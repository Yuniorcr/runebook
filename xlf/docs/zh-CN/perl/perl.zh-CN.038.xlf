<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="dbd5594c7134763067cde3b54f3bfaeaa68b552a" translate="yes" xml:space="preserve">
          <source>If the child process follows the convention of C programs compiled with the _POSIX_EXIT macro set, the status value will contain the actual value of 0 to 255 returned by that program on a normal exit.</source>
          <target state="translated">如果子进程遵循用_POSIX_EXIT宏集编译的C程序的惯例,状态值将包含该程序在正常退出时返回的0到255的实际值。</target>
        </trans-unit>
        <trans-unit id="ba30380d4c3fff1189949a912a23e2f3c323237f" translate="yes" xml:space="preserve">
          <source>If the class shown in &lt;a href=&quot;#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot;&lt;/a&gt; were placed in the MyClass.pm module, then the following code:</source>
          <target state="translated">如果&lt;a href=&quot;#SYNOPSIS&quot;&gt;&amp;ldquo;概要&amp;rdquo;&lt;/a&gt;中显示的类放在MyClass.pm模块中，则下面的代码：</target>
        </trans-unit>
        <trans-unit id="3a2359effbd1215640880aada1292b5fa0877c9a" translate="yes" xml:space="preserve">
          <source>If the class shown in &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; were placed in the MyClass.pm module, then the following code:</source>
          <target state="translated">如果将&lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt;中显示的类放在MyClass.pm模块中，则下面的代码：</target>
        </trans-unit>
        <trans-unit id="2f9ec72ad3a19d5c4b84af5eba887a50b7eef9b5" translate="yes" xml:space="preserve">
          <source>If the client asks for &quot;fr&quot;, that will look up successfully in %greetings, to the value &quot;Bonjour&quot;. And if the client asks for &quot;i-mingo&quot;, that will look up successfully in %greetings, to the value &quot;Hau'&quot;.</source>
          <target state="translated">如果客户问的是 &quot;fr&quot;,将在%greetings中成功查找到 &quot;Bonjour&quot;。如果客户询问 &quot;i-mingo&quot;,则会在%greetings中成功查找到 &quot;Hau'&quot;。</target>
        </trans-unit>
        <trans-unit id="1e012fb4a0052bc107066983e24cd424b0582af0" translate="yes" xml:space="preserve">
          <source>If the code point is unassigned, this returns the block it would belong to if it were assigned. (If the Unicode version being used is so early as to not have blocks, all code points are considered to be in &lt;code&gt;No_Block&lt;/code&gt; .)</source>
          <target state="translated">如果未分配代码点，则返回它在分配时将属于的块。（如果所使用的Unicode版本太早而没有块，则所有代码点都被视为位于 &lt;code&gt;No_Block&lt;/code&gt; 中。）</target>
        </trans-unit>
        <trans-unit id="318dcf1cce3429cb8c9fd8f8fb72e309dc55b11b" translate="yes" xml:space="preserve">
          <source>If the code point is unassigned, this returns the block it would belong to if it were assigned. (If the Unicode version being used is so early as to not have blocks, all code points are considered to be in &lt;code&gt;No_Block&lt;/code&gt;.)</source>
          <target state="translated">如果未分配代码点，则返回它在分配时将属于的块。（如果所使用的Unicode版本太早以至于没有块，则所有代码点都被视为位于 &lt;code&gt;No_Block&lt;/code&gt; 中。）</target>
        </trans-unit>
        <trans-unit id="46675f67eada0291c64ffce7fc8980b9b58c2b77" translate="yes" xml:space="preserve">
          <source>If the code to be executed doesn't vary, you may use the eval-BLOCK form to trap run-time errors without incurring the penalty of recompiling each time. The error, if any, is still returned in &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt;. Examples:</source>
          <target state="translated">如果要执行的代码没有变化，则可以使用eval-BLOCK表单来捕获运行时错误，而不会导致每次重新编译的代价。该错误（如果有）仍在&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;返回。例子：</target>
        </trans-unit>
        <trans-unit id="ced2db748e9e7079888c75fca8f7175caebcea61" translate="yes" xml:space="preserve">
          <source>If the code to be executed doesn't vary, you may use the eval-BLOCK form to trap run-time errors without incurring the penalty of recompiling each time. The error, if any, is still returned in &lt;code&gt;$@&lt;/code&gt; . Examples:</source>
          <target state="translated">如果要执行的代码没有变化，则可以使用eval-BLOCK表单来捕获运行时错误，而不会造成每次重新编译的代价。该错误（如果有）仍在 &lt;code&gt;$@&lt;/code&gt; 返回。例子：</target>
        </trans-unit>
        <trans-unit id="2bd498c74c7384947431c9fbfc4c96437164ae53" translate="yes" xml:space="preserve">
          <source>If the code to execute had been passed in as a string, &lt;code&gt;'$line = &amp;lt;STDIN&amp;gt;'&lt;/code&gt; , there would have been no way for the hypothetical timeout() function to access the lexical variable $line back in its caller's scope.</source>
          <target state="translated">如果要执行的代码已作为字符串 &lt;code&gt;'$line = &amp;lt;STDIN&amp;gt;'&lt;/code&gt; 传入，则假设的timeout（）函数将无法在其调用者的作用域中访问词法变量$ line。</target>
        </trans-unit>
        <trans-unit id="c1827c22ec543702fffafe0a0fe1de8c30879660" translate="yes" xml:space="preserve">
          <source>If the code to execute had been passed in as a string, &lt;code&gt;'$line = &amp;lt;STDIN&amp;gt;'&lt;/code&gt;, there would have been no way for the hypothetical timeout() function to access the lexical variable $line back in its caller's scope.</source>
          <target state="translated">如果要执行的代码已作为字符串 &lt;code&gt;'$line = &amp;lt;STDIN&amp;gt;'&lt;/code&gt; 传入，则假设的timeout（）函数将无法在其调用者的作用域中访问词法变量$ line。</target>
        </trans-unit>
        <trans-unit id="68179989040030e944377fc50f5fa69dee822170" translate="yes" xml:space="preserve">
          <source>If the command works, you can move to the next step, but beware: &lt;b&gt;You'll have to remove the directory from the device once you are done! Unlike &lt;i&gt;/mnt/asec&lt;/i&gt;, &lt;i&gt;/data/local/tmp&lt;/i&gt; may not get automatically garbage collected once you shut off the phone&lt;/b&gt;.</source>
          <target state="translated">如果该命令有效，则可以继续进行下一步，但请注意：完成后，&lt;b&gt;必须从设备中删除目录！与&lt;i&gt;/ mnt / asec&lt;/i&gt;不同，关闭手机后，&lt;i&gt;/ data / local / tmp&lt;/i&gt;可能不会自动收集垃圾&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="9c340c9bb0fb834396be0e28dd3dddd81bf15437" translate="yes" xml:space="preserve">
          <source>If the condition expression of a &lt;code&gt;while&lt;/code&gt; statement is based on any of a group of iterative expression types then it gets some magic treatment. The affected iterative expression types are &lt;a href=&quot;perlfunc#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt;&lt;/a&gt; input operator, &lt;a href=&quot;perlfunc#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#glob-EXPR&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&lt;code&gt;&amp;lt;PATTERN&amp;gt;&lt;/code&gt;&lt;/a&gt; globbing operator, and &lt;a href=&quot;perlfunc#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt;. If the condition expression is one of these expression types, then the value yielded by the iterative operator will be implicitly assigned to &lt;code&gt;$_&lt;/code&gt;. If the condition expression is one of these expression types or an explicit assignment of one of them to a scalar, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="translated">如果 &lt;code&gt;while&lt;/code&gt; 语句的条件表达式基于一组迭代表达式类型中的任何一个，则它将得到一些魔术处理。受影响的迭代表达式类型为&lt;a href=&quot;perlfunc#readline-EXPR&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt; &lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt; &lt;/a&gt;输入运算符，&lt;a href=&quot;perlfunc#readdir-DIRHANDLE&quot;&gt; &lt;code&gt;readdir&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;perlfunc#glob-EXPR&quot;&gt; &lt;code&gt;glob&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt; &lt;code&gt;&amp;lt;PATTERN&amp;gt;&lt;/code&gt; &lt;/a&gt; globlob运算符，以及&lt;a href=&quot;perlfunc#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;。如果条件表达式是这些表达式类型之一，则迭代运算符产生的值将隐式分配给 &lt;code&gt;$_&lt;/code&gt; 。如果条件表达式是这些表达式类型之一，或者是其中一种明确分配给标量，则条件实际上将测试表达式值的定义性，而不是其常规真值。</target>
        </trans-unit>
        <trans-unit id="c5dcda0eb63d695c2273d9f58a5b27fc7e844c60" translate="yes" xml:space="preserve">
          <source>If the configurations variable &lt;code&gt;build_dir_reuse&lt;/code&gt; is set to a true value, then CPAN.pm reads the collected YAML files. If the stored signature matches the currently running perl, the stored state is loaded into memory such that persistence between sessions is effectively established.</source>
          <target state="translated">如果配置变量 &lt;code&gt;build_dir_reuse&lt;/code&gt; 设置为true值，则CPAN.pm读取收集的YAML文件。如果存储的签名与当前正在运行的Perl匹配，则将存储的状态加载到内存中，以便有效地建立会话之间的持久性。</target>
        </trans-unit>
        <trans-unit id="a91d44bc473043f072a494275450d9c876250d17" translate="yes" xml:space="preserve">
          <source>If the connection is via a firewall then the &lt;code&gt;authorize&lt;/code&gt; method will be called with no arguments.</source>
          <target state="translated">如果通过防火墙进行连接，则将不带任何参数调用 &lt;code&gt;authorize&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="880ff18ec98ddcf514d383275dae13c355bbcadf" translate="yes" xml:space="preserve">
          <source>If the construct is a here-doc, the ending delimiter is a line that has a terminating string as the content. Therefore &lt;code&gt;&amp;lt;&amp;lt;EOF&lt;/code&gt; is terminated by &lt;code&gt;EOF&lt;/code&gt; immediately followed by &lt;code&gt;&quot;\n&quot;&lt;/code&gt; and starting from the first column of the terminating line. When searching for the terminating line of a here-doc, nothing is skipped. In other words, lines after the here-doc syntax are compared with the terminating string line by line.</source>
          <target state="translated">如果构造为here-doc，则结束定界符为以终止字符串为内容的行。因此， &lt;code&gt;&amp;lt;&amp;lt;EOF&lt;/code&gt; 由 &lt;code&gt;EOF&lt;/code&gt; 终止，紧随其后的是 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 并从终止行的第一列开始。搜索here-doc的终止行时，不会跳过任何内容。换句话说，here-doc语法之后的行与终止字符串逐行进行比较。</target>
        </trans-unit>
        <trans-unit id="e1f5405c8fb7cef756ea27523f26d6d391697258" translate="yes" xml:space="preserve">
          <source>If the constructor fails undef will be returned and an error message will be in $@</source>
          <target state="translated">如果构造函数失败,将返回undef,并在$@中显示错误信息。</target>
        </trans-unit>
        <trans-unit id="fd68f60bc1a46c89ed70417ef132417733df0aab" translate="yes" xml:space="preserve">
          <source>If the constructor fails, it will set &lt;code&gt;$@&lt;/code&gt; to an appropriate error message; this may be from &lt;code&gt;$!&lt;/code&gt; or it may be some other string; not every failure necessarily has an associated &lt;code&gt;errno&lt;/code&gt; value.</source>
          <target state="translated">如果构造函数失败，它将把 &lt;code&gt;$@&lt;/code&gt; 设置为适当的错误消息；这可能是从 &lt;code&gt;$!&lt;/code&gt; 或者可能是其他字符串；并非每个故障都必须具有关联的 &lt;code&gt;errno&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="a03d6a855f28c1f0fcb373d36da3e2b752b1b618" translate="yes" xml:space="preserve">
          <source>If the constructor is only passed a single argument, it is assumed to be a &lt;code&gt;Peer&lt;/code&gt; specification.</source>
          <target state="translated">如果仅向构造函数传递单个参数，则将其视为对 &lt;code&gt;Peer&lt;/code&gt; 规范。</target>
        </trans-unit>
        <trans-unit id="59d6c514d80580b526f459658680b5bcb3039600" translate="yes" xml:space="preserve">
          <source>If the constructor is only passed a single argument, it is assumed to be a &lt;code&gt;PeerAddr&lt;/code&gt; specification.</source>
          <target state="translated">如果仅向构造函数传递单个参数，则将其视为 &lt;code&gt;PeerAddr&lt;/code&gt; 规范。</target>
        </trans-unit>
        <trans-unit id="253c66bbe032a626b97c6e706376db98b636ddae" translate="yes" xml:space="preserve">
          <source>If the constructor is passed a defined but false value for the &lt;code&gt;Blocking&lt;/code&gt; argument then the socket is put into non-blocking mode. When in non-blocking mode, the socket will not be set up by the time the constructor returns, because the underlying &lt;code&gt;connect(2)&lt;/code&gt; syscall would otherwise have to block.</source>
          <target state="translated">如果为构造函数传递了 &lt;code&gt;Blocking&lt;/code&gt; 参数的已定义但错误的值，则套接字将进入非阻塞模式。在非阻塞模式下，构造函数返回时将不会建立套接字，否则底层的 &lt;code&gt;connect(2)&lt;/code&gt; 系统调用将不得不阻塞。</target>
        </trans-unit>
        <trans-unit id="2c1d4da7e238174b01de906293d93c6822b7ffed" translate="yes" xml:space="preserve">
          <source>If the count doesn't impress your friends, then the code might. :-)</source>
          <target state="translated">如果这个数字不能打动你的朋友,那么代码可能会。 :-)</target>
        </trans-unit>
        <trans-unit id="e2812a31f32729d7d8acbab2252b618f1597089e" translate="yes" xml:space="preserve">
          <source>If the current directory is not writable, file is created using modified &lt;code&gt;tmpnam&lt;/code&gt; , so there may be a race condition.</source>
          <target state="translated">如果当前目录不可写，则使用修改后的 &lt;code&gt;tmpnam&lt;/code&gt; 创建文件，因此可能存在竞争情况。</target>
        </trans-unit>
        <trans-unit id="58341845d1b46d579ba494b307ff64132940c287" translate="yes" xml:space="preserve">
          <source>If the current directory is not writable, file is created using modified &lt;code&gt;tmpnam&lt;/code&gt;, so there may be a race condition.</source>
          <target state="translated">如果当前目录不可写，则使用修改后的 &lt;code&gt;tmpnam&lt;/code&gt; 创建文件，因此可能存在竞争条件。</target>
        </trans-unit>
        <trans-unit id="494e23aba89eecf5e12f5237686e230eddf4cf1f" translate="yes" xml:space="preserve">
          <source>If the current tests are considered &quot;TODO&quot; it will return the reason, if any. This reason can come from a &lt;code&gt;$TODO&lt;/code&gt; variable or the last call to &lt;code&gt;todo_start()&lt;/code&gt; .</source>
          <target state="translated">如果当前测试被认为是&amp;ldquo; TODO&amp;rdquo;，它将返回原因（如果有）。该原因可能来自 &lt;code&gt;$TODO&lt;/code&gt; 变量或上一次对 &lt;code&gt;todo_start()&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="33c537a42d68a9fab37456220c53df0c1404714b" translate="yes" xml:space="preserve">
          <source>If the current tests are considered &quot;TODO&quot; it will return the reason, if any. This reason can come from a &lt;code&gt;$TODO&lt;/code&gt; variable or the last call to &lt;code&gt;todo_start()&lt;/code&gt;.</source>
          <target state="translated">如果当前测试被认为是&amp;ldquo; TODO&amp;rdquo;，它将返回原因（如果有）。该原因可能来自 &lt;code&gt;$TODO&lt;/code&gt; 变量或上一次对 &lt;code&gt;todo_start()&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="d07a75af0e09b32f52321893f3368ffdcf3680ce" translate="yes" xml:space="preserve">
          <source>If the data the &lt;code&gt;info&lt;/code&gt; facet needs to convey can be represented as a table then the data may be placed in this attribute in a more raw form for better display. The data must also be represented in the &lt;code&gt;details&lt;/code&gt; attribute for renderers which do not support rendering tables directly.</source>
          <target state="translated">如果 &lt;code&gt;info&lt;/code&gt; 方面需要传达的数据可以表示为表格，则可以将数据以更原始的形式放置在此属性中，以便更好地显示。数据还必须在不直接支持渲染表的渲染器的 &lt;code&gt;details&lt;/code&gt; 属性中表示。</target>
        </trans-unit>
        <trans-unit id="4dc2b173d8d4940a748b9c83e49e0862799d41a0" translate="yes" xml:space="preserve">
          <source>If the debugging output of &lt;code&gt;-D&lt;/code&gt; doesn't help you, it's time to step through perl's execution with a source-level debugger.</source>
          <target state="translated">如果 &lt;code&gt;-D&lt;/code&gt; 的调试输出无法帮助您，那么该使用源代码级调试器逐步执行perl的执行了。</target>
        </trans-unit>
        <trans-unit id="e01dfde61dfe31eebc6c4d98caf34437480ee91e" translate="yes" xml:space="preserve">
          <source>If the default collation sequence is used, and the BASE is less than or equal to 36, the letter case in STR is ignored.</source>
          <target state="translated">如果使用默认的整理序列,且base小于或等于36,STR中的字母大小写将被忽略。</target>
        </trans-unit>
        <trans-unit id="5d9b61b179e59a5faa76c718b44a80bf30b29231" translate="yes" xml:space="preserve">
          <source>If the deferred-write buffer isn't yet full, but the total size of the buffer and the read cache would exceed the &lt;code&gt;memory&lt;/code&gt; limit, the oldest records will be expired from the read cache until the total size is under the limit.</source>
          <target state="translated">如果延迟写入缓冲区尚未满，但是缓冲区和读取缓存的总大小将超过 &lt;code&gt;memory&lt;/code&gt; 限制，则最早的记录将从读取缓存中过期，直到总大小低于限制。</target>
        </trans-unit>
        <trans-unit id="2d787ba93d433e8611c0010f5b5125e21c2fae5b" translate="yes" xml:space="preserve">
          <source>If the delimiter chosen is a single quote, no interpolation is done on either the</source>
          <target state="translated">如果选择的定界符是一个单引号,则不对以下两个部分进行插值。</target>
        </trans-unit>
        <trans-unit id="938284088206ea35ed759b0277c2738a57db55da" translate="yes" xml:space="preserve">
          <source>If the delimiter chosen is a single quote, no variable interpolation is done on either the</source>
          <target state="translated">如果选择的定界符是一个单引号,则不对以下两个变量插值</target>
        </trans-unit>
        <trans-unit id="fd691ad27529116a3a5593dc1f80d4b01d408999" translate="yes" xml:space="preserve">
          <source>If the destination (second argument) already exists and is a directory, and the source (first argument) is not a filehandle, then the source file will be copied into the directory specified by the destination, using the same base name as the source file. It's a failure to have a filehandle as the source when the destination is a directory.</source>
          <target state="translated">如果目标(第二个参数)已经存在并且是一个目录,而源(第一个参数)不是filehandle,那么源文件将被复制到目标指定的目录中,使用与源文件相同的基名。当目标是目录时,以filehandle作为源文件是失败的。</target>
        </trans-unit>
        <trans-unit id="bf967ef029273cc2d212ca164cc9a8a6a20b4430" translate="yes" xml:space="preserve">
          <source>If the element type does not start with a &lt;code&gt;'*'&lt;/code&gt; , the accessor returns the element value (after assignment). If the element type starts with a &lt;code&gt;'*'&lt;/code&gt; , a reference to the element itself is returned.</source>
          <target state="translated">如果元素类型不是以 &lt;code&gt;'*'&lt;/code&gt; 开头，则访问器将返回元素值（分配后）。如果元素类型以 &lt;code&gt;'*'&lt;/code&gt; 开头，则返回对元素本身的引用。</target>
        </trans-unit>
        <trans-unit id="087f6b4ba4b4848e4cef927f8a6659e4cd63651c" translate="yes" xml:space="preserve">
          <source>If the element type does not start with a &lt;code&gt;'*'&lt;/code&gt;, the accessor returns the element value (after assignment). If the element type starts with a &lt;code&gt;'*'&lt;/code&gt;, a reference to the element itself is returned.</source>
          <target state="translated">如果元素类型不是以 &lt;code&gt;'*'&lt;/code&gt; 开头，则访问器将返回元素值（分配后）。如果元素类型以 &lt;code&gt;'*'&lt;/code&gt; 开头，则返回对元素本身的引用。</target>
        </trans-unit>
        <trans-unit id="4e23930732591461e14ec21d8b1f90dcd530ad74" translate="yes" xml:space="preserve">
          <source>If the element type is &lt;code&gt;'$'&lt;/code&gt; , the value of the element (after assignment) is returned. If the element type is &lt;code&gt;'*$'&lt;/code&gt; , a reference to the element is returned.</source>
          <target state="translated">如果元素类型为 &lt;code&gt;'$'&lt;/code&gt; ，则返回元素的值（赋值后）。如果元素类型为 &lt;code&gt;'*$'&lt;/code&gt; ，则返回对该元素的引用。</target>
        </trans-unit>
        <trans-unit id="416316907f2cce96ccc209eeb130ba72299c8e3b" translate="yes" xml:space="preserve">
          <source>If the element type is &lt;code&gt;'$'&lt;/code&gt;, the value of the element (after assignment) is returned. If the element type is &lt;code&gt;'*$'&lt;/code&gt;, a reference to the element is returned.</source>
          <target state="translated">如果元素类型为 &lt;code&gt;'$'&lt;/code&gt; ，则返回元素的值（赋值后）。如果元素类型为 &lt;code&gt;'*$'&lt;/code&gt; ，则返回对该元素的引用。</target>
        </trans-unit>
        <trans-unit id="1bac597df37b35f3a7dd05dd8ec187e68ab2f23b" translate="yes" xml:space="preserve">
          <source>If the empty regex &lt;code&gt;//&lt;/code&gt; is used, the string is split into individual characters. If the regex has groupings, then the list produced contains the matched substrings from the groupings as well:</source>
          <target state="translated">如果使用空的正则表达式 &lt;code&gt;//&lt;/code&gt; ，则将字符串拆分为单个字符。如果正则表达式具有分组，那么生成的列表也将包含来自分组的匹配子字符串：</target>
        </trans-unit>
        <trans-unit id="8e04e07bd20c824f00e23be10a97b35d7d8bdaf8" translate="yes" xml:space="preserve">
          <source>If the empty regexp &lt;code&gt;//&lt;/code&gt; is used, the regexp always matches and the string is split into individual characters. If the regexp has groupings, then the resulting list contains the matched substrings from the groupings as well. For instance,</source>
          <target state="translated">如果使用了空的regexp &lt;code&gt;//&lt;/code&gt; ，则regexp总是匹配，并且字符串被拆分为单个字符。如果正则表达式具有分组，则结果列表也将包含来自分组的匹配子字符串。例如，</target>
        </trans-unit>
        <trans-unit id="9160efcd7b61ecdb5eab89bb5f1048b8690bd897" translate="yes" xml:space="preserve">
          <source>If the entereval op is permitted then the code can use eval &quot;...&quot; to 'hide' code which might use denied ops. This is not a major problem since when the code tries to execute the eval it will fail because the opmask is still in effect. However this technique would allow clever, and possibly harmful, code to 'probe' the boundaries of what is possible.</source>
          <target state="translated">如果entereval操作是允许的,那么代码可以使用eval&quot;...&quot;来 &quot;隐藏 &quot;可能使用拒绝的操作的代码。这不是一个大问题,因为当代码试图执行eval时,它会失败,因为odmask仍然有效。然而,这种技术将允许聪明的,可能是有害的代码来 &quot;探测 &quot;可能的边界。</target>
        </trans-unit>
        <trans-unit id="a6dd91d8fc44e261add22f788040f3b0d9653b9a" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;code&gt;PERL_TEST_HARNESS_DUMP_TAP&lt;/code&gt; is defined it should name a directory into which a copy of the raw TAP for each test will be written. TAP is written to files named for each test. Subdirectories will be created as needed.</source>
          <target state="translated">如果定义了环境变量 &lt;code&gt;PERL_TEST_HARNESS_DUMP_TAP&lt;/code&gt; ，则应命名一个目录，其中将写入每个测试的原始TAP的副本。TAP将写入每个测试命名的文件中。将根据需要创建子目录。</target>
        </trans-unit>
        <trans-unit id="1677cef1b7d08b33d16cc5ab5e637dae11805c4b" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;code&gt;SSL_CERT_FILE&lt;/code&gt; is present, HTTP::Tiny will try to find a CA certificate file in that location.</source>
          <target state="translated">如果存在环境变量 &lt;code&gt;SSL_CERT_FILE&lt;/code&gt; ，则HTTP :: Tiny将尝试在该位置查找CA证书文件。</target>
        </trans-unit>
        <trans-unit id="85e9e60a253e04ba9480e07ca8d4f04ff80b74d6" translate="yes" xml:space="preserve">
          <source>If the event is a final subtest event, this should contain the subtest ID.</source>
          <target state="translated">如果事件是最终的子测试事件,则应包含子测试ID。</target>
        </trans-unit>
        <trans-unit id="2d65844b53fa3e967e642960ca12717bb316d545" translate="yes" xml:space="preserve">
          <source>If the event is inside a subtest this should have the subtest ID.</source>
          <target state="translated">如果事件是在一个子测试里面,这个事件应该有子测试的ID。</target>
        </trans-unit>
        <trans-unit id="9e66c1c6198ecf06cc2142e9e5e1dd957bf8c18d" translate="yes" xml:space="preserve">
          <source>If the executable called by system()/exec()/pipe-open()/&lt;code&gt;``&lt;/code&gt; is a script with the &quot;magic&quot; &lt;code&gt;#!&lt;/code&gt; line or &lt;code&gt;extproc&lt;/code&gt; line which specifies shell;</source>
          <target state="translated">如果system（）/ exec（）/ pipe-open（）/ &lt;code&gt;``&lt;/code&gt; 调用的可执行文件是带有&amp;ldquo; magic&amp;rdquo; &lt;code&gt;#!&lt;/code&gt; 的脚本！指定shell的行或 &lt;code&gt;extproc&lt;/code&gt; 行；</target>
        </trans-unit>
        <trans-unit id="2a754fbd5a5705920e61152dd8c6911b9ca9d965" translate="yes" xml:space="preserve">
          <source>If the executable called by system()/exec()/pipe-open()/&lt;code&gt;``&lt;/code&gt; is a script without &quot;magic&quot; line, and &lt;code&gt;$ENV{EXECSHELL}&lt;/code&gt; is set to shell;</source>
          <target state="translated">如果可执行的系统（）/执行exec（）/管道的open（）称为/ &lt;code&gt;``&lt;/code&gt; 是一个脚本没有&amp;ldquo;神奇&amp;rdquo;行， &lt;code&gt;$ENV{EXECSHELL}&lt;/code&gt; 设置为壳;</target>
        </trans-unit>
        <trans-unit id="6143c4a0521be912f40be9869aedf7b75cf3c5aa" translate="yes" xml:space="preserve">
          <source>If the executable called by system()/exec()/pipe-open()/&lt;code&gt;``&lt;/code&gt; is not found (is not this remark obsolete?);</source>
          <target state="translated">如果找不到由system（）/ exec（）/ pipe-open（）/ &lt;code&gt;``&lt;/code&gt; 调用的可执行文件（此标记是否已过时？）;</target>
        </trans-unit>
        <trans-unit id="50b9d8b532d25e89b151dc2833716077761d9468" translate="yes" xml:space="preserve">
          <source>If the exit status used is less than 2, then output is printed on &lt;code&gt;STDOUT&lt;/code&gt; . Otherwise output is printed on &lt;code&gt;STDERR&lt;/code&gt; .</source>
          <target state="translated">如果使用的退出状态小于2，则在 &lt;code&gt;STDOUT&lt;/code&gt; 上打印输出。否则，输出将打印在 &lt;code&gt;STDERR&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="e6254e53f84fb9e366ade9a7d71888f7244075a2" translate="yes" xml:space="preserve">
          <source>If the exit status used is less than 2, then output is printed on &lt;code&gt;STDOUT&lt;/code&gt;. Otherwise output is printed on &lt;code&gt;STDERR&lt;/code&gt;.</source>
          <target state="translated">如果使用的退出状态小于2，则在 &lt;code&gt;STDOUT&lt;/code&gt; 上打印输出。否则，输出将打印在 &lt;code&gt;STDERR&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="48f5e0e5ea6330c7048648eb2edf1ad4ccc05a55" translate="yes" xml:space="preserve">
          <source>If the experimental &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; . This indicates that the caller is expecting numeric behaviour. The fourth argument will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, as that position (&lt;code&gt;$_[3]&lt;/code&gt; ) is reserved for use by &lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt;.</source>
          <target state="translated">如果启用了实验性的&amp;ldquo;按位&amp;rdquo;功能（请参见&lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;），则将第五个TRUE参数传递给处理 &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; 的子例程。， &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; 。这表明呼叫者正在期待数字行为。第四个参数将是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，因为该位置（ &lt;code&gt;$_[3]&lt;/code&gt; ）保留供&lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt;使用。</target>
        </trans-unit>
        <trans-unit id="8d70ab84f3a316c00496bd0dced7b93acc9fa6af" translate="yes" xml:space="preserve">
          <source>If the experimental &quot;bitwise&quot; feature is enabled via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'bitwise'&lt;/code&gt; , then this operator always treats its operand as numbers. This feature produces a warning unless you also use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings
'experimental::bitwise'&lt;/code&gt; .</source>
          <target state="translated">如果通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'bitwise'&lt;/code&gt; 启用了实验性的&amp;ldquo;按位&amp;rdquo;功能，则此运算符始终将其操作数视为数字。除非您也 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::bitwise'&lt;/code&gt; 使用警告'experimental :: bitwise'，否则此功能会产生警告。</target>
        </trans-unit>
        <trans-unit id="429f3423b67c7b1e2fda19e3e61bde6079c26d75" translate="yes" xml:space="preserve">
          <source>If the experimental &quot;bitwise&quot; feature is enabled via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'bitwise'&lt;/code&gt; , then unary &lt;code&gt;&quot;~&quot;&lt;/code&gt; always treats its argument as a number, and an alternate form of the operator, &lt;code&gt;&quot;~.&quot;&lt;/code&gt; , always treats its argument as a string. So &lt;code&gt;~0&lt;/code&gt; and &lt;code&gt;~&quot;0&quot;&lt;/code&gt; will both give 2**32-1 on 32-bit platforms, whereas &lt;code&gt;~.0&lt;/code&gt; and &lt;code&gt;~.&quot;0&quot;&lt;/code&gt; will both yield &lt;code&gt;&quot;\xff&quot;&lt;/code&gt; . This feature produces a warning unless you use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::bitwise'&lt;/code&gt; .</source>
          <target state="translated">如果通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'bitwise'&lt;/code&gt; 启用了实验性的&amp;ldquo;按位&amp;rdquo;功能，则一元 &lt;code&gt;&quot;~&quot;&lt;/code&gt; 始终将其自变量视为数字，并使用另一种形式的运算符 &lt;code&gt;&quot;~.&quot;&lt;/code&gt; ，始终将其参数视为字符串。所以 &lt;code&gt;~0&lt;/code&gt; 和 &lt;code&gt;~&quot;0&quot;&lt;/code&gt; 将两者得到2 ** 32-1在32位的平台，而 &lt;code&gt;~.0&lt;/code&gt; 和 &lt;code&gt;~.&quot;0&quot;&lt;/code&gt; 将两者收率 &lt;code&gt;&quot;\xff&quot;&lt;/code&gt; 。除非你使用该功能产生警告 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::bitwise'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc923038f738e51827c6486386f676bb16b7db9f" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to a label name, its scope will be resolved dynamically. This allows for computed &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">如果表达式的计算结果为标签名称，则将动态解析其范围。这允许每个FORTRAN计算&lt;a href=&quot;#goto-LABEL&quot;&gt; &lt;code&gt;goto&lt;/code&gt; &lt;/a&gt;，但是如果您要针对可维护性进行优化，则不一定建议这样做：</target>
        </trans-unit>
        <trans-unit id="44c964489535901a948a3b23073f9b9bb3c0a3e6" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to a label name, its scope will be resolved dynamically. This allows for computed &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">如果表达式的计算结果为标签名称，则将动态解析其范围。这允许每个FORTRAN 计算出 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; ，但是如果您要针对可维护性进行优化，则不一定建议这样做：</target>
        </trans-unit>
        <trans-unit id="c0c3c70b730f0e2950f8179af548175b3c6ef32a" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to a label name, its scope will be resolved dynamically. This allows for computed &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">如果表达式的计算结果为标签名称，则将动态解析其范围。这允许每个FORTRAN 计算出 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; ，但是如果您要针对可维护性进行优化，则不一定建议这样做：</target>
        </trans-unit>
        <trans-unit id="3a5f344d7e209018f81b3bb395e41710ea76000e" translate="yes" xml:space="preserve">
          <source>If the extension doesn't contain a &lt;code&gt;*&lt;/code&gt; , then it is appended to the end of the current filename as a suffix. If the extension does contain one or more &lt;code&gt;*&lt;/code&gt; characters, then each &lt;code&gt;*&lt;/code&gt; is replaced with the current filename. In Perl terms, you could think of this as:</source>
          <target state="translated">如果扩展名不包含 &lt;code&gt;*&lt;/code&gt; ，那么它将作为后缀附加到当前文件名的末尾。如果扩展名确实包含一个或多个 &lt;code&gt;*&lt;/code&gt; 字符，则每个 &lt;code&gt;*&lt;/code&gt; 将被替换为当前文件名。用Perl来讲，您可以这样认为：</target>
        </trans-unit>
        <trans-unit id="de01c14a7209a45c44123f6710c3fc14dda93261" translate="yes" xml:space="preserve">
          <source>If the extension doesn't contain a &lt;code&gt;*&lt;/code&gt;, then it is appended to the end of the current filename as a suffix. If the extension does contain one or more &lt;code&gt;*&lt;/code&gt; characters, then each &lt;code&gt;*&lt;/code&gt; is replaced with the current filename. In Perl terms, you could think of this as:</source>
          <target state="translated">如果扩展名不包含 &lt;code&gt;*&lt;/code&gt; ，那么它将作为后缀附加到当前文件名的末尾。如果扩展名确实包含一个或多个 &lt;code&gt;*&lt;/code&gt; 字符，则每个 &lt;code&gt;*&lt;/code&gt; 将被替换为当前文件名。用Perl的话，您可以认为这是：</target>
        </trans-unit>
        <trans-unit id="912122ed04813ef6afa69c21de9ff5d7b9578a1b" translate="yes" xml:space="preserve">
          <source>If the extension links to a library that it builds, set this to the name of the library (see SDBM_File)</source>
          <target state="translated">如果扩展链接到它所构建的库,则将其设置为库的名称(参见SDBM_File)</target>
        </trans-unit>
        <trans-unit id="d3a643174ddd0d9876c30f4ff9ae6dc788ca282c" translate="yes" xml:space="preserve">
          <source>If the extension might need extra libraries, they should be included here. The extension Makefile.PL will take care of checking whether the libraries actually exist and how they should be loaded. The extra libraries should be specified in the form -lm -lposix, etc, just as on the cc command line. By default, the Makefile.PL will search through the library path determined by Configure. That path can be augmented by including arguments of the form &lt;b&gt;-L/another/library/path&lt;/b&gt; in the extra-libraries argument.</source>
          <target state="translated">如果扩展程序可能需要额外的库，则应将其包含在此处。扩展Makefile.PL将负责检查库是否确实存在以及如何加载它们。额外的库应以-lm -lposix等形式指定，就像在cc命令行上一样。默认情况下，Makefile.PL将搜索由Configure确定的库路径。可以通过在Extra-libraries参数中包含&lt;b&gt;-L / another / library / path&lt;/b&gt;形式的参数来扩展该路径。</target>
        </trans-unit>
        <trans-unit id="effa256cfcef0cdd6582a1503da6bdf1fb1d1f9e" translate="yes" xml:space="preserve">
          <source>If the external</source>
          <target state="translated">如果外部</target>
        </trans-unit>
        <trans-unit id="2e204c469081d0ce7742a3d71bcaeedaf9240cda" translate="yes" xml:space="preserve">
          <source>If the extractor fails to match (in the case of a regex extractor), or returns an empty list or an undefined value (in the case of a subroutine extractor), it is assumed to have failed to extract. If none of the extractor subroutines succeeds, then one character is extracted from the start of the text and the extraction subroutines reapplied. Characters which are thus removed are accumulated and eventually become the next field (unless the fourth argument is true, in which case they are discarded).</source>
          <target state="translated">如果提取器未能匹配(在regex提取器的情况下),或返回一个空列表或未定义的值(在子程序提取器的情况下),则认为提取失败。如果没有一个提取子程序成功,那么就从文本的开头提取一个字符,然后重新应用提取子程序。这样被删除的字符会被累积起来,最终成为下一个字段(除非第四个参数为真,在这种情况下,它们会被丢弃)。</target>
        </trans-unit>
        <trans-unit id="17d2c98a680d0b983c00126ba7fbf7037583b89d" translate="yes" xml:space="preserve">
          <source>If the extractor is a hash reference, it must contain exactly one element. The value of that element is one of the above extractor types (subroutine reference, regular expression, or string). The key of that element is the name of a class into which the successful return value of the extractor will be blessed.</source>
          <target state="translated">如果提取器是一个哈希引用,那么它必须正好包含一个元素,这个元素的值是上述提取器类型之一(子程序引用、正则表达式或字符串)。该元素的值是上述提取器类型之一(子程序引用、正则表达式或字符串)。该元素的键是一个类的名称,提取器的成功返回值将被祝福到该类中。</target>
        </trans-unit>
        <trans-unit id="a2187e610c6c9ce986c9ab2bc434fe210c96d6c7" translate="yes" xml:space="preserve">
          <source>If the extractor is a precompiled regular expression or a string, it is matched against the text in a scalar context with a leading '\G' and the gc modifiers enabled. The extracted value is either $1 if that variable is defined after the match, or else the complete match (i.e. $&amp;amp;).</source>
          <target state="translated">如果提取器是预编译的正则表达式或字符串，则将其与标量上下文中的文本匹配，并启用前导'\ G'并启用gc修饰符。如果该变量是在匹配之后定义的，则提取的值要么是$ 1，要么是完整匹配（即$＆）。</target>
        </trans-unit>
        <trans-unit id="8efec72894ea829331e728164da92723ccc10f46" translate="yes" xml:space="preserve">
          <source>If the extractor is a subroutine it is called in a list context and is expected to return a list of a single element, namely the extracted text. It may optionally also return two further arguments: a string representing the text left after extraction (like $' for a pattern match), and a string representing any prefix skipped before the extraction (like $` in a pattern match). Note that this is designed to facilitate the use of other Text::Balanced subroutines with &lt;code&gt;extract_multiple&lt;/code&gt; . Note too that the value returned by an extractor subroutine need not bear any relationship to the corresponding substring of the original text (see examples below).</source>
          <target state="translated">如果提取器是子例程，则在列表上下文中调用该提取器，并期望它返回单个元素的列表，即提取的文本。它也可以选择返回另外两个参数：一个字符串，表示提取后剩余的文本（如$'用于模式匹配），以及一个字符串，表示提取前跳过的任何前缀（如$`在模式匹配中）。请注意，这是为了方便使用带有 &lt;code&gt;extract_multiple&lt;/code&gt; 的其他Text :: Balanced子例程。还要注意，提取器子例程返回的值不必与原始文本的相应子字符串有任何关系（请参见下面的示例）。</target>
        </trans-unit>
        <trans-unit id="91257d19dbe73c3f0115d0e82b54c986793ce4ee" translate="yes" xml:space="preserve">
          <source>If the extractor is a subroutine it is called in a list context and is expected to return a list of a single element, namely the extracted text. It may optionally also return two further arguments: a string representing the text left after extraction (like $' for a pattern match), and a string representing any prefix skipped before the extraction (like $` in a pattern match). Note that this is designed to facilitate the use of other Text::Balanced subroutines with &lt;code&gt;extract_multiple&lt;/code&gt;. Note too that the value returned by an extractor subroutine need not bear any relationship to the corresponding substring of the original text (see examples below).</source>
          <target state="translated">如果提取器是子例程，则在列表上下文中调用该提取器，并期望它返回单个元素的列表，即提取的文本。它也可以选择返回另外两个参数：一个字符串，表示提取后剩余的文本（如$'用于模式匹配），以及一个字符串，表示提取前跳过的任何前缀（如$`在模式匹配中）。请注意，这是为了方便使用带有 &lt;code&gt;extract_multiple&lt;/code&gt; 的其他Text :: Balanced子例程。还要注意，提取器子例程返回的值不必与原始文本的相应子字符串有任何关系（请参见下面的示例）。</target>
        </trans-unit>
        <trans-unit id="a385fcb5d8ca5cfa07426e73b4f41df3b2f355d3" translate="yes" xml:space="preserve">
          <source>If the field contains a numeric value it will be displayed in hex. Zip stored most numbers in little-endian format - the value displayed will have the little-endian encoding removed.</source>
          <target state="translated">如果该字段包含一个数字值,它将以十六进制显示。Zip以小二烯格式存储了大多数数字--显示的值将被删除小二烯编码。</target>
        </trans-unit>
        <trans-unit id="12045367f64a99179f5690e61487afbfd5fe1436" translate="yes" xml:space="preserve">
          <source>If the file begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then it is skipped before processing, and the content of the file is also decoded appropriately starting from perl 5.8.</source>
          <target state="translated">如果文件的开头是UTF-8、UTF-16BE或UTF-16LE字节序标记,那么在处理前就会跳过,而且从perl 5.8开始,文件的内容也会被适当解码。</target>
        </trans-unit>
        <trans-unit id="8a0b45c8a0563151ba3b588e7383417bdd5f8a3d" translate="yes" xml:space="preserve">
          <source>If the file does not exist, &lt;code&gt;cpan&lt;/code&gt; dies.</source>
          <target state="translated">如果该文件不存在，则 &lt;code&gt;cpan&lt;/code&gt; 死亡。</target>
        </trans-unit>
        <trans-unit id="e4293d2972da49b7deee5cbac8e57e93be999a13" translate="yes" xml:space="preserve">
          <source>If the file is a symlink, the file it's pointing to</source>
          <target state="translated">如果文件是一个符号链接,那么它所指向的文件就是</target>
        </trans-unit>
        <trans-unit id="1260f14708b5c4f0e969b3d9b19ac87d75cb1573" translate="yes" xml:space="preserve">
          <source>If the file is pulled in by &lt;code&gt;perl_parse()&lt;/code&gt; , compiled into a newly constructed interpreter, and subsequently cleaned out with &lt;code&gt;perl_destruct()&lt;/code&gt; afterwards, you're shielded from most namespace troubles.</source>
          <target state="translated">如果将文件由 &lt;code&gt;perl_parse()&lt;/code&gt; 放入，编译为新构造的解释器，然后再使用 &lt;code&gt;perl_destruct()&lt;/code&gt; 进行清理，则可以避免大多数命名空间的麻烦。</target>
        </trans-unit>
        <trans-unit id="12e4d1ea92f7af34b6047df7fcc8abb443c9f062" translate="yes" xml:space="preserve">
          <source>If the file is pulled in by &lt;code&gt;perl_parse()&lt;/code&gt;, compiled into a newly constructed interpreter, and subsequently cleaned out with &lt;code&gt;perl_destruct()&lt;/code&gt; afterwards, you're shielded from most namespace troubles.</source>
          <target state="translated">如果将文件由 &lt;code&gt;perl_parse()&lt;/code&gt; 放入，编译为新构造的解释器，然后再使用 &lt;code&gt;perl_destruct()&lt;/code&gt; 进行清理，则可以避免大多数命名空间的麻烦。</target>
        </trans-unit>
        <trans-unit id="0047e959707fe337b2aa331e4b4d29cbdd3ddf49" translate="yes" xml:space="preserve">
          <source>If the file named by FILENAME does not exist and the &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; call creates it (typically because MODE includes the &lt;code&gt;O_CREAT&lt;/code&gt; flag), then the value of PERMS specifies the permissions of the newly created file. If you omit the PERMS argument to &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt;, Perl uses the octal value &lt;code&gt;0666&lt;/code&gt;. These permission values need to be in octal, and are modified by your process's current &lt;a href=&quot;#umask-EXPR&quot;&gt;&lt;code&gt;umask&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果由FILENAME命名的文件不存在，并且&lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;调用创建了该文件（通常是因为MODE包含 &lt;code&gt;O_CREAT&lt;/code&gt; 标志），则PERMS的值指定了新创建的文件的权限。如果您将&lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt; &lt;code&gt;sysopen&lt;/code&gt; &lt;/a&gt;的PERMS参数省略，则Perl使用八进制值 &lt;code&gt;0666&lt;/code&gt; 。这些权限值必须为八进制，并由您进程的当前&lt;a href=&quot;#umask-EXPR&quot;&gt; &lt;code&gt;umask&lt;/code&gt; &lt;/a&gt;进行修改。</target>
        </trans-unit>
        <trans-unit id="972b095c8cf0635710238db90318d20a5a12c4b1" translate="yes" xml:space="preserve">
          <source>If the file named by FILENAME does not exist and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call creates it (typically because MODE includes the &lt;code&gt;O_CREAT&lt;/code&gt; flag), then the value of PERMS specifies the permissions of the newly created file. If you omit the PERMS argument to &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, Perl uses the octal value &lt;code&gt;0666&lt;/code&gt; . These permission values need to be in octal, and are modified by your process's current &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果由FILENAME命名的文件不存在，并且 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 调用创建了该文件（通常是因为MODE包含 &lt;code&gt;O_CREAT&lt;/code&gt; 标志），则PERMS的值将指定新创建文件的权限。如果您将 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 的PERMS参数省略，Perl将使用八进制值 &lt;code&gt;0666&lt;/code&gt; 。这些权限值必须为八进制，并由进程的当前 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 进行修改。</target>
        </trans-unit>
        <trans-unit id="8aa66e9311c9629d0b8c20e950c88829b4d37f7e" translate="yes" xml:space="preserve">
          <source>If the file named by FILENAME does not exist and the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call creates it (typically because MODE includes the &lt;code&gt;O_CREAT&lt;/code&gt; flag), then the value of PERMS specifies the permissions of the newly created file. If you omit the PERMS argument to &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, Perl uses the octal value &lt;code&gt;0666&lt;/code&gt; . These permission values need to be in octal, and are modified by your process's current &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果由FILENAME命名的文件不存在，并且 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 调用创建了该文件（通常是因为MODE包含 &lt;code&gt;O_CREAT&lt;/code&gt; 标志），则PERMS的值将指定新创建文件的权限。如果您将 &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 的PERMS参数省略，Perl将使用八进制值 &lt;code&gt;0666&lt;/code&gt; 。这些权限值必须为八进制，并由进程的当前 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 进行修改。</target>
        </trans-unit>
        <trans-unit id="afca59eeb0296a7f173f43e8587c0ce7c2de1f87" translate="yes" xml:space="preserve">
          <source>If the file specification is already in a valid VMS syntax, it will be passed through unchanged, except that the UTF-8 flag will be cleared since VMS format file specifications are never in UTF-8.</source>
          <target state="translated">如果文件规范已经是有效的VMS语法,那么它将不加改变地通过,只是UTF-8标志将被清除,因为VMS格式的文件规范从来不是UTF-8。</target>
        </trans-unit>
        <trans-unit id="f20f26d4d2cfe896fd9be41e5561303708778051" translate="yes" xml:space="preserve">
          <source>If the file that contains the module begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then it is skipped before processing, and the content of the file is also decoded appropriately starting from perl 5.8.</source>
          <target state="translated">如果包含该模块的文件以UTF-8、UTF-16BE或UTF-16LE字节序标记开头,则在处理前跳过该文件,并从perl 5.8开始对文件内容进行适当解码。</target>
        </trans-unit>
        <trans-unit id="9b9e946eeefcb8ca3ed866d0a22b192157304573" translate="yes" xml:space="preserve">
          <source>If the file to be opened contains binary data instead of text characters, then the &lt;code&gt;MODE&lt;/code&gt; argument to &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is a little different. Instead of specifying the encoding, you tell Perl that your data are in raw bytes.</source>
          <target state="translated">如果要打开的文件包含二进制数据而不是文本字符， &lt;code&gt;MODE&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 的MODE参数稍有不同。您无需指定编码，而是告诉Perl您的数据以原始字节为单位。</target>
        </trans-unit>
        <trans-unit id="b62027d4bfba52954180b6ef864f354108e4a798" translate="yes" xml:space="preserve">
          <source>If the file to be opened contains binary data instead of text characters, then the &lt;code&gt;MODE&lt;/code&gt; argument to &lt;code&gt;open&lt;/code&gt; is a little different. Instead of specifying the encoding, you tell Perl that your data are in raw bytes.</source>
          <target state="translated">如果要打开的文件包含二进制数据而不是文本字符， &lt;code&gt;MODE&lt;/code&gt; &lt;code&gt;open&lt;/code&gt; 的MODE参数稍有不同。您无需指定编码，而是告诉Perl您的数据以原始字节为单位。</target>
        </trans-unit>
        <trans-unit id="ed7727f14d3896e4199132a911f1277a6913be80" translate="yes" xml:space="preserve">
          <source>If the file was loaded via a hook (e.g. a subroutine reference, see &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for a description of these hooks), this hook is by default inserted into &lt;code&gt;%INC&lt;/code&gt; in place of a filename. Note, however, that the hook may have set the &lt;code&gt;%INC&lt;/code&gt; entry by itself to provide some more specific info.</source>
          <target state="translated">如果文件是通过挂钩加载的（例如，子例程引用，请参阅&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;以获取这些挂钩的描述），则默认情况下，此挂钩将插入 &lt;code&gt;%INC&lt;/code&gt; 而不是文件名。但是请注意，该挂钩可能已自行设置了 &lt;code&gt;%INC&lt;/code&gt; 条目以提供一些更具体的信息。</target>
        </trans-unit>
        <trans-unit id="cf52c06965f9e5fc28f2b729df47caf3473ff123" translate="yes" xml:space="preserve">
          <source>If the file was loaded via a hook (e.g. a subroutine reference, see &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt; for a description of these hooks), this hook is by default inserted into &lt;code&gt;%INC&lt;/code&gt; in place of a filename. Note, however, that the hook may have set the &lt;code&gt;%INC&lt;/code&gt; entry by itself to provide some more specific info.</source>
          <target state="translated">如果文件是通过挂钩加载的（例如，子例程引用，请参阅&lt;a href=&quot;perlfunc#require&quot;&gt;perlfunc&lt;/a&gt;中的&amp;ldquo; require&amp;rdquo;以获取这些挂钩的说明），则默认情况下，此挂钩将插入 &lt;code&gt;%INC&lt;/code&gt; 而不是文件名。但是请注意，该挂钩可能已自行设置了 &lt;code&gt;%INC&lt;/code&gt; 条目以提供一些更具体的信息。</target>
        </trans-unit>
        <trans-unit id="cbada7e6f993214c7ee778a69597cde7ab2c7bef" translate="yes" xml:space="preserve">
          <source>If the file was modified and the server response includes a properly formatted &lt;code&gt;Last-Modified&lt;/code&gt; header, the file modification time will be updated accordingly.</source>
          <target state="translated">如果文件被修改，并且服务器响应中包含格式正确的 &lt;code&gt;Last-Modified&lt;/code&gt; 头，则文件修改时间将相应地更新。</target>
        </trans-unit>
        <trans-unit id="1055d8f3bf09e356a8ac90a312ee4c58ffecab8f" translate="yes" xml:space="preserve">
          <source>If the filehandle came from a piped open, &lt;a href=&quot;#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; returns false if one of the other syscalls involved fails or if its program exits with non-zero status. If the only problem was that the program exited non-zero, &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; will be set to &lt;code&gt;0&lt;/code&gt;. Closing a pipe also waits for the process executing on the pipe to exit--in case you wish to look at the output of the pipe afterwards--and implicitly puts the exit status value of that command into &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt;&lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果文件句柄来自管道打开，则如果涉及的其他系统调用之一失败，或者其程序以非零状态退出，则&lt;a href=&quot;#close-FILEHANDLE&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;返回false。如果唯一的问题是程序退出了非零值，则&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;将设置为 &lt;code&gt;0&lt;/code&gt; 。关闭管道还等待管道上执行的进程退出（以防您以后要查看管道的输出），并将该命令的退出状态值隐式地放入&lt;a href=&quot;perlvar#%24%3F&quot;&gt; &lt;code&gt;$?&lt;/code&gt; 中。&lt;/a&gt;和&lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt; &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e74503c754d78c3ba0f9051478f8b0d722c72c1" translate="yes" xml:space="preserve">
          <source>If the filehandle came from a piped open, &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; returns false if one of the other syscalls involved fails or if its program exits with non-zero status. If the only problem was that the program exited non-zero, &lt;code&gt;$!&lt;/code&gt; will be set to &lt;code&gt;0&lt;/code&gt; . Closing a pipe also waits for the process executing on the pipe to exit--in case you wish to look at the output of the pipe afterwards--and implicitly puts the exit status value of that command into &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</source>
          <target state="translated">如果文件句柄来自管道打开，则如果所涉及的其他系统调用之一失败或其程序以非零状态退出，则 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 返回false。如果唯一的问题是程序退出了非零值，则 &lt;code&gt;$!&lt;/code&gt; 将设置为 &lt;code&gt;0&lt;/code&gt; 。关闭管道还需要等待在管道上执行的进程退出（以防您以后要查看管道的输出），并将该命令的退出状态值隐式地放入 &lt;code&gt;$?&lt;/code&gt; 中。和 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a275dda5ca271e5742fe50c27b80a1dea7fadc2a" translate="yes" xml:space="preserve">
          <source>If the filehandle came from a piped open, &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; returns false if one of the other syscalls involved fails or if its program exits with non-zero status. If the only problem was that the program exited non-zero, &lt;code&gt;$!&lt;/code&gt; will be set to &lt;code&gt;0&lt;/code&gt; . Closing a pipe also waits for the process executing on the pipe to exit--in case you wish to look at the output of the pipe afterwards--and implicitly puts the exit status value of that command into &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</source>
          <target state="translated">如果文件句柄来自管道打开，则如果所涉及的其他系统调用之一失败或其程序以非零状态退出，则 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 返回false。如果唯一的问题是程序退出了非零值，则 &lt;code&gt;$!&lt;/code&gt; 将设置为 &lt;code&gt;0&lt;/code&gt; 。关闭管道还需要等待在管道上执行的进程退出（以防您以后要查看管道的输出），并将该命令的退出状态值隐式地放入 &lt;code&gt;$?&lt;/code&gt; 中。和 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fc5e1415bd14e8d1ec6ad1e512653e073ea2d16" translate="yes" xml:space="preserve">
          <source>If the filename supplied contains directory separators (and so is an absolute or relative pathname), and if that file is not found, platforms that append file extensions will do so and try to look for the file with those extensions added, one by one.</source>
          <target state="translated">如果提供的文件名包含目录分隔符(所以是绝对或相对路径名),如果找不到该文件,附加文件扩展名的平台就会这样做,并试图逐一寻找添加了这些扩展名的文件。</target>
        </trans-unit>
        <trans-unit id="8b638dc989817125971a607e8fa00529b2b307c1" translate="yes" xml:space="preserve">
          <source>If the final value specified is not in the sequence that the magical increment would produce, the sequence goes until the next value would be longer than the final value specified.</source>
          <target state="translated">如果指定的最终值不在魔法增量所产生的序列中,则序列将继续进行,直到下一个值比指定的最终值长。</target>
        </trans-unit>
        <trans-unit id="a33c6e16dc7645806ca8dcd82f881fedaded9d02" translate="yes" xml:space="preserve">
          <source>If the final value specified is not in the sequence that the magical increment would produce, the sequence goes until the next value would be longer than the final value specified. If the length of the final string is shorter than the first, the empty list is returned.</source>
          <target state="translated">如果指定的最终值不在魔力增量产生的序列中,则序列一直到下一个比最终值长的值为止。如果最后一个字符串的长度比第一个字符串的长度短,则返回空列表。</target>
        </trans-unit>
        <trans-unit id="d5f8e1e30b780f6553cc08550f9370ae0ed9b97a" translate="yes" xml:space="preserve">
          <source>If the first argument is a reference to an array, the pseudo-hash will be created with keys from that array. If a second argument is supplied, it must also be a reference to an array whose elements will be used as the values. If the second array contains less elements than the first, the trailing elements of the pseudo-hash will not be initialized. This makes it particularly useful for creating a pseudo-hash from subroutine arguments:</source>
          <target state="translated">如果第一个参数是一个数组的引用,那么伪哈希值将用该数组中的键创建。如果提供了第二个参数,它也必须是一个数组的引用,其元素将被用作值。如果第二个数组包含的元素比第一个数组少,伪哈希值的尾部元素将不会被初始化。这使得它对于从子程序参数创建伪哈希值特别有用。</target>
        </trans-unit>
        <trans-unit id="9f235f80bacbd6f2376896bcd2071e6b6ed89634" translate="yes" xml:space="preserve">
          <source>If the first argument is an empty string &quot;&quot; or is a volume name, i.e. matches the pattern /^[^:]+:/, the resulting path is &lt;b&gt;absolute&lt;/b&gt;.</source>
          <target state="translated">如果第一个参数是空字符串&amp;ldquo;&amp;rdquo;或卷名，即匹配模式/ ^ [^：] +：/，则结果路径为&lt;b&gt;absolute&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="89aa8ef2f6a6df7b419aa16ffe18ced8031ac672" translate="yes" xml:space="preserve">
          <source>If the first character after the &lt;b&gt;-M&lt;/b&gt; or &lt;b&gt;-m&lt;/b&gt; is a dash (&lt;b&gt;-&lt;/b&gt;) then the 'use' is replaced with 'no'.</source>
          <target state="translated">如果&lt;b&gt;-M&lt;/b&gt;或&lt;b&gt;-m&lt;/b&gt;之后的第一个字符是破折号（&lt;b&gt;-&lt;/b&gt;），则将'use'替换为'no'。</target>
        </trans-unit>
        <trans-unit id="d6369cd957319ca2b8d2442c19d6fcbc6b24183a" translate="yes" xml:space="preserve">
          <source>If the first character after the &lt;b&gt;-M&lt;/b&gt; or &lt;b&gt;-m&lt;/b&gt; is a dash (&lt;b&gt;-&lt;/b&gt;) then the 'use' is replaced with 'no'. This makes no difference for &lt;b&gt;-m&lt;/b&gt;.</source>
          <target state="translated">如果&lt;b&gt;-M&lt;/b&gt;或&lt;b&gt;-m&lt;/b&gt;之后的第一个字符是破折号（&lt;b&gt;-&lt;/b&gt;），则将'use'替换为'no'。对于&lt;b&gt;-m而言，&lt;/b&gt;这没有区别。</target>
        </trans-unit>
        <trans-unit id="781d0d29a2affd4018c32ec572f1b116a7081027" translate="yes" xml:space="preserve">
          <source>If the first chars of a Perl script are &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; , this line is treated as &lt;code&gt;#!&lt;/code&gt; -line, thus all the switches on this line are processed (twice if script was started via cmd.exe). See &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;DESCRIPTION in perlrun&lt;/a&gt;.</source>
          <target state="translated">如果Perl脚本的第一个字符为 &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; ，则此行将被视为 &lt;code&gt;#!&lt;/code&gt; 。-line，因此将处理此行上的所有开关（如果脚本是通过cmd.exe启动的，则为两次）。请参见&lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;perlrun中的DESCRIPTION&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="581c684b617d92750c5f38a91fda2e5d76163206" translate="yes" xml:space="preserve">
          <source>If the first chars of a Perl script are &lt;code&gt;&quot;extproc &quot;&lt;/code&gt;, this line is treated as &lt;code&gt;#!&lt;/code&gt;-line, thus all the switches on this line are processed (twice if script was started via cmd.exe). See &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;&quot;DESCRIPTION&quot; in perlrun&lt;/a&gt;.</source>
          <target state="translated">如果Perl脚本的第一个字符为 &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; ，则此行将被视为 &lt;code&gt;#!&lt;/code&gt; 。-line，因此将处理此行上的所有开关（如果脚本是通过cmd.exe启动的，则为两次）。请参见&lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;perlrun中的&amp;ldquo; DESCRIPTION&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f46518f452342a5c022fec8e53026c8608f2e02a" translate="yes" xml:space="preserve">
          <source>If the first digit following the backslash is a 0, it's an octal escape.</source>
          <target state="translated">如果反斜杠后面的第一个数字是0,那就是八进制转义。</target>
        </trans-unit>
        <trans-unit id="5675bafb3dc48482ba4a4f320234c0b4d704c9a0" translate="yes" xml:space="preserve">
          <source>If the first element of the return value (&lt;code&gt;success&lt;/code&gt; ) was 0, then some error occurred. This second element is the error message the command you requested exited with, if available. This is generally a pretty printed value of &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$@&lt;/code&gt; . See &lt;code&gt;perldoc perlvar&lt;/code&gt; for details on what they can contain. If the error was a timeout, the &lt;code&gt;error message&lt;/code&gt; will be prefixed with the string &lt;code&gt;IPC::Cmd::TimeOut&lt;/code&gt; , the timeout class.</source>
          <target state="translated">如果返回值的第一个元素（ &lt;code&gt;success&lt;/code&gt; ）为0，则发生一些错误。第二个元素是您请求退出的命令的错误消息（如果有）。通常这是 &lt;code&gt;$?&lt;/code&gt; 的漂亮印刷价值。或 &lt;code&gt;$@&lt;/code&gt; 。有关它们可以包含的内容的详细信息，请参见 &lt;code&gt;perldoc perlvar&lt;/code&gt; 。如果错误是超时，则 &lt;code&gt;error message&lt;/code&gt; 将以字符串 &lt;code&gt;IPC::Cmd::TimeOut&lt;/code&gt; 作为超时类的前缀。</target>
        </trans-unit>
        <trans-unit id="638a2f7fa728eb482819629ddfdf65e5299a089f" translate="yes" xml:space="preserve">
          <source>If the first element of the return value (&lt;code&gt;success&lt;/code&gt;) was 0, then some error occurred. This second element is the error message the command you requested exited with, if available. This is generally a pretty printed value of &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$@&lt;/code&gt;. See &lt;code&gt;perldoc perlvar&lt;/code&gt; for details on what they can contain. If the error was a timeout, the &lt;code&gt;error message&lt;/code&gt; will be prefixed with the string &lt;code&gt;IPC::Cmd::TimeOut&lt;/code&gt;, the timeout class.</source>
          <target state="translated">如果返回值的第一个元素（ &lt;code&gt;success&lt;/code&gt; ）为0，则发生了一些错误。第二个元素是您请求退出的命令的错误消息（如果有）。这通常是 &lt;code&gt;$?&lt;/code&gt; 的漂亮印刷价值。或 &lt;code&gt;$@&lt;/code&gt; 。有关它们可以包含的内容的详细信息，请参见 &lt;code&gt;perldoc perlvar&lt;/code&gt; 。如果错误是超时，则 &lt;code&gt;error message&lt;/code&gt; 将以字符串 &lt;code&gt;IPC::Cmd::TimeOut&lt;/code&gt; 作为超时类的前缀。</target>
        </trans-unit>
        <trans-unit id="6a57fb9b1830952d24356efef9c0744590e7e139" translate="yes" xml:space="preserve">
          <source>If the first item in a bracket group is &quot;*&quot;, it's taken as shorthand for the so commonly called &quot;quant&quot; method. Similarly, if the first item in a bracket group is &quot;#&quot;, it's taken to be shorthand for &quot;numf&quot;.</source>
          <target state="translated">如果括号组中的第一项是 &quot;*&quot;,它就会被当作是通常所说的 &quot;quant &quot;方法的简写。同样,如果括号组中的第一项是 &quot;#&quot;,则作为 &quot;numf &quot;的速记。</target>
        </trans-unit>
        <trans-unit id="1953104edb77654c33631a60ba8219310b08e426" translate="yes" xml:space="preserve">
          <source>If the first item in a bracket group is the empty-string, or &quot;_*&quot; or &quot;_</source>
          <target state="translated">如果括号组中的第一项是空字符串,或&quot;_*&quot;或&quot;_&quot;。</target>
        </trans-unit>
        <trans-unit id="bf6e94a3fad4e68b50306c3295f243e0a73b5811" translate="yes" xml:space="preserve">
          <source>If the first item in a bracket group looks like a method name, then that group is interpreted like this:</source>
          <target state="translated">如果括号组中的第一项看起来像方法名,那么该组的解释是这样的。</target>
        </trans-unit>
        <trans-unit id="ccf14e3215a8aeb1aa87eb4f44052cead882fc98" translate="yes" xml:space="preserve">
          <source>If the first operand has a &quot;nomethod&quot; method then use that.</source>
          <target state="translated">如果第一个操作数有一个 &quot;nomethod &quot;方法,那么就使用该方法。</target>
        </trans-unit>
        <trans-unit id="a0dadbb13895f7c7975effc9602b93ea5e861379" translate="yes" xml:space="preserve">
          <source>If the first operand has declared a subroutine to overload the operator then use that implementation.</source>
          <target state="translated">如果第一个操作数已经声明了一个子程序来重载操作数,那么就使用该实现。</target>
        </trans-unit>
        <trans-unit id="f7ca747166805083d1be553c7e78c86f97bd5b0c" translate="yes" xml:space="preserve">
          <source>If the flag &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; is passed, no warnings are generated, and hence no AV is created.</source>
          <target state="translated">如果传递了标志 &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; ，则不会生成任何警告，因此不会创建任何AV。</target>
        </trans-unit>
        <trans-unit id="63722d831a3c09d59c00e59b75ba5f74f6230f38" translate="yes" xml:space="preserve">
          <source>If the flag is present in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; will delete whitespace from the start of the subject string before it's operated on. What is considered whitespace depends on if the subject is a UTF-8 string and if the &lt;code&gt;RXf_PMf_LOCALE&lt;/code&gt; flag is set.</source>
          <target state="translated">如果该标志存在于 &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; 中,则 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 将在操作主题字符串之前从主题字符串的开头删除空格。空格取决于主题是否为UTF-8字符串以及是否设置了 &lt;code&gt;RXf_PMf_LOCALE&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="69393e8c9a9ff1f7ad6c1d1075c45161dd52ff73" translate="yes" xml:space="preserve">
          <source>If the flag is present in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt;&lt;code&gt;split&lt;/code&gt; will delete whitespace from the start of the subject string before it's operated on. What is considered whitespace depends on if the subject is a UTF-8 string and if the &lt;code&gt;RXf_PMf_LOCALE&lt;/code&gt; flag is set.</source>
          <target state="translated">如果该标志出现在 &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; 中,则 &lt;code&gt;split&lt;/code&gt; 会在对其进行操作之前从主题字符串的开头删除空格。空格取决于主题是否为UTF-8字符串以及是否设置了 &lt;code&gt;RXf_PMf_LOCALE&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="dbc08ae29def75bcb01866771948171d3f78fd50" translate="yes" xml:space="preserve">
          <source>If the function is used across several files, but intended only for Perl's internal use (and this should be the common case), do not export it to the public API. See the discussion about</source>
          <target state="translated">如果该函数在多个文件中使用,但仅用于 Perl 内部使用(这应该是常见的情况),不要将其导出到公共 API 中。参见关于</target>
        </trans-unit>
        <trans-unit id="0cd096b932efa03a9f98d53e47997c47f5475a48" translate="yes" xml:space="preserve">
          <source>If the function is used only inside one source code file, make it static. See the discussion about</source>
          <target state="translated">如果该函数只在一个源代码文件中使用,请将其静态化。参见关于</target>
        </trans-unit>
        <trans-unit id="56833441b11ff81d3798d0015a0f9476e6600637" translate="yes" xml:space="preserve">
          <source>If the function wants to handle the keyword, it first must parse anything following the keyword that is part of the syntax introduced by the keyword. See &lt;a href=&quot;#Lexer-interface&quot;&gt;&quot;Lexer interface&quot;&lt;/a&gt; for details.</source>
          <target state="translated">如果函数要处理关键字，则它首先必须解析关键字后面的所有内容，这是关键字引入的语法的一部分。有关详细信息，请参见&lt;a href=&quot;#Lexer-interface&quot;&gt;&amp;ldquo; Lexer界面&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d809f75a0fec341370456ffe5542097322b23570" translate="yes" xml:space="preserve">
          <source>If the function wants to handle the keyword, it first must parse anything following the keyword that is part of the syntax introduced by the keyword. See &lt;a href=&quot;#Lexer-interface&quot;&gt;Lexer interface&lt;/a&gt; for details.</source>
          <target state="translated">如果函数要处理关键字，则它首先必须解析关键字后面的所有内容，这是关键字引入的语法的一部分。有关详细信息，请参见&lt;a href=&quot;#Lexer-interface&quot;&gt;Lexer界面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4257aa9162577acd082afc2803cd5eba4d35b6a8" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;DESTROY&lt;/b&gt; then the C++ &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; function will be called and &lt;code&gt;THIS&lt;/code&gt; will be given as its parameter. The generated C++ code for</source>
          <target state="translated">如果该函数的名称为&lt;b&gt;DESTROY，&lt;/b&gt;则将调用C ++ &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 函数，并以 &lt;code&gt;THIS&lt;/code&gt; 作为其参数。为生成的C ++代码</target>
        </trans-unit>
        <trans-unit id="2d5573b215565d0881940be9d2690435373f68b6" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;DESTROY&lt;/b&gt; then the C++ &lt;code&gt;delete&lt;/code&gt; function will be called and &lt;code&gt;THIS&lt;/code&gt; will be given as its parameter. The generated C++ code for</source>
          <target state="translated">如果该函数的名称为&lt;b&gt;DESTROY，&lt;/b&gt;则将调用C ++ &lt;code&gt;delete&lt;/code&gt; 函数，并将 &lt;code&gt;THIS&lt;/code&gt; 作为其参数。生成的C ++代码</target>
        </trans-unit>
        <trans-unit id="7a9d5afefb1f72725e3effbcde85fc42f858949b" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;new&lt;/b&gt; then the C++ &lt;code&gt;new&lt;/code&gt; function will be called to create a dynamic C++ object. The XSUB will expect the class name, which will be kept in a variable called &lt;code&gt;CLASS&lt;/code&gt; , to be given as the first argument.</source>
          <target state="translated">如果函数名称为&lt;b&gt;new，&lt;/b&gt;则将调用C ++ &lt;code&gt;new&lt;/code&gt; 函数来创建动态C ++对象。XSUB将期望将类名作为第一个参数给出，该类名将保留在名为 &lt;code&gt;CLASS&lt;/code&gt; 的变量中。</target>
        </trans-unit>
        <trans-unit id="55694f31aaf01067ff0315ab3ecdf0ed7ab87a27" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;new&lt;/b&gt; then the C++ &lt;code&gt;new&lt;/code&gt; function will be called to create a dynamic C++ object. The XSUB will expect the class name, which will be kept in a variable called &lt;code&gt;CLASS&lt;/code&gt;, to be given as the first argument.</source>
          <target state="translated">如果函数名称是&lt;b&gt;new，&lt;/b&gt;则将调用C ++ &lt;code&gt;new&lt;/code&gt; 函数来创建动态C ++对象。XSUB将期望将类名作为第一个参数给出，该类名将保留在名为 &lt;code&gt;CLASS&lt;/code&gt; 的变量中。</target>
        </trans-unit>
        <trans-unit id="6b71bbee27e0cc31a2af0019a27b599b4619d0d9" translate="yes" xml:space="preserve">
          <source>If the generated module were architecture-specific, you could replace &lt;code&gt;$(INST_LIB)&lt;/code&gt; above with &lt;code&gt;$(INST_ARCHLIB)&lt;/code&gt;, although if you locate modules under</source>
          <target state="translated">如果生成的模块是特定于体系结构的，则可以将上面的 &lt;code&gt;$(INST_ARCHLIB)&lt;/code&gt; 替换 &lt;code&gt;$(INST_LIB)&lt;/code&gt; $（INST_ARCHLIB），尽管如果您将模块定位在</target>
        </trans-unit>
        <trans-unit id="cf92d6194fe17b6faa691c083e3aa66b73fd41bc" translate="yes" xml:space="preserve">
          <source>If the given file is a Storable image return a hash describing it. If the file is readable, but not a Storable image return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. If the file does not exist or is unreadable then croak.</source>
          <target state="translated">如果给定文件是可存储映像，则返回描述它的哈希值。如果文件可读，但不存储图像，则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。如果文件不存在或不可读，则发出嘶哑声。</target>
        </trans-unit>
        <trans-unit id="1e8a49ab1a01520f2d7d29b472d08d17beed998e" translate="yes" xml:space="preserve">
          <source>If the given file is a Storable image return a hash describing it. If the file is readable, but not a Storable image return &lt;code&gt;undef&lt;/code&gt;. If the file does not exist or is unreadable then croak.</source>
          <target state="translated">如果给定文件是可存储映像，则返回描述它的哈希值。如果文件可读，但不存储图像，则返回 &lt;code&gt;undef&lt;/code&gt; 。如果文件不存在或不可读，则发出嘶哑声。</target>
        </trans-unit>
        <trans-unit id="6f5f5dfa299a465aa9a0110ad7326e956c843743" translate="yes" xml:space="preserve">
          <source>If the given string is in FCD (&quot;Fast C or D&quot; form; cf. UTN #5), it returns the string without modification; otherwise it returns an FCD string.</source>
          <target state="translated">如果给定的字符串是FCD形式(&quot;快速C或D &quot;形式;参见UTN #5),它将不加修改地返回字符串;否则它将返回一个FCD字符串。</target>
        </trans-unit>
        <trans-unit id="12d092a8012a2b0bc17122d5b49e40f14ceca06d" translate="yes" xml:space="preserve">
          <source>If the global variable $KEEP_ALL is true, the file or directory will not be removed.</source>
          <target state="translated">如果全局变量$KEEP_ALL为真,文件或目录将不会被删除。</target>
        </trans-unit>
        <trans-unit id="cc1c6dee6d24dc894200423540415887a91afb83" translate="yes" xml:space="preserve">
          <source>If the groupings in a regex are nested, &lt;code&gt;$1&lt;/code&gt; gets the group with the leftmost opening parenthesis, &lt;code&gt;$2&lt;/code&gt; the next opening parenthesis, etc. For example, here is a complex regex and the matching variables indicated below it:</source>
          <target state="translated">如果正则表达式中的分组是嵌套的，则 &lt;code&gt;$1&lt;/code&gt; 会得到最左括号的组， &lt;code&gt;$2&lt;/code&gt; 是下一个括号的组，以此类推。例如，这是一个复杂的正则表达式，并在其下方指示了匹配的变量：</target>
        </trans-unit>
        <trans-unit id="9d3242285e88212205a68d263609b12616c56fc8" translate="yes" xml:space="preserve">
          <source>If the groupings in a regexp are nested, &lt;code&gt;$1&lt;/code&gt; gets the group with the leftmost opening parenthesis, &lt;code&gt;$2&lt;/code&gt; the next opening parenthesis,</source>
          <target state="translated">如果嵌套了一个正则表达式中的分组，则 &lt;code&gt;$1&lt;/code&gt; 将获得最左圆括号的组， &lt;code&gt;$2&lt;/code&gt; 将得到下一个圆括号的组，</target>
        </trans-unit>
        <trans-unit id="83b41f5fdfcf62fc4686ef889212a3544a4d2078" translate="yes" xml:space="preserve">
          <source>If the groupings in a regexp are nested, &lt;code&gt;$1&lt;/code&gt; gets the group with the leftmost opening parenthesis, &lt;code&gt;$2&lt;/code&gt; the next opening parenthesis, etc. Here is a regexp with nested groups:</source>
          <target state="translated">如果一个正则表达式中的分组是嵌套的，则 &lt;code&gt;$1&lt;/code&gt; 将得到最左括号的组， &lt;code&gt;$2&lt;/code&gt; 将是下一个括号，等等。这是一个带有嵌套组的正则表达式：</target>
        </trans-unit>
        <trans-unit id="ccea903e5c5ba097dd604b81034d2fccf458d781" translate="yes" xml:space="preserve">
          <source>If the gunzip program encounters a file containing multiple gzip files concatenated together it will automatically uncompress them all. The example below illustrates this behaviour</source>
          <target state="translated">如果 gunzip 程序遇到一个包含多个 gzip 文件的文件,它会自动将它们全部解压。下面的例子说明了这种行为</target>
        </trans-unit>
        <trans-unit id="7672fac594e6a7dd98d2bae0c51d24e5065e39e4" translate="yes" xml:space="preserve">
          <source>If the gzip FEXTRA header field is present it must conform to the sub-field structure as defined in RFC 1952.</source>
          <target state="translated">如果存在gzip FEXTRA头字段,它必须符合RFC 1952中定义的子字段结构。</target>
        </trans-unit>
        <trans-unit id="948511a86fa3a757ed333c1057a05dc236b1ed7b" translate="yes" xml:space="preserve">
          <source>If the gzip header contains a comment field (FCOMMENT) it consists solely of ISO 8859-1 characters plus line-feed.</source>
          <target state="translated">如果gzip头包含注释字段(FCOMMENT),它仅由ISO 8859-1字符加换行组成。</target>
        </trans-unit>
        <trans-unit id="309f2d92f5e86ee4880748347a713d797525d1c3" translate="yes" xml:space="preserve">
          <source>If the gzip header contains a name field (FNAME) it consists solely of ISO 8859-1 characters.</source>
          <target state="translated">如果gzip头包含一个名称字段(FNAME),它只由ISO 8859-1字符组成。</target>
        </trans-unit>
        <trans-unit id="5ae4fed28b97ca4227cf5c00d60d4d6f2110ce60" translate="yes" xml:space="preserve">
          <source>If the hash is tied dispatches through to the SCALAR tied method, otherwise if the hash contains no keys returns 0, otherwise returns a mortal sv containing a string specifying the number of used buckets, followed by a slash, followed by the number of available buckets.</source>
          <target state="translated">如果哈希是绑定的,则派发到SCALAR绑定方法,否则如果哈希不包含键,则返回0,否则返回一个凡是的sv,包含一个字符串,指定使用过的桶的数量,后面是一个斜线,后面是可用桶的数量。</target>
        </trans-unit>
        <trans-unit id="76da98a8a76e4650e3f026f7c68c78b99cc6936b" translate="yes" xml:space="preserve">
          <source>If the hash is very large, you might not want to create a long list of keys. To save some memory, you can grab one key-value pair at a time using &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt;, which returns a pair you haven't seen yet:</source>
          <target state="translated">如果哈希很大，则可能不想创建一长串的键。为了节省一些内存，您可以使用 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; 一次获取一个键-值对，它返回一个尚未出现的对：</target>
        </trans-unit>
        <trans-unit id="80cd0158384418c000a070c2edb04e7bd8c177a8" translate="yes" xml:space="preserve">
          <source>If the hash is very large, you might not want to create a long list of keys. To save some memory, you can grab one key-value pair at a time using &lt;code&gt;each()&lt;/code&gt;, which returns a pair you haven't seen yet:</source>
          <target state="translated">如果哈希值很大，则可能不想创建一长串的键。为了节省一些内存，您可以使用 &lt;code&gt;each()&lt;/code&gt; 一次抓取一个键-值对，它返回一个尚未出现的对：</target>
        </trans-unit>
        <trans-unit id="fdb896d2cffead7d5fc78c0ddc9c3c52939333bc" translate="yes" xml:space="preserve">
          <source>If the hint provided is a subroutine, then &lt;code&gt;autodie&lt;/code&gt; will pass the complete return value to that subroutine. If the hint is any other value, then &lt;code&gt;autodie&lt;/code&gt; will smart-match against the value provided. In Perl 5.8.x there is no smart-match operator, and as such only subroutine hints are supported in these versions.</source>
          <target state="translated">如果提供的提示是子例程，则 &lt;code&gt;autodie&lt;/code&gt; 会将完整的返回值传递给该子例程。如果提示是任何其他值，则 &lt;code&gt;autodie&lt;/code&gt; 将与提供的值进行智能匹配。在Perl 5.8.x中没有智能匹配运算符，因此在这些版本中仅支持子例程提示。</target>
        </trans-unit>
        <trans-unit id="7d353d642decb66a3abbcefcf79e58c99b0ba1e9" translate="yes" xml:space="preserve">
          <source>If the hook is an array reference, its first element must be a subroutine reference. This subroutine is called as above, but the first parameter is the array reference. This lets you indirectly pass arguments to the subroutine.</source>
          <target state="translated">如果钩子是一个数组引用,它的第一个元素必须是一个子程序引用。这个子程序的调用和上面一样,但第一个参数是数组引用。这让你可以间接地将参数传递给子程序。</target>
        </trans-unit>
        <trans-unit id="75efff7a12e92261036612262090b64712859893" translate="yes" xml:space="preserve">
          <source>If the hook is an object, it must provide an &lt;code&gt;INC&lt;/code&gt; method that will be called as above, the first parameter being the object itself. (Note that you must fully qualify the sub's name, as unqualified &lt;code&gt;INC&lt;/code&gt; is always forced into package &lt;code&gt;main&lt;/code&gt;.) Here is a typical code layout:</source>
          <target state="translated">如果钩子是对象，则它必须提供将如上所述被调用的 &lt;code&gt;INC&lt;/code&gt; 方法，第一个参数是对象本身。（请注意，您必须完全限定子名称，因为不合格的 &lt;code&gt;INC&lt;/code&gt; 总是被强制放入包 &lt;code&gt;main&lt;/code&gt; 中。）以下是典型的代码布局：</target>
        </trans-unit>
        <trans-unit id="089781c4ed94b59afd45ade73f63dd3ae0adcf17" translate="yes" xml:space="preserve">
          <source>If the hook is an object, it must provide an INC method that will be called as above, the first parameter being the object itself. (Note that you must fully qualify the sub's name, as unqualified &lt;code&gt;INC&lt;/code&gt; is always forced into package &lt;code&gt;main&lt;/code&gt; .) Here is a typical code layout:</source>
          <target state="translated">如果钩子是对象，则它必须提供将如上所述被调用的INC方法，第一个参数是对象本身。（请注意，您必须完全限定子名称，因为不合格的 &lt;code&gt;INC&lt;/code&gt; 总是被强制放入包 &lt;code&gt;main&lt;/code&gt; 中。）以下是典型的代码布局：</target>
        </trans-unit>
        <trans-unit id="dc5ac6730609a596bd949c3bb5ec01a23d4ffce0" translate="yes" xml:space="preserve">
          <source>If the initial value specified isn't part of a magical increment sequence (that is, a non-empty string matching &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; ), only the initial value will be returned. So the following will only return an alpha:</source>
          <target state="translated">如果指定的初始值不是魔术增量序列的一部分（即，非空字符串匹配 &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; ），则仅初始值会被退回。因此，以下内容将仅返回Alpha：</target>
        </trans-unit>
        <trans-unit id="f20e6769b4c4dc9b5fc71b6e41306b51022683e2" translate="yes" xml:space="preserve">
          <source>If the initial value specified isn't part of a magical increment sequence (that is, a non-empty string matching &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt;), only the initial value will be returned.</source>
          <target state="translated">如果指定的初始值不是魔术增量序列的一部分（即，非空字符串匹配 &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; ），则仅初始值会被退回。</target>
        </trans-unit>
        <trans-unit id="ce1ecd771a78ded6bdca0c84c4a8624d300c4df7" translate="yes" xml:space="preserve">
          <source>If the initialization begins with &lt;code&gt;=&lt;/code&gt; , then it is output in the declaration for the input variable, replacing the initialization supplied by the typemap. If the initialization begins with &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; , then it is performed after all of the input variables have been declared. In the &lt;code&gt;;&lt;/code&gt; case the initialization normally supplied by the typemap is not performed. For the &lt;code&gt;+&lt;/code&gt; case, the declaration for the variable will include the initialization from the typemap. A global variable, &lt;code&gt;%v&lt;/code&gt; , is available for the truly rare case where information from one initialization is needed in another initialization.</source>
          <target state="translated">如果初始化以 &lt;code&gt;=&lt;/code&gt; 开头，那么它将在输入变量的声明中输出，取代了typemap提供的初始化。如果初始化以 &lt;code&gt;;&lt;/code&gt; 或 &lt;code&gt;+&lt;/code&gt; ，然后在声明所有输入变量之后执行。在 &lt;code&gt;;&lt;/code&gt; 如果通常不执行类型映射提供的初始化。对于 &lt;code&gt;+&lt;/code&gt; 情况，变量的声明将包括来自类型映射的初始化。全局变量 &lt;code&gt;%v&lt;/code&gt; 可用于非常罕见的情况，在这种情况下，一次初始化需要来自另一次初始化的信息。</target>
        </trans-unit>
        <trans-unit id="ef3d32f84fa869f08148860d3a1b874f45f05bbf" translate="yes" xml:space="preserve">
          <source>If the initialization begins with &lt;code&gt;=&lt;/code&gt;, then it is output in the declaration for the input variable, replacing the initialization supplied by the typemap. If the initialization begins with &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;, then it is performed after all of the input variables have been declared. In the &lt;code&gt;;&lt;/code&gt; case the initialization normally supplied by the typemap is not performed. For the &lt;code&gt;+&lt;/code&gt; case, the declaration for the variable will include the initialization from the typemap. A global variable, &lt;code&gt;%v&lt;/code&gt;, is available for the truly rare case where information from one initialization is needed in another initialization.</source>
          <target state="translated">如果初始化以 &lt;code&gt;=&lt;/code&gt; 开头，那么它将在输入变量的声明中输出，取代了typemap提供的初始化。如果初始化以 &lt;code&gt;;&lt;/code&gt; 或 &lt;code&gt;+&lt;/code&gt; ，然后在声明所有输入变量后执行。在 &lt;code&gt;;&lt;/code&gt; 如果通常不执行类型映射提供的初始化。对于 &lt;code&gt;+&lt;/code&gt; 情况，变量的声明将包括来自类型映射的初始化。全局变量 &lt;code&gt;%v&lt;/code&gt; 可用于非常罕见的情况，在这种情况下，一次初始化需要来自另一个初始化的信息。</target>
        </trans-unit>
        <trans-unit id="a641a3d375c74024ce1445924cf66af681f41ebd" translate="yes" xml:space="preserve">
          <source>If the input code point's name has more than one synonym, they are returned joined into a single comma-separated string.</source>
          <target state="translated">如果输入代码点的名称有一个以上的同义词,则将它们连接成一个逗号分隔的字符串返回。</target>
        </trans-unit>
        <trans-unit id="9e071ed158601437a7fd928632778e71dc9740aa" translate="yes" xml:space="preserve">
          <source>If the input file/buffer contains multiple compressed data streams, this option will uncompress the whole lot as a single data stream.</source>
          <target state="translated">如果输入文件/缓冲区包含多个压缩数据流,该选项将把整个文件/缓冲区解压缩为一个数据流。</target>
        </trans-unit>
        <trans-unit id="3c582e01c3ed1134227361002db4abc5ef87f0a6" translate="yes" xml:space="preserve">
          <source>If the input is a buffer, &lt;code&gt;trailingData&lt;/code&gt; will return everything from the end of the compressed data stream to the end of the buffer.</source>
          <target state="translated">如果输入是缓冲区，则 &lt;code&gt;trailingData&lt;/code&gt; 将返回从压缩数据流末尾到缓冲区末尾的所有内容。</target>
        </trans-unit>
        <trans-unit id="646ddea5cc7fe42fca7b5f673b48b7968e951a94" translate="yes" xml:space="preserve">
          <source>If the input is a filehandle, &lt;code&gt;trailingData&lt;/code&gt; will return the data that is left in the filehandle input buffer once the end of the compressed data stream has been reached. You can then use the filehandle to read the rest of the input file.</source>
          <target state="translated">如果输入是文件句柄，则在到达压缩数据流的末尾时， &lt;code&gt;trailingData&lt;/code&gt; 将返回文件句柄输入缓冲区中剩余的数据。然后，您可以使用文件句柄读取其余的输入文件。</target>
        </trans-unit>
        <trans-unit id="68ffb2242fbe49d90e0f353510f536b7c97b26ff" translate="yes" xml:space="preserve">
          <source>If the input is a gzip (RFC 1952) data stream, the following will be checked:</source>
          <target state="translated">如果输入的是gzip(RFC 1952)数据流,将检查以下内容。</target>
        </trans-unit>
        <trans-unit id="fbb62e9bad07668939b33bd6b3f35cbd2a29221c" translate="yes" xml:space="preserve">
          <source>If the input is an RFC 1950 data stream, the following will be checked:</source>
          <target state="translated">如果输入是RFC1950数据流,将检查以下内容。</target>
        </trans-unit>
        <trans-unit id="681895bf526e306295ee60c6f4d01df1e2e0e233" translate="yes" xml:space="preserve">
          <source>If the input is being interpreted as UTF-8 and a UTF-8 encoding error is encountered, an exception is generated.</source>
          <target state="translated">如果输入被解释为UTF-8,并且遇到UTF-8编码错误,就会产生一个异常。</target>
        </trans-unit>
        <trans-unit id="3c3ba700c41877fa613cc375e9afc8a49773890d" translate="yes" xml:space="preserve">
          <source>If the input is unknown &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned in scalar context; an empty-list in list context. If the input is known, the number of elements in the list is returned if called in scalar context.</source>
          <target state="translated">如果输入未知，则在标量上下文中返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ；否则，返回0。列表上下文中的空列表。如果输入是已知的，则在标量上下文中调用时，将返回列表中的元素数。</target>
        </trans-unit>
        <trans-unit id="a3761d436a5408df215f967b2c72bd018ebcc47f" translate="yes" xml:space="preserve">
          <source>If the input is unknown &lt;code&gt;undef&lt;/code&gt; is returned in scalar context; an empty-list in list context. If the input is known, the number of elements in the list is returned if called in scalar context.</source>
          <target state="translated">如果输入未知，则在标量上下文中返回 &lt;code&gt;undef&lt;/code&gt; ；否则，返回0。列表上下文中的空列表。如果输入是已知的，则在标量上下文中调用时，将返回列表中的元素数。</target>
        </trans-unit>
        <trans-unit id="a45a90c97d69c88324a18a4a975329202a110a46" translate="yes" xml:space="preserve">
          <source>If the input string is longer than needed, extra characters are ignored.</source>
          <target state="translated">如果输入的字符串比需要的长,多余的字符将被忽略。</target>
        </trans-unit>
        <trans-unit id="daec947152f5e00d64f719376318858935b663a6" translate="yes" xml:space="preserve">
          <source>If the input string is longer than needed, remaining characters are ignored.</source>
          <target state="translated">如果输入的字符串比需要的长,剩余的字符将被忽略。</target>
        </trans-unit>
        <trans-unit id="1a191161ccbd661c7961516bab02ad1f7aadb16a" translate="yes" xml:space="preserve">
          <source>If the interdependence of your &lt;code&gt;BOOT:&lt;/code&gt; section and Perl code is more complicated than this (e.g., the &lt;code&gt;BOOT:&lt;/code&gt; section makes calls to Perl functions which make calls to XSUBs with prototypes), get rid of the &lt;code&gt;BOOT:&lt;/code&gt; section altogether. Replace it with a function &lt;code&gt;onBOOT()&lt;/code&gt; , and call it like this:</source>
          <target state="translated">如果您的 &lt;code&gt;BOOT:&lt;/code&gt; 部分与Perl代码的相互依赖关系比这更复杂（例如， &lt;code&gt;BOOT:&lt;/code&gt; 部分进行对Perl函数的调用，而Perl函数对具有原型的XSUB进行了调用），则完全摆脱 &lt;code&gt;BOOT:&lt;/code&gt; 部分。将其替换为 &lt;code&gt;onBOOT()&lt;/code&gt; 函数，并按以下方式调用它：</target>
        </trans-unit>
        <trans-unit id="baa35ea6f799cdc2c58744681c4a0f8490276128" translate="yes" xml:space="preserve">
          <source>If the interdependence of your &lt;code&gt;BOOT:&lt;/code&gt; section and Perl code is more complicated than this (e.g., the &lt;code&gt;BOOT:&lt;/code&gt; section makes calls to Perl functions which make calls to XSUBs with prototypes), get rid of the &lt;code&gt;BOOT:&lt;/code&gt; section altogether. Replace it with a function &lt;code&gt;onBOOT()&lt;/code&gt;, and call it like this:</source>
          <target state="translated">如果 &lt;code&gt;BOOT:&lt;/code&gt; 部分和Perl代码的相互依赖性比这要复杂得多（例如， &lt;code&gt;BOOT:&lt;/code&gt; 部分进行对Perl函数的调用，而Perl函数对具有原型的XSUB进行了调用），则完全摆脱 &lt;code&gt;BOOT:&lt;/code&gt; 部分。将其替换为 &lt;code&gt;onBOOT()&lt;/code&gt; 函数，并按以下方式调用它：</target>
        </trans-unit>
        <trans-unit id="2909f2e071daf0b882a5795cb2264aafaf8e4b0b" translate="yes" xml:space="preserve">
          <source>If the interpreter's &lt;code&gt;PL_exit_flags&lt;/code&gt; word has the &lt;code&gt;PERL_EXIT_DESTRUCT_END&lt;/code&gt; flag set, then this function will execute code in &lt;code&gt;END&lt;/code&gt; blocks before performing the rest of destruction. If it is desired to make any use of the interpreter between &lt;a href=&quot;#perl_parse&quot;&gt;&quot;perl_parse&quot;&lt;/a&gt; and &lt;a href=&quot;#perl_destruct&quot;&gt;&quot;perl_destruct&quot;&lt;/a&gt; other than just calling &lt;a href=&quot;#perl_run&quot;&gt;&quot;perl_run&quot;&lt;/a&gt;, then this flag should be set early on. This matters if &lt;a href=&quot;#perl_run&quot;&gt;&quot;perl_run&quot;&lt;/a&gt; will not be called, or if anything else will be done in addition to calling &lt;a href=&quot;#perl_run&quot;&gt;&quot;perl_run&quot;&lt;/a&gt;.</source>
          <target state="translated">如果解释器的 &lt;code&gt;PL_exit_flags&lt;/code&gt; 字设置了 &lt;code&gt;PERL_EXIT_DESTRUCT_END&lt;/code&gt; 标志，则此函数将在执行其余销毁操作之前在 &lt;code&gt;END&lt;/code&gt; 块中执行代码。如果除了调用&lt;a href=&quot;#perl_run&quot;&gt;&amp;ldquo; perl_run&amp;rdquo;之外&lt;/a&gt;，还希望在&lt;a href=&quot;#perl_parse&quot;&gt;&amp;ldquo; perl_parse&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;#perl_destruct&quot;&gt;&amp;ldquo; perl_destruct&amp;rdquo;&lt;/a&gt;之间使用解释器，则应在早期设置此标志。如果不调用&lt;a href=&quot;#perl_run&quot;&gt;&amp;ldquo; perl_run&amp;rdquo;&lt;/a&gt;，或者除了调用&lt;a href=&quot;#perl_run&quot;&gt;&amp;ldquo; perl_run&amp;rdquo;&lt;/a&gt;之外，还要执行其他任何操作，这一点很重要。</target>
        </trans-unit>
        <trans-unit id="fd4475a90b24f7b1ba4a7b6ea113603191eff994" translate="yes" xml:space="preserve">
          <source>If the kernel set-id script feature isn't disabled, then any set-id script provides an exploitable vulnerability. Perl can't avoid being exploitable, but will point out vulnerable scripts where it can. If Perl detects that it is being applied to a set-id script then it will complain loudly that your set-id script is insecure, and won't run it. When Perl complains, you need to remove the set-id bit from the script to eliminate the vulnerability. Refusing to run the script doesn't in itself close the vulnerability; it is just Perl's way of encouraging you to do this.</source>
          <target state="translated">如果内核的set-id脚本功能没有被禁用,那么任何set-id脚本都会提供一个可利用的漏洞。Perl无法避免被利用,但会在可以的情况下指出脆弱的脚本。如果Perl检测到它被应用于set-id脚本,那么它会大声抱怨你的set-id脚本不安全,并且不会运行它。当Perl抱怨时,你需要从脚本中删除set-id位来消除漏洞。拒绝运行脚本本身并不能消除漏洞,这只是Perl鼓励你这么做的方式。</target>
        </trans-unit>
        <trans-unit id="3e4a966e522ce068cba366c74c39330ba735c481" translate="yes" xml:space="preserve">
          <source>If the key does not exist the method returns 1.</source>
          <target state="translated">如果键不存在,该方法返回1。</target>
        </trans-unit>
        <trans-unit id="f85edef10f25d12c44c4dedc4c6946807ec9d900" translate="yes" xml:space="preserve">
          <source>If the label equals '-', then Concise will treat the bit as a raw bit and not try to display it symbolically.</source>
          <target state="translated">如果标签等于'-',那么Concise将把位作为一个原始位来处理,而不会尝试以符号方式显示。</target>
        </trans-unit>
        <trans-unit id="f74ad7c032adb69e8741c3ce089dbedf2af387c8" translate="yes" xml:space="preserve">
          <source>If the language handle has a &quot;fail&quot; attribute whose value is a coderef, then $lh-&amp;gt;maketext(</source>
          <target state="translated">如果语言句柄具有值为&amp;ldquo; coderef&amp;rdquo;的&amp;ldquo; fail&amp;rdquo;属性，则$ lh-&amp;gt; maketext（</target>
        </trans-unit>
        <trans-unit id="74b0a2c233bae54a5a0a22d4c6904ecf217ffcc9" translate="yes" xml:space="preserve">
          <source>If the language handle has no &quot;fail&quot; attribute, maketext will simply throw an exception (i.e., it calls &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, mentioning the</source>
          <target state="translated">如果语言句柄没有&amp;ldquo; fail&amp;rdquo;属性，则maketext只会抛出一个异常（即，它调用 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，提到</target>
        </trans-unit>
        <trans-unit id="ed178838d46c1e8b7a50a0bfb02973479dc8e58f" translate="yes" xml:space="preserve">
          <source>If the language handle has no &quot;fail&quot; attribute, maketext will simply throw an exception (i.e., it calls &lt;code&gt;die&lt;/code&gt;, mentioning the</source>
          <target state="translated">如果语言句柄没有&amp;ldquo; fail&amp;rdquo;属性，则maketext只会抛出一个异常（即，它调用 &lt;code&gt;die&lt;/code&gt; ，并提及</target>
        </trans-unit>
        <trans-unit id="f4c30b1f2ee79d6c9f16717998b6ca5cb7a43494" translate="yes" xml:space="preserve">
          <source>If the last definition is removed, then the DOS device name is also deleted.</source>
          <target state="translated">如果删除了最后一个定义,那么DOS设备名称也会被删除。</target>
        </trans-unit>
        <trans-unit id="11f576169bf47c87f2f0af12c0e2e1a4146c280c" translate="yes" xml:space="preserve">
          <source>If the last element of LIST does not end in a newline, the current script line number and input line number (if any) are also printed, and a newline is supplied. Note that the &quot;input line number&quot; (also known as &quot;chunk&quot;) is subject to whatever notion of &quot;line&quot; happens to be currently in effect, and is also available as the special variable &lt;code&gt;$.&lt;/code&gt; . See &lt;a href=&quot;../perlvar#%24%2f&quot;&gt;$/ in perlvar&lt;/a&gt; and &lt;a href=&quot;../perlvar#%24.&quot;&gt;$. in perlvar&lt;/a&gt;.</source>
          <target state="translated">如果LIST的最后一个元素未以换行符结尾，则还将打印当前脚本行号和输入行号（如果有），并提供换行符。请注意，&amp;ldquo;输入行号&amp;rdquo;（也称为&amp;ldquo;块&amp;rdquo;）受当前有效的任何&amp;ldquo;行&amp;rdquo;概念的约束，并且也可以作为特殊变量 &lt;code&gt;$.&lt;/code&gt; 。请参阅&lt;a href=&quot;../perlvar#%24%2f&quot;&gt;$ /在perlvar&lt;/a&gt;和&lt;a href=&quot;../perlvar#%24.&quot;&gt;$。在perlvar中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ddf8780e7e7d9b3df1dc954871c1e6b0c532c31" translate="yes" xml:space="preserve">
          <source>If the last element of LIST does not end in a newline, the current script line number and input line number (if any) are also printed, and a newline is supplied. Note that the &quot;input line number&quot; (also known as &quot;chunk&quot;) is subject to whatever notion of &quot;line&quot; happens to be currently in effect, and is also available as the special variable &lt;code&gt;$.&lt;/code&gt; . See &lt;a href=&quot;perlvar#%24%2f&quot;&gt;$/ in perlvar&lt;/a&gt; and &lt;a href=&quot;perlvar#%24.&quot;&gt;$. in perlvar&lt;/a&gt;.</source>
          <target state="translated">如果LIST的最后一个元素未以换行符结尾，则还将打印当前脚本行号和输入行号（如果有），并提供换行符。请注意，&amp;ldquo;输入行号&amp;rdquo;（也称为&amp;ldquo;块&amp;rdquo;）受当前有效的任何&amp;ldquo;行&amp;rdquo;概念的约束，并且也可以作为特殊变量 &lt;code&gt;$.&lt;/code&gt; 。请参阅&lt;a href=&quot;perlvar#%24%2f&quot;&gt;$ /在perlvar&lt;/a&gt;和&lt;a href=&quot;perlvar#%24.&quot;&gt;$。在perlvar中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65ccdf7ae6afe2d083d0de8afca0765301ad5a3c" translate="yes" xml:space="preserve">
          <source>If the left hand side is neither a package name nor an object, then the method call will cause an error, but see the section on &lt;a href=&quot;#Method-Call-Variations&quot;&gt;&quot;Method Call Variations&quot;&lt;/a&gt; for more nuances.</source>
          <target state="translated">如果左侧既不是程序包名称也不是对象，则该方法调用将导致错误，但是请参见&lt;a href=&quot;#Method-Call-Variations&quot;&gt;&amp;ldquo;方法调用变体&amp;rdquo;&lt;/a&gt;部分以获取更多细微差别。</target>
        </trans-unit>
        <trans-unit id="e90835049bf9dceb2b3128f6e0da3805c87bc497" translate="yes" xml:space="preserve">
          <source>If the left hand side is neither a package name nor an object, then the method call will cause an error, but see the section on &lt;a href=&quot;#Method-Call-Variations&quot;&gt;Method Call Variations&lt;/a&gt; for more nuances.</source>
          <target state="translated">如果左侧既不是程序包名称也不是对象，则方法调用将导致错误，但是请参见&amp;ldquo; &lt;a href=&quot;#Method-Call-Variations&quot;&gt;方法调用变体&lt;/a&gt; &amp;rdquo;部分以获取更多细微差别。</target>
        </trans-unit>
        <trans-unit id="37bacecd2332508665ec81733fbdffa749ac5bfa" translate="yes" xml:space="preserve">
          <source>If the length of the input string is not even, it behaves as if padded by a null character at the end. Similarly, &quot;extra&quot; nybbles are ignored during unpacking.</source>
          <target state="translated">如果输入字符串的长度不是偶数,它的行为就像在末尾填充了一个空字符一样。同样,&quot;额外的 &quot;nybbles在解包过程中会被忽略。</target>
        </trans-unit>
        <trans-unit id="88b7864a27a0577ffff54b7d555aea0617e9d505" translate="yes" xml:space="preserve">
          <source>If the length of the input string is not evenly divisible by 8, the remainder is packed as if the input string were padded by null characters at the end. Similarly during unpacking, &quot;extra&quot; bits are ignored.</source>
          <target state="translated">如果输入字符串的长度不能被8整除,那么剩余的部分就会被打包,就像输入字符串的末尾被空字符填充一样。同样,在解包过程中,&quot;额外 &quot;位将被忽略。</target>
        </trans-unit>
        <trans-unit id="a2e67d3ea522ed96fe7a9c8431714f7f3d0ba5c5" translate="yes" xml:space="preserve">
          <source>If the library happens to be in a location not in &lt;code&gt;$Config{libpth}&lt;/code&gt; , you need:</source>
          <target state="translated">如果该库恰好不在 &lt;code&gt;$Config{libpth}&lt;/code&gt; ，则需要：</target>
        </trans-unit>
        <trans-unit id="c256d5d027a4accdcc167669a7812e5bf777ccbe" translate="yes" xml:space="preserve">
          <source>If the library happens to be in a location not in &lt;code&gt;$Config{libpth}&lt;/code&gt;, you need:</source>
          <target state="translated">如果该库恰好不在 &lt;code&gt;$Config{libpth}&lt;/code&gt; ，则需要：</target>
        </trans-unit>
        <trans-unit id="96118a855a2f1b2515701521249ef16334052e1f" translate="yes" xml:space="preserve">
          <source>If the line number is &lt;code&gt;.&lt;/code&gt;, sets a breakpoint on the current line:</source>
          <target state="translated">如果行号是 &lt;code&gt;.&lt;/code&gt; ，在当前行上设置一个断点：</target>
        </trans-unit>
        <trans-unit id="94650250941df693d5a68b4ac245a935f3b9c2e5" translate="yes" xml:space="preserve">
          <source>If the list moderators tell you that you are not being civil, carefully consider how your words have appeared before responding in any way. Were they kind? You may protest, but repeated protest in the face of a repeatedly reaffirmed decision is not acceptable. Repeatedly protesting about the moderators' decisions regarding a third party is also unacceptable, as is continuing to initiate off-list contact with the moderators about their decisions.</source>
          <target state="translated">如果列表版主告诉你,你不文明,在以任何方式回应之前,请仔细考虑你的话是如何出现的。他们是善良的吗?你可以抗议,但面对反复重申的决定,反复抗议是不能接受的。反复抗议版主对第三方的决定也是不可接受的,继续就版主的决定主动与版主进行非列表联系也是不可接受的。</target>
        </trans-unit>
        <trans-unit id="f93c03970a56584f9fb61994432bc17cb7db5f12" translate="yes" xml:space="preserve">
          <source>If the list moderators tell you that you are not being civil, carefully consider how your words have appeared before responding in any way. You may protest, but repeated protest in the face of a repeatedly reaffirmed decision is not acceptable.</source>
          <target state="translated">如果列表版主告诉你,你不文明,在以任何方式回应之前,请仔细考虑你的话是如何出现的。你可以抗议,但面对一再重申的决定,反复抗议是不可接受的。</target>
        </trans-unit>
        <trans-unit id="e0a9f58b026642b9c9e8e7bb8deab3007d5236f6" translate="yes" xml:space="preserve">
          <source>If the locale from the user's environment is desired, there should be no need for XS code to set the locale except for &lt;code&gt;LC_NUMERIC&lt;/code&gt; , as perl has already set it up. XS code should avoid changing the locale, as it can adversely affect other, unrelated, code and may not be thread safe. However, some alien libraries that may be called do set it, such as &lt;code&gt;Gtk&lt;/code&gt; . This can cause problems for the perl core and other modules. Starting in v5.20.1, calling the function &lt;a href=&quot;perlapi#sync_locale&quot;&gt;sync_locale()&lt;/a&gt; from XS should be sufficient to avoid most of these problems. Prior to this, you need a pure Perl statement that does this:</source>
          <target state="translated">如果需要来自用户环境的语言环境，则除了 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 之外，不需要XS代码来设置语言环境，因为perl已经设置了它。XS代码应避免更改语言环境，因为它可能会对其他不相关的代码产生不利影响，并且可能不是线程安全的。但是，可能会调用某些外来库来设置它，例如 &lt;code&gt;Gtk&lt;/code&gt; 。这可能会导致perl核心和其他模块出现问题。从v5.20.1开始，从XS 调用函数&lt;a href=&quot;perlapi#sync_locale&quot;&gt;sync_locale（）&lt;/a&gt;应该足以避免大多数此类问题。在此之前，您需要执行以下操作的纯Perl语句：</target>
        </trans-unit>
        <trans-unit id="29cc247eadfeb453e1955bad0bbc5ed23022a753" translate="yes" xml:space="preserve">
          <source>If the locale from the user's environment is desired, there should be no need for XS code to set the locale except for &lt;code&gt;LC_NUMERIC&lt;/code&gt;, as perl has already set the others up. XS code should avoid changing the locale, as it can adversely affect other, unrelated, code and may not be thread-safe. To minimize problems, the macros &lt;a href=&quot;perlapi#STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;&quot;STORE_LC_NUMERIC_SET_TO_NEEDED&quot; in perlapi&lt;/a&gt;, &lt;a href=&quot;perlapi#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;&quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot; in perlapi&lt;/a&gt;, and &lt;a href=&quot;perlapi#RESTORE_LC_NUMERIC&quot;&gt;&quot;RESTORE_LC_NUMERIC&quot; in perlapi&lt;/a&gt; should be used to affect any needed change.</source>
          <target state="translated">如果需要来自用户环境的语言环境，则除了 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 之外，不需要XS代码来设置语言环境，因为perl已经设置了其他语言环境。XS代码应避免更改语言环境，因为它可能会对其他不相关的代码产生不利影响，并且可能不是线程安全的。为了最大限度地减少问题，宏&lt;a href=&quot;perlapi#STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;&amp;ldquo;STORE_LC_NUMERIC_SET_TO_NEEDED&amp;rdquo;在负责填实perlapi&lt;/a&gt;，&lt;a href=&quot;perlapi#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;&amp;ldquo;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&amp;rdquo;在负责填实perlapi&lt;/a&gt;和&lt;a href=&quot;perlapi#RESTORE_LC_NUMERIC&quot;&gt;&amp;ldquo;RESTORE_LC_NUMERIC&amp;rdquo;在负责填实perlapi&lt;/a&gt;应该被用来影响任何需要的改变。</target>
        </trans-unit>
        <trans-unit id="4664ee573739492d5623b9369f8faea69d271aa1" translate="yes" xml:space="preserve">
          <source>If the main thread exits while there are detached threads which are still running, then Perl's global destruction phase is not executed because otherwise certain global structures that control the operation of threads and that are allocated in the main thread's memory may get destroyed before the detached thread is destroyed.</source>
          <target state="translated">如果主线程退出时,还有分离的线程还在运行,那么Perl的全局销毁阶段就不会被执行,因为否则某些控制线程运行的全局结构和分配在主线程内存中的结构可能会在分离的线程被销毁之前被销毁。</target>
        </trans-unit>
        <trans-unit id="823e97e3e713d61f96695c0b7d66500ba0535b81" translate="yes" xml:space="preserve">
          <source>If the make process encounters trouble with either compilation or linking then try setting the _C89_CCMODE to 1. Assuming sh is your login shell then run:</source>
          <target state="translated">如果make进程在编译或链接时遇到问题,那么可以尝试将_C89_CCMODE设置为1。假设sh是你的登录shell,然后运行。</target>
        </trans-unit>
        <trans-unit id="fa7d8db26880e3b2b83f69006312ed2e5013aabf" translate="yes" xml:space="preserve">
          <source>If the member name in the zip archive is not valid UTF-8 when this optionn is true, the script will die with an error message.</source>
          <target state="translated">当这个选项为真时,如果压缩包中的成员名不是有效的UTF-8,脚本将以错误信息结束。</target>
        </trans-unit>
        <trans-unit id="0119f182d57e85f55c259aad67e5507f5a71d506" translate="yes" xml:space="preserve">
          <source>If the method is called in scalar context, then it will try to extract exactly</source>
          <target state="translated">如果该方法是在标量上下文中调用的,那么它将尝试准确地提取出</target>
        </trans-unit>
        <trans-unit id="2ae0fed8c834da6c72af01b4cce727e6b5ec751e" translate="yes" xml:space="preserve">
          <source>If the module &lt;code&gt;Module&lt;/code&gt; is already loaded, then the declaration</source>
          <target state="translated">如果模块 &lt;code&gt;Module&lt;/code&gt; 已被加载，则声明</target>
        </trans-unit>
        <trans-unit id="1b3cd9a44d834ecaba373518cdced67ef6882e1c" translate="yes" xml:space="preserve">
          <source>If the module &lt;code&gt;Module&lt;/code&gt; is not loaded yet, then the above declaration declares functions func1() and func2() in the current package. When these functions are called, they load the package &lt;code&gt;Module&lt;/code&gt; if needed, and substitute themselves with the correct definitions.</source>
          <target state="translated">如果尚未加载模块 &lt;code&gt;Module&lt;/code&gt; ，则上述声明在当前包中声明函数func1（）和func2（）。调用这些函数时，它们会在需要时加载程序包 &lt;code&gt;Module&lt;/code&gt; ，并用正确的定义替换它们。</target>
        </trans-unit>
        <trans-unit id="aa83e5ba98e2e00acddd7117050d321e4e9d54d9" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, &lt;code&gt;mark_as_loaded&lt;/code&gt; will carp about this and tell you from where the &lt;code&gt;PACKAGE&lt;/code&gt; has been loaded already.</source>
          <target state="translated">如果模块已经加载， &lt;code&gt;mark_as_loaded&lt;/code&gt; 会对此进行提示，并告诉您 &lt;code&gt;PACKAGE&lt;/code&gt; 从何处加载。</target>
        </trans-unit>
        <trans-unit id="e1cec740a866f3242f2245723f611d8e6a35a17e" translate="yes" xml:space="preserve">
          <source>If the module is already unloaded, &lt;code&gt;mark_as_unloaded&lt;/code&gt; will carp about this and tell you the &lt;code&gt;PACKAGE&lt;/code&gt; has been unloaded already.</source>
          <target state="translated">如果模块已经卸载，则 &lt;code&gt;mark_as_unloaded&lt;/code&gt; 会对此进行提示，并告诉您 &lt;code&gt;PACKAGE&lt;/code&gt; 已经卸载。</target>
        </trans-unit>
        <trans-unit id="55dd2ee6ad71be855cc8cea6dc45014e0de598b9" translate="yes" xml:space="preserve">
          <source>If the module is needed inside the</source>
          <target state="translated">如果该模块是需要内部的</target>
        </trans-unit>
        <trans-unit id="fab3a0f11307492451a39d88e9be980974dcb4d2" translate="yes" xml:space="preserve">
          <source>If the module will only be used inside a thread, you can try loading the module from inside the thread entry point function using &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; if needed):</source>
          <target state="translated">如果模块仅在线程内部使用，则可以尝试使用 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 从线程入口点函数内部加载模块（并在需要时 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="b3aa735bc422b148dd84e6d085642a87f49e47ba" translate="yes" xml:space="preserve">
          <source>If the module will only be used inside a thread, you can try loading the module from inside the thread entry point function using &lt;code&gt;require&lt;/code&gt; (and &lt;code&gt;import&lt;/code&gt; if needed):</source>
          <target state="translated">如果模块仅在线程内部使用，则可以尝试使用 &lt;code&gt;require&lt;/code&gt; 从线程入口点函数内部加载模块（并在需要时 &lt;code&gt;import&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="cc3b3934908dc77b79dcbb0b789e5b838d36463c" translate="yes" xml:space="preserve">
          <source>If the name is given in UTF-8, set this to &lt;code&gt;HVhek_UTF8&lt;/code&gt; . The value is passed direct as the parameter</source>
          <target state="translated">如果名称以UTF-8给出，请将其设置为 &lt;code&gt;HVhek_UTF8&lt;/code&gt; 。该值直接作为参数传递</target>
        </trans-unit>
        <trans-unit id="873d55d8a257eaf7386c02b0cf4a9016781f6d23" translate="yes" xml:space="preserve">
          <source>If the name is given in UTF-8, set this to &lt;code&gt;HVhek_UTF8&lt;/code&gt;. The value is passed direct as the parameter</source>
          <target state="translated">如果名称是以UTF-8给出的，请将其设置为 &lt;code&gt;HVhek_UTF8&lt;/code&gt; 。该值直接作为参数传递</target>
        </trans-unit>
        <trans-unit id="31ddfa3306f944720376a989f9d5fd87c400eb47" translate="yes" xml:space="preserve">
          <source>If the name is omitted, format &quot;STDOUT&quot; is defined. A single &quot;.&quot; in column 1 is used to terminate a format. FORMLIST consists of a sequence of lines, each of which may be one of three types:</source>
          <target state="translated">如果省略名称,则定义格式 &quot;STDOUT&quot;。第1列中的一个&quot;.&quot;用于终止一个格式。FORMLIST由一连串的行组成,每行可以是三种类型之一。</target>
        </trans-unit>
        <trans-unit id="0def4cf3757d0553a2341afef733c2c0849f1052" translate="yes" xml:space="preserve">
          <source>If the name is unknown, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned (or an empty list in list context). Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt; &quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt; . This function does not recognize those in the input, returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. Nor are they included in the output as possible synonyms.</source>
          <target state="translated">如果名称未知，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （或列表上下文中的空列表）。请注意，Perl通常在正则表达式中以前缀可选的 &lt;code&gt;&quot;Is_&lt;/code&gt; _&amp;rdquo;（带或不带下划线）的方式识别正则表达式中的属性名称，例如 &lt;code&gt;\p{isgc=punct}&lt;/code&gt; 。此函数无法识别输入中的那些，返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。它们也没有作为可能的同义词包含在输出中。</target>
        </trans-unit>
        <trans-unit id="88548ac66c76967c7a6bd845c8445fe8da2c6437" translate="yes" xml:space="preserve">
          <source>If the name is unknown, &lt;code&gt;undef&lt;/code&gt; is returned (or an empty list in list context). Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt;&quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt;. This function does not recognize those in the input, returning &lt;code&gt;undef&lt;/code&gt;. Nor are they included in the output as possible synonyms.</source>
          <target state="translated">如果名称未知，则返回 &lt;code&gt;undef&lt;/code&gt; （或列表上下文中的空列表）。请注意，Perl通常在正则表达式中以前缀可选的 &lt;code&gt;&quot;Is_&lt;/code&gt; _&amp;rdquo;（带或不带下划线）的方式识别正则表达式中的属性名称，例如 &lt;code&gt;\p{isgc=punct}&lt;/code&gt; 。此函数无法识别输入中的那些，返回 &lt;code&gt;undef&lt;/code&gt; 。它们也没有作为可能的同义词包含在输出中。</target>
        </trans-unit>
        <trans-unit id="a79bb3cadb8f975e939ef18071a526a4b5d3363e" translate="yes" xml:space="preserve">
          <source>If the named parameter &lt;code&gt;config_override&lt;/code&gt; is specified, it should be a reference to a hash which contains all information usually found in &lt;code&gt;%Config::Config&lt;/code&gt; . For example, you can obtain the configuration information for a separate perl installation and pass that in.</source>
          <target state="translated">如果指定了命名参数 &lt;code&gt;config_override&lt;/code&gt; ，则它应该是对哈希的引用，该哈希包含通常在 &lt;code&gt;%Config::Config&lt;/code&gt; 找到的所有信息。例如，您可以获取单独的perl安装的配置信息并将其传入。</target>
        </trans-unit>
        <trans-unit id="455e39c93d939d0a811460c9e6eb8b61291c4896" translate="yes" xml:space="preserve">
          <source>If the named parameter &lt;code&gt;config_override&lt;/code&gt; is specified, it should be a reference to a hash which contains all information usually found in &lt;code&gt;%Config::Config&lt;/code&gt;. For example, you can obtain the configuration information for a separate perl installation and pass that in.</source>
          <target state="translated">如果指定了命名参数 &lt;code&gt;config_override&lt;/code&gt; ，则它应该是对哈希的引用，该哈希包含通常在 &lt;code&gt;%Config::Config&lt;/code&gt; 找到的所有信息。例如，您可以获取单独的perl安装的配置信息并将其传入。</target>
        </trans-unit>
        <trans-unit id="db3ef5746e8cd5bab310439aa50dba89f545a584" translate="yes" xml:space="preserve">
          <source>If the named parameter &lt;code&gt;skip_cwd&lt;/code&gt; is true, the current directory &lt;code&gt;.&lt;/code&gt; will be stripped from &lt;code&gt;@INC&lt;/code&gt; before searching for .packlists. This keeps ExtUtils::Installed from finding modules installed in other perls that happen to be located below the current directory.</source>
          <target state="translated">如果命名参数 &lt;code&gt;skip_cwd&lt;/code&gt; 为true，则为当前目录 &lt;code&gt;.&lt;/code&gt; 将在搜索.packlists之前从 &lt;code&gt;@INC&lt;/code&gt; 中删除。这样可以避免ExtUtils :: Installed找到其他安装在当前目录下的Perl中的模块。</target>
        </trans-unit>
        <trans-unit id="7f6facbdb87684a56df7a20a0d54e6b8073b8eb9" translate="yes" xml:space="preserve">
          <source>If the new version of the C library is ABI-compatible (that's Application Binary Interface compatible) with the version you're upgrading from, and if the shared library version didn't change, no re-compilation should be necessary.</source>
          <target state="translated">如果新版本的C库与你升级的版本是ABI兼容的(也就是应用二进制接口兼容),而且如果共享库的版本没有改变,就不需要重新编译。</target>
        </trans-unit>
        <trans-unit id="3f6451aaf2bf86188eece8b63b5bab6c7257462f" translate="yes" xml:space="preserve">
          <source>If the next character is in (or extends into) the next chunk of input text, the next chunk will be read in. Normally the current chunk will be discarded at the same time, but if</source>
          <target state="translated">如果下一个字符在下一个输入文本块中(或延伸到下一个文本块中),下一个文本块将被读入。通常,当前的文本块将被同时丢弃,但如果</target>
        </trans-unit>
        <trans-unit id="1f73682ad19692885d11822d4f6d7cb69031b04a" translate="yes" xml:space="preserve">
          <source>If the next character is in (or extends into) the next chunk of input text, the next chunk will be read in. Normally the current chunk will be discarded at the same time, but if &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;LEX_KEEP_PREVIOUS&lt;/code&gt; bit set, then the current chunk will not be discarded.</source>
          <target state="translated">如果下一个字符位于输入文本的下一个块中（或延伸到下一个字符中），则将读取下一个块。通常，当前块将同时被丢弃，但是如果 &lt;code&gt;flags&lt;/code&gt; 的 &lt;code&gt;LEX_KEEP_PREVIOUS&lt;/code&gt; 位置1，则当前块将不会被丢弃。</target>
        </trans-unit>
        <trans-unit id="2a6672795e23362230912b4b8b4e28fb661f0a19" translate="yes" xml:space="preserve">
          <source>If the number consists of digits only, JSON::PP will try to represent it as an integer value. If that fails, it will try to represent it as a numeric (floating point) value if that is possible without loss of precision. Otherwise it will preserve the number as a string value (in which case you lose roundtripping ability, as the JSON number will be re-encoded to a JSON string).</source>
          <target state="translated">如果数字仅由数字组成,JSON::PP将尝试将其表示为一个整数值。如果失败了,它将尝试将其表示为一个数字(浮点)值,如果这是可能的,而不损失精度。否则,它将把数字作为一个字符串值保留下来(在这种情况下,你将失去roundtripping能力,因为JSON数字将被重新编码为JSON字符串)。</target>
        </trans-unit>
        <trans-unit id="bf7862ebb65f1805f38240d9ec3614885b02e6ad" translate="yes" xml:space="preserve">
          <source>If the number following the backslash is N (in decimal), and Perl already has seen N capture groups, Perl considers this a backreference. Otherwise, it considers it an octal escape. If N has more than three digits, Perl takes only the first three for the octal escape; the rest are matched as is.</source>
          <target state="translated">如果反斜线后面的数字是N(十进制),并且Perl已经看到了N个捕获组,那么Perl认为这是一个反推。否则,它认为这是一个八进制转义。如果 N 有三个以上的数字,Perl 只取前三个数字作为八进制转义,其余的则按原样匹配。</target>
        </trans-unit>
        <trans-unit id="fad0df49da49393094ec039045da70fce50b5429" translate="yes" xml:space="preserve">
          <source>If the number of data bytes ($bytes) is given, that many data bytes are included in the ping packet sent to the remote host. The number of data bytes is ignored if the protocol is &quot;tcp&quot;. The minimum (and default) number of data bytes is 1 if the protocol is &quot;udp&quot; and 0 otherwise. The maximum number of data bytes that can be specified is 1024.</source>
          <target state="translated">如果给定了数据字节数($bytes),那么发送到远程主机的ping数据包中就会包含这么多数据字节。如果协议是 &quot;tcp&quot;,数据字节数会被忽略。如果协议是 &quot;udp&quot;,数据字节的最小(默认)数是1,否则是0。可以指定的最大数据字节数是1024。</target>
        </trans-unit>
        <trans-unit id="173b84764a7ba838f6e1039dc98cb544515aa621" translate="yes" xml:space="preserve">
          <source>If the number of data bytes (&lt;code&gt;bytes&lt;/code&gt;) is given, that many data bytes are included in the ping packet sent to the remote host. The number of data bytes is ignored if the protocol is &quot;tcp&quot;. The minimum (and default) number of data bytes is 1 if the protocol is &quot;udp&quot; and 0 otherwise. The maximum number of data bytes that can be specified is 65535, but staying below the MTU (1472 bytes for ICMP) is recommended. Many small devices cannot deal with fragmented ICMP packets.</source>
          <target state="translated">如果给出了数据字节数（ &lt;code&gt;bytes&lt;/code&gt; ），那么发送到远程主机的ping数据包中将包含许多数据字节。如果协议为&amp;ldquo; tcp&amp;rdquo;，则忽略数据字节数。如果协议为&amp;ldquo; udp&amp;rdquo;，则数据字节的最小（默认）数为1，否则为0。可以指定的最大数据字节数为65535，但建议保持在MTU（ICMP为1472字节）以下。许多小型设备无法处理碎片化的ICMP数据包。</target>
        </trans-unit>
        <trans-unit id="6ea88b95c30f8557b60611e6fa0d52e56ecf8669" translate="yes" xml:space="preserve">
          <source>If the number of partitions on the disk.</source>
          <target state="translated">如果磁盘上的分区数量。</target>
        </trans-unit>
        <trans-unit id="a34b4bc1598422e778b8ed9662906c7efb975344" translate="yes" xml:space="preserve">
          <source>If the number of scalars in the left-hand list is greater than that in the left-hand list, the &quot;missing&quot; scalars will become undefined.</source>
          <target state="translated">如果左手列表中的标量数量大于左手列表中的标量,那么 &quot;缺失 &quot;的标量将成为未定义的标量。</target>
        </trans-unit>
        <trans-unit id="73c7831330bbfcd31669c32d53f7a76b28d963cd" translate="yes" xml:space="preserve">
          <source>If the number of scalars in the left-hand list is less than that in the right-hand list, the &quot;extra&quot; scalars in the right-hand list will simply not be assigned.</source>
          <target state="translated">如果左手列表中的标量数量少于右手列表中的标量,右手列表中的 &quot;额外 &quot;标量就不会被分配。</target>
        </trans-unit>
        <trans-unit id="cf726231b3d599cdbe46b108046dbf7815381c4c" translate="yes" xml:space="preserve">
          <source>If the object has been passed to a child process during a fork, the file will be deleted when the object goes out of scope in the parent.</source>
          <target state="translated">如果对象在分叉过程中被传递给了子进程,那么当该对象在父进程中超出范围时,该文件将被删除。</target>
        </trans-unit>
        <trans-unit id="39e52d92c6b313ed3349d0401be82f80d273536a" translate="yes" xml:space="preserve">
          <source>If the only casing for a code point is locale-dependent, then the returned hash will not have any of the base keys, like &lt;code&gt;code&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , etc., but will contain only locale keys.</source>
          <target state="translated">如果代码点的唯一大小写依赖于语言环境，则返回的哈希将不包含任何基本键，如 &lt;code&gt;code&lt;/code&gt; ， &lt;code&gt;upper&lt;/code&gt; 等，而仅包含语言环境键。</target>
        </trans-unit>
        <trans-unit id="4285420e25852376bd4b42fe10dbce58fa32d6ad" translate="yes" xml:space="preserve">
          <source>If the only casing for a code point is locale-dependent, then the returned hash will not have any of the base keys, like &lt;code&gt;code&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, etc., but will contain only locale keys.</source>
          <target state="translated">如果代码点的唯一大小写依赖于语言环境，则返回的哈希将不包含任何基本键，如 &lt;code&gt;code&lt;/code&gt; ， &lt;code&gt;upper&lt;/code&gt; 等，而仅包含语言环境键。</target>
        </trans-unit>
        <trans-unit id="17fa159e601e547a6489ad99ba45fba36084dad4" translate="yes" xml:space="preserve">
          <source>If the only comparison needed is whether an installed module is of a sufficiently high version, a direct test may be done using the string form of &lt;code&gt;eval&lt;/code&gt; and the &lt;code&gt;use&lt;/code&gt; function. For example, for module &lt;code&gt;$mod&lt;/code&gt; and version prerequisite &lt;code&gt;$prereq&lt;/code&gt;:</source>
          <target state="translated">如果唯一需要比较的是安装的模块是否具有足够高的版本，则可以使用字符串形式的 &lt;code&gt;eval&lt;/code&gt; 和 &lt;code&gt;use&lt;/code&gt; 函数进行直接测试。例如，对于模块 &lt;code&gt;$mod&lt;/code&gt; 和版本先决条件 &lt;code&gt;$prereq&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e51d5a9ae61f6c29388fc414c6297a691764547b" translate="yes" xml:space="preserve">
          <source>If the operand is a reference to a blessed object, then the name of the class into which the referent is blessed will be returned. &lt;code&gt;ref&lt;/code&gt; doesn't care what the physical type of the referent is; blessing takes precedence over such concerns. Beware that exact comparison of &lt;code&gt;ref&lt;/code&gt; results against a class name doesn't perform a class membership test: a class's members also include objects blessed into subclasses, for which &lt;code&gt;ref&lt;/code&gt; will return the name of the subclass. Also beware that class names can clash with the built-in type names (described below).</source>
          <target state="translated">如果操作数是对祝福对象的引用，则将返回引用对象被祝福的类的名称。 &lt;code&gt;ref&lt;/code&gt; 不在乎所指对象的物理类型；祝福优先于此类担忧。请注意，将 &lt;code&gt;ref&lt;/code&gt; 结果与类名称进行精确比较不会执行类成员资格测试：类的成员还包括被祝福进入子类的对象，为此 &lt;code&gt;ref&lt;/code&gt; 将返回子类的名称。还要注意，类名可能与内置类型名发生冲突（如下所述）。</target>
        </trans-unit>
        <trans-unit id="7623f1bb883be3a3b5a21de5d5644725c26daefe" translate="yes" xml:space="preserve">
          <source>If the operand is a reference to an unblessed object, then the return value indicates the type of object. If the unblessed referent is not a scalar, then the return value will be one of the strings &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;HASH&lt;/code&gt;, &lt;code&gt;CODE&lt;/code&gt;, &lt;code&gt;FORMAT&lt;/code&gt;, or &lt;code&gt;IO&lt;/code&gt;, indicating only which kind of object it is. If the unblessed referent is a scalar, then the return value will be one of the strings &lt;code&gt;SCALAR&lt;/code&gt;, &lt;code&gt;VSTRING&lt;/code&gt;, &lt;code&gt;REF&lt;/code&gt;, &lt;code&gt;GLOB&lt;/code&gt;, &lt;code&gt;LVALUE&lt;/code&gt;, or &lt;code&gt;REGEXP&lt;/code&gt;, depending on the kind of value the scalar currently has. But note that &lt;code&gt;qr//&lt;/code&gt; scalars are created already blessed, so &lt;code&gt;ref qr/.../&lt;/code&gt; will likely return &lt;code&gt;Regexp&lt;/code&gt;. Beware that these built-in type names can also be used as class names, so &lt;code&gt;ref&lt;/code&gt; returning one of these names doesn't unambiguously indicate that the referent is of the kind to which the name refers.</source>
          <target state="translated">如果操作数是对未祝福对象的引用，则返回值指示对象的类型。如果不受祝福的引用对象不是标量，则返回值将是字符串 &lt;code&gt;ARRAY&lt;/code&gt; ， &lt;code&gt;HASH&lt;/code&gt; ， &lt;code&gt;CODE&lt;/code&gt; ， &lt;code&gt;FORMAT&lt;/code&gt; 或 &lt;code&gt;IO&lt;/code&gt; 之一，仅指示其是哪种对象。如果 &lt;code&gt;VSTRING&lt;/code&gt; 引用是标量，则返回值将是字符串 &lt;code&gt;SCALAR&lt;/code&gt; ，VSTRING， &lt;code&gt;REF&lt;/code&gt; ， &lt;code&gt;GLOB&lt;/code&gt; ， &lt;code&gt;LVALUE&lt;/code&gt; 或 &lt;code&gt;REGEXP&lt;/code&gt; 之一，具体取决于标量当前具有的值的类型。但是请注意， &lt;code&gt;qr//&lt;/code&gt; 标量的创建已经很幸运了，所以 &lt;code&gt;ref qr/.../&lt;/code&gt; 可能会返回 &lt;code&gt;Regexp&lt;/code&gt; 。注意，这些内置类型名称也可以用作类名称，因此 &lt;code&gt;ref&lt;/code&gt; 返回这些名称之一并不会明确表示该引用对象是该名称所引用的类型。</target>
        </trans-unit>
        <trans-unit id="8aa1ec170d0d4fcfcfbbdd9dd518a1d70b552ce0" translate="yes" xml:space="preserve">
          <source>If the operand is not a reference, then the empty string will be returned. An empty string will only be returned in this situation. &lt;code&gt;ref&lt;/code&gt; is often useful to just test whether a value is a reference, which can be done by comparing the result to the empty string. It is a common mistake to use the result of &lt;code&gt;ref&lt;/code&gt; directly as a truth value: this goes wrong because &lt;code&gt;0&lt;/code&gt; (which is false) can be returned for a reference.</source>
          <target state="translated">如果操作数不是引用，则将返回空字符串。在这种情况下，将只返回一个空字符串。 &lt;code&gt;ref&lt;/code&gt; 通常仅用于测试值是否为引用，这可以通过将结果与空字符串进行比较来实现。直接将 &lt;code&gt;ref&lt;/code&gt; 的结果用作真实值是一个常见的错误：这是错误的，因为可以返回 &lt;code&gt;0&lt;/code&gt; （为假）作为参考。</target>
        </trans-unit>
        <trans-unit id="addcad10a864d1cffc4846608d394fea1feac09a" translate="yes" xml:space="preserve">
          <source>If the operands to a binary bitwise op are strings of different sizes, &lt;b&gt;|&lt;/b&gt; and &lt;b&gt;^&lt;/b&gt; ops act as though the shorter operand had additional zero bits on the right, while the &lt;b&gt;&amp;amp;&lt;/b&gt; op acts as though the longer operand were truncated to the length of the shorter. The granularity for such extension or truncation is one or more bytes.</source>
          <target state="translated">如果二进制按位运算的操作数是不同大小的字符串，&lt;b&gt;| &lt;/b&gt;和&lt;b&gt;^&lt;/b&gt; ops的作用就像较短的操作数在右侧具有附加的零位，而&lt;b&gt;＆&lt;/b&gt; op的作用就像较长的操作数被截短为较短的操作数。这种扩展或截断的粒度为一个或多个字节。</target>
        </trans-unit>
        <trans-unit id="c7870bd3c024159f240305b7047279e21ad1fe56" translate="yes" xml:space="preserve">
          <source>If the operating system supports it (for example BSD derived systems), the filehandle will be opened with O_EXLOCK (open with exclusive file lock). This can sometimes cause problems if the intention is to pass the filename to another system that expects to take an exclusive lock itself (such as DBD::SQLite) whilst ensuring that the tempfile is not reused. In this situation the &quot;EXLOCK&quot; option can be passed to tempfile. By default EXLOCK will be true (this retains compatibility with earlier releases).</source>
          <target state="translated">如果操作系统支持它(例如BSD衍生系统),文件柄将用O_EXLOCK(用专属文件锁打开)打开。如果打算将文件名传递给另一个期望自己使用独占锁的系统(例如DBD::SQLite),同时确保tempfile不被重复使用,这有时会引起问题。在这种情况下,&quot;EXLOCK &quot;选项可以传递给tempfile。默认情况下,EXLOCK将为true(这保留了与早期版本的兼容性)。</target>
        </trans-unit>
        <trans-unit id="e19b7bb4d69a3c985ce8931960025916d3561c3a" translate="yes" xml:space="preserve">
          <source>If the operation being timed out is system() or qx(), this technique is liable to generate zombies. If this matters to you, you'll need to do your own fork() and exec(), and kill the errant child process.</source>
          <target state="translated">如果被超时的操作是system()或qx(),这种技术就有可能产生僵尸。如果这对你很重要,你需要自己进行fork()和exec(),并杀死错误的子进程。</target>
        </trans-unit>
        <trans-unit id="05f4a71ea34fe9d7ddbd210db5290a2dfa223838" translate="yes" xml:space="preserve">
          <source>If the operation shown is &quot;ToFold&quot;, it means that case-insensitive matching in a regular expression was done on the code point.</source>
          <target state="translated">如果显示的操作是 &quot;ToFold&quot;,说明在代码点上进行了正则表达式的大小写不敏感匹配。</target>
        </trans-unit>
        <trans-unit id="3ba42937f598291497eafce66d29e91aabe688c5" translate="yes" xml:space="preserve">
          <source>If the optimization can not be applied, this returns undef. If it can be applied, this method returns a hash reference containing the following information:</source>
          <target state="translated">如果不能应用优化,则返回undef。如果可以应用,本方法返回一个包含以下信息的哈希引用。</target>
        </trans-unit>
        <trans-unit id="a982ec5add551174c87d54c0c75cad924249147a" translate="yes" xml:space="preserve">
          <source>If the option destination is a reference to a hash, the option will take, as value, strings of the form</source>
          <target state="translated">如果选项的目标是对哈希的引用,那么选项的值将是以下形式的字符串</target>
        </trans-unit>
        <trans-unit id="ab8a370e734c2b7f25ad3475fabaef52fd095ddb" translate="yes" xml:space="preserve">
          <source>If the option is provided, and &lt;code&gt;PERL_PERTURB_KEYS&lt;/code&gt; is NOT set, then a value of '0' implies &lt;code&gt;PERL_PERTURB_KEYS=0&lt;/code&gt; and any other value implies &lt;code&gt;PERL_PERTURB_KEYS=2&lt;/code&gt; .</source>
          <target state="translated">如果提供了该选项，并且 &lt;code&gt;PERL_PERTURB_KEYS&lt;/code&gt; 设置PERL_PERTURB_KEYS，则值'0'表示 &lt;code&gt;PERL_PERTURB_KEYS=0&lt;/code&gt; ,而其他任何值表示 &lt;code&gt;PERL_PERTURB_KEYS=2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d707532b21b034988218d78dc5dd2089b91f3ef" translate="yes" xml:space="preserve">
          <source>If the option is provided, and &lt;code&gt;PERL_PERTURB_KEYS&lt;/code&gt; is NOT set, then a value of '0' implies &lt;code&gt;PERL_PERTURB_KEYS=0&lt;/code&gt; and any other value implies &lt;code&gt;PERL_PERTURB_KEYS=2&lt;/code&gt;.</source>
          <target state="translated">如果提供了该选项，并且 &lt;code&gt;PERL_PERTURB_KEYS&lt;/code&gt; 设置PERL_PERTURB_KEYS，则值'0'表示 &lt;code&gt;PERL_PERTURB_KEYS=0&lt;/code&gt; ,而其他任何值则表示 &lt;code&gt;PERL_PERTURB_KEYS=2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb774833de734f7b65efa56e3c7c5f53234542f8" translate="yes" xml:space="preserve">
          <source>If the option is set to false, the output buffer in the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method will be truncated before uncompressed data is written to it.</source>
          <target state="translated">如果该选项设置为false，则在将未压缩的数据写入 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 方法中的输出缓冲区之前，该缓冲区将被截断。</target>
        </trans-unit>
        <trans-unit id="a7e5a140437039036cbeabf084c8f96c887a93f7" translate="yes" xml:space="preserve">
          <source>If the option is set to true, uncompressed data will be appended to the output buffer by the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method.</source>
          <target state="translated">如果该选项设置为true，则将通过 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 方法将未压缩的数据附加到输出缓冲区。</target>
        </trans-unit>
        <trans-unit id="c22c2720bbc793b56d2bdb2031cd852762e79aba" translate="yes" xml:space="preserve">
          <source>If the option is set to true, uncompressed data will be appended to the output buffer in the &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; and &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; methods.</source>
          <target state="translated">如果该选项设置为true，则未压缩的数据将通过 &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; 和 &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; 方法添加到输出缓冲区。</target>
        </trans-unit>
        <trans-unit id="943c28148863687139f9e45e03407da89d7e13fa" translate="yes" xml:space="preserve">
          <source>If the option value is required, Getopt::Long will take the command line argument that follows the option and assign this to the option variable. If, however, the option value is specified as optional, this will only be done if that value does not look like a valid command line option itself.</source>
          <target state="translated">如果选项值是必需的,Getopt::Long 将取选项后面的命令行参数并将其赋值给选项变量。然而,如果选项值被指定为可选的,那么只有当该值本身看起来不像一个有效的命令行选项时,才会这样做。</target>
        </trans-unit>
        <trans-unit id="8b25fc0c82dd37f9c4b9d7996e6e001cd8c1c22e" translate="yes" xml:space="preserve">
          <source>If the order of &lt;code&gt;sv_setiv&lt;/code&gt; and &lt;code&gt;sv_setpv&lt;/code&gt; had been reversed, then the macro &lt;code&gt;SvPOK_on&lt;/code&gt; would need to be called instead of &lt;code&gt;SvIOK_on&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;sv_setiv&lt;/code&gt; 和 &lt;code&gt;sv_setpv&lt;/code&gt; 的顺序已颠倒，则需要调用宏 &lt;code&gt;SvPOK_on&lt;/code&gt; 而不是 &lt;code&gt;SvIOK_on&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2507fa462b26287b008669ac5e4307de24ce4d06" translate="yes" xml:space="preserve">
          <source>If the order of &lt;code&gt;sv_setiv&lt;/code&gt; and &lt;code&gt;sv_setpv&lt;/code&gt; had been reversed, then the macro &lt;code&gt;SvPOK_on&lt;/code&gt; would need to be called instead of &lt;code&gt;SvIOK_on&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;sv_setiv&lt;/code&gt; 和 &lt;code&gt;sv_setpv&lt;/code&gt; 的顺序已颠倒，则需要调用宏 &lt;code&gt;SvPOK_on&lt;/code&gt; 而不是 &lt;code&gt;SvIOK_on&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b0f391156a0e1896106ec41b93d3c42cc8fd48b" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; already contains a value (typically from a previous eval) that value is reused after appending &lt;code&gt;&quot;\t...propagated&quot;&lt;/code&gt; . This is useful for propagating exceptions:</source>
          <target state="translated">如果输出为空，并且 &lt;code&gt;$@&lt;/code&gt; 已经包含一个值（通常来自先前的eval），则在附加 &lt;code&gt;&quot;\t...propagated&quot;&lt;/code&gt; 之后将重用该值。这对于传播异常很有用：</target>
        </trans-unit>
        <trans-unit id="25d81dad12165191ac2a4d2f3e667fda9ababd8e" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; already contains a value (typically from a previous eval) that value is used after appending &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; to &lt;code&gt;$@&lt;/code&gt; . This is useful for staying almost, but not entirely similar to &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果输出为空，并且 &lt;code&gt;$@&lt;/code&gt; 已经包含一个值（通常来自先前的评估），则在将 &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; 附加到 &lt;code&gt;$@&lt;/code&gt; 之后使用该值。这对于留下几乎但不完全像 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 物体很有用。</target>
        </trans-unit>
        <trans-unit id="65e420bc5858eb45a1dddd4a10cb455bd1ce4cc1" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; already contains a value (typically from a previous eval) that value is used after appending &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; to &lt;code&gt;$@&lt;/code&gt; . This is useful for staying almost, but not entirely similar to &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果输出为空，并且 &lt;code&gt;$@&lt;/code&gt; 已经包含一个值（通常来自先前的评估），则在将 &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; 附加到 &lt;code&gt;$@&lt;/code&gt; 之后使用该值。这对于留下几乎但不完全像 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 物体很有用。</target>
        </trans-unit>
        <trans-unit id="2cfa46357b1516decacabae244126181d8b80b21" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; contains an object reference that has a &lt;code&gt;PROPAGATE&lt;/code&gt; method, that method will be called with additional file and line number parameters. The return value replaces the value in &lt;code&gt;$@&lt;/code&gt; ; i.e., as if &lt;code&gt;$@ = &lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; were called.</source>
          <target state="translated">如果输出为空，并且 &lt;code&gt;$@&lt;/code&gt; 包含具有 &lt;code&gt;PROPAGATE&lt;/code&gt; 方法的对象引用，则将使用其他文件和行号参数调用该方法。返回值替换 &lt;code&gt;$@&lt;/code&gt; 的值；即，好像 &lt;code&gt;$@ = &lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; 被称为。</target>
        </trans-unit>
        <trans-unit id="a97492155e7589378bb301645dfa7c34b680ef04" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; contains an object reference that has a &lt;code&gt;PROPAGATE&lt;/code&gt; method, that method will be called with additional file and line number parameters. The return value replaces the value in &lt;code&gt;$@&lt;/code&gt; ; i.e., as if &lt;code&gt;$@ = &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; were called.</source>
          <target state="translated">如果输出为空，并且 &lt;code&gt;$@&lt;/code&gt; 包含具有 &lt;code&gt;PROPAGATE&lt;/code&gt; 方法的对象引用，则将使用其他文件和行号参数调用该方法。返回值替换 &lt;code&gt;$@&lt;/code&gt; 的值；即，好像 &lt;code&gt;$@ = &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; 被称为。</target>
        </trans-unit>
        <trans-unit id="4e71a254b15b38644afabad82376b2bb1e4f7fab" translate="yes" xml:space="preserve">
          <source>If the output of the &lt;code&gt;h h&lt;/code&gt; command (or any command, for that matter) scrolls past your screen, precede the command with a leading pipe symbol so that it's run through your pager, as in</source>
          <target state="translated">如果 &lt;code&gt;h h&lt;/code&gt; 命令（或其他任何命令）的输出滚动到屏幕之外，请在该命令之前加一个前置的管道符号，以便它在您的寻呼机中运行，如下所示：</target>
        </trans-unit>
        <trans-unit id="f7911c6fed712fb085afb893540153d04c3ba2b2" translate="yes" xml:space="preserve">
          <source>If the package has a mailing list, include a URL or subscription instructions here.</source>
          <target state="translated">如果软件包有邮件列表,请在这里附上URL或订阅说明。</target>
        </trans-unit>
        <trans-unit id="2bd5efd382acc87571dd747451ad45f157dd85d7" translate="yes" xml:space="preserve">
          <source>If the package has a web site, include a URL here.</source>
          <target state="translated">如果软件包有网站,请在这里附上网址。</target>
        </trans-unit>
        <trans-unit id="128d72462f8fdf7586cd07b73dc9169d6e753911" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, &lt;code&gt;U+FFFE&lt;/code&gt; has a minimal primary weight. The comparison between &lt;code&gt;&quot;$a1\x{FFFE}$a2&quot;&lt;/code&gt; and &lt;code&gt;&quot;$b1\x{FFFE}$b2&quot;&lt;/code&gt; first compares &lt;code&gt;$a1&lt;/code&gt; and &lt;code&gt;$b1&lt;/code&gt; at level 1, and then &lt;code&gt;$a2&lt;/code&gt; and &lt;code&gt;$b2&lt;/code&gt; at level 1, as followed.</source>
          <target state="translated">如果该参数为true，则 &lt;code&gt;U+FFFE&lt;/code&gt; 的主权重最小。之间的比较 &lt;code&gt;&quot;$a1\x{FFFE}$a2&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;$b1\x{FFFE}$b2&quot;&lt;/code&gt; 首先比较 &lt;code&gt;$a1&lt;/code&gt; 和 &lt;code&gt;$b1&lt;/code&gt; 在第1级，然后 &lt;code&gt;$a2&lt;/code&gt; 和 &lt;code&gt;$b2&lt;/code&gt; 在第1级，如随后。</target>
        </trans-unit>
        <trans-unit id="c1bc1d540aa212d81d3c27835031fe5adbb0eee1" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, &lt;code&gt;U+FFFF&lt;/code&gt; has a highest primary weight. When a boolean of &lt;code&gt;$coll-&amp;gt;ge($str, &quot;abc&quot;)&lt;/code&gt; and &lt;code&gt;$coll-&amp;gt;le($str, &quot;abc\x{FFFF}&quot;)&lt;/code&gt; is true, it is expected that &lt;code&gt;$str&lt;/code&gt; begins with &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , or another primary equivalent. &lt;code&gt;$str&lt;/code&gt; may be &lt;code&gt;&quot;abcd&quot;&lt;/code&gt; , &lt;code&gt;&quot;abc012&quot;&lt;/code&gt; , but should not include &lt;code&gt;U+FFFF&lt;/code&gt; such as &lt;code&gt;&quot;abc\x{FFFF}xyz&quot;&lt;/code&gt; .</source>
          <target state="translated">如果该参数为true，则 &lt;code&gt;U+FFFF&lt;/code&gt; 具有最高的主权重。当 &lt;code&gt;$coll-&amp;gt;ge($str, &quot;abc&quot;)&lt;/code&gt; 和 &lt;code&gt;$coll-&amp;gt;le($str, &quot;abc\x{FFFF}&quot;)&lt;/code&gt; 的布尔值为true时，则期望 &lt;code&gt;$str&lt;/code&gt; 以 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 开头，或其他主要等效项。 &lt;code&gt;$str&lt;/code&gt; 可以是 &lt;code&gt;&quot;abcd&quot;&lt;/code&gt; ， &lt;code&gt;&quot;abc012&quot;&lt;/code&gt; ，但不应包含 &lt;code&gt;U+FFFF&lt;/code&gt; ,例如 &lt;code&gt;&quot;abc\x{FFFF}xyz&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd592631134dd93dfb6509b2405e1e6bdddd05d2" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, &lt;code&gt;U+FFFF&lt;/code&gt; has a highest primary weight. When a boolean of &lt;code&gt;$coll-&amp;gt;ge($str, &quot;abc&quot;)&lt;/code&gt; and &lt;code&gt;$coll-&amp;gt;le($str, &quot;abc\x{FFFF}&quot;)&lt;/code&gt; is true, it is expected that &lt;code&gt;$str&lt;/code&gt; begins with &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, or another primary equivalent. &lt;code&gt;$str&lt;/code&gt; may be &lt;code&gt;&quot;abcd&quot;&lt;/code&gt;, &lt;code&gt;&quot;abc012&quot;&lt;/code&gt;, but should not include &lt;code&gt;U+FFFF&lt;/code&gt; such as &lt;code&gt;&quot;abc\x{FFFF}xyz&quot;&lt;/code&gt;.</source>
          <target state="translated">如果该参数为true，则 &lt;code&gt;U+FFFF&lt;/code&gt; 具有最高的主权重。当 &lt;code&gt;$coll-&amp;gt;ge($str, &quot;abc&quot;)&lt;/code&gt; 和 &lt;code&gt;$coll-&amp;gt;le($str, &quot;abc\x{FFFF}&quot;)&lt;/code&gt; 的布尔值为true时，则期望 &lt;code&gt;$str&lt;/code&gt; 以 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 开头，或其他主要等效项。 &lt;code&gt;$str&lt;/code&gt; 可以是 &lt;code&gt;&quot;abcd&quot;&lt;/code&gt; ， &lt;code&gt;&quot;abc012&quot;&lt;/code&gt; ，但不应包含 &lt;code&gt;U+FFFF&lt;/code&gt; ,例如 &lt;code&gt;&quot;abc\x{FFFF}xyz&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2379a678967ce11b206cce9256eec402c626744e" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, a final, tie-breaking level is used. If no difference of weights is found after the comparison through all the level specified by &lt;code&gt;level&lt;/code&gt; , the comparison with code points will be performed. For the tie-breaking comparison, the sort key has code points of the original string appended. Completely ignorable characters are not ignored.</source>
          <target state="translated">如果参数为true，则使用最终的平局决胜级别。如果通过所有规定的水平进行比较后发现没有权重的差异 &lt;code&gt;level&lt;/code&gt; ，与代码点的比较将被执行。对于平局比较，排序键附加了原始字符串的代码点。完全可忽略的字符不会被忽略。</target>
        </trans-unit>
        <trans-unit id="cf3801fdcc987b0c168aed25eff11116ed2d9d13" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, a final, tie-breaking level is used. If no difference of weights is found after the comparison through all the level specified by &lt;code&gt;level&lt;/code&gt;, the comparison with code points will be performed. For the tie-breaking comparison, the sort key has code points of the original string appended. Completely ignorable characters are not ignored.</source>
          <target state="translated">如果该参数为true，则使用最终的平局决胜级别。如果通过所有规定的水平进行比较后发现没有权重的差异 &lt;code&gt;level&lt;/code&gt; ，与代码点的比较将被执行。为了平局比较，排序键附加了原始字符串的代码点。完全可忽略的字符不会被忽略。</target>
        </trans-unit>
        <trans-unit id="e6d70ed0cf4279c5cf91d7d6890341737c51d4df" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, accents (and other primary ignorable characters) are ignored, even though cases are taken into account.</source>
          <target state="translated">如果参数为真,则会忽略重音(和其他主要的可忽略字符),尽管会考虑到大小写。</target>
        </trans-unit>
        <trans-unit id="3ffce08d047eaee75c853cd8ab3be63e13efe5a7" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, for a contraction with three or more characters (here nicknamed &quot;long contraction&quot;), initial substrings will be handled. For example, a contraction ABC, where A is a starter, and B and C are non-starters (character with non-zero combining character class), will be detected even if there is not AB as a contraction.</source>
          <target state="translated">如果该参数为真,对于有3个或更多字符的收缩(这里称为 &quot;长收缩&quot;),将处理初始子串。例如,收缩ABC,其中A是起始字符,B和C是非起始字符(组合字符类别为非零的字符),即使没有AB作为收缩,也会被检测出来。</target>
        </trans-unit>
        <trans-unit id="6196ed90d85a5642d1f2bff307d9850731d3ee76" translate="yes" xml:space="preserve">
          <source>If the parameters to the INCLUDE: keyword are followed by a pipe (&lt;code&gt;|&lt;/code&gt;) then the compiler will interpret the parameters as a command. This feature is mildly deprecated in favour of the &lt;code&gt;INCLUDE_COMMAND:&lt;/code&gt; directive, as documented below.</source>
          <target state="translated">如果INCLUDE：关键字的参数后跟管道（ &lt;code&gt;|&lt;/code&gt; ），则编译器会将这些参数解释为命令。不推荐使用此功能，而推荐使用 &lt;code&gt;INCLUDE_COMMAND:&lt;/code&gt; 指令，如下所述。</target>
        </trans-unit>
        <trans-unit id="60984150a4a273c37051fdd1024089806a686df1" translate="yes" xml:space="preserve">
          <source>If the parent process is killed (either using Perl's kill() builtin, or using some external means) all the pseudo-processes are killed as well, and the whole process exits.</source>
          <target state="translated">如果父进程被杀死(无论是使用Perl的kill()内建函数,还是使用某种外部手段),所有的伪进程也会被杀死,整个进程退出。</target>
        </trans-unit>
        <trans-unit id="aa64f5b5dc3063c1ec88bf3714d6a78f8885563e" translate="yes" xml:space="preserve">
          <source>If the pattern contains embedded code, such as</source>
          <target state="translated">如果该模式包含嵌入式代码,如</target>
        </trans-unit>
        <trans-unit id="c8e637c05d0476b3ff64dcc72c39f7a79e3a588a" translate="yes" xml:space="preserve">
          <source>If the pattern contains its delimiter within it, that delimiter must be escaped. Prefixing it with a backslash (</source>
          <target state="translated">如果模式中包含定界符,则必须对定界符进行转义。用反斜杠(</target>
        </trans-unit>
        <trans-unit id="400ab285c2500104132be9cd3fcc1a752df8a4f5" translate="yes" xml:space="preserve">
          <source>If the pattern does not match any pathname, then bsd_glob() returns a list consisting of only the pattern. If &lt;code&gt;GLOB_QUOTE&lt;/code&gt; is set, its effect is present in the pattern returned.</source>
          <target state="translated">如果该模式与任何路径名都不匹配，则bsd_glob（）返回仅包含该模式的列表。如果设置了 &lt;code&gt;GLOB_QUOTE&lt;/code&gt; ，则其效果将出现在返回的模式中。</target>
        </trans-unit>
        <trans-unit id="6adde583f90fd2399e3928b4e6217841c09c97fb" translate="yes" xml:space="preserve">
          <source>If the pattern may match only at a handful of places, with &lt;code&gt;TYPE&lt;/code&gt; being &lt;code&gt;SBOL&lt;/code&gt; , &lt;code&gt;MBOL&lt;/code&gt; , or &lt;code&gt;GPOS&lt;/code&gt; . See the table below.</source>
          <target state="translated">如果该模式仅在少数几个地方匹配，且 &lt;code&gt;TYPE&lt;/code&gt; 为 &lt;code&gt;SBOL&lt;/code&gt; ， &lt;code&gt;MBOL&lt;/code&gt; 或 &lt;code&gt;GPOS&lt;/code&gt; 。请参阅下表。</target>
        </trans-unit>
        <trans-unit id="40469f0b5b6e999f3b3f0091f7983d3535304a67" translate="yes" xml:space="preserve">
          <source>If the pattern may match only at a handful of places, with &lt;code&gt;TYPE&lt;/code&gt; being &lt;code&gt;SBOL&lt;/code&gt;, &lt;code&gt;MBOL&lt;/code&gt;, or &lt;code&gt;GPOS&lt;/code&gt;. See the table below.</source>
          <target state="translated">如果模式仅在少数几个地方匹配，且 &lt;code&gt;TYPE&lt;/code&gt; 为 &lt;code&gt;SBOL&lt;/code&gt; ， &lt;code&gt;MBOL&lt;/code&gt; 或 &lt;code&gt;GPOS&lt;/code&gt; 。请参阅下表。</target>
        </trans-unit>
        <trans-unit id="d0ce5cbb841f39a51912df72d9768f6a6a5fae33" translate="yes" xml:space="preserve">
          <source>If the pattern was used as follows</source>
          <target state="translated">如果使用的模式如下</target>
        </trans-unit>
        <trans-unit id="2dd05fadef47c4bd45462fdfaa94e04afc77ad22" translate="yes" xml:space="preserve">
          <source>If the performance in such cases is unacceptable, you may defer the actual writing, and then have it done all at once. The following loop will perform much better for large files:</source>
          <target state="translated">如果这种情况下的性能无法接受,可以推迟实际写入,然后一次性完成。下面的循环对于大文件的性能会好很多。</target>
        </trans-unit>
        <trans-unit id="956656b1b2d0c77e2fbe4d0d92677dc48070a8ed" translate="yes" xml:space="preserve">
          <source>If the platform is MS-DOS like and normally does CRLF to &quot;\n&quot; translation for text files then the default layers are :</source>
          <target state="translated">如果平台是像MS-DOS一样,通常对文本文件进行CRLF到&quot;\n &quot;的翻译,那么默认的层是.NET。</target>
        </trans-unit>
        <trans-unit id="5f1c5a6b0ba8f7ba98047b8fb60cfdcca7e45034" translate="yes" xml:space="preserve">
          <source>If the platform is MS-DOS like and normally does CRLF to &quot;\n&quot; translation for text files then the default layers are:</source>
          <target state="translated">如果该平台类似MS-DOS,并且通常对文本文件进行CRLF到&quot;\n &quot;的翻译,那么默认的层是。</target>
        </trans-unit>
        <trans-unit id="fee788dad0c5b1cd15e2fa5ddb122d4f9bd910af" translate="yes" xml:space="preserve">
          <source>If the platform supports the &lt;code&gt;langinfo(CODESET)&lt;/code&gt; interface, the codeset returned is used as the default encoding for the open pragma.</source>
          <target state="translated">如果平台支持 &lt;code&gt;langinfo(CODESET)&lt;/code&gt; 接口，则返回的代码集将用作打开的编译指示的默认编码。</target>
        </trans-unit>
        <trans-unit id="e029b7bfe44b40ce79cdafd38dd9f57646af8f39" translate="yes" xml:space="preserve">
          <source>If the program exits without all threads having either been joined or detached, then a warning will be issued.</source>
          <target state="translated">如果程序在没有加入或脱离所有线程的情况下就退出,则会发出警告。</target>
        </trans-unit>
        <trans-unit id="68122aab68b9511758161a833aab14bd7cf8f3f4" translate="yes" xml:space="preserve">
          <source>If the program exits without all threads having either been joined or detached, then this warning will be issued.</source>
          <target state="translated">如果程序在没有加入或脱离所有线程的情况下退出,就会发出这个警告。</target>
        </trans-unit>
        <trans-unit id="3f05e0c9adcc7343a41a8d24201ee4c19ce64a54" translate="yes" xml:space="preserve">
          <source>If the program has been given to perl via the switches &lt;code&gt;-e&lt;/code&gt; or &lt;code&gt;-E&lt;/code&gt; , &lt;code&gt;$0&lt;/code&gt; will contain the string &lt;code&gt;&quot;-e&quot;&lt;/code&gt; .</source>
          <target state="translated">如果已通过开关 &lt;code&gt;-e&lt;/code&gt; 或 &lt;code&gt;-E&lt;/code&gt; 将程序提供给perl ，则 &lt;code&gt;$0&lt;/code&gt; 将包含字符串 &lt;code&gt;&quot;-e&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b296afa5e8ade3ba3ac78a9d465e171ac5067f8" translate="yes" xml:space="preserve">
          <source>If the program has been given to perl via the switches &lt;code&gt;-e&lt;/code&gt; or &lt;code&gt;-E&lt;/code&gt;, &lt;code&gt;$0&lt;/code&gt; will contain the string &lt;code&gt;&quot;-e&quot;&lt;/code&gt;.</source>
          <target state="translated">如果已通过开关 &lt;code&gt;-e&lt;/code&gt; 或 &lt;code&gt;-E&lt;/code&gt; 将程序提供给perl ，则 &lt;code&gt;$0&lt;/code&gt; 将包含字符串 &lt;code&gt;&quot;-e&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="187d3c3b9917db708f6b4997f1f577493d56ad38" translate="yes" xml:space="preserve">
          <source>If the program is syntactically correct, it is executed. If the program runs off the end without hitting an exit() or die() operator, an implicit &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(0)&lt;/a&gt;&lt;/code&gt; is provided to indicate successful completion.</source>
          <target state="translated">如果程序在语法上正确，则将执行该程序。如果程序运行到最后而没有命中exit（）或die（）运算符，则提供隐式 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(0)&lt;/a&gt;&lt;/code&gt; 表示成功完成。</target>
        </trans-unit>
        <trans-unit id="c7da837d3689d8811d08d5a2ade1a1a152e04568" translate="yes" xml:space="preserve">
          <source>If the program is syntactically correct, it is executed. If the program runs off the end without hitting an exit() or die() operator, an implicit &lt;code&gt;exit(0)&lt;/code&gt; is provided to indicate successful completion.</source>
          <target state="translated">如果程序在语法上正确，则将执行该程序。如果程序运行到最后而没有命中exit（）或die（）运算符，则会提供一个隐式 &lt;code&gt;exit(0)&lt;/code&gt; 来指示成功完成。</target>
        </trans-unit>
        <trans-unit id="8cf82d5604429bbfe1cb41298b645fa1f014e9ae" translate="yes" xml:space="preserve">
          <source>If the property doesn't have such a restricted set, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果属性没有这样的限制集，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f561839327dfb379f3ced83b14775ceeeefed09a" translate="yes" xml:space="preserve">
          <source>If the property doesn't have such a restricted set, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">如果该属性没有这样的限制集，则返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f736ee647a4d5e1589838b72f5b05af7545714ad" translate="yes" xml:space="preserve">
          <source>If the property name is unknown, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned. Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt; &quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt; . This function does not recognize those in the property parameter, returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果属性名称未知，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。请注意，Perl通常在正则表达式中以前缀可选的 &lt;code&gt;&quot;Is_&lt;/code&gt; _&amp;rdquo;（带或不带下划线）的方式识别正则表达式中的属性名称，例如 &lt;code&gt;\p{isgc=punct}&lt;/code&gt; 。此函数无法识别属性参数中的那些，返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8e6c1687e04cb1c576cc3de9ba670b370bee76a" translate="yes" xml:space="preserve">
          <source>If the property name is unknown, &lt;code&gt;undef&lt;/code&gt; is returned. Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt;&quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt;. This function does not recognize those in the property parameter, returning &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">如果属性名称未知，则返回 &lt;code&gt;undef&lt;/code&gt; 。请注意，Perl通常在正则表达式中以前缀可选的 &lt;code&gt;&quot;Is_&lt;/code&gt; _&amp;rdquo;（带或不带下划线）的方式识别正则表达式中的属性名称，例如 &lt;code&gt;\p{isgc=punct}&lt;/code&gt; 。此函数无法识别属性参数中的那些，返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afaf0816b79f3c9b4d1b468e6b1d9a01691cd781" translate="yes" xml:space="preserve">
          <source>If the protocol is set to &quot;tcp&quot;, this method may be called any number of times, and each call to the ping() method (below) will use the most recent $local_addr. If the protocol is &quot;icmp&quot; or &quot;udp&quot;, then bind() must be called at most once per object, and (if it is called at all) must be called before the first call to ping() for that object.</source>
          <target state="translated">如果协议设置为 &quot;tcp&quot;,那么这个方法可以被任意调用多次,每次调用ping()方法(如下)都会使用最近的$local_addr。如果协议是 &quot;icmp &quot;或 &quot;udp&quot;,那么每个对象最多只能调用一次bind(),而且(如果有调用的话)必须在第一次调用该对象的ping()之前调用。</target>
        </trans-unit>
        <trans-unit id="bd278d79ed04376a1ab23bc38f3813d0d8a95858" translate="yes" xml:space="preserve">
          <source>If the prototypes are enabled, you can disable it locally for a given XSUB as in the following example:</source>
          <target state="translated">如果启用了原型,你可以对给定的XSUB在本地禁用它,就像下面的例子一样。</target>
        </trans-unit>
        <trans-unit id="22222d2992db775cc93f4e6df7a745c81e01a6be" translate="yes" xml:space="preserve">
          <source>If the referenced object has been blessed into a package, then that package name is returned instead. But don't use that, as it's now considered &quot;bad practice&quot;. For one reason, an object could be using a class called &lt;code&gt;Regexp&lt;/code&gt; or &lt;code&gt;IO&lt;/code&gt; , or even &lt;code&gt;HASH&lt;/code&gt; . Also, &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; doesn't take into account subclasses, like &lt;code&gt;isa&lt;/code&gt; does.</source>
          <target state="translated">如果所引用的对象已被祝福到一个包中，则将返回该包名称。但是不要使用它，因为它现在被认为是&amp;ldquo;不好的做法&amp;rdquo;。由于一个原因，一个对象可能正在使用称为 &lt;code&gt;Regexp&lt;/code&gt; 或 &lt;code&gt;IO&lt;/code&gt; 甚至 &lt;code&gt;HASH&lt;/code&gt; 的类。同样， &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 不像 &lt;code&gt;isa&lt;/code&gt; 那样考虑子类。</target>
        </trans-unit>
        <trans-unit id="cf268542a8929b7e398cc1536659093d140d5216" translate="yes" xml:space="preserve">
          <source>If the referenced object has been blessed into a package, then that package name is returned instead. But don't use that, as it's now considered &quot;bad practice&quot;. For one reason, an object could be using a class called &lt;code&gt;Regexp&lt;/code&gt; or &lt;code&gt;IO&lt;/code&gt; , or even &lt;code&gt;HASH&lt;/code&gt; . Also, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; doesn't take into account subclasses, like &lt;code&gt;isa&lt;/code&gt; does.</source>
          <target state="translated">如果所引用的对象已被祝福到一个包中，则将返回该包名称。但是不要使用它，因为它现在被认为是&amp;ldquo;不好的做法&amp;rdquo;。由于一个原因，一个对象可能正在使用称为 &lt;code&gt;Regexp&lt;/code&gt; 或 &lt;code&gt;IO&lt;/code&gt; 甚至 &lt;code&gt;HASH&lt;/code&gt; 的类。同样， &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 不像 &lt;code&gt;isa&lt;/code&gt; 那样考虑子类。</target>
        </trans-unit>
        <trans-unit id="09e68bc71ae659a158de263698e821903752a759" translate="yes" xml:space="preserve">
          <source>If the referred library is an archive library, then it is treated as a simple collection of .o modules (all of which must contain PIC). These modules are then linked into the shared library.</source>
          <target state="translated">如果所引用的库是一个档案库,那么它将被视为一个简单的.o模块的集合(所有模块必须包含PIC)。然后将这些模块链接到共享库中。</target>
        </trans-unit>
        <trans-unit id="487c69f3c32cf6208263be856047bd1120b5cb11" translate="yes" xml:space="preserve">
          <source>If the regex engine was entered, the output may look like this:</source>
          <target state="translated">如果输入了regex引擎,输出可能是这样的。</target>
        </trans-unit>
        <trans-unit id="4071da6362bfae97335d6ccd04527e0675ca1ecf" translate="yes" xml:space="preserve">
          <source>If the remote server sends data a byte at time, and you need that data immediately without waiting for a newline (which might not happen), you may wish to replace the &lt;code&gt;while&lt;/code&gt; loop in the parent with the following:</source>
          <target state="translated">如果远程服务器一次发送一个字节的数据，并且您需要立即使用该数据而无需等待换行符（这种情况可能不会发生），则您可能希望用以下内容替换父级中的 &lt;code&gt;while&lt;/code&gt; 循环：</target>
        </trans-unit>
        <trans-unit id="78e886a06c0d6c64ae06980c39f4979b0d06c657" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;*&lt;/code&gt; , the offset is relative to the start of the packed string.</source>
          <target state="translated">如果重复计数为 &lt;code&gt;*&lt;/code&gt; ，则偏移量相对于打包字符串的开头。</target>
        </trans-unit>
        <trans-unit id="0c6d8ab738d17a47ddcc7210024698f2d723ba66" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;*&lt;/code&gt;, the offset is relative to the start of the packed string.</source>
          <target state="translated">如果重复计数为 &lt;code&gt;*&lt;/code&gt; ，则偏移量相对于打包字符串的开头。</target>
        </trans-unit>
        <trans-unit id="71535d2706781140ebf79d95c5c1eb0328f89697" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;0&lt;/code&gt; , it's relative to the current position.</source>
          <target state="translated">如果重复计数为 &lt;code&gt;0&lt;/code&gt; ，则相对于当前位置。</target>
        </trans-unit>
        <trans-unit id="8bb595e18165255d40d28696ced7cb987361acca" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;0&lt;/code&gt;, it's relative to the current position.</source>
          <target state="translated">如果重复计数为 &lt;code&gt;0&lt;/code&gt; ，则相对于当前位置。</target>
        </trans-unit>
        <trans-unit id="adddd684b7b4b320c5c6cd3d4e144f8d42b00be2" translate="yes" xml:space="preserve">
          <source>If the requested class doesn't yet exist, this function will still succeed, and return &lt;code&gt;[ $classname ]&lt;/code&gt;</source>
          <target state="translated">如果所请求的类尚不存在，则此函数仍将成功，并返回 &lt;code&gt;[ $classname ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3c8df40676c5ef413c4d428cc8bce1edd4a74be" translate="yes" xml:space="preserve">
          <source>If the required version is older than Perl 5.10, the &quot;:default&quot; feature bundle is automatically loaded instead.</source>
          <target state="translated">如果所需的版本比Perl 5.10旧,则会自动加载&quot;:default &quot;功能捆绑包。</target>
        </trans-unit>
        <trans-unit id="d407bfa98e92001cef51aaea080c36419318c881" translate="yes" xml:space="preserve">
          <source>If the result is a fraction, it is converted into a floating point number to the accuracy of your platform.</source>
          <target state="translated">如果结果是分数,就会按照你的平台的精度转换成浮点数。</target>
        </trans-unit>
        <trans-unit id="a0f32bf4dd5015a300ddb6707d47fae5eba9e46c" translate="yes" xml:space="preserve">
          <source>If the result is multiple script names, they are returned joined into a single comma-separated string.</source>
          <target state="translated">如果结果是多个脚本名称,则将它们连接成一个逗号分隔的字符串。</target>
        </trans-unit>
        <trans-unit id="45ec7fbff805996e6714524f94283d541160e6c3" translate="yes" xml:space="preserve">
          <source>If the return type of the XSUB includes &lt;code&gt;static&lt;/code&gt; , the method is considered to be a static method. It will call the C++ function using the class::method() syntax. If the method is not static the function will be called using the THIS-&amp;gt;method() syntax.</source>
          <target state="translated">如果XSUB的返回类型包括 &lt;code&gt;static&lt;/code&gt; ，则该方法被视为静态方法。它将使用class :: method（）语法调用C ++函数。如果该方法不是静态的，则将使用THIS-&amp;gt; method（）语法调用该函数。</target>
        </trans-unit>
        <trans-unit id="b467c0c1883d9fa2c1ada74a10e9d69505846ac1" translate="yes" xml:space="preserve">
          <source>If the return type of the XSUB includes &lt;code&gt;static&lt;/code&gt;, the method is considered to be a static method. It will call the C++ function using the class::method() syntax. If the method is not static the function will be called using the THIS-&amp;gt;method() syntax.</source>
          <target state="translated">如果XSUB的返回类型包括 &lt;code&gt;static&lt;/code&gt; ，则该方法被视为静态方法。它将使用class :: method（）语法调用C ++函数。如果该方法不是静态的，则将使用THIS-&amp;gt; method（）语法调用该函数。</target>
        </trans-unit>
        <trans-unit id="0b11488412f3e860557eb1891af20655d0de0fe4" translate="yes" xml:space="preserve">
          <source>If the return value of reval() is (or contains) any code reference, those code references are wrapped to be themselves executed always in the compartment. See &lt;a href=&quot;#wrap_code_refs_within&quot;&gt;&quot;wrap_code_refs_within&quot;&lt;/a&gt;.</source>
          <target state="translated">如果reval（）的返回值是（或包含）任何代码引用，则这些代码引用将包装为始终在隔离专区中执行。参见&lt;a href=&quot;#wrap_code_refs_within&quot;&gt;&amp;ldquo; wrap_code_refs_within&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="95ff7ce638cb043eea1113e455241d4090a0ba15" translate="yes" xml:space="preserve">
          <source>If the return value of reval() is (or contains) any code reference, those code references are wrapped to be themselves executed always in the compartment. See &lt;a href=&quot;#wrap_code_refs_within&quot;&gt;wrap_code_refs_within&lt;/a&gt;.</source>
          <target state="translated">如果reval（）的返回值是（或包含）任何代码引用，则这些代码引用将被包装为始终在隔离专区中执行。参见&lt;a href=&quot;#wrap_code_refs_within&quot;&gt;wrap_code_refs_within&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b5b2e1517f57a24f52793e2d523bf3e3916b624" translate="yes" xml:space="preserve">
          <source>If the revision (previously &quot;tracking version&quot;) number of UCA is given, behavior of that revision is emulated on collating. If omitted, the return value of &lt;code&gt;UCA_Version()&lt;/code&gt; is used.</source>
          <target state="translated">如果给出了UCA的修订版本号（以前称为&amp;ldquo;跟踪版本&amp;rdquo;），则在整理时将模拟该修订版的行为。如果省略，则使用 &lt;code&gt;UCA_Version()&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="1a7a3bfd506eaa3a5969fb39449cbd90048c5cd5" translate="yes" xml:space="preserve">
          <source>If the right argument is an expression rather than a search pattern, substitution, or transliteration, it is interpreted as a search pattern at run time. Note that this means that its contents will be interpolated twice, so</source>
          <target state="translated">如果正确的参数是一个表达式,而不是搜索模式、替换或翻译,那么它在运行时被解释为搜索模式。请注意,这意味着它的内容将被插值两次,所以</target>
        </trans-unit>
        <trans-unit id="397d47eee4fc1ac1405170a336868a5dec199f77" translate="yes" xml:space="preserve">
          <source>If the same C type is used in several different contexts which require different translations, &lt;code&gt;typedef&lt;/code&gt; several new types mapped to this C type, and create separate</source>
          <target state="translated">如果在需要不同翻译的几种不同上下文中使用相同的C类型，请 &lt;code&gt;typedef&lt;/code&gt; 映射到该C类型的几种新类型，并创建单独的</target>
        </trans-unit>
        <trans-unit id="456756c29fcce7da570891f767727aa9e1c8ea70" translate="yes" xml:space="preserve">
          <source>If the same character (or a sequence of characters) exists in the collation element table through &lt;code&gt;table&lt;/code&gt; , mapping to collation elements is overridden. If it does not exist, the mapping is defined additionally.</source>
          <target state="translated">如果通过 &lt;code&gt;table&lt;/code&gt; 到排序规则元素表中存在相同的字符（或字符序列），则覆盖到排序规则元素的映射将被覆盖。如果不存在，则另外定义映射。</target>
        </trans-unit>
        <trans-unit id="e4dde7b413bfb31794120513bb19ebe90728fd10" translate="yes" xml:space="preserve">
          <source>If the same character (or a sequence of characters) exists in the collation element table through &lt;code&gt;table&lt;/code&gt;, mapping to collation elements is overridden. If it does not exist, the mapping is defined additionally.</source>
          <target state="translated">如果通过 &lt;code&gt;table&lt;/code&gt; 到排序规则元素表中存在相同的字符（或字符序列），则覆盖到排序规则元素的映射将被覆盖。如果不存在，则另外定义映射。</target>
        </trans-unit>
        <trans-unit id="250b229660b09d1a93cecb0077c43fdb021bc44f" translate="yes" xml:space="preserve">
          <source>If the scalar contains a number the raw SV will be leaner.</source>
          <target state="translated">如果标量包含一个数字,那么原始的SV就会变瘦。</target>
        </trans-unit>
        <trans-unit id="129cba7aa8d1059953f619ec45963493064daafb" translate="yes" xml:space="preserve">
          <source>If the scalar from the previous example had an extra reference:</source>
          <target state="translated">如果前一个例子中的标量有一个额外的引用。</target>
        </trans-unit>
        <trans-unit id="942a6cfe1787a0e79c2fbf6e9025269b48593e53" translate="yes" xml:space="preserve">
          <source>If the script says that your package is incomplete, and asks whether to continue, just answer with Y (this can only happen if you don't use long filenames or forget to issue &quot;set FNCASE=y&quot; first).</source>
          <target state="translated">如果脚本说你的包不完整,并询问是否要继续,只需回答Y即可(这只可能发生在你没有使用长文件名或忘记先发出 &quot;set FNCASE=y &quot;的情况下)。</target>
        </trans-unit>
        <trans-unit id="1ebc636a0a5f78fe0991b4d30678c7a47413c67b" translate="yes" xml:space="preserve">
          <source>If the second argument to a piped &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; contains shell metacharacters, perl &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;s, then &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;s a shell to decode the metacharacters and eventually run the desired program. If the program couldn't be run, it's the shell that gets the message, not Perl. All your Perl program can find out is whether the shell itself could be successfully started. You can still capture the shell's STDERR and check it for error messages. See &lt;a href=&quot;#How-can-I-capture-STDERR-from-an-external-command%3f&quot;&gt;How can I capture STDERR from an external command?&lt;/a&gt; elsewhere in this document, or use the &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt; module.</source>
          <target state="translated">如果传递给管道的 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 的第二个参数包含shell元字符，perl &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; ，则 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 是shell来解码元字符并最终运行所需的程序。如果无法运行该程序，则是获取消息的外壳程序，而不是Perl。您的Perl程序所能找到的就是shell本身是否可以成功启动。您仍然可以捕获外壳程序的STDERR并检查它是否有错误消息。请参阅&lt;a href=&quot;#How-can-I-capture-STDERR-from-an-external-command%3f&quot;&gt;如何从外部命令捕获STDERR？&lt;/a&gt;或在本文档的其他地方使用&lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="4c86f791ed05e6400ffb0303d6157f674dcf38a9" translate="yes" xml:space="preserve">
          <source>If the second argument to a piped &lt;code&gt;open()&lt;/code&gt; contains shell metacharacters, perl &lt;code&gt;fork()&lt;/code&gt;s, then &lt;code&gt;exec()&lt;/code&gt;s a shell to decode the metacharacters and eventually run the desired program. If the program couldn't be run, it's the shell that gets the message, not Perl. All your Perl program can find out is whether the shell itself could be successfully started. You can still capture the shell's STDERR and check it for error messages. See &lt;a href=&quot;#How-can-I-capture-STDERR-from-an-external-command%3F&quot;&gt;&quot;How can I capture STDERR from an external command?&quot;&lt;/a&gt; elsewhere in this document, or use the &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt; module.</source>
          <target state="translated">如果传递给管道的 &lt;code&gt;open()&lt;/code&gt; 的第二个参数包含shell元字符，perl &lt;code&gt;fork()&lt;/code&gt; ，则 &lt;code&gt;exec()&lt;/code&gt; 是shell来解码元字符并最终运行所需的程序。如果无法运行该程序，则是获取消息的外壳程序，而不是Perl。您的Perl程序所能找到的就是shell本身是否可以成功启动。您仍然可以捕获外壳程序的STDERR并检查它是否有错误消息。请参阅&lt;a href=&quot;#How-can-I-capture-STDERR-from-an-external-command%3F&quot;&gt;&amp;ldquo;如何从外部命令捕获STDERR？&amp;rdquo;&lt;/a&gt;或在本文档的其他地方使用&lt;a href=&quot;IPC::Open3&quot;&gt;IPC :: Open3&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="6a485d6980d01df96f56ec659ef159a6f3e30c7c" translate="yes" xml:space="preserve">
          <source>If the second operand has a &quot;nomethod&quot; method then use that.</source>
          <target state="translated">如果第二个操作数有一个 &quot;nomethod &quot;方法,那么就用它。</target>
        </trans-unit>
        <trans-unit id="d89fc930c903cfb2489602dfe78fa395aab16a02" translate="yes" xml:space="preserve">
          <source>If the second parameter (a boolean) is omitted or false, the decomposition is canonical decomposition; if the second parameter (a boolean) is true, the decomposition is compatibility decomposition.</source>
          <target state="translated">如果第二个参数(布尔值)省略或为假,则分解为规范分解;如果第二个参数(布尔值)为真,则分解为兼容性分解。</target>
        </trans-unit>
        <trans-unit id="cdc3a4f8b493e77f4b46b059968dc0b38f7409ec" translate="yes" xml:space="preserve">
          <source>If the selected element is outside the string, the value 0 is returned. If an element off the end of the string is written to, Perl will first extend the string with sufficiently many zero bytes. It is an error to try to write off the beginning of the string (i.e., negative OFFSET).</source>
          <target state="translated">如果选中的元素在字符串之外,则返回值0。如果向字符串末端以外的元素写入,Perl会先用足够多的0字节扩展字符串。如果试图写掉字符串的开头(即负OFFSET),则是一个错误。</target>
        </trans-unit>
        <trans-unit id="a0efffe8f3cec0c66bc0076cfbf0d0f016059fa0" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will block until either the semaphore's count is greater than or equal to the amount you're &lt;code&gt;down&lt;/code&gt;ing the semaphore's count by, or until the timeout is reached.</source>
          <target state="translated">如果信号灯的计数降至零以下，则此方法将阻塞，直到信号灯的计数大于或等于您要 &lt;code&gt;down&lt;/code&gt; 信号灯的计数的数量，或者直到达到超时为止。</target>
        </trans-unit>
        <trans-unit id="08309d3b072967d3ab275a7c77649be9b9f2f474" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will block until such time as the semaphore's count is greater than or equal to the amount you're &lt;code&gt;down&lt;/code&gt; ing the semaphore's count by.</source>
          <target state="translated">如果信号量的计数降至零以下，则此方法将一直阻塞，直到信号量的计数大于或等于您要 &lt;code&gt;down&lt;/code&gt; 信号量计数的量。</target>
        </trans-unit>
        <trans-unit id="083a8e90721e210cc119c4e7060a13485c79131e" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will block until such time as the semaphore's count is greater than or equal to the amount you're &lt;code&gt;down&lt;/code&gt;ing the semaphore's count by.</source>
          <target state="translated">如果信号量的计数降至零以下，则该方法将一直阻塞，直到信号量的计数大于或等于您 &lt;code&gt;down&lt;/code&gt; 信号量计数所依据的量。</target>
        </trans-unit>
        <trans-unit id="49cf6efaba2d8b062462556a6172122cd62a7391" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will return</source>
          <target state="translated">如果semaphore的计数低于零,本方法将返回</target>
        </trans-unit>
        <trans-unit id="43da8fe1e0dfe354dcb09a89c8401b1d0438aefd" translate="yes" xml:space="preserve">
          <source>If the sequence contains a single code point which is unassigned to a character in the version of Unicode being used, the function will return TRUE, and the script will be &lt;code&gt;SCX_Unknown&lt;/code&gt;. Any other combination of unassigned code points in the input sequence will result in the function treating the input as not being a script run.</source>
          <target state="translated">如果序列包含一个未分配给使用的Unicode版本中的字符的单个代码点，则该函数将返回TRUE，并且脚本将为 &lt;code&gt;SCX_Unknown&lt;/code&gt; 。输入序列中未分配代码点的任何其他组合将导致该函数将输入视为不是脚本运行。</target>
        </trans-unit>
        <trans-unit id="ecadb78dff58886929648354bb050576d1075181" translate="yes" xml:space="preserve">
          <source>If the sequence is empty, TRUE is returned, but &lt;code&gt;*ret_script&lt;/code&gt; (if asked for) will be &lt;code&gt;SCX_INVALID&lt;/code&gt;.</source>
          <target state="translated">如果序列为空，则返回TRUE，但是 &lt;code&gt;*ret_script&lt;/code&gt; （如果要求）将为 &lt;code&gt;SCX_INVALID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="feaf413a0792a40fde39688dd7794f1b79d23f9d" translate="yes" xml:space="preserve">
          <source>If the shareable image isn't in any of these places, you'll need to define a logical name</source>
          <target state="translated">如果可共享图片不在这些地方,你需要定义一个逻辑名称。</target>
        </trans-unit>
        <trans-unit id="34b3b705ebfb832784afae8421a8cf44e644e9c0" translate="yes" xml:space="preserve">
          <source>If the socket is in a connected state, the peer address is returned. If the socket is not in a connected state, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">如果套接字处于连接状态，则返回对等地址。如果套接字未处于连接状态，则返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d77daa474d5b520bbe270f2db415132f8e51945" translate="yes" xml:space="preserve">
          <source>If the socket is in a connected state, the peer address is returned. If the socket is not in a connected state, undef is returned.</source>
          <target state="translated">如果套接字处于连接状态,则返回对等体地址。如果套接字不在连接状态,则返回undef。</target>
        </trans-unit>
        <trans-unit id="bc839afaf75ab77ac378c573dd37cfe67fada222" translate="yes" xml:space="preserve">
          <source>If the source number can be represented in the target form, that representation is used.</source>
          <target state="translated">如果源号可以用目标形式表示,则使用该表示。</target>
        </trans-unit>
        <trans-unit id="ad2456e62439e41ca828e4d7a559faef86d9a12f" translate="yes" xml:space="preserve">
          <source>If the source number is between two numbers representable in the target form, a representation of one of these numbers is used. (</source>
          <target state="translated">如果源数在两个可以用目标形式表示的数之间,则使用其中一个数的表示。(</target>
        </trans-unit>
        <trans-unit id="5807a3edb0534ce60ac2857df2fbffa4467c6e15" translate="yes" xml:space="preserve">
          <source>If the source number is outside of the limits representable in the target form, a representation of the closest limit is used. (</source>
          <target state="translated">如果源数在目标表格中可表示的限制之外,则使用最接近的限制表示。(</target>
        </trans-unit>
        <trans-unit id="a2b6fc7f507aeb4c29a8733766d6c6136c45fda9" translate="yes" xml:space="preserve">
          <source>If the special input filename &quot;&quot;, &quot;-&quot; or &quot;&amp;lt;&amp;amp;STDIN&quot; is given then the STDIN filehandle is used for input (and no open or close is performed). If no input filename is specified then &quot;-&quot; is implied. Filehandle references, or objects that support the regular IO operations (like &lt;code&gt;&amp;lt;$fh&amp;gt;&lt;/code&gt; or &lt;code&gt;$fh-&amp;lt;Egt&lt;/code&gt;getline&amp;gt;) are also accepted; the handles must already be opened.</source>
          <target state="translated">如果给出了特殊的输入文件名&amp;ldquo;&amp;rdquo;，&amp;ldquo;-&amp;rdquo;或&amp;ldquo; &amp;lt;＆STDIN&amp;rdquo;，那么将使用STDIN文件句柄进行输入（并且不执行打开或关闭操作）。如果未指定输入文件名，则意味着&amp;ldquo;-&amp;rdquo;。也接受文件句柄引用或支持常规IO操作的对象（如 &lt;code&gt;&amp;lt;$fh&amp;gt;&lt;/code&gt; 或 &lt;code&gt;$fh-&amp;lt;Egt&lt;/code&gt; getline&amp;gt;）；手柄必须已经打开。</target>
        </trans-unit>
        <trans-unit id="3247f1e5568a45232c218d52498138f8657c71b9" translate="yes" xml:space="preserve">
          <source>If the specification of the class was not completely valid, the message indicates that.</source>
          <target state="translated">如果该类的规范不完全有效,则该消息表明。</target>
        </trans-unit>
        <trans-unit id="0ec8f0307ac0cd29be9e31e20412d0003c85f12a" translate="yes" xml:space="preserve">
          <source>If the standard options aren't enough, you may want to subclass Pod::Simple::XHMTL. These are the most likely candidates for methods you'll want to override when subclassing.</source>
          <target state="translated">如果标准的选项还不够,你可能想要子类Pod::Simple::XHMTL。这些是你在子类时最有可能要覆盖的方法。</target>
        </trans-unit>
        <trans-unit id="c57481fa08ceb2f9368092d11351ebd6c6865947" translate="yes" xml:space="preserve">
          <source>If the string can not be interpreted, NaN is returned.</source>
          <target state="translated">如果字符串不能被解释,则返回NaN。</target>
        </trans-unit>
        <trans-unit id="fc03084e4b347434da04ee646a45ae6dc9795b98" translate="yes" xml:space="preserve">
          <source>If the string exception does not end in a newline, the current script line number and input line number (if any) and a newline are appended to it. Note that the &quot;input line number&quot; (also known as &quot;chunk&quot;) is subject to whatever notion of &quot;line&quot; happens to be currently in effect, and is also available as the special variable &lt;a href=&quot;perlvar#%24.&quot;&gt;&lt;code&gt;$.&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&quot;$/&quot; in perlvar&lt;/a&gt; and &lt;a href=&quot;perlvar#%24.&quot;&gt;&quot;$.&quot; in perlvar&lt;/a&gt;.</source>
          <target state="translated">如果字符串异常未以换行符结尾，则将当前脚本行号和输入行号（如果有）以及换行符附加在其后。请注意，&amp;ldquo;输入行号&amp;rdquo;（也称为&amp;ldquo;块&amp;rdquo;）受当前有效的任何&amp;ldquo;行&amp;rdquo;概念的约束，并且也可以作为特殊变量&lt;a href=&quot;perlvar#%24.&quot;&gt; &lt;code&gt;$.&lt;/code&gt; &lt;/a&gt;。请参见&lt;a href=&quot;perlvar#%24%2F&quot;&gt;perlvar中的&amp;ldquo; $ /&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;perlvar#%24.&quot;&gt;&amp;ldquo; $&amp;rdquo;。在perlvar中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61afcdbf0b63afa329f8dddf52dc441cb7c93f4b" translate="yes" xml:space="preserve">
          <source>If the string happens to be encoded as UTF-8 internally (and thus has the UTF8 flag set), &lt;a href=&quot;#vec-EXPR%2COFFSET%2CBITS&quot;&gt;&lt;code&gt;vec&lt;/code&gt;&lt;/a&gt; tries to convert it to use a one-byte-per-character internal representation. However, if the string contains characters with values of 256 or higher, a fatal error will occur.</source>
          <target state="translated">如果字符串恰好在内部被编码为UTF-8（因此设置了UTF8标志），则&lt;a href=&quot;#vec-EXPR%2COFFSET%2CBITS&quot;&gt; &lt;code&gt;vec&lt;/code&gt; &lt;/a&gt;尝试将其转换为使用每个字符一个字节的内部表示形式。但是，如果字符串包含的字符值为256或更高，则将发生致命错误。</target>
        </trans-unit>
        <trans-unit id="95c4f5fed91805150d0fb1f5cc265445f3719afe" translate="yes" xml:space="preserve">
          <source>If the string happens to be encoded as UTF-8 internally (and thus has the UTF8 flag set), this is ignored by &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, and it operates on the internal byte string, not the conceptual character string, even if you only have characters with values less than 256.</source>
          <target state="translated">如果字符串恰好在内部被编码为UTF-8（并因此设置了UTF8标志），则 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 会忽略该字符串，并且它将对内部字节字符串（而不是概念性字符串）进行操作，即使您仅使用值小于256。</target>
        </trans-unit>
        <trans-unit id="e46f7dff46b6e909ca2a4c0f1cd989e3474f6367" translate="yes" xml:space="preserve">
          <source>If the string happens to be encoded as UTF-8 internally (and thus has the UTF8 flag set), this is ignored by &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, and it operates on the internal byte string, not the conceptual character string, even if you only have characters with values less than 256.</source>
          <target state="translated">如果字符串恰好在内部被编码为UTF-8（并因此设置了UTF8标志），则 &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 会忽略该字符串，并且它将对内部字节字符串（而不是概念性字符串）进行操作，即使您仅使用值小于256。</target>
        </trans-unit>
        <trans-unit id="7652f3d26c3d783ee2b0cdbd7edb6550d6506acc" translate="yes" xml:space="preserve">
          <source>If the string has a &quot;0b&quot; prefix, it is interpreted as a binary number.</source>
          <target state="translated">如果字符串的前缀为 &quot;0b&quot;,则解释为二进制数。</target>
        </trans-unit>
        <trans-unit id="88ff0fdfcd38431066beb5169d3e97b3f28b4513" translate="yes" xml:space="preserve">
          <source>If the string has a &quot;0x&quot; prefix, it is interpreted as a hexadecimal number.</source>
          <target state="translated">如果字符串的前缀为 &quot;0x&quot;,则解释为十六进制数。</target>
        </trans-unit>
        <trans-unit id="556906a3727707516e15ba62fe70b3006b4bd52d" translate="yes" xml:space="preserve">
          <source>If the string is just one character in length, the Unicode numeric value is returned if it has one, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise. Note that this need not be a whole number. &lt;code&gt;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&lt;/code&gt; , for example returns -0.5.</source>
          <target state="translated">如果字符串长度只有一个字符，则返回Unicode数字值（如果包含一个字符），否则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。请注意，这不必是整数。 &lt;code&gt;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&lt;/code&gt; 例如返回-0.5。</target>
        </trans-unit>
        <trans-unit id="4fce93c48f5e7099a349c6ef5a41848fb5f748c7" translate="yes" xml:space="preserve">
          <source>If the string is just one character in length, the Unicode numeric value is returned if it has one, or &lt;code&gt;undef&lt;/code&gt; otherwise. If the optional scalar ref is passed, it would be set to 1 if the return is valid; or 0 if the return is &lt;code&gt;undef&lt;/code&gt;. Note that the numeric value returned need not be a whole number. &lt;code&gt;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&lt;/code&gt;, for example returns -0.5.</source>
          <target state="translated">如果字符串的长度仅为一个字符，则返回Unicode数字值（如果包含一个字符），否则返回 &lt;code&gt;undef&lt;/code&gt; 。如果传递了可选的标量ref，则在返回有效时将其设置为1；否则，将其设置为1。或0（如果返回为 &lt;code&gt;undef&lt;/code&gt; )。请注意，返回的数值不必是整数。 &lt;code&gt;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&lt;/code&gt; 例如返回-0.5。</target>
        </trans-unit>
        <trans-unit id="3c98175c6574b582a8455429e44a48ac7e74d895" translate="yes" xml:space="preserve">
          <source>If the string is more than one character, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned unless all its characters are decimal digits (that is, they would match &lt;code&gt;\d+&lt;/code&gt; ), from the same script. For example if you have an ASCII '0' and a Bengali '3', mixed together, they aren't considered a valid number, and &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned. A further restriction is that the digits all have to be of the same form. A half-width digit mixed with a full-width one will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. The Arabic script has two sets of digits; &lt;code&gt;num&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; unless all the digits in the string come from the same set.</source>
          <target state="translated">如果字符串不只一个字符，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，除非其所有字符都是十进制数字（即它们将匹配 &lt;code&gt;\d+&lt;/code&gt; ），都来自同一脚本。例如，如果您将ASCII'0'和孟加拉'3'混合在一起，则它们不会被视为有效数字，并返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。进一步的限制是所有数字都必须具有相同的形式。半角数字与全角数字混合将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。阿拉伯文字有两组数字；除非字符串中的所有数字都来自同一组，否则 &lt;code&gt;num&lt;/code&gt; 将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38c89008b47ecbaadc076b7aa2f24f0e7c6c9985" translate="yes" xml:space="preserve">
          <source>If the string is more than one character, &lt;code&gt;undef&lt;/code&gt; is returned unless all its characters are decimal digits (that is, they would match &lt;code&gt;\d+&lt;/code&gt;), from the same script. For example if you have an ASCII '0' and a Bengali '3', mixed together, they aren't considered a valid number, and &lt;code&gt;undef&lt;/code&gt; is returned. A further restriction is that the digits all have to be of the same form. A half-width digit mixed with a full-width one will return &lt;code&gt;undef&lt;/code&gt;. The Arabic script has two sets of digits; &lt;code&gt;num&lt;/code&gt; will return &lt;code&gt;undef&lt;/code&gt; unless all the digits in the string come from the same set. In all cases, the optional scalar ref parameter is set to how long any valid initial substring of digits is; hence it will be set to the entire string length if the main return value is not &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">如果字符串不止一个字符，则返回 &lt;code&gt;undef&lt;/code&gt; ，除非其所有字符都是十进制数字（也就是说，它们将匹配 &lt;code&gt;\d+&lt;/code&gt; ），都来自同一脚本。例如，如果您将ASCII'0'和孟加拉'3'混合在一起，则它们不会被视为有效数字，并且会返回 &lt;code&gt;undef&lt;/code&gt; 。进一步的限制是所有数字都必须具有相同的形式。半角数字与全角数字混合将返回 &lt;code&gt;undef&lt;/code&gt; 。阿拉伯文字有两组数字。 &lt;code&gt;num&lt;/code&gt; 将返回 &lt;code&gt;undef&lt;/code&gt; 除非字符串中的所有数字都来自同一集合。在所有情况下，可选的标量ref参数都设置为任何有效的初始数字子串的长度。因此，如果主返回值不是 &lt;code&gt;undef&lt;/code&gt; ，它将被设置为整个字符串的长度。</target>
        </trans-unit>
        <trans-unit id="4fc51a016846748fdbc037c08fcea8e548c16fe0" translate="yes" xml:space="preserve">
          <source>If the string used for the filename and/or comment is not valid UTF-8 when this option is true, the script will die with a &quot;wide character&quot; error.</source>
          <target state="translated">当这个选项为真时,如果用于文件名和/或注释的字符串不是有效的UTF-8,脚本将以 &quot;宽字符 &quot;错误而死。</target>
        </trans-unit>
        <trans-unit id="bc54c0830b9373d2798de2bf5260229a62e838a3" translate="yes" xml:space="preserve">
          <source>If the subroutine has one of a few special names, such as &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. Execution of the subroutine will likely be a no-op, unless &lt;code&gt;sv&lt;/code&gt; was a tied array or the caller modified the subroutine in some interesting way before it was executed. In the case of &lt;code&gt;BEGIN&lt;/code&gt;, the treatment is buggy: the sub will be executed when only half built, and may be deleted prematurely, possibly causing a crash.</source>
          <target state="translated">如果子例程具有一些特殊名称之一，例如 &lt;code&gt;BEGIN&lt;/code&gt; 或 &lt;code&gt;END&lt;/code&gt; ，则将由适当的队列声明该名称，以自动运行与阶段相关的子例程。在这种情况下，即使相关的glob之前包含一个子例程，它也将不包含任何子例程。除非 &lt;code&gt;sv&lt;/code&gt; 是一个绑定数组，或者调用者在执行之前以某种有趣的方式修改了子例程，否则该子例程的执行可能是无操作的。在 &lt;code&gt;BEGIN&lt;/code&gt; 的情况下，处理是有问题的：子程序将仅在构建一半时执行，并且可能会过早删除，从而可能导致崩溃。</target>
        </trans-unit>
        <trans-unit id="6c1db3945f60801d9fe74fe01151fa3c625ba2ad" translate="yes" xml:space="preserve">
          <source>If the subroutine has one of a few special names, such as &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. In the case of &lt;code&gt;BEGIN&lt;/code&gt;, the subroutine will be executed and the reference to it disposed of before this function returns, and also before its prototype is set. If a &lt;code&gt;BEGIN&lt;/code&gt; subroutine would not be sufficiently constructed by this function to be ready for execution then the caller must prevent this happening by giving the subroutine a different name.</source>
          <target state="translated">如果子例程具有一些特殊名称之一，例如 &lt;code&gt;BEGIN&lt;/code&gt; 或 &lt;code&gt;END&lt;/code&gt; ，则将由适当的队列声明该名称，以自动运行与阶段相关的子例程。在这种情况下，即使相关的glob之前包含一个子例程，它也将不包含任何子例程。在 &lt;code&gt;BEGIN&lt;/code&gt; 的情况下，将在该函数返回之前以及在设置其原型之前执行该子例程，并丢弃对该子例程的引用。如果此函数无法充分构造 &lt;code&gt;BEGIN&lt;/code&gt; 子例程以准备执行，则调用者必须通过给该子例程指定其他名称来防止这种情况的发生。</target>
        </trans-unit>
        <trans-unit id="bb58246d15f13a6f8775c588f89be7261648c55a" translate="yes" xml:space="preserve">
          <source>If the subroutine has one of a few special names, such as &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. In the case of &lt;code&gt;BEGIN&lt;/code&gt;, the subroutine will be executed and the reference to it disposed of before this function returns.</source>
          <target state="translated">如果子例程具有一些特殊名称之一，例如 &lt;code&gt;BEGIN&lt;/code&gt; 或 &lt;code&gt;END&lt;/code&gt; ，则将由适当的队列声明该名称，以自动运行与阶段相关的子例程。在这种情况下，即使相关的glob之前包含一个子例程，它也将不包含任何子例程。在 &lt;code&gt;BEGIN&lt;/code&gt; 的情况下，将在该函数返回之前执行该子例程并丢弃对该子例程的引用。</target>
        </trans-unit>
        <trans-unit id="b8c4922eb5c062cef768c57176fb78d4965487a5" translate="yes" xml:space="preserve">
          <source>If the subroutine is an XSUB, the elements to be compared are pushed on to the stack, the way arguments are usually passed to XSUBs. $a and $b are not set.</source>
          <target state="translated">如果子程序是XSUB,要比较的元素会被推到堆栈上,就像参数通常被传递给XSUB一样。$a和$b不被设置。</target>
        </trans-unit>
        <trans-unit id="1afca0c8662d7dc27c024fcc727c62d11480ea99" translate="yes" xml:space="preserve">
          <source>If the subroutine is an XSUB, the elements to be compared are pushed on to the stack, the way arguments are usually passed to XSUBs. &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are not set.</source>
          <target state="translated">如果子例程是XSUB，则将要比较的元素推入堆栈，通常将参数传递给XSUB的方式。 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 未设置。</target>
        </trans-unit>
        <trans-unit id="976151f66fa723fd3131374feb62ee8e2fa9f3b7" translate="yes" xml:space="preserve">
          <source>If the subroutine needs to signal an error, it should call die() with the desired error message as its argument. GetOptions() will catch the die(), issue the error message, and record that an error result must be returned upon completion.</source>
          <target state="translated">如果子程序需要发出错误信号,它应该调用die(),并将所需的错误信息作为参数。GetOptions()将捕获die(),发出错误信息,并记录完成后必须返回一个错误结果。</target>
        </trans-unit>
        <trans-unit id="40540ec0b48601a220c70ec78c454bb0e1f51c33" translate="yes" xml:space="preserve">
          <source>If the subroutine returns a scalar with a newline or a filehandle, it will be interpreted as raw TAP or as a TAP stream, respectively.</source>
          <target state="translated">如果子程序返回一个带换行的标量或filehandle,它将分别被解释为原始TAP或TAP流。</target>
        </trans-unit>
        <trans-unit id="ca613cca9ddf94b18fd3a6da5979f02e2a0a3fcf" translate="yes" xml:space="preserve">
          <source>If the subroutine's prototype is &lt;code&gt;($$)&lt;/code&gt; , the elements to be compared are passed by reference in &lt;code&gt;@_&lt;/code&gt; , as for a normal subroutine. This is slower than unprototyped subroutines, where the elements to be compared are passed into the subroutine as the package global variables $a and $b (see example below). Note that in the latter case, it is usually highly counter-productive to declare $a and $b as lexicals.</source>
          <target state="translated">如果子例程的原型是 &lt;code&gt;($$)&lt;/code&gt; ， &lt;code&gt;@_&lt;/code&gt; 进行比较的元素将通过@_引用传递，就像普通子例程一样。这比未原型的子例程要慢，在该例程中要比较的元素作为包全局变量$ a和$ b传递到子例程中（请参见下面的示例）。请注意，在后一种情况下，将$ a和$ b声明为词汇通常会适得其反。</target>
        </trans-unit>
        <trans-unit id="84b98f5d60037882d103faaf29e539e20c444828" translate="yes" xml:space="preserve">
          <source>If the subroutine's prototype is &lt;code&gt;($$)&lt;/code&gt;, the elements to be compared are passed by reference in &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt;, as for a normal subroutine. This is slower than unprototyped subroutines, where the elements to be compared are passed into the subroutine as the package global variables &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; (see example below).</source>
          <target state="translated">如果子例程的原型为 &lt;code&gt;($$)&lt;/code&gt; ，&lt;a href=&quot;perlvar#%40_&quot;&gt; &lt;code&gt;@_&lt;/code&gt; &lt;/a&gt;进行比较的元素将通过引用引用@_传递给普通子例程。这比未原型的子例程要慢，在该例程中，要比较的元素作为包全局变量 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 传递到子例程中（请参见下面的示例）。</target>
        </trans-unit>
        <trans-unit id="1b8a697c5090fd8ce94c13b5cefb41955f99b010" translate="yes" xml:space="preserve">
          <source>If the sv already is UTF-8 (or if it is not POK), or if the encoding is not a reference, nothing is done to the sv. If the encoding is not an &lt;code&gt;Encode::XS&lt;/code&gt; Encoding object, bad things will happen. (See</source>
          <target state="translated">如果sv已经是UTF-8（或者不是POK），或者编码不是参考，则不会对该sv执行任何操作。如果编码不是 &lt;code&gt;Encode::XS&lt;/code&gt; 编码对象，则会发生不良情况。（看到</target>
        </trans-unit>
        <trans-unit id="25e6d11786b2dfdb0f52678b6850a3dff8731c46" translate="yes" xml:space="preserve">
          <source>If the sv is the target of a weak reference then it returns the back references structure associated with the sv; otherwise return NULL.</source>
          <target state="translated">如果sv是弱引用的目标,那么它将返回与sv相关联的后引用结构;否则返回NULL。</target>
        </trans-unit>
        <trans-unit id="82b0821b14cc4cbb805ab8ac00aa5900da22e409" translate="yes" xml:space="preserve">
          <source>If the symbol &lt;code&gt;:void&lt;/code&gt; appears in the import list, then functions named later in that import list raise an exception only when these are called in void context--that is, when their return values are ignored. For example</source>
          <target state="translated">如果符号 &lt;code&gt;:void&lt;/code&gt; 出现在导入列表中，则稍后在该导入列表中命名的函数仅在void上下文中调用时（即，其返回值被忽略时）才会引发异常。例如</target>
        </trans-unit>
        <trans-unit id="50cf7df5061941de64a11ddf12781ae7a8f3290f" translate="yes" xml:space="preserve">
          <source>If the system Perl is compiled in has thread-safe variants of such calls, they will be used. Beyond that, Perl is at the mercy of the thread-safety or -unsafety of the calls. Please consult your C library call documentation.</source>
          <target state="translated">如果 Perl 编译的系统有这种调用的线程安全变体,就会使用它们。除此以外,Perl 将会受到这些调用的线程安全或不安全的影响。请参考你的 C 库调用文档。</target>
        </trans-unit>
        <trans-unit id="d5b1234bec481f7f0fb540471e8867994b10762a" translate="yes" xml:space="preserve">
          <source>If the target machine is little-endian, we could write:</source>
          <target state="translated">如果目标机是小字型,我们可以写。</target>
        </trans-unit>
        <trans-unit id="4756e731e627a9969d09a902907c109ca92f4013" translate="yes" xml:space="preserve">
          <source>If the template is not specified, a template is always automatically generated. This temporary file is placed in tmpdir() (&lt;a href=&quot;File::Spec&quot;&gt;File::Spec&lt;/a&gt;) unless a directory is specified explicitly with the DIR option.</source>
          <target state="translated">如果未指定模板，则始终自动生成模板。除非使用DIR选项明确指定目录，否则此临时文件将放置在tmpdir（）（&lt;a href=&quot;File::Spec&quot;&gt;File :: Spec&lt;/a&gt;）中。</target>
        </trans-unit>
        <trans-unit id="ff635540edd5aea28a885e06a80c5c6844ba7c11" translate="yes" xml:space="preserve">
          <source>If the template is not specified, a template is always automatically generated. This temporary file is placed in tmpdir() (L&amp;lt;:spec&amp;gt;) unless a directory is specified explicitly with the DIR option.</source>
          <target state="translated">如果未指定模板，则始终自动生成模板。除非使用DIR选项明确指定目录，否则此临时文件将放置在tmpdir（）（L &amp;lt;：spec&amp;gt;）中。</target>
        </trans-unit>
        <trans-unit id="593ec0746d963b28de5ba2cf0799b3f4777c63c7" translate="yes" xml:space="preserve">
          <source>If the temporary file can not be created undef is returned. Currently this command will probably not work when the temporary directory is on an NFS file system.</source>
          <target state="translated">如果不能创建临时文件,则返回undef。目前,当临时目录在NFS文件系统上时,该命令可能无法使用。</target>
        </trans-unit>
        <trans-unit id="326e7cf804954bda3811121b38cb7c631e7575fe" translate="yes" xml:space="preserve">
          <source>If the terminating string is quoted, the type of quotes used determine the treatment of the text.</source>
          <target state="translated">如果终止字符串被引用,使用的引号类型决定了文本的处理方式。</target>
        </trans-unit>
        <trans-unit id="957eb5ae659823f7ba1c0183ec0ac873de8b4109" translate="yes" xml:space="preserve">
          <source>If the test is unplanned, this method will always return false. See &lt;code&gt;is_unplanned&lt;/code&gt; .</source>
          <target state="translated">如果计划外的测试，则此方法将始终返回false。参见 &lt;code&gt;is_unplanned&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20d3ba6a3f24850f51b5f59f10528892b52a140e" translate="yes" xml:space="preserve">
          <source>If the test is unplanned, this method will always return false. See &lt;code&gt;is_unplanned&lt;/code&gt;.</source>
          <target state="translated">如果计划外的测试，则此方法将始终返回false。参见 &lt;code&gt;is_unplanned&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bfabe273698ccd033cf292d0d277e005ca02c57" translate="yes" xml:space="preserve">
          <source>If the tests fail &lt;code&gt;prove&lt;/code&gt; will exit with non-zero status.</source>
          <target state="translated">如果测试失败，则 &lt;code&gt;prove&lt;/code&gt; 将以非零状态退出。</target>
        </trans-unit>
        <trans-unit id="269c79628ff3b9a7faad565d0d36f6d320d9b282" translate="yes" xml:space="preserve">
          <source>If the text of the L&amp;lt;&amp;gt; escape is entirely enclosed in double quotes, it's interpreted as a link to a section for backward compatibility.</source>
          <target state="translated">如果L &amp;lt;&amp;gt;转义符的文本完全用双引号引起来，则将其解释为指向节的链接，以实现向后兼容。</target>
        </trans-unit>
        <trans-unit id="f92e03b607dab58b8f2f2e3c224ccb0a3fc3ca6c" translate="yes" xml:space="preserve">
          <source>If the text of the error message starts with an exclamation mark &lt;code&gt;!&lt;/code&gt; it is interpreted specially by GetOptions(). There is currently one special command implemented: &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die(&quot;!FINISH&quot;)&lt;/a&gt;&lt;/code&gt; will cause GetOptions() to stop processing options, as if it encountered a double dash &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">如果错误消息的文本以感叹号开头 &lt;code&gt;!&lt;/code&gt; 它由GetOptions（）专门解释。当前实现了一个特殊命令： &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die(&quot;!FINISH&quot;)&lt;/a&gt;&lt;/code&gt; 将导致GetOptions（）停止处理选项，就像遇到了双破折号 &lt;code&gt;--&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d332109bf38a18b83347b1abe4af5018dfcf4a0" translate="yes" xml:space="preserve">
          <source>If the text of the error message starts with an exclamation mark &lt;code&gt;!&lt;/code&gt; it is interpreted specially by GetOptions(). There is currently one special command implemented: &lt;code&gt;die(&quot;!FINISH&quot;)&lt;/code&gt; will cause GetOptions() to stop processing options, as if it encountered a double dash &lt;code&gt;--&lt;/code&gt;.</source>
          <target state="translated">如果错误消息的文本以感叹号开头 &lt;code&gt;!&lt;/code&gt; 它由GetOptions（）专门解释。当前实现了一个特殊的命令： &lt;code&gt;die(&quot;!FINISH&quot;)&lt;/code&gt; 将导致GetOptions（）停止处理选项，就好像遇到了双破折号 &lt;code&gt;--&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54a21a0dcb36b1ce3d43912ccebce5a460b97864" translate="yes" xml:space="preserve">
          <source>If the third argument is</source>
          <target state="translated">如果第三个参数是</target>
        </trans-unit>
        <trans-unit id="b232866b6ad063c73d4ad37ea476edb565d6de63" translate="yes" xml:space="preserve">
          <source>If the third argument,</source>
          <target state="translated">如果第三个论点。</target>
        </trans-unit>
        <trans-unit id="66bf0740d3ced4e3ce4166e93bb8bdf81549240a" translate="yes" xml:space="preserve">
          <source>If the thread being &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;ed &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;d, the error it died with will be returned at this time. If you don't want the thread performing the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; to die as well, you should either wrap the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or use the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; thread method instead of &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果线程之中 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 编 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; d，它与死去的错误会在这个时候被退回。如果您不希望执行 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 的线程也消失，则应该将 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 包装在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中,或者使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; thread方法而不是 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a5af2f1be44751c2177059f4e6af4dd499466cc" translate="yes" xml:space="preserve">
          <source>If the thread being &lt;code&gt;join&lt;/code&gt;ed &lt;code&gt;die&lt;/code&gt;d, the error it died with will be returned at this time. If you don't want the thread performing the &lt;code&gt;join&lt;/code&gt; to die as well, you should either wrap the &lt;code&gt;join&lt;/code&gt; in an &lt;code&gt;eval&lt;/code&gt; or use the &lt;code&gt;eval&lt;/code&gt; thread method instead of &lt;code&gt;join&lt;/code&gt;.</source>
          <target state="translated">如果线程之中 &lt;code&gt;join&lt;/code&gt; 编 &lt;code&gt;die&lt;/code&gt; d，它与死去的错误会在这个时候被退回。如果您不希望执行 &lt;code&gt;join&lt;/code&gt; 的线程也消失，则应将 &lt;code&gt;join&lt;/code&gt; 包装在 &lt;code&gt;eval&lt;/code&gt; 中,或者使用 &lt;code&gt;eval&lt;/code&gt; thread方法而不是 &lt;code&gt;join&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2279b2f8b74fd7d772a6ba18eb3177b3a248c49d" translate="yes" xml:space="preserve">
          <source>If the timeout is reached, this method will return</source>
          <target state="translated">如果达到超时,本方法将返回</target>
        </trans-unit>
        <trans-unit id="3cd970acc5e28ee89d2e82334dde273c65bae5b7" translate="yes" xml:space="preserve">
          <source>If the title can't be found, then get_short_title returns empty-string (&quot;&quot;).</source>
          <target state="translated">如果找不到标题,那么get_short_title返回空字符串(&quot;&quot;)。</target>
        </trans-unit>
        <trans-unit id="697a489e14d5b870ec5510bd4b458c67ab45bad8" translate="yes" xml:space="preserve">
          <source>If the typeglob &lt;code&gt;gv&lt;/code&gt; can be expressed more succinctly, by having something other than a real GV in its place in the stash, replace it with the optimised form. Basic requirements for this are that &lt;code&gt;gv&lt;/code&gt; is a real typeglob, is sufficiently ordinary, and is only referenced from its package. This function is meant to be used when a GV has been looked up in part to see what was there, causing upgrading, but based on what was found it turns out that the real GV isn't required after all.</source>
          <target state="translated">如果可以通过在存储区中放置除真实GV之外的其他内容来更简洁地表示typeglob &lt;code&gt;gv&lt;/code&gt; ，请用优化形式替换它。对此的基本要求是 &lt;code&gt;gv&lt;/code&gt; 是一个实类型的glob，足够普通，并且只能从其包中引用。当部分地查看GV以查看其中存在的内容并导致升级时，可以使用此功能，但是基于找到的结果，事实证明根本不需要真正的GV。</target>
        </trans-unit>
        <trans-unit id="7e317e256420ab2a48b2f7e7b312c3d9f416e521" translate="yes" xml:space="preserve">
          <source>If the underlying &lt;code&gt;IO::Handle&lt;/code&gt; is closed, or if there are any read or write failures, the file handle will be forced closed, and &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Connection closed&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt; ). The _set_status_closed() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="translated">如果底层的 &lt;code&gt;IO::Handle&lt;/code&gt; 已关闭，或者存在任何读取或写入失败，则将强制关闭文件句柄，并且 &lt;code&gt;code()&lt;/code&gt; 将返回&amp;ldquo; 421&amp;rdquo;（临时连接失败），而 &lt;code&gt;message()&lt;/code&gt; 将返回&amp;ldquo; [ $ pkg]&amp;ldquo;连接已关闭&amp;rdquo;（其中$ pkg是 &lt;code&gt;Net::Cmd&lt;/code&gt; 子类的名称）。可以重写_set_status_closed（）方法以设置其他消息（通过调用set_status（）），否则可以捕获此错误。</target>
        </trans-unit>
        <trans-unit id="1e77ce40e4dd7efc2c043a17aee5d821a48fe672" translate="yes" xml:space="preserve">
          <source>If the underlying &lt;code&gt;IO::Handle&lt;/code&gt; is closed, or if there are any read or write failures, the file handle will be forced closed, and &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Connection closed&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt;). The _set_status_closed() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="translated">如果底层的 &lt;code&gt;IO::Handle&lt;/code&gt; 已关闭，或者存在任何读取或写入失败，则将强制关闭文件句柄，并且 &lt;code&gt;code()&lt;/code&gt; 将返回&amp;ldquo; 421&amp;rdquo;（临时连接失败），而 &lt;code&gt;message()&lt;/code&gt; 将返回&amp;ldquo; [ $ pkg]&amp;ldquo;连接已关闭&amp;rdquo;（其中$ pkg是 &lt;code&gt;Net::Cmd&lt;/code&gt; 子类的名称）。可以重写_set_status_closed（）方法以设置其他消息（通过调用set_status（）），否则可以捕获此错误。</target>
        </trans-unit>
        <trans-unit id="cdc3b2cf894256f273b0349af8d5d688d0cdcb39" translate="yes" xml:space="preserve">
          <source>If the user builds a shared</source>
          <target state="translated">如果用户建立了一个共享</target>
        </trans-unit>
        <trans-unit id="32324af5745fb70c85007da7a27faa556a189cfd" translate="yes" xml:space="preserve">
          <source>If the user didn't specify anything, it's interpreted as having used the &lt;code&gt;please&lt;/code&gt; tag. It's up to you to make this useful.</source>
          <target state="translated">如果用户未指定任何内容，则解释为使用了 &lt;code&gt;please&lt;/code&gt; 标签。有用的取决于您。</target>
        </trans-unit>
        <trans-unit id="cd074d1ec9315994a5770ffd227be188d8ea3674" translate="yes" xml:space="preserve">
          <source>If the user does not have HTML::Lint installed, the whole block of code</source>
          <target state="translated">如果用户没有安装HTML::Lint,则整个代码块会在</target>
        </trans-unit>
        <trans-unit id="b39c8811f479889c6eabed43038bf7a333557852" translate="yes" xml:space="preserve">
          <source>If the user has superuser privileges, and is not working on AFS or relatives, then the defaults for INSTALLPRIVLIB, INSTALLARCHLIB, INSTALLSCRIPT, etc. will be appropriate, and this incantation will be the best:</source>
          <target state="translated">如果用户有超级用户权限,而且不是在AFS或亲属上工作,那么INSTALLPRIVLIB、INSTALLARCHLIB、INSTALLSCRIPT等默认值就合适了,这个咒语最好。</target>
        </trans-unit>
        <trans-unit id="3d9745c4616cab220c27715466f7a222d8b72268" translate="yes" xml:space="preserve">
          <source>If the value</source>
          <target state="translated">如果该值</target>
        </trans-unit>
        <trans-unit id="1676523b419ae746e43ad6553d2687aea42c504e" translate="yes" xml:space="preserve">
          <source>If the value doesn't match the 'make' program you want to use, edit Config.pm to fix it.</source>
          <target state="translated">如果该值与你要使用的'make'程序不匹配,请编辑Config.pm来修正它。</target>
        </trans-unit>
        <trans-unit id="9aa86f4743abc7079a416abc9073771271ff4394" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; it is returned as a UV, the output flags are clear, and nothing is written to</source>
          <target state="translated">如果该值&amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; ,则将其作为UV返回，清除输出标志，并且不写入任何内容</target>
        </trans-unit>
        <trans-unit id="69db17f26df78ff9935057c8c72522c8171dedc4" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; it is returned as a UV, the output flags are clear, and nothing is written to &lt;code&gt;*result&lt;/code&gt;. If the value is &amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt;, &lt;code&gt;grok_bin&lt;/code&gt; returns &lt;code&gt;UV_MAX&lt;/code&gt;, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes an approximation of the correct value into &lt;code&gt;*result&lt;/code&gt; (which is an NV; or the approximation is discarded if &lt;code&gt;result&lt;/code&gt; is NULL).</source>
          <target state="translated">如果值&amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; ,则将其作为UV返回，输出标志将清除，并且不会将任何内容写入 &lt;code&gt;*result&lt;/code&gt; 。如果值&amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt; ，则 &lt;code&gt;grok_bin&lt;/code&gt; 返回 &lt;code&gt;UV_MAX&lt;/code&gt; ，在输出标志中设置 &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; ，并将正确值的近似值写入 &lt;code&gt;*result&lt;/code&gt; （它是NV；如果 &lt;code&gt;result&lt;/code&gt; 为NULL，则近似值将被丢弃）。</target>
        </trans-unit>
        <trans-unit id="b33edf1191e45f2f7c173468860c56b9c68eec7c" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; it is returned as a UV, the output flags are clear, and nothing is written to &lt;code&gt;*result&lt;/code&gt;. If the value is &amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt;, &lt;code&gt;grok_hex&lt;/code&gt; returns &lt;code&gt;UV_MAX&lt;/code&gt;, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes an approximation of the correct value into &lt;code&gt;*result&lt;/code&gt; (which is an NV; or the approximation is discarded if &lt;code&gt;result&lt;/code&gt; is NULL).</source>
          <target state="translated">如果值&amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; ,则将其作为UV返回，输出标志将清除，并且不会将任何内容写入 &lt;code&gt;*result&lt;/code&gt; 。如果值&amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt; ，则 &lt;code&gt;grok_hex&lt;/code&gt; 返回 &lt;code&gt;UV_MAX&lt;/code&gt; ，在输出标志中设置 &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; ，并将正确值的近似值写入 &lt;code&gt;*result&lt;/code&gt; （它是NV；如果 &lt;code&gt;result&lt;/code&gt; 为NULL，则近似值将被丢弃）。</target>
        </trans-unit>
        <trans-unit id="11949fed265c94f0f9f0cc1d3c0a3164a55a86d5" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; it is returned as a UV, the output flags are clear, and nothing is written to &lt;code&gt;*result&lt;/code&gt;. If the value is &amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt;, &lt;code&gt;grok_oct&lt;/code&gt; returns &lt;code&gt;UV_MAX&lt;/code&gt;, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes an approximation of the correct value into &lt;code&gt;*result&lt;/code&gt; (which is an NV; or the approximation is discarded if &lt;code&gt;result&lt;/code&gt; is NULL).</source>
          <target state="translated">如果值&amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; ,则将其作为UV返回，输出标志将清除，并且不会将任何内容写入 &lt;code&gt;*result&lt;/code&gt; 。如果值&amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt; ，则 &lt;code&gt;grok_oct&lt;/code&gt; 返回 &lt;code&gt;UV_MAX&lt;/code&gt; ，在输出标志中设置 &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; ，并将正确值的近似值写入 &lt;code&gt;*result&lt;/code&gt; （它是NV；如果 &lt;code&gt;result&lt;/code&gt; 为NULL，则近似值将被丢弃）。</target>
        </trans-unit>
        <trans-unit id="bd15952acdcd265d4f18a816b3be548c37a82d83" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= UV_MAX it is returned as a UV, the output flags are clear, and nothing is written to</source>
          <target state="translated">如果该值&amp;lt;= UV_MAX，则将其作为UV返回，清除输出标志，并且不写入任何内容</target>
        </trans-unit>
        <trans-unit id="c10d8690679793d91d603d7249997075229bffed" translate="yes" xml:space="preserve">
          <source>If the value is a coderef, we return &amp;amp;$value($lh, ...parameters...).</source>
          <target state="translated">如果该值是一个代码引用，则返回＆$ value（$ lh，... parameters ...）。</target>
        </trans-unit>
        <trans-unit id="ef50a320b2209faad43a3f8213d92ea4b618e424" translate="yes" xml:space="preserve">
          <source>If the value is a scalarref, the scalar is dereferenced and returned (and any parameters are ignored).</source>
          <target state="translated">如果值是一个标量ref,则标量会被取消引用并返回(并且忽略任何参数)。</target>
        </trans-unit>
        <trans-unit id="6f950a468109b8d39520112d3f58effdc56407fc" translate="yes" xml:space="preserve">
          <source>If the value is a string that</source>
          <target state="translated">如果值是一个字符串,那么</target>
        </trans-unit>
        <trans-unit id="034aa5dfb1d3fc388ace8815e3c3af316b7fe0f0" translate="yes" xml:space="preserve">
          <source>If the value is true, then the appropriate pragma is assumed to be in the ambient scope, otherwise not.</source>
          <target state="translated">如果该值为真,则假定相应的pragma在环境范围内,否则不在。</target>
        </trans-unit>
        <trans-unit id="c4b0ded1a1deef22b5fab46f3c6efeda2921b5b8" translate="yes" xml:space="preserve">
          <source>If the value of</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="3679a65190bd3883b712c84ff2c3ed51da02c8c9" translate="yes" xml:space="preserve">
          <source>If the value of the number can fit in a UV, it is returned in &lt;code&gt;*valuep&lt;/code&gt;. &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; will be set to indicate that &lt;code&gt;*valuep&lt;/code&gt; is valid, &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; will never be set unless &lt;code&gt;*valuep&lt;/code&gt; is valid, but &lt;code&gt;*valuep&lt;/code&gt; may have been assigned to during processing even though &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; is not set on return. If &lt;code&gt;valuep&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; will be set for the same cases as when &lt;code&gt;valuep&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt;, but no actual assignment (or SEGV) will occur.</source>
          <target state="translated">如果该数字的值适合UV，则在 &lt;code&gt;*valuep&lt;/code&gt; 中返回它。 &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; 将被设置为表明 &lt;code&gt;*valuep&lt;/code&gt; 是有效的， &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; 永远不会设置，除非 &lt;code&gt;*valuep&lt;/code&gt; 是有效的，但 &lt;code&gt;*valuep&lt;/code&gt; 可能已经即使在加工过程中分配给 &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; 未设置上的回报。如果 &lt;code&gt;valuep&lt;/code&gt; 为 &lt;code&gt;NULL&lt;/code&gt; ， &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; 在与 &lt;code&gt;valuep&lt;/code&gt; 为非 &lt;code&gt;NULL&lt;/code&gt; 的情况相同的情况下设置IS_NUMBER_IN_UV，但不会发生实际分配（或SEGV）。</target>
        </trans-unit>
        <trans-unit id="3799e4ea2da2d340ca2beed8a5872250c216eb41" translate="yes" xml:space="preserve">
          <source>If the value of the number can fit in a UV, it is returned in the *valuep IS_NUMBER_IN_UV will be set to indicate that *valuep is valid, IS_NUMBER_IN_UV will never be set unless *valuep is valid, but *valuep may have been assigned to during processing even though IS_NUMBER_IN_UV is not set on return. If valuep is NULL, IS_NUMBER_IN_UV will be set for the same cases as when valuep is non-NULL, but no actual assignment (or SEGV) will occur.</source>
          <target state="translated">如果数字的值可以容纳在一个UV中,则在*valuep中返回IS_NUMBER_IN_UV将被设置为表示*valuep是有效的,除非*valuep是有效的,否则IS_NUMBER_IN_UV将永远不会被设置,但*valuep可能在处理过程中被分配到,即使IS_NUMBER_IN_UV在返回时没有被设置。如果valuep为NULL,IS_NUMBER_IN_UV将被设置,与valuep为非NULL时的情况相同,但不会发生实际的分配(或SEGV)。</target>
        </trans-unit>
        <trans-unit id="d417792987cefdc8fbbad820c7047930346b40c5" translate="yes" xml:space="preserve">
          <source>If the value to pack is too long, the result is truncated. If it's too long and an explicit count is provided, &lt;code&gt;Z&lt;/code&gt; packs only &lt;code&gt;$count-1&lt;/code&gt; bytes, followed by a null byte. Thus &lt;code&gt;Z&lt;/code&gt; always packs a trailing null, except when the count is 0.</source>
          <target state="translated">如果要打包的值太长，结果将被截断。如果太长并且提供了显式计数，则 &lt;code&gt;Z&lt;/code&gt; 仅打包 &lt;code&gt;$count-1&lt;/code&gt; 个字节，后跟一个空字节。因此，除非计数为0，否则 &lt;code&gt;Z&lt;/code&gt; 总是打包结尾的null。</target>
        </trans-unit>
        <trans-unit id="2b18faee7915986e7efaa1de04f931c2b8c71f1c" translate="yes" xml:space="preserve">
          <source>If the values are all small integers, you could use a simple indexed array. This kind of an array will take up less space:</source>
          <target state="translated">如果值都是小整数,你可以使用一个简单的索引数组。这种数组会占用较少的空间。</target>
        </trans-unit>
        <trans-unit id="5cc9e16e91b4a8896cd9faaa5f9549cbc7085c8f" translate="yes" xml:space="preserve">
          <source>If the values in question are integers instead of strings, you can save quite a lot of space by using bit strings instead:</source>
          <target state="translated">如果所涉及的值是整数而不是字符串,你可以通过使用比特字符串来节省不少空间。</target>
        </trans-unit>
        <trans-unit id="82319500e10e873dfa0526d703945d89b55231f8" translate="yes" xml:space="preserve">
          <source>If the values of &lt;code&gt;$mod&lt;/code&gt; and &lt;code&gt;$prereq&lt;/code&gt; have not been scrubbed, however, this presents security implications.</source>
          <target state="translated">但是，如果未 &lt;code&gt;$prereq&lt;/code&gt; &lt;code&gt;$mod&lt;/code&gt; 和$ prereq的值，则表示安全性。</target>
        </trans-unit>
        <trans-unit id="73e7da39372f108fea1077e432f6f8a5490ef1c9" translate="yes" xml:space="preserve">
          <source>If the variable is locked by another thread, the &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; call will block until it's available. &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; is recursive, so multiple calls to &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; are safe--the variable will remain locked until the outermost lock on the variable goes out of scope.</source>
          <target state="translated">如果变量被另一个线程锁定，则 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 调用将阻塞，直到可用为止。 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 是递归的，因此多次调用 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 是安全的-变量将保持锁定状态，直到变量的最外面的锁超出范围为止。</target>
        </trans-unit>
        <trans-unit id="d43da14411193cb05153c9413f27d1e7c410d9b1" translate="yes" xml:space="preserve">
          <source>If the variable is locked by another thread, the &lt;code&gt;lock&lt;/code&gt; call will block until it's available. &lt;code&gt;lock&lt;/code&gt; is recursive, so multiple calls to &lt;code&gt;lock&lt;/code&gt; are safe--the variable will remain locked until the outermost lock on the variable goes out of scope.</source>
          <target state="translated">如果变量被另一个线程锁定，则 &lt;code&gt;lock&lt;/code&gt; 调用将阻塞，直到可用为止。 &lt;code&gt;lock&lt;/code&gt; 是递归的，因此多次调用 &lt;code&gt;lock&lt;/code&gt; 是安全的-变量将保持锁定状态，直到变量的最外面的锁超出范围为止。</target>
        </trans-unit>
        <trans-unit id="82a274850c71686d34e3baa803737f0dedda24d3" translate="yes" xml:space="preserve">
          <source>If the variable is not set, or if the head of space-separated list is empty, the best available package is loaded.</source>
          <target state="translated">如果变量没有设置,或者空格分隔的列表头为空,则加载最佳的可用包。</target>
        </trans-unit>
        <trans-unit id="332df1267de6f0a87c793832b4c5597a101a667d" translate="yes" xml:space="preserve">
          <source>If the warning comes from other than I/O, this diagnostic probably indicates that incorrect results are being obtained. You should examine your code to determine how a wide character is getting to an operation that doesn't handle them.</source>
          <target state="translated">如果警告来自I/O以外的其他地方,这个诊断可能表明正在获得不正确的结果。你应该检查你的代码,以确定宽字符是如何进入一个不处理它们的操作的。</target>
        </trans-unit>
        <trans-unit id="80b83d018cb7a8db8be65fb54c56d8b5b7e8cb24" translate="yes" xml:space="preserve">
          <source>If the warnings category, &lt;code&gt;$category&lt;/code&gt; , has been set to &quot;FATAL&quot; in the calling module then die. Otherwise return.</source>
          <target state="translated">如果在调用模块中将警告类别 &lt;code&gt;$category&lt;/code&gt; 设置为&amp;ldquo; FATAL&amp;rdquo;，则死机。否则返回。</target>
        </trans-unit>
        <trans-unit id="834ab1c45a3f45ffae4b5d0f33ce4babb0604bab" translate="yes" xml:space="preserve">
          <source>If the warnings category, &lt;code&gt;$category&lt;/code&gt;, has been set to &quot;FATAL&quot; in the calling module then die. Otherwise return.</source>
          <target state="translated">如果在调用模块中将警告类别 &lt;code&gt;$category&lt;/code&gt; 设置为&amp;ldquo; FATAL&amp;rdquo;，则死机。否则返回。</target>
        </trans-unit>
        <trans-unit id="a5e41570d4b0ba06d69d1ed0ddaa70c09dffea4d" translate="yes" xml:space="preserve">
          <source>If the whole program is Unicode (signified by using 8-bit &lt;b&gt;U&lt;/b&gt;nicode &lt;b&gt;T&lt;/b&gt;ransformation &lt;b&gt;F&lt;/b&gt;ormat), then all literal strings within it must be Unicode.</source>
          <target state="translated">如果整个程序是Unicode（通过使用8位所指&lt;b&gt;&amp;ugrave;&lt;/b&gt; nicode &lt;b&gt;Ť&lt;/b&gt; ransformation &lt;b&gt;˚F&lt;/b&gt; ORMAT），然后在其内的所有的文字串必须是Unicode。</target>
        </trans-unit>
        <trans-unit id="9de09cf9a89a26f0cb448619847689ec2527d3db" translate="yes" xml:space="preserve">
          <source>If the whole program is Unicode (signified by using 8-bit &lt;b&gt;U&lt;/b&gt;nicode &lt;b&gt;T&lt;/b&gt;ransformation &lt;b&gt;F&lt;/b&gt;ormat), then all strings within it must be Unicode.</source>
          <target state="translated">如果整个程序是Unicode（通过使用8位所指&lt;b&gt;&amp;ugrave;&lt;/b&gt; nicode &lt;b&gt;Ť&lt;/b&gt; ransformation &lt;b&gt;˚F&lt;/b&gt; ORMAT），然后在其内的所有字符串必须是Unicode。</target>
        </trans-unit>
        <trans-unit id="9cdf7f58b72ea89ccbb496e2eb6b9b4bc7fadaa5" translate="yes" xml:space="preserve">
          <source>If the word &lt;code&gt;while&lt;/code&gt; is replaced by the word &lt;code&gt;until&lt;/code&gt; , the sense of the test is reversed, but the conditional is still tested before the first iteration.</source>
          <target state="translated">如果将 &lt;code&gt;while&lt;/code&gt; 单词替换为 &lt;code&gt;until&lt;/code&gt; 单词，则测试的意义相反，但是在第一次迭代之前仍对条件语句进行测试。</target>
        </trans-unit>
        <trans-unit id="bb24c8d0dff7253263fabb1012737a1c5185daa5" translate="yes" xml:space="preserve">
          <source>If the word &lt;code&gt;while&lt;/code&gt; is replaced by the word &lt;code&gt;until&lt;/code&gt;, the sense of the test is reversed, but the conditional is still tested before the first iteration.</source>
          <target state="translated">如果将 &lt;code&gt;while&lt;/code&gt; 单词替换为 &lt;code&gt;until&lt;/code&gt; 单词，则测试的意义相反，但是在第一次迭代之前仍对条件语句进行测试。</target>
        </trans-unit>
        <trans-unit id="10166029e96e7fe67231308fbe3c16515584c847" translate="yes" xml:space="preserve">
          <source>If there are additional casing rules that apply only in certain locales, an additional key for each will be defined in the returned hash. Each such key will be its locale name, defined as a 2-letter ISO 3166 country code, possibly followed by a &quot;_&quot; and a 2-letter ISO language code (possibly followed by a &quot;_&quot; and a variant code). You can find the lists of all possible locales, see &lt;a href=&quot;../locale/country&quot;&gt;Locale::Country&lt;/a&gt; and &lt;a href=&quot;../locale/language&quot;&gt;Locale::Language&lt;/a&gt;. (In Unicode 6.0, the only locales returned by this function are &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;az&lt;/code&gt; .)</source>
          <target state="translated">如果还有其他仅适用于特定语言环境的大小写规则，则将在返回的哈希中定义每个规则的其他键。每个这样的键都是其区域名称，定义为2个字母的ISO 3166国家/地区代码，可能后跟一个&amp;ldquo; _&amp;rdquo;和一个2个字母的ISO语言代码（可能后跟一个&amp;ldquo; _&amp;rdquo;和一个变体代码）。您可以找到所有可能的语言环境的列表，请参见&lt;a href=&quot;../locale/country&quot;&gt;Locale :: Country&lt;/a&gt;和&lt;a href=&quot;../locale/language&quot;&gt;Locale :: Language&lt;/a&gt;。 （在Unicode 6.0中，此函数返回的唯一语言环境是 &lt;code&gt;lt&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;az&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="c9b92a1c0c95f09069f2ada78514b6761e600855" translate="yes" xml:space="preserve">
          <source>If there are additional casing rules that apply only in certain locales, an additional key for each will be defined in the returned hash. Each such key will be its locale name, defined as a 2-letter ISO 3166 country code, possibly followed by a &quot;_&quot; and a 2-letter ISO language code (possibly followed by a &quot;_&quot; and a variant code). You can find the lists of all possible locales, see &lt;a href=&quot;Locale::Country&quot;&gt;Locale::Country&lt;/a&gt; and &lt;a href=&quot;Locale::Language&quot;&gt;Locale::Language&lt;/a&gt;. (In Unicode 6.0, the only locales returned by this function are &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;tr&lt;/code&gt;, and &lt;code&gt;az&lt;/code&gt;.)</source>
          <target state="translated">如果还有其他仅适用于某些语言环境的大小写规则，则将在返回的哈希中定义每个大小写的附加键。每个这样的键都是其语言环境名称，定义为2个字母的ISO 3166国家/地区代码，可能后跟&amp;ldquo; _&amp;rdquo;和2个字母的ISO语言代码（可能后跟&amp;ldquo; _&amp;rdquo;和变体代码）。您可以找到所有可能的语言环境的列表，请参见&lt;a href=&quot;Locale::Country&quot;&gt;Locale :: Country&lt;/a&gt;和&lt;a href=&quot;Locale::Language&quot;&gt;Locale :: Language&lt;/a&gt;。（在Unicode 6.0中，此函数返回的唯一语言环境是 &lt;code&gt;lt&lt;/code&gt; ， &lt;code&gt;tr&lt;/code&gt; 和 &lt;code&gt;az&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="10187abc55d0802b4b3951872dffe3ad9dfa823c" translate="yes" xml:space="preserve">
          <source>If there are fewer than &lt;code&gt;$count&lt;/code&gt; items in the list then the function will return once all of them have been randomly selected; effectively the function behaves similarly to &lt;a href=&quot;#shuffle&quot;&gt;&quot;shuffle&quot;&lt;/a&gt;.</source>
          <target state="translated">如果列表中少于 &lt;code&gt;$count&lt;/code&gt; 项目，则所有这些项都被随机选择后，该函数将返回；否则，该函数将返回。有效地，该函数的行为类似于&lt;a href=&quot;#shuffle&quot;&gt;&amp;ldquo; shuffle&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c91a8fd751937bd233ccdf982bb8140e1a1456b2" translate="yes" xml:space="preserve">
          <source>If there are more pack codes or if the repeat count of a field or a group is larger than what the remainder of the input string allows, the result is not well defined: the repeat count may be decreased, or &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; may produce empty strings or zeros, or it may raise an exception. If the input string is longer than one described by the TEMPLATE, the remainder of that input string is ignored.</source>
          <target state="translated">如果有更多的打包代码，或者字段或组的重复计数大于输入字符串的其余部分所允许的数量，则结果的定义不明确：重复计数可能会减少，或者&lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt;可能会产生空字符串或零，否则可能会引发异常。如果输入字符串长于TEMPLATE描述的字符串，则该输入字符串的其余部分将被忽略。</target>
        </trans-unit>
        <trans-unit id="c264a98231858c182cc8e558543c798b7c30e957" translate="yes" xml:space="preserve">
          <source>If there are more pack codes or if the repeat count of a field or a group is larger than what the remainder of the input string allows, the result is not well defined: the repeat count may be decreased, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; may produce empty strings or zeros, or it may raise an exception. If the input string is longer than one described by the TEMPLATE, the remainder of that input string is ignored.</source>
          <target state="translated">如果有更多的打包代码，或者字段或组的重复计数大于输入字符串的其余部分所允许的数量，则结果定义不明确：重复计数可能会减少，或者 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 可能会产生空字符串或零，否则可能会引发异常。如果输入字符串长于TEMPLATE描述的字符串，则该输入字符串的其余部分将被忽略。</target>
        </trans-unit>
        <trans-unit id="b76f7ceb246d4c2d7fabcbfce30f4b0cda04fc65" translate="yes" xml:space="preserve">
          <source>If there are more pack codes or if the repeat count of a field or a group is larger than what the remainder of the input string allows, the result is not well defined: the repeat count may be decreased, or &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; may produce empty strings or zeros, or it may raise an exception. If the input string is longer than one described by the TEMPLATE, the remainder of that input string is ignored.</source>
          <target state="translated">如果有更多的打包代码，或者字段或组的重复计数大于输入字符串的其余部分所允许的数量，则结果定义不明确：重复计数可能会减少，或者 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 可能会产生空字符串或零，否则可能会引发异常。如果输入字符串长于TEMPLATE描述的字符串，则该输入字符串的其余部分将被忽略。</target>
        </trans-unit>
        <trans-unit id="68b83d3193021444c248ae823551b36481a4afcb" translate="yes" xml:space="preserve">
          <source>If there are multiple threads running, &lt;a href=&quot;#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; on a filehandle from a piped open returns true without waiting for the child process to terminate, if the filehandle is still open in another thread.</source>
          <target state="translated">如果有多个线程运行，&lt;a href=&quot;#close-FILEHANDLE&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;上一个文件句柄从管道开放的回报，而无需等待子进程终止，如果文件句柄仍然在另一个线程中打开真。</target>
        </trans-unit>
        <trans-unit id="cf8ae3d8fd9e42e9aba417d2727a1cef25f1654d" translate="yes" xml:space="preserve">
          <source>If there are multiple threads running, &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on a filehandle from a piped open returns true without waiting for the child process to terminate, if the filehandle is still open in another thread.</source>
          <target state="translated">如果有多个线程运行， &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 上一个文件句柄从管道开放的回报，而无需等待子进程终止，如果文件句柄仍然在另一个线程中打开真。</target>
        </trans-unit>
        <trans-unit id="2d703ea78c6bd312ccc4d4536374984caf742a2c" translate="yes" xml:space="preserve">
          <source>If there are multiple threads running, &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on a filehandle from a piped open returns true without waiting for the child process to terminate, if the filehandle is still open in another thread.</source>
          <target state="translated">如果有多个线程运行， &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 上一个文件句柄从管道开放的回报，而无需等待子进程终止，如果文件句柄仍然在另一个线程中打开真。</target>
        </trans-unit>
        <trans-unit id="b367c7608072c7b2e27d64beb7fdc3ebcfc5757e" translate="yes" xml:space="preserve">
          <source>If there are no case mappings for the &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;, or if all three possible mappings (</source>
          <target state="translated">如果&lt;a href=&quot;#code-point-argument&quot;&gt;&amp;ldquo;代码点参数&amp;rdquo;&lt;/a&gt;没有大小写映射，或者所有三种可能的映射（</target>
        </trans-unit>
        <trans-unit id="c3ca3b8e4b7d3fd6327a3431ba332cb4654544b7" translate="yes" xml:space="preserve">
          <source>If there are no case mappings for the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;, or if all three possible mappings (</source>
          <target state="translated">如果&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数&lt;/a&gt;没有大小写映射，或者所有三个可能的映射（</target>
        </trans-unit>
        <trans-unit id="4d288bab40c0346d55a3c0eb77940eab7a6641ad" translate="yes" xml:space="preserve">
          <source>If there are no shell metacharacters in the argument of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, Perl runs the command directly, without using the shell, and can correctly report whether the command started.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 的参数中没有外壳元字符，则Perl无需使用外壳即可直接运行命令，并且可以正确报告命令是否已启动。</target>
        </trans-unit>
        <trans-unit id="07b923cdb7f2db79984c43279c6e1908fa7560e3" translate="yes" xml:space="preserve">
          <source>If there are no shell metacharacters in the argument of &lt;code&gt;open()&lt;/code&gt;, Perl runs the command directly, without using the shell, and can correctly report whether the command started.</source>
          <target state="translated">如果 &lt;code&gt;open()&lt;/code&gt; 的参数中没有外壳元字符，则Perl无需使用外壳即可直接运行命令，并且可以正确报告命令是否已启动。</target>
        </trans-unit>
        <trans-unit id="83b3c9dc933e2482f8eba281e591135e3899389e" translate="yes" xml:space="preserve">
          <source>If there are no threads blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the variable, the signal is discarded.</source>
          <target state="translated">如果在变量的 &lt;code&gt;cond_wait&lt;/code&gt; 中没有线程被阻塞，则信号被丢弃。</target>
        </trans-unit>
        <trans-unit id="dcf5c5ee7e0424ea7ada5c7826f4b90fdb2a116c" translate="yes" xml:space="preserve">
          <source>If there are no threads blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the variable, the signal is discarded. By always locking before signaling, you can (with care), avoid signaling before another thread has entered cond_wait().</source>
          <target state="translated">如果在变量的 &lt;code&gt;cond_wait&lt;/code&gt; 中没有线程被阻塞，则信号被丢弃。通过始终在发信号之前锁定，您可以（小心）避免在另一个线程进入cond_wait（）之前发信号。</target>
        </trans-unit>
        <trans-unit id="a5de19948908467a5a983001d47b7d9a0689b746" translate="yes" xml:space="preserve">
          <source>If there are no valid digits between the braces, the generated character is the NULL character (&lt;code&gt;\x{00}&lt;/code&gt; ). However, an explicit empty brace (&lt;code&gt;\x{}&lt;/code&gt; ) will not cause a warning (currently).</source>
          <target state="translated">如果括号之间没有有效数字，则生成的字符为NULL字符（ &lt;code&gt;\x{00}&lt;/code&gt; ）。但是，显式的空括号（ &lt;code&gt;\x{}&lt;/code&gt; ）不会引起警告（当前）。</target>
        </trans-unit>
        <trans-unit id="954b2d334088acf7ff9ea75b92d63622f7bf51c0" translate="yes" xml:space="preserve">
          <source>If there are no valid digits between the braces, the generated character is the NULL character (&lt;code&gt;\x{00}&lt;/code&gt;). However, an explicit empty brace (&lt;code&gt;\x{}&lt;/code&gt;) will not cause a warning (currently).</source>
          <target state="translated">如果括号之间没有有效数字，则生成的字符为NULL字符（ &lt;code&gt;\x{00}&lt;/code&gt; ）。但是，显式的空括号（ &lt;code&gt;\x{}&lt;/code&gt; ）不会引起警告（当前）。</target>
        </trans-unit>
        <trans-unit id="b342c6d59112da790e47e12118a22cde8dbcaf22" translate="yes" xml:space="preserve">
          <source>If there are only a few field hashes to declare, it is simplest to</source>
          <target state="translated">如果只有几个字段哈希要声明,最简单的方法就是</target>
        </trans-unit>
        <trans-unit id="ae8e9a2c571cd018342d9c2118caec048fd77da4" translate="yes" xml:space="preserve">
          <source>If there are only three arguments and the third argument is a hash reference, the keys of that hash can have values &lt;code&gt;dict&lt;/code&gt; , &lt;code&gt;fold&lt;/code&gt; , and &lt;code&gt;comp&lt;/code&gt; or &lt;code&gt;xfrm&lt;/code&gt; (see below), and their corresponding values will be used as the parameters.</source>
          <target state="translated">如果只有三个参数，而第三个参数是哈希引用，则该哈希的键可以具有值 &lt;code&gt;dict&lt;/code&gt; ， &lt;code&gt;fold&lt;/code&gt; 和 &lt;code&gt;comp&lt;/code&gt; 或 &lt;code&gt;xfrm&lt;/code&gt; （请参见下文），并将它们的相应值用作参数。</target>
        </trans-unit>
        <trans-unit id="e81956a0441efe3f26746423f2c17c9cee5f29f4" translate="yes" xml:space="preserve">
          <source>If there are only three arguments and the third argument is a hash reference, the keys of that hash can have values &lt;code&gt;dict&lt;/code&gt;, &lt;code&gt;fold&lt;/code&gt;, and &lt;code&gt;comp&lt;/code&gt; or &lt;code&gt;xfrm&lt;/code&gt; (see below), and their corresponding values will be used as the parameters.</source>
          <target state="translated">如果只有三个参数，并且第三个参数是哈希引用，则该哈希的键可以具有值 &lt;code&gt;dict&lt;/code&gt; ， &lt;code&gt;fold&lt;/code&gt; 和 &lt;code&gt;comp&lt;/code&gt; 或 &lt;code&gt;xfrm&lt;/code&gt; （请参见下文），并将它们的相应值用作参数。</target>
        </trans-unit>
        <trans-unit id="1e86b013905dd12651149e8ec83c3ae6cf6c6b73" translate="yes" xml:space="preserve">
          <source>If there are two modules using &lt;code&gt;FindBin&lt;/code&gt; from different directories under the same interpreter, this won't work. Since &lt;code&gt;FindBin&lt;/code&gt; uses a &lt;code&gt;BEGIN&lt;/code&gt; block, it'll be executed only once, and only the first caller will get it right. This is a problem under mod_perl and other persistent Perl environments, where you shouldn't use this module. Which also means that you should avoid using &lt;code&gt;FindBin&lt;/code&gt; in modules that you plan to put on CPAN. To make sure that &lt;code&gt;FindBin&lt;/code&gt; will work is to call the &lt;code&gt;again&lt;/code&gt; function:</source>
          <target state="translated">如果有两个模块在同一解释器下的不同目录中使用 &lt;code&gt;FindBin&lt;/code&gt; ，则此方法将无效。由于 &lt;code&gt;FindBin&lt;/code&gt; 使用 &lt;code&gt;BEGIN&lt;/code&gt; 块，因此它将仅执行一次，并且只有第一个调用者才能正确执行。在mod_perl和其他持久性Perl环境下，这是一个问题，在这些环境下您不应该使用此模块。这也意味着您应该避免在计划放入CPAN的模块中使用 &lt;code&gt;FindBin&lt;/code&gt; 。要确保 &lt;code&gt;FindBin&lt;/code&gt; 可以正常运行，请调用 &lt;code&gt;again&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="fcc3c3e2760c5e396f33222005be848fc9fe18e0" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK, it is always executed just before the conditional is about to be evaluated again. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">如果存在 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，则总是在即将再次评估条件之前执行它。因此，即使通过 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 一条语句继续执行循环，也可以使用它来增加循环变量。</target>
        </trans-unit>
        <trans-unit id="47225f2cbf093a41e464bfd235d898451ab3fec3" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;continue&lt;/code&gt; BLOCK, it is always executed just before the conditional is about to be evaluated again. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;next&lt;/code&gt; statement.</source>
          <target state="translated">如果存在 &lt;code&gt;continue&lt;/code&gt; 块，则总是在即将再次评估条件之前执行它。因此，即使通过 &lt;code&gt;next&lt;/code&gt; 一条语句继续执行循环，也可以使用它来增加循环变量。</target>
        </trans-unit>
        <trans-unit id="8b36be5061281671022cf399b379651681b1d4d0" translate="yes" xml:space="preserve">
          <source>If there is a case folding for that code point, a reference to a hash with the following fields is returned:</source>
          <target state="translated">如果该码点有大小写折叠,则返回一个包含以下字段的哈希引用。</target>
        </trans-unit>
        <trans-unit id="791dad5bf77a3c7753599734b55d1d951806d6b3" translate="yes" xml:space="preserve">
          <source>If there is a possibility of malformed input, use instead:</source>
          <target state="translated">如果有可能出现错误的输入,请使用。</target>
        </trans-unit>
        <trans-unit id="6424bf8b1f44f30e366f5038ca9bafadec447990" translate="yes" xml:space="preserve">
          <source>If there is a read or write timeout &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Timeout&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt; ). The _set_status_timeout() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="translated">如果存在读取或写入超时，则 &lt;code&gt;code()&lt;/code&gt; 将返回&amp;ldquo; 421&amp;rdquo;（临时连接失败），而 &lt;code&gt;message()&lt;/code&gt; 将返回&amp;ldquo; [$ pkg] Timeout&amp;rdquo;（其中$ pkg是 &lt;code&gt;Net::Cmd&lt;/code&gt; 子类的名称））。可以重写_set_status_timeout（）方法以设置其他消息（通过调用set_status（）），否则可以捕获此错误。</target>
        </trans-unit>
        <trans-unit id="5c5ddbe053c3383dcb2da814550e984622b561fa" translate="yes" xml:space="preserve">
          <source>If there is a read or write timeout &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Timeout&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt;). The _set_status_timeout() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="translated">如果存在读取或写入超时，则 &lt;code&gt;code()&lt;/code&gt; 将返回&amp;ldquo; 421&amp;rdquo;（临时连接失败），而 &lt;code&gt;message()&lt;/code&gt; 将返回&amp;ldquo; [$ pkg]超时&amp;rdquo;（其中$ pkg是将 &lt;code&gt;Net::Cmd&lt;/code&gt; 子类化的类的名称））。可以重写_set_status_timeout（）方法以设置其他消息（通过调用set_status（）），否则可以捕获此错误。</target>
        </trans-unit>
        <trans-unit id="5a08eec9ef05dccf9a00729a1af45acee83fa1a4" translate="yes" xml:space="preserve">
          <source>If there is a syntax error or runtime error, or a &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; statement is executed, &lt;code&gt;eval&lt;/code&gt; returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; in scalar context, or an empty list in list context, and &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; is set to the error message. (Prior to 5.16, a bug caused &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; to be returned in list context for syntax errors, but not for runtime errors.) If there was no error, &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; is set to the empty string. A control flow operator like &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt; can bypass the setting of &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt;. Beware that using &lt;code&gt;eval&lt;/code&gt; neither silences Perl from printing warnings to STDERR, nor does it stuff the text of warning messages into &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt;. To do either of those, you have to use the &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;$SIG{__WARN__}&lt;/code&gt;&lt;/a&gt; facility, or turn off warnings inside the BLOCK or EXPR using &lt;code&gt;no warnings 'all'&lt;/code&gt;. See &lt;a href=&quot;#warn-LIST&quot;&gt;&lt;code&gt;warn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;, and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">如果存在语法错误或运行时错误，或者执行了&lt;a href=&quot;#die-LIST&quot;&gt; &lt;code&gt;die&lt;/code&gt; &lt;/a&gt;语句，则 &lt;code&gt;eval&lt;/code&gt; 在标量上下文中返回&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;，或者在列表上下文中返回空列表，并将&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;设置为错误消息。 （在5.16之前，一个错误导致&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;在语法错误而不是在运行时错误的列表上下文中返回。）如果没有错误，则将&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;设置为空字符串。诸如&lt;a href=&quot;#last-LABEL&quot;&gt; &lt;code&gt;last&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#goto-LABEL&quot;&gt; &lt;code&gt;goto&lt;/code&gt; 之&lt;/a&gt;类的控制流运算符可以绕过&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;的设置。请注意，使用 &lt;code&gt;eval&lt;/code&gt; 既不会使Perl从打印警告到STDERR的操作保持静音，也不会将警告消息的文本填充到&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;。要执行上述任一操作，您必须使用&lt;a href=&quot;perlvar#%25SIG&quot;&gt; &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; &lt;/a&gt;工具，或者在BLOCK或EXPR内部使用 &lt;code&gt;no warnings 'all'&lt;/code&gt; 来关闭警告。请参阅&lt;a href=&quot;#warn-LIST&quot;&gt; &lt;code&gt;warn&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;和&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11aba41a92baa1006f7ccfb764892fd564d365da" translate="yes" xml:space="preserve">
          <source>If there is a syntax error or runtime error, or a &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; statement is executed, &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context or an empty list in list context, and &lt;code&gt;$@&lt;/code&gt; is set to the error message. (Prior to 5.16, a bug caused &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to be returned in list context for syntax errors, but not for runtime errors.) If there was no error, &lt;code&gt;$@&lt;/code&gt; is set to the empty string. A control flow operator like &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; can bypass the setting of &lt;code&gt;$@&lt;/code&gt; . Beware that using &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; neither silences Perl from printing warnings to STDERR, nor does it stuff the text of warning messages into &lt;code&gt;$@&lt;/code&gt; . To do either of those, you have to use the &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; facility, or turn off warnings inside the BLOCK or EXPR using &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; . See &lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;, &lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt;, and &lt;a href=&quot;../warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">如果存在语法错误或运行时错误，或者执行了 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 语句，则 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 在标量上下文中返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或在列表上下文中返回空列表，并将 &lt;code&gt;$@&lt;/code&gt; 设置为错误消息。 （在5.16之前，一个错误导致 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 在语法语法错误而不是在运行时错误的列表上下文中返回。）如果没有错误，则将 &lt;code&gt;$@&lt;/code&gt; 设置为空字符串。诸如 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 之类的控制流运算符可以绕过 &lt;code&gt;$@&lt;/code&gt; 的设置。请注意，使用 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 既不会使Perl从打印警告到STDERR的操作保持静音，也不会将警告消息的文本填充到 &lt;code&gt;$@&lt;/code&gt; 。要执行上述任一操作，您必须使用 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 工具，或者在BLOCK或EXPR内部使用 &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; 来关闭警告。请参阅&lt;a href=&quot;warn&quot;&gt;警告&lt;/a&gt;，&lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt;和&lt;a href=&quot;../warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ebacccba519ce29c0edb6165a1d7c06041545422" translate="yes" xml:space="preserve">
          <source>If there is a syntax error or runtime error, or a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; statement is executed, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context or an empty list in list context, and &lt;code&gt;$@&lt;/code&gt; is set to the error message. (Prior to 5.16, a bug caused &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to be returned in list context for syntax errors, but not for runtime errors.) If there was no error, &lt;code&gt;$@&lt;/code&gt; is set to the empty string. A control flow operator like &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; can bypass the setting of &lt;code&gt;$@&lt;/code&gt; . Beware that using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; neither silences Perl from printing warnings to STDERR, nor does it stuff the text of warning messages into &lt;code&gt;$@&lt;/code&gt; . To do either of those, you have to use the &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; facility, or turn off warnings inside the BLOCK or EXPR using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; . See &lt;a href=&quot;#warn&quot;&gt;warn&lt;/a&gt;, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;, and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">如果存在语法错误或运行时错误，或者执行了 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 语句，则 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 在标量上下文中返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或在列表上下文中返回空列表，并将 &lt;code&gt;$@&lt;/code&gt; 设置为错误消息。 （在5.16之前，一个错误导致 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 在语法语法错误而不是在运行时错误的列表上下文中返回。）如果没有错误，则将 &lt;code&gt;$@&lt;/code&gt; 设置为空字符串。诸如 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 之类的控制流运算符可以绕过 &lt;code&gt;$@&lt;/code&gt; 的设置。请注意，使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 既不会使Perl从打印警告到STDERR的操作保持静音，也不会将警告消息的文本填充到 &lt;code&gt;$@&lt;/code&gt; 。要执行上述任一操作，您必须使用 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 工具，或者在BLOCK或EXPR内部使用 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; 来关闭警告。请参阅&lt;a href=&quot;#warn&quot;&gt;警告&lt;/a&gt;，&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;和&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0363f8d22dbc9b336b291dea3342e0d06c042240" translate="yes" xml:space="preserve">
          <source>If there is already a subroutine of the specified name, then the new sub will either replace the existing one in the glob or be merged with the existing one. A warning may be generated about redefinition.</source>
          <target state="translated">如果已经有一个指定名称的子程序,那么新的子程序将取代 glob 中现有的子程序或与现有的子程序合并。可能会产生一个关于重新定义的警告。</target>
        </trans-unit>
        <trans-unit id="f502d2c87f9e6854805c11486fbe0df87ab65e99" translate="yes" xml:space="preserve">
          <source>If there is already a subroutine of the specified name, then the new sub will replace the existing one in the glob. A warning may be generated about the redefinition.</source>
          <target state="translated">如果已经有一个指定名称的子程序,那么新的子程序将取代 glob 中现有的子程序。可能会产生一个关于重新定义的警告。</target>
        </trans-unit>
        <trans-unit id="9b62d67db30c0ed8a724a981f3cdb26a57d7bac9" translate="yes" xml:space="preserve">
          <source>If there is already a subroutine of the specified name, then the new sub will replace the existing one in the glob. A warning may be generated about the redefinition. If the old subroutine was &lt;code&gt;CvCONST&lt;/code&gt; then the decision about whether to warn is influenced by an expectation about whether the new subroutine will become a constant of similar value. That expectation is determined by &lt;code&gt;const_svp&lt;/code&gt;. (Note that the call to this function doesn't make the new subroutine &lt;code&gt;CvCONST&lt;/code&gt; in any case; that is left to the caller.) If &lt;code&gt;const_svp&lt;/code&gt; is null then it indicates that the new subroutine will not become a constant. If &lt;code&gt;const_svp&lt;/code&gt; is non-null then it indicates that the new subroutine will become a constant, and it points to an &lt;code&gt;SV*&lt;/code&gt; that provides the constant value that the subroutine will have.</source>
          <target state="translated">如果已经有指定名称的子例程，则新子例程将替换glob中现有的子例程。可能会产生有关重新定义的警告。如果旧的子例程是 &lt;code&gt;CvCONST&lt;/code&gt; ,则有关是否发出警告的决定会受到对新子例程是否将成为具有相似值的常量的期望的影响。该期望由 &lt;code&gt;const_svp&lt;/code&gt; 确定。 （请注意，在任何情况下，对该函数的调用都不会创建新的子例程 &lt;code&gt;CvCONST&lt;/code&gt; ；它留给调用者。）如果 &lt;code&gt;const_svp&lt;/code&gt; 为null，则表明新的子例程将不会成为常量。如果 &lt;code&gt;const_svp&lt;/code&gt; 为非null，则表明新的子例程将成为常量，并且它指向一个 &lt;code&gt;SV*&lt;/code&gt; 提供子例程将具有的常数值。</target>
        </trans-unit>
        <trans-unit id="5466934b0ce09952bbdf7a873d8e98baf5e63870" translate="yes" xml:space="preserve">
          <source>If there is an error then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">如果有错误，则将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b85ca592364b34a60190d51f6450258a4cd0c81b" translate="yes" xml:space="preserve">
          <source>If there is an error then &lt;code&gt;undef&lt;/code&gt; will be returned.</source>
          <target state="translated">如果有错误，则将返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="467d2ed550f37bc1b9fda912fd43e11ff12b4118" translate="yes" xml:space="preserve">
          <source>If there is any question about whether a given patch might merit inclusion in a maint release, then it almost certainly should not be included.</source>
          <target state="translated">如果有任何关于某个补丁是否值得包含在主版本中的问题,那么几乎可以肯定它不应该被包含在内。</target>
        </trans-unit>
        <trans-unit id="ca419a7d4011e71c524719322dfff4afd6d50991" translate="yes" xml:space="preserve">
          <source>If there is more than one argument in LIST, this calls &lt;a href=&quot;http://man.he.net/man3/execvp&quot;&gt;execvp(3)&lt;/a&gt; with the arguments in LIST. If there is only one element in LIST, the argument is checked for shell metacharacters, and if there are any, the entire argument is passed to the system's command shell for parsing (this is &lt;code&gt;/bin/sh -c&lt;/code&gt; on Unix platforms, but varies on other platforms). If there are no shell metacharacters in the argument, it is split into words and passed directly to &lt;code&gt;execvp&lt;/code&gt;, which is more efficient. Examples:</source>
          <target state="translated">如果LIST中有多个参数，则使用LIST中的参数调用&lt;a href=&quot;http://man.he.net/man3/execvp&quot;&gt;execvp（3）&lt;/a&gt;。如果LIST中只有一个元素，则检查该参数是否包含shell元字符，如果存在，则将整个参数传递给系统的命令shell进行解析（在Unix平台上为 &lt;code&gt;/bin/sh -c&lt;/code&gt; ，但有所不同在其他平台上）。如果参数中没有外壳元字符，则将其拆分为单词，然后直接传递给 &lt;code&gt;execvp&lt;/code&gt; ，这样效率更高。例子：</target>
        </trans-unit>
        <trans-unit id="0f8376c45472eeb9e97a43b3d977d663509a5686" translate="yes" xml:space="preserve">
          <source>If there is more than one argument in LIST, this calls execvp(3) with the arguments in LIST. If there is only one element in LIST, the argument is checked for shell metacharacters, and if there are any, the entire argument is passed to the system's command shell for parsing (this is &lt;code&gt;/bin/sh -c&lt;/code&gt; on Unix platforms, but varies on other platforms). If there are no shell metacharacters in the argument, it is split into words and passed directly to &lt;code&gt;execvp&lt;/code&gt; , which is more efficient. Examples:</source>
          <target state="translated">如果LIST中有多个参数，则使用LIST中的参数调用execvp（3）。如果LIST中只有一个元素，则检查该参数是否包含shell元字符，如果有，则将整个参数传递给系统的命令shell进行解析（在Unix平台上为 &lt;code&gt;/bin/sh -c&lt;/code&gt; ，但有所不同在其他平台上）。如果参数中没有外壳元字符，则将其拆分为单词，然后直接传递给 &lt;code&gt;execvp&lt;/code&gt; ，这样效率更高。例子：</target>
        </trans-unit>
        <trans-unit id="2594b97a91aa3fa79863d35058be1a8172ac679a" translate="yes" xml:space="preserve">
          <source>If there is no</source>
          <target state="translated">如果没有</target>
        </trans-unit>
        <trans-unit id="836d7eec1f71c6b6f4181b3811b03cbac0e80430" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;\E&lt;/code&gt; , case is converted until the end of the string. The regexps &lt;code&gt;\L\u$word&lt;/code&gt; or &lt;code&gt;\u\L$word&lt;/code&gt; convert the first character of &lt;code&gt;$word&lt;/code&gt; to uppercase and the rest of the characters to lowercase.</source>
          <target state="translated">如果没有 &lt;code&gt;\E&lt;/code&gt; ，则转换大小写直到字符串的结尾。在正则表达式 &lt;code&gt;\L\u$word&lt;/code&gt; 或 &lt;code&gt;\u\L$word&lt;/code&gt; 转换的第一个字符 &lt;code&gt;$word&lt;/code&gt; 为大写和字符的其余小写。</target>
        </trans-unit>
        <trans-unit id="f1b2b91591fb1955a250148f5d6f9f32438d8436" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;\E&lt;/code&gt;, case is converted until the end of the string. The regexps &lt;code&gt;\L\u$word&lt;/code&gt; or &lt;code&gt;\u\L$word&lt;/code&gt; convert the first character of &lt;code&gt;$word&lt;/code&gt; to uppercase and the rest of the characters to lowercase.</source>
          <target state="translated">如果没有 &lt;code&gt;\E&lt;/code&gt; ，则转换大小写直到字符串的结尾。在正则表达式 &lt;code&gt;\L\u$word&lt;/code&gt; 或 &lt;code&gt;\u\L$word&lt;/code&gt; 转换的第一个字符 &lt;code&gt;$word&lt;/code&gt; 为大写和字符的其余小写。</target>
        </trans-unit>
        <trans-unit id="c73d7b3af9d178254858949bc270c269c6e2e60d" translate="yes" xml:space="preserve">
          <source>If there is no INSTALL.SKIP file in the make directory then this value can be used to provide a default.</source>
          <target state="translated">如果make目录下没有INSTALL.SKIP文件,那么这个值可以用来提供一个默认值。</target>
        </trans-unit>
        <trans-unit id="3610af61096f12f4c9e6f52b35a24b772a2c16bd" translate="yes" xml:space="preserve">
          <source>If there is no Pod in the given document, then the event structure will be this:</source>
          <target state="translated">如果给定的文档中没有Pod,那么事件结构将是这样。</target>
        </trans-unit>
        <trans-unit id="349639462c1781c6c7203933948097f1b032dbf1" translate="yes" xml:space="preserve">
          <source>If there is no case folding for the input code point, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果输入代码点没有大小写折叠，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fb296c4463c79fc259188fecb37636b958c8768" translate="yes" xml:space="preserve">
          <source>If there is no case folding for the input code point, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">如果输入代码点没有大小写折叠，则返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20a8d9cc6cec6caebf969b32884584509dabbda2" translate="yes" xml:space="preserve">
          <source>If there is no corresponding capture group defined, then it is a fatal error. Recursing deeper than 50 times without consuming any input string will also result in a fatal error. The maximum depth is compiled into perl, so changing it requires a custom build.</source>
          <target state="translated">如果没有定义相应的捕获组,那么就是一个致命的错误。在没有消耗任何输入字符串的情况下,递归深度超过50次也会导致一个致命的错误。最大深度是编译到perl中的,所以改变它需要自定义构建。</target>
        </trans-unit>
        <trans-unit id="9a6e24a6b319d54eae6772ce7d4930464be16411" translate="yes" xml:space="preserve">
          <source>If there is no corresponding capture group defined, then it is a fatal error. Recursing deeply without consuming any input string will also result in a fatal error. The depth at which that happens is compiled into perl, so it can be changed with a custom build.</source>
          <target state="translated">如果没有定义相应的捕获组,那么这是一个致命的错误。在没有消耗任何输入字符串的情况下,深度递归也会导致一个致命的错误。这种情况发生的深度被编译到perl中,所以可以通过自定义构建来改变。</target>
        </trans-unit>
        <trans-unit id="28265c4ced5473656451fd65ecb5d6a73bdd1b4e" translate="yes" xml:space="preserve">
          <source>If there is no description, its the same as the parameter to WriteMakefile() documented in &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;.</source>
          <target state="translated">如果没有描述，则与&lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils :: MakeMaker中&lt;/a&gt;记录的WriteMakefile（）参数相同。</target>
        </trans-unit>
        <trans-unit id="c5c7947682ddf8ce5897cbba5d096660017802ec" translate="yes" xml:space="preserve">
          <source>If there is no description, its the same as the parameter to WriteMakefile() documented in ExtUtils::MakeMaker.</source>
          <target state="translated">如果没有描述,它和ExtUtils::MakeMaker中记载的WriteMakefile()参数一样。</target>
        </trans-unit>
        <trans-unit id="9a08244ff3de5da70abd74d4f48bc9a98bd5fd63" translate="yes" xml:space="preserve">
          <source>If there is no error, then the method returns the value of the last expression evaluated, or a return statement may be used, just as with subroutines and &lt;b&gt;eval()&lt;/b&gt;. The context (list or scalar) is determined by the caller as usual.</source>
          <target state="translated">如果没有错误，则该方法将返回最后计算出的表达式的值，或者可以使用return语句，就像子例程和&lt;b&gt;eval（）一样&lt;/b&gt;。上下文（列表或标量）由调用者照常确定。</target>
        </trans-unit>
        <trans-unit id="9fcf9881e5055fcb38df136c867429f9722c1a7e" translate="yes" xml:space="preserve">
          <source>If there is no global precision or accuracy set, &lt;b&gt;and&lt;/b&gt; the operation in question was not called with a requested precision or accuracy, &lt;b&gt;and&lt;/b&gt; the input $x has no accuracy or precision set, then a fallback parameter will be used. For historical reasons, it is called &lt;code&gt;div_scale&lt;/code&gt; and can be accessed via:</source>
          <target state="translated">如果没有设置全局精度或精度，&lt;b&gt;并且&lt;/b&gt;没有以请求的精度或精度调用相关操作，&lt;b&gt;并且&lt;/b&gt;输入$ x没有设置精度或精度，则将使用后备参数。由于历史原因，它称为 &lt;code&gt;div_scale&lt;/code&gt; ，可以通过以下方式访问：</target>
        </trans-unit>
        <trans-unit id="bbd1fd130f18a572d29a93b5834a0fdb0347ebb7" translate="yes" xml:space="preserve">
          <source>If there is no interactivity then you may still want to look at using something like &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fmodule%2fTemplate&quot;&gt;Template Toolkit&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::TemplateToolkit&quot;&gt;Plack::Middleware::TemplateToolkit&lt;/a&gt; so maintenance of your HTML files (and other assets) is easier.</source>
          <target state="translated">如果没有交互性，那么您可能仍希望使用诸如&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fmodule%2fTemplate&quot;&gt;Template Toolkit&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::TemplateToolkit&quot;&gt;Plack :: Middleware :: TemplateToolkit之&lt;/a&gt;类的工具，以便更轻松地维护HTML文件（和其他资产）。</target>
        </trans-unit>
        <trans-unit id="a299e842222c6ed90a64aa41cd2a789a3c361e2f" translate="yes" xml:space="preserve">
          <source>If there is no interactivity then you may still want to look at using something like &lt;a href=&quot;https://metacpan.org/module/Template&quot;&gt;Template Toolkit&lt;/a&gt; or &lt;a href=&quot;Plack::Middleware::TemplateToolkit&quot;&gt;Plack::Middleware::TemplateToolkit&lt;/a&gt; so maintenance of your HTML files (and other assets) is easier.</source>
          <target state="translated">如果没有交互性，那么您可能仍想使用诸如&lt;a href=&quot;https://metacpan.org/module/Template&quot;&gt;Template Toolkit&lt;/a&gt;或&lt;a href=&quot;Plack::Middleware::TemplateToolkit&quot;&gt;Plack :: Middleware :: TemplateToolkit之类的东西，&lt;/a&gt;以便更轻松地维护HTML文件（和其他资产）。</target>
        </trans-unit>
        <trans-unit id="8dd8956e9b63cae584008cf6c1bbe7cd26c8c5c5" translate="yes" xml:space="preserve">
          <source>If there is no matching entry found and there is no default defined, or no .netrc file is found, then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果找不到匹配的条目，并且没有定义默认值，或者没有找到.netrc文件，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6537a61412be05c76bbd6dbb9043f0a60ac95b9" translate="yes" xml:space="preserve">
          <source>If there is no matching entry found and there is no default defined, or no .netrc file is found, then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">如果找不到匹配的条目，并且没有定义默认值，或者没有找到.netrc文件，则返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed6dfba39c8f615f2c8441ca5b61296e07f9cf19" translate="yes" xml:space="preserve">
          <source>If there is no top hub, and you do not ask to leave IPC and formatter undef, then a new formatter will be created, and the IPC instance from &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt; will be used.</source>
          <target state="translated">如果没有顶部集线器，并且您不要求保留IPC和格式化程序undef，则将创建一个新的格式化程序，并将使用&lt;a href=&quot;Test2::API&quot;&gt;Test2 :: API&lt;/a&gt;的IPC实例。</target>
        </trans-unit>
        <trans-unit id="40165726268e187e7ad5a226c93cb70fb5e7ae2c" translate="yes" xml:space="preserve">
          <source>If there is only one argument and it is a reference to an array then the array is assumed to contain a list of key-value pairs specifying the options. In this case the option &quot;from_to&quot; is mandatory. This style means that you do not have to supply a cryptic list of arguments and can use a self documenting argument list that is easier to understand.</source>
          <target state="translated">如果只有一个参数,并且是一个数组的引用,那么数组被认为包含了一个键值对的列表,指定了选项。在这种情况下,选项 &quot;from_to &quot;是必须的。这种风格意味着你不需要提供一个神秘的参数列表,可以使用一个更容易理解的自记录参数列表。</target>
        </trans-unit>
        <trans-unit id="663e6f7ad7626839945e055f61dd00fa139292d7" translate="yes" xml:space="preserve">
          <source>If there was an error authenticating the user then</source>
          <target state="translated">如果验证用户时出现错误,那么</target>
        </trans-unit>
        <trans-unit id="c4805e4afe7a0ccfe45caa54514a077972082082" translate="yes" xml:space="preserve">
          <source>If there's already an entry in &lt;code&gt;%table&lt;/code&gt; for the current &lt;code&gt;$country&lt;/code&gt; , then nothing is different. Line 6 will locate the value in &lt;code&gt;$table{$country}&lt;/code&gt; , which is a reference to an array, and push &lt;code&gt;$city&lt;/code&gt; into the array. But what does it do when &lt;code&gt;$country&lt;/code&gt; holds a key, say &lt;code&gt;Greece&lt;/code&gt; , that is not yet in &lt;code&gt;%table&lt;/code&gt; ?</source>
          <target state="translated">如果 &lt;code&gt;%table&lt;/code&gt; 中已经有当前 &lt;code&gt;$country&lt;/code&gt; 的条目，则没有什么不同。第6行将在 &lt;code&gt;$table{$country}&lt;/code&gt; 定位值，该值是对数组的引用，并将 &lt;code&gt;$city&lt;/code&gt; 推入数组。但是，当 &lt;code&gt;Greece&lt;/code&gt; 说 &lt;code&gt;$country&lt;/code&gt; 拥有尚未在 &lt;code&gt;%table&lt;/code&gt; 中的键时，该怎么办？</target>
        </trans-unit>
        <trans-unit id="9e3670f66abc27b9c0c1a9a3a64b0edd5b7f7779" translate="yes" xml:space="preserve">
          <source>If there's already an entry in &lt;code&gt;%table&lt;/code&gt; for the current &lt;code&gt;$country&lt;/code&gt;, then nothing is different. Line 6 will locate the value in &lt;code&gt;$table{$country}&lt;/code&gt;, which is a reference to an array, and push &lt;code&gt;$city&lt;/code&gt; into the array. But what does it do when &lt;code&gt;$country&lt;/code&gt; holds a key, say &lt;code&gt;Greece&lt;/code&gt;, that is not yet in &lt;code&gt;%table&lt;/code&gt;?</source>
          <target state="translated">如果 &lt;code&gt;%table&lt;/code&gt; 中已经有当前 &lt;code&gt;$country&lt;/code&gt; 的条目，则没有什么不同。第6行将在 &lt;code&gt;$table{$country}&lt;/code&gt; 定位值，该值是对数组的引用，并将 &lt;code&gt;$city&lt;/code&gt; 推入数组。但是，当 &lt;code&gt;Greece&lt;/code&gt; 说 &lt;code&gt;$country&lt;/code&gt; 拥有尚未在 &lt;code&gt;%table&lt;/code&gt; 中的键时，该怎么办？</target>
        </trans-unit>
        <trans-unit id="b79b95fc8b6f0bdad9a42663607fbb6bbfce24c2" translate="yes" xml:space="preserve">
          <source>If there's no &lt;code&gt;\w&lt;/code&gt; in &lt;code&gt;s1&lt;/code&gt; nor in &lt;code&gt;s2&lt;/code&gt; , why does their concatenation have one?</source>
          <target state="translated">如果没有 &lt;code&gt;\w&lt;/code&gt; 在 &lt;code&gt;s1&lt;/code&gt; 也不是 &lt;code&gt;s2&lt;/code&gt; ，为什么他们的串联也有吗？</target>
        </trans-unit>
        <trans-unit id="f998e73c18ed98eef0579d8f9950627eae9eb668" translate="yes" xml:space="preserve">
          <source>If there's no &lt;code&gt;\w&lt;/code&gt; in &lt;code&gt;s1&lt;/code&gt; nor in &lt;code&gt;s2&lt;/code&gt;, why does their concatenation have one?</source>
          <target state="translated">如果没有 &lt;code&gt;\w&lt;/code&gt; 在 &lt;code&gt;s1&lt;/code&gt; 也不是 &lt;code&gt;s2&lt;/code&gt; ，为什么他们的串联也有吗？</target>
        </trans-unit>
        <trans-unit id="e887683b17f434ea92edf8b372be7bfa0a590185" translate="yes" xml:space="preserve">
          <source>If there's no handle_unknown_option, then we just warn, and then increment the error counter</source>
          <target state="translated">如果没有handle_unknown_option,那么我们就发出警告,然后递增错误计数器</target>
        </trans-unit>
        <trans-unit id="4d867e0a4fd4a8ea827c16a08b87197c9c461d55" translate="yes" xml:space="preserve">
          <source>If these dependent libraries are not listed at shared library creation time, you will get fatal &quot;Unresolved symbol&quot; errors at run time when the library is loaded.</source>
          <target state="translated">如果在创建共享库时没有列出这些依赖库,那么在运行时加载库时就会出现致命的 &quot;Unresolved symbol &quot;错误。</target>
        </trans-unit>
        <trans-unit id="66c4d2d6f3874b5b92940f178682f9bbdd8c1db5" translate="yes" xml:space="preserve">
          <source>If these operators are not explicitly overloaded then they work in the normal way, yielding the underlying scalar, array, or whatever stores the object data (or the appropriate error message if the dereference operator doesn't match it). Defining a catch-all &lt;code&gt;'nomethod'&lt;/code&gt; (see &lt;a href=&quot;#nomethod&quot;&gt;below&lt;/a&gt;) makes no difference to this as the catch-all function will not be called to implement a missing dereference operator.</source>
          <target state="translated">如果这些运算符未显式重载，则它们将以正常方式工作，产生底层标量，数组或任何存储对象数据的内容（如果取消引用运算符不匹配，则会显示相应的错误消息）。定义一个 &lt;code&gt;'nomethod'&lt;/code&gt; （请参见&lt;a href=&quot;#nomethod&quot;&gt;下文&lt;/a&gt;）对此没有任何区别，因为将不会调用catch-all函数来实现缺少的解除引用运算符。</target>
        </trans-unit>
        <trans-unit id="e7e81ed1aafee87e39f3bf4df7400134171b1b47" translate="yes" xml:space="preserve">
          <source>If these were ordinary paragraphs, the Pod parser would try to expand the &quot;E&amp;lt;/em&amp;gt;&quot; (in the first paragraph) as a formatting code, just like &quot;E&amp;lt;lt&amp;gt;&quot; or &quot;E&amp;lt;eacute&amp;gt;&quot;. But since this is in a &quot;=begin</source>
          <target state="translated">如果这些是普通段落，则Pod解析器将尝试将&amp;ldquo; E &amp;lt;/ em&amp;gt;&amp;rdquo;（在第一段中）扩展为格式代码，就像&amp;ldquo; E &amp;lt;lt&amp;gt;&amp;rdquo;或&amp;ldquo; E &amp;lt;eacute&amp;gt;&amp;rdquo;一样。但是由于这是在&amp;ldquo; =开始</target>
        </trans-unit>
        <trans-unit id="fc6b5f11ab146ad9637defe5808c195788361c30" translate="yes" xml:space="preserve">
          <source>If these weren't meant to be POSIX classes, this warning message is spurious, and can be suppressed by reordering things, such as</source>
          <target state="translated">如果这些不是为了POSIX类,这个警告信息是虚假的,可以通过重新排序来抑制,如</target>
        </trans-unit>
        <trans-unit id="4135dfc8a9407c20cefc1359ee43028a8d9e9a77" translate="yes" xml:space="preserve">
          <source>If they are not composable, it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果它们不可组合，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a6c7139e709a41aafbcb832650d6f1102386857" translate="yes" xml:space="preserve">
          <source>If they are not composable, it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">如果它们不可组合，则返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7928853cb29cf0ed7b6549f627a68e66710a9993" translate="yes" xml:space="preserve">
          <source>If they wanted to clobber something, they might say:</source>
          <target state="translated">如果他们想砸东西,他们可能会说:</target>
        </trans-unit>
        <trans-unit id="005637a170229ceb4ce45f18dce99b88396f9f92" translate="yes" xml:space="preserve">
          <source>If things aren't broken, upgrading perl may break them (or at least issue new warnings).</source>
          <target state="translated">如果事情没有被破坏,升级perl可能会破坏它们(或者至少发出新的警告)。</target>
        </trans-unit>
        <trans-unit id="f401b770207b3e95d6e44d96ff6ad2d9bf229b05" translate="yes" xml:space="preserve">
          <source>If this attribute is set to true, the parser will not ignore empty &lt;code&gt;=over&lt;/code&gt;/&lt;code&gt;=back&lt;/code&gt; blocks. The type of &lt;code&gt;=over&lt;/code&gt; will be</source>
          <target state="translated">如果将此属性设置为true，则解析器将不会忽略空的 &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; 块。 &lt;code&gt;=over&lt;/code&gt; 的类型将是</target>
        </trans-unit>
        <trans-unit id="af3184843a959ec8cbcadf6df48b4b495b6b3f78" translate="yes" xml:space="preserve">
          <source>If this behaviour is not desirable, the &lt;code&gt;error&lt;/code&gt; attribute may be used to hold a reference to a variable, which will be used to store the diagnostics. The variable is made a reference to an array of hash references. Each hash contain a single key/value pair where the key is the name of the file, and the value is the error message (including the contents of &lt;code&gt;$!&lt;/code&gt; when appropriate). If a general error is encountered the diagnostic key will be empty.</source>
          <target state="translated">如果这种行为是不希望的，则可以使用 &lt;code&gt;error&lt;/code&gt; 属性保存对变量的引用，该变量将用于存储诊断信息。将该变量作为对哈希引用数组的引用。每个哈希包含一个键/值对，其中键是文件名，值是错误消息（适当时包括 &lt;code&gt;$!&lt;/code&gt; 的内容）。如果遇到一般错误，诊断键将为空。</target>
        </trans-unit>
        <trans-unit id="b9e80a2a00d7763bcb33166ac12286d96be2d204" translate="yes" xml:space="preserve">
          <source>If this bit is set and a file [but not a directory] named &lt;code&gt;$sNewName&lt;/code&gt; already exists, then it will be replaced by &lt;code&gt;$sOldName&lt;/code&gt;. If this bit is not set then &lt;code&gt;MoveFileEx&lt;/code&gt; will fail rather than replace an existing &lt;code&gt;$sNewName&lt;/code&gt;.</source>
          <target state="translated">如果设置了此位并且已经存在名为 &lt;code&gt;$sNewName&lt;/code&gt; 的文件[但没有目录] ，则它将由 &lt;code&gt;$sOldName&lt;/code&gt; 替换。如果未设置此位，则 &lt;code&gt;MoveFileEx&lt;/code&gt; 将失败，而不是替换现有的 &lt;code&gt;$sNewName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa9fb1ea3eae474e9c243073b7277960fe7cd8b7" translate="yes" xml:space="preserve">
          <source>If this bit is set, then calls to &lt;code&gt;CloseHandle&lt;/code&gt; against this handle will be ignored, leaving the handle open and usable.</source>
          <target state="translated">如果设置了该位，则将忽略对此句柄的 &lt;code&gt;CloseHandle&lt;/code&gt; 调用，从而使句柄保持打开状态并可用。</target>
        </trans-unit>
        <trans-unit id="cb0ba2e4466abc8ea8b16e3596960ca402d75037" translate="yes" xml:space="preserve">
          <source>If this bit is set, then children of this process who inherit handles [that is, processes created by calls to the Win32 &lt;code&gt;CreateProcess&lt;/code&gt; API with the &lt;code&gt;bInheritHandles&lt;/code&gt; parameter specified as &lt;code&gt;TRUE&lt;/code&gt;], will inherit this particular object handle.</source>
          <target state="translated">如果设置了此位，则继承进程的子进程[即，通过将 &lt;code&gt;bInheritHandles&lt;/code&gt; 参数指定为 &lt;code&gt;TRUE&lt;/code&gt; 的Win32 &lt;code&gt;CreateProcess&lt;/code&gt; API调用创建的进程]将继承此特定的对象句柄。</target>
        </trans-unit>
        <trans-unit id="cfffc413c869bcf00848584ef88629d0cba8d4b7" translate="yes" xml:space="preserve">
          <source>If this command lists any paths that don't exist on your system, then you may need to move the appropriate libraries to these locations, or create symbolic links, aliases, or shortcuts appropriately. &lt;code&gt;@INC&lt;/code&gt; is also printed as part of the output of</source>
          <target state="translated">如果此命令列出了系统上不存在的任何路径，则可能需要将适当的库移至这些位置，或适当地创建符号链接，别名或快捷方式。 &lt;code&gt;@INC&lt;/code&gt; 也作为输出的一部分打印</target>
        </trans-unit>
        <trans-unit id="4975023e8ced451b521e66f7c64344d22c9935aa" translate="yes" xml:space="preserve">
          <source>If this directory is exactly the same as the prefix which was compiled into</source>
          <target state="translated">如果这个目录与被编译为</target>
        </trans-unit>
        <trans-unit id="285c8028480f1bd9da414482302791b2b2e5917d" translate="yes" xml:space="preserve">
          <source>If this displays any &lt;code&gt;D&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt; symbols (or possibly &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; ), you have non-const data. The symbols the &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; removed are as follows: &lt;code&gt;Tt&lt;/code&gt; are</source>
          <target state="translated">如果显示任何 &lt;code&gt;D&lt;/code&gt; 或 &lt;code&gt;d&lt;/code&gt; 符号（或可能显示 &lt;code&gt;C&lt;/code&gt; 或 &lt;code&gt;c&lt;/code&gt; ），则说明您具有非常量数据。 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 删除的符号如下： &lt;code&gt;Tt&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="e00722416b7c55f26c8b791511437fbf3bd5fa48" translate="yes" xml:space="preserve">
          <source>If this displays any &lt;code&gt;D&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt; symbols (or possibly &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt;), you have non-const data. The symbols the &lt;code&gt;grep&lt;/code&gt; removed are as follows: &lt;code&gt;Tt&lt;/code&gt; are</source>
          <target state="translated">如果显示任何 &lt;code&gt;D&lt;/code&gt; 或 &lt;code&gt;d&lt;/code&gt; 符号（或者可能显示 &lt;code&gt;C&lt;/code&gt; 或 &lt;code&gt;c&lt;/code&gt; ），则说明您具有非常量数据。 &lt;code&gt;grep&lt;/code&gt; 删除的符号如下： &lt;code&gt;Tt&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="4abdac7aa391382bc2754c2374cb867d27e05580" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to a true value, all of the functions defined by this module (color(), colored(), and all of the constants not previously used in the program) will not output any escape sequences and instead will just return the empty string or pass through the original text as appropriate. This is intended to support easy use of scripts using this module on platforms that don't support ANSI escape sequences.</source>
          <target state="translated">如果这个环境变量设置为true,那么这个模块定义的所有函数(color(),colored(),以及所有之前没有在程序中使用的常量)将不会输出任何转义序列,而只是返回空字符串或者适当地通过原文。这样做的目的是为了支持在不支持ANSI转义序列的平台上使用本模块的脚本,方便使用。</target>
        </trans-unit>
        <trans-unit id="38f035ce9a9a2458333cab9abdbe9a0ca164bacc" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to a true value, all of the functions defined by this module (color(), colored(), and all of the constants) will not output any escape sequences and instead will just return the empty string or pass through the original text as appropriate. This is intended to support easy use of scripts using this module on platforms that don't support ANSI escape sequences.</source>
          <target state="translated">如果这个环境变量被设置为true,那么这个模块定义的所有函数(color(),colored(),和所有的常量)将不会输出任何转义序列,而只是返回空字符串或者适当地通过原始文本。这样做的目的是为了支持在不支持ANSI转义序列的平台上使用本模块的脚本。</target>
        </trans-unit>
        <trans-unit id="f18c65b6596250b7fc84f994b0860dfb64443933" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to any value, it suppresses generation of escape sequences the same as if ANSI_COLORS_DISABLED is set to a true value. This implements the &lt;a href=&quot;https://no-color.org/&quot;&gt;https://no-color.org/&lt;/a&gt; informal standard. Programs that want to enable color despite NO_COLOR being set will need to unset that environment variable before any constant or function provided by this module is used.</source>
          <target state="translated">如果将此环境变量设置为任何值，则与ANSI_COLORS_DISABLED设置为真值一样，它抑制转义序列的生成。这实现了&lt;a href=&quot;https://no-color.org/&quot;&gt;https://no-color.org/&lt;/a&gt;非正式标准。即使设置了NO_COLOR但仍要启用颜色的程序将需要在使用此模块提供的任何常量或函数之前取消设置该环境变量。</target>
        </trans-unit>
        <trans-unit id="876cbaf8d98a55944949f12e34d25c434a20bad7" translate="yes" xml:space="preserve">
          <source>If this environment variable is true then normal install processes will always overwrite older identical files during the install process.</source>
          <target state="translated">如果这个环境变量为真,那么在安装过程中,正常的安装过程将总是覆盖旧的相同文件。</target>
        </trans-unit>
        <trans-unit id="e053edd732d7c1c9c9166271bdb64b8b374b5d23" translate="yes" xml:space="preserve">
          <source>If this event is nested inside of other events, this should be the depth of nesting. (This is mainly for subtests)</source>
          <target state="translated">如果这个事件被嵌套在其他事件里面,这应该是嵌套的深度。(这主要用于子测试)</target>
        </trans-unit>
        <trans-unit id="30b941d4f353a594151f4f0a38deaca7c7d4a4d4" translate="yes" xml:space="preserve">
          <source>If this feature is enabled (which is the default under a &lt;code&gt;use 5.16&lt;/code&gt; or higher declaration), EXPR is considered to be in the same encoding as the surrounding program. Thus if &lt;a href=&quot;utf8&quot;&gt;&lt;code&gt;use utf8&lt;/code&gt;&lt;/a&gt; is in effect, the string will be treated as being UTF-8 encoded. Otherwise, the string is considered to be a sequence of independent bytes. Bytes that correspond to ASCII-range code points will have their normal meanings for operators in the string. The treatment of the other bytes depends on if the &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;'unicode_strings&quot;&lt;/code&gt; feature&lt;/a&gt; is in effect.</source>
          <target state="translated">如果启用了此功能（在 &lt;code&gt;use 5.16&lt;/code&gt; 或更高版本的声明中为默认设置），则认为EXPR与周围程序具有相同的编码。因此，如果有效&lt;a href=&quot;utf8&quot;&gt; &lt;code&gt;use utf8&lt;/code&gt; &lt;/a&gt;，则该字符串将被视为UTF-8编码。否则，该字符串被认为是一个独立字节序列。对应于ASCII范围代码点的字节对于字符串中的运算符将具有其正常含义。其他字节的处理方式取决于&lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;'unicode_strings&quot;&lt;/code&gt; 功能&lt;/a&gt;是否有效。</target>
        </trans-unit>
        <trans-unit id="f7eb5123560aed4a2756b83ae3d2c52a26a17f8b" translate="yes" xml:space="preserve">
          <source>If this field is omitted, it defaults to 1 (true).</source>
          <target state="translated">如果省略此字段,则默认为1(true)。</target>
        </trans-unit>
        <trans-unit id="07fe5d03fc19f605909f122565e563658cd995e6" translate="yes" xml:space="preserve">
          <source>If this field is zero then &lt;code&gt;PerlIO_pushed&lt;/code&gt; does not malloc anything and assumes layer's Pushed function will do any required layer stack manipulation - used to avoid malloc/free overhead for dummy layers. If the field is non-zero it must be at least the size of &lt;code&gt;PerlIOl&lt;/code&gt; , &lt;code&gt;PerlIO_pushed&lt;/code&gt; will allocate memory for the layer's data structures and link new layer onto the stream's stack. (If the layer's Pushed method returns an error indication the layer is popped again.)</source>
          <target state="translated">如果此字段为零，则 &lt;code&gt;PerlIO_pushed&lt;/code&gt; 不会分配任何内容，并假定层的Pushed函数将执行任何必需的层堆栈操作-用于避免虚拟层的malloc /空闲开销。如果该字段不为零，则必须至少为 &lt;code&gt;PerlIOl&lt;/code&gt; 的大小， &lt;code&gt;PerlIO_pushed&lt;/code&gt; 将为该层的数据结构分配内存，并将新层链接到流的堆栈上。（如果图层的Pushed方法返回错误指示，则该图层将再次弹出。）</target>
        </trans-unit>
        <trans-unit id="a5a45df8d66f9a394f3a4c96ed9c17f127fd5118" translate="yes" xml:space="preserve">
          <source>If this field is zero then &lt;code&gt;PerlIO_pushed&lt;/code&gt; does not malloc anything and assumes layer's Pushed function will do any required layer stack manipulation - used to avoid malloc/free overhead for dummy layers. If the field is non-zero it must be at least the size of &lt;code&gt;PerlIOl&lt;/code&gt;, &lt;code&gt;PerlIO_pushed&lt;/code&gt; will allocate memory for the layer's data structures and link new layer onto the stream's stack. (If the layer's Pushed method returns an error indication the layer is popped again.)</source>
          <target state="translated">如果此字段为零，则 &lt;code&gt;PerlIO_pushed&lt;/code&gt; 不会分配任何内容，并假定层的Pushed函数将执行任何必需的层堆栈操作-用于避免虚拟层的malloc /空闲开销。如果该字段不为零，则必须至少为 &lt;code&gt;PerlIOl&lt;/code&gt; 的大小， &lt;code&gt;PerlIO_pushed&lt;/code&gt; 将为该层的数据结构分配内存，并将新层链接到流的堆栈上。 （如果该图层的Pushed方法返回错误指示，则该图层将再次弹出。）</target>
        </trans-unit>
        <trans-unit id="6eff879286b0f884c3e6b0dc473e05a91d80d4a8" translate="yes" xml:space="preserve">
          <source>If this function is being sourced in from a separate file via &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, then this is probably just fine. If it's all in the main program, you'll need to arrange for the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; to be executed early, either by putting the whole block above your main program, or more likely, placing merely a &lt;code&gt;BEGIN&lt;/code&gt; code block around it to make sure it gets executed before your program starts to run:</source>
          <target state="translated">如果此功能是通过 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 从单独的文件中获取的，那么可能就很好了。如果所有内容都在主程序中，则需要安排 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 尽早执行，方法是将整个代码块放在主程序上方，或者更有可能的是，仅在其周围放置一个 &lt;code&gt;BEGIN&lt;/code&gt; 代码块以确保其获得在程序开始运行之前执行：</target>
        </trans-unit>
        <trans-unit id="3b08fb8fb677146606e9cfcd0ad7806affc639d2" translate="yes" xml:space="preserve">
          <source>If this function is being sourced in from a separate file via &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt;, then this is probably just fine. If it's all in the main program, you'll need to arrange for the &lt;code&gt;my&lt;/code&gt; to be executed early, either by putting the whole block above your main program, or more likely, placing merely a &lt;code&gt;BEGIN&lt;/code&gt; code block around it to make sure it gets executed before your program starts to run:</source>
          <target state="translated">如果此功能是通过 &lt;code&gt;require&lt;/code&gt; 或 &lt;code&gt;use&lt;/code&gt; 从单独的文件中获取的，那么可能就很好了。如果所有内容都在主程序中，则需要安排 &lt;code&gt;my&lt;/code&gt; 尽早执行，方法是将整个代码块放在主程序之上，或者更有可能的是，仅在其周围放置一个 &lt;code&gt;BEGIN&lt;/code&gt; 代码块以确保其获得在程序开始运行之前执行：</target>
        </trans-unit>
        <trans-unit id="e5121e7b7256f6d0ab378dc9bff9a8c6dad43577" translate="yes" xml:space="preserve">
          <source>If this happens to you, there's not much you can do except switch to use a different locale or use &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; to translate from the locale into UTF-8; if that's impracticable, you have been warned that some things may break.</source>
          <target state="translated">如果您遇到这种情况，除了切换为使用其他语言环境或使用&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;将语言环境转换为UTF-8 之外，您无能为力。如果这不可行，则已警告您某些事情可能会中断。</target>
        </trans-unit>
        <trans-unit id="faa64c33180aaefa8582782daf214d7a2f4780a7" translate="yes" xml:space="preserve">
          <source>If this interior sequence is nested inside of another interior sequence, then the outer/parent sequence that contains it is returned. Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果此内部序列嵌套在另一个内部序列内部，则返回包含它的外部/父序列。否则，将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf7d995797b0338af1d03b9d03a8511323aeb269" translate="yes" xml:space="preserve">
          <source>If this is a TODO test and an 'ok' line, this method returns true. Otherwise, it will always return false (regardless of passing status on non-todo tests).</source>
          <target state="translated">如果这是一个TODO测试,并且是一个'ok'行,那么这个方法就会返回true,否则,它将总是返回false(不管非todo测试的通过状态如何)。否则,它将总是返回false(不管非待办事项测试的通过状态如何)。</target>
        </trans-unit>
        <trans-unit id="604eb865cff5427575c78b447eb628e9c645992c" translate="yes" xml:space="preserve">
          <source>If this is a simple scalar then it will be treated as a boolean for the 'buffered' setting. If this is a hash reference then it will be used as a parameters hash. The param hash will be used for hub construction (with the specified keys removed).</source>
          <target state="translated">如果这是一个简单的标量,那么它将被视为 &quot;缓冲 &quot;设置的布尔值。如果这是一个哈希引用,那么它将被用作参数哈希。参数哈希将被用于枢纽的构建(删除指定的键)。</target>
        </trans-unit>
        <trans-unit id="f7666722db0ac2cfa26e5cabc574e02e68556877" translate="yes" xml:space="preserve">
          <source>If this is being called as &lt;code&gt;re::regname&lt;/code&gt; , &lt;code&gt;re::regnames&lt;/code&gt; or &lt;code&gt;re::regnames_count&lt;/code&gt; , if any. The first two will be combined with &lt;code&gt;RXapif_ONE&lt;/code&gt; or &lt;code&gt;RXapif_ALL&lt;/code&gt; .</source>
          <target state="translated">如果将其称为 &lt;code&gt;re::regname&lt;/code&gt; ， &lt;code&gt;re::regnames&lt;/code&gt; 或 &lt;code&gt;re::regnames_count&lt;/code&gt; （如果有）。前两个将与 &lt;code&gt;RXapif_ONE&lt;/code&gt; 或 &lt;code&gt;RXapif_ALL&lt;/code&gt; 组合。</target>
        </trans-unit>
        <trans-unit id="79a068f47ba129d0ff77349a01057b9518f8fbed" translate="yes" xml:space="preserve">
          <source>If this is being called as &lt;code&gt;re::regname&lt;/code&gt;, &lt;code&gt;re::regnames&lt;/code&gt; or &lt;code&gt;re::regnames_count&lt;/code&gt;, if any. The first two will be combined with &lt;code&gt;RXapif_ONE&lt;/code&gt; or &lt;code&gt;RXapif_ALL&lt;/code&gt;.</source>
          <target state="translated">如果将其称为 &lt;code&gt;re::regname&lt;/code&gt; ， &lt;code&gt;re::regnames&lt;/code&gt; 或 &lt;code&gt;re::regnames_count&lt;/code&gt; （如果有）。前两个将与 &lt;code&gt;RXapif_ONE&lt;/code&gt; 或 &lt;code&gt;RXapif_ALL&lt;/code&gt; 组合。</target>
        </trans-unit>
        <trans-unit id="9edbce2664bb4f91955d900ea95b27deaa6b5a4b" translate="yes" xml:space="preserve">
          <source>If this is in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; it will be passed to &lt;code&gt;Perl_fbm_instr&lt;/code&gt; by &lt;code&gt;pp_split&lt;/code&gt; which will treat the subject string as a multi-line string.</source>
          <target state="translated">如果这是在 &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; 它会被传递给 &lt;code&gt;Perl_fbm_instr&lt;/code&gt; 由 &lt;code&gt;pp_split&lt;/code&gt; 将治疗目标字符串作为多行字符串。</target>
        </trans-unit>
        <trans-unit id="3e0c042153cf9f6ff54247584b15672ab611a4af" translate="yes" xml:space="preserve">
          <source>If this is negative, and amounts to &lt;code&gt;HEf_SVKEY&lt;/code&gt; , it indicates the entry holds an &lt;code&gt;SV*&lt;/code&gt; key. Otherwise, holds the actual length of the key. Can be assigned to. The &lt;code&gt;HePV()&lt;/code&gt; macro is usually preferable for finding key lengths.</source>
          <target state="translated">如果为负，并且等于 &lt;code&gt;HEf_SVKEY&lt;/code&gt; ，则表明该条目包含 &lt;code&gt;SV*&lt;/code&gt; 密钥。否则，保留密钥的实际长度。可以分配给。通常，最好使用 &lt;code&gt;HePV()&lt;/code&gt; 宏来查找密钥长度。</target>
        </trans-unit>
        <trans-unit id="f90d0f4d493e8df7c15bcc83bca70a42ffcdb6df" translate="yes" xml:space="preserve">
          <source>If this is negative, and amounts to &lt;code&gt;HEf_SVKEY&lt;/code&gt;, it indicates the entry holds an &lt;code&gt;SV*&lt;/code&gt; key. Otherwise, holds the actual length of the key. Can be assigned to. The &lt;code&gt;HePV()&lt;/code&gt; macro is usually preferable for finding key lengths.</source>
          <target state="translated">如果为负，并且等于 &lt;code&gt;HEf_SVKEY&lt;/code&gt; ，则表明该条目包含 &lt;code&gt;SV*&lt;/code&gt; 密钥。否则，保留密钥的实际长度。可以分配给。通常，最好使用 &lt;code&gt;HePV()&lt;/code&gt; 宏来查找密钥长度。</target>
        </trans-unit>
        <trans-unit id="ddda819aeefa94d361f2fc0677ccc065e6c33f4f" translate="yes" xml:space="preserve">
          <source>If this is starting to sound scarier than it's worth, relax. Perl has some features to help you avoid its most common pitfalls. The best way to avoid getting confused is to start every program like this:</source>
          <target state="translated">如果这听起来很可怕,那么请放松。Perl有一些功能可以帮助你避免最常见的陷阱。避免混淆的最好方法是这样启动每个程序。</target>
        </trans-unit>
        <trans-unit id="c2cd7396387cdb373b2dd32a6d21ffa39a9fbdd0" translate="yes" xml:space="preserve">
          <source>If this is true, none of that will be done.</source>
          <target state="translated">如果这是真的,这些都不会做。</target>
        </trans-unit>
        <trans-unit id="998c59b2484753d1482d0ff9ba7497a84e80fcd4" translate="yes" xml:space="preserve">
          <source>If this is what you intended then you can silence the warning by using &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/${\}/&lt;/a&gt;&lt;/code&gt; (for example: &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo${\}s+bar/&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果您打算这样做，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/${\}/&lt;/a&gt;&lt;/code&gt; （例如： &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo${\}s+bar/&lt;/a&gt;&lt;/code&gt; ）使警告静音。</target>
        </trans-unit>
        <trans-unit id="44c23df76d34643bd06f7fcbfd01951d86e6affe" translate="yes" xml:space="preserve">
          <source>If this is what you intended then you can silence the warning by using &lt;code&gt;m/${\}/&lt;/code&gt; (for example: &lt;code&gt;m/foo${\}s+bar/&lt;/code&gt;).</source>
          <target state="translated">如果这是您的预期目的，则可以使用 &lt;code&gt;m/${\}/&lt;/code&gt; （例如： &lt;code&gt;m/foo${\}s+bar/&lt;/code&gt; ）使警告静音。</target>
        </trans-unit>
        <trans-unit id="b2f4b7328771b0d9e19ff0a7ce5f9c13e4b36300" translate="yes" xml:space="preserve">
          <source>If this is your first use of Sys::Syslog, you must read the doc.</source>
          <target state="translated">如果这是你第一次使用Sys::Syslog,你必须阅读文档。</target>
        </trans-unit>
        <trans-unit id="51d2478f45a9802ed436c7d6c5c2a5bb72aeb395" translate="yes" xml:space="preserve">
          <source>If this optimization is applicable, &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; will emit a &lt;code&gt;dXSTARG;&lt;/code&gt; definition at the start of the generated XSUB code, and type (see below) dependent code to set &lt;code&gt;TARG&lt;/code&gt; and push it on the stack at the end of the generated XSUB code.</source>
          <target state="translated">如果适用此优化，则 &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 将发出 &lt;code&gt;dXSTARG;&lt;/code&gt; 否则，将发出dXSTARG。定义在生成的XSUB代码的开头，然后键入（参见下文）相关代码以设置 &lt;code&gt;TARG&lt;/code&gt; 并将其压入生成的XSUB代码末尾的堆栈中。</target>
        </trans-unit>
        <trans-unit id="51861420a23f19227e776c6bc3a38fdcea309df1" translate="yes" xml:space="preserve">
          <source>If this option is not present, the value stored in XFL field will be determined by the setting of the &lt;code&gt;Level&lt;/code&gt; option.</source>
          <target state="translated">如果不存在此选项，则XFL字段中存储的值将由&amp;ldquo; &lt;code&gt;Level&lt;/code&gt; 选项的设置确定。</target>
        </trans-unit>
        <trans-unit id="415323d14a6e182890345d78f7ae3f3149cdff1f" translate="yes" xml:space="preserve">
          <source>If this option is set and the input file/buffer is not compressed data, the module will allow reading of it anyway.</source>
          <target state="translated">如果设置了这个选项,并且输入的文件/缓冲区不是压缩数据,那么无论如何模块都会允许读取它。</target>
        </trans-unit>
        <trans-unit id="805aae725ba9def01f764562edc887adcbc46d85" translate="yes" xml:space="preserve">
          <source>If this option is set, Pod::Man will instead output UTF-8. If your *roff implementation can handle it, this is the best output format to use and avoids corruption of documents containing non-ASCII characters. However, be warned that *roff source with literal UTF-8 characters is not supported by many implementations and may even result in segfaults and other bad behavior.</source>
          <target state="translated">如果设置了这个选项,Pod::Man将代替UTF-8输出,如果你的*roff实现能够处理它,这是最好的输出格式,并避免包含非ASCII字符的文件损坏。如果你的*roff实现可以处理它,这是最好的输出格式,可以避免包含非ASCII字符的文档损坏。然而,要注意的是,许多实现并不支持使用UTF-8字符的*roff源码,甚至可能导致 segfaults和其他不良行为。</target>
        </trans-unit>
        <trans-unit id="9276827e0a43ce0cd98e803156d215d94a1cfced" translate="yes" xml:space="preserve">
          <source>If this paragraph is a command paragraph, then this method will return the name of the command (</source>
          <target state="translated">如果这一段是一个命令段,那么这个方法将返回命令的名称(</target>
        </trans-unit>
        <trans-unit id="bcc44b3b4b66c03b7a2464f3e737f50efd9dbf21" translate="yes" xml:space="preserve">
          <source>If this paragraph is a command paragraph, then this method will return the prefix used to denote the command (which should be the string &quot;=&quot; or &quot;==&quot;).</source>
          <target state="translated">如果这个段落是一个命令段落,那么这个方法将返回用来表示命令的前缀(应该是字符串&quot;=&quot;或&quot;==&quot;)。</target>
        </trans-unit>
        <trans-unit id="97d5af9792754821d43f791eb7a3e99d0e1078a4" translate="yes" xml:space="preserve">
          <source>If this paragraph is a command paragraph, then this method will return the text used to separate the command name from the rest of the paragraph (if any).</source>
          <target state="translated">如果这个段落是一个命令段落,那么这个方法将返回用于将命令名称与段落的其余部分分开的文本(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="b75f187e2f383fe73ad62fc9d325ab173aba9b5e" translate="yes" xml:space="preserve">
          <source>If this parameter is not used, certain error conditions may raise a fatal error that will cause the program to halt, unless trapped in an &lt;code&gt;eval&lt;/code&gt; block.</source>
          <target state="translated">如果不使用此参数，则某些错误条件可能会引发致命错误，除非程序陷入 &lt;code&gt;eval&lt;/code&gt; 块中，否则它将导致程序停止运行。</target>
        </trans-unit>
        <trans-unit id="f1f4b76081f3628eb70be0fbee8dbf0d6e9f3ca4" translate="yes" xml:space="preserve">
          <source>If this parameter is not used, certain error conditions may raise a fatal error that will cause the program will halt, unless trapped in an &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block.</source>
          <target state="translated">如果不使用此参数，则某些错误条件可能会引发致命错误，除非程序陷入 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 块中，否则它将导致程序停止运行。</target>
        </trans-unit>
        <trans-unit id="0d2fb08e29fba6225fdf1f445f37f2366e459721" translate="yes" xml:space="preserve">
          <source>If this regexp matches, &lt;code&gt;$1&lt;/code&gt; contains a string starting with &lt;code&gt;'ab'&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; is either set to &lt;code&gt;'cd'&lt;/code&gt; or &lt;code&gt;'ef'&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; equals either &lt;code&gt;'gi'&lt;/code&gt; or &lt;code&gt;'j'&lt;/code&gt; , and &lt;code&gt;$4&lt;/code&gt; is either set to &lt;code&gt;'gi'&lt;/code&gt; , just like &lt;code&gt;$3&lt;/code&gt; , or it remains undefined.</source>
          <target state="translated">如果此正则表达式匹配，则 &lt;code&gt;$1&lt;/code&gt; 包含以 &lt;code&gt;'ab'&lt;/code&gt; 开头的字符串， &lt;code&gt;$2&lt;/code&gt; 设置为 &lt;code&gt;'cd'&lt;/code&gt; 或 &lt;code&gt;'ef'&lt;/code&gt; ， &lt;code&gt;$3&lt;/code&gt; 等于 &lt;code&gt;'gi'&lt;/code&gt; 或 &lt;code&gt;'j'&lt;/code&gt; ，而 &lt;code&gt;$4&lt;/code&gt; 设置为 &lt;code&gt;'gi'&lt;/code&gt; ，只是例如 &lt;code&gt;$3&lt;/code&gt; ，否则它仍未定义。</target>
        </trans-unit>
        <trans-unit id="1b5fa9692a7ddbf5956b5114988e2959b2c5e493" translate="yes" xml:space="preserve">
          <source>If this regexp matches, &lt;code&gt;$1&lt;/code&gt; contains a string starting with &lt;code&gt;'ab'&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt; is either set to &lt;code&gt;'cd'&lt;/code&gt; or &lt;code&gt;'ef'&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt; equals either &lt;code&gt;'gi'&lt;/code&gt; or &lt;code&gt;'j'&lt;/code&gt;, and &lt;code&gt;$4&lt;/code&gt; is either set to &lt;code&gt;'gi'&lt;/code&gt;, just like &lt;code&gt;$3&lt;/code&gt;, or it remains undefined.</source>
          <target state="translated">如果此正则表达式匹配，则 &lt;code&gt;$1&lt;/code&gt; 包含以 &lt;code&gt;'ab'&lt;/code&gt; 开头的字符串， &lt;code&gt;$2&lt;/code&gt; 设置为 &lt;code&gt;'cd'&lt;/code&gt; 或 &lt;code&gt;'ef'&lt;/code&gt; ， &lt;code&gt;$3&lt;/code&gt; 等于 &lt;code&gt;'gi'&lt;/code&gt; 或 &lt;code&gt;'j'&lt;/code&gt; ，而 &lt;code&gt;$4&lt;/code&gt; 设置为 &lt;code&gt;'gi'&lt;/code&gt; ，只是例如 &lt;code&gt;$3&lt;/code&gt; ，否则它仍未定义。</target>
        </trans-unit>
        <trans-unit id="9bf2f5a008449abe516d485f423f30c756bf9374" translate="yes" xml:space="preserve">
          <source>If this seems like a lot, then feel free to inherit from merely the standard Tie::StdHash module for most of your methods, redefining only the interesting ones. See &lt;a href=&quot;Tie::Hash&quot;&gt;Tie::Hash&lt;/a&gt; for details.</source>
          <target state="translated">如果这看起来很多，请随意从大多数方法的标准Tie :: StdHash模块继承，仅重新定义有趣的方法。有关详细信息，请参见&lt;a href=&quot;Tie::Hash&quot;&gt;Tie :: Hash&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4f92dc123bfc535dc7925652fedf35a2b5f0876" translate="yes" xml:space="preserve">
          <source>If this seems like a lot, then feel free to inherit from merely the standard Tie::StdHash module for most of your methods, redefining only the interesting ones. See &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; for details.</source>
          <target state="translated">如果这看起来很多，请随意从大多数方法的标准Tie :: StdHash模块继承，仅重新定义有趣的方法。有关详细信息，请参见&lt;a href=&quot;tie/hash&quot;&gt;Tie :: Hash&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c67ef6ff224aaeb335a4c34ee8f8573b58ab3fc4" translate="yes" xml:space="preserve">
          <source>If this still doesn't work, look into the &lt;code&gt;clearerr&lt;/code&gt; method from &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;, which resets the error and end-of-file states on the handle.</source>
          <target state="translated">如果仍然 &lt;code&gt;clearerr&lt;/code&gt; ，请查看&lt;a href=&quot;IO::Handle&quot;&gt;IO :: Handle&lt;/a&gt;的clearerr方法，该方法将重置句柄上的错误和文件结束状态。</target>
        </trans-unit>
        <trans-unit id="d3f60efe640d39524c6e11c22deb74b1e7bd6e48" translate="yes" xml:space="preserve">
          <source>If this still doesn't work, look into the &lt;code&gt;clearerr&lt;/code&gt; method from &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;, which resets the error and end-of-file states on the handle.</source>
          <target state="translated">如果仍然 &lt;code&gt;clearerr&lt;/code&gt; ，请查看&lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt;的clearerr方法，该方法将重置句柄上的错误和文件结束状态。</target>
        </trans-unit>
        <trans-unit id="5f660c829995c0ccf8574939955dcb34cbb1fbc2" translate="yes" xml:space="preserve">
          <source>If this template key is true, enforces that if this key is provided by user input, its value is &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt;. This just means that the user is not allowed to pass &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as a value for this key and is equivalent to: allow =&amp;gt; sub { defined $_[0] &amp;amp;&amp;amp; OTHER TESTS }</source>
          <target state="translated">如果此模板密钥为true，则强制执行此操作（如果该密钥由用户输入提供），则将 &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 其值。这仅表示不允许用户将 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 作为此键的值传递，并且等效于：allow =&amp;gt; sub {defined $ _ [0] &amp;amp;&amp;amp; OTHER TESTS}</target>
        </trans-unit>
        <trans-unit id="e156c85e449c1c19860e80cb4d0bda5ed5967f61" translate="yes" xml:space="preserve">
          <source>If this template key is true, enforces that if this key is provided by user input, its value is &lt;code&gt;defined&lt;/code&gt;. This just means that the user is not allowed to pass &lt;code&gt;undef&lt;/code&gt; as a value for this key and is equivalent to: allow =&amp;gt; sub { defined $_[0] &amp;amp;&amp;amp; OTHER TESTS }</source>
          <target state="translated">如果此模板密钥为true，则强制执行此操作（如果该密钥由用户输入提供），则其值 &lt;code&gt;defined&lt;/code&gt; 。这仅表示不允许用户将 &lt;code&gt;undef&lt;/code&gt; 作为此键的值传递，并且等效于：allow =&amp;gt; sub {defined $ _ [0] &amp;amp;&amp;amp; OTHER TESTS}</target>
        </trans-unit>
        <trans-unit id="76bbabb48932b2f041b390c777de07be84c85182" translate="yes" xml:space="preserve">
          <source>If this value is defined but false then such an operation has ocurred, but should not impact later operations.</source>
          <target state="translated">如果定义了这个值,但为假,那么这样的操作已经发生,但不应该影响以后的操作。</target>
        </trans-unit>
        <trans-unit id="cc6a20a1fa0fe02624d3822b74f6ca89396c5ee4" translate="yes" xml:space="preserve">
          <source>If this variable is set to a true value, then &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; on Windows will not try to open the file. This means that the link count cannot be determined and file attributes may be out of date if additional hardlinks to the file exist. On the other hand, not opening the file is considerably faster, especially for files on network drives.</source>
          <target state="translated">如果将此变量设置为true值，则Windows上的 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 将不会尝试打开文件。这意味着无法确定链接数，并且如果存在到文件的其他硬链接，则文件属性可能已过期。另一方面，不打开文件的速度要快得多，尤其是对于网络驱动器上的文件。</target>
        </trans-unit>
        <trans-unit id="bea7dc99d361b98967fbf94336d0529e85ea5d0f" translate="yes" xml:space="preserve">
          <source>If this variable is set to a true value, then &lt;code&gt;stat()&lt;/code&gt; on Windows will not try to open the file. This means that the link count cannot be determined and file attributes may be out of date if additional hardlinks to the file exist. On the other hand, not opening the file is considerably faster, especially for files on network drives.</source>
          <target state="translated">如果将此变量设置为true值，则Windows上的 &lt;code&gt;stat()&lt;/code&gt; 将不会尝试打开文件。这意味着无法确定链接数，并且如果存在到文件的其他硬链接，则文件属性可能已过期。另一方面，不打开文件的速度要快得多，尤其是对于网络驱动器上的文件。</target>
        </trans-unit>
        <trans-unit id="65e9d7214894094637d48b5893992a1d4deebf1e" translate="yes" xml:space="preserve">
          <source>If this variable is true then such an operation has occurred and anything depending on this module cannot proceed until a reboot has occurred.</source>
          <target state="translated">如果这个变量为真,那么这样的操作就发生了,在重启之前,任何依赖于这个模块的操作都不能进行。</target>
        </trans-unit>
        <trans-unit id="0523b9c70c7c9e8111746aca12afc08517491534" translate="yes" xml:space="preserve">
          <source>If this warning does come from I/O, the easiest way to quiet it is simply to add the &lt;code&gt;:utf8&lt;/code&gt; layer,</source>
          <target state="translated">如果此警告确实来自I / O，则最简单的静默方法是添加 &lt;code&gt;:utf8&lt;/code&gt; 层，</target>
        </trans-unit>
        <trans-unit id="41c3e520fc9953b8c23b0cb154effeffba4245f7" translate="yes" xml:space="preserve">
          <source>If three (or more) arguments are specified, the open mode (including optional encoding) in the second argument are distinct from the filename in the third. If MODE is &lt;code&gt;&amp;lt;&lt;/code&gt; or nothing, the file is opened for input. If MODE is &lt;code&gt;&amp;gt;&lt;/code&gt;, the file is opened for output, with existing files first being truncated (&quot;clobbered&quot;) and nonexisting files newly created. If MODE is &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , the file is opened for appending, again being created if necessary.</source>
          <target state="translated">如果指定了三个（或更多）参数，则第二个参数中的打开模式（包括可选编码）与第三个参数中的文件名不同。如果MODE为 &lt;code&gt;&amp;lt;&lt;/code&gt; 或为空，则打开文件进行输入。如果MODE为 &lt;code&gt;&amp;gt;&lt;/code&gt; ，则打开文件以进行输出，首先将现有文件截断（&amp;ldquo;弄皱&amp;rdquo;），然后新创建不存在的文件。如果MODE为 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ，则打开文件以进行追加，并在必要时再次创建。</target>
        </trans-unit>
        <trans-unit id="977c9556940f8be99675602713d0721d1fa68782" translate="yes" xml:space="preserve">
          <source>If trailing data is present immediately after the zip archive and the &lt;code&gt;Transparent&lt;/code&gt; option is enabled, this method will consider that trailing data to be another member of the zip archive.</source>
          <target state="translated">如果在zip归档文件之后立即存在尾随数据，并且启用了&amp;ldquo; &lt;code&gt;Transparent&lt;/code&gt; 选项，则此方法将认为尾随数据是zip归档文件的另一个成员。</target>
        </trans-unit>
        <trans-unit id="2e10a47d1100af2f4e741fa10c714b1d6eb83c05" translate="yes" xml:space="preserve">
          <source>If true (the default value), we autogenerate a JavaScript in the output directory, and set our HTML files to use it. Currently, the JavaScript is used only to get the browser to remember what stylesheet it prefers. TODO: continue</source>
          <target state="translated">如果为true(默认值),我们会在输出目录下自动生成一个JavaScript,并设置我们的HTML文件使用它。目前,JavaScript只是用来让浏览器记住它喜欢的样式表。待办事项:继续</target>
        </trans-unit>
        <trans-unit id="634c500cd04e5d0b913158c1c6e9ccddc0f9bc06" translate="yes" xml:space="preserve">
          <source>If true (the default value), we autogenerate some CSS files in the output directory, and set our HTML files to use those. TODO: continue</source>
          <target state="translated">如果为true(默认值),我们会在输出目录中自动生成一些CSS文件,并设置我们的HTML文件使用这些文件。待办事项:继续</target>
        </trans-unit>
        <trans-unit id="ed672b2b381b7d94345040cc4eb4667fc3d97c8b" translate="yes" xml:space="preserve">
          <source>If true and a code reference, will be called with the symbolic link name and the directory it lives in as arguments. Otherwise, if true and warnings are on, warning &quot;symbolic_link_name is a dangling symbolic link\n&quot; will be issued. If false, the dangling symbolic link will be silently ignored.</source>
          <target state="translated">如果为真且有代码引用,将调用符号链接名和它所在的目录作为参数。否则,如果为真且警告开启,将发出警告 &quot;symbolic_link_name是一个悬空的符号链接&quot;。如果为false,则会默默地忽略这个悬空的符号链接。</target>
        </trans-unit>
        <trans-unit id="93e6a2b3c3a0187d609e46522f3b6f893e49aa02" translate="yes" xml:space="preserve">
          <source>If true is returned, those arguments &lt;b&gt;should&lt;/b&gt; in theory be processed with &lt;code&gt;quadmath_snprintf()&lt;/code&gt;, but in case there is more than one such format specifier (see &lt;a href=&quot;#quadmath_format_valid&quot;&gt;&quot;quadmath_format_valid&quot;&lt;/a&gt;), and if there is anything else beyond that one (even just a single byte), they &lt;b&gt;cannot&lt;/b&gt; be processed because &lt;code&gt;quadmath_snprintf()&lt;/code&gt; is very strict, accepting only one format spec, and nothing else. In this case, the code should probably fail.</source>
          <target state="translated">如果返回true，则这些参数&lt;b&gt;应&lt;/b&gt;在理论与处理 &lt;code&gt;quadmath_snprintf()&lt;/code&gt; ，但万一有不止一个这样的格式说明（见&lt;a href=&quot;#quadmath_format_valid&quot;&gt;&amp;ldquo;quadmath_format_valid&amp;rdquo;&lt;/a&gt;），如果有别的超出了一个（甚至只是一个字节），&lt;b&gt;则无法&lt;/b&gt;对其进行处理，因为 &lt;code&gt;quadmath_snprintf()&lt;/code&gt; 非常严格，仅接受一种格式规范，而不能接受其他任何规范。在这种情况下，代码可能会失败。</target>
        </trans-unit>
        <trans-unit id="3f3fdfd0a40c103a2211bdac354013485a8b6be3" translate="yes" xml:space="preserve">
          <source>If true is returned, those arguments &lt;b&gt;should&lt;/b&gt; in theory be processed with quadmath_snprintf(), but in case there is more than one such format specifier (see &lt;a href=&quot;#quadmath_format_single&quot;&gt;quadmath_format_single&lt;/a&gt;), and if there is anything else beyond that one (even just a single byte), they &lt;b&gt;cannot&lt;/b&gt; be processed because quadmath_snprintf() is very strict, accepting only one format spec, and nothing else. In this case, the code should probably fail.</source>
          <target state="translated">如果返回true，则这些参数&lt;b&gt;应&lt;/b&gt;在理论与quadmath_snprintf（）处理，但万一有不止一个这样的格式说明（见&lt;a href=&quot;#quadmath_format_single&quot;&gt;quadmath_format_single&lt;/a&gt;），如果有别的超出了一个（甚至只是一个字节），&lt;b&gt;无法&lt;/b&gt;处理它们，因为quadmath_snprintf（）非常严格，仅接受一种格式规范，而别无其他。在这种情况下，代码可能会失败。</target>
        </trans-unit>
        <trans-unit id="0653af7b3995880e12e86c1b6df46b2abdc8adcd" translate="yes" xml:space="preserve">
          <source>If true then &lt;code&gt;Configure&lt;/code&gt; will check each hostname given that it exists</source>
          <target state="translated">如果为true，则 &lt;code&gt;Configure&lt;/code&gt; 将检查每个存在的主机名</target>
        </trans-unit>
        <trans-unit id="5e192827bd7624c2eefa078600e9250f2fd8d099" translate="yes" xml:space="preserve">
          <source>If true then &lt;code&gt;make test&lt;/code&gt; may attempt to connect to hosts given in the configuration.</source>
          <target state="translated">如果为true，则 &lt;code&gt;make test&lt;/code&gt; 可以尝试连接到配置中给定的主机。</target>
        </trans-unit>
        <trans-unit id="0dfb0e1e33130859f2e7e4109870d6a5dff7d085" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;TAP::Harness&lt;/code&gt; will output the verbose results of running its tests.</source>
          <target state="translated">如果为true，则 &lt;code&gt;TAP::Harness&lt;/code&gt; 将输出运行其测试的详细结果。</target>
        </trans-unit>
        <trans-unit id="1bd986bfa48b8d9de9607995da53c20f474abed0" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;Test::Harness&lt;/code&gt; will output the verbose results of running its tests. Setting &lt;code&gt;$Test::Harness::verbose&lt;/code&gt; will override this, or you can use the &lt;code&gt;-v&lt;/code&gt; switch in the</source>
          <target state="translated">如果为true，则 &lt;code&gt;Test::Harness&lt;/code&gt; 将输出运行其测试的详细结果。设置 &lt;code&gt;$Test::Harness::verbose&lt;/code&gt; 将覆盖这一点，或者你可以使用 &lt;code&gt;-v&lt;/code&gt; 在开关</target>
        </trans-unit>
        <trans-unit id="44529fee5d3eb44416500710e8dc9bea67c57ded" translate="yes" xml:space="preserve">
          <source>If true, STDERR and STDOUT are the same filehandle. This may cause breakage if STDERR contains anything resembling TAP format, but does allow exact synchronization.</source>
          <target state="translated">如果为真,STDERR和STDOUT是同一个文件柄。如果STDERR包含任何类似于TAP格式的内容,这可能会导致中断,但确实允许精确同步。</target>
        </trans-unit>
        <trans-unit id="fe1c5580c4e77a7f54f6b42fc274494bf3ad60b5" translate="yes" xml:space="preserve">
          <source>If true, make install will be verbose</source>
          <target state="translated">如果为真,则make install将是啰嗦的。</target>
        </trans-unit>
        <trans-unit id="a169cfeed98e3c1eafec522650538e080de52944" translate="yes" xml:space="preserve">
          <source>If true, set the &lt;code&gt;SO_BROADCAST&lt;/code&gt; sockopt</source>
          <target state="translated">如果为true，则设置 &lt;code&gt;SO_BROADCAST&lt;/code&gt; sockopt</target>
        </trans-unit>
        <trans-unit id="2e14d9f9dc273a75bb28fef309ebf7b650f85381" translate="yes" xml:space="preserve">
          <source>If true, set the &lt;code&gt;SO_REUSEADDR&lt;/code&gt; sockopt</source>
          <target state="translated">如果为true，则设置 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; sockopt</target>
        </trans-unit>
        <trans-unit id="e89fb240c4dc14ea640fd2d16ea6df8791107ad3" translate="yes" xml:space="preserve">
          <source>If true, set the &lt;code&gt;SO_REUSEPORT&lt;/code&gt; sockopt (not all OSes implement this sockopt)</source>
          <target state="translated">如果为true，则设置 &lt;code&gt;SO_REUSEPORT&lt;/code&gt; sockopt（并非所有操作系统都实现此sockopt）</target>
        </trans-unit>
        <trans-unit id="dab1cddffad75299c410b1e954057e9efb6fb3e2" translate="yes" xml:space="preserve">
          <source>If true, uses proxy subs. See &lt;a href=&quot;ExtUtils::Constant::ProxySubs&quot;&gt;ExtUtils::Constant::ProxySubs&lt;/a&gt;.</source>
          <target state="translated">如果为true，则使用代理订阅。参见&lt;a href=&quot;ExtUtils::Constant::ProxySubs&quot;&gt;ExtUtils :: Constant :: ProxySubs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb2c5a318ef60df6e780dd24e4ef173dd23b6b3c" translate="yes" xml:space="preserve">
          <source>If true, uses proxy subs. See &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Constant::ProxySubs&quot;&gt;ExtUtils::Constant::ProxySubs&lt;/a&gt;.</source>
          <target state="translated">如果为true，则使用代理订阅。参见&lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Constant::ProxySubs&quot;&gt;ExtUtils :: Constant :: ProxySubs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33b670decc24a56dd9e5e0101143f31051cabe4b" translate="yes" xml:space="preserve">
          <source>If two arrays smartmatch each other, then they are deep copies of each others' values, as this example reports:</source>
          <target state="translated">如果两个数组互相smartmatch,那么它们就是彼此值的深度拷贝,就像这个例子所报告的那样。</target>
        </trans-unit>
        <trans-unit id="acee3e1d7871c445b42f87ba144a405a067cf53f" translate="yes" xml:space="preserve">
          <source>If two characters here and next (as code points) are composable (including Hangul Jamo/Syllables and Composition Exclusions), it returns the code point of the composite.</source>
          <target state="translated">如果这里和接下来的两个字符(作为代码点)是可以合成的(包括Hangul Jamo/音节和合成排除),它返回合成的代码点。</target>
        </trans-unit>
        <trans-unit id="5cba0eaa180ef04fc5494ba487a038ca330cd204" translate="yes" xml:space="preserve">
          <source>If type is non-Unix (see &lt;a href=&quot;#fileparse_set_fstype&quot;&gt;&quot;fileparse_set_fstype&quot;&lt;/a&gt;) then the pattern matching for suffix removal is performed case-insensitively, since those systems are not case-sensitive when opening existing files.</source>
          <target state="translated">如果type是非Unix（请参阅&lt;a href=&quot;#fileparse_set_fstype&quot;&gt;&amp;ldquo; fileparse_set_fstype&amp;rdquo;&lt;/a&gt;），则后缀删除的模式匹配不区分大小写，因为打开现有文件时，这些系统不区分大小写。</target>
        </trans-unit>
        <trans-unit id="42360b0ce037c1aa50c01166917adec5fecc2590" translate="yes" xml:space="preserve">
          <source>If type is non-Unix (see &lt;a href=&quot;#fileparse_set_fstype&quot;&gt;fileparse_set_fstype&lt;/a&gt;) then the pattern matching for suffix removal is performed case-insensitively, since those systems are not case-sensitive when opening existing files.</source>
          <target state="translated">如果type为非Unix（请参阅&lt;a href=&quot;#fileparse_set_fstype&quot;&gt;fileparse_set_fstype&lt;/a&gt;），则后缀删除的模式匹配不区分大小写，因为打开现有文件时，这些系统不区分大小写。</target>
        </trans-unit>
        <trans-unit id="2fd48f2e17e1f717f9f154bd3292076827285d01" translate="yes" xml:space="preserve">
          <source>If umask(2) is not implemented on your system and you are trying to restrict access for</source>
          <target state="translated">如果您的系统中没有实现umask(2),并且您试图限制对</target>
        </trans-unit>
        <trans-unit id="67a1f447b6ee3db12f569b14d8d5a13cc81a620d" translate="yes" xml:space="preserve">
          <source>If unsafe signals is in effect, then signal handling is not thread-safe, and the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; signalling method cannot be used.</source>
          <target state="translated">如果有效的信号不安全，则信号处理不是线程安全的，并且 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; 信号方法不能使用。</target>
        </trans-unit>
        <trans-unit id="70663a96a9c0a32a9a2fde13b31bf56729b3885e" translate="yes" xml:space="preserve">
          <source>If upgrading is in effect, returns PI, rounded to N digits with the current rounding mode:</source>
          <target state="translated">如果升级生效,返回PI,以当前的四舍五入模式四舍五入到N位。</target>
        </trans-unit>
        <trans-unit id="6635daa00264b763872dbf741802de705f31e8f0" translate="yes" xml:space="preserve">
          <source>If used with -v &amp;lt;version&amp;gt; then all utilities released with that version of perl are listed, and any utility programs named on the command line are ignored.</source>
          <target state="translated">如果与-v &amp;lt;version&amp;gt;一起使用，则会列出该版本的perl发行的所有实用程序，并且忽略命令行上命名的所有实用程序。</target>
        </trans-unit>
        <trans-unit id="d763c9ab9f9ca920e89e5e82fe0a4c19ddec98c7" translate="yes" xml:space="preserve">
          <source>If used with a single argument in a scalar context, returns the string consisting of the code points of the named sequence, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if no named sequence by that name exists. If used with a single argument in a list context, it returns the list of the ordinals of the code points.</source>
          <target state="translated">如果在标量上下文中与单个参数一起使用，则返回由命名序列的代码点组成的字符串，如果不存在该名称的命名序列，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。如果在列表上下文中与单个参数一起使用，它将返回代码点的常规列表。</target>
        </trans-unit>
        <trans-unit id="da57dfd2566c5bbbb36939e6a816eb57d92a5102" translate="yes" xml:space="preserve">
          <source>If used with a single argument in a scalar context, returns the string consisting of the code points of the named sequence, or &lt;code&gt;undef&lt;/code&gt; if no named sequence by that name exists. If used with a single argument in a list context, it returns the list of the ordinals of the code points.</source>
          <target state="translated">如果在标量上下文中与单个参数一起使用，则返回由命名序列的代码点组成的字符串，如果不存在该名称的命名序列，则返回 &lt;code&gt;undef&lt;/code&gt; 。如果在列表上下文中与单个参数一起使用，它将返回代码点的常规列表。</target>
        </trans-unit>
        <trans-unit id="beaceddc3b74ab2a5e89e9e5517463a3fd4ed9e1" translate="yes" xml:space="preserve">
          <source>If used with no arguments in a list context, it returns a hash with the names of all the named sequences as the keys and their sequences as strings as the values. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or an empty list depending on the context.</source>
          <target state="translated">如果在列表上下文中不带任何参数使用，它将返回一个哈希，其中所有命名序列的名称作为键，而其序列作为字符串的值。否则，它会根据上下文返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或一个空列表。</target>
        </trans-unit>
        <trans-unit id="0407b6cc8a060a9f5a98513aa0ab0a70e400908b" translate="yes" xml:space="preserve">
          <source>If used with no arguments in a list context, it returns a hash with the names of all the named sequences as the keys and their sequences as strings as the values. Otherwise, it returns &lt;code&gt;undef&lt;/code&gt; or an empty list depending on the context.</source>
          <target state="translated">如果在列表上下文中不带任何参数使用，它将返回一个散列，其中所有命名序列的名称作为键，而其序列作为字符串的值。否则，它会根据上下文返回 &lt;code&gt;undef&lt;/code&gt; 或一个空列表。</target>
        </trans-unit>
        <trans-unit id="20ccd67205017380c2547c8a9567b9cb20e04c0c" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; on a Unicode string (which</source>
          <target state="translated">如果对Unicode字符串使用&lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt; &lt;code&gt;crypt&lt;/code&gt; &lt;/a&gt;（</target>
        </trans-unit>
        <trans-unit id="bcae58a7d75cf50d08d76e85d4556f2e6099dd18" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;https://metacpan.org/pod/BerkeleyDB&quot;&gt;BerkeleyDB&lt;/a&gt; isn't an option, there are a number of modules available on CPAN that can be used to implement locking. Each one implements locking differently and has different goals in mind. It is therefore worth knowing the difference, so that you can pick the right one for your application. Here are the three locking wrappers:</source>
          <target state="translated">如果不能选择使用&lt;a href=&quot;https://metacpan.org/pod/BerkeleyDB&quot;&gt;BerkeleyDB&lt;/a&gt;，则CPAN上有许多模块可用于实现锁定。每个人实现锁的方式都不尽相同，并且有不同的目标。因此，有必要了解它们之间的区别，以便您可以为自己的应用选择合适的产品。这是三个锁定包装器：</target>
        </trans-unit>
        <trans-unit id="6b1f504c6467cdb5b94820cfba3df9e446f6d20a" translate="yes" xml:space="preserve">
          <source>If using &lt;b&gt;BerkeleyDB&lt;/b&gt; isn't an option, there are a number of modules available on CPAN that can be used to implement locking. Each one implements locking differently and has different goals in mind. It is therefore worth knowing the difference, so that you can pick the right one for your application. Here are the three locking wrappers:</source>
          <target state="translated">如果不能选择使用&lt;b&gt;BerkeleyDB&lt;/b&gt;，则CPAN上有许多模块可用于实现锁定。每个人实现锁的方式都不一样，并且有不同的目标。因此，有必要了解它们之间的区别，以便您可以为自己的应用选择合适的。这是三个锁定包装器：</target>
        </trans-unit>
        <trans-unit id="b0d8dee3f60efc11f28b77ac32acb4a0d6da837c" translate="yes" xml:space="preserve">
          <source>If using a Perl file as a source, optional switches may be passed which will be used when invoking the perl executable.</source>
          <target state="translated">如果使用Perl文件作为源文件,可以传递一些可选的开关,这些开关将在调用perl可执行文件时使用。</target>
        </trans-unit>
        <trans-unit id="a612abcdba4adc1d68486aebb4d51b768494dc19" translate="yes" xml:space="preserve">
          <source>If using adb, a &quot;basic&quot; Configure line will look like this:</source>
          <target state="translated">如果使用adb,&quot;基本 &quot;的配置行会像这样。</target>
        </trans-unit>
        <trans-unit id="d2c2e41b4856cbf4192df9fdfdae8eb4debbc3b0" translate="yes" xml:space="preserve">
          <source>If using crypt() on a Unicode string (which</source>
          <target state="translated">如果在Unicode字符串上使用crypt()(这将是</target>
        </trans-unit>
        <trans-unit id="45cfcf2e0c855940dc64008801ae135f972cfd74" translate="yes" xml:space="preserve">
          <source>If using ftp remember to transfer the distribution in binary format.</source>
          <target state="translated">如果使用ftp,记得要以二进制格式传输发行版。</target>
        </trans-unit>
        <trans-unit id="b6fa09de90b513e62acb77e553ed8a67bf3a34b1" translate="yes" xml:space="preserve">
          <source>If using gcc, you can add the &lt;code&gt;-std=c89&lt;/code&gt; option which will hopefully catch most of these unportabilities. (However it might also catch incompatibilities in your system's header files.)</source>
          <target state="translated">如果使用gcc，则可以添加 &lt;code&gt;-std=c89&lt;/code&gt; 选项，该选项有望捕获大多数这些不可移植性。（但是，它也可能会捕获系统头文件中的不兼容性。）</target>
        </trans-unit>
        <trans-unit id="fae0365130c2e3d1490dd7527e14992a1ddb3fda" translate="yes" xml:space="preserve">
          <source>If using ssh, it's not too different -- we just change targetrun to ssh, and pass in targetuser and targetport. It ends up looking like this:</source>
          <target state="translated">如果使用ssh,也没有太大区别--我们只需要把targetrun改为ssh,然后传入targetuser和targetport。最后的结果是这样的。</target>
        </trans-unit>
        <trans-unit id="664754e120bf0080d8c4c2636edd9c4d43e0b86a" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; pragma without an explicit encoding name, the PERL_ENCODING environment variable is consulted for an encoding name.</source>
          <target state="translated">如果使用的是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; 没有明确的编码名称附注中，PERL_ENCODING环境变量征询编码名称。</target>
        </trans-unit>
        <trans-unit id="47d8d46dc66c1660b89d6816f6548597b112a1d7" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;gcc -Wall&lt;/code&gt; note that not all the possible warnings (like &lt;code&gt;-Wuninitialized&lt;/code&gt;) are given unless you also compile with &lt;code&gt;-O&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;gcc -Wall&lt;/code&gt; 请注意，除非您也使用 &lt;code&gt;-O&lt;/code&gt; 进行编译，否则不会给出所有可能的警告（如 &lt;code&gt;-Wuninitialized&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cfca052b74a8f394827d7f4faa9fd4f5bf5109bf" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;gcc -Wall&lt;/code&gt; note that not all the possible warnings (like &lt;code&gt;-Wunitialized&lt;/code&gt; ) are given unless you also compile with &lt;code&gt;-O&lt;/code&gt; .</source>
          <target state="translated">如果使用 &lt;code&gt;gcc -Wall&lt;/code&gt; 请注意，除非您也使用 &lt;code&gt;-O&lt;/code&gt; 进行编译，否则不会给出所有可能的警告（如 &lt;code&gt;-Wunitialized&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fa9480a44177272fde2828188fac358cc2184e4c" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;use encoding&lt;/code&gt; pragma without an explicit encoding name, the PERL_ENCODING environment variable is consulted for an encoding name.</source>
          <target state="translated">如果使用的 &lt;code&gt;use encoding&lt;/code&gt; 没有明确的编码名称附注中，PERL_ENCODING环境变量征询编码名称。</target>
        </trans-unit>
        <trans-unit id="49dda8790f1c37a11e446613192c2ff1c5642e05" translate="yes" xml:space="preserve">
          <source>If using the VC IDE, to build use for example the File-&amp;gt;Open Workspace-&amp;gt; C:\Symbian\8.0a\S60_2nd_FP2\epoc32\build\symbian\perl\perl\wins\perl.dsw The emulator binaries will appear in the same directory.</source>
          <target state="translated">如果使用VC IDE，则要进行构建，例如使用File-&amp;gt; Open Workspace-&amp;gt; C：\ Symbian \ 8.0a \ S60_2nd_FP2 \ epoc32 \ build \ symbian \ perl \ perl \ wins \ perl.dsw。同一目录。</target>
        </trans-unit>
        <trans-unit id="87f25526e76efefdb9a4ff18e831107d545ddc34" translate="yes" xml:space="preserve">
          <source>If using the VC IDE, you will a lot of warnings in the beginning of the build because a lot of headers mentioned by the source cannot be found, but this is not serious since those headers are not used.</source>
          <target state="translated">如果使用VC IDE,在构建之初会有很多警告,因为很多源码提到的头文件找不到,但这并不严重,因为这些头文件是不用的。</target>
        </trans-unit>
        <trans-unit id="95f6a03b7ab2b25638142acde2118920ba4f7593" translate="yes" xml:space="preserve">
          <source>If we add a &lt;code&gt;(*PRUNE)&lt;/code&gt; before the count like the following</source>
          <target state="translated">如果我们在计数之前添加 &lt;code&gt;(*PRUNE)&lt;/code&gt; ，如下所示</target>
        </trans-unit>
        <trans-unit id="f49196da102bf295b3091d7157018af8c9071a57" translate="yes" xml:space="preserve">
          <source>If we call a method on a &lt;code&gt;Child&lt;/code&gt; object and that method is not defined in the &lt;code&gt;Child&lt;/code&gt; class, Perl will look for that method in the &lt;code&gt;Parent&lt;/code&gt; class and then, if necessary, in the &lt;code&gt;Grandparent&lt;/code&gt; class.</source>
          <target state="translated">如果我们在 &lt;code&gt;Child&lt;/code&gt; 对象上调用一个方法，但未在 &lt;code&gt;Child&lt;/code&gt; 类中定义该方法，则Perl将在 &lt;code&gt;Parent&lt;/code&gt; 类中查找该方法，然后在必要时在 &lt;code&gt;Grandparent&lt;/code&gt; 类中查找该方法。</target>
        </trans-unit>
        <trans-unit id="ef968fd799fd1b1033f77f3853f27266c25aff48" translate="yes" xml:space="preserve">
          <source>If we can tell that there is no valid start point then we don't bother running the interpreter at all. Likewise, if we know from the analysis phase that we cannot detect a short-cut to the start position, we go straight to the interpreter.</source>
          <target state="translated">如果我们可以判断出没有有效的起始点,那么我们根本就不用去运行解释器。同样,如果我们从分析阶段就知道无法检测到通往起始位置的捷径,我们就直接进入解释器。</target>
        </trans-unit>
        <trans-unit id="ee8cb3b419bcafdec86df4116638973be94d94a5" translate="yes" xml:space="preserve">
          <source>If we could reliably use `goto &amp;amp;` on core builtins, we wouldn't need this subroutine.</source>
          <target state="translated">如果我们可以在核心内建函数上可靠地使用`goto＆`，则不需要此子例程。</target>
        </trans-unit>
        <trans-unit id="2cd027f23ebc9bafdd0ef83ac988a2e8f6205abb" translate="yes" xml:space="preserve">
          <source>If we encrypt this with &lt;code&gt;mkrot13&lt;/code&gt; :</source>
          <target state="translated">如果我们使用 &lt;code&gt;mkrot13&lt;/code&gt; 对此进行加密：</target>
        </trans-unit>
        <trans-unit id="b2db7414804acef79a0ead64758e1284fbf24a9c" translate="yes" xml:space="preserve">
          <source>If we encrypt this with &lt;code&gt;mkrot13&lt;/code&gt;:</source>
          <target state="translated">如果我们使用 &lt;code&gt;mkrot13&lt;/code&gt; 对此进行加密：</target>
        </trans-unit>
        <trans-unit id="b742d69e435d1dc4ae57558eae468b9e3038bfd1" translate="yes" xml:space="preserve">
          <source>If we have a string which needs to be modified, while a regex will almost always be much more flexible, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;, an oft underused tool, can still be a useful. One scenario might be replace all vowels with another character. The regex solution might look like this:</source>
          <target state="translated">如果我们有一个需要修改的字符串，而一个正则表达式几乎总是更加灵活，那么经常使用的工具 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 仍然是有用的。一种情况是用其他字符替换所有元音。正则表达式解决方案可能如下所示：</target>
        </trans-unit>
        <trans-unit id="d8dec03047abaaa8042a15b74ce655789698f5d5" translate="yes" xml:space="preserve">
          <source>If we have a string which needs to be modified, while a regex will almost always be much more flexible, &lt;code&gt;tr&lt;/code&gt;, an oft underused tool, can still be a useful. One scenario might be replace all vowels with another character. The regex solution might look like this:</source>
          <target state="translated">如果我们有一个需要修改的字符串，而一个正则表达式几乎总是更加灵活，那么 &lt;code&gt;tr&lt;/code&gt; （一个经常未被充分利用的工具）仍然会很有用。一种情况是用其他字符替换所有元音。正则表达式解决方案可能如下所示：</target>
        </trans-unit>
        <trans-unit id="e9e855f5e5eecc49e2e1826c2e605b2358ee8b64" translate="yes" xml:space="preserve">
          <source>If we look at any of the C code generated by any of the examples except example 1, you will notice a number of references to ST(n), where n is usually 0. &quot;ST&quot; is actually a macro that points to the n'th argument on the argument stack. ST(0) is thus the first argument on the stack and therefore the first argument passed to the XSUB, ST(1) is the second argument, and so on.</source>
          <target state="translated">如果我们看一下除了例子1以外的任何一个例子所生成的C代码,你会注意到有很多对ST(n)的引用,其中n通常是0。&quot;ST &quot;实际上是一个宏,它指向参数堆栈上的第n'th个参数,因此ST(0)是堆栈上的第一个参数,因此传递给XSUB的第一个参数,ST(1)是第二个参数,等等。因此,ST(0)是堆栈中的第一个参数,因此也是传递给XSUB的第一个参数,ST(1)是第二个参数,以此类推。</target>
        </trans-unit>
        <trans-unit id="b4b727c2115d816f7a5edf98b373babd311821be" translate="yes" xml:space="preserve">
          <source>If we replace the &lt;code&gt; (?{local $c = $c + 1;})&lt;/code&gt; with &lt;code&gt; (?{$c = $c + 1;})&lt;/code&gt;, the variable changes are</source>
          <target state="translated">如果我们将 &lt;code&gt; (?{local $c = $c + 1;})&lt;/code&gt; 替换为 &lt;code&gt; (?{$c = $c + 1;})&lt;/code&gt; ，则变量更改为</target>
        </trans-unit>
        <trans-unit id="6b22701c7de1c1b18f83a3da253320877e6db57e" translate="yes" xml:space="preserve">
          <source>If we want to call the function in scalar context, we have to do a bit more work. We can really have any code we like inside the braces, so we simply have to end with the scalar reference, although how you do that is up to you, and you can use code inside the braces. Note that the use of parens creates a list context, so we need &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; to force the scalar context on the function:</source>
          <target state="translated">如果要在标量上下文中调用该函数，则必须做更多的工作。我们实际上可以在花括号内包含任何我们喜欢的代码，因此我们只需要以标量引用结尾，尽管您的操作取决于您自己，并且可以在花括号内使用代码。请注意，使用parens会创建一个列表上下文，因此我们需要 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 才能将标量上下文强制应用于该函数：</target>
        </trans-unit>
        <trans-unit id="b2ecb0d182e5a6aa3494d3aa82a88c04143a9745" translate="yes" xml:space="preserve">
          <source>If we want to call the function in scalar context, we have to do a bit more work. We can really have any code we like inside the braces, so we simply have to end with the scalar reference, although how you do that is up to you, and you can use code inside the braces. Note that the use of parens creates a list context, so we need &lt;code&gt;scalar&lt;/code&gt; to force the scalar context on the function:</source>
          <target state="translated">如果要在标量上下文中调用该函数，则需要做更多的工作。我们确实可以在花括号内包含任何我们喜欢的代码，因此我们只需要以标量引用结尾，尽管您的操作取决于您自己，并且可以在花括号内使用代码。请注意，使用parens会创建一个列表上下文，因此我们需要 &lt;code&gt;scalar&lt;/code&gt; 才能将标量上下文强制应用于该函数：</target>
        </trans-unit>
        <trans-unit id="2aa4af82f261a5bfccad859728bbc5e698f2ad5a" translate="yes" xml:space="preserve">
          <source>If we want to sort by the hash value instead, we use the hash key to look it up. We still get out a list of keys, but this time they are ordered by their value.</source>
          <target state="translated">如果我们想改用哈希值排序,我们就用哈希键来查找。我们仍然会得到一个键的列表,但这次是按其值排序。</target>
        </trans-unit>
        <trans-unit id="1a0a23be20e0afdc53dc3805694c934e04c1d63f" translate="yes" xml:space="preserve">
          <source>If we wanted to include the mp3's title in the greeting, we could override the method:</source>
          <target state="translated">如果我们想在问候语中包含mp3的标题,我们可以覆盖这个方法。</target>
        </trans-unit>
        <trans-unit id="215abf71d62aea6c4bacd7ab63842ca42cbc8d09" translate="yes" xml:space="preserve">
          <source>If we were interested in performance, not in code compactness, in the success branch we would not use &lt;code&gt;XPUSHs&lt;/code&gt; macros, but &lt;code&gt;PUSHs&lt;/code&gt; macros, and would pre-extend the stack before pushing the return values:</source>
          <target state="translated">如果我们对性能感兴趣，而不是对代码紧凑性感兴趣，那么在成功分支中，我们将不使用 &lt;code&gt;XPUSHs&lt;/code&gt; 宏，而使用 &lt;code&gt;PUSHs&lt;/code&gt; 宏，并在推送返回值之前预先扩展堆栈：</target>
        </trans-unit>
        <trans-unit id="65993e20767895a57d8f797f997352ddbf9ddad7" translate="yes" xml:space="preserve">
          <source>If we've done things right, you'll probably want to write a new source, rather than sub-classing this (see &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; for that).</source>
          <target state="translated">如果我们做对了，您可能想编写一个新的源代码，而不是对其进行子类化（请参阅&lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ed55ede23a733b9689b8f241805b425f9dc0c341" translate="yes" xml:space="preserve">
          <source>If we've done things right, you'll probably want to write a new source, rather than sub-classing this (see &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; for that).</source>
          <target state="translated">如果我们做对了，您可能想编写一个新的源代码，而不是对其进行子类化（请参阅&lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="433a6e7876c97a91d0108a2079322b6917a252c6" translate="yes" xml:space="preserve">
          <source>If what the angle brackets contain is a simple scalar variable (for example, &lt;code&gt;$foo&lt;/code&gt; ), then that variable contains the name of the filehandle to input from, or its typeglob, or a reference to the same. For example:</source>
          <target state="translated">如果尖括号中包含的是一个简单的标量变量（例如 &lt;code&gt;$foo&lt;/code&gt; ），则该变量包含要从中输入的文件句柄的名称，其句柄或对它的引用。例如：</target>
        </trans-unit>
        <trans-unit id="6838a6ca305b32b023903f5887f6858a0601c74f" translate="yes" xml:space="preserve">
          <source>If what the angle brackets contain is a simple scalar variable (for example, &lt;code&gt;$foo&lt;/code&gt;), then that variable contains the name of the filehandle to input from, or its typeglob, or a reference to the same. For example:</source>
          <target state="translated">如果尖括号包含的是简单的标量变量（例如 &lt;code&gt;$foo&lt;/code&gt; ），则该变量包含要从中输入的文件句柄的名称，其句柄或对它的引用。例如：</target>
        </trans-unit>
        <trans-unit id="0b51d046d4f4e47130f90dab13b7fc186caff6e3" translate="yes" xml:space="preserve">
          <source>If what's within the angle brackets is neither a filehandle nor a simple scalar variable containing a filehandle name, typeglob, or typeglob reference, it is interpreted as a filename pattern to be globbed, and either a list of filenames or the next filename in the list is returned, depending on context. This distinction is determined on syntactic grounds alone. That means &lt;code&gt;&amp;lt;$x&amp;gt;&lt;/code&gt; is always a &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; from an indirect handle, but &lt;code&gt;&amp;lt;$hash{key}&amp;gt;&lt;/code&gt; is always a &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt;. That's because &lt;code&gt;$x&lt;/code&gt; is a simple scalar variable, but &lt;code&gt;$hash{key}&lt;/code&gt; is not--it's a hash element. Even &lt;code&gt;&amp;lt;$x &amp;gt;&lt;/code&gt; (note the extra space) is treated as &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;$x &quot;)&lt;/code&gt; , not &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline($x)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果尖括号中的内容既不是文件句柄，也不是包含文件句柄名称，typeglob或typeglob引用的简单标量变量，则它将被解释为要被文件化的文件名模式，以及文件名列表或列表中的下一个文件名返回，具体取决于上下文。这种区别仅基于句法基础来确定。这意味着 &lt;code&gt;&amp;lt;$x&amp;gt;&lt;/code&gt; 始终是间接句柄的 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; ，而 &lt;code&gt;&amp;lt;$hash{key}&amp;gt;&lt;/code&gt; 始终是 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; 。这是因为 &lt;code&gt;$x&lt;/code&gt; 是一个简单的标量变量，但是 &lt;code&gt;$hash{key}&lt;/code&gt; 不是-它是一个哈希元素。即使 &lt;code&gt;&amp;lt;$x &amp;gt;&lt;/code&gt; （请注意多余的空格）也被视为 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;$x &quot;)&lt;/code&gt; ，不 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline($x)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6919e586a25966a42d5d004843760749c92f077" translate="yes" xml:space="preserve">
          <source>If what's within the angle brackets is neither a filehandle nor a simple scalar variable containing a filehandle name, typeglob, or typeglob reference, it is interpreted as a filename pattern to be globbed, and either a list of filenames or the next filename in the list is returned, depending on context. This distinction is determined on syntactic grounds alone. That means &lt;code&gt;&amp;lt;$x&amp;gt;&lt;/code&gt; is always a &lt;code&gt;readline()&lt;/code&gt; from an indirect handle, but &lt;code&gt;&amp;lt;$hash{key}&amp;gt;&lt;/code&gt; is always a &lt;code&gt;glob()&lt;/code&gt;. That's because &lt;code&gt;$x&lt;/code&gt; is a simple scalar variable, but &lt;code&gt;$hash{key}&lt;/code&gt; is not--it's a hash element. Even &lt;code&gt;&amp;lt;$x &amp;gt;&lt;/code&gt; (note the extra space) is treated as &lt;code&gt;glob(&quot;$x &quot;)&lt;/code&gt;, not &lt;code&gt;readline($x)&lt;/code&gt;.</source>
          <target state="translated">如果尖括号中的内容既不是文件句柄，也不是包含文件句柄名称，typeglob或typeglob引用的简单标量变量，则它将被解释为要被文件化的文件名模式，以及文件名列表或列表中的下一个文件名返回，具体取决于上下文。这种区别仅基于句法基础来确定。这意味着 &lt;code&gt;&amp;lt;$x&amp;gt;&lt;/code&gt; 始终是间接句柄的 &lt;code&gt;readline()&lt;/code&gt; ，而 &lt;code&gt;&amp;lt;$hash{key}&amp;gt;&lt;/code&gt; 始终是 &lt;code&gt;glob()&lt;/code&gt; 。那是因为 &lt;code&gt;$x&lt;/code&gt; 是一个简单的标量变量，但是 &lt;code&gt;$hash{key}&lt;/code&gt; 不是-它是一个哈希元素。即使 &lt;code&gt;&amp;lt;$x &amp;gt;&lt;/code&gt; （请注意多余的空格）也被视为 &lt;code&gt;glob(&quot;$x &quot;)&lt;/code&gt; ，而不是 &lt;code&gt;readline($x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b842d8a427447b55d56f0f86ffb1407d7bbf70b" translate="yes" xml:space="preserve">
          <source>If whitespace is mostly irrelevant, how does one include space characters in an extended regexp? The answer is to backslash it &lt;code&gt;'\ '&lt;/code&gt; or put it in a character class &lt;code&gt;[ ]&lt;/code&gt; . The same thing goes for pound signs: use &lt;code&gt;\#&lt;/code&gt; or &lt;code&gt;[#]&lt;/code&gt;. For instance, Perl allows a space between the sign and the mantissa or integer, and we could add this to our regexp as follows:</source>
          <target state="translated">如果空白大部分无关紧要，那么如何在扩展的正则表达式中包含空格字符？答案是将其反斜杠 &lt;code&gt;'\ '&lt;/code&gt; 或放在字符类 &lt;code&gt;[ ]&lt;/code&gt; 。英镑符号也是如此：使用 &lt;code&gt;\#&lt;/code&gt; 或 &lt;code&gt;[#]&lt;/code&gt; 。例如，Perl在符号和尾数或整数之间允许一个空格，我们可以按如下所示将其添加到正则表达式中：</target>
        </trans-unit>
        <trans-unit id="5ea95fa4866be380e5de6f53e01cf2830a2660fd" translate="yes" xml:space="preserve">
          <source>If whitespace is mostly irrelevant, how does one include space characters in an extended regexp? The answer is to backslash it &lt;code&gt;'\ '&lt;/code&gt; or put it in a character class &lt;code&gt;[ ]&lt;/code&gt;. The same thing goes for pound signs: use &lt;code&gt;\#&lt;/code&gt; or &lt;code&gt;[#]&lt;/code&gt;. For instance, Perl allows a space between the sign and the mantissa or integer, and we could add this to our regexp as follows:</source>
          <target state="translated">如果大多数空白与无关紧要，那么如何在扩展的正则表达式中包含空格字符？答案是用反斜杠 &lt;code&gt;'\ '&lt;/code&gt; 或将其放在字符类 &lt;code&gt;[ ]&lt;/code&gt; 。英镑符号也是如此：使用 &lt;code&gt;\#&lt;/code&gt; 或 &lt;code&gt;[#]&lt;/code&gt; 。例如，Perl允许在符号和尾数或整数之间留一个空格，我们可以将其添加到正则表达式中，如下所示：</target>
        </trans-unit>
        <trans-unit id="f6171e2e12a8c60c3485d29916f7ac5529de6161" translate="yes" xml:space="preserve">
          <source>If writing a plugin is not enough, you can write your own test harness; one of the motives for the 3.00 rewrite of Test::Harness was to make it easier to subclass and extend.</source>
          <target state="translated">如果写一个插件还不够,你可以自己写测试线束;Test::Harness 3.00重写的动机之一就是让它更容易被子类和扩展。</target>
        </trans-unit>
        <trans-unit id="0ac523288e8907db49cd44aeec42c46983d54f41" translate="yes" xml:space="preserve">
          <source>If you</source>
          <target state="translated">如果你</target>
        </trans-unit>
        <trans-unit id="a97a499d1638eac60812016983597e71f2e68467" translate="yes" xml:space="preserve">
          <source>If you &quot;mmap&quot; the file with the File::Map module from CPAN, you can virtually load the entire file into a string without actually storing it in memory:</source>
          <target state="translated">如果你使用CPAN的File::Map模块对文件进行 &quot;mmap&quot;,你实际上可以将整个文件加载到一个字符串中,而无需实际存储在内存中。</target>
        </trans-unit>
        <trans-unit id="bbc7d708aba8a01827e46990051f630f335a2e71" translate="yes" xml:space="preserve">
          <source>If you &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; without ever waiting on your children, you will accumulate zombies. On some systems, you can avoid this by setting &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;$SIG{CHLD}&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt;. See also &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more examples of forking and reaping moribund children.</source>
          <target state="translated">如果您在没有等待孩子的情况下进行&lt;a href=&quot;#fork&quot;&gt; &lt;code&gt;fork&lt;/code&gt; &lt;/a&gt;，则会堆积僵尸。在某些系统上，可以通过将&lt;a href=&quot;perlvar#%25SIG&quot;&gt; &lt;code&gt;$SIG{CHLD}&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 来避免这种情况。另请参阅&lt;a href=&quot;perlipc&quot;&gt;perlipc，&lt;/a&gt;以了解更多分叉和收养垂死儿童的例子。</target>
        </trans-unit>
        <trans-unit id="e9fdf3b9fc81571db27bb02cd29a8e0b53b10cc5" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; without ever waiting on your children, you will accumulate zombies. On some systems, you can avoid this by setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . See also &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for more examples of forking and reaping moribund children.</source>
          <target state="translated">如果您在没有等待孩子的情况下进行 &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; ，则会堆积僵尸。在某些系统上，可以通过将 &lt;code&gt;$SIG{CHLD}&lt;/code&gt; 为 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 来避免这种情况。另请参阅&lt;a href=&quot;../perlipc&quot;&gt;perlipc，&lt;/a&gt;以了解更多分叉和收养垂死儿童的例子。</target>
        </trans-unit>
        <trans-unit id="3342529f369584d116691354aca02d8a637cdc3f" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; without ever waiting on your children, you will accumulate zombies. On some systems, you can avoid this by setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . See also &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more examples of forking and reaping moribund children.</source>
          <target state="translated">如果您在没有等待孩子的情况下进行 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; ，则会堆积僵尸。在某些系统上，可以通过将 &lt;code&gt;$SIG{CHLD}&lt;/code&gt; 为 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 来避免这种情况。另请参阅&lt;a href=&quot;perlipc&quot;&gt;perlipc，&lt;/a&gt;以了解更多分叉和收养垂死儿童的例子。</target>
        </trans-unit>
        <trans-unit id="bb90d14b290d4320ac5634dcbc5bece03b18182e" translate="yes" xml:space="preserve">
          <source>If you actually need to be able to get a real reference back from each hash entry, you can use the Tie::RefHash module, which does the required work for you.</source>
          <target state="translated">如果你真的需要能够从每个哈希条目中得到一个真实的引用,你可以使用Tie::RefHash模块,它可以为你完成所需的工作。</target>
        </trans-unit>
        <trans-unit id="0863c378529bcaaf05a08fbe7b9d62fcdd40f533" translate="yes" xml:space="preserve">
          <source>If you actually want to bless into the stringified version of the reference supplied, you need to stringify it yourself, for example by:</source>
          <target state="translated">如果你真的想祝福到所提供的引用的字符串化版本,你需要自己对它进行字符串化,例如通过。</target>
        </trans-unit>
        <trans-unit id="7632fd79ddaeaed4fd83611844af65a8558ccb38" translate="yes" xml:space="preserve">
          <source>If you actually want to pack Unicode codepoints, use the &lt;code&gt;&quot;U&quot;&lt;/code&gt; format instead.</source>
          <target state="translated">如果您实际上要打包Unicode代码点，请改用 &lt;code&gt;&quot;U&quot;&lt;/code&gt; 格式。</target>
        </trans-unit>
        <trans-unit id="30a06cdba55cf94e2b0d8887615268f65da700c2" translate="yes" xml:space="preserve">
          <source>If you add the &lt;code&gt;stringify&lt;/code&gt; import option to your &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; declaration, then using a threads object in a string or a string context (e.g., as a hash key) will cause its ID to be used as the value:</source>
          <target state="translated">如果在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 线程声明中添加 &lt;code&gt;stringify&lt;/code&gt; import选项，则在字符串或字符串上下文中使用线程对象（例如，作为哈希键）将导致其ID用作值：</target>
        </trans-unit>
        <trans-unit id="30adb136bf842fc19188bd6258e57dee7ddb8e9f" translate="yes" xml:space="preserve">
          <source>If you add the &lt;code&gt;stringify&lt;/code&gt; import option to your &lt;code&gt;use threads&lt;/code&gt; declaration, then using a threads object in a string or a string context (e.g., as a hash key) will cause its ID to be used as the value:</source>
          <target state="translated">如果在 &lt;code&gt;use threads&lt;/code&gt; 声明中添加 &lt;code&gt;stringify&lt;/code&gt; import选项，则在字符串或字符串上下文中使用线程对象（例如，作为哈希键）将导致其ID用作值：</target>
        </trans-unit>
        <trans-unit id="24defde4aa2bffa14e170e2d3b5990c2b9ad5b66" translate="yes" xml:space="preserve">
          <source>If you already have a Perl repository, you should ensure that you're on the</source>
          <target state="translated">如果你已经有一个Perl仓库,你应该确保你是在</target>
        </trans-unit>
        <trans-unit id="77f0b688e7f7db776b8a41a0294b1be395b96046" translate="yes" xml:space="preserve">
          <source>If you already have the data in memory or if you want to keep your code simple, you can use one of the sv_cat*() variants, such as sv_catpvn(). If you want to insert anywhere in the string you can use sv_insert() or sv_insert_flags().</source>
          <target state="translated">如果你已经在内存中拥有数据,或者你想保持你的代码简单,你可以使用sv_cat*()的一个变体,比如sv_catpvn()。如果你想在字符串的任何地方插入,你可以使用sv_insert()或sv_insert_flags()。</target>
        </trans-unit>
        <trans-unit id="d0e6e027d69f3e21d5d8d4eaafdf5a18b7a271a0" translate="yes" xml:space="preserve">
          <source>If you also specify the &lt;code&gt;save&lt;/code&gt; option newly passing tests will be excluded from subsequent runs.</source>
          <target state="translated">如果您还指定 &lt;code&gt;save&lt;/code&gt; 选项，则新的通过测试将从随后的运行中排除。</target>
        </trans-unit>
        <trans-unit id="f2315b4f443374dc91536026901e2322007448a6" translate="yes" xml:space="preserve">
          <source>If you alter your @_ arguments in a subroutine (such as with &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;), the stack backtrace will not show the original values.</source>
          <target state="translated">如果您在子例程中更改@_参数（例如使用 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; ），则堆栈回溯将不显示原始值。</target>
        </trans-unit>
        <trans-unit id="87b7e2c0f9e7bf47de8a9bd321c66e6de23241e4" translate="yes" xml:space="preserve">
          <source>If you alter your @_ arguments in a subroutine (such as with &lt;code&gt;shift&lt;/code&gt; or &lt;code&gt;pop&lt;/code&gt;), the stack backtrace will not show the original values.</source>
          <target state="translated">如果您在子例程（例如，使用 &lt;code&gt;shift&lt;/code&gt; 或 &lt;code&gt;pop&lt;/code&gt; ）中更改@_参数，则堆栈回溯将不显示原始值。</target>
        </trans-unit>
        <trans-unit id="a5bf3485b53b1f2fcb4fdcf6bb2cccc1e74cefad" translate="yes" xml:space="preserve">
          <source>If you are a committer to Perl and you think the patch is good, you can then merge it into blead then push it out to the main repository:</source>
          <target state="translated">如果你是 Perl 的提交者,并且你认为这个补丁是好的,你可以将它合并到 blead 中,然后推送到主仓库。</target>
        </trans-unit>
        <trans-unit id="bcce70763746b8ab89abce0fda8214efc82356bb" translate="yes" xml:space="preserve">
          <source>If you are accustomed to using perl from various command-line shells found in UNIX environments, you will be less than pleased with what Windows offers by way of a command shell.</source>
          <target state="translated">如果你习惯于从UNIX环境中的各种命令行shell中使用perl,那么你会对Windows提供的命令行shell不甚满意。</target>
        </trans-unit>
        <trans-unit id="75851b1a6055f8c9601d27bb8e4f2638f62e5f5e" translate="yes" xml:space="preserve">
          <source>If you are advanced enough with building C code, here is a suggestion to speed up building perl, and the later &lt;code&gt;make test&lt;/code&gt; . Try to keep your PATH enviromental variable with the least number of folders possible (remember to keep your C compiler's folders there). &lt;code&gt;C:\WINDOWS\system32&lt;/code&gt; or &lt;code&gt;C:\WINNT\system32&lt;/code&gt; depending on your OS version should be first folder in PATH, since &quot;cmd.exe&quot; is the most commonly launched program during the build and later testing.</source>
          <target state="translated">如果您对构建C代码有足够的了解，建议您加快构建Perl的速度，稍后再 &lt;code&gt;make test&lt;/code&gt; 。尝试使PATH环境变量的文件夹数尽可能少（请记住，将C编译器的文件夹保留在此处）。根据操作系统的版本， &lt;code&gt;C:\WINDOWS\system32&lt;/code&gt; 或 &lt;code&gt;C:\WINNT\system32&lt;/code&gt; 应该是PATH中的第一个文件夹，因为&amp;ldquo; cmd.exe&amp;rdquo;是在构建和后续测试过程中最常启动的程序。</target>
        </trans-unit>
        <trans-unit id="04da8dab27ca1a90f04cb94a9ccc32581630ed82" translate="yes" xml:space="preserve">
          <source>If you are advanced enough with building C code, here is a suggestion to speed up building perl, and the later &lt;code&gt;make test&lt;/code&gt;. Try to keep your PATH environmental variable with the least number of folders possible (remember to keep your C compiler's folders there). &lt;code&gt;C:\WINDOWS\system32&lt;/code&gt; or &lt;code&gt;C:\WINNT\system32&lt;/code&gt; depending on your OS version should be first folder in PATH, since &quot;cmd.exe&quot; is the most commonly launched program during the build and later testing.</source>
          <target state="translated">如果您对构建C代码有足够的了解，那么建议您加快构建Perl的速度，并在稍后 &lt;code&gt;make test&lt;/code&gt; 。尝试使PATH环境变量的文件夹数尽可能少（请记住，将C编译器的文件夹保留在此处）。根据操作系统的版本， &lt;code&gt;C:\WINDOWS\system32&lt;/code&gt; 或 &lt;code&gt;C:\WINNT\system32&lt;/code&gt; 应该是PATH中的第一个文件夹，因为&amp;ldquo; cmd.exe&amp;rdquo;是在构建和后续测试过程中最常启动的程序。</target>
        </trans-unit>
        <trans-unit id="9e6e47c6af55350e3bd275924a9467fa5be92cb6" translate="yes" xml:space="preserve">
          <source>If you are author of a package and wonder if your $VERSION can be parsed, please try the above method.</source>
          <target state="translated">如果你是一个包的作者,不知道你的$VERSION是否可以被解析,请尝试以上方法。</target>
        </trans-unit>
        <trans-unit id="e9341f5fe0aca50dc1a438efa6a2a0829ec331a7" translate="yes" xml:space="preserve">
          <source>If you are building Perl from source, the Perl test suite file</source>
          <target state="translated">如果你是从源码中构建Perl,那么Perl测试套件文件中的</target>
        </trans-unit>
        <trans-unit id="fd709122178ec9749d3b052901d53a7e7c059f96" translate="yes" xml:space="preserve">
          <source>If you are calling &lt;b&gt;pod2usage()&lt;/b&gt; from a module and want to display that module's POD, you can use this:</source>
          <target state="translated">如果要从模块调用&lt;b&gt;pod2usage（）&lt;/b&gt;并想显示该模块的POD，则可以使用以下命令：</target>
        </trans-unit>
        <trans-unit id="f5b3eed9ee23b3eafd899b21c185d1c6a6521682" translate="yes" xml:space="preserve">
          <source>If you are careful, it is possible to mix API calls with the tied hash/array interface in the same piece of code. Although only a few of the methods used to implement the tied interface currently make use of the cursor, you should always assume that the cursor has been changed any time the tied hash/array interface is used. As an example, this code will probably not do what you expect:</source>
          <target state="translated">如果你小心的话,可以在同一段代码中混合使用API调用和绑定的哈希/数组接口。虽然目前只有少数用于实现绑定接口的方法使用了游标,但在使用绑定的哈希/数组接口时,你应该始终假设游标已经被改变。作为一个例子,这段代码可能不会像你期望的那样。</target>
        </trans-unit>
        <trans-unit id="f310b0eef5419b5aba99dec1af26f1763cc1c050" translate="yes" xml:space="preserve">
          <source>If you are certain that you want a different tool to use the same context you may pass it a snapshot. &lt;code&gt;$ctx-&amp;gt;snapshot&lt;/code&gt; will give you a shallow clone of the context that is safe to pass around or store.</source>
          <target state="translated">如果您确定要让其他工具使用相同的上下文，则可以向其传递快照。 &lt;code&gt;$ctx-&amp;gt;snapshot&lt;/code&gt; 将为您提供可以安全传递或存储的上下文的浅表克隆。</target>
        </trans-unit>
        <trans-unit id="4e316a557a29cf6095279d19d99c5e2d5b583af0" translate="yes" xml:space="preserve">
          <source>If you are certain that you want to save the context for later, you can use a snapshot. &lt;code&gt;$ctx-&amp;gt;snapshot&lt;/code&gt; will give you a shallow clone of the context that is safe to pass around or store.</source>
          <target state="translated">如果确定要保存上下文以供以后使用，则可以使用快照。 &lt;code&gt;$ctx-&amp;gt;snapshot&lt;/code&gt; 将为您提供可以安全传递或存储的上下文的浅表克隆。</target>
        </trans-unit>
        <trans-unit id="46443ee64846124969f99d9a251a1b5c33defa28" translate="yes" xml:space="preserve">
          <source>If you are coming here because code of yours is being adversely affected by someone's use of this variable, you can usually work around it by doing this:</source>
          <target state="translated">如果你来这里是因为你的代码被别人使用了这个变量而受到不利影响,你通常可以通过这样做来解决。</target>
        </trans-unit>
        <trans-unit id="580a992ac4c85198002e3da1ab0af0114ef2843d" translate="yes" xml:space="preserve">
          <source>If you are compiling Perl on a remotely-mounted NFS filesystem, the test io/fs.t may fail on test #18. This appears to be a bug in HP-UX and no fix is currently available.</source>
          <target state="translated">如果你在远程安装的NFS文件系统上编译Perl,测试io/fs.t可能会在测试#18中失败。这似乎是HP-UX中的一个错误,目前还没有修复。</target>
        </trans-unit>
        <trans-unit id="3b33c19354a1a90e2387b434d12153c90f20f627" translate="yes" xml:space="preserve">
          <source>If you are compiling in PASE, then &quot;make install&quot; is the only thing you will need to do.</source>
          <target state="translated">如果你是用PASE编译,那么 &quot;make install &quot;是你唯一需要做的事情。</target>
        </trans-unit>
        <trans-unit id="81413ae9ed04e602e1a5e2aa34f9a9228c164afc" translate="yes" xml:space="preserve">
          <source>If you are compiling on AIX, simply do a &quot;make install&quot; on the AIX box. Once the install finishes, tar up the /QOpenSys/perl directory. Transfer the tarball to the OS/400 using FTP with the following commands:</source>
          <target state="translated">如果你是在AIX上编译,只需在AIX上进行 &quot;make install&quot;。一旦安装完成,将/QOpenSys/perl目录用tar压缩。使用下面的命令将 tar 包传输到 OS/400。</target>
        </trans-unit>
        <trans-unit id="633f40501c71cc3d9b9dd021b947e0958a8636a6" translate="yes" xml:space="preserve">
          <source>If you are confident that all byte-strings will be in a specific encoding like UTF-8,</source>
          <target state="translated">如果你确信所有的字节串都将采用UTF-8等特定编码。</target>
        </trans-unit>
        <trans-unit id="24c32dcfc58ac17c09099d20bc9bc3a8e41bba8b" translate="yes" xml:space="preserve">
          <source>If you are content with the test result, just &quot;make install&quot;</source>
          <target state="translated">如果你对测试结果感到满意,只要 &quot;make install&quot;</target>
        </trans-unit>
        <trans-unit id="aa6a61423fd16b04dc17486be56b73db7a8c3506" translate="yes" xml:space="preserve">
          <source>If you are creating a PerlIO layer, you may want to be lazy, in other words, implement only the methods that interest you. The other methods you can either replace with the &quot;blank&quot; methods</source>
          <target state="translated">如果你正在创建一个PerlIO层,你可能想偷懒,换句话说,只实现你感兴趣的方法。其他的方法你可以用 &quot;空白 &quot;的方法来代替。</target>
        </trans-unit>
        <trans-unit id="602ef84230a9a9bbabefd6f60652a28db56ddfcd" translate="yes" xml:space="preserve">
          <source>If you are creating a Zip file using the one-shot interface, and any of the input files is greater than 4Gig, a zip64 complaint zip file will be created.</source>
          <target state="translated">如果使用一键式界面创建Zip文件,且任何一个输入文件大于4Gig,就会创建一个zip64申诉压缩文件。</target>
        </trans-unit>
        <trans-unit id="4b2de75d9b2a463fc1f9325a0ae503a9f6861718" translate="yes" xml:space="preserve">
          <source>If you are developing a suite of related modules/classes it's good practice to use nested classes with a common prefix as this will avoid namespace clashes. For example: Xyz::Control, Xyz::View, Xyz::Model etc. Use the modules in this list as a naming guide.</source>
          <target state="translated">如果你正在开发一套相关的模块/类,最好的做法是使用具有共同前缀的嵌套类,这样可以避免命名空间的冲突。例如:Xyz::Control,Xyz::View,Xyz::View Xyz::Control,Xyz::View,Xyz::Model等。使用这个列表中的模块作为命名指南。</target>
        </trans-unit>
        <trans-unit id="cf3f54058ec5c3861eafa70f589fb5c16feca4d3" translate="yes" xml:space="preserve">
          <source>If you are doing a blocking &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread()&lt;/a&gt;&lt;/code&gt;, you'll have to arrange for an alarm handler to provide a timeout (see &lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;). If you have a non-blocking open, you'll likely have a non-blocking read, which means you may have to use a 4-arg &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; to determine whether I/O is ready on that device (see &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;.</source>
          <target state="translated">如果要执行阻塞的 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread()&lt;/a&gt;&lt;/code&gt; ，则必须安排警报处理程序以提供超时（请参阅&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;）。如果您打开的是非阻塞状态，则很可能会进行非阻塞读取，这意味着您可能必须使用4-arg &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 来确定该设备上的I / O是否准备就绪（请参见&lt;a href=&quot;functions/select&quot;&gt;select）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3262a8838df2cab768e5f0aeb8b39d02c8c5bb9" translate="yes" xml:space="preserve">
          <source>If you are doing a blocking &lt;code&gt;read()&lt;/code&gt; or &lt;code&gt;sysread()&lt;/code&gt;, you'll have to arrange for an alarm handler to provide a timeout (see &lt;a href=&quot;perlfunc#alarm&quot;&gt;&quot;alarm&quot; in perlfunc&lt;/a&gt;). If you have a non-blocking open, you'll likely have a non-blocking read, which means you may have to use a 4-arg &lt;code&gt;select()&lt;/code&gt; to determine whether I/O is ready on that device (see &lt;a href=&quot;perlfunc#select&quot;&gt;&quot;select&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">如果要执行阻塞的 &lt;code&gt;read()&lt;/code&gt; 或 &lt;code&gt;sysread()&lt;/code&gt; ，则必须安排警报处理程序以提供超时（请参阅&lt;a href=&quot;perlfunc#alarm&quot;&gt;perlfunc中的&amp;ldquo;警报&amp;rdquo;&lt;/a&gt;）。如果您打开的是非阻塞状态，则可能会读取到非阻塞状态，这意味着您可能必须使用4-arg &lt;code&gt;select()&lt;/code&gt; 来确定该设备上的I / O是否准备就绪（请参见&lt;a href=&quot;perlfunc#select&quot;&gt;&amp;ldquo;选择&amp;rdquo;在perlfunc中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec0d9c19ee9bcc3793bd395f6bcc7da295d90db4" translate="yes" xml:space="preserve">
          <source>If you are doing something complex, such as moving through many pages and forms or a web site, you can use &lt;a href=&quot;WWW::Mechanize&quot;&gt;WWW::Mechanize&lt;/a&gt;. See its documentation for all the details.</source>
          <target state="translated">如果您正在做复杂的事情，例如浏览许多页面和表单或一个网站，则可以使用&lt;a href=&quot;WWW::Mechanize&quot;&gt;WWW :: Mechanize&lt;/a&gt;。有关所有详细信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="27eb5f2751e7b3c976fa3693eb1b047c9ea468b5" translate="yes" xml:space="preserve">
          <source>If you are doing something complex, such as moving through many pages and forms or a web site, you can use &lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW::Mechanize&lt;/a&gt;. See its documentation for all the details.</source>
          <target state="translated">如果您正在做复杂的事情，例如浏览许多页面和表单或一个网站，则可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW :: Mechanize&lt;/a&gt;。有关所有详细信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="1a9b4d7923308acf7ee68c13a2cd11f90f3c70ce" translate="yes" xml:space="preserve">
          <source>If you are experiencing variable suicide, that &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; in the subroutine doesn't pick up a fresh copy of the &lt;code&gt;$f&lt;/code&gt; whose value is &lt;code&gt;'foo'&lt;/code&gt; . The output shows that inside the subroutine the value of &lt;code&gt;$f&lt;/code&gt; leaks through when it shouldn't, as in this output:</source>
          <target state="translated">如果您遇到变量自杀，那 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; 在子程序不拿起的全新副本 &lt;code&gt;$f&lt;/code&gt; ，其值是 &lt;code&gt;'foo'&lt;/code&gt; 。输出显示，在子例程中， &lt;code&gt;$f&lt;/code&gt; 的值在不应该泄漏的情况下泄漏，如下所示：</target>
        </trans-unit>
        <trans-unit id="90ffffc1c986cd8a0326c90c4ba333b4ce6ffe43" translate="yes" xml:space="preserve">
          <source>If you are experiencing variable suicide, that &lt;code&gt;my $f&lt;/code&gt; in the subroutine doesn't pick up a fresh copy of the &lt;code&gt;$f&lt;/code&gt; whose value is &lt;code&gt;'foo'&lt;/code&gt;. The output shows that inside the subroutine the value of &lt;code&gt;$f&lt;/code&gt; leaks through when it shouldn't, as in this output:</source>
          <target state="translated">如果您正在经历可变的自杀，则子例程中的 &lt;code&gt;my $f&lt;/code&gt; 不会获取 &lt;code&gt;$f&lt;/code&gt; 的新副本，其值是 &lt;code&gt;'foo'&lt;/code&gt; 。输出显示，在子例程中， &lt;code&gt;$f&lt;/code&gt; 的值在不应该泄漏的情况下泄漏，如下所示：</target>
        </trans-unit>
        <trans-unit id="bbeae6d94c0568a9909c55582ce46133df1b3000" translate="yes" xml:space="preserve">
          <source>If you are familiar with the</source>
          <target state="translated">如果你熟悉</target>
        </trans-unit>
        <trans-unit id="09b5540260d1429f031cae6d4fea34d1c0219ed0" translate="yes" xml:space="preserve">
          <source>If you are forking many processes in parallel that are all creating temporary files, you may need to reset the random number seed using srand(EXPR) in each child else all the children will attempt to walk through the same set of random file names and may well cause themselves to give up if they exceed the number of retry attempts.</source>
          <target state="translated">如果你正在并行分叉许多进程,这些进程都在创建临时文件,你可能需要在每个子进程中使用srand(EXPR)重置随机数种子,否则所有的子进程都会尝试走过同一组随机文件名,如果它们超过了重试次数,很可能导致自己放弃。</target>
        </trans-unit>
        <trans-unit id="79eaecd3ef824520bc14f0a6f551bc580fb007f0" translate="yes" xml:space="preserve">
          <source>If you are going to convert the script to a module you can use the opportunity to redesign the interface. The guidelines for module creation above include many of the issues you should consider.</source>
          <target state="translated">如果你要把脚本转换为模块,你可以利用这个机会重新设计界面。上面的模块创建指南包括了许多你应该考虑的问题。</target>
        </trans-unit>
        <trans-unit id="37c8864889db08a398c2a1fd61fb5557dd86b1b1" translate="yes" xml:space="preserve">
          <source>If you are going to put something onto the Perl stack, you need to know where to put it. This is the purpose of the macro &lt;code&gt;dSP&lt;/code&gt; --it declares and initializes a</source>
          <target state="translated">如果要将东西放到Perl堆栈上，则需要知道将它放到哪里。这是宏 &lt;code&gt;dSP&lt;/code&gt; 的目的-它声明并初始化一个</target>
        </trans-unit>
        <trans-unit id="537495a37e599c942d74bd5d8aca0155b4da8202" translate="yes" xml:space="preserve">
          <source>If you are going to put something onto the Perl stack, you need to know where to put it. This is the purpose of the macro &lt;code&gt;dSP&lt;/code&gt;--it declares and initializes a</source>
          <target state="translated">如果要将某些东西放到Perl堆栈中，则需要知道将它放到哪里。这是宏 &lt;code&gt;dSP&lt;/code&gt; 的目的-它声明并初始化一个</target>
        </trans-unit>
        <trans-unit id="0cf3f133791811ca9201975358ebf1e226d3c50a" translate="yes" xml:space="preserve">
          <source>If you are going to use the HP DCE package, the library used for threading is /usr/lib/libcma.sl, but there have been multiple updates of that library over time. Perl will build with the first version, but it will not pass the test suite. Older Oracle versions might be a compelling reason not to update that library, otherwise please find a newer version in one of the following patches: PHSS_19739, PHSS_20608, or PHSS_23672</source>
          <target state="translated">如果你要使用HP DCE包,用于线程的库是/usr/lib/libcma.sl,但随着时间的推移,该库有过多次更新。Perl会用第一个版本来构建,但它不会通过测试套件。较旧的 Oracle 版本可能是不更新该库的一个令人信服的理由,否则请在以下补丁中找到一个较新的版本。PHSS_19739,PHSS_20608,或 PHSS_23672。</target>
        </trans-unit>
        <trans-unit id="330882464199f1a0851acc4b79e3a966cdc91c15" translate="yes" xml:space="preserve">
          <source>If you are going to use this method you have to be aware of a possible memory leak which can arise under very specific circumstances. To explain these circumstances you need to know a bit about the flow of control between Perl and the callback routine.</source>
          <target state="translated">如果你要使用这个方法,你必须意识到在非常特殊的情况下可能出现的内存泄漏。为了解释这些情况,你需要了解一下Perl和回调例程之间的控制流。</target>
        </trans-unit>
        <trans-unit id="91073f8278c247bf05c5742a59e2d0906bf12cbd" translate="yes" xml:space="preserve">
          <source>If you are going to write a platform specific MM package, please try to limit the necessary overrides to primitive methods, and if it is not possible to do so, let's work out how to achieve that gain.</source>
          <target state="translated">如果你要写一个特定平台的MM包,请尽量把必要的覆盖限制在原始方法上,如果做不到,我们就想办法实现这个收益。</target>
        </trans-unit>
        <trans-unit id="3470649433d76902fec9be392ea404a581213006" translate="yes" xml:space="preserve">
          <source>If you are having trouble with square brackets then consider switching your rlogin or telnet client. Try to avoid older 3270 emulators and ISHELL for working with Perl on USS.</source>
          <target state="translated">如果你在使用方括号时有问题,那么可以考虑换一个rlogin或者telnet客户端。在USS上使用Perl时,尽量避免使用老的3270模拟器和ISHELL。</target>
        </trans-unit>
        <trans-unit id="fb193e3267912e83638916e973e0dcc8b120aead" translate="yes" xml:space="preserve">
          <source>If you are in any doubt about the license situation, contact either the Berkeley DB authors or the author of DB_File. See &lt;a href=&quot;#AUTHOR&quot;&gt;&quot;AUTHOR&quot;&lt;/a&gt; for details.</source>
          <target state="translated">如果您对许可情况有任何疑问，请与Berkeley DB作者或DB_File的作者联系。有关详细信息，请参见&lt;a href=&quot;#AUTHOR&quot;&gt;&amp;ldquo;作者&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="be777d0c50e7b77da7283f3ff8a7e540b7f7344c" translate="yes" xml:space="preserve">
          <source>If you are in any doubt about the license situation, contact either the Berkeley DB authors or the author of DB_File. See &lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt; for details.</source>
          <target state="translated">如果您对许可情况有任何疑问，请与Berkeley DB作者或DB_File作者联系。有关详细信息，请参见&lt;a href=&quot;#AUTHOR&quot;&gt;作者&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99320978b9537887ebc85e1dfd4bdf0910cbc812" translate="yes" xml:space="preserve">
          <source>If you are in doubt which package contains a file you are missing, try to find an installation that has that file. Then do a</source>
          <target state="translated">如果你不确定哪个软件包中包含了你所缺少的文件,请尝试找到一个有该文件的安装。然后执行</target>
        </trans-unit>
        <trans-unit id="92276bc0e44e1b658a5288e18f73cfbd284b63bb" translate="yes" xml:space="preserve">
          <source>If you are intending to manipulate bitstrings, be certain that you're supplying bitstrings: If an operand is a number, that will imply a &lt;b&gt;numeric&lt;/b&gt; bitwise operation. You may explicitly show which type of operation you intend by using &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;0+&lt;/code&gt; , as in the examples below.</source>
          <target state="translated">如果要操纵位串，请确保要提供位串：如果操作数是数字，则表示&lt;b&gt;数字&lt;/b&gt;按位运算。您可以使用 &lt;code&gt;&quot;&quot;&lt;/code&gt; 或 &lt;code&gt;0+&lt;/code&gt; 明确显示您打算使用哪种类型的操作，如以下示例所示。</target>
        </trans-unit>
        <trans-unit id="2877e8cae4b72c189b80caef94210456b80f06da" translate="yes" xml:space="preserve">
          <source>If you are intending to manipulate bitstrings, be certain that you're supplying bitstrings: If an operand is a number, that will imply a &lt;b&gt;numeric&lt;/b&gt; bitwise operation. You may explicitly show which type of operation you intend by using &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;0+&lt;/code&gt;, as in the examples below.</source>
          <target state="translated">如果要操作位串，请确保要提供位串：如果操作数是数字，则表示&lt;b&gt;数字&lt;/b&gt;按位运算。您可以通过使用 &lt;code&gt;&quot;&quot;&lt;/code&gt; 或 &lt;code&gt;0+&lt;/code&gt; 来明确显示您打算使用哪种类型的操作，如以下示例所示。</target>
        </trans-unit>
        <trans-unit id="a0e74d8ccd8d67f221dc38d69397982438ef8887" translate="yes" xml:space="preserve">
          <source>If you are interested in the guts underlying these systems, check out &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">如果您对这些系统的内在结构感兴趣，请查看&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f81bce975381ffe867c89af365021d38913e30eb" translate="yes" xml:space="preserve">
          <source>If you are interested in the z/OS (formerly known as OS/390) and POSIX-BC (BS2000) ports of Perl then see the perl-mvs mailing list. To subscribe, send an empty message to perl-mvs-subscribe@perl.org.</source>
          <target state="translated">如果您对 Perl 的 z/OS (以前称为 OS/390)和 POSIX-BC (BS2000)端口感兴趣,请参见 perl-mvs 邮件列表。要订阅,请发送空邮件到 perl-mvs-subscribe@perl.org。</target>
        </trans-unit>
        <trans-unit id="81e9b341887276c07ed78e971fe73fb2fe685324" translate="yes" xml:space="preserve">
          <source>If you are interested in writing new tools you should take a look at &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt; first.</source>
          <target state="translated">如果您有兴趣编写新工具，则应首先查看&lt;a href=&quot;Test2::API&quot;&gt;Test2 :: API&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18b06deb07c89c9dfd8a2b96ce84d618599bef3b" translate="yes" xml:space="preserve">
          <source>If you are interested in writing tests using new tools then you should look at &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;. &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt; is a separate cpan distribution that contains many tools implemented on Test2.</source>
          <target state="translated">如果您有兴趣使用新工具编写测试，则应查看&lt;a href=&quot;Test2::Suite&quot;&gt;Test2 :: Suite&lt;/a&gt;。&lt;a href=&quot;Test2::Suite&quot;&gt;Test2 :: Suite&lt;/a&gt;是一个单独的cpan发行版，其中包含许多在Test2上实现的工具。</target>
        </trans-unit>
        <trans-unit id="38d9bbb97bd39f15f79a0ad6f3bd53d77bb54ef1" translate="yes" xml:space="preserve">
          <source>If you are looking for a &quot;bar&quot; that isn't preceded by a &quot;foo&quot;, &lt;code&gt;/(?!foo)bar/&lt;/code&gt; will not do what you want. That's because the &lt;code&gt;(?!foo)&lt;/code&gt; is just saying that the next thing cannot be &quot;foo&quot;--and it's not, it's a &quot;bar&quot;, so &quot;foobar&quot; will match. Use look-behind instead (see below).</source>
          <target state="translated">如果您要查找的&amp;ldquo; bar&amp;rdquo;前面没有&amp;ldquo; foo&amp;rdquo;，则 &lt;code&gt;/(?!foo)bar/&lt;/code&gt; 不会做您想要的事情。这是因为 &lt;code&gt;(?!foo)&lt;/code&gt; 只是说下一个东西不能是&amp;ldquo; foo&amp;rdquo;，不是，它是&amp;ldquo; bar&amp;rdquo;，因此&amp;ldquo; foobar&amp;rdquo;将匹配。改用后向（见下文）。</target>
        </trans-unit>
        <trans-unit id="f7b2a50928124f0618a8144a8e1baa9cc8e568eb" translate="yes" xml:space="preserve">
          <source>If you are looking for a &quot;bar&quot; that isn't preceded by a &quot;foo&quot;, &lt;code&gt;/(?!foo)bar/&lt;/code&gt; will not do what you want. That's because the &lt;code&gt;(?!foo)&lt;/code&gt; is just saying that the next thing cannot be &quot;foo&quot;--and it's not, it's a &quot;bar&quot;, so &quot;foobar&quot; will match. Use lookbehind instead (see below).</source>
          <target state="translated">如果您要查找的&amp;ldquo; bar&amp;rdquo;前面没有&amp;ldquo; foo&amp;rdquo;，则 &lt;code&gt;/(?!foo)bar/&lt;/code&gt; 不会做您想要的事情。这是因为 &lt;code&gt;(?!foo)&lt;/code&gt; 只是说下一个东西不能是&amp;ldquo; foo&amp;rdquo;，不是，这是一个&amp;ldquo; bar&amp;rdquo;，因此&amp;ldquo; foobar&amp;rdquo;将匹配。请改用lookbehind（请参阅下文）。</target>
        </trans-unit>
        <trans-unit id="dc60d35f80efdd879c9aa94cc9f2ee7ad195384c" translate="yes" xml:space="preserve">
          <source>If you are looking for a class that does everything for you that you don't define yourself, use the &lt;code&gt;Tie::StdScalar&lt;/code&gt; class, not the &lt;code&gt;Tie::Scalar&lt;/code&gt; one.</source>
          <target state="translated">如果您正在寻找一类可以为您做自己没有定义的事情的类，请使用 &lt;code&gt;Tie::StdScalar&lt;/code&gt; 类，而不要使用 &lt;code&gt;Tie::Scalar&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="f20427718038bfba8c53137f8646eb9abfc2ff46" translate="yes" xml:space="preserve">
          <source>If you are looking for a class that does everything for you you don't define yourself, use the &lt;code&gt;Tie::StdScalar&lt;/code&gt; class, not the &lt;code&gt;Tie::Scalar&lt;/code&gt; one.</source>
          <target state="translated">如果您正在寻找一个可以为您做所有事情的类，但您自己没有定义自己，请使用 &lt;code&gt;Tie::StdScalar&lt;/code&gt; 类，而不要使用 &lt;code&gt;Tie::Scalar&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="7787fb3feb00a627232c8ef4ce3954c9d7deed73" translate="yes" xml:space="preserve">
          <source>If you are looking for a table of contents to the Perl library modules documentation, see the &lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc&lt;/a&gt; page.</source>
          <target state="translated">如果要在Perl库模块文档中查找目录，请参阅&lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc&lt;/a&gt;页面。</target>
        </trans-unit>
        <trans-unit id="40f5e81161933568c426f178117fbe0b2c9f0084" translate="yes" xml:space="preserve">
          <source>If you are looking for a table of contents to the Perl library modules documentation, see the &lt;a href=&quot;perltoc&quot;&gt;perltoc&lt;/a&gt; page.</source>
          <target state="translated">如果要在Perl库模块文档中查找目录，请参阅&lt;a href=&quot;perltoc&quot;&gt;perltoc&lt;/a&gt;页面。</target>
        </trans-unit>
        <trans-unit id="3fac826063cfc00ef4ae02f7626b0848d723ad5d" translate="yes" xml:space="preserve">
          <source>If you are looking for an example, I recommend that you look at the simple example in the Memoize::Expire documentation, or at the code for Memoize::Expire itself.</source>
          <target state="translated">如果你想找一个例子,我建议你看看 Memoize::Expire 文档中的简单例子,或者 Memoize::Expire 本身的代码。</target>
        </trans-unit>
        <trans-unit id="01bb70148d15624f6da074182f77ad2f0eee86c6" translate="yes" xml:space="preserve">
          <source>If you are looking for helpers with &lt;code&gt;is&lt;/code&gt;, &lt;code&gt;like&lt;/code&gt;, and others, see &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;.</source>
          <target state="translated">如果您正在使用 &lt;code&gt;is&lt;/code&gt; 和 &lt;code&gt;like&lt;/code&gt; 等来寻找帮助者，请参见&lt;a href=&quot;Test2::Suite&quot;&gt;Test2 :: Suite&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b33652a525614ae7d89321a43fb11331d7e5b6fa" translate="yes" xml:space="preserve">
          <source>If you are making use of the Perl stack pointer in your code you must always refresh the local copy using SPAGAIN whenever you make use of the</source>
          <target state="translated">如果你在代码中使用Perl堆栈指针,你必须在每次使用了</target>
        </trans-unit>
        <trans-unit id="31bb9506f4ff23e6db70b0b08455755a7de18605" translate="yes" xml:space="preserve">
          <source>If you are not using threads, forking, or IPC then the only difference between a &lt;code&gt;filter&lt;/code&gt; and a &lt;code&gt;pre_filter&lt;/code&gt; is that &lt;code&gt;pre_filter&lt;/code&gt; subs run first. When you are using threads, forking, or IPC, pre_filters happen to events before they are sent to their destination proc/thread, ordinary filters happen only in the destination hub/thread.</source>
          <target state="translated">如果您不使用线程，分支或IPC，则 &lt;code&gt;filter&lt;/code&gt; 和 &lt;code&gt;pre_filter&lt;/code&gt; 之间的唯一区别是 &lt;code&gt;pre_filter&lt;/code&gt; 子程序首先运行。当您使用线程，分支或IPC时，pre_filters会在事件发送到其目标proc / thread之前发生在事件上，普通的filter仅在目标集线器/线程中发生。</target>
        </trans-unit>
        <trans-unit id="0468c5bae6319f4655b5720508b9d190b598ea2a" translate="yes" xml:space="preserve">
          <source>If you are on a Unix-like system, you might be able to get away with a system call where you put an &lt;code&gt;&amp;amp;&lt;/code&gt; on the end of the command:</source>
          <target state="translated">如果您使用的是类似Unix的系统，则可以通过在命令末尾添加 &lt;code&gt;&amp;amp;&lt;/code&gt; 的系统调用来摆脱困境：</target>
        </trans-unit>
        <trans-unit id="74fb92ccab7935bd1e0cc2c8300a7bef29eb75de" translate="yes" xml:space="preserve">
          <source>If you are on a non-UNIX platform &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;, as some features may be unimplemented or work differently.</source>
          <target state="translated">如果您在非UNIX平台上的&lt;b&gt;perldoc &lt;/b&gt;&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;，则某些功能可能未实现或工作方式不同。</target>
        </trans-unit>
        <trans-unit id="5f59ff52a71652ecb89231c85ecae2ce17688eb9" translate="yes" xml:space="preserve">
          <source>If you are on a system that correctly implements &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; and you use the example appending code from &quot;perldoc -f flock&quot; everything will be OK even if the OS you are on doesn't implement append mode correctly (if such a system exists). So if you are happy to restrict yourself to OSs that implement &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; (and that's not really much of a restriction) then that is what you should do.</source>
          <target state="translated">如果您使用的系统正确实现了 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; ,并且使用了来自&amp;ldquo; perldoc -f flock&amp;rdquo;的示例附加代码示例，那么即使您所使用的操作系统未正确实现附加模式（如果存在这样的系统），一切都可以。因此，如果您很乐意将自己限制在实现 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 操作系统上（这实际上并不是很大的限制），那么您应该这样做。</target>
        </trans-unit>
        <trans-unit id="775ac36d1065d528736d6584503c5960de9afca8" translate="yes" xml:space="preserve">
          <source>If you are on a system that correctly implements &lt;code&gt;flock&lt;/code&gt; and you use the example appending code from &quot;perldoc -f flock&quot; everything will be OK even if the OS you are on doesn't implement append mode correctly (if such a system exists). So if you are happy to restrict yourself to OSs that implement &lt;code&gt;flock&lt;/code&gt; (and that's not really much of a restriction) then that is what you should do.</source>
          <target state="translated">如果您使用的系统正确实现了 &lt;code&gt;flock&lt;/code&gt; ,并且使用了来自&amp;ldquo; perldoc -f flock&amp;rdquo;的示例附加代码示例，那么即使您所使用的操作系统未正确实现附加模式（如果存在这样的系统），一切都可以。因此，如果您很乐意将自己限制在实现 &lt;code&gt;flock&lt;/code&gt; 操作系统上（这实际上并不是很大的限制），那么这就是您应该做的。</target>
        </trans-unit>
        <trans-unit id="54d7fa3e38420fc843370b116c9be081ea5603e0" translate="yes" xml:space="preserve">
          <source>If you are only exporting function names it is recommended to omit the ampersand, as the implementation is faster this way.</source>
          <target state="translated">如果你只输出函数名,建议省略安培符,因为这样执行起来更快。</target>
        </trans-unit>
        <trans-unit id="2de91fd61e5dabce87e62b432c1af2d2e0384486" translate="yes" xml:space="preserve">
          <source>If you are overriding any of these methods in your Makefile.PL (in the MY class), please report that to the makemaker mailing list. We are trying to minimize the necessary method overrides and switch to data driven Makefile.PLs wherever possible. In the long run less methods will be overridable via the MY class.</source>
          <target state="translated">如果你在你的Makefile.PL中(在MY类中)覆盖了这些方法,请向makemaker邮件列表报告。我们正在努力减少必要的方法重写,并尽可能地转向数据驱动的Makefile.PLs。从长远来看,通过MY类可重写的方法将会减少。</target>
        </trans-unit>
        <trans-unit id="25095e5b9b6ab11015f95ba50809b8be1a58758d" translate="yes" xml:space="preserve">
          <source>If you are particularly interested in customizing this module's output even more, see the source and/or write to me.</source>
          <target state="translated">如果你对自定义这个模块的输出特别感兴趣,请看源码和/或写信给我。</target>
        </trans-unit>
        <trans-unit id="d40865e3f4f814dc75edbc20fbc8762037c6c824" translate="yes" xml:space="preserve">
          <source>If you are printing IVs, UVs, or NVS instead of the stdio(3) style formatting codes like &lt;code&gt;%d&lt;/code&gt; , &lt;code&gt;%ld&lt;/code&gt; , &lt;code&gt;%f&lt;/code&gt; , you should use the following macros for portability</source>
          <target state="translated">如果要打印IV，UV或NVS而不是诸如 &lt;code&gt;%d&lt;/code&gt; ， &lt;code&gt;%ld&lt;/code&gt; ， &lt;code&gt;%f&lt;/code&gt; 之类的stdio（3）样式格式代码，则应使用以下宏来实现可移植性</target>
        </trans-unit>
        <trans-unit id="367b87e5b6a685cdb2627b032e60c907e2607076" translate="yes" xml:space="preserve">
          <source>If you are printing IVs, UVs, or NVS instead of the stdio(3) style formatting codes like &lt;code&gt;%d&lt;/code&gt;, &lt;code&gt;%ld&lt;/code&gt;, &lt;code&gt;%f&lt;/code&gt;, you should use the following macros for portability</source>
          <target state="translated">如果要打印IV，UV或NVS而不是诸如 &lt;code&gt;%d&lt;/code&gt; ， &lt;code&gt;%ld&lt;/code&gt; ， &lt;code&gt;%f&lt;/code&gt; 之类的stdio（3）样式格式代码，则应使用以下宏以实现可移植性</target>
        </trans-unit>
        <trans-unit id="6da5a3aba0348fe8e8ae52d62d3e9bfb01a53b73" translate="yes" xml:space="preserve">
          <source>If you are printing addresses of pointers, use %p or UVxf combined with PTR2UV().</source>
          <target state="translated">如果你要打印指针的地址,请使用%p或UVxf结合PTR2UV()。</target>
        </trans-unit>
        <trans-unit id="b082a380f246d61dd682cd511f2ea77809e32735" translate="yes" xml:space="preserve">
          <source>If you are printing addresses of pointers, use UVxf combined with PTR2UV(), do not use %lx or %p.</source>
          <target state="translated">如果要打印指针的地址,请使用UVxf结合PTR2UV(),不要使用%lx或%p。</target>
        </trans-unit>
        <trans-unit id="b6f4ed221243b9dde4f0f2cc29b067e485bbf822" translate="yes" xml:space="preserve">
          <source>If you are reading this documentation, looking for a replacement for the &lt;code&gt;FileHandle&lt;/code&gt; package, then I suggest you read the documentation for &lt;code&gt;IO::File&lt;/code&gt; too.</source>
          <target state="translated">如果您正在阅读本文档，寻找 &lt;code&gt;FileHandle&lt;/code&gt; 包的替代品，那么我建议您也阅读 &lt;code&gt;IO::File&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="8c40246fed4e0a31f96c46a72d0a85e56bbe29c3" translate="yes" xml:space="preserve">
          <source>If you are reading this in the future then it's possible that the state of the art has changed. We recommend you start by reading the perlootut document in the latest stable release of Perl, rather than this version.</source>
          <target state="translated">如果你是在未来阅读这篇文章,那么有可能技术状态已经发生了变化。我们建议你先阅读Perl最新稳定版中的perlootut文档,而不是这个版本。</target>
        </trans-unit>
        <trans-unit id="d0add6c557074aa94dbce442362b0e5da76c5396" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Bzip2 can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您正在运行Perl 5.005或更高版本，则从IO :: Compress :: Bzip2返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输出文件操作。例如，要写入压缩文件/缓冲区，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="b7e4df4e4f27db0bf9a46e2a1941e85758d61068" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Deflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您运行的是Perl 5.005或更高版本，则从IO :: Compress :: Deflate返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输出文件操作。例如，要写入压缩文件/缓冲区，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="41e65ffc69fed189ecd525fba0988f92db4e7035" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Gzip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果运行的是Perl 5.005或更高版本，则从IO :: Compress :: Gzip返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输出文件操作。例如，要写入压缩文件/缓冲区，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="c6b6ef257ae9881b6bd3fd8eaa22b1a4c05c99ca" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::RawDeflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您运行的是Perl 5.005或更高版本，则从IO :: Compress :: RawDeflate返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输出文件操作。例如，要写入压缩文件/缓冲区，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="3c423a94c7fc5cb61812044d70c6c094354f683a" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Zip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果运行的是Perl 5.005或更高版本，则从IO :: Compress :: Zip返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输出文件操作。例如，要写入压缩文件/缓冲区，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="5fea5722273a1695c99b2d6f3f73bb1257cd24c3" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::AnyInflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您运行的是Perl 5.005或更高版本，则从IO :: Uncompress :: AnyInflate返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="b2972d5cdbb1eb98b989631b3ded397e40e59e75" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::AnyUncompress can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果运行的是Perl 5.005或更高版本，则从IO :: Uncompress :: AnyUncompress返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="18aa1921698d337e93a7e4edaa2b66e95de457bf" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Bunzip2 can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果运行的是Perl 5.005或更高版本，则从IO :: Uncompress :: Bunzip2返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="f86eb994b5def7f39f87b382b570ded31372309e" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Gunzip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您正在运行Perl 5.005或更高版本，则从IO :: Uncompress :: Gunzip返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="05ab40d4db9fa577fb79380b48870abe52f5c6be" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Inflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您运行的是Perl 5.005或更高版本，则从IO :: Uncompress :: Inflate返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="d70a4ecbd7bb1c964123dba102fe8a49b561cb00" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::RawInflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您运行的是Perl 5.005或更高版本，则从IO :: Uncompress :: RawInflate返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="3608890b582bffd465c544ac9e831ad2b06501a0" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Unzip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您正在运行Perl 5.005或更高版本，则从IO :: Uncompress :: Unzip返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="c3f55f8a5aa9143947c1b03103f8fcb1230f8026" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::Bzip2 can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您运行的是Perl 5.005或更高版本，则从IO :: Compress :: Bzip2返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;IO::File&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输出文件操作。例如，要写入压缩文件/缓冲区，您可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="4c943ecc09f7906641ce0c8c9195f36b53b0da84" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::Deflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您运行的是Perl 5.005或更高版本，则从IO :: Compress :: Deflate返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;IO::File&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输出文件操作。例如，要写入压缩文件/缓冲区，您可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="d0d2de3cb6af8e02dfa388bc8385e1f9fef63232" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::Gzip can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果运行的是Perl 5.005或更高版本，则从IO :: Compress :: Gzip返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;IO::File&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输出文件操作。例如，要写入压缩文件/缓冲区，您可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="0f19394fb5dae0da1468d85a7077d6de961381d1" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::RawDeflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您正在运行Perl 5.005或更高版本，则从IO :: Compress :: RawDeflate返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;IO::File&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输出文件操作。例如，要写入压缩文件/缓冲区，您可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="8705529210f30abadfa2690a88a8e55709062caf" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::Zip can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您运行的是Perl 5.005或更高版本，则从IO :: Compress :: Zip返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;IO::File&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输出文件操作。例如，要写入压缩文件/缓冲区，您可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="af8dcbb9c89b754c497d19b04a16a87cbcd0b450" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::AnyInflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您正在运行Perl 5.005或更高版本，则从IO :: Uncompress :: AnyInflate返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;IO::File&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="3dc295bba8742677124dc7e9dbafd6bdce18ea43" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::AnyUncompress can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果运行的是Perl 5.005或更高版本，则从IO :: Uncompress :: AnyUncompress返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;IO::File&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="f04020399fea242c9c0dc69403e3ea87fc90e780" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::Bunzip2 can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您运行的是Perl 5.005或更高版本，则从IO :: Uncompress :: Bunzip2返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;IO::File&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="d8386c862fdf7a36268d1e2d11759b36cc61a052" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::Gunzip can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您正在运行Perl 5.005或更高版本，则从IO :: Uncompress :: Gunzip返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;IO::File&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="e228b2a0d2a2705757b5a03c01b16b81052402f0" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::Inflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果运行的是Perl 5.005或更高版本，则从IO :: Uncompress :: Inflate返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;IO::File&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="250328bb572e14771a91f743881702e8168f7ce1" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::RawInflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您运行的是Perl 5.005或更高版本，则从IO :: Uncompress :: RawInflate返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;IO::File&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="ac7ddace8a1bf7c76549d07abf22fa8e8e550364" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::Unzip can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您运行的是Perl 5.005或更高版本，则从IO :: Uncompress :: Unzip返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;IO::File&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="89f53b731da5c3618fcf6d87c9434da7f9ed2f65" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.6.0 or better, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma allows fine control of what warnings are produced. See &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; for more details.</source>
          <target state="translated">如果您运行的是Perl 5.6.0或更高版本，则 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 编译指示可以精确控制产生的警告。有关更多详细信息，请参见&lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3a447e1361d79aaa9ee74688b52a31d693ae7e5" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.6.0 or better, the &lt;code&gt;use warnings&lt;/code&gt; pragma allows fine control of what warnings are produced. See &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; for more details.</source>
          <target state="translated">如果您运行的是Perl 5.6.0或更高版本，则 &lt;code&gt;use warnings&lt;/code&gt; 编译指示可以精确控制生成的警告。有关更多详细信息，请参见&lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af8514c8e63d77882efdff2789324ce75a2c20f4" translate="yes" xml:space="preserve">
          <source>If you are running VOS Release 14.4.1 or later, you can obtain a pre-compiled, supported copy of perl by purchasing the GNU Tools product from Stratus Technologies.</source>
          <target state="translated">如果您运行的是VOS 14.4.1或更高版本,您可以通过购买Stratus Technologies的GNU Tools产品来获得一个预编译的、受支持的perl副本。</target>
        </trans-unit>
        <trans-unit id="90113b08f2e5803b4f4fa9119cc6038c86b7bb42" translate="yes" xml:space="preserve">
          <source>If you are running a Unix derivative this value defaults to</source>
          <target state="translated">如果你运行的是Unix衍生产品,这个值默认为</target>
        </trans-unit>
        <trans-unit id="9cc43bdd9e8f39cf93edce0474ecd12686e0c219" translate="yes" xml:space="preserve">
          <source>If you are running experiments with embedding perl as a library into other applications, you might find MakeMaker is not sufficient. You'd better have a look at &lt;a href=&quot;ExtUtils::Embed&quot;&gt;ExtUtils::Embed&lt;/a&gt; which is a collection of utilities for embedding.</source>
          <target state="translated">如果您正在运行将perl作为库嵌入到其他应用程序中的实验，则可能会发现MakeMaker是不够的。您最好看看&lt;a href=&quot;ExtUtils::Embed&quot;&gt;ExtUtils :: Embed&lt;/a&gt;，它是用于嵌入的实用程序的集合。</target>
        </trans-unit>
        <trans-unit id="ae421a254aed7ffd059cb6be52110578a85cd308" translate="yes" xml:space="preserve">
          <source>If you are running experiments with embedding perl as a library into other applications, you might find MakeMaker is not sufficient. You'd better have a look at ExtUtils::Embed which is a collection of utilities for embedding.</source>
          <target state="translated">如果你正在进行将perl作为一个库嵌入到其他应用程序中的实验,你可能会发现MakeMaker是不够的。你最好看看ExtUtils::Embed,这是一个用于嵌入的实用程序集。</target>
        </trans-unit>
        <trans-unit id="743cbf656ee357233b7747fd85635a26f54ae749" translate="yes" xml:space="preserve">
          <source>If you are running the tests from a emacs shell window, you may see failures in op/stat.t. Run &quot;dmake test-notty&quot; in that case.</source>
          <target state="translated">如果你是在 emacs shell 窗口中运行测试,你可能会在 op/stat.t 中看到失败的情况。</target>
        </trans-unit>
        <trans-unit id="eb661707e45d0fa6207ff65030fca0e35ac953eb" translate="yes" xml:space="preserve">
          <source>If you are running under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; (and if you aren't, why in the world aren't you?), you'll have to add some declarations to make it happy:</source>
          <target state="translated">如果您 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; （如果不是，那么，为什么呢？），您必须添加一些声明使其满意：</target>
        </trans-unit>
        <trans-unit id="0cc4f2e6ac843fbaf8224a05183a7220196cd15a" translate="yes" xml:space="preserve">
          <source>If you are running under &lt;code&gt;use strict&lt;/code&gt; (and if you aren't, why in the world aren't you?), you'll have to add some declarations to make it happy:</source>
          <target state="translated">如果您 &lt;code&gt;use strict&lt;/code&gt; （如果不是，那么，为什么呢？），您必须添加一些声明使其满意：</target>
        </trans-unit>
        <trans-unit id="767de91007776d2ff4bd67fc3c5e04ab7cebdfa3" translate="yes" xml:space="preserve">
          <source>If you are seeing spaces between the elements of your array when you print the array, you are probably interpolating the array in double quotes:</source>
          <target state="translated">如果你在打印数组时看到数组元素之间有空格,那么你可能是在用双引号插补数组。</target>
        </trans-unit>
        <trans-unit id="094ee1dd3418e11cdcfc777d87840149f066679d" translate="yes" xml:space="preserve">
          <source>If you are stuck with older Perls, you can do Unicode with the &lt;a href=&quot;Unicode::String&quot;&gt;Unicode::String&lt;/a&gt; module, and character conversions using the &lt;a href=&quot;Unicode::Map8&quot;&gt;Unicode::Map8&lt;/a&gt; and &lt;a href=&quot;Unicode::Map&quot;&gt;Unicode::Map&lt;/a&gt; modules. If you are using Japanese encodings, you might try using the jperl 5.005_03.</source>
          <target state="translated">如果您对较早的Perls&lt;a href=&quot;Unicode::Map8&quot;&gt;感到困惑&lt;/a&gt;，则可以使用&lt;a href=&quot;Unicode::String&quot;&gt;Unicode :: String&lt;/a&gt;模块执行Unicode ，并使用Unicode :: Map8和&lt;a href=&quot;Unicode::Map&quot;&gt;Unicode :: Map&lt;/a&gt;模块进行字符转换。如果使用日语编码，则可以尝试使用jperl 5.005_03。</target>
        </trans-unit>
        <trans-unit id="16bb00dc57c212c5f89aeced92e2138d70407e36" translate="yes" xml:space="preserve">
          <source>If you are stuck with older Perls, you can do Unicode with the &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::String&quot;&gt;Unicode::String&lt;/a&gt; module, and character conversions using the &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map8&quot;&gt;Unicode::Map8&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map&quot;&gt;Unicode::Map&lt;/a&gt; modules. If you are using Japanese encodings, you might try using the jperl 5.005_03.</source>
          <target state="translated">如果您对较早的Perls &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map8&quot;&gt;感到困惑&lt;/a&gt;，则可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::String&quot;&gt;Unicode :: String&lt;/a&gt;模块执行Unicode ，并使用Unicode :: Map8和&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map&quot;&gt;Unicode :: Map&lt;/a&gt;模块进行字符转换。如果使用日语编码，则可以尝试使用jperl 5.005_03。</target>
        </trans-unit>
        <trans-unit id="a4539f5703f218245f234df49c0b9e75bd10857f" translate="yes" xml:space="preserve">
          <source>If you are submitting a code patch there are several things that you can do to help the Perl 5 Porters accept your patch.</source>
          <target state="translated">如果你提交了一个代码补丁,你可以做一些事情来帮助 Perl 5 Porters 接受你的补丁。</target>
        </trans-unit>
        <trans-unit id="9d2ae6978c448ceee8a44a91cddc4545fb9e5c5e" translate="yes" xml:space="preserve">
          <source>If you are targetting an ARM device -- which currently includes the vast majority of phones and tablets -- you'll want to pass -Dcc=arm-unknown-nto-qnx8.0.0eabi-gcc to Configure. Alternatively, if you are targetting an x86 device, or using the simulator provided with the NDK, you should specify -Dcc=ntox86-gcc instead.</source>
          <target state="translated">如果你的目标是ARM设备--目前包括绝大多数的手机和平板电脑--你会希望通过-Dcc=arm-unknown-nto-qnx8.0.0eabi-gcc来配置。另外,如果你的目标是x86设备,或者使用NDK提供的模拟器,你应该指定-Dcc=ntox86-gcc来代替。</target>
        </trans-unit>
        <trans-unit id="562b5f2e0c42aed49d34015bad0780eaae56e849" translate="yes" xml:space="preserve">
          <source>If you are targetting x86 Android, you will have to change &lt;code&gt;$TARGETARCH-gcc&lt;/code&gt; to &lt;code&gt;i686-linux-android-gcc&lt;/code&gt;.</source>
          <target state="translated">如果你是86靶向的Android，你将不得不改变 &lt;code&gt;$TARGETARCH-gcc&lt;/code&gt; 到 &lt;code&gt;i686-linux-android-gcc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c81847f52511bd6e6f2d950ba6b028d46d7fda4c" translate="yes" xml:space="preserve">
          <source>If you are testing locales (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), there are helper functions in</source>
          <target state="translated">如果您正在测试语言环境（请参阅&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;），则在其中有辅助功能。</target>
        </trans-unit>
        <trans-unit id="638d5e69c0134925bf444f9f37d95ff5346d9353" translate="yes" xml:space="preserve">
          <source>If you are testing only once, the standard module &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt; exports the function &lt;code&gt;any&lt;/code&gt; for this purpose. It works by stopping once it finds the element. It's written in C for speed, and its Perl equivalent looks like this subroutine:</source>
          <target state="translated">如果仅测试一次，则标准模块&lt;a href=&quot;List::Util&quot;&gt;List :: Util&lt;/a&gt;为此导出 &lt;code&gt;any&lt;/code&gt; 功能。一旦找到元素，它便会停止工作。它是用C语言编写的，以提高速度，它的Perl等效项看起来像下面的子例程：</target>
        </trans-unit>
        <trans-unit id="1005d40b52c8fba9456ef2a3b1ec6cff90f7233f" translate="yes" xml:space="preserve">
          <source>If you are testing only once, the standard module &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; exports the function &lt;code&gt;first&lt;/code&gt; for this purpose. It works by stopping once it finds the element. It's written in C for speed, and its Perl equivalent looks like this subroutine:</source>
          <target state="translated">如果仅测试一次，则标准模块&lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt;为此 &lt;code&gt;first&lt;/code&gt; 导出功能。一旦找到元素，它便停止运行。它是用C语言编写的，以提高速度，它的Perl等效项类似于以下子例程：</target>
        </trans-unit>
        <trans-unit id="ee2ce6dbafcb9d4d548485293c0456fbed2a8877" translate="yes" xml:space="preserve">
          <source>If you are trying to use this instead of &lt;a href=&quot;#write-FILEHANDLE&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; to capture the output, you may find it easier to open a filehandle to a scalar (&lt;code&gt;open my $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt;) and write to that instead.</source>
          <target state="translated">如果您尝试使用它代替&lt;a href=&quot;#write-FILEHANDLE&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;来捕获输出，则可能会发现打开标量文件句柄（ &lt;code&gt;open my $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ）并写入它更容易。</target>
        </trans-unit>
        <trans-unit id="faf3c25ab12fb420d9fdf6ea0144e15dc43f0fe2" translate="yes" xml:space="preserve">
          <source>If you are trying to use this instead of &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; to capture the output, you may find it easier to open a filehandle to a scalar (&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ) and write to that instead.</source>
          <target state="translated">如果您试图使用它而不是 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 来捕获输出，则可能会发现打开标量文件句柄（ &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ）并写入它更容易。</target>
        </trans-unit>
        <trans-unit id="87f126d580b9d17eb9520e5adc6ebcd7b64cbce8" translate="yes" xml:space="preserve">
          <source>If you are trying to use this instead of &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; to capture the output, you may find it easier to open a filehandle to a scalar (&lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ) and write to that instead.</source>
          <target state="translated">如果您试图使用它而不是 &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 来捕获输出，则可能会发现打开标量文件句柄（ &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ）并写入它更容易。</target>
        </trans-unit>
        <trans-unit id="f0601abe3b8fe05fc06de5499fb9941a40db6bc0" translate="yes" xml:space="preserve">
          <source>If you are unable to send your report using &lt;b&gt;perlbug&lt;/b&gt; (most likely because your system doesn't have a way to send mail that perlbug recognizes), you may be able to use this tool to compose your report and save it to a file which you can then send to &lt;b&gt;perlbug@perl.org&lt;/b&gt; using your regular mail client.</source>
          <target state="translated">如果您无法使用&lt;b&gt;perlbug&lt;/b&gt;发送报告（很可能是因为系统无法发送perlbug可以识别的邮件），则可以使用此工具撰写报告并将其保存到文件中然后可以使用您的常规邮件客户端发送到&lt;b&gt;perlbug@perl.org&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="dd788f693f0912cff62f6c5004a3304201e94790" translate="yes" xml:space="preserve">
          <source>If you are used to working with a version of Perl prior to the introduction of lexically scoped warnings, or have code that uses both lexical warnings and &lt;code&gt;$^W&lt;/code&gt; , this section will describe how they interact.</source>
          <target state="translated">如果您习惯在引入词法范围警告之前使用过Perl版本，或者拥有同时使用词法警告和 &lt;code&gt;$^W&lt;/code&gt; ，本节将介绍它们如何交互。</target>
        </trans-unit>
        <trans-unit id="d4b0bb469edf0650ec3f65bb5c7e77e909873d27" translate="yes" xml:space="preserve">
          <source>If you are used to working with a version of Perl prior to the introduction of lexically scoped warnings, or have code that uses both lexical warnings and &lt;code&gt;$^W&lt;/code&gt;, this section will describe how they interact.</source>
          <target state="translated">如果您习惯在引入词法范围警告之前使用过Perl版本，或者拥有同时使用词法警告和 &lt;code&gt;$^W&lt;/code&gt; ，本节将介绍它们如何交互。</target>
        </trans-unit>
        <trans-unit id="08e74829ea9d71b80a5466e72595b5d826dd1692" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt; or one of its subclasses, you can call the &lt;code&gt;autoflush&lt;/code&gt; method to change the settings of the filehandle:</source>
          <target state="translated">如果使用的是&lt;a href=&quot;IO::Handle&quot;&gt;IO :: Handle&lt;/a&gt;或其子类之一，则可以调用 &lt;code&gt;autoflush&lt;/code&gt; 方法来更改filehandle的设置：</target>
        </trans-unit>
        <trans-unit id="19c883172a7bd8c24338f9dd7a287c030969e4c2" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt; or one of its subclasses, you can call the &lt;code&gt;autoflush&lt;/code&gt; method to change the settings of the filehandle:</source>
          <target state="translated">如果使用的是&lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt;或其子类之一，则可以调用 &lt;code&gt;autoflush&lt;/code&gt; 方法来更改filehandle的设置：</target>
        </trans-unit>
        <trans-unit id="66ca3a901cfd38d2b33b77415f58b3c173825a91" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;HePV&lt;/code&gt; to get values to pass to &lt;code&gt;newSVpvn()&lt;/code&gt; to create a new SV, you should consider using &lt;code&gt;newSVhek(HeKEY_hek(he))&lt;/code&gt; as it is more efficient.</source>
          <target state="translated">如果您使用 &lt;code&gt;HePV&lt;/code&gt; 获取值以传递给 &lt;code&gt;newSVpvn()&lt;/code&gt; 以创建新的SV，则应考虑使用 &lt;code&gt;newSVhek(HeKEY_hek(he))&lt;/code&gt; ,因为这样做效率更高。</target>
        </trans-unit>
        <trans-unit id="987d668924ef21e965c8815374cd5ece61317689" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;nanosleep&lt;/code&gt; for something else than mixing sleeping with signals, give some thought to whether Perl is the tool you should be using for work requiring nanosecond accuracies.</source>
          <target state="translated">如果您将 &lt;code&gt;nanosleep&lt;/code&gt; 用于混合信号和睡眠之外的其他用途，请考虑一下Perl是否是您需要用于纳秒精度工作的工具。</target>
        </trans-unit>
        <trans-unit id="ef7387a4fe9a4611da9e256c7be19f5e356ca6ea" translate="yes" xml:space="preserve">
          <source>If you are using ACLs, there is a pragma called &lt;a href=&quot;filetest&quot;&gt;&lt;code&gt;filetest&lt;/code&gt;&lt;/a&gt; that may produce more accurate results than the bare &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; mode bits. When under &lt;code&gt;use filetest 'access'&lt;/code&gt;, the above-mentioned filetests test whether the permission can(not) be granted using the &lt;a href=&quot;http://man.he.net/man2/access&quot;&gt;access(2)&lt;/a&gt; family of system calls. Also note that the &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;-X&lt;/code&gt; tests may under this pragma return true even if there are no execute permission bits set (nor any extra execute permission ACLs). This strangeness is due to the underlying system calls' definitions. Note also that, due to the implementation of &lt;code&gt;use filetest 'access'&lt;/code&gt;, the &lt;code&gt;_&lt;/code&gt; special filehandle won't cache the results of the file tests when this pragma is in effect. Read the documentation for the &lt;a href=&quot;filetest&quot;&gt;&lt;code&gt;filetest&lt;/code&gt;&lt;/a&gt; pragma for more information.</source>
          <target state="translated">如果使用的是ACL，则存在一个称为&lt;a href=&quot;filetest&quot;&gt; &lt;code&gt;filetest&lt;/code&gt; &lt;/a&gt;的编译指示，它可能会比裸&lt;a href=&quot;#stat-FILEHANDLE&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;模式位产生更准确的结果。在 &lt;code&gt;use filetest 'access'&lt;/code&gt; ，上述filetests测试是否可以使用&lt;a href=&quot;http://man.he.net/man2/access&quot;&gt;access（2）&lt;/a&gt;系列系统调用来授予权限。还要注意，即使没有设置执行许可位（也没有任何额外的执行许可ACL），在此编译指示下 &lt;code&gt;-x&lt;/code&gt; 和 &lt;code&gt;-X&lt;/code&gt; 测试也可能返回true。这种奇怪是由于底层系统调用的定义引起的。还要注意，由于 &lt;code&gt;use filetest 'access'&lt;/code&gt; 的实现， &lt;code&gt;_&lt;/code&gt; 当该编译指示生效时，特殊的文件句柄将不会缓存文件测试的结果。有关更多信息，请阅读文件&lt;a href=&quot;filetest&quot;&gt; &lt;code&gt;filetest&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="f9a45f762f42b66675541c22b88f50402f53057c" translate="yes" xml:space="preserve">
          <source>If you are using ACLs, there is a pragma called &lt;code&gt;filetest&lt;/code&gt; that may produce more accurate results than the bare stat() mode bits. When under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; the above-mentioned filetests test whether the permission can(not) be granted using the access(2) family of system calls. Also note that the &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; may under this pragma return true even if there are no execute permission bits set (nor any extra execute permission ACLs). This strangeness is due to the underlying system calls' definitions. Note also that, due to the implementation of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; , the &lt;code&gt;_&lt;/code&gt; special filehandle won't cache the results of the file tests when this pragma is in effect. Read the documentation for the &lt;code&gt;filetest&lt;/code&gt; pragma for more information.</source>
          <target state="translated">如果您使用的是ACL，则存在一个名为 &lt;code&gt;filetest&lt;/code&gt; 的编译指示，它可能会比裸stat（）模式位产生更准确的结果。在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; ，上述filetest测试是否可以使用access（2）系列系统调用来授予权限。还要注意，即使没有设置执行许可位（也没有任何额外的执行许可ACL），在该编译指示下 &lt;code&gt;-x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 仍可能返回true。这种奇怪是由于底层系统调用的定义引起的。还要注意，由于 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; 的实现， &lt;code&gt;_&lt;/code&gt; 当该编译指示生效时，特殊的文件句柄将不会缓存文件测试的结果。请阅读文档 &lt;code&gt;filetest&lt;/code&gt; 编译以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="536f259afd4833a386595561631d799b0872387d" translate="yes" xml:space="preserve">
          <source>If you are using ACLs, there is a pragma called &lt;code&gt;filetest&lt;/code&gt; that may produce more accurate results than the bare stat() mode bits. When under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; the above-mentioned filetests test whether the permission can(not) be granted using the access(2) family of system calls. Also note that the &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; may under this pragma return true even if there are no execute permission bits set (nor any extra execute permission ACLs). This strangeness is due to the underlying system calls' definitions. Note also that, due to the implementation of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; , the &lt;code&gt;_&lt;/code&gt; special filehandle won't cache the results of the file tests when this pragma is in effect. Read the documentation for the &lt;code&gt;filetest&lt;/code&gt; pragma for more information.</source>
          <target state="translated">如果您使用的是ACL，则存在一个名为 &lt;code&gt;filetest&lt;/code&gt; 的编译指示，它可能会比裸stat（）模式位产生更准确的结果。在 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; ，上述filetest测试是否可以使用access（2）系列系统调用来授予权限。还要注意，即使没有设置执行许可位（也没有任何额外的执行许可ACL），在该编译指示下 &lt;code&gt;-x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 仍可能返回true。这种奇怪是由于底层系统调用的定义引起的。还要注意，由于 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; 的实现， &lt;code&gt;_&lt;/code&gt; 当该编译指示生效时，特殊的文件句柄将不会缓存文件测试的结果。请阅读文档 &lt;code&gt;filetest&lt;/code&gt; 编译以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="4cb0cc5912b1065f25576985628bc261176328a3" translate="yes" xml:space="preserve">
          <source>If you are using MacOS, the same concerns apply. MacPerl (for Classic environments) comes with a simple editor. Popular external editors are BBEdit ( &lt;a href=&quot;http://www.barebones.com/products/bbedit/&quot;&gt;http://www.barebones.com/products/bbedit/&lt;/a&gt; ) or Alpha ( &lt;a href=&quot;http://www.his.com/~jguyer/Alpha/Alpha8.html&quot;&gt;http://www.his.com/~jguyer/Alpha/Alpha8.html&lt;/a&gt; ). MacOS X users can use Unix editors as well.</source>
          <target state="translated">如果您使用的是MacOS，则存在同样的问题。MacPerl（用于经典环境）带有一个简单的编辑器。流行的外部编辑器是BBEdit（&lt;a href=&quot;http://www.barebones.com/products/bbedit/&quot;&gt;http://www.barebones.com/products/bbedit/&lt;/a&gt;）或Alpha（&lt;a href=&quot;http://www.his.com/~jguyer/Alpha/Alpha8.html&quot;&gt;http://www.his.com/~jguyer/Alpha/Alpha8.html&lt;/a&gt;）。MacOS X用户也可以使用Unix编辑器。</target>
        </trans-unit>
        <trans-unit id="6089a0839b7337d6b244906202548f79ff85a178" translate="yes" xml:space="preserve">
          <source>If you are using Plack (which most frameworks do), then &lt;a href=&quot;Plack::Middleware::Rewrite&quot;&gt;Plack::Middleware::Rewrite&lt;/a&gt; is worth looking at if you are migrating from Apache or have URL's you want to always redirect.</source>
          <target state="translated">如果您正在使用Plack（大多数框架都在使用Plack），那么从Apache迁移或拥有要始终重定向的URL的情况下，&lt;a href=&quot;Plack::Middleware::Rewrite&quot;&gt;Plack :: Middleware :: Rewrite&lt;/a&gt;值得一看。</target>
        </trans-unit>
        <trans-unit id="6e4548a312b12b5507979ee1df1e5c700b717005" translate="yes" xml:space="preserve">
          <source>If you are using Plack (which most frameworks do), then &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Rewrite&quot;&gt;Plack::Middleware::Rewrite&lt;/a&gt; is worth looking at if you are migrating from Apache or have URL's you want to always redirect.</source>
          <target state="translated">如果您正在使用Plack（大多数框架都在使用Plack），那么从Apache迁移或拥有要始终重定向的URL的情况下，&lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Rewrite&quot;&gt;Plack :: Middleware :: Rewrite&lt;/a&gt;值得一看。</target>
        </trans-unit>
        <trans-unit id="88dc2855988852eaabc5467d99d4705c5f78e44c" translate="yes" xml:space="preserve">
          <source>If you are using Term::ANSIColor in a console command, consider supporting the CLICOLOR standard. See &lt;a href=&quot;#Supporting-CLICOLOR&quot;&gt;&quot;Supporting CLICOLOR&quot;&lt;/a&gt; for more information.</source>
          <target state="translated">如果在控制台命令中使用Term :: ANSIColor，请考虑支持CLICOLOR标准。有关更多信息，请参见&lt;a href=&quot;#Supporting-CLICOLOR&quot;&gt;&amp;ldquo;支持CLICOLOR&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1b08c775dc3592188f9dd4afa0190ccbb806664" translate="yes" xml:space="preserve">
          <source>If you are using Windows, you can use any editor that lets you work with plain text, such as NotePad or WordPad. Word processors, such as Microsoft Word or WordPerfect, typically do not work since they insert all sorts of behind-the-scenes information, although some allow you to save files as &quot;Text Only&quot;. You can also download text editors designed specifically for programming, such as Textpad ( &lt;a href=&quot;http://www.textpad.com/&quot;&gt;http://www.textpad.com/&lt;/a&gt; ) and UltraEdit ( &lt;a href=&quot;http://www.ultraedit.com/&quot;&gt;http://www.ultraedit.com/&lt;/a&gt; ), among others.</source>
          <target state="translated">如果使用的是Windows，则可以使用任何可用于处理纯文本的编辑器，例如NotePad或WordPad。文字处理器（例如Microsoft Word或WordPerfect）通常无法工作，因为它们会插入各种幕后信息，尽管有些处理器允许您将文件另存为&amp;ldquo;纯文本&amp;rdquo;。您还可以下载专门为编程设计的文本编辑器，例如Textpad（&lt;a href=&quot;http://www.textpad.com/&quot;&gt;http://www.textpad.com/&lt;/a&gt;）和UltraEdit（&lt;a href=&quot;http://www.ultraedit.com/&quot;&gt;http://www.ultraedit.com/&lt;/a&gt;）等。</target>
        </trans-unit>
        <trans-unit id="6e650787f6167c83d416119f9b787ce543fc56ec" translate="yes" xml:space="preserve">
          <source>If you are using Windows, you can use any editor that lets you work with plain text, such as NotePad or WordPad. Word processors, such as Microsoft Word or WordPerfect, typically do not work since they insert all sorts of behind-the-scenes information, although some allow you to save files as &quot;Text Only&quot;. You can also download text editors designed specifically for programming, such as Textpad ( &lt;a href=&quot;https://www.textpad.com/&quot;&gt;http://www.textpad.com/&lt;/a&gt; ) and UltraEdit ( &lt;a href=&quot;http://www.ultraedit.com/&quot;&gt;http://www.ultraedit.com/&lt;/a&gt; ), among others.</source>
          <target state="translated">如果使用Windows，则可以使用任何可用于处理纯文本的编辑器，例如NotePad或WordPad。文字处理器（例如Microsoft Word或WordPerfect）通常无法工作，因为它们会插入各种幕后信息，尽管有些处理器允许您将文件另存为&amp;ldquo;纯文本&amp;rdquo;。您还可以下载专门为编程设计的文本编辑器，例如Textpad（&lt;a href=&quot;https://www.textpad.com/&quot;&gt;http://www.textpad.com/&lt;/a&gt;）和UltraEdit（&lt;a href=&quot;http://www.ultraedit.com/&quot;&gt;http://www.ultraedit.com/&lt;/a&gt;）等。</target>
        </trans-unit>
        <trans-unit id="42b14c31c340803d7d1a8907e87c3b623cebca0d" translate="yes" xml:space="preserve">
          <source>If you are using a SOCKS firewall, you will need to compile perl and link it with the SOCKS library. This is what is normally called a 'socksified' perl. With this executable you will be able to connect to servers outside the firewall as if it were not there.</source>
          <target state="translated">如果你使用的是 SOCKS 防火墙,你需要编译 perl 并将其与 SOCKS 库链接。这就是通常所说的 &quot;socksified &quot;perl。有了这个可执行文件,你就可以连接到防火墙之外的服务器,就像它不存在一样。</target>
        </trans-unit>
        <trans-unit id="52dddb8880620f072f3a58161e2e257e19923fa6" translate="yes" xml:space="preserve">
          <source>If you are using a module which returns something special on failure, then you can manually create hints for each of the desired subroutines. Once the hints are specified, they are available for all files and modules loaded thereafter, thus you can move this work into a module and it will still work.</source>
          <target state="translated">如果你使用的模块在失败时返回一些特殊的东西,那么你可以为每个所需的子程序手动创建提示。一旦提示被指定,它们就可以用于此后加载的所有文件和模块,因此你可以将这项工作移到一个模块中,它仍然可以工作。</target>
        </trans-unit>
        <trans-unit id="29c561106308348f3755c72923d0a263a80ca5d3" translate="yes" xml:space="preserve">
          <source>If you are using a regex here, you have to use the quotes as shown or it won't work. Also note that regex handling is tricky even for the experienced. Use this feature with caution.</source>
          <target state="translated">如果你在这里使用的是regex,你必须使用如图所示的引号,否则就无法使用。还要注意的是,即使是有经验的人,对regex的处理也是很棘手的。请谨慎使用这个功能。</target>
        </trans-unit>
        <trans-unit id="5a12a925a69a2c6041232d382cd6683ae36d2da6" translate="yes" xml:space="preserve">
          <source>If you are using a version of Perl earlier than 5.004_57, the tied array interface is quite limited. In the example script above &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; or determining the array length will not work with a tied array.</source>
          <target state="translated">如果使用的Perl版本早于5.004_57，则绑定数组接口非常有限。在 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 或确定数组长度的示例脚本中，对绑定数组不起作用。</target>
        </trans-unit>
        <trans-unit id="5e370f11050262a4d86dce72f35bfab79335c669" translate="yes" xml:space="preserve">
          <source>If you are using a version of Perl earlier than 5.004_57, the tied array interface is quite limited. In the example script above &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;shift&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt; or determining the array length will not work with a tied array.</source>
          <target state="translated">如果使用的Perl版本早于5.004_57，则绑定数组接口非常有限。在 &lt;code&gt;push&lt;/code&gt; ， &lt;code&gt;pop&lt;/code&gt; ， &lt;code&gt;shift&lt;/code&gt; ， &lt;code&gt;unshift&lt;/code&gt; 或确定数组长度的示例脚本中，对绑定数组不起作用。</target>
        </trans-unit>
        <trans-unit id="02abd4a44d56e10cd1bbe5fedc62225b1b539860" translate="yes" xml:space="preserve">
          <source>If you are using any code that requires the execution of the global destruction phase for clean up (e.g., removing temp files), then do not use detached threads, but rather join all threads before exiting the program.</source>
          <target state="translated">如果你正在使用任何需要执行全局销毁阶段的代码进行清理(例如,删除临时文件),那么不要使用分离线程,而是在退出程序之前加入所有线程。</target>
        </trans-unit>
        <trans-unit id="360a39abe6795afd63327f3e470a092ad595cbfe" translate="yes" xml:space="preserve">
          <source>If you are using cpan-mac, just drop the folder on the &lt;b&gt;installme&lt;/b&gt; droplet, and use the module.</source>
          <target state="translated">如果使用的是cpan-mac，只需将文件夹放在&lt;b&gt;installme小&lt;/b&gt;滴上，然后使用该模块。</target>
        </trans-unit>
        <trans-unit id="1fc1c37b5a3d2067860bd9ba4aa2038972693c34" translate="yes" xml:space="preserve">
          <source>If you are using gcc, just</source>
          <target state="translated">如果你使用的是gcc,只要</target>
        </trans-unit>
        <trans-unit id="8fd5d7695f8aa3649f7196f528604d5d3ae20e06" translate="yes" xml:space="preserve">
          <source>If you are using gcc, you would need to use -mcpu=v9 -m64 instead. This option is not yet supported as of gcc 2.95.2; from install/SPECIFIC in that release:</source>
          <target state="translated">如果你使用的是gcc,你需要使用-mcpu=v9 -m64来代替。这个选项从gcc 2.95.2开始就不支持了;从该版本的install/SPECIFIC开始。</target>
        </trans-unit>
        <trans-unit id="43b374ff761647040bfef238a2f344855f86b957" translate="yes" xml:space="preserve">
          <source>If you are using locale purely for its characteristics related to things like its numeric and time formatting (and not &lt;code&gt;LC_CTYPE&lt;/code&gt; ), consider using a restricted form of the locale pragma (see &lt;a href=&quot;perllocale#The-%22use-locale%22-pragma&quot;&gt;The use locale pragma in perllocale&lt;/a&gt;) like &quot;&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; &quot;.</source>
          <target state="translated">如果纯粹出于与数字和时间格式之类的东西相关的特性而使用语言环境（而不是 &lt;code&gt;LC_CTYPE&lt;/code&gt; ），请考虑使用语言环境编译指示的受限形式（请参阅&lt;a href=&quot;perllocale#The-%22use-locale%22-pragma&quot;&gt;在perllocale中使用语言环境编译指示&lt;/a&gt;），例如&amp;ldquo; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3f4713ad5807b5f7826ec2dd53e64e4312c481e4" translate="yes" xml:space="preserve">
          <source>If you are using locale purely for its characteristics related to things like its numeric and time formatting (and not &lt;code&gt;LC_CTYPE&lt;/code&gt;), consider using a restricted form of the locale pragma (see &lt;a href=&quot;perllocale#The-%22use-locale%22-pragma&quot;&gt;&quot;The &quot;use locale&quot; pragma&quot; in perllocale&lt;/a&gt;) like &quot;&lt;code&gt;use locale ':not_characters'&lt;/code&gt;&quot;.</source>
          <target state="translated">如果纯粹出于其与数字和时间格式之类的东西相关的特性而使用语言环境（而不是 &lt;code&gt;LC_CTYPE&lt;/code&gt; ），请考虑使用语言环境编译指示的受限形式（请参阅&lt;a href=&quot;perllocale#The-%22use-locale%22-pragma&quot;&gt;perllocale中的&amp;ldquo;使用语言环境编译指示&amp;rdquo;&lt;/a&gt;），例如&amp;ldquo; &lt;code&gt;use locale ':not_characters'&lt;/code&gt; &amp;ldquo;。</target>
        </trans-unit>
        <trans-unit id="bf7e18738b21f2b01d05483723778a511f7e8e06" translate="yes" xml:space="preserve">
          <source>If you are using the 'make' directly, it is the GNU make from the SDKs, and it will invoke the right make commands for the Windows emulator build and the Arm target builds ('thumb' by default) as necessary.</source>
          <target state="translated">如果你直接使用'make',那就是SDK中的GNU make,它会根据需要为Windows模拟器构建和Arm目标构建(默认为'thumb')调用正确的make命令。</target>
        </trans-unit>
        <trans-unit id="63c7cadf9ebf06d221687f1101781684817f90c8" translate="yes" xml:space="preserve">
          <source>If you are using the DB_RECNO interface and you intend making use of &lt;code&gt;bval&lt;/code&gt; , you should check out &lt;a href=&quot;#The-'bval'-Option&quot;&gt;The 'bval' Option&lt;/a&gt;.</source>
          <target state="translated">如果您正在使用DB_RECNO接口，并且打算使用 &lt;code&gt;bval&lt;/code&gt; ，则应该签出&lt;a href=&quot;#The-'bval'-Option&quot;&gt;'bval'Option&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f6185500a12d4aa7861d0d23b58da2516585e5a" translate="yes" xml:space="preserve">
          <source>If you are using the DB_RECNO interface and you intend making use of &lt;code&gt;bval&lt;/code&gt;, you should check out &lt;a href=&quot;#The-%27bval%27-Option&quot;&gt;&quot;The 'bval' Option&quot;&lt;/a&gt;.</source>
          <target state="translated">如果您正在使用DB_RECNO接口，并且打算使用 &lt;code&gt;bval&lt;/code&gt; ，那么应该签出&lt;a href=&quot;#The-%27bval%27-Option&quot;&gt;&amp;ldquo;'bval'Option&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e34b95c988ef9ff5f011e4473a6842bbc8f305e" translate="yes" xml:space="preserve">
          <source>If you are using the Visual C compiler, you can get the C runtime's command line wildcard expansion built into perl binary. The resulting binary will always expand unquoted command lines, which may not be what you want if you use a shell that does that for you. The expansion done is also somewhat less powerful than the approach suggested above.</source>
          <target state="translated">如果你使用的是Visual C编译器,你可以在perl二进制中内置C运行时的命令行通配符扩展。由此产生的二进制文件总是会对未引用的命令行进行扩展,如果你使用shell为你做扩展,这可能不是你想要的。所做的扩展也比上面建议的方法要差一些。</target>
        </trans-unit>
        <trans-unit id="7d685e73a12ad96dde7946d5ecb4aacf9b0497e1" translate="yes" xml:space="preserve">
          <source>If you are using the constant interface, be sure to include this code before you use any color constants (such as at the very top of your script), since this environment variable is only honored the first time a color constant is seen.</source>
          <target state="translated">如果你使用常量接口,请确保在你使用任何颜色常量之前包含这段代码(比如在你的脚本的顶部),因为这个环境变量只有在第一次看到颜色常量时才会被尊重。</target>
        </trans-unit>
        <trans-unit id="b64d320b887e6639115cc4ac113f85e3f1804107" translate="yes" xml:space="preserve">
          <source>If you are using this in non-legacy code you may need to reconsider the course of your life, maybe a hermitage would suite you?</source>
          <target state="translated">如果你在非传统的代码中使用这个,你可能需要重新考虑你的生活方向,也许隐居会适合你?</target>
        </trans-unit>
        <trans-unit id="a368c00c8ef926e64658830003081d5eb361bb8d" translate="yes" xml:space="preserve">
          <source>If you are using zlib 1.2.0 or older, &lt;code&gt;zlibCompileFlags&lt;/code&gt; will return 0.</source>
          <target state="translated">如果您使用的是zlib 1.2.0或更早版本，则 &lt;code&gt;zlibCompileFlags&lt;/code&gt; 将返回0。</target>
        </trans-unit>
        <trans-unit id="9d19a794a39cad7420e5c34d0bb89a7b77ddba40" translate="yes" xml:space="preserve">
          <source>If you are willing to accept all the defaults run Configure with &lt;b&gt;-de&lt;/b&gt;. However, several useful customizations are available.</source>
          <target state="translated">如果您愿意接受所有默认设置，请运行Configure with &lt;b&gt;-de&lt;/b&gt;。但是，可以使用几种有用的自定义。</target>
        </trans-unit>
        <trans-unit id="fd5b1c2924a349d7291d8ad147e3c28043609419" translate="yes" xml:space="preserve">
          <source>If you are working with a git clone of the Perl repository, you will want to create a branch for your changes. This will make creating a proper patch much simpler. See the &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">如果您正在使用Perl存储库的git克隆，则需要为更改创建一个分支。这将使创建适当的补丁程序变得更加简单。有关如何执行此&lt;a href=&quot;perlgit&quot;&gt;操作&lt;/a&gt;的详细信息，请参见perlgit。</target>
        </trans-unit>
        <trans-unit id="d3a5c5d66921962ee5d2f131da55a853da5b0930" translate="yes" xml:space="preserve">
          <source>If you are working with data you know to be valid, you can speed your code up by using the &quot;nocheck&quot; variants, &lt;code&gt;timelocal_nocheck()&lt;/code&gt; and &lt;code&gt;timegm_nocheck()&lt;/code&gt; . These variants must be explicitly imported.</source>
          <target state="translated">如果使用已知有效的数据，则可以使用&amp;ldquo; nocheck&amp;rdquo;变体 &lt;code&gt;timelocal_nocheck()&lt;/code&gt; 和 &lt;code&gt;timegm_nocheck()&lt;/code&gt; 来加快代码的速度。这些变体必须显式导入。</target>
        </trans-unit>
        <trans-unit id="44340ebb8cf0e2382c2ca3711523d41bd143a85f" translate="yes" xml:space="preserve">
          <source>If you are working with data you know to be valid, you can speed your code up by using the &quot;nocheck&quot; variants, &lt;code&gt;timelocal_nocheck()&lt;/code&gt; and &lt;code&gt;timegm_nocheck()&lt;/code&gt;. These variants must be explicitly imported.</source>
          <target state="translated">如果使用已知有效的数据，则可以使用&amp;ldquo; nocheck&amp;rdquo;变体 &lt;code&gt;timelocal_nocheck()&lt;/code&gt; 和 &lt;code&gt;timegm_nocheck()&lt;/code&gt; 来加快代码的速度。这些变体必须显式导入。</target>
        </trans-unit>
        <trans-unit id="a9fdba02c2ad23e42f49d14ef3350c451024e80f" translate="yes" xml:space="preserve">
          <source>If you are writing a module to expand an already existing set of modules, please coordinate with the author of the package. It helps if you follow the same naming scheme and module interaction scheme as the original author.</source>
          <target state="translated">如果你写的模块是为了扩展已有的模块集,请与包的作者协调。如果您遵循与原作者相同的命名方案和模块交互方案,会有帮助。</target>
        </trans-unit>
        <trans-unit id="1cd2c8d5447831e253b224430edc3070841bc27c" translate="yes" xml:space="preserve">
          <source>If you are writing a package that &lt;code&gt;AUTOLOAD&lt;/code&gt; s, consider forcing an &lt;code&gt;AUTOLOAD&lt;/code&gt; for any constants explicitly imported by other packages or which are usually used when your package is &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;d.</source>
          <target state="translated">如果要编写一个包含 &lt;code&gt;AUTOLOAD&lt;/code&gt; 的软件包，请考虑对其他软件包明确导入的任何常量或在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; d 的软件包中通常使用的常量强制使用 &lt;code&gt;AUTOLOAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="008854f6c49a92df108a1a38fd8f1f0c1b757eb6" translate="yes" xml:space="preserve">
          <source>If you are writing a package that &lt;code&gt;AUTOLOAD&lt;/code&gt;s, consider forcing an &lt;code&gt;AUTOLOAD&lt;/code&gt; for any constants explicitly imported by other packages or which are usually used when your package is &lt;code&gt;use&lt;/code&gt;d.</source>
          <target state="translated">如果要编写一个包含 &lt;code&gt;AUTOLOAD&lt;/code&gt; 的包，请考虑对其他包显式导入的任何常量或在 &lt;code&gt;use&lt;/code&gt; d的包中通常使用的常量强制使用 &lt;code&gt;AUTOLOAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5966f6f48bbef92de0797373659162ca479de0d" translate="yes" xml:space="preserve">
          <source>If you are writing new code, your first port of call should be one of the new &lt;code&gt;IO::Compress&lt;/code&gt; or &lt;code&gt;IO::Uncompress&lt;/code&gt; modules.</source>
          <target state="translated">如果要编写新代码，则第一个调用端口应该是新的 &lt;code&gt;IO::Compress&lt;/code&gt; 或 &lt;code&gt;IO::Uncompress&lt;/code&gt; 模块之一。</target>
        </trans-unit>
        <trans-unit id="0d5955743a0fa060d529640f937e917d974a0fd9" translate="yes" xml:space="preserve">
          <source>If you ask for nothing in particular, you'll be asking for &lt;code&gt;less
'please'&lt;/code&gt; .</source>
          <target state="translated">如果您不要求任何特别的东西，您将要求 &lt;code&gt;less 'please'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8027e6b734038f8b5eea431be412179b0c1aa993" translate="yes" xml:space="preserve">
          <source>If you ask for nothing in particular, you'll be asking for &lt;code&gt;less 'please'&lt;/code&gt;.</source>
          <target state="translated">如果您不要求任何特别要求，您将要求 &lt;code&gt;less 'please'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d232183f686226b9e4d9f0a9749bb4ab75350724" translate="yes" xml:space="preserve">
          <source>If you ask it to unmemoize a function that was never memoized, it croaks.</source>
          <target state="translated">如果你要求它取消记忆一个从未被记忆的函数,它就会呱呱叫。</target>
        </trans-unit>
        <trans-unit id="5ac398bf0535c0d2bb95ebfd6fd6655ce0bd6b20" translate="yes" xml:space="preserve">
          <source>If you ask to override your chdir() built-in function,</source>
          <target state="translated">如果你要求覆盖你的chdir()内置函数。</target>
        </trans-unit>
        <trans-unit id="aae82346550e5f30641b00cfb651b5e652048f2e" translate="yes" xml:space="preserve">
          <source>If you attempt to compile Perl with (POSIX) threads on an 11.X system and also link in the GDBM library, then Perl will immediately core dump when it starts up. The only workaround at this point is to relink the GDBM library under 11.X, then relink it into Perl.</source>
          <target state="translated">如果你试图在11.X系统上用(POSIX)线程编译Perl,并同时链接到GDBM库中,那么Perl在启动时就会立即进行core dump。这时唯一的变通办法就是在11.X下重新链接GDBM库,然后再重新链接到Perl中。</target>
        </trans-unit>
        <trans-unit id="372756b443de4017a28427029bf0d506d7081a2a" translate="yes" xml:space="preserve">
          <source>If you believe the scalar comes back as UTF-8, you will most likely want the UTF8 flag restored:</source>
          <target state="translated">如果你认为标量返回的是UTF-8,你很可能希望恢复UTF8标志。</target>
        </trans-unit>
        <trans-unit id="1489e0cb25a613554ca1fb1509eb4766e09aaf06" translate="yes" xml:space="preserve">
          <source>If you believe you have found a security vulnerability in Perl, please email perl5-security-report@perl.org with details. This points to a closed subscription, unarchived mailing list. Please only use this address for security issues in the Perl core, not for modules independently distributed on CPAN.</source>
          <target state="translated">如果您认为您发现了Perl中的安全漏洞,请发邮件至 perl5-security-report@perl.org 提供详细信息。这指向的是一个封闭的订阅、未存档的邮件列表。请只用这个地址来处理Perl核心中的安全问题,而不是用于CPAN上独立发布的模块。</target>
        </trans-unit>
        <trans-unit id="74dfa21f751ce3fabe2deb1f0f641c590253ad7e" translate="yes" xml:space="preserve">
          <source>If you believe you have found a security vulnerability in Perl, please email the details to perl5-security-report@perl.org. This creates a new Request Tracker ticket in a special queue which isn't initially publicly accessible. The email will also be copied to a closed subscription unarchived mailing list which includes all the core committers, who will be able to help assess the impact of issues, figure out a resolution, and help co-ordinate the release of patches to mitigate or fix the problem across all platforms on which Perl is supported. Please only use this address for security issues in the Perl core, not for modules independently distributed on CPAN.</source>
          <target state="translated">如果你认为你在Perl中发现了一个安全漏洞,请将详细情况发送电子邮件至 perl5-security-report@perl.org。这样就会在一个特殊的队列中创建一个新的请求跟踪票据,这个票据最初是不公开的。这封邮件也会被复制到一个封闭式订阅的未存档邮件列表中,其中包括所有的核心提交者,他们将能够帮助评估问题的影响,找出解决方案,并帮助协调发布补丁,以减轻或修复所有支持 Perl 的平台上的问题。请只用这个地址来处理Perl核心的安全问题,而不要用在CPAN上独立发布的模块上。</target>
        </trans-unit>
        <trans-unit id="2508e4352c00aad2e5cda3b21b798f7f8735a139" translate="yes" xml:space="preserve">
          <source>If you build with Visual C++ 2013 then three tests currently may fail with Daylight Saving Time related problems:</source>
          <target state="translated">如果你使用Visual C++2013进行构建,那么目前有三个测试可能会因为夏令时相关问题而失败。</target>
        </trans-unit>
        <trans-unit id="a29ad197e59c85308f30e04c723a79c6188595db" translate="yes" xml:space="preserve">
          <source>If you build with Visual C++ 2015 or later then</source>
          <target state="translated">如果你用Visual C++2015或更高版本构建,那么</target>
        </trans-unit>
        <trans-unit id="fc747a2308602b12226c600429d56710358ba8a4" translate="yes" xml:space="preserve">
          <source>If you build with certain versions (e.g. 4.8.1) of gcc from www.mingw.org then</source>
          <target state="translated">如果你使用某些版本的gcc(例如4.8.1)从www.mingw.org,那么</target>
        </trans-unit>
        <trans-unit id="5d082c0ec07ad4429dea09b4d3b6034a0edf4cf9" translate="yes" xml:space="preserve">
          <source>If you built perl with dynamic loading capability then that would also be the way to build XS based extensions. However, if you built perl with the default static linking you can still build XS based extensions for OS/390 but you will need to follow the instructions in ExtUtils::MakeMaker for building statically linked perl binaries. In the simplest configurations building a static perl + XS extension boils down to:</source>
          <target state="translated">如果你建立的perl具有动态加载能力,那么这也是建立基于XS的扩展的方法。然而,如果你用默认的静态链接来构建perl,你仍然可以为OS/390构建基于XS的扩展,但是你需要按照ExtUtils::MakeMaker中的说明来构建静态链接的perl二进制文件。在最简单的配置中,构建静态perl+XS扩展归结为以下几点。</target>
        </trans-unit>
        <trans-unit id="fccb9cfffea038156e1e9bf29f1e74a06b7c692d" translate="yes" xml:space="preserve">
          <source>If you built perl with dynamic loading capability then that would also be the way to build xs based extensions. However, if you built perl with the default static linking you can still build xs based extensions for OS/390 but you will need to follow the instructions in ExtUtils::MakeMaker for building statically linked perl binaries. In the simplest configurations building a static perl + xs extension boils down to:</source>
          <target state="translated">如果你建立的perl具有动态加载功能,那么这也是建立基于xs的扩展的方法。然而,如果你用默认的静态链接来构建perl,你仍然可以为OS/390构建基于xs的扩展,但是你需要按照ExtUtils::MakeMaker中的说明来构建静态链接的perl二进制文件。在最简单的配置中,构建一个静态的perl+xs扩展归结为。</target>
        </trans-unit>
        <trans-unit id="b4bbe3ec8c3dbb9079b54edeba88cab20e6c6b9a" translate="yes" xml:space="preserve">
          <source>If you call $lh-&amp;gt;maketext(</source>
          <target state="translated">如果调用$ lh-&amp;gt; maketext（</target>
        </trans-unit>
        <trans-unit id="b2b245ecec2ba731bc1217986ab8fe3ce3832fb6" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;plan()&lt;/code&gt; , don't call any of the other methods below.</source>
          <target state="translated">如果调用 &lt;code&gt;plan()&lt;/code&gt; ，则不要调用下面的任何其他方法。</target>
        </trans-unit>
        <trans-unit id="1fcdeca5cd1457b673de047212c964254182c124" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;plan()&lt;/code&gt;, don't call any of the other methods below.</source>
          <target state="translated">如果调用 &lt;code&gt;plan()&lt;/code&gt; ，则不要调用下面的任何其他方法。</target>
        </trans-unit>
        <trans-unit id="f29b01f558f5cc8e37b47ab816256a32df3eb207" translate="yes" xml:space="preserve">
          <source>If you call a method that doesn't exist in a class, Perl will throw an error. However, if that class or any of its parent classes defines an &lt;code&gt;AUTOLOAD&lt;/code&gt; method, that &lt;code&gt;AUTOLOAD&lt;/code&gt; method is called instead.</source>
          <target state="translated">如果您调用的类中不存在的方法，Perl将抛出错误。但是，如果该类或其任何父类定义了 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法，则将调用该 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="945646515b442a128e465225a1d325a7ca2f3625" translate="yes" xml:space="preserve">
          <source>If you call a subroutine that is undefined, you would ordinarily get an immediate, fatal error complaining that the subroutine doesn't exist. (Likewise for subroutines being used as methods, when the method doesn't exist in any base class of the class's package.) However, if an &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is defined in the package or packages used to locate the original subroutine, then that &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is called with the arguments that would have been passed to the original subroutine. The fully qualified name of the original subroutine magically appears in the global $AUTOLOAD variable of the same package as the &lt;code&gt;AUTOLOAD&lt;/code&gt; routine. The name is not passed as an ordinary argument because, er, well, just because, that's why. (As an exception, a method call to a nonexistent &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;unimport&lt;/code&gt; method is just skipped instead. Also, if the AUTOLOAD subroutine is an XSUB, there are other ways to retrieve the subroutine name. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;Autoloading with XSUBs in perlguts&lt;/a&gt; for details.)</source>
          <target state="translated">如果调用未定义的子例程，通常会收到一个立即致命的错误，抱怨该子例程不存在。 （同样，对于用作方法的子例程，如果该方法在该类的程序包的任何基类中都不存在。）但是，如果在一个或多个用于定义原始子程序的程序包中定义了 &lt;code&gt;AUTOLOAD&lt;/code&gt; 子程序，则该 &lt;code&gt;AUTOLOAD&lt;/code&gt; 子程序使用将传递给原始子例程的参数调用。原来的子程序的全名奇迹般地出现在同一包的全球$ AUTOLOAD变量作为 &lt;code&gt;AUTOLOAD&lt;/code&gt; 常规。该名称未作为普通参数传递，因为，嗯，正因为如此。（通常，跳过对不存在的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;unimport&lt;/code&gt; 方法的方法调用。此外，如果AUTOLOAD子例程是XSUB，则还有其他方法可以检索该子例程的名称。有关详细信息，请参见&lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;在perlguts中使用XSUBs自动加载&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="ae93390d7689eae59da77f05524628edc8a8e772" translate="yes" xml:space="preserve">
          <source>If you call a subroutine that is undefined, you would ordinarily get an immediate, fatal error complaining that the subroutine doesn't exist. (Likewise for subroutines being used as methods, when the method doesn't exist in any base class of the class's package.) However, if an &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is defined in the package or packages used to locate the original subroutine, then that &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is called with the arguments that would have been passed to the original subroutine. The fully qualified name of the original subroutine magically appears in the global $AUTOLOAD variable of the same package as the &lt;code&gt;AUTOLOAD&lt;/code&gt; routine. The name is not passed as an ordinary argument because, er, well, just because, that's why. (As an exception, a method call to a nonexistent &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;unimport&lt;/code&gt; method is just skipped instead. Also, if the AUTOLOAD subroutine is an XSUB, there are other ways to retrieve the subroutine name. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;&quot;Autoloading with XSUBs&quot; in perlguts&lt;/a&gt; for details.)</source>
          <target state="translated">如果调用未定义的子例程，通常会收到一个立即致命的错误，抱怨该子例程不存在。（同样，对于用作方法的子例程，如果该方法在该类的程序包的任何基类中都不存在。）但是，如果在一个或多个用于定义原始子程序的程序包中定义了 &lt;code&gt;AUTOLOAD&lt;/code&gt; 子程序，则该 &lt;code&gt;AUTOLOAD&lt;/code&gt; 子程序使用将传递给原始子例程的参数调用。原来的子程序的全名奇迹般地出现在同一包的全球$ AUTOLOAD变量作为 &lt;code&gt;AUTOLOAD&lt;/code&gt; 常规。该名称未作为普通参数传递，因为，嗯，正因为如此。（作为例外，仅跳过对不存在的 &lt;code&gt;import&lt;/code&gt; 或 &lt;code&gt;unimport&lt;/code&gt; 导入方法的方法调用。此外，如果AUTOLOAD子例程是XSUB，则还有其他方法来检索子例程名称。有关详细信息，请参见&lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;perlguts中的&amp;ldquo;使用XSUBs自动加载&amp;rdquo;。&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="a71cdebace5c6abb01b81af0b4383d9f3787c035" translate="yes" xml:space="preserve">
          <source>If you can arrange for everyone to deal with this through references, it's cleaner code, although not so nice to look at. Here's a function that takes two array references as arguments, returning the two array elements in order of how many elements they have in them:</source>
          <target state="translated">如果能安排大家通过引用来处理,虽然不那么好看,但代码更干净。这里有一个函数,它将两个数组引用作为参数,按照两个数组元素中元素的多少顺序返回。</target>
        </trans-unit>
        <trans-unit id="3cb0b0acb5a45f37eacb24751a1ec1aefb74d989" translate="yes" xml:space="preserve">
          <source>If you can avoid it, don't, or if you can use a templating system, such as &lt;a href=&quot;Text::Template&quot;&gt;Text::Template&lt;/a&gt; or &lt;a href=&quot;template&quot;&gt;Template&lt;/a&gt; Toolkit, do that instead. You might even be able to get the job done with &lt;code&gt;sprintf&lt;/code&gt; or &lt;code&gt;printf&lt;/code&gt;:</source>
          <target state="translated">如果可以避免，请不要这样做，或者可以使用模板系统，例如&lt;a href=&quot;Text::Template&quot;&gt;Text :: Template&lt;/a&gt;或&lt;a href=&quot;template&quot;&gt;Template&lt;/a&gt; Toolkit，请改为这样做。您甚至可以使用 &lt;code&gt;sprintf&lt;/code&gt; 或 &lt;code&gt;printf&lt;/code&gt; 来完成工作：</target>
        </trans-unit>
        <trans-unit id="23b6ce07b51bd0ae187fbd5346ee2bf854f2bb10" translate="yes" xml:space="preserve">
          <source>If you can avoid it, don't, or if you can use a templating system, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text::Template&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Template&quot;&gt;Template&lt;/a&gt; Toolkit, do that instead. You might even be able to get the job done with &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">如果可以避免，请不要这样做，或者如果可以使用诸如&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text :: Template&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/Template&quot;&gt;Template&lt;/a&gt; Toolkit之类的模板系统，请改为这样做。您甚至可以使用 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 完成工作：</target>
        </trans-unit>
        <trans-unit id="f9556f6832194ce02eb38bf13ea3951955c6d164" translate="yes" xml:space="preserve">
          <source>If you can do these things, you've started on the long road to Perl porting. Thanks for wanting to help make Perl better - and happy hacking!</source>
          <target state="translated">如果你能做到这些,你就已经开始了漫长的 Perl 移植之路。谢谢你愿意帮助Perl变得更好--祝你黑客愉快!</target>
        </trans-unit>
        <trans-unit id="4e5e8e457d8aab789523193251b0cae471debcb4" translate="yes" xml:space="preserve">
          <source>If you can go through your firewall with e.g. lynx, presumably with a command such as</source>
          <target state="translated">如果你能通过你的防火墙,例如 lynx,大概可以用一个命令,如</target>
        </trans-unit>
        <trans-unit id="22d913b1c7a6af16ecff397b87485204b5a8ebbc" translate="yes" xml:space="preserve">
          <source>If you can not reach the author for some reason contact the PAUSE admins at modules@perl.org who may be able to help, but each case is treated separately.</source>
          <target state="translated">如果您因为某些原因无法联系到作者,请联系PAUSE管理员:modules@perl.org,他们可能会提供帮助,但每个案例都会单独处理。</target>
        </trans-unit>
        <trans-unit id="e0ff87acae1d2fe61dfcf4190a982955e52a9134" translate="yes" xml:space="preserve">
          <source>If you can't configure &lt;code&gt;TAP::Harness&lt;/code&gt; to do exactly what you want, and writing a plugin isn't an option, consider extending it. It is designed to be (mostly) easy to subclass, though the cases when sub-classing is necessary should be few and far between.</source>
          <target state="translated">如果您无法将 &lt;code&gt;TAP::Harness&lt;/code&gt; 配置为完全执行您想要的操作，并且不能编写插件，请考虑对其进行扩展。它被设计为（主要）易于子类化，尽管需要子类化的情况应该很少而且相去甚远。</target>
        </trans-unit>
        <trans-unit id="700d8f92e3038752feec96509274cbd7256d79dc" translate="yes" xml:space="preserve">
          <source>If you can't configure &lt;code&gt;TAP::Harness&lt;/code&gt; to do what you want, and you can't find an existing plugin, consider writing one.</source>
          <target state="translated">如果您无法配置 &lt;code&gt;TAP::Harness&lt;/code&gt; 做您想做的事，并且找不到现有的插件，请考虑编写一个插件。</target>
        </trans-unit>
        <trans-unit id="aab6be6829c9bde3ac67ace0b1b8f3a83861108b" translate="yes" xml:space="preserve">
          <source>If you can't use &lt;a href=&quot;File::Copy&quot;&gt;File::Copy&lt;/a&gt;, you'll have to do the work yourself: open the original file, open the destination file, then print to the destination file as you read the original. You also have to remember to copy the permissions, owner, and group to the new file.</source>
          <target state="translated">如果您不能使用&lt;a href=&quot;File::Copy&quot;&gt;File :: Copy&lt;/a&gt;，则必须自己做：打开原始文件，打开目标文件，然后在阅读原始文件时打印到目标文件。您还必须记住将权限，所有者和组复制到新文件。</target>
        </trans-unit>
        <trans-unit id="edcd365c3753fb0814dbbf4b5f1da5978fabe2e0" translate="yes" xml:space="preserve">
          <source>If you can't use &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt;, you'll have to do the work yourself: open the original file, open the destination file, then print to the destination file as you read the original. You also have to remember to copy the permissions, owner, and group to the new file.</source>
          <target state="translated">如果您不能使用&lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt;，则必须自己做：打开原始文件，打开目标文件，然后在阅读原始文件时打印到目标文件。您还必须记住将权限，所有者和组复制到新文件。</target>
        </trans-unit>
        <trans-unit id="2431416836e7be159e91db05fdcbf62b13f365c1" translate="yes" xml:space="preserve">
          <source>If you cannot achieve the desired Makefile behaviour by specifying attributes you may define private subroutines in the Makefile.PL. Each subroutine returns the text it wishes to have written to the Makefile. To override a section of the Makefile you can either say:</source>
          <target state="translated">如果你不能通过指定属性来实现所需的Makefile行为,你可以在Makefile.PL中定义私有子程序。每个子程序都会返回它希望写入Makefile的文本。要覆盖Makefile的某一节,你可以说。</target>
        </trans-unit>
        <trans-unit id="069db45c3cccee54b16dacbbc26ce2a59fc37a49" translate="yes" xml:space="preserve">
          <source>If you cannot upgrade your Perl to 5.8.0 or later, you can still do some Unicode processing by using the modules &lt;code&gt;Unicode::String&lt;/code&gt; , &lt;code&gt;Unicode::Map8&lt;/code&gt; , and &lt;code&gt;Unicode::Map&lt;/code&gt; , available from CPAN. If you have the GNU recode installed, you can also use the Perl front-end &lt;code&gt;Convert::Recode&lt;/code&gt; for character conversions.</source>
          <target state="translated">如果无法将Perl升级到5.8.0或更高版本，则仍可以使用CPAN提供的模块 &lt;code&gt;Unicode::String&lt;/code&gt; ， &lt;code&gt;Unicode::Map8&lt;/code&gt; 和 &lt;code&gt;Unicode::Map&lt;/code&gt; 进行一些Unicode处理。如果安装了GNU重新编码，则还可以使用Perl前端的 &lt;code&gt;Convert::Recode&lt;/code&gt; 进行字符转换。</target>
        </trans-unit>
        <trans-unit id="675032f69b34d194dcc7017e3c4c3044e3fbd01f" translate="yes" xml:space="preserve">
          <source>If you cannot upgrade your Perl to 5.8.0 or later, you can still do some Unicode processing by using the modules &lt;code&gt;Unicode::String&lt;/code&gt;, &lt;code&gt;Unicode::Map8&lt;/code&gt;, and &lt;code&gt;Unicode::Map&lt;/code&gt;, available from CPAN. If you have the GNU recode installed, you can also use the Perl front-end &lt;code&gt;Convert::Recode&lt;/code&gt; for character conversions.</source>
          <target state="translated">如果无法将Perl升级到5.8.0或更高版本，则仍可以使用CPAN提供的模块 &lt;code&gt;Unicode::String&lt;/code&gt; ， &lt;code&gt;Unicode::Map8&lt;/code&gt; 和 &lt;code&gt;Unicode::Map&lt;/code&gt; 进行一些Unicode处理。如果安装了GNU重新编码，则还可以使用Perl前端的 &lt;code&gt;Convert::Recode&lt;/code&gt; 进行字符转换。</target>
        </trans-unit>
        <trans-unit id="0d66bfc35fac26ccfc5a2fc8cf1cd9923cd9f43b" translate="yes" xml:space="preserve">
          <source>If you cannot use &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt;, you can make your own loop to do the same thing. Once you find the element, you stop the loop with last.</source>
          <target state="translated">如果您不能使用&lt;a href=&quot;List::Util&quot;&gt;List :: Util&lt;/a&gt;，则可以使自己的循环执行相同的操作。找到元素后，您就停止了last的循环。</target>
        </trans-unit>
        <trans-unit id="7f06f83624114fcf502e132fac57a686e4d7a4ee" translate="yes" xml:space="preserve">
          <source>If you cannot use &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt;, you can make your own loop to do the same thing. Once you find the element, you stop the loop with last.</source>
          <target state="translated">如果您不能使用&lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt;，则可以使自己的循环执行相同的操作。找到元素后，您就停止了last循环。</target>
        </trans-unit>
        <trans-unit id="83e89259781d3b7bf972995b7c8dc74ef7aacff4" translate="yes" xml:space="preserve">
          <source>If you cannot use the git protocol for firewall reasons, you can also clone via http, though this is much slower:</source>
          <target state="translated">如果因为防火墙的原因不能使用git协议,也可以通过http进行克隆,不过这个速度要慢很多。</target>
        </trans-unit>
        <trans-unit id="b117af02a8ee1b3faa8a2a2959074d94964f1bce" translate="yes" xml:space="preserve">
          <source>If you cannot use the git protocol for firewall reasons, you can also clone via http:</source>
          <target state="translated">如果因为防火墙原因不能使用git协议,也可以通过http进行克隆。</target>
        </trans-unit>
        <trans-unit id="794395d65809aff375720f1da63fe61351840429" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;$pattern&lt;/code&gt; after the first substitution happens, Perl will ignore it. If you don't want any substitutions at all, use the special delimiter &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">如果在第一次替换发生后更改 &lt;code&gt;$pattern&lt;/code&gt; ，Perl将忽略它。如果根本不需要任何替换，请使用特殊的定界符 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5a64e176836406787422c8fb3c6947be0def6d35" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;$pattern&lt;/code&gt; after the first substitution happens, Perl will ignore it. If you don't want any substitutions at all, use the special delimiter &lt;code&gt;m''&lt;/code&gt;:</source>
          <target state="translated">如果在第一次替换发生后更改 &lt;code&gt;$pattern&lt;/code&gt; ，Perl将忽略它。如果根本不需要任何替换，请使用特殊的定界符 &lt;code&gt;m''&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bca560012b71cc8dce8e6a03ec54196daca3d350" translate="yes" xml:space="preserve">
          <source>If you check &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;, you'll see that several of the ways to call open() should do the trick. For example:</source>
          <target state="translated">如果选中&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;，您会发现调用open（）的几种方法应该可以解决问题。例如：</target>
        </trans-unit>
        <trans-unit id="65c2b7d80f9113d02d83f4af5a6da477cccfeb58" translate="yes" xml:space="preserve">
          <source>If you check &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;, you'll see that several of the ways to call open() should do the trick. For example:</source>
          <target state="translated">如果&lt;a href=&quot;perlfunc#open&quot;&gt;在perlfunc中&lt;/a&gt;选中&amp;ldquo; open&amp;rdquo;，您将看到几种调用open（）的方法可以解决问题。例如：</target>
        </trans-unit>
        <trans-unit id="e4dedfaceb9670f08b0798c739b80203032d536c" translate="yes" xml:space="preserve">
          <source>If you chomp a list, each element is chomped, and the total number of characters removed is returned.</source>
          <target state="translated">如果你对一个列表进行分解,每个元素都会被分解,并返回删除的总字符数。</target>
        </trans-unit>
        <trans-unit id="716512a060dd3d5999bac2b4045e2b9123dc9b1b" translate="yes" xml:space="preserve">
          <source>If you choose XL C/C++ V11 you need the April 2010 PTF (or newer) installed otherwise you will not get a working Perl version.</source>
          <target state="translated">如果您选择XL C/C++V11,您需要安装2010年4月的PTF(或更新版本),否则您将无法使用Perl版本。</target>
        </trans-unit>
        <trans-unit id="c10052f207d29ada4465d2d73fcdfabf3621a0b6" translate="yes" xml:space="preserve">
          <source>If you choose XL C/C++ V9 you need APAR IZ35785 installed otherwise the integrated SDBM_File do not compile correctly due to an optimization bug. You can circumvent this problem by adding -qipa to the optimization flags (-Doptimize='-O -qipa'). The PTF for APAR IZ35785 which solves this problem is available from IBM (April 2009 PTF for XL C/C++ Enterprise Edition for AIX, V9.0).</source>
          <target state="translated">如果您选择XL C/C++V9,您需要安装APAR IZ35785,否则由于优化错误,集成的SDBM_File不能正确编译。你可以通过在优化标志中添加-qipa来规避这个问题(-Doptimize='-O -qipa')。解决这个问题的APAR IZ35785的PTF可以从IBM获得(2009年4月PTF for XL C/C++Enterprise Edition for AIX,V9.0)。</target>
        </trans-unit>
        <trans-unit id="fb54bcde599a5f03b31c1ac1b1fac745b31dc5b8" translate="yes" xml:space="preserve">
          <source>If you choose for the PTH package, use swinstall to install pth in the default location (/opt/pth), and then make symbolic links to the libraries from /usr/lib</source>
          <target state="translated">如果选择PTH包,使用swinstall将pth安装到默认位置(/opt/pth),然后从/usr/lib中建立符号链接到库。</target>
        </trans-unit>
        <trans-unit id="5ca7b309ef65dd317303754f8c4a5fd3689e4197" translate="yes" xml:space="preserve">
          <source>If you choose gcc to compile 64-bit Perl then you need to add the following option:</source>
          <target state="translated">如果你选择gcc来编译64位Perl,那么你需要添加以下选项。</target>
        </trans-unit>
        <trans-unit id="043ebe155c68a02fa99782ad455e116e9535a4e8" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;a href=&quot;#chop-VARIABLE&quot;&gt;&lt;code&gt;chop&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果切列表，则每个元素都被切。仅返回最后一个&lt;a href=&quot;#chop-VARIABLE&quot;&gt; &lt;code&gt;chop&lt;/code&gt; &lt;/a&gt;的值。</target>
        </trans-unit>
        <trans-unit id="875c1fe2de9773e7e9366d0703f2a602deb9c197" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果切列表，则每个元素都被切。仅返回最后一个 &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="03160d33f05c1b78628995f8692e16c5933ebe05" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果切列表，则每个元素都被切。仅返回最后一个 &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="caf1e734b10683713e7d496bb52630f5b34525d0" translate="yes" xml:space="preserve">
          <source>If you compile and run</source>
          <target state="translated">如果你编译并运行</target>
        </trans-unit>
        <trans-unit id="4359b9f0177138527f6b61e374c639bb3caf7642" translate="yes" xml:space="preserve">
          <source>If you completely hide the short forms of the Perl public API, add -DPERL_NO_SHORT_NAMES to the compilation flags. This means that for example instead of writing</source>
          <target state="translated">如果你完全隐藏了Perl公共API的简写,请在编译标志中添加-DPERL_NO_SHORT_NAMES。这意味着,比如说,我们不需要写</target>
        </trans-unit>
        <trans-unit id="2026c5f1b05bc468fd9f9b21ddfe279181855850" translate="yes" xml:space="preserve">
          <source>If you constrain the portion of &lt;code&gt;pv&lt;/code&gt; that is looked at by this function (by passing a non-NULL &lt;code&gt;endptr&lt;/code&gt;), and if the intial bytes of that portion form a valid value, it will return TRUE, setting &lt;code&gt;*endptr&lt;/code&gt; to the byte following the final digit of the value. But if there is no constraint at what's looked at, all of &lt;code&gt;pv&lt;/code&gt; must be valid in order for TRUE to be returned. &lt;code&gt;*endptr&lt;/code&gt; is unchanged from its value on input if FALSE is returned;</source>
          <target state="translated">如果您限制了此函数查看的 &lt;code&gt;pv&lt;/code&gt; 部分（通过传递非NULL &lt;code&gt;endptr&lt;/code&gt; ），并且如果该部分的初始字节形成有效值，则它将返回TRUE，并将 &lt;code&gt;*endptr&lt;/code&gt; 设置为紧随其后的字节值的最后一位。但是，如果所查看的内容没有任何限制，则所有 &lt;code&gt;pv&lt;/code&gt; 必须都是有效的，以便返回TRUE。 &lt;code&gt;*endptr&lt;/code&gt; 如果返回FALSE，则endptr与其输入值保持不变；</target>
        </trans-unit>
        <trans-unit id="7e117fe20aeb505e6fb3bd26d20ee9983d45c623" translate="yes" xml:space="preserve">
          <source>If you consult &lt;code&gt;perldoc -f &lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; you will see that &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; will behave differently when given a bareword or a string.</source>
          <target state="translated">如果您咨询 &lt;code&gt;perldoc -f &lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ,您将看到 &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 在给出裸字或字符串时的行为会有所不同。</target>
        </trans-unit>
        <trans-unit id="675f3fe6a1b5c4eacc7781347f628b31f87a96c1" translate="yes" xml:space="preserve">
          <source>If you consult &lt;code&gt;perldoc -f require&lt;/code&gt; you will see that &lt;code&gt;require&lt;/code&gt; will behave differently when given a bareword or a string.</source>
          <target state="translated">如果您咨询 &lt;code&gt;perldoc -f require&lt;/code&gt; ,您将看到 &lt;code&gt;require&lt;/code&gt; 在给出裸字或字符串时的行为会有所不同。</target>
        </trans-unit>
        <trans-unit id="e933e27b4b6affb17bacc2be8545945df23e47f1" translate="yes" xml:space="preserve">
          <source>If you create interpreters in one thread and then proceed to call them in another, you need to make sure perl's own Thread Local Storage (TLS) slot is initialized correctly in each of those threads.</source>
          <target state="translated">如果你在一个线程中创建了解释器,然后在另一个线程中继续调用它们,你需要确保perl自己的线程本地存储(TLS)槽在每个线程中都被正确初始化。</target>
        </trans-unit>
        <trans-unit id="4e50c2bd9e835a3a7f1961b7856f6dac61424cbe" translate="yes" xml:space="preserve">
          <source>If you decide to ignore this advice and use the GNU versions anyway, then be sure that they are relatively recent. Versions newer than 2.7 are apparently new enough. Older versions may have trouble with dynamic loading.</source>
          <target state="translated">如果您决定无视这个建议而使用GNU版本,那么请确保它们是相对较新的版本。比2.7新的版本显然已经足够新了。旧的版本可能在动态加载方面有问题。</target>
        </trans-unit>
        <trans-unit id="ff55c7f7dfadd85537843d3b167612c0ffcaee31" translate="yes" xml:space="preserve">
          <source>If you decide to use a different version of the zlib library, you need to be aware of the following issues</source>
          <target state="translated">如果你决定使用不同版本的zlib库,你需要注意以下问题。</target>
        </trans-unit>
        <trans-unit id="dea32ebc2834b73dcbf2cbd2fdecffa9453ead2d" translate="yes" xml:space="preserve">
          <source>If you decide to use gcc, make sure your installation is recent and complete, and be sure to read the Perl INSTALL file for more gcc-specific details.</source>
          <target state="translated">如果你决定使用gcc,请确保你的安装是最新的和完整的,并且一定要阅读Perl的INSTALL文件来了解更多关于gcc的细节。</target>
        </trans-unit>
        <trans-unit id="275ebe9364d1067d763d9e8ee83a9ef9cef15d89" translate="yes" xml:space="preserve">
          <source>If you decide to use gcc, make sure your installation is recent and complete, and be sure to read the Perl INSTALL file for more gcc-specific details. Please report any hoops you had to jump through to the development team.</source>
          <target state="translated">如果你决定使用gcc,请确保你的安装是最新的和完整的,并且一定要阅读Perl的INSTALL文件来了解更多关于gcc的细节。请向开发团队报告任何你不得不跳过的障碍。</target>
        </trans-unit>
        <trans-unit id="129ecc12b1557dd3798539452dbf9b9ea8476c0d" translate="yes" xml:space="preserve">
          <source>If you define an &lt;code&gt;AUTOLOAD&lt;/code&gt; in your class, then Perl will call your &lt;code&gt;AUTOLOAD&lt;/code&gt; to handle the &lt;code&gt;DESTROY&lt;/code&gt; method. You can prevent this by defining an empty &lt;code&gt;DESTROY&lt;/code&gt; , like we did in the autoloading example. You can also check the value of &lt;code&gt;$AUTOLOAD&lt;/code&gt; and return without doing anything when called to handle &lt;code&gt;DESTROY&lt;/code&gt; .</source>
          <target state="translated">如果您在类中定义了 &lt;code&gt;AUTOLOAD&lt;/code&gt; ，则Perl将调用您的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 来处理 &lt;code&gt;DESTROY&lt;/code&gt; 方法。您可以通过定义一个空的 &lt;code&gt;DESTROY&lt;/code&gt; 来避免这种情况，就像我们在自动加载示例中所做的那样。您还可以检查 &lt;code&gt;$AUTOLOAD&lt;/code&gt; 的值，并在调用 &lt;code&gt;DESTROY&lt;/code&gt; 时不做任何事情就返回。</target>
        </trans-unit>
        <trans-unit id="498a8ce676b34793704f21213180e13370975cc0" translate="yes" xml:space="preserve">
          <source>If you define an &lt;code&gt;AUTOLOAD&lt;/code&gt; in your class, then Perl will call your &lt;code&gt;AUTOLOAD&lt;/code&gt; to handle the &lt;code&gt;DESTROY&lt;/code&gt; method. You can prevent this by defining an empty &lt;code&gt;DESTROY&lt;/code&gt;, like we did in the autoloading example. You can also check the value of &lt;code&gt;$AUTOLOAD&lt;/code&gt; and return without doing anything when called to handle &lt;code&gt;DESTROY&lt;/code&gt;.</source>
          <target state="translated">如果您在类中定义了 &lt;code&gt;AUTOLOAD&lt;/code&gt; ，则Perl将调用您的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 来处理 &lt;code&gt;DESTROY&lt;/code&gt; 方法。您可以通过定义一个空的 &lt;code&gt;DESTROY&lt;/code&gt; 来避免这种情况，就像我们在自动加载示例中所做的那样。您还可以检查 &lt;code&gt;$AUTOLOAD&lt;/code&gt; 的值，并在调用以处理 &lt;code&gt;DESTROY&lt;/code&gt; 时不执行任何操作而返回。</target>
        </trans-unit>
        <trans-unit id="94eb8ac68c4fb558c46d1ee64b3833ca570000ed" translate="yes" xml:space="preserve">
          <source>If you define more than one name for the code point, it is indeterminate which one will be returned.</source>
          <target state="translated">如果你为代码点定义了一个以上的名字,那么返回的是不确定的。</target>
        </trans-unit>
        <trans-unit id="49322aadfdd4f7ccdbc478f7d31a6ef35c74c780" translate="yes" xml:space="preserve">
          <source>If you desire complete control over SSL connections, the &lt;code&gt;SSL_options&lt;/code&gt; attribute lets you provide a hash reference that will be passed through to &lt;code&gt;IO::Socket::SSL::start_SSL()&lt;/code&gt;, overriding any options set by HTTP::Tiny. For example, to provide your own trusted CA file:</source>
          <target state="translated">如果希望完全控制SSL连接，则 &lt;code&gt;SSL_options&lt;/code&gt; 属性可让您提供将传递给 &lt;code&gt;IO::Socket::SSL::start_SSL()&lt;/code&gt; 的哈希引用，从而覆盖由HTTP :: Tiny设置的所有选项。例如，要提供您自己的受信任CA文件：</target>
        </trans-unit>
        <trans-unit id="04b2ed76508ea6501a561cd368f25fd856dfc7e2" translate="yes" xml:space="preserve">
          <source>If you develop any useful expiration managers that you think should be distributed with Memoize, please let me know.</source>
          <target state="translated">如果你开发了任何你认为应该与Memoize一起发布的有用的到期管理程序,请告诉我。</target>
        </trans-unit>
        <trans-unit id="2101fa1f88298b0b195dfaac7732fd2635cea835" translate="yes" xml:space="preserve">
          <source>If you didn't mean to use a Unicode property, escape the &lt;code&gt;\p&lt;/code&gt;, either by &lt;code&gt;\\p&lt;/code&gt; (just the &lt;code&gt;\p&lt;/code&gt;) or by &lt;code&gt;\Q\p&lt;/code&gt; (the rest of the string, or until &lt;code&gt;\E&lt;/code&gt;).</source>
          <target state="translated">如果您不打算使用Unicode属性，请通过 &lt;code&gt;\\p&lt;/code&gt; （只是 &lt;code&gt;\p&lt;/code&gt; ）或 &lt;code&gt;\Q\p&lt;/code&gt; （字符串的其余部分，或者直到 &lt;code&gt;\E&lt;/code&gt; ）对 &lt;code&gt;\p&lt;/code&gt; 转义。</target>
        </trans-unit>
        <trans-unit id="0cf4a8657eebfe97ba9c4e743bd983d09e5edaa6" translate="yes" xml:space="preserve">
          <source>If you didn't use &lt;code&gt;openlog()&lt;/code&gt; before using &lt;code&gt;syslog()&lt;/code&gt; , &lt;code&gt;syslog()&lt;/code&gt; will try to guess the &lt;code&gt;$ident&lt;/code&gt; by extracting the shortest prefix of &lt;code&gt;$format&lt;/code&gt; that ends in a &lt;code&gt;&quot;:&quot;&lt;/code&gt; .</source>
          <target state="translated">如果您没有使用 &lt;code&gt;openlog()&lt;/code&gt; 使用前 &lt;code&gt;syslog()&lt;/code&gt; ， &lt;code&gt;syslog()&lt;/code&gt; 函数将尝试猜测 &lt;code&gt;$ident&lt;/code&gt; 通过提取的最短前缀 &lt;code&gt;$format&lt;/code&gt; ，在一个两端 &lt;code&gt;&quot;:&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2758eb43b68115ce83395ea254e99fa90136500" translate="yes" xml:space="preserve">
          <source>If you didn't use &lt;code&gt;openlog()&lt;/code&gt; before using &lt;code&gt;syslog()&lt;/code&gt;, &lt;code&gt;syslog()&lt;/code&gt; will try to guess the &lt;code&gt;$ident&lt;/code&gt; by extracting the shortest prefix of &lt;code&gt;$format&lt;/code&gt; that ends in a &lt;code&gt;&quot;:&quot;&lt;/code&gt;.</source>
          <target state="translated">如果您没有使用 &lt;code&gt;openlog()&lt;/code&gt; 使用前 &lt;code&gt;syslog()&lt;/code&gt; ， &lt;code&gt;syslog()&lt;/code&gt; 函数将尝试猜测 &lt;code&gt;$ident&lt;/code&gt; 通过提取的最短前缀 &lt;code&gt;$format&lt;/code&gt; ，在一个两端 &lt;code&gt;&quot;:&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06ed1961687b0abd10e165d61c48cda9ac3ae785" translate="yes" xml:space="preserve">
          <source>If you discover some glitches, move directories of problematic modules to a different location; if these modules are non-XS modules, you may just ignore them - they are already installed; the remaining, XS, modules you need to install manually one by one.</source>
          <target state="translated">如果你发现了一些小问题,就把有问题的模块目录移到另一个位置;如果这些模块是非XS模块,你可以忽略它们--它们已经安装好了;剩下的XS模块,你需要一个个手动安装。</target>
        </trans-unit>
        <trans-unit id="43d56dedc7192e637755e1fdcd48fbf68cbff70a" translate="yes" xml:space="preserve">
          <source>If you do</source>
          <target state="translated">如果你这样做</target>
        </trans-unit>
        <trans-unit id="cb8667358646593d3b3e540e94dd3bddc5a68445" translate="yes" xml:space="preserve">
          <source>If you do need to sort non-alphabetically for whatever reasons, you can give a code reference (or a subroutine name) to &lt;code&gt;sort_by&lt;/code&gt;, then the argument will be passed to Perl's &lt;code&gt;sort&lt;/code&gt; built-in function.</source>
          <target state="translated">如果出于某种原因确实需要非字母排序，则可以给 &lt;code&gt;sort_by&lt;/code&gt; 提供代码引用（或子例程名称），然后该参数将传递给Perl的 &lt;code&gt;sort&lt;/code&gt; 内置函数。</target>
        </trans-unit>
        <trans-unit id="f303cdfeba4ec1c04b3ea76ad07c019d7ba1217e" translate="yes" xml:space="preserve">
          <source>If you do not do this, then tools you call that also check for a context will notice that the context they grabbed was created at the same stack depth, which will trigger protective measures that warn you and destroy the existing context.</source>
          <target state="translated">如果你不这样做,那么你调用的那些同样检查上下文的工具就会注意到他们所抓取的上下文是在相同的堆栈深度创建的,这将触发保护措施,警告你并销毁现有的上下文。</target>
        </trans-unit>
        <trans-unit id="87ef7e6c621828b29eab79e96b5fb6269cd00a77" translate="yes" xml:space="preserve">
          <source>If you do not enter the shell, shell commands are available both as methods (&lt;code&gt;CPAN::Shell-&amp;gt;install(...)&lt;/code&gt; ) and as functions in the calling package (&lt;code&gt;install(...)&lt;/code&gt; ). Before calling low-level commands, it makes sense to initialize components of CPAN you need, e.g.:</source>
          <target state="translated">如果不输入外壳程序，则外壳程序命令既可以用作方法（ &lt;code&gt;CPAN::Shell-&amp;gt;install(...)&lt;/code&gt; ），也可以用作调用包中的函数（ &lt;code&gt;install(...)&lt;/code&gt; ）。在调用低级命令之前，有必要初始化所需的CPAN组件，例如：</target>
        </trans-unit>
        <trans-unit id="bc816a9fd08d7a00464780adbf72cc89737d7fde" translate="yes" xml:space="preserve">
          <source>If you do not have</source>
          <target state="translated">如果你没有</target>
        </trans-unit>
        <trans-unit id="69ced298dbf1c87fefd1662253cccc2e7a8bde7d" translate="yes" xml:space="preserve">
          <source>If you do not have a copy of the GNU General Public License write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</source>
          <target state="translated">如果您没有GNU通用公共许可证的副本,请写信给自由软件基金会公司,675 Mass Ave,Cambridge,MA 02139,USA。</target>
        </trans-unit>
        <trans-unit id="ca85e836f91816edbc4e15e9107effedf45973f0" translate="yes" xml:space="preserve">
          <source>If you do not have that module, you can do the same thing with &lt;a href=&quot;File::Find&quot;&gt;File::Find&lt;/a&gt; which is part of the standard library:</source>
          <target state="translated">如果没有该模块，则可以使用&lt;a href=&quot;File::Find&quot;&gt;File :: Find&lt;/a&gt;来做相同的事情，它是标准库的一部分：</target>
        </trans-unit>
        <trans-unit id="f9c124bac0783d0b5dcccc34a0dbf3566f426f11" translate="yes" xml:space="preserve">
          <source>If you do not have that module, you can do the same thing with &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt; which is part of the standard library:</source>
          <target state="translated">如果没有该模块，则可以使用标准库中的&lt;a href=&quot;file/find&quot;&gt;File :: Find&lt;/a&gt;进行相同的操作：</target>
        </trans-unit>
        <trans-unit id="05c2496743b48fe9b410f73d7328bfcdc228baa8" translate="yes" xml:space="preserve">
          <source>If you do not have the SDK installed you must at least have abc-shell installed or some other suitable sh port. This is required to run external commands and should be available as 'sh' in your path.</source>
          <target state="translated">如果你没有安装SDK,你必须至少安装abc-shell或其他合适的sh端口。这是运行外部命令所必需的,并且应该在你的路径中以'sh'的形式存在。</target>
        </trans-unit>
        <trans-unit id="bd07d5a5c26be6eca98f51764342db5783f35fa8" translate="yes" xml:space="preserve">
          <source>If you do not know what shell you have, consult your local helpdesk or the equivalent.</source>
          <target state="translated">如果您不知道您所使用的是什么外壳,请咨询您当地的服务台或同等机构。</target>
        </trans-unit>
        <trans-unit id="7e4c6cc6957c31110bb18e19744ff8957469df93" translate="yes" xml:space="preserve">
          <source>If you do not override this then the default implementation will attempt to generate facets from the legacy API. This generation is limited only to what the legacy API can provide. It is recommended that you override this method and write out explicit facet data.</source>
          <target state="translated">如果您不重写这一点,那么默认的实现将尝试从传统API生成面。这种生成只限于 legacy API 能够提供的内容。建议你覆盖这个方法,并写出显式的面数据。</target>
        </trans-unit>
        <trans-unit id="1de6e3279f2bd155e7f8bf6759e637927cce20be" translate="yes" xml:space="preserve">
          <source>If you do not set this flag then it is</source>
          <target state="translated">如果您不设置这个标志,那么它就是</target>
        </trans-unit>
        <trans-unit id="926a166805dd3b0aef3dd1d472d192955fb1ec52" translate="yes" xml:space="preserve">
          <source>If you do not specify a package name, the variable is created in the current package.</source>
          <target state="translated">如果没有指定包名,则在当前包中创建变量。</target>
        </trans-unit>
        <trans-unit id="eb887a9c7d54012c86e6e1c5e9df47c38a1fd9a7" translate="yes" xml:space="preserve">
          <source>If you do not want to actually create a full blown version object, but would still like to verify that a given string meets the criteria to be parsed as a version, there are two helper functions that can be employed directly:</source>
          <target state="translated">如果你不想实际创建一个完整的版本对象,但仍想验证一个给定的字符串是否符合作为版本解析的标准,有两个辅助函数可以直接使用。</target>
        </trans-unit>
        <trans-unit id="5ec84ed1a6f6d8da6377929662414a47b27976a2" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="translated">如果您不想调用包的&lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;方法（例如，阻止更改名称空间），请显式提供空列表：</target>
        </trans-unit>
        <trans-unit id="3b6ac2382b8b465b26d1901487c44646a3e50e04" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="translated">如果您不想调用包的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法（例如，阻止更改名称空间），请显式提供空列表：</target>
        </trans-unit>
        <trans-unit id="ea10c1ff3a243c28f284c149e22c1d185c65b318" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="translated">如果您不想调用包的 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法（例如，阻止更改名称空间），请显式提供空列表：</target>
        </trans-unit>
        <trans-unit id="8470234c0d68b289fd8da0f074a387fae1ae490f" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="translated">如果您不想使用这些默认值，则可以通过显式设置 &lt;code&gt;Name&lt;/code&gt; ， &lt;code&gt;Time&lt;/code&gt; ， &lt;code&gt;TextFlag&lt;/code&gt; ， &lt;code&gt;ExtAttr&lt;/code&gt; ， &lt;code&gt;exUnixN&lt;/code&gt; 和 &lt;code&gt;exTime&lt;/code&gt; 选项或设置 &lt;code&gt;Minimal&lt;/code&gt; 参数来覆盖它们。</target>
        </trans-unit>
        <trans-unit id="f15a287c32e6f66173e359fbddfbe362d18b693a" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Time&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="translated">如果您不想使用这些默认值，则可以通过显式设置&amp;ldquo; &lt;code&gt;Name&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;Time&lt;/code&gt; 选项或通过设置&amp;ldquo; &lt;code&gt;Minimal&lt;/code&gt; 参数来覆盖它们。</target>
        </trans-unit>
        <trans-unit id="de7aec51016dff43e0ecf45d764d0cccf666e711" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt;, &lt;code&gt;Time&lt;/code&gt;, &lt;code&gt;TextFlag&lt;/code&gt;, &lt;code&gt;ExtAttr&lt;/code&gt;, &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="translated">如果您不想使用这些默认值，则可以通过显式设置 &lt;code&gt;Name&lt;/code&gt; ， &lt;code&gt;Time&lt;/code&gt; ， &lt;code&gt;TextFlag&lt;/code&gt; ， &lt;code&gt;ExtAttr&lt;/code&gt; ， &lt;code&gt;exUnixN&lt;/code&gt; 和 &lt;code&gt;exTime&lt;/code&gt; 选项或设置 &lt;code&gt;Minimal&lt;/code&gt; 参数来覆盖它们。</target>
        </trans-unit>
        <trans-unit id="c647e4788bb29e5dcf3d258b1e0dc34c9ef54f62" translate="yes" xml:space="preserve">
          <source>If you do not wish this to happen, you should provide an array reference, where all parts of your command are already separated out. Note however, if there are extra or spurious whitespaces in these parts, the parser or underlying code may not interpret it correctly, and cause an error.</source>
          <target state="translated">如果你不希望发生这种情况,你应该提供一个数组引用,在这个数组中,你的命令的所有部分都已经被分离出来,但是请注意,如果在这些部分中有额外的或虚假的空白,解析器或底层代码可能不会正确解释,并导致错误。但是请注意,如果这些部分有额外的或虚假的空白,解析器或底层代码可能无法正确解释,并导致错误。</target>
        </trans-unit>
        <trans-unit id="459db29c5c8a7302439a70851525c81616dcc865" translate="yes" xml:space="preserve">
          <source>If you do not wish to install the &lt;a href=&quot;Module::Starter&quot;&gt;Module::Starter&lt;/a&gt; package from CPAN,</source>
          <target state="translated">如果您不想从CPAN安装&lt;a href=&quot;Module::Starter&quot;&gt;Module :: Starter&lt;/a&gt;软件包，</target>
        </trans-unit>
        <trans-unit id="1f09ee5e6b9af0c82c4326addc62e789f8443f5c" translate="yes" xml:space="preserve">
          <source>If you do not wish to install the &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module::Starter&lt;/a&gt; package from CPAN,</source>
          <target state="translated">如果您不想从CPAN 安装&lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module :: Starter&lt;/a&gt;软件包，</target>
        </trans-unit>
        <trans-unit id="484cd976813c85d85881ff70f66c34600b720c15" translate="yes" xml:space="preserve">
          <source>If you do set &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; to 0, you may notice an improvement in speed at the risk of not recursing into subdirectories if a filesystem doesn't populate &lt;code&gt;nlink&lt;/code&gt; as expected.</source>
          <target state="translated">如果确实将 &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; 为0，则在文件系统 &lt;code&gt;nlink&lt;/code&gt; 预期填充nlink的情况下，您可能会注意到速度有所提高，但存在无法递归到子目录的风险。</target>
        </trans-unit>
        <trans-unit id="0549310bae0dd74950be604da632c91876f7d8c0" translate="yes" xml:space="preserve">
          <source>If you do set &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; to 1, you will notice slow-downs.</source>
          <target state="translated">如果确实将 &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; 为1，您会注意到速度变慢。</target>
        </trans-unit>
        <trans-unit id="feef0b7ae2868ad2a4e1f83d30c63fb0d93e6be4" translate="yes" xml:space="preserve">
          <source>If you do this in a binary operator, you will actually change one of the strings that came into the operator, and, while it shouldn't be noticeable by the end user, it can cause problems in deficient code.</source>
          <target state="translated">如果你在二进制操作符中这样做,你实际上会改变进入操作符的其中一个字符串,虽然终端用户应该不会注意到,但它可能会导致缺陷代码的问题。</target>
        </trans-unit>
        <trans-unit id="32f0578310d415019b09f619288e373d3b705f8d" translate="yes" xml:space="preserve">
          <source>If you do want this subroutine to be a closure that reflects future changes to the variable that it closes over, add an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">如果您确实希望此子例程是一个闭合函数，以反映对该变量结束的将来更改，请添加显式 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="38c006c4445fbc760bcc20774ff0c404fc351e3b" translate="yes" xml:space="preserve">
          <source>If you do want this subroutine to be a closure that reflects future changes to the variable that it closes over, add an explicit &lt;code&gt;return&lt;/code&gt;:</source>
          <target state="translated">如果您确实希望此子例程是一个闭合函数，以反映对该变量结束的将来更改，请添加显式 &lt;code&gt;return&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7553259d39face4afb80ca316b04630713e25671" translate="yes" xml:space="preserve">
          <source>If you do want to work with large integers like under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; , try &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint;&lt;/code&gt; :</source>
          <target state="translated">如果您确实想使用大整数，例如 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; ，请尝试 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b1975a786e24a8553b122ca84ecd2c75458bf60c" translate="yes" xml:space="preserve">
          <source>If you do want to work with large integers like under &lt;code&gt;use integer;&lt;/code&gt;, try &lt;code&gt;use bigint;&lt;/code&gt;:</source>
          <target state="translated">如果您确实想使用大整数，例如 &lt;code&gt;use integer;&lt;/code&gt; ，请尝试 &lt;code&gt;use bigint;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="226407ccd685c51b95b1d8b7151f227bb1d0575c" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to be included in the AUTHORS file, just let us know. Otherwise we will take your submission of a patch as permission to credit you in the AUTHORS file.</source>
          <target state="translated">如果您不想被包含在AUTHORS文件中，请告诉我们。否则，我们会将您提交的补丁程序视为允许您将其贷记到AUTHORS文件中的权限。</target>
        </trans-unit>
        <trans-unit id="a338314884729930813df6e4dec44b70118fce2d" translate="yes" xml:space="preserve">
          <source>If you don't ask for any feature, you get the list of features that the user requested you to be nice to. This has the nice side effect that if you don't respect anything in particular then you can just ask for it and use it like a boolean.</source>
          <target state="translated">如果你不要求任何功能,你会得到用户要求你对其好的功能列表。这有一个很好的副作用,如果你不尊重任何特别的东西,那么你可以直接要求它,并像布尔值一样使用它。</target>
        </trans-unit>
        <trans-unit id="d5b6d156d7cf6f2a797778536a48c223724f9360" translate="yes" xml:space="preserve">
          <source>If you don't care about the order of the elements, you could just create the hash then extract the keys. It's not important how you create that hash: just that you use &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; to get the unique elements.</source>
          <target state="translated">如果您不关心元素的顺序，则可以只创建哈希然后提取键。创建散列并不重要：只是使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 来获取唯一元素。</target>
        </trans-unit>
        <trans-unit id="6ab466d2383fda10b330c50a2b963d3911043a02" translate="yes" xml:space="preserve">
          <source>If you don't care about the order of the elements, you could just create the hash then extract the keys. It's not important how you create that hash: just that you use &lt;code&gt;keys&lt;/code&gt; to get the unique elements.</source>
          <target state="translated">如果您不关心元素的顺序，则可以只创建哈希然后提取键。创建散列并不重要：只是使用 &lt;code&gt;keys&lt;/code&gt; 来获取唯一元素。</target>
        </trans-unit>
        <trans-unit id="e21625178e6b6545fac5abe6f5027d91ef293d91" translate="yes" xml:space="preserve">
          <source>If you don't care about where digits and underscore sort to, you can do something like this</source>
          <target state="translated">如果你不关心数字和下划线的排序,你可以这样做</target>
        </trans-unit>
        <trans-unit id="f92e493c5048826b06ef70fc4669cac080dfe915" translate="yes" xml:space="preserve">
          <source>If you don't care that one hash overwrites keys and values from the other, you could just use a hash slice to add one hash to another. In this case, values from &lt;code&gt;%hash2&lt;/code&gt; replace values from &lt;code&gt;%hash1&lt;/code&gt; when they have keys in common:</source>
          <target state="translated">如果您不关心一个哈希值会覆盖另一个哈希值的键和值，则可以使用一个哈希片将一个哈希值添加到另一个哈希值中。在这种情况下，从值 &lt;code&gt;%hash2&lt;/code&gt; 从替代值 &lt;code&gt;%hash1&lt;/code&gt; 时，他们有共同的键：</target>
        </trans-unit>
        <trans-unit id="c43d001ee345c63043409156142b64f915867634" translate="yes" xml:space="preserve">
          <source>If you don't get a paragraph or two of expanded discussion, it might not be perl's message.</source>
          <target state="translated">如果你没有得到一两段扩展的讨论,可能不是perl的信息。</target>
        </trans-unit>
        <trans-unit id="7a12cb113cb2e2457200764dfd73d419fb8973d7" translate="yes" xml:space="preserve">
          <source>If you don't have File::Stream, you have to do a little more work.</source>
          <target state="translated">如果你没有File::Stream,你必须做更多的工作。</target>
        </trans-unit>
        <trans-unit id="ea4a8fbdbdee9b250414a6cc40a6c3e590cef92d" translate="yes" xml:space="preserve">
          <source>If you don't have data written with specific configuration of perl described above, then you do not and should not do anything. Don't set the flag - not only will Storable on an identically configured perl refuse to load them, but Storable a differently configured perl will load them believing them to be correct for it, and then may well fail or crash part way through reading them.</source>
          <target state="translated">如果你没有用上面描述的perl的特定配置来写数据,那么你不要也不应该做任何事情。不要设置这个标志--不仅在相同配置的perl上Storable会拒绝加载它们,而且不同配置的perl也会加载它们,认为它们是正确的,然后很可能在读取它们的过程中失败或崩溃。</target>
        </trans-unit>
        <trans-unit id="670ababa1b4eae15ad2ad8b23b062bc17283021f" translate="yes" xml:space="preserve">
          <source>If you don't have the safe version of set-id scripts, all is not lost. Sometimes this kernel &quot;feature&quot; can be disabled, so that the kernel either doesn't run set-id scripts with the set-id or doesn't run them at all. Either way avoids the exploitability of the race condition, but doesn't help in actually running scripts set-id.</source>
          <target state="translated">如果你没有安全版的set-id脚本,也不是万事大吉。有时可以禁用这个内核的 &quot;功能&quot;,这样内核要么不运行set-id脚本,要么根本不运行set-id脚本。无论哪种方式都避免了race条件的可利用性,但对实际运行set-id的脚本没有帮助。</target>
        </trans-unit>
        <trans-unit id="f34e9607e58d64a63d5aabb3955bab5ec740de09" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; to trap the error.</source>
          <target state="translated">如果您没有对该DBM文件的写访问权，则只能读取哈希变量，而不能设置它们。如果要测试是否可以写，请使用文件测试或尝试在&lt;a href=&quot;#eval-EXPR&quot;&gt; &lt;code&gt;eval&lt;/code&gt; 中&lt;/a&gt;设置虚拟哈希条目以捕获错误。</target>
        </trans-unit>
        <trans-unit id="36289d77701a121889713d6277f544f12a871bb4" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; to trap the error.</source>
          <target state="translated">如果您没有对该DBM文件的写访问权，则只能读取哈希变量，而不能设置它们。如果要测试是否可以写入，请使用文件测试或尝试在 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中设置虚拟哈希条目以捕获错误。</target>
        </trans-unit>
        <trans-unit id="bdbbd37031df2f33535ed6549b499d32ea9aa9e5" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; to trap the error.</source>
          <target state="translated">如果您没有对该DBM文件的写访问权，则只能读取哈希变量，而不能设置它们。如果要测试是否可以写入，请使用文件测试或尝试在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中设置虚拟哈希条目以捕获错误。</target>
        </trans-unit>
        <trans-unit id="8f4b767528b9f98c2858aad05fc8520eae2c1d33" translate="yes" xml:space="preserve">
          <source>If you don't import any of these functions, assume a &lt;code&gt;&amp;amp;I18N::LangTags::&lt;/code&gt; in front of all the function names in the following examples.</source>
          <target state="translated">如果您不导入任何这些函数，则在以下示例中，在所有函数名称之前假定 &lt;code&gt;&amp;amp;I18N::LangTags::&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="107952179f7076da25aad77d14c209ced7df48df" translate="yes" xml:space="preserve">
          <source>If you don't know how many tests you're going to run, you can issue the plan when you're done running tests.</source>
          <target state="translated">如果你不知道你要运行多少测试,你可以在运行测试完成后发出计划。</target>
        </trans-unit>
        <trans-unit id="739739cb456280bdf258e73ad5d6021f89fcc54e" translate="yes" xml:space="preserve">
          <source>If you don't know if a string contains YAML or JSON, this method will use &lt;a href=&quot;Parse::CPAN::Meta&quot;&gt;Parse::CPAN::Meta&lt;/a&gt; to guess. In other respects it is identical to &lt;code&gt;load_file()&lt;/code&gt;.</source>
          <target state="translated">如果您不知道字符串是否包含YAML或JSON，则此方法将使用&lt;a href=&quot;Parse::CPAN::Meta&quot;&gt;Parse :: CPAN :: Meta&lt;/a&gt;进行猜测。在其他方面，它与 &lt;code&gt;load_file()&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="209c65929fc8bcea028a0c96cf1f684c89334602" translate="yes" xml:space="preserve">
          <source>If you don't know what license to use, dual licensing under the GPL and Artistic licenses (the same as Perl itself) is a good idea. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt; and &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;.</source>
          <target state="translated">如果您不知道要使用什么许可证，那么根据GPL和Artistic许可证（与Perl本身相同）进行双重许可是个好主意。参见&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt;和&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed23e5a70f4d9c445aa4d9a13f1bd7f582002fa9" translate="yes" xml:space="preserve">
          <source>If you don't know what license to use, dual licensing under the GPL and Artistic licenses (the same as Perl itself) is a good idea. See &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlgpl&quot;&gt;perlgpl&lt;/a&gt; and &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlartistic&quot;&gt;perlartistic&lt;/a&gt;.</source>
          <target state="translated">如果您不知道要使用什么许可证，那么按照GPL和Artistic许可证（与Perl本身相同）进行双重许可是个好主意。参见&lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlgpl&quot;&gt;perlgpl&lt;/a&gt;和&lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlartistic&quot;&gt;perlartistic&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0afa056a783c1ff17e6396cee6d067cb1e22c33a" translate="yes" xml:space="preserve">
          <source>If you don't know whether a string contains YAML or JSON data, this method will use some heuristics and guess. If it can't tell, it assumes YAML.</source>
          <target state="translated">如果你不知道一个字符串是否包含YAML或JSON数据,这个方法会使用一些启发式的方法,并进行猜测。如果它无法判断,就会假设是YAML。</target>
        </trans-unit>
        <trans-unit id="d34593d2a30bd46dc846ad60717c333d071ef181" translate="yes" xml:space="preserve">
          <source>If you don't mind shelling out, the &lt;code&gt;wc&lt;/code&gt; command is usually the fastest, even with the extra interprocess overhead. Ensure that you have an untainted filename though:</source>
          <target state="translated">如果您不介意炮击，即使有额外的进程间开销， &lt;code&gt;wc&lt;/code&gt; 命令通常也是最快的。不过，请确保文件名没有污染：</target>
        </trans-unit>
        <trans-unit id="ab42639abd5abd9367c12d1d0ad1d1482fb0d4b6" translate="yes" xml:space="preserve">
          <source>If you don't need the existing content of the SV, you can avoid some copying with:</source>
          <target state="translated">如果你不需要SV的现有内容,你可以用避免一些复制。</target>
        </trans-unit>
        <trans-unit id="bd9e10a2452b68c075fcb32cabd703d0209267ed" translate="yes" xml:space="preserve">
          <source>If you don't need to know the name of the file, you can use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in place of the file name. In Perl 5.8 or later, the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function creates an anonymous temporary file:</source>
          <target state="translated">如果您不需要知道文件名，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 代替文件名。在Perl 5.8或更高版本中， &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 函数创建一个匿名临时文件：</target>
        </trans-unit>
        <trans-unit id="22928fef3e84c8263a53f0cfc23f1b5d448491ff" translate="yes" xml:space="preserve">
          <source>If you don't need to know the name of the file, you can use &lt;code&gt;open()&lt;/code&gt; with &lt;code&gt;undef&lt;/code&gt; in place of the file name. In Perl 5.8 or later, the &lt;code&gt;open()&lt;/code&gt; function creates an anonymous temporary file:</source>
          <target state="translated">如果您不需要知道文件名，则可以使用 &lt;code&gt;open()&lt;/code&gt; 和 &lt;code&gt;undef&lt;/code&gt; 代替文件名。在Perl 5.8或更高版本中， &lt;code&gt;open()&lt;/code&gt; 函数创建一个匿名临时文件：</target>
        </trans-unit>
        <trans-unit id="b260604ab4c441d85ae092e22c063810eb4d30c0" translate="yes" xml:space="preserve">
          <source>If you don't provide an exact inverse transformation, you will find that code like this will not behave as you expect.</source>
          <target state="translated">如果你不提供精确的逆向变换,你会发现这样的代码不会像你期望的那样。</target>
        </trans-unit>
        <trans-unit id="da9f240e2e4669201b3520ed7f3f5a0edd014292" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="translated">如果您真的不想执行第一个参数，而是想对正在执行的程序使用自己的名字说谎，则可以在其中指定要实际运行的程序作为&amp;ldquo;间接对象&amp;rdquo;（不带逗号）。 LIST的前面，如 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 。 （即使列表中只有一个标量，这始终会强制将LIST解释为多值列表。）示例：</target>
        </trans-unit>
        <trans-unit id="90475a6e4998e8131a7d71a411d5204a133b0a81" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="translated">如果您真的不想执行第一个参数，而是想对正在执行的程序使用自己的名字说谎，则可以在其中指定要实际运行的程序作为&amp;ldquo;间接对象&amp;rdquo;（不带逗号）。 LIST的前面，如 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 。 （即使列表中只有一个标量，这始终会强制将LIST解释为多值列表。）示例：</target>
        </trans-unit>
        <trans-unit id="418ff649fbe756afaa4bfbbd2264a36cfbe884b8" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;exec PROGRAM LIST&lt;/code&gt;. (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="translated">如果您真的不想执行第一个参数，而是想对正在执行的程序撒谎，可以使用自己的名称，则可以在其中指定要实际运行的程序作为&amp;ldquo;间接对象&amp;rdquo;（不带逗号）。 LIST的最前面，如 &lt;code&gt;exec PROGRAM LIST&lt;/code&gt; 。（即使列表中只有一个标量，这始终会强制将LIST解释为多值列表。）示例：</target>
        </trans-unit>
        <trans-unit id="24b9da8187ce4c2f915ec1ca4c659113a1fb93a3" translate="yes" xml:space="preserve">
          <source>If you don't run the full test suite, at least &lt;code&gt;make test_porting&lt;/code&gt;. This will run basic sanity checks. To see which sanity checks, have a look in</source>
          <target state="translated">如果您没有运行完整的测试套件，请至少 &lt;code&gt;make test_porting&lt;/code&gt; 。这将运行基本的健全性检查。要查看哪些健全性检查，请查看</target>
        </trans-unit>
        <trans-unit id="1d09c87ff03423122d55e0fe04c7fdafafae320f" translate="yes" xml:space="preserve">
          <source>If you don't see an error message, you have the module. (If you do see an error message, it's still possible you have the module, but that it's not in your path, which you can display with &lt;code&gt;perl -e
&quot;print qq(@INC)&quot;&lt;/code&gt; .) For the remainder of this document, we'll assume that you really honestly truly lack an installed module, but have found it on the CPAN.</source>
          <target state="translated">如果没有看到错误消息，则说明您拥有该模块。（如果确实看到错误消息，则仍然有可能拥有该模块，但该模块不在您的路径中，可以使用 &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt; 显示该路径。）对于本文档的其余部分，我们将假设您确实缺乏安装的模块，但是已经在CPAN上找到了它。</target>
        </trans-unit>
        <trans-unit id="eb0d75079c24e83da6fecb7132e9b60520bba455" translate="yes" xml:space="preserve">
          <source>If you don't see an error message, you have the module. (If you do see an error message, it's still possible you have the module, but that it's not in your path, which you can display with &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt;.) For the remainder of this document, we'll assume that you really honestly truly lack an installed module, but have found it on the CPAN.</source>
          <target state="translated">如果没有看到错误消息，则说明您拥有该模块。（如果确实看到错误消息，那么仍然有可能拥有该模块，但是该模块不在您的路径中，您可以使用 &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt; 来显示该模块。）对于本文档的其余部分，我们将假设您确实缺乏安装的模块，但是已经在CPAN上找到了它。</target>
        </trans-unit>
        <trans-unit id="22a71969f2b2e317963f5563c127a63079459334" translate="yes" xml:space="preserve">
          <source>If you don't specify a &lt;code&gt;dw_size&lt;/code&gt; , it defaults to the entire memory limit.</source>
          <target state="translated">如果不指定 &lt;code&gt;dw_size&lt;/code&gt; ，则默认为整个内存限制。</target>
        </trans-unit>
        <trans-unit id="a1d09f5237198c8d539c87c541eb6e6b72285d75" translate="yes" xml:space="preserve">
          <source>If you don't specify a &lt;code&gt;dw_size&lt;/code&gt;, it defaults to the entire memory limit.</source>
          <target state="translated">如果不指定 &lt;code&gt;dw_size&lt;/code&gt; ，则默认为整个内存限制。</target>
        </trans-unit>
        <trans-unit id="680f0cec0c96fdd6b5789593128bcc203ccf616d" translate="yes" xml:space="preserve">
          <source>If you don't specify a plan, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; expects to see &lt;code&gt;done_testing()&lt;/code&gt; before your program exits. It will warn you if you forget it. You can give &lt;code&gt;done_testing()&lt;/code&gt; an optional number of tests you expected to run, and if the number ran differs, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; will give you another kind of warning.</source>
          <target state="translated">如果您未指定计划，则&lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt;希望在程序退出之前看到 &lt;code&gt;done_testing()&lt;/code&gt; 。如果您忘记它，它将警告您。您可以为 &lt;code&gt;done_testing()&lt;/code&gt; 提供预期运行的可选测试数量，如果运行的数量不同，则&lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt;将给您另一种警告。</target>
        </trans-unit>
        <trans-unit id="d559d6056536d78595c17d437dfe78484f93f47a" translate="yes" xml:space="preserve">
          <source>If you don't understand this question, just press ENTER.</source>
          <target state="translated">如果你不明白这个问题,就按回车键。</target>
        </trans-unit>
        <trans-unit id="e1a9da1b5f8c61c5b3d264532c0386f7656b5414" translate="yes" xml:space="preserve">
          <source>If you don't want &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; to change your original variable you can use the non-destructive substitute modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt;. This changes the behavior so that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; returns the final substituted string (instead of the number of substitutions):</source>
          <target state="translated">如果您不希望 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 更改原始变量，则可以使用非破坏性替换修饰符 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 。这将改变行为，以便 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 返回最终的替换字符串（而不是替换数）：</target>
        </trans-unit>
        <trans-unit id="b16ffc6d1bac1378ef5d03cf556d21c8b3e4f33f" translate="yes" xml:space="preserve">
          <source>If you don't want &lt;code&gt;s///&lt;/code&gt; to change your original variable you can use the non-destructive substitute modifier, &lt;code&gt;s///r&lt;/code&gt;. This changes the behavior so that &lt;code&gt;s///r&lt;/code&gt; returns the final substituted string (instead of the number of substitutions):</source>
          <target state="translated">如果您不希望 &lt;code&gt;s///&lt;/code&gt; 更改原始变量，则可以使用非破坏性替换修饰符 &lt;code&gt;s///r&lt;/code&gt; 。这将改变行为，以便 &lt;code&gt;s///r&lt;/code&gt; 返回最终的替换字符串（而不是替换数）：</target>
        </trans-unit>
        <trans-unit id="b63f96d379f7a46f61c3872f0a57972ef07d6947" translate="yes" xml:space="preserve">
          <source>If you don't want any output should all modules be up to date, parse the output of above command for the regular expression &lt;code&gt;/modules are up to date/&lt;/code&gt; and decide to mail the output only if it doesn't match.</source>
          <target state="translated">如果您不希望所有模块都是最新的输出，请解析上述命令的输出以获取正则表达式 &lt;code&gt;/modules are up to date/&lt;/code&gt; 并决定仅在不匹配时才通过邮件发送。</target>
        </trans-unit>
        <trans-unit id="717adb67f10193acb40c16a22305c4dc8ba0e791" translate="yes" xml:space="preserve">
          <source>If you don't want to create a new hash, you can still use this looping technique; just change the &lt;code&gt;%new_hash&lt;/code&gt; to &lt;code&gt;%hash1&lt;/code&gt; .</source>
          <target state="translated">如果您不想创建新的哈希，则仍然可以使用此循环技术。只需更改 &lt;code&gt;%new_hash&lt;/code&gt; 到 &lt;code&gt;%hash1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="611b9b2078bc455fea7df0c75d337a1c6b770290" translate="yes" xml:space="preserve">
          <source>If you don't want to create a new hash, you can still use this looping technique; just change the &lt;code&gt;%new_hash&lt;/code&gt; to &lt;code&gt;%hash1&lt;/code&gt;.</source>
          <target state="translated">如果您不想创建新的哈希，则仍然可以使用此循环技术。只需更改 &lt;code&gt;%new_hash&lt;/code&gt; 到 &lt;code&gt;%hash1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5861b9dcca59001a7ac94c68a3d243558acaf640" translate="yes" xml:space="preserve">
          <source>If you don't want to install the compiled Perl in AIX into /QOpenSys (for packaging it before copying it to PASE), you can use a Configure parameter: -Dinstallprefix=/tmp/QOpenSys/perl. This will cause the &quot;make install&quot; to install everything into that directory, while the installed files still think they are (will be) in /QOpenSys/perl.</source>
          <target state="translated">如果你不想把在 AIX 中编译的 Perl 安装到 /QOpenSys 中 (为了在复制到 PASE 之前打包),你可以使用 Configure 参数:-Dinstallprefix=/tmp/QOpenSys/perl。这将导致 &quot;make install &quot;把所有的东西都安装到该目录下,而安装的文件仍然认为它们在/QOpenSys/perl中。</target>
        </trans-unit>
        <trans-unit id="ebe8a5460a3cd2a89a4ca3fccf1f4c546c9647e5" translate="yes" xml:space="preserve">
          <source>If you don't want to keep the defaults for the INSTALL* macros, MakeMaker helps you to minimize the typing needed: the usual relationship between INSTALLPRIVLIB and INSTALLARCHLIB is determined by Configure at perl compilation time. MakeMaker supports the user who sets INSTALLPRIVLIB. If INSTALLPRIVLIB is set, but INSTALLARCHLIB not, then MakeMaker defaults the latter to be the same subdirectory of INSTALLPRIVLIB as Configure decided for the counterparts in %Config, otherwise it defaults to INSTALLPRIVLIB. The same relationship holds for INSTALLSITELIB and INSTALLSITEARCH.</source>
          <target state="translated">如果你不想保留INSTALL*宏的默认值,MakeMaker可以帮助你尽量减少所需的键入:INSTALLPRIVLIB和INSTALLARCHLIB之间通常的关系是在perl编译时由Configure决定的。MakeMaker支持设置INSTALLPRIVLIB的用户。如果设置了INSTALLPRIVLIB,但没有设置INSTALLARCHLIB,那么MakeMaker默认后者是INSTALLPRIVLIB的同一个子目录,就像Configure决定的%Config中的对应目录一样,否则默认为INSTALLPRIVLIB。同样的关系也适用于INSTALLSITELIB和INSTALLSITEARCH。</target>
        </trans-unit>
        <trans-unit id="5f0e1c4bb41a9dbee49413981e4f4536890ac2a6" translate="yes" xml:space="preserve">
          <source>If you don't want to modify your source code, but still have on-the-fly warnings, do this:</source>
          <target state="translated">如果你不想修改你的源代码,但仍然有飞行中的警告,可以这样做。</target>
        </trans-unit>
        <trans-unit id="883af52a64cbec821f8f52f9cf06fce4facdd6ad" translate="yes" xml:space="preserve">
          <source>If you don't want to use the objects, you may import the &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method into your namespace as a regular function called &lt;code&gt;stat_cando&lt;/code&gt; . This takes an arrayref containing the return values of &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; as its first argument, and interprets it for you.</source>
          <target state="translated">如果您不想使用对象，则可以将 &lt;code&gt;-&amp;gt;cando&lt;/code&gt; 方法作为名为 &lt;code&gt;stat_cando&lt;/code&gt; 的常规函数导入到您的命名空间中。这将一个包含 &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 返回值的arrayref 作为其第一个参数，并为您解释它。</target>
        </trans-unit>
        <trans-unit id="75651ef23090da325a0156abcf83a5415a24e8bd" translate="yes" xml:space="preserve">
          <source>If you don't want to use the objects, you may import the &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method into your namespace as a regular function called &lt;code&gt;stat_cando&lt;/code&gt;. This takes an arrayref containing the return values of &lt;code&gt;stat&lt;/code&gt; or &lt;code&gt;lstat&lt;/code&gt; as its first argument, and interprets it for you.</source>
          <target state="translated">如果您不想使用这些对象，则可以将 &lt;code&gt;-&amp;gt;cando&lt;/code&gt; 方法作为名为 &lt;code&gt;stat_cando&lt;/code&gt; 的常规函数导入到您的命名空间中。这将一个包含 &lt;code&gt;stat&lt;/code&gt; 或 &lt;code&gt;lstat&lt;/code&gt; 返回值的arrayref作为其第一个参数，并为您解释它。</target>
        </trans-unit>
        <trans-unit id="8ca8817e625d3ffbecabec4b725646c93f6f8e36" translate="yes" xml:space="preserve">
          <source>If you don't wish to do this, set this variable to &lt;code&gt;false&lt;/code&gt; . Understand then that version comparisons are not possible, and Module::Load::Conditional can not tell you what module version you have installed. This may be desirable from a security or performance point of view. Note that &lt;code&gt;$FIND_VERSION&lt;/code&gt; code runs safely under &lt;code&gt;taint mode&lt;/code&gt; .</source>
          <target state="translated">如果您不想这样做，请将此变量设置为 &lt;code&gt;false&lt;/code&gt; 。然后了解不可能进行版本比较，并且Module :: Load :: Conditional无法告诉您已安装的模块版本。从安全性或性能的角度来看，这可能是理想的。请注意， &lt;code&gt;$FIND_VERSION&lt;/code&gt; 代码可以在taint &lt;code&gt;taint mode&lt;/code&gt; 安全运行。</target>
        </trans-unit>
        <trans-unit id="de94190185ca2f3465ff49971ba654614381737e" translate="yes" xml:space="preserve">
          <source>If you don't wish to do this, set this variable to &lt;code&gt;false&lt;/code&gt;. Understand then that version comparisons are not possible, and Module::Load::Conditional can not tell you what module version you have installed. This may be desirable from a security or performance point of view. Note that &lt;code&gt;$FIND_VERSION&lt;/code&gt; code runs safely under &lt;code&gt;taint mode&lt;/code&gt;.</source>
          <target state="translated">如果您不想这样做，请将此变量设置为 &lt;code&gt;false&lt;/code&gt; 。然后，您将无法进行版本比较，并且Module :: Load :: Conditional无法告诉您已安装的模块版本。从安全性或性能的角度来看，这可能是理想的。请注意， &lt;code&gt;$FIND_VERSION&lt;/code&gt; 代码可以在taint &lt;code&gt;taint mode&lt;/code&gt; 安全运行。</target>
        </trans-unit>
        <trans-unit id="1341f2f78549b1827b1d11fb4b0cc0463ec09d6c" translate="yes" xml:space="preserve">
          <source>If you don't, you may experience strange build errors.</source>
          <target state="translated">如果你不这样做,你可能会遇到奇怪的构建错误。</target>
        </trans-unit>
        <trans-unit id="dae8c74471266a8218d010f2ece1eeec7e339df7" translate="yes" xml:space="preserve">
          <source>If you edit</source>
          <target state="translated">如果您编辑</target>
        </trans-unit>
        <trans-unit id="2fb01cc36906ab2ae202731906c27291970214ff" translate="yes" xml:space="preserve">
          <source>If you either have Perl 5.8.0 or later installed, or if you have Scalar-List-Utils 1.03 or later installed, you can say:</source>
          <target state="translated">如果你安装了Perl 5.8.0或更高版本,或者安装了Scalar-List-Utils 1.03或更高版本,你可以说。</target>
        </trans-unit>
        <trans-unit id="09872666932a845e43c465fbd124a59438a49096" translate="yes" xml:space="preserve">
          <source>If you evaluate a hash in scalar context, it returns a false value if the hash is empty. If there are any key/value pairs, it returns a true value. A more precise definition is version dependent.</source>
          <target state="translated">如果你在标量上下文中评估一个哈希,如果哈希是空的,它会返回一个假值。如果有任何键/值对,它返回一个真值。更精确的定义取决于版本。</target>
        </trans-unit>
        <trans-unit id="b892a658ce0764f4b064036e5d8f58bd78f5e370" translate="yes" xml:space="preserve">
          <source>If you evaluate a hash in scalar context, it returns false if the hash is empty. If there are any key/value pairs, it returns true; more precisely, the value returned is a string consisting of the number of used buckets and the number of allocated buckets, separated by a slash. This is pretty much useful only to find out whether Perl's internal hashing algorithm is performing poorly on your data set. For example, you stick 10,000 things in a hash, but evaluating %HASH in scalar context reveals &lt;code&gt;&quot;1/16&quot;&lt;/code&gt; , which means only one out of sixteen buckets has been touched, and presumably contains all 10,000 of your items. This isn't supposed to happen. If a tied hash is evaluated in scalar context, the &lt;code&gt;SCALAR&lt;/code&gt; method is called (with a fallback to &lt;code&gt;FIRSTKEY&lt;/code&gt; ).</source>
          <target state="translated">如果在标量上下文中评估哈希，则如果哈希为空，则返回false。如果有任何键/值对，则返回true；否则，返回true。更确切地说，返回的值是一个字符串，该字符串由已使用的存储桶数和已分配的存储桶数组成，并用斜杠分隔。这仅在发现Perl的内部哈希算法在数据集上是否表现不佳时非常有用。例如，您将10,000个东西粘贴在一个散列中，但是在标量上下文中评估％HASH会显示 &lt;code&gt;&quot;1/16&quot;&lt;/code&gt; ，这意味着仅触摸了16个存储桶中的一个，大概包含了所有10,000个项。这是不应该发生的。如果在标量上下文中计算绑定哈希，则将调用 &lt;code&gt;SCALAR&lt;/code&gt; 方法（回 &lt;code&gt;FIRSTKEY&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8b7212a78497ddedc16438e486691b2144fe7186" translate="yes" xml:space="preserve">
          <source>If you evaluate an array in scalar context, it returns the length of the array. (Note that this is not true of lists, which return the last value, like the C comma operator, nor of built-in functions, which return whatever they feel like returning.) The following is always true:</source>
          <target state="translated">如果你在标量上下文中评估一个数组,它会返回数组的长度。(请注意,这对列表来说不是真的,因为列表会返回最后一个值,就像C语言中的逗号运算符一样,对内置函数来说也不是真的,因为内置函数会返回它们想返回的任何值。)下面的内容永远是真的。</target>
        </trans-unit>
        <trans-unit id="ae75f4b9e5f451131a1e22cec2a555eb5370ed40" translate="yes" xml:space="preserve">
          <source>If you ever see a string that looks like this, you'll know you printed out a reference by mistake.</source>
          <target state="translated">如果你看到一个看起来像这样的字符串,你就会知道你打印出来的引用是错误的。</target>
        </trans-unit>
        <trans-unit id="d2eae54bf1fbe9ae68c160098f500a78269b550c" translate="yes" xml:space="preserve">
          <source>If you execute the &lt;code&gt;T&lt;/code&gt; command from inside an active &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, the backtrace will contain both a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; frame and an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; frame.</source>
          <target state="translated">如果从活动 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句内部执行 &lt;code&gt;T&lt;/code&gt; 命令，则回溯将同时包含 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 框架和 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 框架。</target>
        </trans-unit>
        <trans-unit id="091b3761ddd88c9d0dd9f58cc16fae998cfc428e" translate="yes" xml:space="preserve">
          <source>If you execute the &lt;code&gt;T&lt;/code&gt; command from inside an active &lt;code&gt;use&lt;/code&gt; statement, the backtrace will contain both a &lt;code&gt;require&lt;/code&gt; frame and an &lt;code&gt;eval&lt;/code&gt; frame.</source>
          <target state="translated">如果从活动 &lt;code&gt;use&lt;/code&gt; 语句内部执行 &lt;code&gt;T&lt;/code&gt; 命令，则回溯将同时包含一个 &lt;code&gt;require&lt;/code&gt; 框架和一个 &lt;code&gt;eval&lt;/code&gt; 框架。</target>
        </trans-unit>
        <trans-unit id="e5fd5107f38bc928d4af20adedacdcf1cb44e019" translate="yes" xml:space="preserve">
          <source>If you expect characters to get to your device when you &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; them, you'll want to autoflush that filehandle. You can use &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;$|&lt;/code&gt; variable to control autoflushing (see</source>
          <target state="translated">如果您希望字符在 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 时进入设备，则需要自动刷新该文件句柄。您可以使用 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;$|&lt;/code&gt; 变量以控制自动冲洗（请参见</target>
        </trans-unit>
        <trans-unit id="13366f7fd030f27f570c375099dc54189f595b15" translate="yes" xml:space="preserve">
          <source>If you expect characters to get to your device when you &lt;code&gt;print()&lt;/code&gt; them, you'll want to autoflush that filehandle. You can use &lt;code&gt;select()&lt;/code&gt; and the &lt;code&gt;$|&lt;/code&gt; variable to control autoflushing (see &lt;a href=&quot;perlvar#%24%7C&quot;&gt;&quot;$|&quot; in perlvar&lt;/a&gt; and &lt;a href=&quot;perlfunc#select&quot;&gt;&quot;select&quot; in perlfunc&lt;/a&gt;, or &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt;, &quot;How do I flush/unbuffer an output filehandle? Why must I do this?&quot;):</source>
          <target state="translated">如果您希望字符在 &lt;code&gt;print()&lt;/code&gt; 时进入设备，则需要自动刷新该文件句柄。您可以使用 &lt;code&gt;select()&lt;/code&gt; 和 &lt;code&gt;$|&lt;/code&gt; 变量以控制自动刷新（请参阅&lt;a href=&quot;perlvar#%24%7C&quot;&gt;perlvar中的&amp;ldquo; $ |&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;perlfunc#select&quot;&gt;perlfunc&lt;/a&gt;或&lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5中的&lt;/a&gt;&amp;ldquo; select&amp;rdquo;，&amp;ldquo;如何刷新/取消缓冲输出文件句柄？为什么必须这样做？&amp;rdquo;）：</target>
        </trans-unit>
        <trans-unit id="b65a4bc3927cbd6d7618d76eb545351eb5d8a945" translate="yes" xml:space="preserve">
          <source>If you expect to use both read and write operations on the device, you'll have to open it for update (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for details). You may wish to open it without running the risk of blocking by using &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module (part of the standard perl distribution). See &lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt; for more on this approach.</source>
          <target state="translated">如果您希望在设备上同时使用读写操作，则必须将其打开以进行更新（有关详细信息，请参见&lt;a href=&quot;functions/open&quot;&gt;打开&lt;/a&gt;）。通过使用&lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt;模块（标准perl发行版的一部分 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; ，您可能希望打开它而不会产生阻塞的风险。有关此方法的更多信息，请参见&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c9408c9e8ecf3bf3ccb1ff9f6037ecd31cab34f" translate="yes" xml:space="preserve">
          <source>If you expect to use both read and write operations on the device, you'll have to open it for update (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt; for details). You may wish to open it without running the risk of blocking by using &lt;code&gt;sysopen()&lt;/code&gt; and &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module (part of the standard perl distribution). See &lt;a href=&quot;perlfunc#sysopen&quot;&gt;&quot;sysopen&quot; in perlfunc&lt;/a&gt; for more on this approach.</source>
          <target state="translated">如果希望在设备上同时使用读写操作，则必须将其打开以进行更新（有关详细信息，请参见&lt;a href=&quot;perlfunc#open&quot;&gt;perlfunc中的&amp;ldquo;打开&amp;rdquo;&lt;/a&gt;）。你不妨打开它不运行使用阻塞的风险 &lt;code&gt;sysopen()&lt;/code&gt; 和 &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; 从&lt;a href=&quot;fcntl&quot;&gt;FCNTL&lt;/a&gt;模组（标准perl的一部分）。有关此方法的更多信息，请参见&lt;a href=&quot;perlfunc#sysopen&quot;&gt;perlfunc中的&amp;ldquo; sysopen&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="086943bc39b9078514791bccbde5ea2eddf63045" translate="yes" xml:space="preserve">
          <source>If you fail more than 254 tests, it will be reported as 254.</source>
          <target state="translated">如果你的测试不合格的次数超过254次,就会被报成254次。</target>
        </trans-unit>
        <trans-unit id="cba05a1f1e542bc35030ada7de3e6bf8ced79b98" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt; . Note that you will then need &lt;code&gt;IO::String&lt;/code&gt; installed to support writing stringified archives.</source>
          <target state="translated">如果您强烈希望禁用它，请将此变量设置为 &lt;code&gt;false&lt;/code&gt; 。请注意，然后您将需要安装 &lt;code&gt;IO::String&lt;/code&gt; 以支持编写字符串化的存档。</target>
        </trans-unit>
        <trans-unit id="0eb03812b9a06455d8a297e6d6e18c05b28becbc" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt; . Note that you will then need &lt;code&gt;perlio&lt;/code&gt; support from your perl to be able to write stringified archives.</source>
          <target state="translated">如果您强烈希望禁用它，请将此变量设置为 &lt;code&gt;false&lt;/code&gt; 。请注意，然后您将需要perl的 &lt;code&gt;perlio&lt;/code&gt; 支持，以便能够编写字符串化的存档。</target>
        </trans-unit>
        <trans-unit id="3a8a7ec77511b20c4509af066f4a3c986692847a" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt;. Note that you will then need &lt;code&gt;IO::String&lt;/code&gt; installed to support writing stringified archives.</source>
          <target state="translated">如果您强烈希望禁用它，请将此变量设置为 &lt;code&gt;false&lt;/code&gt; 。请注意，然后您将需要安装 &lt;code&gt;IO::String&lt;/code&gt; 以支持编写字符串化的存档。</target>
        </trans-unit>
        <trans-unit id="fdfe08a0cfcd839078102e8b91b9b69bb63aa64b" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt;. Note that you will then need &lt;code&gt;perlio&lt;/code&gt; support from your perl to be able to write stringified archives.</source>
          <target state="translated">如果您强烈希望禁用它，请将此变量设置为 &lt;code&gt;false&lt;/code&gt; 。请注意，然后您将需要perl的 &lt;code&gt;perlio&lt;/code&gt; 支持，以便能够编写字符串化的存档。</target>
        </trans-unit>
        <trans-unit id="8b50f7e3c982f4c5e423c530952e3d4ee9e5c5f1" translate="yes" xml:space="preserve">
          <source>If you feel the urge to write Perl modules, &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt; will give you good advice.</source>
          <target state="translated">如果您渴望编写Perl模块，&lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt;将为您提供很好的建议。</target>
        </trans-unit>
        <trans-unit id="5e8118a36fba749a624194d24477115572a55b8e" translate="yes" xml:space="preserve">
          <source>If you feel you need to use one of these functions, first send email to &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;perl5-porters@perl.org&lt;/a&gt;. It may be that there is a good reason for the function not being documented, and it should be removed from this list; or it may just be that no one has gotten around to documenting it. In the latter case, you will be asked to submit a patch to document the function. Once your patch is accepted, it will indicate that the interface is stable (unless it is explicitly marked otherwise) and usable by you.</source>
          <target state="translated">如果您需要使用这些功能之一，请首先将电子邮件发送至&lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;perl5-porters@perl.org&lt;/a&gt;。可能有充分的理由未记录该功能，应将其从此列表中删除。或者可能只是没有人到处进行记录。在后一种情况下，系统将要求您提交补丁以记录该功能。一旦您的补丁被接受，它将指示该接口是稳定的（除非以其他方式明确标记）并且可以被您使用。</target>
        </trans-unit>
        <trans-unit id="1ab4e553b43f57ec6c364e3642fd9276b76ed300" translate="yes" xml:space="preserve">
          <source>If you fill comfortable with</source>
          <target state="translated">如果你觉得舒服</target>
        </trans-unit>
        <trans-unit id="d37bfff208b4893c857f8a0e5567752243d86aa9" translate="yes" xml:space="preserve">
          <source>If you find any bugs, &lt;code&gt;Devel::PPPort&lt;/code&gt; doesn't seem to build on your system, or any of its tests fail, please file an issue here: &lt;a href=&quot;https://github.com/mhx/Devel-PPPort/issues/&quot;&gt;https://github.com/mhx/Devel-PPPort/issues/&lt;/a&gt;</source>
          <target state="translated">如果发现任何错误， &lt;code&gt;Devel::PPPort&lt;/code&gt; 似乎未在您的系统上构建，或者其任何测试失败，请在此处提出问题：&lt;a href=&quot;https://github.com/mhx/Devel-PPPort/issues/&quot;&gt;https&lt;/a&gt; : //github.com/mhx/Devel-PPPort/issues/</target>
        </trans-unit>
        <trans-unit id="55c31040a6a87b03d0eac44bd1c63f05031e2f01" translate="yes" xml:space="preserve">
          <source>If you find any bugs, &lt;code&gt;Devel::PPPort&lt;/code&gt; doesn't seem to build on your system, or any of its tests fail, please send a bug report to &lt;a href=&quot;https://github.com/Dual-Life/Devel-PPPort/issues/new&quot;&gt;https://github.com/Dual-Life/Devel-PPPort/issues/new&lt;/a&gt;.</source>
          <target state="translated">如果发现任何错误， &lt;code&gt;Devel::PPPort&lt;/code&gt; 似乎未在您的系统上构建，或者其任何测试失败，请将错误报告发送至&lt;a href=&quot;https://github.com/Dual-Life/Devel-PPPort/issues/new&quot;&gt;https://github.com/Dual-Life/Devel-PPPort/issues /新&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f336ce8c57722e9cc0dd1c79931ced850c7378d" translate="yes" xml:space="preserve">
          <source>If you find any other limitations or bugs then let me know.</source>
          <target state="translated">如果你发现任何其他的限制或错误,那么让我知道。</target>
        </trans-unit>
        <trans-unit id="8d6e534aca61d370cf38f89adc29a8e3c3accf6a" translate="yes" xml:space="preserve">
          <source>If you find bugs in perl, you can report them to &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="translated">如果您在perl中发现错误，则可以将其报告给&lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5ef4696f943b05c3aef9d5f207bfe62cada2927" translate="yes" xml:space="preserve">
          <source>If you find bugs in perl, you can run &lt;code&gt;perlbug&lt;/code&gt; to create a bug report (you may have to send it manually if &lt;code&gt;perlbug&lt;/code&gt; cannot find a mailer on your system).</source>
          <target state="translated">如果在perl中发现错误，则可以运行 &lt;code&gt;perlbug&lt;/code&gt; 来创建错误报告（如果 &lt;code&gt;perlbug&lt;/code&gt; 在系统上找不到邮件，则可能必须手动发送它）。</target>
        </trans-unit>
        <trans-unit id="549be5a33ff1eaf5b330339ea140d5f50a8a508b" translate="yes" xml:space="preserve">
          <source>If you find bugs or if it does not work at all on your device, send mail to the address below. Please report the details of your device (processor, ceversion, devicetype (hpc/palm/pocket)) and the date of the downloaded files.</source>
          <target state="translated">如果您发现错误或在您的设备上根本无法使用,请发送邮件到以下地址。请报告您设备的详细信息(处理器、版本、设备类型(HPC/Palm/Pocket))和下载文件的日期。</target>
        </trans-unit>
        <trans-unit id="ce181ab3a1836691a411c40b59cfd6c2a33af266" translate="yes" xml:space="preserve">
          <source>If you find instances of this in the Perl distribution itself, please let us know, so we can try to work around them.</source>
          <target state="translated">如果你在Perl发行版中发现了这种情况,请告诉我们,这样我们就可以尝试解决这些问题。</target>
        </trans-unit>
        <trans-unit id="a35b038d2558b01a66b6ce215ee08874b540cf15" translate="yes" xml:space="preserve">
          <source>If you find that you do need to update the system Perl, one issue worth keeping in mind is the question of static vs. dynamic libraries. If you upgrade using the default static libperl, you will find that the dynamic libperl supplied by Apple will not be deleted. If both libraries are present when an application that links against libperl is built, ld will link against the dynamic library by default. So, if you need to replace Apple's dynamic libperl with a static libperl, you need to be sure to delete the older dynamic library after you've installed the update.</source>
          <target state="translated">如果你发现确实需要更新系统Perl,有一个问题值得注意,那就是静态库与动态库的问题。如果你使用默认的静态libperl升级,你会发现苹果提供的动态libperl不会被删除。如果在构建针对libperl链接的应用程序时,这两个库都存在,那么ld会默认针对动态库进行链接。所以,如果你需要用静态libperl替换苹果的动态libperl,在安装更新后,你需要确保删除旧的动态库。</target>
        </trans-unit>
        <trans-unit id="8facfef28f917f827b51a8dc9cc5203934df7f46" translate="yes" xml:space="preserve">
          <source>If you find that you need to speed up a specific part of a Perl application (not something you often need) you may want to use C, but you can access this from your Perl code with &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;.</source>
          <target state="translated">如果发现需要加快Perl应用程序的特定部分（不是您经常需要的部分）的速度，则可以使用C，但是您可以使用&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;从Perl代码中访问它。</target>
        </trans-unit>
        <trans-unit id="6d6f2d3762fd66cb49c45a26180601ab0ecbaf26" translate="yes" xml:space="preserve">
          <source>If you find the Calc module to slow, try to install any of the replacement modules and see if they help you.</source>
          <target state="translated">如果你发现Calc模块速度很慢,请尝试安装任何一个替换模块,看看它们是否能帮助你。</target>
        </trans-unit>
        <trans-unit id="9507dd44f0fdbd974fde8543eaceef56a9bf59da" translate="yes" xml:space="preserve">
          <source>If you find the implementation document unclear or not sufficient, look at the existing PerlIO layer implementations, which include:</source>
          <target state="translated">如果你觉得实现文档不清楚或不充分,可以看看现有的PerlIO层实现,其中包括。</target>
        </trans-unit>
        <trans-unit id="bb1a29c843961bd016421afc69613b486ab41b5a" translate="yes" xml:space="preserve">
          <source>If you find this module useful, please consider rating it on the CPAN Ratings service at &lt;a href=&quot;http://cpanratings.perl.org/rate?distribution=autodie&quot;&gt;http://cpanratings.perl.org/rate?distribution=autodie&lt;/a&gt; .</source>
          <target state="translated">如果您发现此模块有用，请考虑在&lt;a href=&quot;http://cpanratings.perl.org/rate?distribution=autodie&quot;&gt;http://cpanratings.perl.org/rate?distribution=autodie&lt;/a&gt;的CPAN评分服务上对其进行评分。</target>
        </trans-unit>
        <trans-unit id="3d0991b7062cd068d03525a35a6b09de37c1af1a" translate="yes" xml:space="preserve">
          <source>If you find this module useful, please consider rating it on the CPAN Ratings service at &lt;a href=&quot;https://cpanratings.perl.org/rate?distribution=autodie&quot;&gt;http://cpanratings.perl.org/rate?distribution=autodie&lt;/a&gt; .</source>
          <target state="translated">如果您发现此模块有用，请考虑在&lt;a href=&quot;https://cpanratings.perl.org/rate?distribution=autodie&quot;&gt;http://cpanratings.perl.org/rate?distribution=autodie&lt;/a&gt;的CPAN评分服务上对其进行评分。</target>
        </trans-unit>
        <trans-unit id="8307a7110288b02faca83e75adb216a84beaca75" translate="yes" xml:space="preserve">
          <source>If you find you need to provide custom functionality (as you would have using &lt;a href=&quot;Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;), you're in luck: &lt;code&gt;TAP::Parser&lt;/code&gt; and friends are designed to be easily plugged-into and/or subclassed.</source>
          <target state="translated">如果发现需要提供自定义功能（就像使用&lt;a href=&quot;Test::Harness::Straps&quot;&gt;Test :: Harness :: Straps一样&lt;/a&gt;），那么您会很幸运： &lt;code&gt;TAP::Parser&lt;/code&gt; 和朋友被设计为易于插入和/或子类化。</target>
        </trans-unit>
        <trans-unit id="5afed98244534d5e7bd9f07d6f953a138ea4f8e9" translate="yes" xml:space="preserve">
          <source>If you find you need to provide custom functionality (as you would have using &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;), you're in luck: &lt;code&gt;TAP::Parser&lt;/code&gt; and friends are designed to be easily plugged-into and/or subclassed.</source>
          <target state="translated">如果您发现需要提供自定义功能（就像使用&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test :: Harness :: Straps一样&lt;/a&gt;），那么您会很幸运： &lt;code&gt;TAP::Parser&lt;/code&gt; 和朋友被设计为易于插入和/或子类化。</target>
        </trans-unit>
        <trans-unit id="e0f3870d3b01febf6f7490ea91b0d476cdafaf0c" translate="yes" xml:space="preserve">
          <source>If you find you really need to use your own iterator factory you can still do so without sub-classing &lt;code&gt;TAP::Parser&lt;/code&gt; by setting &lt;a href=&quot;#iterator_factory_class&quot;&gt;&quot;iterator_factory_class&quot;&lt;/a&gt;.</source>
          <target state="translated">如果发现确实需要使用自己的迭代器工厂，则仍然可以通过设置&lt;a href=&quot;#iterator_factory_class&quot;&gt;&amp;ldquo; iterator_factory_class&amp;rdquo;来对&lt;/a&gt; &lt;code&gt;TAP::Parser&lt;/code&gt; 进行子类化而无需这样做。</target>
        </trans-unit>
        <trans-unit id="7eaae25128643ba9a8e9cd9fd035b84dc1c8a6c4" translate="yes" xml:space="preserve">
          <source>If you find you really need to use your own iterator factory you can still do so without sub-classing &lt;code&gt;TAP::Parser&lt;/code&gt; by setting &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt;.</source>
          <target state="translated">如果发现确实需要使用自己的迭代器工厂，则仍然可以通过设置&lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class来对&lt;/a&gt; &lt;code&gt;TAP::Parser&lt;/code&gt; 进行子类化而无需这样做。</target>
        </trans-unit>
        <trans-unit id="ef253d4b5355af7bdf0e5249c9becef0fb63f08e" translate="yes" xml:space="preserve">
          <source>If you for some reason (such as binary backward compatibility) really need to use perl's malloc, you can rebuild perl from the sources and Configure the build with</source>
          <target state="translated">如果你出于某些原因(比如二进制后向兼容)真的需要使用perl的malloc,你可以从源码中重建perl,然后用以下方法配置构建。</target>
        </trans-unit>
        <trans-unit id="a38ea3094c2349d48a8464c8b2ede590e7cc8393" translate="yes" xml:space="preserve">
          <source>If you forget &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , high bytes will be misunderstood as separate characters, and nothing will work right.</source>
          <target state="translated">如果您忘记 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; ，高字节将被误认为是单独的字符，并且将无法正常工作。</target>
        </trans-unit>
        <trans-unit id="1c95ef6991d8327e95ef74bf4e7dd1e20f49af62" translate="yes" xml:space="preserve">
          <source>If you forget &lt;code&gt;use utf8&lt;/code&gt;, high bytes will be misunderstood as separate characters, and nothing will work right.</source>
          <target state="translated">如果您忘记 &lt;code&gt;use utf8&lt;/code&gt; ，高字节将被误认为是单独的字符，并且将无法正常工作。</target>
        </trans-unit>
        <trans-unit id="5c73cb5a6222b98080e0788ac4c8f896039ff111" translate="yes" xml:space="preserve">
          <source>If you forget to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , you'll miss out entirely on the helpful diagnostic message:</source>
          <target state="translated">如果您忘记 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ，则会完全忽略有用的诊断消息：</target>
        </trans-unit>
        <trans-unit id="f4036448bea62235f8e0ea98c0684157616bfe9e" translate="yes" xml:space="preserve">
          <source>If you forget to &lt;code&gt;use warnings&lt;/code&gt;, you'll miss out entirely on the helpful diagnostic message:</source>
          <target state="translated">如果您忘记 &lt;code&gt;use warnings&lt;/code&gt; ，则会完全忽略有用的诊断消息：</target>
        </trans-unit>
        <trans-unit id="4e4db242421a858aa14b9bcaa4e5f3862b8a23c5" translate="yes" xml:space="preserve">
          <source>If you get a core dump (or equivalent), you may use a debugger (&lt;b&gt;dbx&lt;/b&gt;, &lt;b&gt;gdb&lt;/b&gt;, etc) to produce a stack trace to include in the bug report.</source>
          <target state="translated">如果获得核心转储（或等效的转储），则可以使用调试器（&lt;b&gt;dbx&lt;/b&gt;，&lt;b&gt;gdb&lt;/b&gt;等）来生成要包含在错误报告中的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="722060cb13bfb62427a93bad15761822b6a7686d" translate="yes" xml:space="preserve">
          <source>If you get a message like &quot;perl: command not found&quot;, perl is not in your PATH, which might also mean that the location of perl is not where you expect it so you need to adjust your shebang line.</source>
          <target state="translated">如果你收到 &quot;perl:command not found &quot;这样的消息,说明perl不在你的PATH里,这也可能意味着perl的位置不在你期望的地方,所以你需要调整你的shebang行。</target>
        </trans-unit>
        <trans-unit id="6bc5836fc16b720e6dc1a4fbf9bbeb14813f0dae" translate="yes" xml:space="preserve">
          <source>If you get an error like</source>
          <target state="translated">如果你得到一个错误,如</target>
        </trans-unit>
        <trans-unit id="e71cc5ed2d43a688912302c22a7a0e3e08b5d7b1" translate="yes" xml:space="preserve">
          <source>If you get an error message</source>
          <target state="translated">如果你得到一个错误信息</target>
        </trans-unit>
        <trans-unit id="8b6135f8eeab8f4ac6ffe0b88df52abad52ae3b4" translate="yes" xml:space="preserve">
          <source>If you get complaints about so_locations then search in the file hints/irix_6.sh for &quot;lddflags&quot; and do the suggested adjustments. (David Billinghurst &amp;lt;David.Billinghurst@riotinto.com.au&amp;gt;)</source>
          <target state="translated">如果您对so_locations有所投诉，请在hints / irix_6.sh文件中搜索&amp;ldquo; lddflags&amp;rdquo;，然后进行建议的调整。（戴维&amp;middot;比林赫斯特&amp;lt;David.Billinghurst@riotinto.com.au&amp;gt;）</target>
        </trans-unit>
        <trans-unit id="0d74278837310505aa97f12b787c58f0bb90e74c" translate="yes" xml:space="preserve">
          <source>If you get lots of errors of the form</source>
          <target state="translated">如果你得到很多错误的形式</target>
        </trans-unit>
        <trans-unit id="0e2cd49639ef6344568879d541e1a269a34ede3d" translate="yes" xml:space="preserve">
          <source>If you get the error</source>
          <target state="translated">如果你收到错误信息</target>
        </trans-unit>
        <trans-unit id="39b025fcc6f0d1c529cf233b24ac57e017d8f611" translate="yes" xml:space="preserve">
          <source>If you get this message on SunOS or Solaris, and you're using gcc, it's probably the GNU as or GNU ld problem in the previous item &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;&quot;GNU as and GNU ld&quot;&lt;/a&gt;.</source>
          <target state="translated">如果在SunOS或Solaris上收到此消息，并且使用的是gcc，则可能是前一项&lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;&amp;ldquo; GNU as and GNU ld&amp;rdquo;中&lt;/a&gt;的GNU as或GNU ld问题。</target>
        </trans-unit>
        <trans-unit id="91993b40c91822c3454671d4c8a24b32c3e646ba" translate="yes" xml:space="preserve">
          <source>If you get this message on SunOS or Solaris, and you're using gcc, it's probably the GNU as or GNU ld problem in the previous item &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as and GNU ld&lt;/a&gt;.</source>
          <target state="translated">如果您在SunOS或Solaris上收到此消息，并且使用的是gcc，则可能是前一项&lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as和GNU ld中&lt;/a&gt;的GNU as或GNU ld问题。</target>
        </trans-unit>
        <trans-unit id="36f4dbd793640e550ca076d30024d627de795ab8" translate="yes" xml:space="preserve">
          <source>If you get tired of being subject to your platform's native integers, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; pragma neatly sidesteps the issue altogether:</source>
          <target state="translated">如果您厌倦了受制于平台的本机整数，则 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; pragma会巧妙地完全避开该问题：</target>
        </trans-unit>
        <trans-unit id="69ba4fd6db8745c64a8a60725ff36af2b0505794" translate="yes" xml:space="preserve">
          <source>If you get tired of being subject to your platform's native integers, the &lt;code&gt;use bigint&lt;/code&gt; pragma neatly sidesteps the issue altogether:</source>
          <target state="translated">如果您厌倦了受制于平台的本机整数，则 &lt;code&gt;use bigint&lt;/code&gt; pragma会巧妙地完全避开该问题：</target>
        </trans-unit>
        <trans-unit id="a28e8a38182dc716f4c7bb3a2e2a63a098694e97" translate="yes" xml:space="preserve">
          <source>If you get tired of constantly saying &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; $lh-&amp;gt;maketext&lt;/code&gt; , consider making a functional wrapper for it, like so:</source>
          <target state="translated">如果您厌倦了不停地说 &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; $lh-&amp;gt;maketext&lt;/code&gt; ，请考虑为其创建一个功能包装器，如下所示：</target>
        </trans-unit>
        <trans-unit id="f2e5f31a627306a3c5068e17e18a085ffc1169d9" translate="yes" xml:space="preserve">
          <source>If you get tired of constantly saying &lt;code&gt;print $lh-&amp;gt;maketext&lt;/code&gt;, consider making a functional wrapper for it, like so:</source>
          <target state="translated">如果您厌倦了不停地说 &lt;code&gt;print $lh-&amp;gt;maketext&lt;/code&gt; ，请考虑为其制作一个功能性包装器，如下所示：</target>
        </trans-unit>
        <trans-unit id="572c0959177d510f33c38a6508a8f796163c8877" translate="yes" xml:space="preserve">
          <source>If you get tired of remembering which element of the return list contains which return value, by-name interfaces are provided in standard modules: &lt;a href=&quot;File::stat&quot;&gt;&lt;code&gt;File::stat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Net::hostent&quot;&gt;&lt;code&gt;Net::hostent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Net::netent&quot;&gt;&lt;code&gt;Net::netent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Net::protoent&quot;&gt;&lt;code&gt;Net::protoent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Net::servent&quot;&gt;&lt;code&gt;Net::servent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Time::gmtime&quot;&gt;&lt;code&gt;Time::gmtime&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Time::localtime&quot;&gt;&lt;code&gt;Time::localtime&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;User::grent&quot;&gt;&lt;code&gt;User::grent&lt;/code&gt;&lt;/a&gt;. These override the normal built-ins, supplying versions that return objects with the appropriate names for each field. For example:</source>
          <target state="translated">如果您不记得返回列表中的哪个元素包含哪个返回值，则在标准模块中提供按名称命名的接口：&lt;a href=&quot;File::stat&quot;&gt; &lt;code&gt;File::stat&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;Net::hostent&quot;&gt; &lt;code&gt;Net::hostent&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;Net::netent&quot;&gt; &lt;code&gt;Net::netent&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;Net::protoent&quot;&gt; &lt;code&gt;Net::protoent&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;Net::servent&quot;&gt; &lt;code&gt;Net::servent&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;Time::gmtime&quot;&gt; &lt;code&gt;Time::gmtime&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;Time::localtime&quot;&gt; &lt;code&gt;Time::localtime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;User::grent&quot;&gt; &lt;code&gt;User::grent&lt;/code&gt; &lt;/a&gt;。它们覆盖了普通的内置函数，提供的版本将为每个字段返回具有适当名称的对象。例如：</target>
        </trans-unit>
        <trans-unit id="693c393f75e992e3003bea94747936126a6b0327" translate="yes" xml:space="preserve">
          <source>If you get tired of remembering which element of the return list contains which return value, by-name interfaces are provided in standard modules: &lt;code&gt;File::stat&lt;/code&gt; , &lt;code&gt;Net::hostent&lt;/code&gt; , &lt;code&gt;Net::netent&lt;/code&gt; , &lt;code&gt;Net::protoent&lt;/code&gt; , &lt;code&gt;Net::servent&lt;/code&gt; , &lt;code&gt;Time::gmtime&lt;/code&gt; , &lt;code&gt;Time::localtime&lt;/code&gt; , and &lt;code&gt;User::grent&lt;/code&gt; . These override the normal built-ins, supplying versions that return objects with the appropriate names for each field. For example:</source>
          <target state="translated">如果您厌倦了记住返回列表中的哪个元素包含哪个返回值，则在标准模块中提供按名称命名的接口： &lt;code&gt;File::stat&lt;/code&gt; ， &lt;code&gt;Net::hostent&lt;/code&gt; ， &lt;code&gt;Net::netent&lt;/code&gt; ， &lt;code&gt;Net::protoent&lt;/code&gt; ， &lt;code&gt;Net::servent&lt;/code&gt; ， &lt;code&gt;Time::gmtime&lt;/code&gt; ， &lt;code&gt;Time::localtime&lt;/code&gt; 和 &lt;code&gt;User::grent&lt;/code&gt; 。它们覆盖了普通的内置组件，提供的版本会为每个字段返回具有适当名称的对象。例如：</target>
        </trans-unit>
        <trans-unit id="b8e0fc194ad5e5c2cd16a3f242684fe425f3428b" translate="yes" xml:space="preserve">
          <source>If you get used to writing odd things like these:</source>
          <target state="translated">如果你习惯了写这种奇怪的东西。</target>
        </trans-unit>
        <trans-unit id="0cd15dd92a142244892a9be7434b98670ff15dc6" translate="yes" xml:space="preserve">
          <source>If you had &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %Foo::Bar::QUUX&lt;/code&gt; to check whether such a package variable exists then that's never really been reliable, and isn't a good way to enquire about the features of a package, or whether it's loaded, etc.</source>
          <target state="translated">如果您已 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %Foo::Bar::QUUX&lt;/code&gt; 来检查是否存在这样的程序包变量，那么这将永远是不可靠的，并且不是查询程序包功能或是否已加载程序包的好方法。</target>
        </trans-unit>
        <trans-unit id="3a8d785689c76bcc85c3a87585c7936ee4bbbc6c" translate="yes" xml:space="preserve">
          <source>If you had &lt;code&gt;defined %Foo::Bar::QUUX&lt;/code&gt; to check whether such a package variable exists then that's never really been reliable, and isn't a good way to enquire about the features of a package, or whether it's loaded, etc.</source>
          <target state="translated">如果您已 &lt;code&gt;defined %Foo::Bar::QUUX&lt;/code&gt; 来检查是否存在这样的程序包变量，那么这将永远是不可靠的，也不是查询程序包功能或是否已加载等的好方法。</target>
        </trans-unit>
        <trans-unit id="4ef8417488b5df9f33f3d1b38e3847657756981c" translate="yes" xml:space="preserve">
          <source>If you had to get a variable through, you could do this:</source>
          <target state="translated">如果你必须要把一个变量打通,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="67b4946ef744afdd9a1b21f685b5b8e140afa4b4" translate="yes" xml:space="preserve">
          <source>If you have</source>
          <target state="translated">如果你有</target>
        </trans-unit>
        <trans-unit id="5887bd3238a6e02f0034680e74b35124b3f3183f" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;File::Stream&quot;&gt;File::Stream&lt;/a&gt;, this is easy.</source>
          <target state="translated">如果您有&lt;a href=&quot;File::Stream&quot;&gt;File :: Stream&lt;/a&gt;，这很容易。</target>
        </trans-unit>
        <trans-unit id="aebe0c8d3505d2fdad4a2b644054c80705f47533" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module installed from CPAN, you can use it to fetch the width and height in characters and in pixels:</source>
          <target state="translated">如果从CPAN安装了&lt;a href=&quot;Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt;模块，则可以使用它来获取字符和像素的宽度和高度：</target>
        </trans-unit>
        <trans-unit id="8ebbe151437cc5de6b126287c5035e996e85c741" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;http://search.cpan.org/perldoc/File::Stream&quot;&gt;File::Stream&lt;/a&gt;, this is easy.</source>
          <target state="translated">如果您有&lt;a href=&quot;http://search.cpan.org/perldoc/File::Stream&quot;&gt;File :: Stream&lt;/a&gt;，这很容易。</target>
        </trans-unit>
        <trans-unit id="8477c0614e083a37a8e560c57638a0b5f36ef52b" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module installed from CPAN, you can use it to fetch the width and height in characters and in pixels:</source>
          <target state="translated">如果从CPAN安装了&lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt;模块，则可以使用它来获取字符和像素的宽度和高度：</target>
        </trans-unit>
        <trans-unit id="7230ece2e031d91cec5a13b629b5ff58c45c8753" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;IPC::Run&lt;/code&gt; installed, and the variable &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; is set to true (See the &lt;a href=&quot;#Global-Variables&quot;&gt;&quot;Global Variables&quot;&lt;/a&gt; section) use that to execute the command. You will have the full output available in buffers, interactive commands are sure to work and you are guaranteed to have your verbosity settings honored cleanly.</source>
          <target state="translated">如果安装了 &lt;code&gt;IPC::Run&lt;/code&gt; ，并且变量 &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; 设置为true（请参见&lt;a href=&quot;#Global-Variables&quot;&gt;&amp;ldquo;全局变量&amp;rdquo;&lt;/a&gt;部分），则使用该命令执行命令。您将在缓冲区中获得完整的输出，交互式命令必定会起作用，并且可以确保您的冗长设置得到明确的尊重。</target>
        </trans-unit>
        <trans-unit id="240e14e2dd47b4fb473147b6d297b2d7726b59cc" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;IPC::Run&lt;/code&gt; installed, and the variable &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; is set to true (See the &lt;a href=&quot;#Global-Variables&quot;&gt;Global Variables&lt;/a&gt; section) use that to execute the command. You will have the full output available in buffers, interactive commands are sure to work and you are guaranteed to have your verbosity settings honored cleanly.</source>
          <target state="translated">如果安装了 &lt;code&gt;IPC::Run&lt;/code&gt; ，并且变量 &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; 设置为true（请参阅&amp;ldquo; &lt;a href=&quot;#Global-Variables&quot;&gt;全局变量&amp;rdquo;&lt;/a&gt;部分），则可以使用该命令执行命令。您将在缓冲区中获得完整的输出，交互式命令确保可以正常工作，并且确保您的详细程度设置明确无误。</target>
        </trans-unit>
        <trans-unit id="b8acd2601ad065393113859c8a7e3855297ce5ac" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;man&lt;/code&gt; installed on your system, and you installed perl manpages, use something like this:</source>
          <target state="translated">如果您的系统上安装了 &lt;code&gt;man&lt;/code&gt; ，并且安装了perl手册页，请使用以下命令：</target>
        </trans-unit>
        <trans-unit id="d6036be6bd4d2a23f70dfe8c9f989a5911198ccc" translate="yes" xml:space="preserve">
          <source>If you have Perl 5.10 or later, and you just want to store a value against the reference for lookup later, you can use the core Hash::Util::Fieldhash module. This will also handle renaming the keys if you use multiple threads (which causes all variables to be reallocated at new addresses, changing their stringification), and garbage-collecting the entries when the referenced variable goes out of scope.</source>
          <target state="translated">如果你使用的是Perl 5.10或更高版本,并且你只是想存储一个值以备以后查找,你可以使用核心的Hash::Util::Fieldhash模块。如果你使用多个线程,它还会处理键的重命名(这会导致所有变量在新的地址上被重新分配,改变它们的字符串化),以及当被引用的变量超出范围时垃圾回收条目。</target>
        </trans-unit>
        <trans-unit id="1ff5e330b4023d9ffe19df36972bfcc73814fd9b" translate="yes" xml:space="preserve">
          <source>If you have Perl 5.10 or later, this is almost trivial. You just smart match against an array of regular expression objects:</source>
          <target state="translated">如果你有Perl 5.10或更高版本,这几乎是微不足道的。你只需对一个正则表达式对象数组进行智能匹配。</target>
        </trans-unit>
        <trans-unit id="f112acda35554c21f927d9597b0b2023538c4e09" translate="yes" xml:space="preserve">
          <source>If you have Perl v5.16 or v5.18 and can't upgrade, you can use</source>
          <target state="translated">如果你的Perl v5.16或v5.18无法升级,你可以使用</target>
        </trans-unit>
        <trans-unit id="2fe696e9056ea562cb89c9b2f102390c60db24f0" translate="yes" xml:space="preserve">
          <source>If you have Perl v5.16, the problems mentioned above go away if you use the &lt;code&gt;:not_characters&lt;/code&gt; parameter to the locale pragma (except for vendor bugs in the non-character portions). If you don't have v5.16, and you</source>
          <target state="translated">如果您具有Perl v5.16，则对区域设置用法使用 &lt;code&gt;:not_characters&lt;/code&gt; 参数，上述问题将消失（非字符部分中的供应商错误除外）。如果您没有v5.16，并且您</target>
        </trans-unit>
        <trans-unit id="6642f62c4bfdebf5e62452d5d72c26f1bd89b8ec" translate="yes" xml:space="preserve">
          <source>If you have YAML.pm (or some other YAML module configured in &lt;code&gt;yaml_module&lt;/code&gt; ) installed, CPAN.pm collects a few statistical data about recent downloads. You can view the statistics with the &lt;code&gt;hosts&lt;/code&gt; command or inspect them directly by looking into the &lt;code&gt;FTPstats.yml&lt;/code&gt; file in your &lt;code&gt;cpan_home&lt;/code&gt; directory.</source>
          <target state="translated">如果您安装了YAML.pm（或在 &lt;code&gt;yaml_module&lt;/code&gt; 中配置的其他一些YAML模块），则CPAN.pm会收集一些有关最近下载的统计数据。您可以使用 &lt;code&gt;hosts&lt;/code&gt; 命令查看统计信息，也可以通过查看 &lt;code&gt;cpan_home&lt;/code&gt; 目录中的 &lt;code&gt;FTPstats.yml&lt;/code&gt; 文件直接检查统计信息。</target>
        </trans-unit>
        <trans-unit id="225c354ad980b0b7bb691380c5b2f0d3c2643a5a" translate="yes" xml:space="preserve">
          <source>If you have a ReadLine module installed, you can hit TAB at any point of the commandline and &lt;code&gt;o conf&lt;/code&gt; will offer you completion for the built-in subcommands and/or config variable names.</source>
          <target state="translated">如果安装了ReadLine模块，则可以在命令行的任何位置点击TAB， &lt;code&gt;o conf&lt;/code&gt; 将为您提供内置子命令和/或配置变量名称的完成信息。</target>
        </trans-unit>
        <trans-unit id="86d2e902132f610059a158729cf105aa2e1d4e91" translate="yes" xml:space="preserve">
          <source>If you have a buffer allocated with Newx() and want to set that as the SV's value, you can use sv_usepvn_flags(). That has some requirements if you want to avoid perl re-allocating the buffer to fit the trailing NUL:</source>
          <target state="translated">如果你有一个用Newx()分配的缓冲区,并且想把它设置为SV的值,你可以使用sv_usepvn_flags()。如果你想避免perl重新分配缓冲区以适应尾部的NUL,这有一些要求。</target>
        </trans-unit>
        <trans-unit id="28b93e0d6dcdb9743374e046e2c50f7ec24b530d" translate="yes" xml:space="preserve">
          <source>If you have a burning desire to tell the world about your release, post an announcement to the moderated &lt;code&gt;comp.lang.perl.announce&lt;/code&gt; newsgroup.</source>
          <target state="translated">如果您有向世人讲述发布的强烈愿望，请在主持人的 &lt;code&gt;comp.lang.perl.announce&lt;/code&gt; 新闻组中发布公告。</target>
        </trans-unit>
        <trans-unit id="2ed22a427a030ed732816620f86f5c52ec466566" translate="yes" xml:space="preserve">
          <source>If you have a command-line program that does the job, you can call it in backticks to capture whatever it outputs so you can use it later:</source>
          <target state="translated">如果你有一个命令行程序来完成这项工作,你可以用回标调用它来捕捉它输出的任何东西,以便你以后可以使用它。</target>
        </trans-unit>
        <trans-unit id="aabc7446c5d3e0c2ebc9233bf601a7899d673f9d" translate="yes" xml:space="preserve">
          <source>If you have a commit bit, please see &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt; for more details on using git.</source>
          <target state="translated">如果您有提交位，请参阅&lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt;以获得有关使用git的更多详细信息。</target>
        </trans-unit>
        <trans-unit id="392daf22cd236f28ba9ceee336856176b759059d" translate="yes" xml:space="preserve">
          <source>If you have a complicated function needed to pull out the part you want to sort on, then don't do it inside the sort function. Pull it out first, because the sort BLOCK can be called many times for the same element. Here's an example of how to pull out the first word after the first number on each item, and then sort those words case-insensitively.</source>
          <target state="translated">如果你有一个复杂的函数需要拉出你要排序的部分,那么不要在排序函数里面做。先把它拉出来,因为同一个元素的排序BLOCK可以被调用很多次。下面是一个例子,如何在每个项目上拉出第一个数字后面的第一个单词,然后对这些单词进行大小写不敏感的排序。</target>
        </trans-unit>
        <trans-unit id="b0e6b3bda8c96c33f56e6b729af6c8286cbfdc17" translate="yes" xml:space="preserve">
          <source>If you have a legacy encoding, you can use the &lt;code&gt;:encoding(...)&lt;/code&gt; tag.</source>
          <target state="translated">如果您使用的是旧版编码，则可以使用 &lt;code&gt;:encoding(...)&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="01656c2b4f7ea5f69bae8d5caaac9ea48410bb3e" translate="yes" xml:space="preserve">
          <source>If you have a library that provides an API, you can make any component of it available as just another Perl function or variable using a Perl extension written in C or C++ and dynamically linked into your main perl interpreter. You can also go the other direction, and write your main program in C or C++, and then link in some Perl code on the fly, to create a powerful application. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">如果您有提供API的库，则可以使用以C或C ++编写的Perl扩展并将其动态链接到您的主要perl解释器中，使其任何组件仅作为另一个Perl函数或变量可用。您也可以朝另一个方向发展，用C或C ++编写主程序，然后动态链接一些Perl代码，以创建功能强大的应用程序。见&lt;a href=&quot;perlembed&quot;&gt;临危&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51f9e3f6122598346b767c490154d73f3d45b4f6" translate="yes" xml:space="preserve">
          <source>If you have a list of tests (or URLs, or anything else you want to test) in a file, you can add them to your tests by using a '-':</source>
          <target state="translated">如果你有一个文件中的测试列表(或URL,或其他任何你想测试的东西),你可以通过使用'-'将它们添加到你的测试中。</target>
        </trans-unit>
        <trans-unit id="a1add680b7e930dc8542127166a2c6922328bade" translate="yes" xml:space="preserve">
          <source>If you have a local mirror of CPAN and can access all files with &quot;file:&quot; URLs, then you only need a perl later than perl5.003 to run this module. Otherwise Net::FTP is strongly recommended. LWP may be required for non-UNIX systems, or if your nearest CPAN site is associated with a URL that is not &lt;code&gt;ftp:&lt;/code&gt; .</source>
          <target state="translated">如果您具有CPAN的本地镜像，并且可以访问带有&amp;ldquo; file：&amp;rdquo; URL的所有文件，则只需要晚于perl5.003的perl即可运行此模块。否则，强烈建议使用Net :: FTP。对于非UNIX系统，或者如果您最近的CPAN站点与非 &lt;code&gt;ftp:&lt;/code&gt; 的URL关联，则可能需要LWP 。</target>
        </trans-unit>
        <trans-unit id="cc89a24f0e796df127e886da4fce9233949042a4" translate="yes" xml:space="preserve">
          <source>If you have a module that uses a decimal $VERSION (floating point), and you do not intend to ever change that, this module is not for you. There is nothing that version.pm gains you over a simple $VERSION assignment:</source>
          <target state="translated">如果你有一个使用十进制$VERSION(浮点)的模块,并且你不打算改变它,那么这个模块不适合你。version.pm对你来说并没有比简单的$VERSION赋值带来任何好处。</target>
        </trans-unit>
        <trans-unit id="44d0404e38c1a8f4fe7f4884e84970ffe1a562e8" translate="yes" xml:space="preserve">
          <source>If you have a question you'd like to see added to the FAQ (whether or not you have the answer) please either:</source>
          <target state="translated">如果你有一个问题想添加到FAQ中(不管你是否有答案),请要么。</target>
        </trans-unit>
        <trans-unit id="3c6b091f1c2f3916b6f982ec5d76127aba417742" translate="yes" xml:space="preserve">
          <source>If you have a question you'd like to see added to the FAQ (whether or not you have the answer) please send it to makemaker@perl.org.</source>
          <target state="translated">如果你有一个问题想添加到FAQ中(无论你是否有答案),请将其发送到makemaker@perl.org。</target>
        </trans-unit>
        <trans-unit id="883ef441e28a9d839f80a61f11348168ebf17cd9" translate="yes" xml:space="preserve">
          <source>If you have a raw sequence of bytes that you know should be interpreted via a particular encoding, you can use &lt;code&gt;Encode&lt;/code&gt; :</source>
          <target state="translated">如果您知道应通过特定编码解释的原始字节序列，则可以使用 &lt;code&gt;Encode&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5b4a02619440b043ea55b1e3e613964a4f9957c4" translate="yes" xml:space="preserve">
          <source>If you have a raw sequence of bytes that you know should be interpreted via a particular encoding, you can use &lt;code&gt;Encode&lt;/code&gt;:</source>
          <target state="translated">如果您知道应该通过特定编码解释的原始字节序列，则可以使用 &lt;code&gt;Encode&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4977b6a1b7796edc98abe66364bdbf5af8c6caa8" translate="yes" xml:space="preserve">
          <source>If you have a really hairy regular expression, use the &lt;code&gt;/x&lt;/code&gt; modifier and put in some whitespace to make it look a little less like line noise. Don't use slash as a delimiter when your regexp has slashes or backslashes.</source>
          <target state="translated">如果您的正则表达式真的很毛茸茸，请使用 &lt;code&gt;/x&lt;/code&gt; 修饰符并放入一些空格，使其看起来更像行噪。当您的regexp有斜杠或反斜杠时，请勿使用斜杠作为分隔符。</target>
        </trans-unit>
        <trans-unit id="df35f05fcbbff85a11dabd04bca96051a29d5068" translate="yes" xml:space="preserve">
          <source>If you have a really hairy regular expression, use the &lt;code&gt;/x&lt;/code&gt; or &lt;code&gt;/xx&lt;/code&gt; modifiers and put in some whitespace to make it look a little less like line noise. Don't use slash as a delimiter when your regexp has slashes or backslashes.</source>
          <target state="translated">如果您的正则表达式真的很毛茸茸，请使用 &lt;code&gt;/x&lt;/code&gt; 或 &lt;code&gt;/xx&lt;/code&gt; 修饰符，并在其中添加一些空格，以使其看起来不太像行噪。当您的regexp有斜杠或反斜杠时，请勿使用斜杠作为分隔符。</target>
        </trans-unit>
        <trans-unit id="c4670adaa2657eda2badbded5180916956105a77" translate="yes" xml:space="preserve">
          <source>If you have a sequence of bytes you &lt;b&gt;know&lt;/b&gt; is valid UTF-8, but Perl doesn't know it yet, you can make Perl a believer, too:</source>
          <target state="translated">如果您有一个字节序列，则&lt;b&gt;知道&lt;/b&gt;是有效的UTF-8，但Perl尚不知道，您也可以使Perl成为一个信徒：</target>
        </trans-unit>
        <trans-unit id="9756e7acda84539ead2e5f85f560f283b75aed93" translate="yes" xml:space="preserve">
          <source>If you have a single string that you want to check for &quot;equality in locale&quot; against several others, you might think you could gain a little efficiency by using &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; in conjunction with &lt;code&gt;eq&lt;/code&gt; :</source>
          <target state="translated">如果您有一个字符串要与其他字符串检查&amp;ldquo;语言环境是否相等&amp;rdquo;，您可能会认为通过将 &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; 与 &lt;code&gt;eq&lt;/code&gt; 结合使用可以提高效率：</target>
        </trans-unit>
        <trans-unit id="f95d4b51e2c5877925e6bfc513dc2300a8f4721e" translate="yes" xml:space="preserve">
          <source>If you have a single string that you want to check for &quot;equality in locale&quot; against several others, you might think you could gain a little efficiency by using &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; in conjunction with &lt;code&gt;eq&lt;/code&gt;:</source>
          <target state="translated">如果您有一个字符串要与其他字符串检查&amp;ldquo;语言环境是否相等&amp;rdquo;，您可能会认为将 &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; 与 &lt;code&gt;eq&lt;/code&gt; 结合使用可以提高效率：</target>
        </trans-unit>
        <trans-unit id="f645dc4bb8034c3799b831d6996356797ca7be48" translate="yes" xml:space="preserve">
          <source>If you have a small patch to submit, please submit it via perlbug. You can also send email directly to perlbug@perl.org. Please note that messages sent to perlbug may be held in a moderation queue, so you won't receive a response immediately.</source>
          <target state="translated">如果你有一个小补丁要提交,请通过perlbug提交。您也可以直接发送电子邮件到 perlbug@perl.org。请注意,发送至 perlbug 的消息可能会被保留在管理队列中,因此您不会立即收到回复。</target>
        </trans-unit>
        <trans-unit id="6b5776918dce21a614ab7d2b6b104a983a49243a" translate="yes" xml:space="preserve">
          <source>If you have a small patch to submit, please submit it via the GitHub Pull Request workflow. You may also send patches to the p5p list.</source>
          <target state="translated">如果你有一个小补丁要提交,请通过GitHub Pull Request工作流提交。您也可以将补丁发送到p5p列表中。</target>
        </trans-unit>
        <trans-unit id="42845d8c8c875f89de9dd2d1b7586e0d3ad16bc8" translate="yes" xml:space="preserve">
          <source>If you have a specific romanization scheme in mind, use the specific module:</source>
          <target state="translated">如果你有特定的罗马化方案,请使用特定的模块。</target>
        </trans-unit>
        <trans-unit id="fb355db0f3f4b40524a1c3ff445d923be623d546" translate="yes" xml:space="preserve">
          <source>If you have a working &lt;code&gt;DynaLoader&lt;/code&gt; then there is rarely any need to statically link in any other extensions.</source>
          <target state="translated">如果您有一个可用的 &lt;code&gt;DynaLoader&lt;/code&gt; ,那么几乎不需要任何其他扩展中的静态链接。</target>
        </trans-unit>
        <trans-unit id="fd5f81af8a4a7363d6132316fb90657fc9d4e232" translate="yes" xml:space="preserve">
          <source>If you have a zip file that contains multiple members and want to read a specific member from the file, say &lt;code&gt;&quot;data1&quot;&lt;/code&gt; , use the &lt;code&gt;Name&lt;/code&gt; option</source>
          <target state="translated">如果您的zip文件包含多个成员，并且想从该文件中读取特定成员，请说 &lt;code&gt;&quot;data1&quot;&lt;/code&gt; ，请使用&amp;ldquo; &lt;code&gt;Name&lt;/code&gt; 选项</target>
        </trans-unit>
        <trans-unit id="6052cdbbf6fcaf2baac87ba7e1b86897c2e18ac9" translate="yes" xml:space="preserve">
          <source>If you have a zip file that contains multiple members and want to read a specific member from the file, say &lt;code&gt;&quot;data1&quot;&lt;/code&gt;, use the &lt;code&gt;Name&lt;/code&gt; option</source>
          <target state="translated">如果您的zip文件包含多个成员，并且想从文件中读取特定成员，请说 &lt;code&gt;&quot;data1&quot;&lt;/code&gt; ，请使用&amp;ldquo; &lt;code&gt;Name&lt;/code&gt; 选项</target>
        </trans-unit>
        <trans-unit id="e8e60773a7086adcadd9997f1e4e60bf13f42c27" translate="yes" xml:space="preserve">
          <source>If you have an FTP proxy firewall (&lt;b&gt;NOT&lt;/b&gt; an HTTP or SOCKS firewall) then this value should be set to the firewall hostname. If your firewall does not listen to port 21, then this value should be set to &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; (eg &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt; )</source>
          <target state="translated">如果您有FTP代理防火墙（&lt;b&gt;不是&lt;/b&gt; HTTP或SOCKS防火墙），则应将此值设置为防火墙主机名。如果您的防火墙不侦听端口21，则此值应设置为 &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; （例如 &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3ebb071202346598d9545555072b8cd9d0e64671" translate="yes" xml:space="preserve">
          <source>If you have an FTP proxy firewall (&lt;b&gt;NOT&lt;/b&gt; an HTTP or SOCKS firewall) then this value should be set to the firewall hostname. If your firewall does not listen to port 21, then this value should be set to &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; (eg &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt;)</source>
          <target state="translated">如果您有FTP代理防火墙（&lt;b&gt;不是&lt;/b&gt;HTTP或SOCKS防火墙），则应将此值设置为防火墙主机名。如果您的防火墙不侦听端口21，则此值应设置为 &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; （例如 &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3a37d9c6262b12c7aa2b49bfbcebb4a375757d2e" translate="yes" xml:space="preserve">
          <source>If you have an SV and want to know what kind of data Perl thinks is stored in it, you can use the following macros to check the type of SV you have.</source>
          <target state="translated">如果你有一个SV,并且想知道Perl认为里面存储了什么样的数据,你可以使用下面的宏来检查你所拥有的SV的类型。</target>
        </trans-unit>
        <trans-unit id="2bc4f67186bf30ca57f017f1cea8612b943dd146" translate="yes" xml:space="preserve">
          <source>If you have an array of &lt;code&gt;@string&lt;/code&gt; that should be concatenated and then normalized, you can do like this:</source>
          <target state="translated">如果您有一个 &lt;code&gt;@string&lt;/code&gt; 数组，应该将其连接起来然后再进行规范化，则可以这样进行：</target>
        </trans-unit>
        <trans-unit id="403ab04dd713d2cfe6f16d5487fb0193f691f18c" translate="yes" xml:space="preserve">
          <source>If you have an empty directory, you can use Perl's built-in &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt;. If the directory is not empty (so, no files or subdirectories), you either have to empty it yourself (a lot of work) or use a module to help you.</source>
          <target state="translated">如果目录为空，则可以使用Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; 。如果目录不为空（因此没有文件或子目录），则您必须自己清空（很多工作）或使用模块来帮助您。</target>
        </trans-unit>
        <trans-unit id="e617c76fa41bca088e2fe925791d55bef7f3208c" translate="yes" xml:space="preserve">
          <source>If you have an empty directory, you can use Perl's built-in &lt;code&gt;rmdir&lt;/code&gt;. If the directory is not empty (so, with files or subdirectories), you either have to empty it yourself (a lot of work) or use a module to help you.</source>
          <target state="translated">如果目录为空，则可以使用Perl的内置 &lt;code&gt;rmdir&lt;/code&gt; 。如果目录不为空（因此包含文件或子目录），则您必须自己将其清空（大量工作），或者使用模块来帮助您。</target>
        </trans-unit>
        <trans-unit id="6898ea8c69aa4a0ff2b81092a3457a58f7bdc010" translate="yes" xml:space="preserve">
          <source>If you have an existing inside-out class, simply making all hashes field hashes with no other change should make no difference. Through the calls to &lt;code&gt;refaddr&lt;/code&gt; or equivalent, the field hashes never get to see a reference and work like normal hashes. Your DESTROY (and CLONE) methods are still needed.</source>
          <target state="translated">如果您有一个现有的由内而外的类，则仅进行所有哈希字段哈希而不进行其他任何更改就不会有任何区别。通过调用 &lt;code&gt;refaddr&lt;/code&gt; 或等效项，字段散列永远不会看到引用，并且像普通散列一样工作。仍然需要您的DESTROY（和CLONE）方法。</target>
        </trans-unit>
        <trans-unit id="03fcf475306c60d974596613b76c03a9f344e66a" translate="yes" xml:space="preserve">
          <source>If you have an older version of Perl, the &lt;code&gt;$^W&lt;/code&gt; variable (documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;) controls runtime warnings for a block:</source>
          <target state="translated">如果您使用的是Perl的旧版本，则 &lt;code&gt;$^W&lt;/code&gt; 变量（在&lt;a href=&quot;perlvar&quot;&gt;perlvar中记录&lt;/a&gt;）控制着块的运行时警告：</target>
        </trans-unit>
        <trans-unit id="55ec04844d40449455953b5a185c6050647bf370" translate="yes" xml:space="preserve">
          <source>If you have any other characters you need to escape, please install the &lt;code&gt;URI::Escape&lt;/code&gt; module from CPAN, and pre-encode your URI before passing it to &lt;code&gt;File::Fetch&lt;/code&gt; . You can read about the details of URIs and URI encoding here:</source>
          <target state="translated">如果您还有其他需要转义的字符，请从CPAN 安装 &lt;code&gt;URI::Escape&lt;/code&gt; 模块，并在将其传递到 &lt;code&gt;File::Fetch&lt;/code&gt; 之前对其进行预编码。您可以在此处阅读有关URI和URI编码的详细信息：</target>
        </trans-unit>
        <trans-unit id="b3a311e2f3de5d8bd7b59c7e63cc0db7c3de9dbd" translate="yes" xml:space="preserve">
          <source>If you have any other characters you need to escape, please install the &lt;code&gt;URI::Escape&lt;/code&gt; module from CPAN, and pre-encode your URI before passing it to &lt;code&gt;File::Fetch&lt;/code&gt;. You can read about the details of URIs and URI encoding here:</source>
          <target state="translated">如果您还有其他需要转义的字符，请从CPAN安装 &lt;code&gt;URI::Escape&lt;/code&gt; 模块，并在将URI传递给 &lt;code&gt;File::Fetch&lt;/code&gt; 之前对其进行预编码。您可以在此处阅读有关URI和URI编码的详细信息：</target>
        </trans-unit>
        <trans-unit id="baafc393e6c194ed8ae0aabf8fee882236c21df9" translate="yes" xml:space="preserve">
          <source>If you have any suggested changes for this page, let me know. Please don't send me mail asking for help on how to install your modules. There are too many modules, and too few Orwants, for me to be able to answer or even acknowledge all your questions. Contact the module author instead, ask someone familiar with Perl on your operating system, or if all else fails, file a ticket at &lt;a href=&quot;https://rt.cpan.org/&quot;&gt;https://rt.cpan.org/&lt;/a&gt;.</source>
          <target state="translated">如果您对此页面有任何建议的更改，请告诉我。请不要给我发送邮件，以寻求有关如何安装模块的帮助。对于我来说，模块太多，而Orwants却很少，因此我无法回答甚至承认您的所有问题。请与模块作者联系，请与您操作系统上熟悉Perl的人联系，或者，如果其他所有操作都失败，请通过&lt;a href=&quot;https://rt.cpan.org/&quot;&gt;https://rt.cpan.org/&lt;/a&gt;提交票证。</target>
        </trans-unit>
        <trans-unit id="59ef038a12de814aa0cdf806e88e5a326fdaf2d5" translate="yes" xml:space="preserve">
          <source>If you have any suggested changes for this page, let me know. Please don't send me mail asking for help on how to install your modules. There are too many modules, and too few Orwants, for me to be able to answer or even acknowledge all your questions. Contact the module author instead, or post to comp.lang.perl.modules, or ask someone familiar with Perl on your operating system.</source>
          <target state="translated">如果你对这个页面有任何修改建议,请告诉我。请不要给我发邮件询问如何安装您的模块。模块太多,Orwants也太少,我无法回答甚至确认你所有的问题。请联系模块的作者,或者在comp.lang.perl.modules上发帖,或者询问熟悉Perl的人。</target>
        </trans-unit>
        <trans-unit id="e2545920681caa56966e901dca47f4688bdb95ac" translate="yes" xml:space="preserve">
          <source>If you have built this module with zlib &amp;gt;= 1.2.0, the &lt;code&gt;$eof&lt;/code&gt; parameter is ignored. You can still set it if you want, but it won't be used behind the scenes.</source>
          <target state="translated">如果您使用zlib&amp;gt; = 1.2.0构建了该模块，则 &lt;code&gt;$eof&lt;/code&gt; 参数将被忽略。您仍然可以根据需要进行设置，但是不会在幕后使用它。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
