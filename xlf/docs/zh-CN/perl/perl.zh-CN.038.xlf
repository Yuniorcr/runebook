<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="b39e88e61083334da27e22ac3304f5322910c7a2" translate="yes" xml:space="preserve">
          <source>Single-letter properties match all characters in any of the two-letter sub-properties starting with the same letter. &lt;code&gt;LC&lt;/code&gt; and &lt;code&gt;L&amp;amp;&lt;/code&gt; are special: both are aliases for the set consisting of everything matched by &lt;code&gt;Ll&lt;/code&gt; , &lt;code&gt;Lu&lt;/code&gt; , and &lt;code&gt;Lt&lt;/code&gt; .</source>
          <target state="translated">单字母属性匹配以相同字母开头的任何两个字母子属性中的所有字符。 &lt;code&gt;LC&lt;/code&gt; 和 &lt;code&gt;L&amp;amp;&lt;/code&gt; 是特殊的：两者都是由 &lt;code&gt;Ll&lt;/code&gt; ， &lt;code&gt;Lu&lt;/code&gt; 和 &lt;code&gt;Lt&lt;/code&gt; 匹配的所有内容组成的集合的别名。</target>
        </trans-unit>
        <trans-unit id="47784ae534e76f07f938e74b6b49c2e04c524d60" translate="yes" xml:space="preserve">
          <source>Single-step flag. Will be true if the API will stop at the next statement.</source>
          <target state="translated">单步标志。如果API将在下一条语句中停止,则为真。</target>
        </trans-unit>
        <trans-unit id="3fd72cbf421902beaf4893343701c7e9f292181e" translate="yes" xml:space="preserve">
          <source>Sinograms like &amp;ldquo;東京&amp;rdquo; come back with character names of &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; and &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt; , because their &amp;ldquo;names&amp;rdquo; vary. The CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; module has a large database for decoding these (and a whole lot more), provided you know how to understand its output.</source>
          <target state="translated">诸如&amp;ldquo;东京&amp;rdquo;之类的汉字会以 &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; 和 &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt; 的字符名称返回，因为它们的&amp;ldquo;名称&amp;rdquo;有所不同。CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; 模块具有一个大型数据库，可以解码这些（以及更多），只要您知道如何理解其输出即可。</target>
        </trans-unit>
        <trans-unit id="28e8fd907b0e11131190209772e747eaed820c59" translate="yes" xml:space="preserve">
          <source>Site-specific perl extensions and modules can be installed in one of two places. Put architecture-independent files into:</source>
          <target state="translated">特定站点的perl扩展和模块可以安装在两个地方之一。把与架构无关的文件放入。</target>
        </trans-unit>
        <trans-unit id="00832815e260edfba2e83c2f4b5a6a35db1c2d1c" translate="yes" xml:space="preserve">
          <source>Six such conversions are possible:</source>
          <target state="translated">这样的转换有六种可能。</target>
        </trans-unit>
        <trans-unit id="43701334f4b3da3fdeb3363278217ac0f215873d" translate="yes" xml:space="preserve">
          <source>Size of the function table. This is compared against the value PerlIO code &quot;knows&quot; as a compatibility check. Future versions</source>
          <target state="translated">函数表的大小。这将与PerlIO代码 &quot;知道 &quot;的值进行比较,作为一种兼容性检查。未来版本</target>
        </trans-unit>
        <trans-unit id="936d52e1c615ea7024397f6ff1aeb7c89ebd5bad" translate="yes" xml:space="preserve">
          <source>Size, Endianness, and BOM</source>
          <target state="translated">规模、内涵和BOM</target>
        </trans-unit>
        <trans-unit id="0ec62bfb6670c34f50ed4190d4e6017dc34d76d5" translate="yes" xml:space="preserve">
          <source>Skip a package when throwing autodie exceptions</source>
          <target state="translated">抛出自动处理异常时跳过一个包。</target>
        </trans-unit>
        <trans-unit id="57a18bbc33fb3b107b0f37ec04073b6f8f1aa7be" translate="yes" xml:space="preserve">
          <source>Skip sub-char mapping should there be no code point.</source>
          <target state="translated">如果没有代码点,则跳过子字符映射。</target>
        </trans-unit>
        <trans-unit id="fa22bcdeb4f395bdc09dc2fd5b11b93a885994fb" translate="yes" xml:space="preserve">
          <source>Skip the real Pod formatting, and just show the raw Pod source (&lt;b&gt;U&lt;/b&gt;nformatted)</source>
          <target state="translated">跳过真正的波德格式，并且只显示原始波德源（&lt;b&gt;&amp;uuml;&lt;/b&gt; nformatted）</target>
        </trans-unit>
        <trans-unit id="3e59adfb26a9113df0d5c476d39a18d0087952f5" translate="yes" xml:space="preserve">
          <source>Skip this section if the XSUB functions are supposed to be called from other modules only; read it only if you call your XSUBs from the code in your module, or have a &lt;code&gt;BOOT:&lt;/code&gt; section in your XS file (see &lt;a href=&quot;perlxs#The-BOOT%3a-Keyword&quot;&gt;The BOOT: Keyword in perlxs&lt;/a&gt;). What is described here is equally applicable to the &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; interface.</source>
          <target state="translated">如果仅应从其他模块调用XSUB函数，请跳过本节；仅当您从模块中的代码调用XSUB或在XS文件中包含 &lt;code&gt;BOOT:&lt;/code&gt; 部分时，才阅读它（请参阅&lt;a href=&quot;perlxs#The-BOOT%3a-Keyword&quot;&gt;perlxs中的BOOT：关键字&lt;/a&gt;）。这里描述的内容同样适用于&lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="54ab6781ff6514e41583039acc42db3e0f3c9201" translate="yes" xml:space="preserve">
          <source>Skips all the tests, using the given &lt;code&gt;$reason&lt;/code&gt; . Exits immediately with 0.</source>
          <target state="translated">使用给定的 &lt;code&gt;$reason&lt;/code&gt; 跳过所有测试。立即以0退出。</target>
        </trans-unit>
        <trans-unit id="563adc0d862d00d2bcc7549833d1039985aead2a" translate="yes" xml:space="preserve">
          <source>Skips the current test, reporting &lt;code&gt;$why&lt;/code&gt; .</source>
          <target state="translated">跳过当前测试，报告 &lt;code&gt;$why&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca1ac1071abc2c48fe8c683c23437c17bcd0e5ba" translate="yes" xml:space="preserve">
          <source>Skips to the next compressed data stream in the input file/buffer. If a new compressed data stream is found, the eof marker will be cleared and &lt;code&gt;$.&lt;/code&gt; will be reset to 0.</source>
          <target state="translated">跳至输入文件/缓冲区中的下一个压缩数据流。如果找到新的压缩数据流，则将清除eof标记和 &lt;code&gt;$.&lt;/code&gt; 将重置为0。</target>
        </trans-unit>
        <trans-unit id="e59d0602eb0550fd0dbf5d82907d6271ae4af6ea" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of microseconds (millionths of a second) specified. Returns the number of microseconds actually slept. Can sleep for more than one second, unlike the &lt;code&gt;usleep&lt;/code&gt; system call. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">休眠指定的微秒数（百万分之一秒）。返回实际睡眠的微秒数。与 &lt;code&gt;usleep&lt;/code&gt; 系统调用不同，它可以睡眠一秒钟以上。也可以睡零秒，这通常就像</target>
        </trans-unit>
        <trans-unit id="a7c111ccc19a7463efac9caa48bfd176015106c5" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of nanoseconds (1e9ths of a second) specified. Returns the number of nanoseconds actually slept (accurate only to microseconds, the nearest thousand of them). Can sleep for more than one second. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">睡眠时间为指定的纳秒数(1e9th of a second)。返回实际睡眠的纳秒数(只精确到微秒,最接近的千分之一)。可以休眠一秒以上。也可以休眠零秒,它的工作原理往往像一个</target>
        </trans-unit>
        <trans-unit id="858360f4742bec3dbad2b4b1586f95ca8cfce48d" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of nanoseconds (1e9ths of a second) specified. Returns the number of nanoseconds actually slept. The $which is the &quot;clock id&quot;, as with clock_gettime() and clock_getres(). The flags default to zero but &lt;code&gt;TIMER_ABSTIME&lt;/code&gt; can specified (must be exported explicitly) which means that &lt;code&gt;$nanoseconds&lt;/code&gt; is not a time interval (as is the default) but instead an absolute time. Can sleep for more than one second. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">休眠指定的纳秒数（1e9秒）。返回实际睡眠的纳秒数。$其中是&amp;ldquo; clock id&amp;rdquo;，与clock_gettime（）和clock_getres（）一样。这些标志默认为零，但是可以指定 &lt;code&gt;TIMER_ABSTIME&lt;/code&gt; （必须显式导出），这意味着 &lt;code&gt;$nanoseconds&lt;/code&gt; nanoseconds不是时间间隔（默认值），而是绝对时间。可以睡一秒钟以上。也可以睡零秒，这通常就像</target>
        </trans-unit>
        <trans-unit id="bfc9358c36664745e87042ffeea926ba49acc8f0" translate="yes" xml:space="preserve">
          <source>Sleeps for the specified amount of seconds. Returns the number of seconds actually slept (a floating point value). This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; below.</source>
          <target state="translated">休眠指定的秒数。返回实际睡眠的秒数（浮点值）。可以导入此功能，从而可以很好地替代perl附带的 &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; ，请参见下面的&lt;a href=&quot;#EXAMPLES&quot;&gt;示例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a455933ba1827ec6d2d6cea6cb61c05bd3954351" translate="yes" xml:space="preserve">
          <source>Slices</source>
          <target state="translated">Slices</target>
        </trans-unit>
        <trans-unit id="de97696f04df2d455746fc0459c7a0334ac08b94" translate="yes" xml:space="preserve">
          <source>Slices in scalar context return the last item of the slice.</source>
          <target state="translated">标量上下文中的片子返回片子的最后一项。</target>
        </trans-unit>
        <trans-unit id="fade4867f2281855741bb2fdfae6ec6bfe669774" translate="yes" xml:space="preserve">
          <source>Slicing operations and parentheses cause the right-hand side to be evaluated in list context:</source>
          <target state="translated">分片操作和括号会导致右侧在列表上下文中被评估。</target>
        </trans-unit>
        <trans-unit id="71625e10c96350176b8faecaf24d1d897cf6efce" translate="yes" xml:space="preserve">
          <source>Slightly modified by Arthur Bergman to fit the new thread model/module.</source>
          <target state="translated">由Arthur Bergman稍作修改,以适应新的螺纹模型/模块。</target>
        </trans-unit>
        <trans-unit id="c05c92e1201b3c7a99b14a3196c426c41067b9ce" translate="yes" xml:space="preserve">
          <source>Smartmatch Operator</source>
          <target state="translated">Smartmatch操作员</target>
        </trans-unit>
        <trans-unit id="e4adce585ab904a3b57996c9eacd1526a8856e59" translate="yes" xml:space="preserve">
          <source>Smartmatching of Objects</source>
          <target state="translated">对象的智能匹配</target>
        </trans-unit>
        <trans-unit id="fcef3abf224b18a1a9539b5cd1a74a21f40eb21d" translate="yes" xml:space="preserve">
          <source>Smartmatching one hash against another reports whether both contain the same keys, no more and no less. This could be used to see whether two records have the same field names, without caring what values those fields might have. For example:</source>
          <target state="translated">将一个哈希值与另一个哈希值进行智能匹配,报告两者是否包含相同的键,不多不少。这可以用来查看两条记录是否有相同的字段名,而不关心这些字段可能有什么值。比如说</target>
        </trans-unit>
        <trans-unit id="4460e52ce30ee2f7dab472f65e7bc2c1c88dffad" translate="yes" xml:space="preserve">
          <source>So I got smart: I decided to be lazy and let the C compiler parse the C, which would spit out debugger stabs for me to read. These were much easier to parse. It's still not a pretty program, but at least it's more robust.</source>
          <target state="translated">于是我变聪明了:我决定偷懒,让C编译器解析C语言,它会吐出调试器刺让我阅读。这些解析起来就容易多了。这仍然不是一个漂亮的程序,但至少它更健壮了。</target>
        </trans-unit>
        <trans-unit id="a1f5ce193c65cebf4de4614792ca39a016541f36" translate="yes" xml:space="preserve">
          <source>So a typical call to check would look like this:</source>
          <target state="translated">所以一个典型的调用检查会是这样的。</target>
        </trans-unit>
        <trans-unit id="32bf3b4ebf1dd24fdccf516f7c267bd10f4fed6f" translate="yes" xml:space="preserve">
          <source>So assuming the database created above, we can use &lt;code&gt;get_dup&lt;/code&gt; like this:</source>
          <target state="translated">因此，假设上面创建了数据库，我们可以像这样使用 &lt;code&gt;get_dup&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9531481e3958e36f87e15fe09a502608d674e17a" translate="yes" xml:space="preserve">
          <source>So called because of a similar construct in &lt;b&gt;shells&lt;/b&gt; that pretends that the &lt;b&gt;lines&lt;/b&gt; following the &lt;b&gt;command&lt;/b&gt; are a separate &lt;b&gt;file&lt;/b&gt; to be fed to the command, up to some terminating string. In Perl, however, it&amp;rsquo;s just a fancy form of quoting.</source>
          <target state="translated">所谓的，因为在一个类似的构建体的&lt;b&gt;壳&lt;/b&gt;伪装该&lt;b&gt;线&lt;/b&gt;以下的&lt;b&gt;命令&lt;/b&gt;是一个独立的&lt;b&gt;文件&lt;/b&gt;要被馈送到该命令，直到某个终止字符串。但是，在Perl中，这只是一种奇特的报价形式。</target>
        </trans-unit>
        <trans-unit id="93e9a6ece24ada54b55dc7612c9389e7a638c36b" translate="yes" xml:space="preserve">
          <source>So each subroutine is born with an array of scratchpads (of length 1). On each entry to the subroutine it is checked that the current depth of the recursion is not more than the length of this array, and if it is, new scratchpad is created and pushed into the array.</source>
          <target state="translated">所以每个子程序出生时都有一个scratchpads数组(长度为1)。在每次进入子程序时,都会检查当前递归的深度是否超过这个数组的长度,如果超过,就会创建新的scratchpad并推送到数组中。</target>
        </trans-unit>
        <trans-unit id="bfd2a2cfe6e08c35c8f0019242b9920756d8258f" translate="yes" xml:space="preserve">
          <source>So far so good. But suppose the way you're implementing this is:</source>
          <target state="translated">到目前为止还不错。但假设你的实施方式是:</target>
        </trans-unit>
        <trans-unit id="99d938c6031e3ad535ec502cea56c5d218d4389a" translate="yes" xml:space="preserve">
          <source>So far so good. Those of you who have been paying attention will have spotted that the tied object hasn't been used so far. So lets add an extra method to the Remember class to allow comments to be included in the file; say, something like this:</source>
          <target state="translated">到目前为止还算不错。那些一直在关注的人将会发现,到目前为止,绑定对象还没有被使用。因此,让我们在 Remember 类中添加一个额外的方法,以允许在文件中包含注释;比如,像这样。</target>
        </trans-unit>
        <trans-unit id="438b9b4e31229df657e054c261ee9d298ca8b103" translate="yes" xml:space="preserve">
          <source>So far we've merely tried to find and list the experimental features and infer their inception, versions, etc. There's a lot of speculation here.</source>
          <target state="translated">到目前为止,我们只是试图找到并列出实验功能,并推断出它们的成立时间、版本等。这里有很多的猜测。</target>
        </trans-unit>
        <trans-unit id="10bc3a4c124b48037408d12298d27779d339f321" translate="yes" xml:space="preserve">
          <source>So far, so good. With the knowledge above you can already perform searches with just about any literal string regexp you can dream up. Here is a</source>
          <target state="translated">到目前为止,还算不错。有了上面的知识,你已经可以用任何你能想到的文字字符串regexp进行搜索了。下面是一个</target>
        </trans-unit>
        <trans-unit id="8af65d96d3224572aaaeff6426ae992e0bd5b192" translate="yes" xml:space="preserve">
          <source>So far, we're using just the normal list return mechanism. What happens if you want to pass or return a hash? Well, if you're using only one of them, or you don't mind them concatenating, then the normal calling convention is ok, although a little expensive.</source>
          <target state="translated">到目前为止,我们使用的只是普通的列表返回机制。如果你想传递或返回一个哈希,会发生什么?好吧,如果你只使用其中一个,或者你不介意它们连在一起,那么正常的调用惯例是可以的,虽然有点贵。</target>
        </trans-unit>
        <trans-unit id="6a1a83e9f4437f40c54f1506b859ac7294d0d128" translate="yes" xml:space="preserve">
          <source>So far, we've seen literals used as templates. If the list of pack items doesn't have fixed length, an expression constructing the template is required (whenever, for some reason, &lt;code&gt;()*&lt;/code&gt; cannot be used). Here's an example: To store named string values in a way that can be conveniently parsed by a C program, we create a sequence of names and null terminated ASCII strings, with &lt;code&gt;=&lt;/code&gt; between the name and the value, followed by an additional delimiting null byte. Here's how:</source>
          <target state="translated">到目前为止，我们已经看到文字用作模板。如果包装物品列表的长度不固定，则需要构造模板的表达式（但由于某种原因，不能使用 &lt;code&gt;()*&lt;/code&gt; ）。这是一个示例：为了以一种可以由C程序方便地解析的方式存储命名字符串值，我们创建了一个名称序列和以null终止的ASCII字符串，在名称和值之间带有 &lt;code&gt;=&lt;/code&gt; ，然后是一个附加的定界空字节。这是如何做：</target>
        </trans-unit>
        <trans-unit id="7a5692420708108a4d7ad47094be88b57cf9bf66" translate="yes" xml:space="preserve">
          <source>So for English (with Bracket Notation) &lt;code&gt;&quot;...[quant,_1,file]...&quot;&lt;/code&gt; is fine (for 0 it returns &quot;0 files&quot;, for 1 it returns &quot;1 file&quot;, and for more it returns &quot;2 files&quot;, etc.)</source>
          <target state="translated">因此，对于英语（带括号表示法） &lt;code&gt;&quot;...[quant,_1,file]...&quot;&lt;/code&gt; 很好（对于0，它返回&amp;ldquo; 0个文件&amp;rdquo;，对于1，它返回&amp;ldquo; 1个文件&amp;rdquo;，对于更多，它返回&amp;ldquo; 2个文件&amp;rdquo;等）</target>
        </trans-unit>
        <trans-unit id="8477c048b776b6250b8d3a6b206bd8a95a79a9ff" translate="yes" xml:space="preserve">
          <source>So for example, instead of using:</source>
          <target state="translated">因此,例如,不使用。</target>
        </trans-unit>
        <trans-unit id="23a15c81788a2c5aff56ccaef77af7e0b8ce44eb" translate="yes" xml:space="preserve">
          <source>So given the diagram above, Perl will search &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt; , and finally &lt;code&gt;MaternalGrandparent&lt;/code&gt; . This may be a problem because now we're looking in &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;</source>
          <target state="translated">因此，鉴于上面的图表中，Perl会寻找 &lt;code&gt;Child&lt;/code&gt; ， &lt;code&gt;Father&lt;/code&gt; ， &lt;code&gt;PaternalGrandparent&lt;/code&gt; ， &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; ， &lt;code&gt;Mother&lt;/code&gt; ，终于 &lt;code&gt;MaternalGrandparent&lt;/code&gt; 。这可能是一个问题，因为现在我们正在寻找 &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="91f4e47cc018c4b1c4ca9fc78408994ad8035bd1" translate="yes" xml:space="preserve">
          <source>So here is the bottom line--if you are sure that control will revert back to the enclosing Perl scope fairly quickly after the end of your callback, then it isn't absolutely necessary to dispose explicitly of any temporaries you may have created. Mind you, if you are at all uncertain about what to do, it doesn't do any harm to tidy up anyway.</source>
          <target state="translated">所以这里有一个底线--如果你确信在你的回调结束后,控制会很快地返回到外层的Perl作用域,那么并不是绝对有必要明确地处理任何你可能已经创建的临时变量。提醒你,如果你不确定要做什么,那么无论如何整理一下也没有什么坏处。</target>
        </trans-unit>
        <trans-unit id="4443d502fbd614fe670f624b7a8d6e87d74c5b32" translate="yes" xml:space="preserve">
          <source>So hopefully you've now got a few ideas about what's good to modularise. Let's now see how it's done.</source>
          <target state="translated">所以希望你现在已经对模块化的好东西有了一些想法。现在就让我们来看看是怎么做的吧。</target>
        </trans-unit>
        <trans-unit id="6d3a27421600e7d4abecd702bd20845b8466123d" translate="yes" xml:space="preserve">
          <source>So how do I use a proxy with File::Fetch?</source>
          <target state="translated">那么如何使用File::Fetch的代理?</target>
        </trans-unit>
        <trans-unit id="9d00ee45ac1982b7db0dbf721dd3e3787ed6d62f" translate="yes" xml:space="preserve">
          <source>So how do you use a source filter in a Perl script? Above, I said that a source filter is just a special kind of module. Like all Perl modules, a source filter is invoked with a use statement.</source>
          <target state="translated">那么如何在Perl脚本中使用源码过滤器呢?上面我说过,源过滤器只是一种特殊的模块。和所有的Perl模块一样,源过滤器也是通过使用语句来调用的。</target>
        </trans-unit>
        <trans-unit id="6cca2cb75a50d0827a566440232066af85d09fbe" translate="yes" xml:space="preserve">
          <source>So how does it work?</source>
          <target state="translated">那么它是如何运作的呢?</target>
        </trans-unit>
        <trans-unit id="9612f816ae3d1d599129006ddc23ec570699e275" translate="yes" xml:space="preserve">
          <source>So if you take for example the shell command</source>
          <target state="translated">因此,如果你以shell命令为例</target>
        </trans-unit>
        <trans-unit id="557e6fd5bed4c1d07e89cc778dd5ffa04e712afb" translate="yes" xml:space="preserve">
          <source>So if you want to check the validity of the encoding, surround the expression with &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; block as follows;</source>
          <target state="translated">因此，如果要检查编码的有效性，请按如下所示用 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 块包围表达式；</target>
        </trans-unit>
        <trans-unit id="d7e30a7ebf49e6593b8da91cf7504894e9cfa473" translate="yes" xml:space="preserve">
          <source>So if you were to supply a new, complete, top-level source file to add to Perl, you should conform to this peculiar practice by yourself selecting an appropriate quotation from Tolkien, retaining the original spelling and punctuation and using the same format the rest of the quotes are in. Indirect and oblique is just fine; remember, it's a metaphor, so being meta is, after all, what it's for.</source>
          <target state="translated">所以,如果你要提供一个新的、完整的、顶层的源文件添加到Perl中,你应该遵守这种奇特的做法,自己从Tolkien中选择一个合适的引文,保留原来的拼写和标点,并使用其余引文的格式。间接和间接就可以了,记住,这是一个比喻,所以毕竟是元的,是用来做什么的。</target>
        </trans-unit>
        <trans-unit id="02bb4252af15d73e7777da1a95cce444353d918a" translate="yes" xml:space="preserve">
          <source>So if you're working with Unicode data, consult the documentation of every module you're using if there are any issues with Unicode data exchange. If the documentation does not talk about Unicode at all, suspect the worst and probably look at the source to learn how the module is implemented. Modules written completely in Perl shouldn't cause problems. Modules that directly or indirectly access code written in other programming languages are at risk.</source>
          <target state="translated">所以,如果你在使用Unicode数据,请查阅你使用的每个模块的文档,如果有Unicode数据交换的问题。如果文档中根本没有谈到Unicode,就怀疑最坏的情况,可能要看源码来了解模块是如何实现的。完全用Perl编写的模块应该不会引起问题。直接或间接访问其他编程语言编写的代码的模块就有风险了。</target>
        </trans-unit>
        <trans-unit id="e319523cadbb2780f0ef0af26ce5a7a559c73594" translate="yes" xml:space="preserve">
          <source>So in VMS its pm_to_blib.ts.</source>
          <target state="translated">所以在VMS中,它的pm_to_blib.ts。</target>
        </trans-unit>
        <trans-unit id="3bce9b15392a6c8658669f57b4a2decac3558eb6" translate="yes" xml:space="preserve">
          <source>So instead you'll want to do something like this:</source>
          <target state="translated">所以,你会想做这样的事情。</target>
        </trans-unit>
        <trans-unit id="6161c23b3048d528f32556aeffc6deb23d6328c9" translate="yes" xml:space="preserve">
          <source>So it is round-trip safe for \xF9\xF9. But if the line above is upside down, here is what happens.</source>
          <target state="translated">所以,它是往返安全的xF9xF9。但如果上面的线是颠倒的,就会出现这样的情况。</target>
        </trans-unit>
        <trans-unit id="c06ae4675003e825258b16549181d9f72cc7560a" translate="yes" xml:space="preserve">
          <source>So it's clearer and best to use the compound form when specifying blocks. And be sure that is what you really really want to do. In most cases scripts are what you want instead.</source>
          <target state="translated">所以在指定块的时候,最好使用复合形式,这样更清晰。而且要确定那是你真正真正想做的事情。在大多数情况下,脚本才是你想要的。</target>
        </trans-unit>
        <trans-unit id="3007e0313fdaf4be553a40db748fe3ab3979d2d6" translate="yes" xml:space="preserve">
          <source>So just remember always to use the array or hash constructors with &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;{}&lt;/code&gt; , and you'll be fine, although it's not always optimally efficient.</source>
          <target state="translated">因此，只要记住始终将数组或哈希构造函数与 &lt;code&gt;[]&lt;/code&gt; 或 &lt;code&gt;{}&lt;/code&gt; 一起使用，就可以了，尽管它并不总是最佳效率的。</target>
        </trans-unit>
        <trans-unit id="28f6b3059bd71a14d4d6430ebaa792ae77f9b5ae" translate="yes" xml:space="preserve">
          <source>So much for textual data. Let's get onto the meaty stuff that &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; are best at: handling binary formats for numbers. There is, of course, not just one binary format - life would be too simple - but Perl will do all the finicky labor for you.</source>
          <target state="translated">文本数据就这么多。让我们到肉的东西， &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 最擅长的：处理二进制格式的数字。当然，不仅有一种二进制格式-生活太简单了-但Perl会为您完成所有繁琐的工作。</target>
        </trans-unit>
        <trans-unit id="19e5670a7ba385b708ff4bcfadcd36a0825afece" translate="yes" xml:space="preserve">
          <source>So now this code would be written:</source>
          <target state="translated">所以现在要写这段代码。</target>
        </trans-unit>
        <trans-unit id="7ec657e348cc94be548b290696e0a818e7f982d5" translate="yes" xml:space="preserve">
          <source>So now you have a file ending in .tar.gz (or, less often, .zip). You know there's a tasty module inside. There are four steps you must now take:</source>
          <target state="translated">所以现在你有一个以 .tar.gz 结尾的文件 (或者,较少见的是 .zip)。你知道里面有一个美味的模块。现在你必须采取四个步骤。</target>
        </trans-unit>
        <trans-unit id="9f7f09ef2fcd4d20ffdab1795e6c221c8b2cdf50" translate="yes" xml:space="preserve">
          <source>So please select carefully what library you want to use.</source>
          <target state="translated">所以请慎重选择您要使用的图书馆。</target>
        </trans-unit>
        <trans-unit id="fc4d504736579a86ac1ba1abd47d391cec08a768" translate="yes" xml:space="preserve">
          <source>So put in parentheses to say what you really mean.</source>
          <target state="translated">所以在括号里写上你的真实意思。</target>
        </trans-unit>
        <trans-unit id="291a379872204cd90f4de2f2a608af9f0d7dabed" translate="yes" xml:space="preserve">
          <source>So specifically, autoloaded functions cannot see package lexicals (this applies to both the &lt;b&gt;SelfLoader&lt;/b&gt; and the Autoloader). The &lt;code&gt;vars&lt;/code&gt; pragma provides an alternative to defining package-level globals that will be visible to autoloaded routines. See the documentation on &lt;b&gt;vars&lt;/b&gt; in the pragma section of &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">因此，特别是，自动加载的函数无法查看包词汇（这既适用于&lt;b&gt;SelfLoader&lt;/b&gt;，也适用于Autoloader）。的 &lt;code&gt;vars&lt;/code&gt; 编译指示提供到限定封装级全局那将是自动加载例程可见的替代方案。请参阅&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;的pragma部分中有关&lt;b&gt;vars&lt;/b&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="178e0296c43b2c22ca3149a0d363aa4b6a82de7c" translate="yes" xml:space="preserve">
          <source>So that's how we consume and produce fixed-width data. Let's recap what we've seen of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; so far:</source>
          <target state="translated">这就是我们消费和产生固定宽度数据的方式。让我们回顾一下我们所看到的 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 并 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 至今：</target>
        </trans-unit>
        <trans-unit id="da5a5de8356ec781cae3674738f4fa4085230f11" translate="yes" xml:space="preserve">
          <source>So the Perl interface would look like this</source>
          <target state="translated">所以Perl的界面是这样的</target>
        </trans-unit>
        <trans-unit id="eb361df349469f52fd13dc7f637fd6d3f4002c01" translate="yes" xml:space="preserve">
          <source>So the Perl subroutine would look like this:</source>
          <target state="translated">所以Perl的子程序是这样的。</target>
        </trans-unit>
        <trans-unit id="f9e5e29abec6c42a24502ee051f01eb881622a3a" translate="yes" xml:space="preserve">
          <source>So the exit codes are...</source>
          <target state="translated">所以退出密码是...</target>
        </trans-unit>
        <trans-unit id="ecdcbf5b6eec0983bdba576e908b1b991d7bdaa0" translate="yes" xml:space="preserve">
          <source>So the methods &lt;code&gt;PrintID&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; can be invoked like this:</source>
          <target state="translated">因此，可以像这样调用方法 &lt;code&gt;PrintID&lt;/code&gt; 和 &lt;code&gt;Display&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="050bc5740a1b6bb30a161c3c46fabef260c75737" translate="yes" xml:space="preserve">
          <source>So this:</source>
          <target state="translated">所以这个。</target>
        </trans-unit>
        <trans-unit id="65f64a88a88a2a42947aa812e415dc968ce4fc3b" translate="yes" xml:space="preserve">
          <source>So to repeat always use SvOK() to check whether an sv is defined.</source>
          <target state="translated">所以重复总是使用SvOK()来检查是否定义了一个sv。</target>
        </trans-unit>
        <trans-unit id="ec007077340f2b45239679ca4cc61f38315a3433" translate="yes" xml:space="preserve">
          <source>So what happened to dTHR?</source>
          <target state="translated">那么,dTHR怎么了?</target>
        </trans-unit>
        <trans-unit id="dd71b3066f2c37ca89d49c13416a448baf2ad1f1" translate="yes" xml:space="preserve">
          <source>So what has this got to do with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;? Well, if you want to compose a Unicode string (that is internally encoded as UTF-8), you can do so by using template code &lt;code&gt;U&lt;/code&gt; . As an example, let's produce the Euro currency symbol (code number 0x20AC):</source>
          <target state="translated">那么，这和 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 有什么关系呢？好吧，如果您想编写Unicode字符串（内部编码为UTF-8），则可以使用模板代码 &lt;code&gt;U&lt;/code&gt; 来完成。例如，让我们产生欧元货币符号（代码号0x20AC）：</target>
        </trans-unit>
        <trans-unit id="76db05e5ac37110bc4537d598a8e57f24d0e7d58" translate="yes" xml:space="preserve">
          <source>So what is the big problem? Well, if you are expecting Perl to tidy up those temporaries for you, you might be in for a long wait. For Perl to dispose of your temporaries, control must drop back to the enclosing scope at some stage. In the event driven scenario that may never happen. This means that, as time goes on, your program will create more and more temporaries, none of which will ever be freed. As each of these temporaries consumes some memory your program will eventually consume all the available memory in your system--kapow!</source>
          <target state="translated">那么最大的问题是什么呢?好吧,如果你希望Perl为你整理这些临时文件,你可能要等很久。为了让Perl处理掉你的临时变量,控制权必须在某个阶段回落到外层作用域。在事件驱动的情况下,这可能永远不会发生。这意味着,随着时间的推移,你的程序将创建越来越多的临时变量,其中没有一个会被释放。由于每个临时变量都会消耗一些内存,你的程序最终会消耗系统中所有的可用内存--kapow!</target>
        </trans-unit>
        <trans-unit id="49dd0c06fd8f279176f457e7dd90bd0af2090341" translate="yes" xml:space="preserve">
          <source>So what's new?</source>
          <target state="translated">那么,有什么新鲜事呢?</target>
        </trans-unit>
        <trans-unit id="8be287051544a93972a5fe33ce5f2eed6334bad0" translate="yes" xml:space="preserve">
          <source>So when the output is a filehandle it will carry out a seek to the eof before writing any compressed data. If the output is a filename, it will be opened for appending. If the output is a buffer, all compressed data will be appended to the existing buffer.</source>
          <target state="translated">因此,当输出是一个文件柄时,它将在写入任何压缩数据之前对eof进行寻址。如果输出是一个文件名,它将被打开进行追加。如果输出是一个缓冲区,所有的压缩数据将被追加到现有的缓冲区。</target>
        </trans-unit>
        <trans-unit id="2b16151fbc25d8d9908507f5cf41dca81006fcb5" translate="yes" xml:space="preserve">
          <source>So when the output is a filehandle it will carry out a seek to the eof before writing any uncompressed data. If the output is a filename, it will be opened for appending. If the output is a buffer, all uncompressed data will be appended to the existing buffer.</source>
          <target state="translated">所以当输出是一个文件柄时,它将在写入任何未压缩的数据之前对eof进行寻址。如果输出是一个文件名,它将被打开进行追加。如果输出是一个缓冲区,所有未压缩的数据将被追加到现有的缓冲区。</target>
        </trans-unit>
        <trans-unit id="faf320f95dede4954f64d637d17b4ef0ec2ac56b" translate="yes" xml:space="preserve">
          <source>So when we parse &lt;code&gt;/foo/&lt;/code&gt; we see something like the following table. The left shows what is being parsed, and the number indicates where the next regop would go. The stuff on the right is the trace output of the graph. The names are chosen to be short to make it less dense on the screen. 'tsdy' is a special form of &lt;code&gt;regtail()&lt;/code&gt; which does some extra analysis.</source>
          <target state="translated">因此，当我们解析 &lt;code&gt;/foo/&lt;/code&gt; 我们会看到类似下表的内容。左侧显示了要解析的内容，数字表示下一个重新加载的位置。右侧的内容是图形的跟踪输出。选择的名称要短一些，以使其在屏幕上的密度较小。'tsdy'是 &lt;code&gt;regtail()&lt;/code&gt; 的一种特殊形式，它进行了一些额外的分析。</target>
        </trans-unit>
        <trans-unit id="4ca42b2545bb9f74c7dfcf26ad336456861738d0" translate="yes" xml:space="preserve">
          <source>So why is UNINST=1 not the default?</source>
          <target state="translated">那么为什么UNINST=1不是默认的呢?</target>
        </trans-unit>
        <trans-unit id="5764d39b6b45dd4fdf0407e6dadfbf8730c1c2c3" translate="yes" xml:space="preserve">
          <source>So why use these? They produce better diagnostics on failure. &lt;code&gt;ok()&lt;/code&gt; cannot know what you are testing for (beyond the name), but &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; know what the test was and why it failed. For example this test:</source>
          <target state="translated">那么为什么要使用这些呢？它们可以对故障进行更好的诊断。 &lt;code&gt;ok()&lt;/code&gt; 无法知道您要测试的内容（名称之外），但是 &lt;code&gt;is()&lt;/code&gt; 和 &lt;code&gt;isnt()&lt;/code&gt; 知道测试的内容以及测试失败的原因。例如此测试：</target>
        </trans-unit>
        <trans-unit id="0723871c8efb4af11337b70788bc11e5f341de34" translate="yes" xml:space="preserve">
          <source>So why would you ever want to use a Unix domain socket instead of a simpler named pipe? Because a named pipe doesn't give you sessions. You can't tell one process's data from another's. With socket programming, you get a separate session for each client; that's why accept() takes two arguments.</source>
          <target state="translated">那么为什么你要使用Unix域套接字而不是更简单的命名管道呢?因为命名管道不会给你提供会话。你无法区分一个进程的数据和另一个进程的数据。使用套接字编程,你可以为每个客户端获得一个单独的会话;这就是为什么accept()需要两个参数。</target>
        </trans-unit>
        <trans-unit id="907dfd8f705f1e1d725ffd018f44b3318d9e84e1" translate="yes" xml:space="preserve">
          <source>So you can figure out what went wrong without rerunning the test.</source>
          <target state="translated">所以你可以在不重新运行测试的情况下,找出问题所在。</target>
        </trans-unit>
        <trans-unit id="85a109f19c85f2e155b7bae45252c43e85217d92" translate="yes" xml:space="preserve">
          <source>So you should instead try this;</source>
          <target state="translated">所以你反而应该试试这个。</target>
        </trans-unit>
        <trans-unit id="99368e21d7e985fc9382de7cbad3270d6b572550" translate="yes" xml:space="preserve">
          <source>So you want to know what &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; actually does?</source>
          <target state="translated">因此，您想知道 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 实际上是做什么的吗？</target>
        </trans-unit>
        <trans-unit id="d98457d69f47757522cf080b8cba6d90757ec58b" translate="yes" xml:space="preserve">
          <source>So, beside calls like</source>
          <target state="translated">所以,除了像这样的电话之外</target>
        </trans-unit>
        <trans-unit id="8b676466aa2043751e164c60e8f768fad4f2409b" translate="yes" xml:space="preserve">
          <source>So, for classes and subclasses to have inheritance correctly work with autoloading, you need to ensure stubs are loaded.</source>
          <target state="translated">所以,要想让类和子类的继承正确地与自动加载一起工作,你需要确保存根被加载。</target>
        </trans-unit>
        <trans-unit id="3fdc850c88acfeea0034b4d0a5ecf1cbe8955116" translate="yes" xml:space="preserve">
          <source>So, for example, &quot;wb9&quot; means open for writing with the maximum compression using the default strategy and &quot;wb4R&quot; means open for writing with compression level 4 and run-length encoding.</source>
          <target state="translated">所以,举例来说,&quot;wb9 &quot;意味着使用默认策略的最大压缩量打开写入,&quot;wb4R &quot;意味着使用压缩级别4和运行长度编码打开写入。</target>
        </trans-unit>
        <trans-unit id="98d3c65256a4087c70ab29c5923eefef7208b53e" translate="yes" xml:space="preserve">
          <source>So, for instance, to pack 20302 to a signed 16 bit integer in your computer's representation you write</source>
          <target state="translated">所以,例如,要把20302包装成一个有符号的16位整数,在你的计算机中,你写道</target>
        </trans-unit>
        <trans-unit id="5a026df42e6a15ca497ded704c00f477c0e8e518" translate="yes" xml:space="preserve">
          <source>So, if you see two terms with an &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; , between them, you can turn them into a single expression. When you do this, you execute the code in the block on the next line: if you see &lt;code&gt;=&lt;/code&gt; , you'll do the code in line 2. If you see &lt;code&gt;+&lt;/code&gt; , you'll do the code in line 4. It's this code which contributes to the op tree.</source>
          <target state="translated">因此，如果看到两个带有 &lt;code&gt;=&lt;/code&gt; 或 &lt;code&gt;+&lt;/code&gt; 的项，则可以将它们变成单个表达式。执行此操作时，将在下一行的代码块中执行代码：如果看到 &lt;code&gt;=&lt;/code&gt; ，则将在第2行中执行代码。如果看到 &lt;code&gt;+&lt;/code&gt; ，则将在第4行中进行代码。这有助于op树。</target>
        </trans-unit>
        <trans-unit id="f012b7bad59a01daf6da8ed100b9c040ae573c55" translate="yes" xml:space="preserve">
          <source>So, if you want to collect memory info in a cycle, you may call</source>
          <target state="translated">所以,如果你想在一个周期内收集内存信息,你可以调用</target>
        </trans-unit>
        <trans-unit id="f33ef09895b9595e58c40994534996d41b9b84f6" translate="yes" xml:space="preserve">
          <source>So, in general, &quot;state&quot; subroutines are faster. But &quot;my&quot; subs are necessary if you want to create closures:</source>
          <target state="translated">所以,一般来说,&quot;状态 &quot;子程序更快。但如果你想创建闭包,&quot;我的 &quot;子程序是必要的。</target>
        </trans-unit>
        <trans-unit id="b92446e0fc5150a550f9b239a78e7589775be2a5" translate="yes" xml:space="preserve">
          <source>So, let's say you want to add a custom element called 'foo'. In your subclass's &lt;code&gt;new&lt;/code&gt; method, after calling &lt;code&gt;SUPER::new&lt;/code&gt; you'd call:</source>
          <target state="translated">因此，假设您要添加一个名为&amp;ldquo; foo&amp;rdquo;的自定义元素。在子类的 &lt;code&gt;new&lt;/code&gt; 方法中，调用 &lt;code&gt;SUPER::new&lt;/code&gt; 您将调用：</target>
        </trans-unit>
        <trans-unit id="04546d861006181e7076b52be007eeaf163f592b" translate="yes" xml:space="preserve">
          <source>So, rather than having to say:</source>
          <target state="translated">所以,与其说是。</target>
        </trans-unit>
        <trans-unit id="ce7cf438ffd137d4b9ae434030e4dd1bac347bb0" translate="yes" xml:space="preserve">
          <source>So, saying &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; performs the &quot;and&quot; operation on numbers (yielding &lt;code&gt;3&lt;/code&gt; ). Saying &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; performs the &quot;and&quot; operation on strings (yielding &lt;code&gt;&quot;1&quot;&lt;/code&gt; ).</source>
          <target state="translated">因此，说 &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; 对数字执行&amp;ldquo;与&amp;rdquo;运算（产生 &lt;code&gt;3&lt;/code&gt; ）。说 &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; 对字符串执行&amp;ldquo;和&amp;rdquo;运算（产生 &lt;code&gt;&quot;1&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4a687b4464c81c65ad71b0b242c9a17889c06be5" translate="yes" xml:space="preserve">
          <source>So, sometimes you might want to use symbolic references to manipulate the symbol table directly. This doesn't matter for formats, handles, and subroutines, because they are always global--you can't use my() on them. For scalars, arrays, and hashes, though--and usually for subroutines-- you probably only want to use hard references.</source>
          <target state="translated">所以,有时你可能会想使用符号引用来直接操作符号表,这对格式、句柄和子程序来说并不重要,因为它们总是全局的--你不能对它们使用my()。对于格式、句柄和子程序来说,这并不重要,因为它们总是全局的--你不能对它们使用my()。但对于标量、数组和散列--通常对于子程序--你可能只想使用硬引用。</target>
        </trans-unit>
        <trans-unit id="8b62c1a83484ac0f80542a2de9bd04874ec15952" translate="yes" xml:space="preserve">
          <source>So, the following examples will now work all as expected:</source>
          <target state="translated">所以,下面的例子现在将全部按照预期工作。</target>
        </trans-unit>
        <trans-unit id="b83b5043b490e39d23dba00f7ce754a2ed020ba9" translate="yes" xml:space="preserve">
          <source>So, the following line:</source>
          <target state="translated">所以,下面这句话。</target>
        </trans-unit>
        <trans-unit id="e43264c4b337b0feb1da1b34ab4669d9bfde22ae" translate="yes" xml:space="preserve">
          <source>So, the following two statements do the same thing:</source>
          <target state="translated">所以,下面两句话的作用是一样的。</target>
        </trans-unit>
        <trans-unit id="0f5b24deb12867f441d62aa11cf38e02b6693a70" translate="yes" xml:space="preserve">
          <source>So, the string of Martian &quot;I am CVSGXX!&quot; uses 12 bytes to encode the nine characters 'I', ' ', 'a', 'm', ' ', 'CV', 'SG', 'XX', '!'.</source>
          <target state="translated">所以,火星人 &quot;我是CVSGXX!&quot;这个字符串用12个字节来编码'I'、''、'a'、'm'、''、'CV'、'SG'、'XX'、'!'这九个字符。</target>
        </trans-unit>
        <trans-unit id="666f233dad00e2e027af2bcddbc736103b174459" translate="yes" xml:space="preserve">
          <source>So, what's the big problem with that? It looks right, doesn't it? After all, I just told you that you need an array of references, so by golly, you've made me one!</source>
          <target state="translated">那么,这有什么大问题呢?它看起来是对的,不是吗?毕竟,我刚刚告诉你,你需要一个引用的数组,所以天哪,你给我做了一个数组!</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="93c6a1f183694628e37ced41591147bfc0da1908" translate="yes" xml:space="preserve">
          <source>Socket</source>
          <target state="translated">Socket</target>
        </trans-unit>
        <trans-unit id="1a669dbe9f824af2034872bc98a2b6823a4c09af" translate="yes" xml:space="preserve">
          <source>Socket option level constant for setsockopt() and getsockopt().</source>
          <target state="translated">setockopt()和getockopt()的Socket选项级别常数。</target>
        </trans-unit>
        <trans-unit id="e89a311c363b4ef4dc4be93eaeb6560498486275" translate="yes" xml:space="preserve">
          <source>Socket option name constants for IPv4 socket options at the &lt;code&gt;IPPROTO_IP&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;IPPROTO_IP&lt;/code&gt; 级别的IPv4套接字选项的套接字选项名称常量。</target>
        </trans-unit>
        <trans-unit id="d741b5bebfd867658e744ca3a901afeae953cecf" translate="yes" xml:space="preserve">
          <source>Socket option name constants for IPv6 socket options at the &lt;code&gt;IPPROTO_IPV6&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;IPPROTO_IPV6&lt;/code&gt; 级别的IPv6套接字选项的套接字选项名称常量。</target>
        </trans-unit>
        <trans-unit id="1bea3c52b1b205afb6610aaf669b9a46fdff261d" translate="yes" xml:space="preserve">
          <source>Socket option name constants for TCP socket options at the &lt;code&gt;IPPROTO_TCP&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;IPPROTO_TCP&lt;/code&gt; 级别的TCP套接字选项的套接字选项名称常量。</target>
        </trans-unit>
        <trans-unit id="8943cecdeb64eeb6c75caac188d81a6e580de3c7" translate="yes" xml:space="preserve">
          <source>Socket option name constants for setsockopt() and getsockopt() at the &lt;code&gt;SOL_SOCKET&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;SOL_SOCKET&lt;/code&gt; 级别的setsockopt（）和getsockopt（）的套接字选项名称常量。</target>
        </trans-unit>
        <trans-unit id="8a16f3d4e350888989be5c310a53b83649d06948" translate="yes" xml:space="preserve">
          <source>Socket option value constants for &lt;code&gt;IP_TOS&lt;/code&gt; socket option.</source>
          <target state="translated">&lt;code&gt;IP_TOS&lt;/code&gt; 套接字选项的套接字选项值常数。</target>
        </trans-unit>
        <trans-unit id="734337896e45cc2ebeff48479a66b46bdd05ddb4" translate="yes" xml:space="preserve">
          <source>Socket type constants to use as the second argument to socket(), or the value of the &lt;code&gt;SO_TYPE&lt;/code&gt; socket option.</source>
          <target state="translated">套接字类型常量，用作socket（）的第二个参数，或 &lt;code&gt;SO_TYPE&lt;/code&gt; 套接字选项的值。</target>
        </trans-unit>
        <trans-unit id="5bedda872ecdb70c2a2d140ada477f5b294eb6f0" translate="yes" xml:space="preserve">
          <source>Socket.</source>
          <target state="translated">Socket.</target>
        </trans-unit>
        <trans-unit id="ebe92a08483968e414740930bf0a0a08483ad931" translate="yes" xml:space="preserve">
          <source>Socket.a</source>
          <target state="translated">Socket.a</target>
        </trans-unit>
        <trans-unit id="848572346180cfeef643ccd7fddcc1762d26f13a" translate="yes" xml:space="preserve">
          <source>Sockets: Client/Server Communication</source>
          <target state="translated">套接字。客户机/服务器通信</target>
        </trans-unit>
        <trans-unit id="bbfadcc007c702d16ecd0e6f6d3baeefff3d72aa" translate="yes" xml:space="preserve">
          <source>Solaris 10 documentation on syslog, &lt;a href=&quot;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&quot;&gt;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&lt;/a&gt;</source>
          <target state="translated">有关syslog的Solaris 10文档，&lt;a href=&quot;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&quot;&gt;http：//docs.sun.com/app/docs/doc/816-5168/syslog-3c？a = view&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98fa552d1b28be69cf1da96419b8a90307162871" translate="yes" xml:space="preserve">
          <source>Solaris 7 and above will run in either 32 bit or 64 bit mode on SPARC CPUs, via a reboot. You can build 64 bit apps whilst running 32 bit mode and vice-versa. 32 bit apps will run under Solaris running in either 32 or 64 bit mode. 64 bit apps require Solaris to be running 64 bit mode.</source>
          <target state="translated">Solaris 7及以上版本将通过重启在SPARC CPU上以32位或64位模式运行。您可以在运行32位模式时构建64位应用程序,反之亦然。32位应用程序将在32位或64位模式的Solaris下运行。64位应用程序需要Solaris运行在64位模式下。</target>
        </trans-unit>
        <trans-unit id="6ef2766b707c501497b46c746afec2754f6fc860" translate="yes" xml:space="preserve">
          <source>Solaris Version Numbers.</source>
          <target state="translated">Solaris版本号。</target>
        </trans-unit>
        <trans-unit id="cc61dfb91810e5a0313350199a1b65c0af136cfa" translate="yes" xml:space="preserve">
          <source>Solaris global loading added by Nick Ing-Simmons with design/coding assistance from Tim Bunce, January 1996.</source>
          <target state="translated">1996年1月,Nick Ing-Simmons在Tim Bunce的设计/编码协助下增加了Solaris全局加载。</target>
        </trans-unit>
        <trans-unit id="708154fc528413c51483abd6933e68d503e36bdc" translate="yes" xml:space="preserve">
          <source>Solaris may include two versions of perl, e.g. Solaris 9 includes both 5.005_03 and 5.6.1. This is to provide stability across Solaris releases, in cases where a later perl version has incompatibilities with the version included in the preceding Solaris release. The default perl version will always be the most recent, and in general the old version will only be retained for one Solaris release. Note also that the default perl will NOT be configured to search for modules in the older version, again due to compatibility/stability concerns. As a consequence if you upgrade Solaris, you will have to rebuild/reinstall any additional CPAN modules that you installed for the previous Solaris version. See the CPAN manpage under 'autobundle' for a quick way of doing this.</source>
          <target state="translated">Solaris可能包含两个版本的perl,例如Solaris 9包括5.005_03和5.6.1。这是为了在Solaris的各个版本中提供稳定性,以防以后的perl版本与前一个Solaris版本中的版本不兼容。默认的 perl 版本总是最新的,一般来说,旧的版本只会在一个 Solaris 版本中保留。还请注意,同样出于兼容性/稳定性的考虑,默认的 perl 将不会被配置为搜索旧版本中的模块。因此,如果你升级Solaris,你将不得不重建/重新安装你为以前的Solaris版本安装的任何额外的CPAN模块。请参阅CPAN手册中 &quot;autobundle &quot;一栏,了解如何快速完成这项工作。</target>
        </trans-unit>
        <trans-unit id="4bfa1cd2c976e4c546cb366d1dac1622384583a6" translate="yes" xml:space="preserve">
          <source>Solaris provides some BSD-compatibility functions in /usr/ucblib/libucb.a. Perl will not build and run correctly if linked against -lucb since it contains routines that are incompatible with the standard Solaris libc. Normally this is not a problem since the solaris hints file prevents Configure from even looking in /usr/ucblib for libraries, and also explicitly omits -lucb.</source>
          <target state="translated">Solaris 在 /usr/ucblib/libucb.a 中提供了一些与 BSD 兼容的函数。如果与 -lucb 相连,Perl 将无法正确地构建和运行,因为它包含了与标准 Solaris libc 不兼容的例程。通常这不是问题,因为 solaris 提示文件会阻止 Configure 在 /usr/ucblib 中查找库,而且还明确省略了 -lucb。</target>
        </trans-unit>
        <trans-unit id="d0c3f51965773ced91efb778a3671a3477592fd4" translate="yes" xml:space="preserve">
          <source>Solaris ships with a range of Solaris-specific modules. If you choose to install your own version of perl you will find the source of many of these modules is available on CPAN under the Sun::Solaris:: namespace.</source>
          <target state="translated">Solaris提供了一系列Solaris特有的模块,如果你选择安装你自己版本的perl,你会发现许多这些模块的源码在CPAN的Sun::Solaris::命名空间下。如果你选择安装你自己的perl版本,你会发现这些模块的源代码在CPAN上的Sun::Solaris::命名空间下有很多。</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="05b004a92e5eda3ec6e47516b582fc25b61b35b9" translate="yes" xml:space="preserve">
          <source>Solutions</source>
          <target state="translated">Solutions</target>
        </trans-unit>
        <trans-unit id="00b2aad45d07b70e1b7eefea74316913901b6e42" translate="yes" xml:space="preserve">
          <source>Some</source>
          <target state="translated">Some</target>
        </trans-unit>
        <trans-unit id="5f679f54e4d0cf2197954f773a392f8d165d2696" translate="yes" xml:space="preserve">
          <source>Some (minor) parts copyright 2009 Adam Kennedy.</source>
          <target state="translated">部分(小部分)版权归亚当-肯尼迪2009年所有。</target>
        </trans-unit>
        <trans-unit id="3a644bfc8b4acacc1b56f8b5a49f0fbd16c47364" translate="yes" xml:space="preserve">
          <source>Some *nix programs use fork() a lot; with the mostly useful flavors of perl for OS/2 (there are several built simultaneously) this is supported; but some flavors do not support this (e.g., when Perl is called from inside REXX). Using fork() after</source>
          <target state="translated">一些*nix程序经常使用fork();对于大多数有用的perl for OS/2风味(有几个同时构建的),它是支持的;但有些风味不支持这个(例如,当Perl从REX内部调用时)。使用 fork()后的</target>
        </trans-unit>
        <trans-unit id="6a808c47f9491da438c1507c81067e0d0ad1d610" translate="yes" xml:space="preserve">
          <source>Some / became \ in pdksh.</source>
          <target state="translated">有些/成为了pdksh。</target>
        </trans-unit>
        <trans-unit id="2ced2108dbb21d847b539e5bf8d6eae4e6952b9e" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;/&lt;/code&gt; became &lt;code&gt;\&lt;/code&gt; in pdksh.</source>
          <target state="translated">一些 &lt;code&gt;/&lt;/code&gt; 在pdksh中变成 &lt;code&gt;\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aee5f872bb2cc36da4c3ed1ff4e14aea96b6faa3" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;Win*&lt;/code&gt; entry points also overload a &quot;meaningful&quot; return value with the error indicator; having a 0 return value indicates an error. Yet some other &lt;code&gt;Win*&lt;/code&gt; entry points overload things even more, and 0 return value may mean a successful call returning a valid value 0, as well as an error condition; in the case of a 0 return value one should call WinGetLastError() API to distinguish a successful call from a failing one.</source>
          <target state="translated">一些 &lt;code&gt;Win*&lt;/code&gt; 入口点还会使带有错误指示符的&amp;ldquo;有意义的&amp;rdquo;返回值超载。返回值为0表示错误。还有一些其他 &lt;code&gt;Win*&lt;/code&gt; 入口点甚至使事情更加过载，返回值0可能意味着成功的调用将返回有效值0以及错误情况。如果返回值为0，则应调用WinGetLastError（）API来区分成功调用和失败调用。</target>
        </trans-unit>
        <trans-unit id="7d77130c6b6fd9352c737bed1bb1dcb935bd9ca9" translate="yes" xml:space="preserve">
          <source>Some DLLs are only present in some versions of OS/2, or in some configurations of OS/2. Some exported entry points are present only in DLLs shipped with some versions of OS/2. If these DLLs and entry points were linked directly for a Perl executable/DLL or from a Perl extensions, this binary would work only with the specified versions/setups. Even if these entry points were not needed, the</source>
          <target state="translated">有些DLL只存在于某些版本的OS/2中,或某些配置的OS/2中。一些导出的入口点只存在于某些版本的OS/2的DLL中。如果这些 DLLs 和入口点直接链接到一个 Perl 可执行文件/DLL 或来自 Perl 扩展,那么这个二进制文件将只在指定的版本/设置中工作。即使不需要这些入口点,这个</target>
        </trans-unit>
        <trans-unit id="14adc2a370c74e9f0b7a6eb136961fb44f4e9d5e" translate="yes" xml:space="preserve">
          <source>Some IBM EBCDIC character sets may be known by character code set identification numbers (CCSID numbers) or code page numbers.</source>
          <target state="translated">一些IBM EBCDIC字符集可以通过字符代码集识别号(CCSID号)或代码页号来了解。</target>
        </trans-unit>
        <trans-unit id="20970d609d169c267b614af470114dc6b026c453" translate="yes" xml:space="preserve">
          <source>Some Irix cc versions, e.g. 7.3.1.1m (try cc -version) have been known to have issues (coredumps) when compiling perl.c. If you've used -OPT:fast_io=ON and this happens, try removing it. If that fails, or you didn't use that, then try adjusting other optimization options (-LNO, -INLINE, -O3 to -O2, etcetera). The compiler bug has been reported to SGI. (Allen Smith &amp;lt;easmith@beatrice.rutgers.edu&amp;gt;)</source>
          <target state="translated">已知某些Irix cc版本，例如7.3.1.1m（尝试cc -version）在编译perl.c时会出现问题（coredumps）。如果您使用-OPT：fast_io = ON并发生这种情况，请尝试将其删除。如果失败，或者您没有使用它，请尝试调整其他优化选项（-LNO，-INLINE，-O3到-O2等）。编译器错误已报告给SGI。 （艾伦&amp;middot;史密斯&amp;lt;easmith@beatrice.rutgers.edu&amp;gt;）</target>
        </trans-unit>
        <trans-unit id="e270800f9e2c9ef58198c6c9f8463f63bac86a3b" translate="yes" xml:space="preserve">
          <source>Some Linux platforms have a maximum stack size. Setting too large of a stack size will cause thread creation to fail.</source>
          <target state="translated">有些Linux平台有最大的堆栈大小,设置过大的堆栈大小会导致线程创建失败。设置过大的栈大小会导致线程创建失败。</target>
        </trans-unit>
        <trans-unit id="bad9f67e1f3cb77c4fe9db59234d0c5d6bb841b2" translate="yes" xml:space="preserve">
          <source>Some OSes do not need these in which case leave it blank.</source>
          <target state="translated">有些操作系统不需要这些,在这种情况下,留下空白。</target>
        </trans-unit>
        <trans-unit id="69e7c8fdafb5d76df4c8f736ecf437657f4dc150" translate="yes" xml:space="preserve">
          <source>Some Pod formatters output to formats that implement non-breaking spaces as an individual character (which I'll call &quot;NBSP&quot;), and others output to formats that implement non-breaking spaces just as spaces wrapped in a &quot;don't break this across lines&quot; code. Note that at the level of Pod, both sorts of codes can occur: Pod can contain a NBSP character (whether as a literal, or as a &quot;E&amp;lt;160&amp;gt;&quot; or &quot;E&amp;lt;nbsp&amp;gt;&quot; code); and Pod can contain &quot;S&amp;lt;foo I&amp;lt;bar&amp;gt; baz&amp;gt;&quot; codes, where &quot;mere spaces&quot; (character 32) in such codes are taken to represent non-breaking spaces. Pod parsers should consider supporting the optional parsing of &quot;S&amp;lt;foo I&amp;lt;bar&amp;gt; baz&amp;gt;&quot; as if it were &quot;foo</source>
          <target state="translated">一些Pod格式化程序输出为将不间断空格作为单个字符实现的格式（我将其称为&amp;ldquo; NBSP&amp;rdquo;），而其他Pod格式化程序将输出为实现不间断空格的格式，例如包装为&amp;ldquo;不要破坏该空格&amp;rdquo;的格式跨行&amp;rdquo;代码。请注意，在Pod级别上，两种代码都可能发生：Pod可以包含NBSP字符（无论是文字，还是&amp;ldquo; E &amp;lt;160&amp;gt;&amp;rdquo;或&amp;ldquo; E &amp;lt;nbsp&amp;gt;&amp;rdquo;代码）； Pod和Pod可以包含&amp;ldquo; S &amp;lt;foo I &amp;lt;bar&amp;gt; baz&amp;gt;&amp;rdquo;代码，其中此类代码中的&amp;ldquo;纯空格&amp;rdquo;（字符32）用于表示不间断空格。 Pod解析器应考虑支持&amp;ldquo; S &amp;lt;foo I &amp;lt;bar&amp;gt; baz&amp;gt;&amp;rdquo;的可选解析，就好像它是&amp;ldquo; foo&amp;rdquo;一样。</target>
        </trans-unit>
        <trans-unit id="f04294d93d5e63f6eed93e1148616595ef1487e2" translate="yes" xml:space="preserve">
          <source>Some Sys-V based systems, notably Solaris 2.X, redefined some of the standard socket constants. Since these were constant across all architectures, they were often hardwired into perl code. The proper way to deal with this is to &quot;use Socket&quot; to get the correct values.</source>
          <target state="translated">一些基于Sys-V的系统,尤其是Solaris 2.X,重新定义了一些标准的socket常量。由于这些常量在所有的架构中都是不变的,所以它们经常被硬生生地加入到perl代码中。处理这种情况的正确方法是 &quot;使用Socket &quot;来获得正确的值。</target>
        </trans-unit>
        <trans-unit id="a5a0c5f6bf86975f2c301ba492652230f705bf5a" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; ; and there are only a few dozen possible General Categories.</source>
          <target state="translated">某些Unicode属性具有一组受限制的合法值。例如，所有二进制属性都被限制为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ；而且只有几十种可能的常规类别。</target>
        </trans-unit>
        <trans-unit id="9e6eb6762559c642717c0b35b0e9407b4ea3c431" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; ; and there are only a few dozen possible General Categories. Use &lt;code&gt;prop_values&lt;/code&gt; to find out if a given property is one such, and if so, to get a list of the values:</source>
          <target state="translated">某些Unicode属性具有一组受限制的合法值。例如，所有二进制属性都被限制为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ；而且只有几十种可能的常规类别。使用 &lt;code&gt;prop_values&lt;/code&gt; 找出给定的属性是否为此类属性，如果是，则获取值列表：</target>
        </trans-unit>
        <trans-unit id="abd2e23e9cee0c22d7103f4f9a78d73d761dd3aa" translate="yes" xml:space="preserve">
          <source>Some approximate operating system names and their &lt;code&gt;$^O&lt;/code&gt; values in the &quot;OTHER&quot; category include:</source>
          <target state="translated">一些近似的操作系统名称及其在&amp;ldquo; OTHER&amp;rdquo;类别中的 &lt;code&gt;$^O&lt;/code&gt; 值包括：</target>
        </trans-unit>
        <trans-unit id="fc63731ea34f43c4af1c4ec405f7ea69ef1d9704" translate="yes" xml:space="preserve">
          <source>Some authors have strange characters in their names.</source>
          <target state="translated">有些作者的名字里有奇怪的字。</target>
        </trans-unit>
        <trans-unit id="6877eb2746dbad4bb0e9e27d968022bfea3412f0" translate="yes" xml:space="preserve">
          <source>Some background on thread implementations from the operating system viewpoint. There are three basic categories of threads: user-mode threads, kernel threads, and multiprocessor kernel threads.</source>
          <target state="translated">从操作系统的角度介绍一下线程实现的背景。线程有三个基本类别:用户模式线程、内核线程和多处理器内核线程。</target>
        </trans-unit>
        <trans-unit id="fc0d6a626635ac5ae4291cc3487e50efd6ae5a14" translate="yes" xml:space="preserve">
          <source>Some bits may be relevant at compile-time only, some at run-time only. This is a new mechanism and the details may change. See also &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;.</source>
          <target state="translated">一些位可能仅在编译时相关，而某些位仅在运行时相关。这是一个新机制，细节可能会更改。另请参阅&lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd8e9b1766f0e1e6eaaded7abc870a37e4571ff0" translate="yes" xml:space="preserve">
          <source>Some brief examples:</source>
          <target state="translated">一些简单的例子:</target>
        </trans-unit>
        <trans-unit id="61327002f5b3861abd79c62e144ccb79536f4f22" translate="yes" xml:space="preserve">
          <source>Some builtins (e.g. &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt;) has a call signature that cannot completely be representated with a Perl prototype. This means that some valid Perl code will be invalid under autodie. As an example:</source>
          <target state="translated">一些内置函数（例如 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; ）具有不能完全用Perl原型表示的调用签名。这意味着某些有效的Perl代码在autodie下将无效。举个例子：</target>
        </trans-unit>
        <trans-unit id="21eaccc7842c81c4d4f8ac981ea6b511271286ba" translate="yes" xml:space="preserve">
          <source>Some calls simply aren't available, real or emulated, on every platform.</source>
          <target state="translated">有些电话根本不是每个平台都能用,真实的或仿真的。</target>
        </trans-unit>
        <trans-unit id="7144ad6e6fa073f902e93d5905df49ebac937d92" translate="yes" xml:space="preserve">
          <source>Some code points also have abbreviated names, such as &quot;LF&quot; or &quot;NL&quot;. &lt;code&gt;viacode&lt;/code&gt; never returns these.</source>
          <target state="translated">一些代码点还具有缩写名称，例如&amp;ldquo; LF&amp;rdquo;或&amp;ldquo; NL&amp;rdquo;。 &lt;code&gt;viacode&lt;/code&gt; 从不返回这些。</target>
        </trans-unit>
        <trans-unit id="73ac6d49c092929d2ed08d514c7b1beb64ede02a" translate="yes" xml:space="preserve">
          <source>Some code taken from &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Catch&quot;&gt;Test::Catch&lt;/a&gt;, written by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;. Hence, those parts Copyright Micheal G Schwern 2001. Used and distributed with permission.</source>
          <target state="translated">一些代码取自Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;编写的&lt;a href=&quot;../more&quot;&gt;Test :: More&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Catch&quot;&gt;Test :: Catch&lt;/a&gt;。因此，这些部分版权所有Micheal G Schwern2001。经许可使用和分发。</target>
        </trans-unit>
        <trans-unit id="a1339e50839100723841e8e48747e9f9a1f5bed3" translate="yes" xml:space="preserve">
          <source>Some constants and functions are exported by default by this module; but for backward-compatibility any recently-added symbols are not exported by default and must be requested explicitly. When an import list is provided to the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; line, the default exports are not automatically imported. It is therefore best practice to always to explicitly list all the symbols required.</source>
          <target state="translated">默认情况下，此模块会导出一些常量和函数。但是为了向后兼容，默认情况下不会导出任何最近添加的符号，而必须明确地请求它们。向 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; 行提供导入列表时，不会自动导入默认导出。因此，最佳实践是始终明确列出所需的所有符号。</target>
        </trans-unit>
        <trans-unit id="078dd465c32a4795a8e3e38bd49c7d92d32009a8" translate="yes" xml:space="preserve">
          <source>Some constants don't print correctly either with or without &lt;b&gt;-d&lt;/b&gt;. For instance, neither B::Deparse nor Data::Dumper know how to print dual-valued scalars correctly, as in:</source>
          <target state="translated">使用&lt;b&gt;-d&lt;/b&gt;或不使用&lt;b&gt;-d，&lt;/b&gt;某些常量均无法正确打印。例如，B :: Deparse或Data :: Dumper都不知道如何正确打印双值标量，如：</target>
        </trans-unit>
        <trans-unit id="0e689eba4cf9a38a4acdff5d45d4adaf1f020711" translate="yes" xml:space="preserve">
          <source>Some contexts allow 2 or even 1 digit, but any usage without exactly three digits, the first being a zero, may give unintended results. (For example, in a regular expression it may be confused with a backreference; see &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;Octal escapes in perlrebackslash&lt;/a&gt;.) Starting in Perl 5.14, you may use &lt;code&gt;\o{}&lt;/code&gt; instead, which avoids all these problems. Otherwise, it is best to use this construct only for ordinals &lt;code&gt;\077&lt;/code&gt; and below, remembering to pad to the left with zeros to make three digits. For larger ordinals, either use &lt;code&gt;\o{}&lt;/code&gt; , or convert to something else, such as to hex and use &lt;code&gt;\N{U+}&lt;/code&gt; (which is portable between platforms with different character sets) or &lt;code&gt;\x{}&lt;/code&gt; instead.</source>
          <target state="translated">有些上下文允许2甚至1位数字，但是任何没有正好3位数字的用法（第一个为零）可能会产生意想不到的结果。 （例如，在正则表达式中，它可能与反向引用混淆；请参阅&lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;perlrebackslash中的八进制转义&lt;/a&gt;。）从Perl 5.14开始，可以改用 &lt;code&gt;\o{}&lt;/code&gt; ，这样可以避免所有这些问题。否则，最好仅对 &lt;code&gt;\077&lt;/code&gt; 及以下的普通字符使用此构造，记住要在左边用零填充以产生三位数。对于较大的普通字符，请使用 &lt;code&gt;\o{}&lt;/code&gt; 或转换为其他内容，例如十六进制并使用 &lt;code&gt;\N{U+}&lt;/code&gt; （可在具有不同字符集的平台之间移植）或使用 &lt;code&gt;\x{}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17469d7643e0741d1ada43cbcada6ad7b4213174" translate="yes" xml:space="preserve">
          <source>Some cool command line examples to impress the Python crowd ;)</source>
          <target state="translated">一些很酷的命令行例子,让Python人群印象深刻;)</target>
        </trans-unit>
        <trans-unit id="4f597c06196db5dfae23debf5b526fce9cd25685" translate="yes" xml:space="preserve">
          <source>Some cool command line examples to impress the Python crowd ;) You might want to compare them to the results under -Mbignum or -Mbigrat:</source>
          <target state="translated">一些很酷的命令行示例会给Python人群留下深刻的印象;)你可能想把它们与-Mbignum或-Mbigrat下的结果进行比较。</target>
        </trans-unit>
        <trans-unit id="c6746b978d2a5bd75b46a34b757950222f7e2d87" translate="yes" xml:space="preserve">
          <source>Some database drivers for DBI can also automatically encode and decode, but that is sometimes limited to the UTF-8 encoding.</source>
          <target state="translated">一些DBI的数据库驱动程序也可以自动编码和解码,但这有时仅限于UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="20c968c59a29a0ad6a0ddbad176bb82749120644" translate="yes" xml:space="preserve">
          <source>Some devices will be expecting a &quot;\r&quot; at the end of each line rather than a &quot;\n&quot;. In some ports of perl, &quot;\r&quot; and &quot;\n&quot; are different from their usual (Unix) ASCII values of &quot;\015&quot; and &quot;\012&quot;. You may have to give the numeric values you want directly, using octal (&quot;\015&quot;), hex (&quot;0x0D&quot;), or as a control-character specification (&quot;\cM&quot;).</source>
          <target state="translated">有些设备会期望在每行末尾有一个&quot;\r &quot;而不是&quot;\n&quot;。在 perl 的某些端口中,&quot;\r&quot; 和 &quot;\n&quot; 与它们通常的 (Unix)ASCII 值 &quot;\015&quot; 和 &quot;\012&quot; 不同。您可能必须直接给出您想要的数值,使用八进制 (&quot;\015&quot;)、 十六进制 (&quot;0x0D&quot;),或作为控制字符规范 (&quot;\cM&quot;)。</target>
        </trans-unit>
        <trans-unit id="b15270299f74ddedc9cb2a27cec0a8d56d430a18" translate="yes" xml:space="preserve">
          <source>Some digits that &lt;code&gt;\d&lt;/code&gt; matches look like some of the [0-9] ones, but have different values. For example, BENGALI DIGIT FOUR (U+09EA) looks very much like an ASCII DIGIT EIGHT (U+0038). An application that is expecting only the ASCII digits might be misled, or if the match is &lt;code&gt;\d+&lt;/code&gt; , the matched string might contain a mixture of digits from different writing systems that look like they signify a number different than they actually do. &lt;a href=&quot;unicode/ucd#num()&quot;&gt;num() in Unicode::UCD&lt;/a&gt; can be used to safely calculate the value, returning &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the input string contains such a mixture.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 匹配的某些数字看起来像[0-9]中的某些数字，但具有不同的值。例如，BENGALI DIGIT FOUR（U + 09EA）看起来非常像ASCII DIGIT EIGHT（U + 0038）。预期仅ASCII数字的应用程序可能会被误导，或者如果匹配为 &lt;code&gt;\d+&lt;/code&gt; ，则匹配的字符串可能包含来自不同书写系统的数字的混合，看起来它们表示的数字与实际数字不同。&lt;a href=&quot;unicode/ucd#num()&quot;&gt;Unicode :: UCD中的num（）&lt;/a&gt;可用于安全地计算该值，如果输入字符串包含此类混合，则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb6208f023afd54f9f4acc30a7d493bf14dc6378" translate="yes" xml:space="preserve">
          <source>Some distributions may fail some tests, but you may want to install them anyway (as above, or via &lt;code&gt;force install&lt;/code&gt; command of &lt;code&gt;CPAN.pm&lt;/code&gt; shell-mode).</source>
          <target state="translated">某些发行版可能无法通过某些测试，但您可能仍要安装它们（如上所述，或通过 &lt;code&gt;CPAN.pm&lt;/code&gt; shell-mode的 &lt;code&gt;force install&lt;/code&gt; 命令）。</target>
        </trans-unit>
        <trans-unit id="673083d85e2bc8b38798cec75fcc0568d074003d" translate="yes" xml:space="preserve">
          <source>Some distributions may need to link to libraries or other third-party code and their build and installation sequences may be more complicated. Check any</source>
          <target state="translated">有些发行版可能需要链接到库或其他第三方代码,它们的构建和安装顺序可能比较复杂。请检查任何</target>
        </trans-unit>
        <trans-unit id="e14b5226c1b3194a20df87855367bd2962c1e595" translate="yes" xml:space="preserve">
          <source>Some documentation is not available as man pages, so if a cross-reference is not found by man, try it with &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;. Perldoc can also take you directly to documentation for functions (with the &lt;b&gt;-f&lt;/b&gt; switch). See &lt;code&gt;perldoc --help&lt;/code&gt; (or &lt;code&gt;perldoc perldoc&lt;/code&gt; or &lt;code&gt;man perldoc&lt;/code&gt; ) for other helpful options &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; has to offer.</source>
          <target state="translated">某些文档不能作为手册页使用，因此，如果man找不到交叉引用，请尝试使用&lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;。Perldoc也可以直接将您带到功能的文档（带有&lt;b&gt;-f&lt;/b&gt;开关）。见 &lt;code&gt;perldoc --help&lt;/code&gt; （或 &lt;code&gt;perldoc perldoc&lt;/code&gt; 或 &lt;code&gt;man perldoc&lt;/code&gt; 其他有用的选项）&lt;a href=&quot;perldoc&quot;&gt;的perldoc&lt;/a&gt;所提供的。</target>
        </trans-unit>
        <trans-unit id="24f338e775f9d8f25e87916116198ed5fdfd8fac" translate="yes" xml:space="preserve">
          <source>Some earlier versions of this module had docs with some confusing typos in the description of &lt;code&gt;skip(...)&lt;/code&gt; .</source>
          <target state="translated">该模块的某些早期版本的文档在 &lt;code&gt;skip(...)&lt;/code&gt; 的描述中带有一些令人困惑的错别字。</target>
        </trans-unit>
        <trans-unit id="2d5fff71fc694b06c17e66dad87b134506e2302b" translate="yes" xml:space="preserve">
          <source>Some essentially obsolete locales that aren't supersets of ASCII, mainly those in ISO 646 or other 7-bit locales, such as ASMO 449, can also have problems, depending on what portions of the ASCII character set get changed by the locale and are also used by the program. The warning message lists the determinable conflicting characters.</source>
          <target state="translated">一些不是ASCII的超集的基本过时的locale,主要是ISO 646或其他7位locale,如ASMO 449,也会有问题,这取决于ASCII字符集的哪些部分被locale改变了,并且也被程序使用。警告信息列出了可确定的冲突字符。</target>
        </trans-unit>
        <trans-unit id="e8b38cbb77fcb476bf8e2983ccfda5ed33f46a79" translate="yes" xml:space="preserve">
          <source>Some example section specifications follow.</source>
          <target state="translated">下面是一些示例部分的规格。</target>
        </trans-unit>
        <trans-unit id="6e29ae8ec1bfc30435ce56e5aeb3c20b82d6940f" translate="yes" xml:space="preserve">
          <source>Some examples of lists include:</source>
          <target state="translated">一些名单的例子包括:</target>
        </trans-unit>
        <trans-unit id="ae84b84bf5612613743104cf4d1d3f624e770f5d" translate="yes" xml:space="preserve">
          <source>Some examples of syntactically invalid attribute lists (with annotation):</source>
          <target state="translated">一些语法上无效的属性列表的例子(有注释)。</target>
        </trans-unit>
        <trans-unit id="9c0e82c6c1b276d5dbb162e62c1346aa697136e3" translate="yes" xml:space="preserve">
          <source>Some examples of syntactically valid attribute lists:</source>
          <target state="translated">一些语法上有效的属性列表的例子。</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">一些例子:</target>
        </trans-unit>
        <trans-unit id="75d23fa0c37e5a03812b09ef6b9c46fbb0fa3389" translate="yes" xml:space="preserve">
          <source>Some extensions provide filters on data entry/exit points, such as &lt;code&gt;DB_File::filter_store_key&lt;/code&gt; and family. Look out for such filters in the documentation of your extensions; they can make the transition to Unicode data much easier.</source>
          <target state="translated">一些扩展提供了有关数据输入/输出点的过滤器，例如 &lt;code&gt;DB_File::filter_store_key&lt;/code&gt; 和family。在扩展文档中查找此类过滤器；它们可以使向Unicode数据的转换更加容易。</target>
        </trans-unit>
        <trans-unit id="1ba2d8223f5d5832c6d62c8b546d87c608dd84fc" translate="yes" xml:space="preserve">
          <source>Some extensions, like DB_File and Compress::Zlib use/require prebuilt libraries for the perl extensions/modules to work. If these libraries are built using the default configuration, it might happen that you run into an error like &quot;invalid loader fixup&quot; during load phase. HP is aware of this problem. Search the HP-UX cxx-dev forums for discussions about the subject. The short answer is that &lt;b&gt;everything&lt;/b&gt; (all libraries, everything) must be compiled with &lt;code&gt;+z&lt;/code&gt; or &lt;code&gt;+Z&lt;/code&gt; to be PIC (position independent code). (For gcc, that would be &lt;code&gt;-fpic&lt;/code&gt; or &lt;code&gt;-fPIC&lt;/code&gt; ). In HP-UX 11.00 or newer the linker error message should tell the name of the offending object file.</source>
          <target state="translated">一些扩展，例如DB_File和Compress :: Zlib使用/要求预建的库来使perl扩展/模块正常工作。如果这些库是使用默认配置构建的，则可能会在加载阶段遇到诸如&amp;ldquo;无效的加载器修复&amp;rdquo;之类的错误。 HP已意识到此问题。在HP-UX cxx-dev论坛中搜索有关该主题的讨论。简短的答案是，&lt;b&gt;所有内容&lt;/b&gt;（所有库，所有内容）都必须使用 &lt;code&gt;+z&lt;/code&gt; 或 &lt;code&gt;+Z&lt;/code&gt; 编译为PIC（与位置无关的代码）。 （对于gcc，这将是 &lt;code&gt;-fpic&lt;/code&gt; 或 &lt;code&gt;-fPIC&lt;/code&gt; ）。在HP-UX 11.00或更高版本中，链接器错误消息应告诉有问题的目标文件名。</target>
        </trans-unit>
        <trans-unit id="4b7fd53f722062eada03c99c5c0131726fe7cb4c" translate="yes" xml:space="preserve">
          <source>Some features of Storable can lead to security vulnerabilities if you accept Storable documents from untrusted sources. Most obviously, the optional (off by default) CODE reference serialization feature allows transfer of code to the deserializing process. Furthermore, any serialized object will cause Storable to helpfully load the module corresponding to the class of the object in the deserializing module. For manipulated module names, this can load almost arbitrary code. Finally, the deserialized object's destructors will be invoked when the objects get destroyed in the deserializing process. Maliciously crafted Storable documents may put such objects in the value of a hash key that is overridden by another key/value pair in the same hash, thus causing immediate destructor execution.</source>
          <target state="translated">如果您接受来自不受信任来源的 Storable 文档,Storable 的一些功能可能会导致安全漏洞。最明显的是,可选的(默认情况下是关闭的)CODE引用序列化功能允许将代码转移到反序列化过程中。此外,任何序列化的对象都会导致Storable在反序列化模块中帮助加载与该对象的类相对应的模块。对于被操纵的模块名,这可以加载几乎任意的代码。最后,当对象在反序列化过程中被销毁时,将调用反序列化对象的析构器。恶意制作的Storable文档可能会将这种对象放在一个哈希键的值中,而这个哈希键的值被同一哈希中的另一个键/值对所覆盖,从而导致反序列化对象的解构器立即执行。</target>
        </trans-unit>
        <trans-unit id="410f15ec6c766d4ad924aef6bed79d8486d14679" translate="yes" xml:space="preserve">
          <source>Some folks are surprised that &lt;code&gt;make distclean&lt;/code&gt; does not delete everything not listed in their MANIFEST (thus making a clean distribution) but only tells them what they need to delete. This is done because it is considered too dangerous. While developing your module you might write a new file, not add it to the MANIFEST, then run a &lt;code&gt;distclean&lt;/code&gt; and be sad because your new work was deleted.</source>
          <target state="translated">有些人感到惊讶， &lt;code&gt;make distclean&lt;/code&gt; 不会删除清单中未列出的所有内容（从而进行干净的发行），而只是告诉他们需要删除什么。这样做是因为它被认为太危险了。在开发模块时，您可能会编写一个新文件，而不是将其添加到MANIFEST中，然后运行 &lt;code&gt;distclean&lt;/code&gt; 并感到遗憾，因为您的新工作已被删除。</target>
        </trans-unit>
        <trans-unit id="278e93ddc6a44b33edbb2aa1b1e3252bdefc68ee" translate="yes" xml:space="preserve">
          <source>Some folks would prefer full alphanumeric prototypes. Alphanumerics have been intentionally left out of prototypes for the express purpose of someday in the future adding named, formal parameters. The current mechanism's main goal is to let module writers provide better diagnostics for module users. Larry feels the notation quite understandable to Perl programmers, and that it will not intrude greatly upon the meat of the module, nor make it harder to read. The line noise is visually encapsulated into a small pill that's easy to swallow.</source>
          <target state="translated">有些人更喜欢完整的字母数字原型。原型中故意不使用字母数字,目的是为了将来有一天能够添加命名的正式参数。目前机制的主要目的是让模块编写者为模块用户提供更好的诊断方法。Larry觉得这种符号对于Perl程序员来说相当容易理解,它不会极大地侵入模块的肉体,也不会让模块更难读。行噪声在视觉上被封装成一个容易吞咽的小药丸。</target>
        </trans-unit>
        <trans-unit id="97b6babea6d7a1882a7f9edff1a7d1c57e6e6a28" translate="yes" xml:space="preserve">
          <source>Some format names that formatters currently are known to accept include &quot;roff&quot;, &quot;man&quot;, &quot;latex&quot;, &quot;tex&quot;, &quot;text&quot;, and &quot;html&quot;. (Some formatters will treat some of these as synonyms.)</source>
          <target state="translated">目前已知格式化程序接受的一些格式名称包括 &quot;roff&quot;、&quot;man&quot;、&quot;latex&quot;、&quot;tex&quot;、&quot;text &quot;和 &quot;html&quot;。(有些格式化程序会把其中一些当作同义词。)</target>
        </trans-unit>
        <trans-unit id="bae9c58f7596d57c13463eeb374970b17faa09ff" translate="yes" xml:space="preserve">
          <source>Some frequently seen examples:</source>
          <target state="translated">一些经常看到的例子。</target>
        </trans-unit>
        <trans-unit id="5f63fbe742ecc7df05393f6e705a1b34f98dd874" translate="yes" xml:space="preserve">
          <source>Some functions are provided to simplify customization.</source>
          <target state="translated">提供了一些功能,以简化定制。</target>
        </trans-unit>
        <trans-unit id="37fca23bc4f77bc45e835fb641ab69a99facbd7e" translate="yes" xml:space="preserve">
          <source>Some functions are slower when working on UTF-8 encoded strings than on byte encoded strings. All functions that need to hop over characters such as &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt;, or matching regular expressions can work &lt;b&gt;much&lt;/b&gt; faster when the underlying data are byte-encoded.</source>
          <target state="translated">使用UTF-8编码的字符串时，某些功能比使用字节编码的字符串时要慢。需要跳跃过的字符，如所有的功能 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; ，或匹配正则表达式可以工作&lt;b&gt;多&lt;/b&gt;当底层数据是字节编码的更快。</target>
        </trans-unit>
        <trans-unit id="83116620b210d6b01d6ea586806a731e05a2beb8" translate="yes" xml:space="preserve">
          <source>Some functions available based on the version of VMS. (VMS)</source>
          <target state="translated">根据VMS的版本提供一些功能。(VMS)</target>
        </trans-unit>
        <trans-unit id="851bf3122418d781546b0c8256e17049b7be4c91" translate="yes" xml:space="preserve">
          <source>Some languages work directly with the memory addresses of values, but this can be like playing with fire. Perl provides a set of asbestos gloves for handling all memory management. The closest to an address operator in Perl is the backslash operator, but it gives you a &lt;b&gt;hard reference&lt;/b&gt;, which is much safer than a memory address.</source>
          <target state="translated">有些语言直接使用值的内存地址，但这就像玩火一样。Perl提供了一套用于处理所有内存管理的石棉手套。在Perl中最接近地址运算符的是反斜杠运算符，但它为您提供了一个&lt;b&gt;硬引用&lt;/b&gt;，它比内存地址安全得多。</target>
        </trans-unit>
        <trans-unit id="f2704cdd835e2ffc2151c5b3e73d345acc2100f0" translate="yes" xml:space="preserve">
          <source>Some locales have special sorting rules.</source>
          <target state="translated">有些地方有特殊的排序规则。</target>
        </trans-unit>
        <trans-unit id="4cbad0bcc8b3efd678863ec66e302790409bbb20" translate="yes" xml:space="preserve">
          <source>Some methods take slightly different arguments to those defined in &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; in attempt to make the interface more flexible. These are</source>
          <target state="translated">某些方法采用与&lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt;中定义的参数略有不同的参数，以使接口更加灵活。这些是</target>
        </trans-unit>
        <trans-unit id="4d5ca2cd44839d0147fa7ed895887914f1a8f96d" translate="yes" xml:space="preserve">
          <source>Some modules have an event loop, waiting for user-input. It is highly unlikely that two such modules would work adequately together in a single Perl application.</source>
          <target state="translated">有些模块有一个事件循环,等待用户输入。在一个Perl应用程序中,两个这样的模块不太可能充分地一起工作。</target>
        </trans-unit>
        <trans-unit id="99aeed54cc1e7c695f296661c28f743d9f582de7" translate="yes" xml:space="preserve">
          <source>Some modules have validation for particular types of input, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business::CreditCard&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email::Valid&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Validate::IP&quot;&gt;Data::Validate::IP&lt;/a&gt;.</source>
          <target state="translated">一些模块对特定类型的输入进行验证，例如&lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business :: ISBN&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business :: CreditCard&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email :: Valid&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Data::Validate::IP&quot;&gt;Data :: Validate :: IP&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8896acdebb142a8bf319a25d0ebc467b0372d0f5" translate="yes" xml:space="preserve">
          <source>Some modules live both in the &lt;b&gt;Standard Library&lt;/b&gt; and on &lt;b&gt;CPAN&lt;/b&gt;. These modules might be developed on two tracks as people modify either version. The trend currently is to untangle these situations.</source>
          <target state="translated">一些模块同时存在于&lt;b&gt;标准库&lt;/b&gt;和&lt;b&gt;CPAN中&lt;/b&gt;。当人们修改任一版本时，可能会在两个轨道上开发这些模块。当前的趋势是解开这些情况。</target>
        </trans-unit>
        <trans-unit id="2536c5611f03605401087c295c560b8c0a55966f" translate="yes" xml:space="preserve">
          <source>Some modules might have special reporting requirements, such as a Github or Google Code tracking system, so you should check the module documentation too.</source>
          <target state="translated">有些模块可能有特殊的报告要求,比如Github或Google代码跟踪系统,所以你也应该检查模块的文档。</target>
        </trans-unit>
        <trans-unit id="9d3dcbb265761ea263567338345aa34c90c2eea2" translate="yes" xml:space="preserve">
          <source>Some modules, mainly extensions, provide their own AUTOLOAD subroutines. They typically need to check for some special cases (such as constants) and then fallback to &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD for the rest.</source>
          <target state="translated">一些模块（主要是扩展模块）提供了自己的AUTOLOAD子例程。他们通常需要检查某些特殊情况（例如常量），然后其余时间回&lt;b&gt;退到AutoLoader&lt;/b&gt;的AUTOLOAD。</target>
        </trans-unit>
        <trans-unit id="2c12ec8767768e2405ac12fa9dd3e5b3e02eaa4d" translate="yes" xml:space="preserve">
          <source>Some names known to &lt;code&gt;\N{...}&lt;/code&gt; refer to a sequence of multiple characters, instead of the usual single character. When one of these is included in the class, the entire sequence is matched. For example,</source>
          <target state="translated">&lt;code&gt;\N{...}&lt;/code&gt; 已知的某些名称是指多个字符的序列，而不是通常的单个字符。当其中之一包含在类中时，整个序列将匹配。例如，</target>
        </trans-unit>
        <trans-unit id="86874fce71a4882d328a8877cd2a4fc52a6a4fe2" translate="yes" xml:space="preserve">
          <source>Some networking library functions like gethostbyname() are known to have their own implementations of timeouts which may conflict with your timeouts. If you have problems with such functions, try using the POSIX sigaction() function, which bypasses Perl safe signals. Be warned that this does subject you to possible memory corruption, as described above.</source>
          <target state="translated">一些网络库函数,如gethostbyname(),有自己的超时实现,可能会与你的超时冲突。如果你在使用这些函数时遇到问题,可以尝试使用POSIX sigaction()函数,它可以绕过Perl的安全信号。请注意,这可能会导致内存损坏,如上所述。</target>
        </trans-unit>
        <trans-unit id="0ce6014b84ac6fe075f649ff6034ad219b7b909a" translate="yes" xml:space="preserve">
          <source>Some non-Perl implementations of the Age property may change its meaning to be the same as the Perl &lt;code&gt;Present_In&lt;/code&gt; property; just be aware of that.</source>
          <target state="translated">Age属性的某些非Perl实现可能会将其含义更改为与Perl &lt;code&gt;Present_In&lt;/code&gt; 属性相同；请注意这一点。</target>
        </trans-unit>
        <trans-unit id="020d12e0872ef168546404b52284bd6940ecd187" translate="yes" xml:space="preserve">
          <source>Some non-numeric HTML entity name, such as &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; , meaning the same thing as &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; in HTML -- i.e., a lowercase e with an acute (/-shaped) accent.</source>
          <target state="translated">一些非数字HTML实体名称，例如 &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; ，与 &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; 含义相同。在HTML中-即带有尖锐（/形）重音的小写字母e。</target>
        </trans-unit>
        <trans-unit id="742d524f056fc75f1015c7da11070249cb40a21b" translate="yes" xml:space="preserve">
          <source>Some notes about ftp archives: Please use a long descriptive file name that includes the version number. Most incoming directories will not be readable/listable, i.e., you won't be able to see your file after uploading it. Remember to send your email notification message as soon as possible after uploading else your file may get deleted automatically. Allow time for the file to be processed and/or check the file has been processed before announcing its location.</source>
          <target state="translated">关于ftp档案的一些说明。请使用一个长的描述性文件名,包括版本号。大多数传入的目录将无法读取/列表,也就是说,上传后你将无法看到你的文件。记得上传后尽快发送邮件通知信息,否则你的文件可能会被自动删除。在公布文件的位置之前,请给文件处理的时间和/或检查文件是否已经处理完毕。</target>
        </trans-unit>
        <trans-unit id="cc5039f425d422cec80636f2fe25c7aa8c335808" translate="yes" xml:space="preserve">
          <source>Some of the books we've listed appear almost ancient in internet scale, but we've included those books because they still describe the current way of doing things. Not everything in Perl changes every day. Many of the beginner-level books, too, go over basic features and techniques that are still valid today. In general though, we try to limit this list to books published in the past five years.</source>
          <target state="translated">我们列出的一些书籍在互联网规模上看起来几乎是古老的,但我们将这些书籍包括在内,因为它们仍然描述了当前的做事方式。并非Perl中的所有内容每天都在变化。许多初级水平的书籍,也会介绍一些今天仍然有效的基本特性和技术。不过一般来说,我们会尽量将这个列表限制在过去五年内出版的书籍。</target>
        </trans-unit>
        <trans-unit id="ec6365cb89577ea447484ee46de59521b7dffa94" translate="yes" xml:space="preserve">
          <source>Some of the built-in functions do not act exactly as documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, and a few are not implemented at all. To avoid surprises, particularly if you have had prior exposure to Perl in other operating environments or if you intend to write code that will be portable to other environments, see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for a reasonably definitive list of these differences.</source>
          <target state="translated">一些内置函数的功能与&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;所记录的功能不完全相同，有一些根本没有实现。为避免意外，特别是如果您以前在其他操作环境中接触过Perl，或者打算编写可移植到其他环境中的代码时，请参见&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;，以获取有关这些差异的合理确定列表。</target>
        </trans-unit>
        <trans-unit id="0c8239353496c2009cfe543c3292467ce35311ef" translate="yes" xml:space="preserve">
          <source>Some of the configuration files in /etc used by the networking APIs are either missing or have the wrong names. In particular, make sure that there's either an /etc/resolv.conf or an /etc/hosts, so that gethostbyname() works, and make sure that the file /etc/proto has been renamed to /etc/protocol (NOT /etc/protocols, as used by other Unix systems). You may have to look for things like HOSTNAME and DOMAINORIGIN in the &quot;//'SYS1.TCPPARMS(TCPDATA)'&quot; PDS member in order to properly set up your /etc networking files.</source>
          <target state="translated">网络API使用的/etc中的一些配置文件要么缺失,要么名称错误。特别是,确保有一个/etc/resolv.conf或/etc/hosts,这样getshostbyname()就可以工作了,并确保文件/etc/proto已经被重命名为/etc/protocol(而不是其他Unix系统使用的/etc/protocols)。你可能需要在&quot;//'SYS1.TCPPARMS(TCPDATA)'&quot;中查找诸如HOSTNAME和DOMAINORIGIN之类的东西。PDS成员,以便正确设置你的/etc网络文件。</target>
        </trans-unit>
        <trans-unit id="c4c6dd767013c78841ab05e0e012ebcc93f26f14" translate="yes" xml:space="preserve">
          <source>Some of the examples later in &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt; use the &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; module from CPAN. The reason you might choose &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; over the perl built-in functions is that it works with numbers of ANY size, that it is optimized for speed on some operations, and for at least some programmers the notation might be familiar.</source>
          <target state="translated">&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;稍后的一些示例使用CPAN 的&lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt;模块。您可能会选择&lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Per：&lt;/a&gt;内置函数中的Bit :: Vector的原因是，它可以处理任何大小的数字，并且针对某些操作的速度进行了优化，并且至少对于某些程序员而言，这种表示法可能很熟悉。</target>
        </trans-unit>
        <trans-unit id="b1b52c56fd19edbbc0804a6b9841658fb64d4030" translate="yes" xml:space="preserve">
          <source>Some of the functionality of the debugging code can be achieved using XS modules.</source>
          <target state="translated">调试代码的部分功能可以通过XS模块来实现。</target>
        </trans-unit>
        <trans-unit id="129d9d1e78c142ea547ff6b028cde8ebd0aadf7f" translate="yes" xml:space="preserve">
          <source>Some of the functions are called with a</source>
          <target state="translated">有些函数的调用是以</target>
        </trans-unit>
        <trans-unit id="43704b45451eba3bea984abb31f94004f6ecfd41" translate="yes" xml:space="preserve">
          <source>Some of the highlights of &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;perlref&quot;&gt;perlref的&lt;/a&gt;一些亮点：</target>
        </trans-unit>
        <trans-unit id="c35b9e6be7b3bf5bc03040d536fb7da8f901aae2" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from the &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; class. See &lt;a href=&quot;ftp/dataconn&quot;&gt;Net::FTP::dataconn&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;Net::FTP&lt;/code&gt; 定义的某些方法返回一个对象，该对象将从 &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; 类派生。有关更多详细信息，请参见&lt;a href=&quot;ftp/dataconn&quot;&gt;Net :: FTP :: dataconn&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="085f62b2598cb482a6875006e876358d6d804f21" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from this class. The dataconn class itself is derived from the &lt;code&gt;IO::Socket::INET&lt;/code&gt; class, so any normal IO operations can be performed. However the following methods are defined in the dataconn class and IO should be performed using these.</source>
          <target state="translated">&lt;code&gt;Net::FTP&lt;/code&gt; 定义的一些方法返回一个将从该类派生的对象。dataconn类本身是从 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 类派生的，因此可以执行任何常规的IO操作。但是，以下方法在dataconn类中定义，并且应使用这些方法执行IO。</target>
        </trans-unit>
        <trans-unit id="312d5ef79ec3abd87646ed6a59f9c68ae862462d" translate="yes" xml:space="preserve">
          <source>Some of the most common mistakes:</source>
          <target state="translated">一些最常见的错误。</target>
        </trans-unit>
        <trans-unit id="5796d9bed54a4c270451442098ed19f9f0088003" translate="yes" xml:space="preserve">
          <source>Some of the most common values are &lt;code&gt;O_RDONLY&lt;/code&gt; for opening the file in read-only mode, &lt;code&gt;O_WRONLY&lt;/code&gt; for opening the file in write-only mode, and &lt;code&gt;O_RDWR&lt;/code&gt; for opening the file in read-write mode.</source>
          <target state="translated">一些最常见的值是 &lt;code&gt;O_RDONLY&lt;/code&gt; (用于以只读模式打开文件）， &lt;code&gt;O_WRONLY&lt;/code&gt; (用于以只读模式打开文件）和 &lt;code&gt;O_RDWR&lt;/code&gt; (用于以读写模式打开文件）。</target>
        </trans-unit>
        <trans-unit id="d5f4367d2cd66fe5bca2400a4df459be12cf9924" translate="yes" xml:space="preserve">
          <source>Some of the parser default template files in /samples are needed in /etc. In particular be sure that you at least copy /samples/yyparse.c to /etc before running Perl's Configure. This step ensures successful extraction of EBCDIC versions of parser files such as perly.c and perly.h. This has to be done before running Configure the first time. If you failed to do so then the easiest way to re-Configure Perl is to delete your misconfigured build root and re-extract the source from the tar ball. Then you must ensure that /etc/yyparse.c is properly in place before attempting to re-run Configure.</source>
          <target state="translated">在 /samples 中的一些解析器默认模板文件在 /etc 中是需要的。特别是在运行Perl的Configure之前,至少要将/samples/yyparse.c复制到/etc中。这一步可以确保成功提取EBCDIC版本的解析器文件,如perly.c和perly.h,这一点必须在第一次运行Configure之前完成。如果你没有做到这一点,那么重新配置Perl的最简单的方法就是删除你错误配置的构建根目录,并从tar球中重新解压源代码。然后你必须确保/etc/yyparse.c正确到位,然后再尝试重新运行Configure。</target>
        </trans-unit>
        <trans-unit id="83c0811a95d044951ce0ba50edb2e9cd1f45c8cb" translate="yes" xml:space="preserve">
          <source>Some of the reported info, such as hex addresses, is not particularly valuable. Other information would be more useful for the typical programmer, such as line-numbers, pad-slot reuses, etc.. Given this, -newlex is not a particularly good flag-name.</source>
          <target state="translated">一些报告的信息,如十六进制地址,不是特别有价值。其他的信息对于典型的程序员来说会更有用,比如行号、焊盘槽重用等等。鉴于此,-newlex并不是一个特别好的标志名。</target>
        </trans-unit>
        <trans-unit id="2cdf99bdb0c6c762dab8d358da246b612330e8fa" translate="yes" xml:space="preserve">
          <source>Some of these are also deprecated. You can exclude these from your compiled Perl by adding this option to Configure: &lt;code&gt;-Accflags='-DNO_MATHOMS'&lt;/code&gt;</source>
          <target state="translated">其中一些也不推荐使用。您可以通过将以下选项添加到Configure中来将它们从已编译的Perl中排除： &lt;code&gt;-Accflags='-DNO_MATHOMS'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d94da1d47f6dfef189dc9a92fab735da2e9c93d7" translate="yes" xml:space="preserve">
          <source>Some of these books are available as free downloads.</source>
          <target state="translated">其中一些书籍可以免费下载。</target>
        </trans-unit>
        <trans-unit id="55b425b2a6fe515905b997d3820e2d955eabc2cf" translate="yes" xml:space="preserve">
          <source>Some of these functions also combine dynaloading semantic with the error-propagation semantic discussed above.</source>
          <target state="translated">其中一些函数还将dynaloading语义与上面讨论的错误传播语义相结合。</target>
        </trans-unit>
        <trans-unit id="7a3b090758880601b5c97fb9b694e1e73a3369bc" translate="yes" xml:space="preserve">
          <source>Some of these methods might be of interest to general users, as well as of interest to formatter-writers.</source>
          <target state="translated">这些方法中的一些方法可能会引起一般用户的兴趣,也会引起formatter编写者的兴趣。</target>
        </trans-unit>
        <trans-unit id="80eb2a0ac01474685656b9eca0e98318c5698b3f" translate="yes" xml:space="preserve">
          <source>Some of these pseudo-modules import semantics into the current block scope (like &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;integer&lt;/code&gt; , unlike ordinary modules, which import symbols into the current package (which are effective through the end of the file).</source>
          <target state="translated">这些伪模块中的一些将语义导入到当前块范围中（例如 &lt;code&gt;strict&lt;/code&gt; 或 &lt;code&gt;integer&lt;/code&gt; ，与普通模块不同，普通模块将符号导入到当前包中（在文件末尾有效）。</target>
        </trans-unit>
        <trans-unit id="8fc82daea8e525be9f1657205fd39cc94c0720ec" translate="yes" xml:space="preserve">
          <source>Some of these specific cases are shown as examples in other answers in this section of the perlfaq.</source>
          <target state="translated">在本节perlfaq的其他答案中,其中一些具体的情况被作为例子展示出来。</target>
        </trans-unit>
        <trans-unit id="7ac7dfacde52b03cada88bb1c11d6be2449d545b" translate="yes" xml:space="preserve">
          <source>Some of this may be confusing. Here's a handy reference to the ASCII CR and LF characters. You can print it out and stick it in your wallet.</source>
          <target state="translated">其中有些可能会让人感到困惑。这里有一个方便的ASCII CR和LF字符的参考。你可以把它打印出来,然后贴在你的钱包里。</target>
        </trans-unit>
        <trans-unit id="9436ec9fafb3dbaf8b6e8266e0c7a558118556b8" translate="yes" xml:space="preserve">
          <source>Some older Pod translators require paragraphs (including command paragraphs like &quot;=head2 Functions&quot;) to be separated by</source>
          <target state="translated">一些较老的Pod翻译要求段落(包括命令段落,如&quot;=head2 Functions&quot;)用&quot;=head2 &quot;分隔。</target>
        </trans-unit>
        <trans-unit id="530312ef21d84b684c5534cd434fe4d79ac602e0" translate="yes" xml:space="preserve">
          <source>Some older versions of Berkeley DB had problems with fixed length records using the RECNO file format. This problem has been fixed since version 1.85 of Berkeley DB.</source>
          <target state="translated">一些旧版本的Berkeley DB在使用RECNO文件格式的固定长度记录方面存在问题。这个问题从Berkeley DB的1.85版本开始已经得到了解决。</target>
        </trans-unit>
        <trans-unit id="4c2cd6192ba71ba66f15fbdbb416f6e8ad76580e" translate="yes" xml:space="preserve">
          <source>Some operating systems don't ship the CORE directory with their base perl install. To solve the problem, you likely need to install a perl development package such as perl-devel (CentOS, Fedora and other Redhat systems) or perl (Ubuntu and other Debian systems).</source>
          <target state="translated">有些操作系统在安装perl的时候,并没有将CORE目录与基本的perl安装在一起。为了解决这个问题,你可能需要安装一个perl开发包,比如perl-devel(CentOS、Fedora和其他Redhat系统)或者perl(Ubuntu和其他Debian系统)。</target>
        </trans-unit>
        <trans-unit id="a0bcdb116909bbaf782dcc8531648c8104b0144b" translate="yes" xml:space="preserve">
          <source>Some operating systems have bugs in the kernel that make setuid scripts inherently insecure. Perl gives you a number of options (described in &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) to work around such systems.</source>
          <target state="translated">某些操作系统的内核中存在错误，这些错误使setuid脚本本质上不安全。Perl为您提供了许多解决此类系统的选项（在&lt;a href=&quot;perlsec&quot;&gt;perlsec中&lt;/a&gt;进行了描述）。</target>
        </trans-unit>
        <trans-unit id="2250e1a4559063fcac9cec7cc104374f3f26f7ef" translate="yes" xml:space="preserve">
          <source>Some operating systems may perform &lt;code&gt;IO::File::new()&lt;/code&gt; or &lt;code&gt;IO::File::open()&lt;/code&gt; on a directory without errors. This behavior is not portable and not suggested for use. Using &lt;code&gt;&lt;a href=&quot;../functions/opendir&quot;&gt;opendir()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;IO::Dir&lt;/code&gt; are suggested instead.</source>
          <target state="translated">某些操作系统可以在目录上执行 &lt;code&gt;IO::File::new()&lt;/code&gt; 或 &lt;code&gt;IO::File::open()&lt;/code&gt; 而不会出错。此行为不是便携式的，不建议使用。使用 &lt;code&gt;&lt;a href=&quot;../functions/opendir&quot;&gt;opendir()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;IO::Dir&lt;/code&gt; 的建议来代替。</target>
        </trans-unit>
        <trans-unit id="39015af4e836c35f8e25b30fad81d0e5afdfce43" translate="yes" xml:space="preserve">
          <source>Some operations may be slower for small numbers, but are significantly faster for big numbers. Other operations are now constant (O(1), like &lt;code&gt;bneg()&lt;/code&gt; , &lt;code&gt;babs()&lt;/code&gt; etc), instead of O(N) and thus nearly always take much less time. These optimizations were done on purpose.</source>
          <target state="translated">对于较小的数字，某些操作可能会比较慢，但是对于较大的数字，某些操作会明显更快。现在其他操作都是常量（O（1），例如 &lt;code&gt;bneg()&lt;/code&gt; ， &lt;code&gt;babs()&lt;/code&gt; 等），而不是O（N），因此几乎总是花费更少的时间。这些优化是有目的的。</target>
        </trans-unit>
        <trans-unit id="03ecacb543bf1cb170543843116f3f4c7e881ad8" translate="yes" xml:space="preserve">
          <source>Some other (not completely debugged) situations when FP flags change include some video drivers (?), and some operations related to creation of the windows. People who code &lt;b&gt;OpenGL&lt;/b&gt; may have more experience on this.</source>
          <target state="translated">FP标志更改时，其他一些情况（尚未完全调试）包括一些视频驱动程序（？），以及与创建窗口有关的某些操作。编写&lt;b&gt;OpenGL的人&lt;/b&gt;可能对此有更多的经验。</target>
        </trans-unit>
        <trans-unit id="377fbf88a15d635b8d6d486abdf4ac17224b10a7" translate="yes" xml:space="preserve">
          <source>Some other IO modules don't belong to the perl core but can be loaded as well if they have been installed from CPAN. You can discover which ones exist by searching for &quot;^IO::&quot; on &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt;.</source>
          <target state="translated">其他一些IO模块不属于perl内核，但如果已从CPAN安装，则也可以加载。您可以通过在&lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt;上搜索&amp;ldquo; ^ IO ::&amp;rdquo;来发现存在的那些。</target>
        </trans-unit>
        <trans-unit id="7424cd4ab88fb33b2270b2db7bbe8e04cad5739e" translate="yes" xml:space="preserve">
          <source>Some output formats that do allow rendering &quot;L&amp;lt;...&amp;gt;&quot; codes as hypertext, might not allow the link-text to be formatted; in that case, formatters will have to just ignore that formatting.</source>
          <target state="translated">某些确实允许将&amp;ldquo; L &amp;lt;...&amp;gt;&amp;rdquo;代码呈现为超文本的输出格式，可能不允许对链接文本进行格式化。在这种情况下，格式化者将不得不忽略该格式化。</target>
        </trans-unit>
        <trans-unit id="e1a79a974eeb026992ad7b1bb5fab50968d6932c" translate="yes" xml:space="preserve">
          <source>Some passes discussed below are performed concurrently, but because their results are the same, we consider them individually. For different quoting constructs, Perl performs different numbers of passes, from one to four, but these passes are always performed in the same order.</source>
          <target state="translated">下面讨论的一些传递是同时进行的,但因为它们的结果是一样的,所以我们单独考虑它们。对于不同的引号结构,Perl 会执行不同数量的传递,从一个到四个,但这些传递总是以相同的顺序进行。</target>
        </trans-unit>
        <trans-unit id="7ae8fed66b51985370778e2e29c81e03a37d1f13" translate="yes" xml:space="preserve">
          <source>Some people get too used to writing things like:</source>
          <target state="translated">有些人太习惯于写这样的东西。</target>
        </trans-unit>
        <trans-unit id="970ff42e05d0088fd549cac2a995425a1e1eba68" translate="yes" xml:space="preserve">
          <source>Some people have reported encountering &quot;Out of memory!&quot; errors while trying to build Perl using GNU make binaries. If you encounter such trouble then try to download the source code kit and build GNU make from source to eliminate any such trouble. You might also find GNU make (as well as Perl and Apache) in the red-piece/book &quot;Open Source Software for OS/390 UNIX&quot;, SG24-5944-00 from IBM.</source>
          <target state="translated">有些人报告说,在使用 GNU make 二进制文件构建 Perl 时遇到了 &quot;Out of memory!&quot;错误。如果您遇到这样的问题,请尝试下载源代码包,并从源代码中构建GNU make,以消除此类问题。你也可以在IBM的红片/书 &quot;OS/390 UNIX的开源软件 &quot;SG24-5944-00中找到GNU make(以及Perl和Apache)。</target>
        </trans-unit>
        <trans-unit id="98c7c01703d39bcc6345fdf8d617292db8f23d37" translate="yes" xml:space="preserve">
          <source>Some people may be inclined to include an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in the above XSUB, rather than letting control fall through to the end. In those situations &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; should be used, instead. This will ensure that the XSUB stack is properly adjusted. Consult &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for other &lt;code&gt;XSRETURN&lt;/code&gt; macros.</source>
          <target state="translated">有些人可能倾向于在上述XSUB中包含一个显式的 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; ，而不是让控制权落到最后。在这些情况下，应改用 &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; 。这将确保正确调整XSUB堆栈。有关其他 &lt;code&gt;XSRETURN&lt;/code&gt; 宏，请咨询&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b055a6a001cadf9ec7b3e638f2bc15cb8ed85e4" translate="yes" xml:space="preserve">
          <source>Some people may wish to outlaw barewords entirely. If you say</source>
          <target state="translated">有些人可能希望完全取缔裸辞。如果你说</target>
        </trans-unit>
        <trans-unit id="bae38a7d38c5d89eb67db6e4b702e604142997e5" translate="yes" xml:space="preserve">
          <source>Some people mistakenly regard this as a security problem. If your program does insecure things, and relies on people not knowing how to exploit those insecurities, it is not secure. It is often possible for someone to determine the insecure things and exploit them without viewing the source. Security through obscurity, the name for hiding your bugs instead of fixing them, is little security indeed.</source>
          <target state="translated">有些人误认为这是一个安全问题。如果你的程序做了不安全的事情,并且依靠人们不知道如何利用这些不安全因素,那么它就是不安全的。往往有人可以在不查看源码的情况下确定不安全的东西并加以利用。通过隐蔽来保证安全,美其名曰隐藏你的bug,而不是修复它们,这确实是小安全。</target>
        </trans-unit>
        <trans-unit id="df10001a5e994bd1a3232bcb5d3f173424f0cd78" translate="yes" xml:space="preserve">
          <source>Some people need this and some people avoid it. For Perl, it&amp;rsquo;s an old way to say &lt;b&gt;I/O layer&lt;/b&gt;.</source>
          <target state="translated">有些人需要这个，有些人避免它。对于Perl，这是说&lt;b&gt;I / O层&lt;/b&gt;的一种古老方法。</target>
        </trans-unit>
        <trans-unit id="37ecbcdb1f8127ee6539d97d23e8c04d2e848681" translate="yes" xml:space="preserve">
          <source>Some people regard this as a security problem. If your program does insecure things and relies on people not knowing how to exploit those insecurities, it is not secure. It is often possible for someone to determine the insecure things and exploit them without viewing the source. Security through obscurity, the name for hiding your bugs instead of fixing them, is little security indeed.</source>
          <target state="translated">有些人认为这是一个安全问题。如果你的程序做了不安全的事情,并且依靠人们不知道如何利用这些不安全因素,那么它就是不安全的。往往有人可以在不查看源码的情况下确定不安全的东西并加以利用。通过隐蔽来保证安全,美其名曰隐藏你的bug而不是修复它们,这确实是小安全。</target>
        </trans-unit>
        <trans-unit id="646207c2365abd1daf6b5c56b0451ba2ee5e82de" translate="yes" xml:space="preserve">
          <source>Some platforms (Win32, AIX, VMS, OS/2, to name a few) require any function that is part of the public API (the shared Perl library) to be explicitly marked as exported. See the discussion about</source>
          <target state="translated">一些平台(Win32、AIX、VMS、OS/2等)要求任何属于公共API(共享的Perl库)的函数都要明确标记为导出。参见关于</target>
        </trans-unit>
        <trans-unit id="29e0751f43cf70fa1b809101e7e4735cf3d63955" translate="yes" xml:space="preserve">
          <source>Some platforms can't delete or rename files held open by the system, this limitation may also apply to changing filesystem metainformation like file permissions or owners. Remember to &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; files when you are done with them. Don't &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;&lt;/code&gt; an open file. Don't &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; a file already tied or opened; &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; it first.</source>
          <target state="translated">某些平台无法删除或重命名系统打开的文件，此限制也可能适用于更改文件系统元信息，例如文件权限或所有者。完成操作后，请记住 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 文件。不要 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;&lt;/code&gt; 打开的文件。不要 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 已经打结或打开的文件； &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 它。</target>
        </trans-unit>
        <trans-unit id="da26b78199e00ef73fdfb4bbe53a1032367ab8a7" translate="yes" xml:space="preserve">
          <source>Some platforms have a minimum thread stack size. Trying to set the stack size below this value will result in a warning, and the minimum stack size will be used.</source>
          <target state="translated">有些平台有最小线程堆栈大小。试图将堆栈大小设置为低于这个值会导致一个警告,并且会使用最小堆栈大小。</target>
        </trans-unit>
        <trans-unit id="bcf43713051466cf97d586bae0917d51d61ca30f" translate="yes" xml:space="preserve">
          <source>Some platforms have a minimum thread stack size. Trying to set the stack size below this value will result in the above warning, and the stack size will be set to the minimum.</source>
          <target state="translated">有些平台有一个最小线程堆栈大小。试图将堆栈大小设置为低于这个值,将导致上述警告,并且堆栈大小将被设置为最小值。</target>
        </trans-unit>
        <trans-unit id="a11c8787b6044982e680d4ae9bfff407819b6d1c" translate="yes" xml:space="preserve">
          <source>Some platforms have other categories, dealing with such things as measurement units and paper sizes. None of these are used directly by Perl, but outside operations that Perl interacts with may use these. See &lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;Not within the scope of use locale&lt;/a&gt; below.</source>
          <target state="translated">某些平台还有其他类别，涉及度量单位和纸张尺寸。这些都没有被Perl直接使用，但是与Perl交互的外部操作可能会使用它们。请参阅下面的&lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;不在使用区域设置范围内&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27d67098e269de48eafdad3480b3920c43ba2cb7" translate="yes" xml:space="preserve">
          <source>Some points to note:</source>
          <target state="translated">需要注意的几点:</target>
        </trans-unit>
        <trans-unit id="4d3653fc867e65c669e5c29b359dbebb9253c5c0" translate="yes" xml:space="preserve">
          <source>Some possible reasons: your inheritance is getting confused, you've misspelled the method name, or the object is of the wrong type. Check out &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for details about any of the above cases. You may also use &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;($object)&lt;/code&gt; to find out the class &lt;code&gt;$object&lt;/code&gt; was blessed into.</source>
          <target state="translated">可能的原因：继承变得混乱，方法名称拼写错误或对象的类型错误。请查看&lt;a href=&quot;perlootut&quot;&gt;perlootut，&lt;/a&gt;以获取有关上述任何情况的详细信息。您也可以使用 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;($object)&lt;/code&gt; 来找出 &lt;code&gt;$object&lt;/code&gt; 被祝福的类。</target>
        </trans-unit>
        <trans-unit id="7b61ffed7b1a69179adefb6f5756bdb1cb79574b" translate="yes" xml:space="preserve">
          <source>Some pragmas are lexically scoped--typically those that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable. Others affect the current package instead, like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; , which allow you to predeclare a variables or subroutines within a particular</source>
          <target state="translated">一些编译指示在词法上是作用域的-通常是那些影响 &lt;code&gt;$^H&lt;/code&gt; 提示变量的编译指示。其他会影响当前程序包，例如 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; ，它们允许您在特定程序中预先声明变量或子例程。</target>
        </trans-unit>
        <trans-unit id="ca977f551e014badc60a278bfe97ad872b1a03f5" translate="yes" xml:space="preserve">
          <source>Some problem (forget which ;-)</source>
          <target state="translated">一些问题(忘了是哪一个;-)</target>
        </trans-unit>
        <trans-unit id="747d0cb3f2eb2365d2dd72ee766a74de28620e7d" translate="yes" xml:space="preserve">
          <source>Some problems are associated with using temporary files that reside on NFS file systems and it is recommended that a local filesystem is used whenever possible. Some of the security tests will most probably fail when the temp file is not local. Additionally, be aware that the performance of I/O operations over NFS will not be as good as for a local disk.</source>
          <target state="translated">使用驻留在NFS文件系统上的临时文件会出现一些问题,建议尽可能使用本地文件系统。当临时文件不是本地文件时,一些安全测试很可能会失败。此外,要注意通过NFS进行的I/O操作的性能不会像本地磁盘那样好。</target>
        </trans-unit>
        <trans-unit id="82690c6e6b8e4e473e3f2745d7358e432662fc95" translate="yes" xml:space="preserve">
          <source>Some processors may find that the &lt;code&gt;S&amp;lt;...&amp;gt;&lt;/code&gt; code is easiest to implement by replacing each space in the parse tree under the content of the S, with an NBSP. But note: the replacement should apply</source>
          <target state="translated">一些处理器可能会发现，通过使用NBSP替换S内容下的解析树中的每个空间，最容易实现 &lt;code&gt;S&amp;lt;...&amp;gt;&lt;/code&gt; 代码。但请注意：更换应适用</target>
        </trans-unit>
        <trans-unit id="229ed6abc320881bbd15c4ddf8619bff82e22293" translate="yes" xml:space="preserve">
          <source>Some programmers choose to use an explicit conversion so as to leave nothing to doubt:</source>
          <target state="translated">有些程序员选择使用显式转换,这样就不会有任何疑问。</target>
        </trans-unit>
        <trans-unit id="76cff92347a8a5dd33b0b88b52afc87676bbe1d1" translate="yes" xml:space="preserve">
          <source>Some programmers may prefer to think of filehandles as objects with methods, preferring to write the last example as:</source>
          <target state="translated">有些程序员可能更喜欢把filehandles看作是带有方法的对象,喜欢把最后一个例子写成。</target>
        </trans-unit>
        <trans-unit id="9293db7d23e9765c2433258535b9e48d3fd5d563" translate="yes" xml:space="preserve">
          <source>Some properties are considered obsolete by Unicode, but still available. There are several varieties of obsolescence:</source>
          <target state="translated">有些属性被Unicode认为是过时的,但仍可使用。过时有几种品种。</target>
        </trans-unit>
        <trans-unit id="8e185e2d007b85b8d377436c39a0c68b4b4f4ab1" translate="yes" xml:space="preserve">
          <source>Some rare applications will need to create more than one interpreter during a session. Such an application might sporadically decide to release any resources associated with the interpreter.</source>
          <target state="translated">一些罕见的应用程序将需要在一个会话期间创建多个解释器。这样的应用程序可能会零星地决定释放与解释器相关的任何资源。</target>
        </trans-unit>
        <trans-unit id="7c5ce3e6e9260f74f3afe8318024d986a7fd16de" translate="yes" xml:space="preserve">
          <source>Some regular expressions use identical subpatterns in several places. Starting with Perl 5.10, it is possible to define named subpatterns in a section of the pattern so that they can be called up by name anywhere in the pattern. This syntactic pattern for this definition group is &lt;code&gt;(?(DEFINE)(?&amp;lt;name&amp;gt;pattern)...)&lt;/code&gt;. An insertion of a named pattern is written as &lt;code&gt;(?&amp;amp;name)&lt;/code&gt;.</source>
          <target state="translated">一些正则表达式在多个地方使用相同的子模式。从Perl 5.10开始，可以在模式的一部分中定义命名子模式，以便可以在模式中的任何位置按名称调用它们。此定义组的语法模式为 &lt;code&gt;(?(DEFINE)(?&amp;lt;name&amp;gt;pattern)...)&lt;/code&gt; 。命名模式的插入被写为 &lt;code&gt;(?&amp;amp;name)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58899e8b736f7c4726449bcec0f3b25df5fc7632" translate="yes" xml:space="preserve">
          <source>Some routines (&lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; ) return true or false, while others (&lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) return either undef, &amp;lt;0, 0 or &amp;gt;0 and are suited for sort.</source>
          <target state="translated">一些例程（ &lt;code&gt;is_odd()&lt;/code&gt; ， &lt;code&gt;is_even()&lt;/code&gt; ， &lt;code&gt;is_zero()&lt;/code&gt; ， &lt;code&gt;is_one()&lt;/code&gt; ， &lt;code&gt;is_nan()&lt;/code&gt; ）返回true或false，而另一些 &lt;code&gt;bcmp()&lt;/code&gt; ， &lt;code&gt;bacmp()&lt;/code&gt; ）返回undef，&amp;lt;0、0或&amp;gt; 0并且适合排序。</target>
        </trans-unit>
        <trans-unit id="834cc437cec84afae22c004e80ee3d6149cb6f55" translate="yes" xml:space="preserve">
          <source>Some routines (&lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; , etc.) return true or false, while others (&lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) return either undef (if NaN is involved), &amp;lt;0, 0 or &amp;gt;0 and are suited for sort.</source>
          <target state="translated">一些例程（ &lt;code&gt;is_odd()&lt;/code&gt; ， &lt;code&gt;is_even()&lt;/code&gt; ， &lt;code&gt;is_zero()&lt;/code&gt; ， &lt;code&gt;is_one()&lt;/code&gt; ， &lt;code&gt;is_nan()&lt;/code&gt; 等）返回true或false，而其他 &lt;code&gt;bcmp()&lt;/code&gt; ， &lt;code&gt;bacmp()&lt;/code&gt; ）返回undef（如果涉及到NaN） ），&amp;lt;0、0或&amp;gt; 0，适合排序。</target>
        </trans-unit>
        <trans-unit id="b07ef2379b9c2b49ab7fe4b04878c3104f0be76f" translate="yes" xml:space="preserve">
          <source>Some scalar variables contain more than one type of scalar data. For example, the variable &lt;code&gt;$!&lt;/code&gt; contains either the numeric value of &lt;code&gt;errno&lt;/code&gt; or its string equivalent from either &lt;code&gt;strerror&lt;/code&gt; or &lt;code&gt;sys_errlist[]&lt;/code&gt; .</source>
          <target state="translated">一些标量变量包含不止一种类型的标量数据。例如，变量 &lt;code&gt;$!&lt;/code&gt; 包含 &lt;code&gt;errno&lt;/code&gt; 的数值或 &lt;code&gt;strerror&lt;/code&gt; 或 &lt;code&gt;sys_errlist[]&lt;/code&gt; 等效字符串。</target>
        </trans-unit>
        <trans-unit id="b802bf6a4f1848df9acbe46a4e2a4fe02ad51578" translate="yes" xml:space="preserve">
          <source>Some scripts, usually identified with a *.PL extension, are self-configuring and are able to correctly create their own shebang path from config information located in Plan 9 Perl. These you won't need to be worried about.</source>
          <target state="translated">有些脚本,通常用*.PL扩展名来标识,它们是自配置的,能够根据Plan 9 Perl中的配置信息正确创建自己的shebang路径。这些你就不需要担心了。</target>
        </trans-unit>
        <trans-unit id="0de1611bc5300339bfc467a34c6fb8f9747fd7ed" translate="yes" xml:space="preserve">
          <source>Some servers are configured to only work in passive mode. If you have one of these you can force &lt;code&gt;Net::FTP&lt;/code&gt; to always transfer in passive mode; when not going via a firewall, by setting &lt;code&gt;ftp_int_passive&lt;/code&gt; to a</source>
          <target state="translated">某些服务器配置为仅在被动模式下工作。如果您具有其中之一，则可以强制 &lt;code&gt;Net::FTP&lt;/code&gt; 始终以被动模式进行传输；当不通过防火墙时，通过将 &lt;code&gt;ftp_int_passive&lt;/code&gt; 设置为</target>
        </trans-unit>
        <trans-unit id="ebc3655c5b01cc226f09d2ace7c8e5f430f35ebd" translate="yes" xml:space="preserve">
          <source>Some servers do not understand this command, but issuing it and ignoring the response is harmless.</source>
          <target state="translated">有些服务器不理解这个命令,但发出这个命令并忽略响应是无害的。</target>
        </trans-unit>
        <trans-unit id="c3d7fb888727f4ae5ed3bb068213cd5f194d2bf2" translate="yes" xml:space="preserve">
          <source>Some signals can be neither trapped nor ignored, such as the KILL and STOP (but not the TSTP) signals. Note that ignoring signals makes them disappear. If you only want them blocked temporarily without them getting lost you'll have to use POSIX' sigprocmask.</source>
          <target state="translated">有些信号既不能被捕获,也不能被忽略,比如KILL和STOP(但不是TSTP)信号。注意,忽略信号会使它们消失。如果你只想让它们暂时被屏蔽而不丢失,你就必须使用POSIX的sigprocmask。</target>
        </trans-unit>
        <trans-unit id="2bcba60d06f3c08a852e1ccedb100d4bd2f6af23" translate="yes" xml:space="preserve">
          <source>Some simple style guidelines</source>
          <target state="translated">一些简单的风格准则</target>
        </trans-unit>
        <trans-unit id="0a3063c3a46746b861b03ccbf2777db3ca544d44" translate="yes" xml:space="preserve">
          <source>Some simple tricks for determining if you are running on an EBCDIC platform could include any of the following (perhaps all):</source>
          <target state="translated">一些简单的技巧来确定你是否在EBCDIC平台上运行,可以包括以下任何一种(也许是全部)。</target>
        </trans-unit>
        <trans-unit id="038ab8e08e45dcac2b1a2ba44edc5e7ade978952" translate="yes" xml:space="preserve">
          <source>Some source filters use the &lt;code&gt;DATA&lt;/code&gt; handle to read the calling program. When using these source filters you cannot rely on this handle, nor expect any particular kind of behavior when operating on it. Filters based on Filter::Util::Call (and therefore Filter::Simple) do not alter the &lt;code&gt;DATA&lt;/code&gt; filehandle.</source>
          <target state="translated">一些源过滤器使用 &lt;code&gt;DATA&lt;/code&gt; 句柄来读取调用程序。使用这些源过滤器时，您不能依赖此句柄，也不能期望对其进行任何特定类型的行为。基于Filter :: Util :: Call的过滤器（以及因此Filter :: Simple）不会更改 &lt;code&gt;DATA&lt;/code&gt; 文件句柄。</target>
        </trans-unit>
        <trans-unit id="5b3ebd295e43b2c81df8bd4b9c3baef266ee5f66" translate="yes" xml:space="preserve">
          <source>Some switches do care if they are processed twice, for instance combinations of &lt;b&gt;-l&lt;/b&gt; and &lt;b&gt;-0&lt;/b&gt;. Either put all the switches after the 32-character boundary (if applicable), or replace the use of &lt;b&gt;-0&lt;/b&gt;</source>
          <target state="translated">一些开关确实关心它们是否被处理了两次，例如&lt;b&gt;-l&lt;/b&gt;和&lt;b&gt;-0的&lt;/b&gt;组合。将所有开关置于32个字符的边界之后（如果适用），或替换为&lt;b&gt;-0&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c346e3627bcf4ba52fad903600add2510035afb4" translate="yes" xml:space="preserve">
          <source>Some systems defined &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; in terms of &lt;code&gt;&lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt;, in which a call to &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; is essentially:</source>
          <target state="translated">一些系统根据 &lt;code&gt;&lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; 定义 &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; ，其中对 &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; 的调用（Rdr，Wtr）本质上是：</target>
        </trans-unit>
        <trans-unit id="6fc6b04b810684b6c41fe63810499cab8b09c739" translate="yes" xml:space="preserve">
          <source>Some systems defined &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; in terms of &lt;code&gt;&lt;a href=&quot;socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt;, in which a call to &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; is essentially:</source>
          <target state="translated">一些系统根据 &lt;code&gt;&lt;a href=&quot;socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; 定义 &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; ，其中对 &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; 的调用（Rdr，Wtr）本质上是：</target>
        </trans-unit>
        <trans-unit id="ec2cddcb7714cb3145808dbf1959d4cf532d708d" translate="yes" xml:space="preserve">
          <source>Some systems have APIs but not implementations: for example QNX and Haiku have the interval timer APIs but not the functionality.</source>
          <target state="translated">有些系统有应用程序接口,但没有实现:例如 QNX 和 Haiku 有间隔定时器应用程序接口,但没有功能。</target>
        </trans-unit>
        <trans-unit id="f1b5dcc57517fdbe334dfa953d44b8287e96b48c" translate="yes" xml:space="preserve">
          <source>Some systems may have even weirder byte orders such as</source>
          <target state="translated">有些系统可能有更奇怪的字节顺序,如</target>
        </trans-unit>
        <trans-unit id="6223cb44b81823af78522ece7689e7171de5236a" translate="yes" xml:space="preserve">
          <source>Some systems use CONFORMING TO to note conformance to relevant standards and MT-LEVEL to note safeness for use in threaded programs or signal handlers. These headings are primarily useful when documenting parts of a C library.</source>
          <target state="translated">有些系统使用CONFORMING TO来说明是否符合相关标准,使用MT-LEVEL来说明在线程或信号处理程序中使用的安全性。这些标题主要在记录C库的部分内容时有用。</target>
        </trans-unit>
        <trans-unit id="b5f78f639815d7596cee6bf607be57c18273af36" translate="yes" xml:space="preserve">
          <source>Some test failures may occur if you use a command shell other than the native &quot;cmd.exe&quot;, or if you are building from a path that contains spaces. So don't do that.</source>
          <target state="translated">如果你使用非本地 &quot;cmd.exe &quot;的命令壳,或者你从包含空格的路径构建,可能会出现一些测试失败。所以不要这样做。</target>
        </trans-unit>
        <trans-unit id="ec70ba84fc671de1bea2095d64f0ecee13115e62" translate="yes" xml:space="preserve">
          <source>Some tests are known to fail:</source>
          <target state="translated">众所周知,有些测试是会失败的。</target>
        </trans-unit>
        <trans-unit id="75d98556687379d0793051b330180895e416a427" translate="yes" xml:space="preserve">
          <source>Some tests may complain under known circumstances.</source>
          <target state="translated">在已知的情况下,一些测试可能会抱怨。</target>
        </trans-unit>
        <trans-unit id="c1340d9e04d7bf928c677a3bd6e8e8121f7021a3" translate="yes" xml:space="preserve">
          <source>Some tests may generate extra messages similar to</source>
          <target state="translated">一些测试可能会产生类似于</target>
        </trans-unit>
        <trans-unit id="81c36c454152688ffa8f0d5944c5eae241cf584a" translate="yes" xml:space="preserve">
          <source>Some tests will be skipped because they need the fork() function:</source>
          <target state="translated">有些测试会被跳过,因为它们需要fork()函数。</target>
        </trans-unit>
        <trans-unit id="ae4dfb05b376af0b4aa8499ceeb5ad1587cfc612" translate="yes" xml:space="preserve">
          <source>Some things might not work as you expect them. Below is documented what is known to be troublesome:</source>
          <target state="translated">有些事情可能无法按照你的预期进行。下面记录的是已知的麻烦。</target>
        </trans-unit>
        <trans-unit id="c22086010db6828bca64b97b121f052c5aaeaeec" translate="yes" xml:space="preserve">
          <source>Some time ago I had reports it does not work. Nowadays it is checked in the Perl test suite, so grep</source>
          <target state="translated">前段时间,我有报道说它不工作。现在在Perl测试套件中已经检查过了,所以grep</target>
        </trans-unit>
        <trans-unit id="729fe9bb5c1721be7b9c47b47d38d0043a1d5be9" translate="yes" xml:space="preserve">
          <source>Some types of lvalues can be localized as well: hash and array elements and slices, conditionals (provided that their result is always localizable), and symbolic references. As for simple variables, this creates new, dynamically scoped values.</source>
          <target state="translated">一些类型的lvalues也可以被本地化:哈希和数组元素和切片,条件(只要它们的结果总是可本地化的),以及符号引用。至于简单变量,这将创建新的、动态范围的值。</target>
        </trans-unit>
        <trans-unit id="36c279e82d37aef763f2dc425df33d302f2edc2c" translate="yes" xml:space="preserve">
          <source>Some unusual systems, such as VMS, require special filename handling in order to deal with symbolic names for files (i.e., VMS's Logical Names).</source>
          <target state="translated">一些不寻常的系统,如VMS,需要特殊的文件名处理,以处理文件的符号名(即VMS的逻辑名)。</target>
        </trans-unit>
        <trans-unit id="6a39214b093577878080cd0246589b3e208ffeb5" translate="yes" xml:space="preserve">
          <source>Some user's however may feel that the above &quot;economy of expression&quot; is not particularly readable nor consistent and may instead choose to do something more like the following:</source>
          <target state="translated">不过,有些用户可能会觉得上面的 &quot;表达经济 &quot;不是特别可读,也不是特别连贯,反而可能会选择更像下面的做法。</target>
        </trans-unit>
        <trans-unit id="1ad295080cd8e985d193a33706aa64c82df7132f" translate="yes" xml:space="preserve">
          <source>Some users have expressed that they think this whole mechanism of having a &quot;fail&quot; attribute at all, seems a rather pointless complication. But I want Locale::Maketext to be usable for software projects of</source>
          <target state="translated">有些用户表示,他们认为这种有 &quot;失败 &quot;属性的机制,似乎是一种相当无意义的复杂化。但我希望Locale::Maketext可以用于以下软件项目中。</target>
        </trans-unit>
        <trans-unit id="7ab6d61e44a0f4b38225b697b64d41eb4c216b63" translate="yes" xml:space="preserve">
          <source>Some users may wish to encourage the use of lexically scoped variables. As an aid to catching implicit uses to package variables, which are always global, if you say</source>
          <target state="translated">一些用户可能希望鼓励使用词法范围变量。作为一种辅助手段,我们可以捕捉到对包变量的隐式使用,这些变量总是全局的,如果你说</target>
        </trans-unit>
        <trans-unit id="020ce1178f605ac1782ec8459fa4fa7fd0cf745e" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;DB_File&lt;/code&gt; won't let you store data under a key of length 0. That means that if you have a function &lt;code&gt;f&lt;/code&gt; which you memoized and the cache is in a &lt;code&gt;DB_File&lt;/code&gt; database, then the value of &lt;code&gt;f()&lt;/code&gt; (&lt;code&gt;f&lt;/code&gt; called with no arguments) will not be memoized. If this is a big problem, you can supply a normalizer function that prepends &lt;code&gt;&quot;x&quot;&lt;/code&gt; to every key.</source>
          <target state="translated">有些版本的 &lt;code&gt;DB_File&lt;/code&gt; 不会让您存储长度为0的项下的数据这意味着，如果你有一个函数 &lt;code&gt;f&lt;/code&gt; 您memoized和缓存处于一个 &lt;code&gt;DB_File&lt;/code&gt; 数据库，那么的值 &lt;code&gt;f()&lt;/code&gt; （ &lt;code&gt;f&lt;/code&gt; 调用没有参数）将不会被记忆。如果这是个大问题，则可以提供一个规范化函数，在每个键之前加上 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bb4498f94e563a623dff663cd55b4fc862752c4" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;make&lt;/code&gt; set the variable &lt;code&gt;MAKE&lt;/code&gt; . Others do not. This variable contains the string to be included in</source>
          <target state="translated">一些版本的 &lt;code&gt;make&lt;/code&gt; 设置变量 &lt;code&gt;MAKE&lt;/code&gt; 。其他人没有。此变量包含要包含在其中的字符串</target>
        </trans-unit>
        <trans-unit id="954f7aeec06323e12a6983f37a0846eca84625d3" translate="yes" xml:space="preserve">
          <source>Some versions of flock() can't lock files over a network (e.g. on NFS file systems), so you'd need to force the use of fcntl(2) when you build Perl. But even this is dubious at best. See the flock entry of &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and the</source>
          <target state="translated">某些版本的flock（）无法通过网络锁定文件（例如，在NFS文件系统上），因此在构建Perl时需要强制使用fcntl（2）。但是，即使这充其量也是可疑的。请参阅&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;的羊群条目和</target>
        </trans-unit>
        <trans-unit id="d311518a6bb3b8613076ce871f73cf8cb1a1e05f" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is one reason why this function is deprecated. The other is that only in extremely limited circumstances should the Unicode versus native code point be of any interest to you. See &lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;utf8_to_uvuni_buf&lt;/a&gt; for alternatives.</source>
          <target state="translated">检测到一些但不是全部UTF-8格式错误，实际上，某些格式错误的输入可能导致读取超出输入缓冲区的末尾，这是不建议使用此功能的原因之一。另一个是只有在极有限的情况下，您才会对Unicode与本机代码点感兴趣。有关替代方法，请参见&lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;utf8_to_uvuni_buf&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2fc9641c97ef26419e8b09582d42e0230f643449" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is why this function is deprecated. Use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt; instead.</source>
          <target state="translated">检测到一些但不是全部UTF-8格式错误，实际上，某些格式错误的输入可能会导致超出输入缓冲区末尾的读取，这就是不建议使用此功能的原因。请改用&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5b99daee126bc167396885e5a173ca7e1b5727f" translate="yes" xml:space="preserve">
          <source>Some, such as &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; aren't provided because the concept does not exist within Plan 9. Others, such as some of the socket-related functions, simply haven't been written yet. Many in the latter category may be supported in the future.</source>
          <target state="translated">由于在Plan 9中不存在该概念，因此未提供诸如 &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 之类的功能。其他诸如与套接字相关的功能之类的其他功能只是尚未编写。将来可能会支持后一类中的许多功能。</target>
        </trans-unit>
        <trans-unit id="6b529d1f2a1daeac288a5dc3e3f1ad071820c7a2" translate="yes" xml:space="preserve">
          <source>Some/Module.pm</source>
          <target state="translated">Some/Module.pm</target>
        </trans-unit>
        <trans-unit id="75f6f0269318d3e6d862e35e227cdb78f8aa0076" translate="yes" xml:space="preserve">
          <source>Someone like Larry, or one of his peculiar friends. Also refers to the strange prefixes that Perl requires as noun markers on its variables.</source>
          <target state="translated">像Larry这样的人,或者他的一个奇特的朋友。也指Perl要求在变量上使用奇怪的前缀作为名词标记。</target>
        </trans-unit>
        <trans-unit id="4645c18015bf5520c386fecd9f2627c0f851f491" translate="yes" xml:space="preserve">
          <source>Someone who &amp;ldquo;carries&amp;rdquo; software from one &lt;b&gt;platform&lt;/b&gt; to another. Porting programs written in platform-dependent languages such as C can be difficult work, but porting programs like Perl is very much worth the agony.</source>
          <target state="translated">将软件从一个&lt;b&gt;平台&lt;/b&gt; &amp;ldquo;携带&amp;rdquo; 到另一个&lt;b&gt;平台的&lt;/b&gt;人。移植用依赖于平台的语言（例如C）编写的程序可能很难，但是移植像Perl这样的程序非常值得痛苦。</target>
        </trans-unit>
        <trans-unit id="81901ca358030c454d79961747b435397961631e" translate="yes" xml:space="preserve">
          <source>Someone who breaks security on computer systems. A cracker may be a true &lt;b&gt;hacker&lt;/b&gt; or only a &lt;b&gt;script kiddie&lt;/b&gt;.</source>
          <target state="translated">破坏计算机系统安全性的人。破解者可能是真正的&lt;b&gt;黑客，&lt;/b&gt;也可能只是&lt;b&gt;脚本小子&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="1964ccb6039dfc22b78b8e0d35db2a914eb047cc" translate="yes" xml:space="preserve">
          <source>Someone who is brilliantly persistent in solving technical problems, whether these involve golfing, fighting orcs, or programming. Hacker is a neutral term, morally speaking. Good hackers are not to be confused with evil &lt;b&gt;crackers&lt;/b&gt; or clueless &lt;b&gt;script kiddies&lt;/b&gt;. If you confuse them, we will presume that you are either evil or clueless.</source>
          <target state="translated">精通解决技术问题的人，无论是打高尔夫球，打兽人还是编程。从道德上讲，黑客是一个中立的名词。好的黑客不要与邪恶的&lt;b&gt;饼干&lt;/b&gt;或无知的&lt;b&gt;脚本小子&lt;/b&gt;混淆。如果您混淆了它们，我们将假定您是邪恶的还是无知的。</target>
        </trans-unit>
        <trans-unit id="a06bdcd2151c9efce6b287181e34780a4956856f" translate="yes" xml:space="preserve">
          <source>Something &amp;ldquo;iffy&amp;rdquo;. See &lt;b&gt;Boolean context&lt;/b&gt;.</source>
          <target state="translated">有点&amp;ldquo; iff&amp;rdquo;。请参见&lt;b&gt;布尔上下文&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="e155f24963deb993057b4c0bc7a9a37afd51cb22" translate="yes" xml:space="preserve">
          <source>Something extra that happens when you evaluate an &lt;b&gt;expression&lt;/b&gt;. Nowadays it can refer to almost anything. For example, evaluating a simple assignment statement typically has the &amp;ldquo;side effect&amp;rdquo; of assigning a value to a variable. (And you thought assigning the value was your primary intent in the first place!) Likewise, assigning a value to the special variable &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) has the side effect of forcing a flush after every &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; on the currently selected filehandle.</source>
          <target state="translated">计算&lt;b&gt;表达式&lt;/b&gt;时会发生一些额外的情况。如今，它几乎可以指任何东西。例如，评估简单的赋值语句通常具有将值分配给变量的&amp;ldquo;副作用&amp;rdquo;。（并且您认为分配值首先是您的主要意图！）同样，将值分配给特殊变量 &lt;code&gt;$|&lt;/code&gt; （ &lt;code&gt;$AUTOFLUSH&lt;/code&gt; ）的副作用是每次在当前选定的文件句柄上 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 后都强制刷新。</target>
        </trans-unit>
        <trans-unit id="783e080adee89f0dfad650da0b7f44d322697c43" translate="yes" xml:space="preserve">
          <source>Something is rotten in the state of the program. An attributed subroutine ceased to exist between the point it was declared and the point at which its attribute handler(s) would have been called.</source>
          <target state="translated">程序的状态有问题。一个归属的子程序在它被声明和它的归属处理程序被调用之间不存在了。</target>
        </trans-unit>
        <trans-unit id="9119b80c4db3125e0e5d3f36b18c5029258c49c9" translate="yes" xml:space="preserve">
          <source>Something is still amiss: consider the loop variable $cnt of the script. It was a number, not an object. We cannot make this value of type &lt;code&gt;symbolic&lt;/code&gt; , since then the loop will not terminate.</source>
          <target state="translated">仍然有些不对劲：考虑脚本的循环变量$ cnt。这是一个数字，而不是一个对象。我们不能使这个类型的值成为 &lt;code&gt;symbolic&lt;/code&gt; ，因为那样循环就不会终止。</target>
        </trans-unit>
        <trans-unit id="b420f56b3a25fc6071dc9a2a0d9e492a4d5a4fac" translate="yes" xml:space="preserve">
          <source>Something like &lt;code&gt;&quot;-DHAVE_UNISTD_H&quot;&lt;/code&gt;</source>
          <target state="translated">类似于 &lt;code&gt;&quot;-DHAVE_UNISTD_H&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2229723dcea531af53507e7f80155b0032f61e90" translate="yes" xml:space="preserve">
          <source>Something not owned by anybody. Perl is copyrighted and is thus</source>
          <target state="translated">不属于任何人的东西。Perl是受版权保护的,因此</target>
        </trans-unit>
        <trans-unit id="63320e06b401dd030b4898741e99304253f96385" translate="yes" xml:space="preserve">
          <source>Something of a hack but it prevents a lot of code duplication between MM_* variants.</source>
          <target state="translated">虽然是个黑客,但它可以防止MM_*变种之间的大量代码重复。</target>
        </trans-unit>
        <trans-unit id="bbccb8a40149fe00b8fef910fa55b43eced89db6" translate="yes" xml:space="preserve">
          <source>Something similar to the offset hack is performed on AVs to enable efficient shifting and splicing off the beginning of the array; while &lt;code&gt;AvARRAY&lt;/code&gt; points to the first element in the array that is visible from Perl, &lt;code&gt;AvALLOC&lt;/code&gt; points to the real start of the C array. These are usually the same, but a &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; operation can be carried out by increasing &lt;code&gt;AvARRAY&lt;/code&gt; by one and decreasing &lt;code&gt;AvFILL&lt;/code&gt; and &lt;code&gt;AvMAX&lt;/code&gt; . Again, the location of the real start of the C array only comes into play when freeing the array. See &lt;code&gt;av_shift&lt;/code&gt; in</source>
          <target state="translated">在AV上执行与偏移hack相似的操作，以实现有效的移位和拼接数组的开头。而 &lt;code&gt;AvARRAY&lt;/code&gt; 指向数组中的第一个元素是可见从Perl中， &lt;code&gt;AvALLOC&lt;/code&gt; 点到C阵列的真正开始。这些通常是相同的，但是可以通过将 &lt;code&gt;AvARRAY&lt;/code&gt; 增加1并减小 &lt;code&gt;AvFILL&lt;/code&gt; 和 &lt;code&gt;AvMAX&lt;/code&gt; 来执行 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 操作。同样，仅当释放数组时，C数组的实际起始位置才起作用。见 &lt;code&gt;av_shift&lt;/code&gt; 在</target>
        </trans-unit>
        <trans-unit id="4332fef1f22d39fca98466a0536a5b2d1aaa44ee" translate="yes" xml:space="preserve">
          <source>Something that tells your program what sort of variable you&amp;rsquo;d like. Perl doesn&amp;rsquo;t require you to declare variables, but you can use &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; to denote that you want something other than the default.</source>
          <target state="translated">告诉您的程序您想要哪种变量的信息。Perl不需要声明变量，但是您可以使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 表示您想要除默认值以外的内容。</target>
        </trans-unit>
        <trans-unit id="7ad3b77572daa04075d4890e62387b4b824f1955" translate="yes" xml:space="preserve">
          <source>Something to exclude, prefixed by &lt;code&gt;&quot;-&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">以 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 为前缀的要排除的东西：现有的字符属性（以 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; 作为前缀）或完全限定的（包括程序包名称）用户定义的字符属性，以表示该属性中的所有字符；一个范围的两个十六进制代码点；或单个十六进制代码点。</target>
        </trans-unit>
        <trans-unit id="2f7458ff984e1016174a3ccc404733830b1557d4" translate="yes" xml:space="preserve">
          <source>Something to include, prefixed by &lt;code&gt;&quot;+&quot;&lt;/code&gt; : a built-in character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">包含以 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 为前缀的内容：内置字符属性（以 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; 为前缀）或完全限定的（包括程序包名称）用户定义的字符属性，以表示该属性中的所有字符；一个范围的两个十六进制代码点；或单个十六进制代码点。</target>
        </trans-unit>
        <trans-unit id="691cfd6a9c9ef44b73a6c3b1fc2fc7e231422dbe" translate="yes" xml:space="preserve">
          <source>Something to intersect with, prefixed by &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, for all the characters except the characters in the property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">与之相交的东西，以 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 为前缀：对于该属性中除字符之外的所有字符，现有字符属性（以 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; 作为前缀）或完全限定的（包括程序包名称）用户定义的字符属性；一个范围的两个十六进制代码点；或单个十六进制代码点。</target>
        </trans-unit>
        <trans-unit id="6131959027de2eb65107afa87755cfdbae0af220" translate="yes" xml:space="preserve">
          <source>Something to negate, prefixed &lt;code&gt;&quot;!&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">否定的东西，以 &lt;code&gt;&quot;!&quot;&lt;/code&gt; 为前缀 ：一个现有的字符属性（以 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; 为前缀）或一个完全限定的（包括程序包名称）用户定义的字符属性，以表示该属性中的所有字符；一个范围的两个十六进制代码点；或单个十六进制代码点。</target>
        </trans-unit>
        <trans-unit id="b29b35d3b7e27c5736fa04a9d5a9779f7c0d02b4" translate="yes" xml:space="preserve">
          <source>Something we&amp;rsquo;d call a &lt;b&gt;metacharacter&lt;/b&gt; except that it&amp;rsquo;s a sequence of more than one character. Generally, the first character in the sequence must be a true metacharacter to get the other characters in the metasymbol to misbehave along with it.</source>
          <target state="translated">我们称其为&lt;b&gt;元字符，&lt;/b&gt;只是它是一个以上的字符序列。通常，序列中的第一个字符必须是真实的元字符，才能使该元符号中的其他字符与之一起行为异常。</target>
        </trans-unit>
        <trans-unit id="0939ed03ca5713b7d596d517d3a21d567b42a063" translate="yes" xml:space="preserve">
          <source>Something went horribly wrong-- the number of microseconds that cannot become negative just became negative. Maybe your compiler is broken?</source>
          <target state="translated">有些地方出了大问题...不能变成负数的微秒数刚刚变成了负数。也许你的编译器坏了?</target>
        </trans-unit>
        <trans-unit id="c59ba282daa2ae9441382d6bdd1d5cbb102eba6e" translate="yes" xml:space="preserve">
          <source>Something you can see from anywhere, usually used of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; that are visible everywhere in your program. In Perl, only certain special variables are truly global&amp;mdash;most variables (and all subroutines) exist only in the current &lt;b&gt;package&lt;/b&gt;. Global variables can be declared with &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;. See &amp;ldquo;Global Declarations&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="translated">您可以从任何地方看到的东西，通常使用&lt;b&gt;变量&lt;/b&gt;和&lt;b&gt;子例程&lt;/b&gt;，这些&lt;b&gt;变量&lt;/b&gt;和&lt;b&gt;子例程&lt;/b&gt;在程序中随处可见。在Perl中，只有某些特殊变量才是真正的全局变量-大多数变量（和所有子例程）仅存在于当前&lt;b&gt;包中&lt;/b&gt;。全局变量可以用 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明。请参见骆驼第4章&amp;ldquo;声明和声明&amp;rdquo;中的&amp;ldquo;全球声明&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="07e88fa4cc64647b2e3278d50a97cb8b0618c720" translate="yes" xml:space="preserve">
          <source>Something you do for someone else to make them happy, like giving them the time of day (or of their life). On some machines, well-known services are listed by the &lt;code&gt;&lt;a href=&quot;functions/getservent&quot;&gt;getservent&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">您为他人做的使他们开心的事情，例如给他们一天（或一生）的时间。在某些计算机上， &lt;code&gt;&lt;a href=&quot;functions/getservent&quot;&gt;getservent&lt;/a&gt;&lt;/code&gt; 函数列出了众所周知的服务。</target>
        </trans-unit>
        <trans-unit id="457be77433ae10862116d65ca361c913afdc2edf" translate="yes" xml:space="preserve">
          <source>Sometimes (see &lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;When Unicode Does Not Happen&lt;/a&gt; or &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;) there are situations where you simply need to force a byte string into UTF-8, or vice versa. The standard module &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; can be used for this, or the low-level calls &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::upgrade($bytestring) &lt;/a&gt; and &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::downgrade($utf8string[, FAIL_OK]) &lt;/a&gt;.</source>
          <target state="translated">有时（请参见&lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;Unicode不会发生&lt;/a&gt;或&lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;Unicode错误&lt;/a&gt;）在某些情况下，您只需要将字节字符串强制放入UTF-8，反之亦然。可以使用标准模块&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;或低级调用&lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: upgrade（$ bytestring）&lt;/a&gt;和&lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: downgrade（$ utf8string [，FAIL_OK]）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c72f071a765fd3018bc7af5d49df36cbd9aae7b" translate="yes" xml:space="preserve">
          <source>Sometimes greed is not good. At times, we would like quantifiers to match a</source>
          <target state="translated">有时候,贪心不是好事。有时,我们会希望量化器能匹配一个</target>
        </trans-unit>
        <trans-unit id="0aa27e840004256e29009bb974e009bb34e90abf" translate="yes" xml:space="preserve">
          <source>Sometimes instead of zeroing the allocated heap by using Newxz() you should consider &quot;poisoning&quot; the data. This means writing a bit pattern into it that should be illegal as pointers (and floating point numbers), and also hopefully surprising enough as integers, so that any code attempting to use the data without forethought will break sooner rather than later. Poisoning can be done using the Poison() macros, which have similar arguments to Zero():</source>
          <target state="translated">有时,与其使用Newxz()将分配的堆归零,不如考虑给数据 &quot;下毒&quot;。这意味着在其中写一个位模式,作为指针(和浮点数)应该是非法的,同时也希望作为整数有足够的惊喜,这样任何试图不经意地使用数据的代码都会迟早崩溃。中毒可以使用Poison()宏,它的参数与Zero()类似。</target>
        </trans-unit>
        <trans-unit id="cae5675054ecaa30b3d68d273e86faefe7bf19e0" translate="yes" xml:space="preserve">
          <source>Sometimes it is advantageous to construct a pattern from the</source>
          <target state="translated">有时,从</target>
        </trans-unit>
        <trans-unit id="fa5de12a356ae81ac7e15fb6c4fdf4f42322289c" translate="yes" xml:space="preserve">
          <source>Sometimes it may be necessary to make more than one pass over the input files. If this is the case you have several options. You can make the first pass using &lt;b&gt;Pod::Parser&lt;/b&gt; and override your methods to store the intermediate results in memory somewhere for the &lt;b&gt;end_pod()&lt;/b&gt; method to process. You could use &lt;b&gt;Pod::Parser&lt;/b&gt; for several passes with an appropriate state variable to control the operation for each pass. If your input source can't be reset to start at the beginning, you can store it in some other structure as a string or an array and have that structure implement a &lt;b&gt;getline()&lt;/b&gt; method (which is all that &lt;b&gt;parse_from_filehandle()&lt;/b&gt; uses to read input).</source>
          <target state="translated">有时可能需要对输入文件进行一次以上的传递。如果是这种情况，您可以有几种选择。您可以使用&lt;b&gt;Pod :: Parser&lt;/b&gt;进行第一遍，并覆盖您的方法以将中间结果存储在内存中的某个地方，以便&lt;b&gt;end_pod（）&lt;/b&gt;方法进行处理。您可以使用&lt;b&gt;Pod :: Parser&lt;/b&gt;进行多次传递，并使用适当的状态变量来控制每次传递的操作。如果您无法将输入源重置为从头开始，则可以将其以字符串或数组的形式存储在其他结构中，并使该结构实现&lt;b&gt;getline（）&lt;/b&gt;方法（&lt;b&gt;parse_from_filehandle（）&lt;/b&gt;用于读取的全部&lt;b&gt;内容）&lt;/b&gt;输入）。</target>
        </trans-unit>
        <trans-unit id="f6006f7823a5727b8006f191fa888a2e039ea099" translate="yes" xml:space="preserve">
          <source>Sometimes minimal matching can help a lot. Imagine you'd like to match everything between &quot;foo&quot; and &quot;bar&quot;. Initially, you write something like this:</source>
          <target state="translated">有时候,最小化的匹配会有很大的帮助。想象一下,你想匹配 &quot;foo &quot;和 &quot;bar &quot;之间的所有内容。最初,你写的东西是这样的。</target>
        </trans-unit>
        <trans-unit id="7e0fb1495abd7611e5570cce2cb4d1976ffa0113" translate="yes" xml:space="preserve">
          <source>Sometimes older versions of the module you're installing live in other directories in @INC. Because Perl loads the first version of a module it finds, not the newest, you might accidentally get one of these older versions even after installing a brand new version. To delete</source>
          <target state="translated">有时,你要安装的模块的旧版本存在于 @INC 的其他目录中。因为Perl加载的是它所找到的模块的第一个版本,而不是最新的版本,所以即使安装了一个全新的版本,你也可能会意外地得到其中的一个旧版本。要删除</target>
        </trans-unit>
        <trans-unit id="eb753520a2d796d4f761ee04ddf336bdbe0915a3" translate="yes" xml:space="preserve">
          <source>Sometimes ops are executed within an inner runops loop, such as tie, sort or overload code. In this case, something like</source>
          <target state="translated">有时,运维会在内部的runops循环中执行,比如领带、排序或重载代码。在这种情况下,类似于</target>
        </trans-unit>
        <trans-unit id="147ec757892c0aed445b0fb45a48e27c978e8a0c" translate="yes" xml:space="preserve">
          <source>Sometimes running a test under certain conditions will cause the test script to die. A certain function or method isn't implemented (such as &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; on MacOS), some resource isn't available (like a net connection) or a module isn't available. In these cases it's necessary to skip tests, or declare that they are supposed to fail but will work in the future (a todo test).</source>
          <target state="translated">有时在某些条件下运行测试将导致测试脚本死亡。某些功能或方法未实现（例如MacOS上的 &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; ），某些资源不可用（例如网络连接）或模块不可用。在这种情况下，有必要跳过测试，或者声明它们应该失败，但将来仍可以使用（待办事项测试）。</target>
        </trans-unit>
        <trans-unit id="14a525fd22c2b653fcabe0c32c53b3975d5455dc" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::Builder test counter is incremented without it printing any test output, for example, when &lt;code&gt;current_test()&lt;/code&gt; is changed. In these cases, Test::Builder doesn't know the result of the test, so its type is 'unknown'. These details for these tests are filled in. They are considered ok, but the name and actual_ok is left &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有时，Test :: Builder测试计数器会递增，而不会打印任何测试输出，例如，当 &lt;code&gt;current_test()&lt;/code&gt; 更改时。在这些情况下，Test :: Builder不知道测试结果，因此其类型为&amp;ldquo;未知&amp;rdquo;。这些测试的详细信息已填写。它们被认为可以，但是名称和Actual_ok仍为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c117b85f5735958c8ac918f5819ede8cc1b0ef4" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::More interface isn't quite enough. Fortunately, Test::More is built on top of &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; which provides a single, unified backend for any test library to use. This means two test libraries which both use &amp;lt;Test::Builder&amp;gt; &lt;b&gt;can&lt;/b&gt; be used together in the same program&amp;gt;.</source>
          <target state="translated">有时Test :: More接口还不够。幸运的是，Test :: More建立在&lt;a href=&quot;builder&quot;&gt;Test :: Builder的基础上&lt;/a&gt;，它为任何测试库提供了一个统一的后端。这意味着两个都使用&amp;lt;Test :: Builder&amp;gt;的测试库&lt;b&gt;可以&lt;/b&gt;在同一程序中一起使用。</target>
        </trans-unit>
        <trans-unit id="ff0436b0b7df1e2c343b73c639e499fd807b68f3" translate="yes" xml:space="preserve">
          <source>Sometimes there is some confusion about where &lt;code&gt;todo()&lt;/code&gt; should be looking for the &lt;code&gt;$TODO&lt;/code&gt; variable. If you want to be sure, tell it explicitly what $pack to use.</source>
          <target state="translated">有时对于 &lt;code&gt;todo()&lt;/code&gt; 应该在哪里寻找 &lt;code&gt;$TODO&lt;/code&gt; 变量有些困惑。如果要确定，请明确告诉它使用什么$ pack。</target>
        </trans-unit>
        <trans-unit id="399765aa05845ba02b6fea1a15de4bf746fb4a9e" translate="yes" xml:space="preserve">
          <source>Sometimes we would like our regexp to be able to match different possible words or character strings. This is accomplished by using the</source>
          <target state="translated">有时我们希望我们的regexp能够匹配不同可能的单词或字符串。这可以通过使用</target>
        </trans-unit>
        <trans-unit id="c45fdfd630d6939174042d52a2669877eec8162b" translate="yes" xml:space="preserve">
          <source>Sometimes you don't want to pass the value of an array to a subroutine but rather the name of it, so that the subroutine can modify the global copy of it rather than working with a local copy. In perl you can refer to all objects of a particular name by prefixing the name with a star: &lt;code&gt;*foo&lt;/code&gt; . This is often known as a &quot;typeglob&quot;, because the star on the front can be thought of as a wildcard match for all the funny prefix characters on variables and subroutines and such.</source>
          <target state="translated">有时，您不想将数组的值传递给子例程，而是希望将其名称传递给子例程，以便子例程可以修改其全局副本，而不是使用本地副本。在perl中，可以通过在名称前面加上星号 &lt;code&gt;*foo&lt;/code&gt; 来引用特定名称的所有对象。这通常被称为&amp;ldquo; typeglob&amp;rdquo;，因为前面的星星可以被认为是变量和子例程等上所有有趣的前缀字符的通配符匹配。</target>
        </trans-unit>
        <trans-unit id="3dc7c2918cdb381ad384c3d9167215ff71a8a0da" translate="yes" xml:space="preserve">
          <source>Sometimes you have to store undefined values in AVs or HVs. Although this may be a rare case, it can be tricky. That's because you're used to using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; if you need an undefined SV.</source>
          <target state="translated">有时您必须在AV或HV中存储未定义的值。尽管这可能很少见，但可能很棘手。这是因为如果您需要未定义的SV，则习惯于使用 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce5b78669327a1c5203b6d6638f97e91e235e173" translate="yes" xml:space="preserve">
          <source>Sometimes you just want to say that the tests have passed. Usually the case is you've got some complicated condition that is difficult to wedge into an &lt;code&gt;ok()&lt;/code&gt; . In this case, you can simply use &lt;code&gt;pass()&lt;/code&gt; (to declare the test ok) or fail (for not ok). They are synonyms for &lt;code&gt;ok(1)&lt;/code&gt; and &lt;code&gt;ok(0)&lt;/code&gt; .</source>
          <target state="translated">有时您只想说测试已经通过。通常情况是，您遇到了一些复杂的情况，很难适应 &lt;code&gt;ok()&lt;/code&gt; 。在这种情况下，您可以简单地使用 &lt;code&gt;pass()&lt;/code&gt; （声明测试正常）或失败（表示不正常）。它们是 &lt;code&gt;ok(1)&lt;/code&gt; 和 &lt;code&gt;ok(0)&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="99ad657b111885cfb86229225ce3dd7e07ab7571" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to truncate an already-existing file. This can be done using the &lt;code&gt;O_TRUNC&lt;/code&gt; flag. The behavior of &lt;code&gt;O_TRUNC&lt;/code&gt; with &lt;code&gt;O_RDONLY&lt;/code&gt; is undefined.</source>
          <target state="translated">有时您可能想截断一个已经存在的文件。可以使用 &lt;code&gt;O_TRUNC&lt;/code&gt; 标志来完成。 &lt;code&gt;O_TRUNC&lt;/code&gt; 与 &lt;code&gt;O_RDONLY&lt;/code&gt; 的行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="d108e62bce7d546642fdcfcda3e786d8361305f7" translate="yes" xml:space="preserve">
          <source>Sometimes you may wish to leave the processes run by CPAN alone without caring about them. Because the Makefile.PL or the Build.PL sometimes contains question you're expected to answer, you can set a timer that will kill a 'perl Makefile.PL' process after the specified time in seconds.</source>
          <target state="translated">有时你可能希望不关心CPAN运行的进程。因为Makefile.PL或Build.PL有时会包含你需要回答的问题,你可以设置一个定时器,在指定的时间(秒)后杀死 &quot;perl Makefile.PL &quot;进程。</target>
        </trans-unit>
        <trans-unit id="c00f6f509d151b6fb1ea7605fa661bc15fbf5303" translate="yes" xml:space="preserve">
          <source>Sometimes you might really need to know the byte length of a string instead of the character length. For that use either the &lt;code&gt;Encode::encode_utf8()&lt;/code&gt; function or the &lt;code&gt;bytes&lt;/code&gt; pragma and the &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; function:</source>
          <target state="translated">有时您可能真的需要知道字符串的字节长度而不是字符长度。为此，请使用 &lt;code&gt;Encode::encode_utf8()&lt;/code&gt; 函数或 &lt;code&gt;bytes&lt;/code&gt; 编译指示和 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="69ca48a72c9601cef59e5c67d6f3681c75e3b061" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to build a statically linked perl although your system supports dynamic loading. In this case you may explicitly set the linktype with the invocation of the Makefile.PL or make:</source>
          <target state="translated">有时你可能想建立一个静态链接的perl,尽管你的系统支持动态加载。在这种情况下,你可以通过调用Makefile.PL或make.PL来明确设置链接类型。</target>
        </trans-unit>
        <trans-unit id="d30402c312d3b94f0c6f02a6509532f4e38398dd" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to display Perl scalars containing Unicode as simple ASCII (or EBCDIC) text. The following subroutine converts its argument so that Unicode characters with code points greater than 255 are displayed as &lt;code&gt;\x{...}&lt;/code&gt; , control characters (like &lt;code&gt;\n&lt;/code&gt; ) are displayed as &lt;code&gt;\x..&lt;/code&gt; , and the rest of the characters as themselves:</source>
          <target state="translated">有时，您可能希望将包含Unicode的Perl标量显示为简单ASCII（或EBCDIC）文本。下面的子例程转换其参数，以使代码点大于255的Unicode字符显示为 &lt;code&gt;\x{...}&lt;/code&gt; ，控制字符（如 &lt;code&gt;\n&lt;/code&gt; ）显示为 &lt;code&gt;\x..&lt;/code&gt; ，其余字符作为它们自己：</target>
        </trans-unit>
        <trans-unit id="93cab2a917ae8f995aa91a73cd34dbac7106cc0f" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to provide some extra methods or subroutines to assist in making the interface between Perl and your extension simpler or easier to understand. These routines should live in the .pm file. Whether they are automatically loaded when the extension itself is loaded or only loaded when called depends on where in the .pm file the subroutine definition is placed. You can also consult &lt;a href=&quot;autoloader&quot;&gt;AutoLoader&lt;/a&gt; for an alternate way to store and load your extra subroutines.</source>
          <target state="translated">有时，您可能想提供一些额外的方法或子例程，以帮助使Perl和您的扩展之间的接口更简单或更易于理解。这些例程应位于.pm文件中。它们是在加载扩展本身时自动加载还是仅在调用扩展时加载，取决于子例程定义在.pm文件中的位置。您还可以咨询&lt;a href=&quot;autoloader&quot;&gt;AutoLoader&lt;/a&gt;，以找到另一种方式来存储和加载额外的子例程。</target>
        </trans-unit>
        <trans-unit id="d50f25bb7791c3200f165a11a2621c66fc26aa1f" translate="yes" xml:space="preserve">
          <source>Sometimes you need to have two and more XS files in the same package. One way to go is to put them into separate directories, but sometimes this is not the most suitable solution. The following technique allows you to put two (and more) XS files in the same directory.</source>
          <target state="translated">有时你需要在同一个包里有两个及以上的XS文件。一种方法是把它们放在不同的目录中,但有时这不是最合适的解决方案。下面的技术可以让你把两个(和多个)XS文件放在同一个目录中。</target>
        </trans-unit>
        <trans-unit id="d84ae75a88af76cd17f4e95ee970d0624fc53ec5" translate="yes" xml:space="preserve">
          <source>Sometimes you need to invoke the same subroutine repeatedly. This usually happens with a function that acts on a list of values, such as Perl's built-in sort(). You can pass a comparison function to sort(), which will then be invoked for every pair of values that needs to be compared. The first() and reduce() functions from &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; follow a similar pattern.</source>
          <target state="translated">有时您需要重复调​​用同一子例程。这通常发生在作用于值列表的函数上，例如Perl的内置sort（）。您可以将比较函数传递给sort（），然后对需要比较的每对值调用该函数。&lt;a href=&quot;list/util&quot;&gt;List :: Util中&lt;/a&gt;的first（）和reduce（）函数遵循类似的模式。</target>
        </trans-unit>
        <trans-unit id="74631c8a306d075a7cfb9919a67e89afd99fe44c" translate="yes" xml:space="preserve">
          <source>Sometimes you really don't know how many tests were run, or it's too difficult to calculate. In which case you can leave off $number_of_tests_run.</source>
          <target state="translated">有时你真的不知道运行了多少测试,或者是太难计算了,在这种情况下,你可以不使用$number_of_tests_run。在这种情况下,你可以不填写$number_of_tests_run。</target>
        </trans-unit>
        <trans-unit id="85a6426e0300f2135b305a518e04a9c8bcb36f5b" translate="yes" xml:space="preserve">
          <source>Sometimes you should change the positions of the constant and the variable. For example, let's say you wanted to test which of many answers you were given, but in a case-insensitive way that also allows abbreviations. You can use the following technique if the strings all start with different characters or if you want to arrange the matches so that one takes precedence over another, as &lt;code&gt;&quot;SEND&quot;&lt;/code&gt; has precedence over &lt;code&gt;&quot;STOP&quot;&lt;/code&gt; here:</source>
          <target state="translated">有时您应该更改常量和变量的位置。例如，假设您想测试给出的许多答案中的哪一个，但是以不区分大小写的方式进行，也允许使用缩写。如果所有字符串均以不同的字符开头，或者您要安排匹配项以使一个优先于另一个，则可以使用以下技术，因为此处 &lt;code&gt;&quot;SEND&quot;&lt;/code&gt; 优先于 &lt;code&gt;&quot;STOP&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e295d93f5cf54bf6ebaedc8fedd1af1c66b62ba7" translate="yes" xml:space="preserve">
          <source>Sometimes you want to combine the best of hashes and arrays. For example, the command line:</source>
          <target state="translated">有时你想把哈希和数组的优点结合起来。例如,命令行。</target>
        </trans-unit>
        <trans-unit id="eb405d6eff8a4115aee698cb0c98540a6a3fb25a" translate="yes" xml:space="preserve">
          <source>Sometimes you want to test if a module, or a list of modules, can successfully load. For example, you'll often want a first test which simply loads all the modules in the distribution to make sure they work before going on to do more complicated testing.</source>
          <target state="translated">有时你想测试一个模块或一个模块列表是否能成功加载。例如,你经常会想要进行第一次测试,简单地加载发行版中的所有模块,以确保它们能够工作,然后再进行更复杂的测试。</target>
        </trans-unit>
        <trans-unit id="ddf8f669e0c9325d3a3aabdd507e3c59589ddd67" translate="yes" xml:space="preserve">
          <source>Sometimes, for example when there are a lot of options, having a separate variable for each of them can be cumbersome. GetOptions() supports, as an alternative mechanism, storing options values in a hash.</source>
          <target state="translated">有时,例如当有很多选项时,为每一个选项建立一个单独的变量是很麻烦的,GetOptions()支持,作为一种替代机制,将选项值存储在哈希中。GetOptions()作为一种替代机制,支持在哈希中存储选项值。</target>
        </trans-unit>
        <trans-unit id="02fbdd8083e416b0e9b5fb808fb524ba8afb9c15" translate="yes" xml:space="preserve">
          <source>Sometimes, however, linked lists can be useful in situations where you want to &quot;shard&quot; an array so you have many small arrays instead of a single big array. You can keep arrays longer than Perl's largest array index, lock smaller arrays separately in threaded programs, reallocate less memory, or quickly insert elements in the middle of the chain.</source>
          <target state="translated">然而,有时,在你想 &quot;碎片 &quot;一个数组,从而拥有许多小数组而不是一个大数组的情况下,链接列表会很有用。你可以保留比Perl最大的数组索引更长的数组,在线程程序中分别锁定较小的数组,重新分配较少的内存,或者在链的中间快速插入元素。</target>
        </trans-unit>
        <trans-unit id="97c577b8a14d559ea222f726e98e3c5c96ca2ea7" translate="yes" xml:space="preserve">
          <source>Sometimes, it can be necessary or useful to make sure that a certain function is fully loaded by AutoLoader. This is the case, for example, when you need to wrap a function to inject debugging code. It is also helpful to force early loading of code before forking to make use of copy-on-write as much as possible.</source>
          <target state="translated">有时,确保某个函数被AutoLoader完全加载是必要的或有用的。例如,当您需要封装一个函数以注入调试代码时,就会出现这种情况。在分叉之前强制提前加载代码也是很有帮助的,这样可以尽可能多地利用copy-on-write。</target>
        </trans-unit>
        <trans-unit id="c69c69258cfab486eea48fb3f2e535b94c5ff785" translate="yes" xml:space="preserve">
          <source>Sometimes, when the extension does not convert data but just stores and retrieves it, you will be able to use the otherwise dangerous &lt;a href=&quot;encode#_utf8_on&quot;&gt;Encode::_utf8_on() &lt;/a&gt; function. Let's say the popular &lt;code&gt;Foo::Bar&lt;/code&gt; extension, written in C, provides a &lt;code&gt;param&lt;/code&gt; method that lets you store and retrieve data according to these prototypes:</source>
          <target state="translated">有时，当扩展名不转换数据而是仅存储和检索数据时，您将能够使用否则会很危险的&lt;a href=&quot;encode#_utf8_on&quot;&gt;Encode :: _ utf8_on（）&lt;/a&gt;函数。假设流行的 &lt;code&gt;Foo::Bar&lt;/code&gt; 扩展是用C编写的，它提供了一个 &lt;code&gt;param&lt;/code&gt; 方法，使您可以根据以下原型存储和检索数据：</target>
        </trans-unit>
        <trans-unit id="915dac0cd6a2dc4688c56bcdae8cb3044da9ebd2" translate="yes" xml:space="preserve">
          <source>Sometimes, you might not wish to extract a complete archive, just the files that are relevant to you, based on some criteria.</source>
          <target state="translated">有时,您可能不希望提取完整的存档,而只是根据某些标准提取与您相关的文件。</target>
        </trans-unit>
        <trans-unit id="7d2c8f1aa042b04053bafd03d4559b130a601b41" translate="yes" xml:space="preserve">
          <source>Sort an array, with various options.</source>
          <target state="translated">对一个数组进行排序,有多种选项。</target>
        </trans-unit>
        <trans-unit id="f11b2d382bb4d1812bd22f06feccfbd16f64c011" translate="yes" xml:space="preserve">
          <source>Sort an array. Here is an example:</source>
          <target state="translated">对一个数组进行排序。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="4d31f4a6a4ae686389ba0f01ad7435ce3ff7f965" translate="yes" xml:space="preserve">
          <source>Sort speed and memory use impacts</source>
          <target state="translated">排序速度和内存使用的影响</target>
        </trans-unit>
        <trans-unit id="e86fa3b469953cdb9c0cfc2f27adce6dc70ff6d4" translate="yes" xml:space="preserve">
          <source>Sort your map in Unicode order.</source>
          <target state="translated">按照Unicode的顺序对地图进行排序。</target>
        </trans-unit>
        <trans-unit id="ba790800e4b9f3d3512c898b0e6088f4dbb30c87" translate="yes" xml:space="preserve">
          <source>Sorting - the quicksort algorithm used in Perls before 5.8.0 to implement the sort() function is very easy to trick into misbehaving so that it consumes a lot of time. Starting from Perl 5.8.0 a different sorting algorithm, mergesort, is used by default. Mergesort cannot misbehave on any input.</source>
          <target state="translated">排序--在5.8.0之前的Perls中使用的quicksort算法来实现sort()函数,很容易被欺骗,使其产生错误行为,从而消耗大量时间。从Perl 5.8.0开始,默认使用不同的排序算法mergesort。Mergesort 不能在任何输入上发生误操作。</target>
        </trans-unit>
        <trans-unit id="88a6e89fe9499560d5c7c4f0eba879f0797fcbdf" translate="yes" xml:space="preserve">
          <source>Sorts a list of strings.</source>
          <target state="translated">对字符串列表进行排序。</target>
        </trans-unit>
        <trans-unit id="89989e7858233b758069d9e36e356e32ea1f4ab9" translate="yes" xml:space="preserve">
          <source>Sounds an awful lot like a process, doesn't it? Well, it should. Threads are one of the pieces of a process. Every process has at least one thread and, up until now, every process running Perl had only one thread. With 5.8, though, you can create extra threads. We're going to show you how, when, and why.</source>
          <target state="translated">听起来很像一个过程,不是吗?嗯,应该是这样。线程是进程的一个组成部分。每个进程都至少有一个线程,直到现在,每个运行Perl的进程都只有一个线程。不过,在5.8中,你可以创建额外的线程。我们将向你展示如何、何时以及为什么。</target>
        </trans-unit>
        <trans-unit id="7b37110e5b01350732eac4676af2611966b9ccef" translate="yes" xml:space="preserve">
          <source>Source Code</source>
          <target state="translated">源代码</target>
        </trans-unit>
        <trans-unit id="f0a8c7951e6c30a3c63c9dfb78486cbdf3df91af" translate="yes" xml:space="preserve">
          <source>Source Documentation</source>
          <target state="translated">源文件</target>
        </trans-unit>
        <trans-unit id="c29ede2e39eca25683627a84bf1a76ac20119bd7" translate="yes" xml:space="preserve">
          <source>Source Filters</source>
          <target state="translated">源过滤器</target>
        </trans-unit>
        <trans-unit id="ade8f2661e9afaab2f2ac27ea8394747efc3b4bf" translate="yes" xml:space="preserve">
          <source>Source Handler</source>
          <target state="translated">源处理程序</target>
        </trans-unit>
        <trans-unit id="862ba12e5a4342d2fb92f862ee8e26706e1ba4d8" translate="yes" xml:space="preserve">
          <source>Source code locations, even if available, can often be missing or misleading if the compiler has e.g. inlined code. Optimizer can make matching the source code and the object code quite challenging.</source>
          <target state="translated">源代码的位置,即使有,如果编译器有例如内联代码,也会经常丢失或误导。优化器可以使源代码和对象代码的匹配变得相当具有挑战性。</target>
        </trans-unit>
        <trans-unit id="b0272509bdb0dc4d43ea57d6e30f085a388335e1" translate="yes" xml:space="preserve">
          <source>Source documentation is created by putting POD comments into the C source, like this:</source>
          <target state="translated">源码文档是通过将POD注释放入C源码中来创建的,比如这样。</target>
        </trans-unit>
        <trans-unit id="4e42a4c9cdabac1017a64b490d8e6fd830b2d27a" translate="yes" xml:space="preserve">
          <source>Source filtering is an immensely powerful feature of recent versions of Perl. It allows one to extend the language itself (e.g. the Switch module), to simplify the language (e.g. Language::Pythonesque), or to completely recast the language (e.g. Lingua::Romana::Perligata). Effectively, it allows one to use the full power of Perl as its own, recursively applied, macro language.</source>
          <target state="translated">源码过滤是Perl最新版本中一个非常强大的功能。它允许我们扩展语言本身(例如 Switch 模块),简化语言(例如 Language::Pythonesque),或者完全重构语言(例如 Lingua::Romana::Perligata)。实际上,它允许人们将Perl的全部功能作为自己的、递归应用的宏语言来使用。</target>
        </trans-unit>
        <trans-unit id="83fa9e2aac616eaf300f336da8ba4cb15a670bf8" translate="yes" xml:space="preserve">
          <source>Source filters activated within &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; leak out into whichever</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 激活的源过滤器泄漏到任何一个</target>
        </trans-unit>
        <trans-unit id="23c4984b5ea778bfe1a620b2921096dd64ef1a0a" translate="yes" xml:space="preserve">
          <source>Source filters only work on the string level, thus are highly limited in its ability to change source code on the fly. It cannot detect comments, quoted strings, heredocs, it is no replacement for a real parser. The only stable usage for source filters are encryption, compression, or the byteloader, to translate binary code back to source code.</source>
          <target state="translated">源码过滤器只在字符串层面上工作,因此在快速改变源代码的能力上受到很大的限制,它不能检测注释、引用的字符串、heredocs,它不能取代真正的解析器。它不能检测注释、引用的字符串、heredocs,它不能替代真正的解析器。源码过滤器唯一稳定的用途是加密、压缩,或者字节加载器,将二进制代码翻译回源代码。</target>
        </trans-unit>
        <trans-unit id="6cf561fd42e8003d80556309fdb07a79bace6a7b" translate="yes" xml:space="preserve">
          <source>Source of the ISO 639-2 codes.</source>
          <target state="translated">ISO 639-2编码的来源。</target>
        </trans-unit>
        <trans-unit id="178db77b6a3b9b6df2ef880ae7bdafacae37b3c6" translate="yes" xml:space="preserve">
          <source>Source of the ISO 639-5 codes.</source>
          <target state="translated">ISO 639-5编码的来源。</target>
        </trans-unit>
        <trans-unit id="b69498a9aee25a26e6f9b5b4bc9ecc63222abc92" translate="yes" xml:space="preserve">
          <source>SourceHandler</source>
          <target state="translated">SourceHandler</target>
        </trans-unit>
        <trans-unit id="8644212c6ba60e5d4b37bed3eca56024c125205f" translate="yes" xml:space="preserve">
          <source>SourceHandlers</source>
          <target state="translated">SourceHandlers</target>
        </trans-unit>
        <trans-unit id="2eb56be3c2d93cdab0c52e677e3167dfddb30ac5" translate="yes" xml:space="preserve">
          <source>Sources</source>
          <target state="translated">Sources</target>
        </trans-unit>
        <trans-unit id="0933c3d8de99d538b1745c97c9ac4e0808ab779e" translate="yes" xml:space="preserve">
          <source>Sources of further information</source>
          <target state="translated">进一步的资料来源</target>
        </trans-unit>
        <trans-unit id="b1ffb4c07982ffdd1d32da2ad256d5f400cca0af" translate="yes" xml:space="preserve">
          <source>South America</source>
          <target state="translated">南美</target>
        </trans-unit>
        <trans-unit id="f082fd9f31b253e1bc875b4f98b8b4196b3c96c9" translate="yes" xml:space="preserve">
          <source>Space after each comma.</source>
          <target state="translated">每个逗号后都有空格。</target>
        </trans-unit>
        <trans-unit id="b842d2b9fb013f376f25c0749d5ad88cdb3e09d2" translate="yes" xml:space="preserve">
          <source>Space after last parenthesis matching on current line.</source>
          <target state="translated">在当前行的最后一个小括号后留有空格。</target>
        </trans-unit>
        <trans-unit id="155b83258e151629b360ae86e49e0abf46f96413" translate="yes" xml:space="preserve">
          <source>Space around a &quot;complex&quot; subscript (inside brackets).</source>
          <target state="translated">在 &quot;复杂 &quot;的下标周围留出空间(括号内)。</target>
        </trans-unit>
        <trans-unit id="3f9d9d7fddff18fb290d25d4e2d47eb10b024565" translate="yes" xml:space="preserve">
          <source>Space around most operators.</source>
          <target state="translated">大多数运营商周围的空间。</target>
        </trans-unit>
        <trans-unit id="01ea9b6b043a2469906ded26f3a48de8eaf9e6e3" translate="yes" xml:space="preserve">
          <source>Space before the opening curly of a multi-line BLOCK.</source>
          <target state="translated">在多行BLOCK的开头大括号前的空格。</target>
        </trans-unit>
        <trans-unit id="1109418eced3ecb23f96484aec5504c863ea2053" translate="yes" xml:space="preserve">
          <source>Spaces in the argument delimit distinct patterns, so &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('*.exe *.dll')&lt;/code&gt; globs all filenames that end in &lt;code&gt;.exe&lt;/code&gt; or &lt;code&gt;.dll&lt;/code&gt;. If you want to put in literal spaces in the glob pattern, you can escape them with either double quotes, or backslashes. e.g. &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/&quot;Program Files&quot;/*/*.dll')&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/Program\ Files/*/*.dll')&lt;/code&gt; . The argument is tokenized using &lt;code&gt;Text::ParseWords::parse_line()&lt;/code&gt; , so see &lt;a href=&quot;../text/parsewords&quot;&gt;Text::ParseWords&lt;/a&gt; for details of the quoting rules used.</source>
          <target state="translated">参数中的空格分隔了不同的模式，因此 &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('*.exe *.dll')&lt;/code&gt; 会将以 &lt;code&gt;.exe&lt;/code&gt; 或 &lt;code&gt;.dll&lt;/code&gt; 结尾的所有文件名都作为glob。如果要在glob模式中放置文字空间，则可以使用双引号或反斜杠将其转义。例如 &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/&quot;Program Files&quot;/*/*.dll')&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/Program\ Files/*/*.dll')&lt;/code&gt; 。该参数使用 &lt;code&gt;Text::ParseWords::parse_line()&lt;/code&gt; 标记化，因此请参阅&lt;a href=&quot;../text/parsewords&quot;&gt;Text :: ParseWords&lt;/a&gt;以获取所用引号规则的详细信息。</target>
        </trans-unit>
        <trans-unit id="39b253a2d834caa9ad3a83fa215c9eabff3effb2" translate="yes" xml:space="preserve">
          <source>Speaking of debugging, there are several pragmas available to control and debug regexps in Perl. We have already encountered one pragma in the previous section, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval';&lt;/code&gt; , that allows variable interpolation and code expressions to coexist in a regexp. The other pragmas are</source>
          <target state="translated">说到调试，Perl中有几种编译控制可用于控制和调试正则表达式。在上一节中，我们已经遇到了一个 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval';&lt;/code&gt; ，请使用 re'eval'; ，它允许变量插值和代码表达式共存于正则表达式中。其他的语用是</target>
        </trans-unit>
        <trans-unit id="5cdd144975003eba8959b061eba84041ab9e203b" translate="yes" xml:space="preserve">
          <source>Speaking of the build directory. Do I have to clean it up myself?</source>
          <target state="translated">说到构建目录。我必须自己清理吗?</target>
        </trans-unit>
        <trans-unit id="cf16c389cb12320d4c2b7cc5db763c0d5676df4a" translate="yes" xml:space="preserve">
          <source>Speaking of things like &lt;code&gt;@{$AoA[$i]}&lt;/code&gt; , the following are actually the same thing:</source>
          <target state="translated">说到 &lt;code&gt;@{$AoA[$i]}&lt;/code&gt; 之类的东西，实际上是相同的：</target>
        </trans-unit>
        <trans-unit id="735223734da1211964b616a8067d85971e38faaf" translate="yes" xml:space="preserve">
          <source>Special &lt;code&gt;make test&lt;/code&gt; targets</source>
          <target state="translated">特殊 &lt;code&gt;make test&lt;/code&gt; 目标</target>
        </trans-unit>
        <trans-unit id="fdfdc56af4901b065f0b9e0022efafcd50dad6b5" translate="yes" xml:space="preserve">
          <source>Special Backtracking Control Verbs</source>
          <target state="translated">特殊回溯控制动词</target>
        </trans-unit>
        <trans-unit id="59f265692e8532f3f9f4cf8098a358d626fbb2eb" translate="yes" xml:space="preserve">
          <source>Special Cases</source>
          <target state="translated">特殊情况</target>
        </trans-unit>
        <trans-unit id="c09831be5235393e990f8ebc035a5453fef09355" translate="yes" xml:space="preserve">
          <source>Special Characters Inside a Bracketed Character Class</source>
          <target state="translated">括号内的特殊字符</target>
        </trans-unit>
        <trans-unit id="076a0893de022e884b65708a98aa1abe56ee52c6" translate="yes" xml:space="preserve">
          <source>Special Keys for &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 过载专用键</target>
        </trans-unit>
        <trans-unit id="f1bc7b98edc6763e9d6c0abf8b4fa80886e2046f" translate="yes" xml:space="preserve">
          <source>Special Keys for use overload</source>
          <target state="translated">过载使用的特殊键</target>
        </trans-unit>
        <trans-unit id="749ad8df41c6024cc71b56ff395f77ccf401c88e" translate="yes" xml:space="preserve">
          <source>Special Literals</source>
          <target state="translated">特殊文字</target>
        </trans-unit>
        <trans-unit id="d4cb1cbcc64290386b7c11a130ff81a51320cc9f" translate="yes" xml:space="preserve">
          <source>Special Patterns</source>
          <target state="translated">特殊模式</target>
        </trans-unit>
        <trans-unit id="f4d1e4b7e421f179bd6711768af6fd760a8db942" translate="yes" xml:space="preserve">
          <source>Special Topics</source>
          <target state="translated">专题</target>
        </trans-unit>
        <trans-unit id="93e61da05b321c91a757c91aeb83a231cf936002" translate="yes" xml:space="preserve">
          <source>Special behaviors for OS X</source>
          <target state="translated">OS X的特殊行为</target>
        </trans-unit>
        <trans-unit id="e0e39ed69d2c670390ee8a8802b8ef63f9291065" translate="yes" xml:space="preserve">
          <source>Special floating point: infinity (Inf) and not-a-number (NaN)</source>
          <target state="translated">特殊浮点数:无穷大(Inf)和非数(NaN)</target>
        </trans-unit>
        <trans-unit id="ca393fa33bfec26b8152f3f8b37c3b963f3cd851" translate="yes" xml:space="preserve">
          <source>Special make test targets</source>
          <target state="translated">特殊制造测试目标</target>
        </trans-unit>
        <trans-unit id="3bc242af481a6d0584675ca62d67c528336abb44" translate="yes" xml:space="preserve">
          <source>Special note should be made of the return values for a few properties:</source>
          <target state="translated">需要特别注意的是,有几个属性的返回值。</target>
        </trans-unit>
        <trans-unit id="b129e56f9be43046b321c79a90495916b0276970" translate="yes" xml:space="preserve">
          <source>Special package variables when using &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;, see &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;. Because of this specialness &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; don't need to be declared (using &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt;) even when using the &lt;code&gt;strict 'vars'&lt;/code&gt; pragma. Don't lexicalize them with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $b&lt;/code&gt; if you want to be able to use them in the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; comparison block or function.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 时的特殊包变量，请参见&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;。由于这种特殊性，即使使用 &lt;code&gt;strict 'vars'&lt;/code&gt; 编译指示，也无需声明 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; （使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt; ）。不要用lexicalize他们 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $a&lt;/code&gt; $一个或 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $b&lt;/code&gt; $ B，如果你希望能够在使用它们 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 的比较块或者函数。</target>
        </trans-unit>
        <trans-unit id="c400e57824d764b6a1f1b8ed067b982b5491dad3" translate="yes" xml:space="preserve">
          <source>Special regop that is used by &lt;code&gt;re_intuit_start()&lt;/code&gt; to check if a pattern can match at a certain position. For instance if the regex engine knows that the pattern must start with a 'Z' then it can scan the string until it finds one and then launch the regex engine from there. The routine that handles this is called &lt;code&gt;find_by_class()&lt;/code&gt; . Sometimes this field points at a regop embedded in the program, and sometimes it points at an independent synthetic regop that has been constructed by the optimiser.</source>
          <target state="translated">所使用的特殊regop &lt;code&gt;re_intuit_start()&lt;/code&gt; ，以检查是否一个图案可以在某一位置相匹配。例如，如果正则表达式引擎知道模式必须以'Z'开头，则它可以扫描字符串直到找到一个字符串，然后从那里启动正则表达式引擎。处理该问题的例程称为 &lt;code&gt;find_by_class()&lt;/code&gt; 。有时，该字段指向嵌入在程序中的一个规则的regop，有时指向一个由优化器构造的独立的合成regop。</target>
        </trans-unit>
        <trans-unit id="d7c69507b8821a1ac319bfe089337d432b752233" translate="yes" xml:space="preserve">
          <source>Special thanks to Craig Berry and Peter Prymmer (for VMS portability help), Randy Kobes (for Win32 portability help), Clinton Pierce and Autrijus Tang (for heroic eleventh-hour Win32 testing above and beyond the call of duty), Michael G Schwern (for testing advice), and the rest of the CPAN testers (for testing generally).</source>
          <target state="translated">特别感谢Craig Berry和Peter Prymmer(为VMS移植提供帮助),Randy Kobes(为Win32移植提供帮助),Clinton Pierce和Autrijus Tang(为Win32测试的第十一个小时的英勇表现提供帮助),Michael G Schwern(为测试提供建议),以及其他CPAN测试人员(为测试提供帮助)。</target>
        </trans-unit>
        <trans-unit id="5543458d832e80fa74fffef1fb3a6e0c964fd937" translate="yes" xml:space="preserve">
          <source>Special thanks to Jarkko Hietaniemi, the 5.8.0 pumpking, for including this module in the core and for his patient and helpful guidance during the integration process.</source>
          <target state="translated">特别感谢5.8.0 pumpking的Jarkko Hietaniemi,感谢他将这个模块纳入核心,并在集成过程中给予耐心和有益的指导。</target>
        </trans-unit>
        <trans-unit id="bdc349ae3de267bae2e06e8394305bd25b3d697e" translate="yes" xml:space="preserve">
          <source>Special thanks to Tels for suggesting several speed and memory optimizations.</source>
          <target state="translated">特别感谢Tels提出的多项速度和内存优化建议。</target>
        </trans-unit>
        <trans-unit id="58c72ff51f409e740d18b159d1db36db70f1453a" translate="yes" xml:space="preserve">
          <source>Special thanks to the following people who assisted in the creation of the document.</source>
          <target state="translated">特别感谢下列人员协助编写本文件:</target>
        </trans-unit>
        <trans-unit id="b9982eff3f0e28f25e92903f06ecf866a5e7dab5" translate="yes" xml:space="preserve">
          <source>Special variables that have side effects when you access them or assign to them. For example, in Perl, changing elements of the &lt;code&gt;%ENV&lt;/code&gt; array also changes the corresponding environment variables that subprocesses will use. Reading the &lt;code&gt;$!&lt;/code&gt; variable gives you the current system error number or message.</source>
          <target state="translated">访问或分配给它们时会产生副作用的特殊变量。例如，在Perl中，更改 &lt;code&gt;%ENV&lt;/code&gt; 数组的元素也会更改子流程将使用的相应环境变量。读 &lt;code&gt;$!&lt;/code&gt; 变量为您提供当前的系统错误号或消息。</target>
        </trans-unit>
        <trans-unit id="100bcda8aa4f874878478525651d3bbff5ff7492" translate="yes" xml:space="preserve">
          <source>Specialised Import Lists</source>
          <target state="translated">专业进口清单</target>
        </trans-unit>
        <trans-unit id="7b09828591f2a4848f0494348259138540610a11" translate="yes" xml:space="preserve">
          <source>Specific (mis)features of OS/2 port</source>
          <target state="translated">OS/2端口的具体(错误)特征</target>
        </trans-unit>
        <trans-unit id="f1dec8c277f6ad361d73048827b65d45acdb1217" translate="yes" xml:space="preserve">
          <source>Specific features of the Cygwin port</source>
          <target state="translated">Cygwin port的具体功能</target>
        </trans-unit>
        <trans-unit id="686482526f9ca64e951de751df199a7ac0b21959" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Gives the directory part of the location for</source>
          <target state="translated">专用于 EMX port。给予目录中的</target>
        </trans-unit>
        <trans-unit id="8719eacadd757c4d532ec01e84ca717f26242d45" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Should have the form</source>
          <target state="translated">EMX端口专用。应具有以下形式</target>
        </trans-unit>
        <trans-unit id="57a0519d586edded6d90f93d7b49b9ce56048c1e" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Since</source>
          <target state="translated">专门针对EMX端口。由于</target>
        </trans-unit>
        <trans-unit id="17684874cc7718b5fa207627bf38a956b3362a43" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Used as storage place for temporary files.</source>
          <target state="translated">EMX端口专用。用作临时文件的存放处。</target>
        </trans-unit>
        <trans-unit id="8ee5fb071a0f4fc5995dbb8fab061746ab818f7e" translate="yes" xml:space="preserve">
          <source>Specifically, we read pathnames one at a time from the input array, and store the results in an output array (results) in the same order. If statfs fails, the element pushed onto the return array is the value of errno after the failure. If statfs succeeds, though, the value pushed onto the return array is a reference to a hash containing some of the information in the statfs structure.</source>
          <target state="translated">具体来说,我们每次从输入数组中读取一个路径名,并以同样的顺序将结果存储在输出数组(results)中。如果 statfs 失败,推送到返回数组中的元素是失败后的 errno 值。但如果 statfs 成功了,推送到返回数组上的值是对包含 statfs 结构中一些信息的哈希的引用。</target>
        </trans-unit>
        <trans-unit id="eda3fdece3884b319c275582d4e0949e974b3c68" translate="yes" xml:space="preserve">
          <source>Specifically: Turning on this option will disable the heuristics for seeing only files with Perl-like extensions, omitting subdirectories that are numeric but do</source>
          <target state="translated">具体来说。开启这个选项将禁用启发式功能,只看到带有类似Perl扩展名的文件,省略那些有数字的子目录,但确实是</target>
        </trans-unit>
        <trans-unit id="ed81a4faa05daf1c1be51b7b8fa82d019bf30684" translate="yes" xml:space="preserve">
          <source>Specification for CPAN distribution metadata</source>
          <target state="translated">CPAN分销元数据规范</target>
        </trans-unit>
        <trans-unit id="73a4072f8995fd4faf63509594cc45d51dcda62a" translate="yes" xml:space="preserve">
          <source>Specified line by line via &lt;b&gt;-e&lt;/b&gt; or &lt;b&gt;-E&lt;/b&gt; switches on the command line.</source>
          <target state="translated">通过&lt;b&gt;-e&lt;/b&gt;或&lt;b&gt;-E&lt;/b&gt;在命令行上逐行指定。</target>
        </trans-unit>
        <trans-unit id="acc937be340e9018f067e36d4fbe600f0ca7a48d" translate="yes" xml:space="preserve">
          <source>Specifies a TAP::Harness subclass to be used in place of TAP::Harness.</source>
          <target state="translated">指定一个 TAP::Harness 子类来代替 TAP::Harness。</target>
        </trans-unit>
        <trans-unit id="2ccb38b1ea1946cfb54e7b524ba85568b166e308" translate="yes" xml:space="preserve">
          <source>Specifies a name to be used for the extension, e.g., -n RPC::DCE</source>
          <target state="translated">指定用于扩展的名称,例如,-n RPC::DCE。</target>
        </trans-unit>
        <trans-unit id="fb10437a9b9ee94fe2ef27d29d4fd6290157541f" translate="yes" xml:space="preserve">
          <source>Specifies an encoding to store lexicon entries, instead of utf8-strings. If set to &lt;code&gt;locale&lt;/code&gt; , the encoding from the current locale setting is used. Implies a true value for &lt;code&gt;Decode&lt;/code&gt; .</source>
          <target state="translated">指定用于存储词典条目的编码，而不是utf8字符串。如果设置为 &lt;code&gt;locale&lt;/code&gt; ，则使用来自当前语言环境设置的编码。表示 &lt;code&gt;Decode&lt;/code&gt; 为真值。</target>
        </trans-unit>
        <trans-unit id="5288f1281b330410c08afae34819d7cfc53b87f4" translate="yes" xml:space="preserve">
          <source>Specifies any additional arguments to pass to the compiler. Should be given as a list reference containing the arguments individually, or if this is not possible, as a string containing all the arguments together.</source>
          <target state="translated">指定要传递给编译器的任何附加参数。应该以包含各个参数的列表引用的形式给出,如果无法做到,则以包含所有参数的字符串形式给出。</target>
        </trans-unit>
        <trans-unit id="8c0fc5c465acc07c545f1645a7b4737064b57885" translate="yes" xml:space="preserve">
          <source>Specifies any additional directories in which to search for header files. May be given as a string indicating a single directory, or as a list reference indicating multiple directories.</source>
          <target state="translated">指定要搜索头文件的任何附加目录。可以用字符串表示单个目录,也可以用列表引用表示多个目录。</target>
        </trans-unit>
        <trans-unit id="df5f877cdfce163f364b76c3bfab4e6c5095d6d8" translate="yes" xml:space="preserve">
          <source>Specifies file structure for file to be transferred.</source>
          <target state="translated">指定要传输的文件结构。</target>
        </trans-unit>
        <trans-unit id="087e5ef636ea46b335e961f7299045a135d4c08f" translate="yes" xml:space="preserve">
          <source>Specifies how much effort bzip2 should take before resorting to a slower fallback compression algorithm.</source>
          <target state="translated">指定在采用较慢的回退压缩算法之前,bzip2 应该付出多少努力。</target>
        </trans-unit>
        <trans-unit id="98ed6b009cf98007a6f6d9bd7e33d610c98ad8ec" translate="yes" xml:space="preserve">
          <source>Specifies one or more directories to search for the input file if it was not supplied with an absolute path. Each directory path in the given list should be separated by a ':' on Unix (';' on MSWin32 and DOS).</source>
          <target state="translated">如果没有提供绝对路径,指定一个或多个目录来搜索输入文件。在给定列表中的每个目录路径在Unix上应该用':'来分隔(在MSWin32和DOS上用';')。</target>
        </trans-unit>
        <trans-unit id="1b9774b42720c2ff28dbc21e628ebcd3703ef058" translate="yes" xml:space="preserve">
          <source>Specifies that the source file is a C++ source file and sets appropriate compiler flags</source>
          <target state="translated">指定源文件是C++源文件,并设置相应的编译器标志。</target>
        </trans-unit>
        <trans-unit id="752f5b793296a2436f0f638671fc26add2789004" translate="yes" xml:space="preserve">
          <source>Specifies that this distribution shall not be processed at all.</source>
          <target state="translated">指明本次发行完全不做处理。</target>
        </trans-unit>
        <trans-unit id="27c19b2359d6f4ac0335e1401df42879661c8cd1" translate="yes" xml:space="preserve">
          <source>Specifies the directory to use for the temporary directory. The temporary directory name is derived from an internal template.</source>
          <target state="translated">指定临时目录使用的目录。临时目录名称由内部模板导出。</target>
        </trans-unit>
        <trans-unit id="69c1bcd4ebd70c8615309d5b9b715199cd57859f" translate="yes" xml:space="preserve">
          <source>Specifies the encoding you are converting from. Unlike &lt;b&gt;iconv&lt;/b&gt;, this option can be omitted. In such cases, the current locale is used.</source>
          <target state="translated">指定要转换的编码。与&lt;b&gt;iconv&lt;/b&gt;不同，此选项可以省略。在这种情况下，将使用当前语言环境。</target>
        </trans-unit>
        <trans-unit id="b6aabb58f01ed0bc266ebcb530fd5e3060867e4c" translate="yes" xml:space="preserve">
          <source>Specifies the encoding you are converting to. Unlike &lt;b&gt;iconv&lt;/b&gt;, this option can be omitted. In such cases, the current locale is used.</source>
          <target state="translated">指定要转换为的编码。与&lt;b&gt;iconv&lt;/b&gt;不同，此选项可以省略。在这种情况下，将使用当前语言环境。</target>
        </trans-unit>
        <trans-unit id="bc14cf57cc1d526c9df38cf39a2a5e11891e51ad" translate="yes" xml:space="preserve">
          <source>Specifies the extension of the module's loadable object. For example:</source>
          <target state="translated">指定模块的可加载对象的扩展。例如:</target>
        </trans-unit>
        <trans-unit id="62350db256aee74b2119a37a32d38d1a559bd3c6" translate="yes" xml:space="preserve">
          <source>Specifies the method or subroutine to use when printing error messages about POD syntax. The supplied method/subroutine</source>
          <target state="translated">指定打印POD语法错误信息时要使用的方法或子程序。提供的方法/子程序</target>
        </trans-unit>
        <trans-unit id="8490adfe21694bc6560acb4c4b017183f5259a5a" translate="yes" xml:space="preserve">
          <source>Specifies the name of the Perl module that will be created by linking. On platforms that need to do prelinking (Win32, OS/2, etc.) this is a required parameter.</source>
          <target state="translated">指定将通过链接创建的Perl模块的名称。在需要进行预链接的平台上(Win32、OS/2等),这是一个必须的参数。</target>
        </trans-unit>
        <trans-unit id="f6fab30529e40665f8d0178ef7752b76fb583aec" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output executable file to create. Otherwise the &lt;code&gt;exe_file()&lt;/code&gt; method will be consulted, passing it the name of the first entry in &lt;code&gt;objects&lt;/code&gt; .</source>
          <target state="translated">指定要创建的输出可执行文件的名称。否则，将 &lt;code&gt;exe_file()&lt;/code&gt; 方法，并向其传递 &lt;code&gt;objects&lt;/code&gt; 第一个条目的名称。</target>
        </trans-unit>
        <trans-unit id="712c7b0a7198fb19bf2fcbbf1b68671ab3789d42" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output file to create. Otherwise the &lt;code&gt;object_file()&lt;/code&gt; method will be consulted, passing it the name of the &lt;code&gt;source&lt;/code&gt; file.</source>
          <target state="translated">指定要创建的输出文件的名称。否则，将 &lt;code&gt;object_file()&lt;/code&gt; 方法，并向其传递 &lt;code&gt;source&lt;/code&gt; 文件的名称。</target>
        </trans-unit>
        <trans-unit id="0ea5fb9dc13c7dfd946c4f0ec1f502d959136293" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output file to generate. If no file is specified, output will be written to standard output.</source>
          <target state="translated">指定要生成的输出文件的名称,如果没有指定文件,输出将写入标准输出。如果没有指定文件,输出将被写入标准输出。</target>
        </trans-unit>
        <trans-unit id="95eb37279bd4905df986dc0709bc7910f0b3037c" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output library file to create. Otherwise the &lt;code&gt;lib_file()&lt;/code&gt; method will be consulted, passing it the name of the first entry in &lt;code&gt;objects&lt;/code&gt; .</source>
          <target state="translated">指定要创建的输出库文件的名称。否则，将 &lt;code&gt;lib_file()&lt;/code&gt; 方法，并向其传递 &lt;code&gt;objects&lt;/code&gt; 第一个条目的名称。</target>
        </trans-unit>
        <trans-unit id="9fc8b469ff5b98736322a31c19a8ffad03de9557" translate="yes" xml:space="preserve">
          <source>Specifies the string that will be prefixed to every line of the output. Empty string by default.</source>
          <target state="translated">指定输出的每行前缀的字符串。默认为空字符串。</target>
        </trans-unit>
        <trans-unit id="969aa343df55e9a403d592d5b7e666d694e7c272" translate="yes" xml:space="preserve">
          <source>Specifies transfer mode (stream, block or compressed) for file to be transferred.</source>
          <target state="translated">指定要传输的文件的传输模式(流、块或压缩)。</target>
        </trans-unit>
        <trans-unit id="9e50a3555457e006ff9201a0e994fbe18d143981" translate="yes" xml:space="preserve">
          <source>Specify Perl version requirements with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">指定用Perl版本要求 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a389cd0788a594b00d81ac38b0d5b58f982bb23" translate="yes" xml:space="preserve">
          <source>Specify a collation strength of level 1 to ignore case and diacritics, only looking at the basic character.</source>
          <target state="translated">指定1级的整理强度,忽略大小写和双拼,只看基本字符。</target>
        </trans-unit>
        <trans-unit id="fd9decfe42c6333527f5da43637561403cd51753" translate="yes" xml:space="preserve">
          <source>Specify a prefix which should be removed from the Perl function names, e.g., -p sec_rgy_ This sets up the XS &lt;b&gt;PREFIX&lt;/b&gt; keyword and removes the prefix from functions that are autoloaded via the &lt;code&gt;constant()&lt;/code&gt; mechanism.</source>
          <target state="translated">指定应从Perl函数名称中删除的前缀，例如-p sec_rgy_。这将设置XS &lt;b&gt;PREFIX&lt;/b&gt;关键字，并从通过 &lt;code&gt;constant()&lt;/code&gt; 机制自动加载的函数中删除该前缀。</target>
        </trans-unit>
        <trans-unit id="8c37cb69f6acc79919a59db7bb047596246ded37" translate="yes" xml:space="preserve">
          <source>Specify a section to include in the output. See &lt;a href=&quot;pod/parser#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS in Pod::Parser&lt;/a&gt; for the format to use for</source>
          <target state="translated">指定要包含在输出中的部分。请参阅&lt;a href=&quot;pod/parser#SECTION-SPECIFICATIONS&quot;&gt;Pod :: Parser&lt;/a&gt;中的SECTION SPECIFICATIONS，以了解用于</target>
        </trans-unit>
        <trans-unit id="c842e0100e27043e97262bc2a56a8695e0228b4b" translate="yes" xml:space="preserve">
          <source>Specify a version number for this extension. This version number is added to the templates. The default is 0.01, or 0.00_01 if &lt;code&gt;-B&lt;/code&gt; is specified. The version specified should be numeric.</source>
          <target state="translated">指定此扩展的版本号。该版本号已添加到模板中。缺省值为0.01，如果指定 &lt;code&gt;-B&lt;/code&gt; ，则为0.00_01 。指定的版本应为数字。</target>
        </trans-unit>
        <trans-unit id="e7f58f2c2dcff1260c061c4b22f076c9afef1f52" translate="yes" xml:space="preserve">
          <source>Specify content is binary</source>
          <target state="translated">指定内容为二进制</target>
        </trans-unit>
        <trans-unit id="196ff6b62a23b7ba506c7490495c47cea5d35955" translate="yes" xml:space="preserve">
          <source>Specify in seconds how long to run the command before it is killed with SIG_KILL (9), which effectively terminates it and all of its children (direct or indirect).</source>
          <target state="translated">以秒为单位,指定运行命令的时间,然后用SIG_KILL (9)杀死命令,从而有效地终止该命令及其所有子命令(直接或间接)。</target>
        </trans-unit>
        <trans-unit id="e42f9f14e720a274b615a5fad1a17e292745c606" translate="yes" xml:space="preserve">
          <source>Specify pre-requisites in Makefile.PL or Build.PL</source>
          <target state="translated">在Makefile.PL或Build.PL中指定先决条件。</target>
        </trans-unit>
        <trans-unit id="1a3e3b8941c020b4dead165334a6a7f6f39e0c5c" translate="yes" xml:space="preserve">
          <source>Specify replacement for groff</source>
          <target state="translated">指定更换groff</target>
        </trans-unit>
        <trans-unit id="82792121ccf914c52ccf31c689a51331bdf9896b" translate="yes" xml:space="preserve">
          <source>Specify some text that will be passed into the &lt;code&gt;STDIN&lt;/code&gt; of the executed program.</source>
          <target state="translated">指定一些将传递到已执行程序的 &lt;code&gt;STDIN&lt;/code&gt; 中的文本。</target>
        </trans-unit>
        <trans-unit id="e4f8120097eb5801ad49966dad7112d6c8bcad54" translate="yes" xml:space="preserve">
          <source>Specify stream encoding. This is the normal way to deal with encoded text, not by calling low-level functions.</source>
          <target state="translated">指定流编码。这是处理编码文本的正常方式,而不是通过调用低级函数。</target>
        </trans-unit>
        <trans-unit id="8473cee86e4b03ee43a6c19c0f0dc45619e13394" translate="yes" xml:space="preserve">
          <source>Specify the HTML file to create. Output goes to STDOUT if no outfile is specified.</source>
          <target state="translated">指定要创建的HTML文件。如果没有指定输出文件,则输出到STDOUT。</target>
        </trans-unit>
        <trans-unit id="2deadb9e68c32c96f8a837b13d5dc23a9778d417" translate="yes" xml:space="preserve">
          <source>Specify the URL of a cascading style sheet. Also disables all HTML/CSS &lt;code&gt;style&lt;/code&gt; attributes that are output by default (to avoid conflicts).</source>
          <target state="translated">指定级联样式表的URL。还禁用默认情况下输出的所有HTML / CSS &lt;code&gt;style&lt;/code&gt; 属性（以避免冲突）。</target>
        </trans-unit>
        <trans-unit id="4aa99f54409387b7146f47653777c920418ff10b" translate="yes" xml:space="preserve">
          <source>Specify the URL of cascading style sheet to link from resulting HTML file. Default is none style sheet.</source>
          <target state="translated">指定从HTML文件中链接的层叠样式表的URL。默认为无样式表。</target>
        </trans-unit>
        <trans-unit id="9afcf7f83edb719a030bfbfd6d7f5c91cf7f8d6b" translate="yes" xml:space="preserve">
          <source>Specify the base directory for finding library pods.</source>
          <target state="translated">指定用于查找库荚的基础目录。</target>
        </trans-unit>
        <trans-unit id="44291a4ec495223a1da4f1839ae4e831f5a3c791" translate="yes" xml:space="preserve">
          <source>Specify the base directory for finding library pods. Default is the current working directory.</source>
          <target state="translated">指定用于查找库荚的基础目录。默认为当前工作目录。</target>
        </trans-unit>
        <trans-unit id="bc5534a64aa32340e65ed43e45968b60d705f9fc" translate="yes" xml:space="preserve">
          <source>Specify the internal type that the constant() mechanism uses for macros. The default is IV (signed integer). Currently all macros found during the header scanning process will be assumed to have this type. Future versions of &lt;code&gt;h2xs&lt;/code&gt; may gain the ability to make educated guesses.</source>
          <target state="translated">指定constant（）机制用于宏的内部类型。默认值为IV（有符号整数）。当前，将假定在标头扫描过程中找到的所有宏都具有此类型。将来的 &lt;code&gt;h2xs&lt;/code&gt; 版本可能会进行有根据的猜测。</target>
        </trans-unit>
        <trans-unit id="a20b2619004bea1e14f0e7f2949d240b1952dd51" translate="yes" xml:space="preserve">
          <source>Specify the number of 100K blocks bzip2 uses during compression.</source>
          <target state="translated">指定bzip2在压缩过程中使用的100K块数。</target>
        </trans-unit>
        <trans-unit id="1d869ecbc9c626d4a96da51d8e392c8fcdb22cdc" translate="yes" xml:space="preserve">
          <source>Specify the pod file to convert. Input is taken from STDIN if no infile is specified.</source>
          <target state="translated">指定要转换的 pod 文件。如果没有指定infile,则从STDIN输入。</target>
        </trans-unit>
        <trans-unit id="2bed91a5a620b4aae10dcfd8cbca6e35a0ef51dd" translate="yes" xml:space="preserve">
          <source>Specify the targets for testing.</source>
          <target state="translated">指定测试的目标。</target>
        </trans-unit>
        <trans-unit id="21bb885000d067ff7c549508e4dd3407f52920a2" translate="yes" xml:space="preserve">
          <source>Specify the title of the resulting HTML file.</source>
          <target state="translated">指定生成的HTML文件的标题。</target>
        </trans-unit>
        <trans-unit id="46f23c724776424563c656a058b3155bcce7e71b" translate="yes" xml:space="preserve">
          <source>Specify version requirements for other Perl modules in the pre-requisites in your Makefile.PL or Build.PL.</source>
          <target state="translated">在你的Makefile.PL或Build.PL的前置条件中指定其他Perl模块的版本要求。</target>
        </trans-unit>
        <trans-unit id="8bd129aeb5d58a2d4cd81a32d015c916c4dfff29" translate="yes" xml:space="preserve">
          <source>Specify which directory is used for storing cache. Default directory is the current working directory.</source>
          <target state="translated">指定用于存储缓存的目录。默认目录为当前工作目录。</target>
        </trans-unit>
        <trans-unit id="c06413cd34d05ffad8b760e0ccbb2a8039560c0e" translate="yes" xml:space="preserve">
          <source>Specify which subdirectories of the podroot contain pod files whose HTML converted forms can be linked to in cross references.</source>
          <target state="translated">指定podroot的哪些子目录包含pod文件,其HTML转换后的表单可以链接到交叉引用中。</target>
        </trans-unit>
        <trans-unit id="4ed9289cec9db507a9bd1e2cf8a443192d39f482" translate="yes" xml:space="preserve">
          <source>Specify which subdirectories of the podroot contain pod files whose HTML converted forms can be linked-to in cross-references.</source>
          <target state="translated">指定podroot的哪些子目录包含pod文件,其HTML转换后的表单可以在交叉引用中被链接到。</target>
        </trans-unit>
        <trans-unit id="cda870361643b1e3b5ceca1a143c1054b6477609" translate="yes" xml:space="preserve">
          <source>Specifying VERSION as a literal of the form v5.6.1 should generally be avoided, because it leads to misleading error messages under earlier versions of Perl (that is, prior to 5.6.0) that do not support this syntax. The equivalent numeric version should be used instead.</source>
          <target state="translated">一般来说,应该避免将 VERSION 指定为 v5.6.1 这种形式的文字,因为在不支持这种语法的早期 Perl 版本(即 5.6.0 之前的版本)下,它会导致误导性的错误信息。应该使用等价的数字版本。</target>
        </trans-unit>
        <trans-unit id="4cc4c6ab0a0e40b55ad8e487edeab38628dd47f2" translate="yes" xml:space="preserve">
          <source>Specifying VERSION as a literal of the form v5.6.1 should generally be avoided, because it leads to misleading error messages under earlier versions of Perl that do not support this syntax. The equivalent numeric version should be used instead.</source>
          <target state="translated">一般来说,应该避免将 VERSION 指定为 v5.6.1 这种形式的文字,因为在不支持这种语法的早期 Perl 版本中,它会导致误导性的错误信息。应该使用等价的数字版本来代替。</target>
        </trans-unit>
        <trans-unit id="105a66a84ae1308320a2e6185af2d7c0f4640974" translate="yes" xml:space="preserve">
          <source>Specifying Values</source>
          <target state="translated">指定值</target>
        </trans-unit>
        <trans-unit id="6ddacaf845437713514dee82096d8d2996a0782a" translate="yes" xml:space="preserve">
          <source>Specifying a compatibility version higher than the version of perl you are using to run h2xs will have no effect. If unspecified h2xs will default to compatibility with the version of perl you are using to run h2xs.</source>
          <target state="translated">指定比运行h2xs所使用的perl版本更高的兼容性版本将不会有任何影响,如果没有指定,h2xs将默认与运行h2xs的perl版本兼容。如果没有指定,h2xs将默认为与运行h2xs的perl版本兼容。</target>
        </trans-unit>
        <trans-unit id="b9ac38be3885e820db907e52feea151509c97c14" translate="yes" xml:space="preserve">
          <source>Specifying a negative flag after the caret is an error, as the flag is redundant.</source>
          <target state="translated">在转折号后指定一个负标志是错误的,因为这个标志是多余的。</target>
        </trans-unit>
        <trans-unit id="fcb93594508dd14f6f183606eef58af67f897bab" translate="yes" xml:space="preserve">
          <source>Specifying a negative index position greater than the number of items in the queue adds the list to the head of the queue.</source>
          <target state="translated">指定一个大于队列中项目数的负指数位置,将列表添加到队列的头部。</target>
        </trans-unit>
        <trans-unit id="90e80e764794a3f53d9bd22d3f4959b3c3e8e8c0" translate="yes" xml:space="preserve">
          <source>Specifying an index position greater than the number of items in the queue just adds the list to the end.</source>
          <target state="translated">指定的索引位置大于队列中的项目数,只是将列表添加到最后。</target>
        </trans-unit>
        <trans-unit id="9c224eb1496ab5698ab91d2a22838e04eaf02d0d" translate="yes" xml:space="preserve">
          <source>Specifying an index position greater than the number of items in the queue results in &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or an empty list being returned.</source>
          <target state="translated">如果指定的索引位置大于队列中的项目数，则会导致 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或返回空列表。</target>
        </trans-unit>
        <trans-unit id="8b369061e994be9b95b9b52fd041d04e9eccbbae" translate="yes" xml:space="preserve">
          <source>Specifying sub-versions such as the &lt;code&gt;0&lt;/code&gt; in &lt;code&gt;5.14.0&lt;/code&gt; in feature bundles has no effect. Feature bundles are guaranteed to be the same for all sub-versions.</source>
          <target state="translated">指定子版本，如在 &lt;code&gt;0&lt;/code&gt; 在 &lt;code&gt;5.14.0&lt;/code&gt; 中特征束不起作用。保证所有子版本的功能包都相同。</target>
        </trans-unit>
        <trans-unit id="79a6f96c957e7feef1314dc46564cc00f5833bc6" translate="yes" xml:space="preserve">
          <source>Specifying the &quot;udp&quot; protocol causes the ping() method to send a udp packet to the remote host's echo port. If the echoed packet is received from the remote host and the received packet contains the same data as the packet that was sent, the remote host is considered reachable. This protocol does not require any special privileges. It should be borne in mind that, for a udp ping, a host will be reported as unreachable if it is not running the appropriate echo service. For Unix-like systems see</source>
          <target state="translated">指定 &quot;udp &quot;协议会使ping()方法向远程主机的echo端口发送一个udp数据包。如果从远程主机接收到回声数据包,并且接收到的数据包包含的数据与发送的数据包相同,则认为远程主机是可到达的。这个协议不需要任何特殊的权限。需要注意的是,对于udp ping来说,如果主机没有运行适当的echo服务,则会被报告为不可到达。对于类似Unix的系统,请参见</target>
        </trans-unit>
        <trans-unit id="2819720e6a0b64709090cd36c99161c9c51d2535" translate="yes" xml:space="preserve">
          <source>Specifying the G_DISCARD flag with</source>
          <target state="translated">在指定G_DISCARD标志的时候,用</target>
        </trans-unit>
        <trans-unit id="2d2cb022bc3d26bd1407c4aa787d5e46e1ad4c3b" translate="yes" xml:space="preserve">
          <source>Speed</source>
          <target state="translated">Speed</target>
        </trans-unit>
        <trans-unit id="40e5809be52d66c56af4f3807fbc74465fe77f2b" translate="yes" xml:space="preserve">
          <source>Spherical coordinates,</source>
          <target state="translated">球面坐标:</target>
        </trans-unit>
        <trans-unit id="0bce309883c4786c8f96950f6206dff26186fc2b" translate="yes" xml:space="preserve">
          <source>Split a directory specification into the components.</source>
          <target state="translated">将一个目录规范分割成各个组件。</target>
        </trans-unit>
        <trans-unit id="0e9eed69886886b90fb3afa01fba40f13ff4d0a7" translate="yes" xml:space="preserve">
          <source>Split a package for autoloading</source>
          <target state="translated">分割一个包以便自动加载</target>
        </trans-unit>
        <trans-unit id="0a230284c2746978c6d208e00f352e0d6fb5d918" translate="yes" xml:space="preserve">
          <source>Split out from Safe module version 1, named opcode tags and other changes added by Tim Bunce.</source>
          <target state="translated">从Safe模块第1版中拆分出来,命名为opcode标签,并由Tim Bunce添加了其他改动。</target>
        </trans-unit>
        <trans-unit id="273ddbe310d23df41c94915a842b407f242c4749" translate="yes" xml:space="preserve">
          <source>Splits a path in to volume, directory, and filename portions. On systems with no concept of volume, returns '' for volume.</source>
          <target state="translated">将一个路径分割成卷、目录和文件名的部分。在没有卷的概念的系统中,返回''表示卷。</target>
        </trans-unit>
        <trans-unit id="334895ed21abe595a625b2f1658f99e01bbe8d40" translate="yes" xml:space="preserve">
          <source>Splits a path into volume, directory, and filename portions.</source>
          <target state="translated">将一个路径分割成卷、目录和文件名的部分。</target>
        </trans-unit>
        <trans-unit id="9683042273a4ecd00e523d0bde1551fc4f8c1380" translate="yes" xml:space="preserve">
          <source>Splits a path into volume, directory, and filename portions. Assumes that the last file is a path unless the path ends in '\\', '\\.', '\\..' or $no_file is true. On Win32 this means that $no_file true makes this return ( $volume, $path, '' ).</source>
          <target state="translated">将一个路径分割成卷、目录和文件名的部分。假设最后一个文件是一个路径,除非路径以'\\','\\','\\...'结尾或者$no_file为真。在Win32中,这意味着$no_file为真会返回($volume,$path,'')。</target>
        </trans-unit>
        <trans-unit id="86fed3cc24e2d19645e7064b9a14b47a5f182fe6" translate="yes" xml:space="preserve">
          <source>Splits a path into volume, directory, and filename portions. On systems with no concept of volume, returns '' for volume.</source>
          <target state="translated">将一个路径分割成卷、目录和文件名的部分。在没有volume概念的系统中,返回''表示volume。</target>
        </trans-unit>
        <trans-unit id="5d39c4c6b066b235387ae82c04d47c7856f6398b" translate="yes" xml:space="preserve">
          <source>Splits the string EXPR into a list of strings and returns the list in list context, or the size of the list in scalar context.</source>
          <target state="translated">将字符串EXPR分割成一个字符串列表,并在列表上下文中返回列表,或者在标量上下文中返回列表的大小。</target>
        </trans-unit>
        <trans-unit id="250f996321b0ccf8a0a091d8ad8d1f0defcbee6b" translate="yes" xml:space="preserve">
          <source>Splitting up a program text into &lt;b&gt;tokens&lt;/b&gt;. Also known as &amp;ldquo;lexing&amp;rdquo;, in which case you get &amp;ldquo;lexemes&amp;rdquo; instead of tokens.</source>
          <target state="translated">将程序文本拆分为&lt;b&gt;令牌&lt;/b&gt;。也称为&amp;ldquo;词法&amp;rdquo;，在这种情况下，您将获得&amp;ldquo;词法&amp;rdquo;而不是标记。</target>
        </trans-unit>
        <trans-unit id="785ca9526809c90e3417966be7d5844fd2a0c5c8" translate="yes" xml:space="preserve">
          <source>Stability</source>
          <target state="translated">Stability</target>
        </trans-unit>
        <trans-unit id="699cbcfa1d2de31b511ffab2c2a0ef9730993e7e" translate="yes" xml:space="preserve">
          <source>Stable CPAN modules</source>
          <target state="translated">稳定的CPAN模块</target>
        </trans-unit>
        <trans-unit id="0c37e4671699616f1b661a8adda9cc25f7e7c380" translate="yes" xml:space="preserve">
          <source>Stable modules should maintain backwards compatibility</source>
          <target state="translated">稳定的模块应保持向后兼容性</target>
        </trans-unit>
        <trans-unit id="e59f32f5132f95bd8522cf0423d93b2b074371e3" translate="yes" xml:space="preserve">
          <source>Stack Manipulation Macros</source>
          <target state="translated">堆栈操作宏</target>
        </trans-unit>
        <trans-unit id="d3f19bccf79868f3c579b95c4b4aa5c3173cdfc2" translate="yes" xml:space="preserve">
          <source>Stack Overflow is a free question-and-answer site for programmers. It's not focussed solely on Perl, but it does have an active group of users who do their best to help people with their Perl programming questions.</source>
          <target state="translated">Stack Overflow是一个面向程序员的免费问答网站。它并不只专注于Perl,但它有一个活跃的用户群,他们会尽力帮助人们解决Perl编程问题。</target>
        </trans-unit>
        <trans-unit id="79c0915aad1c8e4662635799d017c78213056099" translate="yes" xml:space="preserve">
          <source>Stack Trace formatting</source>
          <target state="translated">堆栈跟踪格式化</target>
        </trans-unit>
        <trans-unit id="c32c5432806926c51af3a6d722094d1b8498ee67" translate="yes" xml:space="preserve">
          <source>Stack marker variable for the XSUB. See &lt;code&gt;dMARK&lt;/code&gt; .</source>
          <target state="translated">XSUB的堆栈标记变量。参见 &lt;code&gt;dMARK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abb5c52ccc52723cd1612e07bb13d70407d8e476" translate="yes" xml:space="preserve">
          <source>Stack pointer. This is usually handled by &lt;code&gt;xsubpp&lt;/code&gt; . See &lt;code&gt;dSP&lt;/code&gt; and &lt;code&gt;SPAGAIN&lt;/code&gt; .</source>
          <target state="translated">堆栈指针。通常由 &lt;code&gt;xsubpp&lt;/code&gt; 处理。请参阅 &lt;code&gt;dSP&lt;/code&gt; 和 &lt;code&gt;SPAGAIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7eeeffb91b556017b0569617dac90bb982af82c6" translate="yes" xml:space="preserve">
          <source>Stack size discussion: &lt;a href=&quot;http://www.perlmonks.org/?node_id=532956&quot;&gt;http://www.perlmonks.org/?node_id=532956&lt;/a&gt;</source>
          <target state="translated">堆栈大小讨论：&lt;a href=&quot;http://www.perlmonks.org/?node_id=532956&quot;&gt;http&lt;/a&gt; ://www.perlmonks.org/?node_id= 532956</target>
        </trans-unit>
        <trans-unit id="5972ab200f32099d27f68650121e9738cdd0e0dc" translate="yes" xml:space="preserve">
          <source>Standard Exports</source>
          <target state="translated">标准出口</target>
        </trans-unit>
        <trans-unit id="615e5b98a32ea52bb60f7df7a2666749db3e59ab" translate="yes" xml:space="preserve">
          <source>Standard I/O functions via VMS extensions</source>
          <target state="translated">通过VMS扩展的标准I/O功能</target>
        </trans-unit>
        <trans-unit id="fbc014247a90e3e9471cd43027f6ed1dd5022323" translate="yes" xml:space="preserve">
          <source>Standard Modules</source>
          <target state="translated">标准模块</target>
        </trans-unit>
        <trans-unit id="fcb1fc559ce28778664dae993a8bd3c9c1e13c04" translate="yes" xml:space="preserve">
          <source>Standard codes for country identification</source>
          <target state="translated">国家识别的标准代码</target>
        </trans-unit>
        <trans-unit id="60f2260734e540712fc0b3a84eed77018b10ca66" translate="yes" xml:space="preserve">
          <source>Standard codes for currency identification</source>
          <target state="translated">货币识别的标准代码</target>
        </trans-unit>
        <trans-unit id="b5deda2e5280ead9cecc60bbf30d177abf9ec4ea" translate="yes" xml:space="preserve">
          <source>Standard codes for language extension identification</source>
          <target state="translated">语文扩展标识的标准代码</target>
        </trans-unit>
        <trans-unit id="f2ee3631bc2f34f1c73413a9d2061ce03c5ab44f" translate="yes" xml:space="preserve">
          <source>Standard codes for language identification</source>
          <target state="translated">语文识别标准代码</target>
        </trans-unit>
        <trans-unit id="10a16afeaf36afe90baa03b4e90894540cc06be0" translate="yes" xml:space="preserve">
          <source>Standard codes for language variation identification</source>
          <target state="translated">语文差异识别的标准代码</target>
        </trans-unit>
        <trans-unit id="b1589d1520251236f9eb362681e4874ce8c5e9ee" translate="yes" xml:space="preserve">
          <source>Standard codes for script identification</source>
          <target state="translated">脚本识别的标准代码</target>
        </trans-unit>
        <trans-unit id="5d6d11511a070bcf17fa4eb2391ebf6e7a493c05" translate="yes" xml:space="preserve">
          <source>Standard modules with VMS-specific differences</source>
          <target state="translated">标准模块与VMS特有的差异</target>
        </trans-unit>
        <trans-unit id="de92c20ac3781f514b3f3e2c2c6d7cf3cd1b6af8" translate="yes" xml:space="preserve">
          <source>Standard, bundled modules are all expected to behave in a well-defined manner with respect to namespace pollution because they use the Exporter module. See their own documentation for details.</source>
          <target state="translated">标准的、捆绑的模块因为使用了Exporter模块,所以在命名空间污染方面的行为都应该有一个明确的规定。详情请看它们自己的文档。</target>
        </trans-unit>
        <trans-unit id="8e0bc2ae4e7dee6efa427af24dac0f51946576f0" translate="yes" xml:space="preserve">
          <source>StandardizedVariants.txt</source>
          <target state="translated">StandardizedVariants.txt</target>
        </trans-unit>
        <trans-unit id="07142f93c49bc59a674f3cf54cfc45c16742e4f3" translate="yes" xml:space="preserve">
          <source>Stands for &amp;ldquo;Database Management&amp;rdquo; routines, a set of routines that emulate an &lt;b&gt;associative array&lt;/b&gt; using disk files. The routines use a dynamic hashing scheme to locate any entry with only two disk accesses. DBM files allow a Perl program to keep a persistent &lt;b&gt;hash&lt;/b&gt; across multiple invocations. You can &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; your hash variables to various DBM implementations.</source>
          <target state="translated">代表&amp;ldquo;数据库管理&amp;rdquo;例程，这是一&lt;b&gt;组&lt;/b&gt;使用磁盘文件模拟&lt;b&gt;关联阵列&lt;/b&gt;的例程。这些例程使用动态哈希方案来定位只有两个磁盘访问权限的任何条目。DBM文件允许Perl程序在多个调用之间保持持久性&lt;b&gt;哈希&lt;/b&gt;。您可以 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 哈希变量绑定到各种DBM实现。</target>
        </trans-unit>
        <trans-unit id="32e3debe4cf1141c3184e11a9dc572fab1423447" translate="yes" xml:space="preserve">
          <source>Start position and no-match optimisations</source>
          <target state="translated">起始位置和无匹配优化</target>
        </trans-unit>
        <trans-unit id="db76cc0f3f883ec9a2ed91694d94f4588b9f7245" translate="yes" xml:space="preserve">
          <source>Start up an interval timer: after a certain time, a signal ($which) arrives, and more signals may keep arriving at certain intervals. To disable an &quot;itimer&quot;, use &lt;code&gt;$floating_seconds&lt;/code&gt; of zero. If the &lt;code&gt;$interval_floating_seconds&lt;/code&gt; is set to zero (or unspecified), the timer is disabled &lt;b&gt;after&lt;/b&gt; the next delivered signal.</source>
          <target state="translated">启动一个间隔计时器：在一定的时间后，信号（$ which）到达，并且更多的信号可能以一定的间隔不断到达。要禁用&amp;ldquo;初始值&amp;rdquo;，请使用 &lt;code&gt;$floating_seconds&lt;/code&gt; 为零。如果 &lt;code&gt;$interval_floating_seconds&lt;/code&gt; 设置为零（或未指定），则在下一个传递信号&lt;b&gt;后&lt;/b&gt;禁用计时器。</target>
        </trans-unit>
        <trans-unit id="bf54d336f01982c7f36b58a5973054d7f918d05e" translate="yes" xml:space="preserve">
          <source>Start with a dummy run of h2xs:</source>
          <target state="translated">先用h2xs假跑。</target>
        </trans-unit>
        <trans-unit id="8d112be587c3b58ec2b08ad08b5f28537f049d9b" translate="yes" xml:space="preserve">
          <source>Start with single-step on.</source>
          <target state="translated">从单步上开始。</target>
        </trans-unit>
        <trans-unit id="8332767a94ccaf8b2674f5e407c13b8594261e03" translate="yes" xml:space="preserve">
          <source>Start with the first letter in the string 'a'.</source>
          <target state="translated">从字符串'a'的第一个字母开始。</target>
        </trans-unit>
        <trans-unit id="be46870dc50c93db69a63c772d7b331eea2b204f" translate="yes" xml:space="preserve">
          <source>Start with the first letter in the string 't'.</source>
          <target state="translated">从字符串't'的第一个字母开始。</target>
        </trans-unit>
        <trans-unit id="e5189aa41c41bf90fef351656e01e6473fbaf249" translate="yes" xml:space="preserve">
          <source>Start your Perl program</source>
          <target state="translated">启动你的Perl程序</target>
        </trans-unit>
        <trans-unit id="9f05ee38f1d8c4b639d2c05f6f7cb39a8f63ba62" translate="yes" xml:space="preserve">
          <source>Start-tokens from Pod::Simple::PullParser</source>
          <target state="translated">来自Pod::Simple::PullParser的起始标记。</target>
        </trans-unit>
        <trans-unit id="bba3dd50f7eb62963e78abd741a6ecb84d7e0e92" translate="yes" xml:space="preserve">
          <source>Starting From Scratch</source>
          <target state="translated">从零开始</target>
        </trans-unit>
        <trans-unit id="d9722acfd050423d2f793d245909513d9f792a51" translate="yes" xml:space="preserve">
          <source>Starting OS/2 (and DOS) programs under Perl</source>
          <target state="translated">在Perl下启动OS/2(和DOS)程序。</target>
        </trans-unit>
        <trans-unit id="6a454cb163d40a3be765256333ed856099e340c6" translate="yes" xml:space="preserve">
          <source>Starting Perl in the VMS debugger may change the program execution profile in a way that such problems are not reproduced.</source>
          <target state="translated">在VMS调试器中启动Perl可能会改变程序的执行配置文件,从而无法重现此类问题。</target>
        </trans-unit>
        <trans-unit id="61b2b3d56b228f00035d9baf98e67307d761a53f" translate="yes" xml:space="preserve">
          <source>Starting Perl programs under AmigaOS</source>
          <target state="translated">在AmigaOS下启动Perl程序</target>
        </trans-unit>
        <trans-unit id="c712909317e062b2443119b81f61884099ac7f3f" translate="yes" xml:space="preserve">
          <source>Starting Perl programs under OS/2 (and DOS and...)</source>
          <target state="translated">在OS/2(以及DOS和...)下启动Perl程序。</target>
        </trans-unit>
        <trans-unit id="653f89b4c2f41c0d0134c806e923d3709fc205d1" translate="yes" xml:space="preserve">
          <source>Starting from IO::Zlib version 1.02, IO::Zlib can also use an external</source>
          <target state="translated">从IO::Zlib 1.02版本开始,IO::Zlib也可以使用外部的</target>
        </trans-unit>
        <trans-unit id="a508a2e273548a63bb5c0b07719e420fe300b9fd" translate="yes" xml:space="preserve">
          <source>Starting from OS/400 V5R2 the IBM Visual Age compiler is supported on OS/400 PASE, so it is possible to build Perl natively on OS/400. The easier way, however, is to compile in AIX, as just described.</source>
          <target state="translated">从OS/400 V5R2开始,OS/400 PASE支持IBM Visual Age编译器,因此可以在OS/400上原生地构建Perl。然而,更简单的方法是在AIX上编译,就像刚才所说的那样。</target>
        </trans-unit>
        <trans-unit id="5e473385f5209d49f3d6236a23d69b61072e12c5" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.10.1 (well, 5.10.0, but it didn't work right), you can say</source>
          <target state="translated">从Perl 5.10.1 (好吧,5.10.0,但它没有工作正确)开始,你可以说</target>
        </trans-unit>
        <trans-unit id="213483245e12096ac5558b413cc608887022de0d" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.6 Perl has had some level of multibyte character support. Perl 5.8 or later is recommended. Supported multibyte character repertoires include Unicode, and legacy encodings through the Encode module. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;, &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;, and &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">从Perl 5.6开始，Perl具有一定程度的多字节字符支持。建议使用Perl 5.8或更高版本。支持的多字节字符库包括Unicode和通过&amp;ldquo;编码&amp;rdquo;模块的旧版编码。请参见&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;，&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;和&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3401e5a549f724e4569e770d48d8137b822e30b" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.7.2 (and consequently 5.8.x / 5.10.x / 5.12.x) and AIX 4.3 or newer Perl uses the AIX native dynamic loading interface in the so called runtime linking mode instead of the emulated interface that was used in Perl releases 5.6.1 and earlier or, for AIX releases 4.2 and earlier. This change does break backward compatibility with compiled modules from earlier Perl releases. The change was made to make Perl more compliant with other applications like Apache/mod_perl which are using the AIX native interface. This change also enables the use of C++ code with static constructors and destructors in Perl extensions, which was not possible using the emulated interface.</source>
          <target state="translated">从Perl 5.7.2(以及5.8.x/5.10.x/5.12.x)和AIX 4.3或更新版本开始,Perl在所谓的运行时链接模式中使用AIX本地动态加载接口,而不是在Perl 5.6.1和更早的版本中使用的模拟接口,或者在AIX 4.2和更早的版本中使用。这一改变确实破坏了与早期 Perl 版本的编译模块的向后兼容性。这一改动是为了使Perl更符合其他应用程序的要求,比如Apache/mod_perl,它们使用的是AIX本地接口。这一改动也使得 Perl 扩展中可以使用带有静态构造函数和反构造函数的 C++代码,而使用仿真接口则是不可能的。</target>
        </trans-unit>
        <trans-unit id="25d510ae8cee14025ed8b7521c9e7b4803c6e585" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8 Filter::Util::Call (the core part of the Source Filters distribution) is part of the standard Perl distribution. Also included is a friendlier interface called Filter::Simple, by Damian Conway.</source>
          <target state="translated">从Perl 5.8开始,Filter::Util::Call(Source Filters发行版的核心部分)是标准Perl发行版的一部分。同时还包含了一个更友好的接口,叫做Filter::Simple,由Damian Conway编写。</target>
        </trans-unit>
        <trans-unit id="84131be03444ffa9bfcdc4607ace523b2b4abf69" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8 you can use the standard module Encode to translate from EBCDIC to Latin-1 code points. Encode knows about more EBCDIC character sets than Perl can currently be compiled to run on.</source>
          <target state="translated">从Perl 5.8开始,你可以使用标准模块Encode从EBCDIC翻译成Latin-1码点。Encode 知道的 EBCDIC 字符集比 Perl 目前可以编译运行的更多。</target>
        </trans-unit>
        <trans-unit id="b494835e5e76badb9fdcdcf6ee9b4a757213c9dc" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8, a source filter module, &lt;code&gt;Switch&lt;/code&gt; , can also be used to get switch and case. Its use is now discouraged, because it's not fully compatible with the native switch of Perl 5.10, and because, as it's implemented as a source filter, it doesn't always work as intended when complex syntax is involved.</source>
          <target state="translated">从Perl 5.8开始，源过滤器模块 &lt;code&gt;Switch&lt;/code&gt; 也可以用于获取switch和case。现在不鼓励使用它，因为它与Perl 5.10的本机开关不完全兼容，并且因为它作为源过滤器实现，所以在涉及复杂语法时，它并不总是按预期工作。</target>
        </trans-unit>
        <trans-unit id="a6f4302390c39dc69e8bb4ae56d84681737deb52" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8, in C/C++ level Perl knows how to wrap system/library interfaces that have thread-aware versions (e.g. getpwent_r()) into frontend macros (e.g. getpwent()) that correctly handle the multithreaded interaction with the Perl interpreter. This will happen transparently, the only thing you need to do is to instantiate a Perl interpreter.</source>
          <target state="translated">从Perl 5.8开始,在C/C++层面,Perl知道如何将具有线程感知版本的系统/库接口(如getpwent_r())包装成前端宏(如getpwent()),正确处理与Perl解释器的多线程交互。这将透明地发生,你唯一需要做的就是实例化一个 Perl 解释器。</target>
        </trans-unit>
        <trans-unit id="d0ecdc5671ad43a21bb3ba4b49951928dc27fb67" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8.1 different runs of Perl will have different ordering of hash keys. The change was done for greater security, see &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt;. This means that different runs of Perl will have different Data::Dumper outputs if the data contains hashes. If you need to have identical Data::Dumper outputs from different runs of Perl, use the environment variable PERL_HASH_SEED, see &lt;a href=&quot;../perlrun#PERL_HASH_SEED&quot;&gt;PERL_HASH_SEED in perlrun&lt;/a&gt;. Using this restores the old (platform-specific) ordering: an even prettier solution might be to use the &lt;code&gt;Sortkeys&lt;/code&gt; filter of Data::Dumper.</source>
          <target state="translated">从Perl 5.8.1开始，不同的Perl运行将具有不同的哈希键顺序。进行此更改以提高安全性，请参阅&lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec中的算法复杂性攻击&lt;/a&gt;。这意味着，如果数据包含哈希，则不同的Perl运行将具有不同的Data :: Dumper输出。如果需要从不同的Perl运行获得相同的Data :: Dumper输出，请使用环境变量PERL_HASH_SEED，请参见&lt;a href=&quot;../perlrun#PERL_HASH_SEED&quot;&gt;perlrun中的PERL_HASH_SEED&lt;/a&gt;。使用此方法可以恢复旧的（特定于平台的）排序：更漂亮的解决方案可能是使用Data :: Dumper 的 &lt;code&gt;Sortkeys&lt;/code&gt; 过滤器。</target>
        </trans-unit>
        <trans-unit id="54b73ef5c7c43845a94f049a96a2982af7951ff5" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.9.4 the following extra flags are added:</source>
          <target state="translated">从Perl 5.9.4开始,增加了以下标志。</target>
        </trans-unit>
        <trans-unit id="d0f3b9a37d935e7c453cae03a9fc889658a8b375" translate="yes" xml:space="preserve">
          <source>Starting from Perl v5.6.0, Perl has had the capacity to handle Unicode natively. Perl v5.8.0, however, is the first recommended release for serious Unicode work. The maintenance release 5.6.1 fixed many of the problems of the initial Unicode implementation, but for example regular expressions still do not work with Unicode in 5.6.1. Perl v5.14.0 is the first release where Unicode support is (almost) seamlessly integrable without some gotchas (the exception being some differences in &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;, and that is fixed starting in Perl 5.16.0). To enable this seamless support, you should &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (which is automatically selected if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher). See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. (5.14 also fixes a number of bugs and departures from the Unicode standard.)</source>
          <target state="translated">从Perl v5.6.0开始，Perl具备了本地处理Unicode的能力。但是，Perl v5.8.0是用于认真Unicode工作的第一个推荐版本。维护版本5.6.1修复了最初Unicode实现的许多问题，但是例如正则表达式仍然无法在5.6.1中使用Unicode。 Perl v5.14.0是第一个发行版，其中Unicode支持（几乎）可以无缝集成，而没有一些麻烦（例外是&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;有所不同，并且从Perl 5.16.0开始已修复）。要启用此无缝支持，应 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; （如果 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 或更高版本，则会自动选择该功能）。查看&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;。（5.14还修复了一些错误以及与Unicode标准的不同之处。）</target>
        </trans-unit>
        <trans-unit id="416a20fa36c19a41cf13089d9b7e6cda76a07463" translate="yes" xml:space="preserve">
          <source>Starting from perl 5.7.1 perl uses the Solaris malloc, since the perl malloc breaks when dealing with more than 2GB of memory, and the Solaris malloc also seems to be faster.</source>
          <target state="translated">从perl 5.7.1开始,perl使用Solaris malloc,因为perl malloc在处理超过2GB的内存时就会中断,而且Solaris malloc似乎也更快。</target>
        </trans-unit>
        <trans-unit id="e6f60ae2145b9aa31e782db73fe39a61dbb6b373" translate="yes" xml:space="preserve">
          <source>Starting from the beginning of the input string, each 8-tuple of characters is converted to 1 character of output. With format &lt;code&gt;b&lt;/code&gt; , the first character of the 8-tuple determines the least-significant bit of a character; with format &lt;code&gt;B&lt;/code&gt; , it determines the most-significant bit of a character.</source>
          <target state="translated">从输入字符串的开头开始，每8个字符的字符将转换为1个字符的输出。对于格式 &lt;code&gt;b&lt;/code&gt; ，8元组的第一个字符确定字符的最低有效位；使用格式 &lt;code&gt;B&lt;/code&gt; ，它将确定字符的最高有效位。</target>
        </trans-unit>
        <trans-unit id="bca54402551e7931f104cb3acd73bb3d87fc7a43" translate="yes" xml:space="preserve">
          <source>Starting from the beginning of the template to pack(), each pair of characters is converted to 1 character of output. With format &lt;code&gt;h&lt;/code&gt; , the first character of the pair determines the least-significant nybble of the output character; with format &lt;code&gt;H&lt;/code&gt; , it determines the most-significant nybble.</source>
          <target state="translated">从模板的开头到pack（），每对字符都转换为1个字符的输出。使用格式 &lt;code&gt;h&lt;/code&gt; ，该对中的第一个字符确定输出字符的最低有效字符。格式为 &lt;code&gt;H&lt;/code&gt; ，它确定最重要的连夜。</target>
        </trans-unit>
        <trans-unit id="e0719e57793beb804762734f954a0430e8236ad0" translate="yes" xml:space="preserve">
          <source>Starting from the top, this says &lt;code&gt;$b&lt;/code&gt; is an SV. The scalar is an IV, which is capable of holding an integer or reference value. It has the &lt;code&gt;ROK&lt;/code&gt; flag set, meaning it is a reference (rather than an integer or string). Notice that Dump follows the reference and shows us what &lt;code&gt;$b&lt;/code&gt; was referencing. We see the same &lt;code&gt;$a&lt;/code&gt; that we found in the previous example.</source>
          <target state="translated">从顶部开始，这表示 &lt;code&gt;$b&lt;/code&gt; 是SV。标量是一个IV，它可以保存整数或参考值。它设置了 &lt;code&gt;ROK&lt;/code&gt; 标志，这意味着它是一个引用（而不是整数或字符串）。注意，Dump遵循引用并向我们显示 &lt;code&gt;$b&lt;/code&gt; 所引用的内容。我们看到与上一个示例相同的 &lt;code&gt;$a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0542c0de06c1b01762ccd40a6fe67b90b3556cde" translate="yes" xml:space="preserve">
          <source>Starting from version 5.8, Perl uses a builtin translation layer for text-mode files. This replaces the efficient well-tested EMX layer by some code which should be best characterized as a &quot;quick hack&quot;.</source>
          <target state="translated">从 5.8 版开始,Perl 为文本模式文件使用了一个内置的翻译层。它用一些代码取代了高效的、经过良好测试的EMX层,这些代码最好被称为 &quot;快速黑客&quot;。</target>
        </trans-unit>
        <trans-unit id="ac77222ae2e654fdac46266902dcc915cb8e811b" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.12.0, &lt;code&gt;\N&lt;/code&gt; also can have an additional meaning (only) in patterns, namely to match a non-newline character. (This is short for &lt;code&gt;[^\n]&lt;/code&gt;, and like &lt;code&gt;.&lt;/code&gt; but is not affected by the &lt;code&gt;/s&lt;/code&gt; regex modifier.)</source>
          <target state="translated">从Perl 5.12.0开始， &lt;code&gt;\N&lt;/code&gt; 在模式中也可以（仅）具有其他含义，即匹配非换行符。（这是 &lt;code&gt;[^\n]&lt;/code&gt; 缩写，类似于 &lt;code&gt;.&lt;/code&gt; 但不受 &lt;code&gt;/s&lt;/code&gt; regex修饰符的影响。）</target>
        </trans-unit>
        <trans-unit id="2859a2d886c0e9aec6c1de9465ceff2207dfb72a" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14 (and partially in Perl 5.12), just put a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; near the beginning of your program. Within its lexical scope you shouldn't have this problem. It also is automatically enabled under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature ':5.12'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or using &lt;code&gt;-E&lt;/code&gt; on the command line for Perl 5.12 or higher.</source>
          <target state="translated">从Perl 5.14开始（部分在Perl 5.12中开始），只需在程序开头附近放置一个 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 。在其词汇范围内，您不应遇到此问题。对于Perl 5.12或更高版本，还可以在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature ':5.12'&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; 或在命令行上使用 &lt;code&gt;-E&lt;/code&gt; 的情况下自动启用它。</target>
        </trans-unit>
        <trans-unit id="a8902a856b5fd88514da38f6d1ea437cef45dc91" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14, a &lt;code&gt;&quot;^&quot;&lt;/code&gt; (caret or circumflex accent) immediately after the &lt;code&gt;&quot;?&quot;&lt;/code&gt; is a shorthand equivalent to &lt;code&gt;d-imsx&lt;/code&gt; . Any positive flags (except &lt;code&gt;&quot;d&quot;&lt;/code&gt; ) may follow the caret, so</source>
          <target state="translated">从Perl 5.14开始，紧接在 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 之后的是 &lt;code&gt;&quot;^&quot;&lt;/code&gt; （插入符号或抑扬音符号）。是 &lt;code&gt;d-imsx&lt;/code&gt; 的简写。任何正号（ &lt;code&gt;&quot;d&quot;&lt;/code&gt; 除外）都可以跟在插入符号后面，因此</target>
        </trans-unit>
        <trans-unit id="dd982f589d8e87c6c46ce3117db1a952a4a3a29e" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14, a &lt;code&gt;&quot;^&quot;&lt;/code&gt; (caret or circumflex accent) immediately after the &lt;code&gt;&quot;?&quot;&lt;/code&gt; is a shorthand equivalent to &lt;code&gt;d-imsx&lt;/code&gt; . Flags (except &lt;code&gt;&quot;d&quot;&lt;/code&gt; ) may follow the caret to override it. But a minus sign is not legal with it.</source>
          <target state="translated">从Perl 5.14开始，紧接在 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 之后的是 &lt;code&gt;&quot;^&quot;&lt;/code&gt; （插入符号或抑扬音符号）。是 &lt;code&gt;d-imsx&lt;/code&gt; 的简写。标记（除 &lt;code&gt;&quot;d&quot;&lt;/code&gt; ）可以跟在插入号后面以覆盖它。但是减号不合法。</target>
        </trans-unit>
        <trans-unit id="f8764da9a2d4e197710fd50d36bbe6c6ef6a3ac9" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14.0, regular expressions compiled within the scope of &lt;code&gt;unicode_strings&lt;/code&gt; use Unicode rules even when executed or compiled into larger regular expressions outside the scope.</source>
          <target state="translated">在Perl 5.14.0开始，范围内编译的正则表达式 &lt;code&gt;unicode_strings&lt;/code&gt; 执行或编译成的范围较大的正则表达式时，即使使用Unicode规则。</target>
        </trans-unit>
        <trans-unit id="69cd047e088fdbefa20b4fff4c70feeb8034d880" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.16.0, consistent quoting rules are used within the scope of &lt;code&gt;unicode_strings&lt;/code&gt; , as described in &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;. Prior to that, or outside its scope, no code points above 127 are quoted in UTF-8 encoded strings, but in byte encoded strings, code points between 128-255 are always quoted.</source>
          <target state="translated">在Perl 5.16.0开始，一致引用规则的范围内使用 &lt;code&gt;unicode_strings&lt;/code&gt; ，如描述&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;。在此之前或在其范围之外，UTF-8编码的字符串中没有引用高于127的代码点，但是在字节编码的字符串中，始终引用在128-255之间的代码点。</target>
        </trans-unit>
        <trans-unit id="4f8e157579b8bab3ccd61e698c935bfec29a8f08" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.20, a hash slice operation with the % symbol is a variant of slice operation returning a list of key/value pairs rather than just values:</source>
          <target state="translated">从Perl 5.20开始,带有%符号的哈希分片操作是分片操作的一种变体,它返回的是键/值对的列表,而不仅仅是值。</target>
        </trans-unit>
        <trans-unit id="013197011e87f7e0633670e8b800c1024b759400" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.16 in a very limited way, and more generally in v5.22, you can restrict which category or categories are enabled by this particular instance of the pragma by adding parameters to it. For example,</source>
          <target state="translated">从 Perl v5.16 开始,以一种非常有限的方式,在 v5.22 中,你可以通过添加参数来限制这个 pragma 的特定实例启用哪些类别。例如,你可以通过添加参数来限制这个 pragma 的特定实例启用哪些类别。</target>
        </trans-unit>
        <trans-unit id="d7be757a62548668bef82e6fa7932eb10efddb3b" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.16, Perl adopted a Unicode-defined strategy for quoting non-ASCII characters; the quoting of ASCII characters is unchanged.</source>
          <target state="translated">从Perl v5.16开始,Perl采用了Unicode定义的策略来引用非ASCII字符,而引用ASCII字符的策略没有改变。</target>
        </trans-unit>
        <trans-unit id="a75aca801899de40f1e5f4fc3d561cb6af7bcdc4" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.16, any occurrence of &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; sequences in a double-quotish string automatically loads this module with arguments &lt;code&gt;:full&lt;/code&gt; and &lt;code&gt;:short&lt;/code&gt; (described below) if it hasn't already been loaded with different arguments, in order to compile the named Unicode character into position in the string. Prior to v5.16, an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; was required to enable this usage. (However, prior to v5.16, the form &lt;code&gt;&quot;use
charnames ();&quot;&lt;/code&gt; did not enable &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt;.)</source>
          <target state="translated">从Perl v5.16开始，如果双引号字符串中的 &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; 序列出现任何情况，则该模块将自动使用参数 &lt;code&gt;:full&lt;/code&gt; 和 &lt;code&gt;:short&lt;/code&gt; （如下所述）加载该模块（如果尚未使用不同的参数加载该模块），为了将命名的Unicode字符编译到字符串中的位置。在v5.16之前，需要显式 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; 来启用此用法。 （但是，在v5.16之前，格式 &lt;code&gt;&quot;use charnames ();&quot;&lt;/code&gt; 未启用 &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="bc88b853a6a300ebebd43ce48839b53ca6b33945" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.20, UTF-8 locales are supported in Perl, except for &lt;code&gt;LC_COLLATE&lt;/code&gt; (use &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; instead). If you have Perl v5.16 or v5.18 and can't upgrade, you can use</source>
          <target state="translated">从Perl v5.20开始，Perl支持UTF-8语言环境，除了 &lt;code&gt;LC_COLLATE&lt;/code&gt; （改用&lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collat​​e&lt;/a&gt;）。如果您拥有Perl v5.16或v5.18并且无法升级，则可以使用</target>
        </trans-unit>
        <trans-unit id="24c20bca7982b6c0163573088c845daca9bc60e3" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.22, this applies to ranges in bracketed character classes. If you say, for example, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+20}-\N{U+7F}]/&lt;/a&gt;&lt;/code&gt;, it means the characters &lt;code&gt;\N{U+20}&lt;/code&gt; , &lt;code&gt;\N{U+21}&lt;/code&gt; , ..., &lt;code&gt;\N{U+7F}&lt;/code&gt; . This range is all the printable characters that the ASCII character set contains.</source>
          <target state="translated">从Perl v5.22开始，这适用于方括号字符类中的范围。例如，如果说 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+20}-\N{U+7F}]/&lt;/a&gt;&lt;/code&gt; ，则表示字符 &lt;code&gt;\N{U+20}&lt;/code&gt; ， &lt;code&gt;\N{U+21}&lt;/code&gt; ，.. 。， &lt;code&gt;\N{U+7F}&lt;/code&gt; 。此范围是ASCII字符集包含的所有可打印字符。</target>
        </trans-unit>
        <trans-unit id="b23b660058cb3ee939b11052749bad9b7526e31f" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.22, this is trivially changeable to work portably on both ASCII and EBCDIC platforms.</source>
          <target state="translated">从Perl v5.22开始,这一点可以简单地改变,以便在ASCII和EBCDIC平台上可移植地工作。</target>
        </trans-unit>
        <trans-unit id="0e38118c6920f78946e8d31e17cb36ad4ee8bf0e" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.8.6 (&lt;code&gt;Encode&lt;/code&gt; version 2.0.1),</source>
          <target state="translated">从Perl v5.8.6（ &lt;code&gt;Encode&lt;/code&gt; 版本2.0.1）开始，</target>
        </trans-unit>
        <trans-unit id="474e1944b6ecbc8a507bc2e01a2a550b04aa62eb" translate="yes" xml:space="preserve">
          <source>Starting in Unicode 6.1 and Perl v5.16, Unicode defines many abbreviations and names that were formerly Perl extensions, and some additional ones that Perl did not previously accept. The list is getting too long to reproduce here, but you can get the complete list from the Unicode web site: &lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&lt;/a&gt;.</source>
          <target state="translated">从Unicode 6.1和Perl v5.16开始，Unicode定义了许多以前是Perl扩展名的缩写和名称，以及一些Perl以前不接受的其他缩写和名称。该列表太长了，无法在此处复制，但是您可以从Unicode网站获得完整列表：&lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&quot;&gt;http&lt;/a&gt; : //www.unicode.org/Public/UNIDATA/NameAliases.txt。</target>
        </trans-unit>
        <trans-unit id="818df47ef2f0fcf2a87de97f12babb967ed1fcfb" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl supports UTF-8 locales for &lt;code&gt;LC_CTYPE&lt;/code&gt; , but otherwise Perl only supports single-byte locales, such as the ISO 8859 series. This means that wide character locales, for example for Asian languages, are not well-supported. (If the platform has the capability for Perl to detect such a locale, starting in Perl v5.22, &lt;a href=&quot;warnings#Category-Hierarchy&quot;&gt;Perl will warn, default enabled&lt;/a&gt;, using the &lt;code&gt;locale&lt;/code&gt; warning category, whenever such a locale is switched into.) The UTF-8 locale support is actually a superset of POSIX locales, because it is really full Unicode behavior as if no &lt;code&gt;LC_CTYPE&lt;/code&gt; locale were in effect at all (except for tainting; see &lt;a href=&quot;#SECURITY&quot;&gt;SECURITY&lt;/a&gt;). POSIX locales, even UTF-8 ones, are lacking certain concepts in Unicode, such as the idea that changing the case of a character could expand to be more than one character. Perl in a UTF-8 locale, will give you that expansion. Prior to v5.20, Perl treated a UTF-8 locale on some platforms like an ISO 8859-1 one, with some restrictions, and on other platforms more like the &quot;C&quot; locale. For releases v5.16 and v5.18, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters&lt;/code&gt; could be used as a workaround for this (see &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;).</source>
          <target state="translated">从v5.20开始，Perl支持 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的 UTF-8语言环境，否则Perl仅支持单字节语言环境，例如ISO 8859系列。这意味着没有很好的字符支持区域设置，例如亚洲语言。 （如果从Perl v5.22开始，如果平台具有Perl能够检测到这样的语言环境的&lt;a href=&quot;warnings#Category-Hierarchy&quot;&gt;功能&lt;/a&gt;，则每当切换到这样的语言环境时，Perl就会使用 &lt;code&gt;locale&lt;/code&gt; 警告类别来警告默认启用）。实际上是POSIX语言环境的超集，因为它实际上是完整的Unicode行为，好像根本没有 &lt;code&gt;LC_CTYPE&lt;/code&gt; 语言环境有效（除污点；请参阅&lt;a href=&quot;#SECURITY&quot;&gt;SECURITY&lt;/a&gt;）。 POSIX语言环境，甚至是UTF-8语言环境，在Unicode中都缺少某些概念，例如更改字符大小写可以扩展为多个字符的想法。在UTF-8语言环境中的Perl将为您提供扩展。在v5.20之前，Perl在某些平台上（例如ISO 8859-1）在某些平台上对UTF-8语言环境进行了处理，而在其他平台上则更像&amp;ldquo; C&amp;rdquo;语言环境。对于v5.16和v5.18版本，可以 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters&lt;/code&gt; 来解决此问题（请参见&lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode和UTF-8&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7c0b3fbd50ff716e496a38d1dbfc0634c6a5772b" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl uses full Unicode rules if the locale is UTF-8. Otherwise, there is a deficiency in this scheme, which is that case changes that cross the 255/256 boundary are not well-defined. For example, the lower case of LATIN CAPITAL LETTER SHARP S (U+1E9E) in Unicode rules is U+00DF (on ASCII platforms). But under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (prior to v5.20 or not a UTF-8 locale), the lower case of U+1E9E is itself, because 0xDF may not be LATIN SMALL LETTER SHARP S in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is. Perl returns a result that is above 255 (almost always the input character unchanged, for all instances (and there aren't many) where the 255/256 boundary would otherwise be crossed; and starting in v5.22, it raises a &lt;a href=&quot;perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;locale&lt;/a&gt; warning.</source>
          <target state="translated">从v5.20开始，如果语言环境为UTF-8，Perl将使用完整的Unicode规则。否则，此方案存在缺陷，那就是跨越255/256边界的情况更改未明确定义。例如，在Unicode规则中，小写拉丁字母大写SHARP S（U + 1E9E）为U + 00DF（在ASCII平台上）。但在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; （在v5.20之前，而不是UTF-8语言环境之前），U + 1E9E本身是小写字母，因为0xDF可能不是当前语言环境中的LATIN SMALL LETTER SHARP S，并且Perl无法知道该字符甚至存在于语言环境中，更不用说代码点了。 Perl返回大于255的结果（对于所有实例（并且不多），否则将超过255/256边界的输入字符几乎总是不变）；并且从v5.22开始，它会发出&lt;a href=&quot;perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;区域设置&lt;/a&gt;警告。</target>
        </trans-unit>
        <trans-unit id="cf1eee1ccf148c85a77132cb28b023038cea490f" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl uses full Unicode rules if the locale is UTF-8. Otherwise, there is a deficiency in this scheme, which is that case changes that cross the 255/256 boundary are not well-defined. For example, the lower case of LATIN CAPITAL LETTER SHARP S (U+1E9E) in Unicode rules is U+00DF (on ASCII platforms). But under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (prior to v5.20 or not a UTF-8 locale), the lower case of U+1E9E is itself, because 0xDF may not be LATIN SMALL LETTER SHARP S in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is. Perl returns a result that is above 255 (almost always the input character unchanged, for all instances (and there aren't many) where the 255/256 boundary would otherwise be crossed; and starting in v5.22, it raises a &lt;a href=&quot;../perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;locale&lt;/a&gt; warning.</source>
          <target state="translated">从v5.20开始，如果语言环境为UTF-8，Perl将使用完整的Unicode规则。否则，此方案存在缺陷，那就是跨越255/256边界的情况更改未明确定义。例如，在Unicode规则中，小写拉丁字母大写SHARP S（U + 1E9E）为U + 00DF（在ASCII平台上）。但在 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; （在v5.20之前，而不是UTF-8语言环境之前），U + 1E9E本身是小写字母，因为0xDF可能不是当前语言环境中的LATIN SMALL LETTER SHARP S，并且Perl无法知道该字符甚至存在于语言环境中，更不用说代码点了。 Perl返回大于255的结果（对于所有实例（并且不多），否则将超过255/256边界的输入字符几乎总是不变）；并且从v5.22开始，它会发出&lt;a href=&quot;../perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;区域设置&lt;/a&gt;警告。</target>
        </trans-unit>
        <trans-unit id="2c762f587a88d06d3ee0d5c6c5c66f9e2aa3c2b6" translate="yes" xml:space="preserve">
          <source>Starting in v5.22, Perl will by default warn when switching into a locale that redefines any ASCII printable character (plus &lt;code&gt;\t&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt; ) into a different class than expected. This is likely to happen on modern locales only on EBCDIC platforms, where, for example, a CCSID 0037 locale on a CCSID 1047 machine moves &lt;code&gt;&quot;[&quot;&lt;/code&gt; , but it can happen on ASCII platforms with the ISO 646 and other 7-bit locales that are essentially obsolete. Things may still work, depending on what features of Perl are used by the program. For example, in the example from above where &lt;code&gt;&quot;|&quot;&lt;/code&gt; becomes a &lt;code&gt;\w&lt;/code&gt; , and there are no regular expressions where this matters, the program may still work properly. The warning lists all the characters that it can determine could be adversely affected.</source>
          <target state="translated">从v5.22开始，默认情况下，Perl将在切换到将任何ASCII可打印字符（加上 &lt;code&gt;\t&lt;/code&gt; 和 &lt;code&gt;\n&lt;/code&gt; ）重新定义为与预期不同的类的语言环境时发出警告。仅在EBCDIC平台上，这可能会在现代语言环境中发生，例如，在CCSID 1047机器上的CCSID 0037语言环境移动了 &lt;code&gt;&quot;[&quot;&lt;/code&gt; ，但是在具有ISO 646和其他7位语言环境的ASCII平台上，可能会发生这种情况。本质上已经过时了。根据程序使用Perl的功能，事情仍然可能起作用。例如，在上面的示例中， &lt;code&gt;&quot;|&quot;&lt;/code&gt; 成为 &lt;code&gt;\w&lt;/code&gt; ，并且在此没有正则表达式，该程序可能仍能正常运行。该警告列出了它可以确定可能会受到不利影响的所有字符。</target>
        </trans-unit>
        <trans-unit id="30ce7d231c27d2be8f1b1d8928ca5c39bf4aed51" translate="yes" xml:space="preserve">
          <source>Starting in v5.22, you can use Unicode code points as the end points of regular expression pattern character ranges, and the range will include all Unicode code points that lie between those end points, inclusive.</source>
          <target state="translated">从v5.22开始,您可以使用Unicode码点作为正则表达式模式字符范围的端点,该范围将包括位于这些端点之间的所有Unicode码点,包括。</target>
        </trans-unit>
        <trans-unit id="3cd5e5803935bbb6537a6c17faa83c7fdd9ffba0" translate="yes" xml:space="preserve">
          <source>Starting in v5.8.6, the encoding name may be &lt;code&gt;:locale&lt;/code&gt; . This means that the encoding is taken from the current locale, and not hard-coded by the pragma. Since a script really can only be encoded in exactly one encoding, this option is dangerous. It makes sense only if the script itself is written in ASCII, and all the possible locales that will be in use when the script is executed are supersets of ASCII. That means that the script itself doesn't get changed, but the I/O handles have the specified encoding added, and the operations like &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; use that encoding.</source>
          <target state="translated">从v5.8.6开始，编码名称可以是 &lt;code&gt;:locale&lt;/code&gt; 。这意味着编码是从当前语言环境获取的，而不是由编译指示进行硬编码的。由于脚本实际上只能以一种编码进行编码，因此此选项很危险。仅当脚本本身是用ASCII编写的并且执行脚本时将使用的所有可能的语言环境都是ASCII的超集时，这才有意义。这意味着脚本本身不会更改，但是I / O句柄已添加了指定的编码，并且诸如 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 之类的操作都使用该编码。</target>
        </trans-unit>
        <trans-unit id="f8eb72d81f87d6a7a0f9e91198c8aa2adc48dbed" translate="yes" xml:space="preserve">
          <source>Starting in version 5.21.2, perls built with the experimental define &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; add an extra boolean flag for each op, &lt;code&gt;op_moresib&lt;/code&gt; . When not set, this indicates that this is the last op in an &lt;code&gt;OpSIBLING&lt;/code&gt; chain. This frees up the &lt;code&gt;op_sibling&lt;/code&gt; field on the last sibling to point back to the parent op. Under this build, that field is also renamed &lt;code&gt;op_sibparent&lt;/code&gt; to reflect its joint role. The macro &lt;code&gt;OpSIBLING(o)&lt;/code&gt; wraps this special behaviour, and always returns NULL on the last sibling. With this build the &lt;code&gt;op_parent(o)&lt;/code&gt; function can be used to find the parent of any op. Thus for forward compatibility, you should always use the &lt;code&gt;OpSIBLING(o)&lt;/code&gt; macro rather than accessing &lt;code&gt;op_sibling&lt;/code&gt; directly.</source>
          <target state="translated">在5.21.2版本开始，与实验内置皮尔斯定义 &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; 添加一个额外的布尔标志为每个运算， &lt;code&gt;op_moresib&lt;/code&gt; 。如果未设置，则表示这是 &lt;code&gt;OpSIBLING&lt;/code&gt; 链中的最后一个op 。这将释放最后一个同级上的 &lt;code&gt;op_sibling&lt;/code&gt; 字段，使其指向父级op。在此构建中，该字段也重命名为 &lt;code&gt;op_sibparent&lt;/code&gt; 以反映其共同作用。宏 &lt;code&gt;OpSIBLING(o)&lt;/code&gt; 包装了此特殊行为，并在最后一个同级上始终返回NULL。通过这种构建，可以使用 &lt;code&gt;op_parent(o)&lt;/code&gt; 函数查找任何op的父级。因此，为了向前兼容，您应始终使用 &lt;code&gt;OpSIBLING(o)&lt;/code&gt; 宏，而不是直接访问 &lt;code&gt;op_sibling&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6641cb9032ef109574e28893d667801fcaa3e2c6" translate="yes" xml:space="preserve">
          <source>Starting with 2.10, the special module name &lt;code&gt;Unicode&lt;/code&gt; refers to the version of the Unicode Character Database bundled with Perl.</source>
          <target state="translated">从2.10开始，特殊模块名称 &lt;code&gt;Unicode&lt;/code&gt; 是指与Perl捆绑在一起的Unicode字符数据库的版本。</target>
        </trans-unit>
        <trans-unit id="aca846c8be32988d259af2e704c9972784ca9b87" translate="yes" xml:space="preserve">
          <source>Starting with AutoLoader 5.73, you can call the &lt;code&gt;AutoLoader::autoload_sub&lt;/code&gt; function with the fully-qualified name of the function to load from its</source>
          <target state="translated">从AutoLoader 5.73开始，您可以使用函数的标准名称来调用 &lt;code&gt;AutoLoader::autoload_sub&lt;/code&gt; 函数，以从该函数的名称进行加载</target>
        </trans-unit>
        <trans-unit id="fe6dc30d7e458c682ee2ffab73f38deab13b705d" translate="yes" xml:space="preserve">
          <source>Starting with ExtUtils::ParseXS version 3.13_01 (comes with perl 5.16 and better), it is rather easy to share typemap code between multiple CPAN distributions. The general idea is to share it as a module that offers a certain API and have the dependent modules declare that as a built-time requirement and import the typemap into the XS. An example of such a typemap-sharing module on CPAN is &lt;code&gt;ExtUtils::Typemaps::Basic&lt;/code&gt; . Two steps to getting that module's typemaps available in your code:</source>
          <target state="translated">从ExtUtils :: ParseXS版本3.13_01（perl 5.16和更高版本附带）开始，在多个CPAN发行版之间共享类型映射代码非常容易。通常的想法是将其共享为提供特定API的模块，并让相关模块将其声明为内置时间要求，并将类型映射导入XS。CPAN上 &lt;code&gt;ExtUtils::Typemaps::Basic&lt;/code&gt; 共享模块的示例是ExtUtils :: Typemaps :: Basic。在代码中获得该模块的类型图的两个步骤：</target>
        </trans-unit>
        <trans-unit id="f9212af4220a7c7e6998749dd4723a25f0d7eab4" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.10, &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; and &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; are part of the standard distribution, so you might think that you could do something like this:</source>
          <target state="translated">从Perl 5.10开始，&lt;a href=&quot;time/piece&quot;&gt;Time :: Piece&lt;/a&gt;和&lt;a href=&quot;time/seconds&quot;&gt;Time :: Seconds&lt;/a&gt;是标准发行版的一部分，因此您可能会认为可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="97eea9254558fb3fd8f17c44c41b369b3648d850" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.10.0, integer and floating-point formats, along with the &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats and &lt;code&gt;()&lt;/code&gt; groups, may all be followed by the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; endianness modifiers to respectively enforce big- or little-endian byte-order. These modifiers are especially useful given how &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; , and &lt;code&gt;V&lt;/code&gt; don't cover signed integers, 64-bit integers, or floating-point values.</source>
          <target state="translated">从Perl 5.10.0开始，整数和浮点格式，以及 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt; 格式以及 &lt;code&gt;()&lt;/code&gt; 组，都可能跟在 &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&lt;/code&gt; endianness修饰符之后，分别强制使用大端或小端字节顺序。鉴于 &lt;code&gt;n&lt;/code&gt; ， &lt;code&gt;N&lt;/code&gt; ， &lt;code&gt;v&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 如何不覆盖有符号整数，64位整数或浮点值，这些修饰符特别有用。</target>
        </trans-unit>
        <trans-unit id="2ee36782903bc57420ba5e155b45524572f22583" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.12, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; can handle dates past 03:14:08 January 19, 2038, when a 32-bit based time would overflow. You still might get a warning on a 32-bit &lt;code&gt;perl&lt;/code&gt; :</source>
          <target state="translated">从Perl 5.12开始， &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 可以处理2038年1月19日03:14:08之后的日期，此时基于32位的时间将溢出。您仍然可能在32位 &lt;code&gt;perl&lt;/code&gt; 上收到警告：</target>
        </trans-unit>
        <trans-unit id="3547c4def41d12fec193f972e11bcb976215d4c4" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.12, an additional integer parameter will be passed. It will be zero if &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; is called without parameter; &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; is given a filehandle as a parameter, e.g. &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(FH)&lt;/a&gt;&lt;/code&gt;; and &lt;code&gt;2&lt;/code&gt; in the very special case that the tied filehandle is &lt;code&gt;ARGV&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; is called with an empty parameter list, e.g. &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从Perl 5.12开始，将传递一个附加的整数参数。如果不带参数调用 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; ，它将为零；否则为0 。如果给 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 一个文件句柄作为参数，例如 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(FH)&lt;/a&gt;&lt;/code&gt; ，则为 &lt;code&gt;1&lt;/code&gt; ；和 &lt;code&gt;2&lt;/code&gt; 在非常特殊的情况下，该捆绑的文件句柄是 &lt;code&gt;ARGV&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 被称为带有空参数列表，如 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3385173ff54b55e840ed45e4ab6e0da31d97fba8" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14 a parent will not wait() automatically for any child that has been signalled with &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('TERM', ...)&lt;/code&gt; to avoid a deadlock in case the child is blocking on I/O and never receives the signal.</source>
          <target state="translated">从Perl 5.14开始，父级将不会自动为已被 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('TERM', ...)&lt;/code&gt; 发出信号的任何子级使用wait（）以避免死锁，以防子级在I / O上阻塞并且从不接收信号。</target>
        </trans-unit>
        <trans-unit id="90de3712cf0c49e19f3e9d37735c0e97d4b521ae" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对无祝福的哈希或数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 方面都被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="818e24d28a7aaf2cbc1a6702710734a070d06698" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对无祝福的哈希或数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 方面都被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="72fa5cd516760576150d0418affb48e1abda4a5b" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must contain a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未加祝福的哈希或数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="e2b92aff600824b9c22651f1e75f3d65c35db8ae" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未祝福数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="07bb8994fa6804d1b79f779661eabab22fa4d596" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未祝福数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="10642e156a8402673021a377c62441722a9d8a63" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对无福数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="5169411fd5bf69d929b67dfac03c2c64e43db230" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; can take scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对无祝福数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="7439a015aa95224d62eb3bbca9a133f540e69f0f" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未祝福数组的引用。该参数将自动取消引用。保持 &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="23e76a783b752b5dc19b6f3c4b3d934de488d5e6" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未加祝福的哈希或数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="47398b3574f050221d9d55302c39ea94e67781b9" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must contain a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未加祝福的哈希或数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="fac0b7eb35a23345be196afebeca8562c183fce3" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未祝福数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="427fc5d0e35cec380d803ece997f22ba459e7c3c" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未祝福数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="a0a12ea19c52c77b676bcf9fb786b8629096b3dc" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对无福数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="a3217cf42c0331e4a0cfa6eb7dd493042a8c7e44" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; can take scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对无祝福数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="d0f153998e2fa782a330b974d3d6a495fc8735ee" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未祝福数组的引用。该参数将自动取消引用。保持 &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="e3eb26fa45077fda36157e3c2cd25a74327fbf5e" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未加祝福的哈希或数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="84114b43a4e1c51016947fa39587027a5c42b337" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.16, you can embed typemaps into your XS code instead of or in addition to typemaps in a separate file. Multiple such embedded typemaps will be processed in order of appearance in the XS code and like local typemap files take precedence over the default typemap, the embedded typemaps may overwrite previous definitions of TYPEMAP, INPUT, and OUTPUT stanzas. The syntax for embedded typemaps is</source>
          <target state="translated">从Perl 5.16开始,你可以在XS代码中嵌入typemaps,代替或补充单独文件中的typemaps。在XS代码中,多个这样的嵌入式类型映射将按照出现的顺序进行处理,就像本地类型映射文件优先于默认类型映射一样,嵌入式类型映射可能会覆盖之前定义的typemap、input和output节。嵌入式类型地图的语法是</target>
        </trans-unit>
        <trans-unit id="ead2268f227644c92e6fae21c9b2bbc1c3977d01" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.8, a macro framework has been defined to allow static data to be safely stored in XS modules that will be accessed from a multi-threaded Perl.</source>
          <target state="translated">从Perl 5.8开始,我们定义了一个宏框架,允许静态数据安全地存储在XS模块中,这些模块将从多线程的Perl中访问。</target>
        </trans-unit>
        <trans-unit id="83f897274d9417a81431b1cfc87771e6f6b3c937" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.8.1 strict is strict about its restrictions: if unknown restrictions are used, the strict pragma will abort with</source>
          <target state="translated">从Perl 5.8.1开始,strict对限制条件的要求非常严格:如果使用了未知的限制条件,strict pragma会用下面的命令中止。</target>
        </trans-unit>
        <trans-unit id="4c86c42abf281eff02c433a98ecba5908f6fea66" translate="yes" xml:space="preserve">
          <source>Starting with Solaris 8, perl5.00503 (or higher) is supplied with the operating system, so you might not even need to build a newer version of perl at all. The Sun-supplied version is installed in /usr/perl5 with</source>
          <target state="translated">从Solaris 8开始,perl5.00503(或更高版本)随操作系统一起提供,所以你可能根本不需要构建一个更新的perl版本。Sun提供的版本是安装在/usr/perl5中的,并带有</target>
        </trans-unit>
        <trans-unit id="070cbbea94d8e9dec2f41e08f125528dd6a6e9b2" translate="yes" xml:space="preserve">
          <source>Starting with Tiger (Mac OS X 10.4), Apple shipped broken locale files for the eu_ES locale (Basque-Spain). In previous releases of Perl, this resulted in failures in the</source>
          <target state="translated">从Tiger (Mac OS X 10.4)开始,Apple提供的eu_ES语言(Basque-Spain)的locale文件出现了问题。在之前发布的Perl中,这导致了在</target>
        </trans-unit>
        <trans-unit id="0811928afaca739fa817229f5f4a0d0397bc7c2a" translate="yes" xml:space="preserve">
          <source>Starting with release 1.23_03, Scalar-List-Util is &lt;b&gt;always&lt;/b&gt; using the XS implementation, but for backwards compatibility, we still ship the &lt;code&gt;List::Util::XS&lt;/code&gt; module which just loads &lt;code&gt;List::Util&lt;/code&gt; .</source>
          <target state="translated">从版本1.23_03开始，Scalar-List-Util &lt;b&gt;始终&lt;/b&gt;使用XS实现，但是为了向后兼容，我们仍然提供 &lt;code&gt;List::Util::XS&lt;/code&gt; 模块，该模块仅加载 &lt;code&gt;List::Util&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f31afb43ed5a01839f8ddc750e5dd35f48c3a6c" translate="yes" xml:space="preserve">
          <source>Starting with this section, we will be discussing Perl's set of</source>
          <target state="translated">从本节开始,我们将讨论Perl的一组</target>
        </trans-unit>
        <trans-unit id="8ef231992030ec09e2d04d1b4b88e1196c802a84" translate="yes" xml:space="preserve">
          <source>Starting with version 2.x, Berkeley DB has internal support for locking. The companion module to this one, &lt;b&gt;BerkeleyDB&lt;/b&gt;, provides an interface to this locking functionality. If you are serious about locking Berkeley DB databases, I strongly recommend using &lt;b&gt;BerkeleyDB&lt;/b&gt;.</source>
          <target state="translated">从2.x版开始，Berkeley DB具有内部锁定支持。该模块的配套模块&lt;b&gt;BerkeleyDB&lt;/b&gt;提供了此锁定功能的接口。如果您真的想锁定Berkeley DB数据库，我强烈建议您使用&lt;b&gt;BerkeleyDB&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="6f6299a2f62ed0797f2e4ca75150d013801fc49f" translate="yes" xml:space="preserve">
          <source>Starts a try block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Exception Handling in perlguts&lt;/a&gt;.</source>
          <target state="translated">启动一个try块。请参阅&lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;perlguts中的异常处理&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="79ce33706ca0540aaf9d8ed291d64bf45fad0cd4" translate="yes" xml:space="preserve">
          <source>Startup</source>
          <target state="translated">Startup</target>
        </trans-unit>
        <trans-unit id="6991439e4716de488447c6e2c2f9b1970b90a8e3" translate="yes" xml:space="preserve">
          <source>Stashes and Globs</source>
          <target state="translated">储藏室和球体</target>
        </trans-unit>
        <trans-unit id="acf91ec4328cf0ba3defd8522962fa33e41a1740" translate="yes" xml:space="preserve">
          <source>State storage for the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;prove&lt;/code&gt; 命令的状态存储。</target>
        </trans-unit>
        <trans-unit id="ed2cb72d0aaac69d6842c67515cf3bf802a6b33a" translate="yes" xml:space="preserve">
          <source>Statement Modifiers</source>
          <target state="translated">声明修正</target>
        </trans-unit>
        <trans-unit id="1ddbc09b1ca4e7855762d5787c6c0d7a3595a8af" translate="yes" xml:space="preserve">
          <source>Static Linking of a new Perl Binary</source>
          <target state="translated">新的Perl二进制的静态链接。</target>
        </trans-unit>
        <trans-unit id="3c5f15db40f98d51818ecdf0034d37509667528b" translate="yes" xml:space="preserve">
          <source>Static functions might not be visible for the backtrace.</source>
          <target state="translated">静态函数在回溯中可能不可见。</target>
        </trans-unit>
        <trans-unit id="8f8ab9355e9f77bfc04d09779d25ce6944605b91" translate="yes" xml:space="preserve">
          <source>Statistics about downloads are truncated by size and period simultaneously.</source>
          <target state="translated">关于下载的统计是按大小和周期同时截断的。</target>
        </trans-unit>
        <trans-unit id="5610cd01f9a3d6080e798d67334a100aa1573c90" translate="yes" xml:space="preserve">
          <source>Status 1 overrides status 2. If you want unambiguous results, call &lt;b&gt;podchecker&lt;/b&gt; with one single argument only.</source>
          <target state="translated">状态1覆盖状态2。如果要获得明确的结果，请&lt;b&gt;仅&lt;/b&gt;使用一个参数调用&lt;b&gt;podchecker&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="187236d960db5eb4ad8363cf8f2f9b1ddb6ac5e1" translate="yes" xml:space="preserve">
          <source>Stdio class buffering options.</source>
          <target state="translated">Stdio类缓冲选项。</target>
        </trans-unit>
        <trans-unit id="60a9d23beb62cbe40cee43c7f38898ee6c1f97c7" translate="yes" xml:space="preserve">
          <source>Steffen Mueller &amp;lt;smueller@cpan.org&amp;gt;</source>
          <target state="translated">斯特芬&amp;middot;穆勒（Steffen Mueller）&amp;lt;smueller@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c982c59dd847ba297d8467bd252ba58dd872a85c" translate="yes" xml:space="preserve">
          <source>Steffen Mueller, &amp;lt;smueller@cpan.org&amp;gt;</source>
          <target state="translated">斯蒂芬&amp;middot;穆勒（Steffen Mueller），&amp;lt;smueller@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="67aeabbbe7f975f118f5118824dfb5a83bb31c11" translate="yes" xml:space="preserve">
          <source>Step-by-step: Distributing your module</source>
          <target state="translated">一步一步的。分发你的模块</target>
        </trans-unit>
        <trans-unit id="1a565c4552b2edcc3b1a58d76fe5018ccb0e6a32" translate="yes" xml:space="preserve">
          <source>Step-by-step: Making the module</source>
          <target state="translated">一步一步来。制作模块</target>
        </trans-unit>
        <trans-unit id="481a4d002beceae3935eab8245f4c76879540359" translate="yes" xml:space="preserve">
          <source>Step-by-step: Preparing the ground</source>
          <target state="translated">逐步进行。准备地面</target>
        </trans-unit>
        <trans-unit id="80427e23cbb5abd94ca5e55445014873b52c64b8" translate="yes" xml:space="preserve">
          <source>Stephen McCamant &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;, based on an earlier version by Malcolm Beattie &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;, with contributions from Gisle Aas, James Duncan, Albert Dvornik, Robin Houston, Dave Mitchell, Hugo van der Sanden, Gurusamy Sarathy, Nick Ing-Simmons, and Rafael Garcia-Suarez.</source>
          <target state="translated">Stephen McCamant &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;，基于Malcolm Beattie &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;的早期版本，由Gisle Aas，James Duncan，Albert Dvornik，Robin Houston，Dave Mitchell，雨果&amp;middot;范德&amp;middot;桑登（Hugo van der Sanden），古鲁萨米&amp;middot;萨拉西（Gurusamy Sarathy），尼克&amp;middot;英格&amp;middot;西蒙斯（Nick Ing-Simmons）和拉斐尔&amp;middot;加西亚&amp;middot;苏亚雷斯（Rafael Garcia-Suarez）。</target>
        </trans-unit>
        <trans-unit id="6a244b340bceacb4b7643a7f28401322b0f43369" translate="yes" xml:space="preserve">
          <source>Stephen McCamant, &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;.</source>
          <target state="translated">史蒂芬&amp;middot;麦卡曼（Stephen McCamant），&amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="406bdac466755debe16970475ad1ba98d0b486e3" translate="yes" xml:space="preserve">
          <source>Stepping through code</source>
          <target state="translated">踏过代码</target>
        </trans-unit>
        <trans-unit id="f13a1be70942b94ceb5c4947f5cad9efec256df0" translate="yes" xml:space="preserve">
          <source>Steps through the program a line at a time, without descending into functions.</source>
          <target state="translated">一行一行地浏览程序,不需要进入函数。</target>
        </trans-unit>
        <trans-unit id="67e08e5dee051e0626b0f262d208037e870d3ac2" translate="yes" xml:space="preserve">
          <source>Steps through the program a line at a time.</source>
          <target state="translated">一行一行地走过程序。</target>
        </trans-unit>
        <trans-unit id="f18c11d1612cf243a4188b75a5a32a4030b759d2" translate="yes" xml:space="preserve">
          <source>Steve Hay &amp;lt;</source>
          <target state="translated">史蒂夫&amp;middot;海伊&amp;lt;</target>
        </trans-unit>
        <trans-unit id="9d16db78589f14f29e83bbd762e7ffb3c9579828" translate="yes" xml:space="preserve">
          <source>Steve Lembark goes through the details in his YAPC::NA 2009 talk &quot;Perly Linked Lists&quot; ( &lt;a href=&quot;http://www.slideshare.net/lembark/perly-linked-lists&quot;&gt;http://www.slideshare.net/lembark/perly-linked-lists&lt;/a&gt; ), although you can just use his &lt;a href=&quot;http://search.cpan.org/perldoc/LinkedList::Single&quot;&gt;LinkedList::Single&lt;/a&gt; module.</source>
          <target state="translated">史蒂夫&amp;middot;伦巴克（Steve Lembark）在YAPC :: NA 2009演讲&amp;ldquo; Perly Linked Lists&amp;rdquo;（&lt;a href=&quot;http://www.slideshare.net/lembark/perly-linked-lists&quot;&gt;http://www.slideshare.net/lembark/perly-linked-lists&lt;/a&gt;）中详细介绍了该过程，尽管您可以使用他的&lt;a href=&quot;http://search.cpan.org/perldoc/LinkedList::Single&quot;&gt;LinkedList :: Single&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="09652192134371fdefcd293d5003ff83e32ed6ed" translate="yes" xml:space="preserve">
          <source>Steve Peters &amp;lt;steve@fisharerojo.org&amp;gt;</source>
          <target state="translated">史蒂夫&amp;middot;彼得斯&amp;lt;steve@fisharerojo.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7d6ea163d8063bfc57b0256f3178b768eac364c1" translate="yes" xml:space="preserve">
          <source>Steve Purkis</source>
          <target state="translated">Steve Purkis</target>
        </trans-unit>
        <trans-unit id="9efb7766602083380f01f9cadb6f278fbfabf5e5" translate="yes" xml:space="preserve">
          <source>Steve Purkis &amp;lt;spurkis@cpan.org&amp;gt;</source>
          <target state="translated">史蒂夫&amp;middot;珀基斯（Steve Purkis）&amp;lt;spurkis@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2200943829d703ee08a178c2eb1eee2c0a806988" translate="yes" xml:space="preserve">
          <source>Steve Purkis.</source>
          <target state="translated">Steve Purkis</target>
        </trans-unit>
        <trans-unit id="270c172269bbb0672801106f89223f66575337c6" translate="yes" xml:space="preserve">
          <source>Steven McDougall &amp;lt;swmcd@world.std.com&amp;gt; for his help and patience with re-writing this manpage.</source>
          <target state="translated">史蒂文&amp;middot;麦克杜格尔（Steven McDougall）&amp;lt;swmcd@world.std.com&amp;gt;感谢他的帮助和耐心，重新编写了此联机帮助页。</target>
        </trans-unit>
        <trans-unit id="3a70ee5e8fb61558310f5b5e31b73a3d007c0de0" translate="yes" xml:space="preserve">
          <source>Still another problem is that this approach can lead to two code points meaning the same character. Thus in a Greek locale, both U+03A7 and U+00D7 are GREEK CAPITAL LETTER CHI.</source>
          <target state="translated">还有一个问题是,这种方法可能会导致两个码点意思相同的字符。因此在希腊语的地方,U+03A7和U+00D7都是GREEK CAPITAL LETTER CHI。</target>
        </trans-unit>
        <trans-unit id="72bc7a84f86b7c98bba879166a64bc5b045625fd" translate="yes" xml:space="preserve">
          <source>Stops running tests as &quot;TODO&quot; tests. This method is fatal if called without a preceding &lt;code&gt;todo_start&lt;/code&gt; method call.</source>
          <target state="translated">停止将测试作为&amp;ldquo; TODO&amp;rdquo;测试运行。如果在没有前面的 &lt;code&gt;todo_start&lt;/code&gt; 方法调用的情况下调用此方法，将是致命的。</target>
        </trans-unit>
        <trans-unit id="45b0f8b6273dfd6e7997a4038c99b48d40e17dae" translate="yes" xml:space="preserve">
          <source>Storable</source>
          <target state="translated">Storable</target>
        </trans-unit>
        <trans-unit id="46f9f6e335231e1456d3ba18bd5a505213eb74c6" translate="yes" xml:space="preserve">
          <source>Storable - persistence for Perl data structures</source>
          <target state="translated">Storable--Perl数据结构的持久化。</target>
        </trans-unit>
        <trans-unit id="1630856d50b3ec9af87960aa33400ccd3dc094bd" translate="yes" xml:space="preserve">
          <source>Storable has now been changed to write out and read in a file header with information about the size of integers. It's impossible to detect whether an old file being read in was written with 32 or 64 bit integers (they have the same header) so it's impossible to automatically switch to a correct backwards compatibility mode. Hence this Storable defaults to the new, correct behaviour.</source>
          <target state="translated">Storable现在已经被改变为写出和读入一个带有整数大小信息的文件头。它不可能检测到被读入的旧文件是用32位还是64位整数写的(它们有相同的头),所以不可能自动切换到正确的向后兼容模式。因此,这个Storable默认为新的、正确的行为。</target>
        </trans-unit>
        <trans-unit id="714a2ccbafbac0389af167e01df326cf6b8a78ff" translate="yes" xml:space="preserve">
          <source>Storable magic</source>
          <target state="translated">储存魔法</target>
        </trans-unit>
        <trans-unit id="7182df5560db2bb6b5167976e453bb5798e3130f" translate="yes" xml:space="preserve">
          <source>Storable provides you with a &lt;code&gt;dclone&lt;/code&gt; interface which does not create that intermediary scalar but instead freezes the structure in some internal memory space and then immediately thaws it out.</source>
          <target state="translated">Storable为您提供了一个 &lt;code&gt;dclone&lt;/code&gt; 接口，该接口不会创建该中间标量，而是将结构冻结在某些内部内存空间中，然后立即将其解冻。</target>
        </trans-unit>
        <trans-unit id="70fb12ce1748ed7f4a137be836ce41aa365bbd68" translate="yes" xml:space="preserve">
          <source>Storable uses the &quot;exception&quot; paradigm, in that it does not try to workaround failures: if something bad happens, an exception is generated from the caller's perspective (see &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; and &lt;code&gt;croak()&lt;/code&gt; ). Use eval {} to trap those exceptions.</source>
          <target state="translated">Storable使用&amp;ldquo;例外&amp;rdquo;范式，因为它不会尝试解决失败：如果发生了某些不良情况，则会从调用者的角度生成异常（请参阅&lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt;和 &lt;code&gt;croak()&lt;/code&gt; ）。使用eval {}捕获那些异常。</target>
        </trans-unit>
        <trans-unit id="531ca0b8b45f41c9f0b1aa246372790831675baa" translate="yes" xml:space="preserve">
          <source>Storable was written by Raphael Manfredi</source>
          <target state="translated">Storable是由Raphael Manfredi写的。</target>
        </trans-unit>
        <trans-unit id="b7e864254e3dece2f3614748bd8acc66ad85caaa" translate="yes" xml:space="preserve">
          <source>Storable writes a file header which contains the sizes of various C language types for the C compiler that built Storable (when not writing in network order), and will refuse to load files written by a Storable not on the same (or compatible) architecture. This check and a check on machine byteorder is needed because the size of various fields in the file are given by the sizes of the C language types, and so files written on different architectures are incompatible. This is done for increased speed. (When writing in network order, all fields are written out as standard lengths, which allows full interworking, but takes longer to read and write)</source>
          <target state="translated">Storable会给构建Storable的C编译器写一个文件头,这个文件头包含了各种C语言类型的大小(不按网络顺序写的时候),会拒绝加载不在同一(或兼容)架构上的Storable写的文件。这个检查和对机器字节顺序的检查是需要的,因为文件中各种字段的大小是由C语言类型的大小给出的,所以在不同架构上编写的文件是不兼容的。这样做是为了提高速度。(按网络顺序写时,所有字段都按标准长度写出来,这样可以实现充分的互通,但读写时间较长)</target>
        </trans-unit>
        <trans-unit id="4150d3a5cc43231c993765dececd1a150bb52a3d" translate="yes" xml:space="preserve">
          <source>Store Memoized data in Storable database</source>
          <target state="translated">将记忆数据存储在可存储数据库中。</target>
        </trans-unit>
        <trans-unit id="92a651d3dc16aed75ba857e2f774b7e083ba7965" translate="yes" xml:space="preserve">
          <source>Store and re-use state information about distributions between CPAN.pm sessions?</source>
          <target state="translated">存储和重用CPAN.pm会话之间分布的状态信息?</target>
        </trans-unit>
        <trans-unit id="2c71530924851d1b8827aef4994b16eb515c4e61" translate="yes" xml:space="preserve">
          <source>Store data</source>
          <target state="translated">储存日期</target>
        </trans-unit>
        <trans-unit id="b25c722ad4f1fce5bbbe8fc35b0030d7d69ef919" translate="yes" xml:space="preserve">
          <source>Store datum</source>
          <target state="translated">存储基准面</target>
        </trans-unit>
        <trans-unit id="8f37eea7a30e3775bbbbb580f43dfdd3bec41576" translate="yes" xml:space="preserve">
          <source>Store the results of a test.</source>
          <target state="translated">存储测试的结果。</target>
        </trans-unit>
        <trans-unit id="389cd56c2ab90c83d09e93be1e21e43d82460448" translate="yes" xml:space="preserve">
          <source>Stores &lt;code&gt;$value&lt;/code&gt; in the gzip OS header field. A number between 0 and 255 is valid.</source>
          <target state="translated">将 &lt;code&gt;$value&lt;/code&gt; 存储在gzip OS标头字段中。0到255之间的数字有效。</target>
        </trans-unit>
        <trans-unit id="b39d714bdc1e95f53f0e2222e4e3c3755001f302" translate="yes" xml:space="preserve">
          <source>Stores &lt;code&gt;val&lt;/code&gt; in a hash. The hash key is specified as &lt;code&gt;key&lt;/code&gt; . The &lt;code&gt;hash&lt;/code&gt; parameter is the precomputed hash value; if it is zero then Perl will compute it. The return value is the new hash entry so created. It will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise the contents of the return value can be accessed using the &lt;code&gt;He?&lt;/code&gt; macros described here. Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL. Effectively a successful hv_store_ent takes ownership of one reference to &lt;code&gt;val&lt;/code&gt; . This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, hv_store will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. Note that hv_store_ent only reads the &lt;code&gt;key&lt;/code&gt; ; unlike &lt;code&gt;val&lt;/code&gt; it does not take ownership of it, so maintaining the correct reference count on &lt;code&gt;key&lt;/code&gt; is entirely the caller's responsibility. hv_store is not implemented as a call to hv_store_ent, and does not create a temporary SV for the key, so if your key data is not already in SV form then use hv_store in preference to hv_store_ent.</source>
          <target state="translated">将 &lt;code&gt;val&lt;/code&gt; 存储在哈希中。哈希键被指定为 &lt;code&gt;key&lt;/code&gt; 。的 &lt;code&gt;hash&lt;/code&gt; 参数是预先计算的散列值;如果为零，则Perl将对其进行计算。返回值是这样创建的新哈希条目。如果操作失败或如果该值实际上不需要存储在哈希中（如绑定哈希的情况），则为NULL。否则，可以使用 &lt;code&gt;He?&lt;/code&gt; 访问返回值的内容。这里描述的宏。请注意，调用者负责在调用之前适当地增加 &lt;code&gt;val&lt;/code&gt; 的引用计数，并在函数返回NULL时递减它。有效地，成功的hv_store_ent拥有对 &lt;code&gt;val&lt;/code&gt; 的一个引用的所有权。这通常是您想要的；新创建的SV的引用计数为1，因此，如果您所有的代码都是创建SV，然后将其存储在哈希中，则hv_store将拥有对新SV的唯一引用，并且您的代码无需执行任何其他操作即可整理。注意hv_store_ent只读取 &lt;code&gt;key&lt;/code&gt; ；与 &lt;code&gt;val&lt;/code&gt; 不同，它不拥有它的所有权，因此，保持 &lt;code&gt;key&lt;/code&gt; 上正确的引用计数完全是调用者的责任。 hv_store未实现为对hv_store_ent的调用，并且不会为密钥创建临时SV，因此，如果密钥数据尚未采用SV格式，则优先使用hv_store而不是hv_store_ent。</target>
        </trans-unit>
        <trans-unit id="7e853791e7f610503cb4ac62aa2d38d07104bcbf" translate="yes" xml:space="preserve">
          <source>Stores a value, associated with a key, in the cop hints hash</source>
          <target state="translated">将一个与键相关联的值存储在 cop hints hash 中。</target>
        </trans-unit>
        <trans-unit id="5e0142d462eb02b96cf9082ac295203e85636940" translate="yes" xml:space="preserve">
          <source>Stores all unambiguous truncations of each element of LIST as keys in the associative array referenced by &lt;code&gt;$hashref&lt;/code&gt; . The values are the original list elements.</source>
          <target state="translated">将LIST的每个元素的所有明确的截断存储为 &lt;code&gt;$hashref&lt;/code&gt; 引用的关联数组中的键。这些值是原始列表元素。</target>
        </trans-unit>
        <trans-unit id="4236561c990b7cd479ccb52f08cd5fac9306b818" translate="yes" xml:space="preserve">
          <source>Stores an SV in a hash. The hash key is specified as &lt;code&gt;key&lt;/code&gt; and the absolute value of &lt;code&gt;klen&lt;/code&gt; is the length of the key. If &lt;code&gt;klen&lt;/code&gt; is negative the key is assumed to be in UTF-8-encoded Unicode. The &lt;code&gt;hash&lt;/code&gt; parameter is the precomputed hash value; if it is zero then Perl will compute it.</source>
          <target state="translated">将SV存储在哈希中。哈希密钥被指定为 &lt;code&gt;key&lt;/code&gt; ， &lt;code&gt;klen&lt;/code&gt; 的绝对值是密钥的长度。如果 &lt;code&gt;klen&lt;/code&gt; 为负，则假定密钥为UTF-8编码的Unicode。的 &lt;code&gt;hash&lt;/code&gt; 参数是预先计算的散列值; 如果为零，则Perl将对其进行计算。</target>
        </trans-unit>
        <trans-unit id="d6c29a0065e8b044a53af0ddb9dc3214fa041cf5" translate="yes" xml:space="preserve">
          <source>Stores an SV in an array. The array index is specified as &lt;code&gt;key&lt;/code&gt; . The return value will be NULL if the operation failed or if the value did not need to be actually stored within the array (as in the case of tied arrays). Otherwise, it can be dereferenced to get the &lt;code&gt;SV*&lt;/code&gt; that was stored there (= &lt;code&gt;val&lt;/code&gt; )).</source>
          <target state="translated">将SV存储在数组中。数组索引指定为 &lt;code&gt;key&lt;/code&gt; 。如果操作失败或如果不需要将该值实际存储在数组中（如绑定数组），则返回值为NULL。否则，可以取消引用以获取存储在那里的 &lt;code&gt;SV*&lt;/code&gt; （= &lt;code&gt;val&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7401a972574f8c1665c02fe0802590c81677bf55" translate="yes" xml:space="preserve">
          <source>Stores an alias to a variable in a hash instead of copying the value.</source>
          <target state="translated">在哈希中存储一个变量的别名,而不是复制其值。</target>
        </trans-unit>
        <trans-unit id="9f6711f9c55cd1025cf538a50470266deb723a43" translate="yes" xml:space="preserve">
          <source>Stores results for later output, all together.</source>
          <target state="translated">将结果存储起来,以便以后输出,所有的人都在一起。</target>
        </trans-unit>
        <trans-unit id="ced5e829ffc1318c3116b905b84107c1f3b72848" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$comment&lt;/code&gt; in the COMMENT field in the gzip header. By default, no comment field is written to the gzip file.</source>
          <target state="translated">将 &lt;code&gt;$comment&lt;/code&gt; 的内容存储在gzip标头的COMMENT字段中。默认情况下，没有注释字段写入gzip文件。</target>
        </trans-unit>
        <trans-unit id="26843a54a3aa3332ec1baa3fb76f8c537a96c327" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$comment&lt;/code&gt; in the Central File Header of the zip file.</source>
          <target state="translated">将 &lt;code&gt;$comment&lt;/code&gt; 的内容存储在zip文件的中央文件头中。</target>
        </trans-unit>
        <trans-unit id="f6d27852fc3f996b193528d04367b82db064d418" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$comment&lt;/code&gt; in the End of Central Directory record of the zip file.</source>
          <target state="translated">将 &lt;code&gt;$comment&lt;/code&gt; 的内容存储在zip文件的Central Directory末尾记录中。</target>
        </trans-unit>
        <trans-unit id="24042b8640feee28c4f2a0aafea788776423cdd1" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$string&lt;/code&gt; in the gzip NAME header field. If &lt;code&gt;Name&lt;/code&gt; is not specified, no gzip NAME field will be created.</source>
          <target state="translated">将 &lt;code&gt;$string&lt;/code&gt; 的内容存储在gzip NAME标头字段中。如果未指定 &lt;code&gt;Name&lt;/code&gt; 则不会创建gzip NAME字段。</target>
        </trans-unit>
        <trans-unit id="1023c335a52babfe2f8c4a04c4f2766471fa8387" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$string&lt;/code&gt; in the zip filename header field.</source>
          <target state="translated">将 &lt;code&gt;$string&lt;/code&gt; 的内容存储在zip文件名标题字段中。</target>
        </trans-unit>
        <trans-unit id="51541d8a3d93b2d48a376cb2252ed37ed72421ab" translate="yes" xml:space="preserve">
          <source>Stores the key/value pair in the database.</source>
          <target state="translated">在数据库中存储键/值对。</target>
        </trans-unit>
        <trans-unit id="ab093d23324af52293488a603b3cc3854b181a9e" translate="yes" xml:space="preserve">
          <source>Stores the pad name (which may be null) at the given index, freeing any existing pad name in that slot.</source>
          <target state="translated">在给定的索引中存储垫名(可以是空的),释放该槽中任何现有的垫名。</target>
        </trans-unit>
        <trans-unit id="9d70a29a0f92ba96f998b27b0c51d6b21ce2123e" translate="yes" xml:space="preserve">
          <source>Stores the string &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringifies to. The Perl engine for example stores &lt;code&gt;(?^:eek)&lt;/code&gt; in the case of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/eek/&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">存储字符串 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 字符串化到。例如，在 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/eek/&lt;/a&gt;&lt;/code&gt; 的情况下，Perl引擎存储 &lt;code&gt;(?^:eek)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30082107d90ca21e79e8350f2001678a7dc4b25b" translate="yes" xml:space="preserve">
          <source>Storing data canonically that contains large hashes can be significantly slower than storing the same data normally, as temporary arrays to hold the keys for each hash have to be allocated, populated, sorted and freed. Some tests have shown a halving of the speed of storing -- the exact penalty will depend on the complexity of your data. There is no slowdown on retrieval.</source>
          <target state="translated">以规范的方式存储包含大型散列的数据可能会比正常存储相同的数据要慢得多,因为必须分配、填充、排序和释放用于保存每个散列键的临时数组。一些测试表明,存储的速度减半--具体的惩罚将取决于你的数据的复杂程度。检索速度不会减慢。</target>
        </trans-unit>
        <trans-unit id="2ccce2de5e8ad98636ec0480f8c1e95cb4123766" translate="yes" xml:space="preserve">
          <source>Storing numbers</source>
          <target state="translated">储存数字</target>
        </trans-unit>
        <trans-unit id="408286a7232f91f660936da7835bac0e8863fd20" translate="yes" xml:space="preserve">
          <source>Storing options values in a hash</source>
          <target state="translated">在哈希中存储期权值</target>
        </trans-unit>
        <trans-unit id="5ca11c09231ed950fa4ac2095c30a18383eebf81" translate="yes" xml:space="preserve">
          <source>Storing pre-compiled regexps in an array &lt;code&gt;@compiled&lt;/code&gt; allows us to simply loop through the regexps without any recompilation, thus gaining flexibility without sacrificing speed.</source>
          <target state="translated">将预编译的正则 &lt;code&gt;@compiled&lt;/code&gt; 存储在数组@compiled中，使我们可以简单地循环遍历该正则表达式而无需任何重新编译，从而在不牺牲速度的情况下获得了灵活性。</target>
        </trans-unit>
        <trans-unit id="3e08b2cdc880eca3b63a251507ea23ebf665def8" translate="yes" xml:space="preserve">
          <source>Straightaway we can see that the number of times each line has been called is identical to the &lt;code&gt;Devel::SmallProf&lt;/code&gt; output, and the sequence is only very slightly different based on the ordering of the amount of time each line took to execute, &lt;code&gt;if ( $debug ) { &lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $message = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; , for example. The differences in the actual times recorded might be in the algorithm used internally, or it could be due to system resource limitations or contention.</source>
          <target state="translated">直截了当地，我们可以看到每行被调用的次数与 &lt;code&gt;Devel::SmallProf&lt;/code&gt; 输出相同，并且根据每行执行时间的长短， &lt;code&gt;if ( $debug ) { &lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $message = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; ， 例如。记录的实际时间差异可能是内部使用的算法，也可能是由于系统资源限制或争用所致。</target>
        </trans-unit>
        <trans-unit id="cf5060e04f34c62382f4c8552c1d1cf9f000d47b" translate="yes" xml:space="preserve">
          <source>Strategies for Storing Callback Context Information</source>
          <target state="translated">存储回调上下文信息的策略</target>
        </trans-unit>
        <trans-unit id="813265ea56803a78f3b7159d5fee7e20c7133600" translate="yes" xml:space="preserve">
          <source>Stratus Technologies on the web at &lt;a href=&quot;http://www.stratus.com&quot;&gt;http://www.stratus.com&lt;/a&gt;</source>
          <target state="translated">Web上的Stratus Technologies网址为&lt;a href=&quot;http://www.stratus.com&quot;&gt;http://www.stratus.com&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9e8d1a4aa1f448e22fd91f660943bf3fb47ccc9" translate="yes" xml:space="preserve">
          <source>Stratus VOS 15.1, &lt;a href=&quot;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&quot;&gt;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&lt;/a&gt;</source>
          <target state="translated">Stratus VOS 15.1，&lt;a href=&quot;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&quot;&gt;http:&lt;/a&gt; //stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context = r502-01&amp;amp;file=ch5r502-01bi.html</target>
        </trans-unit>
        <trans-unit id="6dac5050cc8d5226a232897b98c67a79066b8e3a" translate="yes" xml:space="preserve">
          <source>Stream TAP from a Perl executable</source>
          <target state="translated">从Perl可执行文件中流出TAP流</target>
        </trans-unit>
        <trans-unit id="411adcb2712346800a739adfeb9ade95333b1abf" translate="yes" xml:space="preserve">
          <source>Stream TAP from a text file.</source>
          <target state="translated">从文本文件传输TAP。</target>
        </trans-unit>
        <trans-unit id="5517c94f54c087e37e9e39887df00a0c39d682fc" translate="yes" xml:space="preserve">
          <source>Stream TAP from an IO::Handle or a GLOB.</source>
          <target state="translated">从一个IO::Handle或一个GLOB流TAP。</target>
        </trans-unit>
        <trans-unit id="044591cd59e9b7c9396655ff7bb64423112f9b95" translate="yes" xml:space="preserve">
          <source>Stream output from an executable TAP source</source>
          <target state="translated">从可执行的TAP源输出流</target>
        </trans-unit>
        <trans-unit id="137d2933966619b13837102be962efe1a1067d69" translate="yes" xml:space="preserve">
          <source>Stream output from raw TAP in a scalar/array ref.</source>
          <target state="translated">以标量/数组形式从原始TAP中输出的数据流。</target>
        </trans-unit>
        <trans-unit id="79d9a52c246461dc0594d29507cd94db89e5088f" translate="yes" xml:space="preserve">
          <source>Stricter rules help to find typos and other errors. Perhaps you didn't even intend a range here, if the &lt;code&gt;&quot;-&quot;&lt;/code&gt; was meant to be some other character, or should have been escaped (like &lt;code&gt;&quot;\-&quot;&lt;/code&gt; ). If you did intend a range, the one that was used is not portable between ASCII and EBCDIC platforms, and doesn't have an obvious meaning to a casual reader.</source>
          <target state="translated">更严格的规则有助于查找错别字和其他错误。如果 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 是其他字符，或者应该转义（例如 &lt;code&gt;&quot;\-&quot;&lt;/code&gt; ），也许您甚至都没有打算在此指定范围。如果您确实打算使用某个范围，那么所使用的范围就不能在ASCII和EBCDIC平台之间移植，并且对普通读者没有明显的意义。</target>
        </trans-unit>
        <trans-unit id="5eda0deef3d3835356e2633ac9dde47a16b13b5d" translate="yes" xml:space="preserve">
          <source>Stricter rules help to find typos and other errors. You included a range, and at least one of the end points is a decimal digit. Under the stricter rules, when this happens, both end points should be digits in the same group of 10 consecutive digits.</source>
          <target state="translated">更严格的规则有助于发现错别字和其他错误。你包含了一个范围,并且至少有一个端点是小数点。根据更严格的规则,当发生这种情况时,两个端点应该是同一组10个连续数字中的数字。</target>
        </trans-unit>
        <trans-unit id="0650e0c020aef4abbfbd4bda604f404ed598e991" translate="yes" xml:space="preserve">
          <source>Strictly speaking, a program that munches up another program and spits out yet another file containing the program in a &amp;ldquo;more executable&amp;rdquo; form, typically containing native machine instructions. The</source>
          <target state="translated">严格来说，是一种程序，它压缩另一个程序并以&amp;ldquo;更具可执行性&amp;rdquo;的形式吐出另一个包含该程序的文件，该文件通常包含本机指令。的</target>
        </trans-unit>
        <trans-unit id="19287d999efabb7aed57bbe8e78bb9475aab4690" translate="yes" xml:space="preserve">
          <source>Strictly speaking, a program that reads a second program and does what the second program says directly without turning the program into a different form first, which is what &lt;b&gt;compilers&lt;/b&gt; do. Perl is not an interpreter by this definition, because it contains a kind of compiler that takes a program and turns it into a more executable form (&lt;b&gt;syntax trees&lt;/b&gt;) within the</source>
          <target state="translated">严格来说，一个程序读取第二个程序并直接执行第二个程序所说的操作，而无需先将程序转换为其他形式，这就是&lt;b&gt;编译器&lt;/b&gt;所做的。Perl不是此定义的解释器，因为它包含一种编译器，该编译器接受程序并将其转换为更可执行的形式（&lt;b&gt;语法树&lt;/b&gt;）。</target>
        </trans-unit>
        <trans-unit id="a6fde2b9f7e959d871c8af08462a6492339f7057" translate="yes" xml:space="preserve">
          <source>Strictly speaking, nothing. Stylistically speaking, it's not a good way to write maintainable code. Perl has several operators for running external commands. Backticks are one; they collect the output from the command for use in your program. The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; function is another; it doesn't do this.</source>
          <target state="translated">严格来说，没什么。从风格上讲，这不是编写可维护代码的好方法。Perl有多个用于运行外部命令的运算符。反引号是一个；他们从命令中收集输出以在您的程序中使用。该 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 的功能是另一个; 它不会这样做。</target>
        </trans-unit>
        <trans-unit id="95ea50d3a212d751dc75823785ce8d3fc481176b" translate="yes" xml:space="preserve">
          <source>Strictly speaking, the year should be specified in a form consistent with &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, i.e. the offset from 1900. In order to make the interpretation of the year easier for humans, however, who are more accustomed to seeing years as two-digit or four-digit values, the following conventions are followed:</source>
          <target state="translated">严格来说，应该以与 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 一致的格式来指定年份，即与1900的偏移量。为了使人们更容易理解年份，但更习惯于将年份视为两位数或四位数的值，遵循以下约定：</target>
        </trans-unit>
        <trans-unit id="5c4b8f90e8599772141d5d74184d3678eb652f81" translate="yes" xml:space="preserve">
          <source>Strictly, the shell&amp;rsquo;s &lt;code&gt;*&lt;/code&gt; character, which will match a &amp;ldquo;glob&amp;rdquo; of characters when you&amp;rsquo;re trying to generate a list of filenames. Loosely, the act of using globs and similar symbols to do pattern matching. See also &lt;b&gt;fileglob&lt;/b&gt; and &lt;b&gt;typeglob&lt;/b&gt;.</source>
          <target state="translated">严格来说，shell的 &lt;code&gt;*&lt;/code&gt; 字符将与您尝试生成文件名列表时的字符&amp;ldquo; glob&amp;rdquo;匹配。松散地使用glob和类似符号进行模式匹配的行为。另请参见&lt;b&gt;fileglob&lt;/b&gt;和&lt;b&gt;typeglob&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="158127f06e6da3362607fa7cbbba756efc7019b1" translate="yes" xml:space="preserve">
          <source>Strictness and warnings</source>
          <target state="translated">严格性和警告</target>
        </trans-unit>
        <trans-unit id="516c0f4e3c92a494342e3cb25a961d2360643bc2" translate="yes" xml:space="preserve">
          <source>String &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;LC_NUMERIC&lt;/code&gt;</source>
          <target state="translated">字符串 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;LC_NUMERIC&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="322644ec18f089375fd934ccac0ee29b7bf9401a" translate="yes" xml:space="preserve">
          <source>String Collation</source>
          <target state="translated">字符串整理</target>
        </trans-unit>
        <trans-unit id="40837ec372cc75f0a51393ed930c1fe017719b97" translate="yes" xml:space="preserve">
          <source>String Equivalence</source>
          <target state="translated">字符串等价</target>
        </trans-unit>
        <trans-unit id="c0852fa4a49f9a7f054796351af22423733e0ae5" translate="yes" xml:space="preserve">
          <source>String Lengths</source>
          <target state="translated">字符串长度</target>
        </trans-unit>
        <trans-unit id="b231adac90ed5af6e5723df56d210bfd345958ac" translate="yes" xml:space="preserve">
          <source>String Processing, Language Text Processing, Parsing, and Searching</source>
          <target state="translated">字符串处理、语言文字处理、解析和搜索。</target>
        </trans-unit>
        <trans-unit id="f618ca662dfcc3b16eb26b3a99e8a37d3fd5c229" translate="yes" xml:space="preserve">
          <source>String constants that would normally evaluate to 0 or 1 are warned about.</source>
          <target state="translated">字符串常量通常为0或1,会被警告。</target>
        </trans-unit>
        <trans-unit id="6104084e70872a799af75c0c3b3e9c680e29b421" translate="yes" xml:space="preserve">
          <source>String conversion</source>
          <target state="translated">字符串转换</target>
        </trans-unit>
        <trans-unit id="597fe8909ca1928228ff982d52d105d13e058f8b" translate="yes" xml:space="preserve">
          <source>String eval and LC_NUMERIC</source>
          <target state="translated">字符串 eval 和 LC_NUMERIC</target>
        </trans-unit>
        <trans-unit id="860dceea01893fc71bff8d83982d93e598606a4e" translate="yes" xml:space="preserve">
          <source>String handling functions, for the most part, continue to operate in terms of characters. &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt;, for example, returns the number of characters in a string, just as before. But that number no longer is necessarily the same as the number of bytes in the string (there may be more bytes than characters). The other such functions include &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rindex&quot;&gt;rindex()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在大多数情况下，字符串处理功能继续在字符方面运行。例如， &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 返回字符串中的字符数，就像以前一样。但是该数字不再必须与字符串中的字节数相同（字节数多于字符数）。其他此类函数包括 &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/rindex&quot;&gt;rindex()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c329814ec2d3d4971e2511c74b3273f40003742e" translate="yes" xml:space="preserve">
          <source>String interpolation with case-mapping, as in, say, &lt;code&gt;$dest =
&quot;C:\U$name.$ext&quot;&lt;/code&gt; , may produce dangerous results if a bogus &lt;code&gt;LC_CTYPE&lt;/code&gt; case-mapping table is in effect.</source>
          <target state="translated">如果伪造的 &lt;code&gt;LC_CTYPE&lt;/code&gt; 大小写映射表有效，则带有大小写映射的字符串插值（例如 &lt;code&gt;$dest = &quot;C:\U$name.$ext&quot;&lt;/code&gt; ）可能会产生危险的结果。</target>
        </trans-unit>
        <trans-unit id="d6780b9a46b265648d17e144b69c48ee74770992" translate="yes" xml:space="preserve">
          <source>String literals are usually delimited by either single or double quotes. They work much like quotes in the standard Unix shells: double-quoted string literals are subject to backslash and variable substitution; single-quoted strings are not (except for &lt;code&gt;\'&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt; ). The usual C-style backslash rules apply for making characters such as newline, tab, etc., as well as some more exotic forms. See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt; for a list.</source>
          <target state="translated">字符串文字通常用单引号或双引号分隔。它们的工作方式与标准Unix Shell中的引号很像：双引号字符串文字受反斜杠和变量替换的约束；单引号字符串不是（ &lt;code&gt;\'&lt;/code&gt; 和 &lt;code&gt;\\&lt;/code&gt; 除外）。通常的C样式反斜杠规则适用于制作字符，例如换行符，制表符等，以及一些更奇特的形式。有关列表，请参见&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlop&lt;/a&gt;中的Quote和类似Quote的运算符。</target>
        </trans-unit>
        <trans-unit id="b011a78c96a9c16cf6436848fa3f565de97986a2" translate="yes" xml:space="preserve">
          <source>String of options to pass to xsubpp. This might include &lt;code&gt;-C++&lt;/code&gt; or &lt;code&gt;-extern&lt;/code&gt; . Do not include typemaps here; the TYPEMAP parameter exists for that purpose.</source>
          <target state="translated">传递给xsubpp的选项字符串。这可能包括 &lt;code&gt;-C++&lt;/code&gt; 或 &lt;code&gt;-extern&lt;/code&gt; 。不要在此处包括类型映射。为此，存在TYPEMAP参数。</target>
        </trans-unit>
        <trans-unit id="3fec62342425ec8f81ce629d9250491168e3f930" translate="yes" xml:space="preserve">
          <source>String overloaded objects are compared &lt;b&gt;as strings&lt;/b&gt; (or in &lt;code&gt;cmp_ok()&lt;/code&gt; 's case, strings or numbers as appropriate to the comparison op). This prevents Test::More from piercing an object's interface allowing better blackbox testing. So if a function starts returning overloaded objects instead of bare strings your tests won't notice the difference. This is good.</source>
          <target state="translated">将字符串重载对象&lt;b&gt;作为字符串&lt;/b&gt;进行比较（或在 &lt;code&gt;cmp_ok()&lt;/code&gt; 的情况下，将字符串或数字视作比较op的合适对象）。这样可以防止Test :: More穿透对象的界面，从而实现更好的黑盒测试。因此，如果函数开始返回重载对象而不是裸字符串，则您的测试将不会注意到差异。很好</target>
        </trans-unit>
        <trans-unit id="0f00ebea06538bbe227ded196b24216fa175546f" translate="yes" xml:space="preserve">
          <source>String that will be included in the compiler call command line between the arguments INC and OPTIMIZE.</source>
          <target state="translated">将包含在编译器调用命令行中参数INC和OPTIMIZE之间的字符串。</target>
        </trans-unit>
        <trans-unit id="6e526f1a740ace9291b3849106bb71fe9922d6d7" translate="yes" xml:space="preserve">
          <source>String to (long) integer translation. Returns the parsed number and the number of characters in the unparsed portion of the string. Truly POSIX-compliant systems set &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt; ) to indicate a translation error, so clear &lt;code&gt;$!&lt;/code&gt; before calling &lt;code&gt;strtol&lt;/code&gt; . However, non-POSIX systems may not check for overflow, and therefore will never set &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">字符串到（长）整数的转换。返回解析的数字和字符串的未解析部分中的字符数。真正符合POSIX的系统设置 &lt;code&gt;$!&lt;/code&gt; （ &lt;code&gt;$ERRNO&lt;/code&gt; ）表示翻译错误，因此请清除 &lt;code&gt;$!&lt;/code&gt; 在调用 &lt;code&gt;strtol&lt;/code&gt; 之前。但是，非POSIX系统可能不会检查溢出，因此永远不会设置 &lt;code&gt;$!&lt;/code&gt; 。。</target>
        </trans-unit>
        <trans-unit id="f8ad43047bd965bdc4d07f5ce2456ad0a02b96c7" translate="yes" xml:space="preserve">
          <source>String to double translation. Returns the parsed number and the number of characters in the unparsed portion of the string. Truly POSIX-compliant systems set &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt; ) to indicate a translation error, so clear &lt;code&gt;$!&lt;/code&gt; before calling &lt;code&gt;strtod&lt;/code&gt; . However, non-POSIX systems may not check for overflow, and therefore will never set &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">字符串以双重翻译。返回解析的数字和字符串的未解析部分中的字符数。真正符合POSIX的系统设置 &lt;code&gt;$!&lt;/code&gt; （ &lt;code&gt;$ERRNO&lt;/code&gt; ）表示翻译错误，因此请清除 &lt;code&gt;$!&lt;/code&gt; 在调用 &lt;code&gt;strtod&lt;/code&gt; 之前。但是，非POSIX系统可能不会检查溢出，因此永远不会设置 &lt;code&gt;$!&lt;/code&gt; 。。</target>
        </trans-unit>
        <trans-unit id="2abcfc7dcb04cc4aa0bcda4543317ca564702847" translate="yes" xml:space="preserve">
          <source>String to unsigned (long) integer translation. &lt;code&gt;strtoul()&lt;/code&gt; is identical to &lt;code&gt;strtol()&lt;/code&gt; except that &lt;code&gt;strtoul()&lt;/code&gt; only parses unsigned integers. See &lt;a href=&quot;#strtol&quot;&gt;strtol&lt;/a&gt; for details.</source>
          <target state="translated">字符串到无符号（长整数）转换。 &lt;code&gt;strtoul()&lt;/code&gt; 与 &lt;code&gt;strtol()&lt;/code&gt; 相同，除了 &lt;code&gt;strtoul()&lt;/code&gt; 仅解析无符号整数。有关详细信息，请参见&lt;a href=&quot;#strtol&quot;&gt;strtol&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ad6f48bf54709b2ba69a1fce32b7638601bfac7" translate="yes" xml:space="preserve">
          <source>String transformation. Returns the transformed string.</source>
          <target state="translated">字符串转换。返回转换后的字符串。</target>
        </trans-unit>
        <trans-unit id="095d3b7d7b51ca9267c55a71d96ee740ce9ed714" translate="yes" xml:space="preserve">
          <source>String-To-Number Conversions</source>
          <target state="translated">字符串到数字的转换</target>
        </trans-unit>
        <trans-unit id="89f0c9a299c3800ad98959c29c190d1bc9de23ac" translate="yes" xml:space="preserve">
          <source>String. An arbitrary sequence of characters. It is valid for the argument to start with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">串。任意字符序列。参数以 &lt;code&gt;-&lt;/code&gt; 或 &lt;code&gt;--&lt;/code&gt; 开头是有效的。</target>
        </trans-unit>
        <trans-unit id="fafc0f2cb3777e3c850edce9bbb0624fb76d8e93" translate="yes" xml:space="preserve">
          <source>Stringification also destroys arrays.</source>
          <target state="translated">串化也会破坏数组。</target>
        </trans-unit>
        <trans-unit id="a96e53fa801a030d61d0b0afb131453e4a3a7511" translate="yes" xml:space="preserve">
          <source>Stringified perl data structures, suitable for both printing and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">字符串化的perl数据结构，适用于打印和 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bad8926562843b707945e86b277e1f637dc69d2" translate="yes" xml:space="preserve">
          <source>Stringify dumps the data inside the object.</source>
          <target state="translated">Stringify将数据转储到对象内部。</target>
        </trans-unit>
        <trans-unit id="c5cca40b8e6ab951533c16fbbdd8e8eeb9f0e6f8" translate="yes" xml:space="preserve">
          <source>Strings created with &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; can also be manipulated with the logical operators &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt; . These operators will assume a bit vector operation is desired when both operands are strings. See &lt;a href=&quot;perlop#Bitwise-String-Operators&quot;&gt;Bitwise String Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 创建的字符串也可以使用逻辑运算符进行操作 &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; 。当两个操作数均为字符串时，这些运算符将假定需要进行位向量运算。请参见&lt;a href=&quot;perlop#Bitwise-String-Operators&quot;&gt;perlop中的按位字符串运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc0a2fc8d4082ea8e735316dde8d1811abffaf90" translate="yes" xml:space="preserve">
          <source>Strings created with &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; can also be manipulated with the logical operators &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt; . These operators will assume a bit vector operation is desired when both operands are strings. See &lt;a href=&quot;../perlop#Bitwise-String-Operators&quot;&gt;Bitwise String Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 创建的字符串也可以使用逻辑运算符进行操作 &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; 。当两个操作数均为字符串时，这些运算符将假定需要进行位向量运算。请参见&lt;a href=&quot;../perlop#Bitwise-String-Operators&quot;&gt;perlop中的按位字符串运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f7e8a6f87a8a42268a64c6a11af8887059d5680" translate="yes" xml:space="preserve">
          <source>Strings of multiple sub- and superscripts are not recognized as numbers. You can use either of the compatibility decompositions in Unicode::Normalize to change these into digits, and then call &lt;code&gt;num&lt;/code&gt; on the result.</source>
          <target state="translated">多个下标和上标的字符串不能识别为数字。您可以使用Unicode :: Normalize中的任一兼容性分解将其更改为数字，然后对结果调用 &lt;code&gt;num&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7aaa3eb6eac6d4efb6574a9ba9018939acd1f8cf" translate="yes" xml:space="preserve">
          <source>Strings--including hash keys--and regular expression patterns may contain characters that have ordinal values larger than 255.</source>
          <target state="translated">字符串--包括哈希键--和正则表达式模式可能包含序数值大于255的字符。</target>
        </trans-unit>
        <trans-unit id="d6348b5c86af8ba2c83c3a187e28bfcf9f1d038b" translate="yes" xml:space="preserve">
          <source>Stripping Perl Binaries on Cygwin</source>
          <target state="translated">在Cygwin上剥离Perl二进制文件</target>
        </trans-unit>
        <trans-unit id="f9141f854e0e233503d419a0cf18d9153715c039" translate="yes" xml:space="preserve">
          <source>Strongly object-oriented and fully-featured with a long development history and a large community and addon ecosystem. It is excellent for large and complex applications, where you have full control over the server.</source>
          <target state="translated">强大的面向对象,功能齐全,具有悠久的开发历史和庞大的社区和插件生态系统。它非常适合大型复杂的应用,你可以完全控制服务器。</target>
        </trans-unit>
        <trans-unit id="f23a884e110f1886cdc16e896ca93598233740f9" translate="yes" xml:space="preserve">
          <source>Structs are required to be aligned to the maximum alignment required by the fields - which for native types is for usually equivalent to sizeof() of the field</source>
          <target state="translated">结构需要按照字段所要求的最大对齐方式进行对齐--对于本地类型来说,这通常相当于字段的sizeof()。</target>
        </trans-unit>
        <trans-unit id="eb761c94903285d6515bd20e9cd52538249ae83b" translate="yes" xml:space="preserve">
          <source>Structure of a Regexp Program</source>
          <target state="translated">Regexp程序的结构</target>
        </trans-unit>
        <trans-unit id="cd40698b4bb94e939846994c9f9741e198f30bc1" translate="yes" xml:space="preserve">
          <source>Structured data retrieval of perl -V output</source>
          <target state="translated">perl -V输出的结构化数据检索。</target>
        </trans-unit>
        <trans-unit id="b8ce54f7f99cf2cca6626a2de77f397b8065d514" translate="yes" xml:space="preserve">
          <source>Stub that provides thread hook for perl_destruct when there are no threads.</source>
          <target state="translated">当没有线程时,为perl_destruct提供线程钩子的存根。</target>
        </trans-unit>
        <trans-unit id="d8d7cb9c0bd0e5d2e8d74ffc3881bd4b4fc1400b" translate="yes" xml:space="preserve">
          <source>Stubs for Deleted Documents</source>
          <target state="translated">已删除文件的存根</target>
        </trans-unit>
        <trans-unit id="4d7dabe926bb346f9396e40dca4282529b230cab" translate="yes" xml:space="preserve">
          <source>Stuff here is really low-priority to optimize, since it is far better to implement the operation in the low-level math library directly, possible even using a call to the native lib.</source>
          <target state="translated">这里的东西真的是低优先级的优化,因为直接在低级数学库中实现操作要好得多,甚至可以使用对原生库的调用。</target>
        </trans-unit>
        <trans-unit id="2869e1f287c823d9d113fb739c0f867918c01e7c" translate="yes" xml:space="preserve">
          <source>Stuffit Expander</source>
          <target state="translated">Stuffit扩展器</target>
        </trans-unit>
        <trans-unit id="99a0efc6cfd85d8ff2732a6718140f822cb90472" translate="yes" xml:space="preserve">
          <source>Style</source>
          <target state="translated">Style</target>
        </trans-unit>
        <trans-unit id="6f4fae33d407351a21e057015a8cfce97b1d1d2a" translate="yes" xml:space="preserve">
          <source>Subclass</source>
          <target state="translated">Subclass</target>
        </trans-unit>
        <trans-unit id="873c1d3b114c3c8ca9fa8263d71c270acec87256" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;parser/grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt; and customize your parser by setting the &lt;code&gt;grammar_class&lt;/code&gt; parameter. See &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; for more details.</source>
          <target state="translated">子类&lt;a href=&quot;parser/grammar&quot;&gt;TAP :: Parser :: Grammar&lt;/a&gt;并通过设置 &lt;code&gt;grammar_class&lt;/code&gt; 参数来自定义解析器。有关更多详细信息，请参见&lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a88a43bb409ce5ce1ef29fd247b1a667d1a95af9" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; and register your new result type/class with the default &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt;.</source>
          <target state="translated">子类&lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result，&lt;/a&gt;并使用默认的&lt;a href=&quot;parser/resultfactory&quot;&gt;TAP :: Parser :: ResultFactory&lt;/a&gt;注册新的结果类型/类。</target>
        </trans-unit>
        <trans-unit id="b9c1095f48c3aca9e5b044be2e9f7d4aebd28ac4" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt; itself and implement your own &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; creation logic. Then you'll need to customize the class used by your parser by setting the &lt;code&gt;result_factory_class&lt;/code&gt; parameter. See &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; for more details.</source>
          <target state="translated">子类&lt;a href=&quot;parser/resultfactory&quot;&gt;TAP :: Parser :: ResultFactory&lt;/a&gt;本身，并实现自己的&lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;创建逻辑。然后，您需要通过设置 &lt;code&gt;result_factory_class&lt;/code&gt; 参数来自定义解析器使用的类。有关更多详细信息，请参见&lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e73f017d1b2756188610b88957a8f09f27806cab" translate="yes" xml:space="preserve">
          <source>Subclass implementations of this method may wish to invoke the &lt;b&gt;nested()&lt;/b&gt; method of &lt;code&gt;$pod_seq&lt;/code&gt; to see if it is nested inside some other interior-sequence (and if so, which kind).</source>
          <target state="translated">此方法的子类实现可能希望调用 &lt;code&gt;$pod_seq&lt;/code&gt; 的&lt;b&gt;nested（）&lt;/b&gt;方法以查看其是否嵌套在其他内部序列中（如果是，则嵌套在哪种内部序列中）。</target>
        </trans-unit>
        <trans-unit id="206092a8f1bccf21dc1a96fb2aecc7852ff2c2b3" translate="yes" xml:space="preserve">
          <source>Subclass off of ExtUtils::MM_Any</source>
          <target state="translated">从ExtUtils::MM_Any的子类。</target>
        </trans-unit>
        <trans-unit id="c726c3176746b961b1da7788108e104c74c302c2" translate="yes" xml:space="preserve">
          <source>Subclasses will add methods, and will also inherit these methods:</source>
          <target state="translated">子类会增加方法,也会继承这些方法。</target>
        </trans-unit>
        <trans-unit id="f3e2eeeafa90ba07510736c79555f75b3f2683f2" translate="yes" xml:space="preserve">
          <source>Subclassing Math::BigInt</source>
          <target state="translated">子类Math::BigInt</target>
        </trans-unit>
        <trans-unit id="7a1cf3add6a7e4a2dd149344bc26ee4f53a43b6c" translate="yes" xml:space="preserve">
          <source>Subject to include with the message. You will be prompted if you don't supply one on the command line.</source>
          <target state="translated">要包含在信息中的主题,如果你不在命令行中提供一个主题,你会被提示。如果你不在命令行中提供一个主题,你会被提示。</target>
        </trans-unit>
        <trans-unit id="2dacf65959849884a011f36f76a04eebea94c5ea" translate="yes" xml:space="preserve">
          <source>Submit</source>
          <target state="translated">Submit</target>
        </trans-unit>
        <trans-unit id="403bc0e6094ca81cdc2ca6f64a247c639431d231" translate="yes" xml:space="preserve">
          <source>Submit all messages/phrases/etc. to translators.</source>
          <target state="translated">将所有信息/短语/等提交给翻译人员。</target>
        </trans-unit>
        <trans-unit id="740057b8189ca179a92f1c0babad5e8319eb10b8" translate="yes" xml:space="preserve">
          <source>Submitting patches</source>
          <target state="translated">提交补丁</target>
        </trans-unit>
        <trans-unit id="76ef2c6312acb93997fc9533ac9d5fab3c547483" translate="yes" xml:space="preserve">
          <source>Subroutine Attributes</source>
          <target state="translated">子程序属性</target>
        </trans-unit>
        <trans-unit id="e505b9988266048dcf61fcc7b04326e41ac00577" translate="yes" xml:space="preserve">
          <source>Subroutine References as Methods</source>
          <target state="translated">子程序引用作为方法</target>
        </trans-unit>
        <trans-unit id="e0c81de6298b00147539fb1fd776b06104ff3a1b" translate="yes" xml:space="preserve">
          <source>Subroutine Stubs</source>
          <target state="translated">子程序存根</target>
        </trans-unit>
        <trans-unit id="ba2c6bab1119398dcc6fbf96d66f3ef433c36e56" translate="yes" xml:space="preserve">
          <source>Subroutine call to a named capture group. Equivalent to &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt;.</source>
          <target state="translated">对命名捕获组的子例程调用。等效于 &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2db8d18b231e5da42e906ca30c0b2a5d6ae6ff13" translate="yes" xml:space="preserve">
          <source>Subroutine calls and lookups of individual array elements arise often enough that it gets cumbersome to use method 2. As a form of syntactic sugar, the examples for method 2 may be written:</source>
          <target state="translated">子程序的调用和单个数组元素的查找经常出现,以至于使用方法2会很麻烦。作为一种语法糖的形式,方法2的例子可以写成:</target>
        </trans-unit>
        <trans-unit id="2a4b563566baea0b906bb1fd2aafe77f5b8f15d9" translate="yes" xml:space="preserve">
          <source>Subroutine declarations and definitions may optionally have attribute lists associated with them. (Variable &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declarations also may, but see the warning below.) Perl handles these declarations by passing some information about the call site and the thing being declared along with the attribute list to this module. In particular, the first example above is equivalent to the following:</source>
          <target state="translated">子例程声明和定义可以选择具有与之关联的属性列表。（ &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明也可能是变量，但请参见下面的警告。）Perl通过将有关调用站点和要声明的事物的一些信息以及属性列表传递到此模块来处理这些声明。特别地，上面的第一个示例等效于以下示例：</target>
        </trans-unit>
        <trans-unit id="1033729ecd127028ccf3e2aa66d4fd8f486f7da3" translate="yes" xml:space="preserve">
          <source>Subroutine defined.</source>
          <target state="translated">定义了子程序。</target>
        </trans-unit>
        <trans-unit id="d9339f9cd00dee3efa9f7f46ee1ed9f5d6e327f1" translate="yes" xml:space="preserve">
          <source>Subroutine definitions (and declarations, for that matter) need not necessarily be situated in the package whose symbol table they occupy. You can define a subroutine outside its package by explicitly qualifying the name of the subroutine:</source>
          <target state="translated">子程序的定义(以及声明)不一定要位于它们所占用的符号表的包中。你可以通过明确限定子程序的名称,在其包之外定义一个子程序。</target>
        </trans-unit>
        <trans-unit id="e9df428b17a930b0722f07795c93f287fd3afdec" translate="yes" xml:space="preserve">
          <source>Subroutine or method call.</source>
          <target state="translated">子程序或方法调用。</target>
        </trans-unit>
        <trans-unit id="e848b12ba1771594d7f90740383f312abe841d15" translate="yes" xml:space="preserve">
          <source>Subroutine references are the simplest case. When the inclusion system walks through @INC and encounters a subroutine, this subroutine gets called with two parameters, the first a reference to itself, and the second the name of the file to be included (e.g., &quot;</source>
          <target state="translated">子程序引用是最简单的情况。当包含系统走过@INC,遇到一个子程序时,这个子程序会被调用,有两个参数,第一个是对自身的引用,第二个是要包含的文件名(例如,&quot;</target>
        </trans-unit>
        <trans-unit id="b392dcb7d8c01390614814ebacd1c58485fdcd21" translate="yes" xml:space="preserve">
          <source>Subroutines</source>
          <target state="translated">Subroutines</target>
        </trans-unit>
        <trans-unit id="3a9c9397dc48823cce2af70d8aec97a4fb827cbd" translate="yes" xml:space="preserve">
          <source>Subroutines can also return values:</source>
          <target state="translated">子程序也可以返回值。</target>
        </trans-unit>
        <trans-unit id="7cbe2412d3dda1f0b9872899595b0870846f911a" translate="yes" xml:space="preserve">
          <source>Subroutines declarations can also be loaded up with the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement or both loaded and imported into your namespace with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details on this.</source>
          <target state="translated">子例程声明也可以使用 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 语句加载，也可以 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句加载和导入到名称空间中。有关详细信息，请参见&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01b365b15ba275665842a040de4aa6dff221b841" translate="yes" xml:space="preserve">
          <source>Subroutines in multiple packages within the same file are supported - but you should note that this requires exporting the &lt;code&gt;SelfLoader::AUTOLOAD&lt;/code&gt; to every package which requires it. This is done automatically by the &lt;b&gt;SelfLoader&lt;/b&gt; when it first loads the subs into the cache, but you should really specify it in the initialization before the &lt;code&gt;__DATA__&lt;/code&gt; by putting a 'use SelfLoader' statement in each package.</source>
          <target state="translated">支持同一文件中多个包中的子例程-但是您应注意，这需要将 &lt;code&gt;SelfLoader::AUTOLOAD&lt;/code&gt; 导出到每个需要它的包中。这是由&lt;b&gt;SelfLoader&lt;/b&gt;在第一次将子项加载到缓存时自动完成的，但是您实际上应该在 &lt;code&gt;__DATA__&lt;/code&gt; 之前的初始化中通过在每个包中放置'use SelfLoader'语句来指定它。</target>
        </trans-unit>
        <trans-unit id="908bce63fd3bee1510a99f3549ad888c8938e948" translate="yes" xml:space="preserve">
          <source>Subroutines may be called recursively. If a subroutine is called using the &lt;code&gt;&amp;amp;&lt;/code&gt; form, the argument list is optional, and if omitted, no &lt;code&gt;@_&lt;/code&gt; array is set up for the subroutine: the &lt;code&gt;@_&lt;/code&gt; array at the time of the call is visible to subroutine instead. This is an efficiency mechanism that new users may wish to avoid.</source>
          <target state="translated">子例程可以递归调用。如果一个子程序使用被叫 &lt;code&gt;&amp;amp;&lt;/code&gt; 形式，参数列表是可选的，如果省略，没有 &lt;code&gt;@_&lt;/code&gt; 阵列设置为子程序：在 &lt;code&gt;@_&lt;/code&gt; 数组在调用的时候是可见的，而不是子程序。这是新用户可能希望避免的效率机制。</target>
        </trans-unit>
        <trans-unit id="cda2b08c81beb1e8e27be40c69e142c7b306247c" translate="yes" xml:space="preserve">
          <source>Subroutines used with ExtUtils::ParseXS</source>
          <target state="translated">与ExtUtils::ParseXS一起使用的子程序。</target>
        </trans-unit>
        <trans-unit id="3f753412893b86e74de31ef62203854e630f7671" translate="yes" xml:space="preserve">
          <source>Subroutines whose names are in all upper case are reserved to the Perl core, as are modules whose names are in all lower case. A subroutine in all capitals is a loosely-held convention meaning it will be called indirectly by the run-time system itself, usually due to a triggered event. Subroutines whose name start with a left parenthesis are also reserved the same way. The following is a list of some subroutines that currently do special, pre-defined things.</source>
          <target state="translated">名称全部为大写的子程序是保留给Perl核心的,名称全部为小写的模块也是如此。全大写的子程序是一个松散的惯例,意味着它将被运行时系统本身间接调用,通常是由于一个触发事件。名字以左括号开头的子程序也是这样保留的。下面是一些目前做特殊的、预先定义的子程序的列表。</target>
        </trans-unit>
        <trans-unit id="bd995cb059355e488a61a605eadaa870990fb34e" translate="yes" xml:space="preserve">
          <source>Subscribe to perl5-porters, follow the patches and try and understand them; don't be afraid to ask if there's a portion you're not clear on - who knows, you may unearth a bug in the patch...</source>
          <target state="translated">订阅 perl5-porters,关注补丁并试着去理解它们;如果有不清楚的地方,不要害怕去问--谁知道呢,你可能会在补丁中发现一个 bug......</target>
        </trans-unit>
        <trans-unit id="a9be04fdf20dd61cb8df7236630151f2b739230f" translate="yes" xml:space="preserve">
          <source>Subscribers to perl5-porters (the porters themselves) come in several flavours. Some are quiet curious lurkers, who rarely pitch in and instead watch the ongoing development to ensure they're forewarned of new changes or features in Perl. Some are representatives of vendors, who are there to make sure that Perl continues to compile and work on their platforms. Some patch any reported bug that they know how to fix, some are actively patching their pet area (threads, Win32, the regexp -engine), while others seem to do nothing but complain. In other words, it's your usual mix of technical people.</source>
          <target state="translated">perl5-porters 的订阅者 (porters 本身)有好几种口味。有些人是安静的好奇爱好者,他们很少参与,而是观察正在进行的开发工作,以确保他们能够预先了解 Perl 的新变化或功能。有些人是供应商的代表,他们的目的是确保 Perl 能够继续在他们的平台上编译和工作。有些人给他们知道如何修复的任何报告的bug打补丁,有些人积极地给他们的宠物领域打补丁(线程、Win32、regexp -engine),而有些人似乎除了抱怨什么也不做。换句话说,这就是通常的技术人员的组合。</target>
        </trans-unit>
        <trans-unit id="4ce7140689363704a8ba85b5261797d063cdadf8" translate="yes" xml:space="preserve">
          <source>Subscripts</source>
          <target state="translated">Subscripts</target>
        </trans-unit>
        <trans-unit id="972581919796c696d3887a640cd0abc4a9d6fe2f" translate="yes" xml:space="preserve">
          <source>Substitute &lt;code&gt;mmk&lt;/code&gt; for &lt;code&gt;mms&lt;/code&gt; above if you're using MMK.</source>
          <target state="translated">如果您使用的是MMK，请将 &lt;code&gt;mmk&lt;/code&gt; 替换为以上的 &lt;code&gt;mms&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="014d5a9e6f1c5bae7a50cda20695fb756eee0cc0" translate="yes" xml:space="preserve">
          <source>Substitution of &lt;code&gt;BEGIN { add_100() }&lt;/code&gt; block with:</source>
          <target state="translated">将 &lt;code&gt;BEGIN { add_100() }&lt;/code&gt; 块替换为：</target>
        </trans-unit>
        <trans-unit id="821f56dfe7408535081734d464b6578d0a9340e7" translate="yes" xml:space="preserve">
          <source>Substitution-specific modifiers described in</source>
          <target state="translated">中所述的特定替换修饰剂</target>
        </trans-unit>
        <trans-unit id="a85608dfc0000ff615c1dec302e3be9c2df7837d" translate="yes" xml:space="preserve">
          <source>Substitutions are made with $col and $row in the output string with the following sprintf() line formats:</source>
          <target state="translated">在输出字符串中用$col和$row进行替换,格式如下printf()行。</target>
        </trans-unit>
        <trans-unit id="e9a34939ee76bec97fd549a9a6b322c326e9dbba" translate="yes" xml:space="preserve">
          <source>Substring data about strings that must appear in the final match. This is currently only used internally by Perl's engine, but might be used in the future for all engines for optimisations.</source>
          <target state="translated">关于最终匹配中必须出现的字符串的子串数据。目前只有Perl引擎内部使用,但将来可能会用于所有引擎的优化。</target>
        </trans-unit>
        <trans-unit id="3de3a6f2fafae521ea8d2aedc747771ba7ff68a0" translate="yes" xml:space="preserve">
          <source>Subtests were released in Test::More 0.94, which came with Perl 5.12.0. Subtests did not implicitly call &lt;code&gt;done_testing()&lt;/code&gt; until 0.96; the first Perl with that fix was Perl 5.14.0 with 0.98.</source>
          <target state="translated">子测试在Test :: More 0.94中发布，它随Perl 5.12.0一起提供。子 &lt;code&gt;done_testing()&lt;/code&gt; 直到0.96 才隐式调用done_testing（）。具有此修复程序的第一个Perl是带有0.98的Perl 5.14.0。</target>
        </trans-unit>
        <trans-unit id="8a773e71238655167a41521fa50857f3f27293a6" translate="yes" xml:space="preserve">
          <source>Subtleties of this behavior may be platform-dependent and may change in the future.</source>
          <target state="translated">这种行为的细微之处可能会依赖于平台,未来可能会改变。</target>
        </trans-unit>
        <trans-unit id="ae5f61e523ef194692c08eae320b323a03f8bb9b" translate="yes" xml:space="preserve">
          <source>Subtract</source>
          <target state="translated">Subtract</target>
        </trans-unit>
        <trans-unit id="a1c757fe97bd3bdc11456c873d4a95f5772e2115" translate="yes" xml:space="preserve">
          <source>Success results contain:</source>
          <target state="translated">成功的结果包含:</target>
        </trans-unit>
        <trans-unit id="f918892a0be28ec22ae2148c6c8b20e089383319" translate="yes" xml:space="preserve">
          <source>Successes</source>
          <target state="translated">Successes</target>
        </trans-unit>
        <trans-unit id="9f13946904481800a60a2508acdf81d63816cbc9" translate="yes" xml:space="preserve">
          <source>Successfully tested means that all &quot;make test&quot; runs finish with a result of 100% OK. All tests were conducted with -Duseshrplib set.</source>
          <target state="translated">成功测试意味着所有的 &quot;make test &quot;运行结果都是100% OK。所有测试都是在-Duseshrplib设置下进行的。</target>
        </trans-unit>
        <trans-unit id="acd9d5af15f64c17e2970ba3b3a2889b142e6fb0" translate="yes" xml:space="preserve">
          <source>Such QP strings can be decoded with:</source>
          <target state="translated">这样的QP字符串可以用以下方法解码。</target>
        </trans-unit>
        <trans-unit id="9bd751ae4548def6edde9b711d0020609ff568b3" translate="yes" xml:space="preserve">
          <source>Such code no longer has the desired effect, for two reasons. Firstly, the use of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; means that the sorting algorithm is not changed until runtime, by which time it's too late to have any effect. Secondly, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; is also called at run-time, when in fact the compile-time value of &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; is the one that matters.</source>
          <target state="translated">由于两个原因，这样的代码不再具有预期的效果。首先，使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 意味着排序算法要等到运行时才能更改，到那时它已为时已晚而没有任何效果。其次， &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; 在运行时也被调用，而事实上 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; 的编译时值很重要。</target>
        </trans-unit>
        <trans-unit id="69ef159fceda5830f0aa82ac39ad009b226aeb52" translate="yes" xml:space="preserve">
          <source>Such combinations can include alternatives, leading to a problem of choice: if we match a regular expression &lt;code&gt;a|ab&lt;/code&gt; against &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , will it match substring &lt;code&gt;&quot;a&quot;&lt;/code&gt; or &lt;code&gt;&quot;ab&quot;&lt;/code&gt; ? One way to describe which substring is actually matched is the concept of backtracking (see &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;). However, this description is too low-level and makes you think in terms of a particular implementation.</source>
          <target state="translated">这样的组合可能包含其他选择，从而导致选择问题：如果我们将正则表达式 &lt;code&gt;a|ab&lt;/code&gt; 与 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 匹配，它将匹配子字符串 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;ab&quot;&lt;/code&gt; 吗？描述实际匹配哪个子字符串的一种方法是回溯的概念（请参阅&lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;）。但是，此描述太底层了，使您需要考虑特定的实现。</target>
        </trans-unit>
        <trans-unit id="54d1b0795c68a81e9549d343de87babe2d5446e2" translate="yes" xml:space="preserve">
          <source>Such commands are explained in the &quot;&lt;a href=&quot;#Formatting-Codes&quot;&gt;Formatting Codes&lt;/a&gt;&quot; section, below.</source>
          <target state="translated">此类命令在下面的&amp;ldquo; &lt;a href=&quot;#Formatting-Codes&quot;&gt;格式代码&lt;/a&gt; &amp;rdquo;部分中进行了说明。</target>
        </trans-unit>
        <trans-unit id="610620ff68fcfedc9e4625433127c1fd73d100c6" translate="yes" xml:space="preserve">
          <source>Such constructs are quite frequently used, both because older versions of Perl had no official &lt;code&gt;switch&lt;/code&gt; statement, and also because the new version described immediately below remains experimental and can sometimes be confusing.</source>
          <target state="translated">之所以会经常使用这样的结构，是因为Perl的旧版本没有正式的 &lt;code&gt;switch&lt;/code&gt; 语句，也因为下面立即描述的新版本仍处于试验阶段，有时会造成混淆。</target>
        </trans-unit>
        <trans-unit id="ea3348659ce40b97978cb89e7a2d2a3c12e7d561" translate="yes" xml:space="preserve">
          <source>Such dangers are not peculiar to the locale system: any aspect of an application's environment which may be modified maliciously presents similar challenges. Similarly, they are not specific to Perl: any programming language that allows you to write programs that take account of their environment exposes you to these issues.</source>
          <target state="translated">这种危险并不是locale系统所特有的:应用程序环境中任何可能被恶意修改的方面都会带来类似的挑战。同样,它们也不是Perl所特有的:任何允许你编写考虑到环境的程序的编程语言都会让你面临这些问题。</target>
        </trans-unit>
        <trans-unit id="92e64e08c8f255e5e8a21829e9acd359d7cc7e25" translate="yes" xml:space="preserve">
          <source>Such literals are accepted by both &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; for doing a version check. Note that using the v-strings for IPv4 addresses is not portable unless you also use the inet_aton()/inet_ntoa() routines of the Socket package.</source>
          <target state="translated">这样的文字被接受都 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 做一个版本检查。请注意，除非您也使用Socket程序包的inet_aton（）/ inet_ntoa（）例程，否则将v字符串用于IPv4地址是不可移植的。</target>
        </trans-unit>
        <trans-unit id="c45d151cfb183e258e5e363109f24149b1db62ae" translate="yes" xml:space="preserve">
          <source>Such modules should</source>
          <target state="translated">这些模块应</target>
        </trans-unit>
        <trans-unit id="7aa5a2112d8e6f60d9221533518e8ad273984dab" translate="yes" xml:space="preserve">
          <source>Such things aside, you can see that a lot can be achieved with a modest amount of code.</source>
          <target state="translated">抛开这样的事情不谈,你可以看到,用少量的代码可以实现很多东西。</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="625d4a750d30cd6f4ad0513fdf02b0a356847795" translate="yes" xml:space="preserve">
          <source>Summary Results</source>
          <target state="translated">结果摘要</target>
        </trans-unit>
        <trans-unit id="64d8f92a0739a61061673d891b1afa8db3bbc87d" translate="yes" xml:space="preserve">
          <source>Summary methods</source>
          <target state="translated">简要方法</target>
        </trans-unit>
        <trans-unit id="bbeaa09c87f3637cdf1095b67ab5a263e83c735c" translate="yes" xml:space="preserve">
          <source>Summary of Option Specifications</source>
          <target state="translated">选项规格摘要</target>
        </trans-unit>
        <trans-unit id="90bd8a629095e4d3e067b9ee655f4a7aef77fe44" translate="yes" xml:space="preserve">
          <source>Summary: &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; and installing the Developer Tools would be good.</source>
          <target state="translated">摘要： &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; 并安装开发人员工具会很好。</target>
        </trans-unit>
        <trans-unit id="fac6a1b8f230cdc10fcc15f1e97d9ef7d5b8d095" translate="yes" xml:space="preserve">
          <source>Summary: &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; and you need &lt;code&gt;-lbfd&lt;/code&gt; .</source>
          <target state="translated">摘要： &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; 然后需要 &lt;code&gt;-lbfd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d4dd97ceb3548f78756cbaa9fdb900f6de48597" translate="yes" xml:space="preserve">
          <source>Summing up, Perl numeric values can store only those numbers which have a finite decimal expansion or a &quot;short&quot; binary expansion.</source>
          <target state="translated">综上所述,Perl数值只能存储那些具有有限十进制扩展或 &quot;短 &quot;二进制扩展的数字。</target>
        </trans-unit>
        <trans-unit id="6f2aaceda628f6be2c51aa728019480822a4776e" translate="yes" xml:space="preserve">
          <source>Sun Microsystems has released a port of their Sun Studio compilers for Linux. As of November 2005, only an alpha version has been released. Until a release of these compilers is made, support for compiling Perl with these compiler experimental.</source>
          <target state="translated">Sun Microsystems公司已经发布了他们的Sun Studio编译器的Linux移植版。截至2005年11月,只发布了一个alpha版本。在这些编译器发布之前,支持用这些编译器实验性地编译Perl。</target>
        </trans-unit>
        <trans-unit id="c878825d39958359a72cd8a76c4798d5c63452e1" translate="yes" xml:space="preserve">
          <source>Sun and GNU make</source>
          <target state="translated">太阳与GNU合作</target>
        </trans-unit>
        <trans-unit id="718d79465fef1629218681af768f2453685f48a1" translate="yes" xml:space="preserve">
          <source>Sun's C Compiler</source>
          <target state="translated">Sun公司的C编译器</target>
        </trans-unit>
        <trans-unit id="6195b0f6879010bbee2ff42c95d1331cc047feb8" translate="yes" xml:space="preserve">
          <source>SunOS 4.x</source>
          <target state="translated">SunOS 4.x</target>
        </trans-unit>
        <trans-unit id="e16d86479fe3fa44742384e85cda27574322cbc3" translate="yes" xml:space="preserve">
          <source>Supply a comparison function to sort() (described in &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;):</source>
          <target state="translated">为sort（）提供一个比较函数（在&lt;a href=&quot;functions/sort&quot;&gt;sort中&lt;/a&gt;描述）：</target>
        </trans-unit>
        <trans-unit id="de415e5d5000869495451db35dc93df656397ea8" translate="yes" xml:space="preserve">
          <source>Supply a password. If this token is present, the auto-login process will supply the specified string if the remote server requires a password as part of the login process.</source>
          <target state="translated">提供一个密码,如果有这个标记,当远程服务器需要密码时,自动登录过程将提供指定的字符串。如果这个标记存在,如果远程服务器需要密码作为登录过程的一部分,自动登录过程将提供指定的字符串。</target>
        </trans-unit>
        <trans-unit id="2b5e575cc764d4329007cce80f84811dda7921d8" translate="yes" xml:space="preserve">
          <source>Supply an additional account password. If this token is present, the auto-login process will supply the specified string if the remote server requires an additional account password.</source>
          <target state="translated">提供一个额外的账户密码。如果存在这个标记,如果远程服务器需要额外的账户密码,自动登录进程将提供指定的字符串。</target>
        </trans-unit>
        <trans-unit id="63bb1d0a1fc152b9571b2b05084b5b7573c0a7dc" translate="yes" xml:space="preserve">
          <source>Supply object methods for I/O handles</source>
          <target state="translated">为I/O句柄提供对象方法</target>
        </trans-unit>
        <trans-unit id="e754d6f0995eab7526c2995e6dd29fc5213bbe9f" translate="yes" xml:space="preserve">
          <source>Supply object methods for directory handles</source>
          <target state="translated">为目录句柄提供对象方法</target>
        </trans-unit>
        <trans-unit id="9f22ffa5d56d4c5cfa232e27b220356c8959032d" translate="yes" xml:space="preserve">
          <source>Supply object methods for filehandles</source>
          <target state="translated">为filehandles提供对象方法</target>
        </trans-unit>
        <trans-unit id="b2a77c0ef03836a7333e41ce4f0c7055106ac057" translate="yes" xml:space="preserve">
          <source>Supply object methods for pipes</source>
          <target state="translated">为管道提供对象方法</target>
        </trans-unit>
        <trans-unit id="24f8675a681a3fcf0a19ce2f457ac46639a461cc" translate="yes" xml:space="preserve">
          <source>Supply seek based methods for I/O objects</source>
          <target state="translated">为I/O对象提供基于寻求的方法</target>
        </trans-unit>
        <trans-unit id="4577ee52f9d606e12ad2fa9f7ea83ec15081ff52" translate="yes" xml:space="preserve">
          <source>Supplying a count to the</source>
          <target state="translated">提供一个计数给</target>
        </trans-unit>
        <trans-unit id="9256abeb61b0e9c2634b93f868b22e3b6be3e559" translate="yes" xml:space="preserve">
          <source>Support for 64-bit Windows added in 5.8 (ActiveState Corp).</source>
          <target state="translated">在5.8中增加了对64位Windows的支持(ActiveState公司)。</target>
        </trans-unit>
        <trans-unit id="832ef41556695f42d002862c25aa7f6927ea5c9c" translate="yes" xml:space="preserve">
          <source>Support for 64-bit addressing is experimental: some aspects of Perl may be omitted or buggy. Note the messages output by</source>
          <target state="translated">对64位寻址的支持是试验性的:Perl的某些方面可能会被省略或出现错误。请注意由</target>
        </trans-unit>
        <trans-unit id="dfd649a90bcb497a90c270b395e1aca8e9f13d5a" translate="yes" xml:space="preserve">
          <source>Support for Inside-Out Classes</source>
          <target state="translated">对内外班的支持</target>
        </trans-unit>
        <trans-unit id="f74542dacfa191bd88d61863d9855931e106e4c3" translate="yes" xml:space="preserve">
          <source>Support for PERL_OBJECT was added in 5.005 (ActiveState Tool Corp).</source>
          <target state="translated">在5.005中增加了对PERL_OBJECT的支持(ActiveState Tool Corp)。</target>
        </trans-unit>
        <trans-unit id="4152d06f964d8c8500926a55fcc080decb5f3944" translate="yes" xml:space="preserve">
          <source>Support for code 3 (italic) is rare and therefore not mentioned in that table. It is not believed to be fully supported by any of the terminals listed, although it's displayed as green in the Linux console, but it is reportedly supported by urxvt.</source>
          <target state="translated">对代码3(斜体)的支持很少,因此该表中没有提到。虽然在Linux控制台中显示为绿色,但据说urxvt支持它,但据信没有任何一种终端完全支持它。</target>
        </trans-unit>
        <trans-unit id="d13a3104d38bfebd2d8edefc71bb43ed89c25719" translate="yes" xml:space="preserve">
          <source>Support for colors 16 through 256 (the &lt;code&gt;ansi&lt;/code&gt; , &lt;code&gt;rgb&lt;/code&gt; , and &lt;code&gt;grey&lt;/code&gt; colors), the &lt;code&gt;:constants256&lt;/code&gt; import tag, the coloralias() function, and support for the ANSI_COLORS_ALIASES environment variable were added in Term::ANSIColor 4.00, included in Perl 5.17.8.</source>
          <target state="translated">Perl 5.17中包含的Term :: ANSIColor 4.00中增加了对颜色16至256（ &lt;code&gt;ansi&lt;/code&gt; ， &lt;code&gt;rgb&lt;/code&gt; 和 &lt;code&gt;grey&lt;/code&gt; ）的支持， &lt;code&gt;:constants256&lt;/code&gt; 导入标记，coloralias（）函数以及对ANSI_COLORS_ALIASES环境变量的支持。 8。</target>
        </trans-unit>
        <trans-unit id="c9d79655477c957d3ded48d250eed51bd3ecf8ff" translate="yes" xml:space="preserve">
          <source>Support for colors 8 through 15 (the &lt;code&gt;bright_&lt;/code&gt; variants) was added in Term::ANSIColor 3.00, included in Perl 5.13.3.</source>
          <target state="translated">Perl 5.13.3中包含的Term :: ANSIColor 3.00中增加了对颜色8至15（ &lt;code&gt;bright_&lt;/code&gt; 变体）的支持。</target>
        </trans-unit>
        <trans-unit id="3520e7db85802558bb1d2a5a7277d73d6dd7678b" translate="yes" xml:space="preserve">
          <source>Support for concurrent interpreters and the fork() emulation was implemented by ActiveState, with funding from Microsoft Corporation.</source>
          <target state="translated">在微软公司的资助下,ActiveState实现了对并发解释器和fork()仿真的支持。</target>
        </trans-unit>
        <trans-unit id="46d9a08c8fe0a5fa65df6f50206b3d6f86276cea" translate="yes" xml:space="preserve">
          <source>Support for dark was added in Term::ANSIColor 1.08, included in Perl 5.8.4.</source>
          <target state="translated">在 Term::ANSIColor 1.08 中增加了对 dark 的支持,包含在 Perl 5.8.4 中。</target>
        </trans-unit>
        <trans-unit id="13c3f3679453dc21cf99ba9668b08821dc7c3536" translate="yes" xml:space="preserve">
          <source>Support for external gzip added by Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">Jarkko Hietaniemi添加的对外部gzip的支持&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c1d15c06235a8f38ea6479c09486fef84b83b91c" translate="yes" xml:space="preserve">
          <source>Support for fork() emulation was added in 5.6 (ActiveState Tool Corp).</source>
          <target state="translated">在5.6中增加了对fork()仿真的支持(ActiveState Tool Corp)。</target>
        </trans-unit>
        <trans-unit id="4da419edd1ac30a4a7b7cbe60b1ff8e03675397f" translate="yes" xml:space="preserve">
          <source>Support for globally overriding glob() (GSAR 3-JUN-98)</source>
          <target state="translated">支持全局覆盖 glob()(GSAR 3-JUN-98)</target>
        </trans-unit>
        <trans-unit id="52d4e9ac29525e6d8e33903392c09e0782a71a40" translate="yes" xml:space="preserve">
          <source>Support for italic was added in Term::ANSIColor 3.02, included in Perl 5.17.1.</source>
          <target state="translated">在 Perl 5.17.1 中的 Term::ANSIColor 3.02 中加入了对斜体的支持。</target>
        </trans-unit>
        <trans-unit id="0fee3b6033badb5f9d6b2ad7b4bd90ed22c35a68" translate="yes" xml:space="preserve">
          <source>Support for swapping real and effective user and group IDs is incomplete. On WinNT Cygwin provides &lt;code&gt;setuid()&lt;/code&gt; , &lt;code&gt;seteuid()&lt;/code&gt; , &lt;code&gt;setgid()&lt;/code&gt; and &lt;code&gt;setegid()&lt;/code&gt; . However, additional Cygwin calls for manipulating WinNT access tokens and security contexts are required.</source>
          <target state="translated">支持交换真实有效用户和组ID的支持不完整。在WinNT上，Cygwin提供 &lt;code&gt;setuid()&lt;/code&gt; ， &lt;code&gt;seteuid()&lt;/code&gt; ， &lt;code&gt;setgid()&lt;/code&gt; 和 &lt;code&gt;setegid()&lt;/code&gt; 。但是，需要额外的Cygwin调用来操纵WinNT访问令牌和安全上下文。</target>
        </trans-unit>
        <trans-unit id="112d45f23a800f84de37770824448a89f7d793b8" translate="yes" xml:space="preserve">
          <source>Support for this module is provided via the datetime@perl.org email list. See &lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt; for more details.</source>
          <target state="translated">通过datetime@perl.org电子邮件列表提供了对该模块的支持。有关更多详细信息，请参见&lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="75b47c288b94e063b5e848ebb4c141831f2f842b" translate="yes" xml:space="preserve">
          <source>Support for threads extends beyond the code in this module (i.e.,</source>
          <target state="translated">对线程的支持超出了本模块的代码范围(即。</target>
        </trans-unit>
        <trans-unit id="4ebd54c9803d67645a6bec6e8a530fc77962d822" translate="yes" xml:space="preserve">
          <source>Supported Colors</source>
          <target state="translated">支持的颜色</target>
        </trans-unit>
        <trans-unit id="a65b7f12a991185f44b505808bc867e90d749e20" translate="yes" xml:space="preserve">
          <source>Supported Compilers</source>
          <target state="translated">支持的编译器</target>
        </trans-unit>
        <trans-unit id="1a182e900ad0b28f084dbe30c2f1ab8dc81f123a" translate="yes" xml:space="preserve">
          <source>Supported Platforms</source>
          <target state="translated">支持平台</target>
        </trans-unit>
        <trans-unit id="49b953a7424bb44dd08394b0aeda11553bb12089" translate="yes" xml:space="preserve">
          <source>Supported Platforms (Perl 5.8)</source>
          <target state="translated">支持的平台 (Perl 5.8)</target>
        </trans-unit>
        <trans-unit id="b1429d26115432e6f40c246dd70a7c60030a0632" translate="yes" xml:space="preserve">
          <source>Supported are: &lt;code&gt;build_requires_install_policy&lt;/code&gt; , &lt;code&gt;check_sigs&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;make_install_make_command&lt;/code&gt; , &lt;code&gt;prefer_installer&lt;/code&gt; , &lt;code&gt;test_report&lt;/code&gt; . Please report as a bug when you need another one supported.</source>
          <target state="translated">支持的对象包括： &lt;code&gt;build_requires_install_policy&lt;/code&gt; ， &lt;code&gt;check_sigs&lt;/code&gt; ， &lt;code&gt;make&lt;/code&gt; ， &lt;code&gt;make_install_make_command&lt;/code&gt; ， &lt;code&gt;prefer_installer&lt;/code&gt; ， &lt;code&gt;test_report&lt;/code&gt; 。如果您需要另一个支持，请作为错误报告。</target>
        </trans-unit>
        <trans-unit id="fef4367afdb333ca61c98475adcf339702a0de4a" translate="yes" xml:space="preserve">
          <source>Supported arguments are the same as for C</source>
          <target state="translated">支持的参数与C语言相同</target>
        </trans-unit>
        <trans-unit id="0aee30f240e3b0641c58b8ea19a5ce4e73c13514" translate="yes" xml:space="preserve">
          <source>Supported versions of Perl</source>
          <target state="translated">支持的Perl版本</target>
        </trans-unit>
        <trans-unit id="4ab85bed1d3b1a215699ee5c1c8be8f331ffab56" translate="yes" xml:space="preserve">
          <source>Supports the same options as the C</source>
          <target state="translated">支持与C语言相同的选项</target>
        </trans-unit>
        <trans-unit id="68a10bfa60258c2bbfe38e9f1a7ff60f4694f8f6" translate="yes" xml:space="preserve">
          <source>Suppose instead, that if no matching &quot;/endpara&quot; tag is found, the &quot;/para&quot; tag refers only to the immediately following paragraph:</source>
          <target state="translated">假设没有找到匹配的&quot;/endpara &quot;标签,则&quot;/para &quot;标签仅指紧接着的段落。</target>
        </trans-unit>
        <trans-unit id="4a2e98ea3f847f379e1d62458409b455691002c8" translate="yes" xml:space="preserve">
          <source>Suppose that for some strange reason we need a wrapper around the standard C library function &lt;code&gt;fputs()&lt;/code&gt; . This is all we need:</source>
          <target state="translated">假设出于某种奇怪的原因，我们需要在标准C库函数 &lt;code&gt;fputs()&lt;/code&gt; 周围进行包装。这就是我们所需要的：</target>
        </trans-unit>
        <trans-unit id="e9713a66e131c3277390fd2e0a638134463da779" translate="yes" xml:space="preserve">
          <source>Suppose that in the previous example functions pointers for multiply(), divide(), add(), subtract() are kept in a global C array &lt;code&gt;fp[]&lt;/code&gt; with offsets being &lt;code&gt;multiply_off&lt;/code&gt; , &lt;code&gt;divide_off&lt;/code&gt; , &lt;code&gt;add_off&lt;/code&gt; , &lt;code&gt;subtract_off&lt;/code&gt; . Then one can use</source>
          <target state="translated">假设在前面的示例函数中，multiple（），divide（），add（），subtract（）的指针保存在全局C数组 &lt;code&gt;fp[]&lt;/code&gt; ，其偏移量为 &lt;code&gt;multiply_off&lt;/code&gt; ， &lt;code&gt;divide_off&lt;/code&gt; ， &lt;code&gt;add_off&lt;/code&gt; ， &lt;code&gt;subtract_off&lt;/code&gt; 。然后可以使用</target>
        </trans-unit>
        <trans-unit id="f6b728cf8454bb8ebd395d51ef450a37f61ee3df" translate="yes" xml:space="preserve">
          <source>Suppose that we want to enable a new RE escape-sequence &lt;code&gt;\Y|&lt;/code&gt; which matches at a boundary between whitespace characters and non-whitespace characters. Note that &lt;code&gt;(?=\S)(?&amp;lt;!\S)|(?!\S)(?&amp;lt;=\S)&lt;/code&gt; matches exactly at these positions, so we want to have each &lt;code&gt;\Y|&lt;/code&gt; in the place of the more complicated version. We can create a module &lt;code&gt;customre&lt;/code&gt; to do this:</source>
          <target state="translated">假设我们要启用一个新的RE转义序列 &lt;code&gt;\Y|&lt;/code&gt; 在空白字符和非空白字符之间的边界处匹配。注意 &lt;code&gt;(?=\S)(?&amp;lt;!\S)|(?!\S)(?&amp;lt;=\S)&lt;/code&gt; 在这些位置上完全匹配，因此我们希望每个 &lt;code&gt;\Y|&lt;/code&gt; 代替更复杂的版本。我们可以创建一个模块 &lt;code&gt;customre&lt;/code&gt; 来做到这一点：</target>
        </trans-unit>
        <trans-unit id="5ab2eaff078de5c28b462a36a77339cffbb8f320" translate="yes" xml:space="preserve">
          <source>Suppose that you have some C files implementing some functionality, and the corresponding header files. How to create an extension which makes this functionality accessible in Perl? The example below assumes that the header files are</source>
          <target state="translated">假设你有一些实现某些功能的C文件,以及相应的头文件。如何创建一个扩展,使这些功能在Perl中可以访问?下面的例子假设头文件为</target>
        </trans-unit>
        <trans-unit id="e38ce69c0f981610bad14796ceb31eadf517ce86" translate="yes" xml:space="preserve">
          <source>Suppose you want to create an object which is accessible as both an array reference and a hash reference.</source>
          <target state="translated">假设你想创建一个既可以作为数组引用又可以作为哈希引用访问的对象。</target>
        </trans-unit>
        <trans-unit id="abacd026fc80e9051241fe69f59c13539803bbd4" translate="yes" xml:space="preserve">
          <source>Suppose you want to match all of consecutive pairs of digits in a string like &quot;1122a44&quot; and stop matching when you encounter non-digits. You want to match &lt;code&gt;11&lt;/code&gt; and &lt;code&gt;22&lt;/code&gt; but the letter &amp;lt;a&amp;gt; shows up between &lt;code&gt;22&lt;/code&gt; and &lt;code&gt;44&lt;/code&gt; and you want to stop at &lt;code&gt;a&lt;/code&gt; . Simply matching pairs of digits skips over the &lt;code&gt;a&lt;/code&gt; and still matches &lt;code&gt;44&lt;/code&gt; .</source>
          <target state="translated">假设您要匹配字符串&amp;ldquo; 1122a44&amp;rdquo;中的所有连续数字对，并在遇到非数字时停止匹配。您想匹配 &lt;code&gt;11&lt;/code&gt; 和 &lt;code&gt;22&lt;/code&gt; ,但是字母&amp;lt;a&amp;gt;显示在 &lt;code&gt;22&lt;/code&gt; 和 &lt;code&gt;44&lt;/code&gt; 之间，并且您想在 &lt;code&gt;a&lt;/code&gt; 处停止。简单匹配的数字对将跳过 &lt;code&gt;a&lt;/code&gt; 并仍然匹配 &lt;code&gt;44&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99f46adab557fd8dab8b4b0b09a159b2654c69a5" translate="yes" xml:space="preserve">
          <source>Suppose you wanted to match only the allocated characters, not the raw block ranges: in other words, you want to remove the unassigned characters:</source>
          <target state="translated">假设你只想匹配已分配的字符,而不是原始块范围:换句话说,你想删除未分配的字符。</target>
        </trans-unit>
        <trans-unit id="7282725934a73028b4873e419044ca1541b7ef81" translate="yes" xml:space="preserve">
          <source>Suppose your function looks like this:</source>
          <target state="translated">假设你的函数是这样的。</target>
        </trans-unit>
        <trans-unit id="3cdc33b87c0a24861f5653d7a4749ecf4d10599b" translate="yes" xml:space="preserve">
          <source>Suppress statically defined functions from the profile.</source>
          <target state="translated">禁止在配置文件中使用静态定义的函数。</target>
        </trans-unit>
        <trans-unit id="f000eea4b15966462d081470a0dbb8675e040042" translate="yes" xml:space="preserve">
          <source>Suppress the verbose descriptions in the profile.</source>
          <target state="translated">抑制简介中的冗长描述。</target>
        </trans-unit>
        <trans-unit id="fe4ca7a4b62d0d93f13a11c00e6e1ef2ac15f93d" translate="yes" xml:space="preserve">
          <source>Suppressing Lines Where All Fields Are Void</source>
          <target state="translated">抑制所有字段都是空的线。</target>
        </trans-unit>
        <trans-unit id="f8a4d33a75006d37aaaa326a12ea28f45b06e609" translate="yes" xml:space="preserve">
          <source>Suppressing all output.</source>
          <target state="translated">压制所有输出。</target>
        </trans-unit>
        <trans-unit id="4db0aec339465e45f71592f3d61d3b7d5519b564" translate="yes" xml:space="preserve">
          <source>Suppressing everything but the tests summary.</source>
          <target state="translated">抑制一切,但测试总结。</target>
        </trans-unit>
        <trans-unit id="3118002fe0231bc240b745efda50a51f4811af55" translate="yes" xml:space="preserve">
          <source>Suppressing some test output (mostly failures while tests are running).</source>
          <target state="translated">抑制一些测试输出(主要是测试运行时的失败)。</target>
        </trans-unit>
        <trans-unit id="aaf2f474284f3bb3469459a5f2e282c817445e0a" translate="yes" xml:space="preserve">
          <source>Surprisingly, the following dangerous-looking construct will actually work out fine:</source>
          <target state="translated">出乎意料的是,下面这个看似危险的构造,其实也会有不错的效果。</target>
        </trans-unit>
        <trans-unit id="89de18d6062f8f62c80480423d64e1771fc8ce04" translate="yes" xml:space="preserve">
          <source>Surprisingly, the routines to be called are named &lt;code&gt;freeze&lt;/code&gt; and &lt;code&gt;thaw&lt;/code&gt; . If you wish to send out the frozen scalar to another machine, use &lt;code&gt;nfreeze&lt;/code&gt; instead to get a portable image.</source>
          <target state="translated">出人意料的是，要调用的例程称为 &lt;code&gt;freeze&lt;/code&gt; 和 &lt;code&gt;thaw&lt;/code&gt; 。如果希望将冻结的标量发送到另一台计算机，请使用 &lt;code&gt;nfreeze&lt;/code&gt; 来获取可移植图像。</target>
        </trans-unit>
        <trans-unit id="c6a047875b873f6d1d398e86dbb7108d34705540" translate="yes" xml:space="preserve">
          <source>Surrogate Pairs</source>
          <target state="translated">代孕夫妇</target>
        </trans-unit>
        <trans-unit id="07a0eab00168ce9bedc809f5ad8c9eb56cbd1edb" translate="yes" xml:space="preserve">
          <source>Surrogate pairs were born when the Unicode Consortium finally admitted that 16 bits were not big enough to hold all the world's character repertoires. But they already made UCS-2 16-bit. What do we do?</source>
          <target state="translated">当Unicode联盟终于承认16位不足以容纳世界上所有的字符集时,代用对就诞生了。但他们已经把UCS-2做成了16位。我们该怎么办?</target>
        </trans-unit>
        <trans-unit id="1eaaa69a37b20a485ea6f0e51d7a77d119e19f29" translate="yes" xml:space="preserve">
          <source>Surrogates are code points set aside to encode the &lt;code&gt;U+10000..U+10FFFF&lt;/code&gt; range of Unicode code points in pairs of 16-bit units. The</source>
          <target state="translated">替代项是留出的代码点，用于以16位为单位对 &lt;code&gt;U+10000..U+10FFFF&lt;/code&gt; 范围的Unicode代码点进行编码。的</target>
        </trans-unit>
        <trans-unit id="856dbe523b5bc18c3ac9b4ef67ed5a73d664d082" translate="yes" xml:space="preserve">
          <source>Surrogates have no meaning in Unicode outside their use in pairs to represent other code points. However, Perl allows them to be represented individually internally, for example by saying &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0xD801)&lt;/a&gt;&lt;/code&gt;, so that all code points, not just those valid for open interchange, are representable. Unicode does define semantics for them, such as their &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&quot;Cs&quot;&lt;/code&gt; . But because their use is somewhat dangerous, Perl will warn (using the warning category &lt;code&gt;&quot;surrogate&quot;&lt;/code&gt; , which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ) if an attempt is made to do things like take the lower case of one, or match case-insensitively, or to output them. (But don't try this on Perls before 5.14.)</source>
          <target state="translated">代理在成对使用代表其他代码点时，代理在Unicode中没有任何意义。但是，Perl允许在内部单独表示它们，例如通过说 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0xD801)&lt;/a&gt;&lt;/code&gt; ，以便可以表示所有代码点，而不仅仅是对开放交换有效的代码点。 Unicode确实为它们定义了语义，例如它们的 &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&quot;Cs&quot;&lt;/code&gt; 。但是，由于尝试使用它们有些危险，因此，如果尝试做类似小写的小写或匹配大小写的事情，Perl会发出警告（使用警告类别 &lt;code&gt;&quot;surrogate&quot;&lt;/code&gt; ，这是 &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 的子类别）。 -不敏感，或输出它们。 （但不要在5.14之前在Perls上尝试此操作。）</target>
        </trans-unit>
        <trans-unit id="540da7a8cd172c1838160d487b9d7ef0924efc97" translate="yes" xml:space="preserve">
          <source>Suspicious Warnings on Cygwin</source>
          <target state="translated">Cygwin上的可疑警告</target>
        </trans-unit>
        <trans-unit id="1e1cd0c78512c809bc8f82ce5a88755a660fc1dd" translate="yes" xml:space="preserve">
          <source>SvIV()</source>
          <target state="translated">SvIV()</target>
        </trans-unit>
        <trans-unit id="dbc4878fd112ac06a09fc11cde47bb125aee2c3f" translate="yes" xml:space="preserve">
          <source>SvNV()</source>
          <target state="translated">SvNV()</target>
        </trans-unit>
        <trans-unit id="935c09deb58ecb63d6891adc1aabec93c4c8a5b7" translate="yes" xml:space="preserve">
          <source>SvPV()</source>
          <target state="translated">SvPV()</target>
        </trans-unit>
        <trans-unit id="d644182b7fecca2e84a27663743f7d7d1731110e" translate="yes" xml:space="preserve">
          <source>SvTHINKFIRST sometimes produces false positives. In those cases sv_force_normal does nothing.</source>
          <target state="translated">SvTHINKFIRST 有时会产生假阳性。在这种情况下,sv_force_normal什么也不做。</target>
        </trans-unit>
        <trans-unit id="7d140830d04307683300b42c263a4bad9b2b05e6" translate="yes" xml:space="preserve">
          <source>Switch Statements</source>
          <target state="translated">开关语句</target>
        </trans-unit>
        <trans-unit id="8bd9a48c2b8a06497ad155d8fb2e22e3efb40ec2" translate="yes" xml:space="preserve">
          <source>Switch off optimizations.</source>
          <target state="translated">关闭优化。</target>
        </trans-unit>
        <trans-unit id="3bb7fa365adb6d9413c8c9a8c7435723660691af" translate="yes" xml:space="preserve">
          <source>Switch to viewing a different file or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; statement. If</source>
          <target state="translated">切换到查看其他文件或 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 语句。如果</target>
        </trans-unit>
        <trans-unit id="941726dc5468b689bfb5334269ab159c8c5ac044" translate="yes" xml:space="preserve">
          <source>Switches On the &quot;#!&quot; Line</source>
          <target state="translated">开启 &quot;#!&quot;。线</target>
        </trans-unit>
        <trans-unit id="22865b749e47c4f80690e8fbf02747aa53e87248" translate="yes" xml:space="preserve">
          <source>Switches include:</source>
          <target state="translated">开关包括:</target>
        </trans-unit>
        <trans-unit id="1a104dee1272b5ea48fa02cf2cd55d0cf5980bda" translate="yes" xml:space="preserve">
          <source>Switches which take an argument don't care whether there is a space between the switch and the argument. If unspecified switches are found on the command-line, the user will be warned that an unknown option was given.</source>
          <target state="translated">接受参数的开关不关心开关和参数之间是否有空格。如果在命令行中发现了未指定的开关,用户会被警告说是一个未知的选项。</target>
        </trans-unit>
        <trans-unit id="88a10266365bec895433e46eaf4bb0d9f4319fa6" translate="yes" xml:space="preserve">
          <source>Switching in a loop</source>
          <target state="translated">循环切换</target>
        </trans-unit>
        <trans-unit id="c4833a3fbcd559394f2c58d1f54c950e1415a542" translate="yes" xml:space="preserve">
          <source>Sx is an interface to the Athena widget set which comes with X, but again it appears not to be much used nowadays.</source>
          <target state="translated">Sx是X自带的雅典娜小部件集的接口,但现在似乎又不怎么用了。</target>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="6f23f00b2c5559251a269c3e95612a03f0fa5304" translate="yes" xml:space="preserve">
          <source>Symbol - manipulate Perl symbols and their names</source>
          <target state="translated">Symbol-操作Perl符号和它们的名称</target>
        </trans-unit>
        <trans-unit id="e2434de5e406913ebf6a3ac33e80e10d4a315aea" translate="yes" xml:space="preserve">
          <source>Symbol Encodings</source>
          <target state="translated">符号编码</target>
        </trans-unit>
        <trans-unit id="d794fc2c3b0c30f40edbe0d808d2368ffeb21d98" translate="yes" xml:space="preserve">
          <source>Symbol Tables</source>
          <target state="translated">符号表</target>
        </trans-unit>
        <trans-unit id="4b05d7078c77af4d667a4898e87b6c3188ae4b11" translate="yes" xml:space="preserve">
          <source>Symbolic Calculator</source>
          <target state="translated">符号计算器</target>
        </trans-unit>
        <trans-unit id="37008620b710f26771f72ef684d0d762ce0c312d" translate="yes" xml:space="preserve">
          <source>Symbolic Links</source>
          <target state="translated">符号链接</target>
        </trans-unit>
        <trans-unit id="d0a9fa28cc57e07ecbedf349e28f66a417dbd550" translate="yes" xml:space="preserve">
          <source>Symbolic Unary Operators</source>
          <target state="translated">符号统一运算符</target>
        </trans-unit>
        <trans-unit id="c85b29041363945d0d38e6dd76ab2012cab61284" translate="yes" xml:space="preserve">
          <source>Symbolic links will be replicated in the destination directory. If &lt;b&gt;-l&lt;/b&gt; is not specified, then links are skipped over.</source>
          <target state="translated">符号链接将复制到目标目录中。如果未指定&lt;b&gt;-l&lt;/b&gt;，则跳过链接。</target>
        </trans-unit>
        <trans-unit id="5740fe00b50befc25ecdbfe2ce1dcb268f365ae5" translate="yes" xml:space="preserve">
          <source>Symbolic methods</source>
          <target state="translated">符号方法</target>
        </trans-unit>
        <trans-unit id="2ed5a46b240bca78e1ebda87bbf53e151430ff41" translate="yes" xml:space="preserve">
          <source>Symbolic references</source>
          <target state="translated">符号参考</target>
        </trans-unit>
        <trans-unit id="11ea83f8147883e582553aebb48729beba5bdaf1" translate="yes" xml:space="preserve">
          <source>Symbolic references are forbidden under the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; pragma. They are not true references and consequently are not reference-counted or garbage-collected.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 编译指示时，禁止使用符号引用。它们不是真正的引用，因此没有引用计数或垃圾回收。</target>
        </trans-unit>
        <trans-unit id="2a3d231a255923086dc7e82179bb6e9c216f886c" translate="yes" xml:space="preserve">
          <source>Symbolic references are names of variables or other objects, just as a symbolic link in a Unix filesystem contains merely the name of a file. The &lt;code&gt;*glob&lt;/code&gt; notation is something of a symbolic reference. (Symbolic references are sometimes called &quot;soft references&quot;, but please don't call them that; references are confusing enough without useless synonyms.)</source>
          <target state="translated">符号引用是变量或其他对象的名称，就像Unix文件系统中的符号链接仅包含文件名一样。在 &lt;code&gt;*glob&lt;/code&gt; 符号是一个象征性的参考的东西。（符号引用有时被称为&amp;ldquo;软引用&amp;rdquo;，但是请不要这样称呼；没有无用同义词的引用会引起混乱。）</target>
        </trans-unit>
        <trans-unit id="7eb647835a30e5a1bbf74157fa14f494b596a5c9" translate="yes" xml:space="preserve">
          <source>Symbols representing the concepts &amp;ldquo;and&amp;rdquo;, &amp;ldquo;or&amp;rdquo;, &amp;ldquo;xor&amp;rdquo;, and &amp;ldquo;not&amp;rdquo;.</source>
          <target state="translated">代表概念&amp;ldquo;和&amp;rdquo;，&amp;ldquo;或&amp;rdquo;，&amp;ldquo;异或&amp;rdquo;和&amp;ldquo;非&amp;rdquo;的符号。</target>
        </trans-unit>
        <trans-unit id="bc32943d7841b88a1cf40309071785aab7d4e9d1" translate="yes" xml:space="preserve">
          <source>Synchronization and control</source>
          <target state="translated">同步和控制</target>
        </trans-unit>
        <trans-unit id="fd6877f381ee0675d5bd925a8ea887b401ae7a51" translate="yes" xml:space="preserve">
          <source>Synonymous options (like both the short and long forms) are separated by a comma and a space on the same &lt;code&gt;=item&lt;/code&gt; line, or optionally listed as their own item with a reference to the canonical name. For example, since &lt;b&gt;--section&lt;/b&gt; can also be written as &lt;b&gt;-s&lt;/b&gt;, the above would be:</source>
          <target state="translated">同义选项（如短格式和长格式）在同一 &lt;code&gt;=item&lt;/code&gt; 行上用逗号和空格分隔，或者可以选择将其作为自己的项目列出，并引用规范名称。例如，由于&lt;b&gt;--section&lt;/b&gt;也可以写为&lt;b&gt;-s&lt;/b&gt;，因此上述内容将是：</target>
        </trans-unit>
        <trans-unit id="fcbf093f7bdc572a445b9a43606c7f7a83836b33" translate="yes" xml:space="preserve">
          <source>Synonyms for &lt;code&gt;recipient&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;recipient&lt;/code&gt; 同义词。</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="af5f0a5e089ff24df87876664a300fc1d94de87c" translate="yes" xml:space="preserve">
          <source>Synopsis:</source>
          <target state="translated">Synopsis:</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="e90738f5d4b2229f3a4c124484c36b1275df5262" translate="yes" xml:space="preserve">
          <source>Syntax for invoking shar, tar and zip differs from that for Unix.</source>
          <target state="translated">调用shar、tar和zip的语法与Unix的不同。</target>
        </trans-unit>
        <trans-unit id="7d8c7607abfe852f9a6ad8648332314d9917e637" translate="yes" xml:space="preserve">
          <source>Syntax of Attribute Lists</source>
          <target state="translated">属性列表的语法</target>
        </trans-unit>
        <trans-unit id="1de8dba368e7754dc199c99b017f5c51265ee8dc" translate="yes" xml:space="preserve">
          <source>Syntax:</source>
          <target state="translated">Syntax:</target>
        </trans-unit>
        <trans-unit id="0785d5c2121b7134c4af7c65680f001acb76a92c" translate="yes" xml:space="preserve">
          <source>Sys$Library</source>
          <target state="translated">Sys$Library</target>
        </trans-unit>
        <trans-unit id="65fb3d73b0b7d628e2887a67776fd305bc37b9e6" translate="yes" xml:space="preserve">
          <source>Sys$Share</source>
          <target state="translated">Sys$Share</target>
        </trans-unit>
        <trans-unit id="dbb39438e97d2bc740ddc791cb728708fa6deab2" translate="yes" xml:space="preserve">
          <source>Sys$System:</source>
          <target state="translated">Sys$System:</target>
        </trans-unit>
        <trans-unit id="48fee1621e8e0fbac3a51bb7b722933258b770f4" translate="yes" xml:space="preserve">
          <source>Sys::Hostname</source>
          <target state="translated">Sys::Hostname</target>
        </trans-unit>
        <trans-unit id="2e415aac42b72faad3c72367e40e8717dbc66b3c" translate="yes" xml:space="preserve">
          <source>Sys::Hostname - Try every conceivable way to get hostname</source>
          <target state="translated">Sys::Hostname-尝试所有能想到的方法来获取主机名。</target>
        </trans-unit>
        <trans-unit id="c1e878d92efc49a2e4d7c74bab56ecb4df79e136" translate="yes" xml:space="preserve">
          <source>Sys::Syslog</source>
          <target state="translated">Sys::Syslog</target>
        </trans-unit>
        <trans-unit id="d0e7c26b96f1913c444745d08172cdce4e0c92fa" translate="yes" xml:space="preserve">
          <source>Sys::Syslog - Perl interface to the UNIX syslog(3) calls</source>
          <target state="translated">Sys::Syslog-连接 UNIX syslog(3)调用的 Perl 接口。</target>
        </trans-unit>
        <trans-unit id="e9c9e6fce8c27f1db38faca8727f60ffbd03b1df" translate="yes" xml:space="preserve">
          <source>SysV IPC</source>
          <target state="translated">SysV IPC</target>
        </trans-unit>
        <trans-unit id="b769fe98988d4570b7169913197897773fb46367" translate="yes" xml:space="preserve">
          <source>SysV Msg IPC object class</source>
          <target state="translated">SysV Msg IPC对象类</target>
        </trans-unit>
        <trans-unit id="1b5cd833684b7ef6a59dab44ff94b295bccc40b4" translate="yes" xml:space="preserve">
          <source>SysV Semaphore IPC object class</source>
          <target state="translated">SysV Semaphore IPC对象类。</target>
        </trans-unit>
        <trans-unit id="71c44529ecac23b5c9809ec7a57f43fadf59d867" translate="yes" xml:space="preserve">
          <source>SysV Shared Memory IPC object class</source>
          <target state="translated">SysV 共享内存 IPC 对象类</target>
        </trans-unit>
        <trans-unit id="e45e7e358eb9351a96a4b4d44c0db473a81b0bd0" translate="yes" xml:space="preserve">
          <source>Syscall returns whatever value returned by the system call it calls. If the system call fails, &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Note that some system calls</source>
          <target state="translated">Syscall返回其调用的系统调用返回的任何值。如果系统调用失败，则 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;-1&lt;/code&gt; 并设置 &lt;code&gt;$!&lt;/code&gt; （errno）。请注意，某些系统调用</target>
        </trans-unit>
        <trans-unit id="e0b761d47162708932873aa746a0b31a4af21afe" translate="yes" xml:space="preserve">
          <source>Syscall returns whatever value returned by the system call it calls. If the system call fails, &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Note that some system calls</source>
          <target state="translated">Syscall返回其调用的系统调用返回的任何值。如果系统调用失败，则 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;-1&lt;/code&gt; 并设置 &lt;code&gt;$!&lt;/code&gt; （errno）。请注意，某些系统调用</target>
        </trans-unit>
        <trans-unit id="53aa71666c5046c70bdb9cfa19d05f3e5e2dbe70" translate="yes" xml:space="preserve">
          <source>Syslogging with Perl</source>
          <target state="translated">用Perl做系统日志</target>
        </trans-unit>
        <trans-unit id="b9c23727af44d87276c73142b1bbc56acfa2ff99" translate="yes" xml:space="preserve">
          <source>Sysroot.U</source>
          <target state="translated">Sysroot.U</target>
        </trans-unit>
        <trans-unit id="286ad58c359f169cf560ed965ca49713b4161be5" translate="yes" xml:space="preserve">
          <source>System Interaction</source>
          <target state="translated">系统交互</target>
        </trans-unit>
        <trans-unit id="a5f5e2adb8b84a09a3496b92bfc8ae6f7818b5f8" translate="yes" xml:space="preserve">
          <source>System Resources</source>
          <target state="translated">系统资源</target>
        </trans-unit>
        <trans-unit id="12920688fafa23a0e3538825316e84488141b30c" translate="yes" xml:space="preserve">
          <source>System Specifics</source>
          <target state="translated">系统特性</target>
        </trans-unit>
        <trans-unit id="1c80f9799bbc3cebb5501e8db9a2d073ae25632e" translate="yes" xml:space="preserve">
          <source>System V IPC constants and system calls</source>
          <target state="translated">系统五 IPC 常量和系统调用</target>
        </trans-unit>
        <trans-unit id="16956db37d0c77a530acbdbc4b5059785173084f" translate="yes" xml:space="preserve">
          <source>System calls accept either &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt; as the path separator. However, many command-line utilities of DOS vintage treat &lt;code&gt;/&lt;/code&gt; as the option prefix, so may get confused by filenames containing &lt;code&gt;/&lt;/code&gt;. Aside from calling any external programs, &lt;code&gt;/&lt;/code&gt; will work just fine, and probably better, as it is more consistent with popular usage, and avoids the problem of remembering what to backwhack and what not to.</source>
          <target state="translated">系统调用接受 &lt;code&gt;/&lt;/code&gt; 或 &lt;code&gt;\&lt;/code&gt; 作为路径分隔符。但是，许多DOS vintage的命令行实用程序都将 &lt;code&gt;/&lt;/code&gt; 当作选项前缀，因此可能会对包含 &lt;code&gt;/&lt;/code&gt; 的文件名感到困惑。除了调用任何外部程序外， &lt;code&gt;/&lt;/code&gt; 可以很好地工作，并且可能会更好，因为它与流行用法更加一致，并且避免了记住要反击什么和不反击什么的问题。</target>
        </trans-unit>
        <trans-unit id="007271cb98a5608fe64c06188e43289d61f1c7bd" translate="yes" xml:space="preserve">
          <source>System calls return -1 on error (setting ERRNO with the reason) and (usually) 0 on success. If the return value is -1 this typemap returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. If the return value is not -1, this typemap translates a 0 (perl false) to &quot;0 but true&quot; (which is perl true) or returns the value itself, to indicate that the command succeeded.</source>
          <target state="translated">系统调用在错误时返回-1（将ERRNO设置为原因），在错误时返回（通常）为0。如果返回值为-1，则此类型映射将返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。如果返回值不是-1，则此类型映射将0（perl false）转换为&amp;ldquo; 0 but true&amp;rdquo;（perl true）或返回值本身，以指示命令成功。</target>
        </trans-unit>
        <trans-unit id="eb78d5fbb36025d1ade73acf0ec1dc017253b7c6" translate="yes" xml:space="preserve">
          <source>System calls such as link(), unlink(), rename(), etc. return nonzero for success, not 0. (system(), however, returns zero for success.)</source>
          <target state="translated">系统调用如link()、unlink()、rename()等,成功时返回非零,而不是0(但system()成功时返回0)。</target>
        </trans-unit>
        <trans-unit id="a5bfc62972086e83c2f9e4d6647ba3081448737b" translate="yes" xml:space="preserve">
          <source>System errno constants</source>
          <target state="translated">系统errno常数</target>
        </trans-unit>
        <trans-unit id="0464247110efd6dc873ab7d03699ac46391aa089" translate="yes" xml:space="preserve">
          <source>SystemV Interprocess Communications:</source>
          <target state="translated">SystemV进程间通信。</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="9f94efb44fe911a9e20566c2b4f9e9743238c25c" translate="yes" xml:space="preserve">
          <source>TABLE OF CONTENTS</source>
          <target state="translated">目 录</target>
        </trans-unit>
        <trans-unit id="3b4df05d703541d151d3e3628328bb8fd532308b" translate="yes" xml:space="preserve">
          <source>TAP GRAMMAR</source>
          <target state="translated">录音带语法</target>
        </trans-unit>
        <trans-unit id="1920029d62435d8577df2572dd0096bfaff76178" translate="yes" xml:space="preserve">
          <source>TAP pragma token.</source>
          <target state="translated">TAP pragma token。</target>
        </trans-unit>
        <trans-unit id="a6ad0c7cbda3b41f87bebc3eecd396afa503fee6" translate="yes" xml:space="preserve">
          <source>TAP syntax version token.</source>
          <target state="translated">TAP语法版本令牌。</target>
        </trans-unit>
        <trans-unit id="3876ffd2c762f78e88b10fd7b5ed6b67ff853ed5" translate="yes" xml:space="preserve">
          <source>TAP::Base</source>
          <target state="translated">TAP::Base</target>
        </trans-unit>
        <trans-unit id="393bbdfe5b0291f7582e0a00a859897a43f52662" translate="yes" xml:space="preserve">
          <source>TAP::Base - Base class that provides common functionality to &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and &lt;a href=&quot;harness&quot;&gt;TAP::Harness&lt;/a&gt;</source>
          <target state="translated">TAP :: Base-为&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;和&lt;a href=&quot;harness&quot;&gt;TAP :: Harness&lt;/a&gt;提供通用功能的基类</target>
        </trans-unit>
        <trans-unit id="863c519a681845de61f18ccf2d91ed2bae4b3a87" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Base</source>
          <target state="translated">TAP::Formatter::Base</target>
        </trans-unit>
        <trans-unit id="2219301c0e6ab7a0cac653627940a66913b4e00c" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Base - Base class for harness output delegates</source>
          <target state="translated">TAP::Formatter::Base-harness输出委托的基础类。</target>
        </trans-unit>
        <trans-unit id="737a5324c5901c02f42ad717687b54b1dafd7c3b" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Color</source>
          <target state="translated">TAP::Formatter::Color</target>
        </trans-unit>
        <trans-unit id="83dc9a13e5e40b4cace713c5d42771d2b5bb47e0" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Color - Run Perl test scripts with color</source>
          <target state="translated">TAP::Formatter::Color-使用颜色运行Perl测试脚本。</target>
        </trans-unit>
        <trans-unit id="de057ff7c6b5e40851d3c50d32e9750e339c5926" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console</source>
          <target state="translated">TAP::Formatter::Console</target>
        </trans-unit>
        <trans-unit id="e5caa85b06270fe34451b375ee12674e638dd733" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console - Harness output delegate for default console output</source>
          <target state="translated">TAP::Formatter::Console-驾驭输出委托,用于默认的控制台输出。</target>
        </trans-unit>
        <trans-unit id="01b7c503e4f8a4af70b89b685b263fa99a7779a7" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::ParallelSession</source>
          <target state="translated">TAP::Formatter::Console::ParallelSession</target>
        </trans-unit>
        <trans-unit id="db7bd0c049621f91358c7128fbd5472680ec6d31" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::ParallelSession - Harness output delegate for parallel console output</source>
          <target state="translated">TAP::Formatter::Console::ParallelSession-驾驭并行控制台输出的输出委托。</target>
        </trans-unit>
        <trans-unit id="e10aa0877a249858e704e343610555a15b6331f0" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::Session</source>
          <target state="translated">TAP::Formatter::Console::Session</target>
        </trans-unit>
        <trans-unit id="617e83a9b0bba0c6a87c6403d55512035b5d4331" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::Session - Harness output delegate for default console output</source>
          <target state="translated">TAP::Formatter::Console::Session-驾驭默认控制台输出的输出委托。</target>
        </trans-unit>
        <trans-unit id="ebcc51d604eabcfa523d96f91dc1b0eb51dccb7d" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File</source>
          <target state="translated">TAP::Formatter::File</target>
        </trans-unit>
        <trans-unit id="ce9e5131d6998f180ee6abe8bad4643f869cfb3d" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File - Harness output delegate for file output</source>
          <target state="translated">TAP::Formatter::File-用于文件输出的输出委托。</target>
        </trans-unit>
        <trans-unit id="5a53ebb59dd4ba13f5939d6a9f81cddf3e1c6f45" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File::Session</source>
          <target state="translated">TAP::Formatter::File::Session</target>
        </trans-unit>
        <trans-unit id="360d8f026e4e5483612bf0275831836f9ffb249f" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File::Session - Harness output delegate for file output</source>
          <target state="translated">TAP::Formatter::File::Session-驾驭文件输出的输出委托人</target>
        </trans-unit>
        <trans-unit id="46af53bbf8c7eee3da8d825fcace74fe474d232b" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Session</source>
          <target state="translated">TAP::Formatter::Session</target>
        </trans-unit>
        <trans-unit id="c2df33c30bd450c40b146c186ea09c6cab11e56c" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Session - Abstract base class for harness output delegate</source>
          <target state="translated">TAP::Formatter::Session-驾驭输出委托的抽象基类。</target>
        </trans-unit>
        <trans-unit id="93ebad31adfaf596a987126afe3d7a3f18d93c05" translate="yes" xml:space="preserve">
          <source>TAP::Harness</source>
          <target state="translated">TAP::Harness</target>
        </trans-unit>
        <trans-unit id="b7d5d266f7a8edc064e0b8c710521d51a2bc894a" translate="yes" xml:space="preserve">
          <source>TAP::Harness - Run test scripts with statistics</source>
          <target state="translated">TAP::Harness-使用统计数据运行测试脚本。</target>
        </trans-unit>
        <trans-unit id="7a70a46bfa38bc1216fe94cb04afcea34c7e8685" translate="yes" xml:space="preserve">
          <source>TAP::Object</source>
          <target state="translated">TAP::Object</target>
        </trans-unit>
        <trans-unit id="f09e3a92ac29a0ecd8a4f02097d67c9251bfb4fd" translate="yes" xml:space="preserve">
          <source>TAP::Object - Base class that provides common functionality to all &lt;code&gt;TAP::*&lt;/code&gt; modules</source>
          <target state="translated">TAP :: Object-为所有 &lt;code&gt;TAP::*&lt;/code&gt; 模块提供通用功能的基类</target>
        </trans-unit>
        <trans-unit id="73c55e213830c688e72c24e7e2dc38927a8f526e" translate="yes" xml:space="preserve">
          <source>TAP::Parser</source>
          <target state="translated">TAP::Parser</target>
        </trans-unit>
        <trans-unit id="2f07ed865105b4fe8e06f2ed0ef74d2249f0ce1b" translate="yes" xml:space="preserve">
          <source>TAP::Parser - Parse &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt; output</source>
          <target state="translated">TAP :: Parser-解析&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt;输出</target>
        </trans-unit>
        <trans-unit id="7a216f40bfe5d8c4e9f480503b3353a997f25d9e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Aggregator</source>
          <target state="translated">TAP::Parser::Aggregator</target>
        </trans-unit>
        <trans-unit id="29967243373ff3c2847efa03292cf1394ade91bf" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Aggregator - Aggregate TAP::Parser results</source>
          <target state="translated">TAP::Parser::Aggregator-Aggregate TAP::Parser results</target>
        </trans-unit>
        <trans-unit id="ea252a87adf45624e0915f082cf3a171691e2b87" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Grammar</source>
          <target state="translated">TAP::Parser::Grammar</target>
        </trans-unit>
        <trans-unit id="99d73c9149822b89f098465b0ef15b6e5e432ba4" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Grammar - A grammar for the Test Anything Protocol.</source>
          <target state="translated">TAP::Parser::Grammar-Test Anything Protocol 的语法。</target>
        </trans-unit>
        <trans-unit id="f66dcc18cf605bab72f282216bf437fafae85c73" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator</source>
          <target state="translated">TAP::Parser::Iterator</target>
        </trans-unit>
        <trans-unit id="d222e4542e0f93a9f4cabc8a65b724fcc86515cd" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator - Base class for TAP source iterators</source>
          <target state="translated">TAP::Parser::Iterator-TAP源迭代器的基类。</target>
        </trans-unit>
        <trans-unit id="599e631b6f320b3fc47ee504d90a3e175b821f4e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Array</source>
          <target state="translated">TAP::Parser::Iterator::Array</target>
        </trans-unit>
        <trans-unit id="8849b72265bccd1154b20c5bcfd79b6177e1d979" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Array - Iterator for array-based TAP sources</source>
          <target state="translated">TAP::Parser::Iterator::Array-基于数组的TAP源的迭代器。</target>
        </trans-unit>
        <trans-unit id="8afb640018f748c7abac8e508f78557fe8689509" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Process</source>
          <target state="translated">TAP::Parser::Iterator::Process</target>
        </trans-unit>
        <trans-unit id="ef61fd1ef2ee2ba4a706833aed0bb08fe84a24ba" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Process - Iterator for process-based TAP sources</source>
          <target state="translated">TAP::Parser::Iterator::Process-用于基于过程的TAP源的迭代器。</target>
        </trans-unit>
        <trans-unit id="c97751b26f9e6df1ee3c0a7feabeda4e0d9102c3" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Stream</source>
          <target state="translated">TAP::Parser::Iterator::Stream</target>
        </trans-unit>
        <trans-unit id="be38f68275dc99a67c8ac1d8cfd48bb032de4d4a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Stream - Iterator for filehandle-based TAP sources</source>
          <target state="translated">TAP::Parser::Iterator::Stream-用于基于文件柄的TAP源的迭代器。</target>
        </trans-unit>
        <trans-unit id="d89bed7b6f6d5d165f751cac2ac0a13e2dd7f697" translate="yes" xml:space="preserve">
          <source>TAP::Parser::IteratorFactory</source>
          <target state="translated">TAP::Parser::IteratorFactory</target>
        </trans-unit>
        <trans-unit id="8d39f8677b4d63ea3260e5507a930c994a438d70" translate="yes" xml:space="preserve">
          <source>TAP::Parser::IteratorFactory - Figures out which SourceHandler objects to use for a given Source</source>
          <target state="translated">TAP::Parser::IteratorFactory-计算出要为给定的Source使用哪些SourceHandler对象。</target>
        </trans-unit>
        <trans-unit id="6f50fafc730902e3aa24fa13c0c429b89a2cc1ff" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Multiplexer</source>
          <target state="translated">TAP::Parser::Multiplexer</target>
        </trans-unit>
        <trans-unit id="2da48d5d830b8cd9138d15d18237febc28e0b498" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Multiplexer - Multiplex multiple TAP::Parsers</source>
          <target state="translated">TAP::解析器::多路复用器-多路复用多个TAP::解析器。</target>
        </trans-unit>
        <trans-unit id="3c077c3ce874909f47ae77cbcca2c04344198e5b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result</source>
          <target state="translated">TAP::Parser::Result</target>
        </trans-unit>
        <trans-unit id="a422082a9e255b156b40569483bd6f50f2d5a284" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result - Base class for TAP::Parser output objects</source>
          <target state="translated">TAP::Parser::Result-TAP::Parser输出对象的基类。</target>
        </trans-unit>
        <trans-unit id="03b8058105031bc1095218a7667a2ea1b2512b1e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Bailout</source>
          <target state="translated">TAP::Parser::Result::Bailout</target>
        </trans-unit>
        <trans-unit id="00f4b677e9dddb24581e9ed004b7470cf77a617e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Bailout - Bailout result token.</source>
          <target state="translated">TAP::Parser::Result::Bailout-Bailout result token。</target>
        </trans-unit>
        <trans-unit id="afba56eaac641feaac3daf9f840411e87ecf1e14" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Comment</source>
          <target state="translated">TAP::Parser::Result::Comment</target>
        </trans-unit>
        <trans-unit id="15ac19d49aebc2fdbf7a430ac512a0c55bc03548" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Comment - Comment result token.</source>
          <target state="translated">TAP::Parser::Result::Comment-评论结果标记。</target>
        </trans-unit>
        <trans-unit id="8028e0720d8ec37d7287bdb1bc7450078b0bf251" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Plan</source>
          <target state="translated">TAP::Parser::Result::Plan</target>
        </trans-unit>
        <trans-unit id="4383859286c921d76add9716628e055668e9e51d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Plan - Plan result token.</source>
          <target state="translated">TAP::Parser::Result::Plan-计划结果标记。</target>
        </trans-unit>
        <trans-unit id="f69e80305022a26d3e2f7acc2b0ed1b953372499" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Pragma</source>
          <target state="translated">TAP::Parser::Result::Pragma</target>
        </trans-unit>
        <trans-unit id="14e0c88ebea6563cf55ee8c08b3b9ed300f0d20c" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Pragma - TAP pragma token.</source>
          <target state="translated">TAP::Parser::Result::Pragma-TAP pragma token。</target>
        </trans-unit>
        <trans-unit id="2c91344b1f933a9487eebefc220df8812b008445" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Test</source>
          <target state="translated">TAP::Parser::Result::Test</target>
        </trans-unit>
        <trans-unit id="edc9dae5ee4fae6dd91f0295f192573a8fb6a01a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Test - Test result token.</source>
          <target state="translated">TAP::Parser::Result::Test-测试结果标记。</target>
        </trans-unit>
        <trans-unit id="44c345b7d9dc9992b3e410debbb02b0d29d66e79" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Unknown</source>
          <target state="translated">TAP::Parser::Result::Unknown</target>
        </trans-unit>
        <trans-unit id="2943117d9510c588ee4451eb94edacf47000ab69" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Unknown - Unknown result token.</source>
          <target state="translated">TAP::Parser::Result::Unknown-未知结果标记。</target>
        </trans-unit>
        <trans-unit id="c6da177c03a14aa64f029674caca24adf3980051" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Version</source>
          <target state="translated">TAP::Parser::Result::Version</target>
        </trans-unit>
        <trans-unit id="57883e95518fac69c11831c9fff6d78815a22b85" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Version - TAP syntax version token.</source>
          <target state="translated">TAP::Parser::Result::Version-TAP语法版本标记。</target>
        </trans-unit>
        <trans-unit id="0f318e8c966222dedab8b0415294cae97d5f4f64" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::YAML</source>
          <target state="translated">TAP::Parser::Result::YAML</target>
        </trans-unit>
        <trans-unit id="68efbf9d5d727c77c2280206016668c939f6f897" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::YAML - YAML result token.</source>
          <target state="translated">TAP::Parser::Result::YAML-YAML结果标记。</target>
        </trans-unit>
        <trans-unit id="1a3c6d732b12248b1b6d9e14cf320584eb0a7af0" translate="yes" xml:space="preserve">
          <source>TAP::Parser::ResultFactory</source>
          <target state="translated">TAP::Parser::ResultFactory</target>
        </trans-unit>
        <trans-unit id="4f51e316d0426f94634c75bc33e9099d8d304e39" translate="yes" xml:space="preserve">
          <source>TAP::Parser::ResultFactory - Factory for creating TAP::Parser output objects</source>
          <target state="translated">TAP::Parser::ResultFactory-用于创建TAP::Parser输出对象的工厂。</target>
        </trans-unit>
        <trans-unit id="50d7a126914ae0138b7bdc512d9ccd5a5d77784d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler</source>
          <target state="translated">TAP::Parser::Scheduler</target>
        </trans-unit>
        <trans-unit id="6da57a5308e690ad2cdb39023741e3d016f8b96b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler - Schedule tests during parallel testing</source>
          <target state="translated">TAP::Parser::Scheduler-在并行测试中安排测试。</target>
        </trans-unit>
        <trans-unit id="81a373608790f502b94224968ea5fc04bfbb7622" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Job</source>
          <target state="translated">TAP::Parser::Scheduler::Job</target>
        </trans-unit>
        <trans-unit id="657d2fb895dc4c666b37510d12e2199629196955" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Job - A single testing job.</source>
          <target state="translated">TAP::Parser::Scheduler::Job-一个单一的测试作业。</target>
        </trans-unit>
        <trans-unit id="5f18e879edab289da9e626ab0da6617557a360e9" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Spinner</source>
          <target state="translated">TAP::Parser::Scheduler::Spinner</target>
        </trans-unit>
        <trans-unit id="73c0394de64be963748b5ce71edfd4ac21a6b40d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Spinner - A no-op job.</source>
          <target state="translated">TAP::Parser::Scheduler::Spinner-一个无操作的作业。</target>
        </trans-unit>
        <trans-unit id="223a37f35fb2a759c5993cb7f97ef9683ee5bef9" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Source</source>
          <target state="translated">TAP::Parser::Source</target>
        </trans-unit>
        <trans-unit id="ba1432bca02f36d9b7eb2dec89d208a92989961b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Source - a TAP source &amp;amp; meta data about it</source>
          <target state="translated">TAP :: Parser :: Source-TAP源和有关它的元数据</target>
        </trans-unit>
        <trans-unit id="f75366f8757d0c89dc67745e9e30ae921835fc92" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Reader</source>
          <target state="translated">TAP::Parser::YAMLish::Reader</target>
        </trans-unit>
        <trans-unit id="92a795f40e2bb73376fc045a4635f6fcf7d6a7de" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Reader - Read YAMLish data from iterator</source>
          <target state="translated">TAP::解析器::YAMLish::Reader-从迭代器中读取YAMLish数据。</target>
        </trans-unit>
        <trans-unit id="08d78eef616ac71669e623449566134b1c6d4b77" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Writer</source>
          <target state="translated">TAP::Parser::YAMLish::Writer</target>
        </trans-unit>
        <trans-unit id="662f33223b14be1ce958a19abee31b207588ba54" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Writer - Write YAMLish data</source>
          <target state="translated">TAP::Parser::YAMLish::Writer-写入YAMLish数据。</target>
        </trans-unit>
        <trans-unit id="20a7b118ffa37d6b7bbce47ab0257aa206e6a7b5" translate="yes" xml:space="preserve">
          <source>TBC: Remove the stringified coderef; while it provides a 'cookie' for each function rendered, the cookies used should be 1,2,3.. not a random hex-address. It also complicates string comparison of two different trees.</source>
          <target state="translated">TBC。删除字符串化的coderef;虽然它为每个函数提供了一个 &quot;cookie&quot;,但使用的cookie应该是1,2,3.而不是一个随机的十六进制地址。这也使两个不同树的字符串比较复杂化。</target>
        </trans-unit>
        <trans-unit id="75c76515695c04f9554f43d036ad1241bc04ca9e" translate="yes" xml:space="preserve">
          <source>TBC: a hookpoint (and an option to set it) for a user-supplied function to produce a banner appropriate for users needs. It's not ideal, because the rendering-state variables, which are a natural candidate for use in concise.t, are unavailable to the user.</source>
          <target state="translated">TBC:为用户提供的函数提供一个钩子点(以及设置钩子点的选项),以产生一个适合用户需求的横幅。这并不理想,因为用户无法使用concise.t中的渲染状态变量。</target>
        </trans-unit>
        <trans-unit id="ccb92559aac4354578ea22eca45f6544e0875e36" translate="yes" xml:space="preserve">
          <source>TCP Clients with IO::Socket</source>
          <target state="translated">带有IO::Socket的TCP客户端</target>
        </trans-unit>
        <trans-unit id="90251fa6420d40cf40e1d413320c56543c05df3d" translate="yes" xml:space="preserve">
          <source>TCP Servers with IO::Socket</source>
          <target state="translated">带有IO::Socket的TCP服务器</target>
        </trans-unit>
        <trans-unit id="5f3be0b4f564336745c1f56bb30fefa5d6b55f59" translate="yes" xml:space="preserve">
          <source>TCP32IP</source>
          <target state="translated">TCP32IP</target>
        </trans-unit>
        <trans-unit id="930107c72c67f45aa5652e4a9e00965774f7a294" translate="yes" xml:space="preserve">
          <source>TCP_CORK, TCP_KEEPALIVE, TCP_NODELAY, ...</source>
          <target state="translated">TCP_CORK,TCP_KEEPALIVE,TCP_NODELAY,...。</target>
        </trans-unit>
        <trans-unit id="f903b5ea6b01e57df921d11ccc31344fae1a17ad" translate="yes" xml:space="preserve">
          <source>TECHNICAL NOTES</source>
          <target state="translated">技术说明</target>
        </trans-unit>
        <trans-unit id="b3db3af9a0e0243f28ed20fcc3b1d5d1faaafbb6" translate="yes" xml:space="preserve">
          <source>TERM</source>
          <target state="translated">TERM</target>
        </trans-unit>
        <trans-unit id="cfc996e2b0441d5f42e4bd8a622b4dd1b2f920a4" translate="yes" xml:space="preserve">
          <source>TERMCAP</source>
          <target state="translated">TERMCAP</target>
        </trans-unit>
        <trans-unit id="4baf6f46b36f22af80f6af8178fa1faa75a5a37d" translate="yes" xml:space="preserve">
          <source>TERMINOLOGY</source>
          <target state="translated">TERMINOLOGY</target>
        </trans-unit>
        <trans-unit id="201ab4b1fe261c4f44a8bfbbdafd62a7606acc46" translate="yes" xml:space="preserve">
          <source>TERMPATH</source>
          <target state="translated">TERMPATH</target>
        </trans-unit>
        <trans-unit id="feb84698a707a37aae3ea67dd9630a278a6ca8f5" translate="yes" xml:space="preserve">
          <source>TERTIARY METHODS</source>
          <target state="translated">第三阶段的方法</target>
        </trans-unit>
        <trans-unit id="16731ae62f4aed11f4e128609c52499c94df9c78" translate="yes" xml:space="preserve">
          <source>TEST ON CYGWIN</source>
          <target state="translated">在CYGWIN上测试</target>
        </trans-unit>
        <trans-unit id="e01006d91764e5a9b5b7e2fa6b5505255129d446" translate="yes" xml:space="preserve">
          <source>TEST STATUS</source>
          <target state="translated">测试状态</target>
        </trans-unit>
        <trans-unit id="1aafa503ed48d02972e5772184ca513598703dbe" translate="yes" xml:space="preserve">
          <source>TEST TYPES</source>
          <target state="translated">测试类型</target>
        </trans-unit>
        <trans-unit id="cb73eb0155af5a3da3bb4a63646b40201ab650c4" translate="yes" xml:space="preserve">
          <source>TESTING</source>
          <target state="translated">TESTING</target>
        </trans-unit>
        <trans-unit id="942de0a9a9abe9fb219e796c9c0f10b53d3c6b67" translate="yes" xml:space="preserve">
          <source>TESTING FRAMEWORKS</source>
          <target state="translated">测试框架</target>
        </trans-unit>
        <trans-unit id="04209ee7219637d26ee9cd4fa722493ca838116d" translate="yes" xml:space="preserve">
          <source>THANK YOU</source>
          <target state="translated">谢谢你</target>
        </trans-unit>
        <trans-unit id="ffa4516bffdd79480b0ffbea2e99e02675eb3752" translate="yes" xml:space="preserve">
          <source>THANKS</source>
          <target state="translated">THANKS</target>
        </trans-unit>
        <trans-unit id="506d81bed6d3b4fa9b202f8f107ea34d18c6fadf" translate="yes" xml:space="preserve">
          <source>THE .netrc FILE</source>
          <target state="translated">.netrc文件</target>
        </trans-unit>
        <trans-unit id="2462f7724da7788ea62fc114cce4eab4e3339b38" translate="yes" xml:space="preserve">
          <source>THE API INTERFACE</source>
          <target state="translated">API接口</target>
        </trans-unit>
        <trans-unit id="eb466ef85e05d613480bb98bc1553047a2722184" translate="yes" xml:space="preserve">
          <source>THE CALL_ FUNCTIONS</source>
          <target state="translated">CALL_FUNCTIONS</target>
        </trans-unit>
        <trans-unit id="db00699a00a64bd8eb4f11307ac364af2186b3b7" translate="yes" xml:space="preserve">
          <source>THE Math::BigInt API</source>
          <target state="translated">Math::BigInt API</target>
        </trans-unit>
        <trans-unit id="5bf87badf6e989985ca5cde31b10d699fd946122" translate="yes" xml:space="preserve">
          <source>THE PERL ENCODING API</source>
          <target state="translated">PERL ENCODING API</target>
        </trans-unit>
        <trans-unit id="2036c7632dcc8e78c342e25b215c2cd28f8d5b22" translate="yes" xml:space="preserve">
          <source>THE PERL MODULE LIBRARY</source>
          <target state="translated">PERL MODULE LIBRARY</target>
        </trans-unit>
        <trans-unit id="a1c725e21d784bf655d9ab26a4cdce89326e975c" translate="yes" xml:space="preserve">
          <source>THE QUESTIONS</source>
          <target state="translated">问题:</target>
        </trans-unit>
        <trans-unit id="fb64ef2c36220a9cb84ef2e67b3a1343a0d67d4d" translate="yes" xml:space="preserve">
          <source>THE RULES OF SYS::SYSLOG</source>
          <target state="translated">SYS::SYSLOG的规则</target>
        </trans-unit>
        <trans-unit id="79e66f9682153b1fcc7f947e99f79c4de4e44b30" translate="yes" xml:space="preserve">
          <source>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</source>
          <target state="translated">本软件是 &quot;按原样 &quot;提供的,没有任何形式的明示或暗示的保证,包括但不限于适销性、特定用途的适用性和不侵权的保证。在任何情况下,作者或版权持有者均不对因本软件或本软件的使用或其他交易而引起的、因本软件的使用或与本软件有关的合同、侵权或其他行为的任何索赔、损害或其他责任负责。</target>
        </trans-unit>
        <trans-unit id="6c98c15d2eefa5232f6a2b60310fc78bdae1017e" translate="yes" xml:space="preserve">
          <source>THE dataconn CLASS</source>
          <target state="translated">数据采集类</target>
        </trans-unit>
        <trans-unit id="472f09c67477280b91b7ae79efeb4fde13fbb523" translate="yes" xml:space="preserve">
          <source>THING</source>
          <target state="translated">THING</target>
        </trans-unit>
        <trans-unit id="2360380b4c35fa48f7e3a9f411a80f126b56989e" translate="yes" xml:space="preserve">
          <source>THINGS TO LOOK OUT FOR</source>
          <target state="translated">需要注意的事项</target>
        </trans-unit>
        <trans-unit id="584497c8a870243751bafe0429bbe1f5826e0915" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Instead, &lt;b&gt;Almost all code should use &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; or &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;&lt;/b&gt;.</source>
          <target state="translated">只能在非常特殊的情况下使用此功能。相反，&lt;b&gt;几乎所有代码都应使用&lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt;或&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="331b8f63effc7e7d25ea524ca1aa92004125d86f" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Most code should use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;() rather than call this directly.</source>
          <target state="translated">只能在非常特殊的情况下使用此功能。大多数代码应使用&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;（）而不是直接调用它。</target>
        </trans-unit>
        <trans-unit id="897ebd5219f0c5caa208699bd4713ae3b784c6e0" translate="yes" xml:space="preserve">
          <source>THREAD CONTEXT</source>
          <target state="translated">主题内容</target>
        </trans-unit>
        <trans-unit id="54e59b7bc3a2e96489d360a7b538367313e355dc" translate="yes" xml:space="preserve">
          <source>THREAD SIGNALLING</source>
          <target state="translated">线程信号</target>
        </trans-unit>
        <trans-unit id="60b08b8acc7a625b8f0d9d41c7e2c28fbb134428" translate="yes" xml:space="preserve">
          <source>THREAD STACK SIZE</source>
          <target state="translated">线程堆栈大小</target>
        </trans-unit>
        <trans-unit id="577fa2796ff34704e76d7424a53614775f345523" translate="yes" xml:space="preserve">
          <source>THREAD STATE</source>
          <target state="translated">线程状态</target>
        </trans-unit>
        <trans-unit id="bf2767662599be6d02741631f5d4e162d0241086" translate="yes" xml:space="preserve">
          <source>THREAD SUPPORT</source>
          <target state="translated">线程支持</target>
        </trans-unit>
        <trans-unit id="f8c7150e13e8ea5e3603e546c189035146b726df" translate="yes" xml:space="preserve">
          <source>THREADS</source>
          <target state="translated">THREADS</target>
        </trans-unit>
        <trans-unit id="f266b9c4765272a11c0ed3c20127bf1d201638dd" translate="yes" xml:space="preserve">
          <source>TIEHANDLE by Sven Verdoolaege &amp;lt;</source>
          <target state="translated">SIE Verdoolaege的TIEHANDLE &amp;lt;</target>
        </trans-unit>
        <trans-unit id="64269f9bd268bf28815bb69e82601cd7e806a37b" translate="yes" xml:space="preserve">
          <source>TIME</source>
          <target state="translated">TIME</target>
        </trans-unit>
        <trans-unit id="6c2529a2a2e078590190100f8e1c4972e8846bc5" translate="yes" xml:space="preserve">
          <source>TIME is</source>
          <target state="translated">时间是</target>
        </trans-unit>
        <trans-unit id="6409a515d9fc80e579966498117e7281bd8b98a0" translate="yes" xml:space="preserve">
          <source>TMP or TEMP</source>
          <target state="translated">TMP或TEMP</target>
        </trans-unit>
        <trans-unit id="47bd70df0e55aba216736b1db7710c6478ab9cbf" translate="yes" xml:space="preserve">
          <source>TO DO</source>
          <target state="translated">要做的事</target>
        </trans-unit>
        <trans-unit id="f8953b7e0e4beba3861ba1d10ca937f8f20fdfee" translate="yes" xml:space="preserve">
          <source>TO DO (maybe)</source>
          <target state="translated">要做的事(也许)</target>
        </trans-unit>
        <trans-unit id="b698c11e84460ed5999bfeb5cbf25b865c238f3c" translate="yes" xml:space="preserve">
          <source>TODO</source>
          <target state="translated">TODO</target>
        </trans-unit>
        <trans-unit id="14081c923a6df4129e72afd1550fb67ed4989fb1" translate="yes" xml:space="preserve">
          <source>TODO all (most?) accessorized methods</source>
          <target state="translated">TODO所有(大部分?)接入方法</target>
        </trans-unit>
        <trans-unit id="bac7481b99347a289b8d37ae17bf40d2f44f1514" translate="yes" xml:space="preserve">
          <source>TODO tests are designed for maintaining an &lt;b&gt;executable TODO list&lt;/b&gt;. These tests are</source>
          <target state="translated">TODO测试旨在维护&lt;b&gt;可执行的TODO列表&lt;/b&gt;。这些测试是</target>
        </trans-unit>
        <trans-unit id="fd32d0b7a9d317be835f0befd340eb49cf589cff" translate="yes" xml:space="preserve">
          <source>TODO, see &lt;a href=&quot;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&quot;&gt;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&lt;/a&gt;</source>
          <target state="translated">待办事项，请参阅&lt;a href=&quot;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&quot;&gt;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="643a0382045e00a908788587a0d4b6d602741dc9" translate="yes" xml:space="preserve">
          <source>TODO: An example or two of =extend, then point to Pod::Simple::Subclassing</source>
          <target state="translated">TODO:一两个=extend的例子,然后指向Pod::Simple::Subclassing。</target>
        </trans-unit>
        <trans-unit id="b95da2f919c7ccb270ebcfb13598d7d2d8b6a01a" translate="yes" xml:space="preserve">
          <source>TODO: Document this</source>
          <target state="translated">待办事项:对此进行记录</target>
        </trans-unit>
        <trans-unit id="26dbb18df63ed25641cd65981a2bd8abf41c6420" translate="yes" xml:space="preserve">
          <source>TODO: Document those cases.</source>
          <target state="translated">待办事项:记录这些案件。</target>
        </trans-unit>
        <trans-unit id="503edd260136cc51f7d583a68da986091421e06f" translate="yes" xml:space="preserve">
          <source>TODO: a corpus of sample Pod input and HTML output? Or common idioms?</source>
          <target state="translated">TODO:花苞输入和HTML输出的样本语料库?或者常见的成语?</target>
        </trans-unit>
        <trans-unit id="767b9b1886f65db5d2c2efe4d311ec16282ddf3e" translate="yes" xml:space="preserve">
          <source>TOTAL RESULTS</source>
          <target state="translated">总结果</target>
        </trans-unit>
        <trans-unit id="6168d5c87ca259972f2a01ffcfd10f094db6e548" translate="yes" xml:space="preserve">
          <source>TRANSFORMATION FORMATS</source>
          <target state="translated">变换格式</target>
        </trans-unit>
        <trans-unit id="08e80e877114a02316e2a85c727dc2ec2e8d050b" translate="yes" xml:space="preserve">
          <source>TRANSLATIONS</source>
          <target state="translated">TRANSLATIONS</target>
        </trans-unit>
        <trans-unit id="881efc13a4ce5c9b7f10acdee48bdf35dab16bcd" translate="yes" xml:space="preserve">
          <source>TREE-BASED PARSING</source>
          <target state="translated">以树为基础的切菜</target>
        </trans-unit>
        <trans-unit id="55c5fdc09a5315c1ab2a4b0b8470a49a53936b60" translate="yes" xml:space="preserve">
          <source>TRIGONOMETRIC FUNCTIONS</source>
          <target state="translated">触发函数</target>
        </trans-unit>
        <trans-unit id="d814d3e7d55ad64b9a68fdab60bd5741a6c86453" translate="yes" xml:space="preserve">
          <source>TUTORIAL</source>
          <target state="translated">TUTORIAL</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="40ea9041285003e004a8f6fe2dd14ebb07961af2" translate="yes" xml:space="preserve">
          <source>TYPES</source>
          <target state="translated">TYPES</target>
        </trans-unit>
        <trans-unit id="3409e584f0822b2e9f6e17cf539649bef61e2695" translate="yes" xml:space="preserve">
          <source>T_OPAQUE supports input and output of simple types. T_OPAQUEPTR can be used to pass these bytes back into C if a pointer is acceptable.</source>
          <target state="translated">T_OPAQUE支持简单类型的输入和输出。如果一个指针是可以接受的,那么T_OPAQUEPTR可以用来将这些字节传回C语言中。</target>
        </trans-unit>
        <trans-unit id="2acdc87aba62301b1c46833bbb0d8a2ab24b5d4c" translate="yes" xml:space="preserve">
          <source>T_PACKEDARRAY is similar to T_PACKED. In fact, the &lt;code&gt;INPUT&lt;/code&gt; (Perl to XSUB) typemap is identical, but the &lt;code&gt;OUTPUT&lt;/code&gt; typemap passes an additional argument to the &lt;code&gt;XS_pack_$ntype&lt;/code&gt; function. This third parameter indicates the number of elements in the output so that the function can handle C arrays sanely. The variable needs to be declared by the user and must have the name &lt;code&gt;count_$ntype&lt;/code&gt; where &lt;code&gt;$ntype&lt;/code&gt; is the normalized C type name as explained above. The signature of the function would be for the example above and &lt;code&gt;foo_t **&lt;/code&gt; :</source>
          <target state="translated">T_PACKEDARRAY与T_PACKED类似。实际上， &lt;code&gt;INPUT&lt;/code&gt; （从Perl到XSUB）类型映射是相同的，但是 &lt;code&gt;OUTPUT&lt;/code&gt; 类型映射将附加参数传递给 &lt;code&gt;XS_pack_$ntype&lt;/code&gt; 函数。第三个参数指示输出中元素的数量，以便函数可以合理地处理C数组。该变量需要由用户声明，并且必须具有名称 &lt;code&gt;count_$ntype&lt;/code&gt; ，其中 &lt;code&gt;$ntype&lt;/code&gt; 是如上所述的规范化C类型名称。该函数的签名将用于上面的示例和 &lt;code&gt;foo_t **&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f31b217f3c82ab68ac7452146830667f22ddb6a9" translate="yes" xml:space="preserve">
          <source>T_U_LONG is used for type &lt;code&gt;U32&lt;/code&gt; in the standard typemap.</source>
          <target state="translated">T_U_LONG用于标准类型图中的 &lt;code&gt;U32&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="067c0c90742a514deacd491758ccd4ba0e1d9275" translate="yes" xml:space="preserve">
          <source>T_U_SHORT is used for type &lt;code&gt;U16&lt;/code&gt; in the standard typemap.</source>
          <target state="translated">T_U_SHORT用于标准类型图中的 &lt;code&gt;U16&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="267d7ded4fb1f4fe830b757c69adcb120de3c36c" translate="yes" xml:space="preserve">
          <source>Table in hex, sorted in 1047 order</source>
          <target state="translated">十六进制表,按1047顺序排列。</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">目录</target>
        </trans-unit>
        <trans-unit id="f6f2ebfa1ea92516cffdbcabbc226ad6201fc14f" translate="yes" xml:space="preserve">
          <source>Tag Handling Utility Functions</source>
          <target state="translated">标签处理实用功能</target>
        </trans-unit>
        <trans-unit id="8a6299767c14d608575e773d7c250b1dd1bef09f" translate="yes" xml:space="preserve">
          <source>Tags and names for human languages</source>
          <target state="translated">人类语言的标签和名称</target>
        </trans-unit>
        <trans-unit id="0caddaacf6ffdd3b4a1f2e6c28c9c60f84fe10e3" translate="yes" xml:space="preserve">
          <source>Tags for the Identification of Languages</source>
          <target state="translated">识别语言的标签</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
