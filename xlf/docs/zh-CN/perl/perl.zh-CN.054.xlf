<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="466f242a777ff54f7c93093c4d90a137e616e30f" translate="yes" xml:space="preserve">
          <source>incremental</source>
          <target state="translated">incremental</target>
        </trans-unit>
        <trans-unit id="3cc46d20365996efe5ff1d4a9e0d401d68f186ed" translate="yes" xml:space="preserve">
          <source>indent</source>
          <target state="translated">indent</target>
        </trans-unit>
        <trans-unit id="bb563dfba453db67bbec56ac010da0ffa7c3928b" translate="yes" xml:space="preserve">
          <source>indentlevel</source>
          <target state="translated">indentlevel</target>
        </trans-unit>
        <trans-unit id="5db560de5f46f68f2cf6566c95097f8e2f035630" translate="yes" xml:space="preserve">
          <source>independent subexpression</source>
          <target state="translated">独立子表达式</target>
        </trans-unit>
        <trans-unit id="e540cdd1328b2b21e29a95405c301b9313b7c346" translate="yes" xml:space="preserve">
          <source>index</source>
          <target state="translated">index</target>
        </trans-unit>
        <trans-unit id="43f884af0bc6ff4672586657430c850be72e55ba" translate="yes" xml:space="preserve">
          <source>index STR,SUBSTR</source>
          <target state="translated">索引 STR,SUBSTR</target>
        </trans-unit>
        <trans-unit id="99e8de47a322ff3d13bd1a7ab53b04a9be460a7c" translate="yes" xml:space="preserve">
          <source>index STR,SUBSTR,POSITION</source>
          <target state="translated">STR,SUBSTR,POSITION</target>
        </trans-unit>
        <trans-unit id="bd7ea36f65e58c5c7bbf8dd9aceaaa73c4fd1c3b" translate="yes" xml:space="preserve">
          <source>indicate an exceptional condition: &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when its argument is an empty array,</source>
          <target state="translated">表示例外情况：当 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 的参数为空数组时，其返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="48ba91ecc2fdf08cfe5fd27747c3c8e58cadd255" translate="yes" xml:space="preserve">
          <source>indicate an exceptional condition: &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when its argument is an empty array,</source>
          <target state="translated">表示例外情况：当 &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 的参数为空数组时，其返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="7a89f7b99b7459c3e3a376ab2fa2510f98bafcc8" translate="yes" xml:space="preserve">
          <source>indicates a problem with the permissions on your /tmp directory within the HFS. To correct that problem issue the command:</source>
          <target state="translated">表示你的/tmp目录在HFS中的权限有问题。要纠正这个问题,请执行以下命令</target>
        </trans-unit>
        <trans-unit id="46adef8d549f47ce21751c1f181a46c1b9f28795" translate="yes" xml:space="preserve">
          <source>indicates that the name is a corrected form for the original name (which remains valid) for the same code point.</source>
          <target state="translated">表示该名称是同一代码点的原名称的更正形式(仍然有效)。</target>
        </trans-unit>
        <trans-unit id="aafce730a5c69801b1cd038fde73b5890228164a" translate="yes" xml:space="preserve">
          <source>indicates that the t/io/openpid.t test of Perl has passed but done so with extraneous messages on stderr from CEE.</source>
          <target state="translated">表示 Perl 的 t/io/openpid.t 测试通过了,但在测试过程中,CEE 的 stderr 上有无关信息。</target>
        </trans-unit>
        <trans-unit id="8beeb2fce58d3cf706cd79c74605d5f6cec09a88" translate="yes" xml:space="preserve">
          <source>indicates that we're running this test as part of the perl core test suite. This is useful for modules that have a dual life on CPAN.</source>
          <target state="translated">表示我们正在将此测试作为 perl 核心测试套件的一部分来运行。这对于在CPAN上有双重生命的模块是很有用的。</target>
        </trans-unit>
        <trans-unit id="f809e25f7ab91ace25f0a3090dbe01b370226459" translate="yes" xml:space="preserve">
          <source>indicates the kind of subroutine:</source>
          <target state="translated">表示子程序的种类。</target>
        </trans-unit>
        <trans-unit id="b02c8cb9a48d2ffe0d568aa710cf9a12f602ddf6" translate="yes" xml:space="preserve">
          <source>indicates whether to use effective (true) or real (false) ids. The method interprets the &lt;code&gt;mode&lt;/code&gt; , &lt;code&gt;uid&lt;/code&gt; and &lt;code&gt;gid&lt;/code&gt; fields, and returns whether or not the current process would be allowed the specified access.</source>
          <target state="translated">指示使用有效（true）还是真实（false）ID。该方法解释 &lt;code&gt;mode&lt;/code&gt; ， &lt;code&gt;uid&lt;/code&gt; 和 &lt;code&gt;gid&lt;/code&gt; 字段，并返回是否允许当前进程进行指定访问。</target>
        </trans-unit>
        <trans-unit id="483df761d9cb026b9fc15456c941640572afafa1" translate="yes" xml:space="preserve">
          <source>indirect filehandle</source>
          <target state="translated">间接文件柄</target>
        </trans-unit>
        <trans-unit id="fcda6fabde0a3b0d0a1cfb866dfe701d0a8396cb" translate="yes" xml:space="preserve">
          <source>indirs</source>
          <target state="translated">indirs</target>
        </trans-unit>
        <trans-unit id="0cedd5bbf169e21b494623b26255ee592a3b4610" translate="yes" xml:space="preserve">
          <source>inetd(8)</source>
          <target state="translated">inetd(8)</target>
        </trans-unit>
        <trans-unit id="d6dbadb30700039562565904023976ef1620b170" translate="yes" xml:space="preserve">
          <source>infers</source>
          <target state="translated">infers</target>
        </trans-unit>
        <trans-unit id="f11b6d2142b8785dcbce524760b8a5eefaf8a51c" translate="yes" xml:space="preserve">
          <source>inflate</source>
          <target state="translated">inflate</target>
        </trans-unit>
        <trans-unit id="2f55f97803b98ce7727f4f32861d8b9d60ec8076" translate="yes" xml:space="preserve">
          <source>inflate $input_filename_or_reference =&amp;gt; $output_filename_or_reference [, OPTS]</source>
          <target state="translated">膨胀$ input_filename_or_reference =&amp;gt; $ output_filename_or_reference [，OPTS]</target>
        </trans-unit>
        <trans-unit id="b6aa8886133566b84aa50528606b6d86540c9b75" translate="yes" xml:space="preserve">
          <source>inflateInit2</source>
          <target state="translated">inflateInit2</target>
        </trans-unit>
        <trans-unit id="f5442a6076f59c3a613b48a99fadcb1f1fb6506c" translate="yes" xml:space="preserve">
          <source>inflateSync</source>
          <target state="translated">inflateSync</target>
        </trans-unit>
        <trans-unit id="554b53fb93ab9b3811936a10d5be83b8a3f3155d" translate="yes" xml:space="preserve">
          <source>info is indented with respect to the backtracking level. Other incidental information appears interspersed within.</source>
          <target state="translated">信息与回溯级别缩进。其他的附带信息则穿插在其中。</target>
        </trans-unit>
        <trans-unit id="57d5da7aaccaec3f7654dc61728d28ae4e5d6035" translate="yes" xml:space="preserve">
          <source>ing dynamically loading extensions would not work with</source>
          <target state="translated">动态加载的扩展将无法使用。</target>
        </trans-unit>
        <trans-unit id="e93b4a3fb9f2ae1924b54eb33df09d70945cd655" translate="yes" xml:space="preserve">
          <source>inherits from &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;继承。</target>
        </trans-unit>
        <trans-unit id="0e39975c1cdd0e165540e4c4297a8811904a676b" translate="yes" xml:space="preserve">
          <source>init_ABSTRACT</source>
          <target state="translated">init_ABSTRACT</target>
        </trans-unit>
        <trans-unit id="7cda590f08b4740a6590d7c44f166ba347919601" translate="yes" xml:space="preserve">
          <source>init_DIRFILESEP</source>
          <target state="translated">init_DIRFILESEP</target>
        </trans-unit>
        <trans-unit id="022f97d2b72f11b72258f24adb9af75996565df6" translate="yes" xml:space="preserve">
          <source>init_INST</source>
          <target state="translated">init_INST</target>
        </trans-unit>
        <trans-unit id="5cadb1507731d78b120c5b699141c83cf1ebcdb1" translate="yes" xml:space="preserve">
          <source>init_INSTALL</source>
          <target state="translated">init_INSTALL</target>
        </trans-unit>
        <trans-unit id="f607f848017aa48f552d6587df059baa8185c0c1" translate="yes" xml:space="preserve">
          <source>init_INSTALL_from_PREFIX</source>
          <target state="translated">init_INSTALL_from_PREFIX</target>
        </trans-unit>
        <trans-unit id="6d4ca819ebd448eadb26fae424a1daafae5538db" translate="yes" xml:space="preserve">
          <source>init_MAKE</source>
          <target state="translated">init_MAKE</target>
        </trans-unit>
        <trans-unit id="9375d2ed65f4648645abb14f2a07f4d4bfc7513c" translate="yes" xml:space="preserve">
          <source>init_VERSION</source>
          <target state="translated">init_VERSION</target>
        </trans-unit>
        <trans-unit id="9a0421852ea0c4dcae1cfa28534cd586cdf0e7d5" translate="yes" xml:space="preserve">
          <source>init_dist</source>
          <target state="translated">init_dist</target>
        </trans-unit>
        <trans-unit id="7d0fbcbecc897f6ad65c1d6d94207049fabca61c" translate="yes" xml:space="preserve">
          <source>init_from_INSTALL_BASE</source>
          <target state="translated">init_from_INSTALL_BASE</target>
        </trans-unit>
        <trans-unit id="d7c9b833e00c346f0bab160ef687e581517f1629" translate="yes" xml:space="preserve">
          <source>init_linker</source>
          <target state="translated">init_linker</target>
        </trans-unit>
        <trans-unit id="e3ab6049dd8bbaac48b18159b44f042e9d537459" translate="yes" xml:space="preserve">
          <source>init_others</source>
          <target state="translated">init_others</target>
        </trans-unit>
        <trans-unit id="e31881026ec06ae1c137294de90fc6573deb157b" translate="yes" xml:space="preserve">
          <source>init_platform</source>
          <target state="translated">init_platform</target>
        </trans-unit>
        <trans-unit id="019990422924c9d39c643c5b10dac864649676c5" translate="yes" xml:space="preserve">
          <source>init_tools</source>
          <target state="translated">init_tools</target>
        </trans-unit>
        <trans-unit id="8ad7d21c71b049b7003ba31b5f1322974df77ac8" translate="yes" xml:space="preserve">
          <source>initial</source>
          <target state="translated">initial</target>
        </trans-unit>
        <trans-unit id="d01e6b638f63d0ce474e5d2056a42868e8e743f1" translate="yes" xml:space="preserve">
          <source>initial special characters (denoting hashes, subroutines and typeglobs), and you said something like &lt;code&gt;*foo * foo&lt;/code&gt; that might be interpreted as either of them. We assumed you meant the infix operator, but please try to make it more clear -- in the example given, you might write &lt;code&gt;*foo * foo()&lt;/code&gt; if you really meant to multiply a glob by the result of calling a function.</source>
          <target state="translated">最初的特殊字符（表示散列，子例程和typeglob），并且您说了类似 &lt;code&gt;*foo * foo&lt;/code&gt; ，它们可能会被解释为它们中的任何一个。我们假设您的意思是infix运算符，但是请尝试使它更清楚-在给定的示例中，如果您确实要通过调用函数的结果来乘以glob，则可以编写 &lt;code&gt;*foo * foo()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="398108d3cc7ae14b27f679220599912f6c8a2948" translate="yes" xml:space="preserve">
          <source>inplace operation (the -i switch) without backup file</source>
          <target state="translated">无备份文件的就地操作(-i开关)</target>
        </trans-unit>
        <trans-unit id="140f86aae51ab9e1cda9b4254fe98a74eb54c1a1" translate="yes" xml:space="preserve">
          <source>input</source>
          <target state="translated">input</target>
        </trans-unit>
        <trans-unit id="075102130b9c2bee418af0f0abf0c05eb6428b5b" translate="yes" xml:space="preserve">
          <source>input fileglob string</source>
          <target state="translated">输入的fileglob字符串</target>
        </trans-unit>
        <trans-unit id="14fafbea21b2afc4ac197a41c562da03ba2fd623" translate="yes" xml:space="preserve">
          <source>input_line_number</source>
          <target state="translated">input_line_number</target>
        </trans-unit>
        <trans-unit id="44b7f604ecb19d542ee06bc079099d93cfbfd8e9" translate="yes" xml:space="preserve">
          <source>inputfile</source>
          <target state="translated">inputfile</target>
        </trans-unit>
        <trans-unit id="dbf3f1e65ed994aafa92d37f106f81eb0f116b8d" translate="yes" xml:space="preserve">
          <source>insert is the first of a chain of nodes to be inserted in place of the nodes. If NULL, no nodes are inserted.</source>
          <target state="translated">insert是要插入的节点链中的第一个节点,如果为NULL,则没有节点被插入。如果为NULL,则不插入任何节点。</target>
        </trans-unit>
        <trans-unit id="fcc537881cd1d5bcddabf48fa8809c7471176de0" translate="yes" xml:space="preserve">
          <source>inside</source>
          <target state="translated">inside</target>
        </trans-unit>
        <trans-unit id="0d1a9a751997ac8a3af8a0e66a529b769c64f9e8" translate="yes" xml:space="preserve">
          <source>inside a &quot;=begin</source>
          <target state="translated">在&quot;=begin &quot;内</target>
        </trans-unit>
        <trans-unit id="0404efe3ff82a89c15bd12e264f4ad6b4b5b9a26" translate="yes" xml:space="preserve">
          <source>inside a 5th eval in the program;</source>
          <target state="translated">在程序中的第5个评价里面。</target>
        </trans-unit>
        <trans-unit id="42069c6395d15e1204e32a0c3d074ee53152dec6" translate="yes" xml:space="preserve">
          <source>inside a given script</source>
          <target state="translated">脚本内</target>
        </trans-unit>
        <trans-unit id="89e02e198979d4b18ae44228f038f8bbcc90e3f2" translate="yes" xml:space="preserve">
          <source>inside out</source>
          <target state="translated">内外</target>
        </trans-unit>
        <trans-unit id="1318be358545620d758b5fbfc720522057898255" translate="yes" xml:space="preserve">
          <source>inside-out</source>
          <target state="translated">inside-out</target>
        </trans-unit>
        <trans-unit id="ffae41ad3ecb9c4be51654fdbdec2294d08ba3a9" translate="yes" xml:space="preserve">
          <source>inside-out classes</source>
          <target state="translated">内向型</target>
        </trans-unit>
        <trans-unit id="89fb511ffe93ee7826661ca1e3bb468dc1ad0ff2" translate="yes" xml:space="preserve">
          <source>install</source>
          <target state="translated">install</target>
        </trans-unit>
        <trans-unit id="40e1b335d61258d5a48f641159e6957a1ff5ea0a" translate="yes" xml:space="preserve">
          <source>install.exe</source>
          <target state="translated">install.exe</target>
        </trans-unit>
        <trans-unit id="e1e2b964389a44069f6393f7f404e4082b21b782" translate="yes" xml:space="preserve">
          <source>installation</source>
          <target state="translated">installation</target>
        </trans-unit>
        <trans-unit id="cc1194708f9e63bdff55fc192202228c34612f10" translate="yes" xml:space="preserve">
          <source>installed already, make sure that no copies or perl are currently running. Later steps of the build may fail since an older version of</source>
          <target state="translated">已经安装,请确保当前没有拷贝或perl运行。后面的编译步骤可能会失败,因为旧版本的</target>
        </trans-unit>
        <trans-unit id="50ce7e3f521a0c513361fb30e1f4fe7052c98c9b" translate="yes" xml:space="preserve">
          <source>installed as</source>
          <target state="translated">安装为</target>
        </trans-unit>
        <trans-unit id="3a29dc65c6a5ec09f964c6e29d915690b9661711" translate="yes" xml:space="preserve">
          <source>installed on your system, and you installed perl manpages, use something like this:</source>
          <target state="translated">安装在你的系统上,并且你安装了perl manpages,使用类似这样的东西。</target>
        </trans-unit>
        <trans-unit id="2907a7c430f00ce076d72256002da217245f85b6" translate="yes" xml:space="preserve">
          <source>installed under another name.</source>
          <target state="translated">以另一个名字安装。</target>
        </trans-unit>
        <trans-unit id="b211760ff4348121f2719ef634ab34586418d866" translate="yes" xml:space="preserve">
          <source>installed, you can follow WWW links from this document in</source>
          <target state="translated">安装,您可以按照本文档中的WWW链接在</target>
        </trans-unit>
        <trans-unit id="0b6c2e3cc55e3bb4fce5a65f78016fe2471ddee9" translate="yes" xml:space="preserve">
          <source>installprefix.U</source>
          <target state="translated">installprefix.U</target>
        </trans-unit>
        <trans-unit id="637fb636ffe280ca72d9b5ea3567bce61300bc40" translate="yes" xml:space="preserve">
          <source>installs the memoized version of &lt;code&gt;fib&lt;/code&gt; as &lt;code&gt;fastfib&lt;/code&gt; ; without the &lt;code&gt;INSTALL&lt;/code&gt; option it would have replaced the old &lt;code&gt;fib&lt;/code&gt; with the memoized version.</source>
          <target state="translated">将记忆的 &lt;code&gt;fib&lt;/code&gt; 版本安装为 &lt;code&gt;fastfib&lt;/code&gt; ; 如果没有 &lt;code&gt;INSTALL&lt;/code&gt; 选项，它将用记忆版本替换旧的 &lt;code&gt;fib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f09b06690d13eb940215681daf48fc97f3a138c" translate="yes" xml:space="preserve">
          <source>installstyle.U</source>
          <target state="translated">installstyle.U</target>
        </trans-unit>
        <trans-unit id="4eb977bcd33ca38c1e0b488eac44ee25547efd26" translate="yes" xml:space="preserve">
          <source>installvars</source>
          <target state="translated">installvars</target>
        </trans-unit>
        <trans-unit id="213d3b87dbe505b0072f3929805c83c8a5257052" translate="yes" xml:space="preserve">
          <source>instantiate an Expect object that reads from the console, waits for some regular expressions and enters some answers</source>
          <target state="translated">实例化一个Expect对象,该对象从控制台读取,等待一些正则表达式并输入一些答案。</target>
        </trans-unit>
        <trans-unit id="6d20c05e1fc41e487c521873baf51d86fd2da739" translate="yes" xml:space="preserve">
          <source>instead do it thru maketext, using no variable interpolation in the key:</source>
          <target state="translated">而不是通过maketext来做,在键中不使用变量插值。</target>
        </trans-unit>
        <trans-unit id="cb82821f5443620916128c66c024a61d87b0565d" translate="yes" xml:space="preserve">
          <source>instead of</source>
          <target state="translated">而不是</target>
        </trans-unit>
        <trans-unit id="2f1647312ffbefd675d8f528a8e37c5009e71a69" translate="yes" xml:space="preserve">
          <source>instead of WriteMakefile().</source>
          <target state="translated">而不是WriteMakefile()。</target>
        </trans-unit>
        <trans-unit id="eba0c6725752796c17e07a2937a561d006b6b15d" translate="yes" xml:space="preserve">
          <source>instead of as equivalent to a &quot;C&quot; formatting code containing only &quot;$foo-&quot;, and then a &quot;bar&amp;gt;&quot; outside the &quot;C&quot; formatting code. This problem has since been solved by the addition of syntaxes like this:</source>
          <target state="translated">而不是等同于仅包含&amp;ldquo; $ foo-&amp;rdquo;的&amp;ldquo; C&amp;rdquo;格式代码，然后是&amp;ldquo; C&amp;rdquo;格式代码之外的&amp;ldquo; bar&amp;gt;&amp;rdquo;。此后，通过添加以下语法解决了此问题：</target>
        </trans-unit>
        <trans-unit id="339af1c38f4492cc861c0d877b7a58adb6e97b45" translate="yes" xml:space="preserve">
          <source>instead of directory names (strictly speaking, a string like &quot;:a&quot; is a path, but not a name, since it contains a punctuation character &quot;:&quot;).</source>
          <target state="translated">而不是目录名(严格来说,像&quot;:a &quot;这样的字符串是一个路径,但不是名称,因为它包含一个标点符号&quot;:&quot;)。</target>
        </trans-unit>
        <trans-unit id="71c621eff819164ca1ecdbe04a4dc834c714be8e" translate="yes" xml:space="preserve">
          <source>instead of file for the source of text.</source>
          <target state="translated">而不是文本源的文件。</target>
        </trans-unit>
        <trans-unit id="88c26c2da878553e470eabd76716a5185e744b60" translate="yes" xml:space="preserve">
          <source>instead of having to write these:</source>
          <target state="translated">而不是要写这些。</target>
        </trans-unit>
        <trans-unit id="91a313e739687b01fbf17ae071a8b7960e77caf3" translate="yes" xml:space="preserve">
          <source>instead of importing it from &lt;code&gt;Scalar::Util&lt;/code&gt; . It should now be possible to disable DESTROY and CLONE. Note that while it isn't disabled, DESTROY will be called before the garbage collection of field hashes, so it will be invoked with a functional object and will continue to function.</source>
          <target state="translated">而不是从 &lt;code&gt;Scalar::Util&lt;/code&gt; 导入它。现在应该可以禁用DESTROY和CLONE了。请注意，虽然未禁用它，但将在对字段哈希进行垃圾回收之前调用DESTROY，因此它将与功能对象一起调用并继续运行。</target>
        </trans-unit>
        <trans-unit id="ca19eef2eb91cd974e6c0056c5fddda19bfec434" translate="yes" xml:space="preserve">
          <source>instead of this:</source>
          <target state="translated">而不是这样。</target>
        </trans-unit>
        <trans-unit id="6c8457cd65849bf5a9285f8b862e990e1a44ac09" translate="yes" xml:space="preserve">
          <source>instead of:</source>
          <target state="translated">而不是:</target>
        </trans-unit>
        <trans-unit id="bcd1c0a3df4642e2147982d69e49b696e53ddfb8" translate="yes" xml:space="preserve">
          <source>instead since</source>
          <target state="translated">相反</target>
        </trans-unit>
        <trans-unit id="55e45921eb338b868da29d4463e5c0b1a7fa032c" translate="yes" xml:space="preserve">
          <source>instead). All tests are run from the</source>
          <target state="translated">代替)。)所有的测试都是在</target>
        </trans-unit>
        <trans-unit id="6568964b0e39083c6acb94093d9e6cd117dbe508" translate="yes" xml:space="preserve">
          <source>instead.</source>
          <target state="translated">instead.</target>
        </trans-unit>
        <trans-unit id="5864cc31660892914a70fe91105e62ed75ab49ed" translate="yes" xml:space="preserve">
          <source>instead. Accepted for backward compatibility; this option no longer does anything.</source>
          <target state="translated">代替。为了向后兼容而接受,这个选项不再有任何作用。</target>
        </trans-unit>
        <trans-unit id="ef03d77059a00bfd1c11d4cbfef75cdec7cdddf4" translate="yes" xml:space="preserve">
          <source>instead. Example:</source>
          <target state="translated">而不是。例如:</target>
        </trans-unit>
        <trans-unit id="204889318f37ff1d1f1f6f99292b41699b359695" translate="yes" xml:space="preserve">
          <source>instead. The first argument is the modulus, the second is the angle (in radians, the full circle is 2*pi). (Mnemonic: &lt;code&gt;e&lt;/code&gt; is used as a notation for complex numbers in the polar form).</source>
          <target state="translated">代替。第一个参数是模数，第二个参数是角度（以弧度表示，完整的圆为2 * pi）。（助记符： &lt;code&gt;e&lt;/code&gt; 用作极性形式的复数的表示法）。</target>
        </trans-unit>
        <trans-unit id="7645f7261302e0c93107f96c3a0a2f2e386a7465" translate="yes" xml:space="preserve">
          <source>instmodsh</source>
          <target state="translated">instmodsh</target>
        </trans-unit>
        <trans-unit id="70e40b33ec9352c176bca23475fd76d8a67b5973" translate="yes" xml:space="preserve">
          <source>instmodsh - A shell to examine installed modules</source>
          <target state="translated">instmodsh-检查已安装模块的shell。</target>
        </trans-unit>
        <trans-unit id="1d52ae13ac6814d64753bd650c8b9eb068671b1f" translate="yes" xml:space="preserve">
          <source>instrumenting</source>
          <target state="translated">instrumenting</target>
        </trans-unit>
        <trans-unit id="cf024bf7ff5c78f4291e2a56cf869c898842d0fd" translate="yes" xml:space="preserve">
          <source>instubperl.U</source>
          <target state="translated">instubperl.U</target>
        </trans-unit>
        <trans-unit id="46f8ab7c0cff9df7cd124852e26022a6bf89e315" translate="yes" xml:space="preserve">
          <source>int</source>
          <target state="translated">int</target>
        </trans-unit>
        <trans-unit id="6c36204b30c264dd8c654c40f76b604c80780842" translate="yes" xml:space="preserve">
          <source>int EXPR</source>
          <target state="translated">int EXPR</target>
        </trans-unit>
        <trans-unit id="1178cafbd64bbbfa77f5ac0a9d5032ed88162781" translate="yes" xml:space="preserve">
          <source>integer</source>
          <target state="translated">integer</target>
        </trans-unit>
        <trans-unit id="81edaa310efa3869e0192600c26c36ecc2b41f19" translate="yes" xml:space="preserve">
          <source>integer - Perl pragma to use integer arithmetic instead of floating point</source>
          <target state="translated">integer-使用整数运算而非浮点运算的Perl pragma。</target>
        </trans-unit>
        <trans-unit id="1f7eb7b938a62fcc0eef0f61d44ced570ecec276" translate="yes" xml:space="preserve">
          <source>integer subscript</source>
          <target state="translated">整数下标</target>
        </trans-unit>
        <trans-unit id="5cbf2e209eef789477d4a083088b0b6f85e093bb" translate="yes" xml:space="preserve">
          <source>integers and numbers with decimal points are allowed in front of an exponent. Then exponents, like the overall sign, are independent of whether we are matching numbers with or without decimal points, and can be 'decoupled' from the mantissa. The overall form of the regexp now becomes clear:</source>
          <target state="translated">整数和带小数点的数字都可以放在指数前面。那么指数就像整体符号一样,与我们匹配的数字是否有小数点无关,可以与mantissa &quot;脱钩&quot;。现在,regexp的整体形式变得清晰了。</target>
        </trans-unit>
        <trans-unit id="8530773c89ade420faa71319e7ce6daa712ea89c" translate="yes" xml:space="preserve">
          <source>intended as a general cross-platform interface to all your C building needs. That would have been a much more ambitious goal!</source>
          <target state="translated">作为一个通用的跨平台接口,满足你所有的C语言构建需求。这本来是一个更远大的目标!</target>
        </trans-unit>
        <trans-unit id="41b2a346afcb03862127323893afda0250576026" translate="yes" xml:space="preserve">
          <source>intention</source>
          <target state="translated">intention</target>
        </trans-unit>
        <trans-unit id="e5d84f3be36511b9cf0c6417bb410c050384d434" translate="yes" xml:space="preserve">
          <source>interface (see &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;) to make very customized executables.</source>
          <target state="translated">接口（请参阅&lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;）以制作非常自定义的可执行文件。</target>
        </trans-unit>
        <trans-unit id="34b8b656f661dde4a485cdae2859f84de092702d" translate="yes" xml:space="preserve">
          <source>interface (see &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;), such things are easy to do repeating the steps outlined in &lt;a href=&quot;#Making-executables-with-a-custom-collection-of-statically-loaded-extensions&quot;&gt;Making executables with a custom collection of statically loaded extensions&lt;/a&gt;, and doing more comprehensive edits to main() of</source>
          <target state="translated">界面（请参阅&lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;），重复&lt;a href=&quot;#Making-executables-with-a-custom-collection-of-statically-loaded-extensions&quot;&gt;执行&amp;ldquo;使用静态加载的扩展程序的自定义集合来制作可执行文件&amp;rdquo;中&lt;/a&gt;概述的步骤，并对的main（）进行更全面的编辑很容易</target>
        </trans-unit>
        <trans-unit id="9404540d9f00d3c17c19b97f44fa1073b9f1c94f" translate="yes" xml:space="preserve">
          <source>interface provided by zlib.</source>
          <target state="translated">由zlib提供的接口。</target>
        </trans-unit>
        <trans-unit id="46e1a61d83495a69cfaa8d84253bec174db2a0fe" translate="yes" xml:space="preserve">
          <source>interface to the dynamic linking mechanisms available on many platforms. Its primary purpose is to implement cheap automatic dynamic loading of Perl modules.</source>
          <target state="translated">的接口,以连接许多平台上的动态链接机制。它的主要目的是实现廉价的Perl模块的自动动态加载。</target>
        </trans-unit>
        <trans-unit id="902ee24d0f5c369c83561e631220c869f56c159a" translate="yes" xml:space="preserve">
          <source>interface_hairy.h</source>
          <target state="translated">interface_hairy.h</target>
        </trans-unit>
        <trans-unit id="58abb7dae834bec7c2231a51b0e43d7b2f1dcd1e" translate="yes" xml:space="preserve">
          <source>interface_simple.h</source>
          <target state="translated">interface_simple.h</target>
        </trans-unit>
        <trans-unit id="c48322cd43b3f5db0aa919df16088078ec067df7" translate="yes" xml:space="preserve">
          <source>interior-sequence storage will not be reclaimed upon destruction!</source>
          <target state="translated">内部序列存储在销毁后将不会被回收!</target>
        </trans-unit>
        <trans-unit id="9f33a7c798af6fd6abb28049d9c1b3edfa2fd24a" translate="yes" xml:space="preserve">
          <source>internal</source>
          <target state="translated">internal</target>
        </trans-unit>
        <trans-unit id="e51ec2956340bd90ad015ad9b1a44eb41fe13048" translate="yes" xml:space="preserve">
          <source>internal error: useconds &amp;lt; 0 (unsigned ... signed ...)</source>
          <target state="translated">内部错误：秒数&amp;lt;0（未签名...已签名...）</target>
        </trans-unit>
        <trans-unit id="8bc675a4bbcb339a374caa4cff4d8cc8a867b3a0" translate="yes" xml:space="preserve">
          <source>internally. &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is just a synonym for &lt;code&gt;&amp;lt;ARGV&amp;gt;&lt;/code&gt; , which is magical. (The pseudo code above doesn't work because it treats &lt;code&gt;&amp;lt;ARGV&amp;gt;&lt;/code&gt; as non-magical.)</source>
          <target state="translated">内部。 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 只是 &lt;code&gt;&amp;lt;ARGV&amp;gt;&lt;/code&gt; 的同义词，这很神奇。（上面的伪代码不起作用，因为它将 &lt;code&gt;&amp;lt;ARGV&amp;gt;&lt;/code&gt; 视为非魔术。）</target>
        </trans-unit>
        <trans-unit id="f95a7232cfa16eef01e2e32a3d063b6807475100" translate="yes" xml:space="preserve">
          <source>interp</source>
          <target state="translated">interp</target>
        </trans-unit>
        <trans-unit id="dd17e57867fd7c7c09f592d502367e7a72bee660" translate="yes" xml:space="preserve">
          <source>interp.c</source>
          <target state="translated">interp.c</target>
        </trans-unit>
        <trans-unit id="5ec54f35edbea363d07d169d7643fe49322214d6" translate="yes" xml:space="preserve">
          <source>interpolate within double quotes, nor do single quotes impede evaluation of variables when used within double quotes.</source>
          <target state="translated">在双引号内进行插值,当在双引号内使用时,单引号也不会妨碍对变量的评估。</target>
        </trans-unit>
        <trans-unit id="21842adaec06e4938f4774dc8dc13c419d06b021" translate="yes" xml:space="preserve">
          <source>interpolate, see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">插值，请参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7365365ce3b1fe060f6c2b335e7ead37819acbe2" translate="yes" xml:space="preserve">
          <source>interpreted as a signed integer</source>
          <target state="translated">解释为有符号的整数</target>
        </trans-unit>
        <trans-unit id="22798399388200f939f1d84f974aacbf98336d00" translate="yes" xml:space="preserve">
          <source>interpreter has to be &lt;b&gt;compiled&lt;/b&gt; differently for each platform because it is implemented in C, but programs written in the Perl language are largely platform independent.</source>
          <target state="translated">解释程序必须针对每个平台进行不同的&lt;b&gt;编译&lt;/b&gt;，因为它是用C实现的，但是用Perl语言编写的程序在很大程度上与平台无关。</target>
        </trans-unit>
        <trans-unit id="09d29e0b1909ff0aa3805759c7f1db36d575f073" translate="yes" xml:space="preserve">
          <source>interpreter threads</source>
          <target state="translated">解释器线程</target>
        </trans-unit>
        <trans-unit id="d897bf481c6d3038f32cd50b3a8b5f6cf56b6348" translate="yes" xml:space="preserve">
          <source>interrupted</source>
          <target state="translated">interrupted</target>
        </trans-unit>
        <trans-unit id="5e40097f4262a60de6a010dd128b47db45b0fccb" translate="yes" xml:space="preserve">
          <source>intflags</source>
          <target state="translated">intflags</target>
        </trans-unit>
        <trans-unit id="a379c85f8c69a0d3679d831f2b58817f66b078af" translate="yes" xml:space="preserve">
          <source>into</source>
          <target state="translated">into</target>
        </trans-unit>
        <trans-unit id="80a3fceeaea68858a65bb33607e442ea25c1e2b4" translate="yes" xml:space="preserve">
          <source>into UTF-8, and similarly converts character code points. This is used when the script is a combination of ASCII (for the variable names and punctuation,</source>
          <target state="translated">转为UTF-8,并同样转换字符代码点。当脚本是ASCII码的组合(用于变量名和标点符号。</target>
        </trans-unit>
        <trans-unit id="5efbb46a90ecb3ca1fecc85280ad96184eda7b36" translate="yes" xml:space="preserve">
          <source>into Unix format before being written to the zip file.</source>
          <target state="translated">变成Unix格式,然后再写入zip文件。</target>
        </trans-unit>
        <trans-unit id="5a8ec964fb55903ea9af77229da3a4f176eca61a" translate="yes" xml:space="preserve">
          <source>into a &lt;code&gt;lineseq&lt;/code&gt; list op, which is returned.</source>
          <target state="translated">进入 &lt;code&gt;lineseq&lt;/code&gt; 列表操作，然后返回。</target>
        </trans-unit>
        <trans-unit id="09bdc6967275516d660dcb43a692aac47b477ffa" translate="yes" xml:space="preserve">
          <source>into a list op if it is not one already, and then converts it into the specified</source>
          <target state="translated">变成一个list op(如果还没有的话),然后把它转换成指定的</target>
        </trans-unit>
        <trans-unit id="0e21ff0e56d846baee28d588470952974dd44859" translate="yes" xml:space="preserve">
          <source>into the package by &lt;code&gt;filter_add&lt;/code&gt; , unless the reference was already blessed.</source>
          <target state="translated">除非引用已被 &lt;code&gt;filter_add&lt;/code&gt; ，否则将由filter_add放入包中。</target>
        </trans-unit>
        <trans-unit id="4f339c3e14932662ae9d0559ad77c63d4936a2d3" translate="yes" xml:space="preserve">
          <source>into this:</source>
          <target state="translated">成这。</target>
        </trans-unit>
        <trans-unit id="760aebbce7f663b4ebc868367cc05da9ede071dc" translate="yes" xml:space="preserve">
          <source>intrpvar.h</source>
          <target state="translated">intrpvar.h</target>
        </trans-unit>
        <trans-unit id="ad345dd991761a50f9adb9059b18cd2ed01ff85e" translate="yes" xml:space="preserve">
          <source>intsize.U</source>
          <target state="translated">intsize.U</target>
        </trans-unit>
        <trans-unit id="2bb8530511b63a0c151d59eadae559d3b4f9fc74" translate="yes" xml:space="preserve">
          <source>intuit</source>
          <target state="translated">intuit</target>
        </trans-unit>
        <trans-unit id="b712b0f1d2c4286763eab08ade92c1091ec6dd8d" translate="yes" xml:space="preserve">
          <source>invalid, potentially earning a different error message than the error message (or warning, or event) generated by a merely unknown (but theoretically valid) htmlname, as in &quot;E&amp;lt;qacute&amp;gt;&quot; [sic]. However, Pod parsers are not required to make this distinction.</source>
          <target state="translated">无效，可能会产生与错误消息（或警告或事件）不同的错误消息，该错误消息（或警告或事件）由仅未知（但理论上有效）的htmlname生成，例如&amp;ldquo; E &amp;lt;qacute&amp;gt;&amp;rdquo; [sic]。但是，不需要Pod解析器进行这种区分。</target>
        </trans-unit>
        <trans-unit id="1292ad671fbfc4d35ca913ab3b9a0129dc90d413" translate="yes" xml:space="preserve">
          <source>inverse operation should be applied in the Fetch method.</source>
          <target state="translated">在Fetch方法中应该应用反操作。</target>
        </trans-unit>
        <trans-unit id="4d2aa1cd14486c3a4a5f5b5f91ebfce00891a815" translate="yes" xml:space="preserve">
          <source>invoke the method call like this:</source>
          <target state="translated">像这样调用方法。</target>
        </trans-unit>
        <trans-unit id="9d2e89cb161a40179909f64d20244135bf4c608d" translate="yes" xml:space="preserve">
          <source>invoke the overload method with &lt;code&gt;&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; as an argument. Instead the above table is consulted as normal, and based on the type of &lt;code&gt;&lt;i&gt;X&lt;/i&gt;&lt;/code&gt;, overloading may or may not be invoked. For simple strings or numbers, &quot;in&quot; becomes equivalent to this:</source>
          <target state="translated">以 &lt;code&gt;&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 为参数调用重载方法。而是正常参考上表，并且基于 &lt;code&gt;&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 的类型，可以调用也可以不调用重载。对于简单的字符串或数字，&amp;ldquo; in&amp;rdquo;等效于此：</target>
        </trans-unit>
        <trans-unit id="a5f53a1db4bd0284aa3660bede417a2b6d5db51f" translate="yes" xml:space="preserve">
          <source>invokes the &lt;b&gt;parse_from_filehandle()&lt;/b&gt; method passing it the corresponding input and output filehandles.</source>
          <target state="translated">调用&lt;b&gt;parse_from_filehandle（）&lt;/b&gt;方法，&lt;b&gt;并向&lt;/b&gt;其传递相应的输入和输出文件句柄。</target>
        </trans-unit>
        <trans-unit id="271383556324a922b015d9d5abb777b3b680293a" translate="yes" xml:space="preserve">
          <source>invoking it for the directory's contents. It does a postorder traversal instead of a preorder traversal, working from the bottom of the directory tree up where &lt;code&gt;find()&lt;/code&gt; works from the top of the tree down.</source>
          <target state="translated">调用它获取目录的内容。它执行后遍历遍历而不是前遍历遍历，从目录树的底部向上运行，而 &lt;code&gt;find()&lt;/code&gt; 从树的顶部向下运行。</target>
        </trans-unit>
        <trans-unit id="1eb7e48254406f0ad58f032dc48fe49432e4957e" translate="yes" xml:space="preserve">
          <source>io/pipe.t</source>
          <target state="translated">io/pipe.t</target>
        </trans-unit>
        <trans-unit id="1ad14cf4402c59fea497f745d3df4a52f09e403b" translate="yes" xml:space="preserve">
          <source>ioctl</source>
          <target state="translated">ioctl</target>
        </trans-unit>
        <trans-unit id="ac706755d569c148cde69cf903fa0e404d5fb464" translate="yes" xml:space="preserve">
          <source>ioctl FILEHANDLE,FUNCTION,SCALAR</source>
          <target state="translated">ioctl FILEHANDLE,FUNCTION,SCALAR......。</target>
        </trans-unit>
        <trans-unit id="81c3f83f167f0c364e4d909401dd2fbced2eb5c4" translate="yes" xml:space="preserve">
          <source>ioctl.h</source>
          <target state="translated">ioctl.h</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="463b46fb59560ec9a4f45c2879fbeca62bdbadb9" translate="yes" xml:space="preserve">
          <source>is #included, it redefines the aTHX and aTHX_ macros to call a function that will return the context. Thus, something like:</source>
          <target state="translated">是#included的,它重新定义了aTHX和aTHX_宏来调用一个返回上下文的函数。因此,类似于</target>
        </trans-unit>
        <trans-unit id="869c55ae7392038ca2ada25a5b705659a6fc2134" translate="yes" xml:space="preserve">
          <source>is - and it has the same effect.)</source>
          <target state="translated">是--而且它具有同样的效果)。)</target>
        </trans-unit>
        <trans-unit id="83b4bd82f5c3073fcab6cd52e2b883488c825747" translate="yes" xml:space="preserve">
          <source>is 0, encoding and decoding replace any malformed character with a</source>
          <target state="translated">为0,编码和解码将任何畸形字符替换为一个</target>
        </trans-unit>
        <trans-unit id="0bda6c393b81ec62986133bc68d16a600e5376b4" translate="yes" xml:space="preserve">
          <source>is 0, or the routine croaks if</source>
          <target state="translated">为0,或者如果</target>
        </trans-unit>
        <trans-unit id="9433dff76d69aeb49c9f1b1e6a810eef80d46303" translate="yes" xml:space="preserve">
          <source>is 1, methods immediately die with an error message. Therefore, when</source>
          <target state="translated">为1时,方法立即死亡,并发出错误信息。因此,当</target>
        </trans-unit>
        <trans-unit id="a4d2c83b695d00259b2771edae5aa2d42137fabb" translate="yes" xml:space="preserve">
          <source>is 1, you should trap exceptions with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt;, unless you really want to let it &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">为1时，应该使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 捕获异常，除非您真的想让它 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08b01d36edc2dd6fddbc0756fbe9c5513a659ab8" translate="yes" xml:space="preserve">
          <source>is 1.</source>
          <target state="translated">是1。</target>
        </trans-unit>
        <trans-unit id="8c0ff8e969bcd171ef8d6c4cddc51856c058ecf8" translate="yes" xml:space="preserve">
          <source>is 1. When a character whose ord value is larger than 0xFFFF is encountered, its place is filled with \x{FFFD} if</source>
          <target state="translated">是1,当遇到一个ord值大于0xFFFF的字符时,它的位置会被填上\x{FFFD},如果</target>
        </trans-unit>
        <trans-unit id="79d529e67b476b62851937c5b23067cd4ce1b5bd" translate="yes" xml:space="preserve">
          <source>is 3 and</source>
          <target state="translated">是3和</target>
        </trans-unit>
        <trans-unit id="9522c6460c5f6f20c4307e7bed6822d3f2d77897" translate="yes" xml:space="preserve">
          <source>is 3. A single &lt;code&gt;ITEM&lt;/code&gt; is always inlined.</source>
          <target state="translated">是3。始终内联单个 &lt;code&gt;ITEM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5c84ec496d8b224c85fc14573a3862152ff5122" translate="yes" xml:space="preserve">
          <source>is &lt;code&gt;C&lt;/code&gt; (for &lt;code&gt;common&lt;/code&gt; ) if the best possible fold is a single code point (</source>
          <target state="translated">如果最佳折叠是单个代码点，则 &lt;code&gt;C&lt;/code&gt; 为C（ &lt;code&gt;common&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="939984a83e875f30897be52391d8f5b35e2e83eb" translate="yes" xml:space="preserve">
          <source>is &lt;code&gt;FooPtr&lt;/code&gt;</source>
          <target state="translated">是 &lt;code&gt;FooPtr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65816c93586e4c56d14bdf38227bc0d35e22af9d" translate="yes" xml:space="preserve">
          <source>is &lt;code&gt;Foo__Bar&lt;/code&gt;</source>
          <target state="translated">是 &lt;code&gt;Foo__Bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e4470db40e21830b033effb525cbd3a1872e1d1" translate="yes" xml:space="preserve">
          <source>is &lt;code&gt;I&lt;/code&gt; , and</source>
          <target state="translated">是 &lt;code&gt;I&lt;/code&gt; ，并且</target>
        </trans-unit>
        <trans-unit id="c6bcb94dd29106e50e5e67679cd655c28bdf7f7a" translate="yes" xml:space="preserve">
          <source>is &lt;code&gt;OP_ANDASSIGN&lt;/code&gt; , &lt;code&gt;OP_ORASSIGN&lt;/code&gt; , or &lt;code&gt;OP_DORASSIGN&lt;/code&gt; , then a suitable conditional optree is constructed. If</source>
          <target state="translated">为 &lt;code&gt;OP_ANDASSIGN&lt;/code&gt; ， &lt;code&gt;OP_ORASSIGN&lt;/code&gt; 或 &lt;code&gt;OP_DORASSIGN&lt;/code&gt; ，则构造一个合适的条件optree。如果</target>
        </trans-unit>
        <trans-unit id="ce21611a14027ecfce0b71f876f7d06f5a1d8b5b" translate="yes" xml:space="preserve">
          <source>is NULL).</source>
          <target state="translated">是NULL)。)</target>
        </trans-unit>
        <trans-unit id="4ad590898ac06ec587af8f66311fb1bbc1535303" translate="yes" xml:space="preserve">
          <source>is a GV supplying the name that should be used by the check function to refer to the callee of the &lt;code&gt;entersub&lt;/code&gt; op if it needs to emit any diagnostics. It is permitted to apply the check function in non-standard situations, such as to a call to a different subroutine or to a method call.</source>
          <target state="translated">是一个GV，如果需要发出任何诊断信息，则GV提供的名称应由check函数用来引用 &lt;code&gt;entersub&lt;/code&gt; op 的被调用方。允许在非标准情况下应用检查功能，例如，对其他子例程的调用或对方法的调用。</target>
        </trans-unit>
        <trans-unit id="08d3d68a728efcdd2ab6530d7d5ecfbfb371a2be" translate="yes" xml:space="preserve">
          <source>is a Perl</source>
          <target state="translated">是一个Perl</target>
        </trans-unit>
        <trans-unit id="130739bc618160f7f1fc5c5a9ff8b4322613f98e" translate="yes" xml:space="preserve">
          <source>is a Perl subroutine that takes no arguments (that's the</source>
          <target state="translated">是一个不接受任何参数的Perl子程序(这就是所谓的</target>
        </trans-unit>
        <trans-unit id="b8059014bc71acfd20332d69515ec64768947e28" translate="yes" xml:space="preserve">
          <source>is a blessed reference or a package name</source>
          <target state="translated">是一个受祝福的引用或包名</target>
        </trans-unit>
        <trans-unit id="37b225c02472425d591d858f478440711108fafc" translate="yes" xml:space="preserve">
          <source>is a combination of the &lt;code&gt;&quot;al&quot;&lt;/code&gt; type and the &lt;code&gt;&quot;ae&quot;&lt;/code&gt; type. Some of the map array elements have the forms given by &lt;code&gt;&quot;al&quot;&lt;/code&gt; , and the rest are the empty string. The property &lt;code&gt;NFKC_Casefold&lt;/code&gt; has this form. An example slice is:</source>
          <target state="translated">是 &lt;code&gt;&quot;al&quot;&lt;/code&gt; 类型和 &lt;code&gt;&quot;ae&quot;&lt;/code&gt; 类型的组合。一些map数组元素具有 &lt;code&gt;&quot;al&quot;&lt;/code&gt; 给出的形式，其余为空字符串。属性 &lt;code&gt;NFKC_Casefold&lt;/code&gt; 具有这种形式。一个示例切片是：</target>
        </trans-unit>
        <trans-unit id="61c94ee116f6a0b02686534706f14ab4ac28cf95" translate="yes" xml:space="preserve">
          <source>is a command-line interface to CPAN.pm. It allows you to install modules or distributions from CPAN, or just get information about them, and a lot more. It is similar to the command line mode of the &lt;a href=&quot;cpan&quot;&gt;CPAN&lt;/a&gt; module,</source>
          <target state="translated">是CPAN.pm的命令行界面。它允许您从CPAN安装模块或发行版，或仅获取有关它们的信息，等等。它类似于&lt;a href=&quot;cpan&quot;&gt;CPAN&lt;/a&gt;模块的命令行模式，</target>
        </trans-unit>
        <trans-unit id="8330f641c616959b5dc4d2a1018e6e7abd8aea60" translate="yes" xml:space="preserve">
          <source>is a command-line interface to the test-running functionality of</source>
          <target state="translated">是一个命令行接口,用于连接测试运行功能的</target>
        </trans-unit>
        <trans-unit id="a3f3d9feee7e7a4f2fbdd3512e2a38e4a55fb2b5" translate="yes" xml:space="preserve">
          <source>is a common abbreviation for a character</source>
          <target state="translated">是一个常用字的缩略语</target>
        </trans-unit>
        <trans-unit id="9febe7f9f7abef798cc6a59cd722795b25995da6" translate="yes" xml:space="preserve">
          <source>is a compiler to convert Perl XS code into C code. It is typically run by the makefiles created by &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;.</source>
          <target state="translated">是将Perl XS代码转换为C代码的编译器。它通常由&lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt;创建的makefile运行。</target>
        </trans-unit>
        <trans-unit id="90882a351b430362ddbaa59a277b7ed39fa5a7e3" translate="yes" xml:space="preserve">
          <source>is a computer science term with a precise but hard-to-explain meaning. Usually, closures are implemented in Perl as anonymous subroutines with lasting references to lexical variables outside their own scopes. These lexicals magically refer to the variables that were around when the subroutine was defined (deep binding).</source>
          <target state="translated">是一个计算机科学术语,具有精确但难以解释的含义。通常情况下,闭包在Perl中是以匿名子程序的形式实现的,它对自己作用域外的词汇变量有持久的引用。这些词性变量神奇地引用了子程序被定义时存在的变量(深度绑定)。</target>
        </trans-unit>
        <trans-unit id="bff47d2ce40b707b0845e92b4a96b5d4dc076d28" translate="yes" xml:space="preserve">
          <source>is a cpp token indicating which entry to return. If the member is not set this will return a default value. The return type depends on</source>
          <target state="translated">是一个cpp标记,表示要返回哪个条目。如果没有设置成员,将返回一个默认值。返回的类型取决于</target>
        </trans-unit>
        <trans-unit id="e5f9de05e11db96a337f0d1eb38539a88b5409b2" translate="yes" xml:space="preserve">
          <source>is a cpp token indicating which entry to set. See &lt;a href=&quot;perlguts#Custom-Operators&quot;&gt;Custom Operators in perlguts&lt;/a&gt; for details about the available members and how they are used. This macro evaluates its argument more than once.</source>
          <target state="translated">是一个cpp令牌，指示要设置的条目。有关可用成员及其使用方式的详细信息，请参见&lt;a href=&quot;perlguts#Custom-Operators&quot;&gt;perlguts中的&amp;ldquo;自定义运算符&amp;rdquo;&lt;/a&gt;。该宏多次评估其自变量。</target>
        </trans-unit>
        <trans-unit id="8b175b89be18442a11782bc701cae16d7d0a17b0" translate="yes" xml:space="preserve">
          <source>is a decimal number, and XML uses &lt;code&gt;&amp;amp;#x&lt;i&gt;HHHH&lt;/i&gt;;&lt;/code&gt; where</source>
          <target state="translated">是十进制数字，XML使用 &lt;code&gt;&amp;amp;#x&lt;i&gt;HHHH&lt;/i&gt;;&lt;/code&gt; 哪里</target>
        </trans-unit>
        <trans-unit id="867e37e0ad95e37a79d195114de1a83f0d632684" translate="yes" xml:space="preserve">
          <source>is a fixed string that must appear at a particular offset from the beginning of the match. A</source>
          <target state="translated">是一个固定的字符串,必须出现在匹配开始时的一个特定偏移量。A</target>
        </trans-unit>
        <trans-unit id="61f3bde037bf2172e594d6db29ca0978f1c08a37" translate="yes" xml:space="preserve">
          <source>is a flag indicating whether we're in a dclone() or a regular de-serialization via thaw(), and</source>
          <target state="translated">是一个标志,表示我们是在dclone()还是通过thaw()进行常规的去序列化,而</target>
        </trans-unit>
        <trans-unit id="177a8f74fbd5fb5c45bffdbce71939307bad58c8" translate="yes" xml:space="preserve">
          <source>is a flag indicating whether we're in a dclone() or a regular serialization via store() or freeze().</source>
          <target state="translated">是一个标志,表示我们是在dclone()还是通过store()或freeze()进行常规序列化。</target>
        </trans-unit>
        <trans-unit id="6e2e892937bca1eea5ee9c95d0d5e5e5f11395dd" translate="yes" xml:space="preserve">
          <source>is a form of if-then-else statement that allows one to choose which patterns are to be matched, based on some condition. There are two types of conditional expression: &lt;code&gt;(?(condition)yes-regexp)&lt;/code&gt; and &lt;code&gt;(?(condition)yes-regexp|no-regexp)&lt;/code&gt;. &lt;code&gt;(?(condition)yes-regexp)&lt;/code&gt; is like an &lt;code&gt;'if () {}'&lt;/code&gt; statement in Perl. If the &lt;code&gt;condition&lt;/code&gt; is true, the &lt;code&gt;yes-regexp&lt;/code&gt; will be matched. If the &lt;code&gt;condition&lt;/code&gt; is false, the &lt;code&gt;yes-regexp&lt;/code&gt; will be skipped and Perl will move onto the next regexp element. The second form is like an &lt;code&gt;'if () {} else {}'&lt;/code&gt; statement in Perl. If the &lt;code&gt;condition&lt;/code&gt; is true, the &lt;code&gt;yes-regexp&lt;/code&gt; will be matched, otherwise the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no-regexp&lt;/a&gt;&lt;/code&gt; will be matched.</source>
          <target state="translated">是if-then-else语句的一种形式，它允许用户根据某些条件选择要匹配的模式。条件表达式有两种类型： &lt;code&gt;(?(condition)yes-regexp)&lt;/code&gt; 和 &lt;code&gt;(?(condition)yes-regexp|no-regexp)&lt;/code&gt; 。 &lt;code&gt;(?(condition)yes-regexp)&lt;/code&gt; 就像Perl中的 &lt;code&gt;'if () {}'&lt;/code&gt; 语句一样。如果 &lt;code&gt;condition&lt;/code&gt; 为真，则将匹配 &lt;code&gt;yes-regexp&lt;/code&gt; 。如果 &lt;code&gt;condition&lt;/code&gt; 为false，则将跳过 &lt;code&gt;yes-regexp&lt;/code&gt; ，Perl将移至下一个regexp元素。第二种形式类似于Perl中的 &lt;code&gt;'if () {} else {}'&lt;/code&gt; 语句。如果 &lt;code&gt;condition&lt;/code&gt; 为真，则 &lt;code&gt;yes-regexp&lt;/code&gt; 将匹配，否则将匹配 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no-regexp&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9a2da8cb2cec1f20323fe27b5dacfdea89a7e07" translate="yes" xml:space="preserve">
          <source>is a hashref (as passed to &lt;code&gt;C_constant&lt;/code&gt; and &lt;code&gt;match_clause&lt;/code&gt; .</source>
          <target state="translated">是一个hashref（传递给 &lt;code&gt;C_constant&lt;/code&gt; 和 &lt;code&gt;match_clause&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="792c669ddbc9146f9c82edec4f8d983c193844e7" translate="yes" xml:space="preserve">
          <source>is a hexadecimal number, also inserts a character into a string. The character it inserts is the one whose Unicode code point (ordinal value) is equal to the number. For example, &lt;code&gt;&quot;\N{U+263a}&quot;&lt;/code&gt; is the Unicode (white background, black foreground) smiley face equivalent to &lt;code&gt;&quot;\N{WHITE SMILING FACE}&quot;&lt;/code&gt; . Also note, &lt;code&gt;\N{&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt; can mean a regex quantifier instead of a character name, when the</source>
          <target state="translated">是十六进制数字，还在字符串中插入一个字符。它插入的字符是Unicode代码点（常规值）等于数字的字符。例如， &lt;code&gt;&quot;\N{U+263a}&quot;&lt;/code&gt; 是Unicode（白色背景，黑色前景）笑脸，等效于 &lt;code&gt;&quot;\N{WHITE SMILING FACE}&quot;&lt;/code&gt; 。另请注意，当 &lt;code&gt;\N{&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt; 表示正则表达式量词而不是字符名称时，</target>
        </trans-unit>
        <trans-unit id="0370087df9b1f80bb3aab519d6395ef994f93a7f" translate="yes" xml:space="preserve">
          <source>is a module meta-data file pioneered by Module::Build and automatically generated as part of the 'distdir' target (and thus 'dist'). See &lt;a href=&quot;../makemaker#Module-Meta-Data&quot;&gt;Module Meta-Data in ExtUtils::MakeMaker&lt;/a&gt;.</source>
          <target state="translated">是由Module :: Build开创的模块元数据文件，并自动生成为&amp;ldquo; distdir&amp;rdquo;目标（因此也是&amp;ldquo; dist&amp;rdquo;）的一部分。请参阅&lt;a href=&quot;../makemaker#Module-Meta-Data&quot;&gt;ExtUtils :: MakeMaker中的模块元数据&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb5615f55577e2ec9ec2ce738441f4f048adaa11" translate="yes" xml:space="preserve">
          <source>is a name for a character that has been documented but was never in any actual standard.</source>
          <target state="translated">是一个已经被记录在案但从未在任何实际标准中出现的字符的名称。</target>
        </trans-unit>
        <trans-unit id="a64ade54cc01a4b8ab579c03320b508d3b51d58b" translate="yes" xml:space="preserve">
          <source>is a name for the Unicode character, as specified in the Unicode standard. For instance, if we wanted to represent or match the astrological sign for the planet Mercury, we could use</source>
          <target state="translated">是Unicode标准中规定的Unicode字符的名称。例如,如果我们想表示或匹配水星的星象,我们可以使用</target>
        </trans-unit>
        <trans-unit id="2afe30cfa025d1ad86d16c1371192737e35d27e5" translate="yes" xml:space="preserve">
          <source>is a not-very-meaningful hex checksum), and run</source>
          <target state="translated">是一个不大的十六进制校验和),并运行</target>
        </trans-unit>
        <trans-unit id="fc99a02b05cb226b1a73a69a63bbd1617e2aa050" translate="yes" xml:space="preserve">
          <source>is a number (or comma separated pair of numbers (see &lt;a href=&quot;perlreref#QUANTIFIERS&quot;&gt;QUANTIFIERS in perlreref&lt;/a&gt;), and is not related to this pragma.</source>
          <target state="translated">是一个数字（或逗号分隔的一对数字（请参见&lt;a href=&quot;perlreref#QUANTIFIERS&quot;&gt;perlreref中的QUANTIFIERS&lt;/a&gt;）），并且与该编译指示无关。</target>
        </trans-unit>
        <trans-unit id="4a38b8230fcc77e55d3807d6b5a4aaef15592a7b" translate="yes" xml:space="preserve">
          <source>is a number in hexadecimal that gives the code point that Unicode has assigned to the desired character. It is customary but not required to use leading zeros to pad the number to 4 digits. Thus &lt;code&gt;\N{U+0041}&lt;/code&gt; means &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; , and you will rarely see it written without the two leading zeros. &lt;code&gt;\N{U+0041}&lt;/code&gt; means &quot;A&quot; even on EBCDIC machines (where the ordinal value of &quot;A&quot; is not 0x41).</source>
          <target state="translated">是十六进制数字，它给出了Unicode已分配给所需字符的代码点。这是惯例，但不需要使用前导零将数字填充到4位数字。因此， &lt;code&gt;\N{U+0041}&lt;/code&gt; 表示 &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; ，并且您几乎看不到没有两个前导零的情况。 &lt;code&gt;\N{U+0041}&lt;/code&gt; 甚至在EBCDIC机器上（&amp;ldquo; A&amp;rdquo;的序号值不是0x41）也表示&amp;ldquo; A&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9f403a1abf70edece08e0c80d52724deac025b2c" translate="yes" xml:space="preserve">
          <source>is a number.</source>
          <target state="translated">是一个数字。</target>
        </trans-unit>
        <trans-unit id="6d72cdfe9071b403de5c891b1782a09bdb8b7a77" translate="yes" xml:space="preserve">
          <source>is a numeric suffix), and other duplicate references to substructures within &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">是数字后缀），以及 &lt;code&gt;$VAR&lt;/code&gt; 结构的其他重复引用</target>
        </trans-unit>
        <trans-unit id="1caf25c615a60e7db02057f097ce6ef82bd0a961" translate="yes" xml:space="preserve">
          <source>is a numeric suffix. Will return a list of strings in a list context.</source>
          <target state="translated">是一个数字后缀。将返回一个列表上下文中的字符串列表。</target>
        </trans-unit>
        <trans-unit id="5450267d9d9934e68cfc043e8aa906ed9b69bfee" translate="yes" xml:space="preserve">
          <source>is a package name</source>
          <target state="translated">是一个包名</target>
        </trans-unit>
        <trans-unit id="a6b5bcbb54d5f0f80b9f08f8fbaf2ea009b106b5" translate="yes" xml:space="preserve">
          <source>is a pointer to the &lt;code&gt;entersub&lt;/code&gt; op, which may be replaced by the check function, and</source>
          <target state="translated">是指向 &lt;code&gt;entersub&lt;/code&gt; op 的指针，可以由检查功能代替，并且</target>
        </trans-unit>
        <trans-unit id="4e118cb5d55603d5852d3f949969f69eb230e7be" translate="yes" xml:space="preserve">
          <source>is a pointer to the C function that is to be added to that opcode's check chain, and</source>
          <target state="translated">是指向要添加到该操作码检查链的C函数的指针,而</target>
        </trans-unit>
        <trans-unit id="8f2f096033e5e09b15119337208eeca0b44d4133" translate="yes" xml:space="preserve">
          <source>is a pointer.</source>
          <target state="translated">是一个指针。</target>
        </trans-unit>
        <trans-unit id="dece3ef8f9c2a4f9d52c4c4c5d98bb83ab5bfede" translate="yes" xml:space="preserve">
          <source>is a positive (unsigned) decimal number of any length is an absolute reference to a capturing group.</source>
          <target state="translated">是一个任意长度的正(无符号)十进制数,是对捕获组的绝对引用。</target>
        </trans-unit>
        <trans-unit id="4edbb45f32f48cd1511fdfb6115d66414ec1fbfb" translate="yes" xml:space="preserve">
          <source>is a positive integer and</source>
          <target state="translated">是一个正整数,并且</target>
        </trans-unit>
        <trans-unit id="165f46eaddab8fb19180056f4de237d41d7417b2" translate="yes" xml:space="preserve">
          <source>is a precomputed hash of the key string, or zero if it has not been precomputed.</source>
          <target state="translated">是关键字符串的预计算哈希值,如果没有预计算,则为零。</target>
        </trans-unit>
        <trans-unit id="7069eb9cb165fec523e6308bce4b06c05a39cb8c" translate="yes" xml:space="preserve">
          <source>is a precomputed hash of the key string, or zero if it has not been precomputed. Returns a mortal scalar copy of the value associated with the key, or &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt; if there is no value associated with the key.</source>
          <target state="translated">是密钥字符串的预先计算的哈希值；如果尚未预先计算，则为零。返回与键关联的值的 &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt; 标量副本，如果没有与键关联的值，则返回＆PL_sv_placeholder。</target>
        </trans-unit>
        <trans-unit id="5da7fecbae6781f458a7622c0a97efc463b638d6" translate="yes" xml:space="preserve">
          <source>is a precomputed hash of the key string, or zero if it has not been precomputed. Returns a mortal scalar representing the value associated with the key, or &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt; if there is no value associated with the key.</source>
          <target state="translated">是密钥字符串的预先计算的哈希值；如果尚未预先计算，则为零。返回表示与键关联的值的凡间标量，如果没有与键关联的值，则返回 &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1da3d543f80049c240b6604f0deb64866fbd0017" translate="yes" xml:space="preserve">
          <source>is a preprocessing token indicating which entry to set. The type of</source>
          <target state="translated">是一个预处理标记,表示要设置哪个条目。的类型是</target>
        </trans-unit>
        <trans-unit id="d9012ca0d0ddb846debfb4395c94c7b45828744f" translate="yes" xml:space="preserve">
          <source>is a preprocessing token; the type of</source>
          <target state="translated">是一个预处理令牌。</target>
        </trans-unit>
        <trans-unit id="a7b7145b8e2f4d29a4eac42b3b05b4ed146ab52f" translate="yes" xml:space="preserve">
          <source>is a preprocessor token indicating which entry to disable.</source>
          <target state="translated">是一个预处理器标记,表示要禁用哪个条目。</target>
        </trans-unit>
        <trans-unit id="fbe9b4cd270e1fcc591a419f6eee763dc9c340d8" translate="yes" xml:space="preserve">
          <source>is a preprocessor token indicating which entry to enable. This will assert (under -DDEBUGGING) if the entry doesn't contain a valid pointer.</source>
          <target state="translated">是一个预处理器令牌,表示要启用哪个条目,如果条目中不包含有效的指针,将断言(在-DDEBUGGING下)。如果条目不包含有效的指针,这将断言(在-DDEBUGGING下)。</target>
        </trans-unit>
        <trans-unit id="ea5ce0a59c714754786219bdd5275aeb9e974151" translate="yes" xml:space="preserve">
          <source>is a preprocessor token indicating which entry to return. If the appropriate flag is not set this will return NULL. The type of the return value depends on which entry you ask for.</source>
          <target state="translated">是一个预处理器标记,表示要返回哪个条目。如果没有设置适当的标志,将返回NULL。返回值的类型取决于你要求的条目。</target>
        </trans-unit>
        <trans-unit id="38ca9aff9fa5b538144546880af0d48a59e862b4" translate="yes" xml:space="preserve">
          <source>is a profiling tool available in many Unix platforms which uses</source>
          <target state="translated">是一个在许多Unix平台上可用的剖析工具,它使用的是</target>
        </trans-unit>
        <trans-unit id="d57a2c635ead24e8cb41d2f62c0df6efe7ec2d7c" translate="yes" xml:space="preserve">
          <source>is a pure</source>
          <target state="translated">是一种纯</target>
        </trans-unit>
        <trans-unit id="c05fe253a73eaf5c843bec936db4e04771e23194" translate="yes" xml:space="preserve">
          <source>is a reference to a hash, keyed by name, values being the hashrefs in the</source>
          <target state="translated">是一个对哈希的引用,以名称为键,值为</target>
        </trans-unit>
        <trans-unit id="9987d31f4281509d0e0c9da093d035205a293365" translate="yes" xml:space="preserve">
          <source>is a regex that matches</source>
          <target state="translated">是一个与</target>
        </trans-unit>
        <trans-unit id="3dca816cf7d96a1f946c0cb0d43d7b15ae0dd1ff" translate="yes" xml:space="preserve">
          <source>is a sequence of digits (not starting with 0) whose value reflects the paren-number of the capture group to recurse to. &lt;code&gt;(?R)&lt;/code&gt; recurses to the beginning of the whole pattern. &lt;code&gt;(?0)&lt;/code&gt; is an alternate syntax for &lt;code&gt;(?R)&lt;/code&gt;. If</source>
          <target state="translated">是一个数字序列（不以0开头），其值反映了要递归到的捕获组的paren-number。 &lt;code&gt;(?R)&lt;/code&gt; 递归到整个模式的开头。 &lt;code&gt;(?0)&lt;/code&gt; 是 &lt;code&gt;(?R)&lt;/code&gt; 的替代语法。如果</target>
        </trans-unit>
        <trans-unit id="bba78d1bb88089201797aae5c1cab963b9424243" translate="yes" xml:space="preserve">
          <source>is a set of flags indicating the kind of pad entry required, which will be set in the value SV for the allocated pad entry:</source>
          <target state="translated">是一组标志,表示所需的焊盘条目种类,它将被设置在分配的焊盘条目的值SV中。</target>
        </trans-unit>
        <trans-unit id="91abdb027092f65d2c1008ca97d5e66bca8c6cd6" translate="yes" xml:space="preserve">
          <source>is a simple matter of writing:</source>
          <target state="translated">是一个简单的写作问题。</target>
        </trans-unit>
        <trans-unit id="60d1efccf0a496e682102a0ca23ae84351984489" translate="yes" xml:space="preserve">
          <source>is a single Han ideograph).</source>
          <target state="translated">是一个单一的汉族表意文字)。)</target>
        </trans-unit>
        <trans-unit id="7f0804766ef794c650875e5cd6577f8ca62d3808" translate="yes" xml:space="preserve">
          <source>is a single character, it is used as both the left and right quote; if</source>
          <target state="translated">是一个单字符,它同时作为左引号和右引号使用;如果</target>
        </trans-unit>
        <trans-unit id="40a10a304b7ecaf941deb45a42636381388f5a3b" translate="yes" xml:space="preserve">
          <source>is a single user-visible &lt;b&gt;character&lt;/b&gt;, which may in turn be several characters (&lt;b&gt;codepoints&lt;/b&gt;) long. For example, a carriage return plus a line feed is a single grapheme but two characters, while a &amp;ldquo;ȫ&amp;rdquo; is a single grapheme but one, two, or even three characters, depending on &lt;b&gt;normalization&lt;/b&gt;.</source>
          <target state="translated">是一个用户可见的&lt;b&gt;字符&lt;/b&gt;，该&lt;b&gt;字符&lt;/b&gt;可能又是几个字符（&lt;b&gt;代码点&lt;/b&gt;）。例如，回车加换行符是单个字形，但包含两个字符，而&amp;ldquo;ȫ&amp;rdquo;是单个字形，但包含一个，两个或什至三个字符，具体取决于&lt;b&gt;标准化&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="94a42c80703dda187cbf9d8dc635962500cae627" translate="yes" xml:space="preserve">
          <source>is a small utility that produces a diff between an extracted archive and an unextracted one. (Note that this utility requires the &lt;code&gt;Text::Diff&lt;/code&gt; module to function properly; this module isn't distributed with perl, but is available from the CPAN.)</source>
          <target state="translated">是一个小型实用程序，可在提取的存档和未提取的存档之间产生差异。（请注意，该实用程序需要 &lt;code&gt;Text::Diff&lt;/code&gt; 模块才能正常运行；该模块未随perl一起分发，但可从CPAN使用。）</target>
        </trans-unit>
        <trans-unit id="0317915857aed0b904067e1c9f03cf0d3827f112" translate="yes" xml:space="preserve">
          <source>is a space-separated list of the login names of the members of the group.</source>
          <target state="translated">是一个以空格分隔的组员登录名列表。</target>
        </trans-unit>
        <trans-unit id="94df1f18f1035b39bcc002ff85383c1903d30b19" translate="yes" xml:space="preserve">
          <source>is a special case of</source>
          <target state="translated">是一种特殊情况</target>
        </trans-unit>
        <trans-unit id="1e4503fa2022262b8888da1041ba3a96a491c954" translate="yes" xml:space="preserve">
          <source>is a strictly positive integer. There are exactly</source>
          <target state="translated">是一个严格的正整数。确切地说,有</target>
        </trans-unit>
        <trans-unit id="22b4d0a1706395e3dc8904448c577180ebc49623" translate="yes" xml:space="preserve">
          <source>is a string of three octal digits, matches the character whose coded character set value is</source>
          <target state="translated">是一串三位八进制数字,匹配的字符的编码字符集的值是</target>
        </trans-unit>
        <trans-unit id="9237185425d334578430573eb80cfb1d7070152b" translate="yes" xml:space="preserve">
          <source>is a string value that will be printed if the test fails. This should be some useful information about the test, pertaining to why it failed, and/or a description of the test. For example:</source>
          <target state="translated">是一个字符串值,如果测试失败将被打印出来。这应该是关于测试的一些有用的信息,与测试失败的原因有关,和/或对测试的描述。例如:</target>
        </trans-unit>
        <trans-unit id="f5d49daf4b07c85bc3e9c9ef9d8fffc8d3e3f192" translate="yes" xml:space="preserve">
          <source>is a string, it is interpreted as a method name - which may (in the usual way) be inherited from another class.</source>
          <target state="translated">是一个字符串,它被解释为一个方法名--它可以(以通常的方式)从另一个类继承。</target>
        </trans-unit>
        <trans-unit id="3586b680080fd5641b2ceb505391e64b157c6d54" translate="yes" xml:space="preserve">
          <source>is a string.</source>
          <target state="translated">是一个字符串。</target>
        </trans-unit>
        <trans-unit id="4ed0c07d66bccd475fa1593c086fc3fa98dec2eb" translate="yes" xml:space="preserve">
          <source>is a subclass of Pod::Simple.</source>
          <target state="translated">是Pod::Simple的一个子类。</target>
        </trans-unit>
        <trans-unit id="0c003c50abcb5c5b0264289df696a4d0a86e8994" translate="yes" xml:space="preserve">
          <source>is a syntax error. The &lt;code&gt;&lt;a href=&quot;text/balanced&quot;&gt;Text::Balanced&lt;/a&gt;&lt;/code&gt; module (standard as of v5.8, and from CPAN before then) is able to do this properly.</source>
          <target state="translated">是语法错误。该 &lt;code&gt;&lt;a href=&quot;text/balanced&quot;&gt;Text::Balanced&lt;/a&gt;&lt;/code&gt; 模块（标准为V5.8，并从CPAN在此之前）能够正确地做到这一点。</target>
        </trans-unit>
        <trans-unit id="2876ee2f7992b444410c106ba7451d0d11add079" translate="yes" xml:space="preserve">
          <source>is a tar-like program, written in pure Perl.</source>
          <target state="translated">是一个用纯Perl编写的类似于tar的程序。</target>
        </trans-unit>
        <trans-unit id="789ff2609c0abca97040f597d9fb835495dbcb55" translate="yes" xml:space="preserve">
          <source>is a type.</source>
          <target state="translated">是一种类型。</target>
        </trans-unit>
        <trans-unit id="ffb330a620d2c555f748134ae75b69f801c184e1" translate="yes" xml:space="preserve">
          <source>is a utility to apply pattern matching to the contents of files in a tar archive.</source>
          <target state="translated">是一个实用程序,用于对 tar 存档中的文件内容进行模式匹配。</target>
        </trans-unit>
        <trans-unit id="5a8daa6bdde6d599bc39901138a55ee1a90e8f3c" translate="yes" xml:space="preserve">
          <source>is actually</source>
          <target state="translated">其实</target>
        </trans-unit>
        <trans-unit id="18ace8663c11e15c7ea7af0769d0b51ea8be5d9e" translate="yes" xml:space="preserve">
          <source>is actually a wrapper to call &lt;code&gt;nmake -f makefile.ce&lt;/code&gt; with appropriate parameters and it accepts extra parameters and forwards them to &lt;code&gt;nmake&lt;/code&gt; command as additional arguments. You should pass target this way.</source>
          <target state="translated">实际上是使用适当的参数调用 &lt;code&gt;nmake -f makefile.ce&lt;/code&gt; 的包装，它接受其他参数并将其作为附加参数转发给 &lt;code&gt;nmake&lt;/code&gt; 命令。您应该以这种方式传递目标。</target>
        </trans-unit>
        <trans-unit id="9fbb21c8780d25c2d62c14d525ba4493fed3f009" translate="yes" xml:space="preserve">
          <source>is actually nothing more than a link to the (executable)</source>
          <target state="translated">其实不过是一个链接到(可执行)的。</target>
        </trans-unit>
        <trans-unit id="5c143cd7b595ecaec566bd11322616c254969521" translate="yes" xml:space="preserve">
          <source>is adopted and becomes the name entry; it must already contain the name string.</source>
          <target state="translated">被采用,成为名称条目;它必须已经包含名称字符串。</target>
        </trans-unit>
        <trans-unit id="f0396ad875d583a36bd13679febb8581f2d969c0" translate="yes" xml:space="preserve">
          <source>is aggregate (eg</source>
          <target state="translated">是总和(例如</target>
        </trans-unit>
        <trans-unit id="bb8fcae34915a333a3718d00db6629dab07f6c3d" translate="yes" xml:space="preserve">
          <source>is aliased to a constant in the look</source>
          <target state="translated">被别名为一个常数,在look</target>
        </trans-unit>
        <trans-unit id="ef7ecbbb686b7c87fdcabe5489a7fa8b747a3327" translate="yes" xml:space="preserve">
          <source>is all lowercase, then the &lt;code&gt;CAPITAL&lt;/code&gt; variant is ignored, otherwise the &lt;code&gt;SMALL&lt;/code&gt; variant is ignored, and both</source>
          <target state="translated">都是小写字母，则忽略 &lt;code&gt;CAPITAL&lt;/code&gt; 变体，否则忽略 &lt;code&gt;SMALL&lt;/code&gt; 变体，并且两者</target>
        </trans-unit>
        <trans-unit id="33ba30df2d642bce79e623dcea9beec8c9b22ce4" translate="yes" xml:space="preserve">
          <source>is allowed so that &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;$AUTOLOAD&lt;/code&gt; would not break under stricture.</source>
          <target state="translated">允许，以便 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;$AUTOLOAD&lt;/code&gt; 在严格的条件下不会中断。</target>
        </trans-unit>
        <trans-unit id="46fdc8e9a838eea8febbedf9514625b10566e73a" translate="yes" xml:space="preserve">
          <source>is almost exactly like saying:</source>
          <target state="translated">几乎和说。</target>
        </trans-unit>
        <trans-unit id="0a5481b3e3d73092971b7b67886c83a33452d0d4" translate="yes" xml:space="preserve">
          <source>is already stored as</source>
          <target state="translated">已经存储为</target>
        </trans-unit>
        <trans-unit id="e58ea1e0a6e29d9ef790e92565bf38a0d8bec6a6" translate="yes" xml:space="preserve">
          <source>is already stored as native 8 bit, then this is a no-op. Can be used to make sure that the UTF-8 flag is off, e.g. when you want to make sure that the substr() or length() function works with the usually faster byte algorithm.</source>
          <target state="translated">已经被存储为原生8位,那么这就是一个无操作的选项。可以用来确保UTF-8标志是关闭的,例如,当你想确保substr()或length()函数与通常更快的字节算法一起工作时。</target>
        </trans-unit>
        <trans-unit id="4ac0b49408848578e35ac08e94a2eb89181b4b85" translate="yes" xml:space="preserve">
          <source>is also checked if it exists in any of the given search directories. This ensures that e.g. &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; is found.</source>
          <target state="translated">还检查它是否存在于任何给定的搜索目录中。这样可以确保找到例如&lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a6684732c17ab02c8bf39ac150678f88574a5f9" translate="yes" xml:space="preserve">
          <source>is also run unconditionally. But for</source>
          <target state="translated">也是无条件运行的。但对于</target>
        </trans-unit>
        <trans-unit id="4b33a9f079edd28e14aa0e8744a90b1c55a32145" translate="yes" xml:space="preserve">
          <source>is always interpreted exactly as specified. Otherwise, if the</source>
          <target state="translated">始终按照指定的方式解释。否则,如果</target>
        </trans-unit>
        <trans-unit id="91b6c84b698378cb0b4e7eec5833aff6a0180f6a" translate="yes" xml:space="preserve">
          <source>is always non-negative, so &lt;code&gt;[x,pi]&lt;/code&gt; is really &lt;code&gt;-x&lt;/code&gt; , a negative number) and the above definition states that</source>
          <target state="translated">始终为非负数，因此 &lt;code&gt;[x,pi]&lt;/code&gt; 实际上是 &lt;code&gt;-x&lt;/code&gt; ，为负数），以上定义指出：</target>
        </trans-unit>
        <trans-unit id="2da11ce46f8ece756162bb2bd4909c483184c069" translate="yes" xml:space="preserve">
          <source>is always used instead of</source>
          <target state="translated">始终用于代替</target>
        </trans-unit>
        <trans-unit id="da8ff8262fd46aff0c9a7c13fdec487e6709caf8" translate="yes" xml:space="preserve">
          <source>is an &lt;code&gt;enum&lt;/code&gt; . If a reference an array is passed then the first element is used in place of the &lt;code&gt;#ifdef&lt;/code&gt; line, and the second element in place of the &lt;code&gt;#endif&lt;/code&gt; . This allows pre-processor constructions such as</source>
          <target state="translated">是一个 &lt;code&gt;enum&lt;/code&gt; 。如果引用了数组，则使用第一个元素代替 &lt;code&gt;#ifdef&lt;/code&gt; 行，使用第二个元素代替 &lt;code&gt;#endif&lt;/code&gt; 。这允许预处理器构造如</target>
        </trans-unit>
        <trans-unit id="e407c507e8202b86ad93aac32e3005d18c456577" translate="yes" xml:space="preserve">
          <source>is an abstract entity. It is not bound to any particular integer width, especially not to the C language &lt;code&gt;char&lt;/code&gt; . Unicode is language-neutral and display-neutral: it does not encode the language of the text, and it does not generally define fonts or other graphical layout details. Unicode operates on characters and on text built from those characters.</source>
          <target state="translated">是一个抽象实体。它没有绑定到任何特定的整数宽度，尤其是没有绑定到C语言 &lt;code&gt;char&lt;/code&gt; 。Unicode与语言无关并且与显示无关：它不对文本的语言进行编码，并且通常不定义字体或其他图形布局细节。Unicode适用于字符以及由这些字符构建的文本。</target>
        </trans-unit>
        <trans-unit id="5b08b5f167ddd80c250223169363f388a08ecb4a" translate="yes" xml:space="preserve">
          <source>is an alias of Encode::Encoder-&amp;gt;new(). This one is exported on demand.</source>
          <target state="translated">是Encode :: Encoder-&amp;gt; new（）的别名。这是按需出口。</target>
        </trans-unit>
        <trans-unit id="72d90656006280a94921d89ee421ad3991654b7e" translate="yes" xml:space="preserve">
          <source>is an alternate name for a character</source>
          <target state="translated">是一个字符的另一个名字</target>
        </trans-unit>
        <trans-unit id="25511ab968aa9c3ee55dc28d290edd3e8efa06cf" translate="yes" xml:space="preserve">
          <source>is an appropriate suffix for the platform.</source>
          <target state="translated">是平台的适当后缀。</target>
        </trans-unit>
        <trans-unit id="7c8e05cc3c89a308a1e47e52a0132a344b0c0867" translate="yes" xml:space="preserve">
          <source>is an array of all the layers destined for the &lt;code&gt;PerlIO *&lt;/code&gt; , and any arguments passed to them,</source>
          <target state="translated">是目的地为 &lt;code&gt;PerlIO *&lt;/code&gt; 的所有层的数组，以及传递给它们的所有参数，</target>
        </trans-unit>
        <trans-unit id="0d1781574c62d77c8d78bcf079651e77516db6c7" translate="yes" xml:space="preserve">
          <source>is an executable image containing the main entry point for Perl, as well as some initialization code. It should be placed in a public directory, and made world executable. In order to run Perl with command line arguments, you should define a foreign command to invoke this image.</source>
          <target state="translated">是一个可执行的映像,包含了Perl的主要入口点,以及一些初始化代码。它应该放在一个公共目录中,并使其成为世界可执行文件。为了使用命令行参数运行Perl,你应该定义一个外来命令来调用这个映像。</target>
        </trans-unit>
        <trans-unit id="da2e040dacc739036641a30943ec92d4d35fb00f" translate="yes" xml:space="preserve">
          <source>is an executable image which contains all of the basic functionality of Perl, but cannot take advantage of Perl XS extensions and has a hard-wired list of library locations for loading pure-Perl modules. It is used extensively to build and test Perl and various extensions, but is not installed.</source>
          <target state="translated">是一个可执行映像,它包含了Perl的所有基本功能,但不能利用Perl XS的扩展,并且有一个硬连接的库位置列表,用于加载纯Perl模块。它被广泛用于构建和测试Perl和各种扩展,但并没有安装。</target>
        </trans-unit>
        <trans-unit id="295e5d231e93271cf2e87ff53177a2085d57895e" translate="yes" xml:space="preserve">
          <source>is an interface to &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; - paste in your error message to it, and it'll explain it for you.</source>
          <target state="translated">是&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;的接口-将错误消息粘贴到该接口，它将为您解释。</target>
        </trans-unit>
        <trans-unit id="03aebc26e2a8086c7faa0ae9cd0a6e9a5014db91" translate="yes" xml:space="preserve">
          <source>is an older tool, originally intended for the development of XS modules, which comes packaged with the Perl distribution.</source>
          <target state="translated">是一个较老的工具,最初是用于开发XS模块的,它与Perl发行版一起打包。</target>
        </trans-unit>
        <trans-unit id="c81e7450f22acc425e61712a1eaf2d872d794637" translate="yes" xml:space="preserve">
          <source>is an op that has been optimized away by perl. They're displayed with a sequence-number of '-', because they are not executed (they don't appear in previous example), they're printed here because they reflect the parse.</source>
          <target state="translated">是一个已经被perl优化掉的操作。它们显示的序列号是'-',因为它们没有被执行(在前面的例子中没有出现),在这里打印出来是因为它们反映了解析结果。</target>
        </trans-unit>
        <trans-unit id="9d5e6dcb345ffb1eb11d5479427e9235760d76bd" translate="yes" xml:space="preserve">
          <source>is an optional preconstructed &lt;code&gt;enterloop&lt;/code&gt; op to use in the loop; if it is null then a suitable op will be constructed automatically.</source>
          <target state="translated">是在循环中使用的可选的预构建 &lt;code&gt;enterloop&lt;/code&gt; op；如果为null，则将自动构造合适的op。</target>
        </trans-unit>
        <trans-unit id="acf27be8c27b564ea715f62509eb99be46454cb1" translate="yes" xml:space="preserve">
          <source>is another German-speaking magazine for Perl beginners (see &lt;a href=&quot;http://perl-zeitung.at.tf&quot;&gt;http://perl-zeitung.at.tf&lt;/a&gt; ).</source>
          <target state="translated">是另一本面向Perl初学者的德语杂志（请参阅&lt;a href=&quot;http://perl-zeitung.at.tf&quot;&gt;http://perl-zeitung.at.tf&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="aa85c7e6136b506253070be8f818e9007d9cfdee" translate="yes" xml:space="preserve">
          <source>is any integer.</source>
          <target state="translated">是任何整数。</target>
        </trans-unit>
        <trans-unit id="be3f59631fae1d8b0922b826e41efeee4ec99b4a" translate="yes" xml:space="preserve">
          <source>is any integer. atan2(0, 0) is undefined, and if the complex arguments are used for atan2(), a division by zero will happen if z1**2+z2**2 == 0.</source>
          <target state="translated">atan2(0,0)是未定义的,如果在atan2()中使用复数参数,如果z1**2+z2**2==0,就会发生除以零的情况。</target>
        </trans-unit>
        <trans-unit id="5783bc43b68f92b02879e3b2c43e9bdd7ca36459" translate="yes" xml:space="preserve">
          <source>is any of the above or an unblessed reference</source>
          <target state="translated">是以上任何一种,还是一种无缺的参考。</target>
        </trans-unit>
        <trans-unit id="30e4914477a91ec9b94e791e584cbb65619eeac2" translate="yes" xml:space="preserve">
          <source>is as above. Note that it is possible for calls to &lt;code&gt;pre_&lt;/code&gt; and &lt;code&gt;post_end&lt;/code&gt; to nest, if there is something on the save stack that calls string eval.</source>
          <target state="translated">如上所述。请注意，有可能调用 &lt;code&gt;pre_&lt;/code&gt; 和 &lt;code&gt;post_end&lt;/code&gt; 筑巢，如果在保存堆栈的呼叫字符串的eval东西。</target>
        </trans-unit>
        <trans-unit id="36eb847ac03124888eb9b23e1494c3b3077980d8" translate="yes" xml:space="preserve">
          <source>is asking for trouble, since</source>
          <target state="translated">是自找麻烦,因为</target>
        </trans-unit>
        <trans-unit id="df9814075a8a9994907bb7e926342f5cd51701bc" translate="yes" xml:space="preserve">
          <source>is associated with the matched string, and is reset by each assignment to pos(). Zero-length matches at the end of the previous match are ignored during &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与匹配的字符串相关联，并通过对pos（）的每次赋值重置。在 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 期间，将忽略先前匹配末尾的零长度匹配。</target>
        </trans-unit>
        <trans-unit id="6941b5c781a0a521041b5c1dd8c16baced227b53" translate="yes" xml:space="preserve">
          <source>is at &lt;a href=&quot;http://sunsite.dk/RFC/rfc/rfc2277.html&quot;&gt;http://sunsite.dk/RFC/rfc/rfc2277.html&lt;/a&gt; -- much of it is just things of interest to protocol designers, but it explains some basic concepts, like the distinction between locales and language-tags.</source>
          <target state="translated">可以在&lt;a href=&quot;http://sunsite.dk/RFC/rfc/rfc2277.html&quot;&gt;http://sunsite.dk/RFC/rfc/rfc2277.html上找到&lt;/a&gt;，其中的大部分只是协议设计者所感兴趣的，但是它解释了一些基本概念，例如语言环境和语言标签之间的区别。</target>
        </trans-unit>
        <trans-unit id="3695a320bebe6f3e9a28f189a22d75b358931b52" translate="yes" xml:space="preserve">
          <source>is at least 3, &lt;code&gt;for&lt;/code&gt; loops will be translated into equivalent while loops with continue blocks; for instance</source>
          <target state="translated">至少为3， &lt;code&gt;for&lt;/code&gt; 循环将转换为具有while块的while循环；例如</target>
        </trans-unit>
        <trans-unit id="a932359d1eeb1e12e4da8b3878fa5ee714a70634" translate="yes" xml:space="preserve">
          <source>is at least 5, &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declarations will be translated into &lt;code&gt;BEGIN&lt;/code&gt; blocks containing calls to &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;; for instance,</source>
          <target state="translated">至少为5， &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 声明将转换为包含对 &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 的调用的 &lt;code&gt;BEGIN&lt;/code&gt; 块；例如，</target>
        </trans-unit>
        <trans-unit id="c119f702a61cc525d7584c5eac4566db8774adc2" translate="yes" xml:space="preserve">
          <source>is at least 512kbyte (you can check this with: &lt;code&gt;stubedit cc1.exe&lt;/code&gt; ).</source>
          <target state="translated">至少为512kbyte（可以通过 &lt;code&gt;stubedit cc1.exe&lt;/code&gt; 进行检查）。</target>
        </trans-unit>
        <trans-unit id="f1edba509463471e4477759e68744d683b69a1f8" translate="yes" xml:space="preserve">
          <source>is at least 7, &lt;code&gt;if&lt;/code&gt; statements will be translated into equivalent expressions using &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;?:&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; ; for instance</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 语句将使用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ， &lt;code&gt;?:&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; 转换为等效表达式，则至少为7 。例如</target>
        </trans-unit>
        <trans-unit id="3ebcba5300e1807510d46aa9590e6c6a47b91326" translate="yes" xml:space="preserve">
          <source>is basically equivalent to</source>
          <target state="translated">基本等同于</target>
        </trans-unit>
        <trans-unit id="f2a370a954d86dc4cfe469a68c83fd68b9353b30" translate="yes" xml:space="preserve">
          <source>is basically equivalent to this:</source>
          <target state="translated">基本等同于此。</target>
        </trans-unit>
        <trans-unit id="ffc0ffcd2f24cb5977dd7a038df50d731e24c9b9" translate="yes" xml:space="preserve">
          <source>is basically equivalent to:</source>
          <target state="translated">基本等同于。</target>
        </trans-unit>
        <trans-unit id="efa6ff7d8cd2f270c8d3889d8b02bcd7a2b0379a" translate="yes" xml:space="preserve">
          <source>is be a hashref of types the constant function will return. In ExtUtils::Constant::XS this method is used to returns a hashref keyed IV NV PV SV to show which combination of pointers will be needed in the C argument list generated by C_constant_other_params_definition and C_constant_other_params</source>
          <target state="translated">是常量函数将返回的类型的哈希夫。在ExtUtils::Constant::XS中,这个方法用来返回一个键入IV NV PV SV的哈希夫,以显示在C_constant_other_params_definition和C_constant_other_params生成的C参数列表中,需要哪些指针组合。</target>
        </trans-unit>
        <trans-unit id="beed228bb7571f61ef1254143747172d93f725df" translate="yes" xml:space="preserve">
          <source>is because &quot;:&quot; often comes up in paths, like &lt;code&gt;&quot;c:/perl/lib&quot;&lt;/code&gt; .)</source>
          <target state="translated">是因为&amp;ldquo;：&amp;rdquo;通常出现在路径中，例如 &lt;code&gt;&quot;c:/perl/lib&quot;&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="b00405322d6959fc080131bfe766ce7448452d15" translate="yes" xml:space="preserve">
          <source>is being compiled you may (depending on the operating system release) see an additional compiler flag being used: &lt;code&gt;-DNO_EFF_ONLY_OK&lt;/code&gt; . This is normal and refers to a feature that is relevant only if you use the &lt;code&gt;filetest&lt;/code&gt; pragma. In older releases of the operating system the feature was broken and the NO_EFF_ONLY_OK instructs Perl not to use the feature.</source>
          <target state="translated">正在编译中（可能取决于操作系统版本），您会看到正在使用其他编译器标志： &lt;code&gt;-DNO_EFF_ONLY_OK&lt;/code&gt; 。这是正常现象，是指仅在使用 &lt;code&gt;filetest&lt;/code&gt; 编译指示时才相关的功能。在较早的操作系统版本中，该功能已损坏，并且NO_EFF_ONLY_OK指示Perl不要使用该功能。</target>
        </trans-unit>
        <trans-unit id="5a7b7ea63bcfd4e7e919847cbe05a532d715b559" translate="yes" xml:space="preserve">
          <source>is being used, false if not.</source>
          <target state="translated">正在使用,如果不使用则为false。</target>
        </trans-unit>
        <trans-unit id="46adb9ce162b644638d5f6ea5ff817ff62b057cb" translate="yes" xml:space="preserve">
          <source>is being used, the Perl subroutine is specified as a C string. In this case the subroutine name has been 'hard-wired' into the code.</source>
          <target state="translated">的时候,Perl 子程序被指定为 C 字符串。在这种情况下,子程序的名称已经被 &quot;硬连接 &quot;到代码中。</target>
        </trans-unit>
        <trans-unit id="9a77723c3a569791ba0daaaeffeea04df4037001" translate="yes" xml:space="preserve">
          <source>is better than</source>
          <target state="translated">胜过</target>
        </trans-unit>
        <trans-unit id="e0502ca9d9f39e4be66fbcd074913732a28c22e5" translate="yes" xml:space="preserve">
          <source>is bigger then the group level.</source>
          <target state="translated">大于组级。</target>
        </trans-unit>
        <trans-unit id="343082504b9a0655ece30e29661825f00250e1d3" translate="yes" xml:space="preserve">
          <source>is built using</source>
          <target state="translated">是用</target>
        </trans-unit>
        <trans-unit id="0854b2a1714cc6445ab7e4ddf8c2db426ce57837" translate="yes" xml:space="preserve">
          <source>is built,</source>
          <target state="translated">是建。</target>
        </trans-unit>
        <trans-unit id="cf600e83596fbcfa5796fa75f5e47d5ff1240570" translate="yes" xml:space="preserve">
          <source>is built. This is a single executable (without DLL), intended to run on Win32, and it will facilitate remaining build process; all binaries built after it are foreign and should not run locally.</source>
          <target state="translated">被构建。这是一个单一的可执行文件(不含DLL),打算在Win32上运行,它将方便剩余的构建过程;在它之后构建的所有二进制文件都是外来的,不应该在本地运行。</target>
        </trans-unit>
        <trans-unit id="5255e100819691e64fa9b4a02162efc6ad2a7971" translate="yes" xml:space="preserve">
          <source>is called</source>
          <target state="translated">叫做</target>
        </trans-unit>
        <trans-unit id="0226beba7cd0e825fb4e38da5573e429bdef0536" translate="yes" xml:space="preserve">
          <source>is called like this</source>
          <target state="translated">是这样叫的</target>
        </trans-unit>
        <trans-unit id="01efdfc207c40685a40505df8a8c6de053fd276d" translate="yes" xml:space="preserve">
          <source>is called thus</source>
          <target state="translated">所谓</target>
        </trans-unit>
        <trans-unit id="d6879492c8d67c42189022fa109e24255ed0a45a" translate="yes" xml:space="preserve">
          <source>is called, the interpreter's syntax parse tree and symbol tables are cleaned up, and global variables are reset. The second assignment to &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; is needed because perl_construct resets it to &lt;code&gt;0&lt;/code&gt; .</source>
          <target state="translated">调用后，将清除解释程序的语法分析树和符号表，并重置全局变量。需要对 &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; 进行第二次分配，因为perl_construct将其重置为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e0ec575b76e364e00644cc1e1456d4682a0ca12" translate="yes" xml:space="preserve">
          <source>is called. If</source>
          <target state="translated">被称为。如果</target>
        </trans-unit>
        <trans-unit id="ec4d308b2a7ec41f333fa7e39a6baafd8199536a" translate="yes" xml:space="preserve">
          <source>is completed, control reverts back to Perl more or less immediately.</source>
          <target state="translated">完成后,控制权或多或少会立即恢复到Perl。</target>
        </trans-unit>
        <trans-unit id="9808d99a48eef922543021cb1dd28efe676ff96c" translate="yes" xml:space="preserve">
          <source>is computed to be</source>
          <target state="translated">经计算为</target>
        </trans-unit>
        <trans-unit id="26d5193d0879df7801befc090d32f16dea7f62bc" translate="yes" xml:space="preserve">
          <source>is considerably slower.)</source>
          <target state="translated">要慢得多)。)</target>
        </trans-unit>
        <trans-unit id="7457b7ec85de496d14e61652a0482492c7d41031" translate="yes" xml:space="preserve">
          <source>is considered an octal escape (but something like &lt;code&gt;\18&lt;/code&gt; is the same as &lt;code&gt;\0018&lt;/code&gt; ; that is, the octal escape &lt;code&gt;&quot;\001&quot;&lt;/code&gt; followed by a literal digit &lt;code&gt;&quot;8&quot;&lt;/code&gt; ).</source>
          <target state="translated">被认为是八进制转义符（但 &lt;code&gt;\18&lt;/code&gt; 与 &lt;code&gt;\0018&lt;/code&gt; 相同；也就是说，八进制转义符 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 后跟文字数字 &lt;code&gt;&quot;8&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0c6c59d53731eb4d62ce728fe5d323178a21c69a" translate="yes" xml:space="preserve">
          <source>is consumed by this function and becomes part of the returned op tree.</source>
          <target state="translated">被这个函数消耗掉,成为返回的运算树的一部分。</target>
        </trans-unit>
        <trans-unit id="dc258a7b37a09c5a513defc7421c502e2dfc41b4" translate="yes" xml:space="preserve">
          <source>is copied by this function, which thus does not take ownership of any reference to it, and later changes to the scalar will not be reflected in the value visible in the &lt;code&gt;refcounted_he&lt;/code&gt; . Complex types of scalar will not be stored with referential integrity, but will be coerced to strings.</source>
          <target state="translated">由此函数复制，因此该函数不拥有对该函数的任何引用，以后对标量的更改将不会反映在 &lt;code&gt;refcounted_he&lt;/code&gt; 中可见的值中。标量的复杂类型将不会以引用完整性存储，而是将被强制为字符串。</target>
        </trans-unit>
        <trans-unit id="fbf2c8c541938c6077a677f840135912410a3a25" translate="yes" xml:space="preserve">
          <source>is copied by this function, which thus does not take ownership of any reference to it, and later changes to the scalar will not be reflected in the value visible in the cop hints hash. Complex types of scalar will not be stored with referential integrity, but will be coerced to strings.</source>
          <target state="translated">是由这个函数复制的,因此它不拥有对它的任何引用的所有权,以后对标量的改变将不会反映在cop hints hash中可见的值中。复杂类型的标量将不会以引用完整性的方式存储,而会被胁迫为字符串。</target>
        </trans-unit>
        <trans-unit id="30e3ef0b8ff559774ec5ed938edd84b1f238cb9b" translate="yes" xml:space="preserve">
          <source>is copied to a new hash, which has the &lt;code&gt;%^H&lt;/code&gt; -specific magic added to it. A pointer to the new hash is returned.</source>
          <target state="translated">被复制到新的哈希，其中添加了 &lt;code&gt;%^H&lt;/code&gt; 特定的魔术。返回指向新哈希的指针。</target>
        </trans-unit>
        <trans-unit id="747f6e21ce3daf93f93dd4472373d8de083a21bc" translate="yes" xml:space="preserve">
          <source>is created using &lt;code&gt;TMP&lt;/code&gt; or &lt;code&gt;TEMP&lt;/code&gt; environment variable, via &lt;code&gt;tempnam&lt;/code&gt; .</source>
          <target state="translated">通过 &lt;code&gt;TMP&lt;/code&gt; 或 &lt;code&gt;TEMP&lt;/code&gt; 环境变量通过 &lt;code&gt;tempnam&lt;/code&gt; 创建。</target>
        </trans-unit>
        <trans-unit id="0a61d9fe71ed76708341c4ca0d849865f0cdc3b4" translate="yes" xml:space="preserve">
          <source>is currently unused and ignored. In future it may be used to pass in information used to change the C indentation style used.] The best way to maintain consistency is to pass in a hash reference and let this function update it.</source>
          <target state="translated">目前未被使用和忽略。将来可能会用它来传递用于改变所使用的C语言缩进风格的信息]。保持一致性的最好方法是传入一个哈希引用,让这个函数更新它。</target>
        </trans-unit>
        <trans-unit id="9813a16c1f4cea91b9c2c265d663c4bd1846f7de" translate="yes" xml:space="preserve">
          <source>is currently unused and must be zero.</source>
          <target state="translated">目前未使用,必须为零。</target>
        </trans-unit>
        <trans-unit id="99e47089baf7bf5a97290b50bc31baafb3fecfdf" translate="yes" xml:space="preserve">
          <source>is currently unused and should always be 1.</source>
          <target state="translated">目前未使用,应始终为1。</target>
        </trans-unit>
        <trans-unit id="e342eb67743e357f6c505cac08784c21c4ae08f3" translate="yes" xml:space="preserve">
          <source>is dead simple: for given cross-architecture places in @INC a path where perl modules are, and right</source>
          <target state="translated">很简单:在@INC中给定的跨架构的地方,给出一个perl模块所在的路径,然后右击</target>
        </trans-unit>
        <trans-unit id="c705d4c7e0b74c44541c11aa71e1a8a9918a05c8" translate="yes" xml:space="preserve">
          <source>is defined as a fixed string that can appear at any point in a range of positions relative to the start of the match. For example,</source>
          <target state="translated">被定义为一个固定的字符串,可以出现在相对于比赛开始的位置范围内的任何一点。例如:</target>
        </trans-unit>
        <trans-unit id="ecb2ca25d83a1d9ea96055686343475429c34ffd" translate="yes" xml:space="preserve">
          <source>is defined as being a substring that must appear for the pattern to match. An</source>
          <target state="translated">被定义为一个子串,这个子串必须出现在模式匹配中。一个</target>
        </trans-unit>
        <trans-unit id="1da1038b5104f0f95e494512f9adf3b8d6beaf10" translate="yes" xml:space="preserve">
          <source>is defined, such as when running under GNV bash.</source>
          <target state="translated">的定义,例如在GNV bash下运行时。</target>
        </trans-unit>
        <trans-unit id="deb74afad5c0f4e11684626863d8cd55cb9bdeee" translate="yes" xml:space="preserve">
          <source>is defined, then it is used to avoid &lt;code&gt;memEQ&lt;/code&gt; for short names, or to generate a comment to highlight the position of the character in the &lt;code&gt;switch&lt;/code&gt; statement.</source>
          <target state="translated">定义后，它可用于避免使用短名称的 &lt;code&gt;memEQ&lt;/code&gt; 或生成注释以突出显示字符在 &lt;code&gt;switch&lt;/code&gt; 语句中的位置。</target>
        </trans-unit>
        <trans-unit id="991181f3df7a8cdf4f7168cba333bb5158ffb3d9" translate="yes" xml:space="preserve">
          <source>is delimited by bracketing quotes, the</source>
          <target state="translated">是由括号分隔的。</target>
        </trans-unit>
        <trans-unit id="0aab59497e397eb628c4ae4e65530bcc8256b5ef" translate="yes" xml:space="preserve">
          <source>is designed to test whether a particular code snippet has been compiled into an optree containing specified numbers of particular op types. This is good for testing whether optimisations which alter ops, such as converting an &lt;code&gt;aelem&lt;/code&gt; op into an &lt;code&gt;aelemfast&lt;/code&gt; op, are really doing that.</source>
          <target state="translated">用于测试特定代码段是否已编译到包含指定数量的特定op类型的optree中。这对于测试更改操作的优化（例如将 &lt;code&gt;aelem&lt;/code&gt; op转换为 &lt;code&gt;aelemfast&lt;/code&gt; op）是否确实在进行测试很有帮助。</target>
        </trans-unit>
        <trans-unit id="416051867536031c9c339fabd2716eb40c91334e" translate="yes" xml:space="preserve">
          <source>is directed to &lt;b&gt;STDOUT&lt;/b&gt;, unlike the pragma.</source>
          <target state="translated">定向到&lt;b&gt;STDOUT&lt;/b&gt;，与杂注不同。</target>
        </trans-unit>
        <trans-unit id="9553c90ac38c53c0080494be25343dc34ae22d57" translate="yes" xml:space="preserve">
          <source>is effectively</source>
          <target state="translated">实际上</target>
        </trans-unit>
        <trans-unit id="73b6c5e895538dd2917ae4f7b4e4274c97cfa6db" translate="yes" xml:space="preserve">
          <source>is empty if</source>
          <target state="translated">是空的,如果</target>
        </trans-unit>
        <trans-unit id="f685ee609385b240742c6531d09c2e99375d25df" translate="yes" xml:space="preserve">
          <source>is empty). Note that this describes the contents of</source>
          <target state="translated">为空)。)请注意,这描述了</target>
        </trans-unit>
        <trans-unit id="c70ff529c1678e6d6f8a86a860dfe6b90b65a6d1" translate="yes" xml:space="preserve">
          <source>is empty, or is exactly one code with at least four hexdigits which can be used as an alternative case folding when the calling program cannot cope with the fold being a sequence of multiple code points. If</source>
          <target state="translated">是空的,或者正好是一个至少有4个十六进制的代码,当调用程序无法应对折叠是一个多代码点的序列时,可以用它作为替代情况下的折叠。如果</target>
        </trans-unit>
        <trans-unit id="b82f1aa4dc1e11bb0291658e76619710db88ea38" translate="yes" xml:space="preserve">
          <source>is empty, the</source>
          <target state="translated">为空,则</target>
        </trans-unit>
        <trans-unit id="0e207ae2f0db5023f32cc9020e3ddf2c71a2b3cc" translate="yes" xml:space="preserve">
          <source>is equal to the C variable &lt;code&gt;name&lt;/code&gt; . If</source>
          <target state="translated">等于C变量 &lt;code&gt;name&lt;/code&gt; 。如果</target>
        </trans-unit>
        <trans-unit id="1ec285792f84b2006557cfe7a76ef03e4dffbd46" translate="yes" xml:space="preserve">
          <source>is equivalent to</source>
          <target state="translated">相当于</target>
        </trans-unit>
        <trans-unit id="bc2b09c98193f0e5662cbf8b53fad07d5e736c01" translate="yes" xml:space="preserve">
          <source>is equivalent to the following Perl-like pseudo code:</source>
          <target state="translated">相当于以下类似Perl的伪代码。</target>
        </trans-unit>
        <trans-unit id="32a86d7541273833cc59233715d55c78fd068962" translate="yes" xml:space="preserve">
          <source>is equivalent to the more verbose</source>
          <target state="translated">相当于比较啰嗦的</target>
        </trans-unit>
        <trans-unit id="058019ba79ba28b16d81510fd9c7be6426e9a31b" translate="yes" xml:space="preserve">
          <source>is equivalent to the original path for all systems but VMS.</source>
          <target state="translated">相当于所有系统的原始路径,但VMS除外。</target>
        </trans-unit>
        <trans-unit id="8a799343991654a6923d4110f493e02c300d895c" translate="yes" xml:space="preserve">
          <source>is equivalent to this Perl code:</source>
          <target state="translated">相当于这段Perl代码。</target>
        </trans-unit>
        <trans-unit id="5cffe5ee80305aeabc52048276f1acf872533639" translate="yes" xml:space="preserve">
          <source>is equivalent to this:</source>
          <target state="translated">与此相当。</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">相当于:</target>
        </trans-unit>
        <trans-unit id="6c01ad008c1dcafb297a57e15952c3a221508e1b" translate="yes" xml:space="preserve">
          <source>is evaluated in &lt;b&gt;list context&lt;/b&gt; and interpolated into the list value.</source>
          <target state="translated">在&lt;b&gt;列表上下文中&lt;/b&gt;求值并插值到列表值中。</target>
        </trans-unit>
        <trans-unit id="304cd7bde8c8a066e9ddc11f5d17d8c69ab28cfc" translate="yes" xml:space="preserve">
          <source>is exactly equivalent to</source>
          <target state="translated">正好等于</target>
        </trans-unit>
        <trans-unit id="5868f5f052497727f3a75d03017159c24abf653a" translate="yes" xml:space="preserve">
          <source>is explicitly used, false if an external</source>
          <target state="translated">显式使用,如果是外部的</target>
        </trans-unit>
        <trans-unit id="9f231ca4498f5e3002502cfac3a6b5698c2f1ac4" translate="yes" xml:space="preserve">
          <source>is extracted and decoded for</source>
          <target state="translated">被提取并解码为</target>
        </trans-unit>
        <trans-unit id="c507073afeb7ab580d7916aa3aef230ed3bfced7" translate="yes" xml:space="preserve">
          <source>is false then &lt;code&gt;decode&lt;/code&gt; should make a &quot;best effort&quot; to convert the string - for example by using Unicode's &quot;\x{FFFD}&quot; as a replacement character.</source>
          <target state="translated">如果为false，则 &lt;code&gt;decode&lt;/code&gt; 应&amp;ldquo;尽最大努力&amp;rdquo;转换字符串-例如，使用Unicode的&amp;ldquo; \ x {FFFD}&amp;rdquo;作为替换字符。</target>
        </trans-unit>
        <trans-unit id="66ef51ab90721c11c96b9fd1112297ae5c3bc612" translate="yes" xml:space="preserve">
          <source>is false then &lt;code&gt;encode&lt;/code&gt; MUST make a &quot;best effort&quot; to convert the string - for example, by using a replacement character.</source>
          <target state="translated">为假，则 &lt;code&gt;encode&lt;/code&gt; 必须&amp;ldquo;尽最大努力&amp;rdquo;来转换字符串-例如，使用替换字符。</target>
        </trans-unit>
        <trans-unit id="85c8ac4c204bffb12a6b2e5264aea8475c7fa00f" translate="yes" xml:space="preserve">
          <source>is false unless the old $x happened to have the value &lt;code&gt;123&lt;/code&gt; .</source>
          <target state="translated">除非旧的$ x的值为 &lt;code&gt;123&lt;/code&gt; ,否则它为false 。</target>
        </trans-unit>
        <trans-unit id="59641b07163bb2532f0e133b6081758f8b622aff" translate="yes" xml:space="preserve">
          <source>is find. The returned object is what does the actual encoding or decoding.</source>
          <target state="translated">是查找。返回的对象是做实际编码或解码的。</target>
        </trans-unit>
        <trans-unit id="19134d8f14cf9efb45a39a603eab01b599496a36" translate="yes" xml:space="preserve">
          <source>is first looked up in the list of standard Unicode character names.</source>
          <target state="translated">首先在标准Unicode字符名列表中查找。</target>
        </trans-unit>
        <trans-unit id="28844e6770c7541b46bf5769a48ab89a32b3a220" translate="yes" xml:space="preserve">
          <source>is formatted as:</source>
          <target state="translated">格式为:</target>
        </trans-unit>
        <trans-unit id="a5bf27e9e737c2b17d8bda56643008ebf40f5d55" translate="yes" xml:space="preserve">
          <source>is found, &lt;code&gt;Z_OK&lt;/code&gt; is returned and &lt;code&gt;$buffer&lt;/code&gt; will be have all data up to the flush point removed. This can then be passed to the &lt;code&gt;deflate&lt;/code&gt; method.</source>
          <target state="translated">找到后，将返回 &lt;code&gt;Z_OK&lt;/code&gt; 并删除 &lt;code&gt;$buffer&lt;/code&gt; 直到刷新点的所有数据。然后可以将其传递给 &lt;code&gt;deflate&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="7b39d821e927a0c9d0363f2727cc57c75893ba1d" translate="yes" xml:space="preserve">
          <source>is found, &lt;code&gt;Z_OK&lt;/code&gt; is returned and &lt;code&gt;$input&lt;/code&gt; will be have all data up to the flush point removed. This data can then be passed to the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method to be uncompressed.</source>
          <target state="translated">找到后，将返回 &lt;code&gt;Z_OK&lt;/code&gt; 并将删除 &lt;code&gt;$input&lt;/code&gt; 直到刷新点的所有数据。然后可以将此数据传递到 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 方法以进行解压缩。</target>
        </trans-unit>
        <trans-unit id="4ad43a18a515527a341bfc4d3a6681a6fd357b43" translate="yes" xml:space="preserve">
          <source>is found, Perl will investigate its first line etc. The only hardwired limit on the recursion depth is implicit: there is a limit 4 on the number of additional arguments inserted before the actual arguments given to system(). In particular, if no additional arguments are specified on the &quot;magic&quot; first lines, then the limit on the depth is 4.</source>
          <target state="translated">被发现,Perl会调查它的第一行等。对递归深度的唯一硬性限制是隐含的:在给system()的实际参数之前插入的附加参数数量有一个限制4。特别是,如果在 &quot;神奇 &quot;的第一行没有指定附加参数,那么深度的限制就是4。</target>
        </trans-unit>
        <trans-unit id="1f1b1a9afa41f162ae23bb3a01d9f047e652e6e1" translate="yes" xml:space="preserve">
          <source>is four characters, the first two are used as the left quote and the second two as the right quote.</source>
          <target state="translated">是四个字符,前两个作为左引号,后两个作为右引号。</target>
        </trans-unit>
        <trans-unit id="6f9a16a4dd16d307d04182c223f1289cfcd07c67" translate="yes" xml:space="preserve">
          <source>is generated automatically from</source>
          <target state="translated">是自动生成的</target>
        </trans-unit>
        <trans-unit id="bd2a87dbabce881cfa0ac191619b95b7f30ff0e2" translate="yes" xml:space="preserve">
          <source>is generated by &lt;code&gt;ExtUtils::Miniperl&lt;/code&gt; from</source>
          <target state="translated">由 &lt;code&gt;ExtUtils::Miniperl&lt;/code&gt; 从</target>
        </trans-unit>
        <trans-unit id="97061dcc49398ed7873f16a75d7351365d5bd949" translate="yes" xml:space="preserve">
          <source>is greater than 10, the digit for 11 will be 'a', and so on. If</source>
          <target state="translated">大于10,那么11的数字就是'a',以此类推。如果</target>
        </trans-unit>
        <trans-unit id="c6cff08bd14f0967385302adf53b41c3a3d439b0" translate="yes" xml:space="preserve">
          <source>is greater than 36, the digit for 37 will be 'A', and so on until 62. Values greater than 62 are not currently supported. The default is 36.</source>
          <target state="translated">大于36,37的数字将是'A',以此类推,直到62。目前不支持大于62的值。默认值是36。</target>
        </trans-unit>
        <trans-unit id="ffe49080789a404d2d720870ea3296af02ff6123" translate="yes" xml:space="preserve">
          <source>is greater than zero then it gives the number of arguments passed to &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, otherwise it will be 1 if for example &lt;code&gt;PerlIO_open&lt;/code&gt; was called. In simple cases SvPV_nolen(*args) is the pathname to open.</source>
          <target state="translated">大于零，则给出传递给 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 的参数数量，否则，例如，如果调用 &lt;code&gt;PerlIO_open&lt;/code&gt; ,则为 1 。在简单情况下，SvPV_nolen（* args）是打开的路径名。</target>
        </trans-unit>
        <trans-unit id="b7ead90991363b6d52dd34fbbeb13fb170062d0a" translate="yes" xml:space="preserve">
          <source>is held as bytes (both these states are 'consistent'). Main reason for this routine is to allow Perl's test suite to check that operations have left strings in a consistent state. You most probably want to use utf8::is_utf8() instead.</source>
          <target state="translated">是以字节的形式保存的(这两种状态都是 &quot;一致的&quot;)。这个例程的主要原因是允许Perl的测试套件检查操作是否使字符串处于一致状态。你很可能想用utf8::is_utf8()来代替。</target>
        </trans-unit>
        <trans-unit id="f6524de4ede507c0f25877cf9853d0bde2075a2e" translate="yes" xml:space="preserve">
          <source>is hex, as in &lt;code&gt;E&amp;lt;0x201E&amp;gt;&lt;/code&gt; . A leading &quot;0&quot; means that</source>
          <target state="translated">是十六进制的，如 &lt;code&gt;E&amp;lt;0x201E&amp;gt;&lt;/code&gt; 。前导&amp;ldquo; 0&amp;rdquo;表示</target>
        </trans-unit>
        <trans-unit id="ee2f8650f57b54260f06fc232faca4874614507a" translate="yes" xml:space="preserve">
          <source>is identical to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ee8461739b14ea02f3b9c0b9c9eb44d2a1409e" translate="yes" xml:space="preserve">
          <source>is implemented as a Perl module. The structure of the module can take one of two broadly similar formats. To distinguish between them, the first will be referred to as</source>
          <target state="translated">是以Perl模块的形式实现的。模块的结构可以采用两种大致相似的格式之一。为了区分它们,第一种形式将被称为</target>
        </trans-unit>
        <trans-unit id="b176c796440a7e55c89af58d299f53bc936cfeff" translate="yes" xml:space="preserve">
          <source>is implemented using the Perl module &lt;a href=&quot;digest/sha&quot;&gt;Digest::SHA&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Digest::SHA::PurePerl&quot;&gt;Digest::SHA::PurePerl&lt;/a&gt;.</source>
          <target state="translated">使用Perl模块&lt;a href=&quot;digest/sha&quot;&gt;Digest :: SHA&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/Digest::SHA::PurePerl&quot;&gt;Digest :: SHA :: PurePerl实现&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1e051efb59784127a6ed01a9c76c742681c671e" translate="yes" xml:space="preserve">
          <source>is implemented, but bugs remain in &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//i&lt;/a&gt;&lt;/code&gt; with them, mostly fixed by 5.14, and essentially entirely by 5.18.</source>
          <target state="translated">已实现，但bug仍保留在 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//i&lt;/a&gt;&lt;/code&gt; ，大部分已由5.14修复，而基本上已由5.18完全修复。</target>
        </trans-unit>
        <trans-unit id="608c8bcda4c8d3f4fd99afdca20fc7d478aadc35" translate="yes" xml:space="preserve">
          <source>is implied if neither a template nor a directory are supplied.</source>
          <target state="translated">如果既没有提供模板,也没有提供目录,则隐含了这个意思。</target>
        </trans-unit>
        <trans-unit id="029ccc41ee21c1341d1578997e21239d4d69dd57" translate="yes" xml:space="preserve">
          <source>is in a consistent state regarding UTF-8. Will return true if it is well-formed UTF-8 and has the UTF-8 flag on &lt;b&gt;or&lt;/b&gt; if</source>
          <target state="translated">关于UTF-8处于一致状态。将返回true，如果它是格式良好的UTF-8和具有UTF-8标志上&lt;b&gt;或&lt;/b&gt;如果</target>
        </trans-unit>
        <trans-unit id="6da1d29c95b983c26f31a22e5a9c05d88563966c" translate="yes" xml:space="preserve">
          <source>is in effect:</source>
          <target state="translated">是有效的。</target>
        </trans-unit>
        <trans-unit id="fca20ec285ed27cbaefdb07ee844b5ac0358c904" translate="yes" xml:space="preserve">
          <source>is in fact</source>
          <target state="translated">其实</target>
        </trans-unit>
        <trans-unit id="e384cbeffbac9cd924ef4dc73d622e1a5322584a" translate="yes" xml:space="preserve">
          <source>is in the customary packed binary format used for Perl strings.</source>
          <target state="translated">是Perl字符串惯用的打包二进制格式。</target>
        </trans-unit>
        <trans-unit id="cac7c1be39dca233019b8ffda50806e1b4a70009" translate="yes" xml:space="preserve">
          <source>is included. Other possible values include</source>
          <target state="translated">包括。其他可能的值包括</target>
        </trans-unit>
        <trans-unit id="5138f4117c88d0c0de8e325485d990c34725fde1" translate="yes" xml:space="preserve">
          <source>is intended to rhyme with</source>
          <target state="translated">韵味</target>
        </trans-unit>
        <trans-unit id="18bc197f96cca45c02a3aaa837ac2696dd0f97ab" translate="yes" xml:space="preserve">
          <source>is interpolated in the usual way. Something like &lt;code&gt;&quot;\Q\\E&quot;&lt;/code&gt; has no &lt;code&gt;\E&lt;/code&gt; inside. Instead, it has &lt;code&gt;\Q&lt;/code&gt; , &lt;code&gt;\\&lt;/code&gt; , and &lt;code&gt;E&lt;/code&gt; , so the result is the same as for &lt;code&gt;&quot;\\\\E&quot;&lt;/code&gt; . As a general rule, backslashes between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; may lead to counterintuitive results. So, &lt;code&gt;&quot;\Q\t\E&quot;&lt;/code&gt; is converted to &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta(&quot;\t&quot;)&lt;/a&gt;&lt;/code&gt;, which is the same as &lt;code&gt;&quot;\\\t&quot;&lt;/code&gt; (since TAB is not alphanumeric). Note also that:</source>
          <target state="translated">以通常的方式插值。像 &lt;code&gt;&quot;\Q\\E&quot;&lt;/code&gt; 类的东西里面没有 &lt;code&gt;\E&lt;/code&gt; 相反，它具有 &lt;code&gt;\Q&lt;/code&gt; ， &lt;code&gt;\\&lt;/code&gt; 和 &lt;code&gt;E&lt;/code&gt; ，因此结果与 &lt;code&gt;&quot;\\\\E&quot;&lt;/code&gt; 。通常， &lt;code&gt;\Q&lt;/code&gt; 和 &lt;code&gt;\E&lt;/code&gt; 之间的反斜杠可能会导致违反直觉的结果。因此， &lt;code&gt;&quot;\Q\t\E&quot;&lt;/code&gt; 被转换为 &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta(&quot;\t&quot;)&lt;/a&gt;&lt;/code&gt; ，它与 &lt;code&gt;&quot;\\\t&quot;&lt;/code&gt; 相同（因为TAB不是字母数字）。另请注意：</target>
        </trans-unit>
        <trans-unit id="77a8d3d60ed8be450c9ffcc1d60689ed94aa9704" translate="yes" xml:space="preserve">
          <source>is interpolated the same way as</source>
          <target state="translated">是插值的方式与</target>
        </trans-unit>
        <trans-unit id="6645e23e420237e998b6d2cedfb1dc6622827f9f" translate="yes" xml:space="preserve">
          <source>is interpreted as being in decimal, as in &lt;code&gt;E&amp;lt;181&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">与 &lt;code&gt;E&amp;lt;181&amp;gt;&lt;/code&gt; 一样，被解释为十进制。</target>
        </trans-unit>
        <trans-unit id="22c75022beb252e282558c71e996793c6d980a55" translate="yes" xml:space="preserve">
          <source>is invalid as</source>
          <target state="translated">无效,因为</target>
        </trans-unit>
        <trans-unit id="e8ffd60ca890c4ec9f93077049a6c161e0914d97" translate="yes" xml:space="preserve">
          <source>is invoked to create right</source>
          <target state="translated">被调用来创建权利</target>
        </trans-unit>
        <trans-unit id="29af8a8fa79689fd5e71210eb1c3ba564cdffa85" translate="yes" xml:space="preserve">
          <source>is invoked, which in turn steps in</source>
          <target state="translated">被调用,而后者又会介入</target>
        </trans-unit>
        <trans-unit id="cfee822da79f87e0f9bf29a70b1f7e186da8af5d" translate="yes" xml:space="preserve">
          <source>is just a funny way to write</source>
          <target state="translated">只是一种有趣的写法</target>
        </trans-unit>
        <trans-unit id="b044360009bd48fa7435baabf472b05cb3e2087e" translate="yes" xml:space="preserve">
          <source>is just an alias for</source>
          <target state="translated">的别称。</target>
        </trans-unit>
        <trans-unit id="a1bbe39e9abe31cecf6dbbe9e345b36bee6a8e2e" translate="yes" xml:space="preserve">
          <source>is just one code point, then</source>
          <target state="translated">只是一个代码点,那么</target>
        </trans-unit>
        <trans-unit id="fb4747d98d1d42af6b094401a12cd8de28b86f5d" translate="yes" xml:space="preserve">
          <source>is kept open without a name while the output is redirected to a new file with the original</source>
          <target state="translated">在没有名字的情况下被打开,而输出则被重定向到一个新的文件,并带有原来的</target>
        </trans-unit>
        <trans-unit id="f2943b59aed5e708de53a3b73d4947169b635ec4" translate="yes" xml:space="preserve">
          <source>is largely like</source>
          <target state="translated">大致如此</target>
        </trans-unit>
        <trans-unit id="9188ab140ad2e7ca45c0eacb2137ae4084f8e251" translate="yes" xml:space="preserve">
          <source>is latitude (northward positive, southward negative) and</source>
          <target state="translated">是纬度(北向正,南向负),而</target>
        </trans-unit>
        <trans-unit id="9f6334181abd08a5e5386bd949a39504d56e205a" translate="yes" xml:space="preserve">
          <source>is like</source>
          <target state="translated">就像</target>
        </trans-unit>
        <trans-unit id="48ed010598288313ecc15c5c568a57c8a8397db8" translate="yes" xml:space="preserve">
          <source>is like &lt;code&gt;&quot;s&quot;&lt;/code&gt; in that all the map array elements are scalars, but here they are restricted to all being integers, and some have to be adjusted (hence the name &lt;code&gt;&quot;a&quot;&lt;/code&gt; ) to get the correct result. For example, in:</source>
          <target state="translated">就像 &lt;code&gt;&quot;s&quot;&lt;/code&gt; 一样，所有的map数组元素都是标量，但是这里它们被限制为全部为整数，并且必须对其进行一些调整（因此命名为 &lt;code&gt;&quot;a&quot;&lt;/code&gt; ）以获得正确的结果。例如，在：</target>
        </trans-unit>
        <trans-unit id="f732dd47aa6f4ff2876b84adc0d6e54cc3222968" translate="yes" xml:space="preserve">
          <source>is like doing this:</source>
          <target state="translated">是这样做的。</target>
        </trans-unit>
        <trans-unit id="59b5273750d4d23e41112610a3e421f40227d715" translate="yes" xml:space="preserve">
          <source>is linked into the pad, and its &lt;code&gt;CvOUTSIDE&lt;/code&gt; link to the outer scope is weakened to avoid a reference loop.</source>
          <target state="translated">连接到焊盘，并且削弱了它到外部示波器的 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 链接以避免参考环路。</target>
        </trans-unit>
        <trans-unit id="f78b503f16d85a9efd1beacafcdfdaf3f270807f" translate="yes" xml:space="preserve">
          <source>is located in</source>
          <target state="translated">位于</target>
        </trans-unit>
        <trans-unit id="fa07b54f5a9fd2750d4f4d0986e9e9fdb812fef7" translate="yes" xml:space="preserve">
          <source>is longitude (eastward positive, westward negative).</source>
          <target state="translated">是经度(东正西负)。</target>
        </trans-unit>
        <trans-unit id="8e42e7821439f1d14a05038b954f5c84e7ed25c3" translate="yes" xml:space="preserve">
          <source>is looked up as a letter in script</source>
          <target state="translated">隶书</target>
        </trans-unit>
        <trans-unit id="cb4ca3c72721f7c4253dd2277262b9ddc4ed46e6" translate="yes" xml:space="preserve">
          <source>is looked up as a letter in the given scripts (in the specified order). Customized aliases can override these, and are explained in &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;CUSTOM ALIASES&lt;/a&gt;.</source>
          <target state="translated">在给定脚本中按字母顺序（按指定顺序）查找。自定义别名可以覆盖这些别名，并将在&amp;ldquo; &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;自&lt;/a&gt;定义别名&amp;rdquo;中进行说明。</target>
        </trans-unit>
        <trans-unit id="65a9de9318bd902cd3babdefa5b0b92ad233e720" translate="yes" xml:space="preserve">
          <source>is made active via fork()/exec(), which may lead to some resources taken from the system (even if we do not count extra work needed for fork()ing).</source>
          <target state="translated">通过fork()/exec()被激活,这可能会导致从系统中占用一些资源(即使我们不计算fork()ing所需的额外工作)。</target>
        </trans-unit>
        <trans-unit id="239548bf60aa08580ca32f625ff4309e8f81b542" translate="yes" xml:space="preserve">
          <source>is made equivalent to</source>
          <target state="translated">变成了等同于</target>
        </trans-unit>
        <trans-unit id="70f7caafd49cafb298f6bed5bd8a09a8a7b6e1f0" translate="yes" xml:space="preserve">
          <source>is marked internally as encoded in UTF-8. Functionally the same as Encode::is_utf8().</source>
          <target state="translated">在内部被标记为UTF-8编码。功能上与Encode::is_utf8()相同。</target>
        </trans-unit>
        <trans-unit id="cafeb6d4161aa2a759fa9cb04517c81a82e79352" translate="yes" xml:space="preserve">
          <source>is merely a shortcut for</source>
          <target state="translated">只是一个捷径</target>
        </trans-unit>
        <trans-unit id="cc1707c0c187b01916ee3df94ec53bf20d5e805b" translate="yes" xml:space="preserve">
          <source>is mirrored in bidirectional text</source>
          <target state="translated">是双向文字的镜像</target>
        </trans-unit>
        <trans-unit id="2ed56127ce2edce69beb7e4554959d32a6773da2" translate="yes" xml:space="preserve">
          <source>is more appropriate. The process of converting the complex number into a string that can be displayed is known as</source>
          <target state="translated">是比较合适的。将复数转换为可显示的字符串的过程称为</target>
        </trans-unit>
        <trans-unit id="df959619050e76c8841c515d15b08c043ee77963" translate="yes" xml:space="preserve">
          <source>is more sophisticated, and uses the &lt;a href=&quot;test/harness&quot;&gt;Test::Harness&lt;/a&gt; module, thus using this test target supposes that perl mostly works. The main advantage for our purposes is that it prints a detailed summary of failed tests at the end. Also, unlike</source>
          <target state="translated">更加复杂，并使用&lt;a href=&quot;test/harness&quot;&gt;Test :: Harness&lt;/a&gt;模块，因此使用此测试目标假定perl大部分有效。对于我们而言，主要优点是它在最后打印了失败测试的详细摘要。另外，不像</target>
        </trans-unit>
        <trans-unit id="0858c3a91f7c4ca07fe54237280827493469443b" translate="yes" xml:space="preserve">
          <source>is more than just a C header. It's also a Perl script that can check your source code. It will suggest hints and portability notes, and can even make suggestions on how to change your code. You can run it like any other Perl program:</source>
          <target state="translated">不仅仅是一个C语言头。它也是一个Perl脚本,可以检查你的源代码。它将建议提示和可移植性说明,甚至可以对如何修改你的代码提出建议。你可以像其他Perl程序一样运行它。</target>
        </trans-unit>
        <trans-unit id="73b99ca814cd9f3692bee8c058c4c6db3425b4f7" translate="yes" xml:space="preserve">
          <source>is much more memory-efficient than either</source>
          <target state="translated">是比任何一个更节省内存的</target>
        </trans-unit>
        <trans-unit id="f364fbd6a7a0be0bd077f092be562b8bbd3797f6" translate="yes" xml:space="preserve">
          <source>is needed to get through the test suite.</source>
          <target state="translated">是需要通过测试套件的。</target>
        </trans-unit>
        <trans-unit id="6a14b970b88d3b4ba0134624be5559b774fcc9e5" translate="yes" xml:space="preserve">
          <source>is needed.</source>
          <target state="translated">是需要的。</target>
        </trans-unit>
        <trans-unit id="9d94e3f31359c70b6973e6ab915dd0761fd3dfe4" translate="yes" xml:space="preserve">
          <source>is never checked (so if it does not exists when its content is needed, the user of %hash may be confused).</source>
          <target state="translated">从不被检查(所以如果在需要它的内容时它不存在,%hash的用户可能会感到困惑)。</target>
        </trans-unit>
        <trans-unit id="d1c931dd86f631640926b9290e424da1679547cd" translate="yes" xml:space="preserve">
          <source>is non-&lt;code&gt;NULL&lt;/code&gt; , it will be set to a pointer to the frame for the sub call itself.</source>
          <target state="translated">为非 &lt;code&gt;NULL&lt;/code&gt; ，它将被设置为指向子调用本身的框架的指针。</target>
        </trans-unit>
        <trans-unit id="5e581b526692a62a2e9311d15e92a68ee14d4cf1" translate="yes" xml:space="preserve">
          <source>is non-null, it supplies the name of a label to attach to the state op; this function takes ownership of the memory pointed at by</source>
          <target state="translated">为非空,它提供了附加到状态操作的标签的名称;这个函数拥有由</target>
        </trans-unit>
        <trans-unit id="10e7f3d3e39943812d42aa325a0624806d73fc1d" translate="yes" xml:space="preserve">
          <source>is non-null, it's a lexical reference to a package variable, and this identifies the package. The following flags can be OR'ed together:</source>
          <target state="translated">是非空的,它是一个包变量的词法引用,这就标识了这个包。以下标志可以一起进行OR'ed。</target>
        </trans-unit>
        <trans-unit id="6de6591eb61d37cb2280e26d54c5fd16117e3fea" translate="yes" xml:space="preserve">
          <source>is non-null, the name is for a typed lexical, and this identifies the type. If</source>
          <target state="translated">为非空,那么这个名字就是一个类型化的词法,这就表明了这个类型。如果</target>
        </trans-unit>
        <trans-unit id="57de99dddfaf807ff4ccc5d2881dd47c080db528" translate="yes" xml:space="preserve">
          <source>is non-zero then</source>
          <target state="translated">为非零,则</target>
        </trans-unit>
        <trans-unit id="e82fdbe87df063bbd6188f48b5ff47c8f53b5e5b" translate="yes" xml:space="preserve">
          <source>is not</source>
          <target state="translated">不是</target>
        </trans-unit>
        <trans-unit id="2442a9efabb42df6d9155ee7e736901c656341f1" translate="yes" xml:space="preserve">
          <source>is not &lt;code&gt;NULL&lt;/code&gt; then this is a &lt;code&gt;PerlIO_reopen&lt;/code&gt; . Perl itself does not use this (yet?) and semantics are a little vague.</source>
          <target state="translated">不为 &lt;code&gt;NULL&lt;/code&gt; 则为 &lt;code&gt;PerlIO_reopen&lt;/code&gt; 。Perl本身不使用它（还可以吗？），并且语义有点模糊。</target>
        </trans-unit>
        <trans-unit id="5dbf0d4a2783568bc0ec6653623e5d748ba64d73" translate="yes" xml:space="preserve">
          <source>is not NULL. Since we don't have to check the NULLness, it's faster and smaller.</source>
          <target state="translated">是不是NULL。因为我们不用检查NULL性,所以速度更快,体积更小。</target>
        </trans-unit>
        <trans-unit id="09afe42e6e5a8f0e386f1909d4abd2a189d4f310" translate="yes" xml:space="preserve">
          <source>is not NULL. The macro doesn't need to return a meaningful value, or check for NULLness, so it's smaller and faster.</source>
          <target state="translated">并非NULL.这个宏不需要返回有意义的值,也不需要检查是否为NULL,所以它更小更快。这个宏不需要返回一个有意义的值,也不需要检查是否为NULL,所以它更小更快。</target>
        </trans-unit>
        <trans-unit id="1ffb843df2c6536477027470d90d6811acce8f6a" translate="yes" xml:space="preserve">
          <source>is not a directory that you can chdir to, possibly because it doesn't exist.</source>
          <target state="translated">并不是一个你可以chdir到的目录,可能是因为它不存在。</target>
        </trans-unit>
        <trans-unit id="cd05864506055467d4c1543f9ab79897eee73f31" translate="yes" xml:space="preserve">
          <source>is not a full pathname found in the values of %INC, it is considered a regex.</source>
          <target state="translated">不是在%INC的值中找到的完整路径名,它被认为是一个regex。</target>
        </trans-unit>
        <trans-unit id="ca37ad081732791ac7c3c488d1b688611146a3d5" translate="yes" xml:space="preserve">
          <source>is not a multiple of 8, use the</source>
          <target state="translated">不是8的倍数,使用</target>
        </trans-unit>
        <trans-unit id="90cfc06661f28638ad5685d595f94c84092a1299" translate="yes" xml:space="preserve">
          <source>is not a reference, it is &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;-ed in order to allow &lt;code&gt;$1&lt;/code&gt; etc. to be substituted. The example is one way to alias names as used in X11 fonts to the MIME names for the iso-8859-* family. Note the double quotes inside the single quotes.</source>
          <target state="translated">不是参考，它被 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 以允许 &lt;code&gt;$1&lt;/code&gt; 等被替换。该示例是将X11字体中使用的名称别名化为iso-8859- *系列的MIME名称的一种方法。请注意单引号内的双引号。</target>
        </trans-unit>
        <trans-unit id="cc27d44385271fc935f660f9829b5e1b57bf2fba" translate="yes" xml:space="preserve">
          <source>is not a string.</source>
          <target state="translated">不是一个字符串。</target>
        </trans-unit>
        <trans-unit id="fe97c6a25e6e10b05fea34af623f7790fa5fba36" translate="yes" xml:space="preserve">
          <source>is not a string. Do not treat the return value as indicative of success or failure, because that isn't what it means: it is only the previous setting.</source>
          <target state="translated">不是一个字符串。不要把返回值当作成功或失败的指示,因为那不是它的意思:它只是之前的设置。</target>
        </trans-unit>
        <trans-unit id="da2c1159c594f4eb414e53a0a7777f80e553cdef" translate="yes" xml:space="preserve">
          <source>is not allowed, but</source>
          <target state="translated">不允许,但</target>
        </trans-unit>
        <trans-unit id="606701e8f5f91b1f859064528c6c90e0850405fe" translate="yes" xml:space="preserve">
          <source>is not already a list of the right type, it will be upgraded into one. If either</source>
          <target state="translated">不是正确类型的列表,它将被升级为一个列表。如果其中一个</target>
        </trans-unit>
        <trans-unit id="8d605d2cddd686b63627dcedefd81881d4aede9c" translate="yes" xml:space="preserve">
          <source>is not available.</source>
          <target state="translated">是没有的。</target>
        </trans-unit>
        <trans-unit id="0e07acfe6e445415bc80f4539e83f2e5479627c6" translate="yes" xml:space="preserve">
          <source>is not defined, then Perl defaults to consulting first the logical name tables specified by</source>
          <target state="translated">未定义,那么Perl默认先查询由</target>
        </trans-unit>
        <trans-unit id="3b35dc3fb767643d25e161d97495375b6c8925d3" translate="yes" xml:space="preserve">
          <source>is not empty, and it is the same as</source>
          <target state="translated">是不空的,它与。</target>
        </trans-unit>
        <trans-unit id="133cd8c37eb7f1bc84f3898facc206421e336545" translate="yes" xml:space="preserve">
          <source>is not found in any of $lh's %Lexicon hashes. What happens if a key is not found, is discussed in a later section, &quot;Controlling Lookup Failure&quot;.</source>
          <target state="translated">在$lh的%Lexicon哈希中没有找到。如果一个键没有找到会发生什么,在后面的 &quot;控制查找失败 &quot;一节中讨论。</target>
        </trans-unit>
        <trans-unit id="20608bdf427071b3f2b3bc63e3ca5ad5dba32b48" translate="yes" xml:space="preserve">
          <source>is not found, then Perl looks for an executable</source>
          <target state="translated">没有找到,那么Perl就会寻找一个可执行的</target>
        </trans-unit>
        <trans-unit id="33010be083ed65d0281dbcb74bf9325a0f99e09d" translate="yes" xml:space="preserve">
          <source>is not given, skip all constants that are defined in a C enumeration. Otherwise skip only those constants that are defined in an enum whose name matches</source>
          <target state="translated">不给定,跳过所有定义在 C 枚举中的常量。否则,只跳过那些定义在名称与</target>
        </trans-unit>
        <trans-unit id="3339d9443dad98ccb99bf9de00b6ef263750537d" translate="yes" xml:space="preserve">
          <source>is not in PERL5LIB.</source>
          <target state="translated">在PERL5LIB中没有。</target>
        </trans-unit>
        <trans-unit id="9ee2f3e24f21d916d1b9f7d8d204a62832704191" translate="yes" xml:space="preserve">
          <source>is not necessary,</source>
          <target state="translated">没有必要。</target>
        </trans-unit>
        <trans-unit id="3f84e0c82fe1616e060e2332dff93b4abd3bb7e3" translate="yes" xml:space="preserve">
          <source>is not ok, as the regex engine will end up trying to compile the pattern &lt;code&gt;\&lt;/code&gt; , which it will consider a syntax error.</source>
          <target state="translated">这不是很好，因为正则表达式引擎最终将尝试编译模式 &lt;code&gt;\&lt;/code&gt; ，它将考虑语法错误。</target>
        </trans-unit>
        <trans-unit id="1de141eaa0f30aab49d63c7c0d6cb5d7b40c44a8" translate="yes" xml:space="preserve">
          <source>is not passed if the layer is at the bottom of the stack, for this reason and to maintain some level of &quot;compatibility&quot; with TIEHANDLE classes it is passed last.</source>
          <target state="translated">如果该层在堆栈的最底层,则不会被传递,出于这个原因,并且为了与TIEHANDLE类保持一定程度的 &quot;兼容性&quot;,它被最后传递。</target>
        </trans-unit>
        <trans-unit id="14ca5e3fc9da5c9523747e734197510c25796d8c" translate="yes" xml:space="preserve">
          <source>is not portable. Leave out the last comma.</source>
          <target state="translated">是不便携的。省去最后一个逗号。</target>
        </trans-unit>
        <trans-unit id="f5ac0afcf1f3987905381d9349d990f0a6872ecc" translate="yes" xml:space="preserve">
          <source>is not required and not implemented.</source>
          <target state="translated">不需要,也不执行。</target>
        </trans-unit>
        <trans-unit id="a5cf5f3c675f9c2d68cf66e1262d7c525fab832d" translate="yes" xml:space="preserve">
          <source>is not returned explicitly from &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">没有从 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 中显式返回。</target>
        </trans-unit>
        <trans-unit id="461edf58bab13d0e289e3fd343d9a0a8b3513001" translate="yes" xml:space="preserve">
          <source>is not returned explicitly from &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">没有从 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 中显式返回。</target>
        </trans-unit>
        <trans-unit id="0d97eb902a0ef031b420e6b9b05fccbf862f0b26" translate="yes" xml:space="preserve">
          <source>is not specified: &lt;b&gt;xsubpp&lt;/b&gt; can see that it needs to generate a function call section, and will autogenerate the OUTPUT section too. Thus one can shortcut the XSUB to become:</source>
          <target state="translated">未指定：&lt;b&gt;xsubpp&lt;/b&gt;可以看到它需要生成一个函数调用部分，并且也会自动生成OUTPUT部分。因此，可以将XSUB快捷方式变为：</target>
        </trans-unit>
        <trans-unit id="46d1ac57316dccf7b303f8434af4c18ee03b0a0b" translate="yes" xml:space="preserve">
          <source>is not supported).</source>
          <target state="translated">不支持)。)</target>
        </trans-unit>
        <trans-unit id="660e55295ec134f5c48bc724bc723675d1a1b8fd" translate="yes" xml:space="preserve">
          <source>is not the same as</source>
          <target state="translated">不等于</target>
        </trans-unit>
        <trans-unit id="c20017ff75bdfb50ee3a50480bd863b1895d08c4" translate="yes" xml:space="preserve">
          <source>is not transparent. The</source>
          <target state="translated">是不透明的。该</target>
        </trans-unit>
        <trans-unit id="a2f7dc60b1a7a427469f140199570b1bd8f899c4" translate="yes" xml:space="preserve">
          <source>is not yet implemented (dummy function). (Perl has a workaround.)</source>
          <target state="translated">还没有实现 (虚函数)。(Perl有一个变通方法。)</target>
        </trans-unit>
        <trans-unit id="8e0d75ab66ac6c358071d7ce5aa3ae1d338105d6" translate="yes" xml:space="preserve">
          <source>is nothing to worry about at all.</source>
          <target state="translated">是完全不用担心的。</target>
        </trans-unit>
        <trans-unit id="7206590a99801f0070757ea643074d99c5330488" translate="yes" xml:space="preserve">
          <source>is now different from</source>
          <target state="translated">现在已经不同于</target>
        </trans-unit>
        <trans-unit id="296c2ce8ed25f67f0112e54c6f7348b8ee269520" translate="yes" xml:space="preserve">
          <source>is now misinterpreted as</source>
          <target state="translated">现在被误解为</target>
        </trans-unit>
        <trans-unit id="784e257d270f346aebf3530a8118df2e3e970f3c" translate="yes" xml:space="preserve">
          <source>is null, the other is returned unchanged.</source>
          <target state="translated">是空的,另一个返回不变。</target>
        </trans-unit>
        <trans-unit id="1cd25b0094b3720a6cc3ba23740121d376548889" translate="yes" xml:space="preserve">
          <source>is null, the state op is returned. Otherwise the state op is combined with</source>
          <target state="translated">为空,则返回状态运算。否则,状态运算将与</target>
        </trans-unit>
        <trans-unit id="bfd34bbffb3bec2ae854bed4fe93b5b4df09d7c5" translate="yes" xml:space="preserve">
          <source>is octal, as in &lt;code&gt;E&amp;lt;075&amp;gt;&lt;/code&gt; . Otherwise</source>
          <target state="translated">是八进制的，如 &lt;code&gt;E&amp;lt;075&amp;gt;&lt;/code&gt; 。除此以外</target>
        </trans-unit>
        <trans-unit id="e59f8572639c6d7abe84f59ed23f115265c34830" translate="yes" xml:space="preserve">
          <source>is officially available in gcc 3.0 and later. You can build a profiled version of</source>
          <target state="translated">在gcc 3.0及以后的版本中正式可用。你可以在gcc 3.0及以后的版本中构建一个</target>
        </trans-unit>
        <trans-unit id="bb3335ba98001fe8c8858bb517435edad14df2ff" translate="yes" xml:space="preserve">
          <source>is often the quickest way to compute SHA message digests. The user simply feeds data to the script through files or standard input, and then collects the results from standard output.</source>
          <target state="translated">通常是计算SHA消息摘要的最快方法。用户只需通过文件或标准输入向脚本提供数据,然后从标准输出中收集结果。</target>
        </trans-unit>
        <trans-unit id="7c869452ca51dc4f4b90e7e682e32efa15fa5d08" translate="yes" xml:space="preserve">
          <source>is often used interchangeably with it.</source>
          <target state="translated">常与之互换使用。</target>
        </trans-unit>
        <trans-unit id="5031d72b525717047dc6fd15f90430cc40172acd" translate="yes" xml:space="preserve">
          <source>is omitted,</source>
          <target state="translated">被省略了。</target>
        </trans-unit>
        <trans-unit id="59383e02842c6ecb450610847b00c5496ed1ae05" translate="yes" xml:space="preserve">
          <source>is omitted, list them all.</source>
          <target state="translated">是省略的,全部列出。</target>
        </trans-unit>
        <trans-unit id="bed8ec63611bd49c0e67878865bfd9f59745945e" translate="yes" xml:space="preserve">
          <source>is omitted, set an action on the line about to be executed. The sequence of steps taken by the debugger is</source>
          <target state="translated">被省略,在即将执行的行上设置一个动作。调试器采取的步骤顺序为</target>
        </trans-unit>
        <trans-unit id="1454936324f5b838ad8702f3a4e912fdb73181b3" translate="yes" xml:space="preserve">
          <source>is omitted, sets &lt;code&gt;$\&lt;/code&gt; to the current value of &lt;code&gt;$/&lt;/code&gt; . For instance, to trim lines to 80 columns:</source>
          <target state="translated">省略，将 &lt;code&gt;$\&lt;/code&gt; 设置为 &lt;code&gt;$/&lt;/code&gt; 的当前值。例如，将行修剪为80列：</target>
        </trans-unit>
        <trans-unit id="4bb3e6d01d8abb5873707a404b01ed088d627c52" translate="yes" xml:space="preserve">
          <source>is omitted. If that viewer is &lt;b&gt;man&lt;/b&gt;, the current &lt;code&gt;Config&lt;/code&gt; information is used to invoke &lt;b&gt;man&lt;/b&gt; using the proper MANPATH or &lt;b&gt;-M&lt;/b&gt;</source>
          <target state="translated">被省略。如果该查看者是&lt;b&gt;man&lt;/b&gt;，则使用正确的MANPATH或&lt;b&gt;-M&lt;/b&gt;使用当前的 &lt;code&gt;Config&lt;/code&gt; 信息来调用&lt;b&gt;man&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="808a9a0b7d1e742f272682180efba6d96e49b61e" translate="yes" xml:space="preserve">
          <source>is one of &lt;code&gt;S_IRUSR&lt;/code&gt; , &lt;code&gt;S_IWUSR&lt;/code&gt; or &lt;code&gt;S_IXUSR&lt;/code&gt; from the &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; module, and</source>
          <target state="translated">是以下之一 &lt;code&gt;S_IRUSR&lt;/code&gt; ， &lt;code&gt;S_IWUSR&lt;/code&gt; 或 &lt;code&gt;S_IXUSR&lt;/code&gt; 从&lt;a href=&quot;../fcntl&quot;&gt;FCNTL&lt;/a&gt;模块，和</target>
        </trans-unit>
        <trans-unit id="774717fd7c9c7ce3270b72d058c209e6053fc8a0" translate="yes" xml:space="preserve">
          <source>is one of the 10 exceptional cases (or things like them) listed below, it is used directly as a boolean.</source>
          <target state="translated">是下面列出的10种特殊情况(或类似的事情)之一,它直接作为布尔值使用。</target>
        </trans-unit>
        <trans-unit id="c53bf86436bbbd29af464847d3f11c3b0b08cbf8" translate="yes" xml:space="preserve">
          <source>is one of those defined in the Unicode standard. For Unicode 5.1, they are defined in Section 3.13 &lt;code&gt;Default Case Operations&lt;/code&gt; available at &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.1.0/&quot;&gt;http://www.unicode.org/versions/Unicode5.1.0/&lt;/a&gt;. These are for context-sensitive casing.</source>
          <target state="translated">是Unicode标准中定义的标准之一。对于Unicode 5.1，它们在&lt;a href=&quot;http://www.unicode.org/versions/Unicode5.1.0/&quot;&gt;http://www.unicode.org/versions/Unicode5.1.0/上的&lt;/a&gt;第3.13节&amp;ldquo; &lt;code&gt;Default Case Operations&lt;/code&gt; 中定义。这些用于上下文敏感的大小写。</target>
        </trans-unit>
        <trans-unit id="840b280f15a6b38ff8c9a2baa67e8c9188a87b38" translate="yes" xml:space="preserve">
          <source>is open, or use &quot;r+&quot; to indicate a read/write stream.</source>
          <target state="translated">是打开的,或者用 &quot;r+&quot;表示一个读/写流。</target>
        </trans-unit>
        <trans-unit id="c683506eb9e31819d71640bdc2f2478d3f6ce65d" translate="yes" xml:space="preserve">
          <source>is opened for writing.</source>
          <target state="translated">是开写的。</target>
        </trans-unit>
        <trans-unit id="79749dba2b390bb7475fce2507f0f4eb5987e332" translate="yes" xml:space="preserve">
          <source>is optional and defaults to rest of the array.</source>
          <target state="translated">是可选的,默认为数组的其余部分。</target>
        </trans-unit>
        <trans-unit id="915a141436744a90f3e02d0dd1d609a72b2c593a" translate="yes" xml:space="preserve">
          <source>is optional and defaults to zero, negative values count back from the end of the array.</source>
          <target state="translated">是可选的,默认值为0,负值从数组末尾开始倒数。</target>
        </trans-unit>
        <trans-unit id="df5063ae13199d816cf6966e77f57c23f1e15e7b" translate="yes" xml:space="preserve">
          <source>is optional, make sure that this switch is followed by at least one other switch if you omit</source>
          <target state="translated">是可选的,如果你省略了</target>
        </trans-unit>
        <trans-unit id="6dd01b70fcde3901a9b8cd6f99e52b559931ae66" translate="yes" xml:space="preserve">
          <source>is optional.</source>
          <target state="translated">是可选的。</target>
        </trans-unit>
        <trans-unit id="d3403c1182056f32036e1b0b051b43fe6e7e8805" translate="yes" xml:space="preserve">
          <source>is optional. If omitted, the encoding specified in the environment variable &lt;a href=&quot;perlrun#PERL_ENCODING&quot;&gt;PERL_ENCODING &lt;/a&gt; is used. If this isn't set, or the resolved-to encoding is not known to &lt;code&gt;&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;&lt;/code&gt;, the error &lt;code&gt;Unknown encoding '&lt;i&gt;ENCNAME&lt;/i&gt;'&lt;/code&gt; will be thrown.</source>
          <target state="translated">是可选的。如果省略，则使用在环境变量&lt;a href=&quot;perlrun#PERL_ENCODING&quot;&gt;PERL_ENCODING中&lt;/a&gt;指定的编码。如果没有设置，或解析到的编码是不知道 &lt;code&gt;&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;&lt;/code&gt; ，误差 &lt;code&gt;Unknown encoding '&lt;i&gt;ENCNAME&lt;/i&gt;'&lt;/code&gt; 将被抛出。</target>
        </trans-unit>
        <trans-unit id="460daaa5dcc2cb35dc81c46bff6ccd69c45e1b70" translate="yes" xml:space="preserve">
          <source>is passed to &lt;code&gt;SvPV_flags&lt;/code&gt; , and usually should be &lt;code&gt;SV_GMAGIC|SV_CONST_RETURN&lt;/code&gt; to handle magic.</source>
          <target state="translated">传递给 &lt;code&gt;SvPV_flags&lt;/code&gt; ，通常应为 &lt;code&gt;SV_GMAGIC|SV_CONST_RETURN&lt;/code&gt; 以处理魔术。</target>
        </trans-unit>
        <trans-unit id="dd20141170d229f9cc0136383909cd4f633a749b" translate="yes" xml:space="preserve">
          <source>is passed to the RE engine for compilation.</source>
          <target state="translated">被传递给RE引擎进行编译。</target>
        </trans-unit>
        <trans-unit id="a9eb96dfee227401a57fda9e8cbf3aa10f225974" translate="yes" xml:space="preserve">
          <source>is platform specific and may not be available for a specific port of Perl.</source>
          <target state="translated">是特定的平台,可能无法用于特定的 Perl port。</target>
        </trans-unit>
        <trans-unit id="25efb0ba5cb2478bde4a9a44864c9da4f454d8ed" translate="yes" xml:space="preserve">
          <source>is possible</source>
          <target state="translated">有可能</target>
        </trans-unit>
        <trans-unit id="523f09771ac3cf4731742b1c80be3d254a1ba53f" translate="yes" xml:space="preserve">
          <source>is preceded by a plus or minus sign then it is assumed to be relative, with negative numbers indicating preceding capture groups and positive ones following. Thus &lt;code&gt;(?-1)&lt;/code&gt; refers to the most recently declared group, and &lt;code&gt;(?+1)&lt;/code&gt; indicates the next group to be declared. Note that the counting for relative recursion differs from that of relative backreferences, in that with recursion unclosed groups &lt;b&gt;are&lt;/b&gt; included.</source>
          <target state="translated">如果前面有一个加号或减号，则假定它是相对的，负数表示前面的捕获组，正数后面的捕获组。因此 &lt;code&gt;(?-1)&lt;/code&gt; 指的是最近声明的组， &lt;code&gt;(?+1)&lt;/code&gt; 表示要声明的下一个组。注意，对于相对递归不同于相对反向引用的，在与递归未封闭基团的计数&lt;b&gt;被&lt;/b&gt;包括在内。</target>
        </trans-unit>
        <trans-unit id="e7ca6ab06ff93674a9f398734b75e0712f956c08" translate="yes" xml:space="preserve">
          <source>is preferred over the system malloc. Otherwise the value is null. This variable is intended for generating Makefiles.</source>
          <target state="translated">是首选,而不是系统的malloc。否则该值为空。这个变量是用来生成Makefile的。</target>
        </trans-unit>
        <trans-unit id="bd9425232ec1477789dd62e49cd5398771156271" translate="yes" xml:space="preserve">
          <source>is preferred over the system malloc. Otherwise the value is null. This variable is intended for generating Makefiles. See mallocsrc.</source>
          <target state="translated">是首选,而不是系统的malloc。否则该值为空。这个变量是用来生成Makefile的。参见 mallocsrc。</target>
        </trans-unit>
        <trans-unit id="f67f67cd9d10cfa55835748252e70c39d94e9642" translate="yes" xml:space="preserve">
          <source>is present but is not a positive number matching &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A(\d*\.)?\d+\z/&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">存在但不是与 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A(\d*\.)?\d+\z/&lt;/a&gt;&lt;/code&gt; 匹配的正数？\ d + \ z /。</target>
        </trans-unit>
        <trans-unit id="cd6cfac1ce57b9138644859e222534e07b64b3f7" translate="yes" xml:space="preserve">
          <source>is present in EMX, but is not functional, it is emulated by perl. To disable the emulations, set environment variable &lt;code&gt;USE_PERL_FLOCK=0&lt;/code&gt; .</source>
          <target state="translated">在EMX中存在，但不起作用，它由perl仿真。要禁用仿真，请设置环境变量 &lt;code&gt;USE_PERL_FLOCK=0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0eb8a82dec3aea4891c7d0fdc7c4040cbf80deac" translate="yes" xml:space="preserve">
          <source>is present. On Unix, this means that &lt;code&gt;$no_file&lt;/code&gt; true makes this return ( '', $path, '' ).</source>
          <target state="translated">存在。在Unix上，这意味着 &lt;code&gt;$no_file&lt;/code&gt; true使此返回（''，$ path，''）。</target>
        </trans-unit>
        <trans-unit id="fae39eb0e249041dca8ecd4c4e5c73741b3158c8" translate="yes" xml:space="preserve">
          <source>is printed with proper indentation.</source>
          <target state="translated">是以适当的缩进方式打印的。</target>
        </trans-unit>
        <trans-unit id="f9b801d1d0e729e303069ae25d8e485d81ece8ba" translate="yes" xml:space="preserve">
          <source>is probably overkill for this. Something as simple as a &lt;code&gt;#define&lt;/code&gt; will do too:</source>
          <target state="translated">为此可能是过大了。像 &lt;code&gt;#define&lt;/code&gt; 这样简单的事情也可以做到：</target>
        </trans-unit>
        <trans-unit id="c75e0ceb23f1e1bd5d1ae898ae5b3a046e750c35" translate="yes" xml:space="preserve">
          <source>is processed before processing &lt;code&gt;PERLDB_OPTS&lt;/code&gt; . If</source>
          <target state="translated">在处理 &lt;code&gt;PERLDB_OPTS&lt;/code&gt; 之前先进行处理。如果</target>
        </trans-unit>
        <trans-unit id="dd2e5ec393361241bdf00bf003cfd5d912213a01" translate="yes" xml:space="preserve">
          <source>is replicated. This latter is useful for counting characters in a class or for squashing character sequences in a class.</source>
          <target state="translated">是复制的。后者对于计算类中的字符或压制类中的字符序列很有用。</target>
        </trans-unit>
        <trans-unit id="5127b5091f9438f482f3b3e9a135487ed542c34c" translate="yes" xml:space="preserve">
          <source>is reported by mkmanifest() if $Verbose is set and a file is added to MANIFEST. $Verbose is set to 1 by default.</source>
          <target state="translated">如果$Verbose被设置并且文件被添加到MANIFEST中,则由mkmanifest()报告,默认情况下$Verbose被设置为1。</target>
        </trans-unit>
        <trans-unit id="bb20d2b460123fa620831fa74f056496b2769aa8" translate="yes" xml:space="preserve">
          <source>is reported if &lt;code&gt;MANIFEST&lt;/code&gt; could not be opened.</source>
          <target state="translated">如果无法打开 &lt;code&gt;MANIFEST&lt;/code&gt; 则报告。</target>
        </trans-unit>
        <trans-unit id="328906540cfc4914dc5ef9e9058dee50029d2b82" translate="yes" xml:space="preserve">
          <source>is reported if a file is found which is not in &lt;code&gt;MANIFEST&lt;/code&gt; .</source>
          <target state="translated">如果找到的文件不在 &lt;code&gt;MANIFEST&lt;/code&gt; 中,则报告。</target>
        </trans-unit>
        <trans-unit id="552d792cd22a56b9bb40ff5d893f66da4e73233e" translate="yes" xml:space="preserve">
          <source>is reported if a file is skipped due to an entry in &lt;code&gt;MANIFEST.SKIP&lt;/code&gt; .</source>
          <target state="translated">如果由于 &lt;code&gt;MANIFEST.SKIP&lt;/code&gt; 中的条目而跳过了文件，则报告。</target>
        </trans-unit>
        <trans-unit id="aeed03f4804268d15748142d4e8831e16972eca4" translate="yes" xml:space="preserve">
          <source>is reported if a file mentioned in a &lt;code&gt;MANIFEST&lt;/code&gt; file does not exist.</source>
          <target state="translated">如果 &lt;code&gt;MANIFEST&lt;/code&gt; 文件中提到的文件不存在，则会报告此错误。</target>
        </trans-unit>
        <trans-unit id="62f90f7410ef6025437546070986df3097b81356" translate="yes" xml:space="preserve">
          <source>is requested, Perl will not look for</source>
          <target state="translated">的请求,Perl将不会查找</target>
        </trans-unit>
        <trans-unit id="732d7871b8b24cfa3bee53313dd1156e83c03669" translate="yes" xml:space="preserve">
          <source>is required if you want to start your program without a VIO window present, but not &lt;code&gt;detach&lt;/code&gt; ed (run &lt;code&gt;help detach&lt;/code&gt; for more info). Very useful for extensions which use PM, like &lt;code&gt;Perl/Tk&lt;/code&gt; or &lt;code&gt;OpenGL&lt;/code&gt; .</source>
          <target state="translated">如果要在不存在VIO窗口但不 &lt;code&gt;detach&lt;/code&gt; 情况下启动程序，则是必需的（运行 &lt;code&gt;help detach&lt;/code&gt; 以获取更多信息）。对于使用PM的扩展（例如 &lt;code&gt;Perl/Tk&lt;/code&gt; 或 &lt;code&gt;OpenGL&lt;/code&gt; )非常有用。</target>
        </trans-unit>
        <trans-unit id="8e6d5c50073dedc878c0bb174986728a65c26611" translate="yes" xml:space="preserve">
          <source>is reserved and must be zero. If it is not in the current pad but appears in the pad of any lexically enclosing scope, then a pseudo-entry for it is added in the current pad. Returns the offset in the current pad, or &lt;code&gt;NOT_IN_PAD&lt;/code&gt; if no such lexical is in scope.</source>
          <target state="translated">保留，并且必须为零。如果它不在当前填充板中，但出现在任何词法包围范围的填充板中，则将其伪条目添加到当前填充板中。返回当前填充中的偏移量；如果没有此类词汇，则返回 &lt;code&gt;NOT_IN_PAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dab1f8b59686974bbcd2707bc651d6707dac406f" translate="yes" xml:space="preserve">
          <source>is returned.</source>
          <target state="translated">是返回。</target>
        </trans-unit>
        <trans-unit id="3b418f45ad77bc3826b32d08799dfded45d89432" translate="yes" xml:space="preserve">
          <source>is roughly equivalent to:</source>
          <target state="translated">大致相当于:</target>
        </trans-unit>
        <trans-unit id="b84a5263098f0e0c514dc8fe7d67295e56c987dc" translate="yes" xml:space="preserve">
          <source>is run on source code files, like this</source>
          <target state="translated">是在源代码文件上运行的,像这样</target>
        </trans-unit>
        <trans-unit id="505ded7fa9f0c714268c66ac7bb3b81302192c94" translate="yes" xml:space="preserve">
          <source>is semantically ambiguous, in a way that makes formatting decisions a bit difficult. On the one hand, it could be mention of an item &quot;Neque&quot;, mention of another item &quot;Porro&quot;, and mention of another item &quot;Quisquam Est&quot;, with just the last one requiring the explanatory paragraph &quot;Qui dolorem ipsum quia dolor...&quot;; and then an item &quot;Ut Enim&quot;. In that case, you'd want to format it like so:</source>
          <target state="translated">在语义上是含糊的,这使得格式决定有点困难。一方面,可以是提到一个项目 &quot;Neque&quot;,提到另一个项目 &quot;Porro&quot;,再提到另一个项目 &quot;Quisquam Est&quot;,只是最后一个项目需要解释段 &quot;Qui dolorem ipsum quia dolor...&quot;;然后是一个项目 &quot;Ut Enim&quot;。在这种情况下,你会希望这样格式化。</target>
        </trans-unit>
        <trans-unit id="7722d64cd0eafe5303c971058e1fcb33e1d6e14c" translate="yes" xml:space="preserve">
          <source>is semantically equivalent to the list:</source>
          <target state="translated">在语义上等同于列表。</target>
        </trans-unit>
        <trans-unit id="2126556a279c8048a27fc92ce2d017bedadfc33a" translate="yes" xml:space="preserve">
          <source>is set accordingly.</source>
          <target state="translated">相应设置。</target>
        </trans-unit>
        <trans-unit id="9fa2db030f6de6d0d8d463059f009a0bd838f324" translate="yes" xml:space="preserve">
          <source>is set explicitly. Additionally, C</source>
          <target state="translated">是明确设置的。此外,C</target>
        </trans-unit>
        <trans-unit id="f33cd6497df379b7aa55e16988255762f6cc5079" translate="yes" xml:space="preserve">
          <source>is set to 2 if it isn't set already (see &lt;a href=&quot;perlhacktips#PERL_DESTRUCT_LEVEL&quot;&gt;PERL_DESTRUCT_LEVEL in perlhacktips&lt;/a&gt;).</source>
          <target state="translated">如果尚未设置，则设置为2（请参阅&lt;a href=&quot;perlhacktips#PERL_DESTRUCT_LEVEL&quot;&gt;perlhacktips中的PERL_DESTRUCT_LEVEL&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2b4d53f643e8f5289626164f0873fffe60309f8d" translate="yes" xml:space="preserve">
          <source>is set to &lt;code&gt;Encode::FB_QUIET&lt;/code&gt; , encoding and decoding immediately return the portion of the data that has been processed so far when an error occurs. The data argument is overwritten with everything after that point; that is, the unprocessed portion of the data. This is handy when you have to call &lt;code&gt;decode&lt;/code&gt; repeatedly in the case where your source data may contain partial multi-byte character sequences, (that is, you are reading with a fixed-width buffer). Here's some sample code to do exactly that:</source>
          <target state="translated">设置为 &lt;code&gt;Encode::FB_QUIET&lt;/code&gt; ，当发生错误时，编码和解码会立即返回到目前为止已处理的数据部分。此后，data参数将被所有内容覆盖；也就是说，数据的未处理部分。如果您的源数据可能包含部分多字节字符序列（也就是说，您正在使用固定宽度的缓冲区读取），则必须反复调用 &lt;code&gt;decode&lt;/code&gt; 时，这非常方便。下面是一些示例代码，正是这样做的：</target>
        </trans-unit>
        <trans-unit id="fbfb9653688f76b59517a59a6f2dc20d0b7fcf79" translate="yes" xml:space="preserve">
          <source>is set to MEDIUM or higher.</source>
          <target state="translated">设置为MEDIUM或更高。</target>
        </trans-unit>
        <trans-unit id="c2ad4f726f3cb1586df04ee0538b5e72441b3f80" translate="yes" xml:space="preserve">
          <source>is set to the length of the scanned string, and</source>
          <target state="translated">被设置为扫描字符串的长度,而</target>
        </trans-unit>
        <trans-unit id="1cee3f4a0dcf9c9aac5c7b81e0001cba5602885c" translate="yes" xml:space="preserve">
          <source>is set up so that the logical name &lt;code&gt;story&lt;/code&gt; is found, rather than a CLI symbol or CRTL &lt;code&gt;environ&lt;/code&gt; element with the same name.</source>
          <target state="translated">进行设置，以便找到逻辑名称 &lt;code&gt;story&lt;/code&gt; ，而不是具有相同名称的CLI符号或CRTL &lt;code&gt;environ&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="ca6947993695dc137eeb97b7855ecc954a5db745" translate="yes" xml:space="preserve">
          <source>is set, then the source string to encode() or decode() will be overwritten in place. If you're not interested in this, then bitwise-OR it with the bitmask.</source>
          <target state="translated">设置,那么要编码()或解码()的源字符串将被覆盖。如果你对这个不感兴趣,那就用位掩码来进行位掩码。</target>
        </trans-unit>
        <trans-unit id="bbdac3cf799e738c5a8da93062efb7bc674a7966" translate="yes" xml:space="preserve">
          <source>is shorter than the</source>
          <target state="translated">短于</target>
        </trans-unit>
        <trans-unit id="09e367c3fc5cc8d794bb19d7c88ac5b3dbdeee84" translate="yes" xml:space="preserve">
          <source>is similar to:</source>
          <target state="translated">是类似于:</target>
        </trans-unit>
        <trans-unit id="252ba6878cfe0ead48b091a1c7b126be1c7dff77" translate="yes" xml:space="preserve">
          <source>is simply a named option of &lt;b&gt;Pod::Parser&lt;/b&gt; with a value that corresponds to a certain specified behavior. These various behaviors of &lt;b&gt;Pod::Parser&lt;/b&gt; may be enabled/disabled by setting or unsetting one or more</source>
          <target state="translated">只是&lt;b&gt;Pod :: Parser&lt;/b&gt;的命名选项，其值对应于特定的指定行为。可以通过设置或取消设置一个或多个来启用/禁用&lt;b&gt;Pod :: Parser的&lt;/b&gt;这些各种行为</target>
        </trans-unit>
        <trans-unit id="a84848b3c3eaf21ad8fc8af050d6c81e580ed346" translate="yes" xml:space="preserve">
          <source>is simply opened and read; no special modes or I/O disciplines are used. To change this, set the optional</source>
          <target state="translated">只是简单地打开和读取;没有使用特殊模式或I/O纪律。要改变这一点,请将可选的</target>
        </trans-unit>
        <trans-unit id="fbcaf1a2e7b687efcdea29a64a0429d2d73c416e" translate="yes" xml:space="preserve">
          <source>is skipped, including all its sub-directories. The default is to 'die' in such a case.</source>
          <target state="translated">被跳过,包括其所有子目录。在这种情况下,默认为 &quot;死&quot;。</target>
        </trans-unit>
        <trans-unit id="57e430e116971e873eefc3dde4fa051e8cf43562" translate="yes" xml:space="preserve">
          <source>is slower than</source>
          <target state="translated">慢于</target>
        </trans-unit>
        <trans-unit id="d049167d37668316c130f710bc1870b3a57a2719" translate="yes" xml:space="preserve">
          <source>is something that produces a stream of TAP for the parser to consume, such as an executable file, a text file, an archive, an IO handle, a database, etc. &lt;code&gt;TAP::Parser::Source&lt;/code&gt; s encapsulate these</source>
          <target state="translated">是生成供分析器使用的TAP流的东西，例如可执行文件，文本文件，存档，IO句柄，数据库等 &lt;code&gt;TAP::Parser::Source&lt;/code&gt; 封装了这些内容</target>
        </trans-unit>
        <trans-unit id="e9ef489bd0e8e4faddde7bba7424e123d5cb2cdf" translate="yes" xml:space="preserve">
          <source>is substituted, and resulting binaries will be a mess.</source>
          <target state="translated">被替代,产生的二进制文件将是一团糟。</target>
        </trans-unit>
        <trans-unit id="598b73ec92930dcb2052eb812846ae6b23e7a9f4" translate="yes" xml:space="preserve">
          <source>is suggested instead. See also &lt;a href=&quot;perlhacktips#PERL_MEM_LOG&quot;&gt;PERL_MEM_LOG in perlhacktips&lt;/a&gt;.</source>
          <target state="translated">建议使用。另请参见&lt;a href=&quot;perlhacktips#PERL_MEM_LOG&quot;&gt;perlhacktips中的PERL_MEM_LOG&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f36c7e47ba89397191d8268fee1d7e7b3176375" translate="yes" xml:space="preserve">
          <source>is supported by Encode, any source encoding is fine.</source>
          <target state="translated">Encode支持,任何源码都可以。</target>
        </trans-unit>
        <trans-unit id="f26f422c33326b47a62f1cb9a45fdcf68258f29a" translate="yes" xml:space="preserve">
          <source>is that it indiscriminately applies the specified transformation to the entire text of your source program. So something like:</source>
          <target state="translated">是它不分青红皂白地将指定的转换应用到你的源程序的整个文本中。所以类似于:</target>
        </trans-unit>
        <trans-unit id="988ce70c85eae79d0fe25b4054ce79630b89879b" translate="yes" xml:space="preserve">
          <source>is the OP that needs optimizing;</source>
          <target state="translated">是需要优化的OP。</target>
        </trans-unit>
        <trans-unit id="338540b0e9d83bd77bd1013d1cc68e0e7753e278" translate="yes" xml:space="preserve">
          <source>is the OP that requested the eval, and will normally be an &lt;code&gt;OP_ENTEREVAL&lt;/code&gt; , &lt;code&gt;OP_DOFILE&lt;/code&gt; or &lt;code&gt;OP_REQUIRE&lt;/code&gt; .</source>
          <target state="translated">是请求评估的OP，通常为 &lt;code&gt;OP_ENTEREVAL&lt;/code&gt; ， &lt;code&gt;OP_DOFILE&lt;/code&gt; 或 &lt;code&gt;OP_REQUIRE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="503522920752d3b808908bb7e985e21cf9217310" translate="yes" xml:space="preserve">
          <source>is the Unicode code point (in any number of hex digits) of the character that cannot be found in the character repertoire of the encoding.</source>
          <target state="translated">是指在编码的字符库中找不到的字符的Unicode码点(以任意数量的十六进制数字)。</target>
        </trans-unit>
        <trans-unit id="b435409a7d8e12b8eb19aeb5a153ffd1f9f409bc" translate="yes" xml:space="preserve">
          <source>is the access mode and the encoding format to open the file with;</source>
          <target state="translated">是访问模式和打开文件的编码格式。</target>
        </trans-unit>
        <trans-unit id="5fa370b47b540f6499c736b9b14daa48b0750be8" translate="yes" xml:space="preserve">
          <source>is the body of the block. Returns the block, possibly modified.</source>
          <target state="translated">是代码块的主体。返回可能被修改的代码块。</target>
        </trans-unit>
        <trans-unit id="0ae28d04d97b4db2036c9e56276e357f10acc52e" translate="yes" xml:space="preserve">
          <source>is the class we are attaching to,</source>
          <target state="translated">是我们要附加的类。</target>
        </trans-unit>
        <trans-unit id="88c2f81141fada39655c45626c041dad52ddc90e" translate="yes" xml:space="preserve">
          <source>is the debugging one. When called with an argument, switches to debugging or non-debugging dispatcher depending on the argument (active for newly-entered subs/etc only). (The returned value is for the dispatcher before the modification.)</source>
          <target state="translated">是调试型的。有参数时,根据参数的不同,切换到调试或非调试调度器(仅对新输入的子程序等有效)。返回的值是修改前的调度器的值。</target>
        </trans-unit>
        <trans-unit id="82c52d1d716f93b650732617909547f222352c02" translate="yes" xml:space="preserve">
          <source>is the direct equivalent of this bit of Perl</source>
          <target state="translated">直接相当于Perl中的这一点</target>
        </trans-unit>
        <trans-unit id="1fb2b7c32e3e6b82afdc74d9253d0b3262b0d7c9" translate="yes" xml:space="preserve">
          <source>is the empty string. Otherwise, it is an inferior, but still better-than-nothing alternative folding to</source>
          <target state="translated">是空字符串。否则,它是一个较差的,但仍比没有好的替代性折叠,以达到</target>
        </trans-unit>
        <trans-unit id="b4e2abd936326e926d92e153325a90b9130254a2" translate="yes" xml:space="preserve">
          <source>is the external name of the file you want opened.</source>
          <target state="translated">是您要打开的文件的外部名称。</target>
        </trans-unit>
        <trans-unit id="acae083d8f7267d56411d4d8123fe8329504c47b" translate="yes" xml:space="preserve">
          <source>is the famous imaginary number introduced above. Conversion between this form and the cartesian form &lt;code&gt;a + bi&lt;/code&gt; is immediate:</source>
          <target state="translated">是上面介绍的著名的虚数。这种形式和笛卡尔形式 &lt;code&gt;a + bi&lt;/code&gt; 之间的转换是立即的：</target>
        </trans-unit>
        <trans-unit id="e5958b1e8af4ba98be9cc22430ff29e15f04e50c" translate="yes" xml:space="preserve">
          <source>is the file to read for POD source (the POD can be embedded in code). If</source>
          <target state="translated">是读取POD源的文件(POD可以嵌入代码中)。如果</target>
        </trans-unit>
        <trans-unit id="4a902a3b5a686c36c34a6d4895c350e6d72563d5" translate="yes" xml:space="preserve">
          <source>is the hex representation of the octet that could not be decoded to utf8. When you encode, &lt;code&gt;\x{&lt;i&gt;HHHH&lt;/i&gt;}&lt;/code&gt; will be inserted, where</source>
          <target state="translated">是八位位组的十六进制表示形式，无法将其解码为utf8。编码时，将插入 &lt;code&gt;\x{&lt;i&gt;HHHH&lt;/i&gt;}&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="504ac0735ae10a95e2b5ee3e369194696677007c" translate="yes" xml:space="preserve">
          <source>is the hexadecimal number.</source>
          <target state="translated">是十六进制数。</target>
        </trans-unit>
        <trans-unit id="98790fd2c6f05473e5c44b7acdc0f6b4506f2f5e" translate="yes" xml:space="preserve">
          <source>is the index into that array of the layer being called. The macro &lt;code&gt;PerlIOArg&lt;/code&gt; will return a (possibly &lt;code&gt;NULL&lt;/code&gt; ) SV * for the argument passed to the layer.</source>
          <target state="translated">是被调用层的数组的索引。宏 &lt;code&gt;PerlIOArg&lt;/code&gt; 将为传递给该层的参数返回一个SV * （可能为 &lt;code&gt;NULL&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="142db92371cc5426856fa3d444ddae687efa8615" translate="yes" xml:space="preserve">
          <source>is the last argument in the list.</source>
          <target state="translated">是列表中的最后一个参数。</target>
        </trans-unit>
        <trans-unit id="a14b49226b3bbb81004f3cb1f765bb5fef97f5a8" translate="yes" xml:space="preserve">
          <source>is the list-type op, and</source>
          <target state="translated">是列表类型的操作,而</target>
        </trans-unit>
        <trans-unit id="f82606a57221f2b4b38ede02bc6cd6626d56d5e3" translate="yes" xml:space="preserve">
          <source>is the list-type op.</source>
          <target state="translated">是列表类型的操作。</target>
        </trans-unit>
        <trans-unit id="cafab01435fe922ebcb5d5cff02f00617e1abe22" translate="yes" xml:space="preserve">
          <source>is the mapped drive to the sys: volume of the server where Perl on NetWare is installed. Now typing</source>
          <target state="translated">是映射到安装 Perl on NetWare 的服务器的 sys:卷的驱动器。现在输入</target>
        </trans-unit>
        <trans-unit id="5fa4a40ee43f92498170d49135ea24ebd1ead4cd" translate="yes" xml:space="preserve">
          <source>is the moral equivalent of these two:</source>
          <target state="translated">是这两者的道德等价物。</target>
        </trans-unit>
        <trans-unit id="14b3a81aac7cf79ce51c3e68af0806f7f4937ca7" translate="yes" xml:space="preserve">
          <source>is the most popular. UTF-8 is a variable length encoding that encodes Unicode characters as 1 to 4 bytes. Other encodings include UTF-16 and UTF-32 and their big- and little-endian variants (UTF-8 is byte-order independent). The ISO/IEC 10646 defines the UCS-2 and UCS-4 encoding forms.</source>
          <target state="translated">是最流行的。UTF-8是一种可变长度的编码,将Unicode字符编码为1至4个字节。其他编码包括UTF-16和UTF-32以及它们的大字节和小字节变体(UTF-8与字节顺序无关)。ISO/IEC 10646定义了UCS-2和UCS-4编码形式。</target>
        </trans-unit>
        <trans-unit id="0b4974b8d2e6f377f9801c3b800b1ac0b7c4207d" translate="yes" xml:space="preserve">
          <source>is the name of the extension, with all &lt;code&gt;::&lt;/code&gt; replaced by &lt;code&gt;.&lt;/code&gt; (e.g. the library module for extension Foo::Bar would be copied to a</source>
          <target state="translated">是扩展名，所有 &lt;code&gt;::&lt;/code&gt; 替换为 &lt;code&gt;.&lt;/code&gt; （例如，扩展名为Foo :: Bar的库模块将被复制到</target>
        </trans-unit>
        <trans-unit id="fdcdffe2e65ad3302d98757411e195b4ad6675af" translate="yes" xml:space="preserve">
          <source>is the name of the module to load. If the string specified does not contain the package separator characters &quot;::&quot;, it is assumed to refer to the full module name &quot;DBM_Filter::name&quot;. This means that the full names for canned filters, &quot;null&quot; and &quot;utf8&quot;, included with this module are:</source>
          <target state="translated">是要加载的模块的名称,如果指定的字符串不包含分隔符&quot;::&quot;,则假定是指完整的模块名称 &quot;DBM_Filter::name&quot;。如果指定的字符串不包含包的分隔符&quot;::&quot;,它被认为是指完整的模块名称 &quot;DBM_Filter::name&quot;。这意味着罐装过滤器的完整名称 &quot;null &quot;和 &quot;utf8&quot;,包括这个模块。</target>
        </trans-unit>
        <trans-unit id="0de37e5050d6ab02ac54039af959dc47e7ba20d0" translate="yes" xml:space="preserve">
          <source>is the name of the package, and is only used in comments inside the generated C code.</source>
          <target state="translated">是包的名称,只在生成的C代码中的注释中使用。</target>
        </trans-unit>
        <trans-unit id="45440de46c4177a6572cf02f38585860def2ca1a" translate="yes" xml:space="preserve">
          <source>is the name, and the &lt;code&gt;[:&lt;/code&gt; and &lt;code&gt;:]&lt;/code&gt; delimiters. POSIX character classes only appear</source>
          <target state="translated">是名称，以及 &lt;code&gt;[:&lt;/code&gt; 和 &lt;code&gt;:]&lt;/code&gt; 分隔符。POSIX字符类仅出现</target>
        </trans-unit>
        <trans-unit id="896190cdbc3b73377c85418c4564a09f6ac5486e" translate="yes" xml:space="preserve">
          <source>is the number assigned to a character: for example, in EBCDIC the character &quot;A&quot; is usually assigned the number 193. In Unicode, the character &quot;A&quot; is assigned the number 65. All the code points in ASCII and Latin-1 (ISO 8859-1) have the same meaning in Unicode. All three of the recognized EBCDIC code sets have 256 code points, and in each code set, all 256 code points are mapped to equivalent Latin1 code points. Obviously, &quot;A&quot; will map to &quot;A&quot;, &quot;B&quot; =&amp;gt; &quot;B&quot;, &quot;%&quot; =&amp;gt; &quot;%&quot;, etc., for all printable characters in Latin1 and these code pages.</source>
          <target state="translated">是分配给字符的数字：例如，在EBCDIC中，字符&amp;ldquo; A&amp;rdquo;通常被分配数字193。在Unicode中，字符&amp;ldquo; A&amp;rdquo;被分配了数字65。所有以ASCII和Latin-1（ ISO 8859-1）在Unicode中具有相同的含义。所有三个公认的EBCDIC代码集都有256个代码点，并且在每个代码集中，所有256个代码点都映射到等效的Latin1代码点。显然，对于Latin1和这些代码页中的所有可打印字符，&amp;ldquo; A&amp;rdquo;将映射为&amp;ldquo; A&amp;rdquo;，&amp;ldquo; B&amp;rdquo; =&amp;gt;&amp;ldquo; B&amp;rdquo;，&amp;ldquo;％&amp;rdquo; =&amp;gt;&amp;ldquo;％&amp;rdquo;等。</target>
        </trans-unit>
        <trans-unit id="44a3ced633aa8e3d881613e20fe3ca4570b01d8e" translate="yes" xml:space="preserve">
          <source>is the number of spaces to indent, defaulting to 6.</source>
          <target state="translated">是缩进的空格数,默认为6。</target>
        </trans-unit>
        <trans-unit id="f35768e77df2a6fcb46d380fc0c5c7af5c55fc6d" translate="yes" xml:space="preserve">
          <source>is the object to serialize,</source>
          <target state="translated">是要序列化的对象。</target>
        </trans-unit>
        <trans-unit id="490225a54a9ac66bcdb59f92017f41f299257ed1" translate="yes" xml:space="preserve">
          <source>is the op being considered, normally an &lt;code&gt;rv2cv&lt;/code&gt; op. A pointer to the identified subroutine is returned, if it could be determined statically, and a null pointer is returned if it was not possible to determine statically.</source>
          <target state="translated">是要考虑的op，通常是 &lt;code&gt;rv2cv&lt;/code&gt; op。如果可以静态确定，则返回指向已标识子例程的指针，如果无法静态确定，则返回空指针。</target>
        </trans-unit>
        <trans-unit id="346d72197b82381e3d135c3fd096d1560c48b51d" translate="yes" xml:space="preserve">
          <source>is the op to append to the list.</source>
          <target state="translated">是要追加到列表中的操作。</target>
        </trans-unit>
        <trans-unit id="2c471482064fafead892cdf7b22397b6be3fe1e9" translate="yes" xml:space="preserve">
          <source>is the op to prepend to the list, and</source>
          <target state="translated">是要放在列表前的操作,而</target>
        </trans-unit>
        <trans-unit id="aaf68fac1b03ed7c6353ab95af2dd6b8cc61684c" translate="yes" xml:space="preserve">
          <source>is the op tree, and</source>
          <target state="translated">是运算树,而</target>
        </trans-unit>
        <trans-unit id="3684b3a23a1a941786c7c86346c047661fcfe052" translate="yes" xml:space="preserve">
          <source>is the opcode of a binary operator, such as &lt;code&gt;OP_BIT_OR&lt;/code&gt; , then an op is constructed that performs the binary operation and assigns the result to the left argument. Either way, if</source>
          <target state="translated">是二进制运算符的操作码，例如 &lt;code&gt;OP_BIT_OR&lt;/code&gt; ，则构造一个执行二进制运算并将结果分配给left参数的op。无论哪种方式，如果</target>
        </trans-unit>
        <trans-unit id="a0a985ac039d3d2ad165d51298ff6ea64e498ec2" translate="yes" xml:space="preserve">
          <source>is the opcode.</source>
          <target state="translated">是操作码。</target>
        </trans-unit>
        <trans-unit id="185ceb5c9d854b05a21926141803af21e0fce555" translate="yes" xml:space="preserve">
          <source>is the outer pad name that this one mirrors. The returned pad name has the PADNAMEt_OUTER flag already set.</source>
          <target state="translated">是这个文件镜像的外部垫名。返回的垫名已经设置了PADNAMEt_OUTER标志。</target>
        </trans-unit>
        <trans-unit id="a6ee3b580c0eceeeca1f85f9032f86a8c10b6343" translate="yes" xml:space="preserve">
          <source>is the pad offset of the scalar lexical variable that will be affected. If it is 0, the global $_ will be used.</source>
          <target state="translated">是将被影响的标量词法变量的焊盘偏移量。如果是0,则使用全局的$_。</target>
        </trans-unit>
        <trans-unit id="075349611fc93d2e62829ba77d41e494ad441dd4" translate="yes" xml:space="preserve">
          <source>is the perl version the code should be backwards compatible with. It defaults to the version of perl running the subroutine. If</source>
          <target state="translated">是代码应该向后兼容的perl版本。它的默认值是运行子程序的perl版本。如果</target>
        </trans-unit>
        <trans-unit id="2e519216b0de8348846fa9b4a5055de6958ae755" translate="yes" xml:space="preserve">
          <source>is the point whose coordinates are (a, b). Actually, it would be the vector originating from (0, 0) to (a, b). It follows that the addition of two complex numbers is a vectorial addition.</source>
          <target state="translated">是坐标为(a,b)的点。实际上,它应该是源于(0,0)到(a,b)的向量。由此可见,两个复数的加法是一个向量加法。</target>
        </trans-unit>
        <trans-unit id="2cc4f790eddde04d02f931089ea9bbb40ba3a6a4" translate="yes" xml:space="preserve">
          <source>is the portion of the extension's name after the last &lt;code&gt;::&lt;/code&gt; , which translates to the full file specification of the shareable image.</source>
          <target state="translated">是扩展名中最后一个 &lt;code&gt;::&lt;/code&gt; 后面的部分，它转换为可共享映像的完整文件规范。</target>
        </trans-unit>
        <trans-unit id="2d16c45482f74eb9930301a0ecafdb6a012a8de5" translate="yes" xml:space="preserve">
          <source>is the portion of the extension's name following the last &lt;code&gt;::&lt;/code&gt; ), containing the XS code,</source>
          <target state="translated">是扩展名中最后一个 &lt;code&gt;::&lt;/code&gt; :）之后的部分，其中包含XS代码，</target>
        </trans-unit>
        <trans-unit id="ff4bfee209d75ed4a7ac713cfc5d716f2c1e2be4" translate="yes" xml:space="preserve">
          <source>is the previous OP optimized, whose &lt;code&gt;op_next&lt;/code&gt; points to</source>
          <target state="translated">是先前优化的OP，其 &lt;code&gt;op_next&lt;/code&gt; 指向</target>
        </trans-unit>
        <trans-unit id="7959ce09f1e3e9e7ae880e926860f28302895b7e" translate="yes" xml:space="preserve">
          <source>is the primary name of this option. When a program executes under &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; (recommended), these variables must be pre-declared with our() or &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; .</source>
          <target state="translated">是此选项的主要名称。当程序在 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;../functions/use&quot;&gt;使用&lt;/a&gt;（推荐）条件下执行时，必须使用our（）或 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 预先声明这些变量。</target>
        </trans-unit>
        <trans-unit id="dc92b1dcb6d32cc02b0b929328d0aa4e792bcfc8" translate="yes" xml:space="preserve">
          <source>is the property of a particular build of perl, and does not depend on the current process. If you do not provide the optional argument to the functions mstats_fillhash(), fill_mstats(), mstats2hash(), then the information in fields &lt;code&gt;mem_size&lt;/code&gt; , &lt;code&gt;available_size&lt;/code&gt; is not updated.</source>
          <target state="translated">是perl特定版本的属性，并且不依赖于当前过程。如果不向函数mstats_fillhash（），fill_mstats（），mstats2hash（）提供可选参数，则不会更新字段 &lt;code&gt;mem_size&lt;/code&gt; ， &lt;code&gt;available_size&lt;/code&gt; 中的信息。</target>
        </trans-unit>
        <trans-unit id="e0a2bbcb355a7bdbc9b5d8f8dbd1d6a1892216c8" translate="yes" xml:space="preserve">
          <source>is the reason for version-specific mangling of the DLL name for perl DLL.</source>
          <target state="translated">是版本特定的原因,对perl DLL的DLL名称进行了混淆。</target>
        </trans-unit>
        <trans-unit id="533e118d459a0417538dc17219094be54c0e410e" translate="yes" xml:space="preserve">
          <source>is the recommended way to report bugs in the perl interpreter itself or any of the standard library modules back to the developers; please read through the documentation for</source>
          <target state="translated">是推荐的向开发者报告 perl 解释器本身或任何标准库模块中的错误的方式;请阅读文档中的</target>
        </trans-unit>
        <trans-unit id="059ae99546fd6d2b968c421a21e81f0cc4cf52d3" translate="yes" xml:space="preserve">
          <source>is the recommended wide native character-aware way of saying</source>
          <target state="translated">是推荐的广义本位字的表达方式。</target>
        </trans-unit>
        <trans-unit id="b99ef0d01d54e7d02d4e29eb81f05081577ed0c4" translate="yes" xml:space="preserve">
          <source>is the root of the optree representing the scope; it is a double pointer so you can replace the OP if you need to.</source>
          <target state="translated">是代表作用域的optree的根,它是一个双指针,所以你可以在需要的时候替换OP。</target>
        </trans-unit>
        <trans-unit id="841108c86e9fbb4edafbf1fc269ca06fbd9c2aa7" translate="yes" xml:space="preserve">
          <source>is the same as</source>
          <target state="translated">是一样的</target>
        </trans-unit>
        <trans-unit id="5664826178886ed6dc31d7a56be756161e89003e" translate="yes" xml:space="preserve">
          <source>is the same as this:</source>
          <target state="translated">与此相同。</target>
        </trans-unit>
        <trans-unit id="ea9ca7dc351fef7638a53b6e78fc2c745436b2f0" translate="yes" xml:space="preserve">
          <source>is the same as using the program:</source>
          <target state="translated">和使用程序是一样的。</target>
        </trans-unit>
        <trans-unit id="c789dc7dbbbae7937501c4047bbd4ca49aed4ac3" translate="yes" xml:space="preserve">
          <source>is the savestack index returned by &lt;code&gt;block_start&lt;/code&gt; , and</source>
          <target state="translated">是 &lt;code&gt;block_start&lt;/code&gt; 返回的保存堆栈索引，并且</target>
        </trans-unit>
        <trans-unit id="4a63caa46b829fcb01fe4a8c31e68b7e20d84a2f" translate="yes" xml:space="preserve">
          <source>is the scalar value to store for this key.</source>
          <target state="translated">是这个键的标量值。</target>
        </trans-unit>
        <trans-unit id="cb053ed2ecf771fb84e4c68638f701622bf37193" translate="yes" xml:space="preserve">
          <source>is the serialized string you returned to the engine in &lt;code&gt;STORABLE_freeze&lt;/code&gt; , and there may be an optional list of references, in the same order you gave them at serialization time, pointing to the deserialized objects (which have been processed courtesy of the Storable engine).</source>
          <target state="translated">是您在 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 中返回给引擎的序列化字符串，并且可能有一个可选的引用列表，其顺序与您在序列化时赋予它们的顺序相同，指向反序列化的对象（已由Storable引擎处理）。</target>
        </trans-unit>
        <trans-unit id="681d5ca1a6522883a0d7e74c2ad38f23f79e4445" translate="yes" xml:space="preserve">
          <source>is the shortest distance between two points on a sphere. The distance is in &lt;code&gt;$rho&lt;/code&gt; units. The &lt;code&gt;$rho&lt;/code&gt; is optional, it defaults to 1 (the unit sphere), therefore the distance defaults to radians.</source>
          <target state="translated">是球体上两点之间的最短距离。距离以 &lt;code&gt;$rho&lt;/code&gt; 单位表示。的 &lt;code&gt;$rho&lt;/code&gt; 是可选的，其默认值为1（单位球面），因此，距离默认为弧度。</target>
        </trans-unit>
        <trans-unit id="bb152e814624de7f776388475643c5915a6bbc02" translate="yes" xml:space="preserve">
          <source>is the stored string for the resource object.</source>
          <target state="translated">是资源对象的存储字符串。</target>
        </trans-unit>
        <trans-unit id="7666856489819ec07e5e68fda7968ecdf4b7481e" translate="yes" xml:space="preserve">
          <source>is the string &lt;code&gt;&quot;\0X\0\0YZ&quot;&lt;/code&gt; .</source>
          <target state="translated">是字符串 &lt;code&gt;&quot;\0X\0\0YZ&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4af45b7011bdf9dc23ddbc9ab955c3a70b8a6852" translate="yes" xml:space="preserve">
          <source>is the string length, not the number of strings. With an explicit repeat count for pack, the packed string is adjusted to that length. For example:</source>
          <target state="translated">是字符串的长度,而不是字符串的数量。如果对pack有明确的重复次数,打包后的字符串就会调整为该长度。例如</target>
        </trans-unit>
        <trans-unit id="a38238d720532a1187dfe70331e701543f8d69a2" translate="yes" xml:space="preserve">
          <source>is the type returned by &lt;code&gt;ITEM&lt;/code&gt; s that don't specify their type. It defaults to the value of &lt;code&gt;default_type()&lt;/code&gt; .</source>
          <target state="translated">是 &lt;code&gt;ITEM&lt;/code&gt; 返回的类型，未指定其类型。它默认为 &lt;code&gt;default_type()&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="62dd259d4f7a6605999861260db4a925294adb84" translate="yes" xml:space="preserve">
          <source>is the unknown layer.</source>
          <target state="translated">是未知层。</target>
        </trans-unit>
        <trans-unit id="7ebb9cb388028784d1ffeb685835e29c39c8a750" translate="yes" xml:space="preserve">
          <source>is the version of Perl you're using, as supplied in &lt;code&gt;$]&lt;/code&gt; , with '.' converted to '_'), or</source>
          <target state="translated">是您正在使用的Perl的版本，如 &lt;code&gt;$]&lt;/code&gt; 中所提供，带有'。'。转换为&amp;ldquo; _&amp;rdquo;），或</target>
        </trans-unit>
        <trans-unit id="334b91284c73938e4e816a510966fc314842a93e" translate="yes" xml:space="preserve">
          <source>is translated once when Perl starts up; any changes you make while Perl is running do not affect the behavior of &lt;code&gt;%ENV&lt;/code&gt; . If</source>
          <target state="translated">Perl启动时翻译一次；Perl运行时所做的任何更改都不会影响 &lt;code&gt;%ENV&lt;/code&gt; 的行为。如果</target>
        </trans-unit>
        <trans-unit id="a86d775dd40947cb031e2e57ff35692497a46818" translate="yes" xml:space="preserve">
          <source>is treated as number of spaces to indent by. If &lt;code&gt;declare_types&lt;/code&gt; is true a &lt;code&gt;$types&lt;/code&gt; is always declared in the perl code generated, if defined and false never declared, and if undefined &lt;code&gt;$types&lt;/code&gt; is only declared if the values in</source>
          <target state="translated">被视为缩进的空格数。如果 &lt;code&gt;declare_types&lt;/code&gt; 为true，则始终在生成的perl代码中声明 &lt;code&gt;$types&lt;/code&gt; ，如果已定义且为false，则从不声明；如果未定义 &lt;code&gt;$types&lt;/code&gt; 则仅在</target>
        </trans-unit>
        <trans-unit id="10fa8676748c59212055af40992e63bcbc7c643b" translate="yes" xml:space="preserve">
          <source>is true (not empty or zero), generates the value of</source>
          <target state="translated">为真(不为空或为零),产生的值为</target>
        </trans-unit>
        <trans-unit id="48302db9668c7d7b445abda36a22e6062f411e8f" translate="yes" xml:space="preserve">
          <source>is true on all platforms. If you want native code points for the low 256, use the &lt;code&gt;&quot;W&quot;&lt;/code&gt; template. This means that the equivalences</source>
          <target state="translated">在所有平台上都是如此。如果要将本机代码点设置为低256，请使用 &lt;code&gt;&quot;W&quot;&lt;/code&gt; 模板。这意味着等价</target>
        </trans-unit>
        <trans-unit id="067d235b3d6dbb909f945abdb70f31cbc437b930" translate="yes" xml:space="preserve">
          <source>is true when we're part of a deep clone operation,</source>
          <target state="translated">当我们参与深度克隆行动时,是真的。</target>
        </trans-unit>
        <trans-unit id="779d38fac96628c599fdd2384e085d60ba46ca15" translate="yes" xml:space="preserve">
          <source>is true, also checks whether</source>
          <target state="translated">是否为真,同时检查</target>
        </trans-unit>
        <trans-unit id="45f8f7c6ce5b54b9230f2a84836b12d460e6184b" translate="yes" xml:space="preserve">
          <source>is true, ignore case. The default is to honour case.</source>
          <target state="translated">为真,忽略大小写。默认情况下,忽略大小写。</target>
        </trans-unit>
        <trans-unit id="4056d1d8ea1ba0fdc400bcac4f4b8f6e5cb5bd11" translate="yes" xml:space="preserve">
          <source>is true, it SHOULD modify</source>
          <target state="translated">为真,它应该修改</target>
        </trans-unit>
        <trans-unit id="e01d069b2f9d59305c080956514566b0ca93db4c" translate="yes" xml:space="preserve">
          <source>is true, returns false.</source>
          <target state="translated">为真,返回假。</target>
        </trans-unit>
        <trans-unit id="4c6f61c4a55f03174097ae702fb602dd769db21e" translate="yes" xml:space="preserve">
          <source>is true, search by dictionary order (ignore anything but word characters and whitespace). The default is honour all characters.</source>
          <target state="translated">为真,按字典顺序搜索(忽略除单词字符和空格以外的任何内容)。默认值是尊重所有字符。</target>
        </trans-unit>
        <trans-unit id="ec9b11fcd9e9d4abe8ffa5611c1f06b9f3b4638a" translate="yes" xml:space="preserve">
          <source>is true, the AUTOLOAD subroutine falls back on AutoLoader::AUTOLOAD for all names that the constant() routine doesn't recognise.</source>
          <target state="translated">为真,则AUTOLOAD子程序会对所有constant()例程无法识别的名称回退到AutoLoader::AUTOLOAD。</target>
        </trans-unit>
        <trans-unit id="1c557d39d34bad4891cbefb6c9ce51864c16f310" translate="yes" xml:space="preserve">
          <source>is true, the scheme above allows the encoding to do as much as it can and tell the layer above how much that was. What is lacking at present is a mechanism to report what went wrong. The most likely interface will be an additional method call to the object, or perhaps (to avoid forcing per-stream objects on otherwise stateless encodings) an additional parameter.</source>
          <target state="translated">是真的,上面的方案可以让编码做多少就做多少,并告诉上一层是多少。目前缺乏的是报告出错的机制。最有可能的接口是对对象进行额外的方法调用,或者可能(为了避免在其他无状态编码上强行使用每流对象)增加一个参数。</target>
        </trans-unit>
        <trans-unit id="a5fb713f23256ce8adf865a7bb140abb92cbc783" translate="yes" xml:space="preserve">
          <source>is two characters, the first character is used as the left quote and the second as the right quoted; and if</source>
          <target state="translated">是两个字符,第一个字符作为左引号,第二个字符作为右引号;如果是</target>
        </trans-unit>
        <trans-unit id="da08ff0a55825cc7ad3dbe2e4beefb9e6a6ab73b" translate="yes" xml:space="preserve">
          <source>is unlinked.</source>
          <target state="translated">是没有联系的。</target>
        </trans-unit>
        <trans-unit id="99206005453caddd66236543e24f39a90d1fd368" translate="yes" xml:space="preserve">
          <source>is used &lt;b&gt;instead&lt;/b&gt; of &lt;code&gt;Compress::Zlib&lt;/code&gt; .</source>
          <target state="translated">用来&lt;b&gt;代替&lt;/b&gt;的 &lt;code&gt;Compress::Zlib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82cf7ac9ae1725690fb609a1273cc9ea666cc709" translate="yes" xml:space="preserve">
          <source>is used instead of &lt;code&gt;\x{&lt;i&gt;XXXX&lt;/i&gt;}&lt;/code&gt;.</source>
          <target state="translated">用于代替 &lt;code&gt;\x{&lt;i&gt;XXXX&lt;/i&gt;}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db853bb4b5bdcd8035b1c491d509b51c38d42af0" translate="yes" xml:space="preserve">
          <source>is used instead. So we have</source>
          <target state="translated">是用来代替的。所以我们有</target>
        </trans-unit>
        <trans-unit id="38f21bebe9090675b3b7c95faffad6681c98ff75" translate="yes" xml:space="preserve">
          <source>is used to call a method from a Perl class. The parameter &lt;code&gt;methname&lt;/code&gt; corresponds to the name of the method to be called. Note that the class that the method belongs to is passed on the Perl stack rather than in the parameter list. This class can be either the name of the class (for a static method) or a reference to an object (for a virtual method). See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more information on static and virtual methods and &lt;a href=&quot;#Using-call_method&quot;&gt;Using call_method&lt;/a&gt; for an example of using</source>
          <target state="translated">用于从Perl类调用方法。参数 &lt;code&gt;methname&lt;/code&gt; 对应于要调用的方法的名称。请注意，该方法所属的类是在Perl堆栈上而不是在参数列表中传递的。该类可以是该类的名称（对于静态方法），也可以是对对象的引用（对于虚拟方法）。有关静态和虚拟方法的更多信息，请参见&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;；有关&lt;a href=&quot;#Using-call_method&quot;&gt;使用&lt;/a&gt;示例，请参见使用call_method。</target>
        </trans-unit>
        <trans-unit id="174c45b58d93e19a1bf9b115b40967fdc9b93c7c" translate="yes" xml:space="preserve">
          <source>is used to create a &lt;a href=&quot;parser/source&quot;&gt;TAP::Parser::Source&lt;/a&gt; that is passed to the &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt; which in turn figures out how to handle the source and creates a &amp;lt;TAP::Parser::Iterator&amp;gt; for it. The iterator is used by the parser to read in the TAP stream.</source>
          <target state="translated">用于创建传递给&lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt;的&lt;a href=&quot;parser/source&quot;&gt;TAP :: Parser :: Source&lt;/a&gt;，后者进而找出如何处理源并为其创建&amp;lt;TAP :: Parser :: Iterator&amp;gt;。解析器使用迭代器来读取TAP流。</target>
        </trans-unit>
        <trans-unit id="3d08f94f5cb97d407acf7f344990711fbd64478a" translate="yes" xml:space="preserve">
          <source>is used to refer to UTF-8 on ASCII and ISO Latin based platforms and UTF-EBCDIC on EBCDIC based platforms.</source>
          <target state="translated">在ASCII和基于ISO拉丁语的平台上用于指UTF-8,在基于EBCDIC的平台上用于指UTF-EBCDIC。</target>
        </trans-unit>
        <trans-unit id="caef3d98540ddc9f2f1ce1a294bcbe58f435fe11" translate="yes" xml:space="preserve">
          <source>is used to store this status.</source>
          <target state="translated">是用来存储这个状态的。</target>
        </trans-unit>
        <trans-unit id="d148088d7797718280b1177b22c2c5191737877f" translate="yes" xml:space="preserve">
          <source>is used, the following &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;s are used:</source>
          <target state="translated">使用时，使用以下 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a6839d76bbb7783af5dc7927fd3ea8c02821e91c" translate="yes" xml:space="preserve">
          <source>is used.</source>
          <target state="translated">是用。</target>
        </trans-unit>
        <trans-unit id="0c7240c81a5b6100a1329f457d83532b0ff32851" translate="yes" xml:space="preserve">
          <source>is used. If no password is given and the login is</source>
          <target state="translated">被使用。如果没有给出密码,而登录是</target>
        </trans-unit>
        <trans-unit id="fe97f79326aa164bdecbb65e7fb757c2dd7af24b" translate="yes" xml:space="preserve">
          <source>is used. When you decode, the Unicode REPLACEMENT CHARACTER, code point U+FFFD, is used. If the data is supposed to be UTF-8, an optional lexical warning of warning category &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; is given.</source>
          <target state="translated">用来。解码时，使用Unicode REPLACEMENT CHARACTER，代码点U + FFFD。如果数据应为UTF-8，则给出警告类别为 &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 的可选词汇警告。</target>
        </trans-unit>
        <trans-unit id="12235ad06fa18edfce70787b2cda7be75ef01ddb" translate="yes" xml:space="preserve">
          <source>is useful because it allows other code (typically parser support code or caching variables) to be defined before the filter is invoked. However, there is often no need for such a separation.</source>
          <target state="translated">是很有用的,因为它允许在调用过滤器之前定义其他代码(通常是解析器支持代码或缓存变量)。然而,通常不需要这样的分离。</target>
        </trans-unit>
        <trans-unit id="4e47b26bd8204f22d84b37cecf46b2ae865ef9fd" translate="yes" xml:space="preserve">
          <source>is useful.</source>
          <target state="translated">是有用的。</target>
        </trans-unit>
        <trans-unit id="40a7b397fd325b5ecbf0d373914724c1f6367724" translate="yes" xml:space="preserve">
          <source>is usually 1 for on, but higher values trigger additional warnings. See &lt;a href=&quot;#Warnings&quot;&gt;Warnings&lt;/a&gt;.</source>
          <target state="translated">通常为1表示开启，但较高的值会触发其他警告。请参阅&lt;a href=&quot;#Warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69bc4bb7fd74f861f5b8bca772f152dcc604661a" translate="yes" xml:space="preserve">
          <source>is valid and matches '0', '1', any alphabetic character, and the percent sign.</source>
          <target state="translated">是有效的,并且匹配'0'、'1'、任何字母字符和百分号。</target>
        </trans-unit>
        <trans-unit id="d231156292aeca125ab2ff401f5be71547c7f695" translate="yes" xml:space="preserve">
          <source>is where the main processing for the filter is done.</source>
          <target state="translated">是对滤波器进行主要处理的地方。</target>
        </trans-unit>
        <trans-unit id="30e01163fe1949f10b45b91d1e13f0c7637e25e7" translate="yes" xml:space="preserve">
          <source>is written into the &lt;a href=&quot;#PL_check&quot;&gt;PL_check&lt;/a&gt; array, while the value previously stored there is written to</source>
          <target state="translated">被写入&lt;a href=&quot;#PL_check&quot;&gt;PL_check&lt;/a&gt;数组，而先前存储在其中的值被写入</target>
        </trans-unit>
        <trans-unit id="680b8b11b1f1a95b7c654104af2981b4c44a0974" translate="yes" xml:space="preserve">
          <source>is your blessed reference for this particular instance.</source>
          <target state="translated">是你对这个特殊例子的祝福参考。</target>
        </trans-unit>
        <trans-unit id="637ede9f0bac88412365638ad04d0f903dece281" translate="yes" xml:space="preserve">
          <source>is zero or</source>
          <target state="translated">为零或</target>
        </trans-unit>
        <trans-unit id="da78c7a4809cb6ce24ac8e29b2195288ba32cd34" translate="yes" xml:space="preserve">
          <source>is zero, then a plain scalar or list assignment is constructed. Which type of assignment it is is automatically determined.</source>
          <target state="translated">是零,那么就会构造一个普通标量或列表赋值。自动确定是哪种类型的赋值。</target>
        </trans-unit>
        <trans-unit id="623d50572aae446dc358fd966327ce8c9a0ed204" translate="yes" xml:space="preserve">
          <source>is, if non-empty, the lowercase mapping for</source>
          <target state="translated">的小写映射,如果非空,则为</target>
        </trans-unit>
        <trans-unit id="3d7682c10121c3528254ad891855f87cf827fae6" translate="yes" xml:space="preserve">
          <source>is, if non-empty, the titlecase mapping for</source>
          <target state="translated">如果非空,则为</target>
        </trans-unit>
        <trans-unit id="17656293490b52e28e817d6f958f58501e80a596" translate="yes" xml:space="preserve">
          <source>is, if non-empty, the uppercase mapping for</source>
          <target state="translated">的大写映射,如果非空,则为</target>
        </trans-unit>
        <trans-unit id="cb18cfba59a431e4fe8a80b174c133778446c806" translate="yes" xml:space="preserve">
          <source>is, in short, an idhash with auto-registry. When an object (or, indeed, any reference) is used as a fieldhash key, the fieldhash is automatically registered for garbage collection with the object, as if &lt;code&gt;register $obj, \ %fieldhash&lt;/code&gt; had been called.</source>
          <target state="translated">简而言之，是具有自动注册功能的idhash。当将一个对象（或实际上是任何引用）用作字段哈希键时，该字段哈希将自动注册为该对象的垃圾回收，就好像已调用了 &lt;code&gt;register $obj, \ %fieldhash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2eb3ddf53a44d0014465dbf2511b96e2ca53542f" translate="yes" xml:space="preserve">
          <source>is_even()</source>
          <target state="translated">is_even()</target>
        </trans-unit>
        <trans-unit id="11dbccec36ef1a03c703d514dd31a8d0c0798066" translate="yes" xml:space="preserve">
          <source>is_int()</source>
          <target state="translated">is_int()</target>
        </trans-unit>
        <trans-unit id="81c4be558fcd3af8cca4b285c2962c5989f928f3" translate="yes" xml:space="preserve">
          <source>is_make_type</source>
          <target state="translated">is_make_type</target>
        </trans-unit>
        <trans-unit id="5e192aa23e81e4d04b32a6b074858b9c768cac41" translate="yes" xml:space="preserve">
          <source>is_neg()/is_negative()</source>
          <target state="translated">is_neg()/is_negative()</target>
        </trans-unit>
        <trans-unit id="2ffcb1a862f4b027f0ab6152305df1200860e1b3" translate="yes" xml:space="preserve">
          <source>is_odd()</source>
          <target state="translated">is_odd()</target>
        </trans-unit>
        <trans-unit id="70c8f014e9c6a6d99e78620643d9bc507b9fb363" translate="yes" xml:space="preserve">
          <source>is_one()</source>
          <target state="translated">is_one()</target>
        </trans-unit>
        <trans-unit id="aeee4fc11afe65037967eaa9c965d8912ecf4589" translate="yes" xml:space="preserve">
          <source>is_pos()/is_positive()</source>
          <target state="translated">is_pos()/is_positive()</target>
        </trans-unit>
        <trans-unit id="e07cc517821b5551e950dff4acb3c80a32d29930" translate="yes" xml:space="preserve">
          <source>is_utf8</source>
          <target state="translated">is_utf8</target>
        </trans-unit>
        <trans-unit id="1ddb13cfa4feb404c5ec5eefd16e3616cef8e112" translate="yes" xml:space="preserve">
          <source>is_zero()</source>
          <target state="translated">is_zero()</target>
        </trans-unit>
        <trans-unit id="8ffda1fa78645c009ffa2b7d1f049da6785b1dfd" translate="yes" xml:space="preserve">
          <source>isdual</source>
          <target state="translated">isdual</target>
        </trans-unit>
        <trans-unit id="ee2ebf5133051bf39cd49d499acea403e44a4978" translate="yes" xml:space="preserve">
          <source>isn't</source>
          <target state="translated">isn't</target>
        </trans-unit>
        <trans-unit id="9d94e5f09ea80b838abc637f6cc2137bf9b40766" translate="yes" xml:space="preserve">
          <source>isn't available,</source>
          <target state="translated">是不可用的。</target>
        </trans-unit>
        <trans-unit id="b643075840def260815468ce095b78f495761c52" translate="yes" xml:space="preserve">
          <source>isn't available, it converts it to plain text with the external command</source>
          <target state="translated">无法使用,它就会用外部的命令</target>
        </trans-unit>
        <trans-unit id="e16b96ecf693e658c2424ac211a1dfdc920c5a12" translate="yes" xml:space="preserve">
          <source>isn't given, it defaults to &lt;code&gt;STDIN&lt;/code&gt; .</source>
          <target state="translated">没有给出，默认为 &lt;code&gt;STDIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75e52afea6c5f5fb7c62edc35d62baf474ddc2bf" translate="yes" xml:space="preserve">
          <source>isn't given, the formatted output is written to &lt;code&gt;STDOUT&lt;/code&gt; . Several POD files can be processed in the same &lt;b&gt;pod2man&lt;/b&gt; invocation (saving module load and compile times) by providing multiple pairs of</source>
          <target state="translated">没有给出，格式化的输出将被写入 &lt;code&gt;STDOUT&lt;/code&gt; 。可以通过提供多个对来在同一&lt;b&gt;pod2man&lt;/b&gt;调用中处理多个POD文件（节省模块加载和编译时间）。</target>
        </trans-unit>
        <trans-unit id="464bc0306867e48eb03dffa3c82d60e097b5207c" translate="yes" xml:space="preserve">
          <source>isn't given, the formatted output is written to &lt;code&gt;STDOUT&lt;/code&gt; . Several POD files can be processed in the same &lt;b&gt;pod2text&lt;/b&gt; invocation (saving module load and compile times) by providing multiple pairs of</source>
          <target state="translated">没有给出，格式化的输出将被写入 &lt;code&gt;STDOUT&lt;/code&gt; 。可以通过提供多个对来在同一&lt;b&gt;pod2text&lt;/b&gt;调用中处理多个POD文件（节省模块加载和编译时间）。</target>
        </trans-unit>
        <trans-unit id="96d2a4fbb9059f5330274f55be6262e3cbc96904" translate="yes" xml:space="preserve">
          <source>issue 21. See &lt;a href=&quot;http://interglacial.com/tpj/21/&quot;&gt;http://interglacial.com/tpj/21/&lt;/a&gt;</source>
          <target state="translated">第21期。请参阅&lt;a href=&quot;http://interglacial.com/tpj/21/&quot;&gt;http://interglacial.com/tpj/21/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1da083affe279217f988b36f92bb98ac176b46e" translate="yes" xml:space="preserve">
          <source>issymlink.U</source>
          <target state="translated">issymlink.U</target>
        </trans-unit>
        <trans-unit id="45098fc2aa4e6608f56f987d63d68920609dbbd1" translate="yes" xml:space="preserve">
          <source>isvstring</source>
          <target state="translated">isvstring</target>
        </trans-unit>
        <trans-unit id="073c2d116dfe6c35185754930917fb5ca91ecdec" translate="yes" xml:space="preserve">
          <source>isweak</source>
          <target state="translated">isweak</target>
        </trans-unit>
        <trans-unit id="6c5522ca8af86fc5069b737bb8892b3ea61002c2" translate="yes" xml:space="preserve">
          <source>it</source>
          <target state="translated">it</target>
        </trans-unit>
        <trans-unit id="05a4caf354063cd0b1c1282164b973f1a8b3ca03" translate="yes" xml:space="preserve">
          <source>it as though it were a two-dimensional one. This is actually the way almost all C multidimensional arrays work as well.</source>
          <target state="translated">的方式,就好像它是一个二维的一样。这其实也是几乎所有C语言多维数组的工作方式。</target>
        </trans-unit>
        <trans-unit id="61d4d6f86f6911f9c0b355a4b638b81c72da1544" translate="yes" xml:space="preserve">
          <source>it depends</source>
          <target state="translated">看情况</target>
        </trans-unit>
        <trans-unit id="e9ed3745b6da2ff65c1330a469e0e606269e1aea" translate="yes" xml:space="preserve">
          <source>it does any key lookups. Anything more complicated than a simple scalar variable must use methods 2 or 3 below. However, a &quot;simple scalar&quot; includes an identifier that itself uses method 1 recursively. Therefore, the following prints &quot;howdy&quot;.</source>
          <target state="translated">它进行任何键的查找。任何比简单标量变量更复杂的东西都必须使用下面的方法2或3。然而,&quot;简单标量 &quot;包括一个标识符,它本身也会递归地使用方法1。因此,下面打印的是 &quot;你好&quot;。</target>
        </trans-unit>
        <trans-unit id="ba8e66e3faac8aa41508246830eac4c0ce1367d9" translate="yes" xml:space="preserve">
          <source>it does.</source>
          <target state="translated">确实如此。</target>
        </trans-unit>
        <trans-unit id="0586fd2e9ea179909692618fde703704590b2778" translate="yes" xml:space="preserve">
          <source>it doesn't make sense for &lt;code&gt;$result&lt;/code&gt; to be tainted.</source>
          <target state="translated">&lt;code&gt;$result&lt;/code&gt; 被污染是没有意义的。</target>
        </trans-unit>
        <trans-unit id="67860f13d2c0675d8e22bfdbbcae1da9fb06bf2d" translate="yes" xml:space="preserve">
          <source>it has been determined whether or not it is part of a POD paragraph). The parameter &lt;code&gt;$text&lt;/code&gt; is the input line; and the parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number of the corresponding text line.</source>
          <target state="translated">确定它是否是POD段落的一部分）。参数 &lt;code&gt;$text&lt;/code&gt; 是输入行；参数 &lt;code&gt;$line_num&lt;/code&gt; 是相应文本行的行号。</target>
        </trans-unit>
        <trans-unit id="3870d4bae6a615c7d0c3110b61ef4d9f15473beb" translate="yes" xml:space="preserve">
          <source>it has no prototype (&lt;code&gt;PROTOTYPE&lt;/code&gt; field is missing).</source>
          <target state="translated">它没有原型（缺少 &lt;code&gt;PROTOTYPE&lt;/code&gt; 字段）。</target>
        </trans-unit>
        <trans-unit id="1690d6efd12aa7c091debf143ad3278ea0ef7e39" translate="yes" xml:space="preserve">
          <source>it is executed directly instead of via your system's command shell (see below).</source>
          <target state="translated">它是直接执行的,而不是通过你的系统命令shell(见下文)。</target>
        </trans-unit>
        <trans-unit id="0c696ff0d66734bc1af537a36f453902c087a5ec" translate="yes" xml:space="preserve">
          <source>it is implemented, they just need to know</source>
          <target state="translated">落实,他们只需要知道</target>
        </trans-unit>
        <trans-unit id="5aff30627b547c2a01a9bb55f014f8a4f50a64aa" translate="yes" xml:space="preserve">
          <source>it is necessary to make a note of their addresses--thus the two variables &lt;code&gt;sva&lt;/code&gt; and &lt;code&gt;svb&lt;/code&gt; .</source>
          <target state="translated">有必要记下它们的地址-因此这两个变量 &lt;code&gt;sva&lt;/code&gt; 和 &lt;code&gt;svb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e9959c9fffd7b05f3976705116788c5f70c5388" translate="yes" xml:space="preserve">
          <source>it is necessary to use either this:</source>
          <target state="translated">有必要使用这两种方式。</target>
        </trans-unit>
        <trans-unit id="310129d7662f2f9acf2e335aff9582946ee14a1c" translate="yes" xml:space="preserve">
          <source>it is not currently executed (see &lt;code&gt;DEPTH&lt;/code&gt; );</source>
          <target state="translated">当前未执行（请参阅 &lt;code&gt;DEPTH&lt;/code&gt; ）；</target>
        </trans-unit>
        <trans-unit id="0a9795eca7a07fa1ec5f54c4aca84e9b6ddd94be" translate="yes" xml:space="preserve">
          <source>it is probably because your LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). The reason this causes a problem is quite subtle. The file libdl.so.1.0 actually *only* contains functions which generate 'stub interception failed' errors! The runtime linker intercepts links to &quot;/usr/lib/libdl.so.1.0&quot; and links in internal implementations of those functions instead. [Thanks to Tim Bunce for this explanation.]</source>
          <target state="translated">可能是因为你的 LD_LIBRARY_PATH 环境变量包含了一个指向 /usr/lib 的目录 (例如 /lib)。这导致问题的原因很微妙。libdl.so.1.0文件实际上只包含了会产生 &quot;stub拦截失败 &quot;错误的函数!运行时链接器拦截了链接。运行时链接器拦截到&quot;/usr/lib/libdl.so.1.0 &quot;的链接,并将这些函数的内部实现链接进来。[感谢Tim Bunce的解释]</target>
        </trans-unit>
        <trans-unit id="612612823271c4dd6d5f3ffd06e4c196c2f4cc3b" translate="yes" xml:space="preserve">
          <source>it is the parser who called the handler. The second line will print backtrace and die if &lt;code&gt;Carp&lt;/code&gt; was available. The third line will be executed only if &lt;code&gt;Carp&lt;/code&gt; was not available.</source>
          <target state="translated">解析器调用了处理程序。如果 &lt;code&gt;Carp&lt;/code&gt; 可用，第二行将打印回溯记录并死亡。仅当 &lt;code&gt;Carp&lt;/code&gt; 不可用时，才会执行第三行。</target>
        </trans-unit>
        <trans-unit id="b58c9409bf16cf04174e7afa22fe71b231a9b517" translate="yes" xml:space="preserve">
          <source>it means you need to (re)run the</source>
          <target state="translated">这意味着你需要(重新)运行的是</target>
        </trans-unit>
        <trans-unit id="8f446b862762106f931a1429d6239d02e83adc85" translate="yes" xml:space="preserve">
          <source>it prints two lines of output, a perhaps more useful outcome.</source>
          <target state="translated">它打印两行输出,也许是一个更有用的结果。</target>
        </trans-unit>
        <trans-unit id="3a6a63104db0674a31400a90bd3f6dedc040f2d3" translate="yes" xml:space="preserve">
          <source>it really means</source>
          <target state="translated">真意</target>
        </trans-unit>
        <trans-unit id="13fd5928c332d6966fcfc1b3936835e1f2fdd3ce" translate="yes" xml:space="preserve">
          <source>it should match, we would use the &lt;b&gt;anchor&lt;/b&gt; metacharacters &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; . The anchor &lt;code&gt;^&lt;/code&gt; means match at the beginning of the string and the anchor &lt;code&gt;$&lt;/code&gt; means match at the end of the string, or before a newline at the end of the string. Some examples:</source>
          <target state="translated">它应该匹配，我们将使用&lt;b&gt;锚&lt;/b&gt;元字符 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 。锚 &lt;code&gt;^&lt;/code&gt; 表示在字符串的开头匹配，锚 &lt;code&gt;$&lt;/code&gt; 表示在字符串的末尾匹配，或者在字符串的末尾在换行符之前。一些例子：</target>
        </trans-unit>
        <trans-unit id="e296f0161e64279421db490742dbd931d8bc8114" translate="yes" xml:space="preserve">
          <source>it uses.</source>
          <target state="translated">它使用的。</target>
        </trans-unit>
        <trans-unit id="9740d8c8a2509877b0874f04a9fb40b6504cad81" translate="yes" xml:space="preserve">
          <source>it was given. There are a few types of Iterators available by default, all sub-classes of &lt;a href=&quot;parser/iterator&quot;&gt;TAP::Parser::Iterator&lt;/a&gt;. Choosing which iterator to use is the responsibility of the</source>
          <target state="translated">它被给予。默认情况下，有几种类型的迭代器可用，即&lt;a href=&quot;parser/iterator&quot;&gt;TAP :: Parser :: Iterator的&lt;/a&gt;所有子类。选择使用哪个迭代器是</target>
        </trans-unit>
        <trans-unit id="90f05049b267c672ac20306b59373a3c6dd17d68" translate="yes" xml:space="preserve">
          <source>it will be opened for reading. Likewise, the second argument will be written to. If the second argument does not exist but the parent directory does exist, then it will be created. Trying to copy a file into a non-existent directory is an error. Trying to copy a file on top of itself is also an error. &lt;code&gt;copy&lt;/code&gt; will not overwrite read-only files.</source>
          <target state="translated">它将打开以供阅读。同样，第二个参数将被写入。如果第二个参数不存在，但父目录确实存在，则将创建它。尝试将文件复制到不存在的目录是一个错误。尝试在自身之上复制文件也是一个错误。 &lt;code&gt;copy&lt;/code&gt; 不会覆盖只读文件。</target>
        </trans-unit>
        <trans-unit id="85077e36260e1c964f3bb3d589eff39a4e93a0b6" translate="yes" xml:space="preserve">
          <source>it will still be a gv.</source>
          <target state="translated">它将仍然是一个GV。</target>
        </trans-unit>
        <trans-unit id="25c14feb4e8e18138f532db9509b63ad8f630a23" translate="yes" xml:space="preserve">
          <source>it would be better to keep a hash around like %USER_VARS and have variable references actually refer to entries in that hash:</source>
          <target state="translated">最好是保留一个像%USER_VARS这样的哈希值,并且让变量引用实际指向这个哈希值中的条目。</target>
        </trans-unit>
        <trans-unit id="e5c94463c2fd1216a37265c6eb1ebb573441081f" translate="yes" xml:space="preserve">
          <source>it).</source>
          <target state="translated">it).</target>
        </trans-unit>
        <trans-unit id="7ab962e80665cb9cc68421c37b838570afc27fae" translate="yes" xml:space="preserve">
          <source>it.</source>
          <target state="translated">it.</target>
        </trans-unit>
        <trans-unit id="0a0be36bcf81cae54b4e92e27a7da272f28892ba" translate="yes" xml:space="preserve">
          <source>it; and it also doubles as a note about why it's being skipped. So in the first codeblock above, read the code as &quot;skip if MSWin -- (otherwise) test whether &lt;code&gt;thing($foo)&lt;/code&gt; is &lt;code&gt;thing($bar)&lt;/code&gt; &quot; or for the second case, &quot;skip unless MSWin...&quot;.</source>
          <target state="translated">它; 并且还可以作为为什么被跳过的注释。因此，在上面的第一个代码块中，将代码读取为&amp;ldquo;如果跳过MSWin，则跳过-（否则）测试 &lt;code&gt;thing($foo)&lt;/code&gt; 是 &lt;code&gt;thing($bar)&lt;/code&gt; &amp;rdquo;；对于第二种情况，则为&amp;ldquo;跳过，除非MSWin ...&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="90665ca6c8810138a69c5d8421143bbaa3be9fa1" translate="yes" xml:space="preserve">
          <source>italic</source>
          <target state="translated">italic</target>
        </trans-unit>
        <trans-unit id="939d66a4b75f040c931e31b7a89333e45cd668cc" translate="yes" xml:space="preserve">
          <source>iterate</source>
          <target state="translated">iterate</target>
        </trans-unit>
        <trans-unit id="bef4aaaa11015ef79d88f3701f4c69ad690eb4c7" translate="yes" xml:space="preserve">
          <source>iterator</source>
          <target state="translated">iterator</target>
        </trans-unit>
        <trans-unit id="4131f600eefaae3bd0bdca31fdfbd0ee66fd34df" translate="yes" xml:space="preserve">
          <source>iterator factory</source>
          <target state="translated">迭代器工厂</target>
        </trans-unit>
        <trans-unit id="3bdff15b39ed0956a3ac055e7cb35e717df3ac4f" translate="yes" xml:space="preserve">
          <source>iterators</source>
          <target state="translated">iterators</target>
        </trans-unit>
        <trans-unit id="02b745e9b5e2fad4405c0c56805599232ff0da14" translate="yes" xml:space="preserve">
          <source>ithreads</source>
          <target state="translated">ithreads</target>
        </trans-unit>
        <trans-unit id="729ee8658c32bfd976df663131e9d855fadb0bd2" translate="yes" xml:space="preserve">
          <source>its parent classes are called (in depth-first, left-to-right order).</source>
          <target state="translated">它的父类被调用(按深度优先、从左到右的顺序)。</target>
        </trans-unit>
        <trans-unit id="81f3fb4eaedb1a632822e8e071eaf79b0daa2a96" translate="yes" xml:space="preserve">
          <source>itself is perfectly fine and probably best to quote from, provided you can find a suitable quote there.</source>
          <target state="translated">本身是完全可以的,可能是最好的报价,只要你能在那里找到合适的报价。</target>
        </trans-unit>
        <trans-unit id="a6597c4b9bc3a39747ccb10ba2dc28b25654f99e" translate="yes" xml:space="preserve">
          <source>itself, or the UNIX error message when it is not (i.e.</source>
          <target state="translated">本身,或者当它不是UNIX错误信息时(即</target>
        </trans-unit>
        <trans-unit id="a448ee962c26966eb9ffb37083bad9b8255c68a0" translate="yes" xml:space="preserve">
          <source>itself. &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; was made available for hashes, and weak references now call uvar &lt;code&gt;get&lt;/code&gt; magic after a weakref has been cleared. The first feature is used to make field hashes intercept their keys upon access. The second one triggers garbage collection.</source>
          <target state="translated">本身。 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 可用于散列，弱引用现在称为uvar，在弱引用被清除后 &lt;code&gt;get&lt;/code&gt; 变魔术。第一个功能用于使字段哈希在访问时拦截其密钥。第二个触发垃圾回收。</target>
        </trans-unit>
        <trans-unit id="9080b7d46b4fc0390c228c28d01f17857e481e91" translate="yes" xml:space="preserve">
          <source>itself. This implements standard prototype processing. It can be changed, for a particular subroutine, by &lt;a href=&quot;#cv_set_call_checker&quot;&gt;cv_set_call_checker&lt;/a&gt;.</source>
          <target state="translated">本身。这实现了标准原型处理。对于特定的子例程，可以通过&lt;a href=&quot;#cv_set_call_checker&quot;&gt;cv_set_call_checker&lt;/a&gt;进行更改。</target>
        </trans-unit>
        <trans-unit id="e65c84ea5ae8f9cb5f144e8560472c4a38ee73a9" translate="yes" xml:space="preserve">
          <source>itself: &lt;code&gt;NaN&lt;/code&gt; != &lt;code&gt;NaN&lt;/code&gt; .</source>
          <target state="translated">本身： &lt;code&gt;NaN&lt;/code&gt; ！= &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e42ca91c60743cbedfdb7a86d0e6ca643050fa2" translate="yes" xml:space="preserve">
          <source>itself; you'll need some other means, (like &lt;a href=&quot;#charprop()&quot;&gt;charprop()&lt;/a&gt; or &lt;a href=&quot;#casespec()&quot;&gt;casespec()&lt;/a&gt; to get the full mapping.</source>
          <target state="translated">本身; 您将需要其他一些方法（例如&lt;a href=&quot;#charprop()&quot;&gt;charprop（）&lt;/a&gt;或&lt;a href=&quot;#casespec()&quot;&gt;casespec（））&lt;/a&gt;来获取完整的映射。</target>
        </trans-unit>
        <trans-unit id="5c2dd944dde9e08881bef0894fe7b22a5c9c4b06" translate="yes" xml:space="preserve">
          <source>j</source>
          <target state="translated">j</target>
        </trans-unit>
        <trans-unit id="ccb3219ddb6265babc86f9f9b3767241cd3c266d" translate="yes" xml:space="preserve">
          <source>jhi!at!iki.fi</source>
          <target state="translated">jhi!at!iki.fi</target>
        </trans-unit>
        <trans-unit id="89bd3e10c41e1404acf15c04b11b8f2b9abbc72b" translate="yes" xml:space="preserve">
          <source>jhi@iki.fi</source>
          <target state="translated">jhi@iki.fi</target>
        </trans-unit>
        <trans-unit id="b8c394cc17419bc3809e014896111af95fe7d3a9" translate="yes" xml:space="preserve">
          <source>job to watch CPAN, you could list all modules that need updating. First a quick and dirty way:</source>
          <target state="translated">工作来观察CPAN,你可以列出所有需要更新的模块。先来个快刀斩乱麻的方法。</target>
        </trans-unit>
        <trans-unit id="c455b38e076228392d1c751d14fe95da50519334" translate="yes" xml:space="preserve">
          <source>join</source>
          <target state="translated">join</target>
        </trans-unit>
        <trans-unit id="5f399a3111bea0589bf7db3e0dfaba80af64407b" translate="yes" xml:space="preserve">
          <source>join EXPR,LIST</source>
          <target state="translated">加入EXPR,LIST</target>
        </trans-unit>
        <trans-unit id="62d2c6aa803cca4cf9c65aa3e227bf0b61706b76" translate="yes" xml:space="preserve">
          <source>join is the same as catfile.</source>
          <target state="translated">join和catfile是一样的。</target>
        </trans-unit>
        <trans-unit id="ca46fff3e67ab1620d4b1bde0a7edc21da9ca6b3" translate="yes" xml:space="preserve">
          <source>json_backend</source>
          <target state="translated">json_backend</target>
        </trans-unit>
        <trans-unit id="d95b79cfc988b3b165ceb830a9c8932d1b52cf18" translate="yes" xml:space="preserve">
          <source>just</source>
          <target state="translated">just</target>
        </trans-unit>
        <trans-unit id="eb0fc5922423716c9914d354f8212f007cc1f6ca" translate="yes" xml:space="preserve">
          <source>just like perl itself:</source>
          <target state="translated">就像perl本身一样。</target>
        </trans-unit>
        <trans-unit id="f9d5ea726b7acb7a642a990df1dd7b92e603dab0" translate="yes" xml:space="preserve">
          <source>just the inverse of &lt;code&gt;:crlf&lt;/code&gt; : other layers which would affect the binary nature of the stream are also removed or disabled.</source>
          <target state="translated">只是 &lt;code&gt;:crlf&lt;/code&gt; 的反面：其他会影响流的二进制性质的层也将被删除或禁用。</target>
        </trans-unit>
        <trans-unit id="13fbd79c3d390e5d6585a21e11ff5ec1970cff0c" translate="yes" xml:space="preserve">
          <source>k</source>
          <target state="translated">k</target>
        </trans-unit>
        <trans-unit id="725ad17778a9ca9c4dcb68f53d1af1a0f509df54" translate="yes" xml:space="preserve">
          <source>k*pi/n</source>
          <target state="translated">k*pi/n</target>
        </trans-unit>
        <trans-unit id="a62f2225bf70bfaccbc7f1ef2a397836717377de" translate="yes" xml:space="preserve">
          <source>key</source>
          <target state="translated">key</target>
        </trans-unit>
        <trans-unit id="e2929051408c4d0d174e1354d7182008186218cd" translate="yes" xml:space="preserve">
          <source>key replacement</source>
          <target state="translated">更换钥匙</target>
        </trans-unit>
        <trans-unit id="0ec928f0548a391077ef8e978657769f625ace95" translate="yes" xml:space="preserve">
          <source>keylen</source>
          <target state="translated">keylen</target>
        </trans-unit>
        <trans-unit id="a9d95efcc011e377892f55ea4ef1cf8af1bde1da" translate="yes" xml:space="preserve">
          <source>keypv</source>
          <target state="translated">keypv</target>
        </trans-unit>
        <trans-unit id="5944ae25418ceabcf285dca1d721b77888dac89b" translate="yes" xml:space="preserve">
          <source>keys</source>
          <target state="translated">keys</target>
        </trans-unit>
        <trans-unit id="163ff7ee9e20183b56bf466efd2816a9b2392c0c" translate="yes" xml:space="preserve">
          <source>keys ARRAY</source>
          <target state="translated">钥匙ARRAY</target>
        </trans-unit>
        <trans-unit id="63c866479b55938ab0686f9368e0bdc3b1e2f798" translate="yes" xml:space="preserve">
          <source>keys EXPR</source>
          <target state="translated">钥匙</target>
        </trans-unit>
        <trans-unit id="a39fdcb0ec2b35fbb1b985ec7492d546a128c563" translate="yes" xml:space="preserve">
          <source>keys HASH</source>
          <target state="translated">钥匙</target>
        </trans-unit>
        <trans-unit id="4401f84be4185188a39d2f59b42a57a00108ee4e" translate="yes" xml:space="preserve">
          <source>keys and values are NULL terminated. Unfortunately when Perl writes to DBM databases it doesn't use NULL termination, so your Perl application will have to manage NULL termination itself. When you write to the database you will have to use something like this:</source>
          <target state="translated">键和值都是NULL终止的。不幸的是,当Perl向DBM数据库写入数据时,它并不使用NULL终止,所以你的Perl应用程序将不得不自己管理NULL终止。当你写到数据库时,你将不得不使用类似这样的东西。</target>
        </trans-unit>
        <trans-unit id="0a2a3d72597603ea8cff70de3f7051f49cb67f9f" translate="yes" xml:space="preserve">
          <source>keys and values.</source>
          <target state="translated">键和值。</target>
        </trans-unit>
        <trans-unit id="6589889c96d31e938e419098b015444a16a2c3a2" translate="yes" xml:space="preserve">
          <source>kflags</source>
          <target state="translated">kflags</target>
        </trans-unit>
        <trans-unit id="c80f5bc166cd6739ba9ba6d94acabc0aa01494da" translate="yes" xml:space="preserve">
          <source>kill</source>
          <target state="translated">kill</target>
        </trans-unit>
        <trans-unit id="a4bc7bbb272a294f330eb938da9fb51c2fcc02c3" translate="yes" xml:space="preserve">
          <source>kill SIGNAL</source>
          <target state="translated">杀死SIGNAL</target>
        </trans-unit>
        <trans-unit id="504bcebca3affd57921d61d9a779cae627657943" translate="yes" xml:space="preserve">
          <source>kill SIGNAL, LIST</source>
          <target state="translated">Kill SIGNAL,LIST</target>
        </trans-unit>
        <trans-unit id="23b08d7df16abcdad774dace7145903fd2c37725" translate="yes" xml:space="preserve">
          <source>kill(3)</source>
          <target state="translated">kill(3)</target>
        </trans-unit>
        <trans-unit id="8c834f073d4d1ae81525a98626e15bf01e8a71bd" translate="yes" xml:space="preserve">
          <source>kind of session by using the arguments &lt;code&gt;/fs&lt;/code&gt;, &lt;code&gt;/pm&lt;/code&gt; or &lt;code&gt;/win&lt;/code&gt; switches of the command &lt;code&gt;start&lt;/code&gt; (of</source>
          <target state="translated">通过使用命令 &lt;code&gt;start&lt;/code&gt; （of的 &lt;code&gt;/fs&lt;/code&gt; ， &lt;code&gt;/pm&lt;/code&gt; 或 &lt;code&gt;/win&lt;/code&gt; 开关的参数进行的会话类型</target>
        </trans-unit>
        <trans-unit id="97accafb53377fd569bc568d3ffe8da985a568ef" translate="yes" xml:space="preserve">
          <source>know</source>
          <target state="translated">know</target>
        </trans-unit>
        <trans-unit id="dd21e4f392e3c1d0f7571bd4b34164706b1a24c3" translate="yes" xml:space="preserve">
          <source>know with absolute certainty</source>
          <target state="translated">确知</target>
        </trans-unit>
        <trans-unit id="263c649e2937afe094a801dc2f1f8ff91cdebe67" translate="yes" xml:space="preserve">
          <source>known_to_exist</source>
          <target state="translated">known_to_exist</target>
        </trans-unit>
        <trans-unit id="4a8d3339c1aceb6e28d45d54ff0a8e537fcb31e8" translate="yes" xml:space="preserve">
          <source>ksh527rt.zip</source>
          <target state="translated">ksh527rt.zip</target>
        </trans-unit>
        <trans-unit id="07c342be6e560e7f43842e2e21b774e61d85f047" translate="yes" xml:space="preserve">
          <source>l</source>
          <target state="translated">l</target>
        </trans-unit>
        <trans-unit id="64c65374dbab6fe3762748196d9d3a9610e2e5a9" translate="yes" xml:space="preserve">
          <source>label</source>
          <target state="translated">label</target>
        </trans-unit>
        <trans-unit id="d6658a9defae77f1757cb09d67b818757cd24486" translate="yes" xml:space="preserve">
          <source>lack</source>
          <target state="translated">lack</target>
        </trans-unit>
        <trans-unit id="ff1aba81fe7b089d82562a718b3ef9c7213d6698" translate="yes" xml:space="preserve">
          <source>langinfo(3)</source>
          <target state="translated">langinfo(3)</target>
        </trans-unit>
        <trans-unit id="931a14650ec8c7a040f2eefd85a897f9590dc3c8" translate="yes" xml:space="preserve">
          <source>langinfo.h</source>
          <target state="translated">langinfo.h</target>
        </trans-unit>
        <trans-unit id="e11523c5ff23fc1600aca2d8ee5adb542c5ce4b3" translate="yes" xml:space="preserve">
          <source>language</source>
          <target state="translated">language</target>
        </trans-unit>
        <trans-unit id="07fd754169cbc14f32d8424ed7ff8efb4e828cf8" translate="yes" xml:space="preserve">
          <source>language code</source>
          <target state="translated">语码</target>
        </trans-unit>
        <trans-unit id="71d7102c1da6fbbced9f583db6704477f11ced56" translate="yes" xml:space="preserve">
          <source>language_territory</source>
          <target state="translated">language_territory</target>
        </trans-unit>
        <trans-unit id="0265a28be8ae180d9d231879cc522733ad7d4408" translate="yes" xml:space="preserve">
          <source>languages</source>
          <target state="translated">languages</target>
        </trans-unit>
        <trans-unit id="2f1e0b0dc470f71151ce6738e9f7be38a0687dde" translate="yes" xml:space="preserve">
          <source>large enough to take one return value.</source>
          <target state="translated">大到可以取一个返回值。</target>
        </trans-unit>
        <trans-unit id="741ba1f0f1533ece02fff2b65d8dc483692f9691" translate="yes" xml:space="preserve">
          <source>larry (at) wall.org</source>
          <target state="translated">larry (at)wall.org</target>
        </trans-unit>
        <trans-unit id="213ed3ea453bf610688ff8041e0a3b7b6abb5e6e" translate="yes" xml:space="preserve">
          <source>last</source>
          <target state="translated">last</target>
        </trans-unit>
        <trans-unit id="b30b6273b59dad174d1c29542b336882ec42ce47" translate="yes" xml:space="preserve">
          <source>last EXPR</source>
          <target state="translated">最后一个EXPR</target>
        </trans-unit>
        <trans-unit id="8d3bc2f9e8b72940971c417ffcb4831427b7f071" translate="yes" xml:space="preserve">
          <source>last LABEL</source>
          <target state="translated">最后一个标签</target>
        </trans-unit>
        <trans-unit id="6fbebf65db8c9e119786b6069e55d8a57449239d" translate="yes" xml:space="preserve">
          <source>last successful match</source>
          <target state="translated">最后一场成功的比赛</target>
        </trans-unit>
        <trans-unit id="6fc4291b99bc40e0a1e6058f237b9032e2a2cb98" translate="yes" xml:space="preserve">
          <source>last_error()</source>
          <target state="translated">last_error()</target>
        </trans-unit>
        <trans-unit id="5f4c3aef2b495c636e2cc379a207951285dc8022" translate="yes" xml:space="preserve">
          <source>laszlo.molnar@eth.ericsson.se</source>
          <target state="translated">laszlo.molnar@eth.ericsson.se</target>
        </trans-unit>
        <trans-unit id="d54c2aa2f61603022c71493f093f0c718419ca13" translate="yes" xml:space="preserve">
          <source>layer</source>
          <target state="translated">layer</target>
        </trans-unit>
        <trans-unit id="388d8a5d86f4ff95a659c127ad269f1e2328643c" translate="yes" xml:space="preserve">
          <source>layer uses native &quot;handle&quot; IO rather than a Unix-like numeric file descriptor layer. Known to be buggy in this release (5.14).</source>
          <target state="translated">层使用原生的 &quot;handle &quot;IO,而不是类似Unix的数字文件描述符层。已知此版本(5.14)存在bug。</target>
        </trans-unit>
        <trans-unit id="9f422a843a976db035a8ac6578fed83f92e8401c" translate="yes" xml:space="preserve">
          <source>layer uses the native &quot;handle&quot; IO rather than the unix-like numeric file descriptor layer. Known to be buggy as of perl 5.8.2.</source>
          <target state="translated">层使用原生的 &quot;handle &quot;IO,而不是类似unix的数字文件描述符层。从perl 5.8.2开始,已经知道有bug。</target>
        </trans-unit>
        <trans-unit id="668165d561c62f330e96b629c4cdbaaa6a959900" translate="yes" xml:space="preserve">
          <source>layers</source>
          <target state="translated">layers</target>
        </trans-unit>
        <trans-unit id="7a01ac075bef9978a02e0d617581075e7ef656ff" translate="yes" xml:space="preserve">
          <source>lc</source>
          <target state="translated">lc</target>
        </trans-unit>
        <trans-unit id="981c93d3cfc093341a5e23cfb2960d27a0bd9b18" translate="yes" xml:space="preserve">
          <source>lc EXPR</source>
          <target state="translated">lc EXPR</target>
        </trans-unit>
        <trans-unit id="03dac16c5a7ea4584e45233fb1fe739d834da705" translate="yes" xml:space="preserve">
          <source>lcfirst</source>
          <target state="translated">lcfirst</target>
        </trans-unit>
        <trans-unit id="4bf10c7c0cf1b946d82e323d34632248cbe61a5a" translate="yes" xml:space="preserve">
          <source>lcfirst EXPR</source>
          <target state="translated">lcfirst EXPR</target>
        </trans-unit>
        <trans-unit id="b9a7e2303793d6c9a795bf7a60a5c58ebb7bae1d" translate="yes" xml:space="preserve">
          <source>ld.script</source>
          <target state="translated">ld.script</target>
        </trans-unit>
        <trans-unit id="593b743b207e10ff55ec63e71a46c07909d0880a" translate="yes" xml:space="preserve">
          <source>le</source>
          <target state="translated">le</target>
        </trans-unit>
        <trans-unit id="2543258632dcde1c9dda11f400265f9020598acd" translate="yes" xml:space="preserve">
          <source>leaves drive as it is.</source>
          <target state="translated">离开驱动器,因为它是。</target>
        </trans-unit>
        <trans-unit id="bee3025990c10dd732e7c46a8b2b715a1dcda3b5" translate="yes" xml:space="preserve">
          <source>leaves the &lt;code&gt;%hash&lt;/code&gt; empty rather than with its original contents.</source>
          <target state="translated">将 &lt;code&gt;%hash&lt;/code&gt; 保留为空，而不保留其原始内容。</target>
        </trans-unit>
        <trans-unit id="12c0f1fbadc4046b5f2bb9e063b227ef8750d9d6" translate="yes" xml:space="preserve">
          <source>left</source>
          <target state="translated">left</target>
        </trans-unit>
        <trans-unit id="4737fa4317b3dbfbe0793f4d77a61ff4da1af746" translate="yes" xml:space="preserve">
          <source>leftmost</source>
          <target state="translated">leftmost</target>
        </trans-unit>
        <trans-unit id="2f936e05c77962997bd534a0c03a5b28d0a9e6e7" translate="yes" xml:space="preserve">
          <source>legitimately return &lt;code&gt;-1&lt;/code&gt; . The proper way to handle such calls is to assign &lt;code&gt;$!=0&lt;/code&gt; before the call, then check the value of &lt;code&gt;$!&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; .</source>
          <target state="translated">合法地返回 &lt;code&gt;-1&lt;/code&gt; 。处理此类调用的正确方法是在调用之前分配 &lt;code&gt;$!=0&lt;/code&gt; ，然后检查 &lt;code&gt;$!&lt;/code&gt; 的值。如果 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2fb3cd5ef7f4ba25ee7e799860a861432c55551d" translate="yes" xml:space="preserve">
          <source>legitimately return &lt;code&gt;-1&lt;/code&gt; . The proper way to handle such calls is to assign &lt;code&gt;$!=0&lt;/code&gt; before the call, then check the value of &lt;code&gt;$!&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; .</source>
          <target state="translated">合法地返回 &lt;code&gt;-1&lt;/code&gt; 。处理此类调用的正确方法是在调用之前分配 &lt;code&gt;$!=0&lt;/code&gt; ，然后检查 &lt;code&gt;$!&lt;/code&gt; 的值。如果 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a573b540d2dde90ba6da3b9d6286c8ec60c10044" translate="yes" xml:space="preserve">
          <source>len</source>
          <target state="translated">len</target>
        </trans-unit>
        <trans-unit id="3d54973f528b01019a58a52d34d518405a01b891" translate="yes" xml:space="preserve">
          <source>length</source>
          <target state="translated">length</target>
        </trans-unit>
        <trans-unit id="53200d1265f64527de5997006b46bed16c623ba8" translate="yes" xml:space="preserve">
          <source>length EXPR</source>
          <target state="translated">长度EXPR</target>
        </trans-unit>
        <trans-unit id="12126f713e2c6e2b378ad7286a6bc4fa4da0d2f3" translate="yes" xml:space="preserve">
          <source>length()</source>
          <target state="translated">length()</target>
        </trans-unit>
        <trans-unit id="17ad2831729fd442f864db7688784dfbf7955cba" translate="yes" xml:space="preserve">
          <source>length-item</source>
          <target state="translated">length-item</target>
        </trans-unit>
        <trans-unit id="0b439cf4e10f87567e60f4b7818ecd57383dc7f0" translate="yes" xml:space="preserve">
          <source>less</source>
          <target state="translated">less</target>
        </trans-unit>
        <trans-unit id="78efad5671f5e78b02faa6a4a581a424dceb0730" translate="yes" xml:space="preserve">
          <source>less - perl pragma to request less of something</source>
          <target state="translated">less-perl pragma,用于请求减少某些东西的数量</target>
        </trans-unit>
        <trans-unit id="02f3496dc7765194620a1d6fcb556b38dd666197" translate="yes" xml:space="preserve">
          <source>less time</source>
          <target state="translated">少时间</target>
        </trans-unit>
        <trans-unit id="4c213394c05bbaa2e6986dee2a278be573c9f3eb" translate="yes" xml:space="preserve">
          <source>less(1) manpage</source>
          <target state="translated">少了(1)页</target>
        </trans-unit>
        <trans-unit id="111d45df9732173914935953b636771bd1fe2f90" translate="yes" xml:space="preserve">
          <source>lets us evaluate individual Perl strings, and then extract variables for coercion into C types. The following program,</source>
          <target state="translated">让我们可以评估单个的Perl字符串,然后将变量提取为C类型的胁迫变量。下面的程序。</target>
        </trans-unit>
        <trans-unit id="ad60c535ff88e85bf0254452fe3934f24e9668d5" translate="yes" xml:space="preserve">
          <source>level</source>
          <target state="translated">level</target>
        </trans-unit>
        <trans-unit id="bb1350a57d9ad1cedc41dbe6c123e723b0969cc3" translate="yes" xml:space="preserve">
          <source>level &lt;code&gt;PerlIO *&lt;/code&gt; is a pointer to a &lt;code&gt;PerlIOl *&lt;/code&gt; - i.e. a pointer to a pointer to the struct. This allows the application level &lt;code&gt;PerlIO *&lt;/code&gt; to remain constant while the actual &lt;code&gt;PerlIOl *&lt;/code&gt; underneath changes. (Compare perl's &lt;code&gt;SV *&lt;/code&gt; which remains constant while its &lt;code&gt;sv_any&lt;/code&gt; field changes as the scalar's type changes.) An IO stream is then in general represented as a pointer to this linked-list of &quot;layers&quot;.</source>
          <target state="translated">水平 &lt;code&gt;PerlIO *&lt;/code&gt; 是一个指向 &lt;code&gt;PerlIOl *&lt;/code&gt; -即指针的指针结构。这允许应用程序级别 &lt;code&gt;PerlIO *&lt;/code&gt; 保持不变，而实际的 &lt;code&gt;PerlIOl *&lt;/code&gt; 却在变化。（比较perl的 &lt;code&gt;SV *&lt;/code&gt; ，它的 &lt;code&gt;sv_any&lt;/code&gt; 字段随标量类型的变化而保持不变。）然后，通常将IO流表示为指向此&amp;ldquo;层&amp;rdquo;链接列表的指针。</target>
        </trans-unit>
        <trans-unit id="6a34b2d4b71d3ddc27cc52fb35135ac1c5dbe44f" translate="yes" xml:space="preserve">
          <source>level. &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock(\$a)&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock($a)&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock(\\$a)&lt;/a&gt;&lt;/code&gt; is not.</source>
          <target state="translated">水平。 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock(\$a)&lt;/a&gt;&lt;/code&gt; 等价于 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock($a)&lt;/a&gt;&lt;/code&gt; ，而 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock(\\$a)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="743e8359279cf7f0547f8ae5b735a7cf348aa31e" translate="yes" xml:space="preserve">
          <source>level:</source>
          <target state="translated">level:</target>
        </trans-unit>
        <trans-unit id="f560237bb64a4ed60f6ec30a321ae364eeccfc8d" translate="yes" xml:space="preserve">
          <source>levels deep, as if the &lt;code&gt;dumpDepth&lt;/code&gt; option had been temporarily set to</source>
          <target state="translated">级别深，好像 &lt;code&gt;dumpDepth&lt;/code&gt; 选项已被临时设置为</target>
        </trans-unit>
        <trans-unit id="87c2760ff0fd836e950d1f3773814e8602f382f6" translate="yes" xml:space="preserve">
          <source>lewart!at!uiuc.edu</source>
          <target state="translated">lewart!at!uiuc.edu</target>
        </trans-unit>
        <trans-unit id="7f9b3be17a93e598368695b2b13dcc4f05f4fa36" translate="yes" xml:space="preserve">
          <source>lexical scope</source>
          <target state="translated">词汇范围</target>
        </trans-unit>
        <trans-unit id="a98b7cb4e1d62107700706f49e9bed1cbf5694db" translate="yes" xml:space="preserve">
          <source>lexical variables created with my(). Typically it would be the first declaration in a file included by the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; operators. You can switch into a package in more than one place; it merely influences which symbol table is used by the compiler for the rest of that block. You can refer to variables and filehandles in other packages by prefixing the identifier with the package name and a double colon: &lt;code&gt;$Package::Variable&lt;/code&gt; . If the package name is null, the &lt;code&gt;main&lt;/code&gt; package is assumed. That is, &lt;code&gt;$::sail&lt;/code&gt; is equivalent to &lt;code&gt;$main::sail&lt;/code&gt; .</source>
          <target state="translated">用my（）创建的词法变量。通常，它是 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 运算符包含的文件中的第一个声明。您可以在多个地方切换到一个包中；它仅影响编译器在该块的其余部分中使用哪个符号表。您可以通过在标识符前面加上软件包名称和双冒号来引用其他软件包中的变量和文件句柄： &lt;code&gt;$Package::Variable&lt;/code&gt; 。如果程序包名称为null，则假定 &lt;code&gt;main&lt;/code&gt; 程序包。也就是说， &lt;code&gt;$::sail&lt;/code&gt; 等效于 &lt;code&gt;$main::sail&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e71249801b330ab4aa5e2053a29f296dbb0e328f" translate="yes" xml:space="preserve">
          <source>lexically-scoped variables, which are created with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;. Typically it would be the first declaration in a file included by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;. You can switch into a package in more than one place, since this only determines which default symbol table the compiler uses for the rest of that block. You can refer to identifiers in other packages than the current one by prefixing the identifier with the package name and a double colon, as in &lt;code&gt;$SomePack::var&lt;/code&gt; or &lt;code&gt;ThatPack::INPUT_HANDLE&lt;/code&gt; . If package name is omitted, the &lt;code&gt;main&lt;/code&gt; package as assumed. That is, &lt;code&gt;$::sail&lt;/code&gt; is equivalent to &lt;code&gt;$main::sail&lt;/code&gt; (as well as to &lt;code&gt;$main'sail&lt;/code&gt; , still seen in ancient code, mostly from Perl 4).</source>
          <target state="translated">词法范围的变量，它们是使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 创建的。通常，它是 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 包含的文件中的第一个声明。您可以在多个位置切换到一个程序包，因为这只能确定编译器对该块其余部分使用哪个默认符号表。您可以通过在标识符前面加上软件包名称和双冒号来引用除当前软件包以外的其他软件包中的标识符，例如 &lt;code&gt;$SomePack::var&lt;/code&gt; 或 &lt;code&gt;ThatPack::INPUT_HANDLE&lt;/code&gt; 。如果省略软件包名称，则假定使用 &lt;code&gt;main&lt;/code&gt; 软件包。也就是说， &lt;code&gt;$::sail&lt;/code&gt; 等效于 &lt;code&gt;$main::sail&lt;/code&gt; （以及 &lt;code&gt;$main'sail&lt;/code&gt; ，仍然在古代代码中常见，主要来自Perl 4）。</target>
        </trans-unit>
        <trans-unit id="3d04adc74c945063bcc590f133adcf214df94a9c" translate="yes" xml:space="preserve">
          <source>lexically-scoped variables, which are created with &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;. Typically it would be the first declaration in a file included by &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;. You can switch into a package in more than one place, since this only determines which default symbol table the compiler uses for the rest of that block. You can refer to identifiers in other packages than the current one by prefixing the identifier with the package name and a double colon, as in &lt;code&gt;$SomePack::var&lt;/code&gt; or &lt;code&gt;ThatPack::INPUT_HANDLE&lt;/code&gt; . If package name is omitted, the &lt;code&gt;main&lt;/code&gt; package as assumed. That is, &lt;code&gt;$::sail&lt;/code&gt; is equivalent to &lt;code&gt;$main::sail&lt;/code&gt; (as well as to &lt;code&gt;$main'sail&lt;/code&gt; , still seen in ancient code, mostly from Perl 4).</source>
          <target state="translated">词法范围的变量，它们是使用 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 创建的。通常，它是 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 包含的文件中的第一个声明。您可以在多个位置切换到一个程序包，因为这只能确定编译器对该块其余部分使用哪个默认符号表。您可以通过在标识符前面加上软件包名称和双冒号来引用除当前软件包以外的其他软件包中的标识符，例如 &lt;code&gt;$SomePack::var&lt;/code&gt; 或 &lt;code&gt;ThatPack::INPUT_HANDLE&lt;/code&gt; 。如果省略软件包名称，则假定使用 &lt;code&gt;main&lt;/code&gt; 软件包。也就是说， &lt;code&gt;$::sail&lt;/code&gt; 等效于 &lt;code&gt;$main::sail&lt;/code&gt; （以及 &lt;code&gt;$main'sail&lt;/code&gt; ，仍然在古代代码中常见，主要来自Perl 4）。</target>
        </trans-unit>
        <trans-unit id="f8df771d8fad6fc4d6a6e0fdcf32235fee4d432f" translate="yes" xml:space="preserve">
          <source>lha -mraxe x perl-$VERSION-bin.lha</source>
          <target state="translated">lha -mrax x perl-$VERSION-bin.lha</target>
        </trans-unit>
        <trans-unit id="9d062bafff17ba8b9a1215c4c51485134d509d91" translate="yes" xml:space="preserve">
          <source>lib</source>
          <target state="translated">lib</target>
        </trans-unit>
        <trans-unit id="b2f1aa4618f8511782e93f2b2456425e658657ba" translate="yes" xml:space="preserve">
          <source>lib - manipulate @INC at compile time</source>
          <target state="translated">lib-在编译时操作@INC。</target>
        </trans-unit>
        <trans-unit id="3e4e355eb6719577404ce98223a2b88d539b0d05" translate="yes" xml:space="preserve">
          <source>lib and lib</source>
          <target state="translated">lib和lib</target>
        </trans-unit>
        <trans-unit id="2f44e7def4cb27180b53a038d394266e50a43a80" translate="yes" xml:space="preserve">
          <source>lib.exe is normally used to build libraries, but link.exe with the /lib option also works, so change win32/config.vc to use it instead:</source>
          <target state="translated">lib.exe通常用于构建库,但带有/lib选项的link.exe也可以使用,所以将win32/config.vc改为使用它。</target>
        </trans-unit>
        <trans-unit id="70070d20d4c6e863f10cb8b6749cc4b4efaf6027" translate="yes" xml:space="preserve">
          <source>lib/</source>
          <target state="translated">lib/</target>
        </trans-unit>
        <trans-unit id="6e588d0eb09843bb85142c36159b59cc3a27a40b" translate="yes" xml:space="preserve">
          <source>lib/Config.pm</source>
          <target state="translated">lib/Config.pm</target>
        </trans-unit>
        <trans-unit id="88d614c0b84efc336051bce3e13eb562d0b8f337" translate="yes" xml:space="preserve">
          <source>lib/ExtUtils</source>
          <target state="translated">lib/ExtUtils</target>
        </trans-unit>
        <trans-unit id="6cb8d15061262831ec39b62c9b20c092a3811f47" translate="yes" xml:space="preserve">
          <source>lib/ExtUtils/typemap</source>
          <target state="translated">lib/ExtUtils/typemap</target>
        </trans-unit>
        <trans-unit id="b5f40c50a611e165a0d206a1e6ef0db737b90e30" translate="yes" xml:space="preserve">
          <source>lib/File.Copy.t</source>
          <target state="translated">lib/File.Copy.t</target>
        </trans-unit>
        <trans-unit id="359125af2199801e53d858f9b4a05dcfff8322c6" translate="yes" xml:space="preserve">
          <source>lib/File/Find/taint.t will complain if '.' is in your PATH. The PATH test is triggered because cwd calls `fullpath -t`.</source>
          <target state="translated">如果'.'在你的PATH中,lib/File/Find/taint.t会抱怨。PATH测试是由于cwd调用 &quot;fullpath -t &quot;而触发的。</target>
        </trans-unit>
        <trans-unit id="90bdcb6812853a7d5bb4ee449e1c2c3938e5b2d9" translate="yes" xml:space="preserve">
          <source>lib/Foo/Bar.pm</source>
          <target state="translated">lib/Foo/Bar.pm</target>
        </trans-unit>
        <trans-unit id="ee16f92d5b61d6587e8d9ccdeea55a375ff6035b" translate="yes" xml:space="preserve">
          <source>lib/Net/Ping/t/450_service.t</source>
          <target state="translated">lib/Net/Ping/t/450_service.t</target>
        </trans-unit>
        <trans-unit id="d42828e03450bbbdcf272afa864cdef4d3a51548" translate="yes" xml:space="preserve">
          <source>lib/Net/Ping/t/510_ping_udp.t</source>
          <target state="translated">lib/Net/Ping/t/510_ping_udp.t</target>
        </trans-unit>
        <trans-unit id="c3d52f60d978ab23a551b74a528a88ef76b18b9a" translate="yes" xml:space="preserve">
          <source>lib/Tie/File/t/09_gen_rs</source>
          <target state="translated">lib/Tie/File/t/09_gen_rs</target>
        </trans-unit>
        <trans-unit id="4c33170bdd26012203a6bd904dd58f36f73a7acd" translate="yes" xml:space="preserve">
          <source>lib/encoding.pm</source>
          <target state="translated">lib/encoding.pm</target>
        </trans-unit>
        <trans-unit id="7c2f483f24dee82ab5e37fd3f7bc02bfb93f9406" translate="yes" xml:space="preserve">
          <source>lib/filehand.t</source>
          <target state="translated">lib/filehand.t</target>
        </trans-unit>
        <trans-unit id="7a322f1fd2b67495d6c867548d84c9ad2bdbe5bf" translate="yes" xml:space="preserve">
          <source>lib/io_pipe.t</source>
          <target state="translated">lib/io_pipe.t</target>
        </trans-unit>
        <trans-unit id="3a9b601afa6c15ad5a349cf79626adae81beecac" translate="yes" xml:space="preserve">
          <source>lib/io_sock.t</source>
          <target state="translated">lib/io_sock.t</target>
        </trans-unit>
        <trans-unit id="825cd0dceebc1d8a0d92ad3966e3ba313c1b1a28" translate="yes" xml:space="preserve">
          <source>lib/lib.pm</source>
          <target state="translated">lib/lib.pm</target>
        </trans-unit>
        <trans-unit id="923b9d7545d00ab27b36e6bb97d33d75634fd485" translate="yes" xml:space="preserve">
          <source>lib/locale</source>
          <target state="translated">lib/locale</target>
        </trans-unit>
        <trans-unit id="0c546992c69ba3886efe8a1a342e4bdbdd95501f" translate="yes" xml:space="preserve">
          <source>lib/locale.t</source>
          <target state="translated">lib/locale.t</target>
        </trans-unit>
        <trans-unit id="d1217cb3b51bf20fe9331bf068816bab61666762" translate="yes" xml:space="preserve">
          <source>lib/open2.t</source>
          <target state="translated">lib/open2.t</target>
        </trans-unit>
        <trans-unit id="7ba11ac14c123959f471691ad31f8b9e84071f76" translate="yes" xml:space="preserve">
          <source>lib/open3.t</source>
          <target state="translated">lib/open3.t</target>
        </trans-unit>
        <trans-unit id="dca0301922534d763ca928ed51e26d8d7783ac18" translate="yes" xml:space="preserve">
          <source>lib/os2_base.t</source>
          <target state="translated">lib/os2_base.t</target>
        </trans-unit>
        <trans-unit id="b8a31ed89dabfffde341b60fd6def6e2c4cc790d" translate="yes" xml:space="preserve">
          <source>lib/perl5</source>
          <target state="translated">lib/perl5</target>
        </trans-unit>
        <trans-unit id="6ba6abb3f64776aa2bb42c96ddc804d4f76ad985" translate="yes" xml:space="preserve">
          <source>lib/strict.pm</source>
          <target state="translated">lib/strict.pm</target>
        </trans-unit>
        <trans-unit id="cf7fc3fcb8b41426b779c987cf3aca145cf46d4c" translate="yes" xml:space="preserve">
          <source>lib/strict.t</source>
          <target state="translated">lib/strict.t</target>
        </trans-unit>
        <trans-unit id="ddf8ccfcb95095226146ff022a9d2f0be94e8d6a" translate="yes" xml:space="preserve">
          <source>lib/syslog.pl</source>
          <target state="translated">lib/syslog.pl</target>
        </trans-unit>
        <trans-unit id="1166bbdf921fa064d4af52b7666490126994f4a9" translate="yes" xml:space="preserve">
          <source>lib/unicore</source>
          <target state="translated">lib/unicore</target>
        </trans-unit>
        <trans-unit id="cb9a2c1b60529371b5aabb0dec31114a2cd72447" translate="yes" xml:space="preserve">
          <source>lib/unicore/To/Foo.pl</source>
          <target state="translated">lib/unicore/To/Foo.pl</target>
        </trans-unit>
        <trans-unit id="2747fd594c4b9098dce15bd69891f3bc7497352a" translate="yes" xml:space="preserve">
          <source>lib/utf8_heavy.pl</source>
          <target state="translated">lib/utf8_heavy.pl</target>
        </trans-unit>
        <trans-unit id="24de2ffa9a7f68a0eaa022fb4d1fc4463cfa7e32" translate="yes" xml:space="preserve">
          <source>libc.U</source>
          <target state="translated">libc.U</target>
        </trans-unit>
        <trans-unit id="9a7905485cd7dad121e13853f453e6168bd685d8" translate="yes" xml:space="preserve">
          <source>libc.so</source>
          <target state="translated">libc.so</target>
        </trans-unit>
        <trans-unit id="ee31a39d4f700ded23ada0ac425f08d9e326043b" translate="yes" xml:space="preserve">
          <source>libcrypt.a</source>
          <target state="translated">libcrypt.a</target>
        </trans-unit>
        <trans-unit id="bb4b26014a9639424988e36bd9e9631832ba04ee" translate="yes" xml:space="preserve">
          <source>libfoo.so.x.y</source>
          <target state="translated">libfoo.so.x.y</target>
        </trans-unit>
        <trans-unit id="9829f920f0965cefd46bd5339f19e3726df34195" translate="yes" xml:space="preserve">
          <source>libname.*</source>
          <target state="translated">libname.*</target>
        </trans-unit>
        <trans-unit id="6084610ec2669c79b3e40c2f469167b5d6ed050c" translate="yes" xml:space="preserve">
          <source>libnetcfg</source>
          <target state="translated">libnetcfg</target>
        </trans-unit>
        <trans-unit id="90297287291496c46cc19f11bcc1f29641bcddf1" translate="yes" xml:space="preserve">
          <source>libnetcfg - configure libnet</source>
          <target state="translated">libnetcfg-配置libnet</target>
        </trans-unit>
        <trans-unit id="63602837884f246bbae970ebe1bf1483d5d73d94" translate="yes" xml:space="preserve">
          <source>libperl and Prebinding</source>
          <target state="translated">libperl和Prebinding</target>
        </trans-unit>
        <trans-unit id="f7ae8185c2b40033375a90176334bf18119d8934" translate="yes" xml:space="preserve">
          <source>libperl.U</source>
          <target state="translated">libperl.U</target>
        </trans-unit>
        <trans-unit id="4c488f9ca04f4580fea44d70fa258f265b01e0cc" translate="yes" xml:space="preserve">
          <source>libperl.a</source>
          <target state="translated">libperl.a</target>
        </trans-unit>
        <trans-unit id="ce9ec3d509b9cb6dfb7bd31e34ac9c1c393f59bd" translate="yes" xml:space="preserve">
          <source>libperl.a equivalent to be linked to dynamic extensions.</source>
          <target state="translated">libperl.a等价于动态扩展的链接。</target>
        </trans-unit>
        <trans-unit id="c5125c991d100a81bb2ab1cf4fc9d757db8bfc62" translate="yes" xml:space="preserve">
          <source>libperl.so</source>
          <target state="translated">libperl.so</target>
        </trans-unit>
        <trans-unit id="db5e46f473e00611def3d06a7cfd97ddab2aa182" translate="yes" xml:space="preserve">
          <source>libperl.so.xxx</source>
          <target state="translated">libperl.so.xxx</target>
        </trans-unit>
        <trans-unit id="ca2af9f2d6220fa51e710bd922000bfeed15c0dc" translate="yes" xml:space="preserve">
          <source>libpth.U</source>
          <target state="translated">libpth.U</target>
        </trans-unit>
        <trans-unit id="bbb082b7d49e9ad809e7f9a2a142296533c655d0" translate="yes" xml:space="preserve">
          <source>libraries for these Perl modules in the places where Perl builder can find it. Use the perl builder: change to an empty directory, create a &quot;dummy&quot;</source>
          <target state="translated">这些Perl模块的库放在Perl builder能找到的地方。使用 perl builder:改成一个空目录,创建一个 &quot;dummy&quot;</target>
        </trans-unit>
        <trans-unit id="8880a921e4238ca055e788428a2b131cc2e7f2b9" translate="yes" xml:space="preserve">
          <source>library and the CPAN module Devel::Symdump make use of this.</source>
          <target state="translated">库和CPAN模块Devel::Symdump利用了这一点。</target>
        </trans-unit>
        <trans-unit id="2f7cc5c519e417b541aeee641af55dc3a4f0071e" translate="yes" xml:space="preserve">
          <source>library provides some of the features of &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt;, but avoids loading most modules and uses as few core features as possible.</source>
          <target state="translated">库提供了&lt;a href=&quot;test/more&quot;&gt;Test :: More的&lt;/a&gt;某些功能，但避免加载大多数模块，并使用了尽可能少的核心功能。</target>
        </trans-unit>
        <trans-unit id="1e947160fbbc3e7ddc94d7fbd4dacb40584ed854" translate="yes" xml:space="preserve">
          <source>library, it combines the features of the</source>
          <target state="translated">库,它结合了</target>
        </trans-unit>
        <trans-unit id="9077bdb27b2b8fc9d2176658752393ca1567f26a" translate="yes" xml:space="preserve">
          <source>library.</source>
          <target state="translated">library.</target>
        </trans-unit>
        <trans-unit id="0778ef88b4665f4828dc51d97a9ae6838afa94b7" translate="yes" xml:space="preserve">
          <source>libs.U</source>
          <target state="translated">libs.U</target>
        </trans-unit>
        <trans-unit id="144fc6d389a583f77c5db29ae574196dcd379d0e" translate="yes" xml:space="preserve">
          <source>libscan</source>
          <target state="translated">libscan</target>
        </trans-unit>
        <trans-unit id="655f1ebeeea52ff6ced2d5d719c659190eb535f6" translate="yes" xml:space="preserve">
          <source>libswanted.</source>
          <target state="translated">libswanted.</target>
        </trans-unit>
        <trans-unit id="d2b824675a5f9e2232ba65db94d4f79ecf3f41d5" translate="yes" xml:space="preserve">
          <source>lies with its &lt;code&gt;NOFILE&lt;/code&gt; define on some systems, so you may have to set</source>
          <target state="translated">在某些系统上带有 &lt;code&gt;NOFILE&lt;/code&gt; 定义，因此您可能需要设置</target>
        </trans-unit>
        <trans-unit id="595dc278b205ed9d7c9ccf298b931232c9af0f83" translate="yes" xml:space="preserve">
          <source>like PAD_SET_CUR, but without the save</source>
          <target state="translated">像PAD_SET_CUR一样,但不需要保存</target>
        </trans-unit>
        <trans-unit id="e95ce206fd1a318d3e2f9217a8174734c6d41c1c" translate="yes" xml:space="preserve">
          <source>like a function, therefore it</source>
          <target state="translated">像函数一样,所以它</target>
        </trans-unit>
        <trans-unit id="e75ea1c71ebd23a635b7661517fc60719e8aaa98" translate="yes" xml:space="preserve">
          <source>like compound statements, but aren't--they're just TERMs in an expression--and thus need an explicit termination when used as the last item in a statement.</source>
          <target state="translated">像复合语句,但不是--它们只是表达式中的TERMs--因此当作为语句中的最后一项使用时,需要一个显式终止。</target>
        </trans-unit>
        <trans-unit id="37f4b3cd257d5cd56ad06fcb46e522be8648e4d5" translate="yes" xml:space="preserve">
          <source>like numbers; using an array as though it were a scalar; if your subroutines recurse more than 100 deep; and innumerable other things.</source>
          <target state="translated">像数字一样使用数组;把数组当作一个标量来使用;如果你的子程序递推超过100个深度;以及其他无数的事情。</target>
        </trans-unit>
        <trans-unit id="0bda6e11e3d8223f3fcb2ce089532445618666fd" translate="yes" xml:space="preserve">
          <source>like script.</source>
          <target state="translated">像剧本。</target>
        </trans-unit>
        <trans-unit id="16edf2fbf12671a4b8e8311124a75cf929f82f3d" translate="yes" xml:space="preserve">
          <source>like this:</source>
          <target state="translated">像这样。</target>
        </trans-unit>
        <trans-unit id="7c4d7e807c0f90aca43d9fe1a786427248bc77ec" translate="yes" xml:space="preserve">
          <source>like to use double quotes, except that in this particular situation, you can just use symbolic references instead, as in case 6.</source>
          <target state="translated">喜欢使用双引号,只是在这种特殊情况下,你可以直接使用符号引用代替,如案例6。</target>
        </trans-unit>
        <trans-unit id="3dd3164fb4c19bfd6a7a909b343e98a2715ee1fe" translate="yes" xml:space="preserve">
          <source>likely</source>
          <target state="translated">likely</target>
        </trans-unit>
        <trans-unit id="c50ed56476fa6fe2fc32cf117ca281f12027cc8b" translate="yes" xml:space="preserve">
          <source>limits itself to real numbers, but an extra &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement brings full complex support, along with a full set of mathematical functions typically associated with and/or extended to complex numbers.</source>
          <target state="translated">将其自身限制为实数，但是额外的 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 声明会带来全面的支持，以及通常与复数关联和/或扩展为复数的全套数学函数。</target>
        </trans-unit>
        <trans-unit id="264f39cab871e4cfd65b3a002f7255888bb5ed97" translate="yes" xml:space="preserve">
          <source>line</source>
          <target state="translated">line</target>
        </trans-unit>
        <trans-unit id="ee6d4c6d5ba67c8947633c21df6ef3227697ec48" translate="yes" xml:space="preserve">
          <source>line (split into two lines above) contains optimizer information. In the example shown, the optimizer found that the match should contain a substring &lt;code&gt;de&lt;/code&gt; at offset 1, plus substring &lt;code&gt;gh&lt;/code&gt; at some offset between 3 and infinity. Moreover, when checking for these substrings (to abandon impossible matches quickly), Perl will check for the substring &lt;code&gt;gh&lt;/code&gt; before checking for the substring &lt;code&gt;de&lt;/code&gt; . The optimizer may also use the knowledge that the match starts (at the &lt;code&gt;first&lt;/code&gt;</source>
          <target state="translated">行（上面分成两行）包含优化程序信息。在所示的示例中，优化程序发现匹配项应包含偏移量为1 的子字符串 &lt;code&gt;de&lt;/code&gt; ，以及偏移量为3与无穷大之间的子字符串 &lt;code&gt;gh&lt;/code&gt; 。此外，当检查这些子字符串（以快速放弃不可能的匹配项）时，Perl将在检查子字符串 &lt;code&gt;de&lt;/code&gt; 之前检查子字符串 &lt;code&gt;gh&lt;/code&gt; 。优化程序还可以使用匹配开始的知识（在第 &lt;code&gt;first&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5cff435ab18a0c579f485626794be0f63bb4f09" translate="yes" xml:space="preserve">
          <source>line 13 is where the action is, so let's continue down to there via the letter '&lt;b&gt;c&lt;/b&gt;', which by the way, inserts a 'one-time-only' breakpoint at the given line or sub routine:</source>
          <target state="translated">第13行是操作所在的位置，因此让我们继续通过字母' &lt;b&gt;c&lt;/b&gt; ' 到那里，顺便说一下，它在给定的行或子例程中插入了&amp;ldquo;一次性的&amp;rdquo;断点：</target>
        </trans-unit>
        <trans-unit id="5d4e605b7f432bb8eb53818c4166fc813e3df040" translate="yes" xml:space="preserve">
          <source>line ends with &quot;\015\012&quot;, and strip what you don't need from the output. This applies especially to socket I/O and autoflushing, discussed next.</source>
          <target state="translated">行以&quot;\015\012 &quot;结尾,并从输出中剥离你不需要的东西。这一点尤其适用于接下来讨论的socket I/O和自动冲洗。</target>
        </trans-unit>
        <trans-unit id="edd5e2ef9789c510bbe128704d9a7e7e3a40e4ec" translate="yes" xml:space="preserve">
          <source>line within the string.</source>
          <target state="translated">字符串内的一行。</target>
        </trans-unit>
        <trans-unit id="c6289336f78366e3f6883b22aef27803c8a7ebe5" translate="yes" xml:space="preserve">
          <source>lines in list context. When performing open, close, or any other operation besides &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; on files, or even when talking about the handle, do</source>
          <target state="translated">列表上下文中的行。在对文件执行打开，关闭或除 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 之外的任何其他操作时，甚至在谈论句柄时，</target>
        </trans-unit>
        <trans-unit id="205e5d4f320847b243dd453a04b92b3be65db4ad" translate="yes" xml:space="preserve">
          <source>lines indented. You can do something like this:</source>
          <target state="translated">行缩进。你可以做这样的事情。</target>
        </trans-unit>
        <trans-unit id="4f0aa52d656a3d75867f784b7e9c5d23bf1321c0" translate="yes" xml:space="preserve">
          <source>link</source>
          <target state="translated">link</target>
        </trans-unit>
        <trans-unit id="893b6bbee2e15aca199ac12f4ec7f3df9dd66111" translate="yes" xml:space="preserve">
          <source>link OLDFILE,NEWFILE</source>
          <target state="translated">链接OLDFILE、NEWFILE</target>
        </trans-unit>
        <trans-unit id="0bd588874c06c526798eba96d6fe06b8a35dbd20" translate="yes" xml:space="preserve">
          <source>lint, splint</source>
          <target state="translated">棉絮</target>
        </trans-unit>
        <trans-unit id="38b62be4bddaa5661c7d6b8e36e28159314df5c7" translate="yes" xml:space="preserve">
          <source>list</source>
          <target state="translated">list</target>
        </trans-unit>
        <trans-unit id="28d839de275cc2a482580b54daa9f1746f8afd3b" translate="yes" xml:space="preserve">
          <source>list as parameters. It will return the corresponding threads object, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if thread creation failed.</source>
          <target state="translated">列出作为参数。它将返回相应的线程对象，如果线程创建失败，则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f85c5f6f515fbe630e0696ceae1fdb9ade45ddad" translate="yes" xml:space="preserve">
          <source>list option</source>
          <target state="translated">列表选项</target>
        </trans-unit>
        <trans-unit id="912fff8dfa7230c9dbc1aafaee034c4c28b60135" translate="yes" xml:space="preserve">
          <source>list. (No parameters are modified, and there can be keys in the</source>
          <target state="translated">列表。(不修改任何参数,可以在</target>
        </trans-unit>
        <trans-unit id="2147a9e5f9e89b70810c82ff8e12817130d6ca10" translate="yes" xml:space="preserve">
          <source>listen</source>
          <target state="translated">listen</target>
        </trans-unit>
        <trans-unit id="97b87c18960b2a4b1aa17d3d60a1e2f067cb6abb" translate="yes" xml:space="preserve">
          <source>listen SOCKET,QUEUESIZE</source>
          <target state="translated">听着SOCKET,QUEUESIZE。</target>
        </trans-unit>
        <trans-unit id="6eccfbe291f324971af6784befbc212824e44176" translate="yes" xml:space="preserve">
          <source>listing</source>
          <target state="translated">listing</target>
        </trans-unit>
        <trans-unit id="61edd61d4a7f28bee492d0997de8c193d478da66" translate="yes" xml:space="preserve">
          <source>lists all of the perl release versions we got the CoreList for.</source>
          <target state="translated">列出了我们得到的 CoreList 的所有 perl 发行版本。</target>
        </trans-unit>
        <trans-unit id="f7d6ae69a9d9939d5b81776dd44d0b872ad9cead" translate="yes" xml:space="preserve">
          <source>lists all of the perl releases and when they were released</source>
          <target state="translated">列出了所有的perl版本和它们的发布时间。</target>
        </trans-unit>
        <trans-unit id="bf9d5a0c63cc1fc18dff839271fcc51b66b70299" translate="yes" xml:space="preserve">
          <source>lists all the files that are skipped due to your &lt;code&gt;MANIFEST.SKIP&lt;/code&gt; file.</source>
          <target state="translated">列出由于 &lt;code&gt;MANIFEST.SKIP&lt;/code&gt; 文件而被跳过的所有文件。</target>
        </trans-unit>
        <trans-unit id="78bebc9e06a6bb16d146b4c83c431c4203e08d0a" translate="yes" xml:space="preserve">
          <source>lists all versions of the given module (or the matching modules, in case you used a module regexp) in the perls Module::CoreList knows about.</source>
          <target state="translated">列出了 perls Module::CoreList 知道的所有模块的版本 (或者匹配的模块,如果你使用了模块的 regexp)。</target>
        </trans-unit>
        <trans-unit id="b82e8dc76d2fa200f820190cf7479ebc1fa8a830" translate="yes" xml:space="preserve">
          <source>lists the first version bundle of each named feature given</source>
          <target state="translated">列出了每个给定特征的第一个版本包</target>
        </trans-unit>
        <trans-unit id="d1e347c1c3866cd9970a92c783f2374e855dfc81" translate="yes" xml:space="preserve">
          <source>listval</source>
          <target state="translated">listval</target>
        </trans-unit>
        <trans-unit id="a568a4ea954740f26f018035ad22bd41cdf0373e" translate="yes" xml:space="preserve">
          <source>literal string</source>
          <target state="translated">字符串</target>
        </trans-unit>
        <trans-unit id="aadf46ad52b563db141c6a8b633250cb09e7740c" translate="yes" xml:space="preserve">
          <source>little-endian</source>
          <target state="translated">little-endian</target>
        </trans-unit>
        <trans-unit id="3c01627cf1f82343852c754d030ad8d0be18a589" translate="yes" xml:space="preserve">
          <source>ln</source>
          <target state="translated">ln</target>
        </trans-unit>
        <trans-unit id="cf7069ab52b9c27c85a59ee69245b2ba15153409" translate="yes" xml:space="preserve">
          <source>ln -s /usr/bin/yacc /usr/local/bin/byacc</source>
          <target state="translated">ln -s /usr/bin/yacc /usr/local/bin/byacc。</target>
        </trans-unit>
        <trans-unit id="f846b4e0eb20fc2b44a3afedf8b1b609fc0fca6f" translate="yes" xml:space="preserve">
          <source>lns.U</source>
          <target state="translated">lns.U</target>
        </trans-unit>
        <trans-unit id="5dbc716c4600097b85b9e51d6aeb77a4363b03ed" translate="yes" xml:space="preserve">
          <source>load</source>
          <target state="translated">load</target>
        </trans-unit>
        <trans-unit id="3d8b45aabc48663acb50c783dcbd10a487867965" translate="yes" xml:space="preserve">
          <source>load_file</source>
          <target state="translated">load_file</target>
        </trans-unit>
        <trans-unit id="d931ba99f1cad82cf3a02b00a20a3f743f4ee781" translate="yes" xml:space="preserve">
          <source>load_json_string</source>
          <target state="translated">load_json_string</target>
        </trans-unit>
        <trans-unit id="bd8a4ef9325f42d52a1f59df9bc59169ed33632d" translate="yes" xml:space="preserve">
          <source>load_string</source>
          <target state="translated">load_string</target>
        </trans-unit>
        <trans-unit id="b4efc8581e40d4d5a86d685e30ad1f651200415c" translate="yes" xml:space="preserve">
          <source>load_yaml_string</source>
          <target state="translated">load_yaml_string</target>
        </trans-unit>
        <trans-unit id="045e2b94f169be3f08f90975694f8e56dc61553f" translate="yes" xml:space="preserve">
          <source>loaded by the full name.</source>
          <target state="translated">由全名加载。</target>
        </trans-unit>
        <trans-unit id="f75ac2bde00caf8de4fa91abaeb94784e5f4eab9" translate="yes" xml:space="preserve">
          <source>loaded from the prescribed path.</source>
          <target state="translated">从规定路径加载。</target>
        </trans-unit>
        <trans-unit id="66fa096aca860773a9d6550be668afcc4230e726" translate="yes" xml:space="preserve">
          <source>loaded into memory may be found. Running &lt;code&gt;make test&lt;/code&gt; becomes meaningless, since the test are checking a previous build of perl (this situation is detected and reported by</source>
          <target state="translated">可能会发现加载到内存中。运行 &lt;code&gt;make test&lt;/code&gt; 变得毫无意义，因为该测试正在检查perl的先前版本（此情况由检测并报告）</target>
        </trans-unit>
        <trans-unit id="19e743edea24c4104fc7fe924db8d02f050e371f" translate="yes" xml:space="preserve">
          <source>loaded into memory, so this will work even for gigantic files.</source>
          <target state="translated">加载到内存中,所以即使是巨大的文件也可以使用。</target>
        </trans-unit>
        <trans-unit id="2c5d6b3e71d391fb38863da485679ad7763ae3b1" translate="yes" xml:space="preserve">
          <source>loading Pod::Simple (or any Pod::Simple-based class). If you try loading Pod::Simple::Debug after &amp;amp;Pod::Simple::DEBUG is already defined, Pod::Simple::Debug will throw a fatal error to the effect that &quot;It's too late to call Pod::Simple::Debug&quot;.</source>
          <target state="translated">加载Pod :: Simple（或任何基于Pod :: Simple的类）。如果在定义了＆Pod :: Simple :: DEBUG之后尝试加载Pod :: Simple :: Debug，则Pod :: Simple :: Debug将引发致命错误，即&amp;ldquo;调用Pod :: Simple已经为时已晚： ：Debug&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="40231aeb561483c2e9b7f30ccfb552f54ea27351" translate="yes" xml:space="preserve">
          <source>loading Pod::Usage, e.g.:</source>
          <target state="translated">加载Pod::Usage,例如:。</target>
        </trans-unit>
        <trans-unit id="52c558e9f725f5eecc9cc18448c82dff5fda24be" translate="yes" xml:space="preserve">
          <source>lobal.</source>
          <target state="translated">lobal.</target>
        </trans-unit>
        <trans-unit id="939bb46a04c3640c8c427e92b1b557e882e2d2a0" translate="yes" xml:space="preserve">
          <source>local</source>
          <target state="translated">local</target>
        </trans-unit>
        <trans-unit id="0cbe83985a317bab5abeb5d93600be89b7c5646f" translate="yes" xml:space="preserve">
          <source>local $Carp::RefArgFormatter = sub { require Data::Dumper; Data::Dumper::Dump($_[0]); # not necessarily safe };</source>
          <target state="translated">local $Carp::RefArgFormatter=sub{require Data::Dumper;Data::Dumper::Dump($_[0]);#不一定安全 };</target>
        </trans-unit>
        <trans-unit id="909cbe434e5f5b8da8ff01039ce1157dbfef1f18" translate="yes" xml:space="preserve">
          <source>local EXPR</source>
          <target state="translated">本地EXPR</target>
        </trans-unit>
        <trans-unit id="0e038a42cca30122c3324dfda646d3f079374dd5" translate="yes" xml:space="preserve">
          <source>locale</source>
          <target state="translated">locale</target>
        </trans-unit>
        <trans-unit id="7151be2e63c3df71d6e8d99768469da377d7fa3e" translate="yes" xml:space="preserve">
          <source>locale - Perl pragma to use or avoid POSIX locales for built-in operations</source>
          <target state="translated">locale-在内置操作中使用或避免使用POSIX语言的Perl pragma。</target>
        </trans-unit>
        <trans-unit id="1526fa886e4977a40dd22b26ef4633fd869bd50f" translate="yes" xml:space="preserve">
          <source>locale(3)</source>
          <target state="translated">locale(3)</target>
        </trans-unit>
        <trans-unit id="86aeaf8b02747cdecdb29ee87a018a9a2691796a" translate="yes" xml:space="preserve">
          <source>locales</source>
          <target state="translated">locales</target>
        </trans-unit>
        <trans-unit id="f25bccd744fab3255bb82bac88c618963868a33f" translate="yes" xml:space="preserve">
          <source>localtime</source>
          <target state="translated">localtime</target>
        </trans-unit>
        <trans-unit id="e7279c8fdf3a31ca3fe4bd189153443f4e05d1ab" translate="yes" xml:space="preserve">
          <source>localtime EXPR</source>
          <target state="translated">当地时间 EXPR</target>
        </trans-unit>
        <trans-unit id="e728eb1d2aa50c88d1b5113f3c08c408b33f7c6f" translate="yes" xml:space="preserve">
          <source>localtime() has the same range as &lt;a href=&quot;#gmtime&quot;&gt;gmtime&lt;/a&gt;, but because time zone rules change its accuracy for historical and future times may degrade but usually by no more than an hour.</source>
          <target state="translated">localtime（）与&lt;a href=&quot;#gmtime&quot;&gt;gmtime的&lt;/a&gt;范围相同，但是由于时区规则会更改其准确性，因此历史记录和将来的时间可能会降低，但通常不会超过一个小时。</target>
        </trans-unit>
        <trans-unit id="87acf50613d511daa509bb42f0542f5b1c19c877" translate="yes" xml:space="preserve">
          <source>locates an auto/$module directory by searching @INC</source>
          <target state="translated">通过搜索@INC定位auto/$module目录。</target>
        </trans-unit>
        <trans-unit id="e117797422d35ce52f036963c7e9603e9955b5c7" translate="yes" xml:space="preserve">
          <source>lock</source>
          <target state="translated">lock</target>
        </trans-unit>
        <trans-unit id="1919d11e33aa63b6546864f63b6597f39b8a192c" translate="yes" xml:space="preserve">
          <source>lock THING</source>
          <target state="translated">锁东西</target>
        </trans-unit>
        <trans-unit id="4fd9900cf61416fbc707cdb91586e771328338b2" translate="yes" xml:space="preserve">
          <source>lock() is a &quot;weak keyword&quot; : this means that if you've defined a function by this name (before any calls to it), that function will be called instead. If you are not under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; this does nothing. See &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;.</source>
          <target state="translated">lock（）是一个&amp;ldquo;弱关键字&amp;rdquo;：这意味着，如果您通过此名称定义了一个函数（在对其进行任何调用之前），那么该函数将被调用。如果您不 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; 则不会执行任何操作。参见&lt;a href=&quot;threads/shared&quot;&gt;thread :: shared&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abe78de368255b02f9df70ea914e277e25b6377a" translate="yes" xml:space="preserve">
          <source>lock() is a &quot;weak keyword&quot; : this means that if you've defined a function by this name (before any calls to it), that function will be called instead. If you are not under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; this does nothing. See &lt;a href=&quot;../threads/shared&quot;&gt;threads::shared&lt;/a&gt;.</source>
          <target state="translated">lock（）是一个&amp;ldquo;弱关键字&amp;rdquo;：这意味着，如果您通过此名称定义了一个函数（在对其进行任何调用之前），那么该函数将被调用。如果您不 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; 则不会执行任何操作。参见&lt;a href=&quot;../threads/shared&quot;&gt;thread :: shared&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="863f64ee1d9d5efee40adfed316ef446406844eb" translate="yes" xml:space="preserve">
          <source>lock_hash() locks an entire hash and any hashes it references recursively, making all keys and values read-only. No value can be changed, no keys can be added or deleted.</source>
          <target state="translated">lock_hash()锁定整个哈希和它递归引用的任何哈希,使所有键和值都是只读的。任何值都不能被改变,任何键都不能被添加或删除。</target>
        </trans-unit>
        <trans-unit id="6e20cbb081d83245b2bb382d13f9e870688dc039" translate="yes" xml:space="preserve">
          <source>lock_hash() locks an entire hash, making all keys and values read-only. No value can be changed, no keys can be added or deleted.</source>
          <target state="translated">lock_hash()锁定整个哈希值,使所有键和值成为只读。任何值都不能被改变,任何键都不能被添加或删除。</target>
        </trans-unit>
        <trans-unit id="5ef7ffb55ca09d3d5d38cd41fdec246b7fc33293" translate="yes" xml:space="preserve">
          <source>lockf(3) does not provide shared locking, and requires that the filehandle be open for writing (or appending, or read/writing).</source>
          <target state="translated">lockf(3)不提供共享锁,并且需要打开文件柄进行写入 (或追加,或读/写)。</target>
        </trans-unit>
        <trans-unit id="7babc233de26ab19ead1b9c278128d5c434910ee" translate="yes" xml:space="preserve">
          <source>log</source>
          <target state="translated">log</target>
        </trans-unit>
        <trans-unit id="54eea61dc30d30177daa813ed0f7f137bf06484b" translate="yes" xml:space="preserve">
          <source>log EXPR</source>
          <target state="translated">日志 EXPR</target>
        </trans-unit>
        <trans-unit id="38dd66928079819674d735fcd8176fe58a1d7607" translate="yes" xml:space="preserve">
          <source>logical</source>
          <target state="translated">logical</target>
        </trans-unit>
        <trans-unit id="2736fab291f04e69b62d490c3c09361f5b82461a" translate="yes" xml:space="preserve">
          <source>login</source>
          <target state="translated">login</target>
        </trans-unit>
        <trans-unit id="bd3027fa569ea15ca76d84db21c67e2d514c1a5a" translate="yes" xml:space="preserve">
          <source>long</source>
          <target state="translated">long</target>
        </trans-unit>
        <trans-unit id="964256f0b5a7ed1218974634ed187c4c92086abb" translate="yes" xml:space="preserve">
          <source>long long</source>
          <target state="translated">悠悠</target>
        </trans-unit>
        <trans-unit id="7d84a9b5ce80cfa867e1b0ac7d47e4d29748d95d" translate="yes" xml:space="preserve">
          <source>longdblfio.U</source>
          <target state="translated">longdblfio.U</target>
        </trans-unit>
        <trans-unit id="e09315fa02d775f3e707a7af455093a1c240583b" translate="yes" xml:space="preserve">
          <source>look</source>
          <target state="translated">look</target>
        </trans-unit>
        <trans-unit id="1f7270b39ba4bb2153715c2af7ce320c7e916470" translate="yes" xml:space="preserve">
          <source>look like it's in Bracket Notation, then we compile it into a sub, replace the string in the %Lexicon with the new coderef, and then we return &amp;amp;$new_sub($lh, ...parameters...).</source>
          <target state="translated">看起来像是括号表示法，然后将其编译为一个子代码，用新的coderef替换％Lexicon中的字符串，然后返回＆$ new_sub（$ lh，... parameters ...）。</target>
        </trans-unit>
        <trans-unit id="4ea4a55106332cc0e3e98059d31fe812e8daa531" translate="yes" xml:space="preserve">
          <source>look like it's in Bracket Notation, we return it (after replacing it with a scalarref, in its %Lexicon).</source>
          <target state="translated">看上去像是用括号表示的,我们就返回它(在它的%Lexicon中用 scalarref替换后)。</target>
        </trans-unit>
        <trans-unit id="449d83a43fb8f44703b6233399d95013a4f778c2" translate="yes" xml:space="preserve">
          <source>looks</source>
          <target state="translated">looks</target>
        </trans-unit>
        <trans-unit id="d348e2927721192d9116c1514b2bf2fc9569cebe" translate="yes" xml:space="preserve">
          <source>looks_like_number</source>
          <target state="translated">looks_like_number</target>
        </trans-unit>
        <trans-unit id="1df823e482339eb6067f4134408b0b8b28411a78" translate="yes" xml:space="preserve">
          <source>loop</source>
          <target state="translated">loop</target>
        </trans-unit>
        <trans-unit id="26ac4aa37ac3a8c344fa2f4dc185d3cd479310b1" translate="yes" xml:space="preserve">
          <source>loses</source>
          <target state="translated">loses</target>
        </trans-unit>
        <trans-unit id="dcf6aa5497e08b90320d9690984d4484444426af" translate="yes" xml:space="preserve">
          <source>lot</source>
          <target state="translated">lot</target>
        </trans-unit>
        <trans-unit id="ee0f49a57ae240afc1fdf80f72c423ec5f89a8ae" translate="yes" xml:space="preserve">
          <source>low surrogate</source>
          <target state="translated">低代理</target>
        </trans-unit>
        <trans-unit id="4bd963634a0c819a99b8db72f5c098cd1267dff4" translate="yes" xml:space="preserve">
          <source>low surrogates</source>
          <target state="translated">低代用品</target>
        </trans-unit>
        <trans-unit id="346e3ee198e98146993894d3de8ecab1a86c3e80" translate="yes" xml:space="preserve">
          <source>lower</source>
          <target state="translated">lower</target>
        </trans-unit>
        <trans-unit id="ebfdec641529d4b59a54e18f8b0e9730f85939fb" translate="yes" xml:space="preserve">
          <source>ls</source>
          <target state="translated">ls</target>
        </trans-unit>
        <trans-unit id="d9ce6d596c2632648fbd8ae6abcd3839f4cbb692" translate="yes" xml:space="preserve">
          <source>lseektype.U</source>
          <target state="translated">lseektype.U</target>
        </trans-unit>
        <trans-unit id="f2b316c5eafa6a056cc0e67989b8ce0c3cc03333" translate="yes" xml:space="preserve">
          <source>lstat</source>
          <target state="translated">lstat</target>
        </trans-unit>
        <trans-unit id="b54245096d5a4f9a2027cbfb28564d6c86ecc831" translate="yes" xml:space="preserve">
          <source>lstat DIRHANDLE</source>
          <target state="translated">lstat DIRHANDLE</target>
        </trans-unit>
        <trans-unit id="c54191eaa53899f1ea11fa61b91001f8f60c7ebb" translate="yes" xml:space="preserve">
          <source>lstat EXPR</source>
          <target state="translated">lstat EXPR</target>
        </trans-unit>
        <trans-unit id="9e33e8fdda61ba945a2beddf3e01162c9c5ee7ca" translate="yes" xml:space="preserve">
          <source>lstat FILEHANDLE</source>
          <target state="translated">lstat FILEHANDLE</target>
        </trans-unit>
        <trans-unit id="5f3acfbeb4f6fa5007dd1137ab1e96149af87281" translate="yes" xml:space="preserve">
          <source>lt</source>
          <target state="translated">lt</target>
        </trans-unit>
        <trans-unit id="18b585d78a0bf7afe6b384a11fedeb39b40868ae" translate="yes" xml:space="preserve">
          <source>lwp-request</source>
          <target state="translated">lwp-request</target>
        </trans-unit>
        <trans-unit id="38d66abc1f9579784448422d6ef39d1f7b4a9a86" translate="yes" xml:space="preserve">
          <source>lxlite</source>
          <target state="translated">lxlite</target>
        </trans-unit>
        <trans-unit id="31d03f8441e634cf0d99448eb5ca7fb3a9fe93d9" translate="yes" xml:space="preserve">
          <source>lynx</source>
          <target state="translated">lynx</target>
        </trans-unit>
        <trans-unit id="056d9d3521478c299c29bed581f1dbf09b2a149a" translate="yes" xml:space="preserve">
          <source>lynx.exe</source>
          <target state="translated">lynx.exe</target>
        </trans-unit>
        <trans-unit id="6b0d31c0d563223024da45691584643ac78c96e8" translate="yes" xml:space="preserve">
          <source>m</source>
          <target state="translated">m</target>
        </trans-unit>
        <trans-unit id="ef3e064abfa5be0f0367ed020edf5681b79671ea" translate="yes" xml:space="preserve">
          <source>m modifier (//m): Treat string as a set of multiple lines. &lt;code&gt;'.'&lt;/code&gt; matches any character except &lt;code&gt;&quot;\n&quot;&lt;/code&gt; . &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; are able to match at the start or end of</source>
          <target state="translated">m修饰符（// m）：将字符串视为一组多行。 &lt;code&gt;'.'&lt;/code&gt; 匹配除 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 以外的任何字符。 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 可以在开头或结尾匹配</target>
        </trans-unit>
        <trans-unit id="d369c164073498644b846b81b69cc5f2c8e49c37" translate="yes" xml:space="preserve">
          <source>m//</source>
          <target state="translated">m//</target>
        </trans-unit>
        <trans-unit id="efd431e9222340418322dc8973ecdf9d041d4b17" translate="yes" xml:space="preserve">
          <source>made further support of WinCE port.</source>
          <target state="translated">对WinCE端口做了进一步的支持。</target>
        </trans-unit>
        <trans-unit id="29328b216c9d886a2b144cfaf368cc216c4398ba" translate="yes" xml:space="preserve">
          <source>madler@alumni.caltech.edu</source>
          <target state="translated">madler@alumni.caltech.edu</target>
        </trans-unit>
        <trans-unit id="b40981aab75932c5b2f555f50769d878e44913d7" translate="yes" xml:space="preserve">
          <source>magic</source>
          <target state="translated">magic</target>
        </trans-unit>
        <trans-unit id="b7161d3acd757800a629497aac7ae100d1b7c5ec" translate="yes" xml:space="preserve">
          <source>magic is called from &lt;code&gt;hv_fetch_common&lt;/code&gt; and &lt;code&gt;hv_delete_common&lt;/code&gt; through the function &lt;code&gt;hv_magic_uvar_xkey&lt;/code&gt; , which defines the interface. The call happens for hashes with &quot;uvar&quot; magic if the &lt;code&gt;ufuncs&lt;/code&gt; structure has equal values in the &lt;code&gt;uf_val&lt;/code&gt; and &lt;code&gt;uf_set&lt;/code&gt; fields. Hashes are unaffected if (and as long as) these fields hold different values.</source>
          <target state="translated">通过定义接口的函数 &lt;code&gt;hv_magic_uvar_xkey&lt;/code&gt; 从 &lt;code&gt;hv_fetch_common&lt;/code&gt; 和 &lt;code&gt;hv_delete_common&lt;/code&gt; 调用magic。如果 &lt;code&gt;ufuncs&lt;/code&gt; 结构在 &lt;code&gt;uf_val&lt;/code&gt; 和 &lt;code&gt;uf_set&lt;/code&gt; 字段中具有相等的值，则调用&amp;ldquo; uvar&amp;rdquo;魔术的哈希。如果（且只要）这些字段具有不同的值，则散列不受影响。</target>
        </trans-unit>
        <trans-unit id="079bca4a77639199d9427705b1cf84c0a19765df" translate="yes" xml:space="preserve">
          <source>mail(1)</source>
          <target state="translated">mail(1)</target>
        </trans-unit>
        <trans-unit id="eeef5463e27b68c50752d7ef6cafa5c83c09c659" translate="yes" xml:space="preserve">
          <source>mailing list.</source>
          <target state="translated">邮件列表。</target>
        </trans-unit>
        <trans-unit id="7af2ad103447ffa690c8bf6319632e78d6f0d6c9" translate="yes" xml:space="preserve">
          <source>mailx(1)</source>
          <target state="translated">mailx(1)</target>
        </trans-unit>
        <trans-unit id="b28b7af69320201d1cf206ebf28373980add1451" translate="yes" xml:space="preserve">
          <source>main</source>
          <target state="translated">main</target>
        </trans-unit>
        <trans-unit id="5821eb27d7b71c9078000da31a5a654c97e401b9" translate="yes" xml:space="preserve">
          <source>make</source>
          <target state="translated">make</target>
        </trans-unit>
        <trans-unit id="9e69b01eeaaedb92e327eadc021b5cbd52d18cd7" translate="yes" xml:space="preserve">
          <source>make alone puts all relevant files into directories that are named by the macros INST_LIB, INST_ARCHLIB, INST_SCRIPT, INST_MAN1DIR and INST_MAN3DIR. All these default to something below ./blib if you are</source>
          <target state="translated">make单独将所有相关文件放入由宏INST_LIB、INST_ARCHLIB、INST_SCRIPT、INST_MAN1DIR和INST_MAN3DIR命名的目录中。所有这些都默认为低于./blib的东西,如果你是</target>
        </trans-unit>
        <trans-unit id="b1414dbd638a7bbedecef3cb42a63b4bb33b205a" translate="yes" xml:space="preserve">
          <source>make even Unix programmers &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; your binary streams, or open them with &lt;code&gt;:raw&lt;/code&gt; , but that's the only way to get at them portably anyway.</source>
          <target state="translated">甚至让Unix程序员 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 您的二进制流进行二进制模式处理，或使用 &lt;code&gt;:raw&lt;/code&gt; 打开它们，但这是可移植地获取它们的唯一方法。</target>
        </trans-unit>
        <trans-unit id="0d2b3e56a2cf0fb81a8aabdc9bbedad97cba9aad" translate="yes" xml:space="preserve">
          <source>make inst_perl by default writes some documentation of what has been done into the file &lt;code&gt;$(INSTALLARCHLIB)/perllocal.pod&lt;/code&gt;. This can be bypassed by calling make pure_inst_perl.</source>
          <target state="translated">默认情况下，make inst_perl将已完成操作的一些文档写入文件 &lt;code&gt;$(INSTALLARCHLIB)/perllocal.pod&lt;/code&gt; 中。可以通过调用make pure_inst_perl来绕开它。</target>
        </trans-unit>
        <trans-unit id="8ac56d2d6c13acc3594f87eb880d15f820a757b2" translate="yes" xml:space="preserve">
          <source>make install</source>
          <target state="translated">安装</target>
        </trans-unit>
        <trans-unit id="9c18e5a4d2fb6411ebee37c34f994e64f9e94356" translate="yes" xml:space="preserve">
          <source>make install by default writes some documentation of what has been done into the file &lt;code&gt;$(INSTALLARCHLIB)/perllocal.pod&lt;/code&gt;. This feature can be bypassed by calling make pure_install.</source>
          <target state="translated">默认情况下，make install会将已完成操作的一些文档写入 &lt;code&gt;$(INSTALLARCHLIB)/perllocal.pod&lt;/code&gt; 文件中。可以通过调用make pure_install来绕过此功能。</target>
        </trans-unit>
        <trans-unit id="b634bb60968f9245e0b837dbb860fc9ffa16de85" translate="yes" xml:space="preserve">
          <source>make test</source>
          <target state="translated">试探</target>
        </trans-unit>
        <trans-unit id="40662a75d2fa6f986ff7fbe892d23df6bb7f669d" translate="yes" xml:space="preserve">
          <source>make testdb</source>
          <target state="translated">制作testdb</target>
        </trans-unit>
        <trans-unit id="4ecb1448927b482d2e8630e628eb858e97dc0d70" translate="yes" xml:space="preserve">
          <source>make them</source>
          <target state="translated">使他们</target>
        </trans-unit>
        <trans-unit id="d91e90d7b776eb0d1d15817fe6d9b9372c6ca037" translate="yes" xml:space="preserve">
          <source>make use of the new qr// construct to pre-compile the regexes they use (whereas &lt;code&gt;extract_tagged&lt;/code&gt; uses standard string variable interpolation to create tag-matching patterns).</source>
          <target state="translated">利用新的qr //构造对它们使用的正则表达式进行预编译（而 &lt;code&gt;extract_tagged&lt;/code&gt; 使用标准字符串变量插值来创建标记匹配模式）。</target>
        </trans-unit>
        <trans-unit id="07526accda1c04050bb9f1a4a62f07c9471df9de" translate="yes" xml:space="preserve">
          <source>make.U</source>
          <target state="translated">make.U</target>
        </trans-unit>
        <trans-unit id="2cbb62d014b07c1a418026eadfae3d532ee66600" translate="yes" xml:space="preserve">
          <source>make_set_make=&lt;code&gt;#&lt;/code&gt; # If your make program handles this for you,</source>
          <target state="translated">make_set_make = &lt;code&gt;#&lt;/code&gt; 如果您的make程序可以为您处理此问题，</target>
        </trans-unit>
        <trans-unit id="fd96c8498d2dc48d3f78f6335afc6ed3167f9b8c" translate="yes" xml:space="preserve">
          <source>make_set_make=&lt;code&gt;MAKE=$make&lt;/code&gt; # if it doesn't.</source>
          <target state="translated">make_set_make = &lt;code&gt;MAKE=$make&lt;/code&gt; ＃（如果没有）。</target>
        </trans-unit>
        <trans-unit id="e7f82c3f566634f9aff062dc010c174e747e8a43" translate="yes" xml:space="preserve">
          <source>makefile.ce</source>
          <target state="translated">makefile.ce</target>
        </trans-unit>
        <trans-unit id="4639a6cdf16268dfbcbc2737352c50221d37ade4" translate="yes" xml:space="preserve">
          <source>makemakerdflt_target</source>
          <target state="translated">makemakerdflt_target</target>
        </trans-unit>
        <trans-unit id="b7c7ada5c449e7874dd51a68b3d5e3334a63dd58" translate="yes" xml:space="preserve">
          <source>makes $this an alias for $that, @this an alias for @that, %this an alias for %that, &amp;amp;this an alias for &amp;amp;that, etc. Much safer is to use a reference. This:</source>
          <target state="translated">使$ this是$ that的别名，@this是@that的别名，％this是％that的别名，＆this是＆that的别名，等等。使用引用更安全。这个：</target>
        </trans-unit>
        <trans-unit id="cdfc243f5581fcd0011d9aa44285de89f3c7df86" translate="yes" xml:space="preserve">
          <source>makes 2 copies of $large_string (one for $copy and another for the quotes), whereas</source>
          <target state="translated">复制2个$large_string (一个用于$copy,另一个用于引号),而</target>
        </trans-unit>
        <trans-unit id="83d231e9f1a700e735290aed581501d7d6b03c61" translate="yes" xml:space="preserve">
          <source>makes Perl use the PATH environment variable to search for the program unless the name of the program contains path separators.</source>
          <target state="translated">使Perl使用PATH环境变量来搜索程序,除非程序的名称包含路径分隔符。</target>
        </trans-unit>
        <trans-unit id="a67bd44e2ab0599fe88c8688792d8ffd48560740" translate="yes" xml:space="preserve">
          <source>makes Tk event loop run when waiting for user input (i.e., during &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; method).</source>
          <target state="translated">在等待用户输入时（即在 &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 方法期间）使Tk事件循环运行。</target>
        </trans-unit>
        <trans-unit id="27400b1510032cb064769829374860147cea9dd5" translate="yes" xml:space="preserve">
          <source>makes the command line stand out by using termcap data. The argument to &lt;code&gt;ornaments&lt;/code&gt; should be 0, 1, or a string of a form &lt;code&gt;&quot;aa,bb,cc,dd&quot;&lt;/code&gt; . Four components of this string should be names of</source>
          <target state="translated">通过使用termcap数据使命令行脱颖而出。 &lt;code&gt;ornaments&lt;/code&gt; 的参数应为0、1或形式为 &lt;code&gt;&quot;aa,bb,cc,dd&quot;&lt;/code&gt; 的字符串。此字符串的四个组成部分应为</target>
        </trans-unit>
        <trans-unit id="0639604e49ec4ac0f7eb55dc4af289d8dc7167a4" translate="yes" xml:space="preserve">
          <source>makes this layer available, although</source>
          <target state="translated">使得该层可以使用,虽然</target>
        </trans-unit>
        <trans-unit id="d6c675249ee9adbb1c9a261647a95be4a6a19ac1" translate="yes" xml:space="preserve">
          <source>maketext_filter</source>
          <target state="translated">maketext_filter</target>
        </trans-unit>
        <trans-unit id="aec3541d23c3a9a173e7827c3070f5f73393d1e0" translate="yes" xml:space="preserve">
          <source>making clear how the parameters are actually passed to &lt;code&gt;foo&lt;/code&gt; .</source>
          <target state="translated">明确说明如何将参数实际传递给 &lt;code&gt;foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e1aeea708e4eb994e02aebaa248131fc82125c0" translate="yes" xml:space="preserve">
          <source>malloc() may want to subdivide a bigger bucket into smaller buckets. If only a part of the deceased bucket is left unsubdivided, the rest is kept as an element of a linked list. This field gives the total size of these chunks.</source>
          <target state="translated">malloc()可能要将一个较大的桶细分为较小的桶。如果只留下已故桶的一部分未被细分,那么剩下的部分就会作为链接列表的一个元素保留下来。这个字段给出了这些小块的总大小。</target>
        </trans-unit>
        <trans-unit id="9a76da154fe4a39e34c734b4cb5bf0dd07eb6ae3" translate="yes" xml:space="preserve">
          <source>malloc(0), realloc(0), calloc(0, 0) are non-portable. To be portable allocate at least one byte. (In general you should rarely need to work at this low level, but instead use the various malloc wrappers.)</source>
          <target state="translated">malloc(0),realloc(0),calloc(0,0)是非可移植的。要做到可移植,至少要分配一个字节。(一般来说,你应该很少需要在这个低级别的工作,而是使用各种malloc包装器。)</target>
        </trans-unit>
        <trans-unit id="222c4a1e90126e2bfcc4b636a85b99c97fd45171" translate="yes" xml:space="preserve">
          <source>malloc.c</source>
          <target state="translated">malloc.c</target>
        </trans-unit>
        <trans-unit id="8596070207a7af9e2362faacf985b07bd76e5e93" translate="yes" xml:space="preserve">
          <source>malloc.o</source>
          <target state="translated">malloc.o</target>
        </trans-unit>
        <trans-unit id="095a5ce7f546af45133c8dc13868feb3acd7faf2" translate="yes" xml:space="preserve">
          <source>mallocsrc.U</source>
          <target state="translated">mallocsrc.U</target>
        </trans-unit>
        <trans-unit id="8175e3c8753aeb1696959f72ede260ebf3ea14c5" translate="yes" xml:space="preserve">
          <source>man</source>
          <target state="translated">man</target>
        </trans-unit>
        <trans-unit id="1c078d0bf4b8dd2e699b069f52b58d7001d16869" translate="yes" xml:space="preserve">
          <source>man page for details.</source>
          <target state="translated">man页面了解详情。</target>
        </trans-unit>
        <trans-unit id="194c36c280a775b2ab3c6204dbb72dea5795ab10" translate="yes" xml:space="preserve">
          <source>man(1)</source>
          <target state="translated">man(1)</target>
        </trans-unit>
        <trans-unit id="b716e508bc702ecd96357df137bb55e7d7979571" translate="yes" xml:space="preserve">
          <source>man(5)</source>
          <target state="translated">man(5)</target>
        </trans-unit>
        <trans-unit id="6208d80a4c0588585c80b00796bde79230ebcf13" translate="yes" xml:space="preserve">
          <source>man(7)</source>
          <target state="translated">man(7)</target>
        </trans-unit>
        <trans-unit id="a3d5158a4aaa199267a8ea6269070ad8aee11093" translate="yes" xml:space="preserve">
          <source>man1dir.U</source>
          <target state="translated">man1dir.U</target>
        </trans-unit>
        <trans-unit id="5bdc3c414d10b0ba2f02bd89b3aa370710faefed" translate="yes" xml:space="preserve">
          <source>man3dir.U</source>
          <target state="translated">man3dir.U</target>
        </trans-unit>
        <trans-unit id="7519267064103f8587f3413cf85843cf6d5b51d6" translate="yes" xml:space="preserve">
          <source>man_url_postfix</source>
          <target state="translated">man_url_postfix</target>
        </trans-unit>
        <trans-unit id="3b4afef27bb9c55d4b3898de6def46e2bd5cde2d" translate="yes" xml:space="preserve">
          <source>man_url_prefix</source>
          <target state="translated">man_url_prefix</target>
        </trans-unit>
        <trans-unit id="967c38874059d9c308cfa6fc765c16a4bc26c1d7" translate="yes" xml:space="preserve">
          <source>manext</source>
          <target state="translated">manext</target>
        </trans-unit>
        <trans-unit id="11208e62cf970ecedb0289935540a9e036a965ed" translate="yes" xml:space="preserve">
          <source>mangle the names according to the scheme of new perl and copy the DLLs to these names;</source>
          <target state="translated">根据new perl的方案,把名字搞乱,然后把DLLs复制到这些名字中。</target>
        </trans-unit>
        <trans-unit id="70f62c5995ffc0a3d8482ebc9cb103ec54f10822" translate="yes" xml:space="preserve">
          <source>manifypods</source>
          <target state="translated">manifypods</target>
        </trans-unit>
        <trans-unit id="cf1b33c2d9cb1cb8c907a395cf2d9daa37137777" translate="yes" xml:space="preserve">
          <source>manifypods_target</source>
          <target state="translated">manifypods_target</target>
        </trans-unit>
        <trans-unit id="0bd558ad5a573716c4a7500ed4950000799f0e6e" translate="yes" xml:space="preserve">
          <source>manpage</source>
          <target state="translated">manpage</target>
        </trans-unit>
        <trans-unit id="8e402ff24e7c6da97aa72971b48ed83bd2075972" translate="yes" xml:space="preserve">
          <source>manpage, on an &quot;empty&quot; program, like this:</source>
          <target state="translated">manpage,在一个 &quot;空 &quot;程序上,像这样。</target>
        </trans-unit>
        <trans-unit id="8fa0fbe8ca06dbd114197c43c3e2ca36a4dd604e" translate="yes" xml:space="preserve">
          <source>manpage. One way to invoke the &lt;code&gt;iconv&lt;/code&gt; shell utility from within perl would be to:</source>
          <target state="translated">联机帮助页。从perl中调用 &lt;code&gt;iconv&lt;/code&gt; shell实用程序的一种方法是：</target>
        </trans-unit>
        <trans-unit id="109e419351c9d9b869f96b375f5b2571c17c6c46" translate="yes" xml:space="preserve">
          <source>manpath</source>
          <target state="translated">manpath</target>
        </trans-unit>
        <trans-unit id="0c2876386539d906bac3a839a472cb5f4cd8a5ad" translate="yes" xml:space="preserve">
          <source>mansrc.U</source>
          <target state="translated">mansrc.U</target>
        </trans-unit>
        <trans-unit id="6cadfcb71363f4d7fc9f2fab3fbedb185b558f8c" translate="yes" xml:space="preserve">
          <source>mantissa() and exponent() return the said parts of the BigFloat as BigInts such that:</source>
          <target state="translated">mantissa()和exponent()将BigFloat的上述部分返回为BigInts,这样。</target>
        </trans-unit>
        <trans-unit id="9c1dd14bb9ad9842019c5e71e79ebfe090ea86ba" translate="yes" xml:space="preserve">
          <source>mantissa(), exponent() and parts()</source>
          <target state="translated">mantissa()、指数()和零件()</target>
        </trans-unit>
        <trans-unit id="37fcf1fa5d0a864017cd95b422637963af01817c" translate="yes" xml:space="preserve">
          <source>manual pages.</source>
          <target state="translated">手动页。</target>
        </trans-unit>
        <trans-unit id="f25470201a131e127feab62862c4c9a8b033b071" translate="yes" xml:space="preserve">
          <source>many</source>
          <target state="translated">many</target>
        </trans-unit>
        <trans-unit id="ef49cb3336572ee03ae671c687d0c1aa65f08ca5" translate="yes" xml:space="preserve">
          <source>many-colored</source>
          <target state="translated">many-colored</target>
        </trans-unit>
        <trans-unit id="9208f9af655701e0391c8136db59433892d1977a" translate="yes" xml:space="preserve">
          <source>many.</source>
          <target state="translated">many.</target>
        </trans-unit>
        <trans-unit id="37745ed7a0f005fb14522c5cc7c1ba3d9e0df579" translate="yes" xml:space="preserve">
          <source>map</source>
          <target state="translated">map</target>
        </trans-unit>
        <trans-unit id="7ae7c2d920d4746221d2021411af1be6f94a2b1e" translate="yes" xml:space="preserve">
          <source>map BLOCK LIST</source>
          <target state="translated">地图BLOCK LIST</target>
        </trans-unit>
        <trans-unit id="252b6dc296dd87752c7fc87bc48e8a3a3ae93df2" translate="yes" xml:space="preserve">
          <source>map EXPR,LIST</source>
          <target state="translated">地图EXPR,LIST</target>
        </trans-unit>
        <trans-unit id="821b7db1bf69055d3819db82de2c55389a73409b" translate="yes" xml:space="preserve">
          <source>mapping</source>
          <target state="translated">mapping</target>
        </trans-unit>
        <trans-unit id="d060c381b2b7e474f3327039365d540bdd00ae54" translate="yes" xml:space="preserve">
          <source>marcus.harnisch (at) gmx.net</source>
          <target state="translated">marcus.harness (at)gmx.net.</target>
        </trans-unit>
        <trans-unit id="db947d9543645af5118ec8eb4a4ca3b85f177330" translate="yes" xml:space="preserve">
          <source>marker or a &quot;package Name;&quot;-style specification.</source>
          <target state="translated">标记或 &quot;包名;&quot;式的规范。</target>
        </trans-unit>
        <trans-unit id="f81924e45a3409b8f19c0c8c0ccc8adb925131f4" translate="yes" xml:space="preserve">
          <source>markers. The original MANIFEST.SKIP is saved as MANIFEST.SKIP.bak.</source>
          <target state="translated">标记。原MANIFEST.SKIP保存为MANIFEST.SKIP.bak。</target>
        </trans-unit>
        <trans-unit id="453a611042ddc2540cd6e814ad412629e5dbe987" translate="yes" xml:space="preserve">
          <source>mask (MASK)</source>
          <target state="translated">掩码(MASK)</target>
        </trans-unit>
        <trans-unit id="c3b8534fda7efd1489afb5fd6145c2c0ee4c5741" translate="yes" xml:space="preserve">
          <source>match any of its subsections:</source>
          <target state="translated">匹配其任何一个子节。</target>
        </trans-unit>
        <trans-unit id="f757168687a351b24f3d7929cacb9c38a3f6d2ba" translate="yes" xml:space="preserve">
          <source>match at the start of the string. Thus the first quantifier has to match everything up to the first &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;. The second minimal quantifier matches just one &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; and the third quantifier matches the rest of the string.</source>
          <target state="translated">在字符串开头匹配。因此，第一个量词必须匹配直到第一个 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 的所有内容。第二个最小量词仅匹配一个 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; ，第三个量词匹配其余的字符串。</target>
        </trans-unit>
        <trans-unit id="0923e6d77fc5fe3e77019fe165e62059bca66c51" translate="yes" xml:space="preserve">
          <source>match is chosen if the</source>
          <target state="translated">匹配,如果</target>
        </trans-unit>
        <trans-unit id="ab40f8ad7e88d02d55d990bcb5fbfb20c5681919" translate="yes" xml:space="preserve">
          <source>match is of zero length.</source>
          <target state="translated">匹配的长度为零。</target>
        </trans-unit>
        <trans-unit id="0d82094c1c07e4a73c286a3d423db8f6e4f8dc59" translate="yes" xml:space="preserve">
          <source>match is what is matched by &lt;code&gt;\w&lt;/code&gt; . Thus zero-length matches alternate with one-character-long matches.</source>
          <target state="translated">match是 &lt;code&gt;\w&lt;/code&gt; 匹配的内容。因此零长度匹配与一字符长匹配交替出现。</target>
        </trans-unit>
        <trans-unit id="04818134b60c58c656e4b991d38166d6f3076c39" translate="yes" xml:space="preserve">
          <source>match of this pattern. This effectively means that the regex engine &quot;skips&quot; forward to this position on failure and tries to match again, (assuming that there is sufficient room to match).</source>
          <target state="translated">的匹配。这实际上意味着在失败时,regex引擎会 &quot;跳过 &quot;前进到这个位置,并尝试再次匹配,(假设有足够的匹配空间)。</target>
        </trans-unit>
        <trans-unit id="2aeb93bd6b0ddbe1b2affadead65a4a0403777df" translate="yes" xml:space="preserve">
          <source>match the current Perl interpreter's version ID, suppressing</source>
          <target state="translated">匹配当前Perl解释器的版本ID,压制了</target>
        </trans-unit>
        <trans-unit id="632d2ed159e13f1f7bc205ac4fd10f5389ed2386" translate="yes" xml:space="preserve">
          <source>match the current Perl interpreter's version id, suppressing</source>
          <target state="translated">匹配当前Perl解释器的版本ID,压制了</target>
        </trans-unit>
        <trans-unit id="f743d4858548a263762a36939a95c6da7ebf0d4d" translate="yes" xml:space="preserve">
          <source>match()</source>
          <target state="translated">match()</target>
        </trans-unit>
        <trans-unit id="9e7284baae613a8be9f37e0730061d6f042d8cb6" translate="yes" xml:space="preserve">
          <source>match, it will</source>
          <target state="translated">匹配,它将</target>
        </trans-unit>
        <trans-unit id="a84c1c52c5a0ad6ba6d17b82c8afb7e48375a135" translate="yes" xml:space="preserve">
          <source>match.c</source>
          <target state="translated">match.c</target>
        </trans-unit>
        <trans-unit id="3269d7265825aa798534517571d41a494aee9d44" translate="yes" xml:space="preserve">
          <source>match:</source>
          <target state="translated">match:</target>
        </trans-unit>
        <trans-unit id="f0ba4ba845edb2f7aae00a27910035ffbe2d4394" translate="yes" xml:space="preserve">
          <source>match_attributes</source>
          <target state="translated">match_attributes</target>
        </trans-unit>
        <trans-unit id="bef3c6a271cefa51790a544a7f9ec2bab5650c92" translate="yes" xml:space="preserve">
          <source>matched regex is used. Delimiters other than '/' may be used for both this operator and the following ones. The leading &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; can be omitted if the delimiter is '/'.</source>
          <target state="translated">使用匹配的正则表达式。除&amp;ldquo; /&amp;rdquo;以外的定界符可用于此运算符和后续运算符。如果定界符为&amp;ldquo; /&amp;rdquo;，则可以省略前导 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac80938af61d76d029e10bff3eeaa4d9936caf68" translate="yes" xml:space="preserve">
          <source>matched regular expression is used instead. In this case, only the &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; flags on the empty pattern are honored; the other flags are taken from the original pattern. If no match has previously succeeded, this will (silently) act instead as a genuine empty pattern (which will always match).</source>
          <target state="translated">而是使用匹配的正则表达式。在这种情况下，仅保留空模式中的 &lt;code&gt;g&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 标志。其他标志取自原始模式。如果之前没有成功匹配，它将（静默）用作真正的空模式（始终匹配）。</target>
        </trans-unit>
        <trans-unit id="cc01360a67b29b124b5c4fb0c967ca385d1fe670" translate="yes" xml:space="preserve">
          <source>matched with zero-length</source>
          <target state="translated">匹配零长度</target>
        </trans-unit>
        <trans-unit id="9f3e9242c63870528e4600bc635fca8f0f5d6e9c" translate="yes" xml:space="preserve">
          <source>matches</source>
          <target state="translated">matches</target>
        </trans-unit>
        <trans-unit id="49da147fbc1f65bec45fdffd10ec7c4b66da5f3d" translate="yes" xml:space="preserve">
          <source>matches a DNA sequence such that it either ends in &lt;code&gt;AAG&lt;/code&gt; , or some other base pair combination and &lt;code&gt;C&lt;/code&gt; . Note that the form is &lt;code&gt;(?(?&amp;lt;=AA)G|C)&lt;/code&gt; and not &lt;code&gt;(?((?&amp;lt;=AA))G|C)&lt;/code&gt;; for the lookahead, lookbehind or code assertions, the parentheses around the conditional are not needed.</source>
          <target state="translated">与DNA序列匹配，使其以 &lt;code&gt;AAG&lt;/code&gt; 结尾，或以其他碱基对组合与 &lt;code&gt;C&lt;/code&gt; 相连。请注意，形式是 &lt;code&gt;(?(?&amp;lt;=AA)G|C)&lt;/code&gt; 而不是 &lt;code&gt;(?((?&amp;lt;=AA))G|C)&lt;/code&gt; ; 对于前瞻，后向或代码断言，不需要在条件周围加上括号。</target>
        </trans-unit>
        <trans-unit id="b1ee14db482234ce9b2680f4f1530b16ee389867" translate="yes" xml:space="preserve">
          <source>matches a chunk of non-parentheses, possibly included in parentheses themselves.</source>
          <target state="translated">匹配了一大块非亲属,可能包含在括号中。</target>
        </trans-unit>
        <trans-unit id="3babeacfb57a1f18f60b79e9f2e4dd3547207ea0" translate="yes" xml:space="preserve">
          <source>matches any four character string which begins with a and ends with d.</source>
          <target state="translated">匹配任何以a开头和以d结尾的四个字符的字符串。</target>
        </trans-unit>
        <trans-unit id="15bb6a71934f5939f8a50dcc56e36bba9679039e" translate="yes" xml:space="preserve">
          <source>matches any single character other than a close square bracket or a minus sign/dash.</source>
          <target state="translated">匹配除近似方括号或减号/斜线以外的任何单个字符。</target>
        </trans-unit>
        <trans-unit id="b44ccf9fc2b923e2e3c4186c16014a27d5a8ac30" translate="yes" xml:space="preserve">
          <source>matches any single printable alphanumeric ASCII character.</source>
          <target state="translated">匹配任何一个可打印的字母数字ASCII字符。</target>
        </trans-unit>
        <trans-unit id="3b42764c7627f67dcaba67e6658bbee63ee5b1a5" translate="yes" xml:space="preserve">
          <source>matches any string that ends with the string &quot;bdc&quot; including the string &quot;bdc&quot; (without quotes).</source>
          <target state="translated">匹配任何以 &quot;bdc &quot;结尾的字符串,包括 &quot;bdc &quot;字符串(不含引号)。</target>
        </trans-unit>
        <trans-unit id="8bc98179220f92e19a1a58c53a9bd45d54ffdbd9" translate="yes" xml:space="preserve">
          <source>matches the character control-</source>
          <target state="translated">匹配字符控制-</target>
        </trans-unit>
        <trans-unit id="b617fbb7b175fdd37c20c95f64db0a36c2293892" translate="yes" xml:space="preserve">
          <source>matches the format of the output produced by method</source>
          <target state="translated">的输出格式相匹配。</target>
        </trans-unit>
        <trans-unit id="9d19065b9d7370cf3c8d6c06d5f9d37ea4be7671" translate="yes" xml:space="preserve">
          <source>matches the literal character &quot;#&quot;. To specify a literal white space character, you can escape it with a backslash, like:</source>
          <target state="translated">匹配文字字符 &quot;#&quot;。要指定一个文字性的空白字符,你可以用反斜杠转义,如:。</target>
        </trans-unit>
        <trans-unit id="3bf2447768fbf2bf4b2e2e933543695b5244c31c" translate="yes" xml:space="preserve">
          <source>matches upper case things. You can avoid surprises by making the components into instances of this construct by compiling them:</source>
          <target state="translated">匹配大写的东西。你可以通过编译组件使其成为该构造的实例来避免意外。</target>
        </trans-unit>
        <trans-unit id="2d3fffffacfc445c265f143813f75c8f495ac85c" translate="yes" xml:space="preserve">
          <source>matches()</source>
          <target state="translated">matches()</target>
        </trans-unit>
        <trans-unit id="c504956e0c725a398bfd8daa901c16a757fa596e" translate="yes" xml:space="preserve">
          <source>matches, because &lt;code&gt;\N{TAMIL SYLLABLE KAU}&lt;/code&gt; is a named sequence consisting of the two characters matched against. Like the other instance where a bracketed class can match multiple characters, and for similar reasons, the class must not be inverted, and the named sequence may not appear in a range, even one where it is both endpoints. If these happen, it is a fatal error if the character class is within an extended &lt;a href=&quot;#Extended-Bracketed-Character-Classes&quot;&gt;(?[...]) &lt;/a&gt; class; and only the first code point is used (with a &lt;code&gt;regexp&lt;/code&gt; -type warning raised) otherwise.</source>
          <target state="translated">匹配，因为 &lt;code&gt;\N{TAMIL SYLLABLE KAU}&lt;/code&gt; 是一个由两个匹配的字符组成的命名序列。就像在另一个实例中，带括号的类可以匹配多个字符，并且出于类似的原因，该类也不得反转，并且命名的序列不得出现在范围内，即使是两个端点也是如此。如果发生这些情况，那么如果字符类在扩展&lt;a href=&quot;#Extended-Bracketed-Character-Classes&quot;&gt;（？[...]）&lt;/a&gt;类之内，则将是致命错误；否则，仅使用第一个代码点（带有 &lt;code&gt;regexp&lt;/code&gt; -type警告）。</target>
        </trans-unit>
        <trans-unit id="1cef80f4af3762f8acb0c8194e31a9dba7622c98" translate="yes" xml:space="preserve">
          <source>math.h</source>
          <target state="translated">math.h</target>
        </trans-unit>
        <trans-unit id="0706025b2bbcec1ed8d64822f4eccd96314938d0" translate="yes" xml:space="preserve">
          <source>max</source>
          <target state="translated">max</target>
        </trans-unit>
        <trans-unit id="f437d0830962615d329585b8ef177af37610c3a6" translate="yes" xml:space="preserve">
          <source>max_exec_len</source>
          <target state="translated">max_exec_len</target>
        </trans-unit>
        <trans-unit id="493a03ab2084312252ebbf79ad1dea22b9c876c0" translate="yes" xml:space="preserve">
          <source>maximal match</source>
          <target state="translated">最大匹配度</target>
        </trans-unit>
        <trans-unit id="6df17187720d1ee015cb9c87f10272784fdb90e6" translate="yes" xml:space="preserve">
          <source>maxopen</source>
          <target state="translated">maxopen</target>
        </trans-unit>
        <trans-unit id="85ce459f8b54d83030c84994d26698ee633e8e8a" translate="yes" xml:space="preserve">
          <source>maxstr</source>
          <target state="translated">maxstr</target>
        </trans-unit>
        <trans-unit id="f458ef050c0ca014fb8f2fdb27ac9b5f69123cfd" translate="yes" xml:space="preserve">
          <source>may</source>
          <target state="translated">may</target>
        </trans-unit>
        <trans-unit id="00dde7e4bcf57be92c2134af6a202a4c7c8c848d" translate="yes" xml:space="preserve">
          <source>may also be expressed as either of:</source>
          <target state="translated">也可表示为:</target>
        </trans-unit>
        <trans-unit id="adb0f7026052c31c6cf256420da26be99c3c65e2" translate="yes" xml:space="preserve">
          <source>may also be set to the special value &lt;code&gt;none&lt;/code&gt; , in which case no quote marks are added around C&amp;lt;&amp;gt; text (but the font is still changed for troff output).</source>
          <target state="translated">也可以将其设置为特殊值 &lt;code&gt;none&lt;/code&gt; ，在这种情况下，不会在C &amp;lt;&amp;gt;文本周围添加引号（但是对于troff输出，字体仍然会更改）。</target>
        </trans-unit>
        <trans-unit id="0ebe475a2d8b3a20ed9e93385b169f98908585ef" translate="yes" xml:space="preserve">
          <source>may also be set to the special value &lt;code&gt;none&lt;/code&gt; , in which case no quote marks are added around C&amp;lt;&amp;gt; text.</source>
          <target state="translated">也可以将其设置为特殊值 &lt;code&gt;none&lt;/code&gt; ，在这种情况下，不会在C &amp;lt;&amp;gt;文本周围添加引号。</target>
        </trans-unit>
        <trans-unit id="e91b6ec2168ed3aab916a99a798fdf733920f81b" translate="yes" xml:space="preserve">
          <source>may also be used to create a skeleton pure Perl module. See the &lt;b&gt;-X&lt;/b&gt; option.</source>
          <target state="translated">也可以用于创建框架纯Perl模块。请参阅&lt;b&gt;-X&lt;/b&gt;选项。</target>
        </trans-unit>
        <trans-unit id="9cfd27998f76697059adfb326f43ad858caa7059" translate="yes" xml:space="preserve">
          <source>may be NULL.</source>
          <target state="translated">可以是NULL。</target>
        </trans-unit>
        <trans-unit id="33043a9fa22b41b4c6ac896111ccbaf62cc4a49e" translate="yes" xml:space="preserve">
          <source>may be a variable containing a code reference (in this case</source>
          <target state="translated">可以是一个包含代码引用的变量(在本例中为</target>
        </trans-unit>
        <trans-unit id="ddec87a1f187c4d9316f5612b310194f0cb15447" translate="yes" xml:space="preserve">
          <source>may be a variable that contains a code reference.</source>
          <target state="translated">可以是一个包含代码引用的变量。</target>
        </trans-unit>
        <trans-unit id="5633babe75c2fba985f3afda654bc7adbab1ef3a" translate="yes" xml:space="preserve">
          <source>may be an unknown concept to some readers. The ISO 8601 standard defines that weeks begin on a Monday and week 1 of the year is the week that includes both January 4th and the first Thursday of the year. In other words, if the first Monday of January is the 2nd, 3rd, or 4th, the preceding days of the January are part of the last week of the preceding year. Week numbers range from 1 to 53.</source>
          <target state="translated">对于一些读者来说,可能是一个陌生的概念。ISO 8601标准定义,周从星期一开始,一年的第1周是包括1月4日和一年的第一个星期四的一周。换句话说,如果1月的第一个星期一是第2、3或4日,那么1月的前几天就是上一年最后一周的一部分。周号的范围是1到53。</target>
        </trans-unit>
        <trans-unit id="620555f380a18af4bd9b7ffcf6fcbb4d729e2b7b" translate="yes" xml:space="preserve">
          <source>may be better to avoid namespace conflict.</source>
          <target state="translated">为了避免命名空间冲突,可能会更好。</target>
        </trans-unit>
        <trans-unit id="b16d2b73013f40d6be654ee941657374d7a6c7cc" translate="yes" xml:space="preserve">
          <source>may be called immediately, even before this function has returned.</source>
          <target state="translated">可以立即被调用,甚至在这个函数返回之前。</target>
        </trans-unit>
        <trans-unit id="c01fdf6f3b149c78a69c314df24371c68b8a9d66" translate="yes" xml:space="preserve">
          <source>may be closer to the conjectural</source>
          <target state="translated">可能更接近于猜想的</target>
        </trans-unit>
        <trans-unit id="8aa5be6aba6ead8c673905a3dcd0c6a264703b5a" translate="yes" xml:space="preserve">
          <source>may be contained in the current directory, or in the home directory. Because this file is sourced in by Perl and may contain arbitrary commands, for security reasons, it must be owned by the superuser or the current user, and writable by no one but its owner.</source>
          <target state="translated">可能包含在当前目录中,也可能包含在主目录中。因为这个文件是由Perl提供的,可能包含任意命令,出于安全考虑,它必须由超级用户或当前用户拥有,除了它的所有者之外,任何人都不能写。</target>
        </trans-unit>
        <trans-unit id="bc813d4cd4ffa7c7d85e1f0cd24c06e64f3ecb37" translate="yes" xml:space="preserve">
          <source>may be either null or &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt; to indicate that no value is to be associated with the key; this, as with any non-null value, takes precedence over the existence of a value for the key further along the chain.</source>
          <target state="translated">可以为null或 &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt; ,以指示该键没有任何值；与任何非null值一样，它优先于整个链中键的值的存在。</target>
        </trans-unit>
        <trans-unit id="d2e64a32b347cd1852fb2ca8b5a92cd685b5142a" translate="yes" xml:space="preserve">
          <source>may be either the name of an encoding or an</source>
          <target state="translated">可以是一个编码的名称,也可以是一个</target>
        </trans-unit>
        <trans-unit id="d0e4afe33850115d15d23bc351fa60444ff005a4" translate="yes" xml:space="preserve">
          <source>may be empty.</source>
          <target state="translated">可能是空的。</target>
        </trans-unit>
        <trans-unit id="082c1d60436b887adb588f21fb8ea006b7e859aa" translate="yes" xml:space="preserve">
          <source>may be needed if you change your codepage</source>
          <target state="translated">如果您改变您的代码页面,可能需要</target>
        </trans-unit>
        <trans-unit id="8c2925aa16e7b49e1bb20df5d9c41ab876a112dd" translate="yes" xml:space="preserve">
          <source>may be optimized to</source>
          <target state="translated">可优化为</target>
        </trans-unit>
        <trans-unit id="59a447a3f4fc5d32399811c9cccb0b4c9956f41d" translate="yes" xml:space="preserve">
          <source>may be rendered as: &quot;magic is enabled if you set &lt;code&gt;$Currency&lt;/code&gt; to '</source>
          <target state="translated">可能显示为：&amp;ldquo;如果将 &lt;code&gt;$Currency&lt;/code&gt; 设置为'</target>
        </trans-unit>
        <trans-unit id="c617289a4345e3f601ec6da0eb0a234d7d3e338e" translate="yes" xml:space="preserve">
          <source>may be the name &lt;code&gt;:locale&lt;/code&gt; . This is for very specialized applications, and is documented in &lt;a href=&quot;#The-%3alocale-sub-pragma&quot;&gt;The :locale sub-pragma&lt;/a&gt; below.</source>
          <target state="translated">可能是名称 &lt;code&gt;:locale&lt;/code&gt; 。这是用于非常专业的应用程序，在&lt;a href=&quot;#The-%3alocale-sub-pragma&quot;&gt;下面的：locale子实用程序&lt;/a&gt;中进行了说明。</target>
        </trans-unit>
        <trans-unit id="acb5ba8300233c06ee33f2092ef458d662a7286b" translate="yes" xml:space="preserve">
          <source>may be used to enter one line of program. If &lt;b&gt;-e&lt;/b&gt; is given, Perl will not look for a filename in the argument list. Multiple &lt;b&gt;-e&lt;/b&gt; commands may be given to build up a multi-line script. Make sure to use semicolons where you would in a normal program.</source>
          <target state="translated">可用于输入一行程序。如果给定&lt;b&gt;-e&lt;/b&gt;，Perl将不在参数列表中查找文件名。可以使用多个&lt;b&gt;-e&lt;/b&gt;命令来构建多行脚本。确保在普通程序中使用分号。</target>
        </trans-unit>
        <trans-unit id="91c85eab0a37caa5e5ee3e84d621bd38427c1f01" translate="yes" xml:space="preserve">
          <source>may contain variables, which will be interpolated every time the pattern search is evaluated, except for when the delimiter is a single quote. (Note that &lt;code&gt;$(&lt;/code&gt; , &lt;code&gt;$)&lt;/code&gt; , and &lt;code&gt;$|&lt;/code&gt; are not interpolated because they look like end-of-string tests.) Perl will not recompile the pattern unless an interpolated variable that it contains changes. You can force Perl to skip the test and never recompile by adding a &lt;code&gt;/o&lt;/code&gt; (which stands for &quot;once&quot;) after the trailing delimiter. Once upon a time, Perl would recompile regular expressions unnecessarily, and this modifier was useful to tell it not to do so, in the interests of speed. But now, the only reasons to use &lt;code&gt;/o&lt;/code&gt; are one of:</source>
          <target state="translated">可能包含变量，每当评估模式搜索时都会对变量进行插值，但定界符为单引号时除外。 （请注意，不会对 &lt;code&gt;$(&lt;/code&gt; ， &lt;code&gt;$)&lt;/code&gt; 和 &lt;code&gt;$|&lt;/code&gt; 进行内插，因为它们看起来像字符串结尾测试。）除非Perl包含的内插变量发生更改，否则Perl不会重新编译该模式。您可以通过在尾随定界符后添加 &lt;code&gt;/o&lt;/code&gt; （表示&amp;ldquo;一次&amp;rdquo;）来强制Perl跳过测试，并且从不重新编译。曾几何时，Perl会不必要地重新编译正则表达式，并且出于速度考虑，此修饰符可用于告诉它不要这样做。但是现在，使用 &lt;code&gt;/o&lt;/code&gt; 的唯一原因是：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
