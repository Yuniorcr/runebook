<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="944edb7108bfdb534265951ea7b5a33f9f4b73e0" translate="yes" xml:space="preserve">
          <source>Share =&amp;gt; $uShare</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bf62db0a202cfe8b527778be027079163e0d35" translate="yes" xml:space="preserve">
          <source>Share what you did with the other people. Relax. Enjoy fruits of your work.</source>
          <target state="translated">与其他人分享你所做的事。放松心情。享受你的工作成果。</target>
        </trans-unit>
        <trans-unit id="df3c637adb69abac13b29419d0cfa8b766ae4adc" translate="yes" xml:space="preserve">
          <source>Shared And Unshared Data</source>
          <target state="translated">共享和非共享数据</target>
        </trans-unit>
        <trans-unit id="2ad8427c8c9758999d3e74a7bdd5fb7162a57750" translate="yes" xml:space="preserve">
          <source>Shared libraries created on a platform using a particular PA-RISC version are not usable on platforms using an earlier PA-RISC version by default. However, this backwards compatibility may be enabled using the same +DAportable compiler flag (with the same PA-RISC 1.0 caveat mentioned above).</source>
          <target state="translated">在使用特定PA-RISC版本的平台上创建的共享库默认不能在使用早期PA-RISC版本的平台上使用。然而,这种向后兼容性可以使用相同的+DAportable编译器标志来启用(与上面提到的PA-RISC 1.0的注意事项相同)。</target>
        </trans-unit>
        <trans-unit id="193a001ab941319380e15850d6f5c791732088df" translate="yes" xml:space="preserve">
          <source>Shared libraries created on an Itanium platform cannot be loaded on a PA-RISC platform. Shared libraries created on a PA-RISC platform can only be loaded on an Itanium platform if it is a PA-RISC executable that is attempting to load the PA-RISC library. A PA-RISC shared library cannot be loaded into an Itanium executable nor vice-versa.</source>
          <target state="translated">在Itanium平台上创建的共享库不能在PA-RISC平台上加载。在PA-RISC平台上创建的共享库只有在PA-RISC可执行文件试图加载PA-RISC库的情况下才能加载到Itanium平台上。PA-RISC 共享库不能被加载到 Itanium 可执行文件中,反之亦然。</target>
        </trans-unit>
        <trans-unit id="6953ee78fc5edeec2d6a50098821da893b0458f7" translate="yes" xml:space="preserve">
          <source>Shared references among objects will not stay shared: if we're serializing the list of object [A, C] where both object A and C refer to the SAME object B, and if there is a serializing hook in A that says freeze(B), then when deserializing, we'll get [A', C'] where A' refers to B', but C' refers to D, a deep clone of B'. The topology was not preserved.</source>
          <target state="translated">对象之间的共享引用不会保持共享:如果我们在序列化对象[A,C]的列表中,对象A和C都引用了SAME对象B,如果A中有一个序列化钩子,说冻结(B),那么在反序列化时,我们会得到[A',C'],其中A'引用了B',但C'引用了D,是B'的深度克隆。拓扑结构没有被保留下来。</target>
        </trans-unit>
        <trans-unit id="f728eba8dfb3236f1667f74466840c95e5a7b8ee" translate="yes" xml:space="preserve">
          <source>Shared variables can only store scalars, refs of shared variables, or refs of shared data (discussed in next section):</source>
          <target state="translated">共享变量只能存储标量、共享变量的refs或共享数据的refs(在下一节讨论)。</target>
        </trans-unit>
        <trans-unit id="001c163e34c30bd422c6c0b180836b52f1afdb17" translate="yes" xml:space="preserve">
          <source>Sharing Databases With C Applications</source>
          <target state="translated">与C应用程序共享数据库</target>
        </trans-unit>
        <trans-unit id="bd8715c47f235864c2ceb04d785a7b7ec14fa56b" translate="yes" xml:space="preserve">
          <source>Sharing typemaps Between CPAN Distributions</source>
          <target state="translated">在CPAN分布之间共享类型图</target>
        </trans-unit>
        <trans-unit id="0a07afc00eaa14a561ef50fb9dc88822e22b041a" translate="yes" xml:space="preserve">
          <source>Sharp shell programmers should take note of the following:</source>
          <target state="translated">锐壳程序员应该注意以下几点。</target>
        </trans-unit>
        <trans-unit id="f78065b15d0af880ad317e4f961cef2d5893c97c" translate="yes" xml:space="preserve">
          <source>Shawn H Corey &lt;code&gt;SHCOREY at cpan.org&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa79f294b4ff3f2bd0e6980c0d9d3429325e3b2" translate="yes" xml:space="preserve">
          <source>Shawn M Moore &lt;code&gt;sartak@gmail.com&lt;/code&gt;</source>
          <target state="translated">肖恩M摩尔 &lt;code&gt;sartak@gmail.com&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a14cc09b3426b2766b9650c676895c8481a40916" translate="yes" xml:space="preserve">
          <source>Shebang Race Condition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc1fd5d3c0f3dcfd55d010426e61bf9451e680d" translate="yes" xml:space="preserve">
          <source>Shell</source>
          <target state="translated">Shell</target>
        </trans-unit>
        <trans-unit id="46f2fc676064cd202c006928e29b43973667f22c" translate="yes" xml:space="preserve">
          <source>Shell Traps</source>
          <target state="translated">诱捕器</target>
        </trans-unit>
        <trans-unit id="05e1aa29dff23edb2a5976ffe3e3f5926084ec96" translate="yes" xml:space="preserve">
          <source>Shell escapes newlines in $text.</source>
          <target state="translated">Shell逃逸$text中的换行。</target>
        </trans-unit>
        <trans-unit id="411430d5faea18a48223083d430d03ec02723be9" translate="yes" xml:space="preserve">
          <source>Shell mode</source>
          <target state="translated">外壳模式</target>
        </trans-unit>
        <trans-unit id="ae8110256e73e2d29bfd2b0361c6084818dcf5fb" translate="yes" xml:space="preserve">
          <source>Shell variables from the</source>
          <target state="translated">壳变量从</target>
        </trans-unit>
        <trans-unit id="a5efec93b7817b727267bf3e97356065022021aa" translate="yes" xml:space="preserve">
          <source>Shell::Command which is these same functions but take arguments normally.</source>
          <target state="translated">Shell::Command是这些相同的函数,但通常会接受参数。</target>
        </trans-unit>
        <trans-unit id="5597033de9e3a9ee3ab28b086225929f8384f842" translate="yes" xml:space="preserve">
          <source>Shells (especially &lt;b&gt;csh&lt;/b&gt;) do several levels of substitution on each command line. Perl does substitution in only certain constructs such as double quotes, backticks, angle brackets, and search patterns.</source>
          <target state="translated">Shell（尤其是&lt;b&gt;csh&lt;/b&gt;）在每个命令行上执行多个替换级别。Perl仅在某些构造（例如双引号，反引号，尖括号和搜索模式）中进行替换。</target>
        </trans-unit>
        <trans-unit id="c3085316e59739c3d0881dec21da7ebe8e1387d1" translate="yes" xml:space="preserve">
          <source>Shells interpret scripts a little bit at a time. Perl compiles the entire program before executing it (except for &lt;code&gt;BEGIN&lt;/code&gt; blocks, which execute at compile time).</source>
          <target state="translated">Shell一次解释一点脚本。Perl在执行之前先编译整个程序（ &lt;code&gt;BEGIN&lt;/code&gt; 块除外，后者在编译时执行）。</target>
        </trans-unit>
        <trans-unit id="d740f71b4c0205327f8285c81beee6b58843073b" translate="yes" xml:space="preserve">
          <source>Shift Operators</source>
          <target state="translated">轮班操作员</target>
        </trans-unit>
        <trans-unit id="53ffaf0e7e7ca17703b35ea2272d3800a2b8789e" translate="yes" xml:space="preserve">
          <source>Shift object N digits right in base B and return the resulting object. This is equivalent to performing integer division by B**N and discarding the remainder, except that it might be much faster, depending on how the number is represented internally.</source>
          <target state="translated">将对象的N个数字以B为基数右移,并返回结果对象。这相当于执行整数除以B**N并丢弃余数,只是它可能快得多,这取决于数字的内部表示方式。</target>
        </trans-unit>
        <trans-unit id="816ba91c6c549fed8497fc4ed9fd5be93db7467c" translate="yes" xml:space="preserve">
          <source>Shift the object N digits left in base B. This is equivalent to multiplying by B**N, except that it might be much faster, depending on how the number is represented internally.</source>
          <target state="translated">这相当于用B**N做乘法,只是可能会快得多,这取决于数字的内部表示方式。</target>
        </trans-unit>
        <trans-unit id="34ca9f2e9bedec059779353756117cfa0cd23d9b" translate="yes" xml:space="preserve">
          <source>Shift_JIS</source>
          <target state="translated">Shift_JIS</target>
        </trans-unit>
        <trans-unit id="c96929f71a3c235121f63b63fb9116d40dbf5a0d" translate="yes" xml:space="preserve">
          <source>Shifting by more bits than the size of the integers means most of the time zero (all bits fall off), except that under &lt;code&gt;use integer&lt;/code&gt; right overshifting a negative shiftee results in -1. This is unlike in C, where shifting by too many bits is undefined. A common C behavior is &quot;shift by modulo wordbits&quot;, so that for example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c82c36060459ec37e9c46c5b4c7db69b11b3eb70" translate="yes" xml:space="preserve">
          <source>Shifting by negative number of bits means the reverse shift: left shift becomes right shift, right shift becomes left shift. This is unlike in C, where negative shift is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bbd5485928f42790ecd61230b448ed394726e75" translate="yes" xml:space="preserve">
          <source>Shifts $x right by $y in base $n. Default is base 2, used are usually 10 and 2, but others work, too.</source>
          <target state="translated">将$x右移$y,基数为$n。默认是基数2,使用的通常是10和2,但其他的也可以。</target>
        </trans-unit>
        <trans-unit id="84e5b666ca83223606a44c0968ce869e11125987" translate="yes" xml:space="preserve">
          <source>Shifts the first value of the array off and returns it, shortening the array by 1 and moving everything down. If there are no elements in the array, returns the undefined value. If ARRAY is omitted, shifts the &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt; array within the lexical scope of subroutines and formats, and the &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt; array outside a subroutine and also within the lexical scopes established by the &lt;code&gt;eval STRING&lt;/code&gt;, &lt;code&gt;BEGIN {}&lt;/code&gt;, &lt;code&gt;INIT {}&lt;/code&gt;, &lt;code&gt;CHECK {}&lt;/code&gt;, &lt;code&gt;UNITCHECK {}&lt;/code&gt;, and &lt;code&gt;END {}&lt;/code&gt; constructs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab6779d1c4d586e5a686816d2490a5a885e59ca" translate="yes" xml:space="preserve">
          <source>Shifts the first value of the array off and returns it, shortening the array by 1 and moving everything down. If there are no elements in the array, returns the undefined value. If ARRAY is omitted, shifts the &lt;code&gt;@_&lt;/code&gt; array within the lexical scope of subroutines and formats, and the &lt;code&gt;@ARGV&lt;/code&gt; array outside a subroutine and also within the lexical scopes established by the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; , &lt;code&gt;BEGIN {}&lt;/code&gt; , &lt;code&gt;INIT {}&lt;/code&gt; , &lt;code&gt;CHECK {}&lt;/code&gt; , &lt;code&gt;UNITCHECK {}&lt;/code&gt; , and &lt;code&gt;END {}&lt;/code&gt; constructs.</source>
          <target state="translated">将数组的第一个值移开并返回它，将数组缩短1并向下移动所有内容。如果数组中没有元素，则返回未定义的值。如果省略了ARRAY，则将 &lt;code&gt;@_&lt;/code&gt; 数组移到子例程和格式的词法范围内，并将 &lt;code&gt;@ARGV&lt;/code&gt; 数组移到子例程的外部，并移到 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; ， &lt;code&gt;BEGIN {}&lt;/code&gt; ， &lt;code&gt;INIT {}&lt;/code&gt; ， &lt;code&gt;CHECK {}&lt;/code&gt; 建立的词法范围内， &lt;code&gt;UNITCHECK {}&lt;/code&gt; 和 &lt;code&gt;END {}&lt;/code&gt; 构造。</target>
        </trans-unit>
        <trans-unit id="ceb6ece5170a4ff335501d527cf25219b25ce8af" translate="yes" xml:space="preserve">
          <source>Shifts the first value of the array off and returns it, shortening the array by 1 and moving everything down. If there are no elements in the array, returns the undefined value. If ARRAY is omitted, shifts the &lt;code&gt;@_&lt;/code&gt; array within the lexical scope of subroutines and formats, and the &lt;code&gt;@ARGV&lt;/code&gt; array outside a subroutine and also within the lexical scopes established by the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; , &lt;code&gt;BEGIN {}&lt;/code&gt; , &lt;code&gt;INIT {}&lt;/code&gt; , &lt;code&gt;CHECK {}&lt;/code&gt; , &lt;code&gt;UNITCHECK {}&lt;/code&gt; , and &lt;code&gt;END {}&lt;/code&gt; constructs.</source>
          <target state="translated">将数组的第一个值移开并返回它，将数组缩短1并向下移动所有内容。如果数组中没有元素，则返回未定义的值。如果省略了ARRAY，则将 &lt;code&gt;@_&lt;/code&gt; 数组移到子例程和格式的词法范围内，并将 &lt;code&gt;@ARGV&lt;/code&gt; 数组移到子例程的外部，并移到 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; ， &lt;code&gt;BEGIN {}&lt;/code&gt; ， &lt;code&gt;INIT {}&lt;/code&gt; ， &lt;code&gt;CHECK {}&lt;/code&gt; 建立的词法范围内， &lt;code&gt;UNITCHECK {}&lt;/code&gt; 和 &lt;code&gt;END {}&lt;/code&gt; 构造。</target>
        </trans-unit>
        <trans-unit id="a9246a967ab694917a93818e0c2f25b9c02d69c1" translate="yes" xml:space="preserve">
          <source>Shlomi Fish</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="531ae3a2e613d67a406a1e927931cfe1052049c5" translate="yes" xml:space="preserve">
          <source>Shoichi Kaji &amp;lt;skaji@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dece67ae205fea215adef783e8ddedd9ee8cd234" translate="yes" xml:space="preserve">
          <source>Short for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e560762a5e85f4245145df0a3d5f14955ebfbe7e" translate="yes" xml:space="preserve">
          <source>Short for &amp;ldquo;an instance of a class&amp;rdquo;, meaning an &lt;b&gt;object&lt;/b&gt; of that &lt;b&gt;class&lt;/b&gt;.</source>
          <target state="translated">简称&amp;ldquo;一类的实例&amp;rdquo;，这意味着一个&lt;b&gt;对象&lt;/b&gt;是的&lt;b&gt;类&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="bf0f9ba179007d01df18b67571c95890eacf53a2" translate="yes" xml:space="preserve">
          <source>Short for &amp;ldquo;array value&amp;rdquo;, which refers to one of Perl&amp;rsquo;s internal data types that holds an &lt;b&gt;array&lt;/b&gt;. The &lt;code&gt;AV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">&amp;ldquo;数组值&amp;rdquo;（array value）的简称，它是指Perl的内部数据类型之一，该数据类型保存一个&lt;b&gt;array&lt;/b&gt;。的 &lt;code&gt;AV&lt;/code&gt; 类型是子类&lt;b&gt;SV&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="daa4e28096f49e40bca183e69c8dbf8fb7d81587" translate="yes" xml:space="preserve">
          <source>Short for &amp;ldquo;scalar value&amp;rdquo;. But within the Perl interpreter, every &lt;b&gt;referent&lt;/b&gt; is treated as a member of a class derived from SV, in an object-oriented sort of way. Every &lt;b&gt;value&lt;/b&gt; inside Perl is passed around as a C language &lt;code&gt;SV*&lt;/code&gt; pointer. The SV &lt;b&gt;struct&lt;/b&gt; knows its own &amp;ldquo;referent type&amp;rdquo;, and the code is smart enough (we hope) not to try to call a &lt;b&gt;hash&lt;/b&gt; function on a &lt;b&gt;subroutine&lt;/b&gt;.</source>
          <target state="translated">&amp;ldquo;标量值&amp;rdquo;的缩写。但是在Perl解释器中，每个&lt;b&gt;引用&lt;/b&gt;对象都以面向对象的方式被视为从SV派生的类的成员。Perl中的每个&lt;b&gt;值&lt;/b&gt;都作为C语言 &lt;code&gt;SV*&lt;/code&gt; 指针传递。SV &lt;b&gt;结构&lt;/b&gt;知道其自己的&amp;ldquo;引用类型&amp;rdquo;，并且代码足够聪明（我们希望如此），以便不尝试在&lt;b&gt;子例程&lt;/b&gt;上调用&lt;b&gt;哈希&lt;/b&gt;函数。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5d19c4596f6bfea39cf19abcb0120dd79077a176" translate="yes" xml:space="preserve">
          <source>Short for &lt;b&gt;scratchpad&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;暂存器的&lt;/b&gt;简称。</target>
        </trans-unit>
        <trans-unit id="11be5993935a64f6ec9ea9395f4cafbeb6afecc6" translate="yes" xml:space="preserve">
          <source>Short for Nevada, no part of which will ever be confused with civilization. NV also means an internal floating- point Numeric Value of the type a &lt;b&gt;scalar&lt;/b&gt; can hold, not to be confused with an &lt;b&gt;IV&lt;/b&gt;.</source>
          <target state="translated">内华达州的简称，内华达州永远不会与文明相混淆。NV还表示&lt;b&gt;标量&lt;/b&gt;可以容纳的内部浮点数值，不要与&lt;b&gt;IV&lt;/b&gt;混淆。</target>
        </trans-unit>
        <trans-unit id="753c68d3ba41db74e4df8914f2ce920431708ec4" translate="yes" xml:space="preserve">
          <source>Short for Transmission Control Protocol. A protocol wrapped around the Internet Protocol to make an unreliable packet transmission mechanism appear to the application program to be a reliable &lt;b&gt;stream&lt;/b&gt; of bytes. (Usually.)</source>
          <target state="translated">传输控制协议的缩写。包裹在Internet协议周围的协议，使不可靠的数据包传输机制在应用程序中看起来像是可靠的字节&lt;b&gt;流&lt;/b&gt;。（通常）</target>
        </trans-unit>
        <trans-unit id="dc5ee68c69bf44299748c4c256b80c120fb271e9" translate="yes" xml:space="preserve">
          <source>Short for a &amp;ldquo;hash value&amp;rdquo; typedef, which holds Perl&amp;rsquo;s internal representation of a hash. The &lt;code&gt;HV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">&amp;ldquo;哈希值&amp;rdquo; typedef的缩写，其中包含Perl对哈希的内部表示。的 &lt;code&gt;HV&lt;/code&gt; 类型是子类&lt;b&gt;SV&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="641d12dc5680debd9252f30257e835d77f2b58b5" translate="yes" xml:space="preserve">
          <source>Short for a &amp;ldquo;terminal&amp;rdquo;&amp;mdash;that is, a leaf node of a &lt;b&gt;syntax tree&lt;/b&gt;. A thing that functions grammatically as an &lt;b&gt;operand&lt;/b&gt; for the operators in an expression.</source>
          <target state="translated">&amp;ldquo;终端&amp;rdquo;的缩写，即&lt;b&gt;语法树&lt;/b&gt;的叶节点。在语法上用作表达式中运算符的&lt;b&gt;操作数的&lt;/b&gt;事物。</target>
        </trans-unit>
        <trans-unit id="2a34ff2be32b26b7b9b0b3b4f346552a9899d102" translate="yes" xml:space="preserve">
          <source>Short for one member of &lt;b&gt;Perl mongers&lt;/b&gt;, a purveyor of Perl.</source>
          <target state="translated">对于短的一个成员&lt;b&gt;的Perl贩子&lt;/b&gt;，Perl中的传播者。</target>
        </trans-unit>
        <trans-unit id="215e423928369d110ed59f1768219b3b38101a83" translate="yes" xml:space="preserve">
          <source>Short integers. This is equivalent to T_IV but explicitly casts the return to type &lt;code&gt;short&lt;/code&gt; . The default typemap for &lt;code&gt;short&lt;/code&gt; is T_IV.</source>
          <target state="translated">短整数。这等效于T_IV，但显式将返回值强制转换为 &lt;code&gt;short&lt;/code&gt; 类型。 &lt;code&gt;short&lt;/code&gt; 的默认类型映射是T_IV。</target>
        </trans-unit>
        <trans-unit id="12e34708f98b55fcfa0df10d0541bdc76b04003d" translate="yes" xml:space="preserve">
          <source>Short integers. This is equivalent to T_IV but explicitly casts the return to type &lt;code&gt;short&lt;/code&gt;. The default typemap for &lt;code&gt;short&lt;/code&gt; is T_IV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e173f44ce033e23615a07008598ed98e0724ec82" translate="yes" xml:space="preserve">
          <source>Short of loading the file into a database or pre-indexing the lines in the file, there are a couple of things that you can do.</source>
          <target state="translated">除了将文件加载到数据库或预先索引文件中的行之外,还有一些事情可以做。</target>
        </trans-unit>
        <trans-unit id="84208312087b060594b7b3ab194603ca9b48cd14" translate="yes" xml:space="preserve">
          <source>Short string (usually 10 characters or less, not enforced, but may be truncated by renderers) categorizing the amnesty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342f19ffca54484d831bc22d60422377cb72128f" translate="yes" xml:space="preserve">
          <source>Short summary: You need to create a package that defines four methods:</source>
          <target state="translated">小结:你需要创建一个包,定义四个方法。</target>
        </trans-unit>
        <trans-unit id="7d0c4499cb9c122a7211725e510477fa79e82bb6" translate="yes" xml:space="preserve">
          <source>Short tag to categorize the error. This is usually 10 characters or less, formatters may truncate longer tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5092f6331f83cfc30c23eb79579783db3e8793f1" translate="yes" xml:space="preserve">
          <source>Short tag to categorize the info. This is usually 10 characters or less, formatters may truncate longer tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b21662873145e63208c0c220c63eecf3382545" translate="yes" xml:space="preserve">
          <source>Short tests may produce negative figures because perl can appear to take longer to execute the empty loop than a short test; try:</source>
          <target state="translated">短测试可能会产生负数,因为perl执行空循环的时间似乎比短测试的时间要长;尝试。</target>
        </trans-unit>
        <trans-unit id="3c291d239a5572586d5800f8940e243040b2c7b5" translate="yes" xml:space="preserve">
          <source>Shortcomings of Perl under AmigaOS</source>
          <target state="translated">AmigaOS下Perl的不足之处</target>
        </trans-unit>
        <trans-unit id="fa78e77c849e3197f1c80d2dbbfe4db374f3b001" translate="yes" xml:space="preserve">
          <source>Shortcomings of Perl under DOS</source>
          <target state="translated">DOS下Perl的缺点</target>
        </trans-unit>
        <trans-unit id="a84b9d9cc1ba4235d4b9a38a4443bc225f0a9d86" translate="yes" xml:space="preserve">
          <source>Should I do anything special if I call perl from multiple threads?</source>
          <target state="translated">如果我从多个线程调用perl,我应该做什么特别的事情吗?</target>
        </trans-unit>
        <trans-unit id="41623a0ef32a13c7058b74719f5d1256441b7302" translate="yes" xml:space="preserve">
          <source>Should I use a web framework?</source>
          <target state="translated">我应该使用网络框架吗?</target>
        </trans-unit>
        <trans-unit id="706821549d14c573be320aadd1615ad49253a11a" translate="yes" xml:space="preserve">
          <source>Should a user have the need for compiling Perl in the LP64 environment, use the -Duse64bitall flag to Configure. This will force Perl to be compiled in a pure LP64 environment (with the +DD64 flag for HP C-ANSI-C, with no additional options for GNU gcc 64-bit on PA-RISC, and with -mlp64 for GNU gcc on Itanium). If you want to compile Perl using gcc, you will have to get a version of the compiler that supports 64-bit operations.)</source>
          <target state="translated">如果用户需要在LP64环境下编译Perl,可以使用-Duse64bitall标志来配置。这将强制Perl在纯LP64环境下编译(对于HP C-ANSI-C,使用+DD64标志,对于PA-RISC上的GNU gcc 64位,没有额外的选项,对于Itanium上的GNU gcc,使用-mlp64)。如果你想用gcc编译Perl,你必须得到一个支持64位操作的编译器版本)。)</target>
        </trans-unit>
        <trans-unit id="efca6f20e60abb6462f2115cc6f4f778b3e904aa" translate="yes" xml:space="preserve">
          <source>Should an &lt;code&gt;ok()&lt;/code&gt; fail, it will produce some diagnostics:</source>
          <target state="translated">如果 &lt;code&gt;ok()&lt;/code&gt; 失败，它将产生一些诊断信息：</target>
        </trans-unit>
        <trans-unit id="6ed2a6a9606e8c4524e86ab5840b45b4bc37bfbb" translate="yes" xml:space="preserve">
          <source>Should be true if this event should result in a test count increment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa2401927f1002b79d1cf0dcfbafc98b85b5c42" translate="yes" xml:space="preserve">
          <source>Should be used if the perl library is moved from the default location in preference to &lt;code&gt;PERL(5)LIB&lt;/code&gt;, since this would not leave wrong entries in @INC. For example, if the compiled version of perl looks for @INC in</source>
          <target state="translated">如果将perl库从默认位置优先移至 &lt;code&gt;PERL(5)LIB&lt;/code&gt; ，则应使用此方法，因为这不会在@INC中留下错误的条目。例如，如果perl的编译版本在以下位置查找@INC</target>
        </trans-unit>
        <trans-unit id="56e9538fa48dc5397d7704d11be1b316f1409e45" translate="yes" xml:space="preserve">
          <source>Should make stream's state consistent with layers below. That is, any buffered write data should be written, and file position of lower layers adjusted for data read from below but not actually consumed. (Should perhaps &lt;code&gt;Unread()&lt;/code&gt; such data to the lower layer.)</source>
          <target state="translated">应该使流的状态与下面的层一致。也就是说，应该写入任何缓冲的写入数据，并针对从下面读取但实际上并未消耗的数据调整较低层的文件位置。（也许应该将 &lt;code&gt;Unread()&lt;/code&gt; 这样的数据发送到下层。）</target>
        </trans-unit>
        <trans-unit id="1c3d2c3d146bd37267ff2248c2cd5e844253f599" translate="yes" xml:space="preserve">
          <source>Should not be set with newer Perls, since this may hide some</source>
          <target state="translated">不应该在较新的Perls中设置,因为这可能会隐藏一些。</target>
        </trans-unit>
        <trans-unit id="ed8ff1c4976aa7b4301ba319829b15d5951b2c6e" translate="yes" xml:space="preserve">
          <source>Should probably be built into the core, and needs to stop pandering to DOS habits. Needs a dose of optimization too.</source>
          <target state="translated">可能应该内置于核心,需要不再迎合DOS的习惯。也需要一定的优化。</target>
        </trans-unit>
        <trans-unit id="fbde5e966385ab1512ea67e3f35d08dd24d83ceb" translate="yes" xml:space="preserve">
          <source>Should return 0 on success, -1 on error. Optional.</source>
          <target state="translated">成功时应返回0,错误时应返回-1。可选。</target>
        </trans-unit>
        <trans-unit id="f8c399f86acf033efef1e2751ef404b5ddaa2865" translate="yes" xml:space="preserve">
          <source>Should return 0 on success, -1 on error. Optional. Default is to fail, but that is likely to be changed in future.</source>
          <target state="translated">成功时应返回0,错误时应返回-1。可选。默认值是失败,但将来可能会改变。</target>
        </trans-unit>
        <trans-unit id="246758221cfd3e60868d6718c892fa1bb87177ab" translate="yes" xml:space="preserve">
          <source>Should return a string to be placed in the buffer. Optional. If not provided, must provide READ or reject handles open for reading in PUSHED.</source>
          <target state="translated">应该返回一个要放在缓冲区的字符串。可选的,如果没有提供,必须提供READ或拒绝句柄开放给PUSHED中读取。如果没有提供,必须提供READ或拒绝句柄,在PUSHED中打开读取。</target>
        </trans-unit>
        <trans-unit id="d3cbfd0fcf4f24975313de4df8de49164d7ee2fd" translate="yes" xml:space="preserve">
          <source>Should return an object or the class, or -1 on failure. (Compare TIEHANDLE.) The arguments are an optional mode string (&quot;r&quot;, &quot;w&quot;, &quot;w+&quot;, ...) and a filehandle for the PerlIO layer below. Mandatory.</source>
          <target state="translated">应该返回一个对象或类,失败时返回-1。(比较TIEHANDLE。)参数是一个可选的模式字符串(&quot;r&quot;,&quot;w&quot;,&quot;w+&quot;,...)和下面PerlIO层的filehandle。必备。</target>
        </trans-unit>
        <trans-unit id="5642f34ce9dcd1c3ffa2dfc0c58640c6cb31044d" translate="yes" xml:space="preserve">
          <source>Should the $prefix fail to match</source>
          <target state="translated">如果$prefix不符合</target>
        </trans-unit>
        <trans-unit id="1690346ded0caeaa5dcdd766cbbfd423effb3884" translate="yes" xml:space="preserve">
          <source>Should yield no problems with AIX 5.1 / 5.2 / 5.3 / 6.1 / 7.1.</source>
          <target state="translated">在AIX 5.1/5.2/5.3/6.1/7.1的情况下应该不会产生问题。</target>
        </trans-unit>
        <trans-unit id="377f03a2a4c9b170d5d73c84fdd0fa6c29b00142" translate="yes" xml:space="preserve">
          <source>Should yield no problems.</source>
          <target state="translated">应该不会产生问题。</target>
        </trans-unit>
        <trans-unit id="35f86593f3a7cab63ebec9bff3335371662e4b80" translate="yes" xml:space="preserve">
          <source>Should you be stuck with an ancient version of git (prior to 1.7), then &lt;code&gt;git push&lt;/code&gt; will not have the &lt;code&gt;-u&lt;/code&gt; switch, and you have to replace the last step with the following sequence:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b16df946245605727ff1e16d4791f2bf174400d" translate="yes" xml:space="preserve">
          <source>Should you wish to build a statically-linked executable on a system which can dynamically load libraries, you may, in all the following examples, where the command &quot;&lt;code&gt;make&lt;/code&gt; &quot; with no arguments is executed, run the command &quot;&lt;code&gt;make perl&lt;/code&gt; &quot; instead.</source>
          <target state="translated">如果希望在可以动态加载库的系统上构建静态链接的可执行文件，则在以下所有示例中，如果执行不带参数的命令&amp;ldquo; &lt;code&gt;make&lt;/code&gt; &amp;rdquo;，请运行命令&amp;ldquo; &lt;code&gt;make perl&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="398654e660729596cb8454b7f800d571ef53f379" translate="yes" xml:space="preserve">
          <source>Should you wish to build a statically-linked executable on a system which can dynamically load libraries, you may, in all the following examples, where the command &quot;&lt;code&gt;make&lt;/code&gt;&quot; with no arguments is executed, run the command &quot;&lt;code&gt;make perl&lt;/code&gt;&quot; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad198af5ed254b36c0129bab30cb66de4af9306" translate="yes" xml:space="preserve">
          <source>Show all individual modules that have a $VERSION of zero?</source>
          <target state="translated">显示所有单个模块的$VERSION为0?</target>
        </trans-unit>
        <trans-unit id="5886e6a19b112ccca7d7e5c6a420d33f7dc320f4" translate="yes" xml:space="preserve">
          <source>Show all individual modules that have no $VERSION?</source>
          <target state="translated">显示所有没有$VERSION?</target>
        </trans-unit>
        <trans-unit id="432657faf9897211c68f4ccc299c680506ae0f85" translate="yes" xml:space="preserve">
          <source>Show lexical variables used in functions or files</source>
          <target state="translated">显示函数或文件中使用的词汇变量</target>
        </trans-unit>
        <trans-unit id="15563729135e9ba264fbcba30a709d66c8a1dd93" translate="yes" xml:space="preserve">
          <source>Show test comments (this is a no-op if &lt;code&gt;verbose&lt;/code&gt; is selected).</source>
          <target state="translated">显示测试注释（如果选择了 &lt;code&gt;verbose&lt;/code&gt; 则为空操作）。</target>
        </trans-unit>
        <trans-unit id="453672f22864e2ecabd52010a0251f21457a02b2" translate="yes" xml:space="preserve">
          <source>Show test failures (this is a no-op if &lt;code&gt;verbose&lt;/code&gt; is selected).</source>
          <target state="translated">显示测试失败（如果选择了 &lt;code&gt;verbose&lt;/code&gt; 则为空操作）。</target>
        </trans-unit>
        <trans-unit id="25af3a88c3b3773349dd8ac90b045308d5492ec5" translate="yes" xml:space="preserve">
          <source>Show the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ccbb891469b1a972be7b689b1ec1c7304ecb2a" translate="yes" xml:space="preserve">
          <source>Show the module details. This prints one line for each out-of-date module (meaning, modules locally installed but have newer versions on CPAN). Each line has three columns: module name, local version, and CPAN version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad96a4d0e92d1a92a25032d1a69981cb8c4094d" translate="yes" xml:space="preserve">
          <source>Show the out-of-date modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3deb58d49160799c00454338107f604ea794ed5" translate="yes" xml:space="preserve">
          <source>Show usage.</source>
          <target state="translated">显示用途。</target>
        </trans-unit>
        <trans-unit id="7222550b5b66397acb151415418533c6a8f6f5fe" translate="yes" xml:space="preserve">
          <source>ShowMode</source>
          <target state="translated">ShowMode</target>
        </trans-unit>
        <trans-unit id="66970db782112b1077801cd655daa3c67c2cdecf" translate="yes" xml:space="preserve">
          <source>Shows if the given module is primarily maintained in perl core or on CPAN and bug tracker URL.</source>
          <target state="translated">显示给定的模块是否主要在perl core或CPAN和bug跟踪器URL上维护。</target>
        </trans-unit>
        <trans-unit id="ab7d18eafb7bcc2a74ee000087e57646aecc2b0d" translate="yes" xml:space="preserve">
          <source>Shows the primary maintainers for the specified modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a820735e69e06ccea6cc9de4ba8697b78a4549" translate="yes" xml:space="preserve">
          <source>Shuts down a Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt; for a tutorial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac75e459283e311c2d85839794c7648cec7df9c2" translate="yes" xml:space="preserve">
          <source>Shuts down a Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">关闭Perl解释器。见&lt;a href=&quot;perlembed&quot;&gt;临危&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90e62e13ea37ff3f7a2ddce5609c724fd7e64daf" translate="yes" xml:space="preserve">
          <source>Shuts down a socket connection in the manner indicated by HOW, which has the same interpretation as in the syscall of the same name.</source>
          <target state="translated">以HOW表示的方式关闭一个套接字连接,其解释与同名syscall相同。</target>
        </trans-unit>
        <trans-unit id="7187637d0f34c57d8bea4681c13bb60273e1f7d1" translate="yes" xml:space="preserve">
          <source>Shuts down a socket connection in the manner indicated by the value passed in, which has the same interpretation as in the syscall of the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de95fa319fad54d4fda1efff03c4320b4f1bbba0" translate="yes" xml:space="preserve">
          <source>Shutsdown the specified MACHINE, notifying users with the supplied MESSAGE, within the specified TIMEOUT interval. Forces closing of all documents without prompting the user if FORCECLOSE is true, and reboots the machine if REBOOT is true. This function works only on WinNT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3d8d665a765918b70a3f5f0378d51df00b92dd" translate="yes" xml:space="preserve">
          <source>Sign</source>
          <target state="translated">Sign</target>
        </trans-unit>
        <trans-unit id="27bed13a88c60350c3de92ec3820e1cc4f7d6ec3" translate="yes" xml:space="preserve">
          <source>Signal</source>
          <target state="translated">Signal</target>
        </trans-unit>
        <trans-unit id="76e3a47c3cea2b4bc39210e8f1a7a4f458325f46" translate="yes" xml:space="preserve">
          <source>Signal flag. Will be set to a true value if a signal was caught. Clients may check for this flag to abort time-consuming operations.</source>
          <target state="translated">信号标志。如果捕捉到信号,将被设置为真值。客户端可以检查这个标志来中止耗时的操作。</target>
        </trans-unit>
        <trans-unit id="47e8409eab6e54647df4cb7cecc41ee28c30a02b" translate="yes" xml:space="preserve">
          <source>Signal handlers deal with signal names, not numbers. Use &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; to find their names on your system.</source>
          <target state="translated">信号处理程序处理信号名称，而不是数字。使用 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; 在系统上找到它们的名称。</target>
        </trans-unit>
        <trans-unit id="f793004ac2bfb867d7b8c1fed8ccaa1370121adc" translate="yes" xml:space="preserve">
          <source>Signal handlers deal with signal names, not numbers. Use &lt;code&gt;kill -l&lt;/code&gt; to find their names on your system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89722759e06611996072c09d8d893f78366be03" translate="yes" xml:space="preserve">
          <source>Signal handlers need to be set up in the threads for the signals they are expected to act upon. Here's an example for</source>
          <target state="translated">信号处理程序需要在线程中为它们要执行的信号设置。下面是一个例子</target>
        </trans-unit>
        <trans-unit id="4c81c67cfc40c99d8beeb124cd5a299ed53f7fa3" translate="yes" xml:space="preserve">
          <source>Signal handling is also used for timeouts in Unix. While safely protected within an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; block, you set a signal handler to trap alarm signals and then schedule to have one delivered to you in some number of seconds. Then try your blocking operation, clearing the alarm when it's done but not before you've exited your &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; block. If it goes off, you'll use die() to jump out of the block.</source>
          <target state="translated">信号处理也用于Unix中的超时。在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 块中受到安全保护的同时，您可以设置信号处理程序以捕获警报信号，然后计划在几秒钟内将信号传递给您。然后尝试您的阻止操作，在完成警报后清除警报，但在退出 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 块之前不要清除警报。如果不成功，您将使用die（）跳出该块。</target>
        </trans-unit>
        <trans-unit id="d4984dbb18bb8f6d69231c1c5402b289b6cae3fd" translate="yes" xml:space="preserve">
          <source>Signal handling is also used for timeouts in Unix. While safely protected within an &lt;code&gt;eval{}&lt;/code&gt; block, you set a signal handler to trap alarm signals and then schedule to have one delivered to you in some number of seconds. Then try your blocking operation, clearing the alarm when it's done but not before you've exited your &lt;code&gt;eval{}&lt;/code&gt; block. If it goes off, you'll use die() to jump out of the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9cd055a7cd87b137130bb8b93c1c2e53904764f" translate="yes" xml:space="preserve">
          <source>Signal handling may not behave as on Unix platforms (where it doesn't exactly &quot;behave&quot;, either :). For instance, calling &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; from signal handlers will cause an exception, since most implementations of &lt;code&gt;signal()&lt;/code&gt; on Windows are severely crippled. Thus, signals may work only for simple things like setting a flag variable in the handler. Using signals under this port should currently be considered unsupported.</source>
          <target state="translated">信号处理的行为可能不如Unix平台（在此也不完全是&amp;ldquo;行为&amp;rdquo; ：）。例如，从信号处理程序调用 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 会导致异常，因为Windows上的 &lt;code&gt;signal()&lt;/code&gt; 的大多数实现都受到严重破坏。因此，信号仅可用于简单的事情，例如在处理程序中设置标志变量。当前应认为不支持在此端口下使用信号。</target>
        </trans-unit>
        <trans-unit id="a87648f8ff8510d519181cee20c22a292d601e89" translate="yes" xml:space="preserve">
          <source>Signal handling may not behave as on Unix platforms (where it doesn't exactly &quot;behave&quot;, either :). For instance, calling &lt;code&gt;die()&lt;/code&gt; or &lt;code&gt;exit()&lt;/code&gt; from signal handlers will cause an exception, since most implementations of &lt;code&gt;signal()&lt;/code&gt; on Windows are severely crippled. Thus, signals may work only for simple things like setting a flag variable in the handler. Using signals under this port should currently be considered unsupported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6c417fd537a17b001daa7dbea3a3b50cef51ef" translate="yes" xml:space="preserve">
          <source>Signal number zero may fail because you lack permission to send the signal when directed at a process whose real or saved UID is not identical to the real or effective UID of the sending process, even though the process is alive. You may be able to determine the cause of failure using &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;%!&lt;/code&gt; .</source>
          <target state="translated">零号信号可能会失败，因为当您定向到其实际或保存的UID与发送过程的实际或有效UID不相同的进程时，即使该进程处于活动状态，您也无法发送信号。您可以使用 &lt;code&gt;$!&lt;/code&gt; 确定故障原因！或 &lt;code&gt;%!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2252f0feffa6900d113f918d18d91c133bf55365" translate="yes" xml:space="preserve">
          <source>Signal number zero may fail because you lack permission to send the signal when directed at a process whose real or saved UID is not identical to the real or effective UID of the sending process, even though the process is alive. You may be able to determine the cause of failure using &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;%!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="fec07adfbf089fdf5b54412a5f3085422a9dd0ae" translate="yes" xml:space="preserve">
          <source>Signals are</source>
          <target state="translated">信号是</target>
        </trans-unit>
        <trans-unit id="fe837ae8c05b966bdccbee31fe8ed0fe5d881059" translate="yes" xml:space="preserve">
          <source>Signals as &quot;faults&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43861fb85280c34c4b0e58573e896842254a1d10" translate="yes" xml:space="preserve">
          <source>Signals in Plan 9 Perl</source>
          <target state="translated">Plan 9 Perl中的信号</target>
        </trans-unit>
        <trans-unit id="259b4915ff9abfbb2a728a264509dffb23aed5c4" translate="yes" xml:space="preserve">
          <source>Signals that are intercepted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2f061cd789264d5433118e03b134a8734af9d2" translate="yes" xml:space="preserve">
          <source>Signals triggered by operating system state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4cf0392296064579858651f856889aadbc2805e" translate="yes" xml:space="preserve">
          <source>Signatures</source>
          <target state="translated">Signatures</target>
        </trans-unit>
        <trans-unit id="d9d7c542958055b1904998cdb447122ec36a75ab" translate="yes" xml:space="preserve">
          <source>Signed bitwise operators.</source>
          <target state="translated">符号位运算符。</target>
        </trans-unit>
        <trans-unit id="2622f509b356185fe6a42f6313ddbc8e57057af2" translate="yes" xml:space="preserve">
          <source>Significant performance improvements</source>
          <target state="translated">性能显著提高</target>
        </trans-unit>
        <trans-unit id="ae6207f79c10c58b3e0ef4c08bbf6c86acc82fd9" translate="yes" xml:space="preserve">
          <source>Signum function. Set the number to -1, 0, or 1, depending on whether the number is negative, zero, or positive, respectively. Does not modify NaNs.</source>
          <target state="translated">符号功能。根据数字是负数、零、还是正数,分别设置为-1、0、1。不修改NaNs。</target>
        </trans-unit>
        <trans-unit id="31506097adfa948440134c0119e5a52038393445" translate="yes" xml:space="preserve">
          <source>Silberschatz, Abraham, and Peter B. Galvin. Operating System Concepts, 4th ed. Addison-Wesley, 1995, ISBN 0-201-59292-4</source>
          <target state="translated">Silberschatz,Abraham,and Peter B.Galvin.操作系统概念》,第4版。Addison-Wesley,1995年,ISBN 0-201-59292-4。</target>
        </trans-unit>
        <trans-unit id="c1200bf449b67efb756e3194a25dcba2a224c7bd" translate="yes" xml:space="preserve">
          <source>Similar in functionality to &lt;a href=&quot;perlfunc#recv&quot;&gt;&quot;recv&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf91ecf8b9db2d36c3c4af1dda8c5294da5403f" translate="yes" xml:space="preserve">
          <source>Similar in functionality to &lt;a href=&quot;perlfunc#send&quot;&gt;&quot;send&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4b469b48eb970781d347cff775a6eb6ed07b9c" translate="yes" xml:space="preserve">
          <source>Similar problems can occur when storing &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; in HVs:</source>
          <target state="translated">在HV中存储 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 时，可能会发生类似的问题：</target>
        </trans-unit>
        <trans-unit id="0939c3fe5c0d5d2bff40d1b5db20a06321bba976" translate="yes" xml:space="preserve">
          <source>Similar to</source>
          <target state="translated">类似于</target>
        </trans-unit>
        <trans-unit id="ca29a7deeeb800f3b647ae8e447ace2495bd48e6" translate="yes" xml:space="preserve">
          <source>Similar to &quot;CHECK&quot;, but for &lt;code&gt;INIT&lt;/code&gt; -blocks, not &lt;code&gt;CHECK&lt;/code&gt; blocks.</source>
          <target state="translated">与&amp;ldquo; CHECK&amp;rdquo;类似，但是对于 &lt;code&gt;INIT&lt;/code&gt; -blocks，不是 &lt;code&gt;CHECK&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="f5ec53f333f04a2995b3e086134767c778243eaa" translate="yes" xml:space="preserve">
          <source>Similar to &quot;CHECK&quot;, but for &lt;code&gt;INIT&lt;/code&gt;-blocks, not &lt;code&gt;CHECK&lt;/code&gt; blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a02dc2c9e4fd99225658784381bc57431376c4f2" translate="yes" xml:space="preserve">
          <source>Similar to $io-&amp;gt;seek, but sets the IO::File's position using the system call lseek(2) directly, so will confuse most perl IO operators except sysread and syswrite (see &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; for full details)</source>
          <target state="translated">与$ io-&amp;gt; seek相似，但是直接使用系统调用lseek（2）设置IO :: File的位置，因此会混淆大多数perl IO操作符，但sysread和syswrite除外（有关详细信息，请参阅&lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="68c4347f8fea5b416312257ca34ba342de4d10b9" translate="yes" xml:space="preserve">
          <source>Similar to $io-&amp;gt;seek, but sets the IO::File's position using the system call lseek(2) directly, so will confuse most perl IO operators except sysread and syswrite (see &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for full details)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a39eaf579340710bf4bd0f530bd675ee9e7a95" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#any&quot;&gt;&quot;any&quot;&lt;/a&gt; and &lt;a href=&quot;#all&quot;&gt;&quot;all&quot;&lt;/a&gt;, but with the return sense inverted. &lt;code&gt;none&lt;/code&gt; returns true only if no value in the &lt;code&gt;@list&lt;/code&gt; causes the &lt;code&gt;BLOCK&lt;/code&gt; to return true, and &lt;code&gt;notall&lt;/code&gt; returns true only if not all of the values do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48998732d2d944be662f876c6215817f6203f325" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#any&quot;&gt;&quot;any&quot;&lt;/a&gt;, except that it requires all elements of the &lt;code&gt;@list&lt;/code&gt; to make the &lt;code&gt;BLOCK&lt;/code&gt; return true. If any element returns false, then it returns false. If the &lt;code&gt;BLOCK&lt;/code&gt; never returns false or the &lt;code&gt;@list&lt;/code&gt; was empty then it returns true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeabee18f75813e1d32d468eb7ba172bf546eaed" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#any&quot;&gt;any&lt;/a&gt; and &lt;a href=&quot;#all&quot;&gt;all&lt;/a&gt;, but with the return sense inverted. &lt;code&gt;none&lt;/code&gt; returns true only if no value in the &lt;code&gt;@list&lt;/code&gt; causes the &lt;code&gt;BLOCK&lt;/code&gt; to return true, and &lt;code&gt;notall&lt;/code&gt; returns true only if not all of the values do.</source>
          <target state="translated">类似&lt;a href=&quot;#any&quot;&gt;的任何&lt;/a&gt;和&lt;a href=&quot;#all&quot;&gt;所有的&lt;/a&gt;，但倒回的感觉。 &lt;code&gt;none&lt;/code&gt; 返回true只有在没有价值 &lt;code&gt;@list&lt;/code&gt; 导致 &lt;code&gt;BLOCK&lt;/code&gt; 返回true，并 &lt;code&gt;notall&lt;/code&gt; 返回true，只有当不是所有的价值做。</target>
        </trans-unit>
        <trans-unit id="e0b3d2d208d62b5b40ff53db1e72a57e69459f20" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#any&quot;&gt;any&lt;/a&gt;, except that it requires all elements of the &lt;code&gt;@list&lt;/code&gt; to make the &lt;code&gt;BLOCK&lt;/code&gt; return true. If any element returns false, then it returns false. If the &lt;code&gt;BLOCK&lt;/code&gt; never returns false or the &lt;code&gt;@list&lt;/code&gt; was empty then it returns true.</source>
          <target state="translated">类似于&lt;a href=&quot;#any&quot;&gt;any&lt;/a&gt;，除了它需要 &lt;code&gt;@list&lt;/code&gt; 的所有元素以使 &lt;code&gt;BLOCK&lt;/code&gt; 返回true。如果任何元素返回false，则返回false。如果 &lt;code&gt;BLOCK&lt;/code&gt; 从不返回false或 &lt;code&gt;@list&lt;/code&gt; 为空，则返回true。</target>
        </trans-unit>
        <trans-unit id="4be8eb83dc7372a8ceafe2d398607db21cbd0df8" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#max&quot;&gt;&quot;max&quot;&lt;/a&gt; but returns the entry in the list with the lowest numerical value. If the list is empty then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfcb2ef3c4104f74e02c3a234af9ace81a7ab965" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#max&quot;&gt;&quot;max&quot;&lt;/a&gt;, but treats all the entries in the list as strings and returns the highest string as defined by the &lt;code&gt;gt&lt;/code&gt; operator. If the list is empty then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9665cd00110ac2a060c12898dd3b9d89a35f309" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#max&quot;&gt;max&lt;/a&gt; but returns the entry in the list with the lowest numerical value. If the list is empty then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">与&lt;a href=&quot;#max&quot;&gt;max&lt;/a&gt;相似，但返回列表中具有最低数值的条目。如果列表为空，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1acc3d00496e9a8972d2b21602c04ac03da5cacb" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#max&quot;&gt;max&lt;/a&gt;, but treats all the entries in the list as strings and returns the highest string as defined by the &lt;code&gt;gt&lt;/code&gt; operator. If the list is empty then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">与&lt;a href=&quot;#max&quot;&gt;max&lt;/a&gt;相似，但是将列表中的所有条目都视为字符串，并返回 &lt;code&gt;gt&lt;/code&gt; 运算符定义的最高字符串。如果列表为空，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cfb0f506a775b443c104de0b0c91306a78f551b3" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#min&quot;&gt;&quot;min&quot;&lt;/a&gt;, but treats all the entries in the list as strings and returns the lowest string as defined by the &lt;code&gt;lt&lt;/code&gt; operator. If the list is empty then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a68b93abd1f3ba4015d6e167facf857ecad51b4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#min&quot;&gt;min&lt;/a&gt;, but treats all the entries in the list as strings and returns the lowest string as defined by the &lt;code&gt;lt&lt;/code&gt; operator. If the list is empty then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">与&lt;a href=&quot;#min&quot;&gt;min&lt;/a&gt;相似，但是将列表中的所有条目都视为字符串，并返回由 &lt;code&gt;lt&lt;/code&gt; 运算符定义的最低字符串。如果列表为空，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ecb07a28c8b871910322942b1bd79e2ea6e867f" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#sum&quot;&gt;&quot;sum&quot;&lt;/a&gt;, except this returns 0 when given an empty list, rather than &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720744a95bf0e839c040c184fab6270aac42881d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#sum&quot;&gt;sum&lt;/a&gt;, except this returns 0 when given an empty list, rather than &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#sum&quot;&gt;sum&lt;/a&gt;相似，除了在给定空列表而不是 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 时返回0 。</target>
        </trans-unit>
        <trans-unit id="de0c5d81a8f59f78025d72fb656f559ed47e0b02" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;%+&lt;/code&gt; , this variable allows access to the named capture groups in the last successful match in the currently active dynamic scope. To each capture group name found in the regular expression, it associates a reference to an array containing the list of values captured by all buffers with that name (should there be several of them), in the order where they appear.</source>
          <target state="translated">与 &lt;code&gt;%+&lt;/code&gt; 相似，此变量允许访问当前活动动态范围中的最后一次成功匹配中的命名捕获组。对于在正则表达式中找到的每个捕获组名称，它将引用与包含该名称（应有多个）的所有缓冲区捕获的值列表的数组相关联（按它们出现的顺序）。</target>
        </trans-unit>
        <trans-unit id="fc5cb74e6a15c2726021f737c1b80fe548fe2cc2" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;%+&lt;/code&gt;, this variable allows access to the named capture groups in the last successful match in the currently active dynamic scope. To each capture group name found in the regular expression, it associates a reference to an array containing the list of values captured by all buffers with that name (should there be several of them), in the order where they appear.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc471f756f7e6a826fb6380627738dab038925d3" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;(??{ &lt;i&gt;code&lt;/i&gt; })&lt;/code&gt; except that it does not involve executing any code or potentially compiling a returned pattern string; instead it treats the part of the current pattern contained within a specified capture group as an independent pattern that must match at the current position. Also different is the treatment of capture buffers, unlike &lt;code&gt;(??{ &lt;i&gt;code&lt;/i&gt; })&lt;/code&gt; recursive patterns have access to their caller's match state, so one can use backreferences safely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e85d1cf5a45c378c11b14a61c254003e40f86d06" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;(??{ code })&lt;/code&gt; except that it does not involve executing any code or potentially compiling a returned pattern string; instead it treats the part of the current pattern contained within a specified capture group as an independent pattern that must match at the current position. Also different is the treatment of capture buffers, unlike &lt;code&gt;(??{ code })&lt;/code&gt; recursive patterns have access to their callers match state, so one can use backreferences safely.</source>
          <target state="translated">与 &lt;code&gt;(??{ code })&lt;/code&gt; 类似，不同之处在于它不涉及执行任何代码或潜在地编译返回的模式字符串；相反，它将包含在指定捕获组中的当前模式部分视为必须在当前位置匹配的独立模式。捕获缓冲区的处理也有所不同，与 &lt;code&gt;(??{ code })&lt;/code&gt; 递归模式可以访问其调用者的匹配状态不同，因此可以安全地使用反向引用。</target>
        </trans-unit>
        <trans-unit id="7b5e1028f59af1e35880841b72d98eb83a4ac03c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;(R1)&lt;/code&gt; , this predicate checks to see if we're executing directly inside of the leftmost group with a given name (this is the same logic used by &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt; to disambiguate). It does not check the full stack, but only the name of the innermost active recursion.</source>
          <target state="translated">与 &lt;code&gt;(R1)&lt;/code&gt; 相似，此谓词检查是否在给定名称的最左边的组中直接执行（这与 &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt; 用于消除歧义的逻辑相同）。它不检查完整堆栈，仅检查最内部活动递归的名称。</target>
        </trans-unit>
        <trans-unit id="a58b4285d54a7974cddfaf2830c81dd7d35f40eb" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;(R1)&lt;/code&gt;, this predicate checks to see if we're executing directly inside of the leftmost group with a given name (this is the same logic used by &lt;code&gt;(?&amp;amp;&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; to disambiguate). It does not check the full stack, but only the name of the innermost active recursion. Full syntax: &lt;code&gt;(?(R&amp;amp;&lt;i&gt;name&lt;/i&gt;)&lt;i&gt;then&lt;/i&gt;|&lt;i&gt;else&lt;/i&gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d819c8539b4d29d94e8d4689944b0f7272e6c433" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in that it evaluates &lt;code&gt;BLOCK&lt;/code&gt; setting &lt;code&gt;$_&lt;/code&gt; to each element of &lt;code&gt;@list&lt;/code&gt; in turn. &lt;code&gt;any&lt;/code&gt; returns true if any element makes the &lt;code&gt;BLOCK&lt;/code&gt; return a true value. If &lt;code&gt;BLOCK&lt;/code&gt; never returns true or &lt;code&gt;@list&lt;/code&gt; was empty then it returns false.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 相似，它依次评估对 &lt;code&gt;@list&lt;/code&gt; 的每个元素的 &lt;code&gt;BLOCK&lt;/code&gt; 设置 &lt;code&gt;$_&lt;/code&gt; 。 &lt;code&gt;any&lt;/code&gt; 如有元素使返回true &lt;code&gt;BLOCK&lt;/code&gt; 返回真值。如果 &lt;code&gt;BLOCK&lt;/code&gt; 从不返回true或 &lt;code&gt;@list&lt;/code&gt; 为空，则返回false。</target>
        </trans-unit>
        <trans-unit id="309f2e4aced8f70bc86983e34f644c5eeda43d60" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in that it evaluates &lt;code&gt;BLOCK&lt;/code&gt; setting &lt;code&gt;$_&lt;/code&gt; to each element of &lt;code&gt;@list&lt;/code&gt; in turn. &lt;code&gt;first&lt;/code&gt; returns the first element where the result from &lt;code&gt;BLOCK&lt;/code&gt; is a true value. If &lt;code&gt;BLOCK&lt;/code&gt; never returns true or &lt;code&gt;@list&lt;/code&gt; was empty then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 相似，它依次评估对 &lt;code&gt;@list&lt;/code&gt; 的每个元素的 &lt;code&gt;BLOCK&lt;/code&gt; 设置 &lt;code&gt;$_&lt;/code&gt; 。 &lt;code&gt;first&lt;/code&gt; 返回第一个元素，其中 &lt;code&gt;BLOCK&lt;/code&gt; 的结果为真值。如果 &lt;code&gt;BLOCK&lt;/code&gt; 从不返回true或 &lt;code&gt;@list&lt;/code&gt; 为空，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e075f217be25d05567036ad66b6856b5e68b562" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;@+&lt;/code&gt; , the &lt;code&gt;%+&lt;/code&gt; hash allows access to the named capture buffers, should they exist, in the last successful match in the currently active dynamic scope.</source>
          <target state="translated">与 &lt;code&gt;@+&lt;/code&gt; 相似， &lt;code&gt;%+&lt;/code&gt; 哈希允许访问命名捕获缓冲区（如果存在），如果它们存在，则在当前活动动态范围的最后成功匹配中。</target>
        </trans-unit>
        <trans-unit id="c20f7b2090b36afe2f8cc1a28252ce82895a9532" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;@+&lt;/code&gt;, the &lt;code&gt;%+&lt;/code&gt; hash allows access to the named capture buffers, should they exist, in the last successful match in the currently active dynamic scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d5383c2abb4219427283869f7f92149d2a972c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;Open&lt;/code&gt; , returns PerlIO* on success, &lt;code&gt;NULL&lt;/code&gt; on failure.</source>
          <target state="translated">与 &lt;code&gt;Open&lt;/code&gt; 类似，成功时返回PerlIO *，失败时返回 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1de2fbefa7ee02f134e1d332ea00e119a6f12731" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;Open&lt;/code&gt;, returns PerlIO* on success, &lt;code&gt;NULL&lt;/code&gt; on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9b990cdb77a226953210e003d5b8ec28f7e6d4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;eq_array()&lt;/code&gt; , except the order of the elements is &lt;b&gt;not&lt;/b&gt; important. This is a deep check, but the irrelevancy of order only applies to the top level.</source>
          <target state="translated">与 &lt;code&gt;eq_array()&lt;/code&gt; 类似，除了元素的顺序&lt;b&gt;并不&lt;/b&gt;重要。这是一个深层检查，但顺序的无关性仅适用于顶层。</target>
        </trans-unit>
        <trans-unit id="c6f86f2d94dbcc71aafb977b9cc5434713d6b331" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;eq_array()&lt;/code&gt;, except the order of the elements is &lt;b&gt;not&lt;/b&gt; important. This is a deep check, but the irrelevancy of order only applies to the top level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3701740d1ad6bfc649e15fd040627ffd1f305bbb" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;grep&lt;/code&gt; in that it evaluates &lt;code&gt;BLOCK&lt;/code&gt; setting &lt;code&gt;$_&lt;/code&gt; to each element of &lt;code&gt;@list&lt;/code&gt; in turn. &lt;code&gt;any&lt;/code&gt; returns true if any element makes the &lt;code&gt;BLOCK&lt;/code&gt; return a true value. If &lt;code&gt;BLOCK&lt;/code&gt; never returns true or &lt;code&gt;@list&lt;/code&gt; was empty then it returns false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbfbf42053ee4ef8969a4fa2ee7faff4e2fb6ee2" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;grep&lt;/code&gt; in that it evaluates &lt;code&gt;BLOCK&lt;/code&gt; setting &lt;code&gt;$_&lt;/code&gt; to each element of &lt;code&gt;@list&lt;/code&gt; in turn. &lt;code&gt;first&lt;/code&gt; returns the first element where the result from &lt;code&gt;BLOCK&lt;/code&gt; is a true value. If &lt;code&gt;BLOCK&lt;/code&gt; never returns true or &lt;code&gt;@list&lt;/code&gt; was empty then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799cf1cf4afc49012909146223bfe3d0985a8027" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;htmlify()&lt;/code&gt; , but turns non-alphanumerics into underscores. Note that &lt;code&gt;anchorify()&lt;/code&gt; is not exported by default.</source>
          <target state="translated">与 &lt;code&gt;htmlify()&lt;/code&gt; 类似，但是将非字母数字转换为下划线。请注意，默认情况下不会导出 &lt;code&gt;anchorify()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c853c707bee9ff3b2aad37853128e372734e9e4d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;htmlify()&lt;/code&gt;, but turns non-alphanumerics into underscores. Note that &lt;code&gt;anchorify()&lt;/code&gt; is not exported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12c5c9a9a0658e780b40222b20b1585f58ad997" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;is()&lt;/code&gt; , except that if $got and $expected are references, it does a deep comparison walking each data structure to see if they are equivalent. If the two structures are different, it will display the place where they start differing.</source>
          <target state="translated">与 &lt;code&gt;is()&lt;/code&gt; 相似，不同之处在于如果$ got和$ expected是引用，它将对每个数据结构进行深度比较以查看它们是否等效。如果两个结构不同，它将显示它们开始不同的位置。</target>
        </trans-unit>
        <trans-unit id="5856aeb59fd6e40eddb32ad4b83e28afc3331a2a" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;is()&lt;/code&gt;, except that if $got and $expected are references, it does a deep comparison walking each data structure to see if they are equivalent. If the two structures are different, it will display the place where they start differing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a60ea110d9d9e2f388b25322faf3b4d38a6a8c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;list&lt;/code&gt; but only active groups that match the pattern are returned. &lt;code&gt;PATTERN&lt;/code&gt; can be a group pattern.</source>
          <target state="translated">与 &lt;code&gt;list&lt;/code&gt; 类似，但仅返回与模式匹配的活动组。 &lt;code&gt;PATTERN&lt;/code&gt; 可以是组模式。</target>
        </trans-unit>
        <trans-unit id="8394e4ee5f103a1c48fa6ce025d057e64f7170cc" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;lock_keys()&lt;/code&gt; , with the difference being that the optional key list specifies keys that may or may not be already in the hash. Essentially this is an easier way to say</source>
          <target state="translated">与 &lt;code&gt;lock_keys()&lt;/code&gt; 相似，不同之处在于可选密钥列表指定了可能已经或可能不在哈希中的密钥。本质上，这是一种更简单的说法</target>
        </trans-unit>
        <trans-unit id="fd28c174d303c48db24df8e8b11ae9ae4d26bc24" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;lock_keys()&lt;/code&gt;, with the difference being that the optional key list specifies keys that may or may not be already in the hash. Essentially this is an easier way to say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb0fd1c6610a16c5e7d118e0a5ba89092c8069d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;newUNOP&lt;/code&gt; , but creates an UNOP_AUX struct instead, with op_aux initialised to aux</source>
          <target state="translated">与 &lt;code&gt;newUNOP&lt;/code&gt; 相似，但是创建一个UNOP_AUX结构，而op_aux初始化为aux</target>
        </trans-unit>
        <trans-unit id="5e858708a27caba519590b6fdb8853664bd94dce" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;newUNOP&lt;/code&gt;, but creates an &lt;code&gt;UNOP_AUX&lt;/code&gt; struct instead, with &lt;code&gt;op_aux&lt;/code&gt; initialised to &lt;code&gt;aux&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc376b4266acbbeb8358039fda2afe78067b9523" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;ok()&lt;/code&gt; , &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; compare their two arguments with &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;ne&lt;/code&gt; respectively and use the result of that to determine if the test succeeded or failed. So these:</source>
          <target state="translated">与 &lt;code&gt;ok()&lt;/code&gt; 相似， &lt;code&gt;is()&lt;/code&gt; 和 &lt;code&gt;isnt()&lt;/code&gt; 分别将它们的两个参数与 &lt;code&gt;eq&lt;/code&gt; 和 &lt;code&gt;ne&lt;/code&gt; 进行比较，并使用其结果确定测试是成功还是失败。所以这些：</target>
        </trans-unit>
        <trans-unit id="2d613f276bedf9458ff8ce32e8990c5576137f0b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;ok()&lt;/code&gt; , &lt;code&gt;like()&lt;/code&gt; matches $got against the regex &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/expected/&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;ok()&lt;/code&gt; 类似， &lt;code&gt;like()&lt;/code&gt; 将$ got与regex &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/expected/&lt;/a&gt;&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="d80b81dd55578d43ab2dc56b52c4c8c56c375c2a" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;ok()&lt;/code&gt;, &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; compare their two arguments with &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;ne&lt;/code&gt; respectively and use the result of that to determine if the test succeeded or failed. So these:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b38f30f4277690cf45428e116cea438e779a9819" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;ok()&lt;/code&gt;, &lt;code&gt;like()&lt;/code&gt; matches $got against the regex &lt;code&gt;qr/expected/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f443cdf5d4202dff7105c24c5a2b89e3df5ba0b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;reduce&lt;/code&gt; except that it also returns the intermediate values along with the final result. As before, &lt;code&gt;$a&lt;/code&gt; is set to the first element of the given list, and the &lt;code&gt;BLOCK&lt;/code&gt; is then called once for remaining item in the list set into &lt;code&gt;$b&lt;/code&gt;, with the result being captured for return as well as becoming the new value for &lt;code&gt;$a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050d8bfd9d6dd81a6f8789b0e8d9cd7b8f6780b4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_scalar&lt;/code&gt; , but localize &lt;code&gt;@gv&lt;/code&gt; and &lt;code&gt;%gv&lt;/code&gt; .</source>
          <target state="translated">与 &lt;code&gt;save_scalar&lt;/code&gt; 相似，但是将 &lt;code&gt;@gv&lt;/code&gt; 和 &lt;code&gt;%gv&lt;/code&gt; 本地化。</target>
        </trans-unit>
        <trans-unit id="07501a6bba290a81025a9cc58f969fd7da78b384" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_scalar&lt;/code&gt; , but will reinstate an &lt;code&gt;SV *&lt;/code&gt; .</source>
          <target state="translated">与 &lt;code&gt;save_scalar&lt;/code&gt; 类似，但是将恢复 &lt;code&gt;SV *&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="657ba45f71ac8c697cb507869c08178c868c5018" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_scalar&lt;/code&gt;, but localize &lt;code&gt;@gv&lt;/code&gt; and &lt;code&gt;%gv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd7eb38494553782c4863edc348cc1335774a8b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_scalar&lt;/code&gt;, but will reinstate an &lt;code&gt;SV *&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1390e677f6a0ebeb104aa1d188d2523b30d8bc4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_svref&lt;/code&gt; , but localize &lt;code&gt;AV *&lt;/code&gt; and &lt;code&gt;HV *&lt;/code&gt; .</source>
          <target state="translated">与 &lt;code&gt;save_svref&lt;/code&gt; 相似，但是将 &lt;code&gt;AV *&lt;/code&gt; 和 &lt;code&gt;HV *&lt;/code&gt; 本地化。</target>
        </trans-unit>
        <trans-unit id="4f3780c5e475fc5db102e3fd087d1848086a6f08" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_svref&lt;/code&gt;, but localize &lt;code&gt;AV *&lt;/code&gt; and &lt;code&gt;HV *&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdee7e1885c1d2ec3f4e4850b44e46e9ebce62cc" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;unlink0&lt;/code&gt; except after file comparison using cmpstat, the filehandle is closed prior to attempting to unlink the file. This allows the file to be removed without using an END block, but does mean that the post-unlink comparison of the filehandle state provided by &lt;code&gt;unlink0&lt;/code&gt; is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf1c2a19f0b0ee74a54bd214a8ec4d84f8e3cf9" translate="yes" xml:space="preserve">
          <source>Similar to C</source>
          <target state="translated">与C相似</target>
        </trans-unit>
        <trans-unit id="a64ea60affb2a9690ec81f413108d64202543e9b" translate="yes" xml:space="preserve">
          <source>Similar to T_PTR except that the pointer is stored in a scalar and the reference to that scalar is returned to the caller. This can be used to hide the actual pointer value from the programmer since it is usually not required directly from within perl.</source>
          <target state="translated">类似于T_PTR,除了指针被存储在一个标量中,而对该标量的引用被返回给调用者。这可以用来向程序员隐藏实际的指针值,因为在perl中通常不需要直接使用它。</target>
        </trans-unit>
        <trans-unit id="4ed1b14b67aa9193491a3dd6d65f8409d185456b" translate="yes" xml:space="preserve">
          <source>Similar to T_PTROBJ in that the pointer is blessed into a scalar object. The difference is that when the object is passed back into XS it must be of the correct type (inheritance is not supported) while T_PTROBJ supports inheritance.</source>
          <target state="translated">与T_PTROBJ类似,指针被祝福成一个标量对象。不同的是,当对象传回XS时,它必须是正确的类型(不支持继承),而T_PTROBJ支持继承。</target>
        </trans-unit>
        <trans-unit id="98345bece5539f546d5a8e96d6aece125a75354c" translate="yes" xml:space="preserve">
          <source>Similar to T_PTRREF except that the reference is blessed into a class. This allows the pointer to be used as an object. Most commonly used to deal with C structs. The typemap checks that the perl object passed into the XS routine is of the correct class (or part of a subclass).</source>
          <target state="translated">类似于T_PTRREF,除了引用被祝福成一个类。这使得指针可以作为一个对象使用。最常用于处理C结构。类型映射检查传递到XS例程中的perl对象是否属于正确的类(或子类的一部分)。</target>
        </trans-unit>
        <trans-unit id="a0e3f786e5320b6b926d5843480fabad22b49df4" translate="yes" xml:space="preserve">
          <source>Similar to T_PTRREF, except the pointer stored in the referenced scalar is dereferenced and copied to the output variable. This means that T_REFREF is to T_PTRREF as T_OPAQUE is to T_OPAQUEPTR. All clear?</source>
          <target state="translated">类似于T_PTRREF,除了存储在被引用标量中的指针被取消引用并复制到输出变量中。这意味着T_REFREF之于T_PTRREF就像T_OPAQUE之于T_OPAQUEPTR一样。都清楚了吗?</target>
        </trans-unit>
        <trans-unit id="316a66a038c9003e3588353dd7b06b4570041574" translate="yes" xml:space="preserve">
          <source>Similar to key/value hash slices (and also introduced in Perl 5.20), the % array slice syntax returns a list of index/value pairs:</source>
          <target state="translated">类似于键/值哈希分片(在Perl 5.20中也有介绍),%数组分片语法返回一个索引/值对的列表。</target>
        </trans-unit>
        <trans-unit id="fcdb3335ff45dd421a45fea8e6567734b9ec0cac" translate="yes" xml:space="preserve">
          <source>Similar to mkstemp(), except that an extra argument can be supplied with a suffix to be appended to the template.</source>
          <target state="translated">类似于mkstemp(),只是可以提供一个额外的参数,并在模板中添加一个后缀。</target>
        </trans-unit>
        <trans-unit id="4cf9bfb3c81fe1275534c974c84d67c5db310bda" translate="yes" xml:space="preserve">
          <source>Similar to perl's &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; keyword, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in scalar context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt; .</source>
          <target state="translated">与perl的 &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 关键字相似，但是将给定列表解释为偶数大小的对列表。它在标量上下文中多次调用 &lt;code&gt;BLOCK&lt;/code&gt; ，并将 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 设置为 &lt;code&gt;@kvlist&lt;/code&gt; 中的连续值对。</target>
        </trans-unit>
        <trans-unit id="20605e6412e378f2426dfa2ecf790a73c30912ee" translate="yes" xml:space="preserve">
          <source>Similar to perl's &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; keyword, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in list context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt; .</source>
          <target state="translated">与perl的 &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 关键字相似，但是将给定列表解释为偶数大小的对列表。它在列表上下文中多次调用 &lt;code&gt;BLOCK&lt;/code&gt; ，并将 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 设置为 &lt;code&gt;@kvlist&lt;/code&gt; 中的连续值对。</target>
        </trans-unit>
        <trans-unit id="c8dc38a4899c208d20a94f1397e679f06553d540" translate="yes" xml:space="preserve">
          <source>Similar to perl's &lt;code&gt;grep&lt;/code&gt; keyword, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in scalar context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6971d89c696879a9eeb673adbf4f23a22af252ce" translate="yes" xml:space="preserve">
          <source>Similar to perl's &lt;code&gt;map&lt;/code&gt; keyword, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in list context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e0979e74abc467bf78f9a39fbc983727e9baaf" translate="yes" xml:space="preserve">
          <source>Similar to strings, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt; acts like apostrophes on a regexp; all other &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; delimiters act like quotes. If the regexp evaluates to the empty string, the regexp in the</source>
          <target state="translated">与字符串相似， &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt; 的作用类似于正则表达式上的撇号；所有其他 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 个定界符的作用就像引号。如果regexp计算为空字符串，则</target>
        </trans-unit>
        <trans-unit id="19b88f89de77da98af72b4163220db2f0a7c8ecd" translate="yes" xml:space="preserve">
          <source>Similar to strings, &lt;code&gt;m''&lt;/code&gt; acts like apostrophes on a regexp; all other &lt;code&gt;'m'&lt;/code&gt; delimiters act like quotes. If the regexp evaluates to the empty string, the regexp in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82cc003c44f0253412b5190a2e4c975c854a684" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#first&quot;&gt;&quot;first&quot;&lt;/a&gt; function, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in scalar context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ef33d2521670adf2f6b3cf61cae1999ab3778c" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#first&quot;&gt;first&lt;/a&gt; function, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in scalar context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt; .</source>
          <target state="translated">与第&lt;a href=&quot;#first&quot;&gt;一个&lt;/a&gt;函数相似，但是将给定列表解释为偶数大小的对列表。它在标量上下文中多次调用 &lt;code&gt;BLOCK&lt;/code&gt; ，并将 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 设置为 &lt;code&gt;@kvlist&lt;/code&gt; 中的连续值对。</target>
        </trans-unit>
        <trans-unit id="f852487d7b194c670f738b8370d3735ea507b49e" translate="yes" xml:space="preserve">
          <source>Similar to the above, a sigil, followed by bareword text in braces, where the first character is a caret. The next character is any one of the characters &lt;code&gt;[][A-Z^_?\]&lt;/code&gt;, followed by ASCII word characters. An example is &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0747626402d2dd7f7c45b97cc24e9304db46b6d7" translate="yes" xml:space="preserve">
          <source>Similar to the above, a sigil, followed by bareword text in brackets, where the first character is either a caret followed by an uppercase letter, like &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; or a non-&lt;code&gt;NUL&lt;/code&gt; , non-space literal control like &lt;code&gt;${\7LOBAL_PHASE}&lt;/code&gt; . Like the above, when not under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; , the characters in &lt;code&gt;[0x80-0xFF]&lt;/code&gt; are considered controls, but as of v5.22, the use of any that are non-graphical are deprecated, and as of v5.20 the use of any ASCII-range literal control is deprecated. Support for these will be removed in a future version of perl.</source>
          <target state="translated">与上述类似，标记符后跟方括号内的裸字文本，其中第一个字符是插入符号，后跟大写字母（例如 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 或非 &lt;code&gt;NUL&lt;/code&gt; ，非空格文字控件（例如 &lt;code&gt;${\7LOBAL_PHASE}&lt;/code&gt; 。与上述类似，当不在 &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; &lt;code&gt;[0x80-0xFF]&lt;/code&gt; ，[0x80-0xFF]中的字符被视为控件，但是从v5.22开始，不使用任何非图形字符，而从v5.20开始，不建议使用任何ASCII范围文字控件。在perl的将来版本中将删除对这些功能的支持。</target>
        </trans-unit>
        <trans-unit id="668df669d9efbd5ecee333d1f8978a303dbbc797" translate="yes" xml:space="preserve">
          <source>Similar to try, except that it does not catch exceptions. The idea here is to protect $@ and $! from changes. $@ and $! will be restored to whatever they were before the run so long as it is successful. If the run fails $! will still be restored, but $@ will contain the exception being thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21000b274c1010d95d46737a373e917805b17d88" translate="yes" xml:space="preserve">
          <source>Similar to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2112c220c2b71523b70f673d7ec4dcde3c15e0" translate="yes" xml:space="preserve">
          <source>Similarly &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'Debug'&lt;/code&gt; produces debugging output, the difference being that it allows the fine tuning of what debugging output will be emitted. Options are divided into three groups, those related to compilation, those related to execution and those related to special purposes. The options are as follows:</source>
          <target state="translated">类似地， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'Debug'&lt;/code&gt; 产生调试输出，不同之处在于它允许对将发出的调试输出进行微调。选项分为三类，与编译有关的选项，与执行有关的选项和与特殊目的有关的选项。选项如下：</target>
        </trans-unit>
        <trans-unit id="c569ec67d5806423bac1b597854e2fd9a9cd8f16" translate="yes" xml:space="preserve">
          <source>Similarly &lt;code&gt;use re 'Debug'&lt;/code&gt; produces debugging output, the difference being that it allows the fine tuning of what debugging output will be emitted. Options are divided into three groups, those related to compilation, those related to execution and those related to special purposes. The options are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d106c3869ea4929caecddf63406cc3cb977903" translate="yes" xml:space="preserve">
          <source>Similarly all warnings are disabled in a block by either of these:</source>
          <target state="translated">同样,在一个区块中,所有的警告都会被这两种方式禁用。</target>
        </trans-unit>
        <trans-unit id="55dea1c41dc940323d881fe12ebce9ec69c591cf" translate="yes" xml:space="preserve">
          <source>Similarly if you opened that handle &lt;code&gt;FH&lt;/code&gt; with regular &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, you may use:</source>
          <target state="translated">同样，如果您通过常规 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 打开了处理 &lt;code&gt;FH&lt;/code&gt; 的代码，则可以使用：</target>
        </trans-unit>
        <trans-unit id="64831f5e93834f6bf428903e01c563e7e7bece53" translate="yes" xml:space="preserve">
          <source>Similarly if you opened that handle &lt;code&gt;FH&lt;/code&gt; with regular &lt;code&gt;open&lt;/code&gt; or &lt;code&gt;sysopen&lt;/code&gt;, you may use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53be67a31768325e220272f535bb98f85e3fcddf" translate="yes" xml:space="preserve">
          <source>Similarly one could take the output of the third numbers column from recipe 2 to obtain a &lt;code&gt;$cp_1047&lt;/code&gt; table. The fourth numbers column of the output from recipe 2 could provide a &lt;code&gt;$cp_posix_bc&lt;/code&gt; table suitable for transcoding as well.</source>
          <target state="translated">同样，可以从配方2中获取第三个数字列的输出，以获得 &lt;code&gt;$cp_1047&lt;/code&gt; 表。配方2输出的第四个数字列可以提供一个 &lt;code&gt;$cp_posix_bc&lt;/code&gt; 适合转码的$ cp_posix_bc表。</target>
        </trans-unit>
        <trans-unit id="d0f4815a422eaba46c3d84f219793b24d2375a6b" translate="yes" xml:space="preserve">
          <source>Similarly the NULL needs to be taken into account when you are considering the length of existing keys/values.</source>
          <target state="translated">同样,在考虑现有键/值的长度时,也需要考虑到NULL。</target>
        </trans-unit>
        <trans-unit id="15d5ffcdd52f893f6f74efb6a4803895765d4c4b" translate="yes" xml:space="preserve">
          <source>Similarly the name &quot;WinWin32s&quot; should have been &quot;Win32s&quot; but has been kept as-is for backwards compatibility reasons too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b052290a572fb153a5a7598b50b12efdb7ef549e" translate="yes" xml:space="preserve">
          <source>Similarly unclear is what should be generated when the &lt;code&gt;\N{...}&lt;/code&gt; is used as one of the end points of the range, such as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04230c63a76d30ed5b83266e25e001a24b4eb855" translate="yes" xml:space="preserve">
          <source>Similarly with the one-shot interface, if the input is a buffer larger than 4 Gig, a zip64 complaint zip file will be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4baed99da5d9cf308161bde5e8cc00af2ab9d79" translate="yes" xml:space="preserve">
          <source>Similarly you can build in parallel with GNU make, type &quot;gmake -j2&quot; to build with two parallel jobs, or higher for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc4fb6a726563143c1c04086d201d673d7729dd3" translate="yes" xml:space="preserve">
          <source>Similarly,</source>
          <target state="translated">Similarly,</target>
        </trans-unit>
        <trans-unit id="90864fd67d3db4c105028d84006c631220f52597" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;$href-&amp;gt;{'red'}&lt;/code&gt; is part of the hash referred to by the scalar variable &lt;code&gt;$href&lt;/code&gt; , perhaps even one with no name. &lt;code&gt;$href{'red'}&lt;/code&gt; is part of the deceptively named &lt;code&gt;%href&lt;/code&gt; hash. It's easy to forget to leave out the &lt;code&gt;-&amp;gt;&lt;/code&gt; , and if you do, you'll get bizarre results when your program gets array and hash elements out of totally unexpected hashes and arrays that weren't the ones you wanted to use.</source>
          <target state="translated">类似地， &lt;code&gt;$href-&amp;gt;{'red'}&lt;/code&gt; 是标量变量 &lt;code&gt;$href&lt;/code&gt; 引用的哈希的一部分，甚至可能是没有名字的变量。 &lt;code&gt;$href{'red'}&lt;/code&gt; 是具有欺骗性的 &lt;code&gt;%href&lt;/code&gt; 哈希的一部分。忘记 &lt;code&gt;-&amp;gt;&lt;/code&gt; 是很容易的，如果这样做，当程序从不是您要使用的完全意外的散列和数组中获取数组和散列元素时，就会得到奇怪的结果。</target>
        </trans-unit>
        <trans-unit id="b70d4728a23b61603feac7dca92ea80423288fd3" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;$href-&amp;gt;{'red'}&lt;/code&gt; is part of the hash referred to by the scalar variable &lt;code&gt;$href&lt;/code&gt;, perhaps even one with no name. &lt;code&gt;$href{'red'}&lt;/code&gt; is part of the deceptively named &lt;code&gt;%href&lt;/code&gt; hash. It's easy to forget to leave out the &lt;code&gt;-&amp;gt;&lt;/code&gt;, and if you do, you'll get bizarre results when your program gets array and hash elements out of totally unexpected hashes and arrays that weren't the ones you wanted to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9f2629494d34ddc3413b1763638df2e3855408" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;-&amp;gt;autodefer(1)&lt;/code&gt; re-enables autodeferment, and &lt;code&gt;-&amp;gt;autodefer()&lt;/code&gt; recovers the current value of the autodefer setting.</source>
          <target state="translated">同样， &lt;code&gt;-&amp;gt;autodefer(1)&lt;/code&gt; 重新启用自动防御， &lt;code&gt;-&amp;gt;autodefer()&lt;/code&gt; 恢复自动防御设置的当前值。</target>
        </trans-unit>
        <trans-unit id="ed0a74921b522c90d239c941839d98f9f544df9e" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;.=&lt;/code&gt; and &lt;code&gt;x=&lt;/code&gt; operators lose their mathemagical properties if the string conversion substitution is applied.</source>
          <target state="translated">同样，如果应用了字符串转换替换，则 &lt;code&gt;.=&lt;/code&gt; 和 &lt;code&gt;x=&lt;/code&gt; 运算符将失去其数学性质。</target>
        </trans-unit>
        <trans-unit id="98381cd292cecc23499c5a97dc7663476a411916" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic can be used much like tie() to call a C function any time a scalar's value is used or changed. The &lt;code&gt;MAGIC&lt;/code&gt; 's &lt;code&gt;mg_ptr&lt;/code&gt; field points to a &lt;code&gt;ufuncs&lt;/code&gt; structure:</source>
          <target state="translated">类似地， &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 使用或更改标量值时，可以像tie（）一样使用PERL_MAGIC_uvar魔术来调用C函数。在 &lt;code&gt;MAGIC&lt;/code&gt; 的 &lt;code&gt;mg_ptr&lt;/code&gt; 场指向 &lt;code&gt;ufuncs&lt;/code&gt; 结构：</target>
        </trans-unit>
        <trans-unit id="dd56bf6157ee2e5e27ea1785ce7250db948cb17e" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic can be used much like tie() to call a C function any time a scalar's value is used or changed. The &lt;code&gt;MAGIC&lt;/code&gt;'s &lt;code&gt;mg_ptr&lt;/code&gt; field points to a &lt;code&gt;ufuncs&lt;/code&gt; structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084028b0095b78ad708b249b88f8a8326808bba4" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;\x&lt;i&gt;nn&lt;/i&gt;&lt;/code&gt;, where</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1434bb43847966624ccbd7c82a8d888d8931593" translate="yes" xml:space="preserve">
          <source>Similarly, Perl's built-in &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; function treats a reference to a blessed object specially. If you call &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref($thing)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;$thing&lt;/code&gt; holds a reference to an object, it will return the name of the class that the object has been blessed into.</source>
          <target state="translated">同样，Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 函数特别对待对祝福对象的引用。如果调用 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref($thing)&lt;/a&gt;&lt;/code&gt; 并且 &lt;code&gt;$thing&lt;/code&gt; 拥有对对象的引用，它将返回该对象被祝福的类的名称。</target>
        </trans-unit>
        <trans-unit id="3c79bdba87881c1ec05393b4d27a2c965c79a1a5" translate="yes" xml:space="preserve">
          <source>Similarly, Perl's built-in &lt;code&gt;ref&lt;/code&gt; function treats a reference to a blessed object specially. If you call &lt;code&gt;ref($thing)&lt;/code&gt; and &lt;code&gt;$thing&lt;/code&gt; holds a reference to an object, it will return the name of the class that the object has been blessed into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed57441510534192d07967fc62d33e33379b4e80" translate="yes" xml:space="preserve">
          <source>Similarly, a list assignment in list context produces the list of lvalues assigned to, and a list assignment in scalar context returns the number of elements produced by the expression on the right hand side of the assignment.</source>
          <target state="translated">同理,列表上下文中的列表赋值会产生赋值的l值列表,标量上下文中的列表赋值会返回赋值右侧表达式产生的元素数。</target>
        </trans-unit>
        <trans-unit id="105351b9ff1ce0c3b0da126c3158372b6f241c09" translate="yes" xml:space="preserve">
          <source>Similarly, a value assigned to &lt;code&gt;$)&lt;/code&gt; must also be a space-separated list of numbers. The first number sets the effective gid, and the rest (if any) are passed to &lt;code&gt;setgroups()&lt;/code&gt; . To get the effect of an empty list for &lt;code&gt;setgroups()&lt;/code&gt; , just repeat the new effective gid; that is, to force an effective gid of 5 and an effectively empty &lt;code&gt;setgroups()&lt;/code&gt; list, say &lt;code&gt; $) = &quot;5 5&quot; &lt;/code&gt; .</source>
          <target state="translated">同样，分配给 &lt;code&gt;$)&lt;/code&gt; 的值也必须是用空格分隔的数字列表。第一个数字设置有效的gid，其余的数字（如果有的话）传递给 &lt;code&gt;setgroups()&lt;/code&gt; 。要获得 &lt;code&gt;setgroups()&lt;/code&gt; 空列表的效果，只需重复新的有效gid；也就是说，强制有效值为5且有效为空的 &lt;code&gt;setgroups()&lt;/code&gt; 列表，例如 &lt;code&gt; $) = &quot;5 5&quot; &lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9bfb808fae3d4ef85e01abecf018c96a424092b" translate="yes" xml:space="preserve">
          <source>Similarly, a value assigned to &lt;code&gt;$)&lt;/code&gt; must also be a space-separated list of numbers. The first number sets the effective gid, and the rest (if any) are passed to &lt;code&gt;setgroups()&lt;/code&gt;. To get the effect of an empty list for &lt;code&gt;setgroups()&lt;/code&gt;, just repeat the new effective gid; that is, to force an effective gid of 5 and an effectively empty &lt;code&gt;setgroups()&lt;/code&gt; list, say &lt;code&gt; $) = &quot;5 5&quot; &lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f830d9f2bf12f89de4edd3497ea1af8e153890fe" translate="yes" xml:space="preserve">
          <source>Similarly, an expression that returns a reference to a scalar can be dereferenced via &lt;code&gt;${...}&lt;/code&gt; . Thus, the above expression may be written as:</source>
          <target state="translated">类似地，可以通过 &lt;code&gt;${...}&lt;/code&gt; 取消引用返回标量引用的表达式。因此，以上表达式可以写为：</target>
        </trans-unit>
        <trans-unit id="6c0225a1fecb24141de2c67cfa637dd7b4544c6f" translate="yes" xml:space="preserve">
          <source>Similarly, an expression that returns a reference to a scalar can be dereferenced via &lt;code&gt;${...}&lt;/code&gt;. Thus, the above expression may be written as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1370fc5b87a4deef9433fab962c63dda2bb0891" translate="yes" xml:space="preserve">
          <source>Similarly, autogeneration for keys &lt;code&gt;'+='&lt;/code&gt; and &lt;code&gt;'++'&lt;/code&gt; is analogous to &lt;code&gt;'-='&lt;/code&gt; and &lt;code&gt;'--'&lt;/code&gt; above:</source>
          <target state="translated">同样，键 &lt;code&gt;'+='&lt;/code&gt; 和 &lt;code&gt;'++'&lt;/code&gt; 自动生成类似于上面的 &lt;code&gt;'-='&lt;/code&gt; 和 &lt;code&gt;'--'&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="22f4fe3ff0b7318ce2f9a1f22a4a30c916f48517" translate="yes" xml:space="preserve">
          <source>Similarly, because of all the subscripting that is done using single words, the same rule applies to any bareword that is used for subscripting a hash. So now, instead of writing</source>
          <target state="translated">同样,由于所有的下标都是使用单字完成的,所以同样的规则也适用于任何用于下标哈希的裸字。所以,现在,不用再写</target>
        </trans-unit>
        <trans-unit id="1ef17c2e729b74afc14b925795781df60a813811" translate="yes" xml:space="preserve">
          <source>Similarly, decimal strings can represent only those numbers which have a finite decimal expansion. Being strings, and thus of arbitrary length, there is no practical limit for the exponent or number of decimal digits for these numbers. (But realize that what we are discussing the rules for just the</source>
          <target state="translated">同样,十进制字符串只能表示那些具有有限十进制扩展的数字。作为字符串,因此是任意长度的,对于这些数字的指数或小数位数没有实际的限制。但要知道,我们所讨论的规则仅仅是对于</target>
        </trans-unit>
        <trans-unit id="d345f5b26d91c2f90c4bf682659d17c36e269cb0" translate="yes" xml:space="preserve">
          <source>Similarly, for repeated &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/()/g&lt;/a&gt;&lt;/code&gt; the second-best match is the match at the position one notch further in the string.</source>
          <target state="translated">类似地，对于重复的 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/()/g&lt;/a&gt;&lt;/code&gt; ，第二个最佳匹配是字符串中更远一个位置处的匹配。</target>
        </trans-unit>
        <trans-unit id="120bba2aa7dfcc858de2e7ae463e7151de6901e1" translate="yes" xml:space="preserve">
          <source>Similarly, for repeated &lt;code&gt;m/()/g&lt;/code&gt; the second-best match is the match at the position one notch further in the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee2c36ef0fdac4abda9dcad28ab4aed983df538" translate="yes" xml:space="preserve">
          <source>Similarly, functions that return text data--such as a function that fetches a web page--should sometimes translate newlines before returning the data, if they've not yet been translated to the local newline representation. A single line of code will often suffice:</source>
          <target state="translated">同样,返回文本数据的函数--比如获取网页的函数--有时应该在返回数据之前翻译换行,如果它们还没有被翻译成本地换行表示。一行代码通常就足够了。</target>
        </trans-unit>
        <trans-unit id="6397152c0c35f4b75972d06222dcea4b97f1756f" translate="yes" xml:space="preserve">
          <source>Similarly, if the &lt;code&gt;compress&lt;/code&gt; program is available, you can use this to write a &lt;code&gt;.tar.Z&lt;/code&gt; file</source>
          <target state="translated">同样，如果有 &lt;code&gt;compress&lt;/code&gt; 程序，则可以使用它编写一个 &lt;code&gt;.tar.Z&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="5e75a2bb501471358d82a9998e95b65710f45b03" translate="yes" xml:space="preserve">
          <source>Similarly, if you need the threads object, but your thread will not be returning a value (i.e.,</source>
          <target state="translated">同样,如果你需要线程对象,但你的线程不会返回一个值(即。</target>
        </trans-unit>
        <trans-unit id="5871ebe0fa13ed14449c1f6ca87d126616162345" translate="yes" xml:space="preserve">
          <source>Similarly, in the failure branch we could use &lt;code&gt;PUSHs&lt;/code&gt;</source>
          <target state="translated">同样，在失败分支中，我们可以使用 &lt;code&gt;PUSHs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9077bdc5741605a4137fa6215e60fd225b8f3e44" translate="yes" xml:space="preserve">
          <source>Similarly, it would be better to use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; instead of,</source>
          <target state="translated">同样，最好 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 代替</target>
        </trans-unit>
        <trans-unit id="14a6593d35c0dd5a226aba97a86d554f0e84ed18" translate="yes" xml:space="preserve">
          <source>Similarly, it would be better to use &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; instead of,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46d4cfe15f7f292996d268d497a4ca8dd6bd83c" translate="yes" xml:space="preserve">
          <source>Similarly, just because an operator lets you assume default arguments doesn't mean that you have to make use of the defaults. The defaults are there for lazy systems programmers writing one-shot programs. If you want your program to be readable, consider supplying the argument.</source>
          <target state="translated">同样,一个操作符让你假设默认参数并不意味着你必须使用默认值。默认值是为懒惰的系统程序员编写一次性程序而存在的。如果你希望你的程序是可读的,可以考虑提供参数。</target>
        </trans-unit>
        <trans-unit id="65a3c4117ed70cbe8d3af699e5cf5e22b4df58b4" translate="yes" xml:space="preserve">
          <source>Similarly, mixing signals and threads may be problematic. Implementations are platform-dependent, and even the POSIX semantics may not be what you expect (and Perl doesn't even give you the full POSIX API). For example, there is no way to guarantee that a signal sent to a multi-threaded Perl application will get intercepted by any particular thread. (However, a recently added feature does provide the capability to send signals between threads. See &lt;a href=&quot;threads#THREAD-SIGNALLING&quot;&gt;&quot;THREAD SIGNALLING&quot; in threads&lt;/a&gt; for more details.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab81862aa9c1688c2206840c0db77adfc7697fb" translate="yes" xml:space="preserve">
          <source>Similarly, mixing signals and threads may be problematic. Implementations are platform-dependent, and even the POSIX semantics may not be what you expect (and Perl doesn't even give you the full POSIX API). For example, there is no way to guarantee that a signal sent to a multi-threaded Perl application will get intercepted by any particular thread. (However, a recently added feature does provide the capability to send signals between threads. See &lt;a href=&quot;threads#THREAD-SIGNALLING&quot;&gt;THREAD SIGNALLING in threads&lt;/a&gt; for more details.)</source>
          <target state="translated">类似地，混合信号和线程可能会出现问题。实现是依赖于平台的，甚至POSIX语义也可能不是您期望的（Perl甚至没有提供完整的POSIX API）。例如，没有办法保证发送到多线程Perl应用程序的信号将被任何特定线程截获。（然而，最近添加的功能并提供在线程之间发送信号的能力。见&lt;a href=&quot;threads#THREAD-SIGNALLING&quot;&gt;在线程的线程信令&lt;/a&gt;的更多细节。）</target>
        </trans-unit>
        <trans-unit id="cd7a72bba4a729c17beea354c31212e7918a1056" translate="yes" xml:space="preserve">
          <source>Similarly, syswrite() and send() use only the &lt;code&gt;:utf8&lt;/code&gt; flag, otherwise ignoring any layers. If the flag is set, both write the value UTF-8 encoded, even if the layer is some different encoding, such as the example above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b7335ed3c7d05707d8547cd24aeb6b264218d7" translate="yes" xml:space="preserve">
          <source>Similarly, syswrite() and send() used only the &lt;code&gt;:utf8&lt;/code&gt; flag, otherwise ignoring any layers. If the flag is set, both wrote the value UTF-8 encoded, even if the layer is some different encoding, such as the example above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9312c4a2cb541668748a3ea749dc0d9f12c2cf9" translate="yes" xml:space="preserve">
          <source>Similarly, the &lt;code&gt;UNICODE_WARN_NONCHAR&lt;/code&gt; and &lt;code&gt;UNICODE_DISALLOW_NONCHAR&lt;/code&gt; flags affect how the function handles a Unicode non-character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa030e076fa248a433f0f83ee4a1aceaeee249f" translate="yes" xml:space="preserve">
          <source>Similarly, the parameter &lt;code&gt;inc_override&lt;/code&gt; may be a reference to an array which is used in place of the default module search paths from &lt;code&gt;@INC&lt;/code&gt; .</source>
          <target state="translated">类似地，参数 &lt;code&gt;inc_override&lt;/code&gt; 可以是对数组的引用，该数组用于代替 &lt;code&gt;@INC&lt;/code&gt; 的默认模块搜索路径。</target>
        </trans-unit>
        <trans-unit id="1c747d6cbaa1a9a827f93122d97bf098849b7485" translate="yes" xml:space="preserve">
          <source>Similarly, the parameter &lt;code&gt;inc_override&lt;/code&gt; may be a reference to an array which is used in place of the default module search paths from &lt;code&gt;@INC&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1497da8abe3ed6eca13bd6302e3d281ea65007d7" translate="yes" xml:space="preserve">
          <source>Similarly, the resultant filespec will contain the file version only if one was present in the input filespec.</source>
          <target state="translated">类似地,只有当输入的 filespec 中存在文件版本时,结果的 filespec 才会包含文件版本。</target>
        </trans-unit>
        <trans-unit id="0dacead88183b1e9c6304a4ceec665b6c24796d7" translate="yes" xml:space="preserve">
          <source>Similarly, they can be used in regular expression literals</source>
          <target state="translated">同样,它们也可以用于正则表达式的字面意义中</target>
        </trans-unit>
        <trans-unit id="395326d4967b38aae5eb742109108213c899c254" translate="yes" xml:space="preserve">
          <source>Similarly, this is invalid:</source>
          <target state="translated">同样,这也是无效的。</target>
        </trans-unit>
        <trans-unit id="6c8f54b856913d21b69f361a1a90203715ac01de" translate="yes" xml:space="preserve">
          <source>Similarly, this recipe can be used for properties that do require adjustments:</source>
          <target state="translated">同样,这个配方也可以用于确实需要调整的属性。</target>
        </trans-unit>
        <trans-unit id="838e649b773f393ab1e3e6ec2fd3f5756cf00ea3" translate="yes" xml:space="preserve">
          <source>Similarly, this will silence warnings from this module, and preserve the default behaviour:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b2e4fdd23d41dfea9d8225a12a424a715230bb" translate="yes" xml:space="preserve">
          <source>Similarly, this:</source>
          <target state="translated">同样,这。</target>
        </trans-unit>
        <trans-unit id="d1bdda2be136926ef9a893301ff91d18747c507f" translate="yes" xml:space="preserve">
          <source>Similarly, to copy an anonymous hash, you can use</source>
          <target state="translated">同样,要复制匿名哈希,你可以使用</target>
        </trans-unit>
        <trans-unit id="7850beac28db723d025cfad11fb93ce97e2ced9b" translate="yes" xml:space="preserve">
          <source>Similarly, using &lt;code&gt;$^W&lt;/code&gt; to either disable or enable blocks of code is fundamentally flawed. For a start, say you want to disable warnings in a block of code. You might expect this to be enough to do the trick:</source>
          <target state="translated">同样，使用 &lt;code&gt;$^W&lt;/code&gt; 禁用或启用代码块从根本上来说也是有缺陷的。首先，假设您要禁用代码块中的警告。您可能希望这足以解决问题：</target>
        </trans-unit>
        <trans-unit id="2664530a7df4eabf1ac2e9d54c9f06c6deee6b41" translate="yes" xml:space="preserve">
          <source>Similarly, with this code</source>
          <target state="translated">同样,在这个代码中</target>
        </trans-unit>
        <trans-unit id="b0293d771b0de8656e1c85bf1faad486bf545599" translate="yes" xml:space="preserve">
          <source>Similarly, you may use these I/O layers on output streams to automatically convert Unicode to the specified encoding when it is written to the stream. For example, the following snippet copies the contents of the file &quot;text.jis&quot; (encoded as ISO-2022-JP, aka JIS) to the file &quot;text.utf8&quot;, encoded as UTF-8:</source>
          <target state="translated">同样,您可以在输出流上使用这些 I/O 层,当它被写入流时,自动将 Unicode 转换为指定的编码。例如,以下代码段将文件 &quot;text.jis&quot;(编码为ISO-2022-JP,又名JIS)的内容复制到文件 &quot;text.utf8 &quot;中,编码为UTF-8。</target>
        </trans-unit>
        <trans-unit id="a9548affa7e4acbe2593b885978a8755658bc00f" translate="yes" xml:space="preserve">
          <source>Similary to</source>
          <target state="translated">类似于</target>
        </trans-unit>
        <trans-unit id="d038c3b0b4f25db2b86d3e73c906bad029553a54" translate="yes" xml:space="preserve">
          <source>Simon Cozens &amp;lt;simon AT brecon DOT co DOT uk&amp;gt; - Being there to answer zillions of annoying questions</source>
          <target state="translated">Simon Cozens &amp;lt;simon AT brecon DOT co DOT UK&amp;gt;-在那里回答不计其数的烦人问题</target>
        </trans-unit>
        <trans-unit id="db6a8ce8a7b56a60b15a1e81509c2149cf995dfb" translate="yes" xml:space="preserve">
          <source>Simon Cozens and Wolfgang Laun.</source>
          <target state="translated">Simon Cozens和Wolfgang Laun.</target>
        </trans-unit>
        <trans-unit id="911ebed02457e684e0b32e14a35ae78fa21f67e0" translate="yes" xml:space="preserve">
          <source>Simon Cozens, &lt;code&gt;simon@cpan.org&lt;/code&gt;</source>
          <target state="translated">Simon Cozens， &lt;code&gt;simon@cpan.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c339f709f7b43634c7fbcb9cbd9eccd0f9cc3ac2" translate="yes" xml:space="preserve">
          <source>Simple Mail Transfer Protocol Client</source>
          <target state="translated">简单邮件传输协议客户端</target>
        </trans-unit>
        <trans-unit id="0b80f19dce22ed4ff1ea0703ed5ec7dc2f2434d5" translate="yes" xml:space="preserve">
          <source>Simple Perl scalars (any scalar that is not a reference) are the most difficult objects to encode: JSON::PP will encode undefined scalars as JSON &lt;code&gt;null&lt;/code&gt; values, scalars that have last been used in a string context before encoding as JSON strings, and anything else as number value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee009eadcb45691f1eecbe3d87057665862d1bd" translate="yes" xml:space="preserve">
          <source>Simple Scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f59937d173df040577971290f0e1cacd671a9c" translate="yes" xml:space="preserve">
          <source>Simple Statements</source>
          <target state="translated">简单声明</target>
        </trans-unit>
        <trans-unit id="84ffc80b7ca3fcee70bdb32bddd613a718e0b12c" translate="yes" xml:space="preserve">
          <source>Simple assignment is not overloadable (the &lt;code&gt;'='&lt;/code&gt; key is used for the &lt;a href=&quot;#Copy-Constructor&quot;&gt;&quot;Copy Constructor&quot;&lt;/a&gt;). Perl does have a way to make assignments to an object do whatever you want, but this involves using tie(), not overload - see &lt;a href=&quot;perlfunc#tie&quot;&gt;&quot;tie&quot; in perlfunc&lt;/a&gt; and the &lt;a href=&quot;#COOKBOOK&quot;&gt;&quot;COOKBOOK&quot;&lt;/a&gt; examples below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd89bedbaeb791041cff4fe148dbfde653b95d00" translate="yes" xml:space="preserve">
          <source>Simple assignment is not overloadable (the &lt;code&gt;'='&lt;/code&gt; key is used for the &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;). Perl does have a way to make assignments to an object do whatever you want, but this involves using tie(), not overload - see &lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; and the &lt;a href=&quot;#COOKBOOK&quot;&gt;COOKBOOK&lt;/a&gt; examples below.</source>
          <target state="translated">简单分配是不可重载的（ &lt;code&gt;'='&lt;/code&gt; 键用于&lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;）。Perl确实有一种使对象赋值的方法，可以执行您想要的任何事情，但这涉及使用tie（）而不是重载-请参见下面的&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;和&lt;a href=&quot;#COOKBOOK&quot;&gt;COOKBOOK&lt;/a&gt;示例。</target>
        </trans-unit>
        <trans-unit id="8605c0b660faa7b5703ee9847774a8d43e86ed05" translate="yes" xml:space="preserve">
          <source>Simple delegatees for misc parameters derived from distribution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94eac8882772ef72bea55863ece1200dedf301b7" translate="yes" xml:space="preserve">
          <source>Simple enough. Now compile and run:</source>
          <target state="translated">很简单。现在编译并运行。</target>
        </trans-unit>
        <trans-unit id="ba971c7177cc7a0849b0167e7f954b49b5a4aaf2" translate="yes" xml:space="preserve">
          <source>Simple examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764eff41a5149cfadde2c6b72cdd2e21368ca43b" translate="yes" xml:space="preserve">
          <source>Simple examples to open a file for reading:</source>
          <target state="translated">打开文件阅读的简单例子。</target>
        </trans-unit>
        <trans-unit id="8bbdbbffdc1d0c057f0470ba8573e7773f1d085a" translate="yes" xml:space="preserve">
          <source>Simple interface to Locale::Maketext::Lexicon</source>
          <target state="translated">Locale::Maketext::Lexicon的简单接口。</target>
        </trans-unit>
        <trans-unit id="7b8b7240c656011159c28f4357d2c8a844877df6" translate="yes" xml:space="preserve">
          <source>Simple matching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a65de4566d838633c7cfe8d2f3954d6165e02e" translate="yes" xml:space="preserve">
          <source>Simple methods for simple tasks</source>
          <target state="translated">简单任务的简单方法</target>
        </trans-unit>
        <trans-unit id="107deb5b12e566d319794bc7ce2d8bcc70c508d0" translate="yes" xml:space="preserve">
          <source>Simple options</source>
          <target state="translated">简单选项</target>
        </trans-unit>
        <trans-unit id="b3c11d00394d5efd68e3089882ea99ef88db2b49" translate="yes" xml:space="preserve">
          <source>Simple subroutine to insert the macros defined by the macro attribute into the Makefile.</source>
          <target state="translated">将宏属性定义的宏插入到Makefile中的简单子程序。</target>
        </trans-unit>
        <trans-unit id="adadcc42c8be98750be33acd4bfac36bd737f651" translate="yes" xml:space="preserve">
          <source>Simple substitution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f78d32b59c097fb10ad26d36f2e74fdbebe4e64" translate="yes" xml:space="preserve">
          <source>Simple word matching</source>
          <target state="translated">简单的词语搭配</target>
        </trans-unit>
        <trans-unit id="f7b02d0f94f21913ddb8d295324658b8720d69e0" translate="yes" xml:space="preserve">
          <source>Simple, eh?</source>
          <target state="translated">很简单,嗯?</target>
        </trans-unit>
        <trans-unit id="5ab4a74caba11b1370fe119fe34f9f5db826dbbf" translate="yes" xml:space="preserve">
          <source>Simple, one-off commits pushed to the 'blead' branch should be simple commits that apply cleanly. In other words, you should make sure your work is committed against the current position of blead, so that you can push back to the master repository without merging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee1790ba48c5c5f5aec6b6de12f218c366e78db" translate="yes" xml:space="preserve">
          <source>Simple... Now look:</source>
          <target state="translated">简单...现在看。</target>
        </trans-unit>
        <trans-unit id="6c9330b7a2ff965f7db6cafb9f575b4d58374515" translate="yes" xml:space="preserve">
          <source>Simpler definition of attribute handlers</source>
          <target state="translated">简化属性处理程序的定义</target>
        </trans-unit>
        <trans-unit id="50c361747016ee3aff5355a6c96f0c2b139551ef" translate="yes" xml:space="preserve">
          <source>Simplest way to do it automatically is to use your version control system's revision number (you are using version control, right?).</source>
          <target state="translated">最简单的方法是使用你的版本控制系统的版本号(你使用的是版本控制,对吧)来自动完成。</target>
        </trans-unit>
        <trans-unit id="68be18029150583164f9438753e32a72fd3e4c87" translate="yes" xml:space="preserve">
          <source>Simplified source filtering</source>
          <target state="translated">简化的源头过滤</target>
        </trans-unit>
        <trans-unit id="66f7f6fe24549ec54694a312ab799bde4d89b2f3" translate="yes" xml:space="preserve">
          <source>Simply not portable. Get your lvalue to be of the right type, or maybe use temporary variables, or dirty tricks with unions.</source>
          <target state="translated">根本无法移植。让你的lvalue成为正确的类型,或者可能使用临时变量,或者使用联合的肮脏技巧。</target>
        </trans-unit>
        <trans-unit id="20084b93a5f754ce0ccd01de74eb0172d18babfc" translate="yes" xml:space="preserve">
          <source>Simply put:</source>
          <target state="translated">简单的说。</target>
        </trans-unit>
        <trans-unit id="991f810db6d12637f2fd5bbddcb5e86f7ab43bb2" translate="yes" xml:space="preserve">
          <source>Simply put: for each extension linked with your Perl executable (determined during its initial configuration on your computer or when adding a new extension), a Perl subroutine is created to incorporate the extension's routines. Normally, that subroutine is named</source>
          <target state="translated">简单地说:对于每一个与你的Perl可执行文件相连的扩展(在你的计算机上初始配置时或添加新的扩展时确定),都会创建一个Perl子程序来合并扩展的例程。通常,这个子程序的名字是</target>
        </trans-unit>
        <trans-unit id="86b802f817d8db47f98e358e0df4e43c122569da" translate="yes" xml:space="preserve">
          <source>Simply run</source>
          <target state="translated">只需运行</target>
        </trans-unit>
        <trans-unit id="14c3e2e53d9dfb6b8072093e8b927f77f6a76d42" translate="yes" xml:space="preserve">
          <source>Simply says that we're Unix.</source>
          <target state="translated">简单地说,我们是Unix。</target>
        </trans-unit>
        <trans-unit id="22a4ed66c623d273a571652cc9ae1a89577a837f" translate="yes" xml:space="preserve">
          <source>Since</source>
          <target state="translated">Since</target>
        </trans-unit>
        <trans-unit id="60dbe9f3bc2001b2c722387a7d49aaabb3da33d1" translate="yes" xml:space="preserve">
          <source>Since # can be used for comments, # must be escaped.</source>
          <target state="translated">由于#可以用于注释,所以#必须被转义。</target>
        </trans-unit>
        <trans-unit id="7f16eb993aa5b4126dadedc6b4f7941b4f104c6b" translate="yes" xml:space="preserve">
          <source>Since 3.26, using &lt;code&gt;-F&lt;/code&gt; as the superuser also implies &lt;code&gt;-U&lt;/code&gt; as opening most files and traversing directories requires privileges that are above the nobody/nogroup level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18dd63133c168a4767fcb87b71a43b938682e1a" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt; does a &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; it may affect a &lt;code&gt;SIGCHLD&lt;/code&gt; handler. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ded02f76d7e8f2623d74fdc5f26a66cd0a132c8" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;http://man.he.net/man3/flock&quot;&gt;flock(3)&lt;/a&gt; is present in EMX, but is not functional, it is emulated by perl. To disable the emulations, set environment variable &lt;code&gt;USE_PERL_FLOCK=0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af160de91abb536123124eac1ecabfc37de02e74" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; it may affect a &lt;code&gt;SIGCHLD&lt;/code&gt; handler. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">由于 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 执行 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 并 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 因此可能会影响 &lt;code&gt;SIGCHLD&lt;/code&gt; 处理程序。有关详细信息，请参见&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aba59b2cf00e40d21bac4c0a192544510ddcbae0" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; will also call the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method, the actual value for &lt;code&gt;MODULE&lt;/code&gt; must be a bareword. That is, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; cannot load files by name, although &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; can:</source>
          <target state="translated">由于 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 也将调用 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法，因此 &lt;code&gt;MODULE&lt;/code&gt; 的实际值必须为空字。也就是说，尽管 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 可以，但 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 无法按名称加载文件：</target>
        </trans-unit>
        <trans-unit id="73d2921b742823e6f578c98791a72739f4a21337" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; it may affect a &lt;code&gt;SIGCHLD&lt;/code&gt; handler. See &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">由于 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 执行 &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 并 &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 因此可能会影响 &lt;code&gt;SIGCHLD&lt;/code&gt; 处理程序。有关详细信息，请参见&lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53cc6266d93eb2a78be0857ad5ecd43af7e2b644" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;Archive::Tar&lt;/code&gt; doesn't change the current directory internally while it is extracting the items in a tarball, all calls to &lt;code&gt;Cwd::cwd()&lt;/code&gt; can be avoided if we can guarantee that the current directory doesn't get changed externally.</source>
          <target state="translated">由于 &lt;code&gt;Archive::Tar&lt;/code&gt; 在压缩包中提取项目时不会在内部更改当前目录，因此，如果我们可以保证当前目录不会在外部更改，则可以避免对 &lt;code&gt;Cwd::cwd()&lt;/code&gt; 所有调用。</target>
        </trans-unit>
        <trans-unit id="42aa5efcb3e75000fce11592bd84e59ec314928e" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;SIGINT&lt;/code&gt; and &lt;code&gt;SIGQUIT&lt;/code&gt; are ignored during the execution of &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;, if you expect your program to terminate on receipt of these signals you will need to arrange to do so yourself based on the return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3c7a53144e6a3302e2a2f9e7b6229b194fa174" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;SIGINT&lt;/code&gt; and &lt;code&gt;SIGQUIT&lt;/code&gt; are ignored during the execution of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you expect your program to terminate on receipt of these signals you will need to arrange to do so yourself based on the return value.</source>
          <target state="translated">由于 &lt;code&gt;SIGINT&lt;/code&gt; 和 &lt;code&gt;SIGQUIT&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 执行期间会被忽略，因此，如果您希望程序在收到这些信号后终止，则您需要根据返回值自行安排这样做。</target>
        </trans-unit>
        <trans-unit id="e4f45d5c1543b43feed600201b8df9285b671829" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;SIGINT&lt;/code&gt; and &lt;code&gt;SIGQUIT&lt;/code&gt; are ignored during the execution of &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you expect your program to terminate on receipt of these signals you will need to arrange to do so yourself based on the return value.</source>
          <target state="translated">由于 &lt;code&gt;SIGINT&lt;/code&gt; 和 &lt;code&gt;SIGQUIT&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 执行期间会被忽略，因此，如果您希望程序在收到这些信号后终止，则您需要根据返回值自行安排这样做。</target>
        </trans-unit>
        <trans-unit id="c78eaa920d9b2c6c4c17bb6231c81108ebdc9ea7" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;XSRETURN_*&lt;/code&gt; macros can be used with CODE blocks as well, one can rewrite this example as:</source>
          <target state="translated">由于 &lt;code&gt;XSRETURN_*&lt;/code&gt; 宏也可以与CODE块一起使用，因此可以将该示例重写为：</target>
        </trans-unit>
        <trans-unit id="ddeb2559b4a933dbff6f6bd50711c077c5250a4a" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;use&lt;/code&gt; will also call the &lt;code&gt;import&lt;/code&gt; method, the actual value for &lt;code&gt;MODULE&lt;/code&gt; must be a bareword. That is, &lt;code&gt;use&lt;/code&gt; cannot load files by name, although &lt;code&gt;require&lt;/code&gt; can:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae1fb90f2e2a999e504c7cb0f71e0777fa542ca" translate="yes" xml:space="preserve">
          <source>Since CPAN.pm version 1.88_51 modules declared as &lt;code&gt;build_requires&lt;/code&gt; by a distribution are treated differently depending on the config variable &lt;code&gt;build_requires_install_policy&lt;/code&gt; . By setting &lt;code&gt;build_requires_install_policy&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;, such a module is not installed. It is only built and tested, and then kept in the list of tested but uninstalled modules. As such, it is available during the build of the dependent module by integrating the path to the &lt;code&gt;blib/arch&lt;/code&gt; and &lt;code&gt;blib/lib&lt;/code&gt; directories in the environment variable PERL5LIB. If &lt;code&gt;build_requires_install_policy&lt;/code&gt; is set ti &lt;code&gt;yes&lt;/code&gt; , then both modules declared as &lt;code&gt;requires&lt;/code&gt; and those declared as &lt;code&gt;build_requires&lt;/code&gt; are treated alike. By setting to &lt;code&gt;ask/yes&lt;/code&gt; or &lt;code&gt;ask/&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; , CPAN.pm asks the user and sets the default accordingly.</source>
          <target state="translated">由于发行版声明为 &lt;code&gt;build_requires&lt;/code&gt; 的CPAN.pm版本1.88_51模块将根据配置变量 &lt;code&gt;build_requires_install_policy&lt;/code&gt; 进行不同处理。通过将 &lt;code&gt;build_requires_install_policy&lt;/code&gt; 设置为 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; ，不会安装这样的模块。它仅经过构建和测试，然后保留在经过测试但已卸载的模块列表中。这样，通过在环境变量PERL5LIB中集成到 &lt;code&gt;blib/arch&lt;/code&gt; 和 &lt;code&gt;blib/lib&lt;/code&gt; 目录的路径，可以在依赖模块的构建过程中使用它。如果 &lt;code&gt;build_requires_install_policy&lt;/code&gt; 设置TI &lt;code&gt;yes&lt;/code&gt; ，那么这两个模块声明 &lt;code&gt;requires&lt;/code&gt; 与那些声明为 &lt;code&gt;build_requires&lt;/code&gt; 的对象一样。通过设置为&amp;ldquo; &lt;code&gt;ask/yes&lt;/code&gt; 或&amp;ldquo; 是 &lt;code&gt;ask/&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; ，CPAN.pm会询问用户并相应地设置默认值。</target>
        </trans-unit>
        <trans-unit id="92bd94b93ba7aa98da9b694cc55416c0183aa164" translate="yes" xml:space="preserve">
          <source>Since DLLs may be loaded at run time, to have the same mechanism for DLLs one needs to have the address range of</source>
          <target state="translated">由于DLLs可能在运行时被加载,所以要想对DLLs有同样的机制,就需要将地址范围为</target>
        </trans-unit>
        <trans-unit id="b8d7eab0940cbd19c7e5c0a0410f1af9f2b70a97" translate="yes" xml:space="preserve">
          <source>Since Emacs version 19 patchlevel 22 or so, there have been both a perl-mode.el and support for the Perl debugger built in. These should come with the standard Emacs 19 distribution.</source>
          <target state="translated">自从 Emacs 19 补丁级别 22 左右,已经有了 perl-mode.el 和对 Perl 调试器的内置支持。这些应该是标准的 Emacs 19 发行版中的内容。</target>
        </trans-unit>
        <trans-unit id="ae992899a872766d28cfb8b692b2e7f7ecf24212" translate="yes" xml:space="preserve">
          <source>Since File::Spec is object oriented, subroutines should not be called directly, as in:</source>
          <target state="translated">由于File::Spec是面向对象的,所以不应直接调用子程序,如。</target>
        </trans-unit>
        <trans-unit id="58330cb00aafa72e888d41a23aef159c39b70e0c" translate="yes" xml:space="preserve">
          <source>Since INPUT sections allow declaration of C variables which do not appear in the parameter list of a subroutine, this may be shortened to:</source>
          <target state="translated">由于INPUT部分允许声明不出现在子程序参数列表中的C变量,因此可以将其缩短为。</target>
        </trans-unit>
        <trans-unit id="45546e69c804ad74560b03b1bfa0ada21545dbab" translate="yes" xml:space="preserve">
          <source>Since Math::BigInt and BigFloat also overload the normal math operations, the following line will still work:</source>
          <target state="translated">由于Math::BigInt和BigFloat也会重载普通的数学运算,所以下面这行还是可以的。</target>
        </trans-unit>
        <trans-unit id="1a22aa5b5825f973b9ba76849397ffcf019b0d3e" translate="yes" xml:space="preserve">
          <source>Since OS/2 port of perl uses a remarkable EMX environment, it can run (and build extensions, and - possibly - be built itself) under any environment which can run EMX. The current list is DOS, DOS-inside-OS/2, Win0.3*, Win0.95 and WinNT. Out of many perl flavors, only one works, see &lt;a href=&quot;#perl_.exe&quot;&gt;&quot;&lt;i&gt;perl_.exe&lt;/i&gt;&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfdb84eddf5f43124818a551b78d4d19bef89ac6" translate="yes" xml:space="preserve">
          <source>Since OS/2 port of perl uses a remarkable EMX environment, it can run (and build extensions, and - possibly - be built itself) under any environment which can run EMX. The current list is DOS, DOS-inside-OS/2, Win0.3*, Win0.95 and WinNT. Out of many perl flavors, only one works, see &lt;a href=&quot;#perl_.exe&quot;&gt;perl_.exe&lt;/a&gt;.</source>
          <target state="translated">由于perl的OS / 2端口使用了出色的EMX环境，因此它可以在任何可以运行EMX的环境下运行（并构建扩展，并且可能自己构建）。当前列表是DOS，DOS-inside-OS / 2，Win0.3 *，Win0.95和WinNT。在许多perl风格中，只有一种起作用，请参见&lt;a href=&quot;#perl_.exe&quot;&gt;perl_.exe&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6084ebce66f9d95008fbd76add0c4721f5880c4b" translate="yes" xml:space="preserve">
          <source>Since PERL_SYS_INIT3() may change &lt;code&gt;env&lt;/code&gt; , it may be more appropriate to provide &lt;code&gt;env&lt;/code&gt; as an argument to perl_parse().</source>
          <target state="translated">由于PERL_SYS_INIT3（）可能会更改 &lt;code&gt;env&lt;/code&gt; ，因此提供 &lt;code&gt;env&lt;/code&gt; 作为perl_parse（）的参数可能更合适。</target>
        </trans-unit>
        <trans-unit id="f7f8af64efb04a46b462c34b5604a1102a5d4309" translate="yes" xml:space="preserve">
          <source>Since PERL_SYS_INIT3() may change &lt;code&gt;env&lt;/code&gt;, it may be more appropriate to provide &lt;code&gt;env&lt;/code&gt; as an argument to perl_parse().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="908c64d54ba36fa8efadd65bbb91e193ec071dc5" translate="yes" xml:space="preserve">
          <source>Since Perl 5.004, however, this situation is a special case and Perl creates the hash key only when you make the assignment:</source>
          <target state="translated">但从Perl 5.004开始,这种情况属于特殊情况,Perl只在你进行赋值时才创建哈希键。</target>
        </trans-unit>
        <trans-unit id="a9ff67b0f4d57746c4f60694c82d05a6c7b9009b" translate="yes" xml:space="preserve">
          <source>Since Perl 5.16.0, the &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; token is available under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'current_sub'&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.16.0&lt;/code&gt; . It will evaluate to a reference to the currently-running sub, which allows for recursive calls without knowing your subroutine's name.</source>
          <target state="translated">因为Perl 5.16.0中， &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; 令牌下可 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'current_sub'&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.16.0&lt;/code&gt; 。它将评估对当前正在运行的子程序的引用，该引用允许递归调用而无需知道子程序的名称。</target>
        </trans-unit>
        <trans-unit id="d1a3d1fb600646bfa2800199a2796c986b7ed30e" translate="yes" xml:space="preserve">
          <source>Since Perl 5.16.0, the &lt;code&gt;__SUB__&lt;/code&gt; token is available under &lt;code&gt;use feature 'current_sub'&lt;/code&gt; and &lt;code&gt;use 5.16.0&lt;/code&gt;. It will evaluate to a reference to the currently-running sub, which allows for recursive calls without knowing your subroutine's name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fae0c1bd1740225eb42eb57769894f0dc25fdf8" translate="yes" xml:space="preserve">
          <source>Since Perl 5.18, the option &lt;code&gt;--libpods&lt;/code&gt; has been deprecated, and using this option did not do anything other than producing a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd0c9118f331aebc3c70bcab476c8b369f379f5" translate="yes" xml:space="preserve">
          <source>Since Perl 5.26, this functionality with the extra parameter has been available by using a corresponding macro to each one of these, and whose name is formed by appending &lt;code&gt;_safe&lt;/code&gt; to the base name. There is no change to the functionality of those. For example, &lt;code&gt;isDIGIT_utf8_safe&lt;/code&gt; corresponds to &lt;code&gt;isDIGIT_utf8&lt;/code&gt;, and both now behave identically. All are documented in &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;&quot;Character case changing&quot; in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#Character-classification&quot;&gt;&quot;Character classification&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd1865b1bb90979ee802c45310e91e7b7152674" translate="yes" xml:space="preserve">
          <source>Since Perl 5.6.1 the special variables @- and @+ can functionally replace $`, $&amp;amp; and $'. These arrays contain pointers to the beginning and end of each match (see perlvar for the full story), so they give you essentially the same information, but without the risk of excessive string copying.</source>
          <target state="translated">从Perl 5.6.1开始，特殊变量@-和@ +可以在功能上替换$`，$＆和$'。这些数组包含指向每个匹配的开始和结束的指针（有关完整信息，请参见perlvar），因此它们可以为您提供基本相同的信息，但不会产生过多的字符串复制风险。</target>
        </trans-unit>
        <trans-unit id="0c3b5811fc581b714a97d98184d154d442e77a68" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8, thread programming has been available using a model called</source>
          <target state="translated">从Perl 5.8开始,线程编程已经可以使用一个叫做</target>
        </trans-unit>
        <trans-unit id="8b1528960c7f653f3987ab48deb0e1d4226f3c72" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0 a file handle referring to a string can be created by calling open with a reference to that string instead of the filename. This file handle can then be used to read from or write to the string:</source>
          <target state="translated">从Perl 5.8.0开始,可以通过调用open来创建一个指向字符串的文件句柄,并引用该字符串而不是文件名。这个文件句柄可以用来读取或写入该字符串。</target>
        </trans-unit>
        <trans-unit id="e4d8eb9b8b02c94511ca94b8a0081bc372e591a2" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, if the first two elements of the list are &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;http://man.he.net/man2/utime&quot;&gt;utime(2)&lt;/a&gt; syscall from your C library is called with a null second argument. On most systems, this will set the file's access and modification times to the current time (i.e., equivalent to the example above) and will work even on files you don't own provided you have write permission:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd9a4f3a496c7e0b6fbb6d2a333860ae199a0774" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, if the first two elements of the list are &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the utime(2) syscall from your C library is called with a null second argument. On most systems, this will set the file's access and modification times to the current time (i.e., equivalent to the example above) and will work even on files you don't own provided you have write permission:</source>
          <target state="translated">从Perl 5.8.0开始，如果列表的前两个元素为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则使用空第二个参数调用C库中的utime（2）syscall。在大多数系统上，这会将文件的访问和修改时间设置为当前时间（即，等同于上面的示例），并且即使您拥有写权限，也可以在您不拥有的文件上使用：</target>
        </trans-unit>
        <trans-unit id="82732a952fbe092bd928ea5f2a3dfaabc967f5cd" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, if the first two elements of the list are &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the utime(2) syscall from your C library is called with a null second argument. On most systems, this will set the file's access and modification times to the current time (i.e., equivalent to the example above) and will work even on files you don't own provided you have write permission:</source>
          <target state="translated">从Perl 5.8.0开始，如果列表的前两个元素为 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则使用空第二个参数调用C库中的utime（2）syscall。在大多数系统上，这会将文件的访问和修改时间设置为当前时间（即，等同于上面的示例），并且即使您拥有写权限，也可以在您不拥有的文件上使用：</target>
        </trans-unit>
        <trans-unit id="e51f3522d03a5b3a232bf4033ea382564508f931" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, signals have been made safer in Perl by postponing their handling until the interpreter is in a</source>
          <target state="translated">从Perl 5.8.0开始,Perl中的信号处理已经变得更安全了,它将信号的处理推迟到解释器在</target>
        </trans-unit>
        <trans-unit id="f2d46e3f9d2d01548c43a50c625a8e637b891700" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, you can also use the list form of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; for pipes. This is preferred when you wish to avoid having the shell interpret metacharacters that may be in your command string.</source>
          <target state="translated">从Perl 5.8.0开始，您还可以使用 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; for pipe的列表形式。当您希望避免让Shell解释命令字符串中可能包含的元字符时，这是首选方法。</target>
        </trans-unit>
        <trans-unit id="718a678663da5c7f9393577cff7fa0dc58227371" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, you can also use the list form of &lt;code&gt;open&lt;/code&gt; for pipes. This is preferred when you wish to avoid having the shell interpret metacharacters that may be in your command string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3480b6dbc008fbf05d437030616ffbd60db1a205" translate="yes" xml:space="preserve">
          <source>Since Perl 5.9.5</source>
          <target state="translated">从Perl 5.9.5开始</target>
        </trans-unit>
        <trans-unit id="ce3c317911640225ca1493860827b3b6d9d6a56f" translate="yes" xml:space="preserve">
          <source>Since Perl doesn't currently do anything with the &lt;code&gt;LC_MONETARY&lt;/code&gt; category, specifying &lt;code&gt;:monetary&lt;/code&gt; does effectively nothing. Some systems have other categories, such as &lt;code&gt;LC_PAPER&lt;/code&gt;, but Perl also doesn't do anything with them, and there is no way to specify them in this pragma's arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83749785256b2bd98e45a0b0907ae739a924facc" translate="yes" xml:space="preserve">
          <source>Since Perl doesn't currently do anything with the &lt;code&gt;LC_MONETARY&lt;/code&gt; category, specifying &lt;code&gt;:monetary&lt;/code&gt; does effectively nothing. Some systems have other categories, such as &lt;code&gt;LC_PAPER_SIZE&lt;/code&gt; , but Perl also doesn't know anything about them, and there is no way to specify them in this pragma's arguments.</source>
          <target state="translated">由于Perl目前不对 &lt;code&gt;LC_MONETARY&lt;/code&gt; 类别执行任何操作，因此指定 &lt;code&gt;:monetary&lt;/code&gt; 实际上不会执行任何操作。某些系统具有其他类别，例如 &lt;code&gt;LC_PAPER_SIZE&lt;/code&gt; ，但Perl也不了解它们，因此无法在此编译指示中指定它们。</target>
        </trans-unit>
        <trans-unit id="7873f3b494192ca12067337abef4df445eb77998" translate="yes" xml:space="preserve">
          <source>Since Perl may compile the pattern at the moment of execution of the &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; operator, using &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; may have speed advantages in some situations, notably if the result of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; is used standalone:</source>
          <target state="translated">由于Perl可能会在执行 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; 运算符时编译模式，因此在某些情况下使用 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; 可能具有速度优势，特别是如果单独使用 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; 的结果：</target>
        </trans-unit>
        <trans-unit id="7ee8fc05b2f265e0275f90b02e962f3d6fb61694" translate="yes" xml:space="preserve">
          <source>Since Perl may compile the pattern at the moment of execution of the &lt;code&gt;qr()&lt;/code&gt; operator, using &lt;code&gt;qr()&lt;/code&gt; may have speed advantages in some situations, notably if the result of &lt;code&gt;qr()&lt;/code&gt; is used standalone:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a306c8d466811a3ef5f554b084c63b5f925fc7a3" translate="yes" xml:space="preserve">
          <source>Since Perl processes the &lt;code&gt;#!&lt;/code&gt; -line (cf. &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;DESCRIPTION in perlrun&lt;/a&gt;, &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;Command Switches in perlrun&lt;/a&gt;, &lt;a href=&quot;perldiag#No-Perl-script-found-in-input&quot;&gt;No Perl script found in input in perldiag&lt;/a&gt;), it should know when a program</source>
          <target state="translated">由于Perl处理 &lt;code&gt;#!&lt;/code&gt; 直插式（参见&lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;在perlrun描述&lt;/a&gt;，&lt;a href=&quot;perlrun#Command-Switches&quot;&gt;命令在perlrun开关&lt;/a&gt;，&lt;a href=&quot;perldiag#No-Perl-script-found-in-input&quot;&gt;无Perl脚本在perldiag输入中找到&lt;/a&gt;），就应该知道，当一个程序</target>
        </trans-unit>
        <trans-unit id="15eed331802dca8328c200227a6895f19cb9da5d" translate="yes" xml:space="preserve">
          <source>Since Perl processes the &lt;code&gt;#!&lt;/code&gt;-line (cf. &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;&quot;DESCRIPTION&quot; in perlrun&lt;/a&gt;, &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;&quot;Command Switches&quot; in perlrun&lt;/a&gt;, &lt;a href=&quot;perldiag#No-Perl-script-found-in-input&quot;&gt;&quot;No Perl script found in input&quot; in perldiag&lt;/a&gt;), it should know when a program</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7890be1aa1eaa7cb9334a73bda7962f1d481f1" translate="yes" xml:space="preserve">
          <source>Since Perl recognizes a Unicode Byte Order Mark at the start of files as signaling that the file is Unicode encoded as in UTF-16 (whether big-endian or little-endian) or UTF-8, Pod parsers should do the same. Otherwise, the character encoding should be understood as being UTF-8 if the first highbit byte sequence in the file seems valid as a UTF-8 sequence, or otherwise as CP-1252 (earlier versions of this specification used Latin-1 instead of CP-1252).</source>
          <target state="translated">由于Perl在文件开始时识别Unicode字节顺序标记,作为文件是Unicode编码的信号,如UTF-16(不管是big-endian还是little-endian)或UTF-8,Pod解析器也应该这样做。否则,如果文件中的第一个高位字节序列似乎是有效的UTF-8序列,那么字符编码应该被理解为UTF-8,否则就是CP-1252(本规范的早期版本使用Latin-1代替CP-1252)。</target>
        </trans-unit>
        <trans-unit id="ca8e547d2675a51d87227fd5471e1262dc702174" translate="yes" xml:space="preserve">
          <source>Since Perl v5.10.0 includes the version.pm comparison logic anyways, you don't need to do anything at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b73dcb8330d72308d60b51669745466fec012ac" translate="yes" xml:space="preserve">
          <source>Since Perl v5.22.0, calls to this function are optimized out on ASCII platforms, so there is no performance hit in using it there.</source>
          <target state="translated">从 Perl v5.22.0 开始,对这个函数的调用在 ASCII 平台上被优化了,所以在那里使用它不会影响性能。</target>
        </trans-unit>
        <trans-unit id="3b795b95acb54fe26d52c3d9e0c84f28d54d781c" translate="yes" xml:space="preserve">
          <source>Since Perl v5.6.0, Perl variable names may also be alphanumeric strings preceded by a caret. These must all be written in the form &lt;code&gt;${^Foo}&lt;/code&gt;; the braces are not optional. &lt;code&gt;${^Foo}&lt;/code&gt; denotes the scalar variable whose name is considered to be a control-&lt;code&gt;F&lt;/code&gt; followed by two &lt;code&gt;o&lt;/code&gt;'s. These variables are reserved for future special uses by Perl, except for the ones that begin with &lt;code&gt;^_&lt;/code&gt; (caret-underscore). No name that begins with &lt;code&gt;^_&lt;/code&gt; will acquire a special meaning in any future version of Perl; such names may therefore be used safely in programs. &lt;code&gt;$^_&lt;/code&gt; itself, however,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9077183204414786a18b0b5b41280a8b58d8fe93" translate="yes" xml:space="preserve">
          <source>Since Perl v5.6.0, Perl variable names may be alphanumeric strings that begin with a caret (or a control character, but this form is deprecated). These variables must be written in the form &lt;code&gt;${^Foo}&lt;/code&gt; ; the braces are not optional. &lt;code&gt;${^Foo}&lt;/code&gt; denotes the scalar variable whose name is a control-&lt;code&gt;F&lt;/code&gt; followed by two &lt;code&gt;o&lt;/code&gt; 's. These variables are reserved for future special uses by Perl, except for the ones that begin with &lt;code&gt;^_&lt;/code&gt; (control-underscore or caret-underscore). No control-character name that begins with &lt;code&gt;^_&lt;/code&gt; will acquire a special meaning in any future version of Perl; such names may therefore be used safely in programs. &lt;code&gt;$^_&lt;/code&gt; itself, however,</source>
          <target state="translated">从Perl v5.6.0开始，Perl变量名称可以是以脱字符号（或控制字符，但不建议使用此格式）开头的字母数字字符串。这些变量必须以 &lt;code&gt;${^Foo}&lt;/code&gt; 的形式编写；大括号不是可选的。 &lt;code&gt;${^Foo}&lt;/code&gt; 表示标量变量，名称为Control- &lt;code&gt;F&lt;/code&gt; ,后跟两个 &lt;code&gt;o&lt;/code&gt; 。这些变量保留给Perl供将来特殊用途，但以 &lt;code&gt;^_&lt;/code&gt; 开头的变量（control-underscore或caret-underscore）除外。以 &lt;code&gt;^_&lt;/code&gt; 开头的控制字符名称在任何将来的Perl版本中都不会具有特殊含义；因此，可以在程序中安全使用此类名称。 &lt;code&gt;$^_&lt;/code&gt; 本身，</target>
        </trans-unit>
        <trans-unit id="33f810cef075561e9d829f100d7d5982e746f4f2" translate="yes" xml:space="preserve">
          <source>Since PodParser-1.24 the &lt;b&gt;Pod::Checker&lt;/b&gt; module uses only the &lt;b&gt;poderror&lt;/b&gt; method to print errors and warnings. The summary output (e.g. &quot;Pod syntax OK&quot;) has been dropped from the module and has been included in &lt;b&gt;podchecker&lt;/b&gt; (the script). This allows users of &lt;b&gt;Pod::Checker&lt;/b&gt; to control completely the output behavior. Users of &lt;b&gt;podchecker&lt;/b&gt; (the script) get the well-known behavior.</source>
          <target state="translated">从PodParser-1.24开始，&lt;b&gt;Pod :: Checker&lt;/b&gt;模块仅使用&lt;b&gt;poderror&lt;/b&gt;方法打印错误和警告。摘要输出（例如&amp;ldquo; Pod语法正常&amp;rdquo;）已从模块中删除，并已包含在&lt;b&gt;podchecker&lt;/b&gt;（脚本）中。这使&lt;b&gt;Pod :: Checker的&lt;/b&gt;用户可以完全控制输出行为。用户&lt;b&gt;podchecker&lt;/b&gt;（脚本）获得著名的行为。</target>
        </trans-unit>
        <trans-unit id="25c4aa2f7c7ea22cd03f6256eb0cf383feb5378c" translate="yes" xml:space="preserve">
          <source>Since Storable version 2.05, CODE references may be serialized with the help of &lt;a href=&quot;B::Deparse&quot;&gt;B::Deparse&lt;/a&gt;. To enable this feature, set &lt;code&gt;$Storable::Deparse&lt;/code&gt; to a true value. To enable deserialization, &lt;code&gt;$Storable::Eval&lt;/code&gt; should be set to a true value. Be aware that deserialization is done through &lt;code&gt;eval&lt;/code&gt;, which is dangerous if the Storable file contains malicious data. You can set &lt;code&gt;$Storable::Eval&lt;/code&gt; to a subroutine reference which would be used instead of &lt;code&gt;eval&lt;/code&gt;. See below for an example using a &lt;a href=&quot;safe&quot;&gt;Safe&lt;/a&gt; compartment for deserialization of CODE references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c62ae1b79550d7e8d8b071446dadbd144fa9a44a" translate="yes" xml:space="preserve">
          <source>Since Storable version 2.05, CODE references may be serialized with the help of &lt;a href=&quot;b/deparse&quot;&gt;B::Deparse&lt;/a&gt;. To enable this feature, set &lt;code&gt;$Storable::Deparse&lt;/code&gt; to a true value. To enable deserialization, &lt;code&gt;$Storable::Eval&lt;/code&gt; should be set to a true value. Be aware that deserialization is done through &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, which is dangerous if the Storable file contains malicious data. You can set &lt;code&gt;$Storable::Eval&lt;/code&gt; to a subroutine reference which would be used instead of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. See below for an example using a &lt;a href=&quot;safe&quot;&gt;Safe&lt;/a&gt; compartment for deserialization of CODE references.</source>
          <target state="translated">从Storable 2.05版开始，CODE引用可以在&lt;a href=&quot;b/deparse&quot;&gt;B :: Deparse&lt;/a&gt;的帮助下进行序列化。要启用此功能，请将 &lt;code&gt;$Storable::Deparse&lt;/code&gt; 设置为真实值。要启用反序列化，应将 &lt;code&gt;$Storable::Eval&lt;/code&gt; 设置为真实值。请注意，反序列化是通过 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 完成的，如果Storable文件包含恶意数据，则这很危险。您可以将 &lt;code&gt;$Storable::Eval&lt;/code&gt; 设置为子例程引用，而不是 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 。请参阅下面的示例，该示例使用&lt;a href=&quot;safe&quot;&gt;安全&lt;/a&gt;隔间对CODE引用进行反序列化。</target>
        </trans-unit>
        <trans-unit id="c88a8ad5ec93e93fc48a98cd339628a0d0dbcb2e" translate="yes" xml:space="preserve">
          <source>Since UTF-7 is a 7-bit (re)encoded version of UTF-16BE, It is not part of Unicode's Character Encoding Scheme. It is separately implemented in Encode::Unicode::UTF7. For details see &lt;a href=&quot;Encode::Unicode::UTF7&quot;&gt;Encode::Unicode::UTF7&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0441a16b2e74d4d0e51c5a02d816d3fcef92571" translate="yes" xml:space="preserve">
          <source>Since UTF-7 is a 7-bit (re)encoded version of UTF-16BE, It is not part of Unicode's Character Encoding Scheme. It is separately implemented in Encode::Unicode::UTF7. For details see &lt;a href=&quot;unicode/utf7&quot;&gt;Encode::Unicode::UTF7&lt;/a&gt;.</source>
          <target state="translated">由于UTF-7是UTF-16BE的7位（重新）编码版本，因此它不是Unicode字符编码方案的一部分。它在Encode :: Unicode :: UTF7中单独实现。有关详细信息，请参见&lt;a href=&quot;unicode/utf7&quot;&gt;Encode :: Unicode :: UTF7&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2162d18e9f113918db80108542b383e4720b61a0" translate="yes" xml:space="preserve">
          <source>Since Unicode rules are not defined on these code points, if a Unicode-defined operation is done on them, Perl uses what we believe are sensible rules, while generally warning, using the &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; category. For example, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc(&quot;\x{11_0000}&quot;)&lt;/a&gt;&lt;/code&gt; will generate such a warning, returning the input parameter as its result, since Perl defines the uppercase of every non-Unicode code point to be the code point itself. (All the case changing operations, not just uppercasing, work this way.)</source>
          <target state="translated">由于未在这些代码点上定义Unicode规则，因此如果对它们进行Unicode定义的操作，Perl将使用我们认为是明智的规则，同时通常会使用 &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; 类别进行警告。例如，由于Perl将每个非Unicode代码点的大写字母定义为代码点本身，因此 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc(&quot;\x{11_0000}&quot;)&lt;/a&gt;&lt;/code&gt; 会生成这样的警告，并返回输入参数作为其结果。（所有大小写更改操作（不仅是大写字母）都以这种方式工作。）</target>
        </trans-unit>
        <trans-unit id="e37eae9f276840962a41c4b116e9f1cbc6df456a" translate="yes" xml:space="preserve">
          <source>Since Unicode rules are not defined on these code points, if a Unicode-defined operation is done on them, Perl uses what we believe are sensible rules, while generally warning, using the &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; category. For example, &lt;code&gt;uc(&quot;\x{11_0000}&quot;)&lt;/code&gt; will generate such a warning, returning the input parameter as its result, since Perl defines the uppercase of every non-Unicode code point to be the code point itself. (All the case changing operations, not just uppercasing, work this way.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7285a56d9c4d213c9ad280d3cdcf143edd27d7d8" translate="yes" xml:space="preserve">
          <source>Since VMS keeps track of files according to a different scheme than Unix, it's not really possible to represent the file's ID in the &lt;code&gt;st_dev&lt;/code&gt; and &lt;code&gt;st_ino&lt;/code&gt; fields of a &lt;code&gt;struct &lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; . Perl tries its best, though, and the values it uses are pretty unlikely to be the same for two different files. We can't guarantee this, though, so caveat scriptor.</source>
          <target state="translated">由于VMS根据与Unix不同的方案跟踪文件，因此实际上不可能在 &lt;code&gt;struct &lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;的 &lt;code&gt;st_dev&lt;/code&gt; 和 &lt;code&gt;st_ino&lt;/code&gt; 字段中表示文件的ID 。但是，Perl会尽力而为，并且对于两个不同的文件，它使用的值几乎不可能相同。但是，我们不能保证这一点，所以请告诫脚本编写者。</target>
        </trans-unit>
        <trans-unit id="f97165e0cc621ecf8ede47b3bb388f24e3bbd9ef" translate="yes" xml:space="preserve">
          <source>Since VMS keeps track of files according to a different scheme than Unix, it's not really possible to represent the file's ID in the &lt;code&gt;st_dev&lt;/code&gt; and &lt;code&gt;st_ino&lt;/code&gt; fields of a &lt;code&gt;struct stat&lt;/code&gt;. Perl tries its best, though, and the values it uses are pretty unlikely to be the same for two different files. We can't guarantee this, though, so caveat scriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5a9b6174ae871df152be709da101732e21f32c" translate="yes" xml:space="preserve">
          <source>Since Windows has nothing as simple as an executable bit, we check the file extension.</source>
          <target state="translated">由于Windows没有可执行位这么简单,我们检查文件扩展名。</target>
        </trans-unit>
        <trans-unit id="fd9730169823a0770803a5925e2496af06ca17b1" translate="yes" xml:space="preserve">
          <source>Since a TODO test does not need a reason, this function can return an empty string even when inside a TODO block. Use &lt;code&gt;$Test-&amp;gt;in_todo&lt;/code&gt; to determine if you are currently inside a TODO block.</source>
          <target state="translated">由于TODO测试不需要理由，因此即使在TODO块中，此函数也可以返回空字符串。使用 &lt;code&gt;$Test-&amp;gt;in_todo&lt;/code&gt; 确定您当前是否在TODO块中。</target>
        </trans-unit>
        <trans-unit id="9ae46893bafbcba3b5e81c0b6866dc9c42e9443c" translate="yes" xml:space="preserve">
          <source>Since a wide character does not fit into a byte, the Digest::SHA routines croak if they encounter one. Whereas if a Unicode string contains no wide characters, the module accepts it quite happily. The following code illustrates the two cases:</source>
          <target state="translated">由于宽字符不适合放在一个字节中,Digest::SHA例程在遇到宽字符时就会崩溃。而如果一个Unicode字符串不包含宽字符,模块就会很高兴地接受它。下面的代码说明了这两种情况。</target>
        </trans-unit>
        <trans-unit id="cf5ecd8beadbfc6894afc9b33f8c568a935ac82c" translate="yes" xml:space="preserve">
          <source>Since all &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directives are executed at compile-time, the only way to change overloading during run-time is to</source>
          <target state="translated">由于所有 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 指令都是在编译时执行的，因此在运行时更改重载的唯一方法是</target>
        </trans-unit>
        <trans-unit id="993a10b235330ad1f20f4c41c806f9d2c3a4329f" translate="yes" xml:space="preserve">
          <source>Since all &lt;code&gt;use&lt;/code&gt; directives are executed at compile-time, the only way to change overloading during run-time is to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121e9d461e86db932f5cbbcefdf834cbc71c32ee" translate="yes" xml:space="preserve">
          <source>Since all numbers are not objects, you can use all functions that are part of the BigInt or BigFloat API. It is wise to use only the bxxx() notation, and not the fxxx() notation, though. This makes you independent on the fact that the underlying object might morph into a different class than BigFloat.</source>
          <target state="translated">因为所有的数字都不是对象,所以你可以使用BigInt或BigFloat API中的所有函数。但明智的做法是只使用bxxx()符号,而不是fxxx()符号。这使得你可以独立于底层对象可能变形为一个不同于BigFloat的类的事实。</target>
        </trans-unit>
        <trans-unit id="a8ab3cbd0a89b8927ddf254335c455bf7a9e0853" translate="yes" xml:space="preserve">
          <source>Since all numbers are now objects, you can use all functions that are part of the BigInt API. You can only use the bxxx() notation, and not the fxxx() notation, though.</source>
          <target state="translated">由于所有的数字都是对象,你可以使用 BigInt API 的所有函数。你只能使用 bxxx()符号,而不能使用 fxxx()符号。</target>
        </trans-unit>
        <trans-unit id="4e2f7ef257d55f0fed05e16ea09bffefc9e8b92c" translate="yes" xml:space="preserve">
          <source>Since all numbers are now objects, you can use all functions that are part of the BigInt or BigFloat API. It is wise to use only the bxxx() notation, and not the fxxx() notation, though. This makes it possible that the underlying object might morph into a different class than BigFloat.</source>
          <target state="translated">由于现在所有的数字都是对象,所以你可以使用BigInt或BigFloat API中的所有函数。但明智的做法是只使用bxxx()符号,而不是fxxx()符号。这使得底层对象有可能变成一个不同于BigFloat的类。</target>
        </trans-unit>
        <trans-unit id="6baa6e390f30e8a9126d448dab3ed477bfa1776f" translate="yes" xml:space="preserve">
          <source>Since an expression &lt;code&gt;&quot;ab$cd,,&quot;&lt;/code&gt; is just a shortcut for &lt;code&gt;'ab' . $cd . ',,'&lt;/code&gt; , it is expected that overloaded constant strings are equipped with reasonable overloaded catenation operator, otherwise absurd results will result. Similarly, negative numbers are considered as negations of positive constants.</source>
          <target state="translated">由于表达式 &lt;code&gt;&quot;ab$cd,,&quot;&lt;/code&gt; 只是 &lt;code&gt;'ab' . $cd . ',,'&lt;/code&gt; 的快捷方式。$ cd。',,'，期望重载常量字符串配备合理的重载分类运算符，否则将导致荒谬的结果。类似地，负数被视为正常数的负数。</target>
        </trans-unit>
        <trans-unit id="9eab2e484706387d3cb0dc782cf2ac19206003e5" translate="yes" xml:space="preserve">
          <source>Since an expression &lt;code&gt;&quot;ab$cd,,&quot;&lt;/code&gt; is just a shortcut for &lt;code&gt;'ab' . $cd . ',,'&lt;/code&gt;, it is expected that overloaded constant strings are equipped with reasonable overloaded catenation operator, otherwise absurd results will result. Similarly, negative numbers are considered as negations of positive constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad22ba0685e5d4fac9ab43140e5e8b95922e320" translate="yes" xml:space="preserve">
          <source>Since any scalar can be passed as a pattern, it's possible to implement an engine that does something with an array (&lt;code&gt;&quot;ook&quot; =~ [ qw/ eek
hlagh / ]&lt;/code&gt; ) or with the non-stringified form of a compiled regular expression (&lt;code&gt;&quot;ook&quot; =~ qr/eek/&lt;/code&gt; ). Perl's own engine will always stringify everything using the snippet above, but that doesn't mean other engines have to.</source>
          <target state="translated">由于任何标量都可以作为模式传递，因此可以实现一种使用数组（ &lt;code&gt;&quot;ook&quot; =~ [ qw/ eek hlagh / ]&lt;/code&gt; ）或编译后的正则表达式的非字符串化形式（ &lt;code&gt;&quot;ook&quot; =~ qr/eek/&lt;/code&gt; ）。Perl自己的引擎将始终使用上面的代码片段对所有内容进行字符串化处理，但这并不意味着其他引擎必须这样做。</target>
        </trans-unit>
        <trans-unit id="a96aedcf3c01c8994f2ad1304c88bcd0b989eae9" translate="yes" xml:space="preserve">
          <source>Since any scalar can be passed as a pattern, it's possible to implement an engine that does something with an array (&lt;code&gt;&quot;ook&quot; =~ [ qw/ eek hlagh / ]&lt;/code&gt;) or with the non-stringified form of a compiled regular expression (&lt;code&gt;&quot;ook&quot; =~ qr/eek/&lt;/code&gt;). Perl's own engine will always stringify everything using the snippet above, but that doesn't mean other engines have to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641d084a3985af991bd9e2608e23022b03d9ab2f" translate="yes" xml:space="preserve">
          <source>Since blessed objects are actually stored as RV's, it is useful to use the typemap features to preprocess parameters and extract the actual SV stored within the blessed RV. See the sample for T_PTROBJ_SPECIAL below.</source>
          <target state="translated">由于受祝福的对象实际上是以RV的形式存储的,因此使用类型映射特征来预处理参数并提取受祝福的RV中存储的实际SV是很有用的。请看下面T_PTROBJ_SPECIAL的示例。</target>
        </trans-unit>
        <trans-unit id="8c4a595ff52b120e783068a746cfa5bbb3e02fd1" translate="yes" xml:space="preserve">
          <source>Since changing a slice changes the original array or hash that it's slicing, a &lt;code&gt;foreach&lt;/code&gt; construct will alter some--or even all--of the values of the array or hash.</source>
          <target state="translated">由于更改切片会更改切片的原始数组或哈希，因此 &lt;code&gt;foreach&lt;/code&gt; 构造会更改数组或哈希的某些（甚至全部）值。</target>
        </trans-unit>
        <trans-unit id="fe77918163189e19fb5ee32ad02fe79f3b55c3d3" translate="yes" xml:space="preserve">
          <source>Since code that runs both with and without threads is usually pretty messy, it's best to isolate the thread-specific code in its own module. In our example above, that's what &lt;code&gt;MyMod_threaded&lt;/code&gt; is, and it's only imported if we're running on a threaded Perl.</source>
          <target state="translated">由于同时运行和不运行线程的代码通常都很混乱，因此最好在其自己的模块中隔离特定于线程的代码。在上面的示例中，这就是 &lt;code&gt;MyMod_threaded&lt;/code&gt; ，仅当我们在线程Perl上运行时才导入。</target>
        </trans-unit>
        <trans-unit id="7cbe078e4c38d00728f285597cf545219cabca7e" translate="yes" xml:space="preserve">
          <source>Since cygwin-1.7 pathnames are UTF-8 encoded.</source>
          <target state="translated">因为cygwin-1.7的路径名是UTF-8编码的。</target>
        </trans-unit>
        <trans-unit id="266d3a18d9d36b211495f4b1c929d7f21c8d9c1c" translate="yes" xml:space="preserve">
          <source>Since cygwin-1.7 textmounts are deprecated and strongly discouraged.</source>
          <target state="translated">自 cygwin-1.7 以来,textmounts 已被废弃,并被强烈反对。</target>
        </trans-unit>
        <trans-unit id="d1be23ed029f3a9d2b3315834beff1a066fe092b" translate="yes" xml:space="preserve">
          <source>Since environment variables are normally in all uppercase, no additional special formatting is generally needed; they're glaring enough as it is.</source>
          <target state="translated">由于环境变量通常都是大写的,所以一般不需要额外的特殊格式,它们已经足够醒目了。</target>
        </trans-unit>
        <trans-unit id="7b1f94f3541d2fa04906c8d0560fd0adccde7ea8" translate="yes" xml:space="preserve">
          <source>Since evaluation of the translation function (see &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;&quot;CUSTOM TRANSLATORS&quot;&lt;/a&gt;) happens in the middle of compilation (of a string literal), the translation function should not do any &lt;code&gt;eval&lt;/code&gt;s or &lt;code&gt;require&lt;/code&gt;s. This restriction should be lifted (but is low priority) in a future version of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af76bf7b4202770a0de3b09fc13dec72dab7c4f4" translate="yes" xml:space="preserve">
          <source>Since evaluation of the translation function (see &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;CUSTOM TRANSLATORS&lt;/a&gt;) happens in the middle of compilation (of a string literal), the translation function should not do any &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;s or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;s. This restriction should be lifted (but is low priority) in a future version of Perl.</source>
          <target state="translated">由于对转换函数的评估（请参阅&lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;CUSTOM TRANSLATORS&lt;/a&gt;）发生在（字符串文字的）编译过程中，因此转换函数不应执行任何 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 。在Perl的未来版本中，应取消此限制（但优先级较低）。</target>
        </trans-unit>
        <trans-unit id="e702e67c36d5f56f32c4ca887c029adc55bb2d25" translate="yes" xml:space="preserve">
          <source>Since file associations don't work everywhere, and there are reportedly bugs with file associations where it does work, the old method of wrapping the perl script to make it look like a regular batch file to the OS, may be used. The install process makes available the &quot;pl2bat.bat&quot; script which can be used to wrap perl scripts into batch files. For example:</source>
          <target state="translated">由于文件关联并不是到处都能用,而且据说在能用的地方,文件关联也有错误,所以可以使用老方法,即包装 perl 脚本,让它看起来像一个普通的批处理文件。安装过程中提供了 &quot;pl2bat.bat &quot;脚本,可以用来将perl脚本包装成批处理文件。例如</target>
        </trans-unit>
        <trans-unit id="23fd0e0c0c88af650bd14da915c09ac6e76b1837" translate="yes" xml:space="preserve">
          <source>Since hash keys are strings, the default normalizer will not distinguish between &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and the empty string. It also won't work when the function's arguments are references. For example, consider a function &lt;code&gt;g&lt;/code&gt; which gets two arguments: A number, and a reference to an array of numbers:</source>
          <target state="translated">由于哈希键是字符串，因此默认规范化器将不会区分 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 和空字符串。当函数的参数是引用时，它也将不起作用。例如，考虑一个具有两个参数的函数 &lt;code&gt;g&lt;/code&gt; ：一个数字和对数字数组的引用：</target>
        </trans-unit>
        <trans-unit id="5436c585986115252a0eaae5572a50baa0e6e228" translate="yes" xml:space="preserve">
          <source>Since hash keys are strings, the default normalizer will not distinguish between &lt;code&gt;undef&lt;/code&gt; and the empty string. It also won't work when the function's arguments are references. For example, consider a function &lt;code&gt;g&lt;/code&gt; which gets two arguments: A number, and a reference to an array of numbers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1b02458a611387371114bfc83a2b6bef610aa1" translate="yes" xml:space="preserve">
          <source>Since in this example only the hostname was used, the redundant conversion of the port number into a service name may be omitted by passing the &lt;code&gt;NIx_NOSERV&lt;/code&gt; flag.</source>
          <target state="translated">由于在此示例中仅使用了主机名，因此可以通过传递 &lt;code&gt;NIx_NOSERV&lt;/code&gt; 标志来省略端口号到服务名的冗余转换。</target>
        </trans-unit>
        <trans-unit id="43ba5f496d72ffff6bead4e713df055d0751d289" translate="yes" xml:space="preserve">
          <source>Since it is an actual &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; (not a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;),</source>
          <target state="translated">由于这是实际 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; （而不是 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ），</target>
        </trans-unit>
        <trans-unit id="55f0899d2eb4523813b05345316dcef5758fc23e" translate="yes" xml:space="preserve">
          <source>Since it is an actual &lt;code&gt;do&lt;/code&gt; (not a &lt;code&gt;require&lt;/code&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb621853d8928b75d75f89c40a84cc2ef109eca4" translate="yes" xml:space="preserve">
          <source>Since it is based on Linux, the NAS can run many popular Linux software packages, including Perl. In fact, Synology provides a ready-to-install package for Perl, depending on the version of DSM the installed perl ranges from 5.8.6 on DSM-4.3 to 5.24.0 on DSM-6.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7acf7de7efee5f314675d9545729adcf4f4695" translate="yes" xml:space="preserve">
          <source>Since it is only at the compilation stage that the operator mask applies, controlled access to potentially unsafe operations can be achieved by having a handle to a wrapper subroutine (written outside the compartment) placed into the compartment. For example,</source>
          <target state="translated">由于只有在编译阶段才会应用操作者掩码,因此可以通过将封装子程序(写在隔间外)的句柄放入隔间内,实现对潜在的不安全操作的控制访问。例如</target>
        </trans-unit>
        <trans-unit id="1f11ca56ce1f8e288941a46d45decb0b96762c16" translate="yes" xml:space="preserve">
          <source>Since it's a common mistake to use &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;, Perl warns you if &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; is called in void context and if there is a following statement that isn't &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#warn-LIST&quot;&gt;&lt;code&gt;warn&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#exit-EXPR&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt; (if &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; are enabled--but you always do that, right?). If you</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="194e3b48a27a3bdaa4b431c05b89584d736f7041" translate="yes" xml:space="preserve">
          <source>Since it's a common mistake to use &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, Perl warns you if &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; is called in void context and if there is a following statement that isn't &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; (if &lt;code&gt;-w&lt;/code&gt; is set--but you always do that, right?). If you</source>
          <target state="translated">由于使用 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 是一个常见的错误，因此Perl会警告您，如果在void上下文中调用 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; ，并且以下语句不是 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; （如果设置了 &lt;code&gt;-w&lt;/code&gt; ，但始终这样做吧？）。如果你</target>
        </trans-unit>
        <trans-unit id="84dfc8fed05280b5766bcde26ffe3ad58754f68f" translate="yes" xml:space="preserve">
          <source>Since it's a common mistake to use &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, Perl warns you if &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; is called in void context and if there is a following statement that isn't &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; (if &lt;code&gt;-w&lt;/code&gt; is set--but you always do that, right?). If you</source>
          <target state="translated">由于使用 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 是一个常见的错误，因此Perl会警告您，如果在void上下文中调用 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; ，并且以下语句不是 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; （如果设置了 &lt;code&gt;-w&lt;/code&gt; ，但始终这样做吧？）。如果你</target>
        </trans-unit>
        <trans-unit id="738084392e8e6e74486d375f063b4666c3458a7c" translate="yes" xml:space="preserve">
          <source>Since just passing an SV to an XS function and copying the data of the SV is not enough to copy the UTF8 flags, even less right is just passing a &lt;code&gt;char *&lt;/code&gt; to an XS function.</source>
          <target state="translated">由于仅将SV传递给XS函数并复制SV的数据不足以复制UTF8标志，因此，将 &lt;code&gt;char *&lt;/code&gt; 传递给XS函数的权利就更少了。</target>
        </trans-unit>
        <trans-unit id="b9469e3eb840b801f9d7d7208ec99b06d836b6ea" translate="yes" xml:space="preserve">
          <source>Since kernel threading can interrupt a thread at any time, they will uncover some of the implicit locking assumptions you may make in your program. For example, something as simple as &lt;code&gt;$x = $x + 2&lt;/code&gt; can behave unpredictably with kernel threads if &lt;code&gt;$x&lt;/code&gt; is visible to other threads, as another thread may have changed &lt;code&gt;$x&lt;/code&gt; between the time it was fetched on the right hand side and the time the new value is stored.</source>
          <target state="translated">由于内核线程可以随时中断线程，因此它们将揭示您可能在程序中做出的一些隐式锁定假设。例如，如果 &lt;code&gt;$x&lt;/code&gt; 对其他线程可见，则诸如 &lt;code&gt;$x = $x + 2&lt;/code&gt; 简单事件在内核线程中的行为可能无法预测，因为另一个线程可能在从右侧获取 &lt;code&gt;$x&lt;/code&gt; 到取回$ x的时间之间已经更改了$ x。新值的存储时间。</target>
        </trans-unit>
        <trans-unit id="50bf4cd3ab25a16dfb39690f40c89ca9d71697ee" translate="yes" xml:space="preserve">
          <source>Since many pieces of code create tiny subroutines consisting of only a few ops, and since a huge slab would be quite a bit of baggage for those to carry around, the first slab is always very small. To avoid allocating too many slabs for a single CV, each subsequent slab is twice the size of the previous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c7d09052cf4af0cf4ad320357c5a1a11966392" translate="yes" xml:space="preserve">
          <source>Since numbers are actually objects, you can call all the usual methods from BigInt/BigFloat on them. This even works to some extent on expressions:</source>
          <target state="translated">因为数字实际上是对象,所以你可以调用BigInt/BigFloat的所有常用方法。这甚至在一定程度上可以用于表达式。</target>
        </trans-unit>
        <trans-unit id="ae2a46b8ade0fb9460587cc2799fe61eb4a8fb37" translate="yes" xml:space="preserve">
          <source>Since perl 5.17.1</source>
          <target state="translated">从perl 5.17.1开始</target>
        </trans-unit>
        <trans-unit id="3f51453ac56d21d59ae3e879a25ac51097e95502" translate="yes" xml:space="preserve">
          <source>Since perl does not (yet?) support constant objects, these constants are in seconds only, so you cannot, for example, do this: &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; ONE_WEEK-&amp;gt;minutes;&lt;/code&gt;</source>
          <target state="translated">由于perl还不支持常量对象，因此这些常量仅以秒为单位，因此，例如，您不能这样做： &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; ONE_WEEK-&amp;gt;minutes;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cab6e87a3c1e5785b11343a6d4dd9e12fc5fa718" translate="yes" xml:space="preserve">
          <source>Since perl does not (yet?) support constant objects, these constants are in seconds only, so you cannot, for example, do this: &lt;code&gt;print ONE_WEEK-&amp;gt;minutes;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea4faada9587774e63ccd6c739ed955f5067def" translate="yes" xml:space="preserve">
          <source>Since pi &amp;asymp; 355/116 is only accurate to 6 decimal places, you would want to say:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6206d48617efe1643080f044370ee3db2757b71" translate="yes" xml:space="preserve">
          <source>Since release 1.77, CPAN.pm has been able to verify cryptographically signed module distributions using Module::Signature. The CPAN modules can be signed by their authors, thus giving more security. The simple unsigned MD5 checksums that were used before by CPAN protect mainly against accidental file corruption.</source>
          <target state="translated">自1.77版本以来,CPAN.pm已经能够使用Module::Signature来验证加密签名的模块发布。CPAN模块可以由它们的作者签名,从而提供更多的安全性。CPAN之前使用的简单的无符号MD5校验和,主要是为了防止意外的文件损坏。</target>
        </trans-unit>
        <trans-unit id="f410d2ff83f136d497487286db5d2eccb910e974" translate="yes" xml:space="preserve">
          <source>Since some operations can be automatically generated from others, there is a minimal set of operations that need to be overloaded in order to have the complete set of overloaded operations at one's disposal. Of course, the autogenerated operations may not do exactly what the user expects. The minimal set is:</source>
          <target state="translated">由于有些操作可以从其他操作中自动生成,因此,要想拥有一套完整的过载操作供自己支配,就需要有一套最小的操作。当然,自动生成的操作可能并不完全按照用户的期望来做。这个最小集是:</target>
        </trans-unit>
        <trans-unit id="9e13ee98073f6b6ff77b6bcc87f449d4c9298e6d" translate="yes" xml:space="preserve">
          <source>Since static extensions are incorporated directly into</source>
          <target state="translated">由于静态扩展是直接纳入到</target>
        </trans-unit>
        <trans-unit id="a88aba659efeb2d72344fd5945ed041580ceab14" translate="yes" xml:space="preserve">
          <source>Since storage is performed recursively, you might want to stuff references to objects that share a lot of common data into a single array or hash table, and then store that object. That way, when you retrieve back the whole thing, the objects will continue to share what they originally shared.</source>
          <target state="translated">由于存储是以递归方式进行的,所以你可能想把共享很多共同数据的对象的引用塞进一个数组或哈希表中,然后存储这个对象。这样,当你检索回整个对象时,这些对象将继续共享它们最初共享的内容。</target>
        </trans-unit>
        <trans-unit id="9ba4735b13fee2b9416d8bafb7be0fc636ca00de" translate="yes" xml:space="preserve">
          <source>Since subroutines implementing assignment operators are not required to modify their operands (see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;&quot;Overloadable Operations&quot;&lt;/a&gt; above), we do not need anything special to make &lt;code&gt;+=&lt;/code&gt; and friends work, besides adding these operators to %subr and defining a copy constructor (needed since Perl has no way to know that the implementation of &lt;code&gt;'+='&lt;/code&gt; does not mutate the argument - see &lt;a href=&quot;#Copy-Constructor&quot;&gt;&quot;Copy Constructor&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b31e0831fe480c7543658e6a5c02d003d2e334" translate="yes" xml:space="preserve">
          <source>Since subroutines implementing assignment operators are not required to modify their operands (see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; above), we do not need anything special to make &lt;code&gt;+=&lt;/code&gt; and friends work, besides adding these operators to %subr and defining a copy constructor (needed since Perl has no way to know that the implementation of &lt;code&gt;'+='&lt;/code&gt; does not mutate the argument - see &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;).</source>
          <target state="translated">由于实现赋值运算符的子例程不需要修改其操作数（请参见上面的可&lt;a href=&quot;#Overloadable-Operations&quot;&gt;重载操作&lt;/a&gt;），因此，除了将这些运算符添加到％subr并定义副本构造函数（Perl具有此功能而需要）之外，使 &lt;code&gt;+=&lt;/code&gt; 和好友工作不需要任何特殊操作。没有办法知道 &lt;code&gt;'+='&lt;/code&gt; 的实现不会改变参数-请参见&lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="39828fbb336c2f70993a4540589d36ff13c1f2fe" translate="yes" xml:space="preserve">
          <source>Since such a construct is equivalent to using an empty string, you are recommended to remove such &lt;code&gt;\N{}&lt;/code&gt; constructs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24efb6846ccb0dd586c9a2d632cd24665dcacdba" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;UNIVERSAL::VERSION&lt;/code&gt; method treats the &lt;code&gt;$VERSION&lt;/code&gt; number as a simple numeric value it will regard version 1.10 as lower than 1.9. For this reason it is strongly recommended that you use numbers with at least two decimal places, e.g., 1.09.</source>
          <target state="translated">由于 &lt;code&gt;UNIVERSAL::VERSION&lt;/code&gt; 方法将 &lt;code&gt;$VERSION&lt;/code&gt; 数字视为一个简单的数字值，因此它将版本1.10低于1.9。因此，强烈建议您使用至少两个小数位的数字，例如1.09。</target>
        </trans-unit>
        <trans-unit id="9984a40959f39d46f91cc9c90e354da67e76965d" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;ops&lt;/code&gt; pragma currently has an irreversible global effect, it is only of significant practical use with the &lt;code&gt;-M&lt;/code&gt; option on the command line.</source>
          <target state="translated">由于 &lt;code&gt;ops&lt;/code&gt; pragma当前具有不可逆的全局效果，因此仅在命令行上带有 &lt;code&gt;-M&lt;/code&gt; 选项才具有实际意义。</target>
        </trans-unit>
        <trans-unit id="953376be0c1beefb5a7844380d81b187b71cbf9b" translate="yes" xml:space="preserve">
          <source>Since the CV takes ownership of its slab when flagged, that flag is never copied when a CV is cloned, as one CV could free a slab that another CV still points to, since forced freeing of ops ignores the reference count (but asserts that it looks right).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926a29507017e24c08c49eb96c57773fd03c95dd" translate="yes" xml:space="preserve">
          <source>Since the MD5 algorithm is byte oriented you might only add bits as multiples of 8, so you probably want to just use add() instead. The add_bits() method is provided for compatibility with other digest implementations. See &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; for description of the arguments that add_bits() take.</source>
          <target state="translated">由于MD5算法是面向字节的，因此您可能只将位添加为8的倍数，因此您可能只想使用add（）。提供add_bits（）方法是为了与其他摘要实现兼容。有关add_bits（）接受的参数的说明，请参见&lt;a href=&quot;../digest&quot;&gt;摘要&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b38cceb121fc001ce43895b005634147912b7f28" translate="yes" xml:space="preserve">
          <source>Since the MD5 algorithm is byte oriented you might only add bits as multiples of 8, so you probably want to just use add() instead. The add_bits() method is provided for compatibility with other digest implementations. See &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; for description of the arguments that add_bits() take.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf00ba41dfb6029d72bbfa314d984c685681962" translate="yes" xml:space="preserve">
          <source>Since the MD5 algorithm is only defined for strings of bytes, it can not be used on strings that contains chars with ordinal number above 255 (Unicode strings). The MD5 functions and methods will croak if you try to feed them such input data:</source>
          <target state="translated">由于 MD5 算法只定义了字节串,所以它不能用于包含序数大于 255 的字符的字符串(Unicode 字符串)。如果你试图输入这样的输入数据,MD5函数和方法会崩溃。</target>
        </trans-unit>
        <trans-unit id="4504893c7038fe54de5cf229bf7abc99b79c512f" translate="yes" xml:space="preserve">
          <source>Since the Perl extension DLLs are always loaded with the full path, there is no need to mangle their names in a version-specific ways: their directory already reflects the corresponding version of perl, and @INC takes into account binary compatibility with older version. Starting from &lt;code&gt;5.6.2&lt;/code&gt; the name mangling scheme is fixed to be the same as for Perl 5.005_53 (same as in a popular binary release). Thus new Perls will be able to</source>
          <target state="translated">由于Perl扩展DLL始终以完整路径加载，因此无需以版本特定的方式更改名称：它们的目录已经反映了Perl的相应版本，并且@INC考虑到与旧版本的二进制兼容性。从 &lt;code&gt;5.6.2&lt;/code&gt; 开始，名称处理方案已固定为与Perl 5.005_53相同（与流行的二进制发行版中的相同）。因此，新的Perls将能够</target>
        </trans-unit>
        <trans-unit id="d9753e3adbb08c389f10d17cb835e755759949e1" translate="yes" xml:space="preserve">
          <source>Since the VMS linker distinguishes symbols based only on the first 31 characters of their names, it is occasionally necessary to shorten symbol names in order to avoid collisions. (This is especially true of names generated by xsubpp, since prefixes generated by nested package names can become quite long.) &lt;code&gt;ExtUtils::XSSymSet&lt;/code&gt; provides functions to shorten names in a consistent fashion, and to track a set of names to insure that each is unique. While designed with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3bc7c77475d3cf936d8648a172f314719ec1f56" translate="yes" xml:space="preserve">
          <source>Since the first character of $x matched the regex, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; prepended an empty initial element to the list.</source>
          <target state="translated">由于$ x的第一个字符与正则表达式匹配，所以 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 在列表的前面添加了一个空的初始元素。</target>
        </trans-unit>
        <trans-unit id="e30d9369cb9f674a0338e525db18f9f146fc0752" translate="yes" xml:space="preserve">
          <source>Since the first character of $x matched the regex, &lt;code&gt;split&lt;/code&gt; prepended an empty initial element to the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2334de3a289af7777d7979b79868746517ddea3f" translate="yes" xml:space="preserve">
          <source>Since the first character of $x matched the regexp, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; prepended an empty initial element to the list.</source>
          <target state="translated">由于$ x的第一个字符与正则表达式匹配，所以 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 在列表的前面添加了一个空的初始元素。</target>
        </trans-unit>
        <trans-unit id="dfb32be28d90dd8cfadf42b0da79f140a1aebe0c" translate="yes" xml:space="preserve">
          <source>Since the first character of &lt;code&gt;$x&lt;/code&gt; matched the regexp, &lt;code&gt;split&lt;/code&gt; prepended an empty initial element to the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9108eba2d411db85e70e8df1569d830e2a5d25c" translate="yes" xml:space="preserve">
          <source>Since the fork() emulation runs code in multiple threads, extensions calling into non-thread-safe libraries may not work reliably when calling fork(). As Perl's threading support gradually becomes more widely adopted even on platforms with a native fork(), such extensions are expected to be fixed for thread-safety.</source>
          <target state="translated">由于fork()仿真是在多个线程中运行代码,所以在调用fork()时,调用到非线程安全库的扩展可能无法可靠地工作。随着Perl的线程支持逐渐被广泛采用,即使是在有原生fork()的平台上,这类扩展也有望得到线程安全的修复。</target>
        </trans-unit>
        <trans-unit id="b5c6d6292298eef29abac825fb611cdb8dbc410b" translate="yes" xml:space="preserve">
          <source>Since the logging doesn't use PerlIO, all SV allocations are logged and no extra SV allocations are introduced by enabling the logging. If compiled with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; , the serial number for each SV allocation is also logged.</source>
          <target state="translated">由于日志记录不使用PerlIO，因此将记录所有SV分配，并且通过启用日志记录不会引入额外的SV分配。如果使用 &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; 进行编译，则还将记录每个SV分配的序列号。</target>
        </trans-unit>
        <trans-unit id="3e539eeb6fc84357572fa6a057c29a86c8133533" translate="yes" xml:space="preserve">
          <source>Since the logging doesn't use PerlIO, all SV allocations are logged and no extra SV allocations are introduced by enabling the logging. If compiled with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt;, the serial number for each SV allocation is also logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3279571aa6d0a69a5a2abdeb30f262cc44dbbdae" translate="yes" xml:space="preserve">
          <source>Since the match operator &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, the substitution operator &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, and the regular expression quoting operator &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; are double-quotish constructs, you can interpolate variables into the pattern. See the answer to &quot;How can I quote a variable to use in a regex?&quot; for more details.</source>
          <target state="translated">由于匹配运算符 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; ，替换运算符 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 和正则表达式引用运算符 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 是双引号的构造，因此可以将变量插值到模式中。请参阅&amp;ldquo;如何引用要在正则表达式中使用的变量？&amp;rdquo;的答案。更多细节。</target>
        </trans-unit>
        <trans-unit id="7344ea0eab36d0c1c0f9a8a859bf628b21f3791b" translate="yes" xml:space="preserve">
          <source>Since the match operator &lt;code&gt;m//&lt;/code&gt;, the substitution operator &lt;code&gt;s///&lt;/code&gt;, and the regular expression quoting operator &lt;code&gt;qr//&lt;/code&gt; are double-quotish constructs, you can interpolate variables into the pattern. See the answer to &quot;How can I quote a variable to use in a regex?&quot; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b10458d44f04e31c63c483bc8240735b5e37c7" translate="yes" xml:space="preserve">
          <source>Since the null filehandle uses the two argument form of &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; it interprets special characters, so if you have a script like this:</source>
          <target state="translated">由于null文件句柄使用&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;的两个参数形式，因此它将解释特殊字符，因此，如果您具有如下脚本：</target>
        </trans-unit>
        <trans-unit id="66fb7ce305be412987d9aacf9b06a1422f1fe031" translate="yes" xml:space="preserve">
          <source>Since the null filehandle uses the two argument form of &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt; it interprets special characters, so if you have a script like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd81accbd1bb6c167fba1a41e5f2407058ac7a87" translate="yes" xml:space="preserve">
          <source>Since the object is also a hash, you can treat it as one, using it to store data associated with the object. Typically, code inside the class can treat the hash as an accessible data structure, while code outside the class should always treat the object as opaque. This is called &lt;b&gt;encapsulation&lt;/b&gt;. Encapsulation means that the user of an object does not have to know how it is implemented. The user simply calls documented methods on the object.</source>
          <target state="translated">由于对象也是哈希，因此您可以将其视为一个哈希，使用它来存储与对象关联的数据。通常，类内部的代码可以将哈希视为可访问的数据结构，而类外部的代码应始终将对象视为不透明。这称为&lt;b&gt;封装&lt;/b&gt;。封装意味着对象的用户不必知道其实现方式。用户只需在对象上调用记录的方法。</target>
        </trans-unit>
        <trans-unit id="db12f27020b74e90b153b0c7282afabc69308986" translate="yes" xml:space="preserve">
          <source>Since the original &lt;code&gt;big5&lt;/code&gt; encoding (1984) is not supported anywhere (glibc and DOS-based systems uses &lt;code&gt;big5&lt;/code&gt; to mean &lt;code&gt;big5-eten&lt;/code&gt; ; Microsoft uses &lt;code&gt;big5&lt;/code&gt; to mean &lt;code&gt;cp950&lt;/code&gt; ), a conscious decision was made to alias &lt;code&gt;big5&lt;/code&gt; to &lt;code&gt;big5-eten&lt;/code&gt; , which is the de facto superset of the original big5.</source>
          <target state="translated">由于原来的 &lt;code&gt;big5&lt;/code&gt; 编码（1984）不被任何支持（glibc的和基于DOS的系统中的使用 &lt;code&gt;big5&lt;/code&gt; 的意思 &lt;code&gt;big5-eten&lt;/code&gt; ;微软使用 &lt;code&gt;big5&lt;/code&gt; 的意思 &lt;code&gt;cp950&lt;/code&gt; ），有意识的决定，以别名做 &lt;code&gt;big5&lt;/code&gt; 到 &lt;code&gt;big5-eten&lt;/code&gt; ，这是原始big5的事实上的超集。</target>
        </trans-unit>
        <trans-unit id="d8d087310b96c8a2161d52fb071f50cb14fd5ed5" translate="yes" xml:space="preserve">
          <source>Since the original &lt;code&gt;big5&lt;/code&gt; encoding (1984) is not supported anywhere (glibc and DOS-based systems uses &lt;code&gt;big5&lt;/code&gt; to mean &lt;code&gt;big5-eten&lt;/code&gt;; Microsoft uses &lt;code&gt;big5&lt;/code&gt; to mean &lt;code&gt;cp950&lt;/code&gt;), a conscious decision was made to alias &lt;code&gt;big5&lt;/code&gt; to &lt;code&gt;big5-eten&lt;/code&gt;, which is the de facto superset of the original big5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e096824f5ca19792394259581d18c44d0fb48327" translate="yes" xml:space="preserve">
          <source>Since the path separators are different on some operating systems ('/' on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec modules wherever portability is a concern.</source>
          <target state="translated">因为在某些操作系统上,路径分隔符是不同的(Unix上的'/',MacPerl上的':'等),所以我们建议你在考虑到可移植性的地方使用File::Spec模块。</target>
        </trans-unit>
        <trans-unit id="8b814beacf19306d64e3fcdb9e9e2ebc37bd2f9a" translate="yes" xml:space="preserve">
          <source>Since the return value of EXPR is executed as a block within the lexical context of the current Perl program, any outer lexical variables are visible to it, and any package variable settings or subroutine and format definitions remain afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc1d2d6e3b782b2dd5e1481aef1464f9b2e04bc" translate="yes" xml:space="preserve">
          <source>Since the scope wasn't lexical, other modules' use of &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">由于范围不是词法，其他模块的使用的 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="a424c04edb43b51178f65103d1803116d4fd0aaa" translate="yes" xml:space="preserve">
          <source>Since the scope wasn't lexical, other modules' use of &lt;code&gt;chr&lt;/code&gt;, &lt;code&gt;ord&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b947b7b4bc7b90e1cd94b89023d67ed8fe406b" translate="yes" xml:space="preserve">
          <source>Since the symbols listed within &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; must also appear in either &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; , two utility functions are provided which allow you to easily add tagged sets of symbols to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; :</source>
          <target state="translated">由于 &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 中列出的符号还必须出现在 &lt;code&gt;@EXPORT&lt;/code&gt; 或 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 中，因此提供了两个实用程序功能，使您可以轻松地将标记的符号集添加到 &lt;code&gt;@EXPORT&lt;/code&gt; 或 &lt;code&gt;@EXPORT_OK&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="12348ccf02ace58fde57dcb8fdfe6146a5174932" translate="yes" xml:space="preserve">
          <source>Since the symbols listed within &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; must also appear in either &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt;, two utility functions are provided which allow you to easily add tagged sets of symbols to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1ad4491daa19cab8cfcffcbf76d31fdb6dedaa" translate="yes" xml:space="preserve">
          <source>Since the text to insert should be different in &lt;code&gt;bytes&lt;/code&gt; mode and out of it, the function should check the current state of &lt;code&gt;bytes&lt;/code&gt; -flag as in:</source>
          <target state="translated">由于要插入的文本在 &lt;code&gt;bytes&lt;/code&gt; 模式下和在字节模式下应该不同，因此该函数应检查 &lt;code&gt;bytes&lt;/code&gt; -flag 的当前状态，如下所示：</target>
        </trans-unit>
        <trans-unit id="a18ac7a6a5b44dc9939056baa28ada3143807b7e" translate="yes" xml:space="preserve">
          <source>Since the text to insert should be different in &lt;code&gt;bytes&lt;/code&gt; mode and out of it, the function should check the current state of &lt;code&gt;bytes&lt;/code&gt;-flag as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b57f88b4da7c64e61f7bcbc6480133424225f899" translate="yes" xml:space="preserve">
          <source>Since the total size of all Perl SIS files once installed is over 2 MB, it is recommended to do the installation into a memory card (drive E:) instead of the C: drive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50530d766e72e0b6fff4d2cca6e94d3aad2090a6" translate="yes" xml:space="preserve">
          <source>Since there are relatively few objects in a picture, there are only a few colors, which get looked up over and over again. Memoizing &lt;code&gt;ColorToRGB&lt;/code&gt; sped up the program by several percent.</source>
          <target state="translated">由于图片中的对象相对较少，因此只有少数几种颜色会一遍又一遍地查找。记忆 &lt;code&gt;ColorToRGB&lt;/code&gt; 使程序加速了百分之几。</target>
        </trans-unit>
        <trans-unit id="6cb6a83a2f2c3167da777a122214abb67623928e" translate="yes" xml:space="preserve">
          <source>Since there are so many, they are presented in table format with languages and corresponding encoding names by vendors. Note that the table is sorted in order of ISO-8859 and the corresponding vendor mappings are slightly different from that of ISO. See &lt;a href=&quot;http://czyborra.com/charsets/iso8859.html&quot;&gt;http://czyborra.com/charsets/iso8859.html&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29f8659dcd90c4211c87b64479756be9287fa54" translate="yes" xml:space="preserve">
          <source>Since there is a bijection between a point in the 2D plane and a complex number (i.e. the mapping is unique and reciprocal), a complex number can also be uniquely identified with polar coordinates:</source>
          <target state="translated">由于二维平面上的点与复数之间存在着双项关系(即映射是唯一的、往复的),所以复数也可以与极坐标进行唯一的识别。</target>
        </trans-unit>
        <trans-unit id="bc706817bd3a8e95c1023efd45beb0908b6a5e49" translate="yes" xml:space="preserve">
          <source>Since these aren't legal POSIX class specifications, but are legal bracketed character classes, Perl treats them as the latter. In the first example, it matches the characters &lt;code&gt;&quot;:&quot;&lt;/code&gt;, &lt;code&gt;&quot;[&quot;&lt;/code&gt;, &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;l&quot;&lt;/code&gt;, &lt;code&gt;&quot;m&quot;&lt;/code&gt;, &lt;code&gt;&quot;n&quot;&lt;/code&gt;, and &lt;code&gt;&quot;u&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3716c24306b4924201a3a983711259349f4d7b7c" translate="yes" xml:space="preserve">
          <source>Since these functions are different for most operating systems, each set of OS specific routines is available in a separate module, including:</source>
          <target state="translated">由于这些功能对大多数操作系统来说都是不同的,每一套操作系统的特定例程都在一个单独的模块中提供,包括:</target>
        </trans-unit>
        <trans-unit id="61e7fa1fca7db47b0de02fb29d8bdc7a036c2ad4" translate="yes" xml:space="preserve">
          <source>Since these macros have side-effects don't use them as arguments to macros that may evaluate their argument several times, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d20e57f802de1056f71e94f07efcc76036480f" translate="yes" xml:space="preserve">
          <source>Since things like &lt;code&gt;&lt;a href=&quot;../functions/sqrt&quot;&gt;sqrt(2)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;1 / 3&lt;/code&gt; must presented with a limited accuracy lest a operation consumes all resources, each operation produces no more than the requested number of digits.</source>
          <target state="translated">由于必须以有限的精度呈现诸如 &lt;code&gt;&lt;a href=&quot;../functions/sqrt&quot;&gt;sqrt(2)&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;1 / 3&lt;/code&gt; ，以免操作消耗所有资源，因此每个操作产生的位数不超过请求的位数。</target>
        </trans-unit>
        <trans-unit id="55385d26f11babeaaffc540cfe07e740a0d30a4d" translate="yes" xml:space="preserve">
          <source>Since things like &lt;code&gt;sqrt(2)&lt;/code&gt; or &lt;code&gt;1 / 3&lt;/code&gt; must presented with a limited accuracy lest a operation consumes all resources, each operation produces no more than the requested number of digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a21b989b9d575d7d2eef7cf2bea0c2bc7b6c1e" translate="yes" xml:space="preserve">
          <source>Since this document was first written, the convention has become more and more to use hexadecimal notation for code points. To do this with the recipes and to also sort is a multi-step process, so here, for convenience, is the table from above, re-sorted to be in Code Page 1047 order, and using hex notation.</source>
          <target state="translated">自本文档写成以来,越来越多的约定俗成地使用十六进制的码点符号。要做到这一点,对菜谱也要进行排序,是一个多步骤的过程,所以这里为了方便起见,是上面的表格,重新排序为码页1047顺序,并使用十六进制符号。</target>
        </trans-unit>
        <trans-unit id="ef4f428bd8f59049b7e023a3a37d2ecfa135c01b" translate="yes" xml:space="preserve">
          <source>Since this is 0.something release, any future releases are almost guaranteed to be binary incompatible. As a sign of this the Symbian symbol exports are kept unfrozen and the .def files fully rebuilt every time.</source>
          <target state="translated">由于这是0.something版本,任何未来的版本几乎都保证是二进制不兼容的。作为一个标志,Symbian的符号出口被解冻,每次都会完全重建.def文件。</target>
        </trans-unit>
        <trans-unit id="a29b3865557e1b6dfb498bcdde9cd5a7a83c05b9" translate="yes" xml:space="preserve">
          <source>Since this module is most often used only indirectly from extension &lt;code&gt;Makefile.PL&lt;/code&gt; files, here is an example &lt;code&gt;Makefile.PL&lt;/code&gt; entry to add a library to the build process for an extension:</source>
          <target state="translated">由于此模块最常仅从扩展 &lt;code&gt;Makefile.PL&lt;/code&gt; 文件间接使用，因此以下示例 &lt;code&gt;Makefile.PL&lt;/code&gt; 条目将库添加到扩展的构建过程中：</target>
        </trans-unit>
        <trans-unit id="01f476f0532c2e2f8ff2160a3485f37336e92c5d" translate="yes" xml:space="preserve">
          <source>Since this module refers to perl core's Unicode database in the directory</source>
          <target state="translated">因为这个模块引用了perl core的Unicode数据库,在目录中的</target>
        </trans-unit>
        <trans-unit id="e87fdde57834ef3e5b68a023cf000c8017fe6842" translate="yes" xml:space="preserve">
          <source>Since this procedure may take quite a long time to complete, it makes sense to &quot;freeze&quot; your CPAN configuration by disabling periodic updates of the local copy of CPAN index: set &lt;code&gt;index_expire&lt;/code&gt; to some big value (I use 365), then save the settings</source>
          <target state="translated">由于此过程可能需要很长时间才能完成，因此通过禁用CPAN索引的本地副本的定期更新来&amp;ldquo;冻结&amp;rdquo;您的CPAN配置是有意义的：将 &lt;code&gt;index_expire&lt;/code&gt; 设置为某个大值（我使用365），然后保存设置</target>
        </trans-unit>
        <trans-unit id="db30ab250873c1062c4781e4e7b7fad867ddcab0" translate="yes" xml:space="preserve">
          <source>Since this will lead to issues as described above.</source>
          <target state="translated">由于这将导致上述问题。</target>
        </trans-unit>
        <trans-unit id="5b8353c61df27001cdfae1689cea0393e824247d" translate="yes" xml:space="preserve">
          <source>Since threads are also subroutines, they can return values. To wait for a thread to exit and extract any values it might return, you can use the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; method:</source>
          <target state="translated">由于线程也是子例程，因此它们可以返回值。要等待线程退出并提取其可能返回的任何值，可以使用 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="9bad1409df4464c147cc94bb57065c1ad067150c" translate="yes" xml:space="preserve">
          <source>Since threads are also subroutines, they can return values. To wait for a thread to exit and extract any values it might return, you can use the &lt;code&gt;join()&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865359543cead83315159b60389211a49302275e" translate="yes" xml:space="preserve">
          <source>Since to call certain OS/2 API one needs to have a correctly initialized &lt;code&gt;Win&lt;/code&gt; subsystem, OS/2-specific extensions may require getting &lt;code&gt;HAB&lt;/code&gt; s and &lt;code&gt;HMQ&lt;/code&gt; s. If an extension would do it on its own, another extension could fail to initialize.</source>
          <target state="translated">由于要调用某些OS / 2 API，需要具有正确初始化的 &lt;code&gt;Win&lt;/code&gt; 子系统，因此，特定于OS / 2的扩展可能需要获取 &lt;code&gt;HAB&lt;/code&gt; 和 &lt;code&gt;HMQ&lt;/code&gt; 。如果扩展将自己执行，则另一个扩展可能无法初始化。</target>
        </trans-unit>
        <trans-unit id="a707076963b2deddc0e47770d659e4e4346ffd5b" translate="yes" xml:space="preserve">
          <source>Since to call certain OS/2 API one needs to have a correctly initialized &lt;code&gt;Win&lt;/code&gt; subsystem, OS/2-specific extensions may require getting &lt;code&gt;HAB&lt;/code&gt;s and &lt;code&gt;HMQ&lt;/code&gt;s. If an extension would do it on its own, another extension could fail to initialize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac123183aa461484cfbda02f53a1d46605cce417" translate="yes" xml:space="preserve">
          <source>Since v1.24 the &lt;b&gt;Pod::Checker&lt;/b&gt; module uses only the &lt;b&gt;poderror&lt;/b&gt; method to print errors and warnings. The summary output (e.g. &quot;Pod syntax OK&quot;) has been dropped from the module and has been included in &lt;b&gt;podchecker&lt;/b&gt; (the script). This allows users of &lt;b&gt;Pod::Checker&lt;/b&gt; to control completely the output behavior. Users of &lt;b&gt;podchecker&lt;/b&gt; (the script) get the well-known behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c16cb5be350777f69ddd741df453e37c786546" translate="yes" xml:space="preserve">
          <source>Since v5.6.0, Perl's CORE::glob() is implemented in terms of bsd_glob(). Note that they don't share the same prototype--CORE::glob() only accepts a single argument. Due to historical reasons, CORE::glob() will also split its argument on whitespace, treating it as multiple patterns, whereas bsd_glob() considers them as one pattern. But see &lt;code&gt;:bsd_glob&lt;/code&gt; under &lt;a href=&quot;#EXPORTS&quot;&gt;&quot;EXPORTS&quot;&lt;/a&gt;, below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993c2506a3b501e251a227378341211573ee7139" translate="yes" xml:space="preserve">
          <source>Since v5.6.0, Perl's CORE::glob() is implemented in terms of bsd_glob(). Note that they don't share the same prototype--CORE::glob() only accepts a single argument. Due to historical reasons, CORE::glob() will also split its argument on whitespace, treating it as multiple patterns, whereas bsd_glob() considers them as one pattern. But see &lt;code&gt;:bsd_glob&lt;/code&gt; under &lt;a href=&quot;#EXPORTS&quot;&gt;EXPORTS&lt;/a&gt;, below.</source>
          <target state="translated">从v5.6.0开始，Perl的CORE :: glob（）是根据bsd_glob（）实现的。请注意，它们不共享相同的原型-CORE :: glob（）仅接受单个参数。由于历史原因，CORE :: glob（）还将在空白上拆分其参数，将其视为多种模式，而bsd_glob（）则将其视为一种模式。但是请参见下面&lt;a href=&quot;#EXPORTS&quot;&gt;EXPORTS&lt;/a&gt;下的 &lt;code&gt;:bsd_glob&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ad68534057bbff035849577fdc9d02265e92498" translate="yes" xml:space="preserve">
          <source>Since valgrind adds significant overhead, tests will take much longer to run. The valgrind tests support being run in parallel to help with this:</source>
          <target state="translated">由于 valgrind 增加了大量的开销,测试将需要更长的时间来运行。valgrind测试支持并行运行以帮助解决这个问题。</target>
        </trans-unit>
        <trans-unit id="cddab41a34bae01a0c375cc55e93affd1f3991b2" translate="yes" xml:space="preserve">
          <source>Since version 1.26.</source>
          <target state="translated">自1.26版本以来。</target>
        </trans-unit>
        <trans-unit id="6b04b338e1bf6330ffba84da282f69c260eb86f1" translate="yes" xml:space="preserve">
          <source>Since version 1.29.</source>
          <target state="translated">自1.29版本以来。</target>
        </trans-unit>
        <trans-unit id="90fa8ea868e9b39ffa1222c302c6573df472b992" translate="yes" xml:space="preserve">
          <source>Since version 1.30.</source>
          <target state="translated">自1.30版本以来。</target>
        </trans-unit>
        <trans-unit id="b46b7661e42d1c9773df584f5695782bec0ddb2f" translate="yes" xml:space="preserve">
          <source>Since version 1.33.</source>
          <target state="translated">自1.33版本以来。</target>
        </trans-unit>
        <trans-unit id="4b40436a29419119d4b78bb2f402e947b823a0e2" translate="yes" xml:space="preserve">
          <source>Since version 1.35.</source>
          <target state="translated">自1.35版本以来。</target>
        </trans-unit>
        <trans-unit id="3a2c4273e02619f5ed86c67adac94047a5ca0b70" translate="yes" xml:space="preserve">
          <source>Since version 1.36.</source>
          <target state="translated">自1.36版本以来。</target>
        </trans-unit>
        <trans-unit id="828428c704d4b18c115ba845d9cbbc499bb7c74e" translate="yes" xml:space="preserve">
          <source>Since version 1.40.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623e941c243fc86dd1af6f5b5214ee2ab1b54b93" translate="yes" xml:space="preserve">
          <source>Since version 1.42.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0995e25b2df10d5239bf46e745e3af66bfa38ff9" translate="yes" xml:space="preserve">
          <source>Since version 1.44.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85fc2cbdcb50a3cca10d3657cdf7b3d3b631c2f4" translate="yes" xml:space="preserve">
          <source>Since version 1.45.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20faedc97370e5707a72fd235e65122603a7fcc7" translate="yes" xml:space="preserve">
          <source>Since version 1.50.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a1a8817578d6cd5474a6b1a0cb684b5b5d0681" translate="yes" xml:space="preserve">
          <source>Since version 1.54.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ea051224d185be13b4a3d24b650c0164b10687" translate="yes" xml:space="preserve">
          <source>Since version 1.55.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aefe381ec383217e51c9e6b76ef75c74617d1b90" translate="yes" xml:space="preserve">
          <source>Since version 2.22 (part of Encode 2.83), the MIME encoder should be fully compliant to &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2231&quot;&gt;RFC 2231&lt;/a&gt;. Due to the aforementioned bugs in previous versions of the MIME encoder, there is a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991cb9597f8a402ad66b55672ad9333f3ec6c358" translate="yes" xml:space="preserve">
          <source>Since version 2.91_01, JSON::PP uses a different number detection logic that converts a scalar that is possible to turn into a number safely. The new logic is slightly faster, and tends to help people who use older perl or who want to encode complicated data structure. However, this may results in a different JSON text from the one JSON::XS encodes (and thus may break tests that compare entire JSON texts). If you do need the previous behavior for compatibility or for finer control, set PERL_JSON_PP_USE_B environmental variable to true before you &lt;code&gt;use&lt;/code&gt; JSON::PP (or JSON.pm).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2498504f50455260e9635ae498353ef8c9decaca" translate="yes" xml:space="preserve">
          <source>Since version 5.8 Perl uses the PerlIO I/O library. This enables you to use different encodings per IO channel. For example you may use</source>
          <target state="translated">从5.8版本开始,Perl使用PerlIO I/O库。这使得你可以对每个IO通道使用不同的编码。例如,你可以使用</target>
        </trans-unit>
        <trans-unit id="656ca296455da01a08e031bd90f196ae0bd4a55c" translate="yes" xml:space="preserve">
          <source>Since version 5.8 Perl uses the new PerlIO on BS2000. This enables you using different encodings per IO channel. For example you may use</source>
          <target state="translated">从5.8版本开始,Perl在BS2000上使用新的PerlIO。这使得你可以在每个IO通道上使用不同的编码。例如,您可以使用</target>
        </trans-unit>
        <trans-unit id="5792847b18d8585cbe32d073b79aab824b6fbb3d" translate="yes" xml:space="preserve">
          <source>Since version 5.8.0, hashes can be</source>
          <target state="translated">从5.8.0版本开始,哈希值可以是</target>
        </trans-unit>
        <trans-unit id="a80731504bb0fcf1278621181ce230d90a8fe55c" translate="yes" xml:space="preserve">
          <source>Since version &lt;code&gt;1.39&lt;/code&gt; these &lt;code&gt;ARRAY&lt;/code&gt; references are blessed objects, recognising the two methods &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;. The following code is equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3045986b0102a2064e1410bb295874d9fe22b31d" translate="yes" xml:space="preserve">
          <source>Since version &lt;code&gt;1.39&lt;/code&gt; these ARRAY references are blessed objects, recognising the two methods &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; . The following code is equivalent:</source>
          <target state="translated">从版本 &lt;code&gt;1.39&lt;/code&gt; 开始,这些ARRAY引用是受祝福的对象，可以识别 &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 这两种方法。以下代码是等效的：</target>
        </trans-unit>
        <trans-unit id="d22b88a2ec6cf389267a717ce7fbb228afb24d03" translate="yes" xml:space="preserve">
          <source>Since version &lt;code&gt;1.51&lt;/code&gt; they also have a &lt;code&gt;TO_JSON&lt;/code&gt; method to ease serialisation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da1ba2b2bc63ba7f5a165684b362132feb79be8" translate="yes" xml:space="preserve">
          <source>Since version v1.33, Math::BigInt and Math::BigFloat have full support for accuracy and precision based rounding, both automatically after every operation, as well as manually.</source>
          <target state="translated">从v1.33版本开始,Math::BigInt和Math::BigFloat完全支持基于精度和精密度的四舍五入,既可以在每次操作后自动进行,也可以手动进行。</target>
        </trans-unit>
        <trans-unit id="75e1e7b33ae8faf22bfba9121d2d99d1efb7768e" translate="yes" xml:space="preserve">
          <source>Since we didn't define a &lt;code&gt;save()&lt;/code&gt; method in the &lt;code&gt;File::MP3&lt;/code&gt; class, Perl will look at the &lt;code&gt;File::MP3&lt;/code&gt; class's parent classes to find the &lt;code&gt;save()&lt;/code&gt; method. If Perl cannot find a &lt;code&gt;save()&lt;/code&gt; method anywhere in the inheritance hierarchy, it will die.</source>
          <target state="translated">由于我们没有在 &lt;code&gt;File::MP3&lt;/code&gt; 类中定义 &lt;code&gt;save()&lt;/code&gt; 方法，因此Perl将查看 &lt;code&gt;File::MP3&lt;/code&gt; 类的父类以找到 &lt;code&gt;save()&lt;/code&gt; 方法。如果Perl 在继承层次结构中的任何地方都找不到 &lt;code&gt;save()&lt;/code&gt; 方法，它将死亡。</target>
        </trans-unit>
        <trans-unit id="3e236441f92cccda5b2d49a5d2e52d11313518e5" translate="yes" xml:space="preserve">
          <source>Since we don't have an NV for &lt;code&gt;$b&lt;/code&gt; , we'll have to use &lt;code&gt;sv_2nv&lt;/code&gt; to convert it. If we step again, we'll find ourselves there:</source>
          <target state="translated">由于我们没有 &lt;code&gt;$b&lt;/code&gt; 的NV ，因此必须使用 &lt;code&gt;sv_2nv&lt;/code&gt; 进行转换。如果我们再次走下去，我们会发现自己在那里：</target>
        </trans-unit>
        <trans-unit id="43d65fe03aac7da5dd4ef49b28b5012afba90c77" translate="yes" xml:space="preserve">
          <source>Since we don't have an NV for &lt;code&gt;$b&lt;/code&gt;, we'll have to use &lt;code&gt;sv_2nv&lt;/code&gt; to convert it. If we step again, we'll find ourselves there:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3708f0927e1925f92bdee0634ab63e7742c6b549" translate="yes" xml:space="preserve">
          <source>Since we don't know if &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; works, or even subroutines, use ad hoc tests for these three. Step carefully to avoid using the feature being tested. Tests in</source>
          <target state="translated">由于我们不知道是否 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 工作，甚至子例程，因此请对这三个应用临时测试。小心执行以避免使用要测试的功能。测试中</target>
        </trans-unit>
        <trans-unit id="959f38fbc36ca9c82998d3e370dda38e5dddb0bf" translate="yes" xml:space="preserve">
          <source>Since we don't know if &lt;code&gt;require&lt;/code&gt; works, or even subroutines, use ad hoc tests for these three. Step carefully to avoid using the feature being tested. Tests in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f9ededf0cd07d09b1ffd3609acb21770a40353" translate="yes" xml:space="preserve">
          <source>Since we feed a list of ten 2-digit hexadecimal strings to &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, the pack template should contain ten pack codes. If this is run on a computer with ASCII character coding, it will print &lt;code&gt;0123456789&lt;/code&gt; .</source>
          <target state="translated">由于我们要输入要 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 的十个2位十六进制字符串的列表，所以打包模板应包含十个打包代码。如果这是在使用ASCII字符编码的计算机上运行的，它将打印 &lt;code&gt;0123456789&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3e96dcf9d6747abca3c34da42f376ec3097c3d9" translate="yes" xml:space="preserve">
          <source>Since we feed a list of ten 2-digit hexadecimal strings to &lt;code&gt;pack&lt;/code&gt;, the pack template should contain ten pack codes. If this is run on a computer with ASCII character coding, it will print &lt;code&gt;0123456789&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a3bb738728020d7b3d2bd56167deba0672548c" translate="yes" xml:space="preserve">
          <source>Since we said earlier:</source>
          <target state="translated">既然我们前面说了。</target>
        </trans-unit>
        <trans-unit id="78829eafb6296e19175ed55a3097f673b5dc1d5f" translate="yes" xml:space="preserve">
          <source>Since you can assign to a list of variables, you can also assign to an array or hash slice.</source>
          <target state="translated">既然可以赋值给变量列表,也可以赋值给数组或哈希片。</target>
        </trans-unit>
        <trans-unit id="35b796faff1e6866bc3d8ff9ecdff8f636cea4f9" translate="yes" xml:space="preserve">
          <source>Since you only run one test per program &lt;code&gt;new&lt;/code&gt; always returns the same Test::Builder object. No matter how many times you call &lt;code&gt;new()&lt;/code&gt; , you're getting the same object. This is called a singleton. This is done so that multiple modules share such global information as the test counter and where test output is going.</source>
          <target state="translated">由于每个程序只运行一个测试，因此 &lt;code&gt;new&lt;/code&gt; 总是返回相同的Test :: Builder对象。无论您调用 &lt;code&gt;new()&lt;/code&gt; 多少次，都将获得相同的对象。这称为单例。这样做是为了使多个模块共享全局信息，例如测试计数器和测试输出的去向。</target>
        </trans-unit>
        <trans-unit id="d6632404c7510ee37ef12fec086b1b9886c3c039" translate="yes" xml:space="preserve">
          <source>Since you only run one test per program &lt;code&gt;new&lt;/code&gt; always returns the same Test::Builder object. No matter how many times you call &lt;code&gt;new()&lt;/code&gt;, you're getting the same object. This is called a singleton. This is done so that multiple modules share such global information as the test counter and where test output is going.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df43da3b7bd5966cc2c20737e50dc599284dd8e" translate="yes" xml:space="preserve">
          <source>Since you want to be a good programmer, you probably want to use a lexical filehandle, even though formats are designed to work with bareword filehandles since the default format names take the filehandle name. However, you can control this with some Perl special per-filehandle variables: &lt;code&gt;$^&lt;/code&gt; , which names the top-of-page format, and &lt;code&gt;$~&lt;/code&gt; which shows the line format. You have to change the default filehandle to set these variables:</source>
          <target state="translated">由于您想成为一名优秀的程序员，因此即使格式被设计为与裸字文件句柄一起使用，也可能要使用词汇文件句柄，因为默认格式名采用文件句柄名称。但是，您可以使用一些Perl特殊的每文件句柄变量来控制此操作： &lt;code&gt;$^&lt;/code&gt; 命名页面顶部格式，而 &lt;code&gt;$~&lt;/code&gt; 表示行格式。您必须更改默认文件句柄才能设置以下变量：</target>
        </trans-unit>
        <trans-unit id="8a72acc5d7f8358918f3a719037cabf59df13c37" translate="yes" xml:space="preserve">
          <source>Since you want to be a good programmer, you probably want to use a lexical filehandle, even though formats are designed to work with bareword filehandles since the default format names take the filehandle name. However, you can control this with some Perl special per-filehandle variables: &lt;code&gt;$^&lt;/code&gt;, which names the top-of-page format, and &lt;code&gt;$~&lt;/code&gt; which shows the line format. You have to change the default filehandle to set these variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ee6b56ac231ef340b4b0ce7a9b1c774baa56bb" translate="yes" xml:space="preserve">
          <source>Since you're assigning to a scalar, the righthand side is in scalar context. The comma operator (yes, it's an operator!) in scalar context evaluates its lefthand side, throws away the result, and evaluates it's righthand side and returns the result. In effect, that list-lookalike assigns to &lt;code&gt;$scalar&lt;/code&gt; it's rightmost value. Many people mess this up because they choose a list-lookalike whose last element is also the count they expect:</source>
          <target state="translated">由于您要分配给标量，因此右侧位于标量上下文中。标量上下文中的逗号运算符（是的，它是运算符！）会评估其左侧，丢弃结果，并评估其右侧并返回结果。实际上，该类似列表将 &lt;code&gt;$scalar&lt;/code&gt; 赋给它最右边的值。许多人把它弄乱了，因为他们选择了一个看起来相似的列表，其最后一个元素也是他们期望的计数：</target>
        </trans-unit>
        <trans-unit id="b1e4d1f3b6584286a7b1e87475e6b68a4163f836" translate="yes" xml:space="preserve">
          <source>Since you're using ssh, you'll have to pass some extra arguments to Configure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e2d6a9962eddfc9f09d9986a8e8b8277588e75" translate="yes" xml:space="preserve">
          <source>Since, as mentioned above, bitwise operators may take extra arguments, you may want to use something like &lt;code&gt;(lobj, robj, swap, ...)&lt;/code&gt; (with literal &lt;code&gt;...&lt;/code&gt;) as your parameter list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c0b7bdab70ca2cc9c844a0d74a3af0bbf41c3e" translate="yes" xml:space="preserve">
          <source>Singapore</source>
          <target state="translated">Singapore</target>
        </trans-unit>
        <trans-unit id="b227b1e063b8171583fca32f48c11de71e845c84" translate="yes" xml:space="preserve">
          <source>Single 8-bit characters.</source>
          <target state="translated">单个8位字符。</target>
        </trans-unit>
        <trans-unit id="62539aaf022cade9262a4b6494d3943b6956e5a8" translate="yes" xml:space="preserve">
          <source>Single Byte Encodings</source>
          <target state="translated">单字节编码</target>
        </trans-unit>
        <trans-unit id="4530f93a4bcf9d5873d117244d6fb7434ad7291d" translate="yes" xml:space="preserve">
          <source>Single Quotes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012b49ff1827b6d4c0bd35ca2f9e9f57f854cb53" translate="yes" xml:space="preserve">
          <source>Single form (&lt;code&gt;\p{name}&lt;/code&gt;) tighter rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8a4e28358318025ab4a8b973931c58f9de9358" translate="yes" xml:space="preserve">
          <source>Single quotes indicate the text is to be treated literally with no interpolation of its content. This is similar to single quoted strings except that backslashes have no special meaning, with &lt;code&gt;\\&lt;/code&gt; being treated as two backslashes and not one as they would in every other quoting construct.</source>
          <target state="translated">单引号表示该文本将按字面意义进行处理，而不会插入其内容。这与单引号字符串相似，不同之处在于反斜杠没有特殊含义，其中 &lt;code&gt;\\&lt;/code&gt; 被视为两个反斜杠，而不是它们在其他所有引号构造中的反斜杠。</target>
        </trans-unit>
        <trans-unit id="2988b7ce72e4ef43941b210b5d2de77bb3a0210b" translate="yes" xml:space="preserve">
          <source>Single space after keywords that are followed by parens, no space between function name and following paren</source>
          <target state="translated">在关键字后的单空格,函数名和后面的父母之间没有空格。</target>
        </trans-unit>
        <trans-unit id="998773a99793919677d4844303decc2eb2f960f3" translate="yes" xml:space="preserve">
          <source>Single step. Executes until the beginning of another statement, descending into subroutine calls. If an expression is supplied that includes function calls, it too will be single-stepped.</source>
          <target state="translated">单步。执行到另一条语句的开始,降为子程序调用。如果提供的表达式包含函数调用,它也将是单步的。</target>
        </trans-unit>
        <trans-unit id="b39e88e61083334da27e22ac3304f5322910c7a2" translate="yes" xml:space="preserve">
          <source>Single-letter properties match all characters in any of the two-letter sub-properties starting with the same letter. &lt;code&gt;LC&lt;/code&gt; and &lt;code&gt;L&amp;amp;&lt;/code&gt; are special: both are aliases for the set consisting of everything matched by &lt;code&gt;Ll&lt;/code&gt; , &lt;code&gt;Lu&lt;/code&gt; , and &lt;code&gt;Lt&lt;/code&gt; .</source>
          <target state="translated">单字母属性匹配以相同字母开头的任何两个字母子属性中的所有字符。 &lt;code&gt;LC&lt;/code&gt; 和 &lt;code&gt;L&amp;amp;&lt;/code&gt; 是特殊的：两者都是由 &lt;code&gt;Ll&lt;/code&gt; ， &lt;code&gt;Lu&lt;/code&gt; 和 &lt;code&gt;Lt&lt;/code&gt; 匹配的所有内容组成的集合的别名。</target>
        </trans-unit>
        <trans-unit id="d8acda7f90b42defaf44562897d2b28bbd83f4e8" translate="yes" xml:space="preserve">
          <source>Single-letter properties match all characters in any of the two-letter sub-properties starting with the same letter. &lt;code&gt;LC&lt;/code&gt; and &lt;code&gt;L&amp;amp;&lt;/code&gt; are special: both are aliases for the set consisting of everything matched by &lt;code&gt;Ll&lt;/code&gt;, &lt;code&gt;Lu&lt;/code&gt;, and &lt;code&gt;Lt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47784ae534e76f07f938e74b6b49c2e04c524d60" translate="yes" xml:space="preserve">
          <source>Single-step flag. Will be true if the API will stop at the next statement.</source>
          <target state="translated">单步标志。如果API将在下一条语句中停止,则为真。</target>
        </trans-unit>
        <trans-unit id="3fd72cbf421902beaf4893343701c7e9f292181e" translate="yes" xml:space="preserve">
          <source>Sinograms like &amp;ldquo;東京&amp;rdquo; come back with character names of &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; and &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt; , because their &amp;ldquo;names&amp;rdquo; vary. The CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; module has a large database for decoding these (and a whole lot more), provided you know how to understand its output.</source>
          <target state="translated">诸如&amp;ldquo;东京&amp;rdquo;之类的汉字会以 &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; 和 &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt; 的字符名称返回，因为它们的&amp;ldquo;名称&amp;rdquo;有所不同。CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; 模块具有一个大型数据库，可以解码这些（以及更多），只要您知道如何理解其输出即可。</target>
        </trans-unit>
        <trans-unit id="b9df3910d077951b174aefd94b54e0bc3ac87d77" translate="yes" xml:space="preserve">
          <source>Sinograms like &amp;ldquo;東京&amp;rdquo; come back with character names of &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; and &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt;, because their &amp;ldquo;names&amp;rdquo; vary. The CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; module has a large database for decoding these (and a whole lot more), provided you know how to understand its output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e8fd907b0e11131190209772e747eaed820c59" translate="yes" xml:space="preserve">
          <source>Site-specific perl extensions and modules can be installed in one of two places. Put architecture-independent files into:</source>
          <target state="translated">特定站点的perl扩展和模块可以安装在两个地方之一。把与架构无关的文件放入。</target>
        </trans-unit>
        <trans-unit id="00832815e260edfba2e83c2f4b5a6a35db1c2d1c" translate="yes" xml:space="preserve">
          <source>Six such conversions are possible:</source>
          <target state="translated">这样的转换有六种可能。</target>
        </trans-unit>
        <trans-unit id="ab71370c759f98b4c2c5f12f621583aa7cb9faf2" translate="yes" xml:space="preserve">
          <source>Sixth:</source>
          <target state="translated">Sixth:</target>
        </trans-unit>
        <trans-unit id="43701334f4b3da3fdeb3363278217ac0f215873d" translate="yes" xml:space="preserve">
          <source>Size of the function table. This is compared against the value PerlIO code &quot;knows&quot; as a compatibility check. Future versions</source>
          <target state="translated">函数表的大小。这将与PerlIO代码 &quot;知道 &quot;的值进行比较,作为一种兼容性检查。未来版本</target>
        </trans-unit>
        <trans-unit id="936d52e1c615ea7024397f6ff1aeb7c89ebd5bad" translate="yes" xml:space="preserve">
          <source>Size, Endianness, and BOM</source>
          <target state="translated">规模、内涵和BOM</target>
        </trans-unit>
        <trans-unit id="0ec62bfb6670c34f50ed4190d4e6017dc34d76d5" translate="yes" xml:space="preserve">
          <source>Skip a package when throwing autodie exceptions</source>
          <target state="translated">抛出自动处理异常时跳过一个包。</target>
        </trans-unit>
        <trans-unit id="73e856b6ebf6aeb3a630b124c6e02c2a78566450" translate="yes" xml:space="preserve">
          <source>Skip all tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c526a5770e20da3a4179e52c1b052314f790b3" translate="yes" xml:space="preserve">
          <source>Skip event type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ffbfd6b2e06775aaf14afc6238b4599cf532c4" translate="yes" xml:space="preserve">
          <source>Skip events bump test counts just like &lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2::Event::Ok&lt;/a&gt; events, but they can never fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57a18bbc33fb3b107b0f37ec04073b6f8f1aa7be" translate="yes" xml:space="preserve">
          <source>Skip sub-char mapping should there be no code point.</source>
          <target state="translated">如果没有代码点,则跳过子字符映射。</target>
        </trans-unit>
        <trans-unit id="fa22bcdeb4f395bdc09dc2fd5b11b93a885994fb" translate="yes" xml:space="preserve">
          <source>Skip the real Pod formatting, and just show the raw Pod source (&lt;b&gt;U&lt;/b&gt;nformatted)</source>
          <target state="translated">跳过真正的波德格式，并且只显示原始波德源（&lt;b&gt;&amp;uuml;&lt;/b&gt; nformatted）</target>
        </trans-unit>
        <trans-unit id="e6cd533514432f62bafda9ad5f9825a972ff6179" translate="yes" xml:space="preserve">
          <source>Skip this section if the XSUB functions are supposed to be called from other modules only; read it only if you call your XSUBs from the code in your module, or have a &lt;code&gt;BOOT:&lt;/code&gt; section in your XS file (see &lt;a href=&quot;perlxs#The-BOOT%3A-Keyword&quot;&gt;&quot;The BOOT: Keyword&quot; in perlxs&lt;/a&gt;). What is described here is equally applicable to the &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e59adfb26a9113df0d5c476d39a18d0087952f5" translate="yes" xml:space="preserve">
          <source>Skip this section if the XSUB functions are supposed to be called from other modules only; read it only if you call your XSUBs from the code in your module, or have a &lt;code&gt;BOOT:&lt;/code&gt; section in your XS file (see &lt;a href=&quot;perlxs#The-BOOT%3a-Keyword&quot;&gt;The BOOT: Keyword in perlxs&lt;/a&gt;). What is described here is equally applicable to the &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; interface.</source>
          <target state="translated">如果仅应从其他模块调用XSUB函数，请跳过本节；仅当您从模块中的代码调用XSUB或在XS文件中包含 &lt;code&gt;BOOT:&lt;/code&gt; 部分时，才阅读它（请参阅&lt;a href=&quot;perlxs#The-BOOT%3a-Keyword&quot;&gt;perlxs中的BOOT：关键字&lt;/a&gt;）。这里描述的内容同样适用于&lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="a516a3ce4b9fd1e3a2a9186564fe4ca0d9da8218" translate="yes" xml:space="preserve">
          <source>Skipping tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ab6781ff6514e41583039acc42db3e0f3c9201" translate="yes" xml:space="preserve">
          <source>Skips all the tests, using the given &lt;code&gt;$reason&lt;/code&gt; . Exits immediately with 0.</source>
          <target state="translated">使用给定的 &lt;code&gt;$reason&lt;/code&gt; 跳过所有测试。立即以0退出。</target>
        </trans-unit>
        <trans-unit id="9d406363c0222ce5a6c71553ed555dc077dda244" translate="yes" xml:space="preserve">
          <source>Skips all the tests, using the given &lt;code&gt;$reason&lt;/code&gt;. Exits immediately with 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563adc0d862d00d2bcc7549833d1039985aead2a" translate="yes" xml:space="preserve">
          <source>Skips the current test, reporting &lt;code&gt;$why&lt;/code&gt; .</source>
          <target state="translated">跳过当前测试，报告 &lt;code&gt;$why&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c9a19a668210cd54ae808f068a27dac1e967c53" translate="yes" xml:space="preserve">
          <source>Skips the current test, reporting &lt;code&gt;$why&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1ac1071abc2c48fe8c683c23437c17bcd0e5ba" translate="yes" xml:space="preserve">
          <source>Skips to the next compressed data stream in the input file/buffer. If a new compressed data stream is found, the eof marker will be cleared and &lt;code&gt;$.&lt;/code&gt; will be reset to 0.</source>
          <target state="translated">跳至输入文件/缓冲区中的下一个压缩数据流。如果找到新的压缩数据流，则将清除eof标记和 &lt;code&gt;$.&lt;/code&gt; 将重置为0。</target>
        </trans-unit>
        <trans-unit id="4249f92b08fd3ea49d1d4587b0dc45efe6514ff5" translate="yes" xml:space="preserve">
          <source>SkyMarshal &amp;lt;skymarshal1729@gmail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1af20e2176a0b7a938bf7cbbbf01e3f656d901" translate="yes" xml:space="preserve">
          <source>Skye Shaw &amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41574ecb0de77a7fed0beca1f4434e4a44173169" translate="yes" xml:space="preserve">
          <source>Slab leaked from cv %p</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d051f41b7de19e7acc50c00d91bed9bc77c2a243" translate="yes" xml:space="preserve">
          <source>Slab-based operator allocation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28422baab3fe565caf66be5cefa3539fc1817282" translate="yes" xml:space="preserve">
          <source>Slab_Alloc</source>
          <target state="translated">Slab_Alloc</target>
        </trans-unit>
        <trans-unit id="dfee07ce355211f20f3bdab2cb3fa2a9def9c336" translate="yes" xml:space="preserve">
          <source>Slab_Free</source>
          <target state="translated">Slab_Free</target>
        </trans-unit>
        <trans-unit id="8b86eb2caadb21d205d9d0ad56cf031153fb8e27" translate="yes" xml:space="preserve">
          <source>Slab_to_ro</source>
          <target state="translated">Slab_to_ro</target>
        </trans-unit>
        <trans-unit id="b4128d18330a7f45f087418a9b524193204735bc" translate="yes" xml:space="preserve">
          <source>Slab_to_rw</source>
          <target state="translated">Slab_to_rw</target>
        </trans-unit>
        <trans-unit id="147d6799969166c3bb4c81176bc4c31ac64ac6bd" translate="yes" xml:space="preserve">
          <source>Slaven Rezic &amp;lt;slaven.rezic@idealo.de&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ac691e6a9650a28847ff59e7d257f5f29d2f4fa" translate="yes" xml:space="preserve">
          <source>Slaven Rezic &amp;lt;slaven@rezic.de&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e59d0602eb0550fd0dbf5d82907d6271ae4af6ea" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of microseconds (millionths of a second) specified. Returns the number of microseconds actually slept. Can sleep for more than one second, unlike the &lt;code&gt;usleep&lt;/code&gt; system call. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">休眠指定的微秒数（百万分之一秒）。返回实际睡眠的微秒数。与 &lt;code&gt;usleep&lt;/code&gt; 系统调用不同，它可以睡眠一秒钟以上。也可以睡零秒，这通常就像</target>
        </trans-unit>
        <trans-unit id="a7c111ccc19a7463efac9caa48bfd176015106c5" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of nanoseconds (1e9ths of a second) specified. Returns the number of nanoseconds actually slept (accurate only to microseconds, the nearest thousand of them). Can sleep for more than one second. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">睡眠时间为指定的纳秒数(1e9th of a second)。返回实际睡眠的纳秒数(只精确到微秒,最接近的千分之一)。可以休眠一秒以上。也可以休眠零秒,它的工作原理往往像一个</target>
        </trans-unit>
        <trans-unit id="858360f4742bec3dbad2b4b1586f95ca8cfce48d" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of nanoseconds (1e9ths of a second) specified. Returns the number of nanoseconds actually slept. The $which is the &quot;clock id&quot;, as with clock_gettime() and clock_getres(). The flags default to zero but &lt;code&gt;TIMER_ABSTIME&lt;/code&gt; can specified (must be exported explicitly) which means that &lt;code&gt;$nanoseconds&lt;/code&gt; is not a time interval (as is the default) but instead an absolute time. Can sleep for more than one second. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">休眠指定的纳秒数（1e9秒）。返回实际睡眠的纳秒数。$其中是&amp;ldquo; clock id&amp;rdquo;，与clock_gettime（）和clock_getres（）一样。这些标志默认为零，但是可以指定 &lt;code&gt;TIMER_ABSTIME&lt;/code&gt; （必须显式导出），这意味着 &lt;code&gt;$nanoseconds&lt;/code&gt; nanoseconds不是时间间隔（默认值），而是绝对时间。可以睡一秒钟以上。也可以睡零秒，这通常就像</target>
        </trans-unit>
        <trans-unit id="bfc9358c36664745e87042ffeea926ba49acc8f0" translate="yes" xml:space="preserve">
          <source>Sleeps for the specified amount of seconds. Returns the number of seconds actually slept (a floating point value). This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; below.</source>
          <target state="translated">休眠指定的秒数。返回实际睡眠的秒数（浮点值）。可以导入此功能，从而可以很好地替代perl附带的 &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; ，请参见下面的&lt;a href=&quot;#EXAMPLES&quot;&gt;示例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18ae77017c85766e5d3a71c2d083fdfba9357fdb" translate="yes" xml:space="preserve">
          <source>Sleeps for the specified amount of seconds. Returns the number of seconds actually slept (a floating point value). This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;sleep&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a455933ba1827ec6d2d6cea6cb61c05bd3954351" translate="yes" xml:space="preserve">
          <source>Slices</source>
          <target state="translated">Slices</target>
        </trans-unit>
        <trans-unit id="de97696f04df2d455746fc0459c7a0334ac08b94" translate="yes" xml:space="preserve">
          <source>Slices in scalar context return the last item of the slice.</source>
          <target state="translated">标量上下文中的片子返回片子的最后一项。</target>
        </trans-unit>
        <trans-unit id="fade4867f2281855741bb2fdfae6ec6bfe669774" translate="yes" xml:space="preserve">
          <source>Slicing operations and parentheses cause the right-hand side to be evaluated in list context:</source>
          <target state="translated">分片操作和括号会导致右侧在列表上下文中被评估。</target>
        </trans-unit>
        <trans-unit id="dcf621083da44b050ec0828499127db4dc13006b" translate="yes" xml:space="preserve">
          <source>SlickEdit</source>
          <target state="translated">SlickEdit</target>
        </trans-unit>
        <trans-unit id="71625e10c96350176b8faecaf24d1d897cf6efce" translate="yes" xml:space="preserve">
          <source>Slightly modified by Arthur Bergman to fit the new thread model/module.</source>
          <target state="translated">由Arthur Bergman稍作修改,以适应新的螺纹模型/模块。</target>
        </trans-unit>
        <trans-unit id="b6c149c3e00467fba347629a63ed02fed098d061" translate="yes" xml:space="preserve">
          <source>Slovakia</source>
          <target state="translated">Slovakia</target>
        </trans-unit>
        <trans-unit id="d1aa0503612aa4168939b77b59ca74532a11951a" translate="yes" xml:space="preserve">
          <source>Slovenia</source>
          <target state="translated">Slovenia</target>
        </trans-unit>
        <trans-unit id="945d75b6ccb37accbc9182a048ffec51dcd1a47f" translate="yes" xml:space="preserve">
          <source>Slurpy parameter not last</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c84511f9de85f2a5bea737ad0651170f5fc9c55" translate="yes" xml:space="preserve">
          <source>Smart matching a non-overloaded object breaks encapsulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05c92e1201b3c7a99b14a3196c426c41067b9ce" translate="yes" xml:space="preserve">
          <source>Smartmatch Operator</source>
          <target state="translated">Smartmatch操作员</target>
        </trans-unit>
        <trans-unit id="853b5644d464d7aa87bcee31b98647e7b0076053" translate="yes" xml:space="preserve">
          <source>Smartmatch expects to be able to allocate an op at run time, run it, and then throw it away. For that to work the op is simply malloced when PL_compcv hasn't been set up. So all slab-allocated ops are marked as such (&lt;code&gt;-&amp;gt;op_slabbed&lt;/code&gt;), to distinguish them from malloced ops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226b6fe8f9e2cd4e8ca8e6e55a94a83ba3f2cf5a" translate="yes" xml:space="preserve">
          <source>Smartmatch is experimental</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4adce585ab904a3b57996c9eacd1526a8856e59" translate="yes" xml:space="preserve">
          <source>Smartmatching of Objects</source>
          <target state="translated">对象的智能匹配</target>
        </trans-unit>
        <trans-unit id="fcef3abf224b18a1a9539b5cd1a74a21f40eb21d" translate="yes" xml:space="preserve">
          <source>Smartmatching one hash against another reports whether both contain the same keys, no more and no less. This could be used to see whether two records have the same field names, without caring what values those fields might have. For example:</source>
          <target state="translated">将一个哈希值与另一个哈希值进行智能匹配,报告两者是否包含相同的键,不多不少。这可以用来查看两条记录是否有相同的字段名,而不关心这些字段可能有什么值。比如说</target>
        </trans-unit>
        <trans-unit id="f02489100f7e7550e46dc3c0c8c28f36daa00353" translate="yes" xml:space="preserve">
          <source>Smoke testing Perl 5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c177aabcbd4f359e0aaa8a530199381f4cf98371" translate="yes" xml:space="preserve">
          <source>Snooping</source>
          <target state="translated">Snooping</target>
        </trans-unit>
        <trans-unit id="4460e52ce30ee2f7dab472f65e7bc2c1c88dffad" translate="yes" xml:space="preserve">
          <source>So I got smart: I decided to be lazy and let the C compiler parse the C, which would spit out debugger stabs for me to read. These were much easier to parse. It's still not a pretty program, but at least it's more robust.</source>
          <target state="translated">于是我变聪明了:我决定偷懒,让C编译器解析C语言,它会吐出调试器刺让我阅读。这些解析起来就容易多了。这仍然不是一个漂亮的程序,但至少它更健壮了。</target>
        </trans-unit>
        <trans-unit id="a1f5ce193c65cebf4de4614792ca39a016541f36" translate="yes" xml:space="preserve">
          <source>So a typical call to check would look like this:</source>
          <target state="translated">所以一个典型的调用检查会是这样的。</target>
        </trans-unit>
        <trans-unit id="32bf3b4ebf1dd24fdccf516f7c267bd10f4fed6f" translate="yes" xml:space="preserve">
          <source>So assuming the database created above, we can use &lt;code&gt;get_dup&lt;/code&gt; like this:</source>
          <target state="translated">因此，假设上面创建了数据库，我们可以像这样使用 &lt;code&gt;get_dup&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9531481e3958e36f87e15fe09a502608d674e17a" translate="yes" xml:space="preserve">
          <source>So called because of a similar construct in &lt;b&gt;shells&lt;/b&gt; that pretends that the &lt;b&gt;lines&lt;/b&gt; following the &lt;b&gt;command&lt;/b&gt; are a separate &lt;b&gt;file&lt;/b&gt; to be fed to the command, up to some terminating string. In Perl, however, it&amp;rsquo;s just a fancy form of quoting.</source>
          <target state="translated">所谓的，因为在一个类似的构建体的&lt;b&gt;壳&lt;/b&gt;伪装该&lt;b&gt;线&lt;/b&gt;以下的&lt;b&gt;命令&lt;/b&gt;是一个独立的&lt;b&gt;文件&lt;/b&gt;要被馈送到该命令，直到某个终止字符串。但是，在Perl中，这只是一种奇特的报价形式。</target>
        </trans-unit>
        <trans-unit id="93e9a6ece24ada54b55dc7612c9389e7a638c36b" translate="yes" xml:space="preserve">
          <source>So each subroutine is born with an array of scratchpads (of length 1). On each entry to the subroutine it is checked that the current depth of the recursion is not more than the length of this array, and if it is, new scratchpad is created and pushed into the array.</source>
          <target state="translated">所以每个子程序出生时都有一个scratchpads数组(长度为1)。在每次进入子程序时,都会检查当前递归的深度是否超过这个数组的长度,如果超过,就会创建新的scratchpad并推送到数组中。</target>
        </trans-unit>
        <trans-unit id="c0f1f69e80ab7ebe217f8989a490d4af7ac57aa2" translate="yes" xml:space="preserve">
          <source>So far I've shown you nothing that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd2a2cfe6e08c35c8f0019242b9920756d8258f" translate="yes" xml:space="preserve">
          <source>So far so good. But suppose the way you're implementing this is:</source>
          <target state="translated">到目前为止还不错。但假设你的实施方式是:</target>
        </trans-unit>
        <trans-unit id="99d938c6031e3ad535ec502cea56c5d218d4389a" translate="yes" xml:space="preserve">
          <source>So far so good. Those of you who have been paying attention will have spotted that the tied object hasn't been used so far. So lets add an extra method to the Remember class to allow comments to be included in the file; say, something like this:</source>
          <target state="translated">到目前为止还算不错。那些一直在关注的人将会发现,到目前为止,绑定对象还没有被使用。因此,让我们在 Remember 类中添加一个额外的方法,以允许在文件中包含注释;比如,像这样。</target>
        </trans-unit>
        <trans-unit id="438b9b4e31229df657e054c261ee9d298ca8b103" translate="yes" xml:space="preserve">
          <source>So far we've merely tried to find and list the experimental features and infer their inception, versions, etc. There's a lot of speculation here.</source>
          <target state="translated">到目前为止,我们只是试图找到并列出实验功能,并推断出它们的成立时间、版本等。这里有很多的猜测。</target>
        </trans-unit>
        <trans-unit id="10bc3a4c124b48037408d12298d27779d339f321" translate="yes" xml:space="preserve">
          <source>So far, so good. With the knowledge above you can already perform searches with just about any literal string regexp you can dream up. Here is a</source>
          <target state="translated">到目前为止,还算不错。有了上面的知识,你已经可以用任何你能想到的文字字符串regexp进行搜索了。下面是一个</target>
        </trans-unit>
        <trans-unit id="8af65d96d3224572aaaeff6426ae992e0bd5b192" translate="yes" xml:space="preserve">
          <source>So far, we're using just the normal list return mechanism. What happens if you want to pass or return a hash? Well, if you're using only one of them, or you don't mind them concatenating, then the normal calling convention is ok, although a little expensive.</source>
          <target state="translated">到目前为止,我们使用的只是普通的列表返回机制。如果你想传递或返回一个哈希,会发生什么?好吧,如果你只使用其中一个,或者你不介意它们连在一起,那么正常的调用惯例是可以的,虽然有点贵。</target>
        </trans-unit>
        <trans-unit id="6a1a83e9f4437f40c54f1506b859ac7294d0d128" translate="yes" xml:space="preserve">
          <source>So far, we've seen literals used as templates. If the list of pack items doesn't have fixed length, an expression constructing the template is required (whenever, for some reason, &lt;code&gt;()*&lt;/code&gt; cannot be used). Here's an example: To store named string values in a way that can be conveniently parsed by a C program, we create a sequence of names and null terminated ASCII strings, with &lt;code&gt;=&lt;/code&gt; between the name and the value, followed by an additional delimiting null byte. Here's how:</source>
          <target state="translated">到目前为止，我们已经看到文字用作模板。如果包装物品列表的长度不固定，则需要构造模板的表达式（但由于某种原因，不能使用 &lt;code&gt;()*&lt;/code&gt; ）。这是一个示例：为了以一种可以由C程序方便地解析的方式存储命名字符串值，我们创建了一个名称序列和以null终止的ASCII字符串，在名称和值之间带有 &lt;code&gt;=&lt;/code&gt; ，然后是一个附加的定界空字节。这是如何做：</target>
        </trans-unit>
        <trans-unit id="7a5692420708108a4d7ad47094be88b57cf9bf66" translate="yes" xml:space="preserve">
          <source>So for English (with Bracket Notation) &lt;code&gt;&quot;...[quant,_1,file]...&quot;&lt;/code&gt; is fine (for 0 it returns &quot;0 files&quot;, for 1 it returns &quot;1 file&quot;, and for more it returns &quot;2 files&quot;, etc.)</source>
          <target state="translated">因此，对于英语（带括号表示法） &lt;code&gt;&quot;...[quant,_1,file]...&quot;&lt;/code&gt; 很好（对于0，它返回&amp;ldquo; 0个文件&amp;rdquo;，对于1，它返回&amp;ldquo; 1个文件&amp;rdquo;，对于更多，它返回&amp;ldquo; 2个文件&amp;rdquo;等）</target>
        </trans-unit>
        <trans-unit id="8477c048b776b6250b8d3a6b206bd8a95a79a9ff" translate="yes" xml:space="preserve">
          <source>So for example, instead of using:</source>
          <target state="translated">因此,例如,不使用。</target>
        </trans-unit>
        <trans-unit id="23a15c81788a2c5aff56ccaef77af7e0b8ce44eb" translate="yes" xml:space="preserve">
          <source>So given the diagram above, Perl will search &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt; , and finally &lt;code&gt;MaternalGrandparent&lt;/code&gt; . This may be a problem because now we're looking in &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;</source>
          <target state="translated">因此，鉴于上面的图表中，Perl会寻找 &lt;code&gt;Child&lt;/code&gt; ， &lt;code&gt;Father&lt;/code&gt; ， &lt;code&gt;PaternalGrandparent&lt;/code&gt; ， &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; ， &lt;code&gt;Mother&lt;/code&gt; ，终于 &lt;code&gt;MaternalGrandparent&lt;/code&gt; 。这可能是一个问题，因为现在我们正在寻找 &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f8c16c38e4b1347fbe4bd6bed13c87b6b97a967" translate="yes" xml:space="preserve">
          <source>So given the diagram above, Perl will search &lt;code&gt;Child&lt;/code&gt;, &lt;code&gt;Father&lt;/code&gt;, &lt;code&gt;PaternalGrandparent&lt;/code&gt;, &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;, &lt;code&gt;Mother&lt;/code&gt;, and finally &lt;code&gt;MaternalGrandparent&lt;/code&gt;. This may be a problem because now we're looking in &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91f4e47cc018c4b1c4ca9fc78408994ad8035bd1" translate="yes" xml:space="preserve">
          <source>So here is the bottom line--if you are sure that control will revert back to the enclosing Perl scope fairly quickly after the end of your callback, then it isn't absolutely necessary to dispose explicitly of any temporaries you may have created. Mind you, if you are at all uncertain about what to do, it doesn't do any harm to tidy up anyway.</source>
          <target state="translated">所以这里有一个底线--如果你确信在你的回调结束后,控制会很快地返回到外层的Perl作用域,那么并不是绝对有必要明确地处理任何你可能已经创建的临时变量。提醒你,如果你不确定要做什么,那么无论如何整理一下也没有什么坏处。</target>
        </trans-unit>
        <trans-unit id="4443d502fbd614fe670f624b7a8d6e87d74c5b32" translate="yes" xml:space="preserve">
          <source>So hopefully you've now got a few ideas about what's good to modularise. Let's now see how it's done.</source>
          <target state="translated">所以希望你现在已经对模块化的好东西有了一些想法。现在就让我们来看看是怎么做的吧。</target>
        </trans-unit>
        <trans-unit id="6d3a27421600e7d4abecd702bd20845b8466123d" translate="yes" xml:space="preserve">
          <source>So how do I use a proxy with File::Fetch?</source>
          <target state="translated">那么如何使用File::Fetch的代理?</target>
        </trans-unit>
        <trans-unit id="9d00ee45ac1982b7db0dbf721dd3e3787ed6d62f" translate="yes" xml:space="preserve">
          <source>So how do you use a source filter in a Perl script? Above, I said that a source filter is just a special kind of module. Like all Perl modules, a source filter is invoked with a use statement.</source>
          <target state="translated">那么如何在Perl脚本中使用源码过滤器呢?上面我说过,源过滤器只是一种特殊的模块。和所有的Perl模块一样,源过滤器也是通过使用语句来调用的。</target>
        </trans-unit>
        <trans-unit id="6cca2cb75a50d0827a566440232066af85d09fbe" translate="yes" xml:space="preserve">
          <source>So how does it work?</source>
          <target state="translated">那么它是如何运作的呢?</target>
        </trans-unit>
        <trans-unit id="7fc04ce8d1c409ed6d44985cf7b3c46dd155a24f" translate="yes" xml:space="preserve">
          <source>So how hard could that be? You look at the code that produces the first item, and it reads:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9612f816ae3d1d599129006ddc23ec570699e275" translate="yes" xml:space="preserve">
          <source>So if you take for example the shell command</source>
          <target state="translated">因此,如果你以shell命令为例</target>
        </trans-unit>
        <trans-unit id="557e6fd5bed4c1d07e89cc778dd5ffa04e712afb" translate="yes" xml:space="preserve">
          <source>So if you want to check the validity of the encoding, surround the expression with &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; block as follows;</source>
          <target state="translated">因此，如果要检查编码的有效性，请按如下所示用 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 块包围表达式；</target>
        </trans-unit>
        <trans-unit id="a821fbe9858bdf4860678fd5e1e7551e3704e346" translate="yes" xml:space="preserve">
          <source>So if you want to check the validity of the encoding, surround the expression with &lt;code&gt;eval {}&lt;/code&gt; block as follows;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e30a7ebf49e6593b8da91cf7504894e9cfa473" translate="yes" xml:space="preserve">
          <source>So if you were to supply a new, complete, top-level source file to add to Perl, you should conform to this peculiar practice by yourself selecting an appropriate quotation from Tolkien, retaining the original spelling and punctuation and using the same format the rest of the quotes are in. Indirect and oblique is just fine; remember, it's a metaphor, so being meta is, after all, what it's for.</source>
          <target state="translated">所以,如果你要提供一个新的、完整的、顶层的源文件添加到Perl中,你应该遵守这种奇特的做法,自己从Tolkien中选择一个合适的引文,保留原来的拼写和标点,并使用其余引文的格式。间接和间接就可以了,记住,这是一个比喻,所以毕竟是元的,是用来做什么的。</target>
        </trans-unit>
        <trans-unit id="02bb4252af15d73e7777da1a95cce444353d918a" translate="yes" xml:space="preserve">
          <source>So if you're working with Unicode data, consult the documentation of every module you're using if there are any issues with Unicode data exchange. If the documentation does not talk about Unicode at all, suspect the worst and probably look at the source to learn how the module is implemented. Modules written completely in Perl shouldn't cause problems. Modules that directly or indirectly access code written in other programming languages are at risk.</source>
          <target state="translated">所以,如果你在使用Unicode数据,请查阅你使用的每个模块的文档,如果有Unicode数据交换的问题。如果文档中根本没有谈到Unicode,就怀疑最坏的情况,可能要看源码来了解模块是如何实现的。完全用Perl编写的模块应该不会引起问题。直接或间接访问其他编程语言编写的代码的模块就有风险了。</target>
        </trans-unit>
        <trans-unit id="e319523cadbb2780f0ef0af26ce5a7a559c73594" translate="yes" xml:space="preserve">
          <source>So in VMS its pm_to_blib.ts.</source>
          <target state="translated">所以在VMS中,它的pm_to_blib.ts。</target>
        </trans-unit>
        <trans-unit id="3bce9b15392a6c8658669f57b4a2decac3558eb6" translate="yes" xml:space="preserve">
          <source>So instead you'll want to do something like this:</source>
          <target state="translated">所以,你会想做这样的事情。</target>
        </trans-unit>
        <trans-unit id="6161c23b3048d528f32556aeffc6deb23d6328c9" translate="yes" xml:space="preserve">
          <source>So it is round-trip safe for \xF9\xF9. But if the line above is upside down, here is what happens.</source>
          <target state="translated">所以,它是往返安全的xF9xF9。但如果上面的线是颠倒的,就会出现这样的情况。</target>
        </trans-unit>
        <trans-unit id="c06ae4675003e825258b16549181d9f72cc7560a" translate="yes" xml:space="preserve">
          <source>So it's clearer and best to use the compound form when specifying blocks. And be sure that is what you really really want to do. In most cases scripts are what you want instead.</source>
          <target state="translated">所以在指定块的时候,最好使用复合形式,这样更清晰。而且要确定那是你真正真正想做的事情。在大多数情况下,脚本才是你想要的。</target>
        </trans-unit>
        <trans-unit id="3007e0313fdaf4be553a40db748fe3ab3979d2d6" translate="yes" xml:space="preserve">
          <source>So just remember always to use the array or hash constructors with &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;{}&lt;/code&gt; , and you'll be fine, although it's not always optimally efficient.</source>
          <target state="translated">因此，只要记住始终将数组或哈希构造函数与 &lt;code&gt;[]&lt;/code&gt; 或 &lt;code&gt;{}&lt;/code&gt; 一起使用，就可以了，尽管它并不总是最佳效率的。</target>
        </trans-unit>
        <trans-unit id="d027afb082f340c36adda48951c99192de3bf3d9" translate="yes" xml:space="preserve">
          <source>So just remember always to use the array or hash constructors with &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;{}&lt;/code&gt;, and you'll be fine, although it's not always optimally efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28f6b3059bd71a14d4d6430ebaa792ae77f9b5ae" translate="yes" xml:space="preserve">
          <source>So much for textual data. Let's get onto the meaty stuff that &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; are best at: handling binary formats for numbers. There is, of course, not just one binary format - life would be too simple - but Perl will do all the finicky labor for you.</source>
          <target state="translated">文本数据就这么多。让我们到肉的东西， &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 最擅长的：处理二进制格式的数字。当然，不仅有一种二进制格式-生活太简单了-但Perl会为您完成所有繁琐的工作。</target>
        </trans-unit>
        <trans-unit id="c03e630c08b97b3f5b437a4e7c4b378ae3776973" translate="yes" xml:space="preserve">
          <source>So much for textual data. Let's get onto the meaty stuff that &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; are best at: handling binary formats for numbers. There is, of course, not just one binary format - life would be too simple - but Perl will do all the finicky labor for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6434510a7a13803f70088fd4384a0dc891e9b671" translate="yes" xml:space="preserve">
          <source>So neither &lt;code&gt;latin1&lt;/code&gt; nor &lt;code&gt;ascii&lt;/code&gt; are incompatible with the &lt;code&gt;utf8&lt;/code&gt; flag - they only govern when the JSON output engine escapes a character or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6d818d0bc8716d4413f806e54c839d9543bd1d" translate="yes" xml:space="preserve">
          <source>So now &lt;code&gt;tie $scalar&lt;/code&gt; will always tie the scalar, not the handle it holds. To tie the handle, use &lt;code&gt;tie *$scalar&lt;/code&gt; (with an explicit asterisk). The same applies to &lt;code&gt;tied *$scalar&lt;/code&gt; and &lt;code&gt;untie *$scalar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e5670a7ba385b708ff4bcfadcd36a0825afece" translate="yes" xml:space="preserve">
          <source>So now this code would be written:</source>
          <target state="translated">所以现在要写这段代码。</target>
        </trans-unit>
        <trans-unit id="7ec657e348cc94be548b290696e0a818e7f982d5" translate="yes" xml:space="preserve">
          <source>So now you have a file ending in .tar.gz (or, less often, .zip). You know there's a tasty module inside. There are four steps you must now take:</source>
          <target state="translated">所以现在你有一个以 .tar.gz 结尾的文件 (或者,较少见的是 .zip)。你知道里面有一个美味的模块。现在你必须采取四个步骤。</target>
        </trans-unit>
        <trans-unit id="9f7f09ef2fcd4d20ffdab1795e6c221c8b2cdf50" translate="yes" xml:space="preserve">
          <source>So please select carefully what library you want to use.</source>
          <target state="translated">所以请慎重选择您要使用的图书馆。</target>
        </trans-unit>
        <trans-unit id="fc4d504736579a86ac1ba1abd47d391cec08a768" translate="yes" xml:space="preserve">
          <source>So put in parentheses to say what you really mean.</source>
          <target state="translated">所以在括号里写上你的真实意思。</target>
        </trans-unit>
        <trans-unit id="291a379872204cd90f4de2f2a608af9f0d7dabed" translate="yes" xml:space="preserve">
          <source>So specifically, autoloaded functions cannot see package lexicals (this applies to both the &lt;b&gt;SelfLoader&lt;/b&gt; and the Autoloader). The &lt;code&gt;vars&lt;/code&gt; pragma provides an alternative to defining package-level globals that will be visible to autoloaded routines. See the documentation on &lt;b&gt;vars&lt;/b&gt; in the pragma section of &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">因此，特别是，自动加载的函数无法查看包词汇（这既适用于&lt;b&gt;SelfLoader&lt;/b&gt;，也适用于Autoloader）。的 &lt;code&gt;vars&lt;/code&gt; 编译指示提供到限定封装级全局那将是自动加载例程可见的替代方案。请参阅&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;的pragma部分中有关&lt;b&gt;vars&lt;/b&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="178e0296c43b2c22ca3149a0d363aa4b6a82de7c" translate="yes" xml:space="preserve">
          <source>So that's how we consume and produce fixed-width data. Let's recap what we've seen of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; so far:</source>
          <target state="translated">这就是我们消费和产生固定宽度数据的方式。让我们回顾一下我们所看到的 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 并 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 至今：</target>
        </trans-unit>
        <trans-unit id="ae19d4915e0b62760549bd4eeb2c1e92ef2ac7db" translate="yes" xml:space="preserve">
          <source>So that's how we consume and produce fixed-width data. Let's recap what we've seen of &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; so far:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5a5de8356ec781cae3674738f4fa4085230f11" translate="yes" xml:space="preserve">
          <source>So the Perl interface would look like this</source>
          <target state="translated">所以Perl的界面是这样的</target>
        </trans-unit>
        <trans-unit id="eb361df349469f52fd13dc7f637fd6d3f4002c01" translate="yes" xml:space="preserve">
          <source>So the Perl subroutine would look like this:</source>
          <target state="translated">所以Perl的子程序是这样的。</target>
        </trans-unit>
        <trans-unit id="f9e5e29abec6c42a24502ee051f01eb881622a3a" translate="yes" xml:space="preserve">
          <source>So the exit codes are...</source>
          <target state="translated">所以退出密码是...</target>
        </trans-unit>
        <trans-unit id="ecdcbf5b6eec0983bdba576e908b1b991d7bdaa0" translate="yes" xml:space="preserve">
          <source>So the methods &lt;code&gt;PrintID&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; can be invoked like this:</source>
          <target state="translated">因此，可以像这样调用方法 &lt;code&gt;PrintID&lt;/code&gt; 和 &lt;code&gt;Display&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fc02af530f320939749f4c5dd232069afbb23ee8" translate="yes" xml:space="preserve">
          <source>So the return value will be true if the seek operation was successful. For failure, a false value is returned and &lt;code&gt;fileLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt; are set to the reason for the failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7fd8e534a0a64d6932df0e7228b52bddc2accd" translate="yes" xml:space="preserve">
          <source>So these now have simple defaults rather than probing at build-time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050bc5740a1b6bb30a161c3c46fabef260c75737" translate="yes" xml:space="preserve">
          <source>So this:</source>
          <target state="translated">所以这个。</target>
        </trans-unit>
        <trans-unit id="65f64a88a88a2a42947aa812e415dc968ce4fc3b" translate="yes" xml:space="preserve">
          <source>So to repeat always use SvOK() to check whether an sv is defined.</source>
          <target state="translated">所以重复总是使用SvOK()来检查是否定义了一个sv。</target>
        </trans-unit>
        <trans-unit id="ec007077340f2b45239679ca4cc61f38315a3433" translate="yes" xml:space="preserve">
          <source>So what happened to dTHR?</source>
          <target state="translated">那么,dTHR怎么了?</target>
        </trans-unit>
        <trans-unit id="dd71b3066f2c37ca89d49c13416a448baf2ad1f1" translate="yes" xml:space="preserve">
          <source>So what has this got to do with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;? Well, if you want to compose a Unicode string (that is internally encoded as UTF-8), you can do so by using template code &lt;code&gt;U&lt;/code&gt; . As an example, let's produce the Euro currency symbol (code number 0x20AC):</source>
          <target state="translated">那么，这和 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 有什么关系呢？好吧，如果您想编写Unicode字符串（内部编码为UTF-8），则可以使用模板代码 &lt;code&gt;U&lt;/code&gt; 来完成。例如，让我们产生欧元货币符号（代码号0x20AC）：</target>
        </trans-unit>
        <trans-unit id="be8214c7c17783a92e4d370b91d6755f26454042" translate="yes" xml:space="preserve">
          <source>So what has this got to do with &lt;code&gt;pack&lt;/code&gt;? Well, if you want to compose a Unicode string (that is internally encoded as UTF-8), you can do so by using template code &lt;code&gt;U&lt;/code&gt;. As an example, let's produce the Euro currency symbol (code number 0x20AC):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76db05e5ac37110bc4537d598a8e57f24d0e7d58" translate="yes" xml:space="preserve">
          <source>So what is the big problem? Well, if you are expecting Perl to tidy up those temporaries for you, you might be in for a long wait. For Perl to dispose of your temporaries, control must drop back to the enclosing scope at some stage. In the event driven scenario that may never happen. This means that, as time goes on, your program will create more and more temporaries, none of which will ever be freed. As each of these temporaries consumes some memory your program will eventually consume all the available memory in your system--kapow!</source>
          <target state="translated">那么最大的问题是什么呢?好吧,如果你希望Perl为你整理这些临时文件,你可能要等很久。为了让Perl处理掉你的临时变量,控制权必须在某个阶段回落到外层作用域。在事件驱动的情况下,这可能永远不会发生。这意味着,随着时间的推移,你的程序将创建越来越多的临时变量,其中没有一个会被释放。由于每个临时变量都会消耗一些内存,你的程序最终会消耗系统中所有的可用内存--kapow!</target>
        </trans-unit>
        <trans-unit id="49dd0c06fd8f279176f457e7dd90bd0af2090341" translate="yes" xml:space="preserve">
          <source>So what's new?</source>
          <target state="translated">那么,有什么新鲜事呢?</target>
        </trans-unit>
        <trans-unit id="8be287051544a93972a5fe33ce5f2eed6334bad0" translate="yes" xml:space="preserve">
          <source>So when the output is a filehandle it will carry out a seek to the eof before writing any compressed data. If the output is a filename, it will be opened for appending. If the output is a buffer, all compressed data will be appended to the existing buffer.</source>
          <target state="translated">因此,当输出是一个文件柄时,它将在写入任何压缩数据之前对eof进行寻址。如果输出是一个文件名,它将被打开进行追加。如果输出是一个缓冲区,所有的压缩数据将被追加到现有的缓冲区。</target>
        </trans-unit>
        <trans-unit id="2b16151fbc25d8d9908507f5cf41dca81006fcb5" translate="yes" xml:space="preserve">
          <source>So when the output is a filehandle it will carry out a seek to the eof before writing any uncompressed data. If the output is a filename, it will be opened for appending. If the output is a buffer, all uncompressed data will be appended to the existing buffer.</source>
          <target state="translated">所以当输出是一个文件柄时,它将在写入任何未压缩的数据之前对eof进行寻址。如果输出是一个文件名,它将被打开进行追加。如果输出是一个缓冲区,所有未压缩的数据将被追加到现有的缓冲区。</target>
        </trans-unit>
        <trans-unit id="faf320f95dede4954f64d637d17b4ef0ec2ac56b" translate="yes" xml:space="preserve">
          <source>So when we parse &lt;code&gt;/foo/&lt;/code&gt; we see something like the following table. The left shows what is being parsed, and the number indicates where the next regop would go. The stuff on the right is the trace output of the graph. The names are chosen to be short to make it less dense on the screen. 'tsdy' is a special form of &lt;code&gt;regtail()&lt;/code&gt; which does some extra analysis.</source>
          <target state="translated">因此，当我们解析 &lt;code&gt;/foo/&lt;/code&gt; 我们会看到类似下表的内容。左侧显示了要解析的内容，数字表示下一个重新加载的位置。右侧的内容是图形的跟踪输出。选择的名称要短一些，以使其在屏幕上的密度较小。'tsdy'是 &lt;code&gt;regtail()&lt;/code&gt; 的一种特殊形式，它进行了一些额外的分析。</target>
        </trans-unit>
        <trans-unit id="4ca42b2545bb9f74c7dfcf26ad336456861738d0" translate="yes" xml:space="preserve">
          <source>So why is UNINST=1 not the default?</source>
          <target state="translated">那么为什么UNINST=1不是默认的呢?</target>
        </trans-unit>
        <trans-unit id="5764d39b6b45dd4fdf0407e6dadfbf8730c1c2c3" translate="yes" xml:space="preserve">
          <source>So why use these? They produce better diagnostics on failure. &lt;code&gt;ok()&lt;/code&gt; cannot know what you are testing for (beyond the name), but &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; know what the test was and why it failed. For example this test:</source>
          <target state="translated">那么为什么要使用这些呢？它们可以对故障进行更好的诊断。 &lt;code&gt;ok()&lt;/code&gt; 无法知道您要测试的内容（名称之外），但是 &lt;code&gt;is()&lt;/code&gt; 和 &lt;code&gt;isnt()&lt;/code&gt; 知道测试的内容以及测试失败的原因。例如此测试：</target>
        </trans-unit>
        <trans-unit id="0723871c8efb4af11337b70788bc11e5f341de34" translate="yes" xml:space="preserve">
          <source>So why would you ever want to use a Unix domain socket instead of a simpler named pipe? Because a named pipe doesn't give you sessions. You can't tell one process's data from another's. With socket programming, you get a separate session for each client; that's why accept() takes two arguments.</source>
          <target state="translated">那么为什么你要使用Unix域套接字而不是更简单的命名管道呢?因为命名管道不会给你提供会话。你无法区分一个进程的数据和另一个进程的数据。使用套接字编程,你可以为每个客户端获得一个单独的会话;这就是为什么accept()需要两个参数。</target>
        </trans-unit>
        <trans-unit id="907dfd8f705f1e1d725ffd018f44b3318d9e84e1" translate="yes" xml:space="preserve">
          <source>So you can figure out what went wrong without rerunning the test.</source>
          <target state="translated">所以你可以在不重新运行测试的情况下,找出问题所在。</target>
        </trans-unit>
        <trans-unit id="23330e80d1d5c0a1be567b0263265e46b7f62019" translate="yes" xml:space="preserve">
          <source>So you rewrite it to read:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a109f19c85f2e155b7bae45252c43e85217d92" translate="yes" xml:space="preserve">
          <source>So you should instead try this;</source>
          <target state="translated">所以你反而应该试试这个。</target>
        </trans-unit>
        <trans-unit id="99368e21d7e985fc9382de7cbad3270d6b572550" translate="yes" xml:space="preserve">
          <source>So you want to know what &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; actually does?</source>
          <target state="translated">因此，您想知道 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 实际上是做什么的吗？</target>
        </trans-unit>
        <trans-unit id="f880312d8311a1d75dbe80304cdf01f9913e6eb1" translate="yes" xml:space="preserve">
          <source>So you want to know what &lt;code&gt;import&lt;/code&gt; actually does?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98457d69f47757522cf080b8cba6d90757ec58b" translate="yes" xml:space="preserve">
          <source>So, beside calls like</source>
          <target state="translated">所以,除了像这样的电话之外</target>
        </trans-unit>
        <trans-unit id="8b676466aa2043751e164c60e8f768fad4f2409b" translate="yes" xml:space="preserve">
          <source>So, for classes and subclasses to have inheritance correctly work with autoloading, you need to ensure stubs are loaded.</source>
          <target state="translated">所以,要想让类和子类的继承正确地与自动加载一起工作,你需要确保存根被加载。</target>
        </trans-unit>
        <trans-unit id="3fdc850c88acfeea0034b4d0a5ecf1cbe8955116" translate="yes" xml:space="preserve">
          <source>So, for example, &quot;wb9&quot; means open for writing with the maximum compression using the default strategy and &quot;wb4R&quot; means open for writing with compression level 4 and run-length encoding.</source>
          <target state="translated">所以,举例来说,&quot;wb9 &quot;意味着使用默认策略的最大压缩量打开写入,&quot;wb4R &quot;意味着使用压缩级别4和运行长度编码打开写入。</target>
        </trans-unit>
        <trans-unit id="ef8d2c630e8e6fd22bf1a2656520cdc24a0e732f" translate="yes" xml:space="preserve">
          <source>So, for example, say you have a file compressed with gzip that you want to recompress with bzip2. Here is all that is needed to carry out the recompression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98d3c65256a4087c70ab29c5923eefef7208b53e" translate="yes" xml:space="preserve">
          <source>So, for instance, to pack 20302 to a signed 16 bit integer in your computer's representation you write</source>
          <target state="translated">所以,例如,要把20302包装成一个有符号的16位整数,在你的计算机中,你写道</target>
        </trans-unit>
        <trans-unit id="5a026df42e6a15ca497ded704c00f477c0e8e518" translate="yes" xml:space="preserve">
          <source>So, if you see two terms with an &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; , between them, you can turn them into a single expression. When you do this, you execute the code in the block on the next line: if you see &lt;code&gt;=&lt;/code&gt; , you'll do the code in line 2. If you see &lt;code&gt;+&lt;/code&gt; , you'll do the code in line 4. It's this code which contributes to the op tree.</source>
          <target state="translated">因此，如果看到两个带有 &lt;code&gt;=&lt;/code&gt; 或 &lt;code&gt;+&lt;/code&gt; 的项，则可以将它们变成单个表达式。执行此操作时，将在下一行的代码块中执行代码：如果看到 &lt;code&gt;=&lt;/code&gt; ，则将在第2行中执行代码。如果看到 &lt;code&gt;+&lt;/code&gt; ，则将在第4行中进行代码。这有助于op树。</target>
        </trans-unit>
        <trans-unit id="0379bb60c338fa89d5d14562ac618c3cb90f2526" translate="yes" xml:space="preserve">
          <source>So, if you see two terms with an &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;, between them, you can turn them into a single expression. When you do this, you execute the code in the block on the next line: if you see &lt;code&gt;=&lt;/code&gt;, you'll do the code in line 2. If you see &lt;code&gt;+&lt;/code&gt;, you'll do the code in line 4. It's this code which contributes to the op tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f012b7bad59a01daf6da8ed100b9c040ae573c55" translate="yes" xml:space="preserve">
          <source>So, if you want to collect memory info in a cycle, you may call</source>
          <target state="translated">所以,如果你想在一个周期内收集内存信息,你可以调用</target>
        </trans-unit>
        <trans-unit id="f33ef09895b9595e58c40994534996d41b9b84f6" translate="yes" xml:space="preserve">
          <source>So, in general, &quot;state&quot; subroutines are faster. But &quot;my&quot; subs are necessary if you want to create closures:</source>
          <target state="translated">所以,一般来说,&quot;状态 &quot;子程序更快。但如果你想创建闭包,&quot;我的 &quot;子程序是必要的。</target>
        </trans-unit>
        <trans-unit id="b92446e0fc5150a550f9b239a78e7589775be2a5" translate="yes" xml:space="preserve">
          <source>So, let's say you want to add a custom element called 'foo'. In your subclass's &lt;code&gt;new&lt;/code&gt; method, after calling &lt;code&gt;SUPER::new&lt;/code&gt; you'd call:</source>
          <target state="translated">因此，假设您要添加一个名为&amp;ldquo; foo&amp;rdquo;的自定义元素。在子类的 &lt;code&gt;new&lt;/code&gt; 方法中，调用 &lt;code&gt;SUPER::new&lt;/code&gt; 您将调用：</target>
        </trans-unit>
        <trans-unit id="6f5a18b784416c2faf1e8dee13b0302a69a860cf" translate="yes" xml:space="preserve">
          <source>So, on the advice of the gettext manual, you rewrite:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04546d861006181e7076b52be007eeaf163f592b" translate="yes" xml:space="preserve">
          <source>So, rather than having to say:</source>
          <target state="translated">所以,与其说是。</target>
        </trans-unit>
        <trans-unit id="ce7cf438ffd137d4b9ae434030e4dd1bac347bb0" translate="yes" xml:space="preserve">
          <source>So, saying &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; performs the &quot;and&quot; operation on numbers (yielding &lt;code&gt;3&lt;/code&gt; ). Saying &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; performs the &quot;and&quot; operation on strings (yielding &lt;code&gt;&quot;1&quot;&lt;/code&gt; ).</source>
          <target state="translated">因此，说 &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; 对数字执行&amp;ldquo;与&amp;rdquo;运算（产生 &lt;code&gt;3&lt;/code&gt; ）。说 &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; 对字符串执行&amp;ldquo;和&amp;rdquo;运算（产生 &lt;code&gt;&quot;1&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="82342d83c583203ac699858cccf76690e3807bf1" translate="yes" xml:space="preserve">
          <source>So, saying &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; performs the &quot;and&quot; operation on numbers (yielding &lt;code&gt;3&lt;/code&gt;). Saying &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; performs the &quot;and&quot; operation on strings (yielding &lt;code&gt;&quot;1&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a687b4464c81c65ad71b0b242c9a17889c06be5" translate="yes" xml:space="preserve">
          <source>So, sometimes you might want to use symbolic references to manipulate the symbol table directly. This doesn't matter for formats, handles, and subroutines, because they are always global--you can't use my() on them. For scalars, arrays, and hashes, though--and usually for subroutines-- you probably only want to use hard references.</source>
          <target state="translated">所以,有时你可能会想使用符号引用来直接操作符号表,这对格式、句柄和子程序来说并不重要,因为它们总是全局的--你不能对它们使用my()。对于格式、句柄和子程序来说,这并不重要,因为它们总是全局的--你不能对它们使用my()。但对于标量、数组和散列--通常对于子程序--你可能只想使用硬引用。</target>
        </trans-unit>
        <trans-unit id="988f750cf0c3c51b512a9cb6f00133978c0404e1" translate="yes" xml:space="preserve">
          <source>So, the following examples now works as expected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b62c1a83484ac0f80542a2de9bd04874ec15952" translate="yes" xml:space="preserve">
          <source>So, the following examples will now work all as expected:</source>
          <target state="translated">所以,下面的例子现在将全部按照预期工作。</target>
        </trans-unit>
        <trans-unit id="b83b5043b490e39d23dba00f7ce754a2ed020ba9" translate="yes" xml:space="preserve">
          <source>So, the following line:</source>
          <target state="translated">所以,下面这句话。</target>
        </trans-unit>
        <trans-unit id="e43264c4b337b0feb1da1b34ab4669d9bfde22ae" translate="yes" xml:space="preserve">
          <source>So, the following two statements do the same thing:</source>
          <target state="translated">所以,下面两句话的作用是一样的。</target>
        </trans-unit>
        <trans-unit id="0f5b24deb12867f441d62aa11cf38e02b6693a70" translate="yes" xml:space="preserve">
          <source>So, the string of Martian &quot;I am CVSGXX!&quot; uses 12 bytes to encode the nine characters 'I', ' ', 'a', 'm', ' ', 'CV', 'SG', 'XX', '!'.</source>
          <target state="translated">所以,火星人 &quot;我是CVSGXX!&quot;这个字符串用12个字节来编码'I'、''、'a'、'm'、''、'CV'、'SG'、'XX'、'!'这九个字符。</target>
        </trans-unit>
        <trans-unit id="93058ef0377751cf8a22fa887d9f94acca14dc08" translate="yes" xml:space="preserve">
          <source>So, this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a65604ac4ef3bcdf6fdcf41ebba719fc161bed" translate="yes" xml:space="preserve">
          <source>So, what needs to replace gettext is a system that supports lexicons of functions instead of lexicons of strings. An entry in a lexicon from such a system should</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666f233dad00e2e027af2bcddbc736103b174459" translate="yes" xml:space="preserve">
          <source>So, what's the big problem with that? It looks right, doesn't it? After all, I just told you that you need an array of references, so by golly, you've made me one!</source>
          <target state="translated">那么,这有什么大问题呢?它看起来是对的,不是吗?毕竟,我刚刚告诉你,你需要一个引用的数组,所以天哪,你给我做了一个数组!</target>
        </trans-unit>
        <trans-unit id="c5f7a9040d43fdd63e7b31365a3279f444817139" translate="yes" xml:space="preserve">
          <source>So, you email your various translators (the boss decides that the languages du jour are Chinese, Arabic, Russian, and Italian, so you have one translator for each), asking for translations for &quot;I scanned %g directory.&quot; and &quot;I scanned %g directories.&quot;. When they reply, you'll put that in the lexicons for gettext to use when it localizes your software, so that when the user is running under the &quot;zh&quot; (Chinese) locale, gettext(&quot;I scanned %g directory.&quot;) will return the appropriate Chinese text, with a &quot;%g&quot; in there where printf can then interpolate $dir_scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="93c6a1f183694628e37ced41591147bfc0da1908" translate="yes" xml:space="preserve">
          <source>Socket</source>
          <target state="translated">Socket</target>
        </trans-unit>
        <trans-unit id="1a669dbe9f824af2034872bc98a2b6823a4c09af" translate="yes" xml:space="preserve">
          <source>Socket option level constant for setsockopt() and getsockopt().</source>
          <target state="translated">setockopt()和getockopt()的Socket选项级别常数。</target>
        </trans-unit>
        <trans-unit id="e89a311c363b4ef4dc4be93eaeb6560498486275" translate="yes" xml:space="preserve">
          <source>Socket option name constants for IPv4 socket options at the &lt;code&gt;IPPROTO_IP&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;IPPROTO_IP&lt;/code&gt; 级别的IPv4套接字选项的套接字选项名称常量。</target>
        </trans-unit>
        <trans-unit id="d741b5bebfd867658e744ca3a901afeae953cecf" translate="yes" xml:space="preserve">
          <source>Socket option name constants for IPv6 socket options at the &lt;code&gt;IPPROTO_IPV6&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;IPPROTO_IPV6&lt;/code&gt; 级别的IPv6套接字选项的套接字选项名称常量。</target>
        </trans-unit>
        <trans-unit id="1bea3c52b1b205afb6610aaf669b9a46fdff261d" translate="yes" xml:space="preserve">
          <source>Socket option name constants for TCP socket options at the &lt;code&gt;IPPROTO_TCP&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;IPPROTO_TCP&lt;/code&gt; 级别的TCP套接字选项的套接字选项名称常量。</target>
        </trans-unit>
        <trans-unit id="8943cecdeb64eeb6c75caac188d81a6e580de3c7" translate="yes" xml:space="preserve">
          <source>Socket option name constants for setsockopt() and getsockopt() at the &lt;code&gt;SOL_SOCKET&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;SOL_SOCKET&lt;/code&gt; 级别的setsockopt（）和getsockopt（）的套接字选项名称常量。</target>
        </trans-unit>
        <trans-unit id="8a16f3d4e350888989be5c310a53b83649d06948" translate="yes" xml:space="preserve">
          <source>Socket option value constants for &lt;code&gt;IP_TOS&lt;/code&gt; socket option.</source>
          <target state="translated">&lt;code&gt;IP_TOS&lt;/code&gt; 套接字选项的套接字选项值常数。</target>
        </trans-unit>
        <trans-unit id="fa50a464d89f205a80a64569fe1c6e97815468d2" translate="yes" xml:space="preserve">
          <source>Socket option value contants for &lt;code&gt;IP_MTU_DISCOVER&lt;/code&gt; socket option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734337896e45cc2ebeff48479a66b46bdd05ddb4" translate="yes" xml:space="preserve">
          <source>Socket type constants to use as the second argument to socket(), or the value of the &lt;code&gt;SO_TYPE&lt;/code&gt; socket option.</source>
          <target state="translated">套接字类型常量，用作socket（）的第二个参数，或 &lt;code&gt;SO_TYPE&lt;/code&gt; 套接字选项的值。</target>
        </trans-unit>
        <trans-unit id="5bedda872ecdb70c2a2d140ada477f5b294eb6f0" translate="yes" xml:space="preserve">
          <source>Socket.</source>
          <target state="translated">Socket.</target>
        </trans-unit>
        <trans-unit id="ebe92a08483968e414740930bf0a0a08483ad931" translate="yes" xml:space="preserve">
          <source>Socket.a</source>
          <target state="translated">Socket.a</target>
        </trans-unit>
        <trans-unit id="848572346180cfeef643ccd7fddcc1762d26f13a" translate="yes" xml:space="preserve">
          <source>Sockets: Client/Server Communication</source>
          <target state="translated">套接字。客户机/服务器通信</target>
        </trans-unit>
        <trans-unit id="7ec10a4e74fb45054402ed905e46c34443ecf08d" translate="yes" xml:space="preserve">
          <source>Sockopts =&amp;gt; ARRAY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96898c7bdde72d33b35d72cb9458ecfe538b1436" translate="yes" xml:space="preserve">
          <source>Software distributions released to the CPAN include a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad9951caf8addf9e39a4e5a9ec448dfc26c21d1a" translate="yes" xml:space="preserve">
          <source>Solaris (x86, SPARC)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbfadcc007c702d16ecd0e6f6d3baeefff3d72aa" translate="yes" xml:space="preserve">
          <source>Solaris 10 documentation on syslog, &lt;a href=&quot;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&quot;&gt;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&lt;/a&gt;</source>
          <target state="translated">有关syslog的Solaris 10文档，&lt;a href=&quot;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&quot;&gt;http：//docs.sun.com/app/docs/doc/816-5168/syslog-3c？a = view&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c7dc4f9a32286dc36b6fd2393ea8eff49fa670d" translate="yes" xml:space="preserve">
          <source>Solaris 11 documentation on syslog, &lt;a href=&quot;https://docs.oracle.com/cd/E53394_01/html/E54766/syslog-3c.html&quot;&gt;https://docs.oracle.com/cd/E53394_01/html/E54766/syslog-3c.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98fa552d1b28be69cf1da96419b8a90307162871" translate="yes" xml:space="preserve">
          <source>Solaris 7 and above will run in either 32 bit or 64 bit mode on SPARC CPUs, via a reboot. You can build 64 bit apps whilst running 32 bit mode and vice-versa. 32 bit apps will run under Solaris running in either 32 or 64 bit mode. 64 bit apps require Solaris to be running 64 bit mode.</source>
          <target state="translated">Solaris 7及以上版本将通过重启在SPARC CPU上以32位或64位模式运行。您可以在运行32位模式时构建64位应用程序,反之亦然。32位应用程序将在32位或64位模式的Solaris下运行。64位应用程序需要Solaris运行在64位模式下。</target>
        </trans-unit>
        <trans-unit id="bd381ce5f7739cf9ac8dad77ffda2188f3978def" translate="yes" xml:space="preserve">
          <source>Solaris Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed34c43c64cf4558fcdec9f488cfa58f0a1b6fe3" translate="yes" xml:space="preserve">
          <source>Solaris FAQ</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef2766b707c501497b46c746afec2754f6fc860" translate="yes" xml:space="preserve">
          <source>Solaris Version Numbers.</source>
          <target state="translated">Solaris版本号。</target>
        </trans-unit>
        <trans-unit id="cc61dfb91810e5a0313350199a1b65c0af136cfa" translate="yes" xml:space="preserve">
          <source>Solaris global loading added by Nick Ing-Simmons with design/coding assistance from Tim Bunce, January 1996.</source>
          <target state="translated">1996年1月,Nick Ing-Simmons在Tim Bunce的设计/编码协助下增加了Solaris全局加载。</target>
        </trans-unit>
        <trans-unit id="708154fc528413c51483abd6933e68d503e36bdc" translate="yes" xml:space="preserve">
          <source>Solaris may include two versions of perl, e.g. Solaris 9 includes both 5.005_03 and 5.6.1. This is to provide stability across Solaris releases, in cases where a later perl version has incompatibilities with the version included in the preceding Solaris release. The default perl version will always be the most recent, and in general the old version will only be retained for one Solaris release. Note also that the default perl will NOT be configured to search for modules in the older version, again due to compatibility/stability concerns. As a consequence if you upgrade Solaris, you will have to rebuild/reinstall any additional CPAN modules that you installed for the previous Solaris version. See the CPAN manpage under 'autobundle' for a quick way of doing this.</source>
          <target state="translated">Solaris可能包含两个版本的perl,例如Solaris 9包括5.005_03和5.6.1。这是为了在Solaris的各个版本中提供稳定性,以防以后的perl版本与前一个Solaris版本中的版本不兼容。默认的 perl 版本总是最新的,一般来说,旧的版本只会在一个 Solaris 版本中保留。还请注意,同样出于兼容性/稳定性的考虑,默认的 perl 将不会被配置为搜索旧版本中的模块。因此,如果你升级Solaris,你将不得不重建/重新安装你为以前的Solaris版本安装的任何额外的CPAN模块。请参阅CPAN手册中 &quot;autobundle &quot;一栏,了解如何快速完成这项工作。</target>
        </trans-unit>
        <trans-unit id="4bfa1cd2c976e4c546cb366d1dac1622384583a6" translate="yes" xml:space="preserve">
          <source>Solaris provides some BSD-compatibility functions in /usr/ucblib/libucb.a. Perl will not build and run correctly if linked against -lucb since it contains routines that are incompatible with the standard Solaris libc. Normally this is not a problem since the solaris hints file prevents Configure from even looking in /usr/ucblib for libraries, and also explicitly omits -lucb.</source>
          <target state="translated">Solaris 在 /usr/ucblib/libucb.a 中提供了一些与 BSD 兼容的函数。如果与 -lucb 相连,Perl 将无法正确地构建和运行,因为它包含了与标准 Solaris libc 不兼容的例程。通常这不是问题,因为 solaris 提示文件会阻止 Configure 在 /usr/ucblib 中查找库,而且还明确省略了 -lucb。</target>
        </trans-unit>
        <trans-unit id="d0c3f51965773ced91efb778a3671a3477592fd4" translate="yes" xml:space="preserve">
          <source>Solaris ships with a range of Solaris-specific modules. If you choose to install your own version of perl you will find the source of many of these modules is available on CPAN under the Sun::Solaris:: namespace.</source>
          <target state="translated">Solaris提供了一系列Solaris特有的模块,如果你选择安装你自己版本的perl,你会发现许多这些模块的源码在CPAN的Sun::Solaris::命名空间下。如果你选择安装你自己的perl版本,你会发现这些模块的源代码在CPAN上的Sun::Solaris::命名空间下有很多。</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="05b004a92e5eda3ec6e47516b582fc25b61b35b9" translate="yes" xml:space="preserve">
          <source>Solutions</source>
          <target state="translated">Solutions</target>
        </trans-unit>
        <trans-unit id="9cdf28d779226e286e9b065703a4425b88267886" translate="yes" xml:space="preserve">
          <source>Solving the problem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b2aad45d07b70e1b7eefea74316913901b6e42" translate="yes" xml:space="preserve">
          <source>Some</source>
          <target state="translated">Some</target>
        </trans-unit>
        <trans-unit id="5f679f54e4d0cf2197954f773a392f8d165d2696" translate="yes" xml:space="preserve">
          <source>Some (minor) parts copyright 2009 Adam Kennedy.</source>
          <target state="translated">部分(小部分)版权归亚当-肯尼迪2009年所有。</target>
        </trans-unit>
        <trans-unit id="3a644bfc8b4acacc1b56f8b5a49f0fbd16c47364" translate="yes" xml:space="preserve">
          <source>Some *nix programs use fork() a lot; with the mostly useful flavors of perl for OS/2 (there are several built simultaneously) this is supported; but some flavors do not support this (e.g., when Perl is called from inside REXX). Using fork() after</source>
          <target state="translated">一些*nix程序经常使用fork();对于大多数有用的perl for OS/2风味(有几个同时构建的),它是支持的;但有些风味不支持这个(例如,当Perl从REX内部调用时)。使用 fork()后的</target>
        </trans-unit>
        <trans-unit id="6a808c47f9491da438c1507c81067e0d0ad1d610" translate="yes" xml:space="preserve">
          <source>Some / became \ in pdksh.</source>
          <target state="translated">有些/成为了pdksh。</target>
        </trans-unit>
        <trans-unit id="2ced2108dbb21d847b539e5bf8d6eae4e6952b9e" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;/&lt;/code&gt; became &lt;code&gt;\&lt;/code&gt; in pdksh.</source>
          <target state="translated">一些 &lt;code&gt;/&lt;/code&gt; 在pdksh中变成 &lt;code&gt;\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aee5f872bb2cc36da4c3ed1ff4e14aea96b6faa3" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;Win*&lt;/code&gt; entry points also overload a &quot;meaningful&quot; return value with the error indicator; having a 0 return value indicates an error. Yet some other &lt;code&gt;Win*&lt;/code&gt; entry points overload things even more, and 0 return value may mean a successful call returning a valid value 0, as well as an error condition; in the case of a 0 return value one should call WinGetLastError() API to distinguish a successful call from a failing one.</source>
          <target state="translated">一些 &lt;code&gt;Win*&lt;/code&gt; 入口点还会使带有错误指示符的&amp;ldquo;有意义的&amp;rdquo;返回值超载。返回值为0表示错误。还有一些其他 &lt;code&gt;Win*&lt;/code&gt; 入口点甚至使事情更加过载，返回值0可能意味着成功的调用将返回有效值0以及错误情况。如果返回值为0，则应调用WinGetLastError（）API来区分成功调用和失败调用。</target>
        </trans-unit>
        <trans-unit id="7d77130c6b6fd9352c737bed1bb1dcb935bd9ca9" translate="yes" xml:space="preserve">
          <source>Some DLLs are only present in some versions of OS/2, or in some configurations of OS/2. Some exported entry points are present only in DLLs shipped with some versions of OS/2. If these DLLs and entry points were linked directly for a Perl executable/DLL or from a Perl extensions, this binary would work only with the specified versions/setups. Even if these entry points were not needed, the</source>
          <target state="translated">有些DLL只存在于某些版本的OS/2中,或某些配置的OS/2中。一些导出的入口点只存在于某些版本的OS/2的DLL中。如果这些 DLLs 和入口点直接链接到一个 Perl 可执行文件/DLL 或来自 Perl 扩展,那么这个二进制文件将只在指定的版本/设置中工作。即使不需要这些入口点,这个</target>
        </trans-unit>
        <trans-unit id="8e4ba3d45352907bcc89de2a6a57c8be8f5ee286" translate="yes" xml:space="preserve">
          <source>Some Filters Clobber the &lt;code&gt;DATA&lt;/code&gt; Handle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14adc2a370c74e9f0b7a6eb136961fb44f4e9d5e" translate="yes" xml:space="preserve">
          <source>Some IBM EBCDIC character sets may be known by character code set identification numbers (CCSID numbers) or code page numbers.</source>
          <target state="translated">一些IBM EBCDIC字符集可以通过字符代码集识别号(CCSID号)或代码页号来了解。</target>
        </trans-unit>
        <trans-unit id="20970d609d169c267b614af470114dc6b026c453" translate="yes" xml:space="preserve">
          <source>Some Irix cc versions, e.g. 7.3.1.1m (try cc -version) have been known to have issues (coredumps) when compiling perl.c. If you've used -OPT:fast_io=ON and this happens, try removing it. If that fails, or you didn't use that, then try adjusting other optimization options (-LNO, -INLINE, -O3 to -O2, etcetera). The compiler bug has been reported to SGI. (Allen Smith &amp;lt;easmith@beatrice.rutgers.edu&amp;gt;)</source>
          <target state="translated">已知某些Irix cc版本，例如7.3.1.1m（尝试cc -version）在编译perl.c时会出现问题（coredumps）。如果您使用-OPT：fast_io = ON并发生这种情况，请尝试将其删除。如果失败，或者您没有使用它，请尝试调整其他优化选项（-LNO，-INLINE，-O3到-O2等）。编译器错误已报告给SGI。 （艾伦&amp;middot;史密斯&amp;lt;easmith@beatrice.rutgers.edu&amp;gt;）</target>
        </trans-unit>
        <trans-unit id="e270800f9e2c9ef58198c6c9f8463f63bac86a3b" translate="yes" xml:space="preserve">
          <source>Some Linux platforms have a maximum stack size. Setting too large of a stack size will cause thread creation to fail.</source>
          <target state="translated">有些Linux平台有最大的堆栈大小,设置过大的堆栈大小会导致线程创建失败。设置过大的栈大小会导致线程创建失败。</target>
        </trans-unit>
        <trans-unit id="bad9f67e1f3cb77c4fe9db59234d0c5d6bb841b2" translate="yes" xml:space="preserve">
          <source>Some OSes do not need these in which case leave it blank.</source>
          <target state="translated">有些操作系统不需要这些,在这种情况下,留下空白。</target>
        </trans-unit>
        <trans-unit id="69e7c8fdafb5d76df4c8f736ecf437657f4dc150" translate="yes" xml:space="preserve">
          <source>Some Pod formatters output to formats that implement non-breaking spaces as an individual character (which I'll call &quot;NBSP&quot;), and others output to formats that implement non-breaking spaces just as spaces wrapped in a &quot;don't break this across lines&quot; code. Note that at the level of Pod, both sorts of codes can occur: Pod can contain a NBSP character (whether as a literal, or as a &quot;E&amp;lt;160&amp;gt;&quot; or &quot;E&amp;lt;nbsp&amp;gt;&quot; code); and Pod can contain &quot;S&amp;lt;foo I&amp;lt;bar&amp;gt; baz&amp;gt;&quot; codes, where &quot;mere spaces&quot; (character 32) in such codes are taken to represent non-breaking spaces. Pod parsers should consider supporting the optional parsing of &quot;S&amp;lt;foo I&amp;lt;bar&amp;gt; baz&amp;gt;&quot; as if it were &quot;foo</source>
          <target state="translated">一些Pod格式化程序输出为将不间断空格作为单个字符实现的格式（我将其称为&amp;ldquo; NBSP&amp;rdquo;），而其他Pod格式化程序将输出为实现不间断空格的格式，例如包装为&amp;ldquo;不要破坏该空格&amp;rdquo;的格式跨行&amp;rdquo;代码。请注意，在Pod级别上，两种代码都可能发生：Pod可以包含NBSP字符（无论是文字，还是&amp;ldquo; E &amp;lt;160&amp;gt;&amp;rdquo;或&amp;ldquo; E &amp;lt;nbsp&amp;gt;&amp;rdquo;代码）； Pod和Pod可以包含&amp;ldquo; S &amp;lt;foo I &amp;lt;bar&amp;gt; baz&amp;gt;&amp;rdquo;代码，其中此类代码中的&amp;ldquo;纯空格&amp;rdquo;（字符32）用于表示不间断空格。 Pod解析器应考虑支持&amp;ldquo; S &amp;lt;foo I &amp;lt;bar&amp;gt; baz&amp;gt;&amp;rdquo;的可选解析，就好像它是&amp;ldquo; foo&amp;rdquo;一样。</target>
        </trans-unit>
        <trans-unit id="f04294d93d5e63f6eed93e1148616595ef1487e2" translate="yes" xml:space="preserve">
          <source>Some Sys-V based systems, notably Solaris 2.X, redefined some of the standard socket constants. Since these were constant across all architectures, they were often hardwired into perl code. The proper way to deal with this is to &quot;use Socket&quot; to get the correct values.</source>
          <target state="translated">一些基于Sys-V的系统,尤其是Solaris 2.X,重新定义了一些标准的socket常量。由于这些常量在所有的架构中都是不变的,所以它们经常被硬生生地加入到perl代码中。处理这种情况的正确方法是 &quot;使用Socket &quot;来获得正确的值。</target>
        </trans-unit>
        <trans-unit id="a5a0c5f6bf86975f2c301ba492652230f705bf5a" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; ; and there are only a few dozen possible General Categories.</source>
          <target state="translated">某些Unicode属性具有一组受限制的合法值。例如，所有二进制属性都被限制为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ；而且只有几十种可能的常规类别。</target>
        </trans-unit>
        <trans-unit id="9e6eb6762559c642717c0b35b0e9407b4ea3c431" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; ; and there are only a few dozen possible General Categories. Use &lt;code&gt;prop_values&lt;/code&gt; to find out if a given property is one such, and if so, to get a list of the values:</source>
          <target state="translated">某些Unicode属性具有一组受限制的合法值。例如，所有二进制属性都被限制为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ；而且只有几十种可能的常规类别。使用 &lt;code&gt;prop_values&lt;/code&gt; 找出给定的属性是否为此类属性，如果是，则获取值列表：</target>
        </trans-unit>
        <trans-unit id="5c1e962daca68404a4b5aeb9ebaf19ea3e632a80" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;; and there are only a few dozen possible General Categories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f826abadcb88c4b8481c939d03177c526f688d85" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;; and there are only a few dozen possible General Categories. Use &lt;code&gt;prop_values&lt;/code&gt; to find out if a given property is one such, and if so, to get a list of the values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da934a0c72e4b177f3b0df8a238ca7ff76fadba5" translate="yes" xml:space="preserve">
          <source>Some Unixes, especially more recent ones, are free of this inherent security bug. On such systems, when the kernel passes the name of the set-id script to open to the interpreter, rather than using a pathname subject to meddling, it instead passes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16213d61f5d76543cce7f4b52c976b8f28e064a" translate="yes" xml:space="preserve">
          <source>Some approximate operating system names and their &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; values in the &quot;OTHER&quot; category include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd2e23e9cee0c22d7103f4f9a78d73d761dd3aa" translate="yes" xml:space="preserve">
          <source>Some approximate operating system names and their &lt;code&gt;$^O&lt;/code&gt; values in the &quot;OTHER&quot; category include:</source>
          <target state="translated">一些近似的操作系统名称及其在&amp;ldquo; OTHER&amp;rdquo;类别中的 &lt;code&gt;$^O&lt;/code&gt; 值包括：</target>
        </trans-unit>
        <trans-unit id="fc63731ea34f43c4af1c4ec405f7ea69ef1d9704" translate="yes" xml:space="preserve">
          <source>Some authors have strange characters in their names.</source>
          <target state="translated">有些作者的名字里有奇怪的字。</target>
        </trans-unit>
        <trans-unit id="6877eb2746dbad4bb0e9e27d968022bfea3412f0" translate="yes" xml:space="preserve">
          <source>Some background on thread implementations from the operating system viewpoint. There are three basic categories of threads: user-mode threads, kernel threads, and multiprocessor kernel threads.</source>
          <target state="translated">从操作系统的角度介绍一下线程实现的背景。线程有三个基本类别:用户模式线程、内核线程和多处理器内核线程。</target>
        </trans-unit>
        <trans-unit id="fc0d6a626635ac5ae4291cc3487e50efd6ae5a14" translate="yes" xml:space="preserve">
          <source>Some bits may be relevant at compile-time only, some at run-time only. This is a new mechanism and the details may change. See also &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;.</source>
          <target state="translated">一些位可能仅在编译时相关，而某些位仅在运行时相关。这是一个新机制，细节可能会更改。另请参阅&lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd8e9b1766f0e1e6eaaded7abc870a37e4571ff0" translate="yes" xml:space="preserve">
          <source>Some brief examples:</source>
          <target state="translated">一些简单的例子:</target>
        </trans-unit>
        <trans-unit id="61327002f5b3861abd79c62e144ccb79536f4f22" translate="yes" xml:space="preserve">
          <source>Some builtins (e.g. &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt;) has a call signature that cannot completely be representated with a Perl prototype. This means that some valid Perl code will be invalid under autodie. As an example:</source>
          <target state="translated">一些内置函数（例如 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; ）具有不能完全用Perl原型表示的调用签名。这意味着某些有效的Perl代码在autodie下将无效。举个例子：</target>
        </trans-unit>
        <trans-unit id="7e79ef5917eeda28b646e901197de5a6a38623ed" translate="yes" xml:space="preserve">
          <source>Some builtins (e.g. &lt;code&gt;chdir&lt;/code&gt; or &lt;code&gt;truncate&lt;/code&gt;) has a call signature that cannot completely be representated with a Perl prototype. This means that some valid Perl code will be invalid under autodie. As an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21eaccc7842c81c4d4f8ac981ea6b511271286ba" translate="yes" xml:space="preserve">
          <source>Some calls simply aren't available, real or emulated, on every platform.</source>
          <target state="translated">有些电话根本不是每个平台都能用,真实的或仿真的。</target>
        </trans-unit>
        <trans-unit id="f873ff9032d8b5cf7f774b66c05c986170a4cd42" translate="yes" xml:space="preserve">
          <source>Some characters have multiple names (synonyms).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7144ad6e6fa073f902e93d5905df49ebac937d92" translate="yes" xml:space="preserve">
          <source>Some code points also have abbreviated names, such as &quot;LF&quot; or &quot;NL&quot;. &lt;code&gt;viacode&lt;/code&gt; never returns these.</source>
          <target state="translated">一些代码点还具有缩写名称，例如&amp;ldquo; LF&amp;rdquo;或&amp;ldquo; NL&amp;rdquo;。 &lt;code&gt;viacode&lt;/code&gt; 从不返回这些。</target>
        </trans-unit>
        <trans-unit id="73ac6d49c092929d2ed08d514c7b1beb64ede02a" translate="yes" xml:space="preserve">
          <source>Some code taken from &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Catch&quot;&gt;Test::Catch&lt;/a&gt;, written by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;. Hence, those parts Copyright Micheal G Schwern 2001. Used and distributed with permission.</source>
          <target state="translated">一些代码取自Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;编写的&lt;a href=&quot;../more&quot;&gt;Test :: More&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Catch&quot;&gt;Test :: Catch&lt;/a&gt;。因此，这些部分版权所有Micheal G Schwern2001。经许可使用和分发。</target>
        </trans-unit>
        <trans-unit id="5561c8c582f640440613f3fca93ddc04efa36da2" translate="yes" xml:space="preserve">
          <source>Some code taken from &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;Test::Catch&quot;&gt;Test::Catch&lt;/a&gt;, written by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;. Hence, those parts Copyright Micheal G Schwern 2001. Used and distributed with permission.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e5cd1d1e32143aa0622aa3ff5ac884d8c3a28f" translate="yes" xml:space="preserve">
          <source>Some comparison operators, as their associativity,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1339e50839100723841e8e48747e9f9a1f5bed3" translate="yes" xml:space="preserve">
          <source>Some constants and functions are exported by default by this module; but for backward-compatibility any recently-added symbols are not exported by default and must be requested explicitly. When an import list is provided to the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; line, the default exports are not automatically imported. It is therefore best practice to always to explicitly list all the symbols required.</source>
          <target state="translated">默认情况下，此模块会导出一些常量和函数。但是为了向后兼容，默认情况下不会导出任何最近添加的符号，而必须明确地请求它们。向 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; 行提供导入列表时，不会自动导入默认导出。因此，最佳实践是始终明确列出所需的所有符号。</target>
        </trans-unit>
        <trans-unit id="54e9eafb99e932590ca2a179b6517831860be80f" translate="yes" xml:space="preserve">
          <source>Some constants and functions are exported by default by this module; but for backward-compatibility any recently-added symbols are not exported by default and must be requested explicitly. When an import list is provided to the &lt;code&gt;use Socket&lt;/code&gt; line, the default exports are not automatically imported. It is therefore best practice to always to explicitly list all the symbols required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="078dd465c32a4795a8e3e38bd49c7d92d32009a8" translate="yes" xml:space="preserve">
          <source>Some constants don't print correctly either with or without &lt;b&gt;-d&lt;/b&gt;. For instance, neither B::Deparse nor Data::Dumper know how to print dual-valued scalars correctly, as in:</source>
          <target state="translated">使用&lt;b&gt;-d&lt;/b&gt;或不使用&lt;b&gt;-d，&lt;/b&gt;某些常量均无法正确打印。例如，B :: Deparse或Data :: Dumper都不知道如何正确打印双值标量，如：</target>
        </trans-unit>
        <trans-unit id="c475f4b24c437233a2b88333a558801f98c19297" translate="yes" xml:space="preserve">
          <source>Some contexts allow 2 or even 1 digit, but any usage without exactly three digits, the first being a zero, may give unintended results. (For example, in a regular expression it may be confused with a backreference; see &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;&quot;Octal escapes&quot; in perlrebackslash&lt;/a&gt;.) Starting in Perl 5.14, you may use &lt;code&gt;\o{}&lt;/code&gt; instead, which avoids all these problems. Otherwise, it is best to use this construct only for ordinals &lt;code&gt;\077&lt;/code&gt; and below, remembering to pad to the left with zeros to make three digits. For larger ordinals, either use &lt;code&gt;\o{}&lt;/code&gt;, or convert to something else, such as to hex and use &lt;code&gt;\N{U+}&lt;/code&gt; (which is portable between platforms with different character sets) or &lt;code&gt;\x{}&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e689eba4cf9a38a4acdff5d45d4adaf1f020711" translate="yes" xml:space="preserve">
          <source>Some contexts allow 2 or even 1 digit, but any usage without exactly three digits, the first being a zero, may give unintended results. (For example, in a regular expression it may be confused with a backreference; see &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;Octal escapes in perlrebackslash&lt;/a&gt;.) Starting in Perl 5.14, you may use &lt;code&gt;\o{}&lt;/code&gt; instead, which avoids all these problems. Otherwise, it is best to use this construct only for ordinals &lt;code&gt;\077&lt;/code&gt; and below, remembering to pad to the left with zeros to make three digits. For larger ordinals, either use &lt;code&gt;\o{}&lt;/code&gt; , or convert to something else, such as to hex and use &lt;code&gt;\N{U+}&lt;/code&gt; (which is portable between platforms with different character sets) or &lt;code&gt;\x{}&lt;/code&gt; instead.</source>
          <target state="translated">有些上下文允许2甚至1位数字，但是任何没有正好3位数字的用法（第一个为零）可能会产生意想不到的结果。 （例如，在正则表达式中，它可能与反向引用混淆；请参阅&lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;perlrebackslash中的八进制转义&lt;/a&gt;。）从Perl 5.14开始，可以改用 &lt;code&gt;\o{}&lt;/code&gt; ，这样可以避免所有这些问题。否则，最好仅对 &lt;code&gt;\077&lt;/code&gt; 及以下的普通字符使用此构造，记住要在左边用零填充以产生三位数。对于较大的普通字符，请使用 &lt;code&gt;\o{}&lt;/code&gt; 或转换为其他内容，例如十六进制并使用 &lt;code&gt;\N{U+}&lt;/code&gt; （可在具有不同字符集的平台之间移植）或使用 &lt;code&gt;\x{}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17469d7643e0741d1ada43cbcada6ad7b4213174" translate="yes" xml:space="preserve">
          <source>Some cool command line examples to impress the Python crowd ;)</source>
          <target state="translated">一些很酷的命令行例子,让Python人群印象深刻;)</target>
        </trans-unit>
        <trans-unit id="4f597c06196db5dfae23debf5b526fce9cd25685" translate="yes" xml:space="preserve">
          <source>Some cool command line examples to impress the Python crowd ;) You might want to compare them to the results under -Mbignum or -Mbigrat:</source>
          <target state="translated">一些很酷的命令行示例会给Python人群留下深刻的印象;)你可能想把它们与-Mbignum或-Mbigrat下的结果进行比较。</target>
        </trans-unit>
        <trans-unit id="c6746b978d2a5bd75b46a34b757950222f7e2d87" translate="yes" xml:space="preserve">
          <source>Some database drivers for DBI can also automatically encode and decode, but that is sometimes limited to the UTF-8 encoding.</source>
          <target state="translated">一些DBI的数据库驱动程序也可以自动编码和解码,但这有时仅限于UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="20c968c59a29a0ad6a0ddbad176bb82749120644" translate="yes" xml:space="preserve">
          <source>Some devices will be expecting a &quot;\r&quot; at the end of each line rather than a &quot;\n&quot;. In some ports of perl, &quot;\r&quot; and &quot;\n&quot; are different from their usual (Unix) ASCII values of &quot;\015&quot; and &quot;\012&quot;. You may have to give the numeric values you want directly, using octal (&quot;\015&quot;), hex (&quot;0x0D&quot;), or as a control-character specification (&quot;\cM&quot;).</source>
          <target state="translated">有些设备会期望在每行末尾有一个&quot;\r &quot;而不是&quot;\n&quot;。在 perl 的某些端口中,&quot;\r&quot; 和 &quot;\n&quot; 与它们通常的 (Unix)ASCII 值 &quot;\015&quot; 和 &quot;\012&quot; 不同。您可能必须直接给出您想要的数值,使用八进制 (&quot;\015&quot;)、 十六进制 (&quot;0x0D&quot;),或作为控制字符规范 (&quot;\cM&quot;)。</target>
        </trans-unit>
        <trans-unit id="29952c75d7a51b190a8cddfeefebadadc1b42414" translate="yes" xml:space="preserve">
          <source>Some digits that &lt;code&gt;\d&lt;/code&gt; matches look like some of the [0-9] ones, but have different values. For example, BENGALI DIGIT FOUR (U+09EA) looks very much like an ASCII DIGIT EIGHT (U+0038), and LEPCHA DIGIT SIX (U+1C46) looks very much like an ASCII DIGIT FIVE (U+0035). An application that is expecting only the ASCII digits might be misled, or if the match is &lt;code&gt;\d+&lt;/code&gt;, the matched string might contain a mixture of digits from different writing systems that look like they signify a number different than they actually do. &lt;a href=&quot;Unicode::UCD#num%28%29&quot;&gt;&quot;num()&quot; in Unicode::UCD&lt;/a&gt; can be used to safely calculate the value, returning &lt;code&gt;undef&lt;/code&gt; if the input string contains such a mixture. Otherwise, for example, a displayed price might be deliberately different than it appears.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b15270299f74ddedc9cb2a27cec0a8d56d430a18" translate="yes" xml:space="preserve">
          <source>Some digits that &lt;code&gt;\d&lt;/code&gt; matches look like some of the [0-9] ones, but have different values. For example, BENGALI DIGIT FOUR (U+09EA) looks very much like an ASCII DIGIT EIGHT (U+0038). An application that is expecting only the ASCII digits might be misled, or if the match is &lt;code&gt;\d+&lt;/code&gt; , the matched string might contain a mixture of digits from different writing systems that look like they signify a number different than they actually do. &lt;a href=&quot;unicode/ucd#num()&quot;&gt;num() in Unicode::UCD&lt;/a&gt; can be used to safely calculate the value, returning &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the input string contains such a mixture.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 匹配的某些数字看起来像[0-9]中的某些数字，但具有不同的值。例如，BENGALI DIGIT FOUR（U + 09EA）看起来非常像ASCII DIGIT EIGHT（U + 0038）。预期仅ASCII数字的应用程序可能会被误导，或者如果匹配为 &lt;code&gt;\d+&lt;/code&gt; ，则匹配的字符串可能包含来自不同书写系统的数字的混合，看起来它们表示的数字与实际数字不同。&lt;a href=&quot;unicode/ucd#num()&quot;&gt;Unicode :: UCD中的num（）&lt;/a&gt;可用于安全地计算该值，如果输入字符串包含此类混合，则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb6208f023afd54f9f4acc30a7d493bf14dc6378" translate="yes" xml:space="preserve">
          <source>Some distributions may fail some tests, but you may want to install them anyway (as above, or via &lt;code&gt;force install&lt;/code&gt; command of &lt;code&gt;CPAN.pm&lt;/code&gt; shell-mode).</source>
          <target state="translated">某些发行版可能无法通过某些测试，但您可能仍要安装它们（如上所述，或通过 &lt;code&gt;CPAN.pm&lt;/code&gt; shell-mode的 &lt;code&gt;force install&lt;/code&gt; 命令）。</target>
        </trans-unit>
        <trans-unit id="673083d85e2bc8b38798cec75fcc0568d074003d" translate="yes" xml:space="preserve">
          <source>Some distributions may need to link to libraries or other third-party code and their build and installation sequences may be more complicated. Check any</source>
          <target state="translated">有些发行版可能需要链接到库或其他第三方代码,它们的构建和安装顺序可能比较复杂。请检查任何</target>
        </trans-unit>
        <trans-unit id="1c42a00c69d1bae42ece6b69f30632a5649a6c28" translate="yes" xml:space="preserve">
          <source>Some documentation is not available as man pages, so if a cross-reference is not found by man, try it with &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;. Perldoc can also take you directly to documentation for functions (with the &lt;b&gt;-f&lt;/b&gt; switch). See &lt;code&gt;perldoc --help&lt;/code&gt; (or &lt;a href=&quot;perldoc&quot;&gt;&lt;code&gt;perldoc perldoc&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;man perldoc&lt;/code&gt;) for other helpful options &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; has to offer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e14b5226c1b3194a20df87855367bd2962c1e595" translate="yes" xml:space="preserve">
          <source>Some documentation is not available as man pages, so if a cross-reference is not found by man, try it with &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;. Perldoc can also take you directly to documentation for functions (with the &lt;b&gt;-f&lt;/b&gt; switch). See &lt;code&gt;perldoc --help&lt;/code&gt; (or &lt;code&gt;perldoc perldoc&lt;/code&gt; or &lt;code&gt;man perldoc&lt;/code&gt; ) for other helpful options &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; has to offer.</source>
          <target state="translated">某些文档不能作为手册页使用，因此，如果man找不到交叉引用，请尝试使用&lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;。Perldoc也可以直接将您带到功能的文档（带有&lt;b&gt;-f&lt;/b&gt;开关）。见 &lt;code&gt;perldoc --help&lt;/code&gt; （或 &lt;code&gt;perldoc perldoc&lt;/code&gt; 或 &lt;code&gt;man perldoc&lt;/code&gt; 其他有用的选项）&lt;a href=&quot;perldoc&quot;&gt;的perldoc&lt;/a&gt;所提供的。</target>
        </trans-unit>
        <trans-unit id="24f338e775f9d8f25e87916116198ed5fdfd8fac" translate="yes" xml:space="preserve">
          <source>Some earlier versions of this module had docs with some confusing typos in the description of &lt;code&gt;skip(...)&lt;/code&gt; .</source>
          <target state="translated">该模块的某些早期版本的文档在 &lt;code&gt;skip(...)&lt;/code&gt; 的描述中带有一些令人困惑的错别字。</target>
        </trans-unit>
        <trans-unit id="755fe62cf032f564de90de30771b7c019c165183" translate="yes" xml:space="preserve">
          <source>Some earlier versions of this module had docs with some confusing typos in the description of &lt;code&gt;skip(...)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d5fff71fc694b06c17e66dad87b134506e2302b" translate="yes" xml:space="preserve">
          <source>Some essentially obsolete locales that aren't supersets of ASCII, mainly those in ISO 646 or other 7-bit locales, such as ASMO 449, can also have problems, depending on what portions of the ASCII character set get changed by the locale and are also used by the program. The warning message lists the determinable conflicting characters.</source>
          <target state="translated">一些不是ASCII的超集的基本过时的locale,主要是ISO 646或其他7位locale,如ASMO 449,也会有问题,这取决于ASCII字符集的哪些部分被locale改变了,并且也被程序使用。警告信息列出了可确定的冲突字符。</target>
        </trans-unit>
        <trans-unit id="e8b38cbb77fcb476bf8e2983ccfda5ed33f46a79" translate="yes" xml:space="preserve">
          <source>Some example section specifications follow.</source>
          <target state="translated">下面是一些示例部分的规格。</target>
        </trans-unit>
        <trans-unit id="6e29ae8ec1bfc30435ce56e5aeb3c20b82d6940f" translate="yes" xml:space="preserve">
          <source>Some examples of lists include:</source>
          <target state="translated">一些名单的例子包括:</target>
        </trans-unit>
        <trans-unit id="ae84b84bf5612613743104cf4d1d3f624e770f5d" translate="yes" xml:space="preserve">
          <source>Some examples of syntactically invalid attribute lists (with annotation):</source>
          <target state="translated">一些语法上无效的属性列表的例子(有注释)。</target>
        </trans-unit>
        <trans-unit id="9c0e82c6c1b276d5dbb162e62c1346aa697136e3" translate="yes" xml:space="preserve">
          <source>Some examples of syntactically valid attribute lists:</source>
          <target state="translated">一些语法上有效的属性列表的例子。</target>
        </trans-unit>
        <trans-unit id="9ef77adb00cc27df250473773f43482c29f3a24d" translate="yes" xml:space="preserve">
          <source>Some examples of valid string input</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">一些例子:</target>
        </trans-unit>
        <trans-unit id="75d23fa0c37e5a03812b09ef6b9c46fbb0fa3389" translate="yes" xml:space="preserve">
          <source>Some extensions provide filters on data entry/exit points, such as &lt;code&gt;DB_File::filter_store_key&lt;/code&gt; and family. Look out for such filters in the documentation of your extensions; they can make the transition to Unicode data much easier.</source>
          <target state="translated">一些扩展提供了有关数据输入/输出点的过滤器，例如 &lt;code&gt;DB_File::filter_store_key&lt;/code&gt; 和family。在扩展文档中查找此类过滤器；它们可以使向Unicode数据的转换更加容易。</target>
        </trans-unit>
        <trans-unit id="1ba2d8223f5d5832c6d62c8b546d87c608dd84fc" translate="yes" xml:space="preserve">
          <source>Some extensions, like DB_File and Compress::Zlib use/require prebuilt libraries for the perl extensions/modules to work. If these libraries are built using the default configuration, it might happen that you run into an error like &quot;invalid loader fixup&quot; during load phase. HP is aware of this problem. Search the HP-UX cxx-dev forums for discussions about the subject. The short answer is that &lt;b&gt;everything&lt;/b&gt; (all libraries, everything) must be compiled with &lt;code&gt;+z&lt;/code&gt; or &lt;code&gt;+Z&lt;/code&gt; to be PIC (position independent code). (For gcc, that would be &lt;code&gt;-fpic&lt;/code&gt; or &lt;code&gt;-fPIC&lt;/code&gt; ). In HP-UX 11.00 or newer the linker error message should tell the name of the offending object file.</source>
          <target state="translated">一些扩展，例如DB_File和Compress :: Zlib使用/要求预建的库来使perl扩展/模块正常工作。如果这些库是使用默认配置构建的，则可能会在加载阶段遇到诸如&amp;ldquo;无效的加载器修复&amp;rdquo;之类的错误。 HP已意识到此问题。在HP-UX cxx-dev论坛中搜索有关该主题的讨论。简短的答案是，&lt;b&gt;所有内容&lt;/b&gt;（所有库，所有内容）都必须使用 &lt;code&gt;+z&lt;/code&gt; 或 &lt;code&gt;+Z&lt;/code&gt; 编译为PIC（与位置无关的代码）。 （对于gcc，这将是 &lt;code&gt;-fpic&lt;/code&gt; 或 &lt;code&gt;-fPIC&lt;/code&gt; ）。在HP-UX 11.00或更高版本中，链接器错误消息应告诉有问题的目标文件名。</target>
        </trans-unit>
        <trans-unit id="97e5fb9532f2e63b2e8307d7b53c5f2c9628f824" translate="yes" xml:space="preserve">
          <source>Some extensions, like DB_File and Compress::Zlib use/require prebuilt libraries for the perl extensions/modules to work. If these libraries are built using the default configuration, it might happen that you run into an error like &quot;invalid loader fixup&quot; during load phase. HP is aware of this problem. Search the HP-UX cxx-dev forums for discussions about the subject. The short answer is that &lt;b&gt;everything&lt;/b&gt; (all libraries, everything) must be compiled with &lt;code&gt;+z&lt;/code&gt; or &lt;code&gt;+Z&lt;/code&gt; to be PIC (position independent code). (For gcc, that would be &lt;code&gt;-fpic&lt;/code&gt; or &lt;code&gt;-fPIC&lt;/code&gt;). In HP-UX 11.00 or newer the linker error message should tell the name of the offending object file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96048dd05a92d52cf8eb93ed66aaff949feef0b8" translate="yes" xml:space="preserve">
          <source>Some features of Storable can lead to security vulnerabilities if you accept Storable documents from untrusted sources with the default flags. Most obviously, the optional (off by default) CODE reference serialization feature allows transfer of code to the deserializing process. Furthermore, any serialized object will cause Storable to helpfully load the module corresponding to the class of the object in the deserializing module. For manipulated module names, this can load almost arbitrary code. Finally, the deserialized object's destructors will be invoked when the objects get destroyed in the deserializing process. Maliciously crafted Storable documents may put such objects in the value of a hash key that is overridden by another key/value pair in the same hash, thus causing immediate destructor execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7fd53f722062eada03c99c5c0131726fe7cb4c" translate="yes" xml:space="preserve">
          <source>Some features of Storable can lead to security vulnerabilities if you accept Storable documents from untrusted sources. Most obviously, the optional (off by default) CODE reference serialization feature allows transfer of code to the deserializing process. Furthermore, any serialized object will cause Storable to helpfully load the module corresponding to the class of the object in the deserializing module. For manipulated module names, this can load almost arbitrary code. Finally, the deserialized object's destructors will be invoked when the objects get destroyed in the deserializing process. Maliciously crafted Storable documents may put such objects in the value of a hash key that is overridden by another key/value pair in the same hash, thus causing immediate destructor execution.</source>
          <target state="translated">如果您接受来自不受信任来源的 Storable 文档,Storable 的一些功能可能会导致安全漏洞。最明显的是,可选的(默认情况下是关闭的)CODE引用序列化功能允许将代码转移到反序列化过程中。此外,任何序列化的对象都会导致Storable在反序列化模块中帮助加载与该对象的类相对应的模块。对于被操纵的模块名,这可以加载几乎任意的代码。最后,当对象在反序列化过程中被销毁时,将调用反序列化对象的析构器。恶意制作的Storable文档可能会将这种对象放在一个哈希键的值中,而这个哈希键的值被同一哈希中的另一个键/值对所覆盖,从而导致反序列化对象的解构器立即执行。</target>
        </trans-unit>
        <trans-unit id="f752a90675005dd54235d7444500f6345be768a8" translate="yes" xml:space="preserve">
          <source>Some fields (prereq, optional_features) indicate the particular version(s) of some other module that may be required as a prerequisite. This section details the Version Range type used to provide this information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4359f8aa4aabe1dad1748bdef1a7b9a37c1bbf67" translate="yes" xml:space="preserve">
          <source>Some fields are marked</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5db1ec9986268b7b9f60738685c3882e9bc3347c" translate="yes" xml:space="preserve">
          <source>Some fields require a version specification (ex. &lt;a href=&quot;#requires&quot;&gt;&quot;requires&quot;&lt;/a&gt;, &lt;a href=&quot;#recommends&quot;&gt;&quot;recommends&quot;&lt;/a&gt;, &lt;a href=&quot;#build_requires&quot;&gt;&quot;build_requires&quot;&lt;/a&gt;, etc.) to indicate the particular version(s) of some other module that may be required as a prerequisite. This section details the version specification formats that are currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97585d9b5872f5fb97ab1bbd9ba4d3f871bc3309" translate="yes" xml:space="preserve">
          <source>Some fields require a version specification (ex. &lt;a href=&quot;#requires&quot;&gt;&quot;requires&quot;&lt;/a&gt;, &lt;a href=&quot;#recommends&quot;&gt;&quot;recommends&quot;&lt;/a&gt;, &lt;a href=&quot;#build_requires&quot;&gt;&quot;build_requires&quot;&lt;/a&gt;, etc.). This section details the version specifications that are currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a5845f2d183141d3d5841eae9982c91a04a877" translate="yes" xml:space="preserve">
          <source>Some filesystems may not support UTF-8 file names, or they may be supported incompatibly with Perl. Therefore UTF-8 names that are visible to the filesystem, such as module names may not work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410f15ec6c766d4ad924aef6bed79d8486d14679" translate="yes" xml:space="preserve">
          <source>Some folks are surprised that &lt;code&gt;make distclean&lt;/code&gt; does not delete everything not listed in their MANIFEST (thus making a clean distribution) but only tells them what they need to delete. This is done because it is considered too dangerous. While developing your module you might write a new file, not add it to the MANIFEST, then run a &lt;code&gt;distclean&lt;/code&gt; and be sad because your new work was deleted.</source>
          <target state="translated">有些人感到惊讶， &lt;code&gt;make distclean&lt;/code&gt; 不会删除清单中未列出的所有内容（从而进行干净的发行），而只是告诉他们需要删除什么。这样做是因为它被认为太危险了。在开发模块时，您可能会编写一个新文件，而不是将其添加到MANIFEST中，然后运行 &lt;code&gt;distclean&lt;/code&gt; 并感到遗憾，因为您的新工作已被删除。</target>
        </trans-unit>
        <trans-unit id="278e93ddc6a44b33edbb2aa1b1e3252bdefc68ee" translate="yes" xml:space="preserve">
          <source>Some folks would prefer full alphanumeric prototypes. Alphanumerics have been intentionally left out of prototypes for the express purpose of someday in the future adding named, formal parameters. The current mechanism's main goal is to let module writers provide better diagnostics for module users. Larry feels the notation quite understandable to Perl programmers, and that it will not intrude greatly upon the meat of the module, nor make it harder to read. The line noise is visually encapsulated into a small pill that's easy to swallow.</source>
          <target state="translated">有些人更喜欢完整的字母数字原型。原型中故意不使用字母数字,目的是为了将来有一天能够添加命名的正式参数。目前机制的主要目的是让模块编写者为模块用户提供更好的诊断方法。Larry觉得这种符号对于Perl程序员来说相当容易理解,它不会极大地侵入模块的肉体,也不会让模块更难读。行噪声在视觉上被封装成一个容易吞咽的小药丸。</target>
        </trans-unit>
        <trans-unit id="97b6babea6d7a1882a7f9edff1a7d1c57e6e6a28" translate="yes" xml:space="preserve">
          <source>Some format names that formatters currently are known to accept include &quot;roff&quot;, &quot;man&quot;, &quot;latex&quot;, &quot;tex&quot;, &quot;text&quot;, and &quot;html&quot;. (Some formatters will treat some of these as synonyms.)</source>
          <target state="translated">目前已知格式化程序接受的一些格式名称包括 &quot;roff&quot;、&quot;man&quot;、&quot;latex&quot;、&quot;tex&quot;、&quot;text &quot;和 &quot;html&quot;。(有些格式化程序会把其中一些当作同义词。)</target>
        </trans-unit>
        <trans-unit id="947f64f8eb13b365edd8f2a637d714cf57c4bdc9" translate="yes" xml:space="preserve">
          <source>Some formatter subclasses use this as a flag for whether output should have prologue and epilogue code omitted. For example, setting this to true for an HTML formatter class should omit the &quot;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;...&amp;lt;/title&amp;gt;&amp;lt;body&amp;gt;...&quot; prologue and the &quot;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot; epilogue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae9c58f7596d57c13463eeb374970b17faa09ff" translate="yes" xml:space="preserve">
          <source>Some frequently seen examples:</source>
          <target state="translated">一些经常看到的例子。</target>
        </trans-unit>
        <trans-unit id="5f63fbe742ecc7df05393f6e705a1b34f98dd874" translate="yes" xml:space="preserve">
          <source>Some functions are provided to simplify customization.</source>
          <target state="translated">提供了一些功能,以简化定制。</target>
        </trans-unit>
        <trans-unit id="37fca23bc4f77bc45e835fb641ab69a99facbd7e" translate="yes" xml:space="preserve">
          <source>Some functions are slower when working on UTF-8 encoded strings than on byte encoded strings. All functions that need to hop over characters such as &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt;, or matching regular expressions can work &lt;b&gt;much&lt;/b&gt; faster when the underlying data are byte-encoded.</source>
          <target state="translated">使用UTF-8编码的字符串时，某些功能比使用字节编码的字符串时要慢。需要跳跃过的字符，如所有的功能 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; ，或匹配正则表达式可以工作&lt;b&gt;多&lt;/b&gt;当底层数据是字节编码的更快。</target>
        </trans-unit>
        <trans-unit id="29d81f6ce46ee6c8888e985a057496dc42144979" translate="yes" xml:space="preserve">
          <source>Some functions are slower when working on UTF-8 encoded strings than on byte encoded strings. All functions that need to hop over characters such as &lt;code&gt;length()&lt;/code&gt;, &lt;code&gt;substr()&lt;/code&gt; or &lt;code&gt;index()&lt;/code&gt;, or matching regular expressions can work &lt;b&gt;much&lt;/b&gt; faster when the underlying data are byte-encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83116620b210d6b01d6ea586806a731e05a2beb8" translate="yes" xml:space="preserve">
          <source>Some functions available based on the version of VMS. (VMS)</source>
          <target state="translated">根据VMS的版本提供一些功能。(VMS)</target>
        </trans-unit>
        <trans-unit id="851bf3122418d781546b0c8256e17049b7be4c91" translate="yes" xml:space="preserve">
          <source>Some languages work directly with the memory addresses of values, but this can be like playing with fire. Perl provides a set of asbestos gloves for handling all memory management. The closest to an address operator in Perl is the backslash operator, but it gives you a &lt;b&gt;hard reference&lt;/b&gt;, which is much safer than a memory address.</source>
          <target state="translated">有些语言直接使用值的内存地址，但这就像玩火一样。Perl提供了一套用于处理所有内存管理的石棉手套。在Perl中最接近地址运算符的是反斜杠运算符，但它为您提供了一个&lt;b&gt;硬引用&lt;/b&gt;，它比内存地址安全得多。</target>
        </trans-unit>
        <trans-unit id="3b63ca608d0f3df96b959d17a1dcc8d27338725f" translate="yes" xml:space="preserve">
          <source>Some layers will automatically insert required lower level layers if not present; for example &lt;code&gt;:perlio&lt;/code&gt; will insert &lt;code&gt;:unix&lt;/code&gt; below itself for low level IO, and &lt;code&gt;:encoding&lt;/code&gt; will insert the platform defaults for buffered IO.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2879836a3b0aef43a136fc41d29e15e272723203" translate="yes" xml:space="preserve">
          <source>Some libraries use methods that don't modify their argument, and some libraries don't even use objects, but rather unblessed references. Because of this, liberary methods are always called as class methods, not instance methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2704cdd835e2ffc2151c5b3e73d345acc2100f0" translate="yes" xml:space="preserve">
          <source>Some locales have special sorting rules.</source>
          <target state="translated">有些地方有特殊的排序规则。</target>
        </trans-unit>
        <trans-unit id="4cbad0bcc8b3efd678863ec66e302790409bbb20" translate="yes" xml:space="preserve">
          <source>Some methods take slightly different arguments to those defined in &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; in attempt to make the interface more flexible. These are</source>
          <target state="translated">某些方法采用与&lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt;中定义的参数略有不同的参数，以使接口更加灵活。这些是</target>
        </trans-unit>
        <trans-unit id="4d5ca2cd44839d0147fa7ed895887914f1a8f96d" translate="yes" xml:space="preserve">
          <source>Some modules have an event loop, waiting for user-input. It is highly unlikely that two such modules would work adequately together in a single Perl application.</source>
          <target state="translated">有些模块有一个事件循环,等待用户输入。在一个Perl应用程序中,两个这样的模块不太可能充分地一起工作。</target>
        </trans-unit>
        <trans-unit id="e535cd54feac531816f027ba1cdedeba3dabdc08" translate="yes" xml:space="preserve">
          <source>Some modules have validation for particular types of input, such as &lt;a href=&quot;Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, &lt;a href=&quot;Business::CreditCard&quot;&gt;Business::CreditCard&lt;/a&gt;, &lt;a href=&quot;Email::Valid&quot;&gt;Email::Valid&lt;/a&gt;, and &lt;a href=&quot;Data::Validate::IP&quot;&gt;Data::Validate::IP&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99aeed54cc1e7c695f296661c28f743d9f582de7" translate="yes" xml:space="preserve">
          <source>Some modules have validation for particular types of input, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business::CreditCard&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email::Valid&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Validate::IP&quot;&gt;Data::Validate::IP&lt;/a&gt;.</source>
          <target state="translated">一些模块对特定类型的输入进行验证，例如&lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business :: ISBN&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business :: CreditCard&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email :: Valid&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Data::Validate::IP&quot;&gt;Data :: Validate :: IP&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8896acdebb142a8bf319a25d0ebc467b0372d0f5" translate="yes" xml:space="preserve">
          <source>Some modules live both in the &lt;b&gt;Standard Library&lt;/b&gt; and on &lt;b&gt;CPAN&lt;/b&gt;. These modules might be developed on two tracks as people modify either version. The trend currently is to untangle these situations.</source>
          <target state="translated">一些模块同时存在于&lt;b&gt;标准库&lt;/b&gt;和&lt;b&gt;CPAN中&lt;/b&gt;。当人们修改任一版本时，可能会在两个轨道上开发这些模块。当前的趋势是解开这些情况。</target>
        </trans-unit>
        <trans-unit id="267ef3c8246a5b5e4dbd867563c1e64b65448f37" translate="yes" xml:space="preserve">
          <source>Some modules look directly at hash keys on the Test::Builder singleton. The problem here is that the Test::Builder singleton no longer holds anything important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="215c8776bbaeb0d62cdfe5e95b87468adeef4092" translate="yes" xml:space="preserve">
          <source>Some modules may call a non-perl library that is locale-aware. This is fine as long as it doesn't try to query or change the locale using the system &lt;code&gt;setlocale&lt;/code&gt;. But if these do call the system &lt;code&gt;setlocale&lt;/code&gt;, those calls may be ineffective. Instead, &lt;a href=&quot;perlapi#Perl_setlocale&quot;&gt;&lt;code&gt;Perl_setlocale&lt;/code&gt;&lt;/a&gt; works in all circumstances. Plain setlocale is ineffective on multi-threaded POSIX 2008 systems. It operates only on the global locale, whereas each thread has its own locale, paying no attention to the global one. Since converting these non-Perl libraries to &lt;code&gt;Perl_setlocale&lt;/code&gt; is out of the question, there is a new function in v5.28 &lt;a href=&quot;perlapi#switch_to_global_locale&quot;&gt;&lt;code&gt;switch_to_global_locale&lt;/code&gt;&lt;/a&gt; that will switch the thread it is called from so that any system &lt;code&gt;setlocale&lt;/code&gt; calls will have their desired effect. The function &lt;a href=&quot;perlapi#sync_locale&quot;&gt;&lt;code&gt;sync_locale&lt;/code&gt;&lt;/a&gt; must be called before returning to perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2536c5611f03605401087c295c560b8c0a55966f" translate="yes" xml:space="preserve">
          <source>Some modules might have special reporting requirements, such as a Github or Google Code tracking system, so you should check the module documentation too.</source>
          <target state="translated">有些模块可能有特殊的报告要求,比如Github或Google代码跟踪系统,所以你也应该检查模块的文档。</target>
        </trans-unit>
        <trans-unit id="9d3dcbb265761ea263567338345aa34c90c2eea2" translate="yes" xml:space="preserve">
          <source>Some modules, mainly extensions, provide their own AUTOLOAD subroutines. They typically need to check for some special cases (such as constants) and then fallback to &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD for the rest.</source>
          <target state="translated">一些模块（主要是扩展模块）提供了自己的AUTOLOAD子例程。他们通常需要检查某些特殊情况（例如常量），然后其余时间回&lt;b&gt;退到AutoLoader&lt;/b&gt;的AUTOLOAD。</target>
        </trans-unit>
        <trans-unit id="f0adb7b022a9b5dadbc9c6aa9b58b0a54e7f8265" translate="yes" xml:space="preserve">
          <source>Some more examples, all returning 250:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c12ec8767768e2405ac12fa9dd3e5b3e02eaa4d" translate="yes" xml:space="preserve">
          <source>Some names known to &lt;code&gt;\N{...}&lt;/code&gt; refer to a sequence of multiple characters, instead of the usual single character. When one of these is included in the class, the entire sequence is matched. For example,</source>
          <target state="translated">&lt;code&gt;\N{...}&lt;/code&gt; 已知的某些名称是指多个字符的序列，而不是通常的单个字符。当其中之一包含在类中时，整个序列将匹配。例如，</target>
        </trans-unit>
        <trans-unit id="86874fce71a4882d328a8877cd2a4fc52a6a4fe2" translate="yes" xml:space="preserve">
          <source>Some networking library functions like gethostbyname() are known to have their own implementations of timeouts which may conflict with your timeouts. If you have problems with such functions, try using the POSIX sigaction() function, which bypasses Perl safe signals. Be warned that this does subject you to possible memory corruption, as described above.</source>
          <target state="translated">一些网络库函数,如gethostbyname(),有自己的超时实现,可能会与你的超时冲突。如果你在使用这些函数时遇到问题,可以尝试使用POSIX sigaction()函数,它可以绕过Perl的安全信号。请注意,这可能会导致内存损坏,如上所述。</target>
        </trans-unit>
        <trans-unit id="0ce6014b84ac6fe075f649ff6034ad219b7b909a" translate="yes" xml:space="preserve">
          <source>Some non-Perl implementations of the Age property may change its meaning to be the same as the Perl &lt;code&gt;Present_In&lt;/code&gt; property; just be aware of that.</source>
          <target state="translated">Age属性的某些非Perl实现可能会将其含义更改为与Perl &lt;code&gt;Present_In&lt;/code&gt; 属性相同；请注意这一点。</target>
        </trans-unit>
        <trans-unit id="020d12e0872ef168546404b52284bd6940ecd187" translate="yes" xml:space="preserve">
          <source>Some non-numeric HTML entity name, such as &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; , meaning the same thing as &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; in HTML -- i.e., a lowercase e with an acute (/-shaped) accent.</source>
          <target state="translated">一些非数字HTML实体名称，例如 &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; ，与 &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; 含义相同。在HTML中-即带有尖锐（/形）重音的小写字母e。</target>
        </trans-unit>
        <trans-unit id="d647bb86c88fea55dd1fa79cef8c74e6a775c39b" translate="yes" xml:space="preserve">
          <source>Some non-numeric HTML entity name, such as &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt;, meaning the same thing as &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; in HTML -- i.e., a lowercase e with an acute (/-shaped) accent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742d524f056fc75f1015c7da11070249cb40a21b" translate="yes" xml:space="preserve">
          <source>Some notes about ftp archives: Please use a long descriptive file name that includes the version number. Most incoming directories will not be readable/listable, i.e., you won't be able to see your file after uploading it. Remember to send your email notification message as soon as possible after uploading else your file may get deleted automatically. Allow time for the file to be processed and/or check the file has been processed before announcing its location.</source>
          <target state="translated">关于ftp档案的一些说明。请使用一个长的描述性文件名,包括版本号。大多数传入的目录将无法读取/列表,也就是说,上传后你将无法看到你的文件。记得上传后尽快发送邮件通知信息,否则你的文件可能会被自动删除。在公布文件的位置之前,请给文件处理的时间和/或检查文件是否已经处理完毕。</target>
        </trans-unit>
        <trans-unit id="7d0867bfec63bbea7b4c7184ee3d3a80f6c90eb5" translate="yes" xml:space="preserve">
          <source>Some of Test::Tester's functions return arrays of these hashes, just like Test::Builder-&amp;gt;details. That is, the hash for the first test will be array element 1 (not 0). Element 0 will not be a hash it will be a string which contains any diagnostic output that came before the first test. This should usually be empty, if it's not, it means something output diagnostics before any test results showed up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc5039f425d422cec80636f2fe25c7aa8c335808" translate="yes" xml:space="preserve">
          <source>Some of the books we've listed appear almost ancient in internet scale, but we've included those books because they still describe the current way of doing things. Not everything in Perl changes every day. Many of the beginner-level books, too, go over basic features and techniques that are still valid today. In general though, we try to limit this list to books published in the past five years.</source>
          <target state="translated">我们列出的一些书籍在互联网规模上看起来几乎是古老的,但我们将这些书籍包括在内,因为它们仍然描述了当前的做事方式。并非Perl中的所有内容每天都在变化。许多初级水平的书籍,也会介绍一些今天仍然有效的基本特性和技术。不过一般来说,我们会尽量将这个列表限制在过去五年内出版的书籍。</target>
        </trans-unit>
        <trans-unit id="ec6365cb89577ea447484ee46de59521b7dffa94" translate="yes" xml:space="preserve">
          <source>Some of the built-in functions do not act exactly as documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, and a few are not implemented at all. To avoid surprises, particularly if you have had prior exposure to Perl in other operating environments or if you intend to write code that will be portable to other environments, see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for a reasonably definitive list of these differences.</source>
          <target state="translated">一些内置函数的功能与&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;所记录的功能不完全相同，有一些根本没有实现。为避免意外，特别是如果您以前在其他操作环境中接触过Perl，或者打算编写可移植到其他环境中的代码时，请参见&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;，以获取有关这些差异的合理确定列表。</target>
        </trans-unit>
        <trans-unit id="0c8239353496c2009cfe543c3292467ce35311ef" translate="yes" xml:space="preserve">
          <source>Some of the configuration files in /etc used by the networking APIs are either missing or have the wrong names. In particular, make sure that there's either an /etc/resolv.conf or an /etc/hosts, so that gethostbyname() works, and make sure that the file /etc/proto has been renamed to /etc/protocol (NOT /etc/protocols, as used by other Unix systems). You may have to look for things like HOSTNAME and DOMAINORIGIN in the &quot;//'SYS1.TCPPARMS(TCPDATA)'&quot; PDS member in order to properly set up your /etc networking files.</source>
          <target state="translated">网络API使用的/etc中的一些配置文件要么缺失,要么名称错误。特别是,确保有一个/etc/resolv.conf或/etc/hosts,这样getshostbyname()就可以工作了,并确保文件/etc/proto已经被重命名为/etc/protocol(而不是其他Unix系统使用的/etc/protocols)。你可能需要在&quot;//'SYS1.TCPPARMS(TCPDATA)'&quot;中查找诸如HOSTNAME和DOMAINORIGIN之类的东西。PDS成员,以便正确设置你的/etc网络文件。</target>
        </trans-unit>
        <trans-unit id="1d2fcdaf6bf2b0dace2c66c8a0e3613f9f85f66f" translate="yes" xml:space="preserve">
          <source>Some of the entries in the list are marked as &quot;experimental&quot;. This means these should not generally be used. They may be removed or changed without notice. You can ask why they are experimental by sending email to &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;mailto:perl5-porters@perl.org&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b022f479803e9b4139aa894b3173d5ebd19950" translate="yes" xml:space="preserve">
          <source>Some of the examples later in &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt; use the &lt;a href=&quot;Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; module from CPAN. The reason you might choose &lt;a href=&quot;Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; over the perl built-in functions is that it works with numbers of ANY size, that it is optimized for speed on some operations, and for at least some programmers the notation might be familiar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c6dd767013c78841ab05e0e012ebcc93f26f14" translate="yes" xml:space="preserve">
          <source>Some of the examples later in &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt; use the &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; module from CPAN. The reason you might choose &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; over the perl built-in functions is that it works with numbers of ANY size, that it is optimized for speed on some operations, and for at least some programmers the notation might be familiar.</source>
          <target state="translated">&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;稍后的一些示例使用CPAN 的&lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt;模块。您可能会选择&lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Per：&lt;/a&gt;内置函数中的Bit :: Vector的原因是，它可以处理任何大小的数字，并且针对某些操作的速度进行了优化，并且至少对于某些程序员而言，这种表示法可能很熟悉。</target>
        </trans-unit>
        <trans-unit id="b1b52c56fd19edbbc0804a6b9841658fb64d4030" translate="yes" xml:space="preserve">
          <source>Some of the functionality of the debugging code can be achieved using XS modules.</source>
          <target state="translated">调试代码的部分功能可以通过XS模块来实现。</target>
        </trans-unit>
        <trans-unit id="bf0e1ecb04bb221fe8c8c990742dfa2a73f01086" translate="yes" xml:space="preserve">
          <source>Some of the functionality of the debugging code can be achieved with a non-debugging perl by using XS modules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129d9d1e78c142ea547ff6b028cde8ebd0aadf7f" translate="yes" xml:space="preserve">
          <source>Some of the functions are called with a</source>
          <target state="translated">有些函数的调用是以</target>
        </trans-unit>
        <trans-unit id="43704b45451eba3bea984abb31f94004f6ecfd41" translate="yes" xml:space="preserve">
          <source>Some of the highlights of &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;perlref&quot;&gt;perlref的&lt;/a&gt;一些亮点：</target>
        </trans-unit>
        <trans-unit id="02ba05af57929b86c26da34f7202e0310b46aa70" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from the &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; class. See &lt;a href=&quot;Net::FTP::dataconn&quot;&gt;Net::FTP::dataconn&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35b9e6be7b3bf5bc03040d536fb7da8f901aae2" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from the &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; class. See &lt;a href=&quot;ftp/dataconn&quot;&gt;Net::FTP::dataconn&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;Net::FTP&lt;/code&gt; 定义的某些方法返回一个对象，该对象将从 &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; 类派生。有关更多详细信息，请参见&lt;a href=&quot;ftp/dataconn&quot;&gt;Net :: FTP :: dataconn&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="085f62b2598cb482a6875006e876358d6d804f21" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from this class. The dataconn class itself is derived from the &lt;code&gt;IO::Socket::INET&lt;/code&gt; class, so any normal IO operations can be performed. However the following methods are defined in the dataconn class and IO should be performed using these.</source>
          <target state="translated">&lt;code&gt;Net::FTP&lt;/code&gt; 定义的一些方法返回一个将从该类派生的对象。dataconn类本身是从 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 类派生的，因此可以执行任何常规的IO操作。但是，以下方法在dataconn类中定义，并且应使用这些方法执行IO。</target>
        </trans-unit>
        <trans-unit id="fbd9bb2f70bdb8a22b7796ad4ee4aab43ab4a22a" translate="yes" xml:space="preserve">
          <source>Some of the modifiers require more explanation than given in the &lt;a href=&quot;#Overview&quot;&gt;&quot;Overview&quot;&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2754422800ffdc8654fa173c411cbbdaf9ca8a2" translate="yes" xml:space="preserve">
          <source>Some of the modules that use these libraries &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt;, &lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt;, and &lt;a href=&quot;Math::BigRat&quot;&gt;Math::BigRat&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312d5ef79ec3abd87646ed6a59f9c68ae862462d" translate="yes" xml:space="preserve">
          <source>Some of the most common mistakes:</source>
          <target state="translated">一些最常见的错误。</target>
        </trans-unit>
        <trans-unit id="5796d9bed54a4c270451442098ed19f9f0088003" translate="yes" xml:space="preserve">
          <source>Some of the most common values are &lt;code&gt;O_RDONLY&lt;/code&gt; for opening the file in read-only mode, &lt;code&gt;O_WRONLY&lt;/code&gt; for opening the file in write-only mode, and &lt;code&gt;O_RDWR&lt;/code&gt; for opening the file in read-write mode.</source>
          <target state="translated">一些最常见的值是 &lt;code&gt;O_RDONLY&lt;/code&gt; (用于以只读模式打开文件）， &lt;code&gt;O_WRONLY&lt;/code&gt; (用于以只读模式打开文件）和 &lt;code&gt;O_RDWR&lt;/code&gt; (用于以读写模式打开文件）。</target>
        </trans-unit>
        <trans-unit id="d5f4367d2cd66fe5bca2400a4df459be12cf9924" translate="yes" xml:space="preserve">
          <source>Some of the parser default template files in /samples are needed in /etc. In particular be sure that you at least copy /samples/yyparse.c to /etc before running Perl's Configure. This step ensures successful extraction of EBCDIC versions of parser files such as perly.c and perly.h. This has to be done before running Configure the first time. If you failed to do so then the easiest way to re-Configure Perl is to delete your misconfigured build root and re-extract the source from the tar ball. Then you must ensure that /etc/yyparse.c is properly in place before attempting to re-run Configure.</source>
          <target state="translated">在 /samples 中的一些解析器默认模板文件在 /etc 中是需要的。特别是在运行Perl的Configure之前,至少要将/samples/yyparse.c复制到/etc中。这一步可以确保成功提取EBCDIC版本的解析器文件,如perly.c和perly.h,这一点必须在第一次运行Configure之前完成。如果你没有做到这一点,那么重新配置Perl的最简单的方法就是删除你错误配置的构建根目录,并从tar球中重新解压源代码。然后你必须确保/etc/yyparse.c正确到位,然后再尝试重新运行Configure。</target>
        </trans-unit>
        <trans-unit id="83c0811a95d044951ce0ba50edb2e9cd1f45c8cb" translate="yes" xml:space="preserve">
          <source>Some of the reported info, such as hex addresses, is not particularly valuable. Other information would be more useful for the typical programmer, such as line-numbers, pad-slot reuses, etc.. Given this, -newlex is not a particularly good flag-name.</source>
          <target state="translated">一些报告的信息,如十六进制地址,不是特别有价值。其他的信息对于典型的程序员来说会更有用,比如行号、焊盘槽重用等等。鉴于此,-newlex并不是一个特别好的标志名。</target>
        </trans-unit>
        <trans-unit id="6116e5b7738fb6cac5aba2e6136f23c97d874e1d" translate="yes" xml:space="preserve">
          <source>Some of the standard Perl XS extensions (see &lt;a href=&quot;#HISTORY&quot;&gt;&quot;HISTORY&quot;&lt;/a&gt; are also available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2180880e97e49639996064a1f6af7e81cac534b" translate="yes" xml:space="preserve">
          <source>Some of the standard Perl libraries are included, but not all: see &lt;a href=&quot;#HISTORY&quot;&gt;&quot;HISTORY&quot;&lt;/a&gt; or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cdf99bdb0c6c762dab8d358da246b612330e8fa" translate="yes" xml:space="preserve">
          <source>Some of these are also deprecated. You can exclude these from your compiled Perl by adding this option to Configure: &lt;code&gt;-Accflags='-DNO_MATHOMS'&lt;/code&gt;</source>
          <target state="translated">其中一些也不推荐使用。您可以通过将以下选项添加到Configure中来将它们从已编译的Perl中排除： &lt;code&gt;-Accflags='-DNO_MATHOMS'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d94da1d47f6dfef189dc9a92fab735da2e9c93d7" translate="yes" xml:space="preserve">
          <source>Some of these books are available as free downloads.</source>
          <target state="translated">其中一些书籍可以免费下载。</target>
        </trans-unit>
        <trans-unit id="55b425b2a6fe515905b997d3820e2d955eabc2cf" translate="yes" xml:space="preserve">
          <source>Some of these functions also combine dynaloading semantic with the error-propagation semantic discussed above.</source>
          <target state="translated">其中一些函数还将dynaloading语义与上面讨论的错误传播语义相结合。</target>
        </trans-unit>
        <trans-unit id="7a3b090758880601b5c97fb9b694e1e73a3369bc" translate="yes" xml:space="preserve">
          <source>Some of these methods might be of interest to general users, as well as of interest to formatter-writers.</source>
          <target state="translated">这些方法中的一些方法可能会引起一般用户的兴趣,也会引起formatter编写者的兴趣。</target>
        </trans-unit>
        <trans-unit id="644a8605b72e956aa183e4a65e2c5fc19e8769dc" translate="yes" xml:space="preserve">
          <source>Some of these pseudo-modules import semantics into the current block scope (like &lt;a href=&quot;strict&quot;&gt;&lt;code&gt;strict&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;integer&quot;&gt;&lt;code&gt;integer&lt;/code&gt;&lt;/a&gt;, unlike ordinary modules, which import symbols into the current package (which are effective through the end of the file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80eb2a0ac01474685656b9eca0e98318c5698b3f" translate="yes" xml:space="preserve">
          <source>Some of these pseudo-modules import semantics into the current block scope (like &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;integer&lt;/code&gt; , unlike ordinary modules, which import symbols into the current package (which are effective through the end of the file).</source>
          <target state="translated">这些伪模块中的一些将语义导入到当前块范围中（例如 &lt;code&gt;strict&lt;/code&gt; 或 &lt;code&gt;integer&lt;/code&gt; ，与普通模块不同，普通模块将符号导入到当前包中（在文件末尾有效）。</target>
        </trans-unit>
        <trans-unit id="f69cda68e897fa9c0b4882048fc82a98372f85df" translate="yes" xml:space="preserve">
          <source>Some of these shouldn't really be called in a Perl application, and for others there are thread-safe versions of these already implemented:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc82daea8e525be9f1657205fd39cc94c0720ec" translate="yes" xml:space="preserve">
          <source>Some of these specific cases are shown as examples in other answers in this section of the perlfaq.</source>
          <target state="translated">在本节perlfaq的其他答案中,其中一些具体的情况被作为例子展示出来。</target>
        </trans-unit>
        <trans-unit id="7ac7dfacde52b03cada88bb1c11d6be2449d545b" translate="yes" xml:space="preserve">
          <source>Some of this may be confusing. Here's a handy reference to the ASCII CR and LF characters. You can print it out and stick it in your wallet.</source>
          <target state="translated">其中有些可能会让人感到困惑。这里有一个方便的ASCII CR和LF字符的参考。你可以把它打印出来,然后贴在你的钱包里。</target>
        </trans-unit>
        <trans-unit id="9436ec9fafb3dbaf8b6e8266e0c7a558118556b8" translate="yes" xml:space="preserve">
          <source>Some older Pod translators require paragraphs (including command paragraphs like &quot;=head2 Functions&quot;) to be separated by</source>
          <target state="translated">一些较老的Pod翻译要求段落(包括命令段落,如&quot;=head2 Functions&quot;)用&quot;=head2 &quot;分隔。</target>
        </trans-unit>
        <trans-unit id="530312ef21d84b684c5534cd434fe4d79ac602e0" translate="yes" xml:space="preserve">
          <source>Some older versions of Berkeley DB had problems with fixed length records using the RECNO file format. This problem has been fixed since version 1.85 of Berkeley DB.</source>
          <target state="translated">一些旧版本的Berkeley DB在使用RECNO文件格式的固定长度记录方面存在问题。这个问题从Berkeley DB的1.85版本开始已经得到了解决。</target>
        </trans-unit>
        <trans-unit id="4c2cd6192ba71ba66f15fbdbb416f6e8ad76580e" translate="yes" xml:space="preserve">
          <source>Some operating systems don't ship the CORE directory with their base perl install. To solve the problem, you likely need to install a perl development package such as perl-devel (CentOS, Fedora and other Redhat systems) or perl (Ubuntu and other Debian systems).</source>
          <target state="translated">有些操作系统在安装perl的时候,并没有将CORE目录与基本的perl安装在一起。为了解决这个问题,你可能需要安装一个perl开发包,比如perl-devel(CentOS、Fedora和其他Redhat系统)或者perl(Ubuntu和其他Debian系统)。</target>
        </trans-unit>
        <trans-unit id="a0bcdb116909bbaf782dcc8531648c8104b0144b" translate="yes" xml:space="preserve">
          <source>Some operating systems have bugs in the kernel that make setuid scripts inherently insecure. Perl gives you a number of options (described in &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) to work around such systems.</source>
          <target state="translated">某些操作系统的内核中存在错误，这些错误使setuid脚本本质上不安全。Perl为您提供了许多解决此类系统的选项（在&lt;a href=&quot;perlsec&quot;&gt;perlsec中&lt;/a&gt;进行了描述）。</target>
        </trans-unit>
        <trans-unit id="2250e1a4559063fcac9cec7cc104374f3f26f7ef" translate="yes" xml:space="preserve">
          <source>Some operating systems may perform &lt;code&gt;IO::File::new()&lt;/code&gt; or &lt;code&gt;IO::File::open()&lt;/code&gt; on a directory without errors. This behavior is not portable and not suggested for use. Using &lt;code&gt;&lt;a href=&quot;../functions/opendir&quot;&gt;opendir()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;IO::Dir&lt;/code&gt; are suggested instead.</source>
          <target state="translated">某些操作系统可以在目录上执行 &lt;code&gt;IO::File::new()&lt;/code&gt; 或 &lt;code&gt;IO::File::open()&lt;/code&gt; 而不会出错。此行为不是便携式的，不建议使用。使用 &lt;code&gt;&lt;a href=&quot;../functions/opendir&quot;&gt;opendir()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;IO::Dir&lt;/code&gt; 的建议来代替。</target>
        </trans-unit>
        <trans-unit id="69855bea0e31a33e7317d263f4ec459059c92ed3" translate="yes" xml:space="preserve">
          <source>Some operating systems may perform &lt;code&gt;IO::File::new()&lt;/code&gt; or &lt;code&gt;IO::File::open()&lt;/code&gt; on a directory without errors. This behavior is not portable and not suggested for use. Using &lt;code&gt;opendir()&lt;/code&gt; and &lt;code&gt;readdir()&lt;/code&gt; or &lt;code&gt;IO::Dir&lt;/code&gt; are suggested instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39015af4e836c35f8e25b30fad81d0e5afdfce43" translate="yes" xml:space="preserve">
          <source>Some operations may be slower for small numbers, but are significantly faster for big numbers. Other operations are now constant (O(1), like &lt;code&gt;bneg()&lt;/code&gt; , &lt;code&gt;babs()&lt;/code&gt; etc), instead of O(N) and thus nearly always take much less time. These optimizations were done on purpose.</source>
          <target state="translated">对于较小的数字，某些操作可能会比较慢，但是对于较大的数字，某些操作会明显更快。现在其他操作都是常量（O（1），例如 &lt;code&gt;bneg()&lt;/code&gt; ， &lt;code&gt;babs()&lt;/code&gt; 等），而不是O（N），因此几乎总是花费更少的时间。这些优化是有目的的。</target>
        </trans-unit>
        <trans-unit id="34443f21f05a44f91512261ff33473bdb84f64b0" translate="yes" xml:space="preserve">
          <source>Some operations may be slower for small numbers, but are significantly faster for big numbers. Other operations are now constant (O(1), like &lt;code&gt;bneg()&lt;/code&gt;, &lt;code&gt;babs()&lt;/code&gt; etc), instead of O(N) and thus nearly always take much less time. These optimizations were done on purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9f3e95144e8b33a9458895d77a0f239683f515" translate="yes" xml:space="preserve">
          <source>Some operators are instead non-associative, meaning that it is a syntax error to use a sequence of those operators of the same precedence. For example, &lt;code&gt;&quot;$x .. $y .. $z&quot;&lt;/code&gt; is an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62110d88a0d086d7fc7d0ffc86ee7f8031edd34d" translate="yes" xml:space="preserve">
          <source>Some options, in particular &lt;code&gt;-I&lt;/code&gt;, &lt;code&gt;-M&lt;/code&gt;, &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERL5OPT&lt;/code&gt; can interact, and the order in which they are applied is important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03ecacb543bf1cb170543843116f3f4c7e881ad8" translate="yes" xml:space="preserve">
          <source>Some other (not completely debugged) situations when FP flags change include some video drivers (?), and some operations related to creation of the windows. People who code &lt;b&gt;OpenGL&lt;/b&gt; may have more experience on this.</source>
          <target state="translated">FP标志更改时，其他一些情况（尚未完全调试）包括一些视频驱动程序（？），以及与创建窗口有关的某些操作。编写&lt;b&gt;OpenGL的人&lt;/b&gt;可能对此有更多的经验。</target>
        </trans-unit>
        <trans-unit id="377fbf88a15d635b8d6d486abdf4ac17224b10a7" translate="yes" xml:space="preserve">
          <source>Some other IO modules don't belong to the perl core but can be loaded as well if they have been installed from CPAN. You can discover which ones exist by searching for &quot;^IO::&quot; on &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt;.</source>
          <target state="translated">其他一些IO模块不属于perl内核，但如果已从CPAN安装，则也可以加载。您可以通过在&lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt;上搜索&amp;ldquo; ^ IO ::&amp;rdquo;来发现存在的那些。</target>
        </trans-unit>
        <trans-unit id="2d0a736269bfee7b88f6f3d6b373b941a1d11276" translate="yes" xml:space="preserve">
          <source>Some other values are treated specially for internal use and should not be depended on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7424cd4ab88fb33b2270b2db7bbe8e04cad5739e" translate="yes" xml:space="preserve">
          <source>Some output formats that do allow rendering &quot;L&amp;lt;...&amp;gt;&quot; codes as hypertext, might not allow the link-text to be formatted; in that case, formatters will have to just ignore that formatting.</source>
          <target state="translated">某些确实允许将&amp;ldquo; L &amp;lt;...&amp;gt;&amp;rdquo;代码呈现为超文本的输出格式，可能不允许对链接文本进行格式化。在这种情况下，格式化者将不得不忽略该格式化。</target>
        </trans-unit>
        <trans-unit id="256ae5437abb579a53a890ac8a995ac8070fd714" translate="yes" xml:space="preserve">
          <source>Some particular limitations of note include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7659015df8ed2f8e8d7c6aab66109d4919b25a40" translate="yes" xml:space="preserve">
          <source>Some particular sequences of characters are given a single name, in addition to their individual ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a79a974eeb026992ad7b1bb5fab50968d6932c" translate="yes" xml:space="preserve">
          <source>Some passes discussed below are performed concurrently, but because their results are the same, we consider them individually. For different quoting constructs, Perl performs different numbers of passes, from one to four, but these passes are always performed in the same order.</source>
          <target state="translated">下面讨论的一些传递是同时进行的,但因为它们的结果是一样的,所以我们单独考虑它们。对于不同的引号结构,Perl 会执行不同数量的传递,从一个到四个,但这些传递总是以相同的顺序进行。</target>
        </trans-unit>
        <trans-unit id="7ae8fed66b51985370778e2e29c81e03a37d1f13" translate="yes" xml:space="preserve">
          <source>Some people get too used to writing things like:</source>
          <target state="translated">有些人太习惯于写这样的东西。</target>
        </trans-unit>
        <trans-unit id="970ff42e05d0088fd549cac2a995425a1e1eba68" translate="yes" xml:space="preserve">
          <source>Some people have reported encountering &quot;Out of memory!&quot; errors while trying to build Perl using GNU make binaries. If you encounter such trouble then try to download the source code kit and build GNU make from source to eliminate any such trouble. You might also find GNU make (as well as Perl and Apache) in the red-piece/book &quot;Open Source Software for OS/390 UNIX&quot;, SG24-5944-00 from IBM.</source>
          <target state="translated">有些人报告说,在使用 GNU make 二进制文件构建 Perl 时遇到了 &quot;Out of memory!&quot;错误。如果您遇到这样的问题,请尝试下载源代码包,并从源代码中构建GNU make,以消除此类问题。你也可以在IBM的红片/书 &quot;OS/390 UNIX的开源软件 &quot;SG24-5944-00中找到GNU make(以及Perl和Apache)。</target>
        </trans-unit>
        <trans-unit id="98c7c01703d39bcc6345fdf8d617292db8f23d37" translate="yes" xml:space="preserve">
          <source>Some people may be inclined to include an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in the above XSUB, rather than letting control fall through to the end. In those situations &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; should be used, instead. This will ensure that the XSUB stack is properly adjusted. Consult &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for other &lt;code&gt;XSRETURN&lt;/code&gt; macros.</source>
          <target state="translated">有些人可能倾向于在上述XSUB中包含一个显式的 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; ，而不是让控制权落到最后。在这些情况下，应改用 &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; 。这将确保正确调整XSUB堆栈。有关其他 &lt;code&gt;XSRETURN&lt;/code&gt; 宏，请咨询&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6b8960b846f5085f978f5b96b85b0906849df57" translate="yes" xml:space="preserve">
          <source>Some people may be inclined to include an explicit &lt;code&gt;return&lt;/code&gt; in the above XSUB, rather than letting control fall through to the end. In those situations &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; should be used, instead. This will ensure that the XSUB stack is properly adjusted. Consult &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for other &lt;code&gt;XSRETURN&lt;/code&gt; macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b055a6a001cadf9ec7b3e638f2bc15cb8ed85e4" translate="yes" xml:space="preserve">
          <source>Some people may wish to outlaw barewords entirely. If you say</source>
          <target state="translated">有些人可能希望完全取缔裸辞。如果你说</target>
        </trans-unit>
        <trans-unit id="bae38a7d38c5d89eb67db6e4b702e604142997e5" translate="yes" xml:space="preserve">
          <source>Some people mistakenly regard this as a security problem. If your program does insecure things, and relies on people not knowing how to exploit those insecurities, it is not secure. It is often possible for someone to determine the insecure things and exploit them without viewing the source. Security through obscurity, the name for hiding your bugs instead of fixing them, is little security indeed.</source>
          <target state="translated">有些人误认为这是一个安全问题。如果你的程序做了不安全的事情,并且依靠人们不知道如何利用这些不安全因素,那么它就是不安全的。往往有人可以在不查看源码的情况下确定不安全的东西并加以利用。通过隐蔽来保证安全,美其名曰隐藏你的bug,而不是修复它们,这确实是小安全。</target>
        </trans-unit>
        <trans-unit id="df10001a5e994bd1a3232bcb5d3f173424f0cd78" translate="yes" xml:space="preserve">
          <source>Some people need this and some people avoid it. For Perl, it&amp;rsquo;s an old way to say &lt;b&gt;I/O layer&lt;/b&gt;.</source>
          <target state="translated">有些人需要这个，有些人避免它。对于Perl，这是说&lt;b&gt;I / O层&lt;/b&gt;的一种古老方法。</target>
        </trans-unit>
        <trans-unit id="37ecbcdb1f8127ee6539d97d23e8c04d2e848681" translate="yes" xml:space="preserve">
          <source>Some people regard this as a security problem. If your program does insecure things and relies on people not knowing how to exploit those insecurities, it is not secure. It is often possible for someone to determine the insecure things and exploit them without viewing the source. Security through obscurity, the name for hiding your bugs instead of fixing them, is little security indeed.</source>
          <target state="translated">有些人认为这是一个安全问题。如果你的程序做了不安全的事情,并且依靠人们不知道如何利用这些不安全因素,那么它就是不安全的。往往有人可以在不查看源码的情况下确定不安全的东西并加以利用。通过隐蔽来保证安全,美其名曰隐藏你的bug而不是修复它们,这确实是小安全。</target>
        </trans-unit>
        <trans-unit id="646207c2365abd1daf6b5c56b0451ba2ee5e82de" translate="yes" xml:space="preserve">
          <source>Some platforms (Win32, AIX, VMS, OS/2, to name a few) require any function that is part of the public API (the shared Perl library) to be explicitly marked as exported. See the discussion about</source>
          <target state="translated">一些平台(Win32、AIX、VMS、OS/2等)要求任何属于公共API(共享的Perl库)的函数都要明确标记为导出。参见关于</target>
        </trans-unit>
        <trans-unit id="f71f7e49e6244b0a28baf7e54c8479e2d307382e" translate="yes" xml:space="preserve">
          <source>Some platforms can't delete or rename files held open by the system, this limitation may also apply to changing filesystem metainformation like file permissions or owners. Remember to &lt;a href=&quot;perlfunc#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; files when you are done with them. Don't &lt;a href=&quot;perlfunc#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#rename-OLDNAME%2CNEWNAME&quot;&gt;&lt;code&gt;rename&lt;/code&gt;&lt;/a&gt; an open file. Don't &lt;a href=&quot;perlfunc#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;&lt;code&gt;tie&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; a file already tied or opened; &lt;a href=&quot;perlfunc#untie-VARIABLE&quot;&gt;&lt;code&gt;untie&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; it first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e0751f43cf70fa1b809101e7e4735cf3d63955" translate="yes" xml:space="preserve">
          <source>Some platforms can't delete or rename files held open by the system, this limitation may also apply to changing filesystem metainformation like file permissions or owners. Remember to &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; files when you are done with them. Don't &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;&lt;/code&gt; an open file. Don't &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; a file already tied or opened; &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; it first.</source>
          <target state="translated">某些平台无法删除或重命名系统打开的文件，此限制也可能适用于更改文件系统元信息，例如文件权限或所有者。完成操作后，请记住 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 文件。不要 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;&lt;/code&gt; 打开的文件。不要 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 已经打结或打开的文件； &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 它。</target>
        </trans-unit>
        <trans-unit id="da26b78199e00ef73fdfb4bbe53a1032367ab8a7" translate="yes" xml:space="preserve">
          <source>Some platforms have a minimum thread stack size. Trying to set the stack size below this value will result in a warning, and the minimum stack size will be used.</source>
          <target state="translated">有些平台有最小线程堆栈大小。试图将堆栈大小设置为低于这个值会导致一个警告,并且会使用最小堆栈大小。</target>
        </trans-unit>
        <trans-unit id="bcf43713051466cf97d586bae0917d51d61ca30f" translate="yes" xml:space="preserve">
          <source>Some platforms have a minimum thread stack size. Trying to set the stack size below this value will result in the above warning, and the stack size will be set to the minimum.</source>
          <target state="translated">有些平台有一个最小线程堆栈大小。试图将堆栈大小设置为低于这个值,将导致上述警告,并且堆栈大小将被设置为最小值。</target>
        </trans-unit>
        <trans-unit id="5105a7088de9859cd20060f09ecf9b0528ad1069" translate="yes" xml:space="preserve">
          <source>Some platforms have other categories, dealing with such things as measurement units and paper sizes. None of these are used directly by Perl, but outside operations that Perl interacts with may use these. See &lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;&quot;Not within the scope of &quot;use locale&quot;&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a11c8787b6044982e680d4ae9bfff407819b6d1c" translate="yes" xml:space="preserve">
          <source>Some platforms have other categories, dealing with such things as measurement units and paper sizes. None of these are used directly by Perl, but outside operations that Perl interacts with may use these. See &lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;Not within the scope of use locale&lt;/a&gt; below.</source>
          <target state="translated">某些平台还有其他类别，涉及度量单位和纸张尺寸。这些都没有被Perl直接使用，但是与Perl交互的外部操作可能会使用它们。请参阅下面的&lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;不在使用区域设置范围内&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27d67098e269de48eafdad3480b3920c43ba2cb7" translate="yes" xml:space="preserve">
          <source>Some points to note:</source>
          <target state="translated">需要注意的几点:</target>
        </trans-unit>
        <trans-unit id="4d3653fc867e65c669e5c29b359dbebb9253c5c0" translate="yes" xml:space="preserve">
          <source>Some possible reasons: your inheritance is getting confused, you've misspelled the method name, or the object is of the wrong type. Check out &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for details about any of the above cases. You may also use &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;($object)&lt;/code&gt; to find out the class &lt;code&gt;$object&lt;/code&gt; was blessed into.</source>
          <target state="translated">可能的原因：继承变得混乱，方法名称拼写错误或对象的类型错误。请查看&lt;a href=&quot;perlootut&quot;&gt;perlootut，&lt;/a&gt;以获取有关上述任何情况的详细信息。您也可以使用 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;($object)&lt;/code&gt; 来找出 &lt;code&gt;$object&lt;/code&gt; 被祝福的类。</target>
        </trans-unit>
        <trans-unit id="290c6b9cea94cfe13fbb802d97a5a0cd78346837" translate="yes" xml:space="preserve">
          <source>Some possible reasons: your inheritance is getting confused, you've misspelled the method name, or the object is of the wrong type. Check out &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for details about any of the above cases. You may also use &lt;code&gt;print ref($object)&lt;/code&gt; to find out the class &lt;code&gt;$object&lt;/code&gt; was blessed into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b61ffed7b1a69179adefb6f5756bdb1cb79574b" translate="yes" xml:space="preserve">
          <source>Some pragmas are lexically scoped--typically those that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable. Others affect the current package instead, like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; , which allow you to predeclare a variables or subroutines within a particular</source>
          <target state="translated">一些编译指示在词法上是作用域的-通常是那些影响 &lt;code&gt;$^H&lt;/code&gt; 提示变量的编译指示。其他会影响当前程序包，例如 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; ，它们允许您在特定程序中预先声明变量或子例程。</target>
        </trans-unit>
        <trans-unit id="7d87d5053d095f39938496538e49008745b231d2" translate="yes" xml:space="preserve">
          <source>Some pragmas are lexically scoped--typically those that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable. Others affect the current package instead, like &lt;code&gt;use vars&lt;/code&gt; and &lt;code&gt;use subs&lt;/code&gt;, which allow you to predeclare a variables or subroutines within a particular</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca977f551e014badc60a278bfe97ad872b1a03f5" translate="yes" xml:space="preserve">
          <source>Some problem (forget which ;-)</source>
          <target state="translated">一些问题(忘了是哪一个;-)</target>
        </trans-unit>
        <trans-unit id="747d0cb3f2eb2365d2dd72ee766a74de28620e7d" translate="yes" xml:space="preserve">
          <source>Some problems are associated with using temporary files that reside on NFS file systems and it is recommended that a local filesystem is used whenever possible. Some of the security tests will most probably fail when the temp file is not local. Additionally, be aware that the performance of I/O operations over NFS will not be as good as for a local disk.</source>
          <target state="translated">使用驻留在NFS文件系统上的临时文件会出现一些问题,建议尽可能使用本地文件系统。当临时文件不是本地文件时,一些安全测试很可能会失败。此外,要注意通过NFS进行的I/O操作的性能不会像本地磁盘那样好。</target>
        </trans-unit>
        <trans-unit id="82690c6e6b8e4e473e3f2745d7358e432662fc95" translate="yes" xml:space="preserve">
          <source>Some processors may find that the &lt;code&gt;S&amp;lt;...&amp;gt;&lt;/code&gt; code is easiest to implement by replacing each space in the parse tree under the content of the S, with an NBSP. But note: the replacement should apply</source>
          <target state="translated">一些处理器可能会发现，通过使用NBSP替换S内容下的解析树中的每个空间，最容易实现 &lt;code&gt;S&amp;lt;...&amp;gt;&lt;/code&gt; 代码。但请注意：更换应适用</target>
        </trans-unit>
        <trans-unit id="229ed6abc320881bbd15c4ddf8619bff82e22293" translate="yes" xml:space="preserve">
          <source>Some programmers choose to use an explicit conversion so as to leave nothing to doubt:</source>
          <target state="translated">有些程序员选择使用显式转换,这样就不会有任何疑问。</target>
        </trans-unit>
        <trans-unit id="76cff92347a8a5dd33b0b88b52afc87676bbe1d1" translate="yes" xml:space="preserve">
          <source>Some programmers may prefer to think of filehandles as objects with methods, preferring to write the last example as:</source>
          <target state="translated">有些程序员可能更喜欢把filehandles看作是带有方法的对象,喜欢把最后一个例子写成。</target>
        </trans-unit>
        <trans-unit id="9293db7d23e9765c2433258535b9e48d3fd5d563" translate="yes" xml:space="preserve">
          <source>Some properties are considered obsolete by Unicode, but still available. There are several varieties of obsolescence:</source>
          <target state="translated">有些属性被Unicode认为是过时的,但仍可使用。过时有几种品种。</target>
        </trans-unit>
        <trans-unit id="8e185e2d007b85b8d377436c39a0c68b4b4f4ab1" translate="yes" xml:space="preserve">
          <source>Some rare applications will need to create more than one interpreter during a session. Such an application might sporadically decide to release any resources associated with the interpreter.</source>
          <target state="translated">一些罕见的应用程序将需要在一个会话期间创建多个解释器。这样的应用程序可能会零星地决定释放与解释器相关的任何资源。</target>
        </trans-unit>
        <trans-unit id="0314a7222da4e53e09e85e4d4942b044d7cacfc9" translate="yes" xml:space="preserve">
          <source>Some regular expressions use identical subpatterns in several places. Starting with Perl 5.10, it is possible to define named subpatterns in a section of the pattern so that they can be called up by name anywhere in the pattern. This syntactic pattern for this definition group is &lt;code&gt;(?(DEFINE)(?&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;i&gt;pattern&lt;/i&gt;)...)&lt;/code&gt;. An insertion of a named pattern is written as &lt;code&gt;(?&amp;amp;&lt;i&gt;name&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5ce3e6e9260f74f3afe8318024d986a7fd16de" translate="yes" xml:space="preserve">
          <source>Some regular expressions use identical subpatterns in several places. Starting with Perl 5.10, it is possible to define named subpatterns in a section of the pattern so that they can be called up by name anywhere in the pattern. This syntactic pattern for this definition group is &lt;code&gt;(?(DEFINE)(?&amp;lt;name&amp;gt;pattern)...)&lt;/code&gt;. An insertion of a named pattern is written as &lt;code&gt;(?&amp;amp;name)&lt;/code&gt;.</source>
          <target state="translated">一些正则表达式在多个地方使用相同的子模式。从Perl 5.10开始，可以在模式的一部分中定义命名子模式，以便可以在模式中的任何位置按名称调用它们。此定义组的语法模式为 &lt;code&gt;(?(DEFINE)(?&amp;lt;name&amp;gt;pattern)...)&lt;/code&gt; 。命名模式的插入被写为 &lt;code&gt;(?&amp;amp;name)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58899e8b736f7c4726449bcec0f3b25df5fc7632" translate="yes" xml:space="preserve">
          <source>Some routines (&lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; ) return true or false, while others (&lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) return either undef, &amp;lt;0, 0 or &amp;gt;0 and are suited for sort.</source>
          <target state="translated">一些例程（ &lt;code&gt;is_odd()&lt;/code&gt; ， &lt;code&gt;is_even()&lt;/code&gt; ， &lt;code&gt;is_zero()&lt;/code&gt; ， &lt;code&gt;is_one()&lt;/code&gt; ， &lt;code&gt;is_nan()&lt;/code&gt; ）返回true或false，而另一些 &lt;code&gt;bcmp()&lt;/code&gt; ， &lt;code&gt;bacmp()&lt;/code&gt; ）返回undef，&amp;lt;0、0或&amp;gt; 0并且适合排序。</target>
        </trans-unit>
        <trans-unit id="834cc437cec84afae22c004e80ee3d6149cb6f55" translate="yes" xml:space="preserve">
          <source>Some routines (&lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; , etc.) return true or false, while others (&lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) return either undef (if NaN is involved), &amp;lt;0, 0 or &amp;gt;0 and are suited for sort.</source>
          <target state="translated">一些例程（ &lt;code&gt;is_odd()&lt;/code&gt; ， &lt;code&gt;is_even()&lt;/code&gt; ， &lt;code&gt;is_zero()&lt;/code&gt; ， &lt;code&gt;is_one()&lt;/code&gt; ， &lt;code&gt;is_nan()&lt;/code&gt; 等）返回true或false，而其他 &lt;code&gt;bcmp()&lt;/code&gt; ， &lt;code&gt;bacmp()&lt;/code&gt; ）返回undef（如果涉及到NaN） ），&amp;lt;0、0或&amp;gt; 0，适合排序。</target>
        </trans-unit>
        <trans-unit id="b07ef2379b9c2b49ab7fe4b04878c3104f0be76f" translate="yes" xml:space="preserve">
          <source>Some scalar variables contain more than one type of scalar data. For example, the variable &lt;code&gt;$!&lt;/code&gt; contains either the numeric value of &lt;code&gt;errno&lt;/code&gt; or its string equivalent from either &lt;code&gt;strerror&lt;/code&gt; or &lt;code&gt;sys_errlist[]&lt;/code&gt; .</source>
          <target state="translated">一些标量变量包含不止一种类型的标量数据。例如，变量 &lt;code&gt;$!&lt;/code&gt; 包含 &lt;code&gt;errno&lt;/code&gt; 的数值或 &lt;code&gt;strerror&lt;/code&gt; 或 &lt;code&gt;sys_errlist[]&lt;/code&gt; 等效字符串。</target>
        </trans-unit>
        <trans-unit id="293877a0e77da8a8b9fbcbcd030c4833f67c96da" translate="yes" xml:space="preserve">
          <source>Some scalar variables contain more than one type of scalar data. For example, the variable &lt;code&gt;$!&lt;/code&gt; contains either the numeric value of &lt;code&gt;errno&lt;/code&gt; or its string equivalent from either &lt;code&gt;strerror&lt;/code&gt; or &lt;code&gt;sys_errlist[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b802bf6a4f1848df9acbe46a4e2a4fe02ad51578" translate="yes" xml:space="preserve">
          <source>Some scripts, usually identified with a *.PL extension, are self-configuring and are able to correctly create their own shebang path from config information located in Plan 9 Perl. These you won't need to be worried about.</source>
          <target state="translated">有些脚本,通常用*.PL扩展名来标识,它们是自配置的,能够根据Plan 9 Perl中的配置信息正确创建自己的shebang路径。这些你就不需要担心了。</target>
        </trans-unit>
        <trans-unit id="0de1611bc5300339bfc467a34c6fb8f9747fd7ed" translate="yes" xml:space="preserve">
          <source>Some servers are configured to only work in passive mode. If you have one of these you can force &lt;code&gt;Net::FTP&lt;/code&gt; to always transfer in passive mode; when not going via a firewall, by setting &lt;code&gt;ftp_int_passive&lt;/code&gt; to a</source>
          <target state="translated">某些服务器配置为仅在被动模式下工作。如果您具有其中之一，则可以强制 &lt;code&gt;Net::FTP&lt;/code&gt; 始终以被动模式进行传输；当不通过防火墙时，通过将 &lt;code&gt;ftp_int_passive&lt;/code&gt; 设置为</target>
        </trans-unit>
        <trans-unit id="ebc3655c5b01cc226f09d2ace7c8e5f430f35ebd" translate="yes" xml:space="preserve">
          <source>Some servers do not understand this command, but issuing it and ignoring the response is harmless.</source>
          <target state="translated">有些服务器不理解这个命令,但发出这个命令并忽略响应是无害的。</target>
        </trans-unit>
        <trans-unit id="c3d7fb888727f4ae5ed3bb068213cd5f194d2bf2" translate="yes" xml:space="preserve">
          <source>Some signals can be neither trapped nor ignored, such as the KILL and STOP (but not the TSTP) signals. Note that ignoring signals makes them disappear. If you only want them blocked temporarily without them getting lost you'll have to use POSIX' sigprocmask.</source>
          <target state="translated">有些信号既不能被捕获,也不能被忽略,比如KILL和STOP(但不是TSTP)信号。注意,忽略信号会使它们消失。如果你只想让它们暂时被屏蔽而不丢失,你就必须使用POSIX的sigprocmask。</target>
        </trans-unit>
        <trans-unit id="2b6d2a03109d9cfeb6b788931c3af13636a6e9ce" translate="yes" xml:space="preserve">
          <source>Some signals can be neither trapped nor ignored, such as the KILL and STOP (but not the TSTP) signals. Note that ignoring signals makes them disappear. If you only want them blocked temporarily without them getting lost you'll have to use the &lt;code&gt;POSIX&lt;/code&gt; module's &lt;a href=&quot;posix#sigprocmask&quot;&gt;sigprocmask&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bcba60d06f3c08a852e1ccedb100d4bd2f6af23" translate="yes" xml:space="preserve">
          <source>Some simple style guidelines</source>
          <target state="translated">一些简单的风格准则</target>
        </trans-unit>
        <trans-unit id="0a3063c3a46746b861b03ccbf2777db3ca544d44" translate="yes" xml:space="preserve">
          <source>Some simple tricks for determining if you are running on an EBCDIC platform could include any of the following (perhaps all):</source>
          <target state="translated">一些简单的技巧来确定你是否在EBCDIC平台上运行,可以包括以下任何一种(也许是全部)。</target>
        </trans-unit>
        <trans-unit id="3f3c0a1f0f425bdd141982a9f345d9ad53284159" translate="yes" xml:space="preserve">
          <source>Some source filters use the &lt;code&gt;DATA&lt;/code&gt; handle to read the calling program. When using these source filters you cannot rely on this handle, nor expect any particular kind of behavior when operating on it. Filters based on Filter::Util::Call (and therefore Filter::Simple) do not alter the &lt;code&gt;DATA&lt;/code&gt; filehandle, but on the other hand totally ignore the text after &lt;code&gt;__DATA__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="038ab8e08e45dcac2b1a2ba44edc5e7ade978952" translate="yes" xml:space="preserve">
          <source>Some source filters use the &lt;code&gt;DATA&lt;/code&gt; handle to read the calling program. When using these source filters you cannot rely on this handle, nor expect any particular kind of behavior when operating on it. Filters based on Filter::Util::Call (and therefore Filter::Simple) do not alter the &lt;code&gt;DATA&lt;/code&gt; filehandle.</source>
          <target state="translated">一些源过滤器使用 &lt;code&gt;DATA&lt;/code&gt; 句柄来读取调用程序。使用这些源过滤器时，您不能依赖此句柄，也不能期望对其进行任何特定类型的行为。基于Filter :: Util :: Call的过滤器（以及因此Filter :: Simple）不会更改 &lt;code&gt;DATA&lt;/code&gt; 文件句柄。</target>
        </trans-unit>
        <trans-unit id="b1b44415edca47e18840114c042b3fbafad7d31e" translate="yes" xml:space="preserve">
          <source>Some special cases like a trailing 0x00 byte or a lone 0x1B byte are not well-defined and decode() will return an empty string for them. One possible workaround is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887e76ddfe1351446ffd243bda2aac92d02dd5a3" translate="yes" xml:space="preserve">
          <source>Some subclasses that indiscriminately dump event attributes (well, except for ones beginning with &quot;~&quot;) can use this object attribute for refraining to dump the &quot;start_line&quot; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0397fafffa0394e8352d14b65804f0f4b7e0e7f0" translate="yes" xml:space="preserve">
          <source>Some switches do care if they are processed twice, for instance combinations of &lt;a href=&quot;#-l%5Boctnum%5D&quot;&gt;-l&lt;/a&gt; and &lt;a href=&quot;#-0%5Boctal%2Fhexadecimal%5D&quot;&gt;-0&lt;/a&gt;. Either put all the switches after the 32-character boundary (if applicable), or replace the use of &lt;b&gt;-0&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3ebd295e43b2c81df8bd4b9c3baef266ee5f66" translate="yes" xml:space="preserve">
          <source>Some switches do care if they are processed twice, for instance combinations of &lt;b&gt;-l&lt;/b&gt; and &lt;b&gt;-0&lt;/b&gt;. Either put all the switches after the 32-character boundary (if applicable), or replace the use of &lt;b&gt;-0&lt;/b&gt;</source>
          <target state="translated">一些开关确实关心它们是否被处理了两次，例如&lt;b&gt;-l&lt;/b&gt;和&lt;b&gt;-0的&lt;/b&gt;组合。将所有开关置于32个字符的边界之后（如果适用），或替换为&lt;b&gt;-0&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="109f18c999c7939dc43da5678ce045bdc21c20e9" translate="yes" xml:space="preserve">
          <source>Some systems define &lt;a href=&quot;#pipe-READHANDLE%2CWRITEHANDLE&quot;&gt;&lt;code&gt;pipe&lt;/code&gt;&lt;/a&gt; in terms of &lt;a href=&quot;#socketpair-SOCKET1%2CSOCKET2%2CDOMAIN%2CTYPE%2CPROTOCOL&quot;&gt;&lt;code&gt;socketpair&lt;/code&gt;&lt;/a&gt;, in which a call to &lt;code&gt;pipe($rdr, $wtr)&lt;/code&gt; is essentially:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c346e3627bcf4ba52fad903600add2510035afb4" translate="yes" xml:space="preserve">
          <source>Some systems defined &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; in terms of &lt;code&gt;&lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt;, in which a call to &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; is essentially:</source>
          <target state="translated">一些系统根据 &lt;code&gt;&lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; 定义 &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; ，其中对 &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; 的调用（Rdr，Wtr）本质上是：</target>
        </trans-unit>
        <trans-unit id="6fc6b04b810684b6c41fe63810499cab8b09c739" translate="yes" xml:space="preserve">
          <source>Some systems defined &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; in terms of &lt;code&gt;&lt;a href=&quot;socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt;, in which a call to &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; is essentially:</source>
          <target state="translated">一些系统根据 &lt;code&gt;&lt;a href=&quot;socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; 定义 &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; ，其中对 &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; 的调用（Rdr，Wtr）本质上是：</target>
        </trans-unit>
        <trans-unit id="ec2cddcb7714cb3145808dbf1959d4cf532d708d" translate="yes" xml:space="preserve">
          <source>Some systems have APIs but not implementations: for example QNX and Haiku have the interval timer APIs but not the functionality.</source>
          <target state="translated">有些系统有应用程序接口,但没有实现:例如 QNX 和 Haiku 有间隔定时器应用程序接口,但没有功能。</target>
        </trans-unit>
        <trans-unit id="af9e4e7dc8e2d766a51ba5d183c159f4967112d1" translate="yes" xml:space="preserve">
          <source>Some systems have thread-safe versions of some of the functions, such as &lt;code&gt;getpwnam_r()&lt;/code&gt; instead of &lt;code&gt;getpwnam()&lt;/code&gt;. There, Perl automatically and invisibly substitutes the thread-safe version, without notice. This means that code that safely runs on some systems can fail on others that lack the thread-safe versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1b5dcc57517fdbe334dfa953d44b8287e96b48c" translate="yes" xml:space="preserve">
          <source>Some systems may have even weirder byte orders such as</source>
          <target state="translated">有些系统可能有更奇怪的字节顺序,如</target>
        </trans-unit>
        <trans-unit id="6223cb44b81823af78522ece7689e7171de5236a" translate="yes" xml:space="preserve">
          <source>Some systems use CONFORMING TO to note conformance to relevant standards and MT-LEVEL to note safeness for use in threaded programs or signal handlers. These headings are primarily useful when documenting parts of a C library.</source>
          <target state="translated">有些系统使用CONFORMING TO来说明是否符合相关标准,使用MT-LEVEL来说明在线程或信号处理程序中使用的安全性。这些标题主要在记录C库的部分内容时有用。</target>
        </trans-unit>
        <trans-unit id="b5f78f639815d7596cee6bf607be57c18273af36" translate="yes" xml:space="preserve">
          <source>Some test failures may occur if you use a command shell other than the native &quot;cmd.exe&quot;, or if you are building from a path that contains spaces. So don't do that.</source>
          <target state="translated">如果你使用非本地 &quot;cmd.exe &quot;的命令壳,或者你从包含空格的路径构建,可能会出现一些测试失败。所以不要这样做。</target>
        </trans-unit>
        <trans-unit id="db2f4892c2d72b4b87094017ed92e99d93095f9c" translate="yes" xml:space="preserve">
          <source>Some test modules would replace the Test::Builder singleton instance with their own instance or subclass. This was usually done to intercept or modify results as they happened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec70ba84fc671de1bea2095d64f0ecee13115e62" translate="yes" xml:space="preserve">
          <source>Some tests are known to fail:</source>
          <target state="translated">众所周知,有些测试是会失败的。</target>
        </trans-unit>
        <trans-unit id="6a89cc5c4b8e960cca98e5c9aef6613a37510494" translate="yes" xml:space="preserve">
          <source>Some tests depended on &lt;code&gt;$!&lt;/code&gt; and &lt;code&gt;$?&lt;/code&gt; being modified in subtle ways. A patch was applied to correct things that changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d98556687379d0793051b330180895e416a427" translate="yes" xml:space="preserve">
          <source>Some tests may complain under known circumstances.</source>
          <target state="translated">在已知的情况下,一些测试可能会抱怨。</target>
        </trans-unit>
        <trans-unit id="c1340d9e04d7bf928c677a3bd6e8e8121f7021a3" translate="yes" xml:space="preserve">
          <source>Some tests may generate extra messages similar to</source>
          <target state="translated">一些测试可能会产生类似于</target>
        </trans-unit>
        <trans-unit id="ed680f9db7c37de4a3fb02472a48fb5b299c3b28" translate="yes" xml:space="preserve">
          <source>Some tests were fragile and required base.pm to be loaded at a late stage. Test2 was loading base.pm too early. The tests were updated to fix this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3e7fb048dd3da6c3efee2236b9f7245e42c776" translate="yes" xml:space="preserve">
          <source>Some tests were fragile, but have been fixed. The actual breakage was from the subtest comment indentation change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c36c454152688ffa8f0d5944c5eae241cf584a" translate="yes" xml:space="preserve">
          <source>Some tests will be skipped because they need the fork() function:</source>
          <target state="translated">有些测试会被跳过,因为它们需要fork()函数。</target>
        </trans-unit>
        <trans-unit id="ae4dfb05b376af0b4aa8499ceeb5ad1587cfc612" translate="yes" xml:space="preserve">
          <source>Some things might not work as you expect them. Below is documented what is known to be troublesome:</source>
          <target state="translated">有些事情可能无法按照你的预期进行。下面记录的是已知的麻烦。</target>
        </trans-unit>
        <trans-unit id="c22086010db6828bca64b97b121f052c5aaeaeec" translate="yes" xml:space="preserve">
          <source>Some time ago I had reports it does not work. Nowadays it is checked in the Perl test suite, so grep</source>
          <target state="translated">前段时间,我有报道说它不工作。现在在Perl测试套件中已经检查过了,所以grep</target>
        </trans-unit>
        <trans-unit id="ff04f69dfe09fd05da827bf89d221c2f8cd81859" translate="yes" xml:space="preserve">
          <source>Some tools did do a good job setting these to the correct hub, but you cannot always rely on that. Use the 'hubs' facet list instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d4257cf6ff6a8e43bd3c5319c1718bd7fb9ab6" translate="yes" xml:space="preserve">
          <source>Some type of removable media other than a floppy diskette.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729fe9bb5c1721be7b9c47b47d38d0043a1d5be9" translate="yes" xml:space="preserve">
          <source>Some types of lvalues can be localized as well: hash and array elements and slices, conditionals (provided that their result is always localizable), and symbolic references. As for simple variables, this creates new, dynamically scoped values.</source>
          <target state="translated">一些类型的lvalues也可以被本地化:哈希和数组元素和切片,条件(只要它们的结果总是可本地化的),以及符号引用。至于简单变量,这将创建新的、动态范围的值。</target>
        </trans-unit>
        <trans-unit id="36c279e82d37aef763f2dc425df33d302f2edc2c" translate="yes" xml:space="preserve">
          <source>Some unusual systems, such as VMS, require special filename handling in order to deal with symbolic names for files (i.e., VMS's Logical Names).</source>
          <target state="translated">一些不寻常的系统,如VMS,需要特殊的文件名处理,以处理文件的符号名(即VMS的逻辑名)。</target>
        </trans-unit>
        <trans-unit id="6a39214b093577878080cd0246589b3e208ffeb5" translate="yes" xml:space="preserve">
          <source>Some user's however may feel that the above &quot;economy of expression&quot; is not particularly readable nor consistent and may instead choose to do something more like the following:</source>
          <target state="translated">不过,有些用户可能会觉得上面的 &quot;表达经济 &quot;不是特别可读,也不是特别连贯,反而可能会选择更像下面的做法。</target>
        </trans-unit>
        <trans-unit id="1ad295080cd8e985d193a33706aa64c82df7132f" translate="yes" xml:space="preserve">
          <source>Some users have expressed that they think this whole mechanism of having a &quot;fail&quot; attribute at all, seems a rather pointless complication. But I want Locale::Maketext to be usable for software projects of</source>
          <target state="translated">有些用户表示,他们认为这种有 &quot;失败 &quot;属性的机制,似乎是一种相当无意义的复杂化。但我希望Locale::Maketext可以用于以下软件项目中。</target>
        </trans-unit>
        <trans-unit id="7ab6d61e44a0f4b38225b697b64d41eb4c216b63" translate="yes" xml:space="preserve">
          <source>Some users may wish to encourage the use of lexically scoped variables. As an aid to catching implicit uses to package variables, which are always global, if you say</source>
          <target state="translated">一些用户可能希望鼓励使用词法范围变量。作为一种辅助手段,我们可以捕捉到对包变量的隐式使用,这些变量总是全局的,如果你说</target>
        </trans-unit>
        <trans-unit id="020ce1178f605ac1782ec8459fa4fa7fd0cf745e" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;DB_File&lt;/code&gt; won't let you store data under a key of length 0. That means that if you have a function &lt;code&gt;f&lt;/code&gt; which you memoized and the cache is in a &lt;code&gt;DB_File&lt;/code&gt; database, then the value of &lt;code&gt;f()&lt;/code&gt; (&lt;code&gt;f&lt;/code&gt; called with no arguments) will not be memoized. If this is a big problem, you can supply a normalizer function that prepends &lt;code&gt;&quot;x&quot;&lt;/code&gt; to every key.</source>
          <target state="translated">有些版本的 &lt;code&gt;DB_File&lt;/code&gt; 不会让您存储长度为0的项下的数据这意味着，如果你有一个函数 &lt;code&gt;f&lt;/code&gt; 您memoized和缓存处于一个 &lt;code&gt;DB_File&lt;/code&gt; 数据库，那么的值 &lt;code&gt;f()&lt;/code&gt; （ &lt;code&gt;f&lt;/code&gt; 调用没有参数）将不会被记忆。如果这是个大问题，则可以提供一个规范化函数，在每个键之前加上 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bb4498f94e563a623dff663cd55b4fc862752c4" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;make&lt;/code&gt; set the variable &lt;code&gt;MAKE&lt;/code&gt; . Others do not. This variable contains the string to be included in</source>
          <target state="translated">一些版本的 &lt;code&gt;make&lt;/code&gt; 设置变量 &lt;code&gt;MAKE&lt;/code&gt; 。其他人没有。此变量包含要包含在其中的字符串</target>
        </trans-unit>
        <trans-unit id="fd2f9dd996c82ce27f9d189fd038a8b3dc2b29cb" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;make&lt;/code&gt; set the variable &lt;code&gt;MAKE&lt;/code&gt;. Others do not. This variable contains the string to be included in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954f7aeec06323e12a6983f37a0846eca84625d3" translate="yes" xml:space="preserve">
          <source>Some versions of flock() can't lock files over a network (e.g. on NFS file systems), so you'd need to force the use of fcntl(2) when you build Perl. But even this is dubious at best. See the flock entry of &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and the</source>
          <target state="translated">某些版本的flock（）无法通过网络锁定文件（例如，在NFS文件系统上），因此在构建Perl时需要强制使用fcntl（2）。但是，即使这充其量也是可疑的。请参阅&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;的羊群条目和</target>
        </trans-unit>
        <trans-unit id="dd60cc6568aba712fcca69343c88a2420637338a" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is one reason why this function is deprecated. The other is that only in extremely limited circumstances should the Unicode versus native code point be of any interest to you. See &lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;&quot;utf8_to_uvuni_buf&quot;&lt;/a&gt; for alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d311518a6bb3b8613076ce871f73cf8cb1a1e05f" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is one reason why this function is deprecated. The other is that only in extremely limited circumstances should the Unicode versus native code point be of any interest to you. See &lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;utf8_to_uvuni_buf&lt;/a&gt; for alternatives.</source>
          <target state="translated">检测到一些但不是全部UTF-8格式错误，实际上，某些格式错误的输入可能导致读取超出输入缓冲区的末尾，这是不建议使用此功能的原因之一。另一个是只有在极有限的情况下，您才会对Unicode与本机代码点感兴趣。有关替代方法，请参见&lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;utf8_to_uvuni_buf&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f0f7251754bf0f46339bfaca2d9d1483409569f4" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is why this function is deprecated. Use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;&quot;utf8_to_uvchr_buf&quot;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc9641c97ef26419e8b09582d42e0230f643449" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is why this function is deprecated. Use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt; instead.</source>
          <target state="translated">检测到一些但不是全部UTF-8格式错误，实际上，某些格式错误的输入可能会导致超出输入缓冲区末尾的读取，这就是不建议使用此功能的原因。请改用&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5b99daee126bc167396885e5a173ca7e1b5727f" translate="yes" xml:space="preserve">
          <source>Some, such as &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; aren't provided because the concept does not exist within Plan 9. Others, such as some of the socket-related functions, simply haven't been written yet. Many in the latter category may be supported in the future.</source>
          <target state="translated">由于在Plan 9中不存在该概念，因此未提供诸如 &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 之类的功能。其他诸如与套接字相关的功能之类的其他功能只是尚未编写。将来可能会支持后一类中的许多功能。</target>
        </trans-unit>
        <trans-unit id="63c9382b076dd9dd8161d9b49e86f36c6b0988c1" translate="yes" xml:space="preserve">
          <source>Some, such as &lt;code&gt;chown&lt;/code&gt; and &lt;code&gt;umask&lt;/code&gt; aren't provided because the concept does not exist within Plan 9. Others, such as some of the socket-related functions, simply haven't been written yet. Many in the latter category may be supported in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b529d1f2a1daeac288a5dc3e3f1ad071820c7a2" translate="yes" xml:space="preserve">
          <source>Some/Module.pm</source>
          <target state="translated">Some/Module.pm</target>
        </trans-unit>
        <trans-unit id="75f6f0269318d3e6d862e35e227cdb78f8aa0076" translate="yes" xml:space="preserve">
          <source>Someone like Larry, or one of his peculiar friends. Also refers to the strange prefixes that Perl requires as noun markers on its variables.</source>
          <target state="translated">像Larry这样的人,或者他的一个奇特的朋友。也指Perl要求在变量上使用奇怪的前缀作为名词标记。</target>
        </trans-unit>
        <trans-unit id="4645c18015bf5520c386fecd9f2627c0f851f491" translate="yes" xml:space="preserve">
          <source>Someone who &amp;ldquo;carries&amp;rdquo; software from one &lt;b&gt;platform&lt;/b&gt; to another. Porting programs written in platform-dependent languages such as C can be difficult work, but porting programs like Perl is very much worth the agony.</source>
          <target state="translated">将软件从一个&lt;b&gt;平台&lt;/b&gt; &amp;ldquo;携带&amp;rdquo; 到另一个&lt;b&gt;平台的&lt;/b&gt;人。移植用依赖于平台的语言（例如C）编写的程序可能很难，但是移植像Perl这样的程序非常值得痛苦。</target>
        </trans-unit>
        <trans-unit id="81901ca358030c454d79961747b435397961631e" translate="yes" xml:space="preserve">
          <source>Someone who breaks security on computer systems. A cracker may be a true &lt;b&gt;hacker&lt;/b&gt; or only a &lt;b&gt;script kiddie&lt;/b&gt;.</source>
          <target state="translated">破坏计算机系统安全性的人。破解者可能是真正的&lt;b&gt;黑客，&lt;/b&gt;也可能只是&lt;b&gt;脚本小子&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="1964ccb6039dfc22b78b8e0d35db2a914eb047cc" translate="yes" xml:space="preserve">
          <source>Someone who is brilliantly persistent in solving technical problems, whether these involve golfing, fighting orcs, or programming. Hacker is a neutral term, morally speaking. Good hackers are not to be confused with evil &lt;b&gt;crackers&lt;/b&gt; or clueless &lt;b&gt;script kiddies&lt;/b&gt;. If you confuse them, we will presume that you are either evil or clueless.</source>
          <target state="translated">精通解决技术问题的人，无论是打高尔夫球，打兽人还是编程。从道德上讲，黑客是一个中立的名词。好的黑客不要与邪恶的&lt;b&gt;饼干&lt;/b&gt;或无知的&lt;b&gt;脚本小子&lt;/b&gt;混淆。如果您混淆了它们，我们将假定您是邪恶的还是无知的。</target>
        </trans-unit>
        <trans-unit id="a06bdcd2151c9efce6b287181e34780a4956856f" translate="yes" xml:space="preserve">
          <source>Something &amp;ldquo;iffy&amp;rdquo;. See &lt;b&gt;Boolean context&lt;/b&gt;.</source>
          <target state="translated">有点&amp;ldquo; iff&amp;rdquo;。请参见&lt;b&gt;布尔上下文&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="e155f24963deb993057b4c0bc7a9a37afd51cb22" translate="yes" xml:space="preserve">
          <source>Something extra that happens when you evaluate an &lt;b&gt;expression&lt;/b&gt;. Nowadays it can refer to almost anything. For example, evaluating a simple assignment statement typically has the &amp;ldquo;side effect&amp;rdquo; of assigning a value to a variable. (And you thought assigning the value was your primary intent in the first place!) Likewise, assigning a value to the special variable &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) has the side effect of forcing a flush after every &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; on the currently selected filehandle.</source>
          <target state="translated">计算&lt;b&gt;表达式&lt;/b&gt;时会发生一些额外的情况。如今，它几乎可以指任何东西。例如，评估简单的赋值语句通常具有将值分配给变量的&amp;ldquo;副作用&amp;rdquo;。（并且您认为分配值首先是您的主要意图！）同样，将值分配给特殊变量 &lt;code&gt;$|&lt;/code&gt; （ &lt;code&gt;$AUTOFLUSH&lt;/code&gt; ）的副作用是每次在当前选定的文件句柄上 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 后都强制刷新。</target>
        </trans-unit>
        <trans-unit id="4a7cb9b5327bb852f44f8593a79f045c7ad57891" translate="yes" xml:space="preserve">
          <source>Something extra that happens when you evaluate an &lt;b&gt;expression&lt;/b&gt;. Nowadays it can refer to almost anything. For example, evaluating a simple assignment statement typically has the &amp;ldquo;side effect&amp;rdquo; of assigning a value to a variable. (And you thought assigning the value was your primary intent in the first place!) Likewise, assigning a value to the special variable &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt;) has the side effect of forcing a flush after every &lt;code&gt;write&lt;/code&gt; or &lt;code&gt;print&lt;/code&gt; on the currently selected filehandle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="783e080adee89f0dfad650da0b7f44d322697c43" translate="yes" xml:space="preserve">
          <source>Something is rotten in the state of the program. An attributed subroutine ceased to exist between the point it was declared and the point at which its attribute handler(s) would have been called.</source>
          <target state="translated">程序的状态有问题。一个归属的子程序在它被声明和它的归属处理程序被调用之间不存在了。</target>
        </trans-unit>
        <trans-unit id="9119b80c4db3125e0e5d3f36b18c5029258c49c9" translate="yes" xml:space="preserve">
          <source>Something is still amiss: consider the loop variable $cnt of the script. It was a number, not an object. We cannot make this value of type &lt;code&gt;symbolic&lt;/code&gt; , since then the loop will not terminate.</source>
          <target state="translated">仍然有些不对劲：考虑脚本的循环变量$ cnt。这是一个数字，而不是一个对象。我们不能使这个类型的值成为 &lt;code&gt;symbolic&lt;/code&gt; ，因为那样循环就不会终止。</target>
        </trans-unit>
        <trans-unit id="e0a55c1b08a5503b38a652a677cea0c95bbc3889" translate="yes" xml:space="preserve">
          <source>Something is still amiss: consider the loop variable $cnt of the script. It was a number, not an object. We cannot make this value of type &lt;code&gt;symbolic&lt;/code&gt;, since then the loop will not terminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b420f56b3a25fc6071dc9a2a0d9e492a4d5a4fac" translate="yes" xml:space="preserve">
          <source>Something like &lt;code&gt;&quot;-DHAVE_UNISTD_H&quot;&lt;/code&gt;</source>
          <target state="translated">类似于 &lt;code&gt;&quot;-DHAVE_UNISTD_H&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2229723dcea531af53507e7f80155b0032f61e90" translate="yes" xml:space="preserve">
          <source>Something not owned by anybody. Perl is copyrighted and is thus</source>
          <target state="translated">不属于任何人的东西。Perl是受版权保护的,因此</target>
        </trans-unit>
        <trans-unit id="63320e06b401dd030b4898741e99304253f96385" translate="yes" xml:space="preserve">
          <source>Something of a hack but it prevents a lot of code duplication between MM_* variants.</source>
          <target state="translated">虽然是个黑客,但它可以防止MM_*变种之间的大量代码重复。</target>
        </trans-unit>
        <trans-unit id="bbccb8a40149fe00b8fef910fa55b43eced89db6" translate="yes" xml:space="preserve">
          <source>Something similar to the offset hack is performed on AVs to enable efficient shifting and splicing off the beginning of the array; while &lt;code&gt;AvARRAY&lt;/code&gt; points to the first element in the array that is visible from Perl, &lt;code&gt;AvALLOC&lt;/code&gt; points to the real start of the C array. These are usually the same, but a &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; operation can be carried out by increasing &lt;code&gt;AvARRAY&lt;/code&gt; by one and decreasing &lt;code&gt;AvFILL&lt;/code&gt; and &lt;code&gt;AvMAX&lt;/code&gt; . Again, the location of the real start of the C array only comes into play when freeing the array. See &lt;code&gt;av_shift&lt;/code&gt; in</source>
          <target state="translated">在AV上执行与偏移hack相似的操作，以实现有效的移位和拼接数组的开头。而 &lt;code&gt;AvARRAY&lt;/code&gt; 指向数组中的第一个元素是可见从Perl中， &lt;code&gt;AvALLOC&lt;/code&gt; 点到C阵列的真正开始。这些通常是相同的，但是可以通过将 &lt;code&gt;AvARRAY&lt;/code&gt; 增加1并减小 &lt;code&gt;AvFILL&lt;/code&gt; 和 &lt;code&gt;AvMAX&lt;/code&gt; 来执行 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 操作。同样，仅当释放数组时，C数组的实际起始位置才起作用。见 &lt;code&gt;av_shift&lt;/code&gt; 在</target>
        </trans-unit>
        <trans-unit id="d8e742452f6bb725bfab3a5c5dba5836e7b3c368" translate="yes" xml:space="preserve">
          <source>Something similar to the offset hack is performed on AVs to enable efficient shifting and splicing off the beginning of the array; while &lt;code&gt;AvARRAY&lt;/code&gt; points to the first element in the array that is visible from Perl, &lt;code&gt;AvALLOC&lt;/code&gt; points to the real start of the C array. These are usually the same, but a &lt;code&gt;shift&lt;/code&gt; operation can be carried out by increasing &lt;code&gt;AvARRAY&lt;/code&gt; by one and decreasing &lt;code&gt;AvFILL&lt;/code&gt; and &lt;code&gt;AvMAX&lt;/code&gt;. Again, the location of the real start of the C array only comes into play when freeing the array. See &lt;code&gt;av_shift&lt;/code&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4332fef1f22d39fca98466a0536a5b2d1aaa44ee" translate="yes" xml:space="preserve">
          <source>Something that tells your program what sort of variable you&amp;rsquo;d like. Perl doesn&amp;rsquo;t require you to declare variables, but you can use &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; to denote that you want something other than the default.</source>
          <target state="translated">告诉您的程序您想要哪种变量的信息。Perl不需要声明变量，但是您可以使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 表示您想要除默认值以外的内容。</target>
        </trans-unit>
        <trans-unit id="e3fc8d53ca8cfa587374cbbfc4c208732524185a" translate="yes" xml:space="preserve">
          <source>Something that tells your program what sort of variable you&amp;rsquo;d like. Perl doesn&amp;rsquo;t require you to declare variables, but you can use &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt;, or &lt;code&gt;state&lt;/code&gt; to denote that you want something other than the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad3b77572daa04075d4890e62387b4b824f1955" translate="yes" xml:space="preserve">
          <source>Something to exclude, prefixed by &lt;code&gt;&quot;-&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">以 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 为前缀的要排除的东西：现有的字符属性（以 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; 作为前缀）或完全限定的（包括程序包名称）用户定义的字符属性，以表示该属性中的所有字符；一个范围的两个十六进制代码点；或单个十六进制代码点。</target>
        </trans-unit>
        <trans-unit id="7bf62f5d5b516cf40152d9946d4ef2a34c8991f7" translate="yes" xml:space="preserve">
          <source>Something to exclude, prefixed by &lt;code&gt;&quot;-&quot;&lt;/code&gt;: an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt;) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7458ff984e1016174a3ccc404733830b1557d4" translate="yes" xml:space="preserve">
          <source>Something to include, prefixed by &lt;code&gt;&quot;+&quot;&lt;/code&gt; : a built-in character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">包含以 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 为前缀的内容：内置字符属性（以 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; 为前缀）或完全限定的（包括程序包名称）用户定义的字符属性，以表示该属性中的所有字符；一个范围的两个十六进制代码点；或单个十六进制代码点。</target>
        </trans-unit>
        <trans-unit id="bb71dc1c8ef0238d1cf6b1ff9fe27bbba1762fb7" translate="yes" xml:space="preserve">
          <source>Something to include, prefixed by &lt;code&gt;&quot;+&quot;&lt;/code&gt;: a built-in character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt;) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691cfd6a9c9ef44b73a6c3b1fc2fc7e231422dbe" translate="yes" xml:space="preserve">
          <source>Something to intersect with, prefixed by &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, for all the characters except the characters in the property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">与之相交的东西，以 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 为前缀：对于该属性中除字符之外的所有字符，现有字符属性（以 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; 作为前缀）或完全限定的（包括程序包名称）用户定义的字符属性；一个范围的两个十六进制代码点；或单个十六进制代码点。</target>
        </trans-unit>
        <trans-unit id="4e94a757edcaa7aad7a0e5c39dc75f3c74ce6898" translate="yes" xml:space="preserve">
          <source>Something to intersect with, prefixed by &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt;: an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt;) or a fully qualified (including package name) user-defined character property, for all the characters except the characters in the property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6131959027de2eb65107afa87755cfdbae0af220" translate="yes" xml:space="preserve">
          <source>Something to negate, prefixed &lt;code&gt;&quot;!&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">否定的东西，以 &lt;code&gt;&quot;!&quot;&lt;/code&gt; 为前缀 ：一个现有的字符属性（以 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; 为前缀）或一个完全限定的（包括程序包名称）用户定义的字符属性，以表示该属性中的所有字符；一个范围的两个十六进制代码点；或单个十六进制代码点。</target>
        </trans-unit>
        <trans-unit id="1f4e74c8c058a6efc1c6982e3f86bee213dbdf3d" translate="yes" xml:space="preserve">
          <source>Something to negate, prefixed &lt;code&gt;&quot;!&quot;&lt;/code&gt;: an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt;) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29b35d3b7e27c5736fa04a9d5a9779f7c0d02b4" translate="yes" xml:space="preserve">
          <source>Something we&amp;rsquo;d call a &lt;b&gt;metacharacter&lt;/b&gt; except that it&amp;rsquo;s a sequence of more than one character. Generally, the first character in the sequence must be a true metacharacter to get the other characters in the metasymbol to misbehave along with it.</source>
          <target state="translated">我们称其为&lt;b&gt;元字符，&lt;/b&gt;只是它是一个以上的字符序列。通常，序列中的第一个字符必须是真实的元字符，才能使该元符号中的其他字符与之一起行为异常。</target>
        </trans-unit>
        <trans-unit id="0939ed03ca5713b7d596d517d3a21d567b42a063" translate="yes" xml:space="preserve">
          <source>Something went horribly wrong-- the number of microseconds that cannot become negative just became negative. Maybe your compiler is broken?</source>
          <target state="translated">有些地方出了大问题...不能变成负数的微秒数刚刚变成了负数。也许你的编译器坏了?</target>
        </trans-unit>
        <trans-unit id="c59ba282daa2ae9441382d6bdd1d5cbb102eba6e" translate="yes" xml:space="preserve">
          <source>Something you can see from anywhere, usually used of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; that are visible everywhere in your program. In Perl, only certain special variables are truly global&amp;mdash;most variables (and all subroutines) exist only in the current &lt;b&gt;package&lt;/b&gt;. Global variables can be declared with &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;. See &amp;ldquo;Global Declarations&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="translated">您可以从任何地方看到的东西，通常使用&lt;b&gt;变量&lt;/b&gt;和&lt;b&gt;子例程&lt;/b&gt;，这些&lt;b&gt;变量&lt;/b&gt;和&lt;b&gt;子例程&lt;/b&gt;在程序中随处可见。在Perl中，只有某些特殊变量才是真正的全局变量-大多数变量（和所有子例程）仅存在于当前&lt;b&gt;包中&lt;/b&gt;。全局变量可以用 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明。请参见骆驼第4章&amp;ldquo;声明和声明&amp;rdquo;中的&amp;ldquo;全球声明&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e2c9c959fabe06831c4dbb79467f69e8f2c98312" translate="yes" xml:space="preserve">
          <source>Something you can see from anywhere, usually used of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; that are visible everywhere in your program. In Perl, only certain special variables are truly global&amp;mdash;most variables (and all subroutines) exist only in the current &lt;b&gt;package&lt;/b&gt;. Global variables can be declared with &lt;code&gt;our&lt;/code&gt;. See &amp;ldquo;Global Declarations&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e88fa4cc64647b2e3278d50a97cb8b0618c720" translate="yes" xml:space="preserve">
          <source>Something you do for someone else to make them happy, like giving them the time of day (or of their life). On some machines, well-known services are listed by the &lt;code&gt;&lt;a href=&quot;functions/getservent&quot;&gt;getservent&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">您为他人做的使他们开心的事情，例如给他们一天（或一生）的时间。在某些计算机上， &lt;code&gt;&lt;a href=&quot;functions/getservent&quot;&gt;getservent&lt;/a&gt;&lt;/code&gt; 函数列出了众所周知的服务。</target>
        </trans-unit>
        <trans-unit id="3583892f6ad6941063be20d46c43faa9b54da5ee" translate="yes" xml:space="preserve">
          <source>Something you do for someone else to make them happy, like giving them the time of day (or of their life). On some machines, well-known services are listed by the &lt;code&gt;getservent&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae96bed2910e868f1f0a103c503d2b55a0cc3496" translate="yes" xml:space="preserve">
          <source>Sometimes (see &lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;&quot;When Unicode Does Not Happen&quot;&lt;/a&gt; or &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot;&lt;/a&gt;) there are situations where you simply need to force a byte string into UTF-8, or vice versa. The standard module &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; can be used for this, or the low-level calls &lt;a href=&quot;utf8#Utility-functions&quot;&gt;&lt;code&gt;utf8::upgrade($bytestring)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;utf8#Utility-functions&quot;&gt;&lt;code&gt;utf8::downgrade($utf8string[, FAIL_OK])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457be77433ae10862116d65ca361c913afdc2edf" translate="yes" xml:space="preserve">
          <source>Sometimes (see &lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;When Unicode Does Not Happen&lt;/a&gt; or &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;) there are situations where you simply need to force a byte string into UTF-8, or vice versa. The standard module &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; can be used for this, or the low-level calls &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::upgrade($bytestring) &lt;/a&gt; and &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::downgrade($utf8string[, FAIL_OK]) &lt;/a&gt;.</source>
          <target state="translated">有时（请参见&lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;Unicode不会发生&lt;/a&gt;或&lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;Unicode错误&lt;/a&gt;）在某些情况下，您只需要将字节字符串强制放入UTF-8，反之亦然。可以使用标准模块&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;或低级调用&lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: upgrade（$ bytestring）&lt;/a&gt;和&lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: downgrade（$ utf8string [，FAIL_OK]）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f608ce8dd6d68e4a0eca5a70c40d0ca13048d16" translate="yes" xml:space="preserve">
          <source>Sometimes a change affects code paths which you cannot test on the OSes which are directly available to you and it would be wise to have users on other OSes test the change before you commit it to blead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c72f071a765fd3018bc7af5d49df36cbd9aae7b" translate="yes" xml:space="preserve">
          <source>Sometimes greed is not good. At times, we would like quantifiers to match a</source>
          <target state="translated">有时候,贪心不是好事。有时,我们会希望量化器能匹配一个</target>
        </trans-unit>
        <trans-unit id="0aa27e840004256e29009bb974e009bb34e90abf" translate="yes" xml:space="preserve">
          <source>Sometimes instead of zeroing the allocated heap by using Newxz() you should consider &quot;poisoning&quot; the data. This means writing a bit pattern into it that should be illegal as pointers (and floating point numbers), and also hopefully surprising enough as integers, so that any code attempting to use the data without forethought will break sooner rather than later. Poisoning can be done using the Poison() macros, which have similar arguments to Zero():</source>
          <target state="translated">有时,与其使用Newxz()将分配的堆归零,不如考虑给数据 &quot;下毒&quot;。这意味着在其中写一个位模式,作为指针(和浮点数)应该是非法的,同时也希望作为整数有足够的惊喜,这样任何试图不经意地使用数据的代码都会迟早崩溃。中毒可以使用Poison()宏,它的参数与Zero()类似。</target>
        </trans-unit>
        <trans-unit id="cae5675054ecaa30b3d68d273e86faefe7bf19e0" translate="yes" xml:space="preserve">
          <source>Sometimes it is advantageous to construct a pattern from the</source>
          <target state="translated">有时,从</target>
        </trans-unit>
        <trans-unit id="fa5de12a356ae81ac7e15fb6c4fdf4f42322289c" translate="yes" xml:space="preserve">
          <source>Sometimes it may be necessary to make more than one pass over the input files. If this is the case you have several options. You can make the first pass using &lt;b&gt;Pod::Parser&lt;/b&gt; and override your methods to store the intermediate results in memory somewhere for the &lt;b&gt;end_pod()&lt;/b&gt; method to process. You could use &lt;b&gt;Pod::Parser&lt;/b&gt; for several passes with an appropriate state variable to control the operation for each pass. If your input source can't be reset to start at the beginning, you can store it in some other structure as a string or an array and have that structure implement a &lt;b&gt;getline()&lt;/b&gt; method (which is all that &lt;b&gt;parse_from_filehandle()&lt;/b&gt; uses to read input).</source>
          <target state="translated">有时可能需要对输入文件进行一次以上的传递。如果是这种情况，您可以有几种选择。您可以使用&lt;b&gt;Pod :: Parser&lt;/b&gt;进行第一遍，并覆盖您的方法以将中间结果存储在内存中的某个地方，以便&lt;b&gt;end_pod（）&lt;/b&gt;方法进行处理。您可以使用&lt;b&gt;Pod :: Parser&lt;/b&gt;进行多次传递，并使用适当的状态变量来控制每次传递的操作。如果您无法将输入源重置为从头开始，则可以将其以字符串或数组的形式存储在其他结构中，并使该结构实现&lt;b&gt;getline（）&lt;/b&gt;方法（&lt;b&gt;parse_from_filehandle（）&lt;/b&gt;用于读取的全部&lt;b&gt;内容）&lt;/b&gt;输入）。</target>
        </trans-unit>
        <trans-unit id="f6006f7823a5727b8006f191fa888a2e039ea099" translate="yes" xml:space="preserve">
          <source>Sometimes minimal matching can help a lot. Imagine you'd like to match everything between &quot;foo&quot; and &quot;bar&quot;. Initially, you write something like this:</source>
          <target state="translated">有时候,最小化的匹配会有很大的帮助。想象一下,你想匹配 &quot;foo &quot;和 &quot;bar &quot;之间的所有内容。最初,你写的东西是这样的。</target>
        </trans-unit>
        <trans-unit id="7e0fb1495abd7611e5570cce2cb4d1976ffa0113" translate="yes" xml:space="preserve">
          <source>Sometimes older versions of the module you're installing live in other directories in @INC. Because Perl loads the first version of a module it finds, not the newest, you might accidentally get one of these older versions even after installing a brand new version. To delete</source>
          <target state="translated">有时,你要安装的模块的旧版本存在于 @INC 的其他目录中。因为Perl加载的是它所找到的模块的第一个版本,而不是最新的版本,所以即使安装了一个全新的版本,你也可能会意外地得到其中的一个旧版本。要删除</target>
        </trans-unit>
        <trans-unit id="eb753520a2d796d4f761ee04ddf336bdbe0915a3" translate="yes" xml:space="preserve">
          <source>Sometimes ops are executed within an inner runops loop, such as tie, sort or overload code. In this case, something like</source>
          <target state="translated">有时,运维会在内部的runops循环中执行,比如领带、排序或重载代码。在这种情况下,类似于</target>
        </trans-unit>
        <trans-unit id="147ec757892c0aed445b0fb45a48e27c978e8a0c" translate="yes" xml:space="preserve">
          <source>Sometimes running a test under certain conditions will cause the test script to die. A certain function or method isn't implemented (such as &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; on MacOS), some resource isn't available (like a net connection) or a module isn't available. In these cases it's necessary to skip tests, or declare that they are supposed to fail but will work in the future (a todo test).</source>
          <target state="translated">有时在某些条件下运行测试将导致测试脚本死亡。某些功能或方法未实现（例如MacOS上的 &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; ），某些资源不可用（例如网络连接）或模块不可用。在这种情况下，有必要跳过测试，或者声明它们应该失败，但将来仍可以使用（待办事项测试）。</target>
        </trans-unit>
        <trans-unit id="7390e59acad33d69c3848b5a344152fa281f8af4" translate="yes" xml:space="preserve">
          <source>Sometimes running a test under certain conditions will cause the test script to die. A certain function or method isn't implemented (such as &lt;code&gt;fork()&lt;/code&gt; on MacOS), some resource isn't available (like a net connection) or a module isn't available. In these cases it's necessary to skip tests, or declare that they are supposed to fail but will work in the future (a todo test).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a525fd22c2b653fcabe0c32c53b3975d5455dc" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::Builder test counter is incremented without it printing any test output, for example, when &lt;code&gt;current_test()&lt;/code&gt; is changed. In these cases, Test::Builder doesn't know the result of the test, so its type is 'unknown'. These details for these tests are filled in. They are considered ok, but the name and actual_ok is left &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有时，Test :: Builder测试计数器会递增，而不会打印任何测试输出，例如，当 &lt;code&gt;current_test()&lt;/code&gt; 更改时。在这些情况下，Test :: Builder不知道测试结果，因此其类型为&amp;ldquo;未知&amp;rdquo;。这些测试的详细信息已填写。它们被认为可以，但是名称和Actual_ok仍为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f02b8eb27bf0ac9011c417f61209efd72c4a3f25" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::Builder test counter is incremented without it printing any test output, for example, when &lt;code&gt;current_test()&lt;/code&gt; is changed. In these cases, Test::Builder doesn't know the result of the test, so its type is 'unknown'. These details for these tests are filled in. They are considered ok, but the name and actual_ok is left &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd534b46a8017bb548267c02f58ed840dafad837" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::More interface isn't quite enough. Fortunately, Test::More is built on top of &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; which provides a single, unified backend for any test library to use. This means two test libraries which both use &amp;lt;Test::Builder&amp;gt; &lt;b&gt;can&lt;/b&gt; be used together in the same program&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c117b85f5735958c8ac918f5819ede8cc1b0ef4" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::More interface isn't quite enough. Fortunately, Test::More is built on top of &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; which provides a single, unified backend for any test library to use. This means two test libraries which both use &amp;lt;Test::Builder&amp;gt; &lt;b&gt;can&lt;/b&gt; be used together in the same program&amp;gt;.</source>
          <target state="translated">有时Test :: More接口还不够。幸运的是，Test :: More建立在&lt;a href=&quot;builder&quot;&gt;Test :: Builder的基础上&lt;/a&gt;，它为任何测试库提供了一个统一的后端。这意味着两个都使用&amp;lt;Test :: Builder&amp;gt;的测试库&lt;b&gt;可以&lt;/b&gt;在同一程序中一起使用。</target>
        </trans-unit>
        <trans-unit id="df8dfca3bc58e211921f51d53ab1d95cb5cb75f5" translate="yes" xml:space="preserve">
          <source>Sometimes the tests are wrong</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0436b0b7df1e2c343b73c639e499fd807b68f3" translate="yes" xml:space="preserve">
          <source>Sometimes there is some confusion about where &lt;code&gt;todo()&lt;/code&gt; should be looking for the &lt;code&gt;$TODO&lt;/code&gt; variable. If you want to be sure, tell it explicitly what $pack to use.</source>
          <target state="translated">有时对于 &lt;code&gt;todo()&lt;/code&gt; 应该在哪里寻找 &lt;code&gt;$TODO&lt;/code&gt; 变量有些困惑。如果要确定，请明确告诉它使用什么$ pack。</target>
        </trans-unit>
        <trans-unit id="399765aa05845ba02b6fea1a15de4bf746fb4a9e" translate="yes" xml:space="preserve">
          <source>Sometimes we would like our regexp to be able to match different possible words or character strings. This is accomplished by using the</source>
          <target state="translated">有时我们希望我们的regexp能够匹配不同可能的单词或字符串。这可以通过使用</target>
        </trans-unit>
        <trans-unit id="c45fdfd630d6939174042d52a2669877eec8162b" translate="yes" xml:space="preserve">
          <source>Sometimes you don't want to pass the value of an array to a subroutine but rather the name of it, so that the subroutine can modify the global copy of it rather than working with a local copy. In perl you can refer to all objects of a particular name by prefixing the name with a star: &lt;code&gt;*foo&lt;/code&gt; . This is often known as a &quot;typeglob&quot;, because the star on the front can be thought of as a wildcard match for all the funny prefix characters on variables and subroutines and such.</source>
          <target state="translated">有时，您不想将数组的值传递给子例程，而是希望将其名称传递给子例程，以便子例程可以修改其全局副本，而不是使用本地副本。在perl中，可以通过在名称前面加上星号 &lt;code&gt;*foo&lt;/code&gt; 来引用特定名称的所有对象。这通常被称为&amp;ldquo; typeglob&amp;rdquo;，因为前面的星星可以被认为是变量和子例程等上所有有趣的前缀字符的通配符匹配。</target>
        </trans-unit>
        <trans-unit id="5af3185bc4cb6153940818cc124ced30384d5bf0" translate="yes" xml:space="preserve">
          <source>Sometimes you don't want to pass the value of an array to a subroutine but rather the name of it, so that the subroutine can modify the global copy of it rather than working with a local copy. In perl you can refer to all objects of a particular name by prefixing the name with a star: &lt;code&gt;*foo&lt;/code&gt;. This is often known as a &quot;typeglob&quot;, because the star on the front can be thought of as a wildcard match for all the funny prefix characters on variables and subroutines and such.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd89c56c7d1482880d960bf6dbcdba4cb33c9a40" translate="yes" xml:space="preserve">
          <source>Sometimes you have a context that is not current, and you want things to use it as the current one. In these cases you can call &lt;code&gt;$ctx-&amp;gt;do_in_context(sub { ... })&lt;/code&gt;. The codeblock will be run, and anything inside of it that looks for a context will find the one on which the method was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc7c2918cdb381ad384c3d9167215ff71a8a0da" translate="yes" xml:space="preserve">
          <source>Sometimes you have to store undefined values in AVs or HVs. Although this may be a rare case, it can be tricky. That's because you're used to using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; if you need an undefined SV.</source>
          <target state="translated">有时您必须在AV或HV中存储未定义的值。尽管这可能很少见，但可能很棘手。这是因为如果您需要未定义的SV，则习惯于使用 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce5b78669327a1c5203b6d6638f97e91e235e173" translate="yes" xml:space="preserve">
          <source>Sometimes you just want to say that the tests have passed. Usually the case is you've got some complicated condition that is difficult to wedge into an &lt;code&gt;ok()&lt;/code&gt; . In this case, you can simply use &lt;code&gt;pass()&lt;/code&gt; (to declare the test ok) or fail (for not ok). They are synonyms for &lt;code&gt;ok(1)&lt;/code&gt; and &lt;code&gt;ok(0)&lt;/code&gt; .</source>
          <target state="translated">有时您只想说测试已经通过。通常情况是，您遇到了一些复杂的情况，很难适应 &lt;code&gt;ok()&lt;/code&gt; 。在这种情况下，您可以简单地使用 &lt;code&gt;pass()&lt;/code&gt; （声明测试正常）或失败（表示不正常）。它们是 &lt;code&gt;ok(1)&lt;/code&gt; 和 &lt;code&gt;ok(0)&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="a82677750f0ce8e378152fcb09ef45c3dffa03dc" translate="yes" xml:space="preserve">
          <source>Sometimes you just want to say that the tests have passed. Usually the case is you've got some complicated condition that is difficult to wedge into an &lt;code&gt;ok()&lt;/code&gt;. In this case, you can simply use &lt;code&gt;pass()&lt;/code&gt; (to declare the test ok) or fail (for not ok). They are synonyms for &lt;code&gt;ok(1)&lt;/code&gt; and &lt;code&gt;ok(0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ad657b111885cfb86229225ce3dd7e07ab7571" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to truncate an already-existing file. This can be done using the &lt;code&gt;O_TRUNC&lt;/code&gt; flag. The behavior of &lt;code&gt;O_TRUNC&lt;/code&gt; with &lt;code&gt;O_RDONLY&lt;/code&gt; is undefined.</source>
          <target state="translated">有时您可能想截断一个已经存在的文件。可以使用 &lt;code&gt;O_TRUNC&lt;/code&gt; 标志来完成。 &lt;code&gt;O_TRUNC&lt;/code&gt; 与 &lt;code&gt;O_RDONLY&lt;/code&gt; 的行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="d108e62bce7d546642fdcfcda3e786d8361305f7" translate="yes" xml:space="preserve">
          <source>Sometimes you may wish to leave the processes run by CPAN alone without caring about them. Because the Makefile.PL or the Build.PL sometimes contains question you're expected to answer, you can set a timer that will kill a 'perl Makefile.PL' process after the specified time in seconds.</source>
          <target state="translated">有时你可能希望不关心CPAN运行的进程。因为Makefile.PL或Build.PL有时会包含你需要回答的问题,你可以设置一个定时器,在指定的时间(秒)后杀死 &quot;perl Makefile.PL &quot;进程。</target>
        </trans-unit>
        <trans-unit id="c00f6f509d151b6fb1ea7605fa661bc15fbf5303" translate="yes" xml:space="preserve">
          <source>Sometimes you might really need to know the byte length of a string instead of the character length. For that use either the &lt;code&gt;Encode::encode_utf8()&lt;/code&gt; function or the &lt;code&gt;bytes&lt;/code&gt; pragma and the &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; function:</source>
          <target state="translated">有时您可能真的需要知道字符串的字节长度而不是字符长度。为此，请使用 &lt;code&gt;Encode::encode_utf8()&lt;/code&gt; 函数或 &lt;code&gt;bytes&lt;/code&gt; 编译指示和 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="f11bb3346a94ad8679e866144b82f5a7774a030a" translate="yes" xml:space="preserve">
          <source>Sometimes you might really need to know the byte length of a string instead of the character length. For that use the &lt;code&gt;bytes&lt;/code&gt; pragma and the &lt;code&gt;length()&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ca48a72c9601cef59e5c67d6f3681c75e3b061" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to build a statically linked perl although your system supports dynamic loading. In this case you may explicitly set the linktype with the invocation of the Makefile.PL or make:</source>
          <target state="translated">有时你可能想建立一个静态链接的perl,尽管你的系统支持动态加载。在这种情况下,你可以通过调用Makefile.PL或make.PL来明确设置链接类型。</target>
        </trans-unit>
        <trans-unit id="d30402c312d3b94f0c6f02a6509532f4e38398dd" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to display Perl scalars containing Unicode as simple ASCII (or EBCDIC) text. The following subroutine converts its argument so that Unicode characters with code points greater than 255 are displayed as &lt;code&gt;\x{...}&lt;/code&gt; , control characters (like &lt;code&gt;\n&lt;/code&gt; ) are displayed as &lt;code&gt;\x..&lt;/code&gt; , and the rest of the characters as themselves:</source>
          <target state="translated">有时，您可能希望将包含Unicode的Perl标量显示为简单ASCII（或EBCDIC）文本。下面的子例程转换其参数，以使代码点大于255的Unicode字符显示为 &lt;code&gt;\x{...}&lt;/code&gt; ，控制字符（如 &lt;code&gt;\n&lt;/code&gt; ）显示为 &lt;code&gt;\x..&lt;/code&gt; ，其余字符作为它们自己：</target>
        </trans-unit>
        <trans-unit id="93f2d5137c1ee615f6cf1836ee85be0ea4a982af" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to display Perl scalars containing Unicode as simple ASCII (or EBCDIC) text. The following subroutine converts its argument so that Unicode characters with code points greater than 255 are displayed as &lt;code&gt;\x{...}&lt;/code&gt;, control characters (like &lt;code&gt;\n&lt;/code&gt;) are displayed as &lt;code&gt;\x..&lt;/code&gt;, and the rest of the characters as themselves:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93cab2a917ae8f995aa91a73cd34dbac7106cc0f" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to provide some extra methods or subroutines to assist in making the interface between Perl and your extension simpler or easier to understand. These routines should live in the .pm file. Whether they are automatically loaded when the extension itself is loaded or only loaded when called depends on where in the .pm file the subroutine definition is placed. You can also consult &lt;a href=&quot;autoloader&quot;&gt;AutoLoader&lt;/a&gt; for an alternate way to store and load your extra subroutines.</source>
          <target state="translated">有时，您可能想提供一些额外的方法或子例程，以帮助使Perl和您的扩展之间的接口更简单或更易于理解。这些例程应位于.pm文件中。它们是在加载扩展本身时自动加载还是仅在调用扩展时加载，取决于子例程定义在.pm文件中的位置。您还可以咨询&lt;a href=&quot;autoloader&quot;&gt;AutoLoader&lt;/a&gt;，以找到另一种方式来存储和加载额外的子例程。</target>
        </trans-unit>
        <trans-unit id="d50f25bb7791c3200f165a11a2621c66fc26aa1f" translate="yes" xml:space="preserve">
          <source>Sometimes you need to have two and more XS files in the same package. One way to go is to put them into separate directories, but sometimes this is not the most suitable solution. The following technique allows you to put two (and more) XS files in the same directory.</source>
          <target state="translated">有时你需要在同一个包里有两个及以上的XS文件。一种方法是把它们放在不同的目录中,但有时这不是最合适的解决方案。下面的技术可以让你把两个(和多个)XS文件放在同一个目录中。</target>
        </trans-unit>
        <trans-unit id="aecdaaa113e37c215923d6d01ac79b4d26b62dd7" translate="yes" xml:space="preserve">
          <source>Sometimes you need to have two and more XS files in the same package. There are three ways: &lt;code&gt;XSMULTI&lt;/code&gt;, separate directories, and bootstrapping one XS from another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dc76b72e97adc6a2bca89e4051260b585b27319" translate="yes" xml:space="preserve">
          <source>Sometimes you need to invoke the same subroutine repeatedly. This usually happens with a function that acts on a list of values, such as Perl's built-in sort(). You can pass a comparison function to sort(), which will then be invoked for every pair of values that needs to be compared. The first() and reduce() functions from &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt; follow a similar pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84ae75a88af76cd17f4e95ee970d0624fc53ec5" translate="yes" xml:space="preserve">
          <source>Sometimes you need to invoke the same subroutine repeatedly. This usually happens with a function that acts on a list of values, such as Perl's built-in sort(). You can pass a comparison function to sort(), which will then be invoked for every pair of values that needs to be compared. The first() and reduce() functions from &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; follow a similar pattern.</source>
          <target state="translated">有时您需要重复调​​用同一子例程。这通常发生在作用于值列表的函数上，例如Perl的内置sort（）。您可以将比较函数传递给sort（），然后对需要比较的每对值调用该函数。&lt;a href=&quot;list/util&quot;&gt;List :: Util中&lt;/a&gt;的first（）和reduce（）函数遵循类似的模式。</target>
        </trans-unit>
        <trans-unit id="74631c8a306d075a7cfb9919a67e89afd99fe44c" translate="yes" xml:space="preserve">
          <source>Sometimes you really don't know how many tests were run, or it's too difficult to calculate. In which case you can leave off $number_of_tests_run.</source>
          <target state="translated">有时你真的不知道运行了多少测试,或者是太难计算了,在这种情况下,你可以不使用$number_of_tests_run。在这种情况下,你可以不填写$number_of_tests_run。</target>
        </trans-unit>
        <trans-unit id="85a6426e0300f2135b305a518e04a9c8bcb36f5b" translate="yes" xml:space="preserve">
          <source>Sometimes you should change the positions of the constant and the variable. For example, let's say you wanted to test which of many answers you were given, but in a case-insensitive way that also allows abbreviations. You can use the following technique if the strings all start with different characters or if you want to arrange the matches so that one takes precedence over another, as &lt;code&gt;&quot;SEND&quot;&lt;/code&gt; has precedence over &lt;code&gt;&quot;STOP&quot;&lt;/code&gt; here:</source>
          <target state="translated">有时您应该更改常量和变量的位置。例如，假设您想测试给出的许多答案中的哪一个，但是以不区分大小写的方式进行，也允许使用缩写。如果所有字符串均以不同的字符开头，或者您要安排匹配项以使一个优先于另一个，则可以使用以下技术，因为此处 &lt;code&gt;&quot;SEND&quot;&lt;/code&gt; 优先于 &lt;code&gt;&quot;STOP&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e295d93f5cf54bf6ebaedc8fedd1af1c66b62ba7" translate="yes" xml:space="preserve">
          <source>Sometimes you want to combine the best of hashes and arrays. For example, the command line:</source>
          <target state="translated">有时你想把哈希和数组的优点结合起来。例如,命令行。</target>
        </trans-unit>
        <trans-unit id="eb405d6eff8a4115aee698cb0c98540a6a3fb25a" translate="yes" xml:space="preserve">
          <source>Sometimes you want to test if a module, or a list of modules, can successfully load. For example, you'll often want a first test which simply loads all the modules in the distribution to make sure they work before going on to do more complicated testing.</source>
          <target state="translated">有时你想测试一个模块或一个模块列表是否能成功加载。例如,你经常会想要进行第一次测试,简单地加载发行版中的所有模块,以确保它们能够工作,然后再进行更复杂的测试。</target>
        </trans-unit>
        <trans-unit id="39b7fbc0e51ead34509190d6590e14e10ef47adc" translate="yes" xml:space="preserve">
          <source>Sometimes, blead will move while you're building or testing your changes. When this happens, your push will be rejected with a message like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf8f669e0c9325d3a3aabdd507e3c59589ddd67" translate="yes" xml:space="preserve">
          <source>Sometimes, for example when there are a lot of options, having a separate variable for each of them can be cumbersome. GetOptions() supports, as an alternative mechanism, storing options values in a hash.</source>
          <target state="translated">有时,例如当有很多选项时,为每一个选项建立一个单独的变量是很麻烦的,GetOptions()支持,作为一种替代机制,将选项值存储在哈希中。GetOptions()作为一种替代机制,支持在哈希中存储选项值。</target>
        </trans-unit>
        <trans-unit id="02fbdd8083e416b0e9b5fb808fb524ba8afb9c15" translate="yes" xml:space="preserve">
          <source>Sometimes, however, linked lists can be useful in situations where you want to &quot;shard&quot; an array so you have many small arrays instead of a single big array. You can keep arrays longer than Perl's largest array index, lock smaller arrays separately in threaded programs, reallocate less memory, or quickly insert elements in the middle of the chain.</source>
          <target state="translated">然而,有时,在你想 &quot;碎片 &quot;一个数组,从而拥有许多小数组而不是一个大数组的情况下,链接列表会很有用。你可以保留比Perl最大的数组索引更长的数组,在线程程序中分别锁定较小的数组,重新分配较少的内存,或者在链的中间快速插入元素。</target>
        </trans-unit>
        <trans-unit id="97c577b8a14d559ea222f726e98e3c5c96ca2ea7" translate="yes" xml:space="preserve">
          <source>Sometimes, it can be necessary or useful to make sure that a certain function is fully loaded by AutoLoader. This is the case, for example, when you need to wrap a function to inject debugging code. It is also helpful to force early loading of code before forking to make use of copy-on-write as much as possible.</source>
          <target state="translated">有时,确保某个函数被AutoLoader完全加载是必要的或有用的。例如,当您需要封装一个函数以注入调试代码时,就会出现这种情况。在分叉之前强制提前加载代码也是很有帮助的,这样可以尽可能多地利用copy-on-write。</target>
        </trans-unit>
        <trans-unit id="135822a5181e82def02074d4f94c0948ca18c68d" translate="yes" xml:space="preserve">
          <source>Sometimes, when the extension does not convert data but just stores and retrieves it, you will be able to use the otherwise dangerous &lt;a href=&quot;encode#_utf8_on&quot;&gt;&lt;code&gt;Encode::_utf8_on()&lt;/code&gt;&lt;/a&gt; function. Let's say the popular &lt;code&gt;Foo::Bar&lt;/code&gt; extension, written in C, provides a &lt;code&gt;param&lt;/code&gt; method that lets you store and retrieve data according to these prototypes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c69c69258cfab486eea48fb3f2e535b94c5ff785" translate="yes" xml:space="preserve">
          <source>Sometimes, when the extension does not convert data but just stores and retrieves it, you will be able to use the otherwise dangerous &lt;a href=&quot;encode#_utf8_on&quot;&gt;Encode::_utf8_on() &lt;/a&gt; function. Let's say the popular &lt;code&gt;Foo::Bar&lt;/code&gt; extension, written in C, provides a &lt;code&gt;param&lt;/code&gt; method that lets you store and retrieve data according to these prototypes:</source>
          <target state="translated">有时，当扩展名不转换数据而是仅存储和检索数据时，您将能够使用否则会很危险的&lt;a href=&quot;encode#_utf8_on&quot;&gt;Encode :: _ utf8_on（）&lt;/a&gt;函数。假设流行的 &lt;code&gt;Foo::Bar&lt;/code&gt; 扩展是用C编写的，它提供了一个 &lt;code&gt;param&lt;/code&gt; 方法，使您可以根据以下原型存储和检索数据：</target>
        </trans-unit>
        <trans-unit id="915dac0cd6a2dc4688c56bcdae8cb3044da9ebd2" translate="yes" xml:space="preserve">
          <source>Sometimes, you might not wish to extract a complete archive, just the files that are relevant to you, based on some criteria.</source>
          <target state="translated">有时,您可能不希望提取完整的存档,而只是根据某些标准提取与您相关的文件。</target>
        </trans-unit>
        <trans-unit id="f51205933e073241a85c203ffa02d17e6d6be23a" translate="yes" xml:space="preserve">
          <source>Somewhat obsolete (last update in 1996), but still useful. Also try</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb96cd07e3d9541f84e40d3e5c507a59f023fa2" translate="yes" xml:space="preserve">
          <source>Sorry, hash keys must be smaller than 2**31 bytes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2c8f1aa042b04053bafd03d4559b130a601b41" translate="yes" xml:space="preserve">
          <source>Sort an array, with various options.</source>
          <target state="translated">对一个数组进行排序,有多种选项。</target>
        </trans-unit>
        <trans-unit id="f11b2d382bb4d1812bd22f06feccfbd16f64c011" translate="yes" xml:space="preserve">
          <source>Sort an array. Here is an example:</source>
          <target state="translated">对一个数组进行排序。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="4d31f4a6a4ae686389ba0f01ad7435ce3ff7f965" translate="yes" xml:space="preserve">
          <source>Sort speed and memory use impacts</source>
          <target state="translated">排序速度和内存使用的影响</target>
        </trans-unit>
        <trans-unit id="669dcc90bf40cd3f0218ee9881e32132c08114cc" translate="yes" xml:space="preserve">
          <source>Sort subroutines written using &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are bound to their calling package. It is possible, but of limited interest, to define them in a different package, since the subroutine must still refer to the calling package's &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86fa3b469953cdb9c0cfc2f27adce6dc70ff6d4" translate="yes" xml:space="preserve">
          <source>Sort your map in Unicode order.</source>
          <target state="translated">按照Unicode的顺序对地图进行排序。</target>
        </trans-unit>
        <trans-unit id="ba790800e4b9f3d3512c898b0e6088f4dbb30c87" translate="yes" xml:space="preserve">
          <source>Sorting - the quicksort algorithm used in Perls before 5.8.0 to implement the sort() function is very easy to trick into misbehaving so that it consumes a lot of time. Starting from Perl 5.8.0 a different sorting algorithm, mergesort, is used by default. Mergesort cannot misbehave on any input.</source>
          <target state="translated">排序--在5.8.0之前的Perls中使用的quicksort算法来实现sort()函数,很容易被欺骗,使其产生错误行为,从而消耗大量时间。从Perl 5.8.0开始,默认使用不同的排序算法mergesort。Mergesort 不能在任何输入上发生误操作。</target>
        </trans-unit>
        <trans-unit id="375ce09517152463f4dde67936d2c7e3cbb12301" translate="yes" xml:space="preserve">
          <source>Sorting - the quicksort algorithm used in Perls before 5.8.0 to implement the sort() function was very easy to trick into misbehaving so that it consumes a lot of time. Starting from Perl 5.8.0 a different sorting algorithm, mergesort, is used by default. Mergesort cannot misbehave on any input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a6e89fe9499560d5c7c4f0eba879f0797fcbdf" translate="yes" xml:space="preserve">
          <source>Sorts a list of strings.</source>
          <target state="translated">对字符串列表进行排序。</target>
        </trans-unit>
        <trans-unit id="89989e7858233b758069d9e36e356e32ea1f4ab9" translate="yes" xml:space="preserve">
          <source>Sounds an awful lot like a process, doesn't it? Well, it should. Threads are one of the pieces of a process. Every process has at least one thread and, up until now, every process running Perl had only one thread. With 5.8, though, you can create extra threads. We're going to show you how, when, and why.</source>
          <target state="translated">听起来很像一个过程,不是吗?嗯,应该是这样。线程是进程的一个组成部分。每个进程都至少有一个线程,直到现在,每个运行Perl的进程都只有一个线程。不过,在5.8中,你可以创建额外的线程。我们将向你展示如何、何时以及为什么。</target>
        </trans-unit>
        <trans-unit id="7b37110e5b01350732eac4676af2611966b9ccef" translate="yes" xml:space="preserve">
          <source>Source Code</source>
          <target state="translated">源代码</target>
        </trans-unit>
        <trans-unit id="f0a8c7951e6c30a3c63c9dfb78486cbdf3df91af" translate="yes" xml:space="preserve">
          <source>Source Documentation</source>
          <target state="translated">源文件</target>
        </trans-unit>
        <trans-unit id="c29ede2e39eca25683627a84bf1a76ac20119bd7" translate="yes" xml:space="preserve">
          <source>Source Filters</source>
          <target state="translated">源过滤器</target>
        </trans-unit>
        <trans-unit id="ade8f2661e9afaab2f2ac27ea8394747efc3b4bf" translate="yes" xml:space="preserve">
          <source>Source Handler</source>
          <target state="translated">源处理程序</target>
        </trans-unit>
        <trans-unit id="862ba12e5a4342d2fb92f862ee8e26706e1ba4d8" translate="yes" xml:space="preserve">
          <source>Source code locations, even if available, can often be missing or misleading if the compiler has e.g. inlined code. Optimizer can make matching the source code and the object code quite challenging.</source>
          <target state="translated">源代码的位置,即使有,如果编译器有例如内联代码,也会经常丢失或误导。优化器可以使源代码和对象代码的匹配变得相当具有挑战性。</target>
        </trans-unit>
        <trans-unit id="145cfa7abc78d317a3cc42e7465f11df70966408" translate="yes" xml:space="preserve">
          <source>Source detection stuff added by Steve Purkis</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0272509bdb0dc4d43ea57d6e30f085a388335e1" translate="yes" xml:space="preserve">
          <source>Source documentation is created by putting POD comments into the C source, like this:</source>
          <target state="translated">源码文档是通过将POD注释放入C源码中来创建的,比如这样。</target>
        </trans-unit>
        <trans-unit id="4e42a4c9cdabac1017a64b490d8e6fd830b2d27a" translate="yes" xml:space="preserve">
          <source>Source filtering is an immensely powerful feature of recent versions of Perl. It allows one to extend the language itself (e.g. the Switch module), to simplify the language (e.g. Language::Pythonesque), or to completely recast the language (e.g. Lingua::Romana::Perligata). Effectively, it allows one to use the full power of Perl as its own, recursively applied, macro language.</source>
          <target state="translated">源码过滤是Perl最新版本中一个非常强大的功能。它允许我们扩展语言本身(例如 Switch 模块),简化语言(例如 Language::Pythonesque),或者完全重构语言(例如 Lingua::Romana::Perligata)。实际上,它允许人们将Perl的全部功能作为自己的、递归应用的宏语言来使用。</target>
        </trans-unit>
        <trans-unit id="83fa9e2aac616eaf300f336da8ba4cb15a670bf8" translate="yes" xml:space="preserve">
          <source>Source filters activated within &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; leak out into whichever</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 激活的源过滤器泄漏到任何一个</target>
        </trans-unit>
        <trans-unit id="29b60a7012567152c7f8bb1a380fa37b7673b6a3" translate="yes" xml:space="preserve">
          <source>Source filters activated within &lt;code&gt;eval&lt;/code&gt; leak out into whichever file scope is currently being compiled. To give an example with the CPAN module &lt;a href=&quot;Semi::Semicolons&quot;&gt;Semi::Semicolons&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800c2a6e745195ecf7cc595cd16957a9d13fb318" translate="yes" xml:space="preserve">
          <source>Source filters activated within the evaluated code apply to the code itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4d1a2fe52cc093111f41dbe07243489fb88fda" translate="yes" xml:space="preserve">
          <source>Source filters apply only to byte streams</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23c4984b5ea778bfe1a620b2921096dd64ef1a0a" translate="yes" xml:space="preserve">
          <source>Source filters only work on the string level, thus are highly limited in its ability to change source code on the fly. It cannot detect comments, quoted strings, heredocs, it is no replacement for a real parser. The only stable usage for source filters are encryption, compression, or the byteloader, to translate binary code back to source code.</source>
          <target state="translated">源码过滤器只在字符串层面上工作,因此在快速改变源代码的能力上受到很大的限制,它不能检测注释、引用的字符串、heredocs,它不能取代真正的解析器。它不能检测注释、引用的字符串、heredocs,它不能替代真正的解析器。源码过滤器唯一稳定的用途是加密、压缩,或者字节加载器,将二进制代码翻译回源代码。</target>
        </trans-unit>
        <trans-unit id="80de4aac92ca7a214fcac217051e36befa5aa31a" translate="yes" xml:space="preserve">
          <source>Source for Perl documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf561fd42e8003d80556309fdb07a79bace6a7b" translate="yes" xml:space="preserve">
          <source>Source of the ISO 639-2 codes.</source>
          <target state="translated">ISO 639-2编码的来源。</target>
        </trans-unit>
        <trans-unit id="178db77b6a3b9b6df2ef880ae7bdafacae37b3c6" translate="yes" xml:space="preserve">
          <source>Source of the ISO 639-5 codes.</source>
          <target state="translated">ISO 639-5编码的来源。</target>
        </trans-unit>
        <trans-unit id="b69498a9aee25a26e6f9b5b4bc9ecc63222abc92" translate="yes" xml:space="preserve">
          <source>SourceHandler</source>
          <target state="translated">SourceHandler</target>
        </trans-unit>
        <trans-unit id="8644212c6ba60e5d4b37bed3eca56024c125205f" translate="yes" xml:space="preserve">
          <source>SourceHandlers</source>
          <target state="translated">SourceHandlers</target>
        </trans-unit>
        <trans-unit id="2eb56be3c2d93cdab0c52e677e3167dfddb30ac5" translate="yes" xml:space="preserve">
          <source>Sources</source>
          <target state="translated">Sources</target>
        </trans-unit>
        <trans-unit id="0933c3d8de99d538b1745c97c9ac4e0808ab779e" translate="yes" xml:space="preserve">
          <source>Sources of further information</source>
          <target state="translated">进一步的资料来源</target>
        </trans-unit>
        <trans-unit id="35fda17ff05f63e9061208c2dd2aaaf98790e921" translate="yes" xml:space="preserve">
          <source>South Africa</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ffb4c07982ffdd1d32da2ad256d5f400cca0af" translate="yes" xml:space="preserve">
          <source>South America</source>
          <target state="translated">南美</target>
        </trans-unit>
        <trans-unit id="ac6a60017b0bf8bff41d9bd208e6ef210c47fbdf" translate="yes" xml:space="preserve">
          <source>South Carolina</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f082fd9f31b253e1bc875b4f98b8b4196b3c96c9" translate="yes" xml:space="preserve">
          <source>Space after each comma.</source>
          <target state="translated">每个逗号后都有空格。</target>
        </trans-unit>
        <trans-unit id="b842d2b9fb013f376f25c0749d5ad88cdb3e09d2" translate="yes" xml:space="preserve">
          <source>Space after last parenthesis matching on current line.</source>
          <target state="translated">在当前行的最后一个小括号后留有空格。</target>
        </trans-unit>
        <trans-unit id="155b83258e151629b360ae86e49e0abf46f96413" translate="yes" xml:space="preserve">
          <source>Space around a &quot;complex&quot; subscript (inside brackets).</source>
          <target state="translated">在 &quot;复杂 &quot;的下标周围留出空间(括号内)。</target>
        </trans-unit>
        <trans-unit id="3f9d9d7fddff18fb290d25d4e2d47eb10b024565" translate="yes" xml:space="preserve">
          <source>Space around most operators.</source>
          <target state="translated">大多数运营商周围的空间。</target>
        </trans-unit>
        <trans-unit id="01ea9b6b043a2469906ded26f3a48de8eaf9e6e3" translate="yes" xml:space="preserve">
          <source>Space before the opening curly of a multi-line BLOCK.</source>
          <target state="translated">在多行BLOCK的开头大括号前的空格。</target>
        </trans-unit>
        <trans-unit id="1109418eced3ecb23f96484aec5504c863ea2053" translate="yes" xml:space="preserve">
          <source>Spaces in the argument delimit distinct patterns, so &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('*.exe *.dll')&lt;/code&gt; globs all filenames that end in &lt;code&gt;.exe&lt;/code&gt; or &lt;code&gt;.dll&lt;/code&gt;. If you want to put in literal spaces in the glob pattern, you can escape them with either double quotes, or backslashes. e.g. &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/&quot;Program Files&quot;/*/*.dll')&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/Program\ Files/*/*.dll')&lt;/code&gt; . The argument is tokenized using &lt;code&gt;Text::ParseWords::parse_line()&lt;/code&gt; , so see &lt;a href=&quot;../text/parsewords&quot;&gt;Text::ParseWords&lt;/a&gt; for details of the quoting rules used.</source>
          <target state="translated">参数中的空格分隔了不同的模式，因此 &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('*.exe *.dll')&lt;/code&gt; 会将以 &lt;code&gt;.exe&lt;/code&gt; 或 &lt;code&gt;.dll&lt;/code&gt; 结尾的所有文件名都作为glob。如果要在glob模式中放置文字空间，则可以使用双引号或反斜杠将其转义。例如 &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/&quot;Program Files&quot;/*/*.dll')&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/Program\ Files/*/*.dll')&lt;/code&gt; 。该参数使用 &lt;code&gt;Text::ParseWords::parse_line()&lt;/code&gt; 标记化，因此请参阅&lt;a href=&quot;../text/parsewords&quot;&gt;Text :: ParseWords&lt;/a&gt;以获取所用引号规则的详细信息。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
