<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="052319a3e5bb93ee7405765a73d430f34cc0defb" translate="yes" xml:space="preserve">
          <source>another simple word (note the lack of effect of the backslashed double-quote)</source>
          <target state="translated">再来一个简单的字</target>
        </trans-unit>
        <trans-unit id="49b2ac3b32339e34e4b9f904d93b48ebd2e613e1" translate="yes" xml:space="preserve">
          <source>ansi2knr.U</source>
          <target state="translated">ansi2knr.U</target>
        </trans-unit>
        <trans-unit id="c5fe0200d1c7a5139bd18fd22268c4ca8bf45e90" translate="yes" xml:space="preserve">
          <source>any</source>
          <target state="translated">any</target>
        </trans-unit>
        <trans-unit id="7696527a9b692224a3b35e3d1ce7238f165ab13d" translate="yes" xml:space="preserve">
          <source>any data associated with that attribute;</source>
          <target state="translated">与该属性相关的任何数据。</target>
        </trans-unit>
        <trans-unit id="9a459f25776e773a64e295d1cb084a05b171699e" translate="yes" xml:space="preserve">
          <source>any function in the DLL, just the act of loading this DLL will reset your flags. What is worse, the same compiler was used to compile some HOOK DLLs. Given that HOOK dlls are executed in the context of</source>
          <target state="translated">DLL中的任何函数,仅仅是加载这个DLL的行为就会重置你的标志。更糟糕的是,同样的编译器被用来编译一些HOOK DLLs。鉴于HOOK DLLs是在以下上下文中执行的</target>
        </trans-unit>
        <trans-unit id="e19bd065bb47fc295eafe4767c2de6b337ea119e" translate="yes" xml:space="preserve">
          <source>any leading &lt;code&gt;=&lt;/code&gt; prefix).</source>
          <target state="translated">任何前导 &lt;code&gt;=&lt;/code&gt; 前缀）。</target>
        </trans-unit>
        <trans-unit id="8b084990d915b056c34e7529bc336db861040427" translate="yes" xml:space="preserve">
          <source>any of the loaded</source>
          <target state="translated">任何一个加载</target>
        </trans-unit>
        <trans-unit id="78e16822f2fffca52176d34705897fa841dd6f90" translate="yes" xml:space="preserve">
          <source>any one</source>
          <target state="translated">任何一个</target>
        </trans-unit>
        <trans-unit id="f637daefbefeda9e4ed60d0501fba49913559846" translate="yes" xml:space="preserve">
          <source>any optional parameters that need to be sent to the filter. See the encode filter for an example of a module that uses parameters.</source>
          <target state="translated">任何需要发送给过滤器的可选参数。关于使用参数的模块,请参见编码过滤器的例子。</target>
        </trans-unit>
        <trans-unit id="42323bfecca119f546c25856e4f9be955460919c" translate="yes" xml:space="preserve">
          <source>any previous content in &lt;code&gt;$tar&lt;/code&gt; !</source>
          <target state="translated">&lt;code&gt;$tar&lt;/code&gt; 任何以前的内容！</target>
        </trans-unit>
        <trans-unit id="c9eb4e932e9bcc3bc1ece409a17107d5c50fed04" translate="yes" xml:space="preserve">
          <source>any starting with &lt;code&gt;(&lt;/code&gt;</source>
          <target state="translated">任何以 &lt;code&gt;(&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6a65efb0501666a4c913ea32a973da114f0ead8" translate="yes" xml:space="preserve">
          <source>any subroutine called from within that block</source>
          <target state="translated">任何从该程序块中调用的子程序</target>
        </trans-unit>
        <trans-unit id="035563ded8fdfc83ecef543e5bd6ec441f8b116a" translate="yes" xml:space="preserve">
          <source>anyinflate $input_filename_or_reference =&amp;gt; $output_filename_or_reference [, OPTS]</source>
          <target state="translated">anyinflate $ input_filename_or_reference =&amp;gt; $ output_filename_or_reference [，OPTS]</target>
        </trans-unit>
        <trans-unit id="8867c88b56e0bfb82cffaf15a66bc8d107d6754a" translate="yes" xml:space="preserve">
          <source>anything</source>
          <target state="translated">anything</target>
        </trans-unit>
        <trans-unit id="da86b2350d7133a0b9455e2c4cae962d691712b0" translate="yes" xml:space="preserve">
          <source>anything at all</source>
          <target state="translated">无所不至</target>
        </trans-unit>
        <trans-unit id="bd4f0e49dee0e1f5509e5161f80bbbbf9009690f" translate="yes" xml:space="preserve">
          <source>anything by default (because you don't want to surprise your users... badly)</source>
          <target state="translated">默认情况下,任何东西(因为你不想让你的用户感到惊讶......很糟糕)。</target>
        </trans-unit>
        <trans-unit id="3c305d671dd1d39b0b5796b00915162f7f25d581" translate="yes" xml:space="preserve">
          <source>anything else</source>
          <target state="translated">其他</target>
        </trans-unit>
        <trans-unit id="cad4d6d244c26510fb5dde9917efd285d64788e5" translate="yes" xml:space="preserve">
          <source>anything you don't need to (because less is more)</source>
          <target state="translated">无所不用其极</target>
        </trans-unit>
        <trans-unit id="faa4dad3e5b02731169057ea528c1d5f84a048de" translate="yes" xml:space="preserve">
          <source>anyuncompress $input_filename_or_reference =&amp;gt; $output_filename_or_reference [, OPTS]</source>
          <target state="translated">anyuncompress $ input_filename_or_reference =&amp;gt; $ output_filename_or_reference [，OPTS]</target>
        </trans-unit>
        <trans-unit id="66623d62c46dc1f443a91e7a202ce54689d760e0" translate="yes" xml:space="preserve">
          <source>anyway.</source>
          <target state="translated">anyway.</target>
        </trans-unit>
        <trans-unit id="112c2a063a0f6f3f9ba00da0de16624f951645e8" translate="yes" xml:space="preserve">
          <source>anywhere</source>
          <target state="translated">anywhere</target>
        </trans-unit>
        <trans-unit id="32e21d9b9cba5dad74e5e372580bff4069832094" translate="yes" xml:space="preserve">
          <source>appear as parameters to the Perl function. With the exception of &lt;code&gt;OUT&lt;/code&gt; -parameters, these parameters are converted to the corresponding C type, then pointers to these data are given as arguments to the C function. It is expected that the C function will write through these pointers.</source>
          <target state="translated">作为Perl函数的参数出现。除 &lt;code&gt;OUT&lt;/code&gt; 参数外，这些参数将转换为相应的C类型，然后将这些数据的指针作为C函数的参数给出。预期C函数将通过这些指针进行写入。</target>
        </trans-unit>
        <trans-unit id="24d201fd82f39662031e729d27fec76771838d92" translate="yes" xml:space="preserve">
          <source>appear in a package's &lt;code&gt;@ISA&lt;/code&gt; variable.</source>
          <target state="translated">出现在包的 &lt;code&gt;@ISA&lt;/code&gt; 变量中。</target>
        </trans-unit>
        <trans-unit id="ef5924a72dac5871eee278d0ded5dbd03cc1c19b" translate="yes" xml:space="preserve">
          <source>appear within the tagged text.</source>
          <target state="translated">出现在被标记的文本中。</target>
        </trans-unit>
        <trans-unit id="db43bff34c78044870bc6b1ae2aa16902bb1bb8a" translate="yes" xml:space="preserve">
          <source>append</source>
          <target state="translated">append</target>
        </trans-unit>
        <trans-unit id="d2005cc206ccbfdedf2be43a200cb050c538bdb5" translate="yes" xml:space="preserve">
          <source>application</source>
          <target state="translated">application</target>
        </trans-unit>
        <trans-unit id="3802a68da20f566d7fb269f15c34508be3676bf9" translate="yes" xml:space="preserve">
          <source>approximately</source>
          <target state="translated">approximately</target>
        </trans-unit>
        <trans-unit id="f8aca17f8dc62636fe56d26d991498181502da89" translate="yes" xml:space="preserve">
          <source>arch_check</source>
          <target state="translated">arch_check</target>
        </trans-unit>
        <trans-unit id="a07f43054e7ab8b8f32e28994504a2df3069bad6" translate="yes" xml:space="preserve">
          <source>archive if the crypt() function is not defined in the standard C library. It is up to the Makefile to use this.</source>
          <target state="translated">如果crypt()函数没有在标准C库中定义,那么就需要在Makefile中使用这个函数。这要由Makefile来决定是否使用。</target>
        </trans-unit>
        <trans-unit id="100ad6ee2f5499bff96b61a63b2efa0ea3981a7e" translate="yes" xml:space="preserve">
          <source>archlib.U</source>
          <target state="translated">archlib.U</target>
        </trans-unit>
        <trans-unit id="72b2a70ac7a2415a83e5898d42c24867ef6c76fb" translate="yes" xml:space="preserve">
          <source>archname.U</source>
          <target state="translated">archname.U</target>
        </trans-unit>
        <trans-unit id="d5067cf69455114e2110970315849096fa94f0fd" translate="yes" xml:space="preserve">
          <source>archname/</source>
          <target state="translated">archname/</target>
        </trans-unit>
        <trans-unit id="5f9e5802bbabc71f9275fccf122f5a52b8599f12" translate="yes" xml:space="preserve">
          <source>are</source>
          <target state="translated">are</target>
        </trans-unit>
        <trans-unit id="8dc07e958ba7e04dfd2e47ec804fc360ac6b560f" translate="yes" xml:space="preserve">
          <source>are 1, 224, 256, 384, 512, 512224, or 512256. It's also possible to use common string representations of the algorithm (e.g. &quot;sha256&quot;, &quot;SHA-384&quot;). If the argument is missing, SHA-1 will be used by default.</source>
          <target state="translated">是1、224、256、384、512、512224或512256。也可以使用算法的普通字符串表示(如 &quot;sha256&quot;、&quot;SHA-384&quot;)。如果缺少参数,默认使用SHA-1。</target>
        </trans-unit>
        <trans-unit id="b3e8825648e40951cf73eb803bb3033952b8d48a" translate="yes" xml:space="preserve">
          <source>are a collection of character code sets from the International Organization for Standardization (ISO), each of which adds characters to the ASCII set that are typically found in various languages, many of which are based on the Roman, or Latin, alphabet. Most are for European languages, but there are also ones for Arabic, Greek, Hebrew, and Thai. There are good references on the web about all these.</source>
          <target state="translated">是国际标准化组织(ISO)的字符代码集,每个字符代码集都在ASCII码集上添加了通常在各种语言中出现的字符,其中许多是基于罗马或拉丁字母表。大多数是针对欧洲语言的,但也有针对阿拉伯语、希腊语、希伯来语和泰语的。网上有很多关于这些的参考资料。</target>
        </trans-unit>
        <trans-unit id="de4fe4ffac933dfb4f0c5094e64bc601a7611806" translate="yes" xml:space="preserve">
          <source>are all equal.</source>
          <target state="translated">都是平等的。</target>
        </trans-unit>
        <trans-unit id="40cd33871ba50f9d26f25a0b0967a938c3c33a02" translate="yes" xml:space="preserve">
          <source>are allowed.</source>
          <target state="translated">允许。</target>
        </trans-unit>
        <trans-unit id="3e1131dc785866fbebf7ccb8d1293f801f197a2a" translate="yes" xml:space="preserve">
          <source>are also always exempt from such warnings.</source>
          <target state="translated">也总是免于这种警告。</target>
        </trans-unit>
        <trans-unit id="5fcbd6f84c4cae433390a20653865fe7ad335515" translate="yes" xml:space="preserve">
          <source>are also defined. Thus, &lt;code&gt;LATIN CAPITAL LETTER A WITH ACUTE&lt;/code&gt; is in</source>
          <target state="translated">也被定义。因此， &lt;code&gt;LATIN CAPITAL LETTER A WITH ACUTE&lt;/code&gt; 在</target>
        </trans-unit>
        <trans-unit id="770b01f5221d280697bb0ba87d0e2d9db74e1a94" translate="yes" xml:space="preserve">
          <source>are comic references to the egg-eating habits of the little-endian Lilliputians and the big-endian Blefuscudians from the classic Jonathan Swift satire,</source>
          <target state="translated">在经典的乔纳森-斯威夫特的讽刺小说中,以滑稽的方式引用了小甸子利利普特人和大甸子博莱福斯库德人的吃蛋习惯。</target>
        </trans-unit>
        <trans-unit id="daac3dfff48cc466d9ca23db01b2c0a1076fa335" translate="yes" xml:space="preserve">
          <source>are converted to all uppercase for look-up. Other than that, both of them follow &lt;a href=&quot;#LOOSE-MATCHES&quot;&gt;loose&lt;/a&gt; rules if &lt;code&gt;:loose&lt;/code&gt; is also specified; strict otherwise.</source>
          <target state="translated">转换为所有大写字母进行查找。除此之外，如果 &lt;code&gt;:loose&lt;/code&gt; 也被指定，它们都遵循&lt;a href=&quot;#LOOSE-MATCHES&quot;&gt;宽松的&lt;/a&gt;规则。否则严格。</target>
        </trans-unit>
        <trans-unit id="3ef4b9fd15129bb4ba23b3e2d5f6b2f50984d837" translate="yes" xml:space="preserve">
          <source>are deleted. (Note that this is slightly more flexible than the behavior of some &lt;b&gt;tr&lt;/b&gt; programs, which delete anything they find in the</source>
          <target state="translated">被删除。（请注意，这比某些&lt;b&gt;tr&lt;/b&gt;程序的行为稍微灵活一些，后者会删除它们在</target>
        </trans-unit>
        <trans-unit id="e553ec1da64a1470d4a07b9f0ea75b9f2786fbbc" translate="yes" xml:space="preserve">
          <source>are designed to test things that run thousands of times slower if a particular optimisation is broken (for example, the utf8 length cache on long utf8 strings). Add a test that will take a fraction of a second normally, and minutes otherwise, causing the test file to time out on failure.</source>
          <target state="translated">是为了测试如果某个优化被破坏,运行速度会慢上千倍的东西(比如长utf8字符串的utf8长度缓存)。增加一个测试,正常情况下需要几分之一秒,否则需要几分钟,导致测试文件失败时超时。</target>
        </trans-unit>
        <trans-unit id="7d19bbed1db5eb79730973a9f9a4bc06ef968d56" translate="yes" xml:space="preserve">
          <source>are exempt from warnings (because they care about truth rather than definedness). Operators such as &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;--&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , and &lt;code&gt;.=&lt;/code&gt; , that operate on undefined variables such as:</source>
          <target state="translated">免于警告（因为他们关心真理而不是定义）。诸如 &lt;code&gt;++&lt;/code&gt; ， &lt;code&gt;--&lt;/code&gt; ， &lt;code&gt;+=&lt;/code&gt; ， &lt;code&gt;-=&lt;/code&gt; 和 &lt;code&gt;.=&lt;/code&gt; 运算符可对未定义的变量进行运算，例如：</target>
        </trans-unit>
        <trans-unit id="5057aa4e52a95f389308d1244df9e17bc251d60c" translate="yes" xml:space="preserve">
          <source>are generated. If there are</source>
          <target state="translated">都会产生。如果有</target>
        </trans-unit>
        <trans-unit id="39e300e92d55897673ef91e24c657fab7d7f2f47" translate="yes" xml:space="preserve">
          <source>are hexadecimal digits, matches the character whose ordinal is</source>
          <target state="translated">是十六进制数字,与序数为_的字符相匹配。</target>
        </trans-unit>
        <trans-unit id="0396f8fab0fd4ee1179eee3502c230f019ae22d2" translate="yes" xml:space="preserve">
          <source>are in effect, &lt;code&gt;postprocess&lt;/code&gt; is a no-op.</source>
          <target state="translated">实际上， &lt;code&gt;postprocess&lt;/code&gt; 是不可操作的。</target>
        </trans-unit>
        <trans-unit id="570405f9be4be3ed167dfbbb5eecc3ddbaa2bed9" translate="yes" xml:space="preserve">
          <source>are in effect, &lt;code&gt;preprocess&lt;/code&gt; is a no-op.</source>
          <target state="translated">实际上， &lt;code&gt;preprocess&lt;/code&gt; 是不可操作的。</target>
        </trans-unit>
        <trans-unit id="fedda21f963002d22ee355f74566c5941f369717" translate="yes" xml:space="preserve">
          <source>are latitudes: zero at the North Pole, northward positive, southward negative. &lt;b&gt;NOTE&lt;/b&gt;: this formula thinks in mathematics, not geographically: the</source>
          <target state="translated">纬度：北极为零，北为正，南为负。&lt;b&gt;注意&lt;/b&gt;：此公式以数学方式而非地理方式考虑：</target>
        </trans-unit>
        <trans-unit id="a431c3157083cfaa848431ab6951d8e26a4c0c12" translate="yes" xml:space="preserve">
          <source>are longitudes: zero at the Greenwhich meridian, eastward positive, westward negative -- and the</source>
          <target state="translated">是经线:在格林威治子午线上为零,向东为正,向西为负-------------。</target>
        </trans-unit>
        <trans-unit id="609716f862354a27aae0296acc60afdae2c70a58" translate="yes" xml:space="preserve">
          <source>are not always present. The</source>
          <target state="translated">并非总是存在。的</target>
        </trans-unit>
        <trans-unit id="46c8feb754cc537b05ea38e46f4716d3389f6083" translate="yes" xml:space="preserve">
          <source>are not checked for taintedness. This requires extra carefulness unless you want external data to affect your control flow. Unless you carefully limit what these symbolic values are, people are able to call functions &lt;b&gt;outside&lt;/b&gt; your Perl code, such as POSIX::system, in which case they are able to run arbitrary external code.</source>
          <target state="translated">不检查污点。除非您希望外部数据影响控制流，否则这需要格外小心。除非您仔细限制这些符号值是什么，否则人们可以&lt;b&gt;在&lt;/b&gt; Perl代码&lt;b&gt;之外&lt;/b&gt;调用函数，例如POSIX :: system，在这种情况下，他们可以运行任意外部代码。</target>
        </trans-unit>
        <trans-unit id="5ccd41f08ede872f51066757b8c4ae13668882ad" translate="yes" xml:space="preserve">
          <source>are not equivalent;</source>
          <target state="translated">是不等价的。</target>
        </trans-unit>
        <trans-unit id="3dbd91a738da0c945eed880dcd55854536701ae2" translate="yes" xml:space="preserve">
          <source>are not implemented.</source>
          <target state="translated">不执行。</target>
        </trans-unit>
        <trans-unit id="d2b97aebc4deb474b3edf462a85d2011cb2609d5" translate="yes" xml:space="preserve">
          <source>are not present by default in compressed data streams. They must have been added explicitly when the data stream was created by calling &lt;code&gt;Compress::Deflate::flush&lt;/code&gt; with &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; .</source>
          <target state="translated">默认情况下，压缩数据流中不存在 在使用 &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; 调用 &lt;code&gt;Compress::Deflate::flush&lt;/code&gt; 创建数据流时，必须已明确添加它们。</target>
        </trans-unit>
        <trans-unit id="40db504d084e6e3300a4b8d81479b259b9880a4a" translate="yes" xml:space="preserve">
          <source>are not set.</source>
          <target state="translated">没有设置。</target>
        </trans-unit>
        <trans-unit id="1d74281d1301f35973cccef918ad9c2a8a370111" translate="yes" xml:space="preserve">
          <source>are numbers from 0 to 5 giving the intensity of red, green, and blue. &lt;code&gt;on_&lt;/code&gt; variants of all of these colors are also provided. These colors may be ignored completely on non-256-color terminals or may be misinterpreted and produce random behavior. Additional attributes such as blink, italic, or bold may not work with the 256-color palette.</source>
          <target state="translated">是从0到5的数字，给出红色，绿色和蓝色的强度。还提供所有这些颜色的 &lt;code&gt;on_&lt;/code&gt; 变体。这些颜色在非256色终端上可能会被完全忽略，或者可能会被误解并产生随机行为。诸如眨眼，斜体或粗体之类的其他属性可能不适用于256色调色板。</target>
        </trans-unit>
        <trans-unit id="ee047ace3155120c0c998a4fbef3fd51e859a9c4" translate="yes" xml:space="preserve">
          <source>are provided with &lt;code&gt;-MCross&lt;/code&gt; so to enable cross- compile.</source>
          <target state="translated">与 &lt;code&gt;-MCross&lt;/code&gt; 一起提供，以便启用交叉编译。</target>
        </trans-unit>
        <trans-unit id="fbbf84bcdae10459f4be5e4c43dfcd186671107d" translate="yes" xml:space="preserve">
          <source>are regular expressions, in the context of a larger regular expression, that function independently of the larger regular expression. That is, they consume as much or as little of the string as they wish without regard for the ability of the larger regexp to match. Independent subexpressions are represented by &lt;code&gt;(?&amp;gt;regexp)&lt;/code&gt;. We can illustrate their behavior by first considering an ordinary regexp:</source>
          <target state="translated">是在较大正则表达式的上下文中的正则表达式，其功能独立于较大正则表达式。也就是说，它们消耗了所希望的字符串的数量，而没有考虑较大的正则表达式进行匹配的能力。独立的子表达式由 &lt;code&gt;(?&amp;gt;regexp)&lt;/code&gt; 表示。我们可以通过首先考虑一个普通的正则表达式来说明它们的行为：</target>
        </trans-unit>
        <trans-unit id="bf6b8a83833152c05402e374a039993996c3a5f4" translate="yes" xml:space="preserve">
          <source>are relocated relative to the directory containing the perl binary, and a logical cleanup of the path is then made around the join point (removing</source>
          <target state="translated">被重新定位到包含perl二进制文件的目录下,然后在连接点周围对路径进行逻辑清理(去除</target>
        </trans-unit>
        <trans-unit id="c22d2121cf1ad3c9fdf597eb6ea7a9ec831c3008" translate="yes" xml:space="preserve">
          <source>are similar to these:</source>
          <target state="translated">与这些类似。</target>
        </trans-unit>
        <trans-unit id="5daee755ffcc3e1b323374ccd7080b09b7b8a3b2" translate="yes" xml:space="preserve">
          <source>are simply the file names of the test scripts to run.</source>
          <target state="translated">是要运行的测试脚本的简单文件名。</target>
        </trans-unit>
        <trans-unit id="097a56ab5012c31b2588a7fcf5955a17a3d173fe" translate="yes" xml:space="preserve">
          <source>are specified in the same way as command line options:</source>
          <target state="translated">与命令行选项的指定方式相同。</target>
        </trans-unit>
        <trans-unit id="78aee12896fca1df627811f8bc479814fea0b083" translate="yes" xml:space="preserve">
          <source>are subjected to double quote interpolation. That means that if you want to use variables, you must use an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">进行双引号内插。这意味着，如果要使用变量，则必须使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1660aa40e15fa486c99c667a79b0b660d94e44d8" translate="yes" xml:space="preserve">
          <source>are supported by a data structure called the</source>
          <target state="translated">的数据结构支持。</target>
        </trans-unit>
        <trans-unit id="b0525539dbfb2e75b20f33ebd3a32d8383ed15e2" translate="yes" xml:space="preserve">
          <source>are text editors for OS X that have a Perl sensitivity mode ( &lt;a href=&quot;http://www.barebones.com/&quot;&gt;http://www.barebones.com/&lt;/a&gt; ).</source>
          <target state="translated">是具有Perl敏感性模式（&lt;a href=&quot;http://www.barebones.com/&quot;&gt;http://www.barebones.com/&lt;/a&gt;）的OS X的文本编辑器。</target>
        </trans-unit>
        <trans-unit id="8f5de845a40e63e6edb669bb61faa6f919437589" translate="yes" xml:space="preserve">
          <source>are the list-type ops to concatenate.</source>
          <target state="translated">是要连接的列表型操作。</target>
        </trans-unit>
        <trans-unit id="7df1a21211f78189703a86e3cbb836a7e63fe998" translate="yes" xml:space="preserve">
          <source>are the range &lt;code&gt;U+D800..U+DBFF&lt;/code&gt; and the</source>
          <target state="translated">范围是 &lt;code&gt;U+D800..U+DBFF&lt;/code&gt; 和</target>
        </trans-unit>
        <trans-unit id="e10ada24dcf0e25f997bb273775bbfb50fbba99d" translate="yes" xml:space="preserve">
          <source>are the range &lt;code&gt;U+DC00..U+DFFF&lt;/code&gt; . The surrogate encoding is</source>
          <target state="translated">范围是 &lt;code&gt;U+DC00..U+DFFF&lt;/code&gt; 。替代编码为</target>
        </trans-unit>
        <trans-unit id="b02d00372e009301b6f76aac94b40c9dd1c62278" translate="yes" xml:space="preserve">
          <source>are treated as infinite loops.</source>
          <target state="translated">被视为无限循环。</target>
        </trans-unit>
        <trans-unit id="7ceaee791c3214e301c067af0fb90e4e9184e870" translate="yes" xml:space="preserve">
          <source>are used in absolutely incompatible manner. Parameters to these functions could be described &lt;b&gt;xsubpp&lt;/b&gt; like this:</source>
          <target state="translated">以绝对不兼容的方式使用。这些功能的参数可以这样描述&lt;b&gt;xsubpp&lt;/b&gt;：</target>
        </trans-unit>
        <trans-unit id="225abc0f937024b5e6707bd1f4cf5fc01203b6c7" translate="yes" xml:space="preserve">
          <source>are used to allow the calling code to think that there is only one such encoding. This is almost always referred to as &lt;code&gt;utf8&lt;/code&gt; , but it means the EBCDIC version as well. Again, comments in the code may well be wrong even if the code itself is right. For example, the concept of UTF-8 &lt;code&gt;invariant
characters&lt;/code&gt; differs between ASCII and EBCDIC. On ASCII platforms, only characters that do not have the high-order bit set (i.e. whose ordinals are strict ASCII, 0 - 127) are invariant, and the documentation and comments in the code may assume that, often referring to something like, say, &lt;code&gt;hibit&lt;/code&gt; . The situation differs and is not so simple on EBCDIC machines, but as long as the code itself uses the &lt;code&gt;NATIVE_IS_INVARIANT()&lt;/code&gt; macro appropriately, it works, even if the comments are wrong.</source>
          <target state="translated">用于允许调用代码认为只有一种这样的编码。几乎总是将其称为 &lt;code&gt;utf8&lt;/code&gt; ，但这也意味着EBCDIC版本。同样，即使代码本身是正确的，代码中的注释也很可能是错误的。例如，UTF-8 &lt;code&gt;invariant characters&lt;/code&gt; 的概念在ASCII和EBCDIC之间有所不同。在ASCII平台上，只有那些没有设置高阶位的字符（即，其序号是严格的ASCII，0-127）是不变的，并且代码中的文档和注释可能会假定，通常是指诸如， &lt;code&gt;hibit&lt;/code&gt; 。情况有所不同，在EBCDIC机器上并非如此简单，但是只要代码本身使用 &lt;code&gt;NATIVE_IS_INVARIANT()&lt;/code&gt; 宏，即使注释错误，它也可以正常工作。</target>
        </trans-unit>
        <trans-unit id="b5e6f047bd2af282863f2c0acfd2b4831e04019f" translate="yes" xml:space="preserve">
          <source>are used to refer to the relative positioning of the stack layers.</source>
          <target state="translated">用来表示堆栈层的相对位置。</target>
        </trans-unit>
        <trans-unit id="79c5c14521f2fdbf7474b004cb4f21e3735f3d69" translate="yes" xml:space="preserve">
          <source>are usually from the standards &lt;b&gt;ISO 3166&lt;/b&gt; and &lt;b&gt;ISO 639&lt;/b&gt;, the two-letter abbreviations for the countries and the languages of the world, respectively. The</source>
          <target state="translated">通常来自标准&lt;b&gt;ISO 3166&lt;/b&gt;和&lt;b&gt;ISO 639&lt;/b&gt;，这两个字母分别是国家和世界语言的缩写。的</target>
        </trans-unit>
        <trans-unit id="e6b83e0d18c05db2e099977bc4d92896d38a2907" translate="yes" xml:space="preserve">
          <source>are what is fed to &lt;code&gt;ok(...)&lt;/code&gt; if this test isn't skipped.</source>
          <target state="translated">如果不跳过此测试，将输入 &lt;code&gt;ok(...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="624cd1f425ffb0afe6e743d09639a61c5ac6e5af" translate="yes" xml:space="preserve">
          <source>aren't</source>
          <target state="translated">aren't</target>
        </trans-unit>
        <trans-unit id="04d6e2b300911995efa37b6707fdc02975a3021c" translate="yes" xml:space="preserve">
          <source>arg</source>
          <target state="translated">arg</target>
        </trans-unit>
        <trans-unit id="e044db5cacc7c1e1ded3c45fa7472331fe5e6246" translate="yes" xml:space="preserve">
          <source>arg1</source>
          <target state="translated">arg1</target>
        </trans-unit>
        <trans-unit id="b38facf4a8f9f6e8fc7192d1cbc326386647f4c1" translate="yes" xml:space="preserve">
          <source>arg2</source>
          <target state="translated">arg2</target>
        </trans-unit>
        <trans-unit id="3030e728f154bf51419109efb93b6b8aeec9a976" translate="yes" xml:space="preserve">
          <source>args</source>
          <target state="translated">args</target>
        </trans-unit>
        <trans-unit id="0f3802314d747bbc5016897875185c3a9fae57bf" translate="yes" xml:space="preserve">
          <source>argument</source>
          <target state="translated">argument</target>
        </trans-unit>
        <trans-unit id="d8d433b9ebc59257b2702d1e5069f881de7eb837" translate="yes" xml:space="preserve">
          <source>argument (using &lt;code&gt;threads::joinable&lt;/code&gt; ), returns a list of all non-joined, non-detached</source>
          <target state="translated">参数（使用 &lt;code&gt;threads::joinable&lt;/code&gt; ），返回所有未连接，未分离的列表</target>
        </trans-unit>
        <trans-unit id="75fa8514a906cf4d46ad0af7f07708ece0b99d60" translate="yes" xml:space="preserve">
          <source>argument (using &lt;code&gt;threads::running&lt;/code&gt; ), returns a list of all non-joined, non-detached</source>
          <target state="translated">参数（使用 &lt;code&gt;threads::running&lt;/code&gt; ），返回所有未连接，未分离的列表</target>
        </trans-unit>
        <trans-unit id="d3aa5b01cae682ed2f47655046c91faa406d82a7" translate="yes" xml:space="preserve">
          <source>argument is in the customary binary format used for Perl strings.</source>
          <target state="translated">参数是Perl字符串惯用的二进制格式。</target>
        </trans-unit>
        <trans-unit id="cd393b012062093f38db6d2b39b7ceda6271e2a9" translate="yes" xml:space="preserve">
          <source>argument specifies that &lt;code&gt;autosplit&lt;/code&gt; is to check the modification time of the module against that of the &lt;code&gt;autosplit.ix&lt;/code&gt; file, and only split the module if it is newer. $modtime defaults to 1.</source>
          <target state="translated">参数指定 &lt;code&gt;autosplit&lt;/code&gt; 将检查模块的修改时间与 &lt;code&gt;autosplit.ix&lt;/code&gt; 文件的修改时间，并且仅在更新时才拆分模块。$ modtime默认为1。</target>
        </trans-unit>
        <trans-unit id="1a29b569d43822c3afa1f10f2e311200106908b4" translate="yes" xml:space="preserve">
          <source>argument tells &lt;code&gt;Encode&lt;/code&gt; what to do when encountering malformed data. Without</source>
          <target state="translated">参数告诉 &lt;code&gt;Encode&lt;/code&gt; 遇到格式错误的数据时该怎么办。不带</target>
        </trans-unit>
        <trans-unit id="2e918e513d7e7933ffcc3b08aa036254e58b7109" translate="yes" xml:space="preserve">
          <source>argument to &lt;code&gt;when&lt;/code&gt; does is hard to describe precisely, but in general, it tries to guess what you want done. Sometimes it is interpreted as &lt;code&gt;$_ ~~ &lt;i&gt;EXPR&lt;/i&gt;&lt;/code&gt;, and sometimes it is not. It also behaves differently when lexically enclosed by a &lt;code&gt;given&lt;/code&gt; block than it does when dynamically enclosed by a &lt;code&gt;foreach&lt;/code&gt; loop. The rules are far too difficult to understand to be described here. See &lt;a href=&quot;#Experimental-Details-on-given-and-when&quot;&gt;Experimental Details on given and when&lt;/a&gt; later on.</source>
          <target state="translated">关于 &lt;code&gt;when&lt;/code&gt; 的说法很难准确描述，但总的来说，它会尝试猜测您想做什么。有时它被解释为 &lt;code&gt;$_ ~~ &lt;i&gt;EXPR&lt;/i&gt;&lt;/code&gt; ，有时不是。当用词法包围一个 &lt;code&gt;given&lt;/code&gt; 块时，它的行为也不同于用一个 &lt;code&gt;foreach&lt;/code&gt; 循环动态包围时的行为。这些规则太难理解了，无法在此处进行描述。请参阅&amp;ldquo; &lt;a href=&quot;#Experimental-Details-on-given-and-when&quot;&gt;实验详细信息&amp;rdquo;，以及&lt;/a&gt;之后的内容。</target>
        </trans-unit>
        <trans-unit id="e08f7198b54296915eb6e0097b8ceca98cfafe50" translate="yes" xml:space="preserve">
          <source>argument to one of the following values:</source>
          <target state="translated">参数改为下列数值之一:</target>
        </trans-unit>
        <trans-unit id="3abba5546715d0ff24cfa816d8610e27353a5e14" translate="yes" xml:space="preserve">
          <source>argument will be true if there is a layer below and that layer was expecting UTF-8.</source>
          <target state="translated">参数将为真,如果下面有一个层,而该层期望使用UTF-8。</target>
        </trans-unit>
        <trans-unit id="77d4f1467ed49524381be69d50a3bb40b010d3c6" translate="yes" xml:space="preserve">
          <source>argument, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; will cause only the thread to exit. With a</source>
          <target state="translated">参数， &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 将仅导致线程退出。用</target>
        </trans-unit>
        <trans-unit id="5e1a5dc31772bb5680208573714d0df8690531e4" translate="yes" xml:space="preserve">
          <source>argument, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; will terminate the application.</source>
          <target state="translated">参数， &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 将终止应用程序。</target>
        </trans-unit>
        <trans-unit id="11b4277f19e0685458402bdc5d7577a60a68c705" translate="yes" xml:space="preserve">
          <source>argument. For example, &lt;a href=&quot;encode/unicode&quot;&gt;Encode::Unicode&lt;/a&gt; ignores</source>
          <target state="translated">论据。例如，&lt;a href=&quot;encode/unicode&quot;&gt;Encode :: Unicode&lt;/a&gt;忽略</target>
        </trans-unit>
        <trans-unit id="d4da21b9484bced14bdff9911f748d00022f7cf3" translate="yes" xml:space="preserve">
          <source>argument. Use &lt;b&gt;-Ilib&lt;/b&gt;, for instance. &lt;b&gt;-I lib&lt;/b&gt; won't work.</source>
          <target state="translated">论据。例如，使用&lt;b&gt;-Ilib&lt;/b&gt;。&lt;b&gt;-我lib&lt;/b&gt;不会工作。</target>
        </trans-unit>
        <trans-unit id="9077da4d0275ca769922dd3ab43da95b6ef7b997" translate="yes" xml:space="preserve">
          <source>arguments are allowed, provided that</source>
          <target state="translated">参数是允许的,但前提是</target>
        </trans-unit>
        <trans-unit id="168293336923dcdfadd4e17664f5fabfcd3ee1d2" translate="yes" xml:space="preserve">
          <source>arguments can be ignored in most cases)</source>
          <target state="translated">参数在大多数情况下可以被忽略)</target>
        </trans-unit>
        <trans-unit id="a144cfdf650067c37a4a69dac8b434fbb91f984b" translate="yes" xml:space="preserve">
          <source>arguments have been parsed (so you can not change the way arguments are processed, sorry), typically with the &lt;code&gt;-P&lt;i&gt;plugin&lt;/i&gt;&lt;/code&gt; switch, eg:</source>
          <target state="translated">参数已解析（抱歉，您不能更改参数的处理方式），通常使用 &lt;code&gt;-P&lt;i&gt;plugin&lt;/i&gt;&lt;/code&gt; 开关，例如：</target>
        </trans-unit>
        <trans-unit id="93520313719be4cf49f3e938fc38e935e34348fd" translate="yes" xml:space="preserve">
          <source>argv[1]</source>
          <target state="translated">argv[1]</target>
        </trans-unit>
        <trans-unit id="405928ee9a480fc2a8eade49b14a897e6af33c76" translate="yes" xml:space="preserve">
          <source>around</source>
          <target state="translated">around</target>
        </trans-unit>
        <trans-unit id="d95e887f901f26e63014aa2cdccb63b7fb5f1815" translate="yes" xml:space="preserve">
          <source>around the subroutine call.</source>
          <target state="translated">围绕子程序调用。</target>
        </trans-unit>
        <trans-unit id="276700d738a08a17c36c325a79d878275e1e62b7" translate="yes" xml:space="preserve">
          <source>array ref is used to create a &lt;a href=&quot;parser/source&quot;&gt;TAP::Parser::Source&lt;/a&gt; that is passed to the &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt; which in turn figures out how to handle the source and creates a &amp;lt;TAP::Parser::Iterator&amp;gt; for it. The iterator is used by the parser to read in the TAP stream.</source>
          <target state="translated">数组引用用于创建传递给&lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt;的&lt;a href=&quot;parser/source&quot;&gt;TAP :: Parser :: Source&lt;/a&gt;，后者进而找出如何处理源并为其创建&amp;lt;TAP :: Parser :: Iterator&amp;gt;。解析器使用迭代器来读取TAP流。</target>
        </trans-unit>
        <trans-unit id="f007d443bf9be1cbb02a5647bc3ffc2ea4a7b0be" translate="yes" xml:space="preserve">
          <source>article about Maketext. It explains many important concepts underlying Locale::Maketext's design, and some insight into why Maketext is better than the plain old approach of having message catalogs that are just databases of sprintf formats.</source>
          <target state="translated">一篇关于Maketext的文章,它解释了Locale::Maketext设计的许多重要概念,以及为什么Maketext比普通的老式消息目录只是数据库的sprintf格式更好的一些见解。它解释了Locale::Maketext设计的许多重要概念,以及为什么Maketext比普通的消息目录(只是sprintf格式的数据库)更好的一些见解。</target>
        </trans-unit>
        <trans-unit id="c39354a2afa38bb8867edb6c280fc4691cf93e48" translate="yes" xml:space="preserve">
          <source>article in the &quot;Far More Than You Ever Wanted To Know&quot; collection in &lt;a href=&quot;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&quot;&gt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&lt;/a&gt; .</source>
          <target state="translated">&lt;a href=&quot;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&quot;&gt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz中&lt;/a&gt; &amp;ldquo;远比您想知道的更多&amp;rdquo;收藏中的文章。</target>
        </trans-unit>
        <trans-unit id="770bc2c07a08614cf46186cc798c253673fb1442" translate="yes" xml:space="preserve">
          <source>article in the &quot;Far More Than You Ever Wanted To Know&quot; collection in &lt;a href=&quot;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&quot;&gt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&lt;/a&gt; . To capture a command's STDERR and STDOUT together:</source>
          <target state="translated">&lt;a href=&quot;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&quot;&gt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&lt;/a&gt;中的&amp;ldquo;远比您想知道的要多&amp;rdquo;文章中的文章。一起捕获命令的STDERR和STDOUT：</target>
        </trans-unit>
        <trans-unit id="d63a2a6a0595f68a45646a780e4852db4b72a660" translate="yes" xml:space="preserve">
          <source>article in the &quot;Far More Than You Ever Wanted To Know&quot; collection in &lt;a href=&quot;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&quot;&gt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&lt;/a&gt; for more about this approach.</source>
          <target state="translated">有关此方法的更多信息，&lt;a href=&quot;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&quot;&gt;请参见http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz中&lt;/a&gt; &amp;ldquo;远比您想知道的要多&amp;rdquo;的文章。</target>
        </trans-unit>
        <trans-unit id="0791a67844c8f4efbe5e99ac3105cf46b29ab17a" translate="yes" xml:space="preserve">
          <source>article in the &quot;Far More Than You Ever Wanted To Know&quot; collection in &lt;a href=&quot;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&quot;&gt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&lt;/a&gt;, courtesy of Tom Phoenix, talks more about this. John von Neumann said, &quot;Anyone who attempts to generate random numbers by deterministic means is, of course, living in a state of sin.&quot;</source>
          <target state="translated">由Tom Phoenix提供的&lt;a href=&quot;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&quot;&gt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&lt;/a&gt;中的&amp;ldquo;远比您想知道的要多&amp;rdquo;文章中的文章对此进行了更多讨论。约翰&amp;middot;冯&amp;middot;诺依曼（John von Neumann）说：&amp;ldquo;任何试图通过确定性手段生成随机数的人，当然都处于犯罪状态。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="df211ccdd94a63e0bcb9e6ae427a249484a49d60" translate="yes" xml:space="preserve">
          <source>as</source>
          <target state="translated">as</target>
        </trans-unit>
        <trans-unit id="a65837ad13e0fdf78d35e16e571d952b5ff6f7e1" translate="yes" xml:space="preserve">
          <source>as &lt;code&gt;load&lt;/code&gt; will use &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; to determine the package.</source>
          <target state="translated">因为 &lt;code&gt;load&lt;/code&gt; 将使用 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 来确定程序包。</target>
        </trans-unit>
        <trans-unit id="54d62e679336367634a72a952dc99d5052db36db" translate="yes" xml:space="preserve">
          <source>as UTF-8. This takes into account if the call to the XS function is being made from within the scope of &lt;a href=&quot;bytes&quot;&gt;use bytes &lt;/a&gt;. If so, the underlying bytes that comprise the UTF-8 string are to be exposed, rather than the character they represent. But this pragma should only really be used for debugging and perhaps low-level testing at the byte level. Hence most XS code need not concern itself with this, but various areas of the perl core do need to support it.</source>
          <target state="translated">作为UTF-8。如果在&lt;a href=&quot;bytes&quot;&gt;使用字节&lt;/a&gt;范围内进行了对XS函数的调用，这将予以考虑。如果是这样，则要公开组成UTF-8字符串的基础字节，而不是它们所代表的字符。但是，该编译指示仅应真正用于字节级别的调试以及可能的低级别测试。因此，大多数XS代码不需要对此进行关注，但是perl内核的各个区域确实需要支持它。</target>
        </trans-unit>
        <trans-unit id="15cb6bc32b06c78e373977af44ccb471b3a1d4af" translate="yes" xml:space="preserve">
          <source>as a binary string of approximately 44 bytes which holds a set or zero or more operators.</source>
          <target state="translated">作为一个约44个字节的二进制字符串,其中包含一组或零个或多个运算符。</target>
        </trans-unit>
        <trans-unit id="49535962cebbc0ea94c6df25ea434365bc702259" translate="yes" xml:space="preserve">
          <source>as a hash itself, the only problem one has to circumvent is how to access this</source>
          <target state="translated">作为一个哈希本身,唯一要规避的问题是如何访问这个</target>
        </trans-unit>
        <trans-unit id="b3d154f01d41c1bc9eb1e234a00980811a7203a7" translate="yes" xml:space="preserve">
          <source>as a logical stream of bits, where each ASCII '0' or '1' character represents a 0 or 1 bit, respectively. All other characters are ignored. This provides a convenient way to calculate the digest values of partial-byte data by using files, rather than having to write separate programs employing the</source>
          <target state="translated">作为一个逻辑位流,其中每个ASCII'0'或'1'字符分别代表0或1位。所有其他字符都被忽略。这提供了一种方便的方法,通过使用文件来计算部分字节数据的摘要值,而不需要编写单独的程序来使用</target>
        </trans-unit>
        <trans-unit id="0484899da16ac25f9334dc3c0f326506de8f3b2a" translate="yes" xml:space="preserve">
          <source>as a module hierarchy name etc.</source>
          <target state="translated">作为模块的层次结构名称等。</target>
        </trans-unit>
        <trans-unit id="2595e4d12822845ad19e585d97389ce1ab042a19" translate="yes" xml:space="preserve">
          <source>as a module hierarchy name, etc.</source>
          <target state="translated">作为模块层次结构名称等。</target>
        </trans-unit>
        <trans-unit id="7489e1fa251bf45372d6ac9fae76ff03bb4fc00a" translate="yes" xml:space="preserve">
          <source>as a naive</source>
          <target state="translated">天真无邪</target>
        </trans-unit>
        <trans-unit id="74d1f75f898cb43e0472a9e5e56f2df27dec3699" translate="yes" xml:space="preserve">
          <source>as a regular expression.</source>
          <target state="translated">作为一个正则表达式。</target>
        </trans-unit>
        <trans-unit id="73ad2cf416dcc1436eb98bf0ea9e81a9ab178ed0" translate="yes" xml:space="preserve">
          <source>as a shell, thus I picked up &lt;code&gt;sh.exe&lt;/code&gt; . This assures almost 100% compatibility with the scripts coming from *nix. As an added benefit this works as well under DOS if you use DOS-enabled port of pdksh (see &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;).</source>
          <target state="translated">作为外壳，因此我选择了 &lt;code&gt;sh.exe&lt;/code&gt; 。这样可确保与来自* nix的脚本几乎100％兼容。另外一个好处是，如果使用pdksh的启用DOS的端口，则在DOS下也可以正常工作（请参阅&lt;a href=&quot;#Prerequisites&quot;&gt;先决条件&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7fc448ca1e6145126fcde1afbfc84e38e6144b79" translate="yes" xml:space="preserve">
          <source>as a temporary development aid while securing legacy code: for real production code and for new secure code written from scratch, always use the real &lt;b&gt;-T&lt;/b&gt;.</source>
          <target state="translated">作为保护旧代码的临时开发工具：对于真实的生产代码和从头开始编写的新安全代码，请始终使用real &lt;b&gt;-T&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="4ab073688be2687e53685015f7b0f7521b1bb83a" translate="yes" xml:space="preserve">
          <source>as after matching the A but failing on the B the &lt;code&gt;(*THEN)&lt;/code&gt; verb will backtrack and try C; but the &lt;code&gt;(*PRUNE)&lt;/code&gt; verb will simply fail.</source>
          <target state="translated">在匹配A但在B上失败后， &lt;code&gt;(*THEN)&lt;/code&gt; 动词将回溯并尝试C；但是 &lt;code&gt;(*PRUNE)&lt;/code&gt; 动词将完全失败。</target>
        </trans-unit>
        <trans-unit id="9753eb43e6b71481134609a83fe7c9d127007ad0" translate="yes" xml:space="preserve">
          <source>as an additional linker argument.</source>
          <target state="translated">作为一个额外的链接器参数。</target>
        </trans-unit>
        <trans-unit id="819da9a9443370e84fe6f05fc53d70984c447739" translate="yes" xml:space="preserve">
          <source>as an argument, and returns text to insert into the string instead of the &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; escape.</source>
          <target state="translated">作为参数，并返回要插入到字符串中的文本，而不是 &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; 转义。</target>
        </trans-unit>
        <trans-unit id="a1e4232743f22df2b484ab094b5e1490c15a9dc6" translate="yes" xml:space="preserve">
          <source>as an array reference (as in the original Tie::Cycle example at the start of this section).</source>
          <target state="translated">作为一个数组引用(就像本节开头的Tie::Cycle例子一样)。</target>
        </trans-unit>
        <trans-unit id="1fedb298f571e978a357461bbaffb88fd67e6d25" translate="yes" xml:space="preserve">
          <source>as an input to makefile.pl above. Here</source>
          <target state="translated">作为上面makefile.pl的输入。在这里</target>
        </trans-unit>
        <trans-unit id="22c9de0caa5ee810970ed637faf33df068656b95" translate="yes" xml:space="preserve">
          <source>as an instance method will reset the object to the initial state associated with</source>
          <target state="translated">作为一个实例方法,将对象重置为与</target>
        </trans-unit>
        <trans-unit id="fec541f105313d0d35c30d128259bc532a7d9fe9" translate="yes" xml:space="preserve">
          <source>as are these</source>
          <target state="translated">如同</target>
        </trans-unit>
        <trans-unit id="3f566ada162944f7b5c8044e94db8ddd5ca7b693" translate="yes" xml:space="preserve">
          <source>as being identical to calling &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode($fh)&lt;/a&gt;&lt;/code&gt; - the stream is made suitable for passing binary data, i.e. each byte is passed as-is. The stream will still be buffered.</source>
          <target state="translated">与调用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode($fh)&lt;/a&gt;&lt;/code&gt; -该流适用于传递二进制数据，即每个字节均按原样传递。流仍将被缓冲。</target>
        </trans-unit>
        <trans-unit id="fe36dc0e525faa7dfe808ab76ec97f002c503815" translate="yes" xml:space="preserve">
          <source>as characters in Perl's internal format. For example, to convert ISO-8859-1 data into Microsoft's CP1250 encoding:</source>
          <target state="translated">作为Perl内部格式的字符。例如,将 ISO-8859-1 数据转换为 Microsoft 的 CP1250 编码。</target>
        </trans-unit>
        <trans-unit id="52ad92a7cc1dc82c3b06fb1e695eb96d880a2a5a" translate="yes" xml:space="preserve">
          <source>as defined by ANSI C are</source>
          <target state="translated">由ANSI C定义的是</target>
        </trans-unit>
        <trans-unit id="0db0e3d07dd3b225f470aaeae03a367dc468530e" translate="yes" xml:space="preserve">
          <source>as described &lt;a href=&quot;#The-Generic-Object&quot;&gt;further down&lt;/a&gt;.</source>
          <target state="translated">如&lt;a href=&quot;#The-Generic-Object&quot;&gt;进一步&lt;/a&gt;所述。</target>
        </trans-unit>
        <trans-unit id="f8f8adcdf42c0a2a9a24916f1ba32a8d72714fa5" translate="yes" xml:space="preserve">
          <source>as expected. Without the specification of &lt;code&gt;&quot;&lt;/code&gt; as an embedded quoter:</source>
          <target state="translated">如预期的那样。没有将 &lt;code&gt;&quot;&lt;/code&gt; 为嵌入式引号：</target>
        </trans-unit>
        <trans-unit id="50b0ba5762dbe68ffeef1f2372b2155aab4b196b" translate="yes" xml:space="preserve">
          <source>as far as &lt;code&gt;CODE:&lt;/code&gt; section or &lt;code&gt;PPCODE:&lt;/code&gt; section</source>
          <target state="translated">至于 &lt;code&gt;CODE:&lt;/code&gt; 部分或 &lt;code&gt;PPCODE:&lt;/code&gt; 部分</target>
        </trans-unit>
        <trans-unit id="4baf8ad65f591cd293a9207d4c3e6ef80259ae5f" translate="yes" xml:space="preserve">
          <source>as far as you can in real-time.</source>
          <target state="translated">尽可能的实时。</target>
        </trans-unit>
        <trans-unit id="3f657c5685f4dbb2d51dff03864121342570902a" translate="yes" xml:space="preserve">
          <source>as follows). The name of suspects can either be canonical names or aliases.</source>
          <target state="translated">下同)。)嫌疑人的名字可以是正名,也可以是别名。</target>
        </trans-unit>
        <trans-unit id="44b2b85ecf80cc5b480b0158de904c01eefa0d24" translate="yes" xml:space="preserve">
          <source>as follows:</source>
          <target state="translated">以下是:</target>
        </trans-unit>
        <trans-unit id="ff4a3f206de020088e59ed005bda8b3029a132f8" translate="yes" xml:space="preserve">
          <source>as is</source>
          <target state="translated">照样</target>
        </trans-unit>
        <trans-unit id="7be0a48e6cca430c773cf99a10b3b59e7934ed11" translate="yes" xml:space="preserve">
          <source>as it feels like a bit of an ugly hack in its current form.</source>
          <target state="translated">因为感觉目前的形式有点像丑陋的黑客。</target>
        </trans-unit>
        <trans-unit id="878a917630b24304536b1a8522e60b14130b110d" translate="yes" xml:space="preserve">
          <source>as needed.</source>
          <target state="translated">根据需要。</target>
        </trans-unit>
        <trans-unit id="b51e507fa59a767444dbf1b962a404eb04a8e4aa" translate="yes" xml:space="preserve">
          <source>as part of the 'distdir' target (and thus the 'dist' target). This is intended to seamlessly and rapidly populate CPAN with module meta-data. If you wish to shut this feature off, set the &lt;code&gt;NO_META&lt;/code&gt;&lt;code&gt;WriteMakefile()&lt;/code&gt; flag to true.</source>
          <target state="translated">作为&amp;ldquo; distdir&amp;rdquo;目标（以及&amp;ldquo; dist&amp;rdquo;目标）的一部分。旨在用模块元数据无缝快速地填充CPAN。如果要关闭此功能，请将 &lt;code&gt;NO_META&lt;/code&gt; &lt;code&gt;WriteMakefile()&lt;/code&gt; 标志设置为true。</target>
        </trans-unit>
        <trans-unit id="1b4102fd0036fbd6a5a356f9ed338ac369433f6c" translate="yes" xml:space="preserve">
          <source>as passed in cannot be inferred from</source>
          <target state="translated">递进</target>
        </trans-unit>
        <trans-unit id="a2383664a361c0b34599be3f0ddacd7781220e2a" translate="yes" xml:space="preserve">
          <source>as returned by &lt;a href=&quot;#charblock()&quot;&gt;charblock()&lt;/a&gt; and &lt;a href=&quot;#charscript()&quot;&gt;charscript()&lt;/a&gt; or as the values of the hash returned by &lt;a href=&quot;#charblocks()&quot;&gt;charblocks()&lt;/a&gt; and &lt;a href=&quot;#charscripts()&quot;&gt;charscripts()&lt;/a&gt; by using &lt;code&gt;charinrange()&lt;/code&gt; :</source>
          <target state="translated">由&lt;a href=&quot;#charblock()&quot;&gt;charblock（）&lt;/a&gt;和&lt;a href=&quot;#charscript()&quot;&gt;charscript（）&lt;/a&gt;返回，&lt;a href=&quot;#charblocks()&quot;&gt;或&lt;/a&gt;通过使用 &lt;code&gt;charinrange()&lt;/code&gt; 由charblocks（）和&lt;a href=&quot;#charscripts()&quot;&gt;charscripts（）&lt;/a&gt;返回的哈希值：</target>
        </trans-unit>
        <trans-unit id="c83d44be22c0359c7a8a15302b7f5e83e6b94790" translate="yes" xml:space="preserve">
          <source>as shown below.</source>
          <target state="translated">如下图所示。</target>
        </trans-unit>
        <trans-unit id="6daf9fe089003e9cf65e42ff59a1d2773ab32262" translate="yes" xml:space="preserve">
          <source>as the first argument</source>
          <target state="translated">作为第一参数</target>
        </trans-unit>
        <trans-unit id="dcb44b7e0e1eb593d77c64f859e0a77259727455" translate="yes" xml:space="preserve">
          <source>as the first line in &lt;code&gt;*.cmd&lt;/code&gt; file (&lt;b&gt;-S&lt;/b&gt; due to a bug in cmd.exe's `extproc' handling).</source>
          <target state="translated">作为 &lt;code&gt;*.cmd&lt;/code&gt; 文件的第一行（&lt;b&gt;-S&lt;/b&gt;由于cmd.exe的'extproc'处理中的错误）。</target>
        </trans-unit>
        <trans-unit id="9afe0920031a79f7bd9f3454807b104ed19d1232" translate="yes" xml:space="preserve">
          <source>as the first line in &lt;code&gt;*.cmd&lt;/code&gt; file (&lt;code&gt;-S&lt;/code&gt; due to a bug in cmd.exe's &quot;extproc&quot; handling). For DOS one should first invent a corresponding batch file and codify it in &lt;code&gt;ALTERNATE_SHEBANG&lt;/code&gt; (see the</source>
          <target state="translated">作为 &lt;code&gt;*.cmd&lt;/code&gt; 文件中的第一行（ &lt;code&gt;-S&lt;/code&gt; 由于cmd.exe的&amp;ldquo; extproc&amp;rdquo;处理中的错误）。对于DOS，您应该首先发明一个相应的批处理文件并将其编入 &lt;code&gt;ALTERNATE_SHEBANG&lt;/code&gt; 中（请参阅</target>
        </trans-unit>
        <trans-unit id="aa88a9399009fa8389588f0aaf2da6151a41febb" translate="yes" xml:space="preserve">
          <source>as the first line instead. Or you can combine some of the above tricks:</source>
          <target state="translated">作为第一行。或者你也可以结合上面的一些技巧。</target>
        </trans-unit>
        <trans-unit id="0d88bf94a93a4b61f0fa92dfc15bfef6b4012493" translate="yes" xml:space="preserve">
          <source>as the first line of the handler (see &lt;a href=&quot;../perlvar#%24%5eS&quot;&gt;$^S in perlvar&lt;/a&gt;). Because this promotes strange action at a distance, this counterintuitive behavior may be fixed in a future release.</source>
          <target state="translated">作为处理程序的第一行（请参阅&lt;a href=&quot;../perlvar#%24%5eS&quot;&gt;perlvar中的$ ^ S&lt;/a&gt;）。因为这会在远处促进奇怪的动作，所以这种反直觉的行为可能会在以后的版本中修复。</target>
        </trans-unit>
        <trans-unit id="17abd9184d2928495e286f5f11862b4c9a8071d0" translate="yes" xml:space="preserve">
          <source>as the first line of the handler (see &lt;a href=&quot;perlvar#%24%5eS&quot;&gt;$^S in perlvar&lt;/a&gt;). Because this promotes strange action at a distance, this counterintuitive behavior may be fixed in a future release.</source>
          <target state="translated">作为处理程序的第一行（请参阅&lt;a href=&quot;perlvar#%24%5eS&quot;&gt;perlvar中的$ ^ S&lt;/a&gt;）。因为这会在远处促进奇怪的动作，所以这种反直觉的行为可能会在以后的版本中修复。</target>
        </trans-unit>
        <trans-unit id="bf7d822469082c4bfc650c2ae1a9bcefcadfb22e" translate="yes" xml:space="preserve">
          <source>as the key. In most cases, this contains only a few keys, but if Perl was invoked via the C &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec[lv]e()&lt;/a&gt;&lt;/code&gt; function, as is the case for some embedded Perl applications or when running under a shell such as GNV bash, the &lt;code&gt;environ&lt;/code&gt; array may have been populated by the calling program.</source>
          <target state="translated">作为关键。在大多数情况下，它仅包含几个键，但是如果通过C &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec[lv]e()&lt;/a&gt;&lt;/code&gt; 函数调用Perl ，则对于某些嵌入式Perl应用程序或在诸如GNV bash这样的shell下运行时， &lt;code&gt;environ&lt;/code&gt; 调用程序可能已填充了数组。</target>
        </trans-unit>
        <trans-unit id="5d01b7b2a5e71d9e7c928d505a1b934e42c98d8d" translate="yes" xml:space="preserve">
          <source>as the logical name. The normal search order of access modes is used.</source>
          <target state="translated">作为逻辑名称。采用正常的访问模式搜索顺序。</target>
        </trans-unit>
        <trans-unit id="24bb2a3db47e83fda820245153deab8162cb8ccb" translate="yes" xml:space="preserve">
          <source>as the name of the symbol. When reading an element of &lt;code&gt;%ENV&lt;/code&gt; , the local symbol table is scanned first, followed by the global symbol table.. The characters following &lt;code&gt;CLISYM_&lt;/code&gt; are significant when an element of &lt;code&gt;%ENV&lt;/code&gt; is set or deleted: if the complete string is &lt;code&gt;CLISYM_LOCAL&lt;/code&gt; , the change is made in the local symbol table; otherwise the global symbol table is changed.</source>
          <target state="translated">作为符号名称。读取 &lt;code&gt;%ENV&lt;/code&gt; 元素时，将先扫描本地符号表，然后扫描全局符号表。当设置或删除 &lt;code&gt;%ENV&lt;/code&gt; 元素时， &lt;code&gt;CLISYM_&lt;/code&gt; 之后的字符很重要：如果完整的字符串是 &lt;code&gt;CLISYM_LOCAL&lt;/code&gt; ，则更改在本地符号表中创建；否则，全局符号表将更改。</target>
        </trans-unit>
        <trans-unit id="43689b10d7e82ce746d34de5bbe78235ef4476bd" translate="yes" xml:space="preserve">
          <source>as though the argument to &lt;code&gt;given&lt;/code&gt; were an element of the hash &lt;code&gt;%foo&lt;/code&gt; , interpreting the braces as hash-element syntax.</source>
          <target state="translated">好像给 &lt;code&gt;given&lt;/code&gt; 的参数是哈希 &lt;code&gt;%foo&lt;/code&gt; 的元素，将花括号解释为哈希元素语法。</target>
        </trans-unit>
        <trans-unit id="9aa9ebca57db525b108992870f6a6a0744343a91" translate="yes" xml:space="preserve">
          <source>as though you stored the same variable reference each time, you actually did not! This is a subtle distinction that can produce more efficient code at the risk of misleading all but the most experienced of programmers. So I usually advise against teaching it to beginners. In fact, except for passing arguments to functions, I seldom like to see the gimme-a-reference operator (backslash) used much at all in code. Instead, I advise beginners that they (and most of the rest of us) should try to use the much more easily understood constructors &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt; instead of relying upon lexical (or dynamic) scoping and hidden reference-counting to do the right thing behind the scenes.</source>
          <target state="translated">就像您每次都存储相同的变量引用一样，实际上您没有！这是一个微妙的区别，可以产生更有效的代码，但会误导除最有经验的程序员之外的所有程序员。因此，我通常建议不要将其教给初学者。实际上，除了将参数传递给函数外，我很少喜欢看到gimme-a-reference运算符（反斜杠）在代码中使用了很多。相反，我建议初学者，他们（以及我们大多数人）应该尝试使用更容易理解的构造函数 &lt;code&gt;[]&lt;/code&gt; 和 &lt;code&gt;{}&lt;/code&gt; ,而不要依靠词汇（或动态）作用域和隐藏的引用计数来做正确的事幕后的事情。</target>
        </trans-unit>
        <trans-unit id="1b721d8a6c65b8f505bf083f7362443eee48e0d5" translate="yes" xml:space="preserve">
          <source>as used in</source>
          <target state="translated">所用</target>
        </trans-unit>
        <trans-unit id="73b20ad0fd8d8906b930c36d48ac0a852e8a70ab" translate="yes" xml:space="preserve">
          <source>as usual</source>
          <target state="translated">照例</target>
        </trans-unit>
        <trans-unit id="9fa196bf1305f9de2ff08f52aee250714a733647" translate="yes" xml:space="preserve">
          <source>as we know that if the final quote does not match, backtracking will not help. See the independent subexpression &lt;a href=&quot;#(%3f%3epattern)&quot;&gt;(?&amp;gt;pattern)&lt;/a&gt; for more details; possessive quantifiers are just syntactic sugar for that construct. For instance the above example could also be written as follows:</source>
          <target state="translated">我们知道，如果最终报价不匹配，回溯将无济于事。有关更多详细信息，请参见独立子表达式&lt;a href=&quot;#(%3f%3epattern)&quot;&gt;（？&amp;gt; pattern）&lt;/a&gt;。所有格量词只是该构造的语法糖。例如，上面的示例也可以编写如下：</target>
        </trans-unit>
        <trans-unit id="983291ad5e53a2455ef9e77e2de94ef019d4ba61" translate="yes" xml:space="preserve">
          <source>as well (I use one from pdksh). The path</source>
          <target state="translated">也是(我用的是pdksh的)。路径</target>
        </trans-unit>
        <trans-unit id="ffcbb6274e566044113aaf2e534009b9310ede89" translate="yes" xml:space="preserve">
          <source>as well.</source>
          <target state="translated">也是。</target>
        </trans-unit>
        <trans-unit id="0b2d56ecd63cccc527289487cbff82b5288f062d" translate="yes" xml:space="preserve">
          <source>as well. Here's a sample entry from that table:</source>
          <target state="translated">也是。下面是该表的一个样本条目。</target>
        </trans-unit>
        <trans-unit id="163b9e6ac2b85e0d1d3b25a5f039388d7483329f" translate="yes" xml:space="preserve">
          <source>as well. Options are not necessary for the program to work, hence the name 'option', but are used to modify its default behaviour. For example, a program could do its job quietly, but with a suitable option it could provide verbose information about what it did.</source>
          <target state="translated">也是。选项并不是程序工作的必要条件,因此被称为 &quot;选项&quot;,而是用来修改程序的默认行为。例如,一个程序可以静静地做它的工作,但如果有一个合适的选项,它可以提供关于它所做的工作的详细信息。</target>
        </trans-unit>
        <trans-unit id="e0f6619c3a0d789145899e0d26503b93025880f2" translate="yes" xml:space="preserve">
          <source>as_bin()</source>
          <target state="translated">as_bin()</target>
        </trans-unit>
        <trans-unit id="6293714a50a40120f58b4889cff9a65fc732965e" translate="yes" xml:space="preserve">
          <source>as_float()</source>
          <target state="translated">as_float()</target>
        </trans-unit>
        <trans-unit id="c3bc5083cb007923550a1a79fad46180e4d878d7" translate="yes" xml:space="preserve">
          <source>as_hex()</source>
          <target state="translated">as_hex()</target>
        </trans-unit>
        <trans-unit id="003d7a49b767183e39c1b831d4ce7263b750ea27" translate="yes" xml:space="preserve">
          <source>as_int()/as_number()</source>
          <target state="translated">as_int()/as_number()</target>
        </trans-unit>
        <trans-unit id="1200fa194bbc6cba8352b08f67c5ac42078a226e" translate="yes" xml:space="preserve">
          <source>as_oct()</source>
          <target state="translated">as_oct()</target>
        </trans-unit>
        <trans-unit id="ce10f51d7f39f9fc7631435563d91f1e2dd622f5" translate="yes" xml:space="preserve">
          <source>ask DB not to stop in these packages</source>
          <target state="translated">要求DB不要停在这些包里</target>
        </trans-unit>
        <trans-unit id="c4407719eccaafa9bde053b1db60d6c0d61f7672" translate="yes" xml:space="preserve">
          <source>assigned</source>
          <target state="translated">assigned</target>
        </trans-unit>
        <trans-unit id="18237e23354148ad3de3fd278a74bf877d784ef2" translate="yes" xml:space="preserve">
          <source>assignment-variants of operators are present in the script, they may be generated by the optimizer. For example,</source>
          <target state="translated">运算符的赋值变体存在于脚本中,它们可以由优化器生成。例如</target>
        </trans-unit>
        <trans-unit id="19f88cb673e51233787f63a133933b396397ecad" translate="yes" xml:space="preserve">
          <source>assigns the entire list value to array @foo, but</source>
          <target state="translated">将整个列表的值分配给数组@foo,但是</target>
        </trans-unit>
        <trans-unit id="bac4a6a253f6704e2643e1787606b1818276ab16" translate="yes" xml:space="preserve">
          <source>assigns the value of variable $bar to the scalar variable $foo. Note that the value of an actual array in scalar context is the length of the array; the following assigns the value 3 to $foo:</source>
          <target state="translated">将变量$bar的值赋给标量变量$foo。请注意,在标量上下文中,实际数组的值是数组的长度;下面将值3赋给$foo。</target>
        </trans-unit>
        <trans-unit id="a2c480bb0d3fb166118fff165602dfb3d8755b71" translate="yes" xml:space="preserve">
          <source>associated with a particular file.</source>
          <target state="translated">与特定文件相关联。</target>
        </trans-unit>
        <trans-unit id="d03fe2e108278a21db78ad03f95614754c65b243" translate="yes" xml:space="preserve">
          <source>associations</source>
          <target state="translated">associations</target>
        </trans-unit>
        <trans-unit id="ae321c05bada36b13f653e5d63881d2980254f64" translate="yes" xml:space="preserve">
          <source>assumes that either the layer has popped itself, or the layer is super special and needs to be retained for other reasons. In most cases it should return</source>
          <target state="translated">假设这个图层是自己弹出的,或者这个图层是超级特殊的,因为其他原因需要保留。在大多数情况下,它应该返回</target>
        </trans-unit>
        <trans-unit id="617755c776549d8f4f3362cdb6a17b675ef13281" translate="yes" xml:space="preserve">
          <source>assuming you have mounted that CD on /cdrom.</source>
          <target state="translated">假设你已经将光盘挂载在/cdrom上。</target>
        </trans-unit>
        <trans-unit id="3602b9270e66ab97788614f8a3fd98920bdaf5c7" translate="yes" xml:space="preserve">
          <source>at &lt;a href=&quot;http://developer.apple.com/documentation/Darwin/Conceptual/64bitPorting/index.html&quot;&gt;http://developer.apple.com/documentation/Darwin/Conceptual/64bitPorting/index.html&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;http://developer.apple.com/documentation/Darwin/Conceptual/64bitPorting/index.html&quot;&gt;http://developer.apple.com/documentation/Darwin/Conceptual/64bitPorting/index.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="412f08a017337a56b4152e7bc3cd13375ff3254f" translate="yes" xml:space="preserve">
          <source>at &lt;a href=&quot;http://perltraining.com.au/tips/2008-08-20.html&quot;&gt;http://perltraining.com.au/tips/2008-08-20.html&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;http://perltraining.com.au/tips/2008-08-20.html&quot;&gt;http://perltraining.com.au/tips/2008-08-20.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="763fd237e6f3831141eb71f2fa9c664c2d5dde22" translate="yes" xml:space="preserve">
          <source>at a given position</source>
          <target state="translated">在某一位置</target>
        </trans-unit>
        <trans-unit id="9a37607749afe8d9567c08deb31e518558e6f3b5" translate="yes" xml:space="preserve">
          <source>at any one time.</source>
          <target state="translated">在任何时候。</target>
        </trans-unit>
        <trans-unit id="850ad5d4afbea97738fa95acd1da7e607bd530cc" translate="yes" xml:space="preserve">
          <source>at compile time</source>
          <target state="translated">在编译时</target>
        </trans-unit>
        <trans-unit id="b4e380389a774a586c5fa16ad6f747ccd0f5dd49" translate="yes" xml:space="preserve">
          <source>at least</source>
          <target state="translated">起码</target>
        </trans-unit>
        <trans-unit id="9564a8b2dea482cb502ddc133f411fb7baa8cd10" translate="yes" xml:space="preserve">
          <source>at make time, so you should make perl to follow this along.</source>
          <target state="translated">在make的时候,所以你应该让perl按照这个来做。</target>
        </trans-unit>
        <trans-unit id="32f22c8244d7198bc5973a52b7e608dea1b695bc" translate="yes" xml:space="preserve">
          <source>at run time</source>
          <target state="translated">在运行时</target>
        </trans-unit>
        <trans-unit id="e490f3a80d5cc3f15d3885d16099e39047e2c3bc" translate="yes" xml:space="preserve">
          <source>at startup (in a BEGIN block). This is a hook that allows the sysadmin to customize how Perl behaves. It can for instance be used to add entries to the @INC array to make Perl find modules in non-standard locations.</source>
          <target state="translated">(在BEGIN块中)。这是一个允许系统管理员自定义 Perl 行为的钩子。例如,它可以用来为 @INC 数组添加条目,使 Perl 能够在非标准位置找到模块。</target>
        </trans-unit>
        <trans-unit id="15d1d5e3a86f87da2663eae7907bc2307a399554" translate="yes" xml:space="preserve">
          <source>at startup.</source>
          <target state="translated">在启动时。</target>
        </trans-unit>
        <trans-unit id="fdc8cfe05d049efd8ba3e7434e7eaf619158eb0f" translate="yes" xml:space="preserve">
          <source>at the C level</source>
          <target state="translated">在C级</target>
        </trans-unit>
        <trans-unit id="c1388282fa974c0f59a57d7833efecdf9f582735" translate="yes" xml:space="preserve">
          <source>at the end</source>
          <target state="translated">到了</target>
        </trans-unit>
        <trans-unit id="9217e9b0a48bcfc528a9d49dbdf842dbf2a6a760" translate="yes" xml:space="preserve">
          <source>at the end. The &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;SAVETMPS&lt;/code&gt; pair creates a boundary for any temporaries we create. This means that the temporaries we get rid of will be limited to those which were created after these calls.</source>
          <target state="translated">在末尾。该 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;SAVETMPS&lt;/code&gt; 对创建我们创建任何的临时边界。这意味着我们摆脱的临时人员将仅限于这些调用之后创建的临时人员。</target>
        </trans-unit>
        <trans-unit id="8dcfd128d2ba54e6c9380293b323b1260cdc3701" translate="yes" xml:space="preserve">
          <source>at the same level of nesting</source>
          <target state="translated">同级嵌套</target>
        </trans-unit>
        <trans-unit id="8e1733375a8dd981de1735fa2875f132e477b6da" translate="yes" xml:space="preserve">
          <source>at the start (or near the start) of your program. (Note that this</source>
          <target state="translated">在你的程序开始时(或接近开始时)。(注意,这个</target>
        </trans-unit>
        <trans-unit id="37f302ce8124164c6fcfe7d012fcfb1e33675294" translate="yes" xml:space="preserve">
          <source>at the start of the function, and</source>
          <target state="translated">在函数开始时,和</target>
        </trans-unit>
        <trans-unit id="9b151ca84837e5f88e85ae049f9b552e13c6fe0d" translate="yes" xml:space="preserve">
          <source>at the top of your code.</source>
          <target state="translated">在你的代码顶部。</target>
        </trans-unit>
        <trans-unit id="89c4f7ac43cc28c22dbb5ebc96fabde7dae0b382" translate="yes" xml:space="preserve">
          <source>at the top of your program, where &lt;b&gt;-mysw&lt;/b&gt; are any command line switches you want to pass to Perl. You can now invoke the program directly, by saying &lt;code&gt;perl program&lt;/code&gt; , or as a DCL procedure, by saying &lt;code&gt;@program&lt;/code&gt; (or implicitly via</source>
          <target state="translated">在程序的顶部，&lt;b&gt;-mysw&lt;/b&gt;是要传递给Perl的任何命令行开关。现在，您可以通过说出 &lt;code&gt;perl program&lt;/code&gt; program来直接调用程序，或者通过说出 &lt;code&gt;@program&lt;/code&gt; （或通过</target>
        </trans-unit>
        <trans-unit id="7e70d57f73905d45b6f79912c7b2b82874d2e8a5" translate="yes" xml:space="preserve">
          <source>at the top of your program. This aliases all the short names to the long names in the current package. Some even have medium names, generally borrowed from &lt;b&gt;awk&lt;/b&gt;. For more info, please see &lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;.</source>
          <target state="translated">在程序的顶部。这会将所有短名称都别名为当前包中的长名称。有些甚至具有中等名称，通常是从&lt;b&gt;awk&lt;/b&gt;借来的。有关更多信息，请参见&lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c4d67f365ec49b947ee79badac65584b0444347" translate="yes" xml:space="preserve">
          <source>at the top of your script, Math::BigFloat and Math::BigInt will be loaded and any constant number will be converted to an object (Math::BigFloat for floats like 3.1415 and Math::BigInt for integers like 1234).</source>
          <target state="translated">在你的脚本顶部,Math::BigFloat 和 Math::BigInt 将被加载,任何常数都将被转换为对象(Math::BigFloat 用于浮动数,如 3.1415,Math::BigInt 用于整数,如 1234)。</target>
        </trans-unit>
        <trans-unit id="c90414cee16b2af97b8d5180cc885c0f62d6800c" translate="yes" xml:space="preserve">
          <source>at which point %greetings has the contents:</source>
          <target state="translated">这时%greetings的内容。</target>
        </trans-unit>
        <trans-unit id="3bb758cfc583548bd5a6d49b0a553b6fe91a0689" translate="yes" xml:space="preserve">
          <source>at your peril</source>
          <target state="translated">妄自菲薄</target>
        </trans-unit>
        <trans-unit id="b1a7357ef61ecd1781b4633dc3e33a383686041c" translate="yes" xml:space="preserve">
          <source>atan2</source>
          <target state="translated">atan2</target>
        </trans-unit>
        <trans-unit id="fc337a53ff380e9cc91c7f4ada35b7c83e1170cd" translate="yes" xml:space="preserve">
          <source>atan2 Y,X</source>
          <target state="translated">atan2 Y,X</target>
        </trans-unit>
        <trans-unit id="5604a15f93274b4be18e2e5703972fcae8d4191f" translate="yes" xml:space="preserve">
          <source>atolf.U</source>
          <target state="translated">atolf.U</target>
        </trans-unit>
        <trans-unit id="20378f82e37925c4f68137e0b5f0ceba9d2f7e7d" translate="yes" xml:space="preserve">
          <source>atoll.U</source>
          <target state="translated">atoll.U</target>
        </trans-unit>
        <trans-unit id="aaa7447496328d92dc17c3d0fc8649f8ad7d1856" translate="yes" xml:space="preserve">
          <source>attribute for this start-token object to</source>
          <target state="translated">属性,将这个起始标记对象的</target>
        </trans-unit>
        <trans-unit id="33337ed515c0adfa6a07049f9d97abb273869d7a" translate="yes" xml:space="preserve">
          <source>attribute for this start-token object, or undef.</source>
          <target state="translated">属性,或者undef。</target>
        </trans-unit>
        <trans-unit id="d7f67a250d8254339cc572b200990d99fe1baf29" translate="yes" xml:space="preserve">
          <source>attributes</source>
          <target state="translated">attributes</target>
        </trans-unit>
        <trans-unit id="247d5e69b38550a7d0b09aea424ed5dab3a67bad" translate="yes" xml:space="preserve">
          <source>attributes - get/set subroutine or variable attributes</source>
          <target state="translated">attributes-获取/设置子程序或变量属性。</target>
        </trans-unit>
        <trans-unit id="6c96eab257b4cf4e5e658df68be3609a71585745" translate="yes" xml:space="preserve">
          <source>attrname</source>
          <target state="translated">attrname</target>
        </trans-unit>
        <trans-unit id="480abf89fe2d1830b23e7098edc6d51d774d0c2a" translate="yes" xml:space="preserve">
          <source>authors/id/TOMC/scripts/nshist.gz</source>
          <target state="translated">authors/id/TOMC/scripts/nshist.gz</target>
        </trans-unit>
        <trans-unit id="c33fcb6996455fe1e1fa0a761ee443d59c481aa3" translate="yes" xml:space="preserve">
          <source>auto/</source>
          <target state="translated">auto/</target>
        </trans-unit>
        <trans-unit id="379a77c54f6ae1790a2244a0d2c048af4e634475" translate="yes" xml:space="preserve">
          <source>auto/$module/$module.bs</source>
          <target state="translated">auto/$module/$module.bs</target>
        </trans-unit>
        <trans-unit id="220e6841a8a7621c4a89ea7b80f1f146f73eaf9b" translate="yes" xml:space="preserve">
          <source>auto/DBD/Oracle/Oracle.a</source>
          <target state="translated">auto/DBD/Oracle/Oracle.a</target>
        </trans-unit>
        <trans-unit id="51ebf6d6fd8909a977306dd245925df9ee90fd5f" translate="yes" xml:space="preserve">
          <source>auto/Foo/*.mo</source>
          <target state="translated">auto/Foo/*.mo</target>
        </trans-unit>
        <trans-unit id="e694098f1cf7520142821fcc984e3d661c44f43f" translate="yes" xml:space="preserve">
          <source>auto/Foo/*.po</source>
          <target state="translated">auto/Foo/*.po</target>
        </trans-unit>
        <trans-unit id="3c5e43613cff090be4fc50d8ae5dd6d77a6b436a" translate="yes" xml:space="preserve">
          <source>auto/Socket/Socket.a</source>
          <target state="translated">auto/Socket/Socket.a</target>
        </trans-unit>
        <trans-unit id="2be06c1e85af3aeda93bd94fc5f8c8f0ca1a6fcf" translate="yes" xml:space="preserve">
          <source>auto/Socket/Socket.so</source>
          <target state="translated">auto/Socket/Socket.so</target>
        </trans-unit>
        <trans-unit id="0159b1c4926c7d3e58575705e2b2446e2f089413" translate="yes" xml:space="preserve">
          <source>auto/funcname.al</source>
          <target state="translated">auto/funcname.al</target>
        </trans-unit>
        <trans-unit id="29dbf9fbbc1982eb3494d98a1ba20678ee1cd75a" translate="yes" xml:space="preserve">
          <source>autobundle</source>
          <target state="translated">autobundle</target>
        </trans-unit>
        <trans-unit id="d7fdb81095b8f0d754d3385c78ee0178778a27e1" translate="yes" xml:space="preserve">
          <source>autochomp</source>
          <target state="translated">autochomp</target>
        </trans-unit>
        <trans-unit id="a577d5867e3da0a70fe888d4e799c74e3bb3acee" translate="yes" xml:space="preserve">
          <source>autodie</source>
          <target state="translated">autodie</target>
        </trans-unit>
        <trans-unit id="3d06c1fb0d41b3bcd406473263f2d39a8385f847" translate="yes" xml:space="preserve">
          <source>autodie - Replace functions with ones that succeed or die with lexical scope</source>
          <target state="translated">autodie-用具有词法范围的成功或失败的函数来代替函数。</target>
        </trans-unit>
        <trans-unit id="a11d8629a6714617f42a511f4ed6cd917d35963b" translate="yes" xml:space="preserve">
          <source>autodie and string eval</source>
          <target state="translated">自动识别和字符串评估</target>
        </trans-unit>
        <trans-unit id="7554acb29f084d6cb46fbc0e7508ae57a54cbdfc" translate="yes" xml:space="preserve">
          <source>autoexec.bat</source>
          <target state="translated">autoexec.bat</target>
        </trans-unit>
        <trans-unit id="b2858151dc8dfe7daca5d572d920ca322993a122" translate="yes" xml:space="preserve">
          <source>autoflush</source>
          <target state="translated">autoflush</target>
        </trans-unit>
        <trans-unit id="64e3d9c664534c5dc480d648743bea7d2acbe343" translate="yes" xml:space="preserve">
          <source>automatically assigns distinct sequential IDs to things for which no ID was supplied by the caller. A default value expression may also refer to parameters earlier in the signature, making the default for one parameter vary according to the earlier parameters. For example,</source>
          <target state="translated">自动为调用者没有提供ID的事物分配不同的顺序ID。默认值表达式也可以引用签名中较早的参数,使得一个参数的默认值根据较早的参数而变化。例如</target>
        </trans-unit>
        <trans-unit id="76fc9ebd6695f30477da08fb8142ffeedfeb7837" translate="yes" xml:space="preserve">
          <source>autosplit.ix</source>
          <target state="translated">autosplit.ix</target>
        </trans-unit>
        <trans-unit id="a5d5b1a8b0a28fc771323790020196c5accafa43" translate="yes" xml:space="preserve">
          <source>autouse</source>
          <target state="translated">autouse</target>
        </trans-unit>
        <trans-unit id="442893c8365aac3e6f7baa2c6d61b464ed2881a4" translate="yes" xml:space="preserve">
          <source>autouse - postpone load of modules until a function is used</source>
          <target state="translated">autouse-推迟模块的加载,直到使用一个函数。</target>
        </trans-unit>
        <trans-unit id="5d4dfc227465e494c0c115736952236fb57eead0" translate="yes" xml:space="preserve">
          <source>autovivification</source>
          <target state="translated">autovivification</target>
        </trans-unit>
        <trans-unit id="7d4a1ec6821afa3e290c645e7f8553cda905013e" translate="yes" xml:space="preserve">
          <source>av.c</source>
          <target state="translated">av.c</target>
        </trans-unit>
        <trans-unit id="bf2d347acf0d2210411dbd48fd0188278826a510" translate="yes" xml:space="preserve">
          <source>available when the &lt;code&gt;seq&lt;/code&gt; method is used along with the R_CURSOR flag.</source>
          <target state="translated">当 &lt;code&gt;seq&lt;/code&gt; 方法与R_CURSOR标志一起使用时可用。</target>
        </trans-unit>
        <trans-unit id="5b2f5ffc6516e12ddb85b8802e4260a6688c946b" translate="yes" xml:space="preserve">
          <source>available. After the first argument, &lt;code&gt;skip(...)&lt;/code&gt; works exactly the same way as &lt;code&gt;ok(...)&lt;/code&gt; does.</source>
          <target state="translated">可用。在第一个参数之后， &lt;code&gt;skip(...)&lt;/code&gt; 的工作方式与 &lt;code&gt;ok(...)&lt;/code&gt; 完全相同。</target>
        </trans-unit>
        <trans-unit id="de42df957f23daa4c8157074e0625209abd6488c" translate="yes" xml:space="preserve">
          <source>avoids such a degradation.</source>
          <target state="translated">避免了这种退化。</target>
        </trans-unit>
        <trans-unit id="c027a379a046e31dfb0f6b178d42c47ae4aba491" translate="yes" xml:space="preserve">
          <source>awk</source>
          <target state="translated">awk</target>
        </trans-unit>
        <trans-unit id="e418c6a55a4fb786dadd646e1573be4fd2df9653" translate="yes" xml:space="preserve">
          <source>awk.exe</source>
          <target state="translated">awk.exe</target>
        </trans-unit>
        <trans-unit id="6431b8949d26ab22586e5fea24d5e1fcf2e09540" translate="yes" xml:space="preserve">
          <source>axes. Mathematicians call</source>
          <target state="translated">轴。数学家称</target>
        </trans-unit>
        <trans-unit id="69036a2af9bfb0d5daf1763137608136cb2401bd" translate="yes" xml:space="preserve">
          <source>axis, and therefore</source>
          <target state="translated">轴,因此</target>
        </trans-unit>
        <trans-unit id="e8e340942e36c5463f6d6ae678f806cf14a11886" translate="yes" xml:space="preserve">
          <source>axis. There is a notation for this using the exponential form, which is:</source>
          <target state="translated">轴。有一种使用指数形式的符号,即:</target>
        </trans-unit>
        <trans-unit id="85f73bad0a71d5e81d44f69fff24051a84f9e8cb" translate="yes" xml:space="preserve">
          <source>azimuthal</source>
          <target state="translated">azimuthal</target>
        </trans-unit>
        <trans-unit id="e9d71f5ee7c92d6dc9e92ffdad17b8bd49418f98" translate="yes" xml:space="preserve">
          <source>b</source>
          <target state="translated">b</target>
        </trans-unit>
        <trans-unit id="be0f342011df36195c2bdef07802b43a541d7d4c" translate="yes" xml:space="preserve">
          <source>b) How do I verify that an email address targets a valid recipient?</source>
          <target state="translated">b)我如何验证电子邮件地址的目标是一个有效的收件人?</target>
        </trans-unit>
        <trans-unit id="e24941468d7edb7b4b97099853ae8f500000e6d5" translate="yes" xml:space="preserve">
          <source>backlink</source>
          <target state="translated">backlink</target>
        </trans-unit>
        <trans-unit id="3652c1c0d07ea36c0f41d5a5bd1906547467aa7c" translate="yes" xml:space="preserve">
          <source>backreference</source>
          <target state="translated">backreference</target>
        </trans-unit>
        <trans-unit id="84eb39aaf0e1b7cca7c174974634139b97dd390f" translate="yes" xml:space="preserve">
          <source>backreferences</source>
          <target state="translated">backreferences</target>
        </trans-unit>
        <trans-unit id="d6666df3cfe0a87d82053354efeb1ef3f1df123d" translate="yes" xml:space="preserve">
          <source>backtracking</source>
          <target state="translated">backtracking</target>
        </trans-unit>
        <trans-unit id="023e7452be147f47fab20b687cbf88f849f3973e" translate="yes" xml:space="preserve">
          <source>bacmp()/bcmp()</source>
          <target state="translated">bacmp()/bcmp()</target>
        </trans-unit>
        <trans-unit id="a30e4fdfae25e2407e88209d32fa3206cbd57707" translate="yes" xml:space="preserve">
          <source>bad for IBM's programs, but the same compiler was used for DLLs which are used with general-purpose applications. When these DLLs are used, the state of floating-point flags in the application is not predictable.</source>
          <target state="translated">但同样的编译器被用于通用应用程序的DLL。当使用这些DLL时,应用程序中浮点标志的状态是不可预测的。</target>
        </trans-unit>
        <trans-unit id="bcea895e1a3b428cb9ae8f8bb6a77c80b6d1735c" translate="yes" xml:space="preserve">
          <source>badd()/bmul()/bsub()/bdiv()/bdec()/binc()</source>
          <target state="translated">badd()/bmul()/bsub()/bdiv()/bdec()/binc()</target>
        </trans-unit>
        <trans-unit id="28776fc2f596476304f65e05ae24e174fbc20745" translate="yes" xml:space="preserve">
          <source>bailey@newman.upenn.edu</source>
          <target state="translated">bailey@newman.upenn.edu</target>
        </trans-unit>
        <trans-unit id="d5f9d5e53a7c7d23a33fb2e87ff767a4dee06322" translate="yes" xml:space="preserve">
          <source>bailout methods</source>
          <target state="translated">纾困方法</target>
        </trans-unit>
        <trans-unit id="62cdb7020ff920e5aa642c3d4066950dd1f01f4d" translate="yes" xml:space="preserve">
          <source>bar</source>
          <target state="translated">bar</target>
        </trans-unit>
        <trans-unit id="961b1cd40787e3f47e9dd503958e048866722a96" translate="yes" xml:space="preserve">
          <source>bar.dll</source>
          <target state="translated">bar.dll</target>
        </trans-unit>
        <trans-unit id="1405df66cbe219b0bf6355bc3d60361a8376b6b4" translate="yes" xml:space="preserve">
          <source>base</source>
          <target state="translated">base</target>
        </trans-unit>
        <trans-unit id="82364d6e500f9e7c6d2e135ddc4ef3ae5df9c250" translate="yes" xml:space="preserve">
          <source>base - Establish an ISA relationship with base classes at compile time</source>
          <target state="translated">base-在编译时与基类建立ISA关系。</target>
        </trans-unit>
        <trans-unit id="d5b858bb629f56a1b3bf07eec9afeff8cb2176cd" translate="yes" xml:space="preserve">
          <source>base character</source>
          <target state="translated">基本字符</target>
        </trans-unit>
        <trans-unit id="fb170bf0a7f9325c8aa7a0a138128b8ec5471d88" translate="yes" xml:space="preserve">
          <source>base.pm was unable to require the base package, because it was not found in your path.</source>
          <target state="translated">base.pm无法要求基础包,因为在你的路径中没有找到它。</target>
        </trans-unit>
        <trans-unit id="e9e99739293e7367ccad4549a440bbf99651181f" translate="yes" xml:space="preserve">
          <source>basename(1)</source>
          <target state="translated">basename(1)</target>
        </trans-unit>
        <trans-unit id="9a441af68f4177c8bcff94839c442392a522bb71" translate="yes" xml:space="preserve">
          <source>baserev.U</source>
          <target state="translated">baserev.U</target>
        </trans-unit>
        <trans-unit id="c8a16b493c487d9f0d43546b842106bf2ffa7152" translate="yes" xml:space="preserve">
          <source>bash</source>
          <target state="translated">bash</target>
        </trans-unit>
        <trans-unit id="1da8eaa4a0d77769d77e901c7a8bd51a90b2108b" translate="yes" xml:space="preserve">
          <source>bash.btm</source>
          <target state="translated">bash.btm</target>
        </trans-unit>
        <trans-unit id="d7113141808e2d9571e4d8981caf323c56b50b9c" translate="yes" xml:space="preserve">
          <source>bash.exe</source>
          <target state="translated">bash.exe</target>
        </trans-unit>
        <trans-unit id="e25ac03f477736cf429678bb164c6ba39a46224c" translate="yes" xml:space="preserve">
          <source>basic block profiling</source>
          <target state="translated">基本区块剖析</target>
        </trans-unit>
        <trans-unit id="bb86a2ae262d9c015cbc4346cbdae479e321322e" translate="yes" xml:space="preserve">
          <source>basic blocks</source>
          <target state="translated">基本模块</target>
        </trans-unit>
        <trans-unit id="ce252839c8120fb5bca1f5ab1ecf317e2b8c1ad2" translate="yes" xml:space="preserve">
          <source>basic-block counting</source>
          <target state="translated">积木式计数</target>
        </trans-unit>
        <trans-unit id="c09a78352f016692dcd8dd798d66441c80a78605" translate="yes" xml:space="preserve">
          <source>basic_text</source>
          <target state="translated">basic_text</target>
        </trans-unit>
        <trans-unit id="504ee22084024022630f49c8572bc2a333f11490" translate="yes" xml:space="preserve">
          <source>batch_mode_page_object_init</source>
          <target state="translated">batch_mode_page_object_init</target>
        </trans-unit>
        <trans-unit id="75736a80f50247c7c9141706465352089a086efa" translate="yes" xml:space="preserve">
          <source>baz&quot;, and, going the other way, the optional parsing of groups of words joined by NBSP's as if each group were in a S&amp;lt;...&amp;gt; code, so that formatters may use the representation that maps best to what the output format demands.</source>
          <target state="translated">baz&amp;rdquo;，以及另一种方式，由NBSP连接的单词组的可选解析，就好像每个组都在S &amp;lt;...&amp;gt;代码中一样，以便格式化程序可以使用最能映射到输出格式的表示形式需要。</target>
        </trans-unit>
        <trans-unit id="89a83e99befe035db29117627cce4ee77338bd35" translate="yes" xml:space="preserve">
          <source>bceil()</source>
          <target state="translated">bceil()</target>
        </trans-unit>
        <trans-unit id="986b1bc1eb8de89643c50722910f99001c232865" translate="yes" xml:space="preserve">
          <source>be</source>
          <target state="translated">be</target>
        </trans-unit>
        <trans-unit id="36048f5f57efa9c9c207392cd7127b119b057243" translate="yes" xml:space="preserve">
          <source>be a bareword. The importation can be made conditional by using the &lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt; module.</source>
          <target state="translated">成为一个空话。可以通过使用&lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt;模块将导入条件化。</target>
        </trans-unit>
        <trans-unit id="e70616934e98e6243ad338b17e6d1d1a80ef47cd" translate="yes" xml:space="preserve">
          <source>be a bareword. The importation can be made conditional by using the &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; module.</source>
          <target state="translated">成为一个空话。可以通过使用&lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;模块将导入条件化。</target>
        </trans-unit>
        <trans-unit id="6174cfdb1b6f1f01bc8c27356965cea1660ff655" translate="yes" xml:space="preserve">
          <source>be a string of octal digits: &lt;code&gt;0644&lt;/code&gt; is okay, but &lt;code&gt;&quot;0644&quot;&lt;/code&gt; is not. Returns the number of files successfully changed. See also &lt;a href=&quot;#oct&quot;&gt;oct&lt;/a&gt; if all you have is a string.</source>
          <target state="translated">可以是八进制数字字符串： &lt;code&gt;0644&lt;/code&gt; 可以，但是 &lt;code&gt;&quot;0644&quot;&lt;/code&gt; 不是。返回成功更改的文件数。如果您只有一个字符串，请参见&lt;a href=&quot;#oct&quot;&gt;oct&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="956f149445457ad325f5a84a0c7c25a363bcc21c" translate="yes" xml:space="preserve">
          <source>be a string of octal digits: &lt;code&gt;0644&lt;/code&gt; is okay, but &lt;code&gt;&quot;0644&quot;&lt;/code&gt; is not. Returns the number of files successfully changed. See also &lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt; if all you have is a string.</source>
          <target state="translated">可以是八进制数字字符串： &lt;code&gt;0644&lt;/code&gt; 可以，但是 &lt;code&gt;&quot;0644&quot;&lt;/code&gt; 不是。返回成功更改的文件数。如果您只有一个字符串，请参见&lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f14746af9c291f92399b053f1e619f9de693adc" translate="yes" xml:space="preserve">
          <source>be a valid Perl package name and it</source>
          <target state="translated">是一个有效的Perl包名,并且它</target>
        </trans-unit>
        <trans-unit id="8bab9adc00fd7e4a64089f6b0ae5c963c3f36a5a" translate="yes" xml:space="preserve">
          <source>be able to tolerate layers compiled against an old version of the headers.</source>
          <target state="translated">能够容忍根据旧版本的头文件编译的层。</target>
        </trans-unit>
        <trans-unit id="14982941f96f6d84c8cd50b24f899b4c1845a614" translate="yes" xml:space="preserve">
          <source>be able to write:</source>
          <target state="translated">能写。</target>
        </trans-unit>
        <trans-unit id="34c1cc772dd68663334c7cc5a51270a9c162743c" translate="yes" xml:space="preserve">
          <source>be addressed by adding a</source>
          <target state="translated">通过增加一个</target>
        </trans-unit>
        <trans-unit id="28396307a68e2c8ee56bd6b269f6e59ccaf41b7a" translate="yes" xml:space="preserve">
          <source>be assigned back to &lt;code&gt;$(&lt;/code&gt; without being forced numeric, such as by adding zero. Note that this is different to the effective gid (&lt;code&gt;$)&lt;/code&gt; ) which does take a list.</source>
          <target state="translated">被分配回 &lt;code&gt;$(&lt;/code&gt; 而不是强制数字，例如通过加零。请注意，这与有效列表（ &lt;code&gt;$)&lt;/code&gt; 不同，后者接受一个列表。</target>
        </trans-unit>
        <trans-unit id="93202847d0c4f58d96ed2de441c5bae895f03f9f" translate="yes" xml:space="preserve">
          <source>be be treated as nested tags within the tagged text (even if they would match the start tag pattern).</source>
          <target state="translated">被视为标签文本中的嵌套标签(即使它们与起始标签模式相匹配)。</target>
        </trans-unit>
        <trans-unit id="e1cd6e63a2e61c9b680434df73ca1618e7d52128" translate="yes" xml:space="preserve">
          <source>be called exactly once, typically in a BOOT: section. If you are maintaining multiple interpreters, it should be called once in each interpreter instance, except for interpreters cloned from existing ones. (But see &lt;a href=&quot;#MY_CXT_CLONE&quot;&gt;MY_CXT_CLONE&lt;/a&gt; below.)</source>
          <target state="translated">通常只在BOOT：部分中被调用一次。如果要维护多个解释器，则应在每个解释器实例中调用一次，但从现有实例中克隆的解释器除外。（但请参见下面的&lt;a href=&quot;#MY_CXT_CLONE&quot;&gt;MY_CXT_CLONE&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="9d2edd7898262b515a39df03229b24d227d1c626" translate="yes" xml:space="preserve">
          <source>be called explicitly.</source>
          <target state="translated">被明确地调用。</target>
        </trans-unit>
        <trans-unit id="438a35efe202395aa4bfcea78aeb25f89d7ddb6d" translate="yes" xml:space="preserve">
          <source>be closed by calling &lt;code&gt;PerlIO_close()&lt;/code&gt; on the returned PerlIO *.</source>
          <target state="translated">通过在返回的PerlIO *上调用 &lt;code&gt;PerlIO_close()&lt;/code&gt; 来关闭。</target>
        </trans-unit>
        <trans-unit id="9934090830c2424ca6cc4ecf9b012220e6cb8ade" translate="yes" xml:space="preserve">
          <source>be closed until both the tied variable is untied and all copies of the saved object are destroyed.</source>
          <target state="translated">被关闭,直到绑定的变量被解除绑定,并且保存对象的所有副本被销毁。</target>
        </trans-unit>
        <trans-unit id="c3e7ca4e78e0952264ac139095f7bf1f632db6fe" translate="yes" xml:space="preserve">
          <source>be consistent with each other (implementation may only use one or the other or may require both).</source>
          <target state="translated">彼此一致(实施时可能只使用其中一种或另一种,也可能要求两种都使用)。</target>
        </trans-unit>
        <trans-unit id="bdfc850e994531d0f620111ecf403220532f49bb" translate="yes" xml:space="preserve">
          <source>be declared</source>
          <target state="translated">被宣布</target>
        </trans-unit>
        <trans-unit id="4bc6d0c7f9935408fb2bc64464a3d82819a4723d" translate="yes" xml:space="preserve">
          <source>be expanded as specified by the &lt;b&gt;-expand_seq&lt;/b&gt; option; Any such recursive expansion needs to be handled by the specified callback routine.]</source>
          <target state="translated">按照&lt;b&gt;-expand_seq&lt;/b&gt;选项指定的方式进行扩展；任何此类递归扩展都需要由指定的回调例程处理。]</target>
        </trans-unit>
        <trans-unit id="fb00294fdc4c477751afeb60eec17519d313dd85" translate="yes" xml:space="preserve">
          <source>be faster in certain circumstances for large files, and may result in less physical memory use when multiple processes are reading the same file.</source>
          <target state="translated">在某些情况下,对于大文件来说速度更快,而且当多个进程读取同一个文件时,可能会减少物理内存的使用。</target>
        </trans-unit>
        <trans-unit id="89547cfa26f8957d4689489ae8e6da3bfe190445" translate="yes" xml:space="preserve">
          <source>be globrefs).</source>
          <target state="translated">是globrefs)。)</target>
        </trans-unit>
        <trans-unit id="aed67ceeb07b3aad12dfc70fda375fa903262c1b" translate="yes" xml:space="preserve">
          <source>be globrefs. Objects of &lt;code&gt;NamedFile&lt;/code&gt; should behave like a file opened for reading and also support the &lt;code&gt;name()&lt;/code&gt; method. This class juncture works with exception of the &lt;code&gt;Name_hash&lt;/code&gt; implementation, where object initialization fails because of the incompatibility of object bodies.</source>
          <target state="translated">成为地球专家。 &lt;code&gt;NamedFile&lt;/code&gt; 对象的行为应类似于为读取而打开的文件，并且还支持 &lt;code&gt;name()&lt;/code&gt; 方法。该类关口工作与 &lt;code&gt;Name_hash&lt;/code&gt; 实现例外，该实现因对象主体的不兼容而导致对象初始化失败。</target>
        </trans-unit>
        <trans-unit id="96a908fc7385d1425e0ba694653b67ebf458eb65" translate="yes" xml:space="preserve">
          <source>be in effect.)</source>
          <target state="translated">有效)。)</target>
        </trans-unit>
        <trans-unit id="93fdaed10217b38690a5394ba6f117f7442dc2d0" translate="yes" xml:space="preserve">
          <source>be interpreted as simply &quot;codepoint</source>
          <target state="translated">编码点</target>
        </trans-unit>
        <trans-unit id="3b8bb41a2a75cf63cb4e4b8dd89b36e596750288" translate="yes" xml:space="preserve">
          <source>be introduced with &lt;code&gt;--&lt;/code&gt; and bundles with &lt;code&gt;-&lt;/code&gt; .</source>
          <target state="translated">用 &lt;code&gt;--&lt;/code&gt; 引入，并用 &lt;code&gt;-&lt;/code&gt; 捆绑。</target>
        </trans-unit>
        <trans-unit id="42a1854f29dd88d78bf67b5c84417d21fb1c6102" translate="yes" xml:space="preserve">
          <source>be invoked.</source>
          <target state="translated">被调用。</target>
        </trans-unit>
        <trans-unit id="9b400f46c67266a74a7941beb8d8f3aa492d507c" translate="yes" xml:space="preserve">
          <source>be made read-only (by the caller), or at least should be treated as such.</source>
          <target state="translated">是只读的(由调用者),或者至少应该这样处理。</target>
        </trans-unit>
        <trans-unit id="8aca838b806998e1c3a7660775bb22707c53a139" translate="yes" xml:space="preserve">
          <source>be open any more when the program is reincarnated, with possible resulting confusion by Perl.</source>
          <target state="translated">在程序转世的时候会被打开,可能会导致Perl的混淆。</target>
        </trans-unit>
        <trans-unit id="4942a835a218847da1bc9474d15e7f7fecee9472" translate="yes" xml:space="preserve">
          <source>be parsed as two paragraphs in italics (with the I code starting in one paragraph and starting in another.) Instead, the first paragraph should generate a warning, but that aside, the above code must parse as if it were:</source>
          <target state="translated">被解析为两段斜体字(I代码在一段中开始,在另一段中开始),相反,第一段应该产生一个警告,但撇开这一点,上面的代码必须像它一样解析。</target>
        </trans-unit>
        <trans-unit id="cac76875da8caea6da506441e4a3013ef795de69" translate="yes" xml:space="preserve">
          <source>be preceded with a blank line; &lt;code&gt;__END__&lt;/code&gt; is</source>
          <target state="translated">空白行之前； &lt;code&gt;__END__&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="56f17a9fa2003de9ef3c254fb72eb38377857e77" translate="yes" xml:space="preserve">
          <source>be present during testing.</source>
          <target state="translated">在测试期间在场。</target>
        </trans-unit>
        <trans-unit id="ac6789e5ce6bb8c48ccfee0a53b55ecb18497192" translate="yes" xml:space="preserve">
          <source>be provided.</source>
          <target state="translated">提供。</target>
        </trans-unit>
        <trans-unit id="8e7ed5c5b2648d3fb47f0ce1afb127706a1279f2" translate="yes" xml:space="preserve">
          <source>be restored.</source>
          <target state="translated">予以恢复。</target>
        </trans-unit>
        <trans-unit id="c9bf9ad1188aa77634cd3b8aff0b84c5c12ad44c" translate="yes" xml:space="preserve">
          <source>be stopped by debugger, although &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;s and INIT blocks will, and compile-time statements can be traced with the &lt;code&gt;AutoTrace&lt;/code&gt; option set in &lt;code&gt;PERLDB_OPTS&lt;/code&gt; ). From your own Perl code, however, you can transfer control back to the debugger using the following statement, which is harmless if the debugger is not running:</source>
          <target state="translated">尽管 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 和INIT块将被调试器停止，并且可以使用在 &lt;code&gt;PERLDB_OPTS&lt;/code&gt; 中设置的 &lt;code&gt;AutoTrace&lt;/code&gt; 选项来跟踪编译时语句。但是，您可以使用以下语句从您自己的Perl代码中将控制权转移回调试器，如果调试器未运行，则这是无害的：</target>
        </trans-unit>
        <trans-unit id="400bf125e188b6776f7244947b865d3a2497a3b3" translate="yes" xml:space="preserve">
          <source>be stored as a single data paragraph (consisting of &quot;&amp;lt;img src='wirth_spokesmodeling_book.png'&amp;gt;\n\n&amp;lt;hr&amp;gt;\n&quot;).</source>
          <target state="translated">被存储为单个数据段落（由&amp;ldquo; &amp;lt;img src ='wirth_spokesmodeling_book.png'&amp;gt; \ n \ n &amp;lt;hr&amp;gt; \ n&amp;rdquo;组成）。</target>
        </trans-unit>
        <trans-unit id="16137519316b812afb2da09aa91b112ba92bff67" translate="yes" xml:space="preserve">
          <source>be stored as two data paragraphs (one consisting of &quot;&amp;lt;img src='wirth_spokesmodeling_book.png'&amp;gt;\n&quot; and another consisting of &quot;&amp;lt;hr&amp;gt;\n&quot;), but</source>
          <target state="translated">被存储为两个数据段（一个由&amp;ldquo; &amp;lt;img src ='wirth_spokesmodeling_book.png'&amp;gt; \ n&amp;rdquo;组成，另一个由&amp;ldquo; &amp;lt;hr&amp;gt; \ n&amp;rdquo;组成），但是</target>
        </trans-unit>
        <trans-unit id="619ff8abea4d5f3ccd22e0c825463c6f2e928d79" translate="yes" xml:space="preserve">
          <source>be sure to invoke &lt;code&gt;$self-&amp;gt;SUPER::initialize()&lt;/code&gt; .</source>
          <target state="translated">确保调用 &lt;code&gt;$self-&amp;gt;SUPER::initialize()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3127d5be257498591fa1b1e632079190d24627c" translate="yes" xml:space="preserve">
          <source>be sure to invoke the &lt;b&gt;initialize()&lt;/b&gt; method of the newly blessed object.</source>
          <target state="translated">确保调用新祝福对象的&lt;b&gt;initialize（）&lt;/b&gt;方法。</target>
        </trans-unit>
        <trans-unit id="6bd6f3dc5720d53f6325adeb9c38189554e2d06f" translate="yes" xml:space="preserve">
          <source>be the desired effect within a diamond hierarchy, but in others (e.g. for destructors) it may be more appropriate to call each method only once during a sequence of redispatches.</source>
          <target state="translated">是钻石层次结构中的理想效果,但在其他层次结构中(例如对于析构器),在重发序列中只调用每个方法一次可能更合适。</target>
        </trans-unit>
        <trans-unit id="f32b0724100efc9f3b38df25932dbc397348687a" translate="yes" xml:space="preserve">
          <source>be thrown if</source>
          <target state="translated">抛出</target>
        </trans-unit>
        <trans-unit id="d996815a3551001f2437592e2dfe9cf2917da354" translate="yes" xml:space="preserve">
          <source>be treated as an error:</source>
          <target state="translated">视为错误。</target>
        </trans-unit>
        <trans-unit id="5cfeeb86f388b90e9358708fb9a2cf2d92ff6a4c" translate="yes" xml:space="preserve">
          <source>be treated as an option, but passed to the program unharmed, in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">被视为选项，但在 &lt;code&gt;@ARGV&lt;/code&gt; 中传递给程序时不受损害。</target>
        </trans-unit>
        <trans-unit id="213ce7c8d8fef7b5daff184033ed3b8b66ff7b3a" translate="yes" xml:space="preserve">
          <source>be undone (but not &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt; @_&lt;/code&gt; or other splicing,</source>
          <target state="translated">被撤消（但不会 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt; @_&lt;/code&gt; 或其他拼接，</target>
        </trans-unit>
        <trans-unit id="8002f964e7f54fd6c9a88e0e37e9510ff919095b" translate="yes" xml:space="preserve">
          <source>be undone (but not &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt; @_&lt;/code&gt; or other splicing,</source>
          <target state="translated">被撤消（但不会 &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt; @_&lt;/code&gt; 或其他拼接，</target>
        </trans-unit>
        <trans-unit id="17bd5dc5ae122c31aab12373873620d67a1c4b2d" translate="yes" xml:space="preserve">
          <source>be used for method calls. You can't use it for regular subroutine calls or class methods:</source>
          <target state="translated">可用于方法调用,但不能用于常规的子程序调用或类方法。你不能将它用于常规子程序调用或类方法。</target>
        </trans-unit>
        <trans-unit id="4e471a2c455269486f9776c668e9c672d74418df" translate="yes" xml:space="preserve">
          <source>be used in interpolating strings (double quotes or the &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; operator), but only if the additional &lt;code&gt;postderef_qq&lt;/code&gt; feature is enabled.</source>
          <target state="translated">仅可在插值字符串（双引号或 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; 运算符）中使用，但 &lt;code&gt;postderef_qq&lt;/code&gt; 是启用了附加的postderef_qq功能。</target>
        </trans-unit>
        <trans-unit id="37c19bda8dda58aa4daba4c9519e4dc020b7a3f4" translate="yes" xml:space="preserve">
          <source>be used in interpolating strings (double quotes or the &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; operator), but only if the additional &lt;code&gt;postderef_qq&lt;/code&gt;&lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; is enabled.</source>
          <target state="translated">仅可在插值字符串（双引号或 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; 运算符）中使用，但 &lt;code&gt;postderef_qq&lt;/code&gt; 是启用了附加的postderef_qq &lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9eccf910fdd37c2a3bcdbac9f3427f38c70da9c0" translate="yes" xml:space="preserve">
          <source>bearing</source>
          <target state="translated">bearing</target>
        </trans-unit>
        <trans-unit id="1407501dd659df6fb3cfafb420938ddd4792bbdd" translate="yes" xml:space="preserve">
          <source>because it can match zero copies of &lt;code&gt;'X'&lt;/code&gt; at the beginning of the string. If you definitely want to match at least one &lt;code&gt;'X'&lt;/code&gt; , use &lt;code&gt;X+&lt;/code&gt; , not &lt;code&gt;X*&lt;/code&gt; .</source>
          <target state="translated">因为它可以匹配字符串开头的零个 &lt;code&gt;'X'&lt;/code&gt; 副本。如果您肯定要匹配至少一个 &lt;code&gt;'X'&lt;/code&gt; ，请使用 &lt;code&gt;X+&lt;/code&gt; 而不是 &lt;code&gt;X*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed626eff2ded4ff54496b1cd4f2b0a1c7d5ccbb9" translate="yes" xml:space="preserve">
          <source>because it is much faster - it reduces internal variables into the modulus whenever possible, so it operates on smaller numbers.</source>
          <target state="translated">因为它的速度要快得多--它尽可能地将内部变量还原成模数,所以它对较小的数字进行操作。</target>
        </trans-unit>
        <trans-unit id="c9ac39be8f080b55461591140c43654051426f56" translate="yes" xml:space="preserve">
          <source>because it was listed as a TODO test on the plan line. However, we are not aware of anyone actually using this feature and hard-coding test numbers is discouraged because it's very easy to add a test and break the test number sequence. This makes test suites very fragile. Instead, the following should be used:</source>
          <target state="translated">因为它在计划行中被列为TODO测试。然而,我们不知道有谁真正使用这个功能,而且不鼓励对测试号进行硬编码,因为很容易增加一个测试并打破测试号序列。这使得测试套件非常脆弱。相反,应该使用以下方法。</target>
        </trans-unit>
        <trans-unit id="3716b55181b7d4ce5a8064066cc2010c3e1b6360" translate="yes" xml:space="preserve">
          <source>because of the strict regularization of Perl 5's grammar into unary and list operators. (The old open was a little of both.) You must put parentheses around the filehandle, or use the new &quot;or&quot; operator instead of &quot;||&quot;.</source>
          <target state="translated">因为 Perl 5 的语法严格地规范化为单数和列表运算符。(以前的 open 是两者兼而有之。)你必须在文件柄周围加上括号,或者使用新的 &quot;or &quot;运算符,而不是&quot;|&quot;。(以前的 open 是两者兼而有之。)你必须在 filehandle 的周围加上括号,或者使用新的 &quot;or&quot; 操作符来代替 &quot;||&quot;。</target>
        </trans-unit>
        <trans-unit id="71ee90a49bf1ab4bd322eb175c4eef72341f4bf3" translate="yes" xml:space="preserve">
          <source>because otherwise &lt;b&gt;xsubpp&lt;/b&gt; will believe that you made a duplicate definition of the function. Also, put a blank line before the #else/#endif so it will not be seen as part of the function body.</source>
          <target state="translated">因为否则&lt;b&gt;xsubpp&lt;/b&gt;会认为您对函数进行了重复定义。另外，在＃else /＃endif之前放置一个空行，这样它就不会被视为函数主体的一部分。</target>
        </trans-unit>
        <trans-unit id="c57dfba8d90c3ee87942986e029f65c0a62033af" translate="yes" xml:space="preserve">
          <source>because the &quot;less than&quot; operator is interpreted as a closing delimiter.</source>
          <target state="translated">因为 &quot;小于 &quot;运算符被解释为结尾定界符。</target>
        </trans-unit>
        <trans-unit id="91d068e640ed02bcfffdad4e89ae0a9db41b7044" translate="yes" xml:space="preserve">
          <source>because the embedded pairs of &lt;code&gt;'(..)'&lt;/code&gt; s and &lt;code&gt;'[..]'&lt;/code&gt; s are &quot;cross-nested&quot; and the embedded &lt;code&gt;'&amp;gt;'&lt;/code&gt; is unbalanced. (In a scalar context, this call would return an empty string. In a void context, &lt;code&gt;$text&lt;/code&gt; would be unchanged.)</source>
          <target state="translated">因为嵌入的 &lt;code&gt;'(..)'&lt;/code&gt; 和 &lt;code&gt;'[..]'&lt;/code&gt; 是&amp;ldquo;交叉嵌套的&amp;rdquo;，并且嵌入的 &lt;code&gt;'&amp;gt;'&lt;/code&gt; 是不平衡的。（在标量上下文中，此调用将返回一个空字符串。在无效上下文中， &lt;code&gt;$text&lt;/code&gt; 将保持不变。）</target>
        </trans-unit>
        <trans-unit id="331252ee302b6da2035026aca3ba4ae99c1a4ea1" translate="yes" xml:space="preserve">
          <source>because the latter will alternate between returning a filename and returning false.</source>
          <target state="translated">因为后者会在返回文件名和返回false之间交替进行。</target>
        </trans-unit>
        <trans-unit id="f2ef9563189019bf8c9ac0f31b94f7d982047b5c" translate="yes" xml:space="preserve">
          <source>because the main point isn't whether the user typed &lt;b&gt;-v&lt;/b&gt; or not.</source>
          <target state="translated">因为重点不在于用户是否键入&lt;b&gt;-v&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="95dd904c935d8d74a8bd1af96d4e502e980aaabd" translate="yes" xml:space="preserve">
          <source>because the notion of &quot;compile-time&quot; is relative. Instead, you want:</source>
          <target state="translated">因为 &quot;编译时 &quot;的概念是相对的。相反,你要。</target>
        </trans-unit>
        <trans-unit id="6a35b87feefdc6c196b1d4d33ac852a059f8f67f" translate="yes" xml:space="preserve">
          <source>because the second way hides the main point of the statement in a modifier. On the other hand</source>
          <target state="translated">因为第二种方式将语句的主要内容隐藏在修饰语中。另一方面</target>
        </trans-unit>
        <trans-unit id="b15c6a463c6e853f47c1bd82bf87355ef292954f" translate="yes" xml:space="preserve">
          <source>because they test functionality which</source>
          <target state="translated">因为他们测试的功能是</target>
        </trans-unit>
        <trans-unit id="c89a78424c4f276725f3f2424f018f5fc3348fbb" translate="yes" xml:space="preserve">
          <source>because you don't have to start a process on every filename found. It does suffer from the bug of mishandling newlines in pathnames, which you can fix if you follow the example under &lt;b&gt;-0&lt;/b&gt;.</source>
          <target state="translated">因为您不必对找到的每个文件名都启动进程。它确实存在路径名中换行处理不当的错误，如果您遵循&lt;b&gt;-0&lt;/b&gt;下的示例，则可以修复该错误。</target>
        </trans-unit>
        <trans-unit id="a217c7a44aead49b3247ffc0322e6ace486aeba7" translate="yes" xml:space="preserve">
          <source>because you'll get just references listed, and perl will never automatically dereference things for you. Instead, you have to roll yourself a loop or two. This prints the whole structure, using the shell-style for() construct to loop across the outer set of subscripts.</source>
          <target state="translated">因为你会得到的只是列出的引用,而perl永远不会自动为你解除引用。相反,你必须给自己滚一两个循环。这将打印整个结构,使用 shell 风格的 for()构造在外层的下标集上循环。</target>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="e0d2345f9f72fcdda8f445997826d44505e55aef" translate="yes" xml:space="preserve">
          <source>been in use as an Internet language tag, and RFC 3066 stipulates that it never should be, since a shorter tag (&quot;ar&quot;) exists.</source>
          <target state="translated">一直被用作互联网语言标签,而RFC 3066规定它永远不应该被用作标签,因为存在一个更短的标签(&quot;ar&quot;)。</target>
        </trans-unit>
        <trans-unit id="51de2b835bd35a67eb32dbcd3d77d4b96e5aa39d" translate="yes" xml:space="preserve">
          <source>before</source>
          <target state="translated">before</target>
        </trans-unit>
        <trans-unit id="915c701ba2639a5081cecf4fc5bdf5de5ad69a85" translate="yes" xml:space="preserve">
          <source>before calling</source>
          <target state="translated">呼叫前</target>
        </trans-unit>
        <trans-unit id="0cbf8d2dc3ebc2ee1d97d9f37a08ec8f737756c3" translate="yes" xml:space="preserve">
          <source>before running your wide record pipe program. A larger value may improve performance at the expense of the BYTLM UAF quota.</source>
          <target state="translated">在运行您的宽记录管程序之前,一个较大的值可能会以牺牲BYTLM UAF配额为代价来提高性能。一个较大的值可能会以牺牲BYTLM UAF配额为代价来提高性能。</target>
        </trans-unit>
        <trans-unit id="9dfe8489641883d87825274b161f0adcb018192e" translate="yes" xml:space="preserve">
          <source>before unpacking the archive.</source>
          <target state="translated">在解压存档之前。</target>
        </trans-unit>
        <trans-unit id="e00d3375a237dc6b36e090011f01e09a680f730b" translate="yes" xml:space="preserve">
          <source>begin with a colon, should not directly contain &quot;=head1&quot; ... &quot;=head4&quot; commands, nor &quot;=over&quot;, nor &quot;=back&quot;, nor &quot;=item&quot;. For example, this may be considered invalid:</source>
          <target state="translated">以冒号开头,不应直接包含&quot;=head1&quot;...。&quot;=head4 &quot;命令,也不能包含&quot;=over&quot;、&quot;=back &quot;或&quot;=item&quot;。例如,这可能被认为是无效的。</target>
        </trans-unit>
        <trans-unit id="35ee011e96122a1b4404f72436530569c798f3bc" translate="yes" xml:space="preserve">
          <source>begin with a colon, then &quot;text...&quot; will constitute a data paragraph. There is no way to use &quot;=for formatname text...&quot; to express &quot;text...&quot; as a verbatim paragraph.</source>
          <target state="translated">以冒号开始,那么 &quot;text...&quot;将构成一个数据段。没有办法使用&quot;=for formatname text...&quot;将 &quot;text...&quot;表达为一个逐字段。</target>
        </trans-unit>
        <trans-unit id="01012d8e1a5ae715258cadbaf70262cad1cf8ef2" translate="yes" xml:space="preserve">
          <source>begin with a colon, then non-command paragraphs are ordinary paragraphs or data paragraphs. This is discussed in detail in the section &lt;a href=&quot;#About-Data-Paragraphs-and-%22%3dbegin%2f%3dend%22-Regions&quot;&gt;About Data Paragraphs and =begin/=end Regions&lt;/a&gt;.</source>
          <target state="translated">以冒号开头，然后非命令段落是普通段落或数据段落。&lt;a href=&quot;#About-Data-Paragraphs-and-%22%3dbegin%2f%3dend%22-Regions&quot;&gt;关于数据段落和= begin / = end区域&lt;/a&gt;中将对此进行详细讨论。</target>
        </trans-unit>
        <trans-unit id="43e8c372c4b8551232015b4964270e14bc96c611" translate="yes" xml:space="preserve">
          <source>begin with a colon.</source>
          <target state="translated">以冒号开头。</target>
        </trans-unit>
        <trans-unit id="f96514769306205e5e54b126ee406aa18da22231" translate="yes" xml:space="preserve">
          <source>begin with a literal colon (&quot;:&quot;). In some sense, a data paragraph is not part of Pod at all (i.e., effectively it's &quot;out-of-band&quot;), since it's not subject to most kinds of Pod parsing; but it is specified here, since Pod parsers need to be able to call an event for it, or store it in some form in a parse tree, or at least just parse</source>
          <target state="translated">以冒号(&quot;:&quot;)开始。在某种意义上,数据段根本不是Pod的一部分(即,实际上它是 &quot;带外的&quot;),因为它不受大多数类型的Pod解析的影响;但它在这里被指定,因为Pod解析器需要能够为它调用一个事件,或以某种形式存储在解析树中,或至少只是解析</target>
        </trans-unit>
        <trans-unit id="e2e281b54db81b16a35418fcd87978434eb58caf" translate="yes" xml:space="preserve">
          <source>begins with a colon,</source>
          <target state="translated">以冒号开头。</target>
        </trans-unit>
        <trans-unit id="1c831dd4349f7440d63aa005aa956edcf6570200" translate="yes" xml:space="preserve">
          <source>behaves approximately like</source>
          <target state="translated">近似于</target>
        </trans-unit>
        <trans-unit id="878cb14881bc8cc40ffa36c11bd520865655b641" translate="yes" xml:space="preserve">
          <source>behaves just like &lt;b&gt;-e&lt;/b&gt;, except that it implicitly enables all optional features (in the main compilation unit). See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">行为与&lt;b&gt;-e&lt;/b&gt;一样，除了它隐式启用所有可选功能（在主编译单元中）。请参阅&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29c4a5cf676b2e6b5aac47ac451d31e3961499c9" translate="yes" xml:space="preserve">
          <source>behavior for a thread after it has been created. With a</source>
          <target state="translated">线程创建后的行为。有了</target>
        </trans-unit>
        <trans-unit id="ab7103d633748a477ad2572ee63045defbe35f36" translate="yes" xml:space="preserve">
          <source>behavior, for some inputs.) In 5.7, the quicksort implementation was replaced with a stable mergesort algorithm whose worst-case behavior is O(NlogN). But benchmarks indicated that for some inputs, on some platforms, the original quicksort was faster. 5.8 has a sort pragma for limited control of the sort. Its rather blunt control of the underlying algorithm may not persist into future Perls, but the ability to characterize the input or output in implementation independent ways quite probably will. See &lt;a href=&quot;../sort&quot;&gt;the sort pragma&lt;/a&gt;.</source>
          <target state="translated">在5.7中，快速排序实现被稳定的合并排序算法取代，该算法的最坏情况是O（NlogN）。但是基准测试表明，对于某些平台上的某些输入，原始的快速排序速度更快。5.8具有排序实用程序，用于对排序的有限控制。它对底层算法的比较直截了当的控制可能不会持续到将来的Perls中，但是很可能会以实现独立的方式表征输入或输出的能力。参见&lt;a href=&quot;../sort&quot;&gt;排序杂注&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7662c3889bf0376550fc93aa4448d4df9574c86b" translate="yes" xml:space="preserve">
          <source>behavior, for some inputs.) In 5.7, the quicksort implementation was replaced with a stable mergesort algorithm whose worst-case behavior is O(NlogN). But benchmarks indicated that for some inputs, on some platforms, the original quicksort was faster. 5.8 has a sort pragma for limited control of the sort. Its rather blunt control of the underlying algorithm may not persist into future Perls, but the ability to characterize the input or output in implementation independent ways quite probably will. See &lt;a href=&quot;sort&quot;&gt;the sort pragma&lt;/a&gt;.</source>
          <target state="translated">在5.7中，快速排序实现被稳定的合并排序算法取代，该算法的最坏情况是O（NlogN）。但是基准测试表明，对于某些平台上的某些输入，原始的快速排序速度更快。5.8具有排序实用程序，用于对排序的有限控制。它对底层算法的比较直截了当的控制可能不会持续到将来的Perls中，但是很可能会以实现独立的方式表征输入或输出的能力。参见&lt;a href=&quot;sort&quot;&gt;排序杂注&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4d45707cf30bc986faddb8a61f21a6e9cdaf80e" translate="yes" xml:space="preserve">
          <source>behaviour is different from the outer public API. The logic is that the &quot;unchecked&quot; case is useful when the encoding is part of a stream which may be reporting errors (e.g. STDERR). In such cases, it is desirable to get everything through somehow without causing additional errors which obscure the original one. Also, the encoding is best placed to know what the correct replacement character is, so if that is the desired behaviour then letting low level code do it is the most efficient.</source>
          <target state="translated">的行为与外部的公共 API 不同,其逻辑是 &quot;未选中 &quot;的情况在编码是可能报告错误的流的一部分(如 STDERR)时很有用。其逻辑是,当编码是一个可能会报告错误的流的一部分时,&quot;未选中 &quot;的情况是有用的(例如STDERR)。在这种情况下,最好能以某种方式让所有的东西都通过,而不引起额外的错误,从而掩盖原来的错误。另外,编码最了解正确的替换字符是什么,所以如果这是期望的行为,那么让低级代码来做是最有效的。</target>
        </trans-unit>
        <trans-unit id="d665cbacbfa3c977993d51ac9f39d4889ffea309" translate="yes" xml:space="preserve">
          <source>behaviour. One can start</source>
          <target state="translated">行为。人们可以从</target>
        </trans-unit>
        <trans-unit id="c4ad9e56b49ef76a7e8fcbc4f0e989ac69868fc0" translate="yes" xml:space="preserve">
          <source>behind its back; calling &lt;a href=&quot;#sync_locale&quot;&gt;sync_locale&lt;/a&gt; before calling this macro will update perl's records.)</source>
          <target state="translated">背后 在调用此宏之前调用&lt;a href=&quot;#sync_locale&quot;&gt;sync_locale&lt;/a&gt;将更新perl的记录。）</target>
        </trans-unit>
        <trans-unit id="53f8e0ff86be0a313b2007cbdd020a9b83a37fba" translate="yes" xml:space="preserve">
          <source>being data being sent to the server. Calls &lt;code&gt;debug_text&lt;/code&gt; before printing to STDERR.</source>
          <target state="translated">被发送到服务器的数据。在打印到STDERR之前调用 &lt;code&gt;debug_text&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70842494fd493a8f8803b71e1e93717e5ff8d7e2" translate="yes" xml:space="preserve">
          <source>being executed within the distribution file's working directory.</source>
          <target state="translated">正在分发文件的工作目录中执行。</target>
        </trans-unit>
        <trans-unit id="c6309e2149391dbe0d16560dc35ff7f7d071ea27" translate="yes" xml:space="preserve">
          <source>being more accurate than C</source>
          <target state="translated">比C更准确</target>
        </trans-unit>
        <trans-unit id="ae7d864b083311cd426e7717f8e3a7be973f886e" translate="yes" xml:space="preserve">
          <source>being unfilled. In a threading situation,</source>
          <target state="translated">未被填充。在穿线的情况下。</target>
        </trans-unit>
        <trans-unit id="d4300189fdbe1cb5fe64ef0a483b7086eb450712" translate="yes" xml:space="preserve">
          <source>belongs to (used in &lt;code&gt;\p{Blk=...}&lt;/code&gt; ). The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the block name.</source>
          <target state="translated">所属（用于 &lt;code&gt;\p{Blk=...}&lt;/code&gt; ）。该&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;函数可用于获取块名称的所有同义词。</target>
        </trans-unit>
        <trans-unit id="a2fdbc23a85b8e4584cd5c7c6fb3ac1138bda7bd" translate="yes" xml:space="preserve">
          <source>belongs to. The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the script name.</source>
          <target state="translated">属于。该&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;函数可用于获取脚本名称的所有同义词。</target>
        </trans-unit>
        <trans-unit id="489c7fc8339f7c44efa172c21d3dbf41ad08c7e4" translate="yes" xml:space="preserve">
          <source>below</source>
          <target state="translated">below</target>
        </trans-unit>
        <trans-unit id="21b17c5ba622c38ebd7690a2824aa2f55d5b8a0f" translate="yes" xml:space="preserve">
          <source>below). The containing directory can be specified in &lt;code&gt;CPAN.pm&lt;/code&gt; in the &lt;code&gt;prefs_dir&lt;/code&gt; config variable. Try &lt;code&gt;o conf init
prefs_dir&lt;/code&gt; in the CPAN shell to set and activate the distroprefs system.</source>
          <target state="translated">下面）。可以在 &lt;code&gt;CPAN.pm&lt;/code&gt; 中的 &lt;code&gt;prefs_dir&lt;/code&gt; 配置变量中指定包含目录。尝试在CPAN shell中使用 &lt;code&gt;o conf init prefs_dir&lt;/code&gt; 来设置和激活distroprefs系统。</target>
        </trans-unit>
        <trans-unit id="6ee65b4d48e2ac02540ecb32d3b43d908326681d" translate="yes" xml:space="preserve">
          <source>bench.pl</source>
          <target state="translated">bench.pl</target>
        </trans-unit>
        <trans-unit id="c5f5e4d75252d9788ce20300d00023fa1ccd4d19" translate="yes" xml:space="preserve">
          <source>best</source>
          <target state="translated">best</target>
        </trans-unit>
        <trans-unit id="a2db5af4b95c649c7f23f26e2d00914f22ca9241" translate="yes" xml:space="preserve">
          <source>best effort</source>
          <target state="translated">尽力</target>
        </trans-unit>
        <trans-unit id="709634051471385aada32356842983beeff4b065" translate="yes" xml:space="preserve">
          <source>between</source>
          <target state="translated">between</target>
        </trans-unit>
        <trans-unit id="6ff6cf52c304b7ca8d264e3830a9bb468d96fb99" translate="yes" xml:space="preserve">
          <source>between configuring and making steps.)</source>
          <target state="translated">在配置和制作步骤之间)。)</target>
        </trans-unit>
        <trans-unit id="95b5da10cca6e837a526a6e638dc826063502032" translate="yes" xml:space="preserve">
          <source>bexp()</source>
          <target state="translated">bexp()</target>
        </trans-unit>
        <trans-unit id="d52f22fd878ee3706d7dd2feba05080b099127cc" translate="yes" xml:space="preserve">
          <source>bfac()</source>
          <target state="translated">bfac()</target>
        </trans-unit>
        <trans-unit id="7bbd3be39df70eda29db2e96251dc8a4c05ce7be" translate="yes" xml:space="preserve">
          <source>bfloor()</source>
          <target state="translated">bfloor()</target>
        </trans-unit>
        <trans-unit id="0eb26de54355ba1e1f99e33725a9d024cfd6b807" translate="yes" xml:space="preserve">
          <source>bidirectional type of</source>
          <target state="translated">双向型</target>
        </trans-unit>
        <trans-unit id="38e4f23119f7668c81c56c877acdc10f397299d2" translate="yes" xml:space="preserve">
          <source>big-endian</source>
          <target state="translated">big-endian</target>
        </trans-unit>
        <trans-unit id="5f9c9d32d71f1ef8b8014c350a5f8aec50c577ec" translate="yes" xml:space="preserve">
          <source>bigint</source>
          <target state="translated">bigint</target>
        </trans-unit>
        <trans-unit id="83123b65dc13ec2d11ceae1c1cec211e7cef1cb6" translate="yes" xml:space="preserve">
          <source>bigint - Transparent BigInteger support for Perl</source>
          <target state="translated">bigint-为Perl提供透明的BigInteger支持。</target>
        </trans-unit>
        <trans-unit id="dc0c0c0aa0c98c99641fd608b1168be57143c887" translate="yes" xml:space="preserve">
          <source>bigint recognizes some options that can be passed while loading it via use. The options can (currently) be either a single letter form, or the long form. The following options exist:</source>
          <target state="translated">bigint 识别了一些选项,这些选项可以在通过使用加载它时传递。这些选项可以(当前)是单字母形式,也可以是长形式。存在以下选项。</target>
        </trans-unit>
        <trans-unit id="2c5ed18936a55186b9ba8eb22ac87953629628d3" translate="yes" xml:space="preserve">
          <source>bignum</source>
          <target state="translated">bignum</target>
        </trans-unit>
        <trans-unit id="ebef2dfbf356b1d6376d0a89d5a3dc3812dc7025" translate="yes" xml:space="preserve">
          <source>bignum - Transparent BigNumber support for Perl</source>
          <target state="translated">bignum-为Perl提供透明的BigNumber支持。</target>
        </trans-unit>
        <trans-unit id="cfc363199f35898d0c10e170520f53e8601bb52d" translate="yes" xml:space="preserve">
          <source>bignum recognizes some options that can be passed while loading it via use. The options can (currently) be either a single letter form, or the long form. The following options exist:</source>
          <target state="translated">bignum 识别一些选项,这些选项可以在通过使用加载时传递。这些选项可以(目前)是单字母形式,也可以是长形式。存在以下选项。</target>
        </trans-unit>
        <trans-unit id="59cfee0f6bb73ee64a7b9dbb363c27ea0eb9f302" translate="yes" xml:space="preserve">
          <source>bigrat</source>
          <target state="translated">bigrat</target>
        </trans-unit>
        <trans-unit id="dbf25a54f2fd0d3932bef731375b0ba1d051ef77" translate="yes" xml:space="preserve">
          <source>bigrat - Transparent BigNumber/BigRational support for Perl</source>
          <target state="translated">bigrat-为Perl提供透明的BigNumber/BigRational支持。</target>
        </trans-unit>
        <trans-unit id="7e19d6f26f79bdfbe7853603c9a8d51e943da151" translate="yes" xml:space="preserve">
          <source>bin.U</source>
          <target state="translated">bin.U</target>
        </trans-unit>
        <trans-unit id="7e57cfe843145135aee1f4d0d63ceb7842093712" translate="yes" xml:space="preserve">
          <source>binary</source>
          <target state="translated">binary</target>
        </trans-unit>
        <trans-unit id="a7932f025d5ca969d2e5249dfaee5d1123fb29da" translate="yes" xml:space="preserve">
          <source>binary representation. Leaving floating point numbers aside for the moment, the salient properties of any such representation are:</source>
          <target state="translated">二进制表示法。暂且不说浮点数,任何这种表示方法的突出特性是:</target>
        </trans-unit>
        <trans-unit id="988edf147febb2b4b364a6acf2ddf6d4e94e8f33" translate="yes" xml:space="preserve">
          <source>binary, setting the C pre-processor macro &lt;code&gt;PERL_SUB_DEPTH_WARN&lt;/code&gt; to the desired value.</source>
          <target state="translated">二进制，将C预处理程序宏 &lt;code&gt;PERL_SUB_DEPTH_WARN&lt;/code&gt; 设置为所需值。</target>
        </trans-unit>
        <trans-unit id="de2cc6807b3c1fe9f5060a6094b70de72fb1f441" translate="yes" xml:space="preserve">
          <source>binary, which affect its binary compatibility with extensions. &lt;code&gt;bincompat_options()&lt;/code&gt; and &lt;code&gt;non_bincompat_options()&lt;/code&gt; are shown together in the output of &lt;code&gt;perl -V&lt;/code&gt; as</source>
          <target state="translated">二进制文件，这会影响其与扩展程序的二进制兼容性。在 &lt;code&gt;perl -V&lt;/code&gt; 的输出 &lt;code&gt;bincompat_options()&lt;/code&gt; 和 &lt;code&gt;non_bincompat_options()&lt;/code&gt; 一起显示为</target>
        </trans-unit>
        <trans-unit id="b636cf5b464cf1767119b4fe29df7c510211a548" translate="yes" xml:space="preserve">
          <source>binary, which do not affect binary compatibility with extensions.</source>
          <target state="translated">二进制,不影响二进制与扩展的兼容性。</target>
        </trans-unit>
        <trans-unit id="27b0abcf6d482c493480a28ab67814ecd71ae2f0" translate="yes" xml:space="preserve">
          <source>binary/&lt;code&gt;API&lt;/code&gt;</source>
          <target state="translated">binary/&lt;code&gt;API&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bdd4db977b0f96aaf3bff2e4300153c648ca382" translate="yes" xml:space="preserve">
          <source>bind</source>
          <target state="translated">bind</target>
        </trans-unit>
        <trans-unit id="15cb6b206f5309c215554249b37ea718b7489464" translate="yes" xml:space="preserve">
          <source>bind SOCKET,NAME</source>
          <target state="translated">bind SOCKET,NAME</target>
        </trans-unit>
        <trans-unit id="b8caa416ad22dfd04289ea1a80760faf5b038881" translate="yes" xml:space="preserve">
          <source>binmode</source>
          <target state="translated">binmode</target>
        </trans-unit>
        <trans-unit id="5e65b13dafb6dd4c759cc9455fddbe5bd69a8e0f" translate="yes" xml:space="preserve">
          <source>binmode FILEHANDLE</source>
          <target state="translated">binmode FILEHANDLE</target>
        </trans-unit>
        <trans-unit id="baf4fab3113579642465b028f8be5d19dbe690da" translate="yes" xml:space="preserve">
          <source>binmode FILEHANDLE, LAYER</source>
          <target state="translated">binmode FILEHANDLE,LAYER(层)</target>
        </trans-unit>
        <trans-unit id="fab68bdc2486879246a68125daf732306cd8090f" translate="yes" xml:space="preserve">
          <source>binmode() is important not only for readline() and print() operations, but also when using read(), seek(), sysread(), syswrite() and tell() (see &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; for more details). See the &lt;code&gt;$/&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt; variables in &lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt; for how to manually set your input and output line-termination sequences.</source>
          <target state="translated">binmode（）不仅对于readline（）和print（）操作很重要，而且在使用read（），seek（），sysread（），syswrite（）和tell（）时也很重要（有关更多详细信息，请参见&lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;）。有关如何手动设置输入和输出行终止顺序的信息，请参见&lt;a href=&quot;../perlvar&quot;&gt;perlvar中&lt;/a&gt;的 &lt;code&gt;$/&lt;/code&gt; 和 &lt;code&gt;$\&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="c6cf70d51d1b9249c9bedbb5a665191357d92d38" translate="yes" xml:space="preserve">
          <source>binmode() is important not only for readline() and print() operations, but also when using read(), seek(), sysread(), syswrite() and tell() (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for more details). See the &lt;code&gt;$/&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt; variables in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for how to manually set your input and output line-termination sequences.</source>
          <target state="translated">binmode（）不仅对于readline（）和print（）操作很重要，而且在使用read（），seek（），sysread（），syswrite（）和tell（）时也很重要（有关更多详细信息，请参见&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;）。有关如何手动设置输入和输出行终止顺序的信息，请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar中&lt;/a&gt;的 &lt;code&gt;$/&lt;/code&gt; 和 &lt;code&gt;$\&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="64304f0eaf264d4083a161af95cca3f4fc9956cd" translate="yes" xml:space="preserve">
          <source>binmode() operates similarly to open(): by default the specified layers are pushed on top of the existing stack.</source>
          <target state="translated">binmode()的操作类似于open():默认情况下,指定的层会被推送到现有栈的顶部。</target>
        </trans-unit>
        <trans-unit id="20f2d91e547cecad3b564ae99be53b45a6e670cc" translate="yes" xml:space="preserve">
          <source>bison on BS2000</source>
          <target state="translated">BS2000上的野牛</target>
        </trans-unit>
        <trans-unit id="f019d80321d209bdb5e25621a435c0f92ac86cfd" translate="yes" xml:space="preserve">
          <source>bits that is computed from the data value by doing sums. For numeric unpack codes, no big feat is achieved:</source>
          <target state="translated">位,是通过做和来计算数据值的。对于数字解包码,没有大的功力。</target>
        </trans-unit>
        <trans-unit id="5bf1fd927dfb8679496a2e6cf00cbe50c1c87145" translate="yes" xml:space="preserve">
          <source>blah</source>
          <target state="translated">blah</target>
        </trans-unit>
        <trans-unit id="fcfd8b08b9dfc18492f53d1d51ef8d9ad41fbf87" translate="yes" xml:space="preserve">
          <source>blah.</source>
          <target state="translated">blah.</target>
        </trans-unit>
        <trans-unit id="c6198477997fe2771883ee25a1a71d0e4c7432b1" translate="yes" xml:space="preserve">
          <source>blah.exe</source>
          <target state="translated">blah.exe</target>
        </trans-unit>
        <trans-unit id="710f4beb6f3094fc46248a083fb427bcc0ad2e24" translate="yes" xml:space="preserve">
          <source>bless</source>
          <target state="translated">bless</target>
        </trans-unit>
        <trans-unit id="e4f59c387f62cb1edb42a1911954c50219be47d9" translate="yes" xml:space="preserve">
          <source>bless REF</source>
          <target state="translated">祝福REF</target>
        </trans-unit>
        <trans-unit id="2e44205459ae344b338868e3b6b33bce58faf520" translate="yes" xml:space="preserve">
          <source>bless REF,CLASSNAME</source>
          <target state="translated">祝福REF,CLASSNAME</target>
        </trans-unit>
        <trans-unit id="a49b3189e430e15827425d766ade8c8277059efb" translate="yes" xml:space="preserve">
          <source>bless, blessed, and ref</source>
          <target state="translated">佑、福、禄</target>
        </trans-unit>
        <trans-unit id="f08a7a19e6f47e1125c9aee2336c6759c7798fe4" translate="yes" xml:space="preserve">
          <source>blessed</source>
          <target state="translated">blessed</target>
        </trans-unit>
        <trans-unit id="7cdb9aa0f32f7a30fb9e35578aff5c7297e84bc8" translate="yes" xml:space="preserve">
          <source>blessings</source>
          <target state="translated">blessings</target>
        </trans-unit>
        <trans-unit id="5948cd46ec4b37fb77f455070c85e3a53a5385e6" translate="yes" xml:space="preserve">
          <source>blib</source>
          <target state="translated">blib</target>
        </trans-unit>
        <trans-unit id="58725a4e858a2c6188cdb04784100e5472989d90" translate="yes" xml:space="preserve">
          <source>blib - Use MakeMaker's uninstalled version of a package</source>
          <target state="translated">blib-使用MakeMaker未安装的包的版本。</target>
        </trans-unit>
        <trans-unit id="a76058b40e0fac4a71812a9bc906c2fefb88858f" translate="yes" xml:space="preserve">
          <source>blibdirs_target</source>
          <target state="translated">blibdirs_target</target>
        </trans-unit>
        <trans-unit id="0214b4b355d11ca8f2ce45a968c264651bdfbf83" translate="yes" xml:space="preserve">
          <source>block</source>
          <target state="translated">block</target>
        </trans-unit>
        <trans-unit id="de78f4557b8f92abac734524c8092acd1ff00895" translate="yes" xml:space="preserve">
          <source>blsft()/brsft()</source>
          <target state="translated">blsft()/brsft()</target>
        </trans-unit>
        <trans-unit id="2e264db45128e397f171695bf390adfeef3598d7" translate="yes" xml:space="preserve">
          <source>bmod()</source>
          <target state="translated">bmod()</target>
        </trans-unit>
        <trans-unit id="acb2323220a9a7746a44255816d71f5351a4790a" translate="yes" xml:space="preserve">
          <source>bneg()</source>
          <target state="translated">bneg()</target>
        </trans-unit>
        <trans-unit id="33366fdd69ce84e94b98d8a229f85a41c634530c" translate="yes" xml:space="preserve">
          <source>bnok()</source>
          <target state="translated">bnok()</target>
        </trans-unit>
        <trans-unit id="c770c8e7173b85479c2dc8ac9f7dcbb9bc5fe2f3" translate="yes" xml:space="preserve">
          <source>bnorm()</source>
          <target state="translated">bnorm()</target>
        </trans-unit>
        <trans-unit id="32895dc66f25fd7dac0899bd9b4408dd1841faf8" translate="yes" xml:space="preserve">
          <source>bnorm() on a BigFloat object is now effectively a no-op, since the numbers are always stored in normalized form. On a string, it creates a BigFloat object.</source>
          <target state="translated">现在,BigFloat 对象上的 bnorm()有效地成为一个无操作的对象,因为数字总是以归一化的形式存储。在字符串上,它会创建一个BigFloat对象。</target>
        </trans-unit>
        <trans-unit id="02083f4579e08a612425c0c1a17ee47add783b94" translate="yes" xml:space="preserve">
          <source>body</source>
          <target state="translated">body</target>
        </trans-unit>
        <trans-unit id="1aed26655fb288402a22a39e65ab37ea6faa2d19" translate="yes" xml:space="preserve">
          <source>book-keeping code to the generated code. During the execution of the code the basic block counters are then updated appropriately. The caveat is that the added extra code can skew the results: again, the profiling tools usually try to factor their own effects out of the results.</source>
          <target state="translated">簿记代码到生成的代码中。在执行代码的过程中,基本的块计数器就会得到适当的更新。需要注意的是,增加的额外代码可能会使结果偏斜:同样,剖析工具通常会尝试将自己的影响从结果中剔除。</target>
        </trans-unit>
        <trans-unit id="729e45dc00b922b49b39fefe181e1e856ed87ec4" translate="yes" xml:space="preserve">
          <source>boot_Module</source>
          <target state="translated">boot_Module</target>
        </trans-unit>
        <trans-unit id="ba663f22e3229112460a32e29c16274682d6bf7a" translate="yes" xml:space="preserve">
          <source>boot_ModuleName</source>
          <target state="translated">boot_ModuleName</target>
        </trans-unit>
        <trans-unit id="3c71cc99d2fc1c12a3d3e1b27e448ca612a89a1d" translate="yes" xml:space="preserve">
          <source>bootstrap</source>
          <target state="translated">bootstrap</target>
        </trans-unit>
        <trans-unit id="4b73f58647d46c351e92c5308bdff57c346a520b" translate="yes" xml:space="preserve">
          <source>bootstrap($module [...])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7910fb624621794d30d4a0171b4ef16c06efef31" translate="yes" xml:space="preserve">
          <source>bootstraps the shared library and</source>
          <target state="translated">引导共享库和</target>
        </trans-unit>
        <trans-unit id="05b1f356646c24bf1765f6f1b65aea3bde7247e1" translate="yes" xml:space="preserve">
          <source>boss</source>
          <target state="translated">boss</target>
        </trans-unit>
        <trans-unit id="fc39b18f287d8bbfaceae020f4a4eb32ac5c1e70" translate="yes" xml:space="preserve">
          <source>both</source>
          <target state="translated">both</target>
        </trans-unit>
        <trans-unit id="abb0e3da05698e3415e8b8587366c2e5c9fe8869" translate="yes" xml:space="preserve">
          <source>both map to</source>
          <target state="translated">两者都映射到</target>
        </trans-unit>
        <trans-unit id="654dc453fcad5d97496638c1771b5fea1e41eb18" translate="yes" xml:space="preserve">
          <source>both of which mean to enable locale awarness of all categories but &lt;code&gt;LC_CTYPE&lt;/code&gt; . Only one category argument may be specified in a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; if it is of the negated form.</source>
          <target state="translated">两者都意味着启用除 &lt;code&gt;LC_CTYPE&lt;/code&gt; 之外的所有类别的语言环境警告。如果它是否定形式，则只能在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 指定一个类别参数。</target>
        </trans-unit>
        <trans-unit id="26d491c7e7617951114de7ec765c4e99eb127ce3" translate="yes" xml:space="preserve">
          <source>both s and m modifiers (//sm): Treat string as a single long line, but detect multiple lines. &lt;code&gt;'.'&lt;/code&gt; matches any character, even &lt;code&gt;&quot;\n&quot;&lt;/code&gt; . &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; , however, are able to match at the start or end of</source>
          <target state="translated">s和m修饰符（// sm）：将字符串视为单个长行，但检测到多行。 &lt;code&gt;'.'&lt;/code&gt; 匹配任何字符，甚至是 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 。 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 可以在开头或结尾匹配</target>
        </trans-unit>
        <trans-unit id="d145e8b6add511128e3c21f5ad3c0317ad3aa0f5" translate="yes" xml:space="preserve">
          <source>both supply a list context to the right-hand side, while</source>
          <target state="translated">都在右侧提供一个列表上下文,而</target>
        </trans-unit>
        <trans-unit id="ddb1e7c979a33eef473274634ab437e562e02159" translate="yes" xml:space="preserve">
          <source>bother</source>
          <target state="translated">bother</target>
        </trans-unit>
        <trans-unit id="23998aef8c711bbb24e99222ca54b2d1029087d8" translate="yes" xml:space="preserve">
          <source>bpow()</source>
          <target state="translated">bpow()</target>
        </trans-unit>
        <trans-unit id="8a6b08579a9805d7dea44b94ea1dcb6609f11536" translate="yes" xml:space="preserve">
          <source>bracketed character classes, and are a convenient and descriptive way of listing a group of characters.</source>
          <target state="translated">括号内的字符类,是一种方便的、描述性的列出一组字符的方式。</target>
        </trans-unit>
        <trans-unit id="837cc1c54b7aa66d67f7d308af69db6dc69fbbe4" translate="yes" xml:space="preserve">
          <source>brackets subscripts, so you can shrink the above down to</source>
          <target state="translated">括号中的下标,所以你可以将上面的内容缩小到</target>
        </trans-unit>
        <trans-unit id="4f9cac8dbc4c67a388b8379dcc126c90c7c5e72a" translate="yes" xml:space="preserve">
          <source>break</source>
          <target state="translated">break</target>
        </trans-unit>
        <trans-unit id="bb43d711172bd27bbb3fc18fb773e33edc6b3165" translate="yes" xml:space="preserve">
          <source>breaking down the problem into smaller parts,</source>
          <target state="translated">将问题分解成更小的部分。</target>
        </trans-unit>
        <trans-unit id="ef6896ab2d5a3c6e8ba7ee46ba3e48c29057ad74" translate="yes" xml:space="preserve">
          <source>breakout</source>
          <target state="translated">breakout</target>
        </trans-unit>
        <trans-unit id="b33a5b3e6b7eb3b9f7f1a0e451dee877c2374873" translate="yes" xml:space="preserve">
          <source>breaks this paradigm;</source>
          <target state="translated">打破了这种模式。</target>
        </trans-unit>
        <trans-unit id="58bcf671da7c6005da184d1a734e880e766af7f5" translate="yes" xml:space="preserve">
          <source>brian d foy &lt;code&gt;&amp;lt;brian.d.foy@gmail.com&amp;gt;&lt;/code&gt;</source>
          <target state="translated">布莱恩&amp;middot; &lt;code&gt;&amp;lt;brian.d.foy@gmail.com&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96a69616cc78fb488e50bb7f07bd37667d493f80" translate="yes" xml:space="preserve">
          <source>broken.</source>
          <target state="translated">broken.</target>
        </trans-unit>
        <trans-unit id="0b12bb49ef8a21331b0526566fe4b80e5eaec019" translate="yes" xml:space="preserve">
          <source>broot()</source>
          <target state="translated">broot()</target>
        </trans-unit>
        <trans-unit id="6fa78ae26f483beb12891190edb2dc005e4cbe3b" translate="yes" xml:space="preserve">
          <source>bround()/round()/bfround()</source>
          <target state="translated">bround()/round()/bfround()</target>
        </trans-unit>
        <trans-unit id="1dbd729f945c8998e112203241f2035b87c572b0" translate="yes" xml:space="preserve">
          <source>bsd_glob() returns a list of matching paths, possibly zero length. If an error occurred, &amp;amp;File::Glob::GLOB_ERROR will be non-zero and &lt;code&gt;$!&lt;/code&gt; will be set. &amp;amp;File::Glob::GLOB_ERROR is guaranteed to be zero if no error occurred, or one of the following values otherwise:</source>
          <target state="translated">bsd_glob（）返回匹配路径的列表，长度可能为零。如果发生错误，＆File :: Glob :: GLOB_ERROR将为非零值和 &lt;code&gt;$!&lt;/code&gt; 将被设置。如果没有发生错误，＆File :: Glob :: GLOB_ERROR保证为零，否则为以下值之一：</target>
        </trans-unit>
        <trans-unit id="60747fb94e0ee1e6a3033c0be43d87212b33a4f5" translate="yes" xml:space="preserve">
          <source>bsddev.zip</source>
          <target state="translated">bsddev.zip</target>
        </trans-unit>
        <trans-unit id="98e6344878aedd07915a448203ac11106893ceb4" translate="yes" xml:space="preserve">
          <source>bsqrt()</source>
          <target state="translated">bsqrt()</target>
        </trans-unit>
        <trans-unit id="d0f6068194aa4e1d1262dafb62bcf499c7cc6deb" translate="yes" xml:space="preserve">
          <source>bstr()/bsstr()</source>
          <target state="translated">bstr()/bsstr()</target>
        </trans-unit>
        <trans-unit id="fe1b2b96400138c433e3bcd27a0351d10505d6a4" translate="yes" xml:space="preserve">
          <source>btree(3)</source>
          <target state="translated">btree(3)</target>
        </trans-unit>
        <trans-unit id="39001d5c18f51088ca9e1057a5abbd818117d55a" translate="yes" xml:space="preserve">
          <source>build them, but you must link the XSUBs subroutines with the rest of Perl, creating a new executable. This situation is similar to Perl 4.</source>
          <target state="translated">构建它们,但你必须将XSUBs子程序与Perl的其他部分连接起来,创建一个新的可执行文件。这种情况与Perl 4类似。</target>
        </trans-unit>
        <trans-unit id="f52318a05e518a5596012af2ed38de68ac26a468" translate="yes" xml:space="preserve">
          <source>builder</source>
          <target state="translated">builder</target>
        </trans-unit>
        <trans-unit id="9b72ae582cc1e1e343de827cc627cd49a4a6c7c4" translate="yes" xml:space="preserve">
          <source>building below the perl source directory. If you</source>
          <target state="translated">构建在perl源目录下。如果你</target>
        </trans-unit>
        <trans-unit id="947d8f664d143e01412e73e257100b32b9ed0ecf" translate="yes" xml:space="preserve">
          <source>building below the perl source, INST_LIB and INST_ARCHLIB default to ../../lib, and INST_SCRIPT is not defined.</source>
          <target state="translated">在perl源码下面构建,INST_LIB和INST_ARCHLIB默认为./.../lib,INST_SCRIPT没有定义。</target>
        </trans-unit>
        <trans-unit id="f125862e397bf52c7831a13c2443aeda18c3ffb1" translate="yes" xml:space="preserve">
          <source>builds a PPD package that references a binary of the &lt;code&gt;Agent&lt;/code&gt; package, located in the &lt;code&gt;x86&lt;/code&gt; directory relative to the PPD itself.</source>
          <target state="translated">构建一个PPD程序包，该 &lt;code&gt;Agent&lt;/code&gt; 包引用Agent程序包的二进制文件，该文件位于相对于PPD本身的 &lt;code&gt;x86&lt;/code&gt; 目录中。</target>
        </trans-unit>
        <trans-unit id="54c968766b16149a445212d3b145a5471982de2f" translate="yes" xml:space="preserve">
          <source>builds a Perl extension for use by Encode from either Unicode Character Mapping files (.ucm) or Tcl Encoding Files (.enc). Besides being used internally during the build process of the Encode module, you can use</source>
          <target state="translated">从Unicode字符映射文件(.ucm)或Tcl编码文件(.enc)中建立一个Perl扩展,供Encode使用。除了在Encode模块的构建过程中在内部使用外,您还可以使用</target>
        </trans-unit>
        <trans-unit id="02270db35bb6bd281f1f08fafc816eeb39611e44" translate="yes" xml:space="preserve">
          <source>builds a Perl extension from C header files. The extension will include functions which can be used to retrieve the value of any #define statement which was in the C header files.</source>
          <target state="translated">从C语言头文件建立一个Perl扩展。该扩展将包含一些函数,这些函数可以用来检索 C 头文件中任何 #define 语句的值。</target>
        </trans-unit>
        <trans-unit id="353c847ec3d51fb75d760939a900605ca2ba1152" translate="yes" xml:space="preserve">
          <source>built</source>
          <target state="translated">built</target>
        </trans-unit>
        <trans-unit id="35e8277cc95cf8aaf1e8e9ffcb5ea39e6502bbd0" translate="yes" xml:space="preserve">
          <source>bundles</source>
          <target state="translated">bundles</target>
        </trans-unit>
        <trans-unit id="97bd27f135ae383d1ab339e2ddd56faabfe06a3c" translate="yes" xml:space="preserve">
          <source>bunzip2 $input_filename_or_reference =&amp;gt; $output_filename_or_reference [, OPTS]</source>
          <target state="translated">bunzip2 $ input_filename_or_reference =&amp;gt; $ output_filename_or_reference [，OPTS]</target>
        </trans-unit>
        <trans-unit id="786e97b3ee9fc4b292d5852c2c5943153c4ce91a" translate="yes" xml:space="preserve">
          <source>but</source>
          <target state="translated">but</target>
        </trans-unit>
        <trans-unit id="cf72a790bf9220db925b72c5cbee1dd78ac17da1" translate="yes" xml:space="preserve">
          <source>but $var is referenced elsewhere and could be modified after the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; expression is evaluated. Either it is explicitly modified elsewhere (&lt;code&gt;$var = 3&lt;/code&gt; ) or it is passed to a subroutine or to an operator like &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, which may or may not modify the variable.</source>
          <target state="translated">但是$ var在其他地方引用，可以在计算 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 表达式后对其进行修改。要么在其他地方显式地修改它（ &lt;code&gt;$var = 3&lt;/code&gt; ），要么将其传递给子例程或传递给 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 的运算符，后者可能会或可能不会修改变量。</target>
        </trans-unit>
        <trans-unit id="71b30c3e0c461e872d1934c8031a13c3d20f53a0" translate="yes" xml:space="preserve">
          <source>but a string consisting of two null bytes (the result of &lt;code&gt;&quot;\020\020&quot;
&amp;amp; &quot;\101\101&quot;&lt;/code&gt; ) is not a false value in Perl. You need:</source>
          <target state="translated">但是由两个空字节组成的字符串（ &lt;code&gt;&quot;\020\020&quot; &amp;amp; &quot;\101\101&quot;&lt;/code&gt; ）在Perl中不是假值。你需要：</target>
        </trans-unit>
        <trans-unit id="0f5c833e6b8ad19de738251b4d0e198a912780cf" translate="yes" xml:space="preserve">
          <source>but avoids the need to know $cpt's package name.</source>
          <target state="translated">但避免了需要知道$cpt的包名。</target>
        </trans-unit>
        <trans-unit id="14589f2bfb988ba357d07d902945d6c51ace67f6" translate="yes" xml:space="preserve">
          <source>but calling any method that modifies the number directly will result in &lt;b&gt;both&lt;/b&gt; the original and the copy being destroyed:</source>
          <target state="translated">但是直接调用任何修改数字的方法将导致原始和副本&lt;b&gt;均被&lt;/b&gt;破坏：</target>
        </trans-unit>
        <trans-unit id="2a43af42a3edda8e818e0b4b4bad6b01d151755a" translate="yes" xml:space="preserve">
          <source>but doesn't spit out extra fields. It's also cheaper not to capture characters if you don't need to.</source>
          <target state="translated">但不会吐出额外的字段。如果不需要的话,不采集字符也比较便宜。</target>
        </trans-unit>
        <trans-unit id="15e6be4e78dba9fceaa351875dbb83140728ef88" translate="yes" xml:space="preserve">
          <source>but faster.</source>
          <target state="translated">但速度更快。</target>
        </trans-unit>
        <trans-unit id="5db5323d8075957d671047bee13d624d6956eafd" translate="yes" xml:space="preserve">
          <source>but in actual fact, you got</source>
          <target state="translated">但实际上,你得到了</target>
        </trans-unit>
        <trans-unit id="f46b2388486d21f0ad260e041f0ddfc6e4c238c0" translate="yes" xml:space="preserve">
          <source>but instead you get:</source>
          <target state="translated">但你却得到。</target>
        </trans-unit>
        <trans-unit id="670c9eed4ef45780d6a27c66aa6737f774ca7361" translate="yes" xml:space="preserve">
          <source>but is more efficient. Returns the number of elements in the array following the completed &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">但效率更高。返回完成 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 之后数组中元素的数量。</target>
        </trans-unit>
        <trans-unit id="ea2b46c116a2c87653b1086423551aaba04ef434" translate="yes" xml:space="preserve">
          <source>but is more efficient. Returns the number of elements in the array following the completed &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">但效率更高。返回完成 &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 之后数组中元素的数量。</target>
        </trans-unit>
        <trans-unit id="430a12560afed6b52405b428e0d46fec40e28bab" translate="yes" xml:space="preserve">
          <source>but not a mixture of both as in:</source>
          <target state="translated">但并不是两者兼而有之,如:</target>
        </trans-unit>
        <trans-unit id="07b3726c790e16484102349cd362b2dc216a33e9" translate="yes" xml:space="preserve">
          <source>but rather as class methods:</source>
          <target state="translated">而是作为类方法。</target>
        </trans-unit>
        <trans-unit id="9702a21ebfe300cef572f0598fe961666de341c4" translate="yes" xml:space="preserve">
          <source>but remember that there's a startup cost to pay in that case (see above &quot;libperl and Prebinding&quot;).</source>
          <target state="translated">但请记住,在这种情况下,需要支付启动成本(参见上面的 &quot;libperl和Prebinding&quot;)。</target>
        </trans-unit>
        <trans-unit id="acb2133a2923255080591abe8aebb2b94ab97c8d" translate="yes" xml:space="preserve">
          <source>but shorter. Parent directory specifications are stripped from the template itself. The C</source>
          <target state="translated">但更短。父目录规格从模板本身中剥离出来。C</target>
        </trans-unit>
        <trans-unit id="62ddbd66e01cf82298f15351b5c586e039d8e26c" translate="yes" xml:space="preserve">
          <source>but since you anticipate localizing this, you write:</source>
          <target state="translated">但既然你预料到会本地化,你就写。</target>
        </trans-unit>
        <trans-unit id="f4adbde7584db1a7c8b596705eb7136fbd8e99a5" translate="yes" xml:space="preserve">
          <source>but that makes no difference compared with the -Duse64bitint because of the &lt;code&gt;cc -64&lt;/code&gt; .</source>
          <target state="translated">但这与-Duse64bitint相比没有什么区别，因为 &lt;code&gt;cc -64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23d8d8f376b2cff8835a27af9acf7c580e3a9e81" translate="yes" xml:space="preserve">
          <source>but that may be just luck. Other AntiVirus software may have similar issues.</source>
          <target state="translated">但这可能只是运气。其他反病毒软件也可能有类似的问题。</target>
        </trans-unit>
        <trans-unit id="ed3d39f2ff5bb81326e9be2a017f7421168dc990" translate="yes" xml:space="preserve">
          <source>but that will be silently converted into &lt;code&gt;[3,-3pi/4]&lt;/code&gt;, since the modulus must be non-negative (it represents the distance to the origin in the complex plane).</source>
          <target state="translated">但由于模数必须为非负数（表示到复平面中到原点的距离），因此将无声转换为 &lt;code&gt;[3,-3pi/4]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b509dd9066df836513e27436a8d4e7ade7f0b728" translate="yes" xml:space="preserve">
          <source>but the comma is not</source>
          <target state="translated">但逗号不是</target>
        </trans-unit>
        <trans-unit id="9384ff012c073541ee4cf2ad0804fa1a41e628ac" translate="yes" xml:space="preserve">
          <source>but the syntax of Perl doesn't allow this. You need a comma after the string. (Of course, you may consider it a bug that commas between all the constants aren't required, in which case you may feel free to insert commas unless you're using $Term::ANSIColor::AUTORESET or PUSHCOLOR/POPCOLOR.)</source>
          <target state="translated">但 Perl 的语法不允许这样做。你需要在字符串后面加一个逗号。(当然,你可能会认为这是一个错误,因为在所有常量之间不需要逗号,在这种情况下,你可以随意插入逗号,除非你使用 $Term::ANSIColor::AUTORESET 或 PUSHCOLOR/POPCOLOR。)</target>
        </trans-unit>
        <trans-unit id="f59fd7340224ad23961f9ec29fad42c961b15b81" translate="yes" xml:space="preserve">
          <source>but then $foo no longer contains a glob.</source>
          <target state="translated">但这样一来,$foo就不再包含一个glob了。</target>
        </trans-unit>
        <trans-unit id="5e375615161c63e7fc29a1c88b265148575b94e3" translate="yes" xml:space="preserve">
          <source>but then cannot see that &quot;En_US&quot; listed by the above-mentioned commands. You may see things like &quot;en_US.ISO8859-1&quot;, but that isn't the same. In this case, try running under a locale that you can list and which somehow matches what you tried. The rules for matching locale names are a bit vague because standardization is weak in this area. See again the &lt;a href=&quot;#Finding-locales&quot;&gt;Finding locales&lt;/a&gt; about general rules.</source>
          <target state="translated">但随后看不到上述命令列出的&amp;ldquo; En_US&amp;rdquo;。您可能会看到类似&amp;ldquo; en_US.ISO8859-1&amp;rdquo;的内容，但这并不相同。在这种情况下，请尝试在您可以列出且与您尝试的方式匹配的语言环境下运行。匹配语言环境名称的规则有点模糊，因为在该领域标准化很薄弱。再次参见有关一般规则的&lt;a href=&quot;#Finding-locales&quot;&gt;查找语言环境&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3cac644780c84e33b8c8e17e1aa72c863bdc551c" translate="yes" xml:space="preserve">
          <source>but then modify it if the current Configure options warrant.</source>
          <target state="translated">但如果当前配置选项需要的话,再进行修改。</target>
        </trans-unit>
        <trans-unit id="9bbd6063bd561229cf513f5487e005633f74b476" translate="yes" xml:space="preserve">
          <source>but these will fail:</source>
          <target state="translated">但这些都会失败。</target>
        </trans-unit>
        <trans-unit id="ca81437b80f2ad6457ea481a09d4317a77895103" translate="yes" xml:space="preserve">
          <source>but this can be altered by passing a second argument to &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; or &lt;code&gt;FILTER&lt;/code&gt; (just remember: there's</source>
          <target state="translated">但这可以通过传递第二个参数来 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; 或 &lt;code&gt;FILTER&lt;/code&gt; 来更改（请记住：</target>
        </trans-unit>
        <trans-unit id="e691b4ae28b1162e1f37e88fdb2e7fa3a57809e2" translate="yes" xml:space="preserve">
          <source>but this will not</source>
          <target state="translated">但这不会</target>
        </trans-unit>
        <trans-unit id="50607a6413ca39fe7073dd9a3b641d9d68b5acf2" translate="yes" xml:space="preserve">
          <source>but translates into</source>
          <target state="translated">但译为</target>
        </trans-unit>
        <trans-unit id="d32b03d32cae9215bc5e3eedc3a4a9edf0f113a6" translate="yes" xml:space="preserve">
          <source>but under a French locale</source>
          <target state="translated">但在法国本土</target>
        </trans-unit>
        <trans-unit id="02bc126135ab3f34b2cc7b1c93207acc39efb18e" translate="yes" xml:space="preserve">
          <source>but with &lt;code&gt;extract_delimited&lt;/code&gt; it can be simplified to:</source>
          <target state="translated">但是使用 &lt;code&gt;extract_delimited&lt;/code&gt; 可以简化为：</target>
        </trans-unit>
        <trans-unit id="5a3caba3b95cb830b6cd3bb3694f24d055d2aa69" translate="yes" xml:space="preserve">
          <source>but you have to say</source>
          <target state="translated">但你必须说</target>
        </trans-unit>
        <trans-unit id="790b666b737305903b34914bd264529abbf92746" translate="yes" xml:space="preserve">
          <source>but you should be aware that in this form, the &lt;code&gt;..&lt;/code&gt; operator creates a list of all integers in the range, which can take a lot of memory for large ranges. However, the problem does not occur when using &lt;code&gt;..&lt;/code&gt; within a &lt;code&gt;for&lt;/code&gt; loop, because in that case the range operator is optimized to</source>
          <target state="translated">但您应该注意，在这种格式下， &lt;code&gt;..&lt;/code&gt; 运算符会创建该范围内所有整数的列表，这在较大范围内可能会占用大量内存。但是，使用时不会发生问题 &lt;code&gt;..&lt;/code&gt; 内的 &lt;code&gt;for&lt;/code&gt; 循环，因为在那种情况下，操作者范围被优化以</target>
        </trans-unit>
        <trans-unit id="920f4cbc6f3b3ccfd1fe8ce2d2eca6336d87c327" translate="yes" xml:space="preserve">
          <source>but your system might have more.</source>
          <target state="translated">但你的系统可能有更多。</target>
        </trans-unit>
        <trans-unit id="0a0df778ce40c92b4130fd3cc1bc732e0dcd8097" translate="yes" xml:space="preserve">
          <source>but your version of perl is compiled without perlio, and this form of open is not supported.</source>
          <target state="translated">但你的perl版本是在没有perlio的情况下编译的,不支持这种形式的开放。</target>
        </trans-unit>
        <trans-unit id="f6cf3e61369618c4d062082f34a8e4eb6950efaa" translate="yes" xml:space="preserve">
          <source>but, because &lt;code&gt;&quot;*&quot;&lt;/code&gt; is higher precedence than named operators:</source>
          <target state="translated">但是，因为 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 的优先级高于命名运算符：</target>
        </trans-unit>
        <trans-unit id="408158643ed564c72fa0921826f8294d71ccbf7c" translate="yes" xml:space="preserve">
          <source>by</source>
          <target state="translated">by</target>
        </trans-unit>
        <trans-unit id="b562123d16a87ef1dd2d50e459ddac28857a828c" translate="yes" xml:space="preserve">
          <source>by &lt;code&gt;BEGIN{ $/ = &quot;\0digits&quot;; }&lt;/code&gt; .</source>
          <target state="translated">由 &lt;code&gt;BEGIN{ $/ = &quot;\0digits&quot;; }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d7f03736d7aee983a0f27b66b3cd7bd23ae58bf" translate="yes" xml:space="preserve">
          <source>by Andreas Koenig &amp;lt;&lt;code&gt;k@anna.in-berlin.de&lt;/code&gt; &amp;gt; and Tim Bunce.</source>
          <target state="translated">由Andreas Koenig &amp;lt; &lt;code&gt;k@anna.in-berlin.de&lt;/code&gt; &amp;gt;和Tim Bunce 撰写。</target>
        </trans-unit>
        <trans-unit id="58b9be2f90b4b5e0f72bcc70fc011d637b555279" translate="yes" xml:space="preserve">
          <source>by Jeffrey Friedl (</source>
          <target state="translated">由Jeffrey Friedl (</target>
        </trans-unit>
        <trans-unit id="b7d25fddceaf2bede4f0c1508fc9756858ff0f82" translate="yes" xml:space="preserve">
          <source>by Jeffrey Friedl (published by O'Reilly, ISBN 1556592-257-3).</source>
          <target state="translated">由Jeffrey Friedl撰写(O'Reilly出版,ISBN 1556592-257-3)。</target>
        </trans-unit>
        <trans-unit id="01bcdce954a667cee1cea208aa989626d65f08eb" translate="yes" xml:space="preserve">
          <source>by Jeffrey Friedl gives a wonderful discussion of this and other efficiency issues.</source>
          <target state="translated">杰弗里德尔(Jeffrey Friedl)的著作对这个问题和其他效率问题进行了精彩的讨论。</target>
        </trans-unit>
        <trans-unit id="292b840af5da5995eb868afee859b139a4198e22" translate="yes" xml:space="preserve">
          <source>by Jeffrey Friedl, published by O'Reilly and Associates.</source>
          <target state="translated">由Jeffrey Friedl撰写,O'Reilly and Associates出版。</target>
        </trans-unit>
        <trans-unit id="a030535d3a4b6473025f29bd648142b0bfd7bded" translate="yes" xml:space="preserve">
          <source>by Jeffrey Friedl. He explains how the regular expressions engine works and why some patterns are surprisingly inefficient. Once you understand how perl applies regular expressions, you can tune them for individual situations.</source>
          <target state="translated">由Jeffrey Friedl撰写。他解释了正则表达式引擎是如何工作的,以及为什么有些模式的效率出奇的低。一旦你了解了perl如何应用正则表达式,你就可以根据个别情况对它们进行调整。</target>
        </trans-unit>
        <trans-unit id="aa3b42830418e798c60825381fd17fa38f07279b" translate="yes" xml:space="preserve">
          <source>by W. Richard Stevens (published by Prentice-Hall). Most books on networking address the subject from the perspective of a C programmer; translation to Perl is left as an exercise for the reader.</source>
          <target state="translated">W.Richard Stevens所著(Prentice-Hall出版)。大多数关于网络的书籍都是从C语言程序员的角度来解决这个问题的;翻译成Perl是留给读者的练习。</target>
        </trans-unit>
        <trans-unit id="aa39ccc1df65d58c55c7ad4408539c603519c108" translate="yes" xml:space="preserve">
          <source>by Yves Orton, 2006.</source>
          <target state="translated">Yves Orton著,2006年。</target>
        </trans-unit>
        <trans-unit id="3e3c60c9a79bc01108d963cab52a79402baacea3" translate="yes" xml:space="preserve">
          <source>by compiling using gcc with the flag &lt;code&gt;-pg&lt;/code&gt; . Either edit</source>
          <target state="translated">通过使用带有标志 &lt;code&gt;-pg&lt;/code&gt; 的 gcc进行编译。要么编辑</target>
        </trans-unit>
        <trans-unit id="f5d400126bc4b2b2a0be4cb6f504f4a728dab5e6" translate="yes" xml:space="preserve">
          <source>by compiling using gcc with the flags &lt;code&gt;-fprofile-arcs -ftest-coverage&lt;/code&gt; . Either edit</source>
          <target state="translated">通过使用带有标志 &lt;code&gt;-fprofile-arcs -ftest-coverage&lt;/code&gt; 的 gcc进行编译。要么编辑</target>
        </trans-unit>
        <trans-unit id="ed704a971a09b89d0355af9ed7f590b8d16afef1" translate="yes" xml:space="preserve">
          <source>by default</source>
          <target state="translated">默认</target>
        </trans-unit>
        <trans-unit id="4e935cb2d694a730a179e0fab14594701e7b71b6" translate="yes" xml:space="preserve">
          <source>by default the object is constructed as if C</source>
          <target state="translated">默认情况下,该对象的构造就像C</target>
        </trans-unit>
        <trans-unit id="76e18cd7b5438dfa50021afe47ddf6798a2380ea" translate="yes" xml:space="preserve">
          <source>by default, and this file is read by the &lt;code&gt;dprofpp&lt;/code&gt; program, which is already installed as part of the &lt;code&gt;Devel::DProf&lt;/code&gt; distribution. If you call &lt;code&gt;dprofpp&lt;/code&gt; with no options, it will read the</source>
          <target state="translated">默认情况下，该文件由 &lt;code&gt;dprofpp&lt;/code&gt; 程序读取，该程序已作为 &lt;code&gt;Devel::DProf&lt;/code&gt; 发行版的一部分安装。如果您不带任何选项调用 &lt;code&gt;dprofpp&lt;/code&gt; ，它将读取</target>
        </trans-unit>
        <trans-unit id="ab0866dc7f2a672bc7b6be003ac55641a8c5066d" translate="yes" xml:space="preserve">
          <source>by default. Human readable reports can be generated from here by using the supplied &lt;code&gt;nytprofhtml&lt;/code&gt; (HTML output) and &lt;code&gt;nytprofcsv&lt;/code&gt; (CSV output) programs. We've used the Unix system &lt;code&gt;html2text&lt;/code&gt; utility to convert the</source>
          <target state="translated">默认。可以使用提供的 &lt;code&gt;nytprofhtml&lt;/code&gt; （HTML输出）和 &lt;code&gt;nytprofcsv&lt;/code&gt; （CSV输出）程序在此处生成易于阅读的报告。我们已经使用Unix系统的 &lt;code&gt;html2text&lt;/code&gt; 实用程序来转换</target>
        </trans-unit>
        <trans-unit id="76d6fc20656e3c76019aabc723d52e70642bd78d" translate="yes" xml:space="preserve">
          <source>by endianness</source>
          <target state="translated">苣荬菜</target>
        </trans-unit>
        <trans-unit id="b98507aaeb9a1c77075f94408b252b18efe599de" translate="yes" xml:space="preserve">
          <source>by just using the name of the program).</source>
          <target state="translated">只需使用程序的名称)。)</target>
        </trans-unit>
        <trans-unit id="2c5bb516b1987dabf813c98e4515eda07d81aaa5" translate="yes" xml:space="preserve">
          <source>by name</source>
          <target state="translated">按名称</target>
        </trans-unit>
        <trans-unit id="5e3f04f999831235b9b402a22b7e7de4ce80d90f" translate="yes" xml:space="preserve">
          <source>by size</source>
          <target state="translated">按大小</target>
        </trans-unit>
        <trans-unit id="d5d90792858f3b6ce0d3e628c5cd82bf536aa2e2" translate="yes" xml:space="preserve">
          <source>by the DynaLoader when the shared object is loaded. See BSLOADLIBS below.</source>
          <target state="translated">当加载共享对象时,由DynaLoader加载。参见下面的BSLOADLIBS。</target>
        </trans-unit>
        <trans-unit id="ac25d943ca16593ccd5b638578371920d418f826" translate="yes" xml:space="preserve">
          <source>by the Perl interpreter itself.</source>
          <target state="translated">由Perl解释器本身进行解释。</target>
        </trans-unit>
        <trans-unit id="c2a3a0641c2dba021dc10a286962de22e15df633" translate="yes" xml:space="preserve">
          <source>by the Perl interpreter itself. This attribute's default value is &lt;b&gt;TRUE&lt;/b&gt;. If you want to search only specific directories, set $self-&amp;gt;inc(0) before calling $inc-&amp;gt;survey or $inc-&amp;gt;find.</source>
          <target state="translated">由Perl解释器本身提供。该属性的默认值为&lt;b&gt;TRUE&lt;/b&gt;。如果只想搜索特定目录，请在调用$ inc-&amp;gt; survey或$ inc-&amp;gt; find之前设置$ self-&amp;gt; inc（0）。</target>
        </trans-unit>
        <trans-unit id="1899511ea754deb578535a8d92e9165fcbc88e82" translate="yes" xml:space="preserve">
          <source>by the ld command when the perl binary is linked with the extension library. See EXTRALIBS below.</source>
          <target state="translated">当perl二进制文件与扩展库链接时,由ld命令执行。参见下面的EXTRALIBS。</target>
        </trans-unit>
        <trans-unit id="b5f079545f5d4621415bdb75f7dcd595e58fae02" translate="yes" xml:space="preserve">
          <source>by the ld command when the shared object is built/linked. See LDLOADLIBS below.</source>
          <target state="translated">当共享对象被构建/链接时,由ld命令执行。参见下面的LDLOADLIBS。</target>
        </trans-unit>
        <trans-unit id="fb53580843b764dd08d059a4ffde7b32707736ab" translate="yes" xml:space="preserve">
          <source>by the main thread (thread ID = 0) of a script. Therefore, setting up signal handlers in threads for purposes other than &lt;a href=&quot;#THREAD-SIGNALLING&quot;&gt;THREAD SIGNALLING&lt;/a&gt; as documented above will not accomplish what is intended.</source>
          <target state="translated">通过脚本的主线程（线程ID = 0）。因此，在线程中设置信号处理程序以实现除上面所述的&lt;a href=&quot;#THREAD-SIGNALLING&quot;&gt;THREAD SIGNALING&lt;/a&gt;之外的其他目的将无法实现预期的目的。</target>
        </trans-unit>
        <trans-unit id="08b3b402ddb7fb46a261bf00b77d547af5513e6c" translate="yes" xml:space="preserve">
          <source>by their very definition. It is of course possible to write a nearly instantaneous program, but it's not going to do very much, here's a very efficient one:</source>
          <target state="translated">从他们的定义来看。当然也可以写一个近乎瞬时的程序,但不会有太大的作用,这里有一个非常高效的程序。</target>
        </trans-unit>
        <trans-unit id="cd5f3427a5b91cc9194daa4a03c9e849e100f09d" translate="yes" xml:space="preserve">
          <source>by this:</source>
          <target state="translated">由这个。</target>
        </trans-unit>
        <trans-unit id="90078d2f7170e62d296450a6cf5226698468ce9b" translate="yes" xml:space="preserve">
          <source>by using calls like this one;</source>
          <target state="translated">通过使用像这样的调用。</target>
        </trans-unit>
        <trans-unit id="cda65ed6f996204ff01e4d76e80bf0eb135783c9" translate="yes" xml:space="preserve">
          <source>by-category</source>
          <target state="translated">by-category</target>
        </trans-unit>
        <trans-unit id="52d31c8a6d5578bdb0ba6c7bacaa72d3064e7f98" translate="yes" xml:space="preserve">
          <source>by-module</source>
          <target state="translated">by-module</target>
        </trans-unit>
        <trans-unit id="8cf1783fa99f62ca581f6fe8f3cd66b0f9ab9fc3" translate="yes" xml:space="preserve">
          <source>byte</source>
          <target state="translated">byte</target>
        </trans-unit>
        <trans-unit id="721b9babe5628970cc09024b3a1a9b932d9e0924" translate="yes" xml:space="preserve">
          <source>byte order marks</source>
          <target state="translated">字节号</target>
        </trans-unit>
        <trans-unit id="beb025390e6b44933a6bf16e1bc9c499925f957e" translate="yes" xml:space="preserve">
          <source>byteorder.U</source>
          <target state="translated">byteorder.U</target>
        </trans-unit>
        <trans-unit id="daf529a73101c2be626b99fc6938163e7a27620b" translate="yes" xml:space="preserve">
          <source>bytes</source>
          <target state="translated">bytes</target>
        </trans-unit>
        <trans-unit id="305428c11e612a57e6dca43980d6a15186d3eedd" translate="yes" xml:space="preserve">
          <source>bytes - Perl pragma to force byte semantics rather than character semantics</source>
          <target state="translated">字节-Perl中强制使用字节语义而非字符语义的pragma。</target>
        </trans-unit>
        <trans-unit id="74e04eb86371917242f5f42e7825ff63f37fa8b7" translate="yes" xml:space="preserve">
          <source>bytes of data from</source>
          <target state="translated">字节的数据,从</target>
        </trans-unit>
        <trans-unit id="a6a3035438f8082d9bbe01b48538b14cd1cebf95" translate="yes" xml:space="preserve">
          <source>bytes of data into</source>
          <target state="translated">字节的数据到</target>
        </trans-unit>
        <trans-unit id="d285f82774e0d86e76e8e37aedf166837530e229" translate="yes" xml:space="preserve">
          <source>bytes of the character. The UTF8 flag is turned off. Returns nothing.</source>
          <target state="translated">字符的字节。UTF8标志被关闭。不返回任何内容。</target>
        </trans-unit>
        <trans-unit id="a8d7a1f72563dfcee3b9751f0008a7ef3b69a283" translate="yes" xml:space="preserve">
          <source>bytes::substr() does not work as an lvalue().</source>
          <target state="translated">bytes::substr()不能作为lvalue()工作。</target>
        </trans-unit>
        <trans-unit id="18966dcea477ed087e87037c4255cd180be7d19e" translate="yes" xml:space="preserve">
          <source>bzip2</source>
          <target state="translated">bzip2</target>
        </trans-unit>
        <trans-unit id="8dddd252e4acf3054b159272da897404d0ef9a10" translate="yes" xml:space="preserve">
          <source>bzip2 $input_filename_or_reference =&amp;gt; $output_filename_or_reference [, OPTS]</source>
          <target state="translated">bzip2 $ input_filename_or_reference =&amp;gt; $ output_filename_or_reference [，OPTS]</target>
        </trans-unit>
        <trans-unit id="84a516841ba77a5b4648de2cd0dfcb30ea46dbb4" translate="yes" xml:space="preserve">
          <source>c</source>
          <target state="translated">c</target>
        </trans-unit>
        <trans-unit id="9bf518bb1d83f8f8b94f6a75e535c0324b999e9e" translate="yes" xml:space="preserve">
          <source>c2ph</source>
          <target state="translated">c2ph</target>
        </trans-unit>
        <trans-unit id="aab64cc4582b2a7ac50ea4d29f8baf504eb3ffd7" translate="yes" xml:space="preserve">
          <source>c2ph, pstruct - Dump C structures as generated from &lt;code&gt;cc -g -S&lt;/code&gt; stabs</source>
          <target state="translated">c2ph，pstruct-转储从 &lt;code&gt;cc -g -S&lt;/code&gt; 刺生成的C结构</target>
        </trans-unit>
        <trans-unit id="ecce20b9ec4855087467bfaecc68195be1813592" translate="yes" xml:space="preserve">
          <source>caches, one for scalar values and one for list values. When your function is called in scalar context, its return value is cached in one hash, and when your function is called in list context, its value is cached in the other hash. You can control the caching behavior of both contexts independently with these options.</source>
          <target state="translated">缓存,一个用于标量值,一个用于列表值。当你的函数在标量上下文中被调用时,它的返回值被缓存在一个哈希中,而当你的函数在列表上下文中被调用时,它的值被缓存在另一个哈希中。您可以通过这些选项独立地控制两个上下文的缓存行为。</target>
        </trans-unit>
        <trans-unit id="0d68cbf5b8fc5792e2b012765c8d99152d921657" translate="yes" xml:space="preserve">
          <source>calculator indeed.</source>
          <target state="translated">计算器确实。</target>
        </trans-unit>
        <trans-unit id="bc8d8647b02deea0ab3e715c220d041ee78cc19d" translate="yes" xml:space="preserve">
          <source>call</source>
          <target state="translated">call</target>
        </trans-unit>
        <trans-unit id="d26793c374d42f2321b52b9ab8c04fd33c02f47c" translate="yes" xml:space="preserve">
          <source>call &lt;code&gt;iota&lt;/code&gt; in scalar context and cache the result, but the &lt;code&gt;SCALAR_CACHE =&amp;gt; 'MERGE'&lt;/code&gt; option says not to do that, but to use the cache list-context value instead. But it cannot return a list of seven elements in a scalar context. In this case &lt;code&gt;$i7&lt;/code&gt; will receive the &lt;b&gt;first element&lt;/b&gt; of the cached list value, namely 7.</source>
          <target state="translated">在标量上下文中调用 &lt;code&gt;iota&lt;/code&gt; 并缓存结果，但是 &lt;code&gt;SCALAR_CACHE =&amp;gt; 'MERGE'&lt;/code&gt; 选项说不这样做，而是使用缓存list-context值。但是它不能在标量上下文中返回七个元素的列表。在这种情况下， &lt;code&gt;$i7&lt;/code&gt; 将接收缓存列表值的&lt;b&gt;第一个元素&lt;/b&gt;，即7。</target>
        </trans-unit>
        <trans-unit id="aea66ab9134e8035b60e502b44c9255902019bb8" translate="yes" xml:space="preserve">
          <source>call a method without void context. Use &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; instead if you need to be able to disable autodying/Fatal behaviour for a small block of code.</source>
          <target state="translated">调用没有无效上下文的方法。使用&lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt;，而是如果你需要能够禁用autodying /致命行为的代码的一小块。</target>
        </trans-unit>
        <trans-unit id="07ee532dfc7a5c9512fdcf2b4ab1a03d4a1d1bd8" translate="yes" xml:space="preserve">
          <source>call an overridden &lt;code&gt;isa&lt;/code&gt; method in any class. Instead, use &lt;code&gt;reftype&lt;/code&gt; from &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; for the first case:</source>
          <target state="translated">在任何类中调用覆盖的 &lt;code&gt;isa&lt;/code&gt; 方法。相反，使用 &lt;code&gt;reftype&lt;/code&gt; 从&lt;a href=&quot;scalar/util&quot;&gt;标量::的Util&lt;/a&gt;对于第一种情况：</target>
        </trans-unit>
        <trans-unit id="0a301a28fa31b59f5762db2f0e4dae07ecf49b7f" translate="yes" xml:space="preserve">
          <source>call in call_Subtract reads:</source>
          <target state="translated">call_Subtract中的调用改为。</target>
        </trans-unit>
        <trans-unit id="09af65b77373b270115d65e0cc4152963620d518" translate="yes" xml:space="preserve">
          <source>call them indirectly:</source>
          <target state="translated">间接叫他们。</target>
        </trans-unit>
        <trans-unit id="bea45b65dbd679ba81c088f23290abf3a9afb91e" translate="yes" xml:space="preserve">
          <source>call to &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; .</source>
          <target state="translated">调用 &lt;code&gt;filter_read&lt;/code&gt; 或 &lt;code&gt;filter_read_exact&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c949d2de33459ca2d9973d9bf5448c9e6bdb1f6" translate="yes" xml:space="preserve">
          <source>call-back unit so that long doubles can be formatted without loss of precision.</source>
          <target state="translated">回调单元,这样就可以在不损失精度的情况下对长双数进行格式化。</target>
        </trans-unit>
        <trans-unit id="01eeb3a3ce36a45d2ed8b640d6a38cc855a0aea9" translate="yes" xml:space="preserve">
          <source>call.</source>
          <target state="translated">call.</target>
        </trans-unit>
        <trans-unit id="a0a7cf13bc05b8452a04f1e2d381330099f264f0" translate="yes" xml:space="preserve">
          <source>call. For example:</source>
          <target state="translated">呼叫。例如:</target>
        </trans-unit>
        <trans-unit id="fa4e53e51ebd0d0df17edd40ee676dc6179cfe87" translate="yes" xml:space="preserve">
          <source>call_*</source>
          <target state="translated">call_*</target>
        </trans-unit>
        <trans-unit id="5558c19f08af12e8462cd902d73078dd2305080f" translate="yes" xml:space="preserve">
          <source>call_AddSubScalar</source>
          <target state="translated">call_AddSubScalar</target>
        </trans-unit>
        <trans-unit id="90ff1a8ade713598c1646d49e8bd8e0ab53cf48c" translate="yes" xml:space="preserve">
          <source>call_AddSubtract</source>
          <target state="translated">call_AddSubtract</target>
        </trans-unit>
        <trans-unit id="2854630a13713d11a8b6885e7f79056447c62688" translate="yes" xml:space="preserve">
          <source>call_LeftString</source>
          <target state="translated">call_LeftString</target>
        </trans-unit>
        <trans-unit id="18631234b2a7bd26d823fa54e3df7188c8e989c8" translate="yes" xml:space="preserve">
          <source>call_Subtract</source>
          <target state="translated">call_Subtract</target>
        </trans-unit>
        <trans-unit id="d4a0b92fad95fc628341a5a87ec98cabb9a02a7d" translate="yes" xml:space="preserve">
          <source>call_argv</source>
          <target state="translated">call_argv</target>
        </trans-unit>
        <trans-unit id="6f635f2379199699013477fde9934d1b25b2ed69" translate="yes" xml:space="preserve">
          <source>call_method</source>
          <target state="translated">call_method</target>
        </trans-unit>
        <trans-unit id="c9b67be4160b43f537f38ed300d8d7d67ad56af8" translate="yes" xml:space="preserve">
          <source>call_pv</source>
          <target state="translated">call_pv</target>
        </trans-unit>
        <trans-unit id="8cecf04d9c1fddec48927de0af20f7d816c7d167" translate="yes" xml:space="preserve">
          <source>call_sv</source>
          <target state="translated">call_sv</target>
        </trans-unit>
        <trans-unit id="b4d5b37bf7a986c138ede89e0806f366b5cb1830" translate="yes" xml:space="preserve">
          <source>callback</source>
          <target state="translated">callback</target>
        </trans-unit>
        <trans-unit id="4e8127df1a4b3dbfb5b327173cfb08b8676ac454" translate="yes" xml:space="preserve">
          <source>callbacks</source>
          <target state="translated">callbacks</target>
        </trans-unit>
        <trans-unit id="5b73d33ca4d0ef4a3df6b67b837e769d4cb0af6e" translate="yes" xml:space="preserve">
          <source>called &lt;code&gt;$some_pack::secret_version&lt;/code&gt; or anything; it's just $secret_version, unqualified and unqualifiable.</source>
          <target state="translated">称为 &lt;code&gt;$some_pack::secret_version&lt;/code&gt; 或其他名称；它只是$ secret_version，不合格且不合格。</target>
        </trans-unit>
        <trans-unit id="1fb8b294c8dd06c5ddbfda59a1996397e5dff5ee" translate="yes" xml:space="preserve">
          <source>called for &lt;code&gt;=pod&lt;/code&gt; paragraphs.</source>
          <target state="translated">要求 &lt;code&gt;=pod&lt;/code&gt; 段落。</target>
        </trans-unit>
        <trans-unit id="4dca004e14e54a193da4bef6ddcce901570f9219" translate="yes" xml:space="preserve">
          <source>called immediately, and if Perl is using the system's &lt;code&gt;stdio&lt;/code&gt; library that library may restart the &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; without returning to Perl to give it a chance to call the %SIG handler. If this happens on your system the solution is to use the &lt;code&gt;:perlio&lt;/code&gt; layer to do IO--at least on those handles that you want to be able to break into with signals. (The &lt;code&gt;:perlio&lt;/code&gt; layer checks the signal flags and calls %SIG handlers before resuming IO operation.)</source>
          <target state="translated">立即调用，并且如果Perl正在使用系统的 &lt;code&gt;stdio&lt;/code&gt; 库，则该库可以重新开始 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 而无需返回Perl，从而使它有机会调用％SIG处理程序。如果在您的系统上发生这种情况，解决方案是使用 &lt;code&gt;:perlio&lt;/code&gt; 层执行IO-至少在您希望能够通过信号插入的那些句柄上。（ &lt;code&gt;:perlio&lt;/code&gt; 层在恢复IO操作之前检查信号标志并调用％SIG处理程序。）</target>
        </trans-unit>
        <trans-unit id="14dc69de2a1e6087529f02b62fd2888c90d741d3" translate="yes" xml:space="preserve">
          <source>caller</source>
          <target state="translated">caller</target>
        </trans-unit>
        <trans-unit id="a5f0d61e9b1c1b14054070cd5efad882cc10c593" translate="yes" xml:space="preserve">
          <source>caller EXPR</source>
          <target state="translated">呼叫者</target>
        </trans-unit>
        <trans-unit id="7aba60747c4150b59b47e08abdd47c33cc7a6995" translate="yes" xml:space="preserve">
          <source>caller's scope</source>
          <target state="translated">呼叫范围</target>
        </trans-unit>
        <trans-unit id="b31614a7ba28b398fab5be5b1f0abace81483c66" translate="yes" xml:space="preserve">
          <source>calling pod2usage, Pod::Usage will fail even on robust platforms. Don't do that. Or use &lt;a href=&quot;../findbin&quot;&gt;FindBin&lt;/a&gt; to locate the script:</source>
          <target state="translated">调用pod2usage，即使在健壮的平台上，Pod :: Usage也会失败。不要那样做 或使用&lt;a href=&quot;../findbin&quot;&gt;FindBin&lt;/a&gt;查找脚本：</target>
        </trans-unit>
        <trans-unit id="51b6cb253fc406fc1b9780eaa1fb645eb82e631d" translate="yes" xml:space="preserve">
          <source>calls</source>
          <target state="translated">calls</target>
        </trans-unit>
        <trans-unit id="4a782bf6f0127a0ab6a9b55b344eb864af06d6d9" translate="yes" xml:space="preserve">
          <source>calls &amp;amp;{&quot;${module}::bootstrap&quot;} to bootstrap the module (actually it uses the function reference returned by dl_install_xsub for speed)</source>
          <target state="translated">调用＆{&amp;ldquo; $ {module} :: bootstrap&amp;rdquo;}来引导模块（实际上，它使用dl_install_xsub返回的函数引用来提高速度）</target>
        </trans-unit>
        <trans-unit id="8068c49fd178ebbbb1181c7892ff798980347f20" translate="yes" xml:space="preserve">
          <source>calls (e.g., using &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; or back-ticks) made from threads use the environment variable settings from the</source>
          <target state="translated">线程进行的调用（例如，使用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 或反引号）使用来自</target>
        </trans-unit>
        <trans-unit id="23927d0aa967922575276101593ab186ac76a894" translate="yes" xml:space="preserve">
          <source>calls dl_find_symbol() for &quot;boot_$module&quot;</source>
          <target state="translated">调用dl_find_symbol()来查找 &quot;boot_$module&quot;。</target>
        </trans-unit>
        <trans-unit id="df5598c9096a42a3629f35c7aa2f39e91fa80505" translate="yes" xml:space="preserve">
          <source>calls dl_install_xsub() to install it as &quot;${module}::bootstrap&quot;</source>
          <target state="translated">调用dl_install_xsub()将其安装为&quot;${module}::bootstrap&quot;</target>
        </trans-unit>
        <trans-unit id="eeddbfb4bab615284264705345a27ee10700ba4b" translate="yes" xml:space="preserve">
          <source>calls dl_load_file() to load the file</source>
          <target state="translated">调用dl_load_file()来加载文件。</target>
        </trans-unit>
        <trans-unit id="60dd082e722533c84eb7e433f3fa4582d921f83b" translate="yes" xml:space="preserve">
          <source>calls dl_load_flags() to determine how to load the file.</source>
          <target state="translated">调用dl_load_flags()来决定如何加载文件。</target>
        </trans-unit>
        <trans-unit id="c1e90b552179a525781d61e90b26ebd803e604f3" translate="yes" xml:space="preserve">
          <source>calls dl_undef_symbols() and warns if any symbols are undefined</source>
          <target state="translated">调用dl_undef_symbols(),如果有未定义的符号,则发出警告。</target>
        </trans-unit>
        <trans-unit id="03b5ee56e23671d3878c7bc1765e42ba79aa3e0b" translate="yes" xml:space="preserve">
          <source>calls like the following</source>
          <target state="translated">像下面这样的调用</target>
        </trans-unit>
        <trans-unit id="f02e2d24dc9d64bcb7041c2fc782098c29ed69dd" translate="yes" xml:space="preserve">
          <source>calls made by that thread.</source>
          <target state="translated">该线程所做的调用。</target>
        </trans-unit>
        <trans-unit id="2dcbf5bd7246d954454bd3f3804dead54471c5e2" translate="yes" xml:space="preserve">
          <source>calls the Perl subroutine specified by the C string stored in the &lt;code&gt;subname&lt;/code&gt; parameter. It also takes the usual &lt;code&gt;flags&lt;/code&gt; parameter. The final parameter, &lt;code&gt;argv&lt;/code&gt; , consists of a NULL-terminated list of C strings to be passed as parameters to the Perl subroutine. See</source>
          <target state="translated">调用由存储在 &lt;code&gt;subname&lt;/code&gt; 参数中的C字符串指定的Perl子例程。它还采用通常的 &lt;code&gt;flags&lt;/code&gt; 参数。最终参数 &lt;code&gt;argv&lt;/code&gt; 包含一个以NULL结尾的C字符串列表，这些字符串将作为参数传递给Perl子例程。看到</target>
        </trans-unit>
        <trans-unit id="df5b12037f7721d936298a1dbbb871e6381c2da1" translate="yes" xml:space="preserve">
          <source>camel_flea</source>
          <target state="translated">camel_flea</target>
        </trans-unit>
        <trans-unit id="7e9219a0599eae1d9601883f894b4fbe60870586" translate="yes" xml:space="preserve">
          <source>can</source>
          <target state="translated">can</target>
        </trans-unit>
        <trans-unit id="699d91f476fc57b066fa45249291eed227b9fc79" translate="yes" xml:space="preserve">
          <source>can also be &lt;code&gt;I&lt;/code&gt; which is the same as &lt;code&gt;C&lt;/code&gt; but is a special case for dotted uppercase I and dotless lowercase i:</source>
          <target state="translated">也可以是与 &lt;code&gt;C&lt;/code&gt; 相同的 &lt;code&gt;I&lt;/code&gt; ，但对于点大写字母I和无点小写字母i是特殊情况：</target>
        </trans-unit>
        <trans-unit id="e4fb56cea3d4b5b887c8b15f28fd462013d373d9" translate="yes" xml:space="preserve">
          <source>can be &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; to specify that the option is list or a hash valued. This is only needed when the destination for the option value is not otherwise specified. It should be omitted when not needed.</source>
          <target state="translated">可以为 &lt;code&gt;@&lt;/code&gt; 或 &lt;code&gt;%&lt;/code&gt; ,以指定该选项为列表或值的哈希值。仅当未另外指定选项值的目的地时才需要这样做。不需要时应将其省略。</target>
        </trans-unit>
        <trans-unit id="24b476e0c0907463a17bc1306e027e47233cc399" translate="yes" xml:space="preserve">
          <source>can be any expression that evaluates to a name accepted by &lt;code&gt;\N{...}&lt;/code&gt; under the &lt;a href=&quot;#DESCRIPTION&quot;&gt;:full option&lt;/a&gt; to &lt;code&gt;charnames&lt;/code&gt; . In addition, any other options for the controlling &lt;code&gt;&quot;use charnames&quot;&lt;/code&gt; in the same scope apply, like &lt;code&gt;:loose&lt;/code&gt; or any &lt;a href=&quot;#DESCRIPTION&quot;&gt;script list, :short option&lt;/a&gt;, or &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;custom aliases&lt;/a&gt; you may have defined.</source>
          <target state="translated">可以是任何运算 &lt;code&gt;charnames&lt;/code&gt; ，其运算结果是charnames的&lt;a href=&quot;#DESCRIPTION&quot;&gt;：full选项&lt;/a&gt;下 &lt;code&gt;\N{...}&lt;/code&gt; 接受的名称。另外，在同一作用域中用于控制 &lt;code&gt;&quot;use charnames&quot;&lt;/code&gt; 任何其他选项都适用，例如 &lt;code&gt;:loose&lt;/code&gt; 或任何&lt;a href=&quot;#DESCRIPTION&quot;&gt;脚本列表，：short选项&lt;/a&gt;或您可能已定义的&lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;自定义别名&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8b34e29f857c70f78af80d100b29730e6cdc1149" translate="yes" xml:space="preserve">
          <source>can be any value which is valid as an assignment to an element of &lt;code&gt;%SIG&lt;/code&gt; . See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for examples of handler functions.</source>
          <target state="translated">可以是任何有效作为 &lt;code&gt;%SIG&lt;/code&gt; 元素分配的值。有关处理程序函数的示例，请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="461c0b19fe19c96b45408c038271b2fb35f66553" translate="yes" xml:space="preserve">
          <source>can be compressed with &lt;code&gt;/c:max&lt;/code&gt; (the bug only appears when there is a fixup in the last 6 bytes of a page (?); since the tiny executables are much smaller than a page, the bug will not hit). Do not compress &lt;code&gt;perl_.exe&lt;/code&gt; - it would not work under DOS.</source>
          <target state="translated">可以用 &lt;code&gt;/c:max&lt;/code&gt; 压缩（该错误仅在页面的最后6个字节中有修复程序（？）时才会出现；由于微小的可执行文件比页面小得多，因此不会击中该错误）。不要压缩 &lt;code&gt;perl_.exe&lt;/code&gt; -它在DOS下不起作用。</target>
        </trans-unit>
        <trans-unit id="446662c59650e49f63dcfb6d7d27d374899b2abe" translate="yes" xml:space="preserve">
          <source>can be constructed using &lt;code&gt;pod2latex&lt;/code&gt; .</source>
          <target state="translated">可以使用 &lt;code&gt;pod2latex&lt;/code&gt; 构造。</target>
        </trans-unit>
        <trans-unit id="794d8b0a9b686ba34ee696408ef6df66c3a413de" translate="yes" xml:space="preserve">
          <source>can be either a canonical name or an alias. For encoding names and aliases, see &lt;a href=&quot;#Defining-Aliases&quot;&gt;Defining Aliases&lt;/a&gt;. For CHECK, see &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;Handling Malformed Data&lt;/a&gt;.</source>
          <target state="translated">可以是规范名称也可以是别名。有关编码名称和别名的信息，请参见&lt;a href=&quot;#Defining-Aliases&quot;&gt;定义别名&lt;/a&gt;。有关检查，请参阅&lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;处理格式错误的数据&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8fd5395b7f9e578475974e9b86e078fb0ec61ac4" translate="yes" xml:space="preserve">
          <source>can be either a canonical name or an alias. For encoding names and aliases, see &lt;a href=&quot;#Defining-Aliases&quot;&gt;Defining Aliases&lt;/a&gt;; for</source>
          <target state="translated">可以是规范名称也可以是别名。有关编码名称和别名的信息，请参见&lt;a href=&quot;#Defining-Aliases&quot;&gt;定义别名&lt;/a&gt; ; 对于</target>
        </trans-unit>
        <trans-unit id="e77ae9195619436cf623136bc0de83a787a047da" translate="yes" xml:space="preserve">
          <source>can be misparsed by pre-5.10.0 Perls as a non-terminated search pattern.</source>
          <target state="translated">可以被5.10.0之前的Perls误解为非终结的搜索模式。</target>
        </trans-unit>
        <trans-unit id="102e5cd9960ccd33f4c8886eae28cc9c5d186cd5" translate="yes" xml:space="preserve">
          <source>can be represented by any of the strings &quot;Y&quot;, &quot;Yes&quot;, &quot;T&quot;, or &quot;True&quot;; and the General Category &quot;Punctuation&quot; by that string, or &quot;Punct&quot;, or simply &quot;P&quot;.</source>
          <target state="translated">可以用 &quot;Y&quot;、&quot;Yes&quot;、&quot;T &quot;或 &quot;True &quot;中的任何一个字符串表示;用该字符串表示一般类别 &quot;标点&quot;,或 &quot;Punct&quot;,或简称为 &quot;P&quot;。</target>
        </trans-unit>
        <trans-unit id="ab1e1922e94c24432c2394888ae6becca02bff46" translate="yes" xml:space="preserve">
          <source>can be rewritten as the much more efficient</source>
          <target state="translated">可以改写成更有效的</target>
        </trans-unit>
        <trans-unit id="6980df54f269ebb5f12cf9f66876a22b962b6463" translate="yes" xml:space="preserve">
          <source>can be specified as either a POSIX termios/SYSV termio speeds (where 9600 equals 9600) or an old DSD-style speed ( where 13 equals 9600).</source>
          <target state="translated">可以指定为POSIX termios/SYSV termio速度(其中9600等于9600)或旧的DSD风格速度(其中13等于9600)。</target>
        </trans-unit>
        <trans-unit id="2a0b30925918e47087c2c3fd8ec3511807439d9a" translate="yes" xml:space="preserve">
          <source>can be supplied as true to force the loop body to be enclosed in its own scope.</source>
          <target state="translated">可以提供true,以强制循环体被包围在自己的范围内。</target>
        </trans-unit>
        <trans-unit id="2ec6c241c08eaa0e7cd65d17fc2d47fc2d922f6d" translate="yes" xml:space="preserve">
          <source>can be used any place a string (char *) is required:</source>
          <target state="translated">可以在任何需要使用字符串(char *)的地方使用。</target>
        </trans-unit>
        <trans-unit id="d8acc4b4615821e09fe517afa1e537f21aba062d" translate="yes" xml:space="preserve">
          <source>can be used as an alias for</source>
          <target state="translated">的别称,可以作为</target>
        </trans-unit>
        <trans-unit id="c83ef2aed21667cc47266aebbf22a19737c73278" translate="yes" xml:space="preserve">
          <source>can be used to initialize a new $x with the value of the old $x, and the expression</source>
          <target state="translated">可以用旧的$x的值初始化一个新的$x,表达式为</target>
        </trans-unit>
        <trans-unit id="32fde68489fc1913d62a482e299a8d35e0bda2c3" translate="yes" xml:space="preserve">
          <source>can be used to pass parameters to the methods which implement that part of the Makefile. Parameters are specified as a hash ref but are passed to the method as a hash.</source>
          <target state="translated">可以用来将参数传递给实现Makefile那部分的方法。参数被指定为哈希 ref,但会以哈希形式传递给方法。</target>
        </trans-unit>
        <trans-unit id="e020f4df52e0881b17e0bbdbefc5b62b50ac0eaa" translate="yes" xml:space="preserve">
          <source>can be used to test the locales on your system. Setting the environment variable &lt;code&gt;PERL_DEBUG_FULL_TEST&lt;/code&gt; to 1 will cause it to output detailed results. For example, on Linux, you could say</source>
          <target state="translated">可用于测试系统上的语言环境。将环境变量 &lt;code&gt;PERL_DEBUG_FULL_TEST&lt;/code&gt; 设置为1将导致其输出详细结果。例如，在Linux上，您可以说</target>
        </trans-unit>
        <trans-unit id="ec38106a7a2c4aeab519526f1fc64d639439ebe7" translate="yes" xml:space="preserve">
          <source>can now be called via the</source>
          <target state="translated">现在可以通过</target>
        </trans-unit>
        <trans-unit id="073fc766b5f28ba9a5e826b65821aea6ad51da11" translate="yes" xml:space="preserve">
          <source>can refer either to a &quot;=head</source>
          <target state="translated">可以是指&quot;=头</target>
        </trans-unit>
        <trans-unit id="f3e4c81c1862fa7e83f6209d035bc6b6a4c37811" translate="yes" xml:space="preserve">
          <source>can tell if it has been sourced already.</source>
          <target state="translated">可以知道是否已经被采购了。</target>
        </trans-unit>
        <trans-unit id="5bac399344eb2e104a9bc2cee9e2a722464b5047" translate="yes" xml:space="preserve">
          <source>can't</source>
          <target state="translated">can't</target>
        </trans-unit>
        <trans-unit id="98058934126afcffdf3e1dca698b1e5933052270" translate="yes" xml:space="preserve">
          <source>can_dep_space</source>
          <target state="translated">can_dep_space</target>
        </trans-unit>
        <trans-unit id="f1d8c600ccae6e37aa7bd1365c835614b2fdb93f" translate="yes" xml:space="preserve">
          <source>can_load_xs</source>
          <target state="translated">can_load_xs</target>
        </trans-unit>
        <trans-unit id="9b48ac28ef2fa55ed9118eab541eb96b568c95c9" translate="yes" xml:space="preserve">
          <source>can_redirect_error</source>
          <target state="translated">can_redirect_error</target>
        </trans-unit>
        <trans-unit id="60f8214968771a1ddbf7e4ae68c3192535834642" translate="yes" xml:space="preserve">
          <source>can_run</source>
          <target state="translated">can_run</target>
        </trans-unit>
        <trans-unit id="0ec09fd5087f20f8f1487c0620fa4aae9bf6bd67" translate="yes" xml:space="preserve">
          <source>cancelling</source>
          <target state="translated">cancelling</target>
        </trans-unit>
        <trans-unit id="6ef80072f39071d4118a6e7890e209d4dd07e504" translate="yes" xml:space="preserve">
          <source>cannot</source>
          <target state="translated">cannot</target>
        </trans-unit>
        <trans-unit id="04f7fc0aca9ad2b7aa0a289811be4f44339c3fa2" translate="yes" xml:space="preserve">
          <source>cannot be computed for all arguments because that would mean dividing by zero or taking logarithm of zero. These situations cause fatal runtime errors looking like this</source>
          <target state="translated">不能对所有参数进行计算,因为这意味着除以零或取零的对数。这些情况会导致致命的运行时错误,如下所示</target>
        </trans-unit>
        <trans-unit id="07567c7d826aa63adc1a5eeccb8e1d221eb1a7bd" translate="yes" xml:space="preserve">
          <source>cannot be included, use</source>
          <target state="translated">不能包含,请用</target>
        </trans-unit>
        <trans-unit id="8204e50dcc76473893509dee81c209dd37748814" translate="yes" xml:space="preserve">
          <source>cannot be started directly using the above API. One needs a way to surround the doublequotes in some other quoting construction, necessarily having an extra non-Unixish shell in between.</source>
          <target state="translated">不能直接使用上述API启动。我们需要用其他的引号结构来包围双引号,必然要在双引号之间有一个额外的非Unixish shell。</target>
        </trans-unit>
        <trans-unit id="d6baf2d107957d5d2e553bf06c6534a12bcb1fc9" translate="yes" xml:space="preserve">
          <source>cannot find the needed</source>
          <target state="translated">找不到</target>
        </trans-unit>
        <trans-unit id="433ee83dd6e407f89126bb331d94555ce0d19f8b" translate="yes" xml:space="preserve">
          <source>cannot lead to &lt;code&gt;$b&lt;/code&gt; 's implementation of &lt;code&gt;*=&lt;/code&gt; being called, even if &lt;code&gt;$a&lt;/code&gt; is a scalar. (It can, however, generate a call to &lt;code&gt;$b&lt;/code&gt; 's method for &lt;code&gt;*&lt;/code&gt; ).</source>
          <target state="translated">即使 &lt;code&gt;$a&lt;/code&gt; 是标量，也无法导致 &lt;code&gt;$b&lt;/code&gt; 的 &lt;code&gt;*=&lt;/code&gt; 实现被调用。（但是，它可以为 &lt;code&gt;*&lt;/code&gt; 生成对 &lt;code&gt;$b&lt;/code&gt; 的方法的调用）。</target>
        </trans-unit>
        <trans-unit id="865f1ff7a475134380e8c1ade9c9257a3b2d3d4b" translate="yes" xml:space="preserve">
          <source>capabilities, such as the less program on Unix.</source>
          <target state="translated">能力,如Unix上的少程序。</target>
        </trans-unit>
        <trans-unit id="24d36117a06589995877d65c61dd6ec645ccc49e" translate="yes" xml:space="preserve">
          <source>capabilities:</source>
          <target state="translated">capabilities:</target>
        </trans-unit>
        <trans-unit id="cf3298ba24c6c4e554b7f8b9a3569ba924ef42f8" translate="yes" xml:space="preserve">
          <source>capturing groups, or else</source>
          <target state="translated">捕获组,否则</target>
        </trans-unit>
        <trans-unit id="27da055de62be5ea00a18b05686dc722ef504503" translate="yes" xml:space="preserve">
          <source>capturing parentheses will not be penalized. So avoid &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; , and &lt;code&gt;$`&lt;/code&gt; if you can, but if you can't (and some algorithms really appreciate them), once you've used them once, use them at will, because you've already paid the price.</source>
          <target state="translated">捕获括号不会受到惩罚。因此，如果可以的话，请避免使用 &lt;code&gt;$&amp;amp;&lt;/code&gt; ， &lt;code&gt;$'&lt;/code&gt; 和 &lt;code&gt;$`&lt;/code&gt; ，但是，如果不能（并且某些算法真的很欣赏它们），则一旦使用它们，就可以随意使用它们，因为您已经支付了价钱。</target>
        </trans-unit>
        <trans-unit id="4fecdfe9582b11c15b0bff91598fe22c64541102" translate="yes" xml:space="preserve">
          <source>careful with this routine, as it short-circuits some of Perl's fundamental security features. XS module authors should not use this function unless they fully understand all the implications of unconditionally untainting the value. Untainting should be done in the standard perl fashion, via a carefully crafted regexp, rather than directly untainting variables.</source>
          <target state="translated">小心使用这个例程,因为它使Perl的一些基本安全特性短路。XS 模块的作者不应该使用这个函数,除非他们完全理解无条件解除着色值的所有含义。解污应该用标准的perl方式,通过精心设计的regexp来完成,而不是直接解污变量。</target>
        </trans-unit>
        <trans-unit id="acfdc4b2f9d00e51d0b86829e77cfae27b4f24d2" translate="yes" xml:space="preserve">
          <source>case 2:</source>
          <target state="translated">案例2:</target>
        </trans-unit>
        <trans-unit id="16c71304ae30f71d8ffe8067ff4329c77039c916" translate="yes" xml:space="preserve">
          <source>casey@geeknest.com</source>
          <target state="translated">casey@geeknest.com</target>
        </trans-unit>
        <trans-unit id="9d989e8d27dc9e0ec3389fc855f142c3d40f0c50" translate="yes" xml:space="preserve">
          <source>cat</source>
          <target state="translated">cat</target>
        </trans-unit>
        <trans-unit id="b7a1dd9696988ff944977d50eecb627d1171afd1" translate="yes" xml:space="preserve">
          <source>cat -v</source>
          <target state="translated">貓 -v</target>
        </trans-unit>
        <trans-unit id="b8af4ddb2fd9d33e56485a48ce24f1383577c83a" translate="yes" xml:space="preserve">
          <source>catfile</source>
          <target state="translated">catfile</target>
        </trans-unit>
        <trans-unit id="8b5241c71bbdffecbb391eeb3bd478542f088494" translate="yes" xml:space="preserve">
          <source>caught</source>
          <target state="translated">caught</target>
        </trans-unit>
        <trans-unit id="ce39e901b8f283aefa4925c1fe1b0dac3ebd0891" translate="yes" xml:space="preserve">
          <source>cause the strings &lt;code&gt;'my,ears,are,bleeding'&lt;/code&gt; and &lt;code&gt;'qw/my ears are bleeding'&lt;/code&gt; respectively to be passed as the data argument.</source>
          <target state="translated">导致分别将字符串 &lt;code&gt;'my,ears,are,bleeding'&lt;/code&gt; 和 &lt;code&gt;'qw/my ears are bleeding'&lt;/code&gt; 作为数据参数传递。</target>
        </trans-unit>
        <trans-unit id="d8573205b7f8e0810587a0422f70a6051e6cffc4" translate="yes" xml:space="preserve">
          <source>causes Perl to assume the following loop around your program, which makes it iterate over filename arguments somewhat like</source>
          <target state="translated">导致Perl在你的程序中假设以下循环,这使得它在文件名参数上的迭代有点像</target>
        </trans-unit>
        <trans-unit id="c70f8ca968cc2b84a2d8f9ff723dd921b777eee6" translate="yes" xml:space="preserve">
          <source>causes Perl to check the syntax of the program and then exit without executing it. Actually, it</source>
          <target state="translated">导致Perl检查程序的语法,然后不执行就退出。实际上,它</target>
        </trans-unit>
        <trans-unit id="7b78a06967eb0fcc80e6215114337d9827b4fb2f" translate="yes" xml:space="preserve">
          <source>causes error like this</source>
          <target state="translated">导致这样的错误</target>
        </trans-unit>
        <trans-unit id="088014ee15be0c288a8023edf6654b8083e4a8da" translate="yes" xml:space="preserve">
          <source>causes it to pass &lt;code&gt;[ ['till','ears','are','bleeding'] ]&lt;/code&gt; ; the array reference specified in the data being passed inside the standard array reference indicating successful interpretation.</source>
          <target state="translated">使它通过 &lt;code&gt;[ ['till','ears','are','bleeding'] ]&lt;/code&gt; ；在标准数组引用中传递的数据中指定的数组引用表示成功解释。</target>
        </trans-unit>
        <trans-unit id="b2bf4396d07b4ae05a6896457aa1b58578889201" translate="yes" xml:space="preserve">
          <source>causes it to pass &lt;code&gt;['till','ears','are','bleeding']&lt;/code&gt; as the handler's data argument. While:</source>
          <target state="translated">使它传递 &lt;code&gt;['till','ears','are','bleeding']&lt;/code&gt; 作为处理程序的数据参数。而：</target>
        </trans-unit>
        <trans-unit id="df8cc3e0e2570acf8b47b8189932aad1db4bc131" translate="yes" xml:space="preserve">
          <source>causes the LoudDecl::Loud handler to be invoked (even if OtherClass also defines a handler for &lt;code&gt;:Loud&lt;/code&gt; attributes).</source>
          <target state="translated">导致LoudDecl :: Loud处理程序被调用（即使OtherClass也为 &lt;code&gt;:Loud&lt;/code&gt; 属性定义了一个处理程序）。</target>
        </trans-unit>
        <trans-unit id="fb15d695643b39f8fa43791dc77a2c03e35f00b6" translate="yes" xml:space="preserve">
          <source>causes the above handler to be invoked, and passed:</source>
          <target state="translated">使上述处理程序被调用,并通过。</target>
        </trans-unit>
        <trans-unit id="252e750ff47e4f26ef1004fd4eb884dc2b37ed2e" translate="yes" xml:space="preserve">
          <source>causes variables, subroutines, formats, and file and directory handles accessible via the identifier &lt;code&gt;richard&lt;/code&gt; also to be accessible via the identifier &lt;code&gt;dick&lt;/code&gt; . If you want to alias only a particular variable or subroutine, assign a reference instead:</source>
          <target state="translated">使变量，子例程，格式以及可通过标识符 &lt;code&gt;richard&lt;/code&gt; 访问的文件和目录句柄也可通过标识符 &lt;code&gt;dick&lt;/code&gt; 访问。如果只想为特定变量或子例程加上别名，请分配一个引用：</target>
        </trans-unit>
        <trans-unit id="bdb480de655aa6ec75ca058c849c4faf3c0f75b1" translate="yes" xml:space="preserve">
          <source>cc</source>
          <target state="translated">cc</target>
        </trans-unit>
        <trans-unit id="e12e6002847af51b7fe034f4ae458d7c224ff7eb" translate="yes" xml:space="preserve">
          <source>cc.U</source>
          <target state="translated">cc.U</target>
        </trans-unit>
        <trans-unit id="36c653ca6aa745b9e24d538496bc8b8d0b36922e" translate="yes" xml:space="preserve">
          <source>cc1.exe</source>
          <target state="translated">cc1.exe</target>
        </trans-unit>
        <trans-unit id="6bbfad7f25547b50fdac092afd8fe1321fabc60b" translate="yes" xml:space="preserve">
          <source>ccflags.U</source>
          <target state="translated">ccflags.U</target>
        </trans-unit>
        <trans-unit id="034778198a045c1ed80be271cdd029b76874f6fc" translate="yes" xml:space="preserve">
          <source>cd</source>
          <target state="translated">cd</target>
        </trans-unit>
        <trans-unit id="e992c3182d410b7ac370694b82237ca081ebad2b" translate="yes" xml:space="preserve">
          <source>cd /usr/local/ascii export IO_CONVERSION=NO gunzip &amp;lt; /usr/local/src/perl.tar.gz | pax -r</source>
          <target state="translated">cd / usr / local / ascii export IO_CONVERSION = NO gunzip &amp;lt;/usr/local/src/perl.tar.gz | pax -r</target>
        </trans-unit>
        <trans-unit id="f7c8cd0c2b39e0615a3916ddfa03de4480bedc53" translate="yes" xml:space="preserve">
          <source>cd /usr/local/src IO_CONVERSION=YES cp -r /usr/local/ascii/perl5.005_02 ./</source>
          <target state="translated">cd /usr/local/src IO_CONVERSION=YES cp -r /usr/local/ascii/perl5.005_02 ./。</target>
        </trans-unit>
        <trans-unit id="02cd8467dc324e9631313e2b2d896d1c32006648" translate="yes" xml:space="preserve">
          <source>ce-helpers/wince-reg.bat</source>
          <target state="translated">ce-helpers/wince-reg.bat</target>
        </trans-unit>
        <trans-unit id="f22c7b71da8e7b91af77c1e966a231ef482b7b4a" translate="yes" xml:space="preserve">
          <source>certain operations will 'upgrade' their calculation and thus the result to the class Foo::Bar. Usually this is used in conjunction with Math::BigFloat:</source>
          <target state="translated">某些操作将 &quot;升级 &quot;他们的计算,从而将结果升级为Foo::Bar类。通常这与Math::BigFloat一起使用。</target>
        </trans-unit>
        <trans-unit id="1a1dc14cbfb80ebee3e6fa16d5973ad2a9773a40" translate="yes" xml:space="preserve">
          <source>cf_email.U</source>
          <target state="translated">cf_email.U</target>
        </trans-unit>
        <trans-unit id="0fee8d38867e35f1baff12ad4f0ab653efd982ee" translate="yes" xml:space="preserve">
          <source>cf_who.U</source>
          <target state="translated">cf_who.U</target>
        </trans-unit>
        <trans-unit id="6edb3b90fe76780aadcce3bd9df636f585dcee65" translate="yes" xml:space="preserve">
          <source>change in a future version!</source>
          <target state="translated">将来的版本会有变化</target>
        </trans-unit>
        <trans-unit id="60e81acd41a6237b0da8a4c03b985db0f8ba5dd2" translate="yes" xml:space="preserve">
          <source>change in the future). This means that &lt;code&gt;_initialize&lt;/code&gt; is never called.</source>
          <target state="translated">改变）。这意味着永远不会调用 &lt;code&gt;_initialize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a993877e0d1e29860d977864aaa31d83906a360e" translate="yes" xml:space="preserve">
          <source>change their distributions, leaving out some parts or including extras. See also &lt;b&gt;dual-lived&lt;/b&gt;.</source>
          <target state="translated">更改他们的分布，忽略某些部分或包括其他内容。另请参阅&lt;b&gt;double-lived&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="57fc90a063f2394662c7d3418550884894dcf3e0" translate="yes" xml:space="preserve">
          <source>change their meanings.)</source>
          <target state="translated">改变其含义)。)</target>
        </trans-unit>
        <trans-unit id="dfa53d2feb524c8b13e38235b2d708f0b72872be" translate="yes" xml:space="preserve">
          <source>changes the &quot;current&quot; drive.</source>
          <target state="translated">改变 &quot;当前 &quot;驱动器。</target>
        </trans-unit>
        <trans-unit id="4484402f1113ed9203c51ce588e25edfdd93e538" translate="yes" xml:space="preserve">
          <source>changing to the extension directory, so it will find your header files OK.</source>
          <target state="translated">改为扩展目录,这样它就能找到你的头文件了。</target>
        </trans-unit>
        <trans-unit id="f0db3fa401aea04b711d6f1f3630552eaaee8e59" translate="yes" xml:space="preserve">
          <source>character</source>
          <target state="translated">character</target>
        </trans-unit>
        <trans-unit id="1ded623062251337ec9783b4d26ea9bea9b5a46d" translate="yes" xml:space="preserve">
          <source>character (letters, digits, Unicode marks, and connector punctuation (like the underscore)). &lt;code&gt;\d&lt;/code&gt; is a character class that matches any decimal digit, while the character class &lt;code&gt;\s&lt;/code&gt; matches any whitespace character. New in perl 5.10.0 are the classes &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; which match horizontal and vertical whitespace characters.</source>
          <target state="translated">字符（字母，数字，Unicode标记和连接器标点（如下划线））。 &lt;code&gt;\d&lt;/code&gt; 是与任何十进制数字匹配的字符类，而 &lt;code&gt;\s&lt;/code&gt; 与任何空白字符匹配。Perl 5.10.0中的新功能是 &lt;code&gt;\h&lt;/code&gt; 和 &lt;code&gt;\v&lt;/code&gt; ，它们匹配水平和垂直空白字符。</target>
        </trans-unit>
        <trans-unit id="23bb22d8aab24aba9b2f28895b2b23e2a939a85f" translate="yes" xml:space="preserve">
          <source>character class</source>
          <target state="translated">字级</target>
        </trans-unit>
        <trans-unit id="0e683117d4a032b7836c0342b63f9dfadb190b53" translate="yes" xml:space="preserve">
          <source>character classes, the [] are part of the construct, for example: /[012[:alpha:]345]/. Note that [= =] and [. .] are not currently implemented; they are simply placeholders for future extensions and will cause fatal errors. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">字符类，[]是构造的一部分，例如：/ [012 [：alpha：] 345] /。请注意[= =]和[。。]当前未实现；它们只是未来扩展的占位符，将导致致命错误。&amp;lt;-HERE在正则表达式中显示发现问题的行踪。参见&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="87099f64417cf7aa38848c69f3d9125914ae7859" translate="yes" xml:space="preserve">
          <source>character encoding forms</source>
          <target state="translated">字符编码形式</target>
        </trans-unit>
        <trans-unit id="184c6f197cfb875777fc5d4fa52ebd2117645d1c" translate="yes" xml:space="preserve">
          <source>character escape</source>
          <target state="translated">逃字</target>
        </trans-unit>
        <trans-unit id="1c475cf1886a99e2cccc41c622e3b56b84fd507c" translate="yes" xml:space="preserve">
          <source>character of &lt;code&gt;s1&lt;/code&gt; beyond what was matched. Correspondingly for &lt;code&gt;pe2&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;s1&lt;/code&gt; 的字符超出了匹配范围。对应于 &lt;code&gt;pe2&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c135ee977d5bdc1daf24b793a26aa0b0337de240" translate="yes" xml:space="preserve">
          <source>character set is complemented. If the &lt;code&gt;/d&lt;/code&gt; modifier is specified, any characters specified by</source>
          <target state="translated">字符集是补充。如果指定了 &lt;code&gt;/d&lt;/code&gt; 修饰符，则由</target>
        </trans-unit>
        <trans-unit id="aa908a40ba515918f9d5edbdcad8ebc1fe5c2b42" translate="yes" xml:space="preserve">
          <source>characters</source>
          <target state="translated">characters</target>
        </trans-unit>
        <trans-unit id="beb063d20fe6a9f7acbd87ce84e35c7e78f47b70" translate="yes" xml:space="preserve">
          <source>characters &lt;code&gt;a&lt;/code&gt; at the beginning of string, leaving no &lt;code&gt;a&lt;/code&gt; for &lt;code&gt;ab&lt;/code&gt; to match. In contrast, &lt;code&gt;a*ab&lt;/code&gt; will match the same as &lt;code&gt;a+b&lt;/code&gt; , since the match of the subgroup &lt;code&gt;a*&lt;/code&gt; is influenced by the following group &lt;code&gt;ab&lt;/code&gt; (see &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;). In particular, &lt;code&gt;a*&lt;/code&gt; inside &lt;code&gt;a*ab&lt;/code&gt; will match fewer characters than a standalone &lt;code&gt;a*&lt;/code&gt; , since this makes the tail match.</source>
          <target state="translated">字符 &lt;code&gt;a&lt;/code&gt; 在字符串的开头，不留下任何 &lt;code&gt;a&lt;/code&gt; 为 &lt;code&gt;ab&lt;/code&gt; 相匹配。相反， &lt;code&gt;a*ab&lt;/code&gt; 将与 &lt;code&gt;a+b&lt;/code&gt; 匹配，因为子组 &lt;code&gt;a*&lt;/code&gt; 的匹配受以下组 &lt;code&gt;ab&lt;/code&gt; 的影响（请参见&lt;a href=&quot;#Backtracking&quot;&gt;回溯&lt;/a&gt;）。特别是， &lt;code&gt;a*&lt;/code&gt; &lt;code&gt;a*ab&lt;/code&gt; 内的a *比单独的 &lt;code&gt;a*&lt;/code&gt; 匹配更少的字符，因为这会使尾部匹配。</target>
        </trans-unit>
        <trans-unit id="51acb16f7fd5365de7328594e8affafe9d165ec2" translate="yes" xml:space="preserve">
          <source>characters. If</source>
          <target state="translated">角色。如果</target>
        </trans-unit>
        <trans-unit id="28f2a64f07df612f1f5f5fd5915a06de60e6989f" translate="yes" xml:space="preserve">
          <source>characters. There is a single character equivalent, for example, for the sequence &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; followed by &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; . It is called &lt;code&gt;LATIN CAPITAL LETTER A WITH
ACUTE&lt;/code&gt; . These precomposed characters are, however, only available for some combinations, and are mainly meant to support round-trip conversions between Unicode and legacy standards (like ISO 8859). Using sequences, as Unicode does, allows for needing fewer basic building blocks (code points) to express many more potential grapheme clusters. To support conversion between equivalent forms, various</source>
          <target state="translated">字符。例如，对于序列 &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; ,后跟 &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; ，有一个等效的字符。这就是所谓 &lt;code&gt;LATIN CAPITAL LETTER A WITH ACUTE&lt;/code&gt; 。但是，这些预先组合的字符仅适用于某些组合，并且主要是为了支持Unicode和旧标准（例如ISO 8859）之间的往返转换。像Unicode一样，使用序列可以减少需要的基本构件（代码点）来表达更多潜在的字素簇。为了支持等效形式之间的转换，各种</target>
        </trans-unit>
        <trans-unit id="c2769251f72974da1bea54c62a8b8393181a1511" translate="yes" xml:space="preserve">
          <source>charnames</source>
          <target state="translated">charnames</target>
        </trans-unit>
        <trans-unit id="6cbcede204922fe5735b40b4f57a548c0c0b6447" translate="yes" xml:space="preserve">
          <source>charnames - access to Unicode character names and named character sequences; also define character names</source>
          <target state="translated">charnames-访问Unicode字符名和命名的字符序列;也可以定义字符名。</target>
        </trans-unit>
        <trans-unit id="53a445993cbe9ace6d33bc2082c16e72ea889024" translate="yes" xml:space="preserve">
          <source>charnames.pm</source>
          <target state="translated">charnames.pm</target>
        </trans-unit>
        <trans-unit id="6dbb040328cb60636ff254f069ae532bcf9c34dd" translate="yes" xml:space="preserve">
          <source>charnames::string_vianame(</source>
          <target state="translated">charnames::string_vianame(</target>
        </trans-unit>
        <trans-unit id="4d584b131071626c28282572a911c82de405d92a" translate="yes" xml:space="preserve">
          <source>charnames::string_vianame(_name_)</source>
          <target state="translated">charnames::string_vianame(_name_)</target>
        </trans-unit>
        <trans-unit id="f30e5e350eda7aed251c0567e09e916651569637" translate="yes" xml:space="preserve">
          <source>charnames::viacode(</source>
          <target state="translated">charnames::viacode(</target>
        </trans-unit>
        <trans-unit id="d5ec2d618a08f9768571680bfb56871f6a619e67" translate="yes" xml:space="preserve">
          <source>charnames::viacode(_code_)</source>
          <target state="translated">charnames::viacode(_code_)</target>
        </trans-unit>
        <trans-unit id="c2b7829d2bf4d9060031381a2ab3c4936307e478" translate="yes" xml:space="preserve">
          <source>charnames::vianame(</source>
          <target state="translated">charnames::vianame(</target>
        </trans-unit>
        <trans-unit id="256d04480387a6b2d1ba2c8fd73adbaa1f26d432" translate="yes" xml:space="preserve">
          <source>charnames::vianame(_name_)</source>
          <target state="translated">charnames::vianame(_name_)</target>
        </trans-unit>
        <trans-unit id="3e62d330b7d706fa949df3d5e9ea0424f148eb11" translate="yes" xml:space="preserve">
          <source>charsize.U</source>
          <target state="translated">charsize.U</target>
        </trans-unit>
        <trans-unit id="35a84f0024005c618708f5609e5a94e5e4d92db6" translate="yes" xml:space="preserve">
          <source>chat2.pl</source>
          <target state="translated">chat2.pl</target>
        </trans-unit>
        <trans-unit id="8869899ee8011d5ab6098b5e50f006d50dff5fc7" translate="yes" xml:space="preserve">
          <source>chatty</source>
          <target state="translated">chatty</target>
        </trans-unit>
        <trans-unit id="2629bf149086d2faa087c4d7a46d46f75c8e924b" translate="yes" xml:space="preserve">
          <source>chcp(1)</source>
          <target state="translated">chcp(1)</target>
        </trans-unit>
        <trans-unit id="9b7ac455925a9f1c24e2faed07172b8cce5f6b5a" translate="yes" xml:space="preserve">
          <source>chdir</source>
          <target state="translated">chdir</target>
        </trans-unit>
        <trans-unit id="714ab6e630b89f329b1b7cd33765085d3e0f8af3" translate="yes" xml:space="preserve">
          <source>chdir DIRHANDLE</source>
          <target state="translated">chdir DIRHANDLE</target>
        </trans-unit>
        <trans-unit id="f4dc55a464a00a60ebc3a35f5b1254009801a498" translate="yes" xml:space="preserve">
          <source>chdir EXPR</source>
          <target state="translated">chdir EXPR</target>
        </trans-unit>
        <trans-unit id="01cab8f49d14f099f7ec4f8b43b93bd91584a333" translate="yes" xml:space="preserve">
          <source>chdir FILEHANDLE</source>
          <target state="translated">chdir FILEHANDLE</target>
        </trans-unit>
        <trans-unit id="21d7d24eb10c88dc964c9ead2a103baa7982275e" translate="yes" xml:space="preserve">
          <source>check the return value from these functions. Even if you are expecting only a particular number of values to be returned from the Perl subroutine, there is nothing to stop someone from doing something unexpected--don't say you haven't been warned.</source>
          <target state="translated">检查这些函数的返回值。即使你只期望从Perl子程序中返回特定数量的值,也无法阻止某人做一些意想不到的事情--不要说你没有被警告。</target>
        </trans-unit>
        <trans-unit id="f02f809bcf184ddf5eb4ab64a1de11c9bda69112" translate="yes" xml:space="preserve">
          <source>check( \%tmpl, \%args, [$verbose] );</source>
          <target state="translated">check(\%tmpl,\%args,[$verbose])。</target>
        </trans-unit>
        <trans-unit id="8974f44f89948eb6014394185f1a7d817a634988" translate="yes" xml:space="preserve">
          <source>checked for containing only well-formed UTF-8. Do not use this unless you</source>
          <target state="translated">检查是否只包含格式良好的UTF-8。不要使用此功能,除非你</target>
        </trans-unit>
        <trans-unit id="400368266f7f8e461618b3fe78656107a8a052ca" translate="yes" xml:space="preserve">
          <source>checked_at</source>
          <target state="translated">checked_at</target>
        </trans-unit>
        <trans-unit id="0dd41d48e3f4289d0dbdc4628e88dcc868f6d214" translate="yes" xml:space="preserve">
          <source>checks if all the files within a &lt;code&gt;MANIFEST&lt;/code&gt; in the current directory really do exist. If &lt;code&gt;MANIFEST&lt;/code&gt; and the tree below the current directory are in sync it silently returns an empty list. Otherwise it returns a list of files which are listed in the &lt;code&gt;MANIFEST&lt;/code&gt; but missing from the directory, and by default also outputs these names to STDERR.</source>
          <target state="translated">检查当前目录中 &lt;code&gt;MANIFEST&lt;/code&gt; 内的所有文件是否确实存在。如果 &lt;code&gt;MANIFEST&lt;/code&gt; 和当前目录下的树同步，则它静默返回一个空列表。否则返回其在上市文件的列表 &lt;code&gt;MANIFEST&lt;/code&gt; ，但是从目录中缺少，默认情况下也输出这些名称STDERR。</target>
        </trans-unit>
        <trans-unit id="d202be8aad13da1f92438d8b7937c8916d90c438" translate="yes" xml:space="preserve">
          <source>checkstr</source>
          <target state="translated">checkstr</target>
        </trans-unit>
        <trans-unit id="0e93069c40111cd62dac2cd02cd71daffdb01cc0" translate="yes" xml:space="preserve">
          <source>child</source>
          <target state="translated">child</target>
        </trans-unit>
        <trans-unit id="793fd19ae07dde0a2238bbe91255c3e0f8040ede" translate="yes" xml:space="preserve">
          <source>chip@fin.uucp</source>
          <target state="translated">chip@fin.uucp</target>
        </trans-unit>
        <trans-unit id="ce1b7c1e7d1b9f2bbb281956ad9dba56ae30dd10" translate="yes" xml:space="preserve">
          <source>chmod</source>
          <target state="translated">chmod</target>
        </trans-unit>
        <trans-unit id="6f334e9a5d18a9e6fad620c5d5feb7ca5c9ca91e" translate="yes" xml:space="preserve">
          <source>chmod LIST</source>
          <target state="translated">chmod LIST</target>
        </trans-unit>
        <trans-unit id="6775b573f38862fd49aea4ec4a987af120199a47" translate="yes" xml:space="preserve">
          <source>chomp</source>
          <target state="translated">chomp</target>
        </trans-unit>
        <trans-unit id="14fe3aa3b351bb70abdaefa315855bec62fe6b23" translate="yes" xml:space="preserve">
          <source>chomp VARIABLE</source>
          <target state="translated">变量</target>
        </trans-unit>
        <trans-unit id="f7655cc7fd7fc8d38a728857c81359132ca5f90e" translate="yes" xml:space="preserve">
          <source>chomp( LIST )</source>
          <target state="translated">chomp(LIST )</target>
        </trans-unit>
        <trans-unit id="0914b71d9a69f732130e136ef20b1f049f4b0707" translate="yes" xml:space="preserve">
          <source>chop</source>
          <target state="translated">chop</target>
        </trans-unit>
        <trans-unit id="d48877c4b876189389e3d56b423aa9d8adf06337" translate="yes" xml:space="preserve">
          <source>chop VARIABLE</source>
          <target state="translated">剁碎</target>
        </trans-unit>
        <trans-unit id="023175c3a37e36cc780269b539ded9f00d61cdca" translate="yes" xml:space="preserve">
          <source>chop( LIST )</source>
          <target state="translated">斩(LIST )</target>
        </trans-unit>
        <trans-unit id="f9f4b9a5f607e09de3d3e8274799aecdc429bc1b" translate="yes" xml:space="preserve">
          <source>chown</source>
          <target state="translated">chown</target>
        </trans-unit>
        <trans-unit id="6b4c351cbd67fa757a21b0ee957f6648d69bb53c" translate="yes" xml:space="preserve">
          <source>chown LIST</source>
          <target state="translated">chown LIST</target>
        </trans-unit>
        <trans-unit id="52018ef6a64fdefbf8127ede4f29a9094de1c755" translate="yes" xml:space="preserve">
          <source>chr</source>
          <target state="translated">chr</target>
        </trans-unit>
        <trans-unit id="1a528aa73e431095b3aaf4c5d6c14c4ab4985caf" translate="yes" xml:space="preserve">
          <source>chr NUMBER</source>
          <target state="translated">编号</target>
        </trans-unit>
        <trans-unit id="80fcb88d41205d6e76d6dff653bb3acc664463a8" translate="yes" xml:space="preserve">
          <source>chr(), ord(), substr(), index() and rindex() behave similarly.</source>
          <target state="translated">chr()、ord()、substr()、index()和rindex()的行为类似。</target>
        </trans-unit>
        <trans-unit id="43f12e50e08974b895e2ed854996e592cd4c8a47" translate="yes" xml:space="preserve">
          <source>chroot</source>
          <target state="translated">chroot</target>
        </trans-unit>
        <trans-unit id="8bc1f73f42677c7ed6b6c8bcb2ecb8307de7d407" translate="yes" xml:space="preserve">
          <source>chroot FILENAME</source>
          <target state="translated">藕节</target>
        </trans-unit>
        <trans-unit id="6c689caf965677e20e4b5b662bd605f6a419ab03" translate="yes" xml:space="preserve">
          <source>ckfun</source>
          <target state="translated">ckfun</target>
        </trans-unit>
        <trans-unit id="c45b8d14b3e1d422fb397e41aba7a7922103cb02" translate="yes" xml:space="preserve">
          <source>ckobj</source>
          <target state="translated">ckobj</target>
        </trans-unit>
        <trans-unit id="8d767bf5b72373d12f0efd4406677e9ed076f592" translate="yes" xml:space="preserve">
          <source>class</source>
          <target state="translated">class</target>
        </trans-unit>
        <trans-unit id="e8954076dd543ae7c54252674b562258ca9ac2cf" translate="yes" xml:space="preserve">
          <source>class coincides with the current one.</source>
          <target state="translated">类与当前的类相吻合。</target>
        </trans-unit>
        <trans-unit id="fc160c927561b470a5ed7db832522a92dcd5924c" translate="yes" xml:space="preserve">
          <source>class methods</source>
          <target state="translated">类方法</target>
        </trans-unit>
        <trans-unit id="d1583919405b0ffaf7049dbab585a9522a3f0a6c" translate="yes" xml:space="preserve">
          <source>class of the tie()d variable.</source>
          <target state="translated">变量 tie()d 的类。</target>
        </trans-unit>
        <trans-unit id="7f794a42ad5205654a6f8a1f0ce2833ce24667bc" translate="yes" xml:space="preserve">
          <source>class the parser should use. It defaults to &lt;a href=&quot;parser/grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt;.</source>
          <target state="translated">解析器应该使用的类。默认为&lt;a href=&quot;parser/grammar&quot;&gt;TAP :: Parser :: Grammar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1adaa84dc07a16d34ede5b9a70713ff832a0f853" translate="yes" xml:space="preserve">
          <source>classes</source>
          <target state="translated">classes</target>
        </trans-unit>
        <trans-unit id="61fbbd0dc1d8da92c1eac1d42004f614817ad786" translate="yes" xml:space="preserve">
          <source>classes, each class declares a (typically lexical) hash for each field it wants to use. The reference address of an object is used as the hash key. By definition, the reference address is unique to each object so this guarantees a place for each field that is private to the class and unique to each object. See &lt;code&gt;Name_id&lt;/code&gt; in &lt;a href=&quot;#Example-1&quot;&gt;Example 1&lt;/a&gt; for a simple example.</source>
          <target state="translated">类，每个类为其要使用的每个字段声明一个（通常是词法）哈希。对象的引用地址用作哈希键。根据定义，引用地址对于每个对象都是唯一的，因此这保证了每个字段对于该类都是私有的并且对于每个对象都是唯一的。有关 &lt;code&gt;Name_id&lt;/code&gt; ，请参见&lt;a href=&quot;#Example-1&quot;&gt;示例1&lt;/a&gt;中的Name_id。</target>
        </trans-unit>
        <trans-unit id="596d49ad40a7bfdeccd623b010b2e22381e6296b" translate="yes" xml:space="preserve">
          <source>clean (o)</source>
          <target state="translated">干净</target>
        </trans-unit>
        <trans-unit id="99876f76b65400ea89723de9692bdbd1d5995e5e" translate="yes" xml:space="preserve">
          <source>clean_subdirs_target</source>
          <target state="translated">clean_subdirs_target</target>
        </trans-unit>
        <trans-unit id="6fa23a207d7e5bd69c9944ee5d9c366d5d10fc7d" translate="yes" xml:space="preserve">
          <source>clear the end-of-file condition on the handle, so that the next &lt;code&gt;&amp;lt;FILE&amp;gt;&lt;/code&gt; makes Perl try again to read something. (We hope.)</source>
          <target state="translated">清除句柄上的文件结束条件，以便下一个 &lt;code&gt;&amp;lt;FILE&amp;gt;&lt;/code&gt; 使Perl再次尝试读取某些内容。（我们希望。）</target>
        </trans-unit>
        <trans-unit id="bcf447495c45ee1eb737f812581bbeefba6a61da" translate="yes" xml:space="preserve">
          <source>clear_for_close</source>
          <target state="translated">clear_for_close</target>
        </trans-unit>
        <trans-unit id="b3da65bbc40b2249fd82c5dbf801f5b38f10338a" translate="yes" xml:space="preserve">
          <source>cloning</source>
          <target state="translated">cloning</target>
        </trans-unit>
        <trans-unit id="da38860cb875cb64092e402d80d9fe29c4865b18" translate="yes" xml:space="preserve">
          <source>close</source>
          <target state="translated">close</target>
        </trans-unit>
        <trans-unit id="d3e09694ad361f2d14e06be36c08e555dfe35cf7" translate="yes" xml:space="preserve">
          <source>close FILEHANDLE</source>
          <target state="translated">关闭FILEHANDLE</target>
        </trans-unit>
        <trans-unit id="b93282e6b78f94dc23da20ce483ad7fb84179590" translate="yes" xml:space="preserve">
          <source>close_test</source>
          <target state="translated">close_test</target>
        </trans-unit>
        <trans-unit id="448a0f12f99fbc5c68d38d7274165acc527a990b" translate="yes" xml:space="preserve">
          <source>closedir</source>
          <target state="translated">closedir</target>
        </trans-unit>
        <trans-unit id="5af96b35b3b6011de105827ac853e0503206d5a3" translate="yes" xml:space="preserve">
          <source>closedir DIRHANDLE</source>
          <target state="translated">Closedir DIRHANDLE</target>
        </trans-unit>
        <trans-unit id="004e9fd382447a65ced980bdc76de1f2cd09d173" translate="yes" xml:space="preserve">
          <source>closes the input and output files.</source>
          <target state="translated">关闭输入和输出文件。</target>
        </trans-unit>
        <trans-unit id="d091cefc7695f6aba9a1064d92fd838e1321dce0" translate="yes" xml:space="preserve">
          <source>closure</source>
          <target state="translated">closure</target>
        </trans-unit>
        <trans-unit id="03b254b372b345c237118eeb5587f74d20f6f2cc" translate="yes" xml:space="preserve">
          <source>closure filter</source>
          <target state="translated">闭合过滤器</target>
        </trans-unit>
        <trans-unit id="2d24694e45580957f57c09b542c087cecccfbafe" translate="yes" xml:space="preserve">
          <source>closure filters</source>
          <target state="translated">闭合过滤器</target>
        </trans-unit>
        <trans-unit id="7bacf512003f37590fdb819abc21a1abb0ffcaaa" translate="yes" xml:space="preserve">
          <source>closures</source>
          <target state="translated">closures</target>
        </trans-unit>
        <trans-unit id="ebf1f9fa8afd6d1932bd65bc4cc3af89a4c8e228" translate="yes" xml:space="preserve">
          <source>cmd.exe</source>
          <target state="translated">cmd.exe</target>
        </trans-unit>
        <trans-unit id="a07c2354daca744663c8a244d9878da128ee6a3a" translate="yes" xml:space="preserve">
          <source>cmd1</source>
          <target state="translated">cmd1</target>
        </trans-unit>
        <trans-unit id="b7ff88cc24f1683fbbca6c2098a5c5e37bd49915" translate="yes" xml:space="preserve">
          <source>cmd2</source>
          <target state="translated">cmd2</target>
        </trans-unit>
        <trans-unit id="ba6c06e4be30524ef0009a48aabf7d270581932f" translate="yes" xml:space="preserve">
          <source>cmp</source>
          <target state="translated">cmp</target>
        </trans-unit>
        <trans-unit id="f5a2ec7db0bf19e16b47cd761c37cf88ab9ac38c" translate="yes" xml:space="preserve">
          <source>cmpthese - print results of timethese as a comparison chart</source>
          <target state="translated">cmpthese-以对比图的形式打印出timethese的结果。</target>
        </trans-unit>
        <trans-unit id="e6fb06210fafc02fd7479ddbed2d042cc3a5155e" translate="yes" xml:space="preserve">
          <source>code</source>
          <target state="translated">code</target>
        </trans-unit>
        <trans-unit id="9da61277ba6865aaef989ee99dee168468b958be" translate="yes" xml:space="preserve">
          <source>code feeds it the constructions it recognizes. Since</source>
          <target state="translated">代码向它提供它所识别的结构。由于</target>
        </trans-unit>
        <trans-unit id="c1a1ce9f897fd014df7e4f16014e8d3ab6f114ba" translate="yes" xml:space="preserve">
          <source>code point</source>
          <target state="translated">码点</target>
        </trans-unit>
        <trans-unit id="f52d596cb405e6b2f7e9f85a49d0e9ce72ddb86a" translate="yes" xml:space="preserve">
          <source>code point argument</source>
          <target state="translated">论点代码</target>
        </trans-unit>
        <trans-unit id="11d4a42d17eb1eb21462ecad911515e463934b68" translate="yes" xml:space="preserve">
          <source>code point pairs. You can test whether a code point is in a range set using the &lt;a href=&quot;#charinrange()&quot;&gt;charinrange()&lt;/a&gt; function. (To be precise, each</source>
          <target state="translated">代码点对。您可以使用&lt;a href=&quot;#charinrange()&quot;&gt;charinrange（）&lt;/a&gt;函数测试代码点是否在范围内。（准确地说，每个</target>
        </trans-unit>
        <trans-unit id="5e0af62d93d2da86a0151c2341d222a391773edd" translate="yes" xml:space="preserve">
          <source>code points</source>
          <target state="translated">点码</target>
        </trans-unit>
        <trans-unit id="657316ad9de3b1e352b6e95e3450ef30527c5349" translate="yes" xml:space="preserve">
          <source>code to ensure portability.</source>
          <target state="translated">代码以确保可移植性。</target>
        </trans-unit>
        <trans-unit id="bac2cb7df5401a49f39bf565a8d26e84d63a9aef" translate="yes" xml:space="preserve">
          <source>coderef for CHECK</source>
          <target state="translated">coderef for CHECK</target>
        </trans-unit>
        <trans-unit id="0e27b22a86082458f75eb9a01371da18ccced707" translate="yes" xml:space="preserve">
          <source>coderef2text</source>
          <target state="translated">coderef2text</target>
        </trans-unit>
        <trans-unit id="794269474d0aada35852054db9616d8208afcea7" translate="yes" xml:space="preserve">
          <source>codeset</source>
          <target state="translated">codeset</target>
        </trans-unit>
        <trans-unit id="0affef98bf27a31edab1f82edb89feedbc9acc25" translate="yes" xml:space="preserve">
          <source>coincides with &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; $_, $-[n],
$+[n] - $-[n]&lt;/code&gt; if &lt;code&gt;$-[n]&lt;/code&gt; is defined, and $+ coincides with &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; $_, $-[$#-], $+[$#-] - $-[$#-]&lt;/code&gt; . One can use &lt;code&gt;$#-&lt;/code&gt; to find the last matched subgroup in the last successful match. Contrast with &lt;code&gt;$#+&lt;/code&gt; , the number of subgroups in the regular expression. Compare with &lt;code&gt;@+&lt;/code&gt; .</source>
          <target state="translated">重合与 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; $_, $-[n], $+[n] - $-[n]&lt;/code&gt; ，如果 &lt;code&gt;$-[n]&lt;/code&gt; 的定义，和$ +与重合 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; $_, $-[$#-], $+[$#-] - $-[$#-]&lt;/code&gt; 。可以使用 &lt;code&gt;$#-&lt;/code&gt; 在最后一次成功匹配中找到最后一个匹配的子组。与 &lt;code&gt;$#+&lt;/code&gt; 相比，正则表达式中的子组数。与 &lt;code&gt;@+&lt;/code&gt; 比较。</target>
        </trans-unit>
        <trans-unit id="baa7634dd6fc792fc39f9eade8c13eef4dc7f687" translate="yes" xml:space="preserve">
          <source>color() takes any number of strings as arguments and considers them to be space-separated lists of attributes. It then forms and returns the escape sequence to set those attributes. It doesn't print it out, just returns it, so you'll have to print it yourself if you want to. This is so that you can save it as a string, pass it to something else, send it to a file handle, or do anything else with it that you might care to. color() throws an exception if given an invalid attribute.</source>
          <target state="translated">color()接受任意数量的字符串作为参数,并将它们视为以空间分隔的属性列表。然后它形成并返回转义序列来设置这些属性。它不会打印出来,只是返回,所以如果你想打印的话,你必须自己打印。这样你就可以把它保存为一个字符串,把它传给其他东西,把它发送到一个文件句柄,或者做其他你可能想做的事情。 color()如果给定一个无效的属性,就会抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="866ebe5a4ffaae003e56cb9000e64fc80cbe587b" translate="yes" xml:space="preserve">
          <source>colorstrip() removes all color escape sequences from the provided strings, returning the modified strings separately in array context or joined together in scalar context. Its arguments are not modified.</source>
          <target state="translated">colorstrip()从提供的字符串中删除所有颜色转义序列,在数组上下文中分别返回修改后的字符串,或者在标量上下文中合并在一起。它的参数不会被修改。</target>
        </trans-unit>
        <trans-unit id="cc2e88d690afd5cca29d4c4820d6f40e865ad2d9" translate="yes" xml:space="preserve">
          <source>colorstrip() was added in Term::ANSIColor 2.01 and colorvalid() was added in Term::ANSIColor 2.02, both included in Perl 5.11.0.</source>
          <target state="translated">在Term::ANSIColor 2.01中加入了colorstrip(),在Term::ANSIColor 2.02中加入了colorvalid(),都包含在Perl 5.11.0中。</target>
        </trans-unit>
        <trans-unit id="c0c1c531424ec61747f6f1b2747a02b590468e5f" translate="yes" xml:space="preserve">
          <source>colorvalid() takes attribute strings the same as color() and returns true if all attributes are known and false otherwise.</source>
          <target state="translated">colorvalid()接收与color()相同的属性字符串,如果所有属性都已知,则返回true,否则返回false。</target>
        </trans-unit>
        <trans-unit id="553b8d9460d5ec9d3238ec3f9f149796206668d1" translate="yes" xml:space="preserve">
          <source>columns. The default is 4 columns.</source>
          <target state="translated">列。默认为4列。</target>
        </trans-unit>
        <trans-unit id="0a5bdb6930a55ea4051008b470a27e557f0620ff" translate="yes" xml:space="preserve">
          <source>combining</source>
          <target state="translated">combining</target>
        </trans-unit>
        <trans-unit id="5c296375f250fae9b2dc8c5ee373383cede54d7b" translate="yes" xml:space="preserve">
          <source>combining character sequence</source>
          <target state="translated">连体字</target>
        </trans-unit>
        <trans-unit id="1e72c3cef8ffa878469f9a8d3b32a08cf2d9d042" translate="yes" xml:space="preserve">
          <source>combining the regexps,</source>
          <target state="translated">结合regexps。</target>
        </trans-unit>
        <trans-unit id="4b30e55fedcd2138a431b53a3c8fa077f91776a7" translate="yes" xml:space="preserve">
          <source>come as compressed or gzipped tarfiles or as zip files and contain a &lt;code&gt;Makefile.PL&lt;/code&gt; or &lt;code&gt;Build.PL&lt;/code&gt; (well, we try to handle a bit more, but with little enthusiasm).</source>
          <target state="translated">以压缩或gzip压缩的tarfile或zip文件的形式出现，并包含 &lt;code&gt;Makefile.PL&lt;/code&gt; 或 &lt;code&gt;Build.PL&lt;/code&gt; （好吧，我们尝试处理更多一点，但热情不高）。</target>
        </trans-unit>
        <trans-unit id="ec796d4586552c37788a6ebe53e4ff905b4159b6" translate="yes" xml:space="preserve">
          <source>comes first and must consist of complete lines of input, and</source>
          <target state="translated">在前,必须由完整的输入行组成,而</target>
        </trans-unit>
        <trans-unit id="08ae9576a25419d97eee8be6079d1102dd501788" translate="yes" xml:space="preserve">
          <source>comma after the initial block when you use &lt;code&gt;FILTER&lt;/code&gt; ).</source>
          <target state="translated">使用 &lt;code&gt;FILTER&lt;/code&gt; 时，初始块后面的逗号）。</target>
        </trans-unit>
        <trans-unit id="a00fc89e489feb78ba2a90d1a1a3e2742cd34b6d" translate="yes" xml:space="preserve">
          <source>command alias management</source>
          <target state="translated">命令别名管理</target>
        </trans-unit>
        <trans-unit id="a32233989708642f746d478ae78867a000f29692" translate="yes" xml:space="preserve">
          <source>command described in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;, which is usable only if a special Perl is built per the instructions in the</source>
          <target state="translated">&lt;a href=&quot;perlrun&quot;&gt;perlrun中&lt;/a&gt;描述的命令，仅当根据Perlrun中的说明构建特殊的Perl时才可用</target>
        </trans-unit>
        <trans-unit id="2350fa1ca5933d3319468870ed1a147463ee228e" translate="yes" xml:space="preserve">
          <source>command is executed with the corresponding part of its memory erased.</source>
          <target state="translated">命令在执行时,其内存的相应部分被删除。</target>
        </trans-unit>
        <trans-unit id="ce97aac05c65318d3a9c0de9f45b34691b032ae8" translate="yes" xml:space="preserve">
          <source>command line tool. This tool will ensure that your bug report includes all the relevant system and configuration information.</source>
          <target state="translated">命令行工具。这个工具将确保你的错误报告包括所有相关的系统和配置信息。</target>
        </trans-unit>
        <trans-unit id="95d7b5e04adb582ccbd1830291eb225a995904e2" translate="yes" xml:space="preserve">
          <source>command line), then there is no reason to assume that the Configure-time $installstyle setting will be relevant for that &lt;code&gt;PREFIX&lt;/code&gt; .</source>
          <target state="translated">命令行），则没有理由假定Configure-time $ installstyle设置与该 &lt;code&gt;PREFIX&lt;/code&gt; 相关。</target>
        </trans-unit>
        <trans-unit id="26f462963f9eb20fdaa42ca56411218d1ee06ad2" translate="yes" xml:space="preserve">
          <source>command paragraph, so a &quot;=pod&quot; command is usually used just when you want to start a Pod block with an ordinary paragraph or a verbatim paragraph. For example:</source>
          <target state="translated">命令段,所以&quot;=pod &quot;命令通常只是在你想用普通段或逐字段开始一个Pod块时使用。例如</target>
        </trans-unit>
        <trans-unit id="fa5b28913405846cb20d2d5c0f7c9da9fdcdad2d" translate="yes" xml:space="preserve">
          <source>command paragraphs allow formatting codes in their content (i.e., after the part that matches &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]\S*\s*/&lt;/a&gt;&lt;/code&gt;), as in:</source>
          <target state="translated">命令段允许在其内容中（即，在匹配 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]\S*\s*/&lt;/a&gt;&lt;/code&gt; 的部分之后）设置格式代码，如下所示：</target>
        </trans-unit>
        <trans-unit id="908e44229adf15648bd313eea07d94f19b18fe8f" translate="yes" xml:space="preserve">
          <source>command processing</source>
          <target state="translated">指令处理</target>
        </trans-unit>
        <trans-unit id="81e8811a50c94aa47e6ab235f23967bf8162fcab" translate="yes" xml:space="preserve">
          <source>command sometimes compensates for this. Other restrictions include whether it works on directories, open files, or pre-existing files. Check &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; and either the rename(2) manpage or equivalent system documentation for details.</source>
          <target state="translated">命令有时可以弥补这一点。其他限制包括它是否适用于目录，打开的文件或预先存在的文件。有关详细信息，请检查&lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;和rename（2）联机帮助页或等效的系统文档。</target>
        </trans-unit>
        <trans-unit id="004b6326b0d5ffc41e7dd89235723df45cdc46b1" translate="yes" xml:space="preserve">
          <source>command sometimes compensates for this. Other restrictions include whether it works on directories, open files, or pre-existing files. Check &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; and either the rename(2) manpage or equivalent system documentation for details.</source>
          <target state="translated">命令有时可以弥补这一点。其他限制包括它是否适用于目录，打开的文件或预先存在的文件。有关详细信息，请检查&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;和rename（2）联机帮助页或等效的系统文档。</target>
        </trans-unit>
        <trans-unit id="701dc47ba0201600971182fe81e8e08348a51774" translate="yes" xml:space="preserve">
          <source>command, and finally the</source>
          <target state="translated">命令,最后是</target>
        </trans-unit>
        <trans-unit id="695d63b2267f9baaa26a81fd9fd45c17a391ec3e" translate="yes" xml:space="preserve">
          <source>command. File::Find exports two functions, &lt;code&gt;find&lt;/code&gt; and &lt;code&gt;finddepth&lt;/code&gt; . They work similarly but have subtle differences.</source>
          <target state="translated">命令。File :: Find导出两个函数， &lt;code&gt;find&lt;/code&gt; 和 &lt;code&gt;finddepth&lt;/code&gt; 。它们的工作类似，但有细微的差别。</target>
        </trans-unit>
        <trans-unit id="c336680fdba2930981615fe8aa2bf1e1c4871200" translate="yes" xml:space="preserve">
          <source>command. The default behaviour is to try to use an external</source>
          <target state="translated">命令。默认的行为是尝试使用外部的</target>
        </trans-unit>
        <trans-unit id="b0d021f1ed473dc5029d50be679688256761e06b" translate="yes" xml:space="preserve">
          <source>comment methods</source>
          <target state="translated">评论方法</target>
        </trans-unit>
        <trans-unit id="5a3c2cd2a71dbff7e78a7d63e72b8ddb4e74daf8" translate="yes" xml:space="preserve">
          <source>commercial software: it has a license that you can grab and carefully read to your manager. It is distributed in releases and comes in well-defined packages. There is a very large and supportive user community and an extensive literature.</source>
          <target state="translated">商业软件:它有一个许可证,你可以抓紧时间向你的经理仔细阅读。它是以发行版的形式发布的,并且有明确的包。有一个非常庞大和支持性的用户社区和一个广泛的文献。</target>
        </trans-unit>
        <trans-unit id="4015b57a143aec5156fd1444a017a32137a3fd0f" translate="yes" xml:space="preserve">
          <source>commit</source>
          <target state="translated">commit</target>
        </trans-unit>
        <trans-unit id="b1227d2ef5edb14a1d4bf6dfb9871c3a17b42df0" translate="yes" xml:space="preserve">
          <source>comp</source>
          <target state="translated">comp</target>
        </trans-unit>
        <trans-unit id="6e4ad69ef96331c1a04ff5303a4abcd4e99129b4" translate="yes" xml:space="preserve">
          <source>comp.programming.threads FAQ, &lt;a href=&quot;http://www.serpentine.com/~bos/threads-faq/&quot;&gt;http://www.serpentine.com/~bos/threads-faq/&lt;/a&gt;</source>
          <target state="translated">comp.programming.threads常见问题解答，&lt;a href=&quot;http://www.serpentine.com/~bos/threads-faq/&quot;&gt;http：//www.serpentine.com/~bos/threads-faq/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="068bba568e6340e330e37a3839f209788f1db08b" translate="yes" xml:space="preserve">
          <source>compatibility file in Debian 4.0.</source>
          <target state="translated">Debian 4.0中的兼容文件。</target>
        </trans-unit>
        <trans-unit id="2e947ba843b3abd53a604b05f7c1726c8be4b575" translate="yes" xml:space="preserve">
          <source>compatibility file in RedHat 7.1.</source>
          <target state="translated">RedHat 7.1中的兼容文件。</target>
        </trans-unit>
        <trans-unit id="f479a23ebfa9b36fa8585d6c66f9a64aa6f9919c" translate="yes" xml:space="preserve">
          <source>compatibility to run &lt;code&gt;XS&lt;/code&gt; code built with the older version). Normally this does not change across maintenance releases. Please read the comment in</source>
          <target state="translated">兼容性以运行使用旧版本构建的 &lt;code&gt;XS&lt;/code&gt; 代码）。通常，在维护版本之间这不会改变。请阅读中的评论</target>
        </trans-unit>
        <trans-unit id="592c971d2d8aa617ad80fea75f2b71af931174b8" translate="yes" xml:space="preserve">
          <source>compatible with the Unix commands of the same name.</source>
          <target state="translated">与同名的Unix命令兼容。</target>
        </trans-unit>
        <trans-unit id="7ac5aba35566b199712c3d2eb7b5e62396cee0a9" translate="yes" xml:space="preserve">
          <source>compilation that the already compiled code may try to perform.</source>
          <target state="translated">已经编译的代码可能会尝试进行编译。</target>
        </trans-unit>
        <trans-unit id="91d57a8d930f6b42fac784730108b8b9dd712b28" translate="yes" xml:space="preserve">
          <source>compile.bat</source>
          <target state="translated">compile.bat</target>
        </trans-unit>
        <trans-unit id="9b6cf5446314f1e4646cf53c0d7e62a18d873f8f" translate="yes" xml:space="preserve">
          <source>compiled form</source>
          <target state="translated">编成</target>
        </trans-unit>
        <trans-unit id="2b2563adbae4d00637b45758bb62d62aa6388692" translate="yes" xml:space="preserve">
          <source>compiler is supported by IBM on AIX 5L/6.1/7.1.</source>
          <target state="translated">IBM在AIX 5L/6.1/7.1上支持编译器。</target>
        </trans-unit>
        <trans-unit id="3df4914ee42164f6ae46e850cebfd5c0ca11bba2" translate="yes" xml:space="preserve">
          <source>compiles any code. Attempting to compile code which contains a masked opcode will cause the compilation to fail with an error. The code will not be executed.</source>
          <target state="translated">编译任何代码。试图编译包含屏蔽的操作码的代码将导致编译失败,出现错误。代码将不会被执行。</target>
        </trans-unit>
        <trans-unit id="1c3ad01b92b3dbd52abd622ca6216853c1fba74b" translate="yes" xml:space="preserve">
          <source>compiles to</source>
          <target state="translated">编译为</target>
        </trans-unit>
        <trans-unit id="36152587b7f8361cfbcf149096a1a5e82959c60d" translate="yes" xml:space="preserve">
          <source>completely</source>
          <target state="translated">completely</target>
        </trans-unit>
        <trans-unit id="b2d73ff91a5f876b29cc72977847ee5d1c3be9a9" translate="yes" xml:space="preserve">
          <source>complex plane</source>
          <target state="translated">复平面</target>
        </trans-unit>
        <trans-unit id="c212f08ed1157ae268fd83d142afd5ccd48664b2" translate="yes" xml:space="preserve">
          <source>components</source>
          <target state="translated">components</target>
        </trans-unit>
        <trans-unit id="12dfb7d897712cd52e3ec502407df7551db4693c" translate="yes" xml:space="preserve">
          <source>composed of a single space character (such as &lt;code&gt;' '&lt;/code&gt; or &lt;code&gt;&quot;\x20&quot;&lt;/code&gt; , but not e.g. &lt;code&gt;/ /&lt;/code&gt; ). In this case, any leading whitespace in EXPR is removed before splitting occurs, and the PATTERN is instead treated as if it were &lt;code&gt;/\s+/&lt;/code&gt; ; in particular, this means that</source>
          <target state="translated">由单个空格字符组成（例如 &lt;code&gt;' '&lt;/code&gt; 或 &lt;code&gt;&quot;\x20&quot;&lt;/code&gt; ，但不包括例如 &lt;code&gt;/ /&lt;/code&gt; ）。在这种情况下，EXPL中的任何前导空格都在拆分之前被删除，而PATTERN被视为 &lt;code&gt;/\s+/&lt;/code&gt; ；特别是，这意味着</target>
        </trans-unit>
        <trans-unit id="6127e6ffe8872ff87ec22f05e6b9f1acb37d59aa" translate="yes" xml:space="preserve">
          <source>compressed data in &lt;code&gt;$input&lt;/code&gt; will have been dealt with. So if you are reading from an input source and uncompressing as you go the code will look something like this</source>
          <target state="translated">&lt;code&gt;$input&lt;/code&gt; 压缩数据将得到处理。因此，如果您正在从输入源中读取并解压缩，那么代码将如下所示</target>
        </trans-unit>
        <trans-unit id="025869549b0b056eecdf01e5c7a04198305b98fb" translate="yes" xml:space="preserve">
          <source>compression library (see &lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt; for details about where to get</source>
          <target state="translated">压缩库（有关从何处获取的详细信息，请参见&lt;a href=&quot;#AUTHOR&quot;&gt;作者&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec13e4eb72f3d391134259d0183bd64c7b1680c9" translate="yes" xml:space="preserve">
          <source>compression library is</source>
          <target state="translated">压缩库是</target>
        </trans-unit>
        <trans-unit id="f12f044c06efa896066b896898d28ea39f1d4af9" translate="yes" xml:space="preserve">
          <source>compression library was written by Jean-loup Gailly</source>
          <target state="translated">压缩库由Jean-loup Gailly编写。</target>
        </trans-unit>
        <trans-unit id="af30dd1d79e03186a6532248645f23029d5446ae" translate="yes" xml:space="preserve">
          <source>concept, which was later further refined into the</source>
          <target state="translated">概念,后来进一步完善为</target>
        </trans-unit>
        <trans-unit id="f9b3c21e895be55922fa8fbdd5f7a004769b4fca" translate="yes" xml:space="preserve">
          <source>cond</source>
          <target state="translated">cond</target>
        </trans-unit>
        <trans-unit id="afad9a69767e7c24ecda5af9187202e1b4b070b2" translate="yes" xml:space="preserve">
          <source>condition</source>
          <target state="translated">condition</target>
        </trans-unit>
        <trans-unit id="53fe0e9923a8475c588d93af07f3fd82021e751d" translate="yes" xml:space="preserve">
          <source>conditional expression</source>
          <target state="translated">条件表达式</target>
        </trans-unit>
        <trans-unit id="c705b5c07e94e5b4ef420654932ee77cfc0d3039" translate="yes" xml:space="preserve">
          <source>config()</source>
          <target state="translated">config()</target>
        </trans-unit>
        <trans-unit id="03461db87a24c8a99f7e61a96ba5df4ef9e79d47" translate="yes" xml:space="preserve">
          <source>config.h</source>
          <target state="translated">config.h</target>
        </trans-unit>
        <trans-unit id="7e889baa6e4cb4bd98805a8b8096412822c4f99d" translate="yes" xml:space="preserve">
          <source>config.sh</source>
          <target state="translated">config.sh</target>
        </trans-unit>
        <trans-unit id="685bb349569f3229e3d50061ff81accc6f623504" translate="yes" xml:space="preserve">
          <source>config_h.SH</source>
          <target state="translated">config_h.SH</target>
        </trans-unit>
        <trans-unit id="5b71a4225f3de00a0de0a2d057fbdc6b7907a61f" translate="yes" xml:space="preserve">
          <source>configpm</source>
          <target state="translated">configpm</target>
        </trans-unit>
        <trans-unit id="09be8533ff0a6ee5d577f971145ed449399fcda4" translate="yes" xml:space="preserve">
          <source>configure</source>
          <target state="translated">configure</target>
        </trans-unit>
        <trans-unit id="6ddd132f5d7491ac61dfcd007387153f4cdb2499" translate="yes" xml:space="preserve">
          <source>configvar</source>
          <target state="translated">configvar</target>
        </trans-unit>
        <trans-unit id="4443fcb96c75058684a34fa6e9077456b788f37d" translate="yes" xml:space="preserve">
          <source>conforming systems).</source>
          <target state="translated">符合系统)。)</target>
        </trans-unit>
        <trans-unit id="4ca9e20e4d70df9dc6c19f404890df5beb2102cd" translate="yes" xml:space="preserve">
          <source>confused about &lt;code&gt;@_&lt;/code&gt; or &lt;code&gt;@DB::args&lt;/code&gt; being tied.</source>
          <target state="translated">对 &lt;code&gt;@_&lt;/code&gt; 或 &lt;code&gt;@DB::args&lt;/code&gt; 被束缚感到困惑。</target>
        </trans-unit>
        <trans-unit id="9664a445a056225ffd216e07a2091d6ad3ff0a33" translate="yes" xml:space="preserve">
          <source>conjugate</source>
          <target state="translated">conjugate</target>
        </trans-unit>
        <trans-unit id="f11a107f38328604e9320754224b60375758bca1" translate="yes" xml:space="preserve">
          <source>connect</source>
          <target state="translated">connect</target>
        </trans-unit>
        <trans-unit id="5b5fd14fd15af0f29c402a456040108ca491bf96" translate="yes" xml:space="preserve">
          <source>connect SOCKET,NAME</source>
          <target state="translated">连接SOCKET,NAME</target>
        </trans-unit>
        <trans-unit id="c2fae7502ca3a8313cd77e43cfa9956a074b0666" translate="yes" xml:space="preserve">
          <source>considered meaningful in language-tag comparison.)</source>
          <target state="translated">在语言标签比较中被认为是有意义的)。)</target>
        </trans-unit>
        <trans-unit id="222f86aa8df05eadc1219055ce940b90898f4ea9" translate="yes" xml:space="preserve">
          <source>considered part of the POD document).</source>
          <target state="translated">视为POD文件的一部分)。)</target>
        </trans-unit>
        <trans-unit id="afd9e885669a3e138aed5be1f9fa0911cf7081c4" translate="yes" xml:space="preserve">
          <source>considered to be a symbolic reference when you're using strict refs:</source>
          <target state="translated">当你使用严格引用时,被认为是一个符号引用。</target>
        </trans-unit>
        <trans-unit id="11f4a64f6fa1d91c5e7b6e491377d7a035449d88" translate="yes" xml:space="preserve">
          <source>considered variable interpolation. Thus:</source>
          <target state="translated">认为是变量插值。因此。</target>
        </trans-unit>
        <trans-unit id="17a9fea753f52d4e03254e2e57c3c4bed8f95bd9" translate="yes" xml:space="preserve">
          <source>const_meth</source>
          <target state="translated">const_meth</target>
        </trans-unit>
        <trans-unit id="d810ca965a236c6f46a932efff918a4b3a191918" translate="yes" xml:space="preserve">
          <source>constant</source>
          <target state="translated">constant</target>
        </trans-unit>
        <trans-unit id="0504ccc4bd11502b019a64b9e806261ce03d723a" translate="yes" xml:space="preserve">
          <source>constant - Perl pragma to declare constants</source>
          <target state="translated">constant-用于声明常量的Perl pragma。</target>
        </trans-unit>
        <trans-unit id="e6d2f0631cda4d6efc629d2121169975c2ccdd85" translate="yes" xml:space="preserve">
          <source>constant.pm</source>
          <target state="translated">constant.pm</target>
        </trans-unit>
        <trans-unit id="3c68e852e576badaab4d5104094f39037265b3aa" translate="yes" xml:space="preserve">
          <source>constants are automatically imported when you make use of</source>
          <target state="translated">的时候,会自动导入常量。</target>
        </trans-unit>
        <trans-unit id="a8baf617ece3e924e80dcbb5e14b608a7dd0da91" translate="yes" xml:space="preserve">
          <source>construct, not just the empty search pattern. Therefore code written in Perl 5.10.0 or later that uses the // as the</source>
          <target state="translated">构造,而不仅仅是空的搜索模式。因此,在Perl 5.10.0或更高版本中编写的代码,如果使用//作为的</target>
        </trans-unit>
        <trans-unit id="8a1c1339801686eb9bf9a9ac5b4719b8c8b8fc9b" translate="yes" xml:space="preserve">
          <source>constructor</source>
          <target state="translated">constructor</target>
        </trans-unit>
        <trans-unit id="72e9a547fbb17beb5b5ea139f68f91eea1ed3e1d" translate="yes" xml:space="preserve">
          <source>cont</source>
          <target state="translated">cont</target>
        </trans-unit>
        <trans-unit id="c1380af48659113969e097bf1cb2bc27425f186c" translate="yes" xml:space="preserve">
          <source>contain</source>
          <target state="translated">contain</target>
        </trans-unit>
        <trans-unit id="9c625731c42e13cefcabbdf038f623268a8b2f8c" translate="yes" xml:space="preserve">
          <source>contain commands. For example:</source>
          <target state="translated">包含命令。例如:</target>
        </trans-unit>
        <trans-unit id="de33d2e14162941894fee180071f7586145848de" translate="yes" xml:space="preserve">
          <source>contain the &lt;code&gt;=&lt;/code&gt; prefix); this is needed only if the POD paragraph corresponds to a command paragraph. The &lt;code&gt;-file&lt;/code&gt; and &lt;code&gt;-line&lt;/code&gt; keywords indicate the filename and line number corresponding to the beginning of the paragraph</source>
          <target state="translated">包含 &lt;code&gt;=&lt;/code&gt; 前缀）; 仅当POD段落对应于命令段落时才需要。该 &lt;code&gt;-file&lt;/code&gt; 和 &lt;code&gt;-line&lt;/code&gt; 关键字指示对应于段落开头的文件名和行号</target>
        </trans-unit>
        <trans-unit id="c83f5eb7732c80efe1cb74cd7698cdb71a73ab40" translate="yes" xml:space="preserve">
          <source>containing the essentials of embedding:</source>
          <target state="translated">包含嵌入的要领。</target>
        </trans-unit>
        <trans-unit id="456759b7de9dffe0984565499992ad5c28e11f2a" translate="yes" xml:space="preserve">
          <source>contains a &lt;code&gt;$&lt;/code&gt; that looks like a variable rather than an end-of-string test, the variable will be interpolated into the pattern at run-time. If you want the pattern compiled only once the first time the variable is interpolated, use the &lt;code&gt;/o&lt;/code&gt; option. If the pattern evaluates to the empty string, the last successfully executed regular expression is used instead. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; for further explanation on these.</source>
          <target state="translated">包含一个看起来像变量而不是字符串结尾测试的 &lt;code&gt;$&lt;/code&gt; ，该变量将在运行时插入到模式中。如果您希望仅在第一次插入变量时才编译一次模式，请使用 &lt;code&gt;/o&lt;/code&gt; 选项。如果该模式的结果为空字符串，则使用最后成功执行的正则表达式。有关&lt;a href=&quot;perlre&quot;&gt;这些&lt;/a&gt;的进一步说明，请参见perlre。</target>
        </trans-unit>
        <trans-unit id="2e9fc2513d38b23de077e16ef771bb5e1ba313ee" translate="yes" xml:space="preserve">
          <source>contains a number of functions which produce formatted output of internal data structures.</source>
          <target state="translated">包含了许多函数,这些函数可以产生内部数据结构的格式化输出。</target>
        </trans-unit>
        <trans-unit id="97d9b2d523ae7c08e42a0378f3168116fd6ac99b" translate="yes" xml:space="preserve">
          <source>contains a third array element, after the range boundary ones: the old_style block name.)</source>
          <target state="translated">包含第三个数组元素,在范围边界的元素之后:老式块名)。)</target>
        </trans-unit>
        <trans-unit id="1e39f4d34160a0c98c4ecb1c728c648cc593c34a" translate="yes" xml:space="preserve">
          <source>contains a third array element, after the range boundary ones: the script name.)</source>
          <target state="translated">包含第三个数组元素,在范围边界的元素之后:脚本名称)。)</target>
        </trans-unit>
        <trans-unit id="41f54bb14132b493b92c26df5faa1d294b7aa12c" translate="yes" xml:space="preserve">
          <source>contains all the elements of @foo followed by all the elements of @bar, followed by all the elements returned by the subroutine named SomeSub called in list context, followed by the key/value pairs of %glarch. To make a list reference that does</source>
          <target state="translated">包含@foo的所有元素,然后是@bar的所有元素,接着是在列表上下文中调用的名为SomeSub的子程序返回的所有元素,然后是%glarch的键/值对。要使一个列表引用做到</target>
        </trans-unit>
        <trans-unit id="3cb4fa0e628428cfb9b4db01087a9f5db68ecf38" translate="yes" xml:space="preserve">
          <source>contains all the system-specific functions,</source>
          <target state="translated">包含所有的系统专用功能。</target>
        </trans-unit>
        <trans-unit id="b4a3e3041113fdd1bddf95caa788a8fa6500be88" translate="yes" xml:space="preserve">
          <source>contains any special folding for Turkic languages. For versions of Unicode starting with 3.2, this field is empty unless</source>
          <target state="translated">包含任何突厥语的特殊折叠。对于从3.2开始的Unicode版本,该字段为空,除非</target>
        </trans-unit>
        <trans-unit id="f682a5e2bacce4b727dd6835165db3a42c0490c7" translate="yes" xml:space="preserve">
          <source>contains everything else. These are, if you like, the C code for Perl's built-in functions and operators.</source>
          <target state="translated">包含了其他所有的内容。如果你喜欢的话,这些是Perl内置函数和运算符的C代码。</target>
        </trans-unit>
        <trans-unit id="4364e65ad67e2e4441d43321c651e2cac9b760eb" translate="yes" xml:space="preserve">
          <source>contains our &lt;code&gt;rpcb_gettime()&lt;/code&gt; function:</source>
          <target state="translated">包含我们的 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="cc59e91f1f4fb80c6f16f33f295a9084147b614e" translate="yes" xml:space="preserve">
          <source>contains snippets of perl code which are intended to be benchmarked across a range of perls by the</source>
          <target state="translated">包含了一些perl代码的片段,这些代码的目的是为了在一系列perl中进行基准测试。</target>
        </trans-unit>
        <trans-unit id="1d22a5d352aa38186ed43bc2d343c65d9b9d7338" translate="yes" xml:space="preserve">
          <source>contains some helpful functions for writing tests valid on both ASCII and EBCDIC platforms. Sometimes, though, a test can't use a function and it's inconvenient to have different test versions depending on the platform. There are 20 code points that are the same in all 4 character sets currently recognized by Perl (the 3 EBCDIC code pages plus ISO 8859-1 (ASCII/Latin1)). These can be used in such tests, though there is a small possibility that Perl will become available in yet another character set, breaking your test. All but one of these code points are C0 control characters. The most significant controls that are the same are &lt;code&gt;\0&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; , and &lt;code&gt;\N{VT}&lt;/code&gt; (also specifiable as &lt;code&gt;\cK&lt;/code&gt; , &lt;code&gt;\x0B&lt;/code&gt; , &lt;code&gt;\N{U+0B}&lt;/code&gt; , or &lt;code&gt;\013&lt;/code&gt; ). The single non-control is U+00B6 PILCROW SIGN. The controls that are the same have the same bit pattern in all 4 character sets, regardless of the UTF8ness of the string containing them. The bit pattern for U+B6 is the same in all 4 for non-UTF8 strings, but differs in each when its containing string is UTF-8 encoded. The only other code points that have some sort of sameness across all 4 character sets are the pair 0xDC and 0xFC. Together these represent upper- and lowercase LATIN LETTER U WITH DIAERESIS, but which is upper and which is lower may be reversed: 0xDC is the capital in Latin1 and 0xFC is the small letter, while 0xFC is the capital in EBCDIC and 0xDC is the small one. This factoid may be exploited in writing case insensitive tests that are the same across all 4 character sets.</source>
          <target state="translated">包含一些有用的功能，用于编写在ASCII和EBCDIC平台上均有效的测试。但是，有时测试不能使用函数，并且根据平台使用不同的测试版本是很不方便的。 Perl当前可识别的所有4个字符集中有20个代码点相同（3个EBCDIC代码页以及ISO 8859-1（ASCII / Latin1））。这些可以用在这样的测试中，尽管极有可能Perl在另一个字符集中可用，从而破坏了您的测试。除了这些代码点之一以外，所有代码点都是C0控制字符。相同的最重要的控件是 &lt;code&gt;\0&lt;/code&gt; ， &lt;code&gt;\r&lt;/code&gt; 和 &lt;code&gt;\N{VT}&lt;/code&gt; （也可以指定为 &lt;code&gt;\cK&lt;/code&gt; ， &lt;code&gt;\x0B&lt;/code&gt; ， &lt;code&gt;\N{U+0B}&lt;/code&gt; 或 &lt;code&gt;\013&lt;/code&gt; ）。单个非控件是U + 00B6 PILCROW SIGN。相同的控件在所有4个字符集中都具有相同的位模式，而与包含它们的字符串的UTF8ness无关。对于非UTF8字符串，U + B6的位模式在所有4个方面都相同，但是当其包含的字符串经过UTF-8编码时，每个位模式都不同。在所有4个字符集上都具有某种相同性的唯一其他代码点是对0xDC和0xFC。它们一起代表带有DIAERESIS的大写和小写拉丁字母U，但大小写可能相反：0xDC是Latin1的大写字母，0xFC是小写字母，而0xFC是EBCDIC的大写字母，0xDC是小写字母之一。在编写对所有4个字符集都相同的不区分大小写的测试时，可以利用此事实。</target>
        </trans-unit>
        <trans-unit id="f9ecf591b48a021fcfa56b07f615c6fee077adcf" translate="yes" xml:space="preserve">
          <source>contains the &quot;hot&quot; code, which is most often used and highly optimized,</source>
          <target state="translated">包含 &quot;热门 &quot;代码,使用频率最高,优化程度最高。</target>
        </trans-unit>
        <trans-unit id="d2f0d0091560a93ac18a046dd74619847856144f" translate="yes" xml:space="preserve">
          <source>contains the &lt;code&gt;&quot;,&quot;&lt;/code&gt; or the &lt;code&gt;&quot;#&quot;&lt;/code&gt; character.</source>
          <target state="translated">包含 &lt;code&gt;&quot;,&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;#&quot;&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="181d5157c98ff403f168dc14c756ebcce30df2fb" translate="yes" xml:space="preserve">
          <source>contains the functions which implement control structures (&lt;code&gt;if&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; and the like) and</source>
          <target state="translated">包含实现控制结构的功能（ &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; 等），以及</target>
        </trans-unit>
        <trans-unit id="5306ca990f920ccf0b74788fb1427bedb68ab005" translate="yes" xml:space="preserve">
          <source>contains well-formed UTF-8. Returns true if successful, false otherwise.</source>
          <target state="translated">包含格式良好的UTF-8。如果成功返回true,否则返回false。</target>
        </trans-unit>
        <trans-unit id="872301ecc9b3c84467427470058935d7214561b0" translate="yes" xml:space="preserve">
          <source>contains.U</source>
          <target state="translated">contains.U</target>
        </trans-unit>
        <trans-unit id="137026ac560ad7653b25bdc20c97ee1bd7ece8f3" translate="yes" xml:space="preserve">
          <source>contains_pod( $file , $verbose )</source>
          <target state="translated">contains_pod($file,$verbose )</target>
        </trans-unit>
        <trans-unit id="ec2727b3b71f07635f726026bef44352ec89e452" translate="yes" xml:space="preserve">
          <source>context</source>
          <target state="translated">context</target>
        </trans-unit>
        <trans-unit id="a3eeca228bc889520c139930476789b402394dd2" translate="yes" xml:space="preserve">
          <source>context), you would do the following:</source>
          <target state="translated">上下文),你会做如下操作。</target>
        </trans-unit>
        <trans-unit id="5a99ed2f608eaf4f435e0115b942d1717c1469e7" translate="yes" xml:space="preserve">
          <source>context, the &lt;code&gt;$@&lt;/code&gt; variable is set. Accessing &lt;code&gt;$@-&amp;gt;{error}&lt;/code&gt; returns one of the error diagnostics listed below. Accessing &lt;code&gt;$@-&amp;gt;{pos}&lt;/code&gt; returns the offset into the original string at which the error was detected (although not necessarily where it occurred!) Printing &lt;code&gt;$@&lt;/code&gt; directly produces the error message, with the offset appended. On success, the &lt;code&gt;$@&lt;/code&gt; variable is guaranteed to be &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在上下文中，设置了 &lt;code&gt;$@&lt;/code&gt; 变量。访问 &lt;code&gt;$@-&amp;gt;{error}&lt;/code&gt; 返回下面列出的错误诊断之一。访问 &lt;code&gt;$@-&amp;gt;{pos}&lt;/code&gt; 会将偏移量返回到检测到错误的原始字符串中（尽管不一定在发生错误的位置！）打印 &lt;code&gt;$@&lt;/code&gt; 直接产生错误消息，并附加偏移量。成功后， &lt;code&gt;$@&lt;/code&gt; 变量将保证为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14700e97a4da0be29b50c0dae3132b7c369e29c6" translate="yes" xml:space="preserve">
          <source>contexts</source>
          <target state="translated">contexts</target>
        </trans-unit>
        <trans-unit id="39d550f280658b767ff7493844c3e30cdf5894bc" translate="yes" xml:space="preserve">
          <source>contexts from the actual types of its operands and uses that type information to select a suitable comparison mechanism.</source>
          <target state="translated">操作数的实际类型的上下文,并使用该类型信息选择合适的比较机制。</target>
        </trans-unit>
        <trans-unit id="f22d8d92136f354829a39361ebf819a0c87f2bda" translate="yes" xml:space="preserve">
          <source>contiguous whitespace (not just a single space character) is used as a separator. However, this special treatment can be avoided by specifying the pattern &lt;code&gt;/ /&lt;/code&gt; instead of the string &lt;code&gt;&quot; &quot;&lt;/code&gt; , thereby allowing only a single space character to be a separator. In earlier Perls this special case was restricted to the use of a plain &lt;code&gt;&quot; &quot;&lt;/code&gt; as the pattern argument to split, in Perl 5.18.0 and later this special case is triggered by any expression which evaluates as the simple string &lt;code&gt;&quot; &quot;&lt;/code&gt; .</source>
          <target state="translated">连续的空格（不只是单个空格字符）用作分隔符。但是，可以通过指定模式 &lt;code&gt;/ /&lt;/code&gt; 而不是字符串 &lt;code&gt;&quot; &quot;&lt;/code&gt; 来避免这种特殊处理，从而仅允许将单个空格字符用作分隔符。在早期的Perls中，这种特殊情况仅限于使用纯 &lt;code&gt;&quot; &quot;&lt;/code&gt; 作为split的模式参数，在Perl 5.18.0中，后来，这种特殊情况由任何计算为简单字符串 &lt;code&gt;&quot; &quot;&lt;/code&gt; 表达式触发。</target>
        </trans-unit>
        <trans-unit id="78a343b7196ffacef4e4111d72721d860fab69a6" translate="yes" xml:space="preserve">
          <source>contiguous. It still leaves the matching position after the here document, but now the rest of the line on which the here document starts is not skipped.</source>
          <target state="translated">相连。它仍然将匹配的位置留在 here 文档之后,但现在 here 文档开始的其余行不会被跳过。</target>
        </trans-unit>
        <trans-unit id="eee0bbba4ff92adbeb038a77df0466d660f15716" translate="yes" xml:space="preserve">
          <source>continue</source>
          <target state="translated">continue</target>
        </trans-unit>
        <trans-unit id="d621f977fc5b4a596a11f857850602ac8b190701" translate="yes" xml:space="preserve">
          <source>continue BLOCK</source>
          <target state="translated">继续BLOCK</target>
        </trans-unit>
        <trans-unit id="633cbbb1b27b0398b3ca7eb06922aad56d751b9c" translate="yes" xml:space="preserve">
          <source>controlling program, instead of</source>
          <target state="translated">控制程序,而不是</target>
        </trans-unit>
        <trans-unit id="4719418f83051cf6557dbd49eac79ed5514925b0" translate="yes" xml:space="preserve">
          <source>conversion functions do croak() on bad arguments.) It is therefore essential to check return values from these functions. Always begin your socket programs this way for optimal success, and don't forget to add the &lt;b&gt;-T&lt;/b&gt; taint-checking flag to the &lt;code&gt;#!&lt;/code&gt; line for servers:</source>
          <target state="translated">转换函数对错误的参数执行croak（）。）因此，必须检查这些函数的返回值。始终以这种方式启动套接字程序以获得最佳成功，并且不要忘记将&lt;b&gt;-T&lt;/b&gt; taint-checking标志添加到 &lt;code&gt;#!&lt;/code&gt; 服务器行：</target>
        </trans-unit>
        <trans-unit id="2484757b822d6a8ec055551756531c20c9545487" translate="yes" xml:space="preserve">
          <source>converts C header files into XS modules, and will try and write as much glue between C libraries and Perl modules as it can. It's also very useful for creating skeletons of pure Perl modules.</source>
          <target state="translated">将 C 头文件转换为 XS 模块,并将尽量在 C 库和 Perl 模块之间编写胶水。它对于创建纯 Perl 模块的骨架也非常有用。</target>
        </trans-unit>
        <trans-unit id="e236c7fcc533441e580388a48ee6c1eb0630aba6" translate="yes" xml:space="preserve">
          <source>converts a string representing a binary number to numeric form.</source>
          <target state="translated">将代表二进制数的字符串转换为数字形式。</target>
        </trans-unit>
        <trans-unit id="98a8e6a8b2996b6a160c2a27faefcd5e98e76254" translate="yes" xml:space="preserve">
          <source>converts a string representing a hex number to numeric form.</source>
          <target state="translated">将代表十六进制数的字符串转换为数字形式。</target>
        </trans-unit>
        <trans-unit id="5372738b9637da96901885d0e698d1fa85c1d7b9" translate="yes" xml:space="preserve">
          <source>converts a string representing an octal number to numeric form.</source>
          <target state="translated">将代表八进制数的字符串转换为数字形式。</target>
        </trans-unit>
        <trans-unit id="a4a102f879e8471e55679daf6e698de673ddb16e" translate="yes" xml:space="preserve">
          <source>converts any C header files specified to the corresponding Perl header file format. It is most easily run while in /usr/include:</source>
          <target state="translated">将任何指定的 C 头文件转换为相应的 Perl 头文件格式。它最容易在/usr/include中运行。</target>
        </trans-unit>
        <trans-unit id="34338ec9943dcbf6124b0147f1de16a04c24de3a" translate="yes" xml:space="preserve">
          <source>coordinate and the</source>
          <target state="translated">统筹兼顾</target>
        </trans-unit>
        <trans-unit id="b8350600f526d289bd9e95c43cde8ce328e85c2a" translate="yes" xml:space="preserve">
          <source>coordinate. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">坐标。另请参见&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00f75dd8d6816b55dfa981aea23c36226a3c13f4" translate="yes" xml:space="preserve">
          <source>coordinate. The North Pole is therefore</source>
          <target state="translated">坐标。因此,北极是</target>
        </trans-unit>
        <trans-unit id="4bee6a29c81fb6cfb3f0ccd73759d5d7493123ac" translate="yes" xml:space="preserve">
          <source>coordinate. The angle from the</source>
          <target state="translated">坐标。角度从</target>
        </trans-unit>
        <trans-unit id="98d9e552ccd124aa232a89d1b97e68700b00c141" translate="yes" xml:space="preserve">
          <source>coordinate. The angle in the</source>
          <target state="translated">坐标。中的角度。</target>
        </trans-unit>
        <trans-unit id="c7c925e009e4517e71ee344e00311a6353973c12" translate="yes" xml:space="preserve">
          <source>coordinate. The third coordinate is the</source>
          <target state="translated">坐标。第三个坐标是</target>
        </trans-unit>
        <trans-unit id="3bb4096cd3e137920b80365c7ccb27f9ced60fe0" translate="yes" xml:space="preserve">
          <source>cop</source>
          <target state="translated">cop</target>
        </trans-unit>
        <trans-unit id="d6add04179c575e90ca0cfb2394dcf612938b72b" translate="yes" xml:space="preserve">
          <source>cophh</source>
          <target state="translated">cophh</target>
        </trans-unit>
        <trans-unit id="475f96eca831d080a0c1c4e82e61660869fdbccd" translate="yes" xml:space="preserve">
          <source>copies</source>
          <target state="translated">copies</target>
        </trans-unit>
        <trans-unit id="f84e2e2dadd87384fb55f25886926b777e8378f1" translate="yes" xml:space="preserve">
          <source>copy</source>
          <target state="translated">copy</target>
        </trans-unit>
        <trans-unit id="2485b57e49793f529fb0cc34d378ecf20efb1a78" translate="yes" xml:space="preserve">
          <source>copy of</source>
          <target state="translated">复本</target>
        </trans-unit>
        <trans-unit id="ec49698ab3e07f7975d6068f30b75f21078351f3" translate="yes" xml:space="preserve">
          <source>copy of the Perl stack pointer.</source>
          <target state="translated">Perl栈指针的副本。</target>
        </trans-unit>
        <trans-unit id="2b2ed0922e5c552c1298785802c663d39da798ea" translate="yes" xml:space="preserve">
          <source>copy()</source>
          <target state="translated">copy()</target>
        </trans-unit>
        <trans-unit id="fd55385eb48f393c84c0b727ea5b123b7df43771" translate="yes" xml:space="preserve">
          <source>corelist</source>
          <target state="translated">corelist</target>
        </trans-unit>
        <trans-unit id="6939cd5fb17cf5658056113938aafea0e6ed75d1" translate="yes" xml:space="preserve">
          <source>corelist - a commandline frontend to Module::CoreList</source>
          <target state="translated">corelist-Module::CoreList的命令行前端。</target>
        </trans-unit>
        <trans-unit id="18040567b4508fbf83110e29def8c8ebc92b5480" translate="yes" xml:space="preserve">
          <source>correctly</source>
          <target state="translated">correctly</target>
        </trans-unit>
        <trans-unit id="5e3a2e46e91ed1c6b53b5b890370200bef1a2e60" translate="yes" xml:space="preserve">
          <source>corresponding to</source>
          <target state="translated">与...相对应</target>
        </trans-unit>
        <trans-unit id="e7a40ef5b5a7db27987f7449f599734f590378ab" translate="yes" xml:space="preserve">
          <source>correspondingly, you need to hand-edit</source>
          <target state="translated">相应地,你需要手工编辑</target>
        </trans-unit>
        <trans-unit id="5bcc2c4d81811ed80bdd75460668f2bc84ab2137" translate="yes" xml:space="preserve">
          <source>cos</source>
          <target state="translated">cos</target>
        </trans-unit>
        <trans-unit id="2b1ed3a70ed16bc27d8adf2da5017ab39b17af11" translate="yes" xml:space="preserve">
          <source>cos EXPR</source>
          <target state="translated">cos EXPR</target>
        </trans-unit>
        <trans-unit id="81dbf9771ca0e4359f0827ba522d0d5e08233012" translate="yes" xml:space="preserve">
          <source>cosec</source>
          <target state="translated">cosec</target>
        </trans-unit>
        <trans-unit id="d3d979ce266c12a742c772be86181f1a30419190" translate="yes" xml:space="preserve">
          <source>cosech</source>
          <target state="translated">cosech</target>
        </trans-unit>
        <trans-unit id="7fd2e982067b387f73dcb93cf080fe66cc2f33b3" translate="yes" xml:space="preserve">
          <source>cot</source>
          <target state="translated">cot</target>
        </trans-unit>
        <trans-unit id="2f723208a5459ef4be350e5486eb56c7c5225202" translate="yes" xml:space="preserve">
          <source>cotan</source>
          <target state="translated">cotan</target>
        </trans-unit>
        <trans-unit id="c3c86eb1ad84347701cf3c00659f271340a34ef2" translate="yes" xml:space="preserve">
          <source>cotanh</source>
          <target state="translated">cotanh</target>
        </trans-unit>
        <trans-unit id="90deb50615027dd3aaf70c6323942dc959e1b32b" translate="yes" xml:space="preserve">
          <source>coth</source>
          <target state="translated">coth</target>
        </trans-unit>
        <trans-unit id="e30de8fdbd3f2502c1d3f32cf7288b3caecc93ee" translate="yes" xml:space="preserve">
          <source>could</source>
          <target state="translated">could</target>
        </trans-unit>
        <trans-unit id="c91c97e310f7b524f0d2829665eb1979e5325553" translate="yes" xml:space="preserve">
          <source>could (unless a method is specifically declared for the key &lt;code&gt;'+'&lt;/code&gt; ) result in a call</source>
          <target state="translated">可能（除非为键 &lt;code&gt;'+'&lt;/code&gt; 专门声明了一个方法）导致调用</target>
        </trans-unit>
        <trans-unit id="c4e5b9a873cc7a9940fe960e094beba494d78f0b" translate="yes" xml:space="preserve">
          <source>could potentially trigger two filters, one for the writing of the key &quot;abc&quot; and another for writing the value 42. Similarly, this snippet</source>
          <target state="translated">可能会触发两个过滤器,一个用于写入键 &quot;abc&quot;,另一个用于写入值42。同样,这个片段</target>
        </trans-unit>
        <trans-unit id="ee9f38e186ba06f57b7b74d7e626b94e13ce2556" translate="yes" xml:space="preserve">
          <source>count</source>
          <target state="translated">count</target>
        </trans-unit>
        <trans-unit id="fc9ec9f65f5ff87c03a0a80c679c8eb98ebd144d" translate="yes" xml:space="preserve">
          <source>count as a loop, so the loop control statements &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; cannot be used to leave or restart the block.</source>
          <target state="translated">算作一个循环，因此循环控制语句 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 不能用于离开或重新启动该块。</target>
        </trans-unit>
        <trans-unit id="3749c0e3ee6fcca3254e89b8c05bafb50b5016eb" translate="yes" xml:space="preserve">
          <source>count as a loop, so the loop control statements &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; cannot be used to leave or restart the block. See &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; for alternative strategies.</source>
          <target state="translated">算作一个循环，因此循环控制语句 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 不能用于离开或重新启动该块。有关替代策略，请参见&lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17283885133328f25c078ae27e90aa6cfec56752" translate="yes" xml:space="preserve">
          <source>count as a loop, so the loop control statements &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; cannot be used to leave or restart the block.</source>
          <target state="translated">算作一个循环，因此循环控制语句 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 不能用于离开或重新启动该块。</target>
        </trans-unit>
        <trans-unit id="41f6af29328830a1db9688bf89de226db6f277ef" translate="yes" xml:space="preserve">
          <source>count as a loop, so the loop control statements &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; cannot be used to leave or restart the block. See &lt;a href=&quot;../perlsyn&quot;&gt;perlsyn&lt;/a&gt; for alternative strategies.</source>
          <target state="translated">算作一个循环，因此循环控制语句 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 不能用于离开或重新启动该块。有关替代策略，请参见&lt;a href=&quot;../perlsyn&quot;&gt;perlsyn&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3510fce2f9f8ca88fafa9cc2ae095cb6652b3285" translate="yes" xml:space="preserve">
          <source>count as loops.) The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block is optional.</source>
          <target state="translated">计数为循环。） &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块是可选的。</target>
        </trans-unit>
        <trans-unit id="733232300c7b6972b9008fb62af14d73e8001245" translate="yes" xml:space="preserve">
          <source>countit - see how many times a chunk of code runs in a given time</source>
          <target state="translated">countit-在给定的时间内,查看代码块运行的次数。</target>
        </trans-unit>
        <trans-unit id="8e68b3e5af636475363c23b52ade8e6064b05806" translate="yes" xml:space="preserve">
          <source>country</source>
          <target state="translated">country</target>
        </trans-unit>
        <trans-unit id="3f81e91d69a8a61ffbf19297eb0791ad54ce5690" translate="yes" xml:space="preserve">
          <source>cp</source>
          <target state="translated">cp</target>
        </trans-unit>
        <trans-unit id="59f869352b368644ee4b1686961cc9d943046b55" translate="yes" xml:space="preserve">
          <source>cpan</source>
          <target state="translated">cpan</target>
        </trans-unit>
        <trans-unit id="9e1e6e1e3374e4b1819e5a93071779728c67e76c" translate="yes" xml:space="preserve">
          <source>cpan/</source>
          <target state="translated">cpan/</target>
        </trans-unit>
        <trans-unit id="646081900f2ce796c13fdf0ec5c1c6d5a28019e6" translate="yes" xml:space="preserve">
          <source>cpan/HTTP-Tiny/t/110_mirror.t</source>
          <target state="translated">cpan/HTTP-Tiny/t/110_mirror.t</target>
        </trans-unit>
        <trans-unit id="da2ffe1e8ff32f669a8b365d03c6e3a6cc22fde8" translate="yes" xml:space="preserve">
          <source>cpd (&lt;a href=&quot;http://pmd.sourceforge.net/cpd.html&quot;&gt;http://pmd.sourceforge.net/cpd.html&lt;/a&gt;) is part of the pmd project (&lt;a href=&quot;http://pmd.sourceforge.net/&quot;&gt;http://pmd.sourceforge.net/&lt;/a&gt;). pmd was originally written for static analysis of Java code, but later the cpd part of it was extended to parse also C and C++.</source>
          <target state="translated">cpd（&lt;a href=&quot;http://pmd.sourceforge.net/cpd.html&quot;&gt;http://pmd.sourceforge.net/cpd.html&lt;/a&gt;）是pmd项目（&lt;a href=&quot;http://pmd.sourceforge.net/&quot;&gt;http://pmd.sourceforge.net/&lt;/a&gt;）的一部分。pmd最初是为Java代码的静态分析而编写的，但是后来cpd部分扩展为也可以解析C和C ++。</target>
        </trans-unit>
        <trans-unit id="3f13690d9f78c0dd3b78cc56249d1342a0762ff6" translate="yes" xml:space="preserve">
          <source>cpd (cut-and-paste detector)</source>
          <target state="translated">粘贴检测器</target>
        </trans-unit>
        <trans-unit id="edd9a349011f4725e482bc6bc145ec92ab109a82" translate="yes" xml:space="preserve">
          <source>cpp</source>
          <target state="translated">cpp</target>
        </trans-unit>
        <trans-unit id="0cd0c956de252609d33214e77f1d31c75fc11ba3" translate="yes" xml:space="preserve">
          <source>cpp_stuff.U</source>
          <target state="translated">cpp_stuff.U</target>
        </trans-unit>
        <trans-unit id="b2167df3c1c60dd7ad51bbf712d081b717ca8ed1" translate="yes" xml:space="preserve">
          <source>cppstdin.U</source>
          <target state="translated">cppstdin.U</target>
        </trans-unit>
        <trans-unit id="05531e92a060a8064db013666efa6357dae24486" translate="yes" xml:space="preserve">
          <source>create a local variable. This is known as dynamic scoping. Lexical scoping is done with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, which works more like C's auto declarations.</source>
          <target state="translated">创建一个局部变量。这称为动态作用域。用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 完成词法作用域，它的工作方式更像C的自动声明。</target>
        </trans-unit>
        <trans-unit id="5b435cb4670fb9989f690757d28c921e069705ff" translate="yes" xml:space="preserve">
          <source>create the key.</source>
          <target state="translated">创建密钥。</target>
        </trans-unit>
        <trans-unit id="d879e705f27e6b66619d4dafc1be673760766192" translate="yes" xml:space="preserve">
          <source>create the smallest possible gzip header (exactly 10 bytes). If you want greater control over what gets stored in the gzip header (like the original filename or a comment) use &lt;a href=&quot;../io/compress/gzip&quot;&gt;IO::Compress::Gzip&lt;/a&gt; instead. Similarly if you want to read the contents of the gzip header use &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt;.</source>
          <target state="translated">创建最小的gzip标头（恰好10个字节）。如果要更好地控制gzip标头中存储的内容（例如原始文件名或注释），请使用&lt;a href=&quot;../io/compress/gzip&quot;&gt;IO :: Compress :: Gzip&lt;/a&gt;。同样，如果您想读取gzip标头的内容，请使用&lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO :: Uncompress :: Gunzip&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4c0122a517eca9362fb442b1949b747aabd4734" translate="yes" xml:space="preserve">
          <source>creates a whole new symbol table entry for the glob &lt;code&gt;name&lt;/code&gt; in the current package. That means that all variables in its glob slot ($name, @name, %name, &amp;amp;name, and the &lt;code&gt;name&lt;/code&gt; filehandle) are dynamically reset.</source>
          <target state="translated">为当前包中的全局 &lt;code&gt;name&lt;/code&gt; 创建一个全新的符号表条目。这意味着其全局槽中的所有变量（$ name，@ name，％name，＆name和 &lt;code&gt;name&lt;/code&gt; filehandle）都将动态重置。</target>
        </trans-unit>
        <trans-unit id="4c6bb7dcb5125acb8022bbc170655e676dfc2515" translate="yes" xml:space="preserve">
          <source>creates actually a Math::BigInt and stores a reference to in $x. This happens transparently and behind your back, so to speak.</source>
          <target state="translated">实际上创建了一个Math::BigInt并在$x中存储了一个引用。可以说,这一切都发生在透明的背后。</target>
        </trans-unit>
        <trans-unit id="4798abd80e0d4f05a5b14a2ff80d235983b66cbf" translate="yes" xml:space="preserve">
          <source>creates an &quot;:all&quot; tag which contains some (but not really all) of its categories. That could be done with one small change:</source>
          <target state="translated">创建了一个&quot;:all &quot;标签,其中包含了一些(但不是全部)类别。这可以通过一个小改动来实现。</target>
        </trans-unit>
        <trans-unit id="bca47fd52c3a4de99dd9e93e28f23b793fa83105" translate="yes" xml:space="preserve">
          <source>creates an attribute handler that applies only to scalars:</source>
          <target state="translated">创建一个只适用于标量的属性处理程序。</target>
        </trans-unit>
        <trans-unit id="d57bdd2b468c862463f2a2f2034aa2d9abf553f8" translate="yes" xml:space="preserve">
          <source>creates two scopes: the first starts at the &lt;code&gt;(&lt;/code&gt; and has &lt;code&gt;full == 1&lt;/code&gt; , the second starts at the &lt;code&gt;{&lt;/code&gt; and has &lt;code&gt;full == 0&lt;/code&gt; . Both end at the &lt;code&gt;}&lt;/code&gt;, so calls to &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;pre/post_end&lt;/code&gt; will match. Anything pushed onto the save stack by this hook will be popped just before the scope ends (between the &lt;code&gt;pre_&lt;/code&gt; and &lt;code&gt;post_end&lt;/code&gt; hooks, in fact).</source>
          <target state="translated">创建两个范围：第一个范围从 &lt;code&gt;(&lt;/code&gt; 且具有 &lt;code&gt;full == 1&lt;/code&gt; 开始，第二个范围从 &lt;code&gt;{&lt;/code&gt; 且具有 &lt;code&gt;full == 0&lt;/code&gt; 两者都在 &lt;code&gt;}&lt;/code&gt; 结束，因此对 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;pre/post_end&lt;/code&gt; 的调用将匹配。堆叠由该钩子节省将被弹出只是范围结束之前（在之间 &lt;code&gt;pre_&lt;/code&gt; 和 &lt;code&gt;post_end&lt;/code&gt; 钩，其实）。</target>
        </trans-unit>
        <trans-unit id="106df19f3461a102c7f9ca426d90c7b79a74fdda" translate="yes" xml:space="preserve">
          <source>croak in a statement that looks like it would modify a numbered capture variable. This is because the STORE callback will not be called if Perl can determine that it doesn't have to modify the value. This is exactly how tied variables behave in the same situation:</source>
          <target state="translated">呱呱坠地的语句,看起来像是要修改一个编号的捕获变量。这是因为,如果Perl能够确定不需要修改值,那么STORE回调就不会被调用。这正是绑定变量在相同情况下的表现。</target>
        </trans-unit>
        <trans-unit id="02f919145acd5795f2be3b610280992c94482221" translate="yes" xml:space="preserve">
          <source>cron</source>
          <target state="translated">cron</target>
        </trans-unit>
        <trans-unit id="8bfe65513ae6e6a1af42c06d65fe37c9eec15df8" translate="yes" xml:space="preserve">
          <source>crypt</source>
          <target state="translated">crypt</target>
        </trans-unit>
        <trans-unit id="2e9f48352e9b455bb12c45023163ec783d4a7204" translate="yes" xml:space="preserve">
          <source>crypt PLAINTEXT,SALT</source>
          <target state="translated">隐语PLAINTEXT,SALT</target>
        </trans-unit>
        <trans-unit id="c168a1a2ae6f569e7911794fb27f81843b3d2e7c" translate="yes" xml:space="preserve">
          <source>crypt() is a one-way hash function. The PLAINTEXT and SALT are turned into a short string, called a digest, which is returned. The same PLAINTEXT and SALT will always return the same string, but there is no (known) way to get the original PLAINTEXT from the hash. Small changes in the PLAINTEXT or SALT will result in large changes in the digest.</source>
          <target state="translated">crypt()是一个单向的哈希函数。PLAINTEXT和SALT被转化为一个短字符串,称为摘要,然后返回。相同的PLAINTEXT和SALT总是返回相同的字符串,但是没有(已知的)方法可以从哈希中得到原始PLAINTEXT。PLAINTEXT或SALT的微小变化将导致摘要的巨大变化。</target>
        </trans-unit>
        <trans-unit id="7018d9174fb00aaa4b853b352d90b923967ab4c7" translate="yes" xml:space="preserve">
          <source>csc</source>
          <target state="translated">csc</target>
        </trans-unit>
        <trans-unit id="d001689ac62cfb0c04a33b16bc1a20d965db399d" translate="yes" xml:space="preserve">
          <source>csch</source>
          <target state="translated">csch</target>
        </trans-unit>
        <trans-unit id="9145a3ad32249e3a113e52d2384b4bf1bb0f3b0f" translate="yes" xml:space="preserve">
          <source>csh</source>
          <target state="translated">csh</target>
        </trans-unit>
        <trans-unit id="6f2d5fee544562755bbcf3f39a480587ba3e49de" translate="yes" xml:space="preserve">
          <source>csh.</source>
          <target state="translated">csh.</target>
        </trans-unit>
        <trans-unit id="9f370c9afd3aed9749f78e294406ff5164e18595" translate="yes" xml:space="preserve">
          <source>ctal or</source>
          <target state="translated">CTAL或</target>
        </trans-unit>
        <trans-unit id="5f4562d4088fad27768c94dfe632c1866009d23f" translate="yes" xml:space="preserve">
          <source>ctal.</source>
          <target state="translated">ctal.</target>
        </trans-unit>
        <trans-unit id="15128f80670b2bc00473a6c2266e24162cc364d7" translate="yes" xml:space="preserve">
          <source>ctime is creation time instead of inode change time (Win32).</source>
          <target state="translated">ctime是创建时间,而不是inode变化时间(Win32)。</target>
        </trans-unit>
        <trans-unit id="6d9f092f5f236a35c5ae0f61df532a58b8a5856d" translate="yes" xml:space="preserve">
          <source>ctime not supported on UFS (Mac OS X).</source>
          <target state="translated">在UFS(Mac OS X)上不支持ctime。</target>
        </trans-unit>
        <trans-unit id="afd17208ab8f7e8b347263da2865b7a7432cfe97" translate="yes" xml:space="preserve">
          <source>ctype.h</source>
          <target state="translated">ctype.h</target>
        </trans-unit>
        <trans-unit id="405ab5d2b930fe3725b3cb1ace051f9fd3d6d7af" translate="yes" xml:space="preserve">
          <source>current</source>
          <target state="translated">current</target>
        </trans-unit>
        <trans-unit id="0a10abed0be29396c6db539c6d3b8235c97ddd65" translate="yes" xml:space="preserve">
          <source>currently: &lt;code&gt;env perl perlconfig distribution module&lt;/code&gt;</source>
          <target state="translated">当前： &lt;code&gt;env perl perlconfig distribution module&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="164c4a27d71c04134780d4cd2d452b4e9e4ddc96" translate="yes" xml:space="preserve">
          <source>cv</source>
          <target state="translated">cv</target>
        </trans-unit>
        <trans-unit id="7106c803ab38fc8e5b1f7fcaf0a665e51f9ca591" translate="yes" xml:space="preserve">
          <source>cvop</source>
          <target state="translated">cvop</target>
        </trans-unit>
        <trans-unit id="abfaabafddc502f22c9572e8c2d4f5674605a2e3" translate="yes" xml:space="preserve">
          <source>cvtres.exe is required by link.exe when using a .res file. It is actually installed by the .NET Framework SDK, but into a location such as the following:</source>
          <target state="translated">cvtres.exe是link.exe在使用.res文件时需要的。它实际上是由.NET框架SDK安装的,但安装在如下位置。</target>
        </trans-unit>
        <trans-unit id="d7320b31283ac19028bafe9886b5c221e881502c" translate="yes" xml:space="preserve">
          <source>cygperl5_16.dll</source>
          <target state="translated">cygperl5_16.dll</target>
        </trans-unit>
        <trans-unit id="3c363836cf4e16666669a25da280a1865c2d2874" translate="yes" xml:space="preserve">
          <source>d</source>
          <target state="translated">d</target>
        </trans-unit>
        <trans-unit id="5a759e9449eca397b4585e1d1fd9b348a4b515c8" translate="yes" xml:space="preserve">
          <source>d_Gconvert may be set to override Configure with a platform- specific function. If this function expects a double, a different value may need to be set by the</source>
          <target state="translated">d_Gconvert可以被设置为用平台特定的函数覆盖Configure。如果这个函数期望的是一个双倍值,那么可能需要由</target>
        </trans-unit>
        <trans-unit id="57313aa0d699891b715baa76c501717862f9c6ae" translate="yes" xml:space="preserve">
          <source>d__fwalk.U</source>
          <target state="translated">d__fwalk.U</target>
        </trans-unit>
        <trans-unit id="a4e7f21386f87ef7c1fd0bc35839b32956f597ec" translate="yes" xml:space="preserve">
          <source>d_access.U</source>
          <target state="translated">d_access.U</target>
        </trans-unit>
        <trans-unit id="55d1006684186b7f8e4a0296bae13f4d59c698ba" translate="yes" xml:space="preserve">
          <source>d_accessx.U</source>
          <target state="translated">d_accessx.U</target>
        </trans-unit>
        <trans-unit id="f0ac6b80d23bd77f6d1cc41b1150ffa39c8bbd6d" translate="yes" xml:space="preserve">
          <source>d_acosh.U</source>
          <target state="translated">d_acosh.U</target>
        </trans-unit>
        <trans-unit id="e7115d5159a72e108ad2694b5058ae288dbd52ba" translate="yes" xml:space="preserve">
          <source>d_aintl.U</source>
          <target state="translated">d_aintl.U</target>
        </trans-unit>
        <trans-unit id="74e588dce9c20c0ce8b36c50bc9a8abcd82a9cb3" translate="yes" xml:space="preserve">
          <source>d_alarm.U</source>
          <target state="translated">d_alarm.U</target>
        </trans-unit>
        <trans-unit id="e399057ffbf3bc0a7916547e9fe6d684ec5cfbf6" translate="yes" xml:space="preserve">
          <source>d_asctime_r.U</source>
          <target state="translated">d_asctime_r.U</target>
        </trans-unit>
        <trans-unit id="960f4add2a90547dc4a813983796203f792628ba" translate="yes" xml:space="preserve">
          <source>d_asinh.U</source>
          <target state="translated">d_asinh.U</target>
        </trans-unit>
        <trans-unit id="a104bd29e39a6aa3e752e1b96addb8ee0f926c26" translate="yes" xml:space="preserve">
          <source>d_atanh.U</source>
          <target state="translated">d_atanh.U</target>
        </trans-unit>
        <trans-unit id="692961e7ed99fa81d62f7536cdf07041fca461dc" translate="yes" xml:space="preserve">
          <source>d_attribut.U</source>
          <target state="translated">d_attribut.U</target>
        </trans-unit>
        <trans-unit id="d40cb034029d16e288606608d915dc6053d51b4d" translate="yes" xml:space="preserve">
          <source>d_backtrace.U</source>
          <target state="translated">d_backtrace.U</target>
        </trans-unit>
        <trans-unit id="cc09486a2f879d7de8991447737e785fb34512a6" translate="yes" xml:space="preserve">
          <source>d_bcmp.U</source>
          <target state="translated">d_bcmp.U</target>
        </trans-unit>
        <trans-unit id="ad52dfebd88fc782f319e91b8b070086f211ae28" translate="yes" xml:space="preserve">
          <source>d_bcopy.U</source>
          <target state="translated">d_bcopy.U</target>
        </trans-unit>
        <trans-unit id="958f6501addd2ca788581076a3b3089c9de1ccba" translate="yes" xml:space="preserve">
          <source>d_builtin.U</source>
          <target state="translated">d_builtin.U</target>
        </trans-unit>
        <trans-unit id="20266f9d23cc1bc712c1a68ac610c61138e4638d" translate="yes" xml:space="preserve">
          <source>d_bzero.U</source>
          <target state="translated">d_bzero.U</target>
        </trans-unit>
        <trans-unit id="ed980090902be825976ad473dd5d4dad7617db35" translate="yes" xml:space="preserve">
          <source>d_c99_variadic.U</source>
          <target state="translated">d_c99_variadic.U</target>
        </trans-unit>
        <trans-unit id="fae4d570397d90f5dec89977b7518f4a7571d055" translate="yes" xml:space="preserve">
          <source>d_casti32.U</source>
          <target state="translated">d_casti32.U</target>
        </trans-unit>
        <trans-unit id="2b5e95decd991782af20944a92f99bb839f14f6c" translate="yes" xml:space="preserve">
          <source>d_castneg.U</source>
          <target state="translated">d_castneg.U</target>
        </trans-unit>
        <trans-unit id="493c53c40edb5db35bc603adfb0c93e294c6cf88" translate="yes" xml:space="preserve">
          <source>d_cbrt.U</source>
          <target state="translated">d_cbrt.U</target>
        </trans-unit>
        <trans-unit id="096a16031618c5dd59672db5de5eff608e1f3cb5" translate="yes" xml:space="preserve">
          <source>d_chown.U</source>
          <target state="translated">d_chown.U</target>
        </trans-unit>
        <trans-unit id="9a038a94e7db4150d0f58dd7f0edd90655dfe30e" translate="yes" xml:space="preserve">
          <source>d_chroot.U</source>
          <target state="translated">d_chroot.U</target>
        </trans-unit>
        <trans-unit id="b63c9627d098800d39ca40d697baf6d74476ebed" translate="yes" xml:space="preserve">
          <source>d_chsize.U</source>
          <target state="translated">d_chsize.U</target>
        </trans-unit>
        <trans-unit id="2ec85552d337dc9808e0410fde95da5d171631a8" translate="yes" xml:space="preserve">
          <source>d_class.U</source>
          <target state="translated">d_class.U</target>
        </trans-unit>
        <trans-unit id="b185e845711e08e036f4c616de54061b9546d20d" translate="yes" xml:space="preserve">
          <source>d_clearenv.U</source>
          <target state="translated">d_clearenv.U</target>
        </trans-unit>
        <trans-unit id="acd2e806af8a8693e21daf3a329eed930ce1d325" translate="yes" xml:space="preserve">
          <source>d_closedir.U</source>
          <target state="translated">d_closedir.U</target>
        </trans-unit>
        <trans-unit id="6918c58efa254e6bb6ca8c3825bc9eb6691b1354" translate="yes" xml:space="preserve">
          <source>d_cmsghdr_s.U</source>
          <target state="translated">d_cmsghdr_s.U</target>
        </trans-unit>
        <trans-unit id="82c4ed0336662bd80e4b9d223e3c2ff08c0f41dd" translate="yes" xml:space="preserve">
          <source>d_const.U</source>
          <target state="translated">d_const.U</target>
        </trans-unit>
        <trans-unit id="49bbc34feebdae07d8bec84c5de2f4c7fb591013" translate="yes" xml:space="preserve">
          <source>d_copysign.U</source>
          <target state="translated">d_copysign.U</target>
        </trans-unit>
        <trans-unit id="14eab0a11fa1e7dd505766a6949ff148235e7edb" translate="yes" xml:space="preserve">
          <source>d_copysignl.U</source>
          <target state="translated">d_copysignl.U</target>
        </trans-unit>
        <trans-unit id="6e4b94074943964aa65ff528f782a9a5b1fe96d0" translate="yes" xml:space="preserve">
          <source>d_cplusplus.U</source>
          <target state="translated">d_cplusplus.U</target>
        </trans-unit>
        <trans-unit id="1f8b425b85071be6ae4eb7d90d16c31acea44894" translate="yes" xml:space="preserve">
          <source>d_crypt.U</source>
          <target state="translated">d_crypt.U</target>
        </trans-unit>
        <trans-unit id="f7ee9c6cf224c3cf855e386e20b51f79d4eaa09d" translate="yes" xml:space="preserve">
          <source>d_crypt_r.U</source>
          <target state="translated">d_crypt_r.U</target>
        </trans-unit>
        <trans-unit id="cb1c3f17fdc00bc8d95d1ed36bbc73bbd25793de" translate="yes" xml:space="preserve">
          <source>d_csh.U</source>
          <target state="translated">d_csh.U</target>
        </trans-unit>
        <trans-unit id="5ecf0bf5506f7396ee5905083306e938edeb3f6d" translate="yes" xml:space="preserve">
          <source>d_ctermid.U</source>
          <target state="translated">d_ctermid.U</target>
        </trans-unit>
        <trans-unit id="dcae0883ca9362a478ed33fc0081313700ba4e5b" translate="yes" xml:space="preserve">
          <source>d_ctermid_r.U</source>
          <target state="translated">d_ctermid_r.U</target>
        </trans-unit>
        <trans-unit id="357ec816bc42fd99a68703c6dc417f1677651e99" translate="yes" xml:space="preserve">
          <source>d_ctime_r.U</source>
          <target state="translated">d_ctime_r.U</target>
        </trans-unit>
        <trans-unit id="bc6de30e4a8656c49b91e07be9c2ab8894af2bdd" translate="yes" xml:space="preserve">
          <source>d_cuserid.U</source>
          <target state="translated">d_cuserid.U</target>
        </trans-unit>
        <trans-unit id="b17000e2ded681fcb95cca1e0526186f9b33f1e9" translate="yes" xml:space="preserve">
          <source>d_dbl_dig.U</source>
          <target state="translated">d_dbl_dig.U</target>
        </trans-unit>
        <trans-unit id="8612d4b652f2979932c96bf1ca7dc9200c76518f" translate="yes" xml:space="preserve">
          <source>d_dbminitproto.U</source>
          <target state="translated">d_dbminitproto.U</target>
        </trans-unit>
        <trans-unit id="c2bdd9db79207a03cc422db92662e779ef8dd059" translate="yes" xml:space="preserve">
          <source>d_difftime.U</source>
          <target state="translated">d_difftime.U</target>
        </trans-unit>
        <trans-unit id="1c20a8f3a68f3a097dc6878ac3805b74d9211bf1" translate="yes" xml:space="preserve">
          <source>d_dir_dd_fd.U</source>
          <target state="translated">d_dir_dd_fd.U</target>
        </trans-unit>
        <trans-unit id="ec159f1e0a73a594474fa6ae89c0a20579e39fc2" translate="yes" xml:space="preserve">
          <source>d_dirfd.U</source>
          <target state="translated">d_dirfd.U</target>
        </trans-unit>
        <trans-unit id="9b3165cc3c8011e8ad6f91854cb2686866e179a3" translate="yes" xml:space="preserve">
          <source>d_dladdr.U</source>
          <target state="translated">d_dladdr.U</target>
        </trans-unit>
        <trans-unit id="b70972dfb75561821beb601ccb3287c342eb55c8" translate="yes" xml:space="preserve">
          <source>d_dlerror.U</source>
          <target state="translated">d_dlerror.U</target>
        </trans-unit>
        <trans-unit id="2b5d12a7db0823de84c0367acad4c235ab064f96" translate="yes" xml:space="preserve">
          <source>d_dlopen.U</source>
          <target state="translated">d_dlopen.U</target>
        </trans-unit>
        <trans-unit id="dc8eed02e671ef678307e9e31da926de773d7e10" translate="yes" xml:space="preserve">
          <source>d_dlsymun.U</source>
          <target state="translated">d_dlsymun.U</target>
        </trans-unit>
        <trans-unit id="9e990b449bcb86098b00cfc09fe8dc9307acb7bd" translate="yes" xml:space="preserve">
          <source>d_dosuid.U</source>
          <target state="translated">d_dosuid.U</target>
        </trans-unit>
        <trans-unit id="4a2ad9cb61942b5f09e9017042cdeb9f570be3ad" translate="yes" xml:space="preserve">
          <source>d_drand48_r.U</source>
          <target state="translated">d_drand48_r.U</target>
        </trans-unit>
        <trans-unit id="93e47f6785b73f0e4f380d618a5328fc35e3349d" translate="yes" xml:space="preserve">
          <source>d_drand48proto.U</source>
          <target state="translated">d_drand48proto.U</target>
        </trans-unit>
        <trans-unit id="0e8171ae7619bc060c417ddc891f452d9ee4d2f4" translate="yes" xml:space="preserve">
          <source>d_dup2.U</source>
          <target state="translated">d_dup2.U</target>
        </trans-unit>
        <trans-unit id="13d99d3557d6463e65f12dab3a3b98f275ea745b" translate="yes" xml:space="preserve">
          <source>d_eaccess.U</source>
          <target state="translated">d_eaccess.U</target>
        </trans-unit>
        <trans-unit id="8942b760c472fd189eb8e058ab7d9a20d64a4fa7" translate="yes" xml:space="preserve">
          <source>d_endgrent.U</source>
          <target state="translated">d_endgrent.U</target>
        </trans-unit>
        <trans-unit id="5f1350c9863b1a138322db5880fe460a27554218" translate="yes" xml:space="preserve">
          <source>d_endgrent_r.U</source>
          <target state="translated">d_endgrent_r.U</target>
        </trans-unit>
        <trans-unit id="055cb43f460fe39ac04fd677b1a831f4d159c399" translate="yes" xml:space="preserve">
          <source>d_endhent.U</source>
          <target state="translated">d_endhent.U</target>
        </trans-unit>
        <trans-unit id="162b1dea1e482ab00847c6db280d9fe5838ec53d" translate="yes" xml:space="preserve">
          <source>d_endhostent_r.U</source>
          <target state="translated">d_endhostent_r.U</target>
        </trans-unit>
        <trans-unit id="9e9a377cadd06e267229e0a8c642446433b157ee" translate="yes" xml:space="preserve">
          <source>d_endnent.U</source>
          <target state="translated">d_endnent.U</target>
        </trans-unit>
        <trans-unit id="b6db102a3e11a5a88079818b05c512c28244e153" translate="yes" xml:space="preserve">
          <source>d_endnetent_r.U</source>
          <target state="translated">d_endnetent_r.U</target>
        </trans-unit>
        <trans-unit id="082434b739c16dafa9b9ff85b0080412c25e142f" translate="yes" xml:space="preserve">
          <source>d_endpent.U</source>
          <target state="translated">d_endpent.U</target>
        </trans-unit>
        <trans-unit id="dbc5e21bfeaa60eba8e35ead73c2aac0aadb5c86" translate="yes" xml:space="preserve">
          <source>d_endprotoent_r.U</source>
          <target state="translated">d_endprotoent_r.U</target>
        </trans-unit>
        <trans-unit id="0a438128e68f364ce1edfe9168384c370ab43078" translate="yes" xml:space="preserve">
          <source>d_endpwent.U</source>
          <target state="translated">d_endpwent.U</target>
        </trans-unit>
        <trans-unit id="290df3e2c64bd74ab162155d0a89b9dcc3ef4c34" translate="yes" xml:space="preserve">
          <source>d_endpwent_r.U</source>
          <target state="translated">d_endpwent_r.U</target>
        </trans-unit>
        <trans-unit id="8ea97974c355e0a355261d95fdac4300e951da34" translate="yes" xml:space="preserve">
          <source>d_endsent.U</source>
          <target state="translated">d_endsent.U</target>
        </trans-unit>
        <trans-unit id="0f45ae11575db454086967fe80a4258298abf4a6" translate="yes" xml:space="preserve">
          <source>d_endservent_r.U</source>
          <target state="translated">d_endservent_r.U</target>
        </trans-unit>
        <trans-unit id="ef1639c3b18f41085695b1642c287890d47b6956" translate="yes" xml:space="preserve">
          <source>d_erf.U</source>
          <target state="translated">d_erf.U</target>
        </trans-unit>
        <trans-unit id="f1c8317114a6e29b13819653d7eefdd60d830928" translate="yes" xml:space="preserve">
          <source>d_erfc.U</source>
          <target state="translated">d_erfc.U</target>
        </trans-unit>
        <trans-unit id="8d3ca9e633401175fac092ab243ed0acc0350dbf" translate="yes" xml:space="preserve">
          <source>d_exp2.U</source>
          <target state="translated">d_exp2.U</target>
        </trans-unit>
        <trans-unit id="1fab102a804397a68c80918e813717a1c544ca6f" translate="yes" xml:space="preserve">
          <source>d_expm1.U</source>
          <target state="translated">d_expm1.U</target>
        </trans-unit>
        <trans-unit id="685fe55c5f870175b5757716439517e51891b514" translate="yes" xml:space="preserve">
          <source>d_faststdio.U</source>
          <target state="translated">d_faststdio.U</target>
        </trans-unit>
        <trans-unit id="8335a708d750853a097559e9d852f3f88b5af450" translate="yes" xml:space="preserve">
          <source>d_fchdir.U</source>
          <target state="translated">d_fchdir.U</target>
        </trans-unit>
        <trans-unit id="3157c34d2ecd7ef6df64b281e86f2a2a5eb13c77" translate="yes" xml:space="preserve">
          <source>d_fchdir='define'</source>
          <target state="translated">d_fchdir='define'</target>
        </trans-unit>
        <trans-unit id="5d9ad69952867afa8d6bf3a5224032f310cb0cd4" translate="yes" xml:space="preserve">
          <source>d_fchdir='undef'</source>
          <target state="translated">d_fchdir='undef'</target>
        </trans-unit>
        <trans-unit id="609c41d6508a4ec4857efa2e4f5a2cb0c5c99cd7" translate="yes" xml:space="preserve">
          <source>d_fchmod.U</source>
          <target state="translated">d_fchmod.U</target>
        </trans-unit>
        <trans-unit id="ef7081bad9616cb32c7150906b6791d4e1eb767f" translate="yes" xml:space="preserve">
          <source>d_fchown.U</source>
          <target state="translated">d_fchown.U</target>
        </trans-unit>
        <trans-unit id="ade11c323f1a312a310054caaed1ccdc07152198" translate="yes" xml:space="preserve">
          <source>d_fcntl.U</source>
          <target state="translated">d_fcntl.U</target>
        </trans-unit>
        <trans-unit id="6b397e85b7df1147766250ebfbfad4e0b3c513c3" translate="yes" xml:space="preserve">
          <source>d_fcntl_can_lock.U</source>
          <target state="translated">d_fcntl_can_lock.U</target>
        </trans-unit>
        <trans-unit id="96cd2e736164f3d1c953572a858dd2f3fecbf743" translate="yes" xml:space="preserve">
          <source>d_fd_set.U</source>
          <target state="translated">d_fd_set.U</target>
        </trans-unit>
        <trans-unit id="5610a6176f6dffa5c6339e3b4aed254c6d8d5bdb" translate="yes" xml:space="preserve">
          <source>d_fdim.U</source>
          <target state="translated">d_fdim.U</target>
        </trans-unit>
        <trans-unit id="093f1f8d37325e4090b731a7e736baa0824ed9bb" translate="yes" xml:space="preserve">
          <source>d_fegetround.U</source>
          <target state="translated">d_fegetround.U</target>
        </trans-unit>
        <trans-unit id="22c5d6e46475330d576fbddf1674c48e022b69a2" translate="yes" xml:space="preserve">
          <source>d_fgetpos.U</source>
          <target state="translated">d_fgetpos.U</target>
        </trans-unit>
        <trans-unit id="4d6ce27a642cfc0e43c2278ef8311e3855bbefe7" translate="yes" xml:space="preserve">
          <source>d_finite.U</source>
          <target state="translated">d_finite.U</target>
        </trans-unit>
        <trans-unit id="df2b5a950f1a6c7ea5c601383c6357b80b529916" translate="yes" xml:space="preserve">
          <source>d_finitel.U</source>
          <target state="translated">d_finitel.U</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
