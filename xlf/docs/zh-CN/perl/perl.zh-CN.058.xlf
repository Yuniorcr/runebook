<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="b981c090e0ccf2394ca9d98ec6e98f5fdb3b15ee" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;&amp;amp;len&lt;/code&gt; ). If you do not care what the length of the data is, use the &lt;code&gt;SvPV_nolen&lt;/code&gt; macro. Historically the &lt;code&gt;SvPV&lt;/code&gt; macro with the global variable &lt;code&gt;PL_na&lt;/code&gt; has been used in this case. But that can be quite inefficient because &lt;code&gt;PL_na&lt;/code&gt; must be accessed in thread-local storage in threaded Perl. In any case, remember that Perl allows arbitrary strings of data that may both contain NULs and might not be terminated by a &lt;code&gt;NUL&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;&amp;amp;len&lt;/code&gt; ）。如果您不关心数据的长度，请使用 &lt;code&gt;SvPV_nolen&lt;/code&gt; 宏。从历史上看，在这种情况下使用具有全局变量 &lt;code&gt;PL_na&lt;/code&gt; 的 &lt;code&gt;SvPV&lt;/code&gt; 宏。但这可能效率很低，因为必须在线程Perl的线程本地存储中访问 &lt;code&gt;PL_na&lt;/code&gt; 。无论如何，请记住Perl允许任意数据字符串，这些数据字符串可能都包含 &lt;code&gt;NUL&lt;/code&gt; 且可能不会被NUL终止。</target>
        </trans-unit>
        <trans-unit id="ab7c0594a0c4ad4b7139bc4478498a69f7e492fd" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b438f8ebaf9cd38ef6ddc105cb8f6b0e5c7983a5" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; for commands names like &lt;b&gt;cat&lt;/b&gt; or &lt;b&gt;grep&lt;/b&gt;.</source>
          <target state="translated">使用 &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; 表示命令名称，例如&lt;b&gt;cat&lt;/b&gt;或&lt;b&gt;grep&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="912f09261e74f066e3e24f4b46906e4342000bf4" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; for function, variable and module names (and more generally anything that can be considered part of code, like filehandles or specific values). Note that function names are considered more readable with parentheses after their name, that is &lt;code&gt;function()&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; 作为函数，变量和模块的名称（通常，任何可以视为代码一部分的内容，例如文件句柄或特定值）。请注意，函数名称被认为在其名称后带有括号 &lt;code&gt;function()&lt;/code&gt; 即function（））更具可读性。</target>
        </trans-unit>
        <trans-unit id="91895a1cf51d91f57aca46510d3d62ba8b32f1ee" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; or &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; for file names. &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; should be the only Pod code for file names, but as most Pod formatters render it as italic, Unix and Windows paths with their slashes and backslashes may be less readable, and better rendered with &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; 作为文件名。 &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; 应该是唯一的文件名Pod代码，但是由于大多数Pod格式化程序将其呈现为斜体，因此Unix和Windows路径中的斜杠和反斜杠可能不太可读，而使用 &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; 更好地呈现。</target>
        </trans-unit>
        <trans-unit id="bdc3bde8eda2284372421b6e4025b7b2372a316b" translate="yes" xml:space="preserve">
          <source>use Bourne shell (&lt;code&gt;sh(1)&lt;/code&gt; ) redirection syntax in backticks, not &lt;code&gt;csh(1)&lt;/code&gt; ! Details on why Perl's &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; and backtick and pipe opens all use the Bourne shell are in the</source>
          <target state="translated">在反引号中使用Bourne shell（ &lt;code&gt;sh(1)&lt;/code&gt; ）重定向语法，而不是 &lt;code&gt;csh(1)&lt;/code&gt; ！有关为何Perl的 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 以及反引号和管道打开全部使用Bourne外壳的详细信息，请参见</target>
        </trans-unit>
        <trans-unit id="16599c655382953c8630fbbdb2c964d3e8dee9ae" translate="yes" xml:space="preserve">
          <source>use Module</source>
          <target state="translated">使用模块</target>
        </trans-unit>
        <trans-unit id="90f04428920392ff9b2def8ba0ed469f079b6502" translate="yes" xml:space="preserve">
          <source>use Module LIST</source>
          <target state="translated">使用模块列表</target>
        </trans-unit>
        <trans-unit id="7ed0869d2d4fc928494f42d5819555da7a79edd6" translate="yes" xml:space="preserve">
          <source>use Module VERSION</source>
          <target state="translated">使用模块VERSION</target>
        </trans-unit>
        <trans-unit id="c2de803ffc4c0a3b39ed0dff30412c19bd9d9fee" translate="yes" xml:space="preserve">
          <source>use Module VERSION LIST</source>
          <target state="translated">使用模块VERSION LIST</target>
        </trans-unit>
        <trans-unit id="ed1b16f9eadabbae879f86b68ec71e8b6d05ca67" translate="yes" xml:space="preserve">
          <source>use Perl; used to provide a slashdot-style news/blog website covering all things Perl, from minutes of the meetings of the Perl 6 Design team to conference announcements with (ir)relevant discussion. It no longer accepts updates, but you can still use the site to read old entries and comments.</source>
          <target state="translated">使用 Perl;曾经提供一个 slashdot 风格的新闻/博客网站,内容涵盖了 Perl 的所有事情,从 Perl 6 设计团队的会议记录到会议公告和(不)相关讨论。它不再接受更新,但你仍然可以使用该网站阅读旧的条目和评论。</target>
        </trans-unit>
        <trans-unit id="d91bc845470d4a86d4018011a4792f7dcf86f037" translate="yes" xml:space="preserve">
          <source>use SA_RESTART. Consequently, restartable system calls can fail (with $! set to &lt;code&gt;EINTR&lt;/code&gt; ) in places where they previously would have succeeded.</source>
          <target state="translated">使用SA_RESTART。因此，可重新启动的系统调用在以前可以成功执行的地方可能会失败（将$！设置为 &lt;code&gt;EINTR&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4c7c49503a611307f683497f7df47accbf51802a" translate="yes" xml:space="preserve">
          <source>use VERSION</source>
          <target state="translated">使用版本</target>
        </trans-unit>
        <trans-unit id="86d6a1e3bbd163625d7fac651620cbfa17805164" translate="yes" xml:space="preserve">
          <source>use bytes;</source>
          <target state="translated">使用字节。</target>
        </trans-unit>
        <trans-unit id="59d6056cfb56b5a37f62f1bf027d56c8cb904bd1" translate="yes" xml:space="preserve">
          <source>use integer vs. use bigint</source>
          <target state="translated">使用整数与使用大数</target>
        </trans-unit>
        <trans-unit id="814151fffad1e37f33b4e503823e70b6bbf3c04b" translate="yes" xml:space="preserve">
          <source>use integer;</source>
          <target state="translated">使用整数。</target>
        </trans-unit>
        <trans-unit id="3d1d48f5b10a148ad0e4d39b9da43de87d730e84" translate="yes" xml:space="preserve">
          <source>use of a backslash to include a space in a word</source>
          <target state="translated">反斜杠的用法</target>
        </trans-unit>
        <trans-unit id="1f5c67435c71d9a6ca9c3233dedb2dc1513c55c2" translate="yes" xml:space="preserve">
          <source>use of a backslash to remove the special meaning of a double-quote</source>
          <target state="translated">反斜杠之说</target>
        </trans-unit>
        <trans-unit id="f6fe0074742b81fff90e497bf135242ea8e89606" translate="yes" xml:space="preserve">
          <source>use of quotes to include a space in a word</source>
          <target state="translated">歇后语</target>
        </trans-unit>
        <trans-unit id="8c01026ad061791e802cf597a172313b49e695da" translate="yes" xml:space="preserve">
          <source>use re 'strict'</source>
          <target state="translated">重用</target>
        </trans-unit>
        <trans-unit id="cda9500ef317eb6fc5a5f798984325090df1150f" translate="yes" xml:space="preserve">
          <source>use re;</source>
          <target state="translated">重用</target>
        </trans-unit>
        <trans-unit id="53e07a32bf191d6917ee6fd863f0b52632a86798" translate="yes" xml:space="preserve">
          <source>use strict</source>
          <target state="translated">严用</target>
        </trans-unit>
        <trans-unit id="8428b0851b0684a353e7ed0874608908c7b5144e" translate="yes" xml:space="preserve">
          <source>use strict;</source>
          <target state="translated">严格使用。</target>
        </trans-unit>
        <trans-unit id="371d195a9f9f3ece23b26e71d1dd939d2d111281" translate="yes" xml:space="preserve">
          <source>use symbolic references are when you really must refer to the symbol table. This may be because it's something that one can't take a real reference to, such as a format name. Doing so may also be important for method calls, since these always go through the symbol table for resolution.</source>
          <target state="translated">使用符号引用是当你真的必须参考符号表的时候。这可能是因为它是一个不能采取真正的引用的东西,例如格式名。这样做可能对方法调用也很重要,因为这些方法总是要通过符号表来解决。</target>
        </trans-unit>
        <trans-unit id="9b052d587b755b57eec4828588dac107af257aee" translate="yes" xml:space="preserve">
          <source>use the &lt;code&gt;sources&lt;/code&gt; parameter below.</source>
          <target state="translated">使用下面的 &lt;code&gt;sources&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="cbacfc4c115173ec78e0b2e5387eefbdb941b814" translate="yes" xml:space="preserve">
          <source>use the brackets. These are correct: &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(FH)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;(FH, 0,
2)&lt;/code&gt; and &quot;copying from STDIN to FILE&quot;.</source>
          <target state="translated">使用括号。这些是正确的： &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(FH)&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;(FH, 0, 2)&lt;/code&gt; 和&amp;ldquo;从STDIN复制到FILE&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="16242ca7d468c97ea7b6997607a050d2e0014a3f" translate="yes" xml:space="preserve">
          <source>use utf8;</source>
          <target state="translated">使用utf8。</target>
        </trans-unit>
        <trans-unit id="9d9bf76551e571ede80cc893a3c04b1861a56e60" translate="yes" xml:space="preserve">
          <source>use warnings;</source>
          <target state="translated">使用警告。</target>
        </trans-unit>
        <trans-unit id="43e6bb793575b0e1c61db35e98228f60aeaf2f8d" translate="yes" xml:space="preserve">
          <source>use()</source>
          <target state="translated">use()</target>
        </trans-unit>
        <trans-unit id="d05287976184d88c455cd302b00f63b076bbdc63" translate="yes" xml:space="preserve">
          <source>use64bits.U</source>
          <target state="translated">use64bits.U</target>
        </trans-unit>
        <trans-unit id="de888ddd185c016565479b29ef9407370202fca3" translate="yes" xml:space="preserve">
          <source>usebacktrace.U</source>
          <target state="translated">usebacktrace.U</target>
        </trans-unit>
        <trans-unit id="c75278e55d10139a00150399331bbf063800d605" translate="yes" xml:space="preserve">
          <source>useconds or interval more than ...</source>
          <target state="translated">秒或间隔多于...。</target>
        </trans-unit>
        <trans-unit id="83a7a6b40353b9f6be160c361611ae311dfb9752" translate="yes" xml:space="preserve">
          <source>useconds or uinterval equal to or more than 1000000</source>
          <target state="translated">useconds或uinterval等于或大于1000000。</target>
        </trans-unit>
        <trans-unit id="192a56759d36454cc0b8c812e31845e9ed10b130" translate="yes" xml:space="preserve">
          <source>used</source>
          <target state="translated">used</target>
        </trans-unit>
        <trans-unit id="73decdd966503bbba3c9fd02a2b5f2ce91746665" translate="yes" xml:space="preserve">
          <source>used by &lt;code&gt;DynaLoader&lt;/code&gt; for DLL name mangling.</source>
          <target state="translated">由 &lt;code&gt;DynaLoader&lt;/code&gt; 用于DLL名称修饰。</target>
        </trans-unit>
        <trans-unit id="e30f4a35ac593e13f39f5488a20368f2d3e27f69" translate="yes" xml:space="preserve">
          <source>used by &lt;code&gt;File::Copy::copy&lt;/code&gt; , see &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt;.</source>
          <target state="translated">由 &lt;code&gt;File::Copy::copy&lt;/code&gt; ，请参阅&lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6651965b06637ac206b1de96bf978eb27b24abe2" translate="yes" xml:space="preserve">
          <source>used by Microsoft C/C++), all of these functions will be available for use. Otherwise, you won't be able to perform the SHA-384 and SHA-512 transforms, both of which require 64-bit operations.</source>
          <target state="translated">使用的),所有这些函数都可以使用。否则,你将无法执行SHA-384和SHA-512变换,这两种变换都需要64位操作。</target>
        </trans-unit>
        <trans-unit id="4bcdb1a3c67ee6a36e9c8f01fec7794365214c0a" translate="yes" xml:space="preserve">
          <source>used in the Canonical Ordering Algorithm. For Unicode 5.1, this is described in Section 3.11 &lt;code&gt;Canonical Ordering Behavior&lt;/code&gt; available at &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.1.0/&quot;&gt;http://www.unicode.org/versions/Unicode5.1.0/&lt;/a&gt;</source>
          <target state="translated">在规范排序算法中使用。对于Unicode 5.1，这可在&lt;a href=&quot;http://www.unicode.org/versions/Unicode5.1.0/&quot;&gt;http://www.unicode.org/versions/Unicode5.1.0/上的&lt;/a&gt;第3.11节&amp;ldquo; &lt;code&gt;Canonical Ordering Behavior&lt;/code&gt; 进行描述。</target>
        </trans-unit>
        <trans-unit id="d652c7d874ec8b1c40417e324ea5d062c754cc5c" translate="yes" xml:space="preserve">
          <source>used in this way, the result of evaluation of &lt;code&gt;code&lt;/code&gt; is put into the special variable &lt;code&gt;$^R&lt;/code&gt; . This happens immediately, so &lt;code&gt;$^R&lt;/code&gt; can be used from other &lt;code&gt;(?{ code })&lt;/code&gt; assertions inside the same regular expression.</source>
          <target state="translated">以这种方式使用时，将 &lt;code&gt;code&lt;/code&gt; 评估的结果放入特殊变量 &lt;code&gt;$^R&lt;/code&gt; 。这会立即发生，因此 &lt;code&gt;$^R&lt;/code&gt; 可用于同一正则表达式中的其他 &lt;code&gt;(?{ code })&lt;/code&gt; 断言。</target>
        </trans-unit>
        <trans-unit id="910e6213db30e16ad6b1c4b4021611873d6ce5e8" translate="yes" xml:space="preserve">
          <source>usedtrace.U</source>
          <target state="translated">usedtrace.U</target>
        </trans-unit>
        <trans-unit id="ae3154c3ec5c365c6959f779a04adc35659601ba" translate="yes" xml:space="preserve">
          <source>usefaststdio.U</source>
          <target state="translated">usefaststdio.U</target>
        </trans-unit>
        <trans-unit id="682aa3c2d38618cf64e946cc3bbd2fc8a96d01db" translate="yes" xml:space="preserve">
          <source>useful programs are slow</source>
          <target state="translated">实用程序慢</target>
        </trans-unit>
        <trans-unit id="64cd2a07a89b1a0f1da29526d021d0937a062dc3" translate="yes" xml:space="preserve">
          <source>useful:</source>
          <target state="translated">useful:</target>
        </trans-unit>
        <trans-unit id="86959ccaa35c5e158cbc673c5b275d5c75322ffb" translate="yes" xml:space="preserve">
          <source>usekernprocpathname.U</source>
          <target state="translated">usekernprocpathname.U</target>
        </trans-unit>
        <trans-unit id="dfb174e9b45efda0d2813ab34a52566fc0e5149a" translate="yes" xml:space="preserve">
          <source>uselfs.U</source>
          <target state="translated">uselfs.U</target>
        </trans-unit>
        <trans-unit id="4a865fd135358714278adf708601a551aa95d374" translate="yes" xml:space="preserve">
          <source>uselongdbl.U</source>
          <target state="translated">uselongdbl.U</target>
        </trans-unit>
        <trans-unit id="8f139461261d4e47392a29d9a1470571a111a9dc" translate="yes" xml:space="preserve">
          <source>uselongdouble.cbu</source>
          <target state="translated">uselongdouble.cbu</target>
        </trans-unit>
        <trans-unit id="55dcabac6b2a581cb97ea8cc9bfb5c2c032a1aa2" translate="yes" xml:space="preserve">
          <source>usemorebits.U</source>
          <target state="translated">usemorebits.U</target>
        </trans-unit>
        <trans-unit id="cacd09fc8d7a5be6357aae988bf81988f273cde2" translate="yes" xml:space="preserve">
          <source>usemultiplicity.U</source>
          <target state="translated">usemultiplicity.U</target>
        </trans-unit>
        <trans-unit id="999728bc8bffebc44a36dcc8573424d9a99a522c" translate="yes" xml:space="preserve">
          <source>usenm.U</source>
          <target state="translated">usenm.U</target>
        </trans-unit>
        <trans-unit id="135519af067f60479443d73bde99b3ce40a82660" translate="yes" xml:space="preserve">
          <source>usensgetexecutablepath.U</source>
          <target state="translated">usensgetexecutablepath.U</target>
        </trans-unit>
        <trans-unit id="f8a6096831b8f25daa716e7ca10d96073259de34" translate="yes" xml:space="preserve">
          <source>useperlio.U</source>
          <target state="translated">useperlio.U</target>
        </trans-unit>
        <trans-unit id="97f9b6453ab8627d3cd32b5de7ede1a376eb1e42" translate="yes" xml:space="preserve">
          <source>usequadmath.U</source>
          <target state="translated">usequadmath.U</target>
        </trans-unit>
        <trans-unit id="12dea96fec20593566ab75692c9949596833adc9" translate="yes" xml:space="preserve">
          <source>user</source>
          <target state="translated">user</target>
        </trans-unit>
        <trans-unit id="948109d35f9658f13aa26db4dca1ebe12f69c043" translate="yes" xml:space="preserve">
          <source>user interface (tty or graphical)</source>
          <target state="translated">用户界面</target>
        </trans-unit>
        <trans-unit id="99cd2c26d48da74abf7a71cda0673fef004fd48c" translate="yes" xml:space="preserve">
          <source>user time</source>
          <target state="translated">用户时间</target>
        </trans-unit>
        <trans-unit id="a7e2c648dc9941f38aea4196f90df226d6e93b2b" translate="yes" xml:space="preserve">
          <source>uses</source>
          <target state="translated">uses</target>
        </trans-unit>
        <trans-unit id="8fe9b31e1cb4034ae05b748f916caeb04bc961ae" translate="yes" xml:space="preserve">
          <source>uses &lt;code&gt;$a&lt;/code&gt; for the width, &lt;code&gt;$b&lt;/code&gt; for the precision, and &lt;code&gt;$c&lt;/code&gt; as the value to format; while:</source>
          <target state="translated">使用 &lt;code&gt;$a&lt;/code&gt; 表示宽度，使用 &lt;code&gt;$b&lt;/code&gt; 表示精度，使用 &lt;code&gt;$c&lt;/code&gt; 表示要格式化的值；而：</target>
        </trans-unit>
        <trans-unit id="09830868f1f121ce087a3809e753c0b99304db3d" translate="yes" xml:space="preserve">
          <source>uses dl_findfile() to determine the filename to load</source>
          <target state="translated">使用dl_findfile()来确定要加载的文件名。</target>
        </trans-unit>
        <trans-unit id="5af968b0841a76d30d08c146e669a78b4cab19ad" translate="yes" xml:space="preserve">
          <source>uses empty string matches as separators to produce the output 'a:b:c'; thus, the empty string may be used to split EXPR into a list of its component characters.</source>
          <target state="translated">使用空字符串匹配作为分隔符来产生输出'a:b:c';因此,空字符串可以用来将EXPR分割成一个由其组成的字符列表。</target>
        </trans-unit>
        <trans-unit id="90fd05af98859035d1a5f230da49fa1011416f54" translate="yes" xml:space="preserve">
          <source>uses the 'b' in 'abc' as a separator to produce the output 'a:c'. However, this:</source>
          <target state="translated">使用'abc'中的'b'作为分隔符,产生'a:c'的输出。然而,这。</target>
        </trans-unit>
        <trans-unit id="0385b247665cc9feec9dd5e3fae26654605693e5" translate="yes" xml:space="preserve">
          <source>uses the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; class.</source>
          <target state="translated">使用&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;类。</target>
        </trans-unit>
        <trans-unit id="7a1854e57bb3e0204fcdb39b3f71fdc0b1165103" translate="yes" xml:space="preserve">
          <source>uses the lexical variables that are maintained by the closure.</source>
          <target state="translated">使用由封闭维护的词汇变量。</target>
        </trans-unit>
        <trans-unit id="09d1afddd581a0eacf04d5d0d5756a7efff2579d" translate="yes" xml:space="preserve">
          <source>uses the object passed to the method to store any context data, whereas the</source>
          <target state="translated">使用传递给该方法的对象来存储任何上下文数据,而</target>
        </trans-unit>
        <trans-unit id="c3ceef66b33c51bee6d1bb1d471003d812947110" translate="yes" xml:space="preserve">
          <source>uses the string &lt;code&gt;&quot;\n&quot;&lt;/code&gt; as the line delimiter.</source>
          <target state="translated">使用字符串 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 作为行定界符。</target>
        </trans-unit>
        <trans-unit id="c3cd2678befce2c7f2ae3fa75bbf277408ae4f0c" translate="yes" xml:space="preserve">
          <source>usesocks.U</source>
          <target state="translated">usesocks.U</target>
        </trans-unit>
        <trans-unit id="f9de3288841199ccb6c310b320eb302bb6d60b04" translate="yes" xml:space="preserve">
          <source>usethreads.U</source>
          <target state="translated">usethreads.U</target>
        </trans-unit>
        <trans-unit id="92bd75ebd8fd2b0179172217b15350cc6d4002f0" translate="yes" xml:space="preserve">
          <source>using</source>
          <target state="translated">using</target>
        </trans-unit>
        <trans-unit id="598c217817c73e5780e3966c099266496e2980d1" translate="yes" xml:space="preserve">
          <source>using GNU libc and you can ignore &lt;code&gt;LANGUAGE&lt;/code&gt; .</source>
          <target state="translated">使用GNU libc，您可以忽略 &lt;code&gt;LANGUAGE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16fc297cbc600394f05f8c2154dec797fd2616a9" translate="yes" xml:space="preserve">
          <source>using the &lt;b&gt;parseopts()&lt;/b&gt; method. The set of currently accepted parse-options is as follows:</source>
          <target state="translated">使用&lt;b&gt;parseopts（）&lt;/b&gt;方法。当前接受的解析选项集如下：</target>
        </trans-unit>
        <trans-unit id="5ddf1529ff81cf1646da1b5ad744e5598d0ce2a2" translate="yes" xml:space="preserve">
          <source>using the G_EVAL flag, it promptly reset &lt;code&gt;$@&lt;/code&gt; . This results in the failure of the outermost test for &lt;code&gt;$@&lt;/code&gt; , and thereby the failure of the error trap.</source>
          <target state="translated">使用G_EVAL标志，它将立即重置 &lt;code&gt;$@&lt;/code&gt; 。这导致 &lt;code&gt;$@&lt;/code&gt; 的最外层测试失败，从而导致错误陷阱失败。</target>
        </trans-unit>
        <trans-unit id="eb699932692b6b7e2ea37fceb7f7f660756e9c08" translate="yes" xml:space="preserve">
          <source>using the mkstemp() from this module.</source>
          <target state="translated">使用本模块的mkstemp()。</target>
        </trans-unit>
        <trans-unit id="74206ccb17460da0011cfb062984120700d158f9" translate="yes" xml:space="preserve">
          <source>usrinc.U</source>
          <target state="translated">usrinc.U</target>
        </trans-unit>
        <trans-unit id="f68489ebd04ca3a9cf85cc582f26b952d9e0e821" translate="yes" xml:space="preserve">
          <source>usually denotes an intensity, but the name does not matter). The number</source>
          <target state="translated">通常表示一种强度,但名称并不重要)。)数字</target>
        </trans-unit>
        <trans-unit id="552fa32543fec03ccf6183c2b935ef13e3235d5b" translate="yes" xml:space="preserve">
          <source>usually have their own documentation, either in the</source>
          <target state="translated">通常有自己的文件,或者在</target>
        </trans-unit>
        <trans-unit id="5b8f21f7c75d9b9f23162e7287673f1417b09fab" translate="yes" xml:space="preserve">
          <source>usually need to be overridden by subclasses.</source>
          <target state="translated">通常需要被子类重写。</target>
        </trans-unit>
        <trans-unit id="81f0c4ab9b5679964eab3692a28c6daa905d6fc9" translate="yes" xml:space="preserve">
          <source>utf8</source>
          <target state="translated">utf8</target>
        </trans-unit>
        <trans-unit id="bf16403afd56538795ee624940c94265c7f38841" translate="yes" xml:space="preserve">
          <source>utf8 - Perl pragma to enable/disable UTF-8 (or UTF-EBCDIC) in source code</source>
          <target state="translated">utf8-在源代码中启用/禁用UTF-8(或UTF-EBCDIC)的Perl pragma。</target>
        </trans-unit>
        <trans-unit id="a594f2111ee293665faf1e597c91b88defdbc7c8" translate="yes" xml:space="preserve">
          <source>utf8.h</source>
          <target state="translated">utf8.h</target>
        </trans-unit>
        <trans-unit id="c23f5615906bc56a2ba756aeb96aa29939293657" translate="yes" xml:space="preserve">
          <source>utf8::unicode_to_native() and utf8::native_to_unicode()</source>
          <target state="translated">utf8::unicode_to_native()和 utf8::native_to_unicode()</target>
        </trans-unit>
        <trans-unit id="1817968011ad57f4fc7f6411c6afa179d20d5f52" translate="yes" xml:space="preserve">
          <source>utfebcdic.h</source>
          <target state="translated">utfebcdic.h</target>
        </trans-unit>
        <trans-unit id="ccf120ba24ab73f5ca75edfecede60e684a35e77" translate="yes" xml:space="preserve">
          <source>utility (which should be installed if you have gcc 3.0 or newer installed).</source>
          <target state="translated">工具(如果你安装了gcc 3.0或更新的版本,应该安装这个工具)。</target>
        </trans-unit>
        <trans-unit id="e41e3186138fd652f131d74e1372b713a50e4b13" translate="yes" xml:space="preserve">
          <source>utility available from the shell or from the C library. Consult your system's documentation for information on iconv.</source>
          <target state="translated">工具,可从shell或C库中获取。关于iconv的信息,请查阅你的系统文档。</target>
        </trans-unit>
        <trans-unit id="b875306388033d91efeec1a88fa3e69e64258572" translate="yes" xml:space="preserve">
          <source>utility is distributed as part of the &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module::Starter&lt;/a&gt; CPAN package. It creates a directory with stubs of all the necessary files to start a new module, according to recent &quot;best practice&quot; for module development, and is invoked from the command line, thus:</source>
          <target state="translated">实用程序作为&lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module :: Starter&lt;/a&gt; CPAN软件包的一部分分发。根据最近用于模块开发的&amp;ldquo;最佳实践&amp;rdquo;，它将创建一个目录，其中包含所有必要文件的存根以启动新模块，并从命令行调用该目录，因此：</target>
        </trans-unit>
        <trans-unit id="d1c19560c50c6028812fe75cd093528162e899fa" translate="yes" xml:space="preserve">
          <source>utility which can be used to package Perl scripts and/or Perl library directories into SIS files, which can be installed to the device. To run the sisify.pl utility, you will need to have the 'makesis' and 'uidcrc' utilities already installed. If you don't have the Win32 SDKs, you may try for example &lt;a href=&quot;http://gnupoc.sourceforge.net/&quot;&gt;http://gnupoc.sourceforge.net/&lt;/a&gt; or &lt;a href=&quot;http://symbianos.org/~andreh/&quot;&gt;http://symbianos.org/~andreh/&lt;/a&gt;.</source>
          <target state="translated">实用程序，可用于将Perl脚本和/或Perl库目录打包到SIS文件中，然后将其安装到设备中。要运行sisify.pl实用程序，您将需要已安装&amp;ldquo; makesis&amp;rdquo;和&amp;ldquo; uidcrc&amp;rdquo;实用程序。如果您没有Win32 SDK，则可以尝试使用例如&lt;a href=&quot;http://gnupoc.sourceforge.net/&quot;&gt;http://gnupoc.sourceforge.net/&lt;/a&gt;或&lt;a href=&quot;http://symbianos.org/~andreh/&quot;&gt;http://symbianos.org/~andreh/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5b20e9780dfec2e3ed9c87a6333e7f3f40af656" translate="yes" xml:space="preserve">
          <source>utility will look for errors in your markup.</source>
          <target state="translated">该工具将查找您的标记中的错误。</target>
        </trans-unit>
        <trans-unit id="abd2ad286bf2e0b3a412f26ebf2a2be21f7de0fc" translate="yes" xml:space="preserve">
          <source>utility.</source>
          <target state="translated">utility.</target>
        </trans-unit>
        <trans-unit id="e5b9fa572bc5bd55617cfad38a4c758f62792ceb" translate="yes" xml:space="preserve">
          <source>utility. If none of these apply then passive mode is used.</source>
          <target state="translated">功用。如果这些都不适用,则使用被动模式。</target>
        </trans-unit>
        <trans-unit id="14409714f17737ef57cc19222c7537577b62d475" translate="yes" xml:space="preserve">
          <source>utils/</source>
          <target state="translated">utils/</target>
        </trans-unit>
        <trans-unit id="07be56c9175d1e0cf47abe27bd2ea4c74d0a71b7" translate="yes" xml:space="preserve">
          <source>utime</source>
          <target state="translated">utime</target>
        </trans-unit>
        <trans-unit id="e021c739267a3c120765dfd8bbf7a3476cf90409" translate="yes" xml:space="preserve">
          <source>utime LIST</source>
          <target state="translated">utime LIST</target>
        </trans-unit>
        <trans-unit id="3677a34e80cc23f49ad5f1fae628d097e1c1e1cb" translate="yes" xml:space="preserve">
          <source>uu encoding and decoding</source>
          <target state="translated">UU编码和解码</target>
        </trans-unit>
        <trans-unit id="7a38d8cbd20d9932ba948efaa364bb62651d5ad4" translate="yes" xml:space="preserve">
          <source>v</source>
          <target state="translated">v</target>
        </trans-unit>
        <trans-unit id="361122ca0dc8560cf79ff094f6193cd4093bfbfc" translate="yes" xml:space="preserve">
          <source>v1.0.0 &amp;ndash; first public release, 2012-02-27</source>
          <target state="translated">v1.0.0 &amp;ndash;首次公开发布，2012-02-27</target>
        </trans-unit>
        <trans-unit id="d8d7aee24dfe0953c95b730f8777dd9d65515b2c" translate="yes" xml:space="preserve">
          <source>v5.22 core Perl runs on z/OS (formerly OS/390). Theoretically it could run on the successors of OS/400 on AS/400 minicomputers as well as VM/ESA, and BS2000 for S/390 Mainframes. Such computers use EBCDIC character sets internally (usually Character Code Set ID 0037 for OS/400 and either 1047 or POSIX-BC for S/390 systems).</source>
          <target state="translated">以v5.22为核心的Perl可在z/OS(以前的OS/390)上运行,理论上它可在AS/400微型计算机上的OS/400的后续产品以及VM/ESA和S/390主机的BS2000上运行。理论上,它可以在AS/400微型计算机上的OS/400的后续产品以及VM/ESA和S/390主机的BS2000上运行。这类计算机内部使用EBCDIC字符集(通常OS/400使用字符代码集ID 0037,S/390系统使用1047或POSIX-BC)。</target>
        </trans-unit>
        <trans-unit id="39f69c278f46165447f30d10acf54277aaa3d5fc" translate="yes" xml:space="preserve">
          <source>val</source>
          <target state="translated">val</target>
        </trans-unit>
        <trans-unit id="c204f11609a31497c02218b5e5a0a169c78effbe" translate="yes" xml:space="preserve">
          <source>valgrind</source>
          <target state="translated">valgrind</target>
        </trans-unit>
        <trans-unit id="53046fa987b388728c455fdf478e8c9a874dace2" translate="yes" xml:space="preserve">
          <source>valid as UTF-8. A line consisting of simply &quot;#&quot;, an e-acute, and any non-highbit byte, is sufficient to establish this file's encoding.</source>
          <target state="translated">有效的UTF-8。由简单的 &quot;#&quot;、e-acute和任何非高位字节组成的一行,就足以建立这个文件的编码。</target>
        </trans-unit>
        <trans-unit id="f32b67c7e26342af42efabc674d441dca0a281c5" translate="yes" xml:space="preserve">
          <source>value</source>
          <target state="translated">value</target>
        </trans-unit>
        <trans-unit id="1e7e5e9fa34075181b1c3ae301720ed61601a7be" translate="yes" xml:space="preserve">
          <source>value is returned. It is up to the user to call &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; if they so desire.</source>
          <target state="translated">返回值。用户可以根据需要调用 &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="216685f7982133ab569ad4dfe5f678f3e1dbbd1f" translate="yes" xml:space="preserve">
          <source>value of 4. Pod processors may complain if</source>
          <target state="translated">值为4的花苞处理器可能会抱怨,如果</target>
        </trans-unit>
        <trans-unit id="789c8a7b03ce1d1295ddf529b2afdf58a3077c30" translate="yes" xml:space="preserve">
          <source>value of the array pointed to by $AoA. If you wanted the C notion, you'd have to write &lt;code&gt;${$AoA[$i]}&lt;/code&gt; to force the &lt;code&gt;$AoA[$i]&lt;/code&gt; to get evaluated first before the leading &lt;code&gt;$&lt;/code&gt; dereferencer.</source>
          <target state="translated">$ AoA指向的数组的值。如果您想要C的概念，则必须编写 &lt;code&gt;${$AoA[$i]}&lt;/code&gt; 来强制 &lt;code&gt;$AoA[$i]&lt;/code&gt; 在领先的 &lt;code&gt;$&lt;/code&gt; 解除引用之前首先被评估。</target>
        </trans-unit>
        <trans-unit id="b8f2b9679159768f9feb1485f4697501baee27a2" translate="yes" xml:space="preserve">
          <source>value which forms part of the method names described in &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;Package-specific Attribute Handling&lt;/a&gt; below.</source>
          <target state="translated">值，该值构成下面的&lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;程序包特定的属性处理&lt;/a&gt;中描述的方法名称的一部分。</target>
        </trans-unit>
        <trans-unit id="d8ad9fad6207027296ab17875f3071f0a7723f9b" translate="yes" xml:space="preserve">
          <source>value, with</source>
          <target state="translated">值,与</target>
        </trans-unit>
        <trans-unit id="345c822266c73d960e7e049d7d44d3fac7c7ec19" translate="yes" xml:space="preserve">
          <source>value.</source>
          <target state="translated">value.</target>
        </trans-unit>
        <trans-unit id="1de6ed8b204380a369710406f1cf40db9ea3121e" translate="yes" xml:space="preserve">
          <source>value. If the user does not call either of these methods then the result will be a reference to a &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; based object.</source>
          <target state="translated">值。如果用户不调用这两种方法，则结果将是对基于 &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; 的对象的引用。</target>
        </trans-unit>
        <trans-unit id="44415ffb02a62884cecd489fafaf5338dd30ca7a" translate="yes" xml:space="preserve">
          <source>value. If you want to see if the array is empty, just use &lt;code&gt;if (@array) { # not empty }&lt;/code&gt; for example.</source>
          <target state="translated">值。如果要查看数组是否为空，则仅使用 &lt;code&gt;if (@array) { # not empty }&lt;/code&gt; 例如。</target>
        </trans-unit>
        <trans-unit id="417801383c26ee78fc40ea379e8eda01aa338144" translate="yes" xml:space="preserve">
          <source>value:</source>
          <target state="translated">value:</target>
        </trans-unit>
        <trans-unit id="048b0cb1b94379c74e7e8c8ede496e3edbea3386" translate="yes" xml:space="preserve">
          <source>values</source>
          <target state="translated">values</target>
        </trans-unit>
        <trans-unit id="17a7c4c339f3492b8acb953db7732092bf51412a" translate="yes" xml:space="preserve">
          <source>values ARRAY</source>
          <target state="translated">值ARRAY</target>
        </trans-unit>
        <trans-unit id="2634c50fe8c56acb708defe572a6f66bd0ae2e7a" translate="yes" xml:space="preserve">
          <source>values EXPR</source>
          <target state="translated">价值观</target>
        </trans-unit>
        <trans-unit id="be8bd433d6363b535b0f1f125f2785bdc4c730c2" translate="yes" xml:space="preserve">
          <source>values HASH</source>
          <target state="translated">价值观</target>
        </trans-unit>
        <trans-unit id="52427f1ebccdb4fcea47bc5d0e5145b7b892e93d" translate="yes" xml:space="preserve">
          <source>values from 0 to 5, such as &lt;code&gt;rgb000&lt;/code&gt; or &lt;code&gt;rgb515&lt;/code&gt; . Similarly, the recognized background colors are:</source>
          <target state="translated">从0到5的值，例如 &lt;code&gt;rgb000&lt;/code&gt; 或 &lt;code&gt;rgb515&lt;/code&gt; 。同样，公认的背景色是：</target>
        </trans-unit>
        <trans-unit id="e74a3ebadeba9abb6c66ee5f8ffd1d486ee6fcb8" translate="yes" xml:space="preserve">
          <source>values from 0 to 5.</source>
          <target state="translated">值从0到5。</target>
        </trans-unit>
        <trans-unit id="e6ad9de07df6ee716656600f984ea5e44acf9199" translate="yes" xml:space="preserve">
          <source>values may already be available through the POSIX, Errno, or Fcntl modules.) The &lt;b&gt;pl2pm&lt;/b&gt; file in the distribution may help in your conversion, but it's just a mechanical process and therefore far from bulletproof.</source>
          <target state="translated">值可能已经可以通过POSIX，Errno或Fcntl模块获得。）发行版中的&lt;b&gt;pl2pm&lt;/b&gt;文件可能有助于您进行转换，但这只是一个机械过程，因此远非防弹。</target>
        </trans-unit>
        <trans-unit id="b6d212092cfb3c4de0fc9e126c8856174b98ea6d" translate="yes" xml:space="preserve">
          <source>values of variables, open file handles) are not affected by calling &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">变量的值，打开的文件句柄）不受调用 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 的影响。</target>
        </trans-unit>
        <trans-unit id="c78a54d54f417f166b040fd1193f989fbac7669b" translate="yes" xml:space="preserve">
          <source>vaproto.U</source>
          <target state="translated">vaproto.U</target>
        </trans-unit>
        <trans-unit id="e5b4e786e382d03c28e9edfab2d8149378ae69df" translate="yes" xml:space="preserve">
          <source>var</source>
          <target state="translated">var</target>
        </trans-unit>
        <trans-unit id="442355f6097724b9f300211ae8b56c9215274278" translate="yes" xml:space="preserve">
          <source>varargs.h</source>
          <target state="translated">varargs.h</target>
        </trans-unit>
        <trans-unit id="32c263408bb93f559077c6e179bd9ba556508a09" translate="yes" xml:space="preserve">
          <source>varglob (VARNAME)</source>
          <target state="translated">varglob (VARNAME)</target>
        </trans-unit>
        <trans-unit id="b46d0172433dd6895dac7544b9dacbb87b361e9f" translate="yes" xml:space="preserve">
          <source>variable</source>
          <target state="translated">variable</target>
        </trans-unit>
        <trans-unit id="f28cdc93712b217f7e1a7f8c732549e7fca12478" translate="yes" xml:space="preserve">
          <source>variable. If found, and the value does not begin with a slash, and the terminal type name is the same as the environment string</source>
          <target state="translated">变量,如果找到了,而且值不是以斜杠开头,并且终端类型名称与环境字符串相同。如果找到了,而且值不是以斜线开头,并且终端类型名称与环境字符串相同。</target>
        </trans-unit>
        <trans-unit id="73be3da84c74dd524e9174ed859ebd8fbe0ecb3e" translate="yes" xml:space="preserve">
          <source>variables with) the compartment's namespace and only that data will be visible to code evaluated in the compartment.</source>
          <target state="translated">变量与)分格的命名空间,只有这些数据才会对在分格中评估的代码可见。</target>
        </trans-unit>
        <trans-unit id="328b2913d40a4414bbacabb3a360dbd897edd419" translate="yes" xml:space="preserve">
          <source>vars</source>
          <target state="translated">vars</target>
        </trans-unit>
        <trans-unit id="d0738423627650c10c37e4c0cb07def0732c0229" translate="yes" xml:space="preserve">
          <source>vars - Perl pragma to predeclare global variable names</source>
          <target state="translated">vars-用Perl pragma来预先声明全局变量名。</target>
        </trans-unit>
        <trans-unit id="3fda85e28248463329b5095a7e36c028b3156227" translate="yes" xml:space="preserve">
          <source>vary in size. The alignment constraint of the structure can be greater than any of its elements. [And if you think that this doesn't affect anything common, dismember the next cellphone that you see. Many have ARM cores, and the ARM structure rules make &lt;code&gt;sizeof (foo_t)&lt;/code&gt; == 4]</source>
          <target state="translated">大小各异。结构的对齐约束可以大于其任何元素。[[如果您认为这不会影响任何常见问题，请拆解您看到的下一部手机。许多具有ARM内核，并且ARM结构规则使 &lt;code&gt;sizeof (foo_t)&lt;/code&gt; == 4]</target>
        </trans-unit>
        <trans-unit id="b803e7ca5c714dbd85bf00d511fbc99a77690ad2" translate="yes" xml:space="preserve">
          <source>vec</source>
          <target state="translated">vec</target>
        </trans-unit>
        <trans-unit id="c54a18ac21d0acf2be7f8a4af68b6de9a68db6ff" translate="yes" xml:space="preserve">
          <source>vec EXPR,OFFSET,BITS</source>
          <target state="translated">vec EXPR,OFFSET,BITS。</target>
        </trans-unit>
        <trans-unit id="32af47b87ac2b19a971faaedbed3373dcd83c6e8" translate="yes" xml:space="preserve">
          <source>vector flag</source>
          <target state="translated">矢量旗</target>
        </trans-unit>
        <trans-unit id="f997c58732c07191b9cf44ba3c5fdd710cc19a22" translate="yes" xml:space="preserve">
          <source>vendorarch.U</source>
          <target state="translated">vendorarch.U</target>
        </trans-unit>
        <trans-unit id="78c0f01568b26ab7021a574fad5f974198aad6d0" translate="yes" xml:space="preserve">
          <source>vendorbin.U</source>
          <target state="translated">vendorbin.U</target>
        </trans-unit>
        <trans-unit id="660495819236779e293a0a32c3609f3b6829ad8a" translate="yes" xml:space="preserve">
          <source>vendorhtml1dir.U</source>
          <target state="translated">vendorhtml1dir.U</target>
        </trans-unit>
        <trans-unit id="ba034d33799b6d494964ade71fe262b57e78da69" translate="yes" xml:space="preserve">
          <source>vendorhtml3dir.U</source>
          <target state="translated">vendorhtml3dir.U</target>
        </trans-unit>
        <trans-unit id="5c5f94ad3d73d98afb7e36c994b2d58e93b157c9" translate="yes" xml:space="preserve">
          <source>vendorlib.U</source>
          <target state="translated">vendorlib.U</target>
        </trans-unit>
        <trans-unit id="2284692bf04e52a99af83b0173dbfd7bb5474851" translate="yes" xml:space="preserve">
          <source>vendorman1dir.U</source>
          <target state="translated">vendorman1dir.U</target>
        </trans-unit>
        <trans-unit id="0bb32aac5c75643dd8a475440312246f61ee79e2" translate="yes" xml:space="preserve">
          <source>vendorman3dir.U</source>
          <target state="translated">vendorman3dir.U</target>
        </trans-unit>
        <trans-unit id="105d52e11b963cf884747461ead872a0d154eae4" translate="yes" xml:space="preserve">
          <source>vendorprefix.U</source>
          <target state="translated">vendorprefix.U</target>
        </trans-unit>
        <trans-unit id="e5ff5428b3a391d0a31fc7b9d32363c3703413d8" translate="yes" xml:space="preserve">
          <source>vendorscript.U</source>
          <target state="translated">vendorscript.U</target>
        </trans-unit>
        <trans-unit id="5e0b8aa15aad848de36cf3fd23d80803845b78d5" translate="yes" xml:space="preserve">
          <source>ver</source>
          <target state="translated">ver</target>
        </trans-unit>
        <trans-unit id="3a4dc0c486f7ec2c6e9ab752e3ce6d8bf47f6d1c" translate="yes" xml:space="preserve">
          <source>verbatim paragraphs, but</source>
          <target state="translated">逐字段,但</target>
        </trans-unit>
        <trans-unit id="c692273deb2772da307ffe37041fef77bf4baa97" translate="yes" xml:space="preserve">
          <source>version</source>
          <target state="translated">version</target>
        </trans-unit>
        <trans-unit id="d3b94753b152e0687bf16e0e66bde6c46129e227" translate="yes" xml:space="preserve">
          <source>version 0.2304</source>
          <target state="translated">0.2304版</target>
        </trans-unit>
        <trans-unit id="10ac6ea1ff9c002c30c590cc6d63a98d39a0b85d" translate="yes" xml:space="preserve">
          <source>version 1.4414</source>
          <target state="translated">1.4414版</target>
        </trans-unit>
        <trans-unit id="76c801534aba92a44e1c434c81eb16f53ac7ddba" translate="yes" xml:space="preserve">
          <source>version 1.70</source>
          <target state="translated">1.70版</target>
        </trans-unit>
        <trans-unit id="50dd6edfb9d761a98efb572f5834520db1b98413" translate="yes" xml:space="preserve">
          <source>version 3.1, this means configuring with &lt;code&gt;-Doptimize=-g3&lt;/code&gt; . Other compilers might use a different switch (if they support debugging macros at all).</source>
          <target state="translated">版本3.1，这意味着使用 &lt;code&gt;-Doptimize=-g3&lt;/code&gt; 进行配置。其他编译器可能会使用其他开关（如果它们完全支持调试宏）。</target>
        </trans-unit>
        <trans-unit id="6d8e3493b0cc6a16d5dae9adf9f2dd0db64b3340" translate="yes" xml:space="preserve">
          <source>version 5.021009</source>
          <target state="translated">5.021009版</target>
        </trans-unit>
        <trans-unit id="44d2f7e0b9f8b8f230b98d6215f70ce9e9142a5e" translate="yes" xml:space="preserve">
          <source>version mismatch</source>
          <target state="translated">版本不匹配</target>
        </trans-unit>
        <trans-unit id="e6d98fbd6e1f722af1a7187d887c11be3eebc59e" translate="yes" xml:space="preserve">
          <source>version number to standard output, then exits.</source>
          <target state="translated">版本号为标准输出,然后退出。</target>
        </trans-unit>
        <trans-unit id="753706ebef33a950942786467c39030e3338394b" translate="yes" xml:space="preserve">
          <source>version of documentation (&lt;b&gt;very&lt;/b&gt; recommended) outside of OS/2, one needs an IBM's reader (may be available on IBM ftp sites (?) (URL anyone?)) or shipped with PC DOS 7.0 and IBM's Visual Age C++ 3.5.</source>
          <target state="translated">版本OS / 2之外的文档版本（&lt;b&gt;强烈&lt;/b&gt;建议），需要IBM的阅读器（可能在IBM ftp站点上可用（？）（URL是否可用？））或PC DOS 7.0和IBM的Visual Age C ++ 3.5附带。</target>
        </trans-unit>
        <trans-unit id="8debcc6e279c738f85bcad06098d11cd2de6baac" translate="yes" xml:space="preserve">
          <source>version of the callback with the same args, or if the f is invalid, set errno to EBADF and return</source>
          <target state="translated">的回调版本,如果f无效,则将errno设为EBADF并返回</target>
        </trans-unit>
        <trans-unit id="da458f9f51eff82b9638d6edc4d1ce471a6ba279" translate="yes" xml:space="preserve">
          <source>version of the callback with the same args, or if the f is invalid, set errno to EBADF.</source>
          <target state="translated">的回调版本,如果f无效,则设置errno为EBADF。</target>
        </trans-unit>
        <trans-unit id="89ea6fd5613838ed30c0baa85610d353411b9790" translate="yes" xml:space="preserve">
          <source>version/</source>
          <target state="translated">version/</target>
        </trans-unit>
        <trans-unit id="636593de67e783331b57ae2dba0e1181ac91cb43" translate="yes" xml:space="preserve">
          <source>version/archname/</source>
          <target state="translated">version/archname/</target>
        </trans-unit>
        <trans-unit id="278658a67f306172b28c147dd5c2b59021a8cb9c" translate="yes" xml:space="preserve">
          <source>versiononly.U</source>
          <target state="translated">versiononly.U</target>
        </trans-unit>
        <trans-unit id="95280caf11d86c580985b1777a2534b60278693b" translate="yes" xml:space="preserve">
          <source>versus/csh.whynot</source>
          <target state="translated">versus/csh.whynot</target>
        </trans-unit>
        <trans-unit id="e74295bfc2ed0b52d40073e8ebad555100df1380" translate="yes" xml:space="preserve">
          <source>very</source>
          <target state="translated">very</target>
        </trans-unit>
        <trans-unit id="81cacac029430830dfca23f87b705db6949c1ea0" translate="yes" xml:space="preserve">
          <source>very same place</source>
          <target state="translated">一地鸡毛</target>
        </trans-unit>
        <trans-unit id="f2e6aa26ddeffa0689780c36cd916b4d3bb69f77" translate="yes" xml:space="preserve">
          <source>very simple</source>
          <target state="translated">很简单</target>
        </trans-unit>
        <trans-unit id="efbea1089258378284b4c64dc60908c3c6b4f3b3" translate="yes" xml:space="preserve">
          <source>vfork.h</source>
          <target state="translated">vfork.h</target>
        </trans-unit>
        <trans-unit id="833da188871dde4c49e08271ff3deff524b7992c" translate="yes" xml:space="preserve">
          <source>vi</source>
          <target state="translated">vi</target>
        </trans-unit>
        <trans-unit id="a19e070e30616772d5e5bccf22dd825266237820" translate="yes" xml:space="preserve">
          <source>via</source>
          <target state="translated">via</target>
        </trans-unit>
        <trans-unit id="3b741f8124ff9a5cff40f1444836353cc05d2208" translate="yes" xml:space="preserve">
          <source>via &lt;code&gt;sh.exe&lt;/code&gt; via &lt;code&gt;perl.exe&lt;/code&gt; , but this is a price to pay if you want to use non-conforming program.</source>
          <target state="translated">通过 &lt;code&gt;sh.exe&lt;/code&gt; 通过 &lt;code&gt;perl.exe&lt;/code&gt; ，但这是您要使用不合格程序时要付出的代价。</target>
        </trans-unit>
        <trans-unit id="3b68c8b6949fa7692f33f6e0bbc33b71066897e0" translate="yes" xml:space="preserve">
          <source>via pointers</source>
          <target state="translated">通过指针</target>
        </trans-unit>
        <trans-unit id="65f7d47d7029da85cdba5bc94831dbaa426ce6e5" translate="yes" xml:space="preserve">
          <source>via shell</source>
          <target state="translated">经壳</target>
        </trans-unit>
        <trans-unit id="f1e73a24ed2cd61923e64ac891a0cf0355e98da1" translate="yes" xml:space="preserve">
          <source>vianame() normally returns an ordinal code point, but when the input name is of the form &lt;code&gt;U+...&lt;/code&gt; , it returns a chr instead. In this case, if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; is in effect and the character won't fit into a byte, it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and raises a warning.</source>
          <target state="translated">vianame（）通常返回一个序号代码点，但是当输入名称的格式为 &lt;code&gt;U+...&lt;/code&gt; 时，它将返回一个chr。在这种情况下，如果 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 有效，并且字符不能容纳在字节中，则它将返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 并发出警告。</target>
        </trans-unit>
        <trans-unit id="857a269ccef5d7fbbb98d9ddef77bc0b5d9701a9" translate="yes" xml:space="preserve">
          <source>vice versa</source>
          <target state="translated">反之亦然</target>
        </trans-unit>
        <trans-unit id="af84d91fde168566c7dc18f3121ea2fbe651af1f" translate="yes" xml:space="preserve">
          <source>virtual</source>
          <target state="translated">virtual</target>
        </trans-unit>
        <trans-unit id="273d3211f66d3ed5bfd77d7571871ddef64f03b6" translate="yes" xml:space="preserve">
          <source>virtual time</source>
          <target state="translated">虚拟时间</target>
        </trans-unit>
        <trans-unit id="fd9d67fe1b466b2dd61a9d25c1346a7e24941513" translate="yes" xml:space="preserve">
          <source>vms/</source>
          <target state="translated">vms/</target>
        </trans-unit>
        <trans-unit id="92e911c38db62b637631e5e6d4e2f54b71f1b1ec" translate="yes" xml:space="preserve">
          <source>vmsish</source>
          <target state="translated">vmsish</target>
        </trans-unit>
        <trans-unit id="b6f4b16934c4d0ae88fbb45f248668506c1e515a" translate="yes" xml:space="preserve">
          <source>vmsish - Perl pragma to control VMS-specific language features</source>
          <target state="translated">vmsish-用于控制VMS特定语言功能的Perl pragma。</target>
        </trans-unit>
        <trans-unit id="47c9b6c34c34bb84a495fafd2ac449b137a21fcf" translate="yes" xml:space="preserve">
          <source>vmsperl list, vmsperl-subscribe@perl.org</source>
          <target state="translated">vmsperl清单,vmsperl-subscribe@perl.org</target>
        </trans-unit>
        <trans-unit id="43e59f877b6e30149c0ab30290dad796aad04379" translate="yes" xml:space="preserve">
          <source>vmsperl on the web, &lt;a href=&quot;http://www.sidhe.org/vmsperl/index.html&quot;&gt;http://www.sidhe.org/vmsperl/index.html&lt;/a&gt;</source>
          <target state="translated">网上的vmsperl，&lt;a href=&quot;http://www.sidhe.org/vmsperl/index.html&quot;&gt;http：//www.sidhe.org/vmsperl/index.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9cede9b80ea3abd89c755f1117337d429162c86" translate="yes" xml:space="preserve">
          <source>void</source>
          <target state="translated">void</target>
        </trans-unit>
        <trans-unit id="9901ea7bc50240c07dbde1f94425cb15aba6f905" translate="yes" xml:space="preserve">
          <source>volume names</source>
          <target state="translated">卷名</target>
        </trans-unit>
        <trans-unit id="aff024fe4ab0fece4091de044c58c9ae4233383a" translate="yes" xml:space="preserve">
          <source>w</source>
          <target state="translated">w</target>
        </trans-unit>
        <trans-unit id="daaad336276d15594d0e765f96c17cd746bf4971" translate="yes" xml:space="preserve">
          <source>wait</source>
          <target state="translated">wait</target>
        </trans-unit>
        <trans-unit id="16599a2caf0e43357dfd62cf1bbedac5d4f9aa78" translate="yes" xml:space="preserve">
          <source>wait() and waitpid() can be passed a pseudo-process ID returned by fork(). These calls will properly wait for the termination of the pseudo-process and return its status.</source>
          <target state="translated">wait()和waitpid()可以传递一个由fork()返回的伪进程ID。这些调用将适当地等待伪进程的终止,并返回其状态。</target>
        </trans-unit>
        <trans-unit id="69c29097cb967e595fc1da3e699aa0f1c4465d43" translate="yes" xml:space="preserve">
          <source>wait(2)</source>
          <target state="translated">wait(2)</target>
        </trans-unit>
        <trans-unit id="2adada1e71a33f071825f68863aa78076956f91c" translate="yes" xml:space="preserve">
          <source>waitpid</source>
          <target state="translated">waitpid</target>
        </trans-unit>
        <trans-unit id="7a5601dcd3b6db75e71ed2908ce3b9fba9edaa57" translate="yes" xml:space="preserve">
          <source>waitpid PID,FLAGS</source>
          <target state="translated">waitpid PID,FLAGS</target>
        </trans-unit>
        <trans-unit id="33a4d790db96047d8f48435d61872442016da10a" translate="yes" xml:space="preserve">
          <source>waitpid(3)</source>
          <target state="translated">waitpid(3)</target>
        </trans-unit>
        <trans-unit id="4a714f64e3698739073c4107159d7e2ec7580a59" translate="yes" xml:space="preserve">
          <source>wallclock time</source>
          <target state="translated">挂钟时间</target>
        </trans-unit>
        <trans-unit id="36fae1179f0e54b2fbcfa0e1e58a96822af50f7c" translate="yes" xml:space="preserve">
          <source>want a record separator of 0777, specify it as &lt;b&gt;-0x1FF&lt;/b&gt;. (This means that you cannot use the &lt;b&gt;-x&lt;/b&gt; option with a directory name that consists of hexadecimal digits, or else Perl will think you have specified a hex number to &lt;b&gt;-0&lt;/b&gt;.)</source>
          <target state="translated">想要0777的记录分隔符，请将其指定为&lt;b&gt;-0x1FF&lt;/b&gt;。（这意味着您不能将&lt;b&gt;-x&lt;/b&gt;选项与包含十六进制数字的目录名称一起使用，否则Perl会认为您已将十六进制数字指定为&lt;b&gt;-0&lt;/b&gt;。）</target>
        </trans-unit>
        <trans-unit id="fa1de8a88193794f6bcd0270bd3c78df8da87f33" translate="yes" xml:space="preserve">
          <source>want locks to block access, then go ahead and tie them to something and manage this yourself. This is done on purpose. While managing access to variables is a good thing, Perl doesn't force you out of its living room...</source>
          <target state="translated">想让锁阻挡访问,那就去把它们绑在某样东西上,自己管理。这样做是有目的的。虽然管理对变量的访问是件好事,但Perl并没有强迫你离开它的客厅......</target>
        </trans-unit>
        <trans-unit id="42f9df8dd43a1cbf03eed19f45b2ac004af68f76" translate="yes" xml:space="preserve">
          <source>want to follow an &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; with some other statement, you can use one of these styles to avoid the warning:</source>
          <target state="translated">要遵循的 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 与其他一些说法，你可以使用这些样式之一，以避免该警告：</target>
        </trans-unit>
        <trans-unit id="1be38d5f877aab6abdfed0efc178920ad9fb017d" translate="yes" xml:space="preserve">
          <source>want to follow an &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; with some other statement, you can use one of these styles to avoid the warning:</source>
          <target state="translated">要遵循的 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 与其他一些说法，你可以使用这些样式之一，以避免该警告：</target>
        </trans-unit>
        <trans-unit id="b18cfd0bd3a597bb757ac9a15224a9fadf94a687" translate="yes" xml:space="preserve">
          <source>want to make the same transformation to all keys and/or values in a DBM database.</source>
          <target state="translated">想要对DBM数据库中的所有键和/或值进行相同的转换。</target>
        </trans-unit>
        <trans-unit id="8898e1e919ff199c09160ba3765d7cb61b031b32" translate="yes" xml:space="preserve">
          <source>want to make the same transformation to all keys, all values or both.</source>
          <target state="translated">想要对所有键、所有值或两者进行相同的转换。</target>
        </trans-unit>
        <trans-unit id="80f812f0ab1052c34ba58a9aa6c43451d87573ad" translate="yes" xml:space="preserve">
          <source>want to subclass &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt;'s grammar the best thing to do is read through the code. There's no easy way of summarizing it here.</source>
          <target state="translated">想要将&lt;a href=&quot;../parser&quot;&gt;TAP :: Parser&lt;/a&gt;的语法子类化，最好的办法是阅读代码。这里没有简单的总结方法。</target>
        </trans-unit>
        <trans-unit id="76f51d192120dd11344a546a620674d65ea15871" translate="yes" xml:space="preserve">
          <source>wantarray</source>
          <target state="translated">wantarray</target>
        </trans-unit>
        <trans-unit id="77921eed5c933c5cd87a4b266d8972f000e6983e" translate="yes" xml:space="preserve">
          <source>wanted()</source>
          <target state="translated">wanted()</target>
        </trans-unit>
        <trans-unit id="5383092a76f9a7f2052899ae6bf06e0ebac04977" translate="yes" xml:space="preserve">
          <source>wants</source>
          <target state="translated">wants</target>
        </trans-unit>
        <trans-unit id="4e586b17a78dad3ec40f5515d1f0072bbcf17f64" translate="yes" xml:space="preserve">
          <source>wants to succeed, so it uses the standard pattern back-off-and-retry and lets &lt;code&gt;\D*&lt;/code&gt; expand to just &quot;AB&quot; this time. Now there's indeed something following &quot;AB&quot; that is not &quot;123&quot;. It's &quot;C123&quot;, which suffices.</source>
          <target state="translated">希望成功，因此它使用标准模式后退并重试，这次让 &lt;code&gt;\D*&lt;/code&gt; 扩展为仅&amp;ldquo; AB&amp;rdquo;。现在，在&amp;ldquo; AB&amp;rdquo;后面确实有一个不是&amp;ldquo; 123&amp;rdquo;的东西。足够了。</target>
        </trans-unit>
        <trans-unit id="4c8ea4760fcb5dff8ec1af0394a338be9df55090" translate="yes" xml:space="preserve">
          <source>warn</source>
          <target state="translated">warn</target>
        </trans-unit>
        <trans-unit id="dd055b1e3e77f358b39e3dcec164c30e81c00105" translate="yes" xml:space="preserve">
          <source>warn LIST</source>
          <target state="translated">警告列表</target>
        </trans-unit>
        <trans-unit id="3f4c20cf2e4f20443c501790a359300f5f40529f" translate="yes" xml:space="preserve">
          <source>warning messages. These messages will be displayed by default. But this is not the same as &lt;code&gt;verbose&lt;/code&gt; mode.</source>
          <target state="translated">警告消息。这些消息将默认显示。但这与 &lt;code&gt;verbose&lt;/code&gt; 模式不同。</target>
        </trans-unit>
        <trans-unit id="9f6be01127af67b499b57da0fae72ba37a45a9a4" translate="yes" xml:space="preserve">
          <source>warning.</source>
          <target state="translated">warning.</target>
        </trans-unit>
        <trans-unit id="bd207fab08951eb6cee30e4969e79ca50d1f7c65" translate="yes" xml:space="preserve">
          <source>warnings</source>
          <target state="translated">warnings</target>
        </trans-unit>
        <trans-unit id="69788f5b932d69519f6c6fa630facec7b52027c8" translate="yes" xml:space="preserve">
          <source>warnings. The difference is that although the previously mandatory warnings are still enabled by default, they can then be subsequently enabled or disabled with the lexical warning pragma. For example, in the code below, an &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; warning will only be reported for the &lt;code&gt;$a&lt;/code&gt; variable.</source>
          <target state="translated">警告。区别在于，尽管默认情况下仍会启用以前的强制性警告，但随后可以使用词汇警告语用来启用或禁用它们。例如，在下面的代码中，只会为 &lt;code&gt;$a&lt;/code&gt; 变量报告 &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="25304d614db590d11bde4fb00d1385306732fa04" translate="yes" xml:space="preserve">
          <source>warnings::register</source>
          <target state="translated">warnings::register</target>
        </trans-unit>
        <trans-unit id="38c5e56d56c5509ef7afa87cb247e50311f9a294" translate="yes" xml:space="preserve">
          <source>warnings::register - warnings import function</source>
          <target state="translated">warnings::register-warnings导入函数</target>
        </trans-unit>
        <trans-unit id="3de521d3619155e9228f83cc5f773bfcbfc52749" translate="yes" xml:space="preserve">
          <source>was</source>
          <target state="translated">was</target>
        </trans-unit>
        <trans-unit id="f062dc50293a6ebef0644413f16dbe666de1a1ed" translate="yes" xml:space="preserve">
          <source>was available through the &lt;code&gt;Thread.pm&lt;/code&gt; API. This threading model has been deprecated, and was removed as of Perl 5.10.0.)</source>
          <target state="translated">可通过 &lt;code&gt;Thread.pm&lt;/code&gt; API获得。该线程模型已被弃用，并从Perl 5.10.0开始删除。）</target>
        </trans-unit>
        <trans-unit id="1f19bc6bea19581bc44bbfb345e232346246a9a6" translate="yes" xml:space="preserve">
          <source>was called without options, but with the additional behaviour that the temporary file is removed by the object destructor if UNLINK is set to true (the default).</source>
          <target state="translated">在没有选项的情况下被调用,但有一个额外的行为,即如果UNLINK被设置为true(默认值),临时文件将被对象分解器删除。</target>
        </trans-unit>
        <trans-unit id="f83d8fcf9f9f581aff720bc3d0f0345f5631b7ae" translate="yes" xml:space="preserve">
          <source>was changed to return some value(s), having specified G_DISCARD will mean that they will be wiped by the time control returns from</source>
          <target state="translated">改为返回一些值,如果指定了G_DISCARD,则意味着这些值将在控制返回时被清除。</target>
        </trans-unit>
        <trans-unit id="358b1b390577816773119471fd35f58a152fe39c" translate="yes" xml:space="preserve">
          <source>was deliberately picked to avoid namespace tainting -- this module may be used as a base class so method names that appear in Encode::Encoding are avoided.</source>
          <target state="translated">被特意挑选出来,以避免命名空间的污染 --这个模块可以被用作基类,因此可以避免出现在 Encode::Encoding 中的方法名。</target>
        </trans-unit>
        <trans-unit id="4ef5ff209fb64ad33c3a43e09b9777f546e6d687" translate="yes" xml:space="preserve">
          <source>was disabled, IO::Zlib has not much chance of working.</source>
          <target state="translated">被禁用,IO::Zlib的工作机会不大。</target>
        </trans-unit>
        <trans-unit id="cc39726c2752bbbdac1623dec16d2ec7ec5530fe" translate="yes" xml:space="preserve">
          <source>was modified after creation. Note that if a temp directory is your current directory, it cannot be removed - a warning will be given in this case. C</source>
          <target state="translated">在创建后被修改。请注意,如果临时目录是您的当前目录,则不能将其删除--在这种情况下,会给出一个警告。C</target>
        </trans-unit>
        <trans-unit id="1c2cacfa9911a9740c2f39057d9556ce6e3a53b2" translate="yes" xml:space="preserve">
          <source>was not built, user must have HOST perl and properly edit</source>
          <target state="translated">没有建立,用户必须有HOST perl并正确编辑</target>
        </trans-unit>
        <trans-unit id="e1a5fcfd7b191fc7b62fed25dba309a60f6a62f6" translate="yes" xml:space="preserve">
          <source>was used to invoke native compiler to create HOST miniperl, which then facilitates cross-compiling process. Extension building support was added.</source>
          <target state="translated">用于调用本地编译器来创建HOST miniperl,从而方便了交叉编译过程。增加了对扩展构建的支持。</target>
        </trans-unit>
        <trans-unit id="66ffd23620129e551f53385e61617103184d89ce" translate="yes" xml:space="preserve">
          <source>was written, not even Perl 5.6.0 had been born yet, many features documented in the book remained unimplemented for a long time. Perl 5.8 corrected much of this, and the introduction of the UTF8 flag is one of them. You can think of there being two fundamentally different kinds of strings and string-operations in Perl: one a byte-oriented mode for when the internal UTF8 flag is off, and the other a character-oriented mode for when the internal UTF8 flag is on.</source>
          <target state="translated">写成的时候,甚至连Perl 5.6.0都还没有诞生,书中记录的很多功能在很长一段时间内都没有实现。Perl 5.8修正了很多,UTF8标志的引入就是其中之一。你可以认为在Perl中存在两种根本不同的字符串和字符串操作:一种是当内部UTF8标志关闭时的面向字节的模式,另一种是当内部UTF8标志打开时的面向字符的模式。</target>
        </trans-unit>
        <trans-unit id="181b4dd436ea635e496b642bf6193eba9531e9f5" translate="yes" xml:space="preserve">
          <source>wasn't installed or doesn't work for you, you can</source>
          <target state="translated">没有安装或不适合您,您可</target>
        </trans-unit>
        <trans-unit id="146b5dae12284acb165c37a9e39cd9753cbc537e" translate="yes" xml:space="preserve">
          <source>wc</source>
          <target state="translated">wc</target>
        </trans-unit>
        <trans-unit id="3fe0dfef3d9b02dc86d540b75c78abe297bdb20e" translate="yes" xml:space="preserve">
          <source>we can write the more sensible (see &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; for a full explanation of is() and other testing functions).</source>
          <target state="translated">我们可以编写更明智的代码（&lt;a href=&quot;test/more&quot;&gt;有关&lt;/a&gt; is（）和其他测试函数的完整说明，请参见Test :: More）。</target>
        </trans-unit>
        <trans-unit id="85ea3c732a0cadb4cba11f8084adbc162ad146ff" translate="yes" xml:space="preserve">
          <source>we prevent backtracking and find the count of the longest matching string at each matching starting point like so:</source>
          <target state="translated">我们防止回溯,在每个匹配起点处找到最长的匹配字符串的计数,像这样。</target>
        </trans-unit>
        <trans-unit id="3d0b0b7bc297d97e84595de72ecb8a0030fdd17e" translate="yes" xml:space="preserve">
          <source>we've checked all its derived classes (i.e. before we tried &lt;code&gt;Mother&lt;/code&gt; and &lt;code&gt;MaternalGrandparent&lt;/code&gt; ).</source>
          <target state="translated">我们已经检查了所有派生类（即，在尝试过 &lt;code&gt;Mother&lt;/code&gt; 和 &lt;code&gt;MaternalGrandparent&lt;/code&gt; 之前）。</target>
        </trans-unit>
        <trans-unit id="fcb9e7c68cc7aee9b7ae828bf3eb4f0c0ab95fcd" translate="yes" xml:space="preserve">
          <source>weaken</source>
          <target state="translated">weaken</target>
        </trans-unit>
        <trans-unit id="ae27e6a12247433968a2426ceb5f2faec9f64b2d" translate="yes" xml:space="preserve">
          <source>webget</source>
          <target state="translated">webget</target>
        </trans-unit>
        <trans-unit id="79b1646e47722f151fadfe6b4b9cfd75b5507a18" translate="yes" xml:space="preserve">
          <source>week number</source>
          <target state="translated">周数</target>
        </trans-unit>
        <trans-unit id="b6894b43bb03af96eabb423701dc0bc9e071a3e0" translate="yes" xml:space="preserve">
          <source>were affected. This leads to spooky, incorrect action at a distance that is hard to debug.</source>
          <target state="translated">受到影响。这就导致了远距离的诡异、不正确的动作,很难调试。</target>
        </trans-unit>
        <trans-unit id="0a8fc1dcdcb951afef794f96428b2c2d30d4cbdd" translate="yes" xml:space="preserve">
          <source>were fine, but the hard ones like</source>
          <target state="translated">是好的,但难的,如</target>
        </trans-unit>
        <trans-unit id="b3e74349971aeb0151fc1bfbab7d483e124b80fe" translate="yes" xml:space="preserve">
          <source>were merged, so perlce build process comes in</source>
          <target state="translated">合并了,所以perlce的构建过程是在</target>
        </trans-unit>
        <trans-unit id="9421eaaa36860a069e3089b1dd32635567692a1f" translate="yes" xml:space="preserve">
          <source>were the command shell, this would probably work better:</source>
          <target state="translated">是命令壳,这可能会更好。</target>
        </trans-unit>
        <trans-unit id="a110e6b9a361653a042e3f5dfbac4c6105693789" translate="yes" xml:space="preserve">
          <source>what</source>
          <target state="translated">what</target>
        </trans-unit>
        <trans-unit id="5028edf30c355a53744774edb4e246a65bdda7eb" translate="yes" xml:space="preserve">
          <source>what &lt;code&gt;File::GlobMapper&lt;/code&gt; does.</source>
          <target state="translated">什么 &lt;code&gt;File::GlobMapper&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="b36160c1ec6399ee58f1e1eaed45b1a11a29091d" translate="yes" xml:space="preserve">
          <source>what follows, it just leaves the choice open. Thus, after</source>
          <target state="translated">下面的内容,只是让人选择。因此,在</target>
        </trans-unit>
        <trans-unit id="235cc5e25df726ef139cc4e3ed273f18953c310e" translate="yes" xml:space="preserve">
          <source>what it does</source>
          <target state="translated">它的作用</target>
        </trans-unit>
        <trans-unit id="9a97de175ae265b931e0f47d8189ba1c158846c3" translate="yes" xml:space="preserve">
          <source>what you want to use to capture the output from a command; for that you should use merely backticks or &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;, as described in &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt;. Return value of -1 indicates a failure to start the program or an error of the wait(2) system call (inspect $! for the reason).</source>
          <target state="translated">您想用来捕获命令输出的内容；为此，您应该仅使用反引号或 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; ，如&lt;a href=&quot;perlop#%60STRING%60&quot;&gt;perlop中的&amp;ldquo; STRING&amp;rdquo;中所述&lt;/a&gt;。返回值-1表示无法启动程序或系统调用wait（2）时出错（原因是检查$！）。</target>
        </trans-unit>
        <trans-unit id="3926fc849cd226411c2dc28dbb3c1ac9425d41ae" translate="yes" xml:space="preserve">
          <source>what you want to use to capture the output from a command; for that you should use merely backticks or &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;, as described in &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt;. Return value of -1 indicates a failure to start the program or an error of the wait(2) system call (inspect $! for the reason).</source>
          <target state="translated">您想用来捕获命令输出的内容；为此，您应该仅使用反引号或 &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; ，如&lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;perlop中的&amp;ldquo; STRING&amp;rdquo;中所述&lt;/a&gt;。返回值-1表示无法启动程序或系统调用wait（2）时出错（原因是检查$！）。</target>
        </trans-unit>
        <trans-unit id="2a01f2e26cea4a9807d9d068afa0bdc36ba5e00e" translate="yes" xml:space="preserve">
          <source>what you're doing, you can use the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers to force big- or little-endian byte-order on floating-point values.</source>
          <target state="translated">在执行操作时，可以使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&lt;/code&gt; 修饰符在浮点值上强制使用大端或小端字节顺序。</target>
        </trans-unit>
        <trans-unit id="d869db7fe62fb07c25a0403ecaea55031744b5fb" translate="yes" xml:space="preserve">
          <source>whatever</source>
          <target state="translated">whatever</target>
        </trans-unit>
        <trans-unit id="021bc9488a6a6118c1c75c3f7a5aeeaa12491ccd" translate="yes" xml:space="preserve">
          <source>whatever falls between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; 和 &lt;code&gt;\E&lt;/code&gt; 之间的任何值</target>
        </trans-unit>
        <trans-unit id="30603fa9e0f620c305cd627ab0ff138a960c48bd" translate="yes" xml:space="preserve">
          <source>when</source>
          <target state="translated">when</target>
        </trans-unit>
        <trans-unit id="ed6268873901e8209d3ac22fc700c31706eaa9bd" translate="yes" xml:space="preserve">
          <source>when &quot;dumping&quot;; it has nothing to do with $| auto-flush.)</source>
          <target state="translated">当 &quot;转储 &quot;时,它与$|自动刷新无关)。)</target>
        </trans-unit>
        <trans-unit id="c89dac7f6e160306ca10f788c9bd6a54efcd1ffc" translate="yes" xml:space="preserve">
          <source>when &lt;code&gt;xsubpp&lt;/code&gt; is invoked with &lt;code&gt;-s foo_&lt;/code&gt; will install a &lt;code&gt;foo_bar&lt;/code&gt; function in Perl, but really call &lt;code&gt;bar(i)&lt;/code&gt; in C. Most of the time, this is the opposite of what you want and failure modes are somewhat obscure, so please avoid this option where possible.</source>
          <target state="translated">当用 &lt;code&gt;-s foo_&lt;/code&gt; 调用 &lt;code&gt;xsubpp&lt;/code&gt; 时，foo_将在Perl中安装一个 &lt;code&gt;foo_bar&lt;/code&gt; 函数，但实际上在C中调用 &lt;code&gt;bar(i)&lt;/code&gt; 。在大多数情况下，这与您想要的相反，并且失败模式有些模糊，因此请避免这种情况选择在可能的情况下。</target>
        </trans-unit>
        <trans-unit id="75aed76d9314bc923e71101c151f2b2893f266e7" translate="yes" xml:space="preserve">
          <source>when another process is holding the lockfile. This is an experimental feature that is not yet tested very well. This second shell then does not write the history file, does not use the metadata file, and has a different prompt.</source>
          <target state="translated">当另一个进程持有锁文件时。这是一个实验性的功能,还没有很好的测试。然后,第二个shell不写历史文件,不使用元数据文件,并且有不同的提示。</target>
        </trans-unit>
        <trans-unit id="ba1a27d93b87aa252d9684f7f42d0351ba582ec5" translate="yes" xml:space="preserve">
          <source>when necessary.</source>
          <target state="translated">必要时。</target>
        </trans-unit>
        <trans-unit id="3cd9d2e738a8b92221411f890d0e1eb0c5e3b660" translate="yes" xml:space="preserve">
          <source>when the element to return happens to be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当要返回的元素恰好是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="7b023844c7b290ca1a038802a6472c7aeafce41c" translate="yes" xml:space="preserve">
          <source>when the element to return happens to be &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当要返回的元素恰好是 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="938c56ff8ee83ab6578974df30b9d1c7e33fe7dd" translate="yes" xml:space="preserve">
          <source>when the functions are called from within the scope of the &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt; pragma</source>
          <target state="translated">当功能被从内称为的范围 &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt; 编译</target>
        </trans-unit>
        <trans-unit id="8ce6402418c47b212eb07ca370a93108ff150f4a" translate="yes" xml:space="preserve">
          <source>when the imaginary part is zero (otherwise, it would not be called an extension, would it?).</source>
          <target state="translated">当虚部为零时(否则,就不叫扩展了,对吧)。</target>
        </trans-unit>
        <trans-unit id="eb1cef34e0771ae508dd63618b6d7ebc545d708d" translate="yes" xml:space="preserve">
          <source>when this tutorial was written. It has now been split off with &lt;code&gt;pp_unpack&lt;/code&gt; to its own file,</source>
          <target state="translated">本教程编写时。现在，已使用 &lt;code&gt;pp_unpack&lt;/code&gt; 将其拆分为自己的文件，</target>
        </trans-unit>
        <trans-unit id="ac26161b0187ead053283bca27ee59e832cfa160" translate="yes" xml:space="preserve">
          <source>when you ask for</source>
          <target state="translated">当你要求</target>
        </trans-unit>
        <trans-unit id="3e5e701932ff1e08475464ba8b75ee91dc43d41c" translate="yes" xml:space="preserve">
          <source>when you intended</source>
          <target state="translated">当你</target>
        </trans-unit>
        <trans-unit id="6e06c432fa349d548f06ebf0f8b460c130ec25ac" translate="yes" xml:space="preserve">
          <source>when you meant</source>
          <target state="translated">当你的意思是</target>
        </trans-unit>
        <trans-unit id="320723f30d494b8eb54e4b744bfd8f4219fbd71c" translate="yes" xml:space="preserve">
          <source>when you meant to say</source>
          <target state="translated">当你想说</target>
        </trans-unit>
        <trans-unit id="0b09f6864ed10d92f6a10d3420ae332e50823d21" translate="yes" xml:space="preserve">
          <source>when you should have said</source>
          <target state="translated">你应该说</target>
        </trans-unit>
        <trans-unit id="bfe41b37d5bad835ce1295749ffd97e4c9fffaac" translate="yes" xml:space="preserve">
          <source>when you should have written this:</source>
          <target state="translated">当你应该写这个。</target>
        </trans-unit>
        <trans-unit id="46148cc3b4d2b3ac8073f14b0cba7f25ffff54bd" translate="yes" xml:space="preserve">
          <source>where</source>
          <target state="translated">where</target>
        </trans-unit>
        <trans-unit id="ab1c267bd23a7a2761e1a1311799eacd65a53cf8" translate="yes" xml:space="preserve">
          <source>where &quot;ENCODING&quot; must be a valid encoding name that the Encode module recognises.</source>
          <target state="translated">其中 &quot;ENCODING &quot;必须是Encode模块能够识别的有效编码名称。</target>
        </trans-unit>
        <trans-unit id="3f76ee4872ba64c6359656344e5d58fab47ab470" translate="yes" xml:space="preserve">
          <source>where $MAKE is whatever 'make' program you have configured perl to use. Use &quot;perl -V:make&quot; to find out what this is. Some extensions may not provide a testsuite (so &quot;$MAKE test&quot; may not do anything or fail), but most serious ones do.</source>
          <target state="translated">其中 $MAKE 是你配置 perl 使用的任何 'make' 程序。使用 &quot;perl -V:make &quot;来找出这个程序。一些扩展可能不提供测试套件 (所以&quot;$MAKE test &quot;可能什么都不做或者失败),但是大多数严肃的扩展都会提供。</target>
        </trans-unit>
        <trans-unit id="c8069144ce0898197e96d2bb7ebc0edbdaca8457" translate="yes" xml:space="preserve">
          <source>where $term is a return value of Term::ReadLine-&amp;gt;new().</source>
          <target state="translated">其中$ term是Term :: ReadLine-&amp;gt; new（）的返回值。</target>
        </trans-unit>
        <trans-unit id="b9c15a20c87c2836864971183b1c442723a838ac" translate="yes" xml:space="preserve">
          <source>where $x is either less than -128 or more than 127; the &lt;code&gt;&quot;c&quot;&lt;/code&gt; format is only for encoding native operating system characters (ASCII, EBCDIC, and so on) and not for Unicode characters, so Perl behaved as if you meant</source>
          <target state="translated">其中$ x小于-128或大于127; 在 &lt;code&gt;&quot;c&quot;&lt;/code&gt; 格式仅编码机操作系统字符（ASCII，EBCDIC，等等），而不是为Unicode字符，所以Perl的表现，就好像你的意思</target>
        </trans-unit>
        <trans-unit id="5bbc43aec00d96c64d05508ffb3bbad3e39afaec" translate="yes" xml:space="preserve">
          <source>where $x is either less than 0 or more than 255. However, &lt;code&gt;U0&lt;/code&gt; -mode expects all values to fall in the interval [0, 255], so Perl behaved as if you meant:</source>
          <target state="translated">其中$ x小于0或大于255。但是， &lt;code&gt;U0&lt;/code&gt; -mode期望所有值都落在区间[0，255]中，因此Perl的行为就像您的意思是：</target>
        </trans-unit>
        <trans-unit id="00bca38c6c6b0a3593705b287c03db33903d5e5f" translate="yes" xml:space="preserve">
          <source>where $x is either less than 0 or more than 255; the &lt;code&gt;&quot;C&quot;&lt;/code&gt; format is only for encoding native operating system characters (ASCII, EBCDIC, and so on) and not for Unicode characters, so Perl behaved as if you meant</source>
          <target state="translated">其中$ x小于0或大于255；在 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 格式仅编码机操作系统字符（ASCII，EBCDIC，等等），而不是为Unicode字符，所以Perl的表现，就好像你的意思</target>
        </trans-unit>
        <trans-unit id="890f9b49db55ce1098a844385610bbb13debaa4c" translate="yes" xml:space="preserve">
          <source>where 0x0400 stands for &lt;code&gt;U+0400&lt;/code&gt; , CYRILLIC CAPITAL LETTER IE WITH GRAVE.</source>
          <target state="translated">其中0x0400代表 &lt;code&gt;U+0400&lt;/code&gt; ，带有坟墓的西里尔大写字母IE。</target>
        </trans-unit>
        <trans-unit id="825d5d6d780f8829ebcd8a7016c279905b219a90" translate="yes" xml:space="preserve">
          <source>where 7E is the hexadecimal ASCII code point for &quot;~&quot;. Here is an example of decoding such a URL in any EBCDIC code page:</source>
          <target state="translated">其中7E是&quot;~&quot;的十六进制ASCII码点。下面是一个在任何EBCDIC码页面中解码这样一个URL的例子。</target>
        </trans-unit>
        <trans-unit id="d4809a830fe1a3429edeff7f9faf0dee554dbec4" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;$parser&lt;/code&gt; is a reference to the parser object, &lt;code&gt;$text&lt;/code&gt; is the text-string encountered, and &lt;code&gt;$ptree_node&lt;/code&gt; is a reference to the current node in the parse-tree (usually an interior-sequence object or else the top-level node of the parse-tree).</source>
          <target state="translated">其中 &lt;code&gt;$parser&lt;/code&gt; 是对解析器对象的引用， &lt;code&gt;$text&lt;/code&gt; 是遇到的文本字符串， &lt;code&gt;$ptree_node&lt;/code&gt; 是对解析树中的当前节点的引用（通常是内部序列对象，否则是该对象的顶级节点）解析树）。</target>
        </trans-unit>
        <trans-unit id="d298264d5947d99205d766cae90ed2313035af45" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;$parser&lt;/code&gt; is a reference to the parser object, and &lt;code&gt;$ptree&lt;/code&gt; is a reference to the parse-tree object.</source>
          <target state="translated">其中 &lt;code&gt;$parser&lt;/code&gt; 是对解析器对象的引用，而 &lt;code&gt;$ptree&lt;/code&gt; 是对解析树对象的引用。</target>
        </trans-unit>
        <trans-unit id="5957a8e4bc7c51d1071eb22f8fe1b48116af9153" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;$parser&lt;/code&gt; is a reference to the parser object, and &lt;code&gt;$sequence&lt;/code&gt; is a reference to the interior-sequence object. [</source>
          <target state="translated">其中 &lt;code&gt;$parser&lt;/code&gt; 是对解析器对象的引用，而 &lt;code&gt;$sequence&lt;/code&gt; 是对内部序列对象的引用。[</target>
        </trans-unit>
        <trans-unit id="15d410b2ce2184b4347be136da68a7719dc0ad85" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;$source&lt;/code&gt; is the filespec of the file being installed. &lt;code&gt;$target&lt;/code&gt; is where it is being installed to, and &lt;code&gt;$uninstalled&lt;/code&gt; is any shadow file that is in &lt;code&gt;@INC&lt;/code&gt; or &lt;code&gt;$ENV{PERL5LIB}&lt;/code&gt; or other standard locations, and &lt;code&gt;$pattern&lt;/code&gt; is the pattern that caused a source file to be skipped. In future more keys will be added, such as to show created directories, however this requires changes in other modules and must therefore wait.</source>
          <target state="translated">其中 &lt;code&gt;$source&lt;/code&gt; 是要安装的文件的filespec。 &lt;code&gt;$target&lt;/code&gt; 是安装位置， &lt;code&gt;$uninstalled&lt;/code&gt; 是 &lt;code&gt;@INC&lt;/code&gt; 或 &lt;code&gt;$ENV{PERL5LIB}&lt;/code&gt; 或其他标准位置中的任何影子文件，而 &lt;code&gt;$pattern&lt;/code&gt; 是导致跳过源文件的模式。将来会添加更多键，例如显示创建的目录，但是这需要更改其他模块，因此必须等待。</target>
        </trans-unit>
        <trans-unit id="a731b563e701bcb16a123ecab85071d224c107aa" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;$where_to_export&lt;/code&gt; is an integer telling how far up the calling stack to export your symbols, and &lt;code&gt;@what_to_export&lt;/code&gt; is an array telling what symbols *to* export (usually this is &lt;code&gt;@_&lt;/code&gt; ). The &lt;code&gt;$package&lt;/code&gt; argument is currently unused.</source>
          <target state="translated">其中 &lt;code&gt;$where_to_export&lt;/code&gt; 是一个整数，告诉您要导出符号的调用堆栈有多远，而 &lt;code&gt;@what_to_export&lt;/code&gt; 是告诉*要*导出哪些符号的数组（通常是 &lt;code&gt;@_&lt;/code&gt; ）。在 &lt;code&gt;$package&lt;/code&gt; 的说法是当前未使用。</target>
        </trans-unit>
        <trans-unit id="48e1c4094f5de010428575d8622f327516bc33ae" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;HERE&lt;/code&gt; can be replaced by other identifiers like with normal Perl HERE-docs. All details below about the typemap textual format remain valid.</source>
          <target state="translated">在 &lt;code&gt;HERE&lt;/code&gt; 可以用其他标识符代替，例如普通的Perl HERE-docs。下面有关类型图文本格式的所有详细信息仍然有效。</target>
        </trans-unit>
        <trans-unit id="721c549e68ff19e2994566a74f0b393f57d254d1" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;MyParser&lt;/code&gt; is some subclass of &lt;b&gt;Pod::Parser&lt;/b&gt;.</source>
          <target state="translated">其中 &lt;code&gt;MyParser&lt;/code&gt; 是&lt;b&gt;Pod :: Parser的&lt;/b&gt;某些子类。</target>
        </trans-unit>
        <trans-unit id="b03bee177daa8ad34db5c35f4571b92ff18e039c" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;SP&lt;/code&gt; is the macro that represents the local copy of the stack pointer, and &lt;code&gt;num&lt;/code&gt; is the number of elements the stack should be extended by.</source>
          <target state="translated">其中 &lt;code&gt;SP&lt;/code&gt; 是代表堆栈指针本地副本的宏，而 &lt;code&gt;num&lt;/code&gt; 是堆栈应扩展的元素数。</target>
        </trans-unit>
        <trans-unit id="de39703cfc1e976397e4c498b4e76e18c8f99017" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;a&lt;/code&gt; is the</source>
          <target state="translated">其中 &lt;code&gt;a&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="6950fd3c6bf4eda6d69d7afe08226888f67c407d" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;function&lt;/code&gt; is the name of the function you want to memoize, or a reference to it. &lt;code&gt;memoize&lt;/code&gt; returns a reference to the new, memoized version of the function, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on a non-fatal error. At present, there are no non-fatal errors, but there might be some in the future.</source>
          <target state="translated">其中 &lt;code&gt;function&lt;/code&gt; 是您要记住的函数的名称或对其的引用。 &lt;code&gt;memoize&lt;/code&gt; 返回对函数的新的，已记忆的版本的引用，或者对非致命错误进行 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。目前，还没有非致命错误，但将来可能会出现。</target>
        </trans-unit>
        <trans-unit id="9baeb27f249365fedd4a037a93595125d9a6014e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;rho&lt;/code&gt; is the distance to the origin, and &lt;code&gt;theta&lt;/code&gt; the angle between the vector and the</source>
          <target state="translated">其中 &lt;code&gt;rho&lt;/code&gt; 是到原点的距离， &lt;code&gt;theta&lt;/code&gt; 是矢量和</target>
        </trans-unit>
        <trans-unit id="fd9e76180b06bd2a44ffe663c1ff849e0a103ca7" translate="yes" xml:space="preserve">
          <source>where FALLBACK can take any of the three values TRUE, FALSE, or UNDEF. If you do not set any FALLBACK value when using OVERLOAD, it defaults to UNDEF. FALLBACK is not used except when one or more functions using OVERLOAD have been defined. Please see &lt;a href=&quot;overload#fallback&quot;&gt;fallback in overload&lt;/a&gt; for more details.</source>
          <target state="translated">其中FALLBACK可以采用三个值TRUE，FALSE或UNDEF中的任何一个。如果在使用OVERLOAD时未设置任何FALLBACK值，则默认为UNDEF。除非定义了一个或多个使用过载的功能，否则不使用FALLBACK。有关更多详细信息，请参见过&lt;a href=&quot;overload#fallback&quot;&gt;载后备&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50396b7e08b271e8034d662ba4fd67f410cb1b19" translate="yes" xml:space="preserve">
          <source>where a more complete solution would split the URL into components and apply a full s/// substitution only to the appropriate parts.</source>
          <target state="translated">其中,一个更完整的解决方案是将URL分割成几个部分,并只对适当的部分进行完整的s///替换。</target>
        </trans-unit>
        <trans-unit id="21585635f4365441aa2484d0f4019c953a7d7b86" translate="yes" xml:space="preserve">
          <source>where chr(0xff) is expected but the test fails because the result is chr(0xff). Exactly.</source>
          <target state="translated">其中chr(0xff)是预期的,但测试失败,因为结果是chr(0xff)。正是如此。</target>
        </trans-unit>
        <trans-unit id="16f78d439c89dcc67cc6d31385ff3dcec533675f" translate="yes" xml:space="preserve">
          <source>where each successive 'list add' option will push the value of add into array ref $list-&amp;gt;{'add'}. The result would be like</source>
          <target state="translated">其中每个后续的&amp;ldquo;列表添加&amp;rdquo;选项都会将添加的值推入数组ref $ list-&amp;gt; {'add'}中。结果就像</target>
        </trans-unit>
        <trans-unit id="517c0898eef6d5914aa381031eb301a948ecc075" translate="yes" xml:space="preserve">
          <source>where such changes can be applied by the means of cherry-picking from blead.</source>
          <target state="translated">其中,这种变化可以通过从blead中摘取的方式来应用。</target>
        </trans-unit>
        <trans-unit id="c1ba074422bf23c3944014acd8f065e730791214" translate="yes" xml:space="preserve">
          <source>where that number is the command number, and which you'd use to access with the built-in &lt;b&gt;csh&lt;/b&gt;-like history mechanism. For example, &lt;code&gt;!17&lt;/code&gt; would repeat command number 17. The depth of the angle brackets indicates the nesting depth of the debugger. You could get more than one set of brackets, for example, if you'd already at a breakpoint and then printed the result of a function call that itself has a breakpoint, or you step into an expression via &lt;code&gt;s/n/t
expression&lt;/code&gt; command.</source>
          <target state="translated">该数字是命令号，您将使用它通过&lt;b&gt;类似csh&lt;/b&gt;的内置历史记录机制进行访问。例如， &lt;code&gt;!17&lt;/code&gt; 将重复命令编号17。尖括号的深度表示调试器的嵌套深度。例如，如果您已经在一个断点处，然后打印出本身具有断点的函数调用的结果，或者通过 &lt;code&gt;s/n/t expression&lt;/code&gt; 命令进入表达式，则可能会得到不止一组括号。。</target>
        </trans-unit>
        <trans-unit id="fe3cffb107c47b95f0ae454e3de2e7e1743bb5ce" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;&quot;|&quot;&lt;/code&gt; is a binary operator with an operand on the right, but no operand on the left.</source>
          <target state="translated">其中 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 是一个二进制运算符，右侧是操作数，而左侧没有操作数。</target>
        </trans-unit>
        <trans-unit id="b244c23995363daf148f79037f34977ba5711e52" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;TYPEMAP&lt;/code&gt; keyword must appear in the first column of a new line.</source>
          <target state="translated">在 &lt;code&gt;TYPEMAP&lt;/code&gt; 关键字必须出现在新行的第一列。</target>
        </trans-unit>
        <trans-unit id="764e081905d06edddf30c836b21ee0f9eb49e89c" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;minlen&lt;/code&gt; would be 3 but &lt;code&gt;minlenret&lt;/code&gt; would only be 2 as the \d is required to match but is not actually included in the matched content. This distinction is particularly important as the substitution logic uses the &lt;code&gt;minlenret&lt;/code&gt; to tell if it can do in-place substitutions (these can result in considerable speed-up).</source>
          <target state="translated">其中 &lt;code&gt;minlen&lt;/code&gt; 为3，而 &lt;code&gt;minlenret&lt;/code&gt; 仅为2，因为\ d必须匹配，但实际上不包含在匹配的内容中。这种区别特别重要，因为替换逻辑使用 &lt;code&gt;minlenret&lt;/code&gt; 来告知它是否可以进行就地替换（这可以导致相当大的提速）。</target>
        </trans-unit>
        <trans-unit id="e11e55dd4712573d987efd1c0884f0c120edda61" translate="yes" xml:space="preserve">
          <source>where the Perl equivalent of &lt;code&gt;register_fatal&lt;/code&gt; and the callback it registers, &lt;code&gt;pcb1&lt;/code&gt; , might look like this</source>
          <target state="translated">Perl等效于 &lt;code&gt;register_fatal&lt;/code&gt; 及其注册的回调 &lt;code&gt;pcb1&lt;/code&gt; 的位置，可能看起来像这样</target>
        </trans-unit>
        <trans-unit id="34cc28c0ed6b3b975c1f8b2f5bfccf3f2b674b4a" translate="yes" xml:space="preserve">
          <source>where the first argument, an &lt;code&gt;SV*&lt;/code&gt; , must be a reference, and the second argument is a stash. The returned &lt;code&gt;SV*&lt;/code&gt; can now be used in the same way as any other SV.</source>
          <target state="translated">其中第一个参数 &lt;code&gt;SV*&lt;/code&gt; 必须是引用，第二个参数是存储。现在可以以与任何其他SV相同的方式使用返回的 &lt;code&gt;SV*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb8f1012228e6574e355ca23612690ce9ced4433" translate="yes" xml:space="preserve">
          <source>where the format expects to process a byte (a character with a value below 256), but a higher value was provided instead. Perl uses the value modulus 256 instead, as if you had provided:</source>
          <target state="translated">格式期望处理一个字节(一个值低于256的字符),但却提供了一个更高的值。Perl会使用256这个值,就像你提供了:</target>
        </trans-unit>
        <trans-unit id="b51b446492bdddf5835c8b7127ee3a8fcffa16ed" translate="yes" xml:space="preserve">
          <source>where the format expects to process a sequence of bytes (character with a value below 256), but some of the characters had a higher value. Perl uses the character values modulus 256 instead, as if you had provided:</source>
          <target state="translated">其中,格式期望处理一个字节序列(值低于256的字符),但其中一些字符的值较高。Perl使用字符值模数256来代替,就像你提供了:</target>
        </trans-unit>
        <trans-unit id="5c49be26fe2412d08b959e58ce62ecd11e8effd9" translate="yes" xml:space="preserve">
          <source>where these arguments mean:</source>
          <target state="translated">这些论点的意思。</target>
        </trans-unit>
        <trans-unit id="4fe303f9adde4840e097ed0d238372b72ff5d199" translate="yes" xml:space="preserve">
          <source>where those dot files live</source>
          <target state="translated">点阵文件所在的地方</target>
        </trans-unit>
        <trans-unit id="00a755e878e51b6d3d95aae065147ee2272798c2" translate="yes" xml:space="preserve">
          <source>where you'd otherwise have to write</source>
          <target state="translated">否则你就得写</target>
        </trans-unit>
        <trans-unit id="09c0979062616fd0606b29296df335c67d5531c0" translate="yes" xml:space="preserve">
          <source>whereupon we might see something like this, with each pair of hex digits corresponding to a byte:</source>
          <target state="translated">这时我们可能会看到这样的内容,每对十六进制数字对应一个字节。</target>
        </trans-unit>
        <trans-unit id="6fac826754ebef5d0de7380bb2ebdf79ac73e626" translate="yes" xml:space="preserve">
          <source>whether the contents are interpreted as a signed or unsigned number,</source>
          <target state="translated">是将内容解释为有符号数还是无符号数。</target>
        </trans-unit>
        <trans-unit id="dc2033256fe72f3be5253a7be85085b830e059f5" translate="yes" xml:space="preserve">
          <source>whether the next byte is in the range 0x80 - 0xBF. If so, the parser may conclude that this file is in UTF-8, and all highbit sequences in the file should be assumed to be UTF-8. Otherwise the parser should treat the file as being in CP-1252. (A better check, and which works on EBCDIC platforms as well, is to pass a copy of the sequence to &lt;a href=&quot;utf8&quot;&gt;utf8::decode()&lt;/a&gt; which performs a full validity check on the sequence and returns TRUE if it is valid UTF-8, FALSE otherwise. This function is always pre-loaded, is fast because it is written in C, and will only get called at most once, so you don't need to avoid it out of performance concerns.) In the unlikely circumstance that the first highbit sequence in a truly non-UTF-8 file happens to appear to be UTF-8, one can cater to our heuristic (as well as any more intelligent heuristic) by prefacing that line with a comment line containing a highbit sequence that is clearly</source>
          <target state="translated">下一个字节是否在0x80-0xBF范围内。如果是这样，则解析器可以得出结论，该文件位于UTF-8中，并且应假定该文件中的所有高位序列均为UTF-8。否则，解析器应将文件视为CP-1252中的文件。（更好的检查方法是将序列的副本传递给&lt;a href=&quot;utf8&quot;&gt;utf8 :: decode（）&lt;/a&gt;，这也适用于EBCDIC平台，它将对序列执行完全有效性检查，如果它是有效的UTF-8，则返回TRUE，否则返回FALSE。此函数始终是预加载的，因为它是用C编写的，所以速度很快，并且最多只能调用一次，因此出于性能方面的考虑，您不必避免它。）在不太可能的情况下，第一个高位序列在真正非UTF-8文件中似乎是UTF-8，可以通过在注释行前添加包含高位序列的注释行来迎合我们的启发式（以及任何更智能的启发式）</target>
        </trans-unit>
        <trans-unit id="13f9423890a306b627963ea70ef49e8541a4438e" translate="yes" xml:space="preserve">
          <source>whether we should try to change or remove those dot files</source>
          <target state="translated">我们是否应该尝试改变或删除这些点阵文件。</target>
        </trans-unit>
        <trans-unit id="ed04ff4dabf1e2d4cd6b89136c2b24dec27ecca4" translate="yes" xml:space="preserve">
          <source>which</source>
          <target state="translated">which</target>
        </trans-unit>
        <trans-unit id="d060cbd0fbb1156378e849bb6c04d6e687e74342" translate="yes" xml:space="preserve">
          <source>which can also be done with &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; which is made to transform one list into another:</source>
          <target state="translated">也可以使用 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; 来完成，它可以将一个列表转换为另一个列表：</target>
        </trans-unit>
        <trans-unit id="679cb19369252215832643aae001a33e00c3edb8" translate="yes" xml:space="preserve">
          <source>which can just be converted to:</source>
          <target state="translated">可以直接转换为。</target>
        </trans-unit>
        <trans-unit id="1058597fc80ec1ae6c9468976c2082b39dc74418" translate="yes" xml:space="preserve">
          <source>which can print filenames terminated by the null character, you can say this:</source>
          <target state="translated">可以打印以空字符结束的文件名,你可以这样说。</target>
        </trans-unit>
        <trans-unit id="0a1bf5f9e60cb26d6cb10d695574f7486a7350a5" translate="yes" xml:space="preserve">
          <source>which can work together</source>
          <target state="translated">可以合作</target>
        </trans-unit>
        <trans-unit id="26e6474c54d74f5e1b54fbb84567108ec9ec0be7" translate="yes" xml:space="preserve">
          <source>which contains a list of newXS() calls near the end. Removing unnecessary calls, and rerunning</source>
          <target state="translated">其中包含了一个新的XS()调用列表,接近尾声。删除不必要的调用,并重新运行</target>
        </trans-unit>
        <trans-unit id="3ba7f1a2c7d9e13feaebe2336a9a9752e948dcc6" translate="yes" xml:space="preserve">
          <source>which contains the profiling data collected during the execution.</source>
          <target state="translated">其中包含在执行过程中收集的剖析数据。</target>
        </trans-unit>
        <trans-unit id="209bf9b2c21856efbe58794a447fa26435ea0055" translate="yes" xml:space="preserve">
          <source>which could also be written this way, using a trick that's come to be known as the Schwartzian Transform:</source>
          <target state="translated">也可以这样写,使用一个被称为Schwartzian变换的技巧。</target>
        </trans-unit>
        <trans-unit id="75ba4f37004a47ec33e2d83893fc18c49f7a2c2b" translate="yes" xml:space="preserve">
          <source>which did not load a particular DLL yet. This is why the DLLs are mapped to the shared memory region.</source>
          <target state="translated">尚未加载特定的DLL。这就是为什么DLL会被映射到共享内存区域的原因。</target>
        </trans-unit>
        <trans-unit id="7b963e7a5bc43a79a319cd65245b0963a9a74082" translate="yes" xml:space="preserve">
          <source>which does nothing, but succeeds on all the &quot;usual&quot; build targets. To do so, use</source>
          <target state="translated">什么都不做,但在所有 &quot;通常 &quot;的构建目标上都能成功。要做到这一点,请使用</target>
        </trans-unit>
        <trans-unit id="1e68ca264c19e5e1287272ae8a0a048239c69afc" translate="yes" xml:space="preserve">
          <source>which has a length of 43. So, the properly padded version is</source>
          <target state="translated">其长度为43。所以,正确的填充版本是</target>
        </trans-unit>
        <trans-unit id="97b9b7ce1f9f8564271626441b5ed04c89fe2ee5" translate="yes" xml:space="preserve">
          <source>which has the short form</source>
          <target state="translated">其简称</target>
        </trans-unit>
        <trans-unit id="cf2897e01293c7352f75dce51f4052d41ff51799" translate="yes" xml:space="preserve">
          <source>which includes newly-installed via &lt;code&gt;Bundle::OS2_default&lt;/code&gt; modules. Doing testing via &lt;code&gt;CPAN.pm&lt;/code&gt; is going to be painfully slow, since it statically links a new executable per XS extension.</source>
          <target state="translated">其中包括通过 &lt;code&gt;Bundle::OS2_default&lt;/code&gt; 模块新安装的模块。通过 &lt;code&gt;CPAN.pm&lt;/code&gt; 进行测试将非常缓慢，因为它会按XS扩展名静态链接新的可执行文件。</target>
        </trans-unit>
        <trans-unit id="740279f94d278254c20a1964b766588db7905a52" translate="yes" xml:space="preserve">
          <source>which interact with the memory allocator in other ways than via malloc(), realloc(), free(), calloc(), sbrk() and brk();</source>
          <target state="translated">通过malloc()、realloc()、free()、calloc()、sbrk()和brk()以外的其他方式与内存分配器交互。</target>
        </trans-unit>
        <trans-unit id="27e6eae0fd902584be95e5d4c59ccdf92b2c93d3" translate="yes" xml:space="preserve">
          <source>which is Perl shorthand for the more explicitly written version:</source>
          <target state="translated">这是Perl中更明确写法版本的简写。</target>
        </trans-unit>
        <trans-unit id="e2c5c74f3c46665187c755c53e173135dab99bf8" translate="yes" xml:space="preserve">
          <source>which is also expressed by this formula:</source>
          <target state="translated">也可以用这个公式表示。</target>
        </trans-unit>
        <trans-unit id="04c6ac4120301d7049af98011b0e572414db64b0" translate="yes" xml:space="preserve">
          <source>which is equivalent to</source>
          <target state="translated">等于</target>
        </trans-unit>
        <trans-unit id="16a66c1b8256121eec60a422104c678c527a1b68" translate="yes" xml:space="preserve">
          <source>which is even the same as</source>
          <target state="translated">堪比</target>
        </trans-unit>
        <trans-unit id="40217363f21b2e6fa15982c559837fa626b0eb67" translate="yes" xml:space="preserve">
          <source>which is exactly what we had defined for negative real numbers above. The &lt;code&gt;&lt;a href=&quot;../functions/sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; returns only one of the solutions: if you want the both, use the &lt;code&gt;root&lt;/code&gt; function.</source>
          <target state="translated">这正是我们上面为负实数定义的内容。该 &lt;code&gt;&lt;a href=&quot;../functions/sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; 只返回的解决方案之一：如果你想两者，使用 &lt;code&gt;root&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="41660e5f3a05c257d71cd236ed7137b3831af720" translate="yes" xml:space="preserve">
          <source>which is generated from</source>
          <target state="translated">其产生于</target>
        </trans-unit>
        <trans-unit id="ed4894b8ab4c596c6c6382023f8f4837da06efce" translate="yes" xml:space="preserve">
          <source>which is hard-wired to replace all occurrences of the string &lt;code&gt;&quot;Joe&quot;&lt;/code&gt; to &lt;code&gt;&quot;Jim&quot;&lt;/code&gt; . Not particularly Useful, but it is the first example and I wanted to keep it simple.</source>
          <target state="translated">用硬连线将所有出现的字符串 &lt;code&gt;&quot;Joe&quot;&lt;/code&gt; 替换为 &lt;code&gt;&quot;Jim&quot;&lt;/code&gt; 。并不是特别有用，但这是第一个示例，我想保持简单。</target>
        </trans-unit>
        <trans-unit id="a4f1633dff7d510a448e9aaeeb40cb63e6e279d1" translate="yes" xml:space="preserve">
          <source>which is not, consequently, deparsed correctly.</source>
          <target state="translated">因此,这不是正确的出发点。</target>
        </trans-unit>
        <trans-unit id="d53450b0fdca8bc7a9a33283360f4cc8874d6819" translate="yes" xml:space="preserve">
          <source>which is presumably easier to read than the old way:</source>
          <target state="translated">这大概比老办法更容易阅读。</target>
        </trans-unit>
        <trans-unit id="590e9b690bb3d4c0ee4fe08d74808195b747676b" translate="yes" xml:space="preserve">
          <source>which is probably not what you were expecting. Unfortunately at least one reasonably common and modern C compiler does &quot;real backward compatibility&quot; here, in AIX that is what still happens even though the rest of the AIX compiler is very happily C89.</source>
          <target state="translated">这可能不是你所期望的。不幸的是,至少有一个合理的常见的和现代的C编译器在这里做了 &quot;真正的向后兼容&quot;,在AIX中,即使AIX编译器的其他部分是非常快乐的C89,这仍然是发生的事情。</target>
        </trans-unit>
        <trans-unit id="29eb09005f5e9aeeb936021e842907d6266dcfda" translate="yes" xml:space="preserve">
          <source>which is ready to be printed.</source>
          <target state="translated">已准备好打印的。</target>
        </trans-unit>
        <trans-unit id="457319eaa9e4f3b728ed192e5fdb2e515988f305" translate="yes" xml:space="preserve">
          <source>which is the correct answer. This example illustrates that it is important not only to match what is desired, but to reject what is not desired.</source>
          <target state="translated">这就是正确的答案。这个例子说明,不仅要匹配想要的东西,而且要拒绝不想要的东西。</target>
        </trans-unit>
        <trans-unit id="2b2a157cb124d5116a790751a46e4a73627b6581" translate="yes" xml:space="preserve">
          <source>which is true (&lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; has the regular meaning for real number, i.e. stands for the absolute value). This example explains why the norm of &lt;code&gt;z&lt;/code&gt; is noted &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt;: it extends the &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; function to complex numbers, yet is the regular &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; we know when the complex number actually has no imaginary part... This justifies</source>
          <target state="translated">这是正确的（ &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; 具有实数的常规含义，即代表绝对值）。这个例子说明了为什么的规范 &lt;code&gt;z&lt;/code&gt; 指出 &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt; ：它扩展了 &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; 功能复数，而又在常规 &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; ，我们知道当复数量实际上已经没有虚部...这证明</target>
        </trans-unit>
        <trans-unit id="3080d1b7e175b0f68ccca8d1ffcce6a17814f888" translate="yes" xml:space="preserve">
          <source>which is visible in other functions called from that subroutine</source>
          <target state="translated">在从该子程序调用的其他函数中可见</target>
        </trans-unit>
        <trans-unit id="f78cd391c699a6564a6185a15b2c00459cb4b5f7" translate="yes" xml:space="preserve">
          <source>which lasts until the end of that BLOCK.</source>
          <target state="translated">持续到该BLOCK结束。</target>
        </trans-unit>
        <trans-unit id="400ae171fcca992b111ee0c9eaa8e6bbbbb647ec" translate="yes" xml:space="preserve">
          <source>which lasts until the end of that BLOCK. Note that this doesn't mean everything is an integer, merely that Perl will use integer operations for arithmetic, comparison, and bitwise operators. For example, even under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; , if you take the &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt(2)&lt;/a&gt;&lt;/code&gt;, you'll still get &lt;code&gt;1.4142135623731&lt;/code&gt; or so.</source>
          <target state="translated">一直持续到该块结束为止。请注意，这并不意味着所有内容都是整数，而只是Perl将使用整数运算进行算术，比较和按位运算符。例如，即使在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; ，如果使用 &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt(2)&lt;/a&gt;&lt;/code&gt; ，您仍将得到 &lt;code&gt;1.4142135623731&lt;/code&gt; 左右。</target>
        </trans-unit>
        <trans-unit id="c45a01f777cdc33148420b0a627621b88968ca28" translate="yes" xml:space="preserve">
          <source>which looks like your module is doing something wrong. Instead, you want to put the blame on the user, and say this:</source>
          <target state="translated">这看起来像是你的模块做错了什么。相反,你想把责任推到用户身上,并说这样的话。</target>
        </trans-unit>
        <trans-unit id="910ece59a1ee7a779c7904607756d8ac6f43840e" translate="yes" xml:space="preserve">
          <source>which makes Configure to use the &lt;code&gt;nm&lt;/code&gt; tool when scanning for library symbols, which usually is not done in AIX.</source>
          <target state="translated">这使Configure可以在扫描库符号时使用 &lt;code&gt;nm&lt;/code&gt; 工具，而AIX中通常不会这样做。</target>
        </trans-unit>
        <trans-unit id="2d3700f0082a2cd4c6079cbe90c96db947b50f48" translate="yes" xml:space="preserve">
          <source>which makes the intention more clear.</source>
          <target state="translated">这就更加明确了意图。</target>
        </trans-unit>
        <trans-unit id="8cd3d9060c1ace30dd6e2d6262dfd40d2021cad0" translate="yes" xml:space="preserve">
          <source>which may be useful for debugging a program that uses &lt;code&gt;Term::ReadLine&lt;/code&gt; itself. Do not forget to detach your shell from the TTY in the window that corresponds to</source>
          <target state="translated">这对于调试使用 &lt;code&gt;Term::ReadLine&lt;/code&gt; 本身的程序可能很有用。不要忘记在与以下内容相对应的窗口中从TTY上卸下外壳</target>
        </trans-unit>
        <trans-unit id="7e2010dc06ea0515288724e36b214acf56509e41" translate="yes" xml:space="preserve">
          <source>which may modify the second input argument.</source>
          <target state="translated">它可以修改第二个输入参数。</target>
        </trans-unit>
        <trans-unit id="eee2fd622722c8b192547f36dd5b9891b7a1ad1e" translate="yes" xml:space="preserve">
          <source>which means</source>
          <target state="translated">也就是说</target>
        </trans-unit>
        <trans-unit id="04a52cf2a6a5e0c79d4fd67cec9d2eb15a88cc21" translate="yes" xml:space="preserve">
          <source>which outputs</source>
          <target state="translated">其中输出</target>
        </trans-unit>
        <trans-unit id="3f62e72ff87682e720abfa0dc12f99261d01428f" translate="yes" xml:space="preserve">
          <source>which pinpoints the real problem. Finally the script can now be modified to fix the original problem by destroying the API object before the untie:</source>
          <target state="translated">其中指出了真正的问题。最后,现在可以修改脚本,通过在解绑前销毁API对象来解决原来的问题。</target>
        </trans-unit>
        <trans-unit id="ac6415ae9e2075f760e53b307b58defa828d2b3f" translate="yes" xml:space="preserve">
          <source>which prints</source>
          <target state="translated">其中打印</target>
        </trans-unit>
        <trans-unit id="bb6c88a0a4a00ee65fac2ab2a88d44234ed99c16" translate="yes" xml:space="preserve">
          <source>which prints (on my machine):</source>
          <target state="translated">其中打印(在我的机器上)。</target>
        </trans-unit>
        <trans-unit id="c6aa678d657ea6708638daf467b4e464862338f7" translate="yes" xml:space="preserve">
          <source>which probably isn't what you intended (the &lt;code&gt;'???'&lt;/code&gt; is a sign that perl optimized away a constant value).</source>
          <target state="translated">这可能不是您想要的（ &lt;code&gt;'???'&lt;/code&gt; 是perl优化了恒定值的标志）。</target>
        </trans-unit>
        <trans-unit id="3f77411f51027e18d6942d6aafcf90ba55ec2701" translate="yes" xml:space="preserve">
          <source>which produces the output (again, long lines have been wrapped here)</source>
          <target state="translated">它产生的输出(这里又是长线包装</target>
        </trans-unit>
        <trans-unit id="bef5e7ef43fdb712239e626bd67fabf93a351f45" translate="yes" xml:space="preserve">
          <source>which produces:</source>
          <target state="translated">其中产生:</target>
        </trans-unit>
        <trans-unit id="f2902720610777e0cb05329288b1b2cd5b87bdd4" translate="yes" xml:space="preserve">
          <source>which provides a new Perl interpreter for each thread, and, by default, results in no data or state information being shared between threads.</source>
          <target state="translated">它为每个线程提供了一个新的Perl解释器,默认情况下,线程之间不会共享数据或状态信息。</target>
        </trans-unit>
        <trans-unit id="f92ba8d28d485765994bd16e6b0139ab94d5b990" translate="yes" xml:space="preserve">
          <source>which puts literal commas into some of the list items. Write it without commas if you don't want them to appear in your data:</source>
          <target state="translated">它将逗号放入一些列表项中。如果你不想让逗号出现在你的数据中,就不写逗号。</target>
        </trans-unit>
        <trans-unit id="87d11dc8fa4ace81bc6cff5f401501d4f07cbd6a" translate="yes" xml:space="preserve">
          <source>which puts you into a readline interface. If &lt;code&gt;Term::ReadKey&lt;/code&gt; and either of &lt;code&gt;Term::ReadLine::Perl&lt;/code&gt; or &lt;code&gt;Term::ReadLine::Gnu&lt;/code&gt; are installed, history and command completion are supported.</source>
          <target state="translated">这将使您进入readline界面。如果安装了 &lt;code&gt;Term::ReadKey&lt;/code&gt; 和 &lt;code&gt;Term::ReadLine::Perl&lt;/code&gt; 或 &lt;code&gt;Term::ReadLine::Gnu&lt;/code&gt; 之一，则支持历史记录和命令完成。</target>
        </trans-unit>
        <trans-unit id="6f4d24b8ce89da9965a39a4a2a60f5482730186f" translate="yes" xml:space="preserve">
          <source>which rely on special alignment which is not provided by Perl's malloc().</source>
          <target state="translated">依靠特殊的对齐方式,而Perl的malloc()并没有提供这种对齐方式。</target>
        </trans-unit>
        <trans-unit id="fdcf525abe96dbcca08ea62d672f58f208fd0fe2" translate="yes" xml:space="preserve">
          <source>which returns 'a/b/c' under Unix. Or:</source>
          <target state="translated">在Unix下返回'a/b/c'。或者:</target>
        </trans-unit>
        <trans-unit id="ec1e3337a0ee7b60523959a46060f22ddce31714" translate="yes" xml:space="preserve">
          <source>which returns a string consisting of the first character from each string. Using pack, we can write</source>
          <target state="translated">它返回一个由每个字符串的第一个字符组成的字符串。使用pack,我们可以写出</target>
        </trans-unit>
        <trans-unit id="3d4e654a3fe5a13b1285db512bfaad46b825adcf" translate="yes" xml:space="preserve">
          <source>which reverses the order of method call.</source>
          <target state="translated">颠倒了方法调用的顺序。</target>
        </trans-unit>
        <trans-unit id="0a42738502aac554f3685b010c8c33d17b8d8a89" translate="yes" xml:space="preserve">
          <source>which runs script non-interactively, printing info on each entry into a subroutine and each executed line into the file named</source>
          <target state="translated">它以非交互方式运行脚本,将每个子程序的条目和每行执行的信息打印到名为</target>
        </trans-unit>
        <trans-unit id="a26dc4262a5b530b9fd0491393a70987f0cb95f8" translate="yes" xml:space="preserve">
          <source>which sets the debugging packages directly. Note that &lt;code&gt;o debug 0&lt;/code&gt; turns debugging off.</source>
          <target state="translated">直接设置调试包。请注意， &lt;code&gt;o debug 0&lt;/code&gt; 将关闭调试。</target>
        </trans-unit>
        <trans-unit id="13c1eb00f520026b6ba1e70a18a4964822f7275f" translate="yes" xml:space="preserve">
          <source>which should be interpreted as a link to the &lt;code&gt;vertical|bar/slash&lt;/code&gt; POD page and not as a link to the &lt;code&gt;slash&lt;/code&gt; section of the &lt;code&gt;bar&lt;/code&gt; POD page with an anchor text of &lt;code&gt;vertical&lt;/code&gt; . Note that not only the anchor text will need to have formatting codes expanded, but so will the target of the link (to deal with E&amp;lt;&amp;gt; and Z&amp;lt;&amp;gt; formatting codes), and special handling of the section may be necessary depending on whether the translator wants to consider markup in sections to be significant when resolving links. See &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt; for more information.</source>
          <target state="translated">应该被解释为指向 &lt;code&gt;vertical|bar/slash&lt;/code&gt; POD页面的链接，而不是指向带有锚定文本 &lt;code&gt;vertical&lt;/code&gt; 的 &lt;code&gt;bar&lt;/code&gt; POD页面的 &lt;code&gt;slash&lt;/code&gt; 部分的链接。请注意，不仅锚文本需要扩展格式代码，而且链接的目标也需要扩展（以处理E &amp;lt;&amp;gt;和Z &amp;lt;&amp;gt;格式代码），并且可能需要对该部分进行特殊处理，具体取决于是否译者希望在解析链接时考虑部分标记的重要性。有关更多信息，请参见&lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82d18cd1d1191a0e6eb914334f14809f4e2df5fc" translate="yes" xml:space="preserve">
          <source>which shows that spaces are still possible in the code parts. Nevertheless, when working with code and conditional expressions, the extended form of regexps is almost necessary in creating and debugging regexps.</source>
          <target state="translated">这表明在代码部分仍然可以使用空格。尽管如此,在处理代码和条件表达式时,在创建和调试regexps时,regexps的扩展形式几乎是必要的。</target>
        </trans-unit>
        <trans-unit id="c562409303f52b59b405fbd73bdc489d191355d6" translate="yes" xml:space="preserve">
          <source>which specifies that the ambient pragmas are exactly those which are in scope at the point of calling.</source>
          <target state="translated">它指定环境实用程序正是那些在调用时处于范围内的程序。</target>
        </trans-unit>
        <trans-unit id="a01b2a58a6fdba96f9248e9340f26dd88b40f22f" translate="yes" xml:space="preserve">
          <source>which the range operator becomes false again. It doesn't become false till the next time the range operator is evaluated. It can test the right operand and become false on the same evaluation it became true (as in &lt;b&gt;awk&lt;/b&gt;), but it still returns true once. If you don't want it to test the right operand until the next evaluation, as in &lt;b&gt;sed&lt;/b&gt;, just use three dots (&lt;code&gt;&quot;...&quot;&lt;/code&gt; ) instead of two. In all other regards, &lt;code&gt;&quot;...&quot;&lt;/code&gt; behaves just like &lt;code&gt;&quot;..&quot;&lt;/code&gt; does.</source>
          <target state="translated">范围运算符再次变为假。直到下次评估范围运算符时，它才会变为假。它可以测试正确的操作数，并且在变为true的相同评估中变为false（如&lt;b&gt;awk一样&lt;/b&gt;），但一次仍返回true。如果您不希望它在下一次求值之前测试正确的操作数，如&lt;b&gt;sed中所示&lt;/b&gt;，只需使用三个点（ &lt;code&gt;&quot;...&quot;&lt;/code&gt; ）而不是两个即可。在所有其他方面， &lt;code&gt;&quot;...&quot;&lt;/code&gt; 行为与 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 行为相同。</target>
        </trans-unit>
        <trans-unit id="81c23090ff08e0fb68830283659fa8701d911f41" translate="yes" xml:space="preserve">
          <source>which then may be given to subsequent gprof runs to accumulate data over several runs.</source>
          <target state="translated">然后可以将其交给后续的 gprof 运行,以积累多个运行的数据。</target>
        </trans-unit>
        <trans-unit id="6bc38136202aaeb79aacb17bb0b21ad3bf7c2961" translate="yes" xml:space="preserve">
          <source>which understands command arguments. One of such ports is listed in &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt; under RSX. Do not forget to set variable &lt;code&gt;&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;&lt;/code&gt; as well.</source>
          <target state="translated">它了解命令参数。RSX下的&amp;ldquo; &lt;a href=&quot;#Prerequisites&quot;&gt;先决条件&amp;rdquo;中&lt;/a&gt;列出了此类端口之一。不要忘记也设置变量 &lt;code&gt;&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da06cc8f27f2a4277c9d2ea18a97a8abd08b8a8d" translate="yes" xml:space="preserve">
          <source>which uses &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; matches exactly when the one above does (verifying this yourself would be a productive exercise), but finishes in a fourth the time when used on a similar string with 1000000 &lt;code&gt;a&lt;/code&gt; s. Be aware, however, that, when this construct is followed by a quantifier, it currently triggers a warning message under the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or &lt;b&gt;-w&lt;/b&gt; switch saying it &lt;code&gt;&quot;matches null string many times in regex&quot;&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; 时，上面的那个完全匹配（您自己验证这将是一个有成效的练习），但是在具有1000000 &lt;code&gt;a&lt;/code&gt; s 的类似字符串上使用时，它的完成时间是四分之一。但是请注意，当此构造后跟一个量词时，它当前会在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 编译指示或&lt;b&gt;-w&lt;/b&gt;开关下触发一条警告消息，称其 &lt;code&gt;&quot;matches null string many times in regex&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1742d6043b0a0627cfbbf796a8a4aec58b9ba1e" translate="yes" xml:space="preserve">
          <source>which will automatically coerce the actual scalar type into an IV, UV, double, or string.</source>
          <target state="translated">它将自动把实际的标量类型胁迫为IV、UV、double或字符串。</target>
        </trans-unit>
        <trans-unit id="6fb146e9079ae4bc7011dc3190cd3e0c07fe95ee" translate="yes" xml:space="preserve">
          <source>which will call</source>
          <target state="translated">这将调用</target>
        </trans-unit>
        <trans-unit id="a70f5704ad119ee244b693c30eb2b8ff7c442560" translate="yes" xml:space="preserve">
          <source>which will cause</source>
          <target state="translated">这将导致</target>
        </trans-unit>
        <trans-unit id="607626ffbe3fb95a065011f0e19304f91e5ce829" translate="yes" xml:space="preserve">
          <source>which will determine if more memory needs to be allocated. If so, it will call the function &lt;code&gt;sv_grow&lt;/code&gt; . Note that &lt;code&gt;SvGROW&lt;/code&gt; can only increase, not decrease, the allocated memory of an SV and that it does not automatically add space for the trailing &lt;code&gt;NUL&lt;/code&gt; byte (perl's own string functions typically do &lt;code&gt;SvGROW(sv, len + 1)&lt;/code&gt; ).</source>
          <target state="translated">这将确定是否需要分配更多的内存。如果是这样，它将调用函数 &lt;code&gt;sv_grow&lt;/code&gt; 。请注意， &lt;code&gt;SvGROW&lt;/code&gt; 只能增加而不是减少SV的已分配内存，并且它不会自动为尾随的 &lt;code&gt;NUL&lt;/code&gt; 字节增加空间（perl自己的字符串函数通常会执行 &lt;code&gt;SvGROW(sv, len + 1)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1979ea935ff5d0f72dacbfc022d39ca4775f4154" translate="yes" xml:space="preserve">
          <source>which will do conversion from LF to CR/LF on the output, or in the environment settings (add this to your .bashrc):</source>
          <target state="translated">它将在输出上或在环境设置中进行从LF到CR/LF的转换(将其添加到你的.bashrc中)。</target>
        </trans-unit>
        <trans-unit id="f602755896feed19e862deed34ab69b1cc800288" translate="yes" xml:space="preserve">
          <source>which will echo the cat command's output as it is generated, instead of waiting until the program has completed to print it out. It also checks the return value.</source>
          <target state="translated">它将在cat命令的输出产生时进行回声,而不是等到程序完成后再打印出来。它还会检查返回值。</target>
        </trans-unit>
        <trans-unit id="b50d57b41b49f3ab1ba2caaab449544638d7c8f0" translate="yes" xml:space="preserve">
          <source>which will expand the macros using cpp. Don't be scared by the results.</source>
          <target state="translated">这将使用cpp扩展宏。不要被结果吓到。</target>
        </trans-unit>
        <trans-unit id="9e71b54891a6848222e41887418f6d0101fb71a1" translate="yes" xml:space="preserve">
          <source>which will export Exporter's own import() method into YourModule. Everything will work as before but you won't need to include Exporter in &lt;code&gt;@YourModule::ISA&lt;/code&gt; .</source>
          <target state="translated">它将导出器自己的import（）方法导出到YourModule中。一切都会像以前一样工作，但是您无需在 &lt;code&gt;@YourModule::ISA&lt;/code&gt; 包括Exporter 。</target>
        </trans-unit>
        <trans-unit id="b87794d0dcf9a6a672b27ff15db2b5b5df0e9109" translate="yes" xml:space="preserve">
          <source>which will match assigned characters known to be part of the Greek script.</source>
          <target state="translated">它将匹配已知是希腊文字的一部分的指定字符。</target>
        </trans-unit>
        <trans-unit id="b95b054f4d66abe300e2020ad56271297a5fff0f" translate="yes" xml:space="preserve">
          <source>which will override system(), exec(), &lt;code&gt;``&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open(,'...|')&lt;/a&gt;&lt;/code&gt;. With current perl you may override only system(), readpipe() - the explicit version of &lt;code&gt;``&lt;/code&gt; , and maybe exec(). The code will substitute the one-argument call to system() by &lt;code&gt;CORE::system('cmd.exe', '/c', &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;)&lt;/code&gt; .</source>
          <target state="translated">这将覆盖system（），exec（）， &lt;code&gt;``&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open(,'...|')&lt;/a&gt;&lt;/code&gt; 。使用当前的perl，您可以仅覆盖system（），readpipe（）- &lt;code&gt;``&lt;/code&gt; 的显式版本，也可以覆盖exec（）。该代码将用 &lt;code&gt;CORE::system('cmd.exe', '/c', &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;)&lt;/code&gt; 替换对system（）的单参数调用。</target>
        </trans-unit>
        <trans-unit id="456a31b1679a3c242ee6fcfa550ef4cff72097d5" translate="yes" xml:space="preserve">
          <source>which will print something like this</source>
          <target state="translated">它将打印类似这样的内容</target>
        </trans-unit>
        <trans-unit id="9d9f99b15b9cecc682a88d237aaf65afdade60cb" translate="yes" xml:space="preserve">
          <source>which will pull in the crlf PerlIO layer which does LF -&amp;gt; CRLF conversion on every output generated by perl.</source>
          <target state="translated">这将拉入crlf PerlIO层，在perl生成的每个输出上执行LF-&amp;gt; CRLF转换。</target>
        </trans-unit>
        <trans-unit id="3f021bf96a0c4f48629afad5e6635345dc7b47e5" translate="yes" xml:space="preserve">
          <source>which works exactly as it does for the &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; commands. Requires the &lt;code&gt;PadWalker&lt;/code&gt; module version 0.08 or higher; will warn if this isn't installed. Output is pretty-printed in the same style as for &lt;code&gt;V&lt;/code&gt; and the format is controlled by the same options.</source>
          <target state="translated">与 &lt;code&gt;V&lt;/code&gt; 和 &lt;code&gt;X&lt;/code&gt; 命令完全一样。要求 &lt;code&gt;PadWalker&lt;/code&gt; 模块版本为0.08或更高；如果未安装，将发出警告。输出以与 &lt;code&gt;V&lt;/code&gt; 相同的样式漂亮地打印，并且格式由相同的选项控制。</target>
        </trans-unit>
        <trans-unit id="11c1ab2f8d5d6cd3a60669a9963f5426c9daee0d" translate="yes" xml:space="preserve">
          <source>which would produce:</source>
          <target state="translated">这将产生:</target>
        </trans-unit>
        <trans-unit id="5a1c45867db7ee2d51ddbd3c9e7a13e56f64c459" translate="yes" xml:space="preserve">
          <source>which, again, is the default that you should probably never change. You cannot use this keyword on versions of perl before 5.16 to make XSUBs &lt;code&gt;static&lt;/code&gt; .</source>
          <target state="translated">同样，这是您可能永远都不要更改的默认设置。您不能在5.16之前的perl版本上使用此关键字来使XSUBs变为 &lt;code&gt;static&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d75fc0dff9af022da4a609d39c10fe2dc49a67f" translate="yes" xml:space="preserve">
          <source>whichever is appropriate.) Also, make sure that the DLLs for external libraries are usable with with executables compiled without &lt;code&gt;-Zmtd&lt;/code&gt; options.</source>
          <target state="translated">还要确保外部库的DLL可与不带 &lt;code&gt;-Zmtd&lt;/code&gt; 选项编译的可执行文件一起使用。</target>
        </trans-unit>
        <trans-unit id="6517f89c46c3f0d6db9cb009b8c7d1f98c371fa0" translate="yes" xml:space="preserve">
          <source>while</source>
          <target state="translated">while</target>
        </trans-unit>
        <trans-unit id="c755db4e16e1ebd5579bf9df24c0a9dde1dc936a" translate="yes" xml:space="preserve">
          <source>while the object methods of the class still work as designed. This is a key feature of inside-out classes.</source>
          <target state="translated">而该类的对象方法仍按设计工作。这是内嵌式类的一个重要特点。</target>
        </trans-unit>
        <trans-unit id="e5daa18cf1bbf438222f9cb7416fc2f0b139eb61" translate="yes" xml:space="preserve">
          <source>while this is invalid:</source>
          <target state="translated">而这是无效的。</target>
        </trans-unit>
        <trans-unit id="d2f5ed52eb803c45683b5fc0aa9520f29eb7cf52" translate="yes" xml:space="preserve">
          <source>whole class</source>
          <target state="translated">全班</target>
        </trans-unit>
        <trans-unit id="5a8cc6fdee71abc3b1476fb220e9d1cd4edb423d" translate="yes" xml:space="preserve">
          <source>whose dot files this object represents</source>
          <target state="translated">该对象所代表的点阵文件</target>
        </trans-unit>
        <trans-unit id="3fd57b2686f4898d067d4a56c073c64e61db82bf" translate="yes" xml:space="preserve">
          <source>whose lookup failed, and naming the line number where the calling $lh-&amp;gt;maketext(</source>
          <target state="translated">其查找失败，并在调用$ lh-&amp;gt; maketext（</target>
        </trans-unit>
        <trans-unit id="10cff4034cedfb92a272cddd774b8b63e3bdad06" translate="yes" xml:space="preserve">
          <source>why</source>
          <target state="translated">why</target>
        </trans-unit>
        <trans-unit id="70bec8a9bf5ecd2e6b37316e112b3f4c615ad4d3" translate="yes" xml:space="preserve">
          <source>width</source>
          <target state="translated">width</target>
        </trans-unit>
        <trans-unit id="37d41699bdee4fcb969ca499eb0f8b82c60d59cc" translate="yes" xml:space="preserve">
          <source>will</source>
          <target state="translated">will</target>
        </trans-unit>
        <trans-unit id="9e698af09629b7ab425fc48e2a23b9a874214ff2" translate="yes" xml:space="preserve">
          <source>will all be loaded correctly by the &lt;b&gt;SelfLoader&lt;/b&gt;, and the &lt;b&gt;SelfLoader&lt;/b&gt; will ensure that the packages 'foo' and 'baz' correctly have the &lt;b&gt;SelfLoader&lt;/b&gt;&lt;code&gt;AUTOLOAD&lt;/code&gt; method when the data after &lt;code&gt;__DATA__&lt;/code&gt; is first parsed.</source>
          <target state="translated">将由&lt;b&gt;SelfLoader&lt;/b&gt;正确加载所有&lt;b&gt;文件&lt;/b&gt;，并且当首次解析 &lt;code&gt;__DATA__&lt;/code&gt; 之后的数据时，&lt;b&gt;SelfLoader&lt;/b&gt;将确保包'foo'和'baz'正确具有&lt;b&gt;SelfLoader &lt;/b&gt; &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="802b42bef12951357b89ef5b2a13122fbe99ef9d" translate="yes" xml:space="preserve">
          <source>will allow calling myref() as</source>
          <target state="translated">将允许调用myref()作为</target>
        </trans-unit>
        <trans-unit id="9f588d27875535a5a81b909a3f21a13470c6000b" translate="yes" xml:space="preserve">
          <source>will allow the user to specify an argument of the form &lt;code&gt;&quot;rsh cat file |&quot;&lt;/code&gt; , but will not work on a filename that happens to have a trailing space, while</source>
          <target state="translated">将允许用户以 &lt;code&gt;&quot;rsh cat file |&quot;&lt;/code&gt; 形式指定参数。，但不适用于碰巧有尾随空格的文件名，而</target>
        </trans-unit>
        <trans-unit id="cdd84ef15151c715185c9415f2310209f946b6e6" translate="yes" xml:space="preserve">
          <source>will also turn on the &lt;code&gt;DEBUGGING&lt;/code&gt; compilation symbol which enables all the internal debugging code in Perl. There are a whole bunch of things you can debug with this: &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; lists them all, and the best way to find out about them is to play about with them. The most useful options are probably</source>
          <target state="translated">还将打开 &lt;code&gt;DEBUGGING&lt;/code&gt; 编译符号，该符号将启用Perl中的所有内部调试代码。您可以使用以下方法调试一堆东西：&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;列出了所有内容，而找出它们的最佳方法就是使用它们。最有用的选项可能是</target>
        </trans-unit>
        <trans-unit id="1b4ff705741e98869e5239461b8d80b3db153b63" translate="yes" xml:space="preserve">
          <source>will always be appropriately set before</source>
          <target state="translated">始终会被适当地设置在</target>
        </trans-unit>
        <trans-unit id="800502b2521db5dda562d1522427959496f11b6d" translate="yes" xml:space="preserve">
          <source>will automatically call &lt;code&gt;deflateSetDictionary&lt;/code&gt; directly after calling &lt;code&gt;deflateInit&lt;/code&gt; . The Adler32 value for the dictionary can be obtained by calling the method &lt;code&gt;$d-&amp;gt;dict_adler()&lt;/code&gt; .</source>
          <target state="translated">会自动调用 &lt;code&gt;deflateSetDictionary&lt;/code&gt; 调用后直接 &lt;code&gt;deflateInit&lt;/code&gt; 。可以通过调用方法 &lt;code&gt;$d-&amp;gt;dict_adler()&lt;/code&gt; 获得字典的Adler32值。</target>
        </trans-unit>
        <trans-unit id="ac2d106304a82f8979d078a5d1a630e0bf0bbed4" translate="yes" xml:space="preserve">
          <source>will automatically call &lt;code&gt;deflateSetDictionary&lt;/code&gt; directly after calling &lt;code&gt;deflateInit&lt;/code&gt; . The Adler32 value for the dictionary can be obtained by calling the method &lt;code&gt;$d-&lt;/code&gt; dict_adler()&amp;gt;.</source>
          <target state="translated">会自动调用 &lt;code&gt;deflateSetDictionary&lt;/code&gt; 调用后直接 &lt;code&gt;deflateInit&lt;/code&gt; 。可以通过调用方法 &lt;code&gt;$d-&lt;/code&gt; dict_adler（）&amp;gt; 获取字典的Adler32值。</target>
        </trans-unit>
        <trans-unit id="bf4cadec0746e1a5ab432f127230623d5e7091d8" translate="yes" xml:space="preserve">
          <source>will automatically search in</source>
          <target state="translated">会自动搜索</target>
        </trans-unit>
        <trans-unit id="047046a9e670aa4336adfdf1872082aee6bc3385" translate="yes" xml:space="preserve">
          <source>will automatically search when adding directories to @&lt;code&gt;INC&lt;/code&gt; . The elements in the list are separated by spaces. This is only useful if you have a perl library directory tree structured like the default one. See &lt;code&gt;INSTALL&lt;/code&gt; for how this works. The versioned site_perl directory was introduced in 5.005, so that is the lowest possible value.</source>
          <target state="translated">将目录添加到@ &lt;code&gt;INC&lt;/code&gt; 时将自动搜索。列表中的元素由空格分隔。仅当您具有结构类似于默认库的perl库目录树时，此功能才有用。有关如何工作的信息，请参见 &lt;code&gt;INSTALL&lt;/code&gt; 。版本版本的site_perl目录是在5.005中引入的，因此这是最低的值。</target>
        </trans-unit>
        <trans-unit id="77ff54c41540566c24d6f01703b68b71c5db0b9e" translate="yes" xml:space="preserve">
          <source>will be a reference to a glob which can be treated as a perl file handle. It refers to the layer below.</source>
          <target state="translated">将会是一个对 glob 的引用,这个 glob 可以被当作一个 perl 文件句柄。它指的是下面的一层。</target>
        </trans-unit>
        <trans-unit id="1f36a5ca854b3b31929c9a757a81400bb46baa6a" translate="yes" xml:space="preserve">
          <source>will be added to the list if not present, as will any types given in the list of</source>
          <target state="translated">将被添加到列表中,如果不存在,也将被添加到列表中的任何类型。</target>
        </trans-unit>
        <trans-unit id="2ee7188301caacf79b6af8dcb2c81f839071db3f" translate="yes" xml:space="preserve">
          <source>will be appropriately labeled using arrow notation. You can specify names for individual values to be dumped if you use the &lt;code&gt;Dump()&lt;/code&gt; method, or you can change the default &lt;code&gt;$VAR&lt;/code&gt; prefix to something else. See &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; and &lt;code&gt;$Data::Dumper::Terse&lt;/code&gt; below.</source>
          <target state="translated">将使用箭头符号适当地标记。如果使用 &lt;code&gt;Dump()&lt;/code&gt; 方法，则可以为要转储的各个值指定名称，也可以将默认的 &lt;code&gt;$VAR&lt;/code&gt; 前缀更改为其他名称。请参见下面的 &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; 和 &lt;code&gt;$Data::Dumper::Terse&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5d33fb37764bb4ed1953600f4adf836066df187" translate="yes" xml:space="preserve">
          <source>will be assigned.</source>
          <target state="translated">将被分配。</target>
        </trans-unit>
        <trans-unit id="4b924079b9f868588e8837d7d50c4a682e44dca9" translate="yes" xml:space="preserve">
          <source>will be associated with</source>
          <target state="translated">将与</target>
        </trans-unit>
        <trans-unit id="02ae7304f1d07ef95ca9aa9e7fec2131cfb9259b" translate="yes" xml:space="preserve">
          <source>will be assumed.</source>
          <target state="translated">将被假定。</target>
        </trans-unit>
        <trans-unit id="69e74f77cfb1d64cc1f2b8b0e7553a0f92d29c07" translate="yes" xml:space="preserve">
          <source>will be assumed. In a</source>
          <target state="translated">将被假定。在</target>
        </trans-unit>
        <trans-unit id="3ffcf20d5b3d655c1147575473aace4b9819db78" translate="yes" xml:space="preserve">
          <source>will be at the start of a block, so variables may be defined in it.</source>
          <target state="translated">将在一个块的开头,所以可以在其中定义变量。</target>
        </trans-unit>
        <trans-unit id="cf4139ebee2a50a45a47c6c20c8db3e1866f4f96" translate="yes" xml:space="preserve">
          <source>will be automatically appended if no dot is present in the name. The workaround is as simple as that: since</source>
          <target state="translated">如果名称中没有点,则会自动添加。变通的方法就这么简单:由于</target>
        </trans-unit>
        <trans-unit id="5a46024906c3202205c9b86fbe8cd6c05e18f661" translate="yes" xml:space="preserve">
          <source>will be automatically closed.</source>
          <target state="translated">将自动关闭。</target>
        </trans-unit>
        <trans-unit id="a5391631955c2960d94bb3306b3cf823fd72eb2e" translate="yes" xml:space="preserve">
          <source>will be called, or whatever is the override, see &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;.</source>
          <target state="translated">将会被调用，或者是任何替代，请参见&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="39863063f526390d21b54f0437be449e32146e0d" translate="yes" xml:space="preserve">
          <source>will be evaluated by &lt;code&gt;wanted()&lt;/code&gt; .</source>
          <target state="translated">将由 &lt;code&gt;wanted()&lt;/code&gt; 评估。</target>
        </trans-unit>
        <trans-unit id="28165e3b4da95eac8adbdc3dff70bd1aebff0f5c" translate="yes" xml:space="preserve">
          <source>will be extracted as if it were:</source>
          <target state="translated">会被提取出来,因为它是。</target>
        </trans-unit>
        <trans-unit id="b611847a2698bb295db4bc4d7f2ff88d3d7bfd77" translate="yes" xml:space="preserve">
          <source>will be incorrectly parsed as:</source>
          <target state="translated">将会被错误地解析为。</target>
        </trans-unit>
        <trans-unit id="6c7777c83dbab33571eaae602d63da07c1775c05" translate="yes" xml:space="preserve">
          <source>will be interpreted DWIMically, often as a comparison against &lt;code&gt;$_&lt;/code&gt; , and may be null to generate a &lt;code&gt;default&lt;/code&gt; block.</source>
          <target state="translated">通常以与 &lt;code&gt;$_&lt;/code&gt; 的比较的方式DWIMical地进行解释，并且可以为null以生成 &lt;code&gt;default&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="75321a4f0c9b87d6d48f48cc9f64b5f655545b5c" translate="yes" xml:space="preserve">
          <source>will be modified to the last $octets position at end of decode. Returns true if $terminator appears output, else returns false.</source>
          <target state="translated">将被修改到解码结束时最后的$octets位置。如果$terminator出现,返回true,否则返回false。</target>
        </trans-unit>
        <trans-unit id="5444aae0d6bc7e881d14ae4362de10908be2d8bc" translate="yes" xml:space="preserve">
          <source>will be moved, and the buffer shortened. This hides the discarded text from any lexing code that runs later, as if the text had never appeared.</source>
          <target state="translated">将被移动,并缩短缓冲区。这样就可以将被丢弃的文本隐藏起来,不被以后运行的任何拼写代码所发现,就像文本从未出现过一样。</target>
        </trans-unit>
        <trans-unit id="fb90a1b23ad48d9287e458757890f8e9565a8afc" translate="yes" xml:space="preserve">
          <source>will be retried. This lets you type &lt;code&gt;man debug&lt;/code&gt; or &lt;code&gt;man op&lt;/code&gt; from the debugger.</source>
          <target state="translated">将重试。这使您可以在调试器中键入 &lt;code&gt;man debug&lt;/code&gt; 或 &lt;code&gt;man op&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ef44a7f700e88aec4c8b15477ecc69c13f947c3" translate="yes" xml:space="preserve">
          <source>will be returned.</source>
          <target state="translated">将被退回。</target>
        </trans-unit>
        <trans-unit id="1970ab6c3e7f53185ec961c7b96e2bec3982ca45" translate="yes" xml:space="preserve">
          <source>will be some defined value if the open succeeds, but &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it fails;</source>
          <target state="translated">如果打开成功，将是一些定义的值，如果打开失败，将是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="b0e5f84ae9a025c95805cfbdda7aba5f2e868b56" translate="yes" xml:space="preserve">
          <source>will be treated as a boolean match because the rules say both a regex match and an explicit test on &lt;code&gt;$_&lt;/code&gt; will be treated as boolean.</source>
          <target state="translated">将被视为布尔匹配，因为规则说正则表达式匹配和对 &lt;code&gt;$_&lt;/code&gt; 的显式测试都将被视为布尔匹配。</target>
        </trans-unit>
        <trans-unit id="7bdb6f7a9a73bafa81d66281077d808cd4f13be5" translate="yes" xml:space="preserve">
          <source>will be twice UTF-8 encoded. A &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; ':encoding(utf8)'&lt;/code&gt; would have avoided the bug, or explicitly opening also the</source>
          <target state="translated">将被两次UTF-8编码。一个 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; ':encoding(utf8)'&lt;/code&gt; 本来可以避免的错误，或者也明确地打开</target>
        </trans-unit>
        <trans-unit id="ee4475df6e379629545ed6276a569f3e2eb1ef11" translate="yes" xml:space="preserve">
          <source>will be undefined, since a recursive structure cannot be constructed using one Perl statement. You should set the &lt;code&gt;Purity&lt;/code&gt; flag to 1 to get additional statements that will correctly fill in these references. Moreover, if &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed when strictures are in effect, you need to ensure that any variables it accesses are previously declared.</source>
          <target state="translated">将不会被定义，因为不能使用一个Perl语句来构造递归结构。您应该将 &lt;code&gt;Purity&lt;/code&gt; 标志设置为1，以获得可以正确填写这些引用的其他语句。此外，如果要在限制生效时进行 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，则需要确保事先声明它访问的任何变量。</target>
        </trans-unit>
        <trans-unit id="eee291ac39ab0e01b156565c777f946041d54d02" translate="yes" xml:space="preserve">
          <source>will be used as the handler for subsequently installed signals.</source>
          <target state="translated">将被用作后续安装信号的处理程序。</target>
        </trans-unit>
        <trans-unit id="4d9bc2ddc4bc2a031e22465c252b6377da6be593" translate="yes" xml:space="preserve">
          <source>will be used for password.</source>
          <target state="translated">将用于密码。</target>
        </trans-unit>
        <trans-unit id="189f210a322c7c2ba81e0ea9896d29ddd547e1b5" translate="yes" xml:space="preserve">
          <source>will be used for the name of the extension. If module_name is not supplied then the name of the first header file will be used, with the first character capitalized.</source>
          <target state="translated">将被用于扩展名。如果没有提供module_name,那么将使用第一个头文件的名称,第一个字符大写。</target>
        </trans-unit>
        <trans-unit id="e9eed5428b5ca4033b733f6e4eabddbdf0bae1ff" translate="yes" xml:space="preserve">
          <source>will be used instead and the output piped through your favourite pager.</source>
          <target state="translated">将被使用,并通过你喜欢的寻呼机进行输出。</target>
        </trans-unit>
        <trans-unit id="00ea2b0f5cc2323252a0479beca63d9f1b08fa40" translate="yes" xml:space="preserve">
          <source>will be warning free regardless of what $ref actually is.</source>
          <target state="translated">无论$ref实际是什么,都将是无警告的。</target>
        </trans-unit>
        <trans-unit id="84d0d493e062ada8d958a287014680fe0c8e6db1" translate="yes" xml:space="preserve">
          <source>will be zero.</source>
          <target state="translated">将为零。</target>
        </trans-unit>
        <trans-unit id="75c5acef5fb2e47df2bf90c4d4c3a7831000cfcd" translate="yes" xml:space="preserve">
          <source>will become:</source>
          <target state="translated">将成为。</target>
        </trans-unit>
        <trans-unit id="e0318a0bb7d80ff064a8678b238ad297c5e7ed6b" translate="yes" xml:space="preserve">
          <source>will both result in the proper type due to the way the overloaded math works.</source>
          <target state="translated">由于重载数学的工作方式,两者都会得出正确的类型。</target>
        </trans-unit>
        <trans-unit id="ed44e6c8395b95eb951ed01fb3df61dd611bca88" translate="yes" xml:space="preserve">
          <source>will build a Perl that supports dynamic loading (which requires a shared</source>
          <target state="translated">将构建一个支持动态加载的Perl(需要一个共享的</target>
        </trans-unit>
        <trans-unit id="2287cd95ce18a71437cb52ed8b1caefedff9eaca" translate="yes" xml:space="preserve">
          <source>will call the Unix emulation library's &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; emulation, which attempts to provide emulation of the stdin, stdout, stderr in force in the parent, providing the child program uses a compatible version of the emulation library.</source>
          <target state="translated">将调用Unix仿真库的 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 仿真，该仿真试图在父程序中提供对有效的stdin，stdout，stderr的仿真，前提是子程序使用该仿真库的兼容版本。</target>
        </trans-unit>
        <trans-unit id="9dd319675b257f0d34e3db5d71aeabc5c8458128" translate="yes" xml:space="preserve">
          <source>will call the native command line direct and no such emulation of a child Unix program will exists. Mileage &lt;b&gt;will&lt;/b&gt; vary. (RISC OS)</source>
          <target state="translated">将直接调用本机命令行，并且不会存在子Unix程序的此类仿真。里程&lt;b&gt;会&lt;/b&gt;有所不同。（RISC操作系统）</target>
        </trans-unit>
        <trans-unit id="5562a8abf4cafe3ad9adfb9e7cbb5beff80d11ed" translate="yes" xml:space="preserve">
          <source>will cause the entire file to be slurped. For large files, it's better to loop:</source>
          <target state="translated">会导致整个文件被吐槽。对于大文件,最好是循环。</target>
        </trans-unit>
        <trans-unit id="c184916ba1fdcc854b79c2ce8f3611570d536868" translate="yes" xml:space="preserve">
          <source>will cause the handler to be called with a similar argument list (except, of course, that &lt;code&gt;$_[2]&lt;/code&gt; will be a reference to the variable).</source>
          <target state="translated">将导致使用类似的参数列表调用该处理程序（当然，除了 &lt;code&gt;$_[2]&lt;/code&gt; 将是对该变量的引用之外）。</target>
        </trans-unit>
        <trans-unit id="caee4713a9cdf89a7945419e9d20fb846188deb3" translate="yes" xml:space="preserve">
          <source>will compile XS code into C code by embedding the constructs necessary to let C functions manipulate Perl values and creates the glue necessary to let Perl access those functions.</source>
          <target state="translated">将通过嵌入必要的结构来将XS代码编译成C代码,让C函数操作Perl的值,并创建必要的胶水让Perl访问这些函数。</target>
        </trans-unit>
        <trans-unit id="bf8a15fdda50374b4163d238b2097ac33d5e0df4" translate="yes" xml:space="preserve">
          <source>will compile XS code into C code by embedding the constructs necessary to let C functions manipulate Perl values and creates the glue necessary to let Perl access those functions. The compiler uses typemaps to determine how to map C function parameters and variables to Perl values.</source>
          <target state="translated">将通过嵌入必要的结构将XS代码编译成C代码,让C函数操纵Perl值,并创建必要的胶水,让Perl访问这些函数。编译器使用类型图来决定如何将C函数参数和变量映射到Perl值。</target>
        </trans-unit>
        <trans-unit id="958cf42d40b9694a262fb0dd1a956ccae7aeee61" translate="yes" xml:space="preserve">
          <source>will construct a &quot;binary&quot; stream, but then enable UTF-8 translation.</source>
          <target state="translated">将构建一个 &quot;二进制 &quot;流,但随后启用UTF-8翻译。</target>
        </trans-unit>
        <trans-unit id="ca2af336688d1e8d5e00a2d443084fd9b744a776" translate="yes" xml:space="preserve">
          <source>will correctly push BLUE onto the top of the stack.</source>
          <target state="translated">将正确地把蓝色推到堆栈的顶部。</target>
        </trans-unit>
        <trans-unit id="ff1d4f6ecbef028562f10ecf8ba054ec728c45eb" translate="yes" xml:space="preserve">
          <source>will create the file &quot;FOO.BAT&quot;. Note &quot;pl2bat&quot; strips any .pl suffix and adds a .bat suffix to the generated file.</source>
          <target state="translated">将创建 &quot;FOO.BAT &quot;文件。注意 &quot;pl2bat &quot;会去掉任何.pl后缀,并在生成的文件中添加一个.bat后缀。</target>
        </trans-unit>
        <trans-unit id="d9d73e9ce730e824d01662cbda4e3da1fcf3537f" translate="yes" xml:space="preserve">
          <source>will do an implicit</source>
          <target state="translated">会做一个隐性的</target>
        </trans-unit>
        <trans-unit id="abce4a07e1007ee8dd7654b319b0cda84bc64efd" translate="yes" xml:space="preserve">
          <source>will do it for you.</source>
          <target state="translated">会为你做的。</target>
        </trans-unit>
        <trans-unit id="7108818138127d16c4094725bba30a3d913149fe" translate="yes" xml:space="preserve">
          <source>will do what you mean (fail if stuff is empty)</source>
          <target state="translated">会按照你的意思去做(如果东西是空的就会失败</target>
        </trans-unit>
        <trans-unit id="066b5eeba4c2198d50173831282c3c44664d4d50" translate="yes" xml:space="preserve">
          <source>will effectively become</source>
          <target state="translated">将有效地成为</target>
        </trans-unit>
        <trans-unit id="7b01657f6df9723f80897f0a01fd87afb4d0fa02" translate="yes" xml:space="preserve">
          <source>will extract and format the documentation from any file in the current directory, any Perl module installed on the system, or any of the standard documentation pages, such as this one. Use &lt;code&gt;perldoc &amp;lt;name&amp;gt;&lt;/code&gt; to get information on any of the utilities described in this document.</source>
          <target state="translated">将从当前目录中的任何文件，系统上安装的任何Perl模块或任何标准文档页面（例如此页面）中提取文档并设置其格式。使用 &lt;code&gt;perldoc &amp;lt;name&amp;gt;&lt;/code&gt; 获取有关本文档中描述的任何实用程序的信息。</target>
        </trans-unit>
        <trans-unit id="915564ffa096011256f1ddfb99671491100c6813" translate="yes" xml:space="preserve">
          <source>will fail, since Test.pm considers the second argument to be a regex! The best bet is to use the one-argument form:</source>
          <target state="translated">将会失败,因为 Test.pm 认为第二个参数是一个 regex! 最好的办法是使用单参数形式。</target>
        </trans-unit>
        <trans-unit id="212fc5e54752a78ba3b78f936f759ccf3eed955c" translate="yes" xml:space="preserve">
          <source>will generate or as a reference to a hash.</source>
          <target state="translated">将生成或作为一个哈希的引用。</target>
        </trans-unit>
        <trans-unit id="2a53f1b0c5018113eb37388423f971ca2d0e17a9" translate="yes" xml:space="preserve">
          <source>will give the same result with or without &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; The power operator &lt;code&gt;**&lt;/code&gt; is also not affected, so that 2 ** .5 is always the square root of 2. Now, it so happens that the pre- and post- increment and decrement operators, ++ and --, are not affected by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; either. Some may rightly consider this to be a bug -- but at least it's a long-standing one.</source>
          <target state="translated">使用或不 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 将给出相同的结果；幂运算符 &lt;code&gt;**&lt;/code&gt; 也不受影响，因此2 ** .5始终是2的平方根。现在，碰巧发生了增量和减量运算符++和-都没有。受 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 影响；要么。有些人可能正确地认为这是一个错误-至少它是一个长期存在的错误。</target>
        </trans-unit>
        <trans-unit id="e522bd0030bde0cd245c6a6a2088de240b790d1c" translate="yes" xml:space="preserve">
          <source>will have exactly the opposite restrictions.</source>
          <target state="translated">将有完全相反的限制。</target>
        </trans-unit>
        <trans-unit id="911e01951fb3b7f75048f4c14389ccff0d911ab7" translate="yes" xml:space="preserve">
          <source>will have the same effect. This construct is</source>
          <target state="translated">会有同样的效果。这个结构是</target>
        </trans-unit>
        <trans-unit id="027d9dd767a399ed29c2f093303b12c4fc85e09e" translate="yes" xml:space="preserve">
          <source>will have their leading dashes stripped.</source>
          <target state="translated">前面的破折号将被去掉。</target>
        </trans-unit>
        <trans-unit id="2194c108734d216b207d2d189e6b066bdc993596" translate="yes" xml:space="preserve">
          <source>will have to specify the installation directories as these most probably have changed since perl itself has been installed. They will have to do this by calling</source>
          <target state="translated">将不得不指定安装目录,因为这些目录很可能在perl本身被安装后发生了变化。他们必须通过调用</target>
        </trans-unit>
        <trans-unit id="fd5c38ed8c7727c38022b12bfd4163d2940b7d68" translate="yes" xml:space="preserve">
          <source>will hold.</source>
          <target state="translated">将持有。</target>
        </trans-unit>
        <trans-unit id="cbda0dd99d938557f490efeb2ffa5530b4ef022d" translate="yes" xml:space="preserve">
          <source>will in most computers print 0, not 1, because even such simple numbers as 0.6 and 0.2 cannot be presented exactly by floating-point numbers. What you think in the above as 'three' is really more like 2.9999999999999995559.</source>
          <target state="translated">因为即使是0.6和0.2这样简单的数字也不能完全用浮点数表示。上面你认为的 &quot;3 &quot;其实更像是2.99999999999995559。</target>
        </trans-unit>
        <trans-unit id="0b96340c4517d8e5916a24e5c0c58c099ab880e5" translate="yes" xml:space="preserve">
          <source>will initially increment &lt;code&gt;$cnt&lt;/code&gt; up to 8; then during backtracking, its value will be unwound back to 4, which is the value assigned to &lt;code&gt;$res&lt;/code&gt; . At the end of the regex execution, $cnt will be wound back to its initial value of 0.</source>
          <target state="translated">最初将 &lt;code&gt;$cnt&lt;/code&gt; 增加到8；然后在回溯期间，其值将退绕到4，这是分配给 &lt;code&gt;$res&lt;/code&gt; 的值。在正则表达式执行结束时，$ cnt将恢复为初始值0。</target>
        </trans-unit>
        <trans-unit id="482fd60cac120fdf28a98539580c1dc1bf947239" translate="yes" xml:space="preserve">
          <source>will invoke &lt;code&gt;ExtUtils::Embed&lt;/code&gt; functions while building your application.</source>
          <target state="translated">将在构建应用程序时调用 &lt;code&gt;ExtUtils::Embed&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="ec31983ab84cf33f76bb7f28f95cd8a45d78dd13" translate="yes" xml:space="preserve">
          <source>will it apply the &lt;code&gt;Bent&lt;/code&gt; attribute to the variable.</source>
          <target state="translated">它将 &lt;code&gt;Bent&lt;/code&gt; 属性应用于变量。</target>
        </trans-unit>
        <trans-unit id="cdb47b66626fed7da3a69fabf094bf802562db6c" translate="yes" xml:space="preserve">
          <source>will just extract the &quot;USAGE&quot; section; some of the utilities will automatically call</source>
          <target state="translated">将只提取 &quot;USAGE &quot;部分;一些实用程序会自动调用</target>
        </trans-unit>
        <trans-unit id="be6de1408397f34ac967e76e8f03f5647f72bce4" translate="yes" xml:space="preserve">
          <source>will load MODULE only if CONDITION evaluates to true. The above statement has no effect unless &lt;code&gt;CONDITION&lt;/code&gt; is true. If the CONDITION does evaluate to true, then the above line has the same effect as:</source>
          <target state="translated">仅当CONDITION评估为true时才加载MODULE。除非 &lt;code&gt;CONDITION&lt;/code&gt; 为真，否则以上声明无效。如果CONDITION的评估结果为true，则上述行与以下行具有相同的作用：</target>
        </trans-unit>
        <trans-unit id="417947d63110228931cd8773ca1769b0152ef181" translate="yes" xml:space="preserve">
          <source>will lock the tied file. &lt;code&gt;MODE&lt;/code&gt; has the same meaning as the second argument to the Perl built-in &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; function; for example &lt;code&gt;LOCK_SH&lt;/code&gt; or &lt;code&gt;LOCK_EX | LOCK_NB&lt;/code&gt; . (These constants are provided by the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Fcntl ':flock'&lt;/code&gt; declaration.)</source>
          <target state="translated">将锁定绑定的文件。 &lt;code&gt;MODE&lt;/code&gt; 与Perl内置的 &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 函数的第二个参数的含义相同；例如 &lt;code&gt;LOCK_SH&lt;/code&gt; 或 &lt;code&gt;LOCK_EX | LOCK_NB&lt;/code&gt; 。 （这些常量由 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Fcntl ':flock'&lt;/code&gt; 声明提供。）</target>
        </trans-unit>
        <trans-unit id="fde5332cf051e296efcfa60b991d8b50c9c48011" translate="yes" xml:space="preserve">
          <source>will look like this:</source>
          <target state="translated">会是这个样子。</target>
        </trans-unit>
        <trans-unit id="9e385389da5f12d892ae543d3886ffd128ec573e" translate="yes" xml:space="preserve">
          <source>will match &quot;foo&quot; using the locale's rules for case-insensitive matching, but the &lt;code&gt;/l&lt;/code&gt; does not affect how the &lt;code&gt;\U&lt;/code&gt; operates. Most likely you want both of them to use locale rules. To do this, instead compile the regular expression within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . This both implicitly adds the &lt;code&gt;/l&lt;/code&gt; , and applies locale rules to the &lt;code&gt;\U&lt;/code&gt; . The lesson is to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , and not &lt;code&gt;/l&lt;/code&gt; explicitly.</source>
          <target state="translated">将使用不区分大小写的语言环境规则来匹配&amp;ldquo; foo&amp;rdquo;，但 &lt;code&gt;/l&lt;/code&gt; 不会影响 &lt;code&gt;\U&lt;/code&gt; 运行方式。您最有可能希望他们两个都使用语言环境规则。为此，请在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 范围内编译正则表达式。这既隐含添加 &lt;code&gt;/l&lt;/code&gt; ，并适用区域规则的 &lt;code&gt;\U&lt;/code&gt; 。课程是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ，而不是显式使用 &lt;code&gt;/l&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="109f68c2b8ad8f0d77ed465628f16e2a2c2e7277" translate="yes" xml:space="preserve">
          <source>will match &lt;code&gt;\x8e&lt;/code&gt; , even though &lt;code&gt;\x89&lt;/code&gt; is &quot;i&quot; and &lt;code&gt;\x91 &lt;/code&gt; is &quot;j&quot;, and &lt;code&gt;\x8e&lt;/code&gt; is a gap character, from the alphabetic viewpoint.</source>
          <target state="translated">从字母的角度来看，即使 &lt;code&gt;\x89&lt;/code&gt; 是&amp;ldquo; i&amp;rdquo;并且 &lt;code&gt;\x91 &lt;/code&gt; 是&amp;ldquo; j&amp;rdquo;，并且 &lt;code&gt;\x8e&lt;/code&gt; 是空格字符，也将匹配 &lt;code&gt;\x8e&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90a6766448c16d38bfe8dff80f09487335928909" translate="yes" xml:space="preserve">
          <source>will match &lt;code&gt;blah&lt;/code&gt; in any case, some spaces, and an exact (</source>
          <target state="translated">在任何情况下都可以匹配 &lt;code&gt;blah&lt;/code&gt; ，有些空格和精确的（</target>
        </trans-unit>
        <trans-unit id="0b19d9e504a210ea89daa1807562b0478767084f" translate="yes" xml:space="preserve">
          <source>will match, and &lt;code&gt;$1&lt;/code&gt; will be &lt;code&gt;AB&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; will be &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; will not be set. If another branch in the inner parentheses was matched, such as in the string 'ACDE', then the &lt;code&gt;D&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; would have to be matched as well.</source>
          <target state="translated">将匹配，并且 &lt;code&gt;$1&lt;/code&gt; 将是 &lt;code&gt;AB&lt;/code&gt; ,而 &lt;code&gt;$2&lt;/code&gt; 将是 &lt;code&gt;B&lt;/code&gt; ，将不会设置 &lt;code&gt;$3&lt;/code&gt; 。如果内括号中的另一个分支（例如字符串&amp;ldquo; ACDE&amp;rdquo;）匹配，则 &lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;E&lt;/code&gt; 也必须匹配。</target>
        </trans-unit>
        <trans-unit id="db2173f99c15aec604a37b03bb19ad87c2e9686f" translate="yes" xml:space="preserve">
          <source>will modify $u2 as well as $u1, because both variables are references to the same array. Had &lt;code&gt;getusers&lt;/code&gt; not been memoized, $u1 and $u2 would have referred to different arrays.</source>
          <target state="translated">将同时修改$ u2和$ u1，因为这两个变量都是对同一数组的引用。有 &lt;code&gt;getusers&lt;/code&gt; 没有memoized，$ U1和U2 $就不得不提到不同的阵列。</target>
        </trans-unit>
        <trans-unit id="56a0e2c0e3a6bfe2b40c936f6d822ddccc889e47" translate="yes" xml:space="preserve">
          <source>will neither assign 42 to $x</source>
          <target state="translated">既不会将42分配给$x</target>
        </trans-unit>
        <trans-unit id="9edcb2b7ab077ed29ec9d28bcba6b5e91ef13ffe" translate="yes" xml:space="preserve">
          <source>will never be accessed. Additionally, the existence of</source>
          <target state="translated">将永远不会被访问。此外,由于存在</target>
        </trans-unit>
        <trans-unit id="524ef249301f2929ce4307d365e5fa52cb183591" translate="yes" xml:space="preserve">
          <source>will never match, as the &lt;code&gt;a++&lt;/code&gt; will gobble up all the &lt;code&gt;a&lt;/code&gt; 's in the string and won't leave any for the remaining part of the pattern. This feature can be extremely useful to give perl hints about where it shouldn't backtrack. For instance, the typical &quot;match a double-quoted string&quot; problem can be most efficiently performed when written as:</source>
          <target state="translated">永远不会匹配，因为 &lt;code&gt;a++&lt;/code&gt; 会吞噬字符串中的所有 &lt;code&gt;a&lt;/code&gt; ，并且不会在模式的其余部分留下任何内容。此功能对于给perl提示不应该回溯的位置非常有用。例如，当编写为以下形式时，可以最有效地执行典型的&amp;ldquo;匹配双引号字符串&amp;rdquo;问题：</target>
        </trans-unit>
        <trans-unit id="cf101365c53e8f42c5b08ca87943df667dc3b58c" translate="yes" xml:space="preserve">
          <source>will not affect</source>
          <target state="translated">不会影响</target>
        </trans-unit>
        <trans-unit id="f0a53a44c73c968f4506c42dbd7c202fdde9aa25" translate="yes" xml:space="preserve">
          <source>will not automatically generate prototype code for all xsubs. This flag will enable prototypes.</source>
          <target state="translated">不会为所有的xsub自动生成原型代码。此标志将启用原型。</target>
        </trans-unit>
        <trans-unit id="37f358342227139465ebf67d77c4e5c07cc3ca01" translate="yes" xml:space="preserve">
          <source>will not create an intermediate list of 500,000 integers.</source>
          <target state="translated">不会创建一个500,000个整数的中间列表。</target>
        </trans-unit>
        <trans-unit id="a909cd12fa7841454a3513c9ecc27aa26ed050e5" translate="yes" xml:space="preserve">
          <source>will not, and a subsequent pop won't restore the correct attributes. PUSHCOLOR pushes the attributes set by its argument, which is normally a string of color constants. It can't ask the terminal what the current attributes are.</source>
          <target state="translated">不会,而且随后的弹出也不会恢复正确的属性。PUSHCOLOR 推送由其参数设置的属性,通常是一串颜色常量。它不能询问终端当前的属性是什么。</target>
        </trans-unit>
        <trans-unit id="5aecbb74b57e959a8f88701a03d15ec0b4986702" translate="yes" xml:space="preserve">
          <source>will not. If you are using background colors, you will probably want to either use say() (in newer versions of Perl) or print the newline with a separate print statement to avoid confusing the terminal.</source>
          <target state="translated">不会。如果你使用的是背景色,你可能需要使用say()(在较新版本的Perl中),或者用单独的打印语句打印新行,以避免混淆终端。</target>
        </trans-unit>
        <trans-unit id="51cb32ab55ef73ac4c7e3b3c80f2c3a6bd4c4502" translate="yes" xml:space="preserve">
          <source>will output &quot;o&quot; twice.</source>
          <target state="translated">将输出 &quot;o &quot;两次。</target>
        </trans-unit>
        <trans-unit id="a06e774b79ee30cc4528a712043ad54d3f5a1a0f" translate="yes" xml:space="preserve">
          <source>will output &lt;code&gt;0&lt;/code&gt; on default 32-bit builds, since &lt;code&gt;bigint&lt;/code&gt; never sees the string literals. To ensure the expression is all treated as &lt;code&gt;Math::BigInt&lt;/code&gt; objects, use a literal number in the expression:</source>
          <target state="translated">由于 &lt;code&gt;bigint&lt;/code&gt; 永远不会看到字符串文字，因此在默认的32位版本上将输出 &lt;code&gt;0&lt;/code&gt; 。为确保将表达式全部视为 &lt;code&gt;Math::BigInt&lt;/code&gt; 对象，请在表达式中使用文字数字：</target>
        </trans-unit>
        <trans-unit id="07967563cc177965a7ed97715e81d6fdae7cbfa8" translate="yes" xml:space="preserve">
          <source>will output &lt;code&gt;0&lt;/code&gt; on default 32-bit builds, since &lt;code&gt;bigrat&lt;/code&gt; never sees the string literals. To ensure the expression is all treated as &lt;code&gt;Math::BigInt&lt;/code&gt; or &lt;code&gt;BigFloat&lt;/code&gt; objects, use a literal number in the expression:</source>
          <target state="translated">在默认的32位版本中，它将输出 &lt;code&gt;0&lt;/code&gt; ，因为 &lt;code&gt;bigrat&lt;/code&gt; 从未看到字符串文字。为确保将表达式全部视为 &lt;code&gt;Math::BigInt&lt;/code&gt; 或 &lt;code&gt;BigFloat&lt;/code&gt; 对象，请在表达式中使用文字数字：</target>
        </trans-unit>
        <trans-unit id="b71659f573a74f6d9f73f656d46b8610e6881c01" translate="yes" xml:space="preserve">
          <source>will output &lt;code&gt;0&lt;/code&gt; on default 32-bit builds, since &lt;code&gt;bigrat&lt;/code&gt; never sees the string literals. To ensure the expression is all treated as &lt;code&gt;Math::BigInt&lt;/code&gt; or &lt;code&gt;Math::BigRat&lt;/code&gt; objects, use a literal number in the expression:</source>
          <target state="translated">在默认的32位版本中，它将输出 &lt;code&gt;0&lt;/code&gt; ，因为 &lt;code&gt;bigrat&lt;/code&gt; 从未看到字符串文字。为确保将表达式全部视为 &lt;code&gt;Math::BigInt&lt;/code&gt; 或 &lt;code&gt;Math::BigRat&lt;/code&gt; 对象，请在表达式中使用文字数字：</target>
        </trans-unit>
        <trans-unit id="5d7a9b3fb1f88c1e1d18d8b9c37f765ed993681d" translate="yes" xml:space="preserve">
          <source>will place into $count the number of digit groups found in $string. This happens because the pattern match is in list context (since it is being assigned to the empty list), and will therefore return a list of all matching parts of the string. The list assignment in scalar context will translate that into the number of elements (here, the number of times the pattern matched) and assign that to $count. Note that simply using</source>
          <target state="translated">将把在$string中找到的数字组的数量放入$count中。这是因为模式匹配是在列表上下文中进行的(因为它被赋值给了空列表),因此将返回字符串中所有匹配部分的列表。在标量上下文中的列表赋值将把它转化为元素的数量(这里是模式匹配的次数),并将其赋值给$count。请注意,仅仅使用</target>
        </trans-unit>
        <trans-unit id="158b4d249db9d3c641342d6ffe07a57aa001b196" translate="yes" xml:space="preserve">
          <source>will preserve the error and restore reliable error handling.</source>
          <target state="translated">将保留错误并恢复可靠的错误处理。</target>
        </trans-unit>
        <trans-unit id="d893c24989b32aee817b8346e7ad376f369b2d24" translate="yes" xml:space="preserve">
          <source>will print</source>
          <target state="translated">将打印</target>
        </trans-unit>
        <trans-unit id="fd687fe7714e5a81fa512dd577f023b74092d11e" translate="yes" xml:space="preserve">
          <source>will print 2, not 1. The only exception is that regular expressions have &lt;code&gt;\X&lt;/code&gt; for matching an extended grapheme cluster. (Thus &lt;code&gt;\X&lt;/code&gt; in a regular expression would match the entire sequence of both the example characters.)</source>
          <target state="translated">将打印2，而不是1。唯一的例外是正则表达式的 &lt;code&gt;\X&lt;/code&gt; 与扩展的字素簇匹配。（因此，正则表达式中的 &lt;code&gt;\X&lt;/code&gt; 将匹配两个示例字符的整个序列。）</target>
        </trans-unit>
        <trans-unit id="5094300d0d532d8932e70f6691fa42ee86dfc712" translate="yes" xml:space="preserve">
          <source>will print nothing but newlines. Use either &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; or &lt;a href=&quot;bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt; to get this to work.</source>
          <target state="translated">将只打印换行符。使用&lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;或&lt;a href=&quot;bigfloat&quot;&gt;Math :: BigFloat&lt;/a&gt;使其起作用。</target>
        </trans-unit>
        <trans-unit id="5f20759593b002250a08ac3165608cf59d1d82f9" translate="yes" xml:space="preserve">
          <source>will print out:</source>
          <target state="translated">会打印出来。</target>
        </trans-unit>
        <trans-unit id="2e9aaf473ea286c62a53337f9951358323be6844" translate="yes" xml:space="preserve">
          <source>will print the number of items returned from the Perl subroutine and their value (for simplicity it assumes that they are integer). So if</source>
          <target state="translated">将打印从Perl子程序返回的项目数和它们的值(为了简单起见,它假设它们是整数)。因此,如果</target>
        </trans-unit>
        <trans-unit id="f115f3fe71ae59d269dceb54d217a18d98aaf788" translate="yes" xml:space="preserve">
          <source>will print the sorted contents of the file named</source>
          <target state="translated">将打印名为</target>
        </trans-unit>
        <trans-unit id="898011ad8ba0ad932dc0a21e6656a3baf0ccd836" translate="yes" xml:space="preserve">
          <source>will print: 5.8, -5, 7, 3, 2, 10, 1, 2147483647, -2147483648</source>
          <target state="translated">将打印。5.8,-5,7,3,2,10,1,2147483647,-2147483648</target>
        </trans-unit>
        <trans-unit id="a2df2915d4c95ac1935b8649d919c89f0b71efb7" translate="yes" xml:space="preserve">
          <source>will produce HTML pages from POD.</source>
          <target state="translated">将从POD中生成HTML页面。</target>
        </trans-unit>
        <trans-unit id="35a48bc9e89843fe90d9679e3c72dc42ba9f3426" translate="yes" xml:space="preserve">
          <source>will produce a customized executable.</source>
          <target state="translated">将产生一个自定义的可执行文件。</target>
        </trans-unit>
        <trans-unit id="37ce8d4fdf5864184a859e4556249981464a898f" translate="yes" xml:space="preserve">
          <source>will produce error messages, usually caused by the fact that there are still threads running when the program exits. You should not be alarmed by this.</source>
          <target state="translated">会产生错误信息,通常是由于程序退出时仍有线程在运行。你不应该为此而惊慌失措。</target>
        </trans-unit>
        <trans-unit id="40a447e2e638aff917b8a98c4dbccbd2ef36fe3c" translate="yes" xml:space="preserve">
          <source>will read a record of no more than 32768 characters from $fh. If you're not reading from a record-oriented file (or your OS doesn't have record-oriented files), then you'll likely get a full chunk of data with every read. If a record is larger than the record size you've set, you'll get the record back in pieces. Trying to set the record size to zero or less is deprecated and will cause $/ to have the value of &quot;undef&quot;, which will cause reading in the (rest of the) whole file.</source>
          <target state="translated">将从$fh中读取不超过32768个字符的记录。如果你不是从一个面向记录的文件中读取(或者你的操作系统没有面向记录的文件),那么你很可能每次读取都会得到一整块数据。如果一条记录大于你设置的记录大小,你会得到一块块的记录。试图将记录大小设置为零或更小是被废弃的,并且会导致$/的值为 &quot;undef&quot;,这将导致读入(其余的)整个文件。</target>
        </trans-unit>
        <trans-unit id="9dbce3601b41181a479b14fe24812dbea1320b3d" translate="yes" xml:space="preserve">
          <source>will remain open. The fact that Berkeley DB then reports the attempt to open a database that is already open via the catch-all &quot;Invalid argument&quot; doesn't help.</source>
          <target state="translated">将保持开放。事实上,Berkeley DB通过 &quot;无效参数 &quot;报告了打开一个已经打开的数据库的尝试,这并没有帮助。</target>
        </trans-unit>
        <trans-unit id="6f37ba2b9a5fbee754eb7c8269a813aeb18cd4ca" translate="yes" xml:space="preserve">
          <source>will require a leading colon (as in &lt;code&gt;&quot;=for :formatname&quot;&lt;/code&gt; , or &lt;code&gt;&quot;=begin :formatname&quot; ... &quot;=end :formatname&quot;&lt;/code&gt; ), to signal that the text is not raw data, but instead</source>
          <target state="translated">将需要一个前导冒号（如 &lt;code&gt;&quot;=for :formatname&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;=begin :formatname&quot; ... &quot;=end :formatname&quot;&lt;/code&gt; ），以表明该文本不是原始数据，而是</target>
        </trans-unit>
        <trans-unit id="00e02cdb26815577afd3b77c2b81936feda569cf" translate="yes" xml:space="preserve">
          <source>will reset the display mode afterward, whereas:</source>
          <target state="translated">后会重置显示模式,而。</target>
        </trans-unit>
        <trans-unit id="cfd246ad185bc0482eb908f8133758235cbeffe1" translate="yes" xml:space="preserve">
          <source>will restore the value of &lt;code&gt;SV&lt;/code&gt; using the stored value. It doesn't handle magic. Use &lt;code&gt;save_scalar&lt;/code&gt; if magic is affected.</source>
          <target state="translated">将使用存储的值恢复 &lt;code&gt;SV&lt;/code&gt; 的值。它不能处理魔术。如果魔法受到影响，请使用 &lt;code&gt;save_scalar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcf47e23e9e89e816d5345e18bf5cc985f8e41ea" translate="yes" xml:space="preserve">
          <source>will result in the &lt;code&gt;@_&lt;/code&gt; array having the following values:</source>
          <target state="translated">将导致 &lt;code&gt;@_&lt;/code&gt; 数组具有以下值：</target>
        </trans-unit>
        <trans-unit id="b214f323b0d930bc4b48c529ba1af86a9de0d7a3" translate="yes" xml:space="preserve">
          <source>will set &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; , but</source>
          <target state="translated">将设置 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;v&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; ，但是</target>
        </trans-unit>
        <trans-unit id="f66b27e740d658271832997896a10c6bbc45b211" translate="yes" xml:space="preserve">
          <source>will set &lt;code&gt;vax&lt;/code&gt; .</source>
          <target state="translated">将设置 &lt;code&gt;vax&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abeb9a24b6c6f570b68ade97160028350917ace8" translate="yes" xml:space="preserve">
          <source>will set all three.</source>
          <target state="translated">将设置所有三个。</target>
        </trans-unit>
        <trans-unit id="6454ef3b29477d49c2c7980e79cde8b57c1ed94f" translate="yes" xml:space="preserve">
          <source>will still exist after the call to</source>
          <target state="translated">在调用到</target>
        </trans-unit>
        <trans-unit id="588ec16637097d7d1d0638d77c96a8a5032b93a3" translate="yes" xml:space="preserve">
          <source>will test only the regex, which causes both operands to be treated as boolean. Watch out for this one, then, because an arrayref is always a true value, which makes it effectively redundant. Not a good idea.</source>
          <target state="translated">将只测试regex,这将导致两个操作数都被视为布尔值。那么,请注意这一点,因为arrayref总是一个真值,这使得它实际上是多余的。不是一个好主意。</target>
        </trans-unit>
        <trans-unit id="bcbf4eab8642ab8923d66dad2868cf95ad241494" translate="yes" xml:space="preserve">
          <source>will then attempt to:</source>
          <target state="translated">然后将试图。</target>
        </trans-unit>
        <trans-unit id="9f4bb9d65e83043ff5b7e82034ad61c789030aed" translate="yes" xml:space="preserve">
          <source>will transliterate any A to X.</source>
          <target state="translated">将任何A翻译成X。</target>
        </trans-unit>
        <trans-unit id="8c5ff1dc5075b42cbe189997bcd24a4dd7044963" translate="yes" xml:space="preserve">
          <source>will trigger two filters, one for the reading of the key and one for the reading of the value.</source>
          <target state="translated">将触发两个过滤器,一个用于读取键,一个用于读取值。</target>
        </trans-unit>
        <trans-unit id="3ed3f8cd65c348f27de4a80b666167e4693d1656" translate="yes" xml:space="preserve">
          <source>will try loading the classes YourProjClass::en_us (note lowercase!), YourProjClass::fr, YourProjClass::kon, YourProjClass::i_klingon and YourProjClass::i_klingon_romanized. (And it'll stop at the first one that actually loads.)</source>
          <target state="translated">将尝试加载YourProjClass::en_us (注意小写!),YourProjClass::fr,YourProjClass::kon,YourProjClass::i_klingon 和 YourProjClass::i_klingon_romanized等类。(它会在第一个真正加载的地方停止。)</target>
        </trans-unit>
        <trans-unit id="c097b2a013bfe704dfa7b64798a8d4b40a34ed49" translate="yes" xml:space="preserve">
          <source>will use smart matching (only the first operand is considered), whereas</source>
          <target state="translated">将使用智能匹配(只考虑第一个操作数),而</target>
        </trans-unit>
        <trans-unit id="5cc2cc537da4d8f70033128374e99deb871707f6" translate="yes" xml:space="preserve">
          <source>will use smartmatching because only</source>
          <target state="translated">将使用智能匹配,因为只有</target>
        </trans-unit>
        <trans-unit id="514139923bd059976cc81a9bef6162ccd170175a" translate="yes" xml:space="preserve">
          <source>will usually call</source>
          <target state="translated">通常会叫</target>
        </trans-unit>
        <trans-unit id="81fcf2d95c7bfeca0899d8452fef6f4f9bd6f8d9" translate="yes" xml:space="preserve">
          <source>will work as well.)</source>
          <target state="translated">也可以)。)</target>
        </trans-unit>
        <trans-unit id="2892afe1b68a0f4ac688e2819db40fcb2dbe61aa" translate="yes" xml:space="preserve">
          <source>will work correctly. These mixed cases don't do always work when using Math::BigInt or Math::BigFloat alone, or at least not in the way normal Perl scalars work.</source>
          <target state="translated">将会正确工作。当单独使用 Math::BigInt 或 Math::BigFloat 时,这些混合情况并不总是有效,或者至少不是以普通 Perl 标量的方式工作。</target>
        </trans-unit>
        <trans-unit id="bc5353c166b1ce6a2755fffe1f9473c7c604fb2e" translate="yes" xml:space="preserve">
          <source>will work in many but not all cases. You see, it's too simple-minded for certain kinds of C programs, in particular, those with what appear to be comments in quoted strings. For that, you'd need something like this, created by Jeffrey Friedl and later modified by Fred Curtis.</source>
          <target state="translated">在很多情况下都可以使用,但不是所有情况。你看,它对于某些类型的C程序来说太简单了,尤其是那些看起来像是引号字符串中的注释的程序。为此,你需要像这样的东西,由Jeffrey Friedl创建,后来由Fred Curtis修改。</target>
        </trans-unit>
        <trans-unit id="786d912fad11b712a3268fcedeb0dec988a5d652" translate="yes" xml:space="preserve">
          <source>will work with earlier versions of Perl 5. Hence, such a module may take full advantage of syntactical and other improvements in Perl 5 blead.</source>
          <target state="translated">因此,这样的模块可以充分利用 Perl 5 blead 在语法和其他方面的改进。</target>
        </trans-unit>
        <trans-unit id="d11df7412eb53de0f032fa263537630590c98be8" translate="yes" xml:space="preserve">
          <source>win32/</source>
          <target state="translated">win32/</target>
        </trans-unit>
        <trans-unit id="ef20e66907c936dd8f32cedd2cde044f7f103034" translate="yes" xml:space="preserve">
          <source>win32/perllib.c</source>
          <target state="translated">win32/perllib.c</target>
        </trans-unit>
        <trans-unit id="ffc229a00767de35e4be6135e2ffebcf9882c38a" translate="yes" xml:space="preserve">
          <source>wince</source>
          <target state="translated">wince</target>
        </trans-unit>
        <trans-unit id="123bb8126c34dd474d44011b10cfbf904c3172d4" translate="yes" xml:space="preserve">
          <source>wince port was kept in the same</source>
          <target state="translated">当年的港口保持在同一水平。</target>
        </trans-unit>
        <trans-unit id="5cd6bd4c16cc2a47ce31db4e0755a63599fc21d0" translate="yes" xml:space="preserve">
          <source>wince/Makefile.ce</source>
          <target state="translated">wince/Makefile.ce</target>
        </trans-unit>
        <trans-unit id="8fcd25a39d2037183044a8897e9a5333d727fded" translate="yes" xml:space="preserve">
          <source>with</source>
          <target state="translated">with</target>
        </trans-unit>
        <trans-unit id="516d8aa61b6759073fd78a57717de8007b3370ce" translate="yes" xml:space="preserve">
          <source>with 0 if it does, 1 if it does not (ie. shell's idea of true and false).</source>
          <target state="translated">0为真,1为假(即shell的真假概念)。</target>
        </trans-unit>
        <trans-unit id="38b9a576bee545c23ad008343813d9e755e740e0" translate="yes" xml:space="preserve">
          <source>with 0 if it does, 1 if it does not.</source>
          <target state="translated">有的话为0,没有的话为1。</target>
        </trans-unit>
        <trans-unit id="fd393d67aeb1a238c4b9b75ace210101e95a963c" translate="yes" xml:space="preserve">
          <source>with &lt;code&gt;$1&lt;/code&gt; being the line number for the next line, and &lt;code&gt;$3&lt;/code&gt; being the optional filename (specified with or without quotes). Note that no whitespace may precede the &lt;code&gt;#&lt;/code&gt; , unlike modern C preprocessors.</source>
          <target state="translated">与 &lt;code&gt;$1&lt;/code&gt; 是用于下一行的行号，和 &lt;code&gt;$3&lt;/code&gt; 是可选的文件名（有或没有引号指定）。请注意，与现代C预处理器不同，空格不能在 &lt;code&gt;#&lt;/code&gt; 之前。</target>
        </trans-unit>
        <trans-unit id="dd277e84169e71230b173e5e86d5c72e9dd4d149" translate="yes" xml:space="preserve">
          <source>with C</source>
          <target state="translated">与C</target>
        </trans-unit>
        <trans-unit id="5f35039fcfb7ca39f0e93041f2c52c34be88131b" translate="yes" xml:space="preserve">
          <source>with DOS hooks is available in</source>
          <target state="translated">含有DOS钩子,可在</target>
        </trans-unit>
        <trans-unit id="f257153d465d0a7a17934523c7043d1cba8cb62c" translate="yes" xml:space="preserve">
          <source>with DTrace support enabled.</source>
          <target state="translated">启用了 DTrace 支持。</target>
        </trans-unit>
        <trans-unit id="79e46a1b41acc15ccc42adaa2b069f673632f7cc" translate="yes" xml:space="preserve">
          <source>with Pre-5.0 MakeMakers. Since version 5.00 of MakeMaker such a line can be deleted safely. MakeMaker recognizes when there's nothing to be linked.</source>
          <target state="translated">与5.0之前的MakeMakers。从5.00版本的MakeMaker开始,这样的行可以安全删除。MakeMaker可以识别出什么时候没有东西可以链接。</target>
        </trans-unit>
        <trans-unit id="902f1c78737d167fe1b8e5be3f95f9481cbb5856" translate="yes" xml:space="preserve">
          <source>with a field hash, the entry will be collected, even if it was later overwritten with a plain scalar key (every positive integer is a candidate). This is true even if the original entry was deleted in the meantime. In fact, deletion from a field hash, and also a test for existence constitute</source>
          <target state="translated">的字段哈希,该条目将被收集,即使它后来被一个普通的标量密钥覆盖(每个正整数都是候选者)。即使在此期间原始条目被删除,也是如此。事实上,从字段哈希中删除,也构成了对存在性的测试。</target>
        </trans-unit>
        <trans-unit id="6b1ee94282ce6cd2f8ed1cd3d21d10ed8a2ffaba" translate="yes" xml:space="preserve">
          <source>with a shell</source>
          <target state="translated">带壳</target>
        </trans-unit>
        <trans-unit id="6712fdd90b5e830ff760a98c106a30072131fe7e" translate="yes" xml:space="preserve">
          <source>with a special meaning described here or above. You can cause characters that normally function as metacharacters to be interpreted literally by prefixing them with a &quot;\&quot; (e.g., &quot;\.&quot; matches a &quot;.&quot;, not any character; &quot;\\&quot; matches a &quot;\&quot;). This escape mechanism is also required for the character used as the pattern delimiter.</source>
          <target state="translated">含有这里或上面描述的特殊含义。你可以在通常作为元字符的字符前加上&quot;//&quot;,使其按字面意思解释(例如,&quot;//&quot;匹配的是&quot;.&quot;,而不是任何字符;&quot;//&quot;匹配的是&quot;//&quot;)。这种转义机制也是作为模式定界符的字符所需要的。</target>
        </trans-unit>
        <trans-unit id="b805bc366a9ebde9467176c73458adee5451ed76" translate="yes" xml:space="preserve">
          <source>with actual &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; support. Trailing newline is removed. Returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on &lt;code&gt;EOF&lt;/code&gt; .</source>
          <target state="translated">有实际的 &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 支持。尾随换行符被删除。在 &lt;code&gt;EOF&lt;/code&gt; 上返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90fb5185e4bcea673e4052e2147a5dec2bf61fa2" translate="yes" xml:space="preserve">
          <source>with all the statically loaded extensions built in. Compare the generated</source>
          <target state="translated">内建了所有静态加载的扩展。比较生成的</target>
        </trans-unit>
        <trans-unit id="5634ec8df617c002f5cf19e1a0d68429da0d491c" translate="yes" xml:space="preserve">
          <source>with any non-default flags appearing between the caret and the colon. A test that looks at such stringification thus doesn't need to have the system default flags hard-coded in it, just the caret. If new flags are added to Perl, the meaning of the caret's expansion will change to include the default for those flags, so the test will still work, unchanged.</source>
          <target state="translated">与任何非默认标志出现在逗号和冒号之间。因此,一个研究这种字符串化的测试不需要将系统默认标志硬编码在里面,而只需要使用 caret。如果 Perl 中加入了新的标志,那么 caret 的扩展含义将改变,以包含这些标志的默认值,因此测试仍然可以使用,没有变化。</target>
        </trans-unit>
        <trans-unit id="bb83d536946bb8d10aca0b9c5349a4fa97876fb1" translate="yes" xml:space="preserve">
          <source>with arguments &lt;code&gt;arg1 arg2 arg3&lt;/code&gt; the same way as on any other platform, by</source>
          <target state="translated">使用参数 &lt;code&gt;arg1 arg2 arg3&lt;/code&gt; 的方式与在任何其他平台上相同，</target>
        </trans-unit>
        <trans-unit id="e596474483116f71691799bfb6c85c3d8699a856" translate="yes" xml:space="preserve">
          <source>with bugs in memory allocations which are caught by Perl's malloc();</source>
          <target state="translated">与内存分配中的错误,这些错误被Perl的malloc()捕获。</target>
        </trans-unit>
        <trans-unit id="43e71f90be5e8d458fd62d980464b4dcacad2891" translate="yes" xml:space="preserve">
          <source>with command line &quot;-size 10 -sizes 24 -sizes 48&quot; will perform the equivalent of the assignments</source>
          <target state="translated">与命令行&quot;-size 10 -sizes 24 -sizes 48 &quot;将执行等效于</target>
        </trans-unit>
        <trans-unit id="a6bb8f0d0bfad7a5f424f1936641a121be95eced" translate="yes" xml:space="preserve">
          <source>with contents being (compare with &lt;a href=&quot;#Making-executables-with-a-custom-collection-of-statically-loaded-extensions&quot;&gt;Making executables with a custom collection of statically loaded extensions&lt;/a&gt;)</source>
          <target state="translated">内容是（与使用&lt;a href=&quot;#Making-executables-with-a-custom-collection-of-statically-loaded-extensions&quot;&gt;静态加载的扩展程序的自定义集合制作可执行文件&lt;/a&gt;相比）</target>
        </trans-unit>
        <trans-unit id="df572e1bbeb0b7187cd03ae0e3427ee531dc9c89" translate="yes" xml:space="preserve">
          <source>with djtarx. If you want to use long file names under w95 and also to get Perl to pass all its tests, don't forget to use</source>
          <target state="translated">和 djtarx。如果你想在w95下使用长文件名,并且想让Perl通过所有测试,别忘了使用</target>
        </trans-unit>
        <trans-unit id="0a6e45130091d1990376001a155acd12e04c02af" translate="yes" xml:space="preserve">
          <source>with invaluable help from Chris Nandor, and valuable help from Brandon Allbery, Charles Bailey, Graham Barr, Dominic Dunlop, Jarkko Hietaniemi, Ben Holzman, Tom Horsley, Nick Ing-Simmons, Tuomas J. Lukka, Laszlo Molnar, Alan Olsen, Peter Prymmer, Gurusamy Sarathy, Christoph Spalinger, Dan Sugalski, Larry Virden, and Ilya Zakharevich.</source>
          <target state="translated">Chris Nandor的宝贵帮助,以及Brandon Allbery、Charles Bailey、Graham Barr、Dominic Dunlop、Jarkko Hietaniemi、Ben Holzman、Tom Horsley、Nick Ing-Simmons、Tuomas J.Lukka、Laszlo Molnar、Alan Olsen、Peter Prymmer、Gurusamy Sarathy、Christoph Spalinger、Dan Sugalski、Larry Virden和Ilya Zakharevich的宝贵帮助。</target>
        </trans-unit>
        <trans-unit id="65cc0156037f347b1259f3f102b72fce7d5f35cb" translate="yes" xml:space="preserve">
          <source>with libperl, any static extensions (usually just DynaLoader), and any other libraries needed on this system. libperl is usually</source>
          <target state="translated">和libperl、任何静态扩展(通常只有DynaLoader)以及本系统所需的其他库。libperl通常是</target>
        </trans-unit>
        <trans-unit id="bf9772e7a963a2d3d329698d4cb2a55502f8d67b" translate="yes" xml:space="preserve">
          <source>with more error checking.</source>
          <target state="translated">有更多的错误检查。</target>
        </trans-unit>
        <trans-unit id="83256d944b6616f13d11d6f626aca53da1031053" translate="yes" xml:space="preserve">
          <source>with nonempty prefix1 and prefix2. If &lt;code&gt;prefix1&lt;/code&gt; is indeed a prefix of a builtin library search path, prefix2 is substituted. The error may appear if components are not found, or are too long. See &quot;PERLLIB_PREFIX&quot; in &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;.</source>
          <target state="translated">具有非空的prefix1和prefix2。如果 &lt;code&gt;prefix1&lt;/code&gt; 确实是内置库搜索路径的前缀，则将替换prefix2。如果找不到组件或组件太长，则可能会出现该错误。请参阅&amp;ldquo;PERLLIB_PREFIX&amp;rdquo;在&lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb3f3ef30b8362c52d5cc55a8fa4f09f4693fecb" translate="yes" xml:space="preserve">
          <source>with one range: an anonymous array with a single element that consists of another anonymous array whose first element is the first code point in the block, and whose second element is the final code point in the block. On an EBCDIC platform, the first two Unicode blocks are not contiguous. Their range sets are lists containing</source>
          <target state="translated">与一个范围:一个单元素的匿名数组,由另一个匿名数组组成,该数组的第一个元素是块中的第一个码点,第二个元素是块中的最后一个码点。在EBCDIC平台上,前两个Unicode块是不连续的。它们的范围集是包含以下内容的列表</target>
        </trans-unit>
        <trans-unit id="ad93216dd3f12b7821d87a82a121ecedc2fe0262" translate="yes" xml:space="preserve">
          <source>with other auxiliary files, but, and this is important to note, there should be &lt;b&gt;no&lt;/b&gt;</source>
          <target state="translated">与其他辅助文件一起使用，但是要注意这一点，应该&lt;b&gt;没有&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fb0e475b39d05deac173d43929afb30eefa9a066" translate="yes" xml:space="preserve">
          <source>with some customization slots left out to be filled later.</source>
          <target state="translated">并留出一些自定义的槽位,以便以后填补。</target>
        </trans-unit>
        <trans-unit id="578150dd4f4464b258a72af475d097b197c86ecf" translate="yes" xml:space="preserve">
          <source>with such a routine added (and slightly modified str()):</source>
          <target state="translated">添加了这样一个例程(并稍微修改了str())。</target>
        </trans-unit>
        <trans-unit id="0c303466efe4cbf12a616af1540bc1eb7aaeaf47" translate="yes" xml:space="preserve">
          <source>with the</source>
          <target state="translated">随着</target>
        </trans-unit>
        <trans-unit id="7d1c3bf8c1f9945ec4599b301b51d74a3a85654a" translate="yes" xml:space="preserve">
          <source>with the array elements, returning the number of matches found.</source>
          <target state="translated">和数组元素,返回找到的匹配数量。</target>
        </trans-unit>
        <trans-unit id="06a358e9a286ee4b634c109bfb039300741fcb98" translate="yes" xml:space="preserve">
          <source>with the first line being</source>
          <target state="translated">第一行是</target>
        </trans-unit>
        <trans-unit id="39ef66642cc8f022fcb29b6192f16996d968e41f" translate="yes" xml:space="preserve">
          <source>with the given set of sections. See &lt;b&gt;add_selection()&lt;/b&gt; for adding to the current set of selected sections.</source>
          <target state="translated">与给定的部分集。请参阅&lt;b&gt;add_selection（）&lt;/b&gt;以添加到当前所选节集中。</target>
        </trans-unit>
        <trans-unit id="681d9ba240a75cd0133e9a797e48af7f60cc1289" translate="yes" xml:space="preserve">
          <source>with the key specified by</source>
          <target state="translated">钥匙</target>
        </trans-unit>
        <trans-unit id="fc8ddfc8af720ff32b46e111b20ee99ab44a3ee8" translate="yes" xml:space="preserve">
          <source>with the options '--url &lt;a href=&quot;http://example.com&quot;&gt;http://example.com&lt;/a&gt;'. When running multiple tests they will each receive the same arguments.</source>
          <target state="translated">并带有&amp;ldquo; --url &lt;a href=&quot;http://example.com&quot;&gt;http://example.com&lt;/a&gt; &amp;rdquo; 选项。当运行多个测试时，它们将各自接收相同的参数。</target>
        </trans-unit>
        <trans-unit id="9af249b71f06549e6ec04dac84cfb0149e01d8b1" translate="yes" xml:space="preserve">
          <source>with the same effect.</source>
          <target state="translated">具有同样的效果。</target>
        </trans-unit>
        <trans-unit id="22d6b042eb59b4513f175226eb07a3dda4da0955" translate="yes" xml:space="preserve">
          <source>with the same result as</source>
          <target state="translated">一样的结果</target>
        </trans-unit>
        <trans-unit id="d916cf8b9311e482b651049d8b87bf349a501880" translate="yes" xml:space="preserve">
          <source>with the sequence &lt;code&gt;1100&lt;/code&gt; repeating again and again. In addition to this limitation, the exponent of the binary number is also restricted when it is represented as a floating point number. On typical hardware, floating point values can store numbers with up to 53 binary digits, and with binary exponents between -1024 and 1024. In decimal representation this is close to 16 decimal digits and decimal exponents in the range of -304..304. The upshot of all this is that Perl cannot store a number like 12345678901234567 as a floating point number on such architectures without loss of information.</source>
          <target state="translated">序列 &lt;code&gt;1100&lt;/code&gt; 一次又一次地重复。除此限制外，当二进制数的指数表示为浮点数时，它的指数也受到限制。在典型的硬件上，浮点值最多可以存储53个二进制数字，并且二进制指数在-1024到1024之间。在十进制表示形式中，这接近于16个十进制数字，并且十进制指数在-304..304范围内。所有这些的结果是，Perl不能在不丢失信息的情况下在此类体系结构上存储像12345678901234567这样的数字作为浮点数。</target>
        </trans-unit>
        <trans-unit id="6ba1d9aa0bd57431c1856954244f3cbc94acd62d" translate="yes" xml:space="preserve">
          <source>with these bytes using this option.</source>
          <target state="translated">使用此选项与这些字节。</target>
        </trans-unit>
        <trans-unit id="9f47eb77d09add43952b7bda3f6a0a9cdacda272" translate="yes" xml:space="preserve">
          <source>with this one, once the &lt;code&gt;o&lt;/code&gt; ption &lt;code&gt;frame=2&lt;/code&gt; has been set:</source>
          <target state="translated">与这一个，一旦 &lt;code&gt;o&lt;/code&gt; ption &lt;code&gt;frame=2&lt;/code&gt; 已经被设置：</target>
        </trans-unit>
        <trans-unit id="f42ef62128025c7fd38f4952b8a2dc53beb818e7" translate="yes" xml:space="preserve">
          <source>within</source>
          <target state="translated">within</target>
        </trans-unit>
        <trans-unit id="92f70e05ed425bf86c4992009349d575e4339965" translate="yes" xml:space="preserve">
          <source>within the affected package, but across scopes.</source>
          <target state="translated">在受影响的包内,但跨范围。</target>
        </trans-unit>
        <trans-unit id="de8017cefaab0d61aa697455fcae07e9312b74bc" translate="yes" xml:space="preserve">
          <source>within the referenced group is used as an independent subpattern in place of the group reference itself. Because the group reference may be contained</source>
          <target state="translated">作为一个独立的子模式来代替组引用本身。因为组引用可能包含在</target>
        </trans-unit>
        <trans-unit id="0d4e654c613ea68bffeeab1587b7dbac44826c2b" translate="yes" xml:space="preserve">
          <source>without</source>
          <target state="translated">without</target>
        </trans-unit>
        <trans-unit id="10f2461de60c6d5b4ff8c4b7507377311e349c19" translate="yes" xml:space="preserve">
          <source>without LIB, setting PREFIX replaces the initial &lt;code&gt;$Config{prefix}&lt;/code&gt; part of those INSTALL* arguments, even if the latter are explicitly set (but are set to still start with &lt;code&gt;$Config{prefix}&lt;/code&gt; ).</source>
          <target state="translated">如果没有LIB，则设置PREFIX会替换那些INSTALL *参数的初始 &lt;code&gt;$Config{prefix}&lt;/code&gt; 部分，即使后者已显式设置（但仍设置为以 &lt;code&gt;$Config{prefix}&lt;/code&gt; 开头）。</target>
        </trans-unit>
        <trans-unit id="8a80d0259d1e71d6750796bdfe9afa977177dab1" translate="yes" xml:space="preserve">
          <source>without a good reason.</source>
          <target state="translated">无缘无故。</target>
        </trans-unit>
        <trans-unit id="c2ca9034d0099c94e02d85eb5ba30cf9f74f58f0" translate="yes" xml:space="preserve">
          <source>without the newlines.</source>
          <target state="translated">没有新行。</target>
        </trans-unit>
        <trans-unit id="4732a6d7f96eade3f478fdd4097e2f5ce9f0b28d" translate="yes" xml:space="preserve">
          <source>won't be run at all</source>
          <target state="translated">销声匿迹</target>
        </trans-unit>
        <trans-unit id="18c4254d09ff75421e3936447920117069935d2e" translate="yes" xml:space="preserve">
          <source>won't recursively apply those macros for you.</source>
          <target state="translated">不会为你递归应用这些宏。</target>
        </trans-unit>
        <trans-unit id="3cbcd90adc4b192a87a625850b7f231caddf0eb3" translate="yes" xml:space="preserve">
          <source>word</source>
          <target state="translated">word</target>
        </trans-unit>
        <trans-unit id="c614707e1344dd5a41b584a7fa3720507a41566c" translate="yes" xml:space="preserve">
          <source>word anchor</source>
          <target state="translated">词锚</target>
        </trans-unit>
        <trans-unit id="d44b255df34f22674d602b2084de78dd16835268" translate="yes" xml:space="preserve">
          <source>wordmatch-line.html</source>
          <target state="translated">wordmatch-line.html</target>
        </trans-unit>
        <trans-unit id="e274eeff768c6396088ec6eb091f4bf4d47ab1e0" translate="yes" xml:space="preserve">
          <source>work</source>
          <target state="translated">work</target>
        </trans-unit>
        <trans-unit id="6c6b6f215bf47eca2a6fa7e244846ed1b5e4779d" translate="yes" xml:space="preserve">
          <source>work in this construct, because modifiers don't take loop labels. Sorry. You can always put another block inside of it (for &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;) or around it (for &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;) to do that sort of thing. For &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, just double the braces:</source>
          <target state="translated">在此构造中起作用，因为修饰符不带有循环标签。抱歉。您总是可以在其中（针对 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ）或在其周围（针对 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; ）放置另一个块来执行此类操作。对于 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ，要加倍括号：</target>
        </trans-unit>
        <trans-unit id="62bee0aec6969f0ad0809c8d6cc21d4734187295" translate="yes" xml:space="preserve">
          <source>work properly on native code points and strings.</source>
          <target state="translated">在本地代码点和字符串上正常工作。</target>
        </trans-unit>
        <trans-unit id="e912ba21c9cf05d0fc8a8967f5359aab2729eca4" translate="yes" xml:space="preserve">
          <source>work under OS/390 and on the Macintosh; you probably don't want to use them in new code.</source>
          <target state="translated">在OS/390和Macintosh下工作;你可能不想在新代码中使用它们。</target>
        </trans-unit>
        <trans-unit id="12b6bdd47224ffe593cf3bd066979ef986b0dfa4" translate="yes" xml:space="preserve">
          <source>work within a &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { } while&lt;/code&gt; construct. See &lt;a href=&quot;perlsyn#Loop-Control&quot;&gt;Loop Control in perlsyn&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { } while&lt;/code&gt; 构建时在&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}中工作。请参见&lt;a href=&quot;perlsyn#Loop-Control&quot;&gt;perlsyn中的循环控制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63b2e519f2bfeef08075c12043e9e0b8da4fe0fe" translate="yes" xml:space="preserve">
          <source>work. (This is equivalent to &lt;code&gt;$&lt;i&gt;human&lt;/i&gt;++&lt;/code&gt;, where</source>
          <target state="translated">工作。（这等效于 &lt;code&gt;$&lt;i&gt;human&lt;/i&gt;++&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="10f5ebe6acb4467b71602be4c4fdb44c44fa26b6" translate="yes" xml:space="preserve">
          <source>worker</source>
          <target state="translated">worker</target>
        </trans-unit>
        <trans-unit id="8f69649f0cb724dcfcaf5d34bac347a0650ed559" translate="yes" xml:space="preserve">
          <source>works because &lt;code&gt;$AoA[0]&lt;/code&gt; already held an array reference. If you try that on an undefined variable, you'll take an exception. That's because the implicit derefererence will never autovivify an undefined variable the way &lt;code&gt;@{ }&lt;/code&gt; always will:</source>
          <target state="translated">之所以起作用，是因为 &lt;code&gt;$AoA[0]&lt;/code&gt; 已保存一个数组引用。如果您尝试对未定义的变量进行操作，则会出现异常。这是因为隐式取消引用永远不会像 &lt;code&gt;@{ }&lt;/code&gt; 那样自动使未定义的变量生效：</target>
        </trans-unit>
        <trans-unit id="15124ebfba7fc813f38c973245978f037d3342fc" translate="yes" xml:space="preserve">
          <source>works bottom-up, so does the first pass of perl compilation.</source>
          <target state="translated">自下而上地工作,所以perl编译的第一遍也是如此。</target>
        </trans-unit>
        <trans-unit id="b2f86c6b40fe0bcf02c6b1cac00b3639a3aa830f" translate="yes" xml:space="preserve">
          <source>works just fine. For some storage methods, you need a little glue.</source>
          <target state="translated">工作就可以了。对于一些存储方法,你需要一点胶水。</target>
        </trans-unit>
        <trans-unit id="d192b622956789bdecb1e8dc26768ccb0a1de12d" translate="yes" xml:space="preserve">
          <source>works like a normal hash, except that it stringifies a</source>
          <target state="translated">和普通的哈希一样工作,只是它将一个字符串化的</target>
        </trans-unit>
        <trans-unit id="eef62adcae43a43a24a531e0fcd32b343c0335e6" translate="yes" xml:space="preserve">
          <source>works like the corresponding perl commands.</source>
          <target state="translated">就像相应的perl命令一样。</target>
        </trans-unit>
        <trans-unit id="278395d966ca8f15d90253e7a54af657001b22d5" translate="yes" xml:space="preserve">
          <source>works out the package name and subroutine name from &lt;code&gt;cv&lt;/code&gt; , and then calls &lt;code&gt;croak()&lt;/code&gt; . Hence if &lt;code&gt;cv&lt;/code&gt; is &lt;code&gt;&amp;amp;ouch::awk&lt;/code&gt; , it would call &lt;code&gt;croak&lt;/code&gt; as:</source>
          <target state="translated">从 &lt;code&gt;cv&lt;/code&gt; 中计算出程序包名称和子例程名称，然后调用 &lt;code&gt;croak()&lt;/code&gt; 。因此，如果 &lt;code&gt;cv&lt;/code&gt; 是 &lt;code&gt;&amp;amp;ouch::awk&lt;/code&gt; ，它将称呼 &lt;code&gt;croak&lt;/code&gt; 为：</target>
        </trans-unit>
        <trans-unit id="6be0ee6d5b9de8b6dd59c468448f9682ef33c831" translate="yes" xml:space="preserve">
          <source>works? That way you can type a line, get the answer, type a line, get the answer, etc.</source>
          <target state="translated">的工作原理?这样你就可以打出一条线,得到答案,打出一条线,得到答案等等。</target>
        </trans-unit>
        <trans-unit id="0955dd818206a40e89101bb215630d0623e506fc" translate="yes" xml:space="preserve">
          <source>would</source>
          <target state="translated">would</target>
        </trans-unit>
        <trans-unit id="1cd672c18cd6ca58a99d38415467298ac7edcacd" translate="yes" xml:space="preserve">
          <source>would allocate a 64K buffer for use in an emergency. See the</source>
          <target state="translated">将分配一个64K的缓冲区供紧急情况下使用。参见</target>
        </trans-unit>
        <trans-unit id="0b290e6292697adca00d7d3d5662240ab8fc30bb" translate="yes" xml:space="preserve">
          <source>would be</source>
          <target state="translated">将是</target>
        </trans-unit>
        <trans-unit id="7b69dbdbceacfeb0d76b23c42db32158c5c4f060" translate="yes" xml:space="preserve">
          <source>would be enough, but having full path would make it easier to use your script under *nix.)</source>
          <target state="translated">就足够了,但是有完整的路径会让你的脚本在*nix下更容易使用。)</target>
        </trans-unit>
        <trans-unit id="fac17e9022ec2b662ea926d0797f33367aaf872c" translate="yes" xml:space="preserve">
          <source>would be executed in a manner equivalent to</source>
          <target state="translated">将以相当于</target>
        </trans-unit>
        <trans-unit id="5b9b72bb55102abb737a9210715fff3a86c182fa" translate="yes" xml:space="preserve">
          <source>would be introduced with:</source>
          <target state="translated">将介绍与。</target>
        </trans-unit>
        <trans-unit id="ee71ebda44e2dc671943d14d6333655aa8766836" translate="yes" xml:space="preserve">
          <source>would become:</source>
          <target state="translated">会成为。</target>
        </trans-unit>
        <trans-unit id="fc7bc135c1fe15a09a47ef32c483c004c406321c" translate="yes" xml:space="preserve">
          <source>would cause a longjmp right back to the guard in &lt;code&gt;perl_run&lt;/code&gt; , popping both runops loops, which is clearly incorrect. One way to avoid this is for the tie code to do a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; before executing &lt;code&gt;FETCH&lt;/code&gt; in the inner runops loop, but for efficiency reasons, perl in fact just sets a flag, using &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; . The &lt;code&gt;pp_require&lt;/code&gt; , &lt;code&gt;pp_entereval&lt;/code&gt; and &lt;code&gt;pp_entertry&lt;/code&gt; ops check this flag, and if true, they call &lt;code&gt;docatch&lt;/code&gt; , which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and starts a new runops level to execute the code, rather than doing it on the current loop.</source>
          <target state="translated">会在 &lt;code&gt;perl_run&lt;/code&gt; 中导致longjmp立刻回到后卫，同时弹出两个runops循环，这显然是不正确的。为了避免这种情况的一个方法是为平手代码做一个 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 执行前 &lt;code&gt;FETCH&lt;/code&gt; 在内runops循环，但出于效率的考虑，PERL实际上只是设置一个标志，使用 &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; 。该 &lt;code&gt;pp_require&lt;/code&gt; ， &lt;code&gt;pp_entereval&lt;/code&gt; 和 &lt;code&gt;pp_entertry&lt;/code&gt; OPS检查这个标志，如果属实，他们称之为 &lt;code&gt;docatch&lt;/code&gt; ，它做了 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; ，并开始一个新的水平runops执行代码，而不是做它的电流回路。</target>
        </trans-unit>
        <trans-unit id="8ebd799d293a64e9ed9d39b91ac1f7fed34f437f" translate="yes" xml:space="preserve">
          <source>would cause the following handlers to be invoked:</source>
          <target state="translated">将导致调用以下处理程序。</target>
        </trans-unit>
        <trans-unit id="2b330e24a100ad409d9215e9accd6009a0f6b093" translate="yes" xml:space="preserve">
          <source>would compile to this:</source>
          <target state="translated">会编译成这样。</target>
        </trans-unit>
        <trans-unit id="c97745307a9b13afa0ef5df546ac7a72284b1bc2" translate="yes" xml:space="preserve">
          <source>would correctly match something like this:</source>
          <target state="translated">会正确匹配这样的东西。</target>
        </trans-unit>
        <trans-unit id="71f0319df98f9c2b350311a9ad295b643da5cc03" translate="yes" xml:space="preserve">
          <source>would do. In scalar context, glob iterates through such filename expansions, returning undef when the list is exhausted. This is the internal function implementing the &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; operator, but you can use it directly. If EXPR is omitted, &lt;code&gt;$_&lt;/code&gt; is used. The &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">会做。在标量上下文中，glob遍历此类文件名扩展，当列表用尽时返回undef。这是实现 &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; 运算符的内部函数，但是您可以直接使用它。如果省略EXPR，则使用 &lt;code&gt;$_&lt;/code&gt; 。所述 &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; 操作中更详细讨论的&lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I / O算perlop得到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f56783a28f8038eb78e33a3c46a24ab091b4d2d" translate="yes" xml:space="preserve">
          <source>would do. In scalar context, glob iterates through such filename expansions, returning undef when the list is exhausted. This is the internal function implementing the &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; operator, but you can use it directly. If EXPR is omitted, &lt;code&gt;$_&lt;/code&gt; is used. The &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">会做。在标量上下文中，glob遍历此类文件名扩展，当列表用尽时返回undef。这是实现 &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; 运算符的内部函数，但是您可以直接使用它。如果省略EXPR，则使用 &lt;code&gt;$_&lt;/code&gt; 。所述 &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; 操作中更详细讨论的&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I / O算perlop得到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="37edd169eed8b427b6f69da497b122303092f2b0" translate="yes" xml:space="preserve">
          <source>would fail, returning:</source>
          <target state="translated">会失败,返回。</target>
        </trans-unit>
        <trans-unit id="574cbd21dd4f01cc7e9a5d6c3ebf7c3fc8d35449" translate="yes" xml:space="preserve">
          <source>would get the POD name</source>
          <target state="translated">将获得POD名称</target>
        </trans-unit>
        <trans-unit id="6e320d29fdf6132581dd222d085e227ad58bf37f" translate="yes" xml:space="preserve">
          <source>would give a full stack backtrace starting from the first caller outside of __PACKAGE__. (Unless that package was also internal to Perl.)</source>
          <target state="translated">会给出一个完整的栈回溯,从__PACKAGE__之外的第一个调用者开始。(除非那个包也是 Perl 内部的。)</target>
        </trans-unit>
        <trans-unit id="ad5c29604d0563177f85184d5b38f87b92f96450" translate="yes" xml:space="preserve">
          <source>would indicate that the module's loadable object has an extension of &lt;code&gt;unusual_ext&lt;/code&gt; instead of the more usual &lt;code&gt;$Config{dlext}&lt;/code&gt; . NOTE: This also requires that the module's</source>
          <target state="translated">表示模块的可加载对象的扩展名是 &lt;code&gt;unusual_ext&lt;/code&gt; 而不是更常见的 &lt;code&gt;$Config{dlext}&lt;/code&gt; 。注意：这还要求模块的</target>
        </trans-unit>
        <trans-unit id="585e126f2d7d5e783ec33329e484ff25c16ca6ba" translate="yes" xml:space="preserve">
          <source>would look like this:</source>
          <target state="translated">会是这样的。</target>
        </trans-unit>
        <trans-unit id="fb35630d9819ace128f90170b4e7e21fb8a844e0" translate="yes" xml:space="preserve">
          <source>would make the output file be &lt;code&gt;&lt;a href=&quot;../functions/index&quot;&gt;index.html&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../functions/index&quot;&gt;index.html?x=y&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">会使输出文件为 &lt;code&gt;&lt;a href=&quot;../functions/index&quot;&gt;index.html&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;../functions/index&quot;&gt;index.html?x=y&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f64975e657327e4be32b5539242811882551af4" translate="yes" xml:space="preserve">
          <source>would match the same as &lt;code&gt;/(Y) ( (X) \g3 \g1 )/x&lt;/code&gt; . This allows you to interpolate regexes into larger regexes and not have to worry about the capture groups being renumbered.</source>
          <target state="translated">将与 &lt;code&gt;/(Y) ( (X) \g3 \g1 )/x&lt;/code&gt; 匹配。这使您可以将正则表达式插入较大的正则表达式中，而不必担心捕获组被重新编号。</target>
        </trans-unit>
        <trans-unit id="c2f054955a6bf9756cf704fa72217ac295bd0e6a" translate="yes" xml:space="preserve">
          <source>would not distinguish whether an argument to a C function which is of the form, say, &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; , is an input, output, or input/output parameter. In particular, argument declarations of the form</source>
          <target state="translated">不会区分形式为 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; 的C函数参数是输入，输出还是输入/输出参数。特别是形式的参数声明</target>
        </trans-unit>
        <trans-unit id="d43dd196be51f739a2f740fe5b9d6d8d4e1e385a" translate="yes" xml:space="preserve">
          <source>would not have worked, since a pattern match in scalar context will only return true or false, rather than a count of matches.</source>
          <target state="translated">不会成功,因为在标量上下文中的模式匹配只会返回true或false,而不是匹配次数。</target>
        </trans-unit>
        <trans-unit id="673f3639cd000b9c54db8198e731d97836c69096" translate="yes" xml:space="preserve">
          <source>would parse as equivalent to this:</source>
          <target state="translated">将会被解析为等同于这个。</target>
        </trans-unit>
        <trans-unit id="9212fded8d922f55d00c869b65a88f38d24b2983" translate="yes" xml:space="preserve">
          <source>would print out:</source>
          <target state="translated">会打印出来。</target>
        </trans-unit>
        <trans-unit id="6c9640bfb221618fc100b05da2396d3c0c4bbe0f" translate="yes" xml:space="preserve">
          <source>would result in the executable file</source>
          <target state="translated">将导致可执行文件</target>
        </trans-unit>
        <trans-unit id="1ad2605d7b28e739c8b99351ef9b3563d4182742" translate="yes" xml:space="preserve">
          <source>would result in the library file</source>
          <target state="translated">将导致库文件</target>
        </trans-unit>
        <trans-unit id="b1f85381415339898b4e35b7420b2a30ff7e6961" translate="yes" xml:space="preserve">
          <source>would result in the object file</source>
          <target state="translated">将导致对象文件</target>
        </trans-unit>
        <trans-unit id="1f7d3dbcc73cffec6f45fb591952a386e20faa47" translate="yes" xml:space="preserve">
          <source>would return the same result, since all sets of both types of specified delimiter brackets are correctly nested and balanced.</source>
          <target state="translated">将返回相同的结果,因为所有指定的两种类型的定界符括号的集合都正确地嵌套和平衡。</target>
        </trans-unit>
        <trans-unit id="2c4cff5293b552fd612d13d20febeef5d79d3555" translate="yes" xml:space="preserve">
          <source>would return:</source>
          <target state="translated">会回来的。</target>
        </trans-unit>
        <trans-unit id="549c70e9abc983bc89d50811971c8d7b3d089c20" translate="yes" xml:space="preserve">
          <source>would run</source>
          <target state="translated">会跑</target>
        </trans-unit>
        <trans-unit id="f0812d8966a2250845dc2d619797b74c9d0e4dab" translate="yes" xml:space="preserve">
          <source>would use &lt;code&gt;$a&lt;/code&gt; for the width and precision, and &lt;code&gt;$b&lt;/code&gt; as the value to format.</source>
          <target state="translated">将使用 &lt;code&gt;$a&lt;/code&gt; 表示宽度和精度，并使用 &lt;code&gt;$b&lt;/code&gt; 作为要格式化的值。</target>
        </trans-unit>
        <trans-unit id="5c4ae51d8b1c837faa9e910a2f351d7de1dfa952" translate="yes" xml:space="preserve">
          <source>wouldn't know where the two parameters we pushed were--remember that up to now all the stack pointer manipulation we have done is with our local copy,</source>
          <target state="translated">不会知道我们推送的两个参数在哪里--请记住,到目前为止,我们所做的所有堆栈指针操作都是在我们的本地副本中进行的。</target>
        </trans-unit>
        <trans-unit id="275a8dd6709a5e2c891d71deaa74a09a2b8d5d39" translate="yes" xml:space="preserve">
          <source>wrap_code_ref (CODEREF)</source>
          <target state="translated">wrap_code_ref (CODEREF)</target>
        </trans-unit>
        <trans-unit id="ffbf27fe46bcaa79a98677fcde1803710c322360" translate="yes" xml:space="preserve">
          <source>wrap_code_refs_within (...)</source>
          <target state="translated">wrap_code_refs_within (...)</target>
        </trans-unit>
        <trans-unit id="21b372156d56807f806631ed6933c5523d17885c" translate="yes" xml:space="preserve">
          <source>wraplist</source>
          <target state="translated">wraplist</target>
        </trans-unit>
        <trans-unit id="a519839bb77029f84f6e3675490ad147a55b8b60" translate="yes" xml:space="preserve">
          <source>wrapped wraplen</source>
          <target state="translated">裹尸布</target>
        </trans-unit>
        <trans-unit id="e1d0c6c1c29e6ad5164072a5b21340dca7fcb052" translate="yes" xml:space="preserve">
          <source>write</source>
          <target state="translated">write</target>
        </trans-unit>
        <trans-unit id="dd01faf5c1113bb980804714f1a3c4f4eca294e2" translate="yes" xml:space="preserve">
          <source>write EXPR</source>
          <target state="translated">写EXPR</target>
        </trans-unit>
        <trans-unit id="45c37b30717044052f1540db05b5ad1c8bba5bf9" translate="yes" xml:space="preserve">
          <source>write FILEHANDLE</source>
          <target state="translated">写FILEHANDLE</target>
        </trans-unit>
        <trans-unit id="dc499117dc83408f0c557cc8b2161889aed51087" translate="yes" xml:space="preserve">
          <source>write code faster</source>
          <target state="translated">加快编写代码</target>
        </trans-unit>
        <trans-unit id="a9a1d28af222c28b77e752b332e8cb55ca3c14d7" translate="yes" xml:space="preserve">
          <source>write faster code</source>
          <target state="translated">快刀斩乱麻</target>
        </trans-unit>
        <trans-unit id="6d71d56a74dcab217f5cf3d91986820cbce58120" translate="yes" xml:space="preserve">
          <source>write.exe</source>
          <target state="translated">write.exe</target>
        </trans-unit>
        <trans-unit id="047dd1341a6717dbc4836719e3c574b3bc97bb54" translate="yes" xml:space="preserve">
          <source>write_mymeta</source>
          <target state="translated">write_mymeta</target>
        </trans-unit>
        <trans-unit id="1935d7b6e1cdaa0cb2a12b33ef6db0f1f938bf83" translate="yes" xml:space="preserve">
          <source>writing</source>
          <target state="translated">writing</target>
        </trans-unit>
        <trans-unit id="a4b48a81cdab1e1a5dd37907d6c85ca1c61ddc7c" translate="yes" xml:space="preserve">
          <source>wrong</source>
          <target state="translated">wrong</target>
        </trans-unit>
        <trans-unit id="11f6ad8ec52a2984abaafd7c3b516503785c2072" translate="yes" xml:space="preserve">
          <source>x</source>
          <target state="translated">x</target>
        </trans-unit>
        <trans-unit id="93dff1d783f239eb6df3ffae594ded880d8c2dfb" translate="yes" xml:space="preserve">
          <source>x/../y</source>
          <target state="translated">x/../y</target>
        </trans-unit>
        <trans-unit id="3482696e3765ecb95ff0b00a865fd23521383490" translate="yes" xml:space="preserve">
          <source>xhtml-symbol.ent</source>
          <target state="translated">xhtml-symbol.ent</target>
        </trans-unit>
        <trans-unit id="f1922a234bb92764a276a8524d28cdb446d3c7da" translate="yes" xml:space="preserve">
          <source>xor</source>
          <target state="translated">xor</target>
        </trans-unit>
        <trans-unit id="bd656af3459b27df22cf48bccc070225063ef3e2" translate="yes" xml:space="preserve">
          <source>xs_init</source>
          <target state="translated">xs_init</target>
        </trans-unit>
        <trans-unit id="9be87fada2e3b55bddb69633715a8cbf8d48722a" translate="yes" xml:space="preserve">
          <source>xsinit(), ldopts(), ccopts(), perl_inc(), ccflags(), ccdlflags(), xsi_header(), xsi_protos(), xsi_body()</source>
          <target state="translated">xsinit(),ldopts(),ccopts(),perl_inc(),ccflags(),ccdlflags(),xsi_header(),xsi_protos(),xsi_body()</target>
        </trans-unit>
        <trans-unit id="1fff56fa3f2f5449b8620c18875a8982395117c3" translate="yes" xml:space="preserve">
          <source>xsinit.c</source>
          <target state="translated">xsinit.c</target>
        </trans-unit>
        <trans-unit id="8caed3fb038593e7e6d1f13475278cfc4b1647e5" translate="yes" xml:space="preserve">
          <source>xsubpp</source>
          <target state="translated">xsubpp</target>
        </trans-unit>
        <trans-unit id="15440904d1068b6f9c7bcddb1d5eab1ae01d515d" translate="yes" xml:space="preserve">
          <source>xsubpp - compiler to convert Perl XS code into C code</source>
          <target state="translated">xsubpp-将Perl XS代码转换为C代码的编译器。</target>
        </trans-unit>
        <trans-unit id="41906962c9fe690a96247971b9ba3de3ba3eef8c" translate="yes" xml:space="preserve">
          <source>xsubpp supports a special syntax for returning packed C arrays to perl. If the XS return type is given as</source>
          <target state="translated">xsubpp支持一种特殊的语法来返回打包的C数组到perl。如果XS返回类型为</target>
        </trans-unit>
        <trans-unit id="7714417f80a650aa8bcd07aa2560cd2d5b40da3b" translate="yes" xml:space="preserve">
          <source>xsubpp variables and internal functions</source>
          <target state="translated">xsubpp变量和内部函数</target>
        </trans-unit>
        <trans-unit id="7313a6242468b7d1e99857893c09fca6dc3ad1eb" translate="yes" xml:space="preserve">
          <source>xsubpp will copy the contents of &lt;code&gt;nelem * sizeof(type)&lt;/code&gt; bytes from RETVAL to an SV and push it onto the stack. This is only really useful if the number of items to be returned is known at compile time and you don't mind having a string of bytes in your SV. Use T_ARRAY to push a variable number of arguments onto the return stack (they won't be packed as a single string though).</source>
          <target state="translated">xsubpp会将 &lt;code&gt;nelem * sizeof(type)&lt;/code&gt; 字节的内容从RETVAL 复制到SV，并将其压入堆栈。仅当在编译时知道要返回的项目数并且您不介意在SV中包含字节字符串时，这才真正有用。使用T_ARRAY将可变数量的参数压入返回堆栈（尽管它们不会打包为单个字符串）。</target>
        </trans-unit>
        <trans-unit id="5f8459982f9f619f4b0d9af2542a2086e56a4bef" translate="yes" xml:space="preserve">
          <source>xy</source>
          <target state="translated">xy</target>
        </trans-unit>
        <trans-unit id="95cb0bfd2977c761298d9624e4b4d4c72a39974a" translate="yes" xml:space="preserve">
          <source>y</source>
          <target state="translated">y</target>
        </trans-unit>
        <trans-unit id="d2f77ac0db8f1535051c3dc4f93ef1b8f6478c1d" translate="yes" xml:space="preserve">
          <source>y///</source>
          <target state="translated">y///</target>
        </trans-unit>
        <trans-unit id="f5619be32b1efe2b008dbb33c1045b38215c4948" translate="yes" xml:space="preserve">
          <source>yacc</source>
          <target state="translated">yacc</target>
        </trans-unit>
        <trans-unit id="d12d9f2a97a58598b867d00b4faff8074cd34270" translate="yes" xml:space="preserve">
          <source>yacc.U</source>
          <target state="translated">yacc.U</target>
        </trans-unit>
        <trans-unit id="9251acc6192fd21eb64ccb0b45a380892e1c36b3" translate="yes" xml:space="preserve">
          <source>yaml_backend</source>
          <target state="translated">yaml_backend</target>
        </trans-unit>
        <trans-unit id="b636d2c48aad51e77144c248b661fb67f7fc03c6" translate="yes" xml:space="preserve">
          <source>yield the same result but</source>
          <target state="translated">殊途同归</target>
        </trans-unit>
        <trans-unit id="271d1c708984e0c55c15fabaa11bd2d3b1458de9" translate="yes" xml:space="preserve">
          <source>yield:</source>
          <target state="translated">yield:</target>
        </trans-unit>
        <trans-unit id="b4f99a7dbe9a425fcc68c36757fe48467fa8d7b7" translate="yes" xml:space="preserve">
          <source>yielding the number of seconds that elapsed between January 1, 1970 (the beginning of the Unix epoch), and the moment I began writing this sentence.</source>
          <target state="translated">得出从1970年1月1日(Unix纪元的开始)到我开始写这句话的那一刻所经过的秒数。</target>
        </trans-unit>
        <trans-unit id="edb0f5b1f639a3886e3180c47fe86c3a6a263842" translate="yes" xml:space="preserve">
          <source>yields</source>
          <target state="translated">yields</target>
        </trans-unit>
        <trans-unit id="341f78d1b5a5471d159f158c1f163fc170e38478" translate="yes" xml:space="preserve">
          <source>yields:</source>
          <target state="translated">yields:</target>
        </trans-unit>
        <trans-unit id="5056f4f5d35641712437421dd222826fdd613905" translate="yes" xml:space="preserve">
          <source>you can assume that the input &quot;ac&quot; will output &quot;ac&quot;, and that &quot;abc&quot; will output only &quot;c&quot;.</source>
          <target state="translated">你可以假设输入 &quot;ac &quot;会输出 &quot;ac&quot;,而 &quot;abc &quot;只会输出 &quot;c&quot;。</target>
        </trans-unit>
        <trans-unit id="a951aa1692118fb65f6cadcde16979f8bb55362a" translate="yes" xml:space="preserve">
          <source>you can expect one of these messages (which you actually get is dependent on the version of Perl you are using)</source>
          <target state="translated">你可以期待这些信息之一(实际得到的信息取决于你所使用的Perl版本</target>
        </trans-unit>
        <trans-unit id="761c473c3fb3b7c8d7e8e15ee579ff0b662dcc3c" translate="yes" xml:space="preserve">
          <source>you can force interpretation as a reserved word by adding anything that makes it more than a bareword:</source>
          <target state="translated">你可以通过添加任何使其超过裸词的东西来强制解释为保留词。</target>
        </trans-unit>
        <trans-unit id="279056ca82a6811880a0d9a6128de1be6e230a2e" translate="yes" xml:space="preserve">
          <source>you can guarantee that the locale will be ISO8859-1. Use POSIX character classes instead.</source>
          <target state="translated">你可以保证locale将是ISO8859-1。使用POSIX字符类代替。</target>
        </trans-unit>
        <trans-unit id="5e460c422109538339eeeb6480684b4f306f3de3" translate="yes" xml:space="preserve">
          <source>you can make them all to use the same XSUB using this:</source>
          <target state="translated">你可以用这个方法让他们都使用同一个XSUB。</target>
        </trans-unit>
        <trans-unit id="5afb3eb8089babca339a0a5ab5ffd74baff0bfbd" translate="yes" xml:space="preserve">
          <source>you can press &lt;code&gt;Ctrl-Insert&lt;/code&gt; now, and cut-and-paste from the resulting file - created in the directory you started</source>
          <target state="translated">您可以立即按 &lt;code&gt;Ctrl-Insert&lt;/code&gt; ，然后从生成的文件中剪切并粘贴-在您启动的目录中创建</target>
        </trans-unit>
        <trans-unit id="6b6d4e3eef8985d17155740fc1fb9090692c91b7" translate="yes" xml:space="preserve">
          <source>you can roll it all into one line:</source>
          <target state="translated">你可以把它全部卷成一条线。</target>
        </trans-unit>
        <trans-unit id="228c9492d3cafe3be9e270db9be067f6669b75db" translate="yes" xml:space="preserve">
          <source>you can simply write:</source>
          <target state="translated">你可以简单地写。</target>
        </trans-unit>
        <trans-unit id="73c2c64bf57a41908c42c9a1cc5c7680a481d9b9" translate="yes" xml:space="preserve">
          <source>you can unambiguously represent data. Here is what we mean by &quot;unambiguously&quot;. After &lt;code&gt;$utf8 = decode(&quot;foo&quot;, $octet)&lt;/code&gt; ,</source>
          <target state="translated">您可以清楚地表示数据。这就是我们&amp;ldquo;明确&amp;rdquo;的意思。在 &lt;code&gt;$utf8 = decode(&quot;foo&quot;, $octet)&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="a0769ff9fc11160998b5a34787676ea117e16054" translate="yes" xml:space="preserve">
          <source>you can use the &lt;code&gt;EVERY::LAST&lt;/code&gt; pseudo-class:</source>
          <target state="translated">您可以使用 &lt;code&gt;EVERY::LAST&lt;/code&gt; 伪类：</target>
        </trans-unit>
        <trans-unit id="5c36535a9c2aa5358bd3fa1a809a56719daa66a5" translate="yes" xml:space="preserve">
          <source>you can write</source>
          <target state="translated">你可以写</target>
        </trans-unit>
        <trans-unit id="1510a5ad8c738b5c46b5a17800ed9f6671e57b9a" translate="yes" xml:space="preserve">
          <source>you can write just</source>
          <target state="translated">你可以随便写</target>
        </trans-unit>
        <trans-unit id="1d905b4762422cd8888fe106e63e876390030933" translate="yes" xml:space="preserve">
          <source>you could do it like so:</source>
          <target state="translated">你可以这样做。</target>
        </trans-unit>
        <trans-unit id="32cbafc88f9919f00875fa01fc871ad53657d16c" translate="yes" xml:space="preserve">
          <source>you could retry with</source>
          <target state="translated">你可以重试用</target>
        </trans-unit>
        <trans-unit id="f31af4d40aa4d113abb8700320d0dec76296cdee" translate="yes" xml:space="preserve">
          <source>you could set DESTDIR=~/tmp/ and installation would go into</source>
          <target state="translated">你可以设置DESTDIR=~/tmp/,然后安装会进入到</target>
        </trans-unit>
        <trans-unit id="97a047f9ba32f1e569d7e98e12e7892d5f52a397" translate="yes" xml:space="preserve">
          <source>you declare any of your own fields.</source>
          <target state="translated">你声明任何你自己的领域。</target>
        </trans-unit>
        <trans-unit id="3069e6795247a4cf630775dcb371de41a404867d" translate="yes" xml:space="preserve">
          <source>you didn't read the above and tried to use tar instead of pax, you'll first have to remove the (now corrupt) perl directory</source>
          <target state="translated">如果你没有读到上面的内容,并试图使用 tar 而不是 pax,你将首先必须删除(现在已经损坏的)perl 目录。</target>
        </trans-unit>
        <trans-unit id="75cceb83b150b42b6f5f66b5da740fdbd16273b6" translate="yes" xml:space="preserve">
          <source>you load the module.</source>
          <target state="translated">您加载模块。</target>
        </trans-unit>
        <trans-unit id="a4411228d0f2dd0ed520803b8f3074cfee30a2f8" translate="yes" xml:space="preserve">
          <source>you make certain that all locales will always and only be either an ISO8859-1, or, if you don't have a deficient C library, a UTF-8 locale.</source>
          <target state="translated">你要确定所有的locale将永远且只能是ISO8859-1,或者,如果你没有缺陷的C库,则是UTF-8 locale。</target>
        </trans-unit>
        <trans-unit id="30a3a6e75011da9030503c667c7b05d715ebcfe8" translate="yes" xml:space="preserve">
          <source>you may THINK you wrote the same thing as</source>
          <target state="translated">你可能认为你写的东西和</target>
        </trans-unit>
        <trans-unit id="01380cc536db3e96b59620f22f2fbfa4c077a9a7" translate="yes" xml:space="preserve">
          <source>you may need to reinstall the ActivePerl.</source>
          <target state="translated">你可能需要重新安装ActivePerl。</target>
        </trans-unit>
        <trans-unit id="d19c7e9e52eed6d3f22ce761e226a5c29f3ad43e" translate="yes" xml:space="preserve">
          <source>you may tell the compiler to use integer operations (see &lt;a href=&quot;integer&quot;&gt;integer&lt;/a&gt; for a detailed explanation) from here to the end of the enclosing BLOCK. An inner BLOCK may countermand this by saying</source>
          <target state="translated">您可能会告诉编译器从此处到封闭的BLOCK末尾使用整数运算（有关详细说明，请参见&lt;a href=&quot;integer&quot;&gt;整数&lt;/a&gt;）。内在的BLOCK可能会这样说：</target>
        </trans-unit>
        <trans-unit id="6a31b287da5d839e2dc623eaffd98dff0ccb062a" translate="yes" xml:space="preserve">
          <source>you need to either recompile your Perl in Tru64 4.0D or upgrade your Tru64 4.0D to at least 4.0F: the sockatmark() system call was added in Tru64 4.0F, and the IO extension refers that symbol.</source>
          <target state="translated">你需要在 Tru64 4.0D 中重新编译你的 Perl,或者将你的 Tru64 4.0D 至少升级到 4.0F:sockatmark()系统调用是在 Tru64 4.0F 中添加的,IO 扩展引用了这个符号。</target>
        </trans-unit>
        <trans-unit id="1722764b528ff2473944177b83c3cd9a8e51bc17" translate="yes" xml:space="preserve">
          <source>you provide.) In the</source>
          <target state="translated">您提供的。)在</target>
        </trans-unit>
        <trans-unit id="5c0579f9be815c7ee48d8d23d3d66d5cb6cfc45a" translate="yes" xml:space="preserve">
          <source>you use to build Perl, adding the extension's name to the &lt;code&gt;ext&lt;/code&gt; macro, and the extension's object file to the &lt;code&gt;extobj&lt;/code&gt; macro. You'll also need to build the extension's object file, either by adding dependencies to the main</source>
          <target state="translated">您用于构建Perl，将扩展名添加到 &lt;code&gt;ext&lt;/code&gt; 宏中，并将扩展的目标文件添加到 &lt;code&gt;extobj&lt;/code&gt; 宏中。您还需要通过将依赖项添加到主目录来构建扩展程序的目标文件。</target>
        </trans-unit>
        <trans-unit id="a387eb2e97a3c9d50bfe300a1159fb7c3637c367" translate="yes" xml:space="preserve">
          <source>you want the pattern to use the initial values of the variables regardless of whether they change or not. (But there are saner ways of accomplishing this than using &lt;code&gt;/o&lt;/code&gt;.)</source>
          <target state="translated">您希望模式使用变量的初始值，而不管变量是否更改。（但是有比使用 &lt;code&gt;/o&lt;/code&gt; 更明智的方法来实现此目的。）</target>
        </trans-unit>
        <trans-unit id="6d89d3b483dbdfd382255886b6f76f6f9ed539d8" translate="yes" xml:space="preserve">
          <source>you will find the shell more convenient than the bare shell before.</source>
          <target state="translated">你会发现外壳比之前的裸壳更方便。</target>
        </trans-unit>
        <trans-unit id="c6d52094053e2271b8e6b8811f157b555c3d0bed" translate="yes" xml:space="preserve">
          <source>you will have to write the explicit full form</source>
          <target state="translated">你将不得不写出明确的完整形式</target>
        </trans-unit>
        <trans-unit id="ae9b86dc8d723ffd5fd2d5e039182429061deb40" translate="yes" xml:space="preserve">
          <source>you will have:</source>
          <target state="translated">你会有。</target>
        </trans-unit>
        <trans-unit id="de50066896083dd63404bb3575f5f66f75090162" translate="yes" xml:space="preserve">
          <source>you will see the slightly more helpful</source>
          <target state="translated">你会看到稍有帮助的</target>
        </trans-unit>
        <trans-unit id="0667d305a0b0067742e1926b7aa78a3f1f8f9b8a" translate="yes" xml:space="preserve">
          <source>you would write:</source>
          <target state="translated">你会写。</target>
        </trans-unit>
        <trans-unit id="b78865bd8c1873f7d311dc1d94a79c917244ed27" translate="yes" xml:space="preserve">
          <source>you'll get &lt;code&gt;mytime() + 2&lt;/code&gt; , not &lt;code&gt;mytime(2)&lt;/code&gt; , which is how it would be parsed without a prototype. If you want to force a unary function to have the same precedence as a list operator, add &lt;code&gt;;&lt;/code&gt; to the end of the prototype:</source>
          <target state="translated">您将得到 &lt;code&gt;mytime() + 2&lt;/code&gt; ，而不是 &lt;code&gt;mytime(2)&lt;/code&gt; ，这是没有原型时如何对其进行解析的方法。如果要强制一元函数具有与列表运算符相同的优先级，请添加 &lt;code&gt;;&lt;/code&gt; 到原型的末尾：</target>
        </trans-unit>
        <trans-unit id="7e6a0e9c6d7617f1874cbd34d69a61bb043ae4b0" translate="yes" xml:space="preserve">
          <source>your class is, rather than having to tell Perl</source>
          <target state="translated">你的类是什么,而不是必须告诉Perl</target>
        </trans-unit>
        <trans-unit id="92646319ab3ad914c108ec6e67cecb3d15d2b874" translate="yes" xml:space="preserve">
          <source>your regexp. So by default, using both interpolation and code expressions in the same regexp is not allowed. If you're not concerned about malicious users, it is possible to bypass this security check by invoking &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; :</source>
          <target state="translated">您的正则表达式。因此，默认情况下，不允许在同一正则表达式中同时使用插值和代码表达式。如果您不关心恶意用户，则可以通过调用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; 来绕过此安全检查：</target>
        </trans-unit>
        <trans-unit id="7d71de9ec3c1742da5275ab3e4ce303c6d416f57" translate="yes" xml:space="preserve">
          <source>your table now reads:</source>
          <target state="translated">你的表格现在是:</target>
        </trans-unit>
        <trans-unit id="edec9917c4429bd24f7af5accd2ac28ce6871922" translate="yes" xml:space="preserve">
          <source>your-handler</source>
          <target state="translated">your-handler</target>
        </trans-unit>
        <trans-unit id="20770554c8961543d282b97286ecde3fed631f64" translate="yes" xml:space="preserve">
          <source>yourself</source>
          <target state="translated">yourself</target>
        </trans-unit>
        <trans-unit id="17ddec5322f6ed39ba7950d6ba2bd67e67db5b6a" translate="yes" xml:space="preserve">
          <source>yourself.</source>
          <target state="translated">yourself.</target>
        </trans-unit>
        <trans-unit id="395df8f7c51f007019cb30201c49e884b46b92fa" translate="yes" xml:space="preserve">
          <source>z</source>
          <target state="translated">z</target>
        </trans-unit>
        <trans-unit id="aa8c41330509455ee5679d04ed41535d280d9a89" translate="yes" xml:space="preserve">
          <source>zero</source>
          <target state="translated">zero</target>
        </trans-unit>
        <trans-unit id="5211a4a12dbc3325a3db2a2cce5d6220da5eb9c2" translate="yes" xml:space="preserve">
          <source>zero is at the North Pole, not at the Equator on the west coast of Africa (Bay of Guinea). You need to subtract your geographical coordinates from</source>
          <target state="translated">零点在北极,而不是在非洲西海岸(几内亚湾)的赤道。你需要把你的地理坐标从以下位置减去</target>
        </trans-unit>
        <trans-unit id="d2234786d04df9bc1bb3c3da3df83549bbae76b7" translate="yes" xml:space="preserve">
          <source>zero-width assertions</source>
          <target state="translated">零宽度断言</target>
        </trans-unit>
        <trans-unit id="9f375b5e2bd318e7607d853092dbfbe693321844" translate="yes" xml:space="preserve">
          <source>zip $input_filename_or_reference =&amp;gt; $output_filename_or_reference [, OPTS]</source>
          <target state="translated">zip $ input_filename_or_reference =&amp;gt; $ output_filename_or_reference [，OPTS]</target>
        </trans-unit>
        <trans-unit id="57968f12798767ae5da8b15a0c383ad79d0f338b" translate="yes" xml:space="preserve">
          <source>zlib</source>
          <target state="translated">zlib</target>
        </trans-unit>
        <trans-unit id="0bada2d421ea3b0a4ee659093f79079ed4b9623f" translate="yes" xml:space="preserve">
          <source>{atan2, cos, exp, floor, fmod, frexp, isnan, log, modf, pow, sin, sqrt}l, strtold</source>
          <target state="translated">{atan2，cos，exp，floor，fmod，frexp，isnan，log，modf，pow，sin，sqrt} l，strtold</target>
        </trans-unit>
        <trans-unit id="f8afa9f0630cc708f3254bd632424571d7937a2d" translate="yes" xml:space="preserve">
          <source>| &lt;b&gt;-C&lt;/b&gt; ] [ &lt;b&gt;-S&lt;/b&gt; ] [ &lt;b&gt;-t&lt;/b&gt; ] [ &lt;b&gt;-d&lt;/b&gt; ] [ &lt;b&gt;-A&lt;/b&gt; ] [ &lt;b&gt;-h&lt;/b&gt; ] [ &lt;b&gt;-T&lt;/b&gt; ]</source>
          <target state="translated">| &lt;b&gt;-C&lt;/b&gt; ] [ &lt;b&gt;-S&lt;/b&gt; ] [ &lt;b&gt;-t&lt;/b&gt; ] [ &lt;b&gt;-d&lt;/b&gt; ] [ &lt;b&gt;-A&lt;/b&gt; ] [ &lt;b&gt;-h&lt;/b&gt; ] [ &lt;b&gt;-T&lt;/b&gt; ]</target>
        </trans-unit>
        <trans-unit id="94864efe9c101c7cfe388d5b720d16e84936f991" translate="yes" xml:space="preserve">
          <source>| &lt;b&gt;-f&lt;/b&gt;</source>
          <target state="translated">| &lt;b&gt;-F&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7a314cca084c8d6e6c8f5328b453da7f8a87abf9" translate="yes" xml:space="preserve">
          <source>} =</source>
          <target state="translated">} =</target>
        </trans-unit>
        <trans-unit id="fb3c6e4de85bd9eae26fdc63e75f10a7f39e850e" translate="yes" xml:space="preserve">
          <source>~</source>
          <target state="translated">~</target>
        </trans-unit>
        <trans-unit id="3546d92b553cbec03ec46dfae3482c4878748b52" translate="yes" xml:space="preserve">
          <source>~/.netscape/history.db</source>
          <target state="translated">~/.netscape/history.db</target>
        </trans-unit>
        <trans-unit id="10147e78c8415aa0b473fbb8dbea5a8966778c0c" translate="yes" xml:space="preserve">
          <source>~/.perldb</source>
          <target state="translated">~/.perldb</target>
        </trans-unit>
        <trans-unit id="2d2cbdb9094f5f4954c6330da66315ee120c6274" translate="yes" xml:space="preserve">
          <source>~/.proverc</source>
          <target state="translated">~/.proverc</target>
        </trans-unit>
        <trans-unit id="ac3bc4988958b749f7dd1bd7030e495f8d6af1a4" translate="yes" xml:space="preserve">
          <source>~/bin</source>
          <target state="translated">~/bin</target>
        </trans-unit>
        <trans-unit id="402b4ddfdf31bfc73a7ea7ed2fb0f95b5a09a270" translate="yes" xml:space="preserve">
          <source>~/lib/perl5</source>
          <target state="translated">~/lib/perl5</target>
        </trans-unit>
        <trans-unit id="db83d96aced0e2c019a65ecc608c84bc6c391ed3" translate="yes" xml:space="preserve">
          <source>~/man</source>
          <target state="translated">~/man</target>
        </trans-unit>
        <trans-unit id="bbf98088c0d37c38d37fa49f16a667216d44ef13" translate="yes" xml:space="preserve">
          <source>~/tmp</source>
          <target state="translated">~/tmp</target>
        </trans-unit>
        <trans-unit id="03f8609dad484cb98c24755bd4acb64e2459cdb6" translate="yes" xml:space="preserve">
          <source>~/tmp/</source>
          <target state="translated">~/tmp/</target>
        </trans-unit>
        <trans-unit id="5a812c8dbd85a0c3fe37d9f84374737a4801d2bc" translate="yes" xml:space="preserve">
          <source>~/tmp/lib/perl5</source>
          <target state="translated">~/tmp/lib/perl5</target>
        </trans-unit>
        <trans-unit id="45cb8fa08bbb384bb68753d12c4d9b9b524fcc41" translate="yes" xml:space="preserve">
          <source>~/tmp/usr/local/lib/perl</source>
          <target state="translated">~/tmp/usr/local/lib/perl</target>
        </trans-unit>
        <trans-unit id="14df47b7b7486d3776ef10c4c880ca067065a0b7" translate="yes" xml:space="preserve">
          <source>~name</source>
          <target state="translated">~name</target>
        </trans-unit>
        <trans-unit id="b5b55a0e439c0317089da34fd3674db902e0188e" translate="yes" xml:space="preserve">
          <source>ἀ-</source>
          <target state="translated">ἀ-</target>
        </trans-unit>
        <trans-unit id="50400a9a3ca82dc97c2a62a8cb1fd9c90797027b" translate="yes" xml:space="preserve">
          <source>℞ 0: Standard preamble</source>
          <target state="translated">℞0：标准序言</target>
        </trans-unit>
        <trans-unit id="c2a5f8ffdee8b1fc6db174346c9351f7a691c79d" translate="yes" xml:space="preserve">
          <source>℞ 10: Custom named characters</source>
          <target state="translated">℞10：自定义命名字符</target>
        </trans-unit>
        <trans-unit id="d99e547ff698f044bb6f9ec55492f016195b8b76" translate="yes" xml:space="preserve">
          <source>℞ 11: Names of CJK codepoints</source>
          <target state="translated">℞11：CJK代码点的名称</target>
        </trans-unit>
        <trans-unit id="3ef3e77c58b7d3c354fb4a79adbe9a3824db9a8f" translate="yes" xml:space="preserve">
          <source>℞ 12: Explicit encode/decode</source>
          <target state="translated">℞12：显式编码/解码</target>
        </trans-unit>
        <trans-unit id="5b67beb4bfc4b3e25c970a54c813cc2a0e285a8b" translate="yes" xml:space="preserve">
          <source>℞ 13: Decode program arguments as utf8</source>
          <target state="translated">℞13：将程序参数解码为utf8</target>
        </trans-unit>
        <trans-unit id="e6b8e850a711b941c3b488e2ed88459f7223a720" translate="yes" xml:space="preserve">
          <source>℞ 14: Decode program arguments as locale encoding</source>
          <target state="translated">℞14：将程序参数解码为语言环境编码</target>
        </trans-unit>
        <trans-unit id="1887bd908402fa513516cc0ea0a1a3025b915578" translate="yes" xml:space="preserve">
          <source>℞ 15: Declare STD{IN,OUT,ERR} to be utf8</source>
          <target state="translated">℞15：声明STD {IN，OUT，ERR}为utf8</target>
        </trans-unit>
        <trans-unit id="e2ebb62517d037f392732882c882d1ba5fc9ecc2" translate="yes" xml:space="preserve">
          <source>℞ 16: Declare STD{IN,OUT,ERR} to be in locale encoding</source>
          <target state="translated">℞16：声明STD {IN，OUT，ERR}为区域设置编码</target>
        </trans-unit>
        <trans-unit id="ebb3cf37c9c1d0a5bb342f588f5b09dbb35be67a" translate="yes" xml:space="preserve">
          <source>℞ 17: Make file I/O default to utf8</source>
          <target state="translated">℞17：将文件I / O缺省为utf8</target>
        </trans-unit>
        <trans-unit id="2270d23ccbd9ab2a598ab2468255ab751d4c25c2" translate="yes" xml:space="preserve">
          <source>℞ 18: Make all I/O and args default to utf8</source>
          <target state="translated">℞18：将所有I / O和args缺省设置为utf8</target>
        </trans-unit>
        <trans-unit id="8babe67379748497306ce72a6dad66fc99fc1e81" translate="yes" xml:space="preserve">
          <source>℞ 19: Open file with specific encoding</source>
          <target state="translated">℞19：使用特定编码打开文件</target>
        </trans-unit>
        <trans-unit id="7b034eaf8616461baa8e3d15f4ad99a4b7d97e42" translate="yes" xml:space="preserve">
          <source>℞ 1: Generic Unicode-savvy filter</source>
          <target state="translated">℞1：通用Unicode过滤器</target>
        </trans-unit>
        <trans-unit id="b729d9a4ed3a62e05db384dc3e1d5044801f8d4e" translate="yes" xml:space="preserve">
          <source>℞ 20: Unicode casing</source>
          <target state="translated">℞20：Unicode大小写</target>
        </trans-unit>
        <trans-unit id="f3b7526897174f1d984b158eeaedadfd87945792" translate="yes" xml:space="preserve">
          <source>℞ 21: Unicode case-insensitive comparisons</source>
          <target state="translated">℞21：Unicode不区分大小写的比较</target>
        </trans-unit>
        <trans-unit id="f1cf2c7882da8c0f9ff3908b5f16003eae636f3e" translate="yes" xml:space="preserve">
          <source>℞ 22: Match Unicode linebreak sequence in regex</source>
          <target state="translated">℞22：在正则表达式中匹配Unicode换行符序列</target>
        </trans-unit>
        <trans-unit id="e4cf00c9ea31f803c1577db0d44ba0e0609610ed" translate="yes" xml:space="preserve">
          <source>℞ 23: Get character category</source>
          <target state="translated">℞23：获取角色类别</target>
        </trans-unit>
        <trans-unit id="7ef354f30d35eb886f206035ce256589f9655f23" translate="yes" xml:space="preserve">
          <source>℞ 24: Disabling Unicode-awareness in builtin charclasses</source>
          <target state="translated">第24节：在内置字符类中禁用Unicode感知</target>
        </trans-unit>
        <trans-unit id="992aea2e1ad40f008b3e87938c62de07b67f29dc" translate="yes" xml:space="preserve">
          <source>℞ 25: Match Unicode properties in regex with \p, \P</source>
          <target state="translated">25：将正则表达式中的Unicode属性与\ p，\ P匹配</target>
        </trans-unit>
        <trans-unit id="9031b7ab091f3539c164cdd9834c8ea6ca177c41" translate="yes" xml:space="preserve">
          <source>℞ 26: Custom character properties</source>
          <target state="translated">℞26：自定义角色属性</target>
        </trans-unit>
        <trans-unit id="a93543794d643ee0acfa19d73095b8305fc87183" translate="yes" xml:space="preserve">
          <source>℞ 27: Unicode normalization</source>
          <target state="translated">℞27：Unicode规范化</target>
        </trans-unit>
        <trans-unit id="3af91d59321e31bb1b94eea9e6b20a303f096c4b" translate="yes" xml:space="preserve">
          <source>℞ 28: Convert non-ASCII Unicode numerics</source>
          <target state="translated">℞28：转换非ASCII Unicode数字</target>
        </trans-unit>
        <trans-unit id="28555117568adeb829bdaa480f535af4c8603c5e" translate="yes" xml:space="preserve">
          <source>℞ 29: Match Unicode grapheme cluster in regex</source>
          <target state="translated">℞29：在正则表达式中匹配Unicode字形簇</target>
        </trans-unit>
        <trans-unit id="f7f40e2d4b5881274c99d4faa54dde14ad616cad" translate="yes" xml:space="preserve">
          <source>℞ 2: Fine-tuning Unicode warnings</source>
          <target state="translated">℞2：微调Unicode警告</target>
        </trans-unit>
        <trans-unit id="7b1e91f2708a78bbedb8e5f5d87aea1a336f35a3" translate="yes" xml:space="preserve">
          <source>℞ 30: Extract by grapheme instead of by codepoint (regex)</source>
          <target state="translated">℞30：通过字素而不是代码点（regex）提取</target>
        </trans-unit>
        <trans-unit id="55cfb33ebf5f1e852b3093f5c7d0bec6229f8ea6" translate="yes" xml:space="preserve">
          <source>℞ 31: Extract by grapheme instead of by codepoint (substr)</source>
          <target state="translated">℞31：通过字素而不是代码点（substr）进行提取</target>
        </trans-unit>
        <trans-unit id="c2ba8073c4eed5409155c51ade3f945a630b558c" translate="yes" xml:space="preserve">
          <source>℞ 32: Reverse string by grapheme</source>
          <target state="translated">℞32：字素反向串</target>
        </trans-unit>
        <trans-unit id="c9ce223e0840c6abef41097684eb5f1c650104df" translate="yes" xml:space="preserve">
          <source>℞ 33: String length in graphemes</source>
          <target state="translated">℞33：字素的字串长度</target>
        </trans-unit>
        <trans-unit id="53c13862cc87714e333fa62d8720a158c6f355ab" translate="yes" xml:space="preserve">
          <source>℞ 34: Unicode column-width for printing</source>
          <target state="translated">℞34：打印的Unicode列宽</target>
        </trans-unit>
        <trans-unit id="87c7c9b1652730b229a2e3ba08465d7c12a8cfc8" translate="yes" xml:space="preserve">
          <source>℞ 35: Unicode collation</source>
          <target state="translated">℞35：Unicode归类</target>
        </trans-unit>
        <trans-unit id="0c95a7a0882b520eaa9bb5d4fbc45228b8c18573" translate="yes" xml:space="preserve">
          <source>℞ 36: Case-</source>
          <target state="translated">℞36：案例-</target>
        </trans-unit>
        <trans-unit id="d2ce8d21b9aecfb67a96ff13188b0a89e0a5624f" translate="yes" xml:space="preserve">
          <source>℞ 36: Case- _and_ accent-insensitive Unicode sort</source>
          <target state="translated">℞36：不区分大小写的Unicode排序</target>
        </trans-unit>
        <trans-unit id="968af3413a857a361da7bcd3d91cb10c913d6e25" translate="yes" xml:space="preserve">
          <source>℞ 37: Unicode locale collation</source>
          <target state="translated">℞37：Unicode语言环境整理</target>
        </trans-unit>
        <trans-unit id="ec65982ad998f2507cc77eee201536acd5324b7e" translate="yes" xml:space="preserve">
          <source>℞ 38: Making &lt;code&gt;cmp&lt;/code&gt; work on text instead of codepoints</source>
          <target state="translated">℞38：使 &lt;code&gt;cmp&lt;/code&gt; 适用于文本而不是代码点</target>
        </trans-unit>
        <trans-unit id="752951dd1ac1d7aaa972f69d508595bf5911635b" translate="yes" xml:space="preserve">
          <source>℞ 38: Making cmp work on text instead of codepoints</source>
          <target state="translated">℞38：使cmp适用于文本而不是代码点</target>
        </trans-unit>
        <trans-unit id="82c6a6149a99cdb0e50810b081474bdbf59d7dfd" translate="yes" xml:space="preserve">
          <source>℞ 39: Case-</source>
          <target state="translated">℞39：案例-</target>
        </trans-unit>
        <trans-unit id="8d5852da7209d5884eebf3b9eb1eb39a14ba85cd" translate="yes" xml:space="preserve">
          <source>℞ 39: Case- _and_ accent-insensitive comparisons</source>
          <target state="translated">℞39：不区分大小写和重音的比较</target>
        </trans-unit>
        <trans-unit id="60b49826b5438b22cc51f4ed224510924e54001e" translate="yes" xml:space="preserve">
          <source>℞ 3: Declare source in utf8 for identifiers and literals</source>
          <target state="translated">℞3：在utf8中声明标识符和文字的源</target>
        </trans-unit>
        <trans-unit id="8f875003d571e6d58aad407fafc68fd83431ef5c" translate="yes" xml:space="preserve">
          <source>℞ 40: Case-</source>
          <target state="translated">℞40：案例-</target>
        </trans-unit>
        <trans-unit id="012ea33c9fc5bf5e135a6a94297f8e911c2c2728" translate="yes" xml:space="preserve">
          <source>℞ 40: Case- _and_ accent-insensitive locale comparisons</source>
          <target state="translated">℞40：不区分大小写和区分重音的语言环境</target>
        </trans-unit>
        <trans-unit id="4537b129b3ba8f2d3226ebf93ad67329cc1da482" translate="yes" xml:space="preserve">
          <source>℞ 41: Unicode linebreaking</source>
          <target state="translated">℞41：Unicode换行符</target>
        </trans-unit>
        <trans-unit id="ffb493f106ab48250c4114cb54731a428a45f791" translate="yes" xml:space="preserve">
          <source>℞ 42: Unicode text in DBM hashes, the tedious way</source>
          <target state="translated">℞42：DBM哈希中的Unicode文本，乏味的方式</target>
        </trans-unit>
        <trans-unit id="f1f50342b103e421d1acc80b87da618d9d7dbcbf" translate="yes" xml:space="preserve">
          <source>℞ 43: Unicode text in DBM hashes, the easy way</source>
          <target state="translated">℞43：DBM哈希中的Unicode文本，简单的方法</target>
        </trans-unit>
        <trans-unit id="be7f9e81a5e53cdd3b016c1ec9d11fc76ad6eba7" translate="yes" xml:space="preserve">
          <source>℞ 44: PROGRAM: Demo of Unicode collation and printing</source>
          <target state="translated">℞44：计划：Unicode校对和打印演示</target>
        </trans-unit>
        <trans-unit id="35d3a90ee9a924edf21b2fcf53b46d3f1ee47cd1" translate="yes" xml:space="preserve">
          <source>℞ 4: Characters and their numbers</source>
          <target state="translated">℞4：字符及其编号</target>
        </trans-unit>
        <trans-unit id="8c799958f1af6fc7d0af3b5af403902598504cc5" translate="yes" xml:space="preserve">
          <source>℞ 5: Unicode literals by character number</source>
          <target state="translated">℞5：按字符数表示的Unicode文字</target>
        </trans-unit>
        <trans-unit id="552601dd95b39360794bf9c6c82f6ccf33fa9abf" translate="yes" xml:space="preserve">
          <source>℞ 6: Get character name by number</source>
          <target state="translated">℞6：通过数字获取角色名称</target>
        </trans-unit>
        <trans-unit id="16cf8eadbcf317c2200365ffa590b025a1e5c8c9" translate="yes" xml:space="preserve">
          <source>℞ 7: Get character number by name</source>
          <target state="translated">℞7：按名称获取字符编号</target>
        </trans-unit>
        <trans-unit id="914bc39318d79633608c077d658050da4a15d838" translate="yes" xml:space="preserve">
          <source>℞ 8: Unicode named characters</source>
          <target state="translated">℞8：Unicode命名字符</target>
        </trans-unit>
        <trans-unit id="3f674921da6a254bb1bdedb20a3aa7a9fc774879" translate="yes" xml:space="preserve">
          <source>℞ 9: Unicode named sequences</source>
          <target state="translated">℞9：Unicode命名序列</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
