<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="5e82b72795636964d66437770c692b7d03ceb23b" translate="yes" xml:space="preserve">
          <source>To assign a specific &lt;b&gt;network address&lt;/b&gt; to a &lt;b&gt;socket&lt;/b&gt;.</source>
          <target state="translated">要指定一个特定的&lt;b&gt;网络地址&lt;/b&gt;的&lt;b&gt;插座&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="c2c2805d5269d7141c86f56aaf1c2c2a76a26622" translate="yes" xml:space="preserve">
          <source>To assist you &lt;code&gt;test_test&lt;/code&gt; can colour the background of the debug information to disambiguate the different types of output. The debug output will have its background coloured green and red. The green part represents the text which is the same between the executed and actual output, the red shows which part differs.</source>
          <target state="translated">为了帮助您， &lt;code&gt;test_test&lt;/code&gt; 可以为调试信息的背景着色，以消除不同类型的输出的歧义。调试输出的背景将变为绿色和红色。绿色部分表示已执行的输出和实际输出之间的文本相同，红色部分表示不同的文本。</target>
        </trans-unit>
        <trans-unit id="e8e1cbea5e7824434cdf9fc699c75f29c54b93f0" translate="yes" xml:space="preserve">
          <source>To auto-detect and uncompress an RFC 1950 or RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP_OR_ZLIB&lt;/code&gt; .</source>
          <target state="translated">要自动检测并解压缩RFC 1950或RFC 1952数据流（即gzip），请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;WANT_GZIP_OR_ZLIB&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b525fdc47ff53e260dc0931cfbc7865b5eae8d3" translate="yes" xml:space="preserve">
          <source>To avoid ambiguity, when signatures are enabled the special syntax for prototypes is disabled. There is no attempt to guess whether a parenthesised group was intended to be a prototype or a signature. To give a subroutine a prototype under these circumstances, use a &lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;prototype attribute&lt;/a&gt;. For example,</source>
          <target state="translated">为避免歧义，启用签名后，将禁用原型的特殊语法。没有尝试猜测带括号的组是作为原型还是签名。要在这种情况下为子例程提供原型，请使用&lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;prototype属性&lt;/a&gt;。例如，</target>
        </trans-unit>
        <trans-unit id="409b9ee9e716af7051876e4ad525c073a4badea1" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code who are running earlier versions of Perl with mysterious failures, put this sort of thing at the top of your file to signal that your code will work</source>
          <target state="translated">为了避免让那些正在运行早期版本的Perl的潜在用户对你的代码感到困惑,请在文件的顶部写上这样的内容,以表明你的代码可以正常工作。</target>
        </trans-unit>
        <trans-unit id="cdb270b498c0b4af5dad93d34e6e87c778aa6616" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code who are running earlier versions of Perl with mysterious syntax errors, put this sort of thing at the top of your file to signal that your code will work</source>
          <target state="translated">为了避免那些正在运行早期版本的Perl的潜在用户被神秘的语法错误所迷惑,请在文件的顶部写上这样的内容,以表明你的代码可以正常工作</target>
        </trans-unit>
        <trans-unit id="010f767fa3f7758e437e81843e72a2beb1516ec0" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code with mysterious syntax errors, put something like this at the top of your script:</source>
          <target state="translated">为了避免你的代码的潜在用户被神秘的语法错误所迷惑,在你的脚本的顶部写上这样的内容。</target>
        </trans-unit>
        <trans-unit id="92c9a11d8c00dc701cc8cb47a28dac284fb7ca76" translate="yes" xml:space="preserve">
          <source>To avoid creating a new SV every time &lt;code&gt;SaveSub2&lt;/code&gt; is called, the function first checks to see if it has been called before. If not, then space for a new SV is allocated and the reference to the Perl subroutine &lt;code&gt;name&lt;/code&gt; is copied to the variable &lt;code&gt;keepSub&lt;/code&gt; in one operation using &lt;code&gt;newSVsv&lt;/code&gt; . Thereafter, whenever &lt;code&gt;SaveSub2&lt;/code&gt; is called, the existing SV, &lt;code&gt;keepSub&lt;/code&gt; , is overwritten with the new value using &lt;code&gt;SvSetSV&lt;/code&gt; .</source>
          <target state="translated">为了避免每次调用 &lt;code&gt;SaveSub2&lt;/code&gt; 时都创建新的SV ，该函数首先检查是否已调用过它。如果不是，则分配用于新SV的空间，并使用 &lt;code&gt;newSVsv&lt;/code&gt; 在一次操作中将对 Perl子例程 &lt;code&gt;name&lt;/code&gt; 的引用复制到变量 &lt;code&gt;keepSub&lt;/code&gt; 中。此后，每当 &lt;code&gt;SaveSub2&lt;/code&gt; 被调用时，现有SV， &lt;code&gt;keepSub&lt;/code&gt; ，改写为使用新的值 &lt;code&gt;SvSetSV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f1c469efc6b2f6bb3fb09ea0c807689f209337a" translate="yes" xml:space="preserve">
          <source>To avoid memory leaks, all trailing duplicate entries in @INC are removed.</source>
          <target state="translated">为了避免内存泄漏,@INC中所有尾部重复的条目都被删除。</target>
        </trans-unit>
        <trans-unit id="fe0f91423917e2fcf830eb3362231efceaad6437" translate="yes" xml:space="preserve">
          <source>To avoid relying on an object's underlying representation, if the smartmatch's right operand is an object that doesn't overload &lt;code&gt;~~&lt;/code&gt; , it raises the exception &quot;&lt;code&gt;Smartmatching a non-overloaded object
breaks encapsulation&lt;/code&gt; &quot;. That's because one has no business digging around to see whether something is &quot;in&quot; an object. These are all illegal on objects without a &lt;code&gt;~~&lt;/code&gt; overload:</source>
          <target state="translated">为了避免依赖对象的基础表示，如果smartmatch的正确操作数是不重载 &lt;code&gt;~~&lt;/code&gt; 的对象，则会引发异常&amp;ldquo; &lt;code&gt;Smartmatching a non-overloaded object breaks encapsulation&lt;/code&gt; &amp;rdquo;。那是因为没有人在四处寻找东西是否在物体中。这些对没有 &lt;code&gt;~~&lt;/code&gt; 重载的对象都是非法的：</target>
        </trans-unit>
        <trans-unit id="4c10393ba7ca423ef6dd3c94a2b581675efc33a8" translate="yes" xml:space="preserve">
          <source>To avoid the possibility of miscoordination, Perl now flushes FILEHANDLE before locking or unlocking it.</source>
          <target state="translated">为了避免误操作的可能性,Perl现在在锁定或解锁FILEHANDLE之前会先刷新它。</target>
        </trans-unit>
        <trans-unit id="5d5d75934a6f7e951fd9357cb74cb7683ab1e280" translate="yes" xml:space="preserve">
          <source>To avoid this problem, either put in extra parentheses or use the super low precedence &lt;code&gt;or&lt;/code&gt; operator:</source>
          <target state="translated">为避免此问题，请添加额外的括号或使用超低优先级 &lt;code&gt;or&lt;/code&gt; 运算符：</target>
        </trans-unit>
        <trans-unit id="766d42f164385b7f29a7e92b44d6d78b6d17a595" translate="yes" xml:space="preserve">
          <source>To avoid this problem, when it encounters a here document whilst extracting from a modifiable string, &lt;code&gt;extract_quotelike&lt;/code&gt; silently rearranges the string to an equivalent piece of Perl:</source>
          <target state="translated">为了避免这个问题，当它在从可修改的字符串中提取时遇到一个here文档时， &lt;code&gt;extract_quotelike&lt;/code&gt; 会默默地将该字符串重新排列为等效的Perl：</target>
        </trans-unit>
        <trans-unit id="da9ceee7d2a6a8bd92bf59b8dd4824301848ef6c" translate="yes" xml:space="preserve">
          <source>To avoid this warning and to avoid having different output encodings in a single stream, always specify an encoding explicitly, for example with a PerlIO layer:</source>
          <target state="translated">为了避免这个警告,并避免在一个流中有不同的输出编码,总是显式地指定一个编码,例如用PerlIO层。</target>
        </trans-unit>
        <trans-unit id="35af978891563db2721278dcfd7e8de9b9ef61ce" translate="yes" xml:space="preserve">
          <source>To avoid this, whenever a CV and its associated pad is freed, any &lt;code&gt;&amp;amp;&lt;/code&gt; entries in the pad are explicitly removed from the pad, and if the refcount of the pointed-to anon sub is still positive, then that child's &lt;code&gt;CvOUTSIDE&lt;/code&gt; is set to point to its grandparent. This will only occur in the single specific case of a non-closure anon prototype having one or more active references (such as &lt;code&gt;$a&lt;/code&gt; above).</source>
          <target state="translated">为避免这种情况，每当释放CV及其关联的填充板时，该填充板中的所有 &lt;code&gt;&amp;amp;&lt;/code&gt; 条目都会从填充板中显式删除，并且如果所指向的anon子的引用计数仍为正，则该孩子的 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 设置为指向给祖父母这仅在具有一个或多个活动引用（例如上述 &lt;code&gt;$a&lt;/code&gt; ）的非封闭式匿名原型的单个特定情况下发生。</target>
        </trans-unit>
        <trans-unit id="892f516de74c75c59b1eb990ddf92d3f52eefdaf" translate="yes" xml:space="preserve">
          <source>To avoid this, you can force the Makefile to be rebuilt whenever you change the module containing the version number by adding this to your WriteMakefile() arguments.</source>
          <target state="translated">为了避免这种情况,你可以通过在你的WriteMakefile()参数中添加以下内容来强制Makefile在每次改变包含版本号的模块时被重建。</target>
        </trans-unit>
        <trans-unit id="79bc3cfb105613cbe5f2c89b6ab087189a45bded" translate="yes" xml:space="preserve">
          <source>To avoid wasted work when a restart is needed, the sizing pass is abandoned - &lt;code&gt;regatom()&lt;/code&gt; immediately returns NULL, setting the flag &lt;code&gt;RESTART_UTF8&lt;/code&gt; . (This action is encapsulated using the macro &lt;code&gt;REQUIRE_UTF8&lt;/code&gt; .) This restart request is propagated up the call chain in a similar fashion, until it is &quot;caught&quot; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , which marks the pattern as containing Unicode, and restarts the sizing pass. It is also possible for constructions within run-time code blocks to turn out to need Unicode representation., which is signalled by &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; returning false to &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; .</source>
          <target state="translated">为了避免在需要重新启动时浪费工作，调整大小通道被放弃 &lt;code&gt;regatom()&lt;/code&gt; 立即返回NULL，并设置标志 &lt;code&gt;RESTART_UTF8&lt;/code&gt; 。 （此操作使用宏 &lt;code&gt;REQUIRE_UTF8&lt;/code&gt; 封装。）此重新启动请求以类似的方式在调用链中传播，直到被&amp;ldquo;捕获&amp;rdquo;在 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; 中，该标志将模式标记为包含Unicode，然后重新启动调整大小。运行时代码块中的构造也有可能需要Unicode表示。这由 &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; 返回false到 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; 来表示。</target>
        </trans-unit>
        <trans-unit id="09e124c75c7cbe80f3e4228168f11f802fe412a9" translate="yes" xml:space="preserve">
          <source>To be able to access the two parameters that were pushed onto the stack after they return from</source>
          <target state="translated">为了能够访问两个参数,这两个参数在它们从</target>
        </trans-unit>
        <trans-unit id="6e3a208559e7fc6775f8912d077235f17cca0135" translate="yes" xml:space="preserve">
          <source>To be announced.</source>
          <target state="translated">有待宣布。</target>
        </trans-unit>
        <trans-unit id="161647c06ada22688c122c82ae94e4258d4b89c7" translate="yes" xml:space="preserve">
          <source>To be announced. Or deleted.</source>
          <target state="translated">待公布。或删除。</target>
        </trans-unit>
        <trans-unit id="1942f94bc444abb1b89482bc04403e0f7a2e9a63" translate="yes" xml:space="preserve">
          <source>To be compatible with .Net regular expressions, &lt;code&gt;\g{name}&lt;/code&gt; may also be written as &lt;code&gt;\k{name}&lt;/code&gt; , &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'name'&lt;/code&gt;.</source>
          <target state="translated">为了与.Net正则表达式兼容， &lt;code&gt;\g{name}&lt;/code&gt; 也可以写为 &lt;code&gt;\k{name}&lt;/code&gt; ， &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; 或 &lt;code&gt;\k'name'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc3bab69ee4c24015f181f505f714806f55a6a5d" translate="yes" xml:space="preserve">
          <source>To be fully compatible with the Exporter and MakeMaker modules you should store your module's version number in a non-my package variable called $VERSION. This should be a positive floating point number with at least two digits after the decimal (i.e., hundredths, e.g, &lt;code&gt;$VERSION = &quot;0.01&quot;&lt;/code&gt; ). Don't use a &quot;1.3.2&quot; style version. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for details.</source>
          <target state="translated">为了与Exporter和MakeMaker模块完全兼容，应将模块的版本号存储在名为$ VERSION的非我的程序包变量中。这应该是一个正浮点数，在小数点后至少应有两位数字（例如，百分之一，例如 &lt;code&gt;$VERSION = &quot;0.01&quot;&lt;/code&gt; ）。不要使用&amp;ldquo; 1.3.2&amp;rdquo;样式的版本。有关详细信息，请参见&lt;a href=&quot;exporter&quot;&gt;导出&lt;/a&gt;器。</target>
        </trans-unit>
        <trans-unit id="781abe7cd10e483cb21c7189d334aa3e4eaca732" translate="yes" xml:space="preserve">
          <source>To be more precise, we will say that a regex program is an encoding of a graph. Each node in the graph corresponds to part of the original regex pattern, such as a literal string or a branch, and has a pointer to the nodes representing the next component to be matched. Since &quot;node&quot; and &quot;opcode&quot; already have other meanings in the perl source, we will call the nodes in a regex program &quot;regops&quot;.</source>
          <target state="translated">更准确地说,我们会说一个regex程序是一个图的编码。图中的每一个节点都对应着原始regex模式的一部分,比如一个文字字符串或一个分支,并且有一个指针指向代表下一个要匹配的组件的节点。由于 &quot;节点 &quot;和 &quot;opcode &quot;在perl源码中已经有了其他含义,所以我们将regex程序中的节点称为 &quot;regops&quot;。</target>
        </trans-unit>
        <trans-unit id="a03a7a550b2afe3393fb820749da17491cf98371" translate="yes" xml:space="preserve">
          <source>To be pedantic, the comparison is actually &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR)&lt;/code&gt; , but that is only an issue if you use a floating point expression; when implicitly using &lt;code&gt;$.&lt;/code&gt; as described in the previous paragraph, the comparison is &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;($.)&lt;/code&gt; which is only an issue when &lt;code&gt;$.&lt;/code&gt; is set to a floating point value and you are not reading from a file. Furthermore, &lt;code&gt;&quot;span&quot; .. &quot;spat&quot;&lt;/code&gt; or &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will not do what you want in scalar context because each of the operands are evaluated using their integer representation.</source>
          <target state="translated">要学究，比较实际上是 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR)&lt;/code&gt; ，但这仅是使用浮点表达式的问题；隐式使用 &lt;code&gt;$.&lt;/code&gt; 如上一段所述，比较是 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;($.)&lt;/code&gt; ，这只是在 &lt;code&gt;$.&lt;/code&gt; 时有问题。设置为浮点值，并且您不是从文件中读取。此外， &lt;code&gt;&quot;span&quot; .. &quot;spat&quot;&lt;/code&gt; 或 &lt;code&gt;2.18 .. 3.14&lt;/code&gt; 在标量上下文中将无法执行您想要的操作，因为每个操作数均使用其整数表示来求值。</target>
        </trans-unit>
        <trans-unit id="ed53a49e46f6db6479ffd9a906bbff37f48f8995" translate="yes" xml:space="preserve">
          <source>To be polite to other functions wrapping your own you usually want to increment &lt;code&gt;$Level&lt;/code&gt; rather than set it to a constant.</source>
          <target state="translated">为了礼貌地使用其他包装自己的函数，通常需要增加 &lt;code&gt;$Level&lt;/code&gt; 而不是将其设置为常量。</target>
        </trans-unit>
        <trans-unit id="377966b7899d2c6cc0617addc0bc388cc67a68ae" translate="yes" xml:space="preserve">
          <source>To be portable each component of a module name should be limited to 11 characters. If it might be used on MS-DOS then try to ensure each is unique in the first 8 characters. Nested modules make this easier.</source>
          <target state="translated">为了便于移植,模块名称中的每个组件应限制在11个字符以内。如果它可能在MS-DOS上使用,那么尽量保证每个模块的前8个字符是唯一的。嵌套的模块可以使这一点更容易。</target>
        </trans-unit>
        <trans-unit id="b076f38e81902902b25d1f17b1608ab8be160484" translate="yes" xml:space="preserve">
          <source>To begin your reading, start with:</source>
          <target state="translated">要开始阅读,先从。</target>
        </trans-unit>
        <trans-unit id="a61e1eb5d11062cb9036bb12d10d76fe348be7c1" translate="yes" xml:space="preserve">
          <source>To browse existing Perl bugs and patches, you can use the web interface at &lt;a href=&quot;http://rt.perl.org/&quot;&gt;http://rt.perl.org/&lt;/a&gt;.</source>
          <target state="translated">要浏览现有的Perl错误和补丁，可以使用Web界面，网址为&lt;a href=&quot;http://rt.perl.org/&quot;&gt;http://rt.perl.org/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b19b13b7eebea3b4a95edad33fffc49ec225b2e5" translate="yes" xml:space="preserve">
          <source>To build a non-XS module, you can use the standard module-building instructions distributed with perl modules.</source>
          <target state="translated">要建立一个非XS模块,你可以使用随perl模块分发的标准模块建立指令。</target>
        </trans-unit>
        <trans-unit id="6c2705e01ac97996d808db8effeb88881961867f" translate="yes" xml:space="preserve">
          <source>To build an XS module, you must use the standard module-building instructions distributed with perl modules *PLUS* three extra instructions specific to the DJGPP &quot;static link&quot; build environment.</source>
          <target state="translated">要构建XS模块,必须使用随perl模块分发的标准模块构建指令*PLUS*三个针对DJGPP &quot;静态链接 &quot;构建环境的额外指令。</target>
        </trans-unit>
        <trans-unit id="d5c2765f0199128d509d1897ee86d4417f4dd8a3" translate="yes" xml:space="preserve">
          <source>To build extensions other than standard extensions, NetWare Perl has to be installed on Windows along with Windows Perl. The Perl for Windows can be either downloaded from the CPAN site and built using the sources, or the binaries can be directly downloaded from the ActiveState site. Installation can be done by invoking</source>
          <target state="translated">要建立标准扩展以外的扩展,必须在Windows上安装NetWare Perl和Windows Perl。Windows 的 Perl 可以从 CPAN 站点下载并使用源代码构建,或者直接从 ActiveState 站点下载二进制文件。安装可以通过调用</target>
        </trans-unit>
        <trans-unit id="787c86241856156cd077a05b7bdc7004761044c1" translate="yes" xml:space="preserve">
          <source>To build perl from its source code on the Stratus V Series platform you must have OpenVOS Release 17.1.0 or later, GNU Tools Release 3.5 or later, and the C/POSIX Runtime Libraries.</source>
          <target state="translated">要在Stratus V系列平台上从源代码中构建perl,你必须有OpenVOS 17.1.0或更高版本,GNU Tools 3.5或更高版本,以及C/POSIX Runtime Libraries。</target>
        </trans-unit>
        <trans-unit id="29d9cfbafe7af9c12fb5ae5d7307a03b50f8bc3e" translate="yes" xml:space="preserve">
          <source>To build perl with AddressSanitizer, your Configure invocation should look like:</source>
          <target state="translated">要使用AddressSanitizer构建perl,你的Configure调用应该是这样的。</target>
        </trans-unit>
        <trans-unit id="b12975798f70dc1cb8c9fb59b7af2b4445d07d6d" translate="yes" xml:space="preserve">
          <source>To calculate the digest of an n-bit message where</source>
          <target state="translated">要计算一个n位信息的摘要,其中</target>
        </trans-unit>
        <trans-unit id="0df1e5f84b4694c53717b89d6fb8b89ff7d44718" translate="yes" xml:space="preserve">
          <source>To calculate the distance between London (51.3N 0.5W) and Tokyo (35.7N 139.8E) in kilometers:</source>
          <target state="translated">计算伦敦(51.3N 0.5W)和东京(35.7N 139.8E)之间的距离,单位为公里。</target>
        </trans-unit>
        <trans-unit id="4cea3ec7425389162d89934663cf2df355daf6af" translate="yes" xml:space="preserve">
          <source>To call a function on each element in an array, and collect the results, use:</source>
          <target state="translated">要对数组中的每个元素调用一个函数,并收集结果,使用。</target>
        </trans-unit>
        <trans-unit id="dbe4aebe356ab30727111304ed5066c2800f1b44" translate="yes" xml:space="preserve">
          <source>To call a function on each element of an array, but ignore the results:</source>
          <target state="translated">对数组中的每个元素调用一个函数,但忽略结果。</target>
        </trans-unit>
        <trans-unit id="710b700709beaae3a0d7fb3e17148d99cdb1ee11" translate="yes" xml:space="preserve">
          <source>To call a function on each integer in a (small) range, you &lt;b&gt;can&lt;/b&gt; use:</source>
          <target state="translated">要在（较小）范围内的每个整数上调用函数，&lt;b&gt;可以&lt;/b&gt;使用：</target>
        </trans-unit>
        <trans-unit id="b0c03ca703f3d70571e4ed1a5f4b95eb2f4f7eac" translate="yes" xml:space="preserve">
          <source>To call individual Perl subroutines, you can use any of the &lt;b&gt;call_*&lt;/b&gt; functions documented in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;. In this example we'll use &lt;code&gt;call_argv&lt;/code&gt; .</source>
          <target state="translated">要调用单独的Perl子程序，你可以使用任何的&lt;b&gt;call_ *&lt;/b&gt;中介绍的功能&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。在此示例中，我们将使用 &lt;code&gt;call_argv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f49f3d19c459317781abadc37d2ae6f14022eac3" translate="yes" xml:space="preserve">
          <source>To call subroutines:</source>
          <target state="translated">要调用子程序。</target>
        </trans-unit>
        <trans-unit id="5abcacc2499f97bcbde0588fdd4401b44cc6c01a" translate="yes" xml:space="preserve">
          <source>To capture a command's STDERR but discard its STDOUT (ordering is important here):</source>
          <target state="translated">捕获一个命令的STDERR,但丢弃它的STDOUT(这里的顺序很重要)。</target>
        </trans-unit>
        <trans-unit id="891b8754dd37bb2c3dc54aab3a1185e0fd372170" translate="yes" xml:space="preserve">
          <source>To capture a command's STDERR but discard its STDOUT:</source>
          <target state="translated">捕获命令的STDERR,但丢弃其STDOUT。</target>
        </trans-unit>
        <trans-unit id="7ddfc050c95c3b76b8561d8851899b023835e01c" translate="yes" xml:space="preserve">
          <source>To capture a command's STDOUT but discard its STDERR:</source>
          <target state="translated">捕获命令的STDOUT,但丢弃其STDERR。</target>
        </trans-unit>
        <trans-unit id="459bfbbfb62f196ec5bdfb8f616f754fb8b81d04" translate="yes" xml:space="preserve">
          <source>To capture a program's STDERR, and let its STDOUT go to our own STDERR:</source>
          <target state="translated">捕捉一个程序的STDERR,让它的STDOUT进入我们自己的STDERR。</target>
        </trans-unit>
        <trans-unit id="5bd52eb04283645c047b422b0b8e0a7d88ad61c6" translate="yes" xml:space="preserve">
          <source>To capture a program's STDERR, but discard its STDOUT:</source>
          <target state="translated">捕获程序的STDERR,但丢弃其STDOUT。</target>
        </trans-unit>
        <trans-unit id="8a448a300769cb48dfafecf642b7105f4ae83d7b" translate="yes" xml:space="preserve">
          <source>To capture a program's STDOUT, but discard its STDERR:</source>
          <target state="translated">捕获程序的STDOUT,但丢弃其STDERR。</target>
        </trans-unit>
        <trans-unit id="48535a0ea84ddf99c0ff0191b2ebc7ac2d2965e6" translate="yes" xml:space="preserve">
          <source>To catch this kind of problem, we can force each variable to be declared before use by pulling in the strict module, by putting 'use strict;' after the first line of the script.</source>
          <target state="translated">为了抓住这种问题,我们可以通过拉入strict模块,在脚本的第一行后面加上'use strict;',强制每个变量在使用前声明。</target>
        </trans-unit>
        <trans-unit id="ee4539dea7c8d87e83fb7b99fbcea7146f28bf41" translate="yes" xml:space="preserve">
          <source>To center a whole line of text, do something like this:</source>
          <target state="translated">要将整行文字居中,可以这样做。</target>
        </trans-unit>
        <trans-unit id="cb50b80c4012bf8864c9070a8feaf64a654c0893" translate="yes" xml:space="preserve">
          <source>To change existing lines, insert the code to modify the lines inside the &lt;code&gt;while&lt;/code&gt; loop. In this case, the code finds all lowercased versions of &quot;perl&quot; and uppercases them. The happens for every line, so be sure that you're supposed to do that on every line!</source>
          <target state="translated">要更改现有行，请插入代码以修改 &lt;code&gt;while&lt;/code&gt; 循环内的行。在这种情况下，代码将查找&amp;ldquo; perl&amp;rdquo;的所有小写版本并将其大写。每行都会发生这种情况，因此请确保您应该在每行上都执行此操作！</target>
        </trans-unit>
        <trans-unit id="3014ba02f0b23a5077d149c5a55186e1b0210812" translate="yes" xml:space="preserve">
          <source>To change one of these elements, just assign to it like this:</source>
          <target state="translated">要改变其中一个元素,只需像这样分配给它。</target>
        </trans-unit>
        <trans-unit id="0bc26e290e338fd9cb7ec178f79c71f3fe32327a" translate="yes" xml:space="preserve">
          <source>To change only a particular line, the input line number, &lt;code&gt;$.&lt;/code&gt; , is useful. First read and print the lines up to the one you want to change. Next, read the single line you want to change, change it, and print it. After that, read the rest of the lines and print those:</source>
          <target state="translated">要仅更改特定行，请输入行号 &lt;code&gt;$.&lt;/code&gt; ，很有用。首先阅读并打印您要更改的行。接下来，阅读要更改的一行，进行更改并打印。之后，阅读其余各行并打印：</target>
        </trans-unit>
        <trans-unit id="f7b3b581f75dc5b407edfb21187704d85ccc3337" translate="yes" xml:space="preserve">
          <source>To change only the fifth line, you can add a test checking &lt;code&gt;$.&lt;/code&gt; , the input line number, then only perform the operation when the test passes:</source>
          <target state="translated">要仅更改第五行，可以添加一个检查 &lt;code&gt;$.&lt;/code&gt; 的测试。，输入行号，然后仅在测试通过时执行操作：</target>
        </trans-unit>
        <trans-unit id="2ac56000e9557456388facc9434e99b2f25c68f2" translate="yes" xml:space="preserve">
          <source>To change part of a string, you can use the optional fourth argument which is the replacement string.</source>
          <target state="translated">要改变字符串的一部分,可以使用可选的第四个参数,即替换字符串。</target>
        </trans-unit>
        <trans-unit id="159bf1e2399227a81a68240fcbc4a8d0c4d4386e" translate="yes" xml:space="preserve">
          <source>To change the configuration you will need to use either the &lt;code&gt;-c&lt;/code&gt; or the &lt;code&gt;-d&lt;/code&gt; options.</source>
          <target state="translated">要更改配置，您将需要使用 &lt;code&gt;-c&lt;/code&gt; 或 &lt;code&gt;-d&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="82b774af2b2d757667a119fdffcb3a39066bffc5" translate="yes" xml:space="preserve">
          <source>To change the value of an</source>
          <target state="translated">要改变一个</target>
        </trans-unit>
        <trans-unit id="c3243d9e5f9c11b853cdbfbdad7815af406db7ec" translate="yes" xml:space="preserve">
          <source>To check if you've got an object derived from a specific class you have to write:</source>
          <target state="translated">要检查你是否有一个从特定类派生出来的对象,你必须写。</target>
        </trans-unit>
        <trans-unit id="b5f0280c18244571ee821966259aa01905eea140" translate="yes" xml:space="preserve">
          <source>To check that a PerlIO* is valid use PerlIOValid(PerlIO *f). (All this does is really just to check that the pointer is non-NULL and that the pointer behind that is non-NULL.)</source>
          <target state="translated">要检查一个PerlIO*是否有效,使用PerlIOValid(PerlIO *f)。(所有这一切其实只是为了检查指针是否为非NULL,以及后面的指针是否为非NULL。)</target>
        </trans-unit>
        <trans-unit id="6efc33cfc9910a60ea4ef9bf5110b124df74dec6" translate="yes" xml:space="preserve">
          <source>To circumvent this, Perl uses two hacks. They help against</source>
          <target state="translated">为了规避这个问题,Perl使用了两个黑客。它们有助于防止</target>
        </trans-unit>
        <trans-unit id="9b687155f88b0a0c7f0b7a50cd6c0fc2a98e0825" translate="yes" xml:space="preserve">
          <source>To clear the screen, you just have to print the special sequence that tells the terminal to clear the screen. Once you have that sequence, output it when you want to clear the screen.</source>
          <target state="translated">要清除屏幕,你只需要打印出告诉终端清除屏幕的特殊序列。一旦你有了这个序列,当你要清除屏幕时,就输出它。</target>
        </trans-unit>
        <trans-unit id="5339fbdb482ebe20149617c58a946c9025ec4bd2" translate="yes" xml:space="preserve">
          <source>To compare two strings case-insensitively, use &lt;a href=&quot;perlapi#foldEQ_utf8&quot;&gt;foldEQ_utf8() &lt;/a&gt; (the strings don't have to have the same UTF-8ness).</source>
          <target state="translated">&lt;a href=&quot;perlapi#foldEQ_utf8&quot;&gt;要不&lt;/a&gt;区分大小写地比较两个字符串，请使用foldEQ_utf8（）（这些字符串不必具有相同的UTF-8ness）。</target>
        </trans-unit>
        <trans-unit id="9ef4437f2da5ad50f0107615b5cd7fb7937669db" translate="yes" xml:space="preserve">
          <source>To compile Perl with threads, add -Dusethreads to the arguments of Configure. Verify that the -D_POSIX_C_SOURCE=199506L compiler flag is automatically added to the list of flags. Also make sure that -lpthread is listed before -lc in the list of libraries to link Perl with. The hints provided for HP-UX during Configure will try very hard to get this right for you.</source>
          <target state="translated">要用线程编译Perl,请在Configure的参数中添加-Dusethreads。确认 -D_POSIX_C_SOURCE=199506L 编译器标志会自动添加到标志列表中。同时确保在链接Perl的库列表中,-lpthread被列在-lc之前。在配置过程中为HP-UX提供的提示会很努力的为你做好这个工作。</target>
        </trans-unit>
        <trans-unit id="dca1f2d388460992485bc83958326b4fabbe3a89" translate="yes" xml:space="preserve">
          <source>To compile a 64-bit application on an UltraSparc with a recent Sun Compiler, you need to use the flag &quot;-xarch=v9&quot;. getconf(1) will tell you this, e.g.</source>
          <target state="translated">要在UltraSparc上用最新的Sun编译器编译一个64位的应用程序,需要使用&quot;-xarch=v9 &quot;这个标志,getconf(1)会告诉你这一点,例如</target>
        </trans-unit>
        <trans-unit id="87a608f7610a06343062c0a4f15a78987866b679" translate="yes" xml:space="preserve">
          <source>To compress all files in the directory &quot;/my/home&quot; that match &quot;*.txt&quot; and store the compressed data in the same directory</source>
          <target state="translated">压缩&quot;/my/home &quot;目录下所有符合 &quot;*.txt &quot;的文件,并将压缩后的数据存储在同一目录下。</target>
        </trans-unit>
        <trans-unit id="e79c6c77e53867aede1a00267dc0d36f666b7950" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number between 8 and 15.</source>
          <target state="translated">要压缩RFC 1950数据流，请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为8到15之间的正数。</target>
        </trans-unit>
        <trans-unit id="7421981a167883ab2bc4949efb716b7db4314b6b" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">要压缩RFC 1951数据流，请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb0992d170df6f988844c94c5a16d02581fe60f0" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP&lt;/code&gt; .</source>
          <target state="translated">要压缩RFC 1952数据流（即gzip），请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;WANT_GZIP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c0a5b03c1713572aa7618df4ce2ea31c5f8ea2a" translate="yes" xml:space="preserve">
          <source>To concatenate</source>
          <target state="translated">连接</target>
        </trans-unit>
        <trans-unit id="6e6c0c8d29557c5cf786e08230a13bcf9f5a031b" translate="yes" xml:space="preserve">
          <source>To configure the</source>
          <target state="translated">要配置</target>
        </trans-unit>
        <trans-unit id="b8324e82632846a0ff4c29dfcce46aaf6bb8f9fb" translate="yes" xml:space="preserve">
          <source>To connect one filehandle to several output filehandles, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Tee&quot;&gt;IO::Tee&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::FileHandle::Multiplex&quot;&gt;Tie::FileHandle::Multiplex&lt;/a&gt; modules.</source>
          <target state="translated">要将一个文件句柄连接到多个输出文件句柄，可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/IO::Tee&quot;&gt;IO :: Tee&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/Tie::FileHandle::Multiplex&quot;&gt;Tie :: FileHandle :: Multiplex&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="8d6cbc660d600cd1c4583162826d97d790f4bf63" translate="yes" xml:space="preserve">
          <source>To conserve memory you should have your compiler modules loaded into the Link Pack Area (LPA/ELPA) rather than in a link list or step lib.</source>
          <target state="translated">为了节省内存,你应该将你的编译器模块加载到链接包区域(LPA/ELPA),而不是链接列表或步骤库中。</target>
        </trans-unit>
        <trans-unit id="968a823fad5813dfb21cd46750147776a5611926" translate="yes" xml:space="preserve">
          <source>To considerably speed up the initial CPAN shell startup, it is possible to use Storable to create a cache of metadata. If Storable is not available, the normal index mechanism will be used.</source>
          <target state="translated">为了大大加快CPAN shell的初始启动速度,可以使用Storable来创建元数据的缓存。如果Storable不可用,将使用普通的索引机制。</target>
        </trans-unit>
        <trans-unit id="20a4b2b8d77aba12d02e264b26db5b4fc2052c4a" translate="yes" xml:space="preserve">
          <source>To contact the author, send email to: &lt;code&gt;mjd-perl-tiefile+@plover.com&lt;/code&gt;</source>
          <target state="translated">要与作者联系，请发送电子邮件至： &lt;code&gt;mjd-perl-tiefile+@plover.com&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4e7d2faeb717445863f554610fdabbf94c812cb" translate="yes" xml:space="preserve">
          <source>To control what text is used for display, you use &quot;&lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt;&quot;, as in:</source>
          <target state="translated">要控制用于显示的文本，请使用&amp;ldquo; &lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt; &amp;rdquo;，如下所示：</target>
        </trans-unit>
        <trans-unit id="0f2616580d4b758d8bc7475f582ba3ef32958144" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;$Config{perlpath}&lt;/code&gt; to a file pathname, say:</source>
          <target state="translated">要将 &lt;code&gt;$Config{perlpath}&lt;/code&gt; 转换为文件路径名，请说：</target>
        </trans-unit>
        <trans-unit id="445d48b4e3ded0561c8b941a914e856d01c116d2" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;$^X&lt;/code&gt; to a file pathname, taking account of the requirements of the various operating system possibilities, say:</source>
          <target state="translated">考虑到各种操作系统可能性的要求，将 &lt;code&gt;$^X&lt;/code&gt; 转换为文件路径名，例如：</target>
        </trans-unit>
        <trans-unit id="c00d24e73fce2df83990c0f155f2d36a18a08fc4" translate="yes" xml:space="preserve">
          <source>To convert an octal number, use from_oct();</source>
          <target state="translated">要转换八进制数,使用from_oct()。</target>
        </trans-unit>
        <trans-unit id="7d95d35a7d9c8de57b1e556f0a9920a9c8320986" translate="yes" xml:space="preserve">
          <source>To convert from EBCDIC 037 to ASCII just reverse the order of the tr/// arguments like so:</source>
          <target state="translated">要将EBCDIC 037转换为ASCII码,只需将tr///参数的顺序颠倒过来,就像这样。</target>
        </trans-unit>
        <trans-unit id="e95102da8c741e9ba252adcb490152dec1b8623d" translate="yes" xml:space="preserve">
          <source>To convert from new-style to old-style, follow this recipe:</source>
          <target state="translated">要想将新式转换为旧式,请按照这个配方进行。</target>
        </trans-unit>
        <trans-unit id="9fa39707ee5532360879dd87b7e44a99cff8fee0" translate="yes" xml:space="preserve">
          <source>To copy all your .c file to a backup directory</source>
          <target state="translated">要将所有的.c文件复制到备份目录下</target>
        </trans-unit>
        <trans-unit id="5ab2f997dcaa14c701c81b93174b6bfe66ee6931" translate="yes" xml:space="preserve">
          <source>To copy the array, use</source>
          <target state="translated">要复制数组,使用</target>
        </trans-unit>
        <trans-unit id="86582412ddc1c4958ec10cc1409f68b2a052f72a" translate="yes" xml:space="preserve">
          <source>To cover such cases, you can redispatch methods via:</source>
          <target state="translated">为了覆盖这种情况,你可以通过重新分配方法。</target>
        </trans-unit>
        <trans-unit id="816db1c262f755f697320a74d5b828dbd17231a2" translate="yes" xml:space="preserve">
          <source>To create Unicode characters in literals, use the &lt;code&gt;\N{...}&lt;/code&gt; notation in double-quoted strings:</source>
          <target state="translated">要在文字中创建Unicode字符，请在双引号字符串中使用 &lt;code&gt;\N{...}&lt;/code&gt; 符号：</target>
        </trans-unit>
        <trans-unit id="c36e175a2f7ac1c4707a3b48724437b649be4b2b" translate="yes" xml:space="preserve">
          <source>To create a POD filter for translating POD documentation into some other format, you create a subclass of &lt;b&gt;Pod::Parser&lt;/b&gt; which typically overrides just the base class implementation for the following methods:</source>
          <target state="translated">要创建用于将POD文档转换为其他格式的POD过滤器，请创建&lt;b&gt;Pod :: Parser&lt;/b&gt;的子类，该子类通常仅覆盖以下方法的基类实现：</target>
        </trans-unit>
        <trans-unit id="3376aadc06d935bc6556cf078e6fff6d6ceed1e6" translate="yes" xml:space="preserve">
          <source>To create a Perl module that implements a PerlIO layer in Perl (as opposed to in C using XS as the interface to Perl), you need to supply some of the following subroutines. It is recommended to create these Perl modules in the PerlIO::via:: namespace, so that they can easily be located on CPAN and use the default namespace feature of the PerlIO::via module itself.</source>
          <target state="translated">要在Perl中创建一个实现PerlIO层的Perl模块(而不是在C语言中使用XS作为Perl的接口),你需要提供以下一些子程序。建议在PerlIO::via::命名空间中创建这些Perl模块,这样就可以很容易地在CPAN上找到它们,并使用PerlIO::via模块本身的默认命名空间功能。</target>
        </trans-unit>
        <trans-unit id="cea82dcc2341d67ceae28cb7f8dd640de30d8fab" translate="yes" xml:space="preserve">
          <source>To create a child &lt;b&gt;process&lt;/b&gt; identical to the parent process at its moment of conception, at least until it gets ideas of its own. A thread with protected memory.</source>
          <target state="translated">要在创建子&lt;b&gt;进程时&lt;/b&gt;创建与父&lt;b&gt;进程&lt;/b&gt;相同的子进程，至少要等到得到自己的想法为止。具有受保护的内存的线程。</target>
        </trans-unit>
        <trans-unit id="973c5f5d0d37e9d577d7def77212ab83a77d00d7" translate="yes" xml:space="preserve">
          <source>To create a complex number, use either:</source>
          <target state="translated">要创建一个复杂的数字,请使用以下两种方法。</target>
        </trans-unit>
        <trans-unit id="2ba00f13d11568a68eea0b9363c1c701b94f3530" translate="yes" xml:space="preserve">
          <source>To create a handler, define it as a subroutine with the same name as the desired attribute, and declare the subroutine itself with the attribute &lt;code&gt;:ATTR&lt;/code&gt; . For example:</source>
          <target state="translated">要创建处理程序，请将其定义为与所需属性同名的子例程，然后使用属性 &lt;code&gt;:ATTR&lt;/code&gt; 声明该子例程本身。例如：</target>
        </trans-unit>
        <trans-unit id="0f301595bc4c387e143da9231296df032806e83c" translate="yes" xml:space="preserve">
          <source>To create a mortal variable, use the functions:</source>
          <target state="translated">要创建一个凡人变量,请使用函数。</target>
        </trans-unit>
        <trans-unit id="168d2bd52151b2f88de55aa6a46a9bc34a213502" translate="yes" xml:space="preserve">
          <source>To create a named pipe, use the &lt;code&gt;POSIX::mkfifo()&lt;/code&gt; function.</source>
          <target state="translated">要创建命名管道，请使用 &lt;code&gt;POSIX::mkfifo()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="fb4519b518bb57bb6e760a3915cac3cb53c117b7" translate="yes" xml:space="preserve">
          <source>To create a new Perl variable with an undef value which can be accessed from your Perl script, use the following routines, depending on the variable type.</source>
          <target state="translated">要创建一个新的带有 undef 值的 Perl 变量,并可以从你的 Perl 脚本中访问,根据变量的类型,使用以下例程。</target>
        </trans-unit>
        <trans-unit id="c5e6c240b7113609dabfe56dd41076e1c64fdaed" translate="yes" xml:space="preserve">
          <source>To create a new compartment, use</source>
          <target state="translated">要创建一个新的隔间,请使用</target>
        </trans-unit>
        <trans-unit id="a2f8f5de503a593a35d422a3d1a1da701a2bb15e" translate="yes" xml:space="preserve">
          <source>To create a reference, use either of the following functions:</source>
          <target state="translated">要创建一个引用,请使用以下任一函数。</target>
        </trans-unit>
        <trans-unit id="3b14234e60346a5da75e272e4ecdc1bcef627a2f" translate="yes" xml:space="preserve">
          <source>To create a reference, we use the &lt;code&gt;newRV&lt;/code&gt; function. Note that you can cast an AV* or an HV* to type SV* in this case (and many others). This allows you to take references to arrays, hashes and scalars with the same function. Conversely, the &lt;code&gt;SvRV&lt;/code&gt; function always returns an SV*, which may need to be cast to the appropriate type if it is something other than a scalar (check with &lt;code&gt;SvTYPE&lt;/code&gt; ).</source>
          <target state="translated">要创建参考，我们使用 &lt;code&gt;newRV&lt;/code&gt; 函数。请注意，在这种情况下（以及许多其他情况），可以将AV *或HV *转换为SV *。这使您可以引用具有相同功能的数组，哈希和标量。相反， &lt;code&gt;SvRV&lt;/code&gt; 函数始终返回SV *，如果它不是标量，则可能需要转换为适当的类型（请使用 &lt;code&gt;SvTYPE&lt;/code&gt; 进行检查）。</target>
        </trans-unit>
        <trans-unit id="f750d278ece92b690ce083757a8b99d17e4a1cc6" translate="yes" xml:space="preserve">
          <source>To create a shared library, the following steps must be performed:</source>
          <target state="translated">要创建一个共享库,必须执行以下步骤。</target>
        </trans-unit>
        <trans-unit id="3c6eb343e88be36bc92d3d97f3219df475d3ded3" translate="yes" xml:space="preserve">
          <source>To create a zip file, &lt;code&gt;output.zip&lt;/code&gt; , that contains the compressed contents of the files &lt;code&gt;alpha.txt&lt;/code&gt; and &lt;code&gt;beta.txt&lt;/code&gt;</source>
          <target state="translated">要创建一个zip文件 &lt;code&gt;output.zip&lt;/code&gt; ，其中包含文件 &lt;code&gt;alpha.txt&lt;/code&gt; 和 &lt;code&gt;beta.txt&lt;/code&gt; 的压缩内容</target>
        </trans-unit>
        <trans-unit id="a8a9c4100fca7c9df2f642138fcef0fc96929592" translate="yes" xml:space="preserve">
          <source>To create an HV, you use the following routine:</source>
          <target state="translated">要创建一个HV,您可以使用以下例程。</target>
        </trans-unit>
        <trans-unit id="0094ef6c2580e3be5fb982924088c9990a9a669b" translate="yes" xml:space="preserve">
          <source>To create an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number.</source>
          <target state="translated">要创建RFC 1950数据流，请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为正数。</target>
        </trans-unit>
        <trans-unit id="c43fa53c9a4af41c4362a70dd0d3da19011de429" translate="yes" xml:space="preserve">
          <source>To create an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">要创建RFC 1951数据流，请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbb0b362cb67cdcf254362d24dcd3489205dd8b1" translate="yes" xml:space="preserve">
          <source>To create your own result types you have two options:</source>
          <target state="translated">要创建自己的结果类型,你有两个选择。</target>
        </trans-unit>
        <trans-unit id="948e86a50124d6c16a2bb795d3ad5dd4ba16fd66" translate="yes" xml:space="preserve">
          <source>To deallocate the memory of a &lt;b&gt;referent&lt;/b&gt; (first triggering its &lt;code&gt;DESTROY&lt;/code&gt; method, if it has one).</source>
          <target state="translated">取消分配&lt;b&gt;参照对象&lt;/b&gt;的内存（如果有&lt;b&gt;参照对象&lt;/b&gt;，则首先触发其 &lt;code&gt;DESTROY&lt;/code&gt; 方法）。</target>
        </trans-unit>
        <trans-unit id="684b7eba474ceeeee203e03efc4972ceab5f4011" translate="yes" xml:space="preserve">
          <source>To declare a file-private variable, you still use a lexical variable. A file is also a scope, so a lexical variable defined in the file cannot be seen from any other file.</source>
          <target state="translated">要声明一个文件私有变量,还是要使用一个词法变量。文件也是一个作用域,所以在文件中定义的词汇变量不能从其他文件中看到。</target>
        </trans-unit>
        <trans-unit id="26f359ab42151643a554fcca60e916cbc3b8c6c1" translate="yes" xml:space="preserve">
          <source>To declare multiple parents, you simply need to pass multiple class names to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; parent&lt;/code&gt; :</source>
          <target state="translated">要声明多个父对象，您只需要传递多个类名即可 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; parent&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="195f600c4f130988d6cb960024f570abb452421b" translate="yes" xml:space="preserve">
          <source>To declare subroutines:</source>
          <target state="translated">要声明子程序。</target>
        </trans-unit>
        <trans-unit id="d689355c5c4c25b69703a4f888325a4f315e40d5" translate="yes" xml:space="preserve">
          <source>To decode the string, use the &lt;code&gt;uri_unescape&lt;/code&gt; function:</source>
          <target state="translated">要解码字符串，请使用 &lt;code&gt;uri_unescape&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="c00b1b3082eeba042c1321adab39b3572b77ab5f" translate="yes" xml:space="preserve">
          <source>To define a new encoding, use:</source>
          <target state="translated">要定义一个新的编码,使用。</target>
        </trans-unit>
        <trans-unit id="90539d229e0f3e1882d607e70d036357967dd42b" translate="yes" xml:space="preserve">
          <source>To define an anonymous subroutine at runtime:</source>
          <target state="translated">在运行时定义一个匿名子程序。</target>
        </trans-unit>
        <trans-unit id="c9cdf944c5644c128ca4890eae1d815775404ea8" translate="yes" xml:space="preserve">
          <source>To define your own variables, simply add them to the hash, or change existing values if you need to. The level and format are passed in as references to scalars, but it is unlikely that they will need to be changed or even used.</source>
          <target state="translated">要定义你自己的变量,只需将它们添加到哈希中,或者在需要时改变现有的值。级别和格式是作为对标量的引用传递进来的,但不太可能需要改变甚至使用它们。</target>
        </trans-unit>
        <trans-unit id="663c37fcccd4eb9d16f3753290874adfe0a38adc" translate="yes" xml:space="preserve">
          <source>To delete a filter pass &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to it.</source>
          <target state="translated">要删除过滤器，请将 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 传递给它。</target>
        </trans-unit>
        <trans-unit id="a7282a69c7ceaa80a01f9176cf957edc11cea4de" translate="yes" xml:space="preserve">
          <source>To delete lines, only print the ones that you want.</source>
          <target state="translated">要删除行,只打印你想要的行。</target>
        </trans-unit>
        <trans-unit id="c1469f4d29b40fb0b7ab86c2c4e92578f7c6eb9f" translate="yes" xml:space="preserve">
          <source>To determine at runtime if this capability has been compiled in your perl, you can check the value of &lt;code&gt;$Config{usesitecustomize}&lt;/code&gt; .</source>
          <target state="translated">要在运行时确定此功能是否已在perl中进行编译，可以检查 &lt;code&gt;$Config{usesitecustomize}&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="5ce033ec9e41969bd8c16961760514dcb521d365" translate="yes" xml:space="preserve">
          <source>To determine if a module came with your version of Perl, you can install and use the &lt;a href=&quot;module/corelist&quot;&gt;Module::CoreList&lt;/a&gt; module. It has the information about the modules (with their versions) included with each release of Perl.</source>
          <target state="translated">要确定Perl版本是否随附模块，可以安装并使用&lt;a href=&quot;module/corelist&quot;&gt;Module :: CoreList&lt;/a&gt;模块。它具有有关每个Perl版本中包含的模块（及其版本）的信息。</target>
        </trans-unit>
        <trans-unit id="a3640814314afd9f7ac9d11a68cf889d6f47fec5" translate="yes" xml:space="preserve">
          <source>To determine if a string is in Unicode, use:</source>
          <target state="translated">要确定一个字符串是否为Unicode,使用:</target>
        </trans-unit>
        <trans-unit id="bca0ec2b6522f981d9c11831a03f1f68a8800f50" translate="yes" xml:space="preserve">
          <source>To determine if an SV is a reference, you can use the following macro:</source>
          <target state="translated">要确定一个SV是否是一个引用,可以使用以下宏。</target>
        </trans-unit>
        <trans-unit id="c9936c817f7d3f0a431d8c4cc266d4265437482c" translate="yes" xml:space="preserve">
          <source>To determine if you are running under ASCII or EBCDIC, you can use the return value of &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; to test one or more character values. For example:</source>
          <target state="translated">要确定您是在ASCII还是EBCDIC下运行，可以使用 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; 的返回值来测试一个或多个字符值。例如：</target>
        </trans-unit>
        <trans-unit id="86e75dff4a5cb692b3db4e186257a30b993c598a" translate="yes" xml:space="preserve">
          <source>To determine whether or not perl was built under an EBCDIC code page you can use the Config module like so:</source>
          <target state="translated">要确定perl是否是在EBCDIC代码页下构建的,你可以使用Config模块,比如这样。</target>
        </trans-unit>
        <trans-unit id="c7ca989a561cc6bb21cb242f3f9a4867fcc2a0a2" translate="yes" xml:space="preserve">
          <source>To determine which category a specific warning has been assigned to see &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;.</source>
          <target state="translated">要确定为哪个类别指定了特定警告，请参阅&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2650be423c3da22a5978107c38e624c70d0e420" translate="yes" xml:space="preserve">
          <source>To die with a simple string message, the &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt; function may be more convenient.</source>
          <target state="translated">为了用简单的字符串消息消亡，&lt;a href=&quot;#croak&quot;&gt;吱吱作响的&lt;/a&gt;功能可能会更方便。</target>
        </trans-unit>
        <trans-unit id="347758299b3b52a08c513c37128e636634230c65" translate="yes" xml:space="preserve">
          <source>To disable prototypes:</source>
          <target state="translated">要禁用原型。</target>
        </trans-unit>
        <trans-unit id="5d0844b4d1a693267fe5fcf752c200ff27d0a20a" translate="yes" xml:space="preserve">
          <source>To disable scoping:</source>
          <target state="translated">要禁用范围化。</target>
        </trans-unit>
        <trans-unit id="6a2e4cf0ee9b26b39ec068b4b4c9bcaa2ebda9e0" translate="yes" xml:space="preserve">
          <source>To disable this check, set this variable to &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">要禁用此检查，请将此变量设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b80cbb6c9445e33c66e64e8bbc664c2dc7cb143d" translate="yes" xml:space="preserve">
          <source>To disable this default safe mode, set these values to something higher than 0. At a level of 1, you get backtraces upon receiving any kind of warning (this is often annoying) or exception (this is often valuable). Unfortunately, the debugger cannot discern fatal exceptions from non-fatal ones. If &lt;code&gt;dieLevel&lt;/code&gt; is even 1, then your non-fatal exceptions are also traced and unceremoniously altered if they came from &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval'ed&lt;/a&gt;&lt;/code&gt; strings or from any kind of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; within modules you're attempting to load. If &lt;code&gt;dieLevel&lt;/code&gt; is 2, the debugger doesn't care where they came from: It usurps your exception handler and prints out a trace, then modifies all exceptions with its own embellishments. This may perhaps be useful for some tracing purposes, but tends to hopelessly destroy any program that takes its exception handling seriously.</source>
          <target state="translated">要禁用此默认安全模式，请将这些值设置为大于0的值。级别为1时，在收到任何类型的警告（这通常很烦人）或异常（这通常很有价值）时会得到回溯。不幸的是，调试器无法区分致命错误和非致命错误。如果 &lt;code&gt;dieLevel&lt;/code&gt; 甚至为1，那么非致命异常也将被跟踪，并且如果它们来自 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval'ed&lt;/a&gt;&lt;/code&gt; 字符串或尝试加载的模块中的任何类型的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，则可以毫不客气地对其进行更改。如果 &lt;code&gt;dieLevel&lt;/code&gt; 为2时，调试器不在乎它们来自何处：它会篡改异常处理程序并打印出跟踪，然后使用自己的修饰来修改所有异常。这可能对于某些跟踪目的很有用，但往往无可救药地破坏认真对待其异常处理的任何程序。</target>
        </trans-unit>
        <trans-unit id="8d156c08336acd4fd9a2800ec24f479a8112dea4" translate="yes" xml:space="preserve">
          <source>To disable version checking:</source>
          <target state="translated">要禁用版本检查。</target>
        </trans-unit>
        <trans-unit id="738a71c259ac0a8afb90292476b05521cb3a2b41" translate="yes" xml:space="preserve">
          <source>To disallow the use of, for example, &lt;code&gt;LWP&lt;/code&gt; and &lt;code&gt;Net::FTP&lt;/code&gt; , you could set $File::Fetch::BLACKLIST to:</source>
          <target state="translated">要禁止使用例如 &lt;code&gt;LWP&lt;/code&gt; 和 &lt;code&gt;Net::FTP&lt;/code&gt; ，可以将$ File :: Fetch :: BLACKLIST设置为：</target>
        </trans-unit>
        <trans-unit id="80dd5fada40953f3424fd8a183a453e068557bb1" translate="yes" xml:space="preserve">
          <source>To discover what type of value the reference refers to, use the following macro and then check the return value.</source>
          <target state="translated">要发现引用指的是什么类型的值,使用以下宏,然后检查返回值。</target>
        </trans-unit>
        <trans-unit id="8fc94d5f52eb1139b287df828008badfb6c3e089" translate="yes" xml:space="preserve">
          <source>To display and change the libnet configuration run the libnetcfg command.</source>
          <target state="translated">要显示和更改libnet配置,请运行libnetcfg命令。</target>
        </trans-unit>
        <trans-unit id="60ed656a96349b78cdba5a83471f5324d8dd1e87" translate="yes" xml:space="preserve">
          <source>To display the results you use the</source>
          <target state="translated">要显示结果,您可以使用</target>
        </trans-unit>
        <trans-unit id="ad781551179d37e74d6f0377992b51ea7bdaace0" translate="yes" xml:space="preserve">
          <source>To do it correctly, you can use one of the &lt;code&gt;Date&lt;/code&gt; modules since they work with calendars instead of times. The &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module makes it simple, and give you the same time of day, only the day before, despite daylight saving time changes:</source>
          <target state="translated">要正确执行此操作，可以使用&amp;ldquo; &lt;code&gt;Date&lt;/code&gt; 模块之一，因为它们使用日历而不是时间。该&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;日期时间&lt;/a&gt;模块使得它简单，给你一天的同一时间，只有前一天，尽管夏令时更改：</target>
        </trans-unit>
        <trans-unit id="f1d6265a7b40372fb699b2b2f27a1df7b8f80a66" translate="yes" xml:space="preserve">
          <source>To do the equivalent of &lt;code&gt;cp -R&lt;/code&gt; (i.e. copy an entire directory tree recursively) in portable Perl, you'll either need to write something yourself or find a good CPAN module such as &lt;a href=&quot;http://search.cpan.org/perldoc/File::Copy::Recursive&quot;&gt;File::Copy::Recursive&lt;/a&gt;.</source>
          <target state="translated">要在便携式Perl中执行 &lt;code&gt;cp -R&lt;/code&gt; 的等效功能（即以递归方式复制整个目录树），您需要自己编写一些内容或找到一个好的CPAN模块，例如&lt;a href=&quot;http://search.cpan.org/perldoc/File::Copy::Recursive&quot;&gt;File :: Copy :: Recursive&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="800198c8e77892b2ea37f8a62c33fb5be9843971" translate="yes" xml:space="preserve">
          <source>To do this we need to produce a program by parsing the text. We then need to execute the program to find the point in the string that matches. And we need to do the whole thing efficiently.</source>
          <target state="translated">要做到这一点,我们需要通过解析文本来制作一个程序。然后我们需要执行程序,在字符串中找到匹配的点。而且我们需要高效地完成整个过程。</target>
        </trans-unit>
        <trans-unit id="b3b368d6bf057c7196323316138f2bb623cf857e" translate="yes" xml:space="preserve">
          <source>To do this you need to store a copy of the object returned from the tie.</source>
          <target state="translated">要做到这一点,你需要存储一个从领带返回的对象的副本。</target>
        </trans-unit>
        <trans-unit id="16944f02408f01608a70adc6c00bddd6a6f21c5d" translate="yes" xml:space="preserve">
          <source>To do this, declare the XSUB as</source>
          <target state="translated">要做到这一点,请将XSUB声明为</target>
        </trans-unit>
        <trans-unit id="9ba25feb906f9144f135e56832aaff07eb5da168" translate="yes" xml:space="preserve">
          <source>To do this, simple invoke the redispatch as:</source>
          <target state="translated">要做到这一点,只需调用重新调度为。</target>
        </trans-unit>
        <trans-unit id="2b963497fc0bd80a2ad6cd72e920bb19d3acf535" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Formatter&quot;&gt;TAP::Formatter&lt;/a&gt;, or write your own. Writing formatters are a bit more involved than writing a</source>
          <target state="translated">为此，您可以扩展现有的&lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Formatter&quot;&gt;TAP :: Formatter&lt;/a&gt;，也可以编写自己的文件。编写格式化程序比编写一个格式化程序要复杂得多。</target>
        </trans-unit>
        <trans-unit id="4d922248445626035fad600ec3b500e3d07eeccb" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, or write your own. It's a pretty simple API, and they can be loaded and configured using the &lt;code&gt;sources&lt;/code&gt; parameter to &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">为此，您可以扩展现有的&lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;，也可以编写自己的。这是一个非常简单的API，可以使用 &lt;code&gt;sources&lt;/code&gt; 参数将它们加载和配置为&lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9af8e6fc2b2d44ed39a720480b5eca952598206" translate="yes" xml:space="preserve">
          <source>To do this, you have to parse out each word in the input stream. We'll pretend that by word you mean chunk of alphabetics, hyphens, or apostrophes, rather than the non-whitespace chunk idea of a word given in the previous question:</source>
          <target state="translated">要做到这一点,你必须解析出输入流中的每个单词。我们假设你所说的单词是指字母、连字符或省略号的块,而不是上一个问题中给出的非空白块的单词概念。</target>
        </trans-unit>
        <trans-unit id="a594dc0644909bfef7173f1f8eb29922809128db" translate="yes" xml:space="preserve">
          <source>To do what you meant properly, you must write:</source>
          <target state="translated">要想做好自己的意思,必须要写。</target>
        </trans-unit>
        <trans-unit id="d3e2fbf11b8c81738d92b26c858673a8798bed9d" translate="yes" xml:space="preserve">
          <source>To emphasize that you are operating only on ASCII characters, you can append &lt;code&gt;_A&lt;/code&gt; to each of the macros in the ASCII column: &lt;code&gt;isALPHA_A&lt;/code&gt; , &lt;code&gt;isDIGIT_A&lt;/code&gt; , and so on.</source>
          <target state="translated">为了强调您仅对ASCII字符进行操作，可以将 &lt;code&gt;_A&lt;/code&gt; 附加到ASCII列中的每个宏： &lt;code&gt;isALPHA_A&lt;/code&gt; ， &lt;code&gt;isDIGIT_A&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="e2f50143516f5760cd1414be18dcb711d9b307dd" translate="yes" xml:space="preserve">
          <source>To enable colouring from the command line, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Builder::Tester::Color&quot;&gt;Text::Builder::Tester::Color&lt;/a&gt; module like so:</source>
          <target state="translated">要从命令行启用着色，可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Builder::Tester::Color&quot;&gt;Text :: Builder :: Tester :: Color&lt;/a&gt;模块，如下所示：</target>
        </trans-unit>
        <trans-unit id="b01967f773567b844b2b023b2a86bde4df70fc34" translate="yes" xml:space="preserve">
          <source>To enable prototypes:</source>
          <target state="translated">要启用原型。</target>
        </trans-unit>
        <trans-unit id="5ccde66aca7ada9c8fed76ada1d4a0446a4f8743" translate="yes" xml:space="preserve">
          <source>To enable scoping:</source>
          <target state="translated">要启用范围界定:</target>
        </trans-unit>
        <trans-unit id="1484f429016f98a746a3ab26c198f24bb67adaaa" translate="yes" xml:space="preserve">
          <source>To enable version checking:</source>
          <target state="translated">要启用版本检查。</target>
        </trans-unit>
        <trans-unit id="270b403e8cadfb40d1d97c0de3bf7642f9c98fb6" translate="yes" xml:space="preserve">
          <source>To encode a string yourself, use the &lt;a href=&quot;http://search.cpan.org/perldoc/URI::Escape&quot;&gt;URI::Escape&lt;/a&gt; module. The &lt;code&gt;uri_escape&lt;/code&gt; function returns the escaped string:</source>
          <target state="translated">要自己编码字符串，请使用&lt;a href=&quot;http://search.cpan.org/perldoc/URI::Escape&quot;&gt;URI :: Escape&lt;/a&gt;模块。该 &lt;code&gt;uri_escape&lt;/code&gt; 函数返回的转义字符串：</target>
        </trans-unit>
        <trans-unit id="197383dea9cb9c2b7e4139f047ab7802bc1168de" translate="yes" xml:space="preserve">
          <source>To end a Pod block, use a blank line, then a line beginning with &quot;=cut&quot;, and a blank line after it. This lets Perl (and the Pod formatter) know that this is where Perl code is resuming. (The blank line before the &quot;=cut&quot; is not technically necessary, but many older Pod processors require it.)</source>
          <target state="translated">要结束一个Pod块,先用空行,然后用&quot;=cut &quot;开头的行,再在它后面用空行。这可以让Perl(和Pod格式化器)知道这是Perl代码恢复的地方。(&quot;=cut &quot;前的空行在技术上并不是必须的,但许多旧的 Pod 处理器要求这样做。)</target>
        </trans-unit>
        <trans-unit id="0ae4a1a4ec134ed8922ee208a028b2c3245ebe13" translate="yes" xml:space="preserve">
          <source>To enforce scalar context in this particular case, however, you need merely omit the parentheses:</source>
          <target state="translated">然而,要在这种特殊情况下执行标量上下文,你只需要省略括号。</target>
        </trans-unit>
        <trans-unit id="5528aa31607b22ee5ba7b25dc9ad20fd957a80a3" translate="yes" xml:space="preserve">
          <source>To ensure your Perl programs can see these newly installed modules, set your &lt;code&gt;PERL5LIB&lt;/code&gt; environment variable to</source>
          <target state="translated">为确保您的Perl程序可以看到这些新安装的模块，请将您的 &lt;code&gt;PERL5LIB&lt;/code&gt; 环境变量设置为</target>
        </trans-unit>
        <trans-unit id="7aa8a6d9b5359d93562881107c4eb01ac8b79421" translate="yes" xml:space="preserve">
          <source>To escape the special meaning of &lt;code&gt;.&lt;/code&gt;, we use &lt;code&gt;\Q&lt;/code&gt; :</source>
          <target state="translated">逃避...的特殊含义 &lt;code&gt;.&lt;/code&gt; ，我们使用 &lt;code&gt;\Q&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1f8b13457bc503e2905034bca18967c492e5be31" translate="yes" xml:space="preserve">
          <source>To exchange a command's STDOUT and STDERR in order to capture the STDERR but leave its STDOUT to come out our old STDERR:</source>
          <target state="translated">要交换一个命令的STDOUT和STDERR,以便捕获STDERR,但留下它的STDOUT,出来我们的旧STDERR。</target>
        </trans-unit>
        <trans-unit id="f19cbea3f43d914ef5dccac2f20ddb20b0a670bb" translate="yes" xml:space="preserve">
          <source>To exchange a command's STDOUT and STDERR in order to capture the STDERR but leave its STDOUT to come out the old STDERR:</source>
          <target state="translated">要交换一个命令的STDOUT和STDERR,以便捕获STDERR,但留下它的STDOUT,出来的是旧的STDERR。</target>
        </trans-unit>
        <trans-unit id="1e299ba0ecd4337d918ed97321e55b553fe7e0a0" translate="yes" xml:space="preserve">
          <source>To exercise the various implementations the script &lt;a href=&quot;#Example-2&quot;&gt;below&lt;/a&gt; can be used.</source>
          <target state="translated">为了执行各种实现，可以使用&lt;a href=&quot;#Example-2&quot;&gt;以下&lt;/a&gt;脚本。</target>
        </trans-unit>
        <trans-unit id="746a283f2992b56a8070a48ac33ef2cb2b8ab7fb" translate="yes" xml:space="preserve">
          <source>To explain them each in detail:</source>
          <target state="translated">要详细解释它们各自。</target>
        </trans-unit>
        <trans-unit id="337ab3fc6e23ee2083bb48006f6530a512cb7265" translate="yes" xml:space="preserve">
          <source>To explicitly turn off a &quot;FATAL&quot; warning you just disable the warning it is associated with. So, for example, to disable the &quot;void&quot; warning in the example above, either of these will do the trick:</source>
          <target state="translated">要明确关闭一个 &quot;FATAL &quot;警告,你只需禁用与之相关的警告。所以,例如,要禁用上面例子中的 &quot;void &quot;警告,这两种方法都可以。</target>
        </trans-unit>
        <trans-unit id="d8cfaf574ce10955d44800ed1fb485165bb12d03" translate="yes" xml:space="preserve">
          <source>To extract a comma-delimited list of numbers, use</source>
          <target state="translated">要提取一个以逗号分隔的数字列表,使用</target>
        </trans-unit>
        <trans-unit id="d086f02213d0494d6662b67a4783c59065f8a170" translate="yes" xml:space="preserve">
          <source>To extract an ASCII tar archive on BS2000 POSIX you need an ASCII filesystem (we used the mountpoint /usr/local/ascii for this). Now you extract the archive in the ASCII filesystem without I/O-conversion:</source>
          <target state="translated">要在BS2000 POSIX上解压ASCII压缩包,你需要一个ASCII文件系统(我们使用挂载点/usr/local/ascii)。现在你可以在ASCII文件系统中解压压缩包,而不需要进行I/O转换。</target>
        </trans-unit>
        <trans-unit id="c062b7c2a495ae2a5b72a1379e8b1a41239ea1d2" translate="yes" xml:space="preserve">
          <source>To find how to use this module in detail, see &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">要详细了解如何使用此模块，请参见&lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3930f92a272e8f2e02166feb6d52740dba8a2a7" translate="yes" xml:space="preserve">
          <source>To find out</source>
          <target state="translated">要了解</target>
        </trans-unit>
        <trans-unit id="8b9ad1d9bf5e88e70343c9bc73bc8f95e823175e" translate="yes" xml:space="preserve">
          <source>To find out how to use this module in detail, see &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">要详细了解如何使用此模块，请参见&lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8814e60c44afe937889a748a7dc5d647bd329617" translate="yes" xml:space="preserve">
          <source>To find out in detail which encodings are supported by this package, see &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt;.</source>
          <target state="translated">要详细了解此程序包支持哪些编码，请参见&lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7957585a16fb8e9f58abff4512426bfd62b9e660" translate="yes" xml:space="preserve">
          <source>To find out where a module's source code is located, use</source>
          <target state="translated">要知道一个模块的源代码在哪里,使用</target>
        </trans-unit>
        <trans-unit id="714fa5ade47f6c038c4e5047b338fbf758e5ccc9" translate="yes" xml:space="preserve">
          <source>To find out whether a given string is a valid non-zero number, it's sometimes enough to test it against both numeric 0 and also lexical &quot;0&quot; (although this will cause noises if warnings are on). That's because strings that aren't numbers count as 0, just as they do in &lt;b&gt;awk&lt;/b&gt;:</source>
          <target state="translated">要找出给定的字符串是否为有效的非零数字，有时足以将其与数字0以及词法&amp;ldquo; 0&amp;rdquo;进行比较（尽管如果打开警告会引起噪音）。这是因为非数字的字符串像&lt;b&gt;awk&lt;/b&gt;一样被计为0 ：</target>
        </trans-unit>
        <trans-unit id="b365160bfd575c380666252714a7e2191298f003" translate="yes" xml:space="preserve">
          <source>To find out which character encodings your Perl supports, run:</source>
          <target state="translated">要了解你的Perl支持哪些字符编码,请运行。</target>
        </trans-unit>
        <trans-unit id="8d0d1d4b42258f044bb86db954a57628e8eecd09" translate="yes" xml:space="preserve">
          <source>To find something between two single characters, a pattern like &lt;code&gt;/x([^x]*)x/&lt;/code&gt; will get the intervening bits in $1. For multiple ones, then something more like &lt;code&gt;/alpha(.*?)omega/&lt;/code&gt; would be needed. For nested patterns and/or balanced expressions, see the so-called &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(?PARNO)&lt;/a&gt; construct (available since perl 5.10). The CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; can help to build such regular expressions (see in particular &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::balanced&quot;&gt;Regexp::Common::balanced&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::delimited&quot;&gt;Regexp::Common::delimited&lt;/a&gt;).</source>
          <target state="translated">要在两个单个字符之间查找内容，类似 &lt;code&gt;/x([^x]*)x/&lt;/code&gt; 将获得$ 1中的中间位。对于多个，则需要类似 &lt;code&gt;/alpha(.*?)omega/&lt;/code&gt; 的东西。有关嵌套模式和/或平衡表达式，请参见所谓的&lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;（？PARNO）&lt;/a&gt;构造（自perl 5.10起可用）。 CPAN模块&lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt;可以帮助构建这样的正则表达式（尤其请参见&lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::balanced&quot;&gt;Regexp :: Common :: balanced&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::delimited&quot;&gt;Regexp :: Common :: delimited&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c8886406693c43465a74828d32fde569bd987324" translate="yes" xml:space="preserve">
          <source>To find the first array element which satisfies a condition, you can use the &lt;code&gt;first()&lt;/code&gt; function in the &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; module, which comes with Perl 5.8. This example finds the first element that contains &quot;Perl&quot;.</source>
          <target state="translated">要查找满足条件的第一个数组元素，可以使用Perl 5.8附带的&lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt;模块中的 &lt;code&gt;first()&lt;/code&gt; 函数。本示例查找包含&amp;ldquo; Perl&amp;rdquo;的第一个元素。</target>
        </trans-unit>
        <trans-unit id="f1ca27f7c9ffaf0873146b4d5569bf1f7dd85f24" translate="yes" xml:space="preserve">
          <source>To find the package you are currently in, use the special literal &lt;code&gt;__PACKAGE__&lt;/code&gt; , as documented in &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;. You can only use the special literals as separate tokens, so you can't interpolate them into strings like you can with variables:</source>
          <target state="translated">寻找你目前在包装，使用特殊的文本 &lt;code&gt;__PACKAGE__&lt;/code&gt; ，如记录&lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;。您只能将特殊文字用作单独的标记，因此无法像使用变量那样将它们插入到字符串中：</target>
        </trans-unit>
        <trans-unit id="cffcf6d33c52e5caff06e5888e1b1afff8c79cd9" translate="yes" xml:space="preserve">
          <source>To find the synonyms for single-forms, such as &lt;code&gt;\p{Any}&lt;/code&gt; , use &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt; instead.</source>
          <target state="translated">要查找单形式的同义词，例如 &lt;code&gt;\p{Any}&lt;/code&gt; ，请使用&lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases（）&lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="2b4474f5909a02cbe785465728ea131216f023c4" translate="yes" xml:space="preserve">
          <source>To find your local Perl Mongers (or PM as they're commonly abbreviated) group check the international Perl Mongers directory at &lt;a href=&quot;http://www.pm.org/&quot;&gt;http://www.pm.org/&lt;/a&gt;.</source>
          <target state="translated">要查找本地的Perl Mongers（或通常缩写为PM）组，请&lt;a href=&quot;http://www.pm.org/&quot;&gt;访问&lt;/a&gt;位于http://www.pm.org/的国际Perl Mongers目录。</target>
        </trans-unit>
        <trans-unit id="51fa9c8218dc025937f10203b9150ec3a3d4872c" translate="yes" xml:space="preserve">
          <source>To fire up the debugger, type</source>
          <target state="translated">要启动调试器,键入</target>
        </trans-unit>
        <trans-unit id="5061c6729e5e674eb297e87fb65b6e686195258a" translate="yes" xml:space="preserve">
          <source>To fix by applying one, as it were. In the realm of hackerdom, a listing of the differences between two versions of a program as might be applied by the &lt;b&gt;patch&lt;/b&gt;(1) program when you want to fix a bug or upgrade your old version.</source>
          <target state="translated">通过应用一个来修复。在黑客领域，列出了程序的两个版本之间的差异，当您要修复错误或升级旧版本时，&lt;b&gt;修补程序&lt;/b&gt;（1）可能会应用这两个版本之间的差异。</target>
        </trans-unit>
        <trans-unit id="baa8da9e4b55dce6e5a8c524e072f785277c31e7" translate="yes" xml:space="preserve">
          <source>To fix this, some people formed Unicode, Inc. and produced a new character set containing all the characters you can possibly think of and more. There are several ways of representing these characters, and the one Perl uses is called UTF-8. UTF-8 uses a variable number of bytes to represent a character. You can learn more about Unicode and Perl's Unicode model in &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">为了解决这个问题，一些人成立了Unicode，Inc.并产生了一个新的字符集，其中包含您可能想到的所有字符以及更多其他字符。有几种表示这些字符的方法，Perl使用的一种称为UTF-8。UTF-8使用可变数量的字节来表示字符。您可以在&lt;a href=&quot;perlunicode&quot;&gt;perlunicode中&lt;/a&gt;了解有关Unicode和Perl的Unicode模型的更多信息。</target>
        </trans-unit>
        <trans-unit id="a4f76f5a03185d9e714674242e64dfcf1b7f20c4" translate="yes" xml:space="preserve">
          <source>To forbid ASCII/non-ASCII matches (like &quot;k&quot; with &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; ), specify the &quot;a&quot; twice, for example &lt;code&gt;/aai&lt;/code&gt; or &lt;code&gt;/aia&lt;/code&gt; . (The first occurrence of &quot;a&quot; restricts the &lt;code&gt;\d&lt;/code&gt; , etc., and the second occurrence adds the &lt;code&gt;/i&lt;/code&gt; restrictions.) But, note that code points outside the ASCII range will use Unicode rules for &lt;code&gt;/i&lt;/code&gt; matching, so the modifier doesn't really restrict things to just ASCII; it just forbids the intermixing of ASCII and non-ASCII.</source>
          <target state="translated">要禁止ASCII /非ASCII匹配（如带有 &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; &amp;ldquo; k&amp;rdquo; ），请两次指定&amp;ldquo; a&amp;rdquo;，例如 &lt;code&gt;/aai&lt;/code&gt; 或 &lt;code&gt;/aia&lt;/code&gt; 。 （第一次出现的&amp;ldquo; a&amp;rdquo;会限制 &lt;code&gt;\d&lt;/code&gt; 等，第二次出现的会添加 &lt;code&gt;/i&lt;/code&gt; 限制。）但是，请注意，ASCII范围之外的代码点将使用Unicode规则进行 &lt;code&gt;/i&lt;/code&gt; 匹配，因此修饰符不会并没有真正将事情限制为仅ASCII；它只是禁止将ASCII与非ASCII混合使用。</target>
        </trans-unit>
        <trans-unit id="bc2a4c58af25cd402ee36a19ab3abed7cc44071e" translate="yes" xml:space="preserve">
          <source>To force interpretation as a subroutine call, either put an ampersand before the subroutine name, or qualify the name with its package. Alternatively, you can import the subroutine (or pretend that it's imported with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; pragma).</source>
          <target state="translated">要强制将其解释为子例程调用，请在子例程名称前加上&amp;ldquo;＆&amp;rdquo;号，或使用其包对名称进行限定。或者，您可以导入子例程（或假装 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; pragma 导入）。</target>
        </trans-unit>
        <trans-unit id="457433c503b0c64ab575af65985486ef91bd670a" translate="yes" xml:space="preserve">
          <source>To force multiple data values into an SV, you must do two things: use the &lt;code&gt;sv_set*v&lt;/code&gt; routines to add the additional scalar type, then set a flag so that Perl will believe it contains more than one type of data. The four macros to set the flags are:</source>
          <target state="translated">要将多个数据值强制输入到SV中，您必须做两件事：使用 &lt;code&gt;sv_set*v&lt;/code&gt; 例程添加其他标量类型，然后设置一个标志，以使Perl认为它包含不止一种数据类型。设置标志的四个宏是：</target>
        </trans-unit>
        <trans-unit id="e794c449edc7f65a40ec8153981b15f3f2a9b550" translate="yes" xml:space="preserve">
          <source>To free an SV that you've created, call &lt;code&gt;SvREFCNT_dec(SV*)&lt;/code&gt; . Normally this call is not necessary (see &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;Reference Counts and Mortality&lt;/a&gt;).</source>
          <target state="translated">要释放已创建的SV，请调用 &lt;code&gt;SvREFCNT_dec(SV*)&lt;/code&gt; 。通常，此调用不是必需的（请参阅&lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;参考计数和死亡率&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2d1737256e6e8a51ce74a94d85a078c8dd0ab640" translate="yes" xml:space="preserve">
          <source>To gain access to symbols that are exported from another module. See &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">获得对从另一个模块导出的符号的访问权限。请参阅 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 骆驼第27章，&amp;ldquo;功能&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="dcb6076af26c9d87b4c92a15d546b5cbbac01e84" translate="yes" xml:space="preserve">
          <source>To generate just the stubs:</source>
          <target state="translated">要只生成存根。</target>
        </trans-unit>
        <trans-unit id="535754fb5bff8ed1b444cf7b15654e6f3c7d7a5c" translate="yes" xml:space="preserve">
          <source>To get a Math::BigFloat you either need to call the operation manually, make sure the operands are already of the proper type or casted to that type via Math::BigFloat-&amp;gt;new():</source>
          <target state="translated">要获取Math :: BigFloat，您需要手动调用操作，请确保操作数已经是正确的类型，或者通过Math :: BigFloat-&amp;gt; new（）强制转换为该类型：</target>
        </trans-unit>
        <trans-unit id="482a14b92894717900240dda3533f7f04de8b428" translate="yes" xml:space="preserve">
          <source>To get a binary stream an alternate method is to use:</source>
          <target state="translated">为了得到二进制流,可以使用另一种方法。</target>
        </trans-unit>
        <trans-unit id="342926328b3f4e6b863f62ddbfc63ea7184c5807" translate="yes" xml:space="preserve">
          <source>To get a full list of the available sync points:</source>
          <target state="translated">要获得可用同步点的完整列表。</target>
        </trans-unit>
        <trans-unit id="4a7e3e5cefb00444495078948120515244d3f977" translate="yes" xml:space="preserve">
          <source>To get a random number between two values, you can use the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; built-in to get a random number between 0 and 1. From there, you shift that into the range that you want.</source>
          <target state="translated">要获得两个值之间的随机数，可以使用内置的 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 获得0到1之间的随机数。从那里，将其移动到所需的范围内。</target>
        </trans-unit>
        <trans-unit id="503a91db6b0ee3a6aaf3799cd04cbf8c2160ee5a" translate="yes" xml:space="preserve">
          <source>To get a real at or caret into the field, do this:</source>
          <target state="translated">要想真正进入这个领域,请这样做。</target>
        </trans-unit>
        <trans-unit id="6546b16387b88ec0ca99336cb1d0e013e452d98c" translate="yes" xml:space="preserve">
          <source>To get all the output from your error log, and not miss any messages via helpful operating system buffering, insert a line like this, at the start of your script:</source>
          <target state="translated">要想从错误日志中获取所有的输出,并通过有用的操作系统缓冲来不错过任何消息,在脚本的开头插入这样一行。</target>
        </trans-unit>
        <trans-unit id="2baf587b399a3c62f41dfcb4f6a76fcf67a09c4b" translate="yes" xml:space="preserve">
          <source>To get an &lt;code&gt;HMQ&lt;/code&gt; , the extension should call &lt;code&gt;hmq = perl_hmq_GET(serve)&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hmq&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hmq&lt;/code&gt; .</source>
          <target state="translated">为了得到一个 &lt;code&gt;HMQ&lt;/code&gt; ，扩展应调用 &lt;code&gt;hmq = perl_hmq_GET(serve)&lt;/code&gt; 中C.执行该呼叫之后， &lt;code&gt;hmq&lt;/code&gt; 可以作为被访问 &lt;code&gt;Perl_hmq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4fbf979e25bdf63e3a72510bfcc0bebacbf8c90" translate="yes" xml:space="preserve">
          <source>To get an unbuffered stream specify an unbuffered layer (e.g. &lt;code&gt;:unix&lt;/code&gt; ) in the open call:</source>
          <target state="translated">要获取未缓冲的流，请在open调用中指定一个未缓冲的层（例如 &lt;code&gt;:unix&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="4f25553ad923c6b2f304e605c8fcb2af6b398a17" translate="yes" xml:space="preserve">
          <source>To get around the error, place the word &lt;code&gt;DB_File&lt;/code&gt; in either single or double quotes, like this:</source>
          <target state="translated">要解决该错误，请将单词 &lt;code&gt;DB_File&lt;/code&gt; 放在单引号或双引号中，如下所示：</target>
        </trans-unit>
        <trans-unit id="e7cc39162825d124202c37827aea79596926f995" translate="yes" xml:space="preserve">
          <source>To get around the security problem, I could also pull the values from a hash instead of evaluating variable names. Using a single &lt;code&gt;/e&lt;/code&gt;, I can check the hash to ensure the value exists, and if it doesn't, I can replace the missing value with a marker, in this case &lt;code&gt;???&lt;/code&gt; to signal that I missed something:</source>
          <target state="translated">为了解决安全问题，我还可以从哈希中提取值，而不是评估变量名。使用单个 &lt;code&gt;/e&lt;/code&gt; ，我可以检查哈希值以确保该值存在，如果不存在，则可以用标记替换丢失的值，在这种情况下 &lt;code&gt;???&lt;/code&gt; 表示我错过了一些东西：</target>
        </trans-unit>
        <trans-unit id="7daccee0149b6b5c023c3105df2756ca16d7041c" translate="yes" xml:space="preserve">
          <source>To get around these problems it is necessary to take a full copy of the SV. The code below shows &lt;code&gt;SaveSub2&lt;/code&gt; modified to do that.</source>
          <target state="translated">要解决这些问题，必须获取SV的完整副本。下面的代码显示 &lt;code&gt;SaveSub2&lt;/code&gt; 已修改为执行此操作。</target>
        </trans-unit>
        <trans-unit id="e5e782973aff491dec9c851f1733c85508f6c14a" translate="yes" xml:space="preserve">
          <source>To get around this, either upgrade to Perl v5.6.0 or later, do the glob yourself with readdir() and patterns, or use a module like &lt;a href=&quot;file/glob&quot;&gt;File::Glob&lt;/a&gt;, one that doesn't use the shell to do globbing.</source>
          <target state="translated">要解决此问题，请升级到Perl v5.6.0或更高版本，使用readdir（）和pattern自己完成glob，或者使用&lt;a href=&quot;file/glob&quot;&gt;File :: Glob之&lt;/a&gt;类的模块，该模块不使用Shell进行globing。</target>
        </trans-unit>
        <trans-unit id="f6d7c7ba0c3680f1bdd16d6aa20e16ef63f21df2" translate="yes" xml:space="preserve">
          <source>To get around this, you have to unbuffer the output filehandle, in this case, &lt;code&gt;STDOUT&lt;/code&gt; . You can set the special variable &lt;code&gt;$|&lt;/code&gt; to a true value (mnemonic: making your filehandles &quot;piping hot&quot;):</source>
          <target state="translated">要解决此问题，您必须取消缓冲输出文件句柄（在本例中为 &lt;code&gt;STDOUT&lt;/code&gt; )。您可以设置特殊变量 &lt;code&gt;$|&lt;/code&gt; 到一个真实值（助记符：使文件句柄&amp;ldquo;变热&amp;rdquo;）：</target>
        </trans-unit>
        <trans-unit id="a6f34a68c60751e410691b9ae6ddd9f980469ba3" translate="yes" xml:space="preserve">
          <source>To get at hash elements:</source>
          <target state="translated">为了获得哈希元素。</target>
        </trans-unit>
        <trans-unit id="7f878bb059ecb8cc0e6a947e6d0564b810589ae6" translate="yes" xml:space="preserve">
          <source>To get even more recent perl depots for the whole range of HP-UX, visit H.Merijn Brand's site at &lt;a href=&quot;http://mirrors.develooper.com/hpux/#Perl&quot;&gt;http://mirrors.develooper.com/hpux/#Perl&lt;/a&gt;. Carefully read the notes to see if the available versions suit your needs.</source>
          <target state="translated">要获得有关整个HP-UX范围的更多Perl软件仓库，请访问H.Merijn Brand的站点，&lt;a href=&quot;http://mirrors.develooper.com/hpux/#Perl&quot;&gt;网址&lt;/a&gt;为http://mirrors.develooper.com/hpux/#Perl。仔细阅读说明，以查看可用版本是否符合您的需求。</target>
        </trans-unit>
        <trans-unit id="76a1d18d8c0d8e0ec36c61f2ab6bce082fca6308" translate="yes" xml:space="preserve">
          <source>To get finer test reports, call</source>
          <target state="translated">要获得更精细的测试报告,请致电</target>
        </trans-unit>
        <trans-unit id="93d274f25d53139f7087deba04a14a18e5484351" translate="yes" xml:space="preserve">
          <source>To get index entries on &lt;code&gt;STDERR&lt;/code&gt; , turn on the F register, as in:</source>
          <target state="translated">要在 &lt;code&gt;STDERR&lt;/code&gt; 上获取索引条目，请打开F寄存器，如下所示：</target>
        </trans-unit>
        <trans-unit id="8b6b89efcdec932089c6c9c0f91cf90b0d1e52b9" translate="yes" xml:space="preserve">
          <source>To get multiple values from an array:</source>
          <target state="translated">从一个数组中获取多个值。</target>
        </trans-unit>
        <trans-unit id="c67d46d6312179612215d6ef23eb3f6db1321700" translate="yes" xml:space="preserve">
          <source>To get platform independent controls, you can use &lt;code&gt;\N{...}&lt;/code&gt; .</source>
          <target state="translated">要获得独立于平台的控件，可以使用 &lt;code&gt;\N{...}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a965832b8b2f81c82888b8327d5081a21e8081aa" translate="yes" xml:space="preserve">
          <source>To get some interesting statistics, it is recommended that &lt;code&gt;randomize_urllist&lt;/code&gt; be set; this introduces some amount of randomness into the URL selection.</source>
          <target state="translated">为了获得一些有趣的统计数据，建议设置 &lt;code&gt;randomize_urllist&lt;/code&gt; 。这在URL选择中引入了一定程度的随机性。</target>
        </trans-unit>
        <trans-unit id="42f32ff5f8a54ed95afefa260a5241934e3c3cb8" translate="yes" xml:space="preserve">
          <source>To get somewhat similar but locale-dependent date strings, set up your locale environment variables appropriately (please see &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;) and try for example:</source>
          <target state="translated">要获得类似但与语言环境相关的日期字符串，请适当地设置您的语言环境环境变量（请参阅&lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;），然后尝试例如：</target>
        </trans-unit>
        <trans-unit id="ab2c259ec21b8fdc7591d4aa060782af6913d852" translate="yes" xml:space="preserve">
          <source>To get somewhat similar but locale-dependent date strings, set up your locale environment variables appropriately (please see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;) and try for example:</source>
          <target state="translated">要获得类似但与语言环境相关的日期字符串，请适当地设置您的语言环境环境变量（请参阅&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;），然后尝试例如：</target>
        </trans-unit>
        <trans-unit id="c33d002d66788db30ed6cc7efa61fd7b3021f5f2" translate="yes" xml:space="preserve">
          <source>To get the 25 traditional lowercase Greek letters, including both sigmas, you could use this instead:</source>
          <target state="translated">要得到25个繁体小写希腊字母,包括两个sigmas,你可以用这个代替。</target>
        </trans-unit>
        <trans-unit id="6e85259394ca22644c2c269f73c9d0468d9813a0" translate="yes" xml:space="preserve">
          <source>To get the HAB, the extension should call &lt;code&gt;hab = perl_hab_GET()&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hab&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hab&lt;/code&gt; . There is no need to release the HAB after it is used.</source>
          <target state="translated">为了得到HAB，扩展应调用 &lt;code&gt;hab = perl_hab_GET()&lt;/code&gt; 进行该呼叫之后在C.， &lt;code&gt;hab&lt;/code&gt; 可以作为被访问 &lt;code&gt;Perl_hab&lt;/code&gt; 。使用后无需释放HAB。</target>
        </trans-unit>
        <trans-unit id="35604b07a393cc3fdbf315f40abc25e64114d031" translate="yes" xml:space="preserve">
          <source>To get the IP address, you can use the &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname&lt;/a&gt;&lt;/code&gt; built-in function to turn the name into a number. To turn that number into the dotted octet form (a.b.c.d) that most people expect, use the &lt;code&gt;inet_ntoa&lt;/code&gt; function from the &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; module, which also comes with perl.</source>
          <target state="translated">要获取IP地址，可以使用内置的 &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname&lt;/a&gt;&lt;/code&gt; 函数将名称转换为数字。要将数字转换为大多数人期望的点分八 &lt;code&gt;inet_ntoa&lt;/code&gt; 形式（abcd），请使用&lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt;模块中的inet_ntoa函数，该模块也是perl附带的。</target>
        </trans-unit>
        <trans-unit id="aa0526e650783189d8454499d3396cf899e8f521" translate="yes" xml:space="preserve">
          <source>To get the day of year for any date, use &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;'s &lt;code&gt;mktime&lt;/code&gt; to get a time in epoch seconds for the argument to &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要获取任何日期的年份，请使用&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;的 &lt;code&gt;mktime&lt;/code&gt; 获取以纪元秒为单位的 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 时间。</target>
        </trans-unit>
        <trans-unit id="ffadb121be361a5885303dda8c46c6cf80b68bb1" translate="yes" xml:space="preserve">
          <source>To get the last two digits of the year (e.g., &quot;01&quot; in 2001) do:</source>
          <target state="translated">要得到年份的最后两位数字(例如,2001年的 &quot;01&quot;),可以这样做:</target>
        </trans-unit>
        <trans-unit id="22228c8d3b8e275582e9f34035469fcccc1c47a6" translate="yes" xml:space="preserve">
          <source>To get the script to work properly and silence the warning make sure there are no valid references to the tied object</source>
          <target state="translated">为了使脚本正常工作并使警告静默,请确保没有对绑定对象的有效引用。</target>
        </trans-unit>
        <trans-unit id="3d2c84cce621656fbbd6db23ecc45f9cb65b75f8" translate="yes" xml:space="preserve">
          <source>To get the stash pointer for a particular package, use the function:</source>
          <target state="translated">要获得特定包的储藏指针,使用函数。</target>
        </trans-unit>
        <trans-unit id="1496f65198c7ac994d7422ae9ced83ce54781e58" translate="yes" xml:space="preserve">
          <source>To get things going, note that GBARR/Scalar-List-Utils-1.18.tar.gz is compatible with ancient perls and that File::Temp is listed as a prerequisite but CPAN has reasonable workarounds if it is missing.</source>
          <target state="translated">要开始工作,请注意GBARR/Scalar-List-Utils-1.18.tar.gz与古老的perls兼容,File::Temp被列为先决条件,但如果缺少它,CPAN有合理的变通办法。</target>
        </trans-unit>
        <trans-unit id="0258f9df35378eac84877d3f62eff75269ae164c" translate="yes" xml:space="preserve">
          <source>To get valgrind and for more information see</source>
          <target state="translated">要获得valgrind和更多信息,请参见</target>
        </trans-unit>
        <trans-unit id="969efaa9efa953c87797414000140cc60d6a47f5" translate="yes" xml:space="preserve">
          <source>To go through all of the keys, use the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; function. This extracts all of the keys of the hash and gives them back to you as a list. You can then get the value through the particular key you're processing:</source>
          <target state="translated">要浏览所有按键，请使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 功能。这将提取哈希的所有键，并将它们作为列表返回给您。然后，您可以通过正在处理的特定键来获取值：</target>
        </trans-unit>
        <trans-unit id="da7117148549139674b757cf18ceb49ea4e3b714" translate="yes" xml:space="preserve">
          <source>To hack on the Perl guts, you'll need to read the following things:</source>
          <target state="translated">要黑掉Perl的内脏,你需要阅读以下内容。</target>
        </trans-unit>
        <trans-unit id="adcd3970934fc11a2c18b9c7c3e26524958accfd" translate="yes" xml:space="preserve">
          <source>To handle this situation, the PPCODE directive is used and the stack is extended using the macro:</source>
          <target state="translated">为了处理这种情况,使用PPCODE指令,并使用宏扩展栈。</target>
        </trans-unit>
        <trans-unit id="f2c53c3c3d7de6d2315fba06d0366c539cf64b63" translate="yes" xml:space="preserve">
          <source>To have everything installed in your home directory, do the following.</source>
          <target state="translated">要把所有的东西都安装在你的主目录中,请执行以下操作。</target>
        </trans-unit>
        <trans-unit id="ebc28ed79805f971814bf2f23886e1860e904a26" translate="yes" xml:space="preserve">
          <source>To help explain what &lt;code&gt;File::GlobMapper&lt;/code&gt; does, consider what code you would write if you wanted to rename all files in the current directory that ended in &lt;code&gt;.tar.gz&lt;/code&gt; to &lt;code&gt;.tgz&lt;/code&gt;. So say these files are in the current directory</source>
          <target state="translated">为了帮助解释 &lt;code&gt;File::GlobMapper&lt;/code&gt; 功能，请考虑如果要将当前目录中所有以 &lt;code&gt;.tar.gz&lt;/code&gt; 结尾的文件重命名为 &lt;code&gt;.tgz&lt;/code&gt; ，将编写什么代码。所以说这些文件在当前目录中</target>
        </trans-unit>
        <trans-unit id="2009b3db85976237ffec01f5a479f250593bd279" translate="yes" xml:space="preserve">
          <source>To help understand how to write a Perl source filter we need an example to study. Here is a complete source filter that performs rot13 decoding. (Rot13 is a very simple encryption scheme used in Usenet postings to hide the contents of offensive posts. It moves every letter forward thirteen places, so that A becomes N, B becomes O, and Z becomes M.)</source>
          <target state="translated">为了帮助理解如何编写Perl源过滤器,我们需要一个例子来研究。这里是一个完整的源码过滤器,它可以执行rot13解码。(Rot13是一个非常简单的加密方案,用于Usenet帖子中隐藏攻击性帖子的内容。它将每个字母向前移动13位,因此A变成了N,B变成了O,Z变成了M。)</target>
        </trans-unit>
        <trans-unit id="b67c3276fc328ee702718e80d3624e6e736f9072" translate="yes" xml:space="preserve">
          <source>To help understand why this can be a real problem first consider how a callback is set up in an all C environment. Typically a C API will provide a function to register a callback. This will expect a pointer to a function as one of its parameters. Below is a call to a hypothetical function &lt;code&gt;register_fatal&lt;/code&gt; which registers the C function to get called when a fatal error occurs.</source>
          <target state="translated">为了帮助理解为什么这可能是一个真正的问题，请首先考虑如何在全C环境中设置回调。通常，C API将提供注册回调的功能。这将期望指向函数的指针作为其参数之一。下面是对假设函数 &lt;code&gt;register_fatal&lt;/code&gt; 的调用，该函数注册 C函数以在发生致命错误时被调用。</target>
        </trans-unit>
        <trans-unit id="6caa11e5f28551bc8c9f71be4abd8c87215d7f26" translate="yes" xml:space="preserve">
          <source>To help you convert legacy programs to more modern Perl, the &lt;a href=&quot;pl2pm&quot;&gt;pl2pm&lt;/a&gt; utility will help you convert old-style Perl 4 libraries to new-style Perl5 modules.</source>
          <target state="translated">为了帮助您将遗留程序转换为更现代的Perl，&lt;a href=&quot;pl2pm&quot;&gt;pl2pm&lt;/a&gt;实用程序将帮助您将旧式Perl 4库转换为新式Perl5模块。</target>
        </trans-unit>
        <trans-unit id="c501d022d8a0fffa65c230084aad7354f866cab9" translate="yes" xml:space="preserve">
          <source>To help you figure out what was undefined, perl will try to tell you the name of the variable (if any) that was undefined. In some cases it cannot do this, so it also tells you what operation you used the undefined value in. Note, however, that perl optimizes your program and the operation displayed in the warning may not necessarily appear literally in your program. For example, &lt;code&gt;&quot;that $foo&quot;&lt;/code&gt; is usually optimized into &lt;code&gt;&quot;that &quot; . $foo&lt;/code&gt; , and the warning will refer to the &lt;code&gt;concatenation (.)&lt;/code&gt; operator, even though there is no &lt;code&gt;.&lt;/code&gt; in your program.</source>
          <target state="translated">为了帮助您弄清未定义的内容，perl会尝试告诉您未定义的变量的名称（如果有）。在某些情况下，它不能执行此操作，因此它还会告诉您使用了未定义值的操作。但是，请注意，perl会优化您的程序，警告中显示的操作不一定会在程序中字面上出现。例如，通常将 &lt;code&gt;&quot;that $foo&quot;&lt;/code&gt; 优化为 &lt;code&gt;&quot;that &quot; . $foo&lt;/code&gt; ，即使没有，警告也会引用 &lt;code&gt;concatenation (.)&lt;/code&gt; 运算符 &lt;code&gt;.&lt;/code&gt; 在您的程序中。</target>
        </trans-unit>
        <trans-unit id="77d1efff4e4ad59e580cc05099536ea5f027ae77" translate="yes" xml:space="preserve">
          <source>To hide the rough edges under the hood, provide a tie()d interface to the package &lt;code&gt;symbolic&lt;/code&gt; . Add methods</source>
          <target state="translated">要隐藏引擎盖下的粗糙边缘，请为 &lt;code&gt;symbolic&lt;/code&gt; 包提供tie（）d接口。新增方法</target>
        </trans-unit>
        <trans-unit id="bb09986ebdb919a3ce53d54257037e7652baac8f" translate="yes" xml:space="preserve">
          <source>To illustrate the differences between these variables, consider the following Perl expression, which uses a single-quoted string. After execution of this statement, perl may have set all four special error variables:</source>
          <target state="translated">为了说明这些变量之间的差异,请考虑以下Perl表达式,它使用的是单引号字符串。在执行这个语句后,perl可能已经设置了所有四个特殊的错误变量。</target>
        </trans-unit>
        <trans-unit id="f0157186b912ecd3453913b9ba18ef7c370be226" translate="yes" xml:space="preserve">
          <source>To illustrate this feature, we'll design a pattern that matches if a string contains a palindrome. (This is a word or a sentence that, while ignoring spaces, interpunctuation and case, reads the same backwards as forwards. We begin by observing that the empty string or a string containing just one word character is a palindrome. Otherwise it must have a word character up front and the same at its end, with another palindrome in between.</source>
          <target state="translated">为了说明这个特性,我们将设计一个模式,如果一个字符串中包含一个词缀,则进行匹配。(这是一个单词或句子,在忽略空格、标点符号和大小写的情况下,读起来和向前一样。我们首先观察到,空字符串或只包含一个单词字符的字符串是一个表音符。否则一定是前面有一个字符,后面也有一个字符,中间还有一个回文。</target>
        </trans-unit>
        <trans-unit id="983dc7293d2e1cce05648cd63638e4f7e22fc331" translate="yes" xml:space="preserve">
          <source>To illustrate unpacking for bit strings, we'll decompose a simple status register (a &quot;-&quot; stands for a &quot;reserved&quot; bit):</source>
          <target state="translated">为了说明对位串的解包,我们将分解一个简单的状态寄存器(&quot;-&quot;代表 &quot;保留 &quot;位)。</target>
        </trans-unit>
        <trans-unit id="0eeac6bf1837c3892fad2067238a40143aea5c3f" translate="yes" xml:space="preserve">
          <source>To illustrate,</source>
          <target state="translated">为了说明:</target>
        </trans-unit>
        <trans-unit id="3f180de5f2359e1c5045cf60151ad16271ecfbd0" translate="yes" xml:space="preserve">
          <source>To implement a copy constructor, add &lt;code&gt;'=' =&amp;gt; \&amp;amp;cpy&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; line, and code (this code assumes that mutators change things one level deep only, so recursive copying is not needed):</source>
          <target state="translated">要实现复制构造函数，请添加 &lt;code&gt;'=' =&amp;gt; \&amp;amp;cpy&lt;/code&gt; 以 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 行和代码（此代码假定mutator仅将内容更改为一级，因此不需要递归复制）：</target>
        </trans-unit>
        <trans-unit id="8240260917b1a03cdad7c5747565fe071f2719a2" translate="yes" xml:space="preserve">
          <source>To implement most arithmetic operations is easy; one should just use the tables of operations, and change the code which fills %subr to</source>
          <target state="translated">要实现大部分的算术运算很容易,只需利用运算表,将填充%subr的代码改成</target>
        </trans-unit>
        <trans-unit id="81c4d513cec75ad639c29820e8f6fc040826df1f" translate="yes" xml:space="preserve">
          <source>To import subroutines:</source>
          <target state="translated">要导入子程序。</target>
        </trans-unit>
        <trans-unit id="97177a061d7ff62a243885c9bd4e1efe9ede32f2" translate="yes" xml:space="preserve">
          <source>To increase the value of something by 1 (or by some other number, if so specified).</source>
          <target state="translated">将某物的价值增加1(或其他数字,如果指定的话)。</target>
        </trans-unit>
        <trans-unit id="72b80e806b1c83aea2a8c7cd737f1e4bbb0943c8" translate="yes" xml:space="preserve">
          <source>To indicate to rather use commandline tools than modules</source>
          <target state="translated">表示宁愿使用命令行工具而不是模块</target>
        </trans-unit>
        <trans-unit id="75120c587d6fba4a38cc9dc45cf5606751546e6f" translate="yes" xml:space="preserve">
          <source>To insert a line after one already in the file, use the &lt;code&gt;-n&lt;/code&gt; switch. It's just like &lt;code&gt;-p&lt;/code&gt; except that it doesn't print &lt;code&gt;$_&lt;/code&gt; at the end of the loop, so you have to do that yourself. In this case, print &lt;code&gt;$_&lt;/code&gt; first, then print the line that you want to add.</source>
          <target state="translated">要在文件中已有的一行之后插入一行，请使用 &lt;code&gt;-n&lt;/code&gt; 开关。就像 &lt;code&gt;-p&lt;/code&gt; 一样，除了在循环结束时不显示 &lt;code&gt;$_&lt;/code&gt; 之外，因此您必须自己执行此操作。在这种情况下，先打印 &lt;code&gt;$_&lt;/code&gt; ，然后打印要添加的行。</target>
        </trans-unit>
        <trans-unit id="574f86f03c88819ff70bca34830f6be35a8bf5f1" translate="yes" xml:space="preserve">
          <source>To install NetWare Perl onto a NetWare server, first map the Sys volume of a NetWare server to</source>
          <target state="translated">要将 NetWare Perl 安装到 NetWare 服务器上,首先要将 NetWare 服务器的 Sys 卷映射到</target>
        </trans-unit>
        <trans-unit id="a7a520bfb7587900e1cbb96bf573db69af079c5b" translate="yes" xml:space="preserve">
          <source>To iterate over the indices of an array, use &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $i (0 .. $#array)
{}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $v (@array) {}&lt;/code&gt; iterates over the values.</source>
          <target state="translated">要遍历数组的索引，请使用 &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $i (0 .. $#array) {}&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $v (@array) {}&lt;/code&gt; 遍历值。</target>
        </trans-unit>
        <trans-unit id="8f0a51f73b6311fa2b970169a1f0134f7c61aef8" translate="yes" xml:space="preserve">
          <source>To join a mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt; , send an empty message to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; . This mailing list is for announcements only and has extremely low traffic---fewer than two messages per year.</source>
          <target state="translated">要加入有关 &lt;code&gt;Memoize&lt;/code&gt; 公告的邮件列表，请将空白消息发送至 &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; 。该邮件列表仅用于公告，并且流量极低-每年少于两封邮件。</target>
        </trans-unit>
        <trans-unit id="9c7770af2e023d19bb1b24c66498040c02b4d820" translate="yes" xml:space="preserve">
          <source>To join a very low-traffic mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt; , send an empty note to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; .</source>
          <target state="translated">要加入流量非常低的邮件列表以获取有关 &lt;code&gt;Memoize&lt;/code&gt; 的公告，请发送空白邮件至 &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30da17ba518ee8896f295021c334b446312ba2d0" translate="yes" xml:space="preserve">
          <source>To just compare two strings for equality/non-equality, you can just use &lt;a href=&quot;perlapi#memEQ&quot;&gt;memEQ() &lt;/a&gt; and &lt;a href=&quot;perlapi#memEQ&quot;&gt;memNE() &lt;/a&gt; as usual, except the strings must be both UTF-8 or not UTF-8 encoded.</source>
          <target state="translated">只需比较两个字符串是否相等，就可以&lt;a href=&quot;perlapi#memEQ&quot;&gt;像平常一样&lt;/a&gt;仅使用memEQ（）和&lt;a href=&quot;perlapi#memEQ&quot;&gt;memNE（）&lt;/a&gt;，不同之处在于字符串必须都是UTF-8或非UTF-8编码的。</target>
        </trans-unit>
        <trans-unit id="bfd1d911fc5d8c1a13ece46d4a41278866b326f9" translate="yes" xml:space="preserve">
          <source>To keep our namespace nice and unpolluted, edit the .pm file and change the variable &lt;code&gt;@EXPORT&lt;/code&gt; to &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Finally, in the .xs file, edit the #include line to read:</source>
          <target state="translated">为了使我们的命名空间保持良好且不受污染，请编辑.pm文件，并将变量 &lt;code&gt;@EXPORT&lt;/code&gt; 更改为 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 。最后，在.xs文件中，编辑#include行以读取：</target>
        </trans-unit>
        <trans-unit id="03272788bb4c31073d76ce4d5e5b7d43fa610bff" translate="yes" xml:space="preserve">
          <source>To learn how to install modules you download from CPAN, read &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt;.</source>
          <target state="translated">要了解如何安装从CPAN下载的模块，请阅读&lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a06d2306514b40b8ba1c92a7641c86fc2fa15b9" translate="yes" xml:space="preserve">
          <source>To learn how to use a particular module, use &lt;code&gt;perldoc &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt;. Typically you will want to &lt;code&gt;use &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt;, which will then give you access to exported functions or an OO interface to the module.</source>
          <target state="translated">要了解如何使用特定模块，请使用 &lt;code&gt;perldoc &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt; 。通常，您将需要 &lt;code&gt;use &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt; ，这将使您可以访问导出的函数或该模块的OO接口。</target>
        </trans-unit>
        <trans-unit id="085a503b5041562d55123a7fc6e92076974024bc" translate="yes" xml:space="preserve">
          <source>To learn more, just type a bogus option, like &lt;b&gt;-\?&lt;/b&gt;, and a long usage message will be provided. There are a fair number of possibilities.</source>
          <target state="translated">要了解更多信息，只需输入假选项，例如&lt;b&gt;-\ ?？&lt;/b&gt;，并且将提供长时间使用消息。有很多可能性。</target>
        </trans-unit>
        <trans-unit id="b660f64338ea03a5a1e256309c3e2566abdfdf76" translate="yes" xml:space="preserve">
          <source>To limit the number of decimal places in your numbers, you can use the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. See &lt;a href=&quot;perlop#Floating-point-Arithmetic&quot;&gt;Floating-point Arithmetic in perlop&lt;/a&gt; for more details.</source>
          <target state="translated">要限制数字中的小数位数，可以使用 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 函数。有关更多详细信息，请参见&lt;a href=&quot;perlop#Floating-point-Arithmetic&quot;&gt;perlop中的浮点算法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a08be93803c5f2a1dab3670911ed75d37f74ad6a" translate="yes" xml:space="preserve">
          <source>To load &lt;code&gt;TAP::Harness&lt;/code&gt; plugins, you'll need to use the &lt;code&gt;tap_harness_args&lt;/code&gt; parameter to &lt;code&gt;new&lt;/code&gt; , typically from your &lt;code&gt;Build.PL&lt;/code&gt; . For example:</source>
          <target state="translated">要加载 &lt;code&gt;TAP::Harness&lt;/code&gt; 插件，通常需要从 &lt;code&gt;Build.PL&lt;/code&gt; 中将 &lt;code&gt;tap_harness_args&lt;/code&gt; 参数用于 &lt;code&gt;new&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="1281377e392724ce754ea5fba63ddbdb0e3e3b86" translate="yes" xml:space="preserve">
          <source>To load on demand. (Also called &amp;ldquo;lazy&amp;rdquo; loading.) Specifically, to call an &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine on behalf of an undefined subroutine.</source>
          <target state="translated">按需加载。（也称为&amp;ldquo;延迟&amp;rdquo;加载。）具体地说，是代表未定义的子例程调用 &lt;code&gt;AUTOLOAD&lt;/code&gt; 子例程。</target>
        </trans-unit>
        <trans-unit id="c23756075d8a23d3d03df135a356f7c210c8debd" translate="yes" xml:space="preserve">
          <source>To maintain backward compatibility with version 1.x of this module &lt;code&gt;gzreadline&lt;/code&gt; ignores the &lt;code&gt;$/&lt;/code&gt; variable - it</source>
          <target state="translated">为了保持与该模块1.x版本的向后兼容性， &lt;code&gt;gzreadline&lt;/code&gt; 忽略 &lt;code&gt;$/&lt;/code&gt; 变量-它</target>
        </trans-unit>
        <trans-unit id="abc4743aa98a734da932da278854d69561d0cbfb" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; work, we need to implement actual mutators, either directly, or in &lt;code&gt;nomethod&lt;/code&gt; . We continue to do things inside &lt;code&gt;nomethod&lt;/code&gt; , thus add</source>
          <target state="translated">为了使 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 正常工作，我们需要直接或以 &lt;code&gt;nomethod&lt;/code&gt; 实现实际的变量。我们继续在 &lt;code&gt;nomethod&lt;/code&gt; 内做事，因此添加</target>
        </trans-unit>
        <trans-unit id="91a1c6beb7c38d494fe7c7d801b2befdd4173ffc" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; work, there were two changes to</source>
          <target state="translated">为了使 &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; 起作用，需要进行两项更改</target>
        </trans-unit>
        <trans-unit id="b87c350e6119d6693a7cb04a8612a5e26f6e647d" translate="yes" xml:space="preserve">
          <source>To make a backup of &lt;code&gt;inFile.txt&lt;/code&gt; , give &lt;code&gt;-i&lt;/code&gt; a file extension to add:</source>
          <target state="translated">要备份 &lt;code&gt;inFile.txt&lt;/code&gt; ，请给 &lt;code&gt;-i&lt;/code&gt; 一个文件扩展名以添加：</target>
        </trans-unit>
        <trans-unit id="8414b77ccfd34c712fab8c626931679fd71f5d22" translate="yes" xml:space="preserve">
          <source>To make a long story short, you can use the special variables &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; , &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; and &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; with AVs and HVs, but you have to make sure you know what you're doing.</source>
          <target state="translated">长话短说，可以将特殊变量 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; ， &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; 和 &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; 与AV和HV一起使用，但必须确保您知道自己在做什么。</target>
        </trans-unit>
        <trans-unit id="5c0463c040e841ec603e099982e8abee57b683e9" translate="yes" xml:space="preserve">
          <source>To make life easier when dealing with duplicate keys, &lt;b&gt;DB_File&lt;/b&gt; comes with a few utility methods.</source>
          <target state="translated">为了&lt;b&gt;简化&lt;/b&gt;重复键的使用，&lt;b&gt;DB_File&lt;/b&gt;提供了一些实用程序方法。</target>
        </trans-unit>
        <trans-unit id="5ae2d3fa0128e67ff0e0a2c8bcd480511ed4d982" translate="yes" xml:space="preserve">
          <source>To make proper use of the</source>
          <target state="translated">要正确使用</target>
        </trans-unit>
        <trans-unit id="c44a199ec9bf1193e7c67a06e66e66c5a73ebf54" translate="yes" xml:space="preserve">
          <source>To make sure we're talking about the same thing when we discuss the removal of features or functionality from the Perl core, we have specific definitions for a few words and phrases.</source>
          <target state="translated">为了确保我们在讨论从 Perl 核心中移除特性或功能时,谈论的是同一件事,我们对一些单词和短语有特定的定义。</target>
        </trans-unit>
        <trans-unit id="5942273fcaa449896c9e37c66cd4e802e9c0964a" translate="yes" xml:space="preserve">
          <source>To make symbols from a &lt;b&gt;module&lt;/b&gt; available for &lt;b&gt;import&lt;/b&gt; by other modules.</source>
          <target state="translated">使&lt;b&gt;模块中的&lt;/b&gt;符号可被其他模块&lt;b&gt;导入&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="dcd61647f554ce66ac28cd2d49ac0cbdb07ed537" translate="yes" xml:space="preserve">
          <source>To make the field hashes kick in, it is easiest to redefine &lt;code&gt;refaddr&lt;/code&gt; as</source>
          <target state="translated">为了使散列值 &lt;code&gt;refaddr&lt;/code&gt; ，将refaddr重新定义为</target>
        </trans-unit>
        <trans-unit id="ffcdcbe9b2ae0d61ba055686a39957aa53dc38e5" translate="yes" xml:space="preserve">
          <source>To make the interface more useful for older versions of Perl, a number of methods are supplied with &lt;b&gt;DB_File&lt;/b&gt; to simulate the missing array operations. All these methods are accessed via the object returned from the tie call.</source>
          <target state="translated">为了使该接口对较早版本的Perl更有用，&lt;b&gt;DB_File&lt;/b&gt;提供了许多方法来模拟缺少的数组操作。所有这些方法都是通过tie调用返回的对象访问的。</target>
        </trans-unit>
        <trans-unit id="1e1af3e6c47d65824073836d9be72328a9d2a810" translate="yes" xml:space="preserve">
          <source>To make these calls fail</source>
          <target state="translated">要使这些呼叫失败</target>
        </trans-unit>
        <trans-unit id="5100ca13c61421986a8b595f7f48745403cf86c2" translate="yes" xml:space="preserve">
          <source>To make things more complicated, the hash may contain references to the actual destinations, for example:</source>
          <target state="translated">为了使事情更复杂,哈希可能包含对实际目的地的引用,例如。</target>
        </trans-unit>
        <trans-unit id="23271da81593c086fb9f97e8eda36eed5fe8ab37" translate="yes" xml:space="preserve">
          <source>To make use of either of the two filter modules above, place the line below in a Perl source file.</source>
          <target state="translated">要使用上述两个过滤模块中的任何一个,请在Perl源文件中加入以下一行。</target>
        </trans-unit>
        <trans-unit id="546b84e64be1bb2630d4087e9c7e0aa2ec07fbeb" translate="yes" xml:space="preserve">
          <source>To make use of threading, however, one usually wants the threads to share at least some data between themselves. This is done with the &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; module and the &lt;code&gt;:shared&lt;/code&gt; attribute:</source>
          <target state="translated">但是，为了利用线程，通常希望线程之间共享至少一些数据。这是通过&lt;a href=&quot;threads/shared&quot;&gt;thread :: shared&lt;/a&gt;模块和 &lt;code&gt;:shared&lt;/code&gt; 属性完成的：</target>
        </trans-unit>
        <trans-unit id="482a24cc09ed210b4be1c7fca66ab517d60e1e62" translate="yes" xml:space="preserve">
          <source>To mark FILEHANDLE as UTF-8, use &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; just marks the data as UTF-8 without further checking, while &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; checks the data for actually being valid UTF-8. More details can be found in &lt;a href=&quot;../perlio/encoding&quot;&gt;PerlIO::encoding&lt;/a&gt;.</source>
          <target state="translated">要将FILEHANDLE标记为UTF-8，请使用 &lt;code&gt;:utf8&lt;/code&gt; 或 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 。 &lt;code&gt;:utf8&lt;/code&gt; 只是将数据标记为UTF-8，而无需进一步检查，而 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 则检查数据是否实际上是有效的UTF-8。更多细节可以在&lt;a href=&quot;../perlio/encoding&quot;&gt;PerlIO :: encoding中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="5274ade94ad24fbd8e1e1d8904bba9bc30f6d6c0" translate="yes" xml:space="preserve">
          <source>To mark FILEHANDLE as UTF-8, use &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; just marks the data as UTF-8 without further checking, while &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; checks the data for actually being valid UTF-8. More details can be found in &lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO::encoding&lt;/a&gt;.</source>
          <target state="translated">要将FILEHANDLE标记为UTF-8，请使用 &lt;code&gt;:utf8&lt;/code&gt; 或 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 。 &lt;code&gt;:utf8&lt;/code&gt; 只是将数据标记为UTF-8，而无需进一步检查，而 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 则检查数据是否实际上是有效的UTF-8。更多细节可以在&lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO :: encoding中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="b4e2df2dd87486f202e752cbd1bc2453ac926173" translate="yes" xml:space="preserve">
          <source>To minimize the number of sbrk(2)s, malloc() asks for more memory. This field gives the size of the yet unused part, which is sbrk(2)ed, but never touched.</source>
          <target state="translated">为了减少sbrk(2)的数量,malloc()要求获得更多的内存。这个字段给出了尚未使用的部分的大小,这部分是sbrk(2)ed,但从未被触及。</target>
        </trans-unit>
        <trans-unit id="c7e29496ccd957aa4492216e45f2282e137e2591" translate="yes" xml:space="preserve">
          <source>To obtain this, a reference to a hash must be passed</source>
          <target state="translated">为了得到这个信息,必须传递一个对哈希的引用。</target>
        </trans-unit>
        <trans-unit id="76c61aa559d88fae477b92a372d192b3b51d4c5b" translate="yes" xml:space="preserve">
          <source>To open a file without blocking, creating if necessary:</source>
          <target state="translated">要在不阻挡的情况下打开文件,必要时创建。</target>
        </trans-unit>
        <trans-unit id="354facfe42bf4e55b171df83905f745324ebd0c9" translate="yes" xml:space="preserve">
          <source>To open file for appending, create if necessary:</source>
          <target state="translated">要打开文件进行追加,必要时创建。</target>
        </trans-unit>
        <trans-unit id="1702818d3f57a9131b4035ed033f063e2b07cebf" translate="yes" xml:space="preserve">
          <source>To open file for appending, file must exist:</source>
          <target state="translated">要打开文件进行追加,文件必须存在。</target>
        </trans-unit>
        <trans-unit id="4967760590c67e61373186454a8e4a1135dcb6d9" translate="yes" xml:space="preserve">
          <source>To open file for reading:</source>
          <target state="translated">要打开文件进行阅读。</target>
        </trans-unit>
        <trans-unit id="cee1bc0ab3a065feee926895157fb947a422ff0d" translate="yes" xml:space="preserve">
          <source>To open file for update, create file if necessary:</source>
          <target state="translated">要打开文件进行更新,必要时创建文件。</target>
        </trans-unit>
        <trans-unit id="7c8a25c4e2b2e915deaf352a915d4e6583e2f962" translate="yes" xml:space="preserve">
          <source>To open file for update, file must exist:</source>
          <target state="translated">要打开文件进行更新,文件必须存在。</target>
        </trans-unit>
        <trans-unit id="b8d1b7a21cb716decbfe05cd44f437ced848a3ac" translate="yes" xml:space="preserve">
          <source>To open file for update, file must not exist:</source>
          <target state="translated">要打开文件进行更新,文件必须不存在。</target>
        </trans-unit>
        <trans-unit id="e09916f7ec3e12864e36849354a4ebf1fbb19361" translate="yes" xml:space="preserve">
          <source>To open file for writing, create new file if needed or else truncate old file:</source>
          <target state="translated">要打开文件进行写作,如果需要的话,可以创建新的文件,或者截断旧的文件。</target>
        </trans-unit>
        <trans-unit id="290398a666a114bce8d99caa62b27b49c84e4b59" translate="yes" xml:space="preserve">
          <source>To open file for writing, create new file, file must not exist:</source>
          <target state="translated">要打开文件进行写入,需要创建新文件,文件必须不存在。</target>
        </trans-unit>
        <trans-unit id="6007d31a54fba5ebc4520f06ed8627e89a0d4a2c" translate="yes" xml:space="preserve">
          <source>To output UTF-8, use the &lt;code&gt;:encoding&lt;/code&gt; or &lt;code&gt;:utf8&lt;/code&gt; output layer. Prepending</source>
          <target state="translated">要输出UTF-8，请使用 &lt;code&gt;:encoding&lt;/code&gt; 或 &lt;code&gt;:utf8&lt;/code&gt; 输出层。前置</target>
        </trans-unit>
        <trans-unit id="3b36e6dcece917ee92e199616190bf7ab5b56187" translate="yes" xml:space="preserve">
          <source>To overcome this limitation, you need to turn on /s matching within the prefix pattern, using the &lt;code&gt;(?s)&lt;/code&gt; directive: '(?s).*?(?=&amp;lt;H1&amp;gt;)'</source>
          <target state="translated">为了克服此限制，您需要使用 &lt;code&gt;(?s)&lt;/code&gt; 指令在前缀模式中打开/ s匹配：'（？s）。*？（？= &amp;lt;H1&amp;gt;）'</target>
        </trans-unit>
        <trans-unit id="062f2ac749842e1dd1762ff59d78e1eb660fe9b7" translate="yes" xml:space="preserve">
          <source>To override a Perl built-in routine with your own version, you need to import it at compile-time. This can be conveniently achieved with the &lt;code&gt;subs&lt;/code&gt; pragma. This will affect only the package in which you've imported the said subroutine:</source>
          <target state="translated">要用您自己的版本覆盖Perl内置例程，您需要在编译时将其导入。可以通过 &lt;code&gt;subs&lt;/code&gt; pragma 方便地实现。这只会影响您在其中导入了上述子例程的软件包：</target>
        </trans-unit>
        <trans-unit id="1aa3f784c17082d78c7fbfe639d471e8c69f8458" translate="yes" xml:space="preserve">
          <source>To override a built-in globally (that is, in all namespaces), you need to import your function into the &lt;code&gt;CORE::GLOBAL&lt;/code&gt; pseudo-namespace at compile time:</source>
          <target state="translated">要全局覆盖一个内置的（即在所有名称空间中），您需要在编译时将函数导入 &lt;code&gt;CORE::GLOBAL&lt;/code&gt; 伪命名空间：</target>
        </trans-unit>
        <trans-unit id="605fcd402b7e1fdc810b4ff2c0f6a15f906ca915" translate="yes" xml:space="preserve">
          <source>To pack dates stored as triplets ( day, month, year ) in an array &lt;code&gt;@dates&lt;/code&gt; into a sequence of byte, byte, short integer we can write</source>
          <target state="translated">要将存储为三元组（日，月，年）的日期包装在 &lt;code&gt;@dates&lt;/code&gt; 数组中，以字节，字节，短整数序列组成，我们可以编写</target>
        </trans-unit>
        <trans-unit id="1d0cde2eb7df8017d255040c9f5af9796899dd92" translate="yes" xml:space="preserve">
          <source>To parse a string &lt;code&gt;$str&lt;/code&gt; as a floating point number use</source>
          <target state="translated">要将字符串 &lt;code&gt;$str&lt;/code&gt; 解析为浮点数，请使用</target>
        </trans-unit>
        <trans-unit id="61571c195afbee84b0b85796b78595db86b7183b" translate="yes" xml:space="preserve">
          <source>To parse a string &lt;code&gt;$str&lt;/code&gt; as a number in some base &lt;code&gt;$base&lt;/code&gt; use</source>
          <target state="translated">解析字符串 &lt;code&gt;$str&lt;/code&gt; 在一些基数的数字 &lt;code&gt;$base&lt;/code&gt; 使用</target>
        </trans-unit>
        <trans-unit id="8c0b000078df0842ed41dd6cf17b93c225c65646" translate="yes" xml:space="preserve">
          <source>To parse this code, Perl uses a heuristic based on what package names it has seen, what subroutines exist in the current package, what barewords it has previously seen, and other input. Needless to say, heuristics can produce very surprising results!</source>
          <target state="translated">为了解析这段代码,Perl使用了一个启发式的方法,基于它见过的包名、当前包中存在的子程序、之前见过的裸词以及其他输入。不用说,启发式方法可以产生非常惊人的结果!</target>
        </trans-unit>
        <trans-unit id="fbca7774c8df9c1e7fff186e61962bc8047a5ac6" translate="yes" xml:space="preserve">
          <source>To pass an object method into a subroutine, you can do this:</source>
          <target state="translated">要将一个对象方法传入一个子程序,可以这样做。</target>
        </trans-unit>
        <trans-unit id="249caf0f11ba46a1737a888a2cd12f841c024b93" translate="yes" xml:space="preserve">
          <source>To pass supplemental arguments to a program opened with &lt;code&gt; '|-' &lt;/code&gt; or &lt;code&gt; '-|' &lt;/code&gt; append them to the command string as you would system EXPR.</source>
          <target state="translated">将补充参数传递给以 &lt;code&gt; '|-' &lt;/code&gt; 或 &lt;code&gt; '-|' &lt;/code&gt; 打开的程序 将它们附加到命令字符串，就像系统EXPR一样。</target>
        </trans-unit>
        <trans-unit id="9bb3f23b2e2cd47ffa049a4b5b8e3297a48bd649" translate="yes" xml:space="preserve">
          <source>To prepare distribution you need to do following:</source>
          <target state="translated">要准备分发,您需要做以下工作。</target>
        </trans-unit>
        <trans-unit id="47e04bab26a33f27d49843c62d8c3b7400695e70" translate="yes" xml:space="preserve">
          <source>To prepend lines to the beginning, print those lines before you enter the loop that prints the existing lines.</source>
          <target state="translated">要在行前添加行,请在进入打印现有行的循环之前打印这些行。</target>
        </trans-unit>
        <trans-unit id="453d8a60ef1b8720b3eb21b0a6becefda886f512" translate="yes" xml:space="preserve">
          <source>To prevent &amp;lt;extract_quotelike&amp;gt; from mucking about with the input in this way (this is the only case where a list-context &lt;code&gt;extract_quotelike&lt;/code&gt; does so), you can pass the input variable as an interpolated literal:</source>
          <target state="translated">为防止&amp;lt;extract_quotelike&amp;gt;以此方式与输入混为一谈（这是列表上下文 &lt;code&gt;extract_quotelike&lt;/code&gt; 这样做的唯一情况），可以将输入变量作为内插文字传递：</target>
        </trans-unit>
        <trans-unit id="743105860f25b02f06770315902de6783c423895" translate="yes" xml:space="preserve">
          <source>To prevent &lt;code&gt;memoize&lt;/code&gt; from installing the memoized version anywhere, use &lt;code&gt;INSTALL =&amp;gt; &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">为了防止 &lt;code&gt;memoize&lt;/code&gt; 的任何地方安装memoized版本，使用 &lt;code&gt;INSTALL =&amp;gt; &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9de321857a95078722502ca43a0201a5f6a4b12" translate="yes" xml:space="preserve">
          <source>To prevent any ambiguity,</source>
          <target state="translated">为了防止任何歧义。</target>
        </trans-unit>
        <trans-unit id="ac0fc603c0e20ee050f6b1167e08040f2086e70a" translate="yes" xml:space="preserve">
          <source>To prevent the contents of a queue from being modified by another thread while it is being examined and/or changed, &lt;a href=&quot;../threads/shared#lock-VARIABLE&quot;&gt;lock&lt;/a&gt; the queue inside a local block:</source>
          <target state="translated">为了防止队列的内容在检查和/或更改时被另一个线程修改，请将队列&lt;a href=&quot;../threads/shared#lock-VARIABLE&quot;&gt;锁定&lt;/a&gt;在本地块内：</target>
        </trans-unit>
        <trans-unit id="521d225cb8b8267bdc9221af420cb3102374b4c5" translate="yes" xml:space="preserve">
          <source>To prevent this, supply a &lt;code&gt;NORMALIZER&lt;/code&gt; function that turns the program arguments into a string in a way that equivalent arguments turn into the same string. A &lt;code&gt;NORMALIZER&lt;/code&gt; function for &lt;code&gt;f&lt;/code&gt; above might look like this:</source>
          <target state="translated">为避免这种情况，请提供 &lt;code&gt;NORMALIZER&lt;/code&gt; 函数，该函数将程序参数转换为字符串，而等效参数转换为相同字符串。上面 &lt;code&gt;f&lt;/code&gt; 的 &lt;code&gt;NORMALIZER&lt;/code&gt; 函数可能看起来像这样：</target>
        </trans-unit>
        <trans-unit id="6fa84f786f1f2e361ba53d7582050f707e69605c" translate="yes" xml:space="preserve">
          <source>To produce a perl binary with a different name than &lt;code&gt;perl&lt;/code&gt; , either say</source>
          <target state="translated">要产生一个与 &lt;code&gt;perl&lt;/code&gt; 名称不同的perl二进制文件，可以说</target>
        </trans-unit>
        <trans-unit id="deeb5ed64d8b8726d03c2a35d8b9a4f9932501dd" translate="yes" xml:space="preserve">
          <source>To prove success on the host machine, run &quot;dumpbin /headers wince-arm-pocket-wce400\perl.exe&quot; from the win32/ folder and look for &quot;machine (ARM)&quot; in the FILE HEADER VALUES and &quot;subsystem (Windows CE GUI)&quot; in the OPTIONAL HEADER VALUES.</source>
          <target state="translated">为了证明在主机上的成功,从win32/文件夹中运行 &quot;dumpbin /headers wince-arm-pocket-wce400/perl.exe&quot;,并在FILE HEADER VALUES中查找 &quot;机器(ARM)&quot;,在OPTIONAL HEADER VALUES中查找 &quot;子系统(Windows CE GUI)&quot;。</target>
        </trans-unit>
        <trans-unit id="e3f95db7629c92dc13df17dee2376ecae6bd28b4" translate="yes" xml:space="preserve">
          <source>To provide a Perl interface to this library we need to be able to map between the &lt;code&gt;fh&lt;/code&gt; parameter and the Perl subroutine we want called. A hash is a convenient mechanism for storing this mapping. The code below shows a possible implementation</source>
          <target state="translated">为了向该库提供Perl接口，我们需要能够在 &lt;code&gt;fh&lt;/code&gt; 参数和我们要调用的Perl子例程之间进行映射。哈希是用于存储此映射的便捷机制。下面的代码显示了可能的实现</target>
        </trans-unit>
        <trans-unit id="56afd5e1c9ab39b7d24b6a35fc7523124fb4a154" translate="yes" xml:space="preserve">
          <source>To provide an example, let's say the popular &lt;code&gt;Foo::Bar::escape_html&lt;/code&gt; function doesn't deal with Unicode data yet. The wrapper function would convert the argument to raw UTF-8 and convert the result back to Perl's internal representation like so:</source>
          <target state="translated">举个例子，假设流行的 &lt;code&gt;Foo::Bar::escape_html&lt;/code&gt; 函数尚未处理Unicode数据。包装函数会将参数转换为原始UTF-8，然后将结果转换回Perl的内部表示形式，如下所示：</target>
        </trans-unit>
        <trans-unit id="fe539191c8112058d164cdbdc07c4a313e2ceb71" translate="yes" xml:space="preserve">
          <source>To provide backward compatibility with the previous version of Net::Ping, a pingecho() subroutine is available with the same functionality as before. pingecho() uses the tcp protocol. The return values and parameters are the same as described for the ping() method. This subroutine is obsolete and may be removed in a future version of Net::Ping.</source>
          <target state="translated">为了向后兼容以前版本的 Net::Ping,我们提供了一个 pingecho()子程序,它的功能与以前的相同。 pingecho()使用 tcp 协议。返回值和参数与ping()方法的描述相同。这个子例程已经过时了,可能会在 Net::Ping 的未来版本中被删除。</target>
        </trans-unit>
        <trans-unit id="ece610257b3402f7eea4d17dbc76eda55d9cbb02" translate="yes" xml:space="preserve">
          <source>To provide the capability to set/get class-wide settings, it is best instead to provide accessors as subroutines or class methods instead.</source>
          <target state="translated">为了提供设置/获取全类设置的功能,最好是以子程序或类方法的形式提供访问器。</target>
        </trans-unit>
        <trans-unit id="b8ad3c75e2a9658073e3c75677575371b7b2154a" translate="yes" xml:space="preserve">
          <source>To put the output from any parse method into a string instead of a file handle, call the output_string() method instead of output_fh().</source>
          <target state="translated">要把任何解析方法的输出放到一个字符串而不是文件句柄中,调用output_string()方法而不是output_fh()。</target>
        </trans-unit>
        <trans-unit id="8d3d8f79e5bb23da5237f2bc4f067b582af08744" translate="yes" xml:space="preserve">
          <source>To quickly check the type of a &lt;code&gt;Archive::Tar::File&lt;/code&gt; object, you can use the following methods:</source>
          <target state="translated">要快速检查 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 对象的类型，可以使用以下方法：</target>
        </trans-unit>
        <trans-unit id="ffb74a402d25037ed756434b89268f8c6c0f487e" translate="yes" xml:space="preserve">
          <source>To quote the bzip2 documentation</source>
          <target state="translated">引用bzip2的文档</target>
        </trans-unit>
        <trans-unit id="2e030dd198e6e120e9f1df9a82e7575806595a2d" translate="yes" xml:space="preserve">
          <source>To read an entire &lt;b&gt;file&lt;/b&gt; into a &lt;b&gt;string&lt;/b&gt; in one operation.</source>
          <target state="translated">通过一次操作将整个&lt;b&gt;文件&lt;/b&gt;读入&lt;b&gt;字符串&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="d6676802f298dda33ea89ee297e7a4c3b7e4e2ac" translate="yes" xml:space="preserve">
          <source>To read both a command's STDOUT and its STDERR separately, it's easiest to redirect them separately to files, and then read from those files when the program is done:</source>
          <target state="translated">如果要分别读取一个命令的STDOUT和它的STDERR,最简单的办法是将它们分别重定向到文件中,等程序完成后再从这些文件中读取。</target>
        </trans-unit>
        <trans-unit id="441b0a3f043e9d675f24f50e1a3845049a78b701" translate="yes" xml:space="preserve">
          <source>To read both a command's STDOUT and its STDERR separately, you can redirect them to temp files, let the command run, then read the temp files:</source>
          <target state="translated">要分别读取一个命令的STDOUT和它的STDERR,可以将它们重定向到临时文件,让命令运行,然后读取临时文件。</target>
        </trans-unit>
        <trans-unit id="5540d6192acd70f39a8ef597e449669bc8ae5ddb" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt; , and write the compressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">要从现有的Perl文件句柄 &lt;code&gt;$input&lt;/code&gt; 读取，并将压缩后的数据写入缓冲区 &lt;code&gt;$buffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c349b729382da049ab850b286913e925d6fe3968" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt; , and write the uncompressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">要从现有的Perl文件句柄 &lt;code&gt;$input&lt;/code&gt; 读取，并将未压缩的数据写入缓冲区 &lt;code&gt;$buffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7482ebcf137b958140c12465f2671a82fcf986b9" translate="yes" xml:space="preserve">
          <source>To read the</source>
          <target state="translated">阅读</target>
        </trans-unit>
        <trans-unit id="87df4beb52a8613330401231fb10bf4839a044e4" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1950&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt.1950&lt;/code&gt; 的内容并将未压缩的数据写入文件 &lt;code&gt;file1.txt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f3af95cfb979c68a078d4244b348eca50284cce" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1951&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt.1951&lt;/code&gt; 的内容并将未压缩的数据写入文件 &lt;code&gt;file1.txt&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="fe87604cf51141fe67b4d7c05185428541881932" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.Compressed&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt.Compressed&lt;/code&gt; 的内容并将未压缩的数据写入文件 &lt;code&gt;file1.txt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dcd74724ed743479732074df76791b8e4375f0ba" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.bz2&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt.bz2&lt;/code&gt; 的内容并将未压缩的数据写入文件 &lt;code&gt;file1.txt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0224a4a1040095275155b56f5f7207fca1c2ad1" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.gz&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt.gz&lt;/code&gt; 的内容并将未压缩的数据写入文件 &lt;code&gt;file1.txt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62b61bd1daa8a6cb2d7eb96d3ece7209a79b5aec" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1950&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt&lt;/code&gt; 的内容并将压缩数据写入文件 &lt;code&gt;file1.txt.1950&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e429b7a25235b582c4b383620392f1a750a3bdd" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1951&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt&lt;/code&gt; 的内容并将压缩数据写入文件 &lt;code&gt;file1.txt.1951&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c406d8acaac2a742d676187babe70fbc63a189bd" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.bz2&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt&lt;/code&gt; 的内容并将压缩数据写入文件 &lt;code&gt;file1.txt.bz2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa350228ff2721777414a685ddb5c4e3af10826c" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.gz&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt&lt;/code&gt; 的内容并将压缩数据写入文件 &lt;code&gt;file1.txt.gz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1253348a31fd66554a6efd5d56c0e22a2ff1b137" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.zip&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt&lt;/code&gt; 的内容并将压缩数据写入文件 &lt;code&gt;file1.txt.zip&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cb0378e48901dddc588a6225fe4a4196884f056" translate="yes" xml:space="preserve">
          <source>To really poke around with Perl, you'll probably want to build Perl for debugging, like this:</source>
          <target state="translated">如果要真正的摸索Perl,你可能会想要构建Perl来进行调试,就像这样。</target>
        </trans-unit>
        <trans-unit id="224b47d42836cf02b0538bc7324878629aa47a30" translate="yes" xml:space="preserve">
          <source>To receive an announcement whenever a new version of this module is released, send a blank email message to &lt;code&gt;mjd-perl-tiefile-subscribe@plover.com&lt;/code&gt; .</source>
          <target state="translated">要在该模块的新版本发布时收到公告，请将空白电子邮件发送到 &lt;code&gt;mjd-perl-tiefile-subscribe@plover.com&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3e33fd8f77a0950334d95b2b753813796d2bf20" translate="yes" xml:space="preserve">
          <source>To recursively create a directory structure, look at the &lt;code&gt;make_path&lt;/code&gt; function of the &lt;a href=&quot;../file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">要递归创建目录结构，请查看&lt;a href=&quot;../file/path&quot;&gt;File :: Path&lt;/a&gt;模块的 &lt;code&gt;make_path&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="d93ce0279ba5e733f28599be83e53944021fc924" translate="yes" xml:space="preserve">
          <source>To recursively create a directory structure, look at the &lt;code&gt;make_path&lt;/code&gt; function of the &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">要递归创建目录结构，请查看&lt;a href=&quot;file/path&quot;&gt;File :: Path&lt;/a&gt;模块的 &lt;code&gt;make_path&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="b5946d1b5adc8bf79e8d8691892a42663cd834d2" translate="yes" xml:space="preserve">
          <source>To reduce the overhead as much as possible, only one possible location is checked to find the extension DLL (this location is where &lt;code&gt;make install&lt;/code&gt; would put the DLL). If not found, the search for the DLL is transparently delegated to &lt;code&gt;DynaLoader&lt;/code&gt; , which looks for the DLL along the &lt;code&gt;@INC&lt;/code&gt; list.</source>
          <target state="translated">为了尽可能减少开销，仅检查一个可能的位置以找到扩展DLL（此位置是 &lt;code&gt;make install&lt;/code&gt; 放置DLL的位置）。如果未找到，则将对DLL的搜索透明地委派给 &lt;code&gt;DynaLoader&lt;/code&gt; ，后者沿 &lt;code&gt;@INC&lt;/code&gt; 列表查找DLL 。</target>
        </trans-unit>
        <trans-unit id="98bed95392f2bd5c21b8012e731bec1f2530889e" translate="yes" xml:space="preserve">
          <source>To remove a directory tree recursively (&lt;code&gt;rm -rf&lt;/code&gt; on Unix) look at the &lt;code&gt;rmtree&lt;/code&gt; function of the &lt;a href=&quot;../file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">要递归删除目录树（在Unix上为 &lt;code&gt;rm -rf&lt;/code&gt; ），请&lt;a href=&quot;../file/path&quot;&gt;查看File :: Path&lt;/a&gt;模块的 &lt;code&gt;rmtree&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="4e5b819764f7105a80a7d510f2a867ba675bddec" translate="yes" xml:space="preserve">
          <source>To remove a directory tree recursively (&lt;code&gt;rm -rf&lt;/code&gt; on Unix) look at the &lt;code&gt;rmtree&lt;/code&gt; function of the &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">要递归删除目录树（在Unix上为 &lt;code&gt;rm -rf&lt;/code&gt; ），请&lt;a href=&quot;file/path&quot;&gt;查看File :: Path&lt;/a&gt;模块的 &lt;code&gt;rmtree&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="e56141f1ebe96f14282b26d571378c274b2244ed" translate="yes" xml:space="preserve">
          <source>To remove a tied environment variable from the environment, assign it the undefined value</source>
          <target state="translated">要从环境中删除一个绑定的环境变量,请给它分配一个未定义的值。</target>
        </trans-unit>
        <trans-unit id="06b0ac63c637336d9c539fb315b8373179470836" translate="yes" xml:space="preserve">
          <source>To remove creation of the tied hash on each access, one may an extra level of indirection which allows a non-circular structure of references:</source>
          <target state="translated">为了消除在每次访问时创建绑定哈希,可以增加一个额外的间接层次,允许引用的非循环结构。</target>
        </trans-unit>
        <trans-unit id="385dafb73da7d1789642356fd78d8d3446310a3d" translate="yes" xml:space="preserve">
          <source>To remove the magic from an SV, call the function sv_unmagic:</source>
          <target state="translated">要删除SV中的魔法,调用函数sv_unmagic。</target>
        </trans-unit>
        <trans-unit id="ee81225f636096e269a365626b3e0c2212110758" translate="yes" xml:space="preserve">
          <source>To report a new bug, visit:</source>
          <target state="translated">要报告一个新的错误,请访问。</target>
        </trans-unit>
        <trans-unit id="935323786b12419a7345fc07129055605bd12b91" translate="yes" xml:space="preserve">
          <source>To retrieve data stored to disk, use &lt;code&gt;retrieve&lt;/code&gt; with a file name. The objects stored into that file are recreated into memory for you, and a</source>
          <target state="translated">要检索存储到磁盘的数据，请使用带有文件名的 &lt;code&gt;retrieve&lt;/code&gt; 。存储在该文件中的对象将为您重新创建到内存中，并且</target>
        </trans-unit>
        <trans-unit id="4f95fbea27e1a9b8ba09786147eb856c1d1f83f4" translate="yes" xml:space="preserve">
          <source>To retrieve the &lt;code&gt;REGEXP&lt;/code&gt; object from the scalar in an XS function use the &lt;code&gt;SvRX&lt;/code&gt; macro, see &lt;a href=&quot;perlapi#REGEXP-Functions&quot;&gt;REGEXP Functions in perlapi&lt;/a&gt;.</source>
          <target state="translated">要使用XS函数从标量中检索 &lt;code&gt;REGEXP&lt;/code&gt; 对象，请使用 &lt;code&gt;SvRX&lt;/code&gt; 宏，请参见&lt;a href=&quot;perlapi#REGEXP-Functions&quot;&gt;perlapi中的REGEXP函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1231633ff6452d875f890a43a2ae8ede0790e949" translate="yes" xml:space="preserve">
          <source>To return an empty list one must use a PPCODE: block and then not push return values on the stack.</source>
          <target state="translated">要返回一个空列表,必须使用PPCODE:块,然后不在栈上推送返回值。</target>
        </trans-unit>
        <trans-unit id="c52a15c8b572dc0999ddd7a3d452b4f9cfbf130a" translate="yes" xml:space="preserve">
          <source>To run Perl on DPMI platforms one needs RSX runtime. This is needed under DOS-inside-OS/2, Win0.3*, Win0.95 and WinNT (see &lt;a href=&quot;#Other-OSes&quot;&gt;Other OSes&lt;/a&gt;). RSX would not work with VCPI only, as EMX would, it requires DMPI.</source>
          <target state="translated">要在DPMI平台上运行Perl，需要RSX运行时。在DOS-inside-OS / 2，Win0.3 *，Win0.95和WinNT下，这是必需的（请参阅&lt;a href=&quot;#Other-OSes&quot;&gt;其他操作系统&lt;/a&gt;）。RSX不能像EMX一样仅与VCPI一起使用，它需要DMPI。</target>
        </trans-unit>
        <trans-unit id="f4988afc10b11011c01fd1dc8e2d9efa2ca35527" translate="yes" xml:space="preserve">
          <source>To run a &lt;b&gt;program&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt;. (Has nothing to do with the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; built-in, unless you&amp;rsquo;re trying to run a &lt;b&gt;signal handler&lt;/b&gt;.)</source>
          <target state="translated">运行&lt;b&gt;程序&lt;/b&gt;或&lt;b&gt;子程序&lt;/b&gt;。（除非您试图运行&lt;b&gt;信号处理程序&lt;/b&gt;，否则它与内置的 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 无关）。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8cf4ac8bbb41685c2ce7804ccdb1791a6e3ce985" translate="yes" xml:space="preserve">
          <source>To run a Perl program from the Unix command line:</source>
          <target state="translated">从Unix命令行运行Perl程序。</target>
        </trans-unit>
        <trans-unit id="69d193d311b7fdb3c43e19bb64a6bebcfed27d39" translate="yes" xml:space="preserve">
          <source>To run this code, &lt;code&gt;perl_run&lt;/code&gt; is called, which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; then enters a runops loop. This loop executes the eval and tie ops on line 1, with the eval pushing a &lt;code&gt;CxEVAL&lt;/code&gt; onto the context stack.</source>
          <target state="translated">要运行此代码，将调用 &lt;code&gt;perl_run&lt;/code&gt; ，它执行 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; ,然后进入runops循环。此循环在第1行执行eval并绑定操作，而eval将 &lt;code&gt;CxEVAL&lt;/code&gt; 推入上下文堆栈。</target>
        </trans-unit>
        <trans-unit id="46ec5458708076d609a6883cd1bd780e161cc64e" translate="yes" xml:space="preserve">
          <source>To say the least, surrogate pairs were the biggest mistake of the Unicode Consortium. But according to the late Douglas Adams in</source>
          <target state="translated">至少可以说,代用对是Unicode联盟最大的错误。但根据已故的道格拉斯-亚当斯(Douglas Adams)在</target>
        </trans-unit>
        <trans-unit id="48af12ca119bf709d476507ec2e3aea7bdcd0d97" translate="yes" xml:space="preserve">
          <source>To search the perlfaq question headings:</source>
          <target state="translated">要搜索perlfaq问题标题。</target>
        </trans-unit>
        <trans-unit id="518862144f077b9ba7e98c4f411c046f6e96affb" translate="yes" xml:space="preserve">
          <source>To see all about your machine, type</source>
          <target state="translated">要查看您的机器的所有信息,请输入</target>
        </trans-unit>
        <trans-unit id="5d0d28f6946dedb31c299d2d78aa9802594a8195" translate="yes" xml:space="preserve">
          <source>To see how (un)packing works, we'll start with a simple template code where the conversion is in low gear: between the contents of a byte sequence and a string of hexadecimal digits. Let's use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, since this is likely to remind you of a dump program, or some desperate last message unfortunate programs are wont to throw at you before they expire into the wild blue yonder. Assuming that the variable &lt;code&gt;$mem&lt;/code&gt; holds a sequence of bytes that we'd like to inspect without assuming anything about its meaning, we can write</source>
          <target state="translated">为了了解打包的工作方式，我们将以一个简单的模板代码开始，该模板的转换速度很慢：在字节序列的内容和一串十六进制数字之间。让我们使用 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ，因为这很可能使您想起一个转储程序，或者一些绝望的最后消息，不幸的程序在它们变成荒野的蓝色边缘之前不会扔给您。假设变量 &lt;code&gt;$mem&lt;/code&gt; 保留了我们要检查的字节序列，而没有对其含义作任何假设，我们可以编写</target>
        </trans-unit>
        <trans-unit id="526ccfeab3729429cc060187cce1bbaba5ac3037" translate="yes" xml:space="preserve">
          <source>To see how this affects &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, we'll compare these two C structures:</source>
          <target state="translated">要查看这如何影响 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ，我们将比较这两个C结构：</target>
        </trans-unit>
        <trans-unit id="99fa402c0f19d397a266c609792e7a721baa908f" translate="yes" xml:space="preserve">
          <source>To see if a variable contains a reference, use the &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; function. It returns true if its argument is a reference. Actually it's a little better than that: It returns &lt;code&gt;HASH&lt;/code&gt; for hash references and &lt;code&gt;ARRAY&lt;/code&gt; for array references.</source>
          <target state="translated">要查看变量是否包含引用，请使用 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 函数。如果其参数是引用，则返回true。实际上，它比这要好一些：它为哈希引用返回 &lt;code&gt;HASH&lt;/code&gt; ，为数组引用返回 &lt;code&gt;ARRAY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="960bf2c563408fba71fe24086af2e53cbf0767bd" translate="yes" xml:space="preserve">
          <source>To see if your system is affected by this discrepancy check if &lt;code&gt;getconf GNU_LIBPTHREAD_VERSION | &lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt; -q NPTL&lt;/code&gt; returns a false value. NTPL threads preserve the POSIX semantics.</source>
          <target state="translated">要查看您的系统是否受此差异影响，请检查 &lt;code&gt;getconf GNU_LIBPTHREAD_VERSION | &lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt; -q NPTL&lt;/code&gt; 返回一个假值。NTPL线程保留POSIX语义。</target>
        </trans-unit>
        <trans-unit id="d211374e5db97da1828e5f0a6f84c0b749ec44e8" translate="yes" xml:space="preserve">
          <source>To see it in action, add a method</source>
          <target state="translated">要想看到它的运作,请添加一个方法</target>
        </trans-unit>
        <trans-unit id="5e8654d4f5f9129c9cab32750ab5566521abf2dc" translate="yes" xml:space="preserve">
          <source>To see what a state description looks like, just run the following:</source>
          <target state="translated">要查看状态描述是什么样子的,只需运行以下命令。</target>
        </trans-unit>
        <trans-unit id="1afd16a9742f3bb00f5d52a4bea0944a04f89bb4" translate="yes" xml:space="preserve">
          <source>To see what is installed on your system:</source>
          <target state="translated">要查看系统中安装了什么。</target>
        </trans-unit>
        <trans-unit id="759c7cca5357567d905de52c1b1b6b667aaa23a6" translate="yes" xml:space="preserve">
          <source>To see what version is included on the DVD (assumed here to be mounted on /cdrom), issue this command:</source>
          <target state="translated">要查看DVD上包含的版本(这里假设是挂载在/cdrom上),发出这个命令。</target>
        </trans-unit>
        <trans-unit id="7ad61eadcf1dbdb7c99f44756b97def548456147" translate="yes" xml:space="preserve">
          <source>To see whether you have non-const data you can use a BSD (or GNU) compatible &lt;code&gt;nm&lt;/code&gt; :</source>
          <target state="translated">要查看是否有非常量数据，可以使用与BSD（或GNU）兼容的 &lt;code&gt;nm&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ceecb8953e41093c57b8581763c4bd993092c9bf" translate="yes" xml:space="preserve">
          <source>To see why this is a problem, consider what can happen when two processes, say &quot;A&quot; and &quot;B&quot;, both want to update the same &lt;b&gt;DB_File&lt;/b&gt; database using the locking steps outlined above. Assume process &quot;A&quot; has already opened the database and has a write lock, but it hasn't actually updated the database yet (it has finished step 2, but not started step 3 yet). Now process &quot;B&quot; tries to open the same database - step 1 will succeed, but it will block on step 2 until process &quot;A&quot; releases the lock. The important thing to notice here is that at this point in time both processes will have cached identical initial blocks from the database.</source>
          <target state="translated">要了解为什么会出现问题，请考虑当两个进程（例如&amp;ldquo; A&amp;rdquo;和&amp;ldquo; B&amp;rdquo;）都希望使用上述锁定步骤更新同一&lt;b&gt;DB_File&lt;/b&gt;数据库时会发生什么。假定进程&amp;ldquo; A&amp;rdquo;已经打开数据库并具有写锁，但是它实际上尚未更新数据库（它已完成步骤2，但尚未开始步骤3）。现在，进程&amp;ldquo; B&amp;rdquo;尝试打开相同的数据库-步骤1将成功，但是它将在步骤2阻塞，直到进程&amp;ldquo; A&amp;rdquo;释放锁为止。这里要注意的重要一点是，此时两个进程都将从数据库中缓存相同的初始块。</target>
        </trans-unit>
        <trans-unit id="887591ebb547202a2fbb02bece1d9984e9bcdec7" translate="yes" xml:space="preserve">
          <source>To see why, notice how you'll still have an issue on half-way-point alternation:</source>
          <target state="translated">要想知道原因,请注意,你在半程点交替上还是会有问题。</target>
        </trans-unit>
        <trans-unit id="0cddf3be7ebfd9389288691711afdcfed8edf9c1" translate="yes" xml:space="preserve">
          <source>To send a &lt;b&gt;datagram&lt;/b&gt; to multiple destinations simultaneously.</source>
          <target state="translated">同时发送&lt;b&gt;数据报到&lt;/b&gt;多个目的地。</target>
        </trans-unit>
        <trans-unit id="8617ca70598e41eabf7c915af7a92af825a55fcd" translate="yes" xml:space="preserve">
          <source>To send something to its correct destination. Often used metaphorically to indicate a transfer of programmatic control to a destination selected algorithmically, often by lookup in a table of function &lt;b&gt;references&lt;/b&gt; or, in the case of object &lt;b&gt;methods&lt;/b&gt;, by traversing the inheritance tree looking for the most specific definition for the method.</source>
          <target state="translated">将某物发送到正确的目的地。通常通过比喻来表示将程序控制权转移到通过算法选择的目标，通常是通过在函数&lt;b&gt;引用&lt;/b&gt;表中查找，或者在对象&lt;b&gt;方法&lt;/b&gt;的情况下，通过遍历继承树以寻找方法的最特定定义。</target>
        </trans-unit>
        <trans-unit id="67e016f9948cc1473ec98e12bd274f9eaa7682bd" translate="yes" xml:space="preserve">
          <source>To set the state of a pragma:</source>
          <target state="translated">设置一个pragma的状态。</target>
        </trans-unit>
        <trans-unit id="4d0f638abe1cc26ab6bbeb03cebb08b40820c287" translate="yes" xml:space="preserve">
          <source>To set your private value, call &lt;code&gt;Perl_mro_set_private_data()&lt;/code&gt; :</source>
          <target state="translated">要设置您的私有值，请调用 &lt;code&gt;Perl_mro_set_private_data()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="39b42d6c90a6c04419bddc3aa56e776f03e6d4b1" translate="yes" xml:space="preserve">
          <source>To shut off its generation, pass the &lt;code&gt;NO_META&lt;/code&gt; flag to &lt;code&gt;WriteMakefile()&lt;/code&gt; .</source>
          <target state="translated">要关闭其生成，请将 &lt;code&gt;NO_META&lt;/code&gt; 标志传递给 &lt;code&gt;WriteMakefile()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57cf8244407c213f6cbced635b585a8f402b31ff" translate="yes" xml:space="preserve">
          <source>To signal the semaphore, replace &lt;code&gt;-1&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt; . See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , and &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">要发出信号量，请将 &lt;code&gt;-1&lt;/code&gt; 替换为 &lt;code&gt;1&lt;/code&gt; 。另请参见&lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;perlipc&lt;/a&gt;， &lt;code&gt;IPC::SysV&lt;/code&gt; 和 &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; 文档中的SysV IPC。</target>
        </trans-unit>
        <trans-unit id="d782cb39a280e66911e6595a3826686b674e633e" translate="yes" xml:space="preserve">
          <source>To signal the semaphore, replace &lt;code&gt;-1&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt; . See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , and &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">要发出信号量，请将 &lt;code&gt;-1&lt;/code&gt; 替换为 &lt;code&gt;1&lt;/code&gt; 。另请参见&lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;perlipc&lt;/a&gt;， &lt;code&gt;IPC::SysV&lt;/code&gt; 和 &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; 文档中的SysV IPC。</target>
        </trans-unit>
        <trans-unit id="46e199b8e074ec6e1896ea95f9bad604e453a779" translate="yes" xml:space="preserve">
          <source>To signal to Perl that HMQ is not needed any more, call &lt;code&gt;perl_hmq_UNSET(serve)&lt;/code&gt; . Perl process will automatically morph/unmorph itself into/from a PM process if HMQ is needed/not-needed. Perl will automatically enable/disable &lt;code&gt;WM_QUIT&lt;/code&gt; message during shutdown if the message queue is served/not-served.</source>
          <target state="translated">要向Perl发出不再需要HMQ的信号，请调用 &lt;code&gt;perl_hmq_UNSET(serve)&lt;/code&gt; 。如果需要/不需要HMQ，Perl进程将自动将自身变形为PM过程或从PM过程中变形。如果消息队列已服务/未服务，则Perl将在关机期间自动启用/禁用 &lt;code&gt;WM_QUIT&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="3868e3b616a54cb1bab8634fd841ed657adc2c50" translate="yes" xml:space="preserve">
          <source>To silently interpret it as the Perl operator, use the &lt;code&gt;CORE::&lt;/code&gt; prefix on the operator (e.g. &lt;code&gt;CORE::log($x)&lt;/code&gt; ) or declare the subroutine to be an object method (see &lt;a href=&quot;perlsub#Subroutine-Attributes&quot;&gt;Subroutine Attributes in perlsub&lt;/a&gt; or &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;).</source>
          <target state="translated">要以静默方式将其解释为Perl运算符，请在运算符上使用 &lt;code&gt;CORE::&lt;/code&gt; 前缀（例如 &lt;code&gt;CORE::log($x)&lt;/code&gt; ）或将子例程声明为对象方法（请参见&lt;a href=&quot;perlsub#Subroutine-Attributes&quot;&gt;perlsub中的Subroutine Attributes&lt;/a&gt;或&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ea26257b4903cfdcc4f9b51c3c53cf94dc5f1003" translate="yes" xml:space="preserve">
          <source>To simplify multi-line substitutions, the &quot;.&quot; character never matches a newline unless you use the &lt;code&gt;/s&lt;/code&gt; modifier, which in effect tells Perl to pretend the string is a single line--even if it isn't.</source>
          <target state="translated">为了简化多行替换，请使用&amp;ldquo;。&amp;rdquo;。字符永远不会与换行符匹配，除非您使用 &lt;code&gt;/s&lt;/code&gt; 修饰符，该修饰符实际上告诉Perl假装字符串是单行-即使不是。</target>
        </trans-unit>
        <trans-unit id="3dcc0c984ac1c1f3aa01cd10ae020a1e23d2e144" translate="yes" xml:space="preserve">
          <source>To skip lines, use the looping controls. The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; in this example skips comment lines, and the &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; stops all processing once it encounters either &lt;code&gt;__END__&lt;/code&gt; or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">要跳过行，请使用循环控件。此示例中的 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 跳过注释行，并且 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 遇到 &lt;code&gt;__END__&lt;/code&gt; 或 &lt;code&gt;__DATA__&lt;/code&gt; 时,它停止所有处理。</target>
        </trans-unit>
        <trans-unit id="7cb7cc3fb6917e0db56d0ceef1f6b092afc65ddb" translate="yes" xml:space="preserve">
          <source>To solve this, you must manually use pipe(), fork(), and the form of open() which sets one file descriptor to another, as shown below:</source>
          <target state="translated">为了解决这个问题,你必须手动使用管道()、fork()以及将一个文件描述符设置为另一个文件描述符的open()形式,如下图所示。</target>
        </trans-unit>
        <trans-unit id="f205d5425879968b7952a3fb61c2ff97a391a194" translate="yes" xml:space="preserve">
          <source>To sort a hash by value, you'll need to use a &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function. Here's a descending numeric sort of a hash by its values:</source>
          <target state="translated">要按值对哈希进行排序，您需要使用 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 功能。这是哈希值的降序数字排序：</target>
        </trans-unit>
        <trans-unit id="e22346e7b0a650eb196d705609c50726a647e816" translate="yes" xml:space="preserve">
          <source>To sort a hash by value, you'll need to use a &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function. Here's a descending numeric sort of a hash by its values:</source>
          <target state="translated">要按值对哈希进行排序，您需要使用 &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 功能。这是哈希值的降序数字排序：</target>
        </trans-unit>
        <trans-unit id="035b2f73f3e8b156397dc2189e758b10b01a049f" translate="yes" xml:space="preserve">
          <source>To sort a hash, start with the keys. In this example, we give the list of keys to the sort function which then compares them ASCIIbetically (which might be affected by your locale settings). The output list has the keys in ASCIIbetical order. Once we have the keys, we can go through them to create a report which lists the keys in ASCIIbetical order.</source>
          <target state="translated">要对一个哈希进行排序,先从键值开始。在这个例子中,我们将键值列表交给排序函数,然后以ASCII码方式对它们进行比较(这可能会受到您的本地设置的影响)。输出列表中的键按 ASCII 字符顺序排列。一旦我们得到了键值,我们就可以通过它们来创建一个按ASCII字节顺序排列的报告。</target>
        </trans-unit>
        <trans-unit id="bd567593644cab945269478fa56978a3d2bc8799" translate="yes" xml:space="preserve">
          <source>To specify a character by Unicode code point, use the form &lt;code&gt;\N{U+&lt;i&gt;code
point&lt;/i&gt;}&lt;/code&gt;, where</source>
          <target state="translated">要通过Unicode代码点指定字符，请使用 &lt;code&gt;\N{U+&lt;i&gt;code point&lt;/i&gt;}&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="97bdead994a8b1301604dc655e33bb83cb6a1547" translate="yes" xml:space="preserve">
          <source>To specify a compression level when writing, append a digit between 0 and 9 to the mode string -- 0 means no compression and 9 means maximum compression. If no compression level is specified Z_DEFAULT_COMPRESSION is used.</source>
          <target state="translated">要在写入时指定压缩级别,请在模式字符串中添加0到9之间的数字--0表示不压缩,9表示最大压缩。如果没有指定压缩级别,则使用Z_DEFAULT_COMPRESSION。</target>
        </trans-unit>
        <trans-unit id="edce8429b2a3fa7edc3e49d4ca87a0b2294c60e2" translate="yes" xml:space="preserve">
          <source>To specify a particular stack size for any individual thread, call &lt;code&gt;-&amp;gt;create()&lt;/code&gt; with a hash reference as the first argument:</source>
          <target state="translated">要为任何单个线程指定特定的堆栈大小，请调用 &lt;code&gt;-&amp;gt;create()&lt;/code&gt; 并将哈希引用作为第一个参数：</target>
        </trans-unit>
        <trans-unit id="5a3b28c1d56d62a0c685010a78c8616b6f249aaf" translate="yes" xml:space="preserve">
          <source>To specify a real-time timeout, supply the &lt;code&gt;LIFETIME&lt;/code&gt; option with a numeric value. Cached data will expire after this many seconds, and will be looked up afresh when it expires. When a data item is looked up afresh, its lifetime is reset.</source>
          <target state="translated">要指定实时超时，请为 &lt;code&gt;LIFETIME&lt;/code&gt; 选项提供一个数值。缓存的数据将在这几秒钟后过期，并且将在过期后重新查找。重新查找数据项时，将重置其生存期。</target>
        </trans-unit>
        <trans-unit id="75872cec7b7dae2ec30afbe5f15f62f2ed47906e" translate="yes" xml:space="preserve">
          <source>To specify by name, the name of the character or character sequence goes between the curly braces.</source>
          <target state="translated">如果要用名称来指定,则在大括号之间加上字符或字符序列的名称。</target>
        </trans-unit>
        <trans-unit id="e22be0e52c335b1ce8908cd9371ba0e4b96e3022" translate="yes" xml:space="preserve">
          <source>To specify the compression strategy when writing, append 'f' for filtered data, 'h' for Huffman only compression, or 'R' for run-length encoding. If no strategy is specified Z_DEFAULT_STRATEGY is used.</source>
          <target state="translated">要在写入时指定压缩策略,请添加'f'表示过滤数据,'h'表示只压缩Huffman,或'R'表示长度编码。如果没有指定策略,则使用Z_DEFAULT_STRATEGY。</target>
        </trans-unit>
        <trans-unit id="cb8a391550e8914db81270f773f4523451df8b90" translate="yes" xml:space="preserve">
          <source>To speed things up in complex installation scenarios, CPAN.pm keeps track of what it has already done and refuses to do some things a second time. A &lt;code&gt;get&lt;/code&gt; , a &lt;code&gt;make&lt;/code&gt; , and an &lt;code&gt;install&lt;/code&gt; are not repeated. A &lt;code&gt;test&lt;/code&gt; is repeated only if the previous test was unsuccessful. The diagnostic message when CPAN.pm refuses to do something a second time is one of</source>
          <target state="translated">为了加快复杂安装场景中的处理速度，CPAN.pm会跟踪已完成的操作，并拒绝第二次执行某些操作。一个 &lt;code&gt;get&lt;/code&gt; ，一个 &lt;code&gt;make&lt;/code&gt; 和 &lt;code&gt;install&lt;/code&gt; 不重复。一个 &lt;code&gt;test&lt;/code&gt; 重复只有在以前的测试是不成功的。CPAN.pm再次拒绝执行某操作时的诊断消息是以下一种</target>
        </trans-unit>
        <trans-unit id="ee745e8e1ccd43545cce5d6e1098128c6d2cb42b" translate="yes" xml:space="preserve">
          <source>To split a string automatically, as the</source>
          <target state="translated">要自动拆分一个字符串,就像</target>
        </trans-unit>
        <trans-unit id="76a587334bce3d780e4ef5607b4eb7989a44b338" translate="yes" xml:space="preserve">
          <source>To start external programs with complicated command lines (like with pipes in between, and/or quoting of arguments), Perl uses an external shell. With EMX port such shell should be named</source>
          <target state="translated">为了启动带有复杂命令行的外部程序 (比如中间有管道,和/或引用参数),Perl 使用了一个外部 shell。对于 EMX port,这种 shell 的名字应该是</target>
        </trans-unit>
        <trans-unit id="4496b7043de2731c625ff5d9cbb9bfec5778dc82" translate="yes" xml:space="preserve">
          <source>To start perl by clicking on a perl source file, you have to make the according entries in HKCR (see</source>
          <target state="translated">要通过点击一个perl源文件来启动perl,你必须在HKCR中输入相应的条目(见</target>
        </trans-unit>
        <trans-unit id="ed415ca8982026bad9b823bf326a650e9d0848ae" translate="yes" xml:space="preserve">
          <source>To subtract a value from a variable, as in &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt; &amp;rdquo; (meaning to remove 1 from its value) or &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt; by 3&amp;rdquo;.</source>
          <target state="translated">从变量中减去一个值，如&amp;ldquo;减 &lt;code&gt;$x&lt;/code&gt; &amp;rdquo;（表示从其值中删除1）或&amp;ldquo;减 &lt;code&gt;$x&lt;/code&gt; 3&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c34bd44153421ecb4ee7a84a5cf2f9e94314d16d" translate="yes" xml:space="preserve">
          <source>To summarise:</source>
          <target state="translated">概括地说:</target>
        </trans-unit>
        <trans-unit id="bdefe539f6f30e5536e03e0dcfcbf06113e55e75" translate="yes" xml:space="preserve">
          <source>To summarize, here are a number of possible methods for you to consider for storing the mapping between C and the Perl callback</source>
          <target state="translated">总结一下,以下是一些你可以考虑的存储C和Perl回调之间的映射的方法。</target>
        </trans-unit>
        <trans-unit id="87770a145a86a8f01c504f30ba378126d36ae639" translate="yes" xml:space="preserve">
          <source>To summarize, here's what to expect and how to handle locales in XS code:</source>
          <target state="translated">总结一下,以下是在XS代码中处理locale的期望和方法。</target>
        </trans-unit>
        <trans-unit id="9eda1d19cb3d66414653545444049318272d3717" translate="yes" xml:space="preserve">
          <source>To summarize, the &lt;code&gt;\o{}&lt;/code&gt; form is always safe to use, and the other form is safe to use for code points through \077 when you use exactly three digits to specify them.</source>
          <target state="translated">总而言之， &lt;code&gt;\o{}&lt;/code&gt; 格式始终可以安全使用，而当您恰好使用三个数字来指定它们时，另一种格式可以安全地用于\ 077的代码点。</target>
        </trans-unit>
        <trans-unit id="f40c24735c228769cecae3c743dcd1c13b34fed1" translate="yes" xml:space="preserve">
          <source>To summarize, this modifier provides protection for applications that don't wish to be exposed to all of Unicode. Specifying it twice gives added protection.</source>
          <target state="translated">总而言之,这个修饰符为那些不希望暴露在所有Unicode下的应用程序提供保护。两次指定它可以提供额外的保护。</target>
        </trans-unit>
        <trans-unit id="8b52f75bf07c40cc3e2dd50eeec591de76cf40c0" translate="yes" xml:space="preserve">
          <source>To support potentially complex type mappings, if a typemap entry used by an XSUB contains a comment like &lt;code&gt;/*scope*/&lt;/code&gt; then scoping will be automatically enabled for that XSUB.</source>
          <target state="translated">为了支持潜在的复杂类型映射，如果XSUB使用的类型映射条目包含 &lt;code&gt;/*scope*/&lt;/code&gt; 之类的注释，则将自动为该XSUB启用作用域。</target>
        </trans-unit>
        <trans-unit id="c8462b0ae01f912ec184e35a1a54c294d3db9c0b" translate="yes" xml:space="preserve">
          <source>To support these systems a dl_expandspec() function can be implemented either in the</source>
          <target state="translated">为了支持这些系统,dl_expandspec()函数可以在</target>
        </trans-unit>
        <trans-unit id="28ae7b79101a8be6ce604e7c61e718194e3e904d" translate="yes" xml:space="preserve">
          <source>To swap pairs of characters in a string (with even length) one could use several techniques. First, let's use &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; to skip forward and back:</source>
          <target state="translated">要交换字符串中的字符对（长度相等），可以使用多种技术。首先，让我们使用 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;X&lt;/code&gt; 向前和向后跳过：</target>
        </trans-unit>
        <trans-unit id="52ed4dc484d91fd5d94539987c6af1829eb4d58f" translate="yes" xml:space="preserve">
          <source>To switch back to the default behaviour, use</source>
          <target state="translated">要切换回默认行为,使用</target>
        </trans-unit>
        <trans-unit id="9ad4d27e66821295806e39cdf16c87b63c90f1ed" translate="yes" xml:space="preserve">
          <source>To take a closer look at how the engine does optimizations, see the section &lt;a href=&quot;#Pragmas-and-debugging&quot;&gt;Pragmas and debugging&lt;/a&gt; below.</source>
          <target state="translated">要仔细查看引擎如何进行优化，请参见下面的&amp;ldquo; &lt;a href=&quot;#Pragmas-and-debugging&quot;&gt;编译和调试&lt;/a&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="f3651fac40bf38f464aae40f7d0973a874e0f3ea" translate="yes" xml:space="preserve">
          <source>To test that your code is behaving correctly and not modifying COW buffers, on systems that support</source>
          <target state="translated">为了测试你的代码是否正确,是否修改了COW缓冲区,在系统上,支持</target>
        </trans-unit>
        <trans-unit id="8ce0bdd874392ab18a8e9a217e048b7e9971ae31" translate="yes" xml:space="preserve">
          <source>To test whether a variable contains tainted data, and whose use would thus trigger an &quot;Insecure dependency&quot; message, you can use the &lt;code&gt;tainted()&lt;/code&gt; function of the Scalar::Util module, available in your nearby CPAN mirror, and included in Perl starting from the release 5.8.0. Or you may be able to use the following &lt;code&gt;is_tainted()&lt;/code&gt; function.</source>
          <target state="translated">要测试变量是否包含污染数据，并使用该变量会触发&amp;ldquo;不安全依赖项&amp;rdquo;消息，可以使用Scalar :: Util模块的 &lt;code&gt;tainted()&lt;/code&gt; 函数，该函数在您附近的CPAN镜像中可用，并且包含在Perl中从5.8.0版开始。或者您可以使用以下 &lt;code&gt;is_tainted()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="521a49c8c35183a9a627a2f63a5d516c8a7cf5ba" translate="yes" xml:space="preserve">
          <source>To the Perl program that called fork(), all this is designed to be transparent. The parent returns from the fork() with a pseudo-process ID that can be subsequently used in any process-manipulation functions; the child returns from the fork() with a value of &lt;code&gt;0&lt;/code&gt; to signify that it is the child pseudo-process.</source>
          <target state="translated">对于调用fork（）的Perl程序，所有这些都设计为透明的。父级从fork（）返回带有伪进程ID的伪ID，该ID可以随后在任何进程操纵函数中使用。子进程从fork（）返回值为 &lt;code&gt;0&lt;/code&gt; ,以表明它是子进程。</target>
        </trans-unit>
        <trans-unit id="c7e05b4fcf627d6e6c4197f19ffda73a879c664a" translate="yes" xml:space="preserve">
          <source>To the best of our ability, we will attempt to fix critical issues in the two most recent stable 5.x release series. Fixes for the current release series take precedence over fixes for the previous release series.</source>
          <target state="translated">我们将尽我们的能力,尝试修复最近两个稳定的 5.x 版本系列中的关键问题。当前版本系列的修复优先于之前版本系列的修复。</target>
        </trans-unit>
        <trans-unit id="51a0f8c69bc4919eb0f20691df0fe50a577785df" translate="yes" xml:space="preserve">
          <source>To the best of our ability, we will provide &quot;critical&quot; security patches / releases for any major version of Perl whose 5.x.0 release was within the past three years. We can only commit to providing these for the most recent .y release in any 5.x.y series.</source>
          <target state="translated">在我们的能力范围内,我们将为过去三年内发布 5.x.0 版本的任何主要 Perl 版本提供 &quot;关键 &quot;安全补丁/版本。我们只能承诺为任何 5.x.y 系列中最新的 .y 版本提供这些补丁。</target>
        </trans-unit>
        <trans-unit id="6fa12fa0dac95b52f8a74aca03b7455d8e9dea13" translate="yes" xml:space="preserve">
          <source>To throw away the current &lt;b&gt;process&lt;/b&gt;&amp;rsquo;s program and replace it with another, without exiting the process or relinquishing any resources held (apart from the old memory image).</source>
          <target state="translated">丢弃当前&lt;b&gt;进程&lt;/b&gt;的程序并用另一个程序替换，而无需退出该进程或放弃所持有的任何资源（除了旧的内存映像外）。</target>
        </trans-unit>
        <trans-unit id="448a61a17f3cda496b5d3ba49da88ff7c85062ed" translate="yes" xml:space="preserve">
          <source>To transform a bit vector into a string or list of 0's and 1's, use these:</source>
          <target state="translated">要将一个位向量转换为一个0和1的字符串或列表,使用这些。</target>
        </trans-unit>
        <trans-unit id="8d6d675a384b336013b57ff889fd3d31ada57c0a" translate="yes" xml:space="preserve">
          <source>To trim trailing newlines from text lines use &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;. With default settings that function looks for a trailing &lt;code&gt;\n&lt;/code&gt; character and thus trims in a portable way.</source>
          <target state="translated">要修剪文本行中的尾随换行符，请使用 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; 。使用默认设置时，该功能会查找尾随 &lt;code&gt;\n&lt;/code&gt; 字符，从而以可移植的方式进行修剪。</target>
        </trans-unit>
        <trans-unit id="40f27a2565b48c1f61edc1951aa27946b5ec4637" translate="yes" xml:space="preserve">
          <source>To turn a hostname into a human-readable plain IP address use getaddrinfo() to turn the hostname into a list of socket structures, then getnameinfo() on each one to make it a readable IP address again.</source>
          <target state="translated">要把主机名变成一个人类可读的普通IP地址,使用getaddrinfo()把主机名变成一个套接字结构的列表,然后对每个套接字结构进行getnameinfo(),使其再次成为一个可读的IP地址。</target>
        </trans-unit>
        <trans-unit id="f7838aca863be2066e77c33f9ec760e481423363" translate="yes" xml:space="preserve">
          <source>To turn one string representation into another by mapping each character of the source string to its corresponding character in the result string. Not to be confused with translation: for example, Greek</source>
          <target state="translated">通过将源字符串中的每个字符映射到结果字符串中的相应字符,将一个字符串表示转化为另一个字符串表示。不要与翻译相混淆:例如,希腊语的</target>
        </trans-unit>
        <trans-unit id="2796f222a72ab401559f8c49bff573c8aee5f84f" translate="yes" xml:space="preserve">
          <source>To unambiguously refer to the built-in form, precede the built-in name with the special package qualifier &lt;code&gt;CORE::&lt;/code&gt; . For example, saying &lt;code&gt;CORE::open()&lt;/code&gt; always refers to the built-in &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, even if the current package has imported some other subroutine called &lt;code&gt;&amp;amp;open()&lt;/code&gt; from elsewhere. Even though it looks like a regular function call, it isn't: the CORE:: prefix in that case is part of Perl's syntax, and works for any keyword, regardless of what is in the CORE package. Taking a reference to it, that is, &lt;code&gt;\&amp;amp;CORE::open&lt;/code&gt; , only works for some keywords. See &lt;a href=&quot;core&quot;&gt;CORE&lt;/a&gt;.</source>
          <target state="translated">要明确引用内置表单，请在内置名称之前加上特殊的包限定符 &lt;code&gt;CORE::&lt;/code&gt; 。例如，说 &lt;code&gt;CORE::open()&lt;/code&gt; 始终是指内置的 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; ，即使当前程序包已从其他位置导入了称为 &lt;code&gt;&amp;amp;open()&lt;/code&gt; 的其他子例程。即使看起来像常规函数调用，它也不是：在这种情况下，CORE ::前缀是Perl语法的一部分，并且适用于任何关键字，而与CORE包中的内容无关。以它为参考，即 &lt;code&gt;\&amp;amp;CORE::open&lt;/code&gt; ，仅适用于某些关键字。参见&lt;a href=&quot;core&quot;&gt;核心&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="248423c43b116b150a001ee976cc646676062436" translate="yes" xml:space="preserve">
          <source>To uncompress</source>
          <target state="translated">解压</target>
        </trans-unit>
        <trans-unit id="218af45982210497e46e853ffef0192283629105" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.1950&quot; and store the compressed data in the same directory</source>
          <target state="translated">解压&quot;/my/home &quot;目录下所有符合 &quot;*.txt.1950 &quot;的文件,并将压缩后的数据存储在同一目录下。</target>
        </trans-unit>
        <trans-unit id="5ddcb357cfd2b7762051e66890c8b84e7d960611" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.1951&quot; and store the compressed data in the same directory</source>
          <target state="translated">解压&quot;/my/home &quot;目录中所有符合 &quot;*.txt.1951 &quot;的文件,并将压缩后的数据存储在同一目录中。</target>
        </trans-unit>
        <trans-unit id="0e932ba5dc24bfd784757a246bd08027f46d4625" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.Compressed&quot; and store the compressed data in the same directory</source>
          <target state="translated">解压&quot;/my/home &quot;目录下所有符合 &quot;*.txt.Compressed &quot;的文件,并将压缩后的数据存储在同一目录下。</target>
        </trans-unit>
        <trans-unit id="29a087f9cfa51d4e0c2f6a475a11f449e63412aa" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.bz2&quot; and store the compressed data in the same directory</source>
          <target state="translated">解压&quot;/my/home &quot;目录下所有符合 &quot;*.txt.bz2 &quot;的文件,并将压缩后的数据存储在同一目录下。</target>
        </trans-unit>
        <trans-unit id="61aa1a4650d4e1d7c6939abfa456f5aeb3345d9a" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.gz&quot; and store the compressed data in the same directory</source>
          <target state="translated">解压&quot;/my/home &quot;目录下所有符合 &quot;*.txt.gz &quot;的文件,并将压缩后的数据存储在同一目录下。</target>
        </trans-unit>
        <trans-unit id="2754edb3f14d19ed8eebfcca373f83ac4a3282e7" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number between 8 and 15.</source>
          <target state="translated">要解压缩RFC 1950数据流，请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为8到15之间的正数。</target>
        </trans-unit>
        <trans-unit id="44083e3f2b591fd2c77505655cdb2c8f0aceb349" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number.</source>
          <target state="translated">要解压缩RFC 1950数据流，请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为正数。</target>
        </trans-unit>
        <trans-unit id="ceb9d1b68954b1740a461cdcd4976b0e567a28d9" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">要解压缩RFC 1951数据流，请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42e613bd86be8bd3cb751a2f5e9d0b238c337e5e" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP&lt;/code&gt; .</source>
          <target state="translated">要解压缩RFC 1952数据流（即gzip），请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;WANT_GZIP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be309868d7c608c972ac92d2374d84d68bbcff87" translate="yes" xml:space="preserve">
          <source>To understand what kinds of incompatibilities one may expect, and in the rare case that the version of Perl on your machine is older than this document, see the section on &quot;Troubleshooting these Examples&quot; for more information.</source>
          <target state="translated">要了解可能出现的不兼容情况,以及你的机器上的Perl版本比本文档更老的罕见情况,请参见 &quot;排除这些示例的故障 &quot;一节了解更多信息。</target>
        </trans-unit>
        <trans-unit id="6b79315e2daa0488ef5b85ec7b3ded4c1bf9ff5d" translate="yes" xml:space="preserve">
          <source>To understand what the above</source>
          <target state="translated">要了解上述内容</target>
        </trans-unit>
        <trans-unit id="84e6e80a4aa5a302f6ddaa79d242cdcf126f821b" translate="yes" xml:space="preserve">
          <source>To uppercase or lowercase several characters, one might want to use &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; , which will lowercase/uppercase all characters following them, until either the end of the pattern or the next occurrence of &lt;code&gt;\E&lt;/code&gt; , whichever comes first. They provide functionality similar to what the functions &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; provide.</source>
          <target state="translated">要对几个字符进行大写或小写转换，可能要使用 &lt;code&gt;\L&lt;/code&gt; 或 &lt;code&gt;\U&lt;/code&gt; ，它们将对它们后面的所有字符进行小写/大写，直到模式结尾或下一个出现的 &lt;code&gt;\E&lt;/code&gt; （以先到者为准）。它们提供的功能类似于 &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; 提供的功能。</target>
        </trans-unit>
        <trans-unit id="fd3b3ccd26f316b1795adeb89ffff2bedd268ce6" translate="yes" xml:space="preserve">
          <source>To use 'load_remote' or 'autoload_remote', specify at 'use'.</source>
          <target state="translated">要使用'load_remote'或'autoload_remote',请在'use'处指定。</target>
        </trans-unit>
        <trans-unit id="8a5610b8c5bc5858528e5c0711e8cd5aeeeaeb22" translate="yes" xml:space="preserve">
          <source>To use &lt;b&gt;AutoLoader&lt;/b&gt;, the author of a module has to place the definitions of subroutines to be autoloaded after an &lt;code&gt;__END__&lt;/code&gt; token. (See &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;.) The &lt;b&gt;AutoSplit&lt;/b&gt; module can then be run manually to extract the definitions into individual files</source>
          <target state="translated">要使用&lt;b&gt;AutoLoader&lt;/b&gt;，模块的作者必须将要自动加载的子例程的定义 &lt;code&gt;__END__&lt;/code&gt; 标记之后。（请参阅&lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;。）然后可以手动运行&lt;b&gt;AutoSplit&lt;/b&gt;模块，以将定义提取到单个文件中。</target>
        </trans-unit>
        <trans-unit id="d246c1b4a8c6fc55969eb14bc150616f75299064" translate="yes" xml:space="preserve">
          <source>To use Getopt::Long from a Perl program, you must include the following line in your Perl program:</source>
          <target state="translated">要从Perl程序中使用Getopt::Long,你必须在Perl程序中加入以下一行。</target>
        </trans-unit>
        <trans-unit id="6a708529644756357339b6bd4e7ce1cb0f6dc3ee" translate="yes" xml:space="preserve">
          <source>To use a here-document to assign an array, one line per element, you might use an approach like this:</source>
          <target state="translated">要使用here-document来分配一个数组,每个元素一行,你可以使用这样的方法。</target>
        </trans-unit>
        <trans-unit id="d339f8f2813eea011c2650e8b1ed1fdac84e3d1c" translate="yes" xml:space="preserve">
          <source>To use a lexical subroutine from inside the subroutine itself, you must predeclare it. The &lt;code&gt;sub foo {...}&lt;/code&gt; subroutine definition syntax respects any previous &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; or &lt;code&gt;state &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; declaration.</source>
          <target state="translated">要从子例程本身内部使用词汇子例程，必须预先声明它。该 &lt;code&gt;sub foo {...}&lt;/code&gt; 子程序定义语法方面的任何以前 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; 或 &lt;code&gt;state &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; 宣言。</target>
        </trans-unit>
        <trans-unit id="0a6c22616496274a8c0483ef0b81201680edefba" translate="yes" xml:space="preserve">
          <source>To use in your program as a pragma, merely invoke</source>
          <target state="translated">要在你的程序中作为一个pragma使用,只需调用一下</target>
        </trans-unit>
        <trans-unit id="c9702d448044d584ba0f08cf12e0416ad038a1b6" translate="yes" xml:space="preserve">
          <source>To use it more practically, you have to give the names of encodings to check (</source>
          <target state="translated">为了更实际地使用它,你必须给出要检查的编码名称(</target>
        </trans-unit>
        <trans-unit id="22588255917f935bc82a9b5e6907a6c5af5e0773" translate="yes" xml:space="preserve">
          <source>To use the OVERLOAD: keyword, create an XS function which takes three input parameters ( or use the c style '...' definition) like this:</source>
          <target state="translated">要使用OVERLOAD:关键字,创建一个XS函数,它需要三个输入参数(或使用c风格的'...'定义),像这样。</target>
        </trans-unit>
        <trans-unit id="3dc634fc1f1bc1b5d00fde6bff6b384f2eeb3f97" translate="yes" xml:space="preserve">
          <source>To use the Perl you just installed you will need to add a new entry to your PATH environment variable: &lt;code&gt;$INST_TOP\bin&lt;/code&gt; , e.g.</source>
          <target state="translated">要使用刚刚安装的Perl，您需要在PATH环境变量中添加一个新条目： &lt;code&gt;$INST_TOP\bin&lt;/code&gt; ，例如</target>
        </trans-unit>
        <trans-unit id="7bc829cf0e8a5c97f97a31b7c617e9428478c19b" translate="yes" xml:space="preserve">
          <source>To use the forked debugger, you need to have the default display set to an X-11 Server and some environment variables set that Unix expects.</source>
          <target state="translated">要使用分叉调试器,你需要将默认显示设置为X-11服务器,并设置一些Unix期望的环境变量。</target>
        </trans-unit>
        <trans-unit id="fc207fecfdae515e813f72872e49086f5b78c28e" translate="yes" xml:space="preserve">
          <source>To use the module it is necessary to do the following:</source>
          <target state="translated">要使用该模块,需要做以下工作。</target>
        </trans-unit>
        <trans-unit id="dd4bd0185af39ed243608e8976fc475a01dc61d4" translate="yes" xml:space="preserve">
          <source>To use this expiration policy, the user would say</source>
          <target state="translated">要使用这个过期策略,用户会说</target>
        </trans-unit>
        <trans-unit id="538ca1c3044001d3cfa088cc4be7d0f4954981d6" translate="yes" xml:space="preserve">
          <source>To use this method you must have the Digest::MD5 or the MD5 module installed, otherwise this method will return</source>
          <target state="translated">要使用这个方法,你必须安装了Digest::MD5或MD5模块,否则这个方法将回到</target>
        </trans-unit>
        <trans-unit id="b3ee11508a4f000324b572266622a1fcc5b08715" translate="yes" xml:space="preserve">
          <source>To use this performance boost, set the current directory via</source>
          <target state="translated">要使用这个性能提升,可以通过以下方式设置当前目录</target>
        </trans-unit>
        <trans-unit id="38c026c273aff885d8062765e295cb0676868f0f" translate="yes" xml:space="preserve">
          <source>To warn with a simple string message, the &lt;a href=&quot;#warn&quot;&gt;warn&lt;/a&gt; function may be more convenient.</source>
          <target state="translated">要使用简单的字符串消息进行&lt;a href=&quot;#warn&quot;&gt;警告&lt;/a&gt;，警告功能可能更方便。</target>
        </trans-unit>
        <trans-unit id="be15e0c4892f05af6b92d2d4a6be1a0a5f9a6dcd" translate="yes" xml:space="preserve">
          <source>To watch the tail of a dynamically growing logfile, (from the command line):</source>
          <target state="translated">要观察一个动态增长的日志文件的尾巴,(从命令行)。</target>
        </trans-unit>
        <trans-unit id="a70297b48e7206cae4fcb0090dd44f6d0f3207a8" translate="yes" xml:space="preserve">
          <source>To work around this bug, surround the code with a second set of braces. This creates an inner block that defeats the &lt;code&gt;MULTICALL&lt;/code&gt; logic, and does get fresh SVs allocated each time:</source>
          <target state="translated">要变通解决此错误，请用另一组花括号将代码括起来。这将创建一个内部块，该内部块会打败 &lt;code&gt;MULTICALL&lt;/code&gt; 逻辑，并且每次都会获得新分配的SV：</target>
        </trans-unit>
        <trans-unit id="df77a0e9f9993c56d24066721ca0f8c51a0345d4" translate="yes" xml:space="preserve">
          <source>To work around this, set environment variables as part of the</source>
          <target state="translated">要解决这个问题,可以将环境变量设置为环境变量的一部分。</target>
        </trans-unit>
        <trans-unit id="67bc56a45c2b844733bf04f643db3f4d6359ddb1" translate="yes" xml:space="preserve">
          <source>To work with only alphanumeric sequences (including underscores), you might consider</source>
          <target state="translated">要只使用字母数字序列(包括下划线),你可以考虑使用</target>
        </trans-unit>
        <trans-unit id="737fcabd51bb1faacb7059e47b96e0c587be8c5f" translate="yes" xml:space="preserve">
          <source>To write a test for your new (and probably not even done) module, create a new file called</source>
          <target state="translated">要为你的新模块(可能还没有完成)写一个测试,创建一个新的文件,叫做</target>
        </trans-unit>
        <trans-unit id="02bfda7919e7b9ec9d9ea9a01639287be236928c" translate="yes" xml:space="preserve">
          <source>To write platform-independent code, you must use &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; instead, like &lt;code&gt;\N{ESCAPE}&lt;/code&gt; or &lt;code&gt;\N{U+001B}&lt;/code&gt; , see &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">要编写与平台无关的代码，必须改为使用 &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; ，例如 &lt;code&gt;\N{ESCAPE}&lt;/code&gt; 或 &lt;code&gt;\N{U+001B}&lt;/code&gt; ，请参见&lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32379df686c78a3422056dcfb4c9b1da18747d64" translate="yes" xml:space="preserve">
          <source>To yield a usable Perl variable, characters that are not part of the syntax for variables are translated to underscores. For example, &lt;code&gt;--fpp-struct-&lt;a href=&quot;../functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; will set the variable &lt;code&gt;$opt_fpp_struct_return&lt;/code&gt; . Note that this variable resides in the namespace of the calling program, not necessarily &lt;code&gt;main&lt;/code&gt; . For example:</source>
          <target state="translated">为了产生可用的Perl变量，将不属于变量语法的字符转换为下划线。例如，-- &lt;code&gt;--fpp-struct-&lt;a href=&quot;../functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 将设置变量 &lt;code&gt;$opt_fpp_struct_return&lt;/code&gt; 。请注意，此变量位于调用程序的名称空间中，不一定位于 &lt;code&gt;main&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="33224443be18843a7174975c46578d74787bc749" translate="yes" xml:space="preserve">
          <source>Tobias Brox, tobiasb@tobiasb.funcom.com</source>
          <target state="translated">Tobias Brox,tobiasb@tobiasb.funcom.com</target>
        </trans-unit>
        <trans-unit id="ec7a57e5883d57c428d8e15819e5060eeed56435" translate="yes" xml:space="preserve">
          <source>Together, these categories go a long way towards being able to customize a single program to run in many different locations. But there are deficiencies, so keep reading.</source>
          <target state="translated">这些类别加在一起,对于能够定制一个程序在许多不同的地方运行有很大的帮助。但也有不足之处,请继续阅读。</target>
        </trans-unit>
        <trans-unit id="6f1eb05b47fbf56bdd9586b2ff6beeffab4ce59f" translate="yes" xml:space="preserve">
          <source>Together, these two features are intended to replace the historical &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; function, which has (at least) two bugs in it, that cannot easily be fixed without breaking existing programs:</source>
          <target state="translated">这两个功能共同旨在取代历史性的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 函数，该函数具有（至少）两个bug，在不破坏现有程序的情况下不易修复：</target>
        </trans-unit>
        <trans-unit id="5379fd6502d08f80951bb93415834c8443e36cd5" translate="yes" xml:space="preserve">
          <source>Toggle trace mode (see also the &lt;code&gt;AutoTrace&lt;/code&gt; option). Optional argument is the maximum number of levels to trace below the current one; anything deeper than that will be silent.</source>
          <target state="translated">切换跟踪模式（另请参阅&amp;ldquo; &lt;code&gt;AutoTrace&lt;/code&gt; 跟踪&amp;rdquo; 选项）。可选参数是要跟踪的当前级别以下的最大级别数；任何比这更深的东西都将保持沉默。</target>
        </trans-unit>
        <trans-unit id="f422da5828ccca294dcf6d07ee5efb74761f28a1" translate="yes" xml:space="preserve">
          <source>Tokens from Pod::Simple::PullParser</source>
          <target state="translated">来自Pod::Simple::PullParser的代币。</target>
        </trans-unit>
        <trans-unit id="685cbbd2434336a1c0d592cb5e469ec23061ee59" translate="yes" xml:space="preserve">
          <source>Tom Christiansen</source>
          <target state="translated">Tom Christiansen</target>
        </trans-unit>
        <trans-unit id="8be2aa955349ba9da124a5ab00db7e6f88ee861a" translate="yes" xml:space="preserve">
          <source>Tom Christiansen &amp;lt;</source>
          <target state="translated">汤姆&amp;middot;克里斯蒂安森&amp;lt;</target>
        </trans-unit>
        <trans-unit id="5ca9f204e050f14afeeca056eec19f3529541293" translate="yes" xml:space="preserve">
          <source>Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt; wrote this, with occasional kibbitzing from Larry Wall and Jeffrey Friedl in the background.</source>
          <target state="translated">汤姆&amp;middot;克里斯蒂安森（Tom Christiansen）&amp;lt;tchrist@perl.com&amp;gt;写道，偶尔还有拉里&amp;middot;沃尔（Larry Wall）和杰弗里&amp;middot;弗里德尔（Jeffrey Friedl）的嘲讽。</target>
        </trans-unit>
        <trans-unit id="8e134c4a6e79e76b0db622556fcf6a08eb055742" translate="yes" xml:space="preserve">
          <source>Tom Christiansen wrote the original perlfaq then expanded it with the help of Nat Torkington. brian d foy substantially edited and expanded the perlfaq. perlfaq-workers and others have also supplied feedback, patches and corrections over the years.</source>
          <target state="translated">Tom Christiansen撰写了最初的perlfaq,然后在Nat Torkington的帮助下对其进行了扩充。Brian D Foy对perlfaq进行了大量的编辑和扩充。</target>
        </trans-unit>
        <trans-unit id="13f0322dc66b8435d53d03e97ab3bdb9a5e08c67" translate="yes" xml:space="preserve">
          <source>Tom Christiansen wrote the original version of this document. brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; wrote this version. See the individual perlfaq documents for additional copyright information.</source>
          <target state="translated">汤姆&amp;middot;克里斯蒂安森（Tom Christiansen）撰写了本文档的原始版本。brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; 编写了此版本。有关其他版权信息，请参阅各个perlfaq文档。</target>
        </trans-unit>
        <trans-unit id="594631f752605ca51961fa701a3edb58acb263cd" translate="yes" xml:space="preserve">
          <source>Tom Christiansen, &amp;lt;tchrist@perl.com&amp;gt;.</source>
          <target state="translated">汤姆&amp;middot;克里斯蒂安森（Tom Christiansen），&amp;lt;tchrist@perl.com&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="95a03ceecd01437e5e0609dbfa8dc64983a0ce69" translate="yes" xml:space="preserve">
          <source>Tom Christiansen, with occasional vestiges of Larry Wall's original version and suggestions from the Perl Porters.</source>
          <target state="translated">Tom Christiansen,偶尔会有Larry Wall的原始版本的痕迹和Perl Porters的建议。</target>
        </trans-unit>
        <trans-unit id="476ccb2f91007a71136d530d51755067de803643" translate="yes" xml:space="preserve">
          <source>Tom Phoenix, &amp;lt;</source>
          <target state="translated">汤姆&amp;middot;菲尼克斯&amp;lt;</target>
        </trans-unit>
        <trans-unit id="ba42647932e0b5434947f286f404459ce1a76e83" translate="yes" xml:space="preserve">
          <source>Too few records will be retrieved.</source>
          <target state="translated">太少的记录会被检索出来。</target>
        </trans-unit>
        <trans-unit id="0f85c6fbc6b17f4b329c823a126de114fb51f097" translate="yes" xml:space="preserve">
          <source>Too many will be retrieved.</source>
          <target state="translated">太多了会被收回。</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="2f4169d30e0802a9d8a3d39c5549f0963dd393e1" translate="yes" xml:space="preserve">
          <source>Tools &amp;amp; SDK</source>
          <target state="translated">工具和SDK</target>
        </trans-unit>
        <trans-unit id="a00a8f35172e2849241ce00e52e7b7a9a0047d25" translate="yes" xml:space="preserve">
          <source>Top of Form Processing</source>
          <target state="translated">表格处理的顶部</target>
        </trans-unit>
        <trans-unit id="ee80479b0fa9a2d2efdf0ff5851a9a2f37c4056d" translate="yes" xml:space="preserve">
          <source>Top of form processing is handled automatically: if there is insufficient room on the current page for the formatted record, the page is advanced by writing a form feed and a special top-of-page format is used to format the new page header before the record is written. By default, the top-of-page format is the name of the filehandle with &quot;_TOP&quot; appended, or &quot;top&quot; in the current package if the former does not exist. This would be a problem with autovivified filehandles, but it may be dynamically set to the format of your choice by assigning the name to the &lt;code&gt;$^&lt;/code&gt; variable while that filehandle is selected. The number of lines remaining on the current page is in variable &lt;code&gt;$-&lt;/code&gt; , which can be set to &lt;code&gt;0&lt;/code&gt; to force a new page.</source>
          <target state="translated">表单顶部的处理是自动进行的：如果当前页面上没有足够的空间容纳格式化记录，则通过编写表单提要来推进页面的前进，并使用特殊的页面顶部格式来格式化新页面的页眉。记录被写入。默认情况下，页面顶部格式是附加了&amp;ldquo; _TOP&amp;rdquo;的文件句柄的名称，如果当前包不存在，则为当前包中的&amp;ldquo;顶部&amp;rdquo;。这是自动文件句柄的问题，但可以通过在选择该文件句柄时将名称分配给 &lt;code&gt;$^&lt;/code&gt; 变量来将其动态设置为您选择的格式。当前页面上剩余的行数在变量 &lt;code&gt;$-&lt;/code&gt; 中，可以将其设置为 &lt;code&gt;0&lt;/code&gt; 以强制进入新页面。</target>
        </trans-unit>
        <trans-unit id="9d8d0feb3edb0eff1e9ffe23486e4f54336c8d4e" translate="yes" xml:space="preserve">
          <source>Top-of-form processing is by default handled by a format with the same name as the current filehandle with &quot;_TOP&quot; concatenated to it. It's triggered at the top of each page. See &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;.</source>
          <target state="translated">默认情况下，格式顶部处理由与当前文件句柄同名的格式处理，并带有&amp;ldquo; _TOP&amp;rdquo;。它在每个页面的顶部触发。见&lt;a href=&quot;functions/write&quot;&gt;写&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="855b740deb0e234d1668b8ec10c825eb8a3450f0" translate="yes" xml:space="preserve">
          <source>Total CPU (User + System) of any children processes.</source>
          <target state="translated">任何子进程的CPU总量(用户+系统)。</target>
        </trans-unit>
        <trans-unit id="3481164ed61c4f3a7713de67224c54bcab0e71f6" translate="yes" xml:space="preserve">
          <source>Total CPU (User + System) of the main (parent) process.</source>
          <target state="translated">主(父)进程的CPU总量(用户+系统)。</target>
        </trans-unit>
        <trans-unit id="1e2c196e8d42960075bf83565f85bd785a488f4c" translate="yes" xml:space="preserve">
          <source>Total CPU of parent and any children processes.</source>
          <target state="translated">父进程和任何子进程的CPU总量。</target>
        </trans-unit>
        <trans-unit id="4b32a7b148f732eb014244c4bbbcbbea6216c149" translate="yes" xml:space="preserve">
          <source>Trace mode (similar to &lt;code&gt;t&lt;/code&gt; command, but can be put into &lt;code&gt;PERLDB_OPTS&lt;/code&gt; ).</source>
          <target state="translated">跟踪模式（类似于 &lt;code&gt;t&lt;/code&gt; 命令，但可以放入 &lt;code&gt;PERLDB_OPTS&lt;/code&gt; 中）。</target>
        </trans-unit>
        <trans-unit id="4d8c4db1a294c0162454110ac7c8472297017033" translate="yes" xml:space="preserve">
          <source>Trace through execution of &lt;code&gt;expr&lt;/code&gt; . Optional first argument is the maximum number of levels to trace below the current one; anything deeper than that will be silent. See &lt;a href=&quot;perldebguts#Frame-Listing-Output-Examples&quot;&gt;Frame Listing Output Examples in perldebguts&lt;/a&gt; for examples.</source>
          <target state="translated">通过执行 &lt;code&gt;expr&lt;/code&gt; 进行跟踪。可选的第一个参数是要跟踪的当前级别以下的最大级别数；任何比这更深的东西都将保持沉默。有关&lt;a href=&quot;perldebguts#Frame-Listing-Output-Examples&quot;&gt;示例，&lt;/a&gt;请参见perldebguts中的框架列表输出示例。</target>
        </trans-unit>
        <trans-unit id="24be5dbb481a63442832782f4da3ef4f0dc024ff" translate="yes" xml:space="preserve">
          <source>Trace variable used when Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch. This is the C variable which corresponds to Perl's $DB::trace variable. See &lt;code&gt;PL_DBsingle&lt;/code&gt; .</source>
          <target state="translated">使用&lt;b&gt;-d&lt;/b&gt;开关在Perl以调试模式运行时使用的跟踪变量。这是C变量，它对应于Perl的$ DB :: trace变量。参见 &lt;code&gt;PL_DBsingle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="411aea8f76aef96f5e36c8b291c19e9ceb9466d1" translate="yes" xml:space="preserve">
          <source>Traces changes to Perl's interpreter state. You can internalize this as tracing changes to Perl's &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; variable, especially since the values for &lt;code&gt;NEWPHASE&lt;/code&gt; and &lt;code&gt;OLDPHASE&lt;/code&gt; are the strings that &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; reports.</source>
          <target state="translated">跟踪更改到Perl的解释器状态。您可以将其内部化，以跟踪对Perl的 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 变量的更改，尤其是因为 &lt;code&gt;NEWPHASE&lt;/code&gt; 和 &lt;code&gt;OLDPHASE&lt;/code&gt; 的值是 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 报告的字符串。</target>
        </trans-unit>
        <trans-unit id="0786ec1507cde8f738cd5528e03a2b67d40c8c91" translate="yes" xml:space="preserve">
          <source>Traces the entry of any subroutine. Note that all of the variables refer to the subroutine that is being invoked; there is currently no way to get ahold of any information about the subroutine's</source>
          <target state="translated">追踪任何子程序的进入。请注意,所有的变量都是指正在被调用的子程序;目前还没有办法获得任何关于子程序的信息。</target>
        </trans-unit>
        <trans-unit id="9f47af59eb569759ff1e8a42a52da14fba8b1705" translate="yes" xml:space="preserve">
          <source>Traces the execution of each opcode in the Perl runloop. This probe is fired before the opcode is executed. When the Perl debugger is enabled, the DTrace probe is fired</source>
          <target state="translated">追踪Perl runloop中每个操作码的执行情况。该探针在操作码执行之前被触发。当启用Perl调试器时,DTrace探针会被触发。</target>
        </trans-unit>
        <trans-unit id="bbb01fbe6bfaaec090a44633982fb31ae18d0d39" translate="yes" xml:space="preserve">
          <source>Traces the exit of any subroutine. Note that all of the variables refer to the subroutine that is returning; there is currently no way to get ahold of any information about the subroutine's</source>
          <target state="translated">追踪任何子程序的退出。请注意,所有的变量都是指正在返回的子程序;目前还没有办法获得任何关于子程序的信息。</target>
        </trans-unit>
        <trans-unit id="469260e080c9b35d7ee5b388f5235f91978c75b9" translate="yes" xml:space="preserve">
          <source>Traditional form:</source>
          <target state="translated">传统形式。</target>
        </trans-unit>
        <trans-unit id="0ad67b0aa9abbb10a0d4b2ca67f1c4ff5d61a0ed" translate="yes" xml:space="preserve">
          <source>Traditionally END blocks have been executed at the end of the perl_run. This causes problems for applications that never call perl_run. Since perl 5.7.2 you can specify &lt;code&gt;PL_exit_flags |= PERL_EXIT_DESTRUCT_END&lt;/code&gt; to get the new behaviour. This also enables the running of END blocks if the perl_parse fails and &lt;code&gt;perl_destruct&lt;/code&gt; will return the exit value.</source>
          <target state="translated">传统上，END块是在perl_run的末尾执行的。这会给永不调用perl_run的应用程序带来问题。从perl 5.7.2开始，您可以指定 &lt;code&gt;PL_exit_flags |= PERL_EXIT_DESTRUCT_END&lt;/code&gt; 以获取新的行为。如果perl_parse失败并且 &lt;code&gt;perl_destruct&lt;/code&gt; 将返回退出值，这还将启用END块的运行。</target>
        </trans-unit>
        <trans-unit id="0f62d4679a2de6656186513ec5b0145dfd0852c8" translate="yes" xml:space="preserve">
          <source>Traditionally in Perl, any use of any of the three variables &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; (or their &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; English&lt;/code&gt; equivalents) anywhere in the code, caused all subsequent successful pattern matches to make a copy of the matched string, in case the code might subsequently access one of those variables. This imposed a considerable performance penalty across the whole program, so generally the use of these variables has been discouraged.</source>
          <target state="translated">传统上，在Perl中，对代码中任何位置的三个变量 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 或 &lt;code&gt;$'&lt;/code&gt; 中的任何一个的使用（或它们 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; English&lt;/code&gt; 等效项）都会导致所有后续的成功模式匹配生成匹配字符串的副本，以防代码随后可能会访问这些变量之一。这对整个程序造成了相当大的性能损失，因此通常不鼓励使用这些变量。</target>
        </trans-unit>
        <trans-unit id="edc1e4ae8cd5bdd4ef52be4cd619be47a1e80306" translate="yes" xml:space="preserve">
          <source>Traditionally the result is a string of 13 bytes: two first bytes of the salt, followed by 11 bytes from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt;, and only the first eight bytes of PLAINTEXT mattered. But alternative hashing schemes (like MD5), higher level security schemes (like C2), and implementations on non-Unix platforms may produce different strings.</source>
          <target state="translated">传统上，结果是一个13字节的字符串：salt的两个前字节，然后是集合 &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; 中的11个字节，仅PLAINTEXT的前八个字节很重要。但是替代的哈希方案（如MD5），更高级别的安全方案（如C2）以及在非Unix平台上的实现可能会产生不同的字符串。</target>
        </trans-unit>
        <trans-unit id="366ba2d0971221ce62e3e700bb5e4027a597313b" translate="yes" xml:space="preserve">
          <source>Traditionally, Perl has captured the value of the variable at that point and turned the subroutine into a constant eligible for inlining. In those cases where the variable can be modified elsewhere, this breaks the behavior of closures, in which the subroutine captures the variable itself, rather than its value, so future changes to the variable are reflected in the subroutine's return value.</source>
          <target state="translated">传统上,Perl在这一点上捕获了变量的值,并将子程序变成了一个符合内联条件的常量。在那些变量可以在其他地方修改的情况下,这就打破了闭包的行为,在闭包中,子程序捕获的是变量本身,而不是它的值,因此未来对变量的改变会反映在子程序的返回值中。</target>
        </trans-unit>
        <trans-unit id="77c289ba4e5a8332a82b92e0a687ee8832b65763" translate="yes" xml:space="preserve">
          <source>Traditionally, the Perl function &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; rounds to 0 (see &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;), and so for floating-point-like types one should follow the same semantic.</source>
          <target state="translated">传统上，Perl函数将 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 四舍五入为0（请参阅&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;），因此对于类浮点类型，应遵循相同的语义。</target>
        </trans-unit>
        <trans-unit id="b2c93accaaddf881f0426884fd5fb319c6e78ef4" translate="yes" xml:space="preserve">
          <source>Traditionally, the definition of an inside-out class contains a bare block inside which a number of lexical hashes are declared and the basic accessor methods defined, usually through &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; . Further methods may be defined outside this block. There has to be a DESTROY method and, for thread support, a CLONE method.</source>
          <target state="translated">传统上，由内而外的类的定义包含一个裸露的块，该块中声明了许多词汇哈希，并定义了基本的访问器方法，通常通过 &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; 。可以在此块之外定义其他方法。必须有一个DESTROY方法，并且为了线程支持，必须有一个CLONE方法。</target>
        </trans-unit>
        <trans-unit id="56e30fa719825fef87897a9b73f8c643d6e27859" translate="yes" xml:space="preserve">
          <source>Traditionally, typemaps needed to be written to a separate file, conventionally called &lt;code&gt;typemap&lt;/code&gt; in a CPAN distribution. With ExtUtils::ParseXS (the XS compiler) version 3.12 or better which comes with perl 5.16, typemaps can also be embedded directly into XS code using a HERE-doc like syntax:</source>
          <target state="translated">传统上，类型映射需要写入一个单独的文件，在CPAN分发中通常称为类型 &lt;code&gt;typemap&lt;/code&gt; 。使用Perl 5.16附带的ExtUtils :: ParseXS（XS编译器）3.12或更高版本，也可以使用类似HERE-doc的语法将类型映射直接嵌入XS代码中：</target>
        </trans-unit>
        <trans-unit id="b116d15c8d0f591aea30acc14d32c8151254d15b" translate="yes" xml:space="preserve">
          <source>Transfer file in ASCII. CRLF translation will be done if required</source>
          <target state="translated">以ASCII码传输文件。如有需要,将进行CRLF翻译。</target>
        </trans-unit>
        <trans-unit id="19b93b66a9a164099cf4c3e60d4b5f7a2c5a7780" translate="yes" xml:space="preserve">
          <source>Transfer file in binary mode. No transformation will be done.</source>
          <target state="translated">以二进制模式传输文件。不会进行转换。</target>
        </trans-unit>
        <trans-unit id="71b54b146f4723aa8db4c8d0ffb0816f4aee31ad" translate="yes" xml:space="preserve">
          <source>Transforms the current application into a PM application and back. The argument true means that a real message loop is going to be served. OS2::MorphPM() returns the PM message queue handle as an integer.</source>
          <target state="translated">将当前应用程序转换为PM应用程序并返回。参数true表示将提供一个真正的消息循环。OS2::MorphPM()以整数形式返回 PM 消息队列句柄。</target>
        </trans-unit>
        <trans-unit id="3ab5267ee01682b79d53eef55a6ec4c6169897d2" translate="yes" xml:space="preserve">
          <source>Translate logical name DCL$PATH as a searchlist, rather than trying to &lt;code&gt;&lt;a href=&quot;../../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; string value of &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; .</source>
          <target state="translated">将逻辑名称DCL $ PATH转换为搜索列表，而不是尝试 &lt;code&gt;&lt;a href=&quot;../../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; 字符串值。</target>
        </trans-unit>
        <trans-unit id="4df3684f8e1af9f3d36ff43ec1a39944ea62d252" translate="yes" xml:space="preserve">
          <source>Translates a Windows path to the corresponding cygwin path respecting the current mount points. With a second non-null argument returns an absolute path. Double-byte characters will not be translated.</source>
          <target state="translated">在尊重当前挂载点的前提下,将Windows路径转换为相应的cygwin路径。如果使用第二个非空参数,则返回一个绝对路径。双字节字符不会被翻译。</target>
        </trans-unit>
        <trans-unit id="43c8972cdf7cbd4964f60ea0553934fab0c0bfe0" translate="yes" xml:space="preserve">
          <source>Translates a Windows pid to the corresponding cygwin pid (if any).</source>
          <target state="translated">将Windows pid翻译成对应的cygwin pid(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="582d5dcb01cd3d8be49a7bc9c562cc61d6d3a8c7" translate="yes" xml:space="preserve">
          <source>Translates a cygwin path to the corresponding cygwin path respecting the current mount points. With a second non-null argument returns an absolute path. Double-byte characters will not be translated.</source>
          <target state="translated">将一个cygwin路径翻译成与当前挂载点相对应的cygwin路径。如果使用第二个非空参数,则返回一个绝对路径。双字节字符不会被翻译。</target>
        </trans-unit>
        <trans-unit id="d0b7e8b1f9fa64e7df02a610ac8f751cbf79794f" translate="yes" xml:space="preserve">
          <source>Translates a cygwin pid to the corresponding Windows pid (which may or may not be the same).</source>
          <target state="translated">将一个cygwin pid翻译成对应的Windows pid(可能是或可能不是相同的)。</target>
        </trans-unit>
        <trans-unit id="3cb9f5d38a91da3cb24f8ddc9ee0b78bc3316e7d" translate="yes" xml:space="preserve">
          <source>Translates the template as before except that a directory name is specified.</source>
          <target state="translated">除了指定目录名外,其他都和之前一样翻译模板。</target>
        </trans-unit>
        <trans-unit id="0e0c59b2d3a94d773b16fba8c10f9e6b9a4c8d83" translate="yes" xml:space="preserve">
          <source>Translators are available for converting Pod to various formats like plain text, HTML, man pages, and more.</source>
          <target state="translated">翻译器可用于将Pod转换为各种格式,如纯文本、HTML、man pages等。</target>
        </trans-unit>
        <trans-unit id="3d02c52d09a4e30f9d862205070306d13e0fd4bf" translate="yes" xml:space="preserve">
          <source>Translators may request clarification of the situation in which a particular phrase is found. For example, in English we are entirely happy saying &quot;</source>
          <target state="translated">译者可以要求对某一短语的情况进行澄清。例如,在英语中,我们完全乐意说&quot;</target>
        </trans-unit>
        <trans-unit id="7cec7716cf837c5d26e64202c8e48b66fd1ee111" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to &amp;amp;#NNN; where NNN is the decimal Unicode code point.</source>
          <target state="translated">编码为＆＃NNN;时缺少音译字符 其中NNN是十进制Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="4a944de5b3bc5a013582ea0515548fdc64b85e91" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to &amp;amp;#xHHHH; where HHHH is the hexadecimal Unicode code point.</source>
          <target state="translated">编码为＆＃xHHHH;时缺少音译字符 其中HHHH是十六进制Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="7531ab4c38b927cd6bd26046089b6f931f4b9669" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to \x{HHHH} where HHHH is the hexadecimal Unicode code point.</source>
          <target state="translated">将编码中缺失的字符转写为 \x{HHHH},其中HHHH是十六进制Unicode码点。</target>
        </trans-unit>
        <trans-unit id="778ddecb6dcc9c5eac19efad6822ed838d8cfd37" translate="yes" xml:space="preserve">
          <source>Transliterates all occurrences of the characters found in the search list with the corresponding character in the replacement list. It returns the number of characters replaced or deleted. If no string is specified via the &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator, the &lt;code&gt;$_&lt;/code&gt; string is transliterated.</source>
          <target state="translated">用替换列表中的相应字符对所有出现在搜索列表中的字符进行音译。它返回替换或删除的字符数。如果没有通过 &lt;code&gt;=~&lt;/code&gt; 或 &lt;code&gt;!~&lt;/code&gt; 运算符指定任何字符串，则 &lt;code&gt;$_&lt;/code&gt; 字符串将被音译。</target>
        </trans-unit>
        <trans-unit id="420a5e0771ab4a0b9e610c4b35eccba70828962b" translate="yes" xml:space="preserve">
          <source>Transparent BigInteger support for Perl</source>
          <target state="translated">为Perl提供透明的BigInteger支持</target>
        </trans-unit>
        <trans-unit id="7267fd5dd0f2d5cad0d4fdfbc6f406231fbc74c7" translate="yes" xml:space="preserve">
          <source>Transparent BigNumber support for Perl</source>
          <target state="translated">为Perl提供透明的BigNumber支持</target>
        </trans-unit>
        <trans-unit id="d53f15081d775673dd122d267a0fda505ffa50fe" translate="yes" xml:space="preserve">
          <source>Transparent BigNumber/BigRational support for Perl</source>
          <target state="translated">为Perl提供透明的BigNumber/BigRational支持。</target>
        </trans-unit>
        <trans-unit id="1320fa0059bd04032c977af604f63823046e2bca" translate="yes" xml:space="preserve">
          <source>Trappable errors may be trapped using the eval operator. See &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;. In almost all cases, warnings may be selectively disabled or promoted to fatal errors using the &lt;code&gt;warnings&lt;/code&gt; pragma. See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">可以使用eval运算符捕获可陷阱错误。参见&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;。在几乎所有情况下，都可以使用 &lt;code&gt;warnings&lt;/code&gt; 实用程序选择性地禁用警告或将警告升级为致命错误。请参阅&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f10d4d7cb6294c3306a64ba2969b74200be2428" translate="yes" xml:space="preserve">
          <source>Traverse a directory tree.</source>
          <target state="translated">遍历一个目录树。</target>
        </trans-unit>
        <trans-unit id="b2a99160c9547d1ab75aaa55623e70b1b8573818" translate="yes" xml:space="preserve">
          <source>Treat string as multiple lines. That is, change &quot;^&quot; and &quot;$&quot; from matching the start of the string's first line and the end of its last line to matching the start and end of each line within the string.</source>
          <target state="translated">将字符串视为多行。也就是说,将&quot;^&quot;和&quot;$&quot;从匹配字符串第一行的开始和最后一行的结束改为匹配字符串内每一行的开始和结束。</target>
        </trans-unit>
        <trans-unit id="93fa15e2fd4bd3f0707530f7f374f8fd00c44547" translate="yes" xml:space="preserve">
          <source>Treat string as single line. That is, change &quot;.&quot; to match any character whatsoever, even a newline, which normally it would not match.</source>
          <target state="translated">将字符串视为单行。也就是说,将&quot;.&quot;改为匹配任何字符,即使是换行符,通常也不会匹配。</target>
        </trans-unit>
        <trans-unit id="369a3fe575602256c74f237530b2066156aadc25" translate="yes" xml:space="preserve">
          <source>Treats ARRAY as a stack by appending the values of LIST to the end of ARRAY. The length of ARRAY increases by the length of LIST. Has the same effect as</source>
          <target state="translated">将ARRAY作为堆栈处理,将LIST的值追加到ARRAY的最后。ARRAY的长度按LIST的长度增加。与</target>
        </trans-unit>
        <trans-unit id="4c2b22d2044144acb2e177299ffb0546b35d1302" translate="yes" xml:space="preserve">
          <source>Treats the complete zip file/buffer as a single compressed data stream. When reading in multi-stream mode each member of the zip file/buffer will be uncompressed in turn until the end of the file/buffer is encountered.</source>
          <target state="translated">将完整的zip文件/缓冲区作为一个单一的压缩数据流处理,当以多流模式读取时,zip文件/缓冲区的每个成员将依次被解压,直到文件/缓冲区结束。当以多流模式读取时,ZIP文件/缓冲区的每个成员将依次被解压缩,直到遇到文件/缓冲区的末端。</target>
        </trans-unit>
        <trans-unit id="9170df3df869288dce7be7560494463cb05b5488" translate="yes" xml:space="preserve">
          <source>Treats the return value of the code block as the condition.</source>
          <target state="translated">将代码块的返回值作为条件。</target>
        </trans-unit>
        <trans-unit id="076fbc2c1d84c79c360a6aaf693ed414200277af" translate="yes" xml:space="preserve">
          <source>Treats the string in EXPR as a bit vector made up of elements of width BITS and returns the value of the element specified by OFFSET as an unsigned integer. BITS therefore specifies the number of bits that are reserved for each element in the bit vector. This must be a power of two from 1 to 32 (or 64, if your platform supports that).</source>
          <target state="translated">将EXPR中的字符串视为由宽度为BITS的元素组成的位向量,并将OFFSET指定的元素值作为无符号整数返回。因此,BITS指定了位向量中每个元素的保留位数。这个数字必须是1到32(或者64,如果你的平台支持的话)的2次幂。</target>
        </trans-unit>
        <trans-unit id="74c726e22e1ef4f0ff5d0f342fa4b671a8d7e3e6" translate="yes" xml:space="preserve">
          <source>Tree Contents</source>
          <target state="translated">树木内容</target>
        </trans-unit>
        <trans-unit id="bc924ad99a31c83efb674a21a76798fdb63e8535" translate="yes" xml:space="preserve">
          <source>Tries to &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; the given $module or $file. If it loads successfully, the test will pass. Otherwise it fails and displays the load error.</source>
          <target state="translated">尝试 &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 给定的$ module或$ file。如果加载成功，则测试将通过。否则，它将失败并显示加载错误。</target>
        </trans-unit>
        <trans-unit id="82437a05f154f78a4ae190392aa21b46338d0c97" translate="yes" xml:space="preserve">
          <source>Tries to uses &lt;a href=&quot;../../../ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt; &amp;amp; &lt;a href=&quot;../../../io/select&quot;&gt;IO::Select&lt;/a&gt; to communicate with the spawned process if they are available. Falls back onto &lt;code&gt;&lt;a href=&quot;../../../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尝试使用&lt;a href=&quot;../../../ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt;＆&lt;a href=&quot;../../../io/select&quot;&gt;IO :: Select&lt;/a&gt;与产生的进程进行通信（如果可用）。退回到 &lt;code&gt;&lt;a href=&quot;../../../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0328d99f96d6b6cb2e5370be4979de91fb2ea44" translate="yes" xml:space="preserve">
          <source>Triggered by a delete from %^H, records the key to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; .</source>
          <target state="translated">由％^ H删除触发，将密钥记录到 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce25e5857867e6310e792d455213353087781834" translate="yes" xml:space="preserve">
          <source>Triggered by a store to %^H, records the key/value pair to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; . It is assumed that hints aren't storing anything that would need a deep copy. Maybe we should warn if we find a reference.</source>
          <target state="translated">由商店触发％^ H，将键/值对记录到 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 。假定提示没有存储任何需要深层复制的内容。如果找到参考，也许我们应该警告。</target>
        </trans-unit>
        <trans-unit id="5e62fd5a7239de339d5bd00c0d3006bd6b133b17" translate="yes" xml:space="preserve">
          <source>Triggered by clearing %^H, resets &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; .</source>
          <target state="translated">通过清除％^ H触发，重置 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="translated">三角函数</target>
        </trans-unit>
        <trans-unit id="ce550b5479caa5cd0ed1b0d59ad15c9773c7bcdb" translate="yes" xml:space="preserve">
          <source>Trilogy, &lt;code&gt;In the beginning the
Universe was created. This has made a lot of people very angry and
been widely regarded as a bad move&lt;/code&gt; . Their mistake was not of this magnitude so let's forgive them.</source>
          <target state="translated">三部曲， &lt;code&gt;In the beginning the Universe was created. This has made a lot of people very angry and been widely regarded as a bad move&lt;/code&gt; 。他们的错误不是那么严重，所以让我们原谅他们。</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="28e5d7df36d1a6dde25f3c09a31821344957a89c" translate="yes" xml:space="preserve">
          <source>Troubleshooting these Examples</source>
          <target state="translated">解决这些例子的问题</target>
        </trans-unit>
        <trans-unit id="95a9fcae6cc7c433c5ecb181677d9e65f088ed3c" translate="yes" xml:space="preserve">
          <source>Tru64 5.1 documentation on syslog, &lt;a href=&quot;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&quot;&gt;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&lt;/a&gt;</source>
          <target state="translated">Syslog上的Tru64 5.1文档，&lt;a href=&quot;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&quot;&gt;http：//h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9109071ad135094f2373ecd2b94d8dc48e87efa6" translate="yes" xml:space="preserve">
          <source>True if an external</source>
          <target state="translated">如果一个外部</target>
        </trans-unit>
        <trans-unit id="f3a74362a5094d39f2b42a3da4ab4b28a9691928" translate="yes" xml:space="preserve">
          <source>True if on an OS where qx operator (or backticks) can redirect &lt;code&gt;STDERR&lt;/code&gt; onto &lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="translated">如果在qx运算符（或反引号）可以将 &lt;code&gt;STDERR&lt;/code&gt; 重定向到 &lt;code&gt;STDOUT&lt;/code&gt; 的操作系统上，则为true 。</target>
        </trans-unit>
        <trans-unit id="52369ee8420cce3f1adcdcc979064876449bf33b" translate="yes" xml:space="preserve">
          <source>True if the socket is currently positioned at the urgent data mark, false otherwise.</source>
          <target state="translated">如果当前套接字定位在紧急数据标记处,则为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="263df4a03022b2922b4599d5befe15e4f094944e" translate="yes" xml:space="preserve">
          <source>True if the source has meta data.</source>
          <target state="translated">如果源有元数据,则为真。</target>
        </trans-unit>
        <trans-unit id="001c945275af8c53e929fc8bb52b9331e9fa2beb" translate="yes" xml:space="preserve">
          <source>True if this op will be the return value of an lvalue subroutine</source>
          <target state="translated">如果这个操作是一个lvalue子程序的返回值,则为true。</target>
        </trans-unit>
        <trans-unit id="a225ab817ea7fa5d168aaeda6fa091c3d9bf26a1" translate="yes" xml:space="preserve">
          <source>True is returned if the file name begins with &lt;code&gt;drive_letter:&lt;/code&gt; , and if not, File::Spec::Unix file_name_is_absolute() is called.</source>
          <target state="translated">如果文件名以 &lt;code&gt;drive_letter:&lt;/code&gt; 开头，则返回True ，否则，返回File :: Spec :: Unix file_name_is_absolute（）。</target>
        </trans-unit>
        <trans-unit id="714a51854b847f734d4ad3e61a135b245522aeae" translate="yes" xml:space="preserve">
          <source>True while the most recent result was a TODO. Becomes true before the TODO result is returned and stays true until just before the next non- TODO test is returned.</source>
          <target state="translated">当最近的结果是TODO时为真。在TODO结果返回之前变为真,并保持真,直到下一个非TODO测试返回之前。</target>
        </trans-unit>
        <trans-unit id="1aceee4ee4f49927d115b3fc82be6c512d7c286c" translate="yes" xml:space="preserve">
          <source>True/false results are never tainted.</source>
          <target state="translated">真/假结果永远不会被污染。</target>
        </trans-unit>
        <trans-unit id="f8dc96e0b59ea3e8174d5b669fb89eb4295305d3" translate="yes" xml:space="preserve">
          <source>Truncate $x to an integer value.</source>
          <target state="translated">将$x截断为一个整数值。</target>
        </trans-unit>
        <trans-unit id="11625b03167a879105d56ac5232340fe7c1e8727" translate="yes" xml:space="preserve">
          <source>Truncate file suggested by open mode.</source>
          <target state="translated">按打开模式建议截断文件。</target>
        </trans-unit>
        <trans-unit id="69983876ff90a7fef773e08a772b817cd9bc808d" translate="yes" xml:space="preserve">
          <source>Truncates the file opened on FILEHANDLE, or named by EXPR, to the specified length. Raises an exception if truncate isn't implemented on your system. Returns true if successful, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="translated">将在FILEHANDLE上打开的文件或由EXPR命名的文件截断为指定的长度。如果未在系统上实现截断，则引发异常。如果成功，则返回true，否则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6b7268dfdb3e49fbc8b9714eadb8dee9d853cfb" translate="yes" xml:space="preserve">
          <source>Truncates the file opened on FILEHANDLE, or named by EXPR, to the specified length. Raises an exception if truncate isn't implemented on your system. Returns true if successful, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="translated">将在FILEHANDLE上打开的文件或由EXPR命名的文件截断为指定的长度。如果未在系统上实现截断，则引发异常。如果成功，则返回true，否则返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2975c0f92fcae4101065548cc1a5e6bfa7744574" translate="yes" xml:space="preserve">
          <source>Truncation to same-or-shorter lengths only. (VOS)</source>
          <target state="translated">只截断到相同或较短的长度。(VOS)</target>
        </trans-unit>
        <trans-unit id="07fcbd4e35869ee7c3769699235ad97c3caf7ea4" translate="yes" xml:space="preserve">
          <source>Truth and Falsehood</source>
          <target state="translated">真相与假象</target>
        </trans-unit>
        <trans-unit id="0ea36a88c9652f7de32e4b8cdc539660f9c8bb67" translate="yes" xml:space="preserve">
          <source>Truth. (&lt;code&gt;PL_sv_yes&lt;/code&gt; ) The value is not needed (and ignored).</source>
          <target state="translated">真相。（ &lt;code&gt;PL_sv_yes&lt;/code&gt; ）不需要（忽略）该值。</target>
        </trans-unit>
        <trans-unit id="820aa128934b824418f5ca61678f5828e0a9f3f1" translate="yes" xml:space="preserve">
          <source>Try 'which ld' and 'which ld' (or try 'ar --version' and 'ld --version', which work only for the GNU tools, and will announce themselves to be such), and adjust your PATH so that you are consistently using either the native tools or the GNU tools. After fixing your PATH, you should do 'make distclean' and start all the way from running the Configure since you may have quite a confused situation.</source>
          <target state="translated">试试 &quot;which ld &quot;和 &quot;which ld&quot;(或者试试 &quot;ar --version &quot;和 &quot;ld --version&quot;,它们只对GNU工具有效,而且会自报家门),然后调整你的PATH,使你始终使用本地工具或GNU工具。修正PATH后,你应该执行'make distclean',然后从运行Configure开始,因为你可能会遇到相当混乱的情况。</target>
        </trans-unit>
        <trans-unit id="dfec8d0f349c3c42fb9d1815573a589ac82ef522" translate="yes" xml:space="preserve">
          <source>Try and match a closing delimiter bracket. If the bracket was the same species as the last opening bracket, return the substring to that point. If the bracket was mismatched, return an error.</source>
          <target state="translated">试着匹配一个关闭的分隔符括号。如果括号与最后一个打开的括号是同一物种,返回到该点的子串。如果括号不匹配,则返回一个错误。</target>
        </trans-unit>
        <trans-unit id="3534e8ec8243f82da173a0a961f29a6061ccc5a4" translate="yes" xml:space="preserve">
          <source>Try every conceivable way to get hostname</source>
          <target state="translated">尝试所有能想到的方法来获取主机名。</target>
        </trans-unit>
        <trans-unit id="dfea66ec3b5d472c8a85f9f4143d2c2a2932e7a3" translate="yes" xml:space="preserve">
          <source>Try hard not to exceed 79-columns</source>
          <target state="translated">尽量不要超过79列</target>
        </trans-unit>
        <trans-unit id="71156f6966e318bbb69b3350da865612c3413590" translate="yes" xml:space="preserve">
          <source>Try keeping around the seekpointer and go there, like this:</source>
          <target state="translated">试着保持在seekpointer周围,然后去那里,像这样。</target>
        </trans-unit>
        <trans-unit id="5ab49ef558819708ac26895c52750c3610705d02" translate="yes" xml:space="preserve">
          <source>Try not to launch headlong into developing your module without spending some time thinking first. A little forethought may save you a vast amount of effort later on.</source>
          <target state="translated">尽量不要在没有先花一些时间思考的情况下,就一头扎进开发你的模块。一点点的预想可能会让你以后省去大量的精力。</target>
        </trans-unit>
        <trans-unit id="1a2b567df2700cceb3e59d9f8a3eb3ca3092a77c" translate="yes" xml:space="preserve">
          <source>Try the &lt;a href=&quot;net/ftp&quot;&gt;Net::FTP&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/TCP::Client&quot;&gt;TCP::Client&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; modules (available from CPAN). &lt;a href=&quot;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&quot;&gt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&lt;/a&gt; will also help for emulating the telnet protocol, but &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; is quite probably easier to use.</source>
          <target state="translated">尝试使用&lt;a href=&quot;net/ftp&quot;&gt;Net :: FTP&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/TCP::Client&quot;&gt;TCP :: Client&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net :: Telnet&lt;/a&gt;模块（可从CPAN获得）。&lt;a href=&quot;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&quot;&gt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&lt;/a&gt;也将有助于模拟telnet协议，但是&lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net :: Telnet&lt;/a&gt;可能更易于使用。</target>
        </trans-unit>
        <trans-unit id="87f2df3af873276d11f18dcdfa6067907516ef82" translate="yes" xml:space="preserve">
          <source>Try the first alternative in the first group 'abd'.</source>
          <target state="translated">试试第一组的第一个备选方案'abd'。</target>
        </trans-unit>
        <trans-unit id="8fdc9fd893f9837a30290ddcdb863de474cd49f7" translate="yes" xml:space="preserve">
          <source>Try the native, UDP socket then UNIX domain socket mechanisms:</source>
          <target state="translated">试试本机、UDP套接字然后UNIX域套接字机制。</target>
        </trans-unit>
        <trans-unit id="6a75e271162bdc3d061e3493d3ce114d627fc256" translate="yes" xml:space="preserve">
          <source>Try the resources in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;.</source>
          <target state="translated">试用&lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2中&lt;/a&gt;的资源。</target>
        </trans-unit>
        <trans-unit id="aacef041b76d57895de9d7f5cee32482707bd3b3" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict qw(...);&lt;/code&gt; ). Remember that you can add &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict qw(...);&lt;/code&gt; to individual blocks of code that need less strictness.</source>
          <target state="translated">尝试 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; （或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict qw(...);&lt;/code&gt; ）。请记住，您不能添加 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict qw(...);&lt;/code&gt; 不需要那么严格的单个代码块。</target>
        </trans-unit>
        <trans-unit id="dbe02bedd5bb36eab5b4bbe32b7d4940cf95d2ec" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings qw(...);&lt;/code&gt; ). Remember that you can add &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings qw(...);&lt;/code&gt; to individual blocks of code that need less warnings.</source>
          <target state="translated">尝试 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; （或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings qw(...);&lt;/code&gt; ）。请记住，您不能添加 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings qw(...);&lt;/code&gt; 到需要较少警告的单个代码块。</target>
        </trans-unit>
        <trans-unit id="1a50d23e31ca789a858a654feff08b918836c974" translate="yes" xml:space="preserve">
          <source>Try to color output. See &lt;a href=&quot;../tap/formatter/base#new&quot;&gt;new in TAP::Formatter::Base&lt;/a&gt;.</source>
          <target state="translated">尝试彩色输出。参见&lt;a href=&quot;../tap/formatter/base#new&quot;&gt;TAP :: Formatter :: Base中的新增内容&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e97a54a5e20ef4c3c124d4963b017c39c1dad7b" translate="yes" xml:space="preserve">
          <source>Try to design the new module to be easy to extend and reuse.</source>
          <target state="translated">尽量将新模块设计成易于扩展和复用。</target>
        </trans-unit>
        <trans-unit id="220ea4d529b6fa37d1fa97bbb19f2fed77ce5e5b" translate="yes" xml:space="preserve">
          <source>Try to determine name of extension being built. We begin with the name of the current directory. Since VMS filenames are case-insensitive, however, we look for a</source>
          <target state="translated">尝试确定正在构建的扩展名。我们从当前目录的名称开始。由于VMS文件名是不区分大小写的,因此,我们寻找一个</target>
        </trans-unit>
        <trans-unit id="909a91fc6d3b48263691b246eef6c09eb4ec3bfc" translate="yes" xml:space="preserve">
          <source>Try to determine the width of the screen and the bold and underline sequences for the terminal from termcap, and use that information in formatting the output. Output will be wrapped at two columns less than the width of your terminal device. Using this option requires that your system have a termcap file somewhere where Term::Cap can find it and requires that your system support termios. With this option, the output of &lt;b&gt;pod2text&lt;/b&gt; will contain terminal control sequences for your current terminal type.</source>
          <target state="translated">尝试从termcap确定屏幕的宽度以及终端的粗体和下划线序列，并在格式化输出时使用该信息。输出将包裹在小于终端设备宽度的两列中。使用此选项要求您的系统在Term :: Cap可以找到的地方有一个termcap文件，并要求您的系统支持termios。使用此选项，&lt;b&gt;pod2text&lt;/b&gt;的输出将包含您当前终端类型的终端控制序列。</target>
        </trans-unit>
        <trans-unit id="08f15a05901602892a511e670ab4aa0307df4226" translate="yes" xml:space="preserve">
          <source>Try to document your code and use Pod formatting in a consistent way. Here are commonly expected conventions:</source>
          <target state="translated">尽量以一致的方式记录你的代码和使用Pod格式。以下是通常预期的约定。</target>
        </trans-unit>
        <trans-unit id="c88c728349f5a2409f402906caa2d933f74c0865" translate="yes" xml:space="preserve">
          <source>Try to match a quote or quotelike operator. If found, call &lt;code&gt;extract_quotelike&lt;/code&gt; to eat it. If &lt;code&gt;extract_quotelike&lt;/code&gt; fails, return the error it returned. Otherwise go back to step 1.</source>
          <target state="translated">尝试匹配一个quote或quotelike运算符。如果找到，请调用 &lt;code&gt;extract_quotelike&lt;/code&gt; 食用。如果 &lt;code&gt;extract_quotelike&lt;/code&gt; 失败，则返回它返回的错误。否则，请返回步骤1。</target>
        </trans-unit>
        <trans-unit id="fed009e07cf40a3bfaccb23b101b1df3951ecefd" translate="yes" xml:space="preserve">
          <source>Try to match an opening delimiter bracket. If found, call &lt;code&gt;extract_codeblock&lt;/code&gt; recursively to eat the embedded block. If the recursive call fails, return an error. Otherwise, go back to step 1.</source>
          <target state="translated">尝试匹配一个分隔符。如果找到，则递归调用 &lt;code&gt;extract_codeblock&lt;/code&gt; 来吃嵌入式块。如果递归调用失败，则返回错误。否则，请返回步骤1。</target>
        </trans-unit>
        <trans-unit id="1bf160ae95bc79040defdb4258d5fad8caa20a29" translate="yes" xml:space="preserve">
          <source>Try to obtain the latest version of the Windows SDK. Sometimes these packages contain a particular Windows OS version in their name, but actually work on other OS versions too. For example, the &quot;Windows Server 2003 R2 Platform SDK&quot; also runs on Windows XP SP2 and Windows 2000.</source>
          <target state="translated">尝试获取最新版本的Windows SDK。有时,这些软件包的名称中包含一个特定的Windows操作系统版本,但实际上也可以在其他操作系统版本上运行。例如,&quot;Windows Server 2003 R2 Platform SDK &quot;也可以在Windows XP SP2和Windows 2000上运行。</target>
        </trans-unit>
        <trans-unit id="962ca701cc2570a663505435d963dc55f234f4d9" translate="yes" xml:space="preserve">
          <source>Trying to create a new child with a previous child still active (i.e., &lt;code&gt;finalize&lt;/code&gt; not called) will &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">尝试创建一个新的孩子并使其先前的孩子仍然处于活动状态（即，未调用 &lt;code&gt;finalize&lt;/code&gt; ）将 &lt;code&gt;croak&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0c592184c4820418323672dd4337df40c4098b0" translate="yes" xml:space="preserve">
          <source>Trying to do too much</source>
          <target state="translated">试图做得太多</target>
        </trans-unit>
        <trans-unit id="44d272c0c6193575553012dfbe62f22573eeb82f" translate="yes" xml:space="preserve">
          <source>Trying to run a test when you have an open child will also &lt;code&gt;croak&lt;/code&gt; and cause the test suite to fail.</source>
          <target state="translated">当您有一个开放的孩子时，尝试运行测试也会 &lt;code&gt;croak&lt;/code&gt; 并导致测试套件失败。</target>
        </trans-unit>
        <trans-unit id="e1251ee8a07b3dea6c343e31961e5913e11f0ce3" translate="yes" xml:space="preserve">
          <source>Tune the internal settings for the deflate object &lt;code&gt;$d&lt;/code&gt; . This option is only available if you are running zlib 1.2.2.3 or better.</source>
          <target state="translated">调整deflate对象 &lt;code&gt;$d&lt;/code&gt; 的内部设置。仅当您运行zlib 1.2.2.3或更高版本时，此选项才可用。</target>
        </trans-unit>
        <trans-unit id="008eee580921a65a5e935994d388ebe43c6df0cd" translate="yes" xml:space="preserve">
          <source>Tuning the way RESOLVE_SYMLINK will works</source>
          <target state="translated">调整RESOLVE_SYMLINK的工作方式。</target>
        </trans-unit>
        <trans-unit id="f7db0bf3a9c02aa40e34f07d8431257fcf327327" translate="yes" xml:space="preserve">
          <source>Turn =head1 directives into links pointing to the top of the HTML file.</source>
          <target state="translated">将=head1指令变成指向HTML文件顶部的链接。</target>
        </trans-unit>
        <trans-unit id="33f87dc87ea378d835e56e5bfd248ea1a352c832" translate="yes" xml:space="preserve">
          <source>Turn Pod into XML</source>
          <target state="translated">将Pod转为XML</target>
        </trans-unit>
        <trans-unit id="8e7cc74dfcc71c13798fc4a8a0bda3cb164ed4c1" translate="yes" xml:space="preserve">
          <source>Turn Pod::Simple events into method calls</source>
          <target state="translated">将Pod::Simple事件转化为方法调用</target>
        </trans-unit>
        <trans-unit id="87a4a4a475f00352f77a10d3ec1fd9eee936c4ee" translate="yes" xml:space="preserve">
          <source>Turn off Apple tar's tendency to copy resource forks as &quot;._foo&quot; files.</source>
          <target state="translated">关闭 Apple tar 将资源叉复制为&quot;._foo &quot;文件的倾向。</target>
        </trans-unit>
        <trans-unit id="48d8224908b27731eb611ee5800a332f08bd6efe" translate="yes" xml:space="preserve">
          <source>Turn on colour in Test::Builder::Tester</source>
          <target state="translated">在 Test::Builder::Tester 中打开颜色。</target>
        </trans-unit>
        <trans-unit id="3aaaf6cc176020f3991943f2032de33eccbdb645" translate="yes" xml:space="preserve">
          <source>Turn on debugging messages.</source>
          <target state="translated">开启调试信息。</target>
        </trans-unit>
        <trans-unit id="c5afa3624933dbb94708b864157bd75149a4bc45" translate="yes" xml:space="preserve">
          <source>Turn on the UTF-8 status of an SV (the data is not changed, just the flag). Do not use frivolously.</source>
          <target state="translated">开启SV的UTF-8状态(数据不改变,只是标志)。不要轻率使用。</target>
        </trans-unit>
        <trans-unit id="9903e627171cb3011421fef7af4a686d6ebc3e08" translate="yes" xml:space="preserve">
          <source>Turn on/off printing of warnings. Repeating &lt;b&gt;-warnings&lt;/b&gt; increases the warning level, i.e. more warnings are printed. Currently increasing to level two causes flagging of unescaped &quot;&amp;lt;,&amp;gt;&quot; characters.</source>
          <target state="translated">打开/关闭警告打印。重复&lt;b&gt;警告会&lt;/b&gt;提高警告级别，即打印更多警告。当前增加到第二级会导致标记未转义的&amp;ldquo; &amp;lt;，&amp;gt;&amp;rdquo;字符。</target>
        </trans-unit>
        <trans-unit id="d7dd646019946f4186b2c9415767806d113e6794" translate="yes" xml:space="preserve">
          <source>Turn warnings on/off.</source>
          <target state="translated">打开/关闭警告。</target>
        </trans-unit>
        <trans-unit id="4c628137dd54154b5661d62a2c76528177ce2c0e" translate="yes" xml:space="preserve">
          <source>Turning on one of the character set flags with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; takes precedence over the &lt;code&gt;locale&lt;/code&gt; pragma and the 'unicode_strings' &lt;code&gt;feature&lt;/code&gt; , for regular expressions. Turning off one of these flags when it is active reverts to the behaviour specified by whatever other pragmata are in scope. For example:</source>
          <target state="translated">对于正则表达式， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; 打开一个字符集标志的优先级高于 &lt;code&gt;locale&lt;/code&gt; 编译指示和&amp;ldquo; unicode_strings&amp;rdquo; &lt;code&gt;feature&lt;/code&gt; 。当这些标志之一处于活动状态时将其关闭，将恢复为其他范围内的杂物所指定的行为。例如：</target>
        </trans-unit>
        <trans-unit id="1dac2f62695f453fd439059f0a117cf373d1f773" translate="yes" xml:space="preserve">
          <source>Turns every &lt;code&gt;head1&lt;/code&gt; heading into a link back to the top of the page. By default, no backlinks are generated.</source>
          <target state="translated">将每个 &lt;code&gt;head1&lt;/code&gt; 标题转换为指向页面顶部的链接。默认情况下，不生成任何反向链接。</target>
        </trans-unit>
        <trans-unit id="488b4a24fda23c677bfd758dfeda4e2b3e28ea5b" translate="yes" xml:space="preserve">
          <source>Turns on all &quot;extra&quot; debugging options.</source>
          <target state="translated">开启所有 &quot;额外 &quot;的调试选项。</target>
        </trans-unit>
        <trans-unit id="8a6abc6af101e3e68b329eb351f149732ea8c3d9" translate="yes" xml:space="preserve">
          <source>Turns on all compile related debug options.</source>
          <target state="translated">开启所有与编译相关的调试选项。</target>
        </trans-unit>
        <trans-unit id="377f42734b94211c01fa848b2645c0c159ecedcd" translate="yes" xml:space="preserve">
          <source>Turns on all execute related debug options.</source>
          <target state="translated">开启所有与执行相关的调试选项。</target>
        </trans-unit>
        <trans-unit id="cf78d64b4c15f8d89c3f09aea595a015508f3471" translate="yes" xml:space="preserve">
          <source>Turns on autoflush, print ARGS and then restores the autoflush status of the &lt;code&gt;IO::Handle&lt;/code&gt; object. Returns the return value from print.</source>
          <target state="translated">打开自动刷新，打印ARGS，然后恢复 &lt;code&gt;IO::Handle&lt;/code&gt; 对象的自动刷新状态。返回打印的返回值。</target>
        </trans-unit>
        <trans-unit id="2d1676fcc040bdf1deeab307eee1f9a1faa4d87a" translate="yes" xml:space="preserve">
          <source>Turns on debug output related to the process of parsing the pattern.</source>
          <target state="translated">开启与模式解析过程相关的调试输出。</target>
        </trans-unit>
        <trans-unit id="80ae89d796a9f5474c9cf55351133039b045499c" translate="yes" xml:space="preserve">
          <source>Turns on debugging</source>
          <target state="translated">开启调试</target>
        </trans-unit>
        <trans-unit id="0b71618ab3c580ced56e12be5afa8ca78d10b841" translate="yes" xml:space="preserve">
          <source>Turns on debugging of the main matching loop.</source>
          <target state="translated">开启主匹配循环的调试。</target>
        </trans-unit>
        <trans-unit id="0d12b512bcc17c858f7f78847cab2c7f6461efd3" translate="yes" xml:space="preserve">
          <source>Turns on the magical status of an SV. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">打开SV的魔法状态。参见 &lt;code&gt;sv_magic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5ed69f1e400ca234d376650a653b6521d5c1651" translate="yes" xml:space="preserve">
          <source>Turns the @metadata_pairs into YAML.</source>
          <target state="translated">将@metadata_pairs变成YAML。</target>
        </trans-unit>
        <trans-unit id="606c2af8d67a4d7dc7224ecdbb198b95627a3d18" translate="yes" xml:space="preserve">
          <source>Tutorial on making a new module.</source>
          <target state="translated">制作新模块的教程。</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="4106aa6fe38782986e71b6df351f9eed9adc1100" translate="yes" xml:space="preserve">
          <source>Tutorials, end-user documentation, research papers, FAQs etc are not appropriate in a module's main documentation. If you really want to write these, include them as sub-documents such as &lt;code&gt;My::Module::Tutorial&lt;/code&gt; or &lt;code&gt;My::Module::FAQ&lt;/code&gt; and provide a link in the SEE ALSO section of the main documentation.</source>
          <target state="translated">教程，最终用户文档，研究论文，常见问题解答等不适用于该模块的主要文档。如果您确实想编写这些内容，请将它们作为子文档包括在 &lt;code&gt;My::Module::Tutorial&lt;/code&gt; 或 &lt;code&gt;My::Module::FAQ&lt;/code&gt; 并在主文档的&amp;ldquo;另请参阅&amp;rdquo;部分中提供链接。</target>
        </trans-unit>
        <trans-unit id="d4f6fcebc83fe08414440f2690253120c9bf99c3" translate="yes" xml:space="preserve">
          <source>Tweak the style of B::Deparse's output. The letters should follow directly after the 's', with no space or punctuation. The following options are available:</source>
          <target state="translated">调整 B::Deparse 的输出风格。字母应该直接跟在's'后面,没有空格或标点符号。以下是可用的选项。</target>
        </trans-unit>
        <trans-unit id="8b77b783948e5ce8fbd237831d47a3e2aa25c8cf" translate="yes" xml:space="preserve">
          <source>Two additional extensions by Andreas Kaiser, &lt;code&gt;OS2::UPM&lt;/code&gt; , and &lt;code&gt;OS2::FTP&lt;/code&gt; , are included into &lt;code&gt;ILYAZ&lt;/code&gt; directory, mirrored on CPAN. Other OS/2-related extensions are available too.</source>
          <target state="translated">&lt;code&gt;ILYAZ&lt;/code&gt; 目录中包含Andreas Kaiser的另外两个扩展 &lt;code&gt;OS2::UPM&lt;/code&gt; 和 &lt;code&gt;OS2::FTP&lt;/code&gt; ，已在CPAN上进行了镜像。其他与OS / 2相关的扩展也可用。</target>
        </trans-unit>
        <trans-unit id="225de66ed8612f5eaedcbe3517b9b8a030dd1dfb" translate="yes" xml:space="preserve">
          <source>Two additional fields &lt;code&gt;free&lt;/code&gt; , &lt;code&gt;used&lt;/code&gt; contain array references which provide per-bucket count of free and used chunks. Two other fields &lt;code&gt;mem_size&lt;/code&gt; , &lt;code&gt;available_size&lt;/code&gt; contain array references which provide the information about the allocated size and usable size of chunks in each bucket. Again, see &lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;Using $ENV{PERL_DEBUG_MSTATS} in perldebguts&lt;/a&gt; for details.</source>
          <target state="translated">两个附加字段 &lt;code&gt;free&lt;/code&gt; ， &lt;code&gt;used&lt;/code&gt; 含有数组引用其提供可用和已用块的每桶计数。另外两个字段 &lt;code&gt;mem_size&lt;/code&gt; ， &lt;code&gt;available_size&lt;/code&gt; 包含数组引用，这些引用提供有关每个存储桶中块的已分配大小和可用大小的信息。再次，请参阅&lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;perldebguts中的使用$ ENV {PERL_DEBUG_MSTATS}以&lt;/a&gt;获取详细信息。</target>
        </trans-unit>
        <trans-unit id="959e1dbe5c03b6bf54bd2c7c42f5c06de670abcf" translate="yes" xml:space="preserve">
          <source>Two arrays smartmatch if each element in the first array smartmatches (that is, is &quot;in&quot;) the corresponding element in the second array, recursively.</source>
          <target state="translated">如果第一个数组中的每个元素与第二个数组中的相应元素递归地智能匹配(即 &quot;在&quot;),则两个数组就会智能匹配。</target>
        </trans-unit>
        <trans-unit id="ef9d289482c44cedd928e08a539e06da234c1ea2" translate="yes" xml:space="preserve">
          <source>Two directories</source>
          <target state="translated">两个目录</target>
        </trans-unit>
        <trans-unit id="4932b4ce84c4a3c76d97d8ddc1677ad9583f731a" translate="yes" xml:space="preserve">
          <source>Two exceptions are fseek() and ftell(). 32-bit applications should use fseeko(3C) and ftello(3C). These will get automatically mapped to fseeko64() and ftello64().</source>
          <target state="translated">两种例外情况是fseek()和ftell(),32位应用应该使用fseeko(3C)和ftello(3C)。32位应用程序应该使用fseeko(3C)和ftello(3C)。这些会自动映射到fseeko64()和ftello64()。</target>
        </trans-unit>
        <trans-unit id="59e6099a51676c8b357d47058d648615908e9535" translate="yes" xml:space="preserve">
          <source>Two functions are provided by</source>
          <target state="translated">提供了两项功能</target>
        </trans-unit>
        <trans-unit id="362495d14b1f3b1a8e9077a2b6d2d038307cf755" translate="yes" xml:space="preserve">
          <source>Two functions are provided to perform in-memory compression/uncompression of RFC 1950 data streams. They are called &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt; .</source>
          <target state="translated">提供了两个功能来执行RFC 1950数据流的内存中压缩/解压缩。它们称为 &lt;code&gt;compress&lt;/code&gt; 和 &lt;code&gt;uncompress&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1fae0daa00d9847553b4c2af0e0bfcf15f43ad2" translate="yes" xml:space="preserve">
          <source>Two hexadecimal numbers separated by horizontal whitespace (space or tabular characters) denoting a range of code points to include.</source>
          <target state="translated">两个十六进制数字,用水平空格(空格或表格字符)隔开,表示要包括的码点范围。</target>
        </trans-unit>
        <trans-unit id="fc8d21d4a74e99aae1a5fc40b83d3fff90123b23" translate="yes" xml:space="preserve">
          <source>Two nested identical markup commands have been found. Generally this does not make sense.</source>
          <target state="translated">发现有两个嵌套的相同标记命令。一般情况下,这是说不通的。</target>
        </trans-unit>
        <trans-unit id="5e76b53030582383f7d551a5e77c668c449dbb3b" translate="yes" xml:space="preserve">
          <source>Two of the codes specified by the standard (XTS which is reserved for testing purposes and XXX which is for transactions where no currency is involved) are omitted.</source>
          <target state="translated">标准规定的两个代码(XTS用于测试目的,XXX用于不涉及货币的交易)被省略。</target>
        </trans-unit>
        <trans-unit id="a1d006aec19b5d26f771c4cb3b1aa7d14cd4a562" translate="yes" xml:space="preserve">
          <source>Two or more suspects remain</source>
          <target state="translated">仍有两名或更多嫌疑人</target>
        </trans-unit>
        <trans-unit id="069f392f8b693bf3f912fa721edb551769786910" translate="yes" xml:space="preserve">
          <source>Two other &quot;encapsulation&quot; macros are the PERL_GLOBAL_STRUCT and PERL_GLOBAL_STRUCT_PRIVATE (the latter turns on the former, and the former turns on MULTIPLICITY.) The PERL_GLOBAL_STRUCT causes all the internal variables of Perl to be wrapped inside a single global struct, struct perl_vars, accessible as (globals) &amp;amp;PL_Vars or PL_VarsPtr or the function Perl_GetVars(). The PERL_GLOBAL_STRUCT_PRIVATE goes one step further, there is still a single struct (allocated in main() either from heap or from stack) but there are no global data symbols pointing to it. In either case the global struct should be initialized as the very first thing in main() using Perl_init_global_struct() and correspondingly tear it down after perl_free() using Perl_free_global_struct(), please see</source>
          <target state="translated">另外两个&amp;ldquo;封装&amp;rdquo;宏是PERL_GLOBAL_STRUCT和PERL_GLOBAL_STRUCT_PRIVATE（后者打开前者，而前者打开MULTIPLICITY。）PERL_GLOBAL_STRUCT使Perl的所有内部变量都包装在单个全局结构（结构perl_vars）中，可作为（全局）＆PL_Vars或PL_VarsPtr或函数Perl_GetVars（）。 PERL_GLOBAL_STRUCT_PRIVATE进一步走了一步，仍然只有一个结构（从堆或堆栈中分配到main（）中），但是没有指向它的全局数据符号。无论哪种情况，都应该使用Perl_init_global_struct（）将全局结构初始化为main（）中的第一件事，并在使用Perl_free_global_struct（）进行perl_free（）之后将其相应地拆除</target>
        </trans-unit>
        <trans-unit id="9e4d897b2c15b7e4e4ca9fbaec8aab25f6b14e93" translate="yes" xml:space="preserve">
          <source>Two possible uses (besides ignoring the property) come to mind. A singleton class could be implemented this using the generic object. If necessary, an &lt;code&gt;init()&lt;/code&gt; method could die or ignore calls with actual objects (references), so only the generic object will ever exist.</source>
          <target state="translated">我想到了两种可能的用途（除了忽略属性）。可以使用泛型对象来实现单例类。如有必要， &lt;code&gt;init()&lt;/code&gt; 方法可能会死掉或忽略对实际对象（引用）的调用，因此只有通用对象会存在。</target>
        </trans-unit>
        <trans-unit id="70abff015732d480e204353f739476e826fe7dc6" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; semantics are that it waits indefinitely until the lock is granted, and that its locks are &lt;b&gt;merely advisory&lt;/b&gt;. Such discretionary locks are more flexible, but offer fewer guarantees. This means that programs that do not also use &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; may modify files locked with &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</source>
          <target state="translated">两种潜在的非显而易见但传统的 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 语义是：它无限期地等待直到授予锁为止，并且其锁&lt;b&gt;仅仅是建议性的&lt;/b&gt;。这样的自由锁更加灵活，但是提供的保证却更少。这意味着，不也使用的程序 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 可以修改文件锁定与 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 。见&lt;a href=&quot;../perlport&quot;&gt;Perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</target>
        </trans-unit>
        <trans-unit id="3c9f59ec6423987c8c2fe5d0858f160205e3fc59" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; semantics are that it waits indefinitely until the lock is granted, and that its locks are &lt;b&gt;merely advisory&lt;/b&gt;. Such discretionary locks are more flexible, but offer fewer guarantees. This means that programs that do not also use &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; may modify files locked with &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</source>
          <target state="translated">两种潜在的非显而易见但传统的 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 语义是：它无限期地等待直到授予锁为止，并且其锁&lt;b&gt;仅仅是建议性的&lt;/b&gt;。这样的自由锁更加灵活，但是提供的保证却更少。这意味着，不也使用的程序 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 可以修改文件锁定与 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 。见&lt;a href=&quot;perlport&quot;&gt;Perlport&lt;/a&gt;，您端口的特定文档以及系统特定的本地联机帮助页以获取详细信息。如果您正在编写可移植程序，则最好采用传统行为。（但是，如果您不是这样，那么您一如既往可以完全自由地编写自己系统的特性（有时称为&amp;ldquo;功能&amp;rdquo;。）对可移植性问题的过度依赖不会妨碍您完成工作。）</target>
        </trans-unit>
        <trans-unit id="53df84b423920613232d12c96d5eb675ef01a9db" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional flock semantics are that it waits indefinitely until the lock is granted, and that its locks are</source>
          <target state="translated">两个潜在的非显而易见但传统的羊群语义是,它无限期地等待,直到锁被授予,并且它的锁是</target>
        </trans-unit>
        <trans-unit id="778a62aee9043b393531476babc83e7e729243c9" translate="yes" xml:space="preserve">
          <source>Two special locales are worth particular mention: &quot;C&quot; and &quot;POSIX&quot;. Currently these are effectively the same locale: the difference is mainly that the first one is defined by the C standard, the second by the POSIX standard. They define the &lt;b&gt;default locale&lt;/b&gt; in which every program starts in the absence of locale information in its environment. (The</source>
          <target state="translated">值得特别提及的两个特殊语言环境：&amp;ldquo; C&amp;rdquo;和&amp;ldquo; POSIX&amp;rdquo;。当前，这些区域实际上是相同的语言环境：区别主要在于第一个由C标准定义，第二个由POSIX标准定义。它们定义了&lt;b&gt;默认语言环境&lt;/b&gt;，每个程序都在其环境中缺少语言环境信息的情况下启动。（</target>
        </trans-unit>
        <trans-unit id="001ed180b265179aa35dbaf576484db20b8f3115" translate="yes" xml:space="preserve">
          <source>Two special marker lines will bracket debugging code, like this:</source>
          <target state="translated">两条特殊的标记线会括住调试代码,像这样。</target>
        </trans-unit>
        <trans-unit id="fc4c89a57e0f51cea54d0e2e158fcc3083bc5fa2" translate="yes" xml:space="preserve">
          <source>Two threads both access &lt;code&gt;$x&lt;/code&gt; . Each thread can potentially be interrupted at any point, or be executed in any order. At the end, &lt;code&gt;$x&lt;/code&gt; could be 3 or 4, and both &lt;code&gt;$y&lt;/code&gt; and &lt;code&gt;$z&lt;/code&gt; could be 2 or 3.</source>
          <target state="translated">两个线程都访问 &lt;code&gt;$x&lt;/code&gt; 。每个线程都可能在任何时候被中断，或以任何顺序执行。最后， &lt;code&gt;$x&lt;/code&gt; 可以是3或4， &lt;code&gt;$y&lt;/code&gt; 和 &lt;code&gt;$z&lt;/code&gt; 都可以是2或3。</target>
        </trans-unit>
        <trans-unit id="a040608578e9e9c915007f47fc1e5b14ac218a6c" translate="yes" xml:space="preserve">
          <source>Two ways. One is to build the module normally...</source>
          <target state="translated">两种方法。一种是正常搭建模块...</target>
        </trans-unit>
        <trans-unit id="aed361ca9a7b196027b5db9a2f0828216a331df8" translate="yes" xml:space="preserve">
          <source>Two's complement (bitwise not). This is equivalent to</source>
          <target state="translated">二的补充(位上不)。这相当于</target>
        </trans-unit>
        <trans-unit id="639570380139caf69541c926ba46013c3318dc90" translate="yes" xml:space="preserve">
          <source>Two-face References</source>
          <target state="translated">双面参考</target>
        </trans-unit>
        <trans-unit id="ae90b2c9e3f2f4b661468b3ddaef859dd9bff8a2" translate="yes" xml:space="preserve">
          <source>Two-face Scalars</source>
          <target state="translated">双面疤痕</target>
        </trans-unit>
        <trans-unit id="47708aacd7aae4d98506843c2ea25848ad8c524c" translate="yes" xml:space="preserve">
          <source>Tying Arrays</source>
          <target state="translated">捆绑数组</target>
        </trans-unit>
        <trans-unit id="29fe0e127980eab253dd9684cf8924d1439a9c07" translate="yes" xml:space="preserve">
          <source>Tying Arrays by Casey West &amp;lt;</source>
          <target state="translated">凯西&amp;middot;韦斯特（Casey West）的捆绑阵列&amp;lt;</target>
        </trans-unit>
        <trans-unit id="1cb864932b4ba6b40040bda147b28500825da685" translate="yes" xml:space="preserve">
          <source>Tying FileHandles</source>
          <target state="translated">绑定FileHandles</target>
        </trans-unit>
        <trans-unit id="c44951e9133e5d8875fa8e60d17eb7ca4e5ec846" translate="yes" xml:space="preserve">
          <source>Tying Hashes</source>
          <target state="translated">捆绑哈希值</target>
        </trans-unit>
        <trans-unit id="c124692dc36c13d6ea9eefe451091514b3053308" translate="yes" xml:space="preserve">
          <source>Tying Scalars</source>
          <target state="translated">绑扎疤痕</target>
        </trans-unit>
        <trans-unit id="dd441f6c670bdd175a4a06606b3ade32864a5013" translate="yes" xml:space="preserve">
          <source>Tying to an already-opened filehandle</source>
          <target state="translated">绑定到一个已经打开的文件柄上</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="622fe690390119c9b2836b529615b923c08f64da" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake install&quot; (or &quot;nmake install&quot;). This will put the newly built perl and the libraries under whatever &lt;code&gt;INST_TOP&lt;/code&gt; points to in the Makefile. It will also install the pod documentation under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod&lt;/code&gt; and HTML versions of the same under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod\html&lt;/code&gt; .</source>
          <target state="translated">键入&amp;ldquo; dmake install&amp;rdquo;（或&amp;ldquo; nmake install&amp;rdquo;）。这会将新建的perl和库放在 &lt;code&gt;INST_TOP&lt;/code&gt; 所指向的Makefile中。它还将在 &lt;code&gt;$INST_TOP\$INST_VER\lib\pod&lt;/code&gt; 下安装pod文档，并在 &lt;code&gt;$INST_TOP\$INST_VER\lib\pod\html&lt;/code&gt; 下安装相同的HTML版本。</target>
        </trans-unit>
        <trans-unit id="48996994efbc36adb9197c655f8807f921339671" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake test&quot; (or &quot;nmake test&quot;). This will run most of the tests from the testsuite (many tests will be skipped).</source>
          <target state="translated">输入 &quot;dmake test&quot; (或 &quot;nmake test&quot;)。这将运行testuite中的大部分测试 (许多测试将被跳过)。</target>
        </trans-unit>
        <trans-unit id="e707f55e50471f8dc7a11eb61a45491656e65c20" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake&quot; (or &quot;nmake&quot; if you are using that make).</source>
          <target state="translated">输入 &quot;dmake&quot;(或 &quot;nmake&quot;,如果你使用的是make)。</target>
        </trans-unit>
        <trans-unit id="817cc5b4f0c413465ec1e98078f923e58ba436f8" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;perl -v&lt;/code&gt; at the command line to find out.</source>
          <target state="translated">在命令行中键入 &lt;code&gt;perl -v&lt;/code&gt; 进行查找。</target>
        </trans-unit>
        <trans-unit id="470a91ba8a41cc959ff1b12a936c2603408f2a81" translate="yes" xml:space="preserve">
          <source>Type flag for I/O objects. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">I / O对象的类型标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="115e0f5825d2a5e2437586f43a3052a4bc413be2" translate="yes" xml:space="preserve">
          <source>Type flag for arrays. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">数组的类型标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5424ebb415da653ce11cbaa80efe5caaa204e71c" translate="yes" xml:space="preserve">
          <source>Type flag for formats. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">输入格式标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11f3d189f9118d5a6a717d6df4d8bfc5dd5c80fb" translate="yes" xml:space="preserve">
          <source>Type flag for hashes. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">输入哈希标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7697ce082ff72de4bd1f6e232aec1e708c3e949b" translate="yes" xml:space="preserve">
          <source>Type flag for regular expressions. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">正则表达式的类型标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8842ec0ce8ceed5f394b670f4b4d43838af8af85" translate="yes" xml:space="preserve">
          <source>Type flag for scalars. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">输入标量的标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba6e0906867866e6b4c76c1aa73ce8fb1ddab2a4" translate="yes" xml:space="preserve">
          <source>Type flag for subroutines. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">子例程的类型标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d98af6202cdf505f81d6de89907f306acd604bb" translate="yes" xml:space="preserve">
          <source>Type flag for typeglobs. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">typeglob的类型标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e47d64cc94d0acfc0cdbf0b2c9dd711351e0f339" translate="yes" xml:space="preserve">
          <source>Type of first matching node.</source>
          <target state="translated">第一匹配节点的类型。</target>
        </trans-unit>
        <trans-unit id="82be69629fdb03e428153252cb628a3089333b85" translate="yes" xml:space="preserve">
          <source>Type-casting operator.</source>
          <target state="translated">型铸操作员。</target>
        </trans-unit>
        <trans-unit id="3c6b62766a1a668fd13ee2f54c72526e46bdd675" translate="yes" xml:space="preserve">
          <source>Type-specific attribute handlers</source>
          <target state="translated">特定类型属性处理程序</target>
        </trans-unit>
        <trans-unit id="ee3fb11d05c90c37311491cf33008925b13b487f" translate="yes" xml:space="preserve">
          <source>Type:</source>
          <target state="translated">Type:</target>
        </trans-unit>
        <trans-unit id="dacaa1ce7373acde846ee256ee267058f226c8cb" translate="yes" xml:space="preserve">
          <source>Typed lexicals</source>
          <target state="translated">打字词法</target>
        </trans-unit>
        <trans-unit id="35c58169317903405f89e446350d7099fc17650c" translate="yes" xml:space="preserve">
          <source>Typeglobs and Filehandles</source>
          <target state="translated">Typeglobs和Filehandles</target>
        </trans-unit>
        <trans-unit id="c93af0f29f506026f9bce190608810109efe41de" translate="yes" xml:space="preserve">
          <source>Typeglobs are also a way to create a local filehandle using the local() operator. These last until their block is exited, but may be passed back. For example:</source>
          <target state="translated">Typeglobs 也是一种使用 local()操作符创建本地文件柄的方法。这些都会持续到它们的块被退出,但可能会被传回。例如</target>
        </trans-unit>
        <trans-unit id="7c854e2c86ed5ebd580cf024fab8796f99c1a0f9" translate="yes" xml:space="preserve">
          <source>Types of Nodes</source>
          <target state="translated">节点类型</target>
        </trans-unit>
        <trans-unit id="54a79ea7d31cf3e80acf5e2ca6b3eef126289136" translate="yes" xml:space="preserve">
          <source>Typical frequently used settings:</source>
          <target state="translated">典型的常用设置。</target>
        </trans-unit>
        <trans-unit id="eeee45f0582f2da790f6df23acb83c5b9ac37e5b" translate="yes" xml:space="preserve">
          <source>Typical usage is just:</source>
          <target state="translated">典型的用法是刚。</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="translated">典型用途:</target>
        </trans-unit>
        <trans-unit id="f0a20c31caa817cfde9a5903c8d1331d2cc5ddae" translate="yes" xml:space="preserve">
          <source>Typical use is to do range checks on &lt;code&gt;uv&lt;/code&gt; before casting:</source>
          <target state="translated">典型用途是在投射前对 &lt;code&gt;uv&lt;/code&gt; 进行范围检查：</target>
        </trans-unit>
        <trans-unit id="0f7c555ca8af58d8be6641bce4c54e1f92594d54" translate="yes" xml:space="preserve">
          <source>Typical use of AutoSplit in the perl MakeMaker utility is via the command-line with:</source>
          <target state="translated">在perl MakeMaker实用程序中,AutoSplit的典型用法是通过命令行使用。</target>
        </trans-unit>
        <trans-unit id="2eb42fd8be2849b836904fd8c0478452015d5021" translate="yes" xml:space="preserve">
          <source>Typically displayed in italics. Example: &quot;&lt;code&gt;F&amp;lt;.cshrc&amp;gt;&lt;/code&gt; &quot;</source>
          <target state="translated">通常以斜体显示。示例：&amp;ldquo; &lt;code&gt;F&amp;lt;.cshrc&amp;gt;&lt;/code&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0b14febd4050c6e9e7fff1ec1a1e04a32b2411b9" translate="yes" xml:space="preserve">
          <source>Typically render into NFD on input and NFC on output. Using NFKC or NFKD functions improves recall on searches, assuming you've already done to the same text to be searched. Note that this is about much more than just pre- combined compatibility glyphs; it also reorders marks according to their canonical combining classes and weeds out singletons.</source>
          <target state="translated">通常在输入时渲染成NFD,输出时渲染成NFC。使用NFKC或NFKD函数可以提高搜索时的召回率,假设你已经对要搜索的同一文本进行了搜索。请注意,这不仅仅是关于预组合兼容性字形,它还根据它们的规范组合类重新排序标记,并剔除单体。</target>
        </trans-unit>
        <trans-unit id="b5c564109e8a3afa5be0b031d855d9ae4aa0bbb3" translate="yes" xml:space="preserve">
          <source>Typically this is used to emulate &lt;code&gt;#!&lt;/code&gt; startup on platforms that don't support &lt;code&gt;#!&lt;/code&gt; . It's also convenient when debugging a script that uses &lt;code&gt;#!&lt;/code&gt; , and is thus normally found by the shell's $PATH search mechanism.</source>
          <target state="translated">通常，它用于模拟 &lt;code&gt;#!&lt;/code&gt; 在不支持 &lt;code&gt;#!&lt;/code&gt; 平台上启动！。当调试使用 &lt;code&gt;#!&lt;/code&gt; 的脚本时，这也很方便。，因此通常是由外壳程序的$ PATH搜索机制找到的。</target>
        </trans-unit>
        <trans-unit id="687058d347f26c3b9dcf0508ed2f5930b5b6fa48" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be returned via &lt;code&gt;$out&lt;/code&gt; . &lt;code&gt;$status&lt;/code&gt; will have a value &lt;code&gt;Z_OK&lt;/code&gt; if successful.</source>
          <target state="translated">通常用于完成放气。任何待处理的输出将通过 &lt;code&gt;$out&lt;/code&gt; 返回。如果成功， &lt;code&gt;$status&lt;/code&gt; 的值 &lt;code&gt;Z_OK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01a46f6fee05faa753caaabc6b43de594c708bd4" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be written to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">通常用于完成放气。任何未决的输出将被写入 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6622b7497b5ad854ceef3d9e6b7f39de4b5a746f" translate="yes" xml:space="preserve">
          <source>Typically will call &lt;code&gt;Fill&lt;/code&gt; and manipulate pointers (possibly via the API). &lt;code&gt;PerlIOBuf_read()&lt;/code&gt; may be suitable for derived classes which provide &quot;fast gets&quot; methods.</source>
          <target state="translated">通常会调用 &lt;code&gt;Fill&lt;/code&gt; 和操作指针（可能通过API）。 &lt;code&gt;PerlIOBuf_read()&lt;/code&gt; 可能适用于提供&amp;ldquo;快速获取&amp;rdquo;方法的派生类。</target>
        </trans-unit>
        <trans-unit id="eb1290094db39111daed12026731de41d874265c" translate="yes" xml:space="preserve">
          <source>Typically you only need to set this if you are using nonstandard prefixes and want some or all of them to have the same semantics as '--' does under normal circumstances.</source>
          <target state="translated">通常情况下,只有当你使用非标准的前缀,并希望其中的一些或所有前缀具有与'--'在正常情况下相同的语义时,你才需要设置这个。</target>
        </trans-unit>
        <trans-unit id="bbb5689bb894bcd45bb2427b7ffbb2ba5d9ac28a" translate="yes" xml:space="preserve">
          <source>Typically you use the &lt;code&gt;\G&lt;/code&gt; anchor with the &lt;code&gt;c&lt;/code&gt; flag when you want to try a different match if one fails, such as in a tokenizer. Jeffrey Friedl offers this example which works in 5.004 or later.</source>
          <target state="translated">通常，如果您想要在匹配失败的情况下尝试其他匹配（例如在分词器中），则可以将 &lt;code&gt;\G&lt;/code&gt; 锚与 &lt;code&gt;c&lt;/code&gt; 标志一起使用。Jeffrey Friedl提供了适用于5.004或更高版本的示例。</target>
        </trans-unit>
        <trans-unit id="291f2d298dd4e6053c773023592956eee5655566" translate="yes" xml:space="preserve">
          <source>Typically, Perl tests are run through this. However, anything which spits out TAP is fine. You can use this argument to specify the name of the program (and optional switches) to run your tests with:</source>
          <target state="translated">通常情况下,Perl测试是通过这个来运行的。然而,任何能吐出TAP的程序都可以。你可以用这个参数来指定程序的名称 (和可选的开关)来运行你的测试。</target>
        </trans-unit>
        <trans-unit id="bc1a3db1817e4391406ea8e4c10b938d812a2baf" translate="yes" xml:space="preserve">
          <source>Typically, a C compiler allocates 12 bytes to a &lt;code&gt;gappy_t&lt;/code&gt; variable, but requires only 8 bytes for a &lt;code&gt;dense_t&lt;/code&gt; . After investigating this further, we can draw memory maps, showing where the extra 4 bytes are hidden:</source>
          <target state="translated">通常，C编译器将12个字节分配给 &lt;code&gt;gappy_t&lt;/code&gt; 变量，但是对于 &lt;code&gt;dense_t&lt;/code&gt; 只需要8个字节。在进一步研究之后，我们可以绘制内存映射，显示出多余的4个字节在哪里被隐藏：</target>
        </trans-unit>
        <trans-unit id="83c91d2712bb90187ca081aa74ad37d202d5e800" translate="yes" xml:space="preserve">
          <source>Typically, however, things are the other way around: the tieable class expects its arguments as a flattened list, so the attribute looks like:</source>
          <target state="translated">然而,通常情况下,事情是相反的:可绑定类希望它的参数是一个扁平化的列表,所以属性看起来像。</target>
        </trans-unit>
        <trans-unit id="a2dcf9e9fce909e6d70f7fd2b928940489e6fad5" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype d off&quot; or &quot;buildtype d&quot; at the command prompt causes the buildtype to be set to Debug type with D1 flag set.</source>
          <target state="translated">在命令提示符下键入 &quot;buildtype d off &quot;或 &quot;buildtype d &quot;会使buildtype被设置为Debug类型,并设置D1标志。</target>
        </trans-unit>
        <trans-unit id="b2c7510e598f94047792f2e34322c55a1d654ee0" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype d on&quot; at the command prompt causes the buildtype to be set to Debug type with D2 flag set.</source>
          <target state="translated">在命令提示符下输入 &quot;buildtype d on &quot;会使buildtype被设置为Debug类型,并设置D2标志。</target>
        </trans-unit>
        <trans-unit id="6127511edf886df0417540a81474ffb3800e60b7" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype r&quot; at the command prompt sets it to Release Build type.</source>
          <target state="translated">在命令提示符下输入 &quot;buildtype r &quot;将其设置为Release Build类型。</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="70ae2f8ea36eac22765cdf44837146969d083d4c" translate="yes" xml:space="preserve">
          <source>U/WIN specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_Unix的U/WIN特定子类。</target>
        </trans-unit>
        <trans-unit id="3a333ea8bebfa50b73219f11f7bf0ebbb8c9a863" translate="yes" xml:space="preserve">
          <source>UCA recommends that out-of-range values should not be ignored for security reasons. Say, &lt;code&gt;&quot;pe\x{110000}rl&quot;&lt;/code&gt; should not be equal to &lt;code&gt;&quot;perl&quot;&lt;/code&gt; . However, &lt;code&gt;U+FFFD&lt;/code&gt; is wrongly mapped to a variable collation element in DUCET for Unicode 6.0.0 to 6.2.0, that means out-of-range values will be ignored when &lt;code&gt;variable&lt;/code&gt; isn't &lt;code&gt;Non-ignorable&lt;/code&gt; .</source>
          <target state="translated">UCA建议出于安全原因，不应忽略超出范围的值。说 &lt;code&gt;&quot;pe\x{110000}rl&quot;&lt;/code&gt; 不应等于 &lt;code&gt;&quot;perl&quot;&lt;/code&gt; 。但是，对于Unicode 6.0.0至6.2.0 ， &lt;code&gt;U+FFFD&lt;/code&gt; 错误地映射到DUCET中的变量归类元素，这意味着当 &lt;code&gt;variable&lt;/code&gt; 不是 &lt;code&gt;Non-ignorable&lt;/code&gt; ignorable时，超出范围的值将被忽略。</target>
        </trans-unit>
        <trans-unit id="206177d23e4d5ec0abfb5c6b0df396d679742e7c" translate="yes" xml:space="preserve">
          <source>UCS-2 is a fixed-length encoding with each character taking 16 bits. It &lt;b&gt;does not&lt;/b&gt; support</source>
          <target state="translated">UCS-2是定长编码，每个字符占用16位。它&lt;b&gt;不&lt;/b&gt;支持</target>
        </trans-unit>
        <trans-unit id="daeba9311089266fcf0acd6d54c9e56ca13a992e" translate="yes" xml:space="preserve">
          <source>UCS-2, UCS-4</source>
          <target state="translated">UCS-2、UCS-4</target>
        </trans-unit>
        <trans-unit id="a392dc8e430c846ca90f8e40c79fda571eef8daf" translate="yes" xml:space="preserve">
          <source>UDP datagrams are</source>
          <target state="translated">UDP数据报是</target>
        </trans-unit>
        <trans-unit id="0b1ddbe7e9085079ee7967600cb1889fd0b548d1" translate="yes" xml:space="preserve">
          <source>UDP: Message Passing</source>
          <target state="translated">UDP:信息传递</target>
        </trans-unit>
        <trans-unit id="74ff590c1dac1161eec0fbaa8b7d8b3a98fff4d5" translate="yes" xml:space="preserve">
          <source>UNICODE AND SIDE EFFECTS</source>
          <target state="translated">统一编码和副作用</target>
        </trans-unit>
        <trans-unit id="0f9d971f52bdd7a74ebeb786ec5143de4c2935d5" translate="yes" xml:space="preserve">
          <source>UNICODE IN OLDER PERLS</source>
          <target state="translated">旧版PERLS中的UNICODE</target>
        </trans-unit>
        <trans-unit id="94c5e5979031dbec3b6f240558b2bfaa36f46791" translate="yes" xml:space="preserve">
          <source>UNIMPLEMENTED</source>
          <target state="translated">UNIMPLEMENTED</target>
        </trans-unit>
        <trans-unit id="9392ee60535a3aa7bb3335f263044b78e27554ed" translate="yes" xml:space="preserve">
          <source>UNISTD</source>
          <target state="translated">UNISTD</target>
        </trans-unit>
        <trans-unit id="c070755890afd262edf57a1cfae99ffc017d2459" translate="yes" xml:space="preserve">
          <source>UNITCHECK</source>
          <target state="translated">UNITCHECK</target>
        </trans-unit>
        <trans-unit id="bc192a928ab3fe78a1c74cfa4d1027b44d52c868" translate="yes" xml:space="preserve">
          <source>UNIVERSAL</source>
          <target state="translated">UNIVERSAL</target>
        </trans-unit>
        <trans-unit id="1feda7e9d1b1a232e025eeb903dd53659f7b069c" translate="yes" xml:space="preserve">
          <source>UNIVERSAL - base class for ALL classes (blessed references)</source>
          <target state="translated">UNIVERSAL-所有类的基础类(祝福参考)</target>
        </trans-unit>
        <trans-unit id="b23387c60700d885c584c4f2b25855ad58b48b48" translate="yes" xml:space="preserve">
          <source>UNIX and POSIX systems provide an abstract access() operating system call, which should be used to query the read, write, and execute rights. This function hides various distinct approaches in additional operating system specific security features, like Access Control Lists (ACLs)</source>
          <target state="translated">UNIX和POSIX系统提供了一个抽象访问()的操作系统调用,应该用来查询读、写和执行权限。这个函数将各种不同的方法隐藏在额外的操作系统特定的安全功能中,比如访问控制列表(ACLs)。</target>
        </trans-unit>
        <trans-unit id="fa0c8b9587852cbf0dc08f98bcecbaed53f1e1c0" translate="yes" xml:space="preserve">
          <source>UNIX domain sockets added by Sean Robinson &amp;lt;</source>
          <target state="translated">Sean Robinson添加的UNIX域套接字&amp;lt;</target>
        </trans-unit>
        <trans-unit id="85db2499d39f4696e02fb26511b230add2c1b670" translate="yes" xml:space="preserve">
          <source>UNIX file permissions are based on sets of mode bits for {read,write,execute} for each {user,group,other}. By default Cygwin only tracks the Win32 read-only attribute represented as the UNIX file user write bit (files are always readable, files are executable if they have a</source>
          <target state="translated">UNIX文件的权限是基于每个{用户、组、其他}的{读、写、执行}模式位的集合。默认情况下,Cygwin只跟踪以UNIX文件用户写位表示的Win32只读属性(文件总是可读的,如果文件有写位,则可执行)。</target>
        </trans-unit>
        <trans-unit id="5b8f1af6e17a29d4f20f56ec6d442f59acfc755d" translate="yes" xml:space="preserve">
          <source>UNSUPPORTED</source>
          <target state="translated">UNSUPPORTED</target>
        </trans-unit>
        <trans-unit id="40cccdd49a4b2f7980664d02999aa7b9e3022b50" translate="yes" xml:space="preserve">
          <source>UNTIE by Nick Ing-Simmons &amp;lt;</source>
          <target state="translated">Nick Ing-Simmons撰写的UNTIE &amp;lt;</target>
        </trans-unit>
        <trans-unit id="41304503568dff57766f35c33ebaca45f5e827b2" translate="yes" xml:space="preserve">
          <source>UNTIE this</source>
          <target state="translated">UNTIE this</target>
        </trans-unit>
        <trans-unit id="e3bb3273c3d27a35e7a79c09d285ae651319171c" translate="yes" xml:space="preserve">
          <source>UPGRADING</source>
          <target state="translated">UPGRADING</target>
        </trans-unit>
        <trans-unit id="a6b6b187a5dabe1711e09378ba034929cf5397f3" translate="yes" xml:space="preserve">
          <source>UPSTREAM indicates where patches should go. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; implies that this hasn't been discussed for the module at hand. &lt;code&gt;blead&lt;/code&gt; indicates that the copy of the module in the blead sources is to be considered canonical, &lt;code&gt;cpan&lt;/code&gt; means that the module on CPAN is to be patched first. &lt;code&gt;first-come&lt;/code&gt; means that blead can be patched freely if it is in sync with the latest release on CPAN.</source>
          <target state="translated">UPSTREAM指示应将修补程序放到哪里。 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 表示尚未对手头的模块进行讨论。 &lt;code&gt;blead&lt;/code&gt; 表示将blead源中的模块副本视为规范副本， &lt;code&gt;cpan&lt;/code&gt; 表示将首先修补CPAN上的模块。 &lt;code&gt;first-come&lt;/code&gt; 是指，如果与最新版CPAN同步，则可以免费修补blead。</target>
        </trans-unit>
        <trans-unit id="ba5e5280eb88749f4ed2bd7802c151c1f77cb3d7" translate="yes" xml:space="preserve">
          <source>URL decoding and encoding</source>
          <target state="translated">URL解码和编码</target>
        </trans-unit>
        <trans-unit id="61aff325c59f0125c7432101521fe8aef2d620f8" translate="yes" xml:space="preserve">
          <source>URLS</source>
          <target state="translated">URLS</target>
        </trans-unit>
        <trans-unit id="cf3bfa9a159c5a5ddc20da1eccd6bbddbdc037e4" translate="yes" xml:space="preserve">
          <source>USAGE</source>
          <target state="translated">USAGE</target>
        </trans-unit>
        <trans-unit id="3ca88d77aca2d323542d2e8f12b83151e0846c19" translate="yes" xml:space="preserve">
          <source>USE EXAMPLES</source>
          <target state="translated">使用示例</target>
        </trans-unit>
        <trans-unit id="045095377d72052bacadc70846f65ba919bc72ee" translate="yes" xml:space="preserve">
          <source>USER METHODS</source>
          <target state="translated">用户方法</target>
        </trans-unit>
        <trans-unit id="eff0e1414e1813c02157d57d3f325f32947a8413" translate="yes" xml:space="preserve">
          <source>USE_MULTI &amp;amp; USE_IMP_SYS defined and USE_ITHREADS not defined</source>
          <target state="translated">已定义USE_MULTI和USE_IMP_SYS，未定义USE_ITHREADS</target>
        </trans-unit>
        <trans-unit id="5e29b7b3b7536de15b46013805cfeb875c7a61d3" translate="yes" xml:space="preserve">
          <source>USE_MULTI, USE_ITHREADS &amp;amp; USE_IMP_SYS defined</source>
          <target state="translated">定义了USE_MULTI，USE_ITHREADS和USE_IMP_SYS</target>
        </trans-unit>
        <trans-unit id="227996d58fdfdee97220bd395f44c03336330289" translate="yes" xml:space="preserve">
          <source>USE_PERL_FLOCK</source>
          <target state="translated">USE_PERL_FLOCK</target>
        </trans-unit>
        <trans-unit id="d403f19c30d9dafcf5b6a7bb8666159dacf7697f" translate="yes" xml:space="preserve">
          <source>USING B::Deparse AS A MODULE</source>
          <target state="translated">使用 B::Deparse 作为一个模块。</target>
        </trans-unit>
        <trans-unit id="2efa10816450d527d9e56d3271b7e34ea8c81a61" translate="yes" xml:space="preserve">
          <source>USING CONTEXT: THE DEBUG FILTER</source>
          <target state="translated">使用上下文:DEBUG过滤器</target>
        </trans-unit>
        <trans-unit id="5dc41a076ce2820059919cbbf35a7c867770cef6" translate="yes" xml:space="preserve">
          <source>USING FILTERS</source>
          <target state="translated">使用过滤器</target>
        </trans-unit>
        <trans-unit id="3d73074a3cddd39278e855bf130287734b3a28e3" translate="yes" xml:space="preserve">
          <source>USING LOCALES</source>
          <target state="translated">使用LOCALS</target>
        </trans-unit>
        <trans-unit id="e914e6326e1588417f534e760a668a311b7406cd" translate="yes" xml:space="preserve">
          <source>USING PERL IN OPENVOS</source>
          <target state="translated">在OPENVOS中使用PERL</target>
        </trans-unit>
        <trans-unit id="ac35aec57e40ba482f8f9fa734ce439013d2f6b2" translate="yes" xml:space="preserve">
          <source>USING THE EXTERNAL GZIP</source>
          <target state="translated">使用外部的GZIP文件</target>
        </trans-unit>
        <trans-unit id="6af50db97d3b4d2d4a30cc3bc98a5ffb4cb39ec7" translate="yes" xml:space="preserve">
          <source>USourceData.txt</source>
          <target state="translated">USourceData.txt</target>
        </trans-unit>
        <trans-unit id="6b28c2250a1cbb7c8f56dfcf0dd9e06201c35f2f" translate="yes" xml:space="preserve">
          <source>UTF stands for &quot;Unicode Transformation Format&quot;. UTF-8 is an encoding of Unicode into a sequence of 8-bit byte chunks, based on ASCII and Latin-1. The length of a sequence required to represent a Unicode code point depends on the ordinal number of that code point, with larger numbers requiring more bytes. UTF-EBCDIC is like UTF-8, but based on EBCDIC. They are enough alike that often, casual usage will conflate the two terms, and use &quot;UTF-8&quot; to mean both the UTF-8 found on ASCII platforms, and the UTF-EBCDIC found on EBCDIC ones.</source>
          <target state="translated">UTF是 &quot;Unicode转换格式 &quot;的缩写。UTF-8是一种基于ASCII和Latin-1的Unicode编码,将Unicode编码成8位字节块的序列。表示一个Unicode码点所需的序列长度取决于该码点的序数,数字越大需要的字节数越多。UTF-EBCDIC和UTF-8一样,但基于EBCDIC。它们非常相像,所以经常会有一些人把这两个术语混为一谈,用 &quot;UTF-8 &quot;来表示ASCII平台上的UTF-8和EBCDIC平台上的UTF-EBCDIC。</target>
        </trans-unit>
        <trans-unit id="c965e907f9d25c517a8e5bd79aea9417a0714217" translate="yes" xml:space="preserve">
          <source>UTF-16 is almost the same as UCS-2 but it supports</source>
          <target state="translated">UTF-16与UCS-2几乎相同,但它支持的是</target>
        </trans-unit>
        <trans-unit id="5222e4ab75ba1ce305284f282ec30a73156a366c" translate="yes" xml:space="preserve">
          <source>UTF-16, UTF-16BE, UTF-16LE, Surrogates, and &lt;code&gt;BOM&lt;/code&gt; 's (Byte Order Marks)</source>
          <target state="translated">UTF-16，UTF-16BE，UTF-16LE，代理和 &lt;code&gt;BOM&lt;/code&gt; （字节顺序标记）</target>
        </trans-unit>
        <trans-unit id="47a1ff59a1e826be6636526f502c21d7b7b97ead" translate="yes" xml:space="preserve">
          <source>UTF-32 (UCS-4) is a fixed-length encoding with each character taking 32 bits. Since it is 32-bit, there is no need for</source>
          <target state="translated">UTF-32(UCS-4)是一种固定长度的编码,每个字符占32位。由于它是32位的,所以没有必要使用 &quot;UCS-4&quot;。</target>
        </trans-unit>
        <trans-unit id="dfd8dce020ef601007001e4289b99a7908444d8a" translate="yes" xml:space="preserve">
          <source>UTF-32, UTF-32BE, UTF-32LE</source>
          <target state="translated">UTF-32,UTF-32BE,UTF-32LE。</target>
        </trans-unit>
        <trans-unit id="20e199acc434517cd4a6e5977a48bae6e5af47a4" translate="yes" xml:space="preserve">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>
        </trans-unit>
        <trans-unit id="4d56cb8e2ad2a50613de9fa7d9d9a0d239c1aca9" translate="yes" xml:space="preserve">
          <source>UTF-7 encoding</source>
          <target state="translated">UTF-7编码</target>
        </trans-unit>
        <trans-unit id="ba8308c0cebaf2cef9e02fb7f26e6c4f56ba6ce0" translate="yes" xml:space="preserve">
          <source>UTF-7 was not supported by Encode until version 1.95 because of that. But Unicode::String, a module by Gisle Aas which adds Unicode supports to non-utf8-savvy perl did support UTF-7, the UTF-7 support was added so Encode can supersede Unicode::String 100%.</source>
          <target state="translated">因为这个原因,Encode在1.95版本之前都不支持UTF-7,但Gisle Aas的Unicode::String模块增加了对UTF-7的支持。但是Gisle Aas的一个模块Unicode::String为不精通utf8的perl增加了Unicode支持,确实支持UTF-7,UTF-7的支持被加入,所以Encode可以100%取代Unicode::String。</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="e2635de14b396bd81c2a4f587434aea9cfbf99fc" translate="yes" xml:space="preserve">
          <source>UTF-8 and UTF-EBCDIC are two different encodings used to represent Unicode code points as sequences of bytes. Macros with the same names (but different definitions) in</source>
          <target state="translated">UTF-8和UTF-EBCDIC是两种不同的编码,用来表示Unicode码点的字节序列。中名称相同(但定义不同)的宏。</target>
        </trans-unit>
        <trans-unit id="8b4fe83acd749a66b827e068556fa7943eee22bb" translate="yes" xml:space="preserve">
          <source>UTF-8 and Unicode FAQ for Unix/Linux</source>
          <target state="translated">UTF-8和Unicode常见问题解答(Unix/Linux)</target>
        </trans-unit>
        <trans-unit id="79cdcb7150e1254a38f057938e6f4012fc46b08a" translate="yes" xml:space="preserve">
          <source>UTF-8 is a variable-length (1 to 4 bytes), byte-order independent encoding. In most of Perl's documentation, including elsewhere in this document, the term &quot;UTF-8&quot; means also &quot;UTF-EBCDIC&quot;. But in this section, &quot;UTF-8&quot; refers only to the encoding used on ASCII platforms. It is a superset of 7-bit US-ASCII, so anything encoded in ASCII has the identical representation when encoded in UTF-8.</source>
          <target state="translated">UTF-8 是一种可变长度(1 到 4 个字节)、独立于字节顺序的编码。在Perl的大部分文档中,包括本文档的其他地方,术语 &quot;UTF-8 &quot;也意味着 &quot;UTF-EBCDIC&quot;。但在本节中,&quot;UTF-8 &quot;仅指ASCII平台上使用的编码。它是7位US-ASCII的超集,所以任何用ASCII编码的东西在用UTF-8编码时都有相同的表示。</target>
        </trans-unit>
        <trans-unit id="64b07e44d3986db9cf7499225144a4d1d394db97" translate="yes" xml:space="preserve">
          <source>UTF-8 treats the first 128 codepoints, 0..127, the same as ASCII. They take only one byte per character. All other characters are encoded as two to four bytes using a complex scheme. Fortunately, Perl handles this for us, so we don't have to worry about this.</source>
          <target state="translated">UTF-8对前128个代码点0...127的处理与ASCII相同。它们每个字符只需要一个字节。所有其他的字符都要用一个复杂的方案编码成两到四个字节。幸运的是,Perl为我们处理了这个问题,所以我们不必担心这个问题。</target>
        </trans-unit>
        <trans-unit id="7443ec4bd05d2044739a43a92206bcfe32f068b2" translate="yes" xml:space="preserve">
          <source>UTF-8 vs. utf8 vs. UTF8</source>
          <target state="translated">UTF-8 vs.utf8 vs.UTF8。</target>
        </trans-unit>
        <trans-unit id="21357a91ac9a6238516304ecf3d0973befa29dc1" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC</source>
          <target state="translated">UTF-EBCDIC</target>
        </trans-unit>
        <trans-unit id="54206a5f5bcbb8b5ddd3ceb665085cec48ec6be8" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is defined by &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr16&quot;&gt;Unicode Technical Report #16&lt;/a&gt;. It is defined based on CCSID 1047, not allowing for the differences for other code pages. This allows for easy interchange of text between computers running different code pages, but makes it unusable, without adaptation, for Perl on those other code pages.</source>
          <target state="translated">UTF-EBCDIC由&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr16&quot;&gt;Unicode技术报告＃16&lt;/a&gt;定义。它是根据CCSID 1047定义的，不允许其他代码页有所不同。这样可以在运行不同代码页的计算机之间轻松交换文本，但是对于其他代码页上的Perl，如果不进行修改，就无法使用。</target>
        </trans-unit>
        <trans-unit id="fae1061497efd49ee6054c0a3d6e1ce19e05e6be" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is used on EBCDIC platforms. The largest Unicode code points take 5 bytes to represent (instead of 4 in UTF-8), and Perl extends it to a maximum of 7 bytes to encode pode points up to what can fit in a 32-bit word (instead of 13 bytes and a 64-bit word in UTF-8).</source>
          <target state="translated">在EBCDIC平台上使用UTF-EBCDIC。最大的Unicode码点需要5个字节来表示(而不是UTF-8中的4个字节),Perl将其扩展到最大7个字节,以将码点编码到32位字中(而不是UTF-8中的13个字节和64位字)。</target>
        </trans-unit>
        <trans-unit id="32e4aba336279eb247fca6069de55e692fafce3d" translate="yes" xml:space="preserve">
          <source>UTF-X</source>
          <target state="translated">UTF-X</target>
        </trans-unit>
        <trans-unit id="17562b3d061f2f42586076a6b020ba8eb357a3ff" translate="yes" xml:space="preserve">
          <source>UTILITIES</source>
          <target state="translated">UTILITIES</target>
        </trans-unit>
        <trans-unit id="58bc809d31f639453a46636f9c8ab08c8b78bb44" translate="yes" xml:space="preserve">
          <source>UTILITY FUNCTIONS</source>
          <target state="translated">实用功能</target>
        </trans-unit>
        <trans-unit id="994023f4756ccee554f76e83b238ef8441ca987c" translate="yes" xml:space="preserve">
          <source>Ultimate control over what should be done when (actually: each time) an option is encountered on the command line can be achieved by designating a reference to a subroutine (or an anonymous subroutine) as the option destination. When GetOptions() encounters the option, it will call the subroutine with two or three arguments. The first argument is the name of the option. (Actually, it is an object that stringifies to the name of the option.) For a scalar or array destination, the second argument is the value to be stored. For a hash destination, the second argument is the key to the hash, and the third argument the value to be stored. It is up to the subroutine to store the value, or do whatever it thinks is appropriate.</source>
          <target state="translated">通过指定一个对子程序(或一个匿名子程序)的引用作为选项的目标,可以最终控制在命令行上遇到一个选项时(实际上:每次)应该做什么。当GetOptions()遇到选项时,它将用两个或三个参数来调用子程序。第一个参数是期权的名称。(实际上,它是一个字符串化为选项名称的对象。)对于一个标量或数组目标,第二个参数是要存储的值。对于哈希目标,第二个参数是哈希的键,第三个参数是要存储的值。由子程序决定是否存储该值,或者做任何它认为合适的事情。</target>
        </trans-unit>
        <trans-unit id="fd11761cf7cb6cb9a563ded422bdfc4417516b2a" translate="yes" xml:space="preserve">
          <source>Unacceptable behavior will result in a public and clearly identified warning. Repeated unacceptable behavior will result in removal from the mailing list and revocation of rights to update rt.perl.org. The first removal is for one month. Subsequent removals will double in length. After six months with no warning, a user's ban length is reset. Removals, like warnings, are public.</source>
          <target state="translated">不可接受的行为将导致公开和明确的警告。重复的不可接受的行为将导致从邮件列表中移除,并取消更新rt.perl.org的权利。第一次移除的期限是一个月。其后的移除时间将加倍。六个月后,在没有警告的情况下,用户的禁言期会被重置。移除和警告一样,都是公开的。</target>
        </trans-unit>
        <trans-unit id="1f8a4652f1c5950bdfb9f442db5f7ff059a9e8ff" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;!&quot;&lt;/code&gt; performs logical negation, that is, &quot;not&quot;. See also &lt;code&gt;not&lt;/code&gt; for a lower precedence version of this.</source>
          <target state="translated">一元 &lt;code&gt;&quot;!&quot;&lt;/code&gt; 执行逻辑否定，即&amp;ldquo;不&amp;rdquo;。也见 &lt;code&gt;not&lt;/code&gt; 为这个优先级较低的版本。</target>
        </trans-unit>
        <trans-unit id="975143052b1e27f57ec5fcc07f42eb1c0eae9dc3" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;+&quot;&lt;/code&gt; has no effect whatsoever, even on strings. It is useful syntactically for separating a function name from a parenthesized expression that would otherwise be interpreted as the complete list of function arguments. (See examples above under &lt;a href=&quot;#Terms-and-List-Operators-(Leftward)&quot;&gt;Terms and List Operators (Leftward)&lt;/a&gt;.)</source>
          <target state="translated">一元 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 即使对字符串也不起作用。在语法上将函数名称与带括号的表达式分隔开很有用，否则该表达式会被解释为函数参数的完整列表。 （请参阅上面&amp;ldquo; &lt;a href=&quot;#Terms-and-List-Operators-(Leftward)&quot;&gt;条款和列表运算符（向左）&amp;rdquo;&lt;/a&gt;下的示例。）</target>
        </trans-unit>
        <trans-unit id="cbc2e014fe3be3f69d01617e0a9853fb77867e55" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;-&quot;&lt;/code&gt; performs arithmetic negation if the operand is numeric, including any string that looks like a number. If the operand is an identifier, a string consisting of a minus sign concatenated with the identifier is returned. Otherwise, if the string starts with a plus or minus, a string starting with the opposite sign is returned. One effect of these rules is that &lt;code&gt;-bareword&lt;/code&gt; is equivalent to the string &lt;code&gt;&quot;-bareword&quot;&lt;/code&gt; . If, however, the string begins with a non-alphabetic character (excluding &lt;code&gt;&quot;+&quot;&lt;/code&gt; or &lt;code&gt;&quot;-&quot;&lt;/code&gt; ), Perl will attempt to convert the string to a numeric, and the arithmetic negation is performed. If the string cannot be cleanly converted to a numeric, Perl will give the warning &lt;b&gt;Argument &quot;the string&quot; isn't numeric in negation (-) at ...&lt;/b&gt;.</source>
          <target state="translated">如果操作数是数字（包括任何看起来像数字的字符串），一元 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 执行算术求反。如果操作数是标识符，则返回一个字符串，该字符串由与标识符连接的减号组成。否则，如果字符串以加号或减号开头，则返回以相反符号开头的字符串。这些规则的作用之一是 &lt;code&gt;-bareword&lt;/code&gt; 等效于字符串 &lt;code&gt;&quot;-bareword&quot;&lt;/code&gt; 。但是，如果字符串以非字母字符（ &lt;code&gt;&quot;+&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 除外）开头，则Perl将尝试将字符串转换为数字，然后执行算术求反。如果字符串不能干净地转换为数字，Perl将给出警告&lt;b&gt;参数&amp;ldquo; string&amp;rdquo;不是...的否定（-）数字&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="75765e3d8911e6ac713c74a3a1fc1d709b9ed2ea" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;\&quot;&lt;/code&gt; creates a reference to whatever follows it. See &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; and &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Do not confuse this behavior with the behavior of backslash within a string, although both forms do convey the notion of protecting the next thing from interpolation.</source>
          <target state="translated">一元 &lt;code&gt;&quot;\&quot;&lt;/code&gt; 会创建一个对其后面内容的引用。参见&lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;和&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。不要混淆此行为与字符串中的反斜杠行为，尽管这两种形式都传达了保护下一个内容免受插值的影响的概念。</target>
        </trans-unit>
        <trans-unit id="a440a050a6ba4df9312abb517ec0cbc1f89e1767" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;not&quot;&lt;/code&gt; returns the logical negation of the expression to its right. It's the equivalent of &lt;code&gt;&quot;!&quot;&lt;/code&gt; except for the very low precedence.</source>
          <target state="translated">一元 &lt;code&gt;&quot;not&quot;&lt;/code&gt; 返回表达式的逻辑取反。相当于 &lt;code&gt;&quot;!&quot;&lt;/code&gt; 除了非常低的优先级。</target>
        </trans-unit>
        <trans-unit id="4dae9b42247425fb7e1e868bc6aec93255104f04" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;~&quot;&lt;/code&gt; performs bitwise negation, that is, 1's complement. For example, &lt;code&gt;0666 &amp;amp; ~027&lt;/code&gt; is 0640. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt; and &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.) Note that the width of the result is platform-dependent: &lt;code&gt;~0&lt;/code&gt; is 32 bits wide on a 32-bit platform, but 64 bits wide on a 64-bit platform, so if you are expecting a certain bit width, remember to use the &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; operator to mask off the excess bits.</source>
          <target state="translated">一元 &lt;code&gt;&quot;~&quot;&lt;/code&gt; 执行按位求反，即1的补码。例如， &lt;code&gt;0666 &amp;amp; ~027&lt;/code&gt; 是0640.（参见&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;整数算术&lt;/a&gt;和&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;按位字符串运算符&lt;/a&gt;。）注意，结果的宽度是依赖于平台的： &lt;code&gt;~0&lt;/code&gt; 是32个位宽为32位的平台上，但64个位宽在64位平台上，因此，如果期望某个位宽，请记住使用 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 运算符来掩盖多余的位。</target>
        </trans-unit>
        <trans-unit id="121bb514c3415be69016271f5f8950c0aed3f161" translate="yes" xml:space="preserve">
          <source>Unbackslashed prototype characters have special meanings. Any unbackslashed &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; eats all remaining arguments, and forces list context. An argument represented by &lt;code&gt;$&lt;/code&gt; forces scalar context. An &lt;code&gt;&amp;amp;&lt;/code&gt; requires an anonymous subroutine, which, if passed as the first argument, does not require the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; keyword or a subsequent comma.</source>
          <target state="translated">不加反斜杠的原型字符具有特殊含义。任何不加反斜杠的 &lt;code&gt;@&lt;/code&gt; 或 &lt;code&gt;%&lt;/code&gt; 都会吃掉所有剩余的参数，并强制列出上下文。由 &lt;code&gt;$&lt;/code&gt; 表示的参数强制标量上下文。一个 &lt;code&gt;&amp;amp;&lt;/code&gt; 需要匿名的子程序，其中，如果作为第一个参数传递，不需要 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 关键字或随后的逗号。</target>
        </trans-unit>
        <trans-unit id="825c40d18a2a673a59517a26d2876574d355db3e" translate="yes" xml:space="preserve">
          <source>Uncompress gzip, zip, bzip2 or lzop file/buffer</source>
          <target state="translated">解压gzip、zip、bzip2或lzop文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="aed55ac0a8b1616e77c1e8b5f3fc823c056e7f68" translate="yes" xml:space="preserve">
          <source>Uncompress zlib-based (zip, gzip) file/buffer</source>
          <target state="translated">解压基于zlib(zip,gzip)的文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="5566ebf8e86133343de98e57588751d94f017699" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$input&lt;/code&gt; and writes the uncompressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">解压缩 &lt;code&gt;$input&lt;/code&gt; 并将未压缩的数据写入 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3241d8b84b7531f4c85af8e73c024fd4504975c7" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$source&lt;/code&gt; . If successful it returns the uncompressed data. Otherwise it returns</source>
          <target state="translated">解压缩 &lt;code&gt;$source&lt;/code&gt; 。如果成功，它将返回未压缩的数据。否则返回</target>
        </trans-unit>
        <trans-unit id="ac8d3226186ea01833996c8b65de3f2a8379790e" translate="yes" xml:space="preserve">
          <source>Uncompression</source>
          <target state="translated">Uncompression</target>
        </trans-unit>
        <trans-unit id="4189d548d277ce627b98749a55c3556ffc35219e" translate="yes" xml:space="preserve">
          <source>Unconditionally match a bareword or any other single character, and then go back to step 1.</source>
          <target state="translated">无条件匹配一个裸字或其他任何一个单字,然后回到步骤1。</target>
        </trans-unit>
        <trans-unit id="577343970a5bf9b7cb8738f42c2797ca4589087a" translate="yes" xml:space="preserve">
          <source>Uncuddled elses and &quot;K&amp;amp;R&quot; style for indenting control constructs</source>
          <target state="translated">缩进的控件和&amp;ldquo; K＆R&amp;rdquo;风格的缩进控件结构</target>
        </trans-unit>
        <trans-unit id="11c11d31d108dd964ce797e5076b1d8839850791" translate="yes" xml:space="preserve">
          <source>Uncuddled elses.</source>
          <target state="translated">未被拥抱的地方。</target>
        </trans-unit>
        <trans-unit id="5cd9e75daaa9152346601595647eb2d9696e6583" translate="yes" xml:space="preserve">
          <source>Undef if an external</source>
          <target state="translated">如果是外部,则为不定义。</target>
        </trans-unit>
        <trans-unit id="b410752a7d8baa31a708ac9e0618b37a2bdd788d" translate="yes" xml:space="preserve">
          <source>Undefined subroutine &amp;amp;main::GetOptions called</source>
          <target state="translated">未定义的子程序＆main :: GetOptions被调用</target>
        </trans-unit>
        <trans-unit id="4be1ae516287ece8c814ce973af8c8cef754916c" translate="yes" xml:space="preserve">
          <source>Undefines the array. Frees the memory used by the av to store its list of scalars. If any destructors are triggered as a result, the av itself may be freed.</source>
          <target state="translated">解除对数组的定义。释放av用于存储其标量列表的内存。如果因此触发了任何析构函数,则可以释放av本身。</target>
        </trans-unit>
        <trans-unit id="270b863b48b0c13c0b01735bf826d9b654084021" translate="yes" xml:space="preserve">
          <source>Undefines the collation element as if it were unassigned in the &lt;code&gt;table&lt;/code&gt; . This reduces the size of the table. If an unassigned character appears in the string to be collated, the sort key is made from its codepoint as a single-character collation element, as it is greater than any other assigned collation elements (in the codepoint order among the unassigned characters). But, it'd be better to ignore characters unfamiliar to you and maybe never used.</source>
          <target state="translated">取消定义排序规则元素，就好像在 &lt;code&gt;table&lt;/code&gt; 中未分配该元素一样。这样可以减小表的大小。如果未分配的字符出现在要校对的字符串中，则排序键将从其代码点作为单字符归类元素，因为它大于任何其他已分配的归类元素（按未分配字符中的代码点顺序）。但是，最好忽略不熟悉的字符，也许永远不要使用。</target>
        </trans-unit>
        <trans-unit id="7b61a323c52c38306eb024952539f4f8c5a7ffe3" translate="yes" xml:space="preserve">
          <source>Undefines the hash. The XS equivalent of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef(%hash)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">未定义哈希。XS等效于 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef(%hash)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21918cc87ca44856538ac74361e547848b42b7b4" translate="yes" xml:space="preserve">
          <source>Undefines the value of EXPR, which must be an lvalue. Use only on a scalar value, an array (using &lt;code&gt;@&lt;/code&gt; ), a hash (using &lt;code&gt;%&lt;/code&gt; ), a subroutine (using &lt;code&gt;&amp;amp;&lt;/code&gt; ), or a typeglob (using &lt;code&gt;*&lt;/code&gt; ). Saying &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; will probably not do what you expect on most predefined variables or DBM list values, so don't do that; see &lt;a href=&quot;#delete&quot;&gt;delete&lt;/a&gt;. Always returns the undefined value. You can omit the EXPR, in which case nothing is undefined, but you still get an undefined value that you could, for instance, return from a subroutine, assign to a variable, or pass as a parameter. Examples:</source>
          <target state="translated">未定义EXPR的值，该值必须为左值。仅用于标量值，数组（使用 &lt;code&gt;@&lt;/code&gt; ），哈希（使用 &lt;code&gt;%&lt;/code&gt; ），子例程（使用 &lt;code&gt;&amp;amp;&lt;/code&gt; ）或typeglob（使用 &lt;code&gt;*&lt;/code&gt; ）。在大多数预定义变量或DBM列表值上说 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; 可能不会达到您的期望，所以不要那样做。请参阅&lt;a href=&quot;#delete&quot;&gt;删除&lt;/a&gt;。始终返回未定义的值。您可以省略EXPR，在这种情况下，所有内容均未定义，但仍会得到一个未定义的值，例如，可以从子例程返回，分配给变量或作为参数传递。例子：</target>
        </trans-unit>
        <trans-unit id="12772c94a5d6a3598c32da79f4c1c4affc5b608e" translate="yes" xml:space="preserve">
          <source>Undefines the value of EXPR, which must be an lvalue. Use only on a scalar value, an array (using &lt;code&gt;@&lt;/code&gt; ), a hash (using &lt;code&gt;%&lt;/code&gt; ), a subroutine (using &lt;code&gt;&amp;amp;&lt;/code&gt; ), or a typeglob (using &lt;code&gt;*&lt;/code&gt; ). Saying &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; will probably not do what you expect on most predefined variables or DBM list values, so don't do that; see &lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;. Always returns the undefined value. You can omit the EXPR, in which case nothing is undefined, but you still get an undefined value that you could, for instance, return from a subroutine, assign to a variable, or pass as a parameter. Examples:</source>
          <target state="translated">未定义EXPR的值，该值必须为左值。仅用于标量值，数组（使用 &lt;code&gt;@&lt;/code&gt; ），哈希（使用 &lt;code&gt;%&lt;/code&gt; ），子例程（使用 &lt;code&gt;&amp;amp;&lt;/code&gt; ）或typeglob（使用 &lt;code&gt;*&lt;/code&gt; ）。在大多数预定义变量或DBM列表值上说 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; 可能不会达到您的期望，所以不要那样做。请参阅&lt;a href=&quot;delete&quot;&gt;删除&lt;/a&gt;。始终返回未定义的值。您可以省略EXPR，在这种情况下，所有内容均未定义，但仍会得到一个未定义的值，例如，可以从子例程返回，分配给变量或作为参数传递。例子：</target>
        </trans-unit>
        <trans-unit id="8b42ea56822642513e4f112de38357bed9dd6a64" translate="yes" xml:space="preserve">
          <source>Undefining this symbol disables the PerlIO abstraction. PerlIO is now the default; it is not recommended to disable PerlIO.</source>
          <target state="translated">取消定义这个符号可以禁用PerlIO抽象。PerlIO现在是默认的,不建议禁用PerlIO。</target>
        </trans-unit>
        <trans-unit id="14931b1ffe46d4f806d87924392ea8d8ba051a3f" translate="yes" xml:space="preserve">
          <source>Undefining this symbol forces Perl to be compiled statically.</source>
          <target state="translated">不定义这个符号会强制Perl进行静态编译。</target>
        </trans-unit>
        <trans-unit id="55d31ccf7c7a9061158740ae0e4ba2a4be4c51d6" translate="yes" xml:space="preserve">
          <source>Under &quot;Classic&quot; MacOS, a perl program will have the appropriate Creator and Type, so that double-clicking them will invoke the MacPerl application. Under Mac OS X, clickable apps can be made from any &lt;code&gt;#!&lt;/code&gt; script using Wil Sanchez' DropScript utility: &lt;a href=&quot;http://www.wsanchez.net/software/&quot;&gt;http://www.wsanchez.net/software/&lt;/a&gt; .</source>
          <target state="translated">在&amp;ldquo;经典&amp;rdquo; MacOS下，perl程序将具有适当的创建者和类型，因此双击它们将调用MacPerl应用程序。在Mac OS X下，可通过任何 &lt;code&gt;#!&lt;/code&gt; 来创建可点击的应用程序！使用Wil Sanchez的DropScript实用程序编写脚本：&lt;a href=&quot;http://www.wsanchez.net/software/&quot;&gt;http&lt;/a&gt; ://www.wsanchez.net/software/ 。</target>
        </trans-unit>
        <trans-unit id="7de147ca0cf42a020c2b34e4934080e8fbf00bba" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;../test/harness&quot;&gt;Test::Harness&lt;/a&gt;, test number 2 would</source>
          <target state="translated">在&lt;a href=&quot;../test/harness&quot;&gt;Test :: Harness下&lt;/a&gt;，测试编号2将</target>
        </trans-unit>
        <trans-unit id="50510298fcc80cb0b2cfe5fcb98eb1382cb9d484" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , detection step of discontiguous contractions will be skipped.</source>
          <target state="translated">在 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; ，不连续收缩的检测步骤将被跳过。</target>
        </trans-unit>
        <trans-unit id="da1bc7be7a27894ec56a14e00f77fdf88c07658e" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;array_base&quot;&lt;/code&gt; , &lt;code&gt;$[&lt;/code&gt; no longer has any effect, and always contains 0. Assigning 0 to it is permitted, but any other value will produce an error.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; ，或者 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;array_base&quot;&lt;/code&gt; ， &lt;code&gt;$[&lt;/code&gt; 不再具有任何作用，并且始终包含0。允许为其分配0，但是任何其他值都会产生错误。</target>
        </trans-unit>
        <trans-unit id="bacf555aace53131b41a0f7ef63c9e3e7d03589b" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;unicode_strings&lt;/code&gt; starting in Perl 5.12.0, Unicode rules are generally used. See &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; for details on how this works in combination with various other pragmas.</source>
          <target state="translated">在 &lt;code&gt;unicode_strings&lt;/code&gt; 在Perl 5.12.0开始，统一规则通常使用。有关与其他各种语用结合使用的详细信息，请参见&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94fe5caf324bcb104f1845ec70df5cb17cd45071" translate="yes" xml:space="preserve">
          <source>Under Cygwin, $^E is the same as $!. When using &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32 API Functions&lt;/a&gt;, use &lt;code&gt;Win32::GetLastError()&lt;/code&gt; to get the last Windows error.</source>
          <target state="translated">在Cygwin下，$ ^ E与$！相同。使用&lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32 API Functions时&lt;/a&gt;，请使用 &lt;code&gt;Win32::GetLastError()&lt;/code&gt; 获取最后的Windows错误。</target>
        </trans-unit>
        <trans-unit id="08490cc0df2a509f16cddc3cf2a4ae40e649767f" translate="yes" xml:space="preserve">
          <source>Under EBCDIC platforms, &lt;code&gt;e2char($n)&lt;/code&gt; may not always be the same as &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(e2charnum($n))&lt;/a&gt;&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr($Name2character_number{$name})&lt;/a&gt;&lt;/code&gt;, because the strings are returned as native, and the numbers are returned as Unicode. However, for Perls starting with v5.8, &lt;code&gt;e2char($n)&lt;/code&gt; is the same as &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native(e2charnum($n)))&lt;/a&gt;&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native($Name2character_number{$name}))&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在EBCDIC平台上， &lt;code&gt;e2char($n)&lt;/code&gt; 可能并不总是与 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(e2charnum($n))&lt;/a&gt;&lt;/code&gt; ，对于 &lt;code&gt;$Name2character{$name}&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr($Name2character_number{$name})&lt;/a&gt;&lt;/code&gt; ，因为返回了字符串作为本机，并且数字以Unicode返回。但是，对于以v5.8开头的Perls， &lt;code&gt;e2char($n)&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native(e2charnum($n)))&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;$Name2character{$name}&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native($Name2character_number{$name}))&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18254acc65d18b7ddbf875f7bfc47db0d75ce39a" translate="yes" xml:space="preserve">
          <source>Under NFS this will use the time of the NFS server, not the time of the local machine. If there is a time synchronization problem, the NFS server and local machine will have different times. The Unix touch(1) command will in fact normally use this form instead of the one shown in the first example.</source>
          <target state="translated">在NFS下,这将使用NFS服务器的时间,而不是本地机器的时间。如果存在时间同步问题,NFS 服务器和本地机器的时间将不同。事实上,Unix touch(1)命令通常会使用这种形式,而不是第一个例子中所示的形式。</target>
        </trans-unit>
        <trans-unit id="f3924a4fe96e1e85710f171a0842dfde3423eb52" translate="yes" xml:space="preserve">
          <source>Under OS/2, &lt;code&gt;$^E&lt;/code&gt; is set to the error code of the last call to OS/2 API either via CRT, or directly from perl.</source>
          <target state="translated">在OS / 2下，将 &lt;code&gt;$^E&lt;/code&gt; 设置为通过CRT或直接从perl对OS / 2 API的最后一次调用的错误代码。</target>
        </trans-unit>
        <trans-unit id="19dcdc34494760727e410f497dbed91a176d6c5e" translate="yes" xml:space="preserve">
          <source>Under Perl 5.10 only, using a string eval when &lt;code&gt;autodie&lt;/code&gt; is in effect can cause the autodie behaviour to leak into the surrounding scope. This can be worked around by using a &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; at the end of the scope to explicitly remove autodie's effects, or by avoiding the use of string eval.</source>
          <target state="translated">仅在Perl 5.10下，当自动 &lt;code&gt;autodie&lt;/code&gt; 有效时使用字符串eval 可能会导致autodie行为泄漏到周围的范围中。可以通过在范围末尾使用 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; 来显式删除autodie的效果，或避免使用字符串eval来解决此问题。</target>
        </trans-unit>
        <trans-unit id="1824d549ede70b3449b6bc94fa47857184a96f9f" translate="yes" xml:space="preserve">
          <source>Under Perl 5.18 and later, SvREADONLY only applies to read-only variables, and, under 5.20, copy-on-write scalars can also be read-only, so the above check is incorrect. You just want:</source>
          <target state="translated">在Perl 5.18及以后的版本中,SvREADONLY只适用于只读变量,而在5.20下,写后复制的标量也可以是只读的,所以上面的检查是不正确的。你只是想。</target>
        </trans-unit>
        <trans-unit id="8d107d150b9abd6d04d1d29a993fa6ea829d9209" translate="yes" xml:space="preserve">
          <source>Under Perl 5.8 only, &lt;code&gt;autodie&lt;/code&gt;</source>
          <target state="translated">仅在Perl 5.8下， &lt;code&gt;autodie&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e28f5c058f0915564622ac46660d6f84c05ab318" translate="yes" xml:space="preserve">
          <source>Under Perl 5.8, the &lt;code&gt;given/when&lt;/code&gt; structure is not available, so the following structure may be used:</source>
          <target state="translated">在Perl 5.8中， &lt;code&gt;given/when&lt;/code&gt; 结构不可用，因此可以使用以下结构：</target>
        </trans-unit>
        <trans-unit id="ef993909ab6a97a91baf7e650bc7ce46f77c2516" translate="yes" xml:space="preserve">
          <source>Under QNX 6.2.0 there are still a few tests which fail. See below and hints/qnx.sh for more information.</source>
          <target state="translated">在 QNX 6.2.0 下,仍有一些测试失败。请参见下文和提示/qnx.sh 了解更多信息。</target>
        </trans-unit>
        <trans-unit id="66b5ec5cf7fb5924aee8dffa63eba13ccd60d52e" translate="yes" xml:space="preserve">
          <source>Under Unicode rules, there are a few case-insensitive matches that cross the 255/256 boundary. Except for UTF-8 locales in Perls v5.20 and later, these are disallowed under &lt;code&gt;/l&lt;/code&gt; . For example, 0xFF (on ASCII platforms) does not caselessly match the character at 0x178, &lt;code&gt;LATIN
CAPITAL LETTER Y WITH DIAERESIS&lt;/code&gt; , because 0xFF may not be &lt;code&gt;LATIN SMALL
LETTER Y WITH DIAERESIS&lt;/code&gt; in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is.</source>
          <target state="translated">根据Unicode规则，有一些不区分大小写的匹配跨越255/256边界。除了Perls v5.20及更高版本中的UTF-8语言环境外， &lt;code&gt;/l&lt;/code&gt; 下不允许使用这些语言环境。例如，0xFF（在ASCII平台上）不能不区分大小写地匹配0x178的字符， &lt;code&gt;LATIN CAPITAL LETTER Y WITH DIAERESIS&lt;/code&gt; ，因为在当前语言环境中0xFF可能不是 &lt;code&gt;LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; ，而Perl无法知道是否字符甚至存在于语言环境中，更不用说代码点了。</target>
        </trans-unit>
        <trans-unit id="666da3b151d79c3526ad94c74b4a7b5272bc4ad7" translate="yes" xml:space="preserve">
          <source>Under Unicode rules, these upper-Latin1 characters are interpreted as Unicode code points, which means they have the same semantics as Latin-1 (ISO-8859-1) and C1 controls.</source>
          <target state="translated">根据Unicode规则,这些上拉丁1字符被解释为Unicode码点,这意味着它们与Latin-1(ISO-8859-1)和C1控制具有相同的语义。</target>
        </trans-unit>
        <trans-unit id="15d191765263aacd2b7fcad31e78fb6cf886a85b" translate="yes" xml:space="preserve">
          <source>Under VMS this reflects the actual VMS exit status; i.e. it is the same as &lt;code&gt;$?&lt;/code&gt; when the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; is in effect.</source>
          <target state="translated">在VMS下，这反映了VMS的实际退出状态；即与 &lt;code&gt;$?&lt;/code&gt; 相同吗？当编译指示 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; 时，使用 vmsish'status'。</target>
        </trans-unit>
        <trans-unit id="737324e93129014d33d4923a010ebe747aa167f7" translate="yes" xml:space="preserve">
          <source>Under VMS, &lt;code&gt;$^E&lt;/code&gt; provides the VMS status value from the last system error. This is more specific information about the last system error than that provided by &lt;code&gt;$!&lt;/code&gt; . This is particularly important when &lt;code&gt;$!&lt;/code&gt; is set to &lt;b&gt;EVMSERR&lt;/b&gt;.</source>
          <target state="translated">在VMS下， &lt;code&gt;$^E&lt;/code&gt; 提供上一次系统错误后的VMS状态值。与 &lt;code&gt;$!&lt;/code&gt; 提供的信息相比，这是有关上一个系统错误的更具体的信息。。这在 &lt;code&gt;$!&lt;/code&gt; 时尤其重要！设置为&lt;b&gt;EVMSERR&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="50b3f98ca540bd0c81d34840956f838255c71318" translate="yes" xml:space="preserve">
          <source>Under VMS, if there is no directory information in the $path, then the current default device and directory is used.</source>
          <target state="translated">在VMS下,如果$path中没有目录信息,则使用当前默认的设备和目录。</target>
        </trans-unit>
        <trans-unit id="3aaae4cddb5ecef27b2c450c8cc4b4b174c7016f" translate="yes" xml:space="preserve">
          <source>Under VMS, the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status, instead of the default emulation of POSIX status; see &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? in perlvms&lt;/a&gt; for details.</source>
          <target state="translated">在VMS下， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; 的编译指示使 &lt;code&gt;$?&lt;/code&gt; 反映实际的VMS退出状态，而不是POSIX状态的默认模拟；看到&lt;a href=&quot;perlvms#%24%3f&quot;&gt;$？在perlvms中&lt;/a&gt;获取详细信息。</target>
        </trans-unit>
        <trans-unit id="711e7c0754f84b5e7bda634825aa4039a4a70c54" translate="yes" xml:space="preserve">
          <source>Under Win32's &quot;test&quot; target you may use the TEST_SWITCHES and TEST_FILES environment variables to control the behaviour of</source>
          <target state="translated">在Win32的 &quot;test &quot;目标下,你可以使用TEST_SWITCHES和TEST_FILES环境变量来控制下面的行为</target>
        </trans-unit>
        <trans-unit id="53c6d0758bf54648c779157ed9111dd650df9efe" translate="yes" xml:space="preserve">
          <source>Under Win32, &lt;code&gt;$^E&lt;/code&gt; always returns the last error information reported by the Win32 call &lt;code&gt;GetLastError()&lt;/code&gt; which describes the last error from within the Win32 API. Most Win32-specific code will report errors via &lt;code&gt;$^E&lt;/code&gt; . ANSI C and Unix-like calls set &lt;code&gt;errno&lt;/code&gt; and so most portable Perl code will report errors via &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">在Win32下， &lt;code&gt;$^E&lt;/code&gt; 总是返回Win32调用 &lt;code&gt;GetLastError()&lt;/code&gt; 报告的最后错误信息，该信息描述了Win32 API中的最后一个错误。大多数特定于Win32的代码将通过 &lt;code&gt;$^E&lt;/code&gt; 报告错误。ANSI C和类Unix调用设置 &lt;code&gt;errno&lt;/code&gt; ，因此大多数可移植的Perl代码将通过 &lt;code&gt;$!&lt;/code&gt; 报告错误！。</target>
        </trans-unit>
        <trans-unit id="445377f279bee790252626a9efe4c710c5fb31ec" translate="yes" xml:space="preserve">
          <source>Under Windows and VMS the option file is named</source>
          <target state="translated">在Windows和VMS下,选项文件名为</target>
        </trans-unit>
        <trans-unit id="991af3b0df6455b17cae9de8484aa49771ee9333" translate="yes" xml:space="preserve">
          <source>Under a few operating systems, &lt;code&gt;$^E&lt;/code&gt; may contain a more verbose error indicator, such as in this case, &quot;CDROM tray not closed.&quot; Systems that do not support extended error messages leave &lt;code&gt;$^E&lt;/code&gt; the same as &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">在某些操作系统下， &lt;code&gt;$^E&lt;/code&gt; 可能包含更详细的错误指示符，例如在这种情况下，&amp;ldquo; CDROM托盘未关闭&amp;rdquo;。不支持扩展错误消息的系统将 &lt;code&gt;$^E&lt;/code&gt; 与 &lt;code&gt;$!&lt;/code&gt; 相同。。</target>
        </trans-unit>
        <trans-unit id="b8188d9bfb2c028e78df0c34f466ab12923ca95e" translate="yes" xml:space="preserve">
          <source>Under bignum (or bigint or bigrat), Perl will &quot;upgrade&quot; the numbers appropriately. This means that:</source>
          <target state="translated">在bignum(或bigint或bigrat)下,Perl会适当地 &quot;升级 &quot;数字。这意味着</target>
        </trans-unit>
        <trans-unit id="936167913e1d36052a60fe747af5e2acfb71f327" translate="yes" xml:space="preserve">
          <source>Under case-sensitive matching, these both match the same code points as &lt;code&gt;\p{General Category=Titlecase_Letter}&lt;/code&gt; (&lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; ). The difference is that under &lt;code&gt;/i&lt;/code&gt; caseless matching, these match the same as &lt;code&gt;\p{Cased}&lt;/code&gt; , whereas &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; matches &lt;code&gt;\p{Cased_Letter&lt;/code&gt; ).</source>
          <target state="translated">在区分大小写的匹配下，它们都与 &lt;code&gt;\p{General Category=Titlecase_Letter}&lt;/code&gt; （ &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; ）相同的代码点匹配。区别在于，在 &lt;code&gt;/i&lt;/code&gt; 不区分大小写的匹配下，这些匹配与 &lt;code&gt;\p{Cased}&lt;/code&gt; ，而 &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; 匹配 &lt;code&gt;\p{Cased_Letter&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="58098e551f5eebaa46d0d3a19d00f14ced3f4d46" translate="yes" xml:space="preserve">
          <source>Under ithreads the optree is read only. If you want to enforce this, to check for write accesses from buggy code, compile with &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_OPS&lt;/code&gt; to enable code that allocates op memory via &lt;code&gt;mmap&lt;/code&gt; , and sets it read-only when it is attached to a subroutine. Any write access to an op results in a &lt;code&gt;SIGBUS&lt;/code&gt; and abort.</source>
          <target state="translated">在ithreads下，optree是只读的。如果要强制执行此操作，要检查来自错误代码的写访问，请使用 &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_OPS&lt;/code&gt; 进行编译，以启用通过 &lt;code&gt;mmap&lt;/code&gt; 分配操作内存的代码，并在将其附加到子例程时将其设置为只读。对op的任何写访问都会导致 &lt;code&gt;SIGBUS&lt;/code&gt; 并中止。</target>
        </trans-unit>
        <trans-unit id="41c5c0dce73b6a45e16e6c80203f13488d40f1dd" translate="yes" xml:space="preserve">
          <source>Under the &quot;switch&quot; feature, Perl gains the experimental keywords &lt;code&gt;given&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;break&lt;/code&gt; . Starting from Perl 5.16, one can prefix the switch keywords with &lt;code&gt;CORE::&lt;/code&gt; to access the feature without a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; statement. The keywords &lt;code&gt;given&lt;/code&gt; and &lt;code&gt;when&lt;/code&gt; are analogous to &lt;code&gt;switch&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt; in other languages, so the code in the previous section could be rewritten as</source>
          <target state="translated">在&amp;ldquo;开关&amp;rdquo;功能，Perl中获得了实验用的关键字 &lt;code&gt;given&lt;/code&gt; ， &lt;code&gt;when&lt;/code&gt; ， &lt;code&gt;default&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;break&lt;/code&gt; 。从Perl 5.16开始，可以在switch关键字前添加 &lt;code&gt;CORE::&lt;/code&gt; 前缀，以在不 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; 语句的情况下访问该功能。 &lt;code&gt;given&lt;/code&gt; 的关键字和 &lt;code&gt;when&lt;/code&gt; 类似于其他语言中的 &lt;code&gt;switch&lt;/code&gt; 和 &lt;code&gt;case&lt;/code&gt; ，因此上一节中的代码可以重写为</target>
        </trans-unit>
        <trans-unit id="3dcedc6c33e9a6ba46a7f82a03dd4b7c259f61b3" translate="yes" xml:space="preserve">
          <source>Under the &lt;code&gt;unicode_eval&lt;/code&gt; feature, Perl's &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; function, when passed a string, will evaluate it as a string of characters, ignoring any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declarations. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; exists to declare the encoding of the script, which only makes sense for a stream of bytes, not a string of characters. Source filters are forbidden, as they also really only make sense on strings of bytes. Any attempt to activate a source filter will result in an error.</source>
          <target state="translated">在 &lt;code&gt;unicode_eval&lt;/code&gt; 功能下，Perl的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 函数在传递字符串时会将其评估为字符串，而不会 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 声明。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 可以声明脚本的编码，该脚本仅对字节流有意义，而对字符串不起作用。禁止使用源过滤器，因为它们实际上仅对字节字符串有意义。任何尝试激活源过滤器的操作都会导致错误。</target>
        </trans-unit>
        <trans-unit id="3ed7e8de69faa9a39e5b719579b31e326e5e1ba3" translate="yes" xml:space="preserve">
          <source>Under the Mac, it depends which environment you are using. The MacPerl shell, or MPW, is much like Unix shells in its support for several quoting variants, except that it makes free use of the Mac's non-ASCII characters as control characters.</source>
          <target state="translated">在Mac下,要看你使用的是什么环境。MacPerl shell,也就是MPW,和Unix shell很像,它支持几种引号变体,只是它可以自由使用Mac的非ASCII字符作为控制字符。</target>
        </trans-unit>
        <trans-unit id="57a69bed4d30aeb2c23df15a4942d2f1bc4e9a99" translate="yes" xml:space="preserve">
          <source>Under the current implementation, the &lt;code&gt;foreach&lt;/code&gt; loop can be anywhere within the &lt;code&gt;when&lt;/code&gt; modifier's dynamic scope, but must be within the &lt;code&gt;given&lt;/code&gt; block's lexical scope. This restricted may be relaxed in a future release. See &lt;a href=&quot;#Switch-Statements&quot;&gt;Switch Statements&lt;/a&gt; below.</source>
          <target state="translated">在当前实现下， &lt;code&gt;foreach&lt;/code&gt; 循环可以在 &lt;code&gt;when&lt;/code&gt; 修饰符的动态范围内的任何位置，但必须在 &lt;code&gt;given&lt;/code&gt; 块的词法范围内。在将来的版本中，可以放宽此限制。请参阅下面的&lt;a href=&quot;#Switch-Statements&quot;&gt;切换语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e08f959b6899ef90dffb2ee9e0e0a8572c0a7c28" translate="yes" xml:space="preserve">
          <source>Under the hood, Perl filehandles are instances of the &lt;code&gt;IO::Handle&lt;/code&gt; or &lt;code&gt;IO::File&lt;/code&gt; class. Once you have an open filehandle, you can call methods on it. Additionally, you can call methods on the &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , and &lt;code&gt;STDERR&lt;/code&gt; filehandles.</source>
          <target state="translated">在幕后，Perl文件句柄是 &lt;code&gt;IO::Handle&lt;/code&gt; 或 &lt;code&gt;IO::File&lt;/code&gt; 类的实例。拥有打开的文件句柄后，可以在其上调用方法。此外，您可以在 &lt;code&gt;STDIN&lt;/code&gt; ， &lt;code&gt;STDOUT&lt;/code&gt; 和 &lt;code&gt;STDERR&lt;/code&gt; 文件句柄上调用方法。</target>
        </trans-unit>
        <trans-unit id="27e7e970c4cb85f5a1a451cbbaa7bb6fdbefed11" translate="yes" xml:space="preserve">
          <source>Underlying implementation for the &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; Perl function. Note that the perl-level function is vaguely deprecated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; Perl功能的基础实现。请注意，不建议使用perl级功能。</target>
        </trans-unit>
        <trans-unit id="3d53a031b5fe95ac3434bee7e57607b8155a1a48" translate="yes" xml:space="preserve">
          <source>Understand References Today</source>
          <target state="translated">了解今天的参考资料</target>
        </trans-unit>
        <trans-unit id="d2b515bbbe667df83c6f17f27b425a07b052435e" translate="yes" xml:space="preserve">
          <source>Understand that this removes the case-insensitivity feature of this module.</source>
          <target state="translated">理解这将删除该模块的大小写不敏感功能。</target>
        </trans-unit>
        <trans-unit id="5dff374e163235318e5ce8f7742ec1049ed8b995" translate="yes" xml:space="preserve">
          <source>Understanding the Magic of Tied Hashes and Arrays</source>
          <target state="translated">理解绑定哈希值和数组的神奇之处</target>
        </trans-unit>
        <trans-unit id="4fad51d89f7e0dadc266115be3afc11b52bc9806" translate="yes" xml:space="preserve">
          <source>Undertake to build a new set of Perl images using VMS commands. Since VMS does dynamic loading, it's not necessary to statically link each extension into the Perl image, so this isn't the normal build path. Consequently, it hasn't really been tested, and may well be incomplete.</source>
          <target state="translated">承担使用VMS命令构建一套新的Perl镜像。由于 VMS 是动态加载的,所以没有必要将每个扩展都静态地链接到 Perl 映像中,所以这不是正常的构建路径。因此,它还没有经过真正的测试,很可能是不完整的。</target>
        </trans-unit>
        <trans-unit id="58380a9a71bcafd994016d7b4cb1383592a7215e" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV, where fakery means &quot;more than&quot; a string: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an xpvmg; if we're a copy-on-write scalar, this is the on-write time when we do the copy, and is also used locally; if this is a vstring, drop the vstring magic. If &lt;code&gt;SV_COW_DROP_PV&lt;/code&gt; is set then a copy-on-write scalar drops its PV buffer (if any) and becomes SvPOK_off rather than making a copy. (Used where this scalar is about to be set to some other value.) In addition, the &lt;code&gt;flags&lt;/code&gt; parameter gets passed to &lt;code&gt;sv_unref_flags()&lt;/code&gt; when unreffing. &lt;code&gt;sv_force_normal&lt;/code&gt; calls this function with flags set to 0.</source>
          <target state="translated">在SV上撤消各种类型的伪造，其中伪造意味着&amp;ldquo;多于&amp;rdquo;一个字符串：如果PV是共享字符串，则进行私人复制；如果我们是裁判，请停止引用；如果我们是全球人士，则降级为xpvmg；如果我们是写时复制标量，则这是我们执行复制时的写时时间，并且也在本地使用；如果这是vstring，请放下vstring魔术。如果设置了 &lt;code&gt;SV_COW_DROP_PV&lt;/code&gt; ,则写时复制标量会丢弃其PV缓冲区（如果有）并变为SvPOK_off，而不是进行复制。 （用于将标量设置为其他值的地方。）此外，取消设置时， &lt;code&gt;flags&lt;/code&gt; 参数将传递给 &lt;code&gt;sv_unref_flags()&lt;/code&gt; 。 &lt;code&gt;sv_force_normal&lt;/code&gt; 将标志设置为0调用此函数。</target>
        </trans-unit>
        <trans-unit id="2c0043167da52b5a8f43ef5ef3ae847c1d205a64" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an xpvmg. See also &lt;code&gt;sv_force_normal_flags&lt;/code&gt; .</source>
          <target state="translated">撤消SV上的各种伪造：如果PV是共享字符串，则进行私人复制；如果我们是裁判，请停止引用；如果我们是全球人士，请降级为xpvmg。另请参见 &lt;code&gt;sv_force_normal_flags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9b219af612756cb93e821fb5ae6c25750a8208b" translate="yes" xml:space="preserve">
          <source>Undocumented functions</source>
          <target state="translated">未记录的功能</target>
        </trans-unit>
        <trans-unit id="eed18284023acb946f22279a557b952faac276d4" translate="yes" xml:space="preserve">
          <source>Unfinished Tales</source>
          <target state="translated">未完成的故事</target>
        </trans-unit>
        <trans-unit id="4df58040d6486eaa853729500be20c8509618322" translate="yes" xml:space="preserve">
          <source>Unfortunately it is not that difficult somehow manage to break one's Mac OS X Perl rather severely. If all else fails and you want to really, &lt;b&gt;REALLY&lt;/b&gt;, start from scratch and remove even your Apple Perl installation (which has become corrupted somehow), the following instructions should do it. &lt;b&gt;Please think twice before following these instructions: they are much like conducting brain surgery to yourself. Without anesthesia.&lt;/b&gt; We will &lt;b&gt;not&lt;/b&gt; come to fix your system if you do this.</source>
          <target state="translated">不幸的是，设法严重破坏Mac OS X Perl并不困难。如果一切都失败了，你要真的，&lt;b&gt;真的&lt;/b&gt;，从头开始，并清除即使您的Apple Perl安装（其中已损坏以某种方式），按以下说明应该这样做。&lt;b&gt;在遵循这些说明之前，请三思：它们非常像对自己进行脑部手术。无需麻醉。&lt;/b&gt;如果您这样做，我们将&lt;b&gt;不会&lt;/b&gt;修复您的系统。</target>
        </trans-unit>
        <trans-unit id="29de2b4590451aa9259989dd73cca2f011560c79" translate="yes" xml:space="preserve">
          <source>Unfortunately, I can't differentiate any further.</source>
          <target state="translated">可惜的是,我无法再区分了。</target>
        </trans-unit>
        <trans-unit id="6e14820d498a0bc4a9f36bbc1285250e475a8eba" translate="yes" xml:space="preserve">
          <source>Unfortunately, a note cannot be used with the single argument style of &lt;code&gt;ok()&lt;/code&gt; . That is, if you try &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt;, then &lt;code&gt;Test&lt;/code&gt; will interpret this as &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt;, and probably end up testing &lt;code&gt;&lt;i&gt;arg1&lt;/i&gt; eq &lt;i&gt;arg2&lt;/i&gt;&lt;/code&gt; -- and that's not what you want!</source>
          <target state="translated">不幸的是，注释不能与 &lt;code&gt;ok()&lt;/code&gt; 的单个参数样式一起使用。也就是说，如果您尝试 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt; ，那么 &lt;code&gt;Test&lt;/code&gt; 会将其解释为 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; ，并且最终可能会测试 &lt;code&gt;&lt;i&gt;arg1&lt;/i&gt; eq &lt;i&gt;arg2&lt;/i&gt;&lt;/code&gt; －那不是您想要的！</target>
        </trans-unit>
        <trans-unit id="7f4f5938609da571758adb22fa6ce02f230693d9" translate="yes" xml:space="preserve">
          <source>Unfortunately, interpretation of colors 0 through 7 often depends on whether the emulator supports eight colors or sixteen colors. Emulators that only support eight colors (such as the Linux console) will display colors 0 through 7 with normal brightness and ignore colors 8 through 15, treating them the same as white. Emulators that support 16 colors, such as gnome-terminal, normally display colors 0 through 7 as dim or darker versions and colors 8 through 15 as normal brightness. On such emulators, the &quot;normal&quot; white (color 7) usually is shown as pale grey, requiring bright white (15) to be used to get a real white color. Bright black usually is a dark grey color, although some terminals display it as pure black. Some sixteen-color terminal emulators also treat normal yellow (color 3) as orange or brown, and bright yellow (color 11) as yellow.</source>
          <target state="translated">不幸的是,0到7的颜色的解释通常取决于仿真器是支持8种颜色还是16种颜色。只支持8种颜色的模拟器(如Linux控制台)会以正常的亮度显示0到7号颜色,而忽略8到15号颜色,把它们当作白色对待。支持16种颜色的模拟器,如gnome-terminal,通常会将颜色0到7显示为暗色或较暗的版本,将颜色8到15显示为正常亮度。在这样的仿真器上,&quot;正常 &quot;的白色(颜色7)通常显示为淡灰色,需要使用亮白色(15)才能得到真正的白色。亮黑色通常是一种深灰色,尽管有些终端显示为纯黑色。一些十六色终端仿真器还将正常的黄色(颜色3)处理为橙色或棕色,将亮黄色(颜色11)处理为黄色。</target>
        </trans-unit>
        <trans-unit id="d3f96232328f4faede427c8ce3041998253135ab" translate="yes" xml:space="preserve">
          <source>Unfortunately, it may be that encodings are not &lt;code&gt;PerlIO&lt;/code&gt; -savvy. You can check to see whether your encoding is supported by &lt;code&gt;PerlIO&lt;/code&gt; by invoking the &lt;code&gt;perlio_ok&lt;/code&gt; method on it:</source>
          <target state="translated">不幸的是，可能是编码不 &lt;code&gt;PerlIO&lt;/code&gt; PerlIO。您可以通过在其上调用 &lt;code&gt;perlio_ok&lt;/code&gt; 方法来检查 &lt;code&gt;PerlIO&lt;/code&gt; 是否支持您的编码：</target>
        </trans-unit>
        <trans-unit id="fa870b38ba970158ffd4da6159a903c51d8f85af" translate="yes" xml:space="preserve">
          <source>Unfortunately, the original specification of UTF-8 leaves some room for interpretation of how many bytes of encoded output one should generate from one input Unicode character. Strictly speaking, the shortest possible sequence of UTF-8 bytes should be generated, because otherwise there is potential for an input buffer overflow at the receiving end of a UTF-8 connection. Perl always generates the shortest length UTF-8, and with warnings on, Perl will warn about non-shortest length UTF-8 along with other malformations, such as the surrogates, which are not Unicode code points valid for interchange.</source>
          <target state="translated">遗憾的是,UTF-8的原始规范为从一个输入的Unicode字符中产生多少字节的编码输出留下了一些解释的空间。严格地说,应该生成尽可能短的UTF-8字节序列,因为否则在UTF-8连接的接收端有可能出现输入缓冲区溢出。Perl总是生成最短长度的UTF-8,在开启警告的情况下,Perl会对非最短长度的UTF-8以及其他畸形情况发出警告,比如代用码,这些代用码不是Unicode码点有效的互换。</target>
        </trans-unit>
        <trans-unit id="1170c59a72df3e22ea0a090adf0e9824ff8c0b09" translate="yes" xml:space="preserve">
          <source>Unfortunately, there are quite a few deficiencies with the design (and often, the implementations) of locales. Unicode was invented (see &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for an introduction to that) in part to address these design deficiencies, and nowadays, there is a series of &quot;UTF-8 locales&quot;, based on Unicode. These are locales whose character set is Unicode, encoded in UTF-8. Starting in v5.20, Perl fully supports UTF-8 locales, except for sorting and string comparisons. (Use &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; for these.) Perl continues to support the old non UTF-8 locales as well. There are currently no UTF-8 locales for EBCDIC platforms.</source>
          <target state="translated">不幸的是，语言环境的设计（通常是实现）存在很多缺陷。发明Unicode是为了解决这些设计缺陷（部分介绍请参见&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;），如今，有一系列基于Unicode的&amp;ldquo; UTF-8语言环境&amp;rdquo;。这些是字符集为Unicode且以UTF-8编码的语言环境。从v5.20开始，Perl完全支持UTF-8语言环境，除了排序和字符串比较。 （为此，请使用&lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collat​​e&lt;/a&gt;。）Perl也继续支持旧的非UTF-8语言环境。 EBCDIC平台当前没有UTF-8语言环境。</target>
        </trans-unit>
        <trans-unit id="c8d518114a049f78aefe7090de8efc32eccefc83" translate="yes" xml:space="preserve">
          <source>Unfortunately, this isn't true. In perl 5.18 and earlier, AVs use &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a marker for indicating that an array element has not yet been initialized. Thus, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $av[0]&lt;/code&gt; would be true for the above Perl code, but false for the array generated by the XS code. In perl 5.20, storing &amp;amp;PL_sv_undef will create a read-only element, because the scalar &amp;amp;PL_sv_undef itself is stored, not a copy.</source>
          <target state="translated">不幸的是，事实并非如此。在perl 5.18及更早版本中，AV使用 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 作为标记来指示尚未初始化数组元素。因此， &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $av[0]&lt;/code&gt; 对于上面的Perl代码为true，但对于XS代码生成的数组为false。在perl 5.20中，存储＆PL_sv_undef将创建一个只读元素，因为标量＆PL_sv_undef本身是存储的，而不是副本。</target>
        </trans-unit>
        <trans-unit id="5a9b09da1b70d953819b14bad175ad6e8c81c049" translate="yes" xml:space="preserve">
          <source>Unfortunately, while this &lt;code&gt;style&lt;/code&gt; variable is used to set defaults for all three directory hierarchies (core, vendor, and site), there is no guarantee that the same style is actually appropriate for all those directories. For example, $prefix might be</source>
          <target state="translated">不幸的是，尽管此 &lt;code&gt;style&lt;/code&gt; 变量用于为所有三个目录层次结构（核心，供应商和站点）设置默认值，但不能保证实际上相同的样式适用于所有这些目录。例如，$ prefix可能是</target>
        </trans-unit>
        <trans-unit id="87c5d4faa14910842f5557a05819e468661f127e" translate="yes" xml:space="preserve">
          <source>Unfortunately, while this is true, it's still broken. All the references in @AoA refer to the</source>
          <target state="translated">不幸的是,虽然这是事实,但还是破绽百出。在@AoA中的所有引用都指的是</target>
        </trans-unit>
        <trans-unit id="b3033d12e8c5e48f79875dd4cf162f90c243f353" translate="yes" xml:space="preserve">
          <source>Unfortunately, you may encounter Perl modules that are not</source>
          <target state="translated">遗憾的是,你可能会遇到一些不属于</target>
        </trans-unit>
        <trans-unit id="76435dad798e21eb71def4f2d3a46ed9708e4adf" translate="yes" xml:space="preserve">
          <source>Unget a line of text from the server.</source>
          <target state="translated">从服务器上获取一行文字。</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="eb802e96fd38e5e550d19f898a4fa941c45d6b21" translate="yes" xml:space="preserve">
          <source>Unicode 7.0 changed the wording so that they are &quot;&lt;b&gt;not recommended&lt;/b&gt; for use in open interchange of Unicode text data&quot;. The 7.0 Standard goes on to say:</source>
          <target state="translated">Unicode 7.0更改了措辞，因此&amp;ldquo; &lt;b&gt;不建议&lt;/b&gt;在开放式Unicode文本数据交换中使用它们&amp;rdquo;。 7.0标准继续说：</target>
        </trans-unit>
        <trans-unit id="8306b01ff9c220d1ce9274f85cf12d457904d299" translate="yes" xml:space="preserve">
          <source>Unicode Character Properties</source>
          <target state="translated">统一码字符属性</target>
        </trans-unit>
        <trans-unit id="2a76af7c10ae9a7945dc677634ff7f287d2f0d66" translate="yes" xml:space="preserve">
          <source>Unicode Collation Algorithm</source>
          <target state="translated">统一码整理算法</target>
        </trans-unit>
        <trans-unit id="8a8a7bf1ba1b9e4c2b07e9ad90fbd26463e5d980" translate="yes" xml:space="preserve">
          <source>Unicode Consortium</source>
          <target state="translated">统一码联盟</target>
        </trans-unit>
        <trans-unit id="b56cce9c1325a6619b09abb29a03b2934dad13be" translate="yes" xml:space="preserve">
          <source>Unicode Encodings</source>
          <target state="translated">統一碼編碼</target>
        </trans-unit>
        <trans-unit id="20d826b4f354ace01634ff9215d461c1d2de2da2" translate="yes" xml:space="preserve">
          <source>Unicode FAQ</source>
          <target state="translated">统一码常见问题</target>
        </trans-unit>
        <trans-unit id="be2c3b070e201b30c780f442801bee53720d3f02" translate="yes" xml:space="preserve">
          <source>Unicode Glossary</source>
          <target state="translated">统一码词汇表</target>
        </trans-unit>
        <trans-unit id="c37be50216d5f3d38f1ea9b4becfe8758aaff3f3" translate="yes" xml:space="preserve">
          <source>Unicode I/O</source>
          <target state="translated">统一码I/O</target>
        </trans-unit>
        <trans-unit id="4f977034e8571e3a210188dcc1d8385457a8e9f6" translate="yes" xml:space="preserve">
          <source>Unicode Normalization Forms</source>
          <target state="translated">统一码规范化形式</target>
        </trans-unit>
        <trans-unit id="775e22294d31686679c1488c3a4e009b588fb93a" translate="yes" xml:space="preserve">
          <source>Unicode Normalization Forms - UAX #15</source>
          <target state="translated">统一码规范化表格-UAX #15</target>
        </trans-unit>
        <trans-unit id="41086ae1277eac703b49ed9c64da7c4e1e028776" translate="yes" xml:space="preserve">
          <source>Unicode Properties</source>
          <target state="translated">统一码属性</target>
        </trans-unit>
        <trans-unit id="ecfb52e522a545f9d54db78a273755a7cf69910d" translate="yes" xml:space="preserve">
          <source>Unicode Recommended Reading List</source>
          <target state="translated">统一码推荐阅读列表</target>
        </trans-unit>
        <trans-unit id="3dc43797a086d2e60b97e26ddbcd0e763ba2be44" translate="yes" xml:space="preserve">
          <source>Unicode Regular Expression Support Level</source>
          <target state="translated">统一码正则表达式支持级别</target>
        </trans-unit>
        <trans-unit id="47be4025952fbf3894ef86d325a9d331d9d77d10" translate="yes" xml:space="preserve">
          <source>Unicode Support</source>
          <target state="translated">支持Unicode</target>
        </trans-unit>
        <trans-unit id="3b3c1f4d1dbf76960cd965f0a9ee21a6e35c74bd" translate="yes" xml:space="preserve">
          <source>Unicode Useful Resources</source>
          <target state="translated">统一码实用资源</target>
        </trans-unit>
        <trans-unit id="0bd38e8f5dc5fab318029c6a0f6bf740c02237f9" translate="yes" xml:space="preserve">
          <source>Unicode aims to &lt;b&gt;UNI&lt;/b&gt;-fy the en-&lt;b&gt;CODE&lt;/b&gt;-ings of all the world's character sets into a single Standard. For quite a few of the various coding standards that existed when Unicode was first created, converting from each to Unicode essentially meant adding a constant to each code point in the original standard, and converting back meant just subtracting that same constant. For ASCII and ISO-8859-1, the constant is 0. For ISO-8859-5, (Cyrillic) the constant is 864; for Hebrew (ISO-8859-8), it's 1488; Thai (ISO-8859-11), 3424; and so forth. This made it easy to do the conversions, and facilitated the adoption of Unicode.</source>
          <target state="translated">Unicode的旨在&lt;b&gt;UNI&lt;/b&gt; -Fy的恩&lt;b&gt;CODE&lt;/b&gt;的世界上所有的字符集-ings成一个单一的标准。对于最初创建Unicode时存在的各种编码标准中的很多，从每种编码标准转换为Unicode本质上意味着在原始标准的每个代码点上添加一个常数，而转换回该常数则意味着减去该常数。对于ASCII和ISO-8859-1，常数为0。对于ISO-8859-5，（西里尔字母），常数为864；对于（Cyrillic）常数。希伯来语（ISO-8859-8）为1488；泰语（ISO-8859-11），3424；等等。这使得转换变得容易，并促进了Unicode的采用。</target>
        </trans-unit>
        <trans-unit id="292b5cfbcdb907b6b9b2852bab43a1e41959e1df" translate="yes" xml:space="preserve">
          <source>Unicode also defines various</source>
          <target state="translated">统一码还定义了各种</target>
        </trans-unit>
        <trans-unit id="bfb017bed191925e52b6029168924ebfe8c5d26c" translate="yes" xml:space="preserve">
          <source>Unicode and EBCDIC</source>
          <target state="translated">统一码和EBCDIC</target>
        </trans-unit>
        <trans-unit id="e27520c25eb75e7d79e8f990eeb1be4ae1df41df" translate="yes" xml:space="preserve">
          <source>Unicode and ISO/IEC 10646 are coordinated standards that unify almost all other modern character set standards, covering more than 80 writing systems and hundreds of languages, including all commercially-important modern languages. All characters in the largest Chinese, Japanese, and Korean dictionaries are also encoded. The standards will eventually cover almost all characters in more than 250 writing systems and thousands of languages. Unicode 1.0 was released in October 1991, and 6.0 in October 2010.</source>
          <target state="translated">統一碼和ISO/IEC 10646是協調的標準,統一了幾乎所有其他的現代字符集標準,涵蓋80多種文字系統和數百種語言,包括所有商業上重要的現代語言。最大的中文、日文和韩文字典中的所有字符也都被编码。该标准最终将覆盖250多种书写系统和数千种语言中的几乎所有字符。统一码1.0于1991年10月发布,6.0于2010年10月发布。</target>
        </trans-unit>
        <trans-unit id="35759c0ae04781f6ce2a8261ef308a0d62267332" translate="yes" xml:space="preserve">
          <source>Unicode and Localisation Support</source>
          <target state="translated">统一码和本地化支持</target>
        </trans-unit>
        <trans-unit id="c79347889e0d28fc8f7e3b48dc5c985da6b9c2b3" translate="yes" xml:space="preserve">
          <source>Unicode and Multilingual Support in HTML, Fonts, Web Browsers and Other Applications</source>
          <target state="translated">在HTML、字体、网络浏览器和其他应用程序中支持统一码和多语言。</target>
        </trans-unit>
        <trans-unit id="aa0a00bb85a8ade7272b8fa2d081ab3abd746b2c" translate="yes" xml:space="preserve">
          <source>Unicode and UTF</source>
          <target state="translated">Unicode和UTF</target>
        </trans-unit>
        <trans-unit id="8e9632880dc5b73eee711bbb8acae51558160af7" translate="yes" xml:space="preserve">
          <source>Unicode and UTF-8</source>
          <target state="translated">统一码和UTF-8</target>
        </trans-unit>
        <trans-unit id="814213da4f2b17caa9167081f902458536e3ac5c" translate="yes" xml:space="preserve">
          <source>Unicode casing is very different from ASCII casing.</source>
          <target state="translated">Unicode编码与ASCII编码有很大不同。</target>
        </trans-unit>
        <trans-unit id="3db087027c1f3fb2dafc91bf1aec8e28ed66555f" translate="yes" xml:space="preserve">
          <source>Unicode character database</source>
          <target state="translated">统一码字符数据库</target>
        </trans-unit>
        <trans-unit id="90ce74ac0f978040e744ea5f9ee3a9fc0fdd5b56" translate="yes" xml:space="preserve">
          <source>Unicode character properties that are NOT accepted by Perl</source>
          <target state="translated">不被Perl接受的Unicode字符属性</target>
        </trans-unit>
        <trans-unit id="131ad96e9210c062a5a91bbff68adb3c52f574b9" translate="yes" xml:space="preserve">
          <source>Unicode characters are assigned to</source>
          <target state="translated">Unicode字符被分配到</target>
        </trans-unit>
        <trans-unit id="9cd8bdcde375ab8cc6d64998c61f22e2b1db366b" translate="yes" xml:space="preserve">
          <source>Unicode characters have a Unicode name and numeric code point (ordinal) value. Use the &lt;code&gt;\N{}&lt;/code&gt; construct to specify a character by either of these values. Certain sequences of characters also have names.</source>
          <target state="translated">Unicode字符具有Unicode名称和数字代码点（常规）值。使用 &lt;code&gt;\N{}&lt;/code&gt; 构造通过这两个值之一指定字符。某些字符序列也具有名称。</target>
        </trans-unit>
        <trans-unit id="210080ef48f936087dda80492d9856fe5ec4b9bc" translate="yes" xml:space="preserve">
          <source>Unicode classes</source>
          <target state="translated">统一码类</target>
        </trans-unit>
        <trans-unit id="0f01459324a40b9e6a3a0e387cbfebfba5b6c62c" translate="yes" xml:space="preserve">
          <source>Unicode code points versus EBCDIC code points</source>
          <target state="translated">统一码码点与EBCDIC码点的比较</target>
        </trans-unit>
        <trans-unit id="7625e9ef1dd87171eb4d5354c03dd9be33744a1d" translate="yes" xml:space="preserve">
          <source>Unicode codepoint</source>
          <target state="translated">统一编码码点</target>
        </trans-unit>
        <trans-unit id="106885fd8f00b6d1d3909f50579c6a1e81f50c34" translate="yes" xml:space="preserve">
          <source>Unicode concept which most often is equal to uppercase, but for certain characters like the German &quot;sharp s&quot; there is a difference.</source>
          <target state="translated">Unicode的概念,大多数情况下等于大写,但对于某些字符,如德语的 &quot;sharp s &quot;是有区别的。</target>
        </trans-unit>
        <trans-unit id="d49075f8dbc705f2f67ea7272b64074e286787f2" translate="yes" xml:space="preserve">
          <source>Unicode defines a fourth boundary type, accessible through the &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::LineBreak&quot;&gt;Unicode::LineBreak&lt;/a&gt; module.</source>
          <target state="translated">Unicode定义了第四个边界类型，可通过&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::LineBreak&quot;&gt;Unicode :: LineBreak&lt;/a&gt;模块访问。</target>
        </trans-unit>
        <trans-unit id="07aa50c4f0010de0db76a15f32c4e153b24a7275" translate="yes" xml:space="preserve">
          <source>Unicode defines all its properties in the compound form, so all single-form properties are Perl extensions. Most of these are just synonyms for the Unicode ones, but some are genuine extensions, including several that are in the compound form. And quite a few of these are actually recommended by Unicode (in &lt;a href=&quot;http://www.unicode.org/reports/tr18&quot;&gt;http://www.unicode.org/reports/tr18&lt;/a&gt;).</source>
          <target state="translated">Unicode以复合形式定义其所有属性，因此所有单形式属性都是Perl扩展。其中大多数只是Unicode的同义词，但有些是真正的扩展，包括一些复合形式。Unicode实际上推荐了其中的很多（在&lt;a href=&quot;http://www.unicode.org/reports/tr18&quot;&gt;http://www.unicode.org/reports/tr18中&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8557c4367cf0c9f30d95a470ee521928d669fb7c" translate="yes" xml:space="preserve">
          <source>Unicode defines characters like &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; or &lt;code&gt;GREEK
SMALL LETTER ALPHA&lt;/code&gt; and unique numbers for the characters, in this case 0x0041 and 0x03B1, respectively. These unique numbers are called</source>
          <target state="translated">Unicode定义类似的字符 &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; 或 &lt;code&gt;GREEK SMALL LETTER ALPHA&lt;/code&gt; 分别和唯一号码中的字符，在这种情况下0x0041和0x03B1。这些唯一的号码称为</target>
        </trans-unit>
        <trans-unit id="66287c5bc6e75d359bae32c20cfc35103e105bf3" translate="yes" xml:space="preserve">
          <source>Unicode does define several other decimal--and numeric--characters besides the familiar 0 to 9, such as the Arabic and Indic digits. Perl does not support string-to-number conversion for digits other than ASCII &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt; (and ASCII &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt; for hexadecimal). To get safe conversions from any Unicode string, use &lt;a href=&quot;unicode/ucd#num()&quot;&gt;num() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Unicode确实定义了除了熟悉的0到9之外的其他十进制和数字字符，例如阿拉伯数字和印度数字。Perl不支持ASCII &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;9&lt;/code&gt; （十六进制的ASCII &lt;code&gt;a&lt;/code&gt; 到 &lt;code&gt;f&lt;/code&gt; ）以外的数字到字符串到数字的转换。要从任何Unicode字符串获得安全的转换，请&lt;a href=&quot;unicode/ucd#num()&quot;&gt;在Unicode :: UCD中&lt;/a&gt;使用num（）。</target>
        </trans-unit>
        <trans-unit id="e0b4309884526bd11fe1ab30cc9fc6ed43648809" translate="yes" xml:space="preserve">
          <source>Unicode form that is useful when comparing strings regardless of case, as certain characters have complex one-to-many case mappings. Primarily a variant of lowercase.</source>
          <target state="translated">Unicode形式,在比较字符串的大小写时非常有用,因为某些字符具有复杂的一对多大小写映射。主要是小写字母的变体。</target>
        </trans-unit>
        <trans-unit id="71079ed61722f43474765527d68998144c7665d4" translate="yes" xml:space="preserve">
          <source>Unicode furnishes the &lt;code&gt;Age&lt;/code&gt; property from which this is derived. The problem with Age is that a strict interpretation of it (which Perl takes) has it matching the precise release a code point's meaning is introduced in. Thus &lt;code&gt;U+0041&lt;/code&gt; would match only 1.1; and &lt;code&gt;U+1EFF&lt;/code&gt; only 5.1. This is not usually what you want.</source>
          <target state="translated">Unicode提供了 &lt;code&gt;Age&lt;/code&gt; 属性（从中派生该属性）。 Age的问题在于对它（Perl采取的一种严格的解释）使其与引入了代码点含义的精确版本相匹配。因此， &lt;code&gt;U+0041&lt;/code&gt; 仅匹配1.1；因此，A + 0041仅匹配1.1。和 &lt;code&gt;U+1EFF&lt;/code&gt; 仅5.1。这通常不是您想要的。</target>
        </trans-unit>
        <trans-unit id="fd3ab6b6f70f7431b1416e0f9107c1af48c38649" translate="yes" xml:space="preserve">
          <source>Unicode has some property-value pairs that currently don't match anything. This happens generally either because they are obsolete, or they exist for symmetry with other forms, but no language has yet been encoded that uses them. In this version of Unicode, the following match zero code points:</source>
          <target state="translated">Unicode有一些属性值对目前没有任何匹配。出现这种情况一般是因为它们已经过时了,或者它们的存在是为了与其他形式对称,但还没有任何语言使用它们的编码。在这个版本的Unicode中,以下是匹配零码点的。</target>
        </trans-unit>
        <trans-unit id="73c49c9d36b230f185c7169c7475e8856ddbd520" translate="yes" xml:space="preserve">
          <source>Unicode in Perl on EBCDIC</source>
          <target state="translated">在Perl中使用EBCDIC的Unicode</target>
        </trans-unit>
        <trans-unit id="5a2ff10d38459692f18fa8f0d5e12e0027770ead" translate="yes" xml:space="preserve">
          <source>Unicode is a character set standard which plans to codify all of the writing systems of the world, plus many other symbols.</source>
          <target state="translated">Unicode是一个字符集标准,它计划将世界上所有的书写系统,加上许多其他符号进行编码。</target>
        </trans-unit>
        <trans-unit id="3bb1c5615f2383d427b4613073ef1ec435b5138c" translate="yes" xml:space="preserve">
          <source>Unicode is a character set that can represent most characters in most of the world's languages, providing room for over one million different characters. Unicode 3.1 specifies 94,140 characters: The Basic Latin characters are assigned to the numbers 0 - 127. The Latin-1 Supplement with characters that are used in several European languages is in the next range, up to 255. After some more Latin extensions we find the character sets from languages using non-Roman alphabets, interspersed with a variety of symbol sets such as currency symbols, Zapf Dingbats or Braille. (You might want to visit &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for a look at some of them - my personal favourites are Telugu and Kannada.)</source>
          <target state="translated">Unicode是一个字符集，可以代表世界上大多数语言的大多数字符，为超过一百万个不同的字符提供了空间。 Unicode 3.1指定94,140个字符：基本拉丁字符分配给数字0-127。具有多种欧洲语言使用的字符的Latin-1补码在下一个范围内，最多为255。在发现更多拉丁扩展之后，我们发现使用非罗马字母的语言中的字符集，并点缀各种符号集，例如货币符号，Zapf Dingbats或盲文。 （您可能想访问&lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt;来查看其中的一些-我个人的最爱是泰卢固语和卡纳达语。）</target>
        </trans-unit>
        <trans-unit id="bb4b52a0e0d40f8cd4680e731fa8661db40b7bfb" translate="yes" xml:space="preserve">
          <source>Unicode is a comprehensive standard. It specifies many things outside the scope of Perl, such as how to display sequences of characters. For a full discussion of all aspects of Unicode, see &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;.</source>
          <target state="translated">Unicode是一个全面的标准。它指定了Perl范围之外的许多内容，例如如何显示字符序列。有关Unicode所有方面的完整讨论，请参见&lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="38d8bac67762b71e3e301bd389dd5bf647e3a7f7" translate="yes" xml:space="preserve">
          <source>Unicode is a new and complex technology and one may easily overlook certain security pitfalls. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; for an overview and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for details, and &lt;a href=&quot;perlunicode#Security-Implications-of-Unicode&quot;&gt;Security Implications of Unicode in perlunicode&lt;/a&gt; for security implications in particular.</source>
          <target state="translated">Unicode是一种新的复杂技术，可以轻易忽略某些安全隐患。见&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;的概述和&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;的细节，并&lt;a href=&quot;perlunicode#Security-Implications-of-Unicode&quot;&gt;在perlunicode统一的安全隐患&lt;/a&gt;特别是对于安全隐患。</target>
        </trans-unit>
        <trans-unit id="2819bd58737a8580070f8ba307d9387529fe1cef" translate="yes" xml:space="preserve">
          <source>Unicode is encoded using several competing encodings, of which UTF-8 is the most used. In a Unicode encoding, multiple subsequent bytes can be used to store a single code point, or simply: character.</source>
          <target state="translated">Unicode使用几种相互竞争的编码,其中UTF-8是使用最多的编码。在Unicode编码中,可以用多个后续字节来存储一个码点,或者干脆说:字符。</target>
        </trans-unit>
        <trans-unit id="5a66fde7942a6271294a3a5979cbe3017c3d5acd" translate="yes" xml:space="preserve">
          <source>Unicode is supported on EBCDIC platforms. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;.</source>
          <target state="translated">EBCDIC平台支持Unicode。参见&lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="989d0062ad097f9dec3fa95782856724eb6165aa" translate="yes" xml:space="preserve">
          <source>Unicode promises that the set of code points that have these two properties will never change, so something that is not quoted in v5.16 will never need to be quoted in any future Perl release. (Not all the code points that match Pattern_Syntax have actually had characters assigned to them; so there is room to grow, but they are quoted whether assigned or not. Perl, of course, would never use an unassigned code point as an actual metacharacter.)</source>
          <target state="translated">Unicode 承诺,具有这两个属性的代码点集永远不会改变,所以在 v5.16 中没有被引用的东西在未来的任何 Perl 版本中都不需要被引用。(并不是所有与 Pattern_Syntax 匹配的代码点实际上都已经被分配了字符;所以还有增长的空间,但无论是否被分配,它们都会被引用。当然,Perl永远不会将一个未分配的代码点作为一个实际的元字符使用)。)</target>
        </trans-unit>
        <trans-unit id="fb2ca4e28ea7e22cfa06c89ba6c3b93dca994a19" translate="yes" xml:space="preserve">
          <source>Unicode properties are defined (surprise!) only on Unicode code points. Starting in v5.20, when matching against &lt;code&gt;\p&lt;/code&gt; and &lt;code&gt;\P&lt;/code&gt; , Perl treats non-Unicode code points (those above the legal Unicode maximum of 0x10FFFF) as if they were typical unassigned Unicode code points.</source>
          <target state="translated">Unicode属性仅在Unicode代码点上定义（惊奇！）。从v5.20开始，当与 &lt;code&gt;\p&lt;/code&gt; 和 &lt;code&gt;\P&lt;/code&gt; 匹配时，Perl会将非Unicode代码点（高于合法Unicode最大值0x10FFFF的代码点）视为典型的未分配Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="139a9bb1fddefbaa23b5411336f2d45c5af1add3" translate="yes" xml:space="preserve">
          <source>Unicode publishes the names of blocks in two different styles, though the two are equivalent under Unicode's loose matching rules.</source>
          <target state="translated">Unicode以两种不同的风格发布区块的名称,不过在Unicode宽松的匹配规则下,两者是等价的。</target>
        </trans-unit>
        <trans-unit id="38ecc57a7a45e8fa0530ba908225186656979efa" translate="yes" xml:space="preserve">
          <source>Unicode rules are used for the case change.</source>
          <target state="translated">箱体变化采用Unicode规则。</target>
        </trans-unit>
        <trans-unit id="7088ba3066aa65d6bcc96771fbb92a42fd96dcd6" translate="yes" xml:space="preserve">
          <source>Unicode support is an extensive requirement. While Perl does not implement the Unicode standard or the accompanying technical reports from cover to cover, Perl does support many Unicode features.</source>
          <target state="translated">支持Unicode是一项广泛的要求。虽然Perl没有从头到尾实施Unicode标准或附带的技术报告,但Perl确实支持许多Unicode功能。</target>
        </trans-unit>
        <trans-unit id="b8b243e5f3e426dd36737b42e29d2ec9970a7c1a" translate="yes" xml:space="preserve">
          <source>Unicode, of course, assigns each of those code points a particular meaning (along with ones above 255). To preserve backward compatibility, Perl only uses the Unicode meanings when there is some indication that Unicode is what is intended; otherwise the non-ASCII code points remain treated as if they are unassigned.</source>
          <target state="translated">当然,Unicode 会给这些代码点分配一个特定的含义(以及 255 以上的代码点)。为了保持向后的兼容性,Perl只在有某种迹象表明Unicode是其目的时才使用Unicode的含义;否则,非ASCII码点仍被当作未分配的码点处理。</target>
        </trans-unit>
        <trans-unit id="21276899f4cb4b0159879360c7526c4fe6c28316" translate="yes" xml:space="preserve">
          <source>Unicode/Collate</source>
          <target state="translated">Unicode/Collate</target>
        </trans-unit>
        <trans-unit id="37148638183749a1c0b03d85014634d4e43c64c4" translate="yes" xml:space="preserve">
          <source>Unicode/Collate/Foo.txt</source>
          <target state="translated">Unicode/Collate/Foo.txt</target>
        </trans-unit>
        <trans-unit id="f77e952a14d870cb3ae7b18f391e8c5f3d325575" translate="yes" xml:space="preserve">
          <source>Unicode::Collate</source>
          <target state="translated">Unicode::Collate</target>
        </trans-unit>
        <trans-unit id="3ff519c896603d01c9e76e4f19191f11d112327a" translate="yes" xml:space="preserve">
          <source>Unicode::Collate - Unicode Collation Algorithm</source>
          <target state="translated">Unicode::Collate-统一码整理算法</target>
        </trans-unit>
        <trans-unit id="72b47eca97eb095d02921b6571fab1a6dfdb0bc0" translate="yes" xml:space="preserve">
          <source>Unicode::Normalize</source>
          <target state="translated">Unicode::Normalize</target>
        </trans-unit>
        <trans-unit id="2e61bd2963848230702b059b3f915c279424ceeb" translate="yes" xml:space="preserve">
          <source>Unicode::Normalize - Unicode Normalization Forms</source>
          <target state="translated">Unicode::normalize-Unicode规范化表格</target>
        </trans-unit>
        <trans-unit id="58e1ebb138145877210bc1aaddb6a695f639333f" translate="yes" xml:space="preserve">
          <source>Unicode::UCD</source>
          <target state="translated">Unicode::UCD</target>
        </trans-unit>
        <trans-unit id="878eb3fe5907f3dbbef3993a9d210c838c3bd0a6" translate="yes" xml:space="preserve">
          <source>Unicode::UCD - Unicode character database</source>
          <target state="translated">Unicode::UCD-Unicode字符数据库</target>
        </trans-unit>
        <trans-unit id="b0e10771734c32d2d9e8385457afb6c4bd746163" translate="yes" xml:space="preserve">
          <source>Unicode::UCD::UnicodeVersion</source>
          <target state="translated">Unicode::UCD::UnicodeVersion</target>
        </trans-unit>
        <trans-unit id="c884d01b9429a9f7304a835d13687b8ca5872d3c" translate="yes" xml:space="preserve">
          <source>Unified method to both set and get options in the SOL_SOCKET level. If called with one argument then getsockopt is called, otherwise setsockopt is called.</source>
          <target state="translated">在SOL_SOCKET层中设置和获取选项的统一方法,如果调用一个参数,则调用getockopt,否则调用setockopt。如果用一个参数调用,则调用getockopt,否则调用setockopt。</target>
        </trans-unit>
        <trans-unit id="238642af65f3add9fa062158d9a8954a0d8cc5fc" translate="yes" xml:space="preserve">
          <source>Unimplemented, but you can use &lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; and the &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; module to achieve similar things.</source>
          <target state="translated">未实现，但是您可以使用&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;和&lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt;模块来实现类似的功能。</target>
        </trans-unit>
        <trans-unit id="c6635fe323dcba6e8b8b2d5cdbb340361ce906ed" translate="yes" xml:space="preserve">
          <source>Universal Binary support</source>
          <target state="translated">支持通用二进制</target>
        </trans-unit>
        <trans-unit id="cecc0d8500754b34f5bd7f11dfabb25c3a770aaf" translate="yes" xml:space="preserve">
          <source>Unix</source>
          <target state="translated">Unix</target>
        </trans-unit>
        <trans-unit id="2fb49d2b5adcca8ced12a532099ac9adce5647b1" translate="yes" xml:space="preserve">
          <source>Unix Network Programming, 2nd Edition, Volume 1</source>
          <target state="translated">Unix网络编程第2版第1卷</target>
        </trans-unit>
        <trans-unit id="b4c5506923f63fcc0ec2a3603b475130b23382af" translate="yes" xml:space="preserve">
          <source>Unix Review</source>
          <target state="translated">Unix评论</target>
        </trans-unit>
        <trans-unit id="4b39a128140df62988dc25aafca006880dd71ad2" translate="yes" xml:space="preserve">
          <source>Unix has no need of special linker flags.</source>
          <target state="translated">Unix不需要特殊的链接器标志。</target>
        </trans-unit>
        <trans-unit id="faa3f11d873bf24fcae352a27226c0c2e88d087f" translate="yes" xml:space="preserve">
          <source>Unix's &lt;code&gt;#!&lt;/code&gt; technique can be simulated on other systems:</source>
          <target state="translated">Unix的 &lt;code&gt;#!&lt;/code&gt; 可以在其他系统上模拟该技术：</target>
        </trans-unit>
        <trans-unit id="7f87c004392cd89a556aff5f86328de12b9ca773" translate="yes" xml:space="preserve">
          <source>Unix-Domain TCP Clients and Servers</source>
          <target state="translated">Unix-Domain TCP客户端和服务器</target>
        </trans-unit>
        <trans-unit id="4acfa258fe45e38658aa00a5dfda8b8abeddb8cc" translate="yes" xml:space="preserve">
          <source>Unix-domain sockets on OS/2 live in a pseudo-file-system &lt;code&gt;/sockets/...&lt;/code&gt; . To avoid a failure to create a socket with a name of a different form, &lt;code&gt;&quot;/socket/&quot;&lt;/code&gt; is prepended to the socket name (unless it starts with this already).</source>
          <target state="translated">OS / 2上的Unix域套接字位于伪文件系统 &lt;code&gt;/sockets/...&lt;/code&gt; 中。为避免创建具有不同格式名称的套接字失败，请在套接字名称之前加上 &lt;code&gt;&quot;/socket/&quot;&lt;/code&gt; （除非它已经以此开头）。</target>
        </trans-unit>
        <trans-unit id="4f3c45c8b86738464ace2f8005c8fbdecfe76366" translate="yes" xml:space="preserve">
          <source>Unix.U</source>
          <target state="translated">Unix.U</target>
        </trans-unit>
        <trans-unit id="516d733c8bf9db439f1f86408315d55784a8e43c" translate="yes" xml:space="preserve">
          <source>Unknown '=xxxx' commands, unknown 'X&amp;lt;...&amp;gt;' interior-sequences, and unterminated interior sequences.</source>
          <target state="translated">未知的'= xxxx'命令，未知的'X &amp;lt;...&amp;gt;'内部序列和未终止的内部序列。</target>
        </trans-unit>
        <trans-unit id="48c5c163aa1fa71615dee0d3c90ca77bf54723d6" translate="yes" xml:space="preserve">
          <source>Unknown result token.</source>
          <target state="translated">未知的结果令牌。</target>
        </trans-unit>
        <trans-unit id="4013e411624fa8892f8200feafb69475d2458d0b" translate="yes" xml:space="preserve">
          <source>Unknowns are &lt;code&gt;&quot;-&quot;&lt;/code&gt; . Unknowns can happen unfortunately quite easily: if the platform doesn't support retrieving the information; if the binary is missing the debug information; if the optimizer has transformed the code by for example inlining.</source>
          <target state="translated">未知的是 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 。不幸的是，未知事件很容易发生：如果平台不支持检索信息；如果二进制文件缺少调试信息；如果优化程序通过内联等方式转换了代码。</target>
        </trans-unit>
        <trans-unit id="ce906b20ea9a7a0bf0bcbae85c1c9421e3de60b2" translate="yes" xml:space="preserve">
          <source>Unless %hash has already been locked the key/value could be deleted regardless of this setting.</source>
          <target state="translated">除非%hash已经被锁定,否则不管这个设置如何,钥匙/值都可以被删除。</target>
        </trans-unit>
        <trans-unit id="5c6af5673dc4ae00136df64bec88a6550bf388e5" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, the PerlIO layers of &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; are set to &quot;&lt;code&gt;:encoding(&lt;i&gt;ENCNAME&lt;/i&gt;)&lt;/code&gt;&quot;. Therefore,</source>
          <target state="translated">除非 &lt;code&gt;${^UNICODE}&lt;/code&gt; （从v5.8.2开始可用）存在并且不为零，否则将 &lt;code&gt;STDIN&lt;/code&gt; 和 &lt;code&gt;STDOUT&lt;/code&gt; 的PerlIO层设置为&amp;ldquo; &lt;code&gt;:encoding(&lt;i&gt;ENCNAME&lt;/i&gt;)&lt;/code&gt; &amp;rdquo;。因此，</target>
        </trans-unit>
        <trans-unit id="c4a238cf9ea26a0e7ddfda497c5bf0d771bd8656" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; is also compiled, the logging functions read $ENV{PERL_MEM_LOG} to determine whether to log the event, and if so how:</source>
          <target state="translated">除非还编译了 &lt;code&gt;-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; ，否则日志记录功能将读取$ ENV {PERL_MEM_LOG}以确定是否记录该事件，以及如何记录该事件：</target>
        </trans-unit>
        <trans-unit id="7183c27cf3fecde6bcc64c00a3a891d43f73c77b" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; is set to &lt;code&gt;T&lt;/code&gt; (and the kernel is after 2000/09/01), such DLLs are considered to be global. When loading a global DLL it is first looked in the table of already-loaded global DLLs. Because of this the fact that one executable loaded a DLL from &lt;code&gt;BEGINLIBPATH&lt;/code&gt; and &lt;code&gt;ENDLIBPATH&lt;/code&gt; , or</source>
          <target state="translated">除非 &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; 设置为 &lt;code&gt;T&lt;/code&gt; （并且内核在2000/09/01之后），否则此类DLL被视为全局的。加载全局DLL时，首先在已加载的全局DLL表中查找。因此，一个可执行文件从 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 和 &lt;code&gt;ENDLIBPATH&lt;/code&gt; 加载了一个DLL ，或者</target>
        </trans-unit>
        <trans-unit id="025ed2d87cd53899da043f16934d54b56cb767cf" translate="yes" xml:space="preserve">
          <source>Unless ASCII vs. EBCDIC issues are specifically being discussed, references to UTF-8 encoding in this document and elsewhere should be read as meaning UTF-EBCDIC on EBCDIC platforms. See &lt;a href=&quot;perlebcdic#Unicode-and-UTF&quot;&gt;Unicode and UTF in perlebcdic&lt;/a&gt;.</source>
          <target state="translated">除非特别讨论了ASCII与EBCDIC的问题，否则本文档和其他地方对UTF-8编码的引用应理解为EBCDIC平台上的UTF-EBCDIC。请参阅&lt;a href=&quot;perlebcdic#Unicode-and-UTF&quot;&gt;perlebcdic中的Unicode和UTF&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="763e516abf0169c17797549989072db7b3b436d9" translate="yes" xml:space="preserve">
          <source>Unless otherwise noted, functions return 0 on success, or a negative value (usually &lt;code&gt;EOF&lt;/code&gt; which is usually -1) and set &lt;code&gt;errno&lt;/code&gt; on error.</source>
          <target state="translated">除非另有说明，否则函数在成功时返回0，或者返回负值（通常 &lt;code&gt;EOF&lt;/code&gt; 通常为-1），并在错误时设置 &lt;code&gt;errno&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="843ebacc41e4317d9c7bf3f947fad475a9e1f11b" translate="yes" xml:space="preserve">
          <source>Unless otherwise notes, all examples below require this standard preamble to work correctly, with the &lt;code&gt;#!&lt;/code&gt; adjusted to work on your system:</source>
          <target state="translated">除非另有说明，否则以下所有示例均要求此标准序言才能正确使用 &lt;code&gt;#!&lt;/code&gt; 。调整以在您的系统上工作：</target>
        </trans-unit>
        <trans-unit id="519ecd12b4838877006c606ab377c9933076da06" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated all methods return either a</source>
          <target state="translated">除非另有说明,否则所有方法都返回一个</target>
        </trans-unit>
        <trans-unit id="58c869a304e00ffd24d619f7d44db8d57f44a80c" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated it works just like ExtUtils::MM_Unix</source>
          <target state="translated">除非另有说明,否则它的工作原理和ExtUtils::MM_Unix一样。</target>
        </trans-unit>
        <trans-unit id="caa9da45012bfbe0b5378d58f4fff0a9abfa58b5" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, it works just like ExtUtils::MM_Unix</source>
          <target state="translated">除非另有说明,否则它的工作原理和ExtUtils::MM_Unix一样。</target>
        </trans-unit>
        <trans-unit id="42e400a7ab19dec964d9377da14546fab4feb3ec" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;anyinflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;anyinflate&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="47a707f463b0bb3f1b25444c520600dbd6696505" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;anyuncompress&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;anyuncompress&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="d669d839575081392547a5a9cafaedbd09bec28c" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;bunzip2&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;bunzip2&lt;/code&gt; 命令， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="5cd0d3bee7135d518d8ccc595535d8b3eccde37f" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;bzip2&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;bzip2&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="2d2f8a94031befaa66720968f47bd4dde9da6fcf" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;deflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;deflate&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="f180e51799fa543d0272bd825b3d860097f806c2" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;gunzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;gunzip&lt;/code&gt; 解， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="43b54de84f56f9f511018d58087cdd33377321ec" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;gzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;gzip&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="d8c0791fbf600370c86e6ae040e4b2abd896e9ba" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;inflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;inflate&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="e65e4b1379d48c357409defc2e3a088bfcc64051" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;rawdeflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数为 &lt;code&gt;rawdeflate&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="f9aa434ca385a7cef6abc358c51e5f3189796565" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;rawinflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数为 &lt;code&gt;rawinflate&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="e2285dec1544503fb1e6e19eb0aec81e1f5a9726" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;unzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;unzip&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="f45874d912d180929ebed6cffec516fc7cf2fb97" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;zip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;zip&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="871cfac0f7d812719fa8ee355ce0991623ac4e0b" translate="yes" xml:space="preserve">
          <source>Unless specified otherwise all method can be called as class methods, or as object methods. If called as class methods then the &quot;default&quot; object will be used, and if necessary created using the current processes %Config and @INC. See the 'default' option to new() for details.</source>
          <target state="translated">除非另有规定,否则所有的方法都可以作为类方法或对象方法来调用,如果作为类方法来调用,那么将使用 &quot;默认 &quot;对象,必要时使用当前进程%Config和@INC来创建。如果作为类方法调用,那么将使用 &quot;默认 &quot;对象,如果需要的话,将使用当前进程%Config和@INC创建。详见new()的 &quot;默认 &quot;选项。</target>
        </trans-unit>
        <trans-unit id="360b129724fa7c1c8235f3513edf30406e818a7b" translate="yes" xml:space="preserve">
          <source>Unless the &lt;code&gt;/r&lt;/code&gt; option is used, the string specified with &lt;code&gt;=~&lt;/code&gt; must be a scalar variable, an array element, a hash element, or an assignment to one of those; in other words, an lvalue.</source>
          <target state="translated">除非使用 &lt;code&gt;/r&lt;/code&gt; 选项，否则用 &lt;code&gt;=~&lt;/code&gt; 指定的字符串必须是标量变量，数组元素，哈希元素或对其中之一的赋值；换句话说，一个左值。</target>
        </trans-unit>
        <trans-unit id="9ef73743f2ca77d91834c677a3b2a131dd0854b0" translate="yes" xml:space="preserve">
          <source>Unless the above additional feature is enabled, nothing about the backtrace functionality is visible, except for the Perl/XS level.</source>
          <target state="translated">除非启用上述附加功能,否则除了Perl/XS级别外,关于回溯功能的任何内容都不可见。</target>
        </trans-unit>
        <trans-unit id="c2c4cb992d99b0b97748811097f97eea4d2ce81b" translate="yes" xml:space="preserve">
          <source>Unless the operator is an assignment (&lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , etc.), repeat step (1) in respect of the second operand.</source>
          <target state="translated">除非运算符是赋值（ &lt;code&gt;+=&lt;/code&gt; ， &lt;code&gt;-=&lt;/code&gt; 等），否则请对第二个操作数重复步骤（1）。</target>
        </trans-unit>
        <trans-unit id="2c6634c0ddc3b2fcdacf253fa92fd7c8403abaf0" translate="yes" xml:space="preserve">
          <source>Unless the pattern or string are encoded in UTF-8, only ASCII characters can match positively.</source>
          <target state="translated">除非模式或字符串用UTF-8编码,否则只有ASCII字符可以正面匹配。</target>
        </trans-unit>
        <trans-unit id="93f6520e33056598a5ce68e86d15794aa942a8a6" translate="yes" xml:space="preserve">
          <source>Unless they are explicitly specified, the default values for the exit status, verbose level, and output stream to use are determined as follows:</source>
          <target state="translated">除非明确指定它们,否则要使用的退出状态、verbose级别和输出流的默认值如下。</target>
        </trans-unit>
        <trans-unit id="28631a8600ab2d0e4799cb9a021cc0306169b6f9" translate="yes" xml:space="preserve">
          <source>Unless you are accessing the CPAN on your filesystem via a file: URL, CPAN.pm needs to keep the source files it downloads somewhere. Please supply a directory where the downloaded files are to be kept.</source>
          <target state="translated">除非你是通过一个文件来访问你的文件系统中的CPAN:URL,CPAN.pm需要在某个地方保存它下载的源文件。请提供一个保存下载文件的目录。</target>
        </trans-unit>
        <trans-unit id="6b861eac07037b268358d427fce8707b48f9500e" translate="yes" xml:space="preserve">
          <source>Unless you are using the &lt;code&gt;fields&lt;/code&gt; pragma, consider this module discouraged in favor of the lighter-weight &lt;code&gt;parent&lt;/code&gt; .</source>
          <target state="translated">除非您使用 &lt;code&gt;fields&lt;/code&gt; pragma，否则建议不要使用此模块，而应使用轻量级的 &lt;code&gt;parent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84f0f4d743460958895c1346a2bcc4ae32486815" translate="yes" xml:space="preserve">
          <source>Unless you don't like the possibility of there being part of your Perl scripts embedded in a database file, this is nothing to worry about.</source>
          <target state="translated">除非你不喜欢你的Perl脚本的一部分被嵌入到数据库文件中,否则这没什么好担心的。</target>
        </trans-unit>
        <trans-unit id="078c8b3d64fda031c2ca3a111adc19b05790c7fb" translate="yes" xml:space="preserve">
          <source>Unless you have a particular reason to use the two-argument form you should use the three-argument form of open() which does not treat any characters in the filename as special.</source>
          <target state="translated">除非你有特别的理由使用两个参数形式,否则你应该使用open()的三个参数形式,它不会将文件名中的任何字符视为特殊字符。</target>
        </trans-unit>
        <trans-unit id="bcd145902080112cd3bd3565e1aa0b2eb6698439" translate="yes" xml:space="preserve">
          <source>Unless you have good reasons for using some other format (for example, a format used within your company), the convention is to name your changelog file &lt;code&gt;Changes&lt;/code&gt; , and to follow the simple format described in &lt;a href=&quot;http://search.cpan.org/perldoc/CPAN::Changes::Spec&quot;&gt;CPAN::Changes::Spec&lt;/a&gt;.</source>
          <target state="translated">除非您有充分的理由使用其他格式（例如，公司内部使用的格式），否则约定是将更改日志文件命名为 &lt;code&gt;Changes&lt;/code&gt; ，并遵循&lt;a href=&quot;http://search.cpan.org/perldoc/CPAN::Changes::Spec&quot;&gt;CPAN :: Changes :: Spec中&lt;/a&gt;描述的简单格式。</target>
        </trans-unit>
        <trans-unit id="ba7a1f205e8e2686b0c4b6d39cce725cef83741e" translate="yes" xml:space="preserve">
          <source>Unless you know better, serializing hook should always say:</source>
          <target state="translated">除非你更了解,否则序列化钩子应该总是说。</target>
        </trans-unit>
        <trans-unit id="4f5f76f31b82833340ef52081bb4d0e79eab2cc2" translate="yes" xml:space="preserve">
          <source>Unless you know with 100% certainty that quux() is only ever available for the &quot;Foonix&quot; operating system &lt;b&gt;and&lt;/b&gt; that is available &lt;b&gt;and&lt;/b&gt; correctly working for &lt;b&gt;all&lt;/b&gt; past, present, &lt;b&gt;and&lt;/b&gt; future versions of &quot;Foonix&quot;, the above is very wrong. This is more correct (though still not perfect, because the below is a compile-time check):</source>
          <target state="translated">除非您有100％的确定性知道quux（）仅可用于&amp;ldquo; Foonix&amp;rdquo;操作系统，&lt;b&gt;并且&lt;/b&gt;该版本对于&amp;ldquo; Foonix&amp;rdquo;的&lt;b&gt;所有&lt;/b&gt;过去，现在&lt;b&gt;和&lt;/b&gt;将来的版本均可用&lt;b&gt;且&lt;/b&gt;正确运行，否则上述说法是错误的。这是更正确的（尽管仍然不完美，因为以下是编​​译时检查）：&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="93ff79231a3d36c0c3d8ce3114e701a1baebbf25" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a false value, Pod::Search will recurse into subdirectories of the search directories.</source>
          <target state="translated">除非你把这个属性设置为假值,否则Pod::Search将递归到搜索目录的子目录。</target>
        </trans-unit>
        <trans-unit id="17c62f898b45d3be500e6c39bec8d493a60a2715" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a true value, Pod::Search will apply Perl-specific heuristics to find the correct module PODs quickly. This attribute's default value is false. You won't normally need to set this to true.</source>
          <target state="translated">除非你把这个属性设置为真,否则Pod::Search将应用Perl特有的启发式方法来快速找到正确的模块POD。这个属性的默认值是false。一般情况下,你不需要将此属性设置为true。</target>
        </trans-unit>
        <trans-unit id="9f9a16887abf4c916f1550cac344cc208f6c0b6b" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a true value, Pod::Simple::Search will consider only the first file of a given modulename as it looks thru the specified directories; that is, with this option off, if Pod::Simple::Search has seen a &lt;code&gt;somepathdir/Foo/Bar.pm&lt;/code&gt; already in this search, then it won't bother looking at a &lt;code&gt;somelaterpathdir/Foo/Bar.pm&lt;/code&gt; later on in that search, because that file is merely a &quot;shadow&quot;. But if you turn on &lt;code&gt;$self-&amp;gt;shadows(1)&lt;/code&gt; , then these &quot;shadow&quot; files are inspected too, and are noted in the pathname2podname return hash.</source>
          <target state="translated">除非将此属性设置为真值，否则Pod :: Simple :: Search将仅考虑给定模块名的第一个文件，因为它通过指定目录进行查找；也就是说，关闭此选项后，如果Pod :: Simple :: Search 在此搜索中已经看到了 &lt;code&gt;somepathdir/Foo/Bar.pm&lt;/code&gt; ，那么以后就不会再 &lt;code&gt;somelaterpathdir/Foo/Bar.pm&lt;/code&gt; 了。该搜索，因为该文件仅仅是&amp;ldquo;影子&amp;rdquo;。但是，如果打开 &lt;code&gt;$self-&amp;gt;shadows(1)&lt;/code&gt; ，那么也会检查这些&amp;ldquo; shadow&amp;rdquo;文件，并在pathname2podname返回哈希中将其记录下来。</target>
        </trans-unit>
        <trans-unit id="fa89971032de2d3d226811c31dc2014b63de305b" translate="yes" xml:space="preserve">
          <source>Unless you want to override the defaults, prefer META_MERGE so as to get the advantage of any future defaults.</source>
          <target state="translated">除非你想覆盖默认值,否则最好选择META_MERGE,这样才能获得未来默认值的优势。</target>
        </trans-unit>
        <trans-unit id="eb83985aa16dab9a13560a8e8f1159fe638efa8b" translate="yes" xml:space="preserve">
          <source>Unless you want to use its advanced features, this is probably all you need to know to use Exporter.</source>
          <target state="translated">除非你想使用它的高级功能,否则这可能是你使用Exporter所需要了解的全部内容。</target>
        </trans-unit>
        <trans-unit id="04c205c66e7bc90d55cfb8afb031ef118a5c83da" translate="yes" xml:space="preserve">
          <source>Unless you&amp;rsquo;ve used &lt;code&gt;/a&lt;/code&gt; or &lt;code&gt;/aa&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; matches more than ASCII digits only, but Perl&amp;rsquo;s implicit string-to-number conversion does not current recognize these. Here&amp;rsquo;s how to convert such strings manually.</source>
          <target state="translated">除非您使用 &lt;code&gt;/a&lt;/code&gt; 或 &lt;code&gt;/aa&lt;/code&gt; ，否则 &lt;code&gt;\d&lt;/code&gt; 只能匹配多个ASCII数字，但是Perl的隐式字符串到数字的转换当前无法识别这些数字。这是手动转换此类字符串的方法。</target>
        </trans-unit>
        <trans-unit id="5d5045afa1f26fa3558f3707783d1ac5db1ca1f3" translate="yes" xml:space="preserve">
          <source>Unless you're writing a new &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, a plugin or subclassing &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt;, you probably won't need to use this module directly.</source>
          <target state="translated">除非您正在编写新的&lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;，插件或&lt;a href=&quot;../parser&quot;&gt;TAP :: Parser的&lt;/a&gt;子类，否则您可能不需要直接使用此模块。</target>
        </trans-unit>
        <trans-unit id="26769d51e7e8546d072ce687409eedaf6bbd7d27" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;, this does not include the decomposition type. Use the &lt;code&gt;Decomposition_Type&lt;/code&gt; property to get that.</source>
          <target state="translated">与&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（）&lt;/a&gt;不同，它不包括分解类型。使用 &lt;code&gt;Decomposition_Type&lt;/code&gt; 属性可以实现这一点。</target>
        </trans-unit>
        <trans-unit id="0f7823a1b5c73e2c047f503abcdbc0ee1982c031" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;integer&quot;&gt;integer&lt;/a&gt;, this pragma creates integer constants that are only limited in their size by the available memory and CPU time.</source>
          <target state="translated">与&lt;a href=&quot;integer&quot;&gt;integer&lt;/a&gt;不同，此pragma创建的整数常量的大小仅受可用内存和CPU时间的限制。</target>
        </trans-unit>
        <trans-unit id="ed386882eb03009cdfed1d7cc619e0742b192d68" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function will not &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you; you need to do that explicitly yourself. See &lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt; or the</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 函数不会为您 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 一个模块。您需要自己明确地执行此操作。请参阅&lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt;或</target>
        </trans-unit>
        <trans-unit id="e6074edfe48b345d15827a75a36946caff143c7a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function will not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you; you need to do that explicitly yourself. See &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; or the</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 函数不会为您 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 一个模块。您需要自己明确地执行此操作。请参阅&lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt;或</target>
        </trans-unit>
        <trans-unit id="7f221507f852d26a177998f0fca0127e91483ffd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for...in&lt;/a&gt;&lt;/code&gt;, Perl's &lt;code&gt;for&lt;/code&gt; (also spelled &lt;code&gt;foreach&lt;/code&gt; ) does not allow the left-hand side to be an arbitrary expression. It must be a variable:</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for...in&lt;/a&gt;&lt;/code&gt; 不同，Perl的 &lt;code&gt;for&lt;/code&gt; （也拼写为 &lt;code&gt;foreach&lt;/code&gt; ）不允许左侧为任意表达式。它必须是一个变量：</target>
        </trans-unit>
        <trans-unit id="2d1c847135806754dca42b817cb04eaf19cedf87" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; does not do what you probably mean when you pass it an array as your first argument. The array is given scalar context, and instead of using the 0th element of the array as the format, Perl will use the count of elements in the array as the format, which is almost never useful.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 不同，当将数组作为第一个参数传递给 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 时，sprintf可能不执行您的意思。该数组具有标量上下文，并且Perl不会使用数组的第0个元素作为格式，而是使用数组中的元素计数作为格式，这几乎是没有用的。</target>
        </trans-unit>
        <trans-unit id="89ae4f74127125a7e7d48317841dc79dfceae6a6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; does not do what you probably mean when you pass it an array as your first argument. The array is given scalar context, and instead of using the 0th element of the array as the format, Perl will use the count of elements in the array as the format, which is almost never useful.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 不同，当将数组作为第一个参数传递给 &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 时，sprintf可能不执行您的意思。该数组具有标量上下文，并且Perl不会使用数组的第0个元素作为格式，而是使用数组中的元素计数作为格式，这几乎是没有用的。</target>
        </trans-unit>
        <trans-unit id="9885543c31cf8cf0906d34d4b26f89726d373169" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;which&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; , this function is platform independent and will also work on, for example, Win32.</source>
          <target state="translated">与 &lt;code&gt;which&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; 不同，此函数与平台无关，并且也可以在Win32等环境下使用。</target>
        </trans-unit>
        <trans-unit id="a93ac07922c6fc8a77d40224ee6574380d8e4055" translate="yes" xml:space="preserve">
          <source>Unlike Win32 build, miniperl will not have</source>
          <target state="translated">与Win32构建不同的是,miniperl将不会有</target>
        </trans-unit>
        <trans-unit id="a7c35c87e2cd92f458c69ed20a29518c1fc60ceb" translate="yes" xml:space="preserve">
          <source>Unlike constants in some languages, these cannot be overridden on the command line or via environment variables.</source>
          <target state="translated">与某些语言中的常量不同,这些常量不能在命令行或通过环境变量被覆盖。</target>
        </trans-unit>
        <trans-unit id="2e9d61b3ed80ed71e7bbbb9d575bf23b5d77fb98" translate="yes" xml:space="preserve">
          <source>Unlike dbmopen(), the tie() function will not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you--you need to do that explicitly yourself.</source>
          <target state="translated">与dbmopen（）不同，tie（）函数不会为您 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 一个模块-您需要自己明确地执行此操作。</target>
        </trans-unit>
        <trans-unit id="ae7d99bfc8b3205da369ad185c97fc4f2004cc75" translate="yes" xml:space="preserve">
          <source>Unlike dynamic variables created by the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; operator, lexical variables declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; are totally hidden from the outside world, including any called subroutines. This is true if it's the same subroutine called from itself or elsewhere--every call gets its own copy.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 运算符创建的动态变量不同，使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明的词法变量对外界完全隐藏，包括任何被调用的子例程。如果它是从其本身或在其他地方调用的相同子例程，则这是正确的-每次调用都有自己的副本。</target>
        </trans-unit>
        <trans-unit id="f1d613b9dfee0f458298b76229e47572b9ad09a4" translate="yes" xml:space="preserve">
          <source>Unlike in C and Pascal, in Perl these are all defined in terms of BLOCKs, not statements. This means that the curly brackets are</source>
          <target state="translated">与C语言和Pascal语言不同的是,在Perl中,这些都是以BLOCK的形式定义的,而不是以语句的形式定义的。这意味着,大括号是</target>
        </trans-unit>
        <trans-unit id="f21336a91710bef15208089eafb11092016626b2" translate="yes" xml:space="preserve">
          <source>Unlike in C, the scalar assignment operator produces a valid lvalue. Modifying an assignment is equivalent to doing the assignment and then modifying the variable that was assigned to. This is useful for modifying a copy of something, like this:</source>
          <target state="translated">与C语言不同的是,标量赋值运算符会产生一个有效的l值。修改赋值相当于先做赋值,然后修改被赋值的变量。这对于修改某个东西的副本很有用,就像这样。</target>
        </trans-unit>
        <trans-unit id="5f827eec6110de095ec9210c18c9cbffc634099b" translate="yes" xml:space="preserve">
          <source>Unlike in earlier versions of Perl, &lt;code&gt;:raw&lt;/code&gt; is</source>
          <target state="translated">与早期版本的Perl不同， &lt;code&gt;:raw&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="33bdaa80be75964fba31840d455d3822e7d396b4" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;&quot;&quot;&lt;/code&gt; ) can be returned. Since &lt;code&gt;catdir()&lt;/code&gt; on Mac OS always appends a trailing colon to distinguish a directory path from a file path, a single trailing colon will be ignored, i.e. there's no empty directory name after it.</source>
          <target state="translated">与仅在分隔符上拆分目录不同，可以返回空目录名称（ &lt;code&gt;&quot;&quot;&lt;/code&gt; ）。由于Mac OS上的 &lt;code&gt;catdir()&lt;/code&gt; 总是附加尾随冒号来区分目录路径和文件路径，因此单个尾随冒号将被忽略，即其后没有空目录名。</target>
        </trans-unit>
        <trans-unit id="54463777f2a5a26bb28578fbecd0a237664559d0" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt; ) can be returned, because these are significant on some OSes.</source>
          <target state="translated">与仅在分隔符上拆分目录不同，可以返回空目录名称（ &lt;code&gt;''&lt;/code&gt; ），因为这些名称在某些操作系统上很重要。</target>
        </trans-unit>
        <trans-unit id="86f74613bf49290364595249fc093a5b0e46c0b1" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt; ) can be returned, because these are significant on some OSs.</source>
          <target state="translated">与仅在分隔符上拆分目录不同，可以返回空目录名称（ &lt;code&gt;''&lt;/code&gt; ），因为这些名称在某些操作系统上很重要。</target>
        </trans-unit>
        <trans-unit id="f0601a2027041706b4a215c5ba97b0f2d038f55f" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, leading empty and trailing directory entries can be returned, because these are significant on some OSs. So,</source>
          <target state="translated">与仅仅在分隔符上分割目录不同,可以返回前导空和后导目录条目,因为这些条目在某些操作系统上很重要。所以。</target>
        </trans-unit>
        <trans-unit id="7934f43f05e561c630f325debe8a290638569198" translate="yes" xml:space="preserve">
          <source>Unlike local variables in C or C++, Perl's lexical variables don't necessarily get recycled just because their scope has exited. If something more permanent is still aware of the lexical, it will stick around. So long as something else references a lexical, that lexical won't be freed--which is as it should be. You wouldn't want memory being free until you were done using it, or kept around once you were done. Automatic garbage collection takes care of this for you.</source>
          <target state="translated">与 C 或 C++中的局部变量不同,Perl 的词法变量不一定会因为其作用域退出而被回收。如果有更永久性的东西仍然知道这个词库,它就会一直存在。只要有其他东西引用一个词法,这个词法就不会被释放--这也是应该的。你不会希望内存在你使用完之前是空闲的,或者一旦你使用完了,它就会被保留下来。自动垃圾收集会帮你解决这个问题。</target>
        </trans-unit>
        <trans-unit id="61c2bf5d9fb9c4e4b449918bf685b7cd4c575760" translate="yes" xml:space="preserve">
          <source>Unlike many other languages which support object orientation, Perl does not provide any special syntax for constructing an object. Objects are merely Perl data structures (hashes, arrays, scalars, filehandles, etc.) that have been explicitly associated with a particular class.</source>
          <target state="translated">与其他许多支持对象导向的语言不同,Perl并没有提供任何特殊的语法来构造对象。对象只是Perl的数据结构(哈希、数组、标量、文件柄等),它们已经明确地与一个特定的类相关联。</target>
        </trans-unit>
        <trans-unit id="96a17407e83fd96732a811a270065f8bf99b9560" translate="yes" xml:space="preserve">
          <source>Unlike most encodings which accept various ways to handle errors, Unicode encodings simply croaks.</source>
          <target state="translated">与大多数编码接受各种处理错误的方式不同,Unicode编码只是呱呱叫。</target>
        </trans-unit>
        <trans-unit id="49b673e0d13d9cc508ff95ef6bf45edac94a0386" translate="yes" xml:space="preserve">
          <source>Unlike most locales, which are specific to a language and country pair, Unicode classifies all the characters that are letters</source>
          <target state="translated">不像大多数地方码是针对语言和国家对的,Unicode将所有属于字母的字符进行分类。</target>
        </trans-unit>
        <trans-unit id="de28345f4c14a0c66a5513ec93329ba001d9ced5" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="c0d9558dea8e06eb18c291c6122258af13477176" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="9b35f8dffb5619dd71375e3734d385be7cc68976" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="642dec0f5e46307ce9e97ef7e93a9392f0b1f7ab" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="8e8af66683db3fc2cddaa8cdf32b4f53ebab4445" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; ，因此重做（&amp;ldquo; foo&amp;rdquo;）。&amp;ldquo; bar&amp;rdquo;将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="5bec2254ea41ddda3ef06eefb12b88f8ff1170ba" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="46f28e7c4c55184f01ee0fc59018a927acd8437c" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="fe0bcbfb6300fcbe2507c49b4631d20697de525c" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; ，因此重做（&amp;ldquo; foo&amp;rdquo;）。&amp;ldquo; bar&amp;rdquo;将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="3ee3973cea98d2564d41622c65ad1eadc9b20495" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="fd9949db65a27c0400a1254746b3e91b925c452b" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="d21a9fd801c4b5ff299a1a5bef8631136555ebd2" translate="yes" xml:space="preserve">
          <source>Unlike most operators, the smartmatch operator knows to treat &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; specially:</source>
          <target state="translated">与大多数运算符不同，smartmatch运算符知道如何特别处理 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c52ae364f54ddc8596b506c3503500a0182fc785" translate="yes" xml:space="preserve">
          <source>Unlike most other encodings, the following always croaks on error for any $chk that evaluates to true.</source>
          <target state="translated">与大多数其他编码不同的是,对于任何值为真的$chk,下面的代码总是错误的。</target>
        </trans-unit>
        <trans-unit id="a0be45e558750e70d5ad5d40843ef88fbc85d85e" translate="yes" xml:space="preserve">
          <source>Unlike non-user-defined &lt;code&gt;\p{}&lt;/code&gt; property matches, no warning is ever generated if these properties are matched against a non-Unicode code point (see &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;Beyond Unicode code points&lt;/a&gt; below).</source>
          <target state="translated">与非用户定义的 &lt;code&gt;\p{}&lt;/code&gt; 属性匹配不同，如果将这些属性与非Unicode代码点匹配，则不会生成任何警告（请参见下面的&lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;Unicode代码点之外&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="54d85676113e32968ab38ead192e565266d17ce6" translate="yes" xml:space="preserve">
          <source>Unlike other DJGPP packages, which are normal &quot;zip&quot; files, most CPAN module packages are &quot;gzipped tarballs&quot;. Recent versions of WinZip will safely unpack and expand them, *UNLESS* they have zero-length files. It is a known WinZip bug (as of v7.0) that it will not extract zero-length files.</source>
          <target state="translated">与其他DJGPP包是普通的 &quot;zip &quot;文件不同,大多数CPAN模块包是 &quot;gzipped tarballs&quot;。最新版本的WinZip可以安全地解压和扩展它们,除非它们有零长度的文件。这是一个已知的WinZip错误(从7.0版本开始),它不能解压零长度的文件。</target>
        </trans-unit>
        <trans-unit id="83864ffb2b433053a7d93f1893b27cbe33018e20" translate="yes" xml:space="preserve">
          <source>Unlike other encodings where mappings are not one-to-one against Unicode, UTFs are supposed to map 100% against one another. So Encode is more strict on UTFs.</source>
          <target state="translated">与其他编码不同,其他编码与Unicode的映射不是一对一的,UTF应该是100%的相互映射。所以Encode对UTFs的要求比较严格。</target>
        </trans-unit>
        <trans-unit id="9944da74f109a50432581cc20ef1a61578ffdb1c" translate="yes" xml:space="preserve">
          <source>Unlike other types of quote-like literals, a here document is rarely a contiguous substring. For example, a typical piece of code using here document might look like this:</source>
          <target state="translated">与其他类型的类似引号的文字不同,here文档很少是一个连续的子串。例如,一段使用 here 文档的典型代码可能是这样的。</target>
        </trans-unit>
        <trans-unit id="82bfb2284168959f095690d2be25e5ae6b5a6d2d" translate="yes" xml:space="preserve">
          <source>Unlike pragmas that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; declarations are not BLOCK-scoped. They are thus effective for the entire file in which they appear. You may not rescind such declarations with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</source>
          <target state="translated">与影响 &lt;code&gt;$^H&lt;/code&gt; 提示变量的编译指示不同， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; 声明不是BLOCK范围的。因此，它们对于显示它们的整个文件都是有效的。你可能不撤销这些声明与 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="946dc8e2b9e4dbb1e056eab35da113b4edec1e74" translate="yes" xml:space="preserve">
          <source>Unlike pragmas that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; declarations are not BLOCK-scoped. They are thus effective for the entire package in which they appear. You may not rescind such declarations with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</source>
          <target state="translated">与影响 &lt;code&gt;$^H&lt;/code&gt; 提示变量的编译指示不同， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; 声明不是BLOCK范围的。因此，它们对于其中出现的整个包装都是有效的。你可能不撤销这些声明与 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a62fc8b32926f79e07e4cd739d192b4db682422d" translate="yes" xml:space="preserve">
          <source>Unlike previous examples, we've now run h2xs on a real include file. This has caused some extra goodies to appear in both the .pm and .xs files.</source>
          <target state="translated">与之前的例子不同,我们现在已经在一个真正的include文件上运行h2xs。这使得一些额外的好东西出现在.pm和.xs文件中。</target>
        </trans-unit>
        <trans-unit id="82613342b350d8ac2d5e700389b419d73a2e8511" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;Newx&lt;/code&gt; and &lt;code&gt;Newxc&lt;/code&gt; macros, the &lt;code&gt;Newxz&lt;/code&gt; macro calls &lt;code&gt;memzero&lt;/code&gt; to zero out all the newly allocated memory.</source>
          <target state="translated">与 &lt;code&gt;Newx&lt;/code&gt; 和 &lt;code&gt;Newxc&lt;/code&gt; 宏不同， &lt;code&gt;Newxz&lt;/code&gt; 宏调用 &lt;code&gt;memzero&lt;/code&gt; 将所有新分配的内存清零。</target>
        </trans-unit>
        <trans-unit id="3459d8de61947e832dd8d6cc93a45a157f32fe5d" translate="yes" xml:space="preserve">
          <source>Unlike the GNU programs,</source>
          <target state="translated">与GNU程序不同。</target>
        </trans-unit>
        <trans-unit id="675122bbd6fe9d02ab821cef4f122f1e2fdb7554" translate="yes" xml:space="preserve">
          <source>Unlike the L</source>
          <target state="translated">不像L</target>
        </trans-unit>
        <trans-unit id="00946f20f0f39de3fde945a1c4762c9a2eb54a4d" translate="yes" xml:space="preserve">
          <source>Unlike the old Unix fmt(1) utility, this module correctly accounts for any Unicode combining characters (such as diacriticals) that may occur in each line for both expansion and unexpansion. These are overstrike characters that do not increment the logical position. Make sure you have the appropriate Unicode settings enabled.</source>
          <target state="translated">与旧的Unix fmt(1)实用程序不同,这个模块正确地计算了每行中可能出现的Unicode组合字符(如双标号)的扩展和未扩展。这些字符是不增加逻辑位置的叠加字符。确保您已经启用了适当的Unicode设置。</target>
        </trans-unit>
        <trans-unit id="0625a7948b2143bf8fa5b94abdec3d975bedca11" translate="yes" xml:space="preserve">
          <source>Unlike the old unix utilities, this module correctly accounts for any Unicode combining characters (such as diacriticals) that may occur in each line for both expansion and unexpansion. These are overstrike characters that do not increment the logical position. Make sure you have the appropriate Unicode settings enabled.</source>
          <target state="translated">与旧的unix实用程序不同,该模块正确地计算了每行中可能出现的Unicode组合字符(如双音符),包括扩展和未扩展。这些字符是不增加逻辑位置的叠加字符。确保您已经启用了适当的Unicode设置。</target>
        </trans-unit>
        <trans-unit id="bbee11f3129dceedbb755c4927925d533e72e81f" translate="yes" xml:space="preserve">
          <source>Unlike the original coding of this example, the returned values are not accessed in reverse order. So &lt;code&gt;ST(0)&lt;/code&gt; refers to the first value returned by the Perl subroutine and &lt;code&gt;ST(count-1)&lt;/code&gt; refers to the last.</source>
          <target state="translated">与本示例的原始编码不同，返回的值不是按相反的顺序访问的。因此， &lt;code&gt;ST(0)&lt;/code&gt; 指的是Perl子例程返回的第一个值， &lt;code&gt;ST(count-1)&lt;/code&gt; 指的是最后一个值。</target>
        </trans-unit>
        <trans-unit id="54921bfadbbc4d5488355e38753c36b606db5127" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="translated">与&lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;不同， &lt;code&gt;pat&lt;/code&gt; 不允许为null。</target>
        </trans-unit>
        <trans-unit id="8a7070baa0bba9b5c3411b37157873dd12da55ea" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#vcroak&quot;&gt;vcroak&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="translated">与&lt;a href=&quot;#vcroak&quot;&gt;vcroak&lt;/a&gt;不同， &lt;code&gt;pat&lt;/code&gt; 不允许为null。</target>
        </trans-unit>
        <trans-unit id="e5cefcdd918640639ca1153770063f61e285104d" translate="yes" xml:space="preserve">
          <source>Unlink any temporary files you create.</source>
          <target state="translated">解除您创建的任何临时文件的链接。</target>
        </trans-unit>
        <trans-unit id="7f2c338fa9bfcccaac25268ab0ef12e64490b19e" translate="yes" xml:space="preserve">
          <source>Unlock and close the database.</source>
          <target state="translated">解锁并关闭数据库。</target>
        </trans-unit>
        <trans-unit id="3a1b8bde43d6985240bfa75345e6d99d943394fd" translate="yes" xml:space="preserve">
          <source>Unpack the result with</source>
          <target state="translated">将结果用</target>
        </trans-unit>
        <trans-unit id="add77c91d022a17024fa5eba373c6e719da883a1" translate="yes" xml:space="preserve">
          <source>Unpack the result with &lt;code&gt;tar -xof yourmodule.tar&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;tar -xof yourmodule.tar&lt;/code&gt; 解压缩结果</target>
        </trans-unit>
        <trans-unit id="ae62392d2b4bc10cbedb53bdaea138dd0c54922e" translate="yes" xml:space="preserve">
          <source>Unpack the source package</source>
          <target state="translated">解压源码包</target>
        </trans-unit>
        <trans-unit id="3ba56861ba0d7e4bf096f38cb19b9bd9d11ad9ab" translate="yes" xml:space="preserve">
          <source>Unpacking CPAN Modules on DOS</source>
          <target state="translated">在DOS上解压CPAN模块</target>
        </trans-unit>
        <trans-unit id="a3e58138dfa89b35eb5a0a67e0ceb78fe71fb3cd" translate="yes" xml:space="preserve">
          <source>Unpacking Perl Distribution on BS2000</source>
          <target state="translated">在BS2000上解压Perl发行版</target>
        </trans-unit>
        <trans-unit id="1906a11a734d044847362b51bdd5c4ffec722822" translate="yes" xml:space="preserve">
          <source>Unpacking Perl distribution on OS/390</source>
          <target state="translated">在OS/390上解压Perl发行版</target>
        </trans-unit>
        <trans-unit id="1bfe6e7e13df7f1f795bc2c142ba9f8933ba83d0" translate="yes" xml:space="preserve">
          <source>Unpacking a Stack Frame</source>
          <target state="translated">拆开堆叠框架的包装</target>
        </trans-unit>
        <trans-unit id="13585670fad4d52485b4ecff204569086b8b8bc7" translate="yes" xml:space="preserve">
          <source>Unpacking this message can be done with the same template:</source>
          <target state="translated">解开这个消息可以用同一个模板。</target>
        </trans-unit>
        <trans-unit id="65ab97485c132c2a06d23b7d99106c078eeca52f" translate="yes" xml:space="preserve">
          <source>Unpacking using the &lt;code&gt;U&lt;/code&gt; template code also works on UTF-8 encoded byte strings.</source>
          <target state="translated">使用 &lt;code&gt;U&lt;/code&gt; 模板代码解压缩也适用于UTF-8编码的字节字符串。</target>
        </trans-unit>
        <trans-unit id="f5c52c7fb5fb7350d05f5400b468c41971c6a2ea" translate="yes" xml:space="preserve">
          <source>Unsets the IV status of an SV.</source>
          <target state="translated">解除SV的IV状态。</target>
        </trans-unit>
        <trans-unit id="4b35d98112909417a16d4e204369414a7012a63c" translate="yes" xml:space="preserve">
          <source>Unsets the NV status of an SV.</source>
          <target state="translated">解除SV的NV状态。</target>
        </trans-unit>
        <trans-unit id="8c346401fde7bad98f35f3a033aefb050144d4e1" translate="yes" xml:space="preserve">
          <source>Unsets the NV/IV status of an SV.</source>
          <target state="translated">解除SV的NV/IV状态。</target>
        </trans-unit>
        <trans-unit id="b2fe5f61df3d20003f435b822e60a53db4a67fca" translate="yes" xml:space="preserve">
          <source>Unsets the PV status of an SV.</source>
          <target state="translated">取消设置SV的PV状态。</target>
        </trans-unit>
        <trans-unit id="2b428943db3814d458253435d21b77a7039ff870" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of an SV.</source>
          <target state="translated">解除SV的RV状态。</target>
        </trans-unit>
        <trans-unit id="167340ebdf7672f2c96a0ab5594ee87b55416719" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt; . The &lt;code&gt;cflags&lt;/code&gt; argument can contain &lt;code&gt;SV_IMMEDIATE_UNREF&lt;/code&gt; to force the reference count to be decremented (otherwise the decrementing is conditional on the reference count being different from one or the reference being a readonly SV). See &lt;code&gt;SvROK_off&lt;/code&gt; .</source>
          <target state="translated">取消设置SV的RV状态，并减少RV所引用内容的引用计数。几乎可以认为这是 &lt;code&gt;newSVrv&lt;/code&gt; 的逆转。所述 &lt;code&gt;cflags&lt;/code&gt; 参数可以包含 &lt;code&gt;SV_IMMEDIATE_UNREF&lt;/code&gt; 迫使引用计数被递减（否则递减是上的引用计数从一个是不同的或参考是一个只读SV有条件的）。参见 &lt;code&gt;SvROK_off&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2213e6f5fdeb83ff58d3c894e858b5a7ff9788f0" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt; . This is &lt;code&gt;sv_unref_flags&lt;/code&gt; with the &lt;code&gt;flag&lt;/code&gt; being zero. See &lt;code&gt;SvROK_off&lt;/code&gt; .</source>
          <target state="translated">取消设置SV的RV状态，并减少RV所引用内容的引用计数。几乎可以认为这是 &lt;code&gt;newSVrv&lt;/code&gt; 的逆转。这是 &lt;code&gt;sv_unref_flags&lt;/code&gt; ， &lt;code&gt;flag&lt;/code&gt; 为零。参见 &lt;code&gt;SvROK_off&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcfacd26d54ec31883bc064dd4f33047f4f7aa58" translate="yes" xml:space="preserve">
          <source>Unsets the UTF-8 status of an SV (the data is not changed, just the flag). Do not use frivolously.</source>
          <target state="translated">取消SV的UTF-8状态(数据没有改变,只是标志)。不要随便使用。</target>
        </trans-unit>
        <trans-unit id="d458cc7af0595ce52fa475113c58f925209c55f3" translate="yes" xml:space="preserve">
          <source>Unsets the script encoding. The layers of &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; are reset to &quot;&lt;code&gt;:raw&lt;/code&gt; &quot; (the default unprocessed raw stream of bytes).</source>
          <target state="translated">取消脚本编码。 &lt;code&gt;STDIN&lt;/code&gt; ， &lt;code&gt;STDOUT&lt;/code&gt; 的层重设为&amp;ldquo; &lt;code&gt;:raw&lt;/code&gt; &amp;rdquo;（默认的未处理原始字节流）。</target>
        </trans-unit>
        <trans-unit id="f3f886677b52de9f164b2193f280f9e0b4fa4087" translate="yes" xml:space="preserve">
          <source>Unshift the given number of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; values onto the beginning of the array. The array will grow automatically to accommodate the addition. You must then use &lt;code&gt;av_store&lt;/code&gt; to assign values to these new elements.</source>
          <target state="translated">将给定数量的 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值平移到数组的开头。阵列将自动增长以适应添加。然后，您必须使用 &lt;code&gt;av_store&lt;/code&gt; 为这些新元素分配值。</target>
        </trans-unit>
        <trans-unit id="56c8806e91e8b07e1c8c5b623b330c5fc17f1e53" translate="yes" xml:space="preserve">
          <source>Unshifts an SV onto the beginning of the array, creating the array if necessary. A small internal helper function to remove a commonly duplicated idiom.</source>
          <target state="translated">将一个SV移到数组的开头,必要时创建数组。一个小的内部辅助函数,用于删除一个常见的重复成语。</target>
        </trans-unit>
        <trans-unit id="ee9dd9a34e19860a5fcf0a7ebd745fb02d06f995" translate="yes" xml:space="preserve">
          <source>Unsigned long integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned long&lt;/code&gt; . The default typemap for &lt;code&gt;unsigned long&lt;/code&gt; is T_UV.</source>
          <target state="translated">无符号长整数。这等效于T_UV，但显式将返回值强制转换为 &lt;code&gt;unsigned long&lt;/code&gt; 类型。 &lt;code&gt;unsigned long&lt;/code&gt; 的默认类型映射是T_UV。</target>
        </trans-unit>
        <trans-unit id="ef145f774c9c40a970f92057ceb7090d079d49a8" translate="yes" xml:space="preserve">
          <source>Unsigned short integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned short&lt;/code&gt; . The default typemap for &lt;code&gt;unsigned short&lt;/code&gt; is T_UV.</source>
          <target state="translated">无符号的短整数。这等效于T_UV，但显式将返回类型强制转换为 &lt;code&gt;unsigned short&lt;/code&gt; 类型。 &lt;code&gt;unsigned short&lt;/code&gt; 的默认类型映射是T_UV。</target>
        </trans-unit>
        <trans-unit id="e913109aa138d1120ee92917139364ad0e62c982" translate="yes" xml:space="preserve">
          <source>Unstable CPAN modules</source>
          <target state="translated">不稳定的CPAN模块</target>
        </trans-unit>
        <trans-unit id="36af1ae54977c39ffd1ead9641e29d3a83f91f42" translate="yes" xml:space="preserve">
          <source>Untaint an SV. Use &lt;code&gt;SvTAINTED_off&lt;/code&gt; instead.</source>
          <target state="translated">取消SV。请改用 &lt;code&gt;SvTAINTED_off&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf2cbcc095493f902db2ae40c30ea409c9c066e5" translate="yes" xml:space="preserve">
          <source>Untaints an SV. Be</source>
          <target state="translated">污染了一个SV。是</target>
        </trans-unit>
        <trans-unit id="dd1c8a6c3311799ae1ea8e9badc636ca33ce5f06" translate="yes" xml:space="preserve">
          <source>Until May 1997, this document was maintained by Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;. It is now maintained as part of Perl itself by the Perl 5 Porters &amp;lt;perl5-porters@perl.org&amp;gt;.</source>
          <target state="translated">直到1997年5月，该文档由Jeff Okamoto维护&amp;lt;okamoto@corp.hp.com&amp;gt;。现在，Perl 5 Porters &amp;lt;perl5-porters@perl.org&amp;gt;将其作为Perl本身的一部分进行维护。</target>
        </trans-unit>
        <trans-unit id="1831403e65413acb20ccb5893a29f9432e4a4a0c" translate="yes" xml:space="preserve">
          <source>Until May 1997, this document was maintained by Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;. It is now maintained as part of Perl itself.</source>
          <target state="translated">直到1997年5月，该文档由Jeff Okamoto维护&amp;lt;okamoto@corp.hp.com&amp;gt;。现在，它已作为Perl本身的一部分进行维护。</target>
        </trans-unit>
        <trans-unit id="9377bbae85c5f3f0ba947e70ca82611c37d8697f" translate="yes" xml:space="preserve">
          <source>Until Unicode 6.1, the 4 control characters U+0080, U+0081, U+0084, and U+0099 did not have names nor aliases. To preserve backwards compatibility, any alias you define for these code points will be returned by this function, in preference to the official name.</source>
          <target state="translated">在Unicode 6.1之前,4个控制字符U+0080、U+0081、U+0084和U+0099没有名称或别名。为了保持向后的兼容性,任何你为这些码点定义的别名都会被这个函数返回,而不是官方名称。</target>
        </trans-unit>
        <trans-unit id="1eb5a9bdac4b575070ceef54e56442cbab9b46a4" translate="yes" xml:space="preserve">
          <source>Until Unicode 7.0, the noncharacters were &quot;&lt;b&gt;forbidden&lt;/b&gt; for use in open interchange of Unicode text data&quot;, so that code that processed those streams could use these code points as sentinels that could be mixed in with character data, and would always be distinguishable from that data. (Emphasis above and in the next paragraph are added in this document.)</source>
          <target state="translated">在Unicode 7.0之前，&amp;ldquo;非字符&lt;b&gt;禁止&lt;/b&gt;在Unicode文本数据的开放式交换中使用&amp;rdquo;，以便处理这些流的代码可以将这些代码点用作可与字符数据混合的标记，并且始终可以与之区别开来。数据。（在本文档的上方和下一个段落中添加了重点。）</target>
        </trans-unit>
        <trans-unit id="39e4b4459c9bb0a70e21b5f9e46e887914c2d11b" translate="yes" xml:space="preserve">
          <source>Until version 1.72 of this module, the recommended technique for locking &lt;b&gt;DB_File&lt;/b&gt; databases was to flock the filehandle returned from the &quot;fd&quot; function. Unfortunately this technique has been shown to be fundamentally flawed (Kudos to David Harris for tracking this down). Use it at your own peril!</source>
          <target state="translated">在此模块的1.72版之前，推荐的用于锁定&lt;b&gt;DB_File&lt;/b&gt;数据库的技术是使从&amp;ldquo; fd&amp;rdquo;函数返回的文件句柄聚集。不幸的是，该技术已被证明具有根本的缺陷（David Harris对此表示敬意）。使用它的后果自负！</target>
        </trans-unit>
        <trans-unit id="086839a55d5b993fe1e0e2c06b1920a0c4bb718d" translate="yes" xml:space="preserve">
          <source>Until version 1.88 CPAN.pm never trusted the contents of the build_dir directory between sessions. Since 1.88_58 CPAN.pm has a YAML-based mechanism that makes it possible to share the contents of the build_dir/ directory between different sessions with the same version of perl. People who prefer to test things several days before installing will like this feature because it saves a lot of time.</source>
          <target state="translated">在1.88版本之前,CPAN.pm从来没有信任过不同会话之间的build_dir/目录的内容。从1.88_58版开始,CPAN.pm有了一个基于YAML的机制,使得在使用相同版本perl的不同会话之间可以共享build_dir/目录的内容。那些喜欢在安装前几天测试的人将会喜欢这个功能,因为它节省了很多时间。</target>
        </trans-unit>
        <trans-unit id="3e8ce03700f57426d42c01b15a7e4b29915f11c3" translate="yes" xml:space="preserve">
          <source>Unused. Left in for compatibility with Perl 5.10.0.</source>
          <target state="translated">未使用。为与Perl 5.10.0兼容而保留。</target>
        </trans-unit>
        <trans-unit id="06342bce5c18e1ce2d5790dec4f3e08db46e5f75" translate="yes" xml:space="preserve">
          <source>Unusually, the overloaded implementation of the smart match operator does not get full control of the smart match behaviour. In particular, in the following code:</source>
          <target state="translated">不寻常的是,智能匹配操作符的重载实现并没有得到智能匹配行为的完全控制。特别是,在下面的代码中。</target>
        </trans-unit>
        <trans-unit id="2e6b69fad267beac964f8da92bb1c2cb8cf51e03" translate="yes" xml:space="preserve">
          <source>Unzipping a complete zip file to disk</source>
          <target state="translated">将一个完整的压缩文件解压缩到磁盘上</target>
        </trans-unit>
        <trans-unit id="3706919ae59d2c2aad143453aa2569b724a8dcba" translate="yes" xml:space="preserve">
          <source>Up to 3.14_05, the switch &lt;b&gt;-v&lt;/b&gt; was used to produce verbose messages of &lt;b&gt;perldoc&lt;/b&gt; operation, which is now enabled by &lt;b&gt;-D&lt;/b&gt;.</source>
          <target state="translated">直到3.14_05，开关&lt;b&gt;-v&lt;/b&gt;用来产生&lt;b&gt;perldoc&lt;/b&gt;操作的详细消息，该消息现在由&lt;b&gt;-D&lt;/b&gt;启用。</target>
        </trans-unit>
        <trans-unit id="b37c83dafbe144687e4e64f7705c9303ba945d98" translate="yes" xml:space="preserve">
          <source>Up until Perl 5.18, the actual rules of what a valid identifier was were a bit fuzzy. However, in general, anything defined here should work on previous versions of Perl, while the opposite -- edge cases that work in previous versions, but aren't defined here -- probably won't work on newer versions. As an important side note, please note that the following only applies to bareword identifiers as found in Perl source code, not identifiers introduced through symbolic references, which have much fewer restrictions. If working under the effect of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; pragma, the following rules apply:</source>
          <target state="translated">直到Perl 5.18，有效标识符的实际规则还是有点模糊。但是，一般而言，此处定义的任何内容都应在Perl的早期版本上起作用，而相反的情况（在先前版本中可用但在此未定义的边缘情况）可能不适用于较新版本。作为重要的补充说明，请注意，以下内容仅适用于Perl源代码中的裸字标识符，不适用于通过符号引用引入的标识符，而符号引用的限制要少得多。如果在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; 的作用下工作；编译指示，以下规则适用：</target>
        </trans-unit>
        <trans-unit id="700db59a01b3167d63908b9389905b718c997451" translate="yes" xml:space="preserve">
          <source>Update the pad compilation state variables on entry to a new block.</source>
          <target state="translated">在进入一个新的块时更新垫子编译状态变量。</target>
        </trans-unit>
        <trans-unit id="8d41ca4ae9515e795255242cbd01a15b9d2f782f" translate="yes" xml:space="preserve">
          <source>Update the running test count during testing.</source>
          <target state="translated">在测试过程中更新运行测试次数。</target>
        </trans-unit>
        <trans-unit id="ee4df1b22166fed22f195ec39ac5348e1ad4b8f4" translate="yes" xml:space="preserve">
          <source>Updated 12 March 2001 to mention //'SYS1.TCPPARMS(TCPDATA)'.</source>
          <target state="translated">2001年3月12日更新,提到//'SYS1.TCPPARMS(TCPDATA)'。</target>
        </trans-unit>
        <trans-unit id="6a623978ea73cf3eae49fa257cd2b3aa518dc7a5" translate="yes" xml:space="preserve">
          <source>Updated 12 November 2000 for the 5.7.1 release of Perl.</source>
          <target state="translated">2000年11月12日更新为Perl的5.7.1版本。</target>
        </trans-unit>
        <trans-unit id="dd3c1a655a151c3e2de2f2bcc426466b5deb0bf5" translate="yes" xml:space="preserve">
          <source>Updated 15 January 2001 for the 5.7.1 release of Perl.</source>
          <target state="translated">2001年1月15日更新为Perl的5.7.1版本。</target>
        </trans-unit>
        <trans-unit id="5b24aab6b7b4ffb7848dd5c01694221d0200543c" translate="yes" xml:space="preserve">
          <source>Updated 24 January 2001 to mention dynamic loading.</source>
          <target state="translated">2001年1月24日更新,提到动态加载。</target>
        </trans-unit>
        <trans-unit id="555d5c68c249342b429101141b4e668ed9316de1" translate="yes" xml:space="preserve">
          <source>Updated 28 November 2001 for broken URLs.</source>
          <target state="translated">2001年11月28日更新了破损的网址。</target>
        </trans-unit>
        <trans-unit id="e62d7626efdd54a1045fbdd7ab753ad6e883c01e" translate="yes" xml:space="preserve">
          <source>Updated by Kirrily &quot;Skud&quot; Robert, &lt;code&gt;skud@cpan.org&lt;/code&gt;</source>
          <target state="translated">由Kirrily&amp;ldquo; Skud&amp;rdquo; Robert更新，skud @ &lt;code&gt;skud@cpan.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d4259d34b695e49901c9de958534f87265a7f80" translate="yes" xml:space="preserve">
          <source>Updated to be autogenerated from comments in the source by Benjamin Stuhl.</source>
          <target state="translated">更新为根据Benjamin Stuhl的评论自动生成。</target>
        </trans-unit>
        <trans-unit id="76fadb0208f83533ce563882faa439aa56b4df27" translate="yes" xml:space="preserve">
          <source>Updates for 5.8.0 by Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;</source>
          <target state="translated">Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt; 5.8.0的更新。</target>
        </trans-unit>
        <trans-unit id="1339cf8af116acbabf9923f4b5f205bd8b4522d5" translate="yes" xml:space="preserve">
          <source>Updates the current digest state by appending bits to it. The return value is the updated object itself.</source>
          <target state="translated">通过添加位来更新当前的摘要状态。返回值是更新后的对象本身。</target>
        </trans-unit>
        <trans-unit id="0f2ec1c28ed80b9544a67d730b3a5ce7a7abddfc" translate="yes" xml:space="preserve">
          <source>Updates to dual-life modules should consist of minimal patches to fix crashing bugs or security issues (as above). Any changes made to dual-life modules for which CPAN is canonical should be coordinated with the upstream author.</source>
          <target state="translated">双生模块的更新应包括最小的补丁,以修复崩溃的错误或安全问题(如上所述)。对CPAN是标准的双寿命模块的任何更改都应与上游作者协调。</target>
        </trans-unit>
        <trans-unit id="6308607dfbe53993e815ce31d09f4ea8e48145b7" translate="yes" xml:space="preserve">
          <source>Updating Apple's Perl</source>
          <target state="translated">更新苹果的Perl</target>
        </trans-unit>
        <trans-unit id="e1215f678a578a0f9348858eb8435faef2c2b2a9" translate="yes" xml:space="preserve">
          <source>Updating perldelta</source>
          <target state="translated">更新perldelta</target>
        </trans-unit>
        <trans-unit id="2c9b320c5f351db0fa6eccf0f443242caa105988" translate="yes" xml:space="preserve">
          <source>Upgrade an SV to a more complex form. Generally adds a new body type to the SV, then copies across as much information as possible from the old body. It croaks if the SV is already in a more complex form than requested. You generally want to use the &lt;code&gt;SvUPGRADE&lt;/code&gt; macro wrapper, which checks the type before calling &lt;code&gt;sv_upgrade&lt;/code&gt; , and hence does not croak. See also &lt;code&gt;svtype&lt;/code&gt; .</source>
          <target state="translated">将SV升级为更复杂的形式。通常，向SV添加新的主体类型，然后从旧主体中复制尽可能多的信息。如果SV已经比要求的形式复杂，它就会发出嘶哑的声音。通常，您需要使用 &lt;code&gt;SvUPGRADE&lt;/code&gt; 宏包装程序，该宏包装程序在调用 &lt;code&gt;sv_upgrade&lt;/code&gt; 之前检查类型，因此不会崩溃。另请参见 &lt;code&gt;svtype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf9f028e2ed4c8dda78241c1ef169c062efd613f" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. Any arguments necessary for SSL must be given in &lt;code&gt;new&lt;/code&gt; already.</source>
          <target state="translated">将现有的普通连接升级到SSL。SSL必需的所有参数都必须已经在 &lt;code&gt;new&lt;/code&gt; 中给出。</target>
        </trans-unit>
        <trans-unit id="2e297ad00204348f72b48d82b1764d98805e45e0" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. The SSL arguments have to be given in &lt;code&gt;new&lt;/code&gt; already because they are needed for data connections too.</source>
          <target state="translated">将现有的普通连接升级到SSL。SSL参数必须已经在 &lt;code&gt;new&lt;/code&gt; 中给出，因为数据连接也需要它们。</target>
        </trans-unit>
        <trans-unit id="1fee598dc67371af303baa6134f7476c80299023" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. You can use SSL arguments as documented in &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Socket::SSL&quot;&gt;IO::Socket::SSL&lt;/a&gt;, but it will usually use the right arguments already.</source>
          <target state="translated">将现有的普通连接升级到SSL。您可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/IO::Socket::SSL&quot;&gt;IO :: Socket :: SSL中&lt;/a&gt;记录的SSL参数，但是通常已经使用了正确的参数。</target>
        </trans-unit>
        <trans-unit id="bd48bfd47491f661502b2059f5ddd29245e2ae65" translate="yes" xml:space="preserve">
          <source>Upgrade the input stream to handle UTF8.</source>
          <target state="translated">升级输入流以处理UTF8。</target>
        </trans-unit>
        <trans-unit id="abc1ecb08d6b6e94555b0616aae01977c29165a2" translate="yes" xml:space="preserve">
          <source>Upon a successful match, if &lt;code&gt;pe1&lt;/code&gt; is non-NULL, it will be set to point to the beginning of the</source>
          <target state="translated">匹配成功后，如果 &lt;code&gt;pe1&lt;/code&gt; 为非NULL，它将被设置为指向</target>
        </trans-unit>
        <trans-unit id="7931625de6bea30c3520a42f1b48c8c7ccb1cf73" translate="yes" xml:space="preserve">
          <source>Upon the call, the &lt;code&gt;mg_obj&lt;/code&gt; field will hold the hash key to be accessed. Upon return, the &lt;code&gt;SV*&lt;/code&gt; value in &lt;code&gt;mg_obj&lt;/code&gt; will be used in place of the original key in the hash access. The integer index value in the first parameter will be the &lt;code&gt;action&lt;/code&gt; value from &lt;code&gt;hv_fetch_common&lt;/code&gt; , or -1 if the call is from &lt;code&gt;hv_delete_common&lt;/code&gt; .</source>
          <target state="translated">调用后， &lt;code&gt;mg_obj&lt;/code&gt; 字段将保留要访问的哈希键。返回时，将使用 &lt;code&gt;mg_obj&lt;/code&gt; 中的 &lt;code&gt;SV*&lt;/code&gt; 值代替哈希访问中的原始键。第一个参数中的整数索引值将是来自 &lt;code&gt;hv_fetch_common&lt;/code&gt; 的 &lt;code&gt;action&lt;/code&gt; 值，如果调用来自 &lt;code&gt;hv_delete_common&lt;/code&gt; 则为 -1 。</target>
        </trans-unit>
        <trans-unit id="fa70849156e04d235d49fdb3686f0245d179ad8d" translate="yes" xml:space="preserve">
          <source>Upon tying a new hash to this package, the developer must specify the size of the keys that will be used, the size of the value fields that the keys will index, and the size of the overall table (in terms of key-value pairs, not size in hard memory).</source>
          <target state="translated">在将一个新的哈希绑定到这个包后,开发者必须指定将使用的键的大小,键将索引的值字段的大小,以及整个表的大小(以键值对为单位,而不是硬内存的大小)。</target>
        </trans-unit>
        <trans-unit id="187b6d106a78abc992df989626da341b4759f5bf" translate="yes" xml:space="preserve">
          <source>Upper/lower case differences in property names and values are irrelevant; thus &lt;code&gt;\p{Upper}&lt;/code&gt; means the same thing as &lt;code&gt;\p{upper}&lt;/code&gt; or even &lt;code&gt;\p{UpPeR}&lt;/code&gt; . Similarly, you can add or subtract underscores anywhere in the middle of a word, so that these are also equivalent to &lt;code&gt;\p{U_p_p_e_r}&lt;/code&gt; . And white space is irrelevant adjacent to non-word characters, such as the braces and the equals or colon separators, so &lt;code&gt;\p{ Upper }&lt;/code&gt; and &lt;code&gt;\p{ Upper_case : Y }&lt;/code&gt; are equivalent to these as well. In fact, white space and even hyphens can usually be added or deleted anywhere. So even &lt;code&gt;\p{ Up-per case = Yes}&lt;/code&gt; is equivalent. All this is called &quot;loose-matching&quot; by Unicode. The few places where stricter matching is used is in the middle of numbers, and in the Perl extension properties that begin or end with an underscore. Stricter matching cares about white space (except adjacent to non-word characters), hyphens, and non-interior underscores.</source>
          <target state="translated">属性名称和值的大小写差异无关紧要；因此 &lt;code&gt;\p{Upper}&lt;/code&gt; 与 &lt;code&gt;\p{upper}&lt;/code&gt; 甚至 &lt;code&gt;\p{UpPeR}&lt;/code&gt; 。同样，您可以在单词中间的任意位置添加或减去下划线，以便它们也等效于 &lt;code&gt;\p{U_p_p_e_r}&lt;/code&gt; 。而且与非单词字符（例如大括号和等号或冒号分隔符）相邻的空格无关紧要，因此 &lt;code&gt;\p{ Upper }&lt;/code&gt; 和 &lt;code&gt;\p{ Upper_case : Y }&lt;/code&gt; 也等同于这些字符。实际上，通常可以在任何地方添加或删除空格甚至连字符。因此，即使 &lt;code&gt;\p{ Up-per case = Yes}&lt;/code&gt; 是等效的。所有这些都被Unicode称为&amp;ldquo;松散匹配&amp;rdquo;。使用更严格匹配的几个地方是数字的中间，以及以下划线开头或结尾的Perl扩展属性。更严格的匹配会关注空格（除了与非单词字符相邻的空格），连字符和非内部下划线。</target>
        </trans-unit>
        <trans-unit id="46cec56f3412b99de640a0bca5cebcfbc4f533b0" translate="yes" xml:space="preserve">
          <source>Urgh. No wonder. There's a big difference between &quot;a null byte&quot;, character zero, and &quot;a space&quot;, character 32. Perl's put something between the date and the description - but unfortunately, we can't see it!</source>
          <target state="translated">呃...难怪。&quot;一个空字节&quot;(字符0)和 &quot;一个空格&quot;(字符32)之间有很大的区别。Perl在日期和描述之间放了一些东西--但不幸的是,我们看不到它!</target>
        </trans-unit>
        <trans-unit id="da969c82ff05cdc8d49e5dc3d47bc17f0b801a39" translate="yes" xml:space="preserve">
          <source>Urgh. Well, it's a bit better, but - well, would you want to maintain that?</source>
          <target state="translated">呃...好吧,这是一个有点好,但-好吧,你想保持这一点?</target>
        </trans-unit>
        <trans-unit id="82706ecdf8b404a3d7af76c38e97c34669646ccc" translate="yes" xml:space="preserve">
          <source>Usage Hints for Perl on OS/390</source>
          <target state="translated">OS/390上Perl的使用提示</target>
        </trans-unit>
        <trans-unit id="96115201cdc9d452c0fc7c1a0ccadddf5148529a" translate="yes" xml:space="preserve">
          <source>Usage Hints for Perl on Windows</source>
          <target state="translated">Perl在Windows上的使用提示</target>
        </trans-unit>
        <trans-unit id="73e902d9c6da4a824d1ebe10f64b85e576698ee7" translate="yes" xml:space="preserve">
          <source>Usage is</source>
          <target state="translated">用途是</target>
        </trans-unit>
        <trans-unit id="b4adcf0ec968acb4f04ec349a0b19258b19ca830" translate="yes" xml:space="preserve">
          <source>Usage messages issued as a result of bad command-line syntax should go to &lt;code&gt;STDERR&lt;/code&gt; . However, usage messages issued due to an explicit request to print usage (like specifying &lt;b&gt;-help&lt;/b&gt; on the command line) should go to &lt;code&gt;STDOUT&lt;/code&gt; , just in case the user wants to pipe the output to a pager (such as &lt;b&gt;more(1)&lt;/b&gt;).</source>
          <target state="translated">由于命令行语法错误而发出的用法消息应发送到 &lt;code&gt;STDERR&lt;/code&gt; 。但是，由于显式请求打印用法而发出的用法消息（例如，在命令行上指定&lt;b&gt;-help&lt;/b&gt;）应发送到 &lt;code&gt;STDOUT&lt;/code&gt; ，以防万一用户希望将输出通过管道发送到寻呼机（例如&lt;b&gt;more（1）&lt;/b&gt;）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
