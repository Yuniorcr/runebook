<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="bed16d4ef44043e0ee787c3f181832f24be03ea6" translate="yes" xml:space="preserve">
          <source>When you speak one language and the computer thinks you&amp;rsquo;re speaking another. You&amp;rsquo;ll see odd translations when you send UTF‑8, for instance, but the computer thinks you sent Latin-1, showing all sorts of weird characters instead. The term is written 「文字化け」in Japanese and means &amp;ldquo;character rot&amp;rdquo;, an apt description. Pronounced [&lt;code&gt;modʑibake&lt;/code&gt; ] in standard &lt;b&gt;IPA&lt;/b&gt; phonetics, or approximately &amp;ldquo;moh-jee-bah-keh&amp;rdquo;.</source>
          <target state="translated">当您说一种语言而计算机认为您在说另一种语言时。例如，当您发送UTF-8时，您会看到奇怪的翻译，但是计算机认为您发送了Latin-1，而是显示了各种奇怪的字符。该术语用日语写成&amp;ldquo;文字化け&amp;rdquo;，意思是&amp;ldquo;字符腐烂&amp;rdquo;，是一种恰当的描述。在标准&lt;b&gt;IPA&lt;/b&gt;语音中发音为[ &lt;code&gt;modʑibake&lt;/code&gt; ] ，或近似为&amp;ldquo; moh-jee-bah-keh&amp;rdquo;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7ef09f89e47adf28a99fbbb7052a436221dbcca0" translate="yes" xml:space="preserve">
          <source>When you speak one language and the computer thinks you&amp;rsquo;re speaking another. You&amp;rsquo;ll see odd translations when you send UTF‑8, for instance, but the computer thinks you sent Latin-1, showing all sorts of weird characters instead. The term is written 「文字化け」in Japanese and means &amp;ldquo;character rot&amp;rdquo;, an apt description. Pronounced [&lt;code&gt;modʑibake&lt;/code&gt;] in standard &lt;b&gt;IPA&lt;/b&gt; phonetics, or approximately &amp;ldquo;moh-jee-bah-keh&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="665a5769943788c4623d27cfed3bae7f7e133317" translate="yes" xml:space="preserve">
          <source>When you specify arguments to routines in the .xs file, you are really passing three pieces of information for each argument listed. The first piece is the order of that argument relative to the others (first, second, etc). The second is the type of argument, and consists of the type declaration of the argument (e.g., int, char*, etc). The third piece is the calling convention for the argument in the call to the library function.</source>
          <target state="translated">当你在.xs文件中为例程指定参数时,你实际上是为列出的每个参数传递了三条信息。第一条是该参数相对于其他参数的顺序(第一、第二等)。第二条是参数的类型,由参数的类型声明组成(例如,int、char*等)。第三块是该参数在调用库函数时的调用约定。</target>
        </trans-unit>
        <trans-unit id="92bc744ea7824ccea4eeb23e82728fbc4ddab899" translate="yes" xml:space="preserve">
          <source>When you supply a separate display name it becomes possible to run a test more than once; the display name is effectively the alias by which the test is known inside the harness. The harness doesn't care if it runs the same test more than once when each invocation uses a different name.</source>
          <target state="translated">当你提供一个单独的显示名称时,就可以多次运行一个测试;显示名称实际上是测试在线束中的别名。当每次调用使用不同的名称时,线束不会在意是否会多次运行同一个测试。</target>
        </trans-unit>
        <trans-unit id="f5d8e81bcb99e99cbe008b301dbaa4156e030e10" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; to lock the file, &lt;code&gt;Tie::File&lt;/code&gt; assumes that the read cache is no longer trustworthy, because another process might have modified the file since the last time it was read. Therefore, a successful call to &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; discards the contents of the read cache and the internal record offset table.</source>
          <target state="translated">当您使用 &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 锁定文件时， &lt;code&gt;Tie::File&lt;/code&gt; 假定读取缓存不再受信任，因为自上次读取文件以来，另一个进程可能已经修改了该文件。因此，对 &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 的成功调用将丢弃读取缓存和内部记录偏移表的内容。</target>
        </trans-unit>
        <trans-unit id="86d314b9ffee5484e299c428ac086a5864115f83" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;flock&lt;/code&gt; to lock the file, &lt;code&gt;Tie::File&lt;/code&gt; assumes that the read cache is no longer trustworthy, because another process might have modified the file since the last time it was read. Therefore, a successful call to &lt;code&gt;flock&lt;/code&gt; discards the contents of the read cache and the internal record offset table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1ea55b20ff67d97a482097e7d303cd94b1b34c" translate="yes" xml:space="preserve">
          <source>When you use Perl from C, your C program will--usually--allocate, &quot;run&quot;, and deallocate a</source>
          <target state="translated">当你从C语言中使用Perl时,你的C语言程序通常会分配、&quot;运行 &quot;和重新分配一个</target>
        </trans-unit>
        <trans-unit id="5b4b7e46fe751c099868927c5d1568ad4f11af65" translate="yes" xml:space="preserve">
          <source>When you use the &lt;b&gt;-n&lt;/b&gt; and &lt;b&gt;-p&lt;/b&gt; switches to Perl, &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; work just as they do in &lt;b&gt;awk&lt;/b&gt;, as a degenerate case. Both &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; blocks are run when you use the &lt;b&gt;-c&lt;/b&gt; switch for a compile-only syntax check, although your main code is not.</source>
          <target state="translated">当您使用&lt;b&gt;-n&lt;/b&gt;和&lt;b&gt;-p&lt;/b&gt;切换到Perl时， &lt;code&gt;BEGIN&lt;/code&gt; 和 &lt;code&gt;END&lt;/code&gt; 就像在&lt;b&gt;awk&lt;/b&gt;中一样工作，这是简并的情况。无论 &lt;code&gt;BEGIN&lt;/code&gt; 和 &lt;code&gt;CHECK&lt;/code&gt; 当您使用块运行&lt;b&gt;-c&lt;/b&gt;开关仅编译语法检查，虽然你的主要代码是没有。</target>
        </trans-unit>
        <trans-unit id="6e7c5168dc3e4d09a86a5c07db61ae55b067c306" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or Perl's &lt;b&gt;-w&lt;/b&gt; command-line option, you may see warnings about useless uses of constants or functions in &quot;void context&quot;. Void context just means the value has been discarded, such as a statement containing only &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt;. It still counts as scalar context for functions that care whether or not they're being called in list context.</source>
          <target state="translated">当您使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 编译指示或Perl的&lt;b&gt;-w&lt;/b&gt;命令行选项时，您可能会看到有关在&amp;ldquo;无效上下文&amp;rdquo;中无用的常量或函数使用的警告。无效上下文仅表示该值已被丢弃，例如仅包含 &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; 的语句；或 &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt; 。对于关心是否在列表上下文中调用它们的函数，它仍视为标量上下文。</target>
        </trans-unit>
        <trans-unit id="21a0f043d5bac1b816d417902a549ec51099c064" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;use warnings&lt;/code&gt; pragma or Perl's &lt;b&gt;-w&lt;/b&gt; command-line option, you may see warnings about useless uses of constants or functions in &quot;void context&quot;. Void context just means the value has been discarded, such as a statement containing only &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; or &lt;code&gt;getpwuid(0);&lt;/code&gt;. It still counts as scalar context for functions that care whether or not they're being called in list context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f561cbf428cfa38a570f079c8fe3f1e6c4934924" translate="yes" xml:space="preserve">
          <source>When you want to encode Unicode for mails and web pages, however, do not use UTF-7 unless you are sure your recipients and readers can handle it. Very few MUAs and WWW Browsers support these days (only Mozilla seems to support one). For general cases, use UTF-8 for message body and MIME-Header for header instead.</source>
          <target state="translated">然而,当你想对邮件和网页进行Unicode编码时,不要使用UTF-7,除非你确信你的收件人和读者可以处理它。现在很少有MUA和WWW浏览器支持(似乎只有Mozilla支持)。在一般情况下,使用UTF-8作为邮件主体,MIME-Header作为邮件头。</target>
        </trans-unit>
        <trans-unit id="d1594b9a6f30c884e42aa7810e12c05455ffa364" translate="yes" xml:space="preserve">
          <source>When you want to write to a file, you first have to decide what to do about any existing contents of that file. You have two basic choices here: to preserve or to clobber.</source>
          <target state="translated">当你想写到一个文件时,你首先要决定如何处理该文件的任何现有内容。在这里,你有两个基本选择:保存或删除。</target>
        </trans-unit>
        <trans-unit id="f729e16e6d70d308845c4e263f4f5d66444de2cc" translate="yes" xml:space="preserve">
          <source>When you're done with your filehandles, you should &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; them (though to be honest, Perl will clean up after you if you forget):</source>
          <target state="translated">完成文件句柄后，应将它们 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; （尽管老实说，如果您忘记了，Perl将在您清理之后）：</target>
        </trans-unit>
        <trans-unit id="1488b5ce874430f2891cff85427abec3fe4ed92a" translate="yes" xml:space="preserve">
          <source>When you're done with your filehandles, you should &lt;code&gt;close()&lt;/code&gt; them (though to be honest, Perl will clean up after you if you forget):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f855bc56e9b2d1a2f4296535cb927b2c13c9dd7d" translate="yes" xml:space="preserve">
          <source>When you're using RETVAL to return an &lt;code&gt;SV *&lt;/code&gt; , there's some magic going on behind the scenes that should be mentioned. When you're manipulating the argument stack using the ST(x) macro, for example, you usually have to pay special attention to reference counts. (For more about reference counts, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.) To make your life easier, the typemap file automatically makes &lt;code&gt;RETVAL&lt;/code&gt; mortal when you're returning an &lt;code&gt;SV *&lt;/code&gt; . Thus, the following two XSUBs are more or less equivalent:</source>
          <target state="translated">当您使用RETVAL返回 &lt;code&gt;SV *&lt;/code&gt; 时，幕后发生了一些不可思议的事情。例如，当您使用ST（x）宏操作参数堆栈时，通常必须特别注意引用计数。（有关参考计数的更多信息，请参见&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;。）为了使您的生活更轻松，当返回 &lt;code&gt;SV *&lt;/code&gt; 时，typemap文件会自动使 &lt;code&gt;RETVAL&lt;/code&gt; 成为凡人。因此，以下两个XSUB或多或少是等效的：</target>
        </trans-unit>
        <trans-unit id="aff47fe5db562b3d2dbc867dc1c147d97de9621a" translate="yes" xml:space="preserve">
          <source>When you're using RETVAL to return an &lt;code&gt;SV *&lt;/code&gt;, there's some magic going on behind the scenes that should be mentioned. When you're manipulating the argument stack using the ST(x) macro, for example, you usually have to pay special attention to reference counts. (For more about reference counts, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.) To make your life easier, the typemap file automatically makes &lt;code&gt;RETVAL&lt;/code&gt; mortal when you're returning an &lt;code&gt;SV *&lt;/code&gt;. Thus, the following two XSUBs are more or less equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5829efde6fb988f406fa62c8ae4c250e14e41e30" translate="yes" xml:space="preserve">
          <source>When you've found that there isn't a module available for what you're trying to do, and you've had to write the code yourself, consider packaging up the solution into a module and uploading it to CPAN so that others can benefit.</source>
          <target state="translated">当你发现你要做的事情没有可用的模块,而你又不得不自己写代码的时候,可以考虑把解决方案打包成一个模块,然后上传到CPAN上,这样其他人就可以受益了。</target>
        </trans-unit>
        <trans-unit id="6b113771452e06c12bd2750d8700f91d2cc72def" translate="yes" xml:space="preserve">
          <source>When you've got your name sorted out and you're sure that your module is wanted and not currently available, it's time to start coding.</source>
          <target state="translated">当你整理好你的名字,确定你的模块是想要的,而且目前还没有,就可以开始编码了。</target>
        </trans-unit>
        <trans-unit id="baa149e5f728be9fcf5c842fafa04ad779a77d18" translate="yes" xml:space="preserve">
          <source>When your child is done running tests, you must call &lt;code&gt;finalize&lt;/code&gt; to clean up and tell the parent your pass/fail status.</source>
          <target state="translated">当您的孩子完成测试后，您必须致电 &lt;code&gt;finalize&lt;/code&gt; 进行清理，并告诉父母您的通过/失败状态。</target>
        </trans-unit>
        <trans-unit id="701f121f0767fb048f9a1e9cdd7bcb29143a3d18" translate="yes" xml:space="preserve">
          <source>When your module encounters an error it should do one or more of:</source>
          <target state="translated">当你的模块遇到一个错误时,它应该做一个或多个。</target>
        </trans-unit>
        <trans-unit id="7d300f1dcd786450162ec26ef8c71857af330be4" translate="yes" xml:space="preserve">
          <source>When, &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; is enabled, this setting controls whether the permissions on files from the archive are used without modification of if they are filtered by removing any setid bits and applying the current umask.</source>
          <target state="translated">当， &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; 启用，使用是否从存档文件的权限此设置不控制，如果他们删除任何SETID位和运用当前的umask过滤的修改。</target>
        </trans-unit>
        <trans-unit id="c7c9dae84175d878d430d8cca64e61d718171eab" translate="yes" xml:space="preserve">
          <source>When, however, you assign a list of scalars to another list of scalars, the results differ according to whether the left-hand list -- the list being assigned to -- has the same, more or fewer elements than the right-hand list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d830d827614f19bd45afae435d976e89279e08bd" translate="yes" xml:space="preserve">
          <source>Whenever JSON allows whitespace, C++-style one-line comments are additionally allowed. They are terminated by the first carriage-return or line-feed character, after which more white-space and comments are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042aae650b0c414ca1cd41812840fd2d72dec204" translate="yes" xml:space="preserve">
          <source>Whenever JSON allows whitespace, C-style multiple-line comments are additionally allowed. Everything between &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt; is a comment, after which more white-space and comments are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a2ef40caf9ba8f64a09af2f45cf33737585968" translate="yes" xml:space="preserve">
          <source>Whenever JSON allows whitespace, shell-style comments are additionally allowed. They are terminated by the first carriage-return or line-feed character, after which more white-space and comments are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cabccb147592c137e487eb001cea479dffb70830" translate="yes" xml:space="preserve">
          <source>Whenever a Berkeley DB function returns data via one of its parameters, the equivalent &lt;b&gt;DB_File&lt;/b&gt; method does exactly the same.</source>
          <target state="translated">每当Berkeley DB函数通过其参数之一返回数据时，等效的&lt;b&gt;DB_File&lt;/b&gt;方法就会执行完全相同的操作。</target>
        </trans-unit>
        <trans-unit id="6a800aba7242513688fb7365bc61881077cd8882" translate="yes" xml:space="preserve">
          <source>Whenever a Perl subroutine is called using one of the</source>
          <target state="translated">每当一个Perl子程序被调用时,使用其中一个</target>
        </trans-unit>
        <trans-unit id="6344d70f52ab5669e0f868bcc4766007019f0e1c" translate="yes" xml:space="preserve">
          <source>Whenever a reference is used as a field hash key, the object registry is checked and a new entry is made if necessary. The field hash is then added to the list of fields this reference has used.</source>
          <target state="translated">每当一个引用被用作字段哈希键时,都会检查对象登记册,必要时还会新建一个条目。然后,该字段哈希将被添加到该参考资料使用过的字段列表中。</target>
        </trans-unit>
        <trans-unit id="ac59cb12b90f854e158e9f7e8d962f434ede4764" translate="yes" xml:space="preserve">
          <source>Whenever control returns from the</source>
          <target state="translated">每当控制权从</target>
        </trans-unit>
        <trans-unit id="56847d63f6da95857482dd3497381b06019beb12" translate="yes" xml:space="preserve">
          <source>Whenever metadata consumers merge prerequisites, either from different phases or from &lt;code&gt;optional_features&lt;/code&gt;, they should merged in a way which preserves the intended semantics of the prerequisite structure. Generally, this means concatenating the version specifications using commas, as described in the &lt;a href=&quot;#Version-Ranges&quot;&gt;&quot;Version Ranges&quot;&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a47aafac8fca0c788807bc11f865583b9a79dd" translate="yes" xml:space="preserve">
          <source>Whenever possible, new features should be prototyped in a CPAN module before they will be considered for the core.</source>
          <target state="translated">在可能的情况下,新功能应该在CPAN模块中进行原型设计,然后再考虑将其纳入核心。</target>
        </trans-unit>
        <trans-unit id="a368a6c064c79ec6ec1d84f92fa7a58354e83dad" translate="yes" xml:space="preserve">
          <source>Whenever this is applied to a string which doesn't quite meet the pattern's expectations such as &lt;code&gt;&quot;abc  &quot;&lt;/code&gt; or &lt;code&gt;&quot;abc  def &quot;&lt;/code&gt; , the regex engine will backtrack, approximately once for each character in the string. But we know that there is no way around taking</source>
          <target state="translated">每当将其应用于不完全满足模式要求的字符串（例如 &lt;code&gt;&quot;abc &quot;&lt;/code&gt; 或 &lt;code&gt;&quot;abc def &quot;&lt;/code&gt; ，正则表达式引擎都会回退，对于字符串中的每个字符大约回溯一次。但是我们知道没有办法</target>
        </trans-unit>
        <trans-unit id="ff79b096fb177b1f29c2b3cfee678fdb53ec5582" translate="yes" xml:space="preserve">
          <source>Whenever this is applied to a string which doesn't quite meet the pattern's expectations such as &lt;code&gt;&quot;abc &quot;&lt;/code&gt; or &lt;code&gt;&quot;abc def &quot;&lt;/code&gt;, the regexp engine will backtrack, approximately once for each character in the string. But we know that there is no way around taking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d972aca2274b3be6437814e7f18c3f8fdf56c12" translate="yes" xml:space="preserve">
          <source>Whenever you do I/O on a file in Perl, you do so through what in Perl is called a &lt;b&gt;filehandle&lt;/b&gt;. A filehandle is an internal name for an external file. It is the job of the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; function to make the association between the internal name and the external name, and it is the job of the &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; function to break that association.</source>
          <target state="translated">每当您在Perl中对文件进行I / O时，都需要通过Perl中称为&lt;b&gt;filehandle的方式来进行&lt;/b&gt;。文件句柄是外部文件的内部名称。在内部名称和外部名称之间建立关联是 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 函数的工作，而打破该关联是 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 函数的工作。</target>
        </trans-unit>
        <trans-unit id="2609a2feff469b602ec869a4ded1b4330334544b" translate="yes" xml:space="preserve">
          <source>Whenever you do I/O on a file in Perl, you do so through what in Perl is called a &lt;b&gt;filehandle&lt;/b&gt;. A filehandle is an internal name for an external file. It is the job of the &lt;code&gt;open&lt;/code&gt; function to make the association between the internal name and the external name, and it is the job of the &lt;code&gt;close&lt;/code&gt; function to break that association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed7093ca3cc4a3c897e96991516ce1f4f0fcfd4e" translate="yes" xml:space="preserve">
          <source>Whenever you have more than one subprocess, you must be careful that each closes whichever half of any pipes created for interprocess communication it is not using. This is because any child process reading from the pipe and expecting an EOF will never receive it, and therefore never exit. A single process closing a pipe is not enough to close it; the last process with the pipe open must close it for it to read EOF.</source>
          <target state="translated">当你有多个子进程时,你必须注意每个子进程都要关闭为进程间通信而创建的任何一半管道。这是因为任何从管道中读取并期望得到 EOF 的子进程将永远不会收到 EOF,因此永远不会退出。单个进程关闭管道还不足以关闭它;最后一个打开管道的进程必须关闭管道才能读取EOF。</target>
        </trans-unit>
        <trans-unit id="cd1ee0eb738b950d883ab6c08ca29be20ef06df7" translate="yes" xml:space="preserve">
          <source>Whenever you're communicating text with anything that is external to your perl process, like a database, a text file, a socket, or another program. Even if the thing you're communicating with is also written in Perl.</source>
          <target state="translated">每当你和你的 perl 进程外部的任何东西进行文本交流时,比如数据库、文本文件、套接字或其他程序。即使你要与之通信的东西也是用Perl写的。</target>
        </trans-unit>
        <trans-unit id="cc31f890f5831db8c47f9104a5fd72a40a9b958c" translate="yes" xml:space="preserve">
          <source>Whenever your encoded, binary string is used together with a text string, Perl will assume that your binary string was encoded with ISO-8859-1, also known as latin-1. If it wasn't latin-1, then your data is unpleasantly converted. For example, if it was UTF-8, the individual bytes of multibyte characters are seen as separate characters, and then again converted to UTF-8. Such double encoding can be compared to double HTML encoding (&lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ), or double URI encoding (&lt;code&gt;%253E&lt;/code&gt; ).</source>
          <target state="translated">每当将编码的二进制字符串与文本字符串一起使用时，Perl都会假定您的二进制字符串是使用ISO-8859-1（也称为latin-1）编码的。如果不是latin-1，那么您的数据将被令人讨厌地转换。例如，如果它是UTF-8，则将多字节字符的各个字节视为单独的字符，然后再次转换为UTF-8。可以将这种双重编码与双重HTML编码（ &lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ）或双重URI编码（ &lt;code&gt;%253E&lt;/code&gt; ）进行比较。</target>
        </trans-unit>
        <trans-unit id="b8d5a9055801b14712a33d32b68e49a7db91b2d3" translate="yes" xml:space="preserve">
          <source>Whenever your encoded, binary string is used together with a text string, Perl will assume that your binary string was encoded with ISO-8859-1, also known as latin-1. If it wasn't latin-1, then your data is unpleasantly converted. For example, if it was UTF-8, the individual bytes of multibyte characters are seen as separate characters, and then again converted to UTF-8. Such double encoding can be compared to double HTML encoding (&lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt;), or double URI encoding (&lt;code&gt;%253E&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d629f115a3e97bf6ae620fc76d3801dd8ef401" translate="yes" xml:space="preserve">
          <source>Whenever your program accesses data or resources that can be accessed by other threads, you must take steps to coordinate access or risk data inconsistency and race conditions. Note that Perl will protect its internals from your race conditions, but it won't protect you from you.</source>
          <target state="translated">每当你的程序访问可以被其他线程访问的数据或资源时,你必须采取措施协调访问,否则就会有数据不一致和竞赛条件的风险。请注意,Perl会保护其内部免受你的竞赛条件的影响,但它不会保护你。</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="59d37a0123152108bee6e05a64e55d45d68bc028" translate="yes" xml:space="preserve">
          <source>Where $directory_count % 10 is 1 (&quot;%&quot; for modulo, remember), assuming $directory count is an integer, and except where $directory_count % 100 is 11, &quot;directories&quot; is forced to become grammatically singular, which means it gets the ending for the accusative singular... You begin to visualize the code it'd take to test for the problem so far,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb9b184246f9c47c2085ba5fb400e91c6332924c" translate="yes" xml:space="preserve">
          <source>Where 1 is the position of the first char in the string. Note that position can be 0, or larger than the actual length of the pattern, likewise length can be zero.</source>
          <target state="translated">其中1是字符串中第一个字符的位置。请注意,位置可以是0,也可以大于图案的实际长度,同样,长度也可以是0。</target>
        </trans-unit>
        <trans-unit id="73e22419719a01d34b548da9ec30ecb83ae08c13" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's.</source>
          <target state="translated">其中 &lt;code&gt;$id1&lt;/code&gt; ， &lt;code&gt;$id2&lt;/code&gt; 是两个字节的子字段ID。</target>
        </trans-unit>
        <trans-unit id="b9cb4e493b9dc9b7340611ceb99bc1cecceb2405" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's. The second byte of the ID cannot be 0, unless the &lt;code&gt;Strict&lt;/code&gt; option has been disabled.</source>
          <target state="translated">其中 &lt;code&gt;$id1&lt;/code&gt; ， &lt;code&gt;$id2&lt;/code&gt; 是两个字节的子字段ID。除非已禁用&amp;ldquo; &lt;code&gt;Strict&lt;/code&gt; 选项，否则ID的第二个字节不能为0 。</target>
        </trans-unit>
        <trans-unit id="77383c70462fa701aace92ef9b074251586e9457" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt;, &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a738c1e73fe6ddbf768fa126f517ebb72454b3e" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt;, &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's. The second byte of the ID cannot be 0, unless the &lt;code&gt;Strict&lt;/code&gt; option has been disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de8d3be1468ab688b0e6e35d8cea1268cae0caa0" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$r1&lt;/code&gt; can be a reference to any kind of data structure you'd like. It will be deeply copied. Because &lt;code&gt;dclone&lt;/code&gt; takes and returns references, you'd have to add extra punctuation if you had a hash of arrays that you wanted to copy.</source>
          <target state="translated">凡 &lt;code&gt;$r1&lt;/code&gt; 可以是任何类型的数据结构，你想一个参考。它将被深深地复制。因为 &lt;code&gt;dclone&lt;/code&gt; 接受并返回引用，所以如果要复制的数组的哈希值很大，则必须添加额外的标点符号。</target>
        </trans-unit>
        <trans-unit id="29126cbcaebf3032a0f200bdad16fd67b9d2ca9f" translate="yes" xml:space="preserve">
          <source>Where a &lt;b&gt;compiler&lt;/b&gt; remembers symbols. A program like Perl must somehow remember all the names of all the &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;filehandles&lt;/b&gt;, and &lt;b&gt;subroutines&lt;/b&gt; you&amp;rsquo;ve used. It does this by placing the names in a symbol table, which is implemented in Perl using a &lt;b&gt;hash table&lt;/b&gt;. There is a separate symbol table for each &lt;b&gt;package&lt;/b&gt; to give each package its own &lt;b&gt;namespace&lt;/b&gt;.</source>
          <target state="translated">当一个&lt;b&gt;编译器&lt;/b&gt;记住符号。像Perl这样的程序必须以某种方式记住您使用过的所有&lt;b&gt;变量&lt;/b&gt;，&lt;b&gt;文件句柄&lt;/b&gt;和&lt;b&gt;子例程&lt;/b&gt;的所有名称。它通过将名称放在符号表中来实现，该符号表在Perl中使用&lt;b&gt;哈希表实现&lt;/b&gt;。每个&lt;b&gt;包&lt;/b&gt;都有一个单独的符号表，以为每个&lt;b&gt;包&lt;/b&gt;提供自己的&lt;b&gt;名称空间&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="c27a5a0858ef6e994699b8e168fe5635708702fa" translate="yes" xml:space="preserve">
          <source>Where a layer opens or takes ownership of a file descriptor, that layer is responsible for getting the file descriptor's close-on-exec flag into the correct state. The flag should be clear for a file descriptor numbered less than or equal to &lt;code&gt;PL_maxsysfd&lt;/code&gt;, and set for any file descriptor numbered higher. For thread safety, when a layer opens a new file descriptor it should if possible open it with the close-on-exec flag initially set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841b8cfbd59c36bfe89c29e0da6a4675a6abce15" translate="yes" xml:space="preserve">
          <source>Where are modules installed?</source>
          <target state="translated">模块安装在哪里?</target>
        </trans-unit>
        <trans-unit id="77cc20dcc0c42287d0cc6c95ce660feb0b4c5aeb" translate="yes" xml:space="preserve">
          <source>Where can I buy a commercial version of Perl?</source>
          <target state="translated">我在哪里可以买到商业版的Perl?</target>
        </trans-unit>
        <trans-unit id="08cf7f142b0ee15a977fe964d0ddcdb1002739ae" translate="yes" xml:space="preserve">
          <source>Where can I get Perl macros for vi?</source>
          <target state="translated">我在哪里可以得到 vi 的 Perl 宏?</target>
        </trans-unit>
        <trans-unit id="406cbb0495a55956cb84611a8d86c9d721557519" translate="yes" xml:space="preserve">
          <source>Where can I get information on Perl?</source>
          <target state="translated">我在哪里可以获得Perl的信息?</target>
        </trans-unit>
        <trans-unit id="c63d9dfa4f6d6dcfc8103ea7650db10cd8e27fea" translate="yes" xml:space="preserve">
          <source>Where can I get perl-mode or cperl-mode for emacs?</source>
          <target state="translated">我在哪里可以得到 perl-mode 或 cperl-mode for emacs?</target>
        </trans-unit>
        <trans-unit id="b85fdb935a7a614522614b7feed541611e8d0a3e" translate="yes" xml:space="preserve">
          <source>Where can I get the latest libnet release</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f1c9d2159564047b740e7956f5640af04f1e3c" translate="yes" xml:space="preserve">
          <source>Where can I learn about CGI or Web programming in Perl?</source>
          <target state="translated">我在哪里可以学习CGI或Perl中的Web编程?</target>
        </trans-unit>
        <trans-unit id="703366e9bd37f95d6d2b90762995773aff84d67e" translate="yes" xml:space="preserve">
          <source>Where can I learn about linking C with Perl?</source>
          <target state="translated">我在哪里可以学习C语言与Perl的链接?</target>
        </trans-unit>
        <trans-unit id="ed8bfc60bd9d8b7923b8341ed07d83afc289bc35" translate="yes" xml:space="preserve">
          <source>Where can I learn about object-oriented Perl programming?</source>
          <target state="translated">哪里可以学习面向对象的Perl编程?</target>
        </trans-unit>
        <trans-unit id="210221a52d88064b34135e9105ebfd5d49152b00" translate="yes" xml:space="preserve">
          <source>Where can I post questions?</source>
          <target state="translated">我在哪里可以发布问题?</target>
        </trans-unit>
        <trans-unit id="34466094d5547ae836abe0422810851106c8e987" translate="yes" xml:space="preserve">
          <source>Where do I get the include files to do ioctl() or syscall()?</source>
          <target state="translated">我在哪里可以得到做ioctl()或syscall()的包含文件?</target>
        </trans-unit>
        <trans-unit id="ae774b74efc34a0e83321577caf18754079572a2" translate="yes" xml:space="preserve">
          <source>Where do I send bug reports?</source>
          <target state="translated">我在哪里发送错误报告?</target>
        </trans-unit>
        <trans-unit id="566e06889afcd4a7979069c8b0fd2da4dd9ed19e" translate="yes" xml:space="preserve">
          <source>Where file systems interfaces pass file names in and out of the program we also need care. The trend is for operating systems to use a fixed file encoding that don't actually depend on the locale; and this module determines the most appropriate encoding for file names. The &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module will know this encoding under the name &quot;locale_fs&quot;. For traditional Unix systems this will be an alias to the same encoding as &quot;locale&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93218aab454721cc4e38fe91ac1668248deeae63" translate="yes" xml:space="preserve">
          <source>Where is the implementation?</source>
          <target state="translated">落实在哪里?</target>
        </trans-unit>
        <trans-unit id="8a78c0649556030e4985847b409471ca9ebd9274" translate="yes" xml:space="preserve">
          <source>Where people get into trouble is here:</source>
          <target state="translated">人们遇到麻烦的地方就在这里。</target>
        </trans-unit>
        <trans-unit id="f616a42d8ce8b58cf95a9bfc5e5383c6c84dc620" translate="yes" xml:space="preserve">
          <source>Where prereqs are concerned, if META_MERGE is used, prerequisites are merged with their counterpart &lt;code&gt;WriteMakefile()&lt;/code&gt; argument (PREREQ_PM is merged into {prereqs}{runtime}{requires}, BUILD_REQUIRES into &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; , CONFIGURE_REQUIRES into &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; , and TEST_REQUIRES into &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; . When prereqs are specified with META_ADD, the only prerequisites added to the file come from the metadata, not &lt;code&gt;WriteMakefile()&lt;/code&gt; arguments.</source>
          <target state="translated">在涉及前提条件的情况下，如果使用META_MERGE，则前提条件将与其对应的 &lt;code&gt;WriteMakefile()&lt;/code&gt; 参数合并（PREREQ_PM并入{prereqs} {runtime} {requires}，BUILD_REQUIRES并入 &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; ，CONFIGURE_REQUIRES并入 &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; ，然后将TEST_REQUIRES放入 &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; 中。当使用META_ADD指定先决条件时，添加到文件的唯一先决条件来自元数据，而不是 &lt;code&gt;WriteMakefile()&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="9262bb4032137f4bd07b4f1a031c40996bf22f95" translate="yes" xml:space="preserve">
          <source>Where prereqs are concerned, if META_MERGE is used, prerequisites are merged with their counterpart &lt;code&gt;WriteMakefile()&lt;/code&gt; argument (PREREQ_PM is merged into {prereqs}{runtime}{requires}, BUILD_REQUIRES into &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt;, CONFIGURE_REQUIRES into &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt;, and TEST_REQUIRES into &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt;. When prereqs are specified with META_ADD, the only prerequisites added to the file come from the metadata, not &lt;code&gt;WriteMakefile()&lt;/code&gt; arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2578ad2cf7eb4212c4c2f76a99c66a64a699a6f4" translate="yes" xml:space="preserve">
          <source>Where the $way is a value from zero ($theta0, $phi0) to one ($theta1, $phi1). Note that antipodal points (where their distance is</source>
          <target state="translated">其中$way是一个从0($theta0,$phi0)到1($theta1,$phi1)的值。请注意,反极点(其距离为</target>
        </trans-unit>
        <trans-unit id="fd6d6e78410be236f0ee8b2e37126d4a25f62f65" translate="yes" xml:space="preserve">
          <source>Where the 'DSLIP' characters have the following meanings:</source>
          <target state="translated">其中'DSLIP'字符具有以下含义。</target>
        </trans-unit>
        <trans-unit id="843828ced3164063fc4c650d4b6af29aa8f9cb2c" translate="yes" xml:space="preserve">
          <source>Where the two must be separate, initially set the type to &lt;code&gt;CXt_NULL&lt;/code&gt; or &lt;code&gt;CXt_BLOCK&lt;/code&gt;, and later change it to &lt;code&gt;CXt_foo&lt;/code&gt; when doing the &lt;code&gt;cx_pushfoo&lt;/code&gt;. This is exactly what &lt;code&gt;pp_enteriter&lt;/code&gt; does, once it's determined which type of loop it's pushing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a57b05d69f49e2636c91eefc4c6774814129e12" translate="yes" xml:space="preserve">
          <source>Where there is only one operand (or only one operand with overloading) the checks in respect of the other operand above are skipped.</source>
          <target state="translated">如果只有一个操作数(或只有一个操作数有重载),则跳过对上述其他操作数的检查。</target>
        </trans-unit>
        <trans-unit id="293c942f397777e729937e1824d906951d88e087" translate="yes" xml:space="preserve">
          <source>Where these steps occur in the actual execution of a perl program is determined by whether the pattern involves interpolating any string variables. If interpolation occurs, then compilation happens at run time. If it does not, then compilation is performed at compile time. (The &lt;code&gt;/o&lt;/code&gt; modifier changes this, as does &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; to a certain extent.) The engine doesn't really care that much.</source>
          <target state="translated">这些步骤在perl程序的实际执行中发生的位置由模式是否涉及对任何字符串变量进行插值来确定。如果发生插值，则编译将在运行时发生。如果不是，则在编译时执行编译。（ &lt;code&gt;/o&lt;/code&gt; 修饰符在一定程度上改变了它， &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 也是如此。）引擎实际上并不那么在乎。</target>
        </trans-unit>
        <trans-unit id="eb41b8cee1215605643716ae7b75d6423a86bb03" translate="yes" xml:space="preserve">
          <source>Where these steps occur in the actual execution of a perl program is determined by whether the pattern involves interpolating any string variables. If interpolation occurs, then compilation happens at run time. If it does not, then compilation is performed at compile time. (The &lt;code&gt;/o&lt;/code&gt; modifier changes this, as does &lt;code&gt;qr//&lt;/code&gt; to a certain extent.) The engine doesn't really care that much.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca423190a1a1c785b9d576f8083e40dd5389585" translate="yes" xml:space="preserve">
          <source>Where to Find the Community</source>
          <target state="translated">哪里可以找到社区</target>
        </trans-unit>
        <trans-unit id="536ef5aba264e8d2aec71ea10430b9efa22dfe0c" translate="yes" xml:space="preserve">
          <source>Where to find the perlfaq</source>
          <target state="translated">在哪里可以找到perlfaq</target>
        </trans-unit>
        <trans-unit id="93683b8b8083dba6e071465301ae1d1c45028dec" translate="yes" xml:space="preserve">
          <source>Where to get this document</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4af9617f74f3fb16e775a0d165421fe00441bc1b" translate="yes" xml:space="preserve">
          <source>Where to start?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e10717c102dd0c9df4c18b5606b9aaf6912d10" translate="yes" xml:space="preserve">
          <source>Where you look to find a pointer to information somewhere else. (See &lt;b&gt;indirection&lt;/b&gt;.) References come in two flavors: &lt;b&gt;symbolic references&lt;/b&gt; and &lt;b&gt;hard references&lt;/b&gt;.</source>
          <target state="translated">您在哪里寻找其他地方的信息指针。（请参阅&lt;b&gt;间接&lt;/b&gt;引用。）引用有两种形式：&lt;b&gt;符号引用&lt;/b&gt;和&lt;b&gt;硬引用&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="500583f76e5e2a57eb1022812ab875f23db70975" translate="yes" xml:space="preserve">
          <source>Where's the catch? Padding is neither required before the first field &lt;code&gt;count&lt;/code&gt; , nor between this and the next field &lt;code&gt;glyph&lt;/code&gt; , so why can't we simply pack like this:</source>
          <target state="translated">渔获物在哪里？在第一个字段 &lt;code&gt;count&lt;/code&gt; 之前，在此字段和下一个字段 &lt;code&gt;glyph&lt;/code&gt; 之间都不需要填充，因此为什么我们不能像这样简单地打包：</target>
        </trans-unit>
        <trans-unit id="2bdd0a720834494322577f4ab7718daee200802f" translate="yes" xml:space="preserve">
          <source>Where's the catch? Padding is neither required before the first field &lt;code&gt;count&lt;/code&gt;, nor between this and the next field &lt;code&gt;glyph&lt;/code&gt;, so why can't we simply pack like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ff01499d11ce21062a9b96027ab58ee226aad3" translate="yes" xml:space="preserve">
          <source>Where,</source>
          <target state="translated">Where,</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="4d453f1163fdbba0e62b8cfe55db1c43bd938110" translate="yes" xml:space="preserve">
          <source>Whereas a QP decoder that works on both ASCII and EBCDIC platforms would look somewhat like the following:</source>
          <target state="translated">而一个同时适用于ASCII和EBCDIC平台的QP解码器则有点像下面的样子。</target>
        </trans-unit>
        <trans-unit id="4c1007108b497a2f8b15b3dc9255f03fbd82a20c" translate="yes" xml:space="preserve">
          <source>Whereas here's how a Perl programmer more comfortable with the idiom might do it:</source>
          <target state="translated">而下面是一个Perl程序员对这个成语比较熟悉的做法。</target>
        </trans-unit>
        <trans-unit id="5db7dff8fd1589f3c435af6d45d16e0816b2e9c4" translate="yes" xml:space="preserve">
          <source>Whereas if you comment out the two lines I said you might wish to, then it shows it to you this way instead:</source>
          <target state="translated">而如果你把我说的那两行字注释出来,你可能会希望,那么它反而会这样显示给你。</target>
        </trans-unit>
        <trans-unit id="ab440f8d11b8fd4e9e75cd6104ac553e6f04002a" translate="yes" xml:space="preserve">
          <source>Whereas other perl internal stacks store individual items all of the same type (usually SV pointers or integers), the items pushed to the save stack are formed of many different types, having multiple fields to them. For example, the &lt;code&gt;SAVEt_INT&lt;/code&gt; type needs to store both the address of the &lt;code&gt;int&lt;/code&gt; variable to restore, and the value to restore it to. This information could have been stored using fields of a &lt;code&gt;struct&lt;/code&gt;, but would have to be large enough to store three pointers in the largest case, which would waste a lot of space in most of the smaller cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa7a6da1ef7f2699440e362142ae5565af060786" translate="yes" xml:space="preserve">
          <source>Wherever a list of operators can be given you can use one or more opsets. See also Manipulating Opsets below.</source>
          <target state="translated">只要能给出一个运算符列表,就可以使用一个或多个OPSET。请参阅下面的操纵操作集。</target>
        </trans-unit>
        <trans-unit id="c457c17dce216494419135c71949242b8d09d0bb" translate="yes" xml:space="preserve">
          <source>Wherever possible, shareable images are preferred to object libraries, and object libraries to plain object files. In accordance with VMS naming conventions, ext() looks for files named</source>
          <target state="translated">在可能的情况下,可共享的图像优于对象库,对象库优于普通对象文件。按照VMS的命名惯例,ext()会查找名为</target>
        </trans-unit>
        <trans-unit id="a5ce0b5c076605e513279f0c54d153294cc237e9" translate="yes" xml:space="preserve">
          <source>Whether PadnamePV is in UTF-8. Currently, this is always true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f21be64cee3c558562d0924a678b1007587a17" translate="yes" xml:space="preserve">
          <source>Whether PadnamePV is in UTF8. Currently, this is always true.</source>
          <target state="translated">PadnamePV是否是UTF8格式。目前,这个值总是为真。</target>
        </trans-unit>
        <trans-unit id="0971615da14029bdca88814940e8de90b6be5147" translate="yes" xml:space="preserve">
          <source>Whether a &quot;signaling&quot; NaN is in any way different from a &quot;quiet&quot; NaN, depends on the platform. Also note that the payload of the default NaN (no argument to nan()) is not necessarily zero, use &lt;code&gt;setpayload&lt;/code&gt; to explicitly set the payload. On some platforms like the 32-bit x86, (unless using the 80-bit long doubles) the signaling bit is not supported at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b3304921bf73755f27746fb53954b4a8c4de93" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is disabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;require_order&lt;/code&gt; is enabled.</source>
          <target state="translated">是否允许命令行参数与选项混合。除非已设置环境变量POSIXLY_CORRECT（在这种情况下启用了 &lt;code&gt;require_order&lt;/code&gt; ），否则默认设置为禁用。</target>
        </trans-unit>
        <trans-unit id="faea90df33f36630a481da4cad34e4c79bf52fc5" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;permute&lt;/code&gt; is disabled. Note that &lt;code&gt;permute&lt;/code&gt; is the opposite of &lt;code&gt;require_order&lt;/code&gt; .</source>
          <target state="translated">是否允许命令行参数与选项混合。除非已设置环境变量POSIXLY_CORRECT，否则将启用默认值，在这种情况下，禁用 &lt;code&gt;permute&lt;/code&gt; 。请注意， &lt;code&gt;permute&lt;/code&gt; 与 &lt;code&gt;require_order&lt;/code&gt; 相反。</target>
        </trans-unit>
        <trans-unit id="7872b2f4a897e4a8ef1ea13c927afbc5f8e9bb5d" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;permute&lt;/code&gt; is disabled. Note that &lt;code&gt;permute&lt;/code&gt; is the opposite of &lt;code&gt;require_order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457d6cfb1888790c7832bd27b66465f0cdcbd754" translate="yes" xml:space="preserve">
          <source>Whether dtrace accepts -xnolibs. If available we call dtrace -h and dtrace -G with -xnolibs to allow dtrace to run in a jail on FreeBSD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf16a187d3ac8048da2c0a9f49f8874167f5a83b" translate="yes" xml:space="preserve">
          <source>Whether or not the op has been optimized by the peephole optimizer.</source>
          <target state="translated">是否已经通过窥视孔优化器对操作进行了优化。</target>
        </trans-unit>
        <trans-unit id="99e430c2678f913bd7c7b93452d560622af7b626" translate="yes" xml:space="preserve">
          <source>Whether or not the test should output numbers. That is, this if true:</source>
          <target state="translated">测试是否应该输出数字。也就是说,这个如果为真。</target>
        </trans-unit>
        <trans-unit id="5f8067023624d336e348da355a79650c3095a919" translate="yes" xml:space="preserve">
          <source>Whether or not to be verbose about what it is doing -- it will default to $Module::Load::Conditional::VERBOSE</source>
          <target state="translated">是否对它正在做的事情进行详细说明--它将默认为$Module::Load::Conditional::VERBOSE。</target>
        </trans-unit>
        <trans-unit id="835c4d9838e01fba8d1ac35f378ff2857c3bbf2f" translate="yes" xml:space="preserve">
          <source>Whether sorting is stable by default is an accident of implementation that can change (and has changed) between Perl versions. If stability is important, be sure to say so with a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f7f78ec0e44e67b9396390cd1ee3bcf0e5e14e" translate="yes" xml:space="preserve">
          <source>Whether this entry belongs to an outer pad. Entries for which this is true are often referred to as 'fake'.</source>
          <target state="translated">这个条目是否属于外垫。这种情况的条目通常被称为 &quot;假的&quot;。</target>
        </trans-unit>
        <trans-unit id="6283322d116e1d51f7edcd1ec872a9eed355ceb1" translate="yes" xml:space="preserve">
          <source>Whether this is a &quot;state&quot; variable.</source>
          <target state="translated">这是否是一个 &quot;状态 &quot;变量。</target>
        </trans-unit>
        <trans-unit id="e7034c09da28fdb3d58392534621cc03eebbd14d" translate="yes" xml:space="preserve">
          <source>Whether this is an &quot;our&quot; variable.</source>
          <target state="translated">这是否是一个 &quot;我们的 &quot;变量。</target>
        </trans-unit>
        <trans-unit id="c084cfe6eeb06cc1ff5160c3c990367fe4946569" translate="yes" xml:space="preserve">
          <source>Whether this type of partition is support under Win32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe93610e6b23e15b98198b34ad48105c383339a" translate="yes" xml:space="preserve">
          <source>Whether to abort printing if debugger signal flag is raised.</source>
          <target state="translated">如果调试器信号标志被激发,是否要中止打印。</target>
        </trans-unit>
        <trans-unit id="2985490d3101108f328098168c5a21b3bc3c5a70" translate="yes" xml:space="preserve">
          <source>Whether to add a table-of-contents at the top of each page (called an index for the sake of tradition).</source>
          <target state="translated">是否在每页顶部增加一个目录(为了传统,称为索引)。</target>
        </trans-unit>
        <trans-unit id="3a911a7e2bce47416920de6f21016acd3029366b" translate="yes" xml:space="preserve">
          <source>Whether to anchor every definition &lt;code&gt;=item&lt;/code&gt; directive. This needs to be enabled if you want to be able to link to specific &lt;code&gt;=item&lt;/code&gt; directives, which are output as &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; elements. Disabled by default.</source>
          <target state="translated">是否锚定每个定义 &lt;code&gt;=item&lt;/code&gt; 指令。如果您希望能够链接到特定的 &lt;code&gt;=item&lt;/code&gt; 指令（以 &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; 元素输出），则需要启用此功能。默认禁用。</target>
        </trans-unit>
        <trans-unit id="626413839d3d50a20deaaad85828e47d347f236c" translate="yes" xml:space="preserve">
          <source>Whether to call these extended grapheme clusters &quot;characters&quot; depends on your point of view. If you are a programmer, you probably would tend towards seeing each element in the sequences as one unit, or &quot;character&quot;. However from the user's point of view, the whole sequence could be seen as one &quot;character&quot; since that's probably what it looks like in the context of the user's language. In this document, we take the programmer's point of view: one &quot;character&quot; is one Unicode code point.</source>
          <target state="translated">是否将这些扩展的字词群称为 &quot;字符&quot;,取决于你的观点。如果你是一个程序员,你可能会倾向于把序列中的每个元素看作一个单元,或者说 &quot;字符&quot;。然而从用户的角度来看,整个序列可以被看作是一个 &quot;字符&quot;,因为在用户语言的上下文中,这可能就是它的样子。在本文档中,我们从程序员的角度出发:一个 &quot;字符 &quot;就是一个Unicode码点。</target>
        </trans-unit>
        <trans-unit id="ee66335b9db0c1d5103deb721dc40777dd212c3c" translate="yes" xml:space="preserve">
          <source>Whether to print chars with high bit set in binary or &quot;as is&quot;.</source>
          <target state="translated">是否打印二进制或 &quot;按原样 &quot;设置的高位字符。</target>
        </trans-unit>
        <trans-unit id="238ca87137bc56748ce05a002a71d9a6db9c7ebe" translate="yes" xml:space="preserve">
          <source>Whether to print contents of globs.</source>
          <target state="translated">是否打印globs的内容。</target>
        </trans-unit>
        <trans-unit id="d3a12643fc63beef0ef6ccef6dae848daa691587" translate="yes" xml:space="preserve">
          <source>Whether to try to find the subroutine name given the reference.</source>
          <target state="translated">是否尝试查找给定引用的子程序名。</target>
        </trans-unit>
        <trans-unit id="bfd0c6dfe7d4e4cba4e02f1a0ab33700dc1c327f" translate="yes" xml:space="preserve">
          <source>Whether to turn every =head1 directive into a link pointing to the top of the page (specifically, the opening body tag).</source>
          <target state="translated">是否将每个=head1指令都变成指向页面顶部的链接(特别是开头的body标签)。</target>
        </trans-unit>
        <trans-unit id="c12251b6a52be9785616abd5b79f50c9699026bb" translate="yes" xml:space="preserve">
          <source>Whether to update this partition information. This field is not used by &lt;code&gt;IOCTL_DISK_GET_PARTITION_INFO&lt;/code&gt;. For &lt;code&gt;IOCTL_DISK_SET_DRIVE_LAYOUT&lt;/code&gt;, you must set this field to a true value for any partitions you wish to have changed, added, or deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26288162f4ab8ff9ae48923849befc89334a4a3" translate="yes" xml:space="preserve">
          <source>Whether to write the non-overloaded form of the stringify-overloaded objects.</source>
          <target state="translated">是否编写非过载形式的字符串化过载对象。</target>
        </trans-unit>
        <trans-unit id="db40c6156e22d6cc6531821dd75bdcb0d45e3842" translate="yes" xml:space="preserve">
          <source>Whether various library calls are thread-safe is outside the control of Perl. Calls often suffering from not being thread-safe include: &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;, functions fetching user, group and network information (such as &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; and so on), &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt;. In general, calls that depend on some global external state.</source>
          <target state="translated">Perl不能控制各种库调用是否是线程安全的。经常受线程安全影响的调用包括： &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; ，获取用户，组和网络信息的函数（例如 &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; 等等）， &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 。通常，调用取决于某些全局外部状态。</target>
        </trans-unit>
        <trans-unit id="d56e1a6230da252ffdc8d6662ae566d3f6b5ee2f" translate="yes" xml:space="preserve">
          <source>Whether various library calls are thread-safe is outside the control of Perl. Calls often suffering from not being thread-safe include: &lt;code&gt;localtime()&lt;/code&gt;, &lt;code&gt;gmtime()&lt;/code&gt;, functions fetching user, group and network information (such as &lt;code&gt;getgrent()&lt;/code&gt;, &lt;code&gt;gethostent()&lt;/code&gt;, &lt;code&gt;getnetent()&lt;/code&gt; and so on), &lt;code&gt;readdir()&lt;/code&gt;, &lt;code&gt;rand()&lt;/code&gt;, and &lt;code&gt;srand()&lt;/code&gt;. In general, calls that depend on some global external state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="465a32753eace035273aaef17e2c639421b02dff" translate="yes" xml:space="preserve">
          <source>Whether we need to build an object file with the dtrace tool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201246e3611962dc1ed1a9edc779811bfcd3278b" translate="yes" xml:space="preserve">
          <source>Whether you are using NIS does not matter. Amazingly enough, the same bug also affects Solaris.</source>
          <target state="translated">你是否使用NIS并不重要。令人惊奇的是,同样的bug也会影响到Solaris。</target>
        </trans-unit>
        <trans-unit id="f8e039fc339d1036f86bd64ce844762f9417fe8b" translate="yes" xml:space="preserve">
          <source>Whether you use &lt;code&gt;perlbug&lt;/code&gt; or send the email manually, please make your Subject line informative. &quot;a bug&quot; is not informative. Neither is &quot;perl crashes&quot; nor is &quot;HELP!!!&quot;. These don't help. A compact description of what's wrong is fine.</source>
          <target state="translated">无论您使用 &lt;code&gt;perlbug&lt;/code&gt; 还是手动发送电子邮件，请使您的主题行内容丰富。 &amp;ldquo;错误&amp;rdquo;不提供信息。 &amp;ldquo; perl崩溃&amp;rdquo;也不是&amp;ldquo;帮助！&amp;rdquo;。这些无济于事。简要描述出什么问题是可以的。</target>
        </trans-unit>
        <trans-unit id="0cde069a15e713b9fe4a9a6b7078fade7daf5170" translate="yes" xml:space="preserve">
          <source>Whew! That is all the rest of the characters and character classes.</source>
          <target state="translated">呼! 剩下的角色和角色类就这些了。</target>
        </trans-unit>
        <trans-unit id="27e5de2ca1964d94a9ea629b708a58094f2d855e" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;Tie::Hash&quot;&gt;Tie::Hash&lt;/a&gt; operation is being performed from the Perl level on &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt;, if any:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56043e0fa27cef8d93950adbdc599597748f590d" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; operation is being performed from the Perl level on &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt; , if any:</source>
          <target state="translated">正在Perl级别上在 &lt;code&gt;%+&lt;/code&gt; 或 &lt;code&gt;%+&lt;/code&gt; 上执行哪个&lt;a href=&quot;tie/hash&quot;&gt;Tie :: Hash&lt;/a&gt;操作：</target>
        </trans-unit>
        <trans-unit id="babf69836d4addec6f5a5308cb5825c678eb405e" translate="yes" xml:space="preserve">
          <source>Which Perl blogs should I read?</source>
          <target state="translated">我应该看哪些Perl博客?</target>
        </trans-unit>
        <trans-unit id="54a12a94c6d59fab4aeefed76c9781df10879a85" translate="yes" xml:space="preserve">
          <source>Which YAML implementation would you prefer?</source>
          <target state="translated">你更喜欢哪种YAML实现?</target>
        </trans-unit>
        <trans-unit id="88e9358d41b432fbb58126174b7979a4235a746a" translate="yes" xml:space="preserve">
          <source>Which architecture dependent directory?</source>
          <target state="translated">哪个架构依赖目录?</target>
        </trans-unit>
        <trans-unit id="b7506b68ee68fa595a60659e338ae77c9646b01d" translate="yes" xml:space="preserve">
          <source>Which character set modifier is in effect?</source>
          <target state="translated">哪个字符集修改器是有效的?</target>
        </trans-unit>
        <trans-unit id="ee9b43c6b4875ca7c0a8fea57558205fc2e727ab" translate="yes" xml:space="preserve">
          <source>Which commit added the first file to match this regex?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d004402710bbe1f74279bca91591607062854495" translate="yes" xml:space="preserve">
          <source>Which commit caused this example code to break?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd77891b19f04e8f4749d5465e616c7d548783ec" translate="yes" xml:space="preserve">
          <source>Which commit caused this example code to start working?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0816de4aeeb375a395f682785a672eb7143a573" translate="yes" xml:space="preserve">
          <source>Which commit removed the last file to match this regex?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6d9abe75ea380074d1386fb6bc4638c51ca405" translate="yes" xml:space="preserve">
          <source>Which is checked first, &lt;code&gt;nomethod&lt;/code&gt; or &lt;code&gt;fallback&lt;/code&gt; ? If the two operands of an operator are of different types and both overload the operator, which implementation is used? The following are the precedence rules:</source>
          <target state="translated">首先检查哪种方法， &lt;code&gt;nomethod&lt;/code&gt; 或 &lt;code&gt;fallback&lt;/code&gt; ？如果一个运算符的两个操作数是不同类型的并且都使该运算符超载，则使用哪种实现？以下是优先规则：</target>
        </trans-unit>
        <trans-unit id="26892517e1a24be563151c63ed23ba887d7067cd" translate="yes" xml:space="preserve">
          <source>Which is checked first, &lt;code&gt;nomethod&lt;/code&gt; or &lt;code&gt;fallback&lt;/code&gt;? If the two operands of an operator are of different types and both overload the operator, which implementation is used? The following are the precedence rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db62588fd2906af96c2fa483b06db407a80424f" translate="yes" xml:space="preserve">
          <source>Which is effectively just:</source>
          <target state="translated">这实际上只是。</target>
        </trans-unit>
        <trans-unit id="b3fbe5ee09cb06684cac7d1a3e427f0dd899daef" translate="yes" xml:space="preserve">
          <source>Which is what we might expect, the match finds the only &lt;code&gt;cat&lt;/code&gt; in the string and locks onto it. Consider, however, this regexp:</source>
          <target state="translated">这可能是我们所期望的，该匹配项在字符串中找到了唯一的 &lt;code&gt;cat&lt;/code&gt; 并将其锁定。但是，请考虑以下正则表达式：</target>
        </trans-unit>
        <trans-unit id="b248b8b60b90917a66aeb94063d05f7d477a94bd" translate="yes" xml:space="preserve">
          <source>Which magazines have Perl content?</source>
          <target state="translated">哪些杂志有Perl内容?</target>
        </trans-unit>
        <trans-unit id="786c2c13e1b48f509ddfa13fe457e7ade1e2d5c4" translate="yes" xml:space="preserve">
          <source>Which makes $richard and $dick the same variable, but leaves @richard and @dick as separate arrays. Tricky, eh?</source>
          <target state="translated">这样一来,$richard和$dick就成了同一个变量,但@richard和@dick就成了单独的数组。棘手吧,嗯?</target>
        </trans-unit>
        <trans-unit id="c62379639a4b05982ed9a5d227696146f851a074" translate="yes" xml:space="preserve">
          <source>Which of the various &lt;code&gt;*OP&lt;/code&gt; structures this op uses. This should be one of the &lt;code&gt;OA_*&lt;/code&gt; constants from</source>
          <target state="translated">该op使用哪种 &lt;code&gt;*OP&lt;/code&gt; 结构。这应该是 &lt;code&gt;OA_*&lt;/code&gt; 常量之一</target>
        </trans-unit>
        <trans-unit id="a891db1882ed2a728a47d9d75117f36a4ff2a006" translate="yes" xml:space="preserve">
          <source>Which of these modifiers is in effect at any given point in a regular expression depends on a fairly complex set of interactions. These have been designed so that in general you don't have to worry about it, but this section gives the gory details. As explained below in &lt;a href=&quot;#Extended-Patterns&quot;&gt;&quot;Extended Patterns&quot;&lt;/a&gt; it is possible to explicitly specify modifiers that apply only to portions of a regular expression. The innermost always has priority over any outer ones, and one applying to the whole expression has priority over any of the default settings that are described in the remainder of this section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c28a2fc8be0459fa3248ceb80936f8aba82ccd2" translate="yes" xml:space="preserve">
          <source>Which of these modifiers is in effect at any given point in a regular expression depends on a fairly complex set of interactions. These have been designed so that in general you don't have to worry about it, but this section gives the gory details. As explained below in &lt;a href=&quot;#Extended-Patterns&quot;&gt;Extended Patterns&lt;/a&gt; it is possible to explicitly specify modifiers that apply only to portions of a regular expression. The innermost always has priority over any outer ones, and one applying to the whole expression has priority over any of the default settings that are described in the remainder of this section.</source>
          <target state="translated">这些修饰符中的哪一个在正则表达式的任何给定点有效，取决于一组相当复杂的交互作用。这些功能的设计使您通常不必担心，但是本节提供了详细的信息。如以下&lt;a href=&quot;#Extended-Patterns&quot;&gt;扩展模式中所述&lt;/a&gt;，可以显式指定仅适用于正则表达式部分的修饰符。最里面的总是优先于任何外部的，而应用于整个表达式的优先于本节其余部分描述的任何默认设置。</target>
        </trans-unit>
        <trans-unit id="3d81e570041b9ef8c3716fd625de2184bc9fcbe4" translate="yes" xml:space="preserve">
          <source>Which one you pick depends on which of these expressions better reflects the above specification of comments.</source>
          <target state="translated">你选哪一个,要看这些表达方式中哪一个更能体现上面的注释规范。</target>
        </trans-unit>
        <trans-unit id="79ee8492b912fab00990fc318850246c7ab7a4ba" translate="yes" xml:space="preserve">
          <source>Which perhaps unexpectedly yields:</source>
          <target state="translated">这或许是意外的收获。</target>
        </trans-unit>
        <trans-unit id="05c36e4547159a2f896e1c4c828cfe54c70d84ef" translate="yes" xml:space="preserve">
          <source>Which rules apply are determined as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3F&quot;&gt;&quot;Which character set modifier is in effect?&quot; in perlre&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e550746bad7dcee6b1162b28bf7aedac094cd1e" translate="yes" xml:space="preserve">
          <source>Which rules apply are determined as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符生效&lt;/a&gt;来确定适用哪些规则？在。</target>
        </trans-unit>
        <trans-unit id="b4ea6c1227777eb0d0611636fc0f0ce8660134f3" translate="yes" xml:space="preserve">
          <source>Which substring to check first.</source>
          <target state="translated">先检查哪个子串。</target>
        </trans-unit>
        <trans-unit id="627f14bbed51912496b6fb85cde41b9d90202d10" translate="yes" xml:space="preserve">
          <source>Which tar should I use on Windows?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f094ffb275753431ba594c04d0d66a718fa1eda" translate="yes" xml:space="preserve">
          <source>Which text formatter to use. Default is &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt;, or for very old Perl versions &lt;a href=&quot;Pod::PlainText&quot;&gt;Pod::PlainText&lt;/a&gt;. An alternative would be e.g. &lt;a href=&quot;Pod::Text::Termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b26c1ae972001db5809b34aeb5a2c0bda11feda" translate="yes" xml:space="preserve">
          <source>Which text formatter to use. Default is &lt;a href=&quot;pod/text&quot;&gt;Pod::Text&lt;/a&gt;, or for very old Perl versions &lt;a href=&quot;pod/plaintext&quot;&gt;Pod::PlainText&lt;/a&gt;. An alternative would be e.g. &lt;a href=&quot;pod/text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">使用哪种文本格式化程序。默认值为&lt;a href=&quot;pod/text&quot;&gt;Pod :: Text&lt;/a&gt;，或者对于非常旧的Perl版本&lt;a href=&quot;pod/plaintext&quot;&gt;Pod :: PlainText&lt;/a&gt;。另一种选择是例如&lt;a href=&quot;pod/text/termcap&quot;&gt;Pod :: Text :: Termcap&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b8afbe233aaf49239a07d2a4536a6d9be415fc8" translate="yes" xml:space="preserve">
          <source>Which version of Perl should I use?</source>
          <target state="translated">我应该使用哪个版本的Perl?</target>
        </trans-unit>
        <trans-unit id="ed3642f21edcd8b0db0bc9f8cee4ac46473a253a" translate="yes" xml:space="preserve">
          <source>Which version of perl do I need ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32a93a6b75c99229f45ca5666bf0720d67cc2e24" translate="yes" xml:space="preserve">
          <source>Which version of perl should I use?</source>
          <target state="translated">我应该使用哪个版本的perl?</target>
        </trans-unit>
        <trans-unit id="7631d79fe8017e212e81e096dcea8cb82517cdbf" translate="yes" xml:space="preserve">
          <source>Which web framework should I use?</source>
          <target state="translated">我应该使用哪个网络框架?</target>
        </trans-unit>
        <trans-unit id="ca95e2a8ef78e8e65dfe2ee661d1738206c25df7" translate="yes" xml:space="preserve">
          <source>Which will create the directory we need, and you can move on to the next step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd7ff93be76f4f655ab909493a6705c72660d9c" translate="yes" xml:space="preserve">
          <source>Which will print</source>
          <target state="translated">这将打印</target>
        </trans-unit>
        <trans-unit id="03d7614f12de55df0b888753d3fa1d0fb28069d7" translate="yes" xml:space="preserve">
          <source>Which would attempt to set breakpoints on lines 4 and 6 immediately after debugger initialization. Note that @DB::typeahead is not a supported interface and is subject to change in future releases.</source>
          <target state="translated">这将试图在调试器初始化后立即在第4行和第6行设置断点。请注意,@DB::typeahead不是一个支持的接口,在未来的版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="c966532947a1e874f5fbb5570050ef3e1254690b" translate="yes" xml:space="preserve">
          <source>Which would generate a format looking something like this:</source>
          <target state="translated">这将产生一个类似于这样的格式。</target>
        </trans-unit>
        <trans-unit id="d885d5ead32cef5d0d07c15652290de0ab57655a" translate="yes" xml:space="preserve">
          <source>Which zip should I use on Windows for '[ndg]make zipdist'?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91c0db76a3c1130f40e63caacba5a278833ffb99" translate="yes" xml:space="preserve">
          <source>Which, in the degenerate case of using only ordinary arrays, gives you multidimensional arrays just like C's:</source>
          <target state="translated">其中,在只使用普通数组的退化情况下,可以得到像C语言一样的多维数组。</target>
        </trans-unit>
        <trans-unit id="49233da44986d650dd0c62f9412171689ae74192" translate="yes" xml:space="preserve">
          <source>Whichever version is used, the actual methods are called in the same context (list, scalar, or void) as the original call via &lt;code&gt;EVERY&lt;/code&gt; , and return:</source>
          <target state="translated">无论使用哪种版本，实际方法都将通过 &lt;code&gt;EVERY&lt;/code&gt; 在与原始调用相同的上下文中（列表，标量或void）调用，并返回：</target>
        </trans-unit>
        <trans-unit id="07d57e57f3a8ced4fc446692cf92ed5425c3284f" translate="yes" xml:space="preserve">
          <source>Whichever version is used, the actual methods are called in the same context (list, scalar, or void) as the original call via &lt;code&gt;EVERY&lt;/code&gt;, and return:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed29deaf6c9f70efd08af26605d88141ad2586b" translate="yes" xml:space="preserve">
          <source>While $FORMAT_TOP_NAME contains the name of the current header format, there is no corresponding mechanism to automatically do the same thing for a footer. Not knowing how big a format is going to be until you evaluate it is one of the major problems. It's on the TODO list.</source>
          <target state="translated">虽然$FORMAT_TOP_NAME包含了当前页眉格式的名称,但没有相应的机制来自动为页脚做同样的事情。在评估之前,不知道一个格式会有多大,这是主要问题之一。这已经在TODO列表中了。</target>
        </trans-unit>
        <trans-unit id="b0cd08c49ca70b961592a79d7ad5531909d37f26" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; provides integer-only arithmetic, there is no analogous mechanism to provide automatic rounding or truncation to a certain number of decimal places. For rounding to a certain number of digits, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; is usually the easiest route. See &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;.</source>
          <target state="translated">尽管 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 提供仅整数运算，但没有类似的机制可提供自动舍入或舍入到一定数量的小数位。对于四舍五入到一定数量的数字， &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; 通常是最简单的方法。参见&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01f836f2c1198b05b58549da2eae8767a49ca6a1" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;STORABLE_freeze&lt;/code&gt; and &lt;code&gt;STORABLE_thaw&lt;/code&gt; are useful for classes where each instance is independent, this mechanism has difficulty (or is incompatible) with objects that exist as common process-level or system-level resources, such as singleton objects, database pools, caches or memoized objects.</source>
          <target state="translated">尽管 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 和 &lt;code&gt;STORABLE_thaw&lt;/code&gt; 对于每个实例都是独立的类很有用，但该机制很难（或不兼容）与作为公共流程级或系统级资源存在的对象（例如单例对象，数据库池，缓存或已记录对象）一起使用（或不兼容） 。</target>
        </trans-unit>
        <trans-unit id="d9b242bc936842344ffd618aab5876b2850c2c1b" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;connect&lt;/code&gt; returns false, the value of &lt;code&gt;$!&lt;/code&gt; indicates whether it should be tried again (by being set to the value &lt;code&gt;EINPROGRESS&lt;/code&gt;, or &lt;code&gt;EWOULDBLOCK&lt;/code&gt; on MSWin32), or whether a permanent error has occurred (e.g. &lt;code&gt;ECONNREFUSED&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a9af13c711e35bbea687932bfa0e243bef5296" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;s///&lt;/code&gt; accepts the &lt;code&gt;/c&lt;/code&gt; flag, it has no effect beyond producing a warning if warnings are enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8eb5c19a610d348554e2fa519e5457ab307a063" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;use integer&lt;/code&gt; provides integer-only arithmetic, there is no analogous mechanism to provide automatic rounding or truncation to a certain number of decimal places. For rounding to a certain number of digits, &lt;code&gt;sprintf()&lt;/code&gt; or &lt;code&gt;printf()&lt;/code&gt; is usually the easiest route. See &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a400d769e405e7503768315d8de6e5c08fa4438" translate="yes" xml:space="preserve">
          <source>While B::Deparse goes to some lengths to try to figure out what your original program was doing, some parts of the language can still trip it up; it still fails even on some parts of Perl's own test suite. If you encounter a failure other than the most common ones described in the BUGS section below, you can help contribute to B::Deparse's ongoing development by submitting a bug report with a small example.</source>
          <target state="translated">虽然 B::Deparse 会花一些力气去弄清楚你的原始程序在做什么,但语言的某些部分还是会让它绊倒;甚至在 Perl 自己的测试套件的某些部分也会失败。如果你遇到了下面 BUGS 部分所描述的最常见的故障以外的故障,你可以通过提交一个小例子的 bug 报告来帮助 B::Deparse 的持续发展。</target>
        </trans-unit>
        <trans-unit id="1fb4e05a5830c846a9dc5981bceec998799ac3ed" translate="yes" xml:space="preserve">
          <source>While BigInt has extensive handling of inf and NaN, certain quirks remain.</source>
          <target state="translated">虽然BigInt对inf和NaN有广泛的处理,但仍然存在某些怪癖。</target>
        </trans-unit>
        <trans-unit id="fd702ed1f93515e973caeb556144e84284909d1e" translate="yes" xml:space="preserve">
          <source>While C guarantees the ordering specified in the struct definition, between different platforms the definitions might differ</source>
          <target state="translated">虽然C语言保证了结构定义中指定的排序,但不同平台之间的定义可能有所不同</target>
        </trans-unit>
        <trans-unit id="cc4691f27fe5f793a7b1a252b87e1f8adf7ae71b" translate="yes" xml:space="preserve">
          <source>While Dan Kogai retains the copyright as a maintainer, credit should go to all those involved. See AUTHORS for a list of those who submitted code to the project.</source>
          <target state="translated">虽然Dan Kogai作为维护者保留了版权,但所有参与的人都应该得到荣誉。请参阅AUTHORS以了解提交项目代码的人员名单。</target>
        </trans-unit>
        <trans-unit id="5c4e91143f9c9ac2ab71808110a8709426a9bc1f" translate="yes" xml:space="preserve">
          <source>While Google doesn't provide a native toolchain for Android, you can still get one from the Play Store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a13f1442da82f36b90f68d9debc0cec8f1fff2" translate="yes" xml:space="preserve">
          <source>While Math::BigInt has extensive handling of inf and NaN, certain quirks remain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e79628255662d7502ebd0e9fa4c3c1aca53d77c4" translate="yes" xml:space="preserve">
          <source>While Perl attempts to keep the vaxc$errno value to be current, if errno is not EVMSERR, it may not be from the current operation.</source>
          <target state="translated">当Perl试图保持vaxc$errno的值为当前值时,如果errno不是EVMSERR,它可能不是来自当前的操作。</target>
        </trans-unit>
        <trans-unit id="82ff355555ab6d2ce0a2840754c6edfffe9b0329" translate="yes" xml:space="preserve">
          <source>While Perl passes arguments to functions by reference, C passes arguments by value; to implement a C function which modifies data of one of the &quot;arguments&quot;, the actual argument of this C function would be a pointer to the data. Thus two C functions with declarations</source>
          <target state="translated">Perl通过引用向函数传递参数,而C语言则通过值传递参数;要实现一个修改其中一个 &quot;参数 &quot;数据的C函数,这个C函数的实际参数将是一个指向数据的指针。因此,两个C函数的声明是</target>
        </trans-unit>
        <trans-unit id="c23f9c83568988309005d4ebe9f3a7a4c7b974ed" translate="yes" xml:space="preserve">
          <source>While System V IPC isn't so widely used as sockets, it still has some interesting uses. However, you cannot use SysV IPC or Berkeley mmap() to have a variable shared amongst several processes. That's because Perl would reallocate your string when you weren't wanting it to. You might look into the &lt;code&gt;IPC::Shareable&lt;/code&gt; or &lt;code&gt;threads::shared&lt;/code&gt; modules for that.</source>
          <target state="translated">尽管System V IPC并未像套接字那样被广泛使用，但它仍有一些有趣的用途。但是，您不能使用SysV IPC或Berkeley mmap（）在多个进程之间共享变量。那是因为Perl会在您不想要的时候重新分配您的字符串。您可以考虑使用 &lt;code&gt;IPC::Shareable&lt;/code&gt; 或 &lt;code&gt;threads::shared&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="95ba383e6ad59d1d5877dab883127e0598dee045" translate="yes" xml:space="preserve">
          <source>While a nice extension, it's not portable. The Perl code does admittedly use them if available to gain some extra speed (essentially as a funky form of inlining), but you shouldn't.</source>
          <target state="translated">虽然是个不错的扩展,但它并不便携。Perl 代码确实会在可用的情况下使用它们来获得一些额外的速度(本质上是一种时髦的内联形式),但你不应该这样做。</target>
        </trans-unit>
        <trans-unit id="98ac33662fa3d3f638b9cfcc69effe66a6af5d40" translate="yes" xml:space="preserve">
          <source>While a search is in progress, the progress object's &lt;code&gt;reach&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; methods are called like this:</source>
          <target state="translated">在搜索过程中，进度对象的 &lt;code&gt;reach&lt;/code&gt; 和 &lt;code&gt;done&lt;/code&gt; 方法按如下方式调用：</target>
        </trans-unit>
        <trans-unit id="5af2731519a4e72226e3efaa5ed68cb8f21ac8fa" translate="yes" xml:space="preserve">
          <source>While apparently a whole nuther program,</source>
          <target state="translated">虽然显然是一个全新的程序。</target>
        </trans-unit>
        <trans-unit id="2192d44f9e946df5ee1f8628bb7cf84591b693e7" translate="yes" xml:space="preserve">
          <source>While building Perl some changes may be necessary to your Cygwin setup so that Perl builds cleanly. These changes are &lt;b&gt;not&lt;/b&gt; required for normal Perl usage.</source>
          <target state="translated">在构建Perl时，您的Cygwin设置可能需要进行一些更改，以便Perl能够干净地构建。这些变化&lt;b&gt;并不&lt;/b&gt;需要正常的Perl使用。</target>
        </trans-unit>
        <trans-unit id="917e67f81e56107e856d601af96f9ace961e9a9a" translate="yes" xml:space="preserve">
          <source>While checking, this module collects document properties, e.g. the nodes for hyperlinks (&lt;code&gt;=headX&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; ) and index entries (&lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ). POD translators can use this feature to syntax-check and get the nodes in a first pass before actually starting to convert. This is expensive in terms of execution time, but allows for very robust conversions.</source>
          <target state="translated">在检查时，此模块收集文档属性，例如，超链接（ &lt;code&gt;=headX&lt;/code&gt; ， &lt;code&gt;=item&lt;/code&gt; ）和索引条目（ &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ）的节点。POD转换程序可以使用此功能进行语法检查并在实际开始转换之前的第一遍中获取节点。就执行时间而言，这是昂贵的，但是允许非常可靠的转换。</target>
        </trans-unit>
        <trans-unit id="0b363ec28aa87cd5d2d84a791b40d48ed17d175f" translate="yes" xml:space="preserve">
          <source>While checking, this module collects document properties, e.g. the nodes for hyperlinks (&lt;code&gt;=headX&lt;/code&gt;, &lt;code&gt;=item&lt;/code&gt;) and index entries (&lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt;). POD translators can use this feature to syntax-check and get the nodes in a first pass before actually starting to convert. This is expensive in terms of execution time, but allows for very robust conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba738010d28065fd95a055094f45e1d958083828" translate="yes" xml:space="preserve">
          <source>While civility is required, kindness is encouraged; if you have any doubt about whether you are being civil, simply ask yourself, &quot;Am I being kind?&quot; and aspire to that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c337ad00b019970748effb87047bdf42ffb16bea" translate="yes" xml:space="preserve">
          <source>While experts may argue about these idioms, a novice to Perl guts may prefer a way which is as little Perl-guts-specific as possible, meaning automatic conversion and automatic call generation, as in &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;&quot;Getting the fat out of XSUBs&quot;&lt;/a&gt;. This approach has the additional benefit of protecting the XSUB writer from future changes to the Perl API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6234d5fa2f6fac6ddbcf991bea921371b64250cc" translate="yes" xml:space="preserve">
          <source>While experts may argue about these idioms, a novice to Perl guts may prefer a way which is as little Perl-guts-specific as possible, meaning automatic conversion and automatic call generation, as in &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt;. This approach has the additional benefit of protecting the XSUB writer from future changes to the Perl API.</source>
          <target state="translated">尽管专家可能会争论这些习惯用法，但是Perl胆量的新手可能更喜欢一种Perl胆量特定的方式，这意味着自动转换和自动调用生成，就像&lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;从XSUBs中脱颖而出&lt;/a&gt;。这种方法的另一个好处是可以保护XSUB编写器免受将来对Perl API的更改。</target>
        </trans-unit>
        <trans-unit id="601070e02f682375d5e25990b39de3389f3b8c49" translate="yes" xml:space="preserve">
          <source>While in principle the &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; operator could be implemented via (and with the same rather severe limitations as) the CRTL &lt;code&gt;vfork()&lt;/code&gt; routine, and while some internal support to do just that is in place, the implementation has never been completed, making &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; currently unavailable. A true kernel &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; is expected in a future version of VMS, and the pseudo-fork based on interpreter threads may be available in a future version of Perl on VMS (see &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;). In the meantime, use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, backticks, or piped filehandles to create subprocesses.</source>
          <target state="translated">虽然原则上可以通过CRTL &lt;code&gt;vfork()&lt;/code&gt; 例程（并具有与之相同的相当严格的限制）来实现 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 运算符，并且尽管已有一些内部支持来实现此目的，但该实现尚未完成，使得 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 目前不可用。期望在VMS的未来版本中使用真正的 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 内核，并且在VMS的Perl的未来版本中可以使用基于解释器线程的伪叉（请参见&lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;）。同时，使用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ，反引号或管道文件句柄创建子进程。</target>
        </trans-unit>
        <trans-unit id="99369babd08034c16995edf0279e157f7f0775da" translate="yes" xml:space="preserve">
          <source>While in principle the &lt;code&gt;fork&lt;/code&gt; operator could be implemented via (and with the same rather severe limitations as) the CRTL &lt;code&gt;vfork()&lt;/code&gt; routine, and while some internal support to do just that is in place, the implementation has never been completed, making &lt;code&gt;fork&lt;/code&gt; currently unavailable. A true kernel &lt;code&gt;fork()&lt;/code&gt; is expected in a future version of VMS, and the pseudo-fork based on interpreter threads may be available in a future version of Perl on VMS (see &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;). In the meantime, use &lt;code&gt;system&lt;/code&gt;, backticks, or piped filehandles to create subprocesses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a11b15d87bb1f9501075e6254f16292a57b123f0" translate="yes" xml:space="preserve">
          <source>While in this mode, Perl takes special precautions called</source>
          <target state="translated">在这种模式下,Perl会采取特殊的预防措施,称为</target>
        </trans-unit>
        <trans-unit id="177c27cbc619ded10f5ed086056984752bc53bbb" translate="yes" xml:space="preserve">
          <source>While it is common to see these two macros in pairs within an &lt;code&gt;ENTER&lt;/code&gt;/ &lt;code&gt;LEAVE&lt;/code&gt; pair, it is not necessary to match them. It is permitted to invoke &lt;code&gt;FREETMPS&lt;/code&gt; multiple times since the most recent &lt;code&gt;SAVETMPS&lt;/code&gt;; for example in a loop iterating over elements of a list. While you can invoke &lt;code&gt;SAVETMPS&lt;/code&gt; multiple times within a scope pair, it is unlikely to be useful. Subsequent invocations will move the temporaries floor further up, thus effectively trapping the existing temporaries to only be released at the end of the scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c260f0d64ec7ed3061fae8a4547b586a55f37c5" translate="yes" xml:space="preserve">
          <source>While it is permissible to &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; a FileCache managed file, do not do so if you are calling &lt;code&gt;FileCache::cacheout&lt;/code&gt; from a package other than which it was imported, or with another module which overrides &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;. If you must, use &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; .</source>
          <target state="translated">虽然可以 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; FileCache托管文件，但是如果您从导入的包之外的包或另一个覆盖 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 的模块中调用 &lt;code&gt;FileCache::cacheout&lt;/code&gt; ，则不要这样做。如果必须，请使用 &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b707b74369a586a0cf2d7bbc0374b51314db5a7" translate="yes" xml:space="preserve">
          <source>While it is permissible to &lt;code&gt;close&lt;/code&gt; a FileCache managed file, do not do so if you are calling &lt;code&gt;FileCache::cacheout&lt;/code&gt; from a package other than which it was imported, or with another module which overrides &lt;code&gt;close&lt;/code&gt;. If you must, use &lt;code&gt;FileCache::cacheout_close&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a78b4c64649b65dd4cad30d6943b6a01e662f0" translate="yes" xml:space="preserve">
          <source>While it would be nice to make this the default behavior, that would almost certainly break a lot of code, so you must explicitly import these subs and use them instead of the default &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="959732eaecdd2fded6d5f4730815e7ecfbb3c6a3" translate="yes" xml:space="preserve">
          <source>While it's not necessary for documentation changes, new tests or trivial patches, it's often worth explaining how your change works. Even if it's clear to you today, it may not be clear to a porter next month or next year.</source>
          <target state="translated">虽然对于文档变更、新的测试或琐碎的补丁来说没有必要,但通常值得解释一下你的变更是如何工作的。即使你今天很清楚,但下个月或明年的搬运工可能就不清楚了。</target>
        </trans-unit>
        <trans-unit id="44568ef65eee77bd20a0348b5e9b725eb8d8f779" translate="yes" xml:space="preserve">
          <source>While it's possible to refer directly to these hash keys outside of the class, it's considered a best practice to wrap all access to the attribute with accessor methods.</source>
          <target state="translated">虽然可以在类外直接引用这些哈希键,但最好的做法是将所有对属性的访问都用访问器方法包起来。</target>
        </trans-unit>
        <trans-unit id="d0849418f5c8269f5aff84704c4d9acb674dcdcc" translate="yes" xml:space="preserve">
          <source>While it's true that Perl's regular expressions resemble the DFAs (deterministic finite automata) of the egrep(1) program, they are in fact implemented as NFAs (non-deterministic finite automata) to allow backtracking and backreferencing. And they aren't POSIX-style either, because those guarantee worst-case behavior for all cases. (It seems that some people prefer guarantees of consistency, even when what's guaranteed is slowness.) See the book &quot;Mastering Regular Expressions&quot; (from O'Reilly) by Jeffrey Friedl for all the details you could ever hope to know on these matters (a full citation appears in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;).</source>
          <target state="translated">虽然Perl的正则表达式确实确实类似于egrep（1）程序的DFA（确定性有限自动机），但实际上它们已实现为NFA（非确定性有限自动机）以允许回溯和反向引用。而且它们也不是POSIX风格的，因为它们保证了所有情况下的最坏情况。 （似乎有些人更喜欢一致性的保证，即使保证的是缓慢性。）请参阅Jeffrey Friedl的书&amp;ldquo; Mastering Regular Expressions&amp;rdquo;（来自O'Reilly），以获取您希望在这些问题上知道的所有详细信息（完整的引文出现在&lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2中&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3329779b59b299850e8b68832610b0b339dc0b1f" translate="yes" xml:space="preserve">
          <source>While it's true that this documentation is somewhat subserious, if you use a program named</source>
          <target state="translated">虽然这个文档确实有些子虚乌有,但如果你使用一个名为</target>
        </trans-unit>
        <trans-unit id="10a36fcf99a8e338089d469f203ab0168ce94e49" translate="yes" xml:space="preserve">
          <source>While literal lists and named arrays are often interchangeable, that's not the case for hashes. Just because you can subscript a list value like a normal array does not mean that you can subscript a list value as a hash. Likewise, hashes included as parts of other lists (including parameters lists and return lists from functions) always flatten out into key/value pairs. That's why it's good to use references sometimes.</source>
          <target state="translated">虽然字面列表和命名数组通常是可以互换的,但哈希的情况并非如此。仅仅因为你可以像普通数组一样下标一个列表值,并不意味着你可以将一个列表值下标为哈希。同样,作为其他列表(包括参数列表和函数的返回列表)的一部分的哈希值总是扁平化为键/值对。这就是为什么有时使用引用是好的。</target>
        </trans-unit>
        <trans-unit id="eca6e56d146060aa14a3a670fa7ed2185164c9b5" translate="yes" xml:space="preserve">
          <source>While most important values in this file</source>
          <target state="translated">虽然这个文件中最重要的值</target>
        </trans-unit>
        <trans-unit id="8f9b053b8a7e4dedb3bcc2addb9bbd5ef56b5365" translate="yes" xml:space="preserve">
          <source>While no_index tells you what must be ignored when indexing, this spec holds no opinion on how you should get your initial candidate list of things to possibly index. For &quot;normal&quot; distributions you might consider simply indexing the contents of lib/, but there are many fascinating oddities on CPAN and many dists from the days when it was normal to put the main .pm file in the root of the distribution archive - so PAUSE currently indexes all .pm and .PL files that are not either (a) specifically excluded by no_index (b) in &lt;code&gt;inc&lt;/code&gt;, &lt;code&gt;xt&lt;/code&gt;, or &lt;code&gt;t&lt;/code&gt; directories, or common 'mistake' directories such as &lt;code&gt;perl5&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393059c305b4f9157627b86935072088d84089d3" translate="yes" xml:space="preserve">
          <source>While none of the built-in data types have any arbitrary size limits (apart from memory size), there are still a few arbitrary limits: a given variable name may not be longer than 251 characters. Line numbers displayed by diagnostics are internally stored as short integers, so they are limited to a maximum of 65535 (higher numbers usually being affected by wraparound).</source>
          <target state="translated">虽然内置的数据类型都没有任意的大小限制(除了内存大小),但还是有一些任意的限制:一个给定的变量名不能超过251个字符。诊断程序显示的行号在内部存储为短整数,所以它们的最大限制是65535(更高的数字通常会受到环绕的影响)。</target>
        </trans-unit>
        <trans-unit id="b09324869be41d3f63ee219787db6a6f9e7b0b52" translate="yes" xml:space="preserve">
          <source>While not currently implemented, it is possible that in the future this function will convert only parts of the path to FILENAME to a short form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f300b76b4f41dcdc512a5b3661d8c1aa39ba74e" translate="yes" xml:space="preserve">
          <source>While not entirely limited to Unix-derived operating systems (e.g., WinSock on PCs provides socket support, as do some VMS libraries), you might not have sockets on your system, in which case this section probably isn't going to do you much good. With sockets, you can do both virtual circuits like TCP streams and datagrams like UDP packets. You may be able to do even more depending on your system.</source>
          <target state="translated">虽然并不完全局限于Unix衍生的操作系统(例如,PC上的WinSock提供了套接字支持,一些VMS库也提供了支持),但你的系统上可能没有套接字,在这种情况下,本节可能对你没有什么好处。有了套接字,你既可以做像TCP流这样的虚拟电路,也可以做像UDP包这样的数据报。根据你的系统,你可能可以做得更多。</target>
        </trans-unit>
        <trans-unit id="6ad3cf3a478c4f24fb9ef9675cf14d8e5c5a06f1" translate="yes" xml:space="preserve">
          <source>While running Configure and when building, you are likely to get quite a few of these warnings:</source>
          <target state="translated">在运行Configure和构建时,你很可能会收到不少这样的警告。</target>
        </trans-unit>
        <trans-unit id="9b58fa2736239282292bc4dda51122cd95ae2910" translate="yes" xml:space="preserve">
          <source>While short identifiers like &lt;code&gt;$gotit&lt;/code&gt; are probably ok, use underscores to separate words in longer identifiers. It is generally easier to read &lt;code&gt;$var_names_like_this&lt;/code&gt; than &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; , especially for non-native speakers of English. It's also a simple rule that works consistently with &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; .</source>
          <target state="translated">虽然像 &lt;code&gt;$gotit&lt;/code&gt; 这样的短标识符可能没问题，但请使用下划线将较长标识符中的单词分开。通常， &lt;code&gt;$var_names_like_this&lt;/code&gt; 比 &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; 更容易阅读，尤其是对于非英语母语的人。这也是一条与 &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; 一致的简单规则。</target>
        </trans-unit>
        <trans-unit id="3d9fa3ada3b6c731a34ad67160b19f8a88213b51" translate="yes" xml:space="preserve">
          <source>While short identifiers like &lt;code&gt;$gotit&lt;/code&gt; are probably ok, use underscores to separate words in longer identifiers. It is generally easier to read &lt;code&gt;$var_names_like_this&lt;/code&gt; than &lt;code&gt;$VarNamesLikeThis&lt;/code&gt;, especially for non-native speakers of English. It's also a simple rule that works consistently with &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3268e08a1d3bd058ed6f797f7794fd47fc37b4" translate="yes" xml:space="preserve">
          <source>While some developers find fatalizing some warnings to be a useful defensive programming technique, using &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; to fatalize all possible warning categories -- including custom ones -- is particularly risky. Therefore, the use of &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; is &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;.</source>
          <target state="translated">尽管有些开发人员发现致命警告某些警告是一种有用的防御性编程技术，但使用 &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; 来致命警告所有可能的警告类别（包括自定义警告）特别危险。因此，使用的 &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; 被&lt;a href=&quot;perlpolicy#discouraged&quot;&gt;气馁&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f10f744968048551bad6ee098cf44a11a372745" translate="yes" xml:space="preserve">
          <source>While still in that directory, type:</source>
          <target state="translated">当仍在该目录中时,输入:</target>
        </trans-unit>
        <trans-unit id="42ffebb3bbe4e65d94b8f907df7dc389a8053ee0" translate="yes" xml:space="preserve">
          <source>While the GNU project includes Perl in its distributions, there's no such thing as &quot;GNU Perl&quot;. Perl is not produced nor maintained by the Free Software Foundation. Perl's licensing terms are also more open than GNU software's tend to be.</source>
          <target state="translated">虽然GNU项目在其发行版中包含了Perl,但并不存在 &quot;GNU Perl &quot;这样的东西。Perl 不是由自由软件基金会制作或维护的。Perl的许可条款也比GNU软件更开放。</target>
        </trans-unit>
        <trans-unit id="84896ae82951e28a26020293e6f0af332fef1cca" translate="yes" xml:space="preserve">
          <source>While the Unicode Standard defines two additional forms of casefolding, one for Turkic languages and one that never maps one character into multiple characters, these are not provided by the Perl core. However, the CPAN module &lt;a href=&quot;Unicode::Casing&quot;&gt;&lt;code&gt;Unicode::Casing&lt;/code&gt;&lt;/a&gt; may be used to provide an implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb3c100d2dfc2d28078ac3b93ee7e431111c075" translate="yes" xml:space="preserve">
          <source>While the Unicode Standard defines two additional forms of casefolding, one for Turkic languages and one that never maps one character into multiple characters, these are not provided by the Perl core; However, the CPAN module &lt;code&gt;Unicode::Casing&lt;/code&gt; may be used to provide an implementation.</source>
          <target state="translated">虽然Unicode标准定义了两种附加的大小写折叠形式，一种用于突厥语，另一种从未将一个字符映射成多个字符，但Perl内核没有提供这些形式。但是，CPAN模块 &lt;code&gt;Unicode::Casing&lt;/code&gt; 可用于提供实现。</target>
        </trans-unit>
        <trans-unit id="761ba2f6d0a7dac9fb4c5d145960b451d6d26420" translate="yes" xml:space="preserve">
          <source>While the key must be a string value (since that's a basic restriction that Perl places on hash keys), the value in the lexicon can currently be of several types: a defined scalar, scalarref, or coderef. The use of these is explained above, in the section 'The &quot;maketext&quot; Method', and Bracket Notation for strings is discussed in the next section.</source>
          <target state="translated">虽然键必须是字符串值(因为这是Perl对哈希键的基本限制),但目前词库中的值可以有几种类型:定义的标量、标量ref或coderef。这些的使用在上面的 &quot;maketext &quot;方法 &quot;一节中进行了说明,下一节将讨论字符串的括号符号。</target>
        </trans-unit>
        <trans-unit id="d08b05105bcedd2fb07dc0399888e4c9d241f3f1" translate="yes" xml:space="preserve">
          <source>While the list of arguments might work fine for one, two or even three arguments, any more arguments become hard for the module user to remember, and hard for the module author to manage. If you want to add a new parameter you will have to add it to the end of the list for backward compatibility, and this will probably make your list order unintuitive. Also, if many elements may be undefined you may see the following unattractive method calls:</source>
          <target state="translated">虽然参数列表对于一个、两个甚至三个参数来说可能很好用,但任何更多的参数对于模块用户来说都会变得很难记住,对于模块作者来说也很难管理。如果你想添加一个新的参数,为了向后兼容,你必须把它添加到列表的最后,这可能会使你的列表顺序变得不直观。另外,如果很多元素可能是未定义的,你可能会看到以下不好看的方法调用。</target>
        </trans-unit>
        <trans-unit id="019950bbf16db8b6543648ebb335d2eaf049366f" translate="yes" xml:space="preserve">
          <source>While the mapping &quot;infin&quot; to the character &quot;\x{221E}&quot; will (hopefully) have been already handled by the Pod parser, the presence of the character in this file means that it's reasonably important enough to include in a formatter's table that maps from notable Unicode characters to the codes necessary for rendering them. So for a Unicode-to-*roff mapping, for example, this would merit the entry:</source>
          <target state="translated">虽然 &quot;infin &quot;到字符&quot;\x{221E}&quot;的映射(希望)已经被Pod解析器处理过了,但这个文件中出现的字符意味着它足够重要,可以被包含在一个表格中,从著名的Unicode字符映射到渲染它们所需的代码。因此,对于Unicode-to-*roff映射,例如,这将是值得的条目。</target>
        </trans-unit>
        <trans-unit id="549c813f59b3276935336cbd28f55b4770622941" translate="yes" xml:space="preserve">
          <source>While the two classes may differ in many ways, when it comes to the &lt;code&gt;print_content()&lt;/code&gt; method, they are the same. This means that we can try to call the &lt;code&gt;print_content()&lt;/code&gt; method on an object of either class, and &lt;b&gt;we don't have to know what class the object belongs to!&lt;/b&gt;</source>
          <target state="translated">尽管这两个类在许多方面可能有所不同，但是当涉及到 &lt;code&gt;print_content()&lt;/code&gt; 方法时，它们是相同的。这意味着我们可以尝试在任一类的对象上调用 &lt;code&gt;print_content()&lt;/code&gt; 方法，而&lt;b&gt;不必知道该对象属于哪个类！&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="76ea82c5269a1424cf449fcf0bff6de44af4f6d8" translate="yes" xml:space="preserve">
          <source>While the word combination &lt;code&gt;character set&lt;/code&gt; has lost this meaning in MIME context since [RFC 2130], the &lt;code&gt;charset&lt;/code&gt; abbreviation has retained it. This is how [RFC 2277] and [RFC 2278] bless &lt;code&gt;charset&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b178eba62086e85a4d0b937f4f56029a87c5eae0" translate="yes" xml:space="preserve">
          <source>While there are Pod codes E&amp;lt;...&amp;gt; and Z&amp;lt;&amp;gt;, these</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f8c54acc4d9406822b250e87f501917fa0a683" translate="yes" xml:space="preserve">
          <source>While there are currently no architecture-specific extensions or modules distributed with perl, the following directories can be used to hold such files (replace the string VERSION by the appropriate version number):</source>
          <target state="translated">虽然目前还没有与perl一起发布的特定架构的扩展或模块,但以下目录可以用来存放这些文件(用适当的版本号替换字符串VERSION)。</target>
        </trans-unit>
        <trans-unit id="0c8516dbb58fd38e067d471797d458e282eb5b87" translate="yes" xml:space="preserve">
          <source>While these operations are not questions of life and death, they are needed for a lot of useful scripts. This forces &lt;code&gt;a.out&lt;/code&gt; -style compile of</source>
          <target state="translated">尽管这些操作不是生死攸关的问题，但许多有用的脚本需要它们。这迫使 &lt;code&gt;a.out&lt;/code&gt; 风格的编译</target>
        </trans-unit>
        <trans-unit id="3d2455a51c401e0d0b17f4da15388c28c0528ee2" translate="yes" xml:space="preserve">
          <source>While these operations are not questions of life and death, they are needed for a lot of useful scripts. This forces &lt;code&gt;a.out&lt;/code&gt;-style compile of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1849a634e96a61e2b3cdef3b11aa962d9aad4c39" translate="yes" xml:space="preserve">
          <source>While this actually can be done, it's much harder than you'd think. For example, this one-liner</source>
          <target state="translated">虽然这其实是可以做到的,但比你想象的要难得多。例如,这个单行本</target>
        </trans-unit>
        <trans-unit id="c8b72cb61463146c67f31be1d892fe7495f6bd9f" translate="yes" xml:space="preserve">
          <source>While this allows some (significant?) performance advantages, this makes life much harder for developers, since the above scheme makes it impossible for a DLL to be &quot;linked&quot; to a symbol in the</source>
          <target state="translated">虽然这允许一些(显著的?)性能优势,但这给开发人员的生活带来了很大的困难,因为上述方案使得DLL不可能与</target>
        </trans-unit>
        <trans-unit id="5a4ded2cb5289b97c3775e062e86790bf5432277" translate="yes" xml:space="preserve">
          <source>While this class is currently implemented using the Class::Struct module to build a struct-like class, you shouldn't rely upon this.</source>
          <target state="translated">虽然这个类目前是用Class::Struct模块来实现的,以建立一个类似结构体的类,但你不应该依赖这个。</target>
        </trans-unit>
        <trans-unit id="e68b146940f9324cc2fc3ad49971a5aa379db2a9" translate="yes" xml:space="preserve">
          <source>While this compiles and runs happily, it probably won't do what's expected, namely it doesn't print &quot;Hello World\n&quot; at all; It will on the other hand do exactly what it was told to do, computers being a bit that way inclined. That is, it will print out a newline character, and you'll get what looks like a blank line. It looks like there's 2 variables when (because of the typo) there's really 3:</source>
          <target state="translated">虽然这个编译和运行得很愉快,但它可能不会做预期的事情,即它根本不会打印 &quot;Hello World\n&quot;;另一方面,它将完全按照它被告知的那样去做,因为计算机有点倾向于这样。也就是说,它会打印出一个换行符,而你会得到一个看起来像空行的东西。它看起来像有两个变量,而(因为打错了)实际上有三个。</target>
        </trans-unit>
        <trans-unit id="b959fa7d0d0730d45d9d80c8527dc6a6d9341163" translate="yes" xml:space="preserve">
          <source>While this currently exists in all three implementations perl itself does not use it.</source>
          <target state="translated">虽然目前所有三个实现中都有这个功能,但perl本身并没有使用它。</target>
        </trans-unit>
        <trans-unit id="386467fc98e2754e0e58a98e1b2d3e8dc8fa8075" translate="yes" xml:space="preserve">
          <source>While this currently exists in both implementations, perl itself does not use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f084942a5c159bd226784a38fd066229baa22988" translate="yes" xml:space="preserve">
          <source>While this document is intended to be useful to all module authors, it is particularly aimed at authors who wish to publish their modules on CPAN.</source>
          <target state="translated">虽然本文件旨在对所有模块作者有用,但它特别针对那些希望在CPAN上发布模块的作者。</target>
        </trans-unit>
        <trans-unit id="66c1c2ee830cc759765d36b85a240cf7d1bab82e" translate="yes" xml:space="preserve">
          <source>While this feature is most commonly used to explicitly call methods inherited from an ancestor class, there is no technical restriction that enforces this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1785d6466e3128c272757d8a3931f08ab9e01f53" translate="yes" xml:space="preserve">
          <source>While this is legal practice, it is certainly dubious, and downright fatal in at least one platform: for example VMS cc considers this a fatal error. One cause for people often making this mistake is that a &quot;naked char&quot; and therefore dereferencing a &quot;naked char pointer&quot; have an undefined signedness: it depends on the compiler and the flags of the compiler and the underlying platform whether the result is signed or unsigned. For this very same reason using a 'char' as an array index is bad.</source>
          <target state="translated">虽然这是合法的做法,但它肯定是可疑的,至少在一个平台上是致命的:例如VMS cc认为这是一个致命的错误。人们经常犯这种错误的一个原因是,一个 &quot;裸体char &quot;以及因此而派生的 &quot;裸体char指针 &quot;具有未定义的签名性:结果是有签名还是无签名取决于编译器和底层平台的标志。出于同样的原因,使用 &quot;char &quot;作为数组索引是不好的。</target>
        </trans-unit>
        <trans-unit id="40200d6701039334e5e5bffbb6cca8ab91bc30ff" translate="yes" xml:space="preserve">
          <source>While this is true on the surface, it's much more efficient to process the file one line or record at a time because then you don't have to read the whole thing into memory at once. It also gives you finer control of the whole process, letting you kill off the child process early if you'd like.</source>
          <target state="translated">虽然表面上看是这样,但一次只处理一行或一条记录的文件效率要高得多,因为这样你就不必一次把整个文件读到内存中。它还能让你更精细地控制整个过程,如果你愿意,可以让你提前杀掉子进程。</target>
        </trans-unit>
        <trans-unit id="9790d6e959def47c7e50e558f607fe7ba4374a90" translate="yes" xml:space="preserve">
          <source>While this might be too cumbersome to implement in event-based Pod parsers, it is straightforward for parsers that return parse trees.</source>
          <target state="translated">虽然在基于事件的Pod解析器中实现这一点可能会过于繁琐,但对于返回解析树的解析器来说,它是直接的。</target>
        </trans-unit>
        <trans-unit id="81aa0dd02571c7973cd68f4d9f805b1c67ff2c9c" translate="yes" xml:space="preserve">
          <source>While this might by accident work in some platform (where IV happens to be an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;), in general it cannot. IV might be something larger. Even worse the situation is with more specific types (defined by Perl's configuration step in</source>
          <target state="translated">尽管这可能是偶然地在某些平台（IV恰好是 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; ）上工作的，但通常不能。IV可能更大。更糟糕的情况是使用更特定的类型（由Perl的配置步骤定义）</target>
        </trans-unit>
        <trans-unit id="7f1683bf56a3090bff1bb086f826f7e09370112c" translate="yes" xml:space="preserve">
          <source>While this might by accident work in some platform (where IV happens to be an &lt;code&gt;int&lt;/code&gt;), in general it cannot. IV might be something larger. Even worse the situation is with more specific types (defined by Perl's configuration step in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82be9c7a2de102e2677bf88ba7443091644097cd" translate="yes" xml:space="preserve">
          <source>While this works reasonably well for unidirectional communication, what about bidirectional communication? The most obvious approach doesn't work:</source>
          <target state="translated">虽然这对于单向通信来说效果还算不错,但双向通信呢?最显而易见的方法是行不通的。</target>
        </trans-unit>
        <trans-unit id="26ea84a69e787188d7dfd7dc7bac4a8b95950ee8" translate="yes" xml:space="preserve">
          <source>While threads bring a new set of useful tools, they also bring a number of pitfalls. One pitfall is the race condition:</source>
          <target state="translated">虽然线程带来了一系列新的有用工具,但它们也带来了一些陷阱。其中一个陷阱就是竞赛条件。</target>
        </trans-unit>
        <trans-unit id="0369ef7f3a86c9ade18a8f113608ef11b27c9fcb" translate="yes" xml:space="preserve">
          <source>While thumbing through the &lt;a href=&quot;Date::ICal&quot;&gt;Date::ICal&lt;/a&gt; man page, I came across this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb55e176d75bb6afa2c9779e5d12c3767454404" translate="yes" xml:space="preserve">
          <source>While trying to read from his caller-id box, the notorious Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; , after much gnashing of teeth and fighting with &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, POSIX's &lt;code&gt;tcgetattr&lt;/code&gt; business, and various other functions that go bump in the night, finally came up with this:</source>
          <target state="translated">当试图从他的来电显示框中读取内容时，臭名昭著的Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; 咬牙切齿地与 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; ，POSIX的 &lt;code&gt;tcgetattr&lt;/code&gt; 业务以及各种其他功能在晚上碰到了一样，终于想到了这个：</target>
        </trans-unit>
        <trans-unit id="3d9a29cb2e71d84a90b207c5a091106e69ab3f88" translate="yes" xml:space="preserve">
          <source>While trying to read from his caller-id box, the notorious Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt;, after much gnashing of teeth and fighting with &lt;code&gt;sysread&lt;/code&gt;, &lt;code&gt;sysopen&lt;/code&gt;, POSIX's &lt;code&gt;tcgetattr&lt;/code&gt; business, and various other functions that go bump in the night, finally came up with this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d7592c228741a449aa83d6358c7b5dbac2c422e" translate="yes" xml:space="preserve">
          <source>While trying to resolve method call %s-&amp;gt;%s() can not locate package &quot;%s&quot; yet it is mentioned in @%s::ISA (perhaps you forgot to load &quot;%s&quot;?)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ffa8b7afc028fdbcdab4b6dea3d1eb48e0f55ad" translate="yes" xml:space="preserve">
          <source>While using the standard</source>
          <target state="translated">当使用标准的</target>
        </trans-unit>
        <trans-unit id="c059f6308f685a568f9b74b626f917b18a45a114" translate="yes" xml:space="preserve">
          <source>While version objects overload stringification, to portably convert &lt;code&gt;$^V&lt;/code&gt; into its string representation, use &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; conversion, which works for both v-strings or version objects:</source>
          <target state="translated">当版本对象超载字符串化时，为了将 &lt;code&gt;$^V&lt;/code&gt; 转换为字符串表示形式，请使用 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; 转换，该转换对v字符串或版本对象均适用：</target>
        </trans-unit>
        <trans-unit id="7e7742e29582b552f48253992f05bd5349646ba9" translate="yes" xml:space="preserve">
          <source>While version objects overload stringification, to portably convert &lt;code&gt;$^V&lt;/code&gt; into its string representation, use &lt;code&gt;sprintf()&lt;/code&gt;'s &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; conversion, which works for both v-strings or version objects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5995cddc89ffbbaa6e8a0013934033bfcd3e1f" translate="yes" xml:space="preserve">
          <source>While versions earlier than 5.8.1 had threads they contain too many bugs to support.</source>
          <target state="translated">虽然比5.8.1更早的版本有线程,但它们包含的bug太多,无法支持。</target>
        </trans-unit>
        <trans-unit id="daa9a857c615b0eef13a54df6fdfd26532388959" translate="yes" xml:space="preserve">
          <source>While we normally think of patterns as being delimited with &lt;code&gt;/&lt;/code&gt; characters, they can be delimited by almost any character. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; describes this. For example, the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; above uses braces as delimiters. Selecting another delimiter can avoid quoting the delimiter within the pattern:</source>
          <target state="translated">虽然我们通常认为模式用 &lt;code&gt;/&lt;/code&gt; 字符分隔，但几乎可以用任何字符分隔它们。&lt;a href=&quot;perlre&quot;&gt;perlre对此进行了&lt;/a&gt;描述。例如，上面的 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 使用花括号作为定界符。选择另一个定界符可以避免在模式中引用定界符：</target>
        </trans-unit>
        <trans-unit id="39f1ea1d3e2074839c9819aaf86819467fb5bb22" translate="yes" xml:space="preserve">
          <source>While we normally think of patterns as being delimited with &lt;code&gt;/&lt;/code&gt; characters, they can be delimited by almost any character. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; describes this. For example, the &lt;code&gt;s///&lt;/code&gt; above uses braces as delimiters. Selecting another delimiter can avoid quoting the delimiter within the pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09af51d2e240602d6d93896cb9f587c7a82f4e64" translate="yes" xml:space="preserve">
          <source>While we strongly suggest you don't build your objects from scratch, you should know the term &lt;b&gt;bless&lt;/b&gt;. A &lt;b&gt;blessed&lt;/b&gt; data structure (aka &quot;a referent&quot;) is an object. We sometimes say that an object has been &quot;blessed into a class&quot;.</source>
          <target state="translated">尽管我们强烈建议您不要从头开始构建对象，但是您应该知道术语&lt;b&gt;bless&lt;/b&gt;。受&lt;b&gt;祝福的&lt;/b&gt;数据结构（也称为&amp;ldquo;对象&amp;rdquo;）是一个对象。有时我们说一个对象已经&amp;ldquo;被祝福到一个类中&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="562c113d1f1007e0a6502247b3772bac3c2d33a2" translate="yes" xml:space="preserve">
          <source>While we usually think of quotes as literal values, in Perl they function as operators, providing various kinds of interpolating and pattern matching capabilities. Perl provides customary quote characters for these behaviors, but also provides a way for you to choose your quote character for any of them. In the following table, a &lt;code&gt;{}&lt;/code&gt; represents any pair of delimiters you choose.</source>
          <target state="translated">虽然我们通常将引号视为文字值，但在Perl中它们充当运算符，提供各种插值和模式匹配功能。Perl为这些行为提供了惯用的引号字符，但还为您提供了一种为其中任何一种选择引号字符的方法。在下表中， &lt;code&gt;{}&lt;/code&gt; 代表您选择的任何一对定界符。</target>
        </trans-unit>
        <trans-unit id="34200b2d58936bc37828d3e87d2eebbab2c0f898" translate="yes" xml:space="preserve">
          <source>While we're here, take a closer look at the '&lt;b&gt;x&lt;/b&gt;' command, it's really useful and will merrily dump out nested references, complete objects, partial objects - just about whatever you throw at it:</source>
          <target state="translated">当我们在这里时，请仔细看一下' &lt;b&gt;x&lt;/b&gt; '命令，它确实很有用，并且会愉快地转储嵌套引用，完整对象，部分对象-几乎与您抛出的内容一样：</target>
        </trans-unit>
        <trans-unit id="00e2fed4a06f99f6100461a2d8cbb333f4d09501" translate="yes" xml:space="preserve">
          <source>While you can mix double colons with singles quotes, the quotes must come after the colons: &lt;code&gt;$::::'foo&lt;/code&gt; and &lt;code&gt;$foo::'bar&lt;/code&gt; are legal, but &lt;code&gt;$::'::foo&lt;/code&gt; and &lt;code&gt;$foo'::bar&lt;/code&gt; are not.</source>
          <target state="translated">虽然可以将双冒号与单引号引起来，但引号必须在冒号后： &lt;code&gt;$::::'foo&lt;/code&gt; 和 &lt;code&gt;$foo::'bar&lt;/code&gt; 是合法的，但是 &lt;code&gt;$::'::foo&lt;/code&gt; 和 &lt;code&gt;$foo'::bar&lt;/code&gt; 不是。</target>
        </trans-unit>
        <trans-unit id="078d591b0ade8bcb579420345c7df7b2c236f00e" translate="yes" xml:space="preserve">
          <source>While you can use arbitrary unique IDs for lexicon keys (like &quot;_min_larger_max_error&quot;), it is often useful for if an entry's key is itself a valid value, like this example error message:</source>
          <target state="translated">虽然你可以为词库键使用任意的唯一ID(如&quot;_min_larger_max_error&quot;),但它通常对一个条目的键本身是一个有效的值很有用,就像这个错误信息的例子。</target>
        </trans-unit>
        <trans-unit id="59ac30a04c89545845f0a1e87ea492a8c9c597ff" translate="yes" xml:space="preserve">
          <source>While you're doing that, make really sure you haven't missed a module similar to the one you're about to write.</source>
          <target state="translated">当你这样做的时候,要确保你没有错过一个类似于你要写的模块。</target>
        </trans-unit>
        <trans-unit id="95a6dc4463afddf0b399fee2185874a12ea0df02" translate="yes" xml:space="preserve">
          <source>While:</source>
          <target state="translated">While:</target>
        </trans-unit>
        <trans-unit id="c6568ae799534002dc040ff86ba3511a9bd4bd58" translate="yes" xml:space="preserve">
          <source>Whilst control is in the library, an error condition occurs. You have previously set up a Perl callback to handle this situation, so it will get executed. Once the callback has finished, control will drop back to Perl again. Here is what the flow of control will be like in that situation</source>
          <target state="translated">当控件在库中时,发生了一个错误条件。你之前已经设置了一个Perl回调来处理这种情况,所以它将被执行。一旦回调完成,控制将再次回到Perl中。下面是在这种情况下的控制流程。</target>
        </trans-unit>
        <trans-unit id="80e9be96d98a6599b821f35e0fd1d6289ce559ee" translate="yes" xml:space="preserve">
          <source>White space, hyphens, and underscores ARE significant except for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="44c1e2cd5ccb90bd73774fc5e53e7773e341381c" translate="yes" xml:space="preserve">
          <source>Whitespace and IPC::Open3 / system()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82098c40334ef85fcca05587546e9cc28f23e2a9" translate="yes" xml:space="preserve">
          <source>Whitespace and IPC::Run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="974608074eb6dc3e2345e2aa4e42c412340d3d49" translate="yes" xml:space="preserve">
          <source>Whitespace and special characters in the filename argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b1deb6ad1643a6518bffe011e47a1bbf2cd01d" translate="yes" xml:space="preserve">
          <source>Whitespace does not delimit fileglobs.</source>
          <target state="translated">空格不对文件组进行定界。</target>
        </trans-unit>
        <trans-unit id="df7fa704cbceacef574fb86983159dfe4b06ae43" translate="yes" xml:space="preserve">
          <source>Whitespace in filenames is tolerated on most systems, but not all, and even on systems where it might be tolerated, some utilities might become confused by such whitespace.</source>
          <target state="translated">文件名中的空白在大多数系统中是可以被容忍的,但并非所有系统都可以,即使在可以容忍的系统中,一些实用程序也会被这种空白所迷惑。</target>
        </trans-unit>
        <trans-unit id="baf39f9fbe05bd8902b826d4b1716bd33c1e5022" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored.</source>
          <target state="translated">忽略空白处。</target>
        </trans-unit>
        <trans-unit id="5899e5ae54fc72cc82eec99924af8577c33c2cbc" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored. The alias value can be a single attribute or a space-separated list of attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09822d18c062da75d056f267dd113eb02444df2b" translate="yes" xml:space="preserve">
          <source>Whitespace is irrelevant:</source>
          <target state="translated">空格是无关紧要的。</target>
        </trans-unit>
        <trans-unit id="e6027b651e819925aa47dc4c27f8a2f557b14aae" translate="yes" xml:space="preserve">
          <source>Who Needs Complicated Data Structures?</source>
          <target state="translated">谁需要复杂的数据结构?</target>
        </trans-unit>
        <trans-unit id="ce404d98012c2a69e116523288638e2bddf0b8c2" translate="yes" xml:space="preserve">
          <source>Who supports Perl? Who develops it? Why is it free?</source>
          <target state="translated">谁支持Perl?谁在开发它?为什么它是免费的?</target>
        </trans-unit>
        <trans-unit id="6272068bf74683d289db3b55d0ea826c2bd453e3" translate="yes" xml:space="preserve">
          <source>Who wrote it (use AUTHORS for multiple people). It's a good idea to include your current e-mail address (or some e-mail address to which bug reports should be sent) or some other contact information so that users have a way of contacting you. Remember that program documentation tends to roam the wild for far longer than you expect and pick a contact method that's likely to last.</source>
          <target state="translated">谁写的 (如果是多人写的,就用AUTHORS)。最好包括你当前的电子邮件地址(或一些应该发送错误报告的电子邮件地址)或其他一些联系信息,这样用户就有办法与你联系。记住,程序文档在野外漫游的时间往往比你预想的要长得多,要选择一种可能持续的联系方法。</target>
        </trans-unit>
        <trans-unit id="cf619e0d870f5f00d0e62715b2fa9d9354bf3093" translate="yes" xml:space="preserve">
          <source>Whoops! Looks like it's unimplemented. Assume you don't have the time to fix this. [11] Normally, you'd just comment out the test and put a note in a todo list somewhere. Instead, explicitly state &quot;this test will fail&quot; by wrapping it in a &lt;code&gt;TODO&lt;/code&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4357002b49a216cedec63d85f662f9560e6c2af" translate="yes" xml:space="preserve">
          <source>Whoops! You just put a tab and a formfeed into that filename! Remember that within double quoted strings (&quot;like\this&quot;), the backslash is an escape character. The full list of these is in &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;&quot;Quote and Quote-like Operators&quot; in perlop&lt;/a&gt;. Unsurprisingly, you don't have a file called &quot;c:(tab)emp(formfeed)oo&quot; or &quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy DOS filesystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22ef207f555182408b6d1958c0f8d72d42ebbcf" translate="yes" xml:space="preserve">
          <source>Whoops! You just put a tab and a formfeed into that filename! Remember that within double quoted strings (&quot;like\this&quot;), the backslash is an escape character. The full list of these is in &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;. Unsurprisingly, you don't have a file called &quot;c:(tab)emp(formfeed)oo&quot; or &quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy DOS filesystem.</source>
          <target state="translated">哎呀！您只需在该文件名中放入一个标签和一个换页符即可！请记住，在双引号字符串（&amp;ldquo; like \ this&amp;rdquo;）中，反斜杠是转义字符。这些的完整列表&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;在perlop&lt;/a&gt;中的Quote和类似Quote的运算符中。毫不奇怪，您的旧DOS文件系统上没有名为&amp;ldquo; c：（tab）emp（formfeed）oo&amp;rdquo;或&amp;ldquo; c：（tab）emp（formfeed）oo.exe&amp;rdquo;的文件。</target>
        </trans-unit>
        <trans-unit id="4b60ac899852ccb4f23a0cc5a329b0dd058c1185" translate="yes" xml:space="preserve">
          <source>Whoops, a failure! [4] &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt; helpfully lets us know on what line the failure occurred, but not much else. We were supposed to get 17, but we didn't. What did we get?? Dunno. You could re-run the test in the debugger or throw in some print statements to find out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0f41e4219d3445a18de71b89eb22ea90d39e82" translate="yes" xml:space="preserve">
          <source>Whoops. You should instead use this, which will fail if the file doesn't exist:</source>
          <target state="translated">呜呜,你应该用这个。你应该用这个,如果文件不存在,就会失败。</target>
        </trans-unit>
        <trans-unit id="21e2caea4476d26af34541ca7c909c7ff2fa4a7f" translate="yes" xml:space="preserve">
          <source>Why</source>
          <target state="translated">Why</target>
        </trans-unit>
        <trans-unit id="9560992747d1a6605928cb6a17f56014fb292bd8" translate="yes" xml:space="preserve">
          <source>Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?</source>
          <target state="translated">为什么我得到的是长小数(例如,19.9499999999999),而不是我应该得到的数字(例如,19.95)?</target>
        </trans-unit>
        <trans-unit id="dc84c992e3edcd39e94928310a7c42a03b0e34c8" translate="yes" xml:space="preserve">
          <source>Why aren't my random numbers random?</source>
          <target state="translated">为什么我的随机数不是随机的?</target>
        </trans-unit>
        <trans-unit id="55451ebd45b1e100db71c6105ddc04433d37cb2f" translate="yes" xml:space="preserve">
          <source>Why can't I get the output of a command with system()?</source>
          <target state="translated">为什么我不能用system()获取命令的输出?</target>
        </trans-unit>
        <trans-unit id="6283f33f8240aceff8b5bf7c89ea62586d7996ea" translate="yes" xml:space="preserve">
          <source>Why can't I just open(FH, &quot;&amp;gt;file.lock&quot;)?</source>
          <target state="translated">为什么我不能只打开（FH，&amp;ldquo;&amp;gt; file.lock&amp;rdquo;）？</target>
        </trans-unit>
        <trans-unit id="45f36238b104ed9ce41136ab2cd5676c9546b754" translate="yes" xml:space="preserve">
          <source>Why can't I use &quot;C:\temp\foo&quot; in DOS paths? Why doesn't `C:\temp\foo.exe` work?</source>
          <target state="translated">为什么我在DOS路径中不能使用 &quot;C:tempfoo&quot;?为什么 &quot;C:\tempfoo.exe &quot;不能使用?</target>
        </trans-unit>
        <trans-unit id="7cf9bf3687394740ded1b7a3b49b00f8b7f479e0" translate="yes" xml:space="preserve">
          <source>Why can't a method included in this same file be found?</source>
          <target state="translated">为什么在这个同样的文件中找不到一个方法?</target>
        </trans-unit>
        <trans-unit id="c1b368f947117e2802b241b52fd0f345164c6250" translate="yes" xml:space="preserve">
          <source>Why can't my script read from STDIN after I gave it EOF (^D on Unix, ^Z on MS-DOS)?</source>
          <target state="translated">为什么我的脚本在给了EOF(Unix上是^D,MS-DOS上是^Z)之后不能从STDIN读取?</target>
        </trans-unit>
        <trans-unit id="12d1b0fba90164d9432c0961ee9c0f59f511f752" translate="yes" xml:space="preserve">
          <source>Why can't the part of an Email address after the @ be used as the hostname ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a35a43f2543633bf09ecfd8ed381f93a2e351c4" translate="yes" xml:space="preserve">
          <source>Why chimera build?</source>
          <target state="translated">为什么要建立奇美拉?</target>
        </trans-unit>
        <trans-unit id="4ad29870738240c44cf5d008e9ef6e5a830b4811" translate="yes" xml:space="preserve">
          <source>Why did MakeMaker reinvent the build configuration wheel? Why not just use autoconf or automake or ppm or Ant or ...</source>
          <target state="translated">为什么MakeMaker要重新发明构建配置轮?为什么不直接使用autoconf或automake或ppm或Ant或 ...</target>
        </trans-unit>
        <trans-unit id="9c94cf8ad35b8d40bcd1d8a24897df534e24a65c" translate="yes" xml:space="preserve">
          <source>Why do I get asked the same questions every time I start the shell?</source>
          <target state="translated">为什么每次启动shell都会问我同样的问题?</target>
        </trans-unit>
        <trans-unit id="88d20a17cd64b1f5b322facdeee78dd428855e4f" translate="yes" xml:space="preserve">
          <source>Why do I get weird spaces when I print an array of lines?</source>
          <target state="translated">为什么我在打印一个数组行时得到奇怪的空格?</target>
        </trans-unit>
        <trans-unit id="22c242ee2f7e6a5499b05c8e9ef2302a328d950b" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use &amp;lt;*&amp;gt;?</source>
          <target state="translated">为什么在使用&amp;lt;*&amp;gt;时有时会出现&amp;ldquo;参数列表过长&amp;rdquo;的情况？</target>
        </trans-unit>
        <trans-unit id="b24284283ebf1fc2287cf9d0bdc0093551feae63" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use ?</source>
          <target state="translated">为什么我有时会收到 &quot;Argument list too long&quot;(参数列表太长),当我使用?</target>
        </trans-unit>
        <trans-unit id="63e6abc6f1a440467925da9b75e53aa88bf445d6" translate="yes" xml:space="preserve">
          <source>Why do Perl operators have different precedence than C operators?</source>
          <target state="translated">为什么Perl运算符与C运算符的优先级不同?</target>
        </trans-unit>
        <trans-unit id="ef2253bfbc8ad66388d03d0bb9e87b886d907b29" translate="yes" xml:space="preserve">
          <source>Why do regex character classes sometimes match only in the ASCII range?</source>
          <target state="translated">为什么regex字符类有时只在ASCII范围内匹配?</target>
        </trans-unit>
        <trans-unit id="fe1dc5c347574cf3a08e8eebfbeb7750b39e6b8c" translate="yes" xml:space="preserve">
          <source>Why do setuid perl scripts complain about kernel problems?</source>
          <target state="translated">为什么setuid perl脚本会抱怨内核问题?</target>
        </trans-unit>
        <trans-unit id="026df39820ea4af121bee1f807b65636d02b2c10" translate="yes" xml:space="preserve">
          <source>Why do some characters not uppercase or lowercase correctly?</source>
          <target state="translated">为什么有些字不能正确地大写或小写?</target>
        </trans-unit>
        <trans-unit id="c99d6ee81fb9e8a95f7bcc8c77d79b83dd80d118" translate="yes" xml:space="preserve">
          <source>Why do you want to do that? :-)</source>
          <target state="translated">你为什么要这样做?)</target>
        </trans-unit>
        <trans-unit id="72bb63a51859ce8a03efe317ce769e0ebbe394ee" translate="yes" xml:space="preserve">
          <source>Why does Net::FTP not implement mput and mget methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f2d2fc2e6067abbcff0c6297133f00fea08094" translate="yes" xml:space="preserve">
          <source>Why does Net::SMTP not do DNS MX lookups ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd94a8382da48e70b41ef67567b746b186c9a0e6" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">为什么 Perl 让我删除只读文件?为什么 -i 会破坏受保护的文件?这难道不是 Perl 的一个错误吗?</target>
        </trans-unit>
        <trans-unit id="cc878c7b17c2f51ef8a429a9375cb383410dd74c" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does &lt;code&gt;-i&lt;/code&gt; clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">为什么Perl让我删除只读文件？为什么 &lt;code&gt;-i&lt;/code&gt; 破坏器保护文件？这不是Perl中的错误吗？</target>
        </trans-unit>
        <trans-unit id="cab7997afd3e855e0bc949d3ba08b5a07d77bad2" translate="yes" xml:space="preserve">
          <source>Why does defined() return true on empty arrays and hashes?</source>
          <target state="translated">为什么 defined()在空数组和哈希上返回 true?</target>
        </trans-unit>
        <trans-unit id="a9078f034de31f1b296232dfb6a8a4e24d9d3fe0" translate="yes" xml:space="preserve">
          <source>Why does passing a subroutine an undefined element in a hash create it?</source>
          <target state="translated">为什么在哈希中传递一个未定义元素的子程序会创建它?</target>
        </trans-unit>
        <trans-unit id="7586fa4c0b5fc90f209bbbf4172abb17863eb05e" translate="yes" xml:space="preserve">
          <source>Why does using $&amp;amp;, $`, or $' slow my program down?</source>
          <target state="translated">为什么使用$＆，$`或$'会使我的程序变慢？</target>
        </trans-unit>
        <trans-unit id="d0d6812625a87b8571932c2c534a16df1d30c46a" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = &amp;lt;$fh&amp;gt;;&quot; work right?</source>
          <target state="translated">为什么不显示&amp;ldquo; my（$ foo）= &amp;lt;$ fh&amp;gt;;&amp;rdquo; 工作吧？</target>
        </trans-unit>
        <trans-unit id="dce612b6a2414fd18ba042c0e4b6d8009b148ed5" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = ;&quot; work right?</source>
          <target state="translated">为什么 &quot;my($foo)=;&quot;不能正常工作?</target>
        </trans-unit>
        <trans-unit id="5027566591e947a691e8c94cf6484817ceca1f52" translate="yes" xml:space="preserve">
          <source>Why doesn't &amp;amp; work the way I want it to?</source>
          <target state="translated">为什么不按我想要的方式工作？</target>
        </trans-unit>
        <trans-unit id="4cf8f75bbab1ae3d6a9b3cc517f4738f093df66a" translate="yes" xml:space="preserve">
          <source>Why doesn't glob(&quot;*.*&quot;) get all the files?</source>
          <target state="translated">为什么 glob(&quot;*.*&quot;)不能得到所有的文件?</target>
        </trans-unit>
        <trans-unit id="2deaa0032d55ad3bbe4d463b92dc4d6876271de7" translate="yes" xml:space="preserve">
          <source>Why doesn't my sockets program work under System V (Solaris)? What does the error message &quot;Protocol not supported&quot; mean?</source>
          <target state="translated">为什么我的套接字程序在System V (Solaris)下不能工作?协议不支持 &quot;的错误信息是什么意思?</target>
        </trans-unit>
        <trans-unit id="94b7e3ba62840111acddb7ecbcec36ba2e7bc4b2" translate="yes" xml:space="preserve">
          <source>Why doesn't open() return an error when a pipe open fails?</source>
          <target state="translated">为什么管道打开失败时,open()不返回错误?</target>
        </trans-unit>
        <trans-unit id="39d80c781157cb75a05623de25db34f558131470" translate="yes" xml:space="preserve">
          <source>Why don't Perl one-liners work on my DOS/Mac/VMS system?</source>
          <target state="translated">为什么Perl单行本在我的DOS/Mac/VMS系统上无法使用?</target>
        </trans-unit>
        <trans-unit id="7efb6bacfd459d208d2e83d3ccd6f5a6e06b31a2" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;</source>
          <target state="translated">为什么我的&amp;lt;</target>
        </trans-unit>
        <trans-unit id="d55b9cceedd9f6975831dcd97371f91faa17e9ba" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;&amp;lt;HERE documents work?</source>
          <target state="translated">为什么我的&amp;lt;&amp;lt; HERE文档不起作用？</target>
        </trans-unit>
        <trans-unit id="1b729d456f5e2de755ce9ca47664753dfbd6fc06" translate="yes" xml:space="preserve">
          <source>Why don't my tied hashes make the defined/exists distinction?</source>
          <target state="translated">为什么我的绑定哈希不做定义/存在的区分?</target>
        </trans-unit>
        <trans-unit id="ec879bc347cf004a28479d385b991508d06231e9" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with &lt;code&gt;\b&lt;/code&gt; work for me?</source>
          <target state="translated">为什么用 &lt;code&gt;\b&lt;/code&gt; 进行单词边界搜索对我不起作用？</target>
        </trans-unit>
        <trans-unit id="123e5244abcc6475513e58c7be3baf1e624a09b7" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with \b work for me?</source>
          <target state="translated">為什麼我不能用字界搜索?</target>
        </trans-unit>
        <trans-unit id="aa0f337d4d9c4331ea81d21ad3497b56fec40614" translate="yes" xml:space="preserve">
          <source>Why dynamic linking?</source>
          <target state="translated">为什么要做动态链接?</target>
        </trans-unit>
        <trans-unit id="4dfd253727c4f99a421a3b97c6c33e70ca139825" translate="yes" xml:space="preserve">
          <source>Why is int() broken?</source>
          <target state="translated">为什么int()会坏掉?</target>
        </trans-unit>
        <trans-unit id="a9539bbca1f0e44580627232613c4e6433a9dda3" translate="yes" xml:space="preserve">
          <source>Why is there Perl source in my database?</source>
          <target state="translated">为什么我的数据库里有Perl源码?</target>
        </trans-unit>
        <trans-unit id="5376410df92e4e194b5ef26e3120b8356d39f687" translate="yes" xml:space="preserve">
          <source>Why isn't my octal data interpreted correctly?</source>
          <target state="translated">为什么我的八进制数据解释不正确?</target>
        </trans-unit>
        <trans-unit id="76e636f7e8860a670fadde05e6d7c8a9de0467dd" translate="yes" xml:space="preserve">
          <source>Why not just use &amp;lt;insert other build config tool here&amp;gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adf1b58b38027864f2d28cd98aeb834dee11ea7" translate="yes" xml:space="preserve">
          <source>Why strange names?</source>
          <target state="translated">为什么会有奇怪的名字?</target>
        </trans-unit>
        <trans-unit id="d2f963c70a1ed1fc561f572fe023203fb76a83ae" translate="yes" xml:space="preserve">
          <source>Why the heck Encode API is different?</source>
          <target state="translated">到底为什么Encode API不一样?</target>
        </trans-unit>
        <trans-unit id="2d967f841c57d824cac2c9266688fd2aa1c5db9c" translate="yes" xml:space="preserve">
          <source>Why use ppport.h?</source>
          <target state="translated">为什么使用pport.h?</target>
        </trans-unit>
        <trans-unit id="df4212a2d988730cb90863e6978ac9cd91d10bdc" translate="yes" xml:space="preserve">
          <source>Why would you want a hash of lists? Let's take a simple example: You have a file of city and country names, like this:</source>
          <target state="translated">为什么你会想要一个列表的哈希?让我们举个简单的例子。你有一个城市和国家名称的文件,像这样。</target>
        </trans-unit>
        <trans-unit id="7f3771c096b7c324730a1a8a01295eb54a206ffa" translate="yes" xml:space="preserve">
          <source>Why, you may ask, would you need a chunk of memory containing some values in binary representation? One good reason is input and output accessing some file, a device, or a network connection, whereby this binary representation is either forced on you or will give you some benefit in processing. Another cause is passing data to some system call that is not available as a Perl function: &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; requires you to provide parameters stored in the way it happens in a C program. Even text processing (as shown in the next section) may be simplified with judicious usage of these two functions.</source>
          <target state="translated">您可能会问，为什么需要一块包含一些二进制表示值的内存？一个很好的理由是输入和输出访问某些文件，设备或网络连接，这样，这种二进制表示形式要么强加于您，要么将给您带来一些处理上的好处。另一个原因是将数据传递给Perl函数无法使用的某些系统调用： &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 要求您提供以C程序中发生的方式存储的参数。通过明智地使用这两个功能，甚至可以简化文本处理（如下一节所示）。</target>
        </trans-unit>
        <trans-unit id="6ab0396ba481d1f15a966e8a80a53c0fff8a6b1e" translate="yes" xml:space="preserve">
          <source>Why, you may ask, would you need a chunk of memory containing some values in binary representation? One good reason is input and output accessing some file, a device, or a network connection, whereby this binary representation is either forced on you or will give you some benefit in processing. Another cause is passing data to some system call that is not available as a Perl function: &lt;code&gt;syscall&lt;/code&gt; requires you to provide parameters stored in the way it happens in a C program. Even text processing (as shown in the next section) may be simplified with judicious usage of these two functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b95af46a7dc5483f3c0502e26f80b536b33809" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;can&lt;/code&gt; returns a coderef to mean &quot;yes it can (and the method is this...)&quot;, and then &lt;code&gt;ok&lt;/code&gt; sees a coderef and thinks you're passing a function that you want it to call and consider the truth of the result of! I.e., just like:</source>
          <target state="translated">为什么？由于 &lt;code&gt;can&lt;/code&gt; 回报CODEREF表示&amp;ldquo;是的，它可以（和方法是这样的......）&amp;rdquo;，然后 &lt;code&gt;ok&lt;/code&gt; 看到了CODEREF并且认为你传递一个函数，你想它来调用，并考虑结果的真相的！即，就像：</target>
        </trans-unit>
        <trans-unit id="c682a5bde8a3f0f1d13f9a9af66f849014ab6208" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;nasty_break()&lt;/code&gt; modifies &lt;code&gt;$\&lt;/code&gt; without localizing it first. The value you set in &lt;code&gt;nasty_break()&lt;/code&gt; is still there when you return. The fix is to add &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; so the value doesn't leak out of &lt;code&gt;nasty_break()&lt;/code&gt; :</source>
          <target state="translated">为什么？因为 &lt;code&gt;nasty_break()&lt;/code&gt; 修改 &lt;code&gt;$\&lt;/code&gt; 而不先对其进行本地化。返回时，您在 &lt;code&gt;nasty_break()&lt;/code&gt; 中设置的值仍然存在。解决方法是添加 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; ,以便该值不会从 &lt;code&gt;nasty_break()&lt;/code&gt; 中泄漏出来：</target>
        </trans-unit>
        <trans-unit id="a6faa641a92e7908b2759e3d399e519a97396eeb" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;nasty_break()&lt;/code&gt; modifies &lt;code&gt;$\&lt;/code&gt; without localizing it first. The value you set in &lt;code&gt;nasty_break()&lt;/code&gt; is still there when you return. The fix is to add &lt;code&gt;local()&lt;/code&gt; so the value doesn't leak out of &lt;code&gt;nasty_break()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a097ba046d774750c25655e60293a973b6be9d" translate="yes" xml:space="preserve">
          <source>Wide character (U+%X) in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745ada6d8a512f870963c08fe697c0dd823de817" translate="yes" xml:space="preserve">
          <source>Wide character in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59af40d4a351e635fdbe369d7b681d20a590a23a" translate="yes" xml:space="preserve">
          <source>Wildcard expansion</source>
          <target state="translated">通配符扩展</target>
        </trans-unit>
        <trans-unit id="47c9b4ee449bd8455aec29f4590e9aaa03c049f4" translate="yes" xml:space="preserve">
          <source>Wildcards in Property Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70477b387f14e0143de5873f3a9e791508ea1046" translate="yes" xml:space="preserve">
          <source>Will My Old Scripts Break?</source>
          <target state="translated">我的旧脚本会不会坏掉?</target>
        </trans-unit>
        <trans-unit id="2873c6e6e5880b670c065bcdc4a78243fbadf06c" translate="yes" xml:space="preserve">
          <source>Will Sheppard &amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2758b8d4c9377404295cf137b65b7a19678f3231" translate="yes" xml:space="preserve">
          <source>Will add a file to the in-memory archive, with name &lt;code&gt;$filename&lt;/code&gt; and content &lt;code&gt;$data&lt;/code&gt; . Specific properties can be set using &lt;code&gt;$opthashref&lt;/code&gt; . The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type. (On MacOS, the file's path and modification times are converted to Unix equivalents.)</source>
          <target state="translated">会将文件添加到内存存档中，名称 &lt;code&gt;$filename&lt;/code&gt; ，内容 &lt;code&gt;$data&lt;/code&gt; 。可以使用 &lt;code&gt;$opthashref&lt;/code&gt; 设置特定属性。支持以下属性列表：名称，大小，mtime（上次修改日期），模式，uid，gid，链接名，uname，gname，devmajor，devminor，前缀，类型。（在MacOS上，文件的路径和修改时间将转换为Unix等效文件。）</target>
        </trans-unit>
        <trans-unit id="93e582e568148c77bec33609334f756f428deffa" translate="yes" xml:space="preserve">
          <source>Will add a file to the in-memory archive, with name &lt;code&gt;$filename&lt;/code&gt; and content &lt;code&gt;$data&lt;/code&gt;. Specific properties can be set using &lt;code&gt;$opthashref&lt;/code&gt;. The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type. (On MacOS, the file's path and modification times are converted to Unix equivalents.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af66cccfd8aea183b531eebc0a74a7e923052ebf" translate="yes" xml:space="preserve">
          <source>Will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. (See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 时将被调用。（请参阅&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;下面的解开陷阱&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="3135cfa6b9641d632048427137e9d839208222a7" translate="yes" xml:space="preserve">
          <source>Will be called when &lt;code&gt;untie&lt;/code&gt; happens. (See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&quot;The &lt;code&gt;untie&lt;/code&gt; Gotcha&quot;&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c123e132f25bf178be9ea2aca72fafe2969081c" translate="yes" xml:space="preserve">
          <source>Will be loaded on demand and called automatically by BigInt.</source>
          <target state="translated">将按需加载,由BigInt自动调用。</target>
        </trans-unit>
        <trans-unit id="a669aaf9a433f6903c152ca38a90c9c7cb258f3e" translate="yes" xml:space="preserve">
          <source>Will be prepended to each install path.</source>
          <target state="translated">将被预置到每个安装路径中。</target>
        </trans-unit>
        <trans-unit id="4532ff2be2d0615be4c0aa19707d4e886e5a1789" translate="yes" xml:space="preserve">
          <source>Will be set to a uuid if uuid tagging was enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f18d29650d7b716edb7780278b512b0a8a59170" translate="yes" xml:space="preserve">
          <source>Will be used to modify the padding applied to string as described above.</source>
          <target state="translated">将用于修改应用于字符串的padding,如上所述。</target>
        </trans-unit>
        <trans-unit id="4e827c2a869b099543f874a4407588358567998d" translate="yes" xml:space="preserve">
          <source>Will both leave the sentence as is. Normally, when accepting literal string input from the user, &lt;a href=&quot;#quotemeta-EXPR&quot;&gt;&lt;code&gt;quotemeta&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;\Q&lt;/code&gt; must be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a659ce6bd28efeb251560042f49a1924dca7c4a4" translate="yes" xml:space="preserve">
          <source>Will both leave the sentence as is. Normally, when accepting literal string input from the user, quotemeta() or &lt;code&gt;\Q&lt;/code&gt; must be used.</source>
          <target state="translated">都将原样保留该句子。通常，当接受来自用户的文字字符串输入时，必须使用quotemeta（）或 &lt;code&gt;\Q&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10fbb1ac2af71320cfd2110a94f422695cba5311" translate="yes" xml:space="preserve">
          <source>Will cause &lt;code&gt;$sentence&lt;/code&gt; to become &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; .</source>
          <target state="translated">将导致 &lt;code&gt;$sentence&lt;/code&gt; 成为 &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10dc8768858451ca68c298fbc7a5ad46babe9c5d" translate="yes" xml:space="preserve">
          <source>Will cause &lt;code&gt;$sentence&lt;/code&gt; to become &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66fbedfbffb0f55bc116220f01908ca58f12e965" translate="yes" xml:space="preserve">
          <source>Will croak() if there is an error.</source>
          <target state="translated">如果出现错误,会呱呱叫()。</target>
        </trans-unit>
        <trans-unit id="a89e6d7112dafb5b2ad3a46406c0ced36b7d13b7" translate="yes" xml:space="preserve">
          <source>Will die() if called on r-magic.</source>
          <target state="translated">如果在r-magic上调用,会死()。</target>
        </trans-unit>
        <trans-unit id="0768298b9a0627e90df27324883d97a236031b2a" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Handy for things like...</source>
          <target state="translated">会以人类可读的格式转储任何参考资料的内容。很方便,比如...</target>
        </trans-unit>
        <trans-unit id="481a8de568a61f103c3af4da9f82b1f103a46712" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Usually you want to pass this into &lt;code&gt;note&lt;/code&gt; or &lt;code&gt;diag&lt;/code&gt; .</source>
          <target state="translated">将以人类可读的格式转储任何引用的内容。通常，您要将其传递给 &lt;code&gt;note&lt;/code&gt; 或 &lt;code&gt;diag&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdc14d4349b2640a0197394413323e6c4dc94091" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Usually you want to pass this into &lt;code&gt;note&lt;/code&gt; or &lt;code&gt;diag&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75f83221407c4472808dc0bb2139500f5229338d" translate="yes" xml:space="preserve">
          <source>Will force the generation of test code that uses the older &lt;code&gt;Test&lt;/code&gt; module.</source>
          <target state="translated">将强制使用较早的 &lt;code&gt;Test&lt;/code&gt; 模块生成测试代码。</target>
        </trans-unit>
        <trans-unit id="a329a554ce0cef11ca3198cc6cf9ba23c8d4f77f" translate="yes" xml:space="preserve">
          <source>Will incorrectly print</source>
          <target state="translated">会错误地打印</target>
        </trans-unit>
        <trans-unit id="fe4d3313b3f93ee1361d2d67710393a85713398e" translate="yes" xml:space="preserve">
          <source>Will invoke a sub at the end of a (compile-time) scope. The sub is called once with no arguments. Can be called multiple times (even in the same &quot;compile-time&quot; scope) to install multiple subs. Subs are called in a &quot;first-in-last-out&quot;-order (FILO or &quot;stack&quot;-order).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c610d24bbac520a7e0e174e12fe1f23a3ae5f9e4" translate="yes" xml:space="preserve">
          <source>Will make sure that =head1 will become &amp;lt;h3&amp;gt; and =head2 will become &amp;lt;h4&amp;gt; etc...</source>
          <target state="translated">将确保= head1将变为&amp;lt;h3&amp;gt;并且= head2将变为&amp;lt;h4&amp;gt;等等...</target>
        </trans-unit>
        <trans-unit id="49024b4120de3dd67c62575e0a4eb5f193ed6c22" translate="yes" xml:space="preserve">
          <source>Will not cause &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; to re-read the directory stream. The entries already read before the &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; call will just be returned again from a cache buffer. (Win32)</source>
          <target state="translated">不会导致 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 重新读取目录流。在 &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; 调用之前已读取的条目将仅从缓存缓冲区中再次返回。（Win32的）</target>
        </trans-unit>
        <trans-unit id="845d623fd40095b89ded11a672446e7d8d2933f3" translate="yes" xml:space="preserve">
          <source>Will not exceed this limit even if the string is not valid &quot;UTF-8&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7706e40a252d341368a094f13349cb965c7bcf44" translate="yes" xml:space="preserve">
          <source>Will not exceed those limits even if the string is not valid &quot;UTF-8&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b4b57e33203662ee1ddac498725ec0cbd902da5" translate="yes" xml:space="preserve">
          <source>Will not work on platforms that do not support the &lt;code&gt;-k&lt;/code&gt; test for sticky bit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aff13c5ad9d691f5f29f20db0a92fc55a16499de" translate="yes" xml:space="preserve">
          <source>Will not work on platforms that do not support the C test for sticky bit.</source>
          <target state="translated">在不支持C测试的平台上将无法使用粘性位。</target>
        </trans-unit>
        <trans-unit id="19ad79cf64559535aa01bc2039517ce48ed1f305" translate="yes" xml:space="preserve">
          <source>Will output 2, not 1. This is particularly important if you intend to compile the definitions with the &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator, and later interpolate them in another pattern.</source>
          <target state="translated">将输出2，而不是1。如果要使用 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 运算符编译定义，然后以另一种模式内插它们，则这尤其重要。</target>
        </trans-unit>
        <trans-unit id="d7ba12340e687f11ed70710aaea6e46b38d77b8f" translate="yes" xml:space="preserve">
          <source>Will output 2, not 1. This is particularly important if you intend to compile the definitions with the &lt;code&gt;qr//&lt;/code&gt; operator, and later interpolate them in another pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10021ccb8e306fb831263dee40b8f7ca24084b5a" translate="yes" xml:space="preserve">
          <source>Will prevent the automatic use of INSTALL.SKIP as the install skip file.</source>
          <target state="translated">将防止自动使用INSTALL.SKIP作为安装跳过文件。</target>
        </trans-unit>
        <trans-unit id="897aeeccb9736732e15f96f20d971e76dcd3a8ff" translate="yes" xml:space="preserve">
          <source>Will print &lt;code&gt;2&lt;/code&gt; , because &lt;code&gt;$string&lt;/code&gt; is upgraded as UTF-8. Without &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; , it will print &lt;code&gt;4&lt;/code&gt; instead, since &lt;code&gt;$string&lt;/code&gt; is three octets when interpreted as Latin-1.</source>
          <target state="translated">将打印 &lt;code&gt;2&lt;/code&gt; ，因为 &lt;code&gt;$string&lt;/code&gt; 已升级为UTF-8。不 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; ，它将改为打印 &lt;code&gt;4&lt;/code&gt; ，因为当解释为Latin-1时 &lt;code&gt;$string&lt;/code&gt; 是三个八位字节。</target>
        </trans-unit>
        <trans-unit id="c7912cc2705e39fd55074c6583f91d53d1be3b82" translate="yes" xml:space="preserve">
          <source>Will print &lt;code&gt;2&lt;/code&gt;, because &lt;code&gt;$string&lt;/code&gt; is upgraded as UTF-8. Without &lt;code&gt;use encoding 'utf8';&lt;/code&gt;, it will print &lt;code&gt;4&lt;/code&gt; instead, since &lt;code&gt;$string&lt;/code&gt; is three octets when interpreted as Latin-1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceca318096ebec569ca5ded9c24fde055f72cece" translate="yes" xml:space="preserve">
          <source>Will print just the value of &lt;code&gt;$x&lt;/code&gt;, believing that &lt;code&gt;$y&lt;/code&gt; is a numerically- equivalent value. This bug does not affect &lt;code&gt;uniqstr()&lt;/code&gt;, which will correctly observe that the two values stringify to different strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f950740e9c08c94cdc9c22017e9c8d9e11964004" translate="yes" xml:space="preserve">
          <source>Will produce something like this:</source>
          <target state="translated">会产生这样的东西。</target>
        </trans-unit>
        <trans-unit id="73c023c285973466729ee2bf21a0f578281a6002" translate="yes" xml:space="preserve">
          <source>Will return a list of two sockets created (read and write), or an empty list on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e73c78b5d339922fd7fb53696709fc79fcc290" translate="yes" xml:space="preserve">
          <source>Will use &lt;a href=&quot;TAP::Harness::Archive&quot;&gt;TAP::Harness::Archive&lt;/a&gt; as the harness class, and save the TAP to &lt;code&gt;file.tgz&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db8fa98164c98267f0158f423a3da70d388112fe" translate="yes" xml:space="preserve">
          <source>Will use &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP::Harness::Archive&lt;/a&gt; as the harness class, and save the TAP to &lt;code&gt;file.tgz&lt;/code&gt;</source>
          <target state="translated">将使用&lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP :: Harness :: Archive&lt;/a&gt;作为线束类，并将TAP保存到 &lt;code&gt;file.tgz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b653c1a1342f29b6e1ca16ef44b1d14c98a11e3" translate="yes" xml:space="preserve">
          <source>Win32</source>
          <target state="translated">Win32</target>
        </trans-unit>
        <trans-unit id="193cb801459c22b68d471c2735c8916bade862e2" translate="yes" xml:space="preserve">
          <source>Win32 - Interfaces to some Win32 API Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fdadddae42eb18256ba3d6c7445968142a4fd2" translate="yes" xml:space="preserve">
          <source>Win32 CORE function stubs</source>
          <target state="translated">Win32 CORE函数存根</target>
        </trans-unit>
        <trans-unit id="0cab5c56f7d1ce7bc278eb6ee5c4a8575346a7ef" translate="yes" xml:space="preserve">
          <source>Win32 implementation</source>
          <target state="translated">Win32执行</target>
        </trans-unit>
        <trans-unit id="c331f9a552ce93a52bd3bbd4fbac9c58a662301b" translate="yes" xml:space="preserve">
          <source>Win32 support for Sys::Syslog</source>
          <target state="translated">Win32对Sys::Syslog的支持。</target>
        </trans-unit>
        <trans-unit id="263a800b140dc4fe3448979f4261e583bcee830e" translate="yes" xml:space="preserve">
          <source>Win32 users should use the real slash. If you really want to use backslashes, consider using Sarathy's File::DosGlob, which comes with the standard Perl distribution.</source>
          <target state="translated">Win32用户应该使用真正的斜线。如果你真的想使用反斜线,可以考虑使用 Sarathy 的 File::DosGlob,它是标准的 Perl 发行版。</target>
        </trans-unit>
        <trans-unit id="6d0e1038c340ca3cf2b59ac852b5f2ef7407e5c9" translate="yes" xml:space="preserve">
          <source>Win32::AbortSystemShutdown(MACHINE)</source>
          <target state="translated">Win32::AbortSystemShutdown(MACHINE)</target>
        </trans-unit>
        <trans-unit id="6f12fa420b1205100cabb4570f237b3d345d86ca" translate="yes" xml:space="preserve">
          <source>Win32::BuildNumber()</source>
          <target state="translated">Win32::BuildNumber()</target>
        </trans-unit>
        <trans-unit id="99f20893b3ea998d83c35a43b1ddcaefd97d6b9f" translate="yes" xml:space="preserve">
          <source>Win32::CopyFile(FROM, TO, OVERWRITE)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d269bfa64c0a58bda1986a24d2c54a63190e288a" translate="yes" xml:space="preserve">
          <source>Win32::CreateDirectory(DIRECTORY)</source>
          <target state="translated">Win32::CreateDirectory(DIRECTORY)</target>
        </trans-unit>
        <trans-unit id="7a7983d24568164c28a76c5bb077686f88dad153" translate="yes" xml:space="preserve">
          <source>Win32::CreateFile(FILE)</source>
          <target state="translated">Win32::CreateFile(FILE)</target>
        </trans-unit>
        <trans-unit id="fa7c1f0bbed5b785d5607e1311dcb11968fd8fe9" translate="yes" xml:space="preserve">
          <source>Win32::DomainName()</source>
          <target state="translated">Win32::DomainName()</target>
        </trans-unit>
        <trans-unit id="1c453bb935414d8146aa602c45dd5159dab45ade" translate="yes" xml:space="preserve">
          <source>Win32::ExpandEnvironmentStrings(STRING)</source>
          <target state="translated">Win32::ExpandEnvironmentStrings(STRING)</target>
        </trans-unit>
        <trans-unit id="88134ad369f40cbd5ed8e6414b571501a615d721" translate="yes" xml:space="preserve">
          <source>Win32::FormatMessage(ERRORCODE)</source>
          <target state="translated">Win32::FormatMessage(ERRORCODE)</target>
        </trans-unit>
        <trans-unit id="02c33521b3e0cfb9be57585db645c4568be060cf" translate="yes" xml:space="preserve">
          <source>Win32::FreeLibrary(HANDLE)</source>
          <target state="translated">Win32::FreeLibrary(HANDLE)</target>
        </trans-unit>
        <trans-unit id="ec6d95684a511580632674e1e5dce99eca02ed2c" translate="yes" xml:space="preserve">
          <source>Win32::FsType()</source>
          <target state="translated">Win32::FsType()</target>
        </trans-unit>
        <trans-unit id="fdfbfe52059c529a42a7f79b351a29683dd786d2" translate="yes" xml:space="preserve">
          <source>Win32::GUI</source>
          <target state="translated">Win32::GUI</target>
        </trans-unit>
        <trans-unit id="cc575cb0ebbd64ea43f9c9ccc56237b0705f9732" translate="yes" xml:space="preserve">
          <source>Win32::GetACP()</source>
          <target state="translated">Win32::GetACP()</target>
        </trans-unit>
        <trans-unit id="7798f250e449938fcf7dadf70c029ad54f636245" translate="yes" xml:space="preserve">
          <source>Win32::GetANSIPathName(FILENAME)</source>
          <target state="translated">Win32::GetANSIPathName(FILENAME)</target>
        </trans-unit>
        <trans-unit id="58ac17861a87852820b146e725b1e3c3e23cbe3e" translate="yes" xml:space="preserve">
          <source>Win32::GetArchName()</source>
          <target state="translated">Win32::GetArchName()</target>
        </trans-unit>
        <trans-unit id="3834fcd21d4e7fa28d350d64b78639660bbeb2c1" translate="yes" xml:space="preserve">
          <source>Win32::GetChipName()</source>
          <target state="translated">Win32::GetChipName()</target>
        </trans-unit>
        <trans-unit id="202596ea6840cbe9f281840b431aa41aec8424c4" translate="yes" xml:space="preserve">
          <source>Win32::GetConsoleCP()</source>
          <target state="translated">Win32::GetConsoleCP()</target>
        </trans-unit>
        <trans-unit id="8aaff4afc4c9f3d83ba6558614d36b7f40e38e33" translate="yes" xml:space="preserve">
          <source>Win32::GetConsoleOutputCP()</source>
          <target state="translated">Win32::GetConsoleOutputCP()</target>
        </trans-unit>
        <trans-unit id="ebc6f60b70df25fd8c32e53de9a7c9ba577f15ee" translate="yes" xml:space="preserve">
          <source>Win32::GetCurrentProcessId()</source>
          <target state="translated">Win32::GetCurrentProcessId()</target>
        </trans-unit>
        <trans-unit id="41cb4ff89334195c85ec80a4293eee0fe84b1c77" translate="yes" xml:space="preserve">
          <source>Win32::GetCurrentThreadId()</source>
          <target state="translated">Win32::GetCurrentThreadId()</target>
        </trans-unit>
        <trans-unit id="06fb2ae0e34c762652f91cc4b24d288d543148dd" translate="yes" xml:space="preserve">
          <source>Win32::GetCwd()</source>
          <target state="translated">Win32::GetCwd()</target>
        </trans-unit>
        <trans-unit id="424bc0808437c0c40f8b8eca83c71486de0c2ce3" translate="yes" xml:space="preserve">
          <source>Win32::GetFileVersion(FILENAME)</source>
          <target state="translated">Win32::GetFileVersion(FILENAME)</target>
        </trans-unit>
        <trans-unit id="bd89672cc22e170bdb15759f5b2c202ee866d3af" translate="yes" xml:space="preserve">
          <source>Win32::GetFolderPath(FOLDER [, CREATE])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7750debc5964ef700caa1d205774c5c516e86b5" translate="yes" xml:space="preserve">
          <source>Win32::GetFullPathName(FILENAME)</source>
          <target state="translated">Win32::GetFullPathName(FILENAME)</target>
        </trans-unit>
        <trans-unit id="1779b4a74c4e9c74750b4883d1c3a13e7f082821" translate="yes" xml:space="preserve">
          <source>Win32::GetLastError()</source>
          <target state="translated">Win32::GetLastError()</target>
        </trans-unit>
        <trans-unit id="c1d2be25cd4c6103e621d159ba09f9b5f7b7f66d" translate="yes" xml:space="preserve">
          <source>Win32::GetLongPathName(PATHNAME)</source>
          <target state="translated">Win32::GetLongPathName(PATHNAME)</target>
        </trans-unit>
        <trans-unit id="9a5b08237dd1d9c044b42e330417a8ee6c2fddc5" translate="yes" xml:space="preserve">
          <source>Win32::GetNextAvailDrive()</source>
          <target state="translated">Win32::GetNextAvailDrive()</target>
        </trans-unit>
        <trans-unit id="424731cf281e1dda51d3e9681cc85bb2740bbe76" translate="yes" xml:space="preserve">
          <source>Win32::GetOEMCP()</source>
          <target state="translated">Win32::GetOEMCP()</target>
        </trans-unit>
        <trans-unit id="1015f265e18dde79b1939bf46d05753e1cb1fc0a" translate="yes" xml:space="preserve">
          <source>Win32::GetOSDisplayName()</source>
          <target state="translated">Win32::GetOSDisplayName()</target>
        </trans-unit>
        <trans-unit id="e9e643f122af1698a8771b07d042a8eb421add6b" translate="yes" xml:space="preserve">
          <source>Win32::GetOSName()</source>
          <target state="translated">Win32::GetOSName()</target>
        </trans-unit>
        <trans-unit id="9ac415285a2a80e417f87a22967bf20ef2c63935" translate="yes" xml:space="preserve">
          <source>Win32::GetOSVersion()</source>
          <target state="translated">Win32::GetOSVersion()</target>
        </trans-unit>
        <trans-unit id="bbb14f64d25ca5875dac81a570aa2578d64fe870" translate="yes" xml:space="preserve">
          <source>Win32::GetProcAddress(INSTANCE, PROCNAME)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4519c40934e76bc7c24e8acfe3fe14ba43d63f" translate="yes" xml:space="preserve">
          <source>Win32::GetProductInfo(OSMAJOR, OSMINOR, SPMAJOR, SPMINOR)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="976bea2f0bcf19569dea7f3dcd696ad17b85b2c9" translate="yes" xml:space="preserve">
          <source>Win32::GetShortPathName(PATHNAME)</source>
          <target state="translated">Win32::GetShortPathName(PATHNAME)</target>
        </trans-unit>
        <trans-unit id="85686486692a83787d94a67516a3d3724180155d" translate="yes" xml:space="preserve">
          <source>Win32::GetSystemMetrics(INDEX)</source>
          <target state="translated">Win32::GetSystemMetrics(INDEX)</target>
        </trans-unit>
        <trans-unit id="da2531353eddaf6094a844bf9d9cb759ae2af1e8" translate="yes" xml:space="preserve">
          <source>Win32::GetTickCount()</source>
          <target state="translated">Win32::GetTickCount()</target>
        </trans-unit>
        <trans-unit id="ae35ac71f2f974fbd4820718cb015468050c4f6c" translate="yes" xml:space="preserve">
          <source>Win32::GuidGen()</source>
          <target state="translated">Win32::GuidGen()</target>
        </trans-unit>
        <trans-unit id="6c1bb229532a2f942fc09792beca570bb3feca1b" translate="yes" xml:space="preserve">
          <source>Win32::InitiateSystemShutdown</source>
          <target state="translated">Win32::InitiateSystemShutdown</target>
        </trans-unit>
        <trans-unit id="f9fa2b44699da87d011d8d62354503f774420ab1" translate="yes" xml:space="preserve">
          <source>Win32::IsAdminUser()</source>
          <target state="translated">Win32::IsAdminUser()</target>
        </trans-unit>
        <trans-unit id="fe185f7f6aa0888454156f6b1dd0647b97f1c985" translate="yes" xml:space="preserve">
          <source>Win32::IsWin95()</source>
          <target state="translated">Win32::IsWin95()</target>
        </trans-unit>
        <trans-unit id="1f8c102705f38e11ded9cb1693b6ba04ed8d2aac" translate="yes" xml:space="preserve">
          <source>Win32::IsWinNT()</source>
          <target state="translated">Win32::IsWinNT()</target>
        </trans-unit>
        <trans-unit id="75e8f5dee14a6d1c4d34f99cde2cd05959a202c6" translate="yes" xml:space="preserve">
          <source>Win32::LoadLibrary(LIBNAME)</source>
          <target state="translated">Win32::LoadLibrary(LIBNAME)</target>
        </trans-unit>
        <trans-unit id="33e6daf26026220d0161fea28893d1e652b68f17" translate="yes" xml:space="preserve">
          <source>Win32::LoginName()</source>
          <target state="translated">Win32::LoginName()</target>
        </trans-unit>
        <trans-unit id="b7203bf8251626a9d020ee5f4922ecd6ff013788" translate="yes" xml:space="preserve">
          <source>Win32::LookupAccountName(SYSTEM, ACCOUNT, DOMAIN, SID, SIDTYPE)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e02105130675ffb73c863f2651d7886f32ce699c" translate="yes" xml:space="preserve">
          <source>Win32::LookupAccountSID(SYSTEM, SID, ACCOUNT, DOMAIN, SIDTYPE)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b3757407e5968fe8497224d610a6b05e0fb867" translate="yes" xml:space="preserve">
          <source>Win32::MsgBox(MESSAGE [, FLAGS [, TITLE]])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3c6c757d1a1e7f6e540ff3306434ee9703babbe" translate="yes" xml:space="preserve">
          <source>Win32::NodeName()</source>
          <target state="translated">Win32::NodeName()</target>
        </trans-unit>
        <trans-unit id="2712cf0c3d41deb65f7212a8f31b3f82a4ae6a9e" translate="yes" xml:space="preserve">
          <source>Win32::OutputDebugString(STRING)</source>
          <target state="translated">Win32::OutputDebugString(STRING)</target>
        </trans-unit>
        <trans-unit id="75ef631d3c7ea178f0c26bc47d12483cd8c3ea5d" translate="yes" xml:space="preserve">
          <source>Win32::RegisterServer(LIBRARYNAME)</source>
          <target state="translated">Win32::RegisterServer(LIBRARYNAME)</target>
        </trans-unit>
        <trans-unit id="ce0d098c41c01fd9b4d42374933b719c4874605c" translate="yes" xml:space="preserve">
          <source>Win32::SetChildShowWindow(SHOWWINDOW)</source>
          <target state="translated">Win32::SetChildShowWindow(SHOWWINDOW)</target>
        </trans-unit>
        <trans-unit id="6ec2ec156820380d471d8b8902107f69d0c48aac" translate="yes" xml:space="preserve">
          <source>Win32::SetConsoleCP(ID)</source>
          <target state="translated">Win32::SetConsoleCP(ID)</target>
        </trans-unit>
        <trans-unit id="d56fdac00362d0844cebe19c2fbea7797556a862" translate="yes" xml:space="preserve">
          <source>Win32::SetConsoleOutputCP(ID)</source>
          <target state="translated">Win32::SetConsoleOutputCP(ID)</target>
        </trans-unit>
        <trans-unit id="8ff2683659839e8f5dba46b5d4a8ac3aa4a62e14" translate="yes" xml:space="preserve">
          <source>Win32::SetCwd(NEWDIRECTORY)</source>
          <target state="translated">Win32::SetCwd(NEWDIRECTORY)</target>
        </trans-unit>
        <trans-unit id="721ad14df20038a886cdbbad6ec515e2dfd8ef41" translate="yes" xml:space="preserve">
          <source>Win32::SetLastError(ERROR)</source>
          <target state="translated">Win32::SetLastError(ERROR)</target>
        </trans-unit>
        <trans-unit id="70d34dd79a3d13ab005b5f95a3a341dc634b545c" translate="yes" xml:space="preserve">
          <source>Win32::Sleep(TIME)</source>
          <target state="translated">Win32::Sleep(TIME)</target>
        </trans-unit>
        <trans-unit id="0bd78719dddc468413b0b8cae64f7604c9b0760f" translate="yes" xml:space="preserve">
          <source>Win32::Spawn(COMMAND, ARGS, PID)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cf1f14b3a9fb47a3d099c943c81a86f3bab76e" translate="yes" xml:space="preserve">
          <source>Win32::UnregisterServer(LIBRARYNAME)</source>
          <target state="translated">Win32::UnregisterServer(LIBRARYNAME)</target>
        </trans-unit>
        <trans-unit id="aa21f521370d6a588509094452635266c4468ce9" translate="yes" xml:space="preserve">
          <source>Win32API::File</source>
          <target state="translated">Win32API::File</target>
        </trans-unit>
        <trans-unit id="88c0b190dbad57a17cc677f51fa9c1ba74db87d0" translate="yes" xml:space="preserve">
          <source>Win32API::File - Low-level access to Win32 system API calls for files/dirs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a0edd9f797c147e0eca61b93c9942a6aada686" translate="yes" xml:space="preserve">
          <source>Win32CORE</source>
          <target state="translated">Win32CORE</target>
        </trans-unit>
        <trans-unit id="674b29c781e27ee904b0a31e2bca19f160dacd50" translate="yes" xml:space="preserve">
          <source>Win32CORE - Win32 CORE function stubs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823301860ab873ab455e9a7adb1aa457e7019586" translate="yes" xml:space="preserve">
          <source>Win32CORE was created to provide on cygwin those Win32:: functions that for regular win32 builds were provided by default in perl. In cygwin perl releases prior to 5.8.6, this module was standalone and had to be explicitly used. In 5.8.6 and later, it was statically linked into cygwin perl so this would no longer be necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64d38eb25949cf47b772e208780c5548dc84962" translate="yes" xml:space="preserve">
          <source>Win95 and Win98 and WinME are collectively Win9x and Win32</source>
          <target state="translated">Win95和Win98以及WinME是Win9x和Win32的统称。</target>
        </trans-unit>
        <trans-unit id="ea8db18a138027d52bc49a4789f983c73ef0f94f" translate="yes" xml:space="preserve">
          <source>Win95/NT</source>
          <target state="translated">Win95/NT</target>
        </trans-unit>
        <trans-unit id="38d123584917edd3d65a1c41ab99a9088beb8b64" translate="yes" xml:space="preserve">
          <source>Win98 chokes on things like Encode if we set the max length to nmake's max of 2K. So we go for a more conservative value of 1K.</source>
          <target state="translated">如果我们将最大长度设置为nmake的最大2K,Win98会对Encode这样的东西产生窒息。所以我们选择一个比较保守的值1K。</target>
        </trans-unit>
        <trans-unit id="7e7afec2ee076635c5bdb3c20b397b563733e6cf" translate="yes" xml:space="preserve">
          <source>Win9x and &lt;code&gt;d_eofnblk&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb6e2235a0d088883e2901a983ef0e7377f83c0" translate="yes" xml:space="preserve">
          <source>Win9x can not &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; an open file (although WinNT can).</source>
          <target state="translated">Win9x无法 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; 打开的文件（尽管WinNT可以）。</target>
        </trans-unit>
        <trans-unit id="de40f5b5690a0bb23e1bf760363cb6a5e8443821" translate="yes" xml:space="preserve">
          <source>Win9x can not &lt;code&gt;rename()&lt;/code&gt; an open file (although WinNT can).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1865487f835d74c1a32dc51f7e3fd10d2bb1c87c" translate="yes" xml:space="preserve">
          <source>Win9x does not correctly report &lt;code&gt;EOF&lt;/code&gt; with a non-blocking read on a closed pipe. You will see the following messages:</source>
          <target state="translated">Win9x不能正确报告 &lt;code&gt;EOF&lt;/code&gt; ，并且在封闭的管道上进行非阻塞读取。您将看到以下消息：</target>
        </trans-unit>
        <trans-unit id="468c4f1d38914eeba7915aa856cfac9060a7a5fe" translate="yes" xml:space="preserve">
          <source>Win9x support was added in 5.6 (Benjamin Stuhl).</source>
          <target state="translated">5.6中增加了对Win9x的支持(Benjamin Stuhl)。</target>
        </trans-unit>
        <trans-unit id="38c0fc63bcb91fe3116f8590745de1626f0dd16a" translate="yes" xml:space="preserve">
          <source>WinDisk.exe</source>
          <target state="translated">WinDisk.exe</target>
        </trans-unit>
        <trans-unit id="c816e89ffa10335823ff2ffbfd171adf35cada45" translate="yes" xml:space="preserve">
          <source>WinError.h</source>
          <target state="translated">WinError.h</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="bf4f5bc6b10d099fc4024cb19c3bd9cf757e522e" translate="yes" xml:space="preserve">
          <source>Windows .NET Server supports the LLP64 data model on the Intel Itanium architecture.</source>
          <target state="translated">Windows .NET Server支持Intel Itanium架构上的LLP64数据模型。</target>
        </trans-unit>
        <trans-unit id="f6a28970a521e035e5e254c78ec61c1026703f9b" translate="yes" xml:space="preserve">
          <source>Windows 2000</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94cada20ad68e1ffe3678826da4a09dc6377e803" translate="yes" xml:space="preserve">
          <source>Windows 7</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca1d54534e769c83a6c85f5e6241a2523f2592c" translate="yes" xml:space="preserve">
          <source>Windows 95</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdae4500dcdb3f86e38c3347c9fe418dd6deff32" translate="yes" xml:space="preserve">
          <source>Windows 98</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6578fbd48a0229e823dac38105b1950bd25957b3" translate="yes" xml:space="preserve">
          <source>Windows Event Log, &lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&lt;/a&gt;</source>
          <target state="translated">Windows事件日志，&lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http：//msdn.microsoft.com/library/default.asp？url = / library / en-us / wes / wes / windows_event_log.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08fe8b7597a09dd3a844091de7163268dfe54cc6" translate="yes" xml:space="preserve">
          <source>Windows ME</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83dc416748ad54d778d6b19e9f7fde1b7af83339" translate="yes" xml:space="preserve">
          <source>Windows NT4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d80809b5e98653b28bad4f8f5c33d52237b9226" translate="yes" xml:space="preserve">
          <source>Windows Server 2003</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2504575346cece1887f998d2d76408a38af5141e" translate="yes" xml:space="preserve">
          <source>Windows Server 2008</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc44c44b7a030798f3e511dc741ab9400f590ae" translate="yes" xml:space="preserve">
          <source>Windows Vista</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f20bccfe3512339ad2cea01fc1c7809e7d3d15" translate="yes" xml:space="preserve">
          <source>Windows XP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c2af17044bb2c5164875672fc2938f1968ed3a3" translate="yes" xml:space="preserve">
          <source>Windows has basically 2 sets of APIs. A wide API (based on passing UTF-16 strings) and a byte based API based a character set called ANSI. The regular Perl interfaces to the OS currently only uses the ANSI APIs. Unfortunately ANSI is not a single character set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32384d85bc892c2cec1cd8f151b8007b98fa13ff" translate="yes" xml:space="preserve">
          <source>Windows is Win32.</source>
          <target state="translated">Windows是Win32。</target>
        </trans-unit>
        <trans-unit id="15932d7727c0d0850847ee4a3aea588d05fd6a45" translate="yes" xml:space="preserve">
          <source>Windows is Windows telnet, Cygwin SSH is the OpenSSH implementation under Cygwin on Windows NT, and Mac Terminal is the Terminal application in Mac OS X. Where the entry is other than yes or no, that emulator displays the given attribute as something else instead. Note that on an aixterm, clear doesn't reset colors; you have to explicitly set the colors back to what you want. More entries in this table are welcome.</source>
          <target state="translated">Windows是Windows telnet,Cygwin SSH是Windows NT上Cygwin下的OpenSSH实现,Mac Terminal是Mac OS X中的终端应用程序。当条目不是yes或no时,仿真器会将给定的属性显示为其他内容。请注意,在 aixterm 上,清除并不能重置颜色;你必须明确地将颜色设置为你想要的颜色。欢迎在此表中添加更多条目。</target>
        </trans-unit>
        <trans-unit id="a8033e193c1409f4bd5db90d9880ca01290431d4" translate="yes" xml:space="preserve">
          <source>Windows systems also operate with another byte based character set. It's called the OEM code page. This is the encoding that the Console takes as input and output. It's common for the OEM code page to differ from the ANSI code page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3093bbeb765cee856b62debb98821ba39f27fcc6" translate="yes" xml:space="preserve">
          <source>Windows users who are using &lt;code&gt;nmake&lt;/code&gt; should note that due to a bug in &lt;code&gt;nmake&lt;/code&gt; , when specifying &lt;code&gt;TEST_FILES&lt;/code&gt; you must use back-slashes instead of forward-slashes.</source>
          <target state="translated">使用 &lt;code&gt;nmake&lt;/code&gt; 的 Windows用户应注意，由于 &lt;code&gt;nmake&lt;/code&gt; 中的错误，在指定 &lt;code&gt;TEST_FILES&lt;/code&gt; 时，必须使用反斜杠而不是正斜杠。</target>
        </trans-unit>
        <trans-unit id="db6ab0003d513d80fd8056684fe349106fcdab74" translate="yes" xml:space="preserve">
          <source>Windows users who are using &lt;code&gt;nmake&lt;/code&gt; should note that due to a bug in &lt;code&gt;nmake&lt;/code&gt;, when specifying &lt;code&gt;TEST_FILES&lt;/code&gt; you must use back-slashes instead of forward-slashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968c4aaba72bd2883444cce7386789debafb547b" translate="yes" xml:space="preserve">
          <source>Windows-specific tests.</source>
          <target state="translated">Windows专用测试。</target>
        </trans-unit>
        <trans-unit id="52b2489ffd6eceb9bd13b6a8f90eac373db50b35" translate="yes" xml:space="preserve">
          <source>Wisconsin</source>
          <target state="translated">Wisconsin</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="a51957fd22adb3afd697fb8ab328d3922f130d4b" translate="yes" xml:space="preserve">
          <source>With $k chosen carefully, and likely to be a small number like 1 or 2. In theory the larger the bucket array the less chance of collision.</source>
          <target state="translated">在$k慎重选择的情况下,而且很可能是1或2这样的小数。理论上斗阵越大,碰撞的几率越小。</target>
        </trans-unit>
        <trans-unit id="8a3fad0711b1021538f5283d00839025799b6dad" translate="yes" xml:space="preserve">
          <source>With 1 causes this module to use Time::HiRes module, allowing milliseconds to be returned by subsequent calls to ping().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6185bdea28758a42fc320398e067ab2654617d96" translate="yes" xml:space="preserve">
          <source>With 5005threads, you could also &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; a sub such that any calls to that sub from another thread would block until the lock was released.</source>
          <target state="translated">使用5005线程，您还可以 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 一个子线程，以便从另一个线程对该子线程的任何调用都将阻塞，直到释放锁定为止。</target>
        </trans-unit>
        <trans-unit id="a8d11fe55a26fb99c192c4c169dd330b2ce5c5d6" translate="yes" xml:space="preserve">
          <source>With 5005threads, you could also &lt;code&gt;lock&lt;/code&gt; a sub such that any calls to that sub from another thread would block until the lock was released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c741524004c7f8613fe0df95f2304ad27bfaf6" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;/a&lt;/code&gt; , one can write &lt;code&gt;\d&lt;/code&gt; with confidence that it will only match ASCII characters, and should the need arise to match beyond ASCII, you can instead use &lt;code&gt;\p{Digit}&lt;/code&gt; (or &lt;code&gt;\p{Word}&lt;/code&gt; for &lt;code&gt;\w&lt;/code&gt; ). There are similar &lt;code&gt;\p{...}&lt;/code&gt; constructs that can match beyond ASCII both white space (see &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;Whitespace in perlrecharclass&lt;/a&gt;), and Posix classes (see &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;). Thus, this modifier doesn't mean you can't use Unicode, it means that to get Unicode matching you must explicitly use a construct (&lt;code&gt;\p{}&lt;/code&gt; , &lt;code&gt;\P{}&lt;/code&gt; ) that signals Unicode.</source>
          <target state="translated">使用 &lt;code&gt;/a&lt;/code&gt; ，您可以放心地写 &lt;code&gt;\d&lt;/code&gt; 仅匹配ASCII字符，并且如果需要匹配ASCII以外的字符，则可以改用 &lt;code&gt;\p{Digit}&lt;/code&gt; （对于 &lt;code&gt;\w&lt;/code&gt; 使用 &lt;code&gt;\p{Word}&lt;/code&gt; ）。有类似的 &lt;code&gt;\p{...}&lt;/code&gt; 构造可以匹配ASCII以外的&lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;空白&lt;/a&gt;（请参见perlrecharclass中的Whitespace）和Posix类（请参见&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass中的POSIX字符类&lt;/a&gt;）。因此，此修饰符并不意味着您不能使用Unicode，它意味着要获得Unicode匹配，您必须显式使用发出Unicode信号的结构（ &lt;code&gt;\p{}&lt;/code&gt; ， &lt;code&gt;\P{}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d8c642a61a993b2822d327b2f6d2aa5b5cdb0c33" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;/a&lt;/code&gt;, one can write &lt;code&gt;\d&lt;/code&gt; with confidence that it will only match ASCII characters, and should the need arise to match beyond ASCII, you can instead use &lt;code&gt;\p{Digit}&lt;/code&gt; (or &lt;code&gt;\p{Word}&lt;/code&gt; for &lt;code&gt;\w&lt;/code&gt;). There are similar &lt;code&gt;\p{...}&lt;/code&gt; constructs that can match beyond ASCII both white space (see &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;&quot;Whitespace&quot; in perlrecharclass&lt;/a&gt;), and Posix classes (see &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;). Thus, this modifier doesn't mean you can't use Unicode, it means that to get Unicode matching you must explicitly use a construct (&lt;code&gt;\p{}&lt;/code&gt;, &lt;code&gt;\P{}&lt;/code&gt;) that signals Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5132b5fe6c695f29613169cf8ff9a2c949197d0f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, you get around this by using a block and an expression where you would place the filehandle:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; ，您可以使用一个块和一个放置文件句柄的表达式来解决此问题：</target>
        </trans-unit>
        <trans-unit id="487baf6c93470e20c12688608403c20fbdb8e8f3" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;, both STDOUT and STDERR will go the same place as the script's STDOUT and STDERR, unless the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; command redirects them. Backticks and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; read &lt;b&gt;only&lt;/b&gt; the STDOUT of your command.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; ，除非 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 命令将它们重定向，否则STDOUT和STDERR都将与脚本的STDOUT和STDERR放在同一位置。反引号和 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; &lt;b&gt;仅&lt;/b&gt;读取命令的STDOUT。</target>
        </trans-unit>
        <trans-unit id="e6ba4c518cc989a85f1859e34fe5315e0670671f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Class::Tiny&lt;/code&gt; , all accessors are read-write. It generates a constructor for you, as well as the accessors you define.</source>
          <target state="translated">使用 &lt;code&gt;Class::Tiny&lt;/code&gt; ，所有访问器都是可读写的。它为您以及您定义的访问器生成一个构造函数。</target>
        </trans-unit>
        <trans-unit id="30133336b461bf131bf440d3b8937ae3c7286e54" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Class::Tiny&lt;/code&gt;, all accessors are read-write. It generates a constructor for you, as well as the accessors you define.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b55e3069c1cf271c20c8804a7b8c0dbfbb1f17" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ignore_case&lt;/code&gt; , option specifications for options that only differ in case, e.g., &lt;code&gt;&quot;foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; , will be flagged as duplicates.</source>
          <target state="translated">使用 &lt;code&gt;ignore_case&lt;/code&gt; 时，仅大小写不同的选项的选项规范（例如 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; ）将被标记为重复项。</target>
        </trans-unit>
        <trans-unit id="912c5dbb25de4eb33c760222cb62f248afb75050" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ignore_case&lt;/code&gt;, option specifications for options that only differ in case, e.g., &lt;code&gt;&quot;foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;Foo&quot;&lt;/code&gt;, will be flagged as duplicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fffc08f49ded4afbdfb2c00f9dcdbc7da340301" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;latin1&lt;/code&gt; (or &lt;code&gt;ascii&lt;/code&gt;) enabled, &lt;code&gt;encode&lt;/code&gt; will escape characters with ordinal values &amp;gt; 255 (&amp;gt; 127 with &lt;code&gt;ascii&lt;/code&gt;) and encode the remaining characters as specified by the &lt;code&gt;utf8&lt;/code&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee71de233ae712db3a62ad0a5f3c845bcb07690d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;pass_through&lt;/code&gt; anything that is unknown, ambiguous or supplied with an invalid option will not be flagged as an error. Instead the unknown option(s) will be passed to the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present, otherwise through to &lt;code&gt;@ARGV&lt;/code&gt; . This makes it possible to write wrapper scripts that process only part of the user supplied command line arguments, and pass the remaining options to some other program.</source>
          <target state="translated">使用 &lt;code&gt;pass_through&lt;/code&gt; 时,任何未知，模棱两可或带有无效选项的内容都不会被标记为错误。相反，未知选项将传递给catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; (如果存在），否则传递给 &lt;code&gt;@ARGV&lt;/code&gt; 。这样就可以编写仅处理部分用户提供的命令行参数的包装器脚本，并将其余选项传递给其他程序。</target>
        </trans-unit>
        <trans-unit id="f4663d47991fc6ad8f19a68b7dbd43ec5db93e1f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;pass_through&lt;/code&gt; anything that is unknown, ambiguous or supplied with an invalid option will not be flagged as an error. Instead the unknown option(s) will be passed to the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present, otherwise through to &lt;code&gt;@ARGV&lt;/code&gt;. This makes it possible to write wrapper scripts that process only part of the user supplied command line arguments, and pass the remaining options to some other program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21e85e4f08ba1ed663f7825a392d047ce118ae8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;printf&lt;/code&gt;, you get around this by using a block and an expression where you would place the filehandle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161b6ff35bc50314a49d188535255f199fcc9bb0" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;system()&lt;/code&gt;, both STDOUT and STDERR will go the same place as the script's STDOUT and STDERR, unless the &lt;code&gt;system()&lt;/code&gt; command redirects them. Backticks and &lt;code&gt;open()&lt;/code&gt; read &lt;b&gt;only&lt;/b&gt; the STDOUT of your command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb95ac886e1d528b24773e6c70b3ed1c1613335e" translate="yes" xml:space="preserve">
          <source>With EXPR, it returns some extra information that the debugger uses to print a stack trace. The value of EXPR indicates how many call frames to go back before the current one.</source>
          <target state="translated">通过EXPR,它返回一些额外的信息,调试器用来打印堆栈跟踪。EXPR的值表示在当前帧之前要返回多少个调用帧。</target>
        </trans-unit>
        <trans-unit id="a55096d08b5ad2fe54fd898185c93fb2c1c7dfdd" translate="yes" xml:space="preserve">
          <source>With Mac OS X 10.4 &quot;Tiger&quot; and newer, there is almost no performance penalty for non-prebound libraries. Earlier releases will suffer a greater load time than either the static library, or Apple's pre-bound dynamic library.</source>
          <target state="translated">在Mac OS X 10.4 &quot;Tiger &quot;及更新版本中,非预绑定库几乎没有性能上的损失。较早的版本会比静态库或苹果的预绑定动态库的加载时间更长。</target>
        </trans-unit>
        <trans-unit id="5f9d3d0136d8a2d2276cb1a4c4f0bb0c82be3696" translate="yes" xml:space="preserve">
          <source>With NTFS (and no CYGWIN=nontsec), there should be no problems even if perl was built on FAT.</source>
          <target state="translated">如果使用NTFS(而且没有CYGWIN=nontsec),即使perl是建立在FAT上的,也应该没有问题。</target>
        </trans-unit>
        <trans-unit id="783aaaca75cc72bad41475003df821affc75b7c5" translate="yes" xml:space="preserve">
          <source>With OO style, you can break the message arbitrarily. This means that we are no longer limited to have space for the whole message in memory, i.e. we can handle messages of any size.</source>
          <target state="translated">通过OO风格,你可以任意的打破消息。这意味着我们不再局限于在内存中拥有整个消息的空间,即我们可以处理任何大小的消息。</target>
        </trans-unit>
        <trans-unit id="aa5707019a9c4f2624f176a48761ef4f1b3f5952" translate="yes" xml:space="preserve">
          <source>With Perl &amp;gt;= 5.6.2, you can also use a line like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1bf2f77022cd9fed463a5704b297d6ff88b00d5" translate="yes" xml:space="preserve">
          <source>With Perl 5.004 you can also use the TIEHANDLE interface to access compressed files just like ordinary files:</source>
          <target state="translated">在Perl 5.004中,你也可以使用TIEHANDLE接口来访问压缩文件,就像访问普通文件一样。</target>
        </trans-unit>
        <trans-unit id="9f110b40627d54799c1a5b4c023b449d3f05b59d" translate="yes" xml:space="preserve">
          <source>With Perl 5.10 and later, the smart match operator can give you the answer with the least amount of work:</source>
          <target state="translated">在Perl 5.10及以后的版本中,智能匹配运算符可以用最少的工作量给你答案。</target>
        </trans-unit>
        <trans-unit id="4e55c608e124b42bf25bf02c154381796e1d9852" translate="yes" xml:space="preserve">
          <source>With a</source>
          <target state="translated">有一个</target>
        </trans-unit>
        <trans-unit id="cf7bad50138d4a906e034cdc8232445a6a34e8fb" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;, &lt;code&gt;charscript()&lt;/code&gt; returns the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca805fd21b2d73d6d3fa38629cb4d7c77aac2c21" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;&lt;code&gt;charblock()&lt;/code&gt; returns the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f458d9e5c6b401d23a0ff93a93cac73ffa40d782" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;, &lt;code&gt;charscript()&lt;/code&gt; returns the</source>
          <target state="translated">使用&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数&lt;/a&gt;， &lt;code&gt;charscript()&lt;/code&gt; 返回</target>
        </trans-unit>
        <trans-unit id="7cfd816e3af239ee8e3392fa5dd4b28e10c2cbf9" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;&lt;code&gt;charblock()&lt;/code&gt; returns the</source>
          <target state="translated">使用&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数&lt;/a&gt; &lt;code&gt;charblock()&lt;/code&gt; 返回</target>
        </trans-unit>
        <trans-unit id="cc06a9c18caf674053e4b44b132356a1c540f757" translate="yes" xml:space="preserve">
          <source>With a little extra work, you can get all of the groups in angle brackets even if they are in other angle brackets too. Each time you get a balanced match, remove its outer delimiter (that's the one you just matched so don't match it again) and add it to a queue of strings to process. Keep doing that until you get no matches:</source>
          <target state="translated">只要做一点额外的工作,你可以得到所有在角括号中的组,即使它们也在其他角括号中。每当你得到一个平衡的匹配,去掉它的外定界符(就是你刚刚匹配的那个,所以不要再匹配它了),然后把它添加到字符串队列中去处理。一直这样做,直到你没有得到匹配。</target>
        </trans-unit>
        <trans-unit id="a69059588956460f70f3f90c71a968d5af85c118" translate="yes" xml:space="preserve">
          <source>With a non-&lt;code&gt;DEBUGGING&lt;/code&gt; perl, the buckets starting from &lt;code&gt;128&lt;/code&gt; have a 4-byte overhead, and thus an 8192-long bucket may take up to 8188-byte allocations.</source>
          <target state="translated">使用非 &lt;code&gt;DEBUGGING&lt;/code&gt; Perl，从 &lt;code&gt;128&lt;/code&gt; 开始的存储桶会有4字节的开销，因此8192长的存储桶可能需要多达8188字节的分配。</target>
        </trans-unit>
        <trans-unit id="3f782793180910fe0c252c5c5e6b40299dd75d89" translate="yes" xml:space="preserve">
          <source>With a slurpy parameter in the signature, there is no upper limit on how many arguments may be passed. A slurpy array parameter may be nameless just like a positional parameter, in which case its only effect is to turn off the argument limit that would otherwise apply:</source>
          <target state="translated">在签名中使用一个模糊参数,对传递参数的数量没有上限。稀疏数组参数可以是无名的,就像位置参数一样,在这种情况下,它的唯一作用是关闭原本适用的参数限制。</target>
        </trans-unit>
        <trans-unit id="f9508f16c80ad6889c699daf40f43720b8251d92" translate="yes" xml:space="preserve">
          <source>With a technique called copy-on-write, the cost of copying with overload could be minimized or even completely avoided. A test implementation of COW did show performance gains for overloaded math, but introduced a performance loss due to a constant overhead for all other operations. So Math::BigInt does currently not COW.</source>
          <target state="translated">通过一种叫做copy-on-write的技术,可以将过载复制的成本降到最低,甚至完全避免。COW的测试实现确实显示出对重载数学的性能提升,但由于对其他所有操作的持续开销,引入了性能损失。所以Math::BigInt目前没有COW。</target>
        </trans-unit>
        <trans-unit id="338611254651b6fbb00a03edfd8b2e0209a2413c" translate="yes" xml:space="preserve">
          <source>With a todo block, the tests inside are expected to fail. Test::More will run the tests normally, but print out special flags indicating they are &quot;todo&quot;. &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret failures as being ok. Should anything succeed, it will report it as an unexpected success. You then know the thing you had todo is done and can remove the TODO flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ebe6d7c43f224246d4ca3387c92f6cc94b15954" translate="yes" xml:space="preserve">
          <source>With a todo block, the tests inside are expected to fail. Test::More will run the tests normally, but print out special flags indicating they are &quot;todo&quot;. &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret failures as being ok. Should anything succeed, it will report it as an unexpected success. You then know the thing you had todo is done and can remove the TODO flag.</source>
          <target state="translated">使用todo块，内部测试将失败。Test :: More将正常运行测试，但是会打印出特殊标志，表明它们是&amp;ldquo;待办事项&amp;rdquo;。&lt;a href=&quot;harness&quot;&gt;测试::线束&lt;/a&gt;会将故障解释为正常。如果成功，它将报告为意外成功。然后，您知道必须做的事情已经完成，可以删除TODO标志。</target>
        </trans-unit>
        <trans-unit id="039f5d96db075baf2e35a9428955065fad856e3f" translate="yes" xml:space="preserve">
          <source>With all of the previous done, you're now ready to call Configure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be7163284f82da14a87936dad63fbf983833559" translate="yes" xml:space="preserve">
          <source>With all of the regexes above, if the regex matched anywhere in the string, it was considered a match. To specify</source>
          <target state="translated">对于以上所有的regex,如果regex与字符串中的任何地方相匹配,则认为是匹配的。要指定</target>
        </trans-unit>
        <trans-unit id="a49675e374380fe043aff3a5f63d6512021ecfd9" translate="yes" xml:space="preserve">
          <source>With all of the regexps above, if the regexp matched anywhere in the string, it was considered a match. Sometimes, however, we'd like to specify</source>
          <target state="translated">对于上面所有的regexps,如果regexp在字符串中的任何地方匹配,就被认为是匹配的。然而,有时候,我们希望指定的是</target>
        </trans-unit>
        <trans-unit id="544d324c6a361c56f15aa84b4f308989bea67735" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 时，您应该特别小心记住以下情况：</target>
        </trans-unit>
        <trans-unit id="250cfbca6e5e22d4d573a90cd37797d2cb8d3ac5" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 时，您应该特别小心记住以下情况：</target>
        </trans-unit>
        <trans-unit id="8175ced4a0fd9d7cc491a3c946926864742f09d4" translate="yes" xml:space="preserve">
          <source>With an argument, can be used to generate a NaN with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28933cd0405c565c32304d3c729c7e6f31006ad2" translate="yes" xml:space="preserve">
          <source>With any of these, you can change file descriptors before the call:</source>
          <target state="translated">使用其中任何一种,你都可以在调用前改变文件描述符。</target>
        </trans-unit>
        <trans-unit id="944f492857a1db6c839174233fd1c02f59c056dd" translate="yes" xml:space="preserve">
          <source>With any version of Perl 5 you can use the basic OO interface:</source>
          <target state="translated">在任何版本的Perl 5中,你都可以使用基本的OO接口。</target>
        </trans-unit>
        <trans-unit id="d9bf5579433ea6ddabc4d916f0dbd99e9c0f39ff" translate="yes" xml:space="preserve">
          <source>With argument force $ENCODING_... variables to set to the given value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaaac305ec8d42934372356813b4624fa49a8ffc" translate="yes" xml:space="preserve">
          <source>With argument sets the option. Without returns the option value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108bd0cf30895e3a18d32866a5ada0ba72c0b2d2" translate="yes" xml:space="preserve">
          <source>With bundling it is possible to set several single-character options at once. For example if &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are all valid options,</source>
          <target state="translated">通过捆绑，可以一次设置多个单字符选项。例如，如果 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;v&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 均为有效选项，</target>
        </trans-unit>
        <trans-unit id="6a3391ab50835b72ad746f9bc70f0861004cbe03" translate="yes" xml:space="preserve">
          <source>With bundling it is possible to set several single-character options at once. For example if &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are all valid options,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9c20d6876f103320c9d9424556b25f81d7af24" translate="yes" xml:space="preserve">
          <source>With earlier versions of Perl, you have to do a bit more work. If you are going to make this query many times over arbitrary string values, the fastest way is probably to invert the original array and maintain a hash whose keys are the first array's values:</source>
          <target state="translated">对于早期版本的Perl,你必须做更多的工作。如果你要对任意字符串值进行多次查询,最快的方法可能是对原始数组进行反转,并维护一个哈希,其键是第一个数组的值。</target>
        </trans-unit>
        <trans-unit id="089c9811008b67cdbb35efdae3d3f3034c15c2b2" translate="yes" xml:space="preserve">
          <source>With excerpts from Perl, and contributions and suggestions from Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus, Stephen McCamant, and David Landgren.</source>
          <target state="translated">摘自Perl,以及Ronald J.Kimball、Dave Mitchell、Dominic Dunlop、Mark Jason Dominus、Stephen McCamant和David Landgren的贡献和建议。</target>
        </trans-unit>
        <trans-unit id="312cf396f9e4b4f5d83643b7fda95efc6c88ff9d" translate="yes" xml:space="preserve">
          <source>With hooks comes the ability to recurse back to the Storable engine. Indeed, hooks are regular Perl code, and Storable is convenient when it comes to serializing and deserializing things, so why not use it to handle the serialization string?</source>
          <target state="translated">有了hooks,就有了回溯到Storable引擎的能力。事实上,hooks是常规的Perl代码,而Storable在序列化和反序列化的时候很方便,为什么不用它来处理序列化字符串呢?</target>
        </trans-unit>
        <trans-unit id="2092bcf7558e6632164a74cbb09d09cc7943a0d7" translate="yes" xml:space="preserve">
          <source>With lots of help and suggestions from Dean Roehrich, Malcolm Beattie, Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer, Stephen McCamant, and Gurusamy Sarathy.</source>
          <target state="translated">在Dean Roehrich、Malcolm Beattie、Andreas Koenig、Paul Hudson、Ilya Zakharevich、Paul Marquess、Neil Bowers、Matthew Green、Tim Bunce、Spider Boardman、Ulrich Pfeifer、Stephen McCamant和Gurusamy Sarathy的帮助和建议下。</target>
        </trans-unit>
        <trans-unit id="2f32ef7ca32db627a2acbe157dc6fb77e5ecddfd" translate="yes" xml:space="preserve">
          <source>With methods 2 and 3, Perl starts parsing the input file from the beginning, unless you've specified a &lt;a href=&quot;#-x&quot;&gt;&quot;-x&quot;&lt;/a&gt; switch, in which case it scans for the first line starting with &lt;code&gt;#!&lt;/code&gt; and containing the word &quot;perl&quot;, and starts there instead. This is useful for running a program embedded in a larger message. (In this case you would indicate the end of the program using the &lt;code&gt;__END__&lt;/code&gt; token.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2d0cebca8f8c753e2f714f5c39699038d3b25f" translate="yes" xml:space="preserve">
          <source>With methods 2 and 3, Perl starts parsing the input file from the beginning, unless you've specified a &lt;b&gt;-x&lt;/b&gt; switch, in which case it scans for the first line starting with &lt;code&gt;#!&lt;/code&gt; and containing the word &quot;perl&quot;, and starts there instead. This is useful for running a program embedded in a larger message. (In this case you would indicate the end of the program using the &lt;code&gt;__END__&lt;/code&gt; token.)</source>
          <target state="translated">使用方法2和3，Perl从头开始解析输入文件，除非您指定了&lt;b&gt;-x&lt;/b&gt;开关，在这种情况下，它将扫描以 &lt;code&gt;#!&lt;/code&gt; 开头的第一行！并包含&amp;ldquo; perl&amp;rdquo;一词，然后从此处开始。这对于运行嵌入较大消息中的程序很有用。 （在这种情况下，您将使用 &lt;code&gt;__END__&lt;/code&gt; 令牌指示程序的结束。）</target>
        </trans-unit>
        <trans-unit id="6316d5824ca52c312f770e770e783e4a6d5033d6" translate="yes" xml:space="preserve">
          <source>With mod_perl and the Apache::Registry module (distributed with mod_perl), httpd will run with an embedded Perl interpreter which pre-compiles your script and then executes it within the same address space without forking. The Apache extension also gives Perl access to the internal server API, so modules written in Perl can do just about anything a module written in C can. For more on mod_perl, see &lt;a href=&quot;http://perl.apache.org/&quot;&gt;http://perl.apache.org/&lt;/a&gt;</source>
          <target state="translated">通过使用mod_perl和Apache :: Registry模块（随mod_perl分发），httpd将与嵌入式Perl解释器一起运行，该解释器预编译您的脚本，然后在相同的地址空间内执行它而不会分叉。Apache扩展还使Perl可以访问内部服务器API，因此用Perl编写的模块几乎可以执行用C编写的模块可以执行的任何操作。有关mod_perl的更多信息，请参见&lt;a href=&quot;http://perl.apache.org/&quot;&gt;http://perl.apache.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cc2eb3f9b78400953fa9a4ff9c87b68e20c7b681" translate="yes" xml:space="preserve">
          <source>With much assistance regarding shared libraries from Marc Sabatella.</source>
          <target state="translated">在共享图书馆方面得到了Marc Sabatella的大力协助。</target>
        </trans-unit>
        <trans-unit id="b462e2e8ccefffa9756bd47bbfa7c723db9b9b54" translate="yes" xml:space="preserve">
          <source>With negative offsets, it remembers its position from the end of the string when the target string is modified:</source>
          <target state="translated">在负偏移的情况下,当目标字符串被修改时,它会记住它从字符串末端开始的位置。</target>
        </trans-unit>
        <trans-unit id="00344cc849fc9376fff9de99085e79fa3cd552d0" translate="yes" xml:space="preserve">
          <source>With no MASK argument present, it returns the current operator mask of the compartment.</source>
          <target state="translated">在没有MASK参数的情况下,它返回当前隔层的操作者掩码。</target>
        </trans-unit>
        <trans-unit id="a35650496b577c95afdac0e1ebb0191fd46fd2e0" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole array (whether or not the element was specified as &lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt; ).</source>
          <target state="translated">没有参数，访问器将返回对元素整个数组的引用（无论元素是否指定为 &lt;code&gt;'@'&lt;/code&gt; 或 &lt;code&gt;'*@'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a8ef3568dccdeee73b65f3996dd1707e6feb3878" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole array (whether or not the element was specified as &lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4963e3a2e84181fb9a499ef49896fdab34cd7c" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole hash (whether or not the element was specified as &lt;code&gt;'%'&lt;/code&gt; or &lt;code&gt;'*%'&lt;/code&gt; ).</source>
          <target state="translated">不带任何参数的访问器将返回对元素整个哈希的引用（无论元素是否指定为 &lt;code&gt;'%'&lt;/code&gt; 或 &lt;code&gt;'*%'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="988bcaf50ce8ee9902f007f6fc6c2b44abddd67d" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole hash (whether or not the element was specified as &lt;code&gt;'%'&lt;/code&gt; or &lt;code&gt;'*%'&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bae0e18d43bcb818e56d07261a055232eff0bf8" translate="yes" xml:space="preserve">
          <source>With no arguments (or using &lt;code&gt;threads::all&lt;/code&gt; ) and in a list context, returns a list of all non-joined, non-detached</source>
          <target state="translated">不带参数（或使用 &lt;code&gt;threads::all&lt;/code&gt; ），并在列表上下文中，返回所有未连接，未分离的列表</target>
        </trans-unit>
        <trans-unit id="9a2c5169b8859351e115fccd32105029ad3b3e99" translate="yes" xml:space="preserve">
          <source>With no arguments (or using &lt;code&gt;threads::all&lt;/code&gt;) and in a list context, returns a list of all non-joined, non-detached</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18cf8c9e6afcd23474d7fb3a81386e0988d7bd68" translate="yes" xml:space="preserve">
          <source>With older versions of Perl, the &lt;a href=&quot;IO::String&quot;&gt;IO::String&lt;/a&gt; module provides similar functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4cfb999178855ab18f46ce9c518e1bd1ef50096" translate="yes" xml:space="preserve">
          <source>With older versions of Perl, the &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO::String&lt;/a&gt; module provides similar functionality.</source>
          <target state="translated">对于旧版本的Perl，&lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO :: String&lt;/a&gt;模块提供了类似的功能。</target>
        </trans-unit>
        <trans-unit id="789c0f1114004fe97c889b4fd162dac50dbb4785" translate="yes" xml:space="preserve">
          <source>With one exception (below), if both strings look like numbers to Perl, the magic increment will not be applied, and the strings will be treated as numbers (more specifically, integers) instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c467eeeb4f15846c2e3c26d1b4d74776d4da75d4" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is a key specifying one element of the hash; the second argument, if present, is assigned to the hash element. If the element type is &lt;code&gt;'%'&lt;/code&gt; , the accessor returns the hash element value. If the element type is &lt;code&gt;'*%'&lt;/code&gt; , a reference to the hash element is returned.</source>
          <target state="translated">有一个或两个自变量，第一个自变量是指定哈希值一个元素的键；第二个参数（如果存在）被分配给hash元素。如果元素类型为 &lt;code&gt;'%'&lt;/code&gt; ，则访问器返回哈希元素值。如果元素类型为 &lt;code&gt;'*%'&lt;/code&gt; ，则返回对哈希元素的引用。</target>
        </trans-unit>
        <trans-unit id="0bd4bcbdb7945f28a4390fecea625c7a59fd6d00" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is a key specifying one element of the hash; the second argument, if present, is assigned to the hash element. If the element type is &lt;code&gt;'%'&lt;/code&gt;, the accessor returns the hash element value. If the element type is &lt;code&gt;'*%'&lt;/code&gt;, a reference to the hash element is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="043fe821df73a58116e971eada4906da49321cca" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is an index specifying one element of the array; the second argument, if present, is assigned to the array element. If the element type is &lt;code&gt;'@'&lt;/code&gt; , the accessor returns the array element value. If the element type is &lt;code&gt;'*@'&lt;/code&gt; , a reference to the array element is returned.</source>
          <target state="translated">有一个或两个参数，第一个参数是指定数组一个元素的索引；第二个参数（如果存在）将分配给数组元素。如果元素类型为 &lt;code&gt;'@'&lt;/code&gt; ，则访问器返回数组元素值。如果元素类型为 &lt;code&gt;'*@'&lt;/code&gt; ，则返回对数组元素的引用。</target>
        </trans-unit>
        <trans-unit id="eca88cd532fb52622336dc15fcd9f2fe4531eda4" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is an index specifying one element of the array; the second argument, if present, is assigned to the array element. If the element type is &lt;code&gt;'@'&lt;/code&gt;, the accessor returns the array element value. If the element type is &lt;code&gt;'*@'&lt;/code&gt;, a reference to the array element is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d82587a9e3d9d950371c40dd7e06719bffb84440" translate="yes" xml:space="preserve">
          <source>With option -exec, walks tree in execute order, otherwise in basic order.</source>
          <target state="translated">使用选项-exec,按执行顺序走树,否则按基本顺序走。</target>
        </trans-unit>
        <trans-unit id="57d705a8d20354296c55ade02ce168e9aba3ea9c" translate="yes" xml:space="preserve">
          <source>With overloaded math, only the first two variants will result in a BigFloat:</source>
          <target state="translated">在超载的数学情况下,只有前两种变体会导致BigFloat。</target>
        </trans-unit>
        <trans-unit id="04cbc8f37da7397c953eb4dca3b6f0e0eee0dac0" translate="yes" xml:space="preserve">
          <source>With overloaded operators, it is the first (dominating) operand that determines which method is called. Here are some examples showing what actually gets called in various cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b46b3274ff332d0d8381195e802b804512dbcd" translate="yes" xml:space="preserve">
          <source>With proper care you may mix package and my (or state) &lt;code&gt;$a&lt;/code&gt; and/or &lt;code&gt;$b&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d4085fcb09a164c92639ac09b2aa2b53f4f318" translate="yes" xml:space="preserve">
          <source>With respect to character matching, there are a few more points you need to know about. First of all, not all characters can be used &quot;as is&quot; in a match. Some characters, called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549d9ba8c522ce4226592827b058814ec17aafc9" translate="yes" xml:space="preserve">
          <source>With respect to character matching, there are a few more points you need to know about. First of all, not all characters can be used 'as is' in a match. Some characters, called</source>
          <target state="translated">关于字符匹配,还有几点你需要知道。首先,并不是所有的字符都可以在匹配中 &quot;原样 &quot;使用。有些字符,被称为</target>
        </trans-unit>
        <trans-unit id="f52704b066745f4539042b4ca42ac5911b1eae8e" translate="yes" xml:space="preserve">
          <source>With respect to files, one that has the proper permission bit set to let you access the file. With respect to computer programs, one that&amp;rsquo;s written well enough that someone has a chance of figuring out what it&amp;rsquo;s trying to do.</source>
          <target state="translated">对于文件，将其设置为正确的权限位以使您可以访问文件。关于计算机程序，一个编写得很好的程序使某人有机会弄清楚它要做什么。</target>
        </trans-unit>
        <trans-unit id="3dc4eefad3d29ef780cb07bfc36df49d416959b4" translate="yes" xml:space="preserve">
          <source>With respect to loading &lt;code&gt;Exporter&lt;/code&gt; and inheriting, there are alternatives with the use of modules like &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt; .</source>
          <target state="translated">关于加载 &lt;code&gt;Exporter&lt;/code&gt; 和继承，还有一些使用模块的替代方法，例如 &lt;code&gt;base&lt;/code&gt; 和 &lt;code&gt;parent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ddfefdcb8919ff4ad4881cdfab3eb3ea6c93a49" translate="yes" xml:space="preserve">
          <source>With respect to loading &lt;code&gt;Exporter&lt;/code&gt; and inheriting, there are alternatives with the use of modules like &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64aab757411e3efe138dbb9f7787c6359c1eec8b" translate="yes" xml:space="preserve">
          <source>With some firewalls active mode does not work as the server cannot connect to your machine (because you are behind a firewall) and the firewall does not re-write the command. In this case you should set &lt;code&gt;ftp_ext_passive&lt;/code&gt; to a</source>
          <target state="translated">对于某些防火墙，活动模式不起作用，因为服务器无法连接到您的计算机（因为您位于防火墙后面），并且防火墙不会重新编写命令。在这种情况下，您应该将 &lt;code&gt;ftp_ext_passive&lt;/code&gt; 设置为</target>
        </trans-unit>
        <trans-unit id="39e7b288b06e2af98b83632e08ab80e03b9bf7c3" translate="yes" xml:space="preserve">
          <source>With source filters, you can store the text of your script compressed and use a source filter to uncompress it for Perl's parser:</source>
          <target state="translated">通过源码过滤器,你可以将脚本的文本压缩存储,然后使用源码过滤器为Perl的解析器解压。</target>
        </trans-unit>
        <trans-unit id="f3d0833032fe049783c845044de2a75767e40f62" translate="yes" xml:space="preserve">
          <source>With support for &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; this may be circumvented - unless one of DLLs is started from</source>
          <target state="translated">在支持 &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; 的情况下，可以避免这种情况-除非从以下一个DLL启动</target>
        </trans-unit>
        <trans-unit id="741296e189dd1627ab6af5dc824e2c81acff153a" translate="yes" xml:space="preserve">
          <source>With that trick MakeMaker will only read the first line and thus read the underscore, while the perl interpreter will evaluate the $VERSION and convert the string into a number. Later operations that treat $VERSION as a number will then be able to do so without provoking a warning about $VERSION not being a number.</source>
          <target state="translated">通过这个技巧,MakeMaker将只读取第一行,从而读取下划线,而perl解释器将评估$VERSION,并将字符串转换成一个数字。之后的操作如果把$VERSION当作数字来处理,就不会引起关于$VERSION不是数字的警告。</target>
        </trans-unit>
        <trans-unit id="fa542340f7199357b9ddb7d211923c323666ef12" translate="yes" xml:space="preserve">
          <source>With the &quot;tcp&quot; protocol the ping() method attempts to establish a connection to the remote host's echo port. If the connection is successfully established, the remote host is considered reachable. No data is actually echoed. This protocol does not require any special privileges but has higher overhead than the &quot;udp&quot; and &quot;icmp&quot; protocols.</source>
          <target state="translated">对于 &quot;tcp &quot;协议,ping()方法会尝试建立与远程主机回音端口的连接。如果连接成功建立,则认为远程主机是可到达的。实际上没有数据被呼应。这个协议不需要任何特殊的权限,但比 &quot;udp &quot;和 &quot;icmp &quot;协议的开销大。</target>
        </trans-unit>
        <trans-unit id="0c9c2cd66698ade01d6241c0c3475076fe41182f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma you can use the &lt;code&gt;:locale&lt;/code&gt; layer</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 编译指示，您可以使用 &lt;code&gt;:locale&lt;/code&gt; 层</target>
        </trans-unit>
        <trans-unit id="e4721b12184df4c626e83aff44b61b424dee2894" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. are immediately available for use in the replacement expression. With the global modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; will search and replace all occurrences of the regex in the string:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 运算符，匹配的变量 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等可立即用于替换表达式中。使用global修饰符， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; 将搜索并替换字符串中所有出现的正则表达式：</target>
        </trans-unit>
        <trans-unit id="a5f3ac7301bb1927406401553bc7979a7058d48f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma you can control the behaviour of the builtin &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 编译指示，您可以控制内置 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 函数的行为。</target>
        </trans-unit>
        <trans-unit id="ed30d894507576a6aff023249124e00f485a0445" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;IN&lt;/code&gt; subpragma you can declare the default layers of input streams, and with the &lt;code&gt;OUT&lt;/code&gt; subpragma you can declare the default layers of output streams. With the &lt;code&gt;IO&lt;/code&gt; subpragma (may be omitted for &lt;code&gt;:utf8&lt;/code&gt;, &lt;code&gt;:locale&lt;/code&gt;, or &lt;code&gt;:encoding&lt;/code&gt;) you can control both input and output streams simultaneously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640e6849be58e830210cdb457742bd0e5d46239f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;IN&lt;/code&gt; subpragma you can declare the default layers of input streams, and with the &lt;code&gt;OUT&lt;/code&gt; subpragma you can declare the default layers of output streams. With the &lt;code&gt;IO&lt;/code&gt; subpragma you can control both input and output streams simultaneously.</source>
          <target state="translated">使用 &lt;code&gt;IN&lt;/code&gt; 子编译，可以声明输入流的默认层，而使用 &lt;code&gt;OUT&lt;/code&gt; 子编译，可以声明输出流的默认层。使用 &lt;code&gt;IO&lt;/code&gt; 子实用程序，您可以同时控制输入和输出流。</target>
        </trans-unit>
        <trans-unit id="9a9bb48f29cda9ceed93d7949280d0a2ae7a947b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; logical name defined as &quot;ENABLE&quot;, setting &lt;code&gt;$?&lt;/code&gt; will cause the new value to be encoded into &lt;code&gt;$^E&lt;/code&gt; so that either the original parent or child exit status values 0 to 255 can be automatically recovered by C programs expecting _POSIX_EXIT behavior. If both a parent and a child exit value are non-zero, then it will be assumed that this is actually a VMS native status value to be passed through. The special value of 0xFFFF is almost a NOOP as it will cause the current native VMS status in the C library to become the current native Perl VMS status, and is handled this way as it is known to not be a valid native VMS status value. It is recommend that only values in the range of normal Unix parent or child status numbers, 0 to 255 are used.</source>
          <target state="translated">将 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 逻辑名称定义为&amp;ldquo; ENABLE&amp;rdquo;，设置 &lt;code&gt;$?&lt;/code&gt; 将导致将新值编码为 &lt;code&gt;$^E&lt;/code&gt; 以便预期_POSIX_EXIT行为的C程序可以自动恢复原始的父出口或子出口状态值0至255。如果父出口值和子出口值都不为零，则将假定这实际上是要传递的VMS本机状态值。特殊值0xFFFF几乎是NOOP，因为它将导致C库中的当前本机VMS状态变为当前本机Perl VMS状态，并以这种方式进行处理，因为它不是有效的本机VMS状态值。建议仅使用正常Unix父或子状态编号范围内的值（0到255）。</target>
        </trans-unit>
        <trans-unit id="d83714fab9481b19a76857b0c66b38bb676d9244" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;open&lt;/code&gt; pragma you can use the &lt;code&gt;:locale&lt;/code&gt; layer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aef762dfae7dd14d56c63866d88c9f9105ac20d" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;s///&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc. are immediately available for use in the replacement expression. With the global modifier, &lt;code&gt;s///g&lt;/code&gt; will search and replace all occurrences of the regex in the string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2822b5f3a724906c266471a5abc1878fe1a5daf9" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;sort&lt;/code&gt; pragma you can control the behaviour of the builtin &lt;code&gt;sort()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85c0b58283979a05b1d958cf7b8e77666b21187" translate="yes" xml:space="preserve">
          <source>With the C-style operators that would have been written like this:</source>
          <target state="translated">如果用C式运算符,本来是这样写的。</target>
        </trans-unit>
        <trans-unit id="12231f536f1fde7f945e73b86c0bb0963f5133af" translate="yes" xml:space="preserve">
          <source>With the FCGI module (from CPAN) and the mod_fastcgi module (available from &lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/&lt;/a&gt; ) each of your Perl programs becomes a permanent CGI daemon process.</source>
          <target state="translated">使用FCGI模块（来自CPAN）和mod_fastcgi模块（可从&lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/获得&lt;/a&gt;），每个Perl程序都将成为永久的CGI守护进程。</target>
        </trans-unit>
        <trans-unit id="e9f0f761b750ef587b104ca22707f7d417110d25" translate="yes" xml:space="preserve">
          <source>With the MASK argument present, it sets the operator mask for the compartment (equivalent to calling the deny_only method).</source>
          <target state="translated">在MASK参数存在的情况下,它为隔间设置操作者掩码(相当于调用deny_only方法)。</target>
        </trans-unit>
        <trans-unit id="a26ddc37c924b20873cf0fb8deaac6c02f3c0643" translate="yes" xml:space="preserve">
          <source>With the _POSIX_EXIT macro set, the Unix exit value of zero is represented as a VMS native status of 1, and the Unix values from 2 to 255 are encoded by the equation:</source>
          <target state="translated">在设置了_POSIX_EXIT宏后,Unix的退出值为0,表示为VMS的本机状态为1,从2到255的Unix值用公式编码。</target>
        </trans-unit>
        <trans-unit id="ca23bf605fbab54b13a6b11fd9b026fcad525316" translate="yes" xml:space="preserve">
          <source>With the above regexp all content following (and including) any of the given &lt;code&gt;=head1&lt;/code&gt; headings will be shown. It is possible to restrict the output to particular subsections only, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b04e80858e882edcc84d0f324c4fa0f1bc41eaae" translate="yes" xml:space="preserve">
          <source>With the check_sigs parameter you can turn signature checking on and off. The default is off for now because the whole tool chain for the functionality is not yet considered mature by some. The author of CPAN.pm would recommend setting it to true most of the time and turning it off only if it turns out to be annoying.</source>
          <target state="translated">通过check_sigs参数,你可以开启和关闭签名检查。目前默认的是关闭,因为整个工具链的功能还没有被一些人认为是成熟的。CPAN.pm的作者建议在大多数情况下将其设置为true,只有当它变得很烦人时才将其关闭。</target>
        </trans-unit>
        <trans-unit id="65d6f831578499e9dbe5b97d3e54d9d6970d12d6" translate="yes" xml:space="preserve">
          <source>With the completion of Example 4, we now have an easy way to simulate some real-life libraries whose interfaces may not be the cleanest in the world. We shall now continue with a discussion of the arguments passed to the &lt;b&gt;xsubpp&lt;/b&gt; compiler.</source>
          <target state="translated">完成示例4后，我们现在有了一种简单的方法来模拟一些现实世界的库，这些库的接口可能不是世界上最干净的。现在，我们将继续讨论传递给&lt;b&gt;xsubpp&lt;/b&gt;编译器的参数。</target>
        </trans-unit>
        <trans-unit id="1f205214a6ba2cf07a234149bf2d1460c5296c50" translate="yes" xml:space="preserve">
          <source>With the creation of the &lt;code&gt;IO::Compress&lt;/code&gt; and &lt;code&gt;IO::Uncompress&lt;/code&gt; modules no new features are planned for &lt;code&gt;Compress::Zlib&lt;/code&gt; - the new modules do everything that &lt;code&gt;Compress::Zlib&lt;/code&gt; does and then some. Development on &lt;code&gt;Compress::Zlib&lt;/code&gt; will be limited to bug fixes only.</source>
          <target state="translated">随着 &lt;code&gt;IO::Compress&lt;/code&gt; 和 &lt;code&gt;IO::Uncompress&lt;/code&gt; 模块的创建，没有为 &lt;code&gt;Compress::Zlib&lt;/code&gt; 计划新功能-新模块完成了 &lt;code&gt;Compress::Zlib&lt;/code&gt; 工作，然后执行了一些工作。在 &lt;code&gt;Compress::Zlib&lt;/code&gt; 进行的开发将仅限于错误修复。</target>
        </trans-unit>
        <trans-unit id="257b1120ebcd7fe1453a131da8ee68f42d2f7003" translate="yes" xml:space="preserve">
          <source>With the default setting of &lt;code&gt;$Storable::flags&lt;/code&gt; = 6, creating or destroying random objects, even renamed objects can be controlled by an attacker. See CVE-2015-1592 and its metasploit module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f3553b9522af30d1dac804157bedd65e6495d3" translate="yes" xml:space="preserve">
          <source>With the default setting the size is limited to 128MB. The -1 removes this limit. If the &quot;make test&quot; fails please change your /etc/security/limits as stated above.</source>
          <target state="translated">默认设置下,大小限制为128MB。而-1则会取消这个限制。如果 &quot;make test &quot;失败,请如上所述修改你的/etc/security/limits。</target>
        </trans-unit>
        <trans-unit id="9b9699d8827c96371e7103bd01aa95e9549d18da" translate="yes" xml:space="preserve">
          <source>With the example above, you knew to look for &lt;code&gt;Perl_pp_add&lt;/code&gt; , but what if there were multiple calls to it all over the place, or you didn't know what the op was you were looking for?</source>
          <target state="translated">在上面的示例中，您知道要查找 &lt;code&gt;Perl_pp_add&lt;/code&gt; ，但是如果到处都多次调用它，或者您不知道要查找的操作是什么呢？</target>
        </trans-unit>
        <trans-unit id="cfa6b797e8e5233002fffa69434e7ca138b4ff32" translate="yes" xml:space="preserve">
          <source>With the example above, you knew to look for &lt;code&gt;Perl_pp_add&lt;/code&gt;, but what if there were multiple calls to it all over the place, or you didn't know what the op was you were looking for?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65607d779f766d1b6b4828b7428d0ded3d690325" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 32-bit mode.</source>
          <target state="translated">使用下面的选项可以得到一个在32位模式下通过所有make测试的Perl版本。</target>
        </trans-unit>
        <trans-unit id="a8358873bd6ba12b8e2a5bea80bf9adbb46e0a6e" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">使用下面的选项可以得到一个在64位模式下通过所有make测试的Perl版本。</target>
        </trans-unit>
        <trans-unit id="26bc1ab7fe70714950b9630e3ca1a3522b890186" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">使用下面的选项,你可以得到一个线程化的Perl版本,它可以通过64位模式下的所有make测试。</target>
        </trans-unit>
        <trans-unit id="653ecd70c393a4f98976d6cf49198158a3d68bae" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in threaded 32-bit mode, which is the default configuration for the Perl builds that AIX ships with.</source>
          <target state="translated">使用下面的选项,你可以得到一个线程化的Perl版本,它可以在线程化的32位模式下通过所有的make测试,这是AIX的Perl构建的默认配置。</target>
        </trans-unit>
        <trans-unit id="aeae9f602df12b1cbf706e0ffe90fc7d11fa8d65" translate="yes" xml:space="preserve">
          <source>With the help of Jarkko Hietaniemi the Configure system has been tweaked to run under abc-shell so the recommend build process is as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826dec98b275c7a952ab77d69c22223ec197d3b5" translate="yes" xml:space="preserve">
          <source>With the introduction of lexical warnings, mandatory warnings now become</source>
          <target state="translated">随着词性警告的引入,强制警告现在变成了。</target>
        </trans-unit>
        <trans-unit id="cb83c7552e22c7b5119774691db23c4fd72dba00" translate="yes" xml:space="preserve">
          <source>With the introduction of the</source>
          <target state="translated">引入了</target>
        </trans-unit>
        <trans-unit id="dd358809edabd87f2081065d37eb93940f155fac" translate="yes" xml:space="preserve">
          <source>With the lock released, process &quot;B&quot; can now continue. It also updates the database and unfortunately it too modifies the data that was in its initial buffer. Once that data gets flushed to disk it will overwrite some/all of the changes process &quot;A&quot; made to the database.</source>
          <target state="translated">随着锁的释放,进程 &quot;B &quot;现在可以继续。它还更新了数据库,不幸的是它也修改了最初缓冲区中的数据。一旦这些数据被刷新到磁盘上,它将覆盖进程 &quot;A &quot;对数据库所做的一些/全部修改。</target>
        </trans-unit>
        <trans-unit id="b4b71a45e3d179fe5db4257fdf8f0f1934140fcb" translate="yes" xml:space="preserve">
          <source>With the release 5.003_01 the dynamically loadable libraries should be rebuilt when a different version of Perl is compiled. In particular, DLLs (including</source>
          <target state="translated">随着5.003_01版本的发布,当编译不同版本的Perl时,动态加载的库应该被重建。特别是,DLLs(包括</target>
        </trans-unit>
        <trans-unit id="a313290bcf78e6ca63c8b821c60748978a4d212c" translate="yes" xml:space="preserve">
          <source>With this keyword present &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;&quot;The RETVAL Variable&quot;&lt;/a&gt; is created, and in the generated call to the subroutine this variable is assigned to, but the value of this variable is not going to be used in the auto-generated code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5325c34a4ae29cf34042f77f365e0b89df2159a0" translate="yes" xml:space="preserve">
          <source>With this keyword present &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;The RETVAL Variable&lt;/a&gt; is created, and in the generated call to the subroutine this variable is assigned to, but the value of this variable is not going to be used in the auto-generated code.</source>
          <target state="translated">在存在此关键字的情况下，&lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;将&lt;/a&gt;创建RETVAL变量，并在对该子例程的生成的调用中将其分配给该变量，但是该变量的值将不会在自动生成的代码中使用。</target>
        </trans-unit>
        <trans-unit id="92fdd49156ba7199f10cc8d72686bcba30a111b6" translate="yes" xml:space="preserve">
          <source>With this method you can specify your own boolean values for decoding - on decode, JSON &lt;code&gt;false&lt;/code&gt; will be decoded as a copy of &lt;code&gt;$false&lt;/code&gt;, and JSON &lt;code&gt;true&lt;/code&gt; will be decoded as &lt;code&gt;$true&lt;/code&gt; (&quot;copy&quot; here is the same thing as assigning a value to another variable, i.e. &lt;code&gt;$copy = $false&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666c6c1292ea8eefe8526f26c75c36dbe91118ff" translate="yes" xml:space="preserve">
          <source>With this module, simply change all &lt;code&gt;use_ok&lt;/code&gt; in test scripts to &lt;code&gt;use ok&lt;/code&gt;, and they will be executed at &lt;code&gt;BEGIN&lt;/code&gt; time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="153c87b7fb53ffdf16b2513e4ef9fbf84bb1453a" translate="yes" xml:space="preserve">
          <source>With this module, simply change all &lt;code&gt;use_ok&lt;/code&gt; in test scripts to &lt;code&gt;use ok&lt;/code&gt;, and they will be executed at &lt;code&gt;BEGIN&lt;/code&gt; time. The explicit space after &lt;code&gt;use&lt;/code&gt; makes it clear that this is a single compile-time action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7c25b6745f51eae37c62a2374f7ba131484e1b" translate="yes" xml:space="preserve">
          <source>With this option, the rendering of each statement (starting with the nextstate OP) will be preceded by the 1st line of source code that generates it. For example:</source>
          <target state="translated">使用这个选项,每条语句(从nextstate OP开始)的渲染将在生成它的第1行源代码之前。例如</target>
        </trans-unit>
        <trans-unit id="8f18c563efb0b7956e6e194500e98dba172fcbe5" translate="yes" xml:space="preserve">
          <source>With this syntax, the whitespace character(s) after the &quot;C&amp;lt;&amp;lt;&amp;lt;&quot; and before the &quot;&amp;gt;&amp;gt;&amp;gt;&quot; (or whatever letter) are</source>
          <target state="translated">使用这种语法，&amp;ldquo; C &amp;lt;&amp;lt;&amp;lt;&amp;rdquo;之后和&amp;ldquo; &amp;gt;&amp;gt;&amp;gt;&amp;rdquo;（或任何字母）之前的空格字符是</target>
        </trans-unit>
        <trans-unit id="9b739cdb3f9d5a8eac7c3872d89896d374a02d63" translate="yes" xml:space="preserve">
          <source>With this, &quot;somepackage&quot; will be required, then the stash is inspected, and each function is rendered.</source>
          <target state="translated">有了这个,就需要 &quot;somepackage&quot;,然后检查储藏室,每个功能都会呈现。</target>
        </trans-unit>
        <trans-unit id="a5fec2f4d5db8c4f13f212d9ea51033367a444e6" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;charinrange()&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if its input code point maps to &lt;code&gt;$default&lt;/code&gt; . You can avoid this by omitting the &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement, and adding a line after the loop to handle the final element of the inversion map.</source>
          <target state="translated">这样，如果 &lt;code&gt;charinrange()&lt;/code&gt; 的输入代码点映射到 &lt;code&gt;$default&lt;/code&gt; 它将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。您可以通过省略 &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 一条语句并在循环后添加一行以处理反转映射的最后一个元素来避免这种情况。</target>
        </trans-unit>
        <trans-unit id="1fa4ea5d2b0cc15e776882f8e7626028cc55d8d1" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;charinrange()&lt;/code&gt; will return &lt;code&gt;undef&lt;/code&gt; if its input code point maps to &lt;code&gt;$default&lt;/code&gt;. You can avoid this by omitting the &lt;code&gt;next&lt;/code&gt; statement, and adding a line after the loop to handle the final element of the inversion map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf65bbf1a94d413d2ba7d4e9b042fb1c11c5b955" translate="yes" xml:space="preserve">
          <source>With those two in hand, you should add</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dae05359217975cb78e41e5b34deca474650edf" translate="yes" xml:space="preserve">
          <source>With threads one must be careful to make sure they all have a chance to run to completion, assuming that is what you want.</source>
          <target state="translated">对于线程,人们必须小心翼翼地确保它们都有机会运行完成,假设这是你想要的。</target>
        </trans-unit>
        <trans-unit id="caa257633e4cd0d103eaaa262d9da80593127c23" translate="yes" xml:space="preserve">
          <source>With todo tests, it's best to have the tests actually run. That way you'll know when they start passing. Sometimes this isn't possible. Often a failing test will cause the whole program to die or hang, even inside an &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; with and using &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;. In these extreme cases you have no choice but to skip over the broken tests entirely.</source>
          <target state="translated">使用待办事项测试，最好让测试实际运行。这样，您就会知道它们何时开始通过。有时这是不可能的。测试失败通常会导致整个程序死机或挂起，即使在使用并使用 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; 中也是如此。在这些极端情况下，您别无选择，只能完全跳过损坏的测试。</target>
        </trans-unit>
        <trans-unit id="72faa2ea768ae70d5c7c6ca8ac92ad17c2ec51b0" translate="yes" xml:space="preserve">
          <source>With todo tests, it's best to have the tests actually run. That way you'll know when they start passing. Sometimes this isn't possible. Often a failing test will cause the whole program to die or hang, even inside an &lt;code&gt;eval BLOCK&lt;/code&gt; with and using &lt;code&gt;alarm&lt;/code&gt;. In these extreme cases you have no choice but to skip over the broken tests entirely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec0e094c2438c09cc3dbc2cdfeb2a697dd782dc5" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;(?[ ])&lt;/code&gt; , no literal characters are allowed unless they are within an inner pair of square brackets, like</source>
          <target state="translated">在 &lt;code&gt;(?[ ])&lt;/code&gt; ，不允许文字字符，除非它们在一对方括号内，例如</target>
        </trans-unit>
        <trans-unit id="2c0a661c629aabc7b0ae903d13c19ad238648286" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;(?[ ])&lt;/code&gt;, no literal characters are allowed unless they are within an inner pair of square brackets, like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8425db1df10e66ba739a46b6d044fcd9cc27fd" translate="yes" xml:space="preserve">
          <source>Within Perl, you may use this directly:</source>
          <target state="translated">在Perl中,你可以直接使用这个。</target>
        </trans-unit>
        <trans-unit id="34e265601157e7965a7e7bfdb3408a61baf139df" translate="yes" xml:space="preserve">
          <source>Within USS your /etc/profile or $HOME/.profile may limit your ulimit settings. Check that the following command returns reasonable values:</source>
          <target state="translated">在 USS 中,你的 /etc/profile 或 $HOME/.profile 可能会限制你的 ulimit 设置。检查以下命令是否返回合理的值。</target>
        </trans-unit>
        <trans-unit id="a1b6f4407e8eee6ed8eafbd79c8d18589c6adc10" translate="yes" xml:space="preserve">
          <source>Within []-length '%c' not allowed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ba20619ba09719c47471e336e4ab5403150666" translate="yes" xml:space="preserve">
          <source>Within a Pod block, there are &lt;b&gt;Pod paragraphs&lt;/b&gt;. A Pod paragraph consists of non-blank lines of text, separated by one or more blank lines.</source>
          <target state="translated">在Pod块中，有&lt;b&gt;Pod段落&lt;/b&gt;。Pod段落由非空白文本行组成，并由一个或多个空白行分隔。</target>
        </trans-unit>
        <trans-unit id="e21031e24f9ec987f957a61688b27e62b9c110c1" translate="yes" xml:space="preserve">
          <source>Within a character class:</source>
          <target state="translated">在一个角色类内。</target>
        </trans-unit>
        <trans-unit id="40c178236d58dee9559c7a2a4195e7fba2bd546e" translate="yes" xml:space="preserve">
          <source>Within a pattern, you may designate subpatterns for later reference by enclosing them in parentheses, and you may refer back to the</source>
          <target state="translated">在一个模式中,你可以用括号指定子模式供以后参考,你也可以回溯至</target>
        </trans-unit>
        <trans-unit id="0cfdb7962d912e72a66b4f3d5343b1e5e212ac27" translate="yes" xml:space="preserve">
          <source>Within a subroutine the array &lt;code&gt;@_&lt;/code&gt; contains the parameters passed to that subroutine. Inside a subroutine, &lt;code&gt;@_&lt;/code&gt; is the default array for the array operators &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在子例程中，数组 &lt;code&gt;@_&lt;/code&gt; 包含传递给该子例程的参数。在子例程中，@ &lt;code&gt;@_&lt;/code&gt; 是数组运算符 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 的默认数组。</target>
        </trans-unit>
        <trans-unit id="e22e0024e5aeb5956fe2008749d86a9a403a100c" translate="yes" xml:space="preserve">
          <source>Within a subroutine the array &lt;code&gt;@_&lt;/code&gt; contains the parameters passed to that subroutine. Inside a subroutine, &lt;code&gt;@_&lt;/code&gt; is the default array for the array operators &lt;code&gt;pop&lt;/code&gt; and &lt;code&gt;shift&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61eb6fb3f1061f743841ee282bbf0ef293486491" translate="yes" xml:space="preserve">
          <source>Within each function inside each Xsub, print to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab4fe9703eceeab90b6dcb41e63f66c50a795d5" translate="yes" xml:space="preserve">
          <source>Within search patterns (which also undergo double-quotish substitution) there is an unfortunate ambiguity: Is &lt;code&gt;/$foo[bar]/&lt;/code&gt; to be interpreted as &lt;code&gt;/${foo}[bar]/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is a character class for the regular expression) or as &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is the subscript to array @foo)? If @foo doesn't otherwise exist, then it's obviously a character class. If @foo exists, Perl takes a good guess about &lt;code&gt;[bar]&lt;/code&gt; , and is almost always right. If it does guess wrong, or if you're just plain paranoid, you can force the correct interpretation with curly braces as above.</source>
          <target state="translated">在搜索模式（也进行双引号替换）中，存在一个模糊的歧义： &lt;code&gt;/$foo[bar]/&lt;/code&gt; 被解释为 &lt;code&gt;/${foo}[bar]/&lt;/code&gt; （其中 &lt;code&gt;[bar]&lt;/code&gt; 是正则表达式）还是 &lt;code&gt;/${foo[bar]}/&lt;/code&gt; （其中 &lt;code&gt;[bar]&lt;/code&gt; 是数组@foo的下标）？如果@foo不存在，则显然是字符类。如果@foo存在，Perl会对 &lt;code&gt;[bar]&lt;/code&gt; 做出很好的猜测，并且几乎总是正确的。如果确实猜错了，或者只是个偏执狂，则可以如上所述使用花括号强行进行正确的解释。</target>
        </trans-unit>
        <trans-unit id="7cb74f80aa6eb14f52d2f4452df6c30aa1982c05" translate="yes" xml:space="preserve">
          <source>Within search patterns (which also undergo double-quotish substitution) there is an unfortunate ambiguity: Is &lt;code&gt;/$foo[bar]/&lt;/code&gt; to be interpreted as &lt;code&gt;/${foo}[bar]/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is a character class for the regular expression) or as &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is the subscript to array @foo)? If @foo doesn't otherwise exist, then it's obviously a character class. If @foo exists, Perl takes a good guess about &lt;code&gt;[bar]&lt;/code&gt;, and is almost always right. If it does guess wrong, or if you're just plain paranoid, you can force the correct interpretation with curly braces as above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84dbb525d8c49a11b671ff1144decfba831a5a9" translate="yes" xml:space="preserve">
          <source>Within strings that are to be displayed in a fixed-length text field, each control character is substituted by a space. (But remember the special meaning of &lt;code&gt;\r&lt;/code&gt; when using fill mode.) This is done to avoid misalignment when control characters &quot;disappear&quot; on some output media.</source>
          <target state="translated">在要在固定长度的文本字段中显示的字符串中，每个控制字符都用空格代替。（但是，请记住使用 &lt;code&gt;\r&lt;/code&gt; 填充模式时\ r的特殊含义。）这样做是为了避免某些输出媒体上的控制字符&amp;ldquo;消失&amp;rdquo;时出现未对齐的情况。</target>
        </trans-unit>
        <trans-unit id="4456754ccf74e411d5ea49ec8792a5f2c7c3945a" translate="yes" xml:space="preserve">
          <source>Within that basic form, add the parts that you need to insert, change, or delete lines.</source>
          <target state="translated">在该基本表格中,添加需要插入、更改或删除行的部分。</target>
        </trans-unit>
        <trans-unit id="8cbc5afc548aa028061d92c2e27d708ba5cdc361" translate="yes" xml:space="preserve">
          <source>Within that module, create an &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine.</source>
          <target state="translated">在该模块中，创建一个 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程。</target>
        </trans-unit>
        <trans-unit id="dff20e9d902ef01082006d18ff0c36d8795b519a" translate="yes" xml:space="preserve">
          <source>Within that module, create an &lt;code&gt;import&lt;/code&gt; subroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c44a88f26bc68b39089193962c587ad7e818543" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine do a call to &lt;code&gt;filter_add&lt;/code&gt; , passing it either a subroutine reference.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程中，调用 &lt;code&gt;filter_add&lt;/code&gt; ，将其传递给子例程引用。</target>
        </trans-unit>
        <trans-unit id="5abecf0e7e2c92cb0f99df6a077dc9ac3a61e15b" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;import&lt;/code&gt; subroutine do a call to &lt;code&gt;filter_add&lt;/code&gt;, passing it either a subroutine reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ccfeaad3b7f2de2f94c5b7b2a2afe57c62216c" translate="yes" xml:space="preserve">
          <source>Within the alternative numbering group, group numbers start at the same position for each alternative. After the group, numbering continues with one higher than the maximum reached across all the alternatives.</source>
          <target state="translated">在备选编号组内,每个备选方案的组号从同一位置开始。在该组之后,以高于所有替代品所达到的最大值的一个数字继续编号。</target>
        </trans-unit>
        <trans-unit id="bee307dd55ae8e02f4730b754c6aca4828fa5f41" translate="yes" xml:space="preserve">
          <source>Within the anonymous subroutine or block that is passed to &lt;code&gt;FILTER&lt;/code&gt; , process the contents of $_ to change the source code in the desired manner.</source>
          <target state="translated">在传递给 &lt;code&gt;FILTER&lt;/code&gt; 的匿名子例程或块中，处理$ _的内容以所需的方式更改源代码。</target>
        </trans-unit>
        <trans-unit id="f2c9c97c479e458c15e3c5d21939c42abe0d2569" translate="yes" xml:space="preserve">
          <source>Within the anonymous subroutine or block that is passed to &lt;code&gt;FILTER&lt;/code&gt;, process the contents of $_ to change the source code in the desired manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dffaf4183817eca592a98bbc21aa16f78f04d43" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;use feature 'unicode_strings'&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c20e56f1d9e34b6bd5de0acc2c9d7db7958c51" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;use feature 'unicode_strings' &lt;/a&gt;</source>
          <target state="translated">在使用范围内的&lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;功能'unicode_strings'&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f89e477d30d08ce7cdab550d7ebf952c865e297" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt;, all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cdd83d3707c192ff676dcfeb7f714897a412bb4" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;&lt;code&gt;use locale 'not_characters'&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;perllocale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt; and the current locale is a UTF-8 locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db5115b248b9b3a92796783fe0ad72c64d3ee250" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;use locale 'not_characters' &lt;/a&gt;, or &lt;a href=&quot;perllocale&quot;&gt;use locale &lt;/a&gt; and the current locale is a UTF-8 locale.</source>
          <target state="translated">在&lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;使用区域设置'not_characters'&lt;/a&gt;或&lt;a href=&quot;perllocale&quot;&gt;使用区域设置&lt;/a&gt;的范围内，当前区域设置为UTF-8区域设置。</target>
        </trans-unit>
        <trans-unit id="4b75686c25d4349996112a3e43d160bed9377b64" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 或更高的&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;范围内</target>
        </trans-unit>
        <trans-unit id="921e8cdb506222d3c5cb715870308743278f73c9" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 的范围内，无论字符串是否编码为UTF-8，都引用所有非ASCII Latin1代码点。如上所述，语言环境不会影响ASCII范围字符的引用。这可以防止出现诸如 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 字符的语言环境。被认为是文字字符。</target>
        </trans-unit>
        <trans-unit id="7f97b0baeb5c1f48ecb7c6036a913594c0cf832a" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 的&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;范围内</target>
        </trans-unit>
        <trans-unit id="6c6da8dacdcff581b760f12d305142c260f19722" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 的范围内，无论字符串是否编码为UTF-8，都引用所有非ASCII Latin1代码点。如上所述，语言环境不会影响ASCII范围字符的引用。这可以防止出现诸如 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 字符的语言环境。被认为是文字字符。</target>
        </trans-unit>
        <trans-unit id="9be64790ef4be673df7cd3468e821cd802e4c982" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;use 5.012&lt;/code&gt; or higher</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f08cf765adbbec5334990e6d1e73f436a06d62" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;use re 'strict'&lt;/code&gt; in a regular expression pattern, you included an unescaped &lt;code&gt;}&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt; which was interpreted literally. These two characters are sometimes metacharacters, and sometimes literals, depending on what precedes them in the pattern. This is unlike the similar &lt;code&gt;)&lt;/code&gt; which is always a metacharacter unless escaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872708d75ba2c62155c9282b19d1ffd74c4ecb87" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;use utf8&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93e8b9c84e9c172138891ffbac960fd8330a481" translate="yes" xml:space="preserve">
          <source>Within the subroutine reference, call &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; to &quot;prime&quot; $_ with source code data from the source file that will &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; your module. Check the status value returned to see if any source code was actually read in.</source>
          <target state="translated">在子例程引用中， &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 将使用模块的源文件中的源代码数据，调用 &lt;code&gt;filter_read&lt;/code&gt; 或 &lt;code&gt;filter_read_exact&lt;/code&gt; 来对$ _进行&amp;ldquo; prime&amp;rdquo; 。检查返回的状态值以查看是否实际读入任何源代码。</target>
        </trans-unit>
        <trans-unit id="de9983c2f6aa6265b66999a54845fc283501a6b7" translate="yes" xml:space="preserve">
          <source>Within the subroutine reference, call &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; to &quot;prime&quot; $_ with source code data from the source file that will &lt;code&gt;use&lt;/code&gt; your module. Check the status value returned to see if any source code was actually read in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5ec220eb3f4bb73f8ef5f923e39ec8ab09a071" translate="yes" xml:space="preserve">
          <source>Within the while loop we call accept() and check to see if it returns a false value. This would normally indicate a system error needs to be reported. However, the introduction of safe signals (see &lt;a href=&quot;#Deferred-Signals-%28Safe-Signals%29&quot;&gt;&quot;Deferred Signals (Safe Signals)&quot;&lt;/a&gt; above) in Perl 5.8.0 means that accept() might also be interrupted when the process receives a signal. This typically happens when one of the forked subprocesses exits and notifies the parent process with a CHLD signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5dc8da9477105396ff0284ea2a7a7433b232a3" translate="yes" xml:space="preserve">
          <source>Within the while loop we call accept() and check to see if it returns a false value. This would normally indicate a system error needs to be reported. However, the introduction of safe signals (see &lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals)&lt;/a&gt; above) in Perl 5.8.0 means that accept() might also be interrupted when the process receives a signal. This typically happens when one of the forked subprocesses exits and notifies the parent process with a CHLD signal.</source>
          <target state="translated">在while循环中，我们调用accept（）并检查其是否返回假值。这通常表示需要报告系统错误。但是，在Perl 5.8.0中引入了安全信号（请参阅上面的&lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;延迟信号（安全信号）&lt;/a&gt;），这意味着当进程接收到信号时，accept（）也可能会中断。这通常在派生子流程之一退出并用CHLD信号通知父流程时发生。</target>
        </trans-unit>
        <trans-unit id="17b7808b8c8156fa9926b089d73ad2021671fe67" translate="yes" xml:space="preserve">
          <source>Without Readline support you may see the symbols &quot;^[[A&quot;, &quot;^[[C&quot;, &quot;^[[B&quot;, &quot;^[[D&quot;&quot;, &quot;^H&quot;, ... when using the arrow keys and/or the backspace key.</source>
          <target state="translated">如果没有Readline支持,当使用方向键和/或退格键时,你可能会看到符号&quot;^[[A&quot;,&quot;^[[C&quot;,&quot;^[[B&quot;,&quot;^[[D&quot;&quot;,&quot;^H&quot;,...。</target>
        </trans-unit>
        <trans-unit id="7a72072ff5468f365a1052f00033c60b07221002" translate="yes" xml:space="preserve">
          <source>Without additional configuration, GetOptions() will ignore the case of option names, and allow the options to be abbreviated to uniqueness.</source>
          <target state="translated">在没有额外配置的情况下,GetOptions()将忽略选项名称的大小写,并允许选项被缩写为唯一性。</target>
        </trans-unit>
        <trans-unit id="6c913350e18f669953ddd82b1ef504eb99115e6c" translate="yes" xml:space="preserve">
          <source>Without any such configuration, or if Perl itself is built using the system's own IO, then write operations assume that the file handle accepts only</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298442b657e2392a0a1bf4ca9f3ba61c68419ef3" translate="yes" xml:space="preserve">
          <source>Without argument, it returns the currently used icmp protocol message type. By default, it returns 'echo'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5efb30492f1c199d1a2c0cf117a4ad4a638df64" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves a regular expression for simplifying the individual item strings once the list type has been determined. Usage: E.g. when converting to HTML, one might strip the leading number in an ordered list as &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; already prints numbers itself. This must have been set before by either specifying &lt;b&gt;-rx&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;rx()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，一旦确定了列表类型，就检索一个用于简化单个项目字符串的正则表达式。使用方法：例如转换为HTML时，人们可能会作为剥离以有序列表中的前导号码 &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; 已打印号码本身。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-rx&lt;/b&gt;或使用标量参数调用&lt;b&gt;rx（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="18657a3de0c78898530507337e291d8dba0f72cc" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the list tag, which can be any scalar. This must have been set before by either specifying &lt;b&gt;-tag&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;tag()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索有关列表标记的信息，该标记可以是任何标量。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-tag&lt;/b&gt;或通过使用标量参数调用&lt;b&gt;tag（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ccc25a668b5326c657bc2f5c79197991b145ee7" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the parent holding this list, which is represented as an arbitrary scalar. This must have been set before by either specifying &lt;b&gt;-parent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;parent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索有关持有此列表的父级的信息，以任意标量表示。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-parent&lt;/b&gt;或使用标量参数调用&lt;b&gt;parent（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c9f5dc6cba8c17ba8a8e789cb997502b75241827" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the array of the items in this list. The items may be represented by any scalar. If an argument has been given, it is pushed on the list of items.</source>
          <target state="translated">在没有参数的情况下,检索列表中的项目数组。项目可以用任何标量表示。如果有参数,则推送到项目列表中。</target>
        </trans-unit>
        <trans-unit id="b13b7cf761d2e7e6717a0226cb08e73a66d55812" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the file name the list is in. This must have been set before by either specifying &lt;b&gt;-file&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;file()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索列表所在的文件名。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-file&lt;/b&gt;或使用标量参数调用&lt;b&gt;file（）&lt;/b&gt;方法来设置此名称。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1b1eba0344418f60cab2e73b154b51b8cc2fd939" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the indent level of the list as specified in &lt;code&gt;=over n&lt;/code&gt; . This must have been set before by either specifying &lt;b&gt;-indent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;indent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索 &lt;code&gt;=over n&lt;/code&gt; 中指定的列表的缩进级别。必须在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-indent&lt;/b&gt;或通过使用标量参数调用&lt;b&gt;indent（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c3a863e0f35dbdfaea66e845edf4708bb6d53918" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the line number where the list started. This must have been set before by either specifying &lt;b&gt;-start&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;start()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索列表开始的行号。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-start&lt;/b&gt;或使用标量参数调用&lt;b&gt;start（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="914d0fa2ff8badbccd79dfd30e292a8ed73be0c1" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the list type, which can be an arbitrary value, e.g. &lt;code&gt;OL&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , ... when thinking the HTML way. This must have been set before by either specifying &lt;b&gt;-type&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;type()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索列表类型，当考虑HTML方式时，它可以是任意值，例如 &lt;code&gt;OL&lt;/code&gt; ， &lt;code&gt;UL&lt;/code&gt; ，...。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-type&lt;/b&gt;或使用标量参数调用&lt;b&gt;type（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c21aaff33380d9ba14cee3094239dfc4fb494ab" translate="yes" xml:space="preserve">
          <source>Without arguments libnetcfg displays the current configuration.</source>
          <target state="translated">在没有参数的情况下,libnetcfg会显示当前配置。</target>
        </trans-unit>
        <trans-unit id="4decffda157c9d482865e95a2bef98fbdd07c180" translate="yes" xml:space="preserve">
          <source>Without autodie (and assuming BAREWORD is an open filehandle/dirhandle) this is a valid call to chdir. But under autodie, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; will behave like it had the prototype &quot;;$&quot; and thus BAREWORD will be a syntax error (under &quot;use strict&quot;. Without strict, it will interpreted as a filename).</source>
          <target state="translated">没有autodie（并且假设BAREWORD是打开的文件句柄/目录句柄），这是对chdir的有效调用。但是在autodie下， &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 的行为将类似于原型&amp;ldquo;; $&amp;rdquo;，因此BAREWORD将是语法错误（在&amp;ldquo; use strict&amp;rdquo;下。如果没有strict，它将被解释为文件名）。</target>
        </trans-unit>
        <trans-unit id="4f60150307dd02c8b93f0a67955bd9770e2759c8" translate="yes" xml:space="preserve">
          <source>Without autodie (and assuming BAREWORD is an open filehandle/dirhandle) this is a valid call to chdir. But under autodie, &lt;code&gt;chdir&lt;/code&gt; will behave like it had the prototype &quot;;$&quot; and thus BAREWORD will be a syntax error (under &quot;use strict&quot;. Without strict, it will interpreted as a filename).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157dc325ab3004964dba8cb99f25c548e59c3ee6" translate="yes" xml:space="preserve">
          <source>Without binmode this happens to work but without binmode, print() fails instead of write().</source>
          <target state="translated">在没有binmode的情况下,这种情况会发生,但如果没有binmode,print()会失败,而不是write()。</target>
        </trans-unit>
        <trans-unit id="9fae572f92ad00688736431e8db34f7e13e97183" translate="yes" xml:space="preserve">
          <source>Without compiling a special Perl, there is no way to get the exact same behavior of any versions prior to Perl 5.18.0. The closest one can get is by setting PERL_PERTURB_KEYS to 0 and setting the PERL_HASH_SEED to a known value. We do not advise those settings for production use due to the above security considerations.</source>
          <target state="translated">如果不编译一个特殊的Perl,就无法得到Perl 5.18.0之前的任何版本的完全相同的行为。最接近的方法是将PERL_PERTURB_KEYS设置为0,并将PERL_HASH_SEED设置为一个已知值。出于上述安全考虑,我们不建议在生产中使用这些设置。</target>
        </trans-unit>
        <trans-unit id="40d89b93ede452cf3a3abe5db73cc3f6990cb465" translate="yes" xml:space="preserve">
          <source>Without sending mail to the address and seeing whether there's a human on the other end to answer you, you cannot fully answer part</source>
          <target state="translated">如果不按地址发信,不看另一端是否有人接听,你就不能完全回答部分</target>
        </trans-unit>
        <trans-unit id="9dc761ae6cda1ca106ca429a9b91481691a414c5" translate="yes" xml:space="preserve">
          <source>Without tests provided by the original author, how can anyone else changing perl in the future be sure that they haven't unwittingly broken the behaviour the patch implements? And without tests, how can the patch's author be confident that his/her hard work put into the patch won't be accidentally thrown away by someone in the future?</source>
          <target state="translated">如果没有原作者提供的测试,那么将来修改 perl 的人怎么能确定他们没有无意中破坏了补丁所实现的行为?而没有测试,补丁的作者又怎么能确信他/她在补丁中的辛勤工作不会被未来的人不小心丢弃呢?</target>
        </trans-unit>
        <trans-unit id="c1443d621edad5afbf828f718460ec1c38b6ccbc" translate="yes" xml:space="preserve">
          <source>Without that empty line before the &quot;=head1&quot;, many translators wouldn't have recognized the &quot;=head1&quot; as starting a Pod block.</source>
          <target state="translated">如果没有&quot;=head1 &quot;前的那行空行,很多译者就不会把&quot;=head1 &quot;识别为Pod块的起始。</target>
        </trans-unit>
        <trans-unit id="d67d28a004691a2df73ec622342b344f42349502" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; declaration, this code will not compile under the &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; pragma.</source>
          <target state="translated">如果没有 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; 声明，这个代码将不会下编译&lt;a href=&quot;strict&quot;&gt;严格&lt;/a&gt;编译。</target>
        </trans-unit>
        <trans-unit id="e556997c8bdf4cc597d6477622db2033d0112438" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;our $AUTOLOAD&lt;/code&gt; declaration, this code will not compile under the &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8106389e31f882e4de34e6fb1c8fa83f4529f426" translate="yes" xml:space="preserve">
          <source>Without the \ before the #, we'd have the start of a Makefile comment, and the macro would be incorrectly defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9862e56ba4382f4550c0a053a28a9edc67cb29a8" translate="yes" xml:space="preserve">
          <source>Without the \\ before the #, we'd have the start of a Makefile comment, and the macro would be incorrectly defined.</source>
          <target state="translated">如果没有#前的\\,我们就会有一个Makefile注释的开头,宏的定义就会不正确。</target>
        </trans-unit>
        <trans-unit id="c652adb6df9438fc28974e5263002f95713055c4" translate="yes" xml:space="preserve">
          <source>Without the all-critical &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declaration, putting UTF‑8 in your literals and identifiers won&amp;rsquo;t work right. If you used the standard preamble just given above, this already happened. If you did, you can do things like this:</source>
          <target state="translated">如果没有所有至关重要的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 声明，那么将UTF-8放在文字和标识符中将无法正常工作。如果您使用上面刚刚给出的标准前导，则已经发生了。如果这样做，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="022916bda3b0da7053428b82057c474802fe172c" translate="yes" xml:space="preserve">
          <source>Without the all-critical &lt;code&gt;use utf8&lt;/code&gt; declaration, putting UTF‑8 in your literals and identifiers won&amp;rsquo;t work right. If you used the standard preamble just given above, this already happened. If you did, you can do things like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a805f73e432af03c931e3e4ebc6e43febdbb1b0f" translate="yes" xml:space="preserve">
          <source>Without the braces, Perl would have looked for a $whospeak, a &lt;code&gt;$who::0&lt;/code&gt; , and a &lt;code&gt;$who's&lt;/code&gt; variable. The last two would be the $0 and the $s variables in the (presumably) non-existent package &lt;code&gt;who&lt;/code&gt; .</source>
          <target state="translated">如果没有括号，Perl会寻找一个$ whospeak，一个 &lt;code&gt;$who::0&lt;/code&gt; 和一个 &lt;code&gt;$who's&lt;/code&gt; 变量。最后两个是（可能是）不存在的软件包 &lt;code&gt;who&lt;/code&gt; 中的$ 0和$ s变量。</target>
        </trans-unit>
        <trans-unit id="b59ba0c86d5008d327ba4145261903f48586e59b" translate="yes" xml:space="preserve">
          <source>Without the braces, Perl would have looked for a $whospeak, a &lt;code&gt;$who::0&lt;/code&gt;, and a &lt;code&gt;$who's&lt;/code&gt; variable. The last two would be the $0 and the $s variables in the (presumably) non-existent package &lt;code&gt;who&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7119185642381b4835e616a2adfce6407060de" translate="yes" xml:space="preserve">
          <source>Without the file handle there is no straightforward way to map from the C callback to the Perl subroutine.</source>
          <target state="translated">如果没有文件句柄,就无法直接从C回调映射到Perl子程序。</target>
        </trans-unit>
        <trans-unit id="557fc723a913d1e3b2505b4094298be8eec2001a" translate="yes" xml:space="preserve">
          <source>Without the quotes Perl would convert the large number to a floating point constant at compile time and then hand the result to BigInt, which results in an truncated result or a NaN.</source>
          <target state="translated">如果没有引号,Perl会在编译时将大数转换为浮点常数,然后将结果交给BigInt,结果是一个截断的结果或NaN。</target>
        </trans-unit>
        <trans-unit id="cd8dcbc5d0ba46dab27a245d8542910769851151" translate="yes" xml:space="preserve">
          <source>Without the quotes Perl would convert the large number to a floating point constant at compile time and then hand the result to Math::BigInt, which results in an truncated result or a NaN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d0e0ada47acb90500aed8583377dc7e9485f05" translate="yes" xml:space="preserve">
          <source>Without this function call, threads that use the &lt;a href=&quot;setlocale(3)&quot;&gt;&lt;code&gt;setlocale(3)&lt;/code&gt;&lt;/a&gt; system function will not work properly, as all the locale-sensitive functions will look at the per-thread locale, and &lt;code&gt;setlocale&lt;/code&gt; will have no effect on this thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd1a191c5e0195ae68815f767eadf66793aed3f" translate="yes" xml:space="preserve">
          <source>Without this pragma, if strings operating under byte semantics and strings with Unicode character data are concatenated, the new string will be created by decoding the byte strings as</source>
          <target state="translated">如果没有这个参数,如果按字节语义操作的字符串和带有Unicode字符数据的字符串被连接起来,新的字符串将通过解码字节字符串来创建。</target>
        </trans-unit>
        <trans-unit id="4e3240128cc4ac6294817aa01c1437d4416b9150" translate="yes" xml:space="preserve">
          <source>Word characters</source>
          <target state="translated">字符</target>
        </trans-unit>
        <trans-unit id="c1ab804bf377c2d02f25ebababbe5112fca26b12" translate="yes" xml:space="preserve">
          <source>Work Crew</source>
          <target state="translated">工作团队</target>
        </trans-unit>
        <trans-unit id="73f4875bffaeefb6bc4c9e5de5982f1c956b5814" translate="yes" xml:space="preserve">
          <source>Work around DCL's 255 character limit several times,and use VMS-style command line quoting in a few cases.</source>
          <target state="translated">多次绕过DCL的255个字符限制,并在一些情况下使用VMS风格的命令行引号。</target>
        </trans-unit>
        <trans-unit id="beb03a8c30af39505328c268c1180c75604701a0" translate="yes" xml:space="preserve">
          <source>Work for the pumpking, work for Perl programmers, work for module authors, ... Perl is supposed to be easy.</source>
          <target state="translated">为泵金工作,为Perl程序员工作,为模块作者工作,...Perl应该是很简单的。</target>
        </trans-unit>
        <trans-unit id="91f920f3d44c34d2ff6c9dd9603498397730bf04" translate="yes" xml:space="preserve">
          <source>Worked by applying a role that wrapped &lt;code&gt;Test::Builder-&amp;gt;_print_comment&lt;/code&gt;. Fixed by adding an event filter that modifies the message instead when running under Test2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b837e4f0aacd9d9f6074d443ecd309cef87e661e" translate="yes" xml:space="preserve">
          <source>Working code is always preferred to pie-in-the-sky ideas. A patch to add a feature stands a much higher chance of making it to the language than does a random feature request, no matter how fervently argued the request might be. This ties into &quot;Will it be useful?&quot;, as the fact that someone took the time to make the patch demonstrates a strong desire for the feature.</source>
          <target state="translated">工作代码总是比天马行空的想法更受欢迎。一个添加功能的补丁比一个随机的功能请求有更大的机会被加入到语言中,不管这个请求有多么激烈的争论。这与 &quot;它是否有用?&quot;有关,因为有人花时间打补丁的事实表明了对该功能的强烈渴望。</target>
        </trans-unit>
        <trans-unit id="791f0cf1a4866efe09fa052199378fd87a29a636" translate="yes" xml:space="preserve">
          <source>Working with AVs</source>
          <target state="translated">与AVs一起工作</target>
        </trans-unit>
        <trans-unit id="fcf77865e202a40f39e6dc4633dec2c1c8b8542a" translate="yes" xml:space="preserve">
          <source>Working with HVs</source>
          <target state="translated">与HVs一起工作</target>
        </trans-unit>
        <trans-unit id="9ba6b91bf263dc667dda1becd81a9fbef7358bbd" translate="yes" xml:space="preserve">
          <source>Working with Net::FTP</source>
          <target state="translated">使用Net::FTP</target>
        </trans-unit>
        <trans-unit id="9522f5ef01714aab2e2d70111bf52346aa9851c3" translate="yes" xml:space="preserve">
          <source>Working with SVs</source>
          <target state="translated">与SVs一起工作</target>
        </trans-unit>
        <trans-unit id="acaa1f9e891f841e4f55280185da1c9a0bc87b80" translate="yes" xml:space="preserve">
          <source>Working with files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efe528e837c3e9dd842174c934d74e9c8e8af64" translate="yes" xml:space="preserve">
          <source>Works currently only for integers.</source>
          <target state="translated">目前只适用于整数。</target>
        </trans-unit>
        <trans-unit id="c9cb7c59dae1a78441bca64b16b41d57dc70c3e5" translate="yes" xml:space="preserve">
          <source>Works exactly as &lt;code&gt;like()&lt;/code&gt; , only it checks if $got &lt;b&gt;does not&lt;/b&gt; match the given pattern.</source>
          <target state="translated">与 &lt;code&gt;like()&lt;/code&gt; 完全一样，仅检查$ got &lt;b&gt;是否&lt;/b&gt;与给定模式&lt;b&gt;不&lt;/b&gt;匹配。</target>
        </trans-unit>
        <trans-unit id="6ffef90261775bf1446d64de441c14b751512d3c" translate="yes" xml:space="preserve">
          <source>Works exactly as &lt;code&gt;like()&lt;/code&gt;, only it checks if $got &lt;b&gt;does not&lt;/b&gt; match the given pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f0dce4381260fc309ade54b455e20a83cc12f0" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#index-STR%2CSUBSTR%2CPOSITION&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; except that it returns the position of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9232c0576386ef7db9a66e0f3312f80aa2ae0362" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">就像&lt;a href=&quot;#localtime&quot;&gt;localtime&lt;/a&gt;一样工作，但是返回的值被本地化为标准格林威治时区。</target>
        </trans-unit>
        <trans-unit id="9839a604fd52293ec52fedd95d5b5d8df3818c2c" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69a4f2f77bbe0fae40d114143aa5065b6ddabd02" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;cmp_ok()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d895f5ba3197e6e250fa353d94a31dc5531f0f" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">就像&lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt;一样工作，但是返回的值被本地化为标准格林威治时区。</target>
        </trans-unit>
        <trans-unit id="59edd54160d7f94a92175d3ce89e67babbe534fb" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;cmp_ok()&lt;/code&gt; .</source>
          <target state="translated">就像&lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt;的 &lt;code&gt;cmp_ok()&lt;/code&gt; 一样工作。</target>
        </trans-unit>
        <trans-unit id="b054b39e72ec238653744e3a117cbf2b7bacaa18" translate="yes" xml:space="preserve">
          <source>Works just like index() except that it returns the position of the</source>
          <target state="translated">和index()的工作原理一样,只不过它返回的是index()的位置。</target>
        </trans-unit>
        <trans-unit id="ff14a89d24955b4d292116a9dd09815095b69cb7" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_catpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;&lt;a href=&quot;#sv_setpvf_mg&quot;&gt;&quot;sv_setpvf_mg&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62b7e0373549dae581f58b37784d19f9d489170e" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_catpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_setpvf_mg&lt;/code&gt; .</source>
          <target state="translated">像 &lt;code&gt;sv_catpvf&lt;/code&gt; 一样工作，但是将文本复制到SV中，而不是附加文本。不处理&amp;ldquo;定型&amp;rdquo;魔法。参见 &lt;code&gt;sv_setpvf_mg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c14d76b99d10ba25b831daac8203cd025304f5fc" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;&lt;a href=&quot;#sv_vsetpvf_mg&quot;&gt;&quot;sv_vsetpvf_mg&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ccfff897978a36d025fbdd87f7f80f29da36e5" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; .</source>
          <target state="translated">像 &lt;code&gt;sv_vcatpvf&lt;/code&gt; 一样工作，但是将文本复制到SV中，而不是附加文本。不处理&amp;ldquo;定型&amp;rdquo;魔法。参见 &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce9ad1c2559537d328f2e9ae5ccf06d2341106d3" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvfn&lt;/code&gt; but copies the text into the SV instead of appending it.</source>
          <target state="translated">像 &lt;code&gt;sv_vcatpvfn&lt;/code&gt; 一样工作，但是将文本复制到SV中，而不是附加文本。</target>
        </trans-unit>
        <trans-unit id="97569be8c378569cf569a2abd589e6182aac8aca" translate="yes" xml:space="preserve">
          <source>Works remotely similar to &lt;code&gt;filter_json_object&lt;/code&gt;, but is only called for JSON objects having a single key named &lt;code&gt;$key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e28088b9057a774cbeb7647c942ba983be39b65a" translate="yes" xml:space="preserve">
          <source>Workshops</source>
          <target state="translated">Workshops</target>
        </trans-unit>
        <trans-unit id="aca31ad78f24eb8f34a6f1515e5ad96783f7a4c5" translate="yes" xml:space="preserve">
          <source>World Wide Web, HTML, HTTP, CGI, MIME</source>
          <target state="translated">万维网、HTML、HTTP、CGI、MIME。</target>
        </trans-unit>
        <trans-unit id="dc354627de17c28e4a463874cb49fb69cf80c2d0" translate="yes" xml:space="preserve">
          <source>Worse still, if you've got a language like Chinese or Japanese that has hundreds or thousands of characters, then you really can't fit them into a mere 256, so they had to forget about ASCII altogether, and build their own systems using pairs of numbers to refer to one character.</source>
          <target state="translated">更糟糕的是,如果你的语言,比如中文或日文,有几百个或几千个字符,那么你真的无法将它们装进仅仅256个字符中,所以他们不得不完全忘掉ASCII,建立自己的系统,用数字对来指代一个字符。</target>
        </trans-unit>
        <trans-unit id="c5bfba3d49e2ee674235e330da88197da31a7c79" translate="yes" xml:space="preserve">
          <source>Would print '1', because &lt;code&gt;$foo&lt;/code&gt; holds a reference to the</source>
          <target state="translated">将打印&amp;ldquo; 1&amp;rdquo;，因为 &lt;code&gt;$foo&lt;/code&gt; 持有对</target>
        </trans-unit>
        <trans-unit id="193007f64c59b1fb13236d0c41a89912a80da741" translate="yes" xml:space="preserve">
          <source>Would produce an event structure that does &lt;b&gt;not&lt;/b&gt; have the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb47f1ed4bc872fb3335bdefcb281f4424715abe" translate="yes" xml:space="preserve">
          <source>Would run bin/foobar.PL like this:</source>
          <target state="translated">会像这样运行bin/foobar.PL。</target>
        </trans-unit>
        <trans-unit id="ead2351e2ba0bd4c816a4c94cc5152ad666ddb3d" translate="yes" xml:space="preserve">
          <source>Wrapper around CPAN.pm without using any XS module</source>
          <target state="translated">围绕CPAN.pm的封装器,无需使用任何XS模块。</target>
        </trans-unit>
        <trans-unit id="84ac379977c898d123ab3b5be8e7d1ebcc793262" translate="yes" xml:space="preserve">
          <source>Wrapper around Config.pm</source>
          <target state="translated">围绕配置.pm的封装器</target>
        </trans-unit>
        <trans-unit id="5e2ec9565586c686048d53d457fe37527f6aad30" translate="yes" xml:space="preserve">
          <source>Wrapper class for calling subs at end of scope</source>
          <target state="translated">用于在作用域结束时调用子类的封装类。</target>
        </trans-unit>
        <trans-unit id="49754b3431fd16ae1cf0d382c55b7fa7149dd942" translate="yes" xml:space="preserve">
          <source>Wrapping all die calls in a handler routine can be useful to see how, and from where, they're being called, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; has more information:</source>
          <target state="translated">在处理程序例程中包装所有die调用对于查看&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;如何以及从何处被调用有更多信息，这很有用：</target>
        </trans-unit>
        <trans-unit id="c2c61b8accf065e529ff818a1a9f4549b7fc54ab" translate="yes" xml:space="preserve">
          <source>Wrapping with parenthesis allows the wildcard parts of the Input File Glob to be referenced by the second parameter to &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;#1.tgz&lt;/code&gt; , the</source>
          <target state="translated">包装用括号允许输入文件水珠的通配符部分由第二个参数被引用 &lt;code&gt;globmap&lt;/code&gt; ， &lt;code&gt;#1.tgz&lt;/code&gt; ，所述</target>
        </trans-unit>
        <trans-unit id="17f822b6bdf6bec5271484d235680d74774f32cb" translate="yes" xml:space="preserve">
          <source>Wrapping with parenthesis allows the wildcard parts of the Input File Glob to be referenced by the second parameter to &lt;code&gt;globmap&lt;/code&gt;, &lt;code&gt;#1.tgz&lt;/code&gt;, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f5b426a0effa25adf0da16850506b6dbd0cdcc" translate="yes" xml:space="preserve">
          <source>Wraps any CODE references found within the arguments by replacing each with the result of calling &lt;a href=&quot;#wrap_code_ref&quot;&gt;&quot;wrap_code_ref&quot;&lt;/a&gt; on the CODE reference. Any ARRAY or HASH references in the arguments are inspected recursively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee0be976deb11b8b1d2de7c10091a2cf26d9d3d" translate="yes" xml:space="preserve">
          <source>Wraps any CODE references found within the arguments by replacing each with the result of calling &lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt; on the CODE reference. Any ARRAY or HASH references in the arguments are inspected recursively.</source>
          <target state="translated">通过用在CODE引用上调用&lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt;的结果替换每个参数，包装在参数中找到的所有CODE引用。递归检查参数中的所有ARRAY或HASH引用。</target>
        </trans-unit>
        <trans-unit id="c3415b34e4326194b5c5e94f65779568f9ab9142" translate="yes" xml:space="preserve">
          <source>Wraps up an op tree with some additional ops so that at runtime a dynamic scope will be created. The original ops run in the new dynamic scope, and then, provided that they exit normally, the scope will be unwound. The additional ops used to create and unwind the dynamic scope will normally be an &lt;code&gt;enter&lt;/code&gt; /&lt;code&gt;leave&lt;/code&gt; pair, but a &lt;code&gt;scope&lt;/code&gt; op may be used instead if the ops are simple enough to not need the full dynamic scope structure.</source>
          <target state="translated">用一些其他操作包装操作树，以便在运行时创建动态范围。原始操作在新的动态范围内运行，然后，只要它们正常退出，该范围将被取消。用于创建和展开动态范围的其他操作通常将是一个 &lt;code&gt;enter&lt;/code&gt; / &lt;code&gt;leave&lt;/code&gt; 对，但是如果操作足够简单以至于不需要完整的动态范围结构，则可以使用 &lt;code&gt;scope&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="2c03a1841c6b03c290cd48f7ec63334ea2671fbe" translate="yes" xml:space="preserve">
          <source>Wraps up an op tree with some additional ops so that at runtime a dynamic scope will be created. The original ops run in the new dynamic scope, and then, provided that they exit normally, the scope will be unwound. The additional ops used to create and unwind the dynamic scope will normally be an &lt;code&gt;enter&lt;/code&gt;/&lt;code&gt;leave&lt;/code&gt; pair, but a &lt;code&gt;scope&lt;/code&gt; op may be used instead if the ops are simple enough to not need the full dynamic scope structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a48932789d199bbed709777e2d743ca2bafdc6c" translate="yes" xml:space="preserve">
          <source>Write</source>
          <target state="translated">Write</target>
        </trans-unit>
        <trans-unit id="665e91485da7b1f4da854eb4a64d72b175917c29" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes of data from &lt;code&gt;BUFFER&lt;/code&gt; to the server, also performing any &amp;lt;CRLF&amp;gt; translation necessary. &lt;code&gt;TIMEOUT&lt;/code&gt; is optional, if not given, the timeout value from the command connection will be used.</source>
          <target state="translated">将 &lt;code&gt;BUFFER&lt;/code&gt; 中的 &lt;code&gt;SIZE&lt;/code&gt; 字节数据写入服务器，同时还要执行任何&amp;lt;CRLF&amp;gt;转换。 &lt;code&gt;TIMEOUT&lt;/code&gt; 是可选的，如果未指定，将使用命令连接中的超时值。</target>
        </trans-unit>
        <trans-unit id="9e9970521c52eb1a81f415505a29f59eba7d4c0c" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes to the shared memory segment at &lt;code&gt;POS&lt;/code&gt; . Returns true if successful, or false if there is an error. See &lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;SIZE&lt;/code&gt; 字节写入 &lt;code&gt;POS&lt;/code&gt; 的共享内存段。如果成功，则返回true；如果有错误，则返回false。参见&lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e52c0034fc1cfc407469f1ff131f1cb98c7f427d" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes to the shared memory segment at &lt;code&gt;POS&lt;/code&gt;. Returns true if successful, or false if there is an error. See &lt;a href=&quot;shmwrite&quot;&gt;shmwrite&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4d6106f35288022310ffee038cda3aae849b282" translate="yes" xml:space="preserve">
          <source>Write MYMETA information to MYMETA.json and MYMETA.yml.</source>
          <target state="translated">将MYMETA信息写入MYMETA.json和MYMETA.yml中。</target>
        </trans-unit>
        <trans-unit id="a9b6c91570493bdee3be6eef5a6b183ad756cdab" translate="yes" xml:space="preserve">
          <source>Write RFC 1950 files/buffers</source>
          <target state="translated">编写RFC 1950文件/缓冲器</target>
        </trans-unit>
        <trans-unit id="0909abf68380a212e21e5479f6396ce54f63b785" translate="yes" xml:space="preserve">
          <source>Write RFC 1951 files/buffers</source>
          <target state="translated">编写RFC 1951文件/缓冲器</target>
        </trans-unit>
        <trans-unit id="0a1ef998109ed3777e0f667818ad2c1c3ea0b70e" translate="yes" xml:space="preserve">
          <source>Write RFC 1952 files/buffers</source>
          <target state="translated">编写RFC 1952文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="e52a7d8ae8bb89850d8b0bad0931a61da15a6992" translate="yes" xml:space="preserve">
          <source>Write YAMLish data</source>
          <target state="translated">编写YAML语言数据</target>
        </trans-unit>
        <trans-unit id="77878a047db48550e0d5361bfb44d185b930e978" translate="yes" xml:space="preserve">
          <source>Write a formatter as a Pod::Simple subclass</source>
          <target state="translated">写一个formatter作为Pod::Simple子类。</target>
        </trans-unit>
        <trans-unit id="bc54db5c1b3d5ac212fb800fdd56f965140da3e5" translate="yes" xml:space="preserve">
          <source>Write access via git</source>
          <target state="translated">通过git写访问</target>
        </trans-unit>
        <trans-unit id="935636e37a0f4339394c64f63b5cea6433c1f963" translate="yes" xml:space="preserve">
          <source>Write an entry, whose name is equivalent to the file name provided to disk. Optionally takes a second parameter, which is the full native path (including filename) the entry will be written to.</source>
          <target state="translated">写入一个条目,其名称相当于提供给磁盘的文件名。可选择使用第二个参数,即条目将被写入的完整本地路径(包括文件名)。</target>
        </trans-unit>
        <trans-unit id="21bcad44913246d2e6442e5351456a0465facb2b" translate="yes" xml:space="preserve">
          <source>Write an event to the console.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e129f1755e34449f3a6e6df186f50990274c50" translate="yes" xml:space="preserve">
          <source>Write behind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9db66c000d241fa8edccdd62e10c6678d855f50" translate="yes" xml:space="preserve">
          <source>Write bytes to a file or file-like device. Returns a true value if the operation was successful. For failure, returns a false value and sets &lt;code&gt;fileLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt; for the reason for the failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5769fe16b9b0cad42af9406c72e837bd0c18c816" translate="yes" xml:space="preserve">
          <source>Write bzip2 files/buffers</source>
          <target state="translated">写入bzip2文件/缓冲区</target>
        </trans-unit>
        <trans-unit id="33c705dea45d707aeb4260372b955bd490cdccc3" translate="yes" xml:space="preserve">
          <source>Write check compare operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bafb7482744edca206da4c0baa12b4a11269c914" translate="yes" xml:space="preserve">
          <source>Write documentation in POD</source>
          <target state="translated">用POD编写文档</target>
        </trans-unit>
        <trans-unit id="01995de03181a3f8adb7e727e73e6dc5e4e106c7" translate="yes" xml:space="preserve">
          <source>Write files whose names are equivalent to any of the names in &lt;code&gt;@filenames&lt;/code&gt; to disk, creating subdirectories as necessary. This might not work too well under VMS. Under MacPerl, the file's modification time will be converted to the MacOS zero of time, and appropriate conversions will be done to the path. However, the length of each element of the path is not inspected to see whether it's longer than MacOS currently allows (32 characters).</source>
          <target state="translated">将名称等同于 &lt;code&gt;@filenames&lt;/code&gt; 中任何名称的文件写入磁盘，并根据需要创建子目录。在VMS下这可能无法很好地工作。在MacPerl下，文件的修改时间将转换为MacOS的零时间，并将对路径进行适当的转换。但是，不检查路径的每个元素的长度以查看其是否比MacOS当前允许的长度（32个字符）长。</target>
        </trans-unit>
        <trans-unit id="cbcd4ec744f6a0cc7a8100b555d7a1173e6952f5" translate="yes" xml:space="preserve">
          <source>Write linker options files for dynamic extension</source>
          <target state="translated">为动态扩展写链接器选项文件</target>
        </trans-unit>
        <trans-unit id="a3530b843bc763ce23299f2f7a8c7169f29e11c4" translate="yes" xml:space="preserve">
          <source>Write simple routines to do simple things.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19494af103ef52570f65fb0c4441c4f5f25a19b7" translate="yes" xml:space="preserve">
          <source>Write some bytes to the scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391b1a9608423cb9c4d16a7886b9e07fab1acb00" translate="yes" xml:space="preserve">
          <source>Write tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af9a89203723d4a9c54482e7a2f891829a872e2c" translate="yes" xml:space="preserve">
          <source>Write the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f112fa7fb0b15b487e01a318607d918ca868eea9" translate="yes" xml:space="preserve">
          <source>Write the C code for miniperlmain.c and perlmain.c</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5fd755a4779cecce293a2a1e919899f32cdf21" translate="yes" xml:space="preserve">
          <source>Write the C code for perlmain.c</source>
          <target state="translated">编写 perlmain.c 的 C 代码。</target>
        </trans-unit>
        <trans-unit id="0a8eff4063a82696c6af1e9ea9cf555d97a3ea2c" translate="yes" xml:space="preserve">
          <source>Write the in-memory archive to disk. The first argument can either be the name of a file or a reference to an already open filehandle (a GLOB reference).</source>
          <target state="translated">将内存中的档案写入磁盘。第一个参数可以是文件名,也可以是一个已经打开的文件柄的引用(GLOB引用)。</target>
        </trans-unit>
        <trans-unit id="af8f82dc202f24f05f3598bed445a87ed08771b7" translate="yes" xml:space="preserve">
          <source>Write the state to a file.</source>
          <target state="translated">将状态写入文件。</target>
        </trans-unit>
        <trans-unit id="03e89de5415aa73b6bf8d4ce2e95f915540a35da" translate="yes" xml:space="preserve">
          <source>Write the typemap to a file. Optionally takes a &lt;code&gt;file&lt;/code&gt; argument. If given, the typemap will be written to the specified file. If not, the typemap is written to the currently stored file name (see &lt;a href=&quot;#file&quot;&gt;&quot;file&quot;&lt;/a&gt; above, this defaults to the file it was read from if any).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ea3036e84ed65b742580afd08f2cf97f36ee5c9" translate="yes" xml:space="preserve">
          <source>Write to a file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">写入文件。它使用文件描述符，例如通过调用 &lt;code&gt;POSIX::open&lt;/code&gt; 获得的文件描述符。</target>
        </trans-unit>
        <trans-unit id="1ddba3f84caaf1f7da5ab41258196ba4aa666d93" translate="yes" xml:space="preserve">
          <source>Write to a file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff8491fc63b40787a6bc354a1c28b21cd65c0f1" translate="yes" xml:space="preserve">
          <source>Write to modules@perl.org explaining what you did to contact the current maintainer. The PAUSE admins will also try to reach the maintainer.</source>
          <target state="translated">写到modules@perl.org,说明你做了什么来联系当前的维护者。PAUSE管理员也会尝试联系维护者。</target>
        </trans-unit>
        <trans-unit id="ec3b4c2700310731999e0d7e25df0c587f5a195d" translate="yes" xml:space="preserve">
          <source>Write zip files/buffers</source>
          <target state="translated">写压缩文件/缓冲区</target>
        </trans-unit>
        <trans-unit id="08d9173120127debf58115903083c7548d3871d3" translate="yes" xml:space="preserve">
          <source>Write-only access to the data in the file.</source>
          <target state="translated">对文件中的数据进行只写访问。</target>
        </trans-unit>
        <trans-unit id="14518d4671890ab2fd2dc1aa9e641777a8f1afbc" translate="yes" xml:space="preserve">
          <source>WriteConstants ATTRIBUTE =&amp;gt; VALUE [, ...]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94dee2fafe1d10d5ce6db659eb0c0fcb3d5842be" translate="yes" xml:space="preserve">
          <source>WriteFile</source>
          <target state="translated">WriteFile</target>
        </trans-unit>
        <trans-unit id="8a1db595bd4c07aab5da69c69b2b0b595010f3b7" translate="yes" xml:space="preserve">
          <source>WriteMakefile() now does some basic sanity checks on its parameters to protect against typos and malformatted values. This means some things which happened to work in the past will now throw warnings and possibly produce internal errors.</source>
          <target state="translated">WriteMakefile()现在会对其参数进行一些基本的理智检查,以防止错别字和格式化错误的值。这意味着一些过去可以正常工作的东西现在会发出警告,并可能产生内部错误。</target>
        </trans-unit>
        <trans-unit id="97fe0c70bb91d9c9a985fa7a8dd506d2e586dde0" translate="yes" xml:space="preserve">
          <source>WriteMakefileSnippet</source>
          <target state="translated">WriteMakefileSnippet</target>
        </trans-unit>
        <trans-unit id="6e814e2d111b3599c2bf1ca192478a3ffbfc4053" translate="yes" xml:space="preserve">
          <source>WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [, ...]</source>
          <target state="translated">WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [，...]</target>
        </trans-unit>
        <trans-unit id="7bdbf771b888449a861406dd116d15dd91371055" translate="yes" xml:space="preserve">
          <source>Writes SIZE bytes from STRING to a memory segment at ADDR starting at position POS. If STRING is too long, only SIZE bytes are used; if STRING is too short, nulls are written to fill out SIZE bytes. Returns true if successful, or false if there is an error.</source>
          <target state="translated">将STRING中的SIZE字节写入从位置POS开始的ADDR的内存段。如果STRING太长,只使用SIZE字节;如果STRING太短,则写入空值来填充SIZE字节。如果成功则返回true,如果出现错误则返回false。</target>
        </trans-unit>
        <trans-unit id="5d0ca93d68b5dc214818ef186a1bc3e2b3d7c8cd" translate="yes" xml:space="preserve">
          <source>Writes a file of C code and a file of XS code which you should &lt;code&gt;#include&lt;/code&gt; and &lt;code&gt;INCLUDE&lt;/code&gt; in the C and XS sections respectively of your module's XS code. You probably want to do this in your &lt;code&gt;Makefile.PL&lt;/code&gt; , so that you can easily edit the list of constants without touching the rest of your module. The attributes supported are</source>
          <target state="translated">写入C代码文件和XS代码文件，分别在模块的XS代码的C和XS部分中分别 &lt;code&gt;INCLUDE&lt;/code&gt; &lt;code&gt;#include&lt;/code&gt; 和INCLUDE。您可能希望在 &lt;code&gt;Makefile.PL&lt;/code&gt; 中执行此操作，以便可以轻松编辑常量列表，而无需触摸模块的其余部分。支持的属性是</target>
        </trans-unit>
        <trans-unit id="e0245702e3fa0201a8eb501ac9938357e48b7d01" translate="yes" xml:space="preserve">
          <source>Writes a file of C code and a file of XS code which you should &lt;code&gt;#include&lt;/code&gt; and &lt;code&gt;INCLUDE&lt;/code&gt; in the C and XS sections respectively of your module's XS code. You probably want to do this in your &lt;code&gt;Makefile.PL&lt;/code&gt;, so that you can easily edit the list of constants without touching the rest of your module. The attributes supported are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e7628595fe05e976f01b228c1371b889b4fb1c" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;a href=&quot;#select-FILEHANDLE&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; function) may be set explicitly by assigning the name of the format to the &lt;a href=&quot;perlvar#%24~&quot;&gt;&lt;code&gt;$~&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68caf753088df284b27998c0bc22c79c995c9f8a" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">使用与该文件关联的格式，将格式化的记录（可能是多行）写入指定的FILEHANDLE。默认情况下，文件格式是与文件句柄名称相同的格式，但是可以通过将格式名称分配给 &lt;code&gt;$~&lt;/code&gt; 变量来显式设置当前输出通道的格式（请参见 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 函数）。</target>
        </trans-unit>
        <trans-unit id="3c8b534fc59790f52bbc323708c6a448e4336f1e" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">使用与该文件关联的格式，将格式化的记录（可能是多行）写入指定的FILEHANDLE。默认情况下，文件格式是与文件句柄名称相同的格式，但是可以通过将格式名称分配给 &lt;code&gt;$~&lt;/code&gt; 变量来显式设置当前输出通道的格式（请参见 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 函数）。</target>
        </trans-unit>
        <trans-unit id="4e8961057173b914aa902d24e81d3c55d00dde52" translate="yes" xml:space="preserve">
          <source>Writes all files in and below the current directory to your</source>
          <target state="translated">将当前目录下的所有文件写到你的</target>
        </trans-unit>
        <trans-unit id="1ff3060cc065fe5dcf829a42d2a8d401fd64f6d8" translate="yes" xml:space="preserve">
          <source>Writes an empty FORCE: target.</source>
          <target state="translated">写一个空的FORCE:目标。</target>
        </trans-unit>
        <trans-unit id="f5369d43b2f75bf65f1c9b2bf55177161b67ef85" translate="yes" xml:space="preserve">
          <source>Writes are permitted, i.e. opened as &quot;w&quot; or &quot;r+&quot; or &quot;a&quot;, etc.</source>
          <target state="translated">允许写,即以 &quot;w &quot;或 &quot;r+&quot;或 &quot;a &quot;等方式打开。</target>
        </trans-unit>
        <trans-unit id="bc03658e3c61d9705d37afb50e35b60738df57d4" translate="yes" xml:space="preserve">
          <source>Writes the contents of &lt;code&gt;$buffer&lt;/code&gt; to the compressed file. Returns the number of bytes actually written, or 0 on error.</source>
          <target state="translated">将 &lt;code&gt;$buffer&lt;/code&gt; 的内容写入压缩文件。返回实际写入的字节数，如果出错则返回0。</target>
        </trans-unit>
        <trans-unit id="3b30b2d9d9b94819a1a73fa66ad9fdb3aaf93cb5" translate="yes" xml:space="preserve">
          <source>Writes the file META.yml (YAML encoded meta-data) and META.json (JSON encoded meta-data) about the module in the distdir. The format follows Module::Build's as closely as possible.</source>
          <target state="translated">将模块的META.yml(YAML编码的元数据)和META.json(JSON编码的元数据)文件写入distdir中。其格式尽可能的遵循Module::Build的格式。</target>
        </trans-unit>
        <trans-unit id="759cd7af683913d2e067b4f6ffe525a9a1d4a391" translate="yes" xml:space="preserve">
          <source>Writes the file SIGNATURE with &quot;cpansign -s&quot;.</source>
          <target state="translated">用 &quot;cpansign -s &quot;写入文件SIGNATURE。</target>
        </trans-unit>
        <trans-unit id="284cf58439290385abdec38ca7c004471227b097" translate="yes" xml:space="preserve">
          <source>Writes the output of</source>
          <target state="translated">写入</target>
        </trans-unit>
        <trans-unit id="7576a6f2b013b505dded5e0784047fb79ad928e8" translate="yes" xml:space="preserve">
          <source>Writes to the &lt;code&gt;.c&lt;/code&gt; output file certain preprocessor directives and function headers needed in all such files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdd8d478482d63bc406cd41436757960d17780fb" translate="yes" xml:space="preserve">
          <source>Writing Accessors</source>
          <target state="translated">书写配件</target>
        </trans-unit>
        <trans-unit id="1986c44b3bdced950b196d1c43f6cf37a6963d63" translate="yes" xml:space="preserve">
          <source>Writing Constructors</source>
          <target state="translated">编写结构体</target>
        </trans-unit>
        <trans-unit id="2e43f89f29a3e136e02e547cac033fa128355bb0" translate="yes" xml:space="preserve">
          <source>Writing Perl on an EBCDIC platform is really no different than writing on an &lt;a href=&quot;#ASCII&quot;&gt;&quot;ASCII&quot;&lt;/a&gt; one, but with different underlying numbers, as we'll see shortly. You'll have to know something about those &lt;a href=&quot;#ASCII&quot;&gt;&quot;ASCII&quot;&lt;/a&gt; platforms because the documentation is biased and will frequently use example numbers that don't apply to EBCDIC. There are also very few CPAN modules that are written for EBCDIC and which don't work on ASCII; instead the vast majority of CPAN modules are written for ASCII, and some may happen to work on EBCDIC, while a few have been designed to portably work on both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0e44a3a37a4109877068f7584a4c6e490675d8" translate="yes" xml:space="preserve">
          <source>Writing Perl on an EBCDIC platform is really no different than writing on an &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; one, but with different underlying numbers, as we'll see shortly. You'll have to know something about those &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; platforms because the documentation is biased and will frequently use example numbers that don't apply to EBCDIC. There are also very few CPAN modules that are written for EBCDIC and which don't work on ASCII; instead the vast majority of CPAN modules are written for ASCII, and some may happen to work on EBCDIC, while a few have been designed to portably work on both.</source>
          <target state="translated">实际上，在EBCDIC平台上写Perl与在&lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt;上写Perl并没有什么不同，但是具有不同的基础数字，我们将很快看到。您将必须了解有关这些&lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt;平台的一些信息，因为该文档有偏见，并且会经常使用不适用于EBCDIC的示例编号。也很少有为EBCDIC编写的CPAN模块，它们不能在ASCII上工作；取而代之的是，绝大多数CPAN模块都是为ASCII编写的，有些可能恰好在EBCDIC上工作，而有些则被设计为可在这两种模块上移植。</target>
        </trans-unit>
        <trans-unit id="b3e7a0572dc689213dcccc6f0ad9b2cbd894a46a" translate="yes" xml:space="preserve">
          <source>Writing Plugins</source>
          <target state="translated">编写插件</target>
        </trans-unit>
        <trans-unit id="b23e7b02c4f050eb7a5f668109f71a414a28c33d" translate="yes" xml:space="preserve">
          <source>Writing Your Own Debugger</source>
          <target state="translated">编写自己的调试器</target>
        </trans-unit>
        <trans-unit id="12d7ef5d9c4d923fdecfc0a2ba03562ba21e7e82" translate="yes" xml:space="preserve">
          <source>Writing a Filter</source>
          <target state="translated">编写过滤器</target>
        </trans-unit>
        <trans-unit id="7f135a17864ace6ae98bf7a3b9d9b4e20dd72358" translate="yes" xml:space="preserve">
          <source>Writing a module with MakeMaker</source>
          <target state="translated">用MakeMaker编写一个模块</target>
        </trans-unit>
        <trans-unit id="f103eaa4bfb0cd111ad63870dfe99daf1dbfeefb" translate="yes" xml:space="preserve">
          <source>Writing a source filter as a separate executable works fine, but a small performance penalty is incurred. For example, if you execute the small example above, a separate subprocess will be created to run the Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; command. Each use of the filter requires its own subprocess. If creating subprocesses is expensive on your system, you might want to consider one of the other options for creating source filters.</source>
          <target state="translated">将源过滤器编写为单独的可执行文件可以很好地工作，但是会导致性能下降。例如，如果您执行上面的小示例，将创建一个单独的子进程来运行Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 命令。过滤器的每次使用都需要其自己的子过程。如果在您的系统上创建子流程非常昂贵，则可能要考虑使用其他选项之一来创建源过滤器。</target>
        </trans-unit>
        <trans-unit id="42340678aabb28dd8e04eb2e84c897c77707c165" translate="yes" xml:space="preserve">
          <source>Writing a source filter as a separate executable works fine, but a small performance penalty is incurred. For example, if you execute the small example above, a separate subprocess will be created to run the Unix &lt;code&gt;tr&lt;/code&gt; command. Each use of the filter requires its own subprocess. If creating subprocesses is expensive on your system, you might want to consider one of the other options for creating source filters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e224913e88be93885651c47ecb1638090afee7fe" translate="yes" xml:space="preserve">
          <source>Writing all these print statements rapidly gets tedious. Fortunately, there's &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt;. It has one function, &lt;code&gt;ok()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc88b791ccf860fd9df472625687a215e4594f7f" translate="yes" xml:space="preserve">
          <source>Writing backticks in your program sends a clear message to the readers of your code that you wanted to collect the output of the command. Why send a clear message that isn't true?</source>
          <target state="translated">在你的程序中写上反标,会向你的代码读者发出一个明确的信息,即你想收集命令的输出。为什么要发送一个不真实的明确信息呢?</target>
        </trans-unit>
        <trans-unit id="a44149bd1f420e38e67feec9febfbe47dcef5694" translate="yes" xml:space="preserve">
          <source>Writing good test scripts</source>
          <target state="translated">编写好的测试脚本</target>
        </trans-unit>
        <trans-unit id="0d1216f3de5359a11d177bd450454690960a8410" translate="yes" xml:space="preserve">
          <source>Writing subroutines</source>
          <target state="translated">编写子程序</target>
        </trans-unit>
        <trans-unit id="a553ca3bc37b04388da0cff3bc379f04cee8df42" translate="yes" xml:space="preserve">
          <source>Writing subroutines is easy:</source>
          <target state="translated">编写子程序很容易。</target>
        </trans-unit>
        <trans-unit id="c828d0e28e2f569743446e2de56ca66e456c09b7" translate="yes" xml:space="preserve">
          <source>Writing the patch</source>
          <target state="translated">编写补丁</target>
        </trans-unit>
        <trans-unit id="5c10b682e330dccc302170e80493f9eb65449a91" translate="yes" xml:space="preserve">
          <source>Writing the short option first is recommended because it's easier to read. The long option is long enough to draw the eye to it anyway and the short option can otherwise get lost in visual noise.</source>
          <target state="translated">建议先写短选项,因为它更容易阅读。反正长选项足够长,可以吸引眼球,否则短选项可能会在视觉噪音中消失。</target>
        </trans-unit>
        <trans-unit id="1b1d022be94ce5d1101d118c8c80cf3364019b48" translate="yes" xml:space="preserve">
          <source>Writing typemap Entries</source>
          <target state="translated">编写类型图条目</target>
        </trans-unit>
        <trans-unit id="1292edaa487b14cb74f82d4343628858075e0756" translate="yes" xml:space="preserve">
          <source>Wrong: the Storable engine creates an empty one for you. If you know Eiffel, you can view &lt;code&gt;STORABLE_thaw&lt;/code&gt; as an alternate creation routine.</source>
          <target state="translated">错误：可存储引擎为您创建了一个空引擎。如果您知道Eiffel，则可以将 &lt;code&gt;STORABLE_thaw&lt;/code&gt; 作为备用创建例程。</target>
        </trans-unit>
        <trans-unit id="efb99bcd657604ed5888480f20557abaea6afd06" translate="yes" xml:space="preserve">
          <source>Wx</source>
          <target state="translated">Wx</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="af3f0530ce3709877b0c716af9417386f334acd7" translate="yes" xml:space="preserve">
          <source>X [vars]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a98d9bf0f92217c5e8d8919ec41748402162fa" translate="yes" xml:space="preserve">
          <source>XCPT_CATCH</source>
          <target state="translated">XCPT_CATCH</target>
        </trans-unit>
        <trans-unit id="0bbce50dfafd43d2aea26e0a316ecb5bb2789444" translate="yes" xml:space="preserve">
          <source>XCPT_RETHROW</source>
          <target state="translated">XCPT_RETHROW</target>
        </trans-unit>
        <trans-unit id="1c8ec453fa062fcc4d8beb21dfeb7f00e0044e3e" translate="yes" xml:space="preserve">
          <source>XCPT_TRY_END</source>
          <target state="translated">XCPT_TRY_END</target>
        </trans-unit>
        <trans-unit id="62c03b6a034496de09dbf74c72c47fb4b194a801" translate="yes" xml:space="preserve">
          <source>XCPT_TRY_START</source>
          <target state="translated">XCPT_TRY_START</target>
        </trans-unit>
        <trans-unit id="42573a00146341106bb0f06ab931a0b8e20775e3" translate="yes" xml:space="preserve">
          <source>XEmacs</source>
          <target state="translated">XEmacs</target>
        </trans-unit>
        <trans-unit id="c0aa9ef764d832b80428d756a731a94251b0e3a1" translate="yes" xml:space="preserve">
          <source>XML</source>
          <target state="translated">XML</target>
        </trans-unit>
        <trans-unit id="494019465f27565c960f3085abca99be390bd01b" translate="yes" xml:space="preserve">
          <source>XML charref mode (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5fc108bfdd5d96d6f99a6eac89c9af874db7d8" translate="yes" xml:space="preserve">
          <source>XPG operability often implies the presence of an</source>
          <target state="translated">XPG的可操作性往往意味着存在着一个 &quot;XPG&quot;。</target>
        </trans-unit>
        <trans-unit id="0f082b9799dcb8475e7d6fcb04a5adfa774635d5" translate="yes" xml:space="preserve">
          <source>XPUSH args AND set RETVAL AND assign return value to array</source>
          <target state="translated">XPUSH args AND set RETVAL AND assign return value to array(将返回值分配给数组)。</target>
        </trans-unit>
        <trans-unit id="6e96c8ba90434c3991abef6b482029bbb705d617" translate="yes" xml:space="preserve">
          <source>XPUSHi</source>
          <target state="translated">XPUSHi</target>
        </trans-unit>
        <trans-unit id="a45f993c8bc95467cd94eca181fdf46437f5427b" translate="yes" xml:space="preserve">
          <source>XPUSHmortal</source>
          <target state="translated">XPUSHmortal</target>
        </trans-unit>
        <trans-unit id="b231a036815021c5444d064b7fcc1c528ade03e8" translate="yes" xml:space="preserve">
          <source>XPUSHn</source>
          <target state="translated">XPUSHn</target>
        </trans-unit>
        <trans-unit id="f47cdabf2ef1edeef2bd1fb53b6f18747c332149" translate="yes" xml:space="preserve">
          <source>XPUSHp</source>
          <target state="translated">XPUSHp</target>
        </trans-unit>
        <trans-unit id="1dab76d5986d1df120c308434288452972f88fb7" translate="yes" xml:space="preserve">
          <source>XPUSHs</source>
          <target state="translated">XPUSHs</target>
        </trans-unit>
        <trans-unit id="f596fc77ff9e6f6918218a1843202b6b44412bbc" translate="yes" xml:space="preserve">
          <source>XPUSHu</source>
          <target state="translated">XPUSHu</target>
        </trans-unit>
        <trans-unit id="bdb1d0d2760db0ae33b02dff5258e945e708b990" translate="yes" xml:space="preserve">
          <source>XS</source>
          <target state="translated">XS</target>
        </trans-unit>
        <trans-unit id="92bd1887109d3a53eb97d00630c2016c2f9abe52" translate="yes" xml:space="preserve">
          <source>XS VERSION</source>
          <target state="translated">XS版本</target>
        </trans-unit>
        <trans-unit id="f150c9e4da4e74cdaf804a24288dd2d36c2aab56" translate="yes" xml:space="preserve">
          <source>XS code added by Greg Bacon &amp;lt;</source>
          <target state="translated">Greg Bacon添加的XS代码&amp;lt;</target>
        </trans-unit>
        <trans-unit id="1cf142c571c2183260c4664ac183845da5980944" translate="yes" xml:space="preserve">
          <source>XS code can usually be made to work with any platform, but dependent libraries, header files, etc., might not be readily available or portable, or the XS code itself might be platform-specific, just as Perl code might be. If the libraries and headers are portable, then it is normally reasonable to make sure the XS code is portable, too.</source>
          <target state="translated">XS代码通常可以在任何平台上工作,但依赖的库、头文件等可能不是现成的或可移植的,或者XS代码本身可能是平台特定的,就像Perl代码一样。如果库和头文件是可移植的,那么确保XS代码也是可移植的通常是合理的。</target>
        </trans-unit>
        <trans-unit id="292d659c22a7eedddefa474cf1aa726bcee0908b" translate="yes" xml:space="preserve">
          <source>XS code for using native C functions borrowed from &lt;code&gt;&lt;a href=&quot;Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt;, written by Marcus Harnisch &amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8ccd1927a425f4cd71fc5858f4ce61be503a94" translate="yes" xml:space="preserve">
          <source>XS code for using native C functions borrowed from &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt;, written by Marcus Harnisch &amp;lt;</source>
          <target state="translated">Marcus Harnisch编写的用于从 &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt; 借用的使用本机C函数的XS代码，&amp;lt;</target>
        </trans-unit>
        <trans-unit id="fe30568ef2d4c300e100572dbcce63bef5e87790" translate="yes" xml:space="preserve">
          <source>XS code has full access to system calls including C library functions. It thus has the capability of interfering with things that the Perl core or other modules have set up, such as signal handlers or file handles. It could mess with the memory, or any number of harmful things. Don't.</source>
          <target state="translated">XS代码可以完全访问系统调用,包括C库函数。因此,它有能力干扰Perl核心或其他模块所设置的东西,如信号处理程序或文件句柄。它可能会扰乱内存,或者任何有害的东西。不要。</target>
        </trans-unit>
        <trans-unit id="33d48b61f9e9a038a7aea1ef00483763c58f6eff" translate="yes" xml:space="preserve">
          <source>XS code is probably better using &quot;typemap&quot; if it expects FILE * arguments. The standard typemap will be adjusted to comprehend any changes in this area.</source>
          <target state="translated">XS代码如果期望FILE *参数,可能最好使用 &quot;tyemap&quot;。标准的typemap将被调整以理解这方面的任何变化。</target>
        </trans-unit>
        <trans-unit id="89e8c193e223b649f3d44b4194d19ce56bb23e01" translate="yes" xml:space="preserve">
          <source>XS code is very sensitive to the module version number and will complain if the version number in your Perl module doesn't match. If you change your module's version # without rerunning Makefile.PL the old version number will remain in the Makefile, causing the XS code to be built with the wrong number.</source>
          <target state="translated">XS代码对模块的版本号非常敏感,如果你的Perl模块的版本号不匹配,XS代码就会抱怨。如果你改变了你的模块版本号而没有重新运行Makefile.PL,旧的版本号将保留在Makefile中,导致XS代码被编译成错误的版本号。</target>
        </trans-unit>
        <trans-unit id="9966dea2f0bef9d06ac3bd55d265441a4061b99f" translate="yes" xml:space="preserve">
          <source>XS code or C-language libraries called from it that use the system &lt;a href=&quot;setlocale(3)&quot;&gt;&lt;code&gt;setlocale(3)&lt;/code&gt;&lt;/a&gt; function (except on Windows) likely will not work from a multi-threaded application without changes. See &lt;a href=&quot;perlxs#Locale-aware-XS-code&quot;&gt;&quot;Locale-aware XS code&quot; in perlxs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def563b19b3d7a04b960dc4d401ac89d52a4e717" translate="yes" xml:space="preserve">
          <source>XS is an interface description file format used to create an extension interface between Perl and C code (or a C library) which one wishes to use with Perl. The XS interface is combined with the library to create a new library which can then be either dynamically loaded or statically linked into perl. The XS interface description is written in the XS language and is the core component of the Perl extension interface.</source>
          <target state="translated">XS是一种接口描述文件格式,用于在Perl和C代码(或C库)之间创建一个扩展接口,以便与Perl一起使用。XS接口与库相结合,创建一个新的库,然后可以动态加载或静态链接到perl中。XS接口描述是用XS语言编写的,是Perl扩展接口的核心组件。</target>
        </trans-unit>
        <trans-unit id="c1322757203b80e7b2662642555746c59f625860" translate="yes" xml:space="preserve">
          <source>XS modules for all categories but &lt;code&gt;LC_NUMERIC&lt;/code&gt; get the underlying locale, and hence any C library functions they call will use that underlying locale. For more discussion, see &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;&quot;CAVEATS&quot; in perlxs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6e0da0571ab8b6cd13332fb1b92e13ef69723c3" translate="yes" xml:space="preserve">
          <source>XS modules for all categories but &lt;code&gt;LC_NUMERIC&lt;/code&gt; get the underlying locale, and hence any C library functions they call will use that underlying locale. For more discussion, see &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;CAVEATS in perlxs&lt;/a&gt;.</source>
          <target state="translated">除 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 以外的所有类别的XS模块都获得基础语言环境，因此，它们调用的任何C库函数都将使用该基础语言环境。有关更多讨论，请参见&lt;a href=&quot;perlxs#CAVEATS&quot;&gt;perlxs中的CAVEATS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cde8f9f4aa7dc1d35b0c98fee87c3ff3dfbc220c" translate="yes" xml:space="preserve">
          <source>XS-type modules do require re-linking the perl binary, because part of an XS module is written in &quot;C&quot;, and has to be linked together with the perl binary to be executed. This is required because perl under DJGPP is built with the &quot;static link&quot; option, due to the lack of &quot;dynamic linking&quot; in the DJGPP environment.</source>
          <target state="translated">XS类型的模块确实需要重新链接perl二进制文件,因为XS模块的一部分是用 &quot;C &quot;写的,必须和要执行的perl二进制文件链接在一起。之所以需要这样做,是因为DJGPP下的perl是以 &quot;静态链接 &quot;选项构建的,因为DJGPP环境中缺乏 &quot;动态链接&quot;。</target>
        </trans-unit>
        <trans-unit id="ec2988beaa8676362d1ed3ab16467d9b855facea" translate="yes" xml:space="preserve">
          <source>XS::APItest</source>
          <target state="translated">XS::APItest</target>
        </trans-unit>
        <trans-unit id="f864391a1885990bb3986e5bb9cdfe1529118689" translate="yes" xml:space="preserve">
          <source>XS::APItest - Test the perl C API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77965b88f2916dfa7ea799a1ecde83c5bade894f" translate="yes" xml:space="preserve">
          <source>XS::Typemap</source>
          <target state="translated">XS::Typemap</target>
        </trans-unit>
        <trans-unit id="1e9618266eb67d10623f9d27874dc8f7655ade73" translate="yes" xml:space="preserve">
          <source>XS::Typemap - module to test the XS typemaps distributed with perl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb06f137479712fdf29157a9f339063d581a30d" translate="yes" xml:space="preserve">
          <source>XSBUILD</source>
          <target state="translated">XSBUILD</target>
        </trans-unit>
        <trans-unit id="69f57ba624b38c0aa8389aea0ffe9fd217df0165" translate="yes" xml:space="preserve">
          <source>XSLoader</source>
          <target state="translated">XSLoader</target>
        </trans-unit>
        <trans-unit id="afd8fa1c6f48c528375edb581b5cfae64284c5a7" translate="yes" xml:space="preserve">
          <source>XSLoader - Dynamically load C libraries into Perl code</source>
          <target state="translated">XSLoader-动态加载C库到Perl代码中。</target>
        </trans-unit>
        <trans-unit id="beb5f03415996a22eb7162d79a1cf0e450db5ba8" translate="yes" xml:space="preserve">
          <source>XSMULTI</source>
          <target state="translated">XSMULTI</target>
        </trans-unit>
        <trans-unit id="0921a161e9b005cd558f520ad84c3711a9234802" translate="yes" xml:space="preserve">
          <source>XSOPT</source>
          <target state="translated">XSOPT</target>
        </trans-unit>
        <trans-unit id="92e8e6dd254dabeb8537af4197e956a328b3ea2d" translate="yes" xml:space="preserve">
          <source>XSPROTOARG</source>
          <target state="translated">XSPROTOARG</target>
        </trans-unit>
        <trans-unit id="870a57e9b71b2a4c7d8b5d7661446dadbdc3d78c" translate="yes" xml:space="preserve">
          <source>XSRETURN</source>
          <target state="translated">XSRETURN</target>
        </trans-unit>
        <trans-unit id="4412705ffd15db1cc81dd4e97115e4240eed7c02" translate="yes" xml:space="preserve">
          <source>XSRETURN_EMPTY</source>
          <target state="translated">XSRETURN_EMPTY</target>
        </trans-unit>
        <trans-unit id="7516ad5d6afe7eff2028827f9d3ce25b91d747e1" translate="yes" xml:space="preserve">
          <source>XSRETURN_IV</source>
          <target state="translated">XSRETURN_IV</target>
        </trans-unit>
        <trans-unit id="7e5a22d1a7883f884227641cdf52bde57c7c0cd5" translate="yes" xml:space="preserve">
          <source>XSRETURN_NO</source>
          <target state="translated">XSRETURN_NO</target>
        </trans-unit>
        <trans-unit id="a72df091bba7b8d6d0f9b76040485b4a1059b320" translate="yes" xml:space="preserve">
          <source>XSRETURN_NV</source>
          <target state="translated">XSRETURN_NV</target>
        </trans-unit>
        <trans-unit id="c9bd2b450336e9a3992bddc7c7b4a884bb908613" translate="yes" xml:space="preserve">
          <source>XSRETURN_PV</source>
          <target state="translated">XSRETURN_PV</target>
        </trans-unit>
        <trans-unit id="31bb0caf5acf67711f8b48a53013782fa24d0e5c" translate="yes" xml:space="preserve">
          <source>XSRETURN_UNDEF</source>
          <target state="translated">XSRETURN_UNDEF</target>
        </trans-unit>
        <trans-unit id="75dd44c03d403bbc60a246b9a6263dd12586d022" translate="yes" xml:space="preserve">
          <source>XSRETURN_UV</source>
          <target state="translated">XSRETURN_UV</target>
        </trans-unit>
        <trans-unit id="6940b196422b14c137e4603100533585c01d3873" translate="yes" xml:space="preserve">
          <source>XSRETURN_YES</source>
          <target state="translated">XSRETURN_YES</target>
        </trans-unit>
        <trans-unit id="0071e55f0de2d741b86408cbdd221e6b71588408" translate="yes" xml:space="preserve">
          <source>XST_mIV</source>
          <target state="translated">XST_mIV</target>
        </trans-unit>
        <trans-unit id="8746b00346bb95fd6d7203847b95eace0e227af2" translate="yes" xml:space="preserve">
          <source>XST_mNO</source>
          <target state="translated">XST_mNO</target>
        </trans-unit>
        <trans-unit id="18b7e60b2312b4cdf84185a38f3105ba024df44d" translate="yes" xml:space="preserve">
          <source>XST_mNV</source>
          <target state="translated">XST_mNV</target>
        </trans-unit>
        <trans-unit id="f5704ef0a40693c861b7a0f79e6acb2f0a79e526" translate="yes" xml:space="preserve">
          <source>XST_mPV</source>
          <target state="translated">XST_mPV</target>
        </trans-unit>
        <trans-unit id="b30947135a6d0dc9cd094f1f5c672b0d8df27a87" translate="yes" xml:space="preserve">
          <source>XST_mUNDEF</source>
          <target state="translated">XST_mUNDEF</target>
        </trans-unit>
        <trans-unit id="c4c00149e31a863f36a4eccec4b30bed628c9d7b" translate="yes" xml:space="preserve">
          <source>XST_mUV</source>
          <target state="translated">XST_mUV</target>
        </trans-unit>
        <trans-unit id="850783c2d3d2b8cee3448cdaf150b58812cdd570" translate="yes" xml:space="preserve">
          <source>XST_mYES</source>
          <target state="translated">XST_mYES</target>
        </trans-unit>
        <trans-unit id="ddfc93741501a0abefa88da99d97e36deaed4cbc" translate="yes" xml:space="preserve">
          <source>XSUB</source>
          <target state="translated">XSUB</target>
        </trans-unit>
        <trans-unit id="4579138c9695c3de09b5142af11ef81d8446e749" translate="yes" xml:space="preserve">
          <source>XSUB.h</source>
          <target state="translated">XSUB.h</target>
        </trans-unit>
        <trans-unit id="df024d96e0c6354fb4e32675dd41d60e15bc6f98" translate="yes" xml:space="preserve">
          <source>XSUBANY</source>
          <target state="translated">XSUBANY</target>
        </trans-unit>
        <trans-unit id="4df5cfe3d83127b158a7d5a161b5570785b675ad" translate="yes" xml:space="preserve">
          <source>XSUBs and the Argument Stack</source>
          <target state="translated">XSUBs和参数栈</target>
        </trans-unit>
        <trans-unit id="638efca4cf9c7b80e03f195d87e0ea4d39d29c81" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to avoid automatic conversion of Perl function arguments to C function arguments. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details. Some people prefer manual conversion by inspecting &lt;code&gt;ST(i)&lt;/code&gt; even in the cases when automatic conversion will do, arguing that this makes the logic of an XSUB call clearer. Compare with &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;&quot;Getting the fat out of XSUBs&quot;&lt;/a&gt; for a similar tradeoff of a complete separation of &quot;Perl glue&quot; and &quot;workhorse&quot; parts of an XSUB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b5999991ea7d60b38c8ca1802a3aa2e3198b825" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to avoid automatic conversion of Perl function arguments to C function arguments. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details. Some people prefer manual conversion by inspecting &lt;code&gt;ST(i)&lt;/code&gt; even in the cases when automatic conversion will do, arguing that this makes the logic of an XSUB call clearer. Compare with &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt; for a similar tradeoff of a complete separation of &quot;Perl glue&quot; and &quot;workhorse&quot; parts of an XSUB.</source>
          <target state="translated">还允许XSUB避免将Perl函数参数自动转换为C函数参数。有关详细信息，请参见&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;。甚至在自动转换可以进行的情况下，有些人还是喜欢通过检查 &lt;code&gt;ST(i)&lt;/code&gt; 来进行手动转换，因为这使XSUB调用的逻辑更加清晰。与&lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;将脂肪从&lt;/a&gt; XSUB中移除相比，XBOX的&amp;ldquo; Perl胶&amp;rdquo;和&amp;ldquo;主力&amp;rdquo;部分的完全分离具有类似的权衡。</target>
        </trans-unit>
        <trans-unit id="54080bcfea2adf5c913b064ead22f355c2ce0033" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to return lists, not just scalars. This must be done by manipulating stack values ST(0), ST(1), etc, in a subtly different way. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details.</source>
          <target state="translated">还允许XSUB返回列表，而不仅仅是标量。这必须通过以微妙的不同方式操纵堆栈值ST（0），ST（1）等来完成。有关详细信息，请参见&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88b3157d6a7563b7eeae312db4f170271aab7d57" translate="yes" xml:space="preserve">
          <source>XSUBs can have variable-length parameter lists by specifying an ellipsis &lt;code&gt;(...)&lt;/code&gt; in the parameter list. This use of the ellipsis is similar to that found in ANSI C. The programmer is able to determine the number of arguments passed to the XSUB by examining the &lt;code&gt;items&lt;/code&gt; variable which the &lt;b&gt;xsubpp&lt;/b&gt; compiler supplies for all XSUBs. By using this mechanism one can create an XSUB which accepts a list of parameters of unknown length.</source>
          <target state="translated">通过在参数列表中指定省略号 &lt;code&gt;(...)&lt;/code&gt; ，XSUB可以具有可变长度的参数列表。省略号的这种用法类似于ANSI C中的用法。程序员可以通过检查&lt;b&gt;xsubpp&lt;/b&gt;编译器为所有&lt;b&gt;XSUB&lt;/b&gt;提供的 &lt;code&gt;items&lt;/code&gt; 变量来确定传递给XSUB的参数数量。通过使用这种机制，可以创建一个XSUB，它接受未知长度的参数列表。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3be2c3082f6ee5ac4e24cba3fef031d150316f00" translate="yes" xml:space="preserve">
          <source>XSUBs do not have a &lt;code&gt;CvPADLIST&lt;/code&gt;. &lt;code&gt;dXSTARG&lt;/code&gt; fetches values from &lt;code&gt;PL_curpad&lt;/code&gt;, but that is really the callers pad (a slot of which is allocated by every entersub). Do not get or set &lt;code&gt;CvPADLIST&lt;/code&gt; if a CV is an XSUB (as determined by &lt;code&gt;CvISXSUB()&lt;/code&gt;), &lt;code&gt;CvPADLIST&lt;/code&gt; slot is reused for a different internal purpose in XSUBs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2e0ddc3d17d87460a2a8a983be1c97c83b73d1" translate="yes" xml:space="preserve">
          <source>XSUBs do not have a CvPADLIST. dXSTARG fetches values from PL_curpad, but that is really the callers pad (a slot of which is allocated by every entersub). Do not get or set CvPADLIST if a CV is an XSUB (as determined by &lt;code&gt;CvISXSUB()&lt;/code&gt; ), CvPADLIST slot is reused for a different internal purpose in XSUBs.</source>
          <target state="translated">XSUB没有CvPADLIST。dXSTARG从PL_curpad中获取值，但这实际上是调用者板（每个entersub都分配了其插槽）。如果CV是XSUB（由 &lt;code&gt;CvISXSUB()&lt;/code&gt; 确定），则不要获取或设置CvPADLIST ，CvPADLIST插槽在XSUB中被用于其他内部用途。</target>
        </trans-unit>
        <trans-unit id="6daf3f5f97a3cf191b47d0b650ffb497515d3ee1" translate="yes" xml:space="preserve">
          <source>XSUBs refer to their stack arguments with the macro &lt;b&gt;ST(x)&lt;/b&gt;, where</source>
          <target state="translated">XSUB使用宏&lt;b&gt;ST（x）&lt;/b&gt;引用其堆栈参数，其中</target>
        </trans-unit>
        <trans-unit id="b948898c3205f86da22df7bb2aa8e0fc31385f66" translate="yes" xml:space="preserve">
          <source>XS_APIVERSION_BOOTCHECK</source>
          <target state="translated">XS_APIVERSION_BOOTCHECK</target>
        </trans-unit>
        <trans-unit id="45e92c706e14fc42e8a65549cfb504f51b80720e" translate="yes" xml:space="preserve">
          <source>XS_DEFINE_VERSION: -D line to set the xs version when compiling.</source>
          <target state="translated">XS_DEFINE_VERSION:-D行用于在编译时设置xs版本。</target>
        </trans-unit>
        <trans-unit id="c079612ab9bf6b165676a675aeaa6f541c733506" translate="yes" xml:space="preserve">
          <source>XS_EXTERNAL</source>
          <target state="translated">XS_EXTERNAL</target>
        </trans-unit>
        <trans-unit id="b36c9e63716f92004705d5a5880b339795a114b1" translate="yes" xml:space="preserve">
          <source>XS_FH</source>
          <target state="translated">XS_FH</target>
        </trans-unit>
        <trans-unit id="0b91e170805a05f3fc3b4f1fe3e1c801a51a5cd9" translate="yes" xml:space="preserve">
          <source>XS_FILE</source>
          <target state="translated">XS_FILE</target>
        </trans-unit>
        <trans-unit id="5a72d7eb1d508bb628564c702b5adf9c962f07c6" translate="yes" xml:space="preserve">
          <source>XS_INTERNAL</source>
          <target state="translated">XS_INTERNAL</target>
        </trans-unit>
        <trans-unit id="c30e58ff83929eb55292bc3f56bfb117c5d6b82f" translate="yes" xml:space="preserve">
          <source>XS_SUBNAME</source>
          <target state="translated">XS_SUBNAME</target>
        </trans-unit>
        <trans-unit id="c3c54470969e9570024cbdc019515c6664650a72" translate="yes" xml:space="preserve">
          <source>XS_VERSION</source>
          <target state="translated">XS_VERSION</target>
        </trans-unit>
        <trans-unit id="f6c7bf9f42bb6c2a25e194ec60219f0a8150edce" translate="yes" xml:space="preserve">
          <source>XS_VERSION: version in your .xs file. Defaults to $(VERSION)</source>
          <target state="translated">XS_VERSION:.xs文件中的版本。默认值为$(VERSION)</target>
        </trans-unit>
        <trans-unit id="849ccfe7e642de7c6c2afec3b38bc17a103cbe71" translate="yes" xml:space="preserve">
          <source>XS_VERSION_BOOTCHECK</source>
          <target state="translated">XS_VERSION_BOOTCHECK</target>
        </trans-unit>
        <trans-unit id="53fccca1190b204bd667ec9d6791fd3b9d14df6c" translate="yes" xml:space="preserve">
          <source>XS_VERSION_MACRO: which macro represents the XS version.</source>
          <target state="translated">XS_VERSION_MACRO:哪个宏代表XS版本。</target>
        </trans-unit>
        <trans-unit id="c3b618e9ce8bc3b3691008b5df681815a883cb69" translate="yes" xml:space="preserve">
          <source>XS_constant PACKAGE, TYPES, XS_SUBNAME, C_SUBNAME</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20026dc165c030fe3a5d9609a6e61ab26210cbc1" translate="yes" xml:space="preserve">
          <source>XX</source>
          <target state="translated">XX</target>
        </trans-unit>
        <trans-unit id="a9674b19f8c56f785c91a555d0a144522bb318e6" translate="yes" xml:space="preserve">
          <source>XXX</source>
          <target state="translated">XXX</target>
        </trans-unit>
        <trans-unit id="efc0ac66700effcf3b5c6d5cfb0d3ed1e5da5cc1" translate="yes" xml:space="preserve">
          <source>XXX DAPM it would make more sense to make the arg a PADOFFSET void SAVEPADSV(PADOFFSET po)</source>
          <target state="translated">XXX DAPM如果把arg做成PADOFFSET会更有意义 void SAVEPADSV(PADOFFSET po)</target>
        </trans-unit>
        <trans-unit id="0a8c3822391bb958edc27b75e5a6c90f50363bce" translate="yes" xml:space="preserve">
          <source>XXX.</source>
          <target state="translated">XXX.</target>
        </trans-unit>
        <trans-unit id="759d5f762181a933d7c0ff7fd8096838ff6b5ec3" translate="yes" xml:space="preserve">
          <source>XXX: Needs more docs.</source>
          <target state="translated">XXX:需要更多的文件。</target>
        </trans-unit>
        <trans-unit id="e3a8809017dd76bd26557a5b923ab2ae16c0cdb3" translate="yes" xml:space="preserve">
          <source>XXXX</source>
          <target state="translated">XXXX</target>
        </trans-unit>
        <trans-unit id="034f1965ccdbdf9e642feeb9858da5096b6d1a9a" translate="yes" xml:space="preserve">
          <source>XY</source>
          <target state="translated">XY</target>
        </trans-unit>
        <trans-unit id="1ed31ab8e3d4874b1d94827212eca5617d49d812" translate="yes" xml:space="preserve">
          <source>XopDISABLE</source>
          <target state="translated">XopDISABLE</target>
        </trans-unit>
        <trans-unit id="fdee56cbf2dd3729d372ee9ddd71eeb3c584e3a0" translate="yes" xml:space="preserve">
          <source>XopENABLE</source>
          <target state="translated">XopENABLE</target>
        </trans-unit>
        <trans-unit id="d452a85c41b2e0aa7a38834ff3a3b101c7d4ac6f" translate="yes" xml:space="preserve">
          <source>XopENTRY</source>
          <target state="translated">XopENTRY</target>
        </trans-unit>
        <trans-unit id="12a6abfec4959cd21c68fcfdd5a310b6940a1038" translate="yes" xml:space="preserve">
          <source>XopENTRYCUSTOM</source>
          <target state="translated">XopENTRYCUSTOM</target>
        </trans-unit>
        <trans-unit id="f6bc06eec4d13090054285af25a6e8fdfa5cb801" translate="yes" xml:space="preserve">
          <source>XopENTRY_set</source>
          <target state="translated">XopENTRY_set</target>
        </trans-unit>
        <trans-unit id="b37b621154ed9fa599925b4a3aa2dcee68ee7486" translate="yes" xml:space="preserve">
          <source>XopFLAGS</source>
          <target state="translated">XopFLAGS</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="ffbcb202b09db426bae56cf2ffb88f18594f2258" translate="yes" xml:space="preserve">
          <source>YAML</source>
          <target state="translated">YAML</target>
        </trans-unit>
        <trans-unit id="50bc04e009ed4a61bc2c2e4c00258238b3cec732" translate="yes" xml:space="preserve">
          <source>YAML result token.</source>
          <target state="translated">YAML结果标记。</target>
        </trans-unit>
        <trans-unit id="453e08045c54cb8be51989088de3dde3aad22542" translate="yes" xml:space="preserve">
          <source>YAML, &lt;a href=&quot;http://www.yaml.org/&quot;&gt;http://www.yaml.org/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fff039853f5c2bbb8a28d056b579c7dcb7d137f" translate="yes" xml:space="preserve">
          <source>YES</source>
          <target state="translated">YES</target>
        </trans-unit>
        <trans-unit id="bf4ca579becca81a75bf09eee1a917765b24f975" translate="yes" xml:space="preserve">
          <source>YMMV.</source>
          <target state="translated">YMMV.</target>
        </trans-unit>
        <trans-unit id="f4577d4c77ab9c132acbb835cae3c75d2c81ffab" translate="yes" xml:space="preserve">
          <source>YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a8fc610a3168e82e07390203ce40d7382c7da6f" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DDThh:mm:ss</source>
          <target state="translated">YYYY-MM-DDThh:mm:ss</target>
        </trans-unit>
        <trans-unit id="76ac22fb38468218ad6552d9043d5bb2c7920d48" translate="yes" xml:space="preserve">
          <source>Year Value Interpretation</source>
          <target state="translated">年值解释</target>
        </trans-unit>
        <trans-unit id="44f6289f7e3326b30824a187cdb204e4dc7264b2" translate="yes" xml:space="preserve">
          <source>Years greater than 999 are interpreted as being the actual year, rather than the offset from 1900. Thus, 1964 would indicate the year Martin Luther King won the Nobel prize, not the year 3864.</source>
          <target state="translated">大于999的年份被解释为实际年份,而不是从1900年开始的偏移。因此,1964年是马丁-路德-金获得诺贝尔奖的年份,而不是3864年。</target>
        </trans-unit>
        <trans-unit id="c9ec20e90ee8369d4a4738a1355fc718ca45a57e" translate="yes" xml:space="preserve">
          <source>Years in the range 0..99 are interpreted as shorthand for years in the rolling &quot;current century,&quot; defined as 50 years on either side of the current year. Thus, today, in 1999, 0 would refer to 2000, and 45 to 2045, but 55 would refer to 1955. Twenty years from now, 55 would instead refer to 2055. This is messy, but matches the way people currently think about two digit dates. Whenever possible, use an absolute four digit year instead.</source>
          <target state="translated">0..99范围内的年份被解释为滚动的 &quot;本世纪 &quot;中的年份的简写,定义为当年两边的50年。因此,今天,在1999年,0指的是2000年,45指的是2045年,但55指的是1955年。20年后,55反而会指2055年。这很混乱,但符合目前人们对两位数日期的思考方式。只要有可能,就用绝对的四位数年份来代替。</target>
        </trans-unit>
        <trans-unit id="862a9bbc8aa08db48d5ef905c8dc85be457e6ea8" translate="yes" xml:space="preserve">
          <source>Years in the range 100..999 are interpreted as offset from 1900, so that 112 indicates 2012. This rule also applies to years less than zero (but see note below regarding date range).</source>
          <target state="translated">在100...999范围内的年份被解释为从1900年开始的偏移,因此,112表示2012年。这一规则也适用于小于零的年份(但见下文关于日期范围的说明)。</target>
        </trans-unit>
        <trans-unit id="dfc439a506f8ca9ae872d5d02c2ad4c82b034c13" translate="yes" xml:space="preserve">
          <source>Yes it is, see previous answer. Since &lt;code&gt;Compress::Zlib&lt;/code&gt; and therefore &lt;code&gt;IO::Zlib&lt;/code&gt; doesn't support &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; on their filehandles, there is little choice but to read the archive into memory. This is ok if you want to do in-memory manipulation of the archive.</source>
          <target state="translated">是的，请参阅先前的答案。由于 &lt;code&gt;Compress::Zlib&lt;/code&gt; 以及 &lt;code&gt;IO::Zlib&lt;/code&gt; 不支持在其文件句柄上进行 &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; ，因此别无选择，只能将存档读入内存。如果要对归档执行内存中操作，则可以。</target>
        </trans-unit>
        <trans-unit id="4a483b69465fec8d9ad0abf1cb110a3cd5a4d0a4" translate="yes" xml:space="preserve">
          <source>Yes it is, see previous answer. Since &lt;code&gt;Compress::Zlib&lt;/code&gt; and therefore &lt;code&gt;IO::Zlib&lt;/code&gt; doesn't support &lt;code&gt;seek&lt;/code&gt; on their filehandles, there is little choice but to read the archive into memory. This is ok if you want to do in-memory manipulation of the archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb5099459bfa43931dd4b78a628e1d113168a69" translate="yes" xml:space="preserve">
          <source>Yes it is. It's pure perl, so it's a lot slower then your &lt;code&gt;/bin/tar&lt;/code&gt; However, it's very portable. If speed is an issue, consider using &lt;code&gt;/bin/tar&lt;/code&gt; instead.</source>
          <target state="translated">是的。它是纯Perl，所以它比 &lt;code&gt;/bin/tar&lt;/code&gt; 慢得多。但是，它非常易于移植。如果速度是一个问题，请考虑改用 &lt;code&gt;/bin/tar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcbbf7da5377bd36deaae3d4c290fed0db7777c9" translate="yes" xml:space="preserve">
          <source>Yes, both the &lt;code&gt;IO-Compress-Zip&lt;/code&gt; and &lt;code&gt;IO-Uncompress-Unzip&lt;/code&gt; modules support the zip feature called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4107dbe8a030ec286ba38d4f763957128d667542" translate="yes" xml:space="preserve">
          <source>Yes, it does</source>
          <target state="translated">是的,它是</target>
        </trans-unit>
        <trans-unit id="3678471c058284ba4000bf6331c346c6bbd02a28" translate="yes" xml:space="preserve">
          <source>Yes, that's a lot of expansion.</source>
          <target state="translated">是的,这是一个很大的扩展。</target>
        </trans-unit>
        <trans-unit id="eb5a8cd62389870da5aba481f01f1a18a4a6e511" translate="yes" xml:space="preserve">
          <source>Yes, there's a lot of that :-) But more precisely, in UNIX systems there's a utility called &lt;code&gt;file&lt;/code&gt; , which recognizes data files based on their contents (usually their first few bytes). For this to work, a certain file called</source>
          <target state="translated">是的，有很多:-)但是，更准确地说，在UNIX系统中，有一个名为 &lt;code&gt;file&lt;/code&gt; 的实用程序，该实用程序根据其内容（通常是前几个字节）识别数据文件。为此，某个文件称为</target>
        </trans-unit>
        <trans-unit id="f71f9d886920a4f49da8093935995672de9199c3" translate="yes" xml:space="preserve">
          <source>Yes, there's a lot of that :-) But more precisely, in UNIX systems there's a utility called &lt;code&gt;file&lt;/code&gt;, which recognizes data files based on their contents (usually their first few bytes). For this to work, a certain file called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032ab970df677757a74b1c2b5fdbae010210746c" translate="yes" xml:space="preserve">
          <source>Yes, there's a mistake in the test suite. What! Me, contrived?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc1e472e45c46619f7f9549ce98213f0173da937" translate="yes" xml:space="preserve">
          <source>Yes, you can do this by either using the &lt;code&gt;-T&lt;/code&gt; option, or by invoking the program as &lt;code&gt;perlthanks&lt;/code&gt; . Thank-you notes are good. It makes people smile.</source>
          <target state="translated">是的，您可以通过使用 &lt;code&gt;-T&lt;/code&gt; 选项或以 &lt;code&gt;perlthanks&lt;/code&gt; 的身份调用程序来执行此操作。谢谢你的笔记很好。它使人微笑。</target>
        </trans-unit>
        <trans-unit id="8987958587b6289e3623984d6459696a8ad818f9" translate="yes" xml:space="preserve">
          <source>Yes, you can do this by either using the &lt;code&gt;-T&lt;/code&gt; option, or by invoking the program as &lt;code&gt;perlthanks&lt;/code&gt;. Thank-you notes are good. It makes people smile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c8d0f90fcceba5d3649946cef16ef6f0de57be0" translate="yes" xml:space="preserve">
          <source>Yes, you can! If your sources are UTF-8 encoded, you can indicate that with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma.</source>
          <target state="translated">是的你可以！如果您的源是UTF-8编码的，则可以 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma进行指示。</target>
        </trans-unit>
        <trans-unit id="77a1a43bdaae65a00429084f6cd8a3dc8163734c" translate="yes" xml:space="preserve">
          <source>Yes, you can! If your sources are UTF-8 encoded, you can indicate that with the &lt;code&gt;use utf8&lt;/code&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd3c0b60626749e4fb04200f5ac37da9c3ba6f91" translate="yes" xml:space="preserve">
          <source>Yes, you could probably do the same thing with code like $token-&amp;gt;isa('Pod::Simple::PullParserEndToken'), but that's not so pretty as using just $token-&amp;gt;type, or even the following shortcuts:</source>
          <target state="translated">是的，您可能可以使用$ token-&amp;gt; isa（'Pod :: Simple :: PullParserEndToken'）之类的代码执行相同的操作，但这并不像仅使用$ token-&amp;gt; type甚至以下快捷方式那样漂亮：</target>
        </trans-unit>
        <trans-unit id="9ba10bd10462c10515a891999d5f144a0ef8db84" translate="yes" xml:space="preserve">
          <source>Yes. If you are building a web site with any level of interactivity (forms / users / databases), you will want to use a framework to make handling requests and responses easier.</source>
          <target state="translated">是的,如果你正在建立一个具有任何交互性的网站(表单/用户/数据库),你会希望使用一个框架来使处理请求和响应更容易。</target>
        </trans-unit>
        <trans-unit id="4131deed69500e1ce76a1aa4746c5be5d04540cb" translate="yes" xml:space="preserve">
          <source>Yes. Perl's garbage collection system takes care of this so everything works out right.</source>
          <target state="translated">是的,Perl 的垃圾收集系统会处理好这个问题,所以一切都很正常。Perl的垃圾收集系统会处理这些问题,所以一切都很正常。</target>
        </trans-unit>
        <trans-unit id="3a7fae4176564291917eb6c0f952942b7ae63ec5" translate="yes" xml:space="preserve">
          <source>Yes. Read &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for more information. Some examples follow. (These assume standard Unix shell quoting rules.)</source>
          <target state="translated">是。阅读&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;以获取更多信息。以下是一些示例。（这些假设标准的Unix Shell引用规则。）</target>
        </trans-unit>
        <trans-unit id="64a64c9d49bc7ff568ef5c62aefe6945eee0a81a" translate="yes" xml:space="preserve">
          <source>Yes. Zip64 allows this. See previous question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85739d75a309637ea84dea150d48798fe5f385f6" translate="yes" xml:space="preserve">
          <source>Yet Another Compiler Compiler. A parser generator without which Perl probably would not have existed. See the file</source>
          <target state="translated">又一个编译器编译器。一个解析器生成器,如果没有它,Perl可能就不存在了。参见文件</target>
        </trans-unit>
        <trans-unit id="7fafe5e36aa3122413d32c6d4c8b4284bb245038" translate="yes" xml:space="preserve">
          <source>Yet another capturing group numbering technique (also as from Perl 5.10) deals with the problem of referring to groups within a set of alternatives. Consider a pattern for matching a time of the day, civil or military style:</source>
          <target state="translated">然而,另一种捕捉组号的技术(也是Perl 5.10中的技术)处理的是在一组备选方案中引用组的问题。考虑一个用于匹配一天中的时间、民用或军用风格的模式。</target>
        </trans-unit>
        <trans-unit id="a23e788a3e5975e13dc401fc7dc400a7d94469f5" translate="yes" xml:space="preserve">
          <source>Yet another framework for writing test scripts</source>
          <target state="translated">然而,另一个编写测试脚本的框架</target>
        </trans-unit>
        <trans-unit id="1f545787fad8ec88f6418a5e7cfe487632178eef" translate="yes" xml:space="preserve">
          <source>Yet another pseudo-class that &lt;code&gt;NEXT&lt;/code&gt; provides is &lt;code&gt;EVERY&lt;/code&gt;. Its behaviour is considerably simpler than that of the &lt;code&gt;NEXT&lt;/code&gt; family. A call to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d7418e5885441f0de4ccbd54d601d8993cfb34" translate="yes" xml:space="preserve">
          <source>Yet another pseudo-class that NEXT.pm provides is &lt;code&gt;EVERY&lt;/code&gt; . Its behaviour is considerably simpler than that of the &lt;code&gt;NEXT&lt;/code&gt; family. A call to:</source>
          <target state="translated">NEXT.pm提供的另一个伪类是 &lt;code&gt;EVERY&lt;/code&gt; 。它的行为比 &lt;code&gt;NEXT&lt;/code&gt; 系列的行为简单得多。致电至：</target>
        </trans-unit>
        <trans-unit id="807fa18eacfa8333a4615b7233d28577520ce46b" translate="yes" xml:space="preserve">
          <source>Yet another way is to assign to a &lt;code&gt;foreach&lt;/code&gt; loop</source>
          <target state="translated">另一种方法是分配给 &lt;code&gt;foreach&lt;/code&gt; 循环</target>
        </trans-unit>
        <trans-unit id="fb6a80ccd3cd48516fa10f2b5e43ec6135ec9451" translate="yes" xml:space="preserve">
          <source>Yet another way would be to use the Devel::Peek module:</source>
          <target state="translated">然而另一种方法是使用Devel::Peek模块。</target>
        </trans-unit>
        <trans-unit id="8dd7850c540f0b2c7dd564faf5b435a82d533987" translate="yes" xml:space="preserve">
          <source>Yields the widest unsigned integer type on the platform, currently either &lt;code&gt;U32&lt;/code&gt; or &lt;code&gt;64&lt;/code&gt;. This can be used in declarations such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c970e3f1e790a2a4cd28b40401902501b9bc2d74" translate="yes" xml:space="preserve">
          <source>Yields:</source>
          <target state="translated">Yields:</target>
        </trans-unit>
        <trans-unit id="f551936e2c614f3a2dff9203d64b57c373086792" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;do not&lt;/b&gt; call &lt;code&gt;setlogsock&lt;/code&gt; .</source>
          <target state="translated">您&lt;b&gt;不&lt;/b&gt;调用 &lt;code&gt;setlogsock&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c41e00d12c2bf30eb5c57363d593eb5f296a4201" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;do not&lt;/b&gt; call &lt;code&gt;setlogsock&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83525859b43ad2ba983b59bc741a630d369a604" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must not&lt;/b&gt; attempt to install by hand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adc6962b12f722ff929475c965699bd91420b623" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must&lt;/b&gt; convert characters to UVs using the above functions if you're ever in a situation where you have to match UTF-8 and non-UTF-8 characters. You may not skip over UTF-8 characters in this case. If you do this, you'll lose the ability to match hi-bit non-UTF-8 characters; for instance, if your UTF-8 string contains &lt;code&gt;v196.172&lt;/code&gt; , and you skip that character, you can never match a &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(200)&lt;/a&gt;&lt;/code&gt; in a non-UTF-8 string. So don't do that!</source>
          <target state="translated">如果您&lt;b&gt;必须&lt;/b&gt;匹配UTF-8和非UTF-8字符，则&lt;b&gt;必须&lt;/b&gt;使用上述功能将字符转换为UV。在这种情况下，您不能跳过UTF-8字符。如果这样做，将失去匹配高位非UTF-8字符的能力；例如，如果您的UTF-8字符串包含 &lt;code&gt;v196.172&lt;/code&gt; ，而您跳过了该字符，则您永远无法在非UTF-8字符串中匹配 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(200)&lt;/a&gt;&lt;/code&gt; 。所以不要那样做！</target>
        </trans-unit>
        <trans-unit id="fa9dba3c584a1276adf1e71be9d8031a3210c272" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must&lt;/b&gt; convert characters to UVs using the above functions if you're ever in a situation where you have to match UTF-8 and non-UTF-8 characters. You may not skip over UTF-8 characters in this case. If you do this, you'll lose the ability to match hi-bit non-UTF-8 characters; for instance, if your UTF-8 string contains &lt;code&gt;v196.172&lt;/code&gt;, and you skip that character, you can never match a &lt;code&gt;chr(200)&lt;/code&gt; in a non-UTF-8 string. So don't do that!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84f6ab55499a431ab963225e1b323e598c043cac" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must&lt;/b&gt; have the BFD (-lbfd) library installed, otherwise &lt;code&gt;perl&lt;/code&gt; will fail to link. The BFD is usually distributed as part of the GNU binutils.</source>
          <target state="translated">您&lt;b&gt;必须&lt;/b&gt;安装BFD（-lbfd）库，否则 &lt;code&gt;perl&lt;/code&gt; 将无法链接。BFD通常作为GNU binutils的一部分分发。</target>
        </trans-unit>
        <trans-unit id="b5fb57ccedc3fdf63890d16c6dbd3e60731ff70f" translate="yes" xml:space="preserve">
          <source>You CAN say</source>
          <target state="translated">你可以说</target>
        </trans-unit>
        <trans-unit id="53a5cd5fed7f629c72dba4cfdfde9a745c8113d5" translate="yes" xml:space="preserve">
          <source>You MUST NOT pass context objects around</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9893e3bf74f00c1d618d88219ad526fbac0c0c29" translate="yes" xml:space="preserve">
          <source>You MUST NOT store or cache a context for later</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a142a3f1e08b559ac377684a245517410ece7ce4" translate="yes" xml:space="preserve">
          <source>You MUST always release the context when done with it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91a3f4c8d175f6cccdbd1ebd40641bce1aa24ca" translate="yes" xml:space="preserve">
          <source>You SHOULD obtain your context as soon as possible in a given tool</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4ab9d853c38812e284656a7bf6f62a6214856cd" translate="yes" xml:space="preserve">
          <source>You already learned that a &lt;b&gt;method&lt;/b&gt; is a subroutine that operates on an object. You can think of a method as the things that an object can</source>
          <target state="translated">您已经了解到，&lt;b&gt;方法&lt;/b&gt;是对对象进行操作的子例程。您可以将方法视为对象可以做的事情</target>
        </trans-unit>
        <trans-unit id="9a0c2a8aac855d59d1e419df17c0d8362fab4ef6" translate="yes" xml:space="preserve">
          <source>You also cannot exit out of the sort block or subroutine using any of the loop control operators described in &lt;a href=&quot;../perlsyn&quot;&gt;perlsyn&lt;/a&gt; or with &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您还不能使用&lt;a href=&quot;../perlsyn&quot;&gt;perlsyn&lt;/a&gt;或 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 中描述的任何循环控制运算符退出排序块或子例程。</target>
        </trans-unit>
        <trans-unit id="f67f30786418f2d13fcf93e360206e73fbe2ba5c" translate="yes" xml:space="preserve">
          <source>You also cannot exit out of the sort block or subroutine using any of the loop control operators described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; or with &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce8f481cd5c5e068e4367b0b286efd66e3e8b5e" translate="yes" xml:space="preserve">
          <source>You also cannot exit out of the sort block or subroutine using any of the loop control operators described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; or with &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您还不能使用&lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;或 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 中描述的任何循环控制运算符退出排序块或子例程。</target>
        </trans-unit>
        <trans-unit id="6462e3c6fa18441789982aade2cc057d4a5754fa" translate="yes" xml:space="preserve">
          <source>You also don't have to use push(). You could just make a direct assignment if you knew where you wanted to put it:</source>
          <target state="translated">你也不必使用push()。如果你知道你想把它放在哪里,你可以直接进行赋值。</target>
        </trans-unit>
        <trans-unit id="762d8de62e5184e1ddd3f7df62b51251838a45ad" translate="yes" xml:space="preserve">
          <source>You also have to be careful about context. You can assign an array to a scalar to get the number of elements in the array. This only works for arrays, though:</source>
          <target state="translated">你也要注意上下文。你可以将一个数组赋值给一个标量来获取数组中的元素数量。不过这只对数组有效。</target>
        </trans-unit>
        <trans-unit id="c94e331eac1a6006813ffea35d4a89a5abaa1704" translate="yes" xml:space="preserve">
          <source>You also need dmake or gmake. See &lt;a href=&quot;#Make&quot;&gt;&quot;Make&quot;&lt;/a&gt; above on how to get it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9900e6006f63d330e774e6c340305cdfb9e9fa2" translate="yes" xml:space="preserve">
          <source>You also need dmake. See &lt;a href=&quot;#Make&quot;&gt;Make&lt;/a&gt; above on how to get it.</source>
          <target state="translated">您还需要dmake。有关如何获取的信息，请参见上面的&amp;ldquo; &lt;a href=&quot;#Make&quot;&gt;制作&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bae77dd846c87a6c6a294ef10cab8c218809dda8" translate="yes" xml:space="preserve">
          <source>You also need to take care with modules that enable warnings for you. A common example being Moose. In this example, warnings for the 'smartmatch' feature are first turned on by the warnings pragma, off by the experimental pragma and back on again by the Moose module (fix is to switch the last two lines):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f9457dec1ff1c62632c87a4b529a8a11409acd" translate="yes" xml:space="preserve">
          <source>You are &lt;b&gt;strongly&lt;/b&gt; encouraged to use these subs in any new code which uses this module. It will almost certainly make your code's behavior less surprising.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4cae9e1d17ccae297619ff7a90fc58163adef4" translate="yes" xml:space="preserve">
          <source>You are allowed to use underscores (underbars) in numeric literals between digits for legibility (but not multiple underscores in a row: &lt;code&gt;23__500&lt;/code&gt; is not legal; &lt;code&gt;23_500&lt;/code&gt; is). You could, for example, group binary digits by threes (as for a Unix-style mode argument such as 0b110_100_100) or by fours (to represent nibbles, as in 0b1010_0110) or in other groups.</source>
          <target state="translated">允许您在数字之间的数字文字中使用下划线（下划线）以提高可读性（但不能连续使用多个下划线： &lt;code&gt;23__500&lt;/code&gt; 无效； &lt;code&gt;23_500&lt;/code&gt; 合法）。例如，您可以将二进制数字按三位（对于Unix样式的模式自变量，例如0b110_100_100）或四位（代表零字节，如0b1010_0110）或其他组。</target>
        </trans-unit>
        <trans-unit id="e9086be8aa3acbf107ed69aa30ed1efd2e29806d" translate="yes" xml:space="preserve">
          <source>You are chdir()'d to &lt;code&gt;$File::Find::dir&lt;/code&gt; when the function is called, unless &lt;code&gt;no_chdir&lt;/code&gt; was specified. Note that when changing to directories is in effect the root directory (</source>
          <target state="translated">除非指定了 &lt;code&gt;no_chdir&lt;/code&gt; ，否则在调用函数时，您将chdir（）设置为 &lt;code&gt;$File::Find::dir&lt;/code&gt; 。请注意，更改目录实际上是根目录（</target>
        </trans-unit>
        <trans-unit id="3b7c887092493d390ff632279a2e09dfaf7f8868" translate="yes" xml:space="preserve">
          <source>You are chdir()'d to &lt;code&gt;$File::Find::dir&lt;/code&gt; when the function is called, unless &lt;code&gt;no_chdir&lt;/code&gt; was specified. Note that when changing to directories is in effect, the root directory (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765a24f0e7b225890131f993a03189d4db8249a5" translate="yes" xml:space="preserve">
          <source>You are either using a copy of zlib that is older than version 1.2.0 or you want your application code to be able to run with as many different versions of zlib as possible.</source>
          <target state="translated">你使用的zlib副本比1.2.0版本更老,或者你希望你的应用程序代码能够在尽可能多的不同版本的zlib中运行。</target>
        </trans-unit>
        <trans-unit id="a13d801950c0dc8ed9906d27d14a9952af5a263a" translate="yes" xml:space="preserve">
          <source>You are encouraged to participate in the discussion and advocate for your patch. Sometimes your patch may get lost in the shuffle. It's appropriate to send a reminder email to p5p if no action has been taken in a month. Please remember that the Perl 5 developers are all volunteers, and be polite.</source>
          <target state="translated">我们鼓励您参与讨论,并为您的补丁进行宣传。有时你的补丁可能会被淹没在洗牌中。如果一个月内没有任何行动,给 p5p 发送一封提醒邮件是合适的。请记住,Perl 5 的开发者都是志愿者,要有礼貌。</target>
        </trans-unit>
        <trans-unit id="719d41b23df4f3bd674c48a03b68b419d4539869" translate="yes" xml:space="preserve">
          <source>You are encouraged to use &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; over &lt;code&gt;ok()&lt;/code&gt; where possible, however do not be tempted to use them to find out if something is true or false!</source>
          <target state="translated">鼓励您在可能的情况下在 &lt;code&gt;ok()&lt;/code&gt; 上使用 &lt;code&gt;is()&lt;/code&gt; 和 &lt;code&gt;isnt()&lt;/code&gt; ，但是不要试图使用它们来确定真假！</target>
        </trans-unit>
        <trans-unit id="5f7051dcae7048dda5b89cea1569b5b5dced0666" translate="yes" xml:space="preserve">
          <source>You are encouraged to use the explicitly quoted form if you wish to use an empty line as the terminator of the here-document:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7231b46f1cb348d100d3ac2d2fb73b6bf57d8066" translate="yes" xml:space="preserve">
          <source>You are guaranteed that &lt;code&gt;$dirs . $filename . $suffix&lt;/code&gt; will denote the same location as the original $path.</source>
          <target state="translated">您可以保证 &lt;code&gt;$dirs . $filename . $suffix&lt;/code&gt; 将表示与原始$ path相同的位置。</target>
        </trans-unit>
        <trans-unit id="845992c360c01c1fffb9e8ef6310e8cc47a34923" translate="yes" xml:space="preserve">
          <source>You are not supposed to modify arrays while they are being iterated over. For speed and efficiency reasons, Perl internally does not do full reference-counting of iterated items, hence deleting such an item in the middle of an iteration causes Perl to see a freed value.</source>
          <target state="translated">你不应该在数组被迭代的时候修改它们。出于速度和效率的原因,Perl 内部并不对迭代项进行完全的引用计算,因此在迭代过程中删除这样的项会导致 Perl 看到一个释放的值。</target>
        </trans-unit>
        <trans-unit id="c4250931e7c7965b87b322df0e377d3c209e4074" translate="yes" xml:space="preserve">
          <source>You are recommended to change your code to set &lt;code&gt;$/&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; explicitly if you wish to slurp the file. In future versions of Perl assigning a reference to will throw a fatal error.</source>
          <target state="translated">建议您更改您的代码集 &lt;code&gt;$/&lt;/code&gt; 以 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 明确，如果你想发出声音文件。在将来的Perl版本中，分配对的引用将引发致命错误。</target>
        </trans-unit>
        <trans-unit id="25b41e2d5bdfaa0dfc36f2b04421c00c9e912434" translate="yes" xml:space="preserve">
          <source>You are recommended to change your code to set &lt;code&gt;$/&lt;/code&gt; to &lt;code&gt;undef&lt;/code&gt; explicitly if you wish to slurp the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d012b1e71664ae83bcc78214d293fa6e2c91aff" translate="yes" xml:space="preserve">
          <source>You are recommended to change your code to set &lt;code&gt;$/&lt;/code&gt; to &lt;code&gt;undef&lt;/code&gt; explicitly if you wish to slurp the file. As of Perl 5.28 assigning &lt;code&gt;$/&lt;/code&gt; to a reference to an integer which isn't positive is a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65f3a3a78dc9835626ba2ec61976c50a4907da1" translate="yes" xml:space="preserve">
          <source>You are responsible for &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; on the return value if you plan to store it anywhere semi-permanently (otherwise it might be deleted out from under you the next time the cache is invalidated).</source>
          <target state="translated">如果您打算将其半永久性地存储在任何地方，则应对返回值上的 &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; 负责（否则，下一次缓存无效时，它可能会从您的下方删除）。</target>
        </trans-unit>
        <trans-unit id="d2b17aed1d92752587b50f28c3736df1d3cdfde7" translate="yes" xml:space="preserve">
          <source>You are responsible for setting the decoding layers on &lt;code&gt;$handle&lt;/code&gt; if required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda3d08b1d18c1ab40c3862a395af18d46e5f5cf" translate="yes" xml:space="preserve">
          <source>You are strongly discouraged from using this function directly. It is used by various core modules, like &lt;code&gt;Hash::Util&lt;/code&gt;, and the &lt;code&gt;constant&lt;/code&gt; pragma to implement higher-level behavior which should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e416f1d8fe7e351baa8b0e70e6dc37f69f6f41" translate="yes" xml:space="preserve">
          <source>You are strongly encouraged to implement methods below, at least either encode() or decode().</source>
          <target state="translated">强烈鼓励你实现下面的方法,至少是encode()或decode()。</target>
        </trans-unit>
        <trans-unit id="ff134e38e289cfa6f5f3d471d7e0e0fabcbe8c66" translate="yes" xml:space="preserve">
          <source>You are strongly encouraged to migrate any existing threaded code to the new model (i.e., use the &lt;code&gt;threads&lt;/code&gt; and &lt;code&gt;threads::shared&lt;/code&gt; modules) as soon as possible.</source>
          <target state="translated">强烈建议您尽快将任何现有的线程代码迁移到新模型（即，使用 &lt;code&gt;threads&lt;/code&gt; 和 &lt;code&gt;threads::shared&lt;/code&gt; 模块）。</target>
        </trans-unit>
        <trans-unit id="2a08b19fff728f8eb38fe62f343715380f316ef9" translate="yes" xml:space="preserve">
          <source>You aren't allowed to modify constants in this way, of course. If an argument were actually literal and you tried to change it, you'd take a (presumably fatal) exception. For example, this won't work:</source>
          <target state="translated">当然,你不允许以这种方式修改常量。如果一个参数实际上是字面意思,而你又想修改它,你会出现一个(可能是致命的)异常。例如,这样做是行不通的。</target>
        </trans-unit>
        <trans-unit id="2ed4e9f522b1893c218a4950d5f8fc9530c317f7" translate="yes" xml:space="preserve">
          <source>You aren't limited to just a single &lt;code&gt;&quot;|&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d1e1241acbf20a33264ba47e94319bd2c6bf6a8" translate="yes" xml:space="preserve">
          <source>You assigned a reference to a scalar to &lt;code&gt;$/&lt;/code&gt; where the referenced item is not a positive integer. In older perls this &lt;b&gt;appeared&lt;/b&gt; to work the same as setting it to &lt;code&gt;undef&lt;/code&gt; but was in fact internally different, less efficient and with very bad luck could have resulted in your file being split by a stringified form of the reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1622820db3665cc19fb76f05a9e122011064bf68" translate="yes" xml:space="preserve">
          <source>You can &quot;make install&quot; already but you should test first.</source>
          <target state="translated">你已经可以 &quot;制作安装 &quot;了,但你应该先测试一下。</target>
        </trans-unit>
        <trans-unit id="441d296a1602f9e39d91a622912b032dea66e8b8" translate="yes" xml:space="preserve">
          <source>You can (and should) read more about references in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Briefly, references are rather like pointers that know what they point to. (Objects are also a kind of reference, but we won't be needing them right away--if ever.) This means that when you have something which looks to you like an access to a two-or-more-dimensional array and/or hash, what's really going on is that the base type is merely a one-dimensional entity that contains references to the next level. It's just that you can</source>
          <target state="translated">您可以（并且应该）阅读有关&lt;a href=&quot;perlref&quot;&gt;perlref中的&lt;/a&gt;引用的更多信息。简而言之，引用就像是知道它们所指向的指针。（对象也是一种参考，但是我们将不再需要它们（如果有的话）。）这意味着当您拥有某种看起来像是访问二维数组或二维数组的对象时， /或哈希，实际上发生的是，基本类型只是一维实体，其中包含对下一级的引用。只是你可以</target>
        </trans-unit>
        <trans-unit id="4c8d7d3437af9191b3b2ecdbf2e0cc22d58ff901" translate="yes" xml:space="preserve">
          <source>You can &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize just one element of an aggregate. Usually this is done on dynamics:</source>
          <target state="translated">您可以仅 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 集合中的一个元素。通常这是在动力学上完成的：</target>
        </trans-unit>
        <trans-unit id="8ef093b34210f5147b5553d815c011dc81eff7de" translate="yes" xml:space="preserve">
          <source>You can &lt;code&gt;local&lt;/code&gt;ize just one element of an aggregate. Usually this is done on dynamics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3c57d183363a886eda26951cab8a3d873beb8e" translate="yes" xml:space="preserve">
          <source>You can access the first characters of a string with substr(). To get the first character, for example, start at position 0 and grab the string of length 1.</source>
          <target state="translated">你可以用substr()访问一个字符串的第一个字符。例如,要获取第一个字符,从位置0开始,然后抓取长度为1的字符串。</target>
        </trans-unit>
        <trans-unit id="4b6168183223c539ff65f81f73941c2c4a8e59c2" translate="yes" xml:space="preserve">
          <source>You can actually chomp anything that's an lvalue, including an assignment:</source>
          <target state="translated">实际上,你可以咬住任何一个l值,包括一个赋值。</target>
        </trans-unit>
        <trans-unit id="ab3659f896bba38cbe056eb37538d331f15d2fcc" translate="yes" xml:space="preserve">
          <source>You can actually chop anything that's an lvalue, including an assignment.</source>
          <target state="translated">实际上,你可以砍掉任何一个l值,包括一个赋值。</target>
        </trans-unit>
        <trans-unit id="06e51b7968687b9d39d3fba6b7611216b01c17eb" translate="yes" xml:space="preserve">
          <source>You can actually put an array or hash anywhere in the list, but the first one in the list will soak up all the values, and anything after it will become undefined. This may be useful in a my() or local().</source>
          <target state="translated">实际上,你可以在列表中的任何地方放置一个数组或哈希,但是列表中的第一个数组会吸收所有的值,而它之后的任何值都会变成未定义的。这在my()或local()中可能很有用。</target>
        </trans-unit>
        <trans-unit id="532505c0e3919310f7105bcc98c9ca0331dbfd6d" translate="yes" xml:space="preserve">
          <source>You can actually take this one step further and test the manual itself. Have a look at &lt;a href=&quot;Test::Inline&quot;&gt;Test::Inline&lt;/a&gt; (formerly &lt;a href=&quot;Pod::Tests&quot;&gt;Pod::Tests&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fcefecb0feb2b6d0223364636eebffcb896a89d" translate="yes" xml:space="preserve">
          <source>You can add customized aliases to standard (&lt;code&gt;:full&lt;/code&gt; ) Unicode naming conventions. The aliases override any standard definitions, so, if you're twisted enough, you can change &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; to mean &lt;code&gt;&quot;B&quot;&lt;/code&gt; , etc.</source>
          <target state="translated">您可以将自定义别名添加到标准（ &lt;code&gt;:full&lt;/code&gt; ）Unicode命名约定中。别名会覆盖所有标准定义，因此，如果您扭曲得不够充分，可以将 &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; 更改为 &lt;code&gt;&quot;B&quot;&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="665e29e63421d2fd846f895a1a1e9676c964ad4a" translate="yes" xml:space="preserve">
          <source>You can add customized aliases to standard (&lt;code&gt;:full&lt;/code&gt;) Unicode naming conventions. The aliases override any standard definitions, so, if you're twisted enough, you can change &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; to mean &lt;code&gt;&quot;B&quot;&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422d4c1954392600b653163b725624c46d77f3f0" translate="yes" xml:space="preserve">
          <source>You can adjust the counter by assigning to &lt;code&gt;$.&lt;/code&gt; , but this will not actually move the seek pointer.</source>
          <target state="translated">您可以通过分配给 &lt;code&gt;$.&lt;/code&gt; 来调整计数器。，但这实际上不会移动搜索指针。</target>
        </trans-unit>
        <trans-unit id="1e12c1c150e8155af23e75fc04a29600af824216" translate="yes" xml:space="preserve">
          <source>You can adjust the counter by assigning to &lt;code&gt;$.&lt;/code&gt;, but this will not actually move the seek pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="add234c624f206426ee8290a3ddfc9b8ceedcb89" translate="yes" xml:space="preserve">
          <source>You can also alter the way the output and logic of &lt;code&gt;Carp&lt;/code&gt; works, by changing some global variables in the &lt;code&gt;Carp&lt;/code&gt; namespace. See the section on &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; below.</source>
          <target state="translated">您还可以通过更改 &lt;code&gt;Carp&lt;/code&gt; 名称空间中的某些全局变量来更改 &lt;code&gt;Carp&lt;/code&gt; 的输出和逻辑的工作方式。请参阅下面的&amp;ldquo; &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="261bbd570ac37c0ad60f8d4ba64480f35ae30ac1" translate="yes" xml:space="preserve">
          <source>You can also call &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; with a reference argument, and if this is trapped within an &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; contains that reference. This permits more elaborate exception handling using objects that maintain arbitrary state about the exception. Such a scheme is sometimes preferable to matching particular string values of &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; with regular expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d61dd797cd63f1042bbffa35621af46e71f5b31" translate="yes" xml:space="preserve">
          <source>You can also call &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with a reference argument, and if this is trapped within an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;$@&lt;/code&gt; contains that reference. This permits more elaborate exception handling using objects that maintain arbitrary state about the exception. Such a scheme is sometimes preferable to matching particular string values of &lt;code&gt;$@&lt;/code&gt; with regular expressions. Because &lt;code&gt;$@&lt;/code&gt; is a global variable and &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; may be used within object implementations, be careful that analyzing the error object doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="translated">您也可以使用引用参数调用 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，并且如果该引用陷阱包含在 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中，则 &lt;code&gt;$@&lt;/code&gt; 包含该引用。这允许使用维护有关异常的任意状态的对象进行更精细的异常处理。这种方案有时比将 &lt;code&gt;$@&lt;/code&gt; 特定字符串值与正则表达式匹配更可取。因为 &lt;code&gt;$@&lt;/code&gt; 是全局变量，并且 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 可以在对象实现中使用，所以要小心，分析错误对象不会替换全局变量中的引用。在进行任何操作之前，最简单的方法是创建引用的本地副本。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="151ae294544e5b15c198686df29c5202445b492a" translate="yes" xml:space="preserve">
          <source>You can also call &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with a reference argument, and if this is trapped within an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;$@&lt;/code&gt; contains that reference. This permits more elaborate exception handling using objects that maintain arbitrary state about the exception. Such a scheme is sometimes preferable to matching particular string values of &lt;code&gt;$@&lt;/code&gt; with regular expressions. Because &lt;code&gt;$@&lt;/code&gt; is a global variable and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; may be used within object implementations, be careful that analyzing the error object doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="translated">您也可以使用引用参数调用 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，并且如果该引用陷阱包含在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中，则 &lt;code&gt;$@&lt;/code&gt; 包含该引用。这允许使用维护有关异常的任意状态的对象进行更精细的异常处理。这种方案有时比将 &lt;code&gt;$@&lt;/code&gt; 特定字符串值与正则表达式匹配更可取。因为 &lt;code&gt;$@&lt;/code&gt; 是全局变量，并且 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 可以在对象实现中使用，所以要小心，分析错误对象不会替换全局变量中的引用。在进行任何操作之前，最简单的方法是创建引用的本地副本。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="9cdb85fa1e67a62d3e70dba3d5bf1c75c04f7e09" translate="yes" xml:space="preserve">
          <source>You can also call parse_lines() to parse an array of lines or parse_string_document() to parse a document already in memory. As with parse_file(), parse_lines() and parse_string_document() default to sending their output to &lt;code&gt;STDOUT&lt;/code&gt; unless changed with the output_fh() method.</source>
          <target state="translated">您还可以调用parse_lines（）来解析行数组，或者调用parse_string_document（）来解析内存中已经存在的文档。与parse_file（）一样，除非使用output_fh（）方法进行更改，否则parse_lines（）和parse_string_document（）默认将其输出发送到 &lt;code&gt;STDOUT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="792416647ce701349df829839ca082b8dd50a041" translate="yes" xml:space="preserve">
          <source>You can also call parse_lines() to parse an array of lines or parse_string_document() to parse a document already in memory. As with parse_file(), parse_lines() and parse_string_document() default to sending their output to &lt;code&gt;STDOUT&lt;/code&gt; unless changed with the output_fh() method. Be aware that parse_lines() and parse_string_document() both expect raw bytes, not decoded characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61cf53df274337143d282caf711ce10831abe85c" translate="yes" xml:space="preserve">
          <source>You can also chain the calls like this, this first makes a copy and then multiply it by 2:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57fcafa1ea35942e9edb2cd8f5d66578716838d" translate="yes" xml:space="preserve">
          <source>You can also chain the calls like this, this will make first a copy and then multiply it by 2:</source>
          <target state="translated">你也可以这样连锁调用,这样可以先做一个副本,然后再乘以2。</target>
        </trans-unit>
        <trans-unit id="029fcbbc45bf12d25b834057d9395bba7ab192ae" translate="yes" xml:space="preserve">
          <source>You can also change the internal suspects list via &lt;code&gt;set_suspects&lt;/code&gt; method.</source>
          <target state="translated">您也可以通过 &lt;code&gt;set_suspects&lt;/code&gt; 方法更改内部可疑列表。</target>
        </trans-unit>
        <trans-unit id="5c5a392365d6b99ba2358d8d79ba87643cdf832d" translate="yes" xml:space="preserve">
          <source>You can also cherry-pick commits from blead and another branch, by using the &lt;code&gt;git cherry-pick&lt;/code&gt; command. It is recommended to use the &lt;b&gt;-x&lt;/b&gt; option to &lt;code&gt;git cherry-pick&lt;/code&gt; in order to record the SHA1 of the original commit in the new commit message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a2e4e937f2dcf302981b9beceb35f4afd812bf" translate="yes" xml:space="preserve">
          <source>You can also choose to use rsync to get a copy of the current source tree for the bleadperl branch and all maintenance branches:</source>
          <target state="translated">你也可以选择使用rsync来获取 bleadperl分支和所有维护分支的当前源代码树的副本。</target>
        </trans-unit>
        <trans-unit id="06fef7ffb01d2e70116beb4b064bd4adf57f2910" translate="yes" xml:space="preserve">
          <source>You can also construct an empty set of prereqs with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69913c0f24daf22d2c432ea27b2a49c000488188" translate="yes" xml:space="preserve">
          <source>You can also control the 'hushed' flag at run-time, using the built-in routine vmsish::hushed(). Without argument, it returns the hushed status. Since vmsish::hushed is built-in, you do not need to &quot;use vmsish&quot; to call it.</source>
          <target state="translated">你也可以在运行时使用内置例程vmsish::husthed()来控制'hushed'标志。在没有参数的情况下,它将返回 &quot;hushed &quot;状态。因为vmsish::hashed是内置的,所以你不需要 &quot;使用vmsish &quot;来调用它。</target>
        </trans-unit>
        <trans-unit id="563cd6bbc176ecbc734b5b0b439a546964280899" translate="yes" xml:space="preserve">
          <source>You can also control the character encoding and entities. For example, if you're sure that the POD is properly encoded (using the &lt;code&gt;=encoding&lt;/code&gt; command), you can prevent high-bit characters from being encoded as HTML entities and declare the output character set as UTF-8 before parsing, like so:</source>
          <target state="translated">您还可以控制字符编码和实体。例如，如果您确定POD正确编码（使用 &lt;code&gt;=encoding&lt;/code&gt; 命令），则可以防止在分析之前将高位字符编码为HTML实体，并将输出字符集声明为UTF-8，如下所示：</target>
        </trans-unit>
        <trans-unit id="ce7cb29295e37cbd29b717e64482225d4d4ba414" translate="yes" xml:space="preserve">
          <source>You can also control the shell that perl uses to run system() and backtick commands via PERL5SHELL. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">您还可以通过PERL5SHELL控制perl用于运行system（）和backtick命令的shell。参见&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b6274126a67429902f21b4ff102d4a5f157ec82" translate="yes" xml:space="preserve">
          <source>You can also create a circular reference with a single variable:</source>
          <target state="translated">你也可以用单个变量创建一个循环引用。</target>
        </trans-unit>
        <trans-unit id="fe319fa0895a7f47e55075d55fc2289e3b3f2bea" translate="yes" xml:space="preserve">
          <source>You can also do</source>
          <target state="translated">你也可以做</target>
        </trans-unit>
        <trans-unit id="9354065d75fb22856af80d6825be0de174fa14aa" translate="yes" xml:space="preserve">
          <source>You can also do the same things with the &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69a5ee6a0a8ad7101d445832b3faf4f8db8fd92c" translate="yes" xml:space="preserve">
          <source>You can also do the same things with the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module:</source>
          <target state="translated">您还可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;模块执行相同的操作：</target>
        </trans-unit>
        <trans-unit id="efdd9cfab2b6e73dabdc31999bde389ad6e9c40e" translate="yes" xml:space="preserve">
          <source>You can also do the wrapping explicitly by rad2rad(), deg2deg(), and grad2grad().</source>
          <target state="translated">你也可以通过rad2rad()、deg2deg()和grad2grad()明确地进行封装。</target>
        </trans-unit>
        <trans-unit id="e971cca5e90229321a699ea5b197dee6a304b5cb" translate="yes" xml:space="preserve">
          <source>You can also do this directly in the match operator using the &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; sequences. The &lt;code&gt;\Q&lt;/code&gt; tells Perl where to start escaping special characters, and the &lt;code&gt;\E&lt;/code&gt; tells it where to stop (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details).</source>
          <target state="translated">您也可以使用 &lt;code&gt;\Q&lt;/code&gt; 和 &lt;code&gt;\E&lt;/code&gt; 序列直接在match运算符中执行此操作。该 &lt;code&gt;\Q&lt;/code&gt; 告诉Perl从哪里开始转义特殊字符，以及 &lt;code&gt;\E&lt;/code&gt; 告诉它在哪里停止（见&lt;a href=&quot;perlop&quot;&gt;perlop中&lt;/a&gt;有详细介绍）。</target>
        </trans-unit>
        <trans-unit id="5646b0b75475a7d6e7784a71e7f3baa1d3885cbc" translate="yes" xml:space="preserve">
          <source>You can also do this for most systems using the &lt;a href=&quot;Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, which is easier to use and in theory more portable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe2d0afbbbfb95dc9ef1705dc46b6eb4a3e77627" translate="yes" xml:space="preserve">
          <source>You can also do this for most systems using the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, which is easier to use and in theory more portable.</source>
          <target state="translated">您也可以使用CPAN 的&lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt;模块对大多数系统执行此操作，该模块更易于使用，理论上更易于移植。</target>
        </trans-unit>
        <trans-unit id="f3337ad9bcb6d402cd92e0314d2032a9a8dc4c0a" translate="yes" xml:space="preserve">
          <source>You can also easily say to use all categories but one, by either, for example,</source>
          <target state="translated">你也可以很容易的说除了一个类别外,其他类别都要用,比如说,通过任一。</target>
        </trans-unit>
        <trans-unit id="317bed7b561a99db6e7463d3bee761b35a18aa16" translate="yes" xml:space="preserve">
          <source>You can also embed newlines directly in your strings, i.e., they can end on a different line than they begin. This is nice, but if you forget your trailing quote, the error will not be reported until Perl finds another line containing the quote character, which may be much further on in the script. Variable substitution inside strings is limited to scalar variables, arrays, and array or hash slices. (In other words, names beginning with $ or @, followed by an optional bracketed expression as a subscript.) The following code segment prints out &quot;The price is $100.&quot;</source>
          <target state="translated">你也可以直接在字符串中嵌入换行符,也就是说,换行符可以在与开头不同的行结束。这很好,但是如果你忘记了尾部的引号,在Perl找到包含引号字符的另一行之前是不会报告错误的,而这一行可能在脚本的更远处。字符串中的变量替换仅限于标量变量、数组、数组或哈希片。换句话说,以$或@开头的名称,后面跟着一个可选的括号内的表达式作为下标)。下面的代码段打印出 &quot;价格是100元&quot;。</target>
        </trans-unit>
        <trans-unit id="6dc98b973b8e3861953362cf4137bf9098b40a23" translate="yes" xml:space="preserve">
          <source>You can also explicitly indicate that a single handler is meant to be used for all types of referents like so:</source>
          <target state="translated">你也可以显式地指定一个处理程序用于所有类型的引用,就像这样。</target>
        </trans-unit>
        <trans-unit id="cc7d393dae203f89e29915d158bc84c0d091344a" translate="yes" xml:space="preserve">
          <source>You can also explicitly specify the argument number to use for the join string using something like &lt;code&gt;*2$v&lt;/code&gt;; for example:</source>
          <target state="translated">您还可以使用 &lt;code&gt;*2$v&lt;/code&gt; 类的方式显式指定用于连接字符串的参数编号；例如：</target>
        </trans-unit>
        <trans-unit id="3c69b8b0664f8688a90139832b96e7b725fab5ec" translate="yes" xml:space="preserve">
          <source>You can also gain some minuscule measure of efficiency by pre-extending an array that is going to get big. You can also extend an array by assigning to an element that is off the end of the array. You can truncate an array down to nothing by assigning the null list () to it. The following are equivalent:</source>
          <target state="translated">你也可以通过预先扩展一个即将变大的数组来获得一些微不足道的效率。你也可以通过赋值给一个数组末端的元素来扩展数组。你可以通过将空列表()赋值给一个数组,将其截断为零。以下是等价的。</target>
        </trans-unit>
        <trans-unit id="87f6d7508324248bf5fa6b6a6e4e9d73a898fe92" translate="yes" xml:space="preserve">
          <source>You can also get a pointer to the end of the string stored in the SV with the macro:</source>
          <target state="translated">你也可以通过宏来获取存储在SV中的字符串末端的指针。</target>
        </trans-unit>
        <trans-unit id="5c82629fae7a8fb986a942489f622aa4264ef7c4" translate="yes" xml:space="preserve">
          <source>You can also get differences with a subtraction, which returns a &lt;a href=&quot;Time::Seconds&quot;&gt;Time::Seconds&lt;/a&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843f7af3e5947338619464418b011d78b7714032" translate="yes" xml:space="preserve">
          <source>You can also get differences with a subtraction, which returns a &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; object:</source>
          <target state="translated">您还可以通过减法来获得差异，该减法将返回&lt;a href=&quot;time/seconds&quot;&gt;Time :: Seconds&lt;/a&gt;对象：</target>
        </trans-unit>
        <trans-unit id="0da6f0ff3f9840990993a84402f300e13eb838e3" translate="yes" xml:space="preserve">
          <source>You can also get into subtle problems on those few operations in Perl that actually do care about the difference between a string and a number, such as the magical &lt;code&gt;++&lt;/code&gt; autoincrement operator or the syscall() function.</source>
          <target state="translated">您还可以在Perl中的那几个实际上关心字符串和数字之间差异的操作上遇到一些细微问题，例如神奇的 &lt;code&gt;++&lt;/code&gt; 自动增量运算符或syscall（）函数。</target>
        </trans-unit>
        <trans-unit id="b13a71a702d5f9f57f9b335ced17d27c5c8c8136" translate="yes" xml:space="preserve">
          <source>You can also get the precision from the next argument using &lt;code&gt;.*&lt;/code&gt;, or from a specified argument (e.g., with &lt;code&gt;.*2$&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7d480332101e4bfe5db6a1d74af4d69d28cfca" translate="yes" xml:space="preserve">
          <source>You can also get the precision from the next argument using &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="translated">您还可以使用 &lt;code&gt;.*&lt;/code&gt; 从下一个参数获取精度：</target>
        </trans-unit>
        <trans-unit id="31317a51fe6916c8950fb1738da08a3f662e794a" translate="yes" xml:space="preserve">
          <source>You can also go through each element and skip the ones you've seen before. Use a hash to keep track. The first time the loop sees an element, that element has no key in &lt;code&gt;%Seen&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement creates the key and immediately uses its value, which is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, so the loop continues to the &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; and increments the value for that key. The next time the loop sees that same element, its key exists in the hash</source>
          <target state="translated">您还可以浏览每个元素，并跳过之前看到的元素。使用哈希来跟踪。循环第一次看到元素时，该元素在 &lt;code&gt;%Seen&lt;/code&gt; 中没有键。在 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 语句创建关键并立即使用它的价值，这是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，因此该循环不断的 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; ，并增加该键的值。下次循环看到相同的元素时，其键存在于哈希中</target>
        </trans-unit>
        <trans-unit id="edcb0c6ef0708a661ee9e625297a07b8efd27958" translate="yes" xml:space="preserve">
          <source>You can also go through each element and skip the ones you've seen before. Use a hash to keep track. The first time the loop sees an element, that element has no key in &lt;code&gt;%Seen&lt;/code&gt;. The &lt;code&gt;next&lt;/code&gt; statement creates the key and immediately uses its value, which is &lt;code&gt;undef&lt;/code&gt;, so the loop continues to the &lt;code&gt;push&lt;/code&gt; and increments the value for that key. The next time the loop sees that same element, its key exists in the hash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dac992fa47e7fcb08307c37ff877628a10c26073" translate="yes" xml:space="preserve">
          <source>You can also import the symbolic &lt;code&gt;S_I*&lt;/code&gt; constants from the &lt;a href=&quot;fcntl&quot;&gt;&lt;code&gt;Fcntl&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7930ef83d4a331d3e89d11f276bc35572519ad08" translate="yes" xml:space="preserve">
          <source>You can also import the symbolic &lt;code&gt;S_I*&lt;/code&gt; constants from the &lt;code&gt;Fcntl&lt;/code&gt; module:</source>
          <target state="translated">您还可以从 &lt;code&gt;Fcntl&lt;/code&gt; 模块导入符号 &lt;code&gt;S_I*&lt;/code&gt; 常量：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
