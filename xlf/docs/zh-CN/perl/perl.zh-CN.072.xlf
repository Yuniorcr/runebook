<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="745e9758fddddfd17b1f8070f37c73b6ef6dd2f4" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt; , a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="translated">当与 &lt;code&gt;Z&lt;/code&gt; 一起使用时，保证使用 &lt;code&gt;*&lt;/code&gt; 作为重复计数来添加尾随的空字节，因此，所得字符串始终比项目本身的字节长一个字节。</target>
        </trans-unit>
        <trans-unit id="3e309ae810b7ba69caf1b083747a6f0e33a6ad11" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt;, a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="translated">当与 &lt;code&gt;Z&lt;/code&gt; 一起使用时，保证使用 &lt;code&gt;*&lt;/code&gt; 作为重复计数，以添加结尾的空字节，因此所得的字符串始终比项目本身的字节长一个字节。</target>
        </trans-unit>
        <trans-unit id="501ee2b6d5b82410bf49c6ef557d5b8111f9b9e9" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; .</source>
          <target state="translated">与类方法一起使用时，问题甚至更加严重。由于Perl允许将子例程名称写为裸词，因此Perl必须猜测方法后的裸词是类名称还是子例程名称。换句话说，Perl可以将语法解析为 &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt; &lt;b&gt;或&lt;/b&gt; &lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4f8a19419e9cae531fd00a5faf3b4b95c08f01c" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt;.</source>
          <target state="translated">与类方法一起使用时，问题甚至更加严重。由于Perl允许将子例程名称写为裸词，因此Perl必须猜测方法后的裸词是类名称还是子例程名称。换句话说，Perl可以将语法解析为 &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt; &lt;b&gt;或&lt;/b&gt; &lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f87eff678443c76527dd2ab6f92ce339964a9f84" translate="yes" xml:space="preserve">
          <source>When used with command line options:</source>
          <target state="translated">当使用命令行选项时。</target>
        </trans-unit>
        <trans-unit id="034d2956d3ab35d5d0a3009bf9f647819ce96d9f" translate="yes" xml:space="preserve">
          <source>When userelocatableinc is true, this variable holds the location that make install should copy the perl binary to, with all the run-time relocatable paths calculated from this at install time. When used, it is initialized to the original value of binexp, and then binexp is set to</source>
          <target state="translated">当userelocatableinc为true时,这个变量保存了make install应该将perl二进制文件复制到的位置,所有运行时的可重定位路径都是在安装时据此计算出来的。当使用时,它被初始化为binexp的原始值,然后将binexp设置为</target>
        </trans-unit>
        <trans-unit id="52d8c19f5d99981fe4c4d2fcb09c34b0b19ca9a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; on a &lt;code&gt;()&lt;/code&gt; group, this affects all types inside the group that accept byte-order modifiers, including all subgroups. It is silently ignored for all other types. You are not allowed to override the byte-order within a group that already has a byte-order modifier suffix.</source>
          <target state="translated">在 &lt;code&gt;()&lt;/code&gt; 组上使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&lt;/code&gt; 时，这会影响该组内所有接受字节顺序修饰符的类型，包括所有子组。对于所有其他类型，它将被静默忽略。不允许覆盖已经有字节顺序修饰符后缀的组中的字节顺序。</target>
        </trans-unit>
        <trans-unit id="834a7e8ec8b7da2f955444b22e5081d5fee5d139" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt; , &lt;code&gt;@EXPORT&lt;/code&gt; , &lt;code&gt;@ISA&lt;/code&gt; , etc.</source>
          <target state="translated">当将 &lt;code&gt;Exporter&lt;/code&gt; 与标准 &lt;code&gt;strict&lt;/code&gt; 和 &lt;code&gt;warnings&lt;/code&gt; 编译指示一起使用时，需要 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 关键字来声明包变量@ &lt;code&gt;@EXPORT_OK&lt;/code&gt; ，@ &lt;code&gt;@EXPORT&lt;/code&gt; ，@ &lt;code&gt;@ISA&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="ff82b6a088bd3949701c2e9690b32b71bbe25933" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;our&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt;, &lt;code&gt;@EXPORT&lt;/code&gt;, &lt;code&gt;@ISA&lt;/code&gt;, etc.</source>
          <target state="translated">当将 &lt;code&gt;Exporter&lt;/code&gt; 与标准 &lt;code&gt;strict&lt;/code&gt; 和 &lt;code&gt;warnings&lt;/code&gt; 编译指示一起使用时，需要 &lt;code&gt;our&lt;/code&gt; 关键字来声明包变量@ &lt;code&gt;@EXPORT_OK&lt;/code&gt; ，@ &lt;code&gt;@EXPORT&lt;/code&gt; ，@ &lt;code&gt;@ISA&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="098b7ca0910242ebfe289953bb787b86df641163" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="translated">当使用 &lt;code&gt;IPC::Open3&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 时，如果您提供一个字符串作为 &lt;code&gt;command&lt;/code&gt; 参数，则假定它已被适当地转义。您可以使用 &lt;code&gt;QUOTE&lt;/code&gt; 常量用作可移植的引号字符（请参见上文）。但是，如果提供数组引用，则适用特殊规则：</target>
        </trans-unit>
        <trans-unit id="d2f0399c3e8df8b441dc7a3e6752ac0ac539b907" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="translated">当使用 &lt;code&gt;IPC::Open3&lt;/code&gt; 或 &lt;code&gt;system&lt;/code&gt; 时，如果您提供一个字符串作为 &lt;code&gt;command&lt;/code&gt; 参数，则假定它已被适当地转义。您可以使用 &lt;code&gt;QUOTE&lt;/code&gt; 常量用作可移植的引号字符（请参见上文）。但是，如果提供数组引用，则适用特殊规则：</target>
        </trans-unit>
        <trans-unit id="ac72f6ccde75b586d99f93dce2fef690fbdd778e" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt; , if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="translated">当使用 &lt;code&gt;IPC::Run&lt;/code&gt; ，如果您提供一个字符串作为 &lt;code&gt;command&lt;/code&gt; 参数，则该字符串将在空白处分割以确定命令的各个元素。尽管这通常只会执行您的意思，但是如果其中包含空格的文件或命令可能会中断。</target>
        </trans-unit>
        <trans-unit id="cb299ab15bb95a67fd9da59509a66d398c459654" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="translated">使用 &lt;code&gt;IPC::Run&lt;/code&gt; ，如果您提供一个字符串作为 &lt;code&gt;command&lt;/code&gt; 参数，则该字符串将在空白处分割以确定命令的各个元素。尽管这通常只是执行您的意思，但是如果其中包含空格的文件或命令可能会中断。</target>
        </trans-unit>
        <trans-unit id="9bd114611c2ad871f0c8eb7b6bb0b00563bb8b3c" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Perl_langinfo&lt;/code&gt; on systems that don't have a native &lt;code&gt;nl_langinfo()&lt;/code&gt;, you must</source>
          <target state="translated">在没有本地 &lt;code&gt;nl_langinfo()&lt;/code&gt; 的系统上使用 &lt;code&gt;Perl_langinfo&lt;/code&gt; 时，必须</target>
        </trans-unit>
        <trans-unit id="887f4ef11aea133bd95f7e158dd018aa1d9071b1" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; , or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="translated">当将 &lt;code&gt;autodie&lt;/code&gt; 或 &lt;code&gt;Fatal&lt;/code&gt; 与用户子例程一起使用时，这些子例程的声明必须出现在首次使用 &lt;code&gt;Fatal&lt;/code&gt; 或 &lt;code&gt;autodie&lt;/code&gt; 之前，或者已经从模块中导出。尝试在其他用户子例程上使用 &lt;code&gt;Fatal&lt;/code&gt; 或 &lt;code&gt;autodie&lt;/code&gt; 会导致编译时错误。</target>
        </trans-unit>
        <trans-unit id="d38b1b6fe53eaefb297f9d879236a334c99468e3" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt;, or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="translated">当对用户子例程使用 &lt;code&gt;autodie&lt;/code&gt; 或 &lt;code&gt;Fatal&lt;/code&gt; 时，这些子例程的声明必须在首次使用 &lt;code&gt;Fatal&lt;/code&gt; 或 &lt;code&gt;autodie&lt;/code&gt; 之前出现，或者已经从模块中导出。尝试在其他用户子例程上使用 &lt;code&gt;Fatal&lt;/code&gt; 或 &lt;code&gt;autodie&lt;/code&gt; 会导致编译时错误。</target>
        </trans-unit>
        <trans-unit id="8ea0745997af7ee70fec196994401476b7830212" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt; , objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;fd_retrieve&lt;/code&gt; 时，将按顺序检索对象，每个关联的 &lt;code&gt;store_fd&lt;/code&gt; 检索一个对象（即一棵递归树）。</target>
        </trans-unit>
        <trans-unit id="12e3df8bd541ba3c998025aaa4430e3500847d06" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt;, objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;fd_retrieve&lt;/code&gt; 时，将按顺序检索对象，每个关联的 &lt;code&gt;store_fd&lt;/code&gt; 检索一个对象（即一棵递归树）。</target>
        </trans-unit>
        <trans-unit id="e2d48fc5105eb38ba5d5e3af6a3868bf8d76aac7" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt; ) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt; .</source>
          <target state="translated">使用GCC时，该条目指定MakeMaker应该首先在 &lt;code&gt;$Config{libpth}&lt;/code&gt; 指定的所有位置中寻找 &lt;code&gt;libgl.a&lt;/code&gt; （后跟 &lt;code&gt;gl.a&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2c8cc8b7dc989aa2e0c54fa773dd36d96d318229" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt;) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt;.</source>
          <target state="translated">使用GCC时，该条目指定MakeMaker首先应在 &lt;code&gt;$Config{libpth}&lt;/code&gt; 指定的所有位置中查找 &lt;code&gt;libgl.a&lt;/code&gt; （后跟 &lt;code&gt;gl.a&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d3c3fbdf4905ed574790e43ad2b1e958281ade4d" translate="yes" xml:space="preserve">
          <source>When using Module::Build, this will usually be:</source>
          <target state="translated">当使用Module::Build时,这通常会是。</target>
        </trans-unit>
        <trans-unit id="04e10d3b847f5d46ec45809bdc9654ea510527e6" translate="yes" xml:space="preserve">
          <source>When using PUSHCOLOR, POPCOLOR, and LOCALCOLOR, it's particularly important to not put commas between the constants.</source>
          <target state="translated">当使用PUSHCOLOR、POPCOLOR和LOCALCOLOR时,特别重要的是不要在常量之间加逗号。</target>
        </trans-unit>
        <trans-unit id="0fcdfebaed2e26ac7b40fe2bc2a6520f86b06a73" translate="yes" xml:space="preserve">
          <source>When using Term::ReadLine, you can turn ornaments on so that your input stands out against the output from CPAN.pm.</source>
          <target state="translated">当使用Term::ReadLine时,你可以打开饰品,使你的输入与CPAN.pm的输出形成鲜明对比。</target>
        </trans-unit>
        <trans-unit id="3bb24a915046f34ce04a56f60336d0fb58d6c025" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; for file paths.</source>
          <target state="translated">当使用Unix或MSDOS语法时，它会模拟 &lt;code&gt;dirname(1)&lt;/code&gt; shell函数，该函数与 &lt;code&gt;fileparse()&lt;/code&gt; 的工作方式稍有不同。即使最后一级显然是目录，它也会返回文件路径的最后一级以外的所有内容。实际上，它不是返回目录部分，而只是返回上一级的路径，类似于文件路径的 &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83acdc7454980247f70cca18686669a6056893a4" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;chop()&lt;/code&gt; for file paths.</source>
          <target state="translated">当使用Unix或MSDOS语法时，它会模拟 &lt;code&gt;dirname(1)&lt;/code&gt; shell函数，该函数与 &lt;code&gt;fileparse()&lt;/code&gt; 的工作方式稍有不同。即使最后一级显然是目录，它也会返回文件路径的最后一级以外的所有内容。实际上，它不是返回目录部分，而只是返回上一级的路径，类似于文件路径的 &lt;code&gt;chop()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd36b103bb843eb67404d1ba086bba3444a9a91a" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt; ).</source>
          <target state="translated">当使用GCC以外的编译器时，以上条目将搜索 &lt;code&gt;gl.lib&lt;/code&gt; （紧随其后的是 &lt;code&gt;libgl.lib&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c33d34fd00e0ffeecdde05351cb8111bf653102c" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt;).</source>
          <target state="translated">当使用GCC以外的编译器时，以上条目将搜索 &lt;code&gt;gl.lib&lt;/code&gt; （紧随其后的是 &lt;code&gt;libgl.lib&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a204d7a3df2c41a83e110893f714e673583621f8" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="translated">当使用不支持内联修饰符的 &lt;code&gt;(?:)&lt;/code&gt; 构造的自定义引擎时，最好将 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 字符串化为所提供的模式，请注意，在以下情况下，这将创建不需要的模式：</target>
        </trans-unit>
        <trans-unit id="5336937191442d7debf67f5b96f41e967c4d55af" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;qr//&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="translated">当使用不支持用于内联修饰符的 &lt;code&gt;(?:)&lt;/code&gt; 构造的自定义引擎时，最好将 &lt;code&gt;qr//&lt;/code&gt; 字符串化为所提供的模式，请注意，在以下情况下，这将创建不需要的模式：</target>
        </trans-unit>
        <trans-unit id="aa29772ff0d1046f60f263e930495cc6300916c4" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt; , in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="translated">使用签名时，除了签名的词法变量之外，特殊数组变量 &lt;code&gt;@_&lt;/code&gt; 中的参数仍然可用。两种访问参数的方式有所不同： &lt;code&gt;@_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e523513d7b0658b27eb8124687617b728e5c9ac2" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt;, in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="translated">使用签名时，除了签名的词法变量之外，特殊数组变量 &lt;code&gt;@_&lt;/code&gt; 中的参数仍然可用。两种访问参数的方式之间是有区别的： &lt;code&gt;@_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="551ef8173c29847114a58bb1f60332f351498c93" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt; ), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="translated">当使用这些例程中的任何一个（ &lt;code&gt;call_argv&lt;/code&gt; 除外）时，程序员必须操纵Perl堆栈。这些包括以下宏和函数：</target>
        </trans-unit>
        <trans-unit id="b91da188fa3782ad027e51e622e75b65bd3a446d" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt;), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="translated">当使用这些例程中的任何一个（ &lt;code&gt;call_argv&lt;/code&gt; 除外）时，程序员必须操纵Perl堆栈。这些包括以下宏和函数：</target>
        </trans-unit>
        <trans-unit id="b83deb7885e7123190175e707dccaec554d080b8" translate="yes" xml:space="preserve">
          <source>When using look-ahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="translated">当使用前瞻断言和否定时,这一切可能会变得更加棘手。想象一下,你想找到一个不以 &quot;123 &quot;开头的非数字序列。你可以试着写成</target>
        </trans-unit>
        <trans-unit id="8056637c2c9cbcfa303f8f1dbc6790e418dcb403" translate="yes" xml:space="preserve">
          <source>When using lookahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="translated">当使用lookahead断言和否定时,这一切可能会变得更加棘手。想象一下,你想找到一个不以 &quot;123 &quot;开头的非数字序列。你可以试着写成</target>
        </trans-unit>
        <trans-unit id="f069b81fc03a5abd7bd819f6288faad34de8014e" translate="yes" xml:space="preserve">
          <source>When using non-blocking mode, the caller must repeatedly check for writeability on the filehandle (for instance using &lt;code&gt;select&lt;/code&gt; or &lt;code&gt;IO::Poll&lt;/code&gt;). Each time the filehandle is ready to write, the &lt;code&gt;connect&lt;/code&gt; method must be called, with no arguments. Note that some operating systems, most notably &lt;code&gt;MSWin32&lt;/code&gt; do not report a &lt;code&gt;connect()&lt;/code&gt; failure using write-ready; so you must also &lt;code&gt;select()&lt;/code&gt; for exceptional status.</source>
          <target state="translated">使用非阻塞模式时，调用者必须反复检查文件句柄的可写性（例如，使用 &lt;code&gt;select&lt;/code&gt; 或 &lt;code&gt;IO::Poll&lt;/code&gt; ）。每次准备好编写文件句柄时，都必须调用无参数的 &lt;code&gt;connect&lt;/code&gt; 方法。请注意，某些操作系统，最著名的是 &lt;code&gt;MSWin32&lt;/code&gt; ，不会使用可写状态报告 &lt;code&gt;connect()&lt;/code&gt; 故障。因此，您还必须 &lt;code&gt;select()&lt;/code&gt; 以获得特殊状态。</target>
        </trans-unit>
        <trans-unit id="104bb1d18df407b49f695cf681f4f8244f6c16f3" translate="yes" xml:space="preserve">
          <source>When using perl on OS/390 please keep in mind that the EBCDIC and ASCII character sets are different. See perlebcdic.pod for more on such character set issues. Perl builtin functions that may behave differently under EBCDIC are also mentioned in the perlport.pod document.</source>
          <target state="translated">当在OS/390上使用perl时,请记住EBCDIC和ASCII字符集是不同的。有关此类字符集问题的更多信息,请参见 perlebcdic.pod。perlport.pod文档中也提到了在EBCDIC下可能表现不同的Perl内置函数。</target>
        </trans-unit>
        <trans-unit id="1ef7e739e319a736386db6464491dd098d4f2bf1" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; . A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt; . (Don't judge me.)</source>
          <target state="translated">在 &lt;code&gt;-m&lt;/code&gt; 模式（显示模块源代码）下使用perldoc时， &lt;code&gt;perldoc&lt;/code&gt; 将尝试使用 &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; 中设置的寻呼机。该命令的一个有用设置是您喜欢的编辑器，如 &lt;code&gt;/usr/bin/nano&lt;/code&gt; 。（不要判断我）</target>
        </trans-unit>
        <trans-unit id="ca44e9fc9c83d8e97acbec5970188d530099b61d" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt;. A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt;. (Don't judge me.)</source>
          <target state="translated">在 &lt;code&gt;-m&lt;/code&gt; 模式（显示模块源代码）下使用perldoc时， &lt;code&gt;perldoc&lt;/code&gt; 将尝试使用 &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; 中设置的寻呼机。该命令的一个有用设置是您喜欢的编辑器，如 &lt;code&gt;/usr/bin/nano&lt;/code&gt; 。 （不要判断我。）</target>
        </trans-unit>
        <trans-unit id="6f3d08e19ee9978bf8615d5e1fb391a30ff5fc30" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, and the dotted ip string will be returned instead of just the host. If the optional $host argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than syn.</source>
          <target state="translated">当使用 &quot;syn &quot;协议时,使用这个方法来确定远程主机的可到达性。这个方法的调用次数与调用ping()的次数一样多。每次调用都会返回带有TCP ACK的主机(如传递给ping()的那样)。返回主机的顺序不一定与使用ping()方法进行SYN排队的顺序相同。如果在收到TCP ACK之前就达到了超时,或者远程主机没有在尝试的端口上监听,那么TCP连接将无法建立,ack()将返回undef。在列表上下文中,将返回主机、ack时间和点号ip字符串,而不是只返回主机。如果指定了可选的$host参数,返回值将只与该主机有关。如果你使用的是除syn以外的其他协议,这个调用根本没有任何作用。</target>
        </trans-unit>
        <trans-unit id="420afa8aef5868ada909527b4d0cf95eed4c31dc" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, the dotted ip string, and the port number will be returned instead of just the host. If the optional &lt;code&gt;$host&lt;/code&gt; argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than &quot;syn&quot;.</source>
          <target state="translated">使用&amp;ldquo; syn&amp;rdquo;协议时，请使用此方法确定远程主机的可达性。该方法的调用次数应与ping（）的调用次数相同。每个调用都返回随TCP ACK一起返回的主机（传递给ping（））。返回主机的顺序不一定与使用ping（）方法对SYN排队的顺序相同。如果在收到TCP ACK之前达到超时，或者远程主机没有在尝试的端口上侦听，则将不会建立TCP连接，并且ack（）将返回undef。在列表上下文中，将返回主机，确认时间，点分IP字符串和端口号，而不仅仅是返回主机。如果可选的 &lt;code&gt;$host&lt;/code&gt; 指定参数，返回值将仅与该主机有关。如果您使用的是&amp;ldquo; syn&amp;rdquo;以外的其他协议，则此调用完全不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="8669a447d2a5338b38de691880feda228a223459" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;+&lt;/code&gt; prototype, your function must check that the argument is of an acceptable type.</source>
          <target state="translated">使用 &lt;code&gt;+&lt;/code&gt; 原型时，您的函数必须检查参数是否为可接受的类型。</target>
        </trans-unit>
        <trans-unit id="665e3521b5bde08e89b6fb412400db5ea3876686" translate="yes" xml:space="preserve">
          <source>When using the Borland compiler, the second item is returned as &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt;, and MakeMaker takes care of moving the &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; to the correct place in the linker command line.</source>
          <target state="translated">使用Borland编译器时，第二项以 &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt; ，MakeMaker负责将 &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; 移动到链接器命令行中的正确位置。</target>
        </trans-unit>
        <trans-unit id="182973d530ef056d12686b9b768cbe121c56d846" translate="yes" xml:space="preserve">
          <source>When using the GUI version of SAM, click on the Kernel Configuration icon, then the Configurable Parameters icon. Scroll down and select the maxdsiz line. From the Actions menu, select the Modify Configurable Parameter item. Insert the new formula into the Formula/Value box. Then follow the instructions to rebuild your kernel and reboot your system.</source>
          <target state="translated">当使用GUI版本的SAM时,点击内核配置图标,然后点击可配置参数图标。向下滚动并选择maxdsiz行。从Actions菜单中,选择Modify Configurable Parameter项目。在Formula/Value框中插入新的公式。然后按照说明重建内核并重启系统。</target>
        </trans-unit>
        <trans-unit id="7f3f457ad81c7a19053f3621a5ae319fe9cb4521" translate="yes" xml:space="preserve">
          <source>When using the Visual C compiler, the second item is returned as &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt;.</source>
          <target state="translated">使用Visual C编译器时，第二项作为 &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa76c289706bb600b3c9b3e3777d7935b3662cb5" translate="yes" xml:space="preserve">
          <source>When using the constants, if you don't want to have to remember to add the &lt;code&gt;, RESET&lt;/code&gt; at the end of each print line, you can set $Term::ANSIColor::AUTORESET to a true value. Then, the display mode will automatically be reset if there is no comma after the constant. In other words, with that variable set:</source>
          <target state="translated">使用常量时，如果不想记住在每个打印行的末尾添加 &lt;code&gt;, RESET&lt;/code&gt; ，则可以将$ Term :: ANSIColor :: AUTORESET设置为真实值。然后，如果常量后面没有逗号，则显示模式将自动重置。换句话说，设置该变量：</target>
        </trans-unit>
        <trans-unit id="a51c1c8c0eb3074d9df3759b3281e7508c8091a5" translate="yes" xml:space="preserve">
          <source>When using this compiler to build Perl, you should make sure that the flag -Aa is added to the cpprun and cppstdin variables in the config.sh file (though see the section on 64-bit perl below). If you are using a recent version of the Perl distribution, these flags are set automatically.</source>
          <target state="translated">当使用这个编译器来编译Perl时,你应该确保在config.sh文件中的cpprun和cppstdin变量中加入了标志-Aa(参见下面关于64位perl的章节)。如果你使用的是最新版本的 Perl 发行版,这些标志会自动设置。</target>
        </trans-unit>
        <trans-unit id="a190d4d20525775f69d139675c3dc51cef5fb8f2" translate="yes" xml:space="preserve">
          <source>When using tools like &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; that can generate the &lt;code&gt;provides&lt;/code&gt; mapping for your distribution automatically, make sure you examine what it generates to make sure it makes sense - indexers will usually trust the &lt;code&gt;provides&lt;/code&gt; field if it's present, rather than scanning through the distribution files themselves to figure out packages and versions. This is a good thing, because it means you can use the &lt;code&gt;provides&lt;/code&gt; field to tell the indexers precisely what you want indexed about your distribution, rather than relying on them to essentially guess what you want indexed.</source>
          <target state="translated">当使用工具，如&lt;a href=&quot;Module::Build&quot;&gt;模块::生成&lt;/a&gt;，可以生成 &lt;code&gt;provides&lt;/code&gt; 自动为您分布创建，确保你检查它产生，以确保它是有道理的-索引通常会信任 &lt;code&gt;provides&lt;/code&gt; 现场，如果它的存在，而不是通过分发扫描文件本身以找出软件包和版本。这是一件好事，因为这意味着你可以使用 &lt;code&gt;provides&lt;/code&gt; 现场准确地告诉索引你想要什么索引你的分布，而不是依靠他们基本上猜出你想要的索引。</target>
        </trans-unit>
        <trans-unit id="9d278a4b7e876e4a2527267176d89369b93fdace" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">验证现有摘要字符串时，应将摘要用作盐（例如 &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ）。用于创建摘要的SALT作为摘要的一部分可见。这样可以确保crypt（）使用与摘要相同的盐值来哈希新字符串。这使您的代码可以与标准&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;以及更多奇异的实现一起使用。换句话说，对于返回的字符串本身或SALT多少字节可能无关紧要。</target>
        </trans-unit>
        <trans-unit id="1154d04d428d0c152c2ffba2d49aad6c93079515" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">验证现有摘要字符串时，应将摘要用作盐（例如 &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ）。用于创建摘要的SALT作为摘要的一部分可见。这样可以确保crypt（）使用与摘要相同的盐值来哈希新字符串。这使您的代码可以与标准&lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt;以及更多奇异的实现一起使用。换句话说，对于返回的字符串本身或SALT多少字节可能无关紧要。</target>
        </trans-unit>
        <trans-unit id="213bdf210d4174fda29ca99ffa2edc52c2a2b3fb" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;crypt($plain, $digest) eq $digest&lt;/code&gt;). The SALT used to create the digest is visible as part of the digest. This ensures &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">验证现有摘要字符串时，应将摘要用作盐（例如 &lt;code&gt;crypt($plain, $digest) eq $digest&lt;/code&gt; ）。用于创建摘要的SALT作为摘要的一部分可见。这确保了&lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt; &lt;code&gt;crypt&lt;/code&gt; &lt;/a&gt;将使用与摘要相同的盐值来哈希新字符串。这使您的代码可以与标准&lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt; &lt;code&gt;crypt&lt;/code&gt; &lt;/a&gt;以及更多奇异的实现一起使用。换句话说，不要对返回的字符串本身或SALT多少字节可能有任何影响。</target>
        </trans-unit>
        <trans-unit id="3ffe4a395b717a174f8af1eb199172f9bf8e1018" translate="yes" xml:space="preserve">
          <source>When we bless something, we are not blessing the variable which contains a reference to that thing, nor are we blessing the reference that the variable stores; we are blessing the thing that the variable refers to (sometimes known as the</source>
          <target state="translated">当我们祝福某件事时,我们不是祝福包含对该事物的引用的变量,也不是祝福变量所存储的引用;我们是祝福变量所引用的事物(有时也被称为该事物的</target>
        </trans-unit>
        <trans-unit id="7f1d89cf9a7bec3f0e241604b9f6d2928198590e" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="translated">当我们对变量调用 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 时，实际上是在祝福该变量所引用的基础数据结构。我们没有祝福引用本身，也没有祝福包含该引用的变量。这就是第二次对 &lt;code&gt;blessed( $bar )&lt;/code&gt; 调用返回false的原因。那时， &lt;code&gt;$bar&lt;/code&gt; 不再存储对对象的引用。</target>
        </trans-unit>
        <trans-unit id="6555170698fd78a17d09b080573745f1fb3e931d" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;bless&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="translated">当我们对变量调用 &lt;code&gt;bless&lt;/code&gt; 时，实际上是在祝福该变量所引用的基础数据结构。我们没有祝福引用本身，也没有祝福包含该引用的变量。这就是第二次对 &lt;code&gt;blessed( $bar )&lt;/code&gt; 调用返回false的原因。那时， &lt;code&gt;$bar&lt;/code&gt; 不再存储对对象的引用。</target>
        </trans-unit>
        <trans-unit id="c70879bf53ea832ca0790a74069f648240179f77" translate="yes" xml:space="preserve">
          <source>When we make a method call, Perl arranges for the method's &lt;b&gt;invocant&lt;/b&gt; to be passed as the first argument. &lt;b&gt;Invocant&lt;/b&gt; is a fancy name for the thing on the left side of the arrow. The invocant can either be a class name or an object. We can also pass additional arguments to the method:</source>
          <target state="translated">当我们把一个方法调用，Perl的安排方法的&lt;b&gt;调用者&lt;/b&gt;，以作为第一个参数传递。&lt;b&gt;Invocant&lt;/b&gt;是箭头左侧的东西的奇特名称。发起人可以是类名或对象。我们还可以将其他参数传递给该方法：</target>
        </trans-unit>
        <trans-unit id="8e5660d78c1c3767afae15f24a83c561307c4b20" translate="yes" xml:space="preserve">
          <source>When we say &quot;Mac OS&quot; below, we mean Mac OS 7, 8, and 9, and</source>
          <target state="translated">下面我们说的 &quot;Mac OS &quot;是指Mac OS 7、8、9和</target>
        </trans-unit>
        <trans-unit id="32e492af43a84b7607b727f8ffe43ea47c5296c8" translate="yes" xml:space="preserve">
          <source>When we want to place values to be returned to the caller onto the stack, we use the series of macros that begin with &quot;XPUSH&quot;. There are five different versions, for placing integers, unsigned integers, doubles, strings, and Perl scalars on the stack. In our example, we placed a Perl scalar onto the stack. (In fact this is the only macro which can be used to return multiple values.)</source>
          <target state="translated">当我们要将返回给调用者的值放置在栈上时,我们使用一系列以 &quot;XPUSH &quot;开头的宏。有五个不同的版本,用于将整数、无符号整数、双数、字符串和Perl标量放在栈上。在我们的例子中,我们将Perl标量放置在堆栈上。(事实上,这是唯一一个可以用来返回多个值的宏。)</target>
        </trans-unit>
        <trans-unit id="5c32617504af087d7eaf74d60f9f81f18d15e5a1" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt; . This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="translated">当遇到长度超过 &lt;code&gt;$columns&lt;/code&gt; 单词时，它们将被分解。 &lt;code&gt;wrap()&lt;/code&gt; 在 &lt;code&gt;$columns&lt;/code&gt; 添加 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 。可以通过将 &lt;code&gt;$huge&lt;/code&gt; 设置为 'die'或'overflow' 来覆盖此行为。当设置为'die'时，较大的单词将导致 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 被调用。设置为&amp;ldquo;溢出&amp;rdquo;时，大字将保持不变。</target>
        </trans-unit>
        <trans-unit id="5ebaaddfa0e00536f0f1b77f056696aff48f065e" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt;. This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;die()&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="translated">当遇到长度超过 &lt;code&gt;$columns&lt;/code&gt; 单词时，它们将被分解。 &lt;code&gt;wrap()&lt;/code&gt; 在 &lt;code&gt;$columns&lt;/code&gt; 添加 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 。可以通过将 &lt;code&gt;$huge&lt;/code&gt; 设置为'die'或'overflow'来覆盖此行为。当设置为'die'时，较大的单词将导致 &lt;code&gt;die()&lt;/code&gt; 被调用。设置为&amp;ldquo;溢出&amp;rdquo;时，大字将保留原样。</target>
        </trans-unit>
        <trans-unit id="52a8fd5862d63d0243193e3a0106e35c7816b525" translate="yes" xml:space="preserve">
          <source>When writing a DBM filter it is</source>
          <target state="translated">当编写一个DBM过滤器时,它是</target>
        </trans-unit>
        <trans-unit id="6e29ef5da6dd2ada1107f66b4d19daef44972a34" translate="yes" xml:space="preserve">
          <source>When writing a Perl extension for general consumption, one should expect that the extension will be used with versions of Perl different from the version available on your machine. Since you are reading this document, the version of Perl on your machine is probably 5.005 or later, but the users of your extension may have more ancient versions.</source>
          <target state="translated">当编写一个用于一般消费的Perl扩展时,我们应该预料到该扩展将与你机器上的Perl版本不同。由于你正在阅读这篇文档,你的机器上的Perl版本可能是5.005或更高版本,但你的扩展的用户可能有更古老的版本。</target>
        </trans-unit>
        <trans-unit id="b339c5d874b742d033a9c15bc59a2eb32b3fde03" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt; , unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt; .</source>
          <target state="translated">将字符UV写入UTF-8字符串时，请&lt;b&gt;始终&lt;/b&gt;使用 &lt;code&gt;uvchr_to_utf8&lt;/code&gt; ，除非使用 &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; 在这种情况下可以使用 &lt;code&gt;*s = uv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ffec04c54d59e59616907c7e9e4db0144cb75f4" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt;, unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt;.</source>
          <target state="translated">将字符UV写入UTF-8字符串时，请&lt;b&gt;始终&lt;/b&gt;使用 &lt;code&gt;uvchr_to_utf8&lt;/code&gt; ，除非使用 &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; 在这种情况下可以使用 &lt;code&gt;*s = uv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f50a991a4544cc3b4a29ac32fb9e95a158b8cf9" translate="yes" xml:space="preserve">
          <source>When writing a gzip file this interface will</source>
          <target state="translated">当写一个gzip文件时,这个接口将</target>
        </trans-unit>
        <trans-unit id="bb628954db56a328fb9c77ac1ab1c6c9e5566f04" translate="yes" xml:space="preserve">
          <source>When writing to a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before writing to the file.</source>
          <target state="translated">写入文件或文件句柄时，在写入文件之前设置 &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b83d473ca051f901386a9b5075ab3cc8642b96d1" translate="yes" xml:space="preserve">
          <source>When you</source>
          <target state="translated">当你</target>
        </trans-unit>
        <trans-unit id="2677cbf7ed31e30ff85aaafd2211c14bcf4260ba" translate="yes" xml:space="preserve">
          <source>When you are content with suspects list, you can now</source>
          <target state="translated">当您对嫌疑人名单感到满意时,您现在可以进行以下操作</target>
        </trans-unit>
        <trans-unit id="2f2f89e3cbdda44107d5b7350f0150202920760d" translate="yes" xml:space="preserve">
          <source>When you are done, the XS-module install process will have added information to your &quot;perllocal&quot; information telling that the perl binary has been replaced, and what module was installed. You can view this information at any time by using the command:</source>
          <target state="translated">当你完成后,XS-module安装过程会在你的 &quot;perllocal &quot;信息中添加信息,告诉你perl二进制文件已经被替换,以及安装了什么模块。你可以在任何时候使用命令来查看这些信息。</target>
        </trans-unit>
        <trans-unit id="b326342faabbb3f551d027918413fb764e7ae496" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself (if you feel masochistic enough) from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="translated">当您要使用GNU C编译器（gcc）时，如果您还没有gcc，则可以从源代码（例如，可从&lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http：//gcc.gnu&lt;/a&gt;获取）自行构建（如果您感到受虐狂）。.org / mirrors.html），或从HP移植中心（&lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt;或从DSPP提取预构建的二进制文件（您需要是在成员）&lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt;（浏览列表，因为有相同的往往多个版本包可用）。</target>
        </trans-unit>
        <trans-unit id="0c482f23205d9f8b77692de807395bf57f9f55a5" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself (if you feel masochistic enough) from the sources (available from e.g. &lt;a href=&quot;https://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="translated">当您要使用GNU C编译器（gcc）时，如果您还没有gcc，则可以从源代码（例如，可从&lt;a href=&quot;https://gcc.gnu.org/mirrors.html&quot;&gt;http：//gcc.gnu&lt;/a&gt;获取）自行构建（如果您感到受虐狂）。.org / mirrors.html），或从HP移植中心（&lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt;或从DSPP提取预构建的二进制文件（您需要是在成员）&lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt;（浏览列表，因为有相同的往往多个版本包可用）。</target>
        </trans-unit>
        <trans-unit id="081b49cdc45047c15c231503ee57d721c9ac98ea" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="translated">当您要使用GNU C编译器（gcc）且还没有gcc时，您可以从源代码自己构建它（例如，可以从&lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html获得&lt;/a&gt;）。或从&lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt;的HP移植中心获取预构建的二进制文件，或者从&lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://www.hp.com/go/DSPP&lt;/a&gt;（您需要成为成员）：？//h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801 CIID = 2a08725cc2f02110725cc2f02110275d6e10RCRD＆jumpid = reg_r1002_usen_c-001_title_r0001（浏览列表，因为经常有同一个包的多个版本）。</target>
        </trans-unit>
        <trans-unit id="1e1fba30b9427287c1016e2b2ee037287889c225" translate="yes" xml:space="preserve">
          <source>When you are manually creating a UCM file, you should copy ascii.ucm or an existing encoding which is close to yours, rather than write your own from scratch.</source>
          <target state="translated">当您手动创建UCM文件时,您应该复制ascii.ucm或与您的编码相近的现有编码,而不是从头开始编写自己的编码。</target>
        </trans-unit>
        <trans-unit id="4780d196081ec9146c3e56c719b52c3ce1654983" translate="yes" xml:space="preserve">
          <source>When you are satisfied with the results of tests, install the build C libraries for extensions:</source>
          <target state="translated">当你对测试结果满意后,安装扩展的构建C库。</target>
        </trans-unit>
        <trans-unit id="a59f72a1e66eb8909341fcc7e63f4b0c726287dd" translate="yes" xml:space="preserve">
          <source>When you are sure that only a few subdirectories lead to failures, you may want to add &lt;code&gt;-j4&lt;/code&gt; option to &lt;code&gt;make&lt;/code&gt; to speed up skipping subdirectories with already finished build.</source>
          <target state="translated">当你确信只有几个子目录导致故障，您可能要添加 &lt;code&gt;-j4&lt;/code&gt; 选项 &lt;code&gt;make&lt;/code&gt; 加快与已经完成构建跳过子目录。</target>
        </trans-unit>
        <trans-unit id="7b2f8e90d6f4d4294f6e2dcda859cd96193b4ae7" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;icmp&quot; protocol, this call permit to change the message type to 'echo' or 'timestamp' (only for IPv4, see RFC 792).</source>
          <target state="translated">当你使用 &quot;icmp &quot;协议时,这个调用允许将消息类型改为 &quot;echo &quot;或 &quot;timestamp&quot;(仅适用于IPv4,见RFC 792)。</target>
        </trans-unit>
        <trans-unit id="c0610c400691e07d6b5c5967ea7cb5f197bdd7da" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="translated">当您使用&amp;ldquo;流&amp;rdquo;协议时，此调用会预先打开tcp套接字。仅当您要在创建连接时提供不同的超时时间时才需要执行此操作，或者从第一次ping中消除建立连接的开销。如果不调用 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; ，则在第一次调用 &lt;code&gt;ping()&lt;/code&gt; 时会自动打开连接。如果您使用流以外的任何协议，则此调用完全不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="53d7ace59a255ce0dee603a0e82c9350ed60c845" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;open()&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="translated">当您使用&amp;ldquo;流&amp;rdquo;协议时，此调用会预先打开tcp套接字。仅当您要在创建连接时提供不同的超时时间，或从第一次ping消除建立连接的开销时，才需要执行此操作。如果不调用 &lt;code&gt;open()&lt;/code&gt; ，则在第一次调用 &lt;code&gt;ping()&lt;/code&gt; 时会自动打开连接。如果您使用流以外的任何协议，则此调用将不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="19030bdd1652e63fb5fe9a91af20f3234d06d23f" translate="yes" xml:space="preserve">
          <source>When you assign a list of scalars to an array, all previous values in that array are wiped out and the number of elements in the array will now be equal to the number of elements in the right-hand list -- the list from which assignment was made. The array will automatically resize itself to precisely accommodate each element in the right-hand list.</source>
          <target state="translated">当你把一个标量列表分配给一个数组时,数组中所有以前的值都会被抹去,数组中的元素数量现在将等于右侧列表中的元素数量--从列表中进行分配。数组将自动调整自己的大小,以精确地容纳右侧列表中的每个元素。</target>
        </trans-unit>
        <trans-unit id="a9fd269eddc721c08a06a789973e8783627db576" translate="yes" xml:space="preserve">
          <source>When you build modules, tell Perl where to install the modules.</source>
          <target state="translated">当你构建模块时,告诉Perl安装模块的位置。</target>
        </trans-unit>
        <trans-unit id="d2efe854f0b34964ee2879b9748bb899c2079d18" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt; :</source>
          <target state="translated">当您使用参数调用 &lt;code&gt;bar&lt;/code&gt; 时，您会看到 &lt;code&gt;foo&lt;/code&gt; 拥有相同的 &lt;code&gt;@_&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c91152667ee3ebf07dbc40066530c9ec19f3697d" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt;:</source>
          <target state="translated">当您使用参数调用 &lt;code&gt;bar&lt;/code&gt; 时，您会看到 &lt;code&gt;foo&lt;/code&gt; 拥有相同的 &lt;code&gt;@_&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="835f87385a105654b52b3b81d31156a333d91b09" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;open&lt;/code&gt; this way, Perl invokes the given command directly, bypassing the shell. As such, the shell won't try to interpret any special characters within the command's argument list, which might overwise have unwanted effects. This can make for safer, less error-prone &lt;code&gt;open&lt;/code&gt; calls, useful in cases such as passing in variables as arguments, or even just referring to filenames with spaces in them.</source>
          <target state="translated">当您以这种方式调用 &lt;code&gt;open&lt;/code&gt; 时，Perl会绕过Shell直接调用给定命令。因此，shell不会尝试解释命令参数列表中的任何特殊字符，这些特殊字符可能会造成不必要的影响。这样可以进行更安全，更不易出错的 &lt;code&gt;open&lt;/code&gt; 调用，在诸如将变量作为参数传递甚至仅引用其中包含空格的文件名之类的情况下很有用。</target>
        </trans-unit>
        <trans-unit id="685020a1713f908c5ec69a7f573fc741004b77c1" translate="yes" xml:space="preserve">
          <source>When you call Perl's &lt;code&gt;open&lt;/code&gt; to set a Perl file handle [like &lt;code&gt;STDOUT&lt;/code&gt;], Perl calls C's &lt;code&gt;fopen&lt;/code&gt; to set a stdio &lt;code&gt;FILE *&lt;/code&gt;. C's &lt;code&gt;fopen&lt;/code&gt; calls something like Unix's &lt;code&gt;open&lt;/code&gt;, that is, Win32's &lt;code&gt;_sopen&lt;/code&gt;, to get an integer file descriptor [where 0 is for &lt;code&gt;STDIN&lt;/code&gt;, 1 for &lt;code&gt;STDOUT&lt;/code&gt;, etc.]. Win32's &lt;code&gt;_sopen&lt;/code&gt; calls &lt;code&gt;CreateFile&lt;/code&gt; to set a &lt;code&gt;HANDLE&lt;/code&gt;, a Win32 native file handle. So every Perl file handle [like &lt;code&gt;STDOUT&lt;/code&gt;] has an integer file descriptor associated with it that you can get via &lt;code&gt;fileno&lt;/code&gt;. And, under Win32, every file descriptor has a Win32 native file handle associated with it. &lt;code&gt;FdGetOsFHandle&lt;/code&gt; lets you get access to that.</source>
          <target state="translated">当您调用Perl的 &lt;code&gt;open&lt;/code&gt; 来设置Perl文件句柄（如 &lt;code&gt;STDOUT&lt;/code&gt; ）时，Perl调用C的 &lt;code&gt;fopen&lt;/code&gt; 来设置stdio &lt;code&gt;FILE *&lt;/code&gt; 。 C的 &lt;code&gt;fopen&lt;/code&gt; 调用类似于Unix的 &lt;code&gt;open&lt;/code&gt; ，即Win32的 &lt;code&gt;_sopen&lt;/code&gt; ，以获取整数文件描述符（其中0表示 &lt;code&gt;STDIN&lt;/code&gt; ，1表示 &lt;code&gt;STDOUT&lt;/code&gt; 等）。 Win32的 &lt;code&gt;_sopen&lt;/code&gt; 调用 &lt;code&gt;CreateFile&lt;/code&gt; 来设置 &lt;code&gt;HANDLE&lt;/code&gt; ，这是Win32本机文件句柄。因此，每个Perl文件句柄（如 &lt;code&gt;STDOUT&lt;/code&gt; ）都有一个与之关联的整数文件描述符，您可以通过 &lt;code&gt;fileno&lt;/code&gt; 获取该描述符。。并且，在Win32下，每个文件描述符都有一个与之关联的Win32本机文件句柄。 &lt;code&gt;FdGetOsFHandle&lt;/code&gt; 使您可以访问它。</target>
        </trans-unit>
        <trans-unit id="0e313737a6b3963a3bf8908006a0a820d6e4555f" translate="yes" xml:space="preserve">
          <source>When you call a fully qualified method name like &lt;code&gt;File::save&lt;/code&gt;, the method resolution search for the &lt;code&gt;save&lt;/code&gt; method starts in the &lt;code&gt;File&lt;/code&gt; class, skipping any &lt;code&gt;save&lt;/code&gt; method the &lt;code&gt;File::MP3&lt;/code&gt; class may have defined. It still searches the &lt;code&gt;File&lt;/code&gt; class's parents if necessary.</source>
          <target state="translated">当您调用完全限定的方法名称（如 &lt;code&gt;File::save&lt;/code&gt; ，将在 &lt;code&gt;File&lt;/code&gt; 类中开始对 &lt;code&gt;save&lt;/code&gt; 方法的方法分辨率搜索，而跳过 &lt;code&gt;File::MP3&lt;/code&gt; 类可能已定义的任何 &lt;code&gt;save&lt;/code&gt; 方法。如有必要，它仍会搜索 &lt;code&gt;File&lt;/code&gt; 类的父级。</target>
        </trans-unit>
        <trans-unit id="010f5217ea46f708fe21b0efa65632329708b27e" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; , the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; , the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt; .</source>
          <target state="translated">调用方法时，箭头左侧的内容将作为第一个参数传递给该方法。这意味着当我们调用 &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; 时， &lt;code&gt;new()&lt;/code&gt; 方法将接收字符串 &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; 作为其第一个参数。当我们调用 &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; ，会将 &lt;code&gt;$fred&lt;/code&gt; 变量作为第一个参数传递给talk &lt;code&gt;speak()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fae81431a82ed2b7245ab26b577216b20acfee24" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt;, the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt;, the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt;.</source>
          <target state="translated">调用方法时，箭头左侧的内容将作为第一个参数传递给该方法。这意味着当我们调用 &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; 时， &lt;code&gt;new()&lt;/code&gt; 方法将接收字符串 &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; 作为其第一个参数。当我们调用 &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; ，会将 &lt;code&gt;$fred&lt;/code&gt; 变量作为第一个参数传递给talk &lt;code&gt;speak()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="210c4bda966e8ba5f3d3dd89593f4b86c57dc0ef" translate="yes" xml:space="preserve">
          <source>When you call the &lt;code&gt;tie&lt;/code&gt; function to bind an associative array to this package, you may specify as an optional argument the symbol table in which you wish to create and delete symbols. If the argument is the string 'GLOBAL', then the global symbol table is used; any other string causes the local symbol table to be used. Note that this argument does not affect attempts to read symbols; if a symbol with the specified name exists in the local symbol table, it is always returned in preference to a symbol by the same name in the global symbol table.</source>
          <target state="translated">当您调用 &lt;code&gt;tie&lt;/code&gt; 函数将关联数组绑定到此程序包时，可以将希望在其中创建和删除符号的符号表指定为可选参数。如果参数是字符串&amp;ldquo; GLOBAL&amp;rdquo;，则使用全局符号表；否则，将使用全局符号表。任何其他字符串都会导致使用本地符号表。请注意，此参数不会影响读取符号的尝试。如果本地符号表中存在具有指定名称的符号，则始终优先于全局符号表中的名称相同的符号返回该符号。</target>
        </trans-unit>
        <trans-unit id="f9ac7d5348373bdb94113353aa9433d2aa26a56e" translate="yes" xml:space="preserve">
          <source>When you change a &lt;b&gt;value&lt;/b&gt; as it is being copied. [From French &amp;ldquo;in passing&amp;rdquo;, as in the exotic pawn-capturing maneuver in chess.]</source>
          <target state="translated">当您更改要复制的&lt;b&gt;值时&lt;/b&gt;。[摘自法语&amp;ldquo;通过&amp;rdquo;，如国际象棋中充满异国情调的典当捕获动作。]</target>
        </trans-unit>
        <trans-unit id="f19e6c82fbc2b2542cdae76f95f1a0c2e0deb19b" translate="yes" xml:space="preserve">
          <source>When you chop() a mathemagical object it is promoted to a string and its mathemagical properties are lost. The same can happen with other operations as well.</source>
          <target state="translated">当你砍()一个数学对象时,它会被提升为一个字符串,并且它的数学属性会丢失。同样的情况也会发生在其他操作上。</target>
        </trans-unit>
        <trans-unit id="ffb591449d98f90fa2f19a8fc5d8c220dd517b21" translate="yes" xml:space="preserve">
          <source>When you combine legacy data and Unicode, the legacy data needs to be upgraded to Unicode. Normally the legacy data is assumed to be ISO 8859-1 (or EBCDIC, if applicable).</source>
          <target state="translated">当您将遗留数据和Unicode结合起来时,需要将遗留数据升级为Unicode。通常,遗留数据被假定为ISO 8859-1(或EBCDIC,如果适用)。</target>
        </trans-unit>
        <trans-unit id="177eeefc399a73cfd5bfb70b98c9df5de8601114" translate="yes" xml:space="preserve">
          <source>When you create a map, you SHOULD make your mappings round-trip safe. That is, &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq
$data&lt;/code&gt; stands for all characters that are marked as &lt;code&gt;|0&lt;/code&gt;. Here is how to make sure:</source>
          <target state="translated">创建地图时，应确保地图往返安全。也就是说， &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq $data&lt;/code&gt; 表示标记为 &lt;code&gt;|0&lt;/code&gt; 所有字符。这是如何确保：</target>
        </trans-unit>
        <trans-unit id="bb9cd7b8a4ff60818aa2eb01184f94103173f0c2" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt; .</source>
          <target state="translated">当使用上述方法声明诸如 &lt;code&gt;PI&lt;/code&gt; 之类的常量时，运行脚本的每台计算机都可以使用尽可能多的精度。同样，您的程序将更易于阅读，更易于维护（并正确维护），并且不太可能向错误的行星发送空间探测器，因为没有人注意到您编写 &lt;code&gt;3.14195&lt;/code&gt; 的公式。</target>
        </trans-unit>
        <trans-unit id="4e2b5a1dcab630574856b807ba52f00dea975f20" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt;.</source>
          <target state="translated">当使用上述方法声明诸如 &lt;code&gt;PI&lt;/code&gt; 之类的常量时，运行脚本的每台计算机都可以使用尽可能多的精度。同样，您的程序将更易于阅读，更易于维护（并正确维护），并且不太可能向错误的行星发送空间探测器，因为没人注意到您编写了 &lt;code&gt;3.14195&lt;/code&gt; 的方程式。</target>
        </trans-unit>
        <trans-unit id="34ad5430f738cd6a6ba4f6afa7a8297067c10fdd" translate="yes" xml:space="preserve">
          <source>When you decode(=?</source>
          <target state="translated">当你解码(=?</target>
        </trans-unit>
        <trans-unit id="1f9cd5bf8b9a9dc5c6c543459671e6a174da6ded" translate="yes" xml:space="preserve">
          <source>When you decode, &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; is inserted for a malformed character, where</source>
          <target state="translated">解码时，会为格式错误的字符插入 &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="3c3e41e00e97aaa41946f9404604a3e16daeabbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="translated">在&lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;对象上执行$ parser-&amp;gt; get_token时，您可能会得到此类的对象。</target>
        </trans-unit>
        <trans-unit id="8903ce8817b2306a386e9e7bf122e6808d15508e" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="translated">在&lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;上执行$ parser-&amp;gt; get_token时，您可能会得到此类的对象。</target>
        </trans-unit>
        <trans-unit id="c7b2a9b37643890f116ac0184e9ac142f63cbe26" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="translated">在&lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;上执行$ parser-&amp;gt; get_token时，您应该获得Pod :: Simple :: PullParserToken子类的对象。</target>
        </trans-unit>
        <trans-unit id="8f3fe5c47178db8be10e4d3c50152806e0a7dfbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="translated">在&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;对象上执行$ parser-&amp;gt; get_token时，您可能会得到此类的对象。</target>
        </trans-unit>
        <trans-unit id="fdee2ab8e3f283c88595afe8fae4920b1af2e43f" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="translated">在&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;上执行$ parser-&amp;gt; get_token时，您可能会得到此类的对象。</target>
        </trans-unit>
        <trans-unit id="e49f09f58c9d01d7e0d1ab18e02275ef3d85f650" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="translated">在&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;上执行$ parser-&amp;gt; get_token时，您应该获得Pod :: Simple :: PullParserToken子类的对象。</target>
        </trans-unit>
        <trans-unit id="e5d10bb84f2ae2965aec52096372e0823e1ccc9f" translate="yes" xml:space="preserve">
          <source>When you do an open() and specify extra PerlIO layers to be deployed, the layers you specify are &quot;pushed&quot; on top of the already existing default stack. One way to see it is that &quot;operating system is on the left&quot; and &quot;Perl is on the right&quot;.</source>
          <target state="translated">当你进行open()并指定额外的PerlIO层进行部署时,你指定的层会被 &quot;推送 &quot;到已有的默认栈之上。有一种说法是 &quot;操作系统在左边&quot;,&quot;Perl在右边&quot;。</target>
        </trans-unit>
        <trans-unit id="deae100a89ba77dc88cb549c116cc2863e7500d7" translate="yes" xml:space="preserve">
          <source>When you do so, make sure you leave at least &lt;b&gt;U0000&lt;/b&gt; to &lt;b&gt;U0020&lt;/b&gt; as is, unless your environment is EBCDIC.</source>
          <target state="translated">这样做时，除非您的环境是EBCDIC，否则请确保至少&lt;b&gt;保留U0000&lt;/b&gt;到&lt;b&gt;U0020&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="5f9d98bf0fca35661c7810840d0018afb1d2ce55" translate="yes" xml:space="preserve">
          <source>When you do this, you replace ordinary Perl ops with custom ops by creating ops with the type &lt;code&gt;OP_CUSTOM&lt;/code&gt; and the &lt;code&gt;op_ppaddr&lt;/code&gt; of your own PP function. This should be defined in XS code, and should look like the PP ops in &lt;code&gt;pp_*.c&lt;/code&gt;. You are responsible for ensuring that your op takes the appropriate number of values from the stack, and you are responsible for adding stack marks if necessary.</source>
          <target state="translated">执行此操作时，可以通过创建类型为您自己的PP函数的 &lt;code&gt;OP_CUSTOM&lt;/code&gt; 和 &lt;code&gt;op_ppaddr&lt;/code&gt; 的操作，用自定义操作替换普通的Perl操作。这应该在XS代码中定义，并且应该看起来像 &lt;code&gt;pp_*.c&lt;/code&gt; 的PP ops 。您有责任确保您的op从堆栈中获取适当数量的值，并且有责任在必要时添加堆栈标记。</target>
        </trans-unit>
        <trans-unit id="f0737e549db78c3f56b6cebadc591bd894132914" translate="yes" xml:space="preserve">
          <source>When you encode, it just encodes UTF-8 string with</source>
          <target state="translated">当你进行编码时,它只是将UTF-8字符串与</target>
        </trans-unit>
        <trans-unit id="2cb93abd34cd25594e79f391f2b423cc436f1f2e" translate="yes" xml:space="preserve">
          <source>When you execute this script, Perl creates a source stream for the file. Before the parser processes any of the lines from the file, the source stream looks like this:</source>
          <target state="translated">当你执行这个脚本时,Perl会为文件创建一个源流。在解析器处理文件中的任何一行之前,源流看起来是这样的。</target>
        </trans-unit>
        <trans-unit id="c978bab6e05df288a1696970dbd630fd132c029f" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;Data::Dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="translated">当您厌倦了为数据结构编写自定义打印时，可以查看标准的&lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt;或&lt;a href=&quot;Data::Dumper&quot;&gt;Data :: Dumper&lt;/a&gt;模块。前者是Perl调试器使用的东西，而后者则生成可分析的Perl代码。例如：</target>
        </trans-unit>
        <trans-unit id="542d61dee2b7e163e5110ea366ba8573d821b115" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="translated">当您厌倦了为数据结构编写自定义打印时，可以查看标准的&lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt;或&lt;a href=&quot;data/dumper&quot;&gt;Data :: Dumper&lt;/a&gt;模块。前者是Perl调试器使用的东西，而后者则生成可分析的Perl代码。例如：</target>
        </trans-unit>
        <trans-unit id="18b18f51c5b3a1ef29698b4db45e17c63b163a2a" translate="yes" xml:space="preserve">
          <source>When you have Module::Build installed and a module comes with both a Makefile.PL and a Build.PL, which shall have precedence?</source>
          <target state="translated">当您安装了 Module::Build,并且一个模块同时带有 Makefile.PL 和 Build.PL 时,哪个应该优先?</target>
        </trans-unit>
        <trans-unit id="90be52d2f2a07a95a09a611578f9d43f7cd9edea" translate="yes" xml:space="preserve">
          <source>When you have Term::ANSIColor installed, you can turn on colorized output to have some visual differences between normal CPAN.pm output, warnings, debugging output, and the output of the modules being installed. Set your favorite colors after some experimenting with the Term::ANSIColor module.</source>
          <target state="translated">当你安装了Term::ANSIColor后,你可以开启彩色化输出,让正常的CPAN.pm输出、警告、调试输出和正在安装的模块输出有一些视觉上的区别。在对Term::ANSIColor模块进行一些实验后,可以设置自己喜欢的颜色。</target>
        </trans-unit>
        <trans-unit id="805d35dab8fe4274cb0dab9ee72a05d301e431cf" translate="yes" xml:space="preserve">
          <source>When you have a &lt;code&gt;$normalized&lt;/code&gt; string and an &lt;code&gt;$unnormalized&lt;/code&gt; string following it, a simple concatenation is wrong:</source>
          <target state="translated">当您有一个 &lt;code&gt;$normalized&lt;/code&gt; 字符串和紧随其后的 &lt;code&gt;$unnormalized&lt;/code&gt; 字符串时，简单的串联是错误的：</target>
        </trans-unit>
        <trans-unit id="5fc33624ab4cb034a50a1d77e4381e870301d931" translate="yes" xml:space="preserve">
          <source>When you have a duplicate entry, mark either one with '|1' or '|3'.</source>
          <target state="translated">当您有重复的条目时,用&quot;|1 &quot;或&quot;|3 &quot;标记其中一个。</target>
        </trans-unit>
        <trans-unit id="c0776eaeac3f4218a7b8598aad81420ef0246911" translate="yes" xml:space="preserve">
          <source>When you list the arguments to the XSUB in the .xs file, that tells &lt;b&gt;xsubpp&lt;/b&gt; which argument corresponds to which of the argument stack (i.e., the first one listed is the first argument, and so on). You invite disaster if you do not list them in the same order as the function expects them.</source>
          <target state="translated">当您在.xs文件中列出XSUB的参数时，将告诉&lt;b&gt;xsubpp&lt;/b&gt;哪个参数对应于哪个参数堆栈（即，列出的第一个参数是第一个参数，依此类推）。如果您未按函数预期的顺序列出灾难，则会引发灾难。</target>
        </trans-unit>
        <trans-unit id="4fe7c5d2090255d1c2f0cf1a507f4b889f93bbfd" translate="yes" xml:space="preserve">
          <source>When you make a script executable, in order to make it usable as a command, the system will pass switches to perl from the script's #! line. Perl checks that any command line switches given to a setuid (or setgid) script actually match the ones set on the #! line. Some Unix and Unix-like environments impose a one-switch limit on the #! line, so you may need to use something like &lt;code&gt;-wU&lt;/code&gt; instead of &lt;code&gt;-w -U&lt;/code&gt; under such systems. (This issue should arise only in Unix or Unix-like environments that support #! and setuid or setgid scripts.)</source>
          <target state="translated">当使脚本可执行时，为了使其可用作命令，系统将从脚本的＃！将开关传递给perl！线。 Perl检查提供给setuid（或setgid）脚本的任何命令行开关是否确实与＃！上设置的那些匹配！线。某些Unix和类似Unix的环境对＃！施加一键限制。行，因此在这种系统下，可能需要使用 &lt;code&gt;-wU&lt;/code&gt; 之类的东西，而不是 &lt;code&gt;-w -U&lt;/code&gt; 之类的东西。 （仅在支持＃！以及setuid或setgid脚本的Unix或类似Unix的环境中才会出现此问题。）</target>
        </trans-unit>
        <trans-unit id="66b392aea5e0dde426270cd749894810ea22ea80" translate="yes" xml:space="preserve">
          <source>When you obtain a context object it is made specifically for your tool and any tools nested within. If you pass a context around you run the risk of polluting other tools with incorrect context information.</source>
          <target state="translated">当你获得一个上下文对象时,它是专门为你的工具和任何嵌套在其中的工具而制作的。如果你把上下文传递给周围的人,你就有可能用不正确的上下文信息污染其他工具。</target>
        </trans-unit>
        <trans-unit id="b95cff40ad5c3e10b014358530a3857e4311a17f" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;).</source>
          <target state="translated">覆盖内置时，替换项应与内置本机语法保持一致（如果可能）。您可以通过使用合适的原型来实现。要获取可覆盖的内置 &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; ，请使用带有参数 &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; 的prototype函数（请参见&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="403deb8cf132584282b80991028fcc8f4fae8ae6" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;prototype&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;perlfunc#prototype&quot;&gt;&quot;prototype&quot; in perlfunc&lt;/a&gt;).</source>
          <target state="translated">覆盖内置时，替换项应与内置本机语法保持一致（如果可能）。您可以通过使用合适的原型来实现。要获取可覆盖的内置 &lt;code&gt;prototype&lt;/code&gt; ，请使用带有参数 &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; 的原型函数（请参阅&lt;a href=&quot;perlfunc#prototype&quot;&gt;perlfunc中的&amp;ldquo; prototype&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cde2c695557d23e73e52834a17ed471dd59562aa" translate="yes" xml:space="preserve">
          <source>When you replace this variable, it is considered a good practice to store the possibly previously installed hook and that you recall it inside your own.</source>
          <target state="translated">当你更换这个变量时,它被认为是一个很好的做法,存储可能以前安装的钩子,你在你自己的内部调用它。</target>
        </trans-unit>
        <trans-unit id="582bd31e20cc087ebfe2ecd8d499eadfcfa005d7" translate="yes" xml:space="preserve">
          <source>When you run Makefile.PL, it makes a Makefile. That's the whole point of MakeMaker. The Makefile.PL is a simple program which loads ExtUtils::MakeMaker and runs the WriteMakefile() function to generate a Makefile.</source>
          <target state="translated">当你运行Makefile.PL时,它就会生成一个Makefile。这就是MakeMaker的全部意义。Makefile.PL是一个简单的程序,它加载ExtUtils::MakeMaker,并运行WriteMakefile()函数来生成一个Makefile。</target>
        </trans-unit>
        <trans-unit id="b579e440e9d1d7b9d0889bfe36abfaf0be29b72d" translate="yes" xml:space="preserve">
          <source>When you run a Perl script, something else is running the script for you, and that something else may output error messages. The script might emit its own warnings and error messages. Most of the time you cannot tell who said what.</source>
          <target state="translated">当你运行一个Perl脚本时,有其他东西在为你运行这个脚本,而这个其他东西可能会输出错误信息。脚本可能会发出自己的警告和错误信息。大多数时候,你无法判断谁说了什么。</target>
        </trans-unit>
        <trans-unit id="b459c97000689bfb2a9636d9e9707ca71827210e" translate="yes" xml:space="preserve">
          <source>When you run this program, you should get something back that looks like this:</source>
          <target state="translated">当你运行这个程序时,你应该得到类似这样的东西。</target>
        </trans-unit>
        <trans-unit id="a4188abf09b28b37cfb9f20a3ac1868d9c6a543c" translate="yes" xml:space="preserve">
          <source>When you say &quot;make test&quot;, Perl uses the</source>
          <target state="translated">当你说 &quot;make test &quot;时,Perl使用的是</target>
        </trans-unit>
        <trans-unit id="76a6e68fd11c4b70b5a87d525381faf69633be4b" translate="yes" xml:space="preserve">
          <source>When you say &lt;code&gt;make test&lt;/code&gt; it will run with taint mode on.</source>
          <target state="translated">当您说 &lt;code&gt;make test&lt;/code&gt; ，它将在异味模式下运行。</target>
        </trans-unit>
        <trans-unit id="7919c60f354343e7a5369000b965c8d2d0632381" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt; . Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="translated">当您在邮件和网页上看到 &lt;code&gt;charset=gb2312&lt;/code&gt; 时，它们实际上是 &lt;code&gt;euc-cn&lt;/code&gt; 编码。为了解决这个问题， &lt;code&gt;gb2312&lt;/code&gt; 被别名为 &lt;code&gt;euc-cn&lt;/code&gt; 。真正使用时，请使用 &lt;code&gt;gb2312-raw&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c4e1c3fce7decd6f02607f653534397608ae09a" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt;. Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="translated">当您在邮件和网页上看到 &lt;code&gt;charset=gb2312&lt;/code&gt; 时，它们实际上是 &lt;code&gt;euc-cn&lt;/code&gt; 编码。为了解决这个问题， &lt;code&gt;gb2312&lt;/code&gt; 被别名为 &lt;code&gt;euc-cn&lt;/code&gt; 。真正使用时，请使用 &lt;code&gt;gb2312-raw&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17139aebb0fce79faa8dece070270ecb6b39cc8b" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; on mails and web pages, they really mean &quot;cp949&quot; encodings. To fix that, the following aliases are set;</source>
          <target state="translated">当您在邮件和网页上看到 &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; 时，它们实际上是&amp;ldquo; cp949&amp;rdquo;编码。为了解决这个问题，设置了以下别名；</target>
        </trans-unit>
        <trans-unit id="bed16d4ef44043e0ee787c3f181832f24be03ea6" translate="yes" xml:space="preserve">
          <source>When you speak one language and the computer thinks you&amp;rsquo;re speaking another. You&amp;rsquo;ll see odd translations when you send UTF‑8, for instance, but the computer thinks you sent Latin-1, showing all sorts of weird characters instead. The term is written 「文字化け」in Japanese and means &amp;ldquo;character rot&amp;rdquo;, an apt description. Pronounced [&lt;code&gt;modʑibake&lt;/code&gt; ] in standard &lt;b&gt;IPA&lt;/b&gt; phonetics, or approximately &amp;ldquo;moh-jee-bah-keh&amp;rdquo;.</source>
          <target state="translated">当您说一种语言而计算机认为您在说另一种语言时。例如，当您发送UTF-8时，您会看到奇怪的翻译，但是计算机认为您发送了Latin-1，而是显示了各种奇怪的字符。该术语用日语写成&amp;ldquo;文字化け&amp;rdquo;，意思是&amp;ldquo;字符腐烂&amp;rdquo;，是一种恰当的描述。在标准&lt;b&gt;IPA&lt;/b&gt;语音中发音为[ &lt;code&gt;modʑibake&lt;/code&gt; ] ，或近似为&amp;ldquo; moh-jee-bah-keh&amp;rdquo;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7ef09f89e47adf28a99fbbb7052a436221dbcca0" translate="yes" xml:space="preserve">
          <source>When you speak one language and the computer thinks you&amp;rsquo;re speaking another. You&amp;rsquo;ll see odd translations when you send UTF‑8, for instance, but the computer thinks you sent Latin-1, showing all sorts of weird characters instead. The term is written 「文字化け」in Japanese and means &amp;ldquo;character rot&amp;rdquo;, an apt description. Pronounced [&lt;code&gt;modʑibake&lt;/code&gt;] in standard &lt;b&gt;IPA&lt;/b&gt; phonetics, or approximately &amp;ldquo;moh-jee-bah-keh&amp;rdquo;.</source>
          <target state="translated">当您说一种语言而计算机认为您在说另一种语言时。例如，当您发送UTF-8时，您会看到奇怪的翻译，但是计算机认为您发送了Latin-1，而是显示了各种奇怪的字符。该术语用日语写成&amp;ldquo;文字化け&amp;rdquo;，意思是&amp;ldquo;字符腐烂&amp;rdquo;，是一个恰当的描述。在标准&lt;b&gt;IPA&lt;/b&gt;语音中发音为[ &lt;code&gt;modʑibake&lt;/code&gt; ] ，或近似为&amp;ldquo; moh-jee-bah-keh&amp;rdquo;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="665a5769943788c4623d27cfed3bae7f7e133317" translate="yes" xml:space="preserve">
          <source>When you specify arguments to routines in the .xs file, you are really passing three pieces of information for each argument listed. The first piece is the order of that argument relative to the others (first, second, etc). The second is the type of argument, and consists of the type declaration of the argument (e.g., int, char*, etc). The third piece is the calling convention for the argument in the call to the library function.</source>
          <target state="translated">当你在.xs文件中为例程指定参数时,你实际上是为列出的每个参数传递了三条信息。第一条是该参数相对于其他参数的顺序(第一、第二等)。第二条是参数的类型,由参数的类型声明组成(例如,int、char*等)。第三块是该参数在调用库函数时的调用约定。</target>
        </trans-unit>
        <trans-unit id="92bc744ea7824ccea4eeb23e82728fbc4ddab899" translate="yes" xml:space="preserve">
          <source>When you supply a separate display name it becomes possible to run a test more than once; the display name is effectively the alias by which the test is known inside the harness. The harness doesn't care if it runs the same test more than once when each invocation uses a different name.</source>
          <target state="translated">当你提供一个单独的显示名称时,就可以多次运行一个测试;显示名称实际上是测试在线束中的别名。当每次调用使用不同的名称时,线束不会在意是否会多次运行同一个测试。</target>
        </trans-unit>
        <trans-unit id="f5d8e81bcb99e99cbe008b301dbaa4156e030e10" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; to lock the file, &lt;code&gt;Tie::File&lt;/code&gt; assumes that the read cache is no longer trustworthy, because another process might have modified the file since the last time it was read. Therefore, a successful call to &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; discards the contents of the read cache and the internal record offset table.</source>
          <target state="translated">当您使用 &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 锁定文件时， &lt;code&gt;Tie::File&lt;/code&gt; 假定读取缓存不再受信任，因为自上次读取文件以来，另一个进程可能已经修改了该文件。因此，对 &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 的成功调用将丢弃读取缓存和内部记录偏移表的内容。</target>
        </trans-unit>
        <trans-unit id="86d314b9ffee5484e299c428ac086a5864115f83" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;flock&lt;/code&gt; to lock the file, &lt;code&gt;Tie::File&lt;/code&gt; assumes that the read cache is no longer trustworthy, because another process might have modified the file since the last time it was read. Therefore, a successful call to &lt;code&gt;flock&lt;/code&gt; discards the contents of the read cache and the internal record offset table.</source>
          <target state="translated">当您使用 &lt;code&gt;flock&lt;/code&gt; 锁定文件时， &lt;code&gt;Tie::File&lt;/code&gt; 假定读取缓存不再受信任，因为自上次读取文件以来，另一个进程可能已经修改了该文件。因此，对 &lt;code&gt;flock&lt;/code&gt; 的成功调用将丢弃读取缓存和内部记录偏移表的内容。</target>
        </trans-unit>
        <trans-unit id="de1ea55b20ff67d97a482097e7d303cd94b1b34c" translate="yes" xml:space="preserve">
          <source>When you use Perl from C, your C program will--usually--allocate, &quot;run&quot;, and deallocate a</source>
          <target state="translated">当你从C语言中使用Perl时,你的C语言程序通常会分配、&quot;运行 &quot;和重新分配一个</target>
        </trans-unit>
        <trans-unit id="5b4b7e46fe751c099868927c5d1568ad4f11af65" translate="yes" xml:space="preserve">
          <source>When you use the &lt;b&gt;-n&lt;/b&gt; and &lt;b&gt;-p&lt;/b&gt; switches to Perl, &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; work just as they do in &lt;b&gt;awk&lt;/b&gt;, as a degenerate case. Both &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; blocks are run when you use the &lt;b&gt;-c&lt;/b&gt; switch for a compile-only syntax check, although your main code is not.</source>
          <target state="translated">当您使用&lt;b&gt;-n&lt;/b&gt;和&lt;b&gt;-p&lt;/b&gt;切换到Perl时， &lt;code&gt;BEGIN&lt;/code&gt; 和 &lt;code&gt;END&lt;/code&gt; 就像在&lt;b&gt;awk&lt;/b&gt;中一样工作，这是简并的情况。无论 &lt;code&gt;BEGIN&lt;/code&gt; 和 &lt;code&gt;CHECK&lt;/code&gt; 当您使用块运行&lt;b&gt;-c&lt;/b&gt;开关仅编译语法检查，虽然你的主要代码是没有。</target>
        </trans-unit>
        <trans-unit id="6e7c5168dc3e4d09a86a5c07db61ae55b067c306" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or Perl's &lt;b&gt;-w&lt;/b&gt; command-line option, you may see warnings about useless uses of constants or functions in &quot;void context&quot;. Void context just means the value has been discarded, such as a statement containing only &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt;. It still counts as scalar context for functions that care whether or not they're being called in list context.</source>
          <target state="translated">当您使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 编译指示或Perl的&lt;b&gt;-w&lt;/b&gt;命令行选项时，您可能会看到有关在&amp;ldquo;无效上下文&amp;rdquo;中无用的常量或函数使用的警告。无效上下文仅表示该值已被丢弃，例如仅包含 &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; 的语句；或 &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt; 。对于关心是否在列表上下文中调用它们的函数，它仍视为标量上下文。</target>
        </trans-unit>
        <trans-unit id="21a0f043d5bac1b816d417902a549ec51099c064" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;use warnings&lt;/code&gt; pragma or Perl's &lt;b&gt;-w&lt;/b&gt; command-line option, you may see warnings about useless uses of constants or functions in &quot;void context&quot;. Void context just means the value has been discarded, such as a statement containing only &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; or &lt;code&gt;getpwuid(0);&lt;/code&gt;. It still counts as scalar context for functions that care whether or not they're being called in list context.</source>
          <target state="translated">当您使用 &lt;code&gt;use warnings&lt;/code&gt; 编译指示或Perl的&lt;b&gt;-w&lt;/b&gt;命令行选项时，您可能会看到有关在&amp;ldquo;无效上下文&amp;rdquo;中无用的常量或函数使用的警告。无效上下文仅表示该值已被丢弃，例如仅包含 &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; 的语句；或 &lt;code&gt;getpwuid(0);&lt;/code&gt; 。对于关心是否在列表上下文中调用它们的函数，它仍视为标量上下文。</target>
        </trans-unit>
        <trans-unit id="f561cbf428cfa38a570f079c8fe3f1e6c4934924" translate="yes" xml:space="preserve">
          <source>When you want to encode Unicode for mails and web pages, however, do not use UTF-7 unless you are sure your recipients and readers can handle it. Very few MUAs and WWW Browsers support these days (only Mozilla seems to support one). For general cases, use UTF-8 for message body and MIME-Header for header instead.</source>
          <target state="translated">然而,当你想对邮件和网页进行Unicode编码时,不要使用UTF-7,除非你确信你的收件人和读者可以处理它。现在很少有MUA和WWW浏览器支持(似乎只有Mozilla支持)。在一般情况下,使用UTF-8作为邮件主体,MIME-Header作为邮件头。</target>
        </trans-unit>
        <trans-unit id="d1594b9a6f30c884e42aa7810e12c05455ffa364" translate="yes" xml:space="preserve">
          <source>When you want to write to a file, you first have to decide what to do about any existing contents of that file. You have two basic choices here: to preserve or to clobber.</source>
          <target state="translated">当你想写到一个文件时,你首先要决定如何处理该文件的任何现有内容。在这里,你有两个基本选择:保存或删除。</target>
        </trans-unit>
        <trans-unit id="f729e16e6d70d308845c4e263f4f5d66444de2cc" translate="yes" xml:space="preserve">
          <source>When you're done with your filehandles, you should &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; them (though to be honest, Perl will clean up after you if you forget):</source>
          <target state="translated">完成文件句柄后，应将它们 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; （尽管老实说，如果您忘记了，Perl将在您清理之后）：</target>
        </trans-unit>
        <trans-unit id="1488b5ce874430f2891cff85427abec3fe4ed92a" translate="yes" xml:space="preserve">
          <source>When you're done with your filehandles, you should &lt;code&gt;close()&lt;/code&gt; them (though to be honest, Perl will clean up after you if you forget):</source>
          <target state="translated">处理完文件句柄后，应将它们 &lt;code&gt;close()&lt;/code&gt; （尽管老实说，如果您忘记了，Perl将在您清理之后）：</target>
        </trans-unit>
        <trans-unit id="f855bc56e9b2d1a2f4296535cb927b2c13c9dd7d" translate="yes" xml:space="preserve">
          <source>When you're using RETVAL to return an &lt;code&gt;SV *&lt;/code&gt; , there's some magic going on behind the scenes that should be mentioned. When you're manipulating the argument stack using the ST(x) macro, for example, you usually have to pay special attention to reference counts. (For more about reference counts, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.) To make your life easier, the typemap file automatically makes &lt;code&gt;RETVAL&lt;/code&gt; mortal when you're returning an &lt;code&gt;SV *&lt;/code&gt; . Thus, the following two XSUBs are more or less equivalent:</source>
          <target state="translated">当您使用RETVAL返回 &lt;code&gt;SV *&lt;/code&gt; 时，幕后发生了一些不可思议的事情。例如，当您使用ST（x）宏操作参数堆栈时，通常必须特别注意引用计数。（有关参考计数的更多信息，请参见&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;。）为了使您的生活更轻松，当返回 &lt;code&gt;SV *&lt;/code&gt; 时，typemap文件会自动使 &lt;code&gt;RETVAL&lt;/code&gt; 成为凡人。因此，以下两个XSUB或多或少是等效的：</target>
        </trans-unit>
        <trans-unit id="aff47fe5db562b3d2dbc867dc1c147d97de9621a" translate="yes" xml:space="preserve">
          <source>When you're using RETVAL to return an &lt;code&gt;SV *&lt;/code&gt;, there's some magic going on behind the scenes that should be mentioned. When you're manipulating the argument stack using the ST(x) macro, for example, you usually have to pay special attention to reference counts. (For more about reference counts, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.) To make your life easier, the typemap file automatically makes &lt;code&gt;RETVAL&lt;/code&gt; mortal when you're returning an &lt;code&gt;SV *&lt;/code&gt;. Thus, the following two XSUBs are more or less equivalent:</source>
          <target state="translated">当您使用RETVAL返回 &lt;code&gt;SV *&lt;/code&gt; 时，幕后发生了一些不可思议的事情。例如，当您使用ST（x）宏操作参数堆栈时，通常必须特别注意引用计数。（有关参考计数的更多信息，请参见&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;。）为了使您的生活更轻松，当返回 &lt;code&gt;SV *&lt;/code&gt; 时，typemap文件会自动使 &lt;code&gt;RETVAL&lt;/code&gt; 成为凡人。因此，以下两个XSUB或多或少是等效的：</target>
        </trans-unit>
        <trans-unit id="5829efde6fb988f406fa62c8ae4c250e14e41e30" translate="yes" xml:space="preserve">
          <source>When you've found that there isn't a module available for what you're trying to do, and you've had to write the code yourself, consider packaging up the solution into a module and uploading it to CPAN so that others can benefit.</source>
          <target state="translated">当你发现你要做的事情没有可用的模块,而你又不得不自己写代码的时候,可以考虑把解决方案打包成一个模块,然后上传到CPAN上,这样其他人就可以受益了。</target>
        </trans-unit>
        <trans-unit id="6b113771452e06c12bd2750d8700f91d2cc72def" translate="yes" xml:space="preserve">
          <source>When you've got your name sorted out and you're sure that your module is wanted and not currently available, it's time to start coding.</source>
          <target state="translated">当你整理好你的名字,确定你的模块是想要的,而且目前还没有,就可以开始编码了。</target>
        </trans-unit>
        <trans-unit id="baa149e5f728be9fcf5c842fafa04ad779a77d18" translate="yes" xml:space="preserve">
          <source>When your child is done running tests, you must call &lt;code&gt;finalize&lt;/code&gt; to clean up and tell the parent your pass/fail status.</source>
          <target state="translated">当您的孩子完成测试后，您必须致电 &lt;code&gt;finalize&lt;/code&gt; 进行清理，并告诉父母您的通过/失败状态。</target>
        </trans-unit>
        <trans-unit id="701f121f0767fb048f9a1e9cdd7bcb29143a3d18" translate="yes" xml:space="preserve">
          <source>When your module encounters an error it should do one or more of:</source>
          <target state="translated">当你的模块遇到一个错误时,它应该做一个或多个。</target>
        </trans-unit>
        <trans-unit id="7d300f1dcd786450162ec26ef8c71857af330be4" translate="yes" xml:space="preserve">
          <source>When, &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; is enabled, this setting controls whether the permissions on files from the archive are used without modification of if they are filtered by removing any setid bits and applying the current umask.</source>
          <target state="translated">当， &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; 启用，使用是否从存档文件的权限此设置不控制，如果他们删除任何SETID位和运用当前的umask过滤的修改。</target>
        </trans-unit>
        <trans-unit id="c7c9dae84175d878d430d8cca64e61d718171eab" translate="yes" xml:space="preserve">
          <source>When, however, you assign a list of scalars to another list of scalars, the results differ according to whether the left-hand list -- the list being assigned to -- has the same, more or fewer elements than the right-hand list.</source>
          <target state="translated">然而,当你将一个标量列表分配给另一个标量列表时,根据左手列表--被分配到的列表--比右手列表具有相同、更多或更少的元素,结果有所不同。</target>
        </trans-unit>
        <trans-unit id="d830d827614f19bd45afae435d976e89279e08bd" translate="yes" xml:space="preserve">
          <source>Whenever JSON allows whitespace, C++-style one-line comments are additionally allowed. They are terminated by the first carriage-return or line-feed character, after which more white-space and comments are allowed.</source>
          <target state="translated">只要JSON允许留白,还允许使用C++风格的单行注释,它们以第一个回车符或换行符结束。它们以第一个回车或换行字符结束,之后允许更多的空白和注释。</target>
        </trans-unit>
        <trans-unit id="042aae650b0c414ca1cd41812840fd2d72dec204" translate="yes" xml:space="preserve">
          <source>Whenever JSON allows whitespace, C-style multiple-line comments are additionally allowed. Everything between &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt; is a comment, after which more white-space and comments are allowed.</source>
          <target state="translated">每当JSON允许空白时，都会额外允许使用C样式的多行注释。 &lt;code&gt;/*&lt;/code&gt; 和 &lt;code&gt;*/&lt;/code&gt; 之间的所有内容均为注释，之后允许使用更多空格和注释。</target>
        </trans-unit>
        <trans-unit id="99a2ef40caf9ba8f64a09af2f45cf33737585968" translate="yes" xml:space="preserve">
          <source>Whenever JSON allows whitespace, shell-style comments are additionally allowed. They are terminated by the first carriage-return or line-feed character, after which more white-space and comments are allowed.</source>
          <target state="translated">只要JSON允许留白,还允许使用shell风格的注释。它们以第一个回车或换行字符结束,之后允许更多的空白和注释。</target>
        </trans-unit>
        <trans-unit id="cabccb147592c137e487eb001cea479dffb70830" translate="yes" xml:space="preserve">
          <source>Whenever a Berkeley DB function returns data via one of its parameters, the equivalent &lt;b&gt;DB_File&lt;/b&gt; method does exactly the same.</source>
          <target state="translated">每当Berkeley DB函数通过其参数之一返回数据时，等效的&lt;b&gt;DB_File&lt;/b&gt;方法就会执行完全相同的操作。</target>
        </trans-unit>
        <trans-unit id="6a800aba7242513688fb7365bc61881077cd8882" translate="yes" xml:space="preserve">
          <source>Whenever a Perl subroutine is called using one of the</source>
          <target state="translated">每当一个Perl子程序被调用时,使用其中一个</target>
        </trans-unit>
        <trans-unit id="6344d70f52ab5669e0f868bcc4766007019f0e1c" translate="yes" xml:space="preserve">
          <source>Whenever a reference is used as a field hash key, the object registry is checked and a new entry is made if necessary. The field hash is then added to the list of fields this reference has used.</source>
          <target state="translated">每当一个引用被用作字段哈希键时,都会检查对象登记册,必要时还会新建一个条目。然后,该字段哈希将被添加到该参考资料使用过的字段列表中。</target>
        </trans-unit>
        <trans-unit id="ac59cb12b90f854e158e9f7e8d962f434ede4764" translate="yes" xml:space="preserve">
          <source>Whenever control returns from the</source>
          <target state="translated">每当控制权从</target>
        </trans-unit>
        <trans-unit id="56847d63f6da95857482dd3497381b06019beb12" translate="yes" xml:space="preserve">
          <source>Whenever metadata consumers merge prerequisites, either from different phases or from &lt;code&gt;optional_features&lt;/code&gt;, they should merged in a way which preserves the intended semantics of the prerequisite structure. Generally, this means concatenating the version specifications using commas, as described in the &lt;a href=&quot;#Version-Ranges&quot;&gt;&quot;Version Ranges&quot;&lt;/a&gt; section.</source>
          <target state="translated">每当元数据使用者合并来自不同阶段或 &lt;code&gt;optional_features&lt;/code&gt; 的先决条件时，就应以保留先决条件结构的预期语义的方式进行合并。通常，这意味着使用逗号连接版本规范，如&lt;a href=&quot;#Version-Ranges&quot;&gt;&amp;ldquo;版本范围&amp;rdquo;&lt;/a&gt;部分中所述。</target>
        </trans-unit>
        <trans-unit id="58a47aafac8fca0c788807bc11f865583b9a79dd" translate="yes" xml:space="preserve">
          <source>Whenever possible, new features should be prototyped in a CPAN module before they will be considered for the core.</source>
          <target state="translated">在可能的情况下,新功能应该在CPAN模块中进行原型设计,然后再考虑将其纳入核心。</target>
        </trans-unit>
        <trans-unit id="a368a6c064c79ec6ec1d84f92fa7a58354e83dad" translate="yes" xml:space="preserve">
          <source>Whenever this is applied to a string which doesn't quite meet the pattern's expectations such as &lt;code&gt;&quot;abc  &quot;&lt;/code&gt; or &lt;code&gt;&quot;abc  def &quot;&lt;/code&gt; , the regex engine will backtrack, approximately once for each character in the string. But we know that there is no way around taking</source>
          <target state="translated">每当将其应用于不完全满足模式要求的字符串（例如 &lt;code&gt;&quot;abc &quot;&lt;/code&gt; 或 &lt;code&gt;&quot;abc def &quot;&lt;/code&gt; ，正则表达式引擎都会回退，对于字符串中的每个字符大约回溯一次。但是我们知道没有办法</target>
        </trans-unit>
        <trans-unit id="ff79b096fb177b1f29c2b3cfee678fdb53ec5582" translate="yes" xml:space="preserve">
          <source>Whenever this is applied to a string which doesn't quite meet the pattern's expectations such as &lt;code&gt;&quot;abc &quot;&lt;/code&gt; or &lt;code&gt;&quot;abc def &quot;&lt;/code&gt;, the regexp engine will backtrack, approximately once for each character in the string. But we know that there is no way around taking</source>
          <target state="translated">每当将其应用于不完全满足模式要求的字符串（例如 &lt;code&gt;&quot;abc &quot;&lt;/code&gt; 或 &lt;code&gt;&quot;abc def &quot;&lt;/code&gt; ，regexp引擎都会回退，对于字符串中的每个字符大约回溯一次。但是我们知道没有办法采取</target>
        </trans-unit>
        <trans-unit id="1d972aca2274b3be6437814e7f18c3f8fdf56c12" translate="yes" xml:space="preserve">
          <source>Whenever you do I/O on a file in Perl, you do so through what in Perl is called a &lt;b&gt;filehandle&lt;/b&gt;. A filehandle is an internal name for an external file. It is the job of the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; function to make the association between the internal name and the external name, and it is the job of the &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; function to break that association.</source>
          <target state="translated">每当您在Perl中对文件进行I / O时，都需要通过Perl中称为&lt;b&gt;filehandle的方式来进行&lt;/b&gt;。文件句柄是外部文件的内部名称。在内部名称和外部名称之间建立关联是 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 函数的工作，而打破该关联是 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 函数的工作。</target>
        </trans-unit>
        <trans-unit id="2609a2feff469b602ec869a4ded1b4330334544b" translate="yes" xml:space="preserve">
          <source>Whenever you do I/O on a file in Perl, you do so through what in Perl is called a &lt;b&gt;filehandle&lt;/b&gt;. A filehandle is an internal name for an external file. It is the job of the &lt;code&gt;open&lt;/code&gt; function to make the association between the internal name and the external name, and it is the job of the &lt;code&gt;close&lt;/code&gt; function to break that association.</source>
          <target state="translated">每当您在Perl中对文件进行I / O时，都需要通过Perl中称为&lt;b&gt;Filehandle的方式来进行&lt;/b&gt;。文件句柄是外部文件的内部名称。在内部名称和外部名称之间建立关联是 &lt;code&gt;open&lt;/code&gt; 函数的工作，而打破该关联是 &lt;code&gt;close&lt;/code&gt; 函数的工作。</target>
        </trans-unit>
        <trans-unit id="ed7093ca3cc4a3c897e96991516ce1f4f0fcfd4e" translate="yes" xml:space="preserve">
          <source>Whenever you have more than one subprocess, you must be careful that each closes whichever half of any pipes created for interprocess communication it is not using. This is because any child process reading from the pipe and expecting an EOF will never receive it, and therefore never exit. A single process closing a pipe is not enough to close it; the last process with the pipe open must close it for it to read EOF.</source>
          <target state="translated">当你有多个子进程时,你必须注意每个子进程都要关闭为进程间通信而创建的任何一半管道。这是因为任何从管道中读取并期望得到 EOF 的子进程将永远不会收到 EOF,因此永远不会退出。单个进程关闭管道还不足以关闭它;最后一个打开管道的进程必须关闭管道才能读取EOF。</target>
        </trans-unit>
        <trans-unit id="cd1ee0eb738b950d883ab6c08ca29be20ef06df7" translate="yes" xml:space="preserve">
          <source>Whenever you're communicating text with anything that is external to your perl process, like a database, a text file, a socket, or another program. Even if the thing you're communicating with is also written in Perl.</source>
          <target state="translated">每当你和你的 perl 进程外部的任何东西进行文本交流时,比如数据库、文本文件、套接字或其他程序。即使你要与之通信的东西也是用Perl写的。</target>
        </trans-unit>
        <trans-unit id="cc31f890f5831db8c47f9104a5fd72a40a9b958c" translate="yes" xml:space="preserve">
          <source>Whenever your encoded, binary string is used together with a text string, Perl will assume that your binary string was encoded with ISO-8859-1, also known as latin-1. If it wasn't latin-1, then your data is unpleasantly converted. For example, if it was UTF-8, the individual bytes of multibyte characters are seen as separate characters, and then again converted to UTF-8. Such double encoding can be compared to double HTML encoding (&lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ), or double URI encoding (&lt;code&gt;%253E&lt;/code&gt; ).</source>
          <target state="translated">每当将编码的二进制字符串与文本字符串一起使用时，Perl都会假定您的二进制字符串是使用ISO-8859-1（也称为latin-1）编码的。如果不是latin-1，那么您的数据将被令人讨厌地转换。例如，如果它是UTF-8，则将多字节字符的各个字节视为单独的字符，然后再次转换为UTF-8。可以将这种双重编码与双重HTML编码（ &lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ）或双重URI编码（ &lt;code&gt;%253E&lt;/code&gt; ）进行比较。</target>
        </trans-unit>
        <trans-unit id="b8d5a9055801b14712a33d32b68e49a7db91b2d3" translate="yes" xml:space="preserve">
          <source>Whenever your encoded, binary string is used together with a text string, Perl will assume that your binary string was encoded with ISO-8859-1, also known as latin-1. If it wasn't latin-1, then your data is unpleasantly converted. For example, if it was UTF-8, the individual bytes of multibyte characters are seen as separate characters, and then again converted to UTF-8. Such double encoding can be compared to double HTML encoding (&lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt;), or double URI encoding (&lt;code&gt;%253E&lt;/code&gt;).</source>
          <target state="translated">每当将您的编码二进制字符串与文本字符串一起使用时，Perl都会假定您的二进制字符串是使用ISO-8859-1（也称为latin-1）进行编码的。如果不是latin-1，那么您的数据将被令人不愉快地转换。例如，如果它是UTF-8，则将多字节字符的各个字节视为单独的字符，然后再次转换为UTF-8。可以将这种双重编码与双重HTML编码（ &lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ）或双重URI编码（ &lt;code&gt;%253E&lt;/code&gt; ）进行比较。</target>
        </trans-unit>
        <trans-unit id="e1d629f115a3e97bf6ae620fc76d3801dd8ef401" translate="yes" xml:space="preserve">
          <source>Whenever your program accesses data or resources that can be accessed by other threads, you must take steps to coordinate access or risk data inconsistency and race conditions. Note that Perl will protect its internals from your race conditions, but it won't protect you from you.</source>
          <target state="translated">每当你的程序访问可以被其他线程访问的数据或资源时,你必须采取措施协调访问,否则就会有数据不一致和竞赛条件的风险。请注意,Perl会保护其内部免受你的竞赛条件的影响,但它不会保护你。</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="59d37a0123152108bee6e05a64e55d45d68bc028" translate="yes" xml:space="preserve">
          <source>Where $directory_count % 10 is 1 (&quot;%&quot; for modulo, remember), assuming $directory count is an integer, and except where $directory_count % 100 is 11, &quot;directories&quot; is forced to become grammatically singular, which means it gets the ending for the accusative singular... You begin to visualize the code it'd take to test for the problem so far,</source>
          <target state="translated">其中$directory_count % 10是1 (&quot;%&quot;代表模数,记得吗),假设$directory count是一个整数,除了$directory_count % 100是11之外,&quot;directories &quot;被迫成为语法上的单数,这意味着它得到了重音单数的结尾......你开始想象测试这个问题所需要的代码,到目前为止。</target>
        </trans-unit>
        <trans-unit id="fb9b184246f9c47c2085ba5fb400e91c6332924c" translate="yes" xml:space="preserve">
          <source>Where 1 is the position of the first char in the string. Note that position can be 0, or larger than the actual length of the pattern, likewise length can be zero.</source>
          <target state="translated">其中1是字符串中第一个字符的位置。请注意,位置可以是0,也可以大于图案的实际长度,同样,长度也可以是0。</target>
        </trans-unit>
        <trans-unit id="73e22419719a01d34b548da9ec30ecb83ae08c13" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's.</source>
          <target state="translated">其中 &lt;code&gt;$id1&lt;/code&gt; ， &lt;code&gt;$id2&lt;/code&gt; 是两个字节的子字段ID。</target>
        </trans-unit>
        <trans-unit id="b9cb4e493b9dc9b7340611ceb99bc1cecceb2405" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's. The second byte of the ID cannot be 0, unless the &lt;code&gt;Strict&lt;/code&gt; option has been disabled.</source>
          <target state="translated">其中 &lt;code&gt;$id1&lt;/code&gt; ， &lt;code&gt;$id2&lt;/code&gt; 是两个字节的子字段ID。除非已禁用&amp;ldquo; &lt;code&gt;Strict&lt;/code&gt; 选项，否则ID的第二个字节不能为0 。</target>
        </trans-unit>
        <trans-unit id="77383c70462fa701aace92ef9b074251586e9457" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt;, &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's.</source>
          <target state="translated">其中 &lt;code&gt;$id1&lt;/code&gt; ， &lt;code&gt;$id2&lt;/code&gt; 是两个字节的子字段ID。</target>
        </trans-unit>
        <trans-unit id="2a738c1e73fe6ddbf768fa126f517ebb72454b3e" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt;, &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's. The second byte of the ID cannot be 0, unless the &lt;code&gt;Strict&lt;/code&gt; option has been disabled.</source>
          <target state="translated">其中 &lt;code&gt;$id1&lt;/code&gt; ， &lt;code&gt;$id2&lt;/code&gt; 是两个字节的子字段ID。除非已禁用&amp;ldquo; &lt;code&gt;Strict&lt;/code&gt; 选项，否则ID的第二个字节不能为0 。</target>
        </trans-unit>
        <trans-unit id="de8d3be1468ab688b0e6e35d8cea1268cae0caa0" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$r1&lt;/code&gt; can be a reference to any kind of data structure you'd like. It will be deeply copied. Because &lt;code&gt;dclone&lt;/code&gt; takes and returns references, you'd have to add extra punctuation if you had a hash of arrays that you wanted to copy.</source>
          <target state="translated">凡 &lt;code&gt;$r1&lt;/code&gt; 可以是任何类型的数据结构，你想一个参考。它将被深深地复制。因为 &lt;code&gt;dclone&lt;/code&gt; 接受并返回引用，所以如果要复制的数组的哈希值很大，则必须添加额外的标点符号。</target>
        </trans-unit>
        <trans-unit id="29126cbcaebf3032a0f200bdad16fd67b9d2ca9f" translate="yes" xml:space="preserve">
          <source>Where a &lt;b&gt;compiler&lt;/b&gt; remembers symbols. A program like Perl must somehow remember all the names of all the &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;filehandles&lt;/b&gt;, and &lt;b&gt;subroutines&lt;/b&gt; you&amp;rsquo;ve used. It does this by placing the names in a symbol table, which is implemented in Perl using a &lt;b&gt;hash table&lt;/b&gt;. There is a separate symbol table for each &lt;b&gt;package&lt;/b&gt; to give each package its own &lt;b&gt;namespace&lt;/b&gt;.</source>
          <target state="translated">当一个&lt;b&gt;编译器&lt;/b&gt;记住符号。像Perl这样的程序必须以某种方式记住您使用过的所有&lt;b&gt;变量&lt;/b&gt;，&lt;b&gt;文件句柄&lt;/b&gt;和&lt;b&gt;子例程&lt;/b&gt;的所有名称。它通过将名称放在符号表中来实现，该符号表在Perl中使用&lt;b&gt;哈希表实现&lt;/b&gt;。每个&lt;b&gt;包&lt;/b&gt;都有一个单独的符号表，以为每个&lt;b&gt;包&lt;/b&gt;提供自己的&lt;b&gt;名称空间&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="c27a5a0858ef6e994699b8e168fe5635708702fa" translate="yes" xml:space="preserve">
          <source>Where a layer opens or takes ownership of a file descriptor, that layer is responsible for getting the file descriptor's close-on-exec flag into the correct state. The flag should be clear for a file descriptor numbered less than or equal to &lt;code&gt;PL_maxsysfd&lt;/code&gt;, and set for any file descriptor numbered higher. For thread safety, when a layer opens a new file descriptor it should if possible open it with the close-on-exec flag initially set.</source>
          <target state="translated">在层打开或拥有文件描述符所有权的情况下，该层负责使文件描述符的close-on-exec标志进入正确状态。对于编号小于或等于 &lt;code&gt;PL_maxsysfd&lt;/code&gt; 的文件描述符，应清除该标志，并为编号更大的文件描述符设置该标志。为了线程安全，当一个层打开一个新的文件描述符时，如果可能的话，应该在初始设置了close-on-exec标志的情况下打开它。</target>
        </trans-unit>
        <trans-unit id="841b8cfbd59c36bfe89c29e0da6a4675a6abce15" translate="yes" xml:space="preserve">
          <source>Where are modules installed?</source>
          <target state="translated">模块安装在哪里?</target>
        </trans-unit>
        <trans-unit id="77cc20dcc0c42287d0cc6c95ce660feb0b4c5aeb" translate="yes" xml:space="preserve">
          <source>Where can I buy a commercial version of Perl?</source>
          <target state="translated">我在哪里可以买到商业版的Perl?</target>
        </trans-unit>
        <trans-unit id="08cf7f142b0ee15a977fe964d0ddcdb1002739ae" translate="yes" xml:space="preserve">
          <source>Where can I get Perl macros for vi?</source>
          <target state="translated">我在哪里可以得到 vi 的 Perl 宏?</target>
        </trans-unit>
        <trans-unit id="406cbb0495a55956cb84611a8d86c9d721557519" translate="yes" xml:space="preserve">
          <source>Where can I get information on Perl?</source>
          <target state="translated">我在哪里可以获得Perl的信息?</target>
        </trans-unit>
        <trans-unit id="c63d9dfa4f6d6dcfc8103ea7650db10cd8e27fea" translate="yes" xml:space="preserve">
          <source>Where can I get perl-mode or cperl-mode for emacs?</source>
          <target state="translated">我在哪里可以得到 perl-mode 或 cperl-mode for emacs?</target>
        </trans-unit>
        <trans-unit id="b85fdb935a7a614522614b7feed541611e8d0a3e" translate="yes" xml:space="preserve">
          <source>Where can I get the latest libnet release</source>
          <target state="translated">我在哪里可以得到最新的libnet版本</target>
        </trans-unit>
        <trans-unit id="f0f1c9d2159564047b740e7956f5640af04f1e3c" translate="yes" xml:space="preserve">
          <source>Where can I learn about CGI or Web programming in Perl?</source>
          <target state="translated">我在哪里可以学习CGI或Perl中的Web编程?</target>
        </trans-unit>
        <trans-unit id="703366e9bd37f95d6d2b90762995773aff84d67e" translate="yes" xml:space="preserve">
          <source>Where can I learn about linking C with Perl?</source>
          <target state="translated">我在哪里可以学习C语言与Perl的链接?</target>
        </trans-unit>
        <trans-unit id="ed8bfc60bd9d8b7923b8341ed07d83afc289bc35" translate="yes" xml:space="preserve">
          <source>Where can I learn about object-oriented Perl programming?</source>
          <target state="translated">哪里可以学习面向对象的Perl编程?</target>
        </trans-unit>
        <trans-unit id="210221a52d88064b34135e9105ebfd5d49152b00" translate="yes" xml:space="preserve">
          <source>Where can I post questions?</source>
          <target state="translated">我在哪里可以发布问题?</target>
        </trans-unit>
        <trans-unit id="34466094d5547ae836abe0422810851106c8e987" translate="yes" xml:space="preserve">
          <source>Where do I get the include files to do ioctl() or syscall()?</source>
          <target state="translated">我在哪里可以得到做ioctl()或syscall()的包含文件?</target>
        </trans-unit>
        <trans-unit id="ae774b74efc34a0e83321577caf18754079572a2" translate="yes" xml:space="preserve">
          <source>Where do I send bug reports?</source>
          <target state="translated">我在哪里发送错误报告?</target>
        </trans-unit>
        <trans-unit id="566e06889afcd4a7979069c8b0fd2da4dd9ed19e" translate="yes" xml:space="preserve">
          <source>Where file systems interfaces pass file names in and out of the program we also need care. The trend is for operating systems to use a fixed file encoding that don't actually depend on the locale; and this module determines the most appropriate encoding for file names. The &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module will know this encoding under the name &quot;locale_fs&quot;. For traditional Unix systems this will be an alias to the same encoding as &quot;locale&quot;.</source>
          <target state="translated">在文件系统接口将文件名传入和传出程序的地方，我们也需要注意。趋势是操作系统使用实际上不依赖于语言环境的固定文件编码。并且此模块确定最适合文件名的编码。该&lt;a href=&quot;encode&quot;&gt;编码&lt;/a&gt;模块将知道名字&amp;ldquo;locale_fs&amp;rdquo;下这种编码。对于传统的Unix系统，这将是与&amp;ldquo;语言环境&amp;rdquo;相同的编码的别名。</target>
        </trans-unit>
        <trans-unit id="93218aab454721cc4e38fe91ac1668248deeae63" translate="yes" xml:space="preserve">
          <source>Where is the implementation?</source>
          <target state="translated">落实在哪里?</target>
        </trans-unit>
        <trans-unit id="8a78c0649556030e4985847b409471ca9ebd9274" translate="yes" xml:space="preserve">
          <source>Where people get into trouble is here:</source>
          <target state="translated">人们遇到麻烦的地方就在这里。</target>
        </trans-unit>
        <trans-unit id="f616a42d8ce8b58cf95a9bfc5e5383c6c84dc620" translate="yes" xml:space="preserve">
          <source>Where prereqs are concerned, if META_MERGE is used, prerequisites are merged with their counterpart &lt;code&gt;WriteMakefile()&lt;/code&gt; argument (PREREQ_PM is merged into {prereqs}{runtime}{requires}, BUILD_REQUIRES into &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; , CONFIGURE_REQUIRES into &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; , and TEST_REQUIRES into &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; . When prereqs are specified with META_ADD, the only prerequisites added to the file come from the metadata, not &lt;code&gt;WriteMakefile()&lt;/code&gt; arguments.</source>
          <target state="translated">在涉及前提条件的情况下，如果使用META_MERGE，则前提条件将与其对应的 &lt;code&gt;WriteMakefile()&lt;/code&gt; 参数合并（PREREQ_PM并入{prereqs} {runtime} {requires}，BUILD_REQUIRES并入 &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; ，CONFIGURE_REQUIRES并入 &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; ，然后将TEST_REQUIRES放入 &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; 中。当使用META_ADD指定先决条件时，添加到文件的唯一先决条件来自元数据，而不是 &lt;code&gt;WriteMakefile()&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="9262bb4032137f4bd07b4f1a031c40996bf22f95" translate="yes" xml:space="preserve">
          <source>Where prereqs are concerned, if META_MERGE is used, prerequisites are merged with their counterpart &lt;code&gt;WriteMakefile()&lt;/code&gt; argument (PREREQ_PM is merged into {prereqs}{runtime}{requires}, BUILD_REQUIRES into &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt;, CONFIGURE_REQUIRES into &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt;, and TEST_REQUIRES into &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt;. When prereqs are specified with META_ADD, the only prerequisites added to the file come from the metadata, not &lt;code&gt;WriteMakefile()&lt;/code&gt; arguments.</source>
          <target state="translated">在涉及到先决条件的情况下，如果使用META_MERGE，则先决条件将与其对应的 &lt;code&gt;WriteMakefile()&lt;/code&gt; 参数合并（PREREQ_PM合并为{prereqs} {runtime} {requires}，BUILD_REQUIRES合并为 &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; ，CONFIGURE_REQUIRES合并为 &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; ，然后将TEST_REQUIRES放入 &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; 中。当使用META_ADD指定先决条件时，添加到文件的唯一先决条件来自元数据，而不是 &lt;code&gt;WriteMakefile()&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="2578ad2cf7eb4212c4c2f76a99c66a64a699a6f4" translate="yes" xml:space="preserve">
          <source>Where the $way is a value from zero ($theta0, $phi0) to one ($theta1, $phi1). Note that antipodal points (where their distance is</source>
          <target state="translated">其中$way是一个从0($theta0,$phi0)到1($theta1,$phi1)的值。请注意,反极点(其距离为</target>
        </trans-unit>
        <trans-unit id="fd6d6e78410be236f0ee8b2e37126d4a25f62f65" translate="yes" xml:space="preserve">
          <source>Where the 'DSLIP' characters have the following meanings:</source>
          <target state="translated">其中'DSLIP'字符具有以下含义。</target>
        </trans-unit>
        <trans-unit id="843828ced3164063fc4c650d4b6af29aa8f9cb2c" translate="yes" xml:space="preserve">
          <source>Where the two must be separate, initially set the type to &lt;code&gt;CXt_NULL&lt;/code&gt; or &lt;code&gt;CXt_BLOCK&lt;/code&gt;, and later change it to &lt;code&gt;CXt_foo&lt;/code&gt; when doing the &lt;code&gt;cx_pushfoo&lt;/code&gt;. This is exactly what &lt;code&gt;pp_enteriter&lt;/code&gt; does, once it's determined which type of loop it's pushing.</source>
          <target state="translated">两者必须分开的地方，首先将类型设置为 &lt;code&gt;CXt_NULL&lt;/code&gt; 或 &lt;code&gt;CXt_BLOCK&lt;/code&gt; ，然后在执行 &lt;code&gt;CXt_foo&lt;/code&gt; 时将其更改为 &lt;code&gt;cx_pushfoo&lt;/code&gt; 。一旦确定了要推送的循环类型，这正是 &lt;code&gt;pp_enteriter&lt;/code&gt; 所做的。</target>
        </trans-unit>
        <trans-unit id="3a57b05d69f49e2636c91eefc4c6774814129e12" translate="yes" xml:space="preserve">
          <source>Where there is only one operand (or only one operand with overloading) the checks in respect of the other operand above are skipped.</source>
          <target state="translated">如果只有一个操作数(或只有一个操作数有重载),则跳过对上述其他操作数的检查。</target>
        </trans-unit>
        <trans-unit id="293c942f397777e729937e1824d906951d88e087" translate="yes" xml:space="preserve">
          <source>Where these steps occur in the actual execution of a perl program is determined by whether the pattern involves interpolating any string variables. If interpolation occurs, then compilation happens at run time. If it does not, then compilation is performed at compile time. (The &lt;code&gt;/o&lt;/code&gt; modifier changes this, as does &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; to a certain extent.) The engine doesn't really care that much.</source>
          <target state="translated">这些步骤在perl程序的实际执行中发生的位置由模式是否涉及对任何字符串变量进行插值来确定。如果发生插值，则编译将在运行时发生。如果不是，则在编译时执行编译。（ &lt;code&gt;/o&lt;/code&gt; 修饰符在一定程度上改变了它， &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 也是如此。）引擎实际上并不那么在乎。</target>
        </trans-unit>
        <trans-unit id="eb41b8cee1215605643716ae7b75d6423a86bb03" translate="yes" xml:space="preserve">
          <source>Where these steps occur in the actual execution of a perl program is determined by whether the pattern involves interpolating any string variables. If interpolation occurs, then compilation happens at run time. If it does not, then compilation is performed at compile time. (The &lt;code&gt;/o&lt;/code&gt; modifier changes this, as does &lt;code&gt;qr//&lt;/code&gt; to a certain extent.) The engine doesn't really care that much.</source>
          <target state="translated">这些步骤在perl程序的实际执行中发生的位置是由模式是否涉及对任何字符串变量进行插值来确定的。如果发生插值，则编译将在运行时发生。如果不是，则在编译时执行编译。（ &lt;code&gt;/o&lt;/code&gt; 修改器在一定程度上更改了此设置， &lt;code&gt;qr//&lt;/code&gt; 也是如此。）引擎实际上并不那么在乎。</target>
        </trans-unit>
        <trans-unit id="cca423190a1a1c785b9d576f8083e40dd5389585" translate="yes" xml:space="preserve">
          <source>Where to Find the Community</source>
          <target state="translated">哪里可以找到社区</target>
        </trans-unit>
        <trans-unit id="536ef5aba264e8d2aec71ea10430b9efa22dfe0c" translate="yes" xml:space="preserve">
          <source>Where to find the perlfaq</source>
          <target state="translated">在哪里可以找到perlfaq</target>
        </trans-unit>
        <trans-unit id="93683b8b8083dba6e071465301ae1d1c45028dec" translate="yes" xml:space="preserve">
          <source>Where to get this document</source>
          <target state="translated">在哪里可以得到这份文件</target>
        </trans-unit>
        <trans-unit id="4af9617f74f3fb16e775a0d165421fe00441bc1b" translate="yes" xml:space="preserve">
          <source>Where to start?</source>
          <target state="translated">从哪里开始呢?</target>
        </trans-unit>
        <trans-unit id="74e10717c102dd0c9df4c18b5606b9aaf6912d10" translate="yes" xml:space="preserve">
          <source>Where you look to find a pointer to information somewhere else. (See &lt;b&gt;indirection&lt;/b&gt;.) References come in two flavors: &lt;b&gt;symbolic references&lt;/b&gt; and &lt;b&gt;hard references&lt;/b&gt;.</source>
          <target state="translated">您在哪里寻找其他地方的信息指针。（请参阅&lt;b&gt;间接&lt;/b&gt;引用。）引用有两种形式：&lt;b&gt;符号引用&lt;/b&gt;和&lt;b&gt;硬引用&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="500583f76e5e2a57eb1022812ab875f23db70975" translate="yes" xml:space="preserve">
          <source>Where's the catch? Padding is neither required before the first field &lt;code&gt;count&lt;/code&gt; , nor between this and the next field &lt;code&gt;glyph&lt;/code&gt; , so why can't we simply pack like this:</source>
          <target state="translated">渔获物在哪里？在第一个字段 &lt;code&gt;count&lt;/code&gt; 之前，在此字段和下一个字段 &lt;code&gt;glyph&lt;/code&gt; 之间都不需要填充，因此为什么我们不能像这样简单地打包：</target>
        </trans-unit>
        <trans-unit id="2bdd0a720834494322577f4ab7718daee200802f" translate="yes" xml:space="preserve">
          <source>Where's the catch? Padding is neither required before the first field &lt;code&gt;count&lt;/code&gt;, nor between this and the next field &lt;code&gt;glyph&lt;/code&gt;, so why can't we simply pack like this:</source>
          <target state="translated">渔获物在哪里？在第一个字段 &lt;code&gt;count&lt;/code&gt; 之前，在此字段和下一个字段 &lt;code&gt;glyph&lt;/code&gt; 之间都不需要填充，因此为什么我们不能像这样简单地打包：</target>
        </trans-unit>
        <trans-unit id="85ff01499d11ce21062a9b96027ab58ee226aad3" translate="yes" xml:space="preserve">
          <source>Where,</source>
          <target state="translated">Where,</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="4d453f1163fdbba0e62b8cfe55db1c43bd938110" translate="yes" xml:space="preserve">
          <source>Whereas a QP decoder that works on both ASCII and EBCDIC platforms would look somewhat like the following:</source>
          <target state="translated">而一个同时适用于ASCII和EBCDIC平台的QP解码器则有点像下面的样子。</target>
        </trans-unit>
        <trans-unit id="4c1007108b497a2f8b15b3dc9255f03fbd82a20c" translate="yes" xml:space="preserve">
          <source>Whereas here's how a Perl programmer more comfortable with the idiom might do it:</source>
          <target state="translated">而下面是一个Perl程序员对这个成语比较熟悉的做法。</target>
        </trans-unit>
        <trans-unit id="5db7dff8fd1589f3c435af6d45d16e0816b2e9c4" translate="yes" xml:space="preserve">
          <source>Whereas if you comment out the two lines I said you might wish to, then it shows it to you this way instead:</source>
          <target state="translated">而如果你把我说的那两行字注释出来,你可能会希望,那么它反而会这样显示给你。</target>
        </trans-unit>
        <trans-unit id="ab440f8d11b8fd4e9e75cd6104ac553e6f04002a" translate="yes" xml:space="preserve">
          <source>Whereas other perl internal stacks store individual items all of the same type (usually SV pointers or integers), the items pushed to the save stack are formed of many different types, having multiple fields to them. For example, the &lt;code&gt;SAVEt_INT&lt;/code&gt; type needs to store both the address of the &lt;code&gt;int&lt;/code&gt; variable to restore, and the value to restore it to. This information could have been stored using fields of a &lt;code&gt;struct&lt;/code&gt;, but would have to be large enough to store three pointers in the largest case, which would waste a lot of space in most of the smaller cases.</source>
          <target state="translated">其他perl内部堆栈存储的都是相同类型的单个项目（通常是SV指针或整数），而推送到保存堆栈的项目则由许多不同的类型组成，它们具有多个字段。例如， &lt;code&gt;SAVEt_INT&lt;/code&gt; 类型需要存储要还原的 &lt;code&gt;int&lt;/code&gt; 变量的地址和要将其还原到的值。该信息本可以使用 &lt;code&gt;struct&lt;/code&gt; 的字段存储的，但必须足够大以在最大的情况下存储三个指针，这在大多数较小的情况下会浪费很多空间。</target>
        </trans-unit>
        <trans-unit id="aa7a6da1ef7f2699440e362142ae5565af060786" translate="yes" xml:space="preserve">
          <source>Wherever a list of operators can be given you can use one or more opsets. See also Manipulating Opsets below.</source>
          <target state="translated">只要能给出一个运算符列表,就可以使用一个或多个OPSET。请参阅下面的操纵操作集。</target>
        </trans-unit>
        <trans-unit id="c457c17dce216494419135c71949242b8d09d0bb" translate="yes" xml:space="preserve">
          <source>Wherever possible, shareable images are preferred to object libraries, and object libraries to plain object files. In accordance with VMS naming conventions, ext() looks for files named</source>
          <target state="translated">在可能的情况下,可共享的图像优于对象库,对象库优于普通对象文件。按照VMS的命名惯例,ext()会查找名为</target>
        </trans-unit>
        <trans-unit id="a5ce0b5c076605e513279f0c54d153294cc237e9" translate="yes" xml:space="preserve">
          <source>Whether PadnamePV is in UTF-8. Currently, this is always true.</source>
          <target state="translated">PadnamePV是否是UTF-8格式。目前,这个值总是为真。</target>
        </trans-unit>
        <trans-unit id="60f21be64cee3c558562d0924a678b1007587a17" translate="yes" xml:space="preserve">
          <source>Whether PadnamePV is in UTF8. Currently, this is always true.</source>
          <target state="translated">PadnamePV是否是UTF8格式。目前,这个值总是为真。</target>
        </trans-unit>
        <trans-unit id="0971615da14029bdca88814940e8de90b6be5147" translate="yes" xml:space="preserve">
          <source>Whether a &quot;signaling&quot; NaN is in any way different from a &quot;quiet&quot; NaN, depends on the platform. Also note that the payload of the default NaN (no argument to nan()) is not necessarily zero, use &lt;code&gt;setpayload&lt;/code&gt; to explicitly set the payload. On some platforms like the 32-bit x86, (unless using the 80-bit long doubles) the signaling bit is not supported at all.</source>
          <target state="translated">&amp;ldquo;信号&amp;rdquo; NaN是否与&amp;ldquo;安静&amp;rdquo; NaN有所不同，取决于平台。还要注意，默认NaN的有效负载（nan（）的无参数）不一定为零，请使用 &lt;code&gt;setpayload&lt;/code&gt; 显式设置有效负载。在某些平台（例如32位x86）上（除非使用80位长双精度数），根本不支持信令位。</target>
        </trans-unit>
        <trans-unit id="63b3304921bf73755f27746fb53954b4a8c4de93" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is disabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;require_order&lt;/code&gt; is enabled.</source>
          <target state="translated">是否允许命令行参数与选项混合。除非已设置环境变量POSIXLY_CORRECT（在这种情况下启用了 &lt;code&gt;require_order&lt;/code&gt; ），否则默认设置为禁用。</target>
        </trans-unit>
        <trans-unit id="faea90df33f36630a481da4cad34e4c79bf52fc5" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;permute&lt;/code&gt; is disabled. Note that &lt;code&gt;permute&lt;/code&gt; is the opposite of &lt;code&gt;require_order&lt;/code&gt; .</source>
          <target state="translated">是否允许命令行参数与选项混合。除非已设置环境变量POSIXLY_CORRECT，否则将启用默认值，在这种情况下，禁用 &lt;code&gt;permute&lt;/code&gt; 。请注意， &lt;code&gt;permute&lt;/code&gt; 与 &lt;code&gt;require_order&lt;/code&gt; 相反。</target>
        </trans-unit>
        <trans-unit id="7872b2f4a897e4a8ef1ea13c927afbc5f8e9bb5d" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;permute&lt;/code&gt; is disabled. Note that &lt;code&gt;permute&lt;/code&gt; is the opposite of &lt;code&gt;require_order&lt;/code&gt;.</source>
          <target state="translated">是否允许命令行参数与选项混合。除非已设置环境变量POSIXLY_CORRECT，否则将启用默认值，在这种情况下，禁用 &lt;code&gt;permute&lt;/code&gt; 。请注意， &lt;code&gt;permute&lt;/code&gt; 与 &lt;code&gt;require_order&lt;/code&gt; 相反。</target>
        </trans-unit>
        <trans-unit id="457d6cfb1888790c7832bd27b66465f0cdcbd754" translate="yes" xml:space="preserve">
          <source>Whether dtrace accepts -xnolibs. If available we call dtrace -h and dtrace -G with -xnolibs to allow dtrace to run in a jail on FreeBSD.</source>
          <target state="translated">dtrace 是否接受 -xnolibs。如果接受的话,我们调用 dtrace -h 和 dtrace -G 以及 -xnolibs 来允许 dtrace 在 FreeBSD 的 jail 中运行。</target>
        </trans-unit>
        <trans-unit id="bf16a187d3ac8048da2c0a9f49f8874167f5a83b" translate="yes" xml:space="preserve">
          <source>Whether or not the op has been optimized by the peephole optimizer.</source>
          <target state="translated">是否已经通过窥视孔优化器对操作进行了优化。</target>
        </trans-unit>
        <trans-unit id="99e430c2678f913bd7c7b93452d560622af7b626" translate="yes" xml:space="preserve">
          <source>Whether or not the test should output numbers. That is, this if true:</source>
          <target state="translated">测试是否应该输出数字。也就是说,这个如果为真。</target>
        </trans-unit>
        <trans-unit id="5f8067023624d336e348da355a79650c3095a919" translate="yes" xml:space="preserve">
          <source>Whether or not to be verbose about what it is doing -- it will default to $Module::Load::Conditional::VERBOSE</source>
          <target state="translated">是否对它正在做的事情进行详细说明--它将默认为$Module::Load::Conditional::VERBOSE。</target>
        </trans-unit>
        <trans-unit id="835c4d9838e01fba8d1ac35f378ff2857c3bbf2f" translate="yes" xml:space="preserve">
          <source>Whether sorting is stable by default is an accident of implementation that can change (and has changed) between Perl versions. If stability is important, be sure to say so with a</source>
          <target state="translated">排序在默认情况下是否稳定是一个实现的意外,在不同的Perl版本之间可能会发生变化(而且已经发生了变化)。如果稳定性很重要,一定要用一个</target>
        </trans-unit>
        <trans-unit id="a8f7f78ec0e44e67b9396390cd1ee3bcf0e5e14e" translate="yes" xml:space="preserve">
          <source>Whether this entry belongs to an outer pad. Entries for which this is true are often referred to as 'fake'.</source>
          <target state="translated">这个条目是否属于外垫。这种情况的条目通常被称为 &quot;假的&quot;。</target>
        </trans-unit>
        <trans-unit id="6283322d116e1d51f7edcd1ec872a9eed355ceb1" translate="yes" xml:space="preserve">
          <source>Whether this is a &quot;state&quot; variable.</source>
          <target state="translated">这是否是一个 &quot;状态 &quot;变量。</target>
        </trans-unit>
        <trans-unit id="e7034c09da28fdb3d58392534621cc03eebbd14d" translate="yes" xml:space="preserve">
          <source>Whether this is an &quot;our&quot; variable.</source>
          <target state="translated">这是否是一个 &quot;我们的 &quot;变量。</target>
        </trans-unit>
        <trans-unit id="c084cfe6eeb06cc1ff5160c3c990367fe4946569" translate="yes" xml:space="preserve">
          <source>Whether this type of partition is support under Win32.</source>
          <target state="translated">Win32下是否支持这种类型的分区。</target>
        </trans-unit>
        <trans-unit id="8fe93610e6b23e15b98198b34ad48105c383339a" translate="yes" xml:space="preserve">
          <source>Whether to abort printing if debugger signal flag is raised.</source>
          <target state="translated">如果调试器信号标志被激发,是否要中止打印。</target>
        </trans-unit>
        <trans-unit id="2985490d3101108f328098168c5a21b3bc3c5a70" translate="yes" xml:space="preserve">
          <source>Whether to add a table-of-contents at the top of each page (called an index for the sake of tradition).</source>
          <target state="translated">是否在每页顶部增加一个目录(为了传统,称为索引)。</target>
        </trans-unit>
        <trans-unit id="3a911a7e2bce47416920de6f21016acd3029366b" translate="yes" xml:space="preserve">
          <source>Whether to anchor every definition &lt;code&gt;=item&lt;/code&gt; directive. This needs to be enabled if you want to be able to link to specific &lt;code&gt;=item&lt;/code&gt; directives, which are output as &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; elements. Disabled by default.</source>
          <target state="translated">是否锚定每个定义 &lt;code&gt;=item&lt;/code&gt; 指令。如果您希望能够链接到特定的 &lt;code&gt;=item&lt;/code&gt; 指令（以 &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; 元素输出），则需要启用此功能。默认禁用。</target>
        </trans-unit>
        <trans-unit id="626413839d3d50a20deaaad85828e47d347f236c" translate="yes" xml:space="preserve">
          <source>Whether to call these extended grapheme clusters &quot;characters&quot; depends on your point of view. If you are a programmer, you probably would tend towards seeing each element in the sequences as one unit, or &quot;character&quot;. However from the user's point of view, the whole sequence could be seen as one &quot;character&quot; since that's probably what it looks like in the context of the user's language. In this document, we take the programmer's point of view: one &quot;character&quot; is one Unicode code point.</source>
          <target state="translated">是否将这些扩展的字词群称为 &quot;字符&quot;,取决于你的观点。如果你是一个程序员,你可能会倾向于把序列中的每个元素看作一个单元,或者说 &quot;字符&quot;。然而从用户的角度来看,整个序列可以被看作是一个 &quot;字符&quot;,因为在用户语言的上下文中,这可能就是它的样子。在本文档中,我们从程序员的角度出发:一个 &quot;字符 &quot;就是一个Unicode码点。</target>
        </trans-unit>
        <trans-unit id="ee66335b9db0c1d5103deb721dc40777dd212c3c" translate="yes" xml:space="preserve">
          <source>Whether to print chars with high bit set in binary or &quot;as is&quot;.</source>
          <target state="translated">是否打印二进制或 &quot;按原样 &quot;设置的高位字符。</target>
        </trans-unit>
        <trans-unit id="238ca87137bc56748ce05a002a71d9a6db9c7ebe" translate="yes" xml:space="preserve">
          <source>Whether to print contents of globs.</source>
          <target state="translated">是否打印globs的内容。</target>
        </trans-unit>
        <trans-unit id="d3a12643fc63beef0ef6ccef6dae848daa691587" translate="yes" xml:space="preserve">
          <source>Whether to try to find the subroutine name given the reference.</source>
          <target state="translated">是否尝试查找给定引用的子程序名。</target>
        </trans-unit>
        <trans-unit id="bfd0c6dfe7d4e4cba4e02f1a0ab33700dc1c327f" translate="yes" xml:space="preserve">
          <source>Whether to turn every =head1 directive into a link pointing to the top of the page (specifically, the opening body tag).</source>
          <target state="translated">是否将每个=head1指令都变成指向页面顶部的链接(特别是开头的body标签)。</target>
        </trans-unit>
        <trans-unit id="c12251b6a52be9785616abd5b79f50c9699026bb" translate="yes" xml:space="preserve">
          <source>Whether to update this partition information. This field is not used by &lt;code&gt;IOCTL_DISK_GET_PARTITION_INFO&lt;/code&gt;. For &lt;code&gt;IOCTL_DISK_SET_DRIVE_LAYOUT&lt;/code&gt;, you must set this field to a true value for any partitions you wish to have changed, added, or deleted.</source>
          <target state="translated">是否更新此分区信息。 &lt;code&gt;IOCTL_DISK_GET_PARTITION_INFO&lt;/code&gt; 不使用此字段。对于 &lt;code&gt;IOCTL_DISK_SET_DRIVE_LAYOUT&lt;/code&gt; ，对于要更改，添加或删除的所有分区，必须将此字段设置为true值。</target>
        </trans-unit>
        <trans-unit id="d26288162f4ab8ff9ae48923849befc89334a4a3" translate="yes" xml:space="preserve">
          <source>Whether to write the non-overloaded form of the stringify-overloaded objects.</source>
          <target state="translated">是否编写非过载形式的字符串化过载对象。</target>
        </trans-unit>
        <trans-unit id="db40c6156e22d6cc6531821dd75bdcb0d45e3842" translate="yes" xml:space="preserve">
          <source>Whether various library calls are thread-safe is outside the control of Perl. Calls often suffering from not being thread-safe include: &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;, functions fetching user, group and network information (such as &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; and so on), &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt;. In general, calls that depend on some global external state.</source>
          <target state="translated">Perl不能控制各种库调用是否是线程安全的。经常受线程安全影响的调用包括： &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; ，获取用户，组和网络信息的函数（例如 &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; 等等）， &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 。通常，调用取决于某些全局外部状态。</target>
        </trans-unit>
        <trans-unit id="d56e1a6230da252ffdc8d6662ae566d3f6b5ee2f" translate="yes" xml:space="preserve">
          <source>Whether various library calls are thread-safe is outside the control of Perl. Calls often suffering from not being thread-safe include: &lt;code&gt;localtime()&lt;/code&gt;, &lt;code&gt;gmtime()&lt;/code&gt;, functions fetching user, group and network information (such as &lt;code&gt;getgrent()&lt;/code&gt;, &lt;code&gt;gethostent()&lt;/code&gt;, &lt;code&gt;getnetent()&lt;/code&gt; and so on), &lt;code&gt;readdir()&lt;/code&gt;, &lt;code&gt;rand()&lt;/code&gt;, and &lt;code&gt;srand()&lt;/code&gt;. In general, calls that depend on some global external state.</source>
          <target state="translated">各种库调用是否是线程安全的，不在Perl的控制范围之内。经常受线程安全影响的调用包括： &lt;code&gt;localtime()&lt;/code&gt; ， &lt;code&gt;gmtime()&lt;/code&gt; ，获取用户，组和网络信息的函数（例如 &lt;code&gt;getgrent()&lt;/code&gt; ， &lt;code&gt;gethostent()&lt;/code&gt; ， &lt;code&gt;getnetent()&lt;/code&gt; 等）， &lt;code&gt;readdir()&lt;/code&gt; ， &lt;code&gt;rand()&lt;/code&gt; 和 &lt;code&gt;srand()&lt;/code&gt; 。通常，调用取决于某些全局外部状态。</target>
        </trans-unit>
        <trans-unit id="465a32753eace035273aaef17e2c639421b02dff" translate="yes" xml:space="preserve">
          <source>Whether we need to build an object file with the dtrace tool.</source>
          <target state="translated">我们是否需要用dtrace工具建立一个对象文件。</target>
        </trans-unit>
        <trans-unit id="201246e3611962dc1ed1a9edc779811bfcd3278b" translate="yes" xml:space="preserve">
          <source>Whether you are using NIS does not matter. Amazingly enough, the same bug also affects Solaris.</source>
          <target state="translated">你是否使用NIS并不重要。令人惊奇的是,同样的bug也会影响到Solaris。</target>
        </trans-unit>
        <trans-unit id="f8e039fc339d1036f86bd64ce844762f9417fe8b" translate="yes" xml:space="preserve">
          <source>Whether you use &lt;code&gt;perlbug&lt;/code&gt; or send the email manually, please make your Subject line informative. &quot;a bug&quot; is not informative. Neither is &quot;perl crashes&quot; nor is &quot;HELP!!!&quot;. These don't help. A compact description of what's wrong is fine.</source>
          <target state="translated">无论您使用 &lt;code&gt;perlbug&lt;/code&gt; 还是手动发送电子邮件，请使您的主题行内容丰富。 &amp;ldquo;错误&amp;rdquo;不提供信息。 &amp;ldquo; perl崩溃&amp;rdquo;也不是&amp;ldquo;帮助！&amp;rdquo;。这些无济于事。简要描述出什么问题是可以的。</target>
        </trans-unit>
        <trans-unit id="0cde069a15e713b9fe4a9a6b7078fade7daf5170" translate="yes" xml:space="preserve">
          <source>Whew! That is all the rest of the characters and character classes.</source>
          <target state="translated">呼! 剩下的角色和角色类就这些了。</target>
        </trans-unit>
        <trans-unit id="27e5de2ca1964d94a9ea629b708a58094f2d855e" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;Tie::Hash&quot;&gt;Tie::Hash&lt;/a&gt; operation is being performed from the Perl level on &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt;, if any:</source>
          <target state="translated">正在Perl级别上在 &lt;code&gt;%+&lt;/code&gt; 或 &lt;code&gt;%+&lt;/code&gt; 上执行哪个&lt;a href=&quot;Tie::Hash&quot;&gt;Tie :: Hash&lt;/a&gt;操作：</target>
        </trans-unit>
        <trans-unit id="56043e0fa27cef8d93950adbdc599597748f590d" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; operation is being performed from the Perl level on &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt; , if any:</source>
          <target state="translated">正在Perl级别上在 &lt;code&gt;%+&lt;/code&gt; 或 &lt;code&gt;%+&lt;/code&gt; 上执行哪个&lt;a href=&quot;tie/hash&quot;&gt;Tie :: Hash&lt;/a&gt;操作：</target>
        </trans-unit>
        <trans-unit id="babf69836d4addec6f5a5308cb5825c678eb405e" translate="yes" xml:space="preserve">
          <source>Which Perl blogs should I read?</source>
          <target state="translated">我应该看哪些Perl博客?</target>
        </trans-unit>
        <trans-unit id="54a12a94c6d59fab4aeefed76c9781df10879a85" translate="yes" xml:space="preserve">
          <source>Which YAML implementation would you prefer?</source>
          <target state="translated">你更喜欢哪种YAML实现?</target>
        </trans-unit>
        <trans-unit id="88e9358d41b432fbb58126174b7979a4235a746a" translate="yes" xml:space="preserve">
          <source>Which architecture dependent directory?</source>
          <target state="translated">哪个架构依赖目录?</target>
        </trans-unit>
        <trans-unit id="b7506b68ee68fa595a60659e338ae77c9646b01d" translate="yes" xml:space="preserve">
          <source>Which character set modifier is in effect?</source>
          <target state="translated">哪个字符集修改器是有效的?</target>
        </trans-unit>
        <trans-unit id="ee9b43c6b4875ca7c0a8fea57558205fc2e727ab" translate="yes" xml:space="preserve">
          <source>Which commit added the first file to match this regex?</source>
          <target state="translated">哪个提交添加了第一个匹配此regex的文件?</target>
        </trans-unit>
        <trans-unit id="d004402710bbe1f74279bca91591607062854495" translate="yes" xml:space="preserve">
          <source>Which commit caused this example code to break?</source>
          <target state="translated">哪个提交导致了这个示例代码的中断?</target>
        </trans-unit>
        <trans-unit id="dd77891b19f04e8f4749d5465e616c7d548783ec" translate="yes" xml:space="preserve">
          <source>Which commit caused this example code to start working?</source>
          <target state="translated">哪个提交导致这个示例代码开始工作?</target>
        </trans-unit>
        <trans-unit id="e0816de4aeeb375a395f682785a672eb7143a573" translate="yes" xml:space="preserve">
          <source>Which commit removed the last file to match this regex?</source>
          <target state="translated">哪个提交删除了最后一个与此regex匹配的文件?</target>
        </trans-unit>
        <trans-unit id="dc6d9abe75ea380074d1386fb6bc4638c51ca405" translate="yes" xml:space="preserve">
          <source>Which is checked first, &lt;code&gt;nomethod&lt;/code&gt; or &lt;code&gt;fallback&lt;/code&gt; ? If the two operands of an operator are of different types and both overload the operator, which implementation is used? The following are the precedence rules:</source>
          <target state="translated">首先检查哪种方法， &lt;code&gt;nomethod&lt;/code&gt; 或 &lt;code&gt;fallback&lt;/code&gt; ？如果一个运算符的两个操作数是不同类型的并且都使该运算符超载，则使用哪种实现？以下是优先规则：</target>
        </trans-unit>
        <trans-unit id="26892517e1a24be563151c63ed23ba887d7067cd" translate="yes" xml:space="preserve">
          <source>Which is checked first, &lt;code&gt;nomethod&lt;/code&gt; or &lt;code&gt;fallback&lt;/code&gt;? If the two operands of an operator are of different types and both overload the operator, which implementation is used? The following are the precedence rules:</source>
          <target state="translated">首先检查哪种方法， &lt;code&gt;nomethod&lt;/code&gt; 或 &lt;code&gt;fallback&lt;/code&gt; ？如果一个运算符的两个操作数具有不同的类型，并且都使该运算符超载，则使用哪种实现？以下是优先级规则：</target>
        </trans-unit>
        <trans-unit id="2db62588fd2906af96c2fa483b06db407a80424f" translate="yes" xml:space="preserve">
          <source>Which is effectively just:</source>
          <target state="translated">这实际上只是。</target>
        </trans-unit>
        <trans-unit id="b3fbe5ee09cb06684cac7d1a3e427f0dd899daef" translate="yes" xml:space="preserve">
          <source>Which is what we might expect, the match finds the only &lt;code&gt;cat&lt;/code&gt; in the string and locks onto it. Consider, however, this regexp:</source>
          <target state="translated">这可能是我们所期望的，该匹配项在字符串中找到了唯一的 &lt;code&gt;cat&lt;/code&gt; 并将其锁定。但是，请考虑以下正则表达式：</target>
        </trans-unit>
        <trans-unit id="b248b8b60b90917a66aeb94063d05f7d477a94bd" translate="yes" xml:space="preserve">
          <source>Which magazines have Perl content?</source>
          <target state="translated">哪些杂志有Perl内容?</target>
        </trans-unit>
        <trans-unit id="786c2c13e1b48f509ddfa13fe457e7ade1e2d5c4" translate="yes" xml:space="preserve">
          <source>Which makes $richard and $dick the same variable, but leaves @richard and @dick as separate arrays. Tricky, eh?</source>
          <target state="translated">这样一来,$richard和$dick就成了同一个变量,但@richard和@dick就成了单独的数组。棘手吧,嗯?</target>
        </trans-unit>
        <trans-unit id="c62379639a4b05982ed9a5d227696146f851a074" translate="yes" xml:space="preserve">
          <source>Which of the various &lt;code&gt;*OP&lt;/code&gt; structures this op uses. This should be one of the &lt;code&gt;OA_*&lt;/code&gt; constants from</source>
          <target state="translated">该op使用哪种 &lt;code&gt;*OP&lt;/code&gt; 结构。这应该是 &lt;code&gt;OA_*&lt;/code&gt; 常量之一</target>
        </trans-unit>
        <trans-unit id="a891db1882ed2a728a47d9d75117f36a4ff2a006" translate="yes" xml:space="preserve">
          <source>Which of these modifiers is in effect at any given point in a regular expression depends on a fairly complex set of interactions. These have been designed so that in general you don't have to worry about it, but this section gives the gory details. As explained below in &lt;a href=&quot;#Extended-Patterns&quot;&gt;&quot;Extended Patterns&quot;&lt;/a&gt; it is possible to explicitly specify modifiers that apply only to portions of a regular expression. The innermost always has priority over any outer ones, and one applying to the whole expression has priority over any of the default settings that are described in the remainder of this section.</source>
          <target state="translated">这些修饰符中的哪一个在正则表达式的任何给定点有效，取决于一组相当复杂的交互作用。这些功能的设计使您通常不必担心，但是本节提供了详细信息。如下面&lt;a href=&quot;#Extended-Patterns&quot;&gt;&amp;ldquo;扩展模式&amp;rdquo;中所述&lt;/a&gt;，可以显式指定仅适用于正则表达式部分的修饰符。最里面的总是优先于任何外部的，而应用于整个表达式的优先于本节其余部分描述的任何默认设置。</target>
        </trans-unit>
        <trans-unit id="9c28a2fc8be0459fa3248ceb80936f8aba82ccd2" translate="yes" xml:space="preserve">
          <source>Which of these modifiers is in effect at any given point in a regular expression depends on a fairly complex set of interactions. These have been designed so that in general you don't have to worry about it, but this section gives the gory details. As explained below in &lt;a href=&quot;#Extended-Patterns&quot;&gt;Extended Patterns&lt;/a&gt; it is possible to explicitly specify modifiers that apply only to portions of a regular expression. The innermost always has priority over any outer ones, and one applying to the whole expression has priority over any of the default settings that are described in the remainder of this section.</source>
          <target state="translated">这些修饰符中的哪一个在正则表达式的任何给定点有效，取决于一组相当复杂的交互作用。这些功能的设计使您通常不必担心，但是本节提供了详细的信息。如以下&lt;a href=&quot;#Extended-Patterns&quot;&gt;扩展模式中所述&lt;/a&gt;，可以显式指定仅适用于正则表达式部分的修饰符。最里面的总是优先于任何外部的，而应用于整个表达式的优先于本节其余部分描述的任何默认设置。</target>
        </trans-unit>
        <trans-unit id="3d81e570041b9ef8c3716fd625de2184bc9fcbe4" translate="yes" xml:space="preserve">
          <source>Which one you pick depends on which of these expressions better reflects the above specification of comments.</source>
          <target state="translated">你选哪一个,要看这些表达方式中哪一个更能体现上面的注释规范。</target>
        </trans-unit>
        <trans-unit id="79ee8492b912fab00990fc318850246c7ab7a4ba" translate="yes" xml:space="preserve">
          <source>Which perhaps unexpectedly yields:</source>
          <target state="translated">这或许是意外的收获。</target>
        </trans-unit>
        <trans-unit id="05c36e4547159a2f896e1c4c828cfe54c70d84ef" translate="yes" xml:space="preserve">
          <source>Which rules apply are determined as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3F&quot;&gt;&quot;Which character set modifier is in effect?&quot; in perlre&lt;/a&gt;.</source>
          <target state="translated">确定哪些规则适用，如&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3F&quot;&gt;&amp;ldquo;哪个字符集修饰符有效&amp;rdquo;中所述。百分百的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4e550746bad7dcee6b1162b28bf7aedac094cd1e" translate="yes" xml:space="preserve">
          <source>Which rules apply are determined as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符生效&lt;/a&gt;来确定适用哪些规则？在。</target>
        </trans-unit>
        <trans-unit id="b4ea6c1227777eb0d0611636fc0f0ce8660134f3" translate="yes" xml:space="preserve">
          <source>Which substring to check first.</source>
          <target state="translated">先检查哪个子串。</target>
        </trans-unit>
        <trans-unit id="627f14bbed51912496b6fb85cde41b9d90202d10" translate="yes" xml:space="preserve">
          <source>Which tar should I use on Windows?</source>
          <target state="translated">我应该在Windows上使用哪种tar?</target>
        </trans-unit>
        <trans-unit id="2f094ffb275753431ba594c04d0d66a718fa1eda" translate="yes" xml:space="preserve">
          <source>Which text formatter to use. Default is &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt;, or for very old Perl versions &lt;a href=&quot;Pod::PlainText&quot;&gt;Pod::PlainText&lt;/a&gt;. An alternative would be e.g. &lt;a href=&quot;Pod::Text::Termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">使用哪种文本格式化程序。默认值为&lt;a href=&quot;Pod::Text&quot;&gt;Pod :: Text&lt;/a&gt;，或者对于非常旧的Perl版本&lt;a href=&quot;Pod::PlainText&quot;&gt;Pod :: PlainText&lt;/a&gt;。另一种选择是例如&lt;a href=&quot;Pod::Text::Termcap&quot;&gt;Pod :: Text :: Termcap&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b26c1ae972001db5809b34aeb5a2c0bda11feda" translate="yes" xml:space="preserve">
          <source>Which text formatter to use. Default is &lt;a href=&quot;pod/text&quot;&gt;Pod::Text&lt;/a&gt;, or for very old Perl versions &lt;a href=&quot;pod/plaintext&quot;&gt;Pod::PlainText&lt;/a&gt;. An alternative would be e.g. &lt;a href=&quot;pod/text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">使用哪种文本格式化程序。默认值为&lt;a href=&quot;pod/text&quot;&gt;Pod :: Text&lt;/a&gt;，或者对于非常旧的Perl版本&lt;a href=&quot;pod/plaintext&quot;&gt;Pod :: PlainText&lt;/a&gt;。另一种选择是例如&lt;a href=&quot;pod/text/termcap&quot;&gt;Pod :: Text :: Termcap&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b8afbe233aaf49239a07d2a4536a6d9be415fc8" translate="yes" xml:space="preserve">
          <source>Which version of Perl should I use?</source>
          <target state="translated">我应该使用哪个版本的Perl?</target>
        </trans-unit>
        <trans-unit id="ed3642f21edcd8b0db0bc9f8cee4ac46473a253a" translate="yes" xml:space="preserve">
          <source>Which version of perl do I need ?</source>
          <target state="translated">我需要哪个版本的perl?</target>
        </trans-unit>
        <trans-unit id="32a93a6b75c99229f45ca5666bf0720d67cc2e24" translate="yes" xml:space="preserve">
          <source>Which version of perl should I use?</source>
          <target state="translated">我应该使用哪个版本的perl?</target>
        </trans-unit>
        <trans-unit id="7631d79fe8017e212e81e096dcea8cb82517cdbf" translate="yes" xml:space="preserve">
          <source>Which web framework should I use?</source>
          <target state="translated">我应该使用哪个网络框架?</target>
        </trans-unit>
        <trans-unit id="ca95e2a8ef78e8e65dfe2ee661d1738206c25df7" translate="yes" xml:space="preserve">
          <source>Which will create the directory we need, and you can move on to the next step.</source>
          <target state="translated">这将创建我们需要的目录,你可以继续下一步。</target>
        </trans-unit>
        <trans-unit id="1bd7ff93be76f4f655ab909493a6705c72660d9c" translate="yes" xml:space="preserve">
          <source>Which will print</source>
          <target state="translated">这将打印</target>
        </trans-unit>
        <trans-unit id="03d7614f12de55df0b888753d3fa1d0fb28069d7" translate="yes" xml:space="preserve">
          <source>Which would attempt to set breakpoints on lines 4 and 6 immediately after debugger initialization. Note that @DB::typeahead is not a supported interface and is subject to change in future releases.</source>
          <target state="translated">这将试图在调试器初始化后立即在第4行和第6行设置断点。请注意,@DB::typeahead不是一个支持的接口,在未来的版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="c966532947a1e874f5fbb5570050ef3e1254690b" translate="yes" xml:space="preserve">
          <source>Which would generate a format looking something like this:</source>
          <target state="translated">这将产生一个类似于这样的格式。</target>
        </trans-unit>
        <trans-unit id="d885d5ead32cef5d0d07c15652290de0ab57655a" translate="yes" xml:space="preserve">
          <source>Which zip should I use on Windows for '[ndg]make zipdist'?</source>
          <target state="translated">我应该在Windows上使用哪个压缩包进行'[ndg]make zipdist'?</target>
        </trans-unit>
        <trans-unit id="91c0db76a3c1130f40e63caacba5a278833ffb99" translate="yes" xml:space="preserve">
          <source>Which, in the degenerate case of using only ordinary arrays, gives you multidimensional arrays just like C's:</source>
          <target state="translated">其中,在只使用普通数组的退化情况下,可以得到像C语言一样的多维数组。</target>
        </trans-unit>
        <trans-unit id="49233da44986d650dd0c62f9412171689ae74192" translate="yes" xml:space="preserve">
          <source>Whichever version is used, the actual methods are called in the same context (list, scalar, or void) as the original call via &lt;code&gt;EVERY&lt;/code&gt; , and return:</source>
          <target state="translated">无论使用哪种版本，实际方法都将通过 &lt;code&gt;EVERY&lt;/code&gt; 在与原始调用相同的上下文中（列表，标量或void）调用，并返回：</target>
        </trans-unit>
        <trans-unit id="07d57e57f3a8ced4fc446692cf92ed5425c3284f" translate="yes" xml:space="preserve">
          <source>Whichever version is used, the actual methods are called in the same context (list, scalar, or void) as the original call via &lt;code&gt;EVERY&lt;/code&gt;, and return:</source>
          <target state="translated">无论使用哪种版本，实际方法都将通过 &lt;code&gt;EVERY&lt;/code&gt; 在与原始调用相同的上下文（列表，标量或void）中调用，并返回：</target>
        </trans-unit>
        <trans-unit id="fed29deaf6c9f70efd08af26605d88141ad2586b" translate="yes" xml:space="preserve">
          <source>While $FORMAT_TOP_NAME contains the name of the current header format, there is no corresponding mechanism to automatically do the same thing for a footer. Not knowing how big a format is going to be until you evaluate it is one of the major problems. It's on the TODO list.</source>
          <target state="translated">虽然$FORMAT_TOP_NAME包含了当前页眉格式的名称,但没有相应的机制来自动为页脚做同样的事情。在评估之前,不知道一个格式会有多大,这是主要问题之一。这已经在TODO列表中了。</target>
        </trans-unit>
        <trans-unit id="b0cd08c49ca70b961592a79d7ad5531909d37f26" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; provides integer-only arithmetic, there is no analogous mechanism to provide automatic rounding or truncation to a certain number of decimal places. For rounding to a certain number of digits, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; is usually the easiest route. See &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;.</source>
          <target state="translated">尽管 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 提供仅整数运算，但没有类似的机制可提供自动舍入或舍入到一定数量的小数位。对于四舍五入到一定数量的数字， &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; 通常是最简单的方法。参见&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01f836f2c1198b05b58549da2eae8767a49ca6a1" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;STORABLE_freeze&lt;/code&gt; and &lt;code&gt;STORABLE_thaw&lt;/code&gt; are useful for classes where each instance is independent, this mechanism has difficulty (or is incompatible) with objects that exist as common process-level or system-level resources, such as singleton objects, database pools, caches or memoized objects.</source>
          <target state="translated">尽管 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 和 &lt;code&gt;STORABLE_thaw&lt;/code&gt; 对于每个实例都是独立的类很有用，但该机制很难（或不兼容）与作为公共流程级或系统级资源存在的对象（例如单例对象，数据库池，缓存或已记录对象）一起使用（或不兼容） 。</target>
        </trans-unit>
        <trans-unit id="d9b242bc936842344ffd618aab5876b2850c2c1b" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;connect&lt;/code&gt; returns false, the value of &lt;code&gt;$!&lt;/code&gt; indicates whether it should be tried again (by being set to the value &lt;code&gt;EINPROGRESS&lt;/code&gt;, or &lt;code&gt;EWOULDBLOCK&lt;/code&gt; on MSWin32), or whether a permanent error has occurred (e.g. &lt;code&gt;ECONNREFUSED&lt;/code&gt;).</source>
          <target state="translated">当 &lt;code&gt;connect&lt;/code&gt; 返回false时， &lt;code&gt;$!&lt;/code&gt; 的值！指示是否应该再次尝试（通过将其设置为值 &lt;code&gt;EINPROGRESS&lt;/code&gt; 或 &lt;code&gt;EWOULDBLOCK&lt;/code&gt; 上的EWOULDBLOCK），或者是否已发生永久错误（例如 &lt;code&gt;ECONNREFUSED&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b9a9af13c711e35bbea687932bfa0e243bef5296" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;s///&lt;/code&gt; accepts the &lt;code&gt;/c&lt;/code&gt; flag, it has no effect beyond producing a warning if warnings are enabled.</source>
          <target state="translated">尽管 &lt;code&gt;s///&lt;/code&gt; 接受 &lt;code&gt;/c&lt;/code&gt; 标志，但如果启用了警告，则除了产生警告外没有其他作用。</target>
        </trans-unit>
        <trans-unit id="b8eb5c19a610d348554e2fa519e5457ab307a063" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;use integer&lt;/code&gt; provides integer-only arithmetic, there is no analogous mechanism to provide automatic rounding or truncation to a certain number of decimal places. For rounding to a certain number of digits, &lt;code&gt;sprintf()&lt;/code&gt; or &lt;code&gt;printf()&lt;/code&gt; is usually the easiest route. See &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;.</source>
          <target state="translated">尽管 &lt;code&gt;use integer&lt;/code&gt; 提供仅整数运算，但是没有类似的机制可以提供自动舍入或舍入到一定数量的小数位。对于四舍五入到一定位数， &lt;code&gt;sprintf()&lt;/code&gt; 或 &lt;code&gt;printf()&lt;/code&gt; 通常是最简单的方法。参见&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a400d769e405e7503768315d8de6e5c08fa4438" translate="yes" xml:space="preserve">
          <source>While B::Deparse goes to some lengths to try to figure out what your original program was doing, some parts of the language can still trip it up; it still fails even on some parts of Perl's own test suite. If you encounter a failure other than the most common ones described in the BUGS section below, you can help contribute to B::Deparse's ongoing development by submitting a bug report with a small example.</source>
          <target state="translated">虽然 B::Deparse 会花一些力气去弄清楚你的原始程序在做什么,但语言的某些部分还是会让它绊倒;甚至在 Perl 自己的测试套件的某些部分也会失败。如果你遇到了下面 BUGS 部分所描述的最常见的故障以外的故障,你可以通过提交一个小例子的 bug 报告来帮助 B::Deparse 的持续发展。</target>
        </trans-unit>
        <trans-unit id="1fb4e05a5830c846a9dc5981bceec998799ac3ed" translate="yes" xml:space="preserve">
          <source>While BigInt has extensive handling of inf and NaN, certain quirks remain.</source>
          <target state="translated">虽然BigInt对inf和NaN有广泛的处理,但仍然存在某些怪癖。</target>
        </trans-unit>
        <trans-unit id="fd702ed1f93515e973caeb556144e84284909d1e" translate="yes" xml:space="preserve">
          <source>While C guarantees the ordering specified in the struct definition, between different platforms the definitions might differ</source>
          <target state="translated">虽然C语言保证了结构定义中指定的排序,但不同平台之间的定义可能有所不同</target>
        </trans-unit>
        <trans-unit id="cc4691f27fe5f793a7b1a252b87e1f8adf7ae71b" translate="yes" xml:space="preserve">
          <source>While Dan Kogai retains the copyright as a maintainer, credit should go to all those involved. See AUTHORS for a list of those who submitted code to the project.</source>
          <target state="translated">虽然Dan Kogai作为维护者保留了版权,但所有参与的人都应该得到荣誉。请参阅AUTHORS以了解提交项目代码的人员名单。</target>
        </trans-unit>
        <trans-unit id="5c4e91143f9c9ac2ab71808110a8709426a9bc1f" translate="yes" xml:space="preserve">
          <source>While Google doesn't provide a native toolchain for Android, you can still get one from the Play Store.</source>
          <target state="translated">虽然谷歌并没有为Android提供原生工具链,但你仍然可以从Play Store中获得一个工具链。</target>
        </trans-unit>
        <trans-unit id="c1a13f1442da82f36b90f68d9debc0cec8f1fff2" translate="yes" xml:space="preserve">
          <source>While Math::BigInt has extensive handling of inf and NaN, certain quirks remain.</source>
          <target state="translated">虽然Math::BigInt对inf和NaN有广泛的处理,但仍然存在某些怪癖。</target>
        </trans-unit>
        <trans-unit id="e79628255662d7502ebd0e9fa4c3c1aca53d77c4" translate="yes" xml:space="preserve">
          <source>While Perl attempts to keep the vaxc$errno value to be current, if errno is not EVMSERR, it may not be from the current operation.</source>
          <target state="translated">当Perl试图保持vaxc$errno的值为当前值时,如果errno不是EVMSERR,它可能不是来自当前的操作。</target>
        </trans-unit>
        <trans-unit id="82ff355555ab6d2ce0a2840754c6edfffe9b0329" translate="yes" xml:space="preserve">
          <source>While Perl passes arguments to functions by reference, C passes arguments by value; to implement a C function which modifies data of one of the &quot;arguments&quot;, the actual argument of this C function would be a pointer to the data. Thus two C functions with declarations</source>
          <target state="translated">Perl通过引用向函数传递参数,而C语言则通过值传递参数;要实现一个修改其中一个 &quot;参数 &quot;数据的C函数,这个C函数的实际参数将是一个指向数据的指针。因此,两个C函数的声明是</target>
        </trans-unit>
        <trans-unit id="c23f9c83568988309005d4ebe9f3a7a4c7b974ed" translate="yes" xml:space="preserve">
          <source>While System V IPC isn't so widely used as sockets, it still has some interesting uses. However, you cannot use SysV IPC or Berkeley mmap() to have a variable shared amongst several processes. That's because Perl would reallocate your string when you weren't wanting it to. You might look into the &lt;code&gt;IPC::Shareable&lt;/code&gt; or &lt;code&gt;threads::shared&lt;/code&gt; modules for that.</source>
          <target state="translated">尽管System V IPC并未像套接字那样被广泛使用，但它仍有一些有趣的用途。但是，您不能使用SysV IPC或Berkeley mmap（）在多个进程之间共享变量。那是因为Perl会在您不想要的时候重新分配您的字符串。您可以考虑使用 &lt;code&gt;IPC::Shareable&lt;/code&gt; 或 &lt;code&gt;threads::shared&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="95ba383e6ad59d1d5877dab883127e0598dee045" translate="yes" xml:space="preserve">
          <source>While a nice extension, it's not portable. The Perl code does admittedly use them if available to gain some extra speed (essentially as a funky form of inlining), but you shouldn't.</source>
          <target state="translated">虽然是个不错的扩展,但它并不便携。Perl 代码确实会在可用的情况下使用它们来获得一些额外的速度(本质上是一种时髦的内联形式),但你不应该这样做。</target>
        </trans-unit>
        <trans-unit id="98ac33662fa3d3f638b9cfcc69effe66a6af5d40" translate="yes" xml:space="preserve">
          <source>While a search is in progress, the progress object's &lt;code&gt;reach&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; methods are called like this:</source>
          <target state="translated">在搜索过程中，进度对象的 &lt;code&gt;reach&lt;/code&gt; 和 &lt;code&gt;done&lt;/code&gt; 方法按如下方式调用：</target>
        </trans-unit>
        <trans-unit id="5af2731519a4e72226e3efaa5ed68cb8f21ac8fa" translate="yes" xml:space="preserve">
          <source>While apparently a whole nuther program,</source>
          <target state="translated">虽然显然是一个全新的程序。</target>
        </trans-unit>
        <trans-unit id="2192d44f9e946df5ee1f8628bb7cf84591b693e7" translate="yes" xml:space="preserve">
          <source>While building Perl some changes may be necessary to your Cygwin setup so that Perl builds cleanly. These changes are &lt;b&gt;not&lt;/b&gt; required for normal Perl usage.</source>
          <target state="translated">在构建Perl时，您的Cygwin设置可能需要进行一些更改，以便Perl能够干净地构建。这些变化&lt;b&gt;并不&lt;/b&gt;需要正常的Perl使用。</target>
        </trans-unit>
        <trans-unit id="917e67f81e56107e856d601af96f9ace961e9a9a" translate="yes" xml:space="preserve">
          <source>While checking, this module collects document properties, e.g. the nodes for hyperlinks (&lt;code&gt;=headX&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; ) and index entries (&lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ). POD translators can use this feature to syntax-check and get the nodes in a first pass before actually starting to convert. This is expensive in terms of execution time, but allows for very robust conversions.</source>
          <target state="translated">在检查时，此模块收集文档属性，例如，超链接（ &lt;code&gt;=headX&lt;/code&gt; ， &lt;code&gt;=item&lt;/code&gt; ）和索引条目（ &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ）的节点。POD转换程序可以使用此功能进行语法检查并在实际开始转换之前的第一遍中获取节点。就执行时间而言，这是昂贵的，但是允许非常可靠的转换。</target>
        </trans-unit>
        <trans-unit id="0b363ec28aa87cd5d2d84a791b40d48ed17d175f" translate="yes" xml:space="preserve">
          <source>While checking, this module collects document properties, e.g. the nodes for hyperlinks (&lt;code&gt;=headX&lt;/code&gt;, &lt;code&gt;=item&lt;/code&gt;) and index entries (&lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt;). POD translators can use this feature to syntax-check and get the nodes in a first pass before actually starting to convert. This is expensive in terms of execution time, but allows for very robust conversions.</source>
          <target state="translated">在检查时，此模块收集文档属性，例如，超链接（ &lt;code&gt;=headX&lt;/code&gt; ， &lt;code&gt;=item&lt;/code&gt; ）和索引条目（ &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ）的节点。POD转换器可以使用此功能进行语法检查，并在实际开始转换之前的第一遍中获取节点。就执行时间而言，这是昂贵的，但允许非常可靠的转换。</target>
        </trans-unit>
        <trans-unit id="ba738010d28065fd95a055094f45e1d958083828" translate="yes" xml:space="preserve">
          <source>While civility is required, kindness is encouraged; if you have any doubt about whether you are being civil, simply ask yourself, &quot;Am I being kind?&quot; and aspire to that.</source>
          <target state="translated">虽然需要文明,但鼓励善良,如果你对自己是否文明有任何怀疑,只需问自己:&quot;我是否善良?&quot;并向往。</target>
        </trans-unit>
        <trans-unit id="c337ad00b019970748effb87047bdf42ffb16bea" translate="yes" xml:space="preserve">
          <source>While experts may argue about these idioms, a novice to Perl guts may prefer a way which is as little Perl-guts-specific as possible, meaning automatic conversion and automatic call generation, as in &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;&quot;Getting the fat out of XSUBs&quot;&lt;/a&gt;. This approach has the additional benefit of protecting the XSUB writer from future changes to the Perl API.</source>
          <target state="translated">尽管专家可能会争论这些习惯用法，但是Perl胆量的新手可能更喜欢Perl胆量特定的方式，这意味着&amp;ldquo;自动转换和自动生成呼叫&amp;rdquo;，如&lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;&amp;ldquo;从XSUBs中脱颖而出&amp;rdquo;&lt;/a&gt;。这种方法的另一个好处是可以保护XSUB编写器免于将来对Perl API的更改。</target>
        </trans-unit>
        <trans-unit id="6234d5fa2f6fac6ddbcf991bea921371b64250cc" translate="yes" xml:space="preserve">
          <source>While experts may argue about these idioms, a novice to Perl guts may prefer a way which is as little Perl-guts-specific as possible, meaning automatic conversion and automatic call generation, as in &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt;. This approach has the additional benefit of protecting the XSUB writer from future changes to the Perl API.</source>
          <target state="translated">尽管专家可能会争论这些习惯用法，但是Perl胆量的新手可能更喜欢一种Perl胆量特定的方式，这意味着自动转换和自动调用生成，就像&lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;从XSUBs中脱颖而出&lt;/a&gt;。这种方法的另一个好处是可以保护XSUB编写器免受将来对Perl API的更改。</target>
        </trans-unit>
        <trans-unit id="601070e02f682375d5e25990b39de3389f3b8c49" translate="yes" xml:space="preserve">
          <source>While in principle the &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; operator could be implemented via (and with the same rather severe limitations as) the CRTL &lt;code&gt;vfork()&lt;/code&gt; routine, and while some internal support to do just that is in place, the implementation has never been completed, making &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; currently unavailable. A true kernel &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; is expected in a future version of VMS, and the pseudo-fork based on interpreter threads may be available in a future version of Perl on VMS (see &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;). In the meantime, use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, backticks, or piped filehandles to create subprocesses.</source>
          <target state="translated">虽然原则上可以通过CRTL &lt;code&gt;vfork()&lt;/code&gt; 例程（并具有与之相同的相当严格的限制）来实现 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 运算符，并且尽管已有一些内部支持来实现此目的，但该实现尚未完成，使得 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 目前不可用。期望在VMS的未来版本中使用真正的 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 内核，并且在VMS的Perl的未来版本中可以使用基于解释器线程的伪叉（请参见&lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;）。同时，使用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ，反引号或管道文件句柄创建子进程。</target>
        </trans-unit>
        <trans-unit id="99369babd08034c16995edf0279e157f7f0775da" translate="yes" xml:space="preserve">
          <source>While in principle the &lt;code&gt;fork&lt;/code&gt; operator could be implemented via (and with the same rather severe limitations as) the CRTL &lt;code&gt;vfork()&lt;/code&gt; routine, and while some internal support to do just that is in place, the implementation has never been completed, making &lt;code&gt;fork&lt;/code&gt; currently unavailable. A true kernel &lt;code&gt;fork()&lt;/code&gt; is expected in a future version of VMS, and the pseudo-fork based on interpreter threads may be available in a future version of Perl on VMS (see &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;). In the meantime, use &lt;code&gt;system&lt;/code&gt;, backticks, or piped filehandles to create subprocesses.</source>
          <target state="translated">虽然原则上可以通过CRTL &lt;code&gt;vfork()&lt;/code&gt; 例程（并具有与之相同的相当严格的限制）来实现 &lt;code&gt;fork&lt;/code&gt; 运算符，并且尽管已有一些内部支持来实现此目的，但该实现仍未完成，使得 &lt;code&gt;fork&lt;/code&gt; 目前不可用。在VMS的未来版本中，期望有一个真正的内核 &lt;code&gt;fork()&lt;/code&gt; ，而在VMS的Perl的未来版本中，可以使用基于解释器线程的伪叉（请参见&lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;）。同时，使用 &lt;code&gt;system&lt;/code&gt; ，反引号或管道文件句柄创建子进程。</target>
        </trans-unit>
        <trans-unit id="a11b15d87bb1f9501075e6254f16292a57b123f0" translate="yes" xml:space="preserve">
          <source>While in this mode, Perl takes special precautions called</source>
          <target state="translated">在这种模式下,Perl会采取特殊的预防措施,称为</target>
        </trans-unit>
        <trans-unit id="177c27cbc619ded10f5ed086056984752bc53bbb" translate="yes" xml:space="preserve">
          <source>While it is common to see these two macros in pairs within an &lt;code&gt;ENTER&lt;/code&gt;/ &lt;code&gt;LEAVE&lt;/code&gt; pair, it is not necessary to match them. It is permitted to invoke &lt;code&gt;FREETMPS&lt;/code&gt; multiple times since the most recent &lt;code&gt;SAVETMPS&lt;/code&gt;; for example in a loop iterating over elements of a list. While you can invoke &lt;code&gt;SAVETMPS&lt;/code&gt; multiple times within a scope pair, it is unlikely to be useful. Subsequent invocations will move the temporaries floor further up, thus effectively trapping the existing temporaries to only be released at the end of the scope.</source>
          <target state="translated">虽然通常在 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 对中看到这两个宏是成对的，但没有必要将它们匹配。它允许调用 &lt;code&gt;FREETMPS&lt;/code&gt; 因为最近多次 &lt;code&gt;SAVETMPS&lt;/code&gt; ;例如在循环访问列表元素的循环中。尽管您可以在作用域对中多次调用 &lt;code&gt;SAVETMPS&lt;/code&gt; ，但这不太有用。随后的调用将使临时层进一步向上移动，从而有效地限制了现有的临时层，使其仅在作用域末端释放。</target>
        </trans-unit>
        <trans-unit id="7c260f0d64ec7ed3061fae8a4547b586a55f37c5" translate="yes" xml:space="preserve">
          <source>While it is permissible to &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; a FileCache managed file, do not do so if you are calling &lt;code&gt;FileCache::cacheout&lt;/code&gt; from a package other than which it was imported, or with another module which overrides &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;. If you must, use &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; .</source>
          <target state="translated">虽然可以 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; FileCache托管文件，但是如果您从导入的包之外的包或另一个覆盖 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 的模块中调用 &lt;code&gt;FileCache::cacheout&lt;/code&gt; ，则不要这样做。如果必须，请使用 &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b707b74369a586a0cf2d7bbc0374b51314db5a7" translate="yes" xml:space="preserve">
          <source>While it is permissible to &lt;code&gt;close&lt;/code&gt; a FileCache managed file, do not do so if you are calling &lt;code&gt;FileCache::cacheout&lt;/code&gt; from a package other than which it was imported, or with another module which overrides &lt;code&gt;close&lt;/code&gt;. If you must, use &lt;code&gt;FileCache::cacheout_close&lt;/code&gt;.</source>
          <target state="translated">虽然可以 &lt;code&gt;close&lt;/code&gt; FileCache托管文件，但是如果您从导入的包以外的包或另一个覆盖 &lt;code&gt;close&lt;/code&gt; 的模块中调用 &lt;code&gt;FileCache::cacheout&lt;/code&gt; ，则不要这样做。如果必须，请使用 &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41a78b4c64649b65dd4cad30d6943b6a01e662f0" translate="yes" xml:space="preserve">
          <source>While it would be nice to make this the default behavior, that would almost certainly break a lot of code, so you must explicitly import these subs and use them instead of the default &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt;.</source>
          <target state="translated">虽然最好将其设置为默认行为，但这几乎肯定会破坏很多代码，因此您必须显式导入这些子并使用它们，而不是默认的 &lt;code&gt;timelocal()&lt;/code&gt; 和 &lt;code&gt;timegm()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="959732eaecdd2fded6d5f4730815e7ecfbb3c6a3" translate="yes" xml:space="preserve">
          <source>While it's not necessary for documentation changes, new tests or trivial patches, it's often worth explaining how your change works. Even if it's clear to you today, it may not be clear to a porter next month or next year.</source>
          <target state="translated">虽然对于文档变更、新的测试或琐碎的补丁来说没有必要,但通常值得解释一下你的变更是如何工作的。即使你今天很清楚,但下个月或明年的搬运工可能就不清楚了。</target>
        </trans-unit>
        <trans-unit id="44568ef65eee77bd20a0348b5e9b725eb8d8f779" translate="yes" xml:space="preserve">
          <source>While it's possible to refer directly to these hash keys outside of the class, it's considered a best practice to wrap all access to the attribute with accessor methods.</source>
          <target state="translated">虽然可以在类外直接引用这些哈希键,但最好的做法是将所有对属性的访问都用访问器方法包起来。</target>
        </trans-unit>
        <trans-unit id="d0849418f5c8269f5aff84704c4d9acb674dcdcc" translate="yes" xml:space="preserve">
          <source>While it's true that Perl's regular expressions resemble the DFAs (deterministic finite automata) of the egrep(1) program, they are in fact implemented as NFAs (non-deterministic finite automata) to allow backtracking and backreferencing. And they aren't POSIX-style either, because those guarantee worst-case behavior for all cases. (It seems that some people prefer guarantees of consistency, even when what's guaranteed is slowness.) See the book &quot;Mastering Regular Expressions&quot; (from O'Reilly) by Jeffrey Friedl for all the details you could ever hope to know on these matters (a full citation appears in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;).</source>
          <target state="translated">虽然Perl的正则表达式确实确实类似于egrep（1）程序的DFA（确定性有限自动机），但实际上它们已实现为NFA（非确定性有限自动机）以允许回溯和反向引用。而且它们也不是POSIX风格的，因为它们保证了所有情况下的最坏情况。 （似乎有些人更喜欢一致性的保证，即使保证的是缓慢性。）请参阅Jeffrey Friedl的书&amp;ldquo; Mastering Regular Expressions&amp;rdquo;（来自O'Reilly），以获取您希望在这些问题上知道的所有详细信息（完整的引文出现在&lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2中&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3329779b59b299850e8b68832610b0b339dc0b1f" translate="yes" xml:space="preserve">
          <source>While it's true that this documentation is somewhat subserious, if you use a program named</source>
          <target state="translated">虽然这个文档确实有些子虚乌有,但如果你使用一个名为</target>
        </trans-unit>
        <trans-unit id="10a36fcf99a8e338089d469f203ab0168ce94e49" translate="yes" xml:space="preserve">
          <source>While literal lists and named arrays are often interchangeable, that's not the case for hashes. Just because you can subscript a list value like a normal array does not mean that you can subscript a list value as a hash. Likewise, hashes included as parts of other lists (including parameters lists and return lists from functions) always flatten out into key/value pairs. That's why it's good to use references sometimes.</source>
          <target state="translated">虽然字面列表和命名数组通常是可以互换的,但哈希的情况并非如此。仅仅因为你可以像普通数组一样下标一个列表值,并不意味着你可以将一个列表值下标为哈希。同样,作为其他列表(包括参数列表和函数的返回列表)的一部分的哈希值总是扁平化为键/值对。这就是为什么有时使用引用是好的。</target>
        </trans-unit>
        <trans-unit id="eca6e56d146060aa14a3a670fa7ed2185164c9b5" translate="yes" xml:space="preserve">
          <source>While most important values in this file</source>
          <target state="translated">虽然这个文件中最重要的值</target>
        </trans-unit>
        <trans-unit id="8f9b053b8a7e4dedb3bcc2addb9bbd5ef56b5365" translate="yes" xml:space="preserve">
          <source>While no_index tells you what must be ignored when indexing, this spec holds no opinion on how you should get your initial candidate list of things to possibly index. For &quot;normal&quot; distributions you might consider simply indexing the contents of lib/, but there are many fascinating oddities on CPAN and many dists from the days when it was normal to put the main .pm file in the root of the distribution archive - so PAUSE currently indexes all .pm and .PL files that are not either (a) specifically excluded by no_index (b) in &lt;code&gt;inc&lt;/code&gt;, &lt;code&gt;xt&lt;/code&gt;, or &lt;code&gt;t&lt;/code&gt; directories, or common 'mistake' directories such as &lt;code&gt;perl5&lt;/code&gt;.</source>
          <target state="translated">尽管no_index告诉您在建立索引时必须忽略的内容，但该规范对如何使可能的索引的初始候选对象列表没有任何意见。对于&amp;ldquo;正常&amp;rdquo;发行版，您可以考虑简单地索引lib /的内容，但是CPAN上有许多令人着迷的奇特之处，而且与通常将主.pm文件放在发行档案的根目录下的日子相比，还有很多不同之处-因此PAUSE当前会为所有.pm和.PL文件编制索引，这些文件既不是（a）在 &lt;code&gt;inc&lt;/code&gt; ， &lt;code&gt;xt&lt;/code&gt; 或 &lt;code&gt;t&lt;/code&gt; 目录中也不是no_index（b）明确排除的文件，也不是在诸如 &lt;code&gt;perl5&lt;/code&gt; 的常见&amp;ldquo;错误&amp;rdquo;目录中。</target>
        </trans-unit>
        <trans-unit id="393059c305b4f9157627b86935072088d84089d3" translate="yes" xml:space="preserve">
          <source>While none of the built-in data types have any arbitrary size limits (apart from memory size), there are still a few arbitrary limits: a given variable name may not be longer than 251 characters. Line numbers displayed by diagnostics are internally stored as short integers, so they are limited to a maximum of 65535 (higher numbers usually being affected by wraparound).</source>
          <target state="translated">虽然内置的数据类型都没有任意的大小限制(除了内存大小),但还是有一些任意的限制:一个给定的变量名不能超过251个字符。诊断程序显示的行号在内部存储为短整数,所以它们的最大限制是65535(更高的数字通常会受到环绕的影响)。</target>
        </trans-unit>
        <trans-unit id="b09324869be41d3f63ee219787db6a6f9e7b0b52" translate="yes" xml:space="preserve">
          <source>While not currently implemented, it is possible that in the future this function will convert only parts of the path to FILENAME to a short form.</source>
          <target state="translated">虽然目前还没有实现,但将来这个函数有可能只将FILENAME的部分路径转换为简写形式。</target>
        </trans-unit>
        <trans-unit id="1f300b76b4f41dcdc512a5b3661d8c1aa39ba74e" translate="yes" xml:space="preserve">
          <source>While not entirely limited to Unix-derived operating systems (e.g., WinSock on PCs provides socket support, as do some VMS libraries), you might not have sockets on your system, in which case this section probably isn't going to do you much good. With sockets, you can do both virtual circuits like TCP streams and datagrams like UDP packets. You may be able to do even more depending on your system.</source>
          <target state="translated">虽然并不完全局限于Unix衍生的操作系统(例如,PC上的WinSock提供了套接字支持,一些VMS库也提供了支持),但你的系统上可能没有套接字,在这种情况下,本节可能对你没有什么好处。有了套接字,你既可以做像TCP流这样的虚拟电路,也可以做像UDP包这样的数据报。根据你的系统,你可能可以做得更多。</target>
        </trans-unit>
        <trans-unit id="6ad3cf3a478c4f24fb9ef9675cf14d8e5c5a06f1" translate="yes" xml:space="preserve">
          <source>While running Configure and when building, you are likely to get quite a few of these warnings:</source>
          <target state="translated">在运行Configure和构建时,你很可能会收到不少这样的警告。</target>
        </trans-unit>
        <trans-unit id="9b58fa2736239282292bc4dda51122cd95ae2910" translate="yes" xml:space="preserve">
          <source>While short identifiers like &lt;code&gt;$gotit&lt;/code&gt; are probably ok, use underscores to separate words in longer identifiers. It is generally easier to read &lt;code&gt;$var_names_like_this&lt;/code&gt; than &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; , especially for non-native speakers of English. It's also a simple rule that works consistently with &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; .</source>
          <target state="translated">虽然像 &lt;code&gt;$gotit&lt;/code&gt; 这样的短标识符可能没问题，但请使用下划线将较长标识符中的单词分开。通常， &lt;code&gt;$var_names_like_this&lt;/code&gt; 比 &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; 更容易阅读，尤其是对于非英语母语的人。这也是一条与 &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; 一致的简单规则。</target>
        </trans-unit>
        <trans-unit id="3d9fa3ada3b6c731a34ad67160b19f8a88213b51" translate="yes" xml:space="preserve">
          <source>While short identifiers like &lt;code&gt;$gotit&lt;/code&gt; are probably ok, use underscores to separate words in longer identifiers. It is generally easier to read &lt;code&gt;$var_names_like_this&lt;/code&gt; than &lt;code&gt;$VarNamesLikeThis&lt;/code&gt;, especially for non-native speakers of English. It's also a simple rule that works consistently with &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt;.</source>
          <target state="translated">虽然像 &lt;code&gt;$gotit&lt;/code&gt; 这样的短标识符可能没问题，但请使用下划线将较长标识符中的单词分开。通常， &lt;code&gt;$var_names_like_this&lt;/code&gt; 比 &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; 更容易阅读，尤其是对于非英语母语的人。这也是一条与 &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; 一致的简单规则。</target>
        </trans-unit>
        <trans-unit id="ae3268e08a1d3bd058ed6f797f7794fd47fc37b4" translate="yes" xml:space="preserve">
          <source>While some developers find fatalizing some warnings to be a useful defensive programming technique, using &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; to fatalize all possible warning categories -- including custom ones -- is particularly risky. Therefore, the use of &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; is &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;.</source>
          <target state="translated">尽管有些开发人员发现致命警告某些警告是一种有用的防御性编程技术，但使用 &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; 来致命警告所有可能的警告类别（包括自定义警告）特别危险。因此，使用的 &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; 被&lt;a href=&quot;perlpolicy#discouraged&quot;&gt;气馁&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f10f744968048551bad6ee098cf44a11a372745" translate="yes" xml:space="preserve">
          <source>While still in that directory, type:</source>
          <target state="translated">当仍在该目录中时,输入:</target>
        </trans-unit>
        <trans-unit id="42ffebb3bbe4e65d94b8f907df7dc389a8053ee0" translate="yes" xml:space="preserve">
          <source>While the GNU project includes Perl in its distributions, there's no such thing as &quot;GNU Perl&quot;. Perl is not produced nor maintained by the Free Software Foundation. Perl's licensing terms are also more open than GNU software's tend to be.</source>
          <target state="translated">虽然GNU项目在其发行版中包含了Perl,但并不存在 &quot;GNU Perl &quot;这样的东西。Perl 不是由自由软件基金会制作或维护的。Perl的许可条款也比GNU软件更开放。</target>
        </trans-unit>
        <trans-unit id="84896ae82951e28a26020293e6f0af332fef1cca" translate="yes" xml:space="preserve">
          <source>While the Unicode Standard defines two additional forms of casefolding, one for Turkic languages and one that never maps one character into multiple characters, these are not provided by the Perl core. However, the CPAN module &lt;a href=&quot;Unicode::Casing&quot;&gt;&lt;code&gt;Unicode::Casing&lt;/code&gt;&lt;/a&gt; may be used to provide an implementation.</source>
          <target state="translated">虽然Unicode标准定义了两种附加的大小写折叠形式，一种用于突厥语，另一种则从未将一个字符映射成多个字符，但Perl核心并未提供这些形式。但是，可以使用CPAN模块&lt;a href=&quot;Unicode::Casing&quot;&gt; &lt;code&gt;Unicode::Casing&lt;/code&gt; &lt;/a&gt;提供实现。</target>
        </trans-unit>
        <trans-unit id="bcb3c100d2dfc2d28078ac3b93ee7e431111c075" translate="yes" xml:space="preserve">
          <source>While the Unicode Standard defines two additional forms of casefolding, one for Turkic languages and one that never maps one character into multiple characters, these are not provided by the Perl core; However, the CPAN module &lt;code&gt;Unicode::Casing&lt;/code&gt; may be used to provide an implementation.</source>
          <target state="translated">虽然Unicode标准定义了两种附加的大小写折叠形式，一种用于突厥语，另一种从未将一个字符映射成多个字符，但Perl内核没有提供这些形式。但是，CPAN模块 &lt;code&gt;Unicode::Casing&lt;/code&gt; 可用于提供实现。</target>
        </trans-unit>
        <trans-unit id="761ba2f6d0a7dac9fb4c5d145960b451d6d26420" translate="yes" xml:space="preserve">
          <source>While the key must be a string value (since that's a basic restriction that Perl places on hash keys), the value in the lexicon can currently be of several types: a defined scalar, scalarref, or coderef. The use of these is explained above, in the section 'The &quot;maketext&quot; Method', and Bracket Notation for strings is discussed in the next section.</source>
          <target state="translated">虽然键必须是字符串值(因为这是Perl对哈希键的基本限制),但目前词库中的值可以有几种类型:定义的标量、标量ref或coderef。这些的使用在上面的 &quot;maketext &quot;方法 &quot;一节中进行了说明,下一节将讨论字符串的括号符号。</target>
        </trans-unit>
        <trans-unit id="d08b05105bcedd2fb07dc0399888e4c9d241f3f1" translate="yes" xml:space="preserve">
          <source>While the list of arguments might work fine for one, two or even three arguments, any more arguments become hard for the module user to remember, and hard for the module author to manage. If you want to add a new parameter you will have to add it to the end of the list for backward compatibility, and this will probably make your list order unintuitive. Also, if many elements may be undefined you may see the following unattractive method calls:</source>
          <target state="translated">虽然参数列表对于一个、两个甚至三个参数来说可能很好用,但任何更多的参数对于模块用户来说都会变得很难记住,对于模块作者来说也很难管理。如果你想添加一个新的参数,为了向后兼容,你必须把它添加到列表的最后,这可能会使你的列表顺序变得不直观。另外,如果很多元素可能是未定义的,你可能会看到以下不好看的方法调用。</target>
        </trans-unit>
        <trans-unit id="019950bbf16db8b6543648ebb335d2eaf049366f" translate="yes" xml:space="preserve">
          <source>While the mapping &quot;infin&quot; to the character &quot;\x{221E}&quot; will (hopefully) have been already handled by the Pod parser, the presence of the character in this file means that it's reasonably important enough to include in a formatter's table that maps from notable Unicode characters to the codes necessary for rendering them. So for a Unicode-to-*roff mapping, for example, this would merit the entry:</source>
          <target state="translated">虽然 &quot;infin &quot;到字符&quot;\x{221E}&quot;的映射(希望)已经被Pod解析器处理过了,但这个文件中出现的字符意味着它足够重要,可以被包含在一个表格中,从著名的Unicode字符映射到渲染它们所需的代码。因此,对于Unicode-to-*roff映射,例如,这将是值得的条目。</target>
        </trans-unit>
        <trans-unit id="549c813f59b3276935336cbd28f55b4770622941" translate="yes" xml:space="preserve">
          <source>While the two classes may differ in many ways, when it comes to the &lt;code&gt;print_content()&lt;/code&gt; method, they are the same. This means that we can try to call the &lt;code&gt;print_content()&lt;/code&gt; method on an object of either class, and &lt;b&gt;we don't have to know what class the object belongs to!&lt;/b&gt;</source>
          <target state="translated">尽管这两个类在许多方面可能有所不同，但是当涉及到 &lt;code&gt;print_content()&lt;/code&gt; 方法时，它们是相同的。这意味着我们可以尝试在任一类的对象上调用 &lt;code&gt;print_content()&lt;/code&gt; 方法，而&lt;b&gt;不必知道该对象属于哪个类！&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="76ea82c5269a1424cf449fcf0bff6de44af4f6d8" translate="yes" xml:space="preserve">
          <source>While the word combination &lt;code&gt;character set&lt;/code&gt; has lost this meaning in MIME context since [RFC 2130], the &lt;code&gt;charset&lt;/code&gt; abbreviation has retained it. This is how [RFC 2277] and [RFC 2278] bless &lt;code&gt;charset&lt;/code&gt;:</source>
          <target state="translated">自[RFC 2130]起，单词组合 &lt;code&gt;character set&lt;/code&gt; 在MIME上下文中已失去此含义，但 &lt;code&gt;charset&lt;/code&gt; 缩写保留了该含义。这是[RFC 2277]和[RFC 2278]祝福 &lt;code&gt;charset&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b178eba62086e85a4d0b937f4f56029a87c5eae0" translate="yes" xml:space="preserve">
          <source>While there are Pod codes E&amp;lt;...&amp;gt; and Z&amp;lt;&amp;gt;, these</source>
          <target state="translated">尽管有Pod代码E &amp;lt;...&amp;gt;和Z &amp;lt;&amp;gt;，但这些</target>
        </trans-unit>
        <trans-unit id="05f8c54acc4d9406822b250e87f501917fa0a683" translate="yes" xml:space="preserve">
          <source>While there are currently no architecture-specific extensions or modules distributed with perl, the following directories can be used to hold such files (replace the string VERSION by the appropriate version number):</source>
          <target state="translated">虽然目前还没有与perl一起发布的特定架构的扩展或模块,但以下目录可以用来存放这些文件(用适当的版本号替换字符串VERSION)。</target>
        </trans-unit>
        <trans-unit id="0c8516dbb58fd38e067d471797d458e282eb5b87" translate="yes" xml:space="preserve">
          <source>While these operations are not questions of life and death, they are needed for a lot of useful scripts. This forces &lt;code&gt;a.out&lt;/code&gt; -style compile of</source>
          <target state="translated">尽管这些操作不是生死攸关的问题，但许多有用的脚本需要它们。这迫使 &lt;code&gt;a.out&lt;/code&gt; 风格的编译</target>
        </trans-unit>
        <trans-unit id="3d2455a51c401e0d0b17f4da15388c28c0528ee2" translate="yes" xml:space="preserve">
          <source>While these operations are not questions of life and death, they are needed for a lot of useful scripts. This forces &lt;code&gt;a.out&lt;/code&gt;-style compile of</source>
          <target state="translated">尽管这些操作不是生死攸关的问题，但许多有用的脚本需要它们。这迫使 &lt;code&gt;a.out&lt;/code&gt; 风格的编译</target>
        </trans-unit>
        <trans-unit id="1849a634e96a61e2b3cdef3b11aa962d9aad4c39" translate="yes" xml:space="preserve">
          <source>While this actually can be done, it's much harder than you'd think. For example, this one-liner</source>
          <target state="translated">虽然这其实是可以做到的,但比你想象的要难得多。例如,这个单行本</target>
        </trans-unit>
        <trans-unit id="c8b72cb61463146c67f31be1d892fe7495f6bd9f" translate="yes" xml:space="preserve">
          <source>While this allows some (significant?) performance advantages, this makes life much harder for developers, since the above scheme makes it impossible for a DLL to be &quot;linked&quot; to a symbol in the</source>
          <target state="translated">虽然这允许一些(显著的?)性能优势,但这给开发人员的生活带来了很大的困难,因为上述方案使得DLL不可能与</target>
        </trans-unit>
        <trans-unit id="5a4ded2cb5289b97c3775e062e86790bf5432277" translate="yes" xml:space="preserve">
          <source>While this class is currently implemented using the Class::Struct module to build a struct-like class, you shouldn't rely upon this.</source>
          <target state="translated">虽然这个类目前是用Class::Struct模块来实现的,以建立一个类似结构体的类,但你不应该依赖这个。</target>
        </trans-unit>
        <trans-unit id="e68b146940f9324cc2fc3ad49971a5aa379db2a9" translate="yes" xml:space="preserve">
          <source>While this compiles and runs happily, it probably won't do what's expected, namely it doesn't print &quot;Hello World\n&quot; at all; It will on the other hand do exactly what it was told to do, computers being a bit that way inclined. That is, it will print out a newline character, and you'll get what looks like a blank line. It looks like there's 2 variables when (because of the typo) there's really 3:</source>
          <target state="translated">虽然这个编译和运行得很愉快,但它可能不会做预期的事情,即它根本不会打印 &quot;Hello World\n&quot;;另一方面,它将完全按照它被告知的那样去做,因为计算机有点倾向于这样。也就是说,它会打印出一个换行符,而你会得到一个看起来像空行的东西。它看起来像有两个变量,而(因为打错了)实际上有三个。</target>
        </trans-unit>
        <trans-unit id="b959fa7d0d0730d45d9d80c8527dc6a6d9341163" translate="yes" xml:space="preserve">
          <source>While this currently exists in all three implementations perl itself does not use it.</source>
          <target state="translated">虽然目前所有三个实现中都有这个功能,但perl本身并没有使用它。</target>
        </trans-unit>
        <trans-unit id="386467fc98e2754e0e58a98e1b2d3e8dc8fa8075" translate="yes" xml:space="preserve">
          <source>While this currently exists in both implementations, perl itself does not use it.</source>
          <target state="translated">虽然目前这两种实现中都存在,但perl本身并没有使用它。</target>
        </trans-unit>
        <trans-unit id="f084942a5c159bd226784a38fd066229baa22988" translate="yes" xml:space="preserve">
          <source>While this document is intended to be useful to all module authors, it is particularly aimed at authors who wish to publish their modules on CPAN.</source>
          <target state="translated">虽然本文件旨在对所有模块作者有用,但它特别针对那些希望在CPAN上发布模块的作者。</target>
        </trans-unit>
        <trans-unit id="66c1c2ee830cc759765d36b85a240cf7d1bab82e" translate="yes" xml:space="preserve">
          <source>While this feature is most commonly used to explicitly call methods inherited from an ancestor class, there is no technical restriction that enforces this:</source>
          <target state="translated">虽然这个特性最常用来显式调用从祖类继承的方法,但没有任何技术限制来强制执行。</target>
        </trans-unit>
        <trans-unit id="1785d6466e3128c272757d8a3931f08ab9e01f53" translate="yes" xml:space="preserve">
          <source>While this is legal practice, it is certainly dubious, and downright fatal in at least one platform: for example VMS cc considers this a fatal error. One cause for people often making this mistake is that a &quot;naked char&quot; and therefore dereferencing a &quot;naked char pointer&quot; have an undefined signedness: it depends on the compiler and the flags of the compiler and the underlying platform whether the result is signed or unsigned. For this very same reason using a 'char' as an array index is bad.</source>
          <target state="translated">虽然这是合法的做法,但它肯定是可疑的,至少在一个平台上是致命的:例如VMS cc认为这是一个致命的错误。人们经常犯这种错误的一个原因是,一个 &quot;裸体char &quot;以及因此而派生的 &quot;裸体char指针 &quot;具有未定义的签名性:结果是有签名还是无签名取决于编译器和底层平台的标志。出于同样的原因,使用 &quot;char &quot;作为数组索引是不好的。</target>
        </trans-unit>
        <trans-unit id="40200d6701039334e5e5bffbb6cca8ab91bc30ff" translate="yes" xml:space="preserve">
          <source>While this is true on the surface, it's much more efficient to process the file one line or record at a time because then you don't have to read the whole thing into memory at once. It also gives you finer control of the whole process, letting you kill off the child process early if you'd like.</source>
          <target state="translated">虽然表面上看是这样,但一次只处理一行或一条记录的文件效率要高得多,因为这样你就不必一次把整个文件读到内存中。它还能让你更精细地控制整个过程,如果你愿意,可以让你提前杀掉子进程。</target>
        </trans-unit>
        <trans-unit id="9790d6e959def47c7e50e558f607fe7ba4374a90" translate="yes" xml:space="preserve">
          <source>While this might be too cumbersome to implement in event-based Pod parsers, it is straightforward for parsers that return parse trees.</source>
          <target state="translated">虽然在基于事件的Pod解析器中实现这一点可能会过于繁琐,但对于返回解析树的解析器来说,它是直接的。</target>
        </trans-unit>
        <trans-unit id="81aa0dd02571c7973cd68f4d9f805b1c67ff2c9c" translate="yes" xml:space="preserve">
          <source>While this might by accident work in some platform (where IV happens to be an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;), in general it cannot. IV might be something larger. Even worse the situation is with more specific types (defined by Perl's configuration step in</source>
          <target state="translated">尽管这可能是偶然地在某些平台（IV恰好是 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; ）上工作的，但通常不能。IV可能更大。更糟糕的情况是使用更特定的类型（由Perl的配置步骤定义）</target>
        </trans-unit>
        <trans-unit id="7f1683bf56a3090bff1bb086f826f7e09370112c" translate="yes" xml:space="preserve">
          <source>While this might by accident work in some platform (where IV happens to be an &lt;code&gt;int&lt;/code&gt;), in general it cannot. IV might be something larger. Even worse the situation is with more specific types (defined by Perl's configuration step in</source>
          <target state="translated">尽管这可能是偶然地在某些平台（IV恰好是 &lt;code&gt;int&lt;/code&gt; ）上工作的，但通常不能。IV可能更大。更糟糕的情况是使用更具体的类型（由Perl的配置步骤定义）</target>
        </trans-unit>
        <trans-unit id="82be9c7a2de102e2677bf88ba7443091644097cd" translate="yes" xml:space="preserve">
          <source>While this works reasonably well for unidirectional communication, what about bidirectional communication? The most obvious approach doesn't work:</source>
          <target state="translated">虽然这对于单向通信来说效果还算不错,但双向通信呢?最显而易见的方法是行不通的。</target>
        </trans-unit>
        <trans-unit id="26ea84a69e787188d7dfd7dc7bac4a8b95950ee8" translate="yes" xml:space="preserve">
          <source>While threads bring a new set of useful tools, they also bring a number of pitfalls. One pitfall is the race condition:</source>
          <target state="translated">虽然线程带来了一系列新的有用工具,但它们也带来了一些陷阱。其中一个陷阱就是竞赛条件。</target>
        </trans-unit>
        <trans-unit id="0369ef7f3a86c9ade18a8f113608ef11b27c9fcb" translate="yes" xml:space="preserve">
          <source>While thumbing through the &lt;a href=&quot;Date::ICal&quot;&gt;Date::ICal&lt;/a&gt; man page, I came across this:</source>
          <target state="translated">在翻阅&lt;a href=&quot;Date::ICal&quot;&gt;Date :: ICal&lt;/a&gt;手册页时，我遇到了以下问题：</target>
        </trans-unit>
        <trans-unit id="8fb55e176d75bb6afa2c9779e5d12c3767454404" translate="yes" xml:space="preserve">
          <source>While trying to read from his caller-id box, the notorious Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; , after much gnashing of teeth and fighting with &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, POSIX's &lt;code&gt;tcgetattr&lt;/code&gt; business, and various other functions that go bump in the night, finally came up with this:</source>
          <target state="translated">当试图从他的来电显示框中读取内容时，臭名昭著的Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; 咬牙切齿地与 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; ，POSIX的 &lt;code&gt;tcgetattr&lt;/code&gt; 业务以及各种其他功能在晚上碰到了一样，终于想到了这个：</target>
        </trans-unit>
        <trans-unit id="3d9a29cb2e71d84a90b207c5a091106e69ab3f88" translate="yes" xml:space="preserve">
          <source>While trying to read from his caller-id box, the notorious Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt;, after much gnashing of teeth and fighting with &lt;code&gt;sysread&lt;/code&gt;, &lt;code&gt;sysopen&lt;/code&gt;, POSIX's &lt;code&gt;tcgetattr&lt;/code&gt; business, and various other functions that go bump in the night, finally came up with this:</source>
          <target state="translated">在臭名昭著的Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; 试图从他的来电显示框中读取内容时，经过十足的磨牙，并与 &lt;code&gt;sysread&lt;/code&gt; ， &lt;code&gt;sysopen&lt;/code&gt; ，POSIX的 &lt;code&gt;tcgetattr&lt;/code&gt; 业务以及其他各种在夜里碰到的功能进行了斗争，终于想到了这个：</target>
        </trans-unit>
        <trans-unit id="6d7592c228741a449aa83d6358c7b5dbac2c422e" translate="yes" xml:space="preserve">
          <source>While trying to resolve method call %s-&amp;gt;%s() can not locate package &quot;%s&quot; yet it is mentioned in @%s::ISA (perhaps you forgot to load &quot;%s&quot;?)</source>
          <target state="translated">尝试解决方法调用％s-&amp;gt;％s（）时无法找到包&amp;ldquo;％s&amp;rdquo;，但它已在@％s :: ISA中提及（也许您忘记加载&amp;ldquo;％s&amp;rdquo;了吗？）</target>
        </trans-unit>
        <trans-unit id="5ffa8b7afc028fdbcdab4b6dea3d1eb48e0f55ad" translate="yes" xml:space="preserve">
          <source>While using the standard</source>
          <target state="translated">当使用标准的</target>
        </trans-unit>
        <trans-unit id="c059f6308f685a568f9b74b626f917b18a45a114" translate="yes" xml:space="preserve">
          <source>While version objects overload stringification, to portably convert &lt;code&gt;$^V&lt;/code&gt; into its string representation, use &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; conversion, which works for both v-strings or version objects:</source>
          <target state="translated">当版本对象超载字符串化时，为了将 &lt;code&gt;$^V&lt;/code&gt; 转换为字符串表示形式，请使用 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; 转换，该转换对v字符串或版本对象均适用：</target>
        </trans-unit>
        <trans-unit id="7e7742e29582b552f48253992f05bd5349646ba9" translate="yes" xml:space="preserve">
          <source>While version objects overload stringification, to portably convert &lt;code&gt;$^V&lt;/code&gt; into its string representation, use &lt;code&gt;sprintf()&lt;/code&gt;'s &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; conversion, which works for both v-strings or version objects:</source>
          <target state="translated">当版本对象过载字符串化时，为了将 &lt;code&gt;$^V&lt;/code&gt; 可移植地转换为字符串表示形式，请使用 &lt;code&gt;sprintf()&lt;/code&gt; 的 &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; 转换，该转换对v字符串或版本对象均适用：</target>
        </trans-unit>
        <trans-unit id="3a5995cddc89ffbbaa6e8a0013934033bfcd3e1f" translate="yes" xml:space="preserve">
          <source>While versions earlier than 5.8.1 had threads they contain too many bugs to support.</source>
          <target state="translated">虽然比5.8.1更早的版本有线程,但它们包含的bug太多,无法支持。</target>
        </trans-unit>
        <trans-unit id="daa9a857c615b0eef13a54df6fdfd26532388959" translate="yes" xml:space="preserve">
          <source>While we normally think of patterns as being delimited with &lt;code&gt;/&lt;/code&gt; characters, they can be delimited by almost any character. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; describes this. For example, the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; above uses braces as delimiters. Selecting another delimiter can avoid quoting the delimiter within the pattern:</source>
          <target state="translated">虽然我们通常认为模式用 &lt;code&gt;/&lt;/code&gt; 字符分隔，但几乎可以用任何字符分隔它们。&lt;a href=&quot;perlre&quot;&gt;perlre对此进行了&lt;/a&gt;描述。例如，上面的 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 使用花括号作为定界符。选择另一个定界符可以避免在模式中引用定界符：</target>
        </trans-unit>
        <trans-unit id="39f1ea1d3e2074839c9819aaf86819467fb5bb22" translate="yes" xml:space="preserve">
          <source>While we normally think of patterns as being delimited with &lt;code&gt;/&lt;/code&gt; characters, they can be delimited by almost any character. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; describes this. For example, the &lt;code&gt;s///&lt;/code&gt; above uses braces as delimiters. Selecting another delimiter can avoid quoting the delimiter within the pattern:</source>
          <target state="translated">虽然我们通常认为模式用 &lt;code&gt;/&lt;/code&gt; 字符分隔，但几乎可以用任何字符分隔它们。&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;描述了这一点。例如，上面的 &lt;code&gt;s///&lt;/code&gt; 使用花括号作为定界符。选择另一个定界符可以避免在模式中引用定界符：</target>
        </trans-unit>
        <trans-unit id="09af51d2e240602d6d93896cb9f587c7a82f4e64" translate="yes" xml:space="preserve">
          <source>While we strongly suggest you don't build your objects from scratch, you should know the term &lt;b&gt;bless&lt;/b&gt;. A &lt;b&gt;blessed&lt;/b&gt; data structure (aka &quot;a referent&quot;) is an object. We sometimes say that an object has been &quot;blessed into a class&quot;.</source>
          <target state="translated">尽管我们强烈建议您不要从头开始构建对象，但是您应该知道术语&lt;b&gt;bless&lt;/b&gt;。受&lt;b&gt;祝福的&lt;/b&gt;数据结构（也称为&amp;ldquo;对象&amp;rdquo;）是一个对象。有时我们说一个对象已经&amp;ldquo;被祝福到一个类中&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="562c113d1f1007e0a6502247b3772bac3c2d33a2" translate="yes" xml:space="preserve">
          <source>While we usually think of quotes as literal values, in Perl they function as operators, providing various kinds of interpolating and pattern matching capabilities. Perl provides customary quote characters for these behaviors, but also provides a way for you to choose your quote character for any of them. In the following table, a &lt;code&gt;{}&lt;/code&gt; represents any pair of delimiters you choose.</source>
          <target state="translated">虽然我们通常将引号视为文字值，但在Perl中它们充当运算符，提供各种插值和模式匹配功能。Perl为这些行为提供了惯用的引号字符，但还为您提供了一种为其中任何一种选择引号字符的方法。在下表中， &lt;code&gt;{}&lt;/code&gt; 代表您选择的任何一对定界符。</target>
        </trans-unit>
        <trans-unit id="34200b2d58936bc37828d3e87d2eebbab2c0f898" translate="yes" xml:space="preserve">
          <source>While we're here, take a closer look at the '&lt;b&gt;x&lt;/b&gt;' command, it's really useful and will merrily dump out nested references, complete objects, partial objects - just about whatever you throw at it:</source>
          <target state="translated">当我们在这里时，请仔细看一下' &lt;b&gt;x&lt;/b&gt; '命令，它确实很有用，并且会愉快地转储嵌套引用，完整对象，部分对象-几乎与您抛出的内容一样：</target>
        </trans-unit>
        <trans-unit id="00e2fed4a06f99f6100461a2d8cbb333f4d09501" translate="yes" xml:space="preserve">
          <source>While you can mix double colons with singles quotes, the quotes must come after the colons: &lt;code&gt;$::::'foo&lt;/code&gt; and &lt;code&gt;$foo::'bar&lt;/code&gt; are legal, but &lt;code&gt;$::'::foo&lt;/code&gt; and &lt;code&gt;$foo'::bar&lt;/code&gt; are not.</source>
          <target state="translated">虽然可以将双冒号与单引号引起来，但引号必须在冒号后： &lt;code&gt;$::::'foo&lt;/code&gt; 和 &lt;code&gt;$foo::'bar&lt;/code&gt; 是合法的，但是 &lt;code&gt;$::'::foo&lt;/code&gt; 和 &lt;code&gt;$foo'::bar&lt;/code&gt; 不是。</target>
        </trans-unit>
        <trans-unit id="078d591b0ade8bcb579420345c7df7b2c236f00e" translate="yes" xml:space="preserve">
          <source>While you can use arbitrary unique IDs for lexicon keys (like &quot;_min_larger_max_error&quot;), it is often useful for if an entry's key is itself a valid value, like this example error message:</source>
          <target state="translated">虽然你可以为词库键使用任意的唯一ID(如&quot;_min_larger_max_error&quot;),但它通常对一个条目的键本身是一个有效的值很有用,就像这个错误信息的例子。</target>
        </trans-unit>
        <trans-unit id="59ac30a04c89545845f0a1e87ea492a8c9c597ff" translate="yes" xml:space="preserve">
          <source>While you're doing that, make really sure you haven't missed a module similar to the one you're about to write.</source>
          <target state="translated">当你这样做的时候,要确保你没有错过一个类似于你要写的模块。</target>
        </trans-unit>
        <trans-unit id="95a6dc4463afddf0b399fee2185874a12ea0df02" translate="yes" xml:space="preserve">
          <source>While:</source>
          <target state="translated">While:</target>
        </trans-unit>
        <trans-unit id="c6568ae799534002dc040ff86ba3511a9bd4bd58" translate="yes" xml:space="preserve">
          <source>Whilst control is in the library, an error condition occurs. You have previously set up a Perl callback to handle this situation, so it will get executed. Once the callback has finished, control will drop back to Perl again. Here is what the flow of control will be like in that situation</source>
          <target state="translated">当控件在库中时,发生了一个错误条件。你之前已经设置了一个Perl回调来处理这种情况,所以它将被执行。一旦回调完成,控制将再次回到Perl中。下面是在这种情况下的控制流程。</target>
        </trans-unit>
        <trans-unit id="80e9be96d98a6599b821f35e0fd1d6289ce559ee" translate="yes" xml:space="preserve">
          <source>White space, hyphens, and underscores ARE significant except for:</source>
          <target state="translated">除以下情况外,空格、连字符和下划线都是重要的。</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="44c1e2cd5ccb90bd73774fc5e53e7773e341381c" translate="yes" xml:space="preserve">
          <source>Whitespace and IPC::Open3 / system()</source>
          <target state="translated">空白与IPC::Open3/system()</target>
        </trans-unit>
        <trans-unit id="82098c40334ef85fcca05587546e9cc28f23e2a9" translate="yes" xml:space="preserve">
          <source>Whitespace and IPC::Run</source>
          <target state="translated">白色空间和IPC::Run</target>
        </trans-unit>
        <trans-unit id="974608074eb6dc3e2345e2aa4e42c412340d3d49" translate="yes" xml:space="preserve">
          <source>Whitespace and special characters in the filename argument</source>
          <target state="translated">文件名参数中的空白和特殊字符。</target>
        </trans-unit>
        <trans-unit id="e3b1deb6ad1643a6518bffe011e47a1bbf2cd01d" translate="yes" xml:space="preserve">
          <source>Whitespace does not delimit fileglobs.</source>
          <target state="translated">空格不对文件组进行定界。</target>
        </trans-unit>
        <trans-unit id="df7fa704cbceacef574fb86983159dfe4b06ae43" translate="yes" xml:space="preserve">
          <source>Whitespace in filenames is tolerated on most systems, but not all, and even on systems where it might be tolerated, some utilities might become confused by such whitespace.</source>
          <target state="translated">文件名中的空白在大多数系统中是可以被容忍的,但并非所有系统都可以,即使在可以容忍的系统中,一些实用程序也会被这种空白所迷惑。</target>
        </trans-unit>
        <trans-unit id="baf39f9fbe05bd8902b826d4b1716bd33c1e5022" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored.</source>
          <target state="translated">忽略空白处。</target>
        </trans-unit>
        <trans-unit id="5899e5ae54fc72cc82eec99924af8577c33c2cbc" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored. The alias value can be a single attribute or a space-separated list of attributes.</source>
          <target state="translated">忽略空白处。别名的值可以是一个单一属性,也可以是一个用空格分隔的属性列表。</target>
        </trans-unit>
        <trans-unit id="09822d18c062da75d056f267dd113eb02444df2b" translate="yes" xml:space="preserve">
          <source>Whitespace is irrelevant:</source>
          <target state="translated">空格是无关紧要的。</target>
        </trans-unit>
        <trans-unit id="e6027b651e819925aa47dc4c27f8a2f557b14aae" translate="yes" xml:space="preserve">
          <source>Who Needs Complicated Data Structures?</source>
          <target state="translated">谁需要复杂的数据结构?</target>
        </trans-unit>
        <trans-unit id="ce404d98012c2a69e116523288638e2bddf0b8c2" translate="yes" xml:space="preserve">
          <source>Who supports Perl? Who develops it? Why is it free?</source>
          <target state="translated">谁支持Perl?谁在开发它?为什么它是免费的?</target>
        </trans-unit>
        <trans-unit id="6272068bf74683d289db3b55d0ea826c2bd453e3" translate="yes" xml:space="preserve">
          <source>Who wrote it (use AUTHORS for multiple people). It's a good idea to include your current e-mail address (or some e-mail address to which bug reports should be sent) or some other contact information so that users have a way of contacting you. Remember that program documentation tends to roam the wild for far longer than you expect and pick a contact method that's likely to last.</source>
          <target state="translated">谁写的 (如果是多人写的,就用AUTHORS)。最好包括你当前的电子邮件地址(或一些应该发送错误报告的电子邮件地址)或其他一些联系信息,这样用户就有办法与你联系。记住,程序文档在野外漫游的时间往往比你预想的要长得多,要选择一种可能持续的联系方法。</target>
        </trans-unit>
        <trans-unit id="cf619e0d870f5f00d0e62715b2fa9d9354bf3093" translate="yes" xml:space="preserve">
          <source>Whoops! Looks like it's unimplemented. Assume you don't have the time to fix this. [11] Normally, you'd just comment out the test and put a note in a todo list somewhere. Instead, explicitly state &quot;this test will fail&quot; by wrapping it in a &lt;code&gt;TODO&lt;/code&gt; block:</source>
          <target state="translated">哎呀！看起来好像没有实现。假设您没有时间解决此问题。[11]通常，您只是将测试注释掉，然后在待办事项列表中的某处放一个便条。而是通过将其包装在 &lt;code&gt;TODO&lt;/code&gt; 块中来明确声明&amp;ldquo;此测试将失败&amp;rdquo; ：</target>
        </trans-unit>
        <trans-unit id="d4357002b49a216cedec63d85f662f9560e6c2af" translate="yes" xml:space="preserve">
          <source>Whoops! You just put a tab and a formfeed into that filename! Remember that within double quoted strings (&quot;like\this&quot;), the backslash is an escape character. The full list of these is in &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;&quot;Quote and Quote-like Operators&quot; in perlop&lt;/a&gt;. Unsurprisingly, you don't have a file called &quot;c:(tab)emp(formfeed)oo&quot; or &quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy DOS filesystem.</source>
          <target state="translated">哎呀！您只需在该文件名中放入一个标签和一个换页符即可！请记住，在双引号字符串（&amp;ldquo; like \ this&amp;rdquo;）中，反斜杠是转义字符。这些的完整列表&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;在perlop的&amp;ldquo;类似报价和报价的运算符&amp;rdquo;中&lt;/a&gt;。毫不奇怪，您在旧版DOS文件系统上没有名为&amp;ldquo; c：（tab）emp（formfeed）oo&amp;rdquo;或&amp;ldquo; c：（tab）emp（formfeed）oo.exe&amp;rdquo;的文件。</target>
        </trans-unit>
        <trans-unit id="b22ef207f555182408b6d1958c0f8d72d42ebbcf" translate="yes" xml:space="preserve">
          <source>Whoops! You just put a tab and a formfeed into that filename! Remember that within double quoted strings (&quot;like\this&quot;), the backslash is an escape character. The full list of these is in &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;. Unsurprisingly, you don't have a file called &quot;c:(tab)emp(formfeed)oo&quot; or &quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy DOS filesystem.</source>
          <target state="translated">哎呀！您只需在该文件名中放入一个标签和一个换页符即可！请记住，在双引号字符串（&amp;ldquo; like \ this&amp;rdquo;）中，反斜杠是转义字符。这些的完整列表&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;在perlop&lt;/a&gt;中的Quote和类似Quote的运算符中。毫不奇怪，您的旧DOS文件系统上没有名为&amp;ldquo; c：（tab）emp（formfeed）oo&amp;rdquo;或&amp;ldquo; c：（tab）emp（formfeed）oo.exe&amp;rdquo;的文件。</target>
        </trans-unit>
        <trans-unit id="4b60ac899852ccb4f23a0cc5a329b0dd058c1185" translate="yes" xml:space="preserve">
          <source>Whoops, a failure! [4] &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt; helpfully lets us know on what line the failure occurred, but not much else. We were supposed to get 17, but we didn't. What did we get?? Dunno. You could re-run the test in the debugger or throw in some print statements to find out.</source>
          <target state="translated">哎呀，失败了！[4] &lt;a href=&quot;Test::Simple&quot;&gt;Test :: Simple&lt;/a&gt;有助于使我们知道发生故障的那一行，但其他方面不多。我们应该得到17，但我们没有。我们得到了什么？不知道。您可以在调试器中重新运行测试，也可以添加一些打印语句以进行查找。</target>
        </trans-unit>
        <trans-unit id="8c0f41e4219d3445a18de71b89eb22ea90d39e82" translate="yes" xml:space="preserve">
          <source>Whoops. You should instead use this, which will fail if the file doesn't exist:</source>
          <target state="translated">呜呜,你应该用这个。你应该用这个,如果文件不存在,就会失败。</target>
        </trans-unit>
        <trans-unit id="21e2caea4476d26af34541ca7c909c7ff2fa4a7f" translate="yes" xml:space="preserve">
          <source>Why</source>
          <target state="translated">Why</target>
        </trans-unit>
        <trans-unit id="9560992747d1a6605928cb6a17f56014fb292bd8" translate="yes" xml:space="preserve">
          <source>Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?</source>
          <target state="translated">为什么我得到的是长小数(例如,19.9499999999999),而不是我应该得到的数字(例如,19.95)?</target>
        </trans-unit>
        <trans-unit id="dc84c992e3edcd39e94928310a7c42a03b0e34c8" translate="yes" xml:space="preserve">
          <source>Why aren't my random numbers random?</source>
          <target state="translated">为什么我的随机数不是随机的?</target>
        </trans-unit>
        <trans-unit id="55451ebd45b1e100db71c6105ddc04433d37cb2f" translate="yes" xml:space="preserve">
          <source>Why can't I get the output of a command with system()?</source>
          <target state="translated">为什么我不能用system()获取命令的输出?</target>
        </trans-unit>
        <trans-unit id="6283f33f8240aceff8b5bf7c89ea62586d7996ea" translate="yes" xml:space="preserve">
          <source>Why can't I just open(FH, &quot;&amp;gt;file.lock&quot;)?</source>
          <target state="translated">为什么我不能只打开（FH，&amp;ldquo;&amp;gt; file.lock&amp;rdquo;）？</target>
        </trans-unit>
        <trans-unit id="45f36238b104ed9ce41136ab2cd5676c9546b754" translate="yes" xml:space="preserve">
          <source>Why can't I use &quot;C:\temp\foo&quot; in DOS paths? Why doesn't `C:\temp\foo.exe` work?</source>
          <target state="translated">为什么我在DOS路径中不能使用 &quot;C:tempfoo&quot;?为什么 &quot;C:\tempfoo.exe &quot;不能使用?</target>
        </trans-unit>
        <trans-unit id="7cf9bf3687394740ded1b7a3b49b00f8b7f479e0" translate="yes" xml:space="preserve">
          <source>Why can't a method included in this same file be found?</source>
          <target state="translated">为什么在这个同样的文件中找不到一个方法?</target>
        </trans-unit>
        <trans-unit id="c1b368f947117e2802b241b52fd0f345164c6250" translate="yes" xml:space="preserve">
          <source>Why can't my script read from STDIN after I gave it EOF (^D on Unix, ^Z on MS-DOS)?</source>
          <target state="translated">为什么我的脚本在给了EOF(Unix上是^D,MS-DOS上是^Z)之后不能从STDIN读取?</target>
        </trans-unit>
        <trans-unit id="12d1b0fba90164d9432c0961ee9c0f59f511f752" translate="yes" xml:space="preserve">
          <source>Why can't the part of an Email address after the @ be used as the hostname ?</source>
          <target state="translated">为什么Email地址中@后面的部分不能作为主机名使用?</target>
        </trans-unit>
        <trans-unit id="4a35a43f2543633bf09ecfd8ed381f93a2e351c4" translate="yes" xml:space="preserve">
          <source>Why chimera build?</source>
          <target state="translated">为什么要建立奇美拉?</target>
        </trans-unit>
        <trans-unit id="4ad29870738240c44cf5d008e9ef6e5a830b4811" translate="yes" xml:space="preserve">
          <source>Why did MakeMaker reinvent the build configuration wheel? Why not just use autoconf or automake or ppm or Ant or ...</source>
          <target state="translated">为什么MakeMaker要重新发明构建配置轮?为什么不直接使用autoconf或automake或ppm或Ant或 ...</target>
        </trans-unit>
        <trans-unit id="9c94cf8ad35b8d40bcd1d8a24897df534e24a65c" translate="yes" xml:space="preserve">
          <source>Why do I get asked the same questions every time I start the shell?</source>
          <target state="translated">为什么每次启动shell都会问我同样的问题?</target>
        </trans-unit>
        <trans-unit id="88d20a17cd64b1f5b322facdeee78dd428855e4f" translate="yes" xml:space="preserve">
          <source>Why do I get weird spaces when I print an array of lines?</source>
          <target state="translated">为什么我在打印一个数组行时得到奇怪的空格?</target>
        </trans-unit>
        <trans-unit id="22c242ee2f7e6a5499b05c8e9ef2302a328d950b" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use &amp;lt;*&amp;gt;?</source>
          <target state="translated">为什么在使用&amp;lt;*&amp;gt;时有时会出现&amp;ldquo;参数列表过长&amp;rdquo;的情况？</target>
        </trans-unit>
        <trans-unit id="b24284283ebf1fc2287cf9d0bdc0093551feae63" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use ?</source>
          <target state="translated">为什么我有时会收到 &quot;Argument list too long&quot;(参数列表太长),当我使用?</target>
        </trans-unit>
        <trans-unit id="63e6abc6f1a440467925da9b75e53aa88bf445d6" translate="yes" xml:space="preserve">
          <source>Why do Perl operators have different precedence than C operators?</source>
          <target state="translated">为什么Perl运算符与C运算符的优先级不同?</target>
        </trans-unit>
        <trans-unit id="ef2253bfbc8ad66388d03d0bb9e87b886d907b29" translate="yes" xml:space="preserve">
          <source>Why do regex character classes sometimes match only in the ASCII range?</source>
          <target state="translated">为什么regex字符类有时只在ASCII范围内匹配?</target>
        </trans-unit>
        <trans-unit id="fe1dc5c347574cf3a08e8eebfbeb7750b39e6b8c" translate="yes" xml:space="preserve">
          <source>Why do setuid perl scripts complain about kernel problems?</source>
          <target state="translated">为什么setuid perl脚本会抱怨内核问题?</target>
        </trans-unit>
        <trans-unit id="026df39820ea4af121bee1f807b65636d02b2c10" translate="yes" xml:space="preserve">
          <source>Why do some characters not uppercase or lowercase correctly?</source>
          <target state="translated">为什么有些字不能正确地大写或小写?</target>
        </trans-unit>
        <trans-unit id="c99d6ee81fb9e8a95f7bcc8c77d79b83dd80d118" translate="yes" xml:space="preserve">
          <source>Why do you want to do that? :-)</source>
          <target state="translated">你为什么要这样做?)</target>
        </trans-unit>
        <trans-unit id="72bb63a51859ce8a03efe317ce769e0ebbe394ee" translate="yes" xml:space="preserve">
          <source>Why does Net::FTP not implement mput and mget methods</source>
          <target state="translated">为什么Net::FTP没有实现mput和mget方法?</target>
        </trans-unit>
        <trans-unit id="c2f2d2fc2e6067abbcff0c6297133f00fea08094" translate="yes" xml:space="preserve">
          <source>Why does Net::SMTP not do DNS MX lookups ?</source>
          <target state="translated">为什么Net::SMTP不做DNS MX查询?</target>
        </trans-unit>
        <trans-unit id="bd94a8382da48e70b41ef67567b746b186c9a0e6" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">为什么 Perl 让我删除只读文件?为什么 -i 会破坏受保护的文件?这难道不是 Perl 的一个错误吗?</target>
        </trans-unit>
        <trans-unit id="cc878c7b17c2f51ef8a429a9375cb383410dd74c" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does &lt;code&gt;-i&lt;/code&gt; clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">为什么Perl让我删除只读文件？为什么 &lt;code&gt;-i&lt;/code&gt; 破坏器保护文件？这不是Perl中的错误吗？</target>
        </trans-unit>
        <trans-unit id="cab7997afd3e855e0bc949d3ba08b5a07d77bad2" translate="yes" xml:space="preserve">
          <source>Why does defined() return true on empty arrays and hashes?</source>
          <target state="translated">为什么 defined()在空数组和哈希上返回 true?</target>
        </trans-unit>
        <trans-unit id="a9078f034de31f1b296232dfb6a8a4e24d9d3fe0" translate="yes" xml:space="preserve">
          <source>Why does passing a subroutine an undefined element in a hash create it?</source>
          <target state="translated">为什么在哈希中传递一个未定义元素的子程序会创建它?</target>
        </trans-unit>
        <trans-unit id="7586fa4c0b5fc90f209bbbf4172abb17863eb05e" translate="yes" xml:space="preserve">
          <source>Why does using $&amp;amp;, $`, or $' slow my program down?</source>
          <target state="translated">为什么使用$＆，$`或$'会使我的程序变慢？</target>
        </trans-unit>
        <trans-unit id="d0d6812625a87b8571932c2c534a16df1d30c46a" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = &amp;lt;$fh&amp;gt;;&quot; work right?</source>
          <target state="translated">为什么不显示&amp;ldquo; my（$ foo）= &amp;lt;$ fh&amp;gt;;&amp;rdquo; 工作吧？</target>
        </trans-unit>
        <trans-unit id="dce612b6a2414fd18ba042c0e4b6d8009b148ed5" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = ;&quot; work right?</source>
          <target state="translated">为什么 &quot;my($foo)=;&quot;不能正常工作?</target>
        </trans-unit>
        <trans-unit id="5027566591e947a691e8c94cf6484817ceca1f52" translate="yes" xml:space="preserve">
          <source>Why doesn't &amp;amp; work the way I want it to?</source>
          <target state="translated">为什么不按我想要的方式工作？</target>
        </trans-unit>
        <trans-unit id="4cf8f75bbab1ae3d6a9b3cc517f4738f093df66a" translate="yes" xml:space="preserve">
          <source>Why doesn't glob(&quot;*.*&quot;) get all the files?</source>
          <target state="translated">为什么 glob(&quot;*.*&quot;)不能得到所有的文件?</target>
        </trans-unit>
        <trans-unit id="2deaa0032d55ad3bbe4d463b92dc4d6876271de7" translate="yes" xml:space="preserve">
          <source>Why doesn't my sockets program work under System V (Solaris)? What does the error message &quot;Protocol not supported&quot; mean?</source>
          <target state="translated">为什么我的套接字程序在System V (Solaris)下不能工作?协议不支持 &quot;的错误信息是什么意思?</target>
        </trans-unit>
        <trans-unit id="94b7e3ba62840111acddb7ecbcec36ba2e7bc4b2" translate="yes" xml:space="preserve">
          <source>Why doesn't open() return an error when a pipe open fails?</source>
          <target state="translated">为什么管道打开失败时,open()不返回错误?</target>
        </trans-unit>
        <trans-unit id="39d80c781157cb75a05623de25db34f558131470" translate="yes" xml:space="preserve">
          <source>Why don't Perl one-liners work on my DOS/Mac/VMS system?</source>
          <target state="translated">为什么Perl单行本在我的DOS/Mac/VMS系统上无法使用?</target>
        </trans-unit>
        <trans-unit id="7efb6bacfd459d208d2e83d3ccd6f5a6e06b31a2" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;</source>
          <target state="translated">为什么我的&amp;lt;</target>
        </trans-unit>
        <trans-unit id="d55b9cceedd9f6975831dcd97371f91faa17e9ba" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;&amp;lt;HERE documents work?</source>
          <target state="translated">为什么我的&amp;lt;&amp;lt; HERE文档不起作用？</target>
        </trans-unit>
        <trans-unit id="1b729d456f5e2de755ce9ca47664753dfbd6fc06" translate="yes" xml:space="preserve">
          <source>Why don't my tied hashes make the defined/exists distinction?</source>
          <target state="translated">为什么我的绑定哈希不做定义/存在的区分?</target>
        </trans-unit>
        <trans-unit id="ec879bc347cf004a28479d385b991508d06231e9" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with &lt;code&gt;\b&lt;/code&gt; work for me?</source>
          <target state="translated">为什么用 &lt;code&gt;\b&lt;/code&gt; 进行单词边界搜索对我不起作用？</target>
        </trans-unit>
        <trans-unit id="123e5244abcc6475513e58c7be3baf1e624a09b7" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with \b work for me?</source>
          <target state="translated">為什麼我不能用字界搜索?</target>
        </trans-unit>
        <trans-unit id="aa0f337d4d9c4331ea81d21ad3497b56fec40614" translate="yes" xml:space="preserve">
          <source>Why dynamic linking?</source>
          <target state="translated">为什么要做动态链接?</target>
        </trans-unit>
        <trans-unit id="4dfd253727c4f99a421a3b97c6c33e70ca139825" translate="yes" xml:space="preserve">
          <source>Why is int() broken?</source>
          <target state="translated">为什么int()会坏掉?</target>
        </trans-unit>
        <trans-unit id="a9539bbca1f0e44580627232613c4e6433a9dda3" translate="yes" xml:space="preserve">
          <source>Why is there Perl source in my database?</source>
          <target state="translated">为什么我的数据库里有Perl源码?</target>
        </trans-unit>
        <trans-unit id="5376410df92e4e194b5ef26e3120b8356d39f687" translate="yes" xml:space="preserve">
          <source>Why isn't my octal data interpreted correctly?</source>
          <target state="translated">为什么我的八进制数据解释不正确?</target>
        </trans-unit>
        <trans-unit id="76e636f7e8860a670fadde05e6d7c8a9de0467dd" translate="yes" xml:space="preserve">
          <source>Why not just use &amp;lt;insert other build config tool here&amp;gt;?</source>
          <target state="translated">为什么不只使用&amp;lt;在此处插入其他构建配置工具&amp;gt;？</target>
        </trans-unit>
        <trans-unit id="8adf1b58b38027864f2d28cd98aeb834dee11ea7" translate="yes" xml:space="preserve">
          <source>Why strange names?</source>
          <target state="translated">为什么会有奇怪的名字?</target>
        </trans-unit>
        <trans-unit id="d2f963c70a1ed1fc561f572fe023203fb76a83ae" translate="yes" xml:space="preserve">
          <source>Why the heck Encode API is different?</source>
          <target state="translated">到底为什么Encode API不一样?</target>
        </trans-unit>
        <trans-unit id="2d967f841c57d824cac2c9266688fd2aa1c5db9c" translate="yes" xml:space="preserve">
          <source>Why use ppport.h?</source>
          <target state="translated">为什么使用pport.h?</target>
        </trans-unit>
        <trans-unit id="df4212a2d988730cb90863e6978ac9cd91d10bdc" translate="yes" xml:space="preserve">
          <source>Why would you want a hash of lists? Let's take a simple example: You have a file of city and country names, like this:</source>
          <target state="translated">为什么你会想要一个列表的哈希?让我们举个简单的例子。你有一个城市和国家名称的文件,像这样。</target>
        </trans-unit>
        <trans-unit id="7f3771c096b7c324730a1a8a01295eb54a206ffa" translate="yes" xml:space="preserve">
          <source>Why, you may ask, would you need a chunk of memory containing some values in binary representation? One good reason is input and output accessing some file, a device, or a network connection, whereby this binary representation is either forced on you or will give you some benefit in processing. Another cause is passing data to some system call that is not available as a Perl function: &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; requires you to provide parameters stored in the way it happens in a C program. Even text processing (as shown in the next section) may be simplified with judicious usage of these two functions.</source>
          <target state="translated">您可能会问，为什么需要一块包含一些二进制表示值的内存？一个很好的理由是输入和输出访问某些文件，设备或网络连接，这样，这种二进制表示形式要么强加于您，要么将给您带来一些处理上的好处。另一个原因是将数据传递给Perl函数无法使用的某些系统调用： &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 要求您提供以C程序中发生的方式存储的参数。通过明智地使用这两个功能，甚至可以简化文本处理（如下一节所示）。</target>
        </trans-unit>
        <trans-unit id="6ab0396ba481d1f15a966e8a80a53c0fff8a6b1e" translate="yes" xml:space="preserve">
          <source>Why, you may ask, would you need a chunk of memory containing some values in binary representation? One good reason is input and output accessing some file, a device, or a network connection, whereby this binary representation is either forced on you or will give you some benefit in processing. Another cause is passing data to some system call that is not available as a Perl function: &lt;code&gt;syscall&lt;/code&gt; requires you to provide parameters stored in the way it happens in a C program. Even text processing (as shown in the next section) may be simplified with judicious usage of these two functions.</source>
          <target state="translated">您可能会问，为什么需要一块包含一些二进制表示形式的值的内存？一个很好的理由是输入和输出访问某些文件，设备或网络连接，由此，这种二进制表示形式要么强加给您，要么将给您带来一些处理上的好处。另一个原因是将数据传递给Perl函数无法使用的某些系统调用： &lt;code&gt;syscall&lt;/code&gt; 要求您提供以C程序中发生的方式存储的参数。通过明智地使用这两个功能，甚至可以简化文本处理（如下一节所示）。</target>
        </trans-unit>
        <trans-unit id="d1b95af46a7dc5483f3c0502e26f80b536b33809" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;can&lt;/code&gt; returns a coderef to mean &quot;yes it can (and the method is this...)&quot;, and then &lt;code&gt;ok&lt;/code&gt; sees a coderef and thinks you're passing a function that you want it to call and consider the truth of the result of! I.e., just like:</source>
          <target state="translated">为什么？由于 &lt;code&gt;can&lt;/code&gt; 回报CODEREF表示&amp;ldquo;是的，它可以（和方法是这样的......）&amp;rdquo;，然后 &lt;code&gt;ok&lt;/code&gt; 看到了CODEREF并且认为你传递一个函数，你想它来调用，并考虑结果的真相的！即，就像：</target>
        </trans-unit>
        <trans-unit id="c682a5bde8a3f0f1d13f9a9af66f849014ab6208" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;nasty_break()&lt;/code&gt; modifies &lt;code&gt;$\&lt;/code&gt; without localizing it first. The value you set in &lt;code&gt;nasty_break()&lt;/code&gt; is still there when you return. The fix is to add &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; so the value doesn't leak out of &lt;code&gt;nasty_break()&lt;/code&gt; :</source>
          <target state="translated">为什么？因为 &lt;code&gt;nasty_break()&lt;/code&gt; 修改 &lt;code&gt;$\&lt;/code&gt; 而不先对其进行本地化。返回时，您在 &lt;code&gt;nasty_break()&lt;/code&gt; 中设置的值仍然存在。解决方法是添加 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; ,以便该值不会从 &lt;code&gt;nasty_break()&lt;/code&gt; 中泄漏出来：</target>
        </trans-unit>
        <trans-unit id="a6faa641a92e7908b2759e3d399e519a97396eeb" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;nasty_break()&lt;/code&gt; modifies &lt;code&gt;$\&lt;/code&gt; without localizing it first. The value you set in &lt;code&gt;nasty_break()&lt;/code&gt; is still there when you return. The fix is to add &lt;code&gt;local()&lt;/code&gt; so the value doesn't leak out of &lt;code&gt;nasty_break()&lt;/code&gt;:</source>
          <target state="translated">为什么？因为 &lt;code&gt;nasty_break()&lt;/code&gt; 修改 &lt;code&gt;$\&lt;/code&gt; 而不先对其进行本地化。返回时，您在 &lt;code&gt;nasty_break()&lt;/code&gt; 中设置的值仍然存在。解决方法是添加 &lt;code&gt;local()&lt;/code&gt; ,以便该值不会从 &lt;code&gt;nasty_break()&lt;/code&gt; 中泄漏出来：</target>
        </trans-unit>
        <trans-unit id="e2a097ba046d774750c25655e60293a973b6be9d" translate="yes" xml:space="preserve">
          <source>Wide character (U+%X) in %s</source>
          <target state="translated">宽字符(U+%X),以%s为单位。</target>
        </trans-unit>
        <trans-unit id="745ada6d8a512f870963c08fe697c0dd823de817" translate="yes" xml:space="preserve">
          <source>Wide character in %s</source>
          <target state="translated">宽字符(%s)</target>
        </trans-unit>
        <trans-unit id="59af40d4a351e635fdbe369d7b681d20a590a23a" translate="yes" xml:space="preserve">
          <source>Wildcard expansion</source>
          <target state="translated">通配符扩展</target>
        </trans-unit>
        <trans-unit id="47c9b4ee449bd8455aec29f4590e9aaa03c049f4" translate="yes" xml:space="preserve">
          <source>Wildcards in Property Values</source>
          <target state="translated">物业价值中的通配符</target>
        </trans-unit>
        <trans-unit id="70477b387f14e0143de5873f3a9e791508ea1046" translate="yes" xml:space="preserve">
          <source>Will My Old Scripts Break?</source>
          <target state="translated">我的旧脚本会不会坏掉?</target>
        </trans-unit>
        <trans-unit id="2873c6e6e5880b670c065bcdc4a78243fbadf06c" translate="yes" xml:space="preserve">
          <source>Will Sheppard &amp;lt;</source>
          <target state="translated">威尔&amp;middot;谢泼德&amp;lt;</target>
        </trans-unit>
        <trans-unit id="2758b8d4c9377404295cf137b65b7a19678f3231" translate="yes" xml:space="preserve">
          <source>Will add a file to the in-memory archive, with name &lt;code&gt;$filename&lt;/code&gt; and content &lt;code&gt;$data&lt;/code&gt; . Specific properties can be set using &lt;code&gt;$opthashref&lt;/code&gt; . The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type. (On MacOS, the file's path and modification times are converted to Unix equivalents.)</source>
          <target state="translated">会将文件添加到内存存档中，名称 &lt;code&gt;$filename&lt;/code&gt; ，内容 &lt;code&gt;$data&lt;/code&gt; 。可以使用 &lt;code&gt;$opthashref&lt;/code&gt; 设置特定属性。支持以下属性列表：名称，大小，mtime（上次修改日期），模式，uid，gid，链接名，uname，gname，devmajor，devminor，前缀，类型。（在MacOS上，文件的路径和修改时间将转换为Unix等效文件。）</target>
        </trans-unit>
        <trans-unit id="93e582e568148c77bec33609334f756f428deffa" translate="yes" xml:space="preserve">
          <source>Will add a file to the in-memory archive, with name &lt;code&gt;$filename&lt;/code&gt; and content &lt;code&gt;$data&lt;/code&gt;. Specific properties can be set using &lt;code&gt;$opthashref&lt;/code&gt;. The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type. (On MacOS, the file's path and modification times are converted to Unix equivalents.)</source>
          <target state="translated">会将文件添加到内存存档中，名称 &lt;code&gt;$filename&lt;/code&gt; ，内容 &lt;code&gt;$data&lt;/code&gt; 。可以使用 &lt;code&gt;$opthashref&lt;/code&gt; 设置特定属性。支持以下属性列表：名称，大小，mtime（上次修改日期），模式，uid，gid，链接名，uname，gname，devmajor，devminor，前缀，类型。（在MacOS上，文件的路径和修改时间将转换为Unix等效文件。）</target>
        </trans-unit>
        <trans-unit id="af66cccfd8aea183b531eebc0a74a7e923052ebf" translate="yes" xml:space="preserve">
          <source>Will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. (See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 时将被调用。（请参阅&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;下面的解开陷阱&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="3135cfa6b9641d632048427137e9d839208222a7" translate="yes" xml:space="preserve">
          <source>Will be called when &lt;code&gt;untie&lt;/code&gt; happens. (See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&quot;The &lt;code&gt;untie&lt;/code&gt; Gotcha&quot;&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;untie&lt;/code&gt; 时将被调用。（请参阅下面的&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&amp;ldquo; &lt;code&gt;untie&lt;/code&gt; Gotcha&amp;rdquo;&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="5c123e132f25bf178be9ea2aca72fafe2969081c" translate="yes" xml:space="preserve">
          <source>Will be loaded on demand and called automatically by BigInt.</source>
          <target state="translated">将按需加载,由BigInt自动调用。</target>
        </trans-unit>
        <trans-unit id="a669aaf9a433f6903c152ca38a90c9c7cb258f3e" translate="yes" xml:space="preserve">
          <source>Will be prepended to each install path.</source>
          <target state="translated">将被预置到每个安装路径中。</target>
        </trans-unit>
        <trans-unit id="4532ff2be2d0615be4c0aa19707d4e886e5a1789" translate="yes" xml:space="preserve">
          <source>Will be set to a uuid if uuid tagging was enabled.</source>
          <target state="translated">如果启用uuid标签,将被设置为uuid。</target>
        </trans-unit>
        <trans-unit id="9f18d29650d7b716edb7780278b512b0a8a59170" translate="yes" xml:space="preserve">
          <source>Will be used to modify the padding applied to string as described above.</source>
          <target state="translated">将用于修改应用于字符串的padding,如上所述。</target>
        </trans-unit>
        <trans-unit id="4e827c2a869b099543f874a4407588358567998d" translate="yes" xml:space="preserve">
          <source>Will both leave the sentence as is. Normally, when accepting literal string input from the user, &lt;a href=&quot;#quotemeta-EXPR&quot;&gt;&lt;code&gt;quotemeta&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;\Q&lt;/code&gt; must be used.</source>
          <target state="translated">都将原样保留该句子。通常，当接受来自用户的文字字符串输入时，必须使用&lt;a href=&quot;#quotemeta-EXPR&quot;&gt; &lt;code&gt;quotemeta&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;\Q&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a659ce6bd28efeb251560042f49a1924dca7c4a4" translate="yes" xml:space="preserve">
          <source>Will both leave the sentence as is. Normally, when accepting literal string input from the user, quotemeta() or &lt;code&gt;\Q&lt;/code&gt; must be used.</source>
          <target state="translated">都将原样保留该句子。通常，当接受来自用户的文字字符串输入时，必须使用quotemeta（）或 &lt;code&gt;\Q&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10fbb1ac2af71320cfd2110a94f422695cba5311" translate="yes" xml:space="preserve">
          <source>Will cause &lt;code&gt;$sentence&lt;/code&gt; to become &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; .</source>
          <target state="translated">将导致 &lt;code&gt;$sentence&lt;/code&gt; 成为 &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10dc8768858451ca68c298fbc7a5ad46babe9c5d" translate="yes" xml:space="preserve">
          <source>Will cause &lt;code&gt;$sentence&lt;/code&gt; to become &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt;.</source>
          <target state="translated">将导致 &lt;code&gt;$sentence&lt;/code&gt; 成为 &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66fbedfbffb0f55bc116220f01908ca58f12e965" translate="yes" xml:space="preserve">
          <source>Will croak() if there is an error.</source>
          <target state="translated">如果出现错误,会呱呱叫()。</target>
        </trans-unit>
        <trans-unit id="a89e6d7112dafb5b2ad3a46406c0ced36b7d13b7" translate="yes" xml:space="preserve">
          <source>Will die() if called on r-magic.</source>
          <target state="translated">如果在r-magic上调用,会死()。</target>
        </trans-unit>
        <trans-unit id="0768298b9a0627e90df27324883d97a236031b2a" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Handy for things like...</source>
          <target state="translated">会以人类可读的格式转储任何参考资料的内容。很方便,比如...</target>
        </trans-unit>
        <trans-unit id="481a8de568a61f103c3af4da9f82b1f103a46712" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Usually you want to pass this into &lt;code&gt;note&lt;/code&gt; or &lt;code&gt;diag&lt;/code&gt; .</source>
          <target state="translated">将以人类可读的格式转储任何引用的内容。通常，您要将其传递给 &lt;code&gt;note&lt;/code&gt; 或 &lt;code&gt;diag&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdc14d4349b2640a0197394413323e6c4dc94091" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Usually you want to pass this into &lt;code&gt;note&lt;/code&gt; or &lt;code&gt;diag&lt;/code&gt;.</source>
          <target state="translated">将以人类可读的格式转储任何引用的内容。通常，您要将其传递给 &lt;code&gt;note&lt;/code&gt; 或 &lt;code&gt;diag&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75f83221407c4472808dc0bb2139500f5229338d" translate="yes" xml:space="preserve">
          <source>Will force the generation of test code that uses the older &lt;code&gt;Test&lt;/code&gt; module.</source>
          <target state="translated">将强制使用较早的 &lt;code&gt;Test&lt;/code&gt; 模块生成测试代码。</target>
        </trans-unit>
        <trans-unit id="a329a554ce0cef11ca3198cc6cf9ba23c8d4f77f" translate="yes" xml:space="preserve">
          <source>Will incorrectly print</source>
          <target state="translated">会错误地打印</target>
        </trans-unit>
        <trans-unit id="fe4d3313b3f93ee1361d2d67710393a85713398e" translate="yes" xml:space="preserve">
          <source>Will invoke a sub at the end of a (compile-time) scope. The sub is called once with no arguments. Can be called multiple times (even in the same &quot;compile-time&quot; scope) to install multiple subs. Subs are called in a &quot;first-in-last-out&quot;-order (FILO or &quot;stack&quot;-order).</source>
          <target state="translated">将在(编译时)作用域的最后调用一个子。这个子被调用一次,没有参数。可以多次调用(甚至在同一个 &quot;编译时 &quot;作用域中)以安装多个子。子的调用是以 &quot;先入为主 &quot;的顺序进行的(FILO或 &quot;stack &quot;顺序)。</target>
        </trans-unit>
        <trans-unit id="c610d24bbac520a7e0e174e12fe1f23a3ae5f9e4" translate="yes" xml:space="preserve">
          <source>Will make sure that =head1 will become &amp;lt;h3&amp;gt; and =head2 will become &amp;lt;h4&amp;gt; etc...</source>
          <target state="translated">将确保= head1将变为&amp;lt;h3&amp;gt;并且= head2将变为&amp;lt;h4&amp;gt;等等...</target>
        </trans-unit>
        <trans-unit id="49024b4120de3dd67c62575e0a4eb5f193ed6c22" translate="yes" xml:space="preserve">
          <source>Will not cause &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; to re-read the directory stream. The entries already read before the &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; call will just be returned again from a cache buffer. (Win32)</source>
          <target state="translated">不会导致 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 重新读取目录流。在 &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; 调用之前已读取的条目将仅从缓存缓冲区中再次返回。（Win32的）</target>
        </trans-unit>
        <trans-unit id="845d623fd40095b89ded11a672446e7d8d2933f3" translate="yes" xml:space="preserve">
          <source>Will not exceed this limit even if the string is not valid &quot;UTF-8&quot;.</source>
          <target state="translated">即使字符串不是有效的 &quot;UTF-8&quot;,也不会超过这个限制。</target>
        </trans-unit>
        <trans-unit id="7706e40a252d341368a094f13349cb965c7bcf44" translate="yes" xml:space="preserve">
          <source>Will not exceed those limits even if the string is not valid &quot;UTF-8&quot;.</source>
          <target state="translated">即使字符串不是有效的 &quot;UTF-8&quot;,也不会超过这些限制。</target>
        </trans-unit>
        <trans-unit id="0b4b57e33203662ee1ddac498725ec0cbd902da5" translate="yes" xml:space="preserve">
          <source>Will not work on platforms that do not support the &lt;code&gt;-k&lt;/code&gt; test for sticky bit.</source>
          <target state="translated">在不支持 &lt;code&gt;-k&lt;/code&gt; 测试粘性位的平台上将不起作用。</target>
        </trans-unit>
        <trans-unit id="aff13c5ad9d691f5f29f20db0a92fc55a16499de" translate="yes" xml:space="preserve">
          <source>Will not work on platforms that do not support the C test for sticky bit.</source>
          <target state="translated">在不支持C测试的平台上将无法使用粘性位。</target>
        </trans-unit>
        <trans-unit id="19ad79cf64559535aa01bc2039517ce48ed1f305" translate="yes" xml:space="preserve">
          <source>Will output 2, not 1. This is particularly important if you intend to compile the definitions with the &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator, and later interpolate them in another pattern.</source>
          <target state="translated">将输出2，而不是1。如果要使用 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 运算符编译定义，然后以另一种模式内插它们，则这尤其重要。</target>
        </trans-unit>
        <trans-unit id="d7ba12340e687f11ed70710aaea6e46b38d77b8f" translate="yes" xml:space="preserve">
          <source>Will output 2, not 1. This is particularly important if you intend to compile the definitions with the &lt;code&gt;qr//&lt;/code&gt; operator, and later interpolate them in another pattern.</source>
          <target state="translated">将输出2，而不是1。如果要使用 &lt;code&gt;qr//&lt;/code&gt; 运算符编译定义，然后以另一种模式插值，则这尤其重要。</target>
        </trans-unit>
        <trans-unit id="10021ccb8e306fb831263dee40b8f7ca24084b5a" translate="yes" xml:space="preserve">
          <source>Will prevent the automatic use of INSTALL.SKIP as the install skip file.</source>
          <target state="translated">将防止自动使用INSTALL.SKIP作为安装跳过文件。</target>
        </trans-unit>
        <trans-unit id="897aeeccb9736732e15f96f20d971e76dcd3a8ff" translate="yes" xml:space="preserve">
          <source>Will print &lt;code&gt;2&lt;/code&gt; , because &lt;code&gt;$string&lt;/code&gt; is upgraded as UTF-8. Without &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; , it will print &lt;code&gt;4&lt;/code&gt; instead, since &lt;code&gt;$string&lt;/code&gt; is three octets when interpreted as Latin-1.</source>
          <target state="translated">将打印 &lt;code&gt;2&lt;/code&gt; ，因为 &lt;code&gt;$string&lt;/code&gt; 已升级为UTF-8。不 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; ，它将改为打印 &lt;code&gt;4&lt;/code&gt; ，因为当解释为Latin-1时 &lt;code&gt;$string&lt;/code&gt; 是三个八位字节。</target>
        </trans-unit>
        <trans-unit id="c7912cc2705e39fd55074c6583f91d53d1be3b82" translate="yes" xml:space="preserve">
          <source>Will print &lt;code&gt;2&lt;/code&gt;, because &lt;code&gt;$string&lt;/code&gt; is upgraded as UTF-8. Without &lt;code&gt;use encoding 'utf8';&lt;/code&gt;, it will print &lt;code&gt;4&lt;/code&gt; instead, since &lt;code&gt;$string&lt;/code&gt; is three octets when interpreted as Latin-1.</source>
          <target state="translated">将打印 &lt;code&gt;2&lt;/code&gt; ，因为 &lt;code&gt;$string&lt;/code&gt; 已升级为UTF-8。不 &lt;code&gt;use encoding 'utf8';&lt;/code&gt; ，它将改为打印 &lt;code&gt;4&lt;/code&gt; ，因为当解释为Latin-1时， &lt;code&gt;$string&lt;/code&gt; 是三个八位字节。</target>
        </trans-unit>
        <trans-unit id="ceca318096ebec569ca5ded9c24fde055f72cece" translate="yes" xml:space="preserve">
          <source>Will print just the value of &lt;code&gt;$x&lt;/code&gt;, believing that &lt;code&gt;$y&lt;/code&gt; is a numerically- equivalent value. This bug does not affect &lt;code&gt;uniqstr()&lt;/code&gt;, which will correctly observe that the two values stringify to different strings.</source>
          <target state="translated">将仅打印 &lt;code&gt;$x&lt;/code&gt; 的值，并认为 &lt;code&gt;$y&lt;/code&gt; 是数值等效的值。此错误不会影响 &lt;code&gt;uniqstr()&lt;/code&gt; ，它将正确地观察到两个值字符串化为不同的字符串。</target>
        </trans-unit>
        <trans-unit id="f950740e9c08c94cdc9c22017e9c8d9e11964004" translate="yes" xml:space="preserve">
          <source>Will produce something like this:</source>
          <target state="translated">会产生这样的东西。</target>
        </trans-unit>
        <trans-unit id="73c023c285973466729ee2bf21a0f578281a6002" translate="yes" xml:space="preserve">
          <source>Will return a list of two sockets created (read and write), or an empty list on failure.</source>
          <target state="translated">将返回一个创建的两个套接字的列表(读和写),或者失败时返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="b2e73c78b5d339922fd7fb53696709fc79fcc290" translate="yes" xml:space="preserve">
          <source>Will use &lt;a href=&quot;TAP::Harness::Archive&quot;&gt;TAP::Harness::Archive&lt;/a&gt; as the harness class, and save the TAP to &lt;code&gt;file.tgz&lt;/code&gt;</source>
          <target state="translated">将使用&lt;a href=&quot;TAP::Harness::Archive&quot;&gt;TAP :: Harness :: Archive&lt;/a&gt;作为线束类，并将TAP保存到 &lt;code&gt;file.tgz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db8fa98164c98267f0158f423a3da70d388112fe" translate="yes" xml:space="preserve">
          <source>Will use &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP::Harness::Archive&lt;/a&gt; as the harness class, and save the TAP to &lt;code&gt;file.tgz&lt;/code&gt;</source>
          <target state="translated">将使用&lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP :: Harness :: Archive&lt;/a&gt;作为线束类，并将TAP保存到 &lt;code&gt;file.tgz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b653c1a1342f29b6e1ca16ef44b1d14c98a11e3" translate="yes" xml:space="preserve">
          <source>Win32</source>
          <target state="translated">Win32</target>
        </trans-unit>
        <trans-unit id="193cb801459c22b68d471c2735c8916bade862e2" translate="yes" xml:space="preserve">
          <source>Win32 - Interfaces to some Win32 API Functions</source>
          <target state="translated">Win32-一些Win32 API函数的接口</target>
        </trans-unit>
        <trans-unit id="d2fdadddae42eb18256ba3d6c7445968142a4fd2" translate="yes" xml:space="preserve">
          <source>Win32 CORE function stubs</source>
          <target state="translated">Win32 CORE函数存根</target>
        </trans-unit>
        <trans-unit id="0cab5c56f7d1ce7bc278eb6ee5c4a8575346a7ef" translate="yes" xml:space="preserve">
          <source>Win32 implementation</source>
          <target state="translated">Win32执行</target>
        </trans-unit>
        <trans-unit id="c331f9a552ce93a52bd3bbd4fbac9c58a662301b" translate="yes" xml:space="preserve">
          <source>Win32 support for Sys::Syslog</source>
          <target state="translated">Win32对Sys::Syslog的支持。</target>
        </trans-unit>
        <trans-unit id="263a800b140dc4fe3448979f4261e583bcee830e" translate="yes" xml:space="preserve">
          <source>Win32 users should use the real slash. If you really want to use backslashes, consider using Sarathy's File::DosGlob, which comes with the standard Perl distribution.</source>
          <target state="translated">Win32用户应该使用真正的斜线。如果你真的想使用反斜线,可以考虑使用 Sarathy 的 File::DosGlob,它是标准的 Perl 发行版。</target>
        </trans-unit>
        <trans-unit id="6d0e1038c340ca3cf2b59ac852b5f2ef7407e5c9" translate="yes" xml:space="preserve">
          <source>Win32::AbortSystemShutdown(MACHINE)</source>
          <target state="translated">Win32::AbortSystemShutdown(MACHINE)</target>
        </trans-unit>
        <trans-unit id="6f12fa420b1205100cabb4570f237b3d345d86ca" translate="yes" xml:space="preserve">
          <source>Win32::BuildNumber()</source>
          <target state="translated">Win32::BuildNumber()</target>
        </trans-unit>
        <trans-unit id="99f20893b3ea998d83c35a43b1ddcaefd97d6b9f" translate="yes" xml:space="preserve">
          <source>Win32::CopyFile(FROM, TO, OVERWRITE)</source>
          <target state="translated">Win32::复制文件(FROM,TO,OVERWRITE)</target>
        </trans-unit>
        <trans-unit id="d269bfa64c0a58bda1986a24d2c54a63190e288a" translate="yes" xml:space="preserve">
          <source>Win32::CreateDirectory(DIRECTORY)</source>
          <target state="translated">Win32::CreateDirectory(DIRECTORY)</target>
        </trans-unit>
        <trans-unit id="7a7983d24568164c28a76c5bb077686f88dad153" translate="yes" xml:space="preserve">
          <source>Win32::CreateFile(FILE)</source>
          <target state="translated">Win32::CreateFile(FILE)</target>
        </trans-unit>
        <trans-unit id="fa7c1f0bbed5b785d5607e1311dcb11968fd8fe9" translate="yes" xml:space="preserve">
          <source>Win32::DomainName()</source>
          <target state="translated">Win32::DomainName()</target>
        </trans-unit>
        <trans-unit id="1c453bb935414d8146aa602c45dd5159dab45ade" translate="yes" xml:space="preserve">
          <source>Win32::ExpandEnvironmentStrings(STRING)</source>
          <target state="translated">Win32::ExpandEnvironmentStrings(STRING)</target>
        </trans-unit>
        <trans-unit id="88134ad369f40cbd5ed8e6414b571501a615d721" translate="yes" xml:space="preserve">
          <source>Win32::FormatMessage(ERRORCODE)</source>
          <target state="translated">Win32::FormatMessage(ERRORCODE)</target>
        </trans-unit>
        <trans-unit id="02c33521b3e0cfb9be57585db645c4568be060cf" translate="yes" xml:space="preserve">
          <source>Win32::FreeLibrary(HANDLE)</source>
          <target state="translated">Win32::FreeLibrary(HANDLE)</target>
        </trans-unit>
        <trans-unit id="ec6d95684a511580632674e1e5dce99eca02ed2c" translate="yes" xml:space="preserve">
          <source>Win32::FsType()</source>
          <target state="translated">Win32::FsType()</target>
        </trans-unit>
        <trans-unit id="fdfbfe52059c529a42a7f79b351a29683dd786d2" translate="yes" xml:space="preserve">
          <source>Win32::GUI</source>
          <target state="translated">Win32::GUI</target>
        </trans-unit>
        <trans-unit id="cc575cb0ebbd64ea43f9c9ccc56237b0705f9732" translate="yes" xml:space="preserve">
          <source>Win32::GetACP()</source>
          <target state="translated">Win32::GetACP()</target>
        </trans-unit>
        <trans-unit id="7798f250e449938fcf7dadf70c029ad54f636245" translate="yes" xml:space="preserve">
          <source>Win32::GetANSIPathName(FILENAME)</source>
          <target state="translated">Win32::GetANSIPathName(FILENAME)</target>
        </trans-unit>
        <trans-unit id="58ac17861a87852820b146e725b1e3c3e23cbe3e" translate="yes" xml:space="preserve">
          <source>Win32::GetArchName()</source>
          <target state="translated">Win32::GetArchName()</target>
        </trans-unit>
        <trans-unit id="3834fcd21d4e7fa28d350d64b78639660bbeb2c1" translate="yes" xml:space="preserve">
          <source>Win32::GetChipName()</source>
          <target state="translated">Win32::GetChipName()</target>
        </trans-unit>
        <trans-unit id="202596ea6840cbe9f281840b431aa41aec8424c4" translate="yes" xml:space="preserve">
          <source>Win32::GetConsoleCP()</source>
          <target state="translated">Win32::GetConsoleCP()</target>
        </trans-unit>
        <trans-unit id="8aaff4afc4c9f3d83ba6558614d36b7f40e38e33" translate="yes" xml:space="preserve">
          <source>Win32::GetConsoleOutputCP()</source>
          <target state="translated">Win32::GetConsoleOutputCP()</target>
        </trans-unit>
        <trans-unit id="ebc6f60b70df25fd8c32e53de9a7c9ba577f15ee" translate="yes" xml:space="preserve">
          <source>Win32::GetCurrentProcessId()</source>
          <target state="translated">Win32::GetCurrentProcessId()</target>
        </trans-unit>
        <trans-unit id="41cb4ff89334195c85ec80a4293eee0fe84b1c77" translate="yes" xml:space="preserve">
          <source>Win32::GetCurrentThreadId()</source>
          <target state="translated">Win32::GetCurrentThreadId()</target>
        </trans-unit>
        <trans-unit id="06fb2ae0e34c762652f91cc4b24d288d543148dd" translate="yes" xml:space="preserve">
          <source>Win32::GetCwd()</source>
          <target state="translated">Win32::GetCwd()</target>
        </trans-unit>
        <trans-unit id="424bc0808437c0c40f8b8eca83c71486de0c2ce3" translate="yes" xml:space="preserve">
          <source>Win32::GetFileVersion(FILENAME)</source>
          <target state="translated">Win32::GetFileVersion(FILENAME)</target>
        </trans-unit>
        <trans-unit id="bd89672cc22e170bdb15759f5b2c202ee866d3af" translate="yes" xml:space="preserve">
          <source>Win32::GetFolderPath(FOLDER [, CREATE])</source>
          <target state="translated">Win32::GetFolderPath(FOLDER [,CREATE])</target>
        </trans-unit>
        <trans-unit id="f7750debc5964ef700caa1d205774c5c516e86b5" translate="yes" xml:space="preserve">
          <source>Win32::GetFullPathName(FILENAME)</source>
          <target state="translated">Win32::GetFullPathName(FILENAME)</target>
        </trans-unit>
        <trans-unit id="1779b4a74c4e9c74750b4883d1c3a13e7f082821" translate="yes" xml:space="preserve">
          <source>Win32::GetLastError()</source>
          <target state="translated">Win32::GetLastError()</target>
        </trans-unit>
        <trans-unit id="c1d2be25cd4c6103e621d159ba09f9b5f7b7f66d" translate="yes" xml:space="preserve">
          <source>Win32::GetLongPathName(PATHNAME)</source>
          <target state="translated">Win32::GetLongPathName(PATHNAME)</target>
        </trans-unit>
        <trans-unit id="9a5b08237dd1d9c044b42e330417a8ee6c2fddc5" translate="yes" xml:space="preserve">
          <source>Win32::GetNextAvailDrive()</source>
          <target state="translated">Win32::GetNextAvailDrive()</target>
        </trans-unit>
        <trans-unit id="424731cf281e1dda51d3e9681cc85bb2740bbe76" translate="yes" xml:space="preserve">
          <source>Win32::GetOEMCP()</source>
          <target state="translated">Win32::GetOEMCP()</target>
        </trans-unit>
        <trans-unit id="1015f265e18dde79b1939bf46d05753e1cb1fc0a" translate="yes" xml:space="preserve">
          <source>Win32::GetOSDisplayName()</source>
          <target state="translated">Win32::GetOSDisplayName()</target>
        </trans-unit>
        <trans-unit id="e9e643f122af1698a8771b07d042a8eb421add6b" translate="yes" xml:space="preserve">
          <source>Win32::GetOSName()</source>
          <target state="translated">Win32::GetOSName()</target>
        </trans-unit>
        <trans-unit id="9ac415285a2a80e417f87a22967bf20ef2c63935" translate="yes" xml:space="preserve">
          <source>Win32::GetOSVersion()</source>
          <target state="translated">Win32::GetOSVersion()</target>
        </trans-unit>
        <trans-unit id="bbb14f64d25ca5875dac81a570aa2578d64fe870" translate="yes" xml:space="preserve">
          <source>Win32::GetProcAddress(INSTANCE, PROCNAME)</source>
          <target state="translated">Win32::GetProcAddress(INSTANCE,PROCNAME)</target>
        </trans-unit>
        <trans-unit id="0d4519c40934e76bc7c24e8acfe3fe14ba43d63f" translate="yes" xml:space="preserve">
          <source>Win32::GetProductInfo(OSMAJOR, OSMINOR, SPMAJOR, SPMINOR)</source>
          <target state="translated">Win32::GetProductInfo(OSMAJOR,OSMINOR,SPMAJOR,SPMINOR)</target>
        </trans-unit>
        <trans-unit id="976bea2f0bcf19569dea7f3dcd696ad17b85b2c9" translate="yes" xml:space="preserve">
          <source>Win32::GetShortPathName(PATHNAME)</source>
          <target state="translated">Win32::GetShortPathName(PATHNAME)</target>
        </trans-unit>
        <trans-unit id="85686486692a83787d94a67516a3d3724180155d" translate="yes" xml:space="preserve">
          <source>Win32::GetSystemMetrics(INDEX)</source>
          <target state="translated">Win32::GetSystemMetrics(INDEX)</target>
        </trans-unit>
        <trans-unit id="da2531353eddaf6094a844bf9d9cb759ae2af1e8" translate="yes" xml:space="preserve">
          <source>Win32::GetTickCount()</source>
          <target state="translated">Win32::GetTickCount()</target>
        </trans-unit>
        <trans-unit id="ae35ac71f2f974fbd4820718cb015468050c4f6c" translate="yes" xml:space="preserve">
          <source>Win32::GuidGen()</source>
          <target state="translated">Win32::GuidGen()</target>
        </trans-unit>
        <trans-unit id="6c1bb229532a2f942fc09792beca570bb3feca1b" translate="yes" xml:space="preserve">
          <source>Win32::InitiateSystemShutdown</source>
          <target state="translated">Win32::InitiateSystemShutdown</target>
        </trans-unit>
        <trans-unit id="f9fa2b44699da87d011d8d62354503f774420ab1" translate="yes" xml:space="preserve">
          <source>Win32::IsAdminUser()</source>
          <target state="translated">Win32::IsAdminUser()</target>
        </trans-unit>
        <trans-unit id="fe185f7f6aa0888454156f6b1dd0647b97f1c985" translate="yes" xml:space="preserve">
          <source>Win32::IsWin95()</source>
          <target state="translated">Win32::IsWin95()</target>
        </trans-unit>
        <trans-unit id="1f8c102705f38e11ded9cb1693b6ba04ed8d2aac" translate="yes" xml:space="preserve">
          <source>Win32::IsWinNT()</source>
          <target state="translated">Win32::IsWinNT()</target>
        </trans-unit>
        <trans-unit id="75e8f5dee14a6d1c4d34f99cde2cd05959a202c6" translate="yes" xml:space="preserve">
          <source>Win32::LoadLibrary(LIBNAME)</source>
          <target state="translated">Win32::LoadLibrary(LIBNAME)</target>
        </trans-unit>
        <trans-unit id="33e6daf26026220d0161fea28893d1e652b68f17" translate="yes" xml:space="preserve">
          <source>Win32::LoginName()</source>
          <target state="translated">Win32::LoginName()</target>
        </trans-unit>
        <trans-unit id="b7203bf8251626a9d020ee5f4922ecd6ff013788" translate="yes" xml:space="preserve">
          <source>Win32::LookupAccountName(SYSTEM, ACCOUNT, DOMAIN, SID, SIDTYPE)</source>
          <target state="translated">Win32::LookupAccountName(SYSTEM,ACCOUNT,DOMAIN,SID,SIDTYPE)</target>
        </trans-unit>
        <trans-unit id="e02105130675ffb73c863f2651d7886f32ce699c" translate="yes" xml:space="preserve">
          <source>Win32::LookupAccountSID(SYSTEM, SID, ACCOUNT, DOMAIN, SIDTYPE)</source>
          <target state="translated">Win32::LookupAccountSID(SYSTEM,SID,ACCOUNT,DOMAIN,SIDTYPE)</target>
        </trans-unit>
        <trans-unit id="c0b3757407e5968fe8497224d610a6b05e0fb867" translate="yes" xml:space="preserve">
          <source>Win32::MsgBox(MESSAGE [, FLAGS [, TITLE]])</source>
          <target state="translated">Win32::MsgBox(MESSAGE [,FLAGS [,TITLE]])</target>
        </trans-unit>
        <trans-unit id="e3c6c757d1a1e7f6e540ff3306434ee9703babbe" translate="yes" xml:space="preserve">
          <source>Win32::NodeName()</source>
          <target state="translated">Win32::NodeName()</target>
        </trans-unit>
        <trans-unit id="2712cf0c3d41deb65f7212a8f31b3f82a4ae6a9e" translate="yes" xml:space="preserve">
          <source>Win32::OutputDebugString(STRING)</source>
          <target state="translated">Win32::OutputDebugString(STRING)</target>
        </trans-unit>
        <trans-unit id="75ef631d3c7ea178f0c26bc47d12483cd8c3ea5d" translate="yes" xml:space="preserve">
          <source>Win32::RegisterServer(LIBRARYNAME)</source>
          <target state="translated">Win32::RegisterServer(LIBRARYNAME)</target>
        </trans-unit>
        <trans-unit id="ce0d098c41c01fd9b4d42374933b719c4874605c" translate="yes" xml:space="preserve">
          <source>Win32::SetChildShowWindow(SHOWWINDOW)</source>
          <target state="translated">Win32::SetChildShowWindow(SHOWWINDOW)</target>
        </trans-unit>
        <trans-unit id="6ec2ec156820380d471d8b8902107f69d0c48aac" translate="yes" xml:space="preserve">
          <source>Win32::SetConsoleCP(ID)</source>
          <target state="translated">Win32::SetConsoleCP(ID)</target>
        </trans-unit>
        <trans-unit id="d56fdac00362d0844cebe19c2fbea7797556a862" translate="yes" xml:space="preserve">
          <source>Win32::SetConsoleOutputCP(ID)</source>
          <target state="translated">Win32::SetConsoleOutputCP(ID)</target>
        </trans-unit>
        <trans-unit id="8ff2683659839e8f5dba46b5d4a8ac3aa4a62e14" translate="yes" xml:space="preserve">
          <source>Win32::SetCwd(NEWDIRECTORY)</source>
          <target state="translated">Win32::SetCwd(NEWDIRECTORY)</target>
        </trans-unit>
        <trans-unit id="721ad14df20038a886cdbbad6ec515e2dfd8ef41" translate="yes" xml:space="preserve">
          <source>Win32::SetLastError(ERROR)</source>
          <target state="translated">Win32::SetLastError(ERROR)</target>
        </trans-unit>
        <trans-unit id="70d34dd79a3d13ab005b5f95a3a341dc634b545c" translate="yes" xml:space="preserve">
          <source>Win32::Sleep(TIME)</source>
          <target state="translated">Win32::Sleep(TIME)</target>
        </trans-unit>
        <trans-unit id="0bd78719dddc468413b0b8cae64f7604c9b0760f" translate="yes" xml:space="preserve">
          <source>Win32::Spawn(COMMAND, ARGS, PID)</source>
          <target state="translated">Win32::Spawn(COMMAND,ARGS,PID)</target>
        </trans-unit>
        <trans-unit id="55cf1f14b3a9fb47a3d099c943c81a86f3bab76e" translate="yes" xml:space="preserve">
          <source>Win32::UnregisterServer(LIBRARYNAME)</source>
          <target state="translated">Win32::UnregisterServer(LIBRARYNAME)</target>
        </trans-unit>
        <trans-unit id="aa21f521370d6a588509094452635266c4468ce9" translate="yes" xml:space="preserve">
          <source>Win32API::File</source>
          <target state="translated">Win32API::File</target>
        </trans-unit>
        <trans-unit id="88c0b190dbad57a17cc677f51fa9c1ba74db87d0" translate="yes" xml:space="preserve">
          <source>Win32API::File - Low-level access to Win32 system API calls for files/dirs.</source>
          <target state="translated">Win32API::File-对Win32系统API调用文件/目录的低级访问。</target>
        </trans-unit>
        <trans-unit id="b0a0edd9f797c147e0eca61b93c9942a6aada686" translate="yes" xml:space="preserve">
          <source>Win32CORE</source>
          <target state="translated">Win32CORE</target>
        </trans-unit>
        <trans-unit id="674b29c781e27ee904b0a31e2bca19f160dacd50" translate="yes" xml:space="preserve">
          <source>Win32CORE - Win32 CORE function stubs</source>
          <target state="translated">Win32CORE-Win32 CORE函数存根。</target>
        </trans-unit>
        <trans-unit id="823301860ab873ab455e9a7adb1aa457e7019586" translate="yes" xml:space="preserve">
          <source>Win32CORE was created to provide on cygwin those Win32:: functions that for regular win32 builds were provided by default in perl. In cygwin perl releases prior to 5.8.6, this module was standalone and had to be explicitly used. In 5.8.6 and later, it was statically linked into cygwin perl so this would no longer be necessary.</source>
          <target state="translated">Win32CORE 的创建是为了在 cygwin 上提供那些常规 win32 编译中默认提供的 Win32::函数。在5.8.6之前的cygwin perl版本中,这个模块是独立的,必须明确使用。在5.8.6及以后的版本中,它被静态地链接到cygwin perl中,因此不再需要这样做。</target>
        </trans-unit>
        <trans-unit id="a64d38eb25949cf47b772e208780c5548dc84962" translate="yes" xml:space="preserve">
          <source>Win95 and Win98 and WinME are collectively Win9x and Win32</source>
          <target state="translated">Win95和Win98以及WinME是Win9x和Win32的统称。</target>
        </trans-unit>
        <trans-unit id="ea8db18a138027d52bc49a4789f983c73ef0f94f" translate="yes" xml:space="preserve">
          <source>Win95/NT</source>
          <target state="translated">Win95/NT</target>
        </trans-unit>
        <trans-unit id="38d123584917edd3d65a1c41ab99a9088beb8b64" translate="yes" xml:space="preserve">
          <source>Win98 chokes on things like Encode if we set the max length to nmake's max of 2K. So we go for a more conservative value of 1K.</source>
          <target state="translated">如果我们将最大长度设置为nmake的最大2K,Win98会对Encode这样的东西产生窒息。所以我们选择一个比较保守的值1K。</target>
        </trans-unit>
        <trans-unit id="7e7afec2ee076635c5bdb3c20b397b563733e6cf" translate="yes" xml:space="preserve">
          <source>Win9x and &lt;code&gt;d_eofnblk&lt;/code&gt;</source>
          <target state="translated">Win9x和 &lt;code&gt;d_eofnblk&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcb6e2235a0d088883e2901a983ef0e7377f83c0" translate="yes" xml:space="preserve">
          <source>Win9x can not &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; an open file (although WinNT can).</source>
          <target state="translated">Win9x无法 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; 打开的文件（尽管WinNT可以）。</target>
        </trans-unit>
        <trans-unit id="de40f5b5690a0bb23e1bf760363cb6a5e8443821" translate="yes" xml:space="preserve">
          <source>Win9x can not &lt;code&gt;rename()&lt;/code&gt; an open file (although WinNT can).</source>
          <target state="translated">Win9x不能 &lt;code&gt;rename()&lt;/code&gt; 打开的文件重命名（）（尽管WinNT可以）。</target>
        </trans-unit>
        <trans-unit id="1865487f835d74c1a32dc51f7e3fd10d2bb1c87c" translate="yes" xml:space="preserve">
          <source>Win9x does not correctly report &lt;code&gt;EOF&lt;/code&gt; with a non-blocking read on a closed pipe. You will see the following messages:</source>
          <target state="translated">Win9x不能正确报告 &lt;code&gt;EOF&lt;/code&gt; ，并且在封闭的管道上进行非阻塞读取。您将看到以下消息：</target>
        </trans-unit>
        <trans-unit id="468c4f1d38914eeba7915aa856cfac9060a7a5fe" translate="yes" xml:space="preserve">
          <source>Win9x support was added in 5.6 (Benjamin Stuhl).</source>
          <target state="translated">5.6中增加了对Win9x的支持(Benjamin Stuhl)。</target>
        </trans-unit>
        <trans-unit id="38c0fc63bcb91fe3116f8590745de1626f0dd16a" translate="yes" xml:space="preserve">
          <source>WinDisk.exe</source>
          <target state="translated">WinDisk.exe</target>
        </trans-unit>
        <trans-unit id="c816e89ffa10335823ff2ffbfd171adf35cada45" translate="yes" xml:space="preserve">
          <source>WinError.h</source>
          <target state="translated">WinError.h</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="bf4f5bc6b10d099fc4024cb19c3bd9cf757e522e" translate="yes" xml:space="preserve">
          <source>Windows .NET Server supports the LLP64 data model on the Intel Itanium architecture.</source>
          <target state="translated">Windows .NET Server支持Intel Itanium架构上的LLP64数据模型。</target>
        </trans-unit>
        <trans-unit id="f6a28970a521e035e5e254c78ec61c1026703f9b" translate="yes" xml:space="preserve">
          <source>Windows 2000</source>
          <target state="translated">视窗2000</target>
        </trans-unit>
        <trans-unit id="94cada20ad68e1ffe3678826da4a09dc6377e803" translate="yes" xml:space="preserve">
          <source>Windows 7</source>
          <target state="translated">Windows 7</target>
        </trans-unit>
        <trans-unit id="cca1d54534e769c83a6c85f5e6241a2523f2592c" translate="yes" xml:space="preserve">
          <source>Windows 95</source>
          <target state="translated">视窗95</target>
        </trans-unit>
        <trans-unit id="bdae4500dcdb3f86e38c3347c9fe418dd6deff32" translate="yes" xml:space="preserve">
          <source>Windows 98</source>
          <target state="translated">视窗98</target>
        </trans-unit>
        <trans-unit id="6578fbd48a0229e823dac38105b1950bd25957b3" translate="yes" xml:space="preserve">
          <source>Windows Event Log, &lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&lt;/a&gt;</source>
          <target state="translated">Windows事件日志，&lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http：//msdn.microsoft.com/library/default.asp？url = / library / en-us / wes / wes / windows_event_log.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="103df21c74e8700ecbf0be7b47c35a5b830e8e97" translate="yes" xml:space="preserve">
          <source>Windows Event Log, &lt;a href=&quot;https://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&lt;/a&gt;</source>
          <target state="translated">Windows事件日志，&lt;a href=&quot;https://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http：//msdn.microsoft.com/library/default.asp？url = / library / en-us / wes / wes / windows_event_log.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08fe8b7597a09dd3a844091de7163268dfe54cc6" translate="yes" xml:space="preserve">
          <source>Windows ME</source>
          <target state="translated">视窗ME</target>
        </trans-unit>
        <trans-unit id="83dc416748ad54d778d6b19e9f7fde1b7af83339" translate="yes" xml:space="preserve">
          <source>Windows NT4</source>
          <target state="translated">Windows NT4</target>
        </trans-unit>
        <trans-unit id="7d80809b5e98653b28bad4f8f5c33d52237b9226" translate="yes" xml:space="preserve">
          <source>Windows Server 2003</source>
          <target state="translated">Windows Server 2003</target>
        </trans-unit>
        <trans-unit id="2504575346cece1887f998d2d76408a38af5141e" translate="yes" xml:space="preserve">
          <source>Windows Server 2008</source>
          <target state="translated">Windows Server 2008</target>
        </trans-unit>
        <trans-unit id="7dc44c44b7a030798f3e511dc741ab9400f590ae" translate="yes" xml:space="preserve">
          <source>Windows Vista</source>
          <target state="translated">视窗Vista</target>
        </trans-unit>
        <trans-unit id="76f20bccfe3512339ad2cea01fc1c7809e7d3d15" translate="yes" xml:space="preserve">
          <source>Windows XP</source>
          <target state="translated">视窗XP</target>
        </trans-unit>
        <trans-unit id="3c2af17044bb2c5164875672fc2938f1968ed3a3" translate="yes" xml:space="preserve">
          <source>Windows has basically 2 sets of APIs. A wide API (based on passing UTF-16 strings) and a byte based API based a character set called ANSI. The regular Perl interfaces to the OS currently only uses the ANSI APIs. Unfortunately ANSI is not a single character set.</source>
          <target state="translated">Windows基本上有2套API。一个是广义的API(基于传递UTF-16字符串),一个是基于字节的API,基于一个叫做ANSI的字符集。常规的Perl与操作系统的接口目前只使用ANSI API。不幸的是,ANSI不是一个单一的字符集。</target>
        </trans-unit>
        <trans-unit id="32384d85bc892c2cec1cd8f151b8007b98fa13ff" translate="yes" xml:space="preserve">
          <source>Windows is Win32.</source>
          <target state="translated">Windows是Win32。</target>
        </trans-unit>
        <trans-unit id="15932d7727c0d0850847ee4a3aea588d05fd6a45" translate="yes" xml:space="preserve">
          <source>Windows is Windows telnet, Cygwin SSH is the OpenSSH implementation under Cygwin on Windows NT, and Mac Terminal is the Terminal application in Mac OS X. Where the entry is other than yes or no, that emulator displays the given attribute as something else instead. Note that on an aixterm, clear doesn't reset colors; you have to explicitly set the colors back to what you want. More entries in this table are welcome.</source>
          <target state="translated">Windows是Windows telnet,Cygwin SSH是Windows NT上Cygwin下的OpenSSH实现,Mac Terminal是Mac OS X中的终端应用程序。当条目不是yes或no时,仿真器会将给定的属性显示为其他内容。请注意,在 aixterm 上,清除并不能重置颜色;你必须明确地将颜色设置为你想要的颜色。欢迎在此表中添加更多条目。</target>
        </trans-unit>
        <trans-unit id="a8033e193c1409f4bd5db90d9880ca01290431d4" translate="yes" xml:space="preserve">
          <source>Windows systems also operate with another byte based character set. It's called the OEM code page. This is the encoding that the Console takes as input and output. It's common for the OEM code page to differ from the ANSI code page.</source>
          <target state="translated">Windows系统还使用另一个基于字节的字符集进行操作。它被称为OEM代码页。这是控制台作为输入和输出的编码。OEM代码页通常与ANSI代码页不同。</target>
        </trans-unit>
        <trans-unit id="3093bbeb765cee856b62debb98821ba39f27fcc6" translate="yes" xml:space="preserve">
          <source>Windows users who are using &lt;code&gt;nmake&lt;/code&gt; should note that due to a bug in &lt;code&gt;nmake&lt;/code&gt; , when specifying &lt;code&gt;TEST_FILES&lt;/code&gt; you must use back-slashes instead of forward-slashes.</source>
          <target state="translated">使用 &lt;code&gt;nmake&lt;/code&gt; 的 Windows用户应注意，由于 &lt;code&gt;nmake&lt;/code&gt; 中的错误，在指定 &lt;code&gt;TEST_FILES&lt;/code&gt; 时，必须使用反斜杠而不是正斜杠。</target>
        </trans-unit>
        <trans-unit id="db6ab0003d513d80fd8056684fe349106fcdab74" translate="yes" xml:space="preserve">
          <source>Windows users who are using &lt;code&gt;nmake&lt;/code&gt; should note that due to a bug in &lt;code&gt;nmake&lt;/code&gt;, when specifying &lt;code&gt;TEST_FILES&lt;/code&gt; you must use back-slashes instead of forward-slashes.</source>
          <target state="translated">使用 &lt;code&gt;nmake&lt;/code&gt; 的Windows用户应注意，由于 &lt;code&gt;nmake&lt;/code&gt; 中的错误，在指定 &lt;code&gt;TEST_FILES&lt;/code&gt; 时，必须使用反斜杠而不是正斜杠。</target>
        </trans-unit>
        <trans-unit id="968c4aaba72bd2883444cce7386789debafb547b" translate="yes" xml:space="preserve">
          <source>Windows-specific tests.</source>
          <target state="translated">Windows专用测试。</target>
        </trans-unit>
        <trans-unit id="52b2489ffd6eceb9bd13b6a8f90eac373db50b35" translate="yes" xml:space="preserve">
          <source>Wisconsin</source>
          <target state="translated">Wisconsin</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="a51957fd22adb3afd697fb8ab328d3922f130d4b" translate="yes" xml:space="preserve">
          <source>With $k chosen carefully, and likely to be a small number like 1 or 2. In theory the larger the bucket array the less chance of collision.</source>
          <target state="translated">在$k慎重选择的情况下,而且很可能是1或2这样的小数。理论上斗阵越大,碰撞的几率越小。</target>
        </trans-unit>
        <trans-unit id="8a3fad0711b1021538f5283d00839025799b6dad" translate="yes" xml:space="preserve">
          <source>With 1 causes this module to use Time::HiRes module, allowing milliseconds to be returned by subsequent calls to ping().</source>
          <target state="translated">如果为1,则会导致该模块使用Time::HiRes模块,允许后续调用ping()返回毫秒数。</target>
        </trans-unit>
        <trans-unit id="6185bdea28758a42fc320398e067ab2654617d96" translate="yes" xml:space="preserve">
          <source>With 5005threads, you could also &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; a sub such that any calls to that sub from another thread would block until the lock was released.</source>
          <target state="translated">使用5005线程，您还可以 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 一个子线程，以便从另一个线程对该子线程的任何调用都将阻塞，直到释放锁定为止。</target>
        </trans-unit>
        <trans-unit id="a8d11fe55a26fb99c192c4c169dd330b2ce5c5d6" translate="yes" xml:space="preserve">
          <source>With 5005threads, you could also &lt;code&gt;lock&lt;/code&gt; a sub such that any calls to that sub from another thread would block until the lock was released.</source>
          <target state="translated">使用5005线程，您还可以 &lt;code&gt;lock&lt;/code&gt; 一个子线程，以便从另一个线程对该子线程的任何调用都将阻塞，直到释放该锁定为止。</target>
        </trans-unit>
        <trans-unit id="c2c741524004c7f8613fe0df95f2304ad27bfaf6" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;/a&lt;/code&gt; , one can write &lt;code&gt;\d&lt;/code&gt; with confidence that it will only match ASCII characters, and should the need arise to match beyond ASCII, you can instead use &lt;code&gt;\p{Digit}&lt;/code&gt; (or &lt;code&gt;\p{Word}&lt;/code&gt; for &lt;code&gt;\w&lt;/code&gt; ). There are similar &lt;code&gt;\p{...}&lt;/code&gt; constructs that can match beyond ASCII both white space (see &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;Whitespace in perlrecharclass&lt;/a&gt;), and Posix classes (see &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;). Thus, this modifier doesn't mean you can't use Unicode, it means that to get Unicode matching you must explicitly use a construct (&lt;code&gt;\p{}&lt;/code&gt; , &lt;code&gt;\P{}&lt;/code&gt; ) that signals Unicode.</source>
          <target state="translated">使用 &lt;code&gt;/a&lt;/code&gt; ，您可以放心地写 &lt;code&gt;\d&lt;/code&gt; 仅匹配ASCII字符，并且如果需要匹配ASCII以外的字符，则可以改用 &lt;code&gt;\p{Digit}&lt;/code&gt; （对于 &lt;code&gt;\w&lt;/code&gt; 使用 &lt;code&gt;\p{Word}&lt;/code&gt; ）。有类似的 &lt;code&gt;\p{...}&lt;/code&gt; 构造可以匹配ASCII以外的&lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;空白&lt;/a&gt;（请参见perlrecharclass中的Whitespace）和Posix类（请参见&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass中的POSIX字符类&lt;/a&gt;）。因此，此修饰符并不意味着您不能使用Unicode，它意味着要获得Unicode匹配，您必须显式使用发出Unicode信号的结构（ &lt;code&gt;\p{}&lt;/code&gt; ， &lt;code&gt;\P{}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d8c642a61a993b2822d327b2f6d2aa5b5cdb0c33" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;/a&lt;/code&gt;, one can write &lt;code&gt;\d&lt;/code&gt; with confidence that it will only match ASCII characters, and should the need arise to match beyond ASCII, you can instead use &lt;code&gt;\p{Digit}&lt;/code&gt; (or &lt;code&gt;\p{Word}&lt;/code&gt; for &lt;code&gt;\w&lt;/code&gt;). There are similar &lt;code&gt;\p{...}&lt;/code&gt; constructs that can match beyond ASCII both white space (see &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;&quot;Whitespace&quot; in perlrecharclass&lt;/a&gt;), and Posix classes (see &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;). Thus, this modifier doesn't mean you can't use Unicode, it means that to get Unicode matching you must explicitly use a construct (&lt;code&gt;\p{}&lt;/code&gt;, &lt;code&gt;\P{}&lt;/code&gt;) that signals Unicode.</source>
          <target state="translated">使用 &lt;code&gt;/a&lt;/code&gt; ，可以放心地写 &lt;code&gt;\d&lt;/code&gt; 仅匹配ASCII字符，并且如果需要匹配超出ASCII的字符，则可以改用 &lt;code&gt;\p{Digit}&lt;/code&gt; （或 &lt;code&gt;\w&lt;/code&gt; &lt;code&gt;\p{Word}&lt;/code&gt; 代表\ w）。有类似的 &lt;code&gt;\p{...}&lt;/code&gt; 构造可以匹配ASCII以外的&lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;空白&lt;/a&gt;（请参见perlrecharclass中的&amp;ldquo; Whitespace&amp;rdquo;）和Posix类（请参见&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass中的&amp;ldquo; POSIX字符类&amp;rdquo;&lt;/a&gt;）。因此，此修饰符并不意味着您不能使用Unicode，它意味着要获得Unicode匹配，您必须显式使用发出Unicode信号的结构（ &lt;code&gt;\p{}&lt;/code&gt; ， &lt;code&gt;\P{}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5132b5fe6c695f29613169cf8ff9a2c949197d0f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, you get around this by using a block and an expression where you would place the filehandle:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; ，您可以使用一个块和一个放置文件句柄的表达式来解决此问题：</target>
        </trans-unit>
        <trans-unit id="487baf6c93470e20c12688608403c20fbdb8e8f3" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;, both STDOUT and STDERR will go the same place as the script's STDOUT and STDERR, unless the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; command redirects them. Backticks and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; read &lt;b&gt;only&lt;/b&gt; the STDOUT of your command.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; ，除非 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 命令将它们重定向，否则STDOUT和STDERR都将与脚本的STDOUT和STDERR放在同一位置。反引号和 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; &lt;b&gt;仅&lt;/b&gt;读取命令的STDOUT。</target>
        </trans-unit>
        <trans-unit id="e6ba4c518cc989a85f1859e34fe5315e0670671f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Class::Tiny&lt;/code&gt; , all accessors are read-write. It generates a constructor for you, as well as the accessors you define.</source>
          <target state="translated">使用 &lt;code&gt;Class::Tiny&lt;/code&gt; ，所有访问器都是可读写的。它为您以及您定义的访问器生成一个构造函数。</target>
        </trans-unit>
        <trans-unit id="30133336b461bf131bf440d3b8937ae3c7286e54" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Class::Tiny&lt;/code&gt;, all accessors are read-write. It generates a constructor for you, as well as the accessors you define.</source>
          <target state="translated">使用 &lt;code&gt;Class::Tiny&lt;/code&gt; ，所有访问器都是可读写的。它为您以及您定义的访问器生成一个构造函数。</target>
        </trans-unit>
        <trans-unit id="c6b55e3069c1cf271c20c8804a7b8c0dbfbb1f17" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ignore_case&lt;/code&gt; , option specifications for options that only differ in case, e.g., &lt;code&gt;&quot;foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; , will be flagged as duplicates.</source>
          <target state="translated">使用 &lt;code&gt;ignore_case&lt;/code&gt; 时，仅大小写不同的选项的选项规范（例如 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; ）将被标记为重复项。</target>
        </trans-unit>
        <trans-unit id="912c5dbb25de4eb33c760222cb62f248afb75050" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ignore_case&lt;/code&gt;, option specifications for options that only differ in case, e.g., &lt;code&gt;&quot;foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;Foo&quot;&lt;/code&gt;, will be flagged as duplicates.</source>
          <target state="translated">使用 &lt;code&gt;ignore_case&lt;/code&gt; 时，仅大小写不同的选项的选项规范（例如 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; ）将被标记为重复项。</target>
        </trans-unit>
        <trans-unit id="2fffc08f49ded4afbdfb2c00f9dcdbc7da340301" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;latin1&lt;/code&gt; (or &lt;code&gt;ascii&lt;/code&gt;) enabled, &lt;code&gt;encode&lt;/code&gt; will escape characters with ordinal values &amp;gt; 255 (&amp;gt; 127 with &lt;code&gt;ascii&lt;/code&gt;) and encode the remaining characters as specified by the &lt;code&gt;utf8&lt;/code&gt; flag.</source>
          <target state="translated">用 &lt;code&gt;latin1&lt;/code&gt; （或 &lt;code&gt;ascii&lt;/code&gt; ）启用， &lt;code&gt;encode&lt;/code&gt; 将逸出以序值的字符&amp;gt; 255（&amp;gt; 127与 &lt;code&gt;ascii&lt;/code&gt; ），并由指定的编码的剩余字符 &lt;code&gt;utf8&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="ee71de233ae712db3a62ad0a5f3c845bcb07690d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;pass_through&lt;/code&gt; anything that is unknown, ambiguous or supplied with an invalid option will not be flagged as an error. Instead the unknown option(s) will be passed to the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present, otherwise through to &lt;code&gt;@ARGV&lt;/code&gt; . This makes it possible to write wrapper scripts that process only part of the user supplied command line arguments, and pass the remaining options to some other program.</source>
          <target state="translated">使用 &lt;code&gt;pass_through&lt;/code&gt; 时,任何未知，模棱两可或带有无效选项的内容都不会被标记为错误。相反，未知选项将传递给catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; (如果存在），否则传递给 &lt;code&gt;@ARGV&lt;/code&gt; 。这样就可以编写仅处理部分用户提供的命令行参数的包装器脚本，并将其余选项传递给其他程序。</target>
        </trans-unit>
        <trans-unit id="f4663d47991fc6ad8f19a68b7dbd43ec5db93e1f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;pass_through&lt;/code&gt; anything that is unknown, ambiguous or supplied with an invalid option will not be flagged as an error. Instead the unknown option(s) will be passed to the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present, otherwise through to &lt;code&gt;@ARGV&lt;/code&gt;. This makes it possible to write wrapper scripts that process only part of the user supplied command line arguments, and pass the remaining options to some other program.</source>
          <target state="translated">使用 &lt;code&gt;pass_through&lt;/code&gt; 时,任何未知，模棱两可或带有无效选项的内容都不会被标记为错误。相反，未知选项将传递给catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; (如果存在），否则传递给 &lt;code&gt;@ARGV&lt;/code&gt; 。这样就可以编写仅处理部分用户提供的命令行参数的包装器脚本，并将其余选项传递给其他程序。</target>
        </trans-unit>
        <trans-unit id="e21e85e4f08ba1ed663f7825a392d047ce118ae8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;printf&lt;/code&gt;, you get around this by using a block and an expression where you would place the filehandle:</source>
          <target state="translated">使用 &lt;code&gt;print&lt;/code&gt; 和 &lt;code&gt;printf&lt;/code&gt; ，您可以通过使用一个块和一个表达式来放置文件句柄来解决此问题：</target>
        </trans-unit>
        <trans-unit id="161b6ff35bc50314a49d188535255f199fcc9bb0" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;system()&lt;/code&gt;, both STDOUT and STDERR will go the same place as the script's STDOUT and STDERR, unless the &lt;code&gt;system()&lt;/code&gt; command redirects them. Backticks and &lt;code&gt;open()&lt;/code&gt; read &lt;b&gt;only&lt;/b&gt; the STDOUT of your command.</source>
          <target state="translated">使用 &lt;code&gt;system()&lt;/code&gt; ，除非 &lt;code&gt;system()&lt;/code&gt; 命令将它们重定向，否则STDOUT和STDERR都将与脚本的STDOUT和STDERR放在同一位置。反引号和 &lt;code&gt;open()&lt;/code&gt; &lt;b&gt;仅&lt;/b&gt;读取命令的STDOUT。</target>
        </trans-unit>
        <trans-unit id="fb95ac886e1d528b24773e6c70b3ed1c1613335e" translate="yes" xml:space="preserve">
          <source>With EXPR, it returns some extra information that the debugger uses to print a stack trace. The value of EXPR indicates how many call frames to go back before the current one.</source>
          <target state="translated">通过EXPR,它返回一些额外的信息,调试器用来打印堆栈跟踪。EXPR的值表示在当前帧之前要返回多少个调用帧。</target>
        </trans-unit>
        <trans-unit id="a55096d08b5ad2fe54fd898185c93fb2c1c7dfdd" translate="yes" xml:space="preserve">
          <source>With Mac OS X 10.4 &quot;Tiger&quot; and newer, there is almost no performance penalty for non-prebound libraries. Earlier releases will suffer a greater load time than either the static library, or Apple's pre-bound dynamic library.</source>
          <target state="translated">在Mac OS X 10.4 &quot;Tiger &quot;及更新版本中,非预绑定库几乎没有性能上的损失。较早的版本会比静态库或苹果的预绑定动态库的加载时间更长。</target>
        </trans-unit>
        <trans-unit id="5f9d3d0136d8a2d2276cb1a4c4f0bb0c82be3696" translate="yes" xml:space="preserve">
          <source>With NTFS (and no CYGWIN=nontsec), there should be no problems even if perl was built on FAT.</source>
          <target state="translated">如果使用NTFS(而且没有CYGWIN=nontsec),即使perl是建立在FAT上的,也应该没有问题。</target>
        </trans-unit>
        <trans-unit id="783aaaca75cc72bad41475003df821affc75b7c5" translate="yes" xml:space="preserve">
          <source>With OO style, you can break the message arbitrarily. This means that we are no longer limited to have space for the whole message in memory, i.e. we can handle messages of any size.</source>
          <target state="translated">通过OO风格,你可以任意的打破消息。这意味着我们不再局限于在内存中拥有整个消息的空间,即我们可以处理任何大小的消息。</target>
        </trans-unit>
        <trans-unit id="aa5707019a9c4f2624f176a48761ef4f1b3f5952" translate="yes" xml:space="preserve">
          <source>With Perl &amp;gt;= 5.6.2, you can also use a line like this:</source>
          <target state="translated">在Perl&amp;gt; = 5.6.2的情况下，您还可以使用如下一行：</target>
        </trans-unit>
        <trans-unit id="c1bf2f77022cd9fed463a5704b297d6ff88b00d5" translate="yes" xml:space="preserve">
          <source>With Perl 5.004 you can also use the TIEHANDLE interface to access compressed files just like ordinary files:</source>
          <target state="translated">在Perl 5.004中,你也可以使用TIEHANDLE接口来访问压缩文件,就像访问普通文件一样。</target>
        </trans-unit>
        <trans-unit id="9f110b40627d54799c1a5b4c023b449d3f05b59d" translate="yes" xml:space="preserve">
          <source>With Perl 5.10 and later, the smart match operator can give you the answer with the least amount of work:</source>
          <target state="translated">在Perl 5.10及以后的版本中,智能匹配运算符可以用最少的工作量给你答案。</target>
        </trans-unit>
        <trans-unit id="4e55c608e124b42bf25bf02c154381796e1d9852" translate="yes" xml:space="preserve">
          <source>With a</source>
          <target state="translated">有一个</target>
        </trans-unit>
        <trans-unit id="cf7bad50138d4a906e034cdc8232445a6a34e8fb" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;, &lt;code&gt;charscript()&lt;/code&gt; returns the</source>
          <target state="translated">用&lt;a href=&quot;#code-point-argument&quot;&gt;&amp;ldquo;代码点参数&amp;rdquo;&lt;/a&gt;， &lt;code&gt;charscript()&lt;/code&gt; 返回</target>
        </trans-unit>
        <trans-unit id="ca805fd21b2d73d6d3fa38629cb4d7c77aac2c21" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;&lt;code&gt;charblock()&lt;/code&gt; returns the</source>
          <target state="translated">带有&lt;a href=&quot;#code-point-argument&quot;&gt;&amp;ldquo;代码点参数&amp;rdquo;的&lt;/a&gt; &lt;code&gt;charblock()&lt;/code&gt; 返回</target>
        </trans-unit>
        <trans-unit id="f458d9e5c6b401d23a0ff93a93cac73ffa40d782" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;, &lt;code&gt;charscript()&lt;/code&gt; returns the</source>
          <target state="translated">使用&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数&lt;/a&gt;， &lt;code&gt;charscript()&lt;/code&gt; 返回</target>
        </trans-unit>
        <trans-unit id="7cfd816e3af239ee8e3392fa5dd4b28e10c2cbf9" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;&lt;code&gt;charblock()&lt;/code&gt; returns the</source>
          <target state="translated">使用&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数&lt;/a&gt; &lt;code&gt;charblock()&lt;/code&gt; 返回</target>
        </trans-unit>
        <trans-unit id="cc06a9c18caf674053e4b44b132356a1c540f757" translate="yes" xml:space="preserve">
          <source>With a little extra work, you can get all of the groups in angle brackets even if they are in other angle brackets too. Each time you get a balanced match, remove its outer delimiter (that's the one you just matched so don't match it again) and add it to a queue of strings to process. Keep doing that until you get no matches:</source>
          <target state="translated">只要做一点额外的工作,你可以得到所有在角括号中的组,即使它们也在其他角括号中。每当你得到一个平衡的匹配,去掉它的外定界符(就是你刚刚匹配的那个,所以不要再匹配它了),然后把它添加到字符串队列中去处理。一直这样做,直到你没有得到匹配。</target>
        </trans-unit>
        <trans-unit id="a69059588956460f70f3f90c71a968d5af85c118" translate="yes" xml:space="preserve">
          <source>With a non-&lt;code&gt;DEBUGGING&lt;/code&gt; perl, the buckets starting from &lt;code&gt;128&lt;/code&gt; have a 4-byte overhead, and thus an 8192-long bucket may take up to 8188-byte allocations.</source>
          <target state="translated">使用非 &lt;code&gt;DEBUGGING&lt;/code&gt; Perl，从 &lt;code&gt;128&lt;/code&gt; 开始的存储桶会有4字节的开销，因此8192长的存储桶可能需要多达8188字节的分配。</target>
        </trans-unit>
        <trans-unit id="3f782793180910fe0c252c5c5e6b40299dd75d89" translate="yes" xml:space="preserve">
          <source>With a slurpy parameter in the signature, there is no upper limit on how many arguments may be passed. A slurpy array parameter may be nameless just like a positional parameter, in which case its only effect is to turn off the argument limit that would otherwise apply:</source>
          <target state="translated">在签名中使用一个模糊参数,对传递参数的数量没有上限。稀疏数组参数可以是无名的,就像位置参数一样,在这种情况下,它的唯一作用是关闭原本适用的参数限制。</target>
        </trans-unit>
        <trans-unit id="f9508f16c80ad6889c699daf40f43720b8251d92" translate="yes" xml:space="preserve">
          <source>With a technique called copy-on-write, the cost of copying with overload could be minimized or even completely avoided. A test implementation of COW did show performance gains for overloaded math, but introduced a performance loss due to a constant overhead for all other operations. So Math::BigInt does currently not COW.</source>
          <target state="translated">通过一种叫做copy-on-write的技术,可以将过载复制的成本降到最低,甚至完全避免。COW的测试实现确实显示出对重载数学的性能提升,但由于对其他所有操作的持续开销,引入了性能损失。所以Math::BigInt目前没有COW。</target>
        </trans-unit>
        <trans-unit id="338611254651b6fbb00a03edfd8b2e0209a2413c" translate="yes" xml:space="preserve">
          <source>With a todo block, the tests inside are expected to fail. Test::More will run the tests normally, but print out special flags indicating they are &quot;todo&quot;. &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret failures as being ok. Should anything succeed, it will report it as an unexpected success. You then know the thing you had todo is done and can remove the TODO flag.</source>
          <target state="translated">使用todo块，内部测试将失败。Test :: More将正常运行测试，但是会打印出特殊标志，表明它们是&amp;ldquo;待办事项&amp;rdquo;。&lt;a href=&quot;Test::Harness&quot;&gt;测试::线束&lt;/a&gt;会将故障解释为正常。如果成功，它将报告为意外成功。然后，您知道必须做的事情已经完成，可以删除TODO标志。</target>
        </trans-unit>
        <trans-unit id="0ebe6d7c43f224246d4ca3387c92f6cc94b15954" translate="yes" xml:space="preserve">
          <source>With a todo block, the tests inside are expected to fail. Test::More will run the tests normally, but print out special flags indicating they are &quot;todo&quot;. &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret failures as being ok. Should anything succeed, it will report it as an unexpected success. You then know the thing you had todo is done and can remove the TODO flag.</source>
          <target state="translated">使用todo块，内部测试将失败。Test :: More将正常运行测试，但是会打印出特殊标志，表明它们是&amp;ldquo;待办事项&amp;rdquo;。&lt;a href=&quot;harness&quot;&gt;测试::线束&lt;/a&gt;会将故障解释为正常。如果成功，它将报告为意外成功。然后，您知道必须做的事情已经完成，可以删除TODO标志。</target>
        </trans-unit>
        <trans-unit id="039f5d96db075baf2e35a9428955065fad856e3f" translate="yes" xml:space="preserve">
          <source>With all of the previous done, you're now ready to call Configure.</source>
          <target state="translated">前面的工作都做完了,现在就可以调用Configure了。</target>
        </trans-unit>
        <trans-unit id="2be7163284f82da14a87936dad63fbf983833559" translate="yes" xml:space="preserve">
          <source>With all of the regexes above, if the regex matched anywhere in the string, it was considered a match. To specify</source>
          <target state="translated">对于以上所有的regex,如果regex与字符串中的任何地方相匹配,则认为是匹配的。要指定</target>
        </trans-unit>
        <trans-unit id="a49675e374380fe043aff3a5f63d6512021ecfd9" translate="yes" xml:space="preserve">
          <source>With all of the regexps above, if the regexp matched anywhere in the string, it was considered a match. Sometimes, however, we'd like to specify</source>
          <target state="translated">对于上面所有的regexps,如果regexp在字符串中的任何地方匹配,就被认为是匹配的。然而,有时候,我们希望指定的是</target>
        </trans-unit>
        <trans-unit id="544d324c6a361c56f15aa84b4f308989bea67735" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 时，您应该特别小心记住以下情况：</target>
        </trans-unit>
        <trans-unit id="250cfbca6e5e22d4d573a90cd37797d2cb8d3ac5" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 时，您应该特别小心记住以下情况：</target>
        </trans-unit>
        <trans-unit id="8175ced4a0fd9d7cc491a3c946926864742f09d4" translate="yes" xml:space="preserve">
          <source>With an argument, can be used to generate a NaN with</source>
          <target state="translated">有了参数,可以用来生成一个带有</target>
        </trans-unit>
        <trans-unit id="28933cd0405c565c32304d3c729c7e6f31006ad2" translate="yes" xml:space="preserve">
          <source>With any of these, you can change file descriptors before the call:</source>
          <target state="translated">使用其中任何一种,你都可以在调用前改变文件描述符。</target>
        </trans-unit>
        <trans-unit id="944f492857a1db6c839174233fd1c02f59c056dd" translate="yes" xml:space="preserve">
          <source>With any version of Perl 5 you can use the basic OO interface:</source>
          <target state="translated">在任何版本的Perl 5中,你都可以使用基本的OO接口。</target>
        </trans-unit>
        <trans-unit id="d9bf5579433ea6ddabc4d916f0dbd99e9c0f39ff" translate="yes" xml:space="preserve">
          <source>With argument force $ENCODING_... variables to set to the given value.</source>
          <target state="translated">用参数强制$ENCODING_...变量设置为给定值。</target>
        </trans-unit>
        <trans-unit id="aaaac305ec8d42934372356813b4624fa49a8ffc" translate="yes" xml:space="preserve">
          <source>With argument sets the option. Without returns the option value.</source>
          <target state="translated">With参数设置选项。无参数则返回选项值。</target>
        </trans-unit>
        <trans-unit id="108bd0cf30895e3a18d32866a5ada0ba72c0b2d2" translate="yes" xml:space="preserve">
          <source>With bundling it is possible to set several single-character options at once. For example if &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are all valid options,</source>
          <target state="translated">通过捆绑，可以一次设置多个单字符选项。例如，如果 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;v&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 均为有效选项，</target>
        </trans-unit>
        <trans-unit id="6a3391ab50835b72ad746f9bc70f0861004cbe03" translate="yes" xml:space="preserve">
          <source>With bundling it is possible to set several single-character options at once. For example if &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are all valid options,</source>
          <target state="translated">通过捆绑，可以一次设置多个单字符选项。例如，如果 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;v&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 均为有效选项，</target>
        </trans-unit>
        <trans-unit id="bf9c20d6876f103320c9d9424556b25f81d7af24" translate="yes" xml:space="preserve">
          <source>With earlier versions of Perl, you have to do a bit more work. If you are going to make this query many times over arbitrary string values, the fastest way is probably to invert the original array and maintain a hash whose keys are the first array's values:</source>
          <target state="translated">对于早期版本的Perl,你必须做更多的工作。如果你要对任意字符串值进行多次查询,最快的方法可能是对原始数组进行反转,并维护一个哈希,其键是第一个数组的值。</target>
        </trans-unit>
        <trans-unit id="089c9811008b67cdbb35efdae3d3f3034c15c2b2" translate="yes" xml:space="preserve">
          <source>With excerpts from Perl, and contributions and suggestions from Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus, Stephen McCamant, and David Landgren.</source>
          <target state="translated">摘自Perl,以及Ronald J.Kimball、Dave Mitchell、Dominic Dunlop、Mark Jason Dominus、Stephen McCamant和David Landgren的贡献和建议。</target>
        </trans-unit>
        <trans-unit id="312cf396f9e4b4f5d83643b7fda95efc6c88ff9d" translate="yes" xml:space="preserve">
          <source>With hooks comes the ability to recurse back to the Storable engine. Indeed, hooks are regular Perl code, and Storable is convenient when it comes to serializing and deserializing things, so why not use it to handle the serialization string?</source>
          <target state="translated">有了hooks,就有了回溯到Storable引擎的能力。事实上,hooks是常规的Perl代码,而Storable在序列化和反序列化的时候很方便,为什么不用它来处理序列化字符串呢?</target>
        </trans-unit>
        <trans-unit id="2092bcf7558e6632164a74cbb09d09cc7943a0d7" translate="yes" xml:space="preserve">
          <source>With lots of help and suggestions from Dean Roehrich, Malcolm Beattie, Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer, Stephen McCamant, and Gurusamy Sarathy.</source>
          <target state="translated">在Dean Roehrich、Malcolm Beattie、Andreas Koenig、Paul Hudson、Ilya Zakharevich、Paul Marquess、Neil Bowers、Matthew Green、Tim Bunce、Spider Boardman、Ulrich Pfeifer、Stephen McCamant和Gurusamy Sarathy的帮助和建议下。</target>
        </trans-unit>
        <trans-unit id="2f32ef7ca32db627a2acbe157dc6fb77e5ecddfd" translate="yes" xml:space="preserve">
          <source>With methods 2 and 3, Perl starts parsing the input file from the beginning, unless you've specified a &lt;a href=&quot;#-x&quot;&gt;&quot;-x&quot;&lt;/a&gt; switch, in which case it scans for the first line starting with &lt;code&gt;#!&lt;/code&gt; and containing the word &quot;perl&quot;, and starts there instead. This is useful for running a program embedded in a larger message. (In this case you would indicate the end of the program using the &lt;code&gt;__END__&lt;/code&gt; token.)</source>
          <target state="translated">使用方法2和3，除非您已指定&lt;a href=&quot;#-x&quot;&gt;&amp;ldquo; -x&amp;rdquo;&lt;/a&gt;开关，否则Perl从头开始解析输入文件，在这种情况下，它将扫描以 &lt;code&gt;#!&lt;/code&gt; 开头的第一行！并包含&amp;ldquo; perl&amp;rdquo;一词，然后从此处开始。这对于运行嵌入较大消息中的程序很有用。 （在这种情况下，您将使用 &lt;code&gt;__END__&lt;/code&gt; 令牌指示程序的结束。）</target>
        </trans-unit>
        <trans-unit id="6a2d0cebca8f8c753e2f714f5c39699038d3b25f" translate="yes" xml:space="preserve">
          <source>With methods 2 and 3, Perl starts parsing the input file from the beginning, unless you've specified a &lt;b&gt;-x&lt;/b&gt; switch, in which case it scans for the first line starting with &lt;code&gt;#!&lt;/code&gt; and containing the word &quot;perl&quot;, and starts there instead. This is useful for running a program embedded in a larger message. (In this case you would indicate the end of the program using the &lt;code&gt;__END__&lt;/code&gt; token.)</source>
          <target state="translated">使用方法2和3，Perl从头开始解析输入文件，除非您指定了&lt;b&gt;-x&lt;/b&gt;开关，在这种情况下，它将扫描以 &lt;code&gt;#!&lt;/code&gt; 开头的第一行！并包含&amp;ldquo; perl&amp;rdquo;一词，然后从此处开始。这对于运行嵌入较大消息中的程序很有用。 （在这种情况下，您将使用 &lt;code&gt;__END__&lt;/code&gt; 令牌指示程序的结束。）</target>
        </trans-unit>
        <trans-unit id="6316d5824ca52c312f770e770e783e4a6d5033d6" translate="yes" xml:space="preserve">
          <source>With mod_perl and the Apache::Registry module (distributed with mod_perl), httpd will run with an embedded Perl interpreter which pre-compiles your script and then executes it within the same address space without forking. The Apache extension also gives Perl access to the internal server API, so modules written in Perl can do just about anything a module written in C can. For more on mod_perl, see &lt;a href=&quot;http://perl.apache.org/&quot;&gt;http://perl.apache.org/&lt;/a&gt;</source>
          <target state="translated">通过使用mod_perl和Apache :: Registry模块（随mod_perl分发），httpd将与嵌入式Perl解释器一起运行，该解释器预编译您的脚本，然后在相同的地址空间内执行它而不会分叉。Apache扩展还使Perl可以访问内部服务器API，因此用Perl编写的模块几乎可以执行用C编写的模块可以执行的任何操作。有关mod_perl的更多信息，请参见&lt;a href=&quot;http://perl.apache.org/&quot;&gt;http://perl.apache.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d005d6fa4f38275ab653f946a0fd89499661e988" translate="yes" xml:space="preserve">
          <source>With mod_perl and the Apache::Registry module (distributed with mod_perl), httpd will run with an embedded Perl interpreter which pre-compiles your script and then executes it within the same address space without forking. The Apache extension also gives Perl access to the internal server API, so modules written in Perl can do just about anything a module written in C can. For more on mod_perl, see &lt;a href=&quot;https://perl.apache.org/&quot;&gt;http://perl.apache.org/&lt;/a&gt;</source>
          <target state="translated">通过使用mod_perl和Apache :: Registry模块（随mod_perl分发），httpd将与嵌入式Perl解释器一起运行，该解释器预编译您的脚本，然后在相同的地址空间内执行它而不会分叉。Apache扩展还使Perl可以访问内部服务器API，因此用Perl编写的模块几乎可以执行用C编写的模块可以执行的任何操作。有关mod_perl的更多信息，请参见&lt;a href=&quot;https://perl.apache.org/&quot;&gt;http://perl.apache.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cc2eb3f9b78400953fa9a4ff9c87b68e20c7b681" translate="yes" xml:space="preserve">
          <source>With much assistance regarding shared libraries from Marc Sabatella.</source>
          <target state="translated">在共享图书馆方面得到了Marc Sabatella的大力协助。</target>
        </trans-unit>
        <trans-unit id="b462e2e8ccefffa9756bd47bbfa7c723db9b9b54" translate="yes" xml:space="preserve">
          <source>With negative offsets, it remembers its position from the end of the string when the target string is modified:</source>
          <target state="translated">在负偏移的情况下,当目标字符串被修改时,它会记住它从字符串末端开始的位置。</target>
        </trans-unit>
        <trans-unit id="00344cc849fc9376fff9de99085e79fa3cd552d0" translate="yes" xml:space="preserve">
          <source>With no MASK argument present, it returns the current operator mask of the compartment.</source>
          <target state="translated">在没有MASK参数的情况下,它返回当前隔层的操作者掩码。</target>
        </trans-unit>
        <trans-unit id="a35650496b577c95afdac0e1ebb0191fd46fd2e0" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole array (whether or not the element was specified as &lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt; ).</source>
          <target state="translated">没有参数，访问器将返回对元素整个数组的引用（无论元素是否指定为 &lt;code&gt;'@'&lt;/code&gt; 或 &lt;code&gt;'*@'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a8ef3568dccdeee73b65f3996dd1707e6feb3878" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole array (whether or not the element was specified as &lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt;).</source>
          <target state="translated">没有参数，访问器将返回对元素整个数组的引用（无论元素是否指定为 &lt;code&gt;'@'&lt;/code&gt; 或 &lt;code&gt;'*@'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3a4963e3a2e84181fb9a499ef49896fdab34cd7c" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole hash (whether or not the element was specified as &lt;code&gt;'%'&lt;/code&gt; or &lt;code&gt;'*%'&lt;/code&gt; ).</source>
          <target state="translated">不带任何参数的访问器将返回对元素整个哈希的引用（无论元素是否指定为 &lt;code&gt;'%'&lt;/code&gt; 或 &lt;code&gt;'*%'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="988bcaf50ce8ee9902f007f6fc6c2b44abddd67d" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole hash (whether or not the element was specified as &lt;code&gt;'%'&lt;/code&gt; or &lt;code&gt;'*%'&lt;/code&gt;).</source>
          <target state="translated">没有参数，访问器将返回对元素整个哈希的引用（无论元素是否指定为 &lt;code&gt;'%'&lt;/code&gt; 或 &lt;code&gt;'*%'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6bae0e18d43bcb818e56d07261a055232eff0bf8" translate="yes" xml:space="preserve">
          <source>With no arguments (or using &lt;code&gt;threads::all&lt;/code&gt; ) and in a list context, returns a list of all non-joined, non-detached</source>
          <target state="translated">不带参数（或使用 &lt;code&gt;threads::all&lt;/code&gt; ），并在列表上下文中，返回所有未连接，未分离的列表</target>
        </trans-unit>
        <trans-unit id="9a2c5169b8859351e115fccd32105029ad3b3e99" translate="yes" xml:space="preserve">
          <source>With no arguments (or using &lt;code&gt;threads::all&lt;/code&gt;) and in a list context, returns a list of all non-joined, non-detached</source>
          <target state="translated">不带参数（或使用 &lt;code&gt;threads::all&lt;/code&gt; ）并在列表上下文中，返回所有未连接，未分离的列表</target>
        </trans-unit>
        <trans-unit id="18cf8c9e6afcd23474d7fb3a81386e0988d7bd68" translate="yes" xml:space="preserve">
          <source>With older versions of Perl, the &lt;a href=&quot;IO::String&quot;&gt;IO::String&lt;/a&gt; module provides similar functionality.</source>
          <target state="translated">对于旧版本的Perl，&lt;a href=&quot;IO::String&quot;&gt;IO :: String&lt;/a&gt;模块提供了类似的功能。</target>
        </trans-unit>
        <trans-unit id="d4cfb999178855ab18f46ce9c518e1bd1ef50096" translate="yes" xml:space="preserve">
          <source>With older versions of Perl, the &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO::String&lt;/a&gt; module provides similar functionality.</source>
          <target state="translated">对于旧版本的Perl，&lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO :: String&lt;/a&gt;模块提供了类似的功能。</target>
        </trans-unit>
        <trans-unit id="789c0f1114004fe97c889b4fd162dac50dbb4785" translate="yes" xml:space="preserve">
          <source>With one exception (below), if both strings look like numbers to Perl, the magic increment will not be applied, and the strings will be treated as numbers (more specifically, integers) instead.</source>
          <target state="translated">除了一个例外(如下),如果两个字符串在Perl看来都是数字,那么就不会应用魔力增量,而是将这些字符串作为数字(更确切地说,是整数)来处理。</target>
        </trans-unit>
        <trans-unit id="c467eeeb4f15846c2e3c26d1b4d74776d4da75d4" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is a key specifying one element of the hash; the second argument, if present, is assigned to the hash element. If the element type is &lt;code&gt;'%'&lt;/code&gt; , the accessor returns the hash element value. If the element type is &lt;code&gt;'*%'&lt;/code&gt; , a reference to the hash element is returned.</source>
          <target state="translated">有一个或两个自变量，第一个自变量是指定哈希值一个元素的键；第二个参数（如果存在）被分配给hash元素。如果元素类型为 &lt;code&gt;'%'&lt;/code&gt; ，则访问器返回哈希元素值。如果元素类型为 &lt;code&gt;'*%'&lt;/code&gt; ，则返回对哈希元素的引用。</target>
        </trans-unit>
        <trans-unit id="0bd4bcbdb7945f28a4390fecea625c7a59fd6d00" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is a key specifying one element of the hash; the second argument, if present, is assigned to the hash element. If the element type is &lt;code&gt;'%'&lt;/code&gt;, the accessor returns the hash element value. If the element type is &lt;code&gt;'*%'&lt;/code&gt;, a reference to the hash element is returned.</source>
          <target state="translated">有一个或两个自变量，第一个自变量是指定哈希值一个元素的键；第二个参数（如果存在）被分配给hash元素。如果元素类型为 &lt;code&gt;'%'&lt;/code&gt; ，则访问器返回哈希元素值。如果元素类型为 &lt;code&gt;'*%'&lt;/code&gt; ，则返回对哈希元素的引用。</target>
        </trans-unit>
        <trans-unit id="043fe821df73a58116e971eada4906da49321cca" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is an index specifying one element of the array; the second argument, if present, is assigned to the array element. If the element type is &lt;code&gt;'@'&lt;/code&gt; , the accessor returns the array element value. If the element type is &lt;code&gt;'*@'&lt;/code&gt; , a reference to the array element is returned.</source>
          <target state="translated">有一个或两个参数，第一个参数是指定数组一个元素的索引；第二个参数（如果存在）将分配给数组元素。如果元素类型为 &lt;code&gt;'@'&lt;/code&gt; ，则访问器返回数组元素值。如果元素类型为 &lt;code&gt;'*@'&lt;/code&gt; ，则返回对数组元素的引用。</target>
        </trans-unit>
        <trans-unit id="eca88cd532fb52622336dc15fcd9f2fe4531eda4" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is an index specifying one element of the array; the second argument, if present, is assigned to the array element. If the element type is &lt;code&gt;'@'&lt;/code&gt;, the accessor returns the array element value. If the element type is &lt;code&gt;'*@'&lt;/code&gt;, a reference to the array element is returned.</source>
          <target state="translated">有一个或两个自变量，第一个自变量是一个索引，用于指定数组的一个元素；第二个参数（如果存在）将分配给数组元素。如果元素类型为 &lt;code&gt;'@'&lt;/code&gt; ，则访问器返回数组元素值。如果元素类型为 &lt;code&gt;'*@'&lt;/code&gt; ，则返回对数组元素的引用。</target>
        </trans-unit>
        <trans-unit id="d82587a9e3d9d950371c40dd7e06719bffb84440" translate="yes" xml:space="preserve">
          <source>With option -exec, walks tree in execute order, otherwise in basic order.</source>
          <target state="translated">使用选项-exec,按执行顺序走树,否则按基本顺序走。</target>
        </trans-unit>
        <trans-unit id="57d705a8d20354296c55ade02ce168e9aba3ea9c" translate="yes" xml:space="preserve">
          <source>With overloaded math, only the first two variants will result in a BigFloat:</source>
          <target state="translated">在超载的数学情况下,只有前两种变体会导致BigFloat。</target>
        </trans-unit>
        <trans-unit id="04cbc8f37da7397c953eb4dca3b6f0e0eee0dac0" translate="yes" xml:space="preserve">
          <source>With overloaded operators, it is the first (dominating) operand that determines which method is called. Here are some examples showing what actually gets called in various cases.</source>
          <target state="translated">对于重载操作符,决定调用哪个方法的是第一个(主导)操作符。下面是一些例子,说明在各种情况下实际被调用的方法。</target>
        </trans-unit>
        <trans-unit id="a2b46b3274ff332d0d8381195e802b804512dbcd" translate="yes" xml:space="preserve">
          <source>With proper care you may mix package and my (or state) &lt;code&gt;$a&lt;/code&gt; and/or &lt;code&gt;$b&lt;/code&gt;:</source>
          <target state="translated">经过适当的照顾，您可以将package和我（或声明） &lt;code&gt;$a&lt;/code&gt; 和/或 &lt;code&gt;$b&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f7d4085fcb09a164c92639ac09b2aa2b53f4f318" translate="yes" xml:space="preserve">
          <source>With respect to character matching, there are a few more points you need to know about. First of all, not all characters can be used &quot;as is&quot; in a match. Some characters, called</source>
          <target state="translated">关于字符匹配,还有几点你需要知道。首先,并不是所有的字符都能在匹配中 &quot;原样 &quot;使用。有些字符,被称为</target>
        </trans-unit>
        <trans-unit id="549d9ba8c522ce4226592827b058814ec17aafc9" translate="yes" xml:space="preserve">
          <source>With respect to character matching, there are a few more points you need to know about. First of all, not all characters can be used 'as is' in a match. Some characters, called</source>
          <target state="translated">关于字符匹配,还有几点你需要知道。首先,并不是所有的字符都可以在匹配中 &quot;原样 &quot;使用。有些字符,被称为</target>
        </trans-unit>
        <trans-unit id="f52704b066745f4539042b4ca42ac5911b1eae8e" translate="yes" xml:space="preserve">
          <source>With respect to files, one that has the proper permission bit set to let you access the file. With respect to computer programs, one that&amp;rsquo;s written well enough that someone has a chance of figuring out what it&amp;rsquo;s trying to do.</source>
          <target state="translated">对于文件，将其设置为正确的权限位以使您可以访问文件。关于计算机程序，一个编写得很好的程序使某人有机会弄清楚它要做什么。</target>
        </trans-unit>
        <trans-unit id="3dc4eefad3d29ef780cb07bfc36df49d416959b4" translate="yes" xml:space="preserve">
          <source>With respect to loading &lt;code&gt;Exporter&lt;/code&gt; and inheriting, there are alternatives with the use of modules like &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt; .</source>
          <target state="translated">关于加载 &lt;code&gt;Exporter&lt;/code&gt; 和继承，还有一些使用模块的替代方法，例如 &lt;code&gt;base&lt;/code&gt; 和 &lt;code&gt;parent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ddfefdcb8919ff4ad4881cdfab3eb3ea6c93a49" translate="yes" xml:space="preserve">
          <source>With respect to loading &lt;code&gt;Exporter&lt;/code&gt; and inheriting, there are alternatives with the use of modules like &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt;.</source>
          <target state="translated">关于加载 &lt;code&gt;Exporter&lt;/code&gt; 和继承，还有使用 &lt;code&gt;base&lt;/code&gt; 和 &lt;code&gt;parent&lt;/code&gt; 这样的模块的替代方法。</target>
        </trans-unit>
        <trans-unit id="64aab757411e3efe138dbb9f7787c6359c1eec8b" translate="yes" xml:space="preserve">
          <source>With some firewalls active mode does not work as the server cannot connect to your machine (because you are behind a firewall) and the firewall does not re-write the command. In this case you should set &lt;code&gt;ftp_ext_passive&lt;/code&gt; to a</source>
          <target state="translated">对于某些防火墙，活动模式不起作用，因为服务器无法连接到您的计算机（因为您位于防火墙后面），并且防火墙不会重新编写命令。在这种情况下，您应该将 &lt;code&gt;ftp_ext_passive&lt;/code&gt; 设置为</target>
        </trans-unit>
        <trans-unit id="39e7b288b06e2af98b83632e08ab80e03b9bf7c3" translate="yes" xml:space="preserve">
          <source>With source filters, you can store the text of your script compressed and use a source filter to uncompress it for Perl's parser:</source>
          <target state="translated">通过源码过滤器,你可以将脚本的文本压缩存储,然后使用源码过滤器为Perl的解析器解压。</target>
        </trans-unit>
        <trans-unit id="f3d0833032fe049783c845044de2a75767e40f62" translate="yes" xml:space="preserve">
          <source>With support for &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; this may be circumvented - unless one of DLLs is started from</source>
          <target state="translated">在支持 &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; 的情况下，可以避免这种情况-除非从以下一个DLL启动</target>
        </trans-unit>
        <trans-unit id="741296e189dd1627ab6af5dc824e2c81acff153a" translate="yes" xml:space="preserve">
          <source>With that trick MakeMaker will only read the first line and thus read the underscore, while the perl interpreter will evaluate the $VERSION and convert the string into a number. Later operations that treat $VERSION as a number will then be able to do so without provoking a warning about $VERSION not being a number.</source>
          <target state="translated">通过这个技巧,MakeMaker将只读取第一行,从而读取下划线,而perl解释器将评估$VERSION,并将字符串转换成一个数字。之后的操作如果把$VERSION当作数字来处理,就不会引起关于$VERSION不是数字的警告。</target>
        </trans-unit>
        <trans-unit id="fa542340f7199357b9ddb7d211923c323666ef12" translate="yes" xml:space="preserve">
          <source>With the &quot;tcp&quot; protocol the ping() method attempts to establish a connection to the remote host's echo port. If the connection is successfully established, the remote host is considered reachable. No data is actually echoed. This protocol does not require any special privileges but has higher overhead than the &quot;udp&quot; and &quot;icmp&quot; protocols.</source>
          <target state="translated">对于 &quot;tcp &quot;协议,ping()方法会尝试建立与远程主机回音端口的连接。如果连接成功建立,则认为远程主机是可到达的。实际上没有数据被呼应。这个协议不需要任何特殊的权限,但比 &quot;udp &quot;和 &quot;icmp &quot;协议的开销大。</target>
        </trans-unit>
        <trans-unit id="0c9c2cd66698ade01d6241c0c3475076fe41182f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma you can use the &lt;code&gt;:locale&lt;/code&gt; layer</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 编译指示，您可以使用 &lt;code&gt;:locale&lt;/code&gt; 层</target>
        </trans-unit>
        <trans-unit id="e4721b12184df4c626e83aff44b61b424dee2894" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. are immediately available for use in the replacement expression. With the global modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; will search and replace all occurrences of the regex in the string:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 运算符，匹配的变量 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等可立即用于替换表达式中。使用global修饰符， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; 将搜索并替换字符串中所有出现的正则表达式：</target>
        </trans-unit>
        <trans-unit id="a5f3ac7301bb1927406401553bc7979a7058d48f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma you can control the behaviour of the builtin &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 编译指示，您可以控制内置 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 函数的行为。</target>
        </trans-unit>
        <trans-unit id="ed30d894507576a6aff023249124e00f485a0445" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;IN&lt;/code&gt; subpragma you can declare the default layers of input streams, and with the &lt;code&gt;OUT&lt;/code&gt; subpragma you can declare the default layers of output streams. With the &lt;code&gt;IO&lt;/code&gt; subpragma (may be omitted for &lt;code&gt;:utf8&lt;/code&gt;, &lt;code&gt;:locale&lt;/code&gt;, or &lt;code&gt;:encoding&lt;/code&gt;) you can control both input and output streams simultaneously.</source>
          <target state="translated">使用 &lt;code&gt;IN&lt;/code&gt; 子编译，可以声明输入流的默认层，而使用 &lt;code&gt;OUT&lt;/code&gt; 子编译，可以声明输出流的默认层。使用 &lt;code&gt;IO&lt;/code&gt; 子编译（对于 &lt;code&gt;:utf8&lt;/code&gt; ， &lt;code&gt;:locale&lt;/code&gt; 或 &lt;code&gt;:encoding&lt;/code&gt; 可以省略），您可以同时控制输入和输出流。</target>
        </trans-unit>
        <trans-unit id="640e6849be58e830210cdb457742bd0e5d46239f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;IN&lt;/code&gt; subpragma you can declare the default layers of input streams, and with the &lt;code&gt;OUT&lt;/code&gt; subpragma you can declare the default layers of output streams. With the &lt;code&gt;IO&lt;/code&gt; subpragma you can control both input and output streams simultaneously.</source>
          <target state="translated">使用 &lt;code&gt;IN&lt;/code&gt; 子编译，可以声明输入流的默认层，而使用 &lt;code&gt;OUT&lt;/code&gt; 子编译，可以声明输出流的默认层。使用 &lt;code&gt;IO&lt;/code&gt; 子实用程序，您可以同时控制输入和输出流。</target>
        </trans-unit>
        <trans-unit id="9a9bb48f29cda9ceed93d7949280d0a2ae7a947b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; logical name defined as &quot;ENABLE&quot;, setting &lt;code&gt;$?&lt;/code&gt; will cause the new value to be encoded into &lt;code&gt;$^E&lt;/code&gt; so that either the original parent or child exit status values 0 to 255 can be automatically recovered by C programs expecting _POSIX_EXIT behavior. If both a parent and a child exit value are non-zero, then it will be assumed that this is actually a VMS native status value to be passed through. The special value of 0xFFFF is almost a NOOP as it will cause the current native VMS status in the C library to become the current native Perl VMS status, and is handled this way as it is known to not be a valid native VMS status value. It is recommend that only values in the range of normal Unix parent or child status numbers, 0 to 255 are used.</source>
          <target state="translated">将 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 逻辑名称定义为&amp;ldquo; ENABLE&amp;rdquo;，设置 &lt;code&gt;$?&lt;/code&gt; 将导致将新值编码为 &lt;code&gt;$^E&lt;/code&gt; 以便预期_POSIX_EXIT行为的C程序可以自动恢复原始的父出口或子出口状态值0至255。如果父出口值和子出口值都不为零，则将假定这实际上是要传递的VMS本机状态值。特殊值0xFFFF几乎是NOOP，因为它将导致C库中的当前本机VMS状态变为当前本机Perl VMS状态，并以这种方式进行处理，因为它不是有效的本机VMS状态值。建议仅使用正常Unix父或子状态编号范围内的值（0到255）。</target>
        </trans-unit>
        <trans-unit id="d83714fab9481b19a76857b0c66b38bb676d9244" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;open&lt;/code&gt; pragma you can use the &lt;code&gt;:locale&lt;/code&gt; layer</source>
          <target state="translated">使用 &lt;code&gt;open&lt;/code&gt; 编译指示，您可以使用 &lt;code&gt;:locale&lt;/code&gt; 层</target>
        </trans-unit>
        <trans-unit id="5aef762dfae7dd14d56c63866d88c9f9105ac20d" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;s///&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc. are immediately available for use in the replacement expression. With the global modifier, &lt;code&gt;s///g&lt;/code&gt; will search and replace all occurrences of the regex in the string:</source>
          <target state="translated">使用 &lt;code&gt;s///&lt;/code&gt; 运算符，匹配的变量 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等可立即用于替换表达式中。使用global修饰符， &lt;code&gt;s///g&lt;/code&gt; 将搜索并替换字符串中所有出现的正则表达式：</target>
        </trans-unit>
        <trans-unit id="2822b5f3a724906c266471a5abc1878fe1a5daf9" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;sort&lt;/code&gt; pragma you can control the behaviour of the builtin &lt;code&gt;sort()&lt;/code&gt; function.</source>
          <target state="translated">使用 &lt;code&gt;sort&lt;/code&gt; 编译指示，您可以控制内置 &lt;code&gt;sort()&lt;/code&gt; 函数的行为。</target>
        </trans-unit>
        <trans-unit id="d85c0b58283979a05b1d958cf7b8e77666b21187" translate="yes" xml:space="preserve">
          <source>With the C-style operators that would have been written like this:</source>
          <target state="translated">如果用C式运算符,本来是这样写的。</target>
        </trans-unit>
        <trans-unit id="12231f536f1fde7f945e73b86c0bb0963f5133af" translate="yes" xml:space="preserve">
          <source>With the FCGI module (from CPAN) and the mod_fastcgi module (available from &lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/&lt;/a&gt; ) each of your Perl programs becomes a permanent CGI daemon process.</source>
          <target state="translated">使用FCGI模块（来自CPAN）和mod_fastcgi模块（可从&lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/获得&lt;/a&gt;），每个Perl程序都将成为永久的CGI守护进程。</target>
        </trans-unit>
        <trans-unit id="e9f0f761b750ef587b104ca22707f7d417110d25" translate="yes" xml:space="preserve">
          <source>With the MASK argument present, it sets the operator mask for the compartment (equivalent to calling the deny_only method).</source>
          <target state="translated">在MASK参数存在的情况下,它为隔间设置操作者掩码(相当于调用deny_only方法)。</target>
        </trans-unit>
        <trans-unit id="a26ddc37c924b20873cf0fb8deaac6c02f3c0643" translate="yes" xml:space="preserve">
          <source>With the _POSIX_EXIT macro set, the Unix exit value of zero is represented as a VMS native status of 1, and the Unix values from 2 to 255 are encoded by the equation:</source>
          <target state="translated">在设置了_POSIX_EXIT宏后,Unix的退出值为0,表示为VMS的本机状态为1,从2到255的Unix值用公式编码。</target>
        </trans-unit>
        <trans-unit id="ca23bf605fbab54b13a6b11fd9b026fcad525316" translate="yes" xml:space="preserve">
          <source>With the above regexp all content following (and including) any of the given &lt;code&gt;=head1&lt;/code&gt; headings will be shown. It is possible to restrict the output to particular subsections only, e.g.:</source>
          <target state="translated">使用上述正则表达式，将显示（包括）任何给定 &lt;code&gt;=head1&lt;/code&gt; 标题之后的所有内容。可以仅将输出限制为特定的小节，例如：</target>
        </trans-unit>
        <trans-unit id="b04e80858e882edcc84d0f324c4fa0f1bc41eaae" translate="yes" xml:space="preserve">
          <source>With the check_sigs parameter you can turn signature checking on and off. The default is off for now because the whole tool chain for the functionality is not yet considered mature by some. The author of CPAN.pm would recommend setting it to true most of the time and turning it off only if it turns out to be annoying.</source>
          <target state="translated">通过check_sigs参数,你可以开启和关闭签名检查。目前默认的是关闭,因为整个工具链的功能还没有被一些人认为是成熟的。CPAN.pm的作者建议在大多数情况下将其设置为true,只有当它变得很烦人时才将其关闭。</target>
        </trans-unit>
        <trans-unit id="65d6f831578499e9dbe5b97d3e54d9d6970d12d6" translate="yes" xml:space="preserve">
          <source>With the completion of Example 4, we now have an easy way to simulate some real-life libraries whose interfaces may not be the cleanest in the world. We shall now continue with a discussion of the arguments passed to the &lt;b&gt;xsubpp&lt;/b&gt; compiler.</source>
          <target state="translated">完成示例4后，我们现在有了一种简单的方法来模拟一些现实世界的库，这些库的接口可能不是世界上最干净的。现在，我们将继续讨论传递给&lt;b&gt;xsubpp&lt;/b&gt;编译器的参数。</target>
        </trans-unit>
        <trans-unit id="1f205214a6ba2cf07a234149bf2d1460c5296c50" translate="yes" xml:space="preserve">
          <source>With the creation of the &lt;code&gt;IO::Compress&lt;/code&gt; and &lt;code&gt;IO::Uncompress&lt;/code&gt; modules no new features are planned for &lt;code&gt;Compress::Zlib&lt;/code&gt; - the new modules do everything that &lt;code&gt;Compress::Zlib&lt;/code&gt; does and then some. Development on &lt;code&gt;Compress::Zlib&lt;/code&gt; will be limited to bug fixes only.</source>
          <target state="translated">随着 &lt;code&gt;IO::Compress&lt;/code&gt; 和 &lt;code&gt;IO::Uncompress&lt;/code&gt; 模块的创建，没有为 &lt;code&gt;Compress::Zlib&lt;/code&gt; 计划新功能-新模块完成了 &lt;code&gt;Compress::Zlib&lt;/code&gt; 工作，然后执行了一些工作。在 &lt;code&gt;Compress::Zlib&lt;/code&gt; 进行的开发将仅限于错误修复。</target>
        </trans-unit>
        <trans-unit id="257b1120ebcd7fe1453a131da8ee68f42d2f7003" translate="yes" xml:space="preserve">
          <source>With the default setting of &lt;code&gt;$Storable::flags&lt;/code&gt; = 6, creating or destroying random objects, even renamed objects can be controlled by an attacker. See CVE-2015-1592 and its metasploit module.</source>
          <target state="translated">默认设置为 &lt;code&gt;$Storable::flags&lt;/code&gt; = 6，创建或销毁随机对象，甚至重命名的对象也可以由攻击者控制。请参阅CVE-2015-1592及其metasploit模块。</target>
        </trans-unit>
        <trans-unit id="23f3553b9522af30d1dac804157bedd65e6495d3" translate="yes" xml:space="preserve">
          <source>With the default setting the size is limited to 128MB. The -1 removes this limit. If the &quot;make test&quot; fails please change your /etc/security/limits as stated above.</source>
          <target state="translated">默认设置下,大小限制为128MB。而-1则会取消这个限制。如果 &quot;make test &quot;失败,请如上所述修改你的/etc/security/limits。</target>
        </trans-unit>
        <trans-unit id="9b9699d8827c96371e7103bd01aa95e9549d18da" translate="yes" xml:space="preserve">
          <source>With the example above, you knew to look for &lt;code&gt;Perl_pp_add&lt;/code&gt; , but what if there were multiple calls to it all over the place, or you didn't know what the op was you were looking for?</source>
          <target state="translated">在上面的示例中，您知道要查找 &lt;code&gt;Perl_pp_add&lt;/code&gt; ，但是如果到处都多次调用它，或者您不知道要查找的操作是什么呢？</target>
        </trans-unit>
        <trans-unit id="cfa6b797e8e5233002fffa69434e7ca138b4ff32" translate="yes" xml:space="preserve">
          <source>With the example above, you knew to look for &lt;code&gt;Perl_pp_add&lt;/code&gt;, but what if there were multiple calls to it all over the place, or you didn't know what the op was you were looking for?</source>
          <target state="translated">在上面的示例中，您知道要查找 &lt;code&gt;Perl_pp_add&lt;/code&gt; ，但是如果到处都有多次调用它，或者您不知道要查找的操作是什么，该怎么办？</target>
        </trans-unit>
        <trans-unit id="65607d779f766d1b6b4828b7428d0ded3d690325" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 32-bit mode.</source>
          <target state="translated">使用下面的选项可以得到一个在32位模式下通过所有make测试的Perl版本。</target>
        </trans-unit>
        <trans-unit id="a8358873bd6ba12b8e2a5bea80bf9adbb46e0a6e" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">使用下面的选项可以得到一个在64位模式下通过所有make测试的Perl版本。</target>
        </trans-unit>
        <trans-unit id="26bc1ab7fe70714950b9630e3ca1a3522b890186" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">使用下面的选项,你可以得到一个线程化的Perl版本,它可以通过64位模式下的所有make测试。</target>
        </trans-unit>
        <trans-unit id="653ecd70c393a4f98976d6cf49198158a3d68bae" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in threaded 32-bit mode, which is the default configuration for the Perl builds that AIX ships with.</source>
          <target state="translated">使用下面的选项,你可以得到一个线程化的Perl版本,它可以在线程化的32位模式下通过所有的make测试,这是AIX的Perl构建的默认配置。</target>
        </trans-unit>
        <trans-unit id="aeae9f602df12b1cbf706e0ffe90fc7d11fa8d65" translate="yes" xml:space="preserve">
          <source>With the help of Jarkko Hietaniemi the Configure system has been tweaked to run under abc-shell so the recommend build process is as follows.</source>
          <target state="translated">在Jarkko Hietaniemi的帮助下,Configure系统已经调整为在abc-shell下运行,所以推荐的构建过程如下。</target>
        </trans-unit>
        <trans-unit id="826dec98b275c7a952ab77d69c22223ec197d3b5" translate="yes" xml:space="preserve">
          <source>With the introduction of lexical warnings, mandatory warnings now become</source>
          <target state="translated">随着词性警告的引入,强制警告现在变成了。</target>
        </trans-unit>
        <trans-unit id="cb83c7552e22c7b5119774691db23c4fd72dba00" translate="yes" xml:space="preserve">
          <source>With the introduction of the</source>
          <target state="translated">引入了</target>
        </trans-unit>
        <trans-unit id="dd358809edabd87f2081065d37eb93940f155fac" translate="yes" xml:space="preserve">
          <source>With the lock released, process &quot;B&quot; can now continue. It also updates the database and unfortunately it too modifies the data that was in its initial buffer. Once that data gets flushed to disk it will overwrite some/all of the changes process &quot;A&quot; made to the database.</source>
          <target state="translated">随着锁的释放,进程 &quot;B &quot;现在可以继续。它还更新了数据库,不幸的是它也修改了最初缓冲区中的数据。一旦这些数据被刷新到磁盘上,它将覆盖进程 &quot;A &quot;对数据库所做的一些/全部修改。</target>
        </trans-unit>
        <trans-unit id="b4b71a45e3d179fe5db4257fdf8f0f1934140fcb" translate="yes" xml:space="preserve">
          <source>With the release 5.003_01 the dynamically loadable libraries should be rebuilt when a different version of Perl is compiled. In particular, DLLs (including</source>
          <target state="translated">随着5.003_01版本的发布,当编译不同版本的Perl时,动态加载的库应该被重建。特别是,DLLs(包括</target>
        </trans-unit>
        <trans-unit id="a313290bcf78e6ca63c8b821c60748978a4d212c" translate="yes" xml:space="preserve">
          <source>With this keyword present &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;&quot;The RETVAL Variable&quot;&lt;/a&gt; is created, and in the generated call to the subroutine this variable is assigned to, but the value of this variable is not going to be used in the auto-generated code.</source>
          <target state="translated">使用此关键字，&lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;将&lt;/a&gt;创建&amp;ldquo; RETVAL变量&amp;rdquo;，并在对子例程的生成的调用中将该变量分配给该变量，但是该变量的值将不会在自动生成的代码中使用。</target>
        </trans-unit>
        <trans-unit id="5325c34a4ae29cf34042f77f365e0b89df2159a0" translate="yes" xml:space="preserve">
          <source>With this keyword present &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;The RETVAL Variable&lt;/a&gt; is created, and in the generated call to the subroutine this variable is assigned to, but the value of this variable is not going to be used in the auto-generated code.</source>
          <target state="translated">在存在此关键字的情况下，&lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;将&lt;/a&gt;创建RETVAL变量，并在对该子例程的生成的调用中将其分配给该变量，但是该变量的值将不会在自动生成的代码中使用。</target>
        </trans-unit>
        <trans-unit id="92fdd49156ba7199f10cc8d72686bcba30a111b6" translate="yes" xml:space="preserve">
          <source>With this method you can specify your own boolean values for decoding - on decode, JSON &lt;code&gt;false&lt;/code&gt; will be decoded as a copy of &lt;code&gt;$false&lt;/code&gt;, and JSON &lt;code&gt;true&lt;/code&gt; will be decoded as &lt;code&gt;$true&lt;/code&gt; (&quot;copy&quot; here is the same thing as assigning a value to another variable, i.e. &lt;code&gt;$copy = $false&lt;/code&gt;).</source>
          <target state="translated">使用此方法，您可以指定自己的布尔值进行解码-解码时，JSON &lt;code&gt;false&lt;/code&gt; 将被解码为 &lt;code&gt;$false&lt;/code&gt; 的副本，而JSON &lt;code&gt;true&lt;/code&gt; 将被解码为 &lt;code&gt;$true&lt;/code&gt; （&amp;ldquo; copy&amp;rdquo;在这里与分配值相同到另一个变量，即 &lt;code&gt;$copy = $false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="666c6c1292ea8eefe8526f26c75c36dbe91118ff" translate="yes" xml:space="preserve">
          <source>With this module, simply change all &lt;code&gt;use_ok&lt;/code&gt; in test scripts to &lt;code&gt;use ok&lt;/code&gt;, and they will be executed at &lt;code&gt;BEGIN&lt;/code&gt; time.</source>
          <target state="translated">使用此模块，只需将测试脚本中的所有 &lt;code&gt;use_ok&lt;/code&gt; 更改为 &lt;code&gt;use ok&lt;/code&gt; ，它们就会在 &lt;code&gt;BEGIN&lt;/code&gt; 时间执行。</target>
        </trans-unit>
        <trans-unit id="153c87b7fb53ffdf16b2513e4ef9fbf84bb1453a" translate="yes" xml:space="preserve">
          <source>With this module, simply change all &lt;code&gt;use_ok&lt;/code&gt; in test scripts to &lt;code&gt;use ok&lt;/code&gt;, and they will be executed at &lt;code&gt;BEGIN&lt;/code&gt; time. The explicit space after &lt;code&gt;use&lt;/code&gt; makes it clear that this is a single compile-time action.</source>
          <target state="translated">使用此模块，只需将测试脚本中的所有 &lt;code&gt;use_ok&lt;/code&gt; 更改为 &lt;code&gt;use ok&lt;/code&gt; ，它们就会在 &lt;code&gt;BEGIN&lt;/code&gt; 时间执行。 &lt;code&gt;use&lt;/code&gt; 后的显式空间清楚表明这是一个编译时操作。</target>
        </trans-unit>
        <trans-unit id="1f7c25b6745f51eae37c62a2374f7ba131484e1b" translate="yes" xml:space="preserve">
          <source>With this option, the rendering of each statement (starting with the nextstate OP) will be preceded by the 1st line of source code that generates it. For example:</source>
          <target state="translated">使用这个选项,每条语句(从nextstate OP开始)的渲染将在生成它的第1行源代码之前。例如</target>
        </trans-unit>
        <trans-unit id="8f18c563efb0b7956e6e194500e98dba172fcbe5" translate="yes" xml:space="preserve">
          <source>With this syntax, the whitespace character(s) after the &quot;C&amp;lt;&amp;lt;&amp;lt;&quot; and before the &quot;&amp;gt;&amp;gt;&amp;gt;&quot; (or whatever letter) are</source>
          <target state="translated">使用这种语法，&amp;ldquo; C &amp;lt;&amp;lt;&amp;lt;&amp;rdquo;之后和&amp;ldquo; &amp;gt;&amp;gt;&amp;gt;&amp;rdquo;（或任何字母）之前的空格字符是</target>
        </trans-unit>
        <trans-unit id="9b739cdb3f9d5a8eac7c3872d89896d374a02d63" translate="yes" xml:space="preserve">
          <source>With this, &quot;somepackage&quot; will be required, then the stash is inspected, and each function is rendered.</source>
          <target state="translated">有了这个,就需要 &quot;somepackage&quot;,然后检查储藏室,每个功能都会呈现。</target>
        </trans-unit>
        <trans-unit id="a5fec2f4d5db8c4f13f212d9ea51033367a444e6" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;charinrange()&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if its input code point maps to &lt;code&gt;$default&lt;/code&gt; . You can avoid this by omitting the &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement, and adding a line after the loop to handle the final element of the inversion map.</source>
          <target state="translated">这样，如果 &lt;code&gt;charinrange()&lt;/code&gt; 的输入代码点映射到 &lt;code&gt;$default&lt;/code&gt; 它将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。您可以通过省略 &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 一条语句并在循环后添加一行以处理反转映射的最后一个元素来避免这种情况。</target>
        </trans-unit>
        <trans-unit id="1fa4ea5d2b0cc15e776882f8e7626028cc55d8d1" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;charinrange()&lt;/code&gt; will return &lt;code&gt;undef&lt;/code&gt; if its input code point maps to &lt;code&gt;$default&lt;/code&gt;. You can avoid this by omitting the &lt;code&gt;next&lt;/code&gt; statement, and adding a line after the loop to handle the final element of the inversion map.</source>
          <target state="translated">这样，如果 &lt;code&gt;charinrange()&lt;/code&gt; 的输入代码点映射到 &lt;code&gt;$default&lt;/code&gt; 它将返回 &lt;code&gt;undef&lt;/code&gt; 。您可以通过省略 &lt;code&gt;next&lt;/code&gt; 一条语句并在循环后添加一行以处理反转映射的最后一个元素来避免这种情况。</target>
        </trans-unit>
        <trans-unit id="cf65bbf1a94d413d2ba7d4e9b042fb1c11c5b955" translate="yes" xml:space="preserve">
          <source>With those two in hand, you should add</source>
          <target state="translated">有了这两点,你应该加上</target>
        </trans-unit>
        <trans-unit id="6dae05359217975cb78e41e5b34deca474650edf" translate="yes" xml:space="preserve">
          <source>With threads one must be careful to make sure they all have a chance to run to completion, assuming that is what you want.</source>
          <target state="translated">对于线程,人们必须小心翼翼地确保它们都有机会运行完成,假设这是你想要的。</target>
        </trans-unit>
        <trans-unit id="caa257633e4cd0d103eaaa262d9da80593127c23" translate="yes" xml:space="preserve">
          <source>With todo tests, it's best to have the tests actually run. That way you'll know when they start passing. Sometimes this isn't possible. Often a failing test will cause the whole program to die or hang, even inside an &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; with and using &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;. In these extreme cases you have no choice but to skip over the broken tests entirely.</source>
          <target state="translated">使用待办事项测试，最好让测试实际运行。这样，您就会知道它们何时开始通过。有时这是不可能的。测试失败通常会导致整个程序死机或挂起，即使在使用并使用 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; 中也是如此。在这些极端情况下，您别无选择，只能完全跳过损坏的测试。</target>
        </trans-unit>
        <trans-unit id="72faa2ea768ae70d5c7c6ca8ac92ad17c2ec51b0" translate="yes" xml:space="preserve">
          <source>With todo tests, it's best to have the tests actually run. That way you'll know when they start passing. Sometimes this isn't possible. Often a failing test will cause the whole program to die or hang, even inside an &lt;code&gt;eval BLOCK&lt;/code&gt; with and using &lt;code&gt;alarm&lt;/code&gt;. In these extreme cases you have no choice but to skip over the broken tests entirely.</source>
          <target state="translated">使用待办事项测试时，最好让测试实际运行。这样，您就会知道它们何时开始通过。有时这是不可能的。测试失败通常会导致整个程序死机或挂起，即使在使用并使用 &lt;code&gt;alarm&lt;/code&gt; 的 &lt;code&gt;eval BLOCK&lt;/code&gt; 中也是如此。在这些极端情况下，您别无选择，只能完全跳过损坏的测试。</target>
        </trans-unit>
        <trans-unit id="ec0e094c2438c09cc3dbc2cdfeb2a697dd782dc5" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;(?[ ])&lt;/code&gt; , no literal characters are allowed unless they are within an inner pair of square brackets, like</source>
          <target state="translated">在 &lt;code&gt;(?[ ])&lt;/code&gt; ，不允许文字字符，除非它们在一对方括号内，例如</target>
        </trans-unit>
        <trans-unit id="2c0a661c629aabc7b0ae903d13c19ad238648286" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;(?[ ])&lt;/code&gt;, no literal characters are allowed unless they are within an inner pair of square brackets, like</source>
          <target state="translated">在 &lt;code&gt;(?[ ])&lt;/code&gt; ，不允许任何文字字符，除非它们在一个内部的方括号内，例如</target>
        </trans-unit>
        <trans-unit id="2e8425db1df10e66ba739a46b6d044fcd9cc27fd" translate="yes" xml:space="preserve">
          <source>Within Perl, you may use this directly:</source>
          <target state="translated">在Perl中,你可以直接使用这个。</target>
        </trans-unit>
        <trans-unit id="34e265601157e7965a7e7bfdb3408a61baf139df" translate="yes" xml:space="preserve">
          <source>Within USS your /etc/profile or $HOME/.profile may limit your ulimit settings. Check that the following command returns reasonable values:</source>
          <target state="translated">在 USS 中,你的 /etc/profile 或 $HOME/.profile 可能会限制你的 ulimit 设置。检查以下命令是否返回合理的值。</target>
        </trans-unit>
        <trans-unit id="a1b6f4407e8eee6ed8eafbd79c8d18589c6adc10" translate="yes" xml:space="preserve">
          <source>Within []-length '%c' not allowed</source>
          <target state="translated">不允许在[]长度内的'%c'。</target>
        </trans-unit>
        <trans-unit id="29ba20619ba09719c47471e336e4ab5403150666" translate="yes" xml:space="preserve">
          <source>Within a Pod block, there are &lt;b&gt;Pod paragraphs&lt;/b&gt;. A Pod paragraph consists of non-blank lines of text, separated by one or more blank lines.</source>
          <target state="translated">在Pod块中，有&lt;b&gt;Pod段落&lt;/b&gt;。Pod段落由非空白文本行组成，并由一个或多个空白行分隔。</target>
        </trans-unit>
        <trans-unit id="e21031e24f9ec987f957a61688b27e62b9c110c1" translate="yes" xml:space="preserve">
          <source>Within a character class:</source>
          <target state="translated">在一个角色类内。</target>
        </trans-unit>
        <trans-unit id="40c178236d58dee9559c7a2a4195e7fba2bd546e" translate="yes" xml:space="preserve">
          <source>Within a pattern, you may designate subpatterns for later reference by enclosing them in parentheses, and you may refer back to the</source>
          <target state="translated">在一个模式中,你可以用括号指定子模式供以后参考,你也可以回溯至</target>
        </trans-unit>
        <trans-unit id="0cfdb7962d912e72a66b4f3d5343b1e5e212ac27" translate="yes" xml:space="preserve">
          <source>Within a subroutine the array &lt;code&gt;@_&lt;/code&gt; contains the parameters passed to that subroutine. Inside a subroutine, &lt;code&gt;@_&lt;/code&gt; is the default array for the array operators &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在子例程中，数组 &lt;code&gt;@_&lt;/code&gt; 包含传递给该子例程的参数。在子例程中，@ &lt;code&gt;@_&lt;/code&gt; 是数组运算符 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 的默认数组。</target>
        </trans-unit>
        <trans-unit id="e22e0024e5aeb5956fe2008749d86a9a403a100c" translate="yes" xml:space="preserve">
          <source>Within a subroutine the array &lt;code&gt;@_&lt;/code&gt; contains the parameters passed to that subroutine. Inside a subroutine, &lt;code&gt;@_&lt;/code&gt; is the default array for the array operators &lt;code&gt;pop&lt;/code&gt; and &lt;code&gt;shift&lt;/code&gt;.</source>
          <target state="translated">在子例程中，数组 &lt;code&gt;@_&lt;/code&gt; 包含传递给该子例程的参数。在子例程中，@ &lt;code&gt;@_&lt;/code&gt; 是数组运算符 &lt;code&gt;pop&lt;/code&gt; 和 &lt;code&gt;shift&lt;/code&gt; 的默认数组。</target>
        </trans-unit>
        <trans-unit id="61eb6fb3f1061f743841ee282bbf0ef293486491" translate="yes" xml:space="preserve">
          <source>Within each function inside each Xsub, print to the</source>
          <target state="translated">在每个Xsub内的每个函数中,打印到</target>
        </trans-unit>
        <trans-unit id="2ab4fe9703eceeab90b6dcb41e63f66c50a795d5" translate="yes" xml:space="preserve">
          <source>Within search patterns (which also undergo double-quotish substitution) there is an unfortunate ambiguity: Is &lt;code&gt;/$foo[bar]/&lt;/code&gt; to be interpreted as &lt;code&gt;/${foo}[bar]/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is a character class for the regular expression) or as &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is the subscript to array @foo)? If @foo doesn't otherwise exist, then it's obviously a character class. If @foo exists, Perl takes a good guess about &lt;code&gt;[bar]&lt;/code&gt; , and is almost always right. If it does guess wrong, or if you're just plain paranoid, you can force the correct interpretation with curly braces as above.</source>
          <target state="translated">在搜索模式（也进行双引号替换）中，存在一个模糊的歧义： &lt;code&gt;/$foo[bar]/&lt;/code&gt; 被解释为 &lt;code&gt;/${foo}[bar]/&lt;/code&gt; （其中 &lt;code&gt;[bar]&lt;/code&gt; 是正则表达式）还是 &lt;code&gt;/${foo[bar]}/&lt;/code&gt; （其中 &lt;code&gt;[bar]&lt;/code&gt; 是数组@foo的下标）？如果@foo不存在，则显然是字符类。如果@foo存在，Perl会对 &lt;code&gt;[bar]&lt;/code&gt; 做出很好的猜测，并且几乎总是正确的。如果确实猜错了，或者只是个偏执狂，则可以如上所述使用花括号强行进行正确的解释。</target>
        </trans-unit>
        <trans-unit id="7cb74f80aa6eb14f52d2f4452df6c30aa1982c05" translate="yes" xml:space="preserve">
          <source>Within search patterns (which also undergo double-quotish substitution) there is an unfortunate ambiguity: Is &lt;code&gt;/$foo[bar]/&lt;/code&gt; to be interpreted as &lt;code&gt;/${foo}[bar]/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is a character class for the regular expression) or as &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is the subscript to array @foo)? If @foo doesn't otherwise exist, then it's obviously a character class. If @foo exists, Perl takes a good guess about &lt;code&gt;[bar]&lt;/code&gt;, and is almost always right. If it does guess wrong, or if you're just plain paranoid, you can force the correct interpretation with curly braces as above.</source>
          <target state="translated">在搜索模式（也会进行双引号替换）中，有一个不幸的歧义： &lt;code&gt;/$foo[bar]/&lt;/code&gt; 被解释为 &lt;code&gt;/${foo}[bar]/&lt;/code&gt; （其中 &lt;code&gt;[bar]&lt;/code&gt; 是正则表达式）还是 &lt;code&gt;/${foo[bar]}/&lt;/code&gt; （其中 &lt;code&gt;[bar]&lt;/code&gt; 是数组@foo的下标）？如果@foo否则不存在，则显然是字符类。如果@foo存在，Perl会很好地猜测 &lt;code&gt;[bar]&lt;/code&gt; ，并且几乎总是正确的。如果确实猜错了，或者只是个偏执狂，则可以使用上述花括号强制使用正确的解释。</target>
        </trans-unit>
        <trans-unit id="d84dbb525d8c49a11b671ff1144decfba831a5a9" translate="yes" xml:space="preserve">
          <source>Within strings that are to be displayed in a fixed-length text field, each control character is substituted by a space. (But remember the special meaning of &lt;code&gt;\r&lt;/code&gt; when using fill mode.) This is done to avoid misalignment when control characters &quot;disappear&quot; on some output media.</source>
          <target state="translated">在要在固定长度的文本字段中显示的字符串中，每个控制字符都用空格代替。（但是，请记住使用 &lt;code&gt;\r&lt;/code&gt; 填充模式时\ r的特殊含义。）这样做是为了避免某些输出媒体上的控制字符&amp;ldquo;消失&amp;rdquo;时出现未对齐的情况。</target>
        </trans-unit>
        <trans-unit id="4456754ccf74e411d5ea49ec8792a5f2c7c3945a" translate="yes" xml:space="preserve">
          <source>Within that basic form, add the parts that you need to insert, change, or delete lines.</source>
          <target state="translated">在该基本表格中,添加需要插入、更改或删除行的部分。</target>
        </trans-unit>
        <trans-unit id="8cbc5afc548aa028061d92c2e27d708ba5cdc361" translate="yes" xml:space="preserve">
          <source>Within that module, create an &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine.</source>
          <target state="translated">在该模块中，创建一个 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程。</target>
        </trans-unit>
        <trans-unit id="dff20e9d902ef01082006d18ff0c36d8795b519a" translate="yes" xml:space="preserve">
          <source>Within that module, create an &lt;code&gt;import&lt;/code&gt; subroutine.</source>
          <target state="translated">在该模块中，创建一个 &lt;code&gt;import&lt;/code&gt; 子例程。</target>
        </trans-unit>
        <trans-unit id="8c44a88f26bc68b39089193962c587ad7e818543" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine do a call to &lt;code&gt;filter_add&lt;/code&gt; , passing it either a subroutine reference.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程中，调用 &lt;code&gt;filter_add&lt;/code&gt; ，将其传递给子例程引用。</target>
        </trans-unit>
        <trans-unit id="5abecf0e7e2c92cb0f99df6a077dc9ac3a61e15b" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;import&lt;/code&gt; subroutine do a call to &lt;code&gt;filter_add&lt;/code&gt;, passing it either a subroutine reference.</source>
          <target state="translated">在 &lt;code&gt;import&lt;/code&gt; 子例程中，调用 &lt;code&gt;filter_add&lt;/code&gt; ，将其传递给子例程引用。</target>
        </trans-unit>
        <trans-unit id="66ccfeaad3b7f2de2f94c5b7b2a2afe57c62216c" translate="yes" xml:space="preserve">
          <source>Within the alternative numbering group, group numbers start at the same position for each alternative. After the group, numbering continues with one higher than the maximum reached across all the alternatives.</source>
          <target state="translated">在备选编号组内,每个备选方案的组号从同一位置开始。在该组之后,以高于所有替代品所达到的最大值的一个数字继续编号。</target>
        </trans-unit>
        <trans-unit id="bee307dd55ae8e02f4730b754c6aca4828fa5f41" translate="yes" xml:space="preserve">
          <source>Within the anonymous subroutine or block that is passed to &lt;code&gt;FILTER&lt;/code&gt; , process the contents of $_ to change the source code in the desired manner.</source>
          <target state="translated">在传递给 &lt;code&gt;FILTER&lt;/code&gt; 的匿名子例程或块中，处理$ _的内容以所需的方式更改源代码。</target>
        </trans-unit>
        <trans-unit id="f2c9c97c479e458c15e3c5d21939c42abe0d2569" translate="yes" xml:space="preserve">
          <source>Within the anonymous subroutine or block that is passed to &lt;code&gt;FILTER&lt;/code&gt;, process the contents of $_ to change the source code in the desired manner.</source>
          <target state="translated">在传递给 &lt;code&gt;FILTER&lt;/code&gt; 的匿名子例程或块中，处理$ _的内容以所需的方式更改源代码。</target>
        </trans-unit>
        <trans-unit id="4dffaf4183817eca592a98bbc21aa16f78f04d43" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;use feature 'unicode_strings'&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">在使用范围内的&lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="00c20e56f1d9e34b6bd5de0acc2c9d7db7958c51" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;use feature 'unicode_strings' &lt;/a&gt;</source>
          <target state="translated">在使用范围内的&lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;功能'unicode_strings'&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f89e477d30d08ce7cdab550d7ebf952c865e297" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt;, all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">在&lt;a href=&quot;locale&quot;&gt; &lt;code&gt;use locale&lt;/code&gt; &lt;/a&gt;的范围内，无论字符串是否编码为UTF-8，都引用所有非ASCII Latin1代码点。如上所述，语言环境不会影响ASCII范围字符的引用。这可以防止出现诸如 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 字符的语言环境。被认为是文字字符。</target>
        </trans-unit>
        <trans-unit id="5cdd83d3707c192ff676dcfeb7f714897a412bb4" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;&lt;code&gt;use locale 'not_characters'&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;perllocale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt; and the current locale is a UTF-8 locale.</source>
          <target state="translated">在&lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt; &lt;code&gt;use locale 'not_characters'&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;perllocale&quot;&gt; &lt;code&gt;use locale&lt;/code&gt; &lt;/a&gt;的范围内，当前区域设置为UTF-8区域设置。</target>
        </trans-unit>
        <trans-unit id="db5115b248b9b3a92796783fe0ad72c64d3ee250" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;use locale 'not_characters' &lt;/a&gt;, or &lt;a href=&quot;perllocale&quot;&gt;use locale &lt;/a&gt; and the current locale is a UTF-8 locale.</source>
          <target state="translated">在&lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;使用区域设置'not_characters'&lt;/a&gt;或&lt;a href=&quot;perllocale&quot;&gt;使用区域设置&lt;/a&gt;的范围内，当前区域设置为UTF-8区域设置。</target>
        </trans-unit>
        <trans-unit id="4b75686c25d4349996112a3e43d160bed9377b64" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 或更高的&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;范围内</target>
        </trans-unit>
        <trans-unit id="921e8cdb506222d3c5cb715870308743278f73c9" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 的范围内，无论字符串是否编码为UTF-8，都引用所有非ASCII Latin1代码点。如上所述，语言环境不会影响ASCII范围字符的引用。这可以防止出现诸如 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 字符的语言环境。被认为是文字字符。</target>
        </trans-unit>
        <trans-unit id="7f97b0baeb5c1f48ecb7c6036a913594c0cf832a" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 的&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;范围内</target>
        </trans-unit>
        <trans-unit id="6c6da8dacdcff581b760f12d305142c260f19722" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 的范围内，无论字符串是否编码为UTF-8，都引用所有非ASCII Latin1代码点。如上所述，语言环境不会影响ASCII范围字符的引用。这可以防止出现诸如 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 字符的语言环境。被认为是文字字符。</target>
        </trans-unit>
        <trans-unit id="9be64790ef4be673df7cd3468e821cd802e4c982" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;use 5.012&lt;/code&gt; or higher</source>
          <target state="translated">在 &lt;code&gt;use 5.012&lt;/code&gt; 或更高的使用范围内</target>
        </trans-unit>
        <trans-unit id="c2f08cf765adbbec5334990e6d1e73f436a06d62" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;use re 'strict'&lt;/code&gt; in a regular expression pattern, you included an unescaped &lt;code&gt;}&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt; which was interpreted literally. These two characters are sometimes metacharacters, and sometimes literals, depending on what precedes them in the pattern. This is unlike the similar &lt;code&gt;)&lt;/code&gt; which is always a metacharacter unless escaped.</source>
          <target state="translated">在正则表达式模式中 &lt;code&gt;use re 'strict'&lt;/code&gt; 的使用范围内，您包括了未经转义的 &lt;code&gt;}&lt;/code&gt; 或 &lt;code&gt;]&lt;/code&gt; ，它们是按字面解释的。这两个字符有时是元字符，有时是文字，具体取决于模式中它们之前的内容。这与类似的 &lt;code&gt;)&lt;/code&gt; 不同，后者始终是一个元字符，除非进行转义。</target>
        </trans-unit>
        <trans-unit id="872708d75ba2c62155c9282b19d1ffd74c4ecb87" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;use utf8&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;use utf8&lt;/code&gt; 的使用范围内</target>
        </trans-unit>
        <trans-unit id="b93e8b9c84e9c172138891ffbac960fd8330a481" translate="yes" xml:space="preserve">
          <source>Within the subroutine reference, call &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; to &quot;prime&quot; $_ with source code data from the source file that will &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; your module. Check the status value returned to see if any source code was actually read in.</source>
          <target state="translated">在子例程引用中， &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 将使用模块的源文件中的源代码数据，调用 &lt;code&gt;filter_read&lt;/code&gt; 或 &lt;code&gt;filter_read_exact&lt;/code&gt; 来对$ _进行&amp;ldquo; prime&amp;rdquo; 。检查返回的状态值以查看是否实际读入任何源代码。</target>
        </trans-unit>
        <trans-unit id="de9983c2f6aa6265b66999a54845fc283501a6b7" translate="yes" xml:space="preserve">
          <source>Within the subroutine reference, call &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; to &quot;prime&quot; $_ with source code data from the source file that will &lt;code&gt;use&lt;/code&gt; your module. Check the status value returned to see if any source code was actually read in.</source>
          <target state="translated">在子例程引用中， &lt;code&gt;use&lt;/code&gt; 将使用模块的源文件中的源代码数据，调用 &lt;code&gt;filter_read&lt;/code&gt; 或 &lt;code&gt;filter_read_exact&lt;/code&gt; 以&amp;ldquo;素&amp;rdquo; $ _ 。检查返回的状态值，以查看是否实际读入任何源代码。</target>
        </trans-unit>
        <trans-unit id="7d5ec220eb3f4bb73f8ef5f923e39ec8ab09a071" translate="yes" xml:space="preserve">
          <source>Within the while loop we call accept() and check to see if it returns a false value. This would normally indicate a system error needs to be reported. However, the introduction of safe signals (see &lt;a href=&quot;#Deferred-Signals-%28Safe-Signals%29&quot;&gt;&quot;Deferred Signals (Safe Signals)&quot;&lt;/a&gt; above) in Perl 5.8.0 means that accept() might also be interrupted when the process receives a signal. This typically happens when one of the forked subprocesses exits and notifies the parent process with a CHLD signal.</source>
          <target state="translated">在while循环中，我们调用accept（）并检查其是否返回假值。这通常表示需要报告系统错误。但是，在Perl 5.8.0中引入了安全信号（请参见上面的&lt;a href=&quot;#Deferred-Signals-%28Safe-Signals%29&quot;&gt;&amp;ldquo;延迟的信号（安全信号）&amp;rdquo;&lt;/a&gt;），这意味着当进程接收到信号时，accept（）也可能会被中断。当派生的子流程之一退出并用CHLD信号通知父流程时，通常会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="4f5dc8da9477105396ff0284ea2a7a7433b232a3" translate="yes" xml:space="preserve">
          <source>Within the while loop we call accept() and check to see if it returns a false value. This would normally indicate a system error needs to be reported. However, the introduction of safe signals (see &lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals)&lt;/a&gt; above) in Perl 5.8.0 means that accept() might also be interrupted when the process receives a signal. This typically happens when one of the forked subprocesses exits and notifies the parent process with a CHLD signal.</source>
          <target state="translated">在while循环中，我们调用accept（）并检查其是否返回假值。这通常表示需要报告系统错误。但是，在Perl 5.8.0中引入了安全信号（请参阅上面的&lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;延迟信号（安全信号）&lt;/a&gt;），这意味着当进程接收到信号时，accept（）也可能会中断。这通常在派生子流程之一退出并用CHLD信号通知父流程时发生。</target>
        </trans-unit>
        <trans-unit id="17b7808b8c8156fa9926b089d73ad2021671fe67" translate="yes" xml:space="preserve">
          <source>Without Readline support you may see the symbols &quot;^[[A&quot;, &quot;^[[C&quot;, &quot;^[[B&quot;, &quot;^[[D&quot;&quot;, &quot;^H&quot;, ... when using the arrow keys and/or the backspace key.</source>
          <target state="translated">如果没有Readline支持,当使用方向键和/或退格键时,你可能会看到符号&quot;^[[A&quot;,&quot;^[[C&quot;,&quot;^[[B&quot;,&quot;^[[D&quot;&quot;,&quot;^H&quot;,...。</target>
        </trans-unit>
        <trans-unit id="7a72072ff5468f365a1052f00033c60b07221002" translate="yes" xml:space="preserve">
          <source>Without additional configuration, GetOptions() will ignore the case of option names, and allow the options to be abbreviated to uniqueness.</source>
          <target state="translated">在没有额外配置的情况下,GetOptions()将忽略选项名称的大小写,并允许选项被缩写为唯一性。</target>
        </trans-unit>
        <trans-unit id="6c913350e18f669953ddd82b1ef504eb99115e6c" translate="yes" xml:space="preserve">
          <source>Without any such configuration, or if Perl itself is built using the system's own IO, then write operations assume that the file handle accepts only</source>
          <target state="translated">如果没有任何这样的配置,或者如果Perl本身是使用系统自带的IO构建的,那么写操作就会假设文件句柄仅接受</target>
        </trans-unit>
        <trans-unit id="298442b657e2392a0a1bf4ca9f3ba61c68419ef3" translate="yes" xml:space="preserve">
          <source>Without argument, it returns the currently used icmp protocol message type. By default, it returns 'echo'.</source>
          <target state="translated">在没有参数的情况下,它返回当前使用的icmp协议消息类型。默认情况下,它返回'echo'。</target>
        </trans-unit>
        <trans-unit id="d5efb30492f1c199d1a2c0cf117a4ad4a638df64" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves a regular expression for simplifying the individual item strings once the list type has been determined. Usage: E.g. when converting to HTML, one might strip the leading number in an ordered list as &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; already prints numbers itself. This must have been set before by either specifying &lt;b&gt;-rx&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;rx()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，一旦确定了列表类型，就检索一个用于简化单个项目字符串的正则表达式。使用方法：例如转换为HTML时，人们可能会作为剥离以有序列表中的前导号码 &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; 已打印号码本身。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-rx&lt;/b&gt;或使用标量参数调用&lt;b&gt;rx（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="18657a3de0c78898530507337e291d8dba0f72cc" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the list tag, which can be any scalar. This must have been set before by either specifying &lt;b&gt;-tag&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;tag()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索有关列表标记的信息，该标记可以是任何标量。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-tag&lt;/b&gt;或通过使用标量参数调用&lt;b&gt;tag（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ccc25a668b5326c657bc2f5c79197991b145ee7" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the parent holding this list, which is represented as an arbitrary scalar. This must have been set before by either specifying &lt;b&gt;-parent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;parent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索有关持有此列表的父级的信息，以任意标量表示。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-parent&lt;/b&gt;或使用标量参数调用&lt;b&gt;parent（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c9f5dc6cba8c17ba8a8e789cb997502b75241827" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the array of the items in this list. The items may be represented by any scalar. If an argument has been given, it is pushed on the list of items.</source>
          <target state="translated">在没有参数的情况下,检索列表中的项目数组。项目可以用任何标量表示。如果有参数,则推送到项目列表中。</target>
        </trans-unit>
        <trans-unit id="b13b7cf761d2e7e6717a0226cb08e73a66d55812" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the file name the list is in. This must have been set before by either specifying &lt;b&gt;-file&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;file()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索列表所在的文件名。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-file&lt;/b&gt;或使用标量参数调用&lt;b&gt;file（）&lt;/b&gt;方法来设置此名称。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1b1eba0344418f60cab2e73b154b51b8cc2fd939" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the indent level of the list as specified in &lt;code&gt;=over n&lt;/code&gt; . This must have been set before by either specifying &lt;b&gt;-indent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;indent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索 &lt;code&gt;=over n&lt;/code&gt; 中指定的列表的缩进级别。必须在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-indent&lt;/b&gt;或通过使用标量参数调用&lt;b&gt;indent（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c3a863e0f35dbdfaea66e845edf4708bb6d53918" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the line number where the list started. This must have been set before by either specifying &lt;b&gt;-start&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;start()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索列表开始的行号。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-start&lt;/b&gt;或使用标量参数调用&lt;b&gt;start（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="914d0fa2ff8badbccd79dfd30e292a8ed73be0c1" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the list type, which can be an arbitrary value, e.g. &lt;code&gt;OL&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , ... when thinking the HTML way. This must have been set before by either specifying &lt;b&gt;-type&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;type()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索列表类型，当考虑HTML方式时，它可以是任意值，例如 &lt;code&gt;OL&lt;/code&gt; ， &lt;code&gt;UL&lt;/code&gt; ，...。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-type&lt;/b&gt;或使用标量参数调用&lt;b&gt;type（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c21aaff33380d9ba14cee3094239dfc4fb494ab" translate="yes" xml:space="preserve">
          <source>Without arguments libnetcfg displays the current configuration.</source>
          <target state="translated">在没有参数的情况下,libnetcfg会显示当前配置。</target>
        </trans-unit>
        <trans-unit id="4decffda157c9d482865e95a2bef98fbdd07c180" translate="yes" xml:space="preserve">
          <source>Without autodie (and assuming BAREWORD is an open filehandle/dirhandle) this is a valid call to chdir. But under autodie, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; will behave like it had the prototype &quot;;$&quot; and thus BAREWORD will be a syntax error (under &quot;use strict&quot;. Without strict, it will interpreted as a filename).</source>
          <target state="translated">没有autodie（并且假设BAREWORD是打开的文件句柄/目录句柄），这是对chdir的有效调用。但是在autodie下， &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 的行为将类似于原型&amp;ldquo;; $&amp;rdquo;，因此BAREWORD将是语法错误（在&amp;ldquo; use strict&amp;rdquo;下。如果没有strict，它将被解释为文件名）。</target>
        </trans-unit>
        <trans-unit id="4f60150307dd02c8b93f0a67955bd9770e2759c8" translate="yes" xml:space="preserve">
          <source>Without autodie (and assuming BAREWORD is an open filehandle/dirhandle) this is a valid call to chdir. But under autodie, &lt;code&gt;chdir&lt;/code&gt; will behave like it had the prototype &quot;;$&quot; and thus BAREWORD will be a syntax error (under &quot;use strict&quot;. Without strict, it will interpreted as a filename).</source>
          <target state="translated">如果不使用autodie（并且假设BAREWORD是打开的文件句柄/目录句柄），则这是对chdir的有效调用。但是在autodie下， &lt;code&gt;chdir&lt;/code&gt; 的行为将类似于原型&amp;ldquo;; $&amp;rdquo;，因此BAREWORD将是语法错误（在&amp;ldquo; use strict&amp;rdquo;下。如果没有strict，它将被解释为文件名）。</target>
        </trans-unit>
        <trans-unit id="157dc325ab3004964dba8cb99f25c548e59c3ee6" translate="yes" xml:space="preserve">
          <source>Without binmode this happens to work but without binmode, print() fails instead of write().</source>
          <target state="translated">在没有binmode的情况下,这种情况会发生,但如果没有binmode,print()会失败,而不是write()。</target>
        </trans-unit>
        <trans-unit id="9fae572f92ad00688736431e8db34f7e13e97183" translate="yes" xml:space="preserve">
          <source>Without compiling a special Perl, there is no way to get the exact same behavior of any versions prior to Perl 5.18.0. The closest one can get is by setting PERL_PERTURB_KEYS to 0 and setting the PERL_HASH_SEED to a known value. We do not advise those settings for production use due to the above security considerations.</source>
          <target state="translated">如果不编译一个特殊的Perl,就无法得到Perl 5.18.0之前的任何版本的完全相同的行为。最接近的方法是将PERL_PERTURB_KEYS设置为0,并将PERL_HASH_SEED设置为一个已知值。出于上述安全考虑,我们不建议在生产中使用这些设置。</target>
        </trans-unit>
        <trans-unit id="40d89b93ede452cf3a3abe5db73cc3f6990cb465" translate="yes" xml:space="preserve">
          <source>Without sending mail to the address and seeing whether there's a human on the other end to answer you, you cannot fully answer part</source>
          <target state="translated">如果不按地址发信,不看另一端是否有人接听,你就不能完全回答部分</target>
        </trans-unit>
        <trans-unit id="9dc761ae6cda1ca106ca429a9b91481691a414c5" translate="yes" xml:space="preserve">
          <source>Without tests provided by the original author, how can anyone else changing perl in the future be sure that they haven't unwittingly broken the behaviour the patch implements? And without tests, how can the patch's author be confident that his/her hard work put into the patch won't be accidentally thrown away by someone in the future?</source>
          <target state="translated">如果没有原作者提供的测试,那么将来修改 perl 的人怎么能确定他们没有无意中破坏了补丁所实现的行为?而没有测试,补丁的作者又怎么能确信他/她在补丁中的辛勤工作不会被未来的人不小心丢弃呢?</target>
        </trans-unit>
        <trans-unit id="c1443d621edad5afbf828f718460ec1c38b6ccbc" translate="yes" xml:space="preserve">
          <source>Without that empty line before the &quot;=head1&quot;, many translators wouldn't have recognized the &quot;=head1&quot; as starting a Pod block.</source>
          <target state="translated">如果没有&quot;=head1 &quot;前的那行空行,很多译者就不会把&quot;=head1 &quot;识别为Pod块的起始。</target>
        </trans-unit>
        <trans-unit id="d67d28a004691a2df73ec622342b344f42349502" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; declaration, this code will not compile under the &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; pragma.</source>
          <target state="translated">如果没有 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; 声明，这个代码将不会下编译&lt;a href=&quot;strict&quot;&gt;严格&lt;/a&gt;编译。</target>
        </trans-unit>
        <trans-unit id="e556997c8bdf4cc597d6477622db2033d0112438" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;our $AUTOLOAD&lt;/code&gt; declaration, this code will not compile under the &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; pragma.</source>
          <target state="translated">没有 &lt;code&gt;our $AUTOLOAD&lt;/code&gt; 声明，此代码将无法在&lt;a href=&quot;strict&quot;&gt;严格的&lt;/a&gt;编译指示下进行编译。</target>
        </trans-unit>
        <trans-unit id="8106389e31f882e4de34e6fb1c8fa83f4529f426" translate="yes" xml:space="preserve">
          <source>Without the \ before the #, we'd have the start of a Makefile comment, and the macro would be incorrectly defined.</source>
          <target state="translated">如果没有#前的&quot;/&quot;,我们就会有一个Makefile注释的开始,宏的定义就会不正确。</target>
        </trans-unit>
        <trans-unit id="9862e56ba4382f4550c0a053a28a9edc67cb29a8" translate="yes" xml:space="preserve">
          <source>Without the \\ before the #, we'd have the start of a Makefile comment, and the macro would be incorrectly defined.</source>
          <target state="translated">如果没有#前的\\,我们就会有一个Makefile注释的开头,宏的定义就会不正确。</target>
        </trans-unit>
        <trans-unit id="c652adb6df9438fc28974e5263002f95713055c4" translate="yes" xml:space="preserve">
          <source>Without the all-critical &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declaration, putting UTF‑8 in your literals and identifiers won&amp;rsquo;t work right. If you used the standard preamble just given above, this already happened. If you did, you can do things like this:</source>
          <target state="translated">如果没有所有至关重要的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 声明，那么将UTF-8放在文字和标识符中将无法正常工作。如果您使用上面刚刚给出的标准前导，则已经发生了。如果这样做，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="022916bda3b0da7053428b82057c474802fe172c" translate="yes" xml:space="preserve">
          <source>Without the all-critical &lt;code&gt;use utf8&lt;/code&gt; declaration, putting UTF‑8 in your literals and identifiers won&amp;rsquo;t work right. If you used the standard preamble just given above, this already happened. If you did, you can do things like this:</source>
          <target state="translated">如果没有所有至关重要的 &lt;code&gt;use utf8&lt;/code&gt; 声明，那么将UTF-8放在文字和标识符中将无法正常工作。如果您使用了上面给出的标准前导，则已经发生了。如果这样做，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="a805f73e432af03c931e3e4ebc6e43febdbb1b0f" translate="yes" xml:space="preserve">
          <source>Without the braces, Perl would have looked for a $whospeak, a &lt;code&gt;$who::0&lt;/code&gt; , and a &lt;code&gt;$who's&lt;/code&gt; variable. The last two would be the $0 and the $s variables in the (presumably) non-existent package &lt;code&gt;who&lt;/code&gt; .</source>
          <target state="translated">如果没有括号，Perl会寻找一个$ whospeak，一个 &lt;code&gt;$who::0&lt;/code&gt; 和一个 &lt;code&gt;$who's&lt;/code&gt; 变量。最后两个是（可能是）不存在的软件包 &lt;code&gt;who&lt;/code&gt; 中的$ 0和$ s变量。</target>
        </trans-unit>
        <trans-unit id="b59ba0c86d5008d327ba4145261903f48586e59b" translate="yes" xml:space="preserve">
          <source>Without the braces, Perl would have looked for a $whospeak, a &lt;code&gt;$who::0&lt;/code&gt;, and a &lt;code&gt;$who's&lt;/code&gt; variable. The last two would be the $0 and the $s variables in the (presumably) non-existent package &lt;code&gt;who&lt;/code&gt;.</source>
          <target state="translated">如果没有括号，Perl会寻找一个$ whospeak，一个 &lt;code&gt;$who::0&lt;/code&gt; 和一个 &lt;code&gt;$who's&lt;/code&gt; 变量。最后两个是（可能是）不存在的软件包 &lt;code&gt;who&lt;/code&gt; 中的$ 0和$ s变量。</target>
        </trans-unit>
        <trans-unit id="8b7119185642381b4835e616a2adfce6407060de" translate="yes" xml:space="preserve">
          <source>Without the file handle there is no straightforward way to map from the C callback to the Perl subroutine.</source>
          <target state="translated">如果没有文件句柄,就无法直接从C回调映射到Perl子程序。</target>
        </trans-unit>
        <trans-unit id="557fc723a913d1e3b2505b4094298be8eec2001a" translate="yes" xml:space="preserve">
          <source>Without the quotes Perl would convert the large number to a floating point constant at compile time and then hand the result to BigInt, which results in an truncated result or a NaN.</source>
          <target state="translated">如果没有引号,Perl会在编译时将大数转换为浮点常数,然后将结果交给BigInt,结果是一个截断的结果或NaN。</target>
        </trans-unit>
        <trans-unit id="cd8dcbc5d0ba46dab27a245d8542910769851151" translate="yes" xml:space="preserve">
          <source>Without the quotes Perl would convert the large number to a floating point constant at compile time and then hand the result to Math::BigInt, which results in an truncated result or a NaN.</source>
          <target state="translated">如果没有引号,Perl会在编译时将大数转换为浮点常数,然后将结果交给Math::BigInt,结果是一个截断的结果或一个NaN。</target>
        </trans-unit>
        <trans-unit id="44d0e0ada47acb90500aed8583377dc7e9485f05" translate="yes" xml:space="preserve">
          <source>Without this function call, threads that use the &lt;a href=&quot;setlocale(3)&quot;&gt;&lt;code&gt;setlocale(3)&lt;/code&gt;&lt;/a&gt; system function will not work properly, as all the locale-sensitive functions will look at the per-thread locale, and &lt;code&gt;setlocale&lt;/code&gt; will have no effect on this thread.</source>
          <target state="translated">没有此函数调用，使用&lt;a href=&quot;setlocale(3)&quot;&gt; &lt;code&gt;setlocale(3)&lt;/code&gt; &lt;/a&gt;系统函数的线程将无法正常工作，因为所有对语言环境敏感的功能都将查看每个线程的语言环境，而 &lt;code&gt;setlocale&lt;/code&gt; 将对该线程无效。</target>
        </trans-unit>
        <trans-unit id="ebd1a191c5e0195ae68815f767eadf66793aed3f" translate="yes" xml:space="preserve">
          <source>Without this pragma, if strings operating under byte semantics and strings with Unicode character data are concatenated, the new string will be created by decoding the byte strings as</source>
          <target state="translated">如果没有这个参数,如果按字节语义操作的字符串和带有Unicode字符数据的字符串被连接起来,新的字符串将通过解码字节字符串来创建。</target>
        </trans-unit>
        <trans-unit id="4e3240128cc4ac6294817aa01c1437d4416b9150" translate="yes" xml:space="preserve">
          <source>Word characters</source>
          <target state="translated">字符</target>
        </trans-unit>
        <trans-unit id="c1ab804bf377c2d02f25ebababbe5112fca26b12" translate="yes" xml:space="preserve">
          <source>Work Crew</source>
          <target state="translated">工作团队</target>
        </trans-unit>
        <trans-unit id="73f4875bffaeefb6bc4c9e5de5982f1c956b5814" translate="yes" xml:space="preserve">
          <source>Work around DCL's 255 character limit several times,and use VMS-style command line quoting in a few cases.</source>
          <target state="translated">多次绕过DCL的255个字符限制,并在一些情况下使用VMS风格的命令行引号。</target>
        </trans-unit>
        <trans-unit id="beb03a8c30af39505328c268c1180c75604701a0" translate="yes" xml:space="preserve">
          <source>Work for the pumpking, work for Perl programmers, work for module authors, ... Perl is supposed to be easy.</source>
          <target state="translated">为泵金工作,为Perl程序员工作,为模块作者工作,...Perl应该是很简单的。</target>
        </trans-unit>
        <trans-unit id="91f920f3d44c34d2ff6c9dd9603498397730bf04" translate="yes" xml:space="preserve">
          <source>Worked by applying a role that wrapped &lt;code&gt;Test::Builder-&amp;gt;_print_comment&lt;/code&gt;. Fixed by adding an event filter that modifies the message instead when running under Test2.</source>
          <target state="translated">通过应用包装 &lt;code&gt;Test::Builder-&amp;gt;_print_comment&lt;/code&gt; 的角色进行工作。通过添加事件过滤器（在Test2下运行时修改消息）来解决。</target>
        </trans-unit>
        <trans-unit id="b837e4f0aacd9d9f6074d443ecd309cef87e661e" translate="yes" xml:space="preserve">
          <source>Working code is always preferred to pie-in-the-sky ideas. A patch to add a feature stands a much higher chance of making it to the language than does a random feature request, no matter how fervently argued the request might be. This ties into &quot;Will it be useful?&quot;, as the fact that someone took the time to make the patch demonstrates a strong desire for the feature.</source>
          <target state="translated">工作代码总是比天马行空的想法更受欢迎。一个添加功能的补丁比一个随机的功能请求有更大的机会被加入到语言中,不管这个请求有多么激烈的争论。这与 &quot;它是否有用?&quot;有关,因为有人花时间打补丁的事实表明了对该功能的强烈渴望。</target>
        </trans-unit>
        <trans-unit id="791f0cf1a4866efe09fa052199378fd87a29a636" translate="yes" xml:space="preserve">
          <source>Working with AVs</source>
          <target state="translated">与AVs一起工作</target>
        </trans-unit>
        <trans-unit id="fcf77865e202a40f39e6dc4633dec2c1c8b8542a" translate="yes" xml:space="preserve">
          <source>Working with HVs</source>
          <target state="translated">与HVs一起工作</target>
        </trans-unit>
        <trans-unit id="9ba6b91bf263dc667dda1becd81a9fbef7358bbd" translate="yes" xml:space="preserve">
          <source>Working with Net::FTP</source>
          <target state="translated">使用Net::FTP</target>
        </trans-unit>
        <trans-unit id="9522f5ef01714aab2e2d70111bf52346aa9851c3" translate="yes" xml:space="preserve">
          <source>Working with SVs</source>
          <target state="translated">与SVs一起工作</target>
        </trans-unit>
        <trans-unit id="acaa1f9e891f841e4f55280185da1c9a0bc87b80" translate="yes" xml:space="preserve">
          <source>Working with files</source>
          <target state="translated">处理文件</target>
        </trans-unit>
        <trans-unit id="7efe528e837c3e9dd842174c934d74e9c8e8af64" translate="yes" xml:space="preserve">
          <source>Works currently only for integers.</source>
          <target state="translated">目前只适用于整数。</target>
        </trans-unit>
        <trans-unit id="c9cb7c59dae1a78441bca64b16b41d57dc70c3e5" translate="yes" xml:space="preserve">
          <source>Works exactly as &lt;code&gt;like()&lt;/code&gt; , only it checks if $got &lt;b&gt;does not&lt;/b&gt; match the given pattern.</source>
          <target state="translated">与 &lt;code&gt;like()&lt;/code&gt; 完全一样，仅检查$ got &lt;b&gt;是否&lt;/b&gt;与给定模式&lt;b&gt;不&lt;/b&gt;匹配。</target>
        </trans-unit>
        <trans-unit id="6ffef90261775bf1446d64de441c14b751512d3c" translate="yes" xml:space="preserve">
          <source>Works exactly as &lt;code&gt;like()&lt;/code&gt;, only it checks if $got &lt;b&gt;does not&lt;/b&gt; match the given pattern.</source>
          <target state="translated">与 &lt;code&gt;like()&lt;/code&gt; 完全一样，仅检查$ got&lt;b&gt;是否&lt;/b&gt;与给定模式&lt;b&gt;不&lt;/b&gt;匹配。</target>
        </trans-unit>
        <trans-unit id="54f0dce4381260fc309ade54b455e20a83cc12f0" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#index-STR%2CSUBSTR%2CPOSITION&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; except that it returns the position of the</source>
          <target state="translated">就像&lt;a href=&quot;#index-STR%2CSUBSTR%2CPOSITION&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt;一样工作，除了它返回索引的位置。</target>
        </trans-unit>
        <trans-unit id="9232c0576386ef7db9a66e0f3312f80aa2ae0362" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">就像&lt;a href=&quot;#localtime&quot;&gt;localtime&lt;/a&gt;一样工作，但是返回的值被本地化为标准格林威治时区。</target>
        </trans-unit>
        <trans-unit id="9839a604fd52293ec52fedd95d5b5d8df3818c2c" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">就像&lt;a href=&quot;#localtime-EXPR&quot;&gt; &lt;code&gt;localtime&lt;/code&gt; &lt;/a&gt;一样工作，但是返回的值针对标准格林威治时区进行本地化。</target>
        </trans-unit>
        <trans-unit id="69a4f2f77bbe0fae40d114143aa5065b6ddabd02" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;cmp_ok()&lt;/code&gt;.</source>
          <target state="translated">就像&lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt;的 &lt;code&gt;cmp_ok()&lt;/code&gt; 一样工作。</target>
        </trans-unit>
        <trans-unit id="63d895f5ba3197e6e250fa353d94a31dc5531f0f" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">就像&lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt;一样工作，但是返回的值被本地化为标准格林威治时区。</target>
        </trans-unit>
        <trans-unit id="59edd54160d7f94a92175d3ce89e67babbe534fb" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;cmp_ok()&lt;/code&gt; .</source>
          <target state="translated">就像&lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt;的 &lt;code&gt;cmp_ok()&lt;/code&gt; 一样工作。</target>
        </trans-unit>
        <trans-unit id="b054b39e72ec238653744e3a117cbf2b7bacaa18" translate="yes" xml:space="preserve">
          <source>Works just like index() except that it returns the position of the</source>
          <target state="translated">和index()的工作原理一样,只不过它返回的是index()的位置。</target>
        </trans-unit>
        <trans-unit id="ff14a89d24955b4d292116a9dd09815095b69cb7" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_catpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;&lt;a href=&quot;#sv_setpvf_mg&quot;&gt;&quot;sv_setpvf_mg&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">像 &lt;code&gt;sv_catpvf&lt;/code&gt; 一样工作，但是将文本复制到SV中，而不是附加文本。不处理&amp;ldquo;定型&amp;rdquo;魔法。参见 &lt;code&gt;&lt;a href=&quot;#sv_setpvf_mg&quot;&gt;&quot;sv_setpvf_mg&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62b7e0373549dae581f58b37784d19f9d489170e" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_catpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_setpvf_mg&lt;/code&gt; .</source>
          <target state="translated">像 &lt;code&gt;sv_catpvf&lt;/code&gt; 一样工作，但是将文本复制到SV中，而不是附加文本。不处理&amp;ldquo;定型&amp;rdquo;魔法。参见 &lt;code&gt;sv_setpvf_mg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c14d76b99d10ba25b831daac8203cd025304f5fc" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;&lt;a href=&quot;#sv_vsetpvf_mg&quot;&gt;&quot;sv_vsetpvf_mg&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">像 &lt;code&gt;sv_vcatpvf&lt;/code&gt; 一样工作，但是将文本复制到SV中，而不是附加文本。不处理&amp;ldquo;定型&amp;rdquo;魔法。请参见 &lt;code&gt;&lt;a href=&quot;#sv_vsetpvf_mg&quot;&gt;&quot;sv_vsetpvf_mg&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43ccfff897978a36d025fbdd87f7f80f29da36e5" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; .</source>
          <target state="translated">像 &lt;code&gt;sv_vcatpvf&lt;/code&gt; 一样工作，但是将文本复制到SV中，而不是附加文本。不处理&amp;ldquo;定型&amp;rdquo;魔法。参见 &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce9ad1c2559537d328f2e9ae5ccf06d2341106d3" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvfn&lt;/code&gt; but copies the text into the SV instead of appending it.</source>
          <target state="translated">像 &lt;code&gt;sv_vcatpvfn&lt;/code&gt; 一样工作，但是将文本复制到SV中，而不是附加文本。</target>
        </trans-unit>
        <trans-unit id="97569be8c378569cf569a2abd589e6182aac8aca" translate="yes" xml:space="preserve">
          <source>Works remotely similar to &lt;code&gt;filter_json_object&lt;/code&gt;, but is only called for JSON objects having a single key named &lt;code&gt;$key&lt;/code&gt;.</source>
          <target state="translated">远程工作类似于 &lt;code&gt;filter_json_object&lt;/code&gt; ，但仅对具有单个名为 &lt;code&gt;$key&lt;/code&gt; JSON对象调用。</target>
        </trans-unit>
        <trans-unit id="e28088b9057a774cbeb7647c942ba983be39b65a" translate="yes" xml:space="preserve">
          <source>Workshops</source>
          <target state="translated">Workshops</target>
        </trans-unit>
        <trans-unit id="aca31ad78f24eb8f34a6f1515e5ad96783f7a4c5" translate="yes" xml:space="preserve">
          <source>World Wide Web, HTML, HTTP, CGI, MIME</source>
          <target state="translated">万维网、HTML、HTTP、CGI、MIME。</target>
        </trans-unit>
        <trans-unit id="dc354627de17c28e4a463874cb49fb69cf80c2d0" translate="yes" xml:space="preserve">
          <source>Worse still, if you've got a language like Chinese or Japanese that has hundreds or thousands of characters, then you really can't fit them into a mere 256, so they had to forget about ASCII altogether, and build their own systems using pairs of numbers to refer to one character.</source>
          <target state="translated">更糟糕的是,如果你的语言,比如中文或日文,有几百个或几千个字符,那么你真的无法将它们装进仅仅256个字符中,所以他们不得不完全忘掉ASCII,建立自己的系统,用数字对来指代一个字符。</target>
        </trans-unit>
        <trans-unit id="c5bfba3d49e2ee674235e330da88197da31a7c79" translate="yes" xml:space="preserve">
          <source>Would print '1', because &lt;code&gt;$foo&lt;/code&gt; holds a reference to the</source>
          <target state="translated">将打印&amp;ldquo; 1&amp;rdquo;，因为 &lt;code&gt;$foo&lt;/code&gt; 持有对</target>
        </trans-unit>
        <trans-unit id="193007f64c59b1fb13236d0c41a89912a80da741" translate="yes" xml:space="preserve">
          <source>Would produce an event structure that does &lt;b&gt;not&lt;/b&gt; have the</source>
          <target state="translated">会产生一个事件的结构，也&lt;b&gt;不能&lt;/b&gt;有</target>
        </trans-unit>
        <trans-unit id="cb47f1ed4bc872fb3335bdefcb281f4424715abe" translate="yes" xml:space="preserve">
          <source>Would run bin/foobar.PL like this:</source>
          <target state="translated">会像这样运行bin/foobar.PL。</target>
        </trans-unit>
        <trans-unit id="ead2351e2ba0bd4c816a4c94cc5152ad666ddb3d" translate="yes" xml:space="preserve">
          <source>Wrapper around CPAN.pm without using any XS module</source>
          <target state="translated">围绕CPAN.pm的封装器,无需使用任何XS模块。</target>
        </trans-unit>
        <trans-unit id="84ac379977c898d123ab3b5be8e7d1ebcc793262" translate="yes" xml:space="preserve">
          <source>Wrapper around Config.pm</source>
          <target state="translated">围绕配置.pm的封装器</target>
        </trans-unit>
        <trans-unit id="5e2ec9565586c686048d53d457fe37527f6aad30" translate="yes" xml:space="preserve">
          <source>Wrapper class for calling subs at end of scope</source>
          <target state="translated">用于在作用域结束时调用子类的封装类。</target>
        </trans-unit>
        <trans-unit id="49754b3431fd16ae1cf0d382c55b7fa7149dd942" translate="yes" xml:space="preserve">
          <source>Wrapping all die calls in a handler routine can be useful to see how, and from where, they're being called, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; has more information:</source>
          <target state="translated">在处理程序例程中包装所有die调用对于查看&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;如何以及从何处被调用有更多信息，这很有用：</target>
        </trans-unit>
        <trans-unit id="c2c61b8accf065e529ff818a1a9f4549b7fc54ab" translate="yes" xml:space="preserve">
          <source>Wrapping with parenthesis allows the wildcard parts of the Input File Glob to be referenced by the second parameter to &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;#1.tgz&lt;/code&gt; , the</source>
          <target state="translated">包装用括号允许输入文件水珠的通配符部分由第二个参数被引用 &lt;code&gt;globmap&lt;/code&gt; ， &lt;code&gt;#1.tgz&lt;/code&gt; ，所述</target>
        </trans-unit>
        <trans-unit id="17f822b6bdf6bec5271484d235680d74774f32cb" translate="yes" xml:space="preserve">
          <source>Wrapping with parenthesis allows the wildcard parts of the Input File Glob to be referenced by the second parameter to &lt;code&gt;globmap&lt;/code&gt;, &lt;code&gt;#1.tgz&lt;/code&gt;, the</source>
          <target state="translated">包装用括号允许输入文件水珠的通配符部分由第二个参数被引用 &lt;code&gt;globmap&lt;/code&gt; ， &lt;code&gt;#1.tgz&lt;/code&gt; ，所述</target>
        </trans-unit>
        <trans-unit id="53f5b426a0effa25adf0da16850506b6dbd0cdcc" translate="yes" xml:space="preserve">
          <source>Wraps any CODE references found within the arguments by replacing each with the result of calling &lt;a href=&quot;#wrap_code_ref&quot;&gt;&quot;wrap_code_ref&quot;&lt;/a&gt; on the CODE reference. Any ARRAY or HASH references in the arguments are inspected recursively.</source>
          <target state="translated">通过在CODE引用上调用&lt;a href=&quot;#wrap_code_ref&quot;&gt;&amp;ldquo; wrap_code_ref&amp;rdquo;&lt;/a&gt;的结果来替换每个参数，从而包装在参数中找到的所有CODE引用。递归检查参数中的所有ARRAY或HASH引用。</target>
        </trans-unit>
        <trans-unit id="7ee0be976deb11b8b1d2de7c10091a2cf26d9d3d" translate="yes" xml:space="preserve">
          <source>Wraps any CODE references found within the arguments by replacing each with the result of calling &lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt; on the CODE reference. Any ARRAY or HASH references in the arguments are inspected recursively.</source>
          <target state="translated">通过用在CODE引用上调用&lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt;的结果替换每个参数，包装在参数中找到的所有CODE引用。递归检查参数中的所有ARRAY或HASH引用。</target>
        </trans-unit>
        <trans-unit id="c3415b34e4326194b5c5e94f65779568f9ab9142" translate="yes" xml:space="preserve">
          <source>Wraps up an op tree with some additional ops so that at runtime a dynamic scope will be created. The original ops run in the new dynamic scope, and then, provided that they exit normally, the scope will be unwound. The additional ops used to create and unwind the dynamic scope will normally be an &lt;code&gt;enter&lt;/code&gt; /&lt;code&gt;leave&lt;/code&gt; pair, but a &lt;code&gt;scope&lt;/code&gt; op may be used instead if the ops are simple enough to not need the full dynamic scope structure.</source>
          <target state="translated">用一些其他操作包装操作树，以便在运行时创建动态范围。原始操作在新的动态范围内运行，然后，只要它们正常退出，该范围将被取消。用于创建和展开动态范围的其他操作通常将是一个 &lt;code&gt;enter&lt;/code&gt; / &lt;code&gt;leave&lt;/code&gt; 对，但是如果操作足够简单以至于不需要完整的动态范围结构，则可以使用 &lt;code&gt;scope&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="2c03a1841c6b03c290cd48f7ec63334ea2671fbe" translate="yes" xml:space="preserve">
          <source>Wraps up an op tree with some additional ops so that at runtime a dynamic scope will be created. The original ops run in the new dynamic scope, and then, provided that they exit normally, the scope will be unwound. The additional ops used to create and unwind the dynamic scope will normally be an &lt;code&gt;enter&lt;/code&gt;/&lt;code&gt;leave&lt;/code&gt; pair, but a &lt;code&gt;scope&lt;/code&gt; op may be used instead if the ops are simple enough to not need the full dynamic scope structure.</source>
          <target state="translated">用一些其他操作包装操作树，以便在运行时创建动态范围。原始操作在新的动态范围内运行，然后，如果它们正常退出，则该范围将被取消缠绕。通常，用于创建和展开动态范围的其他操作将是一个 &lt;code&gt;enter&lt;/code&gt; / &lt;code&gt;leave&lt;/code&gt; 对，但是如果操作足够简单以至于不需要完整的动态范围结构，则可以使用 &lt;code&gt;scope&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="4a48932789d199bbed709777e2d743ca2bafdc6c" translate="yes" xml:space="preserve">
          <source>Write</source>
          <target state="translated">Write</target>
        </trans-unit>
        <trans-unit id="665e91485da7b1f4da854eb4a64d72b175917c29" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes of data from &lt;code&gt;BUFFER&lt;/code&gt; to the server, also performing any &amp;lt;CRLF&amp;gt; translation necessary. &lt;code&gt;TIMEOUT&lt;/code&gt; is optional, if not given, the timeout value from the command connection will be used.</source>
          <target state="translated">将 &lt;code&gt;BUFFER&lt;/code&gt; 中的 &lt;code&gt;SIZE&lt;/code&gt; 字节数据写入服务器，同时还要执行任何&amp;lt;CRLF&amp;gt;转换。 &lt;code&gt;TIMEOUT&lt;/code&gt; 是可选的，如果未指定，将使用命令连接中的超时值。</target>
        </trans-unit>
        <trans-unit id="9e9970521c52eb1a81f415505a29f59eba7d4c0c" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes to the shared memory segment at &lt;code&gt;POS&lt;/code&gt; . Returns true if successful, or false if there is an error. See &lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;SIZE&lt;/code&gt; 字节写入 &lt;code&gt;POS&lt;/code&gt; 的共享内存段。如果成功，则返回true；如果有错误，则返回false。参见&lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e52c0034fc1cfc407469f1ff131f1cb98c7f427d" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes to the shared memory segment at &lt;code&gt;POS&lt;/code&gt;. Returns true if successful, or false if there is an error. See &lt;a href=&quot;shmwrite&quot;&gt;shmwrite&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;SIZE&lt;/code&gt; 字节写入 &lt;code&gt;POS&lt;/code&gt; 的共享内存段。如果成功，则返回true；如果有错误，则返回false。参见&lt;a href=&quot;shmwrite&quot;&gt;shmwrite&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4d6106f35288022310ffee038cda3aae849b282" translate="yes" xml:space="preserve">
          <source>Write MYMETA information to MYMETA.json and MYMETA.yml.</source>
          <target state="translated">将MYMETA信息写入MYMETA.json和MYMETA.yml中。</target>
        </trans-unit>
        <trans-unit id="a9b6c91570493bdee3be6eef5a6b183ad756cdab" translate="yes" xml:space="preserve">
          <source>Write RFC 1950 files/buffers</source>
          <target state="translated">编写RFC 1950文件/缓冲器</target>
        </trans-unit>
        <trans-unit id="0909abf68380a212e21e5479f6396ce54f63b785" translate="yes" xml:space="preserve">
          <source>Write RFC 1951 files/buffers</source>
          <target state="translated">编写RFC 1951文件/缓冲器</target>
        </trans-unit>
        <trans-unit id="0a1ef998109ed3777e0f667818ad2c1c3ea0b70e" translate="yes" xml:space="preserve">
          <source>Write RFC 1952 files/buffers</source>
          <target state="translated">编写RFC 1952文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="e52a7d8ae8bb89850d8b0bad0931a61da15a6992" translate="yes" xml:space="preserve">
          <source>Write YAMLish data</source>
          <target state="translated">编写YAML语言数据</target>
        </trans-unit>
        <trans-unit id="77878a047db48550e0d5361bfb44d185b930e978" translate="yes" xml:space="preserve">
          <source>Write a formatter as a Pod::Simple subclass</source>
          <target state="translated">写一个formatter作为Pod::Simple子类。</target>
        </trans-unit>
        <trans-unit id="bc54db5c1b3d5ac212fb800fdd56f965140da3e5" translate="yes" xml:space="preserve">
          <source>Write access via git</source>
          <target state="translated">通过git写访问</target>
        </trans-unit>
        <trans-unit id="935636e37a0f4339394c64f63b5cea6433c1f963" translate="yes" xml:space="preserve">
          <source>Write an entry, whose name is equivalent to the file name provided to disk. Optionally takes a second parameter, which is the full native path (including filename) the entry will be written to.</source>
          <target state="translated">写入一个条目,其名称相当于提供给磁盘的文件名。可选择使用第二个参数,即条目将被写入的完整本地路径(包括文件名)。</target>
        </trans-unit>
        <trans-unit id="21bcad44913246d2e6442e5351456a0465facb2b" translate="yes" xml:space="preserve">
          <source>Write an event to the console.</source>
          <target state="translated">向控制台写入一个事件。</target>
        </trans-unit>
        <trans-unit id="92e129f1755e34449f3a6e6df186f50990274c50" translate="yes" xml:space="preserve">
          <source>Write behind.</source>
          <target state="translated">写在后面。</target>
        </trans-unit>
        <trans-unit id="e9db66c000d241fa8edccdd62e10c6678d855f50" translate="yes" xml:space="preserve">
          <source>Write bytes to a file or file-like device. Returns a true value if the operation was successful. For failure, returns a false value and sets &lt;code&gt;fileLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt; for the reason for the failure.</source>
          <target state="translated">将字节写入文件或类似文件的设备。如果操作成功，则返回一个真值。对于失败，返回错误值，并为失败原因设置 &lt;code&gt;fileLastError()&lt;/code&gt; 和 &lt;code&gt;$^E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5769fe16b9b0cad42af9406c72e837bd0c18c816" translate="yes" xml:space="preserve">
          <source>Write bzip2 files/buffers</source>
          <target state="translated">写入bzip2文件/缓冲区</target>
        </trans-unit>
        <trans-unit id="33c705dea45d707aeb4260372b955bd490cdccc3" translate="yes" xml:space="preserve">
          <source>Write check compare operation.</source>
          <target state="translated">写检查比较操作。</target>
        </trans-unit>
        <trans-unit id="bafb7482744edca206da4c0baa12b4a11269c914" translate="yes" xml:space="preserve">
          <source>Write documentation in POD</source>
          <target state="translated">用POD编写文档</target>
        </trans-unit>
        <trans-unit id="01995de03181a3f8adb7e727e73e6dc5e4e106c7" translate="yes" xml:space="preserve">
          <source>Write files whose names are equivalent to any of the names in &lt;code&gt;@filenames&lt;/code&gt; to disk, creating subdirectories as necessary. This might not work too well under VMS. Under MacPerl, the file's modification time will be converted to the MacOS zero of time, and appropriate conversions will be done to the path. However, the length of each element of the path is not inspected to see whether it's longer than MacOS currently allows (32 characters).</source>
          <target state="translated">将名称等同于 &lt;code&gt;@filenames&lt;/code&gt; 中任何名称的文件写入磁盘，并根据需要创建子目录。在VMS下这可能无法很好地工作。在MacPerl下，文件的修改时间将转换为MacOS的零时间，并将对路径进行适当的转换。但是，不检查路径的每个元素的长度以查看其是否比MacOS当前允许的长度（32个字符）长。</target>
        </trans-unit>
        <trans-unit id="cbcd4ec744f6a0cc7a8100b555d7a1173e6952f5" translate="yes" xml:space="preserve">
          <source>Write linker options files for dynamic extension</source>
          <target state="translated">为动态扩展写链接器选项文件</target>
        </trans-unit>
        <trans-unit id="a3530b843bc763ce23299f2f7a8c7169f29e11c4" translate="yes" xml:space="preserve">
          <source>Write simple routines to do simple things.</source>
          <target state="translated">编写简单的例程,做简单的事情。</target>
        </trans-unit>
        <trans-unit id="19494af103ef52570f65fb0c4441c4f5f25a19b7" translate="yes" xml:space="preserve">
          <source>Write some bytes to the scalar.</source>
          <target state="translated">向标量写入一些字节。</target>
        </trans-unit>
        <trans-unit id="391b1a9608423cb9c4d16a7886b9e07fab1acb00" translate="yes" xml:space="preserve">
          <source>Write tests</source>
          <target state="translated">编写测试</target>
        </trans-unit>
        <trans-unit id="af9a89203723d4a9c54482e7a2f891829a872e2c" translate="yes" xml:space="preserve">
          <source>Write the</source>
          <target state="translated">撰写</target>
        </trans-unit>
        <trans-unit id="f112fa7fb0b15b487e01a318607d918ca868eea9" translate="yes" xml:space="preserve">
          <source>Write the C code for miniperlmain.c and perlmain.c</source>
          <target state="translated">编写miniperlmain.c和perlmain.c的C代码。</target>
        </trans-unit>
        <trans-unit id="dc5fd755a4779cecce293a2a1e919899f32cdf21" translate="yes" xml:space="preserve">
          <source>Write the C code for perlmain.c</source>
          <target state="translated">编写 perlmain.c 的 C 代码。</target>
        </trans-unit>
        <trans-unit id="0a8eff4063a82696c6af1e9ea9cf555d97a3ea2c" translate="yes" xml:space="preserve">
          <source>Write the in-memory archive to disk. The first argument can either be the name of a file or a reference to an already open filehandle (a GLOB reference).</source>
          <target state="translated">将内存中的档案写入磁盘。第一个参数可以是文件名,也可以是一个已经打开的文件柄的引用(GLOB引用)。</target>
        </trans-unit>
        <trans-unit id="af8f82dc202f24f05f3598bed445a87ed08771b7" translate="yes" xml:space="preserve">
          <source>Write the state to a file.</source>
          <target state="translated">将状态写入文件。</target>
        </trans-unit>
        <trans-unit id="03e89de5415aa73b6bf8d4ce2e95f915540a35da" translate="yes" xml:space="preserve">
          <source>Write the typemap to a file. Optionally takes a &lt;code&gt;file&lt;/code&gt; argument. If given, the typemap will be written to the specified file. If not, the typemap is written to the currently stored file name (see &lt;a href=&quot;#file&quot;&gt;&quot;file&quot;&lt;/a&gt; above, this defaults to the file it was read from if any).</source>
          <target state="translated">将类型映射写入文件。（可选）采用 &lt;code&gt;file&lt;/code&gt; 参数。如果给定，则将类型映射写入指定的文件。如果不是，则将类型映射写入当前存储的文件名（请参见上面的&lt;a href=&quot;#file&quot;&gt;&amp;ldquo;文件&amp;rdquo;&lt;/a&gt;，如果有的话，默认为读取的文件）。</target>
        </trans-unit>
        <trans-unit id="5ea3036e84ed65b742580afd08f2cf97f36ee5c9" translate="yes" xml:space="preserve">
          <source>Write to a file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">写入文件。它使用文件描述符，例如通过调用 &lt;code&gt;POSIX::open&lt;/code&gt; 获得的文件描述符。</target>
        </trans-unit>
        <trans-unit id="1ddba3f84caaf1f7da5ab41258196ba4aa666d93" translate="yes" xml:space="preserve">
          <source>Write to a file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt;.</source>
          <target state="translated">写入文件。它使用文件描述符，例如通过调用 &lt;code&gt;POSIX::open&lt;/code&gt; 获得的文件描述符。</target>
        </trans-unit>
        <trans-unit id="fff8491fc63b40787a6bc354a1c28b21cd65c0f1" translate="yes" xml:space="preserve">
          <source>Write to modules@perl.org explaining what you did to contact the current maintainer. The PAUSE admins will also try to reach the maintainer.</source>
          <target state="translated">写到modules@perl.org,说明你做了什么来联系当前的维护者。PAUSE管理员也会尝试联系维护者。</target>
        </trans-unit>
        <trans-unit id="ec3b4c2700310731999e0d7e25df0c587f5a195d" translate="yes" xml:space="preserve">
          <source>Write zip files/buffers</source>
          <target state="translated">写压缩文件/缓冲区</target>
        </trans-unit>
        <trans-unit id="08d9173120127debf58115903083c7548d3871d3" translate="yes" xml:space="preserve">
          <source>Write-only access to the data in the file.</source>
          <target state="translated">对文件中的数据进行只写访问。</target>
        </trans-unit>
        <trans-unit id="14518d4671890ab2fd2dc1aa9e641777a8f1afbc" translate="yes" xml:space="preserve">
          <source>WriteConstants ATTRIBUTE =&amp;gt; VALUE [, ...]</source>
          <target state="translated">WriteConstants属性=&amp;gt; VALUE [，...]</target>
        </trans-unit>
        <trans-unit id="94dee2fafe1d10d5ce6db659eb0c0fcb3d5842be" translate="yes" xml:space="preserve">
          <source>WriteFile</source>
          <target state="translated">WriteFile</target>
        </trans-unit>
        <trans-unit id="8a1db595bd4c07aab5da69c69b2b0b595010f3b7" translate="yes" xml:space="preserve">
          <source>WriteMakefile() now does some basic sanity checks on its parameters to protect against typos and malformatted values. This means some things which happened to work in the past will now throw warnings and possibly produce internal errors.</source>
          <target state="translated">WriteMakefile()现在会对其参数进行一些基本的理智检查,以防止错别字和格式化错误的值。这意味着一些过去可以正常工作的东西现在会发出警告,并可能产生内部错误。</target>
        </trans-unit>
        <trans-unit id="97fe0c70bb91d9c9a985fa7a8dd506d2e586dde0" translate="yes" xml:space="preserve">
          <source>WriteMakefileSnippet</source>
          <target state="translated">WriteMakefileSnippet</target>
        </trans-unit>
        <trans-unit id="6e814e2d111b3599c2bf1ca192478a3ffbfc4053" translate="yes" xml:space="preserve">
          <source>WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [, ...]</source>
          <target state="translated">WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [，...]</target>
        </trans-unit>
        <trans-unit id="7bdbf771b888449a861406dd116d15dd91371055" translate="yes" xml:space="preserve">
          <source>Writes SIZE bytes from STRING to a memory segment at ADDR starting at position POS. If STRING is too long, only SIZE bytes are used; if STRING is too short, nulls are written to fill out SIZE bytes. Returns true if successful, or false if there is an error.</source>
          <target state="translated">将STRING中的SIZE字节写入从位置POS开始的ADDR的内存段。如果STRING太长,只使用SIZE字节;如果STRING太短,则写入空值来填充SIZE字节。如果成功则返回true,如果出现错误则返回false。</target>
        </trans-unit>
        <trans-unit id="5d0ca93d68b5dc214818ef186a1bc3e2b3d7c8cd" translate="yes" xml:space="preserve">
          <source>Writes a file of C code and a file of XS code which you should &lt;code&gt;#include&lt;/code&gt; and &lt;code&gt;INCLUDE&lt;/code&gt; in the C and XS sections respectively of your module's XS code. You probably want to do this in your &lt;code&gt;Makefile.PL&lt;/code&gt; , so that you can easily edit the list of constants without touching the rest of your module. The attributes supported are</source>
          <target state="translated">写入C代码文件和XS代码文件，分别在模块的XS代码的C和XS部分中分别 &lt;code&gt;INCLUDE&lt;/code&gt; &lt;code&gt;#include&lt;/code&gt; 和INCLUDE。您可能希望在 &lt;code&gt;Makefile.PL&lt;/code&gt; 中执行此操作，以便可以轻松编辑常量列表，而无需触摸模块的其余部分。支持的属性是</target>
        </trans-unit>
        <trans-unit id="e0245702e3fa0201a8eb501ac9938357e48b7d01" translate="yes" xml:space="preserve">
          <source>Writes a file of C code and a file of XS code which you should &lt;code&gt;#include&lt;/code&gt; and &lt;code&gt;INCLUDE&lt;/code&gt; in the C and XS sections respectively of your module's XS code. You probably want to do this in your &lt;code&gt;Makefile.PL&lt;/code&gt;, so that you can easily edit the list of constants without touching the rest of your module. The attributes supported are</source>
          <target state="translated">分别在模块的XS代码的C和XS部分中分别写入 &lt;code&gt;#include&lt;/code&gt; 和 &lt;code&gt;INCLUDE&lt;/code&gt; 的C代码文件和XS代码文件。您可能希望在 &lt;code&gt;Makefile.PL&lt;/code&gt; 中执行此操作，以便可以轻松编辑常量列表，而无需接触模块的其余部分。支持的属性是</target>
        </trans-unit>
        <trans-unit id="e8e7628595fe05e976f01b228c1371b889b4fb1c" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;a href=&quot;#select-FILEHANDLE&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; function) may be set explicitly by assigning the name of the format to the &lt;a href=&quot;perlvar#%24~&quot;&gt;&lt;code&gt;$~&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">使用与该文件关联的格式，将格式化的记录（可能是多行）写入指定的FILEHANDLE。默认情况下，文件格式是与文件句柄名称相同的格式，但是可以通过将格式名称分配给&lt;a href=&quot;perlvar#%24~&quot;&gt; &lt;code&gt;$~&lt;/code&gt; &lt;/a&gt;变量来显式设置当前输出通道的格式（请参见&lt;a href=&quot;#select-FILEHANDLE&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;函数）。</target>
        </trans-unit>
        <trans-unit id="68caf753088df284b27998c0bc22c79c995c9f8a" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">使用与该文件关联的格式，将格式化的记录（可能是多行）写入指定的FILEHANDLE。默认情况下，文件格式是与文件句柄名称相同的格式，但是可以通过将格式名称分配给 &lt;code&gt;$~&lt;/code&gt; 变量来显式设置当前输出通道的格式（请参见 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 函数）。</target>
        </trans-unit>
        <trans-unit id="3c8b534fc59790f52bbc323708c6a448e4336f1e" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">使用与该文件关联的格式，将格式化的记录（可能是多行）写入指定的FILEHANDLE。默认情况下，文件格式是与文件句柄名称相同的格式，但是可以通过将格式名称分配给 &lt;code&gt;$~&lt;/code&gt; 变量来显式设置当前输出通道的格式（请参见 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 函数）。</target>
        </trans-unit>
        <trans-unit id="4e8961057173b914aa902d24e81d3c55d00dde52" translate="yes" xml:space="preserve">
          <source>Writes all files in and below the current directory to your</source>
          <target state="translated">将当前目录下的所有文件写到你的</target>
        </trans-unit>
        <trans-unit id="1ff3060cc065fe5dcf829a42d2a8d401fd64f6d8" translate="yes" xml:space="preserve">
          <source>Writes an empty FORCE: target.</source>
          <target state="translated">写一个空的FORCE:目标。</target>
        </trans-unit>
        <trans-unit id="f5369d43b2f75bf65f1c9b2bf55177161b67ef85" translate="yes" xml:space="preserve">
          <source>Writes are permitted, i.e. opened as &quot;w&quot; or &quot;r+&quot; or &quot;a&quot;, etc.</source>
          <target state="translated">允许写,即以 &quot;w &quot;或 &quot;r+&quot;或 &quot;a &quot;等方式打开。</target>
        </trans-unit>
        <trans-unit id="bc03658e3c61d9705d37afb50e35b60738df57d4" translate="yes" xml:space="preserve">
          <source>Writes the contents of &lt;code&gt;$buffer&lt;/code&gt; to the compressed file. Returns the number of bytes actually written, or 0 on error.</source>
          <target state="translated">将 &lt;code&gt;$buffer&lt;/code&gt; 的内容写入压缩文件。返回实际写入的字节数，如果出错则返回0。</target>
        </trans-unit>
        <trans-unit id="3b30b2d9d9b94819a1a73fa66ad9fdb3aaf93cb5" translate="yes" xml:space="preserve">
          <source>Writes the file META.yml (YAML encoded meta-data) and META.json (JSON encoded meta-data) about the module in the distdir. The format follows Module::Build's as closely as possible.</source>
          <target state="translated">将模块的META.yml(YAML编码的元数据)和META.json(JSON编码的元数据)文件写入distdir中。其格式尽可能的遵循Module::Build的格式。</target>
        </trans-unit>
        <trans-unit id="759cd7af683913d2e067b4f6ffe525a9a1d4a391" translate="yes" xml:space="preserve">
          <source>Writes the file SIGNATURE with &quot;cpansign -s&quot;.</source>
          <target state="translated">用 &quot;cpansign -s &quot;写入文件SIGNATURE。</target>
        </trans-unit>
        <trans-unit id="284cf58439290385abdec38ca7c004471227b097" translate="yes" xml:space="preserve">
          <source>Writes the output of</source>
          <target state="translated">写入</target>
        </trans-unit>
        <trans-unit id="7576a6f2b013b505dded5e0784047fb79ad928e8" translate="yes" xml:space="preserve">
          <source>Writes to the &lt;code&gt;.c&lt;/code&gt; output file certain preprocessor directives and function headers needed in all such files.</source>
          <target state="translated">将所有此类文件中所需的某些预处理器指令和函数标头写入 &lt;code&gt;.c&lt;/code&gt; 输出文件。</target>
        </trans-unit>
        <trans-unit id="fdd8d478482d63bc406cd41436757960d17780fb" translate="yes" xml:space="preserve">
          <source>Writing Accessors</source>
          <target state="translated">书写配件</target>
        </trans-unit>
        <trans-unit id="1986c44b3bdced950b196d1c43f6cf37a6963d63" translate="yes" xml:space="preserve">
          <source>Writing Constructors</source>
          <target state="translated">编写结构体</target>
        </trans-unit>
        <trans-unit id="2e43f89f29a3e136e02e547cac033fa128355bb0" translate="yes" xml:space="preserve">
          <source>Writing Perl on an EBCDIC platform is really no different than writing on an &lt;a href=&quot;#ASCII&quot;&gt;&quot;ASCII&quot;&lt;/a&gt; one, but with different underlying numbers, as we'll see shortly. You'll have to know something about those &lt;a href=&quot;#ASCII&quot;&gt;&quot;ASCII&quot;&lt;/a&gt; platforms because the documentation is biased and will frequently use example numbers that don't apply to EBCDIC. There are also very few CPAN modules that are written for EBCDIC and which don't work on ASCII; instead the vast majority of CPAN modules are written for ASCII, and some may happen to work on EBCDIC, while a few have been designed to portably work on both.</source>
          <target state="translated">实际上，在EBCDIC平台上编写Perl与在&lt;a href=&quot;#ASCII&quot;&gt;&amp;ldquo; ASCII&amp;rdquo;&lt;/a&gt;平台上编写并没有什么不同，但是具有不同的基础数字，我们将很快看到。您将必须对那些&lt;a href=&quot;#ASCII&quot;&gt;&amp;ldquo; ASCII&amp;rdquo;&lt;/a&gt;平台有所了解，因为该文档是有偏见的，并且会经常使用不适用于EBCDIC的示例编号。也很少有为EBCDIC编写的CPAN模块，这些模块不能在ASCII上工作。相反，绝大多数CPAN模块都是用ASCII编写的，有些可能恰好在EBCDIC上工作，而有些则被设计为可在这两种模块上移植。</target>
        </trans-unit>
        <trans-unit id="ac0e44a3a37a4109877068f7584a4c6e490675d8" translate="yes" xml:space="preserve">
          <source>Writing Perl on an EBCDIC platform is really no different than writing on an &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; one, but with different underlying numbers, as we'll see shortly. You'll have to know something about those &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; platforms because the documentation is biased and will frequently use example numbers that don't apply to EBCDIC. There are also very few CPAN modules that are written for EBCDIC and which don't work on ASCII; instead the vast majority of CPAN modules are written for ASCII, and some may happen to work on EBCDIC, while a few have been designed to portably work on both.</source>
          <target state="translated">实际上，在EBCDIC平台上写Perl与在&lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt;上写Perl并没有什么不同，但是具有不同的基础数字，我们将很快看到。您将必须了解有关这些&lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt;平台的一些信息，因为该文档有偏见，并且会经常使用不适用于EBCDIC的示例编号。也很少有为EBCDIC编写的CPAN模块，它们不能在ASCII上工作；取而代之的是，绝大多数CPAN模块都是为ASCII编写的，有些可能恰好在EBCDIC上工作，而有些则被设计为可在这两种模块上移植。</target>
        </trans-unit>
        <trans-unit id="b3e7a0572dc689213dcccc6f0ad9b2cbd894a46a" translate="yes" xml:space="preserve">
          <source>Writing Plugins</source>
          <target state="translated">编写插件</target>
        </trans-unit>
        <trans-unit id="b23e7b02c4f050eb7a5f668109f71a414a28c33d" translate="yes" xml:space="preserve">
          <source>Writing Your Own Debugger</source>
          <target state="translated">编写自己的调试器</target>
        </trans-unit>
        <trans-unit id="12d7ef5d9c4d923fdecfc0a2ba03562ba21e7e82" translate="yes" xml:space="preserve">
          <source>Writing a Filter</source>
          <target state="translated">编写过滤器</target>
        </trans-unit>
        <trans-unit id="7f135a17864ace6ae98bf7a3b9d9b4e20dd72358" translate="yes" xml:space="preserve">
          <source>Writing a module with MakeMaker</source>
          <target state="translated">用MakeMaker编写一个模块</target>
        </trans-unit>
        <trans-unit id="f103eaa4bfb0cd111ad63870dfe99daf1dbfeefb" translate="yes" xml:space="preserve">
          <source>Writing a source filter as a separate executable works fine, but a small performance penalty is incurred. For example, if you execute the small example above, a separate subprocess will be created to run the Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; command. Each use of the filter requires its own subprocess. If creating subprocesses is expensive on your system, you might want to consider one of the other options for creating source filters.</source>
          <target state="translated">将源过滤器编写为单独的可执行文件可以很好地工作，但是会导致性能下降。例如，如果您执行上面的小示例，将创建一个单独的子进程来运行Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 命令。过滤器的每次使用都需要其自己的子过程。如果在您的系统上创建子流程非常昂贵，则可能要考虑使用其他选项之一来创建源过滤器。</target>
        </trans-unit>
        <trans-unit id="42340678aabb28dd8e04eb2e84c897c77707c165" translate="yes" xml:space="preserve">
          <source>Writing a source filter as a separate executable works fine, but a small performance penalty is incurred. For example, if you execute the small example above, a separate subprocess will be created to run the Unix &lt;code&gt;tr&lt;/code&gt; command. Each use of the filter requires its own subprocess. If creating subprocesses is expensive on your system, you might want to consider one of the other options for creating source filters.</source>
          <target state="translated">将源代码筛选器编写为单独的可执行文件可以很好地工作，但是会产生很小的性能损失。例如，如果执行上面的小示例，将创建一个单独的子进程来运行Unix &lt;code&gt;tr&lt;/code&gt; 命令。过滤器的每次使用都需要其自己的子过程。如果在您的系统上创建子流程很昂贵，则可能要考虑使用其他选项之一来创建源过滤器。</target>
        </trans-unit>
        <trans-unit id="e224913e88be93885651c47ecb1638090afee7fe" translate="yes" xml:space="preserve">
          <source>Writing all these print statements rapidly gets tedious. Fortunately, there's &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt;. It has one function, &lt;code&gt;ok()&lt;/code&gt;.</source>
          <target state="translated">快速编写所有这些打印语句变得乏味。幸运的是，这里有&lt;a href=&quot;Test::Simple&quot;&gt;Test :: Simple&lt;/a&gt;。它具有一个函数 &lt;code&gt;ok()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc88b791ccf860fd9df472625687a215e4594f7f" translate="yes" xml:space="preserve">
          <source>Writing backticks in your program sends a clear message to the readers of your code that you wanted to collect the output of the command. Why send a clear message that isn't true?</source>
          <target state="translated">在你的程序中写上反标,会向你的代码读者发出一个明确的信息,即你想收集命令的输出。为什么要发送一个不真实的明确信息呢?</target>
        </trans-unit>
        <trans-unit id="a44149bd1f420e38e67feec9febfbe47dcef5694" translate="yes" xml:space="preserve">
          <source>Writing good test scripts</source>
          <target state="translated">编写好的测试脚本</target>
        </trans-unit>
        <trans-unit id="0d1216f3de5359a11d177bd450454690960a8410" translate="yes" xml:space="preserve">
          <source>Writing subroutines</source>
          <target state="translated">编写子程序</target>
        </trans-unit>
        <trans-unit id="a553ca3bc37b04388da0cff3bc379f04cee8df42" translate="yes" xml:space="preserve">
          <source>Writing subroutines is easy:</source>
          <target state="translated">编写子程序很容易。</target>
        </trans-unit>
        <trans-unit id="c828d0e28e2f569743446e2de56ca66e456c09b7" translate="yes" xml:space="preserve">
          <source>Writing the patch</source>
          <target state="translated">编写补丁</target>
        </trans-unit>
        <trans-unit id="5c10b682e330dccc302170e80493f9eb65449a91" translate="yes" xml:space="preserve">
          <source>Writing the short option first is recommended because it's easier to read. The long option is long enough to draw the eye to it anyway and the short option can otherwise get lost in visual noise.</source>
          <target state="translated">建议先写短选项,因为它更容易阅读。反正长选项足够长,可以吸引眼球,否则短选项可能会在视觉噪音中消失。</target>
        </trans-unit>
        <trans-unit id="1b1d022be94ce5d1101d118c8c80cf3364019b48" translate="yes" xml:space="preserve">
          <source>Writing typemap Entries</source>
          <target state="translated">编写类型图条目</target>
        </trans-unit>
        <trans-unit id="1292edaa487b14cb74f82d4343628858075e0756" translate="yes" xml:space="preserve">
          <source>Wrong: the Storable engine creates an empty one for you. If you know Eiffel, you can view &lt;code&gt;STORABLE_thaw&lt;/code&gt; as an alternate creation routine.</source>
          <target state="translated">错误：可存储引擎为您创建了一个空引擎。如果您知道Eiffel，则可以将 &lt;code&gt;STORABLE_thaw&lt;/code&gt; 作为备用创建例程。</target>
        </trans-unit>
        <trans-unit id="efb99bcd657604ed5888480f20557abaea6afd06" translate="yes" xml:space="preserve">
          <source>Wx</source>
          <target state="translated">Wx</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="af3f0530ce3709877b0c716af9417386f334acd7" translate="yes" xml:space="preserve">
          <source>X [vars]</source>
          <target state="translated">X [vars]</target>
        </trans-unit>
        <trans-unit id="75a98d9bf0f92217c5e8d8919ec41748402162fa" translate="yes" xml:space="preserve">
          <source>XCPT_CATCH</source>
          <target state="translated">XCPT_CATCH</target>
        </trans-unit>
        <trans-unit id="0bbce50dfafd43d2aea26e0a316ecb5bb2789444" translate="yes" xml:space="preserve">
          <source>XCPT_RETHROW</source>
          <target state="translated">XCPT_RETHROW</target>
        </trans-unit>
        <trans-unit id="1c8ec453fa062fcc4d8beb21dfeb7f00e0044e3e" translate="yes" xml:space="preserve">
          <source>XCPT_TRY_END</source>
          <target state="translated">XCPT_TRY_END</target>
        </trans-unit>
        <trans-unit id="62c03b6a034496de09dbf74c72c47fb4b194a801" translate="yes" xml:space="preserve">
          <source>XCPT_TRY_START</source>
          <target state="translated">XCPT_TRY_START</target>
        </trans-unit>
        <trans-unit id="42573a00146341106bb0f06ab931a0b8e20775e3" translate="yes" xml:space="preserve">
          <source>XEmacs</source>
          <target state="translated">XEmacs</target>
        </trans-unit>
        <trans-unit id="c0aa9ef764d832b80428d756a731a94251b0e3a1" translate="yes" xml:space="preserve">
          <source>XML</source>
          <target state="translated">XML</target>
        </trans-unit>
        <trans-unit id="494019465f27565c960f3085abca99be390bd01b" translate="yes" xml:space="preserve">
          <source>XML charref mode (</source>
          <target state="translated">XML charref模式(</target>
        </trans-unit>
        <trans-unit id="7a5fc108bfdd5d96d6f99a6eac89c9af874db7d8" translate="yes" xml:space="preserve">
          <source>XPG operability often implies the presence of an</source>
          <target state="translated">XPG的可操作性往往意味着存在着一个 &quot;XPG&quot;。</target>
        </trans-unit>
        <trans-unit id="0f082b9799dcb8475e7d6fcb04a5adfa774635d5" translate="yes" xml:space="preserve">
          <source>XPUSH args AND set RETVAL AND assign return value to array</source>
          <target state="translated">XPUSH args AND set RETVAL AND assign return value to array(将返回值分配给数组)。</target>
        </trans-unit>
        <trans-unit id="6e96c8ba90434c3991abef6b482029bbb705d617" translate="yes" xml:space="preserve">
          <source>XPUSHi</source>
          <target state="translated">XPUSHi</target>
        </trans-unit>
        <trans-unit id="a45f993c8bc95467cd94eca181fdf46437f5427b" translate="yes" xml:space="preserve">
          <source>XPUSHmortal</source>
          <target state="translated">XPUSHmortal</target>
        </trans-unit>
        <trans-unit id="b231a036815021c5444d064b7fcc1c528ade03e8" translate="yes" xml:space="preserve">
          <source>XPUSHn</source>
          <target state="translated">XPUSHn</target>
        </trans-unit>
        <trans-unit id="f47cdabf2ef1edeef2bd1fb53b6f18747c332149" translate="yes" xml:space="preserve">
          <source>XPUSHp</source>
          <target state="translated">XPUSHp</target>
        </trans-unit>
        <trans-unit id="1dab76d5986d1df120c308434288452972f88fb7" translate="yes" xml:space="preserve">
          <source>XPUSHs</source>
          <target state="translated">XPUSHs</target>
        </trans-unit>
        <trans-unit id="f596fc77ff9e6f6918218a1843202b6b44412bbc" translate="yes" xml:space="preserve">
          <source>XPUSHu</source>
          <target state="translated">XPUSHu</target>
        </trans-unit>
        <trans-unit id="bdb1d0d2760db0ae33b02dff5258e945e708b990" translate="yes" xml:space="preserve">
          <source>XS</source>
          <target state="translated">XS</target>
        </trans-unit>
        <trans-unit id="92bd1887109d3a53eb97d00630c2016c2f9abe52" translate="yes" xml:space="preserve">
          <source>XS VERSION</source>
          <target state="translated">XS版本</target>
        </trans-unit>
        <trans-unit id="f150c9e4da4e74cdaf804a24288dd2d36c2aab56" translate="yes" xml:space="preserve">
          <source>XS code added by Greg Bacon &amp;lt;</source>
          <target state="translated">Greg Bacon添加的XS代码&amp;lt;</target>
        </trans-unit>
        <trans-unit id="1cf142c571c2183260c4664ac183845da5980944" translate="yes" xml:space="preserve">
          <source>XS code can usually be made to work with any platform, but dependent libraries, header files, etc., might not be readily available or portable, or the XS code itself might be platform-specific, just as Perl code might be. If the libraries and headers are portable, then it is normally reasonable to make sure the XS code is portable, too.</source>
          <target state="translated">XS代码通常可以在任何平台上工作,但依赖的库、头文件等可能不是现成的或可移植的,或者XS代码本身可能是平台特定的,就像Perl代码一样。如果库和头文件是可移植的,那么确保XS代码也是可移植的通常是合理的。</target>
        </trans-unit>
        <trans-unit id="292d659c22a7eedddefa474cf1aa726bcee0908b" translate="yes" xml:space="preserve">
          <source>XS code for using native C functions borrowed from &lt;code&gt;&lt;a href=&quot;Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt;, written by Marcus Harnisch &amp;lt;</source>
          <target state="translated">Marcus Harnisch编写的用于从 &lt;code&gt;&lt;a href=&quot;Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt; 借用的本机C函数的XS代码，由&amp;lt;</target>
        </trans-unit>
        <trans-unit id="7e8ccd1927a425f4cd71fc5858f4ce61be503a94" translate="yes" xml:space="preserve">
          <source>XS code for using native C functions borrowed from &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt;, written by Marcus Harnisch &amp;lt;</source>
          <target state="translated">Marcus Harnisch编写的用于从 &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt; 借用的使用本机C函数的XS代码，&amp;lt;</target>
        </trans-unit>
        <trans-unit id="fe30568ef2d4c300e100572dbcce63bef5e87790" translate="yes" xml:space="preserve">
          <source>XS code has full access to system calls including C library functions. It thus has the capability of interfering with things that the Perl core or other modules have set up, such as signal handlers or file handles. It could mess with the memory, or any number of harmful things. Don't.</source>
          <target state="translated">XS代码可以完全访问系统调用,包括C库函数。因此,它有能力干扰Perl核心或其他模块所设置的东西,如信号处理程序或文件句柄。它可能会扰乱内存,或者任何有害的东西。不要。</target>
        </trans-unit>
        <trans-unit id="33d48b61f9e9a038a7aea1ef00483763c58f6eff" translate="yes" xml:space="preserve">
          <source>XS code is probably better using &quot;typemap&quot; if it expects FILE * arguments. The standard typemap will be adjusted to comprehend any changes in this area.</source>
          <target state="translated">XS代码如果期望FILE *参数,可能最好使用 &quot;tyemap&quot;。标准的typemap将被调整以理解这方面的任何变化。</target>
        </trans-unit>
        <trans-unit id="89e8c193e223b649f3d44b4194d19ce56bb23e01" translate="yes" xml:space="preserve">
          <source>XS code is very sensitive to the module version number and will complain if the version number in your Perl module doesn't match. If you change your module's version # without rerunning Makefile.PL the old version number will remain in the Makefile, causing the XS code to be built with the wrong number.</source>
          <target state="translated">XS代码对模块的版本号非常敏感,如果你的Perl模块的版本号不匹配,XS代码就会抱怨。如果你改变了你的模块版本号而没有重新运行Makefile.PL,旧的版本号将保留在Makefile中,导致XS代码被编译成错误的版本号。</target>
        </trans-unit>
        <trans-unit id="9966dea2f0bef9d06ac3bd55d265441a4061b99f" translate="yes" xml:space="preserve">
          <source>XS code or C-language libraries called from it that use the system &lt;a href=&quot;setlocale(3)&quot;&gt;&lt;code&gt;setlocale(3)&lt;/code&gt;&lt;/a&gt; function (except on Windows) likely will not work from a multi-threaded application without changes. See &lt;a href=&quot;perlxs#Locale-aware-XS-code&quot;&gt;&quot;Locale-aware XS code&quot; in perlxs&lt;/a&gt;.</source>
          <target state="translated">使用系统&lt;a href=&quot;setlocale(3)&quot;&gt; &lt;code&gt;setlocale(3)&lt;/code&gt; &lt;/a&gt;函数（Windows除外）从中调用的XS代码或C语言库可能无法在多线程应用程序中进行更改而无法工作。请参见&lt;a href=&quot;perlxs#Locale-aware-XS-code&quot;&gt;perlxs中的&amp;ldquo;可识别区域设置的XS代码&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="def563b19b3d7a04b960dc4d401ac89d52a4e717" translate="yes" xml:space="preserve">
          <source>XS is an interface description file format used to create an extension interface between Perl and C code (or a C library) which one wishes to use with Perl. The XS interface is combined with the library to create a new library which can then be either dynamically loaded or statically linked into perl. The XS interface description is written in the XS language and is the core component of the Perl extension interface.</source>
          <target state="translated">XS是一种接口描述文件格式,用于在Perl和C代码(或C库)之间创建一个扩展接口,以便与Perl一起使用。XS接口与库相结合,创建一个新的库,然后可以动态加载或静态链接到perl中。XS接口描述是用XS语言编写的,是Perl扩展接口的核心组件。</target>
        </trans-unit>
        <trans-unit id="c1322757203b80e7b2662642555746c59f625860" translate="yes" xml:space="preserve">
          <source>XS modules for all categories but &lt;code&gt;LC_NUMERIC&lt;/code&gt; get the underlying locale, and hence any C library functions they call will use that underlying locale. For more discussion, see &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;&quot;CAVEATS&quot; in perlxs&lt;/a&gt;.</source>
          <target state="translated">除 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 以外的所有类别的XS模块都获得基础语言环境，因此，它们调用的任何C库函数都将使用该基础语言环境。有关更多讨论，请参见&lt;a href=&quot;perlxs#CAVEATS&quot;&gt;perlxs中的&amp;ldquo; CAVEATS&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6e0da0571ab8b6cd13332fb1b92e13ef69723c3" translate="yes" xml:space="preserve">
          <source>XS modules for all categories but &lt;code&gt;LC_NUMERIC&lt;/code&gt; get the underlying locale, and hence any C library functions they call will use that underlying locale. For more discussion, see &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;CAVEATS in perlxs&lt;/a&gt;.</source>
          <target state="translated">除 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 以外的所有类别的XS模块都获得基础语言环境，因此，它们调用的任何C库函数都将使用该基础语言环境。有关更多讨论，请参见&lt;a href=&quot;perlxs#CAVEATS&quot;&gt;perlxs中的CAVEATS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cde8f9f4aa7dc1d35b0c98fee87c3ff3dfbc220c" translate="yes" xml:space="preserve">
          <source>XS-type modules do require re-linking the perl binary, because part of an XS module is written in &quot;C&quot;, and has to be linked together with the perl binary to be executed. This is required because perl under DJGPP is built with the &quot;static link&quot; option, due to the lack of &quot;dynamic linking&quot; in the DJGPP environment.</source>
          <target state="translated">XS类型的模块确实需要重新链接perl二进制文件,因为XS模块的一部分是用 &quot;C &quot;写的,必须和要执行的perl二进制文件链接在一起。之所以需要这样做,是因为DJGPP下的perl是以 &quot;静态链接 &quot;选项构建的,因为DJGPP环境中缺乏 &quot;动态链接&quot;。</target>
        </trans-unit>
        <trans-unit id="ec2988beaa8676362d1ed3ab16467d9b855facea" translate="yes" xml:space="preserve">
          <source>XS::APItest</source>
          <target state="translated">XS::APItest</target>
        </trans-unit>
        <trans-unit id="f864391a1885990bb3986e5bb9cdfe1529118689" translate="yes" xml:space="preserve">
          <source>XS::APItest - Test the perl C API</source>
          <target state="translated">XS::APItest-测试 perl C API</target>
        </trans-unit>
        <trans-unit id="77965b88f2916dfa7ea799a1ecde83c5bade894f" translate="yes" xml:space="preserve">
          <source>XS::Typemap</source>
          <target state="translated">XS::Typemap</target>
        </trans-unit>
        <trans-unit id="1e9618266eb67d10623f9d27874dc8f7655ade73" translate="yes" xml:space="preserve">
          <source>XS::Typemap - module to test the XS typemaps distributed with perl</source>
          <target state="translated">XS::Typemap-用于测试随perl发布的XS类型图的模块。</target>
        </trans-unit>
        <trans-unit id="abb06f137479712fdf29157a9f339063d581a30d" translate="yes" xml:space="preserve">
          <source>XSBUILD</source>
          <target state="translated">XSBUILD</target>
        </trans-unit>
        <trans-unit id="69f57ba624b38c0aa8389aea0ffe9fd217df0165" translate="yes" xml:space="preserve">
          <source>XSLoader</source>
          <target state="translated">XSLoader</target>
        </trans-unit>
        <trans-unit id="afd8fa1c6f48c528375edb581b5cfae64284c5a7" translate="yes" xml:space="preserve">
          <source>XSLoader - Dynamically load C libraries into Perl code</source>
          <target state="translated">XSLoader-动态加载C库到Perl代码中。</target>
        </trans-unit>
        <trans-unit id="beb5f03415996a22eb7162d79a1cf0e450db5ba8" translate="yes" xml:space="preserve">
          <source>XSMULTI</source>
          <target state="translated">XSMULTI</target>
        </trans-unit>
        <trans-unit id="0921a161e9b005cd558f520ad84c3711a9234802" translate="yes" xml:space="preserve">
          <source>XSOPT</source>
          <target state="translated">XSOPT</target>
        </trans-unit>
        <trans-unit id="92e8e6dd254dabeb8537af4197e956a328b3ea2d" translate="yes" xml:space="preserve">
          <source>XSPROTOARG</source>
          <target state="translated">XSPROTOARG</target>
        </trans-unit>
        <trans-unit id="870a57e9b71b2a4c7d8b5d7661446dadbdc3d78c" translate="yes" xml:space="preserve">
          <source>XSRETURN</source>
          <target state="translated">XSRETURN</target>
        </trans-unit>
        <trans-unit id="4412705ffd15db1cc81dd4e97115e4240eed7c02" translate="yes" xml:space="preserve">
          <source>XSRETURN_EMPTY</source>
          <target state="translated">XSRETURN_EMPTY</target>
        </trans-unit>
        <trans-unit id="7516ad5d6afe7eff2028827f9d3ce25b91d747e1" translate="yes" xml:space="preserve">
          <source>XSRETURN_IV</source>
          <target state="translated">XSRETURN_IV</target>
        </trans-unit>
        <trans-unit id="7e5a22d1a7883f884227641cdf52bde57c7c0cd5" translate="yes" xml:space="preserve">
          <source>XSRETURN_NO</source>
          <target state="translated">XSRETURN_NO</target>
        </trans-unit>
        <trans-unit id="a72df091bba7b8d6d0f9b76040485b4a1059b320" translate="yes" xml:space="preserve">
          <source>XSRETURN_NV</source>
          <target state="translated">XSRETURN_NV</target>
        </trans-unit>
        <trans-unit id="c9bd2b450336e9a3992bddc7c7b4a884bb908613" translate="yes" xml:space="preserve">
          <source>XSRETURN_PV</source>
          <target state="translated">XSRETURN_PV</target>
        </trans-unit>
        <trans-unit id="31bb0caf5acf67711f8b48a53013782fa24d0e5c" translate="yes" xml:space="preserve">
          <source>XSRETURN_UNDEF</source>
          <target state="translated">XSRETURN_UNDEF</target>
        </trans-unit>
        <trans-unit id="75dd44c03d403bbc60a246b9a6263dd12586d022" translate="yes" xml:space="preserve">
          <source>XSRETURN_UV</source>
          <target state="translated">XSRETURN_UV</target>
        </trans-unit>
        <trans-unit id="6940b196422b14c137e4603100533585c01d3873" translate="yes" xml:space="preserve">
          <source>XSRETURN_YES</source>
          <target state="translated">XSRETURN_YES</target>
        </trans-unit>
        <trans-unit id="0071e55f0de2d741b86408cbdd221e6b71588408" translate="yes" xml:space="preserve">
          <source>XST_mIV</source>
          <target state="translated">XST_mIV</target>
        </trans-unit>
        <trans-unit id="8746b00346bb95fd6d7203847b95eace0e227af2" translate="yes" xml:space="preserve">
          <source>XST_mNO</source>
          <target state="translated">XST_mNO</target>
        </trans-unit>
        <trans-unit id="18b7e60b2312b4cdf84185a38f3105ba024df44d" translate="yes" xml:space="preserve">
          <source>XST_mNV</source>
          <target state="translated">XST_mNV</target>
        </trans-unit>
        <trans-unit id="f5704ef0a40693c861b7a0f79e6acb2f0a79e526" translate="yes" xml:space="preserve">
          <source>XST_mPV</source>
          <target state="translated">XST_mPV</target>
        </trans-unit>
        <trans-unit id="b30947135a6d0dc9cd094f1f5c672b0d8df27a87" translate="yes" xml:space="preserve">
          <source>XST_mUNDEF</source>
          <target state="translated">XST_mUNDEF</target>
        </trans-unit>
        <trans-unit id="c4c00149e31a863f36a4eccec4b30bed628c9d7b" translate="yes" xml:space="preserve">
          <source>XST_mUV</source>
          <target state="translated">XST_mUV</target>
        </trans-unit>
        <trans-unit id="850783c2d3d2b8cee3448cdaf150b58812cdd570" translate="yes" xml:space="preserve">
          <source>XST_mYES</source>
          <target state="translated">XST_mYES</target>
        </trans-unit>
        <trans-unit id="ddfc93741501a0abefa88da99d97e36deaed4cbc" translate="yes" xml:space="preserve">
          <source>XSUB</source>
          <target state="translated">XSUB</target>
        </trans-unit>
        <trans-unit id="4579138c9695c3de09b5142af11ef81d8446e749" translate="yes" xml:space="preserve">
          <source>XSUB.h</source>
          <target state="translated">XSUB.h</target>
        </trans-unit>
        <trans-unit id="df024d96e0c6354fb4e32675dd41d60e15bc6f98" translate="yes" xml:space="preserve">
          <source>XSUBANY</source>
          <target state="translated">XSUBANY</target>
        </trans-unit>
        <trans-unit id="4df5cfe3d83127b158a7d5a161b5570785b675ad" translate="yes" xml:space="preserve">
          <source>XSUBs and the Argument Stack</source>
          <target state="translated">XSUBs和参数栈</target>
        </trans-unit>
        <trans-unit id="638efca4cf9c7b80e03f195d87e0ea4d39d29c81" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to avoid automatic conversion of Perl function arguments to C function arguments. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details. Some people prefer manual conversion by inspecting &lt;code&gt;ST(i)&lt;/code&gt; even in the cases when automatic conversion will do, arguing that this makes the logic of an XSUB call clearer. Compare with &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;&quot;Getting the fat out of XSUBs&quot;&lt;/a&gt; for a similar tradeoff of a complete separation of &quot;Perl glue&quot; and &quot;workhorse&quot; parts of an XSUB.</source>
          <target state="translated">还允许XSUB避免将Perl函数参数自动转换为C函数参数。有关详细信息，请参见&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;。甚至在自动转换可以进行的情况下，有些人还是喜欢通过检查 &lt;code&gt;ST(i)&lt;/code&gt; 来进行手动转换，因为这使XSUB调用的逻辑更加清晰。与&lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;&amp;ldquo;摆脱&lt;/a&gt;XSUB的麻烦&amp;rdquo;进行比较，可以类似地权衡XSUB的&amp;ldquo; Perl胶&amp;rdquo;和&amp;ldquo;主力&amp;rdquo;部分的完全分离。</target>
        </trans-unit>
        <trans-unit id="3b5999991ea7d60b38c8ca1802a3aa2e3198b825" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to avoid automatic conversion of Perl function arguments to C function arguments. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details. Some people prefer manual conversion by inspecting &lt;code&gt;ST(i)&lt;/code&gt; even in the cases when automatic conversion will do, arguing that this makes the logic of an XSUB call clearer. Compare with &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt; for a similar tradeoff of a complete separation of &quot;Perl glue&quot; and &quot;workhorse&quot; parts of an XSUB.</source>
          <target state="translated">还允许XSUB避免将Perl函数参数自动转换为C函数参数。有关详细信息，请参见&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;。甚至在自动转换可以进行的情况下，有些人还是喜欢通过检查 &lt;code&gt;ST(i)&lt;/code&gt; 来进行手动转换，因为这使XSUB调用的逻辑更加清晰。与&lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;将脂肪从&lt;/a&gt; XSUB中移除相比，XBOX的&amp;ldquo; Perl胶&amp;rdquo;和&amp;ldquo;主力&amp;rdquo;部分的完全分离具有类似的权衡。</target>
        </trans-unit>
        <trans-unit id="54080bcfea2adf5c913b064ead22f355c2ce0033" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to return lists, not just scalars. This must be done by manipulating stack values ST(0), ST(1), etc, in a subtly different way. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details.</source>
          <target state="translated">还允许XSUB返回列表，而不仅仅是标量。这必须通过以微妙的不同方式操纵堆栈值ST（0），ST（1）等来完成。有关详细信息，请参见&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88b3157d6a7563b7eeae312db4f170271aab7d57" translate="yes" xml:space="preserve">
          <source>XSUBs can have variable-length parameter lists by specifying an ellipsis &lt;code&gt;(...)&lt;/code&gt; in the parameter list. This use of the ellipsis is similar to that found in ANSI C. The programmer is able to determine the number of arguments passed to the XSUB by examining the &lt;code&gt;items&lt;/code&gt; variable which the &lt;b&gt;xsubpp&lt;/b&gt; compiler supplies for all XSUBs. By using this mechanism one can create an XSUB which accepts a list of parameters of unknown length.</source>
          <target state="translated">通过在参数列表中指定省略号 &lt;code&gt;(...)&lt;/code&gt; ，XSUB可以具有可变长度的参数列表。省略号的这种用法类似于ANSI C中的用法。程序员可以通过检查&lt;b&gt;xsubpp&lt;/b&gt;编译器为所有&lt;b&gt;XSUB&lt;/b&gt;提供的 &lt;code&gt;items&lt;/code&gt; 变量来确定传递给XSUB的参数数量。通过使用这种机制，可以创建一个XSUB，它接受未知长度的参数列表。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3be2c3082f6ee5ac4e24cba3fef031d150316f00" translate="yes" xml:space="preserve">
          <source>XSUBs do not have a &lt;code&gt;CvPADLIST&lt;/code&gt;. &lt;code&gt;dXSTARG&lt;/code&gt; fetches values from &lt;code&gt;PL_curpad&lt;/code&gt;, but that is really the callers pad (a slot of which is allocated by every entersub). Do not get or set &lt;code&gt;CvPADLIST&lt;/code&gt; if a CV is an XSUB (as determined by &lt;code&gt;CvISXSUB()&lt;/code&gt;), &lt;code&gt;CvPADLIST&lt;/code&gt; slot is reused for a different internal purpose in XSUBs.</source>
          <target state="translated">&lt;code&gt;CvPADLIST&lt;/code&gt; 没有CvPADLIST。 &lt;code&gt;dXSTARG&lt;/code&gt; 中取值从 &lt;code&gt;PL_curpad&lt;/code&gt; ，但是这是真的呼叫者垫（一个时隙一个通过每entersub分配）。如果CV是XSUB（由 &lt;code&gt;CvISXSUB()&lt;/code&gt; 确定），则不要获取或设置 &lt;code&gt;CvPADLIST&lt;/code&gt; ， &lt;code&gt;CvPADLIST&lt;/code&gt; 插槽可用于XSUB中的不同内部用途。</target>
        </trans-unit>
        <trans-unit id="3f2e0ddc3d17d87460a2a8a983be1c97c83b73d1" translate="yes" xml:space="preserve">
          <source>XSUBs do not have a CvPADLIST. dXSTARG fetches values from PL_curpad, but that is really the callers pad (a slot of which is allocated by every entersub). Do not get or set CvPADLIST if a CV is an XSUB (as determined by &lt;code&gt;CvISXSUB()&lt;/code&gt; ), CvPADLIST slot is reused for a different internal purpose in XSUBs.</source>
          <target state="translated">XSUB没有CvPADLIST。dXSTARG从PL_curpad中获取值，但这实际上是调用者板（每个entersub都分配了其插槽）。如果CV是XSUB（由 &lt;code&gt;CvISXSUB()&lt;/code&gt; 确定），则不要获取或设置CvPADLIST ，CvPADLIST插槽在XSUB中被用于其他内部用途。</target>
        </trans-unit>
        <trans-unit id="6daf3f5f97a3cf191b47d0b650ffb497515d3ee1" translate="yes" xml:space="preserve">
          <source>XSUBs refer to their stack arguments with the macro &lt;b&gt;ST(x)&lt;/b&gt;, where</source>
          <target state="translated">XSUB使用宏&lt;b&gt;ST（x）&lt;/b&gt;引用其堆栈参数，其中</target>
        </trans-unit>
        <trans-unit id="b948898c3205f86da22df7bb2aa8e0fc31385f66" translate="yes" xml:space="preserve">
          <source>XS_APIVERSION_BOOTCHECK</source>
          <target state="translated">XS_APIVERSION_BOOTCHECK</target>
        </trans-unit>
        <trans-unit id="45e92c706e14fc42e8a65549cfb504f51b80720e" translate="yes" xml:space="preserve">
          <source>XS_DEFINE_VERSION: -D line to set the xs version when compiling.</source>
          <target state="translated">XS_DEFINE_VERSION:-D行用于在编译时设置xs版本。</target>
        </trans-unit>
        <trans-unit id="c079612ab9bf6b165676a675aeaa6f541c733506" translate="yes" xml:space="preserve">
          <source>XS_EXTERNAL</source>
          <target state="translated">XS_EXTERNAL</target>
        </trans-unit>
        <trans-unit id="b36c9e63716f92004705d5a5880b339795a114b1" translate="yes" xml:space="preserve">
          <source>XS_FH</source>
          <target state="translated">XS_FH</target>
        </trans-unit>
        <trans-unit id="0b91e170805a05f3fc3b4f1fe3e1c801a51a5cd9" translate="yes" xml:space="preserve">
          <source>XS_FILE</source>
          <target state="translated">XS_FILE</target>
        </trans-unit>
        <trans-unit id="5a72d7eb1d508bb628564c702b5adf9c962f07c6" translate="yes" xml:space="preserve">
          <source>XS_INTERNAL</source>
          <target state="translated">XS_INTERNAL</target>
        </trans-unit>
        <trans-unit id="c30e58ff83929eb55292bc3f56bfb117c5d6b82f" translate="yes" xml:space="preserve">
          <source>XS_SUBNAME</source>
          <target state="translated">XS_SUBNAME</target>
        </trans-unit>
        <trans-unit id="c3c54470969e9570024cbdc019515c6664650a72" translate="yes" xml:space="preserve">
          <source>XS_VERSION</source>
          <target state="translated">XS_VERSION</target>
        </trans-unit>
        <trans-unit id="f6c7bf9f42bb6c2a25e194ec60219f0a8150edce" translate="yes" xml:space="preserve">
          <source>XS_VERSION: version in your .xs file. Defaults to $(VERSION)</source>
          <target state="translated">XS_VERSION:.xs文件中的版本。默认值为$(VERSION)</target>
        </trans-unit>
        <trans-unit id="849ccfe7e642de7c6c2afec3b38bc17a103cbe71" translate="yes" xml:space="preserve">
          <source>XS_VERSION_BOOTCHECK</source>
          <target state="translated">XS_VERSION_BOOTCHECK</target>
        </trans-unit>
        <trans-unit id="53fccca1190b204bd667ec9d6791fd3b9d14df6c" translate="yes" xml:space="preserve">
          <source>XS_VERSION_MACRO: which macro represents the XS version.</source>
          <target state="translated">XS_VERSION_MACRO:哪个宏代表XS版本。</target>
        </trans-unit>
        <trans-unit id="c3b618e9ce8bc3b3691008b5df681815a883cb69" translate="yes" xml:space="preserve">
          <source>XS_constant PACKAGE, TYPES, XS_SUBNAME, C_SUBNAME</source>
          <target state="translated">XS_constant PACKAGE,TYPES,XS_SUBNAME,C_SUBNAME。</target>
        </trans-unit>
        <trans-unit id="20026dc165c030fe3a5d9609a6e61ab26210cbc1" translate="yes" xml:space="preserve">
          <source>XX</source>
          <target state="translated">XX</target>
        </trans-unit>
        <trans-unit id="a9674b19f8c56f785c91a555d0a144522bb318e6" translate="yes" xml:space="preserve">
          <source>XXX</source>
          <target state="translated">XXX</target>
        </trans-unit>
        <trans-unit id="efc0ac66700effcf3b5c6d5cfb0d3ed1e5da5cc1" translate="yes" xml:space="preserve">
          <source>XXX DAPM it would make more sense to make the arg a PADOFFSET void SAVEPADSV(PADOFFSET po)</source>
          <target state="translated">XXX DAPM如果把arg做成PADOFFSET会更有意义 void SAVEPADSV(PADOFFSET po)</target>
        </trans-unit>
        <trans-unit id="0a8c3822391bb958edc27b75e5a6c90f50363bce" translate="yes" xml:space="preserve">
          <source>XXX.</source>
          <target state="translated">XXX.</target>
        </trans-unit>
        <trans-unit id="759d5f762181a933d7c0ff7fd8096838ff6b5ec3" translate="yes" xml:space="preserve">
          <source>XXX: Needs more docs.</source>
          <target state="translated">XXX:需要更多的文件。</target>
        </trans-unit>
        <trans-unit id="e3a8809017dd76bd26557a5b923ab2ae16c0cdb3" translate="yes" xml:space="preserve">
          <source>XXXX</source>
          <target state="translated">XXXX</target>
        </trans-unit>
        <trans-unit id="034f1965ccdbdf9e642feeb9858da5096b6d1a9a" translate="yes" xml:space="preserve">
          <source>XY</source>
          <target state="translated">XY</target>
        </trans-unit>
        <trans-unit id="1ed31ab8e3d4874b1d94827212eca5617d49d812" translate="yes" xml:space="preserve">
          <source>XopDISABLE</source>
          <target state="translated">XopDISABLE</target>
        </trans-unit>
        <trans-unit id="fdee56cbf2dd3729d372ee9ddd71eeb3c584e3a0" translate="yes" xml:space="preserve">
          <source>XopENABLE</source>
          <target state="translated">XopENABLE</target>
        </trans-unit>
        <trans-unit id="d452a85c41b2e0aa7a38834ff3a3b101c7d4ac6f" translate="yes" xml:space="preserve">
          <source>XopENTRY</source>
          <target state="translated">XopENTRY</target>
        </trans-unit>
        <trans-unit id="12a6abfec4959cd21c68fcfdd5a310b6940a1038" translate="yes" xml:space="preserve">
          <source>XopENTRYCUSTOM</source>
          <target state="translated">XopENTRYCUSTOM</target>
        </trans-unit>
        <trans-unit id="f6bc06eec4d13090054285af25a6e8fdfa5cb801" translate="yes" xml:space="preserve">
          <source>XopENTRY_set</source>
          <target state="translated">XopENTRY_set</target>
        </trans-unit>
        <trans-unit id="b37b621154ed9fa599925b4a3aa2dcee68ee7486" translate="yes" xml:space="preserve">
          <source>XopFLAGS</source>
          <target state="translated">XopFLAGS</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="ffbcb202b09db426bae56cf2ffb88f18594f2258" translate="yes" xml:space="preserve">
          <source>YAML</source>
          <target state="translated">YAML</target>
        </trans-unit>
        <trans-unit id="50bc04e009ed4a61bc2c2e4c00258238b3cec732" translate="yes" xml:space="preserve">
          <source>YAML result token.</source>
          <target state="translated">YAML结果标记。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
