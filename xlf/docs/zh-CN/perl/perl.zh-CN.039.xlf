<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="f0a36e2858858b02958d2f9bb2e7a02778b6e7c8" translate="yes" xml:space="preserve">
          <source>If you haven't already, before reading this document, you should become familiar with both &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; and &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">如果还没有，请在阅读本文档之前熟悉&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;和&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f5cd5895b74e660a355a89bb89cfe0d64a65e68" translate="yes" xml:space="preserve">
          <source>If you haven't read &lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; and &lt;a href=&quot;perlhacktut&quot;&gt;perlhacktut&lt;/a&gt; yet, you might want to do that first.</source>
          <target state="translated">如果您还没有阅读&lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt;和&lt;a href=&quot;perlhacktut&quot;&gt;perlhacktut&lt;/a&gt;，则可能要先阅读。</target>
        </trans-unit>
        <trans-unit id="9d18cc6d1bb045c22ff75a5143e7edc7882d3f36" translate="yes" xml:space="preserve">
          <source>If you haven't read &lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; yet, go do that first! You might also want to read through &lt;a href=&quot;perlsource&quot;&gt;perlsource&lt;/a&gt; too.</source>
          <target state="translated">如果您还没有阅读过&lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt;，请先进行操作！您可能还需要阅读&lt;a href=&quot;perlsource&quot;&gt;perlsource&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c78c6e524a1994f83a33a6fe7a18f30be9a7fce" translate="yes" xml:space="preserve">
          <source>If you haven't used regular expressions before, a quick-start introduction is available in &lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt;, and a longer tutorial introduction is available in &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;.</source>
          <target state="translated">如果您以前没有使用过正则表达式，则可以在&lt;a href=&quot;perlrequick&quot;&gt;perlrequick中&lt;/a&gt;找到快速入门介绍，而在&lt;a href=&quot;perlretut&quot;&gt;perlretut中&lt;/a&gt;可以找到更长的教程介绍。</target>
        </trans-unit>
        <trans-unit id="523b01060cd2a1e79d110af4dcfaa137536eb9a5" translate="yes" xml:space="preserve">
          <source>If you haven't used regular expressions before, a tutorial introduction is available in &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;. If you know just a little about them, a quick-start introduction is available in &lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7a1d83ca677617a38c3a7af6a10c7ed341f9e8" translate="yes" xml:space="preserve">
          <source>If you haven't yet moved &lt;code&gt;perl*.dll&lt;/code&gt; onto LIBPATH, do it now.</source>
          <target state="translated">如果尚未将 &lt;code&gt;perl*.dll&lt;/code&gt; 移至LIBPATH，请立即执行。</target>
        </trans-unit>
        <trans-unit id="83593b846f63af31e001bdf82839b9a46da47025" translate="yes" xml:space="preserve">
          <source>If you ignore all the error checking that most of the code does, the essence of the filter is as follows:</source>
          <target state="translated">如果你忽略了大部分代码所做的错误检查,过滤器的本质如下。</target>
        </trans-unit>
        <trans-unit id="4660b183b00b39c6b2b92484fb7503359beb8635" translate="yes" xml:space="preserve">
          <source>If you import &lt;code&gt;:constants256&lt;/code&gt; , you can use the following constants directly:</source>
          <target state="translated">如果导入 &lt;code&gt;:constants256&lt;/code&gt; ，则可以直接使用以下常量：</target>
        </trans-unit>
        <trans-unit id="6fb29858655e86b9cd846e89d6a53be9482baa8e" translate="yes" xml:space="preserve">
          <source>If you import &lt;code&gt;:constants256&lt;/code&gt;, you can use the following constants directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed57c7ce00df9ba4b19fb6493a06d874c07ba72a" translate="yes" xml:space="preserve">
          <source>If you insist on using bare v-strings with Perl &amp;gt; 5.6.0, be aware of the following limitations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87b608eeb1cdc6eb4d8977d4b889a03e6d083dd" translate="yes" xml:space="preserve">
          <source>If you intend making use of the object returned from either tie() or tied(), and if the tie's target class defines a destructor, there is a subtle gotcha you</source>
          <target state="translated">如果你打算使用从 tie()或 tied()返回的对象,并且如果 tie 的目标类定义了一个析构器,那么你就会发现一个微妙的陷阱,那就是</target>
        </trans-unit>
        <trans-unit id="dbdc31314e86dc1060f92b8ed429f69bdf25f6be" translate="yes" xml:space="preserve">
          <source>If you intend to manipulate the Zip64 zip files created with &lt;code&gt;IO-Compress-Zip&lt;/code&gt; using an external zip/unzip, make sure that it supports Zip64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc6f9a7f0a4b90e4946e190029eff70ef889753" translate="yes" xml:space="preserve">
          <source>If you intend to manipulate the Zip64 zip files created with this module using an external zip/unzip, make sure that it supports Zip64.</source>
          <target state="translated">如果你打算使用外部的zip/unzip来操作用该模块创建的Zip64压缩文件,请确保它支持Zip64。</target>
        </trans-unit>
        <trans-unit id="fd3a1f6a190142b4a94b8f1071ccacb0e45694c8" translate="yes" xml:space="preserve">
          <source>If you intend to run only on FAT (or if using AnyDBM_File on FAT), run Configure with the -Ui_ndbm and -Ui_dbm options to prevent NDBM_File and ODBM_File being built.</source>
          <target state="translated">如果你打算只在 FAT 上运行 (或者在 FAT 上使用 AnyDBM_File),使用 -Ui_ndbm 和 -Ui_dbm 选项运行 Configure 以防止 NDBM_File 和 ODBM_File 被构建。</target>
        </trans-unit>
        <trans-unit id="3f04b70c5edf0d8a2ff6b52a2e5a3c4237fee493" translate="yes" xml:space="preserve">
          <source>If you intend using the Filter::Call functionality, I would strongly recommend that you check out Damian Conway's excellent Filter::Simple module. Damian's module provides a much cleaner interface than Filter::Util::Call. Although it doesn't allow the fine control that Filter::Util::Call does, it should be adequate for the majority of applications. It's available at</source>
          <target state="translated">如果你打算使用Filter::Call功能,我会强烈建议你查看Damian Conway的优秀的Filter::Simple模块。Damian的模块提供了一个比Filter::Util::Call更简洁的界面。虽然它不允许像Filter::Util::Call那样的精细控制,但它应该足以满足大多数应用程序的需求。它可以在</target>
        </trans-unit>
        <trans-unit id="e2cffac6976f9820e2e90021e812ad7d58d0f5b4" translate="yes" xml:space="preserve">
          <source>If you intended for the subroutine to be eligible for inlining, then make sure the variable is not referenced elsewhere, possibly by copying it:</source>
          <target state="translated">如果你打算让这个子程序符合内联的条件,那么请确保这个变量没有被引用到其他地方,可能是通过复制它。</target>
        </trans-unit>
        <trans-unit id="9dab4bde5120fee3a0a7f6db844ef859c18d4c68" translate="yes" xml:space="preserve">
          <source>If you invoke Concise more than once in a program, you should know that the options are 'sticky'. This means that the options you provide in the first call will be remembered for the 2nd call, unless you re-specify or change them.</source>
          <target state="translated">如果你在程序中调用 Concise 多次,你应该知道这些选项是 &quot;粘性 &quot;的,这意味着你在第一次调用时提供的选项会在第二次调用时被记住,除非你重新指定或更改它们。这意味着你在第一次调用时提供的选项将在第二次调用时被记住,除非你重新指定或更改它们。</target>
        </trans-unit>
        <trans-unit id="50093622d9b6b20299be5b789440addca54eb16b" translate="yes" xml:space="preserve">
          <source>If you invoke Perl with the &lt;b&gt;-d&lt;/b&gt; switch, your script runs under the Perl source debugger. This works like an interactive Perl environment, prompting for debugger commands that let you examine source code, set breakpoints, get stack backtraces, change the values of variables, etc. This is so convenient that you often fire up the debugger all by itself just to test out Perl constructs interactively to see what they do. For example:</source>
          <target state="translated">如果使用&lt;b&gt;-d&lt;/b&gt;开关调用Perl，则脚本将在Perl源调试器下运行。它的工作方式类似于交互式Perl环境，会提示您输入调试器命令，这些命令可让您检查源代码，设置断点，获取堆栈回溯，更改变量的值等。这非常方便，因此您经常自己单独启动调试器即可以交互方式测试Perl构造以查看其作用。例如：</target>
        </trans-unit>
        <trans-unit id="5f165a45e66d1014a54e531d87cac35b6f25f848" translate="yes" xml:space="preserve">
          <source>If you iterate through the hash with each(), you can delete the key most recently returned without worrying about it. If you delete or add other keys, the iterator may skip or double up on them since perl may rearrange the hash table. See the entry for &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">如果使用each（）遍历哈希，则可以删除最近返回的密钥，而不必担心。如果删除或添加其他键，则迭代器可能会跳过或加倍使用它们，因为perl可能会重新排列哈希表。请参阅进入 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; 在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d81db3e7b1b60ae3b2c12b8158af75032cae4b4" translate="yes" xml:space="preserve">
          <source>If you iterate through the hash with each(), you can delete the key most recently returned without worrying about it. If you delete or add other keys, the iterator may skip or double up on them since perl may rearrange the hash table. See the entry for &lt;code&gt;each()&lt;/code&gt; in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e23dd3433d5c0c9ce07c89417e11d9a477ce1b1b" translate="yes" xml:space="preserve">
          <source>If you just need to customize the objects on creation, subclass &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_iterator_factory&quot;&gt;&quot;make_iterator_factory&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96bb290aa78bc388524149987ffa684a6cd88006" translate="yes" xml:space="preserve">
          <source>If you just need to customize the objects on creation, subclass &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_iterator_factory&quot;&gt;make_iterator_factory&lt;/a&gt;.</source>
          <target state="translated">如果只需要在创建时自定义对象，请子类&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;并覆盖&lt;a href=&quot;#make_iterator_factory&quot;&gt;make_iterator_factory&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d8b361c59c621bac0b0795b77d82ce0376ae0d6" translate="yes" xml:space="preserve">
          <source>If you just want the bytes printed in a 7bit NUL-terminated string, you can just use &lt;code&gt;%s&lt;/code&gt; (assuming they are all really only 7bit). But if there is a possibility the value will be encoded as UTF-8 or contains bytes above &lt;code&gt;0x7F&lt;/code&gt; (and therefore 8bit), you should instead use the &lt;code&gt;UTF8f&lt;/code&gt; format. And as its parameter, use the &lt;code&gt;UTF8fARG()&lt;/code&gt; macro:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eae7a7eb8bcc1fc11d062386801944953ed61fe" translate="yes" xml:space="preserve">
          <source>If you just want to extract, use the &lt;code&gt;extract_archive&lt;/code&gt; class method instead. It will optimize and write to disk immediately.</source>
          <target state="translated">如果只想提取，请改用 &lt;code&gt;extract_archive&lt;/code&gt; 类方法。它将优化并立即写入磁盘。</target>
        </trans-unit>
        <trans-unit id="205b6c9376bdc41030a3ba0411b3c133175a1cfb" translate="yes" xml:space="preserve">
          <source>If you just want to know how to use the utilities described here,</source>
          <target state="translated">如果你只是想知道如何使用这里介绍的实用程序。</target>
        </trans-unit>
        <trans-unit id="5ca84053d1241bb168ed3733abf9fe5fef328612" translate="yes" xml:space="preserve">
          <source>If you just want to load a module in a test, we recommend simply using &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directly. It will cause the test to stop.</source>
          <target state="translated">如果您只想在测试中加载模块，我们建议直接使用 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 。这将导致测试停止。</target>
        </trans-unit>
        <trans-unit id="2c70a28f88935f71d3cc2f51d7cbe4011451f638" translate="yes" xml:space="preserve">
          <source>If you just want to load a module in a test, we recommend simply using &lt;code&gt;use&lt;/code&gt; directly. It will cause the test to stop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5383a5a1f3fb1c8ecb11208a275376f630d5aac" translate="yes" xml:space="preserve">
          <source>If you just want to sort keys (names) in JSON objects when you &lt;code&gt;encode&lt;/code&gt;, enable &lt;code&gt;canonical&lt;/code&gt; option (see above) that allows you to sort object keys alphabetically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d9e2fc3089c3ee91bde03c8a168aabda14adca" translate="yes" xml:space="preserve">
          <source>If you just want to submit a single small patch like a pod fix, a test for a bug, comment fixes, etc., it's easy! Here's how:</source>
          <target state="translated">如果你只是想提交一个小补丁,比如一个pod的修复,一个bug的测试,评论的修复等等,这很容易!你可以在这里提交一个小补丁。下面是如何提交的。</target>
        </trans-unit>
        <trans-unit id="a3962095233ae6bded8cb1555c84a52ea4fc9a0c" translate="yes" xml:space="preserve">
          <source>If you just want to test a module can be loaded, use &lt;code&gt;require_ok&lt;/code&gt; .</source>
          <target state="translated">如果您只是想测试模块是否可以加载，请使用 &lt;code&gt;require_ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3978204bccf1fd47b9da04f6a2bf931fa35286f6" translate="yes" xml:space="preserve">
          <source>If you just want to test a module can be loaded, use &lt;code&gt;require_ok&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e3b970aadb68ea3a8923d019f70d26e7a5a350" translate="yes" xml:space="preserve">
          <source>If you know</source>
          <target state="translated">如果你知道</target>
        </trans-unit>
        <trans-unit id="9c14b8eb60486ad1003f5f292ba8d0aaf7f2284e" translate="yes" xml:space="preserve">
          <source>If you know one name for a Unicode property, you can use &lt;code&gt;prop_aliases&lt;/code&gt; to find either the long name (when called in scalar context), or a list of all of the names, somewhat ordered so that the short name is in the 0th element, the long name in the next element, and any other synonyms are in the remaining elements, in no particular order.</source>
          <target state="translated">如果您知道Unicode属性的名称，则可以使用 &lt;code&gt;prop_aliases&lt;/code&gt; 查找长名称（在标量上下文中调用时）或所有名称的列表，并按一定顺序排列，以使短名称位于第0个元素中，下一个元素中的长名称，以及其他任何同义词都在其余元素中，没有特定的顺序。</target>
        </trans-unit>
        <trans-unit id="cb42b2ab34d9ba0baed912ade71e395e6b67b39f" translate="yes" xml:space="preserve">
          <source>If you know that &lt;code&gt;$compressedLength&lt;/code&gt; isn't that big then using temporary storage won't be a problem. But if &lt;code&gt;$compressedLength&lt;/code&gt; is very large or you are writing an application that other people will use, and so have no idea how big &lt;code&gt;$compressedLength&lt;/code&gt; will be, it could be an issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a59a33095f0058eebdfd05ced2318493337053a" translate="yes" xml:space="preserve">
          <source>If you know the columns that contain the data, you can use &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; to extract a single column.</source>
          <target state="translated">如果知道包含数据的列，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; 提取单个列。</target>
        </trans-unit>
        <trans-unit id="06cfb464d41fe790822610afbdaa468a829c60a7" translate="yes" xml:space="preserve">
          <source>If you know the columns that contain the data, you can use &lt;code&gt;substr&lt;/code&gt; to extract a single column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eb4c97e122131b8720d6a259fed14fb554c1b02" translate="yes" xml:space="preserve">
          <source>If you know the directory already, you can add it to &lt;code&gt;@INC&lt;/code&gt; as you would for any other directory. You might &amp;lt;use lib&amp;gt; if you know the directory at compile time:</source>
          <target state="translated">如果您已经知道目录，则可以将其添加到 &lt;code&gt;@INC&lt;/code&gt; ,就像将其添加到任何其他目录一样。如果您在编译时知道目录，则可以&amp;lt;use lib&amp;gt;：</target>
        </trans-unit>
        <trans-unit id="a3a965f3de203e872ac1dbbc0191ed03e5d04a74" translate="yes" xml:space="preserve">
          <source>If you know the directory already, you can add it to &lt;code&gt;@INC&lt;/code&gt; as you would for any other directory. You might &lt;code&gt;use lib&lt;/code&gt; if you know the directory at compile time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e98e61c08f8371d445ada91d42b0a6e31509fa7c" translate="yes" xml:space="preserve">
          <source>If you know the exact length in bits, it can be used in place of the &lt;code&gt;*&lt;/code&gt; .</source>
          <target state="translated">如果您知道确切的长度（以位为单位），则可以用它代替 &lt;code&gt;*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6be1b2dd7aa390ceb8d695be13eb24892efb660c" translate="yes" xml:space="preserve">
          <source>If you know the exact length in bits, it can be used in place of the &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927bf5e4096ddfb3b14c96fc89123708e7ddad90" translate="yes" xml:space="preserve">
          <source>If you know the length of the compressed data stream before you start uncompressing, you can avoid having to use &lt;code&gt;trailingData&lt;/code&gt; by setting the &lt;code&gt;InputLength&lt;/code&gt; option in the constructor.</source>
          <target state="translated">如果您知道压缩数据流的长度，你开始解压之前，你能避免使用 &lt;code&gt;trailingData&lt;/code&gt; 通过设置 &lt;code&gt;InputLength&lt;/code&gt; 在构造函数中的选项。</target>
        </trans-unit>
        <trans-unit id="f21638ec12744a0da920d55488938e9726007614" translate="yes" xml:space="preserve">
          <source>If you know the length of the compressed data stream before you start uncompressing, you can avoid having to use &lt;code&gt;trailingData&lt;/code&gt; by setting the &lt;code&gt;InputLength&lt;/code&gt; option.</source>
          <target state="translated">如果您知道压缩数据流的长度，你开始解压之前，你能避免使用 &lt;code&gt;trailingData&lt;/code&gt; 通过设置 &lt;code&gt;InputLength&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="d2ae57604fb0c858677a8a7bba0d622df68f1d53" translate="yes" xml:space="preserve">
          <source>If you know the name of a hash variable, you can get a pointer to its HV by using the following:</source>
          <target state="translated">如果你知道一个哈希变量的名字,你可以通过使用下面的方法获得指向它的HV的指针。</target>
        </trans-unit>
        <trans-unit id="eb63e6aa11dc04fb3c005505a5dc56980b836dee" translate="yes" xml:space="preserve">
          <source>If you know the name of a scalar variable, you can get a pointer to its SV by using the following:</source>
          <target state="translated">如果你知道一个标量变量的名称,你可以通过使用下面的方法获得指向它的SV的指针。</target>
        </trans-unit>
        <trans-unit id="71cc5e317d663fb79a1bf1ed454222ec34ef184d" translate="yes" xml:space="preserve">
          <source>If you know the name of an array variable, you can get a pointer to its AV by using the following:</source>
          <target state="translated">如果你知道一个数组变量的名称,你可以通过使用下面的方法来获得它的AV指针。</target>
        </trans-unit>
        <trans-unit id="cd318c8126ae3cf5cfc9e3d9345bc2d0fc779cdb" translate="yes" xml:space="preserve">
          <source>If you know what you are doing you can turn off this warning by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'non_unicode';&lt;/code&gt; .</source>
          <target state="translated">如果您知道自己在做什么，则可以通过 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'non_unicode';&lt;/code&gt; 警告来关闭此警告。。</target>
        </trans-unit>
        <trans-unit id="b884b7f1740fc7317e54fef08f2f9cd3cb14f5e3" translate="yes" xml:space="preserve">
          <source>If you know what you are doing you can turn off this warning by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'surrogate';&lt;/code&gt; .</source>
          <target state="translated">如果您知道自己在做什么，则可以通过 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'surrogate';&lt;/code&gt; 来关闭此警告。。</target>
        </trans-unit>
        <trans-unit id="450cdd3bb7c30208da61bb587dafc55dbfb2d416" translate="yes" xml:space="preserve">
          <source>If you know what you are doing you can turn off this warning by &lt;code&gt;no warnings 'non_unicode';&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bdb6f8f972275104dbb956312abdb2698ecb912" translate="yes" xml:space="preserve">
          <source>If you know what you are doing you can turn off this warning by &lt;code&gt;no warnings 'surrogate';&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e7e8e09f3e73c52948b41c1fa2c3d1d138db3f3" translate="yes" xml:space="preserve">
          <source>If you know you are only going to use a system that does correctly implement appending (i.e. not Win32) then you can omit the &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; from the code in the previous answer.</source>
          <target state="translated">如果您知道只使用能够正确实现附加的系统（即不是Win32），则可以忽略上一个答案中的代码 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba755cafcf3fda0933750ad2082aef00aba43d16" translate="yes" xml:space="preserve">
          <source>If you know you are only going to use a system that does correctly implement appending (i.e. not Win32) then you can omit the &lt;code&gt;seek&lt;/code&gt; from the code in the previous answer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1148f14b2fe4053075a5db927cd2f992ce530c8c" translate="yes" xml:space="preserve">
          <source>If you know you are only writing code to run on an OS and filesystem that does implement append mode correctly (a local filesystem on a modern Unix for example), and you keep the file in block-buffered mode and you write less than one buffer-full of output between each manual flushing of the buffer then each bufferload is almost guaranteed to be written to the end of the file in one chunk without getting intermingled with anyone else's output. You can also use the &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; function which is simply a wrapper around your system's &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write(2)&lt;/a&gt;&lt;/code&gt; system call.</source>
          <target state="translated">如果您知道您只是在编写可以在正确实现附加模式的操作系统和文件系统上运行的代码（例如，在现代Unix上为本地文件系统），并且将文件保持在块缓冲模式下，并且编写的缓冲区少于一个-在每次手动刷新缓冲区之间都充满了输出，然后几乎可以保证将每个bufferload以一个块的形式写入文件的末尾，而不会与其他任何人的输出混合在一起。您还可以使用 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 函数，该函数只是系统的 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write(2)&lt;/a&gt;&lt;/code&gt; 系统调用的包装器。</target>
        </trans-unit>
        <trans-unit id="602b87bd77bf909ec7f1749e9c4b42785a2cd907" translate="yes" xml:space="preserve">
          <source>If you know you are only writing code to run on an OS and filesystem that does implement append mode correctly (a local filesystem on a modern Unix for example), and you keep the file in block-buffered mode and you write less than one buffer-full of output between each manual flushing of the buffer then each bufferload is almost guaranteed to be written to the end of the file in one chunk without getting intermingled with anyone else's output. You can also use the &lt;code&gt;syswrite&lt;/code&gt; function which is simply a wrapper around your system's &lt;code&gt;write(2)&lt;/code&gt; system call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c8e667e3ed1b51f8f2d44670f827394972704b" translate="yes" xml:space="preserve">
          <source>If you know your package, you can just mention it explicitly, as in $Some_Pack::var. Note that the notation $::var is &lt;b&gt;not&lt;/b&gt; the dynamic $var in the current package, but rather the one in the &quot;main&quot; package, as though you had written $main::var.</source>
          <target state="translated">如果您知道您的软件包，则可以像$ Some_Pack :: var一样明确地提及它。请注意，符号$ :: var &lt;b&gt;不是&lt;/b&gt;当前程序包中的动态$ var，而是&amp;ldquo; main&amp;rdquo;程序包中的动态$ var，就像您已编写$ main :: var一样。</target>
        </trans-unit>
        <trans-unit id="283a4b9fbff3cde02d8b49d7e007e0e9915125fc" translate="yes" xml:space="preserve">
          <source>If you like a more web-like approach, a good start point can be &lt;a href=&quot;http://www14.software.ibm.com/webapp/download/downloadaz.jsp&quot;&gt;http://www14.software.ibm.com/webapp/download/downloadaz.jsp&lt;/a&gt; and click &quot;C for AIX&quot;, and follow the instructions.</source>
          <target state="translated">如果您喜欢一种更像Web的方法，那么可以从&lt;a href=&quot;http://www14.software.ibm.com/webapp/download/downloadaz.jsp&quot;&gt;http://www14.software.ibm.com/webapp/download/downloadaz.jsp&lt;/a&gt;开始，然后单击&amp;ldquo; C for AIX&amp;rdquo;，然后按照说明进行操作。</target>
        </trans-unit>
        <trans-unit id="f15eb42f4edad457922247251c5d7e7bc14ff512" translate="yes" xml:space="preserve">
          <source>If you like the &lt;code&gt;prove&lt;/code&gt; utility and &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; but you want your own harness, all you need to do is write one and provide &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;runtests&lt;/code&gt; methods. Then you can use the &lt;code&gt;prove&lt;/code&gt; utility like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95d71103315a260f526ee0388cdf401d8ff3b71" translate="yes" xml:space="preserve">
          <source>If you like the &lt;code&gt;prove&lt;/code&gt; utility and &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; but you want your own harness, all you need to do is write one and provide &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;runtests&lt;/code&gt; methods. Then you can use the &lt;code&gt;prove&lt;/code&gt; utility like so:</source>
          <target state="translated">如果你喜欢 &lt;code&gt;prove&lt;/code&gt; 效用和&lt;a href=&quot;parser&quot;&gt;TAP ::分析器&lt;/a&gt;但你想你自己的安全带，所有你需要做的是写一个，并提供 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;runtests&lt;/code&gt; 方法。然后，您可以像这样使用 &lt;code&gt;prove&lt;/code&gt; 工具：</target>
        </trans-unit>
        <trans-unit id="fbd3ba27ff3a08207feb966e075b2fa08e7cf809" translate="yes" xml:space="preserve">
          <source>If you like, you can store these filehandles in an array or a hash. If you access them directly, they aren't simple scalars and you need to give &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; a little help by placing the filehandle reference in braces. Perl can only figure it out on its own when the filehandle reference is a simple scalar.</source>
          <target state="translated">如果愿意，可以将这些文件句柄存储在数组或哈希中。如果直接访问它们，它们不是简单的标量，您需要通过将文件句柄引用放在花括号中来给 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 一点帮助。当文件句柄引用是简单的标量时，Perl只能自行解决。</target>
        </trans-unit>
        <trans-unit id="27d5798184dd1af5697105e7a8d7e3bef1780f00" translate="yes" xml:space="preserve">
          <source>If you like, you can store these filehandles in an array or a hash. If you access them directly, they aren't simple scalars and you need to give &lt;code&gt;print&lt;/code&gt; a little help by placing the filehandle reference in braces. Perl can only figure it out on its own when the filehandle reference is a simple scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d730d69794a1a0d8df4bc0eb2edfe8040f78af15" translate="yes" xml:space="preserve">
          <source>If you localize a special variable, you'll be giving a new value to it, but its magic won't go away. That means that all side-effects related to this magic still work with the localized value.</source>
          <target state="translated">如果你本地化一个特殊变量,你会给它一个新的值,但它的魔力不会消失。这意味着与这个魔法有关的所有副作用仍然会对这个本地化的值起作用。</target>
        </trans-unit>
        <trans-unit id="c90f343f24019c1da72c48d70c317941a7498b61" translate="yes" xml:space="preserve">
          <source>If you localize an exported variable in a module, its exported value will not change. The local name becomes an alias to a new value but the external name is still an alias for the original.</source>
          <target state="translated">如果您在一个模块中本地化了一个导出的变量,那么它的导出值不会改变。本地名称变成了一个新值的别名,但外部名称仍然是原始值的别名。</target>
        </trans-unit>
        <trans-unit id="dafcf35a82f601b489cfb5dd0eef86e45cb1372b" translate="yes" xml:space="preserve">
          <source>If you look at its source, you'll see that open2() uses low-level primitives like the pipe() and exec() syscalls to create all the connections. Although it might have been more efficient by using socketpair(), this would have been even less portable than it already is. The open2() and open3() functions are unlikely to work anywhere except on a Unix system, or at least one purporting POSIX compliance.</source>
          <target state="translated">如果你看一下它的源码,你会发现open2()使用了低级的基元,比如pipe()和exec()syscalls来创建所有的连接。虽然使用socketpair()可能会更有效率,但这将比现在的可移植性更差。open2()和open3()函数不可能在任何地方工作,除非是在Unix系统上,或者至少是在一个声称符合POSIX的系统上。</target>
        </trans-unit>
        <trans-unit id="dba57ac6d2e87e59b7cd30bc2efe7662859d4f78" translate="yes" xml:space="preserve">
          <source>If you look at the contents of a database file created by DB_File, there can sometimes be part of a Perl script included in it.</source>
          <target state="translated">如果你查看DB_File创建的数据库文件的内容,有时会有一部分Perl脚本包含在其中。</target>
        </trans-unit>
        <trans-unit id="9ffeef0f67f605dc88b0c1746d2c0bfb6febb326" translate="yes" xml:space="preserve">
          <source>If you make any changes that affect miniperl or core routines that have different code paths for miniperl, be sure to run &lt;code&gt;make minitest&lt;/code&gt;. This will catch problems that even the full test suite will not catch because it runs a subset of tests under miniperl rather than perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e077c0b0a12316fa45027aa958a68eefe5eb38b" translate="yes" xml:space="preserve">
          <source>If you make use of the Berkeley DB API, it is</source>
          <target state="translated">如果你使用Berkeley DB API,那么它就是</target>
        </trans-unit>
        <trans-unit id="044615c04770ac7a0002f5e8d4d8dd2908b76278" translate="yes" xml:space="preserve">
          <source>If you may assume POSIX (a rather large assumption), you may read more about the POSIX locale system from &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;. The locale system at least attempts to make things a little bit more portable, or at least more convenient and native-friendly for non-English users. The system affects character sets and encoding, and date and time formatting--amongst other things.</source>
          <target state="translated">如果您假设使用POSIX（相当大的假设），则可以从&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;阅读有关POSIX语言环境系统的更多信息。区域设置系统至少尝试使事情变得更便携一些，或者至少对于非英语用户来说更加方便和本机友好。该系统会影响字符集和编码以及日期和时间格式等。</target>
        </trans-unit>
        <trans-unit id="a25944da5356d5910252ea9238bbb196b425ee18" translate="yes" xml:space="preserve">
          <source>If you memoize &lt;code&gt;getusers&lt;/code&gt; here, it will work right exactly once. The reference to the users list will be stored in the memo table. &lt;code&gt;main&lt;/code&gt; will discard the first element from the referenced list. The next time you invoke &lt;code&gt;main&lt;/code&gt; , &lt;code&gt;Memoize&lt;/code&gt; will not call &lt;code&gt;getusers&lt;/code&gt; ; it will just return the same reference to the same list it got last time. But this time the list has already had its head removed; &lt;code&gt;main&lt;/code&gt; will erroneously remove another element from it. The list will get shorter and shorter every time you call &lt;code&gt;main&lt;/code&gt; .</source>
          <target state="translated">如果您在此处记住 &lt;code&gt;getusers&lt;/code&gt; ，它将只正确运行一次。对用户列表的引用将存储在备忘录表中。 &lt;code&gt;main&lt;/code&gt; 将丢弃引用列表中的第一个元素。下次调用 &lt;code&gt;main&lt;/code&gt; 时， &lt;code&gt;Memoize&lt;/code&gt; 将不会调用 &lt;code&gt;getusers&lt;/code&gt; ；它只会将相同的引用返回到上一次获得的相同列表。但是这次，名单已经被删除了。 &lt;code&gt;main&lt;/code&gt; 会错误地从其中删除另一个元素。每次您调用 &lt;code&gt;main&lt;/code&gt; 时，列表将越来越短。</target>
        </trans-unit>
        <trans-unit id="ccab2ece05cb5161b728c7c08be08148f8aa1e6f" translate="yes" xml:space="preserve">
          <source>If you memoize &lt;code&gt;getusers&lt;/code&gt; here, it will work right exactly once. The reference to the users list will be stored in the memo table. &lt;code&gt;main&lt;/code&gt; will discard the first element from the referenced list. The next time you invoke &lt;code&gt;main&lt;/code&gt;, &lt;code&gt;Memoize&lt;/code&gt; will not call &lt;code&gt;getusers&lt;/code&gt;; it will just return the same reference to the same list it got last time. But this time the list has already had its head removed; &lt;code&gt;main&lt;/code&gt; will erroneously remove another element from it. The list will get shorter and shorter every time you call &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdcd78cb5551e89b0a93e6ea03193603933b2916" translate="yes" xml:space="preserve">
          <source>If you must obtain a context in a sub deeper than your entry point you can use this to tell it how many EXTRA stack frames to look back. If this option is not provided the default of &lt;code&gt;0&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b7671e8edf51721ce7a662449c478e8b97bd95" translate="yes" xml:space="preserve">
          <source>If you need a copy of the string, see &lt;a href=&quot;#bytes_from_utf8&quot;&gt;&quot;bytes_from_utf8&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="babf77ebcd09b5b6b24f3181921a88c6ea58626a" translate="yes" xml:space="preserve">
          <source>If you need a copy of the string, see &lt;a href=&quot;#bytes_from_utf8&quot;&gt;bytes_from_utf8&lt;/a&gt;.</source>
          <target state="translated">如果需要字符串的副本，请参见&lt;a href=&quot;#bytes_from_utf8&quot;&gt;bytes_from_utf8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e5f94b7a22fe122cef06ac242e6fea05a7455fe1" translate="yes" xml:space="preserve">
          <source>If you need a notation that's that powerful, use normal Perl:</source>
          <target state="translated">如果你需要一个这么强大的符号,就用普通的Perl。</target>
        </trans-unit>
        <trans-unit id="d3c247b2226d86ce39340fe5128412de0478e397" translate="yes" xml:space="preserve">
          <source>If you need an empty attribute list, for example in a code generator, add a space before the &lt;code&gt;=&lt;/code&gt; .</source>
          <target state="translated">如果您需要一个空的属性列表（例如在代码生成器中），请在 &lt;code&gt;=&lt;/code&gt; 之前添加一个空格。</target>
        </trans-unit>
        <trans-unit id="9ec51b16d80aba23cb27eed2f37d008fc8bfa32a" translate="yes" xml:space="preserve">
          <source>If you need an empty attribute list, for example in a code generator, add a space before the &lt;code&gt;=&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df082bfa03c81e3a347168ac51e900439925f13" translate="yes" xml:space="preserve">
          <source>If you need both &lt;code&gt;next&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;, you have to do both and also use a loop label:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bff095055ae8196964fe851c387b6ea9ca66a7f" translate="yes" xml:space="preserve">
          <source>If you need more advanced management of what runs in parallel vs in sequence, see the associated 'rules' documentation in &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; and &lt;a href=&quot;TAP::Parser::Scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;. If what's possible directly through &lt;code&gt;prove&lt;/code&gt; is not sufficient, you can write your own harness to access these features directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f75e54b3d41cd48a9f47dcdc6a65f36e63ccd0" translate="yes" xml:space="preserve">
          <source>If you need more advanced management of what runs in parallel vs in sequence, see the associated 'rules' documentation in &lt;a href=&quot;tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; and &lt;a href=&quot;tap/parser/scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;. If what's possible directly through &lt;code&gt;prove&lt;/code&gt; is not sufficient, you can write your own harness to access these features directly.</source>
          <target state="translated">如果您需要对并行运行和顺序运行进行更高级的管理，请参阅&lt;a href=&quot;tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt;和&lt;a href=&quot;tap/parser/scheduler&quot;&gt;TAP :: Parser :: Scheduler中&lt;/a&gt;的相关&amp;ldquo;规则&amp;rdquo;文档。如果直接通过 &lt;code&gt;prove&lt;/code&gt; 功能还不够，您可以编写自己的工具来直接访问这些功能。</target>
        </trans-unit>
        <trans-unit id="bcc2262a79a5dbdf9359e3765fbc56f15e34b33f" translate="yes" xml:space="preserve">
          <source>If you need more fine-grained control over shared variable access, see &lt;a href=&quot;../thread/semaphore&quot;&gt;Thread::Semaphore&lt;/a&gt;.</source>
          <target state="translated">如果您需要对共享变量访问进行更细粒度的控制，请参见&lt;a href=&quot;../thread/semaphore&quot;&gt;Thread :: Semaphore&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64caf20ebddb6770dbd779252f4ceb1cec9300bf" translate="yes" xml:space="preserve">
          <source>If you need more fine-grained control over shared variable access, see &lt;a href=&quot;Thread::Semaphore&quot;&gt;Thread::Semaphore&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06a1402305f2d5c348929119dfbe7d1b16bea038" translate="yes" xml:space="preserve">
          <source>If you need more memory (larger data segment) for your Perl programs you can set:</source>
          <target state="translated">如果你的Perl程序需要更多的内存(更大的数据段),你可以设置。</target>
        </trans-unit>
        <trans-unit id="a733f66f7ebcddfc5bced382948b822560f8102b" translate="yes" xml:space="preserve">
          <source>If you need non-ASCII characters in your source code, make it a UTF-8 encoded file and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; .</source>
          <target state="translated">如果您的源代码中需要非ASCII字符，请使其成为UTF-8编码文件，然后 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0a3470b5eeb6f4646e842f332fe5e001c0f8638" translate="yes" xml:space="preserve">
          <source>If you need non-ASCII characters in your source code, make it a UTF-8 encoded file and &lt;code&gt;use utf8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2791275bc33103874a494cba3668a34d497a88" translate="yes" xml:space="preserve">
          <source>If you need not it (say, in the case when you need not handle any combining characters), assign &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; explicitly.</source>
          <target state="translated">如果不需要（例如，在不需要处理任何组合字符的情况下），则显式分配 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f59efc7843078cafcac070fa0d339e2add569c59" translate="yes" xml:space="preserve">
          <source>If you need not it (say, in the case when you need not handle any combining characters), assign &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt; explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c63ba89d54a209534c04c157c983b92a890aeb" translate="yes" xml:space="preserve">
          <source>If you need something like this functionality, it is recommended that use you a simple source filter, such as &lt;a href=&quot;Filter::Encoding&quot;&gt;Filter::Encoding&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d24eea4a069716d3cfb8ce322b04914e0b52151" translate="yes" xml:space="preserve">
          <source>If you need something like this functionality, you should use the &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; pragma, which is also deprecated, but has fewer nasty side effects.</source>
          <target state="translated">如果您需要类似此功能的内容，则应使用&lt;a href=&quot;encoding&quot;&gt;编码&lt;/a&gt;用法，该方法也已弃用，但副作用较少。</target>
        </trans-unit>
        <trans-unit id="988729c3d7bb2f3f6d6060c234bddde42b00f5a7" translate="yes" xml:space="preserve">
          <source>If you need something much more sophisticated and controllable, Leon Brocard's &lt;a href=&quot;Devel::ebug&quot;&gt;Devel::ebug&lt;/a&gt; (which you can call with the &lt;code&gt;-D&lt;/code&gt; switch as &lt;code&gt;-Debug&lt;/code&gt;) gives you the programmatic hooks into everything you need to write your own (without too much pain and suffering).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74399fe1ce7a1f4f506a06b60ded39ec27cea334" translate="yes" xml:space="preserve">
          <source>If you need something much more sophisticated and controllable, Leon Brocard's &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::ebug&quot;&gt;Devel::ebug&lt;/a&gt; (which you can call with the &lt;code&gt;-D&lt;/code&gt; switch as &lt;code&gt;-Debug&lt;/code&gt; ) gives you the programmatic hooks into everything you need to write your own (without too much pain and suffering).</source>
          <target state="translated">如果你需要一些更复杂的，可控的，莱昂Brocard的&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::ebug&quot;&gt;杰韦利:: ebug&lt;/a&gt;（可以与呼叫 &lt;code&gt;-D&lt;/code&gt; 交换机 &lt;code&gt;-Debug&lt;/code&gt; ）为您提供了纲领性钩到你需要将所有内容写你自己的（没有太多的痛苦和折磨）。</target>
        </trans-unit>
        <trans-unit id="77f3f2631a368e380813c177575d4bf78bb0f7fd" translate="yes" xml:space="preserve">
          <source>If you need the string representation of a character that doesn't have a mnemonic name in C, you should add it to the list in</source>
          <target state="translated">如果你需要一个在C语言中没有记忆名的字符的字符串表示,你应该在</target>
        </trans-unit>
        <trans-unit id="c2b8ba636abce4657c8c0f922660904cfc7228c1" translate="yes" xml:space="preserve">
          <source>If you need to be able to read a block which has an exact size, you can use the function &lt;code&gt;filter_read_exact&lt;/code&gt; . It works identically to &lt;code&gt;filter_read&lt;/code&gt; in block mode, except it will try to read a block which is exactly &lt;code&gt;$size&lt;/code&gt; bytes in length. The only circumstances when it will not return a block which is &lt;code&gt;$size&lt;/code&gt; bytes long is on EOF or error.</source>
          <target state="translated">如果您需要读取具有确切大小的块，则可以使用 &lt;code&gt;filter_read_exact&lt;/code&gt; 函数。它会与块模式下的 &lt;code&gt;filter_read&lt;/code&gt; 相同，除了它将尝试读取长度为 &lt;code&gt;$size&lt;/code&gt; 字节的块。它不会返回 &lt;code&gt;$size&lt;/code&gt; 为$ size个字节的块的唯一情况是在EOF或错误上。</target>
        </trans-unit>
        <trans-unit id="8c813a030a97b2b5bb47766e284a0379dde73e25" translate="yes" xml:space="preserve">
          <source>If you need to be able to read a block which has an exact size, you can use the function &lt;code&gt;filter_read_exact&lt;/code&gt;. It works identically to &lt;code&gt;filter_read&lt;/code&gt; in block mode, except it will try to read a block which is exactly &lt;code&gt;$size&lt;/code&gt; bytes in length. The only circumstances when it will not return a block which is &lt;code&gt;$size&lt;/code&gt; bytes long is on EOF or error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a6ebad8222234ffca6c9871e53dc4619a2ca40" translate="yes" xml:space="preserve">
          <source>If you need to bless or re-bless an object you can use the following function:</source>
          <target state="translated">如果您需要对一个对象进行祝福或重新祝福,您可以使用以下功能。</target>
        </trans-unit>
        <trans-unit id="ac05679aaf52c29544dd930529212ccf723e35df" translate="yes" xml:space="preserve">
          <source>If you need to compare version numbers, but can't be sure whether they are expressed as numbers, strings, v-strings or version objects, then you should use version.pm to parse them all into objects for comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a20b3786b554786904a5b1cfd2ed611798a9441" translate="yes" xml:space="preserve">
          <source>If you need to customize the objects on creation, subclass &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_grammar&quot;&gt;&quot;make_grammar&quot;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8826419639cfccd71d1ef977c6d4164c1055d8a9" translate="yes" xml:space="preserve">
          <source>If you need to customize the objects on creation, subclass &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_result&quot;&gt;&quot;make_result&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70c6e2df233bb6ffd0181bcff94f18d3b389825" translate="yes" xml:space="preserve">
          <source>If you need to customize the objects on creation, subclass &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_grammar&quot;&gt;make_grammar&lt;/a&gt;</source>
          <target state="translated">如果需要在创建时自定义对象，请子类&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;并覆盖&lt;a href=&quot;#make_grammar&quot;&gt;make_grammar&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="28d9937fb82713ba1f2c783a5af6bd5ed96f1469" translate="yes" xml:space="preserve">
          <source>If you need to customize the objects on creation, subclass &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_result&quot;&gt;make_result&lt;/a&gt;.</source>
          <target state="translated">如果需要在创建时自定义对象，请子类&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;并覆盖&lt;a href=&quot;#make_result&quot;&gt;make_result&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9bf36336c456165d1f557c63d917cf367e24c8a2" translate="yes" xml:space="preserve">
          <source>If you need to distinguish between endian architectures you could use either of the variables set like so:</source>
          <target state="translated">如果你需要区分endian架构,你可以使用像这样设置的任一变量。</target>
        </trans-unit>
        <trans-unit id="74fb9c00d6d39f0efb84e3bc0ddfd5cbf2ea27a0" translate="yes" xml:space="preserve">
          <source>If you need to do something more complicated, the &lt;a href=&quot;HTTP::Tiny&quot;&gt;HTTP::Tiny&lt;/a&gt; object can be customized by setting attributes, or you can use &lt;a href=&quot;LWP::UserAgent&quot;&gt;LWP::UserAgent&lt;/a&gt; from the libwww-perl distribution or &lt;a href=&quot;Mojo::UserAgent&quot;&gt;Mojo::UserAgent&lt;/a&gt; from the Mojolicious distribution to make common tasks easier. If you want to simulate an interactive web browser, you can use the &lt;a href=&quot;WWW::Mechanize&quot;&gt;WWW::Mechanize&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c8b4493aa37d00a1808e45469530aac89fd5c8" translate="yes" xml:space="preserve">
          <source>If you need to do something more complicated, you can use &lt;a href=&quot;http://search.cpan.org/perldoc/LWP::UserAgent&quot;&gt;LWP::UserAgent&lt;/a&gt; module to create your own user-agent (e.g. browser) to get the job done. If you want to simulate an interactive web browser, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW::Mechanize&lt;/a&gt; module.</source>
          <target state="translated">如果您需要做一些更复杂的事情，可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/LWP::UserAgent&quot;&gt;LWP :: UserAgent&lt;/a&gt;模块创建自己的用户代理（例如浏览器）来完成工作。如果要模拟交互式Web浏览器，则可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW :: Mechanize&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="a7852e983dc45b1c4fb37cf3f05367219e6ca843" translate="yes" xml:space="preserve">
          <source>If you need to do this check often, define your own macro like this:</source>
          <target state="translated">如果你需要经常做这个检查,可以像这样定义自己的宏。</target>
        </trans-unit>
        <trans-unit id="6466ffd2aaaebc3946b351828c459bde58bed891" translate="yes" xml:space="preserve">
          <source>If you need to include C code or C library interfaces use h2xs. h2xs will create the module distribution structure and the initial interface files. &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; explain the details.</source>
          <target state="translated">如果需要包括C代码或C库接口，请使用h2xs。h2xs将创建模块分发结构和初始接口文件。&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;和&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;解释了细节。</target>
        </trans-unit>
        <trans-unit id="132d01927536564513220be940287f0a7e0711cd" translate="yes" xml:space="preserve">
          <source>If you need to make sure your diagnostics are displayed in the correct order relative to test results you can use the &lt;code&gt;--merge&lt;/code&gt; option to merge the test scripts' STDERR into their STDOUT.</source>
          <target state="translated">如果需要确保诊断以相对于测试结果的正确顺序显示，则可以使用 &lt;code&gt;--merge&lt;/code&gt; 选项将测试脚本的STDERR合并到其STDOUT中。</target>
        </trans-unit>
        <trans-unit id="f121bbe2a75e4529feda5970b07f0e59291a1000" translate="yes" xml:space="preserve">
          <source>If you need to pad with a character other than blank or zero you can use one of the following methods. They all generate a pad string with the &lt;code&gt;x&lt;/code&gt; operator and combine that with &lt;code&gt;$text&lt;/code&gt; . These methods do not truncate &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">如果您需要使用非空白或零以外的字符进行填充，则可以使用以下方法之一。它们都使用 &lt;code&gt;x&lt;/code&gt; 运算符生成一个填充字符串，并将其与 &lt;code&gt;$text&lt;/code&gt; 结合在一起。这些方法不会截断 &lt;code&gt;$text&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="281d15e2e9e38bc2d44d9e73a83267de2350b440" translate="yes" xml:space="preserve">
          <source>If you need to pad with a character other than blank or zero you can use one of the following methods. They all generate a pad string with the &lt;code&gt;x&lt;/code&gt; operator and combine that with &lt;code&gt;$text&lt;/code&gt;. These methods do not truncate &lt;code&gt;$text&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed2c6c4464c8d7cdb6c519c251d4778b6623f9b" translate="yes" xml:space="preserve">
          <source>If you need to pass the handle to something that expects a filename then on a unix system you can use &lt;code&gt;&quot;/dev/fd/&quot; . fileno($fh)&lt;/code&gt; for arbitrary programs. Perl code that uses the 2-argument version of &lt;code&gt;open&lt;/code&gt; can be passed &lt;code&gt;&quot;+&amp;lt;=&amp;amp;&quot; . fileno($fh)&lt;/code&gt;. Otherwise you will need to pass the filename. You will have to clear the close-on-exec bit on that file descriptor before passing it to another process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5db19b81a16545df9a2691c134fe238aff01db6b" translate="yes" xml:space="preserve">
          <source>If you need to pass the handle to something that expects a filename then on a unix system you can use C for arbitrary programs. Perl code that uses the 2-argument version of C&amp;lt;&amp;lt; open &amp;gt;&amp;gt; can be passed C&amp;lt;&amp;lt; &quot;+&amp;lt;=&amp;amp;&quot; . fileno($fh) &amp;gt;&amp;gt;. Otherwise you will need to pass the filename. You will have to clear the close-on-exec bit on that file descriptor before passing it to another process.</source>
          <target state="translated">如果需要将句柄传递给需要文件名的内容，则在Unix系统上，可以将C用于任意程序。可以将使用C &amp;lt;&amp;lt; open &amp;gt;&amp;gt;的2参数版本的Perl代码传递给C &amp;lt;&amp;lt;&amp;ldquo; + &amp;lt;=＆&amp;rdquo;。fileno（$ fh）&amp;gt;&amp;gt;。否则，您将需要传递文件名。您必须先清除该文件描述符上的close-on-exec位，然后再将其传递给另一个进程。</target>
        </trans-unit>
        <trans-unit id="a1479a86a7c4f92b2a893038ca84d0e7634155ed" translate="yes" xml:space="preserve">
          <source>If you need to perform any preprocessing of input before it is parsed you may want to override one or more of &lt;b&gt;preprocess_line()&lt;/b&gt; and/or &lt;b&gt;preprocess_paragraph()&lt;/b&gt;.</source>
          <target state="translated">如果您需要在解析输入之前执行任何预处理，则可能需要覆盖&lt;b&gt;preprocess_line（）&lt;/b&gt;和/或&lt;b&gt;preprocess_paragraph（）中的&lt;/b&gt;一个或多个。</target>
        </trans-unit>
        <trans-unit id="6fb6f27c51e4262718886f54bfa50ac616a6eb28" translate="yes" xml:space="preserve">
          <source>If you need to push multiple different values then you should either use the &lt;code&gt;(X)PUSHs&lt;/code&gt; macros, or else use the new &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; macros, none of which make use of &lt;code&gt;TARG&lt;/code&gt; . The &lt;code&gt;(X)PUSHs&lt;/code&gt; macros simply push an SV* on the stack, which, as noted under &lt;a href=&quot;#XSUBs-and-the-Argument-Stack&quot;&gt;XSUBs and the Argument Stack&lt;/a&gt;, will often need to be &quot;mortal&quot;. The new &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; macros make this a little easier to achieve by creating a new mortal for you (via &lt;code&gt;(X)PUSHmortal&lt;/code&gt;), pushing that onto the stack (extending it if necessary in the case of the &lt;code&gt;mXPUSH[iunp]&lt;/code&gt; macros), and then setting its value. Thus, instead of writing this to &quot;fix&quot; the example above:</source>
          <target state="translated">如果需要推入多个不同的值，则应该使用 &lt;code&gt;(X)PUSHs&lt;/code&gt; 宏，或者使用新的 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; 宏，这些宏都不使用 &lt;code&gt;TARG&lt;/code&gt; 。该 &lt;code&gt;(X)PUSHs&lt;/code&gt; 宏只需按下一个SV *栈，这下作为注意到&lt;a href=&quot;#XSUBs-and-the-Argument-Stack&quot;&gt;XSUBs和参数堆栈&lt;/a&gt;，将经常需要&amp;ldquo;凡间&amp;rdquo;。新的 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; 宏通过（通过 &lt;code&gt;(X)PUSHmortal&lt;/code&gt; ）为您创建一个新的凡人，将其推入堆栈（如果需要，在 &lt;code&gt;mXPUSH[iunp]&lt;/code&gt; 扩展，可以扩展），从而使实现起来更加容易iunp]宏），然后设置其值。因此，不是将其编写为&amp;ldquo;修复&amp;rdquo;上面的示例：</target>
        </trans-unit>
        <trans-unit id="dcfff33a227c9b4b0446369038ec69edba6230b7" translate="yes" xml:space="preserve">
          <source>If you need to push multiple different values then you should either use the &lt;code&gt;(X)PUSHs&lt;/code&gt; macros, or else use the new &lt;code&gt;m(X)PUSH[iunp]&lt;/code&gt; macros, none of which make use of &lt;code&gt;TARG&lt;/code&gt;. The &lt;code&gt;(X)PUSHs&lt;/code&gt; macros simply push an SV* on the stack, which, as noted under &lt;a href=&quot;#XSUBs-and-the-Argument-Stack&quot;&gt;&quot;XSUBs and the Argument Stack&quot;&lt;/a&gt;, will often need to be &quot;mortal&quot;. The new &lt;code&gt;m(X)PUSH[iunp]&lt;/code&gt; macros make this a little easier to achieve by creating a new mortal for you (via &lt;code&gt;(X)PUSHmortal&lt;/code&gt;), pushing that onto the stack (extending it if necessary in the case of the &lt;code&gt;mXPUSH[iunp]&lt;/code&gt; macros), and then setting its value. Thus, instead of writing this to &quot;fix&quot; the example above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f2c24c8a5106b97dd605e7836d7f3b3f6f05f0c" translate="yes" xml:space="preserve">
          <source>If you need to run code under taint mode, updating to the latest &lt;a href=&quot;File::Spec&quot;&gt;File::Spec&lt;/a&gt; is highly recommended. On Windows, if the directory given by &lt;a href=&quot;File::Spec::tmpdir&quot;&gt;File::Spec::tmpdir&lt;/a&gt; isn't writable, File::Temp will attempt to fallback to the user's local application data directory or croak with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45e0c901cd619f7527093c4d9dc59b922de91c4" translate="yes" xml:space="preserve">
          <source>If you need to run code under taint mode, updating to the latest L&amp;lt;:spec&amp;gt; is highly recommended.</source>
          <target state="translated">如果需要在污点模式下运行代码，强烈建议更新为最新的L &amp;lt;：spec&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="0a26debdab35f4d9006770f7ff9dd97352bd60fc" translate="yes" xml:space="preserve">
          <source>If you need to set the encoding for STDIN, STDOUT, and STDERR, for example based on the user's locale, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">例如，如果需要基于用户的语言环境设置STDIN，STDOUT和STDERR的编码，请 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="870260c0c362207468a98bb8f507e2cc87fb2a13" translate="yes" xml:space="preserve">
          <source>If you need to set the encoding for STDIN, STDOUT, and STDERR, for example based on the user's locale, &lt;code&gt;use open&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d6ae28c61f9ab4be958ec28b43ea876d12f0ac" translate="yes" xml:space="preserve">
          <source>If you need to sort on several fields, the following paradigm is useful.</source>
          <target state="translated">如果你需要对多个字段进行排序,下面的范式是有用的。</target>
        </trans-unit>
        <trans-unit id="f3d49b98b395f07c8fa5d476950e74044c830e9d" translate="yes" xml:space="preserve">
          <source>If you need to test whether a version object has been initialized, you can simply test it directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb30e833a46ba05085b508093073afbb52be3c6" translate="yes" xml:space="preserve">
          <source>If you need to use</source>
          <target state="translated">如果您需要使用</target>
        </trans-unit>
        <trans-unit id="dd52c7b44ac55aa77cc0e377ad21781b36b65218" translate="yes" xml:space="preserve">
          <source>If you need to use Perl in the ILE environment, you may want to consider using Qp2RunPase() to call the PASE version of Perl.</source>
          <target state="translated">如果你需要在ILE环境中使用Perl,你可以考虑使用Qp2RunPase()来调用Perl的PASE版本。</target>
        </trans-unit>
        <trans-unit id="b4808d5e77c37aaf035853f43eef1fd731c05497" translate="yes" xml:space="preserve">
          <source>If you need to, your program can pass parameters to the subroutine as part of the thread startup. Just include the list of parameters as part of the &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; call, like this:</source>
          <target state="translated">如果需要，您的程序可以在线程启动过程中将参数传递给子例程。只需将参数列表包含在 &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; 调用中即可，如下所示：</target>
        </trans-unit>
        <trans-unit id="1710a33b911c663eb696834835df2f1e23df21c3" translate="yes" xml:space="preserve">
          <source>If you needed to know the length of the string in bytes, now's the perfect time for that. Because &lt;code&gt;$body&lt;/code&gt; is now a byte string, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; will report the number of bytes, instead of the number of characters. The number of characters is no longer known, because characters only exist in text strings.</source>
          <target state="translated">如果您需要知道字符串的长度（以字节为单位），那么现在是最佳时机。因为 &lt;code&gt;$body&lt;/code&gt; 现在是一个字节字符串，所以 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 将报告字节数，而不是字符数。字符数不再已知，因为字符仅存在于文本字符串中。</target>
        </trans-unit>
        <trans-unit id="f897865d444575124f537cfaf9274fd31883caca" translate="yes" xml:space="preserve">
          <source>If you needed to know the length of the string in bytes, now's the perfect time for that. Because &lt;code&gt;$body&lt;/code&gt; is now a byte string, &lt;code&gt;length&lt;/code&gt; will report the number of bytes, instead of the number of characters. The number of characters is no longer known, because characters only exist in text strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be13b7e49abdf9671c1c203318c86c5b390da880" translate="yes" xml:space="preserve">
          <source>If you now say</source>
          <target state="translated">如果你现在说</target>
        </trans-unit>
        <trans-unit id="4e07afe42e8e4906b74c8de7f97562b41c673c72" translate="yes" xml:space="preserve">
          <source>If you only have to do this once, you can print individually to each filehandle.</source>
          <target state="translated">如果您只需要做一次,您可以分别打印到每个文件柄。</target>
        </trans-unit>
        <trans-unit id="4fedbe813a9df1931afb6723a023d133df40e372" translate="yes" xml:space="preserve">
          <source>If you only want to cancel some uncommitted edits, you can use &lt;code&gt;git checkout&lt;/code&gt; and give it a list of files to be reverted, or &lt;code&gt;git checkout -f&lt;/code&gt; to revert them all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a207a0fbb92e170fc7384b498a52e214bc5156" translate="yes" xml:space="preserve">
          <source>If you open a pipe on the command &lt;code&gt;-&lt;/code&gt; (that is, specify either &lt;code&gt;|-&lt;/code&gt; or &lt;code&gt;-|&lt;/code&gt; with the one- or two-argument forms of &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;), an implicit &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; is done, so &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; returns twice: in the parent process it returns the pid of the child process, and in the child process it returns (a defined) &lt;code&gt;0&lt;/code&gt;. Use &lt;code&gt;defined($pid)&lt;/code&gt; or &lt;code&gt;//&lt;/code&gt; to determine whether the open was successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef4f1155d60201a5a642377c105def023a28c8a3" translate="yes" xml:space="preserve">
          <source>If you open a pipe on the command &lt;code&gt;-&lt;/code&gt; (that is, specify either &lt;code&gt;|-&lt;/code&gt; or &lt;code&gt;-|&lt;/code&gt; with the one- or two-argument forms of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;), an implicit &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is done, so &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; returns twice: in the parent process it returns the pid of the child process, and in the child process it returns (a defined) &lt;code&gt;0&lt;/code&gt; . Use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;//&lt;/code&gt; to determine whether the open was successful.</source>
          <target state="translated">如果您在命令打开一个管道 &lt;code&gt;-&lt;/code&gt; （即中，指定 &lt;code&gt;|-&lt;/code&gt; 或者 &lt;code&gt;-|&lt;/code&gt; 用的一个或两个参数的形式 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ），一个隐含的 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 完成，所以 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 的回报两次：在父进程返回子进程的pid，并在子进程中返回（已定义） &lt;code&gt;0&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;//&lt;/code&gt; 确定打开是否成功。</target>
        </trans-unit>
        <trans-unit id="3ae4797a620c0cf454989f9d7b82f21950740479" translate="yes" xml:space="preserve">
          <source>If you open a pipe on the command &lt;code&gt;-&lt;/code&gt; (that is, specify either &lt;code&gt;|-&lt;/code&gt; or &lt;code&gt;-|&lt;/code&gt; with the one- or two-argument forms of &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;), an implicit &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is done, so &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; returns twice: in the parent process it returns the pid of the child process, and in the child process it returns (a defined) &lt;code&gt;0&lt;/code&gt; . Use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;//&lt;/code&gt; to determine whether the open was successful.</source>
          <target state="translated">如果您在命令打开一个管道 &lt;code&gt;-&lt;/code&gt; （即中，指定 &lt;code&gt;|-&lt;/code&gt; 或者 &lt;code&gt;-|&lt;/code&gt; 用的一个或两个参数的形式 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ），一个隐含的 &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 完成，所以 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 的回报两次：在父进程返回子进程的pid，并在子进程中返回（已定义） &lt;code&gt;0&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;//&lt;/code&gt; 确定打开是否成功。</target>
        </trans-unit>
        <trans-unit id="b60263df2e1568250aacc0155390b54bbc574b26" translate="yes" xml:space="preserve">
          <source>If you opted to uncomment &lt;code&gt;INST_VER&lt;/code&gt; and &lt;code&gt;INST_ARCH&lt;/code&gt; in the makefile then the installation structure is a little more complicated and you will need to add two new PATH components instead: &lt;code&gt;$INST_TOP\$INST_VER\bin&lt;/code&gt; and &lt;code&gt;$INST_TOP\$INST_VER\bin\$ARCHNAME&lt;/code&gt; , e.g.</source>
          <target state="translated">如果选择在makefile中取消注释 &lt;code&gt;INST_VER&lt;/code&gt; 和 &lt;code&gt;INST_ARCH&lt;/code&gt; ，则安装结构会稍微复杂一些，您需要添加两个新的PATH组件： &lt;code&gt;$INST_TOP\$INST_VER\bin&lt;/code&gt; 和 &lt;code&gt;$INST_TOP\$INST_VER\bin\$ARCHNAME&lt;/code&gt; ，例如</target>
        </trans-unit>
        <trans-unit id="bad570e796041b2f5592838887a3faca1802a117" translate="yes" xml:space="preserve">
          <source>If you opted to uncomment &lt;code&gt;INST_VER&lt;/code&gt; and &lt;code&gt;INST_ARCH&lt;/code&gt; in the makefile then the installation structure is a little more complicated and you will need to add two new PATH components instead: &lt;code&gt;$INST_TOP\$INST_VER\bin&lt;/code&gt; and &lt;code&gt;$INST_TOP\$INST_VER\bin\$ARCHNAME&lt;/code&gt;, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3281995d9866c6fc2125672694920f44e26bcb98" translate="yes" xml:space="preserve">
          <source>If you override this method, it should never throw an exception.</source>
          <target state="translated">如果你覆盖了这个方法,它应该永远不会抛出异常。</target>
        </trans-unit>
        <trans-unit id="a202baf38183d44995c2fcf3449035cd37813ae8" translate="yes" xml:space="preserve">
          <source>If you pass a perl version you get the release date for that version only.</source>
          <target state="translated">如果你通过一个perl版本,你只得到该版本的发布日期。</target>
        </trans-unit>
        <trans-unit id="d2654ab11aa24c5cd7986448b88f2571bec7a12a" translate="yes" xml:space="preserve">
          <source>If you pass a port number to Net::FTP then it assumes this is the port number of the final destination. By default Net::FTP will always try to connect to the firewall on port 21.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1538bf7a76ecb948f65bf6e3cd597e0fef6beddd" translate="yes" xml:space="preserve">
          <source>If you pass a version argument (value of &lt;code&gt;$]&lt;/code&gt; , like &lt;code&gt;5.00503&lt;/code&gt; or &lt;code&gt;5.008008&lt;/code&gt; ), you get a list of all the modules and their respective versions. (If you have the &lt;code&gt;version&lt;/code&gt; module, you can also use new-style version numbers, like &lt;code&gt;5.8.8&lt;/code&gt; .)</source>
          <target state="translated">如果传递版本参数（值 &lt;code&gt;$]&lt;/code&gt; ，如 &lt;code&gt;5.00503&lt;/code&gt; 或 &lt;code&gt;5.008008&lt;/code&gt; ，则将获得所有模块及其各自版本的列表。（如果您具有 &lt;code&gt;version&lt;/code&gt; 模块，则还可以使用新的版本号，例如 &lt;code&gt;5.8.8&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="7bc630f7bd97f46ece9c6618008aa09db386949e" translate="yes" xml:space="preserve">
          <source>If you pass a version argument (value of &lt;code&gt;$]&lt;/code&gt;, like &lt;code&gt;5.00503&lt;/code&gt; or &lt;code&gt;5.008008&lt;/code&gt;), you get a list of all the modules and their respective versions. (If you have the &lt;code&gt;version&lt;/code&gt; module, you can also use new-style version numbers, like &lt;code&gt;5.8.8&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93bac64f7444e2412e1719cee4ee931ff2c82b7b" translate="yes" xml:space="preserve">
          <source>If you pass the &lt;code&gt;-q&lt;/code&gt; option to the module, then the STDOUT filehandle will be redirected into the variable &lt;code&gt;$O::BEGIN_output&lt;/code&gt; during compilation. This has the effect that any output printed to STDOUT by BEGIN blocks or use'd modules will be stored in this variable rather than printed. It's useful with those backends which produce output themselves (&lt;code&gt;Deparse&lt;/code&gt; , &lt;code&gt;Concise&lt;/code&gt; etc), so that their output is not confused with that generated by the code being compiled.</source>
          <target state="translated">如果将 &lt;code&gt;-q&lt;/code&gt; 选项传递给模块，则STDOUT文件句柄将在编译期间重定向到变量 &lt;code&gt;$O::BEGIN_output&lt;/code&gt; 中。这样的结果是，任何由BEGIN块或使用的模块打印到STDOUT的输出都将存储在此变量中，而不是打印出来。对于那些自己产生输出的后端（ &lt;code&gt;Deparse&lt;/code&gt; ， &lt;code&gt;Concise&lt;/code&gt; 等）很有用，这样它们的输出就不会与正在编译的代码所产生的输出相混淆。</target>
        </trans-unit>
        <trans-unit id="2b02265881df71310516615b75c10b272c997131" translate="yes" xml:space="preserve">
          <source>If you pass the &lt;code&gt;-q&lt;/code&gt; option to the module, then the STDOUT filehandle will be redirected into the variable &lt;code&gt;$O::BEGIN_output&lt;/code&gt; during compilation. This has the effect that any output printed to STDOUT by BEGIN blocks or use'd modules will be stored in this variable rather than printed. It's useful with those backends which produce output themselves (&lt;code&gt;Deparse&lt;/code&gt;, &lt;code&gt;Concise&lt;/code&gt; etc), so that their output is not confused with that generated by the code being compiled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6ebb2e5d7084d0bbbc51b71dbc71d3b131a896" translate="yes" xml:space="preserve">
          <source>If you perform a new installation, then (a newer) Perl will be installed automatically. Pre-installed HP-UX systems now have more recent versions of Perl and the updated modules.</source>
          <target state="translated">如果你进行新的安装,那么(较新的)Perl将被自动安装。预装的HP-UX系统现在有较新版本的Perl和更新的模块。</target>
        </trans-unit>
        <trans-unit id="3e9cb6c101da46aadecf5f8c5c109de4412a1005" translate="yes" xml:space="preserve">
          <source>If you pick the right test function, you'll usually get a good idea of what went wrong when it failed. But sometimes it doesn't work out that way. So here we have ways for you to write your own diagnostic messages which are safer than just &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; STDERR&lt;/code&gt; .</source>
          <target state="translated">如果选择正确的测试功能，通常会很好地了解失败的地方。但是有时候，这种方式行不通。因此，在这里我们有多种方法可以让您编写自己的诊断消息，而不仅仅是 &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; STDERR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bdb193abf588e1053390563380a45f43172b81e" translate="yes" xml:space="preserve">
          <source>If you pick the right test function, you'll usually get a good idea of what went wrong when it failed. But sometimes it doesn't work out that way. So here we have ways for you to write your own diagnostic messages which are safer than just &lt;code&gt;print STDERR&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f8c3042df990d0caf7e15fec6410a8229928ec" translate="yes" xml:space="preserve">
          <source>If you plan on doing serious C hacking, make sure to read this.</source>
          <target state="translated">如果你打算做严肃的C语言黑客,一定要阅读这个。</target>
        </trans-unit>
        <trans-unit id="81013dc1ad1ba24b43d69b63d40b9239df928ef7" translate="yes" xml:space="preserve">
          <source>If you plan to link Perl to any module that requires thread-support, like DBD::Oracle, it is better to use the _r version of the compiler. This will not build a threaded Perl, but a thread-enabled Perl. See also &lt;a href=&quot;#Threaded-Perl&quot;&gt;&quot;Threaded Perl&quot;&lt;/a&gt; later on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea674be45f6eda0998926e34d1adb1941baadfc8" translate="yes" xml:space="preserve">
          <source>If you plan to link Perl to any module that requires thread-support, like DBD::Oracle, it is better to use the _r version of the compiler. This will not build a threaded Perl, but a thread-enabled Perl. See also &lt;a href=&quot;#Threaded-Perl&quot;&gt;Threaded Perl&lt;/a&gt; later on.</source>
          <target state="translated">如果您打算将Perl链接到任何需要线程支持的模块，例如DBD :: Oracle，最好使用_r版本的编译器。这将不会构建线程化的Perl，而是构建启用线程的Perl。稍后也请参见&lt;a href=&quot;#Threaded-Perl&quot;&gt;Threaded Perl&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3ae83db0cc3f44bcbcecf136bd4e7799904f67e" translate="yes" xml:space="preserve">
          <source>If you prefer &quot;regex&quot; over &quot;regexp&quot; in this tutorial, you could use the following program to replace it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a59862b4b635be40786928d6e580b97f5fccb229" translate="yes" xml:space="preserve">
          <source>If you prefer 'regex' over 'regexp' in this tutorial, you could use the following program to replace it:</source>
          <target state="translated">如果你在本教程中喜欢 &quot;regex &quot;而不是 &quot;regexp&quot;,你可以用下面的程序来代替它。</target>
        </trans-unit>
        <trans-unit id="e975a86edf7cf3f2a85267ea19c5e7fb97348443" translate="yes" xml:space="preserve">
          <source>If you prefer &lt;code&gt;CPANPLUS&lt;/code&gt; , it's just as easy:</source>
          <target state="translated">如果您更喜欢 &lt;code&gt;CPANPLUS&lt;/code&gt; ，那就很简单：</target>
        </trans-unit>
        <trans-unit id="7a50be93857181d27ad3f82440855d08d5614eb6" translate="yes" xml:space="preserve">
          <source>If you prefer &lt;code&gt;CPANPLUS&lt;/code&gt;, it's just as easy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b2286238e8c1ea0536c07d5d33ab84bc86bbaa" translate="yes" xml:space="preserve">
          <source>If you prefer not to import these routines into your namespace, you can call them as:</source>
          <target state="translated">如果你不想把这些例程导入到你的命名空间,你可以把它们调用为。</target>
        </trans-unit>
        <trans-unit id="02b429d0fbb0524681e65be7d6f8ab7830a0723a" translate="yes" xml:space="preserve">
          <source>If you prefer something more legible, use the File::stat module (part of the standard distribution in version 5.004 and later):</source>
          <target state="translated">如果你喜欢更清晰的东西,可以使用File::stat模块(5.004和更高版本的标准发行版的一部分)。</target>
        </trans-unit>
        <trans-unit id="f0813e4f27c28bf6e883076eecebd37913fd5b51" translate="yes" xml:space="preserve">
          <source>If you prefer to do it more in a programmerish style in one single process, something like this may better suit you:</source>
          <target state="translated">如果你更喜欢以程序员的风格在一个过程中完成,这样的东西可能更适合你。</target>
        </trans-unit>
        <trans-unit id="ec90d5c6994006bb5fd89f190c78b5cdc340ee30" translate="yes" xml:space="preserve">
          <source>If you prefer to run your program first and look at its problem afterwards, do this:</source>
          <target state="translated">如果你喜欢先运行程序,然后再看它的问题,可以这样做。</target>
        </trans-unit>
        <trans-unit id="aacba9db61987e99507860e0fb4bb65d12a9bd0f" translate="yes" xml:space="preserve">
          <source>If you prefer to use colour as a means of finding tricky whitespace characters then you can set the &lt;code&gt;TESTTESTCOLOUR&lt;/code&gt; environment variable to a comma separated pair of colours, the first for the foreground, the second for the background. For example &quot;white,red&quot; will print white text on a red background. This requires the Term::ANSIColor module. You can specify any colour that would be acceptable to the Term::ANSIColor::color function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3870b14accf24c65cf812dc3594ebf250f4f78e6" translate="yes" xml:space="preserve">
          <source>If you properly encode your strings for output, none of this is of your concern, and you can just &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; dumped data as always.</source>
          <target state="translated">如果您对输出的字符串进行了适当的编码，那么您就 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 担心这些了，您可以像往常一样评估转储的数据。</target>
        </trans-unit>
        <trans-unit id="e766f156c26878a70aac60fe8090c0a4f6df2f3f" translate="yes" xml:space="preserve">
          <source>If you properly encode your strings for output, none of this is of your concern, and you can just &lt;code&gt;eval&lt;/code&gt; dumped data as always.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="065fd2bf37d0cb46e6971e495f8f9b0d94012ccb" translate="yes" xml:space="preserve">
          <source>If you provide a $name, that will be printed along with the &quot;ok/not ok&quot; to make it easier to find your test when if fails (just search for the name). It also makes it easier for the next guy to understand what your test is for. It's highly recommended you use test names.</source>
          <target state="translated">如果你提供了一个$name,那就会和 &quot;ok/not ok &quot;一起打印出来,以便在失败的时候更容易找到你的测试(只要搜索这个名字)。这也让下一个人更容易理解你的测试是为了什么。强烈建议你使用测试名称。</target>
        </trans-unit>
        <trans-unit id="b7880cf2049cee53a05bb2b9ece1c4d6f2c66f65" translate="yes" xml:space="preserve">
          <source>If you put a &lt;code&gt;\&lt;/code&gt; in front of a variable, you get a reference to that variable.</source>
          <target state="translated">如果在变量前面加上 &lt;code&gt;\&lt;/code&gt; ，则会得到对该变量的引用。</target>
        </trans-unit>
        <trans-unit id="34b57973357474bb06b6216c6a1396c52f47b8be" translate="yes" xml:space="preserve">
          <source>If you put extensions in unusual places, you can set PERL5LIB to a list of paths separated by semicolons where you want perl to look for libraries. Look for descriptions of other environment variables you can set in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">如果将扩展名放在不寻常的位置，则可以将PERL5LIB设置为由分号分隔的路径列表，在该路径中您希望perl查找库。查找可以在&lt;a href=&quot;perlrun&quot;&gt;perlrun中&lt;/a&gt;设置的其他环境变量的描述。</target>
        </trans-unit>
        <trans-unit id="4498166e1dac5738a547d2b9e86da7f11d00c4e8" translate="yes" xml:space="preserve">
          <source>If you put two contiguous tilde characters &quot;~~&quot; anywhere into a line, the line will be repeated until all the fields on the line are exhausted, i.e. undefined. For special (caret) text fields this will occur sooner or later, but if you use a text field of the at variety, the expression you supply had better not give the same value every time forever! (&lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@f)&lt;/a&gt;&lt;/code&gt; is a simple example that would work.) Don't use a regular (at) numeric field in such lines, because it will never go blank.</source>
          <target state="translated">如果将两个连续的波浪号&amp;ldquo; ~~&amp;rdquo;放置在一行中的任何位置，则该行将重复进行，直到该行上的所有字段都用尽，即未定义。对于特殊的（插入符号）文本字段，迟早会出现这种情况，但是如果您使用at变体的文本字段，则提供的表达式最好不要每次都给出相同的值！（ &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@f)&lt;/a&gt;&lt;/code&gt; 是一个简单的示例，可以使用。）不要在此类行中使用常规的（at）数字字段，因为它永远不会为空。</target>
        </trans-unit>
        <trans-unit id="5c6b6a167ca19e1425e3b4fcf8a618d7dce2d0b2" translate="yes" xml:space="preserve">
          <source>If you put two contiguous tilde characters &quot;~~&quot; anywhere into a line, the line will be repeated until all the fields on the line are exhausted, i.e. undefined. For special (caret) text fields this will occur sooner or later, but if you use a text field of the at variety, the expression you supply had better not give the same value every time forever! (&lt;code&gt;shift(@f)&lt;/code&gt; is a simple example that would work.) Don't use a regular (at) numeric field in such lines, because it will never go blank.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="131e6f1801bde966ebc62c17a25904f6f6c22132" translate="yes" xml:space="preserve">
          <source>If you re-run &lt;code&gt;git status&lt;/code&gt;, you should see something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6608312c76270dd048459022213c207db61db43" translate="yes" xml:space="preserve">
          <source>If you really do mean it, explicitly numify your reference, like so: &lt;code&gt;$array[0+$ref]&lt;/code&gt; . This warning is not given for overloaded objects, however, because you can overload the numification and stringification operators and then you presumably know what you are doing.</source>
          <target state="translated">如果确实如此，请显式地将您的引用数字化，例如： &lt;code&gt;$array[0+$ref]&lt;/code&gt; 。但是，不会为重载对象发出此警告，因为您可以重载numification和stringification运算符，然后大概知道自己在做什么。</target>
        </trans-unit>
        <trans-unit id="3f20955fb9ac108dca46685f37b1cba8f9e1d54b" translate="yes" xml:space="preserve">
          <source>If you really do mean it, explicitly numify your reference, like so: &lt;code&gt;$array[0+$ref]&lt;/code&gt;. This warning is not given for overloaded objects, however, because you can overload the numification and stringification operators and then you presumably know what you are doing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b04e2e2f5675cd2c5905d17662a57b68104214b" translate="yes" xml:space="preserve">
          <source>If you really insist on using version.pm with an ordinary decimal version, use &lt;code&gt;parse()&lt;/code&gt; instead of declare. See the &lt;a href=&quot;#PARSING-AND-COMPARING-VERSIONS&quot;&gt;&quot;PARSING AND COMPARING VERSIONS&quot;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1013051a31faa052729be2f388df420c87199413" translate="yes" xml:space="preserve">
          <source>If you really need to see whether the change has been accepted simply examine the return value of &lt;code&gt;safe_level&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6ee3c0e5f77f2901d0e16f7c2a62b5dc496ad9" translate="yes" xml:space="preserve">
          <source>If you really need to see whether the change has been accepted simply examine the return value of C</source>
          <target state="translated">如果你真的需要查看更改是否被接受,只需检查C的返回值。</target>
        </trans-unit>
        <trans-unit id="dd150284dfc14b1b33a794d882418a56b32b28b6" translate="yes" xml:space="preserve">
          <source>If you really want a subroutine with a &lt;code&gt;()&lt;/code&gt; prototype that returns a lexical variable you can easily force it to not be inlined by adding an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">如果您确实想要带有 &lt;code&gt;()&lt;/code&gt; 原型的子例程返回一个词法变量，则可以通过添加显式 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 来轻松地使其不被内联：</target>
        </trans-unit>
        <trans-unit id="35a28f2c0d08eecba0c0e0394cdcfb91fe1c86b5" translate="yes" xml:space="preserve">
          <source>If you really want a subroutine with a &lt;code&gt;()&lt;/code&gt; prototype that returns a lexical variable you can easily force it to not be inlined by adding an explicit &lt;code&gt;return&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0166a5725d2770573e3a305750b9dd3edf5c05f" translate="yes" xml:space="preserve">
          <source>If you really want comments, build your list the old-fashioned way, with quotes and commas:</source>
          <target state="translated">如果你真的想要评论,就用老式的方式建立你的列表,用引号和逗号。</target>
        </trans-unit>
        <trans-unit id="f8aa3dfe02cc827e79905e1ddc0f6d36b724e3c5" translate="yes" xml:space="preserve">
          <source>If you really want just plain byte strings, use my_snprintf() and my_vsnprintf() instead, which will try to use snprintf() and vsnprintf() if those safer APIs are available. If you want something fancier than a plain byte string, use &lt;a href=&quot;perlapi#form&quot;&gt;&lt;code&gt;Perl_form&lt;/code&gt;()&lt;/a&gt; or SVs and &lt;a href=&quot;perlapi#sv_catpvf&quot;&gt;&lt;code&gt;Perl_sv_catpvf()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb99b666d9e169ba81737784680da343f375dd69" translate="yes" xml:space="preserve">
          <source>If you really want just plain byte strings, use my_snprintf() and my_vsnprintf() instead, which will try to use snprintf() and vsnprintf() if those safer APIs are available. If you want something fancier than a plain byte string, use &lt;a href=&quot;perlapi#form&quot;&gt;Perl_form ()&lt;/a&gt; or SVs and &lt;a href=&quot;perlapi#sv_catpvf&quot;&gt;Perl_sv_catpvf() &lt;/a&gt;.</source>
          <target state="translated">如果您确实只需要纯字节字符串，请改用my_snprintf（）和my_vsnprintf（），如果可以使用那些更安全的API，它们将尝试使用snprintf（）和vsnprintf（）。如果您想要一个比普通字节字符串更好的东西，请使用&lt;a href=&quot;perlapi#form&quot;&gt;Perl_form（）&lt;/a&gt;或&lt;a href=&quot;perlapi#sv_catpvf&quot;&gt;SVs&lt;/a&gt;和Perl_sv_catpvf（）。</target>
        </trans-unit>
        <trans-unit id="1c2d9e52e0617d90849665511b4fb2b333643750" translate="yes" xml:space="preserve">
          <source>If you really want to be international, you should consider Unicode. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for more information.</source>
          <target state="translated">如果您真的想成为国际用户，则应考虑使用Unicode。有关更多信息，请参见&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;和&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a1586770541996a5a05c7da504fe6b4a6bdef4c" translate="yes" xml:space="preserve">
          <source>If you really want to do this, you can use &lt;code&gt;ExtUtils::Manifest::manifind()&lt;/code&gt; to read the MANIFEST and File::Find to delete the files. But you have to be careful. Here's a script to do that. Use at your own risk. Have fun blowing holes in your foot.</source>
          <target state="translated">如果确实要执行此操作，则可以使用 &lt;code&gt;ExtUtils::Manifest::manifind()&lt;/code&gt; 读取MANIFEST，然后使用File :: Find删除文件。但是您必须要小心。这是执行此操作的脚本。使用风险自负。祝您脚下有洞。</target>
        </trans-unit>
        <trans-unit id="a9347a0885d5cc8b4c2356aaadf69fb6797e3c1b" translate="yes" xml:space="preserve">
          <source>If you really want to, you can use the standard open2() from the &lt;a href=&quot;IPC::Open2&quot;&gt;IPC::Open2&lt;/a&gt; module to catch both ends. There's also an open3() in &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt; for tridirectional I/O so you can also catch your child's STDERR, but doing so would then require an awkward select() loop and wouldn't allow you to use normal Perl input operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd0128791efed65e3bbb8d082044be49dfce046e" translate="yes" xml:space="preserve">
          <source>If you really want to, you can use the standard open2() from the &lt;code&gt;IPC::Open2&lt;/code&gt; module to catch both ends. There's also an open3() in &lt;code&gt;IPC::Open3&lt;/code&gt; for tridirectional I/O so you can also catch your child's STDERR, but doing so would then require an awkward select() loop and wouldn't allow you to use normal Perl input operations.</source>
          <target state="translated">如果确实需要，可以使用 &lt;code&gt;IPC::Open2&lt;/code&gt; 模块中的标准open2（）捕获两端。 &lt;code&gt;IPC::Open3&lt;/code&gt; 还有一个用于三向I / O 的open3（），因此您还可以捕获孩子的STDERR，但是这样做将需要笨拙的select（）循环，并且将不允许您使用常规的Perl输入操作。</target>
        </trans-unit>
        <trans-unit id="3c3fc1f61dc62bd06eef70c14d9957a3cba43c99" translate="yes" xml:space="preserve">
          <source>If you receive this error with a subroutine that has a real name, then you may have found a bug in autodie. See &lt;a href=&quot;autodie#BUGS&quot;&gt;&quot;BUGS&quot; in autodie&lt;/a&gt; for how to report this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53be29d9aa606768bcbe9e3309afe9ba5b57da03" translate="yes" xml:space="preserve">
          <source>If you recognized the quote about the Road above, you're in luck.</source>
          <target state="translated">如果你认出了上面关于 &quot;路 &quot;的名言,那么你很幸运。</target>
        </trans-unit>
        <trans-unit id="39a2ad311b79ed3072c37af199bf41f9f9aebf15" translate="yes" xml:space="preserve">
          <source>If you redefine a subroutine that was eligible for inlining, you'll get a warning by default. You can use this warning to tell whether or not a particular subroutine is considered inlinable, since it's different than the warning for overriding non-inlined subroutines:</source>
          <target state="translated">如果你重新定义了一个符合内联条件的子程序,你会默认得到一个警告。你可以用这个警告来判断一个特定的子程序是否被认为是可以内联的,因为它与覆盖非内联子程序的警告不同。</target>
        </trans-unit>
        <trans-unit id="ef0afdd765138635cef800ba6a31de68edaeb90c" translate="yes" xml:space="preserve">
          <source>If you require more flexibility than</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432e76406abd8db96136b5a2df1a568bbdde9d3f" translate="yes" xml:space="preserve">
          <source>If you resize the array with deferred writing enabled, the file will be resized immediately, but deferred records will not be written. This has a surprising consequence: &lt;code&gt;@a = (...)&lt;/code&gt; erases the file immediately, but the writing of the actual data is deferred. This might be a bug. If it is a bug, it will be fixed in a future version.</source>
          <target state="translated">如果在启用延迟写入的情况下调整数组大小，则将立即调整文件大小，但不会写入延迟记录。这产生了令人惊讶的结果： &lt;code&gt;@a = (...)&lt;/code&gt; 立即删除了文件，但是实际数据的写入被推迟了。这可能是一个错误。如果是错误，它将在将来的版本中修复。</target>
        </trans-unit>
        <trans-unit id="21c1c9d8d7fcdca9d7bb7cd7ffec5848c2f729ce" translate="yes" xml:space="preserve">
          <source>If you run Perl with the &lt;a href=&quot;warnings&quot;&gt;&lt;code&gt;use warnings&lt;/code&gt;&lt;/a&gt; pragma, it can warn you about this. For example, the third line above produces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95da308b81d0840cacd6821e3c3f91e04b82e8a" translate="yes" xml:space="preserve">
          <source>If you run Perl with the &lt;b&gt;-w&lt;/b&gt; switch it can warn you about this. For example, the third line above produces:</source>
          <target state="translated">如果使用&lt;b&gt;-w&lt;/b&gt;开关运行Perl，它可能会警告您。例如，上面的第三行产生：</target>
        </trans-unit>
        <trans-unit id="1983e4f73a942cb1a7c7741631cd3c3e344c8e03" translate="yes" xml:space="preserve">
          <source>If you run the script with the &lt;code&gt;-w&lt;/code&gt; flag the error message becomes:</source>
          <target state="translated">如果使用 &lt;code&gt;-w&lt;/code&gt; 标志运行脚本，则错误消息将变为：</target>
        </trans-unit>
        <trans-unit id="a9ad6a9bb0a2be45f4030cad900647a4bc2c1db1" translate="yes" xml:space="preserve">
          <source>If you run this code twice, the contents of the</source>
          <target state="translated">如果你运行这段代码两次,则在</target>
        </trans-unit>
        <trans-unit id="80dfce6f2a878c8f488ddf11e051d8fa78b7f75e" translate="yes" xml:space="preserve">
          <source>If you run your program with the &lt;code&gt;-w&lt;/code&gt; switch, or if you use the &lt;code&gt;warnings&lt;/code&gt; pragma, File::Find will report warnings for several weird situations. You can disable these warnings by putting the statement</source>
          <target state="translated">如果使用 &lt;code&gt;-w&lt;/code&gt; 开关运行程序，或者使用 &lt;code&gt;warnings&lt;/code&gt; 编译指示，则File :: Find将报告几种奇怪情况的警告。您可以通过放置以下语句来禁用这些警告</target>
        </trans-unit>
        <trans-unit id="714149520d778ab4a3aa775aef45bdd606216fd6" translate="yes" xml:space="preserve">
          <source>If you say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e83e7869cb30f17fc9ab2b3dafef8f917abf86" translate="yes" xml:space="preserve">
          <source>If you say yes to the following question, CPAN will try to store enough information about the build process so that it can pick up in future sessions at the same state of affairs as it left a previous session.</source>
          <target state="translated">如果你对下面的问题说 &quot;是&quot;,CPAN将尝试存储足够的关于构建过程的信息,以便在未来的会话中能够以离开前一个会话时的状态进行接收。</target>
        </trans-unit>
        <trans-unit id="3a116108872049154f6c27d6353e551d6d6917b4" translate="yes" xml:space="preserve">
          <source>If you see &quot;bad interpreter - no such file or directory&quot;, the first line in your perl script (the &quot;shebang&quot; line) does not contain the right path to perl (or any other program capable of running scripts). Sometimes this happens when you move the script from one machine to another and each machine has a different path to perl--/usr/bin/perl versus /usr/local/bin/perl for instance. It may also indicate that the source machine has CRLF line terminators and the destination machine has LF only: the shell tries to find /usr/bin/perl&amp;lt;CR&amp;gt;, but can't.</source>
          <target state="translated">如果看到&amp;ldquo;错误的解释器-没有这样的文件或目录&amp;rdquo;，则perl脚本中的第一行（&amp;ldquo; shebang&amp;rdquo;行）不包含指向perl（或任何其他能够运行脚本的程序）的正确路径。有时，当您将脚本从一台机器移动到另一台机器时，每台机器都有不同的perl路径-例如，/ usr / bin / perl与/ usr / local / bin / perl相对。它还可能表明源计算机具有CRLF行终止符，而目标计算机仅具有LF：shell尝试查找/ usr / bin / perl &amp;lt;CR&amp;gt;，但是找不到。</target>
        </trans-unit>
        <trans-unit id="2f85a9726440183decd897c1fff5988cce63ccf9" translate="yes" xml:space="preserve">
          <source>If you see &quot;bad interpreter: Permission denied&quot;, you need to make your script executable.</source>
          <target state="translated">如果你看到 &quot;bad interpreter.Permission denied&quot;,你需要让你的脚本可以执行。Permission denied&quot;,你需要让你的脚本可以执行。</target>
        </trans-unit>
        <trans-unit id="8de6b12e8e3d869536fad39850a1db08fd9bac7f" translate="yes" xml:space="preserve">
          <source>If you see in a debugger a memory area mysteriously full of 0xABABABAB or 0xEFEFEFEF, you may be seeing the effect of the Poison() macros, see &lt;a href=&quot;perlclib&quot;&gt;perlclib&lt;/a&gt;.</source>
          <target state="translated">如果在调试器中看到一个神秘的充满0xABABABAB或0xEFEFEFEF的内存区域，则可能是在看到Poison（）宏的作用，请参见&lt;a href=&quot;perlclib&quot;&gt;perlclib&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d3df616229a0ebfcb7922d24bec233001d332f4" translate="yes" xml:space="preserve">
          <source>If you see right after &quot;make&quot; this</source>
          <target state="translated">如果你在 &quot;制作 &quot;之后看到这个</target>
        </trans-unit>
        <trans-unit id="d8e7a131ddc6c256b7162ac7f1766e22fd038d65" translate="yes" xml:space="preserve">
          <source>If you see that you're leaking memory at runtime, but neither valgrind nor &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; will find anything, you're probably leaking SVs that are still reachable and will be properly cleaned up during destruction of the interpreter. In such cases, using the &lt;code&gt;-Dm&lt;/code&gt; switch can point you to the source of the leak. If the executable was built with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; , &lt;code&gt;-Dm&lt;/code&gt; will output SV allocations in addition to memory allocations. Each SV allocation has a distinct serial number that will be written on creation and destruction of the SV. So if you're executing the leaking code in a loop, you need to look for SVs that are created, but never destroyed between each cycle. If such an SV is found, set a conditional breakpoint within &lt;code&gt;new_SV()&lt;/code&gt; and make it break only when &lt;code&gt;PL_sv_serial&lt;/code&gt; is equal to the serial number of the leaking SV. Then you will catch the interpreter in exactly the state where the leaking SV is allocated, which is sufficient in many cases to find the source of the leak.</source>
          <target state="translated">如果看到运行时正在泄漏内存，但是valgrind和 &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; 都找不到任何内容，则可能是泄漏了仍可访问的SV，并且将在解释器销毁期间对其进行了适当的清理。在这种情况下，使用 &lt;code&gt;-Dm&lt;/code&gt; 开关可以将您指向泄漏源。如果可执行文件是使用 &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; 构建的，则 &lt;code&gt;-Dm&lt;/code&gt; 除了内存分配外，还将输出SV分配。每个SV分配都有一个不同的序列号，该序列号将在SV创建和销毁时写入。因此，如果要循环执行泄漏的代码，则需要查找已创建但从未在每个周期之间销毁的SV。如果找到了这样的SV，请在 &lt;code&gt;new_SV()&lt;/code&gt; 中设置一个条件断点，并使其仅在 &lt;code&gt;PL_sv_serial&lt;/code&gt; 等于泄漏的SV的序列号时才中断。然后，您将恰好在分配泄漏SV的状态下捕获解释器，这在许多情况下足以找到泄漏的来源。</target>
        </trans-unit>
        <trans-unit id="00d516d64e31e37eefa736f20d08e45a8565422c" translate="yes" xml:space="preserve">
          <source>If you see that you're leaking memory at runtime, but neither valgrind nor &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; will find anything, you're probably leaking SVs that are still reachable and will be properly cleaned up during destruction of the interpreter. In such cases, using the &lt;code&gt;-Dm&lt;/code&gt; switch can point you to the source of the leak. If the executable was built with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt;, &lt;code&gt;-Dm&lt;/code&gt; will output SV allocations in addition to memory allocations. Each SV allocation has a distinct serial number that will be written on creation and destruction of the SV. So if you're executing the leaking code in a loop, you need to look for SVs that are created, but never destroyed between each cycle. If such an SV is found, set a conditional breakpoint within &lt;code&gt;new_SV()&lt;/code&gt; and make it break only when &lt;code&gt;PL_sv_serial&lt;/code&gt; is equal to the serial number of the leaking SV. Then you will catch the interpreter in exactly the state where the leaking SV is allocated, which is sufficient in many cases to find the source of the leak.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bbf4110deb94dbc624ccee947cca19c596a9010" translate="yes" xml:space="preserve">
          <source>If you see this</source>
          <target state="translated">如果你看到这个</target>
        </trans-unit>
        <trans-unit id="4203dc6863ea2ff3c77a2428ddc46eaf1f7849d3" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;$DB::single&lt;/code&gt; to 2, it's equivalent to having just typed the &lt;code&gt;n&lt;/code&gt; command, whereas a value of 1 means the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; command. The &lt;code&gt;$DB::trace&lt;/code&gt; variable should be set to 1 to simulate having typed the &lt;code&gt;t&lt;/code&gt; command.</source>
          <target state="translated">如果将 &lt;code&gt;$DB::single&lt;/code&gt; 设置为 2，则等效于刚刚键入 &lt;code&gt;n&lt;/code&gt; 命令，而值1表示 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 命令。在 &lt;code&gt;$DB::trace&lt;/code&gt; 变量应设置为1，模拟输入具有的 &lt;code&gt;t&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="7b33b418b3104ec5416e5681959ccdc2c9bea5af" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;$DB::single&lt;/code&gt; to 2, it's equivalent to having just typed the &lt;code&gt;n&lt;/code&gt; command, whereas a value of 1 means the &lt;code&gt;s&lt;/code&gt; command. The &lt;code&gt;$DB::trace&lt;/code&gt; variable should be set to 1 to simulate having typed the &lt;code&gt;t&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5d30ba8967fd6c8924240ee40d5a140a986b280" translate="yes" xml:space="preserve">
          <source>If you set a value for this attribute, the value is expected to be an object (probably of a class that you define) that has a &lt;code&gt;reach&lt;/code&gt; method and a &lt;code&gt;done&lt;/code&gt; method. This is meant for reporting progress during the search, if you don't want to use a simple callback.</source>
          <target state="translated">如果为此属性设置一个值，则该值应该是一个具有 &lt;code&gt;reach&lt;/code&gt; 方法和 &lt;code&gt;done&lt;/code&gt; 方法的对象（可能是您定义的类）。如果您不想使用简单的回调，则用于报告搜索过程中的进度。</target>
        </trans-unit>
        <trans-unit id="bcde195e379d8e8445763e6616418aa0a7c91d66" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;parse_characters&lt;/code&gt; option to a true value the parser will expect characters rather than octets; will ignore any &lt;code&gt;=encoding&lt;/code&gt; ; and will make no attempt to decode the input.</source>
          <target state="translated">如果将 &lt;code&gt;parse_characters&lt;/code&gt; 选项设置为true，则解析器将使用字符而不是八位字节；否则，解析器将保留字符。将忽略任何 &lt;code&gt;=encoding&lt;/code&gt; ; 并且不会尝试解码输入。</target>
        </trans-unit>
        <trans-unit id="f6202a4ce3a92187f86730903457c240d414eaac" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;parse_characters&lt;/code&gt; option to a true value the parser will expect characters rather than octets; will ignore any &lt;code&gt;=encoding&lt;/code&gt;; and will make no attempt to decode the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24318749936760c8c43beac827cb9d11fbd59672" translate="yes" xml:space="preserve">
          <source>If you set this attribute to a true value, it will send reports of parsing errors to STDERR. By default, this attribute's value is false, meaning that no output is sent to STDERR.</source>
          <target state="translated">如果您将此属性设置为真值,它将向STDERR发送解析错误报告。默认情况下,此属性的值为false,意味着不会向STDERR发送任何输出。</target>
        </trans-unit>
        <trans-unit id="230572eb4ee772d17d86eabe528a430137c47e2e" translate="yes" xml:space="preserve">
          <source>If you set this attribute to a true value, the parser will try to preserve whitespace in the output. This means that such formatting conventions as two spaces after periods will be preserved by the parser. This is primarily useful for output formats that treat whitespace as significant (such as text or *roff, but not HTML).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b8252659bce51d0b80d2e62f37a533a1cac341" translate="yes" xml:space="preserve">
          <source>If you set this attribute to a true value, you will stop the parser from generating a &quot;POD ERRORS&quot; section at the end of the document. By default, this attribute's value is false, meaning that an errata section will be generated, as necessary.</source>
          <target state="translated">如果你把这个属性设置为true,你就会阻止解析器在文档末尾生成 &quot;POD ERRORS &quot;部分。默认情况下,这个属性的值为false,这意味着将在必要时生成勘误部分。</target>
        </trans-unit>
        <trans-unit id="551f3a0a87736ea2dc54ed40fd31f1fb500e9541" translate="yes" xml:space="preserve">
          <source>If you set this attribute to a true value, you will suppress the parser's complaints about irregularities in the Pod coding. By default, this attribute's value is false, meaning that irregularities will be reported.</source>
          <target state="translated">如果将此属性设置为true,则会抑制解析器对Pod编码中的不规则现象的投诉。默认情况下,这个属性的值为false,意味着将报告不规则的情况。</target>
        </trans-unit>
        <trans-unit id="e0f5cb1c277b98516d80bdfac1209f73af95fdc5" translate="yes" xml:space="preserve">
          <source>If you set this flag, all keys passed in the following manner:</source>
          <target state="translated">如果你设置了这个标志,所有的键都会以如下方式传递。</target>
        </trans-unit>
        <trans-unit id="90adec0aabd8555567c00e54faf42cc1c5fd95da" translate="yes" xml:space="preserve">
          <source>If you set this flag, unknown options will still be present in the return value, rather than filtered out. This is useful if your subroutine is only interested in a few arguments, and wants to pass the rest on blindly to perhaps another subroutine.</source>
          <target state="translated">如果你设置了这个标志,未知选项仍然会出现在返回值中,而不是被过滤掉。如果你的子程序只对几个参数感兴趣,而想把剩下的参数盲目地传递给另一个子程序,那么这个标志就很有用。</target>
        </trans-unit>
        <trans-unit id="71c1c224b5079dff6437c4c296c3882a0dbe0842" translate="yes" xml:space="preserve">
          <source>If you set this value to 0, these processes will wait forever. This is the default and recommended setting.</source>
          <target state="translated">如果将此值设置为0,这些进程将永远等待。这是默认和推荐的设置。</target>
        </trans-unit>
        <trans-unit id="57bb7a66b14f683a002bf6e9ed419bdbfaba4540" translate="yes" xml:space="preserve">
          <source>If you simply need to check quickly to see if a module is available, you can check for its documentation. If you can read the documentation the module is most likely installed. If you cannot read the documentation, the module might not have any (in rare cases):</source>
          <target state="translated">如果您只是需要快速检查一个模块是否可用,您可以检查它的文档。如果您能读懂文档,那么该模块很可能已经安装了。如果您无法阅读文档,则该模块可能没有任何文档(在极少数情况下)。</target>
        </trans-unit>
        <trans-unit id="62a930272a7b67c86c0db7dd61a11f4230b11d14" translate="yes" xml:space="preserve">
          <source>If you simply want &lt;code&gt;TAP::Parser&lt;/code&gt; to handle a new source of TAP you probably don't need to subclass &lt;code&gt;TAP::Parser&lt;/code&gt; itself. Rather, you'll need to create a new &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; class, and just plug it into the parser using the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8217a1604a7e6dedea6a0a5e3eee8fea23c61b15" translate="yes" xml:space="preserve">
          <source>If you simply want &lt;code&gt;TAP::Parser&lt;/code&gt; to handle a new source of TAP you probably don't need to subclass &lt;code&gt;TAP::Parser&lt;/code&gt; itself. Rather, you'll need to create a new &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; class, and just plug it into the parser using the</source>
          <target state="translated">如果您只是希望 &lt;code&gt;TAP::Parser&lt;/code&gt; 处理TAP的新源，则可能无需继承 &lt;code&gt;TAP::Parser&lt;/code&gt; 本身。相反，您需要创建一个新的&lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;类，然后使用将其插入解析器。</target>
        </trans-unit>
        <trans-unit id="bccc23097030849c37e4990da975ad564b128d6e" translate="yes" xml:space="preserve">
          <source>If you simply want to check that a variable contains an object reference, we recommend that you use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; blessed($object)&lt;/code&gt; , since &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; returns true values for all references, not just objects.</source>
          <target state="translated">如果您只是想检查一个变量是否包含对象引用，我们建议您使用已 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; blessed($object)&lt;/code&gt; ，因为 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 会为所有引用而不是对象返回真值。</target>
        </trans-unit>
        <trans-unit id="0eff4b8cc8d1302b285b2ea0f2efb3650eee76be" translate="yes" xml:space="preserve">
          <source>If you simply want to check that a variable contains an object reference, we recommend that you use &lt;code&gt;defined blessed($object)&lt;/code&gt;, since &lt;code&gt;ref&lt;/code&gt; returns true values for all references, not just objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="775bfc9c0c8443d71c6d6889e2281bdebabd0a98" translate="yes" xml:space="preserve">
          <source>If you simply want to do a little tweaking of how the tests behave, you can access the underlying &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; object like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538504cf71c29fca71496cb30f3e2c1293640623" translate="yes" xml:space="preserve">
          <source>If you simply want to do a little tweaking of how the tests behave, you can access the underlying &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; object like so:</source>
          <target state="translated">如果您只是想稍微调整一下测试的行为，则可以像下面这样访问底层的&lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt;对象：</target>
        </trans-unit>
        <trans-unit id="529d627921bb06c8d7af89d86ac316fcc827cff3" translate="yes" xml:space="preserve">
          <source>If you simply want to intercept all results instead of letting them go to TAP, you should look at the &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt; docs and read about pushing a new hub onto the hub stack. Replacing the hub temporarily is now the correct way to intercept results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8d0959c4e3749a28ef9e062bf2ea64f531c9a4d" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;'&amp;lt;&amp;amp;=X'&lt;/code&gt; , where &lt;code&gt;X&lt;/code&gt; is a file descriptor number or a filehandle, then Perl will do an equivalent of C's &lt;code&gt;fdopen&lt;/code&gt; of that file descriptor (and not call &lt;code&gt;dup(2)&lt;/code&gt; ); this is more parsimonious of file descriptors. For example:</source>
          <target state="translated">如果指定 &lt;code&gt;'&amp;lt;&amp;amp;=X'&lt;/code&gt; ，其中 &lt;code&gt;X&lt;/code&gt; 是文件描述符号或文件句柄，则Perl将执行C 对该文件描述符的 &lt;code&gt;fdopen&lt;/code&gt; 的等效操作（并且不调用 &lt;code&gt;dup(2)&lt;/code&gt; ）；这更简化了文件描述符。例如：</target>
        </trans-unit>
        <trans-unit id="374cb57ad3f006566ce6e2725d54d8c62c1dbbdd" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;'&amp;lt;&amp;amp;=X'&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is a file descriptor number or a filehandle, then Perl will do an equivalent of C's &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; of that file descriptor (and not call &lt;a href=&quot;http://man.he.net/man2/dup&quot;&gt;dup(2)&lt;/a&gt;); this is more parsimonious of file descriptors. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="180f2fd51c0d498482504f1f96654a60c731b6ff" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;NUM_USES&lt;/code&gt; with an argument of</source>
          <target state="translated">如果您指定 &lt;code&gt;NUM_USES&lt;/code&gt; 且参数为</target>
        </trans-unit>
        <trans-unit id="8d4306b9666c2a3ba16744fba22e147888a1f901" translate="yes" xml:space="preserve">
          <source>If you specify COMPRESS, then SUFFIX should also be altered, as it is needed to tell make the target file of the compression. Setting DIST_CP to ln can be useful, if you need to preserve the timestamps on your files. DIST_CP can take the values 'cp', which copies the file, 'ln', which links the file, and 'best' which copies symbolic links and links the rest. Default is 'best'.</source>
          <target state="translated">如果你指定了COMPRESS,那么SUFFIX也应该被改变,因为它需要告诉使目标文件的压缩。如果你需要保留文件上的时间戳,将DIST_CP设置为ln是很有用的。DIST_CP 可以取值 'cp',复制文件,'ln',链接文件,'best',复制符号链接并链接其他文件。默认值是'best'。</target>
        </trans-unit>
        <trans-unit id="fc451ad5db1446b8366614b6922be5421ce289a8" translate="yes" xml:space="preserve">
          <source>If you specify LIB or any INSTALL* variables they will not be affected by the PREFIX.</source>
          <target state="translated">如果你指定了 LIB 或任何 INSTALL*变量,它们将不受 PREFIX 的影响。</target>
        </trans-unit>
        <trans-unit id="9241abdeaef157dc233bd737d1c5964fbf4c453e" translate="yes" xml:space="preserve">
          <source>If you specify both arguments, data will be discarded from the cache when either expiration condition holds.</source>
          <target state="translated">如果您指定了这两个参数,当任何一个过期条件成立时,数据将被从缓存中丢弃。</target>
        </trans-unit>
        <trans-unit id="4155cee8fa3d0e362aaa00b0200498bfa23f6764" translate="yes" xml:space="preserve">
          <source>If you specify the &lt;code&gt;'class' =&amp;gt; $class&lt;/code&gt; argument, the new hub will be an instance of the specified class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63159230c4deaa2cf08d944e8f0464cc9f6ef86a" translate="yes" xml:space="preserve">
          <source>If you spell colour differently, that's no problem. The &lt;code&gt;TESTTESTERCOLOR&lt;/code&gt; variable also works (if both are set then the British spelling wins out).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec224c3d56f48a286860fa26eb84c5ac4d399f4c" translate="yes" xml:space="preserve">
          <source>If you start with bullets or numbers, stick with them, as formatters use the first &quot;=item&quot; type to decide how to format the list.</source>
          <target state="translated">如果你从子弹或数字开始,坚持使用它们,因为格式化人员使用第一个&quot;=item &quot;类型来决定如何格式化列表。</target>
        </trans-unit>
        <trans-unit id="583108dc3c7ca5413e3c465d6f2c5b41f57d07b1" translate="yes" xml:space="preserve">
          <source>If you still need a different solution, try to develop another subroutine that fits your needs and submit the diffs to &lt;code&gt;makemaker@perl.org&lt;/code&gt;</source>
          <target state="translated">如果仍然需要其他解决方案，请尝试开发另一个适合您需求的子例程，并将差异提交到 &lt;code&gt;makemaker@perl.org&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a47b80b17f146bdd2f697c181154024073445f0f" translate="yes" xml:space="preserve">
          <source>If you still need commercial support &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActiveState&lt;/a&gt; offers this.</source>
          <target state="translated">如果您仍需要商业支持，&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActiveState会&lt;/a&gt;提供此服务。</target>
        </trans-unit>
        <trans-unit id="e6da1990bc50d152e699b894b1f49c6c5a3821a0" translate="yes" xml:space="preserve">
          <source>If you still need commercial support &lt;a href=&quot;http://www.activestate.com/activeperl&quot;&gt;ActiveState&lt;/a&gt; offers this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36c7ee3bb3bd53d4ea9fd7168cf498f48087d02" translate="yes" xml:space="preserve">
          <source>If you still think you need this outside of debugging, testing or dealing with filenames, you should probably read &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; and &lt;a href=&quot;perlunifaq#What-is-%22the-UTF8-flag%22%3F&quot;&gt;&quot;What is &quot;the UTF8 flag&quot;?&quot; in perlunifaq&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1b0c04cf56825c214a1e0c17a804ce5039d636" translate="yes" xml:space="preserve">
          <source>If you supply a code reference the subroutine will be called once for each line of output with the line as its only argument. Passed lines will have no trailing newline.</source>
          <target state="translated">如果您提供了一个代码引用,子程序将对每行输出调用一次,并将该行作为唯一的参数。通过的行将没有尾部的换行。</target>
        </trans-unit>
        <trans-unit id="9c870447a33109e08d6ac4807e8b39152cd8060a" translate="yes" xml:space="preserve">
          <source>If you supply a function name with &lt;code&gt;INSTALL&lt;/code&gt; , memoize will install the new, memoized version of the function under the name you give. For example,</source>
          <target state="translated">如果您使用 &lt;code&gt;INSTALL&lt;/code&gt; 提供函数名称，则memoize将在您提供的名称下安装该函数的新的，经过记忆的版本。例如，</target>
        </trans-unit>
        <trans-unit id="d57aa0246bfd4cdc05d4e778a00fbcc8da325130" translate="yes" xml:space="preserve">
          <source>If you supply a function name with &lt;code&gt;INSTALL&lt;/code&gt;, memoize will install the new, memoized version of the function under the name you give. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6165205f1f599d384067c9f25ff1f7dd1d17430" translate="yes" xml:space="preserve">
          <source>If you supply data which is not valid (month 27, second 1,000) the results will be unpredictable (so don't do that).</source>
          <target state="translated">如果你提供的数据是无效的(第27个月,第二个1000),结果将是不可预测的(所以不要这样做)。</target>
        </trans-unit>
        <trans-unit id="f2f171e34560b51f24a2295b658a384f71202d5b" translate="yes" xml:space="preserve">
          <source>If you think geographically the</source>
          <target state="translated">如果你从地理上考虑</target>
        </trans-unit>
        <trans-unit id="50a6625675c788b39661b9a604d74414a739f593" translate="yes" xml:space="preserve">
          <source>If you think that you want to add a new command to Pod (like, say, a &quot;=biblio&quot; command), consider whether you could get the same effect with a for or begin/end sequence: &quot;=for biblio ...&quot; or &quot;=begin biblio&quot; ... &quot;=end biblio&quot;. Pod processors that don't understand &quot;=for biblio&quot;, etc, will simply ignore it, whereas they may complain loudly if they see &quot;=biblio&quot;.</source>
          <target state="translated">如果你认为你想在Pod中添加一个新的命令(比如,&quot;=biblio &quot;命令),考虑一下你是否可以用for或begin/end序列来获得同样的效果。&quot;=for biblio ...&quot;或者&quot;=begin biblio&quot; ...&quot;=end biblio&quot;。不懂&quot;=for biblio &quot;等的花苞处理器会直接忽略,而如果看到&quot;=biblio&quot;,他们可能会大声抱怨。</target>
        </trans-unit>
        <trans-unit id="0dc7def89e2edc18a212cddb050ecfe26b36c107" translate="yes" xml:space="preserve">
          <source>If you trust the archive, or have other reasons to allow the archive to write files outside your current working directory, set this variable to &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">如果您信任存档，或者出于其他原因允许存档在当前工作目录之外写入文件，请将此变量设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bec0c73790b3c3d05f6a3152a00361a5cd4bae9" translate="yes" xml:space="preserve">
          <source>If you trust the archive, or have other reasons to allow the archive to write files outside your current working directory, set this variable to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6aec72dc70a1ee4a43ad060e5bdfa6e98825b4f" translate="yes" xml:space="preserve">
          <source>If you try &lt;code&gt;Moose&lt;/code&gt; and find that one of these issues is preventing you from using &lt;code&gt;Moose&lt;/code&gt; , we encourage you to consider &lt;a href=&quot;http://search.cpan.org/perldoc/Moo&quot;&gt;Moo&lt;/a&gt; next. &lt;code&gt;Moo&lt;/code&gt; implements a subset of &lt;code&gt;Moose&lt;/code&gt; 's functionality in a simpler package. For most features that it does implement, the end-user API is</source>
          <target state="translated">如果您尝试 &lt;code&gt;Moose&lt;/code&gt; 并发现其中一个问题阻止了您使用 &lt;code&gt;Moose&lt;/code&gt; ，那么我们建议您接下来考虑使用&lt;a href=&quot;http://search.cpan.org/perldoc/Moo&quot;&gt;Moo&lt;/a&gt;。 &lt;code&gt;Moo&lt;/code&gt; 在更简单的程序包中实现 &lt;code&gt;Moose&lt;/code&gt; 功能的子集。对于它实现的大多数功能，最终用户API为</target>
        </trans-unit>
        <trans-unit id="8196054f51c09e40b22436127d72432408c8b94d" translate="yes" xml:space="preserve">
          <source>If you try &lt;code&gt;Moose&lt;/code&gt; and find that one of these issues is preventing you from using &lt;code&gt;Moose&lt;/code&gt;, we encourage you to consider &lt;a href=&quot;moo&quot;&gt;Moo&lt;/a&gt; next. &lt;code&gt;Moo&lt;/code&gt; implements a subset of &lt;code&gt;Moose&lt;/code&gt;'s functionality in a simpler package. For most features that it does implement, the end-user API is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce64d2eb6b26fca2ba64557ff812899e21e2cf8b" translate="yes" xml:space="preserve">
          <source>If you try to add a file to @INC as follows:</source>
          <target state="translated">如果你试图向@INC添加一个文件,如下所示。</target>
        </trans-unit>
        <trans-unit id="e1047e2245ed732ddd158d44ef63171c1040f4d7" translate="yes" xml:space="preserve">
          <source>If you try to dereference the key, it won't do a hard dereference, and you won't accomplish what you're attempting. You might want to do something more like</source>
          <target state="translated">如果你试图去定义键,它就不会进行硬性的去定义,你就不会完成你的尝试。你可能想做一些更像</target>
        </trans-unit>
        <trans-unit id="b64e549b9d0f70c710cd7ee8a843df08eb7e123c" translate="yes" xml:space="preserve">
          <source>If you try to do something insecure, you will get a fatal error saying something like &quot;Insecure dependency&quot; or &quot;Insecure $ENV{PATH}&quot;.</source>
          <target state="translated">如果你试图做一些不安全的事情,你会得到一个致命的错误,比如 &quot;不安全的依赖 &quot;或 &quot;不安全的$ENV{PATH}&quot;。</target>
        </trans-unit>
        <trans-unit id="baaf467929bddd8fa5b7aa6c26404c219da0153b" translate="yes" xml:space="preserve">
          <source>If you try to do the same thing with what you think is a list, you get a quite different result. Although it looks like you have a list on the righthand side, Perl actually sees a bunch of scalars separated by a comma:</source>
          <target state="translated">如果你试图用你认为是列表的东西做同样的事情,你会得到一个完全不同的结果。虽然看起来你在右面有一个列表,但Perl实际上看到的是一堆用逗号隔开的标量。</target>
        </trans-unit>
        <trans-unit id="e39b81693bb33881d5354ed40ab1aa5e5e421f38" translate="yes" xml:space="preserve">
          <source>If you try to import an unimplemented function in the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement it will fail at compile time.</source>
          <target state="translated">如果尝试在 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句中导入未实现的函数，它将在编译时失败。</target>
        </trans-unit>
        <trans-unit id="4b4406a29e69d0fe589df66b2d19e5926b365127" translate="yes" xml:space="preserve">
          <source>If you try to import an unimplemented function in the &lt;code&gt;use&lt;/code&gt; statement it will fail at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15d030c497334de4682713f89a5eeaabfcfb4a3" translate="yes" xml:space="preserve">
          <source>If you try to read from the child's stdout writer and their stderr writer, you'll have problems with blocking, which means you'll want to use select() or &lt;a href=&quot;IO::Select&quot;&gt;IO::Select&lt;/a&gt;, which means you'd best use sysread() instead of readline() for normal stuff.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce84b9139b9e943d624385f2da9d34f42bd6117a" translate="yes" xml:space="preserve">
          <source>If you try to read from the child's stdout writer and their stderr writer, you'll have problems with blocking, which means you'll want to use select() or the IO::Select, which means you'd best use sysread() instead of readline() for normal stuff.</source>
          <target state="translated">如果你试图从子程序的stdout写作者和他们的stderr写作者那里读取,你会遇到阻塞的问题,这意味着你要使用select()或IO::Select,这意味着你最好使用sysread()而不是readline()来处理普通的东西。</target>
        </trans-unit>
        <trans-unit id="8629095d12898edeef813ea5adb0d8466406ccc7" translate="yes" xml:space="preserve">
          <source>If you try to use a reference like a string, you get strings like</source>
          <target state="translated">如果你尝试使用像字符串一样的引用,你会得到这样的字符串。</target>
        </trans-unit>
        <trans-unit id="39dd9c9407d1478c40154f713c3d3db1f745db97" translate="yes" xml:space="preserve">
          <source>If you try to use an alphanumeric sequence in a prototype you will generate an optional warning - &quot;Illegal character in prototype...&quot;. Unfortunately earlier versions of Perl allowed the prototype to be used as long as its prefix was a valid prototype. The warning may be upgraded to a fatal error in a future version of Perl once the majority of offending code is fixed.</source>
          <target state="translated">如果你试图在原型中使用字母数字序列,你会产生一个可选的警告--&quot;Illegal character in prototype...&quot;。不幸的是,早期版本的Perl允许使用原型,只要它的前缀是一个有效的原型。一旦大部分违规代码被修复,该警告可能会在未来版本的Perl中升级为致命错误。</target>
        </trans-unit>
        <trans-unit id="fe9a752d3dfb5ae4ddbce9b50462b1f6d85d68b3" translate="yes" xml:space="preserve">
          <source>If you try to use code expressions where the code text is contained within an interpolated variable, rather than appearing literally in the pattern, Perl may surprise you:</source>
          <target state="translated">如果你尝试使用代码表达式,其中代码文本包含在一个内插变量中,而不是按字面意思出现在模式中,Perl可能会让你感到惊讶。</target>
        </trans-unit>
        <trans-unit id="11e25dd065a3c2e65ba069546d65a87869f3ab69" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; in your handler for &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;$SIG{CHLD}&lt;/code&gt;&lt;/a&gt;, it may accidentally wait for the child created by &lt;a href=&quot;#qx%2FSTRING%2F&quot;&gt;&lt;code&gt;qx&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74ccad2ea9ca8d857dc7afb6d54fa03395dd0f9" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; in your handler for $SIG{CHLD}, it may accidentally wait for the child created by qx() or system(). See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">如果在处理程序中为$ SIG {CHLD} 使用 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; ，则可能会意外地等待qx（）或system（）创建的子级。有关详细信息，请参见&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f489bb10b3438e3010da06cd3b95ce427029dc2" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; in your handler for $SIG{CHLD}, it may accidentally wait for the child created by qx() or system(). See &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">如果在处理程序中为$ SIG {CHLD} 使用 &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; ，则可能会意外地等待qx（）或system（）创建的子级。有关详细信息，请参见&lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46bb44efb62948225ccf4e92dee64ae61f103a13" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;FilterName&lt;/code&gt; to modify the filename, it is your responsibility to keep the filename in Unix format.</source>
          <target state="translated">如果使用 &lt;code&gt;FilterName&lt;/code&gt; 修改文件名，则有责任将文件名保持为Unix格式。</target>
        </trans-unit>
        <trans-unit id="16f11d3777f6f8b6ecfda56c2150f1df3c1a440a" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;harness&lt;/code&gt; for testing, you have several command line options available to you. The arguments are as follows, and are in the order that they must appear if used together.</source>
          <target state="translated">如果使用 &lt;code&gt;harness&lt;/code&gt; 进行测试，则可以使用几个命令行选项。自变量如下，并按在一起使用时必须出现的顺序排列。</target>
        </trans-unit>
        <trans-unit id="5dace6a8fabe0f3fff4268587985038c8aa60a8e" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;man&lt;/code&gt; , either move the installed</source>
          <target state="translated">如果使用 &lt;code&gt;man&lt;/code&gt; ，请移动已安装的</target>
        </trans-unit>
        <trans-unit id="2526f763683e8e3d761dca9fc7d00f94a999cd3a" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;man&lt;/code&gt;, either move the installed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f77d31c25362c9be9687e6ee59543d3904970c3a" translate="yes" xml:space="preserve">
          <source>If you use Sun's C compiler, make sure the correct directory (usually /opt/SUNWspro/bin/) is in your PATH (before /usr/ucb/).</source>
          <target state="translated">如果你使用的是Sun的C编译器,请确保正确的目录(通常是/opt/SUNWspro/bin/)在你的PATH中(在/usr/ucb/之前)。</target>
        </trans-unit>
        <trans-unit id="694a362a82c6e3cfa50f1318ad85b6fb37d17685" translate="yes" xml:space="preserve">
          <source>If you use a Unicode editor to edit your program, Unicode characters may occur directly within the literal strings in UTF-8 encoding, or UTF-16. (The former requires a &lt;code&gt;BOM&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , the latter requires a &lt;code&gt;BOM&lt;/code&gt; .)</source>
          <target state="translated">如果您使用Unicode编辑器来编辑程序，则Unicode字符可能直接出现在UTF-8编码或UTF-16的文字字符串中。（前者需要 &lt;code&gt;BOM&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; ，后者需要 &lt;code&gt;BOM&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="12733393a4777e2904da336b9a9ac1c8e8988972" translate="yes" xml:space="preserve">
          <source>If you use a Unicode editor to edit your program, Unicode characters may occur directly within the literal strings in UTF-8 encoding, or UTF-16. (The former requires a &lt;code&gt;use utf8&lt;/code&gt;, the latter may require a &lt;code&gt;BOM&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cf615c227432610de49accfafc5d497f5d3f61" translate="yes" xml:space="preserve">
          <source>If you use a deprecated feature or module and believe that its removal from the Perl core would be a mistake, please contact the perl5-porters mailinglist and plead your case. We don't deprecate things without a good reason, but sometimes there's a counterargument we haven't considered. Historically, we did not distinguish between &quot;deprecated&quot; and &quot;discouraged&quot; features.</source>
          <target state="translated">如果你使用了一个被废弃的功能或模块,并且认为将其从 Perl 核心中移除是一个错误,请联系 perl5-porters 邮件列表并说明你的理由。我们不会在没有充分理由的情况下弃用某些东西,但有时会有我们没有考虑到的反驳意见。历史上,我们并没有区分 &quot;废弃 &quot;和 &quot;不鼓励 &quot;的特性。</target>
        </trans-unit>
        <trans-unit id="5dd282c0cc211cebd60be34d73466e199fdff472" translate="yes" xml:space="preserve">
          <source>If you use a here-doc within a delimited construct, such as in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///eg&lt;/a&gt;&lt;/code&gt;, the quoted material must still come on the line following the &lt;code&gt;&amp;lt;&amp;lt;FOO&lt;/code&gt; marker, which means it may be inside the delimited construct:</source>
          <target state="translated">如果在带分隔符的结构（例如 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///eg&lt;/a&gt;&lt;/code&gt; 使用here-doc ，则引用的材料仍必须位于 &lt;code&gt;&amp;lt;&amp;lt;FOO&lt;/code&gt; 标记之后的行中，这意味着它可能位于带分隔符的结构中：</target>
        </trans-unit>
        <trans-unit id="ef85aed564f520195de79872cb8f400e6839cfe4" translate="yes" xml:space="preserve">
          <source>If you use a here-doc within a delimited construct, such as in &lt;code&gt;s///eg&lt;/code&gt;, the quoted material must still come on the line following the &lt;code&gt;&amp;lt;&amp;lt;FOO&lt;/code&gt; marker, which means it may be inside the delimited construct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f880ff17098bf984e1784381aefee800c2614214" translate="yes" xml:space="preserve">
          <source>If you use a mathematic formula that resolves to a floating point number, you are dependent on Perl's conversion routines to yield the version you expect. You are pretty safe by dividing by a power of 10, for example, but other operations are not likely to be what you intend. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="328cd5a18e409f3686cf9b70d3830474d172c463" translate="yes" xml:space="preserve">
          <source>If you use deferred writing (See &lt;a href=&quot;#Deferred-Writing&quot;&gt;&quot;Deferred Writing&quot;&lt;/a&gt;, below) then data you write into the array will not be written directly to the file; instead, it will be saved in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae0c0867250fd5a479e543aea928a9a77d11b83" translate="yes" xml:space="preserve">
          <source>If you use deferred writing (See &lt;a href=&quot;#Deferred-Writing&quot;&gt;Deferred Writing&lt;/a&gt;, below) then data you write into the array will not be written directly to the file; instead, it will be saved in the</source>
          <target state="translated">如果您使用延迟写入（请参见下面的&amp;ldquo; &lt;a href=&quot;#Deferred-Writing&quot;&gt;延迟写入&amp;rdquo;&lt;/a&gt;），那么您写入数组的数据将不会直接写入文件；而是将其保存在</target>
        </trans-unit>
        <trans-unit id="4f2793be84e03f881815cfd6cbd437f560ace728" translate="yes" xml:space="preserve">
          <source>If you use either the R_IAFTER or R_IBEFORE flags, the &lt;code&gt;$key&lt;/code&gt; parameter will have the record number of the inserted key/value pair set.</source>
          <target state="translated">如果使用R_IAFTER或R_IBEFORE标志，则 &lt;code&gt;$key&lt;/code&gt; 参数将设置插入的键/值对的记录号。</target>
        </trans-unit>
        <trans-unit id="7804e89f419dfb4afe57d175e577f649678035a8" translate="yes" xml:space="preserve">
          <source>If you use gcc, make sure your installation is recent and complete. perl versions since 5.6.0 build fine with gcc &amp;gt; 2.8.1 on Solaris &amp;gt;= 2.6.</source>
          <target state="translated">如果您使用gcc，请确保您的安装是最新且完整的。从5.6.0开始的perl版本可以在Solaris&amp;gt; = 2.6上使用gcc&amp;gt; 2.8.1很好地构建。</target>
        </trans-unit>
        <trans-unit id="c133e612772c5c91ca38653bb618cdde5ecf7eea" translate="yes" xml:space="preserve">
          <source>If you use one of the undocumented functions below, you may wish to consider creating and submitting documentation for it. If your patch is accepted, this will indicate that the interface is stable (unless it is explicitly marked otherwise).</source>
          <target state="translated">如果你使用了以下未记录的功能,你可能会考虑为它创建并提交文档。如果你的补丁被接受,这将表明该接口是稳定的(除非它有明确的标记)。</target>
        </trans-unit>
        <trans-unit id="97a1d75ada82bbf9f654420e7c70ad3899b98121" translate="yes" xml:space="preserve">
          <source>If you use preprocessor directives to choose one of two versions of a function, use</source>
          <target state="translated">如果你使用预处理器指令来选择一个函数的两个版本中的一个,使用</target>
        </trans-unit>
        <trans-unit id="32e7fdaa4b2e816b8b9a792f2d7c56bbe0d52ad7" translate="yes" xml:space="preserve">
          <source>If you use the 4DOS/NT or similar command shell, note that &quot;pl2bat&quot; uses the &quot;%*&quot; variable in the generated batch file to refer to all the command line arguments, so you may need to make sure that construct works in batch files. As of this writing, 4DOS/NT users will need a &quot;ParameterChar = *&quot; statement in their 4NT.INI file or will need to execute &quot;setdos /p*&quot; in the 4DOS/NT startup file to enable this to work.</source>
          <target state="translated">如果您使用4DOS/NT或类似的命令外壳,请注意 &quot;pl2bat &quot;在生成的批处理文件中使用&quot;%*&quot;变量来引用所有的命令行参数,所以您可能需要确保该结构在批处理文件中工作。在写这篇文章时,4DOS/NT用户将需要在他们的4NT.INI文件中使用 &quot;ParameterChar=*&quot;语句,或者需要在4DOS/NT启动文件中执行 &quot;setdos /p*&quot;来使其工作。</target>
        </trans-unit>
        <trans-unit id="91300f437c633a42a75ef31ebaae0d2065c281bd" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; PerlIO layer for input, invalid byte sequences are handled gracefully, but if you use &lt;code&gt;:utf8&lt;/code&gt; , the flag is set without validating the data, possibly resulting in this error message.</source>
          <target state="translated">如果将 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; PerlIO层用作输入，则可以正常处理无效的字节序列，但是如果使用 &lt;code&gt;:utf8&lt;/code&gt; ，则将设置标志而不验证数据，这可能会导致此错误消息。</target>
        </trans-unit>
        <trans-unit id="c99f058cbb6ca20108d91c09dfe4c9c7ca4b2109" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; PerlIO layer for input, invalid byte sequences are handled gracefully, but if you use &lt;code&gt;:utf8&lt;/code&gt;, the flag is set without validating the data, possibly resulting in this error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eecf6412d7114c8844a3dfb8554c44c0eb8598c" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;SA_SIGINFO&lt;/code&gt; flag, the signal handler will in addition to the first argument, the signal name, also receive a second argument, a hash reference, inside which are the following keys with the following semantics, as defined by POSIX/SUSv3:</source>
          <target state="translated">如果使用 &lt;code&gt;SA_SIGINFO&lt;/code&gt; 标志，则信号处理程序除了第一个参数（信号名称）之外，还将接收第二个参数（哈希引用），在其中包含具有POSIX / SUSv3定义的下列语义的键：</target>
        </trans-unit>
        <trans-unit id="dc06c253841f15b9de0c355618356ed5550da10d" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;\G&lt;/code&gt; anchor, you force the match after &lt;code&gt;22&lt;/code&gt; to start with the &lt;code&gt;a&lt;/code&gt; . The regular expression cannot match there since it does not find a digit, so the next match fails and the match operator returns the pairs it already found.</source>
          <target state="translated">如果你使用 &lt;code&gt;\G&lt;/code&gt; 主播，你强迫赛后 &lt;code&gt;22&lt;/code&gt; 开始与 &lt;code&gt;a&lt;/code&gt; 。正则表达式无法在此处匹配，因为它找不到数字，因此下一次匹配失败，并且match运算符返回它已经找到的对。</target>
        </trans-unit>
        <trans-unit id="b510ad2eb535862884ae7cf62a7e26f96276ab1c" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;\G&lt;/code&gt; anchor, you force the match after &lt;code&gt;22&lt;/code&gt; to start with the &lt;code&gt;a&lt;/code&gt;. The regular expression cannot match there since it does not find a digit, so the next match fails and the match operator returns the pairs it already found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb20a66ed661494874fa5e98a73f246a9cc34cc" translate="yes" xml:space="preserve">
          <source>If you use the English module, you can even read the variable names:</source>
          <target state="translated">如果你使用英文模块,你甚至可以读取变量名。</target>
        </trans-unit>
        <trans-unit id="5c03e0261fc0b7da7836c0a3093ff6c1dacfba33" translate="yes" xml:space="preserve">
          <source>If you use the VC IDE, you will have to run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abbbac8010fcf4e1f8177dc8b18103356d7c1579" translate="yes" xml:space="preserve">
          <source>If you use the form &lt;code&gt;\N{&lt;i&gt;character name&lt;/i&gt;}&lt;/code&gt;, the &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt; module gets automatically loaded. This may not be suitable for the test level you are doing.</source>
          <target state="translated">如果您使用 &lt;code&gt;\N{&lt;i&gt;character name&lt;/i&gt;}&lt;/code&gt; 格式，则&lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;模块将自动加载。这可能不适合您正在执行的测试级别。</target>
        </trans-unit>
        <trans-unit id="b6639f5cfc711b71b35423e81c784a209aabfc93" translate="yes" xml:space="preserve">
          <source>If you use the hash syntax, you have no control over the order in which the ExtraSubFields are stored, plus you cannot have SubFields with duplicate ID.</source>
          <target state="translated">如果你使用哈希语法,你就无法控制ExtraSubFields的存储顺序,另外你也不能拥有ID重复的SubFields。</target>
        </trans-unit>
        <trans-unit id="cf9048b3298377c86c20ad5d8b5d02655bc3f8b6" translate="yes" xml:space="preserve">
          <source>If you use the raw format, and the &lt;code&gt;Strict&lt;/code&gt; option is enabled, &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; will check that &lt;code&gt;$rawdata&lt;/code&gt; consists of zero or more conformant sub-fields. When &lt;code&gt;Strict&lt;/code&gt; is disabled, &lt;code&gt;$rawdata&lt;/code&gt; can consist of any arbitrary byte stream.</source>
          <target state="translated">如果您使用原始格式，并且启用了 &lt;code&gt;Strict&lt;/code&gt; 选项，则 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 将检查 &lt;code&gt;$rawdata&lt;/code&gt; 包含零个或更多个一致的子字段。当 &lt;code&gt;Strict&lt;/code&gt; 禁止， &lt;code&gt;$rawdata&lt;/code&gt; 可以由任意字节流的。</target>
        </trans-unit>
        <trans-unit id="c067123fb137430de0f256b297d516b2001d264a" translate="yes" xml:space="preserve">
          <source>If you use utf8 or other non-ASCII characters with Test::More you might get a &quot;Wide character in print&quot; warning. Using &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt; STDOUT, &quot;:utf8&quot;&lt;/code&gt; will not fix it. &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; (which powers Test::More) duplicates STDOUT and STDERR. So any changes to them, including changing their output disciplines, will not be seem by Test::More.</source>
          <target state="translated">如果在Test :: More中使用utf8或其他非ASCII字符，则可能会收到&amp;ldquo;正在打印宽字符&amp;rdquo;警告。使用 &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt; STDOUT, &quot;:utf8&quot;&lt;/code&gt; 将无法修复它。&lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt;（为Test :: More提供动力）复制了STDOUT和STDERR。因此，Test :: More不会对它们进行任何更改，包括更改其输出学科。</target>
        </trans-unit>
        <trans-unit id="d00aea3e7b59229d34e146319ce9c85454b14e11" translate="yes" xml:space="preserve">
          <source>If you use utf8 or other non-ASCII characters with Test::More you might get a &quot;Wide character in print&quot; warning. Using &lt;code&gt;binmode STDOUT, &quot;:utf8&quot;&lt;/code&gt; will not fix it. &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; (which powers Test::More) duplicates STDOUT and STDERR. So any changes to them, including changing their output disciplines, will not be seen by Test::More.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630840ae944c06429550447e9540c0ca707dbc1a" translate="yes" xml:space="preserve">
          <source>If you used WinZip, this was already done for you.</source>
          <target state="translated">如果你使用的是WinZip,这已经为你完成了。</target>
        </trans-unit>
        <trans-unit id="8c53b3ef6362ad03c7dbea52d0c4786e608f8e77" translate="yes" xml:space="preserve">
          <source>If you used git to check out the Perl source, then using &lt;code&gt;git
format-patch&lt;/code&gt; will produce a patch in a style suitable for Perl. The &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format-patch&lt;/a&gt;&lt;/code&gt; command produces one patch file for each commit you made. If you prefer to send a single patch for all commits, you can use &lt;code&gt;git diff&lt;/code&gt; .</source>
          <target state="translated">如果您使用git签出Perl源代码，则使用 &lt;code&gt;git format-patch&lt;/code&gt; 将以适合Perl的样式生成补丁。该 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format-patch&lt;/a&gt;&lt;/code&gt; 命令会为每一个承诺，你做一个补丁文件。如果您希望为所有提交发送一个补丁，则可以使用 &lt;code&gt;git diff&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="005c2baa346d58318121715604db7b7de9beda44" translate="yes" xml:space="preserve">
          <source>If you used git to check out the Perl source, then using &lt;code&gt;git format-patch&lt;/code&gt; will produce a patch in a style suitable for Perl. The &lt;code&gt;format-patch&lt;/code&gt; command produces one patch file for each commit you made. If you prefer to send a single patch for all commits, you can use &lt;code&gt;git diff&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc21e512fb418bd39c6e536f3bdd95478cb7d3c" translate="yes" xml:space="preserve">
          <source>If you want $x to have a certain sign, use one of the following methods:</source>
          <target state="translated">如果你想让$x有一个特定的符号,使用以下方法之一。</target>
        </trans-unit>
        <trans-unit id="1553678828e2328fa0aa14746ccfdd7229ce26f6" translate="yes" xml:space="preserve">
          <source>If you want *.ucm installed together with the modules, do as follows;</source>
          <target state="translated">如果你想让*.ucm和模块一起安装,请按以下步骤进行。</target>
        </trans-unit>
        <trans-unit id="3a9e72b266b57bba86c6eccbfed06538dcba5011" translate="yes" xml:space="preserve">
          <source>If you want a &quot;real&quot; C &lt;a href=&quot;http://man.he.net/man2/open&quot;&gt;open(2)&lt;/a&gt;, then you should use the &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt; function, which involves no such magic (but uses different filemodes than Perl &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;, which corresponds to C &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen(3)&lt;/a&gt;). This is another way to protect your filenames from interpretation. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="791324333537699862b9ce903fa1af5980ed496f" translate="yes" xml:space="preserve">
          <source>If you want a &quot;real&quot; C &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; (see</source>
          <target state="translated">如果要 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; &amp;ldquo;真实的&amp;rdquo; C （请参阅</target>
        </trans-unit>
        <trans-unit id="c13df57b95397c5f1d723459f0b855e899e41a8a" translate="yes" xml:space="preserve">
          <source>If you want a &quot;real&quot; C &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; (see</source>
          <target state="translated">如果要 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; &amp;ldquo;真实的&amp;rdquo; C （请参阅</target>
        </trans-unit>
        <trans-unit id="cb1d7bd468d379f255df6d0a8a45090fecae8882" translate="yes" xml:space="preserve">
          <source>If you want a Perl application to process and present your data according to a particular locale, the application code should include the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma (see &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;The use locale pragma&lt;/a&gt;) where appropriate, and &lt;b&gt;at least one&lt;/b&gt; of the following must be true:</source>
          <target state="translated">如果您希望Perl应用程序根据特定的语言环境处理和显示数据，则该应用程序代码应在适当的地方包含 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma（请参阅Use &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;locale pragma&lt;/a&gt;），并且&lt;b&gt;以下至少一项&lt;/b&gt;必须为true：</target>
        </trans-unit>
        <trans-unit id="7f64cf3c950fcdad95bf25b3cb5fe1e64c6e318a" translate="yes" xml:space="preserve">
          <source>If you want a Perl application to process and present your data according to a particular locale, the application code should include the &lt;code&gt;use locale&lt;/code&gt; pragma (see &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;&quot;The &quot;use locale&quot; pragma&quot;&lt;/a&gt;) where appropriate, and &lt;b&gt;at least one&lt;/b&gt; of the following must be true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8f1faa6c36903ecd5d1abeecfdbd92380ab3a3" translate="yes" xml:space="preserve">
          <source>If you want a better approximation of the square root, then use:</source>
          <target state="translated">如果你想要一个更好的平方根近似值,那就用。</target>
        </trans-unit>
        <trans-unit id="409579e935815d3f9b1b191e4808eba939430e40" translate="yes" xml:space="preserve">
          <source>If you want a completely new Test::Builder object different from the singleton, use &lt;code&gt;create&lt;/code&gt; .</source>
          <target state="translated">如果您想要一个不同于单例的全新Test :: Builder对象，请使用 &lt;code&gt;create&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9078ce92d169ba5491de791cf112f90cf0081697" translate="yes" xml:space="preserve">
          <source>If you want a completely new Test::Builder object different from the singleton, use &lt;code&gt;create&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04cafbc1f6bcd93d15d82018f51a268c90603bc8" translate="yes" xml:space="preserve">
          <source>If you want a list of all of the Perl module filenames, you can use &lt;a href=&quot;File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="364287807494857e0923c716161b8323aaaa85ad" translate="yes" xml:space="preserve">
          <source>If you want a list of all of the Perl module filenames, you can use &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt;:</source>
          <target state="translated">如果要列出所有Perl模块文件名，可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File :: Find :: Rule&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="20d03f9f8d59c035c39fd85e8955d33568507a9f" translate="yes" xml:space="preserve">
          <source>If you want a real Perl scalar, use &lt;code&gt;numify()&lt;/code&gt; :</source>
          <target state="translated">如果您想要一个真正的Perl标量，请使用 &lt;code&gt;numify()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b8b877d7756b903200810e1071cc23b772cf0635" translate="yes" xml:space="preserve">
          <source>If you want a real Perl scalar, use &lt;code&gt;numify()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9309fd012fc6beaef72da428ac578230d08f400e" translate="yes" xml:space="preserve">
          <source>If you want a supported version of perl for OpenVOS, purchase the OpenVOS GNU Tools product from Stratus Technologies, along with a support contract (or from anyone else who will sell you support).</source>
          <target state="translated">如果你想要一个支持OpenVOS的perl版本,请从Stratus Technologies购买OpenVOS GNU Tools产品,同时购买一份支持合同(或者从其他愿意向你提供支持的人那里购买)。</target>
        </trans-unit>
        <trans-unit id="6584c0a384e584f13abe302cec979af6b67c1d61" translate="yes" xml:space="preserve">
          <source>If you want a true copy of $x, use:</source>
          <target state="translated">如果你想得到$x的真实副本,使用:</target>
        </trans-unit>
        <trans-unit id="2bd3ed425ef919c14360d525b51cc98be9af477c" translate="yes" xml:space="preserve">
          <source>If you want access to threads, you must &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; before you &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . &lt;a href=&quot;../threads&quot;&gt;threads&lt;/a&gt; will emit a warning if you use it after &lt;a href=&quot;shared&quot;&gt;threads::shared&lt;/a&gt;.</source>
          <target state="translated">如果要访问线程，则必须先 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 然后再 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; 。如果在&lt;a href=&quot;shared&quot;&gt;thread :: shared&lt;/a&gt;之后使用&lt;a href=&quot;../threads&quot;&gt;线程，&lt;/a&gt;则线程将发出警告。</target>
        </trans-unit>
        <trans-unit id="e8a2798b257a3670f42de6843d7775eac47d562b" translate="yes" xml:space="preserve">
          <source>If you want access to threads, you must &lt;code&gt;use threads&lt;/code&gt; before you &lt;code&gt;use threads::shared&lt;/code&gt;. &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; will emit a warning if you use it after &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ffb4d0fb6b209221b80f1da704496ad8ce1ebe0" translate="yes" xml:space="preserve">
          <source>If you want an IDE, check the following (in alphabetical order, not order of preference):</source>
          <target state="translated">如果你想要一个IDE,请检查以下内容(按字母顺序,而不是偏好顺序)。</target>
        </trans-unit>
        <trans-unit id="0cc35691082ef1d0bc8a1a1a8c2c6b40d9490aba" translate="yes" xml:space="preserve">
          <source>If you want anything fancier, consider overriding this with something that uses &lt;a href=&quot;Number::Format&quot;&gt;Number::Format&lt;/a&gt;, or does something else entirely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe93301108d8dca54392bf8f900a5e24a5258416" translate="yes" xml:space="preserve">
          <source>If you want anything fancier, consider overriding this with something that uses &lt;a href=&quot;http://search.cpan.org/perldoc/Number::Format&quot;&gt;Number::Format&lt;/a&gt;, or does something else entirely.</source>
          <target state="translated">如果您需要任何高级功能，请考虑使用&lt;a href=&quot;http://search.cpan.org/perldoc/Number::Format&quot;&gt;Number :: Format&lt;/a&gt;或完全执行其他操作来替代它。</target>
        </trans-unit>
        <trans-unit id="03e2f095ee9c1b96484a23c04f5e5dfef232e04c" translate="yes" xml:space="preserve">
          <source>If you want build some core extensions statically into perl's dll, specify them in the STATIC_EXT macro.</source>
          <target state="translated">如果你想把一些核心扩展静态地构建到perl的dll中,在STATIC_EXT宏中指定它们。</target>
        </trans-unit>
        <trans-unit id="18b0e9b36c2f4eaca25552fa7c7631a4398f6336" translate="yes" xml:space="preserve">
          <source>If you want finer granularity than the 1 second that the &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; function provides, the easiest way is to use the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; function as documented in &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;. Try the &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; and the &lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Itimer&quot;&gt;BSD::Itimer&lt;/a&gt; modules (available from CPAN, and starting from Perl 5.8 &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; is part of the standard distribution).</source>
          <target state="translated">如果你想超过1秒的更细的粒度 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 函数提供了最简单的方法是使用 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 函数中记载&lt;a href=&quot;functions/select&quot;&gt;选择&lt;/a&gt;。尝试使用&lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Itimer&quot;&gt;BSD :: Itimer&lt;/a&gt;模块（可从CPAN获得，从Perl 5.8开始，&lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt;是标准发行版的一部分）。</target>
        </trans-unit>
        <trans-unit id="938f7da4d45d138e899952c66b47a7d1e1a162f3" translate="yes" xml:space="preserve">
          <source>If you want finer granularity than the 1 second that the &lt;code&gt;sleep()&lt;/code&gt; function provides, the easiest way is to use the &lt;code&gt;select()&lt;/code&gt; function as documented in &lt;a href=&quot;perlfunc#select&quot;&gt;&quot;select&quot; in perlfunc&lt;/a&gt;. Try the &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; and the &lt;a href=&quot;BSD::Itimer&quot;&gt;BSD::Itimer&lt;/a&gt; modules (available from CPAN, and starting from Perl 5.8 &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; is part of the standard distribution).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e14afa459a95e2ee1097bdb5d465fc670f04bf72" translate="yes" xml:space="preserve">
          <source>If you want it to be a Unicode string (because you want character semantics with operations like regular expression matching), you need to decode the UTF8-encoded content and have Perl convert it into a Unicode string:</source>
          <target state="translated">如果你想让它成为一个Unicode字符串(因为你想通过正则表达式匹配等操作获得字符语义),你需要对UTF8编码的内容进行解码,并让Perl将其转换为Unicode字符串。</target>
        </trans-unit>
        <trans-unit id="b68288a6982fc2b55a1d1fa4ad5b3ecc68be5d47" translate="yes" xml:space="preserve">
          <source>If you want more flexibility, you need to configure your CPAN client for your particular situation.</source>
          <target state="translated">如果您想要更多的灵活性,您需要根据您的特殊情况配置您的CPAN客户端。</target>
        </trans-unit>
        <trans-unit id="212545de9d894bed7fa89be5bf884693fe7c603b" translate="yes" xml:space="preserve">
          <source>If you want no headers or footers output in the HTML, set these options to the empty string.</source>
          <target state="translated">如果您不想在HTML中输出页眉或页脚,请将这些选项设置为空字符串。</target>
        </trans-unit>
        <trans-unit id="c2f8c74db8ed8406f2f6e08a05e2a2be5038e9a9" translate="yes" xml:space="preserve">
          <source>If you want perl to use globbing that emulates the quirks of DOS filename conventions, you might want to consider using File::DosGlob to override the internal glob() implementation. See &lt;a href=&quot;File::DosGlob&quot;&gt;File::DosGlob&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be3f922578397a2f9698c9c71abc2a55e6ed43d" translate="yes" xml:space="preserve">
          <source>If you want perl to use globbing that emulates the quirks of DOS filename conventions, you might want to consider using File::DosGlob to override the internal glob() implementation. See &lt;a href=&quot;file/dosglob&quot;&gt;File::DosGlob&lt;/a&gt; for details.</source>
          <target state="translated">如果您希望perl使用模仿DOS文件名约定古怪的globbing，则可能要考虑使用File :: DosGlob覆盖内部glob（）实现。有关详细信息，请参见&lt;a href=&quot;file/dosglob&quot;&gt;File :: DosGlob&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="08c46a24da2bb06c6e1c6ef38a1abe76f47d9a13" translate="yes" xml:space="preserve">
          <source>If you want read lines, you must read in list context.</source>
          <target state="translated">如果你想读行,你必须在列表上下文中读。</target>
        </trans-unit>
        <trans-unit id="9bfb8a43a2ce5fcca125d20e873c4c7b11aed7e7" translate="yes" xml:space="preserve">
          <source>If you want the &lt;code&gt;atexit()&lt;/code&gt; syntax (and an &lt;code&gt;rmexit()&lt;/code&gt; as well), try the &lt;code&gt;AtExit&lt;/code&gt; module available from CPAN.</source>
          <target state="translated">如果需要 &lt;code&gt;atexit()&lt;/code&gt; 语法（以及 &lt;code&gt;rmexit()&lt;/code&gt; ），请尝试使用CPAN 的 &lt;code&gt;AtExit&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="124ea0ab66186e4216274d303cbf33e4b47044f9" translate="yes" xml:space="preserve">
          <source>If you want the array index, use the &lt;code&gt;firstidx()&lt;/code&gt; function from &lt;code&gt;List::MoreUtils&lt;/code&gt; :</source>
          <target state="translated">如果需要数组索引，请使用 &lt;code&gt;List::MoreUtils&lt;/code&gt; 的 &lt;code&gt;firstidx()&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="7239c9f8360ace04be0d87fc661805fd9a93d6bc" translate="yes" xml:space="preserve">
          <source>If you want the array index, use the &lt;code&gt;firstidx()&lt;/code&gt; function from &lt;code&gt;List::MoreUtils&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7615fa2a66b55733775cb5d887a00d84846653ee" translate="yes" xml:space="preserve">
          <source>If you want the code to die instead of falling back, use &lt;code&gt;only&lt;/code&gt; instead:</source>
          <target state="translated">如果您想使代码消失而不是回退，请 &lt;code&gt;only&lt;/code&gt; 使用：</target>
        </trans-unit>
        <trans-unit id="5f643e51c29ad1dcf8382df154f107e9e891d49b" translate="yes" xml:space="preserve">
          <source>If you want the code to die instead, replace &quot;try&quot; with &quot;only&quot;:</source>
          <target state="translated">如果你想让代码死掉,把 &quot;try &quot;改为 &quot;only&quot;。</target>
        </trans-unit>
        <trans-unit id="444d833c4fe34c4ebf55ce0643031f3aa4615d34" translate="yes" xml:space="preserve">
          <source>If you want the equivalent of &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Foo ()&lt;/code&gt; , use a module but not import anything, use &lt;code&gt;require_ok&lt;/code&gt; .</source>
          <target state="translated">如果要 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Foo ()&lt;/code&gt; 等效，请使用模块但不导入任何内容，请使用 &lt;code&gt;require_ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd47c89733a2d362efea4a574e386c3bfd848c97" translate="yes" xml:space="preserve">
          <source>If you want the equivalent of &lt;code&gt;use Foo ()&lt;/code&gt;, use a module but not import anything, use &lt;code&gt;require_ok&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ebff181122cf920b540aa12f6f2468119acea8d" translate="yes" xml:space="preserve">
          <source>If you want the old signal behavior back despite possible memory corruption, set the environment variable &lt;code&gt;PERL_SIGNALS&lt;/code&gt; to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; . This feature first appeared in Perl 5.8.1.</source>
          <target state="translated">如果尽管内存可能损坏，也希望恢复旧的信号行为，请将环境变量 &lt;code&gt;PERL_SIGNALS&lt;/code&gt; 设置为 &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; 。此功能最早出现在Perl 5.8.1中。</target>
        </trans-unit>
        <trans-unit id="829231163ed3602e1f949c7395523d09b04596b6" translate="yes" xml:space="preserve">
          <source>If you want the old signal behavior back despite possible memory corruption, set the environment variable &lt;code&gt;PERL_SIGNALS&lt;/code&gt; to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt;. This feature first appeared in Perl 5.8.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35e2e89a1af9e4f4ab883e1fb265f28d997edb48" translate="yes" xml:space="preserve">
          <source>If you want these output in a sorted order, see &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;: &quot;How do I sort a hash (optionally by value instead of key)?&quot;.</source>
          <target state="translated">如果要按排序顺序输出这些输出，请参见&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;：&amp;ldquo;如何对哈希进行排序（可选地按值而不是键）？&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7b0e9370dc85f7e9dd08b608d45bee75d87d8584" translate="yes" xml:space="preserve">
          <source>If you want this event to cause the test to exit you should return the exit code here. Exit code of 0 means exit success, any other integer means exit with failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d12a2eb6658b08fd22781ffd73216531f2e651bd" translate="yes" xml:space="preserve">
          <source>If you want this feature, check out Yanick Champoux's &lt;code&gt;Git::CPAN::Patch&lt;/code&gt; distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1340d84f704d5f6a74163cc5fe06ae9be150fb8b" translate="yes" xml:space="preserve">
          <source>If you want to &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; into a string, you just have to &amp;lt;open&amp;gt; a filehandle to a string, which Perl has been able to do since Perl 5.6:</source>
          <target state="translated">如果要 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 字符串，只需&amp;lt;open&amp;gt;字符串的文件句柄，这是Perl自Perl 5.6起就能做到的：</target>
        </trans-unit>
        <trans-unit id="1004705c5f21359bd47871c5e63f216b6160306f" translate="yes" xml:space="preserve">
          <source>If you want to &lt;code&gt;write&lt;/code&gt; into a string, you just have to &amp;lt;open&amp;gt; a filehandle to a string, which Perl has been able to do since Perl 5.6:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7953e238f104e2cdb7abf22e43568bf172380a8b" translate="yes" xml:space="preserve">
          <source>If you want to CLONE all objects you will need to keep track of them per package. This is simply done using a hash and Scalar::Util::weaken().</source>
          <target state="translated">如果你想克隆所有的对象,你需要对每个包进行跟踪。这可以通过使用哈希和Scalar::Util::weaken()来完成。</target>
        </trans-unit>
        <trans-unit id="8a750f90ba1cfc2d81f044342057667c6ac1726e" translate="yes" xml:space="preserve">
          <source>If you want to actually extract the matching elements, simply use grep in list context.</source>
          <target state="translated">如果你想实际提取匹配的元素,只需在列表上下文中使用grep。</target>
        </trans-unit>
        <trans-unit id="d026b5d2f0b8d0ebf6352db336c8a293bea0fac9" translate="yes" xml:space="preserve">
          <source>If you want to add your encoding to Encode's demand-loading list (so you don't have to &quot;use Encode::YourEncoding&quot;), run</source>
          <target state="translated">如果您想将您的编码添加到Encode的需求加载列表中(所以您不必 &quot;使用Encode::YourEncoding&quot;),运行</target>
        </trans-unit>
        <trans-unit id="3ceac82578bb19fb50532d7256faa44ce8c265df" translate="yes" xml:space="preserve">
          <source>If you want to append something to the end of string stored in an &lt;code&gt;SV*&lt;/code&gt; , you can use the following functions:</source>
          <target state="translated">如果要将某些内容附加到 &lt;code&gt;SV*&lt;/code&gt; 存储的字符串的末尾，可以使用以下功能：</target>
        </trans-unit>
        <trans-unit id="20a16bcf2cf6427a4518ce31b1b9b97af29e8c74" translate="yes" xml:space="preserve">
          <source>If you want to append something to the end of string stored in an &lt;code&gt;SV*&lt;/code&gt;, you can use the following functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abff1ef9e65ec72186150da0b667016af8485105" translate="yes" xml:space="preserve">
          <source>If you want to be sure that you're calling &lt;code&gt;isa&lt;/code&gt; as a method, not a class, check the invocand with &lt;code&gt;blessed&lt;/code&gt; from &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt; first:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fbae8e9319ec5948bcc63aa24cae46d2c786676" translate="yes" xml:space="preserve">
          <source>If you want to be sure that you're calling &lt;code&gt;isa&lt;/code&gt; as a method, not a class, check the invocand with &lt;code&gt;blessed&lt;/code&gt; from &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; first:</source>
          <target state="translated">如果你想确保你调用 &lt;code&gt;isa&lt;/code&gt; 作为一种方法，而不是一个班，请与invocand &lt;code&gt;blessed&lt;/code&gt; 从&lt;a href=&quot;scalar/util&quot;&gt;标量::的Util&lt;/a&gt;第一：</target>
        </trans-unit>
        <trans-unit id="363081145dde14f7c8fd4e2bf011a936ad34c73a" translate="yes" xml:space="preserve">
          <source>If you want to break apart an entire line of fixed columns, you can use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the A (ASCII) format. By using a number after the format specifier, you can denote the column width. See the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; entries in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="translated">如果要分解固定行的整行，可以使用A（ASCII）格式的 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 。通过在格式说明符后面使用数字，可以表示列宽。见 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 的条目&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;更多细节。</target>
        </trans-unit>
        <trans-unit id="619aad3b3e732995b6ff437174735944e21882dc" translate="yes" xml:space="preserve">
          <source>If you want to break apart an entire line of fixed columns, you can use &lt;code&gt;unpack&lt;/code&gt; with the A (ASCII) format. By using a number after the format specifier, you can denote the column width. See the &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; entries in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e8c447f2a79196fb827a87399f6352fddeb35d" translate="yes" xml:space="preserve">
          <source>If you want to build the docs yourself, and have</source>
          <target state="translated">如果你想自己建立文档,并拥有</target>
        </trans-unit>
        <trans-unit id="3016ac8f3431196221d3334c73f10b4a58c7afce" translate="yes" xml:space="preserve">
          <source>If you want to call C from Perl, start with &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;, moving on to &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;, &lt;a href=&quot;xsubpp&quot;&gt;xsubpp&lt;/a&gt;, and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;. If you want to call Perl from C, then read &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;, &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;, and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;. Don't forget that you can learn a lot from looking at how the authors of existing extension modules wrote their code and solved their problems.</source>
          <target state="translated">如果要从Perl调用C，请从&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;开始，然后转到&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;，&lt;a href=&quot;xsubpp&quot;&gt;xsubpp&lt;/a&gt;和&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;。如果要从C调用Perl，请阅读&lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;，&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;和&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;。不要忘记，通过查看现有扩展模块的作者如何编写代码并解决问题，您可以学到很多东西。</target>
        </trans-unit>
        <trans-unit id="315a4534923af9a32596760e1e243392c92b8033" translate="yes" xml:space="preserve">
          <source>If you want to cancel one or several commits, you can use &lt;code&gt;git reset&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548a69c6108c24555301c111e716c92968ea1230" translate="yes" xml:space="preserve">
          <source>If you want to check exactly, compare the string with its NFC/NFKC/FCC.</source>
          <target state="translated">如果你想确切地检查,将该字符串与其NFC/NFKC/FCC进行比较。</target>
        </trans-unit>
        <trans-unit id="59c2fb7af17b706fe9c70e8baa09126e5a3d250b" translate="yes" xml:space="preserve">
          <source>If you want to compress all</source>
          <target state="translated">如果你想压缩所有的</target>
        </trans-unit>
        <trans-unit id="4a7c9a973da32835e6a4f4be3eeeb0d732a06249" translate="yes" xml:space="preserve">
          <source>If you want to configure your module files for local conditions, or to automatically insert a version number, you can use EUMM's &lt;code&gt;PL_FILES&lt;/code&gt; capability, where it will automatically run each</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcfdbb5379f221cca1d97f7787d1bc312424003" translate="yes" xml:space="preserve">
          <source>If you want to control warnings on the fly, do something like this. Make sure you do the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; first, or you won't be able to get at the enable() or disable() methods.</source>
          <target state="translated">如果您想即时控制警告，请执行以下操作。确保先 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ，否则将无法使用enable（）或disable（）方法。</target>
        </trans-unit>
        <trans-unit id="20be3407cc52b51a764f0e8c0b7ea78b6fd0df8b" translate="yes" xml:space="preserve">
          <source>If you want to control warnings on the fly, do something like this. Make sure you do the &lt;code&gt;use&lt;/code&gt; first, or you won't be able to get at the enable() or disable() methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a42c1db2cee198b239c3cde06a946cab4e064353" translate="yes" xml:space="preserve">
          <source>If you want to control what functions Test::More will export, you have to use the 'import' option. For example, to import everything but 'fail', you'd do:</source>
          <target state="translated">如果你想控制 Test::More 会导出哪些函数,你必须使用 'import' 选项。例如,要导入除 &quot;fail &quot;以外的所有函数,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="be1e5234b80eb1f923a376bc3491ec3ca6b109b2" translate="yes" xml:space="preserve">
          <source>If you want to convert the returned map to entirely scalar numbers, you can use something like this:</source>
          <target state="translated">如果你想把返回的地图完全转换为标量数,你可以使用类似这样的方法。</target>
        </trans-unit>
        <trans-unit id="7adae9875339a373afa10e8d5fe3748778b7c17f" translate="yes" xml:space="preserve">
          <source>If you want to convert to UTF-8 from encodings other than the native (Latin1 or EBCDIC), see &lt;a href=&quot;#sv_recode_to_utf8&quot;&gt;&quot;sv_recode_to_utf8&quot;&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba04eeea7231f6480afed51584cd45a160a944a" translate="yes" xml:space="preserve">
          <source>If you want to convert to UTF-8 from encodings other than the native (Latin1 or EBCDIC), see &lt;a href=&quot;#sv_recode_to_utf8&quot;&gt;sv_recode_to_utf8&lt;/a&gt;().</source>
          <target state="translated">如果要从非本地编码（Latin1或EBCDIC）转换为UTF-8，请参见&lt;a href=&quot;#sv_recode_to_utf8&quot;&gt;sv_recode_to_utf8&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="228fa3459a576d7c7cf5495612539d6810b0138e" translate="yes" xml:space="preserve">
          <source>If you want to create a zip64 zip file with the OO interface you must specify the &lt;code&gt;Zip64&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53c24008e3ed2beeee61bb3c00b23e9cec000bd1" translate="yes" xml:space="preserve">
          <source>If you want to create many anonymous handles, you should check out the Symbol or IO::Handle modules.</source>
          <target state="translated">如果你想创建许多匿名句柄,你应该查看Symbol或IO::Handle模块。</target>
        </trans-unit>
        <trans-unit id="d3f92af00462a48927ab51881cd3156c2dfab08a" translate="yes" xml:space="preserve">
          <source>If you want to create the file if it does not already exist then bitwise-OR (&lt;code&gt;|&lt;/code&gt;) &lt;code&gt;O_CREAT&lt;/code&gt; too. If you omit &lt;code&gt;O_CREAT&lt;/code&gt; and the database does not already exist then the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call will fail.</source>
          <target state="translated">如果要创建尚不存在的文件，则也可以按位或（ &lt;code&gt;|&lt;/code&gt; ） &lt;code&gt;O_CREAT&lt;/code&gt; 。如果省略 &lt;code&gt;O_CREAT&lt;/code&gt; 并且数据库尚不存在，则 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用将失败。</target>
        </trans-unit>
        <trans-unit id="fc98ab804f43ba09ba7d693b95e26eb63a6ad833" translate="yes" xml:space="preserve">
          <source>If you want to create the file if it does not already exist then bitwise-OR (&lt;code&gt;|&lt;/code&gt;) &lt;code&gt;O_CREAT&lt;/code&gt; too. If you omit &lt;code&gt;O_CREAT&lt;/code&gt; and the database does not already exist then the &lt;code&gt;tie&lt;/code&gt; call will fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a116b633c8c619c49052dbd9a5c72113a8975d85" translate="yes" xml:space="preserve">
          <source>If you want to create the file if it does not exist, add &lt;code&gt;O_CREAT&lt;/code&gt; to any of these, as in the example. If you omit &lt;code&gt;O_CREAT&lt;/code&gt; and the file does not already exist, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call will fail.</source>
          <target state="translated">如果要创建不存在的文件，请在示例中将 &lt;code&gt;O_CREAT&lt;/code&gt; 添加到其中的任何一个。如果省略 &lt;code&gt;O_CREAT&lt;/code&gt; 且该文件尚不存在，则 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用将失败。</target>
        </trans-unit>
        <trans-unit id="95ab7bc04f484a14dcd9279bd03d23b179493ba9" translate="yes" xml:space="preserve">
          <source>If you want to create the file if it does not exist, add &lt;code&gt;O_CREAT&lt;/code&gt; to any of these, as in the example. If you omit &lt;code&gt;O_CREAT&lt;/code&gt; and the file does not already exist, the &lt;code&gt;tie&lt;/code&gt; call will fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e3b712f48285cffa7900ceeb1af82270cd7a609" translate="yes" xml:space="preserve">
          <source>If you want to cycle through an array endlessly, you can increment the index modulo the number of elements in the array:</source>
          <target state="translated">如果你想无休止地循环浏览一个数组,你可以用数组中元素的数量来递增索引。</target>
        </trans-unit>
        <trans-unit id="6cfb6d26bc5df670c402213d4036f3bf58558df4" translate="yes" xml:space="preserve">
          <source>If you want to debug some other testfile, set the &lt;code&gt;TEST_FILE&lt;/code&gt; variable thusly:</source>
          <target state="translated">如果要调试其他测试文件，请按以下方式设置 &lt;code&gt;TEST_FILE&lt;/code&gt; 变量：</target>
        </trans-unit>
        <trans-unit id="6048d807c79fe8c274777ea98164bb2677fd3a0f" translate="yes" xml:space="preserve">
          <source>If you want to delete your temporary branch, you may do so with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b931492f8ba265d923d9e6b394913c2adf2d8e1f" translate="yes" xml:space="preserve">
          <source>If you want to disallow any rearrangement, pass &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;[]&lt;/code&gt; (a reference to empty list) as the value for this key.</source>
          <target state="translated">如果要禁止任何重新排列，请将 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;[]&lt;/code&gt; （对空列表的引用）作为此键的值传递。</target>
        </trans-unit>
        <trans-unit id="54957337acd4e58dbb0d89d2b021227b45f4fede" translate="yes" xml:space="preserve">
          <source>If you want to disallow any rearrangement, pass &lt;code&gt;undef&lt;/code&gt; or &lt;code&gt;[]&lt;/code&gt; (a reference to empty list) as the value for this key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e399c3f8eff9b2e3be1dfd1cb3c6e184f3c80005" translate="yes" xml:space="preserve">
          <source>If you want to do something when the object is destroyed, you can define a &lt;code&gt;DESTROY&lt;/code&gt; method in your class. This method will always be called by Perl at the appropriate time, unless the method is empty.</source>
          <target state="translated">如果要在销毁对象时执行某些操作，则可以在类中定义 &lt;code&gt;DESTROY&lt;/code&gt; 方法。除非该方法为空，否则Perl将始终在适当的时间调用此方法。</target>
        </trans-unit>
        <trans-unit id="028499023abecf52141490b3dc52996a2e6540e8" translate="yes" xml:space="preserve">
          <source>If you want to do something with the REGEXP* later use SvRX instead and check for NULL.</source>
          <target state="translated">如果你以后想用REGEXP*做一些事情,就用SvRX代替,并检查是否为NULL。</target>
        </trans-unit>
        <trans-unit id="5bec0b0d71b7e3b535fad4f2a98d0fdea0b5611d" translate="yes" xml:space="preserve">
          <source>If you want to do the same thing to modify the values of the hash, you can use the &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; function. As of Perl 5.6 the values are not copied, so if you modify $orbit (in this case), you modify the value.</source>
          <target state="translated">如果您想做同样的事情来修改哈希值，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 函数。从Perl 5.6开始，不会复制值，因此，如果您修改$ orbit（在这种情况下），则会修改该值。</target>
        </trans-unit>
        <trans-unit id="935f14135388c5b598f55e1dc3d822934fdf377b" translate="yes" xml:space="preserve">
          <source>If you want to do the same thing to modify the values of the hash, you can use the &lt;code&gt;values&lt;/code&gt; function. As of Perl 5.6 the values are not copied, so if you modify $orbit (in this case), you modify the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1befe6f0c8cce90a523721cdcb6a3e759a8bf613" translate="yes" xml:space="preserve">
          <source>If you want to downgrade a warning that has been escalated into a fatal error back to a normal warning, you can use the &quot;NONFATAL&quot; keyword. For example, the code below will promote all warnings into fatal errors, except for those in the &quot;syntax&quot; category.</source>
          <target state="translated">如果你想把已经升级为致命错误的警告降级为正常警告,可以使用 &quot;NONFATAL &quot;关键字。例如,下面的代码将把所有的警告升级为致命错误,除了那些 &quot;语法 &quot;类的警告。</target>
        </trans-unit>
        <trans-unit id="aaac7464ef1e41e8e3656bb3c9f1373b9810c3d2" translate="yes" xml:space="preserve">
          <source>If you want to encode a large file, you should encode it in chunks that are a multiple of 57 bytes. This ensures that the base64 lines line up and that you do not end up with padding in the middle. 57 bytes of data fills one complete base64 line (76 == 57*4/3):</source>
          <target state="translated">如果你想对一个大文件进行编码,你应该以57字节的倍数进行编码。这可以确保base64行的行数,而且你不会在中间有填充物。57个字节的数据填满一个完整的base64行(76 ==57*4/3)。</target>
        </trans-unit>
        <trans-unit id="526764856cb11f1625c51adabbc0827d170cf65b" translate="yes" xml:space="preserve">
          <source>If you want to enter a multi-line command, such as a subroutine definition with several statements or a format, escape the newline that would normally end the debugger command with a backslash. Here's an example:</source>
          <target state="translated">如果你想输入一个多行命令,比如一个子程序定义有几条语句或一个格式,请用反斜杠转义通常会结束调试器命令的新行。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="1c27e6ce335738d835ec3fdd82f6c0809ffefc5e" translate="yes" xml:space="preserve">
          <source>If you want to find out how many characters are waiting, there's also the FIONREAD ioctl call to be looked at. The</source>
          <target state="translated">如果你想知道有多少字符在等待,还可以看看FIONREAD ioctl调用。这个</target>
        </trans-unit>
        <trans-unit id="1da1084e18df9224120de5015e0f47b55cae04d1" translate="yes" xml:space="preserve">
          <source>If you want to find out how many entries have a defined value, that's a bit different. You have to check each value. A &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; is handy:</source>
          <target state="translated">如果要找出有多少个条目具有定义的值，那有点不同。您必须检查每个值。一个 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 很方便：</target>
        </trans-unit>
        <trans-unit id="0d72620df0696cc4732b993d293ab2b11520eef6" translate="yes" xml:space="preserve">
          <source>If you want to find out how many entries have a defined value, that's a bit different. You have to check each value. A &lt;code&gt;grep&lt;/code&gt; is handy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308cd4ff0bf951ae1c4968d0825997ff4ae0e702" translate="yes" xml:space="preserve">
          <source>If you want to find the package calling your code, perhaps to give better diagnostics as &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; does, use the &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; built-in:</source>
          <target state="translated">如果您想找到调用您代码的包，也许像&lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt;一样可以提供更好的诊断，请使用内置的 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 程序：</target>
        </trans-unit>
        <trans-unit id="7e82876e02cb96090e26d86eedc47e176c7a8339" translate="yes" xml:space="preserve">
          <source>If you want to find the package calling your code, perhaps to give better diagnostics as &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; does, use the &lt;code&gt;caller&lt;/code&gt; built-in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3665b99091562c54c0340f04e5f55207f573bbfd" translate="yes" xml:space="preserve">
          <source>If you want to force strings to be interpreted as numbers, you could say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db0a89fa31368a04df7fab37ca05a2304cb913c7" translate="yes" xml:space="preserve">
          <source>If you want to generate new style events, events that do many things at once, then you want the &lt;code&gt;*ev2*&lt;/code&gt; methods. These let you directly specify which facets you wish to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f109680f15bd3886268c0dd93d91471450a599" translate="yes" xml:space="preserve">
          <source>If you want to get at a slice (part of a row) in a multidimensional array, you're going to have to do some fancy subscripting. That's because while we have a nice synonym for single elements via the pointer arrow for dereferencing, no such convenience exists for slices.</source>
          <target state="translated">如果你想在一个多维数组中获取一个切片(行的一部分),你将不得不做一些花哨的下标。这是因为,虽然我们有一个很好的同义词,可以通过指针箭头来实现单元素的取消引用,但对于切片却没有这样的便利。</target>
        </trans-unit>
        <trans-unit id="ac8d06c0714514adee4900ccc907acf01c17734d" translate="yes" xml:space="preserve">
          <source>If you want to get warned when the fallback occurs, replace &quot;try&quot; with &quot;lib&quot;:</source>
          <target state="translated">如果你想在回退发生时得到警告,用 &quot;lib &quot;代替 &quot;try&quot;。</target>
        </trans-unit>
        <trans-unit id="c34f1861cd969edfd158d72b53e2b8bf861c0838" translate="yes" xml:space="preserve">
          <source>If you want to have arrays of constant strings, note carefully the right combination of &lt;code&gt;const&lt;/code&gt; s:</source>
          <target state="translated">如果要使用常量字符串数组，请仔细注意 &lt;code&gt;const&lt;/code&gt; 的正确组合：</target>
        </trans-unit>
        <trans-unit id="356345ab0ce94a5efc2714f6ef0d68b5cc2c3066" translate="yes" xml:space="preserve">
          <source>If you want to have arrays of constant strings, note carefully the right combination of &lt;code&gt;const&lt;/code&gt;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc85c01bbb2e5546a912901548bde68e7f312959" translate="yes" xml:space="preserve">
          <source>If you want to have static strings, make them constant:</source>
          <target state="translated">如果你想拥有静态字符串,就把它们变成常量。</target>
        </trans-unit>
        <trans-unit id="5f28aad16a41ad668dc6d2a20ee81e5f9b0af321" translate="yes" xml:space="preserve">
          <source>If you want to have your cake and eat it too, you need a more complicated boilerplate.</source>
          <target state="translated">如果你想吃你的蛋糕,也想吃它,你需要一个更复杂的模板。</target>
        </trans-unit>
        <trans-unit id="732754bf3b16a13d947b836156896a3b2cedc031" translate="yes" xml:space="preserve">
          <source>If you want to indent the text in the here document, you can do this:</source>
          <target state="translated">如果你想在这里的文档中缩进文字,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="d6b9e98bf75fad13fa324d37df3fb0822a303c98" translate="yes" xml:space="preserve">
          <source>If you want to influence compilation of calls to a specific subroutine, then use &lt;a href=&quot;#cv_set_call_checker&quot;&gt;cv_set_call_checker&lt;/a&gt; rather than hooking checking of all &lt;code&gt;entersub&lt;/code&gt; ops.</source>
          <target state="translated">如果要影响对特定子例程的调用的编译，请使用&lt;a href=&quot;#cv_set_call_checker&quot;&gt;cv_set_call_checker&lt;/a&gt;而不是对所有 &lt;code&gt;entersub&lt;/code&gt; op进行挂钩检查。</target>
        </trans-unit>
        <trans-unit id="e66b9245a42c5136074f90bbcaa24c2089883633" translate="yes" xml:space="preserve">
          <source>If you want to influence compilation of calls to a specific subroutine, then use &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;&quot;cv_set_call_checker_flags&quot;&lt;/a&gt; rather than hooking checking of all &lt;code&gt;entersub&lt;/code&gt; ops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d06034c9b20f332ef6d3aafef878e55cf37779" translate="yes" xml:space="preserve">
          <source>If you want to inherit the parent thread's locale, you can, in the parent, set a variable like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168d6eb05b72021bb2cefd5586f5642721fb25b0" translate="yes" xml:space="preserve">
          <source>If you want to install a distribution from the current directory, you can tell &lt;code&gt;CPAN.pm&lt;/code&gt; to install &lt;code&gt;.&lt;/code&gt; (the full stop):</source>
          <target state="translated">如果要从当前目录安装发行版，可以告诉 &lt;code&gt;CPAN.pm&lt;/code&gt; 安装 &lt;code&gt;.&lt;/code&gt; （句号）：</target>
        </trans-unit>
        <trans-unit id="33e2d2f8b434b4a1cc7c6346d405264c8380bf51" translate="yes" xml:space="preserve">
          <source>If you want to install modules for your own use, the easiest way might be &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local::lib&lt;/a&gt;, which you can download from CPAN. It sets various installation settings for you, and uses those same settings within your programs.</source>
          <target state="translated">如果要安装自己使用的模块，最简单的方法可能是&lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local :: lib&lt;/a&gt;，可以从CPAN下载。它为您设置各种安装设置，并在程序中使用相同的设置。</target>
        </trans-unit>
        <trans-unit id="b3dae34f8c2a04f0b25691fed783ebc83dba7816" translate="yes" xml:space="preserve">
          <source>If you want to install modules for your own use, the easiest way might be &lt;a href=&quot;local::lib&quot;&gt;local::lib&lt;/a&gt;, which you can download from CPAN. It sets various installation settings for you, and uses those same settings within your programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d2dc539671f427bbae58845aceababd0159c6c" translate="yes" xml:space="preserve">
          <source>If you want to know as little about Perl as possible but need to add a new encoding, just read this chapter and forget the rest.</source>
          <target state="translated">如果你想尽可能少地了解Perl,但又需要添加一个新的编码,只要读完这一章,其他的就不用管了。</target>
        </trans-unit>
        <trans-unit id="56e1fbcaca6130206229f6c3c8cb0c2d52fb54b7" translate="yes" xml:space="preserve">
          <source>If you want to know how Perl OO works under the hood, the &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; document explains the nitty gritty details.</source>
          <target state="translated">如果您想了解Perl OO的&lt;a href=&quot;perlobj&quot;&gt;幕后&lt;/a&gt;工作原理，请参阅perlobj文档，以了解具体细节。</target>
        </trans-unit>
        <trans-unit id="9f23a106d53e80c8c0f8d1f2b0c84d08d1054140" translate="yes" xml:space="preserve">
          <source>If you want to know how to handle automated testing for your distribution, you can check the environment. The CPAN Testers, for instance, set the value of &lt;code&gt;AUTOMATED_TESTING&lt;/code&gt; :</source>
          <target state="translated">如果您想知道如何处理发行版的自动化测试，则可以检查环境。例如，CPAN测试器设置 &lt;code&gt;AUTOMATED_TESTING&lt;/code&gt; 的值：</target>
        </trans-unit>
        <trans-unit id="9b495e524dc71177b8e643e1224800f20371e451" translate="yes" xml:space="preserve">
          <source>If you want to know how to handle automated testing for your distribution, you can check the environment. The CPAN Testers, for instance, set the value of &lt;code&gt;AUTOMATED_TESTING&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a57ed6abdc67a27c928054414c38fcc1c565d58" translate="yes" xml:space="preserve">
          <source>If you want to know if the scalar value is TRUE, you can use:</source>
          <target state="translated">如果你想知道标量值是否为TRUE,你可以使用。</target>
        </trans-unit>
        <trans-unit id="f0f2be398a4f429a704b8881af39ff31858188bb" translate="yes" xml:space="preserve">
          <source>If you want to know if this variable (or any other SV) is actually &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt;, you can call:</source>
          <target state="translated">如果您想知道是否实际 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 此变量（或任何其他SV），可以调用：</target>
        </trans-unit>
        <trans-unit id="daea143b4968577fdbd42832858949f2fd1cdff0" translate="yes" xml:space="preserve">
          <source>If you want to know if this variable (or any other SV) is actually &lt;code&gt;defined&lt;/code&gt;, you can call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c60925561c19aa1767251e2aee467af3279de6f" translate="yes" xml:space="preserve">
          <source>If you want to know whether a particular scalar refers to an object, you can use the &lt;code&gt;blessed&lt;/code&gt; function exported by &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt;, which is shipped with the Perl core.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4282549729bb35373ef94d2e2b64ea8af51a5d06" translate="yes" xml:space="preserve">
          <source>If you want to know whether a particular scalar refers to an object, you can use the &lt;code&gt;blessed&lt;/code&gt; function exported by &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;, which is shipped with the Perl core.</source>
          <target state="translated">如果您想知道特定的标量是否指向对象，可以使用Perl核心附带的&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;导出的 &lt;code&gt;blessed&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="056d8ddf16a11d708261878d4f200cc28e75de75" translate="yes" xml:space="preserve">
          <source>If you want to learn more about Perl 6, or have a desire to help in the crusade to make Perl a better place then read the Perl 6 developers page at &lt;a href=&quot;http://www.perl6.org/&quot;&gt;http://www.perl6.org/&lt;/a&gt; and get involved.</source>
          <target state="translated">如果您想了解有关Perl 6的更多信息，或者希望帮助他们使Perl变得更好，请阅读位于&lt;a href=&quot;http://www.perl6.org/&quot;&gt;http://www.perl6.org/&lt;/a&gt;的Perl 6开发人员页面，并参与其中。</target>
        </trans-unit>
        <trans-unit id="00255f60e5cd77d55f44acd05aa25f0d59366611" translate="yes" xml:space="preserve">
          <source>If you want to learn the basics of Perl, you might start with the Llama book, which assumes that you already know a little about programming:</source>
          <target state="translated">如果你想学习Perl的基础知识,你可以从Llama这本书开始,这本书假设你已经对编程有一点了解。</target>
        </trans-unit>
        <trans-unit id="b59f1075805db9d0b1d16e3fcdbf9d21e65a49a6" translate="yes" xml:space="preserve">
          <source>If you want to limit yourself to a much more narrow definition of what a version string constitutes, &lt;code&gt;is_strict()&lt;/code&gt; is limited to version strings like the following list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859f839c744c136d7bdf5037e58bd0e9887e2618" translate="yes" xml:space="preserve">
          <source>If you want to load a subclass from a file that &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; would not consider an eligible filename (that is, it does not end in either &lt;code&gt;.pm&lt;/code&gt; or &lt;code&gt;.pmc&lt;/code&gt;), use the following code:</source>
          <target state="translated">如果要从 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 不考虑合格文件名的文件中加载子类（即，文件名不以 &lt;code&gt;.pm&lt;/code&gt; 或 &lt;code&gt;.pmc&lt;/code&gt; 结尾），请使用以下代码：</target>
        </trans-unit>
        <trans-unit id="1e6ddafbd419154de1f46300a143dfff13d40dbc" translate="yes" xml:space="preserve">
          <source>If you want to load a subclass from a file that &lt;code&gt;require&lt;/code&gt; would not consider an eligible filename (that is, it does not end in either &lt;code&gt;.pm&lt;/code&gt; or &lt;code&gt;.pmc&lt;/code&gt;), use the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43171de60cc7817f0c0ddd386dd67107ef6f821" translate="yes" xml:space="preserve">
          <source>If you want to load the entire file, you can use the &lt;a href=&quot;Path::Tiny&quot;&gt;Path::Tiny&lt;/a&gt; module to do it in one simple and efficient step:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63bacba7c0db3c9f406fbf3ba9dec50a07c74303" translate="yes" xml:space="preserve">
          <source>If you want to load the entire file, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Path::Tiny&quot;&gt;Path::Tiny&lt;/a&gt; module to do it in one simple and efficient step:</source>
          <target state="translated">如果要加载整个文件，可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/Path::Tiny&quot;&gt;Path :: Tiny&lt;/a&gt;模块通过一个简单而有效的步骤来完成它：</target>
        </trans-unit>
        <trans-unit id="b17927939e60f1cedd222b2461104e02f72f02d9" translate="yes" xml:space="preserve">
          <source>If you want to make a real copy, use the following:</source>
          <target state="translated">如果你想做一个真正的副本,请使用以下方法。</target>
        </trans-unit>
        <trans-unit id="85008415a7eb8c5259c1befce3f088e509e6063e" translate="yes" xml:space="preserve">
          <source>If you want to make changes to someone else's topic branch, you should check with its creator before making any change to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="011cab076badf929a664e79819f2251ac21c5335" translate="yes" xml:space="preserve">
          <source>If you want to make the SV drop its string buffer, use &lt;code&gt;sv_force_normal_flags(sv, SV_COW_DROP_PV)&lt;/code&gt; or simply &lt;code&gt;sv_setsv(sv, NULL)&lt;/code&gt; .</source>
          <target state="translated">如果要使SV删除其字符串缓冲区，请使用 &lt;code&gt;sv_force_normal_flags(sv, SV_COW_DROP_PV)&lt;/code&gt; 或仅使用 &lt;code&gt;sv_setsv(sv, NULL)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e876f29c89b13d2955e7ddc7b720fb71debcd99e" translate="yes" xml:space="preserve">
          <source>If you want to make the SV drop its string buffer, use &lt;code&gt;sv_force_normal_flags(sv, SV_COW_DROP_PV)&lt;/code&gt; or simply &lt;code&gt;sv_setsv(sv, NULL)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686e0dae9b58a50551e5307de1a432fa51bae3cd" translate="yes" xml:space="preserve">
          <source>If you want to make use of the new features available in Berkeley DB 2.x or greater, use the Perl module &lt;a href=&quot;https://metacpan.org/pod/BerkeleyDB&quot;&gt;BerkeleyDB&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7523637fc2645186f899696d73931e051d6c52" translate="yes" xml:space="preserve">
          <source>If you want to make use of the new features available in Berkeley DB 2.x or greater, use the Perl module &lt;b&gt;BerkeleyDB&lt;/b&gt; instead.</source>
          <target state="translated">如果要利用Berkeley DB 2.x或更高版本中可用的新功能，请改用Perl模块&lt;b&gt;BerkeleyDB&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="610bb38fb99d325c8e7fefe0a23a02b343634382" translate="yes" xml:space="preserve">
          <source>If you want to modify the debugger, copy</source>
          <target state="translated">如果你想修改调试器,请复制</target>
        </trans-unit>
        <trans-unit id="68a89277cf24a3194f901f3f723f1840c4c2f27b" translate="yes" xml:space="preserve">
          <source>If you want to open either STDIN or STDOUT with &lt;code&gt;gzopen&lt;/code&gt; , you can now optionally use the special filename &quot;&lt;code&gt;-&lt;/code&gt; &quot; as a synonym for &lt;code&gt;\*STDIN&lt;/code&gt; and &lt;code&gt;\*STDOUT&lt;/code&gt; .</source>
          <target state="translated">如果要使用 &lt;code&gt;gzopen&lt;/code&gt; 打开STDIN或STDOUT ，则现在可以选择使用特殊文件名&amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;rdquo;作为 &lt;code&gt;\*STDIN&lt;/code&gt; 和 &lt;code&gt;\*STDOUT&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="47c9bd4478a0c2ce9ccca6507ec4f47c10afe7d5" translate="yes" xml:space="preserve">
          <source>If you want to open either STDIN or STDOUT with &lt;code&gt;gzopen&lt;/code&gt;, you can now optionally use the special filename &quot;&lt;code&gt;-&lt;/code&gt;&quot; as a synonym for &lt;code&gt;\*STDIN&lt;/code&gt; and &lt;code&gt;\*STDOUT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41fd5af244837759f6e880c0fa8c36bc7f07f26" translate="yes" xml:space="preserve">
          <source>If you want to overload a Perl operator, such as &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;**&lt;/code&gt; , then you'll want to use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; pragma, documented in &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;.</source>
          <target state="translated">如果要重载Perl运算符（例如 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;**&lt;/code&gt; )，则需要使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 编译指示，该&lt;a href=&quot;overload&quot;&gt;重载&lt;/a&gt;记录在重载中。</target>
        </trans-unit>
        <trans-unit id="71a40071766dc5d5747b55ec51fa1862eac4c688" translate="yes" xml:space="preserve">
          <source>If you want to overload a Perl operator, such as &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;**&lt;/code&gt;, then you'll want to use the &lt;code&gt;use overload&lt;/code&gt; pragma, documented in &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ce9bc615c09fb69253d86037255e2b78a92d09" translate="yes" xml:space="preserve">
          <source>If you want to override a predefined function, such as open(), then you'll have to import the new definition from a different module. See &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;&quot;Overriding Built-in Functions&quot; in perlsub&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="945aa8bcea0076aea35d4a81e4ba840ff11ec82e" translate="yes" xml:space="preserve">
          <source>If you want to override a predefined function, such as open(), then you'll have to import the new definition from a different module. See &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;Overriding Built-in Functions in perlsub&lt;/a&gt;.</source>
          <target state="translated">如果要覆盖预定义的函数，例如open（），则必须从其他模块导入新定义。请参见&lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;在perlsub中重写内置函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa48921f25a631295f915526fc8a70c73af7fbf8" translate="yes" xml:space="preserve">
          <source>If you want to override the mapping of Hangul syllables, NFD and NFKD are not appropriate, since NFD and NFKD will decompose Hangul syllables before overriding. FCD may decompose Hangul syllables as the case may be.</source>
          <target state="translated">如果要覆盖Hangul音节的映射,NFD和NFKD是不合适的,因为NFD和NFKD会在覆盖之前分解Hangul音节。FCD可以根据情况分解Hangul音节。</target>
        </trans-unit>
        <trans-unit id="a2d7808a54f71b111b57ef9e68ce46ce86f7a686" translate="yes" xml:space="preserve">
          <source>If you want to package the Perl DLLs (one for WINS, one for ARMI), the headers, and the documentation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e047de81a230edfe4349188d5e8044f9337baa8" translate="yes" xml:space="preserve">
          <source>If you want to package the PerlApp sources:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab41e5eda5a02ddfb48b24411170b91dc8f23c72" translate="yes" xml:space="preserve">
          <source>If you want to package the perl.exe and miniperl.exe, you can use the perlexe.sis and miniperlexe.sis make targets. You also probably want the perllib.sis for the libraries and maybe even the perlapp.sis for the recognizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c827c3a5508b73a4c675d093f91220233b7dc11" translate="yes" xml:space="preserve">
          <source>If you want to pass arguments to the Perl subroutine, you can add strings to the &lt;code&gt;NULL&lt;/code&gt; -terminated &lt;code&gt;args&lt;/code&gt; list passed to</source>
          <target state="translated">如果要将参数传递给Perl子例程，则可以将字符串添加到传递给 &lt;code&gt;NULL&lt;/code&gt; 终止的 &lt;code&gt;args&lt;/code&gt; 列表中</target>
        </trans-unit>
        <trans-unit id="9fe959ed77f2d03a4c32411d66f89a3b169a2e6b" translate="yes" xml:space="preserve">
          <source>If you want to pass arguments to the Perl subroutine, you can add strings to the &lt;code&gt;NULL&lt;/code&gt;-terminated &lt;code&gt;args&lt;/code&gt; list passed to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0b08e235edf0d26d308eb349b59ea3ef72cb9d" translate="yes" xml:space="preserve">
          <source>If you want to pass more than one array or hash into a function--or return them from it--and have them maintain their integrity, then you're going to have to use an explicit pass-by-reference. Before you do that, you need to understand references as detailed in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. This section may not make much sense to you otherwise.</source>
          <target state="translated">如果您想将多个数组或哈希传递给一个函数（或从中返回它们）并保持它们的完整性，那么您将不得不使用显式的按引用传递。在此之前，您需要了解&lt;a href=&quot;perlref&quot;&gt;perlref中&lt;/a&gt;详细介绍的参考。否则，本节对您可能没有多大意义。</target>
        </trans-unit>
        <trans-unit id="c8a70766df71ba2d4b4ce04954ec69dff30a7c0f" translate="yes" xml:space="preserve">
          <source>If you want to pass switches into your script, you can use one of the &lt;code&gt;Getopts&lt;/code&gt; modules or put a loop on the front like this:</source>
          <target state="translated">如果要将开关传递到脚本中，则可以使用 &lt;code&gt;Getopts&lt;/code&gt; 模块之一，也可以像这样在前面放置一个循环：</target>
        </trans-unit>
        <trans-unit id="d40edffb04fe413946f227532d6ff1f352d417e2" translate="yes" xml:space="preserve">
          <source>If you want to port your own favourite C library for big numbers to the Math::BigInt interface, you can take any of the already existing modules as a rough guideline. You should really wrap up the latest Math::BigInt and Math::BigFloat testsuites with your module, and replace in them any of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4bd2c5192aedd065d255be14f3583448bb4e171" translate="yes" xml:space="preserve">
          <source>If you want to port your own favourite c-lib for big numbers to the Math::BigInt interface, you can take any of the already existing modules as a rough guideline. You should really wrap up the latest BigInt and BigFloat testsuites with your module, and replace in them any of the following:</source>
          <target state="translated">如果你想把你自己喜欢的大数c-lib移植到Math::BigInt接口上,你可以把任何一个已经存在的模块作为一个粗略的指导方针。你应该将最新的BigInt和BigFloat测试套件与你的模块一起打包,并替换其中的任何一个模块。</target>
        </trans-unit>
        <trans-unit id="edf16417cd93b7c19e3e333701fc067e37f8d0a5" translate="yes" xml:space="preserve">
          <source>If you want to position the file for &lt;a href=&quot;#sysread-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;&lt;code&gt;sysread&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#syswrite-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;&lt;code&gt;syswrite&lt;/code&gt;&lt;/a&gt;, don't use &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;, because buffering makes its effect on the file's read-write position unpredictable and non-portable. Use &lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;sysseek&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376b22a241cce9ba252fd1c8a6df064f6b6eac08" translate="yes" xml:space="preserve">
          <source>If you want to position the file for &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;, don't use &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, because buffering makes its effect on the file's read-write position unpredictable and non-portable. Use &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果要将文件定位为 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; ，请不要使用 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; ，因为缓冲会使它对文件的读写位置的影响不可预测且不可移植。请改用 &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab53baa73269bc54f793e2d56860c5115ebd11f4" translate="yes" xml:space="preserve">
          <source>If you want to position the file for &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;, don't use &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, because buffering makes its effect on the file's read-write position unpredictable and non-portable. Use &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果要将文件定位为 &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; ，请不要使用 &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; ，因为缓冲会使它对文件的读写位置的影响不可预测且不可移植。请改用 &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0c3e6b22044730d55d9a0c06443157660dba6ef" translate="yes" xml:space="preserve">
          <source>If you want to preserve any existing contents, then you want to open the file in append mode. As in the shell, in Perl you use &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; to open an existing file in append mode. &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; creates the file if it does not already exist.</source>
          <target state="translated">如果要保留任何现有内容，则要以附加模式打开文件。与在Shell中一样，在Perl中，您可以使用 &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 以附加模式打开现有文件。如果文件不存在，则 &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 创建该文件。</target>
        </trans-unit>
        <trans-unit id="17bd731415d5d66dc3d1ddceae18e6e16a628145" translate="yes" xml:space="preserve">
          <source>If you want to preserve the original hashes, copy one hash (&lt;code&gt;%hash1&lt;/code&gt; ) to a new hash (&lt;code&gt;%new_hash&lt;/code&gt; ), then add the keys from the other hash (&lt;code&gt;%hash2&lt;/code&gt; to the new hash. Checking that the key already exists in &lt;code&gt;%new_hash&lt;/code&gt; gives you a chance to decide what to do with the duplicates:</source>
          <target state="translated">如果要保留原始哈希， &lt;code&gt;%hash1&lt;/code&gt; 一个哈希（％hash1）复制到新哈希（ &lt;code&gt;%new_hash&lt;/code&gt; ），然后将另一个哈希（ &lt;code&gt;%hash2&lt;/code&gt; ）中的密钥添加到新哈希中。检查密钥是否已存在于 &lt;code&gt;%new_hash&lt;/code&gt; 中让您有机会决定如何处理重复项：</target>
        </trans-unit>
        <trans-unit id="63a3234ab9d086d5117080e1694d17f6063efd88" translate="yes" xml:space="preserve">
          <source>If you want to preserve the original hashes, copy one hash (&lt;code&gt;%hash1&lt;/code&gt;) to a new hash (&lt;code&gt;%new_hash&lt;/code&gt;), then add the keys from the other hash (&lt;code&gt;%hash2&lt;/code&gt; to the new hash. Checking that the key already exists in &lt;code&gt;%new_hash&lt;/code&gt; gives you a chance to decide what to do with the duplicates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f7b3c025841bfcdb1aab514c8e2d8e36fbc766" translate="yes" xml:space="preserve">
          <source>If you want to print the whole thing, though, you can't say</source>
          <target state="translated">不过,如果你想把整个事情打印出来,你不能说</target>
        </trans-unit>
        <trans-unit id="a688a8a7ff8d4400e1c5937f70dbd49815b89f90" translate="yes" xml:space="preserve">
          <source>If you want to process all sections, even if they're not targeted for you, call this before you start parsing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93f1e3a9ebfe45627e0241306de345142f514db8" translate="yes" xml:space="preserve">
          <source>If you want to provide config to the source you can use:</source>
          <target state="translated">如果你想为源码提供配置,你可以使用。</target>
        </trans-unit>
        <trans-unit id="9f3a66952ab51429c329502faae26a704977a338" translate="yes" xml:space="preserve">
          <source>If you want to read a gzip file a line at a time and have it respect the &lt;code&gt;$/&lt;/code&gt; variable (or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; , or &lt;code&gt;$RS&lt;/code&gt; when &lt;code&gt;English&lt;/code&gt; is in use) see &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt;.</source>
          <target state="translated">如果你想读一个gzip文件在一个时间线，并把它尊重 &lt;code&gt;$/&lt;/code&gt; 变量（或 &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; ，或 &lt;code&gt;$RS&lt;/code&gt; 当 &lt;code&gt;English&lt;/code&gt; 在使用中）看到&lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO ::解压缩::用gunzip&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0160e4f5dbef362c1a03e51ec2cddded373c9cc7" translate="yes" xml:space="preserve">
          <source>If you want to read a gzip file a line at a time and have it respect the &lt;code&gt;$/&lt;/code&gt; variable (or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt;, or &lt;code&gt;$RS&lt;/code&gt; when &lt;code&gt;English&lt;/code&gt; is in use) see &lt;a href=&quot;IO::Uncompress::Gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d31f53859a4168c72e90a2128210958319d4f50" translate="yes" xml:space="preserve">
          <source>If you want to read from a text file, first open it in read-only mode like this:</source>
          <target state="translated">如果你想从一个文本文件中读取,首先以只读模式打开它,像这样。</target>
        </trans-unit>
        <trans-unit id="87011e177a00565655904726c281857b45b374f1" translate="yes" xml:space="preserve">
          <source>If you want to rebase a personal topic branch, you will have to delete your existing topic branch and push as a new version of it. You can do this via the following formula (see the explanation about &lt;code&gt;refspec&lt;/code&gt;'s in the git push documentation for details) after you have rebased your branch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ab6b15624972e8c18a42d8d83c1cd6a30cfb30" translate="yes" xml:space="preserve">
          <source>If you want to release a 'beta' or 'alpha' version of a module but don't want CPAN.pm to list it as most recent use an '_' after the regular version number followed by at least 2 digits, eg. 1.20_01. If you do this, the following idiom is recommended:</source>
          <target state="translated">如果您想发布一个模块的 &quot;beta &quot;或 &quot;alpha &quot;版本,但又不想让CPAN.pm把它列为最新版本,请在常规版本号后面加上一个&quot;_&quot;,后面至少跟两个数字,例如:1.20_01。如果您这样做,建议使用以下的习惯用语。</target>
        </trans-unit>
        <trans-unit id="aec7d886a6e5c93bd394402ec290052fc195c585" translate="yes" xml:space="preserve">
          <source>If you want to remove the line terminator from your here-docs, use &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果要从here-docs中删除行终止符，请使用 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="272ecc9c9621686a80692664d0c1217296386dd2" translate="yes" xml:space="preserve">
          <source>If you want to remove the line terminator from your here-docs, use &lt;code&gt;chomp()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b69a42c3c7880bfb1671d398c3d54c0775a7ac" translate="yes" xml:space="preserve">
          <source>If you want to report a bug in Perl, or browse existing Perl bugs and patches, use the GitHub issue tracker at &lt;a href=&quot;https://github.com/perl/perl5/issues&quot;&gt;https://github.com/perl/perl5/issues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db615c188722d8560c52e776e317416a34e011c1" translate="yes" xml:space="preserve">
          <source>If you want to report a bug in Perl, you must use the</source>
          <target state="translated">如果你想报告Perl中的一个错误,你必须使用</target>
        </trans-unit>
        <trans-unit id="f2154f64aff6e9940c9fb796b1289c8d854d7ca5" translate="yes" xml:space="preserve">
          <source>If you want to represent quotation marks inside a quotation-mark-delimited field, escape them with backslashes (eg, &lt;code&gt;&quot;like \&quot;this\&quot;&quot;&lt;/code&gt; .</source>
          <target state="translated">如果要在用引号引起来的字段中表示引号，请使用反斜杠对其进行转义（例如 &lt;code&gt;&quot;like \&quot;this\&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="addfd131b393c5c4b432b77bcfe15c8060aec494" translate="yes" xml:space="preserve">
          <source>If you want to represent quotation marks inside a quotation-mark-delimited field, escape them with backslashes (eg, &lt;code&gt;&quot;like \&quot;this\&quot;&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824f7654e0ed811f4acc48396871cdac5a94cdda" translate="yes" xml:space="preserve">
          <source>If you want to retain the UTF-x code points then in script form you might want to write:</source>
          <target state="translated">如果你想保留UTF-x码点,那么在脚本形式下,你可以写。</target>
        </trans-unit>
        <trans-unit id="2c2c9c1a65a810709ccd4ab8e9bc83e0091df0bc" translate="yes" xml:space="preserve">
          <source>If you want to retrieve the time at which the file was last read, written, or had its meta-data (owner, etc) changed, you use the &lt;b&gt;-A&lt;/b&gt;, &lt;b&gt;-M&lt;/b&gt;, or &lt;b&gt;-C&lt;/b&gt; file test operations as documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. These retrieve the age of the file (measured against the start-time of your program) in days as a floating point number. Some platforms may not have all of these times. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for details. To retrieve the &quot;raw&quot; time in seconds since the epoch, you would call the stat function, then use &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;POSIX::strftime()&lt;/code&gt; to convert this into human-readable form.</source>
          <target state="translated">如果要检索文件的上一次读取，写入或更改其元数据（所有者等）的时间，请使用&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;记录的&lt;b&gt;-A&lt;/b&gt;，&lt;b&gt;-M&lt;/b&gt;或&lt;b&gt;-C&lt;/b&gt;文件测试操作。它们以天为单位检索文件的生存期（以程序的开始时间为准），以天为单位。某些平台可能没有所有这些时间。有关详细信息，请参见&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;。要检索自该纪元以来的&amp;ldquo;原始&amp;rdquo;时间（以秒为单位），您可以调用stat函数，然后使用 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;POSIX::strftime()&lt;/code&gt; 将其转换为人类可读的形式。</target>
        </trans-unit>
        <trans-unit id="3c0db177b448ef2ea4c3aecad4e767f4cc4d9798" translate="yes" xml:space="preserve">
          <source>If you want to retrieve the time at which the file was last read, written, or had its meta-data (owner, etc) changed, you use the &lt;b&gt;-A&lt;/b&gt;, &lt;b&gt;-M&lt;/b&gt;, or &lt;b&gt;-C&lt;/b&gt; file test operations as documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. These retrieve the age of the file (measured against the start-time of your program) in days as a floating point number. Some platforms may not have all of these times. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for details. To retrieve the &quot;raw&quot; time in seconds since the epoch, you would call the stat function, then use &lt;code&gt;localtime()&lt;/code&gt;, &lt;code&gt;gmtime()&lt;/code&gt;, or &lt;code&gt;POSIX::strftime()&lt;/code&gt; to convert this into human-readable form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea86bc2e0842c32d086b82e0b936c78284136301" translate="yes" xml:space="preserve">
          <source>If you want to run an external command and still keep your Perl process going, look at a piped &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果您想运行外部命令并且仍然保持Perl进程继续进行，请查看管道的 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3f78cfe37d3db27661bac9c838b06f1955541c1" translate="yes" xml:space="preserve">
          <source>If you want to run an external command and still keep your Perl process going, look at a piped &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;fork&lt;/code&gt;, or &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec243e8883915ce98e61a2fb629a6bec35df46c" translate="yes" xml:space="preserve">
          <source>If you want to run any of the tests yourself manually using e.g. valgrind, please note that by default perl &lt;b&gt;does not&lt;/b&gt; explicitly cleanup all the memory it has allocated (such as global memory arenas) but instead lets the exit() of the whole program &quot;take care&quot; of such allocations, also known as &quot;global destruction of objects&quot;.</source>
          <target state="translated">如果您想使用valgrind等手动运行任何测试，请注意，默认情况下，perl &lt;b&gt;不会&lt;/b&gt;显式清除其已分配的所有内存（例如全局内存竞技场），而是让整个程序的exit（）照顾&amp;rdquo;这样的分配，也称为&amp;ldquo;对象的全局销毁&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c579d4f4691b7da6dbe69f3dde05c84842ed87a2" translate="yes" xml:space="preserve">
          <source>If you want to run particular test files, set the &lt;code&gt;TEST_FILES&lt;/code&gt; variable. It is possible to use globbing with this mechanism.</source>
          <target state="translated">如果要运行特定的测试文件，请设置 &lt;code&gt;TEST_FILES&lt;/code&gt; 变量。可以通过这种机制使用globbing。</target>
        </trans-unit>
        <trans-unit id="cab446873fde6bc4766b7caa4c1c83cdf5ad957d" translate="yes" xml:space="preserve">
          <source>If you want to see the command History, type an '&lt;b&gt;H&lt;/b&gt;':</source>
          <target state="translated">如果要查看历史记录命令，请输入&amp;ldquo; &lt;b&gt;H&lt;/b&gt; &amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="852c71f5265989b791fcb0bad50a31c13ad56ee6" translate="yes" xml:space="preserve">
          <source>If you want to see what perl is doing when parsing/lexing your code, you can use &lt;code&gt;BEGIN {}&lt;/code&gt; :</source>
          <target state="translated">如果您想查看在解析/编写代码时perl在做什么，可以使用 &lt;code&gt;BEGIN {}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5bcd47e1ec20a6f03629c4df1db050e464bbba10" translate="yes" xml:space="preserve">
          <source>If you want to see what perl is doing when parsing/lexing your code, you can use &lt;code&gt;BEGIN {}&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3175d2c86530c83d13669e65994d9eb74402053d" translate="yes" xml:space="preserve">
          <source>If you want to see what the parser/lexer is doing inside of &lt;code&gt;if&lt;/code&gt; blocks and the like you need to be a little trickier:</source>
          <target state="translated">如果要查看解析器/词法分析器在 &lt;code&gt;if&lt;/code&gt; 块等内部的工作，则需要增加一些技巧：</target>
        </trans-unit>
        <trans-unit id="8bca41d076fff99126cd66f621ea4770f98d22fe" translate="yes" xml:space="preserve">
          <source>If you want to select on many filehandles, you may wish to write a subroutine like this:</source>
          <target state="translated">如果你想在许多文件柄上进行选择,你可能希望写一个像这样的子程序。</target>
        </trans-unit>
        <trans-unit id="933790916a521b582a0514fa93b65b7620fb02f6" translate="yes" xml:space="preserve">
          <source>If you want to separate your lines with something other than &lt;code&gt;\n&lt;/code&gt; then set &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; to your preference. This replaces all newlines with &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; . If you just want to preserve existing newlines but add new breaks with something else, set &lt;code&gt;$Text::Wrap::separator2&lt;/code&gt; instead.</source>
          <target state="translated">如果要用 &lt;code&gt;\n&lt;/code&gt; 以外的内容分隔行，则将 &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; 为您的首选项。这将所有换行符替换为 &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; 。如果您只想保留现有的换行符，但添加其他新的换行符，请设置 &lt;code&gt;$Text::Wrap::separator2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60f1d3455cd48b5c9113f562dbd29843400fd015" translate="yes" xml:space="preserve">
          <source>If you want to separate your lines with something other than &lt;code&gt;\n&lt;/code&gt; then set &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; to your preference. This replaces all newlines with &lt;code&gt;$Text::Wrap::separator&lt;/code&gt;. If you just want to preserve existing newlines but add new breaks with something else, set &lt;code&gt;$Text::Wrap::separator2&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22c0f1a9c1e2e9b3f3593f17d9d5d341e79a144" translate="yes" xml:space="preserve">
          <source>If you want to set &lt;code&gt;@ARGV&lt;/code&gt; to your own list of files, go right ahead. This sets &lt;code&gt;@ARGV&lt;/code&gt; to all plain text files if no &lt;code&gt;@ARGV&lt;/code&gt; was given:</source>
          <target state="translated">如果要将 &lt;code&gt;@ARGV&lt;/code&gt; 设置为自己的文件列表，请继续。如果未提供 &lt;code&gt;@ARGV&lt;/code&gt; ，则会将 &lt;code&gt;@ARGV&lt;/code&gt; 设置为所有纯文本文件：</target>
        </trans-unit>
        <trans-unit id="003bfc7ab07433c173e20140a008ce04554b2602" translate="yes" xml:space="preserve">
          <source>If you want to set this to true, you should probably also set &lt;code&gt;no_whining&lt;/code&gt; or at least &lt;code&gt;no_errata_section&lt;/code&gt; to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec4550a1aa8d843e1070b1e888de468d819935e7" translate="yes" xml:space="preserve">
          <source>If you want to set your encoding layers based on your locale environment variables, you can use the &lt;code&gt;:locale&lt;/code&gt; pseudo-layer. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c597fab938b142e9f257da003c8529a2b550cc0b" translate="yes" xml:space="preserve">
          <source>If you want to set your encoding layers based on your locale environment variables, you can use the &lt;code&gt;:locale&lt;/code&gt; tag. For example:</source>
          <target state="translated">如果要基于区域设置环境变量设置编码层，则可以使用 &lt;code&gt;:locale&lt;/code&gt; 标记。例如：</target>
        </trans-unit>
        <trans-unit id="58f89c017aa82e00c2db2aafdcc4c822b860fb98" translate="yes" xml:space="preserve">
          <source>If you want to smoke test Perl, install &lt;code&gt;Perl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d56ce2ac72e38205347248835f6ba0461360176f" translate="yes" xml:space="preserve">
          <source>If you want to smoke test Perl, install &lt;code&gt;patch&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51e8012104c70a0c9ac8e8247b5e7beb2e02a77" translate="yes" xml:space="preserve">
          <source>If you want to specify a full module name you use the '+' prefix:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93a5a664c0fedc0848a47a9e0bdfdba8a57c6b9" translate="yes" xml:space="preserve">
          <source>If you want to specify perl options &lt;code&gt;-my_opts&lt;/code&gt; to the perl itself (as opposed to your program), use</source>
          <target state="translated">如果要为perl本身（与程序相反）指定perl选项 &lt;code&gt;-my_opts&lt;/code&gt; ，请使用</target>
        </trans-unit>
        <trans-unit id="16a2b27e854284e5624b52325615871e56858329" translate="yes" xml:space="preserve">
          <source>If you want to specify the version of Perl, but don't care about the version of the module, pass &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for the module version:</source>
          <target state="translated">如果要指定Perl的版本，但不关心模块的版本，请为模块版本传递 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3e15a1112b03a30e2e96987ec4625cc5601ef943" translate="yes" xml:space="preserve">
          <source>If you want to specify the version of Perl, but don't care about the version of the module, pass &lt;code&gt;undef&lt;/code&gt; for the module version:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4170c2908419d9f1f4a325cd881e413a4558b490" translate="yes" xml:space="preserve">
          <source>If you want to suppress man page installation for all modules you have to reconfigure Perl and tell it 'none' when it asks where to install man pages.</source>
          <target state="translated">如果你想抑制所有模块的man page安装,你必须重新配置Perl,并在它询问安装man page的位置时告诉它 &quot;none&quot;。</target>
        </trans-unit>
        <trans-unit id="73be2d5223229972e63c46363d25a8b4ecd5d388" translate="yes" xml:space="preserve">
          <source>If you want to take advantage of this new implicit dereferencing behavior, go right ahead: it makes code easier on the eye and wrist. Just understand that older releases will choke on it during compilation. Whenever you make use of something that works only in some given release of Perl and later, but not earlier, you should place a prominent</source>
          <target state="translated">如果你想利用这种新的隐式解除引用行为,请继续:它使代码更容易看清,也更方便。只是要明白,旧版本在编译过程中会被它噎住。每当你使用一些只在某个给定的Perl版本及以后的版本中工作的东西,而不是在更早的版本中工作的东西时,你应该把一个突出的</target>
        </trans-unit>
        <trans-unit id="57200b37088a74d0cf2864498f9f2df2310c106a" translate="yes" xml:space="preserve">
          <source>If you want to take into account the &lt;a href=&quot;bytes&quot;&gt;bytes&lt;/a&gt; pragma, use &lt;code&gt;&lt;a href=&quot;#DO_UTF8&quot;&gt;&quot;DO_UTF8&quot;&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1677e0d939fbca31e3c5c86eaef838b1e761cee" translate="yes" xml:space="preserve">
          <source>If you want to take into account the &lt;a href=&quot;bytes&quot;&gt;bytes&lt;/a&gt; pragma, use &lt;code&gt;&lt;a href=&quot;#DO_UTF8&quot;&gt;DO_UTF8&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果要考虑&lt;a href=&quot;bytes&quot;&gt;字节&lt;/a&gt;编译指示，请改用 &lt;code&gt;&lt;a href=&quot;#DO_UTF8&quot;&gt;DO_UTF8&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a26b59839e0fcf13a53cc201bc8166040a47a6c" translate="yes" xml:space="preserve">
          <source>If you want to test what the limits are, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be8af06e2253191bf1cfa1761503b16d4281bf21" translate="yes" xml:space="preserve">
          <source>If you want to trap errors when loading an XS module, some problems with the binary interface (such as Perl version skew) may be fatal even with &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; unless &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; is set. See &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">如果要在加载XS模块时捕获错误，则除非设置 &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; 否则即使使用 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，二进制接口的某些问题（例如Perl版本偏斜）也可能是致命的。参见&lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7dc2a0aef2f5b8c2b438b365b49a4c2f0d40f6ac" translate="yes" xml:space="preserve">
          <source>If you want to trap errors when loading an XS module, some problems with the binary interface (such as Perl version skew) may be fatal even with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; unless &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; is set. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">如果要在加载XS模块时捕获错误，则除非设置 &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; 否则即使使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，二进制接口的某些问题（例如Perl版本偏斜）也可能是致命的。参见&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e07434ddfb0dc6b8d6999cae38187552629bd142" translate="yes" xml:space="preserve">
          <source>If you want to trap errors when loading an XS module, some problems with the binary interface (such as Perl version skew) may be fatal even with &lt;code&gt;eval&lt;/code&gt; unless &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; is set. See &lt;a href=&quot;perlrun#PERL_DL_NONLAZY&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ffd07b12749a1692d47d579873dc74d6c4dfaf" translate="yes" xml:space="preserve">
          <source>If you want to try to install a distribution by yourself, resolving all dependencies on your own, you follow one of two possible build paths.</source>
          <target state="translated">如果你想尝试自己安装一个发行版,自己解决所有的依赖关系,你遵循两种可能的构建路径之一。</target>
        </trans-unit>
        <trans-unit id="c7b6e4ceeebb57e710804bd7d8e9ec8adbeff637" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;a href=&quot;#alarm-SECONDS&quot;&gt;&lt;code&gt;alarm&lt;/code&gt;&lt;/a&gt; to time out a system call you need to use an &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; pair. You can't rely on the alarm causing the system call to fail with &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; set to &lt;code&gt;EINTR&lt;/code&gt; because Perl sets up signal handlers to restart system calls on some systems. Using &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; always works, modulo the caveats given in &lt;a href=&quot;perlipc#Signals&quot;&gt;&quot;Signals&quot; in perlipc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbe14747549d8ad4516b4e89ba086fe45d5bc952" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;$.&lt;/code&gt; , you can reduce it to a simple one-liner, like one of these:</source>
          <target state="translated">如果要使用 &lt;code&gt;$.&lt;/code&gt; ，您可以将其简化为简单的一线式，例如以下一种：</target>
        </trans-unit>
        <trans-unit id="82a547affa563deb5ba9f50355b601f3dc49971a" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;$.&lt;/code&gt;, you can reduce it to a simple one-liner, like one of these:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="638caf8fdb384503ed24e0af4c2fa1fdaedcfe89" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; to time out a system call you need to use an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; pair. You can't rely on the alarm causing the system call to fail with &lt;code&gt;$!&lt;/code&gt; set to &lt;code&gt;EINTR&lt;/code&gt; because Perl sets up signal handlers to restart system calls on some systems. Using &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; always works, modulo the caveats given in &lt;a href=&quot;../perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt;.</source>
          <target state="translated">如果要使用 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 使系统调用超时，则需要使用 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 对。您不能依靠导致 &lt;code&gt;$!&lt;/code&gt; 的系统调用失败的警报！设置为 &lt;code&gt;EINTR&lt;/code&gt; 是因为Perl设置了信号处理程序以重新启动某些系统上的系统调用。使用 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 始终有效，&lt;a href=&quot;../perlipc#Signals&quot;&gt;以perlipc&lt;/a&gt;中的Signals中给出的警告为模。</target>
        </trans-unit>
        <trans-unit id="47fc081d4f98f1098211a1c78312dbb51873804c" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; to time out a system call you need to use an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; pair. You can't rely on the alarm causing the system call to fail with &lt;code&gt;$!&lt;/code&gt; set to &lt;code&gt;EINTR&lt;/code&gt; because Perl sets up signal handlers to restart system calls on some systems. Using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; always works, modulo the caveats given in &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt;.</source>
          <target state="translated">如果要使用 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 使系统调用超时，则需要使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 对。您不能依靠导致 &lt;code&gt;$!&lt;/code&gt; 的系统调用失败的警报！设置为 &lt;code&gt;EINTR&lt;/code&gt; 是因为Perl设置了信号处理程序以重新启动某些系统上的系统调用。使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 始终有效，&lt;a href=&quot;perlipc#Signals&quot;&gt;以perlipc&lt;/a&gt;中的Signals中给出的警告为模。</target>
        </trans-unit>
        <trans-unit id="b5d0b0984ed944888f7b73a2ab2ac582618153b1" translate="yes" xml:space="preserve">
          <source>If you want to use Perl on a non-z/OS EBCDIC machine, please let us know at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95a0ee4afc73cc3c28bb4ee34fc5e5c78c608e7d" translate="yes" xml:space="preserve">
          <source>If you want to use Perl on a non-z/OS EBCDIC machine, please let us know by sending mail to perlbug@perl.org</source>
          <target state="translated">如果你想在非z/OS的EBCDIC机器上使用Perl,请通过发送邮件到 perlbug@perl.org 告诉我们。</target>
        </trans-unit>
        <trans-unit id="e5b580ca1f65ec0f5a604fbeb668e8741070d520" translate="yes" xml:space="preserve">
          <source>If you want to use Perl on the Hurd, I recommend using the Debian GNU/Hurd distribution ( see &lt;a href=&quot;http://www.debian.org/&quot;&gt;http://www.debian.org/&lt;/a&gt; ), even if an official, stable release has not yet been made. The old &quot;gnu-0.2&quot; binary distribution will most certainly have additional problems.</source>
          <target state="translated">如果您想在Hurd上使用Perl，我建议您使用Debian GNU / Hurd发行版（请参阅&lt;a href=&quot;http://www.debian.org/&quot;&gt;http://www.debian.org/&lt;/a&gt;），即使尚未发布正式的稳定版本。当然，旧的&amp;ldquo; gnu-0.2&amp;rdquo;二进制发行版肯定会存在其他问题。</target>
        </trans-unit>
        <trans-unit id="189532095e3e00417c9441e09145ca9ef2976e21" translate="yes" xml:space="preserve">
          <source>If you want to use Perl on the Hurd, I recommend using the Debian GNU/Hurd distribution ( see &lt;a href=&quot;https://www.debian.org/&quot;&gt;https://www.debian.org/&lt;/a&gt; ), even if an official, stable release has not yet been made. The old &quot;gnu-0.2&quot; binary distribution will most certainly have additional problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7811171164463a43cee04445a18ab7a656878768" translate="yes" xml:space="preserve">
          <source>If you want to use a module, try the &lt;code&gt;uniq&lt;/code&gt; function from &lt;a href=&quot;List::MoreUtils&quot;&gt;List::MoreUtils&lt;/a&gt;. In list context it returns the unique elements, preserving their order in the list. In scalar context, it returns the number of unique elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7687d514ed5fdcc15efde5d3bf9ba63b53f53add" translate="yes" xml:space="preserve">
          <source>If you want to use a module, try the &lt;code&gt;uniq&lt;/code&gt; function from &lt;a href=&quot;http://search.cpan.org/perldoc/List::MoreUtils&quot;&gt;List::MoreUtils&lt;/a&gt;. In list context it returns the unique elements, preserving their order in the list. In scalar context, it returns the number of unique elements.</source>
          <target state="translated">如果要使用模块，请尝试使用&lt;a href=&quot;http://search.cpan.org/perldoc/List::MoreUtils&quot;&gt;List :: MoreUtils中&lt;/a&gt;的 &lt;code&gt;uniq&lt;/code&gt; 函数。在列表上下文中，它返回唯一元素，并在列表中保留其顺序。在标量上下文中，它返回唯一元素的数量。</target>
        </trans-unit>
        <trans-unit id="655bd3463f5ce3b5ada699426719c6ddc69d4f2a" translate="yes" xml:space="preserve">
          <source>If you want to use multiple patterns, e.g. &lt;code&gt;bsd_glob(&quot;a* b*&quot;)&lt;/code&gt; , you should probably throw them in a set as in &lt;code&gt;bsd_glob(&quot;{a*,b*}&quot;)&lt;/code&gt; . This is because the argument to bsd_glob() isn't subjected to parsing by the C shell. Remember that you can use a backslash to escape things.</source>
          <target state="translated">如果要使用多种模式，例如 &lt;code&gt;bsd_glob(&quot;a* b*&quot;)&lt;/code&gt; ，则应该像 &lt;code&gt;bsd_glob(&quot;{a*,b*}&quot;)&lt;/code&gt; 那样将它们放入一个集合中。这是因为C外壳程序不对bsd_glob（）的参数进行解析。请记住，可以使用反斜杠来转义。</target>
        </trans-unit>
        <trans-unit id="de3b637ffc15b7fdc6a8a524ee7e6cebe2311614" translate="yes" xml:space="preserve">
          <source>If you want to use multiple patterns, e.g. &lt;code&gt;bsd_glob(&quot;a* b*&quot;)&lt;/code&gt;, you should probably throw them in a set as in &lt;code&gt;bsd_glob(&quot;{a*,b*}&quot;)&lt;/code&gt;. This is because the argument to bsd_glob() isn't subjected to parsing by the C shell. Remember that you can use a backslash to escape things.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daaf83327da114b41b8c24aa71d08a4f5617620d" translate="yes" xml:space="preserve">
          <source>If you want to use non-ASCII bytes (outside the bytes 0x00..0x7f) in the &quot;source code&quot; of your code, to be portable you have to be explicit about what bytes they are. Someone might for example be using your code under a UTF-8 locale, in which case random native bytes might be illegal (&quot;Malformed UTF-8 ...&quot;) This means that for example embedding ISO 8859-1 bytes beyond 0x7f into your strings might cause trouble later. If the bytes are native 8-bit bytes, you can use the &lt;code&gt;bytes&lt;/code&gt; pragma. If the bytes are in a string (regular expressions being curious strings), you can often also use the &lt;code&gt;\xHH&lt;/code&gt; or more portably, the &lt;code&gt;\N{U+HH}&lt;/code&gt; notations instead of embedding the bytes as-is. If you want to write your code in UTF-8, you can use &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="translated">如果要在代码的&amp;ldquo;源代码&amp;rdquo;中使用非ASCII字节（字节0x00..0x7f之外），要想移植，必须明确它们是什么字节。例如，可能有人在UTF-8语言环境下使用您的代码，在这种情况下，随机的本地字节可能是非法的（&amp;ldquo;格式错误的UTF-8 ...&amp;rdquo;），这意味着例如将0x7f之后的ISO 8859-1字节嵌入到您的代码中字符串可能会在以后引起麻烦。如果字节是本机8位字节，则可以使用 &lt;code&gt;bytes&lt;/code&gt; 编译指示。如果字节在字符串中（正则表达式是奇怪的字符串），则通常也可以使用 &lt;code&gt;\xHH&lt;/code&gt; 或更可移植地使用 &lt;code&gt;\N{U+HH}&lt;/code&gt; 表示法，而不是照原样嵌入字节。如果要使用UTF-8编写代码，则可以使用&lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bfe339f2912f8f17fbf2b42472a9d509e3a576bf" translate="yes" xml:space="preserve">
          <source>If you want to use the same literal digits (644) in Perl, you have to tell Perl to treat them as octal numbers either by prefixing the digits with a &lt;code&gt;0&lt;/code&gt; or using &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">如果要在Perl中使用相同的文字数字（644），则必须告诉Perl通过在数字前面加上 &lt;code&gt;0&lt;/code&gt; 或使用 &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 将它们视为八进制数字：</target>
        </trans-unit>
        <trans-unit id="1dae8918eb32c3f3b5353faf9a6fd2771293c0e6" translate="yes" xml:space="preserve">
          <source>If you want to use the same literal digits (644) in Perl, you have to tell Perl to treat them as octal numbers either by prefixing the digits with a &lt;code&gt;0&lt;/code&gt; or using &lt;code&gt;oct&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee36968e514e749df3ac1a70b3903aee1ab0ec1b" translate="yes" xml:space="preserve">
          <source>If you want to use threads, you should primarily use the Perl 5.8.0 threads model by running Configure with -Duseithreads.</source>
          <target state="translated">如果你想使用线程,你应该主要使用Perl 5.8.0线程模型,用-Duseithreads运行Configure。</target>
        </trans-unit>
        <trans-unit id="3a5e52fc579dc6791582e6cfe54da362246b660d" translate="yes" xml:space="preserve">
          <source>If you want to work with comma-separated values, don't do this since that format is a bit more complicated. Use one of the modules that handle that format, such as &lt;a href=&quot;Text::CSV&quot;&gt;Text::CSV&lt;/a&gt;, &lt;a href=&quot;Text::CSV_XS&quot;&gt;Text::CSV_XS&lt;/a&gt;, or &lt;a href=&quot;Text::CSV_PP&quot;&gt;Text::CSV_PP&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b79aac4ab0e44b3e5cf20ea8795f9b26be612e" translate="yes" xml:space="preserve">
          <source>If you want to work with comma-separated values, don't do this since that format is a bit more complicated. Use one of the modules that handle that format, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV&quot;&gt;Text::CSV&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_XS&quot;&gt;Text::CSV_XS&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_PP&quot;&gt;Text::CSV_PP&lt;/a&gt;.</source>
          <target state="translated">如果要使用逗号分隔的值，请不要这样做，因为该格式要复杂一些。使用处理该格式的模块之一，例如&lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV&quot;&gt;Text :: CSV&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_XS&quot;&gt;Text :: CSV_XS&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_PP&quot;&gt;Text :: CSV_PP&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1eaaa5db8078515a0b75d0e6992dfcf80e5ff6b" translate="yes" xml:space="preserve">
          <source>If you want to work with formatted dates, the &lt;a href=&quot;Date::Manip&quot;&gt;Date::Manip&lt;/a&gt;, &lt;a href=&quot;Date::Calc&quot;&gt;Date::Calc&lt;/a&gt;, or &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; modules can help you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37acc7e93925635a2960bac98f19ec762c55738f" translate="yes" xml:space="preserve">
          <source>If you want to work with formatted dates, the &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date::Manip&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; modules can help you.</source>
          <target state="translated">如果要使用格式化的日期，则&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date :: Manip&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;模块可以为您提供帮助。</target>
        </trans-unit>
        <trans-unit id="c337db840462e094257c46f34c19710018f93799" translate="yes" xml:space="preserve">
          <source>If you want to write to an existing SV's buffer and set its value to a string, use SvPV_force() or one of its variants to force the SV to be a PV. This will remove any of various types of non-stringness from the SV while preserving the content of the SV in the PV. This can be used, for example, to append data from an API function to a buffer without extra copying:</source>
          <target state="translated">如果你想写入一个现有的SV的缓冲区,并将其值设置为一个字符串,使用SvPV_force()或它的一个变体来强制SV成为一个PV。这将从SV中删除任何类型的非字符串,同时保留PV中SV的内容。例如,这可以用来将API函数中的数据追加到缓冲区中,而不需要额外的复制。</target>
        </trans-unit>
        <trans-unit id="17fab6cd5cfc4d3a8699ee4d492a9132990d5dbf" translate="yes" xml:space="preserve">
          <source>If you want to zap all predefined aliases, you can use</source>
          <target state="translated">如果您想扎掉所有预定义的别名,您可以使用</target>
        </trans-unit>
        <trans-unit id="6dad17422598919d77ad32018e1ee73ac029ac1c" translate="yes" xml:space="preserve">
          <source>If you want your code to be portable, your format (&lt;code&gt;fmt&lt;/code&gt; ) argument should use only the conversion specifiers defined by the ANSI C standard (C89, to play safe). These are &lt;code&gt;aAbBcdHIjmMpSUwWxXyYZ%&lt;/code&gt; . But even then, the &lt;b&gt;results&lt;/b&gt; of some of the conversion specifiers are non-portable. For example, the specifiers &lt;code&gt;aAbBcpZ&lt;/code&gt; change according to the locale settings of the user, and both how to set locales (the locale names) and what output to expect are non-standard. The specifier &lt;code&gt;c&lt;/code&gt; changes according to the timezone settings of the user and the timezone computation rules of the operating system. The &lt;code&gt;Z&lt;/code&gt; specifier is notoriously unportable since the names of timezones are non-standard. Sticking to the numeric specifiers is the safest route.</source>
          <target state="translated">如果您希望代码具有可移植性，那么您的format（ &lt;code&gt;fmt&lt;/code&gt; ）参数应仅使用ANSI C标准（为了安全起见，C89）定义的转换说明符。这些是 &lt;code&gt;aAbBcdHIjmMpSUwWxXyYZ%&lt;/code&gt; 。但是即使这样，某些转换说明符的&lt;b&gt;结果&lt;/b&gt;还是不可移植的。例如，说明符 &lt;code&gt;aAbBcpZ&lt;/code&gt; 根据用户的语言环境设置而改变，并且如何设置语言环境（语言环境名称）以及期望的输出都是非标准的。指定符 &lt;code&gt;c&lt;/code&gt; 根据用户的时区设置和操作系统的时区计算规则而变化。该 &lt;code&gt;Z&lt;/code&gt; 由于时区的名称是非标准的，因此说明符是众所周知的不可移植的。坚持数字说明符是最安全的方法。</target>
        </trans-unit>
        <trans-unit id="45c7504bca4d1a8d8abed6fce6e884966dc05bc6" translate="yes" xml:space="preserve">
          <source>If you want your code to be portable, your format (&lt;code&gt;fmt&lt;/code&gt;) argument should use only the conversion specifiers defined by the ANSI C standard (C89, to play safe). These are &lt;code&gt;aAbBcdHIjmMpSUwWxXyYZ%&lt;/code&gt;. But even then, the &lt;b&gt;results&lt;/b&gt; of some of the conversion specifiers are non-portable. For example, the specifiers &lt;code&gt;aAbBcpZ&lt;/code&gt; change according to the locale settings of the user, and both how to set locales (the locale names) and what output to expect are non-standard. The specifier &lt;code&gt;c&lt;/code&gt; changes according to the timezone settings of the user and the timezone computation rules of the operating system. The &lt;code&gt;Z&lt;/code&gt; specifier is notoriously unportable since the names of timezones are non-standard. Sticking to the numeric specifiers is the safest route.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8922cb8873f110b4ceb1333b3f31e99ca5b2eb1" translate="yes" xml:space="preserve">
          <source>If you want your encoding to work with &lt;a href=&quot;../encoding&quot;&gt;encoding&lt;/a&gt; pragma, you should also implement the method below.</source>
          <target state="translated">如果您希望您的编码与&lt;a href=&quot;../encoding&quot;&gt;编码&lt;/a&gt;编译指示一起使用，则还应该实现以下方法。</target>
        </trans-unit>
        <trans-unit id="f0a7770b35604635306837054c149681539eca02" translate="yes" xml:space="preserve">
          <source>If you want your encoding to work with &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; pragma, you should also implement the method below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbf6500eb6902acebc3435f4b4dd55c522837bc" translate="yes" xml:space="preserve">
          <source>If you want your here-docs to be indented with the rest of the code, use the &lt;code&gt;&amp;lt;&amp;lt;~FOO&lt;/code&gt; construct described under &lt;a href=&quot;#Indented-Here-docs&quot;&gt;&quot;Indented Here-docs&quot;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7210c4e7ce82b46e9e62a14e14a71ab868752cc" translate="yes" xml:space="preserve">
          <source>If you want your here-docs to be indented with the rest of the code, you'll need to remove leading whitespace from each line manually:</source>
          <target state="translated">如果你想让你的 her-docs 和其他代码一起缩进,你需要手动删除每行的前导空格。</target>
        </trans-unit>
        <trans-unit id="eb763454ad4db2bd6193f7e99d444faca44a82eb" translate="yes" xml:space="preserve">
          <source>If you want your program to be compatible with versions of Perl before 5.20, you must use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; instead. (In previous versions of Perl, the behavior of the statements &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'NONFATAL';&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; was unspecified; they did not behave as if they included the &lt;code&gt;=&amp;gt; 'all'&lt;/code&gt; portion. As of 5.20, they do.)</source>
          <target state="translated">如果您希望程序与5.20之前的Perl版本兼容，则必须使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; 代替。（在Perl的早期版本中，语句的行为 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'NONFATAL';&lt;/code&gt; 而 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; 为未指定的，他们并没有表现得好像它们包括 &lt;code&gt;=&amp;gt; 'all'&lt;/code&gt; 部分从5.20开始，他们这样做了。）</target>
        </trans-unit>
        <trans-unit id="2539f4ee77683fe9463e9a882a260d320b1f9535" translate="yes" xml:space="preserve">
          <source>If you want your program to be compatible with versions of Perl before 5.20, you must use &lt;code&gt;use warnings FATAL =&amp;gt; 'all';&lt;/code&gt; instead. (In previous versions of Perl, the behavior of the statements &lt;code&gt;use warnings 'FATAL';&lt;/code&gt;, &lt;code&gt;use warnings 'NONFATAL';&lt;/code&gt; and &lt;code&gt;no warnings 'FATAL';&lt;/code&gt; was unspecified; they did not behave as if they included the &lt;code&gt;=&amp;gt; 'all'&lt;/code&gt; portion. As of 5.20, they do.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d68917c192fee56b1141df74b8f16f9fa5100fe" translate="yes" xml:space="preserve">
          <source>If you want, you may make low-level pipe() and fork() syscalls to stitch this together by hand. This example only talks to itself, but you could reopen the appropriate handles to STDIN and STDOUT and call other processes. (The following example lacks proper error checking.)</source>
          <target state="translated">如果你愿意,你可以做低级别的管道()和fork()系统调用来手工拼接。这个例子只和自己对话,但你可以重新打开STDIN和STDOUT的适当句柄,并调用其他进程。(下面的例子缺乏适当的错误检查。)</target>
        </trans-unit>
        <trans-unit id="9a78398c052f882736bece8b1553a1b8e0dc056b" translate="yes" xml:space="preserve">
          <source>If you wanted just to append to a row, you'd have to do something a bit funnier looking:</source>
          <target state="translated">如果你只想追加到一行,你就得做一些看起来更有趣的事情。</target>
        </trans-unit>
        <trans-unit id="2260da4124856b0020df29775382e24cb7c28087" translate="yes" xml:space="preserve">
          <source>If you wanted text and not lines, you would use</source>
          <target state="translated">如果你想要的是文字而不是线条,你会使用</target>
        </trans-unit>
        <trans-unit id="b649b444ce3825b2b868566f3609222a2cd25baa" translate="yes" xml:space="preserve">
          <source>If you wanted the commas preserved as separate fields (i.e. like split does if your split pattern has capturing parentheses), you would just make the last parameter undefined (or remove it).</source>
          <target state="translated">如果你想把逗号作为单独的字段保留下来(例如,如果你的分割模式有括号的话,就像分割一样),你只需要把最后一个参数变成未定义的(或者删除它)。</target>
        </trans-unit>
        <trans-unit id="5fba67ea1fbf1509f7d61f0bae5321559a412330" translate="yes" xml:space="preserve">
          <source>If you wanted to do the same thing for lines, you wouldn't need a regular expression:</source>
          <target state="translated">如果你想对行做同样的事情,你就不需要正则表达式了。</target>
        </trans-unit>
        <trans-unit id="ed640c7d7a4ae2cd65ac815fdaa4ce3af7479470" translate="yes" xml:space="preserve">
          <source>If you wanted to have a $ref_to_AoA variable as a reference to an array, you'd have to do something like this:</source>
          <target state="translated">如果你想让$ref_to_AoA变量作为一个数组的引用,你必须做这样的事情。</target>
        </trans-unit>
        <trans-unit id="fed8c5d580fcbca1e699420a58d9ad3cd67321fd" translate="yes" xml:space="preserve">
          <source>If you wanted to keep track of subscripts, you might do this:</source>
          <target state="translated">如果你想跟踪订阅,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="fbf69379e2b3dc67cd59111850ee63e9c65dd9db" translate="yes" xml:space="preserve">
          <source>If you wanted to see the inverse tables, you would first have to sort on the desired numbers column as in recipes 4, 5 or 6, then take the output of the first numbers column.</source>
          <target state="translated">如果你想看反表,你首先要在所需的数字列上进行排序,就像食谱4、5或6一样,然后取第一个数字列的输出。</target>
        </trans-unit>
        <trans-unit id="1d598a9db20ad75da95def7772f5c1aab9645a1d" translate="yes" xml:space="preserve">
          <source>If you were into Schwartzian Transforms, you would probably have selected map for that</source>
          <target state="translated">如果你是进入Schwartzian Transforms,你可能会选择地图的。</target>
        </trans-unit>
        <trans-unit id="ad840be29267c1ff305e523c8e88cf5317d35dc5" translate="yes" xml:space="preserve">
          <source>If you were to set &lt;code&gt;$b[3] = 4&lt;/code&gt; , then instead of reporting that &quot;a and b are deep copies of each other&quot;, it now reports that &lt;code&gt;&quot;b smartmatches in a&quot;&lt;/code&gt; . That's because the corresponding position in &lt;code&gt;@a&lt;/code&gt; contains an array that (eventually) has a 4 in it.</source>
          <target state="translated">如果您要设置 &lt;code&gt;$b[3] = 4&lt;/code&gt; ，那么它现在将报告 &lt;code&gt;&quot;b smartmatches in a&quot;&lt;/code&gt; &amp;rdquo;，而不是报告&amp;ldquo; a和b是彼此的深拷贝&amp;rdquo;。这是因为 &lt;code&gt;@a&lt;/code&gt; 中的相应位置包含一个数组（最终）（其中最后有一个4）。</target>
        </trans-unit>
        <trans-unit id="e625042d34a802ff63347451c799c769cd7bb028" translate="yes" xml:space="preserve">
          <source>If you were to set &lt;code&gt;$b[3] = 4&lt;/code&gt;, then instead of reporting that &quot;a and b are deep copies of each other&quot;, it now reports that &lt;code&gt;&quot;b smartmatches in a&quot;&lt;/code&gt;. That's because the corresponding position in &lt;code&gt;@a&lt;/code&gt; contains an array that (eventually) has a 4 in it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e66b6a4d3408c5b81e396702004bd84b8fbf9d" translate="yes" xml:space="preserve">
          <source>If you wish to compile with the Socket extension, you need to have the TCP/IP toolkit, and you need to make sure that -lsocket locates the correct copy of socket3r.lib. Beware that the Watcom compiler ships with a stub version of socket3r.lib which has very little functionality. Also beware the order in which wlink searches directories for libraries. You may have /usr/lib/socket3r.lib pointing to the correct library, but wlink may pick up /usr/watcom/10.6/usr/lib/socket3r.lib instead. Make sure they both point to the correct library, that is, /usr/tcptk/current/usr/lib/socket3r.lib.</source>
          <target state="translated">如果你想用Socket扩展来编译,你需要有TCP/IP工具包,并且你需要确保-lsocket能找到socket3r.lib的正确副本。要注意Watcom编译器提供了一个stub版本的socket3r.lib,它的功能非常少。同时也要注意wlink搜索库的顺序。你可能有 /usr/lib/socket3r.lib 指向正确的库,但 wlink 可能会找到 /usr/watcom/10.6/usr/lib/socket3r.lib。确保它们都指向正确的库,即/usr/tcptk/current/usr/lib/socket3r.lib。</target>
        </trans-unit>
        <trans-unit id="743a9842bd7eb1c587a8ceb73e47cc40eff3e0ec" translate="yes" xml:space="preserve">
          <source>If you wish to install perl versions for all architectures (68020, mips, sparc and 386) run:</source>
          <target state="translated">如果你想为所有架构(68020,mips,sparc和386)安装perl版本,请运行。</target>
        </trans-unit>
        <trans-unit id="8c3f20eaf91a5deff73dd9c45659c91402df0ac2" translate="yes" xml:space="preserve">
          <source>If you wish to supply an alternative debugger for Perl to run, invoke your script with a colon and a package argument given to the &lt;b&gt;-d&lt;/b&gt; flag. Perl's alternative debuggers include a Perl profiler, &lt;a href=&quot;Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt;, which is available separately as a CPAN distribution. To profile your Perl program in the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0f0e4408b545cb1ecebca491d9be266bb67e8f" translate="yes" xml:space="preserve">
          <source>If you wish to supply an alternative debugger for Perl to run, invoke your script with a colon and a package argument given to the &lt;b&gt;-d&lt;/b&gt; flag. Perl's alternative debuggers include a Perl profiler, &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt;, which is available separately as a CPAN distribution. To profile your Perl program in the file</source>
          <target state="translated">如果希望为Perl提供替代调试器以运行，请使用冒号和给&lt;b&gt;-d&lt;/b&gt;标志的package参数调用脚本。Perl的替代调试器包括Perl分析器&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel :: NYTProf&lt;/a&gt;，它可以作为CPAN发行版单独提供。在文件中分析您的Perl程序</target>
        </trans-unit>
        <trans-unit id="b105ef1f647cb2687215fb2803b65285f6c51529" translate="yes" xml:space="preserve">
          <source>If you wish to turn an entire POD document into a parse-tree, that process is fairly straightforward. The &lt;b&gt;parse_text()&lt;/b&gt; method is the key to doing this successfully. Every paragraph-callback (i.e. the polymorphic methods for &lt;b&gt;command()&lt;/b&gt;, &lt;b&gt;verbatim()&lt;/b&gt;, and &lt;b&gt;textblock()&lt;/b&gt; paragraphs) takes a &lt;b&gt;Pod::Paragraph&lt;/b&gt; object as an argument. Each paragraph object has a &lt;b&gt;parse_tree()&lt;/b&gt; method that can be used to get or set a corresponding parse-tree. So for each of those paragraph-callback methods, simply call &lt;b&gt;parse_text()&lt;/b&gt; with the options you desire, and then use the returned parse-tree to assign to the given paragraph object.</source>
          <target state="translated">如果您希望将整个POD文档变成一个分析树，那么这个过程非常简单。该&lt;b&gt;parse_Text在（）&lt;/b&gt;方法的关键在于成功地这样做。每个段落回调（即&lt;b&gt;command（）&lt;/b&gt;，&lt;b&gt;verbatim（）&lt;/b&gt;和&lt;b&gt;textblock（）&lt;/b&gt;段落的多态方法）都将&lt;b&gt;Pod :: Paragraph&lt;/b&gt;对象作为参数。每个段落对象都有一个&lt;b&gt;parse_tree（）&lt;/b&gt;方法，该方法可用于获取或设置相应的解析树。因此，对于每个这些段落回调方法，只需使用所需的选项调用&lt;b&gt;parse_text（）&lt;/b&gt;，然后使用返回的解析树将其分配给给定的段落对象。</target>
        </trans-unit>
        <trans-unit id="77c82d86f4fb285fcd145d9c870b966041509421" translate="yes" xml:space="preserve">
          <source>If you wish to use GNU ld, then you need to pass it the -Wl,-E flag. The hints/solaris_2.sh file tries to do this automatically by setting the following Configure variables:</source>
          <target state="translated">如果你想使用GNU ld,那么你需要传递-Wl,-E标志。hints/solaris_2.sh文件试图通过设置以下的Configure变量来自动做到这一点。</target>
        </trans-unit>
        <trans-unit id="5c10ef4b4d7cf77ba9367b0a5ba13535a2314b3d" translate="yes" xml:space="preserve">
          <source>If you wish to use gcc to build add-on modules for use with the perl shipped with Solaris, you should use the Solaris::PerlGcc module which is available from CPAN. The perl shipped with Solaris is configured and built with the Sun compilers, and the compiler configuration information stored in Config.pm is therefore only relevant to the Sun compilers. The Solaris:PerlGcc module contains a replacement Config.pm that is correct for gcc - see the module for details.</source>
          <target state="translated">如果你希望使用gcc来构建附加模块,以便与Solaris附带的perl一起使用,你应该使用CPAN提供的Solaris::PerlGcc模块。Solaris 中的 perl 是用 Sun 编译器配置和构建的,因此存储在 Config.pm 中的编译器配置信息只与 Sun 编译器有关。Solaris:PerlGcc模块包含了一个对gcc正确的替换Config.pm--详见该模块。</target>
        </trans-unit>
        <trans-unit id="461c22560c9b4e2d096c9a209fc41fbc9b8e1805" translate="yes" xml:space="preserve">
          <source>If you wonder what complex numbers are, they were invented to be able to solve the following equation:</source>
          <target state="translated">如果你想知道什么是复数,那么发明复数就是为了能解下面的方程。</target>
        </trans-unit>
        <trans-unit id="58f2be2cb41014bdf8c7d1f6da3d5ed7b3a57878" translate="yes" xml:space="preserve">
          <source>If you wonder why defaults for conversion are different for str() and num(), note how easy it was to write the symbolic calculator. This simplicity is due to an appropriate choice of defaults. One extra note: due to the explicit recursion num() is more fragile than sym(): we need to explicitly check for the type of $a and $b. If components $a and $b happen to be of some related type, this may lead to problems.</source>
          <target state="translated">如果你想知道为什么str()和num()的转换默认值不同,请注意写符号计算器是多么的简单。这种简单性是由于适当地选择了默认值。一个额外的说明:由于显式递归num()比sym()更脆弱:我们需要显式检查$a和$b的类型。如果组件$a和$b恰好是一些相关的类型,这可能会导致问题。</target>
        </trans-unit>
        <trans-unit id="f88d82472c17285676b32563ec0b930b79f27b19" translate="yes" xml:space="preserve">
          <source>If you would like to know about a version dependency before you start running the program, put something like this at its top:</source>
          <target state="translated">如果你想在开始运行程序之前了解版本依赖性,请在程序顶部写上这样的内容。</target>
        </trans-unit>
        <trans-unit id="c3bc63e78a724b45aa4c8fcf7d5d3a90c3663440" translate="yes" xml:space="preserve">
          <source>If you would like to print out a lot of man page continuously, you probably want to set the C and D registers to set contiguous page numbering and even/odd paging, at least on some versions of man(7).</source>
          <target state="translated">如果你想连续打印出大量的man页,你可能想设置C和D寄存器来设置连续页码和偶数/多数分页,至少在man(7)的某些版本上是这样。</target>
        </trans-unit>
        <trans-unit id="47a4a5157ecac47010f3fc4d031a714df9cdb1ae" translate="yes" xml:space="preserve">
          <source>If you would like, you can pass in a hashref instead of pairs. When you do so the hashref will be copied, and the copy will be returned blessed as an object. There is no way to ask HashBase to bless a specific hashref.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e270feabb28d65fb97bce6b5a62077129b3eed4" translate="yes" xml:space="preserve">
          <source>If you would rather see it in CCSID 1047 order then change the number 34 in the last line to 39, like this:</source>
          <target state="translated">如果你想按CCSID 1047的顺序看,那就把最后一行的数字34改为39,就像这样。</target>
        </trans-unit>
        <trans-unit id="7ab3cc4dd9f42b386f286d85d40432c48d4dbc0d" translate="yes" xml:space="preserve">
          <source>If you would rather see it in POSIX-BC order then change the number 34 in the last line to 44, like this:</source>
          <target state="translated">如果你想按POSIX-BC的顺序看,那就把最后一行的数字34改为44,像这样。</target>
        </trans-unit>
        <trans-unit id="4685079e88ddb435b412b9c5b1c049410dc612d3" translate="yes" xml:space="preserve">
          <source>If you would rather see the above table in CCSID 0037 order rather than ASCII + Latin-1 order then run the table through:</source>
          <target state="translated">如果您希望以CCSID 0037的顺序而不是ASCII+拉丁语1的顺序查看上表,那么请运行该表。</target>
        </trans-unit>
        <trans-unit id="32ccbee06ab47d2346ade36365b388768fa75f8c" translate="yes" xml:space="preserve">
          <source>If you would rather see this table listing hexadecimal values then run the table through:</source>
          <target state="translated">如果你想看这个列出十六进制值的表格,那么就把这个表格运行一遍。</target>
        </trans-unit>
        <trans-unit id="ee951a76c16a66932dc3802ba31a24c5d5d45366" translate="yes" xml:space="preserve">
          <source>If you write just &lt;code&gt;[]&lt;/code&gt; , you get a new, empty anonymous array. If you write just &lt;code&gt;{}&lt;/code&gt; , you get a new, empty anonymous hash.</source>
          <target state="translated">如果只写 &lt;code&gt;[]&lt;/code&gt; ，则会得到一个新的空匿名数组。如果仅写 &lt;code&gt;{}&lt;/code&gt; ，则会得到一个新的空匿名哈希。</target>
        </trans-unit>
        <trans-unit id="4638b3569a9b4f06615d1c5e8e4772e5510c4692" translate="yes" xml:space="preserve">
          <source>If you write just &lt;code&gt;[]&lt;/code&gt;, you get a new, empty anonymous array. If you write just &lt;code&gt;{}&lt;/code&gt;, you get a new, empty anonymous hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5ce930a64c177374e0a87543a2b84b1ca0633d" translate="yes" xml:space="preserve">
          <source>If you write your own test, use the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2ftestanything.org&quot;&gt;Test Anything Protocol&lt;/a&gt;.</source>
          <target state="translated">如果您编写自己的测试，请使用&amp;ldquo; &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2ftestanything.org&quot;&gt;测试任何协议&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e006dae20780e3ea05d021931a4db8875b19d01" translate="yes" xml:space="preserve">
          <source>If you write your own test, use the &lt;a href=&quot;https://testanything.org&quot;&gt;Test Anything Protocol&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b7f29b396f8216559006548d8b8987bccc01b5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a C or C++ programmer, you might be looking for Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword.</source>
          <target state="translated">如果您是C或C ++程序员，则可能正在寻找Perl的 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="6c0a86670223bfdb26cb68751ec4a4f37f760ea9" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a C or C++ programmer, you might be looking for Perl&amp;rsquo;s &lt;code&gt;state&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65480a92112439353360a0f2410e7e3031db6948" translate="yes" xml:space="preserve">
          <source>If you'd like a graphical user interface and you have &lt;a href=&quot;http://search.cpan.org/perldoc/Tk&quot;&gt;Tk&lt;/a&gt;, you can use &lt;code&gt;ptkdb&lt;/code&gt; . It's on CPAN and available for free.</source>
          <target state="translated">如果您想要图形用户界面并且拥有&lt;a href=&quot;http://search.cpan.org/perldoc/Tk&quot;&gt;Tk&lt;/a&gt;，则可以使用 &lt;code&gt;ptkdb&lt;/code&gt; 。它在CPAN上免费提供。</target>
        </trans-unit>
        <trans-unit id="6666466d25080d49716b3f38912878857c8e62b2" translate="yes" xml:space="preserve">
          <source>If you'd like a graphical user interface and you have &lt;a href=&quot;tk&quot;&gt;Tk&lt;/a&gt;, you can use &lt;code&gt;ptkdb&lt;/code&gt;. It's on CPAN and available for free.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c82ff6955ec720dbffdb6e597947e26e8c52b3d3" translate="yes" xml:space="preserve">
          <source>If you'd like to disable the use of one or more of these utilities and/or modules, see the &lt;code&gt;$BLACKLIST&lt;/code&gt; variable further down.</source>
          <target state="translated">如果您想禁用这些实用程序和/或模块中的一个或多个，请参阅 &lt;code&gt;$BLACKLIST&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="2745d17cd01ce3bb020e0554868598f0ea306839" translate="yes" xml:space="preserve">
          <source>If you'd like to make &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt; (and many other bits of Perl) die on error, have a look at the &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52486225415552ac3d601c87ba41d238a14d5679" translate="yes" xml:space="preserve">
          <source>If you'd like to make &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; (and many other bits of Perl) die on error, have a look at the &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; pragma.</source>
          <target state="translated">如果您想使 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; （以及Perl的许多其他功能）因错误而死亡，请查看自动模具&lt;a href=&quot;autodie&quot;&gt;实用程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1efbce8f9e88ed4ba8cc94bb84af468b14e5c10a" translate="yes" xml:space="preserve">
          <source>If you'd like to make &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; (and many other bits of Perl) die on error, have a look at the &lt;a href=&quot;../autodie&quot;&gt;autodie&lt;/a&gt; pragma.</source>
          <target state="translated">如果您想使 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; （以及Perl的许多其他功能）因错误而死亡，请查看自动模具&lt;a href=&quot;../autodie&quot;&gt;实用程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="31f9c1e59db4aaf2455c75e99d8c0e4aa26479c4" translate="yes" xml:space="preserve">
          <source>If you'd like to manually inspect &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;'s failure, you can check all possible failure modes by inspecting &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a95e0734804b8dcc4d934eb0b4ac64271a89fa" translate="yes" xml:space="preserve">
          <source>If you'd like to manually inspect &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s failure, you can check all possible failure modes by inspecting &lt;code&gt;$?&lt;/code&gt; like this:</source>
          <target state="translated">如果您想手动检查 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 的故障，可以通过检查 &lt;code&gt;$?&lt;/code&gt; 检查所有可能的故障模式。像这样：</target>
        </trans-unit>
        <trans-unit id="c50262b9b752d6c3a022a1f95bc5efa143b999d6" translate="yes" xml:space="preserve">
          <source>If you'd like to manually inspect &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s failure, you can check all possible failure modes by inspecting &lt;code&gt;$?&lt;/code&gt; like this:</source>
          <target state="translated">如果您想手动检查 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 的故障，可以通过检查 &lt;code&gt;$?&lt;/code&gt; 检查所有可能的故障模式。像这样：</target>
        </trans-unit>
        <trans-unit id="b7d0d2c6ab654703248e935ebd07682399b01f80" translate="yes" xml:space="preserve">
          <source>If you'd like to see the raw output of your tests, set the &lt;code&gt;TEST_VERBOSE&lt;/code&gt; variable to true.</source>
          <target state="translated">如果您想查看测试的原始输出，请将 &lt;code&gt;TEST_VERBOSE&lt;/code&gt; 变量设置为true。</target>
        </trans-unit>
        <trans-unit id="15cb39149b7ad3616c39f88b2becd39a6aed03b0" translate="yes" xml:space="preserve">
          <source>If you'd rather treat each line individually, you can do that, too, by just transforming them in-place in the code reference and returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. Say that you don't want</source>
          <target state="translated">如果您希望单独对待每一行，也可以通过在代码引用中就地转换它们并返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 来实现。说你不想</target>
        </trans-unit>
        <trans-unit id="6e65ba1455e726ff251279d7a46229f815e23af8" translate="yes" xml:space="preserve">
          <source>If you'd rather treat each line individually, you can do that, too, by just transforming them in-place in the code reference and returning &lt;code&gt;undef&lt;/code&gt;. Say that you don't want</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c0d6d1d9d7ffd617e3fd0512c67d0a724859e3" translate="yes" xml:space="preserve">
          <source>If you're a plugin author, you'll be interested in how to &lt;a href=&quot;#register_handler&quot;&gt;&quot;register_handler&quot;&lt;/a&gt;s, how &lt;a href=&quot;#detect_source&quot;&gt;&quot;detect_source&quot;&lt;/a&gt; works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd95bdd9903099e5f9ecacdcf9a08a9aec1e1ad" translate="yes" xml:space="preserve">
          <source>If you're a plugin author, you'll be interested in how to &lt;a href=&quot;#register_handler&quot;&gt;register_handler&lt;/a&gt;s, how &lt;a href=&quot;#detect_source&quot;&gt;detect_source&lt;/a&gt; works.</source>
          <target state="translated">如果您是插件作者，那么您将对如何&lt;a href=&quot;#register_handler&quot;&gt;register_handler&lt;/a&gt;以及&lt;a href=&quot;#detect_source&quot;&gt;detect_source的&lt;/a&gt;工作方式感兴趣。</target>
        </trans-unit>
        <trans-unit id="ec02db45e6d3a34d0a303395b0efb8490d821d7c" translate="yes" xml:space="preserve">
          <source>If you're committed to creating a temporary file by hand, use the process ID and/or the current time-value. If you need to have many temporary files in one process, use a counter:</source>
          <target state="translated">如果你致力于手工创建临时文件,请使用进程ID和/或当前时间值。如果你需要在一个进程中拥有许多临时文件,请使用计数器。</target>
        </trans-unit>
        <trans-unit id="6a57c8d5168852184b3e7f9eacd5e84a511755f4" translate="yes" xml:space="preserve">
          <source>If you're concerned about 8-bit textual data then see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;. If you want to deal with multibyte characters, however, there are some gotchas. See the section on Regular Expressions.</source>
          <target state="translated">如果您担心8位文本数据，请参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。但是，如果要处理多字节字符，则有一些陷阱。请参阅正则表达式部分。</target>
        </trans-unit>
        <trans-unit id="a4a17aeb59ac658e17124a0d2eb0b805c011e3c8" translate="yes" xml:space="preserve">
          <source>If you're concerned about people profiting from your code, then the bottom line is that nothing but a restrictive license will give you legal security. License your software and pepper it with threatening statements like &quot;This is unpublished proprietary software of XYZ Corp. Your access to it does not give you permission to use it blah blah blah.&quot; We are not lawyers, of course, so you should see a lawyer if you want to be sure your license's wording will stand up in court.</source>
          <target state="translated">如果你担心人们从你的代码中获利,那么底线是,除了限制性的许可证之外,什么都不能给你带来法律上的保障。给你的软件颁发许可证,并在其中加入威胁性的声明,比如 &quot;这是XYZ公司未发布的专有软件,你对它的访问并不允许你使用它等等。你对它的访问并没有给你使用它的许可等等等等。&quot; 当然,我们不是律师,所以如果你想确保你的许可证的措辞能在法庭上站住脚,你应该去见律师。</target>
        </trans-unit>
        <trans-unit id="20f5afeb7883b43b071ad0d90c989471842051d6" translate="yes" xml:space="preserve">
          <source>If you're concerned about people profiting from your code, then the bottom line is that nothing but a restrictive license will give you legal security. License your software and pepper it with threatening statements like &quot;This is unpublished proprietary software of XYZ Corp. Your access to it does not give you permission to use it blah blah blah.&quot; You should see a lawyer to be sure your license's wording will stand up in court.</source>
          <target state="translated">如果你担心人们从你的代码中获利,那么底线是,除了限制性的许可证之外,什么都不能给你带来法律上的保障。给你的软件颁发许可证,并在其中加入威胁性的声明,比如 &quot;这是XYZ公司未发布的专有软件,你对它的访问并不允许你使用它等等。你对它的访问并没有给你使用它的许可等等等等。&quot; 你应该去见律师,以确保你的许可证的措辞能在法庭上站住脚。</target>
        </trans-unit>
        <trans-unit id="28d412e72884dbac279b68cd8636bc53150a9095" translate="yes" xml:space="preserve">
          <source>If you're confused about why you use an '@' there on a hash slice instead of a '%', think of it like this. The type of bracket (square or curly) governs whether it's an array or a hash being looked at. On the other hand, the leading symbol ('$' or '@') on the array or hash indicates whether you are getting back a singular value (a scalar) or a plural one (a list).</source>
          <target state="translated">如果你对为什么在哈希片上使用'@'而不是'%'感到困惑,可以这样想。括号的类型(方括号或卷括号)决定了看的是数组还是哈希。另一方面,数组或散列上的前导符号('$'或'@')表示你得到的是一个单数值(标量)还是一个复数值(列表)。</target>
        </trans-unit>
        <trans-unit id="2fdaeb94f7920871da7274b75b49a557aeabaf4a" translate="yes" xml:space="preserve">
          <source>If you're creating a completely new result</source>
          <target state="translated">如果你正在创建一个全新的结果</target>
        </trans-unit>
        <trans-unit id="6e2a7b543e2f454e92700f7b1967ab94c4b894e7" translate="yes" xml:space="preserve">
          <source>If you're currently linking your perl executable to a shared</source>
          <target state="translated">如果你目前正在将你的perl可执行文件链接到一个共享的</target>
        </trans-unit>
        <trans-unit id="5ae9e7742fc3a996e99839cc61f7b8352d875d18" translate="yes" xml:space="preserve">
          <source>If you're debugging a script that uses #!, and normally relies on the shell's $PATH search, the -S option causes perl to do that search, so you don't have to type the path or &lt;code&gt;`which $scriptname`&lt;/code&gt; .</source>
          <target state="translated">如果您正在调试使用＃！的脚本，并且通常依赖于shell的$ PATH搜索，则-S选项会使perl进行该搜索，因此您不必键入路径或 &lt;code&gt;`which $scriptname`&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51555a51b8314a910d76003d95e2f0fdc40d94bc" translate="yes" xml:space="preserve">
          <source>If you're debugging a script that uses #!, and normally relies on the shell's $PATH search, the -S option causes perl to do that search, so you don't have to type the path or &lt;code&gt;`which $scriptname`&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c253632d224aa0744dad2b2922eca154c4278dec" translate="yes" xml:space="preserve">
          <source>If you're deprecating a feature with the intent of later simplifying another bit of code, say so. If you're fixing a performance problem or adding a new feature to support some other bit of the core, mention that.</source>
          <target state="translated">如果你废止一个功能的目的是为了以后简化另一部分代码,那么就说出来。如果你正在修复一个性能问题或添加一个新的功能来支持核心的其他部分,请提及。</target>
        </trans-unit>
        <trans-unit id="b41a3856c0dbc6e888db5696272009c4533b95af" translate="yes" xml:space="preserve">
          <source>If you're developing a CPAN distribution using XS, you may add your own file called</source>
          <target state="translated">如果你正在使用XS开发一个CPAN发行版,你可以添加你自己的文件,叫做</target>
        </trans-unit>
        <trans-unit id="897c140e9db65d769b3515a8af2bf69889950440" translate="yes" xml:space="preserve">
          <source>If you're getting this error from a here-document, you may have included unseen whitespace before or after your closing tag or there may not be a linebreak after it. A good programmer's editor will have a way to help you find these characters (or lack of characters). See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for the full details on here-documents.</source>
          <target state="translated">如果您从此处文档中收到此错误，则可能是在结束标记之前或之后包含了看不见的空格，或者在其后可能没有换行符。一个好的程序员编辑器将有一种方法来帮助您找到这些字符（或缺少字符）。有关此处文档的完整详细信息，请参见&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4fd5cbfd79a1c891c020d447f65eef0d65886a8" translate="yes" xml:space="preserve">
          <source>If you're going to put your Pod at the end of the file, and you're using an &lt;code&gt;__END__&lt;/code&gt; or &lt;code&gt;__DATA__&lt;/code&gt; cut mark, make sure to put an empty line there before the first Pod command.</source>
          <target state="translated">如果要将Pod放在文件末尾，并且使用的是 &lt;code&gt;__END__&lt;/code&gt; 或 &lt;code&gt;__DATA__&lt;/code&gt; 剪切标记，请确保在第一个Pod命令之前在其中放置一个空行。</target>
        </trans-unit>
        <trans-unit id="0fef8c8a09918fb182d2a0653d091964fe4d5654" translate="yes" xml:space="preserve">
          <source>If you're in a slow syscall (like &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;ing, &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt;ing, or &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;ing from your keyboard or a socket) and haven't set up your own &lt;code&gt;$SIG{INT}&lt;/code&gt; handler, then you won't be able to CTRL-C your way back to the debugger, because the debugger's own &lt;code&gt;$SIG{INT}&lt;/code&gt; handler doesn't understand that it needs to raise an exception to longjmp(3) out of slow syscalls.</source>
          <target state="translated">如果您的系统调用速度很慢（例如 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; 或从键盘或套接字 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; ），并且尚未设置自己的 &lt;code&gt;$SIG{INT}&lt;/code&gt; 处理程序，则将无法进行CTRL -C以您的方式返回调试器，因为调试器自己的 &lt;code&gt;$SIG{INT}&lt;/code&gt; 处理程序不了解它需要从缓慢的系统调用中向longjmp（3）引发异常。</target>
        </trans-unit>
        <trans-unit id="d57cc5349a6b3818d37de5b1a80ef5bad92c827e" translate="yes" xml:space="preserve">
          <source>If you're in a slow syscall (like &lt;code&gt;wait&lt;/code&gt;ing, &lt;code&gt;accept&lt;/code&gt;ing, or &lt;code&gt;read&lt;/code&gt;ing from your keyboard or a socket) and haven't set up your own &lt;code&gt;$SIG{INT}&lt;/code&gt; handler, then you won't be able to CTRL-C your way back to the debugger, because the debugger's own &lt;code&gt;$SIG{INT}&lt;/code&gt; handler doesn't understand that it needs to raise an exception to longjmp(3) out of slow syscalls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f4284650d0a24b2d57ce770464abe6b8363cfa" translate="yes" xml:space="preserve">
          <source>If you're just trying to get a print out of each line of Perl code as it executes, the way that &lt;code&gt;sh -x&lt;/code&gt; provides for shell scripts, you can't use Perl's &lt;b&gt;-D&lt;/b&gt; switch. Instead do this</source>
          <target state="translated">如果您只是想在执行Perl代码的每一行中打印出打印内容时，即 &lt;code&gt;sh -x&lt;/code&gt; 为shell脚本提供的方式，则不能使用Perl的&lt;b&gt;-D&lt;/b&gt;开关。而是这样做</target>
        </trans-unit>
        <trans-unit id="e1d724a87dfd2f97b8c95cc8c3b05426d4d76542" translate="yes" xml:space="preserve">
          <source>If you're just trying to patch a binary, in many cases something as simple as this works:</source>
          <target state="translated">如果你只是想给一个二进制文件打补丁,在很多情况下,像这样简单的东西就可以了。</target>
        </trans-unit>
        <trans-unit id="e27c869b95726ef20f74a953d6e15ab7c271a595" translate="yes" xml:space="preserve">
          <source>If you're looking for an EBNF grammar, see &lt;a href=&quot;TAP::Parser::Grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beae682a73c10931e4ab41819afea65e05d531cf" translate="yes" xml:space="preserve">
          <source>If you're looking for an EBNF grammar, see &lt;a href=&quot;parser/grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt;.</source>
          <target state="translated">如果您正在寻找EBNF语法，请参见&lt;a href=&quot;parser/grammar&quot;&gt;TAP :: Parser :: Grammar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55c4ac9978b7084a6172dad11c1733f741ff1455" translate="yes" xml:space="preserve">
          <source>If you're looking for something a bit more rigorous, try &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;.</source>
          <target state="translated">如果您正在寻找更严格的东西，请尝试&lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f56748dfc66ac6cba325f7661836f7de96b1136a" translate="yes" xml:space="preserve">
          <source>If you're looking for the information on how to use here-documents, which used to be here, that's been moved to &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;&quot;Quote and Quote-like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7091178e821abb2a7bce9c92cae74d109146a9a0" translate="yes" xml:space="preserve">
          <source>If you're looking for the information on how to use here-documents, which used to be here, that's been moved to &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">如果您要查找有关如何使用here-documents的信息（以前是在此处），则已将其移至&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlop中的Quote和类似Quote的运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a2047473a3643e10d45494d0ba2e46e4f3bb5994" translate="yes" xml:space="preserve">
          <source>If you're looking for the nitty gritty details of how the debugger is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889cd4ec91070da4d939fc8ed6a3a8c2e2067138" translate="yes" xml:space="preserve">
          <source>If you're looking to write your own object system, or you need to maintain code which implements objects from scratch then this document will help you understand exactly how Perl does object orientation.</source>
          <target state="translated">如果你想写自己的对象系统,或者你需要维护从头开始实现对象的代码,那么这个文档将帮助你了解Perl到底是如何做对象定向的。</target>
        </trans-unit>
        <trans-unit id="ddf0bc3794c8ee98c81f65ada98d73c84a0b3b0d" translate="yes" xml:space="preserve">
          <source>If you're lucky enough to be using a system that supports non-blocking reads (most Unixish systems do), you need only to use the &lt;code&gt;O_NDELAY&lt;/code&gt; or &lt;code&gt;O_NONBLOCK&lt;/code&gt; flag from the &lt;code&gt;Fcntl&lt;/code&gt; module in conjunction with &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">如果您有幸使用支持非阻塞读取的系统（大多数Unixish系统支持），则只需将 &lt;code&gt;Fcntl&lt;/code&gt; 模块中的 &lt;code&gt;O_NDELAY&lt;/code&gt; 或 &lt;code&gt;O_NONBLOCK&lt;/code&gt; 标志与 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; 结合使用：</target>
        </trans-unit>
        <trans-unit id="b92a61260d6789cb413228b4875aba877645cd63" translate="yes" xml:space="preserve">
          <source>If you're lucky enough to be using a system that supports non-blocking reads (most Unixish systems do), you need only to use the &lt;code&gt;O_NDELAY&lt;/code&gt; or &lt;code&gt;O_NONBLOCK&lt;/code&gt; flag from the &lt;code&gt;Fcntl&lt;/code&gt; module in conjunction with &lt;code&gt;sysopen()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1442d0654a360821d205030d12b7c46d2249369f" translate="yes" xml:space="preserve">
          <source>If you're lucky you should see &quot;All tests successful&quot;. But there can be a few failed subtests (less than 5 hopefully) depending on some external conditions (e.g. some subtests fail under linux/dosemu or plain dos with short filenames only).</source>
          <target state="translated">如果你幸运的话,你应该会看到 &quot;All tests succeed&quot;。但是可能会有一些失败的子测试(希望少于5个),这取决于一些外部条件(例如,一些子测试在linux/dosemu或只有短文件名的普通dos下失败)。</target>
        </trans-unit>
        <trans-unit id="81d8181270fe0a221e4cfe0273d672eeca038de7" translate="yes" xml:space="preserve">
          <source>If you're matching against &lt;code&gt;$_&lt;/code&gt; , the &lt;code&gt;$_ =~&lt;/code&gt; part can be omitted:</source>
          <target state="translated">如果要与 &lt;code&gt;$_&lt;/code&gt; 匹配，则可以省略 &lt;code&gt;$_ =~&lt;/code&gt; 部分：</target>
        </trans-unit>
        <trans-unit id="11ac83319ace4cc9c28ca859dfddf15f3ecfbd18" translate="yes" xml:space="preserve">
          <source>If you're matching against &lt;code&gt;$_&lt;/code&gt;, the &lt;code&gt;$_ =~&lt;/code&gt; part can be omitted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dff24fd1b5ec5a9dffa27b27da41b1f996870a7" translate="yes" xml:space="preserve">
          <source>If you're matching against the special default variable &lt;code&gt;$_&lt;/code&gt; , the &lt;code&gt;$_ =~&lt;/code&gt; part can be omitted:</source>
          <target state="translated">如果要与特殊的默认变量 &lt;code&gt;$_&lt;/code&gt; 匹配，则可以省略 &lt;code&gt;$_ =~&lt;/code&gt; 部分：</target>
        </trans-unit>
        <trans-unit id="8117f4845259fee2b7568d80ed0d4624414390b8" translate="yes" xml:space="preserve">
          <source>If you're matching against the special default variable &lt;code&gt;$_&lt;/code&gt;, the &lt;code&gt;$_ =~&lt;/code&gt; part can be omitted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="426f58876b20aa644c87cac6d34c02796b1541e8" translate="yes" xml:space="preserve">
          <source>If you're mixing UTF-8 and non-UTF-8 strings, it is necessary to upgrade the non-UTF-8 strings to UTF-8. If you've got an SV, the easiest way to do this is:</source>
          <target state="translated">如果你把UTF-8和非UTF-8的字符串混合在一起,就需要把非UTF-8的字符串升级到UTF-8。如果你有一个SV,最简单的方法是。</target>
        </trans-unit>
        <trans-unit id="adb368df84ed73d15e6f01f5748e1a829c2701dc" translate="yes" xml:space="preserve">
          <source>If you're more familiar with writing in HTML than with writing in Pod, you can try your hand at writing documentation in simple HTML, and converting it to Pod with the experimental &lt;a href=&quot;Pod::HTML2Pod&quot;&gt;Pod::HTML2Pod&lt;/a&gt; module, (available in CPAN), and looking at the resulting code. The experimental &lt;a href=&quot;Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt; module in CPAN might also be useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b4dc2534030724a7fd2a22ed631de91b923d0d4" translate="yes" xml:space="preserve">
          <source>If you're more familiar with writing in HTML than with writing in Pod, you can try your hand at writing documentation in simple HTML, and converting it to Pod with the experimental &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::HTML2Pod&quot;&gt;Pod::HTML2Pod&lt;/a&gt; module, (available in CPAN), and looking at the resulting code. The experimental &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt; module in CPAN might also be useful.</source>
          <target state="translated">如果您比使用Pod编写更熟悉HTML编写，则可以尝试用简单的HTML编写文档，并使用实验性&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::HTML2Pod&quot;&gt;Pod :: HTML2Pod&lt;/a&gt;模块（在CPAN中可用）将其转换为Pod ，然后查找在生成的代码。CPAN中的实验性&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;模块也可能有用。</target>
        </trans-unit>
        <trans-unit id="661a15733b02e1bde18a48ee6f26023806e52abe" translate="yes" xml:space="preserve">
          <source>If you're more from the object-oriented camp, you can inherit from Storable and directly store your objects by invoking &lt;code&gt;store&lt;/code&gt; as a method. The fact that the root of the to-be-stored tree is a blessed reference (i.e. an object) is special-cased so that the retrieve does not provide a reference to that object but rather the blessed object reference itself. (Otherwise, you'd get a reference to that blessed object).</source>
          <target state="translated">如果您来自面向对象阵营，则可以从Storable继承并通过调用 &lt;code&gt;store&lt;/code&gt; 作为一种方法直接存储对象。待存储树的根是祝福引用（即对象）的事实是特殊情况，因此检索不会提供对该对象的引用，而是提供祝福对象引用本身。（否则，您将获得对该受祝福对象的引用）。</target>
        </trans-unit>
        <trans-unit id="f63fe5eb4649dbb1987379a78d0fe4e091aa300f" translate="yes" xml:space="preserve">
          <source>If you're new to Perl, you should start by running &lt;a href=&quot;perlintro&quot;&gt;&lt;code&gt;perldoc perlintro&lt;/code&gt;&lt;/a&gt;, which is a general intro for beginners and provides some background to help you navigate the rest of Perl's extensive documentation. Run &lt;a href=&quot;perldoc&quot;&gt;&lt;code&gt;perldoc perldoc&lt;/code&gt;&lt;/a&gt; to learn more things you can do with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c11316b76d508e073f9fc77a3e623b3eada282" translate="yes" xml:space="preserve">
          <source>If you're new to Perl, you should start by running &lt;code&gt;perldoc perlintro&lt;/code&gt; , which is a general intro for beginners and provides some background to help you navigate the rest of Perl's extensive documentation. Run &lt;code&gt;perldoc
perldoc&lt;/code&gt; to learn more things you can do with</source>
          <target state="translated">如果您不 &lt;code&gt;perldoc perlintro&lt;/code&gt; Perl，则应该先运行perldoc perlintro，这是初学者的一般介绍，并提供了一些背景知识来帮助您浏览Perl的其他大量文档。运行 &lt;code&gt;perldoc perldoc&lt;/code&gt; 以了解更多您可以使用的功能</target>
        </trans-unit>
        <trans-unit id="744942d070c981ce6cf7077125a9b1fdb8807cc7" translate="yes" xml:space="preserve">
          <source>If you're new to the Perl debugger, you may prefer to read &lt;a href=&quot;perldebtut&quot;&gt;perldebtut&lt;/a&gt;, which is a tutorial introduction to the debugger.</source>
          <target state="translated">如果您不&lt;a href=&quot;perldebtut&quot;&gt;熟悉&lt;/a&gt; Perl调试器，则可能更喜欢阅读perldebtut，这是调试器的教程介绍。</target>
        </trans-unit>
        <trans-unit id="c2727aad3001460d90c1014c2e79041ef3c0a256" translate="yes" xml:space="preserve">
          <source>If you're not running VMS, this module does nothing.</source>
          <target state="translated">如果你没有运行VMS,这个模块什么都不做。</target>
        </trans-unit>
        <trans-unit id="57b30f05d7f8cbe152533a07743b1d8313aa4f82" translate="yes" xml:space="preserve">
          <source>If you're not sure what you have (the &lt;code&gt;VAL&lt;/code&gt; case), wrap the method call in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block to catch the exception if &lt;code&gt;VAL&lt;/code&gt; is undefined.</source>
          <target state="translated">如果不确定自己所拥有的内容（ &lt;code&gt;VAL&lt;/code&gt; 情况），则将方法调用包装在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 块中，以在 &lt;code&gt;VAL&lt;/code&gt; 未定义时捕获异常。</target>
        </trans-unit>
        <trans-unit id="4b417f2069d829972fc28b99377df4b969284461" translate="yes" xml:space="preserve">
          <source>If you're not sure what you have (the &lt;code&gt;VAL&lt;/code&gt; case), wrap the method call in an &lt;code&gt;eval&lt;/code&gt; block to catch the exception if &lt;code&gt;VAL&lt;/code&gt; is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ef540b5bff7fa8b60e3b8701e23d84d3552eb5" translate="yes" xml:space="preserve">
          <source>If you're not the Perl administrator you probably don't have permission to install a module to its default location. Then you should install it for your own use into your home directory like so:</source>
          <target state="translated">如果你不是Perl的管理员,你可能没有权限安装一个模块到它的默认位置。那么你应该像这样把它安装到你的主目录下供自己使用。</target>
        </trans-unit>
        <trans-unit id="247917b0ada3108323df59e4327b62f819afb4ad" translate="yes" xml:space="preserve">
          <source>If you're not the Perl administrator you probably don't have permission to install a module to its default location. Ways of handling this with a &lt;b&gt;lot&lt;/b&gt; less manual effort on your part are &lt;a href=&quot;perlbrew&quot;&gt;perlbrew&lt;/a&gt; and &lt;a href=&quot;local::lib&quot;&gt;local::lib&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33fa0120e14a08b5aff452dd882c3994193525a" translate="yes" xml:space="preserve">
          <source>If you're not used to reading BNF grammars, this is how it works: You're fed certain things by the tokeniser, which generally end up in upper case. &lt;code&gt;ADDOP&lt;/code&gt; and &lt;code&gt;ASSIGNOP&lt;/code&gt; are examples of &quot;terminal symbols&quot;, because you can't get any simpler than them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9feed406758bc42352583f962fb6765533ea27d0" translate="yes" xml:space="preserve">
          <source>If you're not used to reading BNF grammars, this is how it works: You're fed certain things by the tokeniser, which generally end up in upper case. Here, &lt;code&gt;ADDOP&lt;/code&gt; , is provided when the tokeniser sees &lt;code&gt;+&lt;/code&gt; in your code. &lt;code&gt;ASSIGNOP&lt;/code&gt; is provided when &lt;code&gt;=&lt;/code&gt; is used for assigning. These are &quot;terminal symbols&quot;, because you can't get any simpler than them.</source>
          <target state="translated">如果您不习惯阅读BNF语法，那么它就是这样工作的：令牌生成器将某些内容提供给您，通常以大写字母结尾。在这里， &lt;code&gt;ADDOP&lt;/code&gt; ，是当tokeniser看到提供 &lt;code&gt;+&lt;/code&gt; 在你的代码。当使用 &lt;code&gt;=&lt;/code&gt; 进行分配时，将提供 &lt;code&gt;ASSIGNOP&lt;/code&gt; 。这些是&amp;ldquo;终端符号&amp;rdquo;，因为您无法获得比它们更简单的符号。</target>
        </trans-unit>
        <trans-unit id="d41cee3341b958945c48519633ed1e0a770e7261" translate="yes" xml:space="preserve">
          <source>If you're not writing a server/client for an existing protocol like NNTP or SMTP, you should give some thought to how your server will know when the client has finished talking, and vice-versa. Most protocols are based on one-line messages and responses (so one party knows the other has finished when a &quot;\n&quot; is received) or multi-line messages and responses that end with a period on an empty line (&quot;\n.\n&quot; terminates a message/response).</source>
          <target state="translated">如果你不是为现有的协议(如NNTP或SMTP)编写服务器/客户端,你应该考虑一下你的服务器如何知道客户端何时结束通话,反之亦然。大多数协议都是基于单行消息和响应(所以当收到&quot;\n &quot;时,一方知道另一方已经结束了)或多行消息和响应,在空行上以句号结束(&quot;\n.\n &quot;终止一个消息/响应)。</target>
        </trans-unit>
        <trans-unit id="1904985e3da30cf5eb915cfb278068985854bae1" translate="yes" xml:space="preserve">
          <source>If you're not writing such a tool, then whether you accept noncharacters as input is up to you (though the Standard recommends that you not). If you do strict input stream checking with Perl, these code points continue to be forbidden. This is to maintain backward compatibility (otherwise potential security holes could open up, as an unsuspecting application that was written assuming the noncharacters would be filtered out before getting to it, could now, without warning, start getting them). To do strict checking, you can use the layer &lt;code&gt;:encoding('UTF-8')&lt;/code&gt; .</source>
          <target state="translated">如果您不编写此类工具，则是否接受非字符作为输入取决于您（尽管标准建议您不这样做）。如果使用Perl进行严格的输入流检查，则将继续禁止使用这些代码点。这是为了保持向后兼容性（否则可能会打开潜在的安全漏洞，因为编写的一个毫无怀疑的应用程序假设非字符在进入非字符之前将被过滤掉，现在可以不加警告地开始获取它们）。要进行严格检查，可以使用 &lt;code&gt;:encoding('UTF-8')&lt;/code&gt; 层。</target>
        </trans-unit>
        <trans-unit id="d77310220e2c4362538cbb9513e4d5aa5a72b313" translate="yes" xml:space="preserve">
          <source>If you're not writing such a tool, then whether you accept noncharacters as input is up to you (though the Standard recommends that you not). If you do strict input stream checking with Perl, these code points continue to be forbidden. This is to maintain backward compatibility (otherwise potential security holes could open up, as an unsuspecting application that was written assuming the noncharacters would be filtered out before getting to it, could now, without warning, start getting them). To do strict checking, you can use the layer &lt;code&gt;:encoding('UTF-8')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e740be7e86f98ca86a316e7e6f108d26ec4db83" translate="yes" xml:space="preserve">
          <source>If you're on Unix, you already have an IDE--Unix itself. The Unix philosophy is the philosophy of several small tools that each do one thing and do it well. It's like a carpenter's toolbox.</source>
          <target state="translated">如果你在Unix上,你已经有了一个IDE--Unix本身。Unix的哲学是几个小工具各做一件事,而且做得很好。这就像一个木匠的工具箱。</target>
        </trans-unit>
        <trans-unit id="27b6c4407588281e5e7fdb718dd9826644dbabc0" translate="yes" xml:space="preserve">
          <source>If you're on a POSIX system, Perl supports the &lt;code&gt;POSIX::strtod&lt;/code&gt; function for converting strings to doubles (and also &lt;code&gt;POSIX::strtol&lt;/code&gt; for longs). Its semantics are somewhat cumbersome, so here's a &lt;code&gt;getnum&lt;/code&gt; wrapper function for more convenient access. This function takes a string and returns the number it found, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for input that isn't a C float. The &lt;code&gt;is_numeric&lt;/code&gt; function is a front end to &lt;code&gt;getnum&lt;/code&gt; if you just want to say, &quot;Is this a float?&quot;</source>
          <target state="translated">如果您使用的是POSIX系统，则Perl支持 &lt;code&gt;POSIX::strtod&lt;/code&gt; 函数，用于将字符串转换为双精度型（以及 &lt;code&gt;POSIX::strtol&lt;/code&gt; 使用POSIX :: strtol的功能）。它的语义有些繁琐，因此这里有一个 &lt;code&gt;getnum&lt;/code&gt; 包装函数，用于更方便的访问。此函数接受一个字符串并返回找到的数字，对于不是C浮点数的输入，则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。如果您只想说&amp;ldquo;这是浮点数吗？&amp;rdquo; ， &lt;code&gt;is_numeric&lt;/code&gt; 函数是 &lt;code&gt;getnum&lt;/code&gt; 的前端。</target>
        </trans-unit>
        <trans-unit id="47aff00cb7b46f5bee1ecbbd614c85d2d65bb4f4" translate="yes" xml:space="preserve">
          <source>If you're on a POSIX system, Perl supports the &lt;code&gt;POSIX::strtod&lt;/code&gt; function for converting strings to doubles (and also &lt;code&gt;POSIX::strtol&lt;/code&gt; for longs). Its semantics are somewhat cumbersome, so here's a &lt;code&gt;getnum&lt;/code&gt; wrapper function for more convenient access. This function takes a string and returns the number it found, or &lt;code&gt;undef&lt;/code&gt; for input that isn't a C float. The &lt;code&gt;is_numeric&lt;/code&gt; function is a front end to &lt;code&gt;getnum&lt;/code&gt; if you just want to say, &quot;Is this a float?&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe652d8671f9747b2b27fba3ba0a6953bf5a58ab" translate="yes" xml:space="preserve">
          <source>If you're only a C programmer, than this is the end of the message for you. You can quit right now, and if you care to, save off the source and run it when you feel like it. Or not.</source>
          <target state="translated">如果你只是一个C语言程序员,比你的信息就到此为止了。你可以马上退出,如果你愿意的话,可以把源码保存下来,等你喜欢的时候再运行。也可以不运行。</target>
        </trans-unit>
        <trans-unit id="5f443393381ebb2ba3b4781af2f167f994444b4f" translate="yes" xml:space="preserve">
          <source>If you're passing a filehandle to a function, you can write the function in two ways:</source>
          <target state="translated">如果你要把一个filehandle传给一个函数,你可以用两种方式写函数。</target>
        </trans-unit>
        <trans-unit id="3681c9d29e3cea8b052a12522cde089c668422cf" translate="yes" xml:space="preserve">
          <source>If you're passing around filehandles, you could usually just use the bare typeglob, like &lt;code&gt;*STDOUT&lt;/code&gt; , but typeglobs references work, too. For example:</source>
          <target state="translated">如果要传递文件句柄，通常可以只使用裸机的typeglob，例如 &lt;code&gt;*STDOUT&lt;/code&gt; ，但是typeglobs引用也可以。例如：</target>
        </trans-unit>
        <trans-unit id="298de4014a3a85ac5b8366c5095b3672193b40a2" translate="yes" xml:space="preserve">
          <source>If you're passing around filehandles, you could usually just use the bare typeglob, like &lt;code&gt;*STDOUT&lt;/code&gt;, but typeglobs references work, too. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f816f45cbfc0eef6f9ae6c1011d3c4a6ca61924" translate="yes" xml:space="preserve">
          <source>If you're planning on generating new filehandles, you could do this. Notice to pass back just the bare *FH, not its reference.</source>
          <target state="translated">如果你打算生成新的filehandles,你可以这样做。注意只传回裸的*FH,而不是它的引用。</target>
        </trans-unit>
        <trans-unit id="e8bfd94e153d8978fbc196c7118de9fb39d2dab3" translate="yes" xml:space="preserve">
          <source>If you're planning to do more extensive work than a single small fix, we encourage you to read the documentation below. This will help you focus your work and make your patches easier to incorporate into the Perl source.</source>
          <target state="translated">如果你打算做比单一的小修复更广泛的工作,我们鼓励你阅读下面的文档。这将帮助你集中精力,并使你的补丁更容易纳入Perl源代码。</target>
        </trans-unit>
        <trans-unit id="2a89224882a8273613d6c7a7a7b1c88a5cbcd4d7" translate="yes" xml:space="preserve">
          <source>If you're planning to filetest the return values out of a &lt;a href=&quot;#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt;, you'd better prepend the directory in question. Otherwise, because we didn't &lt;a href=&quot;#chdir-EXPR&quot;&gt;&lt;code&gt;chdir&lt;/code&gt;&lt;/a&gt; there, it would have been testing the wrong file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304b9d32f29eb0f2f218ff94e8f5f53580345dcb" translate="yes" xml:space="preserve">
          <source>If you're planning to filetest the return values out of a &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, you'd better prepend the directory in question. Otherwise, because we didn't &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; there, it would have been testing the wrong file.</source>
          <target state="translated">如果你打算filetest返回值出的 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; ，你最好在前面加上有问题的目录。否则，因为我们在那里没有 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; ，它将一直在测试错误的文件。</target>
        </trans-unit>
        <trans-unit id="f907870b50e1902094cd7a51307296876f77264b" translate="yes" xml:space="preserve">
          <source>If you're planning to filetest the return values out of a &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, you'd better prepend the directory in question. Otherwise, because we didn't &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; there, it would have been testing the wrong file.</source>
          <target state="translated">如果你打算filetest返回值出的 &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; ，你最好在前面加上有问题的目录。否则，因为我们在那里没有 &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; ，它将一直在测试错误的文件。</target>
        </trans-unit>
        <trans-unit id="a8c4c2e820002b650e8d2ecdec056a32fb436bfd" translate="yes" xml:space="preserve">
          <source>If you're reading this document because you want to write a formatter subclass, continue reading it and then read &lt;a href=&quot;Pod::Simple::Subclassing&quot;&gt;Pod::Simple::Subclassing&lt;/a&gt;, and then possibly even read &lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec&lt;/a&gt; (some of which is for parser-writers, but much of which is notes to formatter-writers).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcece448e0aa8ee8873fb9b13cee8077eaed1e18" translate="yes" xml:space="preserve">
          <source>If you're reading this document because you want to write a formatter subclass, continue reading it and then read &lt;a href=&quot;simple/subclassing&quot;&gt;Pod::Simple::Subclassing&lt;/a&gt;, and then possibly even read &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt; (some of which is for parser-writers, but much of which is notes to formatter-writers).</source>
          <target state="translated">如果您由于要编写格式化程序子类而正在阅读本文档，请继续阅读该文档，然后阅读&lt;a href=&quot;simple/subclassing&quot;&gt;Pod :: Simple :: Subclassing&lt;/a&gt;，然后甚至可能阅读&lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;（其中一些是用于解析器-编写器的，但其中很多是是给格式化作者的注释）。</target>
        </trans-unit>
        <trans-unit id="3eca1cf4cac957f4047c12a2cccf4d8bf7c0618e" translate="yes" xml:space="preserve">
          <source>If you're reading this document just because you have a Pod-processing subclass that you want to use, this document (plus the documentation for the subclass) is probably all you need to read.</source>
          <target state="translated">如果你读这个文档只是因为你有一个你想使用的Pod处理子类,这个文档(加上子类的文档)可能是你需要阅读的全部内容。</target>
        </trans-unit>
        <trans-unit id="b7d2d7b7f7d3b1824419996342901896caf3e1ec" translate="yes" xml:space="preserve">
          <source>If you're running Perl on a system that distinguishes between text files and binary files, then you should check out &lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt; for tips for dealing with this. The key distinction between systems that need &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; and those that don't is their text file formats. Systems like Unix, Mac OS, and Plan 9, that end lines with a single character and encode that character in C as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; do not need &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt;. The rest need it.</source>
          <target state="translated">如果要在区分文本文件和二进制文件的系统上运行Perl，则应查看&lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt;中有关处理此问题的技巧。需要 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 的系统和不需要binmode的系统之间的主要区别是其文本文件格式。像Unix，Mac OS和Plan 9这样的系统，它们的结尾行带有单个字符并将该字符在C中编码为 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 则不需要 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 。其余的需要它。</target>
        </trans-unit>
        <trans-unit id="ffabd87b995f6de8b55fa057fefd0560b9ffddaf" translate="yes" xml:space="preserve">
          <source>If you're running Perl on a system that distinguishes between text files and binary files, then you should check out &lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt; for tips for dealing with this. The key distinction between systems that need &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; and those that don't is their text file formats. Systems like Unix, Mac OS, and Plan 9, that end lines with a single character and encode that character in C as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; do not need &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt;. The rest need it.</source>
          <target state="translated">如果要在区分文本文件和二进制文件的系统上运行Perl，则应查看&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;中有关处理此问题的技巧。需要 &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 的系统和不需要binmode的系统之间的主要区别是其文本文件格式。像Unix，Mac OS和Plan 9这样的系统，它们的结尾行带有单个字符并将该字符在C中编码为 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 则不需要 &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 。其余的需要它。</target>
        </trans-unit>
        <trans-unit id="c1457648c4ce0280355f7ef1bc996151dcbc9e3b" translate="yes" xml:space="preserve">
          <source>If you're running under VMS, the routines in this package are special, in that they're automatically made available to any Perl script, whether you're running</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c1b50b544a3df322b75f65dc11d5ac4c69a35f" translate="yes" xml:space="preserve">
          <source>If you're storing handles in an array or hash, or in general whenever you're using any expression more complex than a bareword handle or a plain, unsubscripted scalar variable to retrieve it, you will have to use a block returning the filehandle value instead, in which case the LIST may not be omitted:</source>
          <target state="translated">如果你在数组或哈希中存储句柄,或者在一般情况下,只要你使用任何比裸词句柄或普通的无标量变量更复杂的表达式来检索它,你将不得不使用一个返回filehandle值的块来代替,在这种情况下,LIST可能不会被省略。</target>
        </trans-unit>
        <trans-unit id="1ed2a4901ca871ef8cee85b2ad371ae78f316632" translate="yes" xml:space="preserve">
          <source>If you're submitting values using the GET method, create a URL and encode the form using the &lt;code&gt;query_form&lt;/code&gt; method:</source>
          <target state="translated">如果要使用GET方法提交值，请创建一个URL并使用 &lt;code&gt;query_form&lt;/code&gt; 方法对表单进行编码：</target>
        </trans-unit>
        <trans-unit id="8589815d02edc83abce0f57d2f0a5efb5068a683" translate="yes" xml:space="preserve">
          <source>If you're submitting values using the GET method, create a URL and encode the form using the &lt;code&gt;www_form_urlencode&lt;/code&gt; method from &lt;a href=&quot;HTTP::Tiny&quot;&gt;HTTP::Tiny&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3997ad77a6ffe99bd09989a635705961b00c6f35" translate="yes" xml:space="preserve">
          <source>If you're talking about obscuring method calls in parent classes, see &lt;a href=&quot;perlootut#Overriding-methods-and-method-resolution&quot;&gt;&quot;Overriding methods and method resolution&quot; in perlootut&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f5ca288d27f19393728db02ea58b007b723ea8" translate="yes" xml:space="preserve">
          <source>If you're talking about obscuring method calls in parent classes, see &lt;a href=&quot;perlootut#Overriding-methods-and-method-resolution&quot;&gt;Overriding methods and method resolution in perlootut&lt;/a&gt;.</source>
          <target state="translated">如果您要讨论父类中的方法调用，请参阅&lt;a href=&quot;perlootut#Overriding-methods-and-method-resolution&quot;&gt;在perlootut中覆盖方法和方法解析&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9fb0313a494e266734d606dab0fb4c3f5c1638a" translate="yes" xml:space="preserve">
          <source>If you're trying to do variable interpolation, it's definitely better to use the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; function, because the older notation can cause people to become confused with the indirect filehandle notation.</source>
          <target state="translated">如果您尝试进行变量插值，则最好使用 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; 函数，因为较旧的表示法可能会使人们与间接文件句柄表示法混淆。</target>
        </trans-unit>
        <trans-unit id="6bfd1f418444ef167b4c1d82e3071f7953fa2d61" translate="yes" xml:space="preserve">
          <source>If you're trying to do variable interpolation, it's definitely better to use the &lt;code&gt;glob()&lt;/code&gt; function, because the older notation can cause people to become confused with the indirect filehandle notation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f801c8c750d6402e7dad5eddfca92a856a8093" translate="yes" xml:space="preserve">
          <source>If you're unsure of the meaning of an error message you've run across, &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; for an explanation. If the message isn't in perldiag, it probably isn't generated by Perl. You may have luck consulting your operating system documentation instead.</source>
          <target state="translated">如果不确定所遇到的错误消息的含义，请使用&lt;b&gt;perldoc &lt;/b&gt;&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;进行解释。如果消息不在perldiag中，则可能不是Perl生成的。您可能会改而查阅操作系统文档。</target>
        </trans-unit>
        <trans-unit id="4b93133a107f3dc1672015bebe523f72dafb6b9f" translate="yes" xml:space="preserve">
          <source>If you're uploading to CPAN, the automated gremlins will extract the README file and place that in your CPAN directory. It'll also appear in the main</source>
          <target state="translated">如果你要上传到CPAN,自动化的Gremlins会提取README文件,并把它放在你的CPAN目录中。它也会出现在主目录下的</target>
        </trans-unit>
        <trans-unit id="3ad89e38e60f381b4a7eacce6c02e2db727251db" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;Archive::Tar&lt;/code&gt; 's &lt;code&gt;extract()&lt;/code&gt; method, &lt;code&gt;setcwd()&lt;/code&gt; will be called for you.</source>
          <target state="translated">如果您使用 &lt;code&gt;Archive::Tar&lt;/code&gt; 的 &lt;code&gt;extract()&lt;/code&gt; 方法， &lt;code&gt;setcwd()&lt;/code&gt; 为您调用setcwd（）。</target>
        </trans-unit>
        <trans-unit id="c63cdfe81388f5792f978ef625e22f4f10866e25" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;Archive::Tar&lt;/code&gt;'s &lt;code&gt;extract()&lt;/code&gt; method, &lt;code&gt;setcwd()&lt;/code&gt; will be called for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc14a892bad71218591bbe7bbef35b81fe36647" translate="yes" xml:space="preserve">
          <source>If you're using VMStar:</source>
          <target state="translated">如果你使用的是VMStar。</target>
        </trans-unit>
        <trans-unit id="907bb15f43743b61b1d7e7cd7fb29070f01e69a0" translate="yes" xml:space="preserve">
          <source>If you're using a module that's not thread-safe for some reason, you can protect yourself by using it from one, and only one thread at all. If you need multiple threads to access such a module, you can use semaphores and lots of programming discipline to control access to it. Semaphores are covered in &lt;a href=&quot;#Basic-semaphores&quot;&gt;&quot;Basic semaphores&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76511f6d042eedee604ffae23aa88974c6f04729" translate="yes" xml:space="preserve">
          <source>If you're using a module that's not thread-safe for some reason, you can protect yourself by using it from one, and only one thread at all. If you need multiple threads to access such a module, you can use semaphores and lots of programming discipline to control access to it. Semaphores are covered in &lt;a href=&quot;#Basic-semaphores&quot;&gt;Basic semaphores&lt;/a&gt;.</source>
          <target state="translated">如果您出于某种原因使用的模块不是线程安全的，则可以通过一个模块（仅一个线程）使用它来保护自己。如果您需要多个线程来访问此类模块，则可以使用信号量和大量编程规范来控制对其的访问。信号量包含在&lt;a href=&quot;#Basic-semaphores&quot;&gt;基本信号量中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9aa1259aa5ab1edcbb7c8ec755fbb7d9933607e8" translate="yes" xml:space="preserve">
          <source>If you're using a version of Perl before 5.004, you must call &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; once at the start of your program to seed the random number generator.</source>
          <target state="translated">如果您使用的是5.004之前的Perl版本，则必须在程序开始时调用 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 一次，以播种随机数生成器。</target>
        </trans-unit>
        <trans-unit id="45f120602aeb67edc0215d28ccd9011716655e69" translate="yes" xml:space="preserve">
          <source>If you're using a version of Perl before 5.004, you must call &lt;code&gt;srand&lt;/code&gt; once at the start of your program to seed the random number generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ff91ee4a99e5bbc7fa9f896e9934c1f57633ce3" translate="yes" xml:space="preserve">
          <source>If you're using localization in an application that keeps a configuration file, you might consider something like this in your project class:</source>
          <target state="translated">如果你在一个保存配置文件的应用程序中使用本地化,你可以考虑在你的项目类中使用这样的东西。</target>
        </trans-unit>
        <trans-unit id="e98919158b85262f93e6e1cca66f69e28561af51" translate="yes" xml:space="preserve">
          <source>If you're using references as keys within your hash tables, you're bound to be disappointed when retrieving your data. Indeed, Perl stringifies references used as hash table keys. If you later wish to access the items via another reference stringification (i.e. using the same reference that was used for the key originally to record the value into the hash table), it will work because both references stringify to the same string.</source>
          <target state="translated">如果你在哈希表中使用引用作为键,那么在检索数据时,你一定会失望。事实上,Perl对用作哈希表键的引用进行了字符串化处理。如果你以后想通过另一个引用串化(即使用最初用于键的同一个引用将值记录到哈希表中)来访问这些项目,就会成功,因为两个引用都串化成了同一个字符串。</target>
        </trans-unit>
        <trans-unit id="cda64e05edf4afefc7befad6697f98377f63d5c2" translate="yes" xml:space="preserve">
          <source>If you're using strict, you</source>
          <target state="translated">如果你使用严格的,你</target>
        </trans-unit>
        <trans-unit id="5149a95571d7bad870cf9d14644f05c40d4e4c11" translate="yes" xml:space="preserve">
          <source>If you're using the POST method, create your own user agent and encode the content appropriately.</source>
          <target state="translated">如果你使用的是POST方式,请创建自己的用户代理,并对内容进行适当的编码。</target>
        </trans-unit>
        <trans-unit id="aa3146750972f670c3e28f005d36e51430c4e4f6" translate="yes" xml:space="preserve">
          <source>If you're using the POST method, the &lt;code&gt;post_form&lt;/code&gt; method will encode the content appropriately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94dea5f329a320df5b1676d594bbe7ddb6af4d25" translate="yes" xml:space="preserve">
          <source>If you're using untarzipme or StuffIt, the archive should be extracted now. &lt;b&gt;Or&lt;/b&gt;, you can use the freeware &lt;b&gt;suntar&lt;/b&gt; or</source>
          <target state="translated">如果您使用的是untarzipme或StuffIt，则应立即提取存档。&lt;b&gt;或者&lt;/b&gt;，您可以使用免费软件&lt;b&gt;suntar&lt;/b&gt;或</target>
        </trans-unit>
        <trans-unit id="03aaa8fe5a352318fc187dc162360b47448bfe8d" translate="yes" xml:space="preserve">
          <source>If you're working with globs at runtime, and need to disambiguate *^G from *{&quot;^G&quot;}, then you should use the raw NAME method.</source>
          <target state="translated">如果您在运行时使用 globs,并且需要从 *{&quot;^G&quot;}中辨别出 *^G,那么您应该使用 raw NAME 方法。</target>
        </trans-unit>
        <trans-unit id="86326ce985c6268f6aa266be33a273db0ac99980" translate="yes" xml:space="preserve">
          <source>If you're worried about users selecting bad passwords, you should proactively check when they try to change their password (by modifying</source>
          <target state="translated">如果你担心用户选择了不好的密码,你应该在他们试图更改密码时主动检查(通过修改</target>
        </trans-unit>
        <trans-unit id="bc54d6339a6f99949e77b0d38ee469b66f200a38" translate="yes" xml:space="preserve">
          <source>If you're worried about users selecting bad passwords, you should proactively check when they try to change their password (by modifying &lt;a href=&quot;http://man.he.net/man1/passwd&quot;&gt;passwd(1)&lt;/a&gt;, for example).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c631e014f0d55506d4df289cf9b8b44d3544afb4" translate="yes" xml:space="preserve">
          <source>If you're writing code, such as an editor, that is supposed to be able to handle any Unicode text data, then you shouldn't be using these code points yourself, and instead allow them in the input. If you need sentinels, they should instead be something that isn't legal Unicode. For UTF-8 data, you can use the bytes 0xC1 and 0xC2 as sentinels, as they never appear in well-formed UTF-8. (There are equivalents for UTF-EBCDIC). You can also store your Unicode code points in integer variables and use negative values as sentinels.</source>
          <target state="translated">如果你写的代码,比如编辑器,应该能够处理任何Unicode文本数据,那么你不应该自己使用这些代码点,而应该在输入中允许使用。如果你需要哨兵,他们反而应该是一些不合法的Unicode。对于UTF-8数据,你可以使用字节0xC1和0xC2作为哨兵,因为它们从来不会出现在格式良好的UTF-8中。(UTF-EBCDIC也有等价物)。您也可以将Unicode码点存储在整数变量中,并使用负值作为哨兵。</target>
        </trans-unit>
        <trans-unit id="ddd87126ab7eec259a7e6ec167a9a1ed6e855f3d" translate="yes" xml:space="preserve">
          <source>If you're writing your own &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, you may need to create your own iterators too. If so you'll need to subclass &lt;a href=&quot;TAP::Parser::Iterator&quot;&gt;TAP::Parser::Iterator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a276dfc7f44e7268960d2975b30664b78a301f5a" translate="yes" xml:space="preserve">
          <source>If you're writing your own &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, you may need to create your own iterators too. If so you'll need to subclass &lt;a href=&quot;parser/iterator&quot;&gt;TAP::Parser::Iterator&lt;/a&gt;.</source>
          <target state="translated">如果您正在编写自己的&lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;，则可能还需要创建自己的迭代器。如果是这样，则需要子类&lt;a href=&quot;parser/iterator&quot;&gt;TAP :: Parser :: Iterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d3ca82cb6d85e36f098b04f831321b68f9f28ab" translate="yes" xml:space="preserve">
          <source>If you're writing your own documentation in POD, the</source>
          <target state="translated">如果你是在POD中编写自己的文档,那么在POD中的</target>
        </trans-unit>
        <trans-unit id="7e39071fa8860b1c165c3510aa6e985ec88eb293" translate="yes" xml:space="preserve">
          <source>If you've already got some other kind of email object, consider passing it to &lt;a href=&quot;Email::Abstract&quot;&gt;Email::Abstract&lt;/a&gt; and then using its cast method to get an &lt;a href=&quot;Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609941eec97975f4a0354cdbfbac32c60f31f261" translate="yes" xml:space="preserve">
          <source>If you've already got some other kind of email object, consider passing it to &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Abstract&quot;&gt;Email::Abstract&lt;/a&gt; and then using its cast method to get an &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; object:</source>
          <target state="translated">如果您已经有了其他类型的电子邮件对象，请考虑将其传递给&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Abstract&quot;&gt;Email :: Abstract&lt;/a&gt;，然后使用其强制转换方法来获取&lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email :: MIME&lt;/a&gt;对象：</target>
        </trans-unit>
        <trans-unit id="49b89fe4b531fe550fa8cdc2584e0b4d10940e84" translate="yes" xml:space="preserve">
          <source>If you've been around Perl a while, all this talk of escape sequences may seem familiar. Similar escape sequences are used in double-quoted strings and in fact the regexps in Perl are mostly treated as double-quoted strings. This means that variables can be used in regexps as well. Just like double-quoted strings, the values of the variables in the regexp will be substituted in before the regexp is evaluated for matching purposes. So we have:</source>
          <target state="translated">如果你在Perl中呆过一段时间,那么这些关于转义序列的说法可能会显得很熟悉。类似的转义序列在双引号字符串中也有使用,事实上Perl中的regexps大多被当作双引号字符串。这意味着变量也可以在regexps中使用。就像双引号字符串一样,在评估 regexp 之前,变量的值会被替换进去,以达到匹配的目的。所以我们有</target>
        </trans-unit>
        <trans-unit id="3fd6cd86298d336909fb8326200590d5396e0f52" translate="yes" xml:space="preserve">
          <source>If you've chosen to use vac 4, be sure to run 4.4.0.3. Older versions will turn up nasty later on. For vac 5 be sure to run at least 5.0.1.0, but vac 5.0.2.6 or up is highly recommended. Note that since IBM has removed vac 5.0.2.1 through 5.0.2.5 from the software depot, these versions should be considered obsolete.</source>
          <target state="translated">如果你选择了使用vac 4,一定要运行4.4.0.3。旧版本以后会出现讨厌的情况。对于vac 5一定要至少运行5.0.1.0,但强烈建议使用vac 5.0.2.6或以上版本。请注意,由于IBM已经从软件仓库中删除了vac 5.0.2.1到5.0.2.5,这些版本应该被认为是过时的。</target>
        </trans-unit>
        <trans-unit id="d7141035b834e9d56f2958df18eb9cabc9003c5d" translate="yes" xml:space="preserve">
          <source>If you've found a bug with the perl interpreter or one of the modules in the standard library (those that come with Perl), you can submit a bug report to the GitHub issue tracker at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f36de392e6562a98fef168bd0f4fd2b6d55a056" translate="yes" xml:space="preserve">
          <source>If you've found a bug with the perl interpreter or one of the modules in the standard library (those that come with Perl), you can use the &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; utility that comes with Perl (&amp;gt;= 5.004). It collects information about your installation to include with your message, then sends the message to the right place.</source>
          <target state="translated">如果在perl解释器或标准库中的一个模块（Perl 随附的模块）中发现了错误，则可以使用Perl随附的&lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt;实用程序（&amp;gt; = 5.004）。它收集有关安装的信息以包括在消息中，然后将消息发送到正确的位置。</target>
        </trans-unit>
        <trans-unit id="b588af6702d40920fe6ce77142ddd4be23c82335" translate="yes" xml:space="preserve">
          <source>If you've just implemented a new feature, complete with doc, tests and well-commented code, a brief commit message will often suffice. If, however, you've just changed a single character deep in the parser or lexer, you might need to write a small novel to ensure that future readers understand what you did and why you did it.</source>
          <target state="translated">如果你刚刚实现了一个新的功能,包括文档、测试和注释完整的代码,那么一个简短的提交信息通常就足够了。然而,如果你只是在解析器或词典的深处修改了一个字符,你可能需要写一篇小小说,以确保未来的读者明白你做了什么以及为什么这么做。</target>
        </trans-unit>
        <trans-unit id="f8a6a3763262120fa20c3dbe30b8abff9d5efbc9" translate="yes" xml:space="preserve">
          <source>If you've played with the examples above and tried to embed a script that</source>
          <target state="translated">如果你玩过上面的例子,并试图嵌入一个脚本,那就是</target>
        </trans-unit>
        <trans-unit id="b894c5ed183f4f7ceceb8937af0c436c24867f7d" translate="yes" xml:space="preserve">
          <source>If you've read all the documentation in the document and the ones listed above, you're more than ready to hack on Perl.</source>
          <target state="translated">如果你已经阅读了文档中的所有文档和上面列出的文档,你已经做好了在Perl上黑客的准备。</target>
        </trans-unit>
        <trans-unit id="f7a6adb80f0b785d2ca1e30e58d59926760d3865" translate="yes" xml:space="preserve">
          <source>If you've read this far in the docs, you've seen this:</source>
          <target state="translated">如果你读了这么多文档,你已经看到了这个。</target>
        </trans-unit>
        <trans-unit id="a5397b1b280e497ccfa7136829a3dcfe46903bd5" translate="yes" xml:space="preserve">
          <source>If you've selected VMS syntax, and the file specification you pass to one of these routines contains a &quot;/&quot;, they assume you are using Unix emulation and apply the Unix syntax rules instead, for that function call only.</source>
          <target state="translated">如果你选择了VMS语法,并且你传递给这些例程的文件规范中包含了&quot;/&quot;,那么它们会假设你使用的是Unix仿真,并且仅对该函数调用应用Unix语法规则。</target>
        </trans-unit>
        <trans-unit id="33caaa832315103fc3c31014628789c923502260" translate="yes" xml:space="preserve">
          <source>If you, as a user, do not need explicit access to the &quot;seen&quot; hash, then you can set the &lt;code&gt;Sparseseen&lt;/code&gt; option to allow Data::Dumper to eschew building the &quot;seen&quot; hash for scalars that are known not to possess more than one reference. This speeds up serialization considerably if you use the XS implementation.</source>
          <target state="translated">如果您作为用户不需要显式访问&amp;ldquo;看到的&amp;rdquo;哈希，则可以设置 &lt;code&gt;Sparseseen&lt;/code&gt; 选项以允许Data :: Dumper避开为已知的标量不拥有超过的标量构建&amp;ldquo;看到的&amp;rdquo;哈希一个参考。如果使用XS实现，则可以大大加快序列化速度。</target>
        </trans-unit>
        <trans-unit id="5641fffcc326bff3bce0a7d7f55bb29dc536ec90" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;DESTROY&lt;/code&gt; method issues a warning during global destruction, the Perl interpreter will append the string &quot; during global destruction&quot; to the warning.</source>
          <target state="translated">如果您的 &lt;code&gt;DESTROY&lt;/code&gt; 方法在全局销毁期间发出警告，则Perl解释器会将字符串&amp;ldquo;全局销毁期间&amp;rdquo;附加到警告中。</target>
        </trans-unit>
        <trans-unit id="e35bc3de6478c74b3aa05b11b90d2c08a9c1eb35" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;DESTROY&lt;/code&gt; method throws an error, this error will be ignored. It will not be sent to &lt;code&gt;STDERR&lt;/code&gt; and it will not cause the program to die. However, if your destructor is running inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; block, then the error will change the value of &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">如果您的 &lt;code&gt;DESTROY&lt;/code&gt; 方法抛出错误，则将忽略此错误。它不会被发送到 &lt;code&gt;STDERR&lt;/code&gt; ，也不会导致程序死亡。但是，如果析构函数在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 块内运行，则该错误将更改 &lt;code&gt;$@&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="fc569fc556abfc5922ff5d102893edd09c51cd29" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;DESTROY&lt;/code&gt; method throws an exception, this will not cause any control transfer beyond exiting the method. The exception will be reported to &lt;code&gt;STDERR&lt;/code&gt; as a warning, marked &quot;(in cleanup)&quot;, and Perl will continue with whatever it was doing before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd8f1a46e80e1b05c149003c578cc17ee1529e3e" translate="yes" xml:space="preserve">
          <source>If your AIX is installed with 64-bit support, you can expect 64-bit configurations to work. In combination with threads some tests might still fail.</source>
          <target state="translated">如果你的AIX安装了64位支持,你可以期待64位配置能够工作。结合线程,一些测试可能仍然会失败。</target>
        </trans-unit>
        <trans-unit id="91cec945ceabbd679cf0509d145b2a724547b098" translate="yes" xml:space="preserve">
          <source>If your AIX system is installed with 64-bit support, you can expect 64-bit configurations to work. If you want to use 64-bit Perl on AIX 6.1 you need an APAR for a libc.a bug which affects (n)dbm_XXX functions. The APAR number for this problem is IZ39077.</source>
          <target state="translated">如果你的AIX系统安装了64位支持,你可以期待64位的配置能够工作。如果你想在 AIX 6.1 上使用 64 位的 Perl,你需要一个 APAR 来解决 libc.a 的 bug,这个 bug 会影响 (n)dbm_XXX 函数。这个问题的 APAR 编号是 IZ39077。</target>
        </trans-unit>
        <trans-unit id="70f3f72afc2e138648aa89e71840c2969a866fbe" translate="yes" xml:space="preserve">
          <source>If your EXISTS function returns true, Memoize will try to fetch the cached value by invoking &lt;code&gt;C-&amp;gt;FETCH(key)&lt;/code&gt; . MyExpirePolicy::FETCH should return the cached value. Otherwise, Memoize will call the memoized function to compute the appropriate value, and will store it into the cache by calling &lt;code&gt;C-&amp;gt;STORE(key, value)&lt;/code&gt; .</source>
          <target state="translated">如果您的EXISTS函数返回true，则Memoize将尝试通过调用 &lt;code&gt;C-&amp;gt;FETCH(key)&lt;/code&gt; 来获取缓存的值。MyExpirePolicy :: FETCH应该返回缓存的值。否则，Memoize将调用被记忆的函数来计算适当的值，并通过调用 &lt;code&gt;C-&amp;gt;STORE(key, value)&lt;/code&gt; 将其存储到缓存中。</target>
        </trans-unit>
        <trans-unit id="24acb5b4fe58034fbc714327d4b7fa709ac07a2e" translate="yes" xml:space="preserve">
          <source>If your EXISTS function returns true, Memoize will try to fetch the cached value by invoking &lt;code&gt;C-&amp;gt;FETCH(key)&lt;/code&gt;. MyExpirePolicy::FETCH should return the cached value. Otherwise, Memoize will call the memoized function to compute the appropriate value, and will store it into the cache by calling &lt;code&gt;C-&amp;gt;STORE(key, value)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e28af787c875d4ef84c9b0c4d899259d2721791" translate="yes" xml:space="preserve">
          <source>If your PO and MO files are under a path elsewhere than &lt;code&gt;auto/&lt;/code&gt; , you may specify it using the &lt;code&gt;Path&lt;/code&gt; option.</source>
          <target state="translated">如果您的PO和MO文件位于 &lt;code&gt;auto/&lt;/code&gt; 之外的其他路径下，则可以使用&amp;ldquo; &lt;code&gt;Path&lt;/code&gt; 选项进行指定。</target>
        </trans-unit>
        <trans-unit id="6409d07584753033defae54495b9d4c75a783436" translate="yes" xml:space="preserve">
          <source>If your PO and MO files are under a path elsewhere than &lt;code&gt;auto/&lt;/code&gt;, you may specify it using the &lt;code&gt;Path&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c89e96cd32d30e30553bcd6fbdd11d2690ecc7" translate="yes" xml:space="preserve">
          <source>If your Perl book isn't listed and you think it should be, let us know.</source>
          <target state="translated">如果您的 Perl 书籍没有被列出,而您又认为它应该被列出,请告诉我们。</target>
        </trans-unit>
        <trans-unit id="6d6e9b58c49da08447f00e52e9068c5bb7576426" translate="yes" xml:space="preserve">
          <source>If your Perl script is itself encoded in &lt;a href=&quot;#Unicode-Encodings&quot;&gt;UTF-8&lt;/a&gt;, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma must be explicitly included to enable recognition of that (in string or regular expression literals, or in identifier names). &lt;b&gt;This is the only time when an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
utf8&lt;/code&gt; is needed.&lt;/b&gt; (See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;).</source>
          <target state="translated">如果您的Perl脚本本身是用&lt;a href=&quot;#Unicode-Encodings&quot;&gt;UTF-8&lt;/a&gt;编码的，则必须明确包括 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;用法&lt;/a&gt;，以便能够识别它（在字符串或正则表达式文字中或在标识符名称中）。&lt;b&gt;这是唯一需要显式 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 时间。&lt;/b&gt;（请参阅&lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="17170cc5afbf6627bb42f8bd492f952db9b4e546" translate="yes" xml:space="preserve">
          <source>If your Perl script is itself encoded in &lt;a href=&quot;#Unicode-Encodings&quot;&gt;UTF-8&lt;/a&gt;, the &lt;code&gt;use utf8&lt;/code&gt; pragma must be explicitly included to enable recognition of that (in string or regular expression literals, or in identifier names). &lt;b&gt;This is the only time when an explicit &lt;code&gt;use utf8&lt;/code&gt; is needed.&lt;/b&gt; (See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1456eed38b989e671412e5dabebc6b17a35fdee8" translate="yes" xml:space="preserve">
          <source>If your Perl success stories and testimonials may be of help to others who wish to advocate the use of Perl in their applications, or if you wish to simply express your gratitude to Larry and the Perl developers, please write to perl-thanks@perl.org .</source>
          <target state="translated">如果您的Perl成功案例和推荐对其他希望在应用程序中使用Perl的人有帮助,或者您只想表达对Larry和Perl开发者的感激之情,请写信到 perl-thanks@perl.org 。</target>
        </trans-unit>
        <trans-unit id="bb4511b53500ce7e796c6be816fd150d579ce6bd" translate="yes" xml:space="preserve">
          <source>If your Perl was configured with &lt;b&gt;-Accflags=-DPERL_MEM_LOG&lt;/b&gt;, setting the environment variable &lt;code&gt;PERL_MEM_LOG&lt;/code&gt; enables logging debug messages. The value has the form &lt;code&gt;&amp;lt;&lt;i&gt;number&lt;/i&gt;&amp;gt;[m][s][t]&lt;/code&gt;, where &lt;code&gt;&lt;i&gt;number&lt;/i&gt;&lt;/code&gt; is the file descriptor number you want to write to (2 is default), and the combination of letters specifies that you want information about (m)emory and/or (s)v, optionally with (t)imestamps. For example, &lt;code&gt;PERL_MEM_LOG=1mst&lt;/code&gt; logs all information to stdout. You can write to other opened file descriptors in a variety of ways:</source>
          <target state="translated">如果您的Perl是使用&lt;b&gt;-Accflags = -DPERL_MEM_LOG&lt;/b&gt;配置的，则设置环境变量 &lt;code&gt;PERL_MEM_LOG&lt;/code&gt; 会启用日志记录调试消息。该值的格式为 &lt;code&gt;&amp;lt;&lt;i&gt;number&lt;/i&gt;&amp;gt;[m][s][t]&lt;/code&gt; ，其中 &lt;code&gt;&lt;i&gt;number&lt;/i&gt;&lt;/code&gt; 是要写入的文件描述符号（默认为2），字母组合指定您需要有关（m）的信息emory和/或（s）v，可选地包含（t）imestamp。例如， &lt;code&gt;PERL_MEM_LOG=1mst&lt;/code&gt; 将所有信息记录到stdout。您可以通过多种方式写入其他打开的文件描述符：</target>
        </trans-unit>
        <trans-unit id="283276e9d183ad9eef7a4c2f27ba79df3995c5ec" translate="yes" xml:space="preserve">
          <source>If your algorithm requires that &lt;code&gt;reduce&lt;/code&gt; produce an identity value, then make sure that you always pass that identity value as the first argument to prevent &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; being returned</source>
          <target state="translated">如果您的算法要求 &lt;code&gt;reduce&lt;/code&gt; 产生一个标识值，请确保始终将该标识值作为第一个参数传递，以防止返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0fc2dbb19ef8bc25dbcf8ac8f222951284588b99" translate="yes" xml:space="preserve">
          <source>If your algorithm requires that &lt;code&gt;reduce&lt;/code&gt; produce an identity value, then make sure that you always pass that identity value as the first argument to prevent &lt;code&gt;undef&lt;/code&gt; being returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711905ae29609d52da565bc6443425ee76c015f8" translate="yes" xml:space="preserve">
          <source>If your application requires accepting data from untrusted sources, you are best off with a less powerful and more-likely safe serialization format and implementation. If your data is sufficiently simple, &lt;a href=&quot;Cpanel::JSON::XS&quot;&gt;Cpanel::JSON::XS&lt;/a&gt;, &lt;a href=&quot;Data::MessagePack&quot;&gt;Data::MessagePack&lt;/a&gt; or &lt;a href=&quot;sereal&quot;&gt;Sereal&lt;/a&gt; are the best choices and offer maximum interoperability, but note that Sereal is &lt;a href=&quot;Sereal::Decoder#ROBUSTNESS&quot;&gt;unsafe by default&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826651d97de1fb76050036181700ee31a9d7cf34" translate="yes" xml:space="preserve">
          <source>If your application requires accepting data from untrusted sources, you are best off with a less powerful and more-likely safe serialization format and implementation. If your data is sufficiently simple, JSON is a good choice and offers maximum interoperability.</source>
          <target state="translated">如果你的应用需要接受来自不受信任的数据,你最好使用功能较弱、更可能安全的序列化格式和实现。如果你的数据足够简单,JSON是一个不错的选择,并提供了最大的互操作性。</target>
        </trans-unit>
        <trans-unit id="6fedf0cadcf133b09c8efb7dc310cff7b7302cdf" translate="yes" xml:space="preserve">
          <source>If your changes are in a single git commit, run the following commands to generate the patch file and attach it to your bug report:</source>
          <target state="translated">如果您的修改是在一次 git 提交中完成的,请运行以下命令来生成补丁文件,并将其附加到您的错误报告中。</target>
        </trans-unit>
        <trans-unit id="db2c1fd426ed9f2c60db2929723c4b3e4c8b99fa" translate="yes" xml:space="preserve">
          <source>If your changes are in multiple commits, generate a patch file for each one and provide them to perlbug's &lt;code&gt;-p&lt;/code&gt; option separated by commas:</source>
          <target state="translated">如果您所做的更改是多次提交，请为每个提交生成一个补丁文件，并将其提供给perlbug的 &lt;code&gt;-p&lt;/code&gt; 选项（以逗号分隔）：</target>
        </trans-unit>
        <trans-unit id="e23115cc45aeaf527b25ea3227a4ca58a4bbcf8b" translate="yes" xml:space="preserve">
          <source>If your class does have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method, we strongly recommend that you override &lt;code&gt;can&lt;/code&gt; in your class as well. Your overridden &lt;code&gt;can&lt;/code&gt; method should return a subroutine reference for any method that your &lt;code&gt;AUTOLOAD&lt;/code&gt; responds to.</source>
          <target state="translated">如果您的类确实具有 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法，则强烈建议您也覆盖类中的 &lt;code&gt;can&lt;/code&gt; 。覆盖的 &lt;code&gt;can&lt;/code&gt; 方法应该为 &lt;code&gt;AUTOLOAD&lt;/code&gt; 响应的任何方法返回子例程引用。</target>
        </trans-unit>
        <trans-unit id="94e34cf5528ccd5dcdb342c8820f7f03af06ab35" translate="yes" xml:space="preserve">
          <source>If your class has a better way of doing roles, then you should not load this class and instead simply say that your class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7692bb0712bd055e295162eb35d771d86fcad6" translate="yes" xml:space="preserve">
          <source>If your class responds to method calls via &lt;code&gt;AUTOLOAD&lt;/code&gt; , you may want to overload &lt;code&gt;can&lt;/code&gt; to return a subroutine reference for methods which your &lt;code&gt;AUTOLOAD&lt;/code&gt; method handles.</source>
          <target state="translated">如果您的类通过 &lt;code&gt;AUTOLOAD&lt;/code&gt; 响应方法调用，则您可能希望重载 &lt;code&gt;can&lt;/code&gt; 返回 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法处理的方法的子例程引用。</target>
        </trans-unit>
        <trans-unit id="d2801f0953803749827f324dc366675780126e87" translate="yes" xml:space="preserve">
          <source>If your class responds to method calls via &lt;code&gt;AUTOLOAD&lt;/code&gt;, you may want to overload &lt;code&gt;can&lt;/code&gt; to return a subroutine reference for methods which your &lt;code&gt;AUTOLOAD&lt;/code&gt; method handles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb0c308f5c747cd8786d190dad063cb23775dff" translate="yes" xml:space="preserve">
          <source>If your code expects an octet sequence this can be used to validate that you've received one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51ef4c74c99126a798f834a23d66ffbb341d516" translate="yes" xml:space="preserve">
          <source>If your code is destined for systems with severely constrained (or missing!) virtual memory systems then you want to be</source>
          <target state="translated">如果你的代码注定要用在虚拟内存系统严重受限(或缺失!)的系统上,那么你要在你的代码中加入</target>
        </trans-unit>
        <trans-unit id="b8ec960b62faa8f2d9e01172beeee1747d962ecd" translate="yes" xml:space="preserve">
          <source>If your code is to run on Perl versions earlier than 5.20, it is worthwhile to note that using &lt;code&gt;$`&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; slows down regexp matching quite a bit, while &lt;code&gt;$&amp;amp;&lt;/code&gt; slows it down to a lesser extent, because if they are used in one regexp in a program, they are generated for</source>
          <target state="translated">如果您的代码要在5.20之前的Perl版本上运行，则值得注意的是，使用 &lt;code&gt;$`&lt;/code&gt; 和 &lt;code&gt;$'&lt;/code&gt; 会大大降低regexp匹配的速度，而 &lt;code&gt;$&amp;amp;&lt;/code&gt; 则会使其速度降低一些，因为如果在一个程序中的一个正则表达式，它们是为</target>
        </trans-unit>
        <trans-unit id="4b7710e8f3ca27397097d7cc62e45c608961218a" translate="yes" xml:space="preserve">
          <source>If your code is to run on various platforms, keep in mind that the upper limit depends on the platform. It is much larger on 64-bit word sizes than 32-bit ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17494161785039e334258f44851b99624e54807" translate="yes" xml:space="preserve">
          <source>If your code is to run on various platforms, keep in mind that the upper limit depends on the platform. It is much larger on 64-bit word sizes than 32-bit ones. For 32-bit integers, &lt;code&gt;IV_MAX&lt;/code&gt; equals &lt;code&gt;0x7FFFFFFF&lt;/code&gt;, for 64-bit integers, &lt;code&gt;IV_MAX&lt;/code&gt; equals &lt;code&gt;0x7FFFFFFFFFFFFFFF&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f35b1b808d1504007b3ea085214451b1ee61358c" translate="yes" xml:space="preserve">
          <source>If your code just uses the 52 letters A-Z and a-z, plus SPACE, the digits 0-9, and the punctuation characters that Perl uses, plus a few controls that are denoted by escape sequences like &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\t&lt;/code&gt; , then there's nothing special about using Perl, and your code may very well work on an ASCII machine without change.</source>
          <target state="translated">如果您的代码只使用52个字母AZ和az，再加上SPACE，数字0-9和Perl使用的标点字符，再加上一些由转义序列（如 &lt;code&gt;\n&lt;/code&gt; 和 &lt;code&gt;\t&lt;/code&gt; 表示的控件，那么没有什么特别的有关使用Perl的信息，您的代码可以很好地在ASCII机器上正常工作而无需更改。</target>
        </trans-unit>
        <trans-unit id="fd44ae53a2c35816d36a21d629151afa4456598c" translate="yes" xml:space="preserve">
          <source>If your code just uses the 52 letters A-Z and a-z, plus SPACE, the digits 0-9, and the punctuation characters that Perl uses, plus a few controls that are denoted by escape sequences like &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\t&lt;/code&gt;, then there's nothing special about using Perl, and your code may very well work on an ASCII machine without change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc20635c4dbc0c4a81b5c97270c1432edba3070f" translate="yes" xml:space="preserve">
          <source>If your code needs to be compatible with versions of perl without &lt;code&gt;use feature 'unicode_strings';&lt;/code&gt;, you can force Unicode semantics on a given string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e9b4a996206aa3ecbfc36df229dca4fb6c7a7b5" translate="yes" xml:space="preserve">
          <source>If your code still needs to run on older versions, stick to &lt;code&gt;foreach&lt;/code&gt; for your topicalizer and you will be less unhappy.</source>
          <target state="translated">如果您的代码仍需要在较旧的版本上运行，请坚持使用 &lt;code&gt;foreach&lt;/code&gt; 作为topicalizer，这样您会感到不满。</target>
        </trans-unit>
        <trans-unit id="dcc0823ff9797cfd85918a8c234e7eca9a51dc4f" translate="yes" xml:space="preserve">
          <source>If your command contains &lt;b&gt;special characters&lt;/b&gt; (&amp;lt; &amp;gt; | &amp;amp;), it will be internally stringified before executing the command, to avoid that these special characters are escaped and passed as arguments instead of retaining their special meaning.</source>
          <target state="translated">如果您的命令包含&lt;b&gt;特殊字符&lt;/b&gt;（&amp;lt;&amp;gt; |＆），则会在执行命令之前对其内部进行字符串化处理，以避免这些特殊字符被转义并作为参数传递而不保留其特殊含义。</target>
        </trans-unit>
        <trans-unit id="43394cfe59583c3fd94893ba6ef409bba1f68bbd" translate="yes" xml:space="preserve">
          <source>If your computer can grow the character set without further processing, you can go ahead and use it. This is called a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf42d5b15f10438a9ce2c86e1004158d46b18003" translate="yes" xml:space="preserve">
          <source>If your copy of Perl is recent enough to contain this documentation (version 5.002 or later), then the perl library (and</source>
          <target state="translated">如果你的Perl版本足够新,包含了这个文档(5.002或更高版本),那么perl库(和</target>
        </trans-unit>
        <trans-unit id="2f8c2d2817394bbcc4a451c1a33b9dff96a282f0" translate="yes" xml:space="preserve">
          <source>If your device is not rooted, you may still be in luck. Try running this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc9b0cc9eec68d672ffff71ad1ff12aed25c2cc" translate="yes" xml:space="preserve">
          <source>If your encoding can work with PerlIO but needs line buffering, you MUST define this method so it returns true. 7bit ISO-2022 encodings are one example that needs this. When this method is missing, false is assumed.</source>
          <target state="translated">如果你的编码可以和PerlIO一起工作,但需要行缓冲,你必须定义这个方法,使它返回true。7bit ISO-2022 编码就是一个需要这个方法的例子。当这个方法缺失时,就会假定为false。</target>
        </trans-unit>
        <trans-unit id="d924438284770c83006ec82d036605b95adc1613" translate="yes" xml:space="preserve">
          <source>If your encoding does not support PerlIO for some reasons, just;</source>
          <target state="translated">如果你的编码因为某些原因不支持PerlIO,只要。</target>
        </trans-unit>
        <trans-unit id="67ac503167790c1d42d0fa145e05ebf3299a6484" translate="yes" xml:space="preserve">
          <source>If your event needs to have extra effects on the &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt; you can override this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb14712099b199ef0cd902ac0e502361e5d3ab8" translate="yes" xml:space="preserve">
          <source>If your executables start with something like #!perl or #!/usr/bin/perl MakeMaker will change this to the path of the perl 'Makefile.PL' was invoked with so the programs will be sure to run properly even if perl is not in /usr/bin/perl.</source>
          <target state="translated">如果你的可执行文件以#!perl或#!/usr/bin/perl这样的开头,MakeMaker会把它改成perl'Makefile.PL'被调用的路径,这样即使perl不在/usr/bin/perl中,程序也能保证正常运行。</target>
        </trans-unit>
        <trans-unit id="0c644837e9e9bd2635823c6fa674e7d01fcd0f60" translate="yes" xml:space="preserve">
          <source>If your extension uses some features of Perl which are not available on older releases of Perl, your users would appreciate an early meaningful warning. You would probably put this information into the</source>
          <target state="translated">如果你的扩展使用了Perl的一些功能,而这些功能在旧版本的Perl上是不可用的,那么你的用户会希望得到一个有意义的早期警告。你可能会把这些信息放在</target>
        </trans-unit>
        <trans-unit id="adbe147193e70e68bb2371038fd445f29bb86c7b" translate="yes" xml:space="preserve">
          <source>If your function already returns a reference, you don't need to create the reference yourself.</source>
          <target state="translated">如果你的函数已经返回一个引用,你不需要自己创建引用。</target>
        </trans-unit>
        <trans-unit id="8e3814e00e4bd2f311a16402f4ba979bbd48ac96" translate="yes" xml:space="preserve">
          <source>If your gcc is configured to use GNU as and ld but you want to use the Solaris ones instead to build perl, then you'll need to add -B/usr/ccs/bin/ to the gcc command line. One convenient way to do that is with</source>
          <target state="translated">如果你的gcc配置为使用GNU as和ld,但你想用Solaris的来编译perl,那么你需要在gcc命令行中添加-B/usr/ccs/bin/。一个方便的方法是用</target>
        </trans-unit>
        <trans-unit id="c36d951537cc72fb144d389f8c16c06615d06bc8" translate="yes" xml:space="preserve">
          <source>If your goal is purely monitoring of events use the &lt;code&gt;Test2::Hub-&amp;gt;listen()&lt;/code&gt; method exported by Test::More to watch events as they are fired. If you wish to modify results before they go to TAP look at the &lt;code&gt;Test2::Hub-&amp;gt;filter()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5872fc905315842d011082a682a6367cfb7ca9e6" translate="yes" xml:space="preserve">
          <source>If your hash could have repeated values, the methods above will only find one of the associated keys. This may or may not worry you. If it does worry you, you can always reverse the hash into a hash of arrays instead:</source>
          <target state="translated">如果你的哈希可能有重复的值,上面的方法只能找到其中一个关联键。这可能让你担心,也可能不担心。如果你确实担心,你可以随时将哈希反转为数组的哈希。</target>
        </trans-unit>
        <trans-unit id="ef30095e54f0686dc32e619850a74327f603829f" translate="yes" xml:space="preserve">
          <source>If your host system's architecture is 32 bits, remember to change the &lt;code&gt;x86_64&lt;/code&gt;'s below to &lt;code&gt;x86&lt;/code&gt;'s. On a similar vein, the examples below use the 4.8 toolchain; if you want to use something older or newer (for example, the 4.4.3 toolchain included in the 8th revision of the NDK), just change those to the relevant version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7de42f17abf69fc8056c809db5d175a47bd9c23" translate="yes" xml:space="preserve">
          <source>If your input is binary, and is supposed to remain binary, you shouldn't decode it to a text string, of course. But in all other cases, you should decode it.</source>
          <target state="translated">如果你的输入是二进制的,并且应该保持二进制,你当然不应该把它解码成一个文本字符串。但在所有其他情况下,你应该对它进行解码。</target>
        </trans-unit>
        <trans-unit id="d2667a072564b25eaaca13a334f7f9d262c4dc4d" translate="yes" xml:space="preserve">
          <source>If your lexicon is a tied hash the simple act of caching the compiled value can be fatal.</source>
          <target state="translated">如果你的词库是一个绑定的哈希,简单的缓存编译值的行为可能是致命的。</target>
        </trans-unit>
        <trans-unit id="84a874bfb13cfbdc7a992429f47c0892596ec6c2" translate="yes" xml:space="preserve">
          <source>If your locale environment variables (&lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_CTYPE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; ) contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching), the default encoding of your &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , and &lt;code&gt;STDERR&lt;/code&gt; , and of &lt;b&gt;any subsequent file open&lt;/b&gt;, is UTF-8.</source>
          <target state="translated">如果您的区域设置环境变量（ &lt;code&gt;LC_ALL&lt;/code&gt; ， &lt;code&gt;LC_CTYPE&lt;/code&gt; ， &lt;code&gt;LANG&lt;/code&gt; ）包含字符串'UTF-8'或'UTF8'（不区分大小写的匹配）， &lt;code&gt;STDIN&lt;/code&gt; ， &lt;code&gt;STDOUT&lt;/code&gt; 和 &lt;code&gt;STDERR&lt;/code&gt; 以及&lt;b&gt;所有后续文件open&lt;/b&gt;的默认编码，是UTF-8。</target>
        </trans-unit>
        <trans-unit id="48763bb2696546d08447fe45d15a3762e501f27c" translate="yes" xml:space="preserve">
          <source>If your locale environment variables (&lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_CTYPE&lt;/code&gt;, &lt;code&gt;LANG&lt;/code&gt;) contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching), the default encoding of your &lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt;, and &lt;code&gt;STDERR&lt;/code&gt;, and of &lt;b&gt;any subsequent file open&lt;/b&gt;, is UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6549b9662c9333f9038a43e101cb863214588ba8" translate="yes" xml:space="preserve">
          <source>If your locale is a UTF-8 locale, starting in Perl v5.20, Perl works well for all categories except &lt;code&gt;LC_COLLATE&lt;/code&gt; dealing with sorting and the &lt;code&gt;cmp&lt;/code&gt; operator.</source>
          <target state="translated">如果您的语言环境是UTF-8语言环境，则从Perl v5.20开始，Perl可以很好地适用于除 &lt;code&gt;LC_COLLATE&lt;/code&gt; 处理排序和 &lt;code&gt;cmp&lt;/code&gt; 运算符之外的所有类别。</target>
        </trans-unit>
        <trans-unit id="7ca7f425bac55c9b318a8c22ef06af377bf476b0" translate="yes" xml:space="preserve">
          <source>If your locale is a UTF-8 locale, starting in Perl v5.26, Perl works well for all categories; before this, starting with Perl v5.20, it works for all categories but &lt;code&gt;LC_COLLATE&lt;/code&gt;, which deals with sorting and the &lt;code&gt;cmp&lt;/code&gt; operator. But note that the standard &lt;code&gt;&lt;a href=&quot;Unicode::Collate&quot;&gt;Unicode::Collate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;Unicode::Collate::Locale&quot;&gt;Unicode::Collate::Locale&lt;/a&gt;&lt;/code&gt; modules offer much more powerful solutions to collation issues, and work on earlier releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b150d3cc1b32cbef03e749b88c3f5c90012ceb" translate="yes" xml:space="preserve">
          <source>If your newly minted styles refer to any new #variables, you'll need to define a callback subroutine that will populate (or modify) those variables. They are then available for use in the style you've chosen.</source>
          <target state="translated">如果你的新样式引用了任何新的#变量,你需要定义一个回调子程序来填充(或修改)这些变量。然后它们就可以在你选择的样式中使用了。</target>
        </trans-unit>
        <trans-unit id="db09b35e2a7d627ad25d25e5e66ae789bbe364b8" translate="yes" xml:space="preserve">
          <source>If your operating system supports a proper mv(1) utility or its functional equivalent, this works:</source>
          <target state="translated">如果你的操作系统支持适当的mv(1)工具或其功能等同物,这就可以了。</target>
        </trans-unit>
        <trans-unit id="3bc865c47f68e828a2747632075834057f8b741e" translate="yes" xml:space="preserve">
          <source>If your parser object has been set to accept other formatting codes, then they will be presented like these B/C/F/I codes -- i.e., without any attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b728e9092f3f9368f8a8be6c5ce7886b0a62de25" translate="yes" xml:space="preserve">
          <source>If your patch changes code (rather than just changing documentation), you should also include one or more test cases which illustrate the bug you're fixing or validate the new functionality you're adding. In general, you should update an existing test file rather than create a new one.</source>
          <target state="translated">如果你的补丁改变了代码 (而不仅仅是改变文档),你还应该包含一个或多个测试用例,以说明你正在修复的错误或验证你正在添加的新功能。一般来说,你应该更新一个现有的测试文件,而不是创建一个新的测试文件。</target>
        </trans-unit>
        <trans-unit id="1c8689164a8ea6c3d7088da54ac1d855f027a272" translate="yes" xml:space="preserve">
          <source>If your perl does not support times larger than &lt;code&gt;2^31&lt;/code&gt; seconds then this module is likely to fail at processing dates beyond the year 2038. There are moves afoot to fix that in perl. Alternatively use 64 bit perl. Or if none of those are options, use the &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; module which has support for years well into the future and past.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a3de11301e669e248cee7c9e70b2562ff6e9f5" translate="yes" xml:space="preserve">
          <source>If your perl does not support times larger than &lt;code&gt;2^31&lt;/code&gt; seconds then this module is likely to fail at processing dates beyond the year 2038. There are moves afoot to fix that in perl. Alternatively use 64 bit perl. Or if none of those are options, use the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module which has support for years well into the future and past.</source>
          <target state="translated">如果您的perl不支持大于 &lt;code&gt;2^31&lt;/code&gt; 秒的时间，则此模块可能在2038年以后的处理日期失败。正在采取一些措施来修复perl中的问题。或者使用64位perl。或者，如果这些都不是选项，请使用&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;模块，该模块具有对未来和过去多年的支持。</target>
        </trans-unit>
        <trans-unit id="b5f6d77f27ea6c645390efe18bf989b76fa95e9b" translate="yes" xml:space="preserve">
          <source>If your perl is compiled with &lt;code&gt;-DDEBUGGING&lt;/code&gt; , you may use the &lt;b&gt;-Dr&lt;/b&gt; flag on the command line.</source>
          <target state="translated">如果您的perl是使用 &lt;code&gt;-DDEBUGGING&lt;/code&gt; 编译的，则可以在命令行上使用&lt;b&gt;-Dr&lt;/b&gt;标志。</target>
        </trans-unit>
        <trans-unit id="4c77f5e67615687160ce5a2c5aa3da747ca2d11d" translate="yes" xml:space="preserve">
          <source>If your perl is compiled with &lt;code&gt;-DDEBUGGING&lt;/code&gt;, you may use the &lt;b&gt;-Dr&lt;/b&gt; flag on the command line, and &lt;code&gt;-Drv&lt;/code&gt; for more verbose information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb3bbcc486c0ac676b28f725bda572e8ce7d210" translate="yes" xml:space="preserve">
          <source>If your perl is using Perl's malloc() and was compiled with the necessary switches (this is the default), then it will print memory usage statistics after compiling your code when &lt;code&gt;$ENV{PERL_DEBUG_MSTATS}
&amp;gt; 1&lt;/code&gt; , and before termination of the program when &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt;= 1&lt;/code&gt; . The report format is similar to the following example:</source>
          <target state="translated">如果您的perl使用Perl的malloc（）并使用必需的开关进行了编译（这是默认设置），则当 &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt; 1&lt;/code&gt; 且在程序终止之前，它将在编译代码后打印内存使用情况统计信息 &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt;= 1&lt;/code&gt; 。报告格式类似于以下示例：</target>
        </trans-unit>
        <trans-unit id="3b5e6d64fef920594f60da6d6dc6a30084b30ce5" translate="yes" xml:space="preserve">
          <source>If your perl is using Perl's malloc() and was compiled with the necessary switches (this is the default), then it will print memory usage statistics after compiling your code when &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt; 1&lt;/code&gt;, and before termination of the program when &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt;= 1&lt;/code&gt;. The report format is similar to the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ec21abacef113106404f37c8ffeaf0991584f3" translate="yes" xml:space="preserve">
          <source>If your perl supports &lt;code&gt;PerlIO&lt;/code&gt; (which is the default), you can use a &lt;code&gt;PerlIO&lt;/code&gt; layer to decode and encode directly via a filehandle. The following two examples are fully identical in functionality:</source>
          <target state="translated">如果您的perl支持 &lt;code&gt;PerlIO&lt;/code&gt; （默认设置），则可以使用 &lt;code&gt;PerlIO&lt;/code&gt; 层直接通过文件句柄进行解码和编码。以下两个示例在功能上完全相同：</target>
        </trans-unit>
        <trans-unit id="605c431eb189340e08603e962b29cd94bebb00d6" translate="yes" xml:space="preserve">
          <source>If your platform does not support disabling this option but you still want to listen for both &lt;code&gt;AF_INET&lt;/code&gt; and &lt;code&gt;AF_INET6&lt;/code&gt; connections you will have to create two listening sockets, one bound to each protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f282d94e305f215eb5d8388f1861231e1f9e48da" translate="yes" xml:space="preserve">
          <source>If your program does not need compatibility for Perl 5.6 and earlier, the recommended approach is to apply appropriate IO disciplines, so all data in your program become unicode-strings. See &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; and &lt;a href=&quot;perlfunc#binmode&quot;&gt;&quot;binmode&quot; in perlfunc&lt;/a&gt; for how.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b23131a86f1ea3c3da4be4496eb45f056a245b0" translate="yes" xml:space="preserve">
          <source>If your program is using the POSIX 2008 multi-thread locale functionality, you should switch into the global locale and set that up properly before starting the Perl interpreter. It will then properly switch back to using the thread-safe functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091f7db96070043c9514e8ee2a91acbe99a23b27" translate="yes" xml:space="preserve">
          <source>If your rc file contains:</source>
          <target state="translated">如果你的rc文件包含:</target>
        </trans-unit>
        <trans-unit id="1cc732c143d69a605c4a486fe1919dbc8511b3b7" translate="yes" xml:space="preserve">
          <source>If your routine iterates through some kind of list (such as a list of files, or records in a database) you may consider providing a callback so that users can manipulate each element of the list in turn. File::Find provides an example of this with its &lt;code&gt;find(\&amp;amp;wanted, $dir)&lt;/code&gt; syntax.</source>
          <target state="translated">如果您的例程遍历某种类型的列表（例如文件列表或数据库中的记录），则可以考虑提供回调，以便用户可以依次操纵列表中的每个元素。File :: Find使用 &lt;code&gt;find(\&amp;amp;wanted, $dir)&lt;/code&gt; 语法提供了一个示例。</target>
        </trans-unit>
        <trans-unit id="fa4660b471bef6e2a6cf6ca593555a146c22ffd2" translate="yes" xml:space="preserve">
          <source>If your script works with huge numbers and Calc is too slow for them, you can also for the loading of one of these libraries and if none of them can be used, the code dies:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d69711a4dff3eb5c2c54e4925f7a2d49b42d0e" translate="yes" xml:space="preserve">
          <source>If your script works with huge numbers and Calc is too slow for them, you can also for the loading of one of these libraries and if none of them can be used, the code will die:</source>
          <target state="translated">如果你的脚本与巨大的数字一起工作,而Calc对它们来说太慢,你也可以为加载这些库中的一个,如果它们都不能被使用,代码就会死掉。</target>
        </trans-unit>
        <trans-unit id="686d70af0d50a3bff3e29e104e2f82c37c794acd" translate="yes" xml:space="preserve">
          <source>If your stdio requires a seek or eof between reads and writes on a particular stream, so does Perl. (This doesn't apply to sysread() and syswrite().)</source>
          <target state="translated">如果你的 stdio 在特定流的读写之间需要一个 seek 或 eof,Perl 也需要。(这不适用于 sysread()和 syswrite()。)</target>
        </trans-unit>
        <trans-unit id="93c7fafa71ca8ecee9c4bc6ffa3da0deecf48bf5" translate="yes" xml:space="preserve">
          <source>If your sub-class does not also derive from &lt;code&gt;IO::Socket::INET&lt;/code&gt; or similar (e.g. &lt;code&gt;IO::Socket::IP&lt;/code&gt;, &lt;code&gt;IO::Socket::INET6&lt;/code&gt; or &lt;code&gt;IO::Socket::SSL&lt;/code&gt;) then you must provide the following methods by other means yourself: &lt;code&gt;close()&lt;/code&gt; and &lt;code&gt;timeout()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ff0a2e68bd649cc4624def7ce4b58902e2e24e" translate="yes" xml:space="preserve">
          <source>If your subsecond sleeping is implemented with &lt;code&gt;nanosleep()&lt;/code&gt; instead of &lt;code&gt;usleep()&lt;/code&gt; , you can mix subsecond sleeping with signals since &lt;code&gt;nanosleep()&lt;/code&gt; does not use signals. This, however, is not portable, and you should first check for the truth value of &lt;code&gt;&amp;amp;Time::HiRes::d_nanosleep&lt;/code&gt; to see whether you have nanosleep, and then carefully read your &lt;code&gt;nanosleep()&lt;/code&gt; C API documentation for any peculiarities.</source>
          <target state="translated">如果使用 &lt;code&gt;nanosleep()&lt;/code&gt; 而不是 &lt;code&gt;usleep()&lt;/code&gt; （）来实现亚秒级睡眠，则可以将亚秒级睡眠与信号混合，因为 &lt;code&gt;nanosleep()&lt;/code&gt; 不使用信号。但是，这不是可移植的，您应该首先检查 &lt;code&gt;&amp;amp;Time::HiRes::d_nanosleep&lt;/code&gt; 的真值，以查看您是否具有nanosleep，然后仔细阅读您的 &lt;code&gt;nanosleep()&lt;/code&gt; C API文档以了解是否有任何特殊之处。</target>
        </trans-unit>
        <trans-unit id="eaecaa38de7e044e0f0abcb184f5c42e588cde80" translate="yes" xml:space="preserve">
          <source>If your subsecond sleeping is implemented with &lt;code&gt;nanosleep()&lt;/code&gt; instead of &lt;code&gt;usleep()&lt;/code&gt;, you can mix subsecond sleeping with signals since &lt;code&gt;nanosleep()&lt;/code&gt; does not use signals. This, however, is not portable, and you should first check for the truth value of &lt;code&gt;&amp;amp;Time::HiRes::d_nanosleep&lt;/code&gt; to see whether you have nanosleep, and then carefully read your &lt;code&gt;nanosleep()&lt;/code&gt; C API documentation for any peculiarities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c582512684ef5d894959bd9f55e416e8035f6a" translate="yes" xml:space="preserve">
          <source>If your system does not support &lt;code&gt;sockatmark&lt;/code&gt;, the &lt;code&gt;use&lt;/code&gt; declaration will fail at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe6bd7053ca68da494e6d40d10fb833af71cceb" translate="yes" xml:space="preserve">
          <source>If your system doesn't support dynamic loading, you still probably ought to use &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;. See &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; and &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; for more information (in brief, just use &lt;b&gt;make perl&lt;/b&gt; instead of a plain &lt;b&gt;make&lt;/b&gt; to rebuild perl with a new static extension).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7033933f15e134ae512f052ac986d8b0ac72a9af" translate="yes" xml:space="preserve">
          <source>If your system doesn't support dynamic loading, you still probably ought to use &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;. See &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; and &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; for more information (in brief, just use &lt;b&gt;make perl&lt;/b&gt; instead of a plain &lt;b&gt;make&lt;/b&gt; to rebuild perl with a new static extension).</source>
          <target state="translated">如果您的系统不支持动态加载，您可能仍应该使用&lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;。有关更多信息，请参见&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;和&lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt;。（总之，只需使用&lt;b&gt;make perl&lt;/b&gt;而不是普通&lt;b&gt;make&lt;/b&gt;即可使用新的静态扩展名重建perl）。</target>
        </trans-unit>
        <trans-unit id="976a5d23704d8a7827f274e64a1b65ab7ed369e5" translate="yes" xml:space="preserve">
          <source>If your system has a strange pointer size--meaning a pointer is neither as big as an int nor as big as a long--it may not be possible to pack or unpack pointers in big- or little-endian byte order. Attempting to do so raises an exception.</source>
          <target state="translated">如果你的系统有一个奇怪的指针大小--意味着一个指针既没有int那么大,也没有long那么大--可能无法按照大字节或小字节的顺序打包或解包指针。试图这样做会引发一个异常。</target>
        </trans-unit>
        <trans-unit id="c8f634435d2540d4ac325a2965a4ae17a54489a6" translate="yes" xml:space="preserve">
          <source>If your system has the &lt;code&gt;sigaction()&lt;/code&gt; function then signal handlers are installed using it. This means you get reliable signal handling.</source>
          <target state="translated">如果您的系统具有 &lt;code&gt;sigaction()&lt;/code&gt; 函数，则使用该函数安装信号处理程序。这意味着您可以获得可靠的信号处理。</target>
        </trans-unit>
        <trans-unit id="fd4695d7aa352602cd4c4febe7f1355134b6280c" translate="yes" xml:space="preserve">
          <source>If your system lacks &lt;code&gt;gettimeofday()&lt;/code&gt; or an emulation of it you don't get &lt;code&gt;gettimeofday()&lt;/code&gt; or the one-argument form of &lt;code&gt;tv_interval()&lt;/code&gt; . If your system lacks all of &lt;code&gt;nanosleep()&lt;/code&gt; , &lt;code&gt;usleep()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;poll&lt;/code&gt; , you don't get &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt; , or &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; . If your system lacks both &lt;code&gt;ualarm()&lt;/code&gt; and &lt;code&gt;setitimer()&lt;/code&gt; you don't get &lt;code&gt;Time::HiRes::ualarm()&lt;/code&gt; or &lt;code&gt;Time::HiRes::alarm()&lt;/code&gt; .</source>
          <target state="translated">如果您的系统缺少 &lt;code&gt;gettimeofday()&lt;/code&gt; 或其仿真，则不会获得 &lt;code&gt;gettimeofday()&lt;/code&gt; 或 &lt;code&gt;tv_interval()&lt;/code&gt; 的单参数形式。如果您的系统缺少所有 &lt;code&gt;nanosleep()&lt;/code&gt; ， &lt;code&gt;usleep()&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;poll&lt;/code&gt; ，则不会得到 &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; ， &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt; 或 &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; 。如果您的系统同时缺少 &lt;code&gt;ualarm()&lt;/code&gt; 和 &lt;code&gt;setitimer()&lt;/code&gt; ，则不会获得 &lt;code&gt;Time::HiRes::ualarm()&lt;/code&gt; 或 &lt;code&gt;Time::HiRes::alarm()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff14b6674e60e3293827358011cc8a222c542ec1" translate="yes" xml:space="preserve">
          <source>If your system lacks &lt;code&gt;gettimeofday()&lt;/code&gt; or an emulation of it you don't get &lt;code&gt;gettimeofday()&lt;/code&gt; or the one-argument form of &lt;code&gt;tv_interval()&lt;/code&gt;. If your system lacks all of &lt;code&gt;nanosleep()&lt;/code&gt;, &lt;code&gt;usleep()&lt;/code&gt;, &lt;code&gt;select()&lt;/code&gt;, and &lt;code&gt;poll&lt;/code&gt;, you don't get &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt;, &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt;, or &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt;. If your system lacks both &lt;code&gt;ualarm()&lt;/code&gt; and &lt;code&gt;setitimer()&lt;/code&gt; you don't get &lt;code&gt;Time::HiRes::ualarm()&lt;/code&gt; or &lt;code&gt;Time::HiRes::alarm()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3404e2a55faf84740517a5a0e24d39c3bdace4c" translate="yes" xml:space="preserve">
          <source>If your system supports dynamic loading, for reasons of portability and sanity you probably ought to use &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; (also part of the standard perl distribution). This tool converts C header files to Perl extensions. See &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; for how to get started with &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;.</source>
          <target state="translated">如果您的系统支持动态加载，则出于便携性和完整性的考虑，您可能应该使用&lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;（也是标准perl发行版的一部分）。此工具将C头文件转换为Perl扩展名。有关如何开始使用&lt;a href=&quot;h2xs&quot;&gt;h2xs的信息，&lt;/a&gt;请参见&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c32ad1b9a818a02634ef64d7fbd9495e5b9eebf0" translate="yes" xml:space="preserve">
          <source>If your system supports the portable operating system programming interface (POSIX), you can use the following code, which you'll note turns off echo processing as well.</source>
          <target state="translated">如果你的系统支持可移植操作系统编程接口(POSIX),你可以使用下面的代码,你会注意到它也会关闭回声处理。</target>
        </trans-unit>
        <trans-unit id="8aa741c7264a81c87bbbe88de85bd0da9b62830f" translate="yes" xml:space="preserve">
          <source>If your version control system supports revision numbers (git doesn't easily), the simplest way to do it automatically is to use its revision number (you are using version control, right?).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf51a5f9f685e20ec9fa41065bc4bbf9f512757f" translate="yes" xml:space="preserve">
          <source>If z is a pure real number (i.e. &lt;code&gt;b == 0&lt;/code&gt; ), then the above yields:</source>
          <target state="translated">如果z是纯实数（即 &lt;code&gt;b == 0&lt;/code&gt; ），则上面的结果为：</target>
        </trans-unit>
        <trans-unit id="4b680ec7961a3ae6c6b5a4223fc07bd86a65a488" translate="yes" xml:space="preserve">
          <source>If z is a pure real number (i.e. &lt;code&gt;b == 0&lt;/code&gt;), then the above yields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866f3e73958b23adbe3e41bd3c02c8704cd81475" translate="yes" xml:space="preserve">
          <source>If, and only if, a token is a bailout token, you can get an &quot;explanation&quot; via this method. The explanation is the text after the mystical &quot;Bail out!&quot; words which appear in the tap output.</source>
          <target state="translated">如果,也只有当一个令牌是保送令牌时,你才可以通过这个方法获得 &quot;解释&quot;。解释就是在点选输出中出现的神秘的 &quot;Bail out!&quot;字样后的文字。</target>
        </trans-unit>
        <trans-unit id="4f07d749cb3d9f280003a3874694f44dd0f9a196" translate="yes" xml:space="preserve">
          <source>If, at the end of a run you get the message</source>
          <target state="translated">如果在运行结束时,你得到的信息是</target>
        </trans-unit>
        <trans-unit id="748ad1a2344142dff26b49b0321a5e20db97e62e" translate="yes" xml:space="preserve">
          <source>If, for a given file, Perl is unable to create the backup file as specified in the extension then it will skip that file and continue on with the next one (if it exists).</source>
          <target state="translated">如果对于某个文件,Perl 无法创建扩展名中指定的备份文件,那么它将跳过该文件,继续下一个文件(如果存在的话)。</target>
        </trans-unit>
        <trans-unit id="3190be8312e8fef021a8d99a686331f02896c645" translate="yes" xml:space="preserve">
          <source>If, for some odd reason, you really want to see the whole file at once rather than processing line-by-line, you can slurp it in (as long as you can fit the whole thing in memory!):</source>
          <target state="translated">如果出于某些奇怪的原因,你真的想一次性看到整个文件,而不是逐行处理,你可以把它啧啧地放进去(只要你能把整个文件放进内存!)。</target>
        </trans-unit>
        <trans-unit id="8294d55294098cd1496efb3523c86ff173cf45ca" translate="yes" xml:space="preserve">
          <source>If, for some reason, you have a file descriptor instead of a filehandle (perhaps you used &lt;code&gt;POSIX::open&lt;/code&gt; ), you can use the &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; function from the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module:</source>
          <target state="translated">如果由于某种原因，您有一个文件描述符而不是一个文件句柄（也许您使用了 &lt;code&gt;POSIX::open&lt;/code&gt; ），则可以使用&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块中的 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="47aebbdcad1bcff07c1f3a89cb274cc12375e577" translate="yes" xml:space="preserve">
          <source>If, for some reason, you have a file descriptor instead of a filehandle (perhaps you used &lt;code&gt;POSIX::open&lt;/code&gt;), you can use the &lt;code&gt;close()&lt;/code&gt; function from the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7db8cc8d76b7ab2eda9890eb0170658ba11e9d0" translate="yes" xml:space="preserve">
          <source>If, surprisingly, the implementor of a Pod formatter can't find a satisfactory pre-existing table mapping from Unicode characters to escapes in the target format (e.g., a decent table of Unicode characters to *roff escapes), it will be necessary to build such a table. If you are in this circumstance, you should begin with the characters in the range 0x00A0 - 0x00FF, which is mostly the heavily used accented characters. Then proceed (as patience permits and fastidiousness compels) through the characters that the (X)HTML standards groups judged important enough to merit mnemonics for. These are declared in the (X)HTML specifications at the www.W3.org site. At time of writing (September 2001), the most recent entity declaration files are:</source>
          <target state="translated">如果出人意料的是,Pod格式器的实现者找不到一个令人满意的从Unicode字符到目标格式中转义符的预先存在的表(例如,一个像样的Unicode字符到*roff转义符的表),那么就需要建立这样一个表。如果你在这种情况下,你应该从0x00A0-0x00FF范围内的字符开始,这主要是大量使用的重音字符。然后(在耐心和细心的驱使下)继续(在耐心和细心的驱使下)寻找(X)HTML标准组认为足够重要的字符,以便为这些字符提供记忆符号。这些字符在 www.W3.org 网站上的 (X)HTML 规范中有所声明。在撰写本文时(2001年9月),最新的实体声明文件是:</target>
        </trans-unit>
        <trans-unit id="3906f56da4298c4e536de3ebef7105b8dabd75e9" translate="yes" xml:space="preserve">
          <source>Ignore &lt;code&gt;dSP&lt;/code&gt; and &lt;code&gt;PUSHMARK(SP)&lt;/code&gt; for now. They will be discussed in the next example.</source>
          <target state="translated">现在 &lt;code&gt;PUSHMARK(SP)&lt;/code&gt; 忽略 &lt;code&gt;dSP&lt;/code&gt; 和PUSHMARK（SP）。在下一个示例中将讨论它们。</target>
        </trans-unit>
        <trans-unit id="51be86b7131a2f6dd784631a551ad5a124bca532" translate="yes" xml:space="preserve">
          <source>Ignore ASCII vs. EBCDIC sort differences.</source>
          <target state="translated">忽略ASCII与EBCDIC的排序差异。</target>
        </trans-unit>
        <trans-unit id="be1854061543f14642d8f6508b59d601baedc0d4" translate="yes" xml:space="preserve">
          <source>Ignore case.</source>
          <target state="translated">忽略案例。</target>
        </trans-unit>
        <trans-unit id="2e352eadd6b1808d1d1be87c9129c2b0edb3ffba" translate="yes" xml:space="preserve">
          <source>Ignore the message about missing &lt;code&gt;ln&lt;/code&gt; , and about &lt;code&gt;-c&lt;/code&gt; option to tr</source>
          <target state="translated">忽略有关缺少 &lt;code&gt;ln&lt;/code&gt; 和tr的 &lt;code&gt;-c&lt;/code&gt; 选项的消息</target>
        </trans-unit>
        <trans-unit id="72b96e98da641687751a87c43bd0316c4d008be2" translate="yes" xml:space="preserve">
          <source>Ignore the message about missing &lt;code&gt;ln&lt;/code&gt;, and about &lt;code&gt;-c&lt;/code&gt; option to tr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28a9d1669608fdb03cba836ec390fdcfb1aebfee" translate="yes" xml:space="preserve">
          <source>Ignore the warning.</source>
          <target state="translated">忽略这个警告。</target>
        </trans-unit>
        <trans-unit id="2789be88625c10d2c36088f497ee1c896ef071b5" translate="yes" xml:space="preserve">
          <source>Ignore them: in IRIX 5.3 there is no way to quieten ld about this.</source>
          <target state="translated">忽略他们:在IRIX 5.3中,没有办法让ld安静下来。</target>
        </trans-unit>
        <trans-unit id="a8788733d30e5e6ffc336904ff3697b5a05072af" translate="yes" xml:space="preserve">
          <source>Ignored if perl is run setuid or setgid. Used only for some limited startup randomization (hash keys) if &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-t&lt;/code&gt; perl is started with tainting enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b4603ab54eaf129f7b585f0908e9724e9831b25" translate="yes" xml:space="preserve">
          <source>Ignores any arguments and returns a new &lt;code&gt;TAP::Parser::Scheduler::Spinner&lt;/code&gt; object.</source>
          <target state="translated">忽略任何参数，并返回一个新的 &lt;code&gt;TAP::Parser::Scheduler::Spinner&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="870e1aa14cd979f7f1df9488b978998300179625" translate="yes" xml:space="preserve">
          <source>Ignoring A Thread</source>
          <target state="translated">忽略一个主题</target>
        </trans-unit>
        <trans-unit id="c345599472f697123763177ed798b710a78992e1" translate="yes" xml:space="preserve">
          <source>Ignoring zero length \N{} in character class in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e1853ac655507e727a7ecfa474945c84b582ca" translate="yes" xml:space="preserve">
          <source>Ill-formed CRTL environ value &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a98f3b9adc99d6eca5487e3635466c7897d1e208" translate="yes" xml:space="preserve">
          <source>Ill-formed message in prime_env_iter: |%s|</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8d69f56b24624da5f02c3105fccc4af1aafcfd" translate="yes" xml:space="preserve">
          <source>Illegal %s digit '%c' ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e60a32732ccee2f9f27142f8031ba26b8d7dc3" translate="yes" xml:space="preserve">
          <source>Illegal binary digit '%c'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0069ddda69becb8f7b322dfab0d91887d6b38cf" translate="yes" xml:space="preserve">
          <source>Illegal character \%o (carriage return)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a9e7d5d6c79cbead9e7a219edc1cf3115b4e4c" translate="yes" xml:space="preserve">
          <source>Illegal character after '_' in prototype for %s : %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac523c566b2bdb256c5d3bdfff364808f4e23fbd" translate="yes" xml:space="preserve">
          <source>Illegal character following sigil in a subroutine signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9714b34609d4e303cabdd33bab8c4221880bccec" translate="yes" xml:space="preserve">
          <source>Illegal character in prototype for %s : %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="403f39532270d448d0836526af86ee2840377440" translate="yes" xml:space="preserve">
          <source>Illegal declaration of anonymous subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8441ad3dcf356cbc9055eaec17cb99c6b40b3f60" translate="yes" xml:space="preserve">
          <source>Illegal declaration of subroutine %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b402a1aef9fad4e86bc75fa0d98c8b6064013045" translate="yes" xml:space="preserve">
          <source>Illegal division by zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc34fa84665015bf956a8d0f9e7eab7f7b556cb7" translate="yes" xml:space="preserve">
          <source>Illegal modulus zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44efc0fd61ea8302183ad4e06ae2e1a20b915b53" translate="yes" xml:space="preserve">
          <source>Illegal number of bits in vec</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def84612dec0b9b85613fc3abd33e76ff6143abb" translate="yes" xml:space="preserve">
          <source>Illegal octal digit '%c'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3dffed7bacaff2750f20d75c00b10e5dda311cc" translate="yes" xml:space="preserve">
          <source>Illegal operator following parameter in a subroutine signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c16a63da830be887556e1c445a15cd94836e397c" translate="yes" xml:space="preserve">
          <source>Illegal pattern in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91183d6c24353dd4efc4edca2cf3d736c588f3ed" translate="yes" xml:space="preserve">
          <source>Illegal suidscript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61cca4d5acdb186d61af82a2d57012a7e14f42a" translate="yes" xml:space="preserve">
          <source>Illegal switch in PERL5OPT: -%c</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="579239231de5fef3bb30ece4ec0c3be4f3f8e3dc" translate="yes" xml:space="preserve">
          <source>Illegal user-defined property name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee7b0829696083ec110a0ef1b14678e7a72b39d" translate="yes" xml:space="preserve">
          <source>Illegal.</source>
          <target state="translated">Illegal.</target>
        </trans-unit>
        <trans-unit id="31b9d2eef058fc852ec75440518312fc6b32dcd0" translate="yes" xml:space="preserve">
          <source>Illinois</source>
          <target state="translated">Illinois</target>
        </trans-unit>
        <trans-unit id="817c7ffeee7200e3277cebf23a0b3dcda06d9829" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &amp;lt;</source>
          <target state="translated">伊利亚&amp;middot;扎克哈列维奇&amp;lt;</target>
        </trans-unit>
        <trans-unit id="91b2e058cf65f0cabffee0e92051934b87d3bc3b" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich (ilya@math.ohio-state.edu)</source>
          <target state="translated">Ilya Zakharevich (ilya@math.ohio-state.edu)</target>
        </trans-unit>
        <trans-unit id="031c817d16973027b8790762eb4b0c35cafca1e9" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &lt;a href=&quot;mailto:ilyaz@cpan.org&quot;&gt;mailto:ilyaz@cpan.org&lt;/a&gt;.</source>
          <target state="translated">Ilya Zakharevich &lt;a href=&quot;mailto:ilyaz@cpan.org&quot;&gt;mailto：ilyaz@cpan.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="afff5ba88102f80e4aa07d73498f8952aca29188" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &lt;a href=&quot;mailto:perl-module-hash-memoize@ilyaz.org&quot;&gt;mailto:perl-module-hash-memoize@ilyaz.org&lt;/a&gt;.</source>
          <target state="translated">Ilya Zakharevich &lt;a href=&quot;mailto:perl-module-hash-memoize@ilyaz.org&quot;&gt;mailto：perl-module-hash-memoize@ilyaz.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4248a84d563fa7da7c5bae89f2669c77f908cab3" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt;</source>
          <target state="translated">伊利亚&amp;middot; &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; Ilya Zakharevich）ilya@math.ohio-state.edu</target>
        </trans-unit>
        <trans-unit id="33d5a3e7b454b4e36eb89767df3980ae73e9890b" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich ilya@math.ohio-state.edu</source>
          <target state="translated">Ilya Zakharevich ilya@math.ohio-state.edu</target>
        </trans-unit>
        <trans-unit id="0182df78996d3eb0a76431c398a0f49f0059b1f4" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich originally extracted &lt;code&gt;XSLoader&lt;/code&gt; from &lt;code&gt;DynaLoader&lt;/code&gt; .</source>
          <target state="translated">伊利亚Zakharevich最初提取 &lt;code&gt;XSLoader&lt;/code&gt; 从 &lt;code&gt;DynaLoader&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="317e8b465d1e45c2334fa7d0b49224fc7b0d2b79" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich originally extracted &lt;code&gt;XSLoader&lt;/code&gt; from &lt;code&gt;DynaLoader&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b5ae6dbba6c0391c239461a326224f80e808d8a" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich, cpan@ilyaz.org</source>
          <target state="translated">Ilya Zakharevich,cpan@ilyaz.org。</target>
        </trans-unit>
        <trans-unit id="f84c916319b1f129948f110816b58ce5079819de" translate="yes" xml:space="preserve">
          <source>Images, Pixmap and Bitmap Manipulation, Drawing, and Graphing</source>
          <target state="translated">图像、Pixmap和位图操作、绘图和制图。</target>
        </trans-unit>
        <trans-unit id="6a42b9040934c9280685a56f5dc127e9e6ee5b8d" translate="yes" xml:space="preserve">
          <source>Imagine that the here-doc end marker is at the beginning of the line. Now you can use &lt;code&gt;\p{InKana}&lt;/code&gt; and &lt;code&gt;\P{InKana}&lt;/code&gt; .</source>
          <target state="translated">想象一下，here-doc结束标记在该行的开头。现在，您可以使用 &lt;code&gt;\p{InKana}&lt;/code&gt; 和 &lt;code&gt;\P{InKana}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b72c2258352d34a102a5998755a0b68fcb5627e1" translate="yes" xml:space="preserve">
          <source>Imagine that the here-doc end marker is at the beginning of the line. Now you can use &lt;code&gt;\p{InKana}&lt;/code&gt; and &lt;code&gt;\P{InKana}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8481d644af6cfb14cd0962521a958539b26e54" translate="yes" xml:space="preserve">
          <source>Imagine that your task for the day is to localize a piece of software -- and luckily for you, the only output the program emits is two messages, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fae6fb5571f38013c7696bd62a49c387d5a5d68" translate="yes" xml:space="preserve">
          <source>Immediate Filters</source>
          <target state="translated">即时过滤器</target>
        </trans-unit>
        <trans-unit id="8a696df97fa48af3310dcba0d55250b2371b7422" translate="yes" xml:space="preserve">
          <source>Immediate filters are useful for one-off situations. For more generic problems it can be useful to package the filter up in its own module.</source>
          <target state="translated">即时过滤器对一次性的情况很有用。对于更普遍的问题,可以将过滤器打包在自己的模块中。</target>
        </trans-unit>
        <trans-unit id="42b04d9e2ede4faefd5e97013f894508883e5ac4" translate="yes" xml:space="preserve">
          <source>Immediately after the check routine is called the returned node is checked for being compile-time executable. If it is (the value is judged to be constant) it is immediately executed, and a</source>
          <target state="translated">在检查例程被调用后,立即检查返回的节点是否是编译时可执行的。如果它是(值被判断为常数),它就会被立即执行,并且一个</target>
        </trans-unit>
        <trans-unit id="5d2ecc7281cc6015d762f885a1871742572e70d2" translate="yes" xml:space="preserve">
          <source>Immediately after the filter has been applied to the source, Filter::Simple will pass control to Exporter, so it can do its magic too.</source>
          <target state="translated">当过滤器被应用到源中后,Filter::Simple会立即将控制权传递给Exporter,这样它也可以发挥它的魔力。</target>
        </trans-unit>
        <trans-unit id="a1efac3e1e3b83ccf445505de1c905ec4e317003" translate="yes" xml:space="preserve">
          <source>Implement $PREFER_BIN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10353737d8f43f937641dff0028a206109a7686a" translate="yes" xml:space="preserve">
          <source>Implementation can adjust its idea of number of bytes in the buffer. Do not use this - use PerlIO_fast_gets.</source>
          <target state="translated">实现可以调整它对缓冲区中字节数的想法。不要使用这个--使用PerlIO_fast_gets。</target>
        </trans-unit>
        <trans-unit id="2c98a52672a4f466f688e44c536060b9826553e9" translate="yes" xml:space="preserve">
          <source>Implementation can return pointer to current position in the &quot;buffer&quot; and a count of bytes available in the buffer. Do not use this - use PerlIO_fast_gets.</source>
          <target state="translated">实现时可以返回指向 &quot;缓冲区 &quot;中当前位置的指针和缓冲区中可用字节数。不要使用这个--使用PerlIO_fast_gets。</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">实施细节</target>
        </trans-unit>
        <trans-unit id="6b3873cf8e5251aa728a3e54318ec3a5f273e5f0" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;sv_copypv&lt;/code&gt; and &lt;code&gt;sv_copypv_nomg&lt;/code&gt;. Calls get magic iff flags has the &lt;code&gt;SV_GMAGIC&lt;/code&gt; bit set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867f93d010e1413848b9511b5f08d11efe452a94" translate="yes" xml:space="preserve">
          <source>Implementation of sv_copypv and sv_copypv_nomg. Calls get magic iff flags include SV_GMAGIC.</source>
          <target state="translated">sv_copypv和sv_copypv_nomg的实现。调用得到的魔力 iff标志包括SV_GMAGIC。</target>
        </trans-unit>
        <trans-unit id="93a44ec01f30940976c8468009fd696e0d07c0cd" translate="yes" xml:space="preserve">
          <source>Implementations of mktemp(), tmpnam(), and tempnam() are provided, but should be used with caution since they return only a filename that was valid when function was called, so cannot guarantee that the file will not exist by the time the caller opens the filename.</source>
          <target state="translated">提供了mktemp()、tmpnam()和tempnam()的实现,但应谨慎使用,因为它们只返回一个在函数被调用时有效的文件名,所以不能保证在调用者打开文件名时文件已经不存在。</target>
        </trans-unit>
        <trans-unit id="472357ef916af9461389e46cdf6fcf7419adc52b" translate="yes" xml:space="preserve">
          <source>Implementations should detect the error as soon as it occurs in any of the other functions and save the corresponding message for later retrieval. This will avoid problems on some platforms (such as SunOS) where the error message is very temporary (e.g., dlerror()).</source>
          <target state="translated">实现应该在任何其他函数发生错误时立即检测到错误,并保存相应的信息以便以后检索。这将避免在某些平台(如SunOS)上出现问题,因为在这些平台上,错误信息是非常临时的(例如,dlerror())。</target>
        </trans-unit>
        <trans-unit id="40dac3861d28b66aac73bee4c06a53c216044f0c" translate="yes" xml:space="preserve">
          <source>Implemented as a post-test hook, this plugin writes a specfile after every successful test run. The content is also written to the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7772f795eb98ffae1df16f5f22b8f9f0482251d7" translate="yes" xml:space="preserve">
          <source>Implemented on 64 bit VMS 8.3. VMS requires the symbolic link to be in Unix syntax if it is intended to resolve to a valid path.</source>
          <target state="translated">在64位VMS 8.3上实现。VMS要求符号链接必须使用Unix语法,如果它是为了解析到一个有效的路径。</target>
        </trans-unit>
        <trans-unit id="5c327b5ffaa641fc9ab42ad686d92c062f812101" translate="yes" xml:space="preserve">
          <source>Implementing PerlIO Layers</source>
          <target state="translated">实现PerlIO层</target>
        </trans-unit>
        <trans-unit id="d1d235ff6e6c8fe294165e40ee8fb7af96b238c6" translate="yes" xml:space="preserve">
          <source>Implements a customized option parser used for &lt;a href=&quot;../perldoc&quot;&gt;Pod::Perldoc&lt;/a&gt;.</source>
          <target state="translated">实现用于&lt;a href=&quot;../perldoc&quot;&gt;Pod :: Perldoc&lt;/a&gt;的自定义选项解析器。</target>
        </trans-unit>
        <trans-unit id="4749a3581afc8d4807ca8e3900d478b2535dbbee" translate="yes" xml:space="preserve">
          <source>Implements a customized option parser used for &lt;a href=&quot;Pod::Perldoc&quot;&gt;Pod::Perldoc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b6d8e1ab41db2682597810f350ac0e642396e48" translate="yes" xml:space="preserve">
          <source>Implements default import method for modules</source>
          <target state="translated">执行模块的默认导入方法</target>
        </trans-unit>
        <trans-unit id="10190ba45fe863f85939478d9d5bb36cd51cea87" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; function. You'll probably have to say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f78f1509e14fc5b2d56dfd77b72b8f3900e010b5" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;http://man.he.net/man2/ioctl&quot;&gt;ioctl(2)&lt;/a&gt; function. You'll probably first have to say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="600b4d0a91fb59ceef4048c760197d5c6d1f4db1" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">实现 &lt;code&gt;prove&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="500351adb27caa795501b65867b0b58aab9da04f" translate="yes" xml:space="preserve">
          <source>Implements the fcntl(2) function. You'll probably have to say</source>
          <target state="translated">实现fcntl(2)函数。你可能不得不说</target>
        </trans-unit>
        <trans-unit id="345a4b053fd3ba6ba91b9b4a311d01970f38b745" translate="yes" xml:space="preserve">
          <source>Implements the ioctl(2) function. You'll probably first have to say</source>
          <target state="translated">实现ioctl(2)函数。你可能会先说</target>
        </trans-unit>
        <trans-unit id="df5a374f83ddf1099a63647567a472d00b3049d5" translate="yes" xml:space="preserve">
          <source>Implicit array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a755dd53c48e0431df0fb3c83a53268941625f80" translate="yes" xml:space="preserve">
          <source>Implicit context</source>
          <target state="translated">隐含的背景</target>
        </trans-unit>
        <trans-unit id="1590ca248f9ea87b12d0a25ed72d75a33b540b98" translate="yes" xml:space="preserve">
          <source>Implicit upgrading for byte-strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690e1538d5a86cb3fc7e71c1d7249c0d6e3e0181" translate="yes" xml:space="preserve">
          <source>Import all symbolic constants. Same as doing this</source>
          <target state="translated">导入所有符号常量。和这样做一样</target>
        </trans-unit>
        <trans-unit id="5941fc0651c5b1f4209500ab16a699a919ff2f79" translate="yes" xml:space="preserve">
          <source>Important Caveat</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f641b0147eed755158e9f661a30e441db68a2b9a" translate="yes" xml:space="preserve">
          <source>Important Caveats</source>
          <target state="translated">重要注意事项</target>
        </trans-unit>
        <trans-unit id="49b3bb070775e7c46535f7d9ea2b7446b904f0e4" translate="yes" xml:space="preserve">
          <source>Important platform-specific changes</source>
          <target state="translated">平台特有的重要变化</target>
        </trans-unit>
        <trans-unit id="cea7c754b6d173704074c0b8cc88cfc7c1f173d8" translate="yes" xml:space="preserve">
          <source>Imported with the &lt;code&gt;:sys_resource_h&lt;/code&gt; tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ab5ed3bb3e27748d586ad9b9b11e2ab9efaaf8" translate="yes" xml:space="preserve">
          <source>Importing</source>
          <target state="translated">Importing</target>
        </trans-unit>
        <trans-unit id="a56aac727c58f5874136fceda15607b87290a37d" translate="yes" xml:space="preserve">
          <source>Importing a particular constant may not be very portable, because the import will fail on platforms that do not have that constant. A more portable way to set &lt;code&gt;$!&lt;/code&gt; to a valid value is to use:</source>
          <target state="translated">导入特定常数可能不是很容易移植，因为在没有该常数的平台上导入会失败。设置 &lt;code&gt;$!&lt;/code&gt; 更便捷的方式！有效值是使用：</target>
        </trans-unit>
        <trans-unit id="e0f171764942008e4afa9ec8365fe319dc1a1bf4" translate="yes" xml:space="preserve">
          <source>Importing autodie into another namespace than &quot;caller&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4eab83913c9890e5e3e1ea6b76a702ac39df78f" translate="yes" xml:space="preserve">
          <source>Importing this module causes the subroutine color in Test::Builder::Tester to be called with a true value causing colour highlighting to be turned on in debug output.</source>
          <target state="translated">导入该模块后,Test::Builder::Tester中的子程序color会被调用,并带有真值,导致在调试输出中开启颜色高亮。</target>
        </trans-unit>
        <trans-unit id="b94be8f7a2bde6a23ee55b54ee8fc9eb76bd786e" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;anyinflate&lt;/code&gt; and &lt;code&gt;$AnyInflateError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;anyinflate&lt;/code&gt; 和 &lt;code&gt;$AnyInflateError&lt;/code&gt; 。与此相同</target>
        </trans-unit>
        <trans-unit id="ac0d700aba31089d6a5c86842474af1ccd35ee48" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;anyinflate&lt;/code&gt; and &lt;code&gt;$AnyInflateError&lt;/code&gt;. Same as doing this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47d4827ba5d67c837818053a8d62f3b22e590b8" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;anyuncompress&lt;/code&gt; and &lt;code&gt;$AnyUncompressError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;anyuncompress&lt;/code&gt; 和 &lt;code&gt;$AnyUncompressError&lt;/code&gt; 。与此相同</target>
        </trans-unit>
        <trans-unit id="c5f3df7452ee0e7ac2933d668a54ce6d80e2d969" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;anyuncompress&lt;/code&gt; and &lt;code&gt;$AnyUncompressError&lt;/code&gt;. Same as doing this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b77142aa14b6211216f5a16e3e213d0c392505" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;bunzip2&lt;/code&gt; and &lt;code&gt;$Bunzip2Error&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;bunzip2&lt;/code&gt; 和 &lt;code&gt;$Bunzip2Error&lt;/code&gt; 。与此相同</target>
        </trans-unit>
        <trans-unit id="ed5276b55d1c3e705615754b5592030b3f86448a" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;bunzip2&lt;/code&gt; and &lt;code&gt;$Bunzip2Error&lt;/code&gt;. Same as doing this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="611c05e07552b8091c699fb7c8b34e627de5035f" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;bzip2&lt;/code&gt; and &lt;code&gt;$Bzip2Error&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;bzip2&lt;/code&gt; 和 &lt;code&gt;$Bzip2Error&lt;/code&gt; 。与此相同</target>
        </trans-unit>
        <trans-unit id="f33038725fdf461a70610da87643ccfeafbb78d0" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;bzip2&lt;/code&gt; and &lt;code&gt;$Bzip2Error&lt;/code&gt;. Same as doing this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f1d5114934adc139dbbd5be66e7aa4d256c7031" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;deflate&lt;/code&gt; , &lt;code&gt;$DeflateError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;deflate&lt;/code&gt; ， &lt;code&gt;$DeflateError&lt;/code&gt; 和 &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 可以使用的所有符号常量。与此相同</target>
        </trans-unit>
        <trans-unit id="0d4974d2c5596367cb5cebb1930f3c2825ac5e43" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;deflate&lt;/code&gt;, &lt;code&gt;$DeflateError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Deflate&lt;/code&gt;. Same as doing this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b3cbf51bdd7f4f367077b86b68d9bc7e23e42e" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;gunzip&lt;/code&gt; and &lt;code&gt;$GunzipError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;gunzip&lt;/code&gt; 和 &lt;code&gt;$GunzipError&lt;/code&gt; 。与此相同</target>
        </trans-unit>
        <trans-unit id="a1c53346bb70d2ef53cbff855bff6bf49a03d218" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;gunzip&lt;/code&gt; and &lt;code&gt;$GunzipError&lt;/code&gt;. Same as doing this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34135d0717f9ce2e7a0257450b1f62fae7932dc" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;gzip&lt;/code&gt; , &lt;code&gt;$GzipError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;gzip&lt;/code&gt; ， &lt;code&gt;$GzipError&lt;/code&gt; 和 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 可以使用的所有符号常量。与此相同</target>
        </trans-unit>
        <trans-unit id="61371e25038e3f4ac705613da33881c8f7d476ca" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;gzip&lt;/code&gt;, &lt;code&gt;$GzipError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Gzip&lt;/code&gt;. Same as doing this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115a4b04735017c59cebd861430122e98ed196f8" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;inflate&lt;/code&gt; and &lt;code&gt;$InflateError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">进口 &lt;code&gt;inflate&lt;/code&gt; 和 &lt;code&gt;$InflateError&lt;/code&gt; 。与此相同</target>
        </trans-unit>
        <trans-unit id="4b984a68fd009c415920f89995a62d37da4180f5" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;inflate&lt;/code&gt; and &lt;code&gt;$InflateError&lt;/code&gt;. Same as doing this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee8ff5937f6a57c492292c874195f1b43a7fe78" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;rawdeflate&lt;/code&gt; , &lt;code&gt;$RawDeflateError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;rawdeflate&lt;/code&gt; ， &lt;code&gt;$RawDeflateError&lt;/code&gt; 和 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 可以使用的所有符号常量。与此相同</target>
        </trans-unit>
        <trans-unit id="6fb62da169da61d1904623e4014ec13f30b31ac3" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;rawdeflate&lt;/code&gt;, &lt;code&gt;$RawDeflateError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt;. Same as doing this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e767570633f5f871775c917a3828a5e9681f4ffd" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;rawinflate&lt;/code&gt; and &lt;code&gt;$RawInflateError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;rawinflate&lt;/code&gt; 和 &lt;code&gt;$RawInflateError&lt;/code&gt; 。与此相同</target>
        </trans-unit>
        <trans-unit id="b57975e38dfb8b63c09125b45981ce41089d4b46" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;rawinflate&lt;/code&gt; and &lt;code&gt;$RawInflateError&lt;/code&gt;. Same as doing this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce5310acfbe49b368b9871554a40ed6e277e8c4" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;unzip&lt;/code&gt; and &lt;code&gt;$UnzipError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;unzip&lt;/code&gt; 和 &lt;code&gt;$UnzipError&lt;/code&gt; 。与此相同</target>
        </trans-unit>
        <trans-unit id="8dce59d7727e957411b6cb73347061a330ebfafc" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;unzip&lt;/code&gt; and &lt;code&gt;$UnzipError&lt;/code&gt;. Same as doing this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c2f9178eea45bfd7d471760d92c394f1bace450" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;zip&lt;/code&gt; , &lt;code&gt;$ZipError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;zip&lt;/code&gt; ， &lt;code&gt;$ZipError&lt;/code&gt; 和 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 可以使用的所有符号常量。与此相同</target>
        </trans-unit>
        <trans-unit id="847ef311d8decfad6e9ddb6bbcfbc5b8302cb9bd" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;zip&lt;/code&gt;, &lt;code&gt;$ZipError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Zip&lt;/code&gt;. Same as doing this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2699b28db29be60d4c03ef4c15f7b6c27c20980d" translate="yes" xml:space="preserve">
          <source>Imports all the functions.</source>
          <target state="translated">导入所有功能。</target>
        </trans-unit>
        <trans-unit id="4e34e9af4ba46ea0c9c8bc6002dd0b4972427661" translate="yes" xml:space="preserve">
          <source>Imports some semantics into the current package from the named module, generally by aliasing certain subroutine or variable names into your package. It is exactly equivalent to</source>
          <target state="translated">将一些语义从命名的模块中导入到当前包中,通常是通过将某些子程序或变量名别名到你的包中。它完全等同于将一些语义从命名的模块中导入到当前包中,一般是通过将某些子程序或变量名别名到你的包中。</target>
        </trans-unit>
        <trans-unit id="3c2be47729bab4d065b481df08ff204f1f40d914" translate="yes" xml:space="preserve">
          <source>Imports the selected functions.</source>
          <target state="translated">导入选定的函数。</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="66efb842734060cc12c6ce77c7726200d42dc777" translate="yes" xml:space="preserve">
          <source>In '(*...)', the '(' and '*' must be adjacent in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04ead423246f254590da876fbfcf30de3598d538" translate="yes" xml:space="preserve">
          <source>In '(*VERB...)', the '(' and '*' must be adjacent in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281e0bcccb215aefbdb7e011061a9ea9aefb2638" translate="yes" xml:space="preserve">
          <source>In '(?...)', the '(' and '?' must be adjacent in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82367e72d0131f5c3fc8d23d0d42328c1c0cde9a" translate="yes" xml:space="preserve">
          <source>In 5.000 to 5.003 perls, trigonometry was done in the &lt;a href=&quot;Math::Complex&quot;&gt;Math::Complex&lt;/a&gt; module. With 5.004, the &lt;a href=&quot;Math::Trig&quot;&gt;Math::Trig&lt;/a&gt; module (part of the standard Perl distribution) implements the trigonometric functions. Internally it uses the &lt;a href=&quot;Math::Complex&quot;&gt;Math::Complex&lt;/a&gt; module and some functions can break out from the real axis into the complex plane, for example the inverse sine of 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e283b44852c55b8cc7c5d3c10f2fb1158a34c408" translate="yes" xml:space="preserve">
          <source>In 5.000 to 5.003 perls, trigonometry was done in the &lt;a href=&quot;math/complex&quot;&gt;Math::Complex&lt;/a&gt; module. With 5.004, the &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt; module (part of the standard Perl distribution) implements the trigonometric functions. Internally it uses the &lt;a href=&quot;math/complex&quot;&gt;Math::Complex&lt;/a&gt; module and some functions can break out from the real axis into the complex plane, for example the inverse sine of 2.</source>
          <target state="translated">在5.000至5.003 perls中，三角函数是在&lt;a href=&quot;math/complex&quot;&gt;Math :: Complex&lt;/a&gt;模块中完成的。使用5.004，&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt;模块（标准Perl发行版的一部分）实现了三角函数。它在内部使用&lt;a href=&quot;math/complex&quot;&gt;Math :: Complex&lt;/a&gt;模块，某些函数可以从实轴分解为复数平面，例如2的反正弦。</target>
        </trans-unit>
        <trans-unit id="391231c66e45cffb8636a5bb3b30c41c9673affc" translate="yes" xml:space="preserve">
          <source>In 5.9.3, &lt;code&gt;newSV()&lt;/code&gt; replaces the older &lt;code&gt;NEWSV()&lt;/code&gt; API, and drops the first parameter,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608cccc0c9bbe325204a599a0810ba75fef50b66" translate="yes" xml:space="preserve">
          <source>In 5.9.3, Newx() and friends replace the older New() API, and drops the first parameter,</source>
          <target state="translated">在5.9.3中,Newx()和friends取代了旧的New()API,并且放弃了第一个参数。</target>
        </trans-unit>
        <trans-unit id="05edeadfa5f882c58e75733f9ca5c3ffa7b75300" translate="yes" xml:space="preserve">
          <source>In 5.9.3, newSV() replaces the older NEWSV() API, and drops the first parameter,</source>
          <target state="translated">在5.9.3中,newSV()取代了旧的NEWSV()API,并删除了第一个参数。</target>
        </trans-unit>
        <trans-unit id="91471efa4c1c6dedd1aca89f914cfd68ba91a793" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#EXAMPLE-4&quot;&gt;&quot;EXAMPLE 4&quot;&lt;/a&gt; the second part of .xs file contained the following description of an XSUB:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0bd3ec2d46f47a7c53bb5eb7fb75ed665e3e0d8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#EXAMPLE-4&quot;&gt;EXAMPLE 4&lt;/a&gt; the second part of .xs file contained the following description of an XSUB:</source>
          <target state="translated">在&lt;a href=&quot;#EXAMPLE-4&quot;&gt;示例4&lt;/a&gt;中，.xs文件的第二部分包含XSUB的以下描述：</target>
        </trans-unit>
        <trans-unit id="7e5fcf76d62ca3c453f917d125d255840ab14460" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#Use-Rule-1&quot;&gt;&lt;b&gt;Use Rule 1&lt;/b&gt;&lt;/a&gt;, you can omit the curly brackets whenever the thing inside them is an atomic scalar variable like &lt;code&gt;$aref&lt;/code&gt;. For example, &lt;code&gt;@$aref&lt;/code&gt; is the same as &lt;code&gt;@{$aref}&lt;/code&gt;, and &lt;code&gt;$$aref[1]&lt;/code&gt; is the same as &lt;code&gt;${$aref}[1]&lt;/code&gt;. If you're just starting out, you may want to adopt the habit of always including the curly brackets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410447fdc9620665a31407179d6df63d2c4b3f50" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;perlfunc#split&quot;&gt;&lt;code&gt;split&lt;/code&gt;'s special-case whitespace splitting&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f10507678ddeb0946365b72294700c17d41e824f" translate="yes" xml:space="preserve">
          <source>In &lt;b&gt;Use Rule 1&lt;/b&gt;, you can omit the curly brackets whenever the thing inside them is an atomic scalar variable like &lt;code&gt;$aref&lt;/code&gt; . For example, &lt;code&gt;@$aref&lt;/code&gt; is the same as &lt;code&gt;@{$aref}&lt;/code&gt; , and &lt;code&gt;$$aref[1]&lt;/code&gt; is the same as &lt;code&gt;${$aref}[1]&lt;/code&gt; . If you're just starting out, you may want to adopt the habit of always including the curly brackets.</source>
          <target state="translated">在&lt;b&gt;使用规则1中&lt;/b&gt;，只要其中的东西是原子标量变量（例如 &lt;code&gt;$aref&lt;/code&gt; ，就可以省略花括号。例如， &lt;code&gt;@$aref&lt;/code&gt; 与 &lt;code&gt;@{$aref}&lt;/code&gt; ，而 &lt;code&gt;$$aref[1]&lt;/code&gt; 与 &lt;code&gt;${$aref}[1]&lt;/code&gt; 。如果您只是刚入门，则可能要养成始终包含大括号的习惯。</target>
        </trans-unit>
        <trans-unit id="557547e0e5d90bb8da914cf09cde8cf85870da5a" translate="yes" xml:space="preserve">
          <source>In &lt;b&gt;shell&lt;/b&gt; programming, the syntactic combination of a program name and its arguments. More loosely, anything you type to a shell (a command interpreter) that starts it doing something. Even more loosely, a Perl &lt;b&gt;statement&lt;/b&gt;, which might start with a &lt;b&gt;label&lt;/b&gt; and typically ends with a semicolon.</source>
          <target state="translated">在&lt;b&gt;Shell&lt;/b&gt;编程中，程序名称及其参数的语法组合。更宽松地说，您键入到外壳程序（命令解释器）中的任何东西都会启动它执行某项操作。更宽松地说，Perl &lt;b&gt;语句&lt;/b&gt;可能以&lt;b&gt;标签&lt;/b&gt;开头，通常以分号结尾。</target>
        </trans-unit>
        <trans-unit id="53ee753ac80ffc3ee3ab0c0d4d2f6ebc840fe7cc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;(?...)&lt;/code&gt; both absolute and relative backreferences may be used. The entire pattern can be reinserted with &lt;code&gt;(?R)&lt;/code&gt; or &lt;code&gt;(?0)&lt;/code&gt;. If you prefer to name your groups, you can use &lt;code&gt;(?&amp;amp;&lt;i&gt;name&lt;/i&gt;)&lt;/code&gt; to recurse into that group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893925583fca341ee58483bd99d5162198b9d0c6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;(?...)&lt;/code&gt; both absolute and relative backreferences may be used. The entire pattern can be reinserted with &lt;code&gt;(?R)&lt;/code&gt; or &lt;code&gt;(?0)&lt;/code&gt;. If you prefer to name your groups, you can use &lt;code&gt;(?&amp;amp;name)&lt;/code&gt; to recurse into that group.</source>
          <target state="translated">在 &lt;code&gt;(?...)&lt;/code&gt; 中，绝对引用和相对引用都可以使用。可以使用 &lt;code&gt;(?R)&lt;/code&gt; 或 &lt;code&gt;(?0)&lt;/code&gt; 重新插入整个模式。如果您想命名组，则可以使用 &lt;code&gt;(?&amp;amp;name)&lt;/code&gt; 递归到该组。</target>
        </trans-unit>
        <trans-unit id="b10785862bf5b38351d62f7106b1ad5b616fb632" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;::INET&lt;/code&gt;, supplying a timeout overrides the non-blocking behaviour, meaning that the &lt;code&gt;connect()&lt;/code&gt; operation will still block despite that the caller asked for a non-blocking socket. This is not explicitly specified in its documentation, nor does this author believe that is a useful behaviour - it appears to come from a quirk of implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e4a1ba97b2988d6a2be557e546a113f04c6f316" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;::IP&lt;/code&gt; therefore, the &lt;code&gt;Blocking&lt;/code&gt; parameter takes precedence - if a non-blocking socket is requested, no operation will block. The &lt;code&gt;Timeout&lt;/code&gt; parameter here simply defines the maximum time that a blocking &lt;code&gt;connect()&lt;/code&gt; call will wait, if it blocks at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38fa69a28fd92dcbb1d20c664855898c29a90ccb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; or its inline equivalent &lt;code&gt;\Q&lt;/code&gt; .</source>
          <target state="translated">用 &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; 或其内联等效 &lt;code&gt;\Q&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1fe5fe4877107e3688ff937058cd386854f2587" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Compress::Zlib&lt;/code&gt; version 1.x, &lt;code&gt;gzopen&lt;/code&gt; used the zlib library to open the underlying file. This made things especially tricky when a Perl filehandle was passed to &lt;code&gt;gzopen&lt;/code&gt; . Behind the scenes the numeric C file descriptor had to be extracted from the Perl filehandle and this passed to the zlib library.</source>
          <target state="translated">在 &lt;code&gt;Compress::Zlib&lt;/code&gt; 版本1.x中， &lt;code&gt;gzopen&lt;/code&gt; 使用zlib库打开基础文件。当将Perl文件句柄传递给 &lt;code&gt;gzopen&lt;/code&gt; 时，这使事情特别棘手。在幕后，必须从Perl文件句柄中提取数字C文件描述符，然后将其传递到zlib库。</target>
        </trans-unit>
        <trans-unit id="97042f19f30bdce3cf114acbac1fee77bdb7a505" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Compress::Zlib&lt;/code&gt; version 1.x, &lt;code&gt;gzopen&lt;/code&gt; used the zlib library to open the underlying file. This made things especially tricky when a Perl filehandle was passed to &lt;code&gt;gzopen&lt;/code&gt;. Behind the scenes the numeric C file descriptor had to be extracted from the Perl filehandle and this passed to the zlib library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bccc4f78696454721af791a75896e8b3d0106582" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Compress::Zlib&lt;/code&gt; version 2.x, the &lt;code&gt;gzopen&lt;/code&gt; interface has been completely rewritten to use the &lt;a href=&quot;../io/compress/gzip&quot;&gt;IO::Compress::Gzip&lt;/a&gt; for writing gzip files and &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt; for reading gzip files. None of the limitations mentioned above apply.</source>
          <target state="translated">在 &lt;code&gt;Compress::Zlib&lt;/code&gt; 版本2.x中，已完全重写 &lt;code&gt;gzopen&lt;/code&gt; 接口，以使用&lt;a href=&quot;../io/compress/gzip&quot;&gt;IO :: Compress :: Gzip&lt;/a&gt;来编写gzip文件，并使用&lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO :: Uncompress :: Gunzip&lt;/a&gt;来读取gzip文件。上述限制均不适用。</target>
        </trans-unit>
        <trans-unit id="114d7ddba5b93cb861ecd5013f29d98f83ffbb88" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Compress::Zlib&lt;/code&gt; version 2.x, the &lt;code&gt;gzopen&lt;/code&gt; interface has been completely rewritten to use the &lt;a href=&quot;IO::Compress::Gzip&quot;&gt;IO::Compress::Gzip&lt;/a&gt; for writing gzip files and &lt;a href=&quot;IO::Uncompress::Gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt; for reading gzip files. None of the limitations mentioned above apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e00aec70e3db954ff900ae2d1de9b4a90ac0844b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Encode&lt;/code&gt; 2.10 or later, &lt;code&gt;LEAVE_SRC&lt;/code&gt; is also implied.</source>
          <target state="translated">在 &lt;code&gt;Encode&lt;/code&gt; 2.10或更高版本中，也暗含了 &lt;code&gt;LEAVE_SRC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51676bb8ef9795bee4bcbafed10516b2d6301ddf" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;native floating point --&amp;gt; native integer&lt;/code&gt; conversions the magnitude of the result is less than or equal to the magnitude of the source. (</source>
          <target state="translated">在 &lt;code&gt;native floating point --&amp;gt; native integer&lt;/code&gt; 转换中，结果的大小小于或等于源的大小。（</target>
        </trans-unit>
        <trans-unit id="7be347ab93d082d1dfdcfb29ae91a2b4d0db0749" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;quotemeta&lt;/code&gt; or its inline equivalent &lt;code&gt;\Q&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67145b5258ab605d487808bb8f38203833e35128" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;simple_replace&lt;/code&gt; we used the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; modifier to replace all occurrences of the regexp on each line. (Even though the regular expression appears in a loop, Perl is smart enough to compile it only once.) As with &lt;code&gt;simple_grep&lt;/code&gt; , both the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/$regexp/$replacement/g&lt;/a&gt;&lt;/code&gt; use &lt;code&gt;$_&lt;/code&gt; implicitly.</source>
          <target state="translated">在 &lt;code&gt;simple_replace&lt;/code&gt; 中,我们使用 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; 修饰符替换了每行上所有出现的regexp。（即使正则表达式出现在循环中，Perl也足够聪明，只可以编译一次。）与 &lt;code&gt;simple_grep&lt;/code&gt; 一样， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/$regexp/$replacement/g&lt;/a&gt;&lt;/code&gt; 隐式使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c4415b354d21581248c9b504615aa6c75b8d907" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;simple_replace&lt;/code&gt; we used the &lt;code&gt;s///g&lt;/code&gt; modifier to replace all occurrences of the regexp on each line. (Even though the regular expression appears in a loop, Perl is smart enough to compile it only once.) As with &lt;code&gt;simple_grep&lt;/code&gt;, both the &lt;code&gt;print&lt;/code&gt; and the &lt;code&gt;s/$regexp/$replacement/g&lt;/code&gt; use &lt;code&gt;$_&lt;/code&gt; implicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d077e5ff0102748fbe2d5e45a0e1e202f0802167" translate="yes" xml:space="preserve">
          <source>In AIX 4.2 Perl extensions that use C++ functions that use statics may have problems in that the statics are not getting initialized. In newer AIX releases this has been solved by linking Perl with the libC_r library, but unfortunately in AIX 4.2 the said library has an obscure bug where the various functions related to time (such as time() and gettimeofday()) return broken values, and therefore in AIX 4.2 Perl is not linked against the libC_r.</source>
          <target state="translated">在AIX 4.2中,使用静态的C++函数的Perl扩展可能会出现静态没有被初始化的问题。在较新的AIX版本中,这个问题已经通过将Perl与libC_r库链接来解决,但不幸的是,在AIX 4.2中,该库有一个不明显的bug,即与时间有关的各种函数(如time()和gettimeofday())会返回破损的值,因此在AIX 4.2中,Perl不能与libC_r链接。</target>
        </trans-unit>
        <trans-unit id="5c64677f24dcacb245231383a983d4852fe14280" translate="yes" xml:space="preserve">
          <source>In BigInt, all numbers except &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; and &lt;code&gt;-inf&lt;/code&gt; are integers.</source>
          <target state="translated">在BigInt中，除了 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;+inf&lt;/code&gt; 和 &lt;code&gt;-inf&lt;/code&gt; 之外的所有数字都是整数。</target>
        </trans-unit>
        <trans-unit id="f83bdc44eedb56878bfa30e1ea8c050d2167ca73" translate="yes" xml:space="preserve">
          <source>In BigInt, unless upgrading is in effect, the result is truncated to an integer.</source>
          <target state="translated">在BigInt中,除非升级生效,否则结果将被截断为一个整数。</target>
        </trans-unit>
        <trans-unit id="a6200922eb25a34272b79346b2b9f5be87e701ac" translate="yes" xml:space="preserve">
          <source>In CVS and RCS version 1.9 is followed by 1.10. Since CPAN compares version numbers numerically we use a sprintf() to convert 1.9 to 1.009 and 1.10 to 1.010 which compare properly.</source>
          <target state="translated">在CVS和RCS中,1.9版本后面是1.10。由于CPAN用数字比较版本号,所以我们用sprintf()把1.9转换成1.009,把1.10转换成1.010,这样就能正确比较了。</target>
        </trans-unit>
        <trans-unit id="e6d98db49c1b068959bb3c31358e246a1630b67a" translate="yes" xml:space="preserve">
          <source>In CVS, RCS and SVN you use $Revision$ (see the documentation of your version control system for details). Every time the file is checked in the $Revision$ will be updated, updating your $VERSION.</source>
          <target state="translated">在 CVS、RCS 和 SVN 中,你可以使用 $Revision$ (详见你的版本控制系统的文档)。每次检查文件时,$Revision$都会被更新,更新你的$VERSION。</target>
        </trans-unit>
        <trans-unit id="562c80499b9073a3905b98e95f6a9c71ca119547" translate="yes" xml:space="preserve">
          <source>In Cray UNICOS there is some strange numerical instability that results in root(), cos(), sin(), cosh(), sinh(), losing accuracy fast. Beware. The bug may be in UNICOS math libs, in UNICOS C compiler, in Math::Complex. Whatever it is, it does not manifest itself anywhere else where Perl runs.</source>
          <target state="translated">在Cray UNICOS中,有一些奇怪的数值不稳定,导致root()、cos()、sin()、cosh()、sinh(),快速失去精度。请注意。这个bug可能存在于UNICOS数学库、UNICOS C编译器、Math::Complex中。不管是什么,在Perl运行的其他地方都没有表现出来。</target>
        </trans-unit>
        <trans-unit id="c2148313df160c8d66540765266d0deaea355ab2" translate="yes" xml:space="preserve">
          <source>In DUCET v4.0.0, primary weight of &lt;code&gt;C&lt;/code&gt; is &lt;code&gt;0E60&lt;/code&gt; and that of &lt;code&gt;D&lt;/code&gt; is &lt;code&gt;0E6D&lt;/code&gt; . So setting primary weight of &lt;code&gt;CH&lt;/code&gt; to &lt;code&gt;0E6A&lt;/code&gt; (as a value between &lt;code&gt;0E60&lt;/code&gt; and &lt;code&gt;0E6D&lt;/code&gt; ) makes ordering as &lt;code&gt;C &amp;lt; CH &amp;lt; D&lt;/code&gt; . Exactly speaking DUCET already has some characters between &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; : &lt;code&gt;small capital C&lt;/code&gt; (&lt;code&gt;U+1D04&lt;/code&gt;) with primary weight &lt;code&gt;0E64&lt;/code&gt; , &lt;code&gt;c-hook/C-hook&lt;/code&gt; (&lt;code&gt;U+0188/U+0187&lt;/code&gt;) with &lt;code&gt;0E65&lt;/code&gt; , and &lt;code&gt;c-curl&lt;/code&gt; (&lt;code&gt;U+0255&lt;/code&gt; ) with &lt;code&gt;0E69&lt;/code&gt; . Then primary weight &lt;code&gt;0E6A&lt;/code&gt; for &lt;code&gt;CH&lt;/code&gt; makes &lt;code&gt;CH&lt;/code&gt; ordered between &lt;code&gt;c-curl&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; .</source>
          <target state="translated">在DUCET v4.0.0中， &lt;code&gt;C&lt;/code&gt; 的主要权重为 &lt;code&gt;0E60&lt;/code&gt; ， &lt;code&gt;D&lt;/code&gt; 的主要权重为 &lt;code&gt;0E6D&lt;/code&gt; 。因此，将 &lt;code&gt;CH&lt;/code&gt; 的主要权重设置为 &lt;code&gt;0E6A&lt;/code&gt; （作为介于 &lt;code&gt;0E60&lt;/code&gt; 和 &lt;code&gt;0E6D&lt;/code&gt; 之间的值）可使排序为 &lt;code&gt;C &amp;lt; CH &amp;lt; D&lt;/code&gt; 。准确地说DUCET已有之间某些字符 &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; ： &lt;code&gt;small capital C&lt;/code&gt; （ &lt;code&gt;U+1D04&lt;/code&gt; 与主配重） &lt;code&gt;0E64&lt;/code&gt; ， &lt;code&gt;c-hook/C-hook&lt;/code&gt; （ &lt;code&gt;U+0188/U+0187&lt;/code&gt; ）与 &lt;code&gt;0E65&lt;/code&gt; 和 &lt;code&gt;c-curl&lt;/code&gt; （ &lt;code&gt;U+0255&lt;/code&gt; ）和 &lt;code&gt;0E69&lt;/code&gt; 。然后， &lt;code&gt;CH&lt;/code&gt; 的主要权重 &lt;code&gt;0E6A&lt;/code&gt; 使 &lt;code&gt;CH&lt;/code&gt; 在 &lt;code&gt;c-curl&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 之间有序。</target>
        </trans-unit>
        <trans-unit id="9108a2eddf4a9c8b757bb1b0b2974cb82775ee81" translate="yes" xml:space="preserve">
          <source>In DUCET v4.0.0, primary weight of &lt;code&gt;C&lt;/code&gt; is &lt;code&gt;0E60&lt;/code&gt; and that of &lt;code&gt;D&lt;/code&gt; is &lt;code&gt;0E6D&lt;/code&gt;. So setting primary weight of &lt;code&gt;CH&lt;/code&gt; to &lt;code&gt;0E6A&lt;/code&gt; (as a value between &lt;code&gt;0E60&lt;/code&gt; and &lt;code&gt;0E6D&lt;/code&gt;) makes ordering as &lt;code&gt;C &amp;lt; CH &amp;lt; D&lt;/code&gt;. Exactly speaking DUCET already has some characters between &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt;: &lt;code&gt;small capital C&lt;/code&gt; (&lt;code&gt;U+1D04&lt;/code&gt;) with primary weight &lt;code&gt;0E64&lt;/code&gt;, &lt;code&gt;c-hook/C-hook&lt;/code&gt; (&lt;code&gt;U+0188/U+0187&lt;/code&gt;) with &lt;code&gt;0E65&lt;/code&gt;, and &lt;code&gt;c-curl&lt;/code&gt; (&lt;code&gt;U+0255&lt;/code&gt;) with &lt;code&gt;0E69&lt;/code&gt;. Then primary weight &lt;code&gt;0E6A&lt;/code&gt; for &lt;code&gt;CH&lt;/code&gt; makes &lt;code&gt;CH&lt;/code&gt; ordered between &lt;code&gt;c-curl&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cbd5bc5a38769b2182dd3a8ac3c64a575d3f230" translate="yes" xml:space="preserve">
          <source>In English grammar, a short noun phrase between a verb and its direct object indicating the beneficiary or recipient of the action. In Perl, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; STDOUT &quot;$foo\n&quot;;&lt;/code&gt; can be understood as &amp;ldquo;verb indirect-object object&amp;rdquo;, where &lt;code&gt;STDOUT&lt;/code&gt; is the recipient of the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; action, and &lt;code&gt;&quot;$foo&quot;&lt;/code&gt; is the object being printed. Similarly, when invoking a &lt;b&gt;method&lt;/b&gt;, you might place the invocant in the dative slot between the method and its arguments:</source>
          <target state="translated">在英语语法中，动词与其直接宾语之间的简短名词短语，指示操作的受益者或接受者。在Perl中， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; STDOUT &quot;$foo\n&quot;;&lt;/code&gt; 可以理解为&amp;ldquo;动词间接对象对象&amp;rdquo;，其中 &lt;code&gt;STDOUT&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 操作的接收者， &lt;code&gt;&quot;$foo&quot;&lt;/code&gt; 是要打印的对象。同样，在调用&lt;b&gt;方法时&lt;/b&gt;，您可以将倡导者放在方法与其参数之间的固定位置中：</target>
        </trans-unit>
        <trans-unit id="06b568eacf88b97c4f6196a1f9c16a7ddc571968" translate="yes" xml:space="preserve">
          <source>In English grammar, a short noun phrase between a verb and its direct object indicating the beneficiary or recipient of the action. In Perl, &lt;code&gt;print STDOUT &quot;$foo\n&quot;;&lt;/code&gt; can be understood as &amp;ldquo;verb indirect-object object&amp;rdquo;, where &lt;code&gt;STDOUT&lt;/code&gt; is the recipient of the &lt;code&gt;print&lt;/code&gt; action, and &lt;code&gt;&quot;$foo&quot;&lt;/code&gt; is the object being printed. Similarly, when invoking a &lt;b&gt;method&lt;/b&gt;, you might place the invocant in the dative slot between the method and its arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d7750b76c1912ccfb266e5802e9aeb1ba6b515" translate="yes" xml:space="preserve">
          <source>In February 2017 the cPanel Security Team reported an additional vulnerability in File-Path. The &lt;code&gt;chmod()&lt;/code&gt; logic to make directories traversable can be abused to set the mode on an attacker-chosen file to an attacker-chosen value. This is due to the time-of-check-to-time-of-use (TOCTTOU) race condition (&lt;a href=&quot;https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use&quot;&gt;https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use&lt;/a&gt;) between the &lt;code&gt;stat()&lt;/code&gt; that decides the inode is a directory and the &lt;code&gt;chmod()&lt;/code&gt; that tries to make it user-rwx. CPAN versions 2.13 and later incorporate a patch provided by John Lightsey to address this problem. This vulnerability has been reported as CVE-2017-6512.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="217cde63e66af3805baaae8b61bf234934e3a17f" translate="yes" xml:space="preserve">
          <source>In IRIX 5.3 and with Perl 5.8.1 (Perl 5.8.0 didn't compile in IRIX 5.3) the following failures are known.</source>
          <target state="translated">在IRIX 5.3和Perl 5.8.1中(Perl 5.8.0没有在IRIX 5.3中编译),已知有以下故障。</target>
        </trans-unit>
        <trans-unit id="ae875351a921c55e10385097f1ce568f0cc36c5c" translate="yes" xml:space="preserve">
          <source>In MakeMaker-based installations,</source>
          <target state="translated">在基于MakeMaker的安装中。</target>
        </trans-unit>
        <trans-unit id="9c3daa3a40c6c633fa39ff2200e0ca157291c425" translate="yes" xml:space="preserve">
          <source>In Math::BigFloat, &lt;code&gt;as_float()&lt;/code&gt; has the same effect as &lt;code&gt;copy()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e41060b8b4a1259b3e9cbe537abe5b49f3f3c1c" translate="yes" xml:space="preserve">
          <source>In Math::BigInt, &lt;code&gt;as_int()&lt;/code&gt; has the same effect as &lt;code&gt;copy()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8ca889adcc661187e58d592f4912a7f93ee302a" translate="yes" xml:space="preserve">
          <source>In Math::BigInt, passing a negative number precision has no effect since no numbers have digits after the dot. In &lt;a href=&quot;bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;, it will round all results to P digits after the dot.</source>
          <target state="translated">在Math :: BigInt中，传递负数精度无效，因为没有数字在点后有数字。在&lt;a href=&quot;bigfloat&quot;&gt;Math :: BigFloat中&lt;/a&gt;，它将所有结果四舍五入到点后的P位。</target>
        </trans-unit>
        <trans-unit id="e908380ff562833ce5edafb0da699c167037b50c" translate="yes" xml:space="preserve">
          <source>In Math::BigInt, this method is identical to &lt;code&gt;parts()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d74a3513f84eb343c782544d1a1cd43c3880330" translate="yes" xml:space="preserve">
          <source>In Math::BigInt, unless upgrading is in effect, the result is truncated to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="846e78092ad74f765fcf7c9c94ce51c84e742d1b" translate="yes" xml:space="preserve">
          <source>In Memory Databases</source>
          <target state="translated">内存数据库</target>
        </trans-unit>
        <trans-unit id="3f860bffab3d111dbe427091c4d724eab7972b48" translate="yes" xml:space="preserve">
          <source>In Part 1 we mentioned that Perl compiles a regexp into a compact sequence of opcodes. Thus, a compiled regexp is a data structure that can be stored once and used again and again. The regexp quote &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; does exactly that: &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/string/&lt;/a&gt;&lt;/code&gt; compiles the &lt;code&gt;string&lt;/code&gt; as a regexp and transforms the result into a form that can be assigned to a variable:</source>
          <target state="translated">在第1部分中，我们提到了Perl将正则表达式编译为紧凑的操作码序列。因此，已编译的正则表达式是一种数据结构，可以存储一次并反复使用。正则表达式报价 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 正是如此： &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/string/&lt;/a&gt;&lt;/code&gt; 编译 &lt;code&gt;string&lt;/code&gt; 作为正则表达式，并将结果转换成可被分配给一个变量的一种形式：</target>
        </trans-unit>
        <trans-unit id="9f422c71ad852c82f393abc6d42d6ed23387e826" translate="yes" xml:space="preserve">
          <source>In Part 1 we mentioned that Perl compiles a regexp into a compact sequence of opcodes. Thus, a compiled regexp is a data structure that can be stored once and used again and again. The regexp quote &lt;code&gt;qr//&lt;/code&gt; does exactly that: &lt;code&gt;qr/string/&lt;/code&gt; compiles the &lt;code&gt;string&lt;/code&gt; as a regexp and transforms the result into a form that can be assigned to a variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e23998d4d31cf53431494db737762f35860793" translate="yes" xml:space="preserve">
          <source>In Perl 5.005, the thread model was that all data is implicitly shared, and shared access to data has to be explicitly synchronized. This model is called</source>
          <target state="translated">在Perl 5.005中,线程模型是所有的数据都是隐式共享的,共享访问数据必须显式同步。这个模型被称为</target>
        </trans-unit>
        <trans-unit id="0ef40fb67bd5325ef3bc9871c79bffa2a2f9def8" translate="yes" xml:space="preserve">
          <source>In Perl 5.10, declare the variable with &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; declaration creates the lexical variable that persists between calls to the subroutine:</source>
          <target state="translated">在Perl 5.10中，使用 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 声明变量。该 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 的声明创建词法变量调用子程序之间挖墙角：</target>
        </trans-unit>
        <trans-unit id="a8b8dc6512fddc6a912b0cbfde84c91f304428a9" translate="yes" xml:space="preserve">
          <source>In Perl 5.10, declare the variable with &lt;code&gt;state&lt;/code&gt;. The &lt;code&gt;state&lt;/code&gt; declaration creates the lexical variable that persists between calls to the subroutine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcad1e403285c6c0597be1e44d89e383fc28fe4e" translate="yes" xml:space="preserve">
          <source>In Perl 5.10, the</source>
          <target state="translated">在Perl 5.10中,</target>
        </trans-unit>
        <trans-unit id="3754647e31be439690cdc120d0f37bbfc1ee49d5" translate="yes" xml:space="preserve">
          <source>In Perl 5.10, use the &lt;code&gt;given-when&lt;/code&gt; construct described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;:</source>
          <target state="translated">在Perl 5.10中，使用&lt;a href=&quot;perlsyn&quot;&gt;perlsyn中&lt;/a&gt;描述的 &lt;code&gt;given-when&lt;/code&gt; 结构：</target>
        </trans-unit>
        <trans-unit id="ef6f20b95a614e3c70a519351a658bbdee2e34af" translate="yes" xml:space="preserve">
          <source>In Perl 5.10.0 the &lt;code&gt;/p&lt;/code&gt; match operator flag and the &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; , and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables were introduced, that allowed you to suffer the penalties only on patterns marked with &lt;code&gt;/p&lt;/code&gt;.</source>
          <target state="translated">在Perl 5.10.0中，引入了 &lt;code&gt;/p&lt;/code&gt; 匹配运算符标志以及 &lt;code&gt;${^PREMATCH}&lt;/code&gt; ， &lt;code&gt;${^MATCH}&lt;/code&gt; 和 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 变量，它们使您仅能对标有 &lt;code&gt;/p&lt;/code&gt; 的模式进行惩罚。</target>
        </trans-unit>
        <trans-unit id="0f3e250c35c16ed5beded9eecafc97e7f7748952" translate="yes" xml:space="preserve">
          <source>In Perl 5.10.0 the &lt;code&gt;/p&lt;/code&gt; match operator flag and the &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt;, and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables were introduced, that allowed you to suffer the penalties only on patterns marked with &lt;code&gt;/p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfdfceeeffa73fd56622a7e4fbcd615a7de619f1" translate="yes" xml:space="preserve">
          <source>In Perl 5.16 and earlier, copy-on-write (see the next section) shared a flag bit with read-only scalars. So the only way to test whether &lt;code&gt;sv_setsv&lt;/code&gt; , etc., will raise a &quot;Modification of a read-only value&quot; error in those versions is:</source>
          <target state="translated">在Perl 5.16和更早版本中，写时复制（请参阅下一节）与只读标量共享一个标志位。因此，测试 &lt;code&gt;sv_setsv&lt;/code&gt; 等在这​​些版本中是否会引发&amp;ldquo;只读值的修改&amp;rdquo;错误的唯一方法是：</target>
        </trans-unit>
        <trans-unit id="2de270c18c4d05efea842690bbe0309208ec91c2" translate="yes" xml:space="preserve">
          <source>In Perl 5.16 and earlier, copy-on-write (see the next section) shared a flag bit with read-only scalars. So the only way to test whether &lt;code&gt;sv_setsv&lt;/code&gt;, etc., will raise a &quot;Modification of a read-only value&quot; error in those versions is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c29d499be725da440aa9799fa65cef604b0abdb" translate="yes" xml:space="preserve">
          <source>In Perl 5.18.0 onwards, perl started noting the presence of each of the three variables separately, and only copied that part of the string required; so in</source>
          <target state="translated">在Perl 5.18.0以后,perl开始分别注意到这三个变量的存在,并且只复制字符串中需要的那部分;所以在</target>
        </trans-unit>
        <trans-unit id="bb6846bd814a1146dc2f695e71c44bd7e9fb3806" translate="yes" xml:space="preserve">
          <source>In Perl 5.20 and 5.22, this syntax must be enabled with &lt;code&gt;use feature 'postderef'&lt;/code&gt;. As of Perl 5.24, no feature declarations are required to make it available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac74f29244f42c123f550a223146503cf87cca65" translate="yes" xml:space="preserve">
          <source>In Perl 5.20 and earlier, the only pragmas to be completely supported are: &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . (&lt;code&gt;$[&lt;/code&gt; , which behaves like a pragma, is also supported.)</source>
          <target state="translated">在Perl 5.20及更早版本中，唯一受完全支持的编译指示是： &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; 。（也支持 &lt;code&gt;$[&lt;/code&gt; ，其行为类似于杂注。）</target>
        </trans-unit>
        <trans-unit id="a99daea546c9fc521d28b295e0227c75c1c77163" translate="yes" xml:space="preserve">
          <source>In Perl 5.20 and higher this is ignored. Due to a new copy-on-write mechanism, ${^PREMATCH}, ${^MATCH}, and ${^POSTMATCH} will be available after the match regardless of the modifier.</source>
          <target state="translated">在 Perl 5.20 或更高版本中,这个功能会被忽略。由于采用了新的写后复制机制,${^PREMATCH}、${^MATCH}和 ${^POSTMATCH}将在匹配后可用,而不考虑修饰符。</target>
        </trans-unit>
        <trans-unit id="c2e345cc084802e472e843021a52be876a248694" translate="yes" xml:space="preserve">
          <source>In Perl 5.20 and higher this is ignored. Due to a new copy-on-write mechanism, &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt;, and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; will be available after the match regardless of the modifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd87335d7944293ee760ce3fce6d463be42dedd" translate="yes" xml:space="preserve">
          <source>In Perl 5.20.0 a new copy-on-write system was enabled by default, which finally fixes all performance issues with these three variables, and makes them safe to use anywhere.</source>
          <target state="translated">在Perl 5.20.0中,默认启用了一个新的copy-on-write系统,终于解决了这三个变量的所有性能问题,使它们可以安全地在任何地方使用。</target>
        </trans-unit>
        <trans-unit id="f3bfdc8baf280a72c47cbbea941ae21c16b028e7" translate="yes" xml:space="preserve">
          <source>In Perl 5.20.0 this was changed so that it would be &lt;b&gt;exactly&lt;/b&gt; the same as setting &lt;code&gt;$/&lt;/code&gt; to undef, with the exception that this warning would be thrown.</source>
          <target state="translated">在Perl 5.20.0中对此进行了更改，使其与将 &lt;code&gt;$/&lt;/code&gt; 设置为 undef &lt;b&gt;完全相同&lt;/b&gt;，不同之处在于将抛出此警告。</target>
        </trans-unit>
        <trans-unit id="b9a5cb481a025f6680fe2e560f757bef411f0354" translate="yes" xml:space="preserve">
          <source>In Perl 5.22 and later, all groups within a regexp can be set to non-capturing by using the new &lt;code&gt;/n&lt;/code&gt; flag:</source>
          <target state="translated">在Perl 5.22和更高版本中，可以使用新的 &lt;code&gt;/n&lt;/code&gt; 标志将正则表达式中的所有组设置为不捕获：</target>
        </trans-unit>
        <trans-unit id="8c05f57b472f3633ffbc63a5a1677bbf1fd5199a" translate="yes" xml:space="preserve">
          <source>In Perl 5.30 and earlier, lookbehind is allowed only for subexpressions whose length is fixed and known at compile time. For positive lookbehind, you can use the &lt;code&gt;\K&lt;/code&gt; regex construct as a way to get the equivalent functionality. See &lt;a href=&quot;perlre#%5CK&quot;&gt;(?&amp;lt;=pattern) and \K in perlre&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="015d46ab8b3eb1374b9c9159b3586fa11c13b7fc" translate="yes" xml:space="preserve">
          <source>In Perl 5.30, it will no longer be possible to use sysread(), recv(), syswrite() or send() to read or send bytes from/to :utf8 handles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829f62b5d0005de3966076a8745c273476071683" translate="yes" xml:space="preserve">
          <source>In Perl 5.6 and some books the &lt;code&gt;:raw&lt;/code&gt; layer (previously sometimes also referred to as a &quot;discipline&quot;) is documented as the inverse of the &lt;code&gt;:crlf&lt;/code&gt; layer. That is no longer the case - other layers which would alter the binary nature of the stream are also disabled. If you want UNIX line endings on a platform that normally does CRLF translation, but still want UTF-8 or encoding defaults, the appropriate thing to do is to add &lt;code&gt;:perlio&lt;/code&gt; to the PERLIO environment variable.</source>
          <target state="translated">在Perl 5.6和一些书籍中， &lt;code&gt;:raw&lt;/code&gt; 层（以前有时也称为&amp;ldquo;学科&amp;rdquo;）被记录为 &lt;code&gt;:crlf&lt;/code&gt; 层的反面。情况不再如此-会更改流的二进制性质的其他层也被禁用。如果要在通常执行CRLF转换的平台上使用UNIX行结尾，但仍希望使用UTF-8或编码默认值，则适当的做法是将 &lt;code&gt;:perlio&lt;/code&gt; 添加到PERLIO环境变量中。</target>
        </trans-unit>
        <trans-unit id="fad3da3a77d2a8e0c192dfbe3d758d620ee24b00" translate="yes" xml:space="preserve">
          <source>In Perl 5.6 and some books the &lt;code&gt;:raw&lt;/code&gt; layer is documented as the inverse of the &lt;code&gt;:crlf&lt;/code&gt; layer. That is no longer the case - other layers which would alter the binary nature of the stream are also disabled. If you want UNIX line endings on a platform that normally does CRLF translation, but still want UTF-8 or encoding defaults, the appropriate thing to do is to add &lt;code&gt;:perlio&lt;/code&gt; to the PERLIO environment variable, or open the handle explicitly with that layer, to replace the platform default of &lt;code&gt;:crlf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fac8c7e82a994285a91ea520c95723e026d4360" translate="yes" xml:space="preserve">
          <source>In Perl 5.6, a new model was introduced in which all is was thread local and shared access to data has to be explicitly declared. This model is called</source>
          <target state="translated">在Perl 5.6中,引入了一个新的模型,在这个模型中,所有的数据都是线程本地的,对数据的共享访问必须要明确声明。这个模型被称为</target>
        </trans-unit>
        <trans-unit id="c2abdf6c9d513612683e10abfef7f22af8c5271f" translate="yes" xml:space="preserve">
          <source>In Perl 5.6, the</source>
          <target state="translated">在Perl 5.6中,</target>
        </trans-unit>
        <trans-unit id="26c0c53508feac78fbf5a2c99792e045ffa03c8a" translate="yes" xml:space="preserve">
          <source>In Perl 5.6.0 the &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; dynamic arrays were introduced that supply the indices of successful matches. So you could for example do this:</source>
          <target state="translated">在Perl 5.6.0中，引入了 &lt;code&gt;@-&lt;/code&gt; 和 &lt;code&gt;@+&lt;/code&gt; 动态数组，它们提供成功匹配的索引。因此，您可以例如执行以下操作：</target>
        </trans-unit>
        <trans-unit id="523c10b75565b9e0e195e0700fdbbd2ed237ae32" translate="yes" xml:space="preserve">
          <source>In Perl 5.8, the</source>
          <target state="translated">在Perl 5.8中,</target>
        </trans-unit>
        <trans-unit id="a58322d6122d01dd67612b6444328927a4d69bfc" translate="yes" xml:space="preserve">
          <source>In Perl 5.8.0 the slowness was often quite spectacular; in Perl 5.8.1 a caching scheme was introduced which improved the situation. In general, operations with UTF-8 encoded strings are still slower. As an example, the Unicode properties (character classes) like &lt;code&gt;\p{Nd}&lt;/code&gt; are known to be quite a bit slower (5-20 times) than their simpler counterparts like &lt;code&gt;[0-9]&lt;/code&gt; (then again, there are hundreds of Unicode characters matching &lt;code&gt;Nd&lt;/code&gt; compared with the 10 ASCII characters matching &lt;code&gt;[0-9]&lt;/code&gt; ).</source>
          <target state="translated">在Perl 5.8.0中，速度通常非常惊人。在Perl 5.8.1中引入了一种缓存方案，从而改善了这种情况。通常，使用UTF-8编码的字符串的操作仍然较慢。例如，已知 &lt;code&gt;\p{Nd}&lt;/code&gt; 类的Unicode属性（字符类）比 &lt;code&gt;[0-9]&lt;/code&gt; 之类的简单属性（5-20倍）要慢得多（5-20​​倍）（然后，还有数百种Unicode匹配 &lt;code&gt;Nd&lt;/code&gt; 的字符和匹配 &lt;code&gt;[0-9]&lt;/code&gt; 的10个ASCII字符）。</target>
        </trans-unit>
        <trans-unit id="e439fc7cf20010bb9655a79250e2e3dd1a376ddd" translate="yes" xml:space="preserve">
          <source>In Perl 5.8.0 the slowness was often quite spectacular; in Perl 5.8.1 a caching scheme was introduced which improved the situation. In general, operations with UTF-8 encoded strings are still slower. As an example, the Unicode properties (character classes) like &lt;code&gt;\p{Nd}&lt;/code&gt; are known to be quite a bit slower (5-20 times) than their simpler counterparts like &lt;code&gt;[0-9]&lt;/code&gt; (then again, there are hundreds of Unicode characters matching &lt;code&gt;Nd&lt;/code&gt; compared with the 10 ASCII characters matching &lt;code&gt;[0-9]&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c85305fdff4b0749bfcf24c2c7a107269854de9" translate="yes" xml:space="preserve">
          <source>In Perl 6, &lt;code&gt;when()&lt;/code&gt; will always do an implicit smartmatch with its argument, while in Perl 5 it is convenient (albeit potentially confusing) to suppress this implicit smartmatch in various rather loosely-defined situations, as roughly outlined above. (The difference is largely because Perl 5 does not have, even internally, a boolean type.)</source>
          <target state="translated">在Perl 6中， &lt;code&gt;when()&lt;/code&gt; 将始终对其参数进行隐式智能匹配，而在Perl 5中，在各种相当松散定义的情况下抑制该隐式智能匹配很方便（尽管可能会造成混淆），如上所述。 （差异主要是因为Perl 5甚至在内部都没有布尔类型。）</target>
        </trans-unit>
        <trans-unit id="ca97d510355543881848d3f320ae7ab2b8841db0" translate="yes" xml:space="preserve">
          <source>In Perl most objects are hashes, but the OO systems we recommend keep you from having to worry about this. In practice, it's best to consider an object's internal data structure opaque.</source>
          <target state="translated">在Perl中,大多数对象都是哈希,但我们推荐的OO系统让你不必担心这个问题。在实践中,最好将对象的内部数据结构视为不透明的。</target>
        </trans-unit>
        <trans-unit id="6fcb11a99abfcbef52ae2fdd52d4cd8656bbc249" translate="yes" xml:space="preserve">
          <source>In Perl regular expressions, most regexp elements &quot;eat up&quot; a certain amount of string when they match. For instance, the regexp element &lt;code&gt;[abc]&lt;/code&gt; eats up one character of the string when it matches, in the sense that Perl moves to the next character position in the string after the match. There are some elements, however, that don't eat up characters (advance the character position) if they match. The examples we have seen so far are the anchors. The anchor &lt;code&gt;'^'&lt;/code&gt; matches the beginning of the line, but doesn't eat any characters. Similarly, the word boundary anchor &lt;code&gt;\b&lt;/code&gt; matches wherever a character matching &lt;code&gt;\w&lt;/code&gt; is next to a character that doesn't, but it doesn't eat up any characters itself. Anchors are examples of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243bad753f535e22807612697dcecab4311e323e" translate="yes" xml:space="preserve">
          <source>In Perl regular expressions, most regexp elements 'eat up' a certain amount of string when they match. For instance, the regexp element &lt;code&gt;[abc}]&lt;/code&gt; eats up one character of the string when it matches, in the sense that Perl moves to the next character position in the string after the match. There are some elements, however, that don't eat up characters (advance the character position) if they match. The examples we have seen so far are the anchors. The anchor &lt;code&gt;^&lt;/code&gt; matches the beginning of the line, but doesn't eat any characters. Similarly, the word boundary anchor &lt;code&gt;\b&lt;/code&gt; matches wherever a character matching &lt;code&gt;\w&lt;/code&gt; is next to a character that doesn't, but it doesn't eat up any characters itself. Anchors are examples of</source>
          <target state="translated">在Perl正则表达式中，大多数regexp元素匹配时会&amp;ldquo;吃掉&amp;rdquo;一定数量的字符串。例如，正则表达式元素 &lt;code&gt;[abc}]&lt;/code&gt; 在匹配时会吃掉字符串中的一个字符，从某种意义上说，Perl会在匹配后移到字符串中的下一个字符位置。但是，有些元素在匹配时不会消耗字符（提前字符位置）。到目前为止，我们看到的示例都是锚。锚点 &lt;code&gt;^&lt;/code&gt; 与行的开头匹配，但不占用任何字符。同样，单词边界锚 &lt;code&gt;\b&lt;/code&gt; 与匹配 &lt;code&gt;\w&lt;/code&gt; 的字符在不存在但不占用任何字符的字符旁边匹配。锚是</target>
        </trans-unit>
        <trans-unit id="905e1c7e56de580fc4af4b17e4c486804586d33e" translate="yes" xml:space="preserve">
          <source>In Perl terms this means that supplying the usual Perl numbers (also known as scalars, please see &lt;a href=&quot;../perldata&quot;&gt;perldata&lt;/a&gt;) as input for the trigonometric functions might produce as output results that no more are simple real numbers: instead they are complex numbers.</source>
          <target state="translated">用Perl术语来说，这意味着提供常用的Perl数（也称为标量，请参见&lt;a href=&quot;../perldata&quot;&gt;perldata&lt;/a&gt;）作为三角函数的输入可能会产生输出结果，不再是简单的实数：而是复杂的数。</target>
        </trans-unit>
        <trans-unit id="c89c1933f929227bc6d7b434996b4c3d5312db42" translate="yes" xml:space="preserve">
          <source>In Perl terms this means that supplying the usual Perl numbers (also known as scalars, please see &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;) as input for the trigonometric functions might produce as output results that no more are simple real numbers: instead they are complex numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f326f4fd32f12380a2d175a436e985d3f4c2edf" translate="yes" xml:space="preserve">
          <source>In Perl v5.14, all non-ASCII characters are quoted in non-UTF-8-encoded strings, but not quoted in UTF-8 strings.</source>
          <target state="translated">在Perl v5.14中,所有非ASCII字符在非UTF-8编码的字符串中都会被引用,但在UTF-8字符串中不会被引用。</target>
        </trans-unit>
        <trans-unit id="0ffdb19ef413239753228d33908dad38e29d542e" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^MATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$MATCH&lt;/code&gt; .</source>
          <target state="translated">在Perl v5.18及更早版本中，仅保证在使用 &lt;code&gt;/p&lt;/code&gt; 修饰符编译或执行模式时返回定义的值。在Perl v5.20中， &lt;code&gt;/p&lt;/code&gt; 修饰符不执行任何操作，因此 &lt;code&gt;${^MATCH}&lt;/code&gt; 与 &lt;code&gt;$MATCH&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="057abcd6479cca74c3b9fb3d3dd6b27878d1413e" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^MATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$MATCH&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4dbbc56c5f11021be8e37601f6986f49dc8e148" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^POSTMATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$POSTMATCH&lt;/code&gt; .</source>
          <target state="translated">在Perl v5.18及更早版本中，仅保证在使用 &lt;code&gt;/p&lt;/code&gt; 修饰符编译或执行模式时返回定义的值。在Perl v5.20中， &lt;code&gt;/p&lt;/code&gt; 修饰符不执行任何操作，因此 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 与 &lt;code&gt;$POSTMATCH&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="7db6a7a5d2c710c4176385519a525c382964c439" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^POSTMATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$POSTMATCH&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05c22186f7acbb5a1c00ca1269cc907a18af05f8" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^PREMATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$PREMATCH&lt;/code&gt; .</source>
          <target state="translated">在Perl v5.18及更早版本中，仅保证在使用 &lt;code&gt;/p&lt;/code&gt; 修饰符编译或执行模式时返回定义的值。在Perl v5.20中， &lt;code&gt;/p&lt;/code&gt; 修饰符不执行任何操作，因此 &lt;code&gt;${^PREMATCH}&lt;/code&gt; 与 &lt;code&gt;$PREMATCH&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="dd3dd771da7118a3415ee7efa43387081550b359" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^PREMATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$PREMATCH&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5432c77569fd0514eaa8844532d6c5cc637bdaa6" translate="yes" xml:space="preserve">
          <source>In Perl versions 5.6 and earlier the quicksort algorithm was used to implement &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;, but in Perl 5.8 a mergesort algorithm was also made available, mainly to guarantee worst case O(N log N) behaviour: the worst case of quicksort is O(N**2). In Perl 5.8 and later, quicksort defends against quadratic behaviour by shuffling large arrays before sorting.</source>
          <target state="translated">在Perl 5.6版和更早的版本中，使用了quicksort算法来实现 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; ，但是在Perl 5.8中，还提供了mergesort算法，主要是为了确保最差情况下的O（N log N）行为：quicksort的最差情况是O（N N ** 2）。在Perl 5.8和更高版本中，quicksort通过在排序之前对大型数组进行混洗来防御二次行为。</target>
        </trans-unit>
        <trans-unit id="b8d70ec01f0ffe74da5bcdba9c1b84357d80b78c" translate="yes" xml:space="preserve">
          <source>In Perl versions prior to 5.26, this feature enabled declaration of subroutines via &lt;code&gt;my sub foo&lt;/code&gt;, &lt;code&gt;state sub foo&lt;/code&gt; and &lt;code&gt;our sub foo&lt;/code&gt; syntax. See &lt;a href=&quot;perlsub#Lexical-Subroutines&quot;&gt;&quot;Lexical Subroutines&quot; in perlsub&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b481016607f0afb6a75f448e44a95f87a802232" translate="yes" xml:space="preserve">
          <source>In Perl you will get a floating point value if you do one of the following:</source>
          <target state="translated">在Perl中,如果你做了以下操作之一,你将得到一个浮点值。</target>
        </trans-unit>
        <trans-unit id="7d663b5a48798d90608073d23eaf6d6597db1534" translate="yes" xml:space="preserve">
          <source>In Perl, &lt;code&gt;else if&lt;/code&gt; is spelled &lt;code&gt;elsif&lt;/code&gt; .</source>
          <target state="translated">在Perl中， &lt;code&gt;else if&lt;/code&gt; 拼写为 &lt;code&gt;elsif&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a2652823d74ae993d4eef83bf52682f95c98945" translate="yes" xml:space="preserve">
          <source>In Perl, &lt;code&gt;else if&lt;/code&gt; is spelled &lt;code&gt;elsif&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49774beef30ebf83ad6beb68cfd55f59cc0e76e3" translate="yes" xml:space="preserve">
          <source>In Perl, a class is just a package, and methods are just subroutines. Perl doesn't get more formal than that and lets you set up the package just the way that you like it (that is, it doesn't set up anything for you).</source>
          <target state="translated">在Perl中,一个类只是一个包,而方法只是子程序。Perl不会比这更正式,它让你按照自己喜欢的方式来设置包(也就是说,它不会为你设置任何东西)。</target>
        </trans-unit>
        <trans-unit id="983e915935b5fb68c2f1bb82bb4cf04272a6754a" translate="yes" xml:space="preserve">
          <source>In Perl, a sequence of statements that defines a scope is called a block. Sometimes a block is delimited by the file containing it (in the case of a required file, or the program as a whole), and sometimes a block is delimited by the extent of a string (in the case of an eval).</source>
          <target state="translated">在Perl中,定义作用域的语句序列称为块。有时,一个块是以包含它的文件为界(如果是所需的文件,或整个程序),有时,一个块是以字符串的范围为界(如果是eval)。</target>
        </trans-unit>
        <trans-unit id="476c5432e1fcd1b2c55042740329df48b50efcfd" translate="yes" xml:space="preserve">
          <source>In Perl, an object is a blessed reference. The standard way of associating data with an object is to store the data inside the object's body, that is, the piece of data pointed to by the reference.</source>
          <target state="translated">在Perl中,一个对象是一个祝福的引用。将数据与对象关联起来的标准方法是将数据存储在对象的主体内,也就是引用所指向的那块数据。</target>
        </trans-unit>
        <trans-unit id="6459245c83006474d0636721805e8f89399cea54" translate="yes" xml:space="preserve">
          <source>In Perl, any package can be a class. The difference between a package which is a class and one which isn't is based on how the package is used. Here's our &quot;class declaration&quot; for the &lt;code&gt;File&lt;/code&gt; class:</source>
          <target state="translated">在Perl中，任何包都可以是一个类。属于类的包与不属于类的包之间的区别取决于该包的使用方式。这是 &lt;code&gt;File&lt;/code&gt; 类的&amp;ldquo;类声明&amp;rdquo; ：</target>
        </trans-unit>
        <trans-unit id="935b815c5b098d8ca1c1e87b1e728cb47b24fb51" translate="yes" xml:space="preserve">
          <source>In Perl, any value that would look like &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;&quot;0&quot;&lt;/code&gt; if evaluated in a string context. Since undefined values evaluate to &lt;code&gt;&quot;&quot;&lt;/code&gt; , all undefined values are false, but not all false values are undefined.</source>
          <target state="translated">在Perl中，如果在字符串上下文中求值，则任何看起来像 &lt;code&gt;&quot;&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 值。由于未定义的值计算为 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，因此所有未定义的值均为false，但并非所有的false值都未定义。</target>
        </trans-unit>
        <trans-unit id="9c0e1a8a489587a81c3737b4c92da909aea6a8ed" translate="yes" xml:space="preserve">
          <source>In Perl, any value that would look like &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;&quot;0&quot;&lt;/code&gt; if evaluated in a string context. Since undefined values evaluate to &lt;code&gt;&quot;&quot;&lt;/code&gt;, all undefined values are false, but not all false values are undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56beb88cb62afd75b5b76cfb0ba20b6ebe456c89" translate="yes" xml:space="preserve">
          <source>In Perl, binary &lt;code&gt;+&lt;/code&gt; is always addition. &lt;code&gt;$string1 + $string2&lt;/code&gt; converts both strings to numbers and then adds them. To concatenate two strings, use the &lt;code&gt;.&lt;/code&gt; operator.</source>
          <target state="translated">在Perl中，二进制 &lt;code&gt;+&lt;/code&gt; 总是加法。 &lt;code&gt;$string1 + $string2&lt;/code&gt; 将两个字符串都转换为数字，然后将它们相加。要连接两个字符串，请使用 &lt;code&gt;.&lt;/code&gt; 操作员。</target>
        </trans-unit>
        <trans-unit id="45dacae9ba665d20910caab3291e37d91f82dce5" translate="yes" xml:space="preserve">
          <source>In Perl, dynamic scoping refers to the runtime nesting of things like subroutine calls, evals etc, as well as the entering and exiting of block scopes. For example, the restoring of a &lt;code&gt;local&lt;/code&gt;ised variable is determined by the dynamic scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a33a4933eab4c192832e758c7f44c0a0303ba50a" translate="yes" xml:space="preserve">
          <source>In Perl, methods are simply subroutines that live in a class's package. Methods are always written to receive the object as their first argument:</source>
          <target state="translated">在Perl中,方法只是存在于类的包中的子程序。方法的编写总是以接收对象作为其第一个参数。</target>
        </trans-unit>
        <trans-unit id="ea72a9a423acf3df90a345514eea4421a19ceb17" translate="yes" xml:space="preserve">
          <source>In Perl, the debugger is not a separate program the way it usually is in the typical compiled environment. Instead, the &lt;b&gt;-d&lt;/b&gt; flag tells the compiler to insert source information into the parse trees it's about to hand off to the interpreter. That means your code must first compile correctly for the debugger to work on it. Then when the interpreter starts up, it preloads a special Perl library file containing the debugger.</source>
          <target state="translated">在Perl中，调试器不是典型的编译环境中通常所用的独立程序。相反，&lt;b&gt;-d&lt;/b&gt;标志告诉编译器将源信息插入要移交给解释器的解析树中。这意味着您的代码必须首先正确编译，调试器才能对其进行处理。然后，当解释器启动时，它会预加载一个包含调试器的特殊Perl库文件。</target>
        </trans-unit>
        <trans-unit id="3c642476c3d73c23016f66bc533c3f6f2db6cded" translate="yes" xml:space="preserve">
          <source>In Perl, the operator determines what operation is performed, independent of the type of the operands. For example &lt;code&gt;$x + $y&lt;/code&gt; is always a numeric addition, and if &lt;code&gt;$x&lt;/code&gt; or &lt;code&gt;$y&lt;/code&gt; do not contain numbers, an attempt is made to convert them to numbers first.</source>
          <target state="translated">在Perl中，运算符确定执行什么运算，而与操作数的类型无关。例如， &lt;code&gt;$x + $y&lt;/code&gt; 始终是数字加法，如果 &lt;code&gt;$x&lt;/code&gt; 或 &lt;code&gt;$y&lt;/code&gt; 不包含数字，则会尝试首先将它们转换为数字。</target>
        </trans-unit>
        <trans-unit id="05577297c46ae0d2cd55a130e9e49792d0bf233a" translate="yes" xml:space="preserve">
          <source>In Perl, there is no special keyword for constructing an object. However, most OO modules on CPAN use a method named &lt;code&gt;new()&lt;/code&gt; to construct a new object:</source>
          <target state="translated">在Perl中，没有用于构造对象的特殊关键字。但是，CPAN上的大多数OO模块都使用名为 &lt;code&gt;new()&lt;/code&gt; 的方法来构造新对象：</target>
        </trans-unit>
        <trans-unit id="5e186db9710e48217d6288a83b8e0190d6d543fb" translate="yes" xml:space="preserve">
          <source>In Perl, unlike C, a string of characters may generally contain embedded &lt;code&gt;NUL&lt;/code&gt; characters. Sometimes in the documentation a Perl string is referred to as a &quot;buffer&quot; to distinguish it from a C string, but sometimes they are both just referred to as strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4aecd76031e1346a21238102ea29667311ebe2a" translate="yes" xml:space="preserve">
          <source>In Perl, you just can't access memory at random, but the structural and representational conversion provided by &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is an excellent alternative. The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function converts values to a byte sequence containing representations according to a given specification, the so-called &quot;template&quot; argument. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is the reverse process, deriving some values from the contents of a string of bytes. (Be cautioned, however, that not all that has been packed together can be neatly unpacked - a very common experience as seasoned travellers are likely to confirm.)</source>
          <target state="translated">在Perl中，您只是不能随机访问内存，但是 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 提供的结构和表示转换是一个很好的选择。所述 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 函数转换值，以根据给定的规范包含表示一个字节序列，即所谓的&amp;ldquo;模板&amp;rdquo;的说法。 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 是相反的过程，它从一串字节的内容中得出一些值。（但是请注意，并不是所有打包在一起的东西都可以整齐地打包-经验丰富的旅行者很可能会证实这是非常普遍的体验。）</target>
        </trans-unit>
        <trans-unit id="6336086c91498a8e5594063230b55c879e95d340" translate="yes" xml:space="preserve">
          <source>In Perl, you just can't access memory at random, but the structural and representational conversion provided by &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; is an excellent alternative. The &lt;code&gt;pack&lt;/code&gt; function converts values to a byte sequence containing representations according to a given specification, the so-called &quot;template&quot; argument. &lt;code&gt;unpack&lt;/code&gt; is the reverse process, deriving some values from the contents of a string of bytes. (Be cautioned, however, that not all that has been packed together can be neatly unpacked - a very common experience as seasoned travellers are likely to confirm.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a69ee0657acfe60fc783ea37121861ef3e8b2c7" translate="yes" xml:space="preserve">
          <source>In Practice</source>
          <target state="translated">在实践中</target>
        </trans-unit>
        <trans-unit id="eb46744ebe1873e93242a02b5eecee5b509f89c1" translate="yes" xml:space="preserve">
          <source>In Raku, &lt;code&gt;when()&lt;/code&gt; will always do an implicit smartmatch with its argument, while in Perl 5 it is convenient (albeit potentially confusing) to suppress this implicit smartmatch in various rather loosely-defined situations, as roughly outlined above. (The difference is largely because Perl 5 does not have, even internally, a boolean type.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9de61f162399b6dd1501b64047f173f7ebabe0" translate="yes" xml:space="preserve">
          <source>In SVN, $Revision$ should be the same for every file in the project so they would all have the same $VERSION. CVS and RCS have a different $Revision$ per file so each file will have a different $VERSION. Distributed version control systems, such as SVK, may have a different $Revision$ based on who checks out the file, leading to a different $VERSION on each machine! Finally, some distributed version control systems, such as darcs, have no concept of revision number at all.</source>
          <target state="translated">在SVN中,$Revision$对项目中的每个文件都应该是相同的,所以它们都有相同的$VERSION。CVS和RCS的每个文件有不同的$Revision$,所以每个文件将有不同的$VERSION。分布式版本控制系统,如SVK,可能有一个不同的$Revision$根据谁检查出的文件,导致在每台机器上的$VERSION不同!最后,一些分布式版本控制系统,如SVK,可能有一个不同的$Revision$根据谁检查出的文件,导致在每台机器上的$VERSION不同!最后,一些分布式版本控制系统,如SVK,可能有一个不同的$Revision$根据谁检查出的文件,导致在每台机器上的$VERSION不同!最后,一些分布式版本控制系统,如SVK,可能有一个不同的$Revision$根据谁检查出的文件,导致在每台机器上的$VERSION不同!最后,一些分布式版本控制系统,如SVK,可能有一个不同的$Revision$根据谁检查出的文件,导致在每台机器上的$VERSION不同 最后,一些分布式版本控制系统,如darcs,根本没有版本号的概念。</target>
        </trans-unit>
        <trans-unit id="90d2162f62558275ce1491c594305e3a7a9057a0" translate="yes" xml:space="preserve">
          <source>In Settings, add the following Package Sources:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c376db5dd46f66500036f6b8bff5133701d987" translate="yes" xml:space="preserve">
          <source>In SunOS 4.x you most probably want to use the SunOS ld, /usr/bin/ld, since the more recent versions of GNU ld (like 2.13) do not seem to work for building Perl anymore. When linking the extensions, the GNU ld gets very unhappy and spews a lot of errors like this</source>
          <target state="translated">在 SunOS 4.x 中,你可能最想使用 SunOS 的 ld,即 /usr/bin/ld,因为较新版本的 GNU ld(如 2.13)似乎已经不能用于构建 Perl 了。当连接扩展时,GNU ld 会变得非常不高兴,并发出许多错误信息,比如说</target>
        </trans-unit>
        <trans-unit id="6b9fdb7061782483bb0e3d2f43e0f1d23f2b17f3" translate="yes" xml:space="preserve">
          <source>In Taiwan, Japan, and Korea, it is common for text to have a mixture of characters from their native scripts and base Chinese. Perl follows Unicode's UTS 39 (&lt;a href=&quot;https://unicode.org/reports/tr39/&quot;&gt;https://unicode.org/reports/tr39/&lt;/a&gt;) Unicode Security Mechanisms in allowing such mixtures. For example, the Japanese scripts Katakana and Hiragana are commonly mixed together in practice, along with some Chinese characters, and hence are treated as being in a single script run by Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1e3aace4bede70eba3cee6d6eb0864ab35df15" translate="yes" xml:space="preserve">
          <source>In Tru64 Perl is automatically able to use large files, that is, files larger than 2 gigabytes, there is no need to use the Configure -Duselargefiles option as described in INSTALL (though using the option is harmless).</source>
          <target state="translated">在Tru64中Perl是可以自动使用大文件的,也就是大于2千兆字节的文件,没有必要使用INSTALL中描述的Configure -Duselargefiles选项(虽然使用该选项是无害的)。</target>
        </trans-unit>
        <trans-unit id="cc19255447bc355361ae2f45799e7311a851742c" translate="yes" xml:space="preserve">
          <source>In Tru64 Perl's integers are automatically 64-bit wide, there is no need to use the Configure -Duse64bitint option as described in INSTALL. Similarly, there is no need for -Duse64bitall since pointers are automatically 64-bit wide.</source>
          <target state="translated">在 Tru64 Perl 中,整数自动是 64 位宽,因此不需要使用 INSTALL 中描述的 Configure -Duse64bitint 选项。同样地,也不需要使用 -Duse64bitall 选项,因为指针自动是 64 位宽的。</target>
        </trans-unit>
        <trans-unit id="92e8004abe586abe7845a841b1a5b8acbf9b5035" translate="yes" xml:space="preserve">
          <source>In Tru64 V5 (at least V5.1A, V5.1B) you cannot build threaded Perl with gcc because the system header &amp;lt;pthread.h&amp;gt; explicitly checks for supported C compilers, gcc (at least 3.2.2) not being one of them. But the system C compiler should work just fine.</source>
          <target state="translated">在Tru64 V5（至少V5.1A，V5.1B）中，无法使用gcc构建线程化的Perl，因为系统头文件&amp;lt;pthread.h&amp;gt;明确检查受支持的C编译器，gcc（至少3.2.2）不是其中之一。 。但是系统C编译器应该可以正常工作。</target>
        </trans-unit>
        <trans-unit id="6303bf4cf60f3cd73bbb5bee3d92ebf1b27db248" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, it is not guaranteed that the lexer buffer actually contains valid UTF-8. Lexing code must be robust in the face of invalid encoding.</source>
          <target state="translated">在UTF-8模式下,并不能保证词典缓冲区实际包含有效的UTF-8。在面对无效编码的情况下,词法代码必须是稳健的。</target>
        </trans-unit>
        <trans-unit id="5587dff620034120288215aaa5eec31db833ac28" translate="yes" xml:space="preserve">
          <source>In Unicode 4.1.0, the definition D2 of canonical composition (which affects NFC and NFKC) has been changed (see Public Review Issue #29 and recent UAX #15). This module has used the newer definition since the version 0.07 (Oct 31, 2001). This module will not support the normalization according to the older definition, even if the Unicode version implemented by perl is lower than 4.1.0.</source>
          <target state="translated">在Unicode 4.1.0中,规范构成的D2定义(影响NFC和NFKC)已被修改(见公共评论问题#29和最近的UAX#15)。这个模块从0.07版本(2001年10月31日)开始就使用了新的定义。即使perl实现的Unicode版本低于4.1.0,本模块也不支持按照旧定义进行规范化。</target>
        </trans-unit>
        <trans-unit id="4add5639cbd0356c9e63afa54113a4c2eb6433cf" translate="yes" xml:space="preserve">
          <source>In Unicode terminology a</source>
          <target state="translated">在Unicode术语中,一个</target>
        </trans-unit>
        <trans-unit id="f8ecaf55c52d72cac38172d4d214a7acd326645e" translate="yes" xml:space="preserve">
          <source>In Unicode, not just characters with the General Category of Lowercase Letter, but any character with the Lowercase property, including Modifier Letters, Letter Numbers, some Other Symbols, and one Combining Mark.</source>
          <target state="translated">在Unicode中,不仅仅是小写字母一般类别的字符,而是任何具有小写属性的字符,包括修饰字母、字母数字、一些其他符号和一个组合标记。</target>
        </trans-unit>
        <trans-unit id="6d6e7c6b62a7207f53debc7941773b1adb72b5b5" translate="yes" xml:space="preserve">
          <source>In Unicode, not just characters with the General Category of Uppercase Letter, but any character with the Uppercase property, including some Letter Numbers and Symbols. Not to be confused with &lt;b&gt;titlecase&lt;/b&gt;.</source>
          <target state="translated">在Unicode中，不仅具有大写字母常规类别的字符，而且具有大写字母属性的任何字符，包括一些字母数字和符号。不要与&lt;b&gt;titlecase&lt;/b&gt;混淆。</target>
        </trans-unit>
        <trans-unit id="b113bf75921160dcb55ede1f720912618b376337" translate="yes" xml:space="preserve">
          <source>In Unix, a sequence of zero or more nonnewline characters terminated with a &lt;b&gt;newline&lt;/b&gt; character. On non-Unix machines, this is emulated by the C library even if the underlying &lt;b&gt;operating system&lt;/b&gt; has different ideas.</source>
          <target state="translated">在Unix中，零个或多个非&lt;b&gt;换行&lt;/b&gt;字符序列以&lt;b&gt;换行符&lt;/b&gt;终止。在非Unix机器上，即使底层&lt;b&gt;操作系统&lt;/b&gt;有不同的想法，也可以由C库来模拟。</target>
        </trans-unit>
        <trans-unit id="1bf9694eb8cd962c6afbe1434566f7218f970b1f" translate="yes" xml:space="preserve">
          <source>In Windows platforms, &lt;code&gt;$^O&lt;/code&gt; is not very helpful: since it is always &lt;code&gt;MSWin32&lt;/code&gt; , it doesn't tell the difference between 95/98/ME/NT/2000/XP/CE/.NET. Use &lt;code&gt;Win32::GetOSName()&lt;/code&gt; or Win32::GetOSVersion() (see &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt; and &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;) to distinguish between the variants.</source>
          <target state="translated">在Windows平台上， &lt;code&gt;$^O&lt;/code&gt; 并不是很有帮助：由于它始终是 &lt;code&gt;MSWin32&lt;/code&gt; ，因此无法区分95/98 / ME / NT / 2000 / XP / CE / .NET。使用 &lt;code&gt;Win32::GetOSName()&lt;/code&gt; 或Win32 :: GetOSVersion（）（请参阅&lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt;和&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;）来区分这些变体。</target>
        </trans-unit>
        <trans-unit id="571c9a8187f8f9b92939078e49787860d6c5b703" translate="yes" xml:space="preserve">
          <source>In Windows platforms, &lt;code&gt;$^O&lt;/code&gt; is not very helpful: since it is always &lt;code&gt;MSWin32&lt;/code&gt;, it doesn't tell the difference between 95/98/ME/NT/2000/XP/CE/.NET. Use &lt;code&gt;Win32::GetOSName()&lt;/code&gt; or Win32::GetOSVersion() (see &lt;a href=&quot;win32&quot;&gt;Win32&lt;/a&gt; and &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;) to distinguish between the variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91f9d78321013250cfcb8d441316ea8cae8423a1" translate="yes" xml:space="preserve">
          <source>In XS code, use of &lt;code&gt;to_utf8_case()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab390a067e67919faf228f1feaba13aa8739d9a5" translate="yes" xml:space="preserve">
          <source>In XS code, use of to_utf8_case()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="864cceec0c178a3fbde977cff7807849ea71044b" translate="yes" xml:space="preserve">
          <source>In XS code, use of various macros dealing with UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8d2f9cdc2abce1c37c00210e5a99994671e5e54" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt; code, text may contain formatting codes for formatting or for E&amp;lt;...&amp;gt; escapes, as in:</source>
          <target state="translated">在 &lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt; 代码中，文本可能包含用于格式化或E &amp;lt;...&amp;gt;转义的格式化代码，如下所示：</target>
        </trans-unit>
        <trans-unit id="282340f2a1ffb453132562968ecc8729e762ed24" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loop, &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;eof(ARGV)&lt;/code&gt; can be used to detect the end of each file, whereas &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof()&lt;/code&gt;&lt;/a&gt; will detect the end of the very last file only. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e19714f7b922e3746b1633bf7eecd4c7104aed" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loop, &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; can be used to detect the end of each file, whereas &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; will detect the end of the very last file only. Examples:</source>
          <target state="translated">在 &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; 循环中，可以使用 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; 检测每个文件的结尾，而 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 仅检测最后一个文件的结尾。例子：</target>
        </trans-unit>
        <trans-unit id="41690d136fbd264eb140c8b8c6cc615177c5eb14" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loop, &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; can be used to detect the end of each file, whereas &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; will detect the end of the very last file only. Examples:</source>
          <target state="translated">在 &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; 循环中，可以使用 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; 检测每个文件的结尾，而 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 仅检测最后一个文件的结尾。例子：</target>
        </trans-unit>
        <trans-unit id="bc099e33e27d3f3cccb59648c75894207f5a15fa" translate="yes" xml:space="preserve">
          <source>In a Perl built for debugging, some buckets may have negative usable size. This means that these buckets cannot (and will not) be used. For larger buckets, the memory footprint may be one page greater than a power of 2. If so, the corresponding power of two is printed in the &lt;code&gt;APPROX&lt;/code&gt; field above.</source>
          <target state="translated">在为调试而构建的Perl中，某些存储桶可能具有负的可用大小。这意味着这些存储桶不能（也不会）被使用。对于较大的存储桶，内存占用量可能比2的幂大1页。如果是，则在上面的 &lt;code&gt;APPROX&lt;/code&gt; 字段中打印相应的2幂。</target>
        </trans-unit>
        <trans-unit id="9d530f843344f7a394d5586d561f13c274faa0f4" translate="yes" xml:space="preserve">
          <source>In a Perl version number such as 5.6.2, this is the 2. Values greater than 50 represent potentially unstable development subversions. This value is manually set in</source>
          <target state="translated">在Perl的版本号中,比如5.6.2,这个值是2,大于50的值代表潜在的不稳定的开发subversion。这个值是在</target>
        </trans-unit>
        <trans-unit id="0f808181882ea1893d708887496cf67865ae159d" translate="yes" xml:space="preserve">
          <source>In a Perl version number such as 5.6.2, this is the 5. This value is manually set in</source>
          <target state="translated">在Perl的版本号中,比如5.6.2,就是5,这个值是在</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
