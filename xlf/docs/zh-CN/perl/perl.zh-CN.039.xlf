<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="40a3c4882101734d96d5257d2a74ae5e78eaf3de" translate="yes" xml:space="preserve">
          <source>Taint Mode</source>
          <target state="translated">污染模式</target>
        </trans-unit>
        <trans-unit id="f63611c6fa286ffcd2142b28c1284de824194c00" translate="yes" xml:space="preserve">
          <source>Taint an SV. Use &lt;code&gt;SvTAINTED_on&lt;/code&gt; instead.</source>
          <target state="translated">污染SV。请改用 &lt;code&gt;SvTAINTED_on&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="413e513edb03310442a1614d65a7d4ad85d457e0" translate="yes" xml:space="preserve">
          <source>Taint checking is most useful when although you trust yourself not to have written a program to give away the farm, you don't necessarily trust those who end up using it not to try to trick it into doing something bad. This is the kind of security checking that's useful for set-id programs and programs launched on someone else's behalf, like CGI programs.</source>
          <target state="translated">污点检查最有用的情况是,虽然你相信自己没有写出一个程序来送农场,但你不一定相信那些最终使用它的人不会试图欺骗它去做一些坏事。这类安全检查对于设定好的程序和以别人的名义启动的程序,比如CGI程序,是很有用的。</target>
        </trans-unit>
        <trans-unit id="88ab9771610a9a442e0329746e6647da7d9f316c" translate="yes" xml:space="preserve">
          <source>Taint mode</source>
          <target state="translated">污染模式</target>
        </trans-unit>
        <trans-unit id="504eb6d55f3dd75624d53392fb2ec7ee299aa14f" translate="yes" xml:space="preserve">
          <source>Taint mode and @INC</source>
          <target state="translated">污染模式和@INC</target>
        </trans-unit>
        <trans-unit id="d6624f88ac2856ed8ccebfe23a63eebf43e447bd" translate="yes" xml:space="preserve">
          <source>Tainting is also likely if the pattern is to be matched case-insensitively (via &lt;code&gt;/i&lt;/code&gt;). The exception is if all the code points to be matched this way are above 255 and do not have folds under Unicode rules to below 256. Tainting is not done for these because Perl only uses Unicode rules for such code points, and those rules are the same no matter what the current locale.</source>
          <target state="translated">如果要不区分大小写地匹配模式（通过 &lt;code&gt;/i&lt;/code&gt; ），也可能会出现污点。唯一的例外是，如果所有要以此方式匹配的代码点都在255以上，并且在Unicode规则下没有折叠到256以下。由于Perl仅对此类代码点使用Unicode规则，因此不对此进行着色。无论当前语言环境如何，都一样。</target>
        </trans-unit>
        <trans-unit id="b1e437790166193a4c207aa58d0fb3a4d2a31ed7" translate="yes" xml:space="preserve">
          <source>Taints an SV if tainting is enabled, and if some input to the current expression is tainted--usually a variable, but possibly also implicit inputs such as locale settings. &lt;code&gt;SvTAINT&lt;/code&gt; propagates that taintedness to the outputs of an expression in a pessimistic fashion; i.e., without paying attention to precisely which outputs are influenced by which inputs.</source>
          <target state="translated">如果启用了污点并且对当前表达式的某些输入被污点（通常是变量），但也可能隐式输入（例如语言环境设置），会污染SV。 &lt;code&gt;SvTAINT&lt;/code&gt; 以悲观的方式将这种污点传播到表达式的输出中。即，无需精确注意哪些输出受哪些输入影响。</target>
        </trans-unit>
        <trans-unit id="750e96a06b9d3c66d6ca7a66a25a581164f0d409" translate="yes" xml:space="preserve">
          <source>Taiwan-based Chinese Encodings</source>
          <target state="translated">台湾中文编码</target>
        </trans-unit>
        <trans-unit id="5a5b403505c94cab4e9f224e4af932dc5aa9d4c7" translate="yes" xml:space="preserve">
          <source>Take a look at &lt;a href=&quot;#Good-Practices&quot;&gt;Good Practices&lt;/a&gt; for some variants you will like to use in modern Perl code.</source>
          <target state="translated">查看一些您希望在现代Perl代码中使用的变体的&lt;a href=&quot;#Good-Practices&quot;&gt;良好实践&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e2b74024aba36db1a23fa804fd1c560d6088d9a" translate="yes" xml:space="preserve">
          <source>Take a sprintf-style format pattern and argument list. These are used to generate a string message. If the message does not end with a newline, then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;mess_sv&lt;/a&gt;.</source>
          <target state="translated">采用sprintf样式的格式模式和参数列表。这些用于生成字符串消息。如果消息不是以换行符结尾，则将使用代码中当前位置的某种指示来对其进行扩展，如&lt;a href=&quot;#mess_sv&quot;&gt;mess_sv所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb04817116fcc4f36afb8949c5edb0a2147a3489" translate="yes" xml:space="preserve">
          <source>Take care when changing a released module.</source>
          <target state="translated">更换已发布的模块时要注意。</target>
        </trans-unit>
        <trans-unit id="fcbbed68b647be19cced53ca66bc41d5fb7b63bd" translate="yes" xml:space="preserve">
          <source>Take care when using this function simply as a truth test (such as in &lt;code&gt;&lt;a href=&quot;../functions/if&quot;&gt;if&lt;/a&gt;(blessed $ref)...&lt;/code&gt; ) because the package name &lt;code&gt;&quot;0&quot;&lt;/code&gt; is defined yet false.</source>
          <target state="translated">在将此函数仅用作真值测试时（例如，在 &lt;code&gt;&lt;a href=&quot;../functions/if&quot;&gt;if&lt;/a&gt;(blessed $ref)...&lt;/code&gt; ），请小心，因为已定义包名称 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 但为false。</target>
        </trans-unit>
        <trans-unit id="c4c196051206e9d1dadde68b1305cdecd7c48024" translate="yes" xml:space="preserve">
          <source>Take the example case of trying to split a string that is comma-separated into its different fields. You can't use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split(/,/)&lt;/a&gt;&lt;/code&gt; because you shouldn't split if the comma is inside quotes. For example, take a data line like this:</source>
          <target state="translated">以尝试将以逗号分隔的字符串拆分为不同字段的示例为例。您不能使用 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split(/,/)&lt;/a&gt;&lt;/code&gt; ,因为如果逗号在引号内，则不应拆分。例如，采用如下数据线：</target>
        </trans-unit>
        <trans-unit id="4471e2b4acce8ca9f0f3bc156ed9ea2897b12f89" translate="yes" xml:space="preserve">
          <source>Take the opportunity to reconsider and redesign the interfaces.</source>
          <target state="translated">借此机会,重新考虑并重新设计接口。</target>
        </trans-unit>
        <trans-unit id="891afd1ff7caaa23526c0cd4250f4fb5063fe719" translate="yes" xml:space="preserve">
          <source>Taken together, these features go a long way towards making Perl's regular expressions more readable. Here's an example:</source>
          <target state="translated">总的来说,这些特性对提高Perl的正则表达式的可读性有很大的帮助。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="d4622f933170417209394d51b607728c20fb64f4" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_in6&lt;/code&gt; structure. Returns a list of four elements: the port number, an opaque string representing the IPv6 address, the scope ID, and the flow label. (You can use inet_ntop() to convert the address to the usual string format). Will croak if the structure does not represent an &lt;code&gt;AF_INET6&lt;/code&gt; address.</source>
          <target state="translated">采用 &lt;code&gt;sockaddr_in6&lt;/code&gt; 结构。返回四个元素的列表：端口号，代表IPv6地址的不透明字符串，作用域ID和流标签。（您可以使用inet_ntop（）将地址转换为通常的字符串格式）。如果结构不代表 &lt;code&gt;AF_INET6&lt;/code&gt; 地址，则会发出嘶哑的声音。</target>
        </trans-unit>
        <trans-unit id="8ffd8f37fe17f4475f9ac3335803a5668dd9a5a9" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_in&lt;/code&gt; structure (as returned by pack_sockaddr_in(), getpeername() or recv()). Returns a list of two elements: the port and an opaque string representing the IP address (you can use inet_ntoa() to convert the address to the four-dotted numeric format). Will croak if the structure does not represent an &lt;code&gt;AF_INET&lt;/code&gt; address.</source>
          <target state="translated">采用 &lt;code&gt;sockaddr_in&lt;/code&gt; 结构（由pack_sockaddr_in（），getpeername（）或recv（）返回）。返回两个元素的列表：端口和代表IP地址的不透明字符串（可以使用inet_ntoa（）将地址转换为四点数字格式）。如果结构不代表 &lt;code&gt;AF_INET&lt;/code&gt; 地址，则会发出嘶哑的声音。</target>
        </trans-unit>
        <trans-unit id="0d55a321d267dd95843d2a82446b8e074d9b4482" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_un&lt;/code&gt; structure (as returned by pack_sockaddr_un(), getpeername() or recv()). Returns a list of one element: the pathname. Will croak if the structure does not represent an &lt;code&gt;AF_UNIX&lt;/code&gt; address.</source>
          <target state="translated">采用 &lt;code&gt;sockaddr_un&lt;/code&gt; 结构（由pack_sockaddr_un（），getpeername（）或recv（）返回）。返回一个元素的列表：路径名。如果结构不代表 &lt;code&gt;AF_UNIX&lt;/code&gt; 地址，则会发出嘶哑的声音。</target>
        </trans-unit>
        <trans-unit id="b39b8aaa0796e13f2d536ba4ee5000dfd3368b8e" translate="yes" xml:space="preserve">
          <source>Takes a LIST of values and converts it into a string using the rules given by the TEMPLATE. The resulting string is the concatenation of the converted values. Typically, each converted value looks like its machine-level representation. For example, on 32-bit machines an integer may be represented by a sequence of 4 bytes, which will in Perl be presented as a string that's 4 characters long.</source>
          <target state="translated">获取一个值的LIST,并使用TEMPLATE给出的规则将其转换为字符串。转换后的字符串是转换后的值的连接。通常情况下,每个转换后的值看起来像它的机器级表示。例如,在32位的机器上,一个整数可以用4个字节的序列来表示,在Perl中,它将以一个4个字符长的字符串来表示。</target>
        </trans-unit>
        <trans-unit id="5bea2fb93e96bf3299efd7e7cc45533fa8e0d5df" translate="yes" xml:space="preserve">
          <source>Takes a destination path and an optional base path and returns a relative path from the base path to the destination path:</source>
          <target state="translated">取一个目标路径和一个可选的基本路径,并返回一个从基本路径到目标路径的相对路径。</target>
        </trans-unit>
        <trans-unit id="95774c404168139c6e80f1611020974553158f89" translate="yes" xml:space="preserve">
          <source>Takes a destination path and an optional base path returns a relative path from the base path to the destination path:</source>
          <target state="translated">取一个目标路径和一个可选的基本路径,返回一个从基本路径到目标路径的相对路径。</target>
        </trans-unit>
        <trans-unit id="d94b0d11d4ec10ac5d773f5e69a50730359dca25" translate="yes" xml:space="preserve">
          <source>Takes a filename, a scalar full of data and optionally a reference to a hash with specific options.</source>
          <target state="translated">取一个文件名,一个充满数据的标量和一个带有特定选项的哈希引用。</target>
        </trans-unit>
        <trans-unit id="ef9cdc80b0d99b082834a1fbb8d5a11a97402e97" translate="yes" xml:space="preserve">
          <source>Takes a list of capabilities as an argument and will croak if one is not found.</source>
          <target state="translated">以能力列表作为参数,如果没有找到能力列表,就会崩溃。</target>
        </trans-unit>
        <trans-unit id="2eadd3f3ba856c4409ed2499d0a3d0b488f0dfce" translate="yes" xml:space="preserve">
          <source>Takes a list of filenames and adds them to the in-memory archive.</source>
          <target state="translated">读取文件名列表,并将其添加到内存存档中。</target>
        </trans-unit>
        <trans-unit id="f1b41457fa3731d32047968d9b9c24bbf39e5764" translate="yes" xml:space="preserve">
          <source>Takes a module name as an argument, returns the first perl version by release date where that module was removed from core. Returns undef if the given module was never in core or remains in core.</source>
          <target state="translated">以模块名作为参数,返回该模块从core中删除的第一个perl版本的发布日期。如果给定的模块从未在core中出现过或者仍然在core中,则返回undef。</target>
        </trans-unit>
        <trans-unit id="f46e15336d9744fdb143311ac69c4190fa941309" translate="yes" xml:space="preserve">
          <source>Takes a module name as an argument, returns the first perl version where that module was removed from core. Returns undef if the given module was never in core or remains in core.</source>
          <target state="translated">以模块名作为参数,返回该模块从core中删除的第一个perl版本。如果给定的模块从未在core中出现过或者仍然在core中,则返回undef。</target>
        </trans-unit>
        <trans-unit id="b0cf83e512f827739a6bf491886eab3446e0a621" translate="yes" xml:space="preserve">
          <source>Takes a number, the value of the array base $[. Cannot be non-zero on Perl 5.15.3 or later.</source>
          <target state="translated">取一个数字,即数组基数$[.]的值。在Perl 5.15.3或更高版本中不能为非零。</target>
        </trans-unit>
        <trans-unit id="5735d53ded3f64fc817f32e6801f9c3332c8c742" translate="yes" xml:space="preserve">
          <source>Takes a packed binary address structure such as returned by unpack_sockaddr_in() (or a v-string representing the four octets of the IPv4 address in network order) and translates it into a string of the form &lt;code&gt;d.d.d.d&lt;/code&gt; where the &lt;code&gt;d&lt;/code&gt; s are numbers less than 256 (the normal human-readable four dotted number notation for Internet addresses).</source>
          <target state="translated">采用打包的二进制地址结构（例如unpack_sockaddr_in（）返回的值）（或按网络顺序表示IPv4地址的四个八位字节的v字符串），并将其转换为 &lt;code&gt;d.d.d.d&lt;/code&gt; 形式的字符串，其中 &lt;code&gt;d&lt;/code&gt; 是小于256的数字（互联网地址的普通人类可读的四点数字符号）。</target>
        </trans-unit>
        <trans-unit id="1a2abe4e916de97dcbd3a2d8761e95258307eb47" translate="yes" xml:space="preserve">
          <source>Takes a packed socket address (as returned by pack_sockaddr_in(), pack_sockaddr_un() or the perl builtin functions getsockname() and getpeername()). Returns the address family tag. This will be one of the &lt;code&gt;AF_*&lt;/code&gt; constants, such as &lt;code&gt;AF_INET&lt;/code&gt; for a &lt;code&gt;sockaddr_in&lt;/code&gt; addresses or &lt;code&gt;AF_UNIX&lt;/code&gt; for a &lt;code&gt;sockaddr_un&lt;/code&gt; . It can be used to figure out what unpack to use for a sockaddr of unknown type.</source>
          <target state="translated">接受一个压缩的套接字地址（由pack_sockaddr_in（），pack_sockaddr_un（）或perl内置函数getockname（）和getpeername（）返回）。返回地址族标签。这将是 &lt;code&gt;AF_*&lt;/code&gt; 常量之一，例如 &lt;code&gt;AF_INET&lt;/code&gt; 用于 &lt;code&gt;sockaddr_in&lt;/code&gt; 地址，或者 &lt;code&gt;AF_UNIX&lt;/code&gt; 用于 &lt;code&gt;sockaddr_un&lt;/code&gt; 。它可以用来找出对未知类型的sockaddr使用什么解压缩。</target>
        </trans-unit>
        <trans-unit id="a13e8e801bfdc18ca93880299add6c6b51640d38" translate="yes" xml:space="preserve">
          <source>Takes a path to a file or dir and returns an empty string if we don't want to include this file in the library. Otherwise it returns the the $path unchanged.</source>
          <target state="translated">取一个文件或目录的路径,如果我们不想将这个文件包含在库中,则返回一个空字符串。否则,它将返回$path,保持不变。</target>
        </trans-unit>
        <trans-unit id="5857a3f9b8ca80529d602d68d365fa9061a89d78" translate="yes" xml:space="preserve">
          <source>Takes a perl version as an argument. Returns that perl version if it exists or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">以perl版本作为参数。返回该perl版本（如果存在），否则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40ef5af0a7a23fbe908b8c6d6bfe7afebb158b73" translate="yes" xml:space="preserve">
          <source>Takes a quoted regular expression produced by &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, or a string representing a regular expression.</source>
          <target state="translated">接受由 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 产生的带引号的正则表达式，或代表正则表达式的字符串。</target>
        </trans-unit>
        <trans-unit id="9f021fc102096073a09c0f85c8e63b62bb7905ee" translate="yes" xml:space="preserve">
          <source>Takes a reference to any Perl value, and turns the referred-to value into an object in the appropriate B::OP-derived or B::SV-derived class. Apart from functions such as &lt;code&gt;main_root&lt;/code&gt; , this is the primary way to get an initial &quot;handle&quot; on an internal perl data structure which can then be followed with the other access methods.</source>
          <target state="translated">引用任何Perl值，并将引用的值转换为相应的B :: OP派生或B :: SV派生类中的对象。除了诸如 &lt;code&gt;main_root&lt;/code&gt; 之类的函数外，这是在内部perl数据结构上获取初始&amp;ldquo;句柄&amp;rdquo;的主要方法，然后可以使用其他访问方法。</target>
        </trans-unit>
        <trans-unit id="e41f495e23e8b7129fbf9bc3a9bb6ededd8628d3" translate="yes" xml:space="preserve">
          <source>Takes a regex as an argument, returns a list of modules that match the regex given. If only a regex is provided applies to all modules in all perl versions. Optionally you may provide a list of perl versions to limit the regex search.</source>
          <target state="translated">以一个regex作为参数,返回一个与给定的regex匹配的模块列表。如果只提供一个regex,则适用于所有perl版本的所有模块。你也可以提供一个perl版本的列表来限制regex的搜索。</target>
        </trans-unit>
        <trans-unit id="4409b17c674e2781e58d19f638d2dce9b604b410" translate="yes" xml:space="preserve">
          <source>Takes a sprintf-style format pattern and conventional (non-SV) arguments and returns the formatted string.</source>
          <target state="translated">取一个sprintf风格的格式模式和常规(非SV)参数,并返回格式化的字符串。</target>
        </trans-unit>
        <trans-unit id="33c7557687a090fd43bd56b07499b14fc80993e2" translate="yes" xml:space="preserve">
          <source>Takes a string giving the name of a host, or a textual representation of an IP address and translates that to an packed binary address structure suitable to pass to pack_sockaddr_in(). If passed a hostname that cannot be resolved, returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. For multi-homed hosts (hosts with more than one address), the first address found is returned.</source>
          <target state="translated">接受一个字符串，该字符串给出主机名或IP地址的文本表示形式，并将其转换为适合传递给pack_sockaddr_in（）的压缩二进制地址结构。如果传递了无法解析的主机名，则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。对于多宿主主机（具有多个地址的主机），将返回找到的第一个地址。</target>
        </trans-unit>
        <trans-unit id="1f86839b95b2c7ce0cd8df0fd7189ee9fa362403" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing a whitespace-separated list of values. The values &quot;all&quot; and &quot;none&quot; are special, again. It's also permissible to pass an array reference here.</source>
          <target state="translated">取一个字符串,可能包含一个用空格分隔的值列表。同样,&quot;all &quot;和 &quot;none &quot;是特殊值。这里也允许传递一个数组引用。</target>
        </trans-unit>
        <trans-unit id="4925dcea23e5ae74b5fce407317c9fa3709b6b25" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing a whitespace-separated list of values. The values &quot;all&quot; and &quot;none&quot; are special. It's also permissible to pass an array reference here.</source>
          <target state="translated">取一个字符串,可能包含一个用空格分隔的值列表。&quot;all &quot;和 &quot;none &quot;是特殊值。这里也允许传递一个数组引用。</target>
        </trans-unit>
        <trans-unit id="90662514b3c1c8b5cad150f77c448383f9911cee" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing several values separated by whitespace. The special values &quot;all&quot; and &quot;none&quot; mean what you'd expect.</source>
          <target state="translated">取一个字符串,可能包含几个用空格分隔的值。特殊值 &quot;all &quot;和 &quot;none &quot;的意思是你所期望的。</target>
        </trans-unit>
        <trans-unit id="8b8cbc4c6f861e88e0cc4c3970f3d7711c8f40ee" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ip_mreq&lt;/code&gt; structure. Returns a list of two elements; the IPv4 multicast address and interface address.</source>
          <target state="translated">采用 &lt;code&gt;ip_mreq&lt;/code&gt; 结构。返回两个元素的列表；IPv4组播地址和接口地址。</target>
        </trans-unit>
        <trans-unit id="04696d2255aec363ebf123f1adcef127402d7fca" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ip_mreq_source&lt;/code&gt; structure. Returns a list of three elements; the IPv4 multicast address, source address and interface address.</source>
          <target state="translated">采用 &lt;code&gt;ip_mreq_source&lt;/code&gt; 结构。返回三个元素的列表；IPv4组播地址，源地址和接口地址。</target>
        </trans-unit>
        <trans-unit id="8895fb55870fc5cb5b67d2b6b1ab10511fd087e6" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ipv6_mreq&lt;/code&gt; structure. Returns a list of two elements; the IPv6 address and an interface number.</source>
          <target state="translated">采用 &lt;code&gt;ipv6_mreq&lt;/code&gt; 结构。返回两个元素的列表；IPv6地址和接口号。</target>
        </trans-unit>
        <trans-unit id="ad12a7e2dccc21686af63739f893c4d2a53e4c04" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt; ). Returns the &lt;code&gt;ip_mreq&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="translated">接受一个I​​Pv4组播地址和一个可选的接口地址（或 &lt;code&gt;INADDR_ANY&lt;/code&gt; ）。返回带有这些参数的 &lt;code&gt;ip_mreq&lt;/code&gt; 结构。适用于 &lt;code&gt;IP_ADD_MEMBERSHIP&lt;/code&gt; 和 &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; sockopts。</target>
        </trans-unit>
        <trans-unit id="e80cd3ce1fd8acb10289fb4bd58c0849f55a8d71" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address, source address, and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt; ). Returns the &lt;code&gt;ip_mreq_source&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_SOURCE_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_SOURCE_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="translated">接受一个I​​Pv4组播地址，源地址，以及一个可选的接口地址（或 &lt;code&gt;INADDR_ANY&lt;/code&gt; ）。返回带有这些参数的 &lt;code&gt;ip_mreq_source&lt;/code&gt; 结构。适用于 &lt;code&gt;IP_ADD_SOURCE_MEMBERSHIP&lt;/code&gt; 和 &lt;code&gt;IP_DROP_SOURCE_MEMBERSHIP&lt;/code&gt; sockopts。</target>
        </trans-unit>
        <trans-unit id="414f4fb4a3a1f32b47a120675c30046be162adca" translate="yes" xml:space="preserve">
          <source>Takes an IPv6 multicast address and an interface number. Returns the &lt;code&gt;ipv6_mreq&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IPV6_ADD_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IPV6_DROP_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="translated">获取IPv6组播地址和接口号。返回带有那些参数的 &lt;code&gt;ipv6_mreq&lt;/code&gt; 结构。适用于 &lt;code&gt;IPV6_ADD_MEMBERSHIP&lt;/code&gt; 和 &lt;code&gt;IPV6_DROP_MEMBERSHIP&lt;/code&gt; sockopts。</target>
        </trans-unit>
        <trans-unit id="84da4affe0802d1076fb7e8fa5b5ab6e38634ce8" translate="yes" xml:space="preserve">
          <source>Takes an address family (such as &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;AF_INET6&lt;/code&gt; ) and a string containing a textual representation of an address in that family and translates that to an packed binary address structure.</source>
          <target state="translated">接受一个地址族（例如 &lt;code&gt;AF_INET&lt;/code&gt; 或 &lt;code&gt;AF_INET6&lt;/code&gt; ）和一个包含该族中地址的文本表示形式的字符串，并将其转换为压缩的二进制地址结构。</target>
        </trans-unit>
        <trans-unit id="185fc4d2aaf4353f2b2708aa34a24508e0a971cd" translate="yes" xml:space="preserve">
          <source>Takes an address family and a packed binary address structure and translates it into a human-readable textual representation of the address; typically in &lt;code&gt;d.d.d.d&lt;/code&gt; form for &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;hhhh:hhhh::hhhh&lt;/code&gt; form for &lt;code&gt;AF_INET6&lt;/code&gt; .</source>
          <target state="translated">采用地址族和压缩的二进制地址结构，并将其转换为地址的人类可读文本表示形式；通常 &lt;code&gt;d.d.d.d&lt;/code&gt; 形式 &lt;code&gt;AF_INET&lt;/code&gt; 或 &lt;code&gt;hhhh:hhhh::hhhh&lt;/code&gt; 的形式 &lt;code&gt;AF_INET6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e77ed8250b0ab9eed8ffd2c4c006ad06b6129f6" translate="yes" xml:space="preserve">
          <source>Takes an array of items and turns them into a well-formatted list of arguments. In most cases this is simply something like:</source>
          <target state="translated">将一个项目数组转化为一个格式良好的参数列表。在大多数情况下,这只是一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="21d2a6e85e05ac293f43bf0aadd4c7b6d2f0e70c" translate="yes" xml:space="preserve">
          <source>Takes as argument a path and returns true if it is an absolute path.</source>
          <target state="translated">将一个路径作为参数,如果是绝对路径则返回true。</target>
        </trans-unit>
        <trans-unit id="6dc3e333ed2be58598d7c496ec3d73ebab444c2b" translate="yes" xml:space="preserve">
          <source>Takes as argument a path and returns true, if it is an absolute path. If the path has a leading &quot;:&quot;, it's a relative path. Otherwise, it's an absolute path, unless the path doesn't contain any colons, i.e. it's a name like &quot;a&quot;. In this particular case, the path is considered to be relative (i.e. it is considered to be a filename). Use &quot;:&quot; in the appropriate place in the path if you want to distinguish unambiguously. As a special case, the filename '' is always considered to be absolute. Note that with version 1.2 of File::Spec::Mac, this does no longer consult the local filesystem.</source>
          <target state="translated">取一个路径作为参数,如果是绝对路径,则返回true。如果路径前面有&quot;:&quot;,则是相对路径。否则,就是绝对路径,除非路径中不包含任何冒号,也就是像 &quot;a &quot;这样的名字。在这种特殊情况下,路径被认为是相对的(即它被认为是一个文件名)。如果你想毫不含糊地区分,请在路径的适当位置使用&quot;:&quot;。作为一种特殊情况,文件名''总是被认为是绝对的。请注意,在 File::Spec::Mac 的 1.2 版本中,它不再咨询本地文件系统。</target>
        </trans-unit>
        <trans-unit id="f927c21bb3e3c4ff729f953eef64006ef1f031a9" translate="yes" xml:space="preserve">
          <source>Takes as arguments a directory name and a regular expression. Returns all entries in the directory that match the regular expression.</source>
          <target state="translated">以一个目录名和一个正则表达式作为参数。返回目录中所有符合正则表达式的条目。</target>
        </trans-unit>
        <trans-unit id="6047190e6cf9ba865c7d15a28d5823f107249805" translate="yes" xml:space="preserve">
          <source>Takes as its argument a path, and returns true if it is an absolute path.</source>
          <target state="translated">将一个路径作为参数,如果是绝对路径则返回true。</target>
        </trans-unit>
        <trans-unit id="29d3a8d482e59f44bd119209a124f4322f931d36" translate="yes" xml:space="preserve">
          <source>Takes no argument, returns the environment variable PATH as an array.</source>
          <target state="translated">不取参数,以数组形式返回环境变量PATH。</target>
        </trans-unit>
        <trans-unit id="fabbbd7a986855e1324a147a7f7a2a0ae979a9a1" translate="yes" xml:space="preserve">
          <source>Takes no argument. Returns the environment variable &lt;code&gt;PATH&lt;/code&gt; (or the local platform's equivalent) as a list.</source>
          <target state="translated">不用争论。以列表形式返回环境变量 &lt;code&gt;PATH&lt;/code&gt; （或本地平台的等效变量）。</target>
        </trans-unit>
        <trans-unit id="904758c12da1c3cf57f2a62e3976ec89f757603e" translate="yes" xml:space="preserve">
          <source>Takes one argument ( 'stdin' | 'stdout' | 'stderr' ) and returns true if the IoIFP of the object is equal to the handle whose name was passed as argument; i.e., $io-&amp;gt;IsSTD('stderr') is true if IoIFP($io) == PerlIO_stderr().</source>
          <target state="translated">接受一个参数（'stdin'|'stdout'|'stderr'），如果对象的IoIFP等于其名称作为参数传递的句柄，则返回true；否则，返回true。即，如果IoIFP（$ io）== PerlIO_stderr（），则$ io-&amp;gt; IsSTD（'stderr'）为true。</target>
        </trans-unit>
        <trans-unit id="2250c086cb14652296208baa0752736a068d5cdd" translate="yes" xml:space="preserve">
          <source>Takes one argument, a file name, and returns the file name, if the argument is likely to be a perl script. On MM_Unix this is true for any ordinary, readable file.</source>
          <target state="translated">取一个参数,即文件名,如果参数可能是一个perl脚本,则返回文件名。在MM_Unix上,这对任何普通的可读文件都是正确的。</target>
        </trans-unit>
        <trans-unit id="b67ed86e7a795bece24f2642cf574b99635c4b90" translate="yes" xml:space="preserve">
          <source>Takes one argument, a pathname. Returns the &lt;code&gt;sockaddr_un&lt;/code&gt; structure with that path packed in with &lt;code&gt;AF_UNIX&lt;/code&gt; filled in. For &lt;code&gt;PF_UNIX&lt;/code&gt; sockets, this structure is normally what you need for the arguments in bind(), connect(), and send().</source>
          <target state="translated">接受一个参数，即路径名。返回 &lt;code&gt;sockaddr_un&lt;/code&gt; 结构，其中的路径用 &lt;code&gt;AF_UNIX&lt;/code&gt; 填充。对于 &lt;code&gt;PF_UNIX&lt;/code&gt; 套接字，此结构通常是bind（），connect（）和send（）中的参数所需要的。</target>
        </trans-unit>
        <trans-unit id="5460ec5112334feb4ac9398f4b8e6e656f42cd55" translate="yes" xml:space="preserve">
          <source>Takes one argument: &lt;code&gt;$type&lt;/code&gt; . Returns the class for this $type, or &lt;code&gt;croak&lt;/code&gt; s with an error.</source>
          <target state="translated">接受一个参数： &lt;code&gt;$type&lt;/code&gt; 。返回此$ type的类，或者返回 &lt;code&gt;croak&lt;/code&gt; ,并显示错误。</target>
        </trans-unit>
        <trans-unit id="16af72bfdf1441df18765f4029d283a1f7f95693" translate="yes" xml:space="preserve">
          <source>Takes the name of a package, which may be a nested package, in the form 'Foo/Bar.pm' and replaces the slash with &lt;code&gt;::&lt;/code&gt; or something else safe for a man page file name. Returns the replacement.</source>
          <target state="translated">以'Foo / Bar.pm'的形式获取包的名称（可能是嵌套的包），并将斜杠替换为 &lt;code&gt;::&lt;/code&gt; 或其他安全的手册页文件名。返回替换。</target>
        </trans-unit>
        <trans-unit id="ff0d6765017f7f35ad28bb62529040cd32d236cb" translate="yes" xml:space="preserve">
          <source>Takes the necessary steps (cache invalidations, mostly) when the @ISA of the given package has changed. Invoked by the &lt;code&gt;setisa&lt;/code&gt; magic, should not need to invoke directly.</source>
          <target state="translated">当给定程序包的@ISA更改时，采取必要的步骤（主要是缓存无效）。由 &lt;code&gt;setisa&lt;/code&gt; 魔术调用，不需要直接调用。</target>
        </trans-unit>
        <trans-unit id="98237f7a990bc1f6af918e56a3b7b9f24407d459" translate="yes" xml:space="preserve">
          <source>Takes two arguments, a port number and an opaque string (as returned by inet_aton(), or a v-string). Returns the &lt;code&gt;sockaddr_in&lt;/code&gt; structure with those arguments packed in and &lt;code&gt;AF_INET&lt;/code&gt; filled in. For Internet domain sockets, this structure is normally what you need for the arguments in bind(), connect(), and send().</source>
          <target state="translated">接受两个参数，一个端口号和一个不透明的字符串（由inet_aton（）返回或v字符串）。返回 &lt;code&gt;sockaddr_in&lt;/code&gt; 结构，其中填充了这些参数，并填充了 &lt;code&gt;AF_INET&lt;/code&gt; 。对于Internet域套接字，此结构通常是bind（），connect（）和send（）中的参数所需要的。</target>
        </trans-unit>
        <trans-unit id="b14fed1e8f7026c1b53ef7c0d55d1e273446b0ea" translate="yes" xml:space="preserve">
          <source>Takes two arguments: &lt;code&gt;$type&lt;/code&gt; , &lt;code&gt;$class&lt;/code&gt;</source>
          <target state="translated">接受两个参数： &lt;code&gt;$type&lt;/code&gt; ， &lt;code&gt;$class&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a9f99285830e8621999fc816f54c6c6183fd552" translate="yes" xml:space="preserve">
          <source>Takes two to four arguments, a port number, an opaque string (as returned by inet_pton()), optionally a scope ID number, and optionally a flow label number. Returns the &lt;code&gt;sockaddr_in6&lt;/code&gt; structure with those arguments packed in and &lt;code&gt;AF_INET6&lt;/code&gt; filled in. IPv6 equivalent of pack_sockaddr_in().</source>
          <target state="translated">带两个到四个参数，一个端口号，一个不透明的字符串（由inet_pton（）返回），一个可选的作用域ID号和一个可选的流标签号。返回带有那些参数并填充了 &lt;code&gt;AF_INET6&lt;/code&gt; 的 &lt;code&gt;sockaddr_in6&lt;/code&gt; 结构。IPv6等效于pack_sockaddr_in（）。</target>
        </trans-unit>
        <trans-unit id="6768416e6b2dea0b5b355ce619b2d42c6c2f27cf" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. On Mac OS, $volume, $directory and $file are concatenated. A ':' is inserted if need be. You may pass an empty string for each portion. If all portions are empty, the empty string is returned. If $volume is empty, the result will be a relative path, beginning with a ':'. If $volume and $directory are empty, a leading &quot;:&quot; (if any) is removed form $file and the remainder is returned. If $file is empty, the resulting path will have a trailing ':'.</source>
          <target state="translated">取体积、目录和文件的一部分并返回整个路径。在 Mac OS 上,$volume、$directory 和 $file 是连在一起的。如果需要的话,会插入一个':'。你可以为每个部分传递一个空字符串。如果所有部分都是空的,则返回空字符串。如果$volume为空,结果将是一个相对路径,以':'开头。如果$volume和$directory是空的,$file中的前导符&quot;:&quot;(如果有的话)会被删除,剩余部分会被返回。如果$file为空,结果将是一个以':'开头的相对路径。</target>
        </trans-unit>
        <trans-unit id="03fb347623243a59c8c7215b498a631b05381519" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, $volume is ignored, and directory and file are concatenated. A '/' is inserted if needed (though if the directory portion doesn't start with '/' it is not added). On other OSs, $volume is significant.</source>
          <target state="translated">取卷、目录和文件的一部分并返回整个路径。在Unix下,$volume被忽略,目录和文件被连在一起。如果需要的话,会插入'/'(但如果目录部分不是以'/'开头,则不会添加)。在其他操作系统上,$volume是重要的。</target>
        </trans-unit>
        <trans-unit id="9945bfbc052c2b04dca187c3550c5f1feee8878d" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, $volume is ignored, and this is just like catfile(). On other OSs, the $volume become significant.</source>
          <target state="translated">取卷、目录和文件的一部分并返回整个路径。在Unix下,$volume被忽略,这就像catfile()一样。在其他操作系统上,$volume变得很重要。</target>
        </trans-unit>
        <trans-unit id="972a64a368ed52f92018a4453bba5f6c8e73cecd" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, &lt;code&gt;$volume&lt;/code&gt; is ignored, and directory and file are concatenated. A '/' is inserted if need be. On other OSes, &lt;code&gt;$volume&lt;/code&gt; is significant.</source>
          <target state="translated">获取卷，目录和文件部分，并返回完整路径。在Unix下， &lt;code&gt;$volume&lt;/code&gt; 被忽略，目录和文件被串联。如果需要，将插入&amp;ldquo; /&amp;rdquo;。在其他操作系统上， &lt;code&gt;$volume&lt;/code&gt; 很重要。</target>
        </trans-unit>
        <trans-unit id="510dd54f6700e32b2e33a7ae6bf0b69436048e78" translate="yes" xml:space="preserve">
          <source>Taking a pattern, usually a &lt;b&gt;regular expression&lt;/b&gt;, and trying the pattern various ways on a string to see whether there&amp;rsquo;s any way to make it fit. Often used to pick interesting tidbits out of a file.</source>
          <target state="translated">采取一个模式，通常是一个&lt;b&gt;正则表达式&lt;/b&gt;，然后对字符串进行各种方式的尝试，以查看是否有任何合适的方式。通常用于从文件中挑选有趣的花絮。</target>
        </trans-unit>
        <trans-unit id="71bab857be3a2f057d5a14d3b22be3dc59b9b4df" translate="yes" xml:space="preserve">
          <source>Taking a reference to an enumerated list is not the same as using square brackets--instead it's the same as creating a list of references!</source>
          <target state="translated">对一个枚举列表的引用与使用方括号是不一样的--相反,它与创建一个引用列表是一样的。</target>
        </trans-unit>
        <trans-unit id="15f9cd429dc93becd860c5d004ae9bccaf0f7bef" translate="yes" xml:space="preserve">
          <source>Taking references to the elements of shared arrays and hashes does not autovivify the elements, and neither does slicing a shared array/hash over non-existent indices/keys autovivify the elements.</source>
          <target state="translated">对共享数组和哈希的元素进行引用并不会自动激活元素,在不存在的索引/键上对共享数组/哈希进行分片也不会自动激活元素。</target>
        </trans-unit>
        <trans-unit id="4c38f4d8d122fb1493ff34d8747e9c4346d4b600" translate="yes" xml:space="preserve">
          <source>Tanenbaum, Andrew S. Distributed Operating Systems. Prentice Hall, 1995, ISBN 0-13-219908-4 (great textbook).</source>
          <target state="translated">Tanenbaum,Andrew S.Distributed Operating Systems.Prentice Hall,1995,ISBN 0-13-219908-4(伟大的教科书)。</target>
        </trans-unit>
        <trans-unit id="2c7e55c8c22c8578371b576097055d97d0b00faf" translate="yes" xml:space="preserve">
          <source>Tar</source>
          <target state="translated">Tar</target>
        </trans-unit>
        <trans-unit id="6fa1266b6a5ee03e688676077ed07cbe3831ca7d" translate="yes" xml:space="preserve">
          <source>Tar command verbosity level (none or v or vv)?</source>
          <target state="translated">焦油命令动词级别(无或v或vv)?</target>
        </trans-unit>
        <trans-unit id="ad911c00bd7a291ef3efa483132270f4863e5d78" translate="yes" xml:space="preserve">
          <source>Tar magic string -- not useful for most users</source>
          <target state="translated">焦油魔绳 ----对大多数用户无用</target>
        </trans-unit>
        <trans-unit id="6c049aa004ef5f9f848604b292466698be913578" translate="yes" xml:space="preserve">
          <source>Tar version string -- not useful for most users</source>
          <target state="translated">焦油版本字符串--对大多数用户没有用处</target>
        </trans-unit>
        <trans-unit id="61ad50a9b9189cc3cf1874568e35e7901ff4c982" translate="yes" xml:space="preserve">
          <source>Target</source>
          <target state="translated">Target</target>
        </trans-unit>
        <trans-unit id="1826e633e69fd1415d51f9f2a918eb7307883a23" translate="yes" xml:space="preserve">
          <source>Target &lt;code&gt;dist&lt;/code&gt; prepares distribution file set. Target &lt;code&gt;zipdist&lt;/code&gt; performs same as &lt;code&gt;dist&lt;/code&gt; but additionally compresses distribution files into zip archive.</source>
          <target state="translated">目标 &lt;code&gt;dist&lt;/code&gt; 准备分发文件集。目标 &lt;code&gt;zipdist&lt;/code&gt; 的性能与 &lt;code&gt;dist&lt;/code&gt; 相同，但还会将分发文件压缩到zip存档中。</target>
        </trans-unit>
        <trans-unit id="d35260a00f655f27edcc35a7eb16da44a4f671a6" translate="yes" xml:space="preserve">
          <source>Targets</source>
          <target state="translated">Targets</target>
        </trans-unit>
        <trans-unit id="cb47f8fe09a055e30fa78d0ffd45295628f69b2c" translate="yes" xml:space="preserve">
          <source>Task-Oriented</source>
          <target state="translated">Task-Oriented</target>
        </trans-unit>
        <trans-unit id="184d6c1f032beb495ac0920ba867a330761f1d3a" translate="yes" xml:space="preserve">
          <source>Tautologous boolean operators are still going to be optimized away. Don't be tempted to write</source>
          <target state="translated">同义布尔运算符还是要优化掉。不要被诱惑去写</target>
        </trans-unit>
        <trans-unit id="3954704c666cb5b3d49966b92f96bca0955f9f5c" translate="yes" xml:space="preserve">
          <source>Technically speaking casting between function pointers and data pointers is unportable and undefined, but practically speaking it seems to work, but you should use the FPTR2DPTR() and DPTR2FPTR() macros. Sometimes you can also play games with unions.</source>
          <target state="translated">从技术上讲,函数指针和数据指针之间的转换是不可移植的,也是未定义的,但实际上,它似乎是可行的,但你应该使用FPTR2DPTR()和DPTR2FPTR()宏。有时你也可以用联合体来玩游戏。</target>
        </trans-unit>
        <trans-unit id="789a9f1903bc34d24a4cbcecb6e7df34821ef6e1" translate="yes" xml:space="preserve">
          <source>Technically speaking, any extra semantics attached to a variable such as &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$0&lt;/code&gt; , &lt;code&gt;%ENV&lt;/code&gt; , or &lt;code&gt;%SIG&lt;/code&gt; , or to any tied variable. Magical things happen when you diddle those variables.</source>
          <target state="translated">从技术上讲，任何附加到变量（例如 &lt;code&gt;$!&lt;/code&gt; )的语义都包括在内！， &lt;code&gt;$0&lt;/code&gt; ， &lt;code&gt;%ENV&lt;/code&gt; 或 &lt;code&gt;%SIG&lt;/code&gt; 或任何绑定变量。欺骗这些变量会发生神奇的事情。</target>
        </trans-unit>
        <trans-unit id="b3fc1fc6f28fa057e70de617f17fd53df2eeea80" translate="yes" xml:space="preserve">
          <source>Tell the grammar which TAP syntax version to support. The lowest supported version is 12. Although 'TAP version' isn't valid version 12 syntax it is accepted so that higher version numbers may be parsed.</source>
          <target state="translated">告诉语法支持哪个TAP语法版本。最低支持的版本是12。虽然'TAP版本'不是有效的12版本语法,但它被接受了,所以更高的版本号可以被解析。</target>
        </trans-unit>
        <trans-unit id="bf7b0d797da557d31ab2a71f5864f39fe5a06aac" translate="yes" xml:space="preserve">
          <source>Tell the parser to ignore the exit status from the test when determining whether the test passed. Normally tests with non-zero exit status are considered to have failed even if all individual tests passed. In cases where it is not possible to control the exit value of the test script use this option to ignore it.</source>
          <target state="translated">告诉解析器在判断测试是否通过时忽略测试的退出状态。通常情况下,即使所有的测试都通过了,退出状态为非零的测试也会被认为是失败的。在无法控制测试脚本的退出值的情况下,使用这个选项来忽略它。</target>
        </trans-unit>
        <trans-unit id="bf2d615f3aae044f0b7af594b2368699ca553959" translate="yes" xml:space="preserve">
          <source>Tell the parser where should the output go. In this case it will be placed in the $html variable:</source>
          <target state="translated">告诉解析器输出的内容应该放在哪里。在这种情况下,它将被放置在$html变量中。</target>
        </trans-unit>
        <trans-unit id="29533c09561de1801d031a71f8c7c8a01e5f03c1" translate="yes" xml:space="preserve">
          <source>Tell the remote server that I am not a user client, but probably another news server.</source>
          <target state="translated">告诉远程服务器,我不是用户客户端,可能是另一个新闻服务器。</target>
        </trans-unit>
        <trans-unit id="08608b0e566d4fb7e89ec44318b59ab07dde69d0" translate="yes" xml:space="preserve">
          <source>Tell the remote server the mail domain which you are in using the EHLO command (or HELO if EHLO fails). Since this method is invoked automatically when the Net::SMTP object is constructed the user should normally not have to call it manually.</source>
          <target state="translated">使用 EHLO 命令(如果 EHLO 失败,则使用 HELO)告诉远程服务器你所处的邮件域。因为这个方法是在Net::SMTP对象被构造时自动调用的,所以用户通常不需要手动调用它。</target>
        </trans-unit>
        <trans-unit id="1f6b5a09a58a8567f17dcd614ece669f9d14b0d0" translate="yes" xml:space="preserve">
          <source>Tell the server that we want to append some data to the end of a file called &lt;code&gt;FILE&lt;/code&gt; . If this file does not exist then create it.</source>
          <target state="translated">告诉服务器，我们要将一些数据附加到名为 &lt;code&gt;FILE&lt;/code&gt; 的文件的末尾。如果该文件不存在，则创建它。</target>
        </trans-unit>
        <trans-unit id="995cb880453aaa8bd60b7aae252f5462234be732" translate="yes" xml:space="preserve">
          <source>Tell the server that you are a reader and not another server.</source>
          <target state="translated">告诉服务器,你是一个读者,而不是另一个服务器。</target>
        </trans-unit>
        <trans-unit id="055d9e27b5b7d5b8f2d504557166da8931089570" translate="yes" xml:space="preserve">
          <source>Tell the server that you wish to store a file. &lt;code&gt;FILE&lt;/code&gt; is the name of the new file that should be created.</source>
          <target state="translated">告诉服务器您要存储文件。 &lt;code&gt;FILE&lt;/code&gt; 是应创建的新文件的名称。</target>
        </trans-unit>
        <trans-unit id="9366b9a09ea150c339542dc64664840e4fc85da8" translate="yes" xml:space="preserve">
          <source>Tell the server to go into passive mode (&lt;code&gt;pasv&lt;/code&gt; for IPv4, &lt;code&gt;epsv&lt;/code&gt; for IPv6). Returns the text that represents the port on which the server is listening, this text is in a suitable form to send to another ftp server using the &lt;code&gt;port&lt;/code&gt; or &lt;code&gt;eprt&lt;/code&gt; method.</source>
          <target state="translated">告诉服务器进入被动模式（对于IPv4， &lt;code&gt;pasv&lt;/code&gt; ，对于IPv6 ， &lt;code&gt;epsv&lt;/code&gt; ）。返回表示服务器正在侦听的端口的文本，此文本采用适当的形式，可以使用 &lt;code&gt;port&lt;/code&gt; 或 &lt;code&gt;eprt&lt;/code&gt; 方法发送到另一个ftp服务器。</target>
        </trans-unit>
        <trans-unit id="15d551aaf2266eb9d86adea81d4570cc191bb729" translate="yes" xml:space="preserve">
          <source>Telling &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email::Sender::Simple&lt;/a&gt; to use your transport is straightforward.</source>
          <target state="translated">告诉&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;电子邮件::发件人:: ::简单&lt;/a&gt;易用。</target>
        </trans-unit>
        <trans-unit id="dd2c3160deeb317e223ba57be41f996c28b1ec03" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; the given string in scalar context and return an SV* result.</source>
          <target state="translated">告诉Perl 在标量上下文中 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 给定的字符串并返回SV *结果。</target>
        </trans-unit>
        <trans-unit id="d9e092fa3e1e256147594ca30bda8c3f4672e0ee" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; the string in the SV. It supports the same flags as &lt;code&gt;call_sv&lt;/code&gt; , with the obvious exception of G_EVAL. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">告诉Perl 在SV中 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 字符串。它支持与 &lt;code&gt;call_sv&lt;/code&gt; 相同的标志，但G_EVAL明显例外。参见&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a71daae5e0e57d93d6228536edc45b69ba84a875" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; the file named by the string argument. It is analogous to the Perl code &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require '$file'&quot;&lt;/code&gt; . It's even implemented that way; consider using load_module instead.</source>
          <target state="translated">告诉Perl &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 使用字符串参数命名的文件。它类似于Perl代码 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require '$file'&quot;&lt;/code&gt; 。它甚至以这种方式实现；考虑改用load_module。</target>
        </trans-unit>
        <trans-unit id="e1bf556e6d9dede28e015a565e8d9027e099de7d" translate="yes" xml:space="preserve">
          <source>Tells Test::Builder what package you exported your functions to.</source>
          <target state="translated">告诉 Test::Builder 你的函数导出到什么包。</target>
        </trans-unit>
        <trans-unit id="21d8020c0986f9af967d2434489f1dff7dddc2b6" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to parse a Perl script. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">告诉Perl解释器解析Perl脚本。见&lt;a href=&quot;perlembed&quot;&gt;临危&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90de9fbbe619d0267fd7167e5dc1db64eb361247" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to run. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">告诉Perl解释器运行。见&lt;a href=&quot;perlembed&quot;&gt;临危&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2794a27373eb4499d2dd0fc224b3c502ced9a12f" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a double and disables all other OK bits.</source>
          <target state="translated">告诉SV是双倍,并禁用所有其他OK位。</target>
        </trans-unit>
        <trans-unit id="cde3486f8b34dcc836358775446f605a6e5f5219" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a double.</source>
          <target state="translated">告诉SV是双倍的。</target>
        </trans-unit>
        <trans-unit id="d29a05e0eb81580dedcd3ec32c30e53e3f465ef8" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other OK bits, and leaves the UTF-8 status as it was.</source>
          <target state="translated">告诉SV是一个字符串,并禁用所有其他OK位,保持UTF-8状态不变。</target>
        </trans-unit>
        <trans-unit id="826cf5cb563ce76cd986386302e8a1a458503e48" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other OK bits. Will also turn off the UTF-8 status.</source>
          <target state="translated">告诉SV是一个字符串,并禁用所有其他OK位。也会关闭UTF-8状态。</target>
        </trans-unit>
        <trans-unit id="3a0e0af0ea20a9f25152c6d76518063affb1c7ae" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string.</source>
          <target state="translated">告诉SV是一个字符串。</target>
        </trans-unit>
        <trans-unit id="9359d018a66deddebc4670552c35dfa39c5db6a1" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an RV.</source>
          <target state="translated">告诉SV,它是一辆RV。</target>
        </trans-unit>
        <trans-unit id="a2ea638c533f4384730e93210ef4a899bb9d756b" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an integer and disables all other OK bits.</source>
          <target state="translated">告诉SV是一个整数,并禁用所有其他OK位。</target>
        </trans-unit>
        <trans-unit id="6d0dafe3ace125974c920e3d5dd9ad0e37849cd8" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an integer.</source>
          <target state="translated">告诉SV是一个整数。</target>
        </trans-unit>
        <trans-unit id="b0b98f3f753198e2b29067e4cd07e7535b94339d" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an unsigned integer and disables all other OK bits.</source>
          <target state="translated">告诉SV是一个无符号整数,并禁用所有其他OK位。</target>
        </trans-unit>
        <trans-unit id="98e3c3ca5f6df324b9d092553470d578100c40eb" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Implemented by calling &lt;code&gt;sv_usepvn_flags&lt;/code&gt; with &lt;code&gt;flags&lt;/code&gt; of 0, hence does not handle 'set' magic. See &lt;code&gt;sv_usepvn_flags&lt;/code&gt; .</source>
          <target state="translated">告诉SV使用 &lt;code&gt;ptr&lt;/code&gt; 查找其字符串值。通过调用来实现 &lt;code&gt;sv_usepvn_flags&lt;/code&gt; 与 &lt;code&gt;flags&lt;/code&gt; 为0，因此不处理&amp;ldquo;设置&amp;rdquo;魔术。参见 &lt;code&gt;sv_usepvn_flags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="898e0cc9cfb0dad2df7d68beacd47f39b7ca2406" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Normally the string is stored inside the SV, but sv_usepvn allows the SV to use an outside string. The &lt;code&gt;ptr&lt;/code&gt; should point to memory that was allocated by &lt;a href=&quot;perlclib#Memory-Management-and-String-Handling&quot;&gt;Newx&lt;/a&gt;. It must be the start of a Newx-ed block of memory, and not a pointer to the middle of it (beware of &lt;a href=&quot;perlguts#Offsets&quot;&gt;OOK&lt;/a&gt; and copy-on-write), and not be from a non-Newx memory allocator like &lt;code&gt;malloc&lt;/code&gt; . The string length, &lt;code&gt;len&lt;/code&gt; , must be supplied. By default this function will &lt;code&gt;Renew&lt;/code&gt; (i.e. realloc, move) the memory pointed to by &lt;code&gt;ptr&lt;/code&gt; , so that pointer should not be freed or used by the programmer after giving it to sv_usepvn, and neither should any pointers from &quot;behind&quot; that pointer (e.g. ptr + 1) be used.</source>
          <target state="translated">告诉SV使用 &lt;code&gt;ptr&lt;/code&gt; 查找其字符串值。通常，字符串存储在SV内部，但是sv_usepvn允许SV使用外部字符串。在 &lt;code&gt;ptr&lt;/code&gt; 应该指向被分配的内存&lt;a href=&quot;perlclib#Memory-Management-and-String-Handling&quot;&gt;下一页末&lt;/a&gt;。它必须是Newx版本的内存块的开始，而不是指向其中间的指针（请注意&lt;a href=&quot;perlguts#Offsets&quot;&gt;OOK&lt;/a&gt;和写时复制），并且不能来自非newx的内存分配器（如 &lt;code&gt;malloc&lt;/code&gt; )。必须提供字符串长度 &lt;code&gt;len&lt;/code&gt; 。默认情况下，此函数将 &lt;code&gt;Renew&lt;/code&gt; （即重新分配，移动） &lt;code&gt;ptr&lt;/code&gt; 指向的内存 ，因此程序员在将指针赋予sv_usepvn之后不应释放或使用该指针，也不应使用该指针&amp;ldquo;后面&amp;rdquo;的任何指针（例如ptr + 1）。</target>
        </trans-unit>
        <trans-unit id="ea1983bb2952566f54d05f0ce7c7dc4c67383643" translate="yes" xml:space="preserve">
          <source>Tells the debugger that we'll want to pause execution when we reach either the named function (but see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;Internal Functions in perlguts&lt;/a&gt;!) or the given line in the named source file.</source>
          <target state="translated">告诉调试器，当我们到达命名函数（但请参见&lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;perlguts中的Internal Functions&lt;/a&gt;）或命名源文件中的给定行时，我们将希望暂停执行。</target>
        </trans-unit>
        <trans-unit id="d14b1bd32ddb84a178c8e757f0eede95fcc4f56d" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on characters. The definition of character varies depending on if the target string is a UTF-8 string.</source>
          <target state="translated">指示分割操作者分割目标字符串的字符。字符的定义根据目标字符串是否是UTF-8字符串而不同。</target>
        </trans-unit>
        <trans-unit id="184bc1d12ee8da813cda422d2ca1e00df540f884" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on newlines (&lt;code&gt;\n&lt;/code&gt; ) without invoking the regex engine.</source>
          <target state="translated">告诉split运算符在不调用正则表达式引擎的情况下在换行符（ &lt;code&gt;\n&lt;/code&gt; ）上分割目标字符串。</target>
        </trans-unit>
        <trans-unit id="b48808542e716e16e3adb670d9889b9528897056" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on whitespace without invoking the regex engine. The definition of whitespace varies depending on if the target string is a UTF-8 string and on if RXf_PMf_LOCALE is set.</source>
          <target state="translated">指示分割操作者在不调用regex引擎的情况下分割目标字符串的whitespace。whitespace的定义取决于目标字符串是否是UTF-8,以及RXf_PMf_LOCALE是否被设置。</target>
        </trans-unit>
        <trans-unit id="e150384486349cedc8729ff69a3903d6982a4a60" translate="yes" xml:space="preserve">
          <source>Tells whether the object is renewed (and how many times). Some modules emit &lt;code&gt;Use of uninitialized value in null operation&lt;/code&gt; warning unless the value is numeric so return 0 for false.</source>
          <target state="translated">告诉对象是否被更新（以及更新了多少次）。某些模块会 &lt;code&gt;Use of uninitialized value in null operation&lt;/code&gt; 发出使用未初始化的值的警告，除非该值是数字，否则返回0表示false。</target>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="716ec42869a03408fcb77c9873e5ac4f7f2b0aad" translate="yes" xml:space="preserve">
          <source>Template Grouping</source>
          <target state="translated">模板分组</target>
        </trans-unit>
        <trans-unit id="c9f888d973643e39eea58ba0d4385df9a5d27ccf" translate="yes" xml:space="preserve">
          <source>Template code &lt;code&gt;P&lt;/code&gt; promises to pack a &quot;pointer to a fixed length string&quot;. Isn't this what we want? Let's try:</source>
          <target state="translated">模板代码 &lt;code&gt;P&lt;/code&gt; 承诺打包&amp;ldquo;指向固定长度字符串的指针&amp;rdquo;。这不是我们想要的吗？我们试试吧：</target>
        </trans-unit>
        <trans-unit id="a108586754857c54e59b71ddb85b8b2a3279733a" translate="yes" xml:space="preserve">
          <source>Template is the same as that required by mkstemp().</source>
          <target state="translated">模板与mkstemp()所要求的模板相同。</target>
        </trans-unit>
        <trans-unit id="58aad47f3a12a51d4d52aa8432c69a9c8ebbb3e7" translate="yes" xml:space="preserve">
          <source>Temporarily disable a member of the XOP, by clearing the appropriate flag.</source>
          <target state="translated">通过清除相应的标志,暂时禁用XOP的一个成员。</target>
        </trans-unit>
        <trans-unit id="d80af7efaaaefafc73c5845cc5b267960e4626cc" translate="yes" xml:space="preserve">
          <source>Temporarily disable an entry in this BHK structure, by clearing the appropriate flag.</source>
          <target state="translated">通过清除相应的标志,暂时禁用该BHK结构中的一个条目。</target>
        </trans-unit>
        <trans-unit id="3e3f1700e4dfa66cdfab75739db179821b620308" translate="yes" xml:space="preserve">
          <source>Temporarily fixing locale problems</source>
          <target state="translated">暂时解决地域问题</target>
        </trans-unit>
        <trans-unit id="48915beb5208adc13703e622845e9d9286a425c6" translate="yes" xml:space="preserve">
          <source>Temporarily override assorted &lt;code&gt;CPAN.pm&lt;/code&gt; configuration variables.</source>
          <target state="translated">临时覆盖各种 &lt;code&gt;CPAN.pm&lt;/code&gt; 配置变量。</target>
        </trans-unit>
        <trans-unit id="6563ecf47ef5662e753d4670106fb233c800e886" translate="yes" xml:space="preserve">
          <source>Temporary Values via local()</source>
          <target state="translated">通过local()的临时值</target>
        </trans-unit>
        <trans-unit id="ab6577ed3ab16dc6a0a24e8a29b8f2320a3f1bea" translate="yes" xml:space="preserve">
          <source>Temporary files and NFS</source>
          <target state="translated">临时文件和NFS</target>
        </trans-unit>
        <trans-unit id="972e2ab11e7ed25c1af63f02f49c51ed09f64187" translate="yes" xml:space="preserve">
          <source>Tend to fail, not succeed.</source>
          <target state="translated">倾向于失败,而不是成功。</target>
        </trans-unit>
        <trans-unit id="038c9aeb7bb05d375a32b9ab2979691faa497330" translate="yes" xml:space="preserve">
          <source>Term used by language lawyers for a storage location you can assign a new &lt;b&gt;value&lt;/b&gt; to, such as a &lt;b&gt;variable&lt;/b&gt; or an element of an &lt;b&gt;array&lt;/b&gt;. The &amp;ldquo;l&amp;rdquo; is short for &amp;ldquo;left&amp;rdquo;, as in the left side of an assignment, a typical place for lvalues. An &lt;b&gt;lvaluable&lt;/b&gt; function or expression is one to which a value may be assigned, as in &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;($x) = 10&lt;/code&gt; .</source>
          <target state="translated">语言律师用于存储位置的术语，您可以为其分配新&lt;b&gt;值&lt;/b&gt;，例如&lt;b&gt;变量&lt;/b&gt;或&lt;b&gt;数组&lt;/b&gt;的元素。&amp;ldquo; l&amp;rdquo;是&amp;ldquo; left&amp;rdquo;的缩写，就像在赋值的左侧一样，是左值的典型位置。可&lt;b&gt;评估&lt;/b&gt;函数或表达式是可以为其分配值的函数或表达式，如 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;($x) = 10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d0028d995c201a4db08a4f29da91c7c14dbfb31" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor</source>
          <target state="translated">Term::ANSIColor</target>
        </trans-unit>
        <trans-unit id="a16dc007b248f41d8a8b48934fc42c79241aa183" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor - Color screen output using ANSI escape sequences</source>
          <target state="translated">Term::ANSIColor-使用ANSI转义序列进行彩色屏幕输出。</target>
        </trans-unit>
        <trans-unit id="db406ea9117455f0b666b6ba8f4edfbd34a6728b" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor is used to get colors and therefore must be installed to use this module.</source>
          <target state="translated">Term::ANSIColor用于获取颜色,因此必须安装该模块才能使用。</target>
        </trans-unit>
        <trans-unit id="f7bdc8f03c4b5d2f5d03a99d6b589da67ba2844c" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor was first included with Perl in Perl 5.6.0.</source>
          <target state="translated">Term::ANSIColor在Perl 5.6.0中首次包含在Perl中。</target>
        </trans-unit>
        <trans-unit id="3973a6639b848462a9aba2fb3883fdeeeee93564" translate="yes" xml:space="preserve">
          <source>Term::Cap</source>
          <target state="translated">Term::Cap</target>
        </trans-unit>
        <trans-unit id="82cd629b4593ce6a72b220343056170a7eb3d545" translate="yes" xml:space="preserve">
          <source>Term::Cap - Perl termcap interface</source>
          <target state="translated">Term::Cap-Perl termcap接口</target>
        </trans-unit>
        <trans-unit id="3d3bfe455e655790515f3b006edeb99748236633" translate="yes" xml:space="preserve">
          <source>Term::Complete</source>
          <target state="translated">Term::Complete</target>
        </trans-unit>
        <trans-unit id="6d23da7c53fbf0f4faebaefa6851bd7ad00eee31" translate="yes" xml:space="preserve">
          <source>Term::Complete - Perl word completion module</source>
          <target state="translated">Term::Complete-Perl词语完成模块</target>
        </trans-unit>
        <trans-unit id="23ebd3bc9f5af49b1131c82bd5eefd1ac9f6bc11" translate="yes" xml:space="preserve">
          <source>Term::ReadLine</source>
          <target state="translated">Term::ReadLine</target>
        </trans-unit>
        <trans-unit id="bfadfd7a83f6920cfb9038f1942ac1ea2e3b25c1" translate="yes" xml:space="preserve">
          <source>Term::ReadLine - Perl interface to various &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; packages. If no real package is found, substitutes stubs instead of basic functions.</source>
          <target state="translated">Term :: ReadLine-各种 &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 包的Perl接口。如果找不到真正的程序包，则用存根代替基本功能。</target>
        </trans-unit>
        <trans-unit id="eb8379c22e18e11951de951761db8a9d7c5f2195" translate="yes" xml:space="preserve">
          <source>Terminal emulators that support color divide into two types: ones that support only eight colors, ones that support sixteen, and ones that support 256. This module provides the ANSI escape codes all of them. These colors are referred to as ANSI colors 0 through 7 (normal), 8 through 15 (16-color), and 16 through 255 (256-color).</source>
          <target state="translated">支持颜色的终端仿真器分为两种类型:只支持8种颜色的,支持16种颜色的,以及支持256种颜色的。本模块提供了所有这些颜色的ANSI转义码。这些颜色被称为ANSI颜色0到7(正常),8到15(16色),16到255(256色)。</target>
        </trans-unit>
        <trans-unit id="9b13399f2e2e5cbdb3d2ac7675630b976b3e5443" translate="yes" xml:space="preserve">
          <source>Terminate use of a parser. Typically used and/or overridden in subclasses. The parser isn't destroyed as a result of this.</source>
          <target state="translated">终止一个解析器的使用。通常在子类中使用和/或重写。解析器不会因此而被销毁。</target>
        </trans-unit>
        <trans-unit id="6b2081166b6ec9fa584db14b8bc64a4e53b287d9" translate="yes" xml:space="preserve">
          <source>Terminates the compressed data stream and flushes any pending compressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">终止压缩数据流，并将所有未决的压缩数据刷新到 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="2c65f89cb90bf010c5c15d59ad7362f6575faeff" translate="yes" xml:space="preserve">
          <source>Terms and List Operators (Leftward)</source>
          <target state="translated">术语和列表操作符(向左</target>
        </trans-unit>
        <trans-unit id="f7687808514bd6fdef254462f2ef21603ff94c5d" translate="yes" xml:space="preserve">
          <source>Ternary &lt;code&gt;&quot;?:&quot;&lt;/code&gt; is the conditional operator, just as in C. It works much like an if-then-else. If the argument before the &lt;code&gt;?&lt;/code&gt; is true, the argument before the &lt;code&gt;:&lt;/code&gt; is returned, otherwise the argument after the &lt;code&gt;:&lt;/code&gt; is returned. For example:</source>
          <target state="translated">与C中一样，三元 &lt;code&gt;&quot;?:&quot;&lt;/code&gt; 是条件运算符。它的工作方式非常类似于if-then-else。如果在论点之前 &lt;code&gt;?&lt;/code&gt; 如果为true，则返回 &lt;code&gt;:&lt;/code&gt; 之前的参数，否则返回 &lt;code&gt;:&lt;/code&gt; 之后的参数。例如：</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="a606ccac095617dc9512d70db5efd42e7bb98a43" translate="yes" xml:space="preserve">
          <source>Test - provides a simple framework for writing test scripts</source>
          <target state="translated">测试-为编写测试脚本提供了一个简单的框架。</target>
        </trans-unit>
        <trans-unit id="39cded9148b38cec922514bd35a2aef5469fc539" translate="yes" xml:space="preserve">
          <source>Test Status and Info</source>
          <target state="translated">测试状态和信息</target>
        </trans-unit>
        <trans-unit id="0f42e18af9e42f65883381d95b6da9a9beb625ba" translate="yes" xml:space="preserve">
          <source>Test _all_ behaviors of a given operator, library, or function.</source>
          <target state="translated">测试给定操作符、库或函数的所有行为。</target>
        </trans-unit>
        <trans-unit id="ccbf4ddf89827f1aef746e7810ae2a433cf06e90" translate="yes" xml:space="preserve">
          <source>Test all optional arguments.</source>
          <target state="translated">测试所有可选参数。</target>
        </trans-unit>
        <trans-unit id="ee2236a26189cf2bce4daa0c312f2ad998013277" translate="yes" xml:space="preserve">
          <source>Test an SV for taintedness. Use &lt;code&gt;SvTAINTED&lt;/code&gt; instead.</source>
          <target state="translated">测试SV的污点。请改用 &lt;code&gt;SvTAINTED&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="435f6b9009ca18e663fe202fc1240deccf2b918a" translate="yes" xml:space="preserve">
          <source>Test building utility methods</source>
          <target state="translated">测试建筑实用方法</target>
        </trans-unit>
        <trans-unit id="b4b87c6940ff3faed10366f7a463d3bfb89e71a4" translate="yes" xml:space="preserve">
          <source>Test control</source>
          <target state="translated">测试控制</target>
        </trans-unit>
        <trans-unit id="10d741ad5424269aabb883c550c337fb9f577347" translate="yes" xml:space="preserve">
          <source>Test for Memoize expiration semantics</source>
          <target state="translated">Memoize过期语义测试</target>
        </trans-unit>
        <trans-unit id="f76975f4d894de42ed86a6b96159814a64e69414" translate="yes" xml:space="preserve">
          <source>Test for end of file.</source>
          <target state="translated">测试文件是否结束。</target>
        </trans-unit>
        <trans-unit id="79382a00ce637c0c3d356c1d16aa7f8ddce716b6" translate="yes" xml:space="preserve">
          <source>Test for the value of &amp;amp;Time::HiRes::d_hires_stat to find out whether the operating system supports subsecond file timestamps: a value larger than zero means yes. There are unfortunately no easy ways to find out whether the filesystem supports such timestamps. UNIX filesystems often do; NTFS does; FAT doesn't (FAT timestamp granularity is &lt;b&gt;two&lt;/b&gt; seconds).</source>
          <target state="translated">测试＆Time :: HiRes :: d_hires_stat的值，以了解操作系统是否支持亚秒级文件时间戳：大于零的值表示是。不幸的是，没有简单的方法来确定文件系统是否支持这种时间戳。UNIX文件系统经常这样做；NTFS可以；FAT没有（FAT时间戳粒度为&lt;b&gt;2&lt;/b&gt;秒）。</target>
        </trans-unit>
        <trans-unit id="7f831cc3a669b4e57bff2b2ef159b4ea5dded3cc" translate="yes" xml:space="preserve">
          <source>Test if the content of an SV looks like a number (or is a number). &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt; are treated as numbers (so will not issue a non-numeric warning), even if your atof() doesn't grok them. Get-magic is ignored.</source>
          <target state="translated">测试SV的内容是否看起来像数字（或是数字）。 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;Infinity&lt;/code&gt; 被视为数字（因此不会发出非数字警告），即使您的atof（）不会忽略它们也是如此。Get-magic被忽略。</target>
        </trans-unit>
        <trans-unit id="7f13862d482c878134330e38991502bcc64e1f31" translate="yes" xml:space="preserve">
          <source>Test mode. The target address defaults to &lt;b&gt;perlbug-test@perl.org&lt;/b&gt;.</source>
          <target state="translated">测试模式。目标地址默认为&lt;b&gt;perlbug-test@perl.org&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="69080e5c49da5d3bba9b15a273b20b2df3903f2b" translate="yes" xml:space="preserve">
          <source>Test names</source>
          <target state="translated">测试名称</target>
        </trans-unit>
        <trans-unit id="5df0db78620ddd32bfd4efd442e6b3f36d8261a7" translate="yes" xml:space="preserve">
          <source>Test result token.</source>
          <target state="translated">测试结果令牌。</target>
        </trans-unit>
        <trans-unit id="ee151a1ef75c0ed5024755e133172ea9006bb555" translate="yes" xml:space="preserve">
          <source>Test results vary depending on your host system and your Cygwin configuration. If a test can pass in some Cygwin setup, it is always attempted and explainable test failures are documented. It is possible for Perl to pass all the tests, but it is more likely that some tests will fail for one of the reasons listed below.</source>
          <target state="translated">测试结果根据您的主机系统和Cygwin配置的不同而不同。如果一个测试在某些Cygwin设置中可以通过,那么它总是会被尝试,并且会记录可解释的测试失败。Perl有可能通过所有的测试,但更有可能的是,有些测试会因为下面列出的原因而失败。</target>
        </trans-unit>
        <trans-unit id="7aeb2301cd878b4bea322bf5867e98635082f17a" translate="yes" xml:space="preserve">
          <source>Test results will be added to the supplied &lt;a href=&quot;parser/aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;. &lt;code&gt;aggregate_tests&lt;/code&gt; may be called multiple times to run several sets of tests. Multiple &lt;code&gt;Test::Harness&lt;/code&gt; instances may be used to pass results to a single aggregator so that different parts of a complex test suite may be run using different &lt;code&gt;TAP::Harness&lt;/code&gt; settings. This is useful, for example, in the case where some tests should run in parallel but others are unsuitable for parallel execution.</source>
          <target state="translated">测试结果将添加到提供的&lt;a href=&quot;parser/aggregator&quot;&gt;TAP :: Parser :: Aggregator中&lt;/a&gt;。可以多次调用 &lt;code&gt;aggregate_tests&lt;/code&gt; 以运行几组测试。可以使用多个 &lt;code&gt;Test::Harness&lt;/code&gt; 实例将结果传递给单个聚合器，以便可以使用不同的 &lt;code&gt;TAP::Harness&lt;/code&gt; 设置来运行复杂测试套件的不同部分。例如，在某些测试应并行运行而其他测试不适合并行执行的情况下，这很有用。</target>
        </trans-unit>
        <trans-unit id="30bf8d2a1f537e3de40966fbaca2a259bafa1326" translate="yes" xml:space="preserve">
          <source>Test return values in various contexts (boolean, scalar, list, lvalue).</source>
          <target state="translated">测试各种情况下的返回值(布尔、标量、列表、lvalue)。</target>
        </trans-unit>
        <trans-unit id="87b25e7182a4957634bdf28eb60aa42f52a26bbf" translate="yes" xml:space="preserve">
          <source>Test style</source>
          <target state="translated">测试风格</target>
        </trans-unit>
        <trans-unit id="5f967f7d2e1f440aeb4c91e854d76b62157077cf" translate="yes" xml:space="preserve">
          <source>Test suite</source>
          <target state="translated">测试套件</target>
        </trans-unit>
        <trans-unit id="26b3f7125d4977a4c818431649628fa0924ccde1" translate="yes" xml:space="preserve">
          <source>Test testsuites that have been built with</source>
          <target state="translated">构建的测试套件。</target>
        </trans-unit>
        <trans-unit id="c743b9b50bdf1cbd4320751b7b3e3e77099e55b4" translate="yes" xml:space="preserve">
          <source>Test that the given &lt;code&gt;pv&lt;/code&gt; doesn't contain any internal &lt;code&gt;NUL&lt;/code&gt; characters. If it does, set &lt;code&gt;errno&lt;/code&gt; to ENOENT, optionally warn, and return FALSE.</source>
          <target state="translated">测试给定的 &lt;code&gt;pv&lt;/code&gt; 不包含任何内部 &lt;code&gt;NUL&lt;/code&gt; 字符。如果是这样，请将 &lt;code&gt;errno&lt;/code&gt; 设置为ENOENT，可以选择发出警告，然后返回FALSE。</target>
        </trans-unit>
        <trans-unit id="e8e7a9e15ab34cf742c942e50d6aff3c06043d08" translate="yes" xml:space="preserve">
          <source>Test the perl C API</source>
          <target state="translated">测试perl C API</target>
        </trans-unit>
        <trans-unit id="8c712f8219cebd35791babf9ed3b703a8351ea8b" translate="yes" xml:space="preserve">
          <source>Test two buffers (which may contain embedded &lt;code&gt;NUL&lt;/code&gt; characters, to see if they are equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns zero if equal, or non-zero if non-equal.</source>
          <target state="translated">测试两个缓冲区（其中可能包含嵌入的 &lt;code&gt;NUL&lt;/code&gt; 字符，以查看它们是否相等 &lt;code&gt;len&lt;/code&gt; 参数指示要比较的字节数。如果相等，则返回零；如果不相等，则返回非零。</target>
        </trans-unit>
        <trans-unit id="aa66181e4ff9ebce0ccdea0d81358cf4b122fa39" translate="yes" xml:space="preserve">
          <source>Test two buffers (which may contain embedded &lt;code&gt;NUL&lt;/code&gt; characters, to see if they are not equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns zero if non-equal, or non-zero if equal.</source>
          <target state="translated">测试两个缓冲区（其中可能包含嵌入式 &lt;code&gt;NUL&lt;/code&gt; 字符，以查看它们是否不相等 &lt;code&gt;len&lt;/code&gt; 参数指示要比较的字节数。如果不相等，则返回零；如果相等，则返回非零。</target>
        </trans-unit>
        <trans-unit id="7588b6c061b826b0f7a0fe2738aa760c611f4b7d" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is greater than or equal to the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">测试两个字符串，以查看第一个字符串 &lt;code&gt;s1&lt;/code&gt; 是否大于或等于第二个字符串 &lt;code&gt;s2&lt;/code&gt; 。返回true或false。</target>
        </trans-unit>
        <trans-unit id="960024a856f809dce4509cd90004cd8da3ca6ba1" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is greater than the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">测试两个字符串，以查看第一个字符串 &lt;code&gt;s1&lt;/code&gt; 是否大于第二个字符串 &lt;code&gt;s2&lt;/code&gt; 。返回true或false。</target>
        </trans-unit>
        <trans-unit id="ee2367cd81142917d4f07c520dafb2f8d390eb84" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is less than or equal to the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">测试两个字符串，以查看第一个字符串 &lt;code&gt;s1&lt;/code&gt; 是否小于或等于第二个字符串 &lt;code&gt;s2&lt;/code&gt; 。返回true或false。</target>
        </trans-unit>
        <trans-unit id="57ddc2e399365a286280a07fe9ed50d6bfa9604c" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is less than the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">测试两个字符串，以查看第一个字符串 &lt;code&gt;s1&lt;/code&gt; 是否小于第二个字符串 &lt;code&gt;s2&lt;/code&gt; 。返回true或false。</target>
        </trans-unit>
        <trans-unit id="237ab8c0b99038db78a7c54fb0bfdbb2ab764cbb" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are different. Returns true or false.</source>
          <target state="translated">测试两个字符串是否不同。返回true或false。</target>
        </trans-unit>
        <trans-unit id="fb2934866aafd7ff65638c4caf1d299244cb4e65" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are different. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt; ).</source>
          <target state="translated">测试两个字符串以查看它们是否不同。该 &lt;code&gt;len&lt;/code&gt; 参数指示字节比较的数量。返回true或false。（ &lt;code&gt;strncmp&lt;/code&gt; 的包装器）。</target>
        </trans-unit>
        <trans-unit id="44326cf741b4ea53c3861e1c04224785c2787564" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are equal. Returns true or false.</source>
          <target state="translated">测试两个字符串是否相等。返回true或false。</target>
        </trans-unit>
        <trans-unit id="f0b60c1b2d7c48750566bd13231437cae4745024" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt; ).</source>
          <target state="translated">测试两个字符串，看它们是否相等。该 &lt;code&gt;len&lt;/code&gt; 参数指示字节比较的数量。返回true或false。（ &lt;code&gt;strncmp&lt;/code&gt; 的包装器）。</target>
        </trans-unit>
        <trans-unit id="368b5822e8d2728701a3f8f8b37d0363f9573092" translate="yes" xml:space="preserve">
          <source>Test.pl</source>
          <target state="translated">Test.pl</target>
        </trans-unit>
        <trans-unit id="193904736b8940fdc2ba17861b0cc502cad2d12e" translate="yes" xml:space="preserve">
          <source>Test::Builder</source>
          <target state="translated">Test::Builder</target>
        </trans-unit>
        <trans-unit id="ab9974f668e2c6c0ffc2992746669dd361b94a4d" translate="yes" xml:space="preserve">
          <source>Test::Builder - Backend for building test libraries</source>
          <target state="translated">Test::Builder-用于构建测试库的后端。</target>
        </trans-unit>
        <trans-unit id="b3b54af1fc0cfa765b71e78e4e18039fd43150ca" translate="yes" xml:space="preserve">
          <source>Test::Builder is only thread-aware if threads.pm is loaded</source>
          <target state="translated">Test::Builder只有在加载了threads.pm的情况下才会有线程感知。</target>
        </trans-unit>
        <trans-unit id="a49fdf2299317bf9d9dff7fce116cd0d0e8a3c2b" translate="yes" xml:space="preserve">
          <source>Test::Builder.</source>
          <target state="translated">Test::Builder.</target>
        </trans-unit>
        <trans-unit id="a007e7488b132a0e9d1aa8009a01ac991651ac14" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module</source>
          <target state="translated">Test::Builder::Module</target>
        </trans-unit>
        <trans-unit id="3ed23c6a90bd99e62a3c52acce5c4439a1d74951" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module - Base class for test modules</source>
          <target state="translated">Test::Builder::Module-测试模块的基础类。</target>
        </trans-unit>
        <trans-unit id="cc216e7a80df8491f0b761fca22c7d52cff231ca" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module is a subclass of &lt;a href=&quot;../../exporter&quot;&gt;Exporter&lt;/a&gt; which means your module is also a subclass of Exporter. @EXPORT, @EXPORT_OK, etc... all act normally.</source>
          <target state="translated">Test :: Builder :: Module是&lt;a href=&quot;../../exporter&quot;&gt;Exporter&lt;/a&gt;的子类，这意味着您的模块也是Exporter的子类。@ EXPORT，@ EXPORT_OK等...均正常运行。</target>
        </trans-unit>
        <trans-unit id="59c85c34391e2a59a9a1aebf543278d41eaede1e" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module provides an &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; method which acts in the same basic way as &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt;'s, setting the plan and controlling exporting of functions and variables. This allows your module to set the plan independent of &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt;.</source>
          <target state="translated">Test :: Builder :: Module提供了一个 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; 方法，该方法的行为与&lt;a href=&quot;../more&quot;&gt;Test :: More&lt;/a&gt;的基本方法相同，用于设置计划并控制函数和变量的导出。这使您的模块可以独立于&lt;a href=&quot;../more&quot;&gt;Test :: More&lt;/a&gt;来设置计划。</target>
        </trans-unit>
        <trans-unit id="1860964402a6fbbf4a8ee83b8ff81c101e436168" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module provides some methods of getting at the underlying Test::Builder object.</source>
          <target state="translated">Test::Builder::Module 提供了一些获取底层 Test::Builder 对象的方法。</target>
        </trans-unit>
        <trans-unit id="dfe8750e469aab07b5d8dadae68c198e1a6ea505" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester</source>
          <target state="translated">Test::Builder::Tester</target>
        </trans-unit>
        <trans-unit id="99afed4f8190d67c7ca9fceff64feafac8a2c27f" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester - test testsuites that have been built with Test::Builder</source>
          <target state="translated">Test::Builder::Tester-使用 Test::Builder 建立的测试套件。</target>
        </trans-unit>
        <trans-unit id="21b5ba34db69a6e0e7e2db842da88dc2874db319" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester::Color</source>
          <target state="translated">Test::Builder::Tester::Color</target>
        </trans-unit>
        <trans-unit id="2d500c7bf4e510506ebc84f5c768b05a6cccce1c" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester::Color - turn on colour in Test::Builder::Tester</source>
          <target state="translated">Test::Builder::Tester::Color-在 Test::Builder::Tester 中打开颜色。</target>
        </trans-unit>
        <trans-unit id="d22ac9fb1a5b65be8b995c5c95d6e3ef8ecf556f" translate="yes" xml:space="preserve">
          <source>Test::Harness</source>
          <target state="translated">Test::Harness</target>
        </trans-unit>
        <trans-unit id="999566fc7acbd2379a803a5571ff7ae9c8a53f12" translate="yes" xml:space="preserve">
          <source>Test::Harness - Run Perl standard test scripts with statistics</source>
          <target state="translated">Test::Harness-通过统计数据运行Perl标准测试脚本。</target>
        </trans-unit>
        <trans-unit id="8bc418104ff43998dd3e36faf2584e579de681bc" translate="yes" xml:space="preserve">
          <source>Test::More</source>
          <target state="translated">Test::More</target>
        </trans-unit>
        <trans-unit id="6bfa9c991e549bd99bf8bd638cf1236dd03e5675" translate="yes" xml:space="preserve">
          <source>Test::More - yet another framework for writing test scripts</source>
          <target state="translated">Test::More-又一个编写测试脚本的框架。</target>
        </trans-unit>
        <trans-unit id="09cadd12e0ce824bc15b5cc2302b3277911f9d5d" translate="yes" xml:space="preserve">
          <source>Test::More is loaded. This is ok:</source>
          <target state="translated">Test::More已加载。这是好的。</target>
        </trans-unit>
        <trans-unit id="298bd3075d22676dbcd8f6e949f1684dca1178d5" translate="yes" xml:space="preserve">
          <source>Test::More will only be aware of threads if &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; has been done</source>
          <target state="translated">Test :: More将仅在 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 完成后才意识到线程</target>
        </trans-unit>
        <trans-unit id="71a20537d51a274a0fa5bf1a1b0842f5d372eac9" translate="yes" xml:space="preserve">
          <source>Test::More works with Perls as old as 5.8.1.</source>
          <target state="translated">Test::More可以在5.8.1版本的Perls中使用。</target>
        </trans-unit>
        <trans-unit id="1daa106bfbe0f2bf149e9e695740563a8ed4ebb6" translate="yes" xml:space="preserve">
          <source>Test::Simple</source>
          <target state="translated">Test::Simple</target>
        </trans-unit>
        <trans-unit id="3b9ad9cea20f592f35fa16d26cd1276645b8b0c3" translate="yes" xml:space="preserve">
          <source>Test::Simple - Basic utilities for writing tests.</source>
          <target state="translated">Test::Simple-编写测试的基本工具。</target>
        </trans-unit>
        <trans-unit id="475687d59b9799eb28a9bf920c296a61e431b89f" translate="yes" xml:space="preserve">
          <source>Test::Simple is &lt;b&gt;explicitly&lt;/b&gt; tested all the way back to perl 5.6.0.</source>
          <target state="translated">自从Perl 5.6.0以来，对Test :: Simple进行了&lt;b&gt;明确的&lt;/b&gt;测试。</target>
        </trans-unit>
        <trans-unit id="5f28cc996a292888e74e1d0b0e1cee8d8ca4199f" translate="yes" xml:space="preserve">
          <source>Test::Simple is thread-safe in perl 5.8.1 and up.</source>
          <target state="translated">Test::Simple在perl 5.8.1及以上版本中是线程安全的。</target>
        </trans-unit>
        <trans-unit id="73bb7e431ecc9d090ef6327ee2db2dd9ad7a8638" translate="yes" xml:space="preserve">
          <source>Test::Simple will only report a maximum of 254 failures in its exit code. If this is a problem, you probably have a huge test script. Split it into multiple files. (Otherwise blame the Unix folks for using an unsigned short integer as the exit status).</source>
          <target state="translated">Test::Simple在其退出代码中最多只能报告254次失败。如果这是一个问题,你可能有一个巨大的测试脚本。将它分割成多个文件。(否则就怪Unix的人使用一个无符号短整数作为退出状态)。</target>
        </trans-unit>
        <trans-unit id="7410d0684050e7e2cf37f448e25d1181f683a339" translate="yes" xml:space="preserve">
          <source>Test::Simple will start by printing number of tests run in the form &quot;1..M&quot; (so &quot;1..5&quot; means you're going to run 5 tests). This strange format lets &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; know how many tests you plan on running in case something goes horribly wrong.</source>
          <target state="translated">Test :: Simple将从打印以&amp;ldquo; 1..M&amp;rdquo;形式运行的测试数量开始（因此&amp;ldquo; 1..5&amp;rdquo;表示您将要运行5个测试）。这种奇怪的格式可以让&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt;知道您计划在运行中进行多少测试，以防万一出了什么问题。</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="df0cbdcfcbefab8ee9cdb49385d677707edb64f0" translate="yes" xml:space="preserve">
          <source>Testing Anomalies with Perl on OS/390</source>
          <target state="translated">在OS/390上使用Perl测试异常情况</target>
        </trans-unit>
        <trans-unit id="5570491e686f99f120f682632ae7878ad3d5e6f3" translate="yes" xml:space="preserve">
          <source>Testing Perl on AmigaOS</source>
          <target state="translated">在AmigaOS上测试Perl</target>
        </trans-unit>
        <trans-unit id="8fcfced2bef4012741d97c1ae50789df4c2ca1a7" translate="yes" xml:space="preserve">
          <source>Testing Perl on BS2000</source>
          <target state="translated">在BS2000上测试Perl</target>
        </trans-unit>
        <trans-unit id="d2f23703acfdab063aa7e2b458c49da1d7edf65c" translate="yes" xml:space="preserve">
          <source>Testing Perl on DOS</source>
          <target state="translated">在DOS上测试Perl</target>
        </trans-unit>
        <trans-unit id="06d9fe11979b660c9a4ee9181d453bdc4d62d418" translate="yes" xml:space="preserve">
          <source>Testing Perl on Tru64</source>
          <target state="translated">在 Tru64 上测试 Perl</target>
        </trans-unit>
        <trans-unit id="ad2407f8ab58aad232d3d10c4a28600678ba9ac4" translate="yes" xml:space="preserve">
          <source>Testing Perl on Windows</source>
          <target state="translated">在Windows上测试Perl</target>
        </trans-unit>
        <trans-unit id="77bcc7871b8f58fd20b1c5a5350ee1211c163038" translate="yes" xml:space="preserve">
          <source>Testing for broken locales</source>
          <target state="translated">测试破损的区域</target>
        </trans-unit>
        <trans-unit id="8a625de0654c02e74db29ae73bd5e3bde68f2ba9" translate="yes" xml:space="preserve">
          <source>Testing for exact floating-point equality or inequality is not a good idea. Here's a (relatively expensive) work-around to compare whether two floating-point numbers are equal to a particular number of decimal places. See Knuth, volume II, for a more robust treatment of this topic.</source>
          <target state="translated">测试精确的浮点数相等或不相等不是一个好主意。这里有一个(相对昂贵的)变通方法,用来比较两个浮点数是否等于特定的小数点位数。参见Knuth,第二卷,关于这个主题的更强大的处理方法。</target>
        </trans-unit>
        <trans-unit id="ce74fac01896559c610eb3a5a4dbe52a84d8dafc" translate="yes" xml:space="preserve">
          <source>Testing for operating systems or versions when should be testing for features</source>
          <target state="translated">测试操作系统或版本的时候应该测试功能</target>
        </trans-unit>
        <trans-unit id="e225b583da27a200eb4cb29e5d543c5d33dff11a" translate="yes" xml:space="preserve">
          <source>Testing results: &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/&lt;/a&gt;</source>
          <target state="translated">测试结果：&lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http&lt;/a&gt; : //www.cpantesters.org/</target>
        </trans-unit>
        <trans-unit id="062a3b44009f84b9f2800778be4849f48c73f2e1" translate="yes" xml:space="preserve">
          <source>Testing the patch</source>
          <target state="translated">测试补丁</target>
        </trans-unit>
        <trans-unit id="39fdec1194d94212b871a28b2aa04a73cd40fce1" translate="yes" xml:space="preserve">
          <source>Tests</source>
          <target state="translated">Tests</target>
        </trans-unit>
        <trans-unit id="16d924262049c4868fcbd9b1e4dbe661fd3a3f60" translate="yes" xml:space="preserve">
          <source>Tests are run from the top level of your distribution. So inside a test you would refer to ./lib to enter the lib directory, for example.</source>
          <target state="translated">测试是在你的发行版的顶层运行的。因此,在一个测试中,你会引用./lib来进入lib目录,例如。</target>
        </trans-unit>
        <trans-unit id="54a6b8165e3eb024d50e4aac5941e40919fd1c85" translate="yes" xml:space="preserve">
          <source>Tests for basic control structures, &lt;code&gt;if/else&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; , subroutines, etc.</source>
          <target state="translated">测试基本控制结构， &lt;code&gt;if/else&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; ，子例程等。</target>
        </trans-unit>
        <trans-unit id="d23a0f9aaa05867bc6031160779c65549d0d4574" translate="yes" xml:space="preserve">
          <source>Tests for basic issues of how Perl parses and compiles itself.</source>
          <target state="translated">测试Perl如何解析和编译的基本问题。</target>
        </trans-unit>
        <trans-unit id="308c251d349eaa69d0bf0cd8f27225db41d2132b" translate="yes" xml:space="preserve">
          <source>Tests for built-in IO functions, including command line arguments.</source>
          <target state="translated">测试内置IO函数,包括命令行参数。</target>
        </trans-unit>
        <trans-unit id="19b2942a8db27974454d5941c50ac27e7e57bf55" translate="yes" xml:space="preserve">
          <source>Tests for core modules in the</source>
          <target state="translated">核心模块的测试</target>
        </trans-unit>
        <trans-unit id="b5bc9dd6c6b565df077d3e101f86339fa68c2de9" translate="yes" xml:space="preserve">
          <source>Tests for features of how perl actually runs, including exit codes and handling of PERL* environment variables.</source>
          <target state="translated">测试perl实际运行的特性,包括退出代码和PERL*环境变量的处理。</target>
        </trans-unit>
        <trans-unit id="3267c94afb370d057a2cbf7d80804c00a071b8c7" translate="yes" xml:space="preserve">
          <source>Tests for modules in</source>
          <target state="translated">模块测试</target>
        </trans-unit>
        <trans-unit id="546a42daa356e4d754d8415b0cf28f28144cb38f" translate="yes" xml:space="preserve">
          <source>Tests for perl's built in functions that don't fit into any of the other directories.</source>
          <target state="translated">测试perl的内置函数,这些函数不适合任何其他目录。</target>
        </trans-unit>
        <trans-unit id="7dde17b953b0dbe2392223a460035fd53ab6fcb8" translate="yes" xml:space="preserve">
          <source>Tests for perl's built in functions which, like those in</source>
          <target state="translated">测试perl的内置函数,就像在</target>
        </trans-unit>
        <trans-unit id="cee38a612a6bf39e0ad8abf7e176cb7eb3696a9c" translate="yes" xml:space="preserve">
          <source>Tests for perl's method resolution order implementations (see &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt;).</source>
          <target state="translated">测试perl的方法解析顺序实现（请参阅&lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="20b59967ab49cfe543876fa9d6d79f51e0848a3e" translate="yes" xml:space="preserve">
          <source>Tests for regex related functions or behaviour. (These used to live in t/op).</source>
          <target state="translated">测试与regex相关的功能或行为。(这些以前在t/op中)。</target>
        </trans-unit>
        <trans-unit id="9a9539800599d59b0f69e2e288d490ed3068858e" translate="yes" xml:space="preserve">
          <source>Tests for the absolute basic functionality of Perl. This includes &lt;code&gt;if&lt;/code&gt; , basic file reads and writes, simple regexes, etc. These are run first in the test suite and if any of them fail, something is</source>
          <target state="translated">测试Perl的绝对基本功能。这包括 &lt;code&gt;if&lt;/code&gt; ，基本文件读写，简单的正则表达式等。它们首先在测试套件中运行，如果其中任何一个失败，则说明存在某些问题。</target>
        </trans-unit>
        <trans-unit id="4c72675b2d7c270a253600fe2e92bb83c326034f" translate="yes" xml:space="preserve">
          <source>Tests for the core support of Unicode.</source>
          <target state="translated">测试对Unicode的核心支持。</target>
        </trans-unit>
        <trans-unit id="5399480a16c4de144214dd4ce3a72127bb1a23c7" translate="yes" xml:space="preserve">
          <source>Tests for your modules go here. Each test filename ends with a .t. So</source>
          <target state="translated">你的模块的测试可以在这里进行。每个测试文件名都以.t结尾,所以</target>
        </trans-unit>
        <trans-unit id="3b09fe0c89b9d62c4f3f3bd0ca9b2eec4dcf9e3b" translate="yes" xml:space="preserve">
          <source>Tests if a directory exists.</source>
          <target state="translated">测试目录是否存在。</target>
        </trans-unit>
        <trans-unit id="46dcf6b14fde2f007d3642aeb765c51b6d6d9ef7" translate="yes" xml:space="preserve">
          <source>Tests if a file exists and is not empty (size &amp;gt; 0).</source>
          <target state="translated">测试文件是否存在并且不为空（大小&amp;gt; 0）。</target>
        </trans-unit>
        <trans-unit id="6b574534ebbfa4f25620de8b753e474bc0774320" translate="yes" xml:space="preserve">
          <source>Tests if a file exists.</source>
          <target state="translated">测试文件是否存在。</target>
        </trans-unit>
        <trans-unit id="cbd83d5913990ad1027b8f9518f00ff7c97af8a7" translate="yes" xml:space="preserve">
          <source>Tests if some arbitrary number of bytes begins in a valid UTF-8 character. Note that an INVARIANT (i.e. ASCII on non-EBCDIC machines) character is a valid UTF-8 character. The actual number of bytes in the UTF-8 character will be returned if it is valid, otherwise 0.</source>
          <target state="translated">测试任意数量的字节是否以有效的UTF-8字符开始。请注意,一个INVARIANT(即非EBCDIC机器上的ASCII码)字符是一个有效的UTF-8字符,如果有效,则返回UTF-8字符的实际字节数,否则为0。如果UTF-8字符是有效的,则返回实际的字节数,否则为0。</target>
        </trans-unit>
        <trans-unit id="44e861c8808d6c4fdc4afa5679c3cee1a9b5d6ca" translate="yes" xml:space="preserve">
          <source>Tests if the SV is an RV.</source>
          <target state="translated">测试SV是否为RV。</target>
        </trans-unit>
        <trans-unit id="e941f360f3702d2e201c15e9113b9156e131c64f" translate="yes" xml:space="preserve">
          <source>Tests if the source file exists and is not empty (size &amp;gt; 0). If it is not empty it copies it to the given destination with the given permissions.</source>
          <target state="translated">测试源文件是否存在并且不为空（大小&amp;gt; 0）。如果不为空，它将使用给定的权限将其复制到给定的目的地。</target>
        </trans-unit>
        <trans-unit id="8add41d28c736769282eb5984bc3956add793925" translate="yes" xml:space="preserve">
          <source>Tests if two threads objects are the same thread or not. This is overloaded to the more natural forms:</source>
          <target state="translated">测试两个线程对象是否为同一线程。这是重载到更自然的形式。</target>
        </trans-unit>
        <trans-unit id="374b92e6c8d9a3ee7da76fc28e0b35de614ef062" translate="yes" xml:space="preserve">
          <source>Tests that have never failed will not be selected. To run all tests with the most recently failed first use</source>
          <target state="translated">从未失败过的测试将不会被选中。要运行所有最近失败的测试,首先使用</target>
        </trans-unit>
        <trans-unit id="0b32728377a8f935217ef765a504aecedda1d3ff" translate="yes" xml:space="preserve">
          <source>Tests the SigSet object to see if it contains a specific signal.</source>
          <target state="translated">测试SigSet对象是否包含一个特定的信号。</target>
        </trans-unit>
        <trans-unit id="018f42b8eff88fccb00a8501792db561a99e45b3" translate="yes" xml:space="preserve">
          <source>Tests the state of the source tree for various common errors. For example, it tests that everyone who is listed in the git log has a corresponding entry in the</source>
          <target state="translated">测试源代码树的各种常见错误状态。例如,它测试git日志中列出的每个人是否在</target>
        </trans-unit>
        <trans-unit id="ea2ffd035ac28e433a00f696dde2f14824fdd414" translate="yes" xml:space="preserve">
          <source>Tests will be run in the order found.</source>
          <target state="translated">测试将按照找到的顺序进行。</target>
        </trans-unit>
        <trans-unit id="e7d8144d0e2f5125039e56e9f410b15ff3f27544" translate="yes" xml:space="preserve">
          <source>Texas Instruments</source>
          <target state="translated">德州仪器</target>
        </trans-unit>
        <trans-unit id="c1c3994d542e6e140e686559285de68d361dbc43" translate="yes" xml:space="preserve">
          <source>Text Fields</source>
          <target state="translated">文本字段</target>
        </trans-unit>
        <trans-unit id="5295b0156f97937927214f3e61425549fb5528ba" translate="yes" xml:space="preserve">
          <source>Text after __DATA__ may be read via the filehandle &lt;code&gt;PACKNAME::DATA&lt;/code&gt; , where &lt;code&gt;PACKNAME&lt;/code&gt; is the package that was current when the __DATA__ token was encountered. The filehandle is left open pointing to the line after __DATA__. The program should &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; DATA&lt;/code&gt; when it is done reading from it. (Leaving it open leaks filehandles if the module is reloaded for any reason, so it's a safer practice to close it.) For compatibility with older scripts written before __DATA__ was introduced, __END__ behaves like __DATA__ in the top level script (but not in files loaded with &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;) and leaves the remaining contents of the file accessible via &lt;code&gt;main::DATA&lt;/code&gt; .</source>
          <target state="translated">__DATA__之后的文本可以通过文件句柄 &lt;code&gt;PACKNAME::DATA&lt;/code&gt; 读取，其中 &lt;code&gt;PACKNAME&lt;/code&gt; 是遇到__DATA__令牌时的当前包。文件句柄保持打开状态，指向__DATA__之后的行。从 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; DATA&lt;/code&gt; 读取完成后，程序应&lt;a href=&quot;functions/close&quot;&gt;关闭&lt;/a&gt; DATA。 （如果出于某种原因重新加载该模块，则将其保持打开状态会泄漏文件句柄，因此关闭它是一种更安全的做法。）为了与引入__DATA__之前编写的旧脚本兼容，__ END__的行为类似于顶级脚本中的__DATA__（但不在文件中）加载了 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; ），并通过 &lt;code&gt;main::DATA&lt;/code&gt; 访问文件的其余内容。</target>
        </trans-unit>
        <trans-unit id="14b961306ccde8b23c4b7e5620da4263be5fc453" translate="yes" xml:space="preserve">
          <source>Text from a &lt;code&gt;&quot;#&quot;&lt;/code&gt; character until the end of the line is a comment, and is ignored. Exceptions include &lt;code&gt;&quot;#&quot;&lt;/code&gt; inside a string or regular expression.</source>
          <target state="translated">从 &lt;code&gt;&quot;#&quot;&lt;/code&gt; 字符到行尾的文本是注释，将被忽略。例外包括字符串或正则表达式中的 &lt;code&gt;&quot;#&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="612222022f1b46958ab65767470934164201705e" translate="yes" xml:space="preserve">
          <source>Text sorted by numeric codepoint follows no reasonable alphabetic order; use the UCA for sorting text.</source>
          <target state="translated">按数字码点排序的文本不遵循合理的字母顺序,使用UCA对文本进行排序。</target>
        </trans-unit>
        <trans-unit id="2c6fa58228dea3c204f1dbf0a6dfadcd17082dee" translate="yes" xml:space="preserve">
          <source>Text strings (character strings)</source>
          <target state="translated">文本串(字符串</target>
        </trans-unit>
        <trans-unit id="3b64142186315d3b56e626d60aec3cca8845fddf" translate="yes" xml:space="preserve">
          <source>Text-mode filehandles</source>
          <target state="translated">文本模式的文件柄</target>
        </trans-unit>
        <trans-unit id="5f66be9f33facdd2db9a099e59f4d627dc79cb6a" translate="yes" xml:space="preserve">
          <source>Text-tokens from Pod::Simple::PullParser</source>
          <target state="translated">来自Pod::Simple::PullParser的文本标记。</target>
        </trans-unit>
        <trans-unit id="0ff712854e85b7ca719cd920d585fda4d395d5a6" translate="yes" xml:space="preserve">
          <source>Text/Soundex.pm</source>
          <target state="translated">Text/Soundex.pm</target>
        </trans-unit>
        <trans-unit id="e496659a9c65305c9d5cc245d38c0b1cea09e5cd" translate="yes" xml:space="preserve">
          <source>Text2</source>
          <target state="translated">Text2</target>
        </trans-unit>
        <trans-unit id="76fdd8573b883583b24f2ee565ca6b0eb2a5486b" translate="yes" xml:space="preserve">
          <source>Text::Abbrev</source>
          <target state="translated">Text::Abbrev</target>
        </trans-unit>
        <trans-unit id="2068aa4164bd7ee8a2ded8f7cd23b18d6c9d99cd" translate="yes" xml:space="preserve">
          <source>Text::Abbrev - abbrev - create an abbreviation table from a list</source>
          <target state="translated">Text::Abbrev-abbrev-从列表中创建一个缩写表。</target>
        </trans-unit>
        <trans-unit id="3fa2f6e623c8f3b7b036f20657d7a8f10bb6417e" translate="yes" xml:space="preserve">
          <source>Text::Balanced</source>
          <target state="translated">Text::Balanced</target>
        </trans-unit>
        <trans-unit id="ed925f6d474c4516a347932710d3ebe30e7e56cb" translate="yes" xml:space="preserve">
          <source>Text::Balanced - Extract delimited text sequences from strings.</source>
          <target state="translated">Text::Balanced-从字符串中提取分隔的文本序列。</target>
        </trans-unit>
        <trans-unit id="e4b49cafa2ac97b401d3d68d8bed306fe21eb79b" translate="yes" xml:space="preserve">
          <source>Text::ParseWords</source>
          <target state="translated">Text::ParseWords</target>
        </trans-unit>
        <trans-unit id="4524c2c613f4d738713e1d030d34e60049e80d95" translate="yes" xml:space="preserve">
          <source>Text::ParseWords - parse text into an array of tokens or array of arrays</source>
          <target state="translated">Text::ParseWords-将文本解析为一个标记数组或数组。</target>
        </trans-unit>
        <trans-unit id="bdadcd3fc912962eb41c1688bb499f95c2ac99b6" translate="yes" xml:space="preserve">
          <source>Text::Tabs</source>
          <target state="translated">Text::Tabs</target>
        </trans-unit>
        <trans-unit id="d895b382c2e881055f9eeb7a0411fad11058bd8a" translate="yes" xml:space="preserve">
          <source>Text::Tabs - expand and unexpand tabs like unix expand(1) and unexpand(1)</source>
          <target state="translated">Text::Tabs-像unix expand(1)和unexpand(1)一样展开和不展开标签。</target>
        </trans-unit>
        <trans-unit id="4b087dde2df1e77a15a3f15af552e2d614eda1ab" translate="yes" xml:space="preserve">
          <source>Text::Tabs does most of what the unix utilities expand(1) and unexpand(1) do. Given a line with tabs in it, &lt;code&gt;expand&lt;/code&gt; replaces those tabs with the appropriate number of spaces. Given a line with or without tabs in it, &lt;code&gt;unexpand&lt;/code&gt; adds tabs when it can save bytes by doing so, like the &lt;code&gt;unexpand -a&lt;/code&gt; command.</source>
          <target state="translated">Text :: Tabs可以完成unix实用工具expand（1）和unexpand（1）的大部分工作。给定其中带有选项卡的行， &lt;code&gt;expand&lt;/code&gt; 将使用适当数量的空格替换这些选项卡。给定其中包含或不包含制表符的行，当 &lt;code&gt;unexpand&lt;/code&gt; 可以这样做保存字节时，它会像 &lt;code&gt;unexpand -a&lt;/code&gt; 命令一样添加制表符。</target>
        </trans-unit>
        <trans-unit id="f269210fd9d87098c23ad7f43c52bf42decefb07" translate="yes" xml:space="preserve">
          <source>Text::Tabs handles only tabs (&lt;code&gt;&quot;\t&quot;&lt;/code&gt; ) and combining characters (&lt;code&gt;/\pM/&lt;/code&gt; ). It doesn't count backwards for backspaces (&lt;code&gt;&quot;\t&quot;&lt;/code&gt; ), omit other non-printing control characters (&lt;code&gt;/\pC/&lt;/code&gt; ), or otherwise deal with any other zero-, half-, and full-width characters.</source>
          <target state="translated">Text :: Tabs仅处理制表符（ &lt;code&gt;&quot;\t&quot;&lt;/code&gt; ）和组合字符（ &lt;code&gt;/\pM/&lt;/code&gt; ）。对于空格，它不会向后计数（ &lt;code&gt;&quot;\t&quot;&lt;/code&gt; ），不会忽略其他非打印控制字符（ &lt;code&gt;/\pC/&lt;/code&gt; ），也不会处理任何其他零，半角和全角字符。</target>
        </trans-unit>
        <trans-unit id="b226bf7a7ae42bd7cbd6a0b3ba78466abba19e61" translate="yes" xml:space="preserve">
          <source>Text::Wrap</source>
          <target state="translated">Text::Wrap</target>
        </trans-unit>
        <trans-unit id="8aabd1ad489c52bb200edd21bc6dce9b91083963" translate="yes" xml:space="preserve">
          <source>Text::Wrap - line wrapping to form simple paragraphs</source>
          <target state="translated">Text::Wrap-通过换行形成简单的段落。</target>
        </trans-unit>
        <trans-unit id="f8e8cd6c504322691d26989da020afe0ebedb22f" translate="yes" xml:space="preserve">
          <source>Thank you to (in chronological order):</source>
          <target state="translated">感谢(按时间顺序):</target>
        </trans-unit>
        <trans-unit id="b05872aaf946f643e0804715742f143fabda127d" translate="yes" xml:space="preserve">
          <source>Thanks (in no particular order) to Chaim Frenkel, Steve Fink, Gurusamy Sarathy, Ilya Zakharevich, Benjamin Sugars, J&amp;uuml;rgen Christoffel, Joshua Pritikin, and Alan Burlison, for their help in reality-checking and polishing this article. Big thanks to Tom Christiansen for his rewrite of the prime number generator.</source>
          <target state="translated">感谢（以不特殊的顺序）感谢Chaim Frenkel，Steve Fink，Gurusamy Sarathy，Ilya Zakharevich，Benjamin Sugars，J&amp;uuml;rgenChristoffel，Joshua Pritikin和Alan Burlison，他们为检查和完善本文提供了帮助。非常感谢Tom Christiansen重写了素数生成器。</target>
        </trans-unit>
        <trans-unit id="515198f3ec489e991661ee9be0d3531260928534" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fhe.net%2f&quot;&gt;Hurricane Electric&lt;/a&gt; for permission to use its &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net%2f&quot;&gt;Linux man pages online&lt;/a&gt; site for man page links.</source>
          <target state="translated">感谢&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fhe.net%2f&quot;&gt;Hurricane Electric&lt;/a&gt;允许将其&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net%2f&quot;&gt;Linux手册页在线&lt;/a&gt;站点用于手册页链接。</target>
        </trans-unit>
        <trans-unit id="4a56281c4f40d78c915f83cd7dcb75140989545c" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2f&quot;&gt;search.cpan.org&lt;/a&gt; for permission to use the site for Perl module links.</source>
          <target state="translated">感谢&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2f&quot;&gt;search.cpan.org&lt;/a&gt;允许将站点用于Perl模块链接。</target>
        </trans-unit>
        <trans-unit id="3cf7d45d74afe72eed5d28a1078191c21d4ed94f" translate="yes" xml:space="preserve">
          <source>Thanks to Chia-Liang Kao for suggesting &lt;code&gt;Path&lt;/code&gt; and &lt;code&gt;loc_lang&lt;/code&gt; .</source>
          <target state="translated">感谢Chia-Liang Kao建议 &lt;code&gt;Path&lt;/code&gt; 和 &lt;code&gt;loc_lang&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28343241fc627e1ddfa37f27bcd25a3afbba56c2" translate="yes" xml:space="preserve">
          <source>Thanks to Gerard Goossen from TTY. His presentation &quot;UTF-8 in the wild&quot; (Dutch Perl Workshop 2006) inspired me to publish my thoughts and write this tutorial.</source>
          <target state="translated">感谢来自 TTY 的 Gerard Goossen。他的演讲 &quot;UTF-8 in the wild&quot;(2006年荷兰Perl研讨会)启发我发表了我的想法,并写了这个教程。</target>
        </trans-unit>
        <trans-unit id="eebcdc028466185c372d461642a6d1089c91d63f" translate="yes" xml:space="preserve">
          <source>Thanks to Graham Barr for contributing the following paragraphs about the interaction between perl, and various firewall configurations. For further information on firewalls, it is recommended to consult the documentation that comes with the</source>
          <target state="translated">感谢 Graham Barr 提供了以下关于 perl 和各种防火墙配置之间的交互的段落。关于防火墙的更多信息,建议查阅随同</target>
        </trans-unit>
        <trans-unit id="d6d72a4f35680c5e9eebf1d781be27639e4c1c23" translate="yes" xml:space="preserve">
          <source>Thanks to James Mastros and Martijn van der Streek for their help in getting &lt;a href=&quot;open3&quot;&gt;IPC::Open3&lt;/a&gt; to behave nicely.</source>
          <target state="translated">感谢James Mastros和Martijn van der Streek为使&lt;a href=&quot;open3&quot;&gt;IPC :: Open3&lt;/a&gt;表现良好而提供的帮助。</target>
        </trans-unit>
        <trans-unit id="7dd46c60691bdec97830a740ba5397edf654eae8" translate="yes" xml:space="preserve">
          <source>Thanks to Johan Vromans from Squirrel Consultancy. His UTF-8 rants during the Amsterdam Perl Mongers meetings got me interested and determined to find out how to use character encodings in Perl in ways that don't break easily.</source>
          <target state="translated">感谢 Squirrel Consultancy 的 Johan Vromans。他在阿姆斯特丹Perl Mongers会议上的UTF-8咆哮让我产生了浓厚的兴趣,并决心找出如何在Perl中使用字符编码而不容易损坏的方法。</target>
        </trans-unit>
        <trans-unit id="6253d9253e0f2874bf9d499be7a8e0251aa0083e" translate="yes" xml:space="preserve">
          <source>Thanks to Jonas B. Nielsen for making explicit imports work.</source>
          <target state="translated">感谢Jonas B.Nielsen让显式导入变得有效。</target>
        </trans-unit>
        <trans-unit id="485f1de2dc0f3f17fa293a32651cd066b318634d" translate="yes" xml:space="preserve">
          <source>Thanks to Jos I. Boumans for suggesting this module to be written.</source>
          <target state="translated">感谢Jos I.Boumans建议编写这个模块。</target>
        </trans-unit>
        <trans-unit id="5e83291fa2c7af3f2f4cad5da93414b81429569b" translate="yes" xml:space="preserve">
          <source>Thanks to Petya Kohts for the &lt;code&gt;run_forked&lt;/code&gt; code.</source>
          <target state="translated">感谢Petya Kohts提供的 &lt;code&gt;run_forked&lt;/code&gt; 代码。</target>
        </trans-unit>
        <trans-unit id="c916a51d90472cf9a92ff461a1e0369e54a45763" translate="yes" xml:space="preserve">
          <source>Thanks to Richard Clamp &amp;lt;richardc@unixbeard.net&amp;gt; for letting me use his testing system to try this module out on.</source>
          <target state="translated">感谢Richard Clamp &amp;lt;richardc@unixbeard.net&amp;gt;让我使用他的测试系统来试用该模块。</target>
        </trans-unit>
        <trans-unit id="d8791cdde7f82c928089217628fa54dbdfb5e400" translate="yes" xml:space="preserve">
          <source>Thanks to Richard Soderberg for his performance improvements.</source>
          <target state="translated">感谢Richard Soderberg对其性能的改进。</target>
        </trans-unit>
        <trans-unit id="1d0320e05ae32871d886bed9f5bf625ba37f166b" translate="yes" xml:space="preserve">
          <source>Thanks to Sean Burke, Chris Nandor, Chip Salzenberg, Tim Heaney, Gisle Aas, Rainer Tammer and especially Andrew Savige for their help and suggestions.</source>
          <target state="translated">感谢Sean Burke、Chris Nandor、Chip Salzenberg、Tim Heaney、Gisle Aas、Rainer Tammer,特别是Andrew Savige的帮助和建议。</target>
        </trans-unit>
        <trans-unit id="3c490099b710a18daaafdd3d9d34a147de5b78a3" translate="yes" xml:space="preserve">
          <source>Thanks to Tom Christiansen for suggesting that this module should be written and providing ideas for code improvements and security enhancements.</source>
          <target state="translated">感谢Tom Christiansen提出编写这个模块的建议,并提供了改进代码和加强安全的想法。</target>
        </trans-unit>
        <trans-unit id="243da9ccc28383d127f497ef267f78f655f69ef4" translate="yes" xml:space="preserve">
          <source>Thanks to overloading, the handling of arithmetics with complex numbers is simple and almost transparent.</source>
          <target state="translated">由于有了重载,对复杂数字的算术处理变得简单而几乎透明。</target>
        </trans-unit>
        <trans-unit id="e1237be2e8e888521e762a958f2915acb036e56d" translate="yes" xml:space="preserve">
          <source>Thanks to the kind readers of the perl5-porters@perl.org, perl-unicode@perl.org, linux-utf8@nl.linux.org, and unicore@unicode.org mailing lists for their valuable feedback.</source>
          <target state="translated">感谢perl5-porters@perl.org、perl-unicode@perl.org、linux-utf8@nl.linux.org 和 unicore@unicode.org 邮件列表的好心读者的宝贵反馈。</target>
        </trans-unit>
        <trans-unit id="895e96674a21c983f493504acc0807a09ac741d7" translate="yes" xml:space="preserve">
          <source>Thanks to the people who asked about this kind of stuff in several Perl IRC channels, and have constantly reminded me that a simpler explanation was needed.</source>
          <target state="translated">感谢在多个Perl IRC频道中询问这种东西的人,并不断提醒我,需要一个更简单的解释。</target>
        </trans-unit>
        <trans-unit id="5daafe91df31a9585afc5052640e7074b414f20e" translate="yes" xml:space="preserve">
          <source>Thanks to the people who reviewed this document for me, before it went public. They are: Benjamin Smith, Jan-Pieter Cornet, Johan Vromans, Lukas Mai, Nathan Gray.</source>
          <target state="translated">感谢在公开之前为我审查这份文件的人。他们是:Benjamin Smith、Jan-Bieter Cornet、Johan Vromans、Lukas Mai、Nathan Gray。本杰明-史密斯、扬-彼得-科内特、约翰-弗罗曼斯、卢卡斯-麦、内森-格雷。</target>
        </trans-unit>
        <trans-unit id="01f69c9fb3b65301a9a56633220645f84a279dc1" translate="yes" xml:space="preserve">
          <source>That a certain field exists in a struct</source>
          <target state="translated">某一字段存在于结构中</target>
        </trans-unit>
        <trans-unit id="13e180f49380db1e610eb63f2836d65fe6a7ff96" translate="yes" xml:space="preserve">
          <source>That a field is of certain signedness, sizeof, or type</source>
          <target state="translated">一个字段具有一定的符号性、大小或类型。</target>
        </trans-unit>
        <trans-unit id="f34dd8b430aa837e89a7b0c15eb719863c536f5a" translate="yes" xml:space="preserve">
          <source>That being said, there are several ways to approach this. In Perl 5.10 and later, you can use the smart match operator to check that an item is contained in an array or a hash:</source>
          <target state="translated">也就是说,有几种方法可以解决这个问题。在Perl 5.10及以后的版本中,你可以使用智能匹配操作符来检查一个项目是否包含在一个数组或哈希中。</target>
        </trans-unit>
        <trans-unit id="0c260ee0a50dde66d3ef426f496fd0710d1eecdf" translate="yes" xml:space="preserve">
          <source>That being said, we value Perl's stability and security and have long had an unwritten covenant with the broader Perl community to support and maintain releases of Perl.</source>
          <target state="translated">也就是说,我们重视Perl的稳定性和安全性,并且长期以来与广大的Perl社区有一个不成文的约定,即支持和维护Perl的发布。</target>
        </trans-unit>
        <trans-unit id="bbe53d4c6627e25c7f5c04a5ce2e7f7fde39b418" translate="yes" xml:space="preserve">
          <source>That block is a proper block like any other, so you can put more complicated code there. This sends the message out to one of two places:</source>
          <target state="translated">这个块和其他块一样,是一个适当的块,所以你可以在那里放更复杂的代码。这将信息发送到两个地方之一。</target>
        </trans-unit>
        <trans-unit id="b8b88815853e7b011e14c857de7c3f74f6afc9bd" translate="yes" xml:space="preserve">
          <source>That build was a portable hppa-1.1 multithread build that supports large files compiled with gcc-2.9-hppa-991112.</source>
          <target state="translated">那个构建是一个可移植的hppa-1.1多线程构建,支持用gcc-2.9-hppa-991112编译的大文件。</target>
        </trans-unit>
        <trans-unit id="51461163b856a03794ba96810bf1373b9d61492c" translate="yes" xml:space="preserve">
          <source>That clarifies the situation with regards Berkeley DB itself. What about &lt;b&gt;DB_File&lt;/b&gt;? Well, the behavior defined in the quote above is quite useful, so &lt;b&gt;DB_File&lt;/b&gt; conforms to it.</source>
          <target state="translated">这就澄清了有关Berkeley DB本身的情况。什么&lt;b&gt;DB_File&lt;/b&gt;？好吧，上面引用中定义的行为非常有用，因此&lt;b&gt;DB_File&lt;/b&gt;符合它。</target>
        </trans-unit>
        <trans-unit id="42854bfa17d6ca63556d6a3b16e69afee421b58e" translate="yes" xml:space="preserve">
          <source>That example prints something like &lt;code&gt;&quot;1314363215shiftbbb&quot;&lt;/code&gt; , because the &lt;code&gt;=&amp;gt;&lt;/code&gt; implicitly quotes the &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; immediately on its left, ignoring the fact that &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time.shift&lt;/a&gt;&lt;/code&gt; is the entire left operand.</source>
          <target state="translated">该示例将输出类似于 &lt;code&gt;&quot;1314363215shiftbbb&quot;&lt;/code&gt; ，因为 &lt;code&gt;=&amp;gt;&lt;/code&gt; 隐式地在 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 引用了shift，而忽略了 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time.shift&lt;/a&gt;&lt;/code&gt; 是整个左操作数的事实。</target>
        </trans-unit>
        <trans-unit id="435a3c58eaf95bd7ca9114e558f52a39c1b31273" translate="yes" xml:space="preserve">
          <source>That example will print &quot;I like dogs. I like cats&quot;. Notice the original &lt;code&gt;$x&lt;/code&gt; variable has not been affected. The overall result of the substitution is instead stored in &lt;code&gt;$y&lt;/code&gt; . If the substitution doesn't affect anything then the original string is returned:</source>
          <target state="translated">该示例将显示&amp;ldquo;我喜欢狗，我喜欢猫&amp;rdquo;。请注意，原始 &lt;code&gt;$x&lt;/code&gt; 变量未受影响。替换的总体结果存储在 &lt;code&gt;$y&lt;/code&gt; 。如果替换不影响任何内容，则返回原始字符串：</target>
        </trans-unit>
        <trans-unit id="8395ebcf27841eba05938be973987efc8d458043" translate="yes" xml:space="preserve">
          <source>That explicit association is created by the built-in &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function, which is typically used within the</source>
          <target state="translated">显式关联是由内置的 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 功能创建的，通常在</target>
        </trans-unit>
        <trans-unit id="c2ec0978d45de2f32fa9de32d3062c113e6a14e6" translate="yes" xml:space="preserve">
          <source>That extra space comes from the interpolation of the array. If you don't want to put anything between your array elements, don't use the array in double quotes. You can send it to print without them:</source>
          <target state="translated">额外的空间来自于数组的插值。如果你不想在数组元素之间加入任何东西,不要用双引号来表示数组。你可以不用双引号发送打印。</target>
        </trans-unit>
        <trans-unit id="9b298824efc1a224419fada1ed430ca9a977cee5" translate="yes" xml:space="preserve">
          <source>That function can be called with either of the following statements. Note the different argument lists.</source>
          <target state="translated">该函数可以用以下任一语句调用。注意不同的参数列表。</target>
        </trans-unit>
        <trans-unit id="5a589d98a381dc121a0ca9e45213c36fe88d4b95" translate="yes" xml:space="preserve">
          <source>That gives you a parse-tree for each paragraph - so now all you need is an ordered list of paragraphs. You can maintain that yourself as a data element in the object/hash. The most straightforward way would be simply to use an array-ref, with the desired set of custom &quot;options&quot; for each invocation of &lt;b&gt;parse_text&lt;/b&gt;. Let's assume the desired option-set is given by the hash &lt;code&gt;%options&lt;/code&gt; . Then we might do something like the following:</source>
          <target state="translated">这样就为每个段落提供了一个分析树-因此，现在您需要的只是段落的有序列表。您可以将自己保留为对象/哈希中的数据元素。最直接的方法就是简单地使用array-ref，并为每次&lt;b&gt;parse_text&lt;/b&gt;调用提供所需的一组自定义&amp;ldquo;选项&amp;rdquo; 。假设所需的选项集由哈希 &lt;code&gt;%options&lt;/code&gt; 给出。然后，我们可能会执行以下操作：</target>
        </trans-unit>
        <trans-unit id="64f729272f1f6cba682dfada58129c0e19d1beec" translate="yes" xml:space="preserve">
          <source>That has historically been Perl's notion of UTF-8, as that is how UTF-8 was first conceived by Ken Thompson when he invented it. However, thanks to later revisions to the applicable standards, official UTF-8 is now rather stricter than that. For example, its range is much narrower (0 .. 0x10_FFFF to cover only 21 bits instead of 32 or 64 bits) and some sequences are not allowed, like those used in surrogate pairs, the 31 non-character code points 0xFDD0 .. 0xFDEF, the last two code points in</source>
          <target state="translated">这在历史上一直是Perl的UTF-8概念,因为Ken Thompson在发明UTF-8时就是这么设想的。然而,由于后来对适用标准的修订,现在官方的UTF-8比这要严格得多。例如,它的范围要窄得多(0 ...0x10_FFFF只覆盖21位,而不是32位或64位),而且有些序列是不允许的,比如那些在代用对中使用的序列,31个非字符码点0xFDD0 ...0xFDEF,最后的两个码点在 &quot;0 &quot;和 &quot;0 &quot;之间。</target>
        </trans-unit>
        <trans-unit id="d65679687da0ceb818cf54be11aba010b00841bb" translate="yes" xml:space="preserve">
          <source>That has the same effect as</source>
          <target state="translated">这与</target>
        </trans-unit>
        <trans-unit id="70ca5d290cf7d16b2ad0d56ac0c8bb778d981254" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. Perl is C89. Using the //-comments is silently allowed by many C compilers but cranking up the ANSI C89 strictness (which we like to do) causes the compilation to fail.</source>
          <target state="translated">那是C99或C++。Perl是C89。使用 //-注释是许多 C 编译器默默允许的,但调高 ANSI C89 的严格程度(我们喜欢这样做)会导致编译失败。</target>
        </trans-unit>
        <trans-unit id="fbc80ae07cc14a3e9ed515ddb417d3903b3e2d4c" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. Some C compilers allow that, but you shouldn't.</source>
          <target state="translated">那是C99或C++。有些C编译器允许这样做,但你不应该这样做。</target>
        </trans-unit>
        <trans-unit id="828feba24600ccd2337dfee90dbb710d49a4eff3" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. While it would indeed be awfully nice to have that also in C89, to limit the scope of the loop variable, alas, we cannot.</source>
          <target state="translated">那是C99或C++。虽然如果在C89中也能有这样的功能确实非常好,但为了限制循环变量的范围,可惜,我们不能。</target>
        </trans-unit>
        <trans-unit id="17c6f4c7bbbd6286d0fe21947d2ba8ade38beb92" translate="yes" xml:space="preserve">
          <source>That is because the translation from EBCDIC to ASCII is done by the web server in this case. Consult your web server's documentation for further details.</source>
          <target state="translated">这是因为在这种情况下,EBCDIC到ASCII的翻译是由Web服务器完成的。更多细节请参考您的网络服务器文档。</target>
        </trans-unit>
        <trans-unit id="942bc883ec6c98a20c711318e17853f42162c195" translate="yes" xml:space="preserve">
          <source>That is exactly equivalent to</source>
          <target state="translated">这完全等同于</target>
        </trans-unit>
        <trans-unit id="755dfd149254cee016be67859ecceb8b680f03fe" translate="yes" xml:space="preserve">
          <source>That is fine as far as it goes. The thing is, the Perl subroutine can be specified as only a string, however, Perl allows references to subroutines and anonymous subroutines. This is where</source>
          <target state="translated">就目前而言,这是很好的。问题是,Perl的子程序只能指定为一个字符串,但是,Perl允许引用子程序和匿名子程序。这就是</target>
        </trans-unit>
        <trans-unit id="f6e51945777f4de56dfd6b06b12bc029f8de1ebc" translate="yes" xml:space="preserve">
          <source>That is just short for this:</source>
          <target state="translated">这只是简称。</target>
        </trans-unit>
        <trans-unit id="48a322119a3ce010a99cb16daaa24fe8a2a63a40" translate="yes" xml:space="preserve">
          <source>That is, a &quot;start&quot; character followed by any number of &quot;continue&quot; characters. Perl requires every character in an identifier to also match &lt;code&gt;\w&lt;/code&gt; (this prevents some problematic cases); and Perl additionally accepts identfier names beginning with an underscore.</source>
          <target state="translated">即，一个&amp;ldquo;开始&amp;rdquo;字符，后跟任意数量的&amp;ldquo;继续&amp;rdquo;字符。Perl要求标识符中的每个字符都必须与 &lt;code&gt;\w&lt;/code&gt; 匹配（这可以防止出现一些问题）；Perl还接受以下划线开头的标识符名称。</target>
        </trans-unit>
        <trans-unit id="6558436d977d36dc225d2cf7090e600f732d6f4d" translate="yes" xml:space="preserve">
          <source>That is, a &lt;code&gt;'code...'&lt;/code&gt; filter</source>
          <target state="translated">也就是说，一个 &lt;code&gt;'code...'&lt;/code&gt; 过滤器</target>
        </trans-unit>
        <trans-unit id="1f4f6b5b263faf39b0387453cc01be5508d1f769" translate="yes" xml:space="preserve">
          <source>That is, a complex number with the real part of approximately &lt;code&gt;1.571&lt;/code&gt; and the imaginary part of approximately &lt;code&gt;-1.317&lt;/code&gt; .</source>
          <target state="translated">即，具有大约实部的复数 &lt;code&gt;1.571&lt;/code&gt; 和大约虚部 &lt;code&gt;-1.317&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0eeeaa892b3243ba38eb1a4d1d75a40e3e83e990" translate="yes" xml:space="preserve">
          <source>That is, any word character in the ASCII range, as long as the first character is not a digit.</source>
          <target state="translated">也就是说,在ASCII码范围内的任何字字符,只要第一个字符不是数字就可以。</target>
        </trans-unit>
        <trans-unit id="36c759497b0b38fb79d0c364113b1512a2c43723" translate="yes" xml:space="preserve">
          <source>That is, both are like this:</source>
          <target state="translated">就是说,两者都是这样的。</target>
        </trans-unit>
        <trans-unit id="75581dadc9573c00040ace36ddd58570a8c1a03a" translate="yes" xml:space="preserve">
          <source>That is, fetch the &lt;code&gt;a&lt;/code&gt; entry from the main symbol table, and then look at the scalar component of it: &lt;code&gt;gvsv&lt;/code&gt; (&lt;code&gt;pp_gvsv&lt;/code&gt; into</source>
          <target state="translated">也就是说，从主符号表中获取 &lt;code&gt;a&lt;/code&gt; 条目，然后查看它的标量组件： &lt;code&gt;gvsv&lt;/code&gt; （ &lt;code&gt;pp_gvsv&lt;/code&gt; into</target>
        </trans-unit>
        <trans-unit id="fe7215514db7a28aa89b16be5f49f87245a3434d" translate="yes" xml:space="preserve">
          <source>That is, it creates a region consisting of a single paragraph; that paragraph is to be treated as a normal paragraph if &quot;formatname&quot; begins with a &quot;:&quot;; if &quot;formatname&quot;</source>
          <target state="translated">也就是说,它创建了一个由单个段落组成的区域;如果 &quot;formatname &quot;以&quot;:&quot;开头,则该段落将被视为普通段落;如果 &quot;formatname&quot;</target>
        </trans-unit>
        <trans-unit id="7678e34c3ebdef14cc53701ea7fd891c9a91f614" translate="yes" xml:space="preserve">
          <source>That is, it runs a conversion with default options, for whatever inputdirs and output dir you specify.</source>
          <target state="translated">也就是说,无论你指定了什么输入目录和输出目录,它都会用默认的选项进行转换。</target>
        </trans-unit>
        <trans-unit id="27a7e3645a7eb93795bc368264f8f8cb79cd561d" translate="yes" xml:space="preserve">
          <source>That is, it treated both matches as undefined, and converted that to false (raising a warning on each). The first case is the expected result, but the second is likely counterintuitive: &quot;How could both be false when they are complements?&quot; Another problem was that the implementation optimized many Unicode property matches down to already existing simpler, faster operations, which don't raise the warning. We chose to not forgo those optimizations, which help the vast majority of matches, just to generate a warning for the unlikely event that an above-Unicode code point is being matched against.</source>
          <target state="translated">也就是说,它将两个匹配都视为未定义,并将其转换为false(对每个匹配都提出警告)。第一种情况是预期的结果,但第二种情况很可能是反直觉的:&quot;既然是补码,怎么可能都是false呢?&quot; 另一个问题是,实现将许多Unicode属性匹配优化为已经存在的更简单、更快速的操作,这些操作不会引发警告。我们选择不放弃这些对绝大多数匹配有帮助的优化,只是为了在不太可能发生的事件中产生警告,即上面的Unicode码点被匹配。</target>
        </trans-unit>
        <trans-unit id="b2448cc58794e445286f5f6bd3ff90ad3138eeba" translate="yes" xml:space="preserve">
          <source>That is, there should be (at least roughly) equal spacing between items as between paragraphs (although that spacing may well be less than the full height of a line of text). This leaves it to the reader to use (con)textual cues to figure out whether the &quot;Qui dolorem ipsum...&quot; paragraph applies to the &quot;Quisquam Est&quot; item or to all three items &quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam Est&quot;. While not an ideal situation, this is preferable to providing formatting cues that may be actually contrary to the author's intent.</source>
          <target state="translated">也就是说,各项目之间的间距应与各段之间的间距相等(至少是大致相等)(尽管这种间距很可能小于一行文字的全高)。这样,读者就可以利用(con)文字提示来弄清 &quot;Qui dolorem ipsum......&quot;段是适用于 &quot;Quisquam Est &quot;项目,还是适用于 &quot;Neque&quot;、&quot;Porro &quot;和 &quot;Quisquam Est &quot;这三个项目。虽然这不是一种理想的情况,但这比提供可能实际上违背作者意图的格式提示要好。</target>
        </trans-unit>
        <trans-unit id="d2a300a2c4d8d472deffaf92f425ba9342ddb708" translate="yes" xml:space="preserve">
          <source>That is, to get a number between 10 and 15, inclusive, you want a random number between 0 and 5 that you can then add to 10.</source>
          <target state="translated">也就是说,要想得到一个介于10和15(含)之间的数字,你要的是一个0和5之间的随机数,然后你可以把它加到10上。</target>
        </trans-unit>
        <trans-unit id="951f36d3e716f12408c22757558026bf31602523" translate="yes" xml:space="preserve">
          <source>That is, with &quot;=for&quot;, you can have only one paragraph's worth of text (i.e., the text in &quot;=foo targetname text...&quot;), but with &quot;=begin targetname&quot; ... &quot;=end targetname&quot;, you can have any amount of stuff in between. (Note that there still must be a blank line after the &quot;=begin&quot; command and a blank line before the &quot;=end&quot; command.)</source>
          <target state="translated">也就是说,使用&quot;=for&quot;,你只能有一段文字(即&quot;=foo targetname text...&quot;中的文字),但使用&quot;=begin targetname&quot;...&quot;=end targetname&quot;,你可以有任何数量的文字。&quot;=end targetname&quot;,你可以有任何数量的东西在中间。(请注意,在&quot;=begin &quot;命令后仍然必须有一个空行,在&quot;=end &quot;命令前必须有一个空行。)</target>
        </trans-unit>
        <trans-unit id="bc1a3360b8c34a0baef326cea1af80815467c26c" translate="yes" xml:space="preserve">
          <source>That last test line above should have the number '3' instead of '2'.</source>
          <target state="translated">上面最后一行测试应该是数字 &quot;3 &quot;而不是 &quot;2&quot;。</target>
        </trans-unit>
        <trans-unit id="c5a055a52b37b46f2d6c0e63eaf4e182af37b495" translate="yes" xml:space="preserve">
          <source>That looks a bit nicer; but we've got to take apart that weird template. Where did I pull that out of?</source>
          <target state="translated">这看起来有点好,但我们得把那个奇怪的模板拆开。我从哪里弄出来的?</target>
        </trans-unit>
        <trans-unit id="1d5efec9cd6d8da4fb36301f3de63b6888e753f1" translate="yes" xml:space="preserve">
          <source>That means that the address comes back in binary for the host functions, and as a regular perl integer for the net ones. This seems a bug, but here's how to deal with it:</source>
          <target state="translated">这意味着主机函数的地址是二进制的,而net函数的地址是一个普通的perl整数。这似乎是一个bug,但这里有一个处理方法。</target>
        </trans-unit>
        <trans-unit id="f3988f8ba5df3605cc3a35c620ff3fb6ee001ddb" translate="yes" xml:space="preserve">
          <source>That means that the inheritance tree of the object is traversed breadth-first and the resulting order of classes is used as the sequence in which methods are called. However, that sequence is modified by imposing a rule that the appropriate method of a derived class must be called before the same method of any ancestral class. That's why, in the above example, &lt;code&gt;X::foo&lt;/code&gt; is called before &lt;code&gt;D::foo&lt;/code&gt; , even though &lt;code&gt;D&lt;/code&gt; comes before &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;@B::ISA&lt;/code&gt; .</source>
          <target state="translated">这意味着对象的继承树被广度优先地遍历，并且类的结果顺序被用作调用方法的顺序。但是，通过施加以下规则来修改该序列：必须在任何祖先类的相同方法之前调用派生类的适当方法。这就是为什么，在上面的例子中， &lt;code&gt;X::foo&lt;/code&gt; 之前被调用 &lt;code&gt;D::foo&lt;/code&gt; ，即使 &lt;code&gt;D&lt;/code&gt; 到来之前 &lt;code&gt;X&lt;/code&gt; 在 &lt;code&gt;@B::ISA&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02a75b8fa4871b84e34a76476fddd056744d525a" translate="yes" xml:space="preserve">
          <source>That means that you can specify other options (e.g. cachesize) and still have bval default to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; for variable length records, and space for fixed length records.</source>
          <target state="translated">这意味着您可以指定其他选项（例如，cachesize），并且对于可变长度记录，bval默认设置为 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; ，对于固定长度记录，其空间设置为空格。</target>
        </trans-unit>
        <trans-unit id="ef48d86c4cc8b17f43db860898bcc6635d718b02" translate="yes" xml:space="preserve">
          <source>That method may be best because otherwise you won't treat IEEE notations like &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Infinity&lt;/code&gt; properly. At other times, you might prefer to determine whether string data can be used numerically by calling the POSIX::strtod() function or by inspecting your string with a regular expression (as documented in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;).</source>
          <target state="translated">该方法可能是最好的，因为否则您将无法正确处理 &lt;code&gt;NaN&lt;/code&gt; 或 &lt;code&gt;Infinity&lt;/code&gt; 等IEEE符号。在其他时候，您可能更喜欢通过调用POSIX :: strtod（）函数或通过使用正则表达式检查字符串（如&lt;a href=&quot;perlre&quot;&gt;perlre中所述&lt;/a&gt;）来确定是否可以数字方式使用字符串数据。</target>
        </trans-unit>
        <trans-unit id="6fd672a313da74831278f92221ca3146d4b9f20c" translate="yes" xml:space="preserve">
          <source>That no other fields exist besides the ones you know of</source>
          <target state="translated">除了你所知道的领域,没有其他领域的存在</target>
        </trans-unit>
        <trans-unit id="5527de36ef73a03f5b5a63ba8cbaf8b4f3a8fcb3" translate="yes" xml:space="preserve">
          <source>That now parses as you'd expect, but you still ought to get in the habit of using parentheses in that situation. For more on prototypes, see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">现在可以按照您的期望进行解析了，但是您仍然应该养成在这种情况下使用括号的习惯。有关原型的更多信息，请参见&lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d37fa65fedd67f278b74cbc5a381d76fb677b39a" translate="yes" xml:space="preserve">
          <source>That prints &lt;code&gt;&quot;unphooey&quot;&lt;/code&gt; . (Yes, there are still unresolved issues having to do with visibility of &lt;code&gt;@_&lt;/code&gt; . I'm ignoring that question for the moment. (But note that if we make &lt;code&gt;@_&lt;/code&gt; lexically scoped, those anonymous subroutines can act like closures... (Gee, is this sounding a little Lispish? (Never mind.))))</source>
          <target state="translated">上面 &lt;code&gt;&quot;unphooey&quot;&lt;/code&gt; 。（是的，仍有一些尚未解决的问题与 &lt;code&gt;@_&lt;/code&gt; 的可见性有关。我暂时暂时不考虑这个问题。（但请注意，如果我们将 &lt;code&gt;@_&lt;/code&gt; 进行词法范围划分，则这些匿名子例程可以像闭包一样起作用...（哎呀，这听起来有点话语吗（没关系））））</target>
        </trans-unit>
        <trans-unit id="b8f34b1d00199940c59db31a2c92190f8c2d18ac" translate="yes" xml:space="preserve">
          <source>That prints out: &lt;code&gt;&quot;The third fish is a red one.&quot;&lt;/code&gt; You can also use a repetition count and repeated pattern like this:</source>
          <target state="translated">打印出来： &lt;code&gt;&quot;The third fish is a red one.&quot;&lt;/code&gt; 您还可以使用重复计数和重复模式，如下所示：</target>
        </trans-unit>
        <trans-unit id="efe950f82cdddb13c9f97d9e858479f8a7148487" translate="yes" xml:space="preserve">
          <source>That problem is corrected by using the &lt;code&gt;&amp;amp;&lt;/code&gt; operator. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will now turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; correctly with parameters &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; . It does this by carrying the &lt;code&gt;&amp;amp;&lt;/code&gt; through, so the function call looks like &lt;code&gt;rpcb_gettime(host, &amp;amp;timep)&lt;/code&gt; .</source>
          <target state="translated">通过使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符可以解决该问题。该&lt;b&gt;xsubpp&lt;/b&gt;编译器现在会变成它调用这个代码 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 与参数正确 &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; 。它通过携带 &lt;code&gt;&amp;amp;&lt;/code&gt; 来做到这一点，因此函数调用看起来像 &lt;code&gt;rpcb_gettime(host, &amp;amp;timep)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd92600acf1aacb4bb45d3c98acc1cde89639e0e" translate="yes" xml:space="preserve">
          <source>That produces a new perl binary in the current directory with all extensions linked in that can be found in INST_ARCHLIB, SITELIBEXP, and PERL_ARCHLIB. To do that, MakeMaker writes a new Makefile, on UNIX, this is called</source>
          <target state="translated">这将在当前目录下生成一个新的perl二进制文件,其中链接了所有可以在INST_ARCHLIB、SITELIBEXP和PERL_ARCHLIB中找到的扩展。要做到这一点,MakeMaker会写一个新的Makefile,在UNIX上,这叫做</target>
        </trans-unit>
        <trans-unit id="2351c4ce268ed6ae21d8f1fadbceac3b965331bf" translate="yes" xml:space="preserve">
          <source>That said, &lt;code&gt;miniperl -Ilib -MConfig -we 1&lt;/code&gt; should report an error, because it can not find</source>
          <target state="translated">就是说， &lt;code&gt;miniperl -Ilib -MConfig -we 1&lt;/code&gt; 应该报告一个错误，因为它找不到</target>
        </trans-unit>
        <trans-unit id="55a11affd308eca30c6c076da831e9e75ab6c62b" translate="yes" xml:space="preserve">
          <source>That said, be aware that Perl version 5.14 introduces an exception to the rule, for syntactic convenience. Experimental array and hash container function behavior allows array and hash references to be handled by Perl as if they had been explicitly syntactically dereferenced. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl5140delta.html#Syntactical-Enhancements&quot;&gt;Syntactical Enhancements in perl5140delta&lt;/a&gt; and &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for details.</source>
          <target state="translated">就是说，请注意，为方便语法，Perl版本5.14引入了该规则的例外。实验性的数组和哈希容器功能行为允许Perl处理数组和哈希引用，就好像它们已在语法上显式取消引用一样。有关详细信息，请参见&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl5140delta.html#Syntactical-Enhancements&quot;&gt;perl5140delta&lt;/a&gt;和&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中的&lt;/a&gt;语法增强。</target>
        </trans-unit>
        <trans-unit id="dd96836988cad318a9323c182f881952adb3274c" translate="yes" xml:space="preserve">
          <source>That said, there are a number of steps that can be taken to make life difficult for the potential cracker. The most important: Write your decryption filter in C and statically link the decryption module into the Perl binary. For further tips to make life difficult for the potential cracker, see the file</source>
          <target state="translated">也就是说,有很多步骤可以让潜在的破解者难以下手。最重要的是:用C语言编写你的解密过滤器,并将解密模块静态地链接到Perl二进制中。更多让潜在的破解者难以下手的技巧,请参见文件</target>
        </trans-unit>
        <trans-unit id="6ebc1959c7e697a446f0d0678eca3b28f8c37055" translate="yes" xml:space="preserve">
          <source>That said, there will always be small, focused, special-purpose languages dedicated to a specific problem domain that are simply more convenient for certain kinds of problems. Perl tries to be all things to all people, but nothing special to anyone. Examples of specialized languages that come to mind include prolog and matlab.</source>
          <target state="translated">也就是说,总有一些小型的、专注的、专门用于特定问题领域的特殊用途语言,它们只是对某些类型的问题更方便。Perl试图成为所有人的一切,但对任何人来说都没有什么特别之处。我想到的专门语言的例子包括prolog和matlab。</target>
        </trans-unit>
        <trans-unit id="e78afc53e325aea84cf9c7e198003b89094d500a" translate="yes" xml:space="preserve">
          <source>That same loop could be replaced with a slice operation:</source>
          <target state="translated">同样的循环可以用分片操作代替。</target>
        </trans-unit>
        <trans-unit id="c28091748ec2b3306715e341483bb158b9c0cd3f" translate="yes" xml:space="preserve">
          <source>That second argument may be either a &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt;'d regular expression (which is then used to match the terminator line), or a defined false value (which indicates that no terminator line should be looked for), or a reference to a hash (in which case the terminator is the value associated with the key &lt;code&gt;'terminator'&lt;/code&gt; .</source>
          <target state="translated">第二个参数可以是 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt; 'd正则表达式（然后用于匹配终止符行），也可以是定义的假值（指示不应查找终止符行），也可以是对哈希的引用（以在这种情况下，终止符是与键 &lt;code&gt;'terminator'&lt;/code&gt; 关联的值。</target>
        </trans-unit>
        <trans-unit id="0abf2ef0e2b7f166486ede4264164097c7510116" translate="yes" xml:space="preserve">
          <source>That should be written:</source>
          <target state="translated">应该这样写。</target>
        </trans-unit>
        <trans-unit id="21e34acb57e36768d34631cec4d8c18d970f96ef" translate="yes" xml:space="preserve">
          <source>That should probably be written more simply as:</source>
          <target state="translated">也许应该更简单地写成:</target>
        </trans-unit>
        <trans-unit id="6c2b874251fc59b8ebf4af56444c528d2be2ade1" translate="yes" xml:space="preserve">
          <source>That shows the &lt;code&gt;UTF8&lt;/code&gt; flag in FLAGS and both the UTF-8 bytes and Unicode characters in &lt;code&gt;PV&lt;/code&gt; . See also later in this document the discussion about the &lt;code&gt;utf8::is_utf8()&lt;/code&gt; function.</source>
          <target state="translated">这在FLAGS中显示 &lt;code&gt;UTF8&lt;/code&gt; 标志，在 &lt;code&gt;PV&lt;/code&gt; 中显示UTF-8字节和Unicode字符。另请参见本文档后面有关 &lt;code&gt;utf8::is_utf8()&lt;/code&gt; 函数的讨论。</target>
        </trans-unit>
        <trans-unit id="032b01f3384ab611cdf4fd40994fa76549ad8c4f" translate="yes" xml:space="preserve">
          <source>That syntax simply won't work. It sets just &lt;code&gt;@a&lt;/code&gt; or &lt;code&gt;%a&lt;/code&gt; and clears the &lt;code&gt;@b&lt;/code&gt; or &lt;code&gt;%b&lt;/code&gt; . Plus the function didn't get passed into two separate arrays or hashes: it got one long list in &lt;code&gt;@_&lt;/code&gt; , as always.</source>
          <target state="translated">该语法根本行不通。它仅设置 &lt;code&gt;@a&lt;/code&gt; 或 &lt;code&gt;%a&lt;/code&gt; 并清除 &lt;code&gt;@b&lt;/code&gt; 或 &lt;code&gt;%b&lt;/code&gt; 。另外，该函数没有传递到两个单独的数组或哈希中：与往常一样，它在 &lt;code&gt;@_&lt;/code&gt; 中有一个很长的列表。</target>
        </trans-unit>
        <trans-unit id="d7adc8c9bedd29857f8a7951c4ad397c707680f4" translate="yes" xml:space="preserve">
          <source>That temporarily undefs your record separator, and will automatically close the file at block exit. If the file is already open, just use this:</source>
          <target state="translated">这将暂时取消你的记录分隔符,并将在块退出时自动关闭文件。如果文件已经打开,就用这个。</target>
        </trans-unit>
        <trans-unit id="e79dac633171d977159db125388db2bf16415ce0" translate="yes" xml:space="preserve">
          <source>That the fields are in a certain order</source>
          <target state="translated">字段按一定顺序排列</target>
        </trans-unit>
        <trans-unit id="5adec0092e434c8b7770e6ed721609aafb6fb0d1" translate="yes" xml:space="preserve">
          <source>That the sizeof(struct) or the alignments are the same everywhere</source>
          <target state="translated">sizeof(struct)或对齐方式在任何地方都是一样的。</target>
        </trans-unit>
        <trans-unit id="ff9ccf09dc2dc150e284071ebd76e3a60583513f" translate="yes" xml:space="preserve">
          <source>That third argument tests the byte size of the data on the &lt;code&gt;$fh&lt;/code&gt; filehandle and reads that many bytes into the buffer &lt;code&gt;$var&lt;/code&gt; .</source>
          <target state="translated">第三个参数测试 &lt;code&gt;$fh&lt;/code&gt; 文件句柄上数据的字节大小，并将那么多字节读入缓冲区 &lt;code&gt;$var&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f38824e1c7c399bcd876c5d796e89f3c65e609e8" translate="yes" xml:space="preserve">
          <source>That will efficiently match a nonempty group with matching parentheses two levels deep or less. However, if there is no such group, it will take virtually forever on a long string. That's because there are so many different ways to split a long string into several substrings. This is what &lt;code&gt;(.+)+&lt;/code&gt; is doing, and &lt;code&gt;(.+)+&lt;/code&gt; is similar to a subpattern of the above pattern. Consider how the pattern above detects no-match on &lt;code&gt;((()aaaaaaaaaaaaaaaaaa&lt;/code&gt; in several seconds, but that each extra letter doubles this time. This exponential performance will make it appear that your program has hung. However, a tiny change to this pattern</source>
          <target state="translated">这样可以有效地将一个非空组与两个或两个以下级别的括号匹配。但是，如果没有这样的组，那么长串实际上将永远占据一席之地。那是因为有很多不同的方法可以将一个长字符串分成几个子字符串。这就是 &lt;code&gt;(.+)+&lt;/code&gt; 的工作，并且 &lt;code&gt;(.+)+&lt;/code&gt; 与上述模式的子模式类似。考虑一下上面的模式如何在几秒钟内检测到 &lt;code&gt;((()aaaaaaaaaaaaaaaaaa&lt;/code&gt; aaaa</target>
        </trans-unit>
        <trans-unit id="d2c33811186783297750533407ae69a2c30dbe1c" translate="yes" xml:space="preserve">
          <source>That will print out &lt;code&gt;20&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt; .</source>
          <target state="translated">那将打印出 &lt;code&gt;20&lt;/code&gt; 和 &lt;code&gt;10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="844b1a95e3bd3c94e0935eae872c27cb6a3ae275" translate="yes" xml:space="preserve">
          <source>That will print out:</source>
          <target state="translated">这将打印出来。</target>
        </trans-unit>
        <trans-unit id="3d6db72df23e281596a803d5b93d6efaedb2438e" translate="yes" xml:space="preserve">
          <source>That will run the script &lt;b&gt;myprogram&lt;/b&gt; without human intervention, printing out the call tree with entry and exit points. Note that &lt;code&gt;NonStop=1 frame=2&lt;/code&gt; is equivalent to &lt;code&gt;N f=2&lt;/code&gt; , and that originally, options could be uniquely abbreviated by the first letter (modulo the &lt;code&gt;Dump*&lt;/code&gt; options). It is nevertheless recommended that you always spell them out in full for legibility and future compatibility.</source>
          <target state="translated">这将在无需人工干预的情况下运行脚本&lt;b&gt;myprogram&lt;/b&gt;，并打印出带有入口和出口点的调用树。请注意， &lt;code&gt;NonStop=1 frame=2&lt;/code&gt; 等效于 &lt;code&gt;N f=2&lt;/code&gt; ，并且最初，选项可以唯一地缩写首字母（以 &lt;code&gt;Dump*&lt;/code&gt; 选项为模）。但是，建议您始终完整地拼写它们，以提高可读性和将来的兼容性。</target>
        </trans-unit>
        <trans-unit id="d06ee710fae521075f5d16e4386c06facdb36dbc" translate="yes" xml:space="preserve">
          <source>That won't work at all, because &lt;code&gt;.*&lt;/code&gt; was greedy and gobbled up the whole string. As &lt;code&gt;\d*&lt;/code&gt; can match on an empty string the complete regular expression matched successfully.</source>
          <target state="translated">那根本行不通，因为 &lt;code&gt;.*&lt;/code&gt; 很贪婪，吞噬了整个字符串。由于 &lt;code&gt;\d*&lt;/code&gt; 可以匹配空字符串，因此可以成功匹配完整的正则表达式。</target>
        </trans-unit>
        <trans-unit id="025065d41f91f68021f87b4bc88af80b714297bb" translate="yes" xml:space="preserve">
          <source>That's a bit better, but we still have that last column which needs to be moved further over. There's an easy way to fix this up: unfortunately, we can't get &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; to right-justify our fields, but we can get &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; to do it:</source>
          <target state="translated">更好一点，但是我们还有最后一列，需要进一步介绍。有一个简单的方法可以解决此问题：不幸的是，我们无法正确 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 我们的字段，但我们可以让 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 做到这一点：</target>
        </trans-unit>
        <trans-unit id="85ac81e130e91631a9d78d2d6a68196fcf7146e7" translate="yes" xml:space="preserve">
          <source>That's about all there is to it. Actually, it's more than all there is to it, because we've done a few nice things here for the sake of completeness, robustness, and general aesthetics. Simpler TIESCALAR classes are certainly possible.</source>
          <target state="translated">这就是它的全部内容了。事实上,这不仅仅是所有的东西,因为我们在这里做了一些很好的事情,为了完整性,健壮性,和一般的美学。更简单的TIESCALAR类当然也是可以的。</target>
        </trans-unit>
        <trans-unit id="eb3acd01c2e3336fdfd272a108c9af206f049bc1" translate="yes" xml:space="preserve">
          <source>That's all that's strictly necessary. There's additional files you might want:</source>
          <target state="translated">这就是所有严格必要的东西。还有一些额外的文件你可能需要。</target>
        </trans-unit>
        <trans-unit id="f4b60ee9e69236a73adb2c3c53252dab7254d2c9" translate="yes" xml:space="preserve">
          <source>That's all well and good for declaration of a fixed data structure, but what if you wanted to add new elements on the fly, or build it up entirely from scratch?</source>
          <target state="translated">对于固定数据结构的声明来说,这一切都很好,但如果你想在飞行中添加新的元素,或者完全从头开始建立它呢?</target>
        </trans-unit>
        <trans-unit id="10d195eb40678f2e435ff6368a25ea9770d7ae62" translate="yes" xml:space="preserve">
          <source>That's all you need to do on Unix systems with dynamic linking. Most Unix systems have dynamic linking. If yours doesn't, or if for another reason you have a statically-linked perl, &lt;b&gt;and&lt;/b&gt; the module requires compilation, you'll need to build a new Perl binary that includes the module. Again, you'll probably need to be root.</source>
          <target state="translated">这就是在带有动态链接的Unix系统上要做的所有事情。大多数Unix系统具有动态链接。如果没有，或者由于其他原因您拥有静态链接的perl，&lt;b&gt;并且&lt;/b&gt;模块需要编译，则需要构建一个包含该模块的新Perl二进制文件。同样，您可能需要成为root用户。</target>
        </trans-unit>
        <trans-unit id="a00ede3b70bdf4862c08ec2dce8548cbf40dc38c" translate="yes" xml:space="preserve">
          <source>That's all. Similarly for ncftp or ftp, you would configure something like</source>
          <target state="translated">就是这样。同样的,对于ncftp或ftp,你可以配置一些东西,比如说</target>
        </trans-unit>
        <trans-unit id="6a90902fefb78efc91bb4045efc7ccd96cd2b158" translate="yes" xml:space="preserve">
          <source>That's autovivification. You can get around this in a few ways. The easiest way is to just turn it off. The lexical &lt;code&gt;autovivification&lt;/code&gt; pragma is available on CPAN. Now you don't add to the hash:</source>
          <target state="translated">那就是自我生存。您可以通过几种方式解决此问题。最简单的方法是将其关闭。词汇自动 &lt;code&gt;autovivification&lt;/code&gt; 编译指示可在CPAN上找到。现在，您无需添加哈希：</target>
        </trans-unit>
        <trans-unit id="9f49d51a5d99f95a36f28eae4b0601a8a32ea05a" translate="yes" xml:space="preserve">
          <source>That's because &lt;code&gt;.*&lt;/code&gt; was greedy, so you get everything between the</source>
          <target state="translated">这是因为 &lt;code&gt;.*&lt;/code&gt; 很贪婪，因此您可以在</target>
        </trans-unit>
        <trans-unit id="1b898ba735cd15a6bd993ec3d75a6b0058359915" translate="yes" xml:space="preserve">
          <source>That's because Perl doesn't (ever) implicitly dereference your variables. If you want to get at the thing a reference is referring to, then you have to do this yourself using either prefix typing indicators, like &lt;code&gt;${$blah}&lt;/code&gt; , &lt;code&gt;@{$blah}&lt;/code&gt; , &lt;code&gt;@{$blah[$i]}&lt;/code&gt; , or else postfix pointer arrows, like &lt;code&gt;$a-&amp;gt;[3]&lt;/code&gt; , &lt;code&gt;$h-&amp;gt;{fred}&lt;/code&gt; , or even &lt;code&gt;$ob-&amp;gt;method()-&amp;gt;[3]&lt;/code&gt; .</source>
          <target state="translated">这是因为Perl不会（永远）隐式取消引用变量。如果您想了解引用所指的东西，那么您必须自己使用前缀输入指示符来完成此操作，例如 &lt;code&gt;${$blah}&lt;/code&gt; ， &lt;code&gt;@{$blah}&lt;/code&gt; ， &lt;code&gt;@{$blah[$i]}&lt;/code&gt; 。或者后缀指针箭头，例如 &lt;code&gt;$a-&amp;gt;[3]&lt;/code&gt; a- &amp;gt; [3]， &lt;code&gt;$h-&amp;gt;{fred}&lt;/code&gt; ，甚至 &lt;code&gt;$ob-&amp;gt;method()-&amp;gt;[3]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07d4ba2bfdf5f5b21a00717fd39047d39da3c192" translate="yes" xml:space="preserve">
          <source>That's because Perl's precedence rules on its five prefix dereferencers (which look like someone swearing: &lt;code&gt;$ @ * % &amp;amp;&lt;/code&gt; ) make them bind more tightly than the postfix subscripting brackets or braces! This will no doubt come as a great shock to the C or C++ programmer, who is quite accustomed to using &lt;code&gt;*a[i]&lt;/code&gt; to mean what's pointed to by the</source>
          <target state="translated">这是因为Perl在其五个前缀解引用器上的优先级规则（看起来像在骂人： &lt;code&gt;$ @ * % &amp;amp;&lt;/code&gt; ）使它们的绑定比后缀下标括号或花括号更紧密！毫无疑问，这将给C或C ++程序员带来极大的震撼，他们相当习惯于使用 &lt;code&gt;*a[i]&lt;/code&gt; 来表示C语言所指的内容。</target>
        </trans-unit>
        <trans-unit id="0f393c4bb027f44afad135cf4530852dabaa1d38" translate="yes" xml:space="preserve">
          <source>That's because it treats &lt;code&gt;$fh&lt;/code&gt; as a string like &lt;code&gt;&quot;IO::Handle=GLOB(0x8039e0)&quot;&lt;/code&gt; , then pattern matches against that.</source>
          <target state="translated">这是因为它将 &lt;code&gt;$fh&lt;/code&gt; 视为类似于 &lt;code&gt;&quot;IO::Handle=GLOB(0x8039e0)&quot;&lt;/code&gt; 的字符串，然后对其进行模式匹配。</target>
        </trans-unit>
        <trans-unit id="5ef987861945b1d2e7a185649ce3d062e04bb5bf" translate="yes" xml:space="preserve">
          <source>That's because my() is more of a run-time statement than it is a compile-time declaration</source>
          <target state="translated">这是因为my()更像是一个运行时的语句,而不是编译时的声明。</target>
        </trans-unit>
        <trans-unit id="62587e053e8900b6dd6dfce6fa04010b4761573b" translate="yes" xml:space="preserve">
          <source>That's certainly better, but we still have to know how long all the integers are, and portability is far away. Rather than &lt;code&gt;2&lt;/code&gt; , for instance, we want to say &quot;however long a short is&quot;. But this can be done by enclosing the appropriate pack code in brackets: &lt;code&gt;[s]&lt;/code&gt;. So, here's the very best we can do:</source>
          <target state="translated">那当然更好，但是我们仍然必须知道所有整数有多长，并且可移植性还很遥远。例如，我们要说&amp;ldquo; 而不是 &lt;code&gt;2&lt;/code&gt; &amp;rdquo;，而不是2。但这可以通过将适当的包装代码放在方括号中来完成： &lt;code&gt;[s]&lt;/code&gt; 。因此，这是我们能做的最好的事情：</target>
        </trans-unit>
        <trans-unit id="0971c7f378d8883abc6949fc548118faa7827c21" translate="yes" xml:space="preserve">
          <source>That's faster, cleaner, and safer than the previous approach. Of course, you don't need to use a dollar sign. You could use your own scheme to make it less confusing, like bracketed percent symbols, etc.</source>
          <target state="translated">这比之前的方法更快、更干净、更安全。当然,你不需要用美元符号。你可以使用你自己的方案,让它不那么混乱,比如括号里的百分比符号等。</target>
        </trans-unit>
        <trans-unit id="c29a101730c3253b24f4d81e9d501b9e43d3a5b6" translate="yes" xml:space="preserve">
          <source>That's fine for Internet-domain clients and servers, but what about local communications? While you can use the same setup, sometimes you don't want to. Unix-domain sockets are local to the current host, and are often used internally to implement pipes. Unlike Internet domain sockets, Unix domain sockets can show up in the file system with an ls(1) listing.</source>
          <target state="translated">对于互联网域名的客户端和服务器来说,这很好,但是本地通信呢?虽然你可以使用同样的设置,但有时你并不想这样做。Unix域套接字是当前主机的本地套接字,经常被内部用来实现管道。与Internet域套接字不同,Unix域套接字可以通过ls(1)列表显示在文件系统中。</target>
        </trans-unit>
        <trans-unit id="931aa8f88f4f387e1b11a09a91636eb5c2525c4d" translate="yes" xml:space="preserve">
          <source>That's how Perl parsed the program, from top to bottom:</source>
          <target state="translated">这就是Perl对程序的解析,从上到下。</target>
        </trans-unit>
        <trans-unit id="8a9ad9d817fc65f643335d0c0e239182a33f908e" translate="yes" xml:space="preserve">
          <source>That's how it works. It's pretty simple; as with many Perl programs, the explanation is much longer than the program.</source>
          <target state="translated">这就是它的工作原理。很简单,和很多Perl程序一样,解释的时间比程序长很多。</target>
        </trans-unit>
        <trans-unit id="a4ec64876254c2b08386415f463aa4c3731a3571" translate="yes" xml:space="preserve">
          <source>That's how the &lt;code&gt;*PL_keyword_plugin&lt;/code&gt; function needs to behave overall. Conventionally, however, one does not completely replace the existing handler function. Instead, take a copy of &lt;code&gt;PL_keyword_plugin&lt;/code&gt; before assigning your own function pointer to it. Your handler function should look for keywords that it is interested in and handle those. Where it is not interested, it should call the saved plugin function, passing on the arguments it received. Thus &lt;code&gt;PL_keyword_plugin&lt;/code&gt; actually points at a chain of handler functions, all of which have an opportunity to handle keywords, and only the last function in the chain (built into the Perl core) will normally return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; .</source>
          <target state="translated">这就是 &lt;code&gt;*PL_keyword_plugin&lt;/code&gt; 函数需要整体表现的方式。但是，按照惯例，不能完全取代现有的处理函数。相反，在 &lt;code&gt;PL_keyword_plugin&lt;/code&gt; 分配自己的函数指针之前，请复制PL_keyword_plugin。您的处理程序函数应查找它感兴趣的关键字并进行处理。如果不感兴趣，则应调用已保存的插件函数，并传递其收到的参数。因此， &lt;code&gt;PL_keyword_plugin&lt;/code&gt; 实际上指向处理程序函数链，所有这些处理函数都有机会处理关键字，并且只有该链中的最后一个函数（内置在Perl内核中）通常会返回 &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="417bb675fe45cc9c0d3fa87fb632598764e6a64d" translate="yes" xml:space="preserve">
          <source>That's it for creating references. By now you're probably dying to know how to use references to get back to your long-lost data. There are several basic methods.</source>
          <target state="translated">创建引用的方法就到这里了。现在你可能已经迫不及待地想知道如何使用引用来找回你久违的数据了。有几种基本方法。</target>
        </trans-unit>
        <trans-unit id="e93f4cf2c16977aa0828b84202ee64df60519c65" translate="yes" xml:space="preserve">
          <source>That's it!</source>
          <target state="translated">就是这样!</target>
        </trans-unit>
        <trans-unit id="4ad43787f3a61735da906162ae4566f1716a8e9d" translate="yes" xml:space="preserve">
          <source>That's it, you're back on home turf again.</source>
          <target state="translated">就这样,你又回到了主场。</target>
        </trans-unit>
        <trans-unit id="ad818b8edee0b9dd293a16c07bd537675f5226f7" translate="yes" xml:space="preserve">
          <source>That's just the simple case of assigning an array to a scalar and getting its element count. If that's what you really and truly want, then you might do well to consider being a tad more explicit about it, like this:</source>
          <target state="translated">这只是简单的将一个数组赋值给一个标量并获取其元素数的例子。如果这就是你真正想要的,那么你可以考虑更明确一点,比如这样。</target>
        </trans-unit>
        <trans-unit id="64d9d2742b71e9220af551f7c7046f7f081af6aa" translate="yes" xml:space="preserve">
          <source>That's not much help, a couple of welcomes in there, but no indication of which are keys, and which are values, it's just a listed array dump and, in this case, not particularly helpful. The trick here, is to use a &lt;b&gt;reference&lt;/b&gt; to the data structure:</source>
          <target state="translated">并没有太大的帮助，在这里受到了几次欢迎，但是没有迹象表明哪些是键，哪些是值，它只是列出的数组转储，在这种情况下并不是特别有用。这里的技巧是使用对数据结构的&lt;b&gt;引用&lt;/b&gt;：</target>
        </trans-unit>
        <trans-unit id="33e7ab43a8b3ad63335115c42e08832229acf410" translate="yes" xml:space="preserve">
          <source>That's not particularly efficient. It would be more space-efficient to use:</source>
          <target state="translated">这不是特别有效率。使用起来会更节省空间。</target>
        </trans-unit>
        <trans-unit id="69885b7848b259e032939450164926f255956e80" translate="yes" xml:space="preserve">
          <source>That's pretty much it. Now write</source>
          <target state="translated">这就是差不多了。现在写</target>
        </trans-unit>
        <trans-unit id="0e0f898332e33495bcec31fc5e9658f137da2c67" translate="yes" xml:space="preserve">
          <source>That's probably because you forgot libraries, or library paths differ. You really should build the whole distribution on the machine it will eventually live on, and then type &lt;code&gt;make install&lt;/code&gt; . Most other approaches are doomed to failure.</source>
          <target state="translated">那可能是因为您忘记了库，或者库路径不同。您确实应该在最终将运行的机器上构建整个发行版，然后键入 &lt;code&gt;make install&lt;/code&gt; 。大多数其他方法注定要失败。</target>
        </trans-unit>
        <trans-unit id="a1f563351f204013afa271606ba9bd745aa56dda" translate="yes" xml:space="preserve">
          <source>That's shown below, in a program I'll call</source>
          <target state="translated">如下图所示,在一个程序中,我称之为</target>
        </trans-unit>
        <trans-unit id="651cfe39b8f69bca0fd98eae5d4edf4fd6370a67" translate="yes" xml:space="preserve">
          <source>That's where the glue code can be inserted to create the initial contact between Perl and linked C/C++ routines. Let's take a look some pieces of</source>
          <target state="translated">这就是可以插入胶水代码的地方,以建立Perl和链接的C/C++例程之间的初始接触。让我们来看看一些</target>
        </trans-unit>
        <trans-unit id="9608b4f77e4cb870b25879f8aef6ee06bf6a1b9f" translate="yes" xml:space="preserve">
          <source>That's why &lt;code&gt;STORABLE_freeze&lt;/code&gt; lets you provide a list of references to serialize. The engine guarantees that those will be serialized in the same context as the other objects, and therefore that shared objects will stay shared.</source>
          <target state="translated">这就是为什么 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 允许您提供要序列化的引用列表。引擎保证将在与其他对象相同的上下文中序列化这些对象，因此共享对象将保持共享状态。</target>
        </trans-unit>
        <trans-unit id="735b594fd42209c8688db3bd34982beb910ab493" translate="yes" xml:space="preserve">
          <source>That's why they're called 'options'.</source>
          <target state="translated">这就是为什么他们被称为 &quot;选项&quot;。</target>
        </trans-unit>
        <trans-unit id="8301b3f815f17c3dd7076e96039e1678841b82a4" translate="yes" xml:space="preserve">
          <source>Thatclassname</source>
          <target state="translated">Thatclassname</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="6f203dc849e9f4f723b6a77e413f463ccf14a492" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; above stands for some two digit Unicode version number, such as &lt;code&gt;1.1&lt;/code&gt; or &lt;code&gt;4.0&lt;/code&gt; ; or the &quot;*&quot; can also be &lt;code&gt;Unassigned&lt;/code&gt; . This property will match the code points whose final disposition has been settled as of the Unicode release given by the version number; &lt;code&gt;\p{Present_In: Unassigned}&lt;/code&gt; will match those code points whose meaning has yet to be assigned.</source>
          <target state="translated">上面的&amp;ldquo; *&amp;rdquo;代表两位数字的Unicode版本号，例如 &lt;code&gt;1.1&lt;/code&gt; 或 &lt;code&gt;4.0&lt;/code&gt; ；或&amp;ldquo; *&amp;rdquo;也可以是 &lt;code&gt;Unassigned&lt;/code&gt; 。此属性将匹配由版本号指定的Unicode版本中已确定最终处置的代码点； &lt;code&gt;\p{Present_In: Unassigned}&lt;/code&gt; 将匹配那些尚未分配其含义的代码点。</target>
        </trans-unit>
        <trans-unit id="a22d3668e744bc1f40c2f7d6bd90a8803737c69c" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; character will be replaced with the complete input filename.</source>
          <target state="translated">&quot;*&quot;字符将被替换为完整的输入文件名。</target>
        </trans-unit>
        <trans-unit id="3b9595dacd7d80fdab60d4dc5871376b0675fb8c" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; quantifier is equivalent to &lt;code&gt;{0,}&lt;/code&gt; , the &quot;+&quot; quantifier to &lt;code&gt;{1,}&lt;/code&gt; , and the &quot;?&quot; quantifier to &lt;code&gt;{0,1}&lt;/code&gt; . n and m are limited to non-negative integral values less than a preset limit defined when perl is built. This is usually 32766 on the most common platforms. The actual limit can be seen in the error message generated by code such as this:</source>
          <target state="translated">&amp;ldquo; *&amp;rdquo;量词等效于 &lt;code&gt;{0,}&lt;/code&gt; ，&amp;ldquo; +&amp;rdquo;量词等效于 &lt;code&gt;{1,}&lt;/code&gt; ，而&amp;ldquo;？&amp;rdquo; &lt;code&gt;{0,1}&lt;/code&gt; 的量词。n和m限于非负整数值，该值小于构建perl时定义的预设极限。在最常见的平台上，通常为32766。实际限制可以在由以下代码生成的错误消息中看到：</target>
        </trans-unit>
        <trans-unit id="ef1a900f188939b7338bcc6047d7f99f423bcf86" translate="yes" xml:space="preserve">
          <source>The &quot;:&quot; on these identifiers means simply &quot;process this stuff normally, even though the result will be for some special target&quot;. I suggest that parser APIs report &quot;biblio&quot; as the target identifier, but also report that it had a &quot;:&quot; prefix. (And similarly, with the above &quot;html&quot;, report &quot;html&quot; as the target identifier, and note the</source>
          <target state="translated">这些标识符上的&quot;:&quot;的意思只是 &quot;正常处理这个东西,尽管结果会是为了某个特殊的目标&quot;。我建议解析器API报告 &quot;biblio &quot;作为目标标识符,但也报告它有一个&quot;:&quot;前缀。(同样的,上面的 &quot;html&quot;,报告 &quot;html &quot;作为目标标识符,并注意到它的</target>
        </trans-unit>
        <trans-unit id="64b5d9da126d3d99727eec1708f648b1bd4f7983" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;rules&lt;/code&gt; &quot; data structure is the the heart of the scheduler. It allows you to express simple rules like &quot;run all tests in sequence&quot; or &quot;run all tests in parallel except these five tests.&quot;. However, the rules structure also supports glob-style pattern matching and recursive definitions, so you can also express arbitarily complicated patterns.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;rules&lt;/code&gt; &amp;rdquo;数据结构是调度程序的核心。它允许您表达一些简单的规则，例如&amp;ldquo;依次运行所有测试&amp;rdquo;或&amp;ldquo;并行运行除这五个测试以外的所有测试&amp;rdquo;。但是，规则结构还支持全局样式模式匹配和递归定义，因此您还可以表达任意复杂的模式。</target>
        </trans-unit>
        <trans-unit id="1074d5a9a7dcd2040a3f0c45e46a4676237c27c8" translate="yes" xml:space="preserve">
          <source>The &quot;=begin</source>
          <target state="translated">的&quot;=begin</target>
        </trans-unit>
        <trans-unit id="15a448a46373702e33d38bd4498490c44fd2b70f" translate="yes" xml:space="preserve">
          <source>The &quot;=item [text]&quot; paragraph should not match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\*\s*\z/&lt;/a&gt;&lt;/code&gt;, nor should it match just &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s*\z/&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; = item [text]&amp;rdquo;段不应与 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\*\s*\z/&lt;/a&gt;&lt;/code&gt; 匹配，也不得与它应该只匹配 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s*\z/&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66cea2af4ab6ab309f2a49ef717323c3929bef20" translate="yes" xml:space="preserve">
          <source>The &quot;=pod&quot; command by itself doesn't do much of anything, but it signals to Perl (and Pod formatters) that a Pod block starts here. A Pod block starts with</source>
          <target state="translated">&quot;=pod &quot;命令本身并没有什么作用,但它向Perl(和Pod格式化器)发出了一个Pod块从这里开始的信号。一个Pod块的开头是</target>
        </trans-unit>
        <trans-unit id="45c9bcf242eeaf20585053facd6dddbfcd2e77f0" translate="yes" xml:space="preserve">
          <source>The &quot;English&quot; operators (&lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;xor&lt;/code&gt; , and &lt;code&gt;not&lt;/code&gt; ) deliberately have precedence lower than that of list operators for just such situations as the one above.</source>
          <target state="translated">在&amp;ldquo;英语&amp;rdquo;运营商（ &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; ， &lt;code&gt;xor&lt;/code&gt; ，而 &lt;code&gt;not&lt;/code&gt; ）故意具有优先级比列表操作为这样的情况，如上图所示的低。</target>
        </trans-unit>
        <trans-unit id="00c4bf3828130bdd16f6f681093f66656168cc64" translate="yes" xml:space="preserve">
          <source>The &quot;MIT&quot; License</source>
          <target state="translated">&quot;MIT &quot;许可证</target>
        </trans-unit>
        <trans-unit id="f6804bf4d1b752ec09b4b554040a4294aa2c28e2" translate="yes" xml:space="preserve">
          <source>The &quot;U&quot; mode is modeled on Python's &quot;Universal Newlines&quot; concept, whereby DOS and Mac OS line terminators are converted internally to UNIX newlines before processing. This ensures consistent digest values when working simultaneously across multiple file systems. &lt;b&gt;The &quot;U&quot; mode influences only text files&lt;/b&gt;, namely those passing Perl's</source>
          <target state="translated">&amp;ldquo; U&amp;rdquo;模式以Python的&amp;ldquo; Universal Newlines&amp;rdquo;概念为模型，在此之前，DOS和Mac OS行终止符在处理之前在内部转换为UNIX换行符。这样可以确保在多个文件系统中同时工作时摘要值保持一致。&lt;b&gt;&amp;ldquo; U&amp;rdquo;模式仅影响文本文件&lt;/b&gt;，即那些通过Perl的文件</target>
        </trans-unit>
        <trans-unit id="3825414166fcae7ca1f01fa808eb7b2edebcc1b6" translate="yes" xml:space="preserve">
          <source>The &quot;Unicode Bug&quot;</source>
          <target state="translated">&quot;Unicode Bug&quot;</target>
        </trans-unit>
        <trans-unit id="0ec3a96aade5dbc6ee323c533eb4507821e58ebe" translate="yes" xml:space="preserve">
          <source>The &quot;access&quot; sub-pragma</source>
          <target state="translated">&quot;访问 &quot;子原则</target>
        </trans-unit>
        <trans-unit id="c5bfb037ae6662a8b7a6614931ff100518e1954f" translate="yes" xml:space="preserve">
          <source>The &quot;bad interpreter&quot; message comes from the shell, not perl. The actual message may vary depending on your platform, shell, and locale settings.</source>
          <target state="translated">坏的解释器 &quot;消息来自shell,而不是perl。实际的消息可能会根据你的平台、shell和locale设置而有所不同。</target>
        </trans-unit>
        <trans-unit id="7324c65fe364cafe1f0b648f9b09ee839b62c197" translate="yes" xml:space="preserve">
          <source>The &quot;else if&quot; keyword is spelled &lt;code&gt;elsif&lt;/code&gt; in Perl. There's no &lt;code&gt;elif&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;else&quot;&gt;else&lt;/a&gt; &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;&lt;/code&gt; either. It does parse &lt;code&gt;&lt;a href=&quot;elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt;, but only to warn you about not using it.</source>
          <target state="translated">在Perl中，&amp;ldquo; else if&amp;rdquo;关键字拼写为 &lt;code&gt;elsif&lt;/code&gt; 。没有 &lt;code&gt;elif&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;else&quot;&gt;else&lt;/a&gt; &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;&lt;/code&gt; 没有。它会解析 &lt;code&gt;&lt;a href=&quot;elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt; ，但是只是警告您不要使用它。</target>
        </trans-unit>
        <trans-unit id="dcec7b786aaf98a8eb4d77d89e7fe0ef405e7fc1" translate="yes" xml:space="preserve">
          <source>The &quot;else if&quot; keyword is spelled &lt;code&gt;elsif&lt;/code&gt; in Perl. There's no &lt;code&gt;elif&lt;/code&gt; or &lt;code&gt;else if&lt;/code&gt; either. It does parse &lt;code&gt;&lt;a href=&quot;functions/elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt;, but only to warn you about not using it.</source>
          <target state="translated">在Perl中，&amp;ldquo; else if&amp;rdquo;关键字拼写为 &lt;code&gt;elsif&lt;/code&gt; 。没有 &lt;code&gt;elif&lt;/code&gt; ， &lt;code&gt;else if&lt;/code&gt; 没有。它会解析 &lt;code&gt;&lt;a href=&quot;functions/elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt; ，但是只是警告您不要使用它。</target>
        </trans-unit>
        <trans-unit id="de0a3bbed813bc00b5b829d702e3237f3e106a1b" translate="yes" xml:space="preserve">
          <source>The &quot;fail&quot; attribute can be accessed with the &lt;code&gt;fail_with&lt;/code&gt; method:</source>
          <target state="translated">可以使用 &lt;code&gt;fail_with&lt;/code&gt; 方法访问&amp;ldquo; fail&amp;rdquo;属性：</target>
        </trans-unit>
        <trans-unit id="3cfcc407b9b43637eb6bd977679586bbeebf2328" translate="yes" xml:space="preserve">
          <source>The &quot;grab all you can, and do not give anything back&quot; semantic is desirable in many situations where on the first sight a simple &lt;code&gt;()*&lt;/code&gt; looks like the correct solution. Suppose we parse text with comments being delimited by &lt;code&gt;#&lt;/code&gt; followed by some optional (horizontal) whitespace. Contrary to its appearance, &lt;code&gt;#[ \t]*&lt;/code&gt;</source>
          <target state="translated">在许多情况下，&amp;ldquo;乍看之下，尽力而为，不要回馈&amp;rdquo;语义是可取的，这些情况乍一看，简单的 &lt;code&gt;()*&lt;/code&gt; 看起来像是正确的解决方案。假设我们用 &lt;code&gt;#&lt;/code&gt; 分隔注释，然后加上一些可选的（水平）空格，来解析文本。与外观相反， &lt;code&gt;#[ \t]*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a64504831dda4d8442cac5969f1512970ea2ab8e" translate="yes" xml:space="preserve">
          <source>The &quot;in most cases&quot; hedge is because local TCP state machine behavior may depend on the peer's socket options. In particular, if the peer socket has SO_LINGER enabled with a zero timeout, then the peer's close() will generate a RST segment, upon receipt of which the local TCP transitions immediately to &lt;b&gt;CLOSED&lt;/b&gt;, and in that state, connected()</source>
          <target state="translated">&amp;ldquo;在大多数情况下&amp;rdquo;对冲是因为本地TCP状态机的行为可能取决于对等方的套接字选项。特别是，如果对等套接字启用了SO_LINGER且超时为零，则对等方的close（）将生成一个RST段，在接收到该段后，本地TCP会立即转换为&lt;b&gt;CLOSED&lt;/b&gt;，并且在该状态下为connected（）</target>
        </trans-unit>
        <trans-unit id="97ff934381d4470548d727908956bd70f3d20831" translate="yes" xml:space="preserve">
          <source>The &quot;inode change timestamp&quot; (the &lt;code&gt;-C&lt;/code&gt; filetest) may really be the &quot;creation timestamp&quot; (which it is not in Unix).</source>
          <target state="translated">&amp;ldquo; inode更改时间戳&amp;rdquo;（ &lt;code&gt;-C&lt;/code&gt; filetest）实际上可能是&amp;ldquo;创建时间戳&amp;rdquo;（在Unix中不是）。</target>
        </trans-unit>
        <trans-unit id="d5dae6e25029009f346d93a94005c0b2df86ea03" translate="yes" xml:space="preserve">
          <source>The &quot;interpreter-based threads&quot; provided by Perl are not the fast, lightweight system for multitasking that one might expect or hope for. Threads are implemented in a way that make them easy to misuse. Few people know how to use them correctly or will be able to provide help.</source>
          <target state="translated">Perl提供的 &quot;基于解释器的线程 &quot;并不是人们所期待或希望的快速、轻量级的多任务系统。线程的实现方式使得它们很容易被滥用。很少有人知道如何正确使用它们,或者能够提供帮助。</target>
        </trans-unit>
        <trans-unit id="611cc4fe5613cabb6ac2b4cb6c84bf4897881a2a" translate="yes" xml:space="preserve">
          <source>The &quot;like&quot; code entry is not always an exact rendition. For example, the smartmatch operator short-circuits whenever possible, but &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; does not. Also, &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in scalar context returns the number of matches, but &lt;code&gt;~~&lt;/code&gt; returns only true or false.</source>
          <target state="translated">&amp;ldquo; like&amp;rdquo;代码条目并不总是精确的表示形式。例如，smartmatch运算符会在可能的情况下短路，但 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 不会。同样，标量上下文中的 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 返回匹配的数量，但是 &lt;code&gt;~~&lt;/code&gt; 仅返回true或false。</target>
        </trans-unit>
        <trans-unit id="812d0b36924ed8327e26e7bd66db9f34693b1e0d" translate="yes" xml:space="preserve">
          <source>The &quot;locked&quot; attribute is deprecated, and has no effect in 5.10.0 and later. It was used as part of the now-removed &quot;Perl 5.005 threads&quot;.</source>
          <target state="translated">&quot;locked &quot;属性已被废弃,在5.10.0及以后的版本中没有效果。它曾被用作现已被移除的 &quot;Perl 5.005线程 &quot;的一部分。</target>
        </trans-unit>
        <trans-unit id="9dcce4d393c04df7e129e843600a4cbb41352ba2" translate="yes" xml:space="preserve">
          <source>The &quot;make test&quot; step runs a Perl Verification Procedure, usually before installation. You might encounter STDERR messages even during a successful run of &quot;make test&quot;. Here is a guide to some of the more commonly seen anomalies:</source>
          <target state="translated">&quot;make test &quot;步骤通常在安装前运行Perl验证过程。即使在成功运行 &quot;make test &quot;期间,你也可能会遇到STDERR消息。下面是一些比较常见的异常情况的指南。</target>
        </trans-unit>
        <trans-unit id="c90503a55170e15efc4d9ae431c0e36ee6a25e33" translate="yes" xml:space="preserve">
          <source>The &quot;maketext&quot; Method</source>
          <target state="translated">&quot;maketext &quot;方法</target>
        </trans-unit>
        <trans-unit id="7968697304f2035aa2639422d611288498d75cab" translate="yes" xml:space="preserve">
          <source>The &quot;mro&quot; namespace provides several utilities for dealing with method resolution order and method caching in general.</source>
          <target state="translated">mro &quot;命名空间为处理方法解析顺序和一般的方法缓存提供了几个实用程序。</target>
        </trans-unit>
        <trans-unit id="71bf414e13a483c3f8866e169ca7ae68644d2c78" translate="yes" xml:space="preserve">
          <source>The &quot;next&quot; pointers of all regops except &lt;code&gt;BRANCH&lt;/code&gt; implement concatenation; a &quot;next&quot; pointer with a &lt;code&gt;BRANCH&lt;/code&gt; on both ends of it is connecting two alternatives. [Here we have one of the subtle syntax dependencies: an individual &lt;code&gt;BRANCH&lt;/code&gt; (as opposed to a collection of them) is never concatenated with anything because of operator precedence.]</source>
          <target state="translated">除 &lt;code&gt;BRANCH&lt;/code&gt; 之外，所有重新绑定的&amp;ldquo; next&amp;rdquo;指针都实现了串联。两端带有 &lt;code&gt;BRANCH&lt;/code&gt; 的&amp;ldquo;下一个&amp;rdquo;指针正在连接两个替代项。[这里我们有一个微妙的语法依赖关系：由于运算符的优先级，单个 &lt;code&gt;BRANCH&lt;/code&gt; （而不是它们的集合）从未与任何东西连接在一起。</target>
        </trans-unit>
        <trans-unit id="7475859558b8ac99b6dbae28949b5ee5991af403" translate="yes" xml:space="preserve">
          <source>The &quot;p&quot; mode differs from &quot;U&quot; only in that it treats &quot;\r\r\n&quot; as a single newline, a quirky feature designed to accommodate legacy applications that occasionally added an extra carriage return before DOS line terminators. The &quot;p&quot; mode will be phased out eventually in favor of the cleaner and more well-established Universal Newlines concept.</source>
          <target state="translated">&quot;p &quot;模式与 &quot;U &quot;模式的不同之处仅在于它将&quot;/rr/rr/n &quot;作为一个新行来处理,这是一个奇特的功能,目的是为了适应传统的应用程序,这些应用程序有时会在DOS行结束符前增加一个额外的回车。&quot;p &quot;模式最终将被淘汰,取而代之的是更简洁、更完善的通用新行概念。</target>
        </trans-unit>
        <trans-unit id="21a4e20c8659f7cc84f2dc6e2b2235449667f421" translate="yes" xml:space="preserve">
          <source>The &quot;prototype&quot; attribute is an alternate means of specifying a prototype on a sub. The desired prototype is within the parens.</source>
          <target state="translated">prototype &quot;属性是在子上指定原型的另一种方式。所需的原型在parens中。</target>
        </trans-unit>
        <trans-unit id="dd5b998a91e6bf19722acfe03146f25538072352" translate="yes" xml:space="preserve">
          <source>The &quot;quality&quot; of a hash is defined as the total number of comparisons needed to access every element once, relative to the expected number needed for a random hash. The value can go over 100%.</source>
          <target state="translated">哈希的 &quot;质量 &quot;定义为:相对于随机哈希所需的预期数量,每一个元素访问一次所需的比较总数。该值可以超过100%。</target>
        </trans-unit>
        <trans-unit id="0fa71c4992e21ca9d0f8816931658731741f8823" translate="yes" xml:space="preserve">
          <source>The &quot;root&quot; of the namespace (i.e. &quot;main::&quot;) is changed to a different package and code evaluated in the compartment cannot refer to variables outside this namespace, even with run-time glob lookups and other tricks.</source>
          <target state="translated">命名空间的 &quot;根&quot;(即 &quot;main::&quot;)被改成了不同的包,在分格中评估的代码不能引用这个命名空间之外的变量,即使使用运行时的glob查找和其他技巧。</target>
        </trans-unit>
        <trans-unit id="40e9eeb816659a4d78537c8ea14e7c775679daaf" translate="yes" xml:space="preserve">
          <source>The &quot;status value&quot; returned in &lt;code&gt;$?&lt;/code&gt; is synthesized from the actual exit status of the subprocess in a way that approximates POSIX wait(5) semantics, in order to allow Perl programs to portably test for successful completion of subprocesses. The low order 8 bits of &lt;code&gt;$?&lt;/code&gt; are always 0 under VMS, since the termination status of a process may or may not have been generated by an exception.</source>
          <target state="translated">以&amp;ldquo; &lt;code&gt;$?&lt;/code&gt; &amp;rdquo;返回的&amp;ldquo;状态值&amp;rdquo; ？通过近似于POSIX wait（5）语义的方式，从子流程的实际退出状态中合成出来，以允许Perl程序可移植地测试子流程的成功完成。 &lt;code&gt;$?&lt;/code&gt; 的低8位 在VMS下，始终为0，因为异常可能已生成或可能未生成进程的终止状态。</target>
        </trans-unit>
        <trans-unit id="9220e93c05c2e58fcb6c44f1b19d591bad6f075c" translate="yes" xml:space="preserve">
          <source>The &quot;unique&quot; attribute is deprecated, and has no effect in 5.10.0 and later. It used to indicate that a single copy of an &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; variable was to be used by all interpreters should the program happen to be running in a multi-interpreter environment.</source>
          <target state="translated">&amp;ldquo; unique&amp;rdquo;属性已弃用，在5.10.0及更高版本中无效。它曾经表示如果程序恰好在多解释器环境中运行，则所有解释器都将使用 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 变量的单个副本。</target>
        </trans-unit>
        <trans-unit id="72e1eabd61e84fec8e9b71e8964b6733954ac85d" translate="yes" xml:space="preserve">
          <source>The &quot;use locale&quot; pragma</source>
          <target state="translated">&quot;使用locale &quot;pragma</target>
        </trans-unit>
        <trans-unit id="127c26381686cdc6cb6db8e06a75ac1b05a13d0e" translate="yes" xml:space="preserve">
          <source>The #endif and #else cannot portably have anything non-comment after them. If you want to document what is going (which is a good idea especially if the branches are long), use (C) comments:</source>
          <target state="translated">在#endif和#else后面不能有任何非注释的东西。如果你想记录正在发生的事情(这是一个好主意,尤其是当分支很长的时候),使用(C)注释。</target>
        </trans-unit>
        <trans-unit id="6d394482dea20b84087d97ed59f1a7ab0353698f" translate="yes" xml:space="preserve">
          <source>The $algorithm is a string like &quot;MD2&quot;, &quot;MD5&quot;, &quot;SHA-1&quot;, &quot;SHA-512&quot;. Additional arguments are passed to the constructor for the implementation of the given algorithm.</source>
          <target state="translated">算法是一个字符串,如 &quot;MD2&quot;、&quot;MD5&quot;、&quot;SHA-1&quot;、&quot;SHA-512&quot;。额外的参数被传递给构造函数,用于实现给定算法。</target>
        </trans-unit>
        <trans-unit id="060c7393d1a230b15152f168cb6702d886a2c8e8" translate="yes" xml:space="preserve">
          <source>The $always_copy parameter which when true causes files to be updated regardless as to whether they have changed, if it is defined but false then copies are made only if the files have changed, if it is undefined then the value of the environment variable EU_INSTALL_ALWAYS_COPY is used as default.</source>
          <target state="translated">当$always_copy参数为true时,无论文件是否发生变化都会被更新,如果定义为false,那么只有当文件发生变化时才会进行拷贝,如果未定义,那么环境变量EU_INSTALL_ALWAYS的值为默认值。</target>
        </trans-unit>
        <trans-unit id="2195889fc63370a441ff8bf1c8a9db960470ff14" translate="yes" xml:space="preserve">
          <source>The $buffer should be a Storable image or the first few bytes of it. If $buffer starts with a Storable header, then a hash describing the image is returned, otherwise &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">$ buffer应该是可存储映像或它的前几个字节。如果$ buffer以Storable头开头，则返回描述该图像的哈希，否则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45f3f95232308dda6cf28aa29e85f72c7757c618" translate="yes" xml:space="preserve">
          <source>The $data provided as argument are appended to the message we calculate the digest for. The return value is the $md5 object itself.</source>
          <target state="translated">作为参数提供的$data被附加到我们计算摘要的消息中。返回值是$md5对象本身。</target>
        </trans-unit>
        <trans-unit id="0b852897867aa68fb0b59cef6457c36880f5fe89" translate="yes" xml:space="preserve">
          <source>The $f that has &quot;bar&quot; added to it three times should be a new &lt;code&gt;$f&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; should create a new lexical variable each time through the loop. The expected output is:</source>
          <target state="translated">添加了&amp;ldquo; bar&amp;rdquo; 3次的 &lt;code&gt;$f&lt;/code&gt; 应该是一个新的$ f &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; 应该在循环中每次创建一个新的词法变量。预期的输出是：</target>
        </trans-unit>
        <trans-unit id="1718e632a613e4c3f044b1d3a129d6229eab251a" translate="yes" xml:space="preserve">
          <source>The $filename parameter is used by Perl to identify the source file for the function if required by die(), caller() or the debugger. If $filename is not defined then &quot;DynaLoader&quot; will be used.</source>
          <target state="translated">如果die()、caller()或debugger需要,$filename参数被Perl用来识别函数的源文件。如果没有定义$filename,那么将使用 &quot;DynaLoader&quot;。</target>
        </trans-unit>
        <trans-unit id="84c0a13d8949255c1b3abd5830e5bb4ca9af26b0" translate="yes" xml:space="preserve">
          <source>The $flags argument to alters dl_load_file behaviour. Assigned bits:</source>
          <target state="translated">改变dl_load_file行为的$flags参数。赋值位。</target>
        </trans-unit>
        <trans-unit id="fd706f4aac9bb23ac72e5f391e9438d3b6687fe7" translate="yes" xml:space="preserve">
          <source>The $io_handle is read until EOF and the content is appended to the message we calculate the digest for. The return value is the $ctx object itself.</source>
          <target state="translated">$io_handle被读取,直到EOF,其内容被追加到我们计算摘要的消息中。返回值是$ctx对象本身。</target>
        </trans-unit>
        <trans-unit id="f48497c09ab813ab9f670545e1d053cf6b1c4105" translate="yes" xml:space="preserve">
          <source>The $io_handle will be read until EOF and its content appended to the message we calculate the digest for. The return value is the $md5 object itself.</source>
          <target state="translated">$io_handle 将被读取,直到 EOF,并将其内容附加到我们计算摘要的消息中。返回值是$md5对象本身。</target>
        </trans-unit>
        <trans-unit id="73b7765fc89db094ffe9099cbf5e1b07621f5606" translate="yes" xml:space="preserve">
          <source>The $keep argument is a boolean flag. If true, then the tokens are split on the specified delimiter, but all other characters (including quotes and backslashes) are kept in the tokens. If $keep is false then the &amp;amp;*quotewords() functions remove all quotes and backslashes that are not themselves backslash-escaped or inside of single quotes (i.e., &amp;amp;quotewords() tries to interpret these characters just like the Bourne shell). NB: these semantics are significantly different from the original version of this module shipped with Perl 5.000 through 5.004. As an additional feature, $keep may be the keyword &quot;delimiters&quot; which causes the functions to preserve the delimiters in each string as tokens in the token lists, in addition to preserving quote and backslash characters.</source>
          <target state="translated">$ keep参数是一个布尔标志。如果为true，则会在指定的分隔符上分割标记，但所有其他字符（包括引号和反斜杠）都保留在标记中。如果$ keep为false，则＆* quotewords（）函数会删除所有本身并非反斜杠转义或在单引号内的引号和反斜杠（即，＆quotewords（）试图像解释Bourne shell一样解释这些字符）。注意：这些语义与Perl 5.000至5.004附带的该模块的原始版本有很大不同。作为附加功能，$ keep可能是关键字&amp;ldquo;定界符&amp;rdquo;，它使函数除了保留引号和反斜杠字符外，还将每个字符串中的定界符保留为标记列表中的标记。</target>
        </trans-unit>
        <trans-unit id="4e5f5797e7dfa3a15e15f61203e30952d45673d5" translate="yes" xml:space="preserve">
          <source>The $members value returned by</source>
          <target state="translated">返回的$members值</target>
        </trans-unit>
        <trans-unit id="ea59b84534455476bdc42448f750e6798f5fa6a2" translate="yes" xml:space="preserve">
          <source>The %result hash will be populated with the various keys/subhashes reflecting the install. Currently these keys and their structure are:</source>
          <target state="translated">%result哈希值将被各种反映安装情况的键/子哈希值所填充。目前,这些键和它们的结构是:</target>
        </trans-unit>
        <trans-unit id="eb2003a4836fd23e3d85388f2cbd39901c6bc22d" translate="yes" xml:space="preserve">
          <source>The &amp;amp; Unary Operator</source>
          <target state="translated">一元运算符</target>
        </trans-unit>
        <trans-unit id="ddb7807e2ac7fcb7b1862d48b33f4bdc45bd2c34" translate="yes" xml:space="preserve">
          <source>The &amp;amp;&amp;amp; problem</source>
          <target state="translated">问题</target>
        </trans-unit>
        <trans-unit id="4101646effcfa6c9b3723eeb19290b923da87717" translate="yes" xml:space="preserve">
          <source>The &amp;amp;&amp;amp; problem.</source>
          <target state="translated">问题。</target>
        </trans-unit>
        <trans-unit id="819c8af579e67bbf16b0d43d190eb1e52a12ff6c" translate="yes" xml:space="preserve">
          <source>The &amp;amp;nested_quotewords() and &amp;amp;quotewords() functions accept a delimiter (which can be a regular expression) and a list of lines and then breaks those lines up into a list of words ignoring delimiters that appear inside quotes. &amp;amp;quotewords() returns all of the tokens in a single long list, while &amp;amp;nested_quotewords() returns a list of token lists corresponding to the elements of @lines. &amp;amp;parse_line() does tokenizing on a single string. The &amp;amp;*quotewords() functions simply call &amp;amp;parse_line(), so if you're only splitting one line you can call &amp;amp;parse_line() directly and save a function call.</source>
          <target state="translated">＆nested_quotewords（）和quotewords（）函数接受定界符（可以是正则表达式）和行列表，然后将这些行分解为单词列表，而忽略出现在引号内的定界符。＆quotewords（）返回单个长列表中的所有标记，而＆nested_quotewords（）返回对应于@lines元素的标记列表的列表。＆parse_line（）对单个字符串进行标记化。＆* quotewords（）函数只需调用＆parse_line（），因此，如果仅拆分一行，则可以直接调用＆parse_line（）并保存函数调用。</target>
        </trans-unit>
        <trans-unit id="9c87ced9da37d8df457e1116fcc0073fb1557eae" translate="yes" xml:space="preserve">
          <source>The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered.</source>
          <target state="translated">&amp;lt;-HERE在正则表达式中显示发现问题的行踪。</target>
        </trans-unit>
        <trans-unit id="c4f590c76222edc7a4139c10a801899ef6080952" translate="yes" xml:space="preserve">
          <source>The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">&amp;lt;-HERE在正则表达式中显示发现问题的行踪。参见&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5bf8f7c8c4159c0583c72496084082131f49306a" translate="yes" xml:space="preserve">
          <source>The &amp;lt;FH&amp;gt; construct is not the name of the filehandle, it is a readline operation on that handle. The data read is assigned to $_ only if the file read is the sole condition in a while loop:</source>
          <target state="translated">&amp;lt;FH&amp;gt;构造不是文件句柄的名称，它是该句柄上的readline操作。仅当在while循环中读取的文件是唯一条件时，才将读取的数据分配给$ _：</target>
        </trans-unit>
        <trans-unit id="ab73cfd3e43216b54a963f39932451a527bcc6a3" translate="yes" xml:space="preserve">
          <source>The '&lt;b&gt;-w&lt;/b&gt;' switch would have told us about this, had we used it at the start, and saved us a lot of trouble:</source>
          <target state="translated">如果我们一开始就使用它，那么&lt;b&gt;-w&lt;/b&gt;开关会告诉我们这一点，并为我们节省了很多麻烦：</target>
        </trans-unit>
        <trans-unit id="bd6318c738360c72f699370e44631e5d478a985b" translate="yes" xml:space="preserve">
          <source>The 'array_base' feature</source>
          <target state="translated">array_base &quot;功能</target>
        </trans-unit>
        <trans-unit id="0d3b66a213047641035eea0c1bcf8c880d1b087a" translate="yes" xml:space="preserve">
          <source>The 'bitwise' feature</source>
          <target state="translated">位元 &quot;功能</target>
        </trans-unit>
        <trans-unit id="3a5d26aebe5343fcb8365359fdfecbe6a1f9ce93" translate="yes" xml:space="preserve">
          <source>The 'bval' Option</source>
          <target state="translated">bval &quot;选项</target>
        </trans-unit>
        <trans-unit id="e00309e30b37c032e9723d99c993712660e13d4a" translate="yes" xml:space="preserve">
          <source>The 'current_sub' feature</source>
          <target state="translated">'current_sub'功能</target>
        </trans-unit>
        <trans-unit id="6c052a5c9bdb1ba3c0df3df62a320e47a9bd25cd" translate="yes" xml:space="preserve">
          <source>The 'd' and the 'm' command normally only show you information they have in their in-memory database and thus will never connect to the internet. If you set the 'show_upload_date' variable to true, 'm' and 'd' will additionally show you the upload date of the module or distribution. Per default this feature is off because it may require a net connection to get at the upload date.</source>
          <target state="translated">d'和'm'命令通常只向您显示他们在内存数据库中的信息,因此不会连接到互联网。如果您将'show_upload_date'变量设置为true,'m'和'd'将额外显示模块或发行版的上传日期。默认情况下,这个功能是关闭的,因为它可能需要网络连接来获取上传日期。</target>
        </trans-unit>
        <trans-unit id="c6e825d609e1bdb12613a2765369452bfb2902c9" translate="yes" xml:space="preserve">
          <source>The 'fc' feature</source>
          <target state="translated">fc &quot;功能</target>
        </trans-unit>
        <trans-unit id="c532c19d0965a864c1673a10c98911020476e550" translate="yes" xml:space="preserve">
          <source>The 'hushed' flag has a global scope during compilation: the exit() or die() commands that are compiled after 'vmsish hushed' will be hushed when they are executed. Doing a &quot;no vmsish 'hushed'&quot; turns off the hushed flag.</source>
          <target state="translated">在编译过程中,'hushed'标志有一个全局范围:在'vmsish hushed'之后编译的exit()或die()命令在执行时将会变成hushed。执行 &quot;no vmsish 'hushed'&quot;会关闭hushed标志。</target>
        </trans-unit>
        <trans-unit id="476d927d17a3d46a0ed772d0abdb4399c93a366e" translate="yes" xml:space="preserve">
          <source>The 'lexical_subs' feature</source>
          <target state="translated">lexical_subs &quot;功能。</target>
        </trans-unit>
        <trans-unit id="d15b2cae0ecbb384e6a16c159b73754a15b73452" translate="yes" xml:space="preserve">
          <source>The 'postderef' and 'postderef_qq' features</source>
          <target state="translated">postderef &quot;和 &quot;postderef_qq &quot;的特点。</target>
        </trans-unit>
        <trans-unit id="032a279126f29bd2ca1a4d576f6688e5bd0a4721" translate="yes" xml:space="preserve">
          <source>The 'postderef' feature allows the use of &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;postfix dereference syntax&lt;/a&gt;. For example, it will make the following two statements equivalent:</source>
          <target state="translated">&amp;ldquo; postderef&amp;rdquo;功能允许使用&lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;后缀解除引用语法&lt;/a&gt;。例如，它将使以下两个语句等效：</target>
        </trans-unit>
        <trans-unit id="72039153ef5da3a0b8c844ea7ff1d46ddb7f3f43" translate="yes" xml:space="preserve">
          <source>The 'postderef_qq' feature extends this, for array and scalar dereference, to working inside of double-quotish interpolations.</source>
          <target state="translated">postderef_qq'功能扩展了这一点,对于数组和标量的减法,可以在双商数内插中工作。</target>
        </trans-unit>
        <trans-unit id="1856b511545a836fd1960f70b611782e60e03174" translate="yes" xml:space="preserve">
          <source>The 'refaliasing' feature</source>
          <target state="translated">反锯齿 &quot;功能</target>
        </trans-unit>
        <trans-unit id="43acd92859b0081e26405b0092a9e001da38bcb0" translate="yes" xml:space="preserve">
          <source>The 'say' feature</source>
          <target state="translated">说 &quot;功能</target>
        </trans-unit>
        <trans-unit id="48c11f3663366e7407088877b28bc4e952cd3e8c" translate="yes" xml:space="preserve">
          <source>The 'signatures' feature</source>
          <target state="translated">签名 &quot;功能</target>
        </trans-unit>
        <trans-unit id="1ef5c6a6bc489a315173331d45afe7880d296d9b" translate="yes" xml:space="preserve">
          <source>The 'state' feature</source>
          <target state="translated">状态 &quot;功能</target>
        </trans-unit>
        <trans-unit id="0202f826bf3e7b7586cfc812c13b1dfe89d2bf49" translate="yes" xml:space="preserve">
          <source>The 'switch' feature</source>
          <target state="translated">开关 &quot;功能</target>
        </trans-unit>
        <trans-unit id="7029a8b5bd568b6e4297fb88434b17a5f75b3a17" translate="yes" xml:space="preserve">
          <source>The 'unicode_eval' and 'evalbytes' features</source>
          <target state="translated">unicode_eval &quot;和 &quot;evalbytes &quot;功能。</target>
        </trans-unit>
        <trans-unit id="e493b49d6dbbae3a5be3b8f2dff13d8ec26ef7db" translate="yes" xml:space="preserve">
          <source>The 'unicode_strings' feature</source>
          <target state="translated">unicode_strings &quot;功能。</target>
        </trans-unit>
        <trans-unit id="0f31ae17f71ba4abf6738dd8a78689f3b1ddbaf2" translate="yes" xml:space="preserve">
          <source>The -Dprefix option will install Perl in a directory parallel to the IBM AIX system Perl installation.</source>
          <target state="translated">选项-Dprefix将把Perl安装在与IBM AIX系统Perl安装平行的目录中。</target>
        </trans-unit>
        <trans-unit id="3bc3be0ef0e3e9886678cc868f1c296c736baaaa" translate="yes" xml:space="preserve">
          <source>The .c files will automatically be included in the list of files deleted by a make clean.</source>
          <target state="translated">.c文件将自动包含在被make clean删除的文件列表中。</target>
        </trans-unit>
        <trans-unit id="eaa1f52ae3c132b312829a1a099fb15cc4451f8a" translate="yes" xml:space="preserve">
          <source>The .i Targets</source>
          <target state="translated">.i目标</target>
        </trans-unit>
        <trans-unit id="c5957baac4fddeea5c92174eefc52a682210436d" translate="yes" xml:space="preserve">
          <source>The .netrc file contains login and initialization information used by the auto-login process. It resides in the user's home directory. The following tokens are recognized; they may be separated by spaces, tabs, or new-lines:</source>
          <target state="translated">.netrc文件包含自动登录进程使用的登录和初始化信息。它位于用户的主目录中。识别下列标记;它们可以用空格、制表符或换行来分隔:</target>
        </trans-unit>
        <trans-unit id="54f9e8c707fce1b5fb29121fecf5b3c5f6fb75cd" translate="yes" xml:space="preserve">
          <source>The .pm and .xs files contain the meat of the extension. The .xs file holds the C routines that make up the extension. The .pm file contains routines that tell Perl how to load your extension.</source>
          <target state="translated">.pm和.xs文件包含了扩展名的内容。.xs 文件包含构成扩展名的 C 例程。.pm 文件包含告诉 Perl 如何加载扩展名的例程。</target>
        </trans-unit>
        <trans-unit id="dd2519bf881a43a692b68b1c0e909064ae51fbd0" translate="yes" xml:space="preserve">
          <source>The .pm file originally exported the name &lt;code&gt;TESTVAL&lt;/code&gt; in the &lt;code&gt;@EXPORT&lt;/code&gt; array. This could lead to name clashes. A good rule of thumb is that if the #define is only going to be used by the C routines themselves, and not by the user, they should be removed from the &lt;code&gt;@EXPORT&lt;/code&gt; array. Alternately, if you don't mind using the &quot;fully qualified name&quot; of a variable, you could move most or all of the items from the &lt;code&gt;@EXPORT&lt;/code&gt; array into the &lt;code&gt;@EXPORT_OK&lt;/code&gt; array.</source>
          <target state="translated">.pm文件最初在 &lt;code&gt;@EXPORT&lt;/code&gt; 数组中导出名称 &lt;code&gt;TESTVAL&lt;/code&gt; 。这可能导致名称冲突。一个好的经验法则是，如果#define仅由C例程本身使用，而不由用户使用，则应将它们从 &lt;code&gt;@EXPORT&lt;/code&gt; 数组中删除。或者，如果您不介意使用变量的&amp;ldquo;完全限定名称&amp;rdquo;，则可以将大多数或所有项目从 &lt;code&gt;@EXPORT&lt;/code&gt; 数组移至 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 数组。</target>
        </trans-unit>
        <trans-unit id="e7ef13c3a85e7562d01716fd477e5df2797f8e0b" translate="yes" xml:space="preserve">
          <source>The .xs file of &lt;a href=&quot;#EXAMPLE-4&quot;&gt;EXAMPLE 4&lt;/a&gt; contained some new elements. To understand the meaning of these elements, pay attention to the line which reads</source>
          <target state="translated">&lt;a href=&quot;#EXAMPLE-4&quot;&gt;示例4&lt;/a&gt;的.xs文件包含一些新元素。要了解这些元素的含义，请注意以下内容：</target>
        </trans-unit>
        <trans-unit id="9a412534f9637df17d083fc0dd838ed8c9b7cead" translate="yes" xml:space="preserve">
          <source>The /usr/bin/perl is obvious (hopefully).</source>
          <target state="translated">/usr/bin/perl是显而易见的(希望如此)。</target>
        </trans-unit>
        <trans-unit id="b90c8fc76aaca137d93e66aec85f8cb2eec3fed5" translate="yes" xml:space="preserve">
          <source>The 0th entry of the PADLIST is a PADNAMELIST which represents the &quot;names&quot; or rather the &quot;static type information&quot; for lexicals. The individual elements of a PADNAMELIST are PADNAMEs. Future refactorings might stop the PADNAMELIST from being stored in the PADLIST's array, so don't rely on it. See &lt;a href=&quot;#PadlistNAMES&quot;&gt;PadlistNAMES&lt;/a&gt;.</source>
          <target state="translated">PADLIST的第0个条目是PADNAMELIST，它表示词汇的&amp;ldquo;名称&amp;rdquo;或&amp;ldquo;静态类型信息&amp;rdquo;。PADNAMELIST的各个元素是PADNAME。将来的重构可能会使PADNAMELIST停止存储在PADLIST的数组中，因此请不要依赖它。参见&lt;a href=&quot;#PadlistNAMES&quot;&gt;PadlistNAMES&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0c98b5db329af061627f1088cd649948958ceb6" translate="yes" xml:space="preserve">
          <source>The 1 or 2 rows of numbers following that correspond to the number of buckets of each size between &lt;code&gt;SMALLEST&lt;/code&gt; and &lt;code&gt;GREATEST&lt;/code&gt; . In the first row, the sizes (memory footprints) of buckets are powers of two--or possibly one page greater. In the second row, if present, the memory footprints of the buckets are between the memory footprints of two buckets &quot;above&quot;.</source>
          <target state="translated">后面的1或2行数字，对应于 &lt;code&gt;SMALLEST&lt;/code&gt; 和 &lt;code&gt;GREATEST&lt;/code&gt; 之间每个大小的存储桶数。在第一行中，存储桶的大小（内存占用空间）是2的幂，或者可能大1页。在第二行中（如果存在），存储桶的内存占用空间位于&amp;ldquo;上方&amp;rdquo;的两个存储桶的内存占用空间之间。</target>
        </trans-unit>
        <trans-unit id="474f74fc74e6b97d1b22c49840ad80fdd2b7a470" translate="yes" xml:space="preserve">
          <source>The 1-argument form of cacheout will open a file for writing (&lt;code&gt;'&amp;gt;'&lt;/code&gt; ) on it's first use, and appending (&lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; ) thereafter.</source>
          <target state="translated">缓存的1参数形式将在第一次使用时打开一个文件进行写入（ &lt;code&gt;'&amp;gt;'&lt;/code&gt; ），然后在其后附加（ &lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ece20b2e43644dc279ab7b6d2adb512919e3c93c" translate="yes" xml:space="preserve">
          <source>The 13 variant characters</source>
          <target state="translated">13个异体字</target>
        </trans-unit>
        <trans-unit id="a9393cb211cfe66570248ab99ec7632708f22fae" translate="yes" xml:space="preserve">
          <source>The 1st column is the op's sequence number, starting at 1, and is displayed in base 36 by default. Here they're purely linear; the sequences are very helpful when looking at code with loops and branches.</source>
          <target state="translated">第1列是操作的序列号,从1开始,默认显示为36基。在这里,它们是纯线性的;在查看有循环和分支的代码时,序列非常有用。</target>
        </trans-unit>
        <trans-unit id="004f29b5a23df31b01d8aa7e1fc9952890ebb7d2" translate="yes" xml:space="preserve">
          <source>The 2-argument form of cacheout will use the supplied mode for the initial and subsequent openings. Most valid modes for 3-argument &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; are supported namely; &lt;code&gt;'&amp;gt;'&lt;/code&gt; , &lt;code&gt;'+&amp;gt;'&lt;/code&gt; , &lt;code&gt;'&amp;lt;'&lt;/code&gt; , &lt;code&gt;'&amp;lt;+'&lt;/code&gt; , &lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; , &lt;code&gt; '|-' &lt;/code&gt; and &lt;code&gt; '-|' &lt;/code&gt;</source>
          <target state="translated">缓存的2参数形式将使用提供的模式进行初始和后续打开。支持三参数 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 最有效模式： &lt;code&gt;'&amp;gt;'&lt;/code&gt; ， &lt;code&gt;'+&amp;gt;'&lt;/code&gt; ， &lt;code&gt;'&amp;lt;'&lt;/code&gt; ， &lt;code&gt;'&amp;lt;+'&lt;/code&gt; ， &lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; ， &lt;code&gt; '|-' &lt;/code&gt; 和 &lt;code&gt; '-|' &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="11ff8f169a4e9a0d5e765f1f57d4ab8242fb17bb" translate="yes" xml:space="preserve">
          <source>The 256-color control sequences are documented at &lt;a href=&quot;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html&quot;&gt;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html&lt;/a&gt; (search for 256-color).</source>
          <target state="translated">256色控制序列记录在&lt;a href=&quot;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html&quot;&gt;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html&lt;/a&gt;（搜索256色）中。</target>
        </trans-unit>
        <trans-unit id="b81b42d9c2528e2e2cc53554ea82b10b2357c0c7" translate="yes" xml:space="preserve">
          <source>The :browse tag represents the next step beyond :default. It it a superset of the :default ops and adds :filesys_read the :sys_db. The intent being that scripts can access more (possibly sensitive) information about your system but not be able to change it.</source>
          <target state="translated">浏览标签代表了 :default 之后的下一个步骤,它是 :default 操作的超集,并增加了 :filesys_read 和 :sys_db。它是 :default ops 的超集,并增加了 :filesys_read 和 :sys_db。这样做的目的是让脚本可以访问更多的(可能是敏感的)系统信息,但不能改变它。</target>
        </trans-unit>
        <trans-unit id="913829e3b140a41628c9596982f027a8f2285b7a" translate="yes" xml:space="preserve">
          <source>The :locale sub-pragma</source>
          <target state="translated">:locale子原则</target>
        </trans-unit>
        <trans-unit id="d85820f28213c3599595658668ce44deb0578d4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Extended-Grapheme-Clusters-(Logical-characters)&quot;&gt;Extended Grapheme Clusters (Logical characters)&lt;/a&gt; section above talked about canonical decompositions. However, many more characters have a different type of decomposition, a &quot;compatible&quot; or &quot;non-canonical&quot; decomposition. The sequences that form these decompositions are not considered canonically equivalent to the pre-composed character. An example is the &lt;code&gt;&quot;SUPERSCRIPT ONE&quot;&lt;/code&gt; . It is somewhat like a regular digit 1, but not exactly; its decomposition into the digit 1 is called a &quot;compatible&quot; decomposition, specifically a &quot;super&quot; decomposition. There are several such compatibility decompositions (see &lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44&lt;/a&gt;), including one called &quot;compat&quot;, which means some miscellaneous type of decomposition that doesn't fit into the other decomposition categories that Unicode has chosen.</source>
          <target state="translated">上面的&lt;a href=&quot;#Extended-Grapheme-Clusters-(Logical-characters)&quot;&gt;扩展字素簇（逻辑字符）&lt;/a&gt;部分讨论了规范分解。但是，更多字符具有不同类型的分解，即&amp;ldquo;兼容&amp;rdquo;或&amp;ldquo;非规范&amp;rdquo;分解。形成这些分解的序列不被认为等同于预先组成的字符。一个示例是 &lt;code&gt;&quot;SUPERSCRIPT ONE&quot;&lt;/code&gt; 。它有点像常规数字1，但不完全相同。其分解为数字1的过程称为&amp;ldquo;兼容&amp;rdquo;分解，特别是&amp;ldquo;超级&amp;rdquo;分解。有几种这样的兼容性分解（请参见&lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44&lt;/a&gt;），包括一个称为&amp;ldquo; compat&amp;rdquo;的符号，这意味着某些杂项分解类型不适合Unicode选择的其他分解类别。</target>
        </trans-unit>
        <trans-unit id="6f116e91479173f83f0ee6321a3113bbe8db276b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt; function is unsuitable for hashing large quantities of data, not least of all because you can't get the information back. Look at the &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; module for more robust algorithms.</source>
          <target state="translated">该&lt;a href=&quot;#crypt&quot;&gt;墓穴&lt;/a&gt;功能不适用于散列大量并非最不重要的所有数据，因为你不能得到信息反馈。查看&lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt;模块以获取更强大的算法。</target>
        </trans-unit>
        <trans-unit id="8854fb6583fec2754cd3983ea80d85f9b0022749" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the bidi type name.</source>
          <target state="translated">该&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;函数可用于获取比迪烟的类型名称的所有同义词。</target>
        </trans-unit>
        <trans-unit id="76a16bb68fd364d030e4901c8f1d916862b53339" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the category name.</source>
          <target state="translated">该&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;函数可用于获取类别名称的所有同义词。</target>
        </trans-unit>
        <trans-unit id="2277466bc19ae0c38a8069cd1ac99be48d5794e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the combining class number.</source>
          <target state="translated">该&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;函数可用于获取组合类号码的所有同义词。</target>
        </trans-unit>
        <trans-unit id="d0d02ad47d23ca3616a65821c3a3e94a1c4a3210" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short bidi type names; and the second gets all the synonyms of a given bidi type name.</source>
          <target state="translated">所述&lt;a href=&quot;#prop_values()&quot;&gt;prop_values（）&lt;/a&gt;和&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;函数可以被用作替代该功能; 第一个返回简短的比迪烟类型名称的简单列表；第二个获取给定的比迪烟类型名称的所有同义词。</target>
        </trans-unit>
        <trans-unit id="ff1836f9843147fc775222ff3469395bcf43b303" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short category names; and the second gets all the synonyms of a given category name.</source>
          <target state="translated">所述&lt;a href=&quot;#prop_values()&quot;&gt;prop_values（）&lt;/a&gt;和&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;函数可以被用作替代该功能; 第一个返回简短类别名称的简单列表；第二个获取给定类别名称的所有同义词。</target>
        </trans-unit>
        <trans-unit id="8295b9c404465c68e21720ae88623e9c9b91d667" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist()&lt;/a&gt; function is provided for finding a code point within an inversion list.</source>
          <target state="translated">提供&lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist（）&lt;/a&gt;函数用于在反转列表中查找代码点。</target>
        </trans-unit>
        <trans-unit id="a99fc3c1e89a0b4e840a4661bca0de0880d27694" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../file/stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="translated">该&lt;a href=&quot;../file/stat&quot;&gt;文件::统计&lt;/a&gt;模块提供了便利，通过名字访问的机制：</target>
        </trans-unit>
        <trans-unit id="f74e082436b86f6a01a3f1c31662df75f43fb323" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; does not use a formal grammar because TAP is essentially a stream-based protocol. In fact, it's quite legal to have an infinite stream. For the same reason that we don't apply regexes to streams, we're not using a formal grammar here. Instead, we parse the TAP in lines.</source>
          <target state="translated">该&lt;a href=&quot;../parser&quot;&gt;TAP ::分析器&lt;/a&gt;因为自来水本质上是一种基于流的协议不使用正式的语法。实际上，拥有无限的流是很合法的。出于与我们不将正则表达式应用于流相同的原因，我们在这里没有使用正式的语法。相反，我们按行解析TAP。</target>
        </trans-unit>
        <trans-unit id="9b27238d4d5342b8376d19c0241b7f8feab19452" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section contains an example of tying handles.</source>
          <target state="translated">所述&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;部分包含捆扎把手的一个例子。</target>
        </trans-unit>
        <trans-unit id="6d31ab6a810582c2c717e2c46d057f9872d7ae58" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section uses a good example of tying scalars by associating process IDs with priority.</source>
          <target state="translated">所述&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;部使用由进程ID与优先级相关联的标量捆扎的一个很好的例子。</target>
        </trans-unit>
        <trans-unit id="ef794a4d4eb5de692a3463fa7a1780b4cded7598" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../time/gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;../time/localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the gmtime() and localtime() functions, respectively.</source>
          <target state="translated">的&lt;a href=&quot;../time/gmtime&quot;&gt;时间:: gmtime的&lt;/a&gt;和&lt;a href=&quot;../time/localtime&quot;&gt;时间::本地时间&lt;/a&gt;模块分别向gmtime的（）和localtime（）函数提供了方便，通过名的访问机制。</target>
        </trans-unit>
        <trans-unit id="1b61ff031aeab44addeeb9ed990fdd03cf707db7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;b/xref&quot;&gt;B::Xref&lt;/a&gt; module can be used to generate cross-reference reports for Perl programs.</source>
          <target state="translated">的&lt;a href=&quot;b/xref&quot;&gt;B ::外部参照&lt;/a&gt;模块可用于生成用于Perl程序交叉引用的报告。</target>
        </trans-unit>
        <trans-unit id="1c782dc05843dae452f5fa426b35990195e14641" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; module allows you to present your error messages from the caller's perspective; this gives you a way to signal a problem with the caller and not your module. For instance, if you say this:</source>
          <target state="translated">将&lt;a href=&quot;carp&quot;&gt;鲤鱼&lt;/a&gt;模块允许您从调用方的角度展示你的错误信息; 这为您提供了一种方法来表示调用者而不是模块的问题。例如，如果您这样说：</target>
        </trans-unit>
        <trans-unit id="99917712f2804784fe8d984e9caf76b36fd4b3a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; function is unsuitable for hashing large quantities of data, not least of all because you can't get the information back. Look at the &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; module for more robust algorithms.</source>
          <target state="translated">该&lt;a href=&quot;crypt&quot;&gt;墓穴&lt;/a&gt;功能不适用于散列大量并非最不重要的所有数据，因为你不能得到信息反馈。查看&lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt;模块以获取更强大的算法。</target>
        </trans-unit>
        <trans-unit id="5477977d65c206b7b8a0bfb0ffcfed2d08e7d436" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; module can pretty-print Perl data structures:</source>
          <target state="translated">该&lt;a href=&quot;data/dumper&quot;&gt;数据::自卸车&lt;/a&gt;模块可以漂亮地打印Perl数据结构：</target>
        </trans-unit>
        <trans-unit id="c389b29dcc18d72eca5cc18bef171945489bed86" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; module on CPAN (or the 5.005 release of Perl) is great for printing out data structures. The &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; module on CPAN (or the 5.8 release of Perl), provides a function called &lt;code&gt;dclone&lt;/code&gt; that recursively copies its argument.</source>
          <target state="translated">CPAN（或Perl的5.005版本）上的&lt;a href=&quot;data/dumper&quot;&gt;Data :: Dumper&lt;/a&gt;模块非常适合打印数据结构。CPAN（或Perl 5.8版本）上的&lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt;模块提供了一个名为 &lt;code&gt;dclone&lt;/code&gt; 的函数，该函数递归地复制其参数。</target>
        </trans-unit>
        <trans-unit id="f90e864f3a759969a519520835fc4b34320f5652" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; module, better known simply as &quot;MakeMaker&quot;, turns a Perl script, typically called &lt;code&gt;Makefile.PL&lt;/code&gt; , into a Makefile. The Unix tool &lt;code&gt;make&lt;/code&gt; uses this file to manage dependencies and actions to process and install a Perl distribution.</source>
          <target state="translated">该&lt;a href=&quot;extutils/makemaker&quot;&gt;参考ExtUtils :: MakeMaker的&lt;/a&gt;模块，更好地简称为&amp;ldquo;MakeMaker的&amp;rdquo;，变成一个Perl脚本，通常称为 &lt;code&gt;Makefile.PL&lt;/code&gt; ，进入一个Makefile。Unix工具 &lt;code&gt;make&lt;/code&gt; 使用此文件来管理依赖关系和操作，以处理和安装Perl发行版。</target>
        </trans-unit>
        <trans-unit id="b36a8fb9e123f79842afcd307b1051443b42499f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt; module, which comes with Perl, does all of the hard work to traverse a directory structure. It comes with Perl. You simply call the &lt;code&gt;find&lt;/code&gt; subroutine with a callback subroutine and the directories you want to traverse:</source>
          <target state="translated">Perl附带的&lt;a href=&quot;file/find&quot;&gt;File :: Find&lt;/a&gt;模块完成了遍历目录结构的所有艰苦工作。它随Perl一起提供。您只需使用回调子例程和要遍历的目录来调用 &lt;code&gt;find&lt;/code&gt; 子例程：</target>
        </trans-unit>
        <trans-unit id="c85303530151e0f7d4bf77f032f56bce0f2d433a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module also has a legacy interface to the older &lt;code&gt;rmtree&lt;/code&gt; subroutine.</source>
          <target state="translated">该&lt;a href=&quot;file/path&quot;&gt;文件::路径&lt;/a&gt;模块还具有一个旧式接口到旧 &lt;code&gt;rmtree&lt;/code&gt; 子程序。</target>
        </trans-unit>
        <trans-unit id="2e3abc4db13d619062f522429a3b20e4ff646e91" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module, which comes with Perl, has a &lt;code&gt;remove_tree&lt;/code&gt; which can take care of all of the hard work for you:</source>
          <target state="translated">Perl随附的&lt;a href=&quot;file/path&quot;&gt;File :: Path&lt;/a&gt;模块具有 &lt;code&gt;remove_tree&lt;/code&gt; ，它可以为您处理所有辛苦的工作：</target>
        </trans-unit>
        <trans-unit id="e423ba5fb093092e153154cd61200bfa0809ecf8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="translated">该&lt;a href=&quot;file/stat&quot;&gt;文件::统计&lt;/a&gt;模块提供了便利，通过名字访问的机制：</target>
        </trans-unit>
        <trans-unit id="147153b8beaaff8771aea84e885cb82d17734d7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;findbin&quot;&gt;FindBin&lt;/a&gt; module, which comes with Perl, might work. It finds the directory of the currently running script and puts it in &lt;code&gt;$Bin&lt;/code&gt; , which you can then use to construct the right library path:</source>
          <target state="translated">Perl附带的&lt;a href=&quot;findbin&quot;&gt;FindBin&lt;/a&gt;模块可能会起作用。它找到当前正在运行的脚本的目录，并将其放入 &lt;code&gt;$Bin&lt;/code&gt; ，然后可以使用该目录构造正确的库路径：</target>
        </trans-unit>
        <trans-unit id="6627242b752186d85aed5b69d9aaec46b0dd05af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Loops&quot;&gt;Algorithm::Loops&lt;/a&gt; module also provides the &lt;code&gt;NextPermute&lt;/code&gt; and &lt;code&gt;NextPermuteNum&lt;/code&gt; functions which efficiently find all unique permutations of an array, even if it contains duplicate values, modifying it in-place: if its elements are in reverse-sorted order then the array is reversed, making it sorted, and it returns false; otherwise the next permutation is returned.</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Loops&quot;&gt;算法::循环&lt;/a&gt;模块还提供了 &lt;code&gt;NextPermute&lt;/code&gt; 和 &lt;code&gt;NextPermuteNum&lt;/code&gt; 功能，这有效地找到一个数组的所有独特排列，即使它包含重复的值，就地修改它：如果它的元素都以相反排序的顺序，则排列被反转，使其排序，并返回false；否则，返回下一个排列。</target>
        </trans-unit>
        <trans-unit id="7f004cbac628e9968204a02264b31a3bb1043a19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Array::Iterator::Circular&quot;&gt;Array::Iterator::Circular&lt;/a&gt; creates an iterator object for circular arrays:</source>
          <target state="translated">所述&lt;a href=&quot;http://search.cpan.org/perldoc/Array::Iterator::Circular&quot;&gt;阵列::迭代::圆形&lt;/a&gt;创建圆形阵列的迭代器对象：</target>
        </trans-unit>
        <trans-unit id="a8c05beafd26231c80f038931300ac0e459427b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; module provides an abstract interface to most database servers and types, including Oracle, DB2, Sybase, mysql, Postgresql, ODBC, and flat files. The DBI module accesses each database type through a database driver, or DBD. You can see a complete list of available drivers on CPAN: &lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http://www.cpan.org/modules/by-module/DBD/&lt;/a&gt; . You can read more about DBI on &lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http://dbi.perl.org/&lt;/a&gt; .</source>
          <target state="translated">在&lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt;模块提供的抽象接口大多数数据库服务器和类型，包括Oracle，DB2中，Sybase，MySQL和PostgreSQL，ODBC和平面文件。DBI模块通过数据库驱动程序或DBD访问每种数据库类型。您可以在CPAN上看到可用驱动程序的完整列表：&lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http&lt;/a&gt; : //www.cpan.org/modules/by-module/DBD/。您可以在&lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http://dbi.perl.org/&lt;/a&gt;上阅读有关DBI的更多信息。</target>
        </trans-unit>
        <trans-unit id="d99e17e2d810ab06df1befd3ba4deffe8e1f4100" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; module on CPAN can do it for you too. Its &lt;code&gt;Dive&lt;/code&gt; subroutine can tell you not only if the keys exist but also get the value:</source>
          <target state="translated">CPAN上的&lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data :: Diver&lt;/a&gt;模块也可以为您完成此操作。它的 &lt;code&gt;Dive&lt;/code&gt; 子例程不仅可以告诉您密钥是否存在，还可以获取值：</target>
        </trans-unit>
        <trans-unit id="2f20a46404ea5d10e8ff52857742923d6a8c636c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module provides two functions to calculate these, too:</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;日期::计算器&lt;/a&gt;模块提供了两个函数来计算这些产品：</target>
        </trans-unit>
        <trans-unit id="cffc0b8a618b23964a5ae541c5cad5a91da659e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt; (New York Times Profiler) does both statement and subroutine profiling. It's available from CPAN and you also invoke it with the &lt;code&gt;-d&lt;/code&gt; switch:</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;杰韦利:: NYTProf&lt;/a&gt;（纽约时报探查）同时做两语句和子程序剖析。它可以从CPAN获得，您还可以使用 &lt;code&gt;-d&lt;/code&gt; 开关来调用它：</target>
        </trans-unit>
        <trans-unit id="36fe1514538dca6b4e14625a53ea351dc45f0bbb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; module can decode base 64-encoded email message parts transparently so the developer doesn't need to worry about it.</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;电子邮件:: MIME&lt;/a&gt;模块可以解码透明，因此开发人员无需对此担心基地64编码的电子邮件消息部分。</target>
        </trans-unit>
        <trans-unit id="5544c90428de4242a1010e3b0f0f5fbfd72933f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Closures&quot;&gt;File::Find::Closures&lt;/a&gt;, which you can download from CPAN, provides many ready-to-use subroutines that you can use with &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Closures&quot;&gt;文件::查找::闭包&lt;/a&gt;，你可以从CPAN下载，提供了很多现成的使用子程序，您可以用使用&lt;a href=&quot;file/find&quot;&gt;文件::查找&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56af297ba8a5f6d4fadfc00398e4a75a93e0389e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt; module, which you can download from CPAN, has a similar interface, but does the traversal for you too:</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;文件::查找::规则&lt;/a&gt;模块，你可以从CPAN下载，也有类似的接口，但是没有遍历对你太：</target>
        </trans-unit>
        <trans-unit id="b152dc512307ef4ac58f7c9208c20855dec936d6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Finder&quot;&gt;File::Finder&lt;/a&gt;, which you can download from CPAN, can help you create the callback subroutine using something closer to the syntax of the &lt;code&gt;find&lt;/code&gt; command-line utility:</source>
          <target state="translated">可以从CPAN下载的&lt;a href=&quot;http://search.cpan.org/perldoc/File::Finder&quot;&gt;File :: Finder&lt;/a&gt;可以帮助您使用更接近 &lt;code&gt;find&lt;/code&gt; 命令行实用程序语法的内容来创建回调子例程：</target>
        </trans-unit>
        <trans-unit id="1598869d41d1eca117a3416dff8d5309f0c6cfec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt; module also has the advantage of setting the input record separator to a regular expression.</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;文件:: ReadBackwards&lt;/a&gt;模块还具有输入记录分隔符设置为正则表达式的优势。</target>
        </trans-unit>
        <trans-unit id="91110246c66bf6d661128beb45e4417253ba4c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Interactive&quot;&gt;IO::Interactive&lt;/a&gt; module does the best it can to give you an answer. Its &lt;code&gt;is_interactive&lt;/code&gt; function returns an output filehandle; that filehandle points to standard output if the module thinks the session is interactive. Otherwise, the filehandle is a null handle that simply discards the output:</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/IO::Interactive&quot;&gt;IO ::互动&lt;/a&gt;模块做最好的它可以给你一个答案。它的 &lt;code&gt;is_interactive&lt;/code&gt; 函数返回一个输出文件句柄；如果模块认为会话是交互式的，则该文件句柄指向标准输出。否则，filehandle是一个空句柄，它仅丢弃输出：</target>
        </trans-unit>
        <trans-unit id="6b13cf53c66e0915c0e8281e749fbd4b759e7ba2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Proc::Daemon&quot;&gt;Proc::Daemon&lt;/a&gt; module, available from CPAN, provides a function to perform these actions for you.</source>
          <target state="translated">可从CPAN获得的&lt;a href=&quot;http://search.cpan.org/perldoc/Proc::Daemon&quot;&gt;Proc :: Daemon&lt;/a&gt;模块提供了为您执行这些操作的功能。</target>
        </trans-unit>
        <trans-unit id="078338e81125883115260ece46dd352b4457327c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Sys::Hostname::Long&quot;&gt;Sys::Hostname::Long&lt;/a&gt; module takes a different approach and tries harder to return the fully qualified hostname:</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/Sys::Hostname::Long&quot;&gt;Sys系统::主机名::龙&lt;/a&gt;模块采用不同的方法，并尝试更难返回完全合格的主机名：</target>
        </trans-unit>
        <trans-unit id="d7d7335f50cc47451871f0f97f15916c1b4287d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Task::Kensho&quot;&gt;Task::Kensho&lt;/a&gt; module has a list of recommended modules which you should review as a good starting point.</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/Task::Kensho&quot;&gt;任务:: Kensho计划&lt;/a&gt;模块推荐模块，你应该检讨是一个很好的出发点的列表。</target>
        </trans-unit>
        <trans-unit id="96f2822c5bca6e995fc1a0007a9363af6e5934b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN offers an easy-to-use interface that should be more efficient than shelling out to &lt;b&gt;stty&lt;/b&gt; for each key. It even includes limited support for Windows.</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;期限:: ReadKey&lt;/a&gt;从CPAN模块提供了一个易于使用的界面，应该比脱壳而出，以更有效&lt;b&gt;的stty&lt;/b&gt;每个键。它甚至包括对Windows的有限支持。</target>
        </trans-unit>
        <trans-unit id="32118c4d7f9e3bede84a1a66430b5426071bf4d3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Tussle&quot;&gt;Unicode::Tussle&lt;/a&gt; CPAN module includes many programs to help with working with Unicode, including these programs to fully or partly replace standard utilities:</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Tussle&quot;&gt;统一::厮打&lt;/a&gt; CPAN模块包括许多方案，以帮助使用Unicode工作，其中包括这些程序完全替代或部分替代标准工具：</target>
        </trans-unit>
        <trans-unit id="919f72853738df881eb6e91400681adc998b688b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/strictures#VERSION-2&quot;&gt;strictures&lt;/a&gt; module on CPAN offers one example of a warnings subset that the module's authors believe is relatively safe to fatalize.</source>
          <target state="translated">CPAN上的&lt;a href=&quot;http://search.cpan.org/perldoc/strictures#VERSION-2&quot;&gt;狭窄&lt;/a&gt;模块提供了一个警告子集的示例，该模块的作者认为该警告子集可以相对安全地致命。</target>
        </trans-unit>
        <trans-unit id="843917bc0f80fad466bd923d5aab8d1c0906f90e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt; objects also have a &lt;code&gt;flush&lt;/code&gt; method. You can flush the buffer any time you want without auto-buffering</source>
          <target state="translated">该&lt;a href=&quot;io/handle&quot;&gt;IO ::句柄&lt;/a&gt;对象也具有 &lt;code&gt;flush&lt;/code&gt; 方法。您可以随时刷新缓冲区而无需自动缓冲</target>
        </trans-unit>
        <trans-unit id="5839e7279588dcb1c4433f17b527ae9a9d772eed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt; module (part of the standard perl distribution) is an easy-to-use approach that internally uses &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; to do the job. Make sure you read the deadlock warnings in its documentation, though (see &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt;). See &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;Bidirectional Communication with Another Process in perlipc&lt;/a&gt; and &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;Bidirectional Communication with Yourself in perlipc&lt;/a&gt;</source>
          <target state="translated">该&lt;a href=&quot;ipc/open2&quot;&gt;IPC :: Open2&lt;/a&gt;模组（标准perl的一部分）是内部使用一个易于使用的方法 &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 的，和 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 来完成这项工作。但是，请确保已阅读其文档中的死锁警告（请参阅&lt;a href=&quot;ipc/open2&quot;&gt;IPC :: Open2&lt;/a&gt;）。见&lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;双向通信与perlipc另一个进程&lt;/a&gt;和&lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;在perlipc双向通信与自己&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09e04b4b58ffa26e2662b854208dafbdb133126a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mime/base64&quot;&gt;MIME::Base64&lt;/a&gt; package handles this as well as the MIME/QP encoding. Decoding base 64 becomes as simple as:</source>
          <target state="translated">该&lt;a href=&quot;mime/base64&quot;&gt;MIME :: Base64的&lt;/a&gt;包处理此还有MIME / QP编码。解码基数64变得很简单：</target>
        </trans-unit>
        <trans-unit id="0b7108620b7e75ec5ba066fc83c0e7f6113d802f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma provides some functions for manipulating the method cache directly.</source>
          <target state="translated">在&lt;a href=&quot;mro&quot;&gt;MRO&lt;/a&gt;编译指示提供了一些功能直接操纵方法缓存。</target>
        </trans-unit>
        <trans-unit id="f076d77a637b12522b1379f81df9ca81640a9292" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;net/domain&quot;&gt;Net::Domain&lt;/a&gt; module, which is part of the Standard Library starting in Perl 5.7.3, can get you the fully qualified domain name (FQDN), the host name, or the domain name.</source>
          <target state="translated">该&lt;a href=&quot;net/domain&quot;&gt;网::域&lt;/a&gt;模块，这是标准库的一部分，在Perl 5.7.3开始，可以让你的完全限定域名（FQDN），主机名或域名。</target>
        </trans-unit>
        <trans-unit id="76dc71fd851bfecf3d4eefc768e03ef389a05460" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma affects all the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; calls after the pragma by setting default layers. If you want to affect only certain streams, use explicit layers directly in the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">在&lt;a href=&quot;open&quot;&gt;开放&lt;/a&gt;编译影响所有 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 设置默认层编译后调用。如果只想影响某些流，请在 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 调用中直接使用显式图层。</target>
        </trans-unit>
        <trans-unit id="2cf8373e5ee8839618cf4f3d8412574499af0964" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; module is one of several ways that Perl lets you define inheritance relationships.</source>
          <target state="translated">该&lt;a href=&quot;parent&quot;&gt;父&lt;/a&gt;模块的几种方法之一是Perl让你定义的继承关系。</target>
        </trans-unit>
        <trans-unit id="6b0fe01583804e7c24edcd36bf4d1dc86edd7004" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C &lt;/a&gt; command line option can specify that certain inputs to the program are Unicode, and the values of this can be read by your Perl code, see &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;${^UNICODE} in perlvar&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt;命令行选项可以指定某些输入到程序都是Unicode，并在此值可以通过你的Perl代码读出，见&lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;$ {^ UNICODE}在perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1dd5f1da5843d43e215f1c5605c7bd2602ba3c8d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; documentation has general advice about data security. If you are using the &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; module, use placeholder to fill in data. If you are running external programs with &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, use the list forms. There are many other precautions that you should take, too many to list here, and most of them fall under the category of not using any data that you don't intend to use. Trust no one.</source>
          <target state="translated">该&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;文档中有关于数据安全的一般建议。如果使用的是&lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt;模块，请使用占位符填写数据。如果您正在使用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 运行外部程序，请使用列表形式。您还应该采取许多其他预防措施，在这里过多列出，大多数措施属于不使用任何您不打算使用的数据的类别。不要相信任何人。</target>
        </trans-unit>
        <trans-unit id="d3dddc8cefb2df3a4b2f380a117370ecb94e0324" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module (part of the standard Perl distribution) implements &lt;code&gt;ceil()&lt;/code&gt; , &lt;code&gt;floor()&lt;/code&gt; , and a number of other mathematical and trigonometric functions.</source>
          <target state="translated">的&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块器械（标准的Perl分布的一部分） &lt;code&gt;ceil()&lt;/code&gt; ， &lt;code&gt;floor()&lt;/code&gt; ，和许多其它的数学和三角函数。</target>
        </trans-unit>
        <trans-unit id="eb81881ffc1ffa7659057b3aad0d531c1c255d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module can also format a date as the day of the year or week of the year.</source>
          <target state="translated">该&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块还可以格式化日期为今年一年或一周中的一天。</target>
        </trans-unit>
        <trans-unit id="f19febd4ca12ddc4d78578d816e9ed0531d16d0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module makes extensive use of this type.</source>
          <target state="translated">该&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块广泛使用这种类型。</target>
        </trans-unit>
        <trans-unit id="2b0fd33e8403b054935aab9d8ee0ab65dd34b689" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; module to alter behaviour and aid debugging.</source>
          <target state="translated">在&lt;a href=&quot;re&quot;&gt;重新&lt;/a&gt;模块改变行为和帮助调试。</target>
        </trans-unit>
        <trans-unit id="cb49b0f767217eaf2addd5f51c9329970eca01df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sys/hostname&quot;&gt;Sys::Hostname&lt;/a&gt; module, part of the Standard Library, can also get the hostname:</source>
          <target state="translated">该&lt;a href=&quot;sys/hostname&quot;&gt;Sys系统::主机名&lt;/a&gt;模块，标准库的一部分，也可以得到主机名：</target>
        </trans-unit>
        <trans-unit id="220edf79ba9ff4834b00c1168d4289b47c73eb1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;term/cap&quot;&gt;Term::Cap&lt;/a&gt; module can also get the special sequence if you want to deal with the low-level details of terminal control. The &lt;code&gt;Tputs&lt;/code&gt; method returns the string for the given capability:</source>
          <target state="translated">该&lt;a href=&quot;term/cap&quot;&gt;期限::上限&lt;/a&gt;，如果你想处理终端控制的低层细节模块还可以得到特殊的序列。该 &lt;code&gt;Tputs&lt;/code&gt; 方法返回给定功能的字符串：</target>
        </trans-unit>
        <trans-unit id="e87c5439cafd856838e66bb969aac3bccda2430c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; modules are included in the core Perl distribution. Additionally, they are maintained as a separate modules on CPAN, so you can check there for any updates.</source>
          <target state="translated">的&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;和&lt;a href=&quot;threads/shared&quot;&gt;线程共享::&lt;/a&gt;模块被包含在核心Perl发行。此外，它们在CPAN上作为单独的模块维护，因此您可以在此处检查是否有任何更新。</target>
        </trans-unit>
        <trans-unit id="2a9bb0674257a5140b5151993d5c3d3a37202400" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the basic functions you need to write threaded programs. In the following sections, we'll cover the basics, showing you what you need to do to create a threaded program. After that, we'll go over some of the features of the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module that make threaded programming easier.</source>
          <target state="translated">该&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;模块提供了你需要编写线程程序的基本功能。在以下各节中，我们将介绍基础知识，向您展示创建线程程序所需的操作。之后，我们将介绍&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;模块的一些功能，这些功能使线程编程更加容易。</target>
        </trans-unit>
        <trans-unit id="2a739a40945ec3475dfa2806df561fe8eb1d910a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the tools you need to create new threads. Like any other module, you need to tell Perl that you want to use it; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads;&lt;/code&gt; imports all the pieces you need to create basic threads.</source>
          <target state="translated">该&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;模块提供了你需要创建新线程的工具。像其他任何模块一样，您需要告诉Perl您要使用它。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads;&lt;/code&gt; 导入创建基本线程所需的所有片段。</target>
        </trans-unit>
        <trans-unit id="ac95afd4b80a6c32d7d4b6fc126fc11993d69484" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;time/localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the gmtime() and localtime() functions, respectively.</source>
          <target state="translated">的&lt;a href=&quot;time/gmtime&quot;&gt;时间:: gmtime的&lt;/a&gt;和&lt;a href=&quot;time/localtime&quot;&gt;时间::本地时间&lt;/a&gt;模块分别向gmtime的（）和localtime（）函数提供了方便，通过名的访问机制。</target>
        </trans-unit>
        <trans-unit id="27e7660ba02616c82b0460251677001be2bab8d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; module (part of the standard distribution as of Perl 5.8) measures time with the &lt;code&gt;gettimeofday()&lt;/code&gt; system call, which returns the time in microseconds since the epoch. If you can't install &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; for older Perls and you are on a Unixish system, you may be able to call &lt;code&gt;gettimeofday(2)&lt;/code&gt; directly. See &lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;.</source>
          <target state="translated">的&lt;a href=&quot;time/hires&quot;&gt;时间::高分辨率&lt;/a&gt;模块测量的时间与（标准分布Perl 5.8的的一部分） &lt;code&gt;gettimeofday()&lt;/code&gt; 系统调用，因为时代它返回时间以微秒。如果您无法为较早的Perls 安装&lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt;，并且您使用的是Unixish系统，则可以直接调用 &lt;code&gt;gettimeofday(2)&lt;/code&gt; 。请参阅&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="70cd112c1d983694e459a2b5affce0b2c176b5e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module exports a new &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; that returns an object, and &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; exports the &lt;code&gt;ONE_DAY&lt;/code&gt; constant that is a set number of seconds. This means that it always gives the time 24 hours ago, which is not always yesterday. This can cause problems around the end of daylight saving time when there's one day that is 25 hours long.</source>
          <target state="translated">该&lt;a href=&quot;time/piece&quot;&gt;时间::件&lt;/a&gt;模块导出一个新的 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 返回一个对象，&lt;a href=&quot;time/seconds&quot;&gt;时间::秒&lt;/a&gt;出口 &lt;code&gt;ONE_DAY&lt;/code&gt; 常量，它是几秒钟的定数。这意味着它总是提供24小时之前的时间，而并非总是昨天。当一天的时间长达25小时时，这可能会导致夏令时结束时出现问题。</target>
        </trans-unit>
        <trans-unit id="ad7b96811e1e0447b346c7c68b0b6f49a0e303ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module, which comes with Perl, replaces &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt; with a version that returns an object. It also overloads the comparison operators so you can compare them directly:</source>
          <target state="translated">Perl随附的&lt;a href=&quot;time/piece&quot;&gt;Time :: Piece&lt;/a&gt;模块将&lt;a href=&quot;functions/localtime&quot;&gt;本地&lt;/a&gt;时间替换为返回对象的版本。它还使比较运算符过载，因此您可以直接比较它们：</target>
        </trans-unit>
        <trans-unit id="7624d8ccf09fad70c6649ad6b1aa4fa701ecfb1c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-C&lt;/b&gt; flag controls some of the Perl Unicode features.</source>
          <target state="translated">的&lt;b&gt;-C&lt;/b&gt;标志控制部分的Perl的Unicode的功能。</target>
        </trans-unit>
        <trans-unit id="eeee1b2385aaa3798bce91466fcda51762a843eb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-C&lt;/b&gt; option only works if it is specified on the command line as well (with the same sequence of letters or numbers following). Either specify this option on the command line, or, if your system supports it, make your script executable and run it directly instead of passing it to perl.</source>
          <target state="translated">的&lt;b&gt;-C&lt;/b&gt;选项仅当在命令行上被指定它，以及（具有字母或下面的数字相同的序列）的工作原理。在命令行上指定此选项，或者，如果系统支持，则使脚本可执行并直接运行它，而不是将其传递给perl。</target>
        </trans-unit>
        <trans-unit id="adbe88919d7c337e67d217e417ae52c5e78e86cc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-DL&lt;/b&gt; command-line switch is obsolete since circa Perl 5.6.0 (it was available only if Perl was built with &lt;code&gt;-DDEBUGGING&lt;/code&gt; ). The switch was used to track Perl's memory allocations and possible memory leaks. These days the use of malloc debugging tools like</source>
          <target state="translated">的&lt;b&gt;-DL&lt;/b&gt;命令行开关是过时因为大约的Perl 5.6.0（这是仅当的Perl用内置可用 &lt;code&gt;-DDEBUGGING&lt;/code&gt; ）。该开关用于跟踪Perl的内存分配和可能的内存泄漏。这些天来使用malloc调试工具，例如</target>
        </trans-unit>
        <trans-unit id="7a02c2d05901d298065bac05eaefdaf89b098f1d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-a&lt;/b&gt; option followed by the name of a perl api function will extract the documentation of this function from &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;.</source>
          <target state="translated">该&lt;b&gt;-a&lt;/b&gt;选项，后跟一个Perl API函数的名称将提取此函数的文档&lt;a href=&quot;perlapi&quot;&gt;负责填实perlapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7458f799f2d3bc9e0821f8f30b793deae5a843f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-f&lt;/b&gt; option followed by the name of a perl built-in function will extract the documentation of this function from &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">该&lt;b&gt;-f&lt;/b&gt;选项，后跟内置函数一个Perl的名称将提取此函数的文档&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1902e94f8bb188d5617c0fc133e4af994267a619" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-q&lt;/b&gt; option takes a regular expression as an argument. It will search the &lt;b&gt;q&lt;/b&gt;uestion headings in perlfaq[1-9] and print the entries matching the regular expression.</source>
          <target state="translated">该&lt;b&gt;-q&lt;/b&gt;选项接受一个正则表达式作为参数。它将搜索perlfaq [1-9]中的&lt;b&gt;q&lt;/b&gt;标题，并打印与正则表达式匹配的条目。</target>
        </trans-unit>
        <trans-unit id="5344e76d29fb1384ca26893a56599519b1faad07" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-v&lt;/b&gt; option followed by the name of a Perl predefined variable will extract the documentation of this variable from &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">的&lt;b&gt;-v&lt;/b&gt;选项，后跟一个Perl的名称预定义的变量将提取从这个变量的文档&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5ae0073660f495c2b0b0a5aff71edb22c20f2cb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-verbose&lt;/b&gt; flag first prints out the &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; introduction before any other diagnostics. The $diagnostics::PRETTY variable can generate nicer escape sequences for pagers.</source>
          <target state="translated">该&lt;b&gt;-verbose&lt;/b&gt;标志首先打印出的&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;任何其他诊断之前的介绍。$ diagnostics :: PRETTY变量可以为寻呼机生成更好的转义序列。</target>
        </trans-unit>
        <trans-unit id="ceb38ecccfec93207c00c9dee183b84b32a5f056" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-w&lt;/b&gt; flag just sets the global &lt;code&gt;$^W&lt;/code&gt; variable as in 5.005. This means that any legacy code that currently relies on manipulating &lt;code&gt;$^W&lt;/code&gt; to control warning behavior will still work as is.</source>
          <target state="translated">该&lt;b&gt;-w&lt;/b&gt;标志只是设置全局 &lt;code&gt;$^W&lt;/code&gt; 变量在5.005。这意味着当前依赖于操纵 &lt;code&gt;$^W&lt;/code&gt; 来控制警告行为的任何旧版代码仍将按原样工作。</target>
        </trans-unit>
        <trans-unit id="72bbdbcc137e1ec7edde830d8069bcdc7d47c4dc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;AutoLoader&lt;/b&gt; is similar in purpose to &lt;b&gt;SelfLoader&lt;/b&gt;: both delay the loading of subroutines.</source>
          <target state="translated">该&lt;b&gt;自动装载&lt;/b&gt;在目的上类似&lt;b&gt;SelfLoader&lt;/b&gt;：两个延迟子程序的加载。</target>
        </trans-unit>
        <trans-unit id="0f53ec7201e8a617c94e28662bed3af80a664f4d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;AutoLoader&lt;/b&gt; module works with the &lt;b&gt;AutoSplit&lt;/b&gt; module and the &lt;code&gt;__END__&lt;/code&gt; token to defer the loading of some subroutines until they are used rather than loading them all at once.</source>
          <target state="translated">该&lt;b&gt;自动装入&lt;/b&gt;与模块厂&lt;b&gt;自动分割&lt;/b&gt;模块和 &lt;code&gt;__END__&lt;/code&gt; 一些子程序的令牌推迟装载，直到它们被使用，而不是装载它们的一次。</target>
        </trans-unit>
        <trans-unit id="93865b59868e970114227e97ec05c9ea3f594f39" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;ExtUtils::Embed&lt;/b&gt; kit on CPAN also contains all source code for the examples in this document, tests, additional examples and other information you may find useful.</source>
          <target state="translated">CPAN上的&lt;b&gt;ExtUtils :: Embed&lt;/b&gt;套件还包含本文档中的示例，测试，其他示例以及您认为有用的其他信息的所有源代码。</target>
        </trans-unit>
        <trans-unit id="d362af90dceed3d87816d0dcbc3d699668f7c9c9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;IO&lt;/b&gt; extension, &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">在&lt;b&gt;IO&lt;/b&gt;扩展，&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;，&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I / O操作员在perlop中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4ddb503abc843b9ef214b377226c71b441a111a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Pod::Hyperlink&lt;/b&gt; class is mainly designed to parse the contents of the &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; sequence, providing a simple interface for accessing the different parts of a POD hyperlink for further processing. It can also be used to construct hyperlinks.</source>
          <target state="translated">的&lt;b&gt;波德::超链接&lt;/b&gt;类主要被设计来解析的内容 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 序列，提供用于访问超链接POD的不同部分以用于进一步处理的简单接口。它也可以用来构造超链接。</target>
        </trans-unit>
        <trans-unit id="159cbd250976e52bd0b54f9fbb2c920f60501cf2" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; can replace the AutoLoader - just change 'use AutoLoader' to 'use SelfLoader' (though note that the &lt;b&gt;SelfLoader&lt;/b&gt; exports the AUTOLOAD function - but if you have your own AUTOLOAD and are using the AutoLoader too, you probably know what you're doing), and the &lt;code&gt;__END__&lt;/code&gt; token to &lt;code&gt;__DATA__&lt;/code&gt; . You will need perl version 5.001m or later to use this (version 5.001 with all patches up to patch m).</source>
          <target state="translated">该&lt;b&gt;SelfLoader&lt;/b&gt;可以代替自动装入-只是改变&amp;ldquo;使用自动装入&amp;rdquo;到&amp;ldquo;使用SelfLoader&amp;rdquo;（但要注意的是，&lt;b&gt;SelfLoader&lt;/b&gt;出口自动加载功能-但如果你有自己的AUTOLOAD和正在使用的自动装载过多，你可能不知道你），并将 &lt;code&gt;__END__&lt;/code&gt; 令牌添加到 &lt;code&gt;__DATA__&lt;/code&gt; 。您将需要perl版本5.001m或更高版本才能使用此版本（版本5.001，所有补丁直至补丁m）。</target>
        </trans-unit>
        <trans-unit id="9cc1e94494f4935e31dcd4aca4dd8097e05b3034" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; exports the &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine to the package using the &lt;b&gt;SelfLoader&lt;/b&gt;, and this loads the called subroutine when it is first called.</source>
          <target state="translated">该&lt;b&gt;SelfLoader&lt;/b&gt;出口的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 子程序包使用&lt;b&gt;SelfLoader&lt;/b&gt;，并且当它第一次叫这个负载调用的子程序。</target>
        </trans-unit>
        <trans-unit id="be3fad23fb52579393cf97f6d16c823542fd3d2f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; reads from wherever the current position of the &lt;code&gt;FOOBAR::DATA&lt;/code&gt; filehandle is, until the EOF or &lt;code&gt;__END__&lt;/code&gt; . This means that if you want to use that filehandle (and ONLY if you want to), you should either</source>
          <target state="translated">该&lt;b&gt;SelfLoader&lt;/b&gt;在任何地方的当前位置读取 &lt;code&gt;FOOBAR::DATA&lt;/code&gt; 文件句柄，直到EOF或 &lt;code&gt;__END__&lt;/code&gt; 。这意味着，如果您要使用该文件句柄（并且仅在需要时使用），则应该</target>
        </trans-unit>
        <trans-unit id="0f59147d20cbbd96eaf3ce69c4654c447143a93e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will read from the FOOBAR::DATA filehandle to load in the data after &lt;code&gt;__DATA__&lt;/code&gt; , and load in any subroutine when it is called. The costs are the one-time parsing of the data after &lt;code&gt;__DATA__&lt;/code&gt; , and a load delay for the _first_ call of any autoloaded function. The benefits (hopefully) are a speeded up compilation phase, with no need to load functions which are never used.</source>
          <target state="translated">该&lt;b&gt;SelfLoader&lt;/b&gt;将从FOOBAR读:: DATA文件句柄在数据加载后 &lt;code&gt;__DATA__&lt;/code&gt; 任何子程序调用时，和负载。成本是 &lt;code&gt;__DATA__&lt;/code&gt; 之后的数据的一次性解析，以及任何自动加载函数的_first_调用的加载延迟。好处（希望是）可以加快编译阶段，而无需加载从未使用过的函数。</target>
        </trans-unit>
        <trans-unit id="b9076a846b441722c5113e39b9bcd0673ac55d99" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will stop reading from &lt;code&gt;__DATA__&lt;/code&gt; if it encounters the &lt;code&gt;__END__&lt;/code&gt; token - just as you would expect. If the &lt;code&gt;__END__&lt;/code&gt; token is present, and is followed by the token DATA, then the &lt;b&gt;SelfLoader&lt;/b&gt; leaves the FOOBAR::DATA filehandle open on the line after that token.</source>
          <target state="translated">该&lt;b&gt;SelfLoader&lt;/b&gt;将停止从阅读 &lt;code&gt;__DATA__&lt;/code&gt; 如果遇到 &lt;code&gt;__END__&lt;/code&gt; 令牌-就像你期望的那样。如果存在 &lt;code&gt;__END__&lt;/code&gt; 令牌，然后是令牌DATA，则&lt;b&gt;SelfLoader&lt;/b&gt;会将FOOBAR :: DATA文件句柄在该令牌之后的行上保持打开状态。</target>
        </trans-unit>
        <trans-unit id="ae4ca9e2af773bc53d6ebfbbbcbbb68e0e663b29" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works by the user placing the &lt;code&gt;__DATA__&lt;/code&gt; token</source>
          <target state="translated">该&lt;b&gt;SelfLoader&lt;/b&gt;作品被用户放置 &lt;code&gt;__DATA__&lt;/code&gt; 令牌</target>
        </trans-unit>
        <trans-unit id="b8a45570c1acb4c43b6a7805f6337844a9606503" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works similarly to the AutoLoader, but picks up the subs from after the &lt;code&gt;__DATA__&lt;/code&gt; instead of in the 'lib/auto' directory. There is a maintenance gain in not needing to run AutoSplit on the module at installation, and a runtime gain in not needing to keep opening and closing files to load subs. There is a runtime loss in needing to parse the code after the &lt;code&gt;__DATA__&lt;/code&gt; . Details of the &lt;b&gt;AutoLoader&lt;/b&gt; and another view of these distinctions can be found in that module's documentation.</source>
          <target state="translated">该&lt;b&gt;SelfLoader&lt;/b&gt;的工作方式类似于自动加载器，但拾起从后潜艇 &lt;code&gt;__DATA__&lt;/code&gt; 而不是在&amp;ldquo;LIB /自动&amp;rdquo;目录。在维护过程中，无需在模块上运行AutoSplit会带来维护方面的收益，而无需保持打开和关闭文件来加载sub的运行时方面的收益。需要解析 &lt;code&gt;__DATA__&lt;/code&gt; 之后的代码会导致运行时丢失。可在该模块的文档中找到&lt;b&gt;AutoLoader的&lt;/b&gt;详细信息以及这些区别的另一种视图。</target>
        </trans-unit>
        <trans-unit id="94dafc36f54a138d4c7c8beed77372c0b7d94298" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::Array&lt;/b&gt; implementation is a stub that simply croaks.</source>
          <target state="translated">该&lt;b&gt;领带::阵列&lt;/b&gt;的实现方式是简单地嘎嘎叫着存根。</target>
        </trans-unit>
        <trans-unit id="6b199766c781a0ae9ebeafd1ad9efb33847e8a69" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::Hash&lt;/b&gt; implementation is a stub that simply croaks.</source>
          <target state="translated">该&lt;b&gt;帖::哈希&lt;/b&gt;实现是简单地嘎嘎叫着存根。</target>
        </trans-unit>
        <trans-unit id="4134fa729bc36043c1bbc4226f0d69bd4bd166dc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdArray&lt;/b&gt; package provides efficient methods required for tied arrays which are implemented as blessed references to an &quot;inner&quot; perl array. It inherits from &lt;b&gt;Tie::Array&lt;/b&gt;, and should cause tied arrays to behave exactly like standard arrays, allowing for selective overloading of methods.</source>
          <target state="translated">所述&lt;b&gt;领带:: StdArray&lt;/b&gt;包提供用于其被实现为一个&amp;ldquo;内部&amp;rdquo;的perl阵列福地引用绑阵列所需的有效的方法。它继承自&lt;b&gt;Tie :: Array&lt;/b&gt;，并应使绑定数组的行为与标准数组完全相同，从而允许方法的选择性重载。</target>
        </trans-unit>
        <trans-unit id="61ae2de46d00875a51e425357ad71e5ccdd2ad38" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdHandle&lt;/b&gt; package provide most methods for file handles described in &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; (the exceptions are &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; ). It causes tied file handles to behave exactly like standard file handles and allow for selective overwriting of methods.</source>
          <target state="translated">该&lt;b&gt;帖:: StdHandle&lt;/b&gt;包提供了所描述的文件句柄大多数方法&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;（例外是 &lt;code&gt;UNTIE&lt;/code&gt; 和 &lt;code&gt;DESTROY&lt;/code&gt; ）。它使绑定的文件句柄的行为与标准文件句柄完全相同，并允许方法的选择性覆盖。</target>
        </trans-unit>
        <trans-unit id="eacf0e41a2a5258a61ae34656b72764dd7acc141" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::SubstrHash&lt;/b&gt; package provides a hash-table-like interface to an array of determinate size, with constant key size and record size.</source>
          <target state="translated">所述&lt;b&gt;领带:: SubstrHash&lt;/b&gt;包提供一个哈希表类似的接口来确定的尺寸的阵列，具有恒定的密钥大小和记录大小。</target>
        </trans-unit>
        <trans-unit id="a8a3a1e60f743e1378ee92d392f9857036d4b3d2" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;begincheck&lt;/b&gt; program makes it all clear, eventually:</source>
          <target state="translated">该&lt;b&gt;begincheck&lt;/b&gt;程序让这一切清楚，最终：</target>
        </trans-unit>
        <trans-unit id="1112db1b82f4fc99681fd70d53f56d13ced227cf" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma changes this to use the specified encoding instead. For example:</source>
          <target state="translated">该&lt;b&gt;编码&lt;/b&gt;编译改变了这种使用指定的编码来代替。例如：</target>
        </trans-unit>
        <trans-unit id="b7162377ab2247a065b27f7ed4e48c5d078da511" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma works by decoding string literals in &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; and so forth. In perl v5.8.0, this does not apply to &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. Therefore,</source>
          <target state="translated">该&lt;b&gt;编码&lt;/b&gt;编译的工作原理是在解码字符串字面量 &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; 等等。在perl v5.8.0中，这不适用于 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 。因此，</target>
        </trans-unit>
        <trans-unit id="80faef413c7207aab71b9f1d03988df6331ef791" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;file&lt;/b&gt; (or &lt;b&gt;string&lt;/b&gt;, in the case of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;) that is currently being &lt;b&gt;compiled&lt;/b&gt;.</source>
          <target state="translated">当前正在&lt;b&gt;编译&lt;/b&gt;的&lt;b&gt;文件&lt;/b&gt;（如果为 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，则为&lt;b&gt;字符串&lt;/b&gt;）。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bb5cf33051195df3d457e45e85209f2138dc4a05" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;first time&lt;/b&gt; the hook is hit in a serialization flow, you may have it return an empty list. That will signal the Storable engine to further discard that hook for this class and to therefore revert to the default serialization of the underlying Perl data. The hook will again be normally processed in the next serialization.</source>
          <target state="translated">在&lt;b&gt;第一次&lt;/b&gt;钩在一个序列化流击中，你可能有它返回一个空列表。这将指示Storable引擎进一步丢弃该类的该挂钩，并因此恢复为基础Perl数据的默认序列化。该挂钩将在下一个序列化中再次正常处理。</target>
        </trans-unit>
        <trans-unit id="31b896e0d53803b62960180dd945e43dfa7f81e7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;garbage collection&lt;/b&gt; of globals (and the running of any associated object destructors) that takes place when a Perl &lt;b&gt;interpreter&lt;/b&gt; is being shut down. Global destruction should not be confused with the Apocalypse, except perhaps when it should.</source>
          <target state="translated">当关闭Perl &lt;b&gt;解释器&lt;/b&gt;时，将进行全局变量的&lt;b&gt;垃圾回收&lt;/b&gt;（以及所有相关对象析构函数的运行）。全球毁灭不应该与世界末日相混淆，除非应该这样做。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="987526f88e29534e7fb822b3987e499066378921" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;grouping&lt;/b&gt; metacharacters &lt;code&gt;()&lt;/code&gt; allow a part of a regex to be treated as a single unit. Parts of a regex are grouped by enclosing them in parentheses. The regex &lt;code&gt;house(cat|keeper)&lt;/code&gt; means match &lt;code&gt;house&lt;/code&gt; followed by either &lt;code&gt;cat&lt;/code&gt; or &lt;code&gt;keeper&lt;/code&gt; . Some more examples are</source>
          <target state="translated">的&lt;b&gt;分组&lt;/b&gt;元字符 &lt;code&gt;()&lt;/code&gt; 允许一个正则表达式的一部分被视为单一的单元。正则表达式的部分通过将其括在圆括号中进行分组。regex &lt;code&gt;house(cat|keeper)&lt;/code&gt; 表示比赛 &lt;code&gt;house&lt;/code&gt; 后跟 &lt;code&gt;cat&lt;/code&gt; 或 &lt;code&gt;keeper&lt;/code&gt; 。还有更多的例子是</target>
        </trans-unit>
        <trans-unit id="ba87bd98015a685039202791b8b4c178941ed0ba" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;interpolation&lt;/b&gt; of a scalar or array variable into a string.</source>
          <target state="translated">的&lt;b&gt;内插&lt;/b&gt;标量或数组变量为一个字符串。</target>
        </trans-unit>
        <trans-unit id="fd9fd954815d11416f915389911ed3472be1a48a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;new()&lt;/b&gt; method can either be passed a set of key/value pairs or a single scalar value, namely the contents of a &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; sequence. An object of the class &lt;code&gt;Pod::Hyperlink&lt;/code&gt; is returned. The value &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; indicates a failure, the error message is stored in &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">的&lt;b&gt;新的（）&lt;/b&gt;方法既可以通过了一组键/值对或单个标量值，一个即内容 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 序列。返回 &lt;code&gt;Pod::Hyperlink&lt;/code&gt; 类的对象。值 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 表示失败，错误消息存储在 &lt;code&gt;$@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22dcd0ec3aed7a2c1842ef98e2374e061c59b868" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;package&lt;/b&gt; in which the current statement is &lt;b&gt;compiled&lt;/b&gt;. Scan backward in the text of your program through the current &lt;b&gt;lexical scope&lt;/b&gt; or any enclosing lexical scopes until you find a package declaration. That&amp;rsquo;s your current package name.</source>
          <target state="translated">在其中&lt;b&gt;编译&lt;/b&gt;当前语句的&lt;b&gt;包&lt;/b&gt;。通过当前&lt;b&gt;词法范围&lt;/b&gt;或任何封闭的词法范围在程序文本中向后扫描，直到找到包声明为止。那是您当前的包裹名称。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="837534d7853b1df8d6be64303da76d4fb655fe6c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parse_text()&lt;/b&gt; method takes a given paragraph of text, and returns a parse-tree that contains one or more children, each of which may be a text-string, or an InteriorSequence object. There are also callback-options that may be passed to &lt;b&gt;parse_text()&lt;/b&gt; to customize the way it expands or transforms interior-sequences, as well as the returned result. These callbacks can be used to create a parse-tree with custom-made objects (which may or may not support the parse-tree interface, depending on how you choose to do it).</source>
          <target state="translated">所述&lt;b&gt;parse_Text在（）&lt;/b&gt;方法采用文本的给定段，并返回一个解析树，包含一个或多个孩子，其中的每一个可以是文本串，或一个InteriorSequence对象。也可以将回调选项传递给&lt;b&gt;parse_text（），&lt;/b&gt;以自定义其扩展或转换内部序列以及返回结果的方式。这些回调可用于创建带有自定义对象的解析树（根据您选择的方式，该对象可能支持也可能不支持解析树接口）。</target>
        </trans-unit>
        <trans-unit id="b2fcda0a32417727cdd721f28d0c908b93bc1f19" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;perlivp&lt;/b&gt; program is set up at Perl source code build time to test the Perl version it was built under. It can be used after running:</source>
          <target state="translated">该&lt;b&gt;perlivp&lt;/b&gt;程序设置在Perl的源代码编译时间来测试Perl版本它是下建造的。可以在运行后使用：</target>
        </trans-unit>
        <trans-unit id="dc37ad02e0c6923bebd0d4430ccd02307461404f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;podchecker&lt;/b&gt; command is provided for checking Pod syntax for errors and warnings. For example, it checks for completely blank lines in Pod blocks and for unknown commands and formatting codes. You should still also pass your document through one or more translators and proofread the result, or print out the result and proofread that. Some of the problems found may be bugs in the translators, which you may or may not wish to work around.</source>
          <target state="translated">该&lt;b&gt;podchecker&lt;/b&gt;命令用于检查错误和警告波德语法。例如，它检查Pod块中的完全空白行以及未知的命令和格式代码。您还应该通过一个或多个翻译人员传递文档并校对结果，或打印结果并进行校对。发现的一些问题可能是翻译程序中的错误，您可能希望也可能不希望解决。</target>
        </trans-unit>
        <trans-unit id="d299b97d8bab37b1330370eb9473b8a413d005a5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;quantifier&lt;/b&gt; metacharacters &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , and &lt;code&gt;{}&lt;/code&gt; allow us to determine the number of repeats of a portion of a regex we consider to be a match. Quantifiers are put immediately after the character, character class, or grouping that we want to specify. They have the following meanings:</source>
          <target state="translated">该&lt;b&gt;量词&lt;/b&gt;元字符 &lt;code&gt;?&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;{}&lt;/code&gt; 允许我们确定被视为匹配项的正则表达式的一部分重复的次数。量词紧跟在我们要指定的字符，字符类或分组之后。它们具有以下含义：</target>
        </trans-unit>
        <trans-unit id="9b54e7f659f70ec7a4f3708e917b8834ab10ef21" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;scalar values&lt;/b&gt; that you supply to a &lt;b&gt;function&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt; when you call it. For instance, when you call &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt; , the string &lt;code&gt;&quot;puff&quot;&lt;/code&gt; is the actual argument. See also &lt;b&gt;argument&lt;/b&gt; and &lt;b&gt;formal arguments&lt;/b&gt;.</source>
          <target state="translated">调用&lt;b&gt;函数&lt;/b&gt;或&lt;b&gt;子例程&lt;/b&gt;时提供的&lt;b&gt;标量值&lt;/b&gt;。例如，当您调用 &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt; ，字符串 &lt;code&gt;&quot;puff&quot;&lt;/code&gt; 是实际参数。另请参见&lt;b&gt;论证&lt;/b&gt;和&lt;b&gt;形式论证&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4a023f0632e523744570838f6670cc7a9e367c0e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sigtrap&lt;/b&gt; pragma is a simple interface to installing signal handlers. You can have it install one of two handlers supplied by &lt;b&gt;sigtrap&lt;/b&gt; itself (one which provides a Perl stack trace and one which simply &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;s), or alternately you can supply your own handler for it to install. It can be told only to install a handler for signals which are either untrapped or ignored. It has a couple of lists of signals to trap, plus you can supply your own list of signals.</source>
          <target state="translated">该&lt;b&gt;SIGTRAP&lt;/b&gt;编译是一个简单的界面，安装信号处理程序。您可以让它安装&lt;b&gt;sigtrap&lt;/b&gt;本身提供的两个处理程序之一（一个提供Perl堆栈跟踪，另一个简单地 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; ），或者您也可以提供自己的处理程序以进行安装。只能告诉您为未捕获或忽略的信号安装处理程序。它有几个要捕获的信号列表，此外，您还可以提供自己的信号列表。</target>
        </trans-unit>
        <trans-unit id="d7c162ba3d4340b1ed67afae232423e0f505fd2b" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; produced by a &lt;b&gt;subroutine&lt;/b&gt; or &lt;b&gt;expression&lt;/b&gt; when evaluated. In Perl, a return value may be either a &lt;b&gt;list&lt;/b&gt; or a &lt;b&gt;scalar&lt;/b&gt;.</source>
          <target state="translated">的&lt;b&gt;值&lt;/b&gt;产生由一个&lt;b&gt;子程序&lt;/b&gt;或&lt;b&gt;表达&lt;/b&gt;进行评估时。在Perl中，返回值可以是&lt;b&gt;list&lt;/b&gt;或&lt;b&gt;scalar&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="7487920171bd7708f5f44fcbcd3a51b3cd669ff9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; returned to the parent &lt;b&gt;process&lt;/b&gt; when one of its child processes dies. This value is placed in the special variable &lt;code&gt;$?&lt;/code&gt; . Its upper eight &lt;b&gt;bits&lt;/b&gt; are the exit status of the defunct process, and its lower eight bits identify the signal (if any) that the process died from. On Unix systems, this status value is the same as the status word returned by</source>
          <target state="translated">该&lt;b&gt;值&lt;/b&gt;在其子进程之一死亡时返回给父&lt;b&gt;进程&lt;/b&gt;。此值放在特殊变量 &lt;code&gt;$?&lt;/code&gt; 中。。它的高八位&lt;b&gt;位&lt;/b&gt;是死进程的退出状态，而其低八位识别信号（如果有的话）的过程中经抢救无效死亡。在Unix系统上，此状态值与的返回值相同</target>
        </trans-unit>
        <trans-unit id="f75f87bdfa0eb35c4f5fe0a1642de1f3532d7289" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;values&lt;/b&gt; you supply along with a program name when you tell a &lt;b&gt;shell&lt;/b&gt; to execute a &lt;b&gt;command&lt;/b&gt;. These values are passed to a Perl program through &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">当您告诉&lt;b&gt;外壳&lt;/b&gt;程序执行&lt;b&gt;命令&lt;/b&gt;时，您提供的&lt;b&gt;值&lt;/b&gt;以及程序名称。这些值通过 &lt;code&gt;@ARGV&lt;/code&gt; 传递给Perl程序。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8215a7b783f151c4ff06cfd84ff859eb48442e77" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;word anchor&lt;/b&gt;&lt;code&gt;\b&lt;/code&gt; matches a boundary between a word character and a non-word character &lt;code&gt;\w\W&lt;/code&gt; or &lt;code&gt;\W\w&lt;/code&gt; :</source>
          <target state="translated">所述&lt;b&gt;字锚&lt;/b&gt; &lt;code&gt;\b&lt;/code&gt; 单词字符和非字符字之间的边界匹配 &lt;code&gt;\w\W&lt;/code&gt; 或 &lt;code&gt;\W\w&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="98df2a206a33c61c05323edbf28b990dfe8bb9b6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;xsubpp&lt;/b&gt; program takes the XS code in the .xs file and translates it into C code, placing it in a file whose suffix is .c. The C code created makes heavy use of the C functions within Perl.</source>
          <target state="translated">该&lt;b&gt;xsubpp&lt;/b&gt;程序取入.xs文件中的XS代码并将其转换成C代码，将其放置在其后缀是.c的一个文件。创建的C代码大量使用了Perl中的C函数。</target>
        </trans-unit>
        <trans-unit id="e9db711485ba959f3d0b453c931365b6638809a5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;xsubpp&lt;/b&gt; program uses rules to convert from Perl's data types (scalar, array, etc.) to C's data types (int, char, etc.). These rules are stored in the typemap file ($PERLLIB/ExtUtils/typemap). There's a brief discussion below, but all the nitty-gritty details can be found in &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;. If you have a new-enough version of perl (5.16 and up) or an upgraded XS compiler (&lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 3.13_01 or better), then you can inline typemaps in your XS instead of writing separate files. Either way, this typemap thing is split into three parts:</source>
          <target state="translated">该&lt;b&gt;xsubpp&lt;/b&gt;程序使用规则来转换从Perl的数据类型（标量，阵列等）至C的数据类型（int，焦炭等）。这些规则存储在类型映射文件（$ PERLLIB / ExtUtils / typemap）中。下面有一个简短的讨论，但是所有的细节都可以在&lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap中&lt;/a&gt;找到。如果您有新版本的perl（5.16及更高版本）或升级的XS编译器（ &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 3.13_01或更高版本），则可以在XS中内联类型映射，而不必编写单独的文件。无论哪种方式，此类型映射都分为三个部分：</target>
        </trans-unit>
        <trans-unit id="1082cc04157e373604ca98ab1606eeb58e2bd5d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt; $output &lt;/code&gt; argument may be:</source>
          <target state="translated">该 &lt;code&gt; $output &lt;/code&gt; 参数可以是：</target>
        </trans-unit>
        <trans-unit id="fe02d79593918e0f0b57f9efa92b9388e3573b1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;)&quot;&lt;/code&gt; is out-of-place. Something apparently was supposed to be combined with the digits, or the &lt;code&gt;&quot;+&quot;&lt;/code&gt; shouldn't be there, or something like that. Perl can't figure out what was intended.</source>
          <target state="translated">该 &lt;code&gt;&quot;)&quot;&lt;/code&gt; 是外的地方。显然应该将某些内容与数字结合在一起，或者不应该在其中加上 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 类的东西。Perl无法弄清楚它的意图。</target>
        </trans-unit>
        <trans-unit id="54034a923125cadab60eef06f26fcb91d4e7c351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;+&quot;&lt;/code&gt; is valid only when followed by digits, indicating a capturing group. See &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(?PARNO)&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;&quot;+&quot;&lt;/code&gt; ，随后的数字时，才指示捕获组是有效的。参见&lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;（？PARNO）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07bb712ac114a7fe219229eb5a67b484b3ca58ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;?&quot;&lt;/code&gt; and &lt;code&gt;&quot;+&quot;&lt;/code&gt; don't have any effect, as they modify whether to match more or fewer when there is a choice, and by specifying to match exactly a given numer, there is no room left for a choice.</source>
          <target state="translated">在 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 没有任何作用，因为它们会在选择时修改是匹配还是多或少，并且通过指定精确匹配给定的数字，就没有选择余地。</target>
        </trans-unit>
        <trans-unit id="622f5262d7227133a18718033006d1fe595c3150" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;U&quot;&lt;/code&gt; template has been ported to mean &quot;Unicode&quot; on all platforms so that</source>
          <target state="translated">在所有平台上， &lt;code&gt;&quot;U&quot;&lt;/code&gt; 模板已被移植为&amp;ldquo; Unicode&amp;rdquo;，因此</target>
        </trans-unit>
        <trans-unit id="d9a4c62629e10d33b540e16fc1ce8f7a3f41635f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;\x&quot;&lt;/code&gt; construct without curly braces should be followed by exactly two hex digits; this one is followed by three. This currently evaluates as equivalent to</source>
          <target state="translated">不带花括号的 &lt;code&gt;&quot;\x&quot;&lt;/code&gt; 结构后面应紧跟两个十六进制数字。接下来是三个。目前，这相当于</target>
        </trans-unit>
        <trans-unit id="18a8e19a030c3c8f53e48396122990cc28295c5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;a&quot;&lt;/code&gt; is a valid modifier flag, but the &lt;code&gt;&quot;n&quot;&lt;/code&gt; is not, and raises this error. Likely what was meant instead was:</source>
          <target state="translated">在 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 是一个有效的修改标志，但 &lt;code&gt;&quot;n&quot;&lt;/code&gt; 是不是，并提出了这个错误。相反，可能的意思是：</target>
        </trans-unit>
        <trans-unit id="14e2e8dae7c922be26733e3e660b25612cc5ce26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;c&quot;&lt;/code&gt; and &lt;code&gt;&quot;C&quot;&lt;/code&gt; templates for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; are dependent upon character set encoding. Examples of usage on EBCDIC include:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&quot;c&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 模板取决于字符集编码。EBCDIC上的用法示例包括：</target>
        </trans-unit>
        <trans-unit id="5c8f5308cfb898e8f57b9a7b021b28f517778138" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;code&quot;&lt;/code&gt; subroutine will only be used to filter parts of the source code that are not quotelikes, POD, or &lt;code&gt;__DATA__&lt;/code&gt; . The &lt;code&gt;quotelike&lt;/code&gt; subroutine only filters Perl quotelikes (including here documents).</source>
          <target state="translated">的 &lt;code&gt;&quot;code&quot;&lt;/code&gt; 子程序将仅被用于将源代码，不quotelikes，POD，或过滤器部件 &lt;code&gt;__DATA__&lt;/code&gt; 。该 &lt;code&gt;quotelike&lt;/code&gt; 子程序仅过滤的Perl quotelikes（这里包括文档）。</target>
        </trans-unit>
        <trans-unit id="de5cb8ed1d57c1871e5453eb580a0076b635dfd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; pragma</source>
          <target state="translated">在 &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; 编译</target>
        </trans-unit>
        <trans-unit id="5361c21bc61e8999f4b7544ffeef33e12b0b1a2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#!&lt;/code&gt; line is always examined for switches as the line is being parsed. Thus, if you're on a machine that allows only one argument with the &lt;code&gt;#!&lt;/code&gt; line, or worse, doesn't even recognize the &lt;code&gt;#!&lt;/code&gt; line, you still can get consistent switch behaviour regardless of how Perl was invoked, even if &lt;b&gt;-x&lt;/b&gt; was used to find the beginning of the program.</source>
          <target state="translated">该 &lt;code&gt;#!&lt;/code&gt; 解析线路时，始终会检查线路是否有开关。因此，如果您使用的机器上只允许使用 &lt;code&gt;#!&lt;/code&gt; 参数！行，或更糟的是，甚至无法识别 &lt;code&gt;#!&lt;/code&gt; 在第1行中，即使使用&lt;b&gt;-x&lt;/b&gt;查找程序的开始，无论Perl是如何调用的，您仍然可以获得一致的开关行为。</target>
        </trans-unit>
        <trans-unit id="4fb2868e39025eacf0d00ec1478ba8ee01a99e7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$VERSION&lt;/code&gt; variable is used to ensure that the .pm file and the shared library are &quot;in sync&quot; with each other. Any time you make changes to the .pm or .xs files, you should increment the value of this variable.</source>
          <target state="translated">的 &lt;code&gt;$VERSION&lt;/code&gt; 变量用于确保的.pm文件和共享库&amp;ldquo;处于同步&amp;rdquo;彼此。每次更改.pm或.xs文件时，都应增加此变量的值。</target>
        </trans-unit>
        <trans-unit id="2ee72eb90ddce6bbc0931d4e233b1341c5327087" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable (&lt;code&gt;$OSNAME&lt;/code&gt; if you use &lt;code&gt;English&lt;/code&gt; ) contains an indication of the name of the operating system (not its release number) that your perl binary was built for.</source>
          <target state="translated">在 &lt;code&gt;$^O&lt;/code&gt; 变量（ &lt;code&gt;$OSNAME&lt;/code&gt; 如果你用 &lt;code&gt;English&lt;/code&gt; ）包含操作系统（而不是它的版本号），你的perl程序，是为建名的指示。</target>
        </trans-unit>
        <trans-unit id="d2aab00569329bab82f1ebc14faa8b668168dc31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable and the &lt;code&gt;$Config{archname}&lt;/code&gt; values for various DOSish perls are as follows:</source>
          <target state="translated">各种DOSish perls 的 &lt;code&gt;$^O&lt;/code&gt; 变量和 &lt;code&gt;$Config{archname}&lt;/code&gt; 值如下：</target>
        </trans-unit>
        <trans-unit id="eba7fdbb831c55f9a441c12e1806775b9e1de0a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$array[1]&lt;/code&gt; is a single-element access to the array. It's going to return the item in index 1 (or undef if there is no item there). If you intend to get exactly one element from the array, this is the form you should use.</source>
          <target state="translated">的 &lt;code&gt;$array[1]&lt;/code&gt; 是将阵列中的单个元件的访问。它会返回索引1中的项目（如果没有项目，则返回undef）。如果打算从数组中仅获取一个元素，则应使用这种形式。</target>
        </trans-unit>
        <trans-unit id="2844c7d661123084d4f84dec0ab13e6bfc03da52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter can either be a scalar or a scalar reference.</source>
          <target state="translated">的 &lt;code&gt;$buffer&lt;/code&gt; 参数可以是一个标量或标量参考。</target>
        </trans-unit>
        <trans-unit id="27274181277155f678e99b9a2b287e41860c82ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter can either be a scalar or a scalar reference. The contents of the &lt;code&gt;$buffer&lt;/code&gt; parameter are destroyed after calling this function.</source>
          <target state="translated">的 &lt;code&gt;$buffer&lt;/code&gt; 参数可以是一个标量或标量参考。调用此函数后， &lt;code&gt;$buffer&lt;/code&gt; 参数的内容将被销毁。</target>
        </trans-unit>
        <trans-unit id="8c4fb1959a7d1bef1019739dc5a4ea212bbc1a3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt; . On completion it will contain what remains of the input buffer after inflation. This means that &lt;code&gt;$buffer&lt;/code&gt; will be an empty string when the return status is &lt;code&gt;Z_OK&lt;/code&gt; . When the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$buffer&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="translated">所述 &lt;code&gt;$buffer&lt;/code&gt; 参数由改性 &lt;code&gt;inflate&lt;/code&gt; 。完成后，它将包含充气后输入缓冲区的剩余内容。这意味着，当返回状态为 &lt;code&gt;Z_OK&lt;/code&gt; 时， &lt;code&gt;$buffer&lt;/code&gt; 将为空字符串。当返回状态为 &lt;code&gt;Z_STREAM_END&lt;/code&gt; 时， &lt;code&gt;$buffer&lt;/code&gt; 参数将包含放气后的数据流之后存储在输入缓冲区中的内容（如果有的话）。</target>
        </trans-unit>
        <trans-unit id="4deaa69228d0bed93aa2331246fd160457f98868" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$description&lt;/code&gt; is usually a test file name (but only by convention.) It is used as a unique identifier (see e.g. &lt;a href=&quot;#parsers&quot;&gt;parsers&lt;/a&gt;.) Reusing a description is a fatal error.</source>
          <target state="translated">在 &lt;code&gt;$description&lt;/code&gt; 通常是一个测试文件名（但仅限于按约定）。它被用来作为一个唯一的标识符（见例如&lt;a href=&quot;#parsers&quot;&gt;解析器&lt;/a&gt;）重用的描述是一个致命的错误。</target>
        </trans-unit>
        <trans-unit id="04558cf60bc9c7167d85368eb6635a2473770d4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$eof&lt;/code&gt; parameter needs a bit of explanation.</source>
          <target state="translated">在 &lt;code&gt;$eof&lt;/code&gt; 参数需要一点解释。</target>
        </trans-unit>
        <trans-unit id="65f92aaac6b66cd674844396e8d45e3f370fce50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$eof&lt;/code&gt; parameter only needs to be used if &lt;b&gt;all&lt;/b&gt; of the following conditions apply</source>
          <target state="translated">在 &lt;code&gt;$eof&lt;/code&gt; 参数只需要如果要使用&lt;b&gt;所有&lt;/b&gt;的以下条件</target>
        </trans-unit>
        <trans-unit id="8a410599f21ede34ce0c4e99388bf1aa3ff8199e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$gzerrno&lt;/code&gt; scalar holds the error code associated with the most recent</source>
          <target state="translated">在 &lt;code&gt;$gzerrno&lt;/code&gt; 标保存与最近有关的错误代码</target>
        </trans-unit>
        <trans-unit id="6264c4349310ae2e82ed9dccab08bd7526a285d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$in_fh&lt;/code&gt; parameter may be any object that provides a &lt;b&gt;getline()&lt;/b&gt; method to retrieve a single line of input text (hence, an appropriate wrapper object could be used to parse PODs from a single string or an array of strings).</source>
          <target state="translated">所述 &lt;code&gt;$in_fh&lt;/code&gt; 参数可以是提供一个任意对象&lt;b&gt;函数getline（）&lt;/b&gt;方法检索输入文本的一行（因此，适当的包装对象可以从一个单一的字符串或字符串数组用于解析的POD）。</target>
        </trans-unit>
        <trans-unit id="e89b34e9c40c9e18afebc88c2be1c3150fecd52e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$input&lt;/code&gt; and &lt;code&gt;$output&lt;/code&gt; parameters can be either scalars or scalar references.</source>
          <target state="translated">在 &lt;code&gt;$input&lt;/code&gt; 和 &lt;code&gt;$output&lt;/code&gt; 参数可以是标量或标量引用。</target>
        </trans-unit>
        <trans-unit id="d5ad245702c5052688f1d153e2fbd703e2f8f301" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter</source>
          <target state="translated">在 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="daa9f5f9a1ef279c49e625124d1e76146ad5e7d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$level&lt;/code&gt; parameter defines the compression level. Valid values are 0 through 9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; , &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; , &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; , and &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; . If &lt;code&gt;$level&lt;/code&gt; is not specified &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; will be used.</source>
          <target state="translated">在 &lt;code&gt;$level&lt;/code&gt; 参数定义的压缩级别。有效值为0到9， &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; ， &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; ， &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; 和 &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; 。如果未指定 &lt;code&gt;$level&lt;/code&gt; 将使用 &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb33cd5cc665b9c3bd624d64f0ec40381e42cbac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$mon&lt;/code&gt; is zero-based: January equals &lt;code&gt;0&lt;/code&gt; . The &lt;code&gt;$year&lt;/code&gt; is 1900-based: 2001 equals &lt;code&gt;101&lt;/code&gt; . &lt;code&gt;$wday&lt;/code&gt; and &lt;code&gt;$yday&lt;/code&gt; default to zero (and are usually ignored anyway), and &lt;code&gt;$isdst&lt;/code&gt; defaults to -1.</source>
          <target state="translated">该 &lt;code&gt;$mon&lt;/code&gt; 是从零开始：一月等于 &lt;code&gt;0&lt;/code&gt; 。该 &lt;code&gt;$year&lt;/code&gt; 是1900型：2001年相当于 &lt;code&gt;101&lt;/code&gt; 。 &lt;code&gt;$wday&lt;/code&gt; 和 &lt;code&gt;$yday&lt;/code&gt; 默认为零（反正通常被忽略），和 &lt;code&gt;$isdst&lt;/code&gt; 默认为-1。</target>
        </trans-unit>
        <trans-unit id="d866868676edf3ef0ef337619cbb9d7d463b060f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter</source>
          <target state="translated">在 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="c96d672905fea90a5656f24eb9f7936742884276" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$parser&lt;/code&gt; is a &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; object.</source>
          <target state="translated">该 &lt;code&gt;$parser&lt;/code&gt; 是一个&lt;a href=&quot;../parser&quot;&gt;TAP ::分析器&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="0cde3685cee91824cf2720ce6f47ce3c1655541a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$tabstop&lt;/code&gt; variable controls how many column positions apart each tabstop is. The default is 8.</source>
          <target state="translated">在 &lt;code&gt;$tabstop&lt;/code&gt; 变量控制多少列位置除了每个制表位是。预设值为8。</target>
        </trans-unit>
        <trans-unit id="07507ab596d7a55a579157466578b8c289c17f57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$whence&lt;/code&gt; parameter should be one of SEEK_SET, SEEK_CUR or SEEK_END.</source>
          <target state="translated">在 &lt;code&gt;$whence&lt;/code&gt; 参数应该是SEEK_SET，SEEK_CUR或SEEK_END之一。</target>
        </trans-unit>
        <trans-unit id="78200cc1ea59e994c5d2418e77df8c6e8fa8185d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$whence&lt;/code&gt; parameter takes one the usual values, namely SEEK_SET, SEEK_CUR or SEEK_END.</source>
          <target state="translated">在 &lt;code&gt;$whence&lt;/code&gt; 参数需要一个平常值，即SEEK_SET，SEEK_CUR或SEEK_END。</target>
        </trans-unit>
        <trans-unit id="d36c42de8f17d5532305a2dae875ef12d3135188" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$|&lt;/code&gt; is one of the per-filehandle special variables, so each filehandle has its own copy of its value. If you want to merge standard output and standard error for instance, you have to unbuffer each (although STDERR might be unbuffered by default):</source>
          <target state="translated">在 &lt;code&gt;$|&lt;/code&gt; 是每个文件句柄的特殊变量之一，因此每个文件句柄都有自己的值副本。例如，如果要合并标准输出和标准错误，则必须分别取消缓冲（尽管默认情况下STDERR可能未缓冲）：</target>
        </trans-unit>
        <trans-unit id="697d0e02c23a6252ba73964b72ba7fef06e6718b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%^H&lt;/code&gt; hash provides the same scoping semantic as &lt;code&gt;$^H&lt;/code&gt; . This makes it useful for implementation of lexically scoped pragmas. See &lt;a href=&quot;perlpragma&quot;&gt;perlpragma&lt;/a&gt;. All the entries are stringified when accessed at runtime, so only simple values can be accommodated. This means no pointers to objects, for example.</source>
          <target state="translated">的 &lt;code&gt;%^H&lt;/code&gt; 散列提供相同的语义范围界定为 &lt;code&gt;$^H&lt;/code&gt; 。这对于实现词法范围的编译指示很有用。参见&lt;a href=&quot;perlpragma&quot;&gt;perlpragma&lt;/a&gt;。在运行时访问时，所有条目都是字符串化的，因此只能容纳简单的值。例如，这意味着没有指向对象的指针。</target>
        </trans-unit>
        <trans-unit id="0c6228356b1a9a18f543cd58f3d14ae5ed0885fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%s&lt;/code&gt; is expanded to be the filename (&lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; is used, so be careful to escape any other &lt;code&gt;%&lt;/code&gt; signs). The 'commands' are checked for sanity - they must contain the &lt;code&gt;%s&lt;/code&gt; , and the read open must end with the pipe sign, and the write open must begin with the pipe sign.</source>
          <target state="translated">将 &lt;code&gt;%s&lt;/code&gt; 扩展为文件名（使用 &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; ，因此请小心转义任何其他 &lt;code&gt;%&lt;/code&gt; 符号）。检查&amp;ldquo;命令&amp;rdquo;的完整性&amp;ndash;它们必须包含 &lt;code&gt;%s&lt;/code&gt; ，并且读打开必须以管道符号结尾，写打开必须以管道符号开头。</target>
        </trans-unit>
        <trans-unit id="cf6ebcc90a0416e4d456de5b17214b9e0b4a29e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator in the INPUT: section is used to tell &lt;b&gt;xsubpp&lt;/b&gt; that it should convert a Perl value to/from C using the C type to the left of &lt;code&gt;&amp;amp;&lt;/code&gt; , but provide a pointer to this value when the C function is called.</source>
          <target state="translated">INPUT：部分中的 &lt;code&gt;&amp;amp;&lt;/code&gt; 一元运算符用于告诉&lt;b&gt;xsubpp&lt;/b&gt;它应使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 左侧的C类型将Perl值转换为C或从C转换为Perl值，但在调用C函数时提供指向该值的指针。</target>
        </trans-unit>
        <trans-unit id="0b29d8efcd6e9fd3b54226af4554626aa17bc6d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers can also be used on &lt;code&gt;()&lt;/code&gt; groups to force a particular byte-order on all components in that group, including all its subgroups.</source>
          <target state="translated">所述 &lt;code&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&lt;/code&gt; 改性剂也可以在使用 &lt;code&gt;()&lt;/code&gt; 基团，以迫使该组中的所有组件，包括其所有亚组的特定字节顺序。</target>
        </trans-unit>
        <trans-unit id="46a36b2037ff10a0c2a8e03718578280ecd8883f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers can only be used on floating-point formats on big- or little-endian machines. Otherwise, attempting to use them raises an exception.</source>
          <target state="translated">所述 &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&lt;/code&gt; 修饰符只能对大端或小端机浮点格式一起使用。否则，尝试使用它们会引发异常。</target>
        </trans-unit>
        <trans-unit id="99da10732816cfac1a93d49f7cb24d6856262342" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator is most often seen in a &lt;code&gt;while&lt;/code&gt; loop:</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符最常见于一个 &lt;code&gt;while&lt;/code&gt; 循环：</target>
        </trans-unit>
        <trans-unit id="afce8c3936870dcddae71b2f62bcc6619bb65ebe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator performs a globbing operation (see above). In Perl versions earlier than v5.6.0, the internal glob() operator forks csh(1) to do the actual glob expansion, but csh can't handle more than 127 items and so gives the error message &lt;code&gt;Argument list too long&lt;/code&gt; . People who installed tcsh as csh won't have this problem, but their users may be surprised by it.</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符执行一个通配符操作（见上文）。在低于v5.6.0的Perl版本中，内部glob（）运算符派生csh（1）进行实际的glob扩展，但是csh不能处理127个以上的项目，因此错误消息 &lt;code&gt;Argument list too long&lt;/code&gt; 。将tcsh安装为csh的用户不会遇到此问题，但是他们的用户可能对此感到惊讶。</target>
        </trans-unit>
        <trans-unit id="6640438652752fb93dc538db26332c2e258075d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; symbol will return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for end-of-file only once. If you call it again after this, it will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from STDIN.</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 符号将返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 只有一次结束文件。如果在此之后再次调用它，它将假定您正在处理另一个 &lt;code&gt;@ARGV&lt;/code&gt; 列表，如果尚未设置 &lt;code&gt;@ARGV&lt;/code&gt; ，则会从STDIN读取输入。</target>
        </trans-unit>
        <trans-unit id="eb62b601a884f58c8064f8b862089ac2459b0228" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'I'&lt;/code&gt; prefix is used during creation of &lt;code&gt;stdin&lt;/code&gt; ..&lt;code&gt;stderr&lt;/code&gt; via special &lt;code&gt;PerlIO_fdopen&lt;/code&gt; calls; the &lt;code&gt;'#'&lt;/code&gt; prefix means that this is &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; and that</source>
          <target state="translated">在 &lt;code&gt;'I'&lt;/code&gt; 前缀创建的过程中使用 &lt;code&gt;stdin&lt;/code&gt; .. &lt;code&gt;stderr&lt;/code&gt; 通过特殊 &lt;code&gt;PerlIO_fdopen&lt;/code&gt; 电话;在 &lt;code&gt;'#'&lt;/code&gt; 前缀意味着这是 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 和</target>
        </trans-unit>
        <trans-unit id="039ae207dd483bda31bf76d897310e5b8ac60fad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'nomethod'&lt;/code&gt; key is used to specify a catch-all function to be called for any operator that is not individually overloaded. The specified function will be passed four parameters. The first three arguments coincide with those that would have been passed to the corresponding method if it had been defined. The fourth argument is the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; key for that missing method. If the experimental &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; to indicate that the caller is expecting numeric behaviour.</source>
          <target state="translated">该 &lt;code&gt;'nomethod'&lt;/code&gt; 键用于指定一个包罗万象的功能被称为对未单独重载任何操作。指定的函数将传递四个参数。前三个参数与如果已定义相应方法的参数相吻合。第四个参数是该丢失方法的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 键。如果启用了实验性的&amp;ldquo;按位&amp;rdquo;功能（请参见&lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;），则将第五个TRUE参数传递给处理 &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; 的子例程。， &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; 表示呼叫者正在期待数字行为。</target>
        </trans-unit>
        <trans-unit id="a56ee7f30e7bca1dfc3e81783dadbc2bc19f727f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(a|b)*&lt;/code&gt; part can match at every char in the string, and then fail every time because there is no &lt;code&gt;z&lt;/code&gt; in the string. So obviously we can avoid using the regex engine unless there is a &lt;code&gt;z&lt;/code&gt; in the string. Likewise in a pattern like:</source>
          <target state="translated">该 &lt;code&gt;(a|b)*&lt;/code&gt; 部分可以匹配在字符串中的字符每一个，再失败，每次都因为没有 &lt;code&gt;z&lt;/code&gt; 的的字符串中。因此，显然，除非字符串中包含 &lt;code&gt;z&lt;/code&gt; ，否则我们可以避免使用正则表达式引擎。同样的模式如下：</target>
        </trans-unit>
        <trans-unit id="13f6771d5d5f30a227731a56b375d2b66657907c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*_BS&lt;/code&gt; file can put some code into the generated &lt;code&gt;*.bs&lt;/code&gt; file by placing it in &lt;code&gt;$bscode&lt;/code&gt; . This is a handy 'escape' mechanism that may prove useful in complex situations.</source>
          <target state="translated">在 &lt;code&gt;*_BS&lt;/code&gt; 文件可以把一些代码到生成的 &lt;code&gt;*.bs&lt;/code&gt; 通过将其放置在文件 &lt;code&gt;$bscode&lt;/code&gt; 。这是一种方便的&amp;ldquo;转义&amp;rdquo;机制，在复杂情况下可能会很有用。</target>
        </trans-unit>
        <trans-unit id="2ecae669ab5e752a1da7ac780070c852f9269859" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*foo{THING}&lt;/code&gt; notation can also be used to obtain references to the individual elements of *foo. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;*foo{THING}&lt;/code&gt; 表示法也可以被用于获取* foo的单个元素的引用。参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="255645a7c66228ebcb1a14a341007dcfb97aeb51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*x = \$y&lt;/code&gt; mechanism may be used to pass and return cheap references into or from subroutines if you don't want to copy the whole thing. It only works when assigning to dynamic variables, not lexicals.</source>
          <target state="translated">在 &lt;code&gt;*x = \$y&lt;/code&gt; 机制可以用来传递和返回便宜引用或从子程序，如果你不想复制整个事情。仅在分配给动态变量而不是词法时才起作用。</target>
        </trans-unit>
        <trans-unit id="fa1621299f61dcb4d1993cf9ac21afe7e26870e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; form is now obsolete and strongly deprecated.</source>
          <target state="translated">该 &lt;code&gt;+&lt;/code&gt; 的形式是现在已经过时，并强烈反对。</target>
        </trans-unit>
        <trans-unit id="6cc8f120eca26410795cc27186ae2b363ac834f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; prototype is a special alternative to &lt;code&gt;$&lt;/code&gt; that will act like &lt;code&gt;\[@%]&lt;/code&gt; when given a literal array or hash variable, but will otherwise force scalar context on the argument. This is useful for functions which should accept either a literal array or an array reference as the argument:</source>
          <target state="translated">的 &lt;code&gt;+&lt;/code&gt; 原型是一个特别的替代 &lt;code&gt;$&lt;/code&gt; 将充当像 &lt;code&gt;\[@%]&lt;/code&gt; 给出一个字面阵列或散列变量时，反而会否则迫使参数标量上下文。这对于应该接受文字数组或数组引用作为参数的函数很有用：</target>
        </trans-unit>
        <trans-unit id="bb2105637115aa748fce8bf2036dcef89f13282b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; specifier is ignored if the option destination is not a scalar.</source>
          <target state="translated">在 &lt;code&gt;+&lt;/code&gt; 如果选项目的不是标符被忽略。</target>
        </trans-unit>
        <trans-unit id="6806c6a2e8d1792a36b6bbc8a8afc151b341b78f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; unary operator doesn't do anything in Perl. It exists to avoid syntactic ambiguities.</source>
          <target state="translated">在 &lt;code&gt;+&lt;/code&gt; 一元运算符并不在Perl做任何事情。它的存在是为了避免句法歧义。</target>
        </trans-unit>
        <trans-unit id="37675ebea1632ec83c2cb0e9f47bb19d76dac534" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;&lt;/code&gt; syntax is also used when dereferencing a reference. It looks like the same operator, but these are two different operations.</source>
          <target state="translated">的 &lt;code&gt;-&amp;gt;&lt;/code&gt; 语法也解除引用的参考时使用。看起来好像是同一操作符，但是这是两个不同的操作。</target>
        </trans-unit>
        <trans-unit id="d4b0e534108246bac541ccb7068bc25380ccc720" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;new()&lt;/code&gt; method is an alias for &lt;code&gt;-&amp;gt;create()&lt;/code&gt; .</source>
          <target state="translated">的 &lt;code&gt;-&amp;gt;new()&lt;/code&gt; 方法是用于一个别名 &lt;code&gt;-&amp;gt;create()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="127cc52ec86933168c2c1aece6f9b232d7cd7b7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--rules&lt;/code&gt; option is used to control which tests are run sequentially and which are run in parallel, if the &lt;code&gt;--jobs&lt;/code&gt; option is specified. The option may be specified multiple times, and the order matters.</source>
          <target state="translated">该 &lt;code&gt;--rules&lt;/code&gt; 选项用于哪些测试被顺序地运行并且被并行运行控制，如果 &lt;code&gt;--jobs&lt;/code&gt; 选项被指定。可以多次指定该选项，并且顺序很重要。</target>
        </trans-unit>
        <trans-unit id="608a757f76e2d49976d1abe026a19ab9cb45d134" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--state&lt;/code&gt; switch may be used more than once.</source>
          <target state="translated">该 &lt;code&gt;--state&lt;/code&gt; 开关可以使用一次以上。</target>
        </trans-unit>
        <trans-unit id="cc3c8ce0b0c852fbdda4091c52f36592afcdc410" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--state&lt;/code&gt; switch requires an argument which must be a comma separated list of one or more of the following options.</source>
          <target state="translated">所述 &lt;code&gt;--state&lt;/code&gt; 开关需要必须是一个逗号参数分隔的一个或多个下面的选项的列表。</target>
        </trans-unit>
        <trans-unit id="377dc2d9444ba53f1e07b9f9c8ed4eb80a1854c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--trap&lt;/code&gt; option will attempt to trap SIGINT (Ctrl-C) during a test run and display the test summary even if the run is interrupted</source>
          <target state="translated">该 &lt;code&gt;--trap&lt;/code&gt; 选项将在测试运行期间尝试陷阱SIGINT（CTRL-C），并显示即使运行被中断的测试总结</target>
        </trans-unit>
        <trans-unit id="e392f25b1c4fe3943f476468712579d620408f6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; command line switch</source>
          <target state="translated">所述 &lt;code&gt;-A&lt;/code&gt; 命令行开关</target>
        </trans-unit>
        <trans-unit id="597b9a9c8e6ccba33470cbc78977519edc52f8e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; omits the Autoloader code, &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; omits XS elements, &lt;code&gt;--skip-exporter&lt;/code&gt; omits the Exporter code, &lt;code&gt;--&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;-new-tests&lt;/code&gt; sets up a modern testing environment, and &lt;code&gt;-n&lt;/code&gt; specifies the name of the module.</source>
          <target state="translated">该 &lt;code&gt;-A&lt;/code&gt; 忽略了自动装弹机代码， &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 遗漏XS元素， &lt;code&gt;--skip-exporter&lt;/code&gt; 省略了出口商的代码， &lt;code&gt;--&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;-new-tests&lt;/code&gt; 建立了一个现代化的测试环境，并 &lt;code&gt;-n&lt;/code&gt; 指定模块的名称。</target>
        </trans-unit>
        <trans-unit id="c623c1943d0dabf76760d7670756f1a93a94f39a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Dusecbacktrace&lt;/code&gt; also enables keeping the debug information when compiling/linking (often: &lt;code&gt;-g&lt;/code&gt; ). Many compilers/linkers do support having both optimization and keeping the debug information. The debug information is needed for the symbol names and the source locations.</source>
          <target state="translated">该 &lt;code&gt;-Dusecbacktrace&lt;/code&gt; 还能够保持调试信息编译/链接时（通常是： &lt;code&gt;-g&lt;/code&gt; ）。许多编译器/链接器都支持同时具有优化和保留调试信息。符号名称和源位置需要调试信息。</target>
        </trans-unit>
        <trans-unit id="63378b07c96f9b709eea4a8451598ec112926512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; switches work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If, so it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;../perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;-T&lt;/code&gt; 和 &lt;code&gt;-B&lt;/code&gt; 开关的工作如下。检查文件的第一个块左右，以查看它是否是包含非ASCII字符的有效UTF-8。如果是，那么它是 &lt;code&gt;-T&lt;/code&gt; 文件。否则，将检查文件的同一部分中是否有奇怪的字符，例如奇怪的控制代码或设置了高位的字符。如果超过三分之一的字符是奇怪的， &lt;code&gt;-B&lt;/code&gt; 文件；否则，为-B文件。否则，它是 &lt;code&gt;-T&lt;/code&gt; 文件。同样，在检查的部分中任何包含零字节的文件都被视为二进制文件。 （如果在包含 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的&lt;a href=&quot;../perllocale&quot;&gt;使用语言环境&lt;/a&gt;的范围内执行，则奇数字符是在当前语言环境中既不可打印也不可空格的任何字符。） &lt;code&gt;-T&lt;/code&gt; 在文件句柄上使用-T或 &lt;code&gt;-B&lt;/code&gt; ，将检查当前IO缓冲区而不是第一个块。在测试文件句柄时， &lt;code&gt;-T&lt;/code&gt; 和 &lt;code&gt;-B&lt;/code&gt; 在空文件或EOF处的文件上均返回true。因为必须读取文件才能进行 &lt;code&gt;-T&lt;/code&gt; 测试，所以在大多数情况下，您首先要对文件使用 &lt;code&gt;-f&lt;/code&gt; ，就像 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; 要使用-f一样，除非-f $ file &amp;amp;&amp;amp; -T $ file。</target>
        </trans-unit>
        <trans-unit id="c91ca83f347b61a13eb65089f07047ddb67d9622" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; switches work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If, so it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;-T&lt;/code&gt; 和 &lt;code&gt;-B&lt;/code&gt; 开关的工作如下。检查文件的第一个块左右，以查看它是否是包含非ASCII字符的有效UTF-8。如果是，那么它是 &lt;code&gt;-T&lt;/code&gt; 文件。否则，将检查文件的同一部分中是否有奇怪的字符，例如奇怪的控制代码或设置了高位的字符。如果超过三分之一的字符是奇怪的， &lt;code&gt;-B&lt;/code&gt; 文件；否则，为-B文件。否则，它是 &lt;code&gt;-T&lt;/code&gt; 文件。同样，在检查的部分中任何包含零字节的文件都被视为二进制文件。 （如果在包含 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的&lt;a href=&quot;perllocale&quot;&gt;使用语言环境&lt;/a&gt;的范围内执行，则奇数字符是在当前语言环境中既不可打印也不可空格的任何字符。） &lt;code&gt;-T&lt;/code&gt; 在文件句柄上使用-T或 &lt;code&gt;-B&lt;/code&gt; ，将检查当前IO缓冲区而不是第一个块。在测试文件句柄时， &lt;code&gt;-T&lt;/code&gt; 和 &lt;code&gt;-B&lt;/code&gt; 在空文件或EOF处的文件上均返回true。因为必须读取文件才能进行 &lt;code&gt;-T&lt;/code&gt; 测试，所以在大多数情况下，您首先要对文件使用 &lt;code&gt;-f&lt;/code&gt; ，就像 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; 要使用-f一样，除非-f $ file &amp;amp;&amp;amp; -T $ file。</target>
        </trans-unit>
        <trans-unit id="9bc0f3fa215c39800076a942f11672815853d1f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Wall&lt;/code&gt; is by default on.</source>
          <target state="translated">该 &lt;code&gt;-Wall&lt;/code&gt; 是默认的。</target>
        </trans-unit>
        <trans-unit id="6dfbaa82d695de76db5a43cbdf063e4ffac5d9ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Wtraditional&lt;/code&gt; is another example of the annoying tendency of gcc to bundle a lot of warnings under one switch (it would be impossible to deploy in practice because it would complain a lot) but it does contain some warnings that would be beneficial to have available on their own, such as the warning about string constants inside macros containing the macro arguments: this behaved differently pre-ANSI than it does in ANSI, and some C compilers are still in transition, AIX being an example.</source>
          <target state="translated">该 &lt;code&gt;-Wtraditional&lt;/code&gt; 是gcc的恼人倾向捆绑了很多警告的下一个开关的另一个例子（这将是不可能在实践中部署，因为它会抱怨很多），但它确实包含了一些警告，这将是有益的可用就其本身而言，例如关于包含宏参数的宏内的字符串常量的警告：在ANSI之前的行为与在ANSI中的行为不同，并且某些C编译器仍在过渡中，以AIX为例。</target>
        </trans-unit>
        <trans-unit id="dea68b3a7d6bdc421299da6629ccc22d6bd7b572" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-ansi&lt;/code&gt; (and its sidekick, &lt;code&gt;-pedantic&lt;/code&gt; ) would be nice to be on always, but unfortunately they are not safe on all platforms, they can for example cause fatal conflicts with the system headers (Solaris being a prime example). If Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; is used, the &lt;code&gt;cflags&lt;/code&gt; frontend selects &lt;code&gt;-ansi -pedantic&lt;/code&gt; for the platforms where they are known to be safe.</source>
          <target state="translated">该 &lt;code&gt;-ansi&lt;/code&gt; （和它的搭档， &lt;code&gt;-pedantic&lt;/code&gt; ）将是很好的始终，但不幸的是他们不是在所有平台上的安全，它们可以例如导致系统标题（的Solaris是一个最好的例子）致命的冲突。如果使用Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; ，则 &lt;code&gt;cflags&lt;/code&gt; 前端会为已知安全的平台选择 &lt;code&gt;-ansi -pedantic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb94d9f2c59455332a30530ef3be81c2f437b975" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-h&lt;/code&gt; option will show a usage message.</source>
          <target state="translated">该 &lt;code&gt;-h&lt;/code&gt; 选项将显示用法消息。</target>
        </trans-unit>
        <trans-unit id="02d034bd54a852b799ddb0bca00601006bc9ad62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-newlex&lt;/code&gt; option produces a more readable &lt;code&gt;name =&amp;gt; value&lt;/code&gt; format, and is shown in the second example above.</source>
          <target state="translated">所述 &lt;code&gt;-newlex&lt;/code&gt; 选项生成一个更可读的 &lt;code&gt;name =&amp;gt; value&lt;/code&gt; 格式，并且在上面的第二个例子被示出。</target>
        </trans-unit>
        <trans-unit id="3ed7e26de1fd10b827d09512227b49a4f8d06d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-nosp&lt;/code&gt; option eliminates reporting of SPECIALs, such as &lt;code&gt;0: SPECIAL
#1 &amp;amp;PL_sv_undef&lt;/code&gt; above. Reporting of SPECIALs can sometimes overwhelm your declared lexicals.</source>
          <target state="translated">所述 &lt;code&gt;-nosp&lt;/code&gt; 选项消除特价报告，诸如 &lt;code&gt;0: SPECIAL #1 &amp;amp;PL_sv_undef&lt;/code&gt; 上方。SPECIAL的报告有时会使您所声明的词汇不堪重负。</target>
        </trans-unit>
        <trans-unit id="063586d44811e787a3acc7fa9925ec22a0e1ef32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-pretty&lt;/code&gt; directive is called too late to affect matters. You have to do this instead, and</source>
          <target state="translated">该 &lt;code&gt;-pretty&lt;/code&gt; 指令被称为来不及影响的事项。您必须这样做，并且</target>
        </trans-unit>
        <trans-unit id="64b5e1fcc02dcf849bd221c8c257f81fb47b92a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-q&lt;/code&gt; and &lt;code&gt;-qq&lt;/code&gt; options don't work correctly if perl isn't compiled with PerlIO support : STDOUT will be closed instead of being redirected to &lt;code&gt;$O::BEGIN_output&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;-q&lt;/code&gt; 和 &lt;code&gt;-qq&lt;/code&gt; 如果是用perl不PerlIO的支持编译选项不能正常工作：STDOUT将被关闭，而不是被重定向到 &lt;code&gt;$O::BEGIN_output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6261ab8564541d33e35c7ac1e97aa8a5e571dd14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-qq&lt;/code&gt; option behaves like &lt;code&gt;-q&lt;/code&gt;, except that it also closes STDERR after deparsing has finished. This suppresses the &quot;Syntax OK&quot; message normally produced by perl.</source>
          <target state="translated">该 &lt;code&gt;-qq&lt;/code&gt; 选项的行为就像 &lt;code&gt;-q&lt;/code&gt; ，但它也deparsing完成后关闭STDERR。这抑制了perl通常生成的&amp;ldquo;语法确定&amp;rdquo;消息。</target>
        </trans-unit>
        <trans-unit id="cb173d8eff47f06c7e37f7374c7227453a2ad4d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-u&lt;/code&gt; switch causes the VMS debugger to be invoked after the Perl program is compiled, but before it has run. It does not create a core dump file.</source>
          <target state="translated">该 &lt;code&gt;-u&lt;/code&gt; 开关使Perl程序被编译后要调用的VMS调试器，但它已运行之前。它不会创建核心转储文件。</target>
        </trans-unit>
        <trans-unit id="1e542d84460c8b59074b5a3d74792d84cf2329fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; and &lt;code&gt;...&lt;/code&gt; flip-flop operators. Note that the &lt;code&gt;...&lt;/code&gt; flip-flop operator is completely different from the &lt;code&gt;...&lt;/code&gt; elliptical statement just described.</source>
          <target state="translated">该 &lt;code&gt;..&lt;/code&gt; 和 &lt;code&gt;...&lt;/code&gt; 触发器运营商。请注意， &lt;code&gt;...&lt;/code&gt; 触发器运算符与刚刚描述的 &lt;code&gt;...&lt;/code&gt; 椭圆语句完全不同。</target>
        </trans-unit>
        <trans-unit id="8189082aec1c35ce34b10a2a482272d1f9442cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; range operator treats certain character ranges with care on EBCDIC platforms. For example the following array will have twenty six elements on either an EBCDIC platform or an ASCII platform:</source>
          <target state="translated">该 &lt;code&gt;..&lt;/code&gt; 范围操作符对待某些字符范围小心在EBCDIC平台。例如，以下数组在EBCDIC平台或ASCII平台上将具有26个元素：</target>
        </trans-unit>
        <trans-unit id="1bfc1b4066699d36e1a1c96b8bf42e5d376ee7e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;//&lt;/code&gt; matching operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;. It operates on &lt;code&gt;$_&lt;/code&gt; by default, or can be bound to another variable using the &lt;code&gt;=~&lt;/code&gt; binding operator (also documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;).</source>
          <target state="translated">该 &lt;code&gt;//&lt;/code&gt; 匹配运算符中记录&lt;a href=&quot;perlop&quot;&gt;perlop中&lt;/a&gt;。默认情况下，它在 &lt;code&gt;$_&lt;/code&gt; 上操作，或者可以使用 &lt;code&gt;=~&lt;/code&gt; 绑定运算符（也记录在&lt;a href=&quot;perlop&quot;&gt;perlop中&lt;/a&gt;）绑定到另一个变量。</target>
        </trans-unit>
        <trans-unit id="32ef826cb43c384876c66cdfd8ef3d6094273ed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;//a&lt;/code&gt; modifier, available starting in Perl 5.14, is used to restrict the matches of \d, \s, and \w to just those in the ASCII range. It is useful to keep your program from being needlessly exposed to full Unicode (and its accompanying security considerations) when all you want is to process English-like text. (The &quot;a&quot; may be doubled, &lt;code&gt;//aa&lt;/code&gt; , to provide even more restrictions, preventing case-insensitive matching of ASCII with non-ASCII characters; otherwise a Unicode &quot;Kelvin Sign&quot; would caselessly match a &quot;k&quot; or &quot;K&quot;.)</source>
          <target state="translated">所述 &lt;code&gt;//a&lt;/code&gt; 改性剂，在Perl 5.14获得的起始，用于限制\ d S的匹配，\，和\ w至只是那些在ASCII范围。当您只需要处理类似英语的文本时，使您的程序避免不必要地暴露于完整的Unicode（及其伴随的安全性考虑）非常有用。 （&amp;ldquo; a&amp;rdquo;可以加倍 &lt;code&gt;//aa&lt;/code&gt; ，以提供更多限制，防止ASCII与非ASCII字符不区分大小写的匹配；否则，Unicode&amp;ldquo; Kelvin Sign&amp;rdquo;将无条件地匹配&amp;ldquo; k&amp;rdquo;或&amp;ldquo; K&amp;rdquo; ）</target>
        </trans-unit>
        <trans-unit id="4d28a339cbae1f464fa994976dfeef2db93a1d7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/&lt;/code&gt; template character allows packing and unpacking of a sequence of items where the packed structure contains a packed item count followed by the packed items themselves. This is useful when the structure you're unpacking has encoded the sizes or repeat counts for some of its fields within the structure itself as separate fields.</source>
          <target state="translated">该 &lt;code&gt;/&lt;/code&gt; 模板性质允许包装和项目的序列，其中的填充结构包含打包项目计数，然后打包项目本身的拆包。当您要拆包的结构将其内部某些字段的大小或重复计数编码为单独的字段时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="8377a1a6991c29f230dc12ce290846f6b362ebc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/a&lt;/code&gt; modifier, on the other hand, may be useful. Its purpose is to allow code that is to work mostly on ASCII data to not have to concern itself with Unicode.</source>
          <target state="translated">的 &lt;code&gt;/a&lt;/code&gt; 改性剂，在另一方面，可能是有用的。其目的是使主要用于ASCII数据的代码不必与Unicode有关。</target>
        </trans-unit>
        <trans-unit id="9d46362c6dee371fc1e41d5a94fbe9c509a82363" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/d&lt;/code&gt;, &lt;code&gt;/u&lt;/code&gt; , and &lt;code&gt;/l&lt;/code&gt; modifiers are not likely to be of much use to you, and so you need not worry about them very much. They exist for Perl's internal use, so that complex regular expression data structures can be automatically serialized and later exactly reconstituted, including all their nuances. But, since Perl can't keep a secret, and there may be rare instances where they are useful, they are documented here.</source>
          <target state="translated">将 &lt;code&gt;/d&lt;/code&gt; ， &lt;code&gt;/u&lt;/code&gt; ，和 &lt;code&gt;/l&lt;/code&gt; 修饰符不可能多大用处给你的，所以你不必对他们非常担心。它们存在的目的是供Perl内部使用，因此可以自动序列化复杂的正则表达式数据结构，并在以后对其进行精确重构，包括所有细微差别。但是，由于Perl不能保密，并且在少数情况下它们很有用，因此在此处进行了说明。</target>
        </trans-unit>
        <trans-unit id="7a635bd3deb5f6d1f8ced7e30d0ca4af436ee119" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/e&lt;/code&gt; will also silently ignore violations of strict, replacing undefined variable names with the empty string. Since I'm using the &lt;code&gt;/e&lt;/code&gt; flag (twice even!), I have all of the same security problems I have with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; in its string form. If there's something odd in &lt;code&gt;$foo&lt;/code&gt; , perhaps something like &lt;code&gt;@{[ &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; &quot;rm -rf /&quot; ]}&lt;/code&gt; , then I could get myself in trouble.</source>
          <target state="translated">该 &lt;code&gt;/e&lt;/code&gt; 也将忽略这些违规行为的严格，用空字符串替换未定义的变量名。由于我正在使用 &lt;code&gt;/e&lt;/code&gt; 标志（甚至是两次！），因此我遇到了与字符串形式的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 相同的所有安全问题。如果 &lt;code&gt;$foo&lt;/code&gt; 有些奇怪的东西，也许像 &lt;code&gt;@{[ &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; &quot;rm -rf /&quot; ]}&lt;/code&gt; ，那么我可能会遇到麻烦。</target>
        </trans-unit>
        <trans-unit id="613bcc3a2284ecc4926054a5b934f30e880d5007" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/g&lt;/code&gt; modifier specifies global pattern matching--that is, matching as many times as possible within the string. How it behaves depends on the context. In list context, it returns a list of the substrings matched by any capturing parentheses in the regular expression. If there are no parentheses, it returns a list of all the matched strings, as if there were parentheses around the whole pattern.</source>
          <target state="translated">The &lt;code&gt;/g&lt;/code&gt; modifier specifies global pattern matching--that is, matching as many times as possible within the string. How it behaves depends on the context. In list context, it returns a list of the substrings matched by any capturing parentheses in the regular expression. If there are no parentheses, it returns a list of all the matched strings, as if there were parentheses around the whole pattern.</target>
        </trans-unit>
        <trans-unit id="987314591903795033c1fec25347d7b594aec577" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/l&lt;/code&gt; and &lt;code&gt;/u&lt;/code&gt; modifiers are automatically selected for regular expressions compiled within the scope of various pragmas, and we recommend that in general, you use those pragmas instead of specifying these modifiers explicitly. For one thing, the modifiers affect only pattern matching, and do not extend to even any replacement done, whereas using the pragmas give consistent results for all appropriate operations within their scopes. For example,</source>
          <target state="translated">在 &lt;code&gt;/l&lt;/code&gt; 和 &lt;code&gt;/u&lt;/code&gt; 修饰符自动选择不同的编译指示的范围之内编译的正则表达式，我们建议在一般情况下，您使用的，而不是明确指定这些修饰的编译指示。一方面，修饰符仅影响模式匹配，甚至不会扩展到任何已完成的替换，而使用编译指示可在其范围内为所有适当的操作提供一致的结果。例如，</target>
        </trans-unit>
        <trans-unit id="9a222e38b5a40a1bf140094ce44f5b0c1b82a0ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/o&lt;/code&gt; option for regular expressions (documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt;) tells Perl to compile the regular expression only once. This is only useful when the pattern contains a variable. Perls 5.6 and later handle this automatically if the pattern does not change.</source>
          <target state="translated">正则表达式的 &lt;code&gt;/o&lt;/code&gt; 选项（在&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;和&lt;a href=&quot;perlreref&quot;&gt;perlreref中有说明&lt;/a&gt;）告诉Perl仅一次编译正则表达式。仅在模式包含变量时才有用。如果模式不变，Perls 5.6和更高版本将自动处理此问题。</target>
        </trans-unit>
        <trans-unit id="02f1967b4475720a962bf35cfc3049c63165e0f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/x&lt;/code&gt; modifier causes whitespace to be ignored in a regex pattern (except in a character class and a few other places), and also allows you to use normal comments there, too. As you can imagine, whitespace and comments help a lot.</source>
          <target state="translated">该 &lt;code&gt;/x&lt;/code&gt; 修改原因空白在正则表达式模式被忽略（除了在字符类和其他几个地方），也可以让你有使用普通的意见了。您可以想象，空格和注释会很有帮助。</target>
        </trans-unit>
        <trans-unit id="26a965e97d532904de76cbb5ec7fa62c78040c70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0x&lt;/code&gt; prefix means a hexadecimal number, the digits are 0-9</source>
          <target state="translated">该 &lt;code&gt;0x&lt;/code&gt; 前缀是指一个十六进制数，数字0-9</target>
        </trans-unit>
        <trans-unit id="c084ffd08879b68d48b86f14b0edd6d007fd471f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; tag, now discouraged, is the old version of &lt;code&gt;:bsd_glob&lt;/code&gt; . It exports the same constants and functions, but its glob() override does not support iteration; it returns the last file name in scalar context. That means this will loop forever:</source>
          <target state="translated">现在不建议使用 &lt;code&gt;:&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 标记，它是 &lt;code&gt;:bsd_glob&lt;/code&gt; 的旧版本。它导出相同的常量和函数，但其​​glob（）覆盖不支持迭代；它返回标量上下文中的最后一个文件名。这意味着它将永远循环：</target>
        </trans-unit>
        <trans-unit id="4231c54d461bf5e25a3f991c3ecf987daad7c115" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:ALL&lt;/code&gt; tag will get all of the above exports.</source>
          <target state="translated">的 &lt;code&gt;:ALL&lt;/code&gt; 标签将得到所有上述出口。</target>
        </trans-unit>
        <trans-unit id="f4ffb1e41b5af144e1e66d6009daba34fcfe78d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bsd_glob&lt;/code&gt; export tag exports bsd_glob() and the constants listed below. It also overrides glob() in the calling package with one that behaves like bsd_glob() with regard to spaces (the space is treated as part of a file name), but supports iteration in scalar context; i.e., it preserves the core function's feature of returning the next item each time it is called.</source>
          <target state="translated">的 &lt;code&gt;:bsd_glob&lt;/code&gt; 出口标签出口bsd_glob（）和下面列出的常量。它还用一个在行为方面类似于bsd_glob（）的行为覆盖调用包中的glob（）（该空间被视为文件名的一部分），但在标量上下文中支持迭代。即，它保留了核心函数每次调用时返回下一个项目的功能。</target>
        </trans-unit>
        <trans-unit id="e5933b7ecdff0d26d0d1ee137373273e087ab3ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt; , &lt;code&gt;:crlf&lt;/code&gt; , &lt;code&gt;:utf8&lt;/code&gt; , and any other directives of the form &lt;code&gt;:...&lt;/code&gt; , are called I/O</source>
          <target state="translated">的 &lt;code&gt;:bytes&lt;/code&gt; ， &lt;code&gt;:crlf&lt;/code&gt; ， &lt;code&gt;:utf8&lt;/code&gt; 和形式的任何其他指令 &lt;code&gt;:...&lt;/code&gt; ...，被称为I / O</target>
        </trans-unit>
        <trans-unit id="586c160f0002e3dc300faf81c49d6dc770a315b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt; layer corresponds to &quot;binary mode&quot; and the &lt;code&gt;:crlf&lt;/code&gt; layer corresponds to &quot;text mode&quot; on platforms that distinguish between the two modes when opening files (which is many DOS-like platforms, including Windows). These two layers are no-ops on platforms where binmode() is a no-op, but perform their functions everywhere if PerlIO is enabled.</source>
          <target state="translated">的 &lt;code&gt;:bytes&lt;/code&gt; 层对应于&amp;ldquo;二进制模式&amp;rdquo;和 &lt;code&gt;:crlf&lt;/code&gt; 层对应于&amp;ldquo;文本模式&amp;rdquo;上打开文件时（这是DOS状许多平台，包括Windows）在两种模式之间区分的平台。在binmode（）是无操作的平台上，这两层是无操作的，但是如果启用了PerlIO，则在任何地方都将执行其功能。</target>
        </trans-unit>
        <trans-unit id="ec6da40dddc20e97c2aa930b3dff507bcb27589f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:default&lt;/code&gt; bundle represents the feature set that is enabled before any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature&lt;/code&gt; declaration.</source>
          <target state="translated">的 &lt;code&gt;:default&lt;/code&gt; 捆绑表示之前的任何启用该功能集 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature&lt;/code&gt; 的声明。</target>
        </trans-unit>
        <trans-unit id="a790449d8cd7160d313e0f6fd7d2b5f5cd711410" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_external&lt;/code&gt; requires one boolean argument.</source>
          <target state="translated">的 &lt;code&gt;:gzip_external&lt;/code&gt; 需要一个boolean变量。</target>
        </trans-unit>
        <trans-unit id="bc95aee8e2b941e818640ac51c8f3c3052958780" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_external&lt;/code&gt; requires one string argument.</source>
          <target state="translated">的 &lt;code&gt;:gzip_external&lt;/code&gt; 需要一个字符串参数。</target>
        </trans-unit>
        <trans-unit id="20c0f5f557ffbe0666f0dfcd916d2b61a638ef52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_read_open&lt;/code&gt; argument must end with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;USING THE EXTERNAL GZIP&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;:gzip_read_open&lt;/code&gt; 参数必须与管道标识尾部（|），并有 &lt;code&gt;%s&lt;/code&gt; 作为文件名。请参阅&lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;使用外部GZIP&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="740fe127c4ced02d559ebb2a859c745ac796eb7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_write_open&lt;/code&gt; argument must begin with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. An output redirect (&amp;gt;) is also often a good idea, depending on your operating system shell syntax. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;USING THE EXTERNAL GZIP&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;:gzip_write_open&lt;/code&gt; 参数必须与管道符号开头（|），并有 &lt;code&gt;%s&lt;/code&gt; 作为文件名。根据您的操作系统外壳语法，输出重定向（&amp;gt;）通常也是个好主意。请参阅&lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;使用外部GZIP&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="244205effe1c86456dd4171100ec82efbb0324f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; does not currently work with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;, only with the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma. The &lt;code&gt;:utf8&lt;/code&gt; and &lt;code&gt;:encoding(...)&lt;/code&gt; methods do work with all of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;, and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma.</source>
          <target state="translated">在 &lt;code&gt;:locale&lt;/code&gt; 目前没有一起工作 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; ，仅与 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 编译。的 &lt;code&gt;:utf8&lt;/code&gt; 和 &lt;code&gt;:encoding(...)&lt;/code&gt; 方法做了所有工作 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; ，和 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 编译。</target>
        </trans-unit>
        <trans-unit id="b0a7c262fbc0be9a9844fe48c62a845c0f4528fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; sub-pragma</source>
          <target state="translated">在 &lt;code&gt;:locale&lt;/code&gt; 子编译</target>
        </trans-unit>
        <trans-unit id="90148b6fce0bbabdeb9d2a0e71e782bdff20ba4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:mmap&lt;/code&gt; layer will not exist if the platform does not support &lt;code&gt;mmap()&lt;/code&gt; .</source>
          <target state="translated">的 &lt;code&gt;:mmap&lt;/code&gt; 如果平台不支持层将不存在 &lt;code&gt;mmap()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd944a87b4f64134b2d5190fde7ca74a27bd05a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:raw&lt;/code&gt; layer is</source>
          <target state="translated">的 &lt;code&gt;:raw&lt;/code&gt; 层是</target>
        </trans-unit>
        <trans-unit id="eb8af45fe08808536fe0e78893d59ec120f251eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:std&lt;/code&gt; subpragma on its own has no effect, but if combined with the &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding&lt;/code&gt; subpragmas, it converts the standard filehandles (STDIN, STDOUT, STDERR) to comply with encoding selected for input/output handles. For example, if both input and out are chosen to be &lt;code&gt;:encoding(utf8)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; will mean that STDIN, STDOUT, and STDERR are also in &lt;code&gt;:encoding(utf8)&lt;/code&gt; . On the other hand, if only output is chosen to be in &lt;code&gt;:encoding(koi8r)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; will cause only the STDOUT and STDERR to be in &lt;code&gt;koi8r&lt;/code&gt; . The &lt;code&gt;:locale&lt;/code&gt; subpragma implicitly turns on &lt;code&gt;:std&lt;/code&gt; .</source>
          <target state="translated">的 &lt;code&gt;:std&lt;/code&gt; 自身subpragma没有效果，但如果与组合 &lt;code&gt;:utf8&lt;/code&gt; 或 &lt;code&gt;:encoding&lt;/code&gt; subpragmas，将其转换的标准文件句柄（STDIN，STDOUT STDERR）遵守用编码选择用于输入/输出的把手。例如，如果输入和输出都选择为 &lt;code&gt;:encoding(utf8)&lt;/code&gt; ，则 &lt;code&gt;:std&lt;/code&gt; 表示STDIN，STDOUT和STDERR也位于 &lt;code&gt;:encoding(utf8)&lt;/code&gt; 中。另一方面，如果仅选择在 &lt;code&gt;:encoding(koi8r)&lt;/code&gt; 中输出，则 &lt;code&gt;:std&lt;/code&gt; 将仅导致STDOUT和STDERR进入 &lt;code&gt;koi8r&lt;/code&gt; 。该 &lt;code&gt;:locale&lt;/code&gt; subpragma隐含开启 &lt;code&gt;:std&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2743b792818bf7f895d0f0b22baae763060aa81f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:void&lt;/code&gt; option is supported in &lt;a href=&quot;fatal&quot;&gt;Fatal&lt;/a&gt;, but not &lt;code&gt;autodie&lt;/code&gt; . To workaround this, &lt;code&gt;autodie&lt;/code&gt; may be explicitly disabled until the end of the current block with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; . To disable autodie for only a single function (eg, open) use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(open)&lt;/code&gt; .</source>
          <target state="translated">的 &lt;code&gt;:void&lt;/code&gt; 选项在支持&lt;a href=&quot;fatal&quot;&gt;致命&lt;/a&gt;，但不 &lt;code&gt;autodie&lt;/code&gt; 。要解决此， &lt;code&gt;autodie&lt;/code&gt; 可以明确地禁用，直到与当前块的末尾 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; 。要仅对单个功能（例如open）禁用autodie，请 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(open)&lt;/code&gt; 使用autodie qw（open）。</target>
        </trans-unit>
        <trans-unit id="67318be992f4377bb68fbe49ed99f910c657a047" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method is used to create an instance of the filter. It is called indirectly by Perl when it encounters the &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; MyFilter&lt;/code&gt; line in a source file (See &lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt; for more details on &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法用于创建过滤器的一个实例。当Perl 在源文件中遇到 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; MyFilter&lt;/code&gt; 行时，它会间接调用它（有关&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;的更多详细信息，请参见 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="69849addd7818fee9c7e8c167a05d6c0d2986859" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; will</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 意志</target>
        </trans-unit>
        <trans-unit id="0eafa6355d483056647b2819a7f67215461c3497" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call returns an object, say &lt;code&gt;$o&lt;/code&gt; . You may call</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用返回的对象，说 &lt;code&gt;$o&lt;/code&gt; 。你可以打电话</target>
        </trans-unit>
        <trans-unit id="51ffe3fc21c6601c2932126d4f4eca5123604eda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; 构建体也可用于阵列/散列元素的删除定位于当前块。请参见&lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsub中复合类型元素的局部删除&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1621ad946434d6c08e6becea5950298e8d654de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; 构建本地化的缺失在运行时当前块。在该块退出之前，暂时删除的本地元素不再存在。请参见&lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsub中复合类型元素的局部删除&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="413b32076323a1b9dc32ef8307740eba59479274" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function executes a system command</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 功能执行系统命令</target>
        </trans-unit>
        <trans-unit id="2195a8cff19304cef2dc99fbcce68cf6dbdaf4fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; function is not implemented on all versions of Windows. Check the documentation for your specific version of Perl.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 函数未在所有的Windows版本中实现。查看文档以了解特定版本的Perl。</target>
        </trans-unit>
        <trans-unit id="1cc7a7cd989d44101ffb59063ba0d9ec90f901e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; operator will attempt to insure that no translation of carriage control occurs on input from or output to this filehandle. Since this involves reopening the file and then restoring its file position indicator, if this function returns FALSE, the underlying filehandle may no longer point to an open file, or may point to a different position in the file than before &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 操作者将试图确保没有托架控制的翻译从输入或输出到该文件句柄发生。由于这涉及到重新打开文件然后恢复其文件位置指示符，因此，如果此函数返回FALSE，则底层文件句柄可能不再指向打开的文件，或者可能指向文件中与调用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 之前不同的位置。</target>
        </trans-unit>
        <trans-unit id="d7b9155394683e2730126a87d41bdd8b7ec8ee0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; functions work on whole characters.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; 函数对整个人物的工作。</target>
        </trans-unit>
        <trans-unit id="b8d018fd592275cef4c6f8f9148b669393d46ef8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; operator uses the &lt;code&gt;sys$hash_password&lt;/code&gt; system service to generate the hashed representation of PLAINTEXT. If USER is a valid username, the algorithm and salt values are taken from that user's UAF record. If it is not, then the preferred algorithm and a salt of 0 are used. The quadword encrypted value is returned as an 8-character string.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; 操作员使用 &lt;code&gt;sys$hash_password&lt;/code&gt; 系统服务产生明文的哈希表示。如果USER是有效的用户名，则算法和盐值将从该用户的UAF记录中获取。如果不是，则使用首选算法和盐0。四字加密值以8个字符的字符串形式返回。</target>
        </trans-unit>
        <trans-unit id="51567ba352ff0d9256d32ae3d4a4cc5e55c3b1bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; 构建体也可用于阵列/散列元素的删除定位于当前块。请参见&lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsub中复合类型元素的局部删除&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="205f4f4c053e1354b5fd41e9a973041210cd6cb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; 构建本地化的缺失在运行时当前块。在该块退出之前，暂时删除的本地元素不再存在。请参见&lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsub中复合类型元素的局部删除&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c330ed0d1614413aef6482d1172074b901ca8ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; construct isn't a real loop that you can use loop control on.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; 构造是不是一个真正的循环，你可以使用闭环控制。</target>
        </trans-unit>
        <trans-unit id="bf5bbfe9093c8abccc03e7c7efe8dbe3d8e0233d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; operator can be a bit tricky though. You can't add or delete keys of the hash while you're using it without possibly skipping or re-processing some pairs after Perl internally rehashes all of the elements. Additionally, a hash has only one iterator, so if you mix &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; on the same hash, you risk resetting the iterator and messing up your processing. See the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; entry in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="translated">尽管 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; 运算符可能有些棘手。在使用散列时，您不能添加或删除散列的键，而在Perl内部对所有元素进行重新散列后，可能无法跳过或重新处理某些对。另外，一个哈希只有一个迭代器，因此，如果您在同一哈希中混合使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; ，则可能会重置迭代器并弄乱您的处理。有关更多详细信息，请参见&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;的 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="6a7ce17abb69e82a8250b438247bf503d68963f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; operator returns the pairs in apparently random order, so if ordering matters to you, you'll have to stick with the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 操作员返回显然随机顺序对，所以如果排序的问题给你，你必须坚持与 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 的方法。</target>
        </trans-unit>
        <trans-unit id="1d704aced95cc8764eb35404aac65f2304fbf2d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; method wrapped an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; around a &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;, and so waited for a thread to exit, passing along any values the thread might have returned and placing any errors into &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 方法包裹的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 周围 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; ，所以等待线程退出，沿着螺纹可能返回的任何值传递和放置任何错误到 &lt;code&gt;$@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80c53083069f05797eef5848d626cca139bde071" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; feature enables the &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; keyword, which evaluates the argument passed to it as a string of bytes. It dies if the string contains any characters outside the 8-bit range. Source filters work within &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt;: they apply to the contents of the string being evaluated.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; 特征使 &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; 关键字，其评估传递给它作为字节串的论点。如果该字符串包含8位范围以外的任何字符，它将终止。源过滤器在 &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; 内工作：它们适用于要评估的字符串的内容。</target>
        </trans-unit>
        <trans-unit id="013c20c8a39c1e9d213753c8f42aa60136c4133a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function executes a system command</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 功能执行系统命令</target>
        </trans-unit>
        <trans-unit id="cc6b445e37f9fe0173dc131ac1ed2864194322f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function's job is to turn your process into another command and never to return. If that's not what you want to do, don't use &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;. :)</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 功能的任务是把你的过程到另一个命令，并再也没有回来。如果那不是您想要的，请不要使用 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 。:)</target>
        </trans-unit>
        <trans-unit id="c64c8f5547bb2a6573770267608423f5c2aa4dc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for(each)&lt;/a&gt;&lt;/code&gt; modifier is an iterator: it executes the statement once for each item in the LIST (with &lt;code&gt;$_&lt;/code&gt; aliased to each item in turn).</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for(each)&lt;/a&gt;&lt;/code&gt; 修饰符是一个迭代器：它执行该语句一次列表中的每个项目（以 &lt;code&gt;$_&lt;/code&gt; 又化名为每个项目）。</target>
        </trans-unit>
        <trans-unit id="fcbb7f06dac39b4543299760a90086a0717180ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; 功能，即使只需要一个说法，有一个列表操作符的优先级，所以要小心：</target>
        </trans-unit>
        <trans-unit id="d7025a8a8790fde9485d755f6c425f01c04b8467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; operator will function properly if you have a working CRTL &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; routine, or if the logical name SYS$TIMEZONE_DIFFERENTIAL is defined as the number of seconds which must be added to UTC to yield local time. (This logical name is defined automatically if you are running a version of VMS with built-in UTC support.) If neither of these cases is true, a warning message is printed, and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 的，如果你有一个工作CRTL运营商将正常工作 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 程序，或者如果逻辑名SYS $ TIMEZONE_DIFFERENTIAL定义为必须添加到UTC以获得本地时间的秒数。 （如果您正在运行具有内置UTC支持的VMS版本，则将自动定义此逻辑名。）如果以上两种情况均不成立，则将显示警告消息，并返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a3ff2f4c2a7967681e4811d9bc792e927dbfcbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by local()) and immediately calls in its place the named subroutine using the current value of @_. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; 形式从其他形式的完全不同的 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 。实际上，从根本上说，它根本不是goto，也没有与其他goto相关的污名。而是，它退出当前子例程（丢失由local（）设置的任何更改），并立即使用@_的当前值在其位置调用命名子例程。希望加载另一个子例程的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 子例程使用此方法，然后假装首先调用了另一个子例程（除了当前子例程中对 &lt;code&gt;@_&lt;/code&gt; 的任何修改都会传播到另一个子例程。） &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 之后，甚至没有 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 就能知道该例程首先被调用。</target>
        </trans-unit>
        <trans-unit id="8c6cdb8b9140a3413b924a1be37defd8094c23ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , below. This is especially useful for implementing tail recursion via &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 形式预计评价 &lt;code&gt;EXPR&lt;/code&gt; 到代码引用或标签名称。如果它评估为代码引用，则将像下面的 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; 一样进行处理。这对于通过 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; 实现尾递归特别有用。</target>
        </trans-unit>
        <trans-unit id="f9a08aec53b4872b20c38601dfe1ff47bb7271a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; in other languages.)</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; 形式发现标有LABEL的语句，并继续执行那里。它不能用于退出给 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 指定的块或子例程。它可以用于动态范围内的几乎所有其他地方，包括子例程之外的其他地方，但是通常最好使用诸如 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 的其他构造。 Perl的作者从未感觉过需要使用这种形式的 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; （在Perl中，C是另一回事）。 （不同之处在于C不提供与循环控制相结合的命名循环。Perl则提供了此功能，并且它替换了其他语言中 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 的大多数结构化用法。）</target>
        </trans-unit>
        <trans-unit id="fd5e7141b6809acf60b4ffb9ca0527589ab4d1fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-&amp;amp;NAME form is highly magical, and substitutes a call to the named subroutine for the currently running subroutine. This is used by &lt;code&gt;AUTOLOAD()&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; - ＆名称形式是非常神奇的，并替换为当前运行的子程序命名子程序调用。 &lt;code&gt;AUTOLOAD()&lt;/code&gt; 子例程使用此方法，该子例程希望加载另一个子例程，然后假装首先调用了另一个子例程（除了当前子例程中对 &lt;code&gt;@_&lt;/code&gt; 的任何修改都会传播到另一个子例程。） &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; ，甚至 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 都不会知道该例程是首先被调用的。</target>
        </trans-unit>
        <trans-unit id="0f2fbb144491503128d3d631573fe99dbb58cb74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-EXPR form expects a label name, whose scope will be resolved dynamically. This allows for computed &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -expr形式需要一个标签名称，其范围将动态解析。这允许每个FORTRAN 计算 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; ，但是如果您要针对可维护性进行优化，则不一定建议这样做：</target>
        </trans-unit>
        <trans-unit id="747fd1051ce1561b7aad0a462ec80a7083e807f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-LABEL form finds the statement labeled with LABEL and resumes execution there. It may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is--C is another matter).</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -label形式发现标有LABEL的语句，并继续执行那里。它可能不能用于需要初始化的任何构造，例如子例程或 &lt;code&gt;foreach&lt;/code&gt; 循环。也不能将其用于经过优化的结构。它可以用于动态范围内的几乎所有其他地方，包括子例程之外的其他地方，但是通常最好使用诸如 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 的其他构造。Perl的作者从未感到需要使用这种形式的 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; （在Perl中，C是另一回事）。</target>
        </trans-unit>
        <trans-unit id="b3e30e59d91f75eda248244fb51004176883c63f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in scalar context returns the count. If you want the list of matching items, just use it in list context instead:</source>
          <target state="translated">标量上下文中的 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 返回计数。如果您想要匹配项的列表，只需在列表上下文中使用它即可：</target>
        </trans-unit>
        <trans-unit id="612dabc89cee10beadc6c980b04dfdba8cc2e280" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; function also resets the iterator, which means that you may see strange results if you use this between uses of other hash operators such as &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; 函数还复位迭代，这意味着可能会看到奇怪的结果如果使用这种其它散列运营商的使用之间，例如 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84a92b66f23e84ffcea0f8036601109332768c0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; function can be used to test this functionality from within a program.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 功能可用于在程序中测试此功能。</target>
        </trans-unit>
        <trans-unit id="8f9dd8be24cd7b207201afca586d0393221c8761" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; function in the parent's &lt;code&gt;if&lt;/code&gt; block is there to send a signal to our child process, currently running in the &lt;code&gt;else&lt;/code&gt; block, as soon as the remote server has closed its end of the connection.</source>
          <target state="translated">远程服务器关闭连接结束后，父级 &lt;code&gt;if&lt;/code&gt; 块中的 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 函数就会向当前在 &lt;code&gt;else&lt;/code&gt; 块中运行的子进程发送信号。</target>
        </trans-unit>
        <trans-unit id="8bfb3b07d45ff01232bb221af626a6a5fb4ea5a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command immediately exits the loop in question. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 命令立即退出有问题的循环。在 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，如果有的话，不执行：</target>
        </trans-unit>
        <trans-unit id="ac302bdab0f919a07174f63d0969bebc85f1b892" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 命令是像 &lt;code&gt;break&lt;/code&gt; 在C（如在循环使用）语句; 它立即退出有问题的循环。如果省略了LABEL，则该命令引用最里面的封闭循环。从Perl 5.18.0开始可用的 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; 格式允许在运行时计算标签名称，否则与 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; 相同。在 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，如果有的话，不执行：</target>
        </trans-unit>
        <trans-unit id="506963259280dc353e83831a1d7243717b046918" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; Keyword</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; 关键字</target>
        </trans-unit>
        <trans-unit id="249bfee98e5c2e5ddbdeda77c1a70bb97c684fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; function takes a shared variable and puts a lock on it. No other thread may lock the variable until the variable is unlocked by the thread holding the lock. Unlocking happens automatically when the locking thread exits the block that contains the call to the &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; function. Using &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; is straightforward: This example has several threads doing some calculations in parallel, and occasionally updating a running total:</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; 函数获得一个共享变量，并把锁就可以了。直到持有锁的线程将变量解锁，其他线程才可以锁定该变量。当锁定线程退出包含对 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; 函数的调用的块时，将自动进行解锁。使用 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; 很简单：此示例有多个线程并行执行一些计算，并偶尔更新运行总计：</target>
        </trans-unit>
        <trans-unit id="844dd628839d69aa91981cfdf9d35b8aa941b210" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; is actually not required; you could just use:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 实际上不是必需的; 您可以使用：</target>
        </trans-unit>
        <trans-unit id="15c7027f68a72fedc245e7d612cf00a82d9df24d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; is simply a modifier on something you might assign to. So when you do assign to variables in its argument list, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; doesn't change whether those variables are viewed as a scalar or an array. So</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 简直就是一些你可能分配给修饰符。因此，当您在其参数列表中分配变量时，无论变量被视为标量还是数组， &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 都不会改变。所以</target>
        </trans-unit>
        <trans-unit id="82cb7d6fd4d7d98853ace6ba4000362cdc7fa762" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; operator declares the listed variables to be lexically confined to the enclosing block, conditional (&lt;code&gt;if/unless/elsif/else&lt;/code&gt;), loop (&lt;code&gt;for/foreach/while/until/continue&lt;/code&gt;), subroutine, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do/require/use&lt;/a&gt;&lt;/code&gt;'d file. If more than one value is listed, the list must be placed in parentheses. All listed elements must be legal lvalues. Only alphanumeric identifiers may be lexically scoped--magical built-ins like &lt;code&gt;$/&lt;/code&gt; must currently be &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized with &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 操作声明中列出的变量是词法仅限于封闭块，条件（ &lt;code&gt;if/unless/elsif/else&lt;/code&gt; ），循环（ &lt;code&gt;for/foreach/while/until/continue&lt;/code&gt; ），子程序， &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，或 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do/require/use&lt;/a&gt;&lt;/code&gt; 的文件。如果列出了多个值，则该列表必须放在括号中。所有列出的元素必须是合法的左值。只有字母数字标识符可以词法范围-神奇的内置插件类似 &lt;code&gt;$/&lt;/code&gt; 当前必须 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 与美化版 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="598c24981891ed39a33542154be0ea54335c8268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 命令是一样 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 使用C语句; 它开始循环的下一个迭代：</target>
        </trans-unit>
        <trans-unit id="4ac987f577bf457aa0aa7edd6027d43957e00541" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command starts the next iteration of the loop:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 命令开始循环的下一次迭代：</target>
        </trans-unit>
        <trans-unit id="90d027781b9d30c834bc3f75976b8010ac44b08a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keywords work differently.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; ，并 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 关键字的工作方式不同。</target>
        </trans-unit>
        <trans-unit id="5eeb76addad99da0bbdd65d75ec9e60f2b34827f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma doesn't</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 编译不</target>
        </trans-unit>
        <trans-unit id="7bf3b5adc84fde6d734586f4bec0209359aa5187" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; lib&lt;/code&gt; statement deletes all instances of each named directory from @INC.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; lib&lt;/code&gt; 语句删除从@INC每个指定目录的所有实例。</target>
        </trans-unit>
        <trans-unit id="1aa289805fbc7ad3a1863fbfa81d350e063c7221" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;|-&quot;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(BAR, &quot;-|&quot;)&lt;/code&gt; constructs are not yet implemented. This limitation can be easily worked around in new code by creating a pipe explicitly. The following example shows how to write to a forked child:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;|-&quot;)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(BAR, &quot;-|&quot;)&lt;/code&gt; 结构尚未实现。通过显式创建管道，可以在新代码中轻松解决此限制。下面的示例显示了如何写入派生的孩子：</target>
        </trans-unit>
        <trans-unit id="91b6442686235ec3446ecfbcfcc1b68ae5f717df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma serves as one of the interfaces to declare default &quot;layers&quot; (also known as &quot;disciplines&quot;) for all I/O. Any two-argument open(), readpipe() (aka qx//) and similar operators found within the lexical scope of this pragma will use the declared defaults. Even three-argument opens may be affected by this pragma when they don't specify IO layers in MODE.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 的pragma用作接口申报默认&amp;ldquo;层&amp;rdquo;（也称为&amp;ldquo;学科&amp;rdquo;）为所有的I / O中的一个。在此编译指示的词法范围内找到的任何两个参数的open（），readpipe（）（aka qx //）和类似的运算符都将使用声明的默认值。如果未在MODE中指定IO层，则即使是三参数打开也可能会受到此编译指示的影响。</target>
        </trans-unit>
        <trans-unit id="d568cb2b48539b711386365d8e03258e04c0c727" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; functions work transparently on all codepoints, not just on ASCII alone &amp;mdash; nor in fact, not even just on Unicode alone.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 功能上的所有代码点透明地工作，而不仅仅是ASCII单独-也不事实上，甚至不仅仅是对Unicode的孤独。</target>
        </trans-unit>
        <trans-unit id="48c955c71d75929afac22e8dfa9aad63b2004a10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator showed up in perl 5.005. It compiles a regular expression, but doesn't apply it. When you use the pre-compiled version of the regex, perl does less work. In this example, I inserted a &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; to turn each pattern into its pre-compiled form. The rest of the script is the same, but faster:</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 运营商在Perl 5.005露面。它编译一个正则表达式，但不应用它。使用正则表达式的预编译版本时，perl的工作量较少。在此示例中，我插入了一个 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; ，将每个模式转换为其预编译的形式。脚本的其余部分相同，但速度更快：</target>
        </trans-unit>
        <trans-unit id="6086a140e1b37399f10a989a119aa2028d369c83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 命令重新启动循环块，而无需再次评价以下条件。在 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，如果有的话，</target>
        </trans-unit>
        <trans-unit id="362e8253628830d9a4d5614fd639fe79bc546984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;
LABEL&lt;/code&gt; . Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 命令重新启动循环块，而无需再次评价以下条件。在 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，如果有的话，不执行。如果省略了LABEL，则该命令引用最里面的封闭循环。从Perl 5.18.0开始可用的 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; 格式允许在运行时计算标签名称，否则与 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; LABEL&lt;/code&gt; 相同。想要对自己所输入的内容撒谎的程序通常使用以下命令：</target>
        </trans-unit>
        <trans-unit id="f9c130f1621f9ce97dabd985717a6055d0d6afd0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; substitution operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 替换操作在记录&lt;a href=&quot;perlop&quot;&gt;perlop中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="121511ae0b5d1fbb23eba64b638e8a05d463c939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; function is another place where a regexp is used. &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; /regexp/, string, limit&lt;/code&gt; separates the &lt;code&gt;string&lt;/code&gt; operand into a list of substrings and returns that list. The regexp must be designed to match whatever constitutes the separators for the desired substrings. The &lt;code&gt;limit&lt;/code&gt; , if present, constrains splitting into no more than &lt;code&gt;limit&lt;/code&gt; number of strings. For example, to split a string into words, use</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; 函数是其中使用正则表达式另一个地方。 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; /regexp/, string, limit&lt;/code&gt; 将 &lt;code&gt;string&lt;/code&gt; 操作数分成子字符串列表，并返回该列表。必须将正则表达式设计为匹配所需子字符串的分隔符。该 &lt;code&gt;limit&lt;/code&gt; ，如果存在的话，约束分裂成不超过 &lt;code&gt;limit&lt;/code&gt; 数量的字符串。例如，要将字符串拆分为单词，请使用</target>
        </trans-unit>
        <trans-unit id="7f7da5ebd320780203ed7d5e0028f1f486db3bfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword creates a lexical variable (following the same scoping rules as &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;) that persists from one subroutine call to the next. If a state variable resides inside an anonymous subroutine, then each copy of the subroutine has its own copy of the state variable. However, the value of the state variable will still persist between calls to the same copy of the anonymous subroutine. (Don't forget that &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; { ... }&lt;/code&gt; creates a new subroutine each time it is executed.)</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 的关键字创建一个词法变量（以下同范围的规则为 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ）从一个子程序调用一直持续到下一个。如果状态变量驻留在匿名子例程中，则该子例程的每个副本都有其自己的状态变量副本。但是，状态变量的值仍将在两次调用匿名子例程的相同副本之间保持不变。（不要忘记 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; { ... }&lt;/code&gt; 每次执行都会创建一个新的子例程。）</target>
        </trans-unit>
        <trans-unit id="87a4764ce311581074e8327a658c6ee1ed914b66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; probes gain a fourth argument: the package name of the function.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; 探头获得第四个参数：函数的包名。</target>
        </trans-unit>
        <trans-unit id="fa495b532decb2c8f20d40c7506dd35df2aff6f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; built-in is considered to have failed in the following circumstances:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 内置的被认为是失败在下列情况下：</target>
        </trans-unit>
        <trans-unit id="007bfa453d22a010bcc25f103e9e741d0e19770d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; operator creates a subprocess, and passes its arguments to the subprocess for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt; , any valid DCL command string may be specified. If the string begins with '@', it is treated as a DCL command unconditionally. Otherwise, if the first token contains a character used as a delimiter in file specification (e.g. &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt;), an attempt is made to expand it using a default type of</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 操作者创建子进程，和将其参数传递到子进程来执行作为DCL命令。由于子过程是通过 &lt;code&gt;lib$spawn()&lt;/code&gt; 直接创建的，因此可以指定任何有效的DCL命令字符串。如果字符串以&amp;ldquo; @&amp;rdquo;开头，则无条件地将其视为DCL命令。否则，如果第一个标记包含用作文件规范中定界符的字符（例如 &lt;code&gt;:&lt;/code&gt; 或 &lt;code&gt;]&lt;/code&gt; ），则会尝试使用默认类型扩展它</target>
        </trans-unit>
        <trans-unit id="c442498b077f35c1d517c581c1d1aa5d5b6d170c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; function returns elapsed realtime since some point in the past (such as system startup), user and system times for this process, and user and system times used by child processes. All times are returned in clock ticks.</source>
          <target state="translated">自过去某个时间点（例如系统启动）以来， &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; 函数返回经过的实时时间，该进程的用户和系统时间以及子进程使用的用户和系统时间。所有时间都以时钟滴答数返回。</target>
        </trans-unit>
        <trans-unit id="80b97318408e6d656bf28c96d67c4dfdc24c2653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; operator translates whole characters. (Note that the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///CU&lt;/a&gt;&lt;/code&gt; functionality has been removed. For similar functionality to that, see &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('U0', ...)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('C0', ...)&lt;/code&gt; ).</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 运营商整体转换的字符。（请注意， &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///CU&lt;/a&gt;&lt;/code&gt; 功能已删除。有关此功能，请参见 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('U0', ...)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('C0', ...)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="11a568ea0ae08ef300d37d167d740832b4c2b16f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; alternative might look like this:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 的替代可能是这样的：</target>
        </trans-unit>
        <trans-unit id="42f87c254ee8d81cee26e792f60cacaefbfbe36a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; counts the null bytes. The &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; call returns a list of name-value pairs each of which is taken apart in the &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; block.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 计数空字节。该 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 调用返回其中的每一个拆开的名称-值对的列表 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="a53ff006297297281156ad4ddc8aef0830e3811c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; version is a clear winner. One solution is flexible, the other is fast - and it's appropriately the programmer's choice which to use.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 版本是一个明显的赢家。一种解决方案是灵活的，另一种是快速的-使用哪种是程序员的适当选择。</target>
        </trans-unit>
        <trans-unit id="6f47b182b84a1df9e8040499b142da5e15a5a35d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; Gotcha</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 疑难杂症</target>
        </trans-unit>
        <trans-unit id="5e2ca855aa217bd553e610f05dba85cf9019d5da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma disables character semantics for the rest of the lexical scope in which it appears. &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; bytes&lt;/code&gt; can be used to reverse the effect of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; within the current lexical scope.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 编译指示禁止字符语义在它所在的词法作用域的其余部分。在当前词法范围内，不能使用 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; bytes&lt;/code&gt; 来反转 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 的效果。</target>
        </trans-unit>
        <trans-unit id="9fdef637aec2a8c40d4ef4a640873fd3daeaa545" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; filetest&lt;/code&gt; statements affect file tests defined in their block, up to the end of the closest enclosing block (they are lexically block-scoped).</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; filetest&lt;/code&gt; 语句影响对其块中定义，最多到最接近的封闭块的端部（它们是词法块范围的）文件的测试。</target>
        </trans-unit>
        <trans-unit id="8744ea2543ae1b476ba91732c622f01f08c1038b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma tells the Perl parser to allow UTF-8 in the program text in the current lexical scope (allow UTF-EBCDIC on EBCDIC based platforms). The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8&lt;/code&gt; pragma tells Perl to switch back to treating the source text as literal bytes in the current lexical scope.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 编译告诉Perl的解析器允许UTF-8在当前词法范围的程序文本（允许UTF-EBCDIC基于EBCDIC平台）。所述 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8&lt;/code&gt; 编译告诉Perl切换回处理所述源文本作为当前词法作用域字面字节。</target>
        </trans-unit>
        <trans-unit id="43067066e43761608ec314550d1ef0009ca78c23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; switch will warn you if it interprets a reserved word as a string. But it will no longer warn you about using lowercase words, because the string is effectively quoted.</source>
          <target state="translated">如果将保留字解释为字符串，则 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 编译指示或&lt;b&gt;-w&lt;/b&gt;开关将警告您。但这将不再警告您使用小写单词，因为该字符串已被有效引用。</target>
        </trans-unit>
        <trans-unit id="19cdd025fab18dcd164b56bb8b49804d47261c9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma produces some lovely diagnostics. One can also use the &lt;b&gt;-w&lt;/b&gt; flag, but its use is normally discouraged, because it gets applied to all executed Perl code, including that not under your control.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 编译产生一些可爱的诊断。也可以使用&lt;b&gt;-w&lt;/b&gt;标志，但是通常不建议使用&lt;b&gt;-w&lt;/b&gt;标志，因为它会应用于所有已执行的Perl代码，包括不受您控制的代码。</target>
        </trans-unit>
        <trans-unit id="98ff32ffdb1aaec51b5964ab04fedf9b556042ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; 功能，即使只需要一个说法，有一个列表操作符的优先级，所以要小心：</target>
        </trans-unit>
        <trans-unit id="57bb7a10c9bf27aba4e74945efa7f4324ecc8306" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by local()) and immediately calls in its place the named subroutine using the current value of @_. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; 形式从其他形式的完全不同的 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 。实际上，从一般意义上讲，它根本不是goto，也没有与其他goto相关的污名。而是，它退出当前子例程（丢失由local（）设置的任何更改），并立即使用@_的当前值在其位置调用命名子例程。希望加载另一个子例程的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 子例程使用此方法，然后假装首先调用了另一个子例程（除了当前子例程中对 &lt;code&gt;@_&lt;/code&gt; 的任何修改都会传播到另一个子例程。） &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 之后，甚至没有 &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 就能知道该例程首先被调用。</target>
        </trans-unit>
        <trans-unit id="e45cfef5656ef233c1972b6e6db8f04158149f58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , below. This is especially useful for implementing tail recursion via &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 形式预计评价 &lt;code&gt;EXPR&lt;/code&gt; 到代码引用或标签名称。如果它评估为代码引用，则将像下面的 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; 一样进行处理。这对于通过 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; 实现尾部递归特别有用。</target>
        </trans-unit>
        <trans-unit id="a0fba7d2ee7cbb751d9b45951b63706bcd429d8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; in other languages.)</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; 形式发现标有LABEL的语句，并继续执行那里。它不能用于退出给 &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 的块或子例程。它可以用于动态范围内的几乎所有其他地方，包括子例程之外的其他地方，但是通常最好使用其他构造，例如 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 。 Perl的作者从未感到过需要使用这种形式的 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; （在Perl中，C是另一回事）。 （不同之处在于，C不提供与循环控制相结合的命名循环。Perl则提供了这种组合，它替代了其他语言中 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 的大多数结构化用法。）</target>
        </trans-unit>
        <trans-unit id="0ec2144df4bcb647e47e9a3fffb037716e0ff735" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 命令是像 &lt;code&gt;break&lt;/code&gt; 在C（如在循环使用）语句; 它立即退出有问题的循环。如果省略了LABEL，则该命令引用最里面的封闭循环。从Perl 5.18.0开始可用的 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; 格式允许在运行时计算标签名称，否则与 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; 相同。在 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，如果有的话，不执行：</target>
        </trans-unit>
        <trans-unit id="0dc04adeb5f33f6be3e55c3b75049d3460dd5faf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 命令是一样 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 使用C语句; 它开始循环的下一个迭代：</target>
        </trans-unit>
        <trans-unit id="d90f5477a728439ae001b7de4028bc5063fe8048" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; pragma can be used to set default modifiers (including these) for regular expressions compiled within its scope. This pragma has precedence over the other pragmas listed below that also change the defaults.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; 编译指示可用于设定的默认调节剂（包括这些），用于在其范围内已编译的正则表达式。该实用程序优先于下面列出的其他实用程序，这些其他实用程序也会更改默认值。</target>
        </trans-unit>
        <trans-unit id="00f56e4e287b4dad7bb9b00175cad4e28ccf4f49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;
LABEL&lt;/code&gt; . Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 命令重新启动循环块，而无需再次评价以下条件。在 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，如果有的话，不执行。如果省略了LABEL，则该命令引用最里面的封闭循环。从Perl 5.18.0开始可用的 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; 格式允许在运行时计算标签名称，否则与 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; LABEL&lt;/code&gt; 相同。想要对自己所输入的内容撒谎的程序通常使用以下命令：</target>
        </trans-unit>
        <trans-unit id="98d8fed67bad4314d20d9f4fe777fa7ab53123e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (sometimes pronounced &quot;fat comma&quot;) is a synonym for the comma except that it causes a word on its left to be interpreted as a string if it begins with a letter or underscore and is composed only of letters, digits and underscores. This includes operands that might otherwise be interpreted as operators, constants, single number v-strings or function calls. If in doubt about this behavior, the left operand can be quoted explicitly.</source>
          <target state="translated">的 &lt;code&gt;=&amp;gt;&lt;/code&gt; 运算符（有时发音为&amp;ldquo;脂肪逗号&amp;rdquo;）是逗号的同义词不同之处在于它会导致在其左侧，如果它以字母或下划线开始被解释为字符串的单词和只由字母，数字组成和下划线。这包括可能被解释为运算符，常量，单数字v字符串或函数调用的操作数。如果对此行为有疑问，可以显式引用左操作数。</target>
        </trans-unit>
        <trans-unit id="8399dbf8e2e784c4274bc7b091a4f7216970d51b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is helpful in documenting the correspondence between keys and values in hashes, and other paired elements in lists.</source>
          <target state="translated">的 &lt;code&gt;=&amp;gt;&lt;/code&gt; 运算符是在记录在散列中列出了其他成对的元件的键和值之间的对应关系，和有帮助的。</target>
        </trans-unit>
        <trans-unit id="efd3e2bb957eaa0ff2ef103df55bdfaea8225389" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=back&lt;/code&gt; command does not take any arguments.</source>
          <target state="translated">该 &lt;code&gt;=back&lt;/code&gt; 的命令不带任何参数。</target>
        </trans-unit>
        <trans-unit id="2748bc14f635bff7b4cada98a19718c4d6f31834" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=begin&lt;/code&gt; directive can mark a section for a particular purpose. If the Pod parser doesn't want to handle it, it just ignores it. Label the comments with &lt;code&gt;comment&lt;/code&gt; . End the comment using &lt;code&gt;=end&lt;/code&gt; with the same label. You still need the &lt;code&gt;=cut&lt;/code&gt; to go back to Perl code from the Pod comment:</source>
          <target state="translated">该 &lt;code&gt;=begin&lt;/code&gt; 指令可以标记为特定目的的部分。如果Pod解析器不想处理它，则将其忽略。用 &lt;code&gt;comment&lt;/code&gt; 标记注释。使用 &lt;code&gt;=end&lt;/code&gt; 结束注释并带有相同标签。您仍然需要 &lt;code&gt;=cut&lt;/code&gt; 从Pod注释返回到Perl代码：</target>
        </trans-unit>
        <trans-unit id="ef8064ce24f5339d152aec47e53a990ce73ae1e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=over&lt;/code&gt; command does not have a corresponding &lt;code&gt;=back&lt;/code&gt; before the next heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt; ) or the end of the file.</source>
          <target state="translated">的 &lt;code&gt;=over&lt;/code&gt; 命令不具有对应 &lt;code&gt;=back&lt;/code&gt; 下一标题之前（ &lt;code&gt;=head1&lt;/code&gt; 或 &lt;code&gt;=head2&lt;/code&gt; ）或文件的末尾。</target>
        </trans-unit>
        <trans-unit id="8153dbca699722108378e052ce04788e510ab3df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@EXPORT&lt;/code&gt; array tells Perl which of the extension's variables and subroutines should be placed into the calling package's namespace. Because you don't know if the user has already used your variable and subroutine names, it's vitally important to carefully select what to export. Do</source>
          <target state="translated">在 &lt;code&gt;@EXPORT&lt;/code&gt; 数组告诉Perl其扩展的变量和子程序应放在调用包的命名空间。因为您不知道用户是否已经使用了变量名和子例程名，所以仔细选择要导出的内容至关重要。做</target>
        </trans-unit>
        <trans-unit id="59c8e98631ebe2ad43446558b18c0e9a67b97b20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@array[1]&lt;/code&gt; is an array slice, although it has only one index. You can pull out multiple elements simultaneously by specifying additional indices as a list, like &lt;code&gt;@array[1,4,3,0]&lt;/code&gt; .</source>
          <target state="translated">所述 &lt;code&gt;@array[1]&lt;/code&gt; 是一个数组切片，尽管它仅具有一个索引。您可以通过将其他索引指定为列表来同时提取多个元素，例如 &lt;code&gt;@array[1,4,3,0]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="651c155493f8eecba5929c58d7483ab06d1863f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ACTUAL&lt;/code&gt; tells &lt;code&gt;NEXT&lt;/code&gt; that there must actually be a next method to call, or it should throw an exception.</source>
          <target state="translated">在 &lt;code&gt;ACTUAL&lt;/code&gt; 告诉 &lt;code&gt;NEXT&lt;/code&gt; 一定有实际上是调用下一个方法，或者它应该抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="8e537d261fb0eb0877ceb1c6331c23797b3540cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alias&lt;/code&gt; module implements localization of the basic types within the</source>
          <target state="translated">该 &lt;code&gt;Alias&lt;/code&gt; 模块实现定位的基本类型的内</target>
        </trans-unit>
        <trans-unit id="2c6a8f1a286c25be4929a3d652924543120a4cba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Archive::Tar&lt;/code&gt; module can optionally use &lt;code&gt;Compress::Zlib&lt;/code&gt; (via the &lt;code&gt;IO::Zlib&lt;/code&gt; module) to access tar files that have been compressed with &lt;code&gt;gzip&lt;/code&gt; . Unfortunately tar files compressed with the Unix &lt;code&gt;compress&lt;/code&gt; utility cannot be read by &lt;code&gt;Compress::Zlib&lt;/code&gt; and so cannot be directly accesses by &lt;code&gt;Archive::Tar&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;Archive::Tar&lt;/code&gt; 模块可以选择使用 &lt;code&gt;Compress::Zlib&lt;/code&gt; （通过 &lt;code&gt;IO::Zlib&lt;/code&gt; 模块）对已压缩的访问tar文件 &lt;code&gt;gzip&lt;/code&gt; 。不幸的是， &lt;code&gt;Compress::Zlib&lt;/code&gt; 无法读取使用Unix &lt;code&gt;compress&lt;/code&gt; 实用程序压缩的tar文件，因此 &lt;code&gt;Archive::Tar&lt;/code&gt; 无法直接访问。</target>
        </trans-unit>
        <trans-unit id="43769b61441be000184345132a2a54dc3708064b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B::COP&lt;/code&gt; class is used for &quot;nextstate&quot; and &quot;dbstate&quot; ops. As of Perl 5.22, it is also used for &quot;null&quot; ops that started out as COPs.</source>
          <target state="translated">的 &lt;code&gt;B::COP&lt;/code&gt; 类是用于&amp;ldquo;nextstate&amp;rdquo;和&amp;ldquo;dbstate&amp;rdquo; OPS。从Perl 5.22开始，它还用于以COP开头的&amp;ldquo;空&amp;rdquo;操作。</target>
        </trans-unit>
        <trans-unit id="1a2938ca3d630d110b73048269c361ea78fb5cb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module contains a set of utility functions for querying the current state of the Perl interpreter; typically these functions return objects from the B::SV and B::OP classes, or their derived classes. These classes in turn define methods for querying the resulting objects about their own internal state.</source>
          <target state="translated">所述 &lt;code&gt;B&lt;/code&gt; 模块包含一组用于查询Perl解释的当前状态的实用功能; 通常，这些函数从B :: SV和B :: OP类或其派生类返回对象。这些类依次定义用于查询结果对象有关其内部状态的方法。</target>
        </trans-unit>
        <trans-unit id="40f9413962f128106cd0802b4a2c73013cd7ed0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module exports a variety of functions: some are simple utility functions, others provide a Perl program with a way to get an initial &quot;handle&quot; on an internal object.</source>
          <target state="translated">在 &lt;code&gt;B&lt;/code&gt; 模块出口的多种功能：有些是简单的实用功能，他人提供Perl程序用一种方式来获得一个内部对象上最初的&amp;ldquo;手柄&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5c92116836eedf111e1da108ac269b10e9e38e79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module supplies classes which allow a Perl program to delve into its own innards. It is the module used to implement the &quot;backends&quot; of the Perl compiler. Usage of the compiler does not require knowledge of this module: see the</source>
          <target state="translated">所述 &lt;code&gt;B&lt;/code&gt; 模块提供的类，其允许一个Perl程序钻研它自己的内脏。它是用于实现Perl编译器的&amp;ldquo;后端&amp;rdquo;的模块。使用编译器不需要了解此模块：请参阅</target>
        </trans-unit>
        <trans-unit id="36e744ee541a84c63162e7b4ffbdc783bc6d5f1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; subroutines are not so much subroutines as named special code blocks, of which you can have more than one in a package, and which you can &lt;b&gt;not&lt;/b&gt; call explicitly. See &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;BEGIN, UNITCHECK, CHECK, INIT and END in perlmod&lt;/a&gt;</source>
          <target state="translated">该 &lt;code&gt;BEGIN&lt;/code&gt; ， &lt;code&gt;UNITCHECK&lt;/code&gt; ， &lt;code&gt;CHECK&lt;/code&gt; ， &lt;code&gt;INIT&lt;/code&gt; 和 &lt;code&gt;END&lt;/code&gt; 子程序是没有这么多的子程序为名为特殊代码块，其中可以有一个以上的包，你可以&lt;b&gt;不&lt;/b&gt;显式调用。请参见&lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;perlmod中的BEGIN，UNITCHECK，CHECK，INIT和END&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38a9cf1f5e3f21b86fcbb8df98f12cbc38b145e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to happen at compile time. The &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method any way it likes, though most modules just choose to derive their &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;code&gt;Exporter&lt;/code&gt; module. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method can be found then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="translated">该 &lt;code&gt;BEGIN&lt;/code&gt; 部队 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 在编译时发生。该 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 确保模块被加载到内存中若没有得到它。该 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 是不是一个内置的;这只是对 &lt;code&gt;Module&lt;/code&gt; 包的普通静态方法调用，告诉模块将功能列表重新导入到当前包中。尽管大多数模块只是选择通过继承自 &lt;code&gt;Exporter&lt;/code&gt; 模块中定义的 &lt;code&gt;Exporter&lt;/code&gt; 类的继承来派生其 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法，但是该模块可以按自己喜欢的任何方式实现其 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法。见&lt;a href=&quot;exporter&quot;&gt;出口商&lt;/a&gt;。如果不 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 即使存在AUTOLOAD方法，也可以找到 import方法，然后跳过该调用。</target>
        </trans-unit>
        <trans-unit id="a9fa3a73043129ebc13296822d30d370f57d9e72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to happen at compile time. The &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method any way it likes, though most modules just choose to derive their &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;code&gt;Exporter&lt;/code&gt; module. See &lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method can be found then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="translated">该 &lt;code&gt;BEGIN&lt;/code&gt; 部队 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 在编译时发生。该 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 确保模块被加载到内存中若没有得到它。该 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 是不是一个内置的;这只是对 &lt;code&gt;Module&lt;/code&gt; 包的普通静态方法调用，告诉模块将功能列表重新导入到当前包中。尽管大多数模块只是选择通过继承自 &lt;code&gt;Exporter&lt;/code&gt; 模块中定义的 &lt;code&gt;Exporter&lt;/code&gt; 类的继承来派生其 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法，但是该模块可以按自己喜欢的任何方式实现其 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法。见&lt;a href=&quot;../exporter&quot;&gt;出口商&lt;/a&gt;。如果不 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 即使存在AUTOLOAD方法，也可以找到 import方法，然后跳过该调用。</target>
        </trans-unit>
        <trans-unit id="9201471b5261b8b4c37aca6c270b666c4082753d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; will assure that the loading of</source>
          <target state="translated">该 &lt;code&gt;BEGIN&lt;/code&gt; 将确保的负载</target>
        </trans-unit>
        <trans-unit id="08a5cc1adfa77075f0adc752b299d298837ebeee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;INIT&lt;/code&gt; blocks in code compiled by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, string &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, or string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; will not be executed if they occur after the end of the main compilation phase; that can be a problem in mod_perl and other persistent environments which use those functions to load code at runtime.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ，string &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 或string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 编译的代码中的 &lt;code&gt;CHECK&lt;/code&gt; 和 &lt;code&gt;INIT&lt;/code&gt; 块在主编译阶段结束之后发生，则将不执行它们；在mod_perl和其他使用这些函数在运行时加载代码的持久性环境中，这可能是个问题。</target>
        </trans-unit>
        <trans-unit id="9d8f4372f9a2ba513ea1d0d1264224c42f7ba97c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CNS11643&lt;/code&gt; encoding files are not complete. For common &lt;code&gt;CNS11643&lt;/code&gt; manipulation, please use &lt;code&gt;EUC-TW&lt;/code&gt; in &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode::HanExtra&lt;/a&gt;, which contains planes 1-7.</source>
          <target state="translated">该 &lt;code&gt;CNS11643&lt;/code&gt; 编码的文件是不完整的。对于普通 &lt;code&gt;CNS11643&lt;/code&gt; 操作，请使用 &lt;code&gt;EUC-TW&lt;/code&gt; 在&lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;编码:: HanExtra&lt;/a&gt;，其中包含飞机1-7。</target>
        </trans-unit>
        <trans-unit id="82651f5375f4780d1c104db566c2ac41e7d83b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CORE&lt;/code&gt; namespace gives access to the original built-in functions of Perl. The &lt;code&gt;CORE&lt;/code&gt; package is built into Perl, and therefore you do not need to use or require a hypothetical &quot;CORE&quot; module prior to accessing routines in this namespace.</source>
          <target state="translated">使用 &lt;code&gt;CORE&lt;/code&gt; 命名空间可以访问Perl的原始内置函数。该 &lt;code&gt;CORE&lt;/code&gt; 包被内置到Perl的，因此，你不需要使用或先于这个命名空间访问例程需要一个假想的&amp;ldquo;核心&amp;rdquo;模块。</target>
        </trans-unit>
        <trans-unit id="8ae42d583657def46159ee7ad1318ba4bd6a3fc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Compress::Zlib&lt;/code&gt; module can be split into two general areas of functionality, namely a simple read/write interface to</source>
          <target state="translated">该 &lt;code&gt;Compress::Zlib&lt;/code&gt; 模块可以拆分成两个功能一般区域，即一个简单的读/写接口</target>
        </trans-unit>
        <trans-unit id="b6db4ade377c3bdb345b712f7106420996bb7261" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DB::OUT&lt;/code&gt; filehandle is opened to</source>
          <target state="translated">该 &lt;code&gt;DB::OUT&lt;/code&gt; 文件句柄被打开</target>
        </trans-unit>
        <trans-unit id="b7ced3778c80b0e6ddceec7627220df1317342e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DEBUG&lt;/code&gt; constant wipes the floor with even the &lt;code&gt;$debug&lt;/code&gt; variable, clocking in at minus zero seconds, and generates a &quot;warning: too few iterations for a reliable count&quot; message into the bargain. To see what is really going on, and why we had too few iterations when we thought we asked for 100000, we can use the very useful &lt;code&gt;B::Deparse&lt;/code&gt; to inspect the new code:</source>
          <target state="translated">在 &lt;code&gt;DEBUG&lt;/code&gt; 常数抹地板甚至 &lt;code&gt;$debug&lt;/code&gt; 变量，在零下零秒计时，并生成一个&amp;ldquo;警告：一个可靠的计数过几次迭代&amp;rdquo;的消息的呢。要查看实际情况，以及为什么当我们认为要求100000时为什么迭代次数太少，我们可以使用非常有用的 &lt;code&gt;B::Deparse&lt;/code&gt; 来检查新代码：</target>
        </trans-unit>
        <trans-unit id="c9d4dcbece0076153dceb385297ea42930b3d2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DOES&lt;/code&gt; method returns</source>
          <target state="translated">该 &lt;code&gt;DOES&lt;/code&gt; 方法返回</target>
        </trans-unit>
        <trans-unit id="13b108bacf05fadc1d57d69518e2671634247ba4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Deparse&lt;/code&gt; flag makes Dump() run slower, since the XSUB implementation does not support it.</source>
          <target state="translated">该 &lt;code&gt;Deparse&lt;/code&gt; 标志使转储（）运行速度较慢，因为XSUB实现不支持它。</target>
        </trans-unit>
        <trans-unit id="1afec46de9e3c4185e7d2feb3396554e349575f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel::NYTProf&lt;/code&gt; and &lt;code&gt;Devel::FindAmpersand&lt;/code&gt; modules can help you find uses of these problematic match variables in your code.</source>
          <target state="translated">该 &lt;code&gt;Devel::NYTProf&lt;/code&gt; 和 &lt;code&gt;Devel::FindAmpersand&lt;/code&gt; 模块可以帮助你找到这些问题的匹配变量的使用您的代码。</target>
        </trans-unit>
        <trans-unit id="7a6b56d230ad8470a46e41fa3a6181ade20a4909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel::SmallProf&lt;/code&gt; profiler examines the runtime of your Perl program and produces a line-by-line listing to show how many times each line was called, and how long each line took to execute. It is called by supplying the familiar &lt;code&gt;-d&lt;/code&gt; flag to Perl at runtime.</source>
          <target state="translated">该 &lt;code&gt;Devel::SmallProf&lt;/code&gt; 探查检查你的Perl程序的运行时间，并产生一个行由行上市，以显示每行了多少次调用，并在每行花费的时间执行。通过在运行时向Perl 提供熟悉的 &lt;code&gt;-d&lt;/code&gt; 标志来调用它。</target>
        </trans-unit>
        <trans-unit id="e3e899b88f5d9c103f9957a381fb75493e4ca219" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel&lt;/code&gt; namespace has several modules which you can use to profile your Perl programs.</source>
          <target state="translated">该 &lt;code&gt;Devel&lt;/code&gt; 命名空间有几个模块，你可以用它来分析你的Perl程序。</target>
        </trans-unit>
        <trans-unit id="f7b3b4bbb4e3a91049c3f2bf1c1599a52a4bab75" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::&lt;/code&gt; interface is based on the interface originally developed by Neil Winton for his &lt;code&gt;MD5&lt;/code&gt; module.</source>
          <target state="translated">该 &lt;code&gt;Digest::&lt;/code&gt; 接口是基于最初由尼尔&amp;middot;温顿开发了自己的界面上 &lt;code&gt;MD5&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="359f33360a7a83f14790bf4d659bef0945120eaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::&lt;/code&gt; modules calculate digests, also called &quot;fingerprints&quot; or &quot;hashes&quot;, of some data, called a message. The digest is (usually) some small/fixed size string. The actual size of the digest depend of the algorithm used. The message is simply a sequence of arbitrary bytes or bits.</source>
          <target state="translated">该 &lt;code&gt;Digest::&lt;/code&gt; 模块计算一些数据，称为消息摘要的，也被称为&amp;ldquo;指纹&amp;rdquo;或&amp;ldquo;散列&amp;rdquo;。摘要是（通常）一些小/固定大小的字符串。摘要的实际大小取决于所使用的算法。该消息只是任意字节或位的序列。</target>
        </trans-unit>
        <trans-unit id="5112b49f2609b19e911cd2f6a34cb7ffa7088cff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module allows you to use the RSA Data Security Inc. MD5 Message Digest algorithm from within Perl programs. The algorithm takes as input a message of arbitrary length and produces as output a 128-bit &quot;fingerprint&quot; or &quot;message digest&quot; of the input.</source>
          <target state="translated">本 &lt;code&gt;Digest::MD5&lt;/code&gt; 模块允许您从Perl程序中使用的RSA数据安全公司的MD5消息摘要算法。该算法将任意长度的消息作为输入，并产生输出的128位输入&amp;ldquo;指纹&amp;rdquo;或&amp;ldquo;消息摘要&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2adafeb0e9eb580775e9922353cdda9ed2fef18a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module is written by Gisle Aas &amp;lt;gisle@ActiveState.com&amp;gt;.</source>
          <target state="translated">该 &lt;code&gt;Digest::MD5&lt;/code&gt; 模块由伊斯勒阿斯&amp;lt;gisle@ActiveState.com&amp;gt;写入。</target>
        </trans-unit>
        <trans-unit id="048cfda097524929fcf424f6794f7c010276767b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module provide a procedural interface for simple use, as well as an object oriented interface that can handle messages of arbitrary length and which can read files directly.</source>
          <target state="translated">该 &lt;code&gt;Digest::MD5&lt;/code&gt; 模块提供简单的使用一个程序接口，以及面向对象的接口，可以处理任意长度和可直接读取的文件的消息。</target>
        </trans-unit>
        <trans-unit id="417545c4adfbc434083e36d20bccbfb0f99aa98e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::base&lt;/code&gt; class provide implementations of the methods &lt;code&gt;addfile&lt;/code&gt; and &lt;code&gt;add_bits&lt;/code&gt; in terms of &lt;code&gt;add&lt;/code&gt; , and of the methods &lt;code&gt;hexdigest&lt;/code&gt; and &lt;code&gt;b64digest&lt;/code&gt; in terms of &lt;code&gt;digest&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;Digest::base&lt;/code&gt; 类提供的方法的实现 &lt;code&gt;addfile&lt;/code&gt; 和 &lt;code&gt;add_bits&lt;/code&gt; 来讲 &lt;code&gt;add&lt;/code&gt; ，并且所述方法 &lt;code&gt;hexdigest&lt;/code&gt; 和 &lt;code&gt;b64digest&lt;/code&gt; 来讲 &lt;code&gt;digest&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="628d5f24b15638f2c6ff193717192cc425ae4155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DirHandle&lt;/code&gt; method provide an alternative interface to the opendir(), closedir(), readdir(), and rewinddir() functions.</source>
          <target state="translated">该 &lt;code&gt;DirHandle&lt;/code&gt; 方法提供一种替代接口向执行opendir（），closedir（），readdir的（）和rewinddir（）函数。</target>
        </trans-unit>
        <trans-unit id="358ca39e53232388840862f052183678f86697cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function takes one or two arguments: something to dump, and an optional limit for recursion and array elements (default is 4). The first argument is evaluted in rvalue scalar context, with exceptions for @array and %hash, which dump the array or hash itself. So &lt;code&gt;Dump @array&lt;/code&gt; works, as does &lt;code&gt;Dump $foo&lt;/code&gt; . And &lt;code&gt;Dump &lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; will call &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; in rvalue context, whereas &lt;code&gt;Dump ${\&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;}&lt;/code&gt; will call it in lvalue context.</source>
          <target state="translated">该 &lt;code&gt;Dump()&lt;/code&gt; 函数采用一个或两个参数：东西倾倒，并递归和数组元素一个可选的限制（默认为4）。第一个参数在右值标量上下文中求值，@ array和％hash例外，它们会转储数组或哈希本身。所以 &lt;code&gt;Dump @array&lt;/code&gt; 可以工作， &lt;code&gt;Dump $foo&lt;/code&gt; 。和 &lt;code&gt;Dump &lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 将调用 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 在右值范围内，而 &lt;code&gt;Dump ${\&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;}&lt;/code&gt; 将其称之为在左值范围内。</target>
        </trans-unit>
        <trans-unit id="cdbf79b7555598c068ba8d9743bee2fb95392923" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function, by default, dumps up to 4 elements from a toplevel array or hash. This number can be increased by supplying a second argument to the function.</source>
          <target state="translated">该 &lt;code&gt;Dump()&lt;/code&gt; 函数，默认情况下，转储到从顶层数组或哈希4个元素。可以通过向函数提供第二个参数来增加此数字。</target>
        </trans-unit>
        <trans-unit id="c95778d99c76e8e03e061209f2b6b5768436be5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;END&lt;/code&gt; block isn't called when untrapped signals kill the program, though, so if you use &lt;code&gt;END&lt;/code&gt; blocks you should also use</source>
          <target state="translated">在 &lt;code&gt;END&lt;/code&gt; 时未捕获的信号杀死程序，但块不叫，所以如果你使用 &lt;code&gt;END&lt;/code&gt; 块，你也应该使用</target>
        </trans-unit>
        <trans-unit id="f434d74067f98a36c01cbe9c20f7d7cf7b02ed54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXPR&lt;/code&gt; following the modifier is referred to as the &quot;condition&quot;. Its truth or falsehood determines how the modifier will behave.</source>
          <target state="translated">所述 &lt;code&gt;EXPR&lt;/code&gt; 改性剂以下被称为&amp;ldquo;条件&amp;rdquo;。它的真假决定了修饰符的行为。</target>
        </trans-unit>
        <trans-unit id="0be035a23dc6f5f75a5bb7fdc10fe00056028240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encode&lt;/code&gt; module knows about many encodings and has interfaces for doing conversions between those encodings:</source>
          <target state="translated">该 &lt;code&gt;Encode&lt;/code&gt; 模块知道许多编码和具有做这些编码之间的转换接口：</target>
        </trans-unit>
        <trans-unit id="5cdf933f51543c5ce4713919bd68bbd3f797378f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encode&lt;/code&gt; module provides the interface between Perl strings and the rest of the system. Perl strings are sequences of</source>
          <target state="translated">的 &lt;code&gt;Encode&lt;/code&gt; 模块提供的Perl字符串和系统的其余部分之间的接口。Perl字符串是</target>
        </trans-unit>
        <trans-unit id="4968644a1dddd78111692e0824f91d81d4b5fde6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Env::import()&lt;/code&gt; function ties environment variables with suitable names to global Perl variables with the same names. By default it ties all existing environment variables (&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %ENV&lt;/code&gt; ) to scalars. If the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function receives arguments, it takes them to be a list of variables to tie; it's okay if they don't yet exist. The scalar type prefix '$' is inferred for any element of this list not prefixed by '$' or '@'. Arrays are implemented in terms of &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;, using &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; as the delimiter.</source>
          <target state="translated">该 &lt;code&gt;Env::import()&lt;/code&gt; 函数关系的环境变量与适当的名称具有相同名称的全局变量的Perl。默认情况下，它将所有现有环境变量（ &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %ENV&lt;/code&gt; ）绑定到标量。如果 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 函数接收到参数，则将其视为要绑定的变量列表；如果还不存在也可以。对于此列表中没有以&amp;ldquo; $&amp;rdquo;或&amp;ldquo; @&amp;rdquo;为前缀的任何元素，将推导出标量类型前缀&amp;ldquo; $&amp;rdquo;。数组是使用 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 来实现的，使用 &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; 作为分隔符。</target>
        </trans-unit>
        <trans-unit id="04fe8159aef76b700007013f5b9be387367b2a84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraFieldLocal&lt;/code&gt; option is used to store additional metadata in the local header for the zip file/buffer. The &lt;code&gt;ExtraFieldCentral&lt;/code&gt; does the same for the matching central header.</source>
          <target state="translated">该 &lt;code&gt;ExtraFieldLocal&lt;/code&gt; 选项用于存储额外的元数据中的压缩文件/缓冲本地报头。该 &lt;code&gt;ExtraFieldCentral&lt;/code&gt; 做为匹配中央头是相同的。</target>
        </trans-unit>
        <trans-unit id="7dceaf4fc99f40b45472fc6396adb3cf093b19ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FREETMPS&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt; pair will get rid of any values returned by the Perl subroutine (see next example), plus it will also dump the mortal SVs we have created. Having &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;SAVETMPS&lt;/code&gt; at the beginning of the code makes sure that no other mortals are destroyed.</source>
          <target state="translated">该 &lt;code&gt;FREETMPS&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 对将摆脱由Perl子（见下面的例子）返回的任何值，再加上它也将倾，我们已经创建了凡人的SV。在代码的开头 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;SAVETMPS&lt;/code&gt; 可确保没有其他凡人被破坏。</target>
        </trans-unit>
        <trans-unit id="e1e824605b84cee8c0b954423f3ab5ef2eb2758b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN&lt;/code&gt; /&lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; keywords can be mixed with ANSI-style declarations, as in</source>
          <target state="translated">在 &lt;code&gt;IN&lt;/code&gt; / &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; 的关键字可以用ANSI风格声明混合，如</target>
        </trans-unit>
        <trans-unit id="2291d3950c0f7a1274711a429d0d47b0e9604c3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; sections have identical formats, that is, each unindented line starts a new in- or output map respectively. A new in- or output map must start with the name of the XS type to map on a line by itself, followed by the code that implements it indented on the following lines. Example:</source>
          <target state="translated">的 &lt;code&gt;INPUT&lt;/code&gt; 和 &lt;code&gt;OUTPUT&lt;/code&gt; 部分具有相同的格式，即，没有锯齿的各线分别开始一个新的输入或输出图。新的输入或输出映射必须以XS类型的名称开头，才能单独在一行上进行映射，然后在下一行上以缩进形式实现该映射的代码。例：</target>
        </trans-unit>
        <trans-unit id="0839ebfa51c8f90f143d226a6a7f33a7ff311878" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INT2PTR&lt;/code&gt; macro (defined in perl.h) casts an integer to a pointer of a given type, taking care of the possible different size of integers and pointers. There are also &lt;code&gt;PTR2IV&lt;/code&gt; , &lt;code&gt;PTR2UV&lt;/code&gt; , &lt;code&gt;PTR2NV&lt;/code&gt; macros, to map the other way, which may be useful in OUTPUT sections.</source>
          <target state="translated">所述 &lt;code&gt;INT2PTR&lt;/code&gt; 宏（在perl.h定义）投射的整数到一个给定类型的指针，以可能的不同大小整数和指针的照顾。还有 &lt;code&gt;PTR2IV&lt;/code&gt; ， &lt;code&gt;PTR2UV&lt;/code&gt; 和 &lt;code&gt;PTR2NV&lt;/code&gt; 宏，以另一种方式映射，这在OUTPUT部分中可能有用。</target>
        </trans-unit>
        <trans-unit id="61f85903ef5f9040c0ff99931c044e8d15426a65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN_OUT&lt;/code&gt; parameters are identical with parameters introduced with &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt; and put into the &lt;code&gt;OUTPUT:&lt;/code&gt; section (see &lt;a href=&quot;#The-OUTPUT%3a-Keyword&quot;&gt;The OUTPUT: Keyword&lt;/a&gt;). The &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters are very similar, the only difference being that the value C function writes through the pointer would not modify the Perl parameter, but is put in the output list.</source>
          <target state="translated">的 &lt;code&gt;IN_OUT&lt;/code&gt; 参数是与引入参数相同&lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;的＆元运算符&lt;/a&gt;并投入 &lt;code&gt;OUTPUT:&lt;/code&gt; 部分（请参见&lt;a href=&quot;#The-OUTPUT%3a-Keyword&quot;&gt;输出：关键字&lt;/a&gt;）。该 &lt;code&gt;IN_OUTLIST&lt;/code&gt; 参数非常相似，唯一的区别是，C值函数通过指针写入不会修改Perl的参数，而是被放在输出列表。</target>
        </trans-unit>
        <trans-unit id="e01d4a34408ea1bec61899bb0715159c8fcfc543" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Dir&lt;/code&gt; package provides two interfaces to perl's directory reading routines.</source>
          <target state="translated">该 &lt;code&gt;IO::Dir&lt;/code&gt; 包提供了两个接口，Perl的目录阅读程序。</target>
        </trans-unit>
        <trans-unit id="2e8c3db24464dee992cbd4fb5389ee4e7af6c03b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Select&lt;/code&gt; package implements an object approach to the system &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function call. It allows the user to see what IO handles, see &lt;a href=&quot;handle&quot;&gt;IO::Handle&lt;/a&gt;, are ready for reading, writing or have an exception pending.</source>
          <target state="translated">该 &lt;code&gt;IO::Select&lt;/code&gt; 包实现的一个对象的方法对系统 &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 函数调用。它允许用户查看IO处理的内容，请参见&lt;a href=&quot;handle&quot;&gt;IO :: Handle&lt;/a&gt;，准备进行读取，写入或等待异常处理。</target>
        </trans-unit>
        <trans-unit id="93e9868cf44653a0a473010fe2cd91001e0a676d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Interpolation&lt;/code&gt; module can also do a lot of magic for you. You can specify a variable name, in this case &lt;code&gt;E&lt;/code&gt; , to set up a tied hash that does the interpolation for you. It has several other methods to do this as well.</source>
          <target state="translated">该 &lt;code&gt;Interpolation&lt;/code&gt; 模块还可以做很多的魔法给你。您可以指定一个变量名，在这种情况下为 &lt;code&gt;E&lt;/code&gt; ，以设置一个绑定的哈希为您进行插值。它也有其他几种方法可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="d3bc590cafc9b13c0e888463643b3750cf44fd73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_CTYPE&lt;/code&gt; locale also provides the map used in transliterating characters between lower and uppercase. This affects the case-mapping functions--&lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt;; case-mapping interpolation with &lt;code&gt;\F&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , or &lt;code&gt;\U&lt;/code&gt; in double-quoted strings and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; substitutions; and case-independent regular expression pattern matching using the &lt;code&gt;i&lt;/code&gt; modifier.</source>
          <target state="translated">的 &lt;code&gt;LC_CTYPE&lt;/code&gt; 语言环境还提供了在较低和大写之间音译字符使用的地图。这影响的情况下映射functions-- &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt; ; 在双引号字符串和 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 替换中用 &lt;code&gt;\F&lt;/code&gt; ， &lt;code&gt;\l&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; 或 &lt;code&gt;\U&lt;/code&gt; 进行大小写映射插值；以及使用 &lt;code&gt;i&lt;/code&gt; 修饰符的大小写无关的正则表达式模式匹配。</target>
        </trans-unit>
        <trans-unit id="941219cd505be61ac26ba8728d69370c60e37046" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_NUMERIC&lt;/code&gt; controls the numeric output:</source>
          <target state="translated">所述 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 控制数字输出：</target>
        </trans-unit>
        <trans-unit id="412121500ef04a2233556ed3ed8bb5c784494003" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option changes the behavior of the &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; method so that the amount of memory used by the output buffer can be limited.</source>
          <target state="translated">所述 &lt;code&gt;LimitOutput&lt;/code&gt; 选项改变的行为 &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; 方法使得存储由输出缓冲器的使用量可以被限制。</target>
        </trans-unit>
        <trans-unit id="1b18a1d213993f63112fefb5d5804b6552cbf33b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option changes the behavior of the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method so that the amount of memory used by the output buffer can be limited.</source>
          <target state="translated">所述 &lt;code&gt;LimitOutput&lt;/code&gt; 选项改变的行为 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 方法使得存储由输出缓冲器的使用量可以被限制。</target>
        </trans-unit>
        <trans-unit id="3600b0d3775b442853dade84e908851ee6d60512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option is designed to help with this use-case.</source>
          <target state="translated">该 &lt;code&gt;LimitOutput&lt;/code&gt; 选项被设计为与该用例的帮助。</target>
        </trans-unit>
        <trans-unit id="4e39cafde8d7c8f339d79044ffb14c41f2b59abf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Listen&lt;/code&gt; parameter is set to the maximum number of pending connections we can accept until we turn away incoming clients. Think of it as a call-waiting queue for your telephone. The low-level Socket module has a special symbol for the system maximum, which is SOMAXCONN.</source>
          <target state="translated">该 &lt;code&gt;Listen&lt;/code&gt; 参数设置为未决的连接，我们可以接受，直到我们转身离开传入客户端的最大数量。将其视为电话的呼叫等待队列。对于系统最大值，低级Socket模块具有特殊符号，即SOMAXCONN。</target>
        </trans-unit>
        <trans-unit id="39d8f8a92949aebb617dd074e69f347a559dd1fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Country&lt;/code&gt; module provides access to several code sets that can be used for identifying countries, such as those defined in ISO 3166-1.</source>
          <target state="translated">的 &lt;code&gt;Locale::Country&lt;/code&gt; 模块提供的是可用于标识国家的若干代码集，例如在ISO 3166-1定义的访问。</target>
        </trans-unit>
        <trans-unit id="7ce570b70dc3b1217c7829eb357747faae317306" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Currency&lt;/code&gt; module provides access to standard codes used for identifying currencies and funds, such as those defined in ISO 4217.</source>
          <target state="translated">的 &lt;code&gt;Locale::Currency&lt;/code&gt; 模块提供用于识别货币和资金，诸如那些在ISO 4217定义的标准代码。</target>
        </trans-unit>
        <trans-unit id="e1ffcce2675347ee9e15ffb62b7a866fc9499f7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Language&lt;/code&gt; module provides access to standard codes used for identifying languages, such as those as defined in ISO 639.</source>
          <target state="translated">的 &lt;code&gt;Locale::Language&lt;/code&gt; 模块提供用于识别语言，如在ISO 639所定义的那些标准代码。</target>
        </trans-unit>
        <trans-unit id="aa76c519ff8997e91915d966da6aed9450ba1a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Script&lt;/code&gt; module provides access to standards codes used for identifying scripts, such as those defined in ISO 15924.</source>
          <target state="translated">的 &lt;code&gt;Locale::Script&lt;/code&gt; 模块提供用于识别脚本，诸如那些在ISO 15924定义的标准代码。</target>
        </trans-unit>
        <trans-unit id="e8120d017d19784f5ec18621659dfbf762367c0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MGVTBL&lt;/code&gt; has five (or sometimes eight) pointers to the following routine types:</source>
          <target state="translated">该 &lt;code&gt;MGVTBL&lt;/code&gt; 有五个（或有时为八个）指针以下的常规类型：</target>
        </trans-unit>
        <trans-unit id="62960d717ea2191ee6cb352f5b362492a57f4b7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Math::Trig&lt;/code&gt; handles this by using the &lt;code&gt;Math::Complex&lt;/code&gt; package which knows how to handle complex numbers, please see &lt;a href=&quot;complex&quot;&gt;Math::Complex&lt;/a&gt; for more information. In practice you need not to worry about getting complex numbers as results because the &lt;code&gt;Math::Complex&lt;/code&gt; takes care of details like for example how to display complex numbers. For example:</source>
          <target state="translated">该 &lt;code&gt;Math::Trig&lt;/code&gt; 通过处理这 &lt;code&gt;Math::Complex&lt;/code&gt; 包，它知道如何处理复杂的数字，请参阅&lt;a href=&quot;complex&quot;&gt;数学::情结&lt;/a&gt;了解更多信息。在实践中，您不必担心将复数作为结果，因为 &lt;code&gt;Math::Complex&lt;/code&gt; 会处理诸如如何显示复数之类的细节。例如：</target>
        </trans-unit>
        <trans-unit id="59d3e5116a50776a62b5e7307aca3591f0689480" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Moose&lt;/code&gt; authors hope that one day &lt;code&gt;Moo&lt;/code&gt; can be made obsolete by improving &lt;code&gt;Moose&lt;/code&gt; enough, but for now it provides a worthwhile alternative to &lt;code&gt;Moose&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;Moose&lt;/code&gt; 笔者希望有一天， &lt;code&gt;Moo&lt;/code&gt; 可以通过改进制造过时 &lt;code&gt;Moose&lt;/code&gt; 就够了，但现在它提供了一个有价值的替代 &lt;code&gt;Moose&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cda22c66d7ae69cf0c1a687755ef0ea97e644b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NNTP&lt;/code&gt; protocol uses the &lt;code&gt;WILDMAT&lt;/code&gt; format for patterns. The WILDMAT format was first developed by Rich Salz based on the format used in the UNIX &quot;find&quot; command to articulate file names. It was developed to provide a uniform mechanism for matching patterns in the same manner that the UNIX shell matches filenames.</source>
          <target state="translated">的 &lt;code&gt;NNTP&lt;/code&gt; 协议使用 &lt;code&gt;WILDMAT&lt;/code&gt; 的模式格式。 WILDMAT格式由Rich Salz首先根据UNIX&amp;ldquo;查找&amp;rdquo;命令中用于表达文件名的格式开发。它的开发旨在提供一种统一的机制，以与UNIX Shell匹配文件名的方式匹配模式。</target>
        </trans-unit>
        <trans-unit id="812543816e7e36906e0a41744e1b881bd6061a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;O::import&lt;/code&gt; function loads the appropriate &lt;code&gt;B::Backend&lt;/code&gt; module and calls its &lt;code&gt;compile&lt;/code&gt; function, passing it OPTIONS. That function is expected to return a sub reference which we'll call CALLBACK. Next, the &quot;compile-only&quot; flag is switched on (equivalent to the command-line option &lt;code&gt;-c&lt;/code&gt; ) and a CHECK block is registered which calls CALLBACK. Thus the main Perl program mentioned on the command-line is read in, parsed and compiled into internal syntax tree form. Since the &lt;code&gt;-c&lt;/code&gt; flag is set, the program does not start running (excepting BEGIN blocks of course) but the CALLBACK function registered by the compiler backend is called.</source>
          <target state="translated">该 &lt;code&gt;O::import&lt;/code&gt; 功能加载相应的 &lt;code&gt;B::Backend&lt;/code&gt; 模块，并调用它的 &lt;code&gt;compile&lt;/code&gt; 功能，通过它选项。该函数将返回一个子引用，我们将其称为CALLBACK。接下来，打开&amp;ldquo;仅编译&amp;rdquo;标志（等效于命令行选项 &lt;code&gt;-c&lt;/code&gt; ），并注册一个CHECK块，该块调用CALLBACK。因此，在命令行中提到的主要Perl程序将被读入，解析并编译为内部语法树形式。由于设置了 &lt;code&gt;-c&lt;/code&gt; 标志，因此程序不会开始运行（当然，BEGIN块除外），但是会调用编译器后端注册的CALLBACK函数。</target>
        </trans-unit>
        <trans-unit id="3d373b71890ff94863d227c7cfce5d1d697b7746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OP *&lt;/code&gt; is op_free()ed at the end of</source>
          <target state="translated">的 &lt;code&gt;OP *&lt;/code&gt; 是op_free（）的在端部</target>
        </trans-unit>
        <trans-unit id="998cf5d3020bb78a9ba1d3cad328d90e354a7767" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; parameter differ from &lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; parameters only by the initial value of the Perl parameter not being read (and not being given to the C function - which gets some garbage instead). For example, the same C function as above can be interfaced with as</source>
          <target state="translated">所述 &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; 参数不同于 &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; 仅由Perl的参数不被读取的初始值的参数（而不是被提供给C函数-它获取一些垃圾代替）。例如，可以将与上述相同的C函数与</target>
        </trans-unit>
        <trans-unit id="0628c399d26c3378a27108a14e1ac2344b8aefb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Open()&lt;/code&gt; method has lots of arguments because it combines the functions of perl's &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;PerlIO_open&lt;/code&gt; , perl's &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;PerlIO_fdopen&lt;/code&gt; and &lt;code&gt;PerlIO_reopen&lt;/code&gt; . The full prototype is as follows:</source>
          <target state="translated">在 &lt;code&gt;Open()&lt;/code&gt; 方法有很多的参数，因为它结合了Perl的功能 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;PerlIO_open&lt;/code&gt; ，Perl的 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;PerlIO_fdopen&lt;/code&gt; 和 &lt;code&gt;PerlIO_reopen&lt;/code&gt; 。完整的原型如下：</target>
        </trans-unit>
        <trans-unit id="9b50db457121e66e0a351ce78b3a957dc8ab0fb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL5DB&lt;/code&gt; environment variable can be used to define a debugger. For example, the minimal &quot;working&quot; debugger (it actually doesn't do anything) consists of one line:</source>
          <target state="translated">所述 &lt;code&gt;PERL5DB&lt;/code&gt; 环境变量可以用于定义调试器。例如，最小的&amp;ldquo;工作&amp;rdquo;调试器（它实际上不执行任何操作）由一行组成：</target>
        </trans-unit>
        <trans-unit id="d2bc99a442d5c0b29501891792cdc1fff80da05a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; and &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic types are defined specifically for use by extensions and will not be used by perl itself. Extensions can use &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic to 'attach' private information to variables (typically objects). This is especially useful because there is no way for normal perl code to corrupt this private information (unlike using extra elements of a hash object).</source>
          <target state="translated">的 &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; 和 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 魔术类型由扩展使用具体限定，并且不会被Perl本身使用。扩展可以使用 &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; 魔术来将私有信息&amp;ldquo;附加&amp;rdquo;到变量（通常是对象）。这是特别有用的，因为普通的perl代码无法破坏此私有信息（与使用哈希对象的其他元素不同）。</target>
        </trans-unit>
        <trans-unit id="8a6e94721b04748465ec2688a94fd6f249730156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; interface for hashes</source>
          <target state="translated">该 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 接口哈希</target>
        </trans-unit>
        <trans-unit id="ebc956792cc9e74cf6710a9899c98dc65f9e9723" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POPi&lt;/code&gt; macro is used here to pop the return value from the stack. In this case we wanted an integer, so &lt;code&gt;POPi&lt;/code&gt; was used.</source>
          <target state="translated">该 &lt;code&gt;POPi&lt;/code&gt; 宏这里使用流行从堆栈的返回值。在这种情况下，我们需要一个整数，因此使用了 &lt;code&gt;POPi&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="441004a0b6f6f50d94cdd26e8efdb4418e11d7d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::getattr&lt;/code&gt; function can do this more portably on systems purporting POSIX compliance. See also the &lt;code&gt;Term::ReadKey&lt;/code&gt; module from your nearest &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org&quot;&gt;CPAN&lt;/a&gt; site.</source>
          <target state="translated">该 &lt;code&gt;POSIX::getattr&lt;/code&gt; 功能，可以对声称符合POSIX系统更可移植做到这一点。另请参见离您最近的&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org&quot;&gt;CPAN&lt;/a&gt;站点的 &lt;code&gt;Term::ReadKey&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="30a4c7c0312ad4ebafbfc4ecde82010a30e5b1d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::localeconv()&lt;/code&gt; function allows you to get particulars of the locale-dependent numeric formatting information specified by the current underlying &lt;code&gt;LC_NUMERIC&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; locales (regardless of whether called from within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; or not). (If you just want the name of the current locale for a particular category, use &lt;code&gt;POSIX::setlocale()&lt;/code&gt; with a single parameter--see &lt;a href=&quot;#The-setlocale-function&quot;&gt;The setlocale function&lt;/a&gt;.)</source>
          <target state="translated">该 &lt;code&gt;POSIX::localeconv()&lt;/code&gt; 函数可以让你获得的当前底层指定的区域设置相关的数字格式信息细节 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 和 &lt;code&gt;LC_MONETARY&lt;/code&gt; 语言环境（无论从范围内调用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 或没有）。（如果只需要特定类别的当前语言环境的名称，请使用带有单个参数的 &lt;code&gt;POSIX::setlocale()&lt;/code&gt; －请参阅&lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale函数&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="1f685f77eea7b515d4045c7a67182dbbc7755a25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUSHMARK&lt;/code&gt; macro tells Perl to make a mental note of the current stack pointer. Even if you aren't passing any parameters (like the example shown in the section</source>
          <target state="translated">该 &lt;code&gt;PUSHMARK&lt;/code&gt; 宏告诉Perl做一个心里记下当前堆栈指针的。即使您没有传递任何参数（例如本节中显示的示例）</target>
        </trans-unit>
        <trans-unit id="07465ad7c738ebeee81550400552ecd67a850bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUTBACK&lt;/code&gt; macro sets the global copy of the stack pointer to be the same as our local copy. If we didn't do this,</source>
          <target state="translated">该 &lt;code&gt;PUTBACK&lt;/code&gt; 堆栈指针的宏设置全局副本是一样的我们的本地副本。如果我们不这样做，</target>
        </trans-unit>
        <trans-unit id="8baae86fdb4cb4e701226e31c2071774be7ff5cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PeerAddr&lt;/code&gt; can be a hostname or the IP-address on the &quot;xx.xx.xx.xx&quot; form. The &lt;code&gt;PeerPort&lt;/code&gt; can be a number or a symbolic service name. The service name might be followed by a number in parenthesis which is used if the service is not known by the system. The &lt;code&gt;PeerPort&lt;/code&gt; specification can also be embedded in the &lt;code&gt;PeerAddr&lt;/code&gt; by preceding it with a &quot;:&quot;.</source>
          <target state="translated">该 &lt;code&gt;PeerAddr&lt;/code&gt; 可以是&amp;ldquo;XX.XX.XX.XX&amp;rdquo;表单上的主机名或IP地址。该 &lt;code&gt;PeerPort&lt;/code&gt; 可以是一个数字或符号服务名称。服务名称后可能带有括号中的数字，如果系统不知道该服务，则使用该数字。所述 &lt;code&gt;PeerPort&lt;/code&gt; 规范也可以嵌入在 &lt;code&gt;PeerAddr&lt;/code&gt; &amp;ldquo;：&amp;rdquo;通过用它前面。</target>
        </trans-unit>
        <trans-unit id="354584d7434f3b3042f7e803f86eee0735ecb30f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PerlInterpreter*&lt;/code&gt; is being constructed via &lt;code&gt;perl_construct&lt;/code&gt; . This value is mostly there for completeness and for use via the underlying C variable &lt;code&gt;PL_phase&lt;/code&gt; . It's not really possible for Perl code to be executed unless construction of the interpreter is finished.</source>
          <target state="translated">所述 &lt;code&gt;PerlInterpreter*&lt;/code&gt; 正在通过构造 &lt;code&gt;perl_construct&lt;/code&gt; 。此值主要用于完整性和通过基础C变量 &lt;code&gt;PL_phase&lt;/code&gt; 使用。除非解释器的构建完成，否则实际上不可能执行Perl代码。</target>
        </trans-unit>
        <trans-unit id="619b9e421badf230488baf0eee0a8b4f64f3d92d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REGlob&lt;/code&gt; example above does not implement all the support needed to cleanly override perl's &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator. The built-in &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; has different behaviors depending on whether it appears in a scalar or list context, but our &lt;code&gt;REGlob&lt;/code&gt; doesn't. Indeed, many perl built-in have such context sensitive behaviors, and these must be adequately supported by a properly written override. For a fully functional example of overriding &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, study the implementation of &lt;code&gt;File::DosGlob&lt;/code&gt; in the standard library.</source>
          <target state="translated">上面的 &lt;code&gt;REGlob&lt;/code&gt; 示例未实现完全重写perl的 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 运算符所需的所有支持。内置 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 具有不同的行为，具体取决于它出现在标量还是列表上下文中，但我们的 &lt;code&gt;REGlob&lt;/code&gt; 却没有。实际上，许多内置的perl都具有此类上下文相关的行为，并且必须由适当编写的重写来充分支持这些行为。有关覆盖 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 的完整功能示例，请研究标准库中 &lt;code&gt;File::DosGlob&lt;/code&gt; 的实现。</target>
        </trans-unit>
        <trans-unit id="541482224c51c4cb7a6cd08e437f820560b203ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Return&lt;/code&gt; and &lt;code&gt;Envelope&lt;/code&gt; parameters are used for DSN (Delivery Status Notification).</source>
          <target state="translated">在 &lt;code&gt;Return&lt;/code&gt; 和 &lt;code&gt;Envelope&lt;/code&gt; 参数用于DSN（传递状态通知）。</target>
        </trans-unit>
        <trans-unit id="0fb74752f70cdbcc4b24e6fe1a79d1c71cc57bd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reuse&lt;/code&gt; parameter is needed so that we restart our server manually without waiting a few minutes to allow system buffers to clear out.</source>
          <target state="translated">该 &lt;code&gt;Reuse&lt;/code&gt; 需要参数，以便我们手动重新启动我们的服务器，而无需等待几分钟，让系统缓冲区就一目了然了。</target>
        </trans-unit>
        <trans-unit id="6ef497f2f64147d9fc11b64ad7836f6a54270b55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIGALRM&lt;/code&gt; signal is sent after the specified number of seconds. Implemented using &lt;code&gt;setitimer()&lt;/code&gt; if available, &lt;code&gt;ualarm()&lt;/code&gt; if not. The &lt;code&gt;$interval_floating_seconds&lt;/code&gt; argument is optional and will be zero if unspecified, resulting in &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt;-like behaviour. This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; below.</source>
          <target state="translated">所述 &lt;code&gt;SIGALRM&lt;/code&gt; 信号的指定的秒数之后被发送。如果有的话，使用 &lt;code&gt;setitimer()&lt;/code&gt; 实现；如果没有，则使用 &lt;code&gt;ualarm()&lt;/code&gt; 实现。 &lt;code&gt;$interval_floating_seconds&lt;/code&gt; 参数是可选的，如果未指定，则为零，从而导致类似 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 的行为。可以导入此功能，从而可以很好地替代perl随附的 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; ，请参见下面的&lt;a href=&quot;#EXAMPLES&quot;&gt;示例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bcb26b9a2abefa95e1228823d5039552d2541e20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER::&lt;/code&gt; bit tells Perl to look for the &lt;code&gt;print_info()&lt;/code&gt; in the &lt;code&gt;File::MP3&lt;/code&gt; class's inheritance chain. When it finds the parent class that implements this method, the method is called.</source>
          <target state="translated">该 &lt;code&gt;SUPER::&lt;/code&gt; 位告诉Perl来寻找 &lt;code&gt;print_info()&lt;/code&gt; 在 &lt;code&gt;File::MP3&lt;/code&gt; 类的继承链。当找到实现此方法的父类时，将调用该方法。</target>
        </trans-unit>
        <trans-unit id="3f5b4cff6fbfe1c281604ef06c021cd92e1eaa6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; modifier can</source>
          <target state="translated">该 &lt;code&gt;SUPER&lt;/code&gt; 改性剂可</target>
        </trans-unit>
        <trans-unit id="371b5ebfc9cdf0db9a0a55eae240989e954cb726" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; pseudo-class is resolved from the package where the call is made. It is</source>
          <target state="translated">该 &lt;code&gt;SUPER&lt;/code&gt; 伪类是从哪里拨制成的包装解决。它是</target>
        </trans-unit>
        <trans-unit id="ce9315ac1b0e03b32c4d0f032e1290883c21a935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Script&lt;/code&gt; or &lt;code&gt;Script_Extensions&lt;/code&gt; properties are likely to be the ones you want to use when processing natural language; the &lt;code&gt;Block&lt;/code&gt; property may occasionally be useful in working with the nuts and bolts of Unicode.</source>
          <target state="translated">该 &lt;code&gt;Script&lt;/code&gt; 或 &lt;code&gt;Script_Extensions&lt;/code&gt; 性质可能是处理自然语言，当你想使用的人; 的 &lt;code&gt;Block&lt;/code&gt; 属性可能偶尔会在使用Unicode的螺母和螺栓的工作是有用的。</target>
        </trans-unit>
        <trans-unit id="0daac5f890ff04f28fabf32094505977d698c4f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Storable::last_op_in_netorder()&lt;/code&gt; predicate will tell you whether network order was used in the last store or retrieve operation. If you don't know how to use this, just forget about it.</source>
          <target state="translated">该 &lt;code&gt;Storable::last_op_in_netorder()&lt;/code&gt; 谓词会告诉你是否在过去的商店使用或检索操作网络秩序。如果您不知道如何使用它，那就别管它了。</target>
        </trans-unit>
        <trans-unit id="4f2453d7aa3fb23473e60b4a26a3d26672cf6341" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TODO:&lt;/code&gt; and &lt;code&gt;$TODO&lt;/code&gt; syntax is generally pretty good about figuring out whether or not we're in a TODO test. However, often we find that this is not possible to determine (such as when we want to use &lt;code&gt;$TODO&lt;/code&gt; but the tests are being executed in other packages which can't be inferred beforehand).</source>
          <target state="translated">通常， &lt;code&gt;TODO:&lt;/code&gt; 和 &lt;code&gt;$TODO&lt;/code&gt; 语法可以很好地判断我们是否处于TODO测试中。但是，通常我们发现这是无法确定的（例如，当我们想使用 &lt;code&gt;$TODO&lt;/code&gt; 但是测试是在其他无法事先推断的程序包中执行时）。</target>
        </trans-unit>
        <trans-unit id="ca16843b685fa84c8313aca285e376c5597ef322" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TYPEMAP&lt;/code&gt; section should contain one pair of C type and XS type per line as follows. An example from the core typemap file:</source>
          <target state="translated">的 &lt;code&gt;TYPEMAP&lt;/code&gt; 部分应包含一对C类和如下每行XS类型。核心类型映射文件中的示例：</target>
        </trans-unit>
        <trans-unit id="ea8183d7125676dfc1989dcabf04b34c38b4f669" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; function returns a thread object that represents the thread making the &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; call.</source>
          <target state="translated">该 &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; 函数返回一个代表线程使一个线程对象 &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; 电话。</target>
        </trans-unit>
        <trans-unit id="5f72cf2b372d3d426c2948d6098fd6cd1afad651" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; module provides multithreading support for Perl.</source>
          <target state="translated">该 &lt;code&gt;Thread&lt;/code&gt; 模块提供了对Perl多线程的支持。</target>
        </trans-unit>
        <trans-unit id="7fe8315550458ad4289f70c4a27bed2792ae2d78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; module served as the frontend to the old-style thread model, called</source>
          <target state="translated">该 &lt;code&gt;Thread&lt;/code&gt; 担任前台的老样式的线程模型模块，名为</target>
        </trans-unit>
        <trans-unit id="ab5cb47a9617fcafbcf6221a375828cf9de09e24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Time::HiRes&lt;/code&gt; module implements a Perl interface to the &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;nanosleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , and &lt;code&gt;setitimer&lt;/code&gt; /&lt;code&gt;getitimer&lt;/code&gt; system calls, in other words, high resolution time and timers. See the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; section below and the test scripts for usage; see your system documentation for the description of the underlying &lt;code&gt;nanosleep&lt;/code&gt; or &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , and &lt;code&gt;setitimer&lt;/code&gt; /&lt;code&gt;getitimer&lt;/code&gt; calls.</source>
          <target state="translated">该 &lt;code&gt;Time::HiRes&lt;/code&gt; 模块实现Perl接口 &lt;code&gt;usleep&lt;/code&gt; ， &lt;code&gt;nanosleep&lt;/code&gt; ， &lt;code&gt;ualarm&lt;/code&gt; ， &lt;code&gt;gettimeofday&lt;/code&gt; 的，和 &lt;code&gt;setitimer&lt;/code&gt; / &lt;code&gt;getitimer&lt;/code&gt; 系统调用，换句话说，高分辨率时间和计时器。请参见下面的&lt;a href=&quot;#EXAMPLES&quot;&gt;示例&lt;/a&gt;部分和测试脚本以了解用法。有关底层 &lt;code&gt;nanosleep&lt;/code&gt; 或 &lt;code&gt;usleep&lt;/code&gt; ， &lt;code&gt;ualarm&lt;/code&gt; ， &lt;code&gt;gettimeofday&lt;/code&gt; 和 &lt;code&gt;setitimer&lt;/code&gt; / &lt;code&gt;getitimer&lt;/code&gt; 调用的描述，请参见系统文档。</target>
        </trans-unit>
        <trans-unit id="adde2e15da0476d4564064bbc384c4ca957b8d40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VERSION&lt;/code&gt; method returns the version number of the class (package).</source>
          <target state="translated">的 &lt;code&gt;VERSION&lt;/code&gt; 方法返回类（包）的版本号。</target>
        </trans-unit>
        <trans-unit id="d8baa2e2f7c0fd0a2f0c9455f11a42eb910290cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Win32::*&lt;/code&gt; modules in &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;Win32::*&lt;/code&gt; 模块&lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;的Win32&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6c47ba9b1855f9e0e157ed96c1dac4112ef8de3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; sequence is supposed to be empty.</source>
          <target state="translated">所述 &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; 序列被认为是空的。</target>
        </trans-unit>
        <trans-unit id="f3c164b87544e368a57522144bf31b4093cb008b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; notation also works in certain circumstances outside the pattern. See &lt;a href=&quot;#Warning-on-%5c1-Instead-of-%241&quot;&gt;Warning on \1 Instead of $1&lt;/a&gt; below for details.</source>
          <target state="translated">该 &lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; 符号也适用于从图案的某些情况。有关详细信息，请参见下面的&lt;a href=&quot;#Warning-on-%5c1-Instead-of-%241&quot;&gt;\ 1而不是$ 1上的警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c49d42a1bfbc0b22f583d2817d2ce107934b83b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\C&lt;/code&gt; is unsupported in lookbehind, because the already treacherous definition of &lt;code&gt;\C&lt;/code&gt; would become even more so when going backwards.</source>
          <target state="translated">该 &lt;code&gt;\C&lt;/code&gt; 是回顾后不支持的，因为已经奸诈定义 &lt;code&gt;\C&lt;/code&gt; 倒退时会变得更加如此。</target>
        </trans-unit>
        <trans-unit id="b97997ed1726a2dd70e1e88046ee54105827a12b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\G&lt;/code&gt; assertion can be used to chain global matches (using &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;), as described in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;. It is also useful when writing &lt;code&gt;lex&lt;/code&gt; -like scanners, when you have several patterns that you want to match against consequent substrings of your string; see the previous reference. The actual location where &lt;code&gt;\G&lt;/code&gt; will match can also be influenced by using &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; as an lvalue: see &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;. Note that the rule for zero-length matches (see &lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;Repeated Patterns Matching a Zero-length Substring&lt;/a&gt;) is modified somewhat, in that contents to the left of &lt;code&gt;\G&lt;/code&gt; are not counted when determining the length of the match. Thus the following will not match forever:</source>
          <target state="translated">所述 &lt;code&gt;\G&lt;/code&gt; 断言可以用于链全局匹配（使用 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; ），如描述&lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;在perlop中的正则表达式报价样算&lt;/a&gt;。当编写 &lt;code&gt;lex&lt;/code&gt; 的扫描器时，当您有几种模式要与字符串的后续子字符串进行匹配时，它也很有用；请参阅前面的参考。 &lt;code&gt;\G&lt;/code&gt; 匹配的实际位置也可以通过使用 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 作为左值来影响：请参见&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;。请注意，零长度匹配的规则（请参见&lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;匹配零长度子字符串的重复模式&lt;/a&gt;）有所修改，其内容位于 &lt;code&gt;\G&lt;/code&gt; 左侧确定比赛时间时不计算在内。因此，以下内容将永远不会匹配：</target>
        </trans-unit>
        <trans-unit id="9300fc0425608314652e19b5173bc5fd7efd18c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\N&lt;/code&gt; character class, not to be confused with the named character sequence &lt;code&gt;\N{NAME}&lt;/code&gt; , denotes any non-newline character in a regular expression.</source>
          <target state="translated">的 &lt;code&gt;\N&lt;/code&gt; 字符类，不与已命名的字符序列相混淆 &lt;code&gt;\N{NAME}&lt;/code&gt; ，表示在正则表达式的任何非换行符。</target>
        </trans-unit>
        <trans-unit id="6fc55e5a124a8f9ba1fb9b74d5a25063c2e050b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\N{...}&lt;/code&gt; construct explicitly refers to a Unicode code point, even if it is one that is also in ASCII. Therefore the string containing it must be Unicode.</source>
          <target state="translated">该 &lt;code&gt;\N{...}&lt;/code&gt; 结构明确指的是Unicode代码点，即使它是一个在ASCII中也。因此，包含它的字符串必须是Unicode。</target>
        </trans-unit>
        <trans-unit id="52316cb23d6228b5040f834369875ce8a00e4e55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations can be used both inside and outside of bracketed character classes. Here are some in use:</source>
          <target state="translated">所述 &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; 的缩写可用于括号字符类的内部和外部。这里有一些使用中：</target>
        </trans-unit>
        <trans-unit id="dc3bb1079451a53e38a66554502d10e12737dc82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations can be used both inside and outside of character classes. Here are some in use:</source>
          <target state="translated">所述 &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; 的缩写可用于字符类的内部和外部。这里有一些使用中：</target>
        </trans-unit>
        <trans-unit id="0f2c8f2ff00b285673d694a7e44211cdef772f8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;/code&gt; and &lt;code&gt;\k&lt;/code&gt; notations were introduced in Perl 5.10.0. Prior to that there were no named nor relative numbered capture groups. Absolute numbered groups were referred to using &lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; , etc., and this notation is still accepted (and likely always will be). But it leads to some ambiguities if there are more than 9 capture groups, as &lt;code&gt;\10&lt;/code&gt; could mean either the tenth capture group, or the character whose ordinal in octal is 010 (a backspace in ASCII). Perl resolves this ambiguity by interpreting &lt;code&gt;\10&lt;/code&gt; as a backreference only if at least 10 left parentheses have opened before it. Likewise &lt;code&gt;\11&lt;/code&gt; is a backreference only if at least 11 left parentheses have opened before it. And so on. &lt;code&gt;\1&lt;/code&gt; through &lt;code&gt;\9&lt;/code&gt; are always interpreted as backreferences. There are several examples below that illustrate these perils. You can avoid the ambiguity by always using &lt;code&gt;\g{}&lt;/code&gt; or &lt;code&gt;\g&lt;/code&gt; if you mean capturing groups; and for octal constants always using &lt;code&gt;\o{}&lt;/code&gt; , or for &lt;code&gt;\077&lt;/code&gt; and below, using 3 digits padded with leading zeros, since a leading zero implies an octal constant.</source>
          <target state="translated">在 &lt;code&gt;\g&lt;/code&gt; Perl 5.10.0中引入了\ g和 &lt;code&gt;\k&lt;/code&gt; 表示法。在此之前，没有命名或相对编号的捕获组。绝对编号的组使用 &lt;code&gt;\1&lt;/code&gt; ， &lt;code&gt;\2&lt;/code&gt; 等来引用，并且该表示法仍然被接受（并且可能总是被使用）。但是，如果捕获组超过9个，则会导致一些歧义，因为 &lt;code&gt;\10&lt;/code&gt; 可能表示第十个捕获组，或者八进制序数为010（ASCII的退格键）的字符。 Perl 仅在至少10个左括号之前将 &lt;code&gt;\10&lt;/code&gt; 解释为反向引用，从而解决了这种歧义。同样 &lt;code&gt;\11&lt;/code&gt; 仅当至少有11个左括号在其之前打开时，才为backreference。等等。 &lt;code&gt;\1&lt;/code&gt; 到 &lt;code&gt;\9&lt;/code&gt; 始终被解释为反向引用。下面有几个示例说明了这些危险。如果要捕获组，可以始终使用 &lt;code&gt;\g{}&lt;/code&gt; 或 &lt;code&gt;\g&lt;/code&gt; 来避免歧义。对于始终使用 &lt;code&gt;\o{}&lt;/code&gt; 八进制常量，或者对于 &lt;code&gt;\077&lt;/code&gt; 及以下版本的八进制常量，请使用3位数字加上前导零，因为前导零表示八进制常数。</target>
        </trans-unit>
        <trans-unit id="517d2abbf8670e3eaf5c272713d99b8bf67cd7d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; form can be equivalently written as &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; which avoids ambiguity when building a regex by concatenating shorter strings. Otherwise if you had a regex &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt; , you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="translated">所述 &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; 形式可以等同地写为 &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; 通过连接较短字符串构建一个正则表达式时，其避免歧义。否则，如果您有一个正则表达式 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt; ，并且 &lt;code&gt;$a&lt;/code&gt; 包含 &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; ，而 &lt;code&gt;$b&lt;/code&gt; 包含 &lt;code&gt;&quot;37&quot;&lt;/code&gt; ，则会得到 &lt;code&gt;/\g137/&lt;/code&gt; ，这可能不是您想要的。</target>
        </trans-unit>
        <trans-unit id="1162dcf378fe4b180c42e9c8606223aea754f52f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__DATA__&lt;/code&gt; token tells the perl compiler that the perl code for compilation is finished. Everything after the &lt;code&gt;__DATA__&lt;/code&gt; token is available for reading via the filehandle FOOBAR::DATA, where FOOBAR is the name of the current package when the &lt;code&gt;__DATA__&lt;/code&gt; token is reached. This works just the same as &lt;code&gt;__END__&lt;/code&gt; does in package 'main', but for other modules data after &lt;code&gt;__END__&lt;/code&gt; is not automatically retrievable, whereas data after &lt;code&gt;__DATA__&lt;/code&gt; is. The &lt;code&gt;__DATA__&lt;/code&gt; token is not recognized in versions of perl prior to 5.001m.</source>
          <target state="translated">该 &lt;code&gt;__DATA__&lt;/code&gt; 令牌告诉perl的编译器编译Perl代码完成。 &lt;code&gt;__DATA__&lt;/code&gt; 令牌之后的所有内容都可以通过文件句柄FOOBAR :: DATA读取，其中FOOBAR 是到达 &lt;code&gt;__DATA__&lt;/code&gt; 令牌时的当前包的名称。这与 &lt;code&gt;__END__&lt;/code&gt; 在程序包&amp;ldquo; main&amp;rdquo;中的工作原理相同，但是对于其他模块， &lt;code&gt;__END__&lt;/code&gt; 之后的数据不能自动检索，而 &lt;code&gt;__DATA__&lt;/code&gt; 之后的数据则可以自动检索。该 &lt;code&gt;__DATA__&lt;/code&gt; 令牌不能在Perl之前5.001米版本认可。</target>
        </trans-unit>
        <trans-unit id="e8e846812293eaeddc68b23ea744d79168534a2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , and &lt;code&gt;Z&lt;/code&gt; types gobble just one value, but pack it as a string of length count, padding with nulls or spaces as needed. When unpacking, &lt;code&gt;A&lt;/code&gt; strips trailing whitespace and nulls, &lt;code&gt;Z&lt;/code&gt; strips everything after the first null, and &lt;code&gt;a&lt;/code&gt; returns data with no stripping at all.</source>
          <target state="translated">的 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;A&lt;/code&gt; ，和 &lt;code&gt;Z&lt;/code&gt; 类型吞噬只有一个值，但根据需要包装它作为长度计数，用null填充或空格的字符串。拆包时， &lt;code&gt;A&lt;/code&gt; 会删除结尾的空格和null， &lt;code&gt;Z&lt;/code&gt; 会删除第一个null之后的所有内容，而 &lt;code&gt;a&lt;/code&gt; 则返回没有任何内容的数据。</target>
        </trans-unit>
        <trans-unit id="d5cca45db774b8d4bbc26743f5dae5512cca0753" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;antlers&lt;/code&gt; import flag tells &lt;code&gt;Class::Accessor&lt;/code&gt; that you want to define your attributes using &lt;code&gt;Moose&lt;/code&gt; -like syntax. The only parameter that you can pass to &lt;code&gt;has&lt;/code&gt; is &lt;code&gt;is&lt;/code&gt; . We recommend that you use this Moose-like syntax if you choose &lt;code&gt;Class::Accessor&lt;/code&gt; since it means you will have a smoother upgrade path if you later decide to move to &lt;code&gt;Moose&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;antlers&lt;/code&gt; 进口标志告诉 &lt;code&gt;Class::Accessor&lt;/code&gt; 要定义使用属性 &lt;code&gt;Moose&lt;/code&gt; 般的语法。你可以传递给唯一的参数 &lt;code&gt;has&lt;/code&gt; 是 &lt;code&gt;is&lt;/code&gt; 。如果您选择 &lt;code&gt;Class::Accessor&lt;/code&gt; ，则建议您使用类似Moose的语法，因为这意味着如果您以后决定迁移到 &lt;code&gt;Moose&lt;/code&gt; ,则升级路径将更加平滑。</target>
        </trans-unit>
        <trans-unit id="30d4c5418acb92744951617bccd4c2bb4e907086" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as_number()&lt;/code&gt; function returns a BigInt from a Math::BigFloat. It uses 'trunc' as rounding mode to make it equivalent to:</source>
          <target state="translated">该 &lt;code&gt;as_number()&lt;/code&gt; 函数返回从数学:: BigFloat一个BIGINT。它使用&amp;ldquo; trunc&amp;rdquo;作为舍入模式，使其等效于：</target>
        </trans-unit>
        <trans-unit id="3e4be85862bcecd6790751ef47534ab240cde4eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autodie&lt;/code&gt; pragma has</source>
          <target state="translated">该 &lt;code&gt;autodie&lt;/code&gt; 编译具有</target>
        </trans-unit>
        <trans-unit id="92907be6274b88924410c3eb7108af17c084f529" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autodie&lt;/code&gt; pragma provides a convenient way to replace functions that normally return false on failure with equivalents that throw an exception on failure.</source>
          <target state="translated">自动 &lt;code&gt;autodie&lt;/code&gt; 编译指示提供了一种方便的方法，可以将通常会在失败时返回false的函数替换为在失败时引发异常的等效项。</target>
        </trans-unit>
        <trans-unit id="3ccf77f6494c4bb94f71a5890c3e377c22247ef4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit&lt;/code&gt; interface splits the specified file into a hierarchy rooted at the directory &lt;code&gt;$dir&lt;/code&gt; . It creates directories as needed to reflect class hierarchy, and creates the file</source>
          <target state="translated">该 &lt;code&gt;autosplit&lt;/code&gt; 接口拆分指定的文件到在目录为根的层次 &lt;code&gt;$dir&lt;/code&gt; 。它根据需要创建目录以反映类层次结构，并创建文件</target>
        </trans-unit>
        <trans-unit id="cc73dbc80868b5e2537b36abd82d968f2ba4c751" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit_lib_modules&lt;/code&gt; form is used in the building of perl. It takes as input a list of files (modules) that are assumed to reside in a directory &lt;b&gt;lib&lt;/b&gt; relative to the current directory. Each file is sent to the autosplitter one at a time, to be split into the directory &lt;b&gt;lib/auto&lt;/b&gt;.</source>
          <target state="translated">该 &lt;code&gt;autosplit_lib_modules&lt;/code&gt; 形式是Perl的建设使用。它以假定位于相对于当前目录的目录&lt;b&gt;lib&lt;/b&gt;中的文件（模块）列表作为输入。每个文件一次发送到&lt;b&gt;自动&lt;/b&gt;拆分器，然后拆分到目录&lt;b&gt;lib / auto&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="423004d21ce960dd9509db30e9f26d66964e12d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autotie&lt;/code&gt; mechanism supports this too. The following code:</source>
          <target state="translated">该 &lt;code&gt;autotie&lt;/code&gt; 机制支持这一点。如下代码：</target>
        </trans-unit>
        <trans-unit id="eadb034339c34e003fe891167b8ebaef4be23657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_clear&lt;/code&gt; function deletes all the elements in the AV* array, but does not actually delete the array itself. The &lt;code&gt;av_undef&lt;/code&gt; function will delete all the elements in the array plus the array itself. The &lt;code&gt;av_extend&lt;/code&gt; function extends the array so that it contains at least &lt;code&gt;key+1&lt;/code&gt; elements. If &lt;code&gt;key+1&lt;/code&gt; is less than the currently allocated length of the array, then nothing is done.</source>
          <target state="translated">该 &lt;code&gt;av_clear&lt;/code&gt; 函数删除在AV *阵列的所有元素，但不实际删除阵列本身。该 &lt;code&gt;av_undef&lt;/code&gt; 功能将删除阵列以及在阵列本身上的所有元素。所述 &lt;code&gt;av_extend&lt;/code&gt; 功能以便它包含至少延伸所述阵列 &lt;code&gt;key+1&lt;/code&gt; 的元件。如果 &lt;code&gt;key+1&lt;/code&gt; 小于当前分配的数组长度，则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="d6bd36bbe209d0e332f324c88cb8fab5da451e26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_store&lt;/code&gt; function, when given a tied array argument, merely copies the magic of the array onto the value to be &quot;stored&quot;, using &lt;code&gt;mg_copy&lt;/code&gt; . It may also return NULL, indicating that the value did not actually need to be stored in the array. [MAYCHANGE] After a call to &lt;code&gt;av_store&lt;/code&gt; on a tied array, the caller will usually need to call &lt;code&gt;mg_set(val)&lt;/code&gt; to actually invoke the perl level &quot;STORE&quot; method on the TIEARRAY object. If &lt;code&gt;av_store&lt;/code&gt; did return NULL, a call to &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; will also be usually necessary to avoid a memory leak. [/MAYCHANGE]</source>
          <target state="translated">的 &lt;code&gt;av_store&lt;/code&gt; 功能，给定一个绑数组参数，仅仅复制阵列上的值的魔术被&amp;ldquo;存储&amp;rdquo;，使用时 &lt;code&gt;mg_copy&lt;/code&gt; 。它还可能返回NULL，指示该值实际上不需要存储在数组中。 [MAYCHANGE]到呼叫后 &lt;code&gt;av_store&lt;/code&gt; 一个绑阵列上，呼叫者将通常需要呼叫 &lt;code&gt;mg_set(val)&lt;/code&gt; 到TIEARRAY对象上实际调用Perl的水平&amp;ldquo;STORE&amp;rdquo;方法。如果 &lt;code&gt;av_store&lt;/code&gt; 确实返回了NULL，则通常也需要调用 &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; 以避免内存泄漏。 [/ MAYCHANGE]</target>
        </trans-unit>
        <trans-unit id="b0bf6421125301461c635d2914e7cd34219ce4cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_top_index&lt;/code&gt; function returns the highest index value in an array (just like $#array in Perl). If the array is empty, -1 is returned. The &lt;code&gt;av_fetch&lt;/code&gt; function returns the value at index &lt;code&gt;key&lt;/code&gt; , but if &lt;code&gt;lval&lt;/code&gt; is non-zero, then &lt;code&gt;av_fetch&lt;/code&gt; will store an undef value at that index. The &lt;code&gt;av_store&lt;/code&gt; function stores the value &lt;code&gt;val&lt;/code&gt; at index &lt;code&gt;key&lt;/code&gt; , and does not increment the reference count of &lt;code&gt;val&lt;/code&gt; . Thus the caller is responsible for taking care of that, and if &lt;code&gt;av_store&lt;/code&gt; returns NULL, the caller will have to decrement the reference count to avoid a memory leak. Note that &lt;code&gt;av_fetch&lt;/code&gt; and &lt;code&gt;av_store&lt;/code&gt; both return &lt;code&gt;SV**&lt;/code&gt; 's, not &lt;code&gt;SV*&lt;/code&gt; 's as their return value.</source>
          <target state="translated">该 &lt;code&gt;av_top_index&lt;/code&gt; 功能在一个数组（就像$＃数组在Perl）返回指数最高值。如果数组为空，则返回-1。该 &lt;code&gt;av_fetch&lt;/code&gt; 函数返回的索引值 &lt;code&gt;key&lt;/code&gt; ，但如果 &lt;code&gt;lval&lt;/code&gt; 中是不为零，那么 &lt;code&gt;av_fetch&lt;/code&gt; 将存储指数在UNDEF值。该 &lt;code&gt;av_store&lt;/code&gt; 功能将值 &lt;code&gt;val&lt;/code&gt; 索引 &lt;code&gt;key&lt;/code&gt; ，并且不增加的引用计数 &lt;code&gt;val&lt;/code&gt; 。因此，调用者负责处理此问题，并且如果 &lt;code&gt;av_store&lt;/code&gt; 返回NULL，则调用者将不得不减少引用计数以避免内存泄漏。注意 &lt;code&gt;av_fetch&lt;/code&gt; 和 &lt;code&gt;av_store&lt;/code&gt; 都返回 &lt;code&gt;SV**&lt;/code&gt; 而不是 &lt;code&gt;SV*&lt;/code&gt; 作为它们的返回值。</target>
        </trans-unit>
        <trans-unit id="ca3e501abc26cf1405f0402c343ec30915264f88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keywords from C become in Perl &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, respectively. Unlike in C, these do</source>
          <target state="translated">来自C 的 &lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 关键字分别在Perl中的 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 中。与C不同，这些</target>
        </trans-unit>
        <trans-unit id="1750aab93908ada1ee29e1880f7061b67617e505" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cacheout&lt;/code&gt; function will make sure that there's a filehandle open for reading or writing available as the pathname you give it. It automatically closes and re-opens files if you exceed your system's maximum number of file descriptors, or the suggested maximum</source>
          <target state="translated">该 &lt;code&gt;cacheout&lt;/code&gt; 功能将确保有一个句柄开放阅读或你给它的路径写入时，可用。如果您超过系统的最大文件描述符数量或建议的最大数量，它将自动关闭并重新打开文件</target>
        </trans-unit>
        <trans-unit id="2c5778ca552de672cec71f94fb24332cb951e6b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can&lt;/code&gt; method checks to see if the class or object it was called on has a method named &lt;code&gt;$method&lt;/code&gt; . This checks for the method in the class and all of its parents. If the method exists, then a reference to the subroutine is returned. If it does not then &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">该 &lt;code&gt;can&lt;/code&gt; 的方法检查，看是否类或对象，它被称为上有一个名为方法 &lt;code&gt;$method&lt;/code&gt; 。这将检查该类及其所有父级中的方法。如果该方法存在，则返回对该子例程的引用。如果没有，则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a231f00f91910adc2ab3862d9199fc8f2fdda4f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can_run&lt;/code&gt; function can tell you if a certain binary is installed and if so where, whereas the &lt;code&gt;run&lt;/code&gt; function can actually execute any of the commands you give it and give you a clear return value, as well as adhere to your verbosity settings.</source>
          <target state="translated">该 &lt;code&gt;can_run&lt;/code&gt; 功能可以告诉你，如果安装了某些二进制如果是的话在哪里，而 &lt;code&gt;run&lt;/code&gt; 功能，实际上可以执行任何你给它，给你一个明确的返回值，以及坚持你的级别设置的命令。</target>
        </trans-unit>
        <trans-unit id="ae669119c46135f428f552580c056d83e94ae6fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char*&lt;/code&gt; string does not tell you the whole story, and you can't copy or reconstruct an SV just by copying the string value. Check if the old SV has the UTF8 flag set (</source>
          <target state="translated">该 &lt;code&gt;char*&lt;/code&gt; 字符串不告诉你整个故事，你不能复制或只是通过复制字符串值重建的SV。检查旧的SV是否设置了UTF8标志（</target>
        </trans-unit>
        <trans-unit id="3b094d933bb88b4ae1f6722063975d6ce16a864f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;charnames&lt;/code&gt; pragma supports arguments &lt;code&gt;:full&lt;/code&gt; , &lt;code&gt;:loose&lt;/code&gt; , &lt;code&gt;:short&lt;/code&gt; , script names and &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;customized aliases&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;charnames&lt;/code&gt; 编译支持论据 &lt;code&gt;:full&lt;/code&gt; ， &lt;code&gt;:loose&lt;/code&gt; ， &lt;code&gt;:short&lt;/code&gt; ，脚本的名称和&lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;自定义的别名&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7bf018bbe36ec38be15a617cdd0dc65af5cb382c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cmp&lt;/code&gt; (and hence &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;) operators do not necessarily give the correct results when both operands are UTF-EBCDIC encoded strings and there is a mixture of ASCII and/or control characters, along with other characters.</source>
          <target state="translated">当两个操作数都是UTF-EBCDIC编码的字符串并且混合了ASCII和/或控制字符以及其他字符时， &lt;code&gt;cmp&lt;/code&gt; （并因此是 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; ）运算符不一定给出正确的结果。</target>
        </trans-unit>
        <trans-unit id="ec09ece4b13035db3b64ac6559a812694d130f2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;color&lt;/code&gt; function determines if colouring should occur or not. Passing it a true or false value will enable or disable colouring respectively, and the function called with no argument will return the current setting.</source>
          <target state="translated">的 &lt;code&gt;color&lt;/code&gt; 函数确定着色应该发生与否。为其传递true或false值将分别启用或禁用着色，并且不带参数调用的函数将返回当前设置。</target>
        </trans-unit>
        <trans-unit id="fcc832a2467057f7acfd689fa1bb07925f149ce1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complicated&lt;/code&gt; function will return the same numeric &lt;code&gt;$result&lt;/code&gt; regardless of whether it is called in list or in scalar context.</source>
          <target state="translated">在 &lt;code&gt;complicated&lt;/code&gt; 函数将返回相同的数值 &lt;code&gt;$result&lt;/code&gt; ，无论它被称为列表或者在标量上下文。</target>
        </trans-unit>
        <trans-unit id="f67952b359119ecd8ea38089ffb10eb7987a4172" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_broadcast&lt;/code&gt; function works similarly to &lt;code&gt;cond_signal&lt;/code&gt; . &lt;code&gt;cond_broadcast&lt;/code&gt; , though, will unblock &lt;b&gt;all&lt;/b&gt; the threads that are blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the locked variable, rather than only one.</source>
          <target state="translated">该 &lt;code&gt;cond_broadcast&lt;/code&gt; 功能工作，以同样 &lt;code&gt;cond_signal&lt;/code&gt; 。但是， &lt;code&gt;cond_broadcast&lt;/code&gt; 将取消阻塞在 &lt;code&gt;cond_wait&lt;/code&gt; 中被锁定的变量（而不是仅一个）上的&lt;b&gt;所有&lt;/b&gt;线程。</target>
        </trans-unit>
        <trans-unit id="a85c76c4fd238a57c5f21f762fcaeb20729d17df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt; ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="translated">该 &lt;code&gt;cond_signal&lt;/code&gt; 函数接受一个&lt;b&gt;锁定&lt;/b&gt;变量作为参数，并接通一个线程的 &lt;code&gt;cond_wait&lt;/code&gt; 该变量ING。如果在该变量的 &lt;code&gt;cond_wait&lt;/code&gt; 中阻塞了多个线程，则只有一个（不确定哪个线程）将被取消阻塞。</target>
        </trans-unit>
        <trans-unit id="c5be06c4673c5f0381dc64821a424c5ce57dffbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a locked variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt; ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="translated">该 &lt;code&gt;cond_signal&lt;/code&gt; 函数接受一个加锁的变量作为参数，并放开一个线程的 &lt;code&gt;cond_wait&lt;/code&gt; 该变量ING。如果在该变量的 &lt;code&gt;cond_wait&lt;/code&gt; 中阻塞了一个以上的线程，则只有一个（不确定哪个线程）将被取消阻塞。</target>
        </trans-unit>
        <trans-unit id="076e7dbb91376a2a5dc565f0cafe6a8c9c90bfab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is re-locked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt; ing on the same variable, all but one will re-block waiting to reacquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible). The two actions of unlocking the variable and entering the blocked wait state are atomic, the two actions of exiting from the blocked wait state and re-locking the variable are not.</source>
          <target state="translated">的 &lt;code&gt;cond_wait&lt;/code&gt; 函数接受一个&lt;b&gt;锁定&lt;/b&gt;变量作为参数，解锁变量，块，直到另一个线程做了 &lt;code&gt;cond_signal&lt;/code&gt; 或 &lt;code&gt;cond_broadcast&lt;/code&gt; 该相同锁定变量。该变量 &lt;code&gt;cond_wait&lt;/code&gt; 阻塞是重新锁定后 &lt;code&gt;cond_wait&lt;/code&gt; 满足。如果在同一个变量上有多个 &lt;code&gt;cond_wait&lt;/code&gt; 线程，则除一个线程外的所有线程都将重新阻塞，以等待重新获取该变量的锁。 （因此，如果您仅使用 &lt;code&gt;cond_wait&lt;/code&gt; 为了同步，请尽快放弃该锁）。解锁变量和进入阻塞等待状态的两个动作是原子的，退出阻塞等待状态和重新锁定变量的两个动作不是原子的。</target>
        </trans-unit>
        <trans-unit id="0fa04a005ef5fee3bbdeb8f830aca63065ce2e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is relocked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt; ing on the same variable, all but one will reblock waiting to re-acquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible.)</source>
          <target state="translated">的 &lt;code&gt;cond_wait&lt;/code&gt; 函数接受一个&lt;b&gt;锁定&lt;/b&gt;变量作为参数，解锁变量，块，直到另一个线程做了 &lt;code&gt;cond_signal&lt;/code&gt; 或 &lt;code&gt;cond_broadcast&lt;/code&gt; 该相同锁定变量。满足 &lt;code&gt;cond_wait&lt;/code&gt; 之后，将重新锁定 &lt;code&gt;cond_wait&lt;/code&gt; 阻塞的变量。如果在同一变量上有多个 &lt;code&gt;cond_wait&lt;/code&gt; 线程，则除一个线程外的所有线程都将重新阻塞，以等待重新获取该变量的锁。 （因此，如果您仅使用 &lt;code&gt;cond_wait&lt;/code&gt; 进行同步，请尽快放弃该锁。）</target>
        </trans-unit>
        <trans-unit id="c05e65092ed5c30b3ec99766dc7198ef2d697366" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;condition&lt;/code&gt; can have several forms. The first form is simply an integer in parentheses &lt;code&gt;(integer)&lt;/code&gt; . It is true if the corresponding backreference &lt;code&gt;\integer&lt;/code&gt; matched earlier in the regexp. The same thing can be done with a name associated with a capture group, written as &lt;code&gt;(&amp;lt;name&amp;gt;)&lt;/code&gt; or &lt;code&gt;('name')&lt;/code&gt; . The second form is a bare zero-width assertion &lt;code&gt;(?...)&lt;/code&gt;, either a lookahead, a lookbehind, or a code assertion (discussed in the next section). The third set of forms provides tests that return true if the expression is executed within a recursion (&lt;code&gt;(R)&lt;/code&gt; ) or is being called from some capturing group, referenced either by number (&lt;code&gt;(R1)&lt;/code&gt; , &lt;code&gt;(R2)&lt;/code&gt; ,...) or by name (&lt;code&gt;(R&amp;amp;name)&lt;/code&gt; ).</source>
          <target state="translated">该 &lt;code&gt;condition&lt;/code&gt; 可以有几种形式。第一种形式只是括号中的整数 &lt;code&gt;(integer)&lt;/code&gt; 。如果相应的反向引用 &lt;code&gt;\integer&lt;/code&gt; 在正则表达式中较早匹配，则为true 。可以使用与捕获组关联的名称来完成同一件事，该名称用 &lt;code&gt;(&amp;lt;name&amp;gt;)&lt;/code&gt; 或 &lt;code&gt;('name')&lt;/code&gt; 表示。第二种形式是裸零宽度断言 &lt;code&gt;(?...)&lt;/code&gt; ，可以是超前，后向或代码断言（在下一节中讨论）。第三组形式提供了以下测试：如果表达式是在递归（ &lt;code&gt;(R)&lt;/code&gt; ）中执行的，或者是从某个捕获组中调用的，则返回true ，这些捕获组可以用数字（ &lt;code&gt;(R1)&lt;/code&gt; ， &lt;code&gt;(R2)&lt;/code&gt; ，...）或按名称（ &lt;code&gt;(R&amp;amp;name)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bf42e706aa15e3b9613116ccaae1bce3997d5965" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; function takes two parameters: a file to copy from and a file to copy to. Either argument may be a string, a FileHandle reference or a FileHandle glob. Obviously, if the first argument is a filehandle of some sort, it will be read from, and if it is a file</source>
          <target state="translated">该 &lt;code&gt;copy&lt;/code&gt; 函数有两个参数：从文件拷贝和复制到文件中。自变量可以是字符串，FileHandle引用或FileHandle Glob。显然，如果第一个参数是某种文件句柄，则将从中读取它，并且如果它是文件</target>
        </trans-unit>
        <trans-unit id="bb585d66ac9e0baf39acd70331ff3f0f5eef7b95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cpp&lt;/code&gt; filter does not apply to the text of the Fred module, only to the text of the file that used it (&lt;code&gt;cpp_test&lt;/code&gt; ). Although the use statement on line 3 will pass through the cpp filter, the module that gets included (&lt;code&gt;Fred&lt;/code&gt; ) will not. The source streams look like this after line 3 has been parsed and before line 4 is parsed:</source>
          <target state="translated">该 &lt;code&gt;cpp&lt;/code&gt; 过滤器并不适用于弗雷德模块的文本，只对使用它的文件（文本 &lt;code&gt;cpp_test&lt;/code&gt; ）。尽管第3行上的use语句将通过cpp过滤器，但包含的模块（ &lt;code&gt;Fred&lt;/code&gt; ）不会通过。在解析第3行之后和解析第4行之前，源流如下所示：</target>
        </trans-unit>
        <trans-unit id="3a0e889b0f475939308ccb8373e116461d3751c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;create()&lt;/code&gt; method takes a reference to a subroutine and creates a new thread that starts executing in the referenced subroutine. Control then passes both to the subroutine and the caller.</source>
          <target state="translated">的 &lt;code&gt;create()&lt;/code&gt; 方法花费的子程序的参考，并创建开始在引用的子程序执行新线程。然后，控制将传递给子例程和调用者。</target>
        </trans-unit>
        <trans-unit id="30b3d6c14b075946962dafa1dc3a2886740f908a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;diagnostics&lt;/code&gt; Pragma</source>
          <target state="translated">该 &lt;code&gt;diagnostics&lt;/code&gt; 附注</target>
        </trans-unit>
        <trans-unit id="086b0e345be46fb23c5d4022bc1b3516ac49d7c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;display_format&lt;/code&gt; class method and the corresponding &lt;code&gt;display_format&lt;/code&gt; object method can now be called using a parameter hash instead of just a one parameter.</source>
          <target state="translated">该 &lt;code&gt;display_format&lt;/code&gt; 类方法和相应的 &lt;code&gt;display_format&lt;/code&gt; 对象方法现在可以使用一个参数散列而不只是一个参数被调用。</target>
        </trans-unit>
        <trans-unit id="85937d63d0c2a7155254307de5c15a8dc64cc7fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;done&lt;/code&gt; method returns true if the thread you're checking has finished, and false otherwise.</source>
          <target state="translated">该 &lt;code&gt;done&lt;/code&gt; 真正的方法返回如果线程您检查已完成，否则为false。</target>
        </trans-unit>
        <trans-unit id="5c42a2b150a081cef9d9a1db39370eb144f13339" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down&lt;/code&gt; method decreases the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">该 &lt;code&gt;down&lt;/code&gt; 的方法由指定的数目，如果没有指定数目（它必须是整数&amp;gt; = 1），或由一个减小信号量的计数。</target>
        </trans-unit>
        <trans-unit id="1d986e9044d0332c0e0b20d1b476092f758b1763" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_force&lt;/code&gt; method decreases the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified. This method does not block, and may cause the semaphore's count to drop below zero.</source>
          <target state="translated">该 &lt;code&gt;down_force&lt;/code&gt; 方法由指定数目如果没有指定数目（它必须是整数&amp;gt; = 1），或由一个减小信号量的计数。此方法不会阻塞，并且可能导致信号量的计数降至零以下。</target>
        </trans-unit>
        <trans-unit id="59032671c2f862c61987094dab4187139af577bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_nb&lt;/code&gt; method attempts to decrease the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">该 &lt;code&gt;down_nb&lt;/code&gt; 方法试图通过指定的号码，如果没有指定数目（它必须是整数&amp;gt; = 1），或由一个以降低信号量的计数。</target>
        </trans-unit>
        <trans-unit id="48ce45b8c5dc5a90ffb8cc26e428eb8e7134ca2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eogc&lt;/code&gt; flags are stripped out before being passed to the comp routine. The regex engine does not need to know if any of these are set, as those flags should only affect what Perl does with the pattern and its match variables, not how it gets compiled and executed.</source>
          <target state="translated">该 &lt;code&gt;eogc&lt;/code&gt; 标志传递给补偿程序之前被剥离出来。正则表达式引擎不需要知道是否设置了其中任何一个，因为这些标志仅会影响Perl对模式及其匹配变量的作用，而不会影响其如何编译和执行。</target>
        </trans-unit>
        <trans-unit id="5dcaf0131993c2fe373ceb68066111b75397ce84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equal()&lt;/code&gt; method takes two thread objects and returns true if the objects represent the same thread, and false if they don't.</source>
          <target state="translated">该 &lt;code&gt;equal()&lt;/code&gt; 方法有两个线程对象，并返回true，如果对象表示相同的线程，假如果他们不这样做。</target>
        </trans-unit>
        <trans-unit id="d80af1149bc4ce69fb624da74e40c6a5dafd9409" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;examples&lt;/code&gt; sub-directory has copies of all these filters implemented both as</source>
          <target state="translated">该 &lt;code&gt;examples&lt;/code&gt; 子目录拥有所有这些过滤器的副本来实现既作为</target>
        </trans-unit>
        <trans-unit id="a371087f59ef9684a3303b0318405ae011e9ec34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract_delimited&lt;/code&gt; function formalizes the common idiom of extracting a single-character-delimited substring from the start of a string. For example, to extract a single-quote delimited string, the following code is typically used:</source>
          <target state="translated">该 &lt;code&gt;extract_delimited&lt;/code&gt; 功能正式确定从字符串的开头提取单字符分隔的子串的习惯用法。例如，要提取单引号分隔的字符串，通常使用以下代码：</target>
        </trans-unit>
        <trans-unit id="01013bd276b6d8fe2331fe338d632601823957b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract_multiple&lt;/code&gt; subroutine takes a string to be processed and a list of extractors (subroutines or regular expressions) to apply to that string.</source>
          <target state="translated">该 &lt;code&gt;extract_multiple&lt;/code&gt; 子程序需要要处理的字符串，并提取（子程序或正则表达式）的列表，以适用于该字符串。</target>
        </trans-unit>
        <trans-unit id="0234e9715d2d58dfe4e40eada785cc5d3ba85e48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fail&lt;/code&gt; option indicates the action to be taken if a matching end tag is not encountered (i.e. before the end of the string or some &lt;code&gt;reject&lt;/code&gt; pattern matches). By default, a failure to match a closing tag causes &lt;code&gt;extract_tagged&lt;/code&gt; to immediately fail.</source>
          <target state="translated">如果未遇到匹配的结束标记（例如，在字符串的结尾或某些 &lt;code&gt;reject&lt;/code&gt; 模式匹配之前），则 &lt;code&gt;fail&lt;/code&gt; 选项指示要采取的操作。默认情况下，未能匹配结束标记会导致 &lt;code&gt;extract_tagged&lt;/code&gt; 立即失败。</target>
        </trans-unit>
        <trans-unit id="7fdb136937ca0405fd0e09f20f2a40c4f858261d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;failed&lt;/code&gt; command reports all distributions that failed on one of &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; or &lt;code&gt;install&lt;/code&gt; for some reason in the currently running shell session.</source>
          <target state="translated">该 &lt;code&gt;failed&lt;/code&gt; 命令报告失败对一个所有发行 &lt;code&gt;make&lt;/code&gt; ， &lt;code&gt;test&lt;/code&gt; 或 &lt;code&gt;install&lt;/code&gt; 出于某种原因在当前运行的shell会话。</target>
        </trans-unit>
        <trans-unit id="5ad80da9f3017cad820985c782b83967ca308a28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;family&lt;/code&gt; hint to getaddrinfo(), or the family of the socket address passed to getnameinfo() is not supported.</source>
          <target state="translated">不支持getaddrinfo（）的 &lt;code&gt;family&lt;/code&gt; 提示或传递给getnameinfo（）的套接字地址的族。</target>
        </trans-unit>
        <trans-unit id="aaa028e0e10b907654ea97ca6e2e56dbd54cf34e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch&lt;/code&gt; utility is available on FreeBSD. NetBSD and Dragonfly BSD may also have it from &lt;code&gt;pkgsrc&lt;/code&gt; . We only check for &lt;code&gt;fetch&lt;/code&gt; on those three platforms.</source>
          <target state="translated">该 &lt;code&gt;fetch&lt;/code&gt; 实用程序可在FreeBSD。NetBSD和Dragonfly BSD也可能来自 &lt;code&gt;pkgsrc&lt;/code&gt; 。我们仅在这三个平台上检查 &lt;code&gt;fetch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e227d5e7190288807dd09d5662a48f3b24c6088" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fforce&lt;/code&gt; pragma is a variant that emulates a &lt;code&gt;force get&lt;/code&gt; which erases the entire memory followed by the action specified, effectively restarting the whole get/make/test/install procedure from scratch.</source>
          <target state="translated">该 &lt;code&gt;fforce&lt;/code&gt; 编译是一个模拟变体 &lt;code&gt;force get&lt;/code&gt; 其擦除整个存储器，然后指定的动作，有效地重启整个GET /化妆/测试/从头开始安装过程。</target>
        </trans-unit>
        <trans-unit id="67136aec5c09887a5fbdbeaf79603ace225d72fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fields&lt;/code&gt; pragma enables compile-time and run-time verified class fields.</source>
          <target state="translated">该 &lt;code&gt;fields&lt;/code&gt; 编译使编译时和运行时验证类字段。</target>
        </trans-unit>
        <trans-unit id="1da25c8608c050c137eec0fcb8b96dfa9d530dcf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filename&lt;/code&gt; , &lt;code&gt;flags&lt;/code&gt; and &lt;code&gt;mode&lt;/code&gt; parameters are the direct equivalent of their dbopen() counterparts. The final parameter $DB_HASH performs the function of both the &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;openinfo&lt;/code&gt; parameters in dbopen().</source>
          <target state="translated">的 &lt;code&gt;filename&lt;/code&gt; ， &lt;code&gt;flags&lt;/code&gt; 和 &lt;code&gt;mode&lt;/code&gt; 参数是其dbopen（）对应的直接等同物。最终参数$ DB_HASH 在dbopen（）中同时执行 &lt;code&gt;type&lt;/code&gt; 和 &lt;code&gt;openinfo&lt;/code&gt; 参数的功能。</target>
        </trans-unit>
        <trans-unit id="711049b66f21cfb21f8abf404e302b9cb973606c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fileparse()&lt;/code&gt; routine divides a file path into its $dirs, $filename and (optionally) the filename $suffix.</source>
          <target state="translated">该 &lt;code&gt;fileparse()&lt;/code&gt; 程序把一个文件路径到其$迪尔斯，$文件名和（可选）的文件名后缀$。</target>
        </trans-unit>
        <trans-unit id="602708ab2289d55123d1e5cfa483278e5dc2b095" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument can have UNI_DISPLAY_ISPRINT set to display isPRINT()able characters as themselves, UNI_DISPLAY_BACKSLASH to display the \\[nrfta\\] as the backslashed versions (like '\n') (UNI_DISPLAY_BACKSLASH is preferred over UNI_DISPLAY_ISPRINT for \\). UNI_DISPLAY_QQ (and its alias UNI_DISPLAY_REGEX) have both UNI_DISPLAY_BACKSLASH and UNI_DISPLAY_ISPRINT turned on.</source>
          <target state="translated">的 &lt;code&gt;flags&lt;/code&gt; 参数可以具有UNI_DISPLAY_ISPRINT组显示isprint判断（）能够字符本身，UNI_DISPLAY_BACKSLASH作为反斜杠的版本（如&amp;ldquo;\ n&amp;rdquo;）来显示\\ [nrfta \\（UNI_DISPLAY_BACKSLASH优于UNI_DISPLAY_ISPRINT为\\）。UNI_DISPLAY_QQ（及其别名UNI_DISPLAY_REGEX）同时打开了UNI_DISPLAY_BACKSLASH和UNI_DISPLAY_ISPRINT。</target>
        </trans-unit>
        <trans-unit id="db2dfe02c9ae062f42652141438a9f9714c71cea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument is as in &lt;a href=&quot;#pv_uni_display&quot;&gt;pv_uni_display&lt;/a&gt;().</source>
          <target state="translated">该 &lt;code&gt;flags&lt;/code&gt; 的说法是在&lt;a href=&quot;#pv_uni_display&quot;&gt;pv_uni_display&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="99738c77e0f1da5722068673963c4a8f215d0b31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; can be:</source>
          <target state="translated">该 &lt;code&gt;flags&lt;/code&gt; 可以是：</target>
        </trans-unit>
        <trans-unit id="cefd6d4dfafa940aea51a92bdcb195eed2de69a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; method returned the flags for the thread - an integer value corresponding to the internal flags for the thread.</source>
          <target state="translated">该 &lt;code&gt;flags&lt;/code&gt; 方法返回的标志的线程-对应于所述线程的内部标记的整数值。</target>
        </trans-unit>
        <trans-unit id="6cca4f06215bca47eddea026c40afe1b9a43be1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter can be used to determine which of these operations the callbacks should respond to. The following flags are currently defined:</source>
          <target state="translated">该 &lt;code&gt;flags&lt;/code&gt; 参数可以用来确定这些操作的回调应该做出响应。当前定义了以下标志：</target>
        </trans-unit>
        <trans-unit id="459faaa5e3280fee22284d6b094987c77fa7de30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter in all the</source>
          <target state="translated">所有参数中的 &lt;code&gt;flags&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="bfe1865df397f3698f54ec1b600413c38607abed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is a bitfield which indicates which of the &lt;code&gt;msixpn&lt;/code&gt; flags the regex was compiled with. It also contains additional info, such as if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect.</source>
          <target state="translated">的 &lt;code&gt;flags&lt;/code&gt; 参数是一个位字段，其指示其中的 &lt;code&gt;msixpn&lt;/code&gt; 标志正则表达式编译时使用。它还包含其他信息，例如 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 是否有效。</target>
        </trans-unit>
        <trans-unit id="b886ddfa56e0b9ebfe8f2070d41589a1086768dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flush_cache()&lt;/code&gt; function will raise a run-time error unless the tied package provides a &lt;code&gt;CLEAR&lt;/code&gt; method.</source>
          <target state="translated">所述 &lt;code&gt;flush_cache()&lt;/code&gt; 除非捆绑包提供了一个功能将提高运行时错误 &lt;code&gt;CLEAR&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="8ee8bf6c49cb0d370b573c84b81eeff22daa626c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;force&lt;/code&gt; pragma may precede another command (currently: &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; , or &lt;code&gt;install&lt;/code&gt; ) to execute the command from scratch and attempt to continue past certain errors. See the section below on the &lt;code&gt;force&lt;/code&gt; and the &lt;code&gt;fforce&lt;/code&gt; pragma.</source>
          <target state="translated">该 &lt;code&gt;force&lt;/code&gt; 编译可能先于其他命令（目前为： &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;make&lt;/code&gt; ， &lt;code&gt;test&lt;/code&gt; ，或 &lt;code&gt;install&lt;/code&gt; ）从头开始执行命令，并试图继续过去的某些错误。请参见以下有关 &lt;code&gt;force&lt;/code&gt; 和力的 &lt;code&gt;fforce&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34f4026c135fb9c9e701839369f22ab72881f9e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; is the non-experimental way to set a topicalizer. If you wish to use the highly experimental &lt;code&gt;given&lt;/code&gt; , that could be written like this:</source>
          <target state="translated">该 &lt;code&gt;foreach&lt;/code&gt; 是非实验的方法来设置一个topicalizer。如果您想使用 &lt;code&gt;given&lt;/code&gt; 的高度实验性，可以这样写：</target>
        </trans-unit>
        <trans-unit id="de226564415ab69d6441fa2857763cf2ce5fdae3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword, so you can use either. If VAR is omitted, &lt;code&gt;$_&lt;/code&gt; is set to each value.</source>
          <target state="translated">该 &lt;code&gt;foreach&lt;/code&gt; 关键字实际上是对一个同义词 &lt;code&gt;for&lt;/code&gt; 关键字，这样你就可以使用。如果省略VAR，则将 &lt;code&gt;$_&lt;/code&gt; 设置为每个值。</target>
        </trans-unit>
        <trans-unit id="375dcc1d1d2f6f42cca4896811ca8fdfa2d3b491" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword. See &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;Foreach Loops in perlsyn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;foreach&lt;/code&gt; 关键字实际上是对一个同义词 &lt;code&gt;for&lt;/code&gt; 关键字。请参见 &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;Foreach Loops in perlsyn&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b86bb402e5da8037aee4e69efe060f892f194612" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop can also take a reference constructor for its loop variable, though the syntax is limited to one of the following, with an optional &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; after the backslash:</source>
          <target state="translated">该 &lt;code&gt;foreach&lt;/code&gt; 循环还可以利用它的循环变量的引用构造函数，虽然语法限于下列情况之一，使用可选的 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; ，还是 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 反斜杠后：</target>
        </trans-unit>
        <trans-unit id="d9c367bfb9bb4dab65fff1b13521d38572d69dfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop defaults to scoping its index variable dynamically in the manner of &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;. However, if the index variable is prefixed with the keyword &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, or if there is already a lexical by that name in scope, then a new lexical is created instead. Thus in the loop</source>
          <target state="translated">所述 &lt;code&gt;foreach&lt;/code&gt; 循环默认为动态范围设定其索引变量的方式 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 。但是，如果index变量以关键字 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 开头，或者如果作用域中已经存在该名称的词法，则将创建一个新词法。因此在循环中</target>
        </trans-unit>
        <trans-unit id="a4c4603cb509242d80999a110064359f577c21d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop iterates over a normal list value and sets the scalar variable VAR to be each element of the list in turn. If the variable is preceded with the keyword &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, then it is lexically scoped, and is therefore visible only within the loop. Otherwise, the variable is implicitly local to the loop and regains its former value upon exiting the loop. If the variable was previously declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, it uses that variable instead of the global one, but it's still localized to the loop. This implicit localization occurs</source>
          <target state="translated">所述 &lt;code&gt;foreach&lt;/code&gt; 超过正常列表值循环迭代，并设置标量变量VAR是反过来的列表的每个元素。如果变量以关键字 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 开头，则它在词法范围内，因此仅在循环中可见。否则，变量在循环中是隐式局部的，并在退出循环时重新获得其先前的值。如果该变量先前是使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明的，则它将使用该变量而不是全局变量，但仍将其本地化到循环中。发生这种隐式本地化</target>
        </trans-unit>
        <trans-unit id="bb381f2681e84a2954e18395a958e606ca6cba3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame&lt;/code&gt; option can be used to control the output of frame information. For example, contrast this expression trace:</source>
          <target state="translated">该 &lt;code&gt;frame&lt;/code&gt; 选项可用于控制的帧信息的输出。例如，对比此表达式跟踪：</target>
        </trans-unit>
        <trans-unit id="01af8f56de621025abc07dc645713da63a5fe927" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_delimited_pat&lt;/code&gt; subroutine takes a single (string) argument and &amp;gt; builds a Friedl-style optimized regex that matches a string delimited by any one of the characters in the single argument. For example:</source>
          <target state="translated">所述 &lt;code&gt;gen_delimited_pat&lt;/code&gt; 子程序采用一个（字符串）参数，并&amp;gt;建立，通过在单一的参数中的字符中的任一项限定的字符串相匹配的弗里德尔式优化正则表达式。例如：</target>
        </trans-unit>
        <trans-unit id="617ccfb027c1e5d2773071a87cbcedc95dc112aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get_dup&lt;/code&gt; method assists in reading duplicate values from BTREE databases. The method can take the following forms:</source>
          <target state="translated">该 &lt;code&gt;get_dup&lt;/code&gt; 从BTREE数据库中读取数据的重复值法助攻。该方法可以采用以下形式：</target>
        </trans-unit>
        <trans-unit id="7ea986ecd3305b94f4546f1c6e3ce692488dd0fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopt()&lt;/code&gt; function is similar, but its argument is a string containing all switches that take an argument. If no argument is provided for a switch, say, &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, the corresponding &lt;code&gt;$opt_y&lt;/code&gt; will be set to an undefined value. Unspecified switches are silently accepted. Use of &lt;code&gt;getopt()&lt;/code&gt; is not recommended.</source>
          <target state="translated">所述 &lt;code&gt;getopt()&lt;/code&gt; 函数是类似的，但它的参数是含有带参数的所有开关的字符串。如果没有为开关提供参数，例如 &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; ，则相应的 &lt;code&gt;$opt_y&lt;/code&gt; 将被设置为未定义的值。未指定的开关将被静默接受。不建议使用 &lt;code&gt;getopt()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c037451f79364fbd043155e0ffbbe91d2a70fbad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function processes single-character switches with switch clustering. Pass one argument which is a string containing all switches to be recognized. For each switch found, if an argument is expected and provided, &lt;code&gt;getopts()&lt;/code&gt; sets &lt;code&gt;$opt_x&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is the switch name) to the value of the argument. If an argument is expected but none is provided, &lt;code&gt;$opt_x&lt;/code&gt; is set to an undefined value. If a switch does not take an argument, &lt;code&gt;$opt_x&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;getopts()&lt;/code&gt; 函数处理单字符与开关聚类切换。传递一个参数，该参数是一个包含所有要识别的开关的字符串。对于每个开关发现，如果参数是预期的和提供， &lt;code&gt;getopts()&lt;/code&gt; 设置 &lt;code&gt;$opt_x&lt;/code&gt; （其中 &lt;code&gt;x&lt;/code&gt; 是交换机名称）该参数的值。如果需要参数，但不提供，则 &lt;code&gt;$opt_x&lt;/code&gt; 设置为未定义的值。如果开关不带参数，则 &lt;code&gt;$opt_x&lt;/code&gt; 设置为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe182c59e721bf2edc44a9253eded06fe11c1a8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function returns true unless an invalid option was found.</source>
          <target state="translated">该 &lt;code&gt;getopts()&lt;/code&gt; ，除非无效选项发现函数返回true。</target>
        </trans-unit>
        <trans-unit id="688985f64d8825090cd98452194bcbd67a98423b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grammar_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;grammar_class&lt;/code&gt; 可定制，如在&lt;a href=&quot;#new&quot;&gt;新的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="361db5e35a8a030899f4185a6ca897ccf88b2984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;h&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; formats pack a string that many nybbles (4-bit groups, representable as hexadecimal digits, &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt;&lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; ) long.</source>
          <target state="translated">的 &lt;code&gt;h&lt;/code&gt; 和 &lt;code&gt;H&lt;/code&gt; 格式打包的字符串，许多半字节（4位组，可表示为十六进制数字， &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt; &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; ）长。</target>
        </trans-unit>
        <trans-unit id="52b0ba82d51f8c56aed17fcdac89e94cd7a38305" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has()&lt;/code&gt; subroutine declares an attribute, and &lt;code&gt;Moose&lt;/code&gt; automatically creates accessors for these attributes. It also takes care of creating a &lt;code&gt;new()&lt;/code&gt; method for you. This constructor knows about the attributes you declared, so you can set them when creating a new &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;has()&lt;/code&gt; 子程序声明的属性，和 &lt;code&gt;Moose&lt;/code&gt; 自动创建这些属性访问器。它还需要为您创建一个 &lt;code&gt;new()&lt;/code&gt; 方法。该构造函数知道您声明的属性，因此可以在创建新 &lt;code&gt;File&lt;/code&gt; 时进行设置。</target>
        </trans-unit>
        <trans-unit id="5a9683174ca55dfc5709630b38ddbf4013af69ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i!&lt;/code&gt; and &lt;code&gt;I!&lt;/code&gt; codes aren't different from &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt; ; they are tolerated for completeness' sake.</source>
          <target state="translated">在 &lt;code&gt;i!&lt;/code&gt; 和 &lt;code&gt;I!&lt;/code&gt; 码不从不同 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;I&lt;/code&gt; ; 为了完整起见，我们容忍他们。</target>
        </trans-unit>
        <trans-unit id="441288d51b032bd9af407d3a9d7124153bae7480" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is incorporated in</source>
          <target state="translated">的 &lt;code&gt;id()&lt;/code&gt; 函数是在并入</target>
        </trans-unit>
        <trans-unit id="5b77bbf33fef07ab4b901464b3d1fbf57256a9cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is provided in addition to the existing &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; . Besides its short name it can be a little faster under some circumstances (and a bit slower under others). Benchmark if it matters. The working of &lt;code&gt;id()&lt;/code&gt; also allows the use of the class name as a</source>
          <target state="translated">的 &lt;code&gt;id()&lt;/code&gt; 函数是在除了现有的提供 &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; 。除了它的简称，在某些情况下它可能会快一些（在其他情况下则要慢一些）。如果重要，则进行基准测试。 &lt;code&gt;id()&lt;/code&gt; 的工作方式还允许将类名用作</target>
        </trans-unit>
        <trans-unit id="1d508e8165fd2906f6e1a4da8eddef354ad1b2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; module is used to conditionally load or unload another module. The construct</source>
          <target state="translated">所述 &lt;code&gt;if&lt;/code&gt; 模块用于有条件地加载或卸载另一个模块。构造</target>
        </trans-unit>
        <trans-unit id="4b048e8a441fb17f85efa08c37a67df6bc5d9c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is straightforward. Because BLOCKs are always bounded by curly brackets, there is never any ambiguity about which &lt;code&gt;if&lt;/code&gt; an &lt;code&gt;else&lt;/code&gt; goes with. If you use &lt;code&gt;unless&lt;/code&gt; in place of &lt;code&gt;if&lt;/code&gt; , the sense of the test is reversed. Like &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;unless&lt;/code&gt; can be followed by &lt;code&gt;else&lt;/code&gt; . &lt;code&gt;unless&lt;/code&gt; can even be followed by one or more &lt;code&gt;elsif&lt;/code&gt; statements, though you may want to think twice before using that particular language construct, as everyone reading your code will have to think at least twice before they can understand what's going on.</source>
          <target state="translated">该 &lt;code&gt;if&lt;/code&gt; 语句是直接的。由于块始终以大括号为界，因此， &lt;code&gt;if&lt;/code&gt; 使用 &lt;code&gt;else&lt;/code&gt; ，则永远不会有任何歧义。如果使用 &lt;code&gt;unless&lt;/code&gt; 代替 &lt;code&gt;if&lt;/code&gt; ，则测试的意义相反。就像 &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;unless&lt;/code&gt; 可以跟 &lt;code&gt;else&lt;/code&gt; 。 &lt;code&gt;unless&lt;/code&gt; 甚至可以跟在一个或多个 &lt;code&gt;elsif&lt;/code&gt; 语句之后，但是您可能要在使用该特定语言构造之前三思而后行，因为每个阅读您代码的人都必须至少三思而后行才能理解正在发生的事情。</target>
        </trans-unit>
        <trans-unit id="e9f3b671cb1eeb07ae7f1604035f9acb4eeee7c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ihave&lt;/code&gt; command informs the server that the client has an article whose id is &lt;code&gt;MSGID&lt;/code&gt; . If the server desires a copy of that article, and &lt;code&gt;MESSAGE&lt;/code&gt; has been given the it will be sent.</source>
          <target state="translated">该 &lt;code&gt;ihave&lt;/code&gt; 命令通知客户端有一篇文章编号为服务器 &lt;code&gt;MSGID&lt;/code&gt; 。如果服务器需要该文章的副本，并且已提供 &lt;code&gt;MESSAGE&lt;/code&gt; ，则将其发送。</target>
        </trans-unit>
        <trans-unit id="31aa9addcda21b8978ff9bf041daba569f826e41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;io&lt;/code&gt; options mean that any subsequent open() (or similar I/O operations) in the current file scope will have the &lt;code&gt;:utf8&lt;/code&gt; PerlIO layer implicitly applied to them, in other words, UTF-8 is expected from any input stream, and UTF-8 is produced to any output stream. This is just the default, with explicit layers in open() and with binmode() one can manipulate streams as usual.</source>
          <target state="translated">该 &lt;code&gt;io&lt;/code&gt; 选项意味着，在当前的文件范围内的任何后续的open（）（或类似的I / O操作）将有 &lt;code&gt;:utf8&lt;/code&gt; PerlIO的层隐式施加到它们，换句话说，UTF-8从任何输入流预期的，和UTF-8被生成到任何输出流。这只是默认设置，在open（）中有显式层，在binmode（）中可以像往常一样操纵流。</target>
        </trans-unit>
        <trans-unit id="ea8cc24a093a2a51529b8db29000183dfdfc585d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isa&lt;/code&gt; method returns</source>
          <target state="translated">该 &lt;code&gt;isa&lt;/code&gt; 方法返回</target>
        </trans-unit>
        <trans-unit id="40b75cea7c9c256a2c7f367ec1f2a28305318646" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;klen&lt;/code&gt; parameter is the length of the key being passed in (Note that you cannot pass 0 in as a value of &lt;code&gt;klen&lt;/code&gt; to tell Perl to measure the length of the key). The &lt;code&gt;val&lt;/code&gt; argument contains the SV pointer to the scalar being stored, and &lt;code&gt;hash&lt;/code&gt; is the precomputed hash value (zero if you want &lt;code&gt;hv_store&lt;/code&gt; to calculate it for you). The &lt;code&gt;lval&lt;/code&gt; parameter indicates whether this fetch is actually a part of a store operation, in which case a new undefined value will be added to the HV with the supplied key and &lt;code&gt;hv_fetch&lt;/code&gt; will return as if the value had already existed.</source>
          <target state="translated">该 &lt;code&gt;klen&lt;/code&gt; 参数键值为传入的长度（请注意，你不能为一个值传递0 &lt;code&gt;klen&lt;/code&gt; 告诉Perl来衡量密钥的长度）。该 &lt;code&gt;val&lt;/code&gt; 参数包含存储的SV指向标，而 &lt;code&gt;hash&lt;/code&gt; 是预先计算哈希值（零，如果你想 &lt;code&gt;hv_store&lt;/code&gt; 来算一下）。该 &lt;code&gt;lval&lt;/code&gt; 参数表示是否获取实际上是一个存储操作，在这种情况下，一个新的未定义的值将被添加到HV与所提供的密钥和一部分 &lt;code&gt;hv_fetch&lt;/code&gt; 将返回仿佛值已经存在。</target>
        </trans-unit>
        <trans-unit id="d1b3be6dbaf0292e629ff79d5077e6e86e950020" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line numbers&lt;/code&gt; are a comma separated list of line numbers (some preceded by code letters) where that object is used in some way. Simple uses aren't preceded by a code letter. Introductions (such as where a lexical is first defined with &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;) are indicated with the letter &quot;i&quot;. Subroutine and method calls are indicated by the character &quot;&amp;amp;&quot;. Subroutine definitions are indicated by &quot;s&quot; and format definitions by &quot;f&quot;.</source>
          <target state="translated">的 &lt;code&gt;line numbers&lt;/code&gt; 是行号（一些前面加上字母代码），其中该对象以某种方式使用的逗号分隔的列表。简单使用之前没有代码字母。简介（例如，首先使用 &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 定义词汇的地方）以字母&amp;ldquo; i&amp;rdquo;表示。子例程和方法调用由字符&amp;ldquo;＆&amp;rdquo;指示。子例程定义由&amp;ldquo; s&amp;rdquo;指示，格式定义由&amp;ldquo; f&amp;rdquo;指示。</target>
        </trans-unit>
        <trans-unit id="ed26c2274a611c42add606638c2955102446922f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_nstore&lt;/code&gt; routine are equivalent to &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;nstore&lt;/code&gt; , except that they get an exclusive lock on the file before writing. Likewise, &lt;code&gt;lock_retrieve&lt;/code&gt; does the same as &lt;code&gt;retrieve&lt;/code&gt; , but also gets a shared lock on the file before reading.</source>
          <target state="translated">该 &lt;code&gt;lock_store&lt;/code&gt; 和 &lt;code&gt;lock_nstore&lt;/code&gt; 常规相当于 &lt;code&gt;store&lt;/code&gt; 和 &lt;code&gt;nstore&lt;/code&gt; ，但他们得到的写作前的文件的独占锁定。同样， &lt;code&gt;lock_retrieve&lt;/code&gt; 的功能与 &lt;code&gt;retrieve&lt;/code&gt; 的功能相同，但在读取文件之前还获得了文件的共享锁。</target>
        </trans-unit>
        <trans-unit id="931b71dd87fea82969167ed5b3226571750cd592" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mail&lt;/code&gt; method can some additional ESMTP OPTIONS which is passed in hash like fashion, using key and value pairs. Possible options are:</source>
          <target state="translated">该 &lt;code&gt;mail&lt;/code&gt; 方法可一些附加ESMTP OPTIONS这在散列传递类似的方式，使用键和值对。可能的选项是：</target>
        </trans-unit>
        <trans-unit id="1672385883542a7bfdb246cc1c07640a71a68feb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make&lt;/code&gt; and &lt;code&gt;emake&lt;/code&gt; accept both real and complex arguments. When they cannot recognize the arguments they will die with error messages like the following</source>
          <target state="translated">在 &lt;code&gt;make&lt;/code&gt; 和 &lt;code&gt;emake&lt;/code&gt; 接受真实和复杂的参数。当他们无法识别参数时，它们将死于错误消息，如下所示</target>
        </trans-unit>
        <trans-unit id="36df2e300d21e511804bebffd14eb9e7ae60ac30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make_path&lt;/code&gt; function creates the given directories if they don't exists before, much like the Unix command &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt; -p&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;make_path&lt;/code&gt; 如果他们不存在之前，很像Unix命令函数创建指定目录 &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt; -p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="072d415ade3aa9a1737c770e2e53b08afe60d304" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match&lt;/code&gt; , &lt;code&gt;gmatch&lt;/code&gt; , &lt;code&gt;subst&lt;/code&gt; , &lt;code&gt;gsubst&lt;/code&gt; methods work like &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt;, respectively, but they are not aware of any pattern, but only a literal substring.</source>
          <target state="translated">的 &lt;code&gt;match&lt;/code&gt; ， &lt;code&gt;gmatch&lt;/code&gt; ， &lt;code&gt;subst&lt;/code&gt; ， &lt;code&gt;gsubst&lt;/code&gt; 方法工作像 &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; ，分别，但它们是不知道任何的图案，但只有一个文字串。</target>
        </trans-unit>
        <trans-unit id="ece173d4e6c78d6e5935815075ac81cc7c62a227" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;memory&lt;/code&gt; value is not an absolute or exact limit on the memory used. &lt;code&gt;Tie::File&lt;/code&gt; objects contains some structures besides the read cache and the deferred write buffer, whose sizes are not charged against &lt;code&gt;memory&lt;/code&gt; .</source>
          <target state="translated">所述 &lt;code&gt;memory&lt;/code&gt; 值是不使用的存储器中的绝对或完全限制。 &lt;code&gt;Tie::File&lt;/code&gt; 对象除了读取缓存和延迟的写入缓冲区之外，还包含其他一些结构，这些结构的大小不计入 &lt;code&gt;memory&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19d121e9a361d9d72576c01fa16affeece8189c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mg_virtual&lt;/code&gt; field in the &lt;code&gt;MAGIC&lt;/code&gt; structure is a pointer to an &lt;code&gt;MGVTBL&lt;/code&gt; , which is a structure of function pointers and stands for &quot;Magic Virtual Table&quot; to handle the various operations that might be applied to that variable.</source>
          <target state="translated">&lt;code&gt;MAGIC&lt;/code&gt; 结构中的 &lt;code&gt;mg_virtual&lt;/code&gt; 字段是指向 &lt;code&gt;MGVTBL&lt;/code&gt; 的指针，MGVTBL是函数指针的结构，代表&amp;ldquo; Magic Virtual Table&amp;rdquo;来处理可能应用于该变量的各种操作。</target>
        </trans-unit>
        <trans-unit id="a5023c90eb5f90ef422233e2dd5d44f7824eab24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; related one will be matched against</source>
          <target state="translated">与之相关的 &lt;code&gt;module&lt;/code&gt; 将与之匹配</target>
        </trans-unit>
        <trans-unit id="47efd6577f009e8c4308e174f5b14a11ddfaec14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;move&lt;/code&gt; function also takes two parameters: the current name and the intended name of the file to be moved. If the destination already exists and is a directory, and the source is not a directory, then the source file will be renamed into the directory specified by the destination.</source>
          <target state="translated">该 &lt;code&gt;move&lt;/code&gt; 功能也有两个参数：要移动的当前名称和文件的预期的名称。如果目标已经存在并且是目录，而源不是目录，那么源文件将重命名为目标指定的目录。</target>
        </trans-unit>
        <trans-unit id="82300ffe8ea8c4a83935f63ac88aba05d079a68e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;namlen&lt;/code&gt; arguments are used to associate a string with the magic, typically the name of a variable. &lt;code&gt;namlen&lt;/code&gt; is stored in the &lt;code&gt;mg_len&lt;/code&gt; field and if &lt;code&gt;name&lt;/code&gt; is non-null then either a &lt;code&gt;savepvn&lt;/code&gt; copy of &lt;code&gt;name&lt;/code&gt; or &lt;code&gt;name&lt;/code&gt; itself is stored in the &lt;code&gt;mg_ptr&lt;/code&gt; field, depending on whether &lt;code&gt;namlen&lt;/code&gt; is greater than zero or equal to zero respectively. As a special case, if &lt;code&gt;(name &amp;amp;&amp;amp; namlen == HEf_SVKEY)&lt;/code&gt; then &lt;code&gt;name&lt;/code&gt; is assumed to contain an &lt;code&gt;SV*&lt;/code&gt; and is stored as-is with its REFCNT incremented.</source>
          <target state="translated">该 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;namlen&lt;/code&gt; 参数用于字符串与魔法，一个变量的典型的名字联系在一起。 &lt;code&gt;namlen&lt;/code&gt; 被存储在 &lt;code&gt;mg_len&lt;/code&gt; 字段，如果 &lt;code&gt;name&lt;/code&gt; 是非空然后是一个 &lt;code&gt;savepvn&lt;/code&gt; 的副本 &lt;code&gt;name&lt;/code&gt; 或 &lt;code&gt;name&lt;/code&gt; 本身被存储在 &lt;code&gt;mg_ptr&lt;/code&gt; 字段，这取决于是否 &lt;code&gt;namlen&lt;/code&gt; 是大于零或分别等于零。作为一种特殊情况，如果 &lt;code&gt;(name &amp;amp;&amp;amp; namlen == HEf_SVKEY)&lt;/code&gt; 则假定 &lt;code&gt;name&lt;/code&gt; 包含 &lt;code&gt;SV*&lt;/code&gt; ，并按原样存储，其REFCNT递增。</target>
        </trans-unit>
        <trans-unit id="30007f38d6317a12ba00ec6e0a7e1a8a5a903fc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; will also understand a single (string) argument of the forms</source>
          <target state="translated">在 &lt;code&gt;new&lt;/code&gt; ， &lt;code&gt;make&lt;/code&gt; ， &lt;code&gt;emake&lt;/code&gt; ， &lt;code&gt;cplx&lt;/code&gt; ，和 &lt;code&gt;cplxe&lt;/code&gt; 也会理解的形式单一（字符串）参数</target>
        </trans-unit>
        <trans-unit id="ed69370147fad222f299ba19e375b2bf7b98be5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; will also understand the case of no arguments: this means plain zero or (0, 0).</source>
          <target state="translated">在 &lt;code&gt;new&lt;/code&gt; ， &lt;code&gt;make&lt;/code&gt; ， &lt;code&gt;emake&lt;/code&gt; ， &lt;code&gt;cplx&lt;/code&gt; ，和 &lt;code&gt;cplxe&lt;/code&gt; 也会理解的不带参数的情况：这意味着普通零或（0，0）。</target>
        </trans-unit>
        <trans-unit id="99af811bc283e732950a12fee28684ae132d20bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; method returns a collator object. If new() is called with no parameters, the collator should do the default collation.</source>
          <target state="translated">该 &lt;code&gt;new&lt;/code&gt; 方法返回一个Collat​​or对象。如果没有参数调用new（），则整理器应执行默认整理。</target>
        </trans-unit>
        <trans-unit id="ebe7378b188460d4f95907a0bf8fffd8170aa799" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nntpstat&lt;/code&gt; command is similar to the &lt;code&gt;article&lt;/code&gt; command except that no text is returned. When selecting by message number within a group, the &lt;code&gt;nntpstat&lt;/code&gt; command serves to set the &quot;current article pointer&quot; without sending text.</source>
          <target state="translated">该 &lt;code&gt;nntpstat&lt;/code&gt; 命令是类似的 &lt;code&gt;article&lt;/code&gt; ，除了没有文本返回指令。当按组中的消息号进行选择时， &lt;code&gt;nntpstat&lt;/code&gt; 命令用于设置&amp;ldquo;当前文章指针&amp;rdquo;而不发送文本。</target>
        </trans-unit>
        <trans-unit id="9a9f846f976939c6373f157aacddb5340df46521" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;notest&lt;/code&gt; pragma skips the test part in the build process.</source>
          <target state="translated">最重要的 &lt;code&gt;notest&lt;/code&gt; 在构建过程中跳过测试部分。</target>
        </trans-unit>
        <trans-unit id="402cbf532fb5078e8455cec160e9e8dbd08504b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nvsize&lt;/code&gt; element is only present for file format v2.2 and higher.</source>
          <target state="translated">所述 &lt;code&gt;nvsize&lt;/code&gt; 元件只存在于文件格式V2.2和更高。</target>
        </trans-unit>
        <trans-unit id="c6ccaa6545aa4fe6352eb7229eabe18e5414aa4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o conf&lt;/code&gt; command has various bells and whistles:</source>
          <target state="translated">该 &lt;code&gt;o conf&lt;/code&gt; 命令具有各种花里胡哨：</target>
        </trans-unit>
        <trans-unit id="e1d6fb5846e3f0194a9a7d71677ca6c483145c33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o?&lt;/code&gt; matches at the beginning of &lt;code&gt;'foo'&lt;/code&gt; , and since the position in the string is not moved by the match, &lt;code&gt;o?&lt;/code&gt; would match again and again because of the &lt;code&gt;*&lt;/code&gt; quantifier. Another common way to create a similar cycle is with the looping modifier &lt;code&gt;//g&lt;/code&gt; :</source>
          <target state="translated">该 &lt;code&gt;o?&lt;/code&gt; 在 &lt;code&gt;'foo'&lt;/code&gt; 的开头匹配，并且由于字符串不被匹配移动，所以 &lt;code&gt;o?&lt;/code&gt; 会因 &lt;code&gt;*&lt;/code&gt; 量词而一次又一次地匹配。创建类似循环的另一种常见方法是使用循环修饰符 &lt;code&gt;//g&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8add6c5a9ee20cf8238a46e09a0cd46fe0b061c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; argument is stored in the &lt;code&gt;mg_obj&lt;/code&gt; field of the &lt;code&gt;MAGIC&lt;/code&gt; structure. If it is not the same as the &lt;code&gt;sv&lt;/code&gt; argument, the reference count of the &lt;code&gt;obj&lt;/code&gt; object is incremented. If it is the same, or if the &lt;code&gt;how&lt;/code&gt; argument is &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt; , or if it is a NULL pointer, then &lt;code&gt;obj&lt;/code&gt; is merely stored, without the reference count being incremented.</source>
          <target state="translated">所述 &lt;code&gt;obj&lt;/code&gt; 参数被存储在 &lt;code&gt;mg_obj&lt;/code&gt; 所述的场 &lt;code&gt;MAGIC&lt;/code&gt; 结构。如果与 &lt;code&gt;sv&lt;/code&gt; 参数不同，则 &lt;code&gt;obj&lt;/code&gt; 对象的引用计数增加。如果相同，或者 &lt;code&gt;how&lt;/code&gt; 参数为 &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt; ，或者为NULL指针，则仅存储 &lt;code&gt;obj&lt;/code&gt; ，而不会增加引用计数。</target>
        </trans-unit>
        <trans-unit id="d80e9ad5ac5b4640a379da6ded2e4e7da8ef85d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op-entry&lt;/code&gt; , &lt;code&gt;loading-file&lt;/code&gt; , and &lt;code&gt;loaded-file&lt;/code&gt; probes were added.</source>
          <target state="translated">添加了 &lt;code&gt;op-entry&lt;/code&gt; ， &lt;code&gt;loading-file&lt;/code&gt; 和 &lt;code&gt;loaded-file&lt;/code&gt; 探针。</target>
        </trans-unit>
        <trans-unit id="2f6e73c286e870319f1bf5046f6a37ff92d8c6ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overloading&lt;/code&gt; pragma can be used to enable or disable overloaded operations within a lexical scope - see &lt;a href=&quot;overloading&quot;&gt;overloading&lt;/a&gt;.</source>
          <target state="translated">所述 &lt;code&gt;overloading&lt;/code&gt; 编译指示可用于使能或词法范围内禁用重载的操作-参见&lt;a href=&quot;overloading&quot;&gt;超载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22d5bf30a5d50f38a10cfc2d7578244917da917c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="translated">该 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt; 格式应小心使用。由于Perl无法检查传递给 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 的值是否对应于有效的内存位置，因此传递未知有效的指针值可能会造成灾难性的后果。</target>
        </trans-unit>
        <trans-unit id="edad35170db1a049ca495222b3c0b5b8c415db1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="translated">该 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt; 格式应小心使用。由于Perl无法检查传递给 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 的值是否对应于有效的内存位置，因此传递未知有效的指针值可能会造成灾难性的后果。</target>
        </trans-unit>
        <trans-unit id="a342dbe90eb2666a6875f71f1fa1cb3e6e7241a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;; similarly with unpack(), where a null pointer unpacks into &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;p&lt;/code&gt; 格式包的指针，空终止字符串。您有责任确保该字符串不是临时值，因为在使用打包结果之前，该字符串可能会被释放。的 &lt;code&gt;P&lt;/code&gt; 格式包的指针由长度表示的大小的结构。如果 &lt;code&gt;p&lt;/code&gt; 或 &lt;code&gt;P&lt;/code&gt; 的对应值是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则创建一个空指针；与unpack（）类似，其中null指针将解压缩为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2e0e3d979b5c34967b7ced67a74a5510cb236cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;; similarly with unpack(), where a null pointer unpacks into &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;p&lt;/code&gt; 格式包的指针，空终止字符串。您有责任确保该字符串不是临时值，因为在使用打包结果之前，该字符串可能会被释放。的 &lt;code&gt;P&lt;/code&gt; 格式包的指针由长度表示的大小的结构。如果 &lt;code&gt;p&lt;/code&gt; 或 &lt;code&gt;P&lt;/code&gt; 的对应值是 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则创建一个空指针；与unpack（）类似，其中null指针将解压缩为 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cd57772719120a4cc44e7170b8984f064c5142a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;paren&lt;/code&gt; parameter will be &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; for &lt;code&gt;$2&lt;/code&gt; and so forth, and have these symbolic values for the special variables:</source>
          <target state="translated">在 &lt;code&gt;paren&lt;/code&gt; 参数将是 &lt;code&gt;1&lt;/code&gt; 为 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; 为 &lt;code&gt;$2&lt;/code&gt; 等等，并有特殊的变量，这些符号值：</target>
        </trans-unit>
        <trans-unit id="49927bc872809a6862bb2b73a995c90fcc3d0b9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; parameter is the scalar that was used as the pattern. Previous versions of Perl would pass two &lt;code&gt;char*&lt;/code&gt; indicating the start and end of the stringified pattern; the following snippet can be used to get the old parameters:</source>
          <target state="translated">的 &lt;code&gt;pattern&lt;/code&gt; 参数是用作图案的标量。以前的Perl版本会传递两个 &lt;code&gt;char*&lt;/code&gt; 指示字符串化模式的开始和结束；以下代码段可用于获取旧参数：</target>
        </trans-unit>
        <trans-unit id="db17bf3bf687b24a2fdb5945dac7eff0732c46a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perl&lt;/code&gt; related one will be matched against &lt;code&gt;$^X&lt;/code&gt; (but with the absolute path).</source>
          <target state="translated">与 &lt;code&gt;perl&lt;/code&gt; 相关的将与 &lt;code&gt;$^X&lt;/code&gt; 匹配（但具有绝对路径）。</target>
        </trans-unit>
        <trans-unit id="5f5ee6756d1fcb64032b91cf7b890baca1e81e1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perl_alloc&lt;/code&gt; and &lt;code&gt;perl_clone&lt;/code&gt; API functions will automatically set the TLS slot to the interpreter they created, so that there is no need to do anything special if the interpreter is always accessed in the same thread that created it, and that thread did not create or call any other interpreters afterwards. If that is not the case, you have to set the TLS slot of the thread before calling any functions in the Perl API on that particular interpreter. This is done by calling the &lt;code&gt;PERL_SET_CONTEXT&lt;/code&gt; macro in that thread as the first thing you do:</source>
          <target state="translated">该 &lt;code&gt;perl_alloc&lt;/code&gt; 和 &lt;code&gt;perl_clone&lt;/code&gt; API函数将自动设置TLS插槽，他们创造了解释，所以没有必要做什么特别的事情，如果解释在创建它的同一线程总是访问，而这些线程没有创造或致电之后再有其他口译员。如果不是这种情况，则必须在该特定解释程序上调用Perl API中的任何函数之前，设置线程的TLS插槽。这是通过 &lt;code&gt;PERL_SET_CONTEXT&lt;/code&gt; 在该线程中调用PERL_SET_CONTEXT宏来完成的：</target>
        </trans-unit>
        <trans-unit id="97a02a3c258cf1103ffa6170e07625f674c4d40e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perldoc&lt;/code&gt; command line tool is part of the standard Perl distribution. To read the perlfaq:</source>
          <target state="translated">所述 &lt;code&gt;perldoc&lt;/code&gt; 命令行工具是标准的Perl分布的一部分。要阅读perlfaq：</target>
        </trans-unit>
        <trans-unit id="50ad124de63dc48f75c0f2545fa281fab8aa3db8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phase-change&lt;/code&gt; probe was added.</source>
          <target state="translated">该 &lt;code&gt;phase-change&lt;/code&gt; 添加探头。</target>
        </trans-unit>
        <trans-unit id="04bb003d93ac0037aab6a2f453c58a6ac0c41912" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;plugin_list&lt;/code&gt; configuration parameter holds a list of strings of the form</source>
          <target state="translated">该 &lt;code&gt;plugin_list&lt;/code&gt; 配置参数保存形式的字符串列表</target>
        </trans-unit>
        <trans-unit id="a63eacc1cc33a9d0218e84fb4e04a60cb849a989" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pp_tie&lt;/code&gt; does a &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; , then starts a second runops loop to execute the body of &lt;code&gt;TIEARRAY&lt;/code&gt; . When it executes the entertry op on line 3, &lt;code&gt;CATCH_GET&lt;/code&gt; is true, so &lt;code&gt;pp_entertry&lt;/code&gt; calls &lt;code&gt;docatch&lt;/code&gt; which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and starts a third runops loop, which then executes the die op. At this point the C call stack looks like this:</source>
          <target state="translated">所述 &lt;code&gt;pp_tie&lt;/code&gt; 做了 &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; ，那么开始第二runops循环执行的主体 &lt;code&gt;TIEARRAY&lt;/code&gt; 。当它在第3行执行Entertry op时， &lt;code&gt;CATCH_GET&lt;/code&gt; 为true，因此 &lt;code&gt;pp_entertry&lt;/code&gt; 调用 &lt;code&gt;docatch&lt;/code&gt; ，它执行 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 并启动第三个runops循环，然后执行die op。此时，C调用堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="6f6012284b93fc2045dcbcea769da43a4a9d853f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prompt()&lt;/code&gt; function provides an easy way to request user input used to write a makefile. It displays the $message as a prompt for input. If a $default is provided it will be used as a default. The function returns the $value selected by the user.</source>
          <target state="translated">的 &lt;code&gt;prompt()&lt;/code&gt; 函数提供了一种简单的方法来用于写入生成文件请求用户输入。它显示$ message作为输入提示。如果提供了$ default，它将用作默认值。该函数返回用户选择的$ value。</target>
        </trans-unit>
        <trans-unit id="251a318ac7ae399ceb208b84bc39666205a2a077" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module encapsulates the results for a single test suite run.</source>
          <target state="translated">该 &lt;code&gt;prove&lt;/code&gt; 命令支持 &lt;code&gt;--state&lt;/code&gt; 指示它来存储整个运行持续状态的选择。该模块封装了单个测试套件运行的结果。</target>
        </trans-unit>
        <trans-unit id="225b0b123ca124089a53e65a14a10e06fffd421b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module encapsulates the results for a single test.</source>
          <target state="translated">该 &lt;code&gt;prove&lt;/code&gt; 命令支持 &lt;code&gt;--state&lt;/code&gt; 指示它来存储整个运行持续状态的选择。该模块封装了单个测试的结果。</target>
        </trans-unit>
        <trans-unit id="630214733172c835a26947747354eba32ad3911c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module implements that state and the operations that may be performed on it.</source>
          <target state="translated">该 &lt;code&gt;prove&lt;/code&gt; 命令支持 &lt;code&gt;--state&lt;/code&gt; 指示它来存储整个运行持续状态的选择。该模块实现该状态以及可以在其上执行的操作。</target>
        </trans-unit>
        <trans-unit id="16ee1aae608f6953af89e472ae38b6d9068b7d8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;re '/flags'&lt;/code&gt; pragma (introduced in Perl 5.14) turns on the given regular expression flags until the end of the lexical scope. See &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;'/flags' mode in re&lt;/a&gt; for more detail.</source>
          <target state="translated">所述 &lt;code&gt;re '/flags'&lt;/code&gt; 编译指示（在Perl 5.14引入）接通给定正则表达式标志直到词法作用域的末尾。有关更多详细信息，请参见&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;re中的&amp;ldquo; / flags&amp;rdquo;模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eabbdc8a005d2bf3f21650b9e863366189c7ced7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recent&lt;/code&gt; command downloads a list of recent uploads to CPAN and displays them</source>
          <target state="translated">在 &lt;code&gt;recent&lt;/code&gt; 命令下载最近上传到CPAN并显示它们的列表</target>
        </trans-unit>
        <trans-unit id="3ae27e036bb44d621cb68002f9a110e07c700371" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recipient&lt;/code&gt; method can also pass additional case-sensitive OPTIONS as an anonymous hash using key and value pairs. Possible options are:</source>
          <target state="translated">的 &lt;code&gt;recipient&lt;/code&gt; 方法还可以通过使用键和值的对附加区分大小写选项作为匿名散列。可能的选项是：</target>
        </trans-unit>
        <trans-unit id="5f6b672315250ddc806f0b1d734bf40a266a6de9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is common to all regex engines. Two of its fields are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and pprivate members. The &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values. In the case of the stock engine the structure pointed to by &lt;code&gt;pprivate&lt;/code&gt; is called &lt;code&gt;regexp_internal&lt;/code&gt; .</source>
          <target state="translated">&lt;a href=&quot;perlreapi&quot;&gt;perlreapi中&lt;/a&gt;描述的 &lt;code&gt;regexp&lt;/code&gt; 结构对所有regex引擎都是通用的。它的两个字段供编译该模式的正则表达式引擎专用。这些是 &lt;code&gt;intflags&lt;/code&gt; 和私有成员。该 &lt;code&gt;pprivate&lt;/code&gt; 是一个空指针到任意的结构，其使用和管理是编译引擎的责任。 perl永远不会修改这些值中的任何一个。在股票引擎的情况下， &lt;code&gt;pprivate&lt;/code&gt; 指向的结构称为 &lt;code&gt;regexp_internal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2292ba9ae057df1902ceef2446c66c533b62b3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remove_tree&lt;/code&gt; function deletes the given directories and any files and subdirectories they might contain, much like the Unix command &lt;code&gt;rm -r&lt;/code&gt; or &lt;code&gt;del /s&lt;/code&gt; on Windows.</source>
          <target state="translated">该 &lt;code&gt;remove_tree&lt;/code&gt; 函数删除指定的目录和它们可能包含任何文件和子目录，就像Unix命令 &lt;code&gt;rm -r&lt;/code&gt; 或 &lt;code&gt;del /s&lt;/code&gt; Windows上。</target>
        </trans-unit>
        <trans-unit id="f800b61fba3cbdc9dbaf2d3127156f3c10c2be33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;report&lt;/code&gt; command temporarily turns on the &lt;code&gt;test_report&lt;/code&gt; config variable, then runs the &lt;code&gt;force test&lt;/code&gt; command with the given arguments. The &lt;code&gt;force&lt;/code&gt; pragma reruns the tests and repeats every step that might have failed before.</source>
          <target state="translated">该 &lt;code&gt;report&lt;/code&gt; 命令暂时打开了 &lt;code&gt;test_report&lt;/code&gt; 配置变量，然后运行 &lt;code&gt;force test&lt;/code&gt; 与给定的参数命令。该 &lt;code&gt;force&lt;/code&gt; 编译重新运行测试，并重复每一个可能之前已经失败的步骤。</target>
        </trans-unit>
        <trans-unit id="bb965f28ada4d369f813e7b58370f45663a7e17c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;requires&lt;/code&gt; and &lt;code&gt;build_requires&lt;/code&gt; dependency declarations</source>
          <target state="translated">的 &lt;code&gt;requires&lt;/code&gt; 和 &lt;code&gt;build_requires&lt;/code&gt; 依赖声明</target>
        </trans-unit>
        <trans-unit id="6825adde139cbe709d6cacc6c4ea55d8ef7cff02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;resolve&lt;/code&gt; function is called to generate a linearised ISA for the given stash, using this MRO. It is called with a pointer to the stash, and a</source>
          <target state="translated">该 &lt;code&gt;resolve&lt;/code&gt; 函数被调用，生成针对给定的藏匿一个线性化ISA，使用这种MRO。它被称为带有隐藏的指针，并且</target>
        </trans-unit>
        <trans-unit id="0e85b7e6554a08b089b5049ccd1a608787302c15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result_factory_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;result_factory_class&lt;/code&gt; 可定制，如在&lt;a href=&quot;#new&quot;&gt;新的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6451f829e84fc9b2a12b294243486a8357dccdcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;roffitall&lt;/code&gt; utility is not installed on your system but lives in the</source>
          <target state="translated">该 &lt;code&gt;roffitall&lt;/code&gt; 实用程序未安装在系统上，但居住在</target>
        </trans-unit>
        <trans-unit id="9411561fa33dd9a0d96df4e7b49fae524226bee1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip(...)&lt;/code&gt; function is for tests that might or might not be possible to run, depending on the availability of platform-specific features. The first argument should evaluate to true (think &quot;yes, please skip&quot;) if the required feature is</source>
          <target state="translated">将 &lt;code&gt;skip(...)&lt;/code&gt; 功能是对可能或可能无法运行测试，取决于特定平台功能的可用性。如果所需的功能是，则第一个参数的计算结果应为true（认为&amp;ldquo;是，请跳过&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="4dd34dc5f337a99adbdb95ed69eaa2b33a678e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;smoke&lt;/code&gt; command takes the list of recent uploads to CPAN as provided by the &lt;code&gt;recent&lt;/code&gt; command and tests them all. While the command is running $SIG{INT} is defined to mean that the current item shall be skipped.</source>
          <target state="translated">该 &lt;code&gt;smoke&lt;/code&gt; 命令将最近上传到CPAN的列表，通过所提供的 &lt;code&gt;recent&lt;/code&gt; 的命令，并测试其所有。当命令运行时，$ SIG {INT}被定义为表示将跳过当前项目。</target>
        </trans-unit>
        <trans-unit id="c81eca2265a8bfa89f7e2b8216b25f7468527582" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;socktype&lt;/code&gt; hint to getaddrinfo() filters the results to only include one socket type and protocol. Without this most OSes return three combinations, for &lt;code&gt;SOCK_STREAM&lt;/code&gt; , &lt;code&gt;SOCK_DGRAM&lt;/code&gt; and &lt;code&gt;SOCK_RAW&lt;/code&gt; , resulting in triplicate output of addresses. The &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; flag to getnameinfo() causes it to return a string-formatted plain IP address, rather than reverse resolving it back into a hostname.</source>
          <target state="translated">getaddrinfo（）的 &lt;code&gt;socktype&lt;/code&gt; 提示会过滤结果，使其仅包含一种套接字类型和协议。没有这些操作系统，大多数OS将返回 &lt;code&gt;SOCK_STREAM&lt;/code&gt; ， &lt;code&gt;SOCK_DGRAM&lt;/code&gt; 和 &lt;code&gt;SOCK_RAW&lt;/code&gt; 的三种组合，从而导致地址输出一式三份。getnameinfo（）的 &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; 标志使它返回字符串格式的纯IP地址，而不是将其反向解析为主机名。</target>
        </trans-unit>
        <trans-unit id="8fb1bd48c372b36b030a4985fb7d0b8ecfff9314" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;source&lt;/code&gt; is used to create a &lt;a href=&quot;parser/source&quot;&gt;TAP::Parser::Source&lt;/a&gt; that is passed to the &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt; which in turn figures out how to handle the source and creates a &amp;lt;TAP::Parser::Iterator&amp;gt; for it. The iterator is used by the parser to read in the TAP stream.</source>
          <target state="translated">该 &lt;code&gt;source&lt;/code&gt; 用于创建&lt;a href=&quot;parser/source&quot;&gt;TAP :: Parser :: Source&lt;/a&gt;，该消息传递给&lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt;，后者进而找出如何处理源代码并为其创建&amp;lt;TAP :: Parser :: Iterator&amp;gt;。解析器使用迭代器来读取TAP流。</target>
        </trans-unit>
        <trans-unit id="92eb80578e9c5fa00cf858e0d3634beaaf8da658" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sources&lt;/code&gt; parameter affects how &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; parameters are handled.</source>
          <target state="translated">在 &lt;code&gt;sources&lt;/code&gt; 参数将影响 &lt;code&gt;source&lt;/code&gt; ， &lt;code&gt;tap&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 参数进行处理。</target>
        </trans-unit>
        <trans-unit id="027d4af5bb9710fddfec7b10292492a3bd8321cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict&lt;/code&gt; pragma is useful in avoiding such errors.</source>
          <target state="translated">在 &lt;code&gt;strict&lt;/code&gt; 附注为避免这样的错误非常有用。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
