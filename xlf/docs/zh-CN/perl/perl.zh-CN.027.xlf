<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="d95c8bef773580433166be7c2c32b85e8e849e6f" translate="yes" xml:space="preserve">
          <source>If a 2-digit code is entered, it is converted to 3 digits by prepending a 0.</source>
          <target state="translated">如果输入的是2位数的代码,则会在前面加上0,转换为3位数。</target>
        </trans-unit>
        <trans-unit id="e64a7d7369be70b0218a1b95be79c2c2deb28c1d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; is used in a context that is looking for a list, a list comprising all input lines is returned, one line per list element. It's easy to grow to a rather large data space this way, so use with care.</source>
          <target state="translated">如果在正在查找列表的上下文中使用 &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; ，则返回包含所有输入行的列表，每个列表元素一行。这样很容易扩展到相当大的数据空间，因此请谨慎使用。</target>
        </trans-unit>
        <trans-unit id="259cdf2dd383c0f84fbe2ca3b6aceeeeaeccb785" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can find a &lt;code&gt;CxEVAL&lt;/code&gt; block on the context stack, then the stack is popped to that level and the return op in that block is assigned to &lt;code&gt;PL_restartop&lt;/code&gt; ; then a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; is performed. This normally passes control back to the guard. In the case of &lt;code&gt;perl_run&lt;/code&gt; and &lt;code&gt;call_sv&lt;/code&gt; , a non-null &lt;code&gt;PL_restartop&lt;/code&gt; triggers re-entry to the runops loop. The is the normal way that &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; is handled within an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 可以在上下文堆栈中找到 &lt;code&gt;CxEVAL&lt;/code&gt; 块，则将堆栈弹出到该级别，并将该块中的返回操作分配给 &lt;code&gt;PL_restartop&lt;/code&gt; ；然后执行 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 。通常，这会将控制权交还给警卫队。在 &lt;code&gt;perl_run&lt;/code&gt; 和 &lt;code&gt;call_sv&lt;/code&gt; 的情况下，非null的 &lt;code&gt;PL_restartop&lt;/code&gt; 触发重新进入runops循环。这是在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中处理 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;croak&lt;/code&gt; 的正常方法。</target>
        </trans-unit>
        <trans-unit id="2e842b426c14ec5c17e64ac341313bcce514b5ce" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), the case map used by &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , and &lt;code&gt;\U&lt;/code&gt; is taken from the current locale. If Unicode (for example, &lt;code&gt;\N{}&lt;/code&gt; or code points of 0x100 or beyond) is being used, the case map used by &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , and &lt;code&gt;\U&lt;/code&gt; is as defined by Unicode. That means that case-mapping a single character can sometimes produce a sequence of several characters. Under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , &lt;code&gt;\F&lt;/code&gt; produces the same results as &lt;code&gt;\L&lt;/code&gt; for all locales but a UTF-8 one, where it instead uses the Unicode definition.</source>
          <target state="translated">如果包含 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 形式有效（请参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;），则 &lt;code&gt;\l&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; 和 &lt;code&gt;\U&lt;/code&gt; 所使用的大小写映射是从当前语言环境获取的。如果使用Unicode（例如 &lt;code&gt;\N{}&lt;/code&gt; 或0x100或更高的代码点），则 &lt;code&gt;\l&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; 和 &lt;code&gt;\U&lt;/code&gt; 使用的大小写映射由Unicode定义。这意味着对单个字符进行大小写映射有时会产生多个字符的序列。在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 语言环境下， &lt;code&gt;\F&lt;/code&gt; 产生的结果与 &lt;code&gt;\L&lt;/code&gt; 用于除UTF-8之外的所有语言环境，它使用Unicode定义。</target>
        </trans-unit>
        <trans-unit id="549e5fcf45cf7944f8141812970bb7a27ad11345" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Net::POP3&lt;/code&gt; object goes out of scope before &lt;code&gt;quit&lt;/code&gt; method is called then the &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; method will called before the connection is closed. This means that any messages marked to be deleted will not be.</source>
          <target state="translated">如果在调用 &lt;code&gt;quit&lt;/code&gt; 方法之前 &lt;code&gt;Net::POP3&lt;/code&gt; 对象超出范围，则在关闭连接之前将调用 &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; 方法。这意味着任何标记为要删除的消息都不会。</target>
        </trans-unit>
        <trans-unit id="043d74f31a25532198b1527d3ae5c4b1da9715ef" translate="yes" xml:space="preserve">
          <source>If a CODE reference is not used, a</source>
          <target state="translated">如果没有使用CODE参考,则会出现</target>
        </trans-unit>
        <trans-unit id="e12066458359083bdcf249636aa07df8a14816c7" translate="yes" xml:space="preserve">
          <source>If a CODE reference is used then a</source>
          <target state="translated">如果使用CODE参考,那么</target>
        </trans-unit>
        <trans-unit id="f9ad0abaf0eff45a492a44f419b412cf87f4dd03" translate="yes" xml:space="preserve">
          <source>If a FILEHANDLE is supplied, it must be writable and opened in append mode (i.e., use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FH, '&amp;gt;&amp;gt;filename')&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen(FH,...,O_APPEND|O_RDWR)&lt;/a&gt;&lt;/code&gt;. If a filename is supplied, it should not be held open elsewhere. (Win32)</source>
          <target state="translated">如果提供了FILEHANDLE，则它必须是可写的，并且必须以附加模式 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FH, '&amp;gt;&amp;gt;filename')&lt;/code&gt; （即，使用open（FH，'&amp;gt;&amp;gt; filename'）或 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen(FH,...,O_APPEND|O_RDWR)&lt;/a&gt;&lt;/code&gt; 。不应在其他地方打开（Win​​32）</target>
        </trans-unit>
        <trans-unit id="3af3f41934dd0fe8f979cc12d4f4c701b5fb0dcf" translate="yes" xml:space="preserve">
          <source>If a Pod processor sees any command other than the ones listed above (like &quot;=head&quot;, or &quot;=haed1&quot;, or &quot;=stuff&quot;, or &quot;=cuttlefish&quot;, or &quot;=w123&quot;), that processor must by default treat this as an error. It must not process the paragraph beginning with that command, must by default warn of this as an error, and may abort the parse. A Pod parser may allow a way for particular applications to add to the above list of known commands, and to stipulate, for each additional command, whether formatting codes should be processed.</source>
          <target state="translated">如果一个花苞处理器看到上面列出的命令以外的任何命令(如&quot;=head&quot;,或&quot;=haed1&quot;,或&quot;=stuff&quot;,或&quot;=cuttlefish&quot;,或&quot;=w123&quot;),该处理器必须默认将其视为一个错误。它必须不处理以该命令开始的段落,默认情况下必须警告这是一个错误,并可能中止解析。Pod解析器可以允许特定的应用程序添加到上述已知命令列表中,并为每个附加命令规定是否应该处理格式代码。</target>
        </trans-unit>
        <trans-unit id="84d7b60c1fec814496b3c4bc1816a8d5d03c5699" translate="yes" xml:space="preserve">
          <source>If a Pod processor sees any formatting code other than the ones listed above (as in &quot;N&amp;lt;...&amp;gt;&quot;, or &quot;Q&amp;lt;...&amp;gt;&quot;, etc.), that processor must by default treat this as an error. A Pod parser may allow a way for particular applications to add to the above list of known formatting codes; a Pod parser might even allow a way to stipulate, for each additional command, whether it requires some form of special processing, as L&amp;lt;...&amp;gt; does.</source>
          <target state="translated">如果Pod处理器看到除上面列出的格式代码之外的任何其他格式代码（如&amp;ldquo; N &amp;lt;...&amp;gt;&amp;rdquo;或&amp;ldquo; Q &amp;lt;...&amp;gt;&amp;rdquo;等），则该处理器必须默认将其视为错误。 。Pod解析器可能允许特定应用程序添加到上面的已知格式代码列表中；Pod解析器甚至可以允许为每个附加命令规定是否需要某种形式的特殊处理，如L &amp;lt;...&amp;gt;那样。</target>
        </trans-unit>
        <trans-unit id="a69d2c6e5370a359253a714b367c144cea0b32a3" translate="yes" xml:space="preserve">
          <source>If a SKIP directive is included with the plan, this method will return it.</source>
          <target state="translated">如果计划中包含SKIP指令,本方法将返回该指令。</target>
        </trans-unit>
        <trans-unit id="fc36fbb42452cd08e5fbc977b40571fcb5ba6163" translate="yes" xml:space="preserve">
          <source>If a SKIP directive was included with the plan, this method will return the explanation, if any.</source>
          <target state="translated">如果计划中包含SKIP指令,本方法将返回解释(如果有)。</target>
        </trans-unit>
        <trans-unit id="21c8d4e7e9fdf0b61712f2ee7b9d5069189ec21c" translate="yes" xml:space="preserve">
          <source>If a TODO test does succeed, then the feature in question shouldn't be on the TODO list, now should it?</source>
          <target state="translated">如果TODO测试确实成功了,那么相关功能就不应该出现在TODO列表中了,现在应该是这样吧?</target>
        </trans-unit>
        <trans-unit id="5bc13fa8b4104f174148a214dadae282567de13a" translate="yes" xml:space="preserve">
          <source>If a character that isn't an octal digit is encountered, a warning is raised, and the value is based on the octal digits before it, discarding it and all following characters up to the closing brace. It is a fatal error if there are no octal digits at all.</source>
          <target state="translated">如果遇到一个不是八位数的字符,就会发出警告,并根据它前面的八位数来计算值,丢弃它和后面的所有字符,直到最后的括号。如果根本没有八位数,则是一个致命的错误。</target>
        </trans-unit>
        <trans-unit id="22ce7778730981e7a416c117aaec163fa0497dba" translate="yes" xml:space="preserve">
          <source>If a check for non-empty is what you wanted then just put it in boolean context (see &lt;a href=&quot;perldata#Scalar-values&quot;&gt;Scalar values in perldata&lt;/a&gt;):</source>
          <target state="translated">如果要检查非空&lt;a href=&quot;perldata#Scalar-values&quot;&gt;值，则将&lt;/a&gt;其放在布尔上下文中（请参阅perldata中的标量值）：</target>
        </trans-unit>
        <trans-unit id="7bbe66a04a030c6e054fb0dfd4a30c2a7ed6df30" translate="yes" xml:space="preserve">
          <source>If a child calls &quot;skip_all&quot; in the plan, a &lt;code&gt;Test::Builder::Exception&lt;/code&gt; is thrown. Trap this error, call &lt;code&gt;finalize()&lt;/code&gt; and don't run any more tests on the child.</source>
          <target state="translated">如果孩子在计划中调用&amp;ldquo; skip_all&amp;rdquo;，则会抛出 &lt;code&gt;Test::Builder::Exception&lt;/code&gt; 。捕获此错误，调用 &lt;code&gt;finalize()&lt;/code&gt; ,并且不再对子级运行任何测试。</target>
        </trans-unit>
        <trans-unit id="9e2b6a0e0e45f39177eb31d01e15e452bd57cce8" translate="yes" xml:space="preserve">
          <source>If a comparison subroutine (comp) is defined, it must return less than zero, zero, or greater than zero, if the first comparand is less than, equal, or greater than the second comparand.</source>
          <target state="translated">如果定义了一个比较子程序(comp),如果第一个比较数小于、等于或大于第二个比较数,它必须返回小于零、零或大于零。</target>
        </trans-unit>
        <trans-unit id="6bcefbb01c642f7f0fc9b06ad8c1d9b86690b30e" translate="yes" xml:space="preserve">
          <source>If a config variable name ends with &lt;code&gt;list&lt;/code&gt; , it is a list. &lt;code&gt;o conf
KEY &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; removes the first element of the list, &lt;code&gt;o conf KEY &lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; removes the last element of the list. &lt;code&gt;o conf KEYS &lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; LIST&lt;/code&gt; prepends a list of values to the list, &lt;code&gt;o conf KEYS &lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; LIST&lt;/code&gt; appends a list of valued to the list.</source>
          <target state="translated">如果配置变量名称以 &lt;code&gt;list&lt;/code&gt; 结尾，则它是一个列表。 &lt;code&gt;o conf KEY &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 删除列表的第一个元素， &lt;code&gt;o conf KEY &lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 删除列表的最后一个元素。 &lt;code&gt;o conf KEYS &lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; LIST&lt;/code&gt; 将值 &lt;code&gt;o conf KEYS &lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; LIST&lt;/code&gt; 添加到列表中，o conf KEYS &lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; LIST将值列表添加到列表中。</target>
        </trans-unit>
        <trans-unit id="5109117db036bd8645f50a5e04d368af63084ec5" translate="yes" xml:space="preserve">
          <source>If a container object, such as a hash or array, is locked, all the elements of that container are not locked. For example, if a thread does a &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt; @a&lt;/code&gt; , any other thread doing a &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock($a[12])&lt;/a&gt;&lt;/code&gt; won't block.</source>
          <target state="translated">如果容器对象（例如哈希或数组）被锁定，则该容器的所有元素都不会被锁定。例如，如果一个线程执行了 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt; @a&lt;/code&gt; &lt;a href=&quot;functions/lock&quot;&gt;锁定&lt;/a&gt;，则其他执行 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock($a[12])&lt;/a&gt;&lt;/code&gt; 其他线程都不会阻塞。</target>
        </trans-unit>
        <trans-unit id="dca4e72f15d2d8185a5bffef1f8b63be490eec41" translate="yes" xml:space="preserve">
          <source>If a default timeout ($def_timeout) in seconds is provided, it is used when a timeout is not given to the ping() method (below). The timeout must be greater than 0 and the default, if not specified, is 5 seconds.</source>
          <target state="translated">如果提供了以秒为单位的默认超时时间 ($def_timeout),那么当 ping()方法没有超时时,就会使用这个超时时间 (如下)。超时时间必须大于0,如果没有指定,默认为5秒。</target>
        </trans-unit>
        <trans-unit id="9cb3d5a547282377cc66b4c5457632db46bb8ed9" translate="yes" xml:space="preserve">
          <source>If a dereference operator is overloaded then it must return a</source>
          <target state="translated">如果一个dereference操作符是重载的,那么它必须返回一个</target>
        </trans-unit>
        <trans-unit id="fe98464b03f834d1a964476866ec0454738cfc5e" translate="yes" xml:space="preserve">
          <source>If a directory name is specified, Perl will switch to that directory before running the program. The &lt;b&gt;-x&lt;/b&gt; switch controls only the disposal of leading garbage. The program must be terminated with &lt;code&gt;__END__&lt;/code&gt; if there is trailing garbage to be ignored; the program can process any or all of the trailing garbage via the &lt;code&gt;DATA&lt;/code&gt; filehandle if desired.</source>
          <target state="translated">如果指定了目录名称，则Perl将在运行程序之前切换到该目录。该&lt;b&gt;-x&lt;/b&gt;开关只控制处置领导垃圾。如果要忽略尾随垃圾，则该程序必须以 &lt;code&gt;__END__&lt;/code&gt; 终止；如果需要，程序可以通过 &lt;code&gt;DATA&lt;/code&gt; 文件句柄处理任何或所有尾随垃圾。</target>
        </trans-unit>
        <trans-unit id="5aaf565f5088172c3b4f50e88e5260fa4d43f871" translate="yes" xml:space="preserve">
          <source>If a distribution defines a minimal required perl version, this is added to the output as an additional line of the form:</source>
          <target state="translated">如果一个发行版定义了一个最小的所需的perl版本,那么这个版本就会被添加到输出中,作为额外的一行形式。</target>
        </trans-unit>
        <trans-unit id="42b6266ffbedee9d19b5a6a2dc00e2ab21c075e3" translate="yes" xml:space="preserve">
          <source>If a false value (but not &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) is passed, &lt;code&gt;overrideHangul&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideHangul =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">如果传递了错误的值（但不是 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），则 &lt;code&gt;overrideHangul&lt;/code&gt; 无效。 &lt;code&gt;$Collator-&amp;gt;change(overrideHangul =&amp;gt; 0)&lt;/code&gt; 重置旧的。</target>
        </trans-unit>
        <trans-unit id="41f3060c136c5cb39245327e845028b89a018338" translate="yes" xml:space="preserve">
          <source>If a false value (including &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) is passed, &lt;code&gt;overrideCJK&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideCJK =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">如果传递了错误的值（包括 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），则 &lt;code&gt;overrideCJK&lt;/code&gt; 无效。 &lt;code&gt;$Collator-&amp;gt;change(overrideCJK =&amp;gt; 0)&lt;/code&gt; 重置旧的。</target>
        </trans-unit>
        <trans-unit id="4ce3e5ab6913747cb34ccc5fe411d22f75b39a20" translate="yes" xml:space="preserve">
          <source>If a false value (including &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) is passed, &lt;code&gt;overrideOut&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideOut =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">如果传递了错误的值（包括 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），则 &lt;code&gt;overrideOut&lt;/code&gt; 无效。 &lt;code&gt;$Collator-&amp;gt;change(overrideOut =&amp;gt; 0)&lt;/code&gt; 重置旧的。</target>
        </trans-unit>
        <trans-unit id="14cf492ed81687842dddeeef058d5e33b14e6b8c" translate="yes" xml:space="preserve">
          <source>If a field width obtained through &lt;code&gt;*&lt;/code&gt; is negative, it has the same effect as the &lt;code&gt;-&lt;/code&gt; flag: left-justification.</source>
          <target state="translated">如果通过 &lt;code&gt;*&lt;/code&gt; 获得的字段宽度为负，则其与 &lt;code&gt;-&lt;/code&gt; 标志相同：左对齐。</target>
        </trans-unit>
        <trans-unit id="9605e9893d52ad305cb79e90d906d025024d5412" translate="yes" xml:space="preserve">
          <source>If a file named by an argument cannot be opened for some reason, Perl warns you about it, and moves on to the next file. Note that the lines are printed automatically. An error occurring during printing is treated as fatal. To suppress printing use the &lt;b&gt;-n&lt;/b&gt; switch. A &lt;b&gt;-p&lt;/b&gt; overrides a &lt;b&gt;-n&lt;/b&gt; switch.</source>
          <target state="translated">如果由于某种原因而无法打开由参数命名的文件，则Perl会警告您，然后移至下一个文件。请注意，这些行是自动打印的。打印期间发生的错误被视为致命错误。要禁止打印，请使用&lt;b&gt;-n&lt;/b&gt;开关。甲&lt;b&gt;-p&lt;/b&gt;覆盖一个&lt;b&gt;-n&lt;/b&gt;开关。</target>
        </trans-unit>
        <trans-unit id="7607c4673d0f39465175ed86077289b9bf56cef9" translate="yes" xml:space="preserve">
          <source>If a filter has been installed with this method, it will be invoked every time you read a key from a DBM database.</source>
          <target state="translated">如果用这个方法安装了过滤器,那么每次从DBM数据库中读取密钥时都会被调用。</target>
        </trans-unit>
        <trans-unit id="ffcdc45cfdda9fabc4fc72ffad32b6bd83924c58" translate="yes" xml:space="preserve">
          <source>If a filter has been installed with this method, it will be invoked every time you read a value from a DBM database.</source>
          <target state="translated">如果用这个方法安装了一个过滤器,那么每次从DBM数据库中读取一个值时都会被调用。</target>
        </trans-unit>
        <trans-unit id="cd250eca2a3b32b9a72984e5551322c2a78954ba" translate="yes" xml:space="preserve">
          <source>If a filter has been installed with this method, it will be invoked every time you write a key to a DBM database.</source>
          <target state="translated">如果用这个方法安装了一个过滤器,那么每次向DBM数据库写入一个密钥时都会被调用。</target>
        </trans-unit>
        <trans-unit id="6d4a7b6c0f00f48df8682a8b26e45e64646603ea" translate="yes" xml:space="preserve">
          <source>If a filter has been installed with this method, it will be invoked every time you write a value to a DBM database.</source>
          <target state="translated">如果用这个方法安装了一个过滤器,那么每次向DBM数据库写入一个值时,它都会被调用。</target>
        </trans-unit>
        <trans-unit id="e3c644e7c4d09f78ea460ddc805cbed0f24eef71" translate="yes" xml:space="preserve">
          <source>If a fully qualified $class is given, its abbreviated version is checked first.</source>
          <target state="translated">如果给出了一个完全限定的$class,则首先检查它的缩写版本。</target>
        </trans-unit>
        <trans-unit id="61efacc190b96b684717f3100b2802427ca3f5f2" translate="yes" xml:space="preserve">
          <source>If a hyphen in a character class cannot syntactically be part of a range, for instance because it is the first or the last character of the character class, or if it immediately follows a range, the hyphen isn't special, and so is considered a character to be matched literally. If you want a hyphen in your set of characters to be matched and its position in the class is such that it could be considered part of a range, you must escape that hyphen with a backslash.</source>
          <target state="translated">如果一个字符类中的连字符在语法上不能成为一个范围的一部分,例如因为它是该字符类的第一个或最后一个字符,或者如果它紧跟在一个范围之后,那么这个连字符并不特殊,因此被认为是一个要按字面意思匹配的字符。如果您希望在您的字符集中的连字符被匹配,并且它在字符类中的位置可以被认为是范围的一部分,您必须用反斜线转义该连字符。</target>
        </trans-unit>
        <trans-unit id="8e9b736d2bd9dc9660e81744f77377a13eb0a302" translate="yes" xml:space="preserve">
          <source>If a key appears more than once in the initializer list of a hash, the last occurrence wins:</source>
          <target state="translated">如果一个键在哈希的初始化列表中出现超过一次,最后出现的键获胜。</target>
        </trans-unit>
        <trans-unit id="e38101b895429346e058b0e8e435924731bb16b2" translate="yes" xml:space="preserve">
          <source>If a layer provides &lt;code&gt;Open()&lt;/code&gt; it should normally call the &lt;code&gt;Open()&lt;/code&gt; method of next layer down (if any) and then push itself on top if that succeeds. &lt;code&gt;PerlIOBase_open&lt;/code&gt; is provided to do exactly that, so in most cases you don't have to write your own &lt;code&gt;Open()&lt;/code&gt; method. If this method is not defined, other layers may have difficulty pushing themselves on top of it during open.</source>
          <target state="translated">如果某个层提供 &lt;code&gt;Open()&lt;/code&gt; ，则通常应向下调用下一层的 &lt;code&gt;Open()&lt;/code&gt; 方法（如果有），如果成功，则将其自身推到顶部。提供 &lt;code&gt;PerlIOBase_open&lt;/code&gt; 可以完全做到这一点，因此在大多数情况下，您不必编写自己的 &lt;code&gt;Open()&lt;/code&gt; 方法。如果未定义此方法，则其他层在打开过程中可能难以将自身推到其顶部。</target>
        </trans-unit>
        <trans-unit id="73dbe9c1af884c682c784ff2164f939b559495d3" translate="yes" xml:space="preserve">
          <source>If a lexical variable is given an attribute, there is no symbol table to which it belongs, so the symbol table argument (&lt;code&gt;$_[1]&lt;/code&gt; ) is set to the string &lt;code&gt;'LEXICAL'&lt;/code&gt; in that case. Likewise, ascribing an attribute to an anonymous subroutine results in a symbol table argument of &lt;code&gt;'ANON'&lt;/code&gt; .</source>
          <target state="translated">如果为词法变量赋予属性，则该词法变量所属的符号表不存在，因此在这种情况下，符号表参数（ &lt;code&gt;$_[1]&lt;/code&gt; ）设置为字符串 &lt;code&gt;'LEXICAL'&lt;/code&gt; 。同样，将属性归于匿名子例程会导致符号表自变量 &lt;code&gt;'ANON'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="373e9d26b4e220dbf14e875851af78e4ef70cdec" translate="yes" xml:space="preserve">
          <source>If a line was available from the source stream, &lt;code&gt;filter_read()&lt;/code&gt; returns a status value greater than zero and appends the line to &lt;code&gt;$_&lt;/code&gt; . A status value of zero indicates end-of-file, less than zero means an error. The filter function itself is expected to return its status in the same way, and put the filtered line it wants written to the source stream in &lt;code&gt;$_&lt;/code&gt; . The use of &lt;code&gt;$_&lt;/code&gt; accounts for the brevity of most Perl source filters.</source>
          <target state="translated">如果源流中有一行，则 &lt;code&gt;filter_read()&lt;/code&gt; 返回大于零的状态值，并将该行追加到 &lt;code&gt;$_&lt;/code&gt; 。状态值为零表示文件结束，小于零表示错误。期望filter函数本身以相同的方式返回其状态，并将要写入的过滤后的行放入 &lt;code&gt;$_&lt;/code&gt; 。使用 &lt;code&gt;$_&lt;/code&gt; 可以简化大多数Perl源过滤器。</target>
        </trans-unit>
        <trans-unit id="eb73e02f11dc05b75008088bd5b205cf808a5add" translate="yes" xml:space="preserve">
          <source>If a matching entry cannot be found, and a default entry exists, then a reference to the default entry is returned.</source>
          <target state="translated">如果找不到匹配的条目,并且存在默认条目,则返回对默认条目的引用。</target>
        </trans-unit>
        <trans-unit id="c613dbc045a6d1ccd39d5e4d8985654cb6efdedb" translate="yes" xml:space="preserve">
          <source>If a message can be controlled by the &lt;code&gt;warnings&lt;/code&gt; pragma, its warning category is included with the classification letter in the description below. E.g. &lt;code&gt;(W closed)&lt;/code&gt; means a warning in the &lt;code&gt;closed&lt;/code&gt; category.</source>
          <target state="translated">如果消息可以由 &lt;code&gt;warnings&lt;/code&gt; 实用程序控制，则其警告类别包括在以下描述中的分类字母中。例如 &lt;code&gt;(W closed)&lt;/code&gt; 表示已 &lt;code&gt;closed&lt;/code&gt; 类别中的警告。</target>
        </trans-unit>
        <trans-unit id="f00576e48e7083129f4536c4d9542b2af3efddb9" translate="yes" xml:space="preserve">
          <source>If a method for an operation is not found then Perl tries to autogenerate a substitute implementation from the operations that have been defined.</source>
          <target state="translated">如果没有找到一个操作的方法,那么Perl会尝试从已经定义的操作中自动生成一个替代实现。</target>
        </trans-unit>
        <trans-unit id="0bdd74a3b17bde34780674e393224f07968f9f1d" translate="yes" xml:space="preserve">
          <source>If a module attempts to import any of these symbols the Exporter will give the module an opportunity to handle the situation before generating an error. The Exporter will call an export_fail method with a list of the failed symbols:</source>
          <target state="translated">如果一个模块试图导入这些符号中的任何一个,Exporter将在产生错误之前给模块一个机会来处理这种情况。Exporter将调用export_fail方法,并提供一个失败的符号列表。</target>
        </trans-unit>
        <trans-unit id="46e9244ade28e8f11cc0bc5968d58da31945ce21" translate="yes" xml:space="preserve">
          <source>If a module does not build for some reason, look carefully for why it failed, and report problems to the module author. If it looks like the extension building support is at fault, report that with full details of how the build failed using the perlbug utility.</source>
          <target state="translated">如果一个模块由于某种原因没有构建,请仔细查找它失败的原因,并向模块作者报告问题。如果看起来是扩展构建支持出了问题,请使用 perlbug 工具报告构建失败的全部细节。</target>
        </trans-unit>
        <trans-unit id="094a8b4d892c0d307d87dac5429320ae267e0ba1" translate="yes" xml:space="preserve">
          <source>If a module implements XSUBs, you will need one of the supported C compilers. You must make sure you have set up the environment for the compiler for command-line compilation before running &lt;code&gt;perl Makefile.PL&lt;/code&gt; or any invocation of make.</source>
          <target state="translated">如果模块实现XSUB，则将需要受支持的C编译器之一。在运行 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 或make的任何调用之前，必须确保已为编译器设置了用于命令行编译的环境。</target>
        </trans-unit>
        <trans-unit id="9711733a9e84337767e9b5acb7ff59757c774ea1" translate="yes" xml:space="preserve">
          <source>If a name does not already have a suitable prefix and/or suffix then the corresponding file will be searched for by trying combinations of prefix and suffix appropriate to the platform: &quot;$name.o&quot;, &quot;lib$name.*&quot; and &quot;$name&quot;.</source>
          <target state="translated">如果一个名字没有合适的前缀和/或后缀,那么将通过尝试适合平台的前缀和后缀组合来搜索相应的文件。&quot;$name.o&quot;、&quot;lib$name.*&quot;和&quot;$name&quot;。</target>
        </trans-unit>
        <trans-unit id="71674c3e4540508bc53564e31d00df9a0af1f1d2" translate="yes" xml:space="preserve">
          <source>If a name resolve operation fails to provide a name, then this flag will cause getnameinfo() to indicate an error, rather than returning the numeric representation as a human-readable string.</source>
          <target state="translated">如果名称解析操作未能提供名称,那么这个标志将导致getnameinfo()指示一个错误,而不是以人类可读的字符串形式返回数字表示。</target>
        </trans-unit>
        <trans-unit id="31b368c0d757e116a5dfb072a97b4193c426b9b0" translate="yes" xml:space="preserve">
          <source>If a negative array index is used to read from an array, the index will be translated to a positive one internally by calling FETCHSIZE before being passed to FETCH. You may disable this feature by assigning a true value to the variable &lt;code&gt;$NEGATIVE_INDICES&lt;/code&gt; in the tied array class.</source>
          <target state="translated">如果使用负数组索引从数组中读取数据，则在传递给FETCH之前，可以通过调用FETCHSIZE在内部将索引转换为正索引。您可以通过为绑定数组类中的变量 &lt;code&gt;$NEGATIVE_INDICES&lt;/code&gt; 分配一个真值来禁用此功能。</target>
        </trans-unit>
        <trans-unit id="77fd7f19527eab5261c210a54c173bb0abc87920" translate="yes" xml:space="preserve">
          <source>If a package uses overload, it carries a special flag. This flag is also set when new functions are defined or @ISA is modified. There will be a slight speed penalty on the very first operation thereafter that supports overloading, while the overload tables are updated. If there is no overloading present, the flag is turned off. Thus the only speed penalty thereafter is the checking of this flag.</source>
          <target state="translated">如果一个包使用了重载,它就会携带一个特殊的标志。当定义新函数或修改@ISA时,这个标志也会被设置。在此后的第一个支持重载的操作中会有轻微的速度惩罚,同时重载表也会被更新。如果没有重载存在,则关闭该标志。因此,此后唯一的速度惩罚就是检查这个标志。</target>
        </trans-unit>
        <trans-unit id="eef6b1875e2dcae080c75ee35ffb78afc980a5f8" translate="yes" xml:space="preserve">
          <source>If a pattern does not contain a special backtracking verb that allows an argument, then &lt;code&gt;$REGERROR&lt;/code&gt; and &lt;code&gt;$REGMARK&lt;/code&gt; are not touched at all.</source>
          <target state="translated">如果模式不包含允许参数的特殊回溯动词，则 &lt;code&gt;$REGMARK&lt;/code&gt; 不会触及 &lt;code&gt;$REGERROR&lt;/code&gt; 和$ REGMARK。</target>
        </trans-unit>
        <trans-unit id="9f0b6253b5fcfd411b56a12da1005e8889d7cecd" translate="yes" xml:space="preserve">
          <source>If a piece of code is under the control of the &lt;code&gt;warnings&lt;/code&gt; pragma, both the &lt;code&gt;$^W&lt;/code&gt; variable and the &lt;b&gt;-w&lt;/b&gt; flag will be ignored for the scope of the lexical warning.</source>
          <target state="translated">如果一段代码在 &lt;code&gt;warnings&lt;/code&gt; 编译指示的控制下，则对于词法警告的范围， &lt;code&gt;$^W&lt;/code&gt; 变量和&lt;b&gt;-w&lt;/b&gt;标志都将被忽略。</target>
        </trans-unit>
        <trans-unit id="dc66a04b7fd6c8f1331b2adb91a4455713a61616" translate="yes" xml:space="preserve">
          <source>If a plan has not yet been output, it will do so.</source>
          <target state="translated">如果一个计划还没有输出,它就会输出。</target>
        </trans-unit>
        <trans-unit id="f9d2f49ea2b290886ecf360d9425d5113040021a" translate="yes" xml:space="preserve">
          <source>If a precision obtained through &lt;code&gt;*&lt;/code&gt; is negative, it counts as having no precision at all.</source>
          <target state="translated">如果通过 &lt;code&gt;*&lt;/code&gt; 获得的精度为负，则认为完全没有精度。</target>
        </trans-unit>
        <trans-unit id="2493d17a98c3b1f685aa6fcd91f6a228a3382409" translate="yes" xml:space="preserve">
          <source>If a precompiled pattern is embedded in a larger pattern then the effect of &lt;code&gt;&quot;msixpluadn&quot;&lt;/code&gt; will be propagated appropriately. The effect that the &lt;code&gt;/o&lt;/code&gt; modifier has is not propagated, being restricted to those patterns explicitly using it.</source>
          <target state="translated">如果将预编译的模式嵌入较大的模式，则 &lt;code&gt;&quot;msixpluadn&quot;&lt;/code&gt; 的效果将适当传播。 &lt;code&gt;/o&lt;/code&gt; 修饰符所具有的效果不会传播，仅限于使用它的显式模式。</target>
        </trans-unit>
        <trans-unit id="cfe77c7e04c6532a52f2ea4bb204b4b081b46114" translate="yes" xml:space="preserve">
          <source>If a program's environment specifies an LC_NUMERIC locale and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
locale&lt;/code&gt; is in effect when the format is declared, the locale is used to specify the decimal point character in formatted output. Formatted output cannot be controlled by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; at the time when write() is called. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for further discussion of locale handling.</source>
          <target state="translated">如果程序的环境指定了LC_NUMERIC语言环境，并且在声明格式时 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 生效，则该语言环境用于在格式化输出中指定小数点字符。调用write（）时，无法 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 来控制格式化输出。有关语言环境处理的进一步讨论，请参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dbdd7653484d14bb99878153118f9a9fc7a64201" translate="yes" xml:space="preserve">
          <source>If a queue is empty, &lt;code&gt;dequeue()&lt;/code&gt; blocks until another thread enqueues something. This makes queues ideal for event loops and other communications between threads.</source>
          <target state="translated">如果队列为空，则 &lt;code&gt;dequeue()&lt;/code&gt; 阻塞，直到另一个线程入队。这使队列非常适合事件循环和线程之间的其他通信。</target>
        </trans-unit>
        <trans-unit id="d8a808372475f8c939dd3899bae64db28b71a73e" translate="yes" xml:space="preserve">
          <source>If a reference happens to be a reference to an object, then there are probably methods to access the things referred to, and you should probably stick to those methods unless you're in the class package that defines the object's methods. In other words, be nice, and don't violate the object's encapsulation without a very good reason. Perl does not enforce encapsulation. We are not totalitarians here. We do expect some basic civility though.</source>
          <target state="translated">如果一个引用恰好是对一个对象的引用,那么可能有方法来访问被引用的东西,你可能应该坚持使用这些方法,除非你在定义对象方法的类封装中。换句话说,如果没有很好的理由,就不要违反对象的封装。Perl不强制封装。我们不是极权主义者。不过我们确实希望有一些基本的文明。</target>
        </trans-unit>
        <trans-unit id="c8efe9417a8ca522054e8e0f20aa5ebe3ad20734" translate="yes" xml:space="preserve">
          <source>If a regexp has a variable that interpolates a code expression, Perl treats the regexp as an error. If the code expression is precompiled into a variable, however, interpolating is ok. The question is, why is this an error?</source>
          <target state="translated">如果一个 regexp 中有一个插值代码表达式的变量,Perl 就会把这个 regexp 作为一个错误处理。然而,如果代码表达式被预先编译成一个变量,那么插值是可以的。问题是,为什么这是一个错误?</target>
        </trans-unit>
        <trans-unit id="d5bd95a2da72abd4235bfb3025f329041ecd2afc" translate="yes" xml:space="preserve">
          <source>If a regexp matches in more than one place in the string, Perl will always match at the earliest possible point in the string:</source>
          <target state="translated">如果一个regexp在字符串中的一个以上的位置匹配,Perl将总是在字符串中最早的位置进行匹配。</target>
        </trans-unit>
        <trans-unit id="eaf4b93182f52023e0f84b564980685b7296c6d9" translate="yes" xml:space="preserve">
          <source>If a regular bracketed character class contains a &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; and is matched against a non-Unicode code point, a warning may be raised, as the result is not Unicode-defined. No such warning will come when using this extended form.</source>
          <target state="translated">如果常规方括号字符类包含 &lt;code&gt;\p{}&lt;/code&gt; 或 &lt;code&gt;\P{}&lt;/code&gt; 并与非Unicode代码点匹配，则可能会出现警告，因为结果未定义Unicode。使用此扩展格式时不会出现此类警告。</target>
        </trans-unit>
        <trans-unit id="f85e430ff8e0f946fbbcd7fbdf03ad676d0029b5" translate="yes" xml:space="preserve">
          <source>If a result does not have a callback defined for it, this callback will be invoked. Thus, if all of the previous result types are specified as callbacks, this callback will</source>
          <target state="translated">如果一个结果没有为它定义回调,这个回调将被调用。因此,如果前面所有的结果类型都被指定为回调,那么这个回调将是</target>
        </trans-unit>
        <trans-unit id="7c88e9a20d1a229d11dbc65d34fee24d0f8252b1" translate="yes" xml:space="preserve">
          <source>If a script does not contain such a cooky, then to avoid calling</source>
          <target state="translated">如果一个脚本不包含这样的cooky,那么为了避免调用</target>
        </trans-unit>
        <trans-unit id="7e6d780b3e70414e72c5be7308b60f82c00d250e" translate="yes" xml:space="preserve">
          <source>If a second argument is given and it corresponds to a valid locale, the locale for the category is set to that value, and the function returns the now-current locale value. You can then use this in yet another call to &lt;code&gt;setlocale()&lt;/code&gt; . (In some implementations, the return value may sometimes differ from the value you gave as the second argument--think of it as an alias for the value you gave.)</source>
          <target state="translated">如果给定第二个参数且该参数对应于有效的语言环境，则将类别的语言环境设置为该值，然后该函数返回当前的语言环境值。然后，您可以在另一个对 &lt;code&gt;setlocale()&lt;/code&gt; 的调用中使用它。 （在某些实现中，返回值有时可能与您作为第二个参数提供的值有所不同-将其视为您提供的值的别名。）</target>
        </trans-unit>
        <trans-unit id="91a945f54fa17399a38d6421bac299acb5873c21" translate="yes" xml:space="preserve">
          <source>If a second argument is given then it should be the name of the desired output file. If the special output filename &quot;-&quot; or &quot;&amp;gt;&amp;amp;STDOUT&quot; is given then the STDOUT filehandle is used for output (and no open or close is performed). If the special output filename &quot;&amp;gt;&amp;amp;STDERR&quot; is given then the STDERR filehandle is used for output (and no open or close is performed). If no output filehandle is currently in use and no output filename is specified, then &quot;-&quot; is implied. Alternatively, filehandle references or objects that support the regular IO operations (like &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, e.g. &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO::String&lt;/a&gt;) are also accepted; the object must already be opened.</source>
          <target state="translated">如果给定第二个参数，则它应该是所需输出文件的名称。如果给出了特殊的输出文件名&amp;ldquo;-&amp;rdquo;或&amp;ldquo; &amp;amp;&amp;amp;&amp;amp; STDOUT&amp;rdquo;，则将STDOUT文件句柄用于输出（并且不执行打开或关闭操作）。如果给出了特殊的输出文件名&amp;ldquo;&amp;ldquo;&amp;gt; &amp;amp;&amp;amp;&amp;amp; STDERR&amp;rdquo;，那么将使用STDERR文件句柄进行输出（并且不执行打开或关闭操作）。如果当前未使用任何输出文件句柄，并且未指定输出文件名，则意味着&amp;ldquo;-&amp;rdquo;。另外，也可以接受支持常规IO操作的文件句柄引用或对象（例如 &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ，例如&lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO :: String&lt;/a&gt;）；该对象必须已经打开。</target>
        </trans-unit>
        <trans-unit id="477169172ccc2cfa646e6b1ff7ebcaf7ea663dbd" translate="yes" xml:space="preserve">
          <source>If a second argument is given then it should correspond to a filehandle where output should be sent (otherwise the default output filehandle is &lt;code&gt;STDOUT&lt;/code&gt; if no output filehandle is currently in use).</source>
          <target state="translated">如果给定第二个参数，则它应对应于应将输出发送到的文件句柄（否则，如果当前未使用任何输出文件句柄，则默认输出文件句柄为 &lt;code&gt;STDOUT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="93e01c4263faa2fd7e903bd96fbfc6f719b4224a" translate="yes" xml:space="preserve">
          <source>If a signal of any given type fires multiple times during an opcode (such as from a fine-grained timer), the handler for that signal will be called only once, after the opcode completes; all other instances will be discarded. Furthermore, if your system's signal queue gets flooded to the point that there are signals that have been raised but not yet caught (and thus not deferred) at the time an opcode completes, those signals may well be caught and deferred during subsequent opcodes, with sometimes surprising results. For example, you may see alarms delivered even after calling &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm(0)&lt;/a&gt;&lt;/code&gt; as the latter stops the raising of alarms but does not cancel the delivery of alarms raised but not yet caught. Do not depend on the behaviors described in this paragraph as they are side effects of the current implementation and may change in future versions of Perl.</source>
          <target state="translated">如果任何给定类型的信号在操作码期间多次触发（例如从细粒度的计时器触发），则在操作码完成后，该信号的处理程序将仅被调用一次；所有其他实例将被丢弃。此外，如果系统的信号队列泛滥到某个操作码完成时已经提出但尚未捕获（因此未推迟）的信号，则这些信号很可能在后续操作码中被捕获并推迟。有时结果令人惊讶。例如，即使在调用 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm(0)&lt;/a&gt;&lt;/code&gt; 之后，您也可能会看到警报已传递因为后者会停止发出警报，但不会取消已发出但尚未捕获的警报的传递。不要依赖本段中描述的行为，因为它们是当前实现的副作用，并且在Perl的将来版本中可能会更改。</target>
        </trans-unit>
        <trans-unit id="8ca9f14adad1a4346557fbd963ffe8837b4e2de6" translate="yes" xml:space="preserve">
          <source>If a specified constant &lt;code&gt;EFOO&lt;/code&gt; does not exist on the system, &lt;code&gt;$!{EFOO}&lt;/code&gt; returns &lt;code&gt;&quot;&quot;&lt;/code&gt; . You may use &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $!{EFOO}&lt;/code&gt; to check whether the constant is available on the system.</source>
          <target state="translated">如果系统上不存在指定的常量 &lt;code&gt;EFOO&lt;/code&gt; ，则 &lt;code&gt;$!{EFOO}&lt;/code&gt; 返回 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。您可以使用 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $!{EFOO}&lt;/code&gt; 来检查常量在系统上是否可用。</target>
        </trans-unit>
        <trans-unit id="f800d47729ac41db50a73befe5a0c18db31026bf" translate="yes" xml:space="preserve">
          <source>If a string is UTF-8, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; to get at the value, unless &lt;code&gt;UTF8_IS_INVARIANT(*s)&lt;/code&gt; in which case you can use &lt;code&gt;*s&lt;/code&gt; .</source>
          <target state="translated">如果字符串是UTF-8，请&lt;b&gt;始终&lt;/b&gt;使用 &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; 获取该值，除非 &lt;code&gt;UTF8_IS_INVARIANT(*s)&lt;/code&gt; 在这种情况下可以使用 &lt;code&gt;*s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1be10a035bc9dd04a9faa3e7d6666d736bd26b25" translate="yes" xml:space="preserve">
          <source>If a sub has both a PROTO and a BLOCK, the prototype is not applied until after the BLOCK is completely defined. This means that a recursive function with a prototype has to be predeclared for the prototype to take effect, like so:</source>
          <target state="translated">如果一个子有PROTO和BLOCK,那么在BLOCK被完全定义后,原型才会被应用。这意味着必须预先声明一个具有原型的递归函数,原型才能生效,就像这样。</target>
        </trans-unit>
        <trans-unit id="0608dc713e7e2ffc835fe7b94ed6aa1dd9da10a4" translate="yes" xml:space="preserve">
          <source>If a subroutine reference was given, it is invoked as:</source>
          <target state="translated">如果给出了一个子程序的引用,那么它的调用是:</target>
        </trans-unit>
        <trans-unit id="b5b26c7bacf7c0c773c98a08b7cfd7b95eaadc8d" translate="yes" xml:space="preserve">
          <source>If a substring is known to match at end-of-line only, it may be followed by &lt;code&gt;$&lt;/code&gt; , as in &lt;code&gt;floating 'k'$&lt;/code&gt; .</source>
          <target state="translated">如果已知子字符串仅在行尾匹配，则可以跟在 &lt;code&gt;$&lt;/code&gt; 后面，如在 &lt;code&gt;floating 'k'$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8bac00f48a56f95c981f68b27c67c1613b3abed" translate="yes" xml:space="preserve">
          <source>If a test had either a &lt;code&gt;TODO&lt;/code&gt; or &lt;code&gt;SKIP&lt;/code&gt; directive, this method will return the accompanying explanation, if present.</source>
          <target state="translated">如果测试具有 &lt;code&gt;TODO&lt;/code&gt; 或 &lt;code&gt;SKIP&lt;/code&gt; 指令，则此方法将返回附带的说明（如果存在）。</target>
        </trans-unit>
        <trans-unit id="65b9290b4f037c914cf42f893f1aba1433a9e97a" translate="yes" xml:space="preserve">
          <source>If a test number is greater than the number of planned tests, this method will return true. Unplanned tests will</source>
          <target state="translated">如果测试次数大于计划的测试次数,这个方法将返回true。未计划的测试将返回</target>
        </trans-unit>
        <trans-unit id="99f0a88031cba297a38b9bb2a8d9794138cdfcc6" translate="yes" xml:space="preserve">
          <source>If a transformation subroutine (xfrm) is defined, its value is used to transform the lines read from the filehandle before their comparison.</source>
          <target state="translated">如果定义了一个转换子程序(xfrm),它的值就用来在比较之前转换从filehandle读取的行。</target>
        </trans-unit>
        <trans-unit id="571f9ad4d812cfdda52b01e4ae41c48c7aa1a889" translate="yes" xml:space="preserve">
          <source>If a true value is given (non-zero but should be positive), it will be added as a terminator primary weight to the end of every standard Hangul syllable. Secondary and any higher weights for terminator are set to zero. If the value is false or &lt;code&gt;hangul_terminator&lt;/code&gt; key does not exist, insertion of terminator weights will not be performed.</source>
          <target state="translated">如果给定一个真值（非零，但应为正数），它将作为终止符的主要权重添加到每个标准韩文音节的末尾。终结器的辅助权重和任何更高的权重都设置为零。如果值为false或 &lt;code&gt;hangul_terminator&lt;/code&gt; 键不存在，将不执行终止符权重的插入。</target>
        </trans-unit>
        <trans-unit id="06c503e180fbd73d4ade263d4ec3fc736e96785b" translate="yes" xml:space="preserve">
          <source>If a typed lexical variable (&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Class
$var&lt;/code&gt; ) holding a reference is used to access a hash element and a package with the same name as the type has declared class fields using this pragma, then the hash key is verified at compile time. If the variables are not typed, access is only checked at run time.</source>
          <target state="translated">如果使用包含引用的类型化词法变量（ &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Class $var&lt;/code&gt; ）来访问哈希元素，并且具有与该类型相同名称的包使用此编译指示符声明了类字段，则在编译时将验证哈希键。如果未键入变量，则仅在运行时检查访问。</target>
        </trans-unit>
        <trans-unit id="a56a688e323d9747dee356792880eafa156d2877" translate="yes" xml:space="preserve">
          <source>If a utility or module isn't available, it will be marked in a cache (see the &lt;code&gt;$METHOD_FAIL&lt;/code&gt; variable further down), so it will not be tried again. The &lt;code&gt;fetch&lt;/code&gt; method will only fail when all options are exhausted, and it was not able to retrieve the file.</source>
          <target state="translated">如果某个实用程序或模块不可用，则会在缓存中将其标记出来（请参阅 &lt;code&gt;$METHOD_FAIL&lt;/code&gt; 变量进一步说明），因此不会再次尝试。仅当所有选项都用尽并且无法检索文件时， &lt;code&gt;fetch&lt;/code&gt; 方法才会失败。</target>
        </trans-unit>
        <trans-unit id="17e415afdb54d5332d73e9d658477c2317a9747c" translate="yes" xml:space="preserve">
          <source>If a variable is declared inside a CODE: section it will follow any typemap code that is emitted for the input parameters. This may result in the declaration ending up after C code, which is C syntax error. Similar errors may happen with an explicit &lt;code&gt;;&lt;/code&gt; -type or &lt;code&gt;+&lt;/code&gt; -type initialization of parameters is used (see &lt;a href=&quot;#Initializing-Function-Parameters&quot;&gt;Initializing Function Parameters&lt;/a&gt;). Declaring these variables in an INIT: section will not help.</source>
          <target state="translated">如果在CODE：节中声明了变量，它将遵循为输入参数发出的任何类型映射代码。这可能导致声明以C代码结尾，这是C语法错误。显式可能会发生类似的错误 &lt;code&gt;;&lt;/code&gt; 型或 &lt;code&gt;+&lt;/code&gt; 型的使用参数初始化（见&lt;a href=&quot;#Initializing-Function-Parameters&quot;&gt;初始化功能参数&lt;/a&gt;）。在INIT：部分中声明这些变量将无济于事。</target>
        </trans-unit>
        <trans-unit id="b1e1471095c4d68dab8592febf94b7e3ac2a2016" translate="yes" xml:space="preserve">
          <source>If accept() is interrupted by a signal, $! will be set to EINTR. If this happens, we can safely continue to the next iteration of the loop and another call to accept(). It is important that your signal handling code not modify the value of $!, or else this test will likely fail. In the REAPER subroutine we create a local version of $! before calling waitpid(). When waitpid() sets $! to ECHILD as it inevitably does when it has no more children waiting, it updates the local copy and leaves the original unchanged.</source>
          <target state="translated">如果accept()被一个信号打断,$!将被设置为EINTR。如果发生这种情况,我们可以安全地继续下一个循环的迭代,再调用accept()。重要的是,你的信号处理代码不能修改$!的值,否则这个测试很可能会失败。在REAPER子程序中,我们在调用waitpid()之前创建一个本地版本的$!。当waitpid()将$!设置为ECHILD时,因为当它没有更多的子程序等待时,它必然会更新本地副本,并保持原始副本不变。</target>
        </trans-unit>
        <trans-unit id="752e6cffd40215caddfd723588dccf4863a5ed16" translate="yes" xml:space="preserve">
          <source>If adding a new module to a set, follow the original author's standards for naming modules and the interface to methods in those modules.</source>
          <target state="translated">如果在一个集合中增加一个新的模块,按照原作者的标准来命名模块和这些模块中的方法接口。</target>
        </trans-unit>
        <trans-unit id="c30aaa76b20fc01d8891caaf8c421bdbbefa39ad" translate="yes" xml:space="preserve">
          <source>If after that process the layer is still not defined then the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; will fail.</source>
          <target state="translated">如果在该过程之后仍未定义该层，则 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 将失败。</target>
        </trans-unit>
        <trans-unit id="3f5b65dba45a85e174c3b613f61ee902daa93694" translate="yes" xml:space="preserve">
          <source>If all actions were successful install will return a hashref of the results as described above for the $result parameter. If any action is a failure then install will die, therefore it is recommended to pass in the $result parameter instead of using the return value. If the result parameter is provided then the returned hashref will be the passed in hashref.</source>
          <target state="translated">如果所有的操作都是成功的,那么 install 将会像上面描述的 $result 参数那样返回一个结果的哈希夫。如果任何操作都是失败的,那么 install 就会死掉,因此建议传入 $result 参数而不是使用返回值。如果提供了result参数,那么返回的hashref将是传入的hashref。</target>
        </trans-unit>
        <trans-unit id="127255eea385053cfe8f53f8f2c648f76a8be49c" translate="yes" xml:space="preserve">
          <source>If all data that comes from a certain handle is encoded in exactly the same way, you can tell the PerlIO system to automatically decode everything, with the &lt;code&gt;encoding&lt;/code&gt; layer. If you do this, you can't accidentally forget to decode or encode anymore, on things that use the layered handle.</source>
          <target state="translated">如果来自某个句柄的所有数据都以完全相同的方式编码，则可以告诉PerlIO系统使用 &lt;code&gt;encoding&lt;/code&gt; 层自动解码所有内容。如果这样做，您就不会偶然忘记对使用分层句柄的东西进行解码或编码了。</target>
        </trans-unit>
        <trans-unit id="3e7d1b1bb140827b5655410f34d1155c7f80618e" translate="yes" xml:space="preserve">
          <source>If all goes okay and no errors during a build, you'll get two independent distributions: &lt;code&gt;wince-mips-pocket-wce300&lt;/code&gt; and &lt;code&gt;mips-wce300-thr&lt;/code&gt; .</source>
          <target state="translated">如果一切顺利，并且在构建过程中没有错误，您将获得两个独立的发行版： &lt;code&gt;wince-mips-pocket-wce300&lt;/code&gt; 和 &lt;code&gt;mips-wce300-thr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ab3e0df4f550d075ed2874e19cdd1793f373e2a" translate="yes" xml:space="preserve">
          <source>If all this is intimidating, have no (well, maybe only a little) fear. There are modules that can help. The &lt;code&gt;File::Spec&lt;/code&gt; modules provide methods to do the Right Thing on whatever platform happens to be running the program.</source>
          <target state="translated">如果所有这些都令人生畏，那就不要（好，也许只有一点）恐惧。有些模块可以提供帮助。该 &lt;code&gt;File::Spec&lt;/code&gt; 模块提供的方法做正确的事情就什么平台恰好是运行程序。</target>
        </trans-unit>
        <trans-unit id="ae7ad2a8e725968ebffe98c6ec06a2f880b60f52" translate="yes" xml:space="preserve">
          <source>If all you want to do is pretend to be telnet but don't need the initial telnet handshaking, then the standard dual-process approach will suffice:</source>
          <target state="translated">如果你想做的只是假装是telnet,但不需要最初的telnet握手,那么标准的双进程方式就足够了。</target>
        </trans-unit>
        <trans-unit id="114fc5763881eaed2b695ddb5eda1e514b33dd63" translate="yes" xml:space="preserve">
          <source>If all your tests passed, &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; will exit with zero (which is normal). If anything failed it will exit with how many failed. If you run less (or more) tests than you planned, the missing (or extras) will be considered failures. If no tests were ever run &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; will throw a warning and exit with 255. If the test died, even after having successfully completed all its tests, it will still be considered a failure and will exit with 255.</source>
          <target state="translated">如果所有测试均通过，则&lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt;将以零退出（正常）。如果有任何失败，它将以多少失败退出。如果您运行的测试次数少于计划的次数（或更多），那么缺失（或额外）的测试将被视为失败。如果从未运行过任何测试，则&lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt;将发出警告并以255退出。如果测试失败，即使在成功完成所有测试之后，仍将视为失败并以255退出。</target>
        </trans-unit>
        <trans-unit id="a98f6624ef41fa5865752ff72d1c88c5adce8ff1" translate="yes" xml:space="preserve">
          <source>If all your tests passed, Test::Builder will exit with zero (which is normal). If anything failed it will exit with how many failed. If you run less (or more) tests than you planned, the missing (or extras) will be considered failures. If no tests were ever run Test::Builder will throw a warning and exit with 255. If the test died, even after having successfully completed all its tests, it will still be considered a failure and will exit with 255.</source>
          <target state="translated">如果你的所有测试都通过了,Test::Builder将以0退出(这是正常的)。如果有任何测试失败,它将以失败的次数退出。如果您运行的测试比您计划的少(或多),缺少的(或额外的)测试将被视为失败。如果没有运行过任何测试,Test::Builder将抛出一个警告并以255退出。如果测试死了,即使成功地完成了所有的测试,它仍然会被认为是失败的,并以 255 退出。</target>
        </trans-unit>
        <trans-unit id="ec52cc18e24a40a3b425f46525ccb32d3bbfcd0d" translate="yes" xml:space="preserve">
          <source>If all your tests passed, Test::Simple will exit with zero (which is normal). If anything failed it will exit with how many failed. If you run less (or more) tests than you planned, the missing (or extras) will be considered failures. If no tests were ever run Test::Simple will throw a warning and exit with 255. If the test died, even after having successfully completed all its tests, it will still be considered a failure and will exit with 255.</source>
          <target state="translated">如果你的所有测试都通过了,Test::Simple将以0退出(这是正常的)。如果有任何测试失败,它将以失败的次数退出。如果你运行的测试比你计划的少(或多),缺少的(或额外的)测试将被视为失败。如果没有运行过任何测试,Test::Simple将抛出一个警告并以255退出。如果测试死了,即使在成功地完成了所有测试之后,它仍然会被认为是失败的,并以 255 退出。</target>
        </trans-unit>
        <trans-unit id="bf21a78dfdb342ccff4796ddae824fa3095f386e" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ExtraField&lt;/code&gt; option is specified and it is a simple scalar, it must conform to the sub-field structure as defined in RFC 1952.</source>
          <target state="translated">如果指定了 &lt;code&gt;ExtraField&lt;/code&gt; 选项并且它是一个简单的标量，则它必须符合RFC 1952中定义的子字段结构。</target>
        </trans-unit>
        <trans-unit id="703bb32d1796efb54146381859e7e166335fd702" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ExtraField&lt;/code&gt; option is specified and it is a simple scalar, the structure will not be checked. The only error is if the length is too big.</source>
          <target state="translated">如果指定了 &lt;code&gt;ExtraField&lt;/code&gt; 选项，并且它是简单的标量，则不会检查结构。唯一的错误是长度太大。</target>
        </trans-unit>
        <trans-unit id="d5888ada14b086770c285ef36da99e64d4b36a12" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ExtraField&lt;/code&gt; option is specified the second byte of the ID will be checked in each subfield to ensure that it does not contain the reserved value 0x00.</source>
          <target state="translated">如果指定了 &lt;code&gt;ExtraField&lt;/code&gt; 选项，则将在每个子字段中检查ID的第二个字节，以确保它不包含保留值0x00。</target>
        </trans-unit>
        <trans-unit id="bba67c55f0a73d622c034c758b4c54c06d0297ce" translate="yes" xml:space="preserve">
          <source>If an AUTOLOAD routine is an XSUB, as with Perl subroutines, Perl puts the fully-qualified name of the autoloaded subroutine in the $AUTOLOAD variable of the XSUB's package.</source>
          <target state="translated">如果一个AUTOLOAD例程是一个XSUB,就像Perl子程序一样,Perl将自动加载的子程序的完全限定名放在XSUB包的$AUTOLOAD变量中。</target>
        </trans-unit>
        <trans-unit id="42bdc376fb833e498b49e6edb80ebe7de88f4149" translate="yes" xml:space="preserve">
          <source>If an Input glob matches the same file more than once, only the first will be used.</source>
          <target state="translated">如果一个Input glob与同一个文件匹配超过一次,将只使用第一个文件。</target>
        </trans-unit>
        <trans-unit id="4c7ac1d42b2433b8600fc2dd6eb1a16139df0641" translate="yes" xml:space="preserve">
          <source>If an XSUB is created to offer a direct translation between this function and Perl, then this XSUB will be used from Perl with the following code. The $status and $timep variables will contain the output of the function.</source>
          <target state="translated">如果创建了一个XSUB来提供函数和Perl之间的直接转换,那么这个XSUB将通过以下代码在Perl中使用。$status 和 $timep 变量将包含函数的输出。</target>
        </trans-unit>
        <trans-unit id="b382afe3d07f60c5f6eced5294d3838170432890" translate="yes" xml:space="preserve">
          <source>If an XSUB name contains &lt;code&gt;::&lt;/code&gt; , it is considered to be a C++ method. The generated Perl function will assume that its first argument is an object pointer. The object pointer will be stored in a variable called THIS. The object should have been created by C++ with the new() function and should be blessed by Perl with the sv_setref_pv() macro. The blessing of the object by Perl can be handled by a typemap. An example typemap is shown at the end of this section.</source>
          <target state="translated">如果XSUB名称包含 &lt;code&gt;::&lt;/code&gt; ，则将其视为C ++方法。生成的Perl函数将假定其第一个参数是对象指针。对象指针将存储在名为THIS的变量中。该对象应该已经由C ++使用new（）函数创建，并且应该由Perl使用sv_setref_pv（）宏来祝福。Perl对对象的祝福可以通过类型映射来处理。本节末尾显示了一个示例类型映射。</target>
        </trans-unit>
        <trans-unit id="a5be5707a4fed01d7fc6a9c5c683f16ea2406809" translate="yes" xml:space="preserve">
          <source>If an argument callback routine is specified, &lt;code&gt;@ARGV&lt;/code&gt; will always be empty upon successful return of GetOptions() since all options have been processed. The only exception is when &lt;code&gt;--&lt;/code&gt; is used:</source>
          <target state="translated">如果指定了参数回调例程，则在成功返回GetOptions（）时，@ &lt;code&gt;@ARGV&lt;/code&gt; 将始终为空，因为已处理所有选项。唯一的例外是使用 &lt;code&gt;--&lt;/code&gt; 时：</target>
        </trans-unit>
        <trans-unit id="b39b97b3c5875ed6ddbb4cadef1665f0d49ebbe7" translate="yes" xml:space="preserve">
          <source>If an argument is given, it must correspond to the desired section heading number, in which case only the specified section heading is returned. If there is no current section heading at the specified level, then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果给出参数，则它必须对应于所需的节标题号，在这种情况下，仅返回指定的节标题。如果没有指定级别的当前节标题，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7271fc38171101f8ded47e78d280e28ab4aefe24" translate="yes" xml:space="preserve">
          <source>If an attribute handler is declared and the &lt;code&gt;:ATTR&lt;/code&gt; specifier is given the name of a built-in type (&lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; , or &lt;code&gt;CODE&lt;/code&gt; ), the handler is only applied to declarations of that type. For example, the following definition:</source>
          <target state="translated">如果声明了属性处理程序，并且为 &lt;code&gt;:ATTR&lt;/code&gt; 说明符指定了内置类型的名称（ &lt;code&gt;SCALAR&lt;/code&gt; ， &lt;code&gt;ARRAY&lt;/code&gt; ， &lt;code&gt;HASH&lt;/code&gt; 或 &lt;code&gt;CODE&lt;/code&gt; ），则该处理程序仅应用于该类型的声明。例如，以下定义：</target>
        </trans-unit>
        <trans-unit id="62eb757e944d2fdd579513e058242369fd9ee059" translate="yes" xml:space="preserve">
          <source>If an element of</source>
          <target state="translated">如果一个元素</target>
        </trans-unit>
        <trans-unit id="34964fb1164dd648c7d2582c841b9ac59c8a6438" translate="yes" xml:space="preserve">
          <source>If an empty list, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, or nothing that matches the first 3 values above is returned, then &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks at the remaining elements of @INC. Note that this filehandle must be a real filehandle (strictly a typeglob or reference to a typeglob, whether blessed or unblessed); tied filehandles will be ignored and processing will stop there.</source>
          <target state="translated">如果返回一个空列表， &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或与上面的前三个值不匹配的任何内容，则 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 查看@INC的其余元素。请注意，此文件句柄必须是真实的文件句柄（严格来说是typeglob或对typeglob的引用，无论是有福的还是无福的）；绑定的文件句柄将被忽略，处理将在那里停止。</target>
        </trans-unit>
        <trans-unit id="e6b9ed06c157d2ccb39c11bcda5c6ea1f6b42a42" translate="yes" xml:space="preserve">
          <source>If an empty list, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, or nothing that matches the first 3 values above is returned, then &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks at the remaining elements of @INC. Note that this filehandle must be a real filehandle (strictly a typeglob or reference to a typeglob, whether blessed or unblessed); tied filehandles will be ignored and processing will stop there.</source>
          <target state="translated">如果返回一个空列表， &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或与上面的前三个值不匹配的任何内容，则 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 查看@INC的其余元素。请注意，此文件句柄必须是真实的文件句柄（严格来说是typeglob或对typeglob的引用，无论是有福的还是无福的）；绑定的文件句柄将被忽略，处理将在那里停止。</target>
        </trans-unit>
        <trans-unit id="f919dfddbef4a1a12f08337d7a834831006d9b11" translate="yes" xml:space="preserve">
          <source>If an error is encountered during conversion, output file will be removed and a warning emitted instead of terminating the conversion immediately.</source>
          <target state="translated">如果在转换过程中遇到错误,输出文件将被删除并发出警告,而不是立即终止转换。</target>
        </trans-unit>
        <trans-unit id="9714806e81ca60318ef1d507fb9add3187535d9b" translate="yes" xml:space="preserve">
          <source>If an error occurs &lt;code&gt;blocking&lt;/code&gt; will return undef and &lt;code&gt;$!&lt;/code&gt; will be set.</source>
          <target state="translated">如果发生错误， &lt;code&gt;blocking&lt;/code&gt; 将返回undef和 &lt;code&gt;$!&lt;/code&gt; 将被设置。</target>
        </trans-unit>
        <trans-unit id="223081f636c4dc0e612cdeecd4fd8749800bcc2c" translate="yes" xml:space="preserve">
          <source>If an error occurs in parsing or compilation, in most cases a valid op tree (most likely null) is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred. Some compilation errors, however, will throw an exception immediately.</source>
          <target state="translated">如果在解析或编译过程中发生错误,在大多数情况下,还是会返回一个有效的操作树(很可能是null)。错误会反映在解析器状态中,通常会在解析的顶层产生一个异常,它涵盖了所有发生的编译错误。然而,有些编译错误会立即抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="409c88cc16ea56deb3ee2fd13496f8443cdeb8ed" translate="yes" xml:space="preserve">
          <source>If an error occurs in parsing or compilation, in most cases a valid op tree is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred. Some compilation errors, however, will throw an exception immediately.</source>
          <target state="translated">如果在解析或编译过程中发生错误,在大多数情况下,还是会返回一个有效的操作树。错误会反映在解析器状态中,通常会在解析的顶层产生一个单一的异常,它涵盖了所有发生的编译错误。然而,有些编译错误会立即抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="fb3a0347b1d41b96c13bdbefc10e2d1afbf9de50" translate="yes" xml:space="preserve">
          <source>If an error occurs in parsing, which can only occur if the label is mandatory, a valid label is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred.</source>
          <target state="translated">如果在解析过程中发生错误,只有在标签是强制性的情况下才会发生,无论如何都会返回一个有效的标签。该错误会反映在解析器状态中,通常会在解析的最高层产生一个异常,该异常涵盖了所有发生的编译错误。</target>
        </trans-unit>
        <trans-unit id="d9bdcdf03abe1ba577aa0e79f3435579268caad1" translate="yes" xml:space="preserve">
          <source>If an error occurs, it SHOULD return the fragment of string that has been converted and modify $octets in-place to remove the converted part leaving it starting with the problem fragment. If perlio_ok() is true, SHOULD becomes MUST.</source>
          <target state="translated">如果发生错误,它将返回被转换的字符串片段,并在原地修改$octets以删除转换后的部分,让它从问题片段开始。如果perlio_ok()为真,SHOULD变成MUST。</target>
        </trans-unit>
        <trans-unit id="5cf7457198e3f9cd671a04a577836ab4a9017358" translate="yes" xml:space="preserve">
          <source>If an error occurs, it SHOULD return the octet sequence for the fragment of string that has been converted and modify $string in-place to remove the converted part leaving it starting with the problem fragment. If perlio_ok() is true, SHOULD becomes MUST.</source>
          <target state="translated">如果发生错误,它将返回被转换的字符串片段的八位数序列,并在原地修改$string以删除转换后的部分,使其从问题片段开始。如果perlio_ok()为真,SHOULD变成了MUST。</target>
        </trans-unit>
        <trans-unit id="0c2d11e497e2ae0afa960e508853e27c914d2845" translate="yes" xml:space="preserve">
          <source>If an existing module &lt;b&gt;almost&lt;/b&gt; does what you want, consider writing a patch, writing a subclass, or otherwise extending the existing module rather than rewriting it.</source>
          <target state="translated">如果现有模块&lt;b&gt;几乎&lt;/b&gt;可以满足您的要求，请考虑编写补丁程序，编写子类或以其他方式扩展现有模块，而不是重写它。</target>
        </trans-unit>
        <trans-unit id="82c1aacb1c3709d4e7d697aae2bed5c77802f47c" translate="yes" xml:space="preserve">
          <source>If an exit status</source>
          <target state="translated">如果退出状态</target>
        </trans-unit>
        <trans-unit id="cea12036a9c231320c44066b7b5457646bd39537" translate="yes" xml:space="preserve">
          <source>If an exit status is</source>
          <target state="translated">如果退出状态为</target>
        </trans-unit>
        <trans-unit id="e2873de2f1e9af5ea740b20953d89320900ebe0e" translate="yes" xml:space="preserve">
          <source>If an extant $SIG{__WARN__} handler is discovered, it will continue to be honored, but only after the diagnostics::splainthis() function (the module's $SIG{__WARN__} interceptor) has had its way with your warnings.</source>
          <target state="translated">如果发现了一个现存的 $SIG{__WARN__}处理程序,它将继续被尊重,但只有在 diagnostics::splainthis()函数 (模块的 $SIG{__WARN__}拦截器)处理完你的警告之后才会被尊重。</target>
        </trans-unit>
        <trans-unit id="d72e4c503af6f4a09cfa2171e2474d37da483a9b" translate="yes" xml:space="preserve">
          <source>If an extension is being built away from the perl source then MakeMaker will leave PERL_SRC undefined and default to using the installed copy of the perl library. The other variables default to the following:</source>
          <target state="translated">如果正在构建一个远离perl源码的扩展,那么MakeMaker将不定义PERL_SRC,默认使用已安装的perl库副本。其他变量默认为如下。</target>
        </trans-unit>
        <trans-unit id="a1c876b366d6c58e85d7243f2dbcbb0c36548470" translate="yes" xml:space="preserve">
          <source>If an extension is being built below the &lt;code&gt;ext/&lt;/code&gt; directory of the perl source then MakeMaker will set PERL_SRC automatically (e.g., &lt;code&gt;../..&lt;/code&gt;). If PERL_SRC is defined and the extension is recognized as a standard extension, then other variables default to the following:</source>
          <target state="translated">如果在perl源的 &lt;code&gt;ext/&lt;/code&gt; 目录下构建扩展名，那么MakeMaker将自动设置PERL_SRC（例如 &lt;code&gt;../..&lt;/code&gt; ）。如果定义了PERL_SRC并将扩展名识别为标准扩展名，则其他变量默认为以下内容：</target>
        </trans-unit>
        <trans-unit id="a0316d054e0262fb322cda466200340b0b6b9a08" translate="yes" xml:space="preserve">
          <source>If an extractor returns a defined value, that value is immediately treated as the next extracted field and pushed onto the list of fields. If the extractor was specified in a hash reference, the field is also blessed into the appropriate class,</source>
          <target state="translated">如果提取器返回一个定义的值,该值会立即被视为下一个提取的字段,并被推送到字段列表中。如果提取器是在哈希引用中指定的,该字段也会被祝福到相应的类中。</target>
        </trans-unit>
        <trans-unit id="f7e24bf211ae35444c0a5b02834d4c163f847646" translate="yes" xml:space="preserve">
          <source>If an infinity or a not-a-number is recognized, the *sp will point to one byte past the end of the recognized string. If the recognition fails, zero is returned, and the *sp will not move.</source>
          <target state="translated">如果识别出一个无穷大或非数字,*sp将指向识别出的字符串末端的一个字节。如果识别失败,则返回0,并且*sp不会移动。</target>
        </trans-unit>
        <trans-unit id="ce09f2ed6b39791e05ffc528e1a968457528299e" translate="yes" xml:space="preserve">
          <source>If an object does not support the method specified (determined using UNIVERSAL::can()) then the call will be skipped. If the method dies a warning will be generated.</source>
          <target state="translated">如果一个对象不支持指定的方法(使用UNIVERSAL::can()确定),那么调用将被跳过。如果该方法失效,则会产生一个警告。</target>
        </trans-unit>
        <trans-unit id="24adf3fb9ad8a72560fd633d7f97a817649bd630" translate="yes" xml:space="preserve">
          <source>If an operation is trapped in this way, then the code in STRING will not be executed. If such a trapped operation occurs or any other compile-time or return error, then $@ is set to the error message, just as with an eval().</source>
          <target state="translated">如果一个操作以这种方式被捕获,那么STRING中的代码将不会被执行。如果发生这样的陷阱操作或任何其他编译时或返回错误,那么$@就会被设置为错误信息,就像eval()一样。</target>
        </trans-unit>
        <trans-unit id="215592828190613f91a4fc9378ebe41cd5d2be61" translate="yes" xml:space="preserve">
          <source>If an uncaught exception results in interpreter exit, the exit code is determined from the values of &lt;code&gt;$!&lt;/code&gt; and &lt;code&gt;$?&lt;/code&gt; with this pseudocode:</source>
          <target state="translated">如果未捕获的异常导致解释器退出，则退出代码由 &lt;code&gt;$!&lt;/code&gt; 的值确定。和 &lt;code&gt;$?&lt;/code&gt; 使用此伪代码：</target>
        </trans-unit>
        <trans-unit id="7b864a885bc89443cbce8d662bf2be7249be99d8" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;test_args&lt;/code&gt; are given they will be appended to the end of the command argument list.</source>
          <target state="translated">如果给出任何 &lt;code&gt;test_args&lt;/code&gt; ，它们将被附加到命令参数列表的末尾。</target>
        </trans-unit>
        <trans-unit id="37251314e00b333d40467d467ca5c0c35c0e366e" translate="yes" xml:space="preserve">
          <source>If any argument to &lt;b&gt;podselect&lt;/b&gt; is a reference to a hash (associative array) then the values with the following keys are processed as follows:</source>
          <target state="translated">如果&lt;b&gt;podselect的&lt;/b&gt;任何参数是对哈希（关联数组）的引用，则具有以下键的值将按以下方式处理：</target>
        </trans-unit>
        <trans-unit id="0fa7b6de1acc5eb4980a2653a96afb04a72dd14b" translate="yes" xml:space="preserve">
          <source>If any arguments remain, and &lt;code&gt;GetOptionsFromString&lt;/code&gt; was not called in list context, a message will be given and &lt;code&gt;GetOptionsFromString&lt;/code&gt; will return failure.</source>
          <target state="translated">如果有任何争论依然存在，并 &lt;code&gt;GetOptionsFromString&lt;/code&gt; 没有在列表上下文中调用时，一条消息将被赋予与 &lt;code&gt;GetOptionsFromString&lt;/code&gt; 将返回失败。</target>
        </trans-unit>
        <trans-unit id="59b5cfa2ac91aed4f93a07d4f29fc54a851c06d0" translate="yes" xml:space="preserve">
          <source>If any destructors are triggered as a result, the hv itself may be freed.</source>
          <target state="translated">如果因此触发了任何破坏者,那么hv本身可能会被释放。</target>
        </trans-unit>
        <trans-unit id="dd7074163e07f37b8a41bd25ef8050c203f85577" translate="yes" xml:space="preserve">
          <source>If any directories are included in @names they are searched before @dl_library_path. Directories may be specified as &lt;b&gt;-Ldir&lt;/b&gt;. Any other names are treated as filenames to be searched for.</source>
          <target state="translated">如果@name中包含任何目录，则在@dl_library_path之前搜索它们。目录可以指定为&lt;b&gt;-Ldir&lt;/b&gt;。其他任何名称均视为要搜索的文件名。</target>
        </trans-unit>
        <trans-unit id="864b32c42a324d7506e9ca2ec49f2bbc8bbdcf83" translate="yes" xml:space="preserve">
          <source>If any element of LIST is an lvalue, you can modify it by modifying VAR inside the loop. Conversely, if any element of LIST is NOT an lvalue, any attempt to modify that element will fail. In other words, the &lt;code&gt;foreach&lt;/code&gt; loop index variable is an implicit alias for each item in the list that you're looping over.</source>
          <target state="translated">如果LIST的任何元素是左值，则可以通过在循环内修改VAR来对其进行修改。相反，如果LIST的任何元素不是左值，则任何修改该元素的尝试都将失败。换句话说， &lt;code&gt;foreach&lt;/code&gt; 循环索引变量是您要遍历的列表中每个项目的隐式别名。</target>
        </trans-unit>
        <trans-unit id="705cbac0d6d9464ed1b8a92ba681b4a46a07d153" translate="yes" xml:space="preserve">
          <source>If any list operator (&lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt;, etc.) or any unary operator (&lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;, etc.) is followed by a left parenthesis as the next token, the operator and arguments within parentheses are taken to be of highest precedence, just like a normal function call.</source>
          <target state="translated">如果任何列表运算符（ &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 等）或任何一元运算符（ &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 等）后跟左括号作为下一个标记，则括号中的运算符和参数将具有最高优先级，只是就像正常的函数调用一样。</target>
        </trans-unit>
        <trans-unit id="cec7c53718240c968018769a330928a1255918e0" translate="yes" xml:space="preserve">
          <source>If any list operator (&lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt;, etc.) or any unary operator (&lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;, etc.) is followed by a left parenthesis as the next token, the operator and arguments within parentheses are taken to be of highest precedence, just like a normal function call. For example, because named unary operators are higher precedence than &lt;code&gt;||&lt;/code&gt;:</source>
          <target state="translated">如果任何列表运算符（ &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 等）或任何一元运算符（ &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 等）后跟左括号作为下一个标记，则括号中的运算符和参数将具有最高优先级，只是就像正常的函数调用一样。例如，由于命名的一元运算符的优先级高于 &lt;code&gt;||&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b227e6f9b5d8d36337845d9688db6eb8efa3551d" translate="yes" xml:space="preserve">
          <source>If any module's own AUTOLOAD subroutine has no need to fallback to the AutoLoader's AUTOLOAD subroutine (because it doesn't have any AutoSplit subroutines), then that module should not use &lt;b&gt;AutoLoader&lt;/b&gt; at all.</source>
          <target state="translated">如果任何模块自己的AUTOLOAD子例程不需要回退到AutoLoader的AUTOLOAD子例程（因为它没有任何AutoSplit子例程），则该模块完全不应使用&lt;b&gt;AutoLoader&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="54f05d2b51008f086be29ce06ad2dc1e36ce0970" translate="yes" xml:space="preserve">
          <source>If any of the alternatives matches, the hash &lt;code&gt;%+&lt;/code&gt; is bound to contain the three key-value pairs.</source>
          <target state="translated">如果任何一个替代项都匹配，则哈希 &lt;code&gt;%+&lt;/code&gt; 绑定为包含三个键值对。</target>
        </trans-unit>
        <trans-unit id="dde2e9ba6df88b543ea738e9014946a615cc8feb" translate="yes" xml:space="preserve">
          <source>If any of the entries in an import list begins with !, : or / then the list is treated as a series of specifications which either add to or delete from the list of names to import. They are processed left to right. Specifications are in the form:</source>
          <target state="translated">如果导入列表中的任何条目以 !、:或/开头,那么该列表将被视为一系列规格,它们要么添加到要导入的名称列表中,要么从列表中删除。它们从左到右进行处理。规格的形式是:</target>
        </trans-unit>
        <trans-unit id="3fd2433b191431a7e89003ab4a4e523c3a5de0d9" translate="yes" xml:space="preserve">
          <source>If any of the file tests (or either the &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; operator) is given the special filehandle consisting of a solitary underline, then the stat structure of the previous file test (or stat operator) is used, saving a system call. (This doesn't work with &lt;code&gt;-t&lt;/code&gt; , and you need to remember that lstat() and &lt;code&gt;-l&lt;/code&gt; leave values in the stat structure for the symbolic link, not the real file.) (Also, if the stat buffer was filled by an &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; will reset it with the results of &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt; _&lt;/code&gt; ). Example:</source>
          <target state="translated">如果为任何文件测试（或 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 运算符）提供了特殊的文件句柄（由单独的下划线组成），则使用先前文件测试（或stat运算符）的stat结构，从而保存系统调用。 （这不适用于 &lt;code&gt;-t&lt;/code&gt; ，并且您需要记住lstat（）和 &lt;code&gt;-l&lt;/code&gt; 在stat结构中为符号链接而不是实际文件保留值。）（此外，如果stat缓冲区由一个 &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 调用 &lt;code&gt;-T&lt;/code&gt; 和 &lt;code&gt;-B&lt;/code&gt; 将使用 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt; _&lt;/code&gt; 的结果将其重置。例：</target>
        </trans-unit>
        <trans-unit id="c70d4afb0f7f0b8a4b2bcb0de7d2fe106cb41892" translate="yes" xml:space="preserve">
          <source>If any of the file tests (or either the &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; operator) is given the special filehandle consisting of a solitary underline, then the stat structure of the previous file test (or stat operator) is used, saving a system call. (This doesn't work with &lt;code&gt;-t&lt;/code&gt; , and you need to remember that lstat() and &lt;code&gt;-l&lt;/code&gt; leave values in the stat structure for the symbolic link, not the real file.) (Also, if the stat buffer was filled by an &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; will reset it with the results of &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt; _&lt;/code&gt; ). Example:</source>
          <target state="translated">如果为任何文件测试（或 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 运算符）提供了特殊的文件句柄（由单独的下划线组成），则使用先前文件测试（或stat运算符）的stat结构，从而保存系统调用。 （这不适用于 &lt;code&gt;-t&lt;/code&gt; ，并且您需要记住lstat（）和 &lt;code&gt;-l&lt;/code&gt; 在stat结构中为符号链接而不是实际文件保留值。）（此外，如果stat缓冲区由一个 &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 调用 &lt;code&gt;-T&lt;/code&gt; 和 &lt;code&gt;-B&lt;/code&gt; 将使用 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt; _&lt;/code&gt; 的结果将其重置。例：</target>
        </trans-unit>
        <trans-unit id="4eae7869337353cadd5cbfe4d84a955fd03cd8ba" translate="yes" xml:space="preserve">
          <source>If any of the given search directories contains a</source>
          <target state="translated">如果任何一个给定的搜索目录包含一个</target>
        </trans-unit>
        <trans-unit id="0865eba790bb7da4cb38d4fafb11a71c0ca93d75" translate="yes" xml:space="preserve">
          <source>If any of the three values is &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; that time value will not be used. So, for example, to set only the &lt;code&gt;$mtime&lt;/code&gt; you would use this</source>
          <target state="translated">如果这三个值中的任何一个为 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则将不使用该时间值。因此，例如，仅设置 &lt;code&gt;$mtime&lt;/code&gt; 使用</target>
        </trans-unit>
        <trans-unit id="341a4d7e4dbc9eeb69d34b947d58bc6f15ecb9f2" translate="yes" xml:space="preserve">
          <source>If any part of LIST is an array, &lt;code&gt;foreach&lt;/code&gt; will get very confused if you add or remove elements within the loop body, for example with &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;. So don't do that.</source>
          <target state="translated">如果LIST的任何部分是数组，则在循环体内添加或删除元素（例如，使用 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; )时， &lt;code&gt;foreach&lt;/code&gt; 会非常困惑。所以不要那样做。</target>
        </trans-unit>
        <trans-unit id="31cf9c709860eea50a338d60ff5edf1e2478723c" translate="yes" xml:space="preserve">
          <source>If applicable, please include details on what the user should do to correct the error; documenting an error as indicating &quot;the input buffer is too small&quot; without telling the user how to increase the size of the input buffer (or at least telling them that it isn't possible) aren't very useful.</source>
          <target state="translated">如果适用,请包括用户应该如何纠正错误的细节;将错误记录为表明 &quot;输入缓冲区太小&quot;,而不告诉用户如何增加输入缓冲区的大小(或至少告诉他们这是不可能的),这不是很有用。</target>
        </trans-unit>
        <trans-unit id="17ebb7f065dcd7d1005a6e70cd7fc9ddab662a16" translate="yes" xml:space="preserve">
          <source>If argument is specified, it is an advice on minimal size of line to be included into history. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; means do not include anything into history. Returns the old value.</source>
          <target state="translated">如果指定了参数，则它是关于要包含在历史记录中的最小行大小的建议。 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 表示不将任何内容纳入历史记录。返回旧值。</target>
        </trans-unit>
        <trans-unit id="fd699eb48fd240fe4a2bcf57e3a3520a6ee8d6f2" translate="yes" xml:space="preserve">
          <source>If backward compatibility for Perls under 5.6 is important, one must write instead a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; statement.</source>
          <target state="translated">如果对5.6以下的Perls的向后兼容性很重要，则必须改写 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="b7d0b9799b974e77c25f857fd60005fd09516395" translate="yes" xml:space="preserve">
          <source>If bits is 4 or less, the string is broken into bytes, then the bits of each byte are broken into 8/BITS groups. Bits of a byte are numbered in a little-endian-ish way, as in &lt;code&gt;0x01&lt;/code&gt; , &lt;code&gt;0x02&lt;/code&gt; , &lt;code&gt;0x04&lt;/code&gt; , &lt;code&gt;0x08&lt;/code&gt; , &lt;code&gt;0x10&lt;/code&gt; , &lt;code&gt;0x20&lt;/code&gt; , &lt;code&gt;0x40&lt;/code&gt; , &lt;code&gt;0x80&lt;/code&gt; . For example, breaking the single input byte &lt;code&gt;&lt;a href=&quot;chr&quot;&gt;chr(0x36)&lt;/a&gt;&lt;/code&gt; into two groups gives a list &lt;code&gt;(0x6, 0x3)&lt;/code&gt; ; breaking it into 4 groups gives &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; .</source>
          <target state="translated">如果bits为4或更少，则将字符串拆分为字节，然后将每个字节的位拆分为8 / BITS组。一个字节的位进行编号，在小尾数十岁上下的方式，为 &lt;code&gt;0x01&lt;/code&gt; ， &lt;code&gt;0x02&lt;/code&gt; ， &lt;code&gt;0x04&lt;/code&gt; ， &lt;code&gt;0x08&lt;/code&gt; ， &lt;code&gt;0x10&lt;/code&gt; ， &lt;code&gt;0x20&lt;/code&gt; ， &lt;code&gt;0x40&lt;/code&gt; 的， &lt;code&gt;0x80&lt;/code&gt; 的。例如，将单个输入字节 &lt;code&gt;&lt;a href=&quot;chr&quot;&gt;chr(0x36)&lt;/a&gt;&lt;/code&gt; 分成两组，得到一个列表 &lt;code&gt;(0x6, 0x3)&lt;/code&gt; ；将其分为4组将得到 &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77d4537f5763ddf89d58388ac5f77f55fec21e75" translate="yes" xml:space="preserve">
          <source>If bits is 4 or less, the string is broken into bytes, then the bits of each byte are broken into 8/BITS groups. Bits of a byte are numbered in a little-endian-ish way, as in &lt;code&gt;0x01&lt;/code&gt; , &lt;code&gt;0x02&lt;/code&gt; , &lt;code&gt;0x04&lt;/code&gt; , &lt;code&gt;0x08&lt;/code&gt; , &lt;code&gt;0x10&lt;/code&gt; , &lt;code&gt;0x20&lt;/code&gt; , &lt;code&gt;0x40&lt;/code&gt; , &lt;code&gt;0x80&lt;/code&gt; . For example, breaking the single input byte &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0x36)&lt;/a&gt;&lt;/code&gt; into two groups gives a list &lt;code&gt;(0x6, 0x3)&lt;/code&gt; ; breaking it into 4 groups gives &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; .</source>
          <target state="translated">如果bits为4或更少，则将字符串拆分为字节，然后将每个字节的位拆分为8 / BITS组。一个字节的位进行编号，在小尾数十岁上下的方式，为 &lt;code&gt;0x01&lt;/code&gt; ， &lt;code&gt;0x02&lt;/code&gt; ， &lt;code&gt;0x04&lt;/code&gt; ， &lt;code&gt;0x08&lt;/code&gt; ， &lt;code&gt;0x10&lt;/code&gt; ， &lt;code&gt;0x20&lt;/code&gt; ， &lt;code&gt;0x40&lt;/code&gt; 的， &lt;code&gt;0x80&lt;/code&gt; 的。例如，将单个输入字节 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0x36)&lt;/a&gt;&lt;/code&gt; 分成两组，得到一个列表 &lt;code&gt;(0x6, 0x3)&lt;/code&gt; ；将其分为4组将得到 &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf0f5d848a9043e820336aaa7c2b5b535010685b" translate="yes" xml:space="preserve">
          <source>If both arguments to &lt;code&gt;copy&lt;/code&gt; are not file handles, then &lt;code&gt;copy&lt;/code&gt; will perform a &quot;system copy&quot; of the input file to a new output file, in order to preserve file attributes, indexed file structure,</source>
          <target state="translated">如果要 &lt;code&gt;copy&lt;/code&gt; 两个参数都不是文件句柄，那么 &lt;code&gt;copy&lt;/code&gt; 将对输入文件执行&amp;ldquo;系统复制&amp;rdquo;到新的输出文件，以保留文件属性，索引文件结构，</target>
        </trans-unit>
        <trans-unit id="e9104a77e501731bf3173e5f8cc7012527cca560" translate="yes" xml:space="preserve">
          <source>If both the SIGNAL and the PROCESS are negative, the results are undefined. A warning may be produced in a future version.</source>
          <target state="translated">如果SIGNAL和PROCESS都是负数,则结果未定义。在未来的版本中可能会产生一个警告。</target>
        </trans-unit>
        <trans-unit id="43c2b718c80fc2756eb63ba9991217396d36da72" translate="yes" xml:space="preserve">
          <source>If braces are not needed to specify a property (e.g., &lt;code&gt;\pL&lt;/code&gt; ), the left column contains both forms, with and without braces.</source>
          <target state="translated">如果不需要大括号来指定属性（例如 &lt;code&gt;\pL&lt;/code&gt; ），则左列包含两种形式，带和不带大括号。</target>
        </trans-unit>
        <trans-unit id="0a4169e83148646605b11ff599e0ccd6579a7d78" translate="yes" xml:space="preserve">
          <source>If branches are involved (ie. $Revision: 1.5.3.4$) it's a little more complicated.</source>
          <target state="translated">如果涉及到分支(例如:$Revision:1.5.3.4$),那就比较复杂了。</target>
        </trans-unit>
        <trans-unit id="2c319407a62fb715df8d4d26f7931f9374106237" translate="yes" xml:space="preserve">
          <source>If building natively on PASE, please do the build under the /QOpenSys directory, since Perl is happier when built on a case sensitive filesystem.</source>
          <target state="translated">如果在PASE上原生构建,请在/QOpenSys目录下进行构建,因为Perl在大小写敏感的文件系统上构建会更快乐。</target>
        </trans-unit>
        <trans-unit id="2edb493675bf68411bac8372236ccf07c63ce62d" translate="yes" xml:space="preserve">
          <source>If building with the cross-compiler provided by mingw-w64.sourceforge.net you'll need to uncomment the line that sets GCCCROSS in the makefile.mk. Do this only if it's the cross-compiler - ie only if the bin folder doesn't contain a gcc.exe. (The cross-compiler does not provide a gcc.exe, g++.exe, ar.exe, etc. Instead, all of these executables are prefixed with 'x86_64-w64-mingw32-'.)</source>
          <target state="translated">如果使用mingw-w64.sourceforge.net提供的交叉编译器,你需要取消makefile.mk中设置GCCCROSS的那一行。只有在交叉编译器的情况下才需要这样做--即只有在bin文件夹中没有gcc.exe的情况下才需要这样做(交叉编译器不提供gcc.exe、g++.exe、ar.exe等。相反,所有这些可执行文件的前缀都是'x86_64-w64-mingw32-')。)</target>
        </trans-unit>
        <trans-unit id="9e17d613e1404f153f1b0ce16d928004818ba4b8" translate="yes" xml:space="preserve">
          <source>If by daemon process you mean one that's detached (disassociated from its tty), then the following process is reported to work on most Unixish systems. Non-Unix users should check their Your_OS::Process module for other solutions.</source>
          <target state="translated">如果你所说的守护进程是指一个分离的进程 (与它的 tty 脱钩),那么下面的进程据说可以在大多数 Unix 系统上工作。非Unix用户应该检查他们的Your_OS::Process模块以获得其他解决方案。</target>
        </trans-unit>
        <trans-unit id="f14156857ddead4c835ba55e44d3f79ccfb246a2" translate="yes" xml:space="preserve">
          <source>If by some reasons</source>
          <target state="translated">如果由于某些原因</target>
        </trans-unit>
        <trans-unit id="85a1911ef5d789d9bb6809a0f2c6b323a8f5cec0" translate="yes" xml:space="preserve">
          <source>If callbacks are used, they will be issued before this call returns.</source>
          <target state="translated">如果使用了回调,它们将在这个调用返回之前发出。</target>
        </trans-unit>
        <trans-unit id="706aad3a29650f166c943e5c886b39dcd0a4394e" translate="yes" xml:space="preserve">
          <source>If called as &lt;code&gt;sv_vcatpvfn&lt;/code&gt; or flags include &lt;code&gt;SV_GMAGIC&lt;/code&gt; , calls get magic.</source>
          <target state="translated">如果称为 &lt;code&gt;sv_vcatpvfn&lt;/code&gt; 或标志包含 &lt;code&gt;SV_GMAGIC&lt;/code&gt; ，则调用会变得神奇。</target>
        </trans-unit>
        <trans-unit id="614a0f52f1c33eb959730f1d5d32f8786b9d57d8" translate="yes" xml:space="preserve">
          <source>If called as an instance method (i.e. $md5-&amp;gt;new) it will just reset the state the object to the state of a newly created object. No new object is created in this case.</source>
          <target state="translated">如果作为实例方法（即$ md5-&amp;gt; new）调用，它将仅将对象的状态重置为新创建的对象的状态。在这种情况下，不会创建新对象。</target>
        </trans-unit>
        <trans-unit id="8679ce9e8862eb205bcd677039372fd6e97a03da" translate="yes" xml:space="preserve">
          <source>If called in a list context and the global variable &lt;code&gt;$INSTANCES&lt;/code&gt; is a true value, it will return a list of the full paths to instances of the binary where found in &lt;code&gt;PATH&lt;/code&gt; , or an empty list if it was not found.</source>
          <target state="translated">如果在列表上下文中调用并且全局变量 &lt;code&gt;$INSTANCES&lt;/code&gt; 为真值，它将返回在 &lt;code&gt;PATH&lt;/code&gt; 中找到的二进制实例的完整路径的列表，如果未找到则返回空列表。</target>
        </trans-unit>
        <trans-unit id="b8293e343dafdb403ea7c5d5ddbde243205b61a6" translate="yes" xml:space="preserve">
          <source>If called in a list context, it will return a list of the full paths to instances of the binary where found in &lt;code&gt;PATH&lt;/code&gt; , or an empty list if it was not found.</source>
          <target state="translated">如果在列表上下文中调用，它将返回在 &lt;code&gt;PATH&lt;/code&gt; 中找到的二进制实例的完整路径的列表，如果未找到，则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="522ffa67a9fbac5fe032f13cc8e4e97e4f0b245b" translate="yes" xml:space="preserve">
          <source>If called in a scalar context it will return the full path to the binary you asked for if it was found, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it was not.</source>
          <target state="translated">如果在标量上下文中调用，它将返回您要求的二进制文件的完整路径，如果找不到，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e86b593d758e5e3c8998823e4b17f5dfdc961bc" translate="yes" xml:space="preserve">
          <source>If called in scalar context, only the filehandle is returned and the file will automatically be deleted when closed on operating systems that support this (see the description of tmpfile() elsewhere in this document). This is the preferred mode of operation, as if you only have a filehandle, you can never create a race condition by fumbling with the filename. On systems that can not unlink an open file or can not mark a file as temporary when it is opened (for example, Windows NT uses the C</source>
          <target state="translated">如果在标量上下文中调用,则只返回文件柄,并且在支持此功能的操作系统上,文件将在关闭时自动删除(参见本文档其他地方对tmpfile()的描述)。这是首选的操作模式,因为如果你只有一个文件柄,你就永远无法通过摸索文件名来创造一个竞赛条件。在不能解开已打开的文件的链接或不能在打开文件时将其标记为临时文件的系统中(例如,Windows NT 使用 C</target>
        </trans-unit>
        <trans-unit id="c83187abf3e8e59deed13ec45be5007e63c321fb" translate="yes" xml:space="preserve">
          <source>If called with a property that doesn't have synonyms for its values, it returns the input value, possibly normalized with capitalization and underscores, but not necessarily checking that the input value is valid.</source>
          <target state="translated">如果用一个没有同义词的属性调用它的值,它就会返回输入值,可能会用大写和下划线规范化,但不一定会检查输入值是否有效。</target>
        </trans-unit>
        <trans-unit id="abcbf5b218ac08698c7495d3bca85cf2f5fc593a" translate="yes" xml:space="preserve">
          <source>If called with an argument &lt;code&gt;blocking&lt;/code&gt; will turn on non-blocking IO if &lt;code&gt;BOOL&lt;/code&gt; is false, and turn it off if &lt;code&gt;BOOL&lt;/code&gt; is true.</source>
          <target state="translated">如果有一个参数叫做 &lt;code&gt;blocking&lt;/code&gt; 会打开非阻塞IO如果 &lt;code&gt;BOOL&lt;/code&gt; 是假的，并关闭它，如果 &lt;code&gt;BOOL&lt;/code&gt; 是真实的。</target>
        </trans-unit>
        <trans-unit id="cd8fbca057a7b0f8546bef2e8eba78cd01155b5c" translate="yes" xml:space="preserve">
          <source>If called with an argument the &lt;code&gt;list&lt;/code&gt; returns the size of the message in octets.</source>
          <target state="translated">如果使用参数调用， &lt;code&gt;list&lt;/code&gt; 将以八位字节为单位返回消息的大小。</target>
        </trans-unit>
        <trans-unit id="d3101b42b801bc480044d4583af8814cf3a6fda1" translate="yes" xml:space="preserve">
          <source>If called without arguments a reference to a hash is returned. The keys will be the &lt;code&gt;MSGNUM&lt;/code&gt; 's of all undeleted messages and the values will be their size in octets.</source>
          <target state="translated">如果不带参数调用，则返回对哈希的引用。密钥将是所有未删除消息的 &lt;code&gt;MSGNUM&lt;/code&gt; ，其值将是它们的大小（以八位字节为单位）。</target>
        </trans-unit>
        <trans-unit id="e77963c1065ed922557c941a37ed57186c92ec48" translate="yes" xml:space="preserve">
          <source>If capturing parenthesis are used in a regular expression, we can refer to the part of the source string that was matched, and match exactly the same thing. There are three ways of referring to such</source>
          <target state="translated">如果在正则表达式中使用了捕捉小括号,我们可以引用源字符串中被匹配的部分,并匹配出完全相同的东西。有三种方式可以引用这样的</target>
        </trans-unit>
        <trans-unit id="8ef19162a844967deef3f5d85d04764641f71041" translate="yes" xml:space="preserve">
          <source>If compiled with &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; , both memory and SV allocations go through logging functions, which is handy for breakpoint setting.</source>
          <target state="translated">如果使用 &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; 进行编译，则内存和SV分配都会通过日志记录功能，这对于设置断点非常方便。</target>
        </trans-unit>
        <trans-unit id="505c257963541e6d1081b0bfdec05dc2d7991e03" translate="yes" xml:space="preserve">
          <source>If constant folding was not performed, the execution-order thread is created.</source>
          <target state="translated">如果没有进行恒定的折叠,则创建执行顺序线程。</target>
        </trans-unit>
        <trans-unit id="9c0592ae26e8bb261300ebbed2b588cacc05e4ff" translate="yes" xml:space="preserve">
          <source>If cross-compiling, this variable can be used to modify the environment on the target system. However, how and where it's used, and even if it's used at all, is entirely dependent on both the transport mechanism (targetrun) and what the target system is. Unless the relevant documentation says otherwise, it is genereally not useful.</source>
          <target state="translated">如果是交叉编译,这个变量可以用来修改目标系统上的环境,但是,如何使用,在哪里使用,甚至是否使用,完全取决于传输机制(targetrun)和目标系统是什么。然而,如何使用它,在哪里使用它,甚至是否使用它,完全取决于传输机制(targetrun)和目标系统是什么。除非相关文档中另有说明,否则它基本没有用处。</target>
        </trans-unit>
        <trans-unit id="c66c617b16e576e77dc9dc8e186d44f33fe447f3" translate="yes" xml:space="preserve">
          <source>If cross-compiling, this variable contains the location of sh on the target system. If not, this will be the same as $sh.</source>
          <target state="translated">如果是交叉编译,这个变量包含sh在目标系统中的位置。如果不交叉编译,则与$sh的位置相同。</target>
        </trans-unit>
        <trans-unit id="60357fb3a62a70cdf0b8804a617b55fe7b82dc59" translate="yes" xml:space="preserve">
          <source>If cross-compiling, this variable contains the target architecture. If not, this will be empty.</source>
          <target state="translated">如果交叉编译,这个变量包含目标架构。如果不是,这个变量将是空的。</target>
        </trans-unit>
        <trans-unit id="e5ce981aa84829db1548a6d11516c6b5fa9cbc60" translate="yes" xml:space="preserve">
          <source>If d_procselfexe is defined, $procselfexe is the filename of the symbolic link pointing to the absolute pathname of the executing program.</source>
          <target state="translated">如果定义了d_procselfexe,$procselfexe是指向执行程序绝对路径名的符号链接的文件名。</target>
        </trans-unit>
        <trans-unit id="dc4c096ee5da0f37bd52c68590795a5281826f8c" translate="yes" xml:space="preserve">
          <source>If declared at the outermost scope (the file scope), then lexicals work somewhat like C's file statics. They are available to all functions in that same file declared below them, but are inaccessible from outside that file. This strategy is sometimes used in modules to create private variables that the whole module can see.</source>
          <target state="translated">如果声明在最外层的作用域(文件作用域),那么词法的工作原理有点像C语言的文件静态。它们对在它们下面声明的同一个文件中的所有函数都是可用的,但从该文件之外是无法访问的。这种策略有时在模块中被用来创建整个模块都能看到的私有变量。</target>
        </trans-unit>
        <trans-unit id="6ae3059e06d397630c09d4c165cce518cf89f33b" translate="yes" xml:space="preserve">
          <source>If defined specifies whether color output is desired. If &lt;code&gt;color&lt;/code&gt; is not defined it will default to color output if color support is available on the current platform and output is not being redirected.</source>
          <target state="translated">如果定义，则指定是否需要颜色输出。如果 &lt;code&gt;color&lt;/code&gt; 没有定义，则默认为彩色输出，如果颜色支持可在当前平台上和输出没有被重定向。</target>
        </trans-unit>
        <trans-unit id="dc3bd5a9c7fbd30c1f819a008f41219b5c451f73" translate="yes" xml:space="preserve">
          <source>If desired, an optional hash-ref may be specified as the first argument to customize certain aspects of the parse-tree that is created and returned. The set of recognized option keywords are:</source>
          <target state="translated">如果需要,可以指定一个可选的hash-ref作为第一个参数,以自定义创建和返回的解析树的某些方面。一组公认的选项关键字是:</target>
        </trans-unit>
        <trans-unit id="c417457bb41c44d12dd8e05efc098db997c407b3" translate="yes" xml:space="preserve">
          <source>If developing modules for private internal or project specific use, that will never be released to the public, then you should ensure that their names will not clash with any future public module. You can do this either by using the reserved Local::* category or by using a category name that includes an underscore like Foo_Corp::*.</source>
          <target state="translated">如果开发的模块是供内部或项目特定使用的,并且永远不会向公众发布,那么你应该确保它们的名字不会与任何未来的公共模块冲突。你可以通过使用保留的 Local::*类别或者使用一个包含下划线的类别名称,比如 Foo_Corp::*。</target>
        </trans-unit>
        <trans-unit id="1bf0d1f77248c2c58d4104ac428f32e38cbba679" translate="yes" xml:space="preserve">
          <source>If either (or both!) is a subroutine reference, it is run and used as the value for comparing. For example:</source>
          <target state="translated">如果其中一个(或两个!)是子程序引用,则运行它并作为比较的值。例如</target>
        </trans-unit>
        <trans-unit id="0201c4d3bcdfd14f6a2e27e712be0d303b850c91" translate="yes" xml:space="preserve">
          <source>If either name is unknown, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned. Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt; &quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt; . This function does not recognize those in the property parameter, returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果其中一个名称未知，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。请注意，Perl通常会在正则表达式中以前缀名称（例如 &lt;code&gt;\p{isgc=punct}&lt;/code&gt; ）为前缀的可选 &lt;code&gt;&quot;Is_&lt;/code&gt; _&amp;rdquo;（带或不带下划线）来识别属性名称。此函数无法识别属性参数中的那些，返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3926f5454427802efbe3e6cffcb07732270c9a24" translate="yes" xml:space="preserve">
          <source>If either operand of scalar &lt;code&gt;&quot;..&quot;&lt;/code&gt; is a constant expression, that operand is considered true if it is equal (&lt;code&gt;==&lt;/code&gt; ) to the current input line number (the &lt;code&gt;$.&lt;/code&gt; variable).</source>
          <target state="translated">如果标量 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 任何一个操作数是一个常量表达式，则该操作数如果等于（ &lt;code&gt;==&lt;/code&gt; ）当前输入行号（ &lt;code&gt;$.&lt;/code&gt; 变量），则认为该操作数为true 。</target>
        </trans-unit>
        <trans-unit id="f99b132bd00ba92228931c93b4096f125672ade0" translate="yes" xml:space="preserve">
          <source>If either reader or writer is the null string, this will be replaced by an autogenerated filehandle. If so, you must pass a valid lvalue in the parameter slot so it can be overwritten in the caller, or an exception will be raised.</source>
          <target state="translated">如果reader或writer是空字符串,将被一个自动生成的filehandle替换。如果是这样,你必须在参数槽中传递一个有效的lvalue,这样它就可以在调用者中被覆盖,否则会引发异常。</target>
        </trans-unit>
        <trans-unit id="c51794930a0cb952da1b5da2c73c8a1455bd1093" translate="yes" xml:space="preserve">
          <source>If embedded documentation (in pod format, see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;) is detected in the script, &lt;code&gt;--help&lt;/code&gt; will also show how to access the documentation.</source>
          <target state="translated">如果在脚本中检测到嵌入式文档（以pod格式，请参见&lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;），则 &lt;code&gt;--help&lt;/code&gt; 还将显示如何访问文档。</target>
        </trans-unit>
        <trans-unit id="29d066b26000935ae7bb2e10a40ebaebacd4b8b0" translate="yes" xml:space="preserve">
          <source>If enabled, case is ignored when matching option names. If, however, bundling is enabled as well, single character options will be treated case-sensitive.</source>
          <target state="translated">如果启用,在匹配选项名时将忽略大小写。但如果也启用了捆绑功能,单字符选项将被区分大小写。</target>
        </trans-unit>
        <trans-unit id="db7040756e9968d1786c608e978b27880a9b3f0b" translate="yes" xml:space="preserve">
          <source>If everything else fails, you need to build a stand-alone DLL for perl. Contact me, I did it once. Sockets would not work, as a lot of other stuff.</source>
          <target state="translated">如果其他一切都失败了,你需要为perl建立一个独立的DLL。联系我,我做过一次。套接字就不行了,其他很多东西也不行。</target>
        </trans-unit>
        <trans-unit id="3a7b09ae5de32a801bf3504292c1ba7f8a26bf8f" translate="yes" xml:space="preserve">
          <source>If exception handling is all you're interested in, use one of the many CPAN modules that handle exceptions, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Try::Tiny&quot;&gt;Try::Tiny&lt;/a&gt;.</source>
          <target state="translated">如果您对异常处理感兴趣，请使用许多处理异常的CPAN模块之一，例如&lt;a href=&quot;http://search.cpan.org/perldoc/Try::Tiny&quot;&gt;Try :: Tiny&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="24299a423807f4b77a396032f4cc65f70fe49537" translate="yes" xml:space="preserve">
          <source>If explicitly enabled by</source>
          <target state="translated">如果明确启用</target>
        </trans-unit>
        <trans-unit id="8ede30fd7e2f6fae82106f61a77ef1de04cb5cb3" translate="yes" xml:space="preserve">
          <source>If false, STDERR is not captured (though it is 'relayed' to keep it somewhat synchronized with STDOUT.)</source>
          <target state="translated">如果为false,则不捕获STDERR(尽管它被 &quot;中继 &quot;以保持与STDOUT的某种同步)。</target>
        </trans-unit>
        <trans-unit id="9b5838f52003c96db3e6bffb7f5e0838c7d79e5c" translate="yes" xml:space="preserve">
          <source>If false, readline support in the debugger is disabled in order to debug applications that themselves use ReadLine.</source>
          <target state="translated">如果为false,则禁用调试器中的读线支持,以便调试本身使用ReadLine的应用程序。</target>
        </trans-unit>
        <trans-unit id="b1fe899108d979b4e6baf329c011d799eeebe85b" translate="yes" xml:space="preserve">
          <source>If filenames might use strange characters, it is safest to open it with &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is magic and can translate characters like &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt; , and &lt;code&gt;|&lt;/code&gt;, which may be the wrong thing to do. (Sometimes, though, it's the right thing.) Three-arg open can also help protect against this translation in cases where it is undesirable.</source>
          <target state="translated">如果文件名可能使用奇怪的字符，则最安全的方法是使用 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 是魔术，可以翻译 &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;|&lt;/code&gt; 等字符 ，这可能是错误的事情。（但是，有时候这是对的。）在不需要的情况下，三参数开放也可以帮助防止这种翻译。</target>
        </trans-unit>
        <trans-unit id="5ca04d4d675b32f985d24c749a113dd2e8503548" translate="yes" xml:space="preserve">
          <source>If find is used in taint-mode (-T command line switch or if EUID != UID or if EGID != GID) then internally directory names have to be untainted before they can be chdir'ed to. Therefore they are checked against a regular expression</source>
          <target state="translated">如果find是在污点模式下使用的(-T命令行开关或EUID !=UID或EGID !=GID),那么内部的目录名在被chdir'ed之前必须是未被污染的。因此,它们会根据正则表达式进行检查</target>
        </trans-unit>
        <trans-unit id="ae542d10e971a673bbde2971d115357debc351d4" translate="yes" xml:space="preserve">
          <source>If flags contains PERL_PV_ESCAPE_QUOTE then any double quotes in the string will also be escaped.</source>
          <target state="translated">如果flags包含PERL_PV_ESCAPE_QUOTE,那么字符串中的任何双引号也将被转义。</target>
        </trans-unit>
        <trans-unit id="5f11c4bbd633be0ac4ec3da7d6d4106626b272c7" translate="yes" xml:space="preserve">
          <source>If for some reason you want to have complete control over the data connection, this includes generating it and calling the &lt;code&gt;response&lt;/code&gt; method when required, then the user can use these methods to do so.</source>
          <target state="translated">如果出于某种原因要完全控制数据连接（包括生成数据并在需要时调用 &lt;code&gt;response&lt;/code&gt; 方法），则用户可以使用这些方法来进行控制。</target>
        </trans-unit>
        <trans-unit id="33f20d3ebb86a1fb4909973670b43aa80acbb4c8" translate="yes" xml:space="preserve">
          <source>If hash values couldn't be lists, you lose. You'd probably have to combine all the cities into a single string somehow, and then when time came to write the output, you'd have to break the string into a list, sort the list, and turn it back into a string. This is messy and error-prone. And it's frustrating, because Perl already has perfectly good lists that would solve the problem if only you could use them.</source>
          <target state="translated">如果哈希值不能是列表,你就输了。你可能不得不以某种方式将所有的城市合并成一个单一的字符串,然后当写输出的时候,你必须将字符串分解成一个列表,对列表进行排序,然后再将它变成一个字符串。这很乱,而且容易出错。而且这很令人沮丧,因为Perl已经有了完美的列表,只要你能使用它们就能解决这个问题。</target>
        </trans-unit>
        <trans-unit id="7e8d248524799b9e3f004b01925fdada9567cc4f" translate="yes" xml:space="preserve">
          <source>If i&amp;lt;checked_at&amp;gt; is a reference to a scalar, then instead it gives the characters pre-checked at the beginning, (and the number of chars by which the C variable name has been advanced. These need to be chopped from the front of</source>
          <target state="translated">如果i &amp;lt;checked_at&amp;gt;是对标量的引用，那么它会在开头提供预先检查的字符（以及C变量名称已使用的字符数。这些字符必须从前面截去）</target>
        </trans-unit>
        <trans-unit id="0cd56861a4473054d59049046296e1c9cc1b21dc" translate="yes" xml:space="preserve">
          <source>If illegalproto warnings are enabled, the prototype declared inside this attribute will be sanity checked at compile time.</source>
          <target state="translated">如果启用了 illegalproto 警告,那么在此属性中声明的原型将在编译时进行理智检查。</target>
        </trans-unit>
        <trans-unit id="4d3aefb53a3e40d895443465bbfd3168415b47af" translate="yes" xml:space="preserve">
          <source>If in doubt, break the expression into simpler terms, or cast all operands to the desired resulting type.</source>
          <target state="translated">如果有疑问,可以将表达式分解成更简单的语句,或者将所有操作数转为所需的结果类型。</target>
        </trans-unit>
        <trans-unit id="ce224243c2c27e9c319eeded5da4d7520f7a48e0" translate="yes" xml:space="preserve">
          <source>If instead of the recommended GNU make you would like to use the system supplied make program then be sure to install the default rules file properly via the shell command:</source>
          <target state="translated">如果你不想使用推荐的GNU make,而想使用系统提供的make程序,那么一定要通过shell命令正确安装默认规则文件。</target>
        </trans-unit>
        <trans-unit id="8c224a826076db854fafc0daefe6f5025badc4ce" translate="yes" xml:space="preserve">
          <source>If instead you intended to match the word 'foo' at the end of the line followed by whitespace and the word 'bar' on the next line then you can use &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/$(?)\/&lt;/a&gt;&lt;/code&gt; (for example: &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo$(?)\s+bar/&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">相反，如果您打算在行的末尾匹配单词&amp;ldquo; foo&amp;rdquo;，然后在下一行匹配单词&amp;ldquo; bar&amp;rdquo;，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/$(?)\/&lt;/a&gt;&lt;/code&gt; （例如： &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo$(?)\s+bar/&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d03def7cbe4cc9c7f39111662b050f07a1bc1197" translate="yes" xml:space="preserve">
          <source>If instead you want to sort the array @key with the comparison routine &lt;code&gt;find_records()&lt;/code&gt; then you can use:</source>
          <target state="translated">相反，如果您想使用比较例程 &lt;code&gt;find_records()&lt;/code&gt; 对@key数组进行排序，则可以使用：</target>
        </trans-unit>
        <trans-unit id="d1fc62400435ca2b18e437e1de72ea45d0c40705" translate="yes" xml:space="preserve">
          <source>If invalid, a &lt;code&gt;Malformed UTF-8 character&lt;/code&gt; warning is produced. The &quot;C0&quot; means &quot;process the string character per character&quot;. Without that, the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U*&quot;, ...)&lt;/code&gt; would work in &lt;code&gt;U0&lt;/code&gt; mode (the default if the format string starts with &lt;code&gt;U&lt;/code&gt; ) and it would return the bytes making up the UTF-8 encoding of the target string, something that will always work.</source>
          <target state="translated">如果无效，则会生成 &lt;code&gt;Malformed UTF-8 character&lt;/code&gt; 警告。&amp;ldquo; C0&amp;rdquo;的意思是&amp;ldquo;处理每个字符的字符串字符&amp;rdquo;。否则， &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U*&quot;, ...)&lt;/code&gt; 将在 &lt;code&gt;U0&lt;/code&gt; 模式下运行（如果格式字符串以 &lt;code&gt;U&lt;/code&gt; 开头，则为默认值），它将返回组成目标字符串UTF-8编码的字节。那将永远有效。</target>
        </trans-unit>
        <trans-unit id="51c33e52f177d40ae2c3679305c70e4a9572745e" translate="yes" xml:space="preserve">
          <source>If it ain't broke, don't fix it! Perl 4 library scripts should continue to work with no problems. You may need to make some minor changes (like escaping non-array @'s in double quoted strings) but there is no need to convert a .pl file into a Module for just that.</source>
          <target state="translated">如果它没有坏,就不要去修它! Perl 4 库脚本应该可以继续工作,不会有任何问题。你可能需要做一些小的改动(比如在双引号字符串中转义非数组的@),但不需要为此而将.pl文件转换为模块。</target>
        </trans-unit>
        <trans-unit id="5ae3aaa5715ffc32724b48d8610f7a354399dcc4" translate="yes" xml:space="preserve">
          <source>If it does not yet provide support for any encoding, one could write a derived class with such a &lt;code&gt;param&lt;/code&gt; method:</source>
          <target state="translated">如果尚不支持任何编码，则可以使用这种 &lt;code&gt;param&lt;/code&gt; 方法编写派生类：</target>
        </trans-unit>
        <trans-unit id="6ed0026aa4685c99082bcd85012c95fb26671228" translate="yes" xml:space="preserve">
          <source>If it is defined and perl is compiled with the C macro &lt;code&gt;DL_UNLOAD_ALL_AT_EXIT&lt;/code&gt; defined, then it is called automatically when the interpreter exits for every shared object or library loaded by DynaLoader::bootstrap. All such library references are stored in @dl_librefs by DynaLoader::Bootstrap as it loads the libraries. The files are unloaded in last-in, first-out order.</source>
          <target state="translated">如果已定义并且用定义的C宏 &lt;code&gt;DL_UNLOAD_ALL_AT_EXIT&lt;/code&gt; 编译perl ，则当解释器针对DynaLoader :: bootstrap加载的每个共享对象或库退出时，将自动调用它。所有此类库引用在加载库时由DynaLoader :: Bootstrap存储在@dl_librefs中。文件以后进先出的顺序卸载。</target>
        </trans-unit>
        <trans-unit id="860a9992a29a5bed07a92916afafcc39c4466897" translate="yes" xml:space="preserve">
          <source>If it is important to you that your bug be fixed, do monitor the perl5-porters@perl.org mailing list (mailing lists are moderated, your message may take a while to show up) and the commit logs to development versions of Perl, and encourage the maintainers with kind words or offers of frosty beverages. (Please do be kind to the maintainers. Harassing or flaming them is likely to have the opposite effect of the one you want.)</source>
          <target state="translated">如果您希望您的 bug 得到修正,请关注 perl5-porters@perl.org 邮件列表 (邮件列表是有版主的,您的信息可能需要一段时间才能显示出来),以及 Perl 开发版本的提交日志,并鼓励维护者说些好话或提供冰冻饮料。(请对维护者友好一点。骚扰或抨击他们很可能会产生你想要的相反效果)。)</target>
        </trans-unit>
        <trans-unit id="835fcc1c62a963fd6a71d84d2861d08fa2d6dba4" translate="yes" xml:space="preserve">
          <source>If it is impossible to tell from the parameters passed back from the C callback what the context is, then you may need to create a sequence of C callback interface functions, and store pointers to each in an array.</source>
          <target state="translated">如果无法从C回调传回的参数中判断出上下文是什么,那么你可能需要创建一个C回调接口函数序列,并将每个函数的指针存储在一个数组中。</target>
        </trans-unit>
        <trans-unit id="5680f195fb6f8f7119b1a5d53970a5a24089ffc3" translate="yes" xml:space="preserve">
          <source>If it is intended that a new perl binary be produced, this variable may hold a name for that binary. Defaults to perl</source>
          <target state="translated">如果打算生成一个新的perl二进制文件,这个变量可以存放该二进制文件的名称。默认值为perl</target>
        </trans-unit>
        <trans-unit id="cb1ca7ba722f679f82900212b2623b7a140c3fd8" translate="yes" xml:space="preserve">
          <source>If it persists, you may disable this warnings, see &lt;a href=&quot;#PERL_BADFREE&quot;&gt;PERL_BADFREE&lt;/a&gt;.</source>
          <target state="translated">如果仍然存在，则可以禁用此警告，请参阅&lt;a href=&quot;#PERL_BADFREE&quot;&gt;PERL_BADFREE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3596d2c66fdea5d09f2cf7238ff867c93df8d69a" translate="yes" xml:space="preserve">
          <source>If it runs thru the entire given list of language-tags, and finds no classes for those exact terms, it then tries &quot;superordinate&quot; language classes. So if no &quot;en-US&quot; class (i.e., YourProjClass::en_us) was found, nor classes for anything else in that list, we then try its superordinate, &quot;en&quot; (i.e., YourProjClass::en), and so on thru the other language-tags in the given list: &quot;es&quot;. (The other language-tags in our example list: happen to have no superordinates.)</source>
          <target state="translated">如果它运行了整个给定的语言标签列表,并且没有找到这些术语的类,它就会尝试 &quot;上级 &quot;语言类。因此,如果没有找到 &quot;en-US &quot;类(即 YourProjClass::en_us),也没有找到列表中其他语言的类,我们就会尝试它的上级类 &quot;en&quot;(即 YourProjClass::en),以此类推,在给定列表中的其他语言标记。&quot;es&quot;。(在我们的示例列表中的其他语言标记:恰好没有上级。)</target>
        </trans-unit>
        <trans-unit id="9e9c27ad93f7400ed6fd8cabde972a2941b1fcc1" translate="yes" xml:space="preserve">
          <source>If it's a regular enough string that it always has the same format, you can split it up and pass the parts to &lt;code&gt;timelocal&lt;/code&gt; in the standard &lt;a href=&quot;time/local&quot;&gt;Time::Local&lt;/a&gt; module. Otherwise, you should look into the &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Parse&quot;&gt;Date::Parse&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date::Manip&lt;/a&gt; modules from CPAN.</source>
          <target state="translated">如果它是一个足够常规的字符串，始终具有相同的格式，则可以将其拆分，然后将这些部分传递给标准&lt;a href=&quot;time/local&quot;&gt;Time :: Local&lt;/a&gt;模块中的 &lt;code&gt;timelocal&lt;/code&gt; 。否则，您应该查看CPAN中的&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Parse&quot;&gt;Date :: Parse&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date :: Manip&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="95cd7c9791eb757b708be268b21d99a1603edf51" translate="yes" xml:space="preserve">
          <source>If it's run from a terminal,</source>
          <target state="translated">如果是在终端运行。</target>
        </trans-unit>
        <trans-unit id="8ec1e5cfa3f1d5f23853bddc58974b89d51e4343" translate="yes" xml:space="preserve">
          <source>If linking miniperl</source>
          <target state="translated">如果连接miniperl</target>
        </trans-unit>
        <trans-unit id="4bdbff6d4225cd79b23186ed9cad6253292a76ca" translate="yes" xml:space="preserve">
          <source>If locale matching rules are in effect, the case map is taken from the current locale for code points less than 255, and from Unicode rules for larger code points. However, matches that would cross the Unicode rules/non-Unicode rules boundary (ords 255/256) will not succeed. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">如果有效的语言环境匹配规则，则对于小于255的代码点，从当前语言环境获取案例映射，对于较大的代码点，则从Unicode规则获取案例映射。但是，将跨越Unicode规则/非Unicode规则边界（ords 255/256）的匹配将不会成功。参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="763f933c48615038adc7019dfce8f6c0c593c306" translate="yes" xml:space="preserve">
          <source>If locale rules are not in effect, the use of a Unicode property will force the regular expression into using Unicode rules, if it isn't already.</source>
          <target state="translated">如果locale规则没有生效,使用Unicode属性将迫使正则表达式使用Unicode规则,如果它还没有生效的话。</target>
        </trans-unit>
        <trans-unit id="d834fc3f63056ccac9737e1620e9488be6eb7541" translate="yes" xml:space="preserve">
          <source>If maketext goes to look in an individual %Lexicon for an entry for</source>
          <target state="translated">如果maketext在一个单独的%Lexicon中寻找一个条目,那么这个条目就是</target>
        </trans-unit>
        <trans-unit id="3e3dcee3a8b9bd973fa29d705bfdb80867c80c81" translate="yes" xml:space="preserve">
          <source>If many functions use the same failure indication based on the return value, you may want to create a special typedef to handle this situation. Put</source>
          <target state="translated">如果许多函数基于返回值使用相同的失败指示,你可能需要创建一个特殊的类型定义来处理这种情况。把</target>
        </trans-unit>
        <trans-unit id="b606db88e20200612d730cc961241a27da21957f" translate="yes" xml:space="preserve">
          <source>If module is installed, peeks into the module's manpage, reads the headline, and returns it. Moreover, if the module has been downloaded within this session, does the equivalent on the downloaded module even if it hasn't been installed yet.</source>
          <target state="translated">如果模块已经安装好,就进入模块的manpage,读取标题,然后返回。此外,如果在这个会话中下载了模块,即使还没有安装,也会在下载的模块上做相应的操作。</target>
        </trans-unit>
        <trans-unit id="dd58d8ff347dcd8c05f67e1fd3ee4d2440157ff1" translate="yes" xml:space="preserve">
          <source>If more arguments are provided then they are all appended to the message, thus all these lines will have the same effect on the state of the $ctx object:</source>
          <target state="translated">如果提供了更多的参数,那么它们都会被附加到消息中,因此所有这些行将对$ctx对象的状态产生同样的影响。</target>
        </trans-unit>
        <trans-unit id="d7d32d6074826a3d2d75814ea308b5ddeaca2f3c" translate="yes" xml:space="preserve">
          <source>If more delimiters than escape chars are specified, the last escape char is used for the remaining delimiters. If no escape char is specified for a given specified delimiter, '\' is used.</source>
          <target state="translated">如果指定的定界符比转义符多,那么剩余的定界符将使用最后一个转义符。如果没有为指定的定界符指定转义字符,则使用'\'。</target>
        </trans-unit>
        <trans-unit id="285c13c421c908ec1b5157ff1d11ce664fe6f585" translate="yes" xml:space="preserve">
          <source>If more than one argument is given then the entire argument list is assumed to be a hash. If a hash is supplied (either as a reference or as a list) it should contain one or more elements with the following keys:</source>
          <target state="translated">如果给出了一个以上的参数,那么整个参数列表被认为是一个哈希值。如果提供了一个哈希值(无论是作为参考还是作为一个列表),它应该包含一个或多个具有以下键的元素:</target>
        </trans-unit>
        <trans-unit id="39e41b545db315dc5126671cc2bd5d88f5c30e3d" translate="yes" xml:space="preserve">
          <source>If more than one restriction of &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;distribution&lt;/code&gt; , etc. is specified, the results of the separately computed match values must all match. If so, the hashref represented by the YAML document is returned as the preference structure for the current distribution.</source>
          <target state="translated">如果指定了 &lt;code&gt;module&lt;/code&gt; ， &lt;code&gt;distribution&lt;/code&gt; 等多个限制，则分别计算的匹配值的结果必须全部匹配。如果是这样，则返回YAML文档表示的hashref作为当前分发的首选项结构。</target>
        </trans-unit>
        <trans-unit id="da05e2a6f3037e503e2698db0f33736532af13ae" translate="yes" xml:space="preserve">
          <source>If more than one variable is listed, the list must be placed in parentheses.</source>
          <target state="translated">如果列出了多个变量,则必须将列表放在括号中。</target>
        </trans-unit>
        <trans-unit id="5915108dabbdb47d0e6487842fce0264a4b8c92e" translate="yes" xml:space="preserve">
          <source>If more than one variable is listed, the list must be placed in parentheses. With a parenthesised list, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder. However, since initialization of state variables in list context is currently not possible this would serve no purpose.</source>
          <target state="translated">如果列出了多个变量，则该列表必须放在括号中。使用带括号的列表， &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 可以用作虚拟占位符。但是，由于当前无法在列表上下文中初始化状态变量，因此这将毫无用处。</target>
        </trans-unit>
        <trans-unit id="13f0dd65ec56750a188884a636ba7b4f0428367d" translate="yes" xml:space="preserve">
          <source>If more than one variable is listed, the list must be placed in parentheses. With a parenthesised list, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder. However, since initialization of state variables in list context is currently not possible this would serve no purpose.</source>
          <target state="translated">如果列出了多个变量，则该列表必须放在括号中。使用带括号的列表， &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 可以用作虚拟占位符。但是，由于当前无法在列表上下文中初始化状态变量，因此这将毫无用处。</target>
        </trans-unit>
        <trans-unit id="cc246b70384e8a417eb59e4e6e4575312d9d1e0a" translate="yes" xml:space="preserve">
          <source>If more than one variable or expression is given to &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;, they must be placed in parentheses. This operator works by saving the current values of those variables in its argument list on a hidden stack and restoring them upon exiting the block, subroutine, or eval. This means that called subroutines can also reference the local variable, but not the global one. The argument list may be assigned to if desired, which allows you to initialize your local variables. (If no initializer is given for a particular variable, it is created with an undefined value.)</source>
          <target state="translated">如果将多个变量或表达式赋给 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ，则必须将它们放在括号中。该运算符的工作方式是将这些变量的当前值保存在其参数列表中的隐藏堆栈中，并在退出块，子例程或eval时恢复它们。这意味着被调用的子例程也可以引用局部变量，但不能引用全局变量。如果需要，可以将参数列表分配给它，这使您可以初始化局部变量。（如果未为特定变量提供初始化程序，则会使用未定义的值来创建它。）</target>
        </trans-unit>
        <trans-unit id="e6e3db41fbfcf6140e9c02e059dd4c934fd6f5ad" translate="yes" xml:space="preserve">
          <source>If multiple distinct capture groups have the same name then the $+{NAME} will refer to the leftmost defined group in the match.</source>
          <target state="translated">如果多个不同的捕获组具有相同的名称,那么$+{NAME}将引用匹配中最左边的定义组。</target>
        </trans-unit>
        <trans-unit id="0bfee97a70420feb4c2945973c34123d251dd9c2" translate="yes" xml:space="preserve">
          <source>If multiple files from one program are desired an array ref can be used.</source>
          <target state="translated">如果需要一个程序中的多个文件,可以使用数组引用。</target>
        </trans-unit>
        <trans-unit id="081ad6caef0052cfab1aad2ae1061ca747e43248" translate="yes" xml:space="preserve">
          <source>If multiple transliterations are given for a character, only the first one is used:</source>
          <target state="translated">如果一个字符有多个音译,则只使用第一个音译。</target>
        </trans-unit>
        <trans-unit id="766c6735ff098a4b925a773897fe49012fa4895d" translate="yes" xml:space="preserve">
          <source>If name passed in doesn't specify a readable file, appends</source>
          <target state="translated">如果传入的文件名没有指定可读的文件,则添加</target>
        </trans-unit>
        <trans-unit id="1afec739c7f1e924deac0edbd4a6af96f74019ce" translate="yes" xml:space="preserve">
          <source>If necessary switch the input stream to handle unicode. This only has any effect for I/O handle based streams.</source>
          <target state="translated">如果需要,将输入流切换为处理unicode。这只对基于I/O句柄的流有影响。</target>
        </trans-unit>
        <trans-unit id="1f88753647459114bf0fff92153d71fa3be1ef0c" translate="yes" xml:space="preserve">
          <source>If needed, &lt;code&gt;$new_size&lt;/code&gt; will be rounded up to the next multiple of the memory page size (usually 4096 or 8192).</source>
          <target state="translated">如果需要， &lt;code&gt;$new_size&lt;/code&gt; 将舍入到内存页面大小的下一个倍数（通常为4096或8192）。</target>
        </trans-unit>
        <trans-unit id="13ffb9e8f4aa9a45a3175ee9916b5d80efc23ef5" translate="yes" xml:space="preserve">
          <source>If needed, a thread can be exited at any time by calling &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; . This will cause the thread to return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in a scalar context, or the empty list in a list context.</source>
          <target state="translated">如果需要，可以通过调用 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; 随时退出线程。这将导致线程在标量上下文中返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，或者在列表上下文中返回空列表。</target>
        </trans-unit>
        <trans-unit id="ba4f2509d5dd63a76d44f087cc7f42f7f77c757a" translate="yes" xml:space="preserve">
          <source>If needed, scripts can be written so as to run on both threaded and non-threaded Perls:</source>
          <target state="translated">如果需要,可以编写脚本,以便在有线程和无线程的Perls上运行。</target>
        </trans-unit>
        <trans-unit id="91fbdba912e7cde9b89fa3cefbc9b3e7d8d65343" translate="yes" xml:space="preserve">
          <source>If needed, these methods should be defined by the package inheriting from &lt;b&gt;Tie::Hash&lt;/b&gt;, &lt;b&gt;Tie::StdHash&lt;/b&gt;, or &lt;b&gt;Tie::ExtraHash&lt;/b&gt;. See &lt;a href=&quot;../perltie#SCALAR&quot;&gt;SCALAR in perltie&lt;/a&gt; to find out what happens when &lt;code&gt;SCALAR&lt;/code&gt; does not exist.</source>
          <target state="translated">如果需要，这些方法应该由继承自&lt;b&gt;Tie :: Hash&lt;/b&gt;，&lt;b&gt;Tie :: StdHash&lt;/b&gt;或&lt;b&gt;Tie :: ExtraHash&lt;/b&gt;的包定义。有关详细信息，请参见&lt;a href=&quot;../perltie#SCALAR&quot;&gt;SCALAR，&lt;/a&gt;以查找不存在 &lt;code&gt;SCALAR&lt;/code&gt; 时发生的情况。</target>
        </trans-unit>
        <trans-unit id="f7a52a7ddea6d450e656d921a0db2fecb1485c60" translate="yes" xml:space="preserve">
          <source>If needed, thread warnings can be suppressed by using:</source>
          <target state="translated">如果需要,线程警告可以通过使用。</target>
        </trans-unit>
        <trans-unit id="7b8270c68932b39381b724db912d7e0064edb351" translate="yes" xml:space="preserve">
          <source>If neither the &lt;code&gt;-L&lt;/code&gt; or &lt;code&gt;-l&lt;/code&gt; prefix is present in an entry, the entry is considered a directory to search if it is in fact a directory, and a library to search for otherwise. The &lt;code&gt;$Config{lib_ext}&lt;/code&gt; suffix will be appended to any entries that are not directories and don't already have the suffix.</source>
          <target state="translated">如果条目中没有 &lt;code&gt;-L&lt;/code&gt; 或 &lt;code&gt;-l&lt;/code&gt; 前缀，则该条目实际上是目录，将被视为目录，否则将被视为库。在 &lt;code&gt;$Config{lib_ext}&lt;/code&gt; 后缀将追加到不属于目录，还没有后缀的所有条目。</target>
        </trans-unit>
        <trans-unit id="33d1d1804f2f0f5f5a1b0fb679650c8cfecd87fb" translate="yes" xml:space="preserve">
          <source>If neither the exit status nor the verbose level is specified, then the default is to use an exit status of 2 with a verbose level of 0.</source>
          <target state="translated">如果既不指定退出状态,也不指定verbose级别,则默认使用退出状态为2,verbose级别为0。</target>
        </trans-unit>
        <trans-unit id="ca010fd55b822b0537501828b1432d2b69dedb67" translate="yes" xml:space="preserve">
          <source>If neither your configured &lt;code&gt;yaml_module&lt;/code&gt; nor YAML.pm is installed, CPAN.pm falls back to using Data::Dumper and Storable and looks for files with the extensions &lt;code&gt;.dd&lt;/code&gt; or &lt;code&gt;.st&lt;/code&gt; in the &lt;code&gt;prefs_dir&lt;/code&gt; directory. These files are expected to contain one or more hashrefs. For Data::Dumper generated files, this is expected to be done with by defining &lt;code&gt;$VAR1&lt;/code&gt; , &lt;code&gt;$VAR2&lt;/code&gt; , etc. The YAML shell would produce these with the command</source>
          <target state="translated">如果未安装配置的 &lt;code&gt;yaml_module&lt;/code&gt; 或YAML.pm，则CPAN.pm将退回到使用Data :: Dumper和Storable的位置，并在 &lt;code&gt;prefs_dir&lt;/code&gt; 目录中查找扩展名为 &lt;code&gt;.dd&lt;/code&gt; 或 &lt;code&gt;.st&lt;/code&gt; 的文件。这些文件应包含一个或多个哈希引用。对于Data :: Dumper生成的文件，可以通过定义 &lt;code&gt;$VAR1&lt;/code&gt; ， &lt;code&gt;$VAR2&lt;/code&gt; 等来完成。YAML shell将使用以下命令生成这些文件：</target>
        </trans-unit>
        <trans-unit id="1ff3f3f68e857a065a27224d0e20ede58778f1ae" translate="yes" xml:space="preserve">
          <source>If new() is called as an instance method (i.e. $ctx-&amp;gt;new) it will just reset the state the object to the state of a newly created object. No new object is created in this case, and the return value is the reference to the object (i.e. $ctx).</source>
          <target state="translated">如果将new（）作为实例方法（即$ ctx-&amp;gt; new）调用，它将仅将对象的状态重置为新创建的对象的状态。在这种情况下，不会创建新对象，并且返回值是该对象的引用（即$ ctx）。</target>
        </trans-unit>
        <trans-unit id="2e13ee0a65adecfa0d8e7d8968c5c8fbe048cddb" translate="yes" xml:space="preserve">
          <source>If no $default is provided an empty string will be used instead.</source>
          <target state="translated">如果没有提供$default,将使用一个空字符串代替。</target>
        </trans-unit>
        <trans-unit id="0472c17854436e8327aa450d7bb9d0ca29c0fa4c" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;$VERSION&lt;/code&gt; was specified on the &lt;code&gt;bootstrap&lt;/code&gt; line, the last line becomes</source>
          <target state="translated">如果在 &lt;code&gt;bootstrap&lt;/code&gt; 行上未指定 &lt;code&gt;$VERSION&lt;/code&gt; ，则最后一行变为</target>
        </trans-unit>
        <trans-unit id="1b4091cfd69b61e159053e0bbc2425f479136432" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;$section_spec&lt;/code&gt; arguments are given, then the existing set of selected sections is cleared out (which means &lt;code&gt;all&lt;/code&gt; sections will be processed).</source>
          <target state="translated">如果没有给出 &lt;code&gt;$section_spec&lt;/code&gt; 参数，那么将清除现有的选定节集（这意味着将处理 &lt;code&gt;all&lt;/code&gt; 节）。</target>
        </trans-unit>
        <trans-unit id="c0be16a9153a991182a683ab2886f1fa902dd9f4" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; is found and if the last statement is an expression, its value is returned. If the last statement is a loop control structure like a &lt;code&gt;foreach&lt;/code&gt; or a &lt;code&gt;while&lt;/code&gt; , the returned value is unspecified. The empty sub returns the empty list.</source>
          <target state="translated">如果未找到 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 值，并且最后一条语句是表达式，则返回其值。如果最后一条语句是诸如 &lt;code&gt;foreach&lt;/code&gt; 或 &lt;code&gt;while&lt;/code&gt; 的循环控制结构，则返回的值不确定。空子返回空列表。</target>
        </trans-unit>
        <trans-unit id="bf9cd2f55bd05fa55b1648853a5a5e34325f19ca" translate="yes" xml:space="preserve">
          <source>If no @args are given, no @cmds will be returned.</source>
          <target state="translated">如果没有给出@args,将不会返回@cmds。</target>
        </trans-unit>
        <trans-unit id="d11be4d28581ad6cd28ff2cca82d45474710696d" translate="yes" xml:space="preserve">
          <source>If no MANIFEST.SKIP file is found, a default set of skips will be used, similar to the example above. If you want nothing skipped, simply make an empty MANIFEST.SKIP file.</source>
          <target state="translated">如果没有找到 MANIFEST.SKIP 文件,将使用默认的跳过集,类似于上面的例子。如果你不想跳过任何东西,只需制作一个空的 MANIFEST.SKIP 文件。</target>
        </trans-unit>
        <trans-unit id="cae10c8870eae9f10da944c7a01e813768cc713b" translate="yes" xml:space="preserve">
          <source>If no arguments are given to pod2man it will read from @ARGV.</source>
          <target state="translated">如果没有给pod2man提供参数,它将从@ARGV读取。</target>
        </trans-unit>
        <trans-unit id="87c6b87283ba7c4ecec068cb48f3ae13420b59ed" translate="yes" xml:space="preserve">
          <source>If no arguments are given, &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; returns the entire formatted archive as a string, which could be useful if you'd like to stuff the archive into a socket or a pipe to gzip or something.</source>
          <target state="translated">如果未提供任何参数， &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 将以字符串形式返回整个格式化的归档文件，如果您想将归档文件放入套接字或通向gzip的管道中，则可能很有用。</target>
        </trans-unit>
        <trans-unit id="886a141165f04df6d6f369bc4c3d2d482bb6efce" translate="yes" xml:space="preserve">
          <source>If no arguments are passed then the current article in the currently selected newsgroup is fetched.</source>
          <target state="translated">如果没有传递任何参数,那么将获取当前所选新闻组中的当前文章。</target>
        </trans-unit>
        <trans-unit id="ddc296f09027fdaaecb023b3cebc4e9cba37abbb" translate="yes" xml:space="preserve">
          <source>If no extension is supplied, and your system supports it, the original</source>
          <target state="translated">如果没有提供任何扩展,而你的系统又支持它,那么原来的</target>
        </trans-unit>
        <trans-unit id="85c571c913f7bfa21e872b065c24a094b4bb7659" translate="yes" xml:space="preserve">
          <source>If no files or directories are supplied, &lt;code&gt;prove&lt;/code&gt; looks for all files matching the pattern &lt;code&gt;t/*.t&lt;/code&gt;.</source>
          <target state="translated">如果未提供文件或目录，则 &lt;code&gt;prove&lt;/code&gt; 查找与模式 &lt;code&gt;t/*.t&lt;/code&gt; 。t匹配的所有文件。</target>
        </trans-unit>
        <trans-unit id="cea57f19921408109bb2fb4d00e16350d27b4844" translate="yes" xml:space="preserve">
          <source>If no import list is supplied, all possible VMS-specific features are assumed. Currently, there are four VMS-specific features available: 'status' (a.k.a '$?'), 'exit', 'time' and 'hushed'.</source>
          <target state="translated">如果没有提供导入列表,则假定所有可能的VMS特定特性。目前,有四个VMS特有的特性:'status'(又名'$?')、'exit'、'time'和'hushed'。</target>
        </trans-unit>
        <trans-unit id="d4ceff2a6aadec6052244b97bba7012539a0b105" translate="yes" xml:space="preserve">
          <source>If no import list is supplied, all possible restrictions are assumed. (This is the safest mode to operate in, but is sometimes too strict for casual programming.) Currently, there are three possible things to be strict about: &quot;subs&quot;, &quot;vars&quot;, and &quot;refs&quot;.</source>
          <target state="translated">如果没有提供导入列表,则假设所有可能的限制。(这是最安全的操作模式,但对于随意编程来说,有时过于严格。)目前,有三种可能的东西需要严格。&quot;subs&quot;、&quot;vars &quot;和 &quot;refs&quot;。</target>
        </trans-unit>
        <trans-unit id="c1d6512b9a9d5a5a9bf4112bcb1e3a393263f0b9" translate="yes" xml:space="preserve">
          <source>If no items exists at the specified index (i.e., the queue is empty, or the index is beyond the number of items on the queue), then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果指定索引处不存在任何项（即，队列为空，或者索引超出了队列中的项数），则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc9e3e2a819c8fb3d75385fda77f033e08dfb423" translate="yes" xml:space="preserve">
          <source>If no options are given, Pod::Man uses the name of the input file with any trailing &lt;code&gt;.pod&lt;/code&gt;, &lt;code&gt;.pm&lt;/code&gt;, or &lt;code&gt;.pl&lt;/code&gt; stripped as the man page title, to section 1 unless the file ended in &lt;code&gt;.pm&lt;/code&gt; in which case it defaults to section 3, to a centered title of &quot;User Contributed Perl Documentation&quot;, to a centered footer of the Perl version it is run with, and to a left-hand footer of the modification date of its input (or the current date if given &lt;code&gt;STDIN&lt;/code&gt; for input).</source>
          <target state="translated">如果没有给出选项，波德::人使用与任何尾随的输入文件名 &lt;code&gt;.pod&lt;/code&gt; ， &lt;code&gt;.pm&lt;/code&gt; 后缀，或 &lt;code&gt;.pl&lt;/code&gt; 剥离作为男人页面标题，第1，除非在结束文件 &lt;code&gt;.pm&lt;/code&gt; 在这种情况下，默认为第3节，以&amp;ldquo; User Contributed Perl Documentation&amp;rdquo;为中心标题，以其为运行时所在的Perl版本的中心为页脚，以其输入的修改日期（或当前日期为给定 &lt;code&gt;STDIN&lt;/code&gt; 作为输入）。</target>
        </trans-unit>
        <trans-unit id="1f1608fb3d0f72aad27d7541f9de6e52f802b4ee" translate="yes" xml:space="preserve">
          <source>If no second argument is provided and the category is &lt;code&gt;LC_ALL&lt;/code&gt; , the result is implementation-dependent. It may be a string of concatenated locale names (separator also implementation-dependent) or a single locale name. Please consult your</source>
          <target state="translated">如果未提供第二个参数，并且类别为 &lt;code&gt;LC_ALL&lt;/code&gt; ，则结果取决于实现。它可以是一串串联的语言环境名称（分隔符也取决于实现）或单个语言环境名称。请咨询您的</target>
        </trans-unit>
        <trans-unit id="ed489574b7ebc8c696d017fb9515c4a591232a34" translate="yes" xml:space="preserve">
          <source>If no second argument is provided and the category is something other than &lt;code&gt;LC_ALL&lt;/code&gt; , the function returns a string naming the current locale for the category. You can use this value as the second argument in a subsequent call to &lt;code&gt;setlocale()&lt;/code&gt; , &lt;b&gt;but&lt;/b&gt; on some platforms the string is opaque, not something that most people would be able to decipher as to what locale it means.</source>
          <target state="translated">如果没有提供第二个参数，并且类别不是 &lt;code&gt;LC_ALL&lt;/code&gt; ，则该函数返回一个字符串，为该类别的当前语言环境命名。您可以在后续对 &lt;code&gt;setlocale()&lt;/code&gt; 的调用中将此值用作第二个参数，&lt;b&gt;但是&lt;/b&gt;在某些平台上，字符串是不透明的，大多数人都无法理解该字符串的含义。</target>
        </trans-unit>
        <trans-unit id="53385049e198591f3af9c0f621b19586d0e6e03c" translate="yes" xml:space="preserve">
          <source>If no string is specified via the &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator, the &lt;code&gt;$_&lt;/code&gt; variable is searched and modified. Unless the &lt;code&gt;/r&lt;/code&gt; option is used, the string specified must be a scalar variable, an array element, a hash element, or an assignment to one of those; that is, some sort of scalar lvalue.</source>
          <target state="translated">如果没有通过 &lt;code&gt;=~&lt;/code&gt; 或 &lt;code&gt;!~&lt;/code&gt; 运算符指定任何字符串，则搜索并修改 &lt;code&gt;$_&lt;/code&gt; 变量。除非使用 &lt;code&gt;/r&lt;/code&gt; 选项，否则指定的字符串必须是标量变量，数组元素，哈希元素或对其中之一的赋值；即某种标量左值。</target>
        </trans-unit>
        <trans-unit id="9ee4d303ec9de35b4bd6b8caf1f726ddd4ca7c6e" translate="yes" xml:space="preserve">
          <source>If no such Pod file is found, this method returns undef.</source>
          <target state="translated">如果没有找到这样的Pod文件,本方法返回undef。</target>
        </trans-unit>
        <trans-unit id="34cd3d77c3969309ab95d1d80fe464b5d299344d" translate="yes" xml:space="preserve">
          <source>If no urllist has been chosen yet, would you prefer CPAN.pm to connect to the built-in default sites without asking? (yes/no)?</source>
          <target state="translated">如果还没有选择urllist,您是否希望CPAN.pm不需要询问就能连接到内置的默认站点?(是/否)?</target>
        </trans-unit>
        <trans-unit id="b1457b54499e074ed5ffc48ffd57a11b298ba627" translate="yes" xml:space="preserve">
          <source>If no value is associated with the attribute, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed.</source>
          <target state="translated">如果没有值与该属性关联，则传递 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3641612d3261f449a8b25c55086ede32d34dbbcb" translate="yes" xml:space="preserve">
          <source>If non-empty braces are the only wildcard characters used in the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, no filenames are matched, but potentially many strings are returned. For example, this produces nine strings, one for each pairing of fruits and colors:</source>
          <target state="translated">如果非空括号是 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 中唯一使用的通配符，则不匹配任何文件名，但可能返回许多字符串。例如，这产生了九个字符串，每对水果和颜色配对一个：</target>
        </trans-unit>
        <trans-unit id="1328c99f7fc26be401ecc4c3daf8d11e272b065b" translate="yes" xml:space="preserve">
          <source>If non-empty braces are the only wildcard characters used in the &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, no filenames are matched, but potentially many strings are returned. For example, this produces nine strings, one for each pairing of fruits and colors:</source>
          <target state="translated">如果非空括号是 &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 中唯一使用的通配符，则不匹配任何文件名，但可能返回许多字符串。例如，这产生了九个字符串，每对水果和颜色配对一个：</target>
        </trans-unit>
        <trans-unit id="cf3289643abb0e0247bc66bf82c16e180f16eb54" translate="yes" xml:space="preserve">
          <source>If none of the above apply, for backwards compatibility reasons, the &lt;code&gt;/d&lt;/code&gt; modifier is the one in effect by default. As this can lead to unexpected results, it is best to specify which other rule set should be used.</source>
          <target state="translated">如果以上都不适用，则出于向后兼容的原因， &lt;code&gt;/d&lt;/code&gt; 修饰符默认为有效。由于这可能会导致意外结果，因此最好指定应使用哪个其他规则集。</target>
        </trans-unit>
        <trans-unit id="ca7c7d8696c46f8858c11c99d7d1a93c5e34454b" translate="yes" xml:space="preserve">
          <source>If none of the three command line flags (&lt;b&gt;-w&lt;/b&gt;, &lt;b&gt;-W&lt;/b&gt; or &lt;b&gt;-X&lt;/b&gt;) that control warnings is used and neither &lt;code&gt;$^W&lt;/code&gt; nor the &lt;code&gt;warnings&lt;/code&gt; pragma are used, then default warnings will be enabled and optional warnings disabled. This means that legacy code that doesn't attempt to control the warnings will work unchanged.</source>
          <target state="translated">如果没有使用用于控制警告的三个命令行标志（&lt;b&gt;-w&lt;/b&gt;，&lt;b&gt;-W&lt;/b&gt;或&lt;b&gt;-X&lt;/b&gt;），并且未使用 &lt;code&gt;$^W&lt;/code&gt; 或 &lt;code&gt;warnings&lt;/code&gt; 编译指示，则将启用默认警告，并禁用可选警告。这意味着不尝试控制警告的旧代码将保持不变。</target>
        </trans-unit>
        <trans-unit id="3318e55dc39962c8bcf2ab6429b4489bcf36fce0" translate="yes" xml:space="preserve">
          <source>If none of those language-tags leads to loadable classes, we then try classes derived from YourProjClass-&amp;gt;fallback_languages() and then if nothing comes of that, we use classes named by YourProjClass-&amp;gt;fallback_language_classes(). Then in the (probably quite unlikely) event that that fails, we just return undef.</source>
          <target state="translated">如果这些语言标签都没有导致可加载的类，则尝试使用从YourProjClass-&amp;gt; fallback_languages（）派生的类，然后如果没有任何结果，则使用由YourProjClass-&amp;gt; fallback_language_classes（）命名的类。然后，在失败的（可能非常不可能的）事件中，我们只返回undef。</target>
        </trans-unit>
        <trans-unit id="92205bb5b979576b7a4566bdd880e8993ef8accb" translate="yes" xml:space="preserve">
          <source>If not 0, then it will be a count of the number of items returned by the subroutine. These items will be stored on the Perl stack. The section</source>
          <target state="translated">如果不是0,那么它将是子程序返回的项目数。这些项目将被存储在Perl栈中。这一节</target>
        </trans-unit>
        <trans-unit id="15089e00b79e7ab36a4d99102807c33fe5f2fa61" translate="yes" xml:space="preserve">
          <source>If not already thread-shared, the other complex data types will be cloned (recursively, if needed, and including any &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt;ings and read-only settings) into thread-shared structures before being placed onto a queue.</source>
          <target state="translated">如果尚未进行线程共享，则将其他复杂数据类型（如果需要，将以递归方式克隆，包括任何 &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 和只读设置）克隆到线程共享结构中，然后再放入队列中。</target>
        </trans-unit>
        <trans-unit id="3e6242ea32a785a3ff0172e42255ea915052f271" translate="yes" xml:space="preserve">
          <source>If not explicitly stated, the thread's context is implied from the context of the &lt;code&gt;-&amp;gt;create()&lt;/code&gt; call:</source>
          <target state="translated">如果未明确说明，则从 &lt;code&gt;-&amp;gt;create()&lt;/code&gt; 调用的上下文隐含线程的上下文：</target>
        </trans-unit>
        <trans-unit id="546f552a865a929b4eb67739806b6d1165a21c9a" translate="yes" xml:space="preserve">
          <source>If not present or if it returns false, then the stream is left with the UTF-8 flag clear. The</source>
          <target state="translated">如果不存在或返回false,那么流将以UTF-8标志清除。列表中的</target>
        </trans-unit>
        <trans-unit id="2aa39c0e8f5ce84edfe0042135e7b88219cc53b5" translate="yes" xml:space="preserve">
          <source>If not specified, this parameter defaults to the OS code of the Operating System this module was built on. The value 3 is used as a catch-all for all Unix variants and unknown Operating Systems.</source>
          <target state="translated">如果没有指定,这个参数默认为这个模块所基于的操作系统的代码。值为3的时候,是对所有Unix变体和未知操作系统的统称。</target>
        </trans-unit>
        <trans-unit id="5be9107047108eada41300dc934c5b436deb60f0" translate="yes" xml:space="preserve">
          <source>If not successful &lt;code&gt;$status&lt;/code&gt; will hold the</source>
          <target state="translated">如果不成功， &lt;code&gt;$status&lt;/code&gt; 将保留</target>
        </trans-unit>
        <trans-unit id="aff9c9f30e8137171bc8ec7e751402e0d4e840fb" translate="yes" xml:space="preserve">
          <source>If not successful, &lt;code&gt;$i&lt;/code&gt; will be</source>
          <target state="translated">如果不成功， &lt;code&gt;$i&lt;/code&gt; 将是</target>
        </trans-unit>
        <trans-unit id="b50aafa5c3c8fb148f77f7f985f1a7044430dc1d" translate="yes" xml:space="preserve">
          <source>If not successful, the returned compression object, &lt;code&gt;$z&lt;/code&gt; , will be</source>
          <target state="translated">如果失败，则返回的压缩对象 &lt;code&gt;$z&lt;/code&gt; 将为</target>
        </trans-unit>
        <trans-unit id="e8abade20743149de14f55b6a98559ef8ef9d29a" translate="yes" xml:space="preserve">
          <source>If not successful, the returned deflation object, &lt;code&gt;$d&lt;/code&gt; , will be</source>
          <target state="translated">如果失败，则返回的通缩对象 &lt;code&gt;$d&lt;/code&gt; 将为</target>
        </trans-unit>
        <trans-unit id="98576d6e30e44a960914f7dcf4587ee17092e2df" translate="yes" xml:space="preserve">
          <source>If not successful, the returned deflation stream (&lt;code&gt;$d&lt;/code&gt; ) will be</source>
          <target state="translated">如果未成功，则返回的放气流（ &lt;code&gt;$d&lt;/code&gt; ）将是</target>
        </trans-unit>
        <trans-unit id="b7bd4ba1b78daba8a26ec4a9a7d4b9cf1b5da29e" translate="yes" xml:space="preserve">
          <source>If not successful, the returned uncompression object, &lt;code&gt;$z&lt;/code&gt; , will be</source>
          <target state="translated">如果未成功，则返回的解压缩对象 &lt;code&gt;$z&lt;/code&gt; 将为</target>
        </trans-unit>
        <trans-unit id="5c88e7dc3b6ede485e4fd5bdcc2d18ce257150ea" translate="yes" xml:space="preserve">
          <source>If not under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , the source is treated as ASCII + 128 extra controls, and identifiers should match</source>
          <target state="translated">如果不 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; ，则将源视为ASCII + 128个额外的控件，并且标识符应匹配</target>
        </trans-unit>
        <trans-unit id="adf92a54eaec2aef254d98d2b3572cf157430f6f" translate="yes" xml:space="preserve">
          <source>If not, you can use a Fisher-Yates shuffle.</source>
          <target state="translated">如果没有,你可以用Fisher-Yates洗牌。</target>
        </trans-unit>
        <trans-unit id="63aa47bb8d880da4c29744c1e2b5b0be9d2d8c10" translate="yes" xml:space="preserve">
          <source>If not, you may need to dig in the indices to find it in the directory of the current maintainer.</source>
          <target state="translated">如果没有,你可能需要在当前维护者的目录中挖掘索引来找到它。</target>
        </trans-unit>
        <trans-unit id="e3dd66c8bbe90e184bf0c3b78ff920f066856ccf" translate="yes" xml:space="preserve">
          <source>If omitted, PATTERN defaults to a single space, &lt;code&gt;&quot; &quot;&lt;/code&gt; , triggering the previously described</source>
          <target state="translated">如果省略，则PATTERN默认为单个空格 &lt;code&gt;&quot; &quot;&lt;/code&gt; ，从而触发前述</target>
        </trans-unit>
        <trans-unit id="9db6f61ce06c88ac7402efe003ec5c4f69fd8d53" translate="yes" xml:space="preserve">
          <source>If omitted, the maximum is the 4th.</source>
          <target state="translated">如果省略,最大的是第4个。</target>
        </trans-unit>
        <trans-unit id="8cf02da092076b8bc64e89cb4d51247518c5d4fc" translate="yes" xml:space="preserve">
          <source>If one attempts to print this value, then the overloaded operator &lt;code&gt;&quot;&quot;&lt;/code&gt; will be called, which will call &lt;code&gt;nomethod&lt;/code&gt; operator. The result of this operator will be stringified again, but this result is again of type &lt;code&gt;symbolic&lt;/code&gt; , which will lead to an infinite loop.</source>
          <target state="translated">如果尝试打印此值，则将调用重载的运算符 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，这将调用 &lt;code&gt;nomethod&lt;/code&gt; 运算符。该运算符的结果将再次被字符串化，但是该结果再次为 &lt;code&gt;symbolic&lt;/code&gt; 类型，这将导致无限循环。</target>
        </trans-unit>
        <trans-unit id="e1adcb84ff8cdfac7bb94b3520eb9afd47061bae" translate="yes" xml:space="preserve">
          <source>If one can be sure that a particular program is a Perl script expecting filenames in @ARGV, the clever programmer can write something like this:</source>
          <target state="translated">如果可以确定某个程序是一个期望以@ARGV为文件名的Perl脚本,聪明的程序员可以写出这样的东西。</target>
        </trans-unit>
        <trans-unit id="b9a4785b4cb95e8fee7a09364380427defe0f204" translate="yes" xml:space="preserve">
          <source>If one is compiling Perl with the &lt;code&gt;-DPERL_GLOBAL_STRUCT&lt;/code&gt; the &lt;code&gt;dVAR&lt;/code&gt; definition is needed if the Perl global variables (see</source>
          <target state="translated">如果一个与编译的Perl &lt;code&gt;-DPERL_GLOBAL_STRUCT&lt;/code&gt; 的 &lt;code&gt;dVAR&lt;/code&gt; 需要，如果Perl的全局变量定义（见</target>
        </trans-unit>
        <trans-unit id="e3e822ed5577ab52cc19452e08717fd8eeaeaafa" translate="yes" xml:space="preserve">
          <source>If one of the input arguments to the C function is the length of a string argument &lt;code&gt;NAME&lt;/code&gt; , one can substitute the name of the length-argument by &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; in the XSUB declaration. This argument must be omitted when the generated Perl function is called. E.g.,</source>
          <target state="translated">如果C函数的输入参数之一是字符串参数 &lt;code&gt;NAME&lt;/code&gt; 的长度，则可以在XSUB声明中用 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; 替换长度参数的名称。调用生成的Perl函数时，必须忽略此参数。例如，</target>
        </trans-unit>
        <trans-unit id="80356b3107601264757c736090081f30d00dbd0c" translate="yes" xml:space="preserve">
          <source>If one of the values is the string &quot;FATAL&quot;, then all the warnings in that list will be considered fatal, just as with the &lt;b&gt;warnings&lt;/b&gt; pragma itself. Should you need to specify that some warnings are fatal, and others are merely enabled, you can pass the &lt;b&gt;warnings&lt;/b&gt; parameter twice:</source>
          <target state="translated">如果值之一是字符串&amp;ldquo; FATAL&amp;rdquo;，则该列表中的所有警告都将被视为致命&lt;b&gt;警告&lt;/b&gt;，就像&lt;b&gt;警告&lt;/b&gt;杂注本身一样。如果您需要指定某些警告是致命的，而其他警告仅被启用，则可以两次传递&lt;b&gt;警告&lt;/b&gt;参数：</target>
        </trans-unit>
        <trans-unit id="58b3d6b8eb5c53fb4bf738ec026bd17996fb8d7b" translate="yes" xml:space="preserve">
          <source>If one wants to use pure Perl and to be compatible with Perl versions prior to 5.10, the general answer is to use &lt;code&gt;if-elsif-else&lt;/code&gt;:</source>
          <target state="translated">如果要使用纯Perl并与5.10之前的Perl版本兼容，通常的答案是使用 &lt;code&gt;if-elsif-else&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="12b8235b34f1e041150a031d0b9fbd780bdea304" translate="yes" xml:space="preserve">
          <source>If only PATTERN is given, EXPR defaults to &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">如果仅给出PATTERN，则EXPR默认为 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16392afc89510c0fc9dd7ff46ccb0d1b3e97fcef" translate="yes" xml:space="preserve">
          <source>If other charset support is needed, please file a bug report against CPAN.pm at rt.cpan.org and describe your needs. Maybe we can extend the support or maybe UTF-8 terminals become widely available.</source>
          <target state="translated">如果需要其他的字符集支持,请在rt.cpan.org上针对CPAN.pm提交一个bug报告,并描述你的需求。也许我们可以扩大支持范围,或者UTF-8终端变得更广泛。</target>
        </trans-unit>
        <trans-unit id="a07176206cda4e320bb3d161ccf541de7489aeb9" translate="yes" xml:space="preserve">
          <source>If our include file had contained #include directives, these would not have been processed by h2xs. There is no good solution to this right now.</source>
          <target state="translated">如果我们的include文件包含了#include指令,这些指令就不会被h2xs处理。现在还没有很好的解决办法。</target>
        </trans-unit>
        <trans-unit id="1342cd54e96ee75c7832a17e50d7545968334b8a" translate="yes" xml:space="preserve">
          <source>If parse errors are found in the TAP output, a note of this will be made in the summary report. To see all of the parse errors, set this argument to true:</source>
          <target state="translated">如果在TAP输出中发现了解析错误,将在摘要报告中进行说明。要查看所有的解析错误,请将此参数设置为true。</target>
        </trans-unit>
        <trans-unit id="390961095f8040e196a232b583180a54cb19ea61" translate="yes" xml:space="preserve">
          <source>If passed a filehandle will write a copy of all parsed TAP to that handle.</source>
          <target state="translated">如果传递一个filehandle,将把所有解析过的TAP的副本写入该handle。</target>
        </trans-unit>
        <trans-unit id="5a4f883097b033ba66596455cc092c01c5e9be39" translate="yes" xml:space="preserve">
          <source>If performance is an issue, and you don't care if the output is in the same case as the input, Use &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; to transform to the case most employed within the data. If the data are primarily UPPERCASE non-Latin1, then apply &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/[a-z]/[A-Z]/&lt;/a&gt;&lt;/code&gt;, and then &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;. If the data are primarily lowercase non Latin1 then apply &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/[A-Z]/[a-z]/&lt;/a&gt;&lt;/code&gt; before sorting. If the data are primarily UPPERCASE and include Latin-1 characters then apply:</source>
          <target state="translated">如果性能是一个问题，并且您不关心输出是否与输入相同，请使用 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 转换为数据中最常用的情况。如果数据主要是大写非Latin1，则应用 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/[a-z]/[A-Z]/&lt;/a&gt;&lt;/code&gt; ，然后应用 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 。如果数据主要是小写的非Latin1，则在排序之前应用 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/[A-Z]/[a-z]/&lt;/a&gt;&lt;/code&gt; 。如果数据主要是大写并包含Latin-1字符，则适用：</target>
        </trans-unit>
        <trans-unit id="ab79de5389c6af407dc202c7877566f66fb7264b" translate="yes" xml:space="preserve">
          <source>If perl has not yet been installed then PERL_SRC can be defined on the command line as shown in the previous section.</source>
          <target state="translated">如果perl还没有安装,那么PERL_SRC可以在命令行中定义,如上一节所示。</target>
        </trans-unit>
        <trans-unit id="527ed5a2bdcdb5849d3d992698d64bca35b1da28" translate="yes" xml:space="preserve">
          <source>If perl is invoked using the &lt;b&gt;-e&lt;/b&gt; option or the perl script is read from &lt;code&gt;STDIN&lt;/code&gt; then FindBin sets both &lt;code&gt;$Bin&lt;/code&gt; and &lt;code&gt;$RealBin&lt;/code&gt; to the current directory.</source>
          <target state="translated">如果使用&lt;b&gt;-e&lt;/b&gt;选项调用perl 或从 &lt;code&gt;STDIN&lt;/code&gt; 读取perl脚本，则FindBin会将 &lt;code&gt;$Bin&lt;/code&gt; 和 &lt;code&gt;$RealBin&lt;/code&gt; 设置为当前目录。</target>
        </trans-unit>
        <trans-unit id="c28bb9f5b57ae9540614c1c058beb6e3302cae11" translate="yes" xml:space="preserve">
          <source>If perl was installed correctly and your shadow library was written properly, the &lt;code&gt;getpw*()&lt;/code&gt; functions described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; should in theory provide (read-only) access to entries in the shadow password file. To change the file, make a new shadow password file (the format varies from system to system--see</source>
          <target state="translated">如果正确安装了perl并正确编写了影子库，则理论上&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;中描述的 &lt;code&gt;getpw*()&lt;/code&gt; 函数应提供对影子密码文件中条目的（只读）访问权限。要更改文件，请制作一个新的影子密码文件（格式因系统而异-请参阅</target>
        </trans-unit>
        <trans-unit id="4aa77499616bd2f38224ed594fc316a580948f20" translate="yes" xml:space="preserve">
          <source>If possible, move() will simply rename the file. Otherwise, it copies the file to the new location and deletes the original. If an error occurs during this copy-and-delete process, you may be left with a (possibly partial) copy of the file under the destination name.</source>
          <target state="translated">如果可能的话,move()会简单地重命名文件。否则,它会将文件复制到新的位置,并删除原来的文件。如果在这个复制和删除过程中发生错误,你可能会留下一个(可能是部分)目标名称下的文件副本。</target>
        </trans-unit>
        <trans-unit id="821e3f8f257e241afb18f9d12ceda656792b21cb" translate="yes" xml:space="preserve">
          <source>If possible, register the module with CPAN. You should include details of its location in your announcement.</source>
          <target state="translated">如有可能,请在CPAN登记该模块。您应在公告中详细说明该模块的位置。</target>
        </trans-unit>
        <trans-unit id="00df1bad6fa3810b7a0fb796a7103c7f28a05f8c" translate="yes" xml:space="preserve">
          <source>If possible, this form should be used to prevent possible race conditions.</source>
          <target state="translated">如果可能的话,应该使用这种形式,以防止可能的比赛条件。</target>
        </trans-unit>
        <trans-unit id="34d4da8aa87987ec9ceda1c43801e78b64cdc28a" translate="yes" xml:space="preserve">
          <source>If present on a regex, &lt;code&gt;&quot;#&quot;&lt;/code&gt; comments will be handled differently by the tokenizer in some cases.</source>
          <target state="translated">如果出现在正则表达式上，则在某些情况下，令牌处理程序将对 &lt;code&gt;&quot;#&quot;&lt;/code&gt; 注释进行不同的处理。</target>
        </trans-unit>
        <trans-unit id="fcb106d01e2834098b09ad25220c5df2510aa768" translate="yes" xml:space="preserve">
          <source>If present, $hints should be a reference to a hash, where the following keys are recognised:</source>
          <target state="translated">如果存在的话,$hints应该是一个哈希值的引用,在这个哈希值中,可以识别以下键。</target>
        </trans-unit>
        <trans-unit id="768b78e920d55b41dde42ac4d330e515e86f1cd7" translate="yes" xml:space="preserve">
          <source>If present, each callback corresponding to a given result type will be called with the result as the argument if the &lt;code&gt;run&lt;/code&gt; method is used:</source>
          <target state="translated">如果存在，则使用 &lt;code&gt;run&lt;/code&gt; 方法时，将使用结果作为参数调用与给定结果类型相对应的每个回调：</target>
        </trans-unit>
        <trans-unit id="80e76146570d6b35c93035dd97f6090cb9b7cbba" translate="yes" xml:space="preserve">
          <source>If present, it should be a reference to a scalar. This scalar will be made to reference an array, which will be used to store all files and directories unlinked during the call. If nothing is unlinked, the array will be empty.</source>
          <target state="translated">如果存在,它应该是一个标量的引用。这个标量将被用来引用一个数组,该数组将用于存储在调用过程中未链接的所有文件和目录。如果没有任何未链接的内容,那么数组将是空的。</target>
        </trans-unit>
        <trans-unit id="eaf6326ff6faceb306eebc039298d3cef21ae0f2" translate="yes" xml:space="preserve">
          <source>If present, it should be a reference to a scalar. This scalar will be made to reference an array, which will be used to store any errors that are encountered. See the &lt;a href=&quot;#ERROR-HANDLING&quot;&gt;ERROR HANDLING&lt;/a&gt; section for more information.</source>
          <target state="translated">如果存在，则应引用标量。将使这个标量引用一个数组，该数组将用于存储遇到的任何错误。有关更多信息，请参见&amp;ldquo; &lt;a href=&quot;#ERROR-HANDLING&quot;&gt;错误处理&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="28236ec2fcbd77071db6f4df51ebe2ad1353410f" translate="yes" xml:space="preserve">
          <source>If present, will cause &lt;code&gt;make_path&lt;/code&gt; to print the name of each directory as it is created. By default nothing is printed.</source>
          <target state="translated">如果存在，将使 &lt;code&gt;make_path&lt;/code&gt; 在创建每个目录时显示其名称。默认情况下，不打印任何内容。</target>
        </trans-unit>
        <trans-unit id="ba616b58ac8bd248e0e92e90224a9f0e82a7126d" translate="yes" xml:space="preserve">
          <source>If present, will cause &lt;code&gt;remove_tree&lt;/code&gt; to print the name of each file as it is unlinked. By default nothing is printed.</source>
          <target state="translated">如果存在，将导致 &lt;code&gt;remove_tree&lt;/code&gt; 打印每个未链接的文件的名称。默认情况下，不打印任何内容。</target>
        </trans-unit>
        <trans-unit id="da38e80a5de666bdd4124bbd72eac17c8b7acaf5" translate="yes" xml:space="preserve">
          <source>If present, will cause any created directory to be owned by &lt;code&gt;$owner&lt;/code&gt; . If the value is numeric, it will be interpreted as a uid, otherwise as username is assumed. An error will be issued if the username cannot be mapped to a uid, or the uid does not exist, or the process lacks the privileges to change ownership.</source>
          <target state="translated">如果存在，将导致任何创建的目录归 &lt;code&gt;$owner&lt;/code&gt; 。如果值为数字，则将其解释为uid，否则假定为username。如果用户名无法映射到uid，或者uid不存在，或者进程缺少更改所有权的特权，将发出错误。</target>
        </trans-unit>
        <trans-unit id="c6bc6a6c714ec1098b00e8f4665bf29765d41191" translate="yes" xml:space="preserve">
          <source>If present, will cause any created directory to be owned by the group &lt;code&gt;$group&lt;/code&gt; . If the value is numeric, it will be interpreted as a gid, otherwise as group name is assumed. An error will be issued if the group name cannot be mapped to a gid, or the gid does not exist, or the process lacks the privileges to change group ownership.</source>
          <target state="translated">如果存在，将使所有创建的目录归组 &lt;code&gt;$group&lt;/code&gt; 拥有。如果值为数字，则将其解释为gid，否则假定为组名。如果无法将组名映射到一个gid，或者该gid不存在，或者该进程缺少更改组所有权的特权，则将发出错误。</target>
        </trans-unit>
        <trans-unit id="a365bb62991d043cada86ad3beb15687e9b5977b" translate="yes" xml:space="preserve">
          <source>If program usage has been explicitly requested by the user, it is often desirable to exit with a status of 1 (as opposed to 0) after issuing the user-requested usage message. It is also desirable to give a more verbose description of program usage in this case.</source>
          <target state="translated">如果程序的使用是由用户明确要求的,那么在发出用户要求的使用信息后,通常最好以状态为1(而不是0)退出。在这种情况下,也最好对程序使用情况进行更详细的描述。</target>
        </trans-unit>
        <trans-unit id="ff3608d191706961b1f05c1c4d43ca10631cdf8b" translate="yes" xml:space="preserve">
          <source>If run on any operating system other than Windows, this will import the functions &lt;code&gt;setlocale&lt;/code&gt; and &lt;code&gt;LC_ALL&lt;/code&gt; from &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;. On Windows it does nothing.</source>
          <target state="translated">如果在Windows以外的任何操作系统上运行，这将从&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;导入功能 &lt;code&gt;setlocale&lt;/code&gt; 和 &lt;code&gt;LC_ALL&lt;/code&gt; 。在Windows上不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="9d9d2ff0e902fe5020fe3d38bdc23ea71c9ea208" translate="yes" xml:space="preserve">
          <source>If run with no arguments, filters standard input to standard output.</source>
          <target state="translated">如果运行时没有参数,则将标准输入过滤为标准输出。</target>
        </trans-unit>
        <trans-unit id="53f4c878607755d2bdfa2564e4393c026538b21e" translate="yes" xml:space="preserve">
          <source>If running under taint mode, and if $ENV{TMPDIR} is tainted, it is not used.</source>
          <target state="translated">如果在污点模式下运行,并且如果$ENV{TMPDIR}被污点,则不使用它。</target>
        </trans-unit>
        <trans-unit id="c028c3067c9e1833a7b2f721beaf502c1d3b87c3" translate="yes" xml:space="preserve">
          <source>If running under taint mode, and if the environment variables are tainted, they are not used.</source>
          <target state="translated">如果在污点模式下运行,且环境变量被污点,则不使用这些变量。</target>
        </trans-unit>
        <trans-unit id="bc42709752d603d6e86a31cea878bd9ef78c5a40" translate="yes" xml:space="preserve">
          <source>If safety matters to you (and why else would you be using the Opcode module?) then you should not rely on the definition of this, or indeed any other, optag!</source>
          <target state="translated">如果安全对您来说很重要(否则您为什么要使用Opcode模块?),那么您就不应该依赖这个或任何其他opag的定义!</target>
        </trans-unit>
        <trans-unit id="c49a3b26a25358ee584c0e87edb350360c053486" translate="yes" xml:space="preserve">
          <source>If set &lt;code&gt;formatter&lt;/code&gt; must be an object that is capable of formatting the TAP output. See &lt;a href=&quot;formatter/console&quot;&gt;TAP::Formatter::Console&lt;/a&gt; for an example.</source>
          <target state="translated">如果设置，则 &lt;code&gt;formatter&lt;/code&gt; 必须是能够格式化TAP输出的对象。有关示例，请参见&lt;a href=&quot;formatter/console&quot;&gt;TAP :: Formatter :: Console&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc6406e3d3c8ec686d43e0bd0630b45054571335" translate="yes" xml:space="preserve">
          <source>If set forward, the details of the missing tests are filled in as 'unknown'. if set backward, the details of the intervening tests are deleted. You can erase history if you really want to.</source>
          <target state="translated">如果向前设置,则将缺失的测试细节填写为 &quot;未知&quot;。如果向后设置,则删除中间测试的细节。如果你真的想删除历史记录,你可以删除。</target>
        </trans-unit>
        <trans-unit id="94a6b6735d1cf67d97faf5afa93385c976f8d9ca" translate="yes" xml:space="preserve">
          <source>If set to 'none', no man pages will be installed.</source>
          <target state="translated">如果设置为 &quot;无&quot;,则不会安装任何手册页。</target>
        </trans-unit>
        <trans-unit id="35193d3a52f1a67d3457cb0804a53caff3b762a2" translate="yes" xml:space="preserve">
          <source>If set to 0, the contents of the output parameter of the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method will be overwritten by the uncompressed data.</source>
          <target state="translated">如果设置为0，则 &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 方法的输出参数的内容将被未压缩的数据覆盖。</target>
        </trans-unit>
        <trans-unit id="63134c061d53f609b58fe4db77f806b2b217214c" translate="yes" xml:space="preserve">
          <source>If set to 1, all uncompressed data will be appended to the output parameter of the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">如果设置为1，则所有未压缩的数据将附加到 &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 方法的输出参数中。</target>
        </trans-unit>
        <trans-unit id="a99badbf73893e25506e2b45aeb306043f0421e4" translate="yes" xml:space="preserve">
          <source>If set to a true value instruct &lt;code&gt;TAP::Parser&lt;/code&gt; to ignore exit and wait status from test scripts.</source>
          <target state="translated">如果设置为真值，请指示 &lt;code&gt;TAP::Parser&lt;/code&gt; 忽略测试脚本的退出和等待状态。</target>
        </trans-unit>
        <trans-unit id="7addd0cdb6e060b7f425d641cdc5802f63dc6646" translate="yes" xml:space="preserve">
          <source>If set to a true value then MakeMaker's prompt function will always return the default without waiting for user input.</source>
          <target state="translated">如果设置为真值,那么MakeMaker的提示函数将始终返回默认值,而不需要等待用户输入。</target>
        </trans-unit>
        <trans-unit id="37acce4270c3ae4d059b2f5d5497684bcefbd070" translate="yes" xml:space="preserve">
          <source>If set to a true value, Pod::PlainText will assume that each sentence ends in two spaces, and will try to preserve that spacing. If set to false, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space. Defaults to true.</source>
          <target state="translated">如果设置为true,Pod::PlainText将假设每个句子以两个空格结束,并将尝试保留该间距。如果设置为false,所有非逐字段落中的连续空白都会被压缩为一个空格。默认为true。</target>
        </trans-unit>
        <trans-unit id="a1e0bdf314190ede062d43bfa363f6d6ba57f992" translate="yes" xml:space="preserve">
          <source>If set to a true value, Pod::Text will assume that each sentence ends in two spaces, and will try to preserve that spacing. If set to false, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space. Defaults to true.</source>
          <target state="translated">如果设置为true,Pod::Text将假设每个句子以两个空格结束,并将尝试保留该间距。如果设置为false,所有非逐字段落中的连续空白都会被压缩为一个空格。默认值为true。</target>
        </trans-unit>
        <trans-unit id="c7ea67874e15073f2f8a8748dd116175b232517b" translate="yes" xml:space="preserve">
          <source>If set to a true value, a blank line is printed after a &lt;code&gt;=head1&lt;/code&gt; heading. If set to false (the default), no blank line is printed after &lt;code&gt;=head1&lt;/code&gt; , although one is still printed after &lt;code&gt;=head2&lt;/code&gt; . This is the default because it's the expected formatting for manual pages; if you're formatting arbitrary text documents, setting this to true may result in more pleasing output.</source>
          <target state="translated">如果设置为true值，则在 &lt;code&gt;=head1&lt;/code&gt; 标题之后打印空白行。如果设置为false（缺省值），没有空行之后打印 &lt;code&gt;=head1&lt;/code&gt; ，虽然其中一个后仍印刷 &lt;code&gt;=head2&lt;/code&gt; 。这是默认设置，因为它是手册页的预期格式。如果您要格式化任意文本文档，则将其设置为true可能会导致更令人满意的输出。</target>
        </trans-unit>
        <trans-unit id="79c7d693600594b39fe949ae434a7a5fc8a792dc" translate="yes" xml:space="preserve">
          <source>If set to a true value, a blank line is printed after a &lt;code&gt;=headN&lt;/code&gt; headings. If set to false (the default), no blank line is printed after &lt;code&gt;=headN&lt;/code&gt; . This is the default because it's the expected formatting for manual pages; if you're formatting arbitrary text documents, setting this to true may result in more pleasing output.</source>
          <target state="translated">如果设置为true值，则在 &lt;code&gt;=headN&lt;/code&gt; 标题之后打印空白行。如果设置为false（默认值），则在 &lt;code&gt;=headN&lt;/code&gt; 之后不打印空白行。这是默认设置，因为它是手册页的预期格式。如果您要格式化任意文本文档，则将其设置为true可能会导致更令人满意的输出。</target>
        </trans-unit>
        <trans-unit id="3fb0153c7c54ce2bccc40f5b7e2d5aff19532ce7" translate="yes" xml:space="preserve">
          <source>If set to a true value, indicates to the debugger that the code being debugged uses threads.</source>
          <target state="translated">如果设置为真值,则向调试器表明被调试的代码使用了线程。</target>
        </trans-unit>
        <trans-unit id="e75bb2ef91a1a8c8b0ee4cbc07e5ef237213911f" translate="yes" xml:space="preserve">
          <source>If set to a true value, only test results with directives will be displayed. This overrides other settings such as &lt;code&gt;verbose&lt;/code&gt; , &lt;code&gt;failures&lt;/code&gt; , or &lt;code&gt;comments&lt;/code&gt; .</source>
          <target state="translated">如果设置为真值，则仅显示带有指令的测试结果。这将覆盖其他设置，例如 &lt;code&gt;verbose&lt;/code&gt; ， &lt;code&gt;failures&lt;/code&gt; 或 &lt;code&gt;comments&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6403db7bde854649adecbe2fe72bc17d3ded2ac7" translate="yes" xml:space="preserve">
          <source>If set to a true value, only test results with directives will be displayed. This overrides other settings such as &lt;code&gt;verbose&lt;/code&gt; or &lt;code&gt;failures&lt;/code&gt; .</source>
          <target state="translated">如果设置为真值，则仅显示带有指令的测试结果。这将覆盖其他设置，例如 &lt;code&gt;verbose&lt;/code&gt; 或 &lt;code&gt;failures&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ace0eebb3ad1da3562cf6ba2f4eb062020ce0829" translate="yes" xml:space="preserve">
          <source>If set to a true value, selects an alternate output format that, among other things, uses a different heading style and marks &lt;code&gt;=item&lt;/code&gt; entries with a colon in the left margin. Defaults to false.</source>
          <target state="translated">如果设置为true值，则选择一种替代输出格式，该格式除其他外将使用不同的标题样式，并在左边距处用冒号标记 &lt;code&gt;=item&lt;/code&gt; 条目。默认为false。</target>
        </trans-unit>
        <trans-unit id="341f05ae650241bc98a8aa05ba502f05572aa8ee" translate="yes" xml:space="preserve">
          <source>If set to a true value, source entries will be converted into utf8-strings (available in Perl 5.6.1 or later). This feature needs the &lt;b&gt;Encode&lt;/b&gt; or &lt;b&gt;Encode::compat&lt;/b&gt; module.</source>
          <target state="translated">如果设置为true值，则源条目将转换为utf8字符串（在Perl 5.6.1或更高版本中可用）。此功能需要&lt;b&gt;Encode&lt;/b&gt;或&lt;b&gt;Encode :: compat&lt;/b&gt;模块。</target>
        </trans-unit>
        <trans-unit id="e52de704a5928c9a6d768f4b0d7d8f6e786b6b18" translate="yes" xml:space="preserve">
          <source>If set to a true value, the non-POD parts of the input file will be included in the output. Useful for viewing code documented with POD blocks with the POD rendered and the code left intact.</source>
          <target state="translated">如果设置为true,输入文件的非POD部分将被包含在输出中。对于查看带有POD块的文档代码时,POD渲染和代码保持完整是有用的。</target>
        </trans-unit>
        <trans-unit id="77ffaa19bbb496da1b7f2a485ed0c35990cc9fa8" translate="yes" xml:space="preserve">
          <source>If set to nonzero, forces a flush right away and after every write or print on the currently selected output channel. Default is 0 (regardless of whether the channel is really buffered by the system or not; &lt;code&gt;$|&lt;/code&gt; tells you only whether you've asked Perl explicitly to flush after each write). STDOUT will typically be line buffered if output is to the terminal and block buffered otherwise. Setting this variable is useful primarily when you are outputting to a pipe or socket, such as when you are running a Perl program under &lt;b&gt;rsh&lt;/b&gt; and want to see the output as it's happening. This has no effect on input buffering. See &lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt; for that. See &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; on how to select the output channel. See also &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">如果设置为非零，则在当前选定的输出通道上每次写入或打印后立即强制执行刷新。缺省值为0（无论通道是否真正被系统缓冲； &lt;code&gt;$|&lt;/code&gt; 仅告诉您是否在每次写入后都明确要求Perl刷新）。如果输出到终端，则STDOUT通常将被行缓冲，否则将被块缓冲。设置此变量主要在输出到管道或套接字时很有用，例如，在&lt;b&gt;rsh&lt;/b&gt;下运行Perl程序并希望看到正在发生的输出时。这对输入缓冲没有影响。参见&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;。请参阅&lt;a href=&quot;functions/select&quot;&gt;选择&lt;/a&gt;如何选择输出通道。另请参见&lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="910076b95e48e767183ba95d8bfd82a29fd1f4b7" translate="yes" xml:space="preserve">
          <source>If set to the name of a file or device, certain operations of PerlIO subsystem will be logged to that file, which is opened in append mode. Typical uses are in Unix:</source>
          <target state="translated">如果设置为文件或设备的名称,PerlIO子系统的某些操作将被记录到该文件中,该文件以追加模式打开。典型的用途是在Unix中。</target>
        </trans-unit>
        <trans-unit id="907b3689c8943c9530c2bccd5f2399b3ea311ce8" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;check&quot;&gt;Params::Check&lt;/a&gt; will &lt;code&gt;croak&lt;/code&gt; when an error during template validation occurs, rather than return &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">如果设置为true，则在模板验证期间发生错误时，&lt;a href=&quot;check&quot;&gt;Params :: Check&lt;/a&gt;将发出 &lt;code&gt;croak&lt;/code&gt; ，而不是返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="262e77d8ecddf65d8252c722de18aca6dafa7dd4" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;check&quot;&gt;Params::Check&lt;/a&gt; will no longer convert all keys from the user input to lowercase, but instead expect them to be in the case the template provided. This is useful when you want to use similar keys with different casing in your templates.</source>
          <target state="translated">如果设置为true，则&lt;a href=&quot;check&quot;&gt;Params :: Check&lt;/a&gt;将不再将所有键从用户输入转换为小写字母，而是期望它们在提供的模板的情况下。当您要在模板中使用相似的键和不同的大小写时，这很有用。</target>
        </trans-unit>
        <trans-unit id="fcd2802dc60a0f5aa656aa8d36630b4a5a1195a7" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;check&quot;&gt;Params::Check&lt;/a&gt; will require all values passed to be &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt;. If you wish to enable this on a 'per key' basis, use the template option &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果设置为true，则&lt;a href=&quot;check&quot;&gt;Params :: Check&lt;/a&gt;将要求所有传递的值都被 &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 。如果希望基于&amp;ldquo;每个键&amp;rdquo;启用此功能，请改用 &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 的模板选项。</target>
        </trans-unit>
        <trans-unit id="b62a3740f4d2f3949ae331d68aff300bd8b9c5aa" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;check&quot;&gt;Params::Check&lt;/a&gt; will sanity check templates, validating for errors and unknown keys. Although very useful for debugging, this can be somewhat slow in hot-code and large loops.</source>
          <target state="translated">如果设置为true，则&lt;a href=&quot;check&quot;&gt;Params :: Check&lt;/a&gt;将进行完整性检查模板，以验证错误和未知密钥。尽管对于调试非常有用，但是在热代码和大型循环中这可能会有点慢。</target>
        </trans-unit>
        <trans-unit id="df88f116b1eff18f21bd345796868ca93d04ee66" translate="yes" xml:space="preserve">
          <source>If set to true, a crc32 checksum of the uncompressed data will be calculated. Use the &lt;code&gt;$d-&amp;gt;crc32&lt;/code&gt; method to retrieve this value.</source>
          <target state="translated">如果设置为true，将计算未压缩数据的crc32校验和。使用 &lt;code&gt;$d-&amp;gt;crc32&lt;/code&gt; 方法检索此值。</target>
        </trans-unit>
        <trans-unit id="bbd8aed6bbb2cb495083f75e98d7497f01edca37" translate="yes" xml:space="preserve">
          <source>If set to true, a crc32 checksum of the uncompressed data will be calculated. Use the &lt;code&gt;$i-&amp;gt;crc32&lt;/code&gt; method to retrieve this value.</source>
          <target state="translated">如果设置为true，将计算未压缩数据的crc32校验和。使用 &lt;code&gt;$i-&amp;gt;crc32&lt;/code&gt; 方法检索该值。</target>
        </trans-unit>
        <trans-unit id="d4a8f4d307b72654b7c09182b593e029ffb7af20" translate="yes" xml:space="preserve">
          <source>If set to true, all keys in the template that are marked as to be stored in a scalar, will also be removed from the result set.</source>
          <target state="translated">如果设置为 &quot;true&quot;,则模板中所有被标记为存储在标量中的键,也将从结果集中删除。</target>
        </trans-unit>
        <trans-unit id="8a9a61d55c40cdf983928fb90e5f246e820a5b49" translate="yes" xml:space="preserve">
          <source>If set to true, an adler32 checksum of the uncompressed data will be calculated. Use the &lt;code&gt;$d-&amp;gt;adler32&lt;/code&gt; method to retrieve this value.</source>
          <target state="translated">如果设置为true，将计算未压缩数据的adler32校验和。使用 &lt;code&gt;$d-&amp;gt;adler32&lt;/code&gt; 方法检索此值。</target>
        </trans-unit>
        <trans-unit id="a5a30a93daed908c592b28db82a1a0b5d4a5ffc0" translate="yes" xml:space="preserve">
          <source>If set to true, an adler32 checksum of the uncompressed data will be calculated. Use the &lt;code&gt;$i-&amp;gt;adler32&lt;/code&gt; method to retrieve this value.</source>
          <target state="translated">如果设置为true，将计算未压缩数据的adler32校验和。使用 &lt;code&gt;$i-&amp;gt;adler32&lt;/code&gt; 方法检索此值。</target>
        </trans-unit>
        <trans-unit id="dbc945146e02b49c89057b1636cf31aa2669f101" translate="yes" xml:space="preserve">
          <source>If set to true, immediately extract entries when reading them. This gives you the same memory break as the &lt;code&gt;extract_archive&lt;/code&gt; function. Note however that entries will not be read into memory, but written straight to disk. This means no &lt;code&gt;Archive::Tar::File&lt;/code&gt; objects are created for you to inspect.</source>
          <target state="translated">如果设置为true，则在读取条目时立即提取它们。这为您提供了与 &lt;code&gt;extract_archive&lt;/code&gt; 函数相同的内存中断。但是请注意，条目不会读入内存，而是直接写入磁盘。这意味着没有创建 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 对象供您检查。</target>
        </trans-unit>
        <trans-unit id="8be646f7a5def96ccc7c7343df2cffa456a1c220" translate="yes" xml:space="preserve">
          <source>If set to true, no &quot;1..N&quot; header will be printed.</source>
          <target state="translated">如果设置为 &quot;true&quot;,则不会打印 &quot;1...N &quot;页眉。</target>
        </trans-unit>
        <trans-unit id="7adb95e8ec0ed6e84fcb01131c2b90c160ee5335" translate="yes" xml:space="preserve">
          <source>If set to true, this option will remove compressed data from the input buffer of the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method as the inflate progresses.</source>
          <target state="translated">如果设置为true，则此选项将随着膨胀的进行从 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 方法的输入缓冲区中删除压缩数据。</target>
        </trans-unit>
        <trans-unit id="d55732bd7089a68f6b5548af27b4b056d17dc65d" translate="yes" xml:space="preserve">
          <source>If set true no diagnostics will be printed. This includes calls to &lt;code&gt;diag()&lt;/code&gt; .</source>
          <target state="translated">如果设置为true，则不会打印诊断信息。这包括对 &lt;code&gt;diag()&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="767e45d99bc3772f600dade44827bcaf3503a3c0" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;sources&lt;/code&gt; must be a hashref containing the names of the &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s to load and/or configure. The values are a hash of configuration that will be accessible to the source handlers via &lt;a href=&quot;parser/source#config_for&quot;&gt;config_for in TAP::Parser::Source&lt;/a&gt;.</source>
          <target state="translated">如果设置，则 &lt;code&gt;sources&lt;/code&gt; 必须是包含要加载和/或配置的&lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;的名称的hashref。这些值是配置的哈希，源处理程序可以通过&lt;a href=&quot;parser/source#config_for&quot;&gt;TAP :: Parser :: Source中的config_for&lt;/a&gt;访问这些配置。</target>
        </trans-unit>
        <trans-unit id="7a162adb7a0dc8b66567284e3d48459cecdcd046" translate="yes" xml:space="preserve">
          <source>If set, a directory which fails the</source>
          <target state="translated">如果设置,则会出现一个不合格的目录。</target>
        </trans-unit>
        <trans-unit id="41e6aaabd1216511f49764603b89114f7c2c7520" translate="yes" xml:space="preserve">
          <source>If set, should be the name of a file (in the output directory) to write the HTML index to. The default value is &quot;index.html&quot;. If you set this to a false value, no contents file will be written.</source>
          <target state="translated">如果设置,应该是要写入HTML索引的文件名(在输出目录中)。默认值是 &quot;index.html&quot;。如果设置为false,则不会写入内容文件。</target>
        </trans-unit>
        <trans-unit id="fed7ed0698b463358f79ea435791a3f79370827d" translate="yes" xml:space="preserve">
          <source>If set, the debugger goes into &lt;code&gt;NonStop&lt;/code&gt; mode and will not connect to a TTY. If interrupted (or if control goes to the debugger via explicit setting of $DB::signal or $DB::single from the Perl script), it connects to a TTY specified in the &lt;code&gt;TTY&lt;/code&gt; option at startup, or to a tty found at runtime using the &lt;code&gt;Term::Rendezvous&lt;/code&gt; module of your choice.</source>
          <target state="translated">如果设置，调试器将进入非 &lt;code&gt;NonStop&lt;/code&gt; 模式，并且不会连接到TTY。如果被中断（或者如果通过Perl脚本中的$ DB :: signal或$ DB :: single的显式设置将控制权交给调试器），它将在启动时连接到 &lt;code&gt;TTY&lt;/code&gt; 选项中指定的TTY或在以下位置找到的tty：使用您选择的 &lt;code&gt;Term::Rendezvous&lt;/code&gt; 模块运行时。</target>
        </trans-unit>
        <trans-unit id="f19bf560504f7c9497b672610231bba49eba7830" translate="yes" xml:space="preserve">
          <source>If set, the debugger goes into non-interactive mode until interrupted, or programmatically by setting $DB::signal or $DB::single.</source>
          <target state="translated">如果设置,则调试器进入非交互模式,直到被中断,或者通过设置$DB::signal或$DB::single进行编程。</target>
        </trans-unit>
        <trans-unit id="825ea211f8cc0b564969fbeabe2d0a330315f1a6" translate="yes" xml:space="preserve">
          <source>If set, this dumps out memory statistics after execution. If set to an integer greater than one, also dumps out memory statistics after compilation.</source>
          <target state="translated">如果设置为,则在执行后会转储出内存统计。如果设置为大于1的整数,也会在编译后转出内存统计。</target>
        </trans-unit>
        <trans-unit id="8b969433f335481102ca199a1faf8cf07ca2debd" translate="yes" xml:space="preserve">
          <source>If set, this symbol indicates that only the version-specific components of a perl installation should be installed. This may be useful for making a test installation of a new version without disturbing the existing installation. Setting versiononly is equivalent to setting installperl's -v option. In particular, the non-versioned scripts and programs such as a2p, c2ph, h2xs, pod2*, and perldoc are not installed (see &lt;code&gt;INSTALL&lt;/code&gt; for a more complete list). Nor are the man pages installed. Usually, this is undef.</source>
          <target state="translated">如果设置，则此符号表示仅应安装perl安装的特定于版本的组件。这对于在不干扰现有安装的情况下进行新版本的测试安装很有用。设置versiononly等效于设置installperl的-v选项。特别是，未安装非版本化的脚本和程序，例如a2p，c2ph，h2xs，pod2 *和perldoc（有关完整列表，请参阅 &lt;code&gt;INSTALL&lt;/code&gt; ）。手册页也没有安装。通常，这是不确定的。</target>
        </trans-unit>
        <trans-unit id="5be95242fd4f1700426db0866219ce183a7c4d43" translate="yes" xml:space="preserve">
          <source>If setmagic is false then no set magic will be called on the new (empty) SV. This typically means that assignment will soon follow (e.g. 'local $x = $y'), and that will handle the magic.</source>
          <target state="translated">如果setmagic为false,那么在新的(空的)SV上将不会调用set magic。这通常意味着赋值将很快跟上(例如'local $x=$y'),这将处理魔法。</target>
        </trans-unit>
        <trans-unit id="b7db0eb29b687c30aa2094a54d8f1f63ca4df7c5" translate="yes" xml:space="preserve">
          <source>If several symbol categories exist in &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; , it's usually useful to create the utility &quot;:all&quot; to simplify &quot;use&quot; statements.</source>
          <target state="translated">如果 &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 中存在多个符号类别，通常创建实用程序&amp;ldquo;：all&amp;rdquo;以简化&amp;ldquo; use&amp;rdquo;语句通常很有用。</target>
        </trans-unit>
        <trans-unit id="1d650df7f1b284cce9178200761c079c663691a8" translate="yes" xml:space="preserve">
          <source>If so, please try to reuse the existing modules either in whole or by inheriting useful features into a new class. If this is not practical try to get together with the module authors to work on extending or enhancing the functionality of the existing modules. A perfect example is the plethora of packages in perl4 for dealing with command line options.</source>
          <target state="translated">如果是这样的话,请尝试重新使用现有的模块,或者将有用的功能继承到一个新的类中。如果这不切实际,请与模块作者一起努力扩展或增强现有模块的功能。一个很好的例子就是perl4中大量的用于处理命令行选项的包。</target>
        </trans-unit>
        <trans-unit id="dcc2c875ef26b86def7f4287ef7a97e0b0212c08" translate="yes" xml:space="preserve">
          <source>If so, that's great news; bug reports with patches are likely to receive significantly more attention and interest than those without patches. Please attach your patch to the report using the &lt;code&gt;-p&lt;/code&gt; option. When sending a patch, create it using &lt;code&gt;git format-patch&lt;/code&gt; if possible, though a unified diff created with &lt;code&gt;diff -pu&lt;/code&gt; will do nearly as well.</source>
          <target state="translated">如果是这样，那是个好消息；与没有补丁程序的错误报告相比，有补丁程序的错误报告可能会受到更多的关注和关注。请使用 &lt;code&gt;-p&lt;/code&gt; 选项将补丁程序附加到报告中。发送补丁时，请尽可能使用 &lt;code&gt;git format-patch&lt;/code&gt; 创建补丁，尽管使用 &lt;code&gt;diff -pu&lt;/code&gt; 创建的统一diff 也差不多。</target>
        </trans-unit>
        <trans-unit id="e41db44860ffe2b84a712b997e64175db6318266" translate="yes" xml:space="preserve">
          <source>If some events detected in</source>
          <target state="translated">如果检测到一些事件,在</target>
        </trans-unit>
        <trans-unit id="4a24b9aa82fff6a4581557ce8337d0476898456b" translate="yes" xml:space="preserve">
          <source>If some threads have not finished running when the main Perl thread ends, Perl will warn you about it and die, since it is impossible for Perl to clean up itself while other threads are running.</source>
          <target state="translated">如果在Perl主线程结束时,有些线程还没有运行完,Perl就会警告你,然后死掉,因为在其他线程运行的时候,Perl是不可能自己清理的。</target>
        </trans-unit>
        <trans-unit id="5c202d6491a5606cc9c88606232cf0104e601803" translate="yes" xml:space="preserve">
          <source>If something in a program isn&amp;rsquo;t the value you&amp;rsquo;re looking for but indicates where the value is, that&amp;rsquo;s indirection. This can be done with either &lt;b&gt;symbolic references&lt;/b&gt; or &lt;b&gt;hard&lt;/b&gt;.</source>
          <target state="translated">如果程序中的某些内容不是您要查找的值，而是指示该值在哪里，那就是间接的。可以使用&lt;b&gt;符号引用&lt;/b&gt;或&lt;b&gt;hard&lt;/b&gt;来完成。</target>
        </trans-unit>
        <trans-unit id="6d353132ec4a6837954d3ce352dc8e97cba1ae50" translate="yes" xml:space="preserve">
          <source>If something in the Perl core is marked as &lt;b&gt;deprecated&lt;/b&gt;, we may remove it from the core in the future, though we might not. Generally, backward incompatible changes will have deprecation warnings for two release cycles before being removed, but may be removed after just one cycle if the risk seems quite low or the benefits quite high.</source>
          <target state="translated">如果将Perl核心中的某些内容标记为&lt;b&gt;已弃用&lt;/b&gt;，则将来可能会将其从核心中删除，尽管可能不会。通常，向后不兼容的更改在删除之前将有两个发布周期的弃用警告，但如果风险似乎很低或收益很高，则可能仅在一个周期后就将其删除。</target>
        </trans-unit>
        <trans-unit id="5fdc0cac0824435fe5437bd44fc271afb23e92f6" translate="yes" xml:space="preserve">
          <source>If something in the Perl core is marked as &lt;b&gt;experimental&lt;/b&gt;, we may change its behaviour, deprecate or remove it without notice. While we'll always do our best to smooth the transition path for users of experimental features, you should contact the perl5-porters mailinglist if you find an experimental feature useful and want to help shape its future.</source>
          <target state="translated">如果Perl核心中的某些内容标记为&lt;b&gt;实验&lt;/b&gt;，我们可能会更改其行为，不建议使用或删除它，恕不另行通知。尽管我们将始终竭尽全力为实验功能的用户简化过渡路径，但如果您发现实验功能有用并希望帮助其发展，则应联系perl5-porters邮件列表。</target>
        </trans-unit>
        <trans-unit id="12083dc2cfbc1c39486c5540691a063ce5c5018f" translate="yes" xml:space="preserve">
          <source>If spaces extend into the next chunk of input text, the next chunk will be read in. Normally the current chunk will be discarded at the same time, but if</source>
          <target state="translated">如果空格延伸到下一个输入文本块,下一个块将被读入。通常,当前的文本块将被同时丢弃,但如果</target>
        </trans-unit>
        <trans-unit id="b6dd58d3559146e497eb5b446f27a9cb126713f8" translate="yes" xml:space="preserve">
          <source>If specified, strings are normalized before preparation of sort keys (the normalization is executed after preprocess).</source>
          <target state="translated">如果指定,则在准备排序键之前对字符串进行归一化处理(归一化处理在预处理之后执行)。</target>
        </trans-unit>
        <trans-unit id="c54d25c0a371a4a7533e5b6eb7a37c54566669f4" translate="yes" xml:space="preserve">
          <source>If specified, the coderef is used to preprocess each string before the formation of sort keys.</source>
          <target state="translated">如果指定了coderef,那么在形成排序键之前,coderef被用来对每个字符串进行预处理。</target>
        </trans-unit>
        <trans-unit id="df742ffc92755882ac205c4e8f1710a25c417cf9" translate="yes" xml:space="preserve">
          <source>If specified, the coderef is used to rewrite lines in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; . The coderef will get each line, and then should return a rewritten line according to the UCA file format. If the coderef returns an empty line, the line will be skipped.</source>
          <target state="translated">如果指定，则coderef用于重写 &lt;code&gt;table&lt;/code&gt; 或 &lt;code&gt;entry&lt;/code&gt; 中的行。coderef将获取每一行，然后应根据UCA文件格式返回重写的行。如果coderef返回空行，则该行将被跳过。</target>
        </trans-unit>
        <trans-unit id="fd186f184cd201e115617cc1e9809ac56ff41627" translate="yes" xml:space="preserve">
          <source>If specified, the given string will be stripped off from the beginning of the C function name in the generated XS functions (if it starts with that prefix). This only applies to XSUBs without &lt;code&gt;CODE&lt;/code&gt; or &lt;code&gt;PPCODE&lt;/code&gt; blocks. For example, the XS:</source>
          <target state="translated">如果指定，将在生成的XS函数中从C函数名称的开头剥离给定的字符串（如果以该前缀开头）。这仅适用于没有 &lt;code&gt;CODE&lt;/code&gt; 或 &lt;code&gt;PPCODE&lt;/code&gt; 块的XSUB。例如，XS：</target>
        </trans-unit>
        <trans-unit id="db33e17f1262611ad9b1ad5050ad6146c6b090c4" translate="yes" xml:space="preserve">
          <source>If specified, this option will disable the creation of all extra fields in the zip local and central headers. So the &lt;code&gt;exTime&lt;/code&gt; , &lt;code&gt;exUnix2&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; , &lt;code&gt;ExtraFieldLocal&lt;/code&gt; and &lt;code&gt;ExtraFieldCentral&lt;/code&gt; options will be ignored.</source>
          <target state="translated">如果指定，此选项将禁止在zip本地和中央标题中创建所有其他字段。因此， &lt;code&gt;exTime&lt;/code&gt; ， &lt;code&gt;exUnix2&lt;/code&gt; ， &lt;code&gt;exUnixN&lt;/code&gt; ， &lt;code&gt;ExtraFieldLocal&lt;/code&gt; 和 &lt;code&gt;ExtraFieldCentral&lt;/code&gt; 选项将被忽略。</target>
        </trans-unit>
        <trans-unit id="4d0066c7ecc8871ce3a62f9b83ef61508d6113e7" translate="yes" xml:space="preserve">
          <source>If specified, this option will force the creation of the smallest possible compliant gzip header (which is exactly 10 bytes long) as defined in RFC 1952.</source>
          <target state="translated">如果指定了这个选项,将强制创建 RFC 1952 中定义的尽可能小的符合标准的 gzip 头(长度正好是 10 字节)。</target>
        </trans-unit>
        <trans-unit id="74b346bb75048f3d43315e1f91c059eb29d865aa" translate="yes" xml:space="preserve">
          <source>If speed is of little concern, the common idiom uses grep in scalar context (which returns the number of items that passed its condition) to traverse the entire list. This does have the benefit of telling you how many matches it found, though.</source>
          <target state="translated">如果对速度没有什么关注,常用的习惯是在标量上下文中使用grep(返回通过其条件的项目数)来遍历整个列表。不过这样做的好处是可以告诉你它找到了多少个匹配项。</target>
        </trans-unit>
        <trans-unit id="8029f3ea6d316f66b8a86b9af29af453cce204da" translate="yes" xml:space="preserve">
          <source>If start_color is non-null then it will be inserted after the opening quote (if there is one) but before the escaped text. If end_color is non-null then it will be inserted after the escaped text but before any quotes or ellipses.</source>
          <target state="translated">如果start_color是非空的,那么它将被插入到开头引号(如果有的话)之后,但在转义文本之前。如果end_color是非空的,那么它将被插入到转义文本之后,但在任何引号或省略号之前。</target>
        </trans-unit>
        <trans-unit id="741bc8e54000bbf6547a93a37e27f9bd7b7bf22e" translate="yes" xml:space="preserve">
          <source>If straightforward stream-based parsing wont meet your needs (as is likely the case for tasks such as translating PODs into structured markup languages like HTML and XML) then you may need to take the tree-based approach. Rather than doing everything in one pass and calling the &lt;b&gt;interpolate()&lt;/b&gt; method to expand sequences into text, it may be desirable to instead create a parse-tree using the &lt;b&gt;parse_text()&lt;/b&gt; method to return a tree-like structure which may contain an ordered list of children (each of which may be a text-string, or a similar tree-like structure).</source>
          <target state="translated">如果简单的基于流的解析无法满足您的需求（如将POD转换为结构化标记语言（如HTML和XML）之类的任务，那么您可能需要采用基于树的方法。与其一口气完成所有工作并调用&lt;b&gt;interpolate（）&lt;/b&gt;方法以将序列扩展为文本，&lt;b&gt;不如&lt;/b&gt;使用&lt;b&gt;parse_text（）&lt;/b&gt;方法创建一个分析树以返回一个可能包含有序列表的树状结构，可能是合乎需要的的孩子（每个孩子可能是文本字符串或类似的树状结构）。</target>
        </trans-unit>
        <trans-unit id="5d14b7e2a788098ee234bfc1585ff4767dfdaee2" translate="yes" xml:space="preserve">
          <source>If subroutine signatures are enabled (see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt;), then the shorter PROTO syntax is unavailable, because it would clash with signatures. In that case, a prototype can only be declared in the form of an attribute.</source>
          <target state="translated">如果启用了子例程签名（请参见&lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt;），则较短的PROTO语法将不可用，因为它将与签名冲突。在这种情况下，原型只能以属性的形式声明。</target>
        </trans-unit>
        <trans-unit id="42c7d01f7359f4959eaf7c155ab3009451137cea" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;$i&lt;/code&gt; will hold the inflation object and &lt;code&gt;$status&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">如果成功， &lt;code&gt;$i&lt;/code&gt; 将持有通胀对象， &lt;code&gt;$status&lt;/code&gt; 将为 &lt;code&gt;Z_OK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec38a973765ca012bc6fc104f4b8ef70937c9614" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;$i&lt;/code&gt; will hold the inflation stream and &lt;code&gt;$status&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">如果成功， &lt;code&gt;$i&lt;/code&gt; 将保持通货膨胀，而 &lt;code&gt;$status&lt;/code&gt; 将为 &lt;code&gt;Z_OK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f34b524a05a94eda9eec45a5e52e923221e9853a" translate="yes" xml:space="preserve">
          <source>If successful, it returns the in-memory gzip file. Otherwise it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;$gzerrno&lt;/code&gt; variable will store the zlib error code.</source>
          <target state="translated">如果成功，它将返回内存中的gzip文件。否则，它将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 并且 &lt;code&gt;$gzerrno&lt;/code&gt; 变量将存储zlib错误代码。</target>
        </trans-unit>
        <trans-unit id="a4a46b7cfb2406db4688f3a0ac9d424f4865a652" translate="yes" xml:space="preserve">
          <source>If successful, it returns the uncompressed gzip file. Otherwise it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;$gzerrno&lt;/code&gt; variable will store the zlib error code.</source>
          <target state="translated">如果成功，它将返回未压缩的gzip文件。否则，它将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 并且 &lt;code&gt;$gzerrno&lt;/code&gt; 变量将存储zlib错误代码。</target>
        </trans-unit>
        <trans-unit id="0f77490ec0c061ac3ae6e48aedaf1d41d413b95c" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised compression object, &lt;code&gt;$z&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;BZ_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$z&lt;/code&gt; , only.</source>
          <target state="translated">如果成功，它将返回初始化压缩对象， &lt;code&gt;$z&lt;/code&gt; 和 &lt;code&gt;$status&lt;/code&gt; 的 &lt;code&gt;BZ_OK&lt;/code&gt; 在列表环境。在标量上下文中，它仅返回放气对象 &lt;code&gt;$z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="003d593630b18abe30c9939f8d44076e1ce90807" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised deflation object, &lt;code&gt;$d&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;Z_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$d&lt;/code&gt; , only.</source>
          <target state="translated">如果成功，它将返回初始化通缩对象， &lt;code&gt;$d&lt;/code&gt; 和 &lt;code&gt;$status&lt;/code&gt; 的 &lt;code&gt;Z_OK&lt;/code&gt; 在列表环境。在标量上下文中，它仅返回通缩对象 &lt;code&gt;$d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f86208486cf7be6093bb8b7191e306d09fb04dc" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised deflation stream, &lt;code&gt;$d&lt;/code&gt; and &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;Z_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation stream, &lt;code&gt;$d&lt;/code&gt; , only.</source>
          <target state="translated">如果成功，它将在列表上下文中 &lt;code&gt;Z_OK&lt;/code&gt; 的初始化通缩流 &lt;code&gt;$d&lt;/code&gt; 和 &lt;code&gt;$status&lt;/code&gt; 。在标量上下文中，它仅返回放气流 &lt;code&gt;$d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05d2c70da3dce90528345981e79d77f52c5f5ddb" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised uncompression object, &lt;code&gt;$z&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;BZ_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$z&lt;/code&gt; , only.</source>
          <target state="translated">如果成功，它将返回初始化解压缩对象， &lt;code&gt;$z&lt;/code&gt; 和 &lt;code&gt;$status&lt;/code&gt; 的 &lt;code&gt;BZ_OK&lt;/code&gt; 在列表环境。在标量上下文中，它仅返回放气对象 &lt;code&gt;$z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9905dac4184f6f7193dddf39eab6d02ad4540f03" translate="yes" xml:space="preserve">
          <source>If supplied with an argument that can't be a code point, &lt;code&gt;charblock()&lt;/code&gt; tries to do the opposite and interpret the argument as an old-style block name. On an ASCII platform, the return value is a</source>
          <target state="translated">如果提供的参数不能是代码点，则 &lt;code&gt;charblock()&lt;/code&gt; 会尝试执行相反的操作，并将该参数解释为旧式块名称。在ASCII平台上，返回值为</target>
        </trans-unit>
        <trans-unit id="343b1f1d2e0b0c3a0e2a3dffed0083feca7d527c" translate="yes" xml:space="preserve">
          <source>If supplied with an argument that can't be a code point, charscript() tries to do the opposite and interpret the argument as a script name. The return value is a</source>
          <target state="translated">如果提供的参数不能是代码点,charscript()会尝试做相反的事情,并将参数解释为一个脚本名称。返回值是一个</target>
        </trans-unit>
        <trans-unit id="608c69ec5dc593b8e31469808e911c9b8c28fab1" translate="yes" xml:space="preserve">
          <source>If tcsh is your login shell then use the setenv command.</source>
          <target state="translated">如果tcsh是你的登录shell,那么使用setenv命令。</target>
        </trans-unit>
        <trans-unit id="6722301f4d6d5b294f3eee46d693b203a67e97d7" translate="yes" xml:space="preserve">
          <source>If that doesn't make much sense, consider the analogy of a command pipeline. Say you have a shell script stored in the compressed file</source>
          <target state="translated">如果这没什么意义,可以考虑一下命令管道的比喻。假设你有一个存储在压缩文件中的shell脚本</target>
        </trans-unit>
        <trans-unit id="0ce337d0a942d7a20e0ccbeff20a1fe0816cdba5" translate="yes" xml:space="preserve">
          <source>If that doesn't work (it relies on features of your stdio implementation), then you need something more like this:</source>
          <target state="translated">如果这还不行(它依赖于你的stdio实现的特性),那么你需要更多类似这样的东西。</target>
        </trans-unit>
        <trans-unit id="ace9cde0327f63e0372278440efb1605dee92be3" translate="yes" xml:space="preserve">
          <source>If that doesn't work (some I/O implementations are particularly cantankerous), you might need something like this:</source>
          <target state="translated">如果这样不行(有些I/O实现特别暴躁),你可能需要这样的东西。</target>
        </trans-unit>
        <trans-unit id="76b21d1151e484221dbc92ea1c2c56d3ec4082a9" translate="yes" xml:space="preserve">
          <source>If that doesn't work, give up on your stdio package and use sysread.</source>
          <target state="translated">如果不行的话,放弃你的stdio包,使用sysread。</target>
        </trans-unit>
        <trans-unit id="0580b926aa13464eaf5222ef23bd075e2a2e806d" translate="yes" xml:space="preserve">
          <source>If that doesn't work, try seeking to a different part of the file and then back.</source>
          <target state="translated">如果不行,请尝试寻找到文件的不同部分,然后再返回。</target>
        </trans-unit>
        <trans-unit id="b4eb30982662b9e20db4ab3ae1666e6a76a6e58a" translate="yes" xml:space="preserve">
          <source>If that doesn't work, try seeking to a different part of the file, reading something, and then seeking back.</source>
          <target state="translated">如果不行,请尝试寻找文件的不同部分,读取一些东西,然后再寻找回来。</target>
        </trans-unit>
        <trans-unit id="4c63d398b08eb5cb7f3f37514cbe92856008dc42" translate="yes" xml:space="preserve">
          <source>If that gives too much output every day, you may want to watch only for three modules. You can write</source>
          <target state="translated">如果每天给的输出太多,你可能想只看三个模块。你可以写</target>
        </trans-unit>
        <trans-unit id="0c73f5392dc820a97b0a4426cb998de73cb28f26" translate="yes" xml:space="preserve">
          <source>If that warnings category has been set to &quot;FATAL&quot; in the calling module then die. Otherwise return.</source>
          <target state="translated">如果该警告类别在调用模块中被设置为 &quot;FATAL&quot;,则死机。否则返回。</target>
        </trans-unit>
        <trans-unit id="313f3cd86007469b883802f17e39affb3f8c8794" translate="yes" xml:space="preserve">
          <source>If that warnings category has been set to &quot;FATAL&quot; in the scope where &lt;code&gt;$object&lt;/code&gt; is first used then die. Otherwise return.</source>
          <target state="translated">如果在第一次使用 &lt;code&gt;$object&lt;/code&gt; 的范围内将该警告类别设置为&amp;ldquo; FATAL&amp;rdquo;，则将死亡。否则返回。</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="4493cf703f913ddbd099cc80db075e294c3617b1" translate="yes" xml:space="preserve">
          <source>If the &quot;external&quot; protocol is specified, the ping() method attempts to use the &lt;code&gt;Net::Ping::External&lt;/code&gt; module to ping the remote host. &lt;code&gt;Net::Ping::External&lt;/code&gt; interfaces with your system's default &lt;code&gt;ping&lt;/code&gt; utility to perform the ping, and generally produces relatively accurate results. If &lt;code&gt;Net::Ping::External&lt;/code&gt; if not installed on your system, specifying the &quot;external&quot; protocol will result in an error.</source>
          <target state="translated">如果指定了&amp;ldquo;外部&amp;rdquo;协议，则ping（）方法将尝试使用 &lt;code&gt;Net::Ping::External&lt;/code&gt; 模块对远程主机执行ping操作。 &lt;code&gt;Net::Ping::External&lt;/code&gt; 与系统的默认 &lt;code&gt;ping&lt;/code&gt; 实用程序进行交互以执行ping，并且通常会产生相对准确的结果。如果未在系统上安装 &lt;code&gt;Net::Ping::External&lt;/code&gt; ，则指定&amp;ldquo;外部&amp;rdquo;协议将导致错误。</target>
        </trans-unit>
        <trans-unit id="b022b01a378125712b4875c54365686882089f63" translate="yes" xml:space="preserve">
          <source>If the &quot;icmp&quot; protocol is specified, the ping() method sends an icmp echo message to the remote host, which is what the UNIX ping program does. If the echoed message is received from the remote host and the echoed information is correct, the remote host is considered reachable. Specifying the &quot;icmp&quot; protocol requires that the program be run as root or that the program be setuid to root.</source>
          <target state="translated">如果指定了 &quot;icmp &quot;协议,ping()方法就会向远程主机发送一个icmp回音信息,这就是UNIX ping程序的工作。如果收到远程主机的回音信息,并且回音信息正确,则认为远程主机是可以到达的。指定 &quot;icmp &quot;协议需要程序以root身份运行,或者程序的setuid为root。</target>
        </trans-unit>
        <trans-unit id="c3280089081e0a65bf27928777cbd13d99f6f66b" translate="yes" xml:space="preserve">
          <source>If the &quot;syn&quot; protocol is specified, the ping() method will only send a TCP SYN packet to the remote host then immediately return. If the syn packet was sent successfully, it will return a true value, otherwise it will return false. NOTE: Unlike the other protocols, the return value does NOT determine if the remote host is alive or not since the full TCP three-way handshake may not have completed yet. The remote host is only considered reachable if it receives a TCP ACK within the timeout specified. To begin waiting for the ACK packets, use the ack() method as explained below. Use the &quot;syn&quot; protocol instead the &quot;tcp&quot; protocol to determine reachability of multiple destinations simultaneously by sending parallel TCP SYN packets. It will not block while testing each remote host. demo/fping is provided in this distribution to demonstrate the &quot;syn&quot; protocol as an example. This protocol does not require any special privileges.</source>
          <target state="translated">如果指定了 &quot;syn &quot;协议,ping()方法将只向远程主机发送一个TCP SYN数据包,然后立即返回。如果syn数据包发送成功,它将返回一个true值,否则将返回false。注意:与其他协议不同,返回值并不决定远程主机是否还活着,因为完整的TCP三方握手可能还没有完成。只有在指定的超时内收到TCP ACK,远程主机才被认为是可到达的。要开始等待ACK数据包,请使用下面解释的ack()方法。使用 &quot;syn &quot;协议代替 &quot;tcp &quot;协议,通过发送平行的tcp SYN数据包来同时确定多个目的地的可到达性。在这个发行版中提供了demo/fping作为例子来演示 &quot;syn &quot;协议。这个协议不需要任何特殊的权限。</target>
        </trans-unit>
        <trans-unit id="318d6b49d6250a4816190433cf297845eb70cba7" translate="yes" xml:space="preserve">
          <source>If the $crc parameters is &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the crc value will be reset.</source>
          <target state="translated">如果$ crc参数为 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则将重置crc值。</target>
        </trans-unit>
        <trans-unit id="abcc06c7fad286b05b36114515df89ab3f899db0" translate="yes" xml:space="preserve">
          <source>If the $crc parameters is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the crc value will be reset.</source>
          <target state="translated">如果$ crc参数为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则将重置crc值。</target>
        </trans-unit>
        <trans-unit id="302e31c3384df8bb8c31ef52a9d8291c6e65b38e" translate="yes" xml:space="preserve">
          <source>If the $must_be_file argument is provided and is TRUE, then return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; unless the image looks like it belongs to a file dump.</source>
          <target state="translated">如果提供了$ must_be_file参数且该参数为TRUE，则除非图像看起来像属于文件转储，否则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="865165ad77b0593f721d466f6d0ebabfe1d34482" translate="yes" xml:space="preserve">
          <source>If the $string is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果$ string是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="076c07280263c9d15e3255695b14d837c538bc87" translate="yes" xml:space="preserve">
          <source>If the &amp;lt;$input_filename_or_reference&amp;gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for reading and the input data will be read from it.</source>
          <target state="translated">如果&amp;lt;$ input_filename_or_reference&amp;gt;参数是一个简单的标量，则假定它是一个文件名。将打开该文件以进行读取，并从中读取输入数据。</target>
        </trans-unit>
        <trans-unit id="e6e87357913d48be4073006d8b0866ceef5457d5" translate="yes" xml:space="preserve">
          <source>If the 'name' is '&amp;amp;' the corresponding entry in the PAD is a CV representing a possible closure.</source>
          <target state="translated">如果&amp;ldquo;名称&amp;rdquo;为&amp;ldquo;＆&amp;rdquo;，则PAD中的对应条目为表示可能关闭的CV。</target>
        </trans-unit>
        <trans-unit id="45cb5ded2282f7dcd41dd84a212cb40770ba3961" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;-W&lt;/b&gt; flag is used on the command line, it will enable all warnings throughout the program regardless of whether warnings were disabled locally using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; or &lt;code&gt;$^W =0&lt;/code&gt; . This includes all files that get included via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;. Think of it as the Perl equivalent of the &quot;lint&quot; command.</source>
          <target state="translated">如果&lt;b&gt;-W&lt;/b&gt;标志在命令行中使用，它将使整个程序中的所有警告，无论是否警告被禁用本地使用 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; 或 &lt;code&gt;$^W =0&lt;/code&gt; 。这包括通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 包含的所有文件。可以将其视为Perl中&amp;ldquo; lint&amp;rdquo;命令的等效项。</target>
        </trans-unit>
        <trans-unit id="544ad5b88e657a2b04055790eb69377a583771e6" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;ExtUtils::Embed&lt;/b&gt; module isn't part of your Perl distribution, you can retrieve it from &lt;a href=&quot;http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/&quot;&gt;http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/&lt;/a&gt; (If this documentation came from your Perl distribution, then you're running 5.004 or better and you already have it.)</source>
          <target state="translated">如果&lt;b&gt;ExtUtils :: Embed&lt;/b&gt;模块不是Perl发行版的一部分，则可以从&lt;a href=&quot;http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/&quot;&gt;http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/&lt;/a&gt;检索（如果此文档来自您的Perl发行版，那么您正在运行5.004或更高版本，并且已经拥有它。）</target>
        </trans-unit>
        <trans-unit id="40e97ddfc26315857071022b6a58a8c5330f9bda" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;-S&quot;&lt;/code&gt; or &lt;code&gt;-&quot;S&quot;&lt;/code&gt; switch is present</source>
          <target state="translated">如果存在 &lt;code&gt;&quot;-S&quot;&lt;/code&gt; 或 &lt;code&gt;-&quot;S&quot;&lt;/code&gt; 开关</target>
        </trans-unit>
        <trans-unit id="bcfb6b5f36fe9b097b6d4cfdd0d5b8347d4498d3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;#!&lt;/code&gt; line does not contain the word &quot;perl&quot; nor the word &quot;indir&quot; the program named after the &lt;code&gt;#!&lt;/code&gt; is executed instead of the Perl interpreter. This is slightly bizarre, but it helps people on machines that don't do &lt;code&gt;#!&lt;/code&gt; , because they can tell a program that their SHELL is</source>
          <target state="translated">如果是 &lt;code&gt;#!&lt;/code&gt; 行以 &lt;code&gt;#!&lt;/code&gt; 命名的程序中不包含单词&amp;ldquo; perl&amp;rdquo;或单词&amp;ldquo; indir&amp;rdquo; 。执行而不是Perl解释器。这有点奇怪，但是它可以帮助不使用 &lt;code&gt;#!&lt;/code&gt; 机器上的人！，因为他们可以告诉程序其外壳是</target>
        </trans-unit>
        <trans-unit id="263d47f71006c52e232d04a65727d383732b439a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$Encode::Guess::NoUTFAutoGuess&lt;/code&gt; variable is set to a true value, no heuristics will be applied to UTF8/16/32, and the result will be limited to the suspects and &lt;code&gt;ascii&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;$Encode::Guess::NoUTFAutoGuess&lt;/code&gt; 变量设置为true值，则不会对UTF8 / 16/32施加启发式方法，并且结果将限于可疑对象和 &lt;code&gt;ascii&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ad3f883582e4c647a3748b90c080c6161d8d898" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle, the compressed data will be read from it. The string '-' can be used as an alias for standard input.</source>
          <target state="translated">如果 &lt;code&gt;$input&lt;/code&gt; 参数是一个文件句柄，则将从中读取压缩的数据。字符串&amp;ldquo;-&amp;rdquo;可用作标准输入的别名。</target>
        </trans-unit>
        <trans-unit id="7b21ca0ba17da1de5557b8c2561a39c672e345ba" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input&lt;/code&gt; parameter is a scalar, it is assumed to be a filename. This file will be opened for reading and the compressed data will be read from it.</source>
          <target state="translated">如果 &lt;code&gt;$input&lt;/code&gt; 参数为标量，则假定为文件名。将打开该文件以进行读取，并从中读取压缩的数据。</target>
        </trans-unit>
        <trans-unit id="8c806bbadc7d9dce5be50aca2c285d39455523f0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter is a filehandle, the input data will be read from it. The string '-' can be used as an alias for standard input.</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 参数是一个文件句柄，则将从中读取输入数据。字符串&amp;ldquo;-&amp;rdquo;可用作标准输入的别名。</target>
        </trans-unit>
        <trans-unit id="573972f31f94bcc5ce697159aca1ad87294adc22" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter is any other type, &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 参数是任何其他类型，则将返回 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f4cccbcdf0c65cc8f40030797afae3d268325f9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$need&lt;/code&gt; argument is given then it will check that the current version (as defined by the $VERSION variable in the package) is greater than or equal to &lt;code&gt;$need&lt;/code&gt; ; it will die if this is not the case. This method is called automatically by the &lt;code&gt;VERSION&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果给出了 &lt;code&gt;$need&lt;/code&gt; 参数，它将检查当前版本（由包中的$ VERSION变量定义）是否大于或等于 &lt;code&gt;$need&lt;/code&gt; ；如果不是这种情况，它将死亡。此方法由 &lt;code&gt;VERSION&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 形式自动调用。</target>
        </trans-unit>
        <trans-unit id="4e612a8de15e6e3ebce7b57945845f8b7dc29222" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle, the compressed data will be written to it. The string '-' can be used as an alias for standard output.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数是一个文件句柄，则将压缩的数据写入其中。字符串&amp;ldquo;-&amp;rdquo;可用作标准输出的别名。</target>
        </trans-unit>
        <trans-unit id="ca1b12c1cf4a15c9b6156dfb74283d87ea201fd5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for writing and the compressed data will be written to it.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数是一个简单的标量，则假定它是一个文件名。将打开该文件以进行写入，并将压缩的数据写入其中。</target>
        </trans-unit>
        <trans-unit id="59757227a4fe8fdd27a95b595bd3ff8c8a163939" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数为任何其他类型，则 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; :: new将返回undef。</target>
        </trans-unit>
        <trans-unit id="cadc0cd9a0990edba8eef6811ffbf43a8f495bbc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数为任何其他类型，则 &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; :: new将返回undef。</target>
        </trans-unit>
        <trans-unit id="3e714bc9d0ca60a68f45566881bf3e6145bc1ce5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数为任何其他类型，则 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; :: new将返回undef。</target>
        </trans-unit>
        <trans-unit id="876928fea8ebdaa591df8075f9c404fb23d04a28" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数为任何其他类型，则 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; :: new将返回undef。</target>
        </trans-unit>
        <trans-unit id="38552f9e6ec9c67c09d8bddc8275dd8bdd5d8803" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Zip&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数为任何其他类型，则 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; :: new将返回undef。</target>
        </trans-unit>
        <trans-unit id="cc18113fea92f93f29a91b56f7f76e4dd3fc2c3e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is a filehandle, the compressed data will be written to it. The string '-' can be used as an alias for standard output.</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 参数是文件句柄，则将压缩的数据写入其中。字符串&amp;ldquo;-&amp;rdquo;可用作标准输出的别名。</target>
        </trans-unit>
        <trans-unit id="b000e8d3bf3971a53c3d271eb802381bc6b99814" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is a filehandle, the uncompressed data will be written to it. The string '-' can be used as an alias for standard output.</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 参数是文件句柄，则将未压缩的数据写入其中。字符串&amp;ldquo;-&amp;rdquo;可用作标准输出的别名。</target>
        </trans-unit>
        <trans-unit id="4843925dd2f30aabd060449fee92e5566394585d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for writing and the compressed data will be written to it.</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 参数是一个简单的标量，则假定它是一个文件名。将打开该文件以进行写入，并将压缩的数据写入其中。</target>
        </trans-unit>
        <trans-unit id="82c61471bec0e7ab85ea6d51b841a7cd924bb91c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for writing and the uncompressed data will be written to it.</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 参数是一个简单的标量，则假定它是一个文件名。该文件将被打开以进行写入，并且未压缩的数据将被写入其中。</target>
        </trans-unit>
        <trans-unit id="171f6debdc3c19e16dbddc9b4ccb5eb09a1f9e1d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is any other type, &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 参数是任何其他类型，则将返回 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2259a2e974894cbf8831f8e74de6dee67d652d9c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$regexp&lt;/code&gt; variable contains a code expression, the user could then execute arbitrary Perl code. For instance, some joker could search for &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;('rm -rf *');&lt;/code&gt; to erase your files. In this sense, the combination of interpolation and code expressions</source>
          <target state="translated">如果 &lt;code&gt;$regexp&lt;/code&gt; 变量包含一个代码表达式，则用户可以执行任意Perl代码。例如，一些小丑可以搜索 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;('rm -rf *');&lt;/code&gt; 删除文件。从这个意义上讲，内插和代码表达式的组合</target>
        </trans-unit>
        <trans-unit id="cead10e67b406c29ab565d567b9609063d5776ca" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a buffer, this method will return &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$z&lt;/code&gt; 对象与缓冲区关联，则此方法将返回 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58dcaddb355cecd931c021172a4bedf908dd76a9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a file or a filehandle, &lt;code&gt;&lt;a href=&quot;../../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; will return the underlying file descriptor. Once the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called &lt;code&gt;&lt;a href=&quot;../../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$z&lt;/code&gt; 对象与文件或文件句柄关联，则 &lt;code&gt;&lt;a href=&quot;../../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 将返回基础文件描述符。一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法， &lt;code&gt;&lt;a href=&quot;../../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 将返回 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8acbfda88a1601bef7d039c62529de82f9b15c5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a file or a filehandle, this method returns the current autoflush setting for the underlying filehandle. If &lt;code&gt;EXPR&lt;/code&gt; is present, and is non-zero, it will enable flushing after every write/print operation.</source>
          <target state="translated">如果 &lt;code&gt;$z&lt;/code&gt; 对象与文件或文件句柄关联，则此方法返回基础文件句柄的当前自动刷新设置。如果存在 &lt;code&gt;EXPR&lt;/code&gt; ，并且EXPR不为零，则它将在每次写入/打印操作后启用刷新。</target>
        </trans-unit>
        <trans-unit id="4f22b38f141c1394908e5c44c3cf641e6013a601" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;(*ACCEPT)&lt;/code&gt; is inside of capturing groups then the groups are marked as ended at the point at which the &lt;code&gt;(*ACCEPT)&lt;/code&gt; was encountered. For instance:</source>
          <target state="translated">如果 &lt;code&gt;(*ACCEPT)&lt;/code&gt; 在捕获组中，则将这些组标记为在遇到 &lt;code&gt;(*ACCEPT)&lt;/code&gt; 的点结束。例如：</target>
        </trans-unit>
        <trans-unit id="d96d9f9f8c91a22bdf7e1a3536eeb47596adfe1c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-Strict&lt;/code&gt; option is disabled, the comment field can contain any character except NULL. If any null characters are present, the field will be truncated at the first NULL.</source>
          <target state="translated">如果禁用 &lt;code&gt;-Strict&lt;/code&gt; 选项，则注释字段可以包含除NULL之外的任何字符。如果存在任何null字符，则该字段将在第一个NULL处被截断。</target>
        </trans-unit>
        <trans-unit id="8a0625a9517209d9c735d420fbb7b372c06cae56" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-Strict&lt;/code&gt; option is enabled, &lt;code&gt;$string&lt;/code&gt; can only consist of ISO 8859-1 characters.</source>
          <target state="translated">如果启用了 &lt;code&gt;-Strict&lt;/code&gt; 选项，则 &lt;code&gt;$string&lt;/code&gt; 只能包含ISO 8859-1字符。</target>
        </trans-unit>
        <trans-unit id="7e727e67c9a9b626ab111993b625d6fae0b44b5e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-Strict&lt;/code&gt; option is enabled, the comment can only consist of ISO 8859-1 characters plus line feed.</source>
          <target state="translated">如果启用了 &lt;code&gt;-Strict&lt;/code&gt; 选项，则注释只能由ISO 8859-1字符加换行符组成。</target>
        </trans-unit>
        <trans-unit id="687858bb0364e03075315214e49915f4063efd20" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-i&lt;/code&gt; switch is present but no extension for a backup copy is given, then inplace editing creates a new version of a file; the existing copy is not deleted. (Note that if an extension is given, an existing file is renamed to the backup file, as is the case under other operating systems, so it does not remain as a previous version under the original filename.)</source>
          <target state="translated">如果存在 &lt;code&gt;-i&lt;/code&gt; 开关，但未提供备份副本的扩展名，则就地编辑将创建文件的新版本；现有副本不会被删除。（请注意，如果指定了扩展名，则现有文件将重命名为备份文件，就像在其他操作系统下一样，因此它不会保留为原始文件名下的先前版本。）</target>
        </trans-unit>
        <trans-unit id="45a06195ed61d1ad05b053f7cec670bab3d1b47d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/c&lt;/code&gt; modifier is specified, the</source>
          <target state="translated">如果指定了 &lt;code&gt;/c&lt;/code&gt; 修饰符，则</target>
        </trans-unit>
        <trans-unit id="61f363164df63c08b01c2f8d842eb83178238fca" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/d&lt;/code&gt; modifier is used, the</source>
          <target state="translated">如果使用 &lt;code&gt;/d&lt;/code&gt; 修饰符，则</target>
        </trans-unit>
        <trans-unit id="228d53bdcd18fe101fa332b95e05c49d501e9bd9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/g&lt;/code&gt; option is not used, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; in list context returns a list consisting of the subexpressions matched by the parentheses in the pattern, that is, (&lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; ...) (Note that here &lt;code&gt;$1&lt;/code&gt; etc. are also set). When there are no parentheses in the pattern, the return value is the list &lt;code&gt;(1)&lt;/code&gt; for success. With or without parentheses, an empty list is returned upon failure.</source>
          <target state="translated">如果未使用 &lt;code&gt;/g&lt;/code&gt; 选项，则列表上下文中的 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 将返回一个列表，该列表由与该模式中的括号匹配的子表达式组成，即（ &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ， &lt;code&gt;$3&lt;/code&gt; ...）（请注意此处 &lt;code&gt;$1&lt;/code&gt; 等。也设置）。当模式中没有括号时，返回值是成功的列表 &lt;code&gt;(1)&lt;/code&gt; 。有或没有括号，失败时将返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="f3f80ef36f0d767bd1b67ec24494f102a4ec7c1e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option is present, a new copy of the string is made and its characters transliterated, and this copy is returned no matter whether it was modified or not: the original string is always left unchanged. The new copy is always a plain string, even if the input string is an object or a tied variable.</source>
          <target state="translated">如果存在 &lt;code&gt;/r&lt;/code&gt; （非破坏性）选项，则将创建字符串的新副本并将其字符音译，并且无论是否对其进行了修改，都将返回此副本：原始字符串始终保持不变。即使输入字符串是对象或绑定变量，新副本也始终是纯字符串。</target>
        </trans-unit>
        <trans-unit id="a9229f75d9765b6c9e80a754666b4ec3786ce235" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option is used then it runs the substitution on a copy of the string and instead of returning the number of substitutions, it returns the copy whether or not a substitution occurred. The original string is never changed when &lt;code&gt;/r&lt;/code&gt; is used. The copy will always be a plain string, even if the input is an object or a tied variable.</source>
          <target state="translated">如果使用 &lt;code&gt;/r&lt;/code&gt; （非破坏性）选项，则它将在字符串的副本上运行替换，并且不返回替换数，而是返回副本（无论是否发生替换）。使用 &lt;code&gt;/r&lt;/code&gt; 时，原始字符串永远不会更改。即使输入是对象或绑定变量，副本也始终是纯字符串。</target>
        </trans-unit>
        <trans-unit id="98015ad9cab949396e11223bb4b809b828f32a12" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ADLER32&lt;/code&gt; option is not enabled in the constructor for this object, this method will always return 0;</source>
          <target state="translated">如果在构造函数中未为此对象启用 &lt;code&gt;ADLER32&lt;/code&gt; 选项，则此方法将始终返回0；否则，此方法将始终返回0。</target>
        </trans-unit>
        <trans-unit id="e7e3cc3b120420d3fe3e5903cbe74d0d544abd6d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to false, the output buffers in the &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; and &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; methods will be truncated before uncompressed data is written to them.</source>
          <target state="translated">如果 &lt;code&gt;AppendOutput&lt;/code&gt; 选项设置为false，则 &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; 和 &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; 方法中的输出缓冲区将被截断，然后再将未压缩的数据写入它们。</target>
        </trans-unit>
        <trans-unit id="dc67d2e9493b30b20a1a27f63c6bc36f875e42fb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to true in the constructor for the &lt;code&gt;$d&lt;/code&gt; object, the compressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If it is false, &lt;code&gt;$output&lt;/code&gt; will be truncated before any compressed data is written to it.</source>
          <target state="translated">如果在 &lt;code&gt;$d&lt;/code&gt; 对象的构造函数中将 &lt;code&gt;AppendOutput&lt;/code&gt; 选项设置为true ，则压缩数据将附加到 &lt;code&gt;$output&lt;/code&gt; 。如果为false，则在将任何压缩数据写入 &lt;code&gt;$output&lt;/code&gt; 之前将其截断。</target>
        </trans-unit>
        <trans-unit id="241ec910d4c3fc198870214959a19e4587117b91" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to true in the constructor for this object, the uncompressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If it is false, &lt;code&gt;$output&lt;/code&gt; will be truncated before any uncompressed data is written to it.</source>
          <target state="translated">如果在此对象的构造函数中将 &lt;code&gt;AppendOutput&lt;/code&gt; 选项设置为true，则未压缩的数据将附加到 &lt;code&gt;$output&lt;/code&gt; 。如果为false，则在将任何未压缩的数据写入 &lt;code&gt;$output&lt;/code&gt; 之前，$ output将被截断。</target>
        </trans-unit>
        <trans-unit id="23a4bdafd5b4aee2bfba5a403d17509d788319bb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Archive::Tar&lt;/code&gt; module is installed and either the &lt;code&gt;uncompress&lt;/code&gt; or &lt;code&gt;gunzip&lt;/code&gt; programs are available, you can use one of these workarounds to read &lt;code&gt;.tar.Z&lt;/code&gt; files.</source>
          <target state="translated">如果安装了 &lt;code&gt;Archive::Tar&lt;/code&gt; 模块并且 &lt;code&gt;uncompress&lt;/code&gt; 程序或 &lt;code&gt;gunzip&lt;/code&gt; 程序可用，则可以使用以下变通办法之一来读取 &lt;code&gt;.tar.Z&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="da717ba776ac7b943780ea377cd85c35cc7f2655" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::Bzip2 object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::压缩:: Bzip2的对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="2451f14f493fd0c1b2a744f1ca680885802c97fb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::Deflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::压缩::减缩对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="a262cca6ca624ccbcc230f0a9a299f301469ea87" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::Gzip object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::压缩:: Gzip已物体时选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="e1abc2a1019c01d985ed7b90e95e969f6f299bf2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::RawDeflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::压缩:: RawDeflate对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="f5ea66329ad2b4187630d779016bfcf01873661d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::Zip object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::压缩::邮编对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="efa0131be286b8ee087293f106c69cc7176b941b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::AnyInflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::解压缩:: AnyInflate对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="d7295924866c46c6268e8a714d1d64a580c31683" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::AnyUncompress object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::解压缩:: AnyUncompress对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="d590344cfdd3022553efe336602191d1dbf477b6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::Bunzip2 object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::解压缩:: bunzip2命令对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="d48a250e20975c54010e5628db4f5baad9a34122" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::Gunzip object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::解压缩:: gunzip文件对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="52452c9550cd8363c6c8237af362cc345e53f457" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::Inflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::解压缩::膨胀对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="34f0502573716752984911463b9f0d1cdbf46468" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::RawInflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::解压缩:: RawInflate对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="a4a69474f66acefa05c78e7afea37ef49d0b67b4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::Unzip object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::解压缩解压::对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="c5ac2a9fbc05192cf46afe1261683a81419aaa4d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CRC32&lt;/code&gt; option is not enabled in the constructor for this object, this method will always return 0;</source>
          <target state="translated">如果在构造函数中未为此对象启用 &lt;code&gt;CRC32&lt;/code&gt; 选项，则此方法将始终返回0；否则，此方法将始终返回0。</target>
        </trans-unit>
        <trans-unit id="1078abcc96e5bc5e00a4c013f64ebcf42ad64647" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ConsumeInput&lt;/code&gt; option has been set to true when the &lt;code&gt;Compress::Raw::Zlib::Inflate&lt;/code&gt; object is created, the &lt;code&gt;$input&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt; . On completion it will contain what remains of the input buffer after inflation. In practice, this means that when the return status is &lt;code&gt;Z_OK&lt;/code&gt; the &lt;code&gt;$input&lt;/code&gt; parameter will contain an empty string, and when the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$input&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="translated">如果在 &lt;code&gt;ConsumeInput&lt;/code&gt; &lt;code&gt;Compress::Raw::Zlib::Inflate&lt;/code&gt; 对象时ConsumeInput选项已设置为true ，则 &lt;code&gt;$input&lt;/code&gt; 参数将由 &lt;code&gt;inflate&lt;/code&gt; 修改。完成后，它将包含充气后输入缓冲区的剩余内容。实际上，这意味着当返回状态为 &lt;code&gt;Z_OK&lt;/code&gt; 时， &lt;code&gt;$input&lt;/code&gt; 参数将包含一个空字符串，而当返回状态为 &lt;code&gt;Z_STREAM_END&lt;/code&gt; 时， &lt;code&gt;$input&lt;/code&gt; 参数将包含在放气数据之后存储在输入缓冲区中的内容（如果有的话）流。</target>
        </trans-unit>
        <trans-unit id="6a12981a50e52bd8360e58342fda216fd19888ef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Encode::LEAVE_SRC&lt;/code&gt; bit is</source>
          <target state="translated">如果 &lt;code&gt;Encode::LEAVE_SRC&lt;/code&gt; 位为</target>
        </trans-unit>
        <trans-unit id="1bd3991b928d2bed7eef1e209952394cc1a3b16f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Listen&lt;/code&gt; argument is given, but false, the queue size will be set to 5.</source>
          <target state="translated">如果给出 &lt;code&gt;Listen&lt;/code&gt; 参数，但为false，则队列大小将设置为5。</target>
        </trans-unit>
        <trans-unit id="1143100ee61e97ea2197747ccc58abb62c39ba7a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Minimal&lt;/code&gt; option is set to true, this option will be ignored.</source>
          <target state="translated">如果将&amp;ldquo; &lt;code&gt;Minimal&lt;/code&gt; 选项设置为true，则将忽略此选项。</target>
        </trans-unit>
        <trans-unit id="9b0cd9b590461a3324fa8fa68396f36ebee97301" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Strict&lt;/code&gt; is on it will automatically enable this option.</source>
          <target state="translated">如果启用 &lt;code&gt;Strict&lt;/code&gt; ，它将自动启用此选项。</target>
        </trans-unit>
        <trans-unit id="1a5a03dfea212cb5b29a1fbf2d5e717d48359451" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;YAML&lt;/code&gt; or the &lt;code&gt;YAML::Syck&lt;/code&gt; module is installed a record of the internal state of all modules is written to disk after each step. The files contain a signature of the currently running perl version for later perusal.</source>
          <target state="translated">如果安装了 &lt;code&gt;YAML&lt;/code&gt; 或 &lt;code&gt;YAML::Syck&lt;/code&gt; 模块，则在每个步骤之后，所有模块的内部状态记录都会写入磁盘。这些文件包含当前运行的perl版本的签名，以供日后阅读。</target>
        </trans-unit>
        <trans-unit id="c82a6fc0a2f95bf7629d02360284d3c7a1ca8a6f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;can&lt;/code&gt; returns false, then that is passed to &lt;code&gt;ok&lt;/code&gt; . If it returns true, then the larger expression &lt;code&gt;$thingy-&amp;gt;can('some_method') &amp;amp;&amp;amp; 1&lt;/code&gt; returns 1, which &lt;code&gt;ok&lt;/code&gt; sees as a simple signal of success, as you would expect.</source>
          <target state="translated">如果 &lt;code&gt;can&lt;/code&gt; 返回false，则将其传递给 &lt;code&gt;ok&lt;/code&gt; 。如果返回true，那么更大的表达式 &lt;code&gt;$thingy-&amp;gt;can('some_method') &amp;amp;&amp;amp; 1&lt;/code&gt; 返回1，即 &lt;code&gt;ok&lt;/code&gt; 认为是成功的一个简单的信号，如你所愿。</target>
        </trans-unit>
        <trans-unit id="8bb03363c1cc83c40db7187bc0c1808c11643507" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;charscript()&lt;/code&gt; argument is not a known script, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;charscript()&lt;/code&gt; 参数不是已知脚本，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15aaa040db904ad0d7e939ff87d0289e4ed113e7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;decimal string --&amp;gt; native integer&lt;/code&gt; conversion cannot be done without loss of information, the result is compatible with the conversion sequence &lt;code&gt;decimal_string --&amp;gt; native_floating_point --&amp;gt; native_integer&lt;/code&gt; . In particular, rounding is strongly biased to 0, though a number like &lt;code&gt;&quot;0.99999999999999999999&quot;&lt;/code&gt; has a chance of being rounded to 1.</source>
          <target state="translated">如果不能在不丢失信息的情况下完成 &lt;code&gt;decimal string --&amp;gt; native integer&lt;/code&gt; 转换，则结果与转换顺序十进制字符串- &lt;code&gt;decimal_string --&amp;gt; native_floating_point --&amp;gt; native_integer&lt;/code&gt; 。特别是，尽管 &lt;code&gt;&quot;0.99999999999999999999&quot;&lt;/code&gt; 类的数字可能会四舍五入，但舍入强烈偏向0 。</target>
        </trans-unit>
        <trans-unit id="6e4484ac7779a53de50aea47a7a5981f680fda36" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;encoding&lt;/code&gt; pragma is in scope then the lengths returned are calculated from the length of &lt;code&gt;$/&lt;/code&gt; in Unicode characters, which is not always the same as the length of &lt;code&gt;$/&lt;/code&gt; in the native encoding.</source>
          <target state="translated">如果 &lt;code&gt;encoding&lt;/code&gt; 杂项在范围内，则返回的长度是根据Unicode字符中 &lt;code&gt;$/&lt;/code&gt; 的长度计算得出的，而该长度并不总是与本机编码中 &lt;code&gt;$/&lt;/code&gt; 的长度相同。</target>
        </trans-unit>
        <trans-unit id="bb917cbee0d97141aac38b7ae445c57c18b27f43" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;export_fail&lt;/code&gt; method returns an empty list then no error is recorded and all the requested symbols are exported. If the returned list is not empty then an error is generated for each symbol and the export fails. The Exporter provides a default &lt;code&gt;export_fail&lt;/code&gt; method which simply returns the list unchanged.</source>
          <target state="translated">如果 &lt;code&gt;export_fail&lt;/code&gt; 方法返回一个空列表，则不会记录任何错误，并且会导出所有请求的符号。如果返回的列表不为空，则为每个符号生成错误，并且导出失败。导出器提供了默认的 &lt;code&gt;export_fail&lt;/code&gt; 方法，该方法只返回不变的列表。</target>
        </trans-unit>
        <trans-unit id="276362d098a443c72a3870f2a2d48ae260499ef9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gv&lt;/code&gt; is present and is not in the symbol table, then this function simply returns. This checked will be skipped if &lt;code&gt;flags &amp;amp; 1&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;gv&lt;/code&gt; 存在并且不在符号表中，则此函数简单地返回。如果 &lt;code&gt;flags &amp;amp; 1&lt;/code&gt; 将被跳过。</target>
        </trans-unit>
        <trans-unit id="798f35bb0e17493f55f47f1e0e601507174d7021" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;maxdepth&lt;/code&gt; is included, it must be a numeral</source>
          <target state="translated">如果包括 &lt;code&gt;maxdepth&lt;/code&gt; ，则必须为数字</target>
        </trans-unit>
        <trans-unit id="4672f4a6483db1b05eeb609d8e652aab384c295c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;timelocal()&lt;/code&gt; function is given a non-existent local time, it will simply return an epoch value for the time one hour later.</source>
          <target state="translated">如果给 &lt;code&gt;timelocal()&lt;/code&gt; 函数提供了不存在的本地时间，则它将仅在一个小时后返回该时间的纪元值。</target>
        </trans-unit>
        <trans-unit id="d8b1721e1ae657f367e4018c29dc66b147cf1c09" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;uncompress&lt;/code&gt; or &lt;code&gt;gunzip&lt;/code&gt; programs are available, you can use one of these workarounds to read &lt;code&gt;.tar.Z&lt;/code&gt; files from &lt;code&gt;Archive::Tar&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;uncompress&lt;/code&gt; 程序或 &lt;code&gt;gunzip&lt;/code&gt; 程序可用，则可以使用以下变通办法之一来从 &lt;code&gt;Archive::Tar&lt;/code&gt; 读取 &lt;code&gt;.tar.Z&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="cddc99dbc25aed0c730c0fe2bb39cef906b6e6a7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;unicode_eval&lt;/code&gt; feature is enabled (which is the default under a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.16&lt;/code&gt; or higher declaration), EXPR or &lt;code&gt;$_&lt;/code&gt; is treated as a string of characters, so &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declarations have no effect, and source filters are forbidden. In the absence of the &lt;code&gt;unicode_eval&lt;/code&gt; feature, the string will sometimes be treated as characters and sometimes as bytes, depending on the internal encoding, and source filters activated within the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; exhibit the erratic, but historical, behaviour of affecting some outer file scope that is still compiling. See also the &lt;a href=&quot;#evalbytes&quot;&gt;evalbytes&lt;/a&gt; keyword, which always treats its input as a byte stream and works properly with source filters, and the &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; pragma.</source>
          <target state="translated">如果启用了 &lt;code&gt;unicode_eval&lt;/code&gt; 功能（这是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.16&lt;/code&gt; 或更高版本的声明中的默认设置），则EXPR或 &lt;code&gt;$_&lt;/code&gt; 被视为字符串，因此 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 声明无效，并且禁止源过滤器。在缺少 &lt;code&gt;unicode_eval&lt;/code&gt; 功能的情况下，根据内部编码，有时会将字符串视为字符，有时视为字节，并且在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中激活的源过滤器会表现出影响某些外部文件范围的不稳定但历史性的行为。仍在编译。另请参阅&lt;a href=&quot;#evalbytes&quot;&gt;evalbytes&lt;/a&gt;关键字，该关键字始终将其输入视为字节流，并且可以与源过滤器和&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;杂注一起正常使用。</target>
        </trans-unit>
        <trans-unit id="87e45908e093ce58a5e789307a68cc9a88437767" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;unicode_eval&lt;/code&gt; feature is enabled (which is the default under a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; 5.16&lt;/code&gt; or higher declaration), EXPR or &lt;code&gt;$_&lt;/code&gt; is treated as a string of characters, so &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declarations have no effect, and source filters are forbidden. In the absence of the &lt;code&gt;unicode_eval&lt;/code&gt; feature, the string will sometimes be treated as characters and sometimes as bytes, depending on the internal encoding, and source filters activated within the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; exhibit the erratic, but historical, behaviour of affecting some outer file scope that is still compiling. See also the &lt;a href=&quot;evalbytes&quot;&gt;evalbytes&lt;/a&gt; keyword, which always treats its input as a byte stream and works properly with source filters, and the &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; pragma.</source>
          <target state="translated">如果启用了 &lt;code&gt;unicode_eval&lt;/code&gt; 功能（这是 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; 5.16&lt;/code&gt; 或更高版本的声明中的默认设置），则EXPR或 &lt;code&gt;$_&lt;/code&gt; 被视为字符串，因此 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 声明无效，并且禁止源过滤器。在缺少 &lt;code&gt;unicode_eval&lt;/code&gt; 功能的情况下，根据内部编码，有时会将字符串视为字符，有时视为字节，并且在 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中激活的源过滤器会表现出影响某些外部文件范围的不稳定但历史性的行为。仍在编译。另请参阅&lt;a href=&quot;evalbytes&quot;&gt;evalbytes&lt;/a&gt;关键字，该关键字始终将其输入视为字节流，并且可以与源过滤器和&lt;a href=&quot;../feature&quot;&gt;功能&lt;/a&gt;杂注一起正常使用。</target>
        </trans-unit>
        <trans-unit id="094a307e3b02182e7190ab8c7d41908a31be7b6f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;utf8&lt;/code&gt; option is not given, the encoding of its output file handle will be forced to the detected encoding of the input POD, which preserves whatever the input text is. This ensures backward compatibility with earlier, pre-Unicode versions of this module, without large numbers of Perl warnings.</source>
          <target state="translated">如果未提供 &lt;code&gt;utf8&lt;/code&gt; 选项，则其输出文件句柄的编码将被强制为检测到的输入POD的编码，这将保留输入文本的内容。这样可确保与该模块的早期Unicode以前版本向后兼容，而不会出现大量Perl警告。</target>
        </trans-unit>
        <trans-unit id="b5abb9df31ef6516fcae104f653339d0026bd9e0" translate="yes" xml:space="preserve">
          <source>If the AIX Toolbox version of lib gdbm &amp;lt; 1.8.3-5 is installed on your system then Perl will not work. This library contains the header files /opt/freeware/include/gdbm/dbm.h|ndbm.h which conflict with the AIX system versions. The lib gdbm will be automatically removed from the wanted libraries if the presence of one of these two header files is detected. If you want to build Perl with GDBM support then please install at least gdbm-devel-1.8.3-5 (or higher).</source>
          <target state="translated">如果您的系统上安装了lib gdbm &amp;lt;1.8.3-5的AIX Toolbox版本，则Perl将不起作用。该库包含与AIX系统版本冲突的头文件/opt/freeware/include/gdbm/dbm.h|ndbm.h。如果检测到这两个头文件之一，则lib gdbm将自动从所需的库中删除。如果要使用GDBM支持构建Perl，请至少安装gdbm-devel-1.8.3-5（或更高版本）。</target>
        </trans-unit>
        <trans-unit id="e4f37200eb3cc7a4dd0c87959fbb6c2e093e138e" translate="yes" xml:space="preserve">
          <source>If the C function setvbuf() is available, then &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; sets the buffering policy for the FileHandle. The calling sequence for the Perl function is the same as its C counterpart, including the macros &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; , and &lt;code&gt;_IONBF&lt;/code&gt; , except that the buffer parameter specifies a scalar variable to use as a buffer. WARNING: A variable used as a buffer by &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; must not be modified in any way until the FileHandle is closed or until &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; is called again, or memory corruption may result!</source>
          <target state="translated">如果C函数setvbuf（）可用，则 &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; 设置FileHandle的缓冲策略。 Perl函数的调用顺序与其C对应的调用顺序相同，包括宏 &lt;code&gt;_IOFBF&lt;/code&gt; ， &lt;code&gt;_IOLBF&lt;/code&gt; 和 &lt;code&gt;_IONBF&lt;/code&gt; ，不同之处在于buffer参数指定了用作缓冲区的标量变量。警告：在关闭 &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; 或再次调用FileHandle :: setvbuf之前，不得以任何方式修改 &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; 用作缓冲区的变量，否则可能导致内存损坏！</target>
        </trans-unit>
        <trans-unit id="1a7ae4abb775cdaecaa965021a5be89b2c2a0678" translate="yes" xml:space="preserve">
          <source>If the C functions fgetpos() and fsetpos() are available, then &lt;code&gt;FileHandle::getpos&lt;/code&gt; returns an opaque value that represents the current position of the FileHandle, and &lt;code&gt;FileHandle::setpos&lt;/code&gt; uses that value to return to a previously visited position.</source>
          <target state="translated">如果C函数fgetpos（）和fsetpos（）可用，则 &lt;code&gt;FileHandle::getpos&lt;/code&gt; 返回一个不透明的值，该值表示FileHandle的当前位置，而 &lt;code&gt;FileHandle::setpos&lt;/code&gt; 使用该值返回到先前访问的位置。</target>
        </trans-unit>
        <trans-unit id="50ebbabfe865d409f0b42636c02f4e83fa99aca9" translate="yes" xml:space="preserve">
          <source>If the C functions setbuf() and/or setvbuf() are available, then &lt;code&gt;IO::Handle::setbuf&lt;/code&gt; and &lt;code&gt;IO::Handle::setvbuf&lt;/code&gt; set the buffering policy for an IO::Handle. The calling sequences for the Perl functions are the same as their C counterparts--including the constants &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; , and &lt;code&gt;_IONBF&lt;/code&gt; for setvbuf()--except that the buffer parameter specifies a scalar variable to use as a buffer. You should only change the buffer before any I/O, or immediately after calling flush.</source>
          <target state="translated">如果C函数setbuf（）和/或setvbuf（）可用，则 &lt;code&gt;IO::Handle::setbuf&lt;/code&gt; 和 &lt;code&gt;IO::Handle::setvbuf&lt;/code&gt; 设置IO :: Handle的缓冲策略。 Perl函数的调用序列与C函数的调用序列相同-包括setvbuf（）的常量 &lt;code&gt;_IOFBF&lt;/code&gt; ， &lt;code&gt;_IOLBF&lt;/code&gt; 和 &lt;code&gt;_IONBF&lt;/code&gt; -区别在于buffer参数指定了用作缓冲区的标量变量。您仅应在任何I / O之前或在调用flush之后立即更改缓冲区。</target>
        </trans-unit>
        <trans-unit id="cb7a6c24ac237588ebe82997b3227d4077970889" translate="yes" xml:space="preserve">
          <source>If the FHCRC bit is set in the gzip FLG header byte, the CRC16 bytes in the header must match the crc16 value of the gzip header actually read.</source>
          <target state="translated">如果在gzip FLG头字节中设置了FHCRC位,则头中的CRC16字节必须与实际读取的gzip头的crc16值相匹配。</target>
        </trans-unit>
        <trans-unit id="716df9a8cd6dfb775c171f4188701d3aabf993bd" translate="yes" xml:space="preserve">
          <source>If the PATTERN contains &lt;a href=&quot;../perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;capturing groups&lt;/a&gt;, then for each separator, an additional field is produced for each substring captured by a group (in the order in which the groups are specified, as per &lt;a href=&quot;../perlretut#Backreferences&quot;&gt;backreferences&lt;/a&gt;); if any group does not match, then it captures the &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value instead of a substring. Also, note that any such additional field is produced whenever there is a separator (that is, whenever a split occurs), and such an additional field does &lt;b&gt;not&lt;/b&gt; count towards the LIMIT. Consider the following expressions evaluated in list context (each returned list is provided in the associated comment):</source>
          <target state="translated">如果PATTERN包含&lt;a href=&quot;../perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;捕获组&lt;/a&gt;，那么对于每个分隔符，将为由组捕获的每个子字符串生成一个附加字段（按照&lt;a href=&quot;../perlretut#Backreferences&quot;&gt;反向引用的&lt;/a&gt;方式指定组的顺序）；如果任何组不匹配，则它将捕获 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值而不是子字符串。此外，请注意，任何这样的附加字段产生每当有一个分离器（即，每当发生分裂），并且这样的一个附加的字段也&lt;b&gt;未&lt;/b&gt;向限制计数。考虑在列表上下文中评估的以下表达式（每个返回的列表在关联的注释中提供）：</target>
        </trans-unit>
        <trans-unit id="82d842f2ab3731c9a4a0e7946b2b84aa92b80adc" translate="yes" xml:space="preserve">
          <source>If the PATTERN contains &lt;a href=&quot;perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;capturing groups&lt;/a&gt;, then for each separator, an additional field is produced for each substring captured by a group (in the order in which the groups are specified, as per &lt;a href=&quot;perlretut#Backreferences&quot;&gt;backreferences&lt;/a&gt;); if any group does not match, then it captures the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value instead of a substring. Also, note that any such additional field is produced whenever there is a separator (that is, whenever a split occurs), and such an additional field does &lt;b&gt;not&lt;/b&gt; count towards the LIMIT. Consider the following expressions evaluated in list context (each returned list is provided in the associated comment):</source>
          <target state="translated">如果PATTERN包含&lt;a href=&quot;perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;捕获组&lt;/a&gt;，那么对于每个分隔符，将为由组捕获的每个子字符串生成一个附加字段（按照&lt;a href=&quot;perlretut#Backreferences&quot;&gt;反向引用的&lt;/a&gt;方式指定组的顺序）；如果任何组不匹配，则它将捕获 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值而不是子字符串。此外，请注意，任何这样的附加字段产生每当有一个分离器（即，每当发生分裂），并且这样的一个附加的字段也&lt;b&gt;未&lt;/b&gt;向限制计数。考虑在列表上下文中评估的以下表达式（每个返回的列表在关联的注释中提供）：</target>
        </trans-unit>
        <trans-unit id="4e7443d40abaa23829b9ab709311a1922fe461b6" translate="yes" xml:space="preserve">
          <source>If the PERL_PV_PRETTY_ELLIPSES flag is set and not all characters in string were output then an ellipsis &lt;code&gt;...&lt;/code&gt; will be appended to the string. Note that this happens AFTER it has been quoted.</source>
          <target state="translated">如果设置了PERL_PV_PRETTY_ELLIPSES标志，并且没有输出字符串中的所有字符，则在字符串后附加省略号 &lt;code&gt;...&lt;/code&gt; 。请注意，这种情况发生在引用之后。</target>
        </trans-unit>
        <trans-unit id="09680d261a6a88f2e5836c919a2510509957b1e5" translate="yes" xml:space="preserve">
          <source>If the PERL_PV_PRETTY_QUOTE flag is set then the result will be double quoted with any double quotes in the string escaped. Otherwise if the PERL_PV_PRETTY_LTGT flag is set then the result be wrapped in angle brackets.</source>
          <target state="translated">如果PERL_PV_PRETTY_QUOTE标志被设置,那么结果将使用双引号,并将字符串中的任何双引号转义。否则,如果PERL_PV_PRETTY_LTGT标志被设置,那么结果将被包裹在角括号中。</target>
        </trans-unit>
        <trans-unit id="b990fe2846203877eedfbcf554045c1e773431f8" translate="yes" xml:space="preserve">
          <source>If the POD is inconsistent about the indentation of verbatim blocks, but you have figured out a heuristic to determine how much a particular verbatim block is indented, you can pass a code reference instead. The code reference will be executed with one argument, an array reference of all the lines in the verbatim block, and should return the value to be stripped from each line. For example, if you decide that you're fine to use the first line of the verbatim block to set the standard for indentation of the rest of the block, you can look at the first line and return the appropriate value, like so:</source>
          <target state="translated">如果POD对逐字块的缩进程度不一致,但你已经想出了一个启发式方法来确定某个逐字块的缩进程度,你可以传递一个代码引用来代替。该代码引用将以一个参数来执行,这个参数是逐字记录块中所有行的数组引用,并且应该返回要从每一行中剥离的值。例如,如果你决定用逐字块的第一行来设置其余块的缩进标准是没有问题的,你可以查看第一行并返回适当的值,就像这样。</target>
        </trans-unit>
        <trans-unit id="e9fd97e2c853d040e2b1f08382eba5acd7317a9d" translate="yes" xml:space="preserve">
          <source>If the POD source does not include an &lt;code&gt;=encoding&lt;/code&gt; declaration, the parser will attempt to guess the encoding (selecting one of UTF-8 or Latin-1) by examining the first non-ASCII bytes and applying the heuristic described in &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;.</source>
          <target state="translated">如果POD源不包含 &lt;code&gt;=encoding&lt;/code&gt; 声明，则解析器将通过检查第一个非ASCII字节并应用&lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec中&lt;/a&gt;描述的启发式方法来尝试猜测编码（选择UTF-8或Latin-1中的一个）。</target>
        </trans-unit>
        <trans-unit id="539121ee50a224917b8fad7fe828de50a4356761" translate="yes" xml:space="preserve">
          <source>If the POD you're parsing adheres to a consistent indentation policy, you can have such indentation stripped from the beginning of every line of your verbatim blocks. This method tells Pod::Simple what to strip. For two-space indents, you'd use:</source>
          <target state="translated">如果您正在解析的POD遵循一致的缩进策略,您可以从您的逐字块的每一行开始剥离这种缩进。这个方法告诉Pod::Simple要去掉什么。对于两个空格的缩进,你可以使用。</target>
        </trans-unit>
        <trans-unit id="767d61bbd817028665e597ffd44d52d2f3072a5a" translate="yes" xml:space="preserve">
          <source>If the PV of the SV is an octet sequence in UTF-8 and contains a multiple-byte character, the &lt;code&gt;SvUTF8&lt;/code&gt; flag is turned on so that it looks like a character. If the PV contains only single-byte characters, the &lt;code&gt;SvUTF8&lt;/code&gt; flag stays off. Scans PV for validity and returns false if the PV is invalid UTF-8.</source>
          <target state="translated">如果SV的PV是UTF-8中的八位字节序列，并且包含多字节字符，则 &lt;code&gt;SvUTF8&lt;/code&gt; 标志将打开，以使其看起来像一个字符。如果PV仅包含单字节字符，则 &lt;code&gt;SvUTF8&lt;/code&gt; 标志保持关闭状态。扫描PV的有效性，如果PV无效的UTF-8，则返回false。</target>
        </trans-unit>
        <trans-unit id="5ce916c1cc7717c4e805155c2d7548fbc24c77ee" translate="yes" xml:space="preserve">
          <source>If the Perl script is being executed as &lt;code&gt;perl scriptname&lt;/code&gt; , then the &lt;b&gt;-%c&lt;/b&gt; option must appear on the command line: &lt;code&gt;perl -%c scriptname&lt;/code&gt;.</source>
          <target state="translated">如果Perl脚本被作为执行 &lt;code&gt;perl scriptname&lt;/code&gt; ，然后&lt;b&gt;- ％C&lt;/b&gt;选项就必须出现在命令行： &lt;code&gt;perl -%c scriptname&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fde4187a6aa163d9c96f574141763bdd38ae34f7" translate="yes" xml:space="preserve">
          <source>If the Perl script is being executed as a command using the #! mechanism (or its local equivalent), this error can usually be fixed by editing the #! line so that the &lt;b&gt;-%c&lt;/b&gt; option is a part of Perl's first argument: e.g. change &lt;code&gt;perl -n -%c&lt;/code&gt; to &lt;code&gt;perl -%c -n&lt;/code&gt; .</source>
          <target state="translated">如果使用＃！将Perl脚本作为命令执行。机制（或其本地等效项），通常可以通过编辑＃！来解决此错误。行，以便&lt;b&gt;-％c&lt;/b&gt;选项成为Perl第一个参数的一部分：例如，将 &lt;code&gt;perl -n -%c&lt;/code&gt; 更改为 &lt;code&gt;perl -%c -n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c878ced38c4f673dcc4c3921e7ce406e54b4b71" translate="yes" xml:space="preserve">
          <source>If the README file seems to be getting too large you may wish to split out some of the sections into separate files: INSTALL, Copying, ToDo etc.</source>
          <target state="translated">如果README文件似乎变得太大了,你可能会希望把一些部分拆成单独的文件。INSTALL,Copying,ToDo等等。</target>
        </trans-unit>
        <trans-unit id="bcda0ef071779fc235b5cd85b1d75a393d7ae1e4" translate="yes" xml:space="preserve">
          <source>If the Time::HiRes module has been installed, you can specify the special tag &lt;code&gt;:hireswallclock&lt;/code&gt; for Benchmark (if Time::HiRes is not available, the tag will be silently ignored). This tag will cause the wallclock time to be measured in microseconds, instead of integer seconds. Note though that the speed computations are still conducted in CPU time, not wallclock time.</source>
          <target state="translated">如果已安装Time :: HiRes模块， &lt;code&gt;:hireswallclock&lt;/code&gt; 以为Benchmark 指定特殊标签：hireswallclock（如果Time :: HiRes不可用，则该标签将被忽略）。此标签将使挂钟时间以微秒为单位，而不是整数秒。请注意，尽管速度计算仍以CPU时间而非壁钟时间进行。</target>
        </trans-unit>
        <trans-unit id="1e0de044d27a1f06d198fa6cd4b199e7a501a7e3" translate="yes" xml:space="preserve">
          <source>If the UNTIE method exists then the warning above does not occur. Instead the UNTIE method is passed the count of &quot;extra&quot; references and can issue its own warning if appropriate. e.g. to replicate the no UNTIE case this method can be used:</source>
          <target state="translated">如果UNTIE方法存在,那么上述警告就不会发生。取而代之的是,UNTIE方法被传递了 &quot;额外 &quot;引用的数量,并且可以在适当的时候发出自己的警告。例如,为了复制没有UNTIE的情况,可以使用这个方法。</target>
        </trans-unit>
        <trans-unit id="afcfedf6cd11f719819da193333a7cf6de0732a7" translate="yes" xml:space="preserve">
          <source>If the VERSION argument is present between Module and LIST, then the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; will call the VERSION method in class Module with the given version as an argument. The default VERSION method, inherited from the UNIVERSAL class, croaks if the given version is larger than the value of the variable &lt;code&gt;$Module::VERSION&lt;/code&gt; .</source>
          <target state="translated">如果VERSION参数存在于Module和LIST之间，则 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 将使用给定版本作为参数调用Module类中的VERSION方法。如果给定版本大于变量 &lt;code&gt;$Module::VERSION&lt;/code&gt; 的值，则从UNIVERSAL类继承的默认VERSION方法将崩溃。</target>
        </trans-unit>
        <trans-unit id="28fd8c6bb88e030936b47d8b396e97702a34b855" translate="yes" xml:space="preserve">
          <source>If the VERSION argument is present between Module and LIST, then the &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; will call the VERSION method in class Module with the given version as an argument. The default VERSION method, inherited from the UNIVERSAL class, croaks if the given version is larger than the value of the variable &lt;code&gt;$Module::VERSION&lt;/code&gt; .</source>
          <target state="translated">如果VERSION参数存在于Module和LIST之间，则 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 将使用给定版本作为参数调用Module类中的VERSION方法。如果给定版本大于变量 &lt;code&gt;$Module::VERSION&lt;/code&gt; 的值，则从UNIVERSAL类继承的默认VERSION方法将崩溃。</target>
        </trans-unit>
        <trans-unit id="333bd150f2ebb931ff98dd0682381076be3b30d6" translate="yes" xml:space="preserve">
          <source>If the XSUB has a return type of &lt;code&gt;void&lt;/code&gt; then the compiler will not declare a RETVAL variable for that function. When using a PPCODE: section no manipulation of the RETVAL variable is required, the section may use direct stack manipulation to place output values on the stack.</source>
          <target state="translated">如果XSUB的返回类型为 &lt;code&gt;void&lt;/code&gt; ,则编译器将不会为该函数声明RETVAL变量。当使用PPCODE：节时，不需要对RETVAL变量进行任何操作，该节可以使用直接堆栈操作将输出值放在堆栈上。</target>
        </trans-unit>
        <trans-unit id="bebee72fc9aa0a9b169227a410e90f7f3df000ed" translate="yes" xml:space="preserve">
          <source>If the above does not work, or is not adequate for your application, then file a bug report on &lt;a href=&quot;http://rt.cpan.org/Public/&quot;&gt;http://rt.cpan.org/Public/&lt;/a&gt; against the problematic module.</source>
          <target state="translated">如果上述方法不起作用，或不足以适合您的应用程序，请针对有问题的模块，在&lt;a href=&quot;http://rt.cpan.org/Public/&quot;&gt;http://rt.cpan.org/Public/上&lt;/a&gt;提交错误报告。</target>
        </trans-unit>
        <trans-unit id="77f8b1f2470978bb7eb295cba54688c501c99623" translate="yes" xml:space="preserve">
          <source>If the above evaluates as true, the following methods will be available on the &lt;code&gt;$result&lt;/code&gt; object.</source>
          <target state="translated">如果以上评估为真，则 &lt;code&gt;$result&lt;/code&gt; 对象上将提供以下方法。</target>
        </trans-unit>
        <trans-unit id="3626e8a47b75cd9814f9aabb6f3226e20a12cd72" translate="yes" xml:space="preserve">
          <source>If the act of unimporting your module (via a &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;) should cause source code filtering to cease, create an &lt;code&gt;unimport&lt;/code&gt; subroutine, and have it call &lt;code&gt;filter_del&lt;/code&gt; . Make sure that the call to &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; in step 5 will not accidentally read past the &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;. Effectively this limits source code filters to line-by-line operation, unless the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine does some fancy pre-pre-parsing of the source code it's filtering.</source>
          <target state="translated">如果您unimporting模块（通过的法案 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; ）应该引起源代码过滤停止，创建一个 &lt;code&gt;unimport&lt;/code&gt; 子程序，并将它称之为 &lt;code&gt;filter_del&lt;/code&gt; 。确保在第5步中对 &lt;code&gt;filter_read&lt;/code&gt; 或 &lt;code&gt;filter_read_exact&lt;/code&gt; 的调用不会意外读取到 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 之后。有效地，这将源代码过滤器限制为逐行操作，除非 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程对要过滤的源代码进行了一些预想的预准备。</target>
        </trans-unit>
        <trans-unit id="f14d384ae54d7fd6956617c902dc52b4f7c913e2" translate="yes" xml:space="preserve">
          <source>If the archive creation fails for any reason, &lt;code&gt;create_archive&lt;/code&gt; will return false. Please use the &lt;code&gt;error&lt;/code&gt; method to find the cause of the failure.</source>
          <target state="translated">如果归档创建由于任何原因而失败，则 &lt;code&gt;create_archive&lt;/code&gt; 将返回false。请使用 &lt;code&gt;error&lt;/code&gt; 方法查找失败原因。</target>
        </trans-unit>
        <trans-unit id="bdb2a47c2b4d923874ce10a47d541cda074eec3d" translate="yes" xml:space="preserve">
          <source>If the argument has any characters in it other than those matching &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;, it must be a file</source>
          <target state="translated">如果参数中有比其它匹配的任何字符 &lt;code&gt;\w&lt;/code&gt; ， &lt;code&gt;:&lt;/code&gt; 或者 &lt;code&gt;'&lt;/code&gt; ，它必须是一个文件</target>
        </trans-unit>
        <trans-unit id="6ad412a6b0ecba8c1d6ad813bdece11aeaddeb49" translate="yes" xml:space="preserve">
          <source>If the argument is &quot;/cygdrive&quot;, then just the volume mount settings, and the cygdrive mount prefix are returned.</source>
          <target state="translated">如果参数是&quot;/cygdrive&quot;,则只返回卷挂载设置和cygdrive挂载前缀。</target>
        </trans-unit>
        <trans-unit id="b2f2982f0afdcf62760763525865c85306c36f4e" translate="yes" xml:space="preserve">
          <source>If the argument is a compiled regular expression as returned by &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, then this function returns the pattern.</source>
          <target state="translated">如果参数是 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 返回的已编译正则表达式，则此函数返回模式。</target>
        </trans-unit>
        <trans-unit id="7b654339779464179184dbeba32e40251c7e2e80" translate="yes" xml:space="preserve">
          <source>If the argument is a compiled regular expression as returned by &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, then this function returns what the optimiser considers to be the longest anchored fixed string and longest floating fixed string in the pattern.</source>
          <target state="translated">如果参数是 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 返回的已编译正则表达式，则此函数返回优化器认为是模式中最长的固定固定字符串和最长的浮动固定字符串的内容。</target>
        </trans-unit>
        <trans-unit id="5788205c6ad8a4a8ebfb81bffe26f845a9b7bbcb" translate="yes" xml:space="preserve">
          <source>If the argument is a distribution file name (recognized by embedded slashes), it is processed. If it is a module, CPAN determines the distribution file in which this module is included and processes that, following any dependencies named in the module's META.yml or Makefile.PL (this behavior is controlled by the configuration parameter &lt;code&gt;prerequisites_policy&lt;/code&gt; ). If an argument is enclosed in slashes it is treated as a regular expression: it is expanded and if the result is a single object (distribution, bundle or module), this object is processed.</source>
          <target state="translated">如果参数是分发文件名（由嵌入式斜杠识别），则将对其进行处理。如果是模块，则CPAN将确定包含此模块的分发文件，并根据模块的META.yml或Makefile.PL中命名的任何依赖项来处理该分发文件（此行为由配置参数 &lt;code&gt;prerequisites_policy&lt;/code&gt; 控制）。如果参数用斜杠括起来，则将其视为正则表达式：将对其进行扩展，并且如果结果是单个对象（分布，分发包或模块），则将处理该对象。</target>
        </trans-unit>
        <trans-unit id="b117f48b026da0b0825304f95daf71b17bbf61f6" translate="yes" xml:space="preserve">
          <source>If the argument matches only &lt;code&gt;[\w:']&lt;/code&gt;, it must be a module</source>
          <target state="translated">如果参数仅匹配 &lt;code&gt;[\w:']&lt;/code&gt; ，则它必须是一个模块</target>
        </trans-unit>
        <trans-unit id="0af3cf093a2df4958131449dc2e48cabc581ef28" translate="yes" xml:space="preserve">
          <source>If the argument matches only &lt;code&gt;\w&lt;/code&gt; , it could either be a module or a file. We will try to find &lt;code&gt;file.pm&lt;/code&gt; first in &lt;code&gt;@INC&lt;/code&gt; and if that fails, we will try to find &lt;code&gt;file&lt;/code&gt; in @INC. If both fail, we die with the respective error messages.</source>
          <target state="translated">如果参数仅匹配 &lt;code&gt;\w&lt;/code&gt; ，则它可以是模块或文件。我们将尝试首先在 &lt;code&gt;@INC&lt;/code&gt; 中找到 &lt;code&gt;file.pm&lt;/code&gt; ，如果失败，我们将尝试在@INC中找到 &lt;code&gt;file&lt;/code&gt; 。如果两者均失败，我们将死于各自的错误消息。</target>
        </trans-unit>
        <trans-unit id="950fc5f071c3850318ce53caaa9abf5b8d7e4b09" translate="yes" xml:space="preserve">
          <source>If the argument ops disagree with the prototype, for example by having an unacceptable number of arguments, a valid op tree is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred. In the error message, the callee is referred to by the name defined by the</source>
          <target state="translated">如果参数操作与原型不一致,比如说参数数量不可接受,那么无论如何都会返回一个有效的操作树。该错误反映在解析器状态中,通常会在解析的最高层产生一个异常,它涵盖了所有发生的编译错误。在错误信息中,callee被引用的名称是由</target>
        </trans-unit>
        <trans-unit id="0d4e5120bb33dd7cd87d33b762323635453284d3" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;charblock()&lt;/code&gt; is not a known block, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;charblock()&lt;/code&gt; 的参数不是已知的块，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7830cf54412f961c402c681fff76496d227d2f2" translate="yes" xml:space="preserve">
          <source>If the attribute name is unqualified, the attribute is installed in the current package. Otherwise it is installed in the qualifier's package:</source>
          <target state="translated">如果属性名是非限定的,则该属性被安装在当前的包中。否则,它将被安装在限定者的包中。</target>
        </trans-unit>
        <trans-unit id="c1735572aa151643b864cff0b5bfb1e1bb6554fd" translate="yes" xml:space="preserve">
          <source>If the author's vision of the future of their module is sufficiently different from the vision of the pumpkin holder and perl5-porters as a whole so as to cause serious problems for Perl, the pumpkin holder may choose to formally fork the version of the module in the Perl core from the one maintained by the author. This should not be done lightly and should &lt;b&gt;always&lt;/b&gt; if at all possible be done only after direct input from Larry. If this is done, it must then be made explicit in the module as distributed with the Perl core that it is a forked version and that while it is based on the original author's work, it is no longer maintained by them. This must be noted in both the documentation and in the comments in the source of the module.</source>
          <target state="translated">如果作者对模块未来的看法与整个南瓜支架和perl5-porters的看法有很大不同，从而给Perl带来了严重的问题，那么南瓜支架可以选择正式将模块的版本分叉到作者维护的Perl核心。这不应该随便做，应&lt;b&gt;始终&lt;/b&gt;如果可能的话后，才从拉里直接输入来完成。如果这样做，则必须在与Perl核心一起分发的模块中将其明确表示为分叉版本，并且它基于原始作者的作品，但不再由他们维护。必须在文档中以及模块源代码中的注释中对此进行说明。</target>
        </trans-unit>
        <trans-unit id="1ff96c964c43432c71bf023f75aff4edc100165c" translate="yes" xml:space="preserve">
          <source>If the backslash is followed by a single digit, it's a backreference.</source>
          <target state="translated">如果反斜杠后面是一个数字,那就是一个反向参考。</target>
        </trans-unit>
        <trans-unit id="a1567cb832ddb83a0b923a12411e03c46deba90f" translate="yes" xml:space="preserve">
          <source>If the beginning of some prebuilt path matches</source>
          <target state="translated">如果某个预建路径的开头符合</target>
        </trans-unit>
        <trans-unit id="10167b28b5bd2cad97967630ae689888c6716c8a" translate="yes" xml:space="preserve">
          <source>If the block of code given to &lt;a href=&quot;#pairmap&quot;&gt;pairmap&lt;/a&gt; contains lexical variables that are captured by a returned closure, and the closure is executed after the block has been re-used for the next iteration, these lexicals will not see the correct values. For example:</source>
          <target state="translated">如果提供给&lt;a href=&quot;#pairmap&quot;&gt;pairmap&lt;/a&gt;的代码块包含由返回的闭包捕获的词法变量，并且在将该块重新用于下一次迭代后执行该闭包，则这些词法将看不到正确的值。例如：</target>
        </trans-unit>
        <trans-unit id="440a5d8f345e7d80a2856dd0eeb83f250fbc92a1" translate="yes" xml:space="preserve">
          <source>If the byte length &lt;code&gt;l1&lt;/code&gt; is non-zero, it says how far into &lt;code&gt;s1&lt;/code&gt; to check for fold equality. In other words, &lt;code&gt;s1&lt;/code&gt; +&lt;code&gt;l1&lt;/code&gt; will be used as a goal to reach. The scan will not be considered to be a match unless the goal is reached, and scanning won't continue past that goal. Correspondingly for &lt;code&gt;l2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt; .</source>
          <target state="translated">如果字节长度 &lt;code&gt;l1&lt;/code&gt; 不为零，则表示要检查 &lt;code&gt;s1&lt;/code&gt; 是否等于倍数。换句话说， &lt;code&gt;s1&lt;/code&gt; + &lt;code&gt;l1&lt;/code&gt; 将用作达成目标。除非达到目标，否则扫描不会被视为匹配，并且扫描不会继续超过该目标。相对于 &lt;code&gt;s2&lt;/code&gt; 为 &lt;code&gt;l2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b7b55adcf46426f8905247d52b7cd465b36f52b" translate="yes" xml:space="preserve">
          <source>If the c89 compiler complains of syntax errors during the build of the Socket extension then be sure to fix the syntax error in the system header /usr/include/sys/socket.h.</source>
          <target state="translated">如果c89编译器在构建Socket扩展时抱怨语法错误,那么一定要修复系统头/usr/include/sys/socket.h中的语法错误。</target>
        </trans-unit>
        <trans-unit id="440bf862cd2a86e099efb047265c5fac0693c286" translate="yes" xml:space="preserve">
          <source>If the call is to an lvalue subroutine, and &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; is defined &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; (</source>
          <target state="translated">如果调用是一个左值子例程，并且 &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; 被定义为 &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; （</target>
        </trans-unit>
        <trans-unit id="3e23c7323ae1871ee025af31121766b37b8d3a26" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;load&lt;/code&gt; is from &lt;code&gt;YourPackage&lt;/code&gt; , then that can be further simplified to</source>
          <target state="translated">如果 &lt;code&gt;load&lt;/code&gt; 调用来自 &lt;code&gt;YourPackage&lt;/code&gt; ，则可以进一步简化为</target>
        </trans-unit>
        <trans-unit id="5682bd082d01ef4bbac6126150d3b6f81612d0af" translate="yes" xml:space="preserve">
          <source>If the character following the backslash is an ASCII letter or an ASCII digit, then the sequence may be special; if so, it's listed below. A few letters have not been used yet, so escaping them with a backslash doesn't change them to be special. A future version of Perl may assign a special meaning to them, so if you have warnings turned on, Perl issues a warning if you use such a sequence. [1].</source>
          <target state="translated">如果反斜线后面的字符是ASCII字母或ASCII数字,那么这个序列可能是特殊的;如果是,就在下面列出。有几个字母还没有被使用,所以用反斜线转义并不能改变它们的特殊性。未来的Perl版本可能会给它们赋予特殊的含义,所以如果你开启了警告,如果你使用这样的序列,Perl会发出警告。[1].</target>
        </trans-unit>
        <trans-unit id="da17f25e114b45ba4ef865a9786c813cdbdd1421" translate="yes" xml:space="preserve">
          <source>If the character is canonically decomposable (including Hangul Syllables), it returns the (full) canonical decomposition as a string. Otherwise it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果角色是可正则分解的（包括韩文音节），它将以字符串形式返回（完整）正则分解。否则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68a39c4975b03ffeafb0215bb69dbcb4fdb18e47" translate="yes" xml:space="preserve">
          <source>If the character is compatibility decomposable (including Hangul Syllables), it returns the (full) compatibility decomposition as a string. Otherwise it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果字符是可分解兼容性的（包括韩文音节），则它将（完整）兼容性分解作为字符串返回。否则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65221cae28ebb56c2b7e384de16ed70d718d62d1" translate="yes" xml:space="preserve">
          <source>If the child falls out of scope before &lt;code&gt;finalize&lt;/code&gt; is called, a failure diagnostic will be issued and the child is considered to have failed.</source>
          <target state="translated">如果子项在调用 &lt;code&gt;finalize&lt;/code&gt; 之前超出范围，则将发出故障诊断，并认为该子项已失败。</target>
        </trans-unit>
        <trans-unit id="ddc80dbef3fa7a98447bcda86b6b6a922737dbbf" translate="yes" xml:space="preserve">
          <source>If the child process dies for any reason, the next write to CHLD_IN is likely to generate a SIGPIPE in the parent, which is fatal by default. So you may wish to handle this signal.</source>
          <target state="translated">如果子进程由于任何原因死亡,下一次向CHLD_IN的写入很可能会在父进程中产生一个SIGPIPE,默认情况下这是致命的。所以你可能希望处理这个信号。</target>
        </trans-unit>
        <trans-unit id="dbd5594c7134763067cde3b54f3bfaeaa68b552a" translate="yes" xml:space="preserve">
          <source>If the child process follows the convention of C programs compiled with the _POSIX_EXIT macro set, the status value will contain the actual value of 0 to 255 returned by that program on a normal exit.</source>
          <target state="translated">如果子进程遵循用_POSIX_EXIT宏集编译的C程序的惯例,状态值将包含该程序在正常退出时返回的0到255的实际值。</target>
        </trans-unit>
        <trans-unit id="3a2359effbd1215640880aada1292b5fa0877c9a" translate="yes" xml:space="preserve">
          <source>If the class shown in &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; were placed in the MyClass.pm module, then the following code:</source>
          <target state="translated">如果将&lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt;中显示的类放在MyClass.pm模块中，则下面的代码：</target>
        </trans-unit>
        <trans-unit id="2f9ec72ad3a19d5c4b84af5eba887a50b7eef9b5" translate="yes" xml:space="preserve">
          <source>If the client asks for &quot;fr&quot;, that will look up successfully in %greetings, to the value &quot;Bonjour&quot;. And if the client asks for &quot;i-mingo&quot;, that will look up successfully in %greetings, to the value &quot;Hau'&quot;.</source>
          <target state="translated">如果客户问的是 &quot;fr&quot;,将在%greetings中成功查找到 &quot;Bonjour&quot;。如果客户询问 &quot;i-mingo&quot;,则会在%greetings中成功查找到 &quot;Hau'&quot;。</target>
        </trans-unit>
        <trans-unit id="1e012fb4a0052bc107066983e24cd424b0582af0" translate="yes" xml:space="preserve">
          <source>If the code point is unassigned, this returns the block it would belong to if it were assigned. (If the Unicode version being used is so early as to not have blocks, all code points are considered to be in &lt;code&gt;No_Block&lt;/code&gt; .)</source>
          <target state="translated">如果未分配代码点，则返回它在分配时将属于的块。（如果所使用的Unicode版本太早而没有块，则所有代码点都被视为位于 &lt;code&gt;No_Block&lt;/code&gt; 中。）</target>
        </trans-unit>
        <trans-unit id="ced2db748e9e7079888c75fca8f7175caebcea61" translate="yes" xml:space="preserve">
          <source>If the code to be executed doesn't vary, you may use the eval-BLOCK form to trap run-time errors without incurring the penalty of recompiling each time. The error, if any, is still returned in &lt;code&gt;$@&lt;/code&gt; . Examples:</source>
          <target state="translated">如果要执行的代码没有变化，则可以使用eval-BLOCK表单来捕获运行时错误，而不会造成每次重新编译的代价。该错误（如果有）仍在 &lt;code&gt;$@&lt;/code&gt; 返回。例子：</target>
        </trans-unit>
        <trans-unit id="2bd498c74c7384947431c9fbfc4c96437164ae53" translate="yes" xml:space="preserve">
          <source>If the code to execute had been passed in as a string, &lt;code&gt;'$line = &amp;lt;STDIN&amp;gt;'&lt;/code&gt; , there would have been no way for the hypothetical timeout() function to access the lexical variable $line back in its caller's scope.</source>
          <target state="translated">如果要执行的代码已作为字符串 &lt;code&gt;'$line = &amp;lt;STDIN&amp;gt;'&lt;/code&gt; 传入，则假设的timeout（）函数将无法在其调用者的作用域中访问词法变量$ line。</target>
        </trans-unit>
        <trans-unit id="c5dcda0eb63d695c2273d9f58a5b27fc7e844c60" translate="yes" xml:space="preserve">
          <source>If the configurations variable &lt;code&gt;build_dir_reuse&lt;/code&gt; is set to a true value, then CPAN.pm reads the collected YAML files. If the stored signature matches the currently running perl, the stored state is loaded into memory such that persistence between sessions is effectively established.</source>
          <target state="translated">如果配置变量 &lt;code&gt;build_dir_reuse&lt;/code&gt; 设置为true值，则CPAN.pm读取收集的YAML文件。如果存储的签名与当前正在运行的Perl匹配，则将存储的状态加载到内存中，以便有效地建立会话之间的持久性。</target>
        </trans-unit>
        <trans-unit id="a91d44bc473043f072a494275450d9c876250d17" translate="yes" xml:space="preserve">
          <source>If the connection is via a firewall then the &lt;code&gt;authorize&lt;/code&gt; method will be called with no arguments.</source>
          <target state="translated">如果通过防火墙进行连接，则将不带任何参数调用 &lt;code&gt;authorize&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="880ff18ec98ddcf514d383275dae13c355bbcadf" translate="yes" xml:space="preserve">
          <source>If the construct is a here-doc, the ending delimiter is a line that has a terminating string as the content. Therefore &lt;code&gt;&amp;lt;&amp;lt;EOF&lt;/code&gt; is terminated by &lt;code&gt;EOF&lt;/code&gt; immediately followed by &lt;code&gt;&quot;\n&quot;&lt;/code&gt; and starting from the first column of the terminating line. When searching for the terminating line of a here-doc, nothing is skipped. In other words, lines after the here-doc syntax are compared with the terminating string line by line.</source>
          <target state="translated">如果构造为here-doc，则结束定界符为以终止字符串为内容的行。因此， &lt;code&gt;&amp;lt;&amp;lt;EOF&lt;/code&gt; 由 &lt;code&gt;EOF&lt;/code&gt; 终止，紧随其后的是 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 并从终止行的第一列开始。搜索here-doc的终止行时，不会跳过任何内容。换句话说，here-doc语法之后的行与终止字符串逐行进行比较。</target>
        </trans-unit>
        <trans-unit id="e1f5405c8fb7cef756ea27523f26d6d391697258" translate="yes" xml:space="preserve">
          <source>If the constructor fails undef will be returned and an error message will be in $@</source>
          <target state="translated">如果构造函数失败,将返回undef,并在$@中显示错误信息。</target>
        </trans-unit>
        <trans-unit id="a03d6a855f28c1f0fcb373d36da3e2b752b1b618" translate="yes" xml:space="preserve">
          <source>If the constructor is only passed a single argument, it is assumed to be a &lt;code&gt;Peer&lt;/code&gt; specification.</source>
          <target state="translated">如果仅向构造函数传递单个参数，则将其视为对 &lt;code&gt;Peer&lt;/code&gt; 规范。</target>
        </trans-unit>
        <trans-unit id="59d6c514d80580b526f459658680b5bcb3039600" translate="yes" xml:space="preserve">
          <source>If the constructor is only passed a single argument, it is assumed to be a &lt;code&gt;PeerAddr&lt;/code&gt; specification.</source>
          <target state="translated">如果仅向构造函数传递单个参数，则将其视为 &lt;code&gt;PeerAddr&lt;/code&gt; 规范。</target>
        </trans-unit>
        <trans-unit id="2c1d4da7e238174b01de906293d93c6822b7ffed" translate="yes" xml:space="preserve">
          <source>If the count doesn't impress your friends, then the code might. :-)</source>
          <target state="translated">如果这个数字不能打动你的朋友,那么代码可能会。 :-)</target>
        </trans-unit>
        <trans-unit id="e2812a31f32729d7d8acbab2252b618f1597089e" translate="yes" xml:space="preserve">
          <source>If the current directory is not writable, file is created using modified &lt;code&gt;tmpnam&lt;/code&gt; , so there may be a race condition.</source>
          <target state="translated">如果当前目录不可写，则使用修改后的 &lt;code&gt;tmpnam&lt;/code&gt; 创建文件，因此可能存在竞争情况。</target>
        </trans-unit>
        <trans-unit id="494e23aba89eecf5e12f5237686e230eddf4cf1f" translate="yes" xml:space="preserve">
          <source>If the current tests are considered &quot;TODO&quot; it will return the reason, if any. This reason can come from a &lt;code&gt;$TODO&lt;/code&gt; variable or the last call to &lt;code&gt;todo_start()&lt;/code&gt; .</source>
          <target state="translated">如果当前测试被认为是&amp;ldquo; TODO&amp;rdquo;，它将返回原因（如果有）。该原因可能来自 &lt;code&gt;$TODO&lt;/code&gt; 变量或上一次对 &lt;code&gt;todo_start()&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="4dc2b173d8d4940a748b9c83e49e0862799d41a0" translate="yes" xml:space="preserve">
          <source>If the debugging output of &lt;code&gt;-D&lt;/code&gt; doesn't help you, it's time to step through perl's execution with a source-level debugger.</source>
          <target state="translated">如果 &lt;code&gt;-D&lt;/code&gt; 的调试输出无法帮助您，那么该使用源代码级调试器逐步执行perl的执行了。</target>
        </trans-unit>
        <trans-unit id="5d9b61b179e59a5faa76c718b44a80bf30b29231" translate="yes" xml:space="preserve">
          <source>If the deferred-write buffer isn't yet full, but the total size of the buffer and the read cache would exceed the &lt;code&gt;memory&lt;/code&gt; limit, the oldest records will be expired from the read cache until the total size is under the limit.</source>
          <target state="translated">如果延迟写入缓冲区尚未满，但是缓冲区和读取缓存的总大小将超过 &lt;code&gt;memory&lt;/code&gt; 限制，则最早的记录将从读取缓存中过期，直到总大小低于限制。</target>
        </trans-unit>
        <trans-unit id="2d787ba93d433e8611c0010f5b5125e21c2fae5b" translate="yes" xml:space="preserve">
          <source>If the delimiter chosen is a single quote, no interpolation is done on either the</source>
          <target state="translated">如果选择的定界符是一个单引号,则不对以下两个部分进行插值。</target>
        </trans-unit>
        <trans-unit id="fd691ad27529116a3a5593dc1f80d4b01d408999" translate="yes" xml:space="preserve">
          <source>If the destination (second argument) already exists and is a directory, and the source (first argument) is not a filehandle, then the source file will be copied into the directory specified by the destination, using the same base name as the source file. It's a failure to have a filehandle as the source when the destination is a directory.</source>
          <target state="translated">如果目标(第二个参数)已经存在并且是一个目录,而源(第一个参数)不是filehandle,那么源文件将被复制到目标指定的目录中,使用与源文件相同的基名。当目标是目录时,以filehandle作为源文件是失败的。</target>
        </trans-unit>
        <trans-unit id="bf967ef029273cc2d212ca164cc9a8a6a20b4430" translate="yes" xml:space="preserve">
          <source>If the element type does not start with a &lt;code&gt;'*'&lt;/code&gt; , the accessor returns the element value (after assignment). If the element type starts with a &lt;code&gt;'*'&lt;/code&gt; , a reference to the element itself is returned.</source>
          <target state="translated">如果元素类型不是以 &lt;code&gt;'*'&lt;/code&gt; 开头，则访问器将返回元素值（分配后）。如果元素类型以 &lt;code&gt;'*'&lt;/code&gt; 开头，则返回对元素本身的引用。</target>
        </trans-unit>
        <trans-unit id="4e23930732591461e14ec21d8b1f90dcd530ad74" translate="yes" xml:space="preserve">
          <source>If the element type is &lt;code&gt;'$'&lt;/code&gt; , the value of the element (after assignment) is returned. If the element type is &lt;code&gt;'*$'&lt;/code&gt; , a reference to the element is returned.</source>
          <target state="translated">如果元素类型为 &lt;code&gt;'$'&lt;/code&gt; ，则返回元素的值（赋值后）。如果元素类型为 &lt;code&gt;'*$'&lt;/code&gt; ，则返回对该元素的引用。</target>
        </trans-unit>
        <trans-unit id="1bac597df37b35f3a7dd05dd8ec187e68ab2f23b" translate="yes" xml:space="preserve">
          <source>If the empty regex &lt;code&gt;//&lt;/code&gt; is used, the string is split into individual characters. If the regex has groupings, then the list produced contains the matched substrings from the groupings as well:</source>
          <target state="translated">如果使用空的正则表达式 &lt;code&gt;//&lt;/code&gt; ，则将字符串拆分为单个字符。如果正则表达式具有分组，那么生成的列表也将包含来自分组的匹配子字符串：</target>
        </trans-unit>
        <trans-unit id="8e04e07bd20c824f00e23be10a97b35d7d8bdaf8" translate="yes" xml:space="preserve">
          <source>If the empty regexp &lt;code&gt;//&lt;/code&gt; is used, the regexp always matches and the string is split into individual characters. If the regexp has groupings, then the resulting list contains the matched substrings from the groupings as well. For instance,</source>
          <target state="translated">如果使用了空的regexp &lt;code&gt;//&lt;/code&gt; ，则regexp总是匹配，并且字符串被拆分为单个字符。如果正则表达式具有分组，则结果列表也将包含来自分组的匹配子字符串。例如，</target>
        </trans-unit>
        <trans-unit id="9160efcd7b61ecdb5eab89bb5f1048b8690bd897" translate="yes" xml:space="preserve">
          <source>If the entereval op is permitted then the code can use eval &quot;...&quot; to 'hide' code which might use denied ops. This is not a major problem since when the code tries to execute the eval it will fail because the opmask is still in effect. However this technique would allow clever, and possibly harmful, code to 'probe' the boundaries of what is possible.</source>
          <target state="translated">如果entereval操作是允许的,那么代码可以使用eval&quot;...&quot;来 &quot;隐藏 &quot;可能使用拒绝的操作的代码。这不是一个大问题,因为当代码试图执行eval时,它会失败,因为odmask仍然有效。然而,这种技术将允许聪明的,可能是有害的代码来 &quot;探测 &quot;可能的边界。</target>
        </trans-unit>
        <trans-unit id="a6dd91d8fc44e261add22f788040f3b0d9653b9a" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;code&gt;PERL_TEST_HARNESS_DUMP_TAP&lt;/code&gt; is defined it should name a directory into which a copy of the raw TAP for each test will be written. TAP is written to files named for each test. Subdirectories will be created as needed.</source>
          <target state="translated">如果定义了环境变量 &lt;code&gt;PERL_TEST_HARNESS_DUMP_TAP&lt;/code&gt; ，则应命名一个目录，其中将写入每个测试的原始TAP的副本。TAP将写入每个测试命名的文件中。将根据需要创建子目录。</target>
        </trans-unit>
        <trans-unit id="9e66c1c6198ecf06cc2142e9e5e1dd957bf8c18d" translate="yes" xml:space="preserve">
          <source>If the executable called by system()/exec()/pipe-open()/&lt;code&gt;``&lt;/code&gt; is a script with the &quot;magic&quot; &lt;code&gt;#!&lt;/code&gt; line or &lt;code&gt;extproc&lt;/code&gt; line which specifies shell;</source>
          <target state="translated">如果system（）/ exec（）/ pipe-open（）/ &lt;code&gt;``&lt;/code&gt; 调用的可执行文件是带有&amp;ldquo; magic&amp;rdquo; &lt;code&gt;#!&lt;/code&gt; 的脚本！指定shell的行或 &lt;code&gt;extproc&lt;/code&gt; 行；</target>
        </trans-unit>
        <trans-unit id="2a754fbd5a5705920e61152dd8c6911b9ca9d965" translate="yes" xml:space="preserve">
          <source>If the executable called by system()/exec()/pipe-open()/&lt;code&gt;``&lt;/code&gt; is a script without &quot;magic&quot; line, and &lt;code&gt;$ENV{EXECSHELL}&lt;/code&gt; is set to shell;</source>
          <target state="translated">如果可执行的系统（）/执行exec（）/管道的open（）称为/ &lt;code&gt;``&lt;/code&gt; 是一个脚本没有&amp;ldquo;神奇&amp;rdquo;行， &lt;code&gt;$ENV{EXECSHELL}&lt;/code&gt; 设置为壳;</target>
        </trans-unit>
        <trans-unit id="6143c4a0521be912f40be9869aedf7b75cf3c5aa" translate="yes" xml:space="preserve">
          <source>If the executable called by system()/exec()/pipe-open()/&lt;code&gt;``&lt;/code&gt; is not found (is not this remark obsolete?);</source>
          <target state="translated">如果找不到由system（）/ exec（）/ pipe-open（）/ &lt;code&gt;``&lt;/code&gt; 调用的可执行文件（此标记是否已过时？）;</target>
        </trans-unit>
        <trans-unit id="50b9d8b532d25e89b151dc2833716077761d9468" translate="yes" xml:space="preserve">
          <source>If the exit status used is less than 2, then output is printed on &lt;code&gt;STDOUT&lt;/code&gt; . Otherwise output is printed on &lt;code&gt;STDERR&lt;/code&gt; .</source>
          <target state="translated">如果使用的退出状态小于2，则在 &lt;code&gt;STDOUT&lt;/code&gt; 上打印输出。否则，输出将打印在 &lt;code&gt;STDERR&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="48f5e0e5ea6330c7048648eb2edf1ad4ccc05a55" translate="yes" xml:space="preserve">
          <source>If the experimental &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; . This indicates that the caller is expecting numeric behaviour. The fourth argument will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, as that position (&lt;code&gt;$_[3]&lt;/code&gt; ) is reserved for use by &lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt;.</source>
          <target state="translated">如果启用了实验性的&amp;ldquo;按位&amp;rdquo;功能（请参见&lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;），则将第五个TRUE参数传递给处理 &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; 的子例程。， &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; 。这表明呼叫者正在期待数字行为。第四个参数将是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，因为该位置（ &lt;code&gt;$_[3]&lt;/code&gt; ）保留供&lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt;使用。</target>
        </trans-unit>
        <trans-unit id="8d70ab84f3a316c00496bd0dced7b93acc9fa6af" translate="yes" xml:space="preserve">
          <source>If the experimental &quot;bitwise&quot; feature is enabled via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'bitwise'&lt;/code&gt; , then this operator always treats its operand as numbers. This feature produces a warning unless you also use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings
'experimental::bitwise'&lt;/code&gt; .</source>
          <target state="translated">如果通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'bitwise'&lt;/code&gt; 启用了实验性的&amp;ldquo;按位&amp;rdquo;功能，则此运算符始终将其操作数视为数字。除非您也 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::bitwise'&lt;/code&gt; 使用警告'experimental :: bitwise'，否则此功能会产生警告。</target>
        </trans-unit>
        <trans-unit id="429f3423b67c7b1e2fda19e3e61bde6079c26d75" translate="yes" xml:space="preserve">
          <source>If the experimental &quot;bitwise&quot; feature is enabled via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'bitwise'&lt;/code&gt; , then unary &lt;code&gt;&quot;~&quot;&lt;/code&gt; always treats its argument as a number, and an alternate form of the operator, &lt;code&gt;&quot;~.&quot;&lt;/code&gt; , always treats its argument as a string. So &lt;code&gt;~0&lt;/code&gt; and &lt;code&gt;~&quot;0&quot;&lt;/code&gt; will both give 2**32-1 on 32-bit platforms, whereas &lt;code&gt;~.0&lt;/code&gt; and &lt;code&gt;~.&quot;0&quot;&lt;/code&gt; will both yield &lt;code&gt;&quot;\xff&quot;&lt;/code&gt; . This feature produces a warning unless you use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::bitwise'&lt;/code&gt; .</source>
          <target state="translated">如果通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'bitwise'&lt;/code&gt; 启用了实验性的&amp;ldquo;按位&amp;rdquo;功能，则一元 &lt;code&gt;&quot;~&quot;&lt;/code&gt; 始终将其自变量视为数字，并使用另一种形式的运算符 &lt;code&gt;&quot;~.&quot;&lt;/code&gt; ，始终将其参数视为字符串。所以 &lt;code&gt;~0&lt;/code&gt; 和 &lt;code&gt;~&quot;0&quot;&lt;/code&gt; 将两者得到2 ** 32-1在32位的平台，而 &lt;code&gt;~.0&lt;/code&gt; 和 &lt;code&gt;~.&quot;0&quot;&lt;/code&gt; 将两者收率 &lt;code&gt;&quot;\xff&quot;&lt;/code&gt; 。除非你使用该功能产生警告 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::bitwise'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44c964489535901a948a3b23073f9b9bb3c0a3e6" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to a label name, its scope will be resolved dynamically. This allows for computed &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">如果表达式的计算结果为标签名称，则将动态解析其范围。这允许每个FORTRAN 计算出 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; ，但是如果您要针对可维护性进行优化，则不一定建议这样做：</target>
        </trans-unit>
        <trans-unit id="c0c3c70b730f0e2950f8179af548175b3c6ef32a" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to a label name, its scope will be resolved dynamically. This allows for computed &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">如果表达式的计算结果为标签名称，则将动态解析其范围。这允许每个FORTRAN 计算出 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; ，但是如果您要针对可维护性进行优化，则不一定建议这样做：</target>
        </trans-unit>
        <trans-unit id="3a5f344d7e209018f81b3bb395e41710ea76000e" translate="yes" xml:space="preserve">
          <source>If the extension doesn't contain a &lt;code&gt;*&lt;/code&gt; , then it is appended to the end of the current filename as a suffix. If the extension does contain one or more &lt;code&gt;*&lt;/code&gt; characters, then each &lt;code&gt;*&lt;/code&gt; is replaced with the current filename. In Perl terms, you could think of this as:</source>
          <target state="translated">如果扩展名不包含 &lt;code&gt;*&lt;/code&gt; ，那么它将作为后缀附加到当前文件名的末尾。如果扩展名确实包含一个或多个 &lt;code&gt;*&lt;/code&gt; 字符，则每个 &lt;code&gt;*&lt;/code&gt; 将被替换为当前文件名。用Perl来讲，您可以这样认为：</target>
        </trans-unit>
        <trans-unit id="912122ed04813ef6afa69c21de9ff5d7b9578a1b" translate="yes" xml:space="preserve">
          <source>If the extension links to a library that it builds, set this to the name of the library (see SDBM_File)</source>
          <target state="translated">如果扩展链接到它所构建的库,则将其设置为库的名称(参见SDBM_File)</target>
        </trans-unit>
        <trans-unit id="d3a643174ddd0d9876c30f4ff9ae6dc788ca282c" translate="yes" xml:space="preserve">
          <source>If the extension might need extra libraries, they should be included here. The extension Makefile.PL will take care of checking whether the libraries actually exist and how they should be loaded. The extra libraries should be specified in the form -lm -lposix, etc, just as on the cc command line. By default, the Makefile.PL will search through the library path determined by Configure. That path can be augmented by including arguments of the form &lt;b&gt;-L/another/library/path&lt;/b&gt; in the extra-libraries argument.</source>
          <target state="translated">如果扩展程序可能需要额外的库，则应将其包含在此处。扩展Makefile.PL将负责检查库是否确实存在以及如何加载它们。额外的库应以-lm -lposix等形式指定，就像在cc命令行上一样。默认情况下，Makefile.PL将搜索由Configure确定的库路径。可以通过在Extra-libraries参数中包含&lt;b&gt;-L / another / library / path&lt;/b&gt;形式的参数来扩展该路径。</target>
        </trans-unit>
        <trans-unit id="effa256cfcef0cdd6582a1503da6bdf1fb1d1f9e" translate="yes" xml:space="preserve">
          <source>If the external</source>
          <target state="translated">如果外部</target>
        </trans-unit>
        <trans-unit id="2e204c469081d0ce7742a3d71bcaeedaf9240cda" translate="yes" xml:space="preserve">
          <source>If the extractor fails to match (in the case of a regex extractor), or returns an empty list or an undefined value (in the case of a subroutine extractor), it is assumed to have failed to extract. If none of the extractor subroutines succeeds, then one character is extracted from the start of the text and the extraction subroutines reapplied. Characters which are thus removed are accumulated and eventually become the next field (unless the fourth argument is true, in which case they are discarded).</source>
          <target state="translated">如果提取器未能匹配(在regex提取器的情况下),或返回一个空列表或未定义的值(在子程序提取器的情况下),则认为提取失败。如果没有一个提取子程序成功,那么就从文本的开头提取一个字符,然后重新应用提取子程序。这样被删除的字符会被累积起来,最终成为下一个字段(除非第四个参数为真,在这种情况下,它们会被丢弃)。</target>
        </trans-unit>
        <trans-unit id="17d2c98a680d0b983c00126ba7fbf7037583b89d" translate="yes" xml:space="preserve">
          <source>If the extractor is a hash reference, it must contain exactly one element. The value of that element is one of the above extractor types (subroutine reference, regular expression, or string). The key of that element is the name of a class into which the successful return value of the extractor will be blessed.</source>
          <target state="translated">如果提取器是一个哈希引用,那么它必须正好包含一个元素,这个元素的值是上述提取器类型之一(子程序引用、正则表达式或字符串)。该元素的值是上述提取器类型之一(子程序引用、正则表达式或字符串)。该元素的键是一个类的名称,提取器的成功返回值将被祝福到该类中。</target>
        </trans-unit>
        <trans-unit id="a2187e610c6c9ce986c9ab2bc434fe210c96d6c7" translate="yes" xml:space="preserve">
          <source>If the extractor is a precompiled regular expression or a string, it is matched against the text in a scalar context with a leading '\G' and the gc modifiers enabled. The extracted value is either $1 if that variable is defined after the match, or else the complete match (i.e. $&amp;amp;).</source>
          <target state="translated">如果提取器是预编译的正则表达式或字符串，则将其与标量上下文中的文本匹配，并启用前导'\ G'并启用gc修饰符。如果该变量是在匹配之后定义的，则提取的值要么是$ 1，要么是完整匹配（即$＆）。</target>
        </trans-unit>
        <trans-unit id="8efec72894ea829331e728164da92723ccc10f46" translate="yes" xml:space="preserve">
          <source>If the extractor is a subroutine it is called in a list context and is expected to return a list of a single element, namely the extracted text. It may optionally also return two further arguments: a string representing the text left after extraction (like $' for a pattern match), and a string representing any prefix skipped before the extraction (like $` in a pattern match). Note that this is designed to facilitate the use of other Text::Balanced subroutines with &lt;code&gt;extract_multiple&lt;/code&gt; . Note too that the value returned by an extractor subroutine need not bear any relationship to the corresponding substring of the original text (see examples below).</source>
          <target state="translated">如果提取器是子例程，则在列表上下文中调用该提取器，并期望它返回单个元素的列表，即提取的文本。它也可以选择返回另外两个参数：一个字符串，表示提取后剩余的文本（如$'用于模式匹配），以及一个字符串，表示提取前跳过的任何前缀（如$`在模式匹配中）。请注意，这是为了方便使用带有 &lt;code&gt;extract_multiple&lt;/code&gt; 的其他Text :: Balanced子例程。还要注意，提取器子例程返回的值不必与原始文本的相应子字符串有任何关系（请参见下面的示例）。</target>
        </trans-unit>
        <trans-unit id="e4293d2972da49b7deee5cbac8e57e93be999a13" translate="yes" xml:space="preserve">
          <source>If the file is a symlink, the file it's pointing to</source>
          <target state="translated">如果文件是一个符号链接,那么它所指向的文件就是</target>
        </trans-unit>
        <trans-unit id="1260f14708b5c4f0e969b3d9b19ac87d75cb1573" translate="yes" xml:space="preserve">
          <source>If the file is pulled in by &lt;code&gt;perl_parse()&lt;/code&gt; , compiled into a newly constructed interpreter, and subsequently cleaned out with &lt;code&gt;perl_destruct()&lt;/code&gt; afterwards, you're shielded from most namespace troubles.</source>
          <target state="translated">如果将文件由 &lt;code&gt;perl_parse()&lt;/code&gt; 放入，编译为新构造的解释器，然后再使用 &lt;code&gt;perl_destruct()&lt;/code&gt; 进行清理，则可以避免大多数命名空间的麻烦。</target>
        </trans-unit>
        <trans-unit id="972b095c8cf0635710238db90318d20a5a12c4b1" translate="yes" xml:space="preserve">
          <source>If the file named by FILENAME does not exist and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call creates it (typically because MODE includes the &lt;code&gt;O_CREAT&lt;/code&gt; flag), then the value of PERMS specifies the permissions of the newly created file. If you omit the PERMS argument to &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, Perl uses the octal value &lt;code&gt;0666&lt;/code&gt; . These permission values need to be in octal, and are modified by your process's current &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果由FILENAME命名的文件不存在，并且 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 调用创建了该文件（通常是因为MODE包含 &lt;code&gt;O_CREAT&lt;/code&gt; 标志），则PERMS的值将指定新创建文件的权限。如果您将 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 的PERMS参数省略，Perl将使用八进制值 &lt;code&gt;0666&lt;/code&gt; 。这些权限值必须为八进制，并由进程的当前 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 进行修改。</target>
        </trans-unit>
        <trans-unit id="8aa66e9311c9629d0b8c20e950c88829b4d37f7e" translate="yes" xml:space="preserve">
          <source>If the file named by FILENAME does not exist and the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call creates it (typically because MODE includes the &lt;code&gt;O_CREAT&lt;/code&gt; flag), then the value of PERMS specifies the permissions of the newly created file. If you omit the PERMS argument to &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, Perl uses the octal value &lt;code&gt;0666&lt;/code&gt; . These permission values need to be in octal, and are modified by your process's current &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果由FILENAME命名的文件不存在，并且 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 调用创建了该文件（通常是因为MODE包含 &lt;code&gt;O_CREAT&lt;/code&gt; 标志），则PERMS的值将指定新创建文件的权限。如果您将 &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 的PERMS参数省略，Perl将使用八进制值 &lt;code&gt;0666&lt;/code&gt; 。这些权限值必须为八进制，并由进程的当前 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 进行修改。</target>
        </trans-unit>
        <trans-unit id="9b9e946eeefcb8ca3ed866d0a22b192157304573" translate="yes" xml:space="preserve">
          <source>If the file to be opened contains binary data instead of text characters, then the &lt;code&gt;MODE&lt;/code&gt; argument to &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is a little different. Instead of specifying the encoding, you tell Perl that your data are in raw bytes.</source>
          <target state="translated">如果要打开的文件包含二进制数据而不是文本字符， &lt;code&gt;MODE&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 的MODE参数稍有不同。您无需指定编码，而是告诉Perl您的数据以原始字节为单位。</target>
        </trans-unit>
        <trans-unit id="ed7727f14d3896e4199132a911f1277a6913be80" translate="yes" xml:space="preserve">
          <source>If the file was loaded via a hook (e.g. a subroutine reference, see &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for a description of these hooks), this hook is by default inserted into &lt;code&gt;%INC&lt;/code&gt; in place of a filename. Note, however, that the hook may have set the &lt;code&gt;%INC&lt;/code&gt; entry by itself to provide some more specific info.</source>
          <target state="translated">如果文件是通过挂钩加载的（例如，子例程引用，请参阅&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;以获取这些挂钩的描述），则默认情况下，此挂钩将插入 &lt;code&gt;%INC&lt;/code&gt; 而不是文件名。但是请注意，该挂钩可能已自行设置了 &lt;code&gt;%INC&lt;/code&gt; 条目以提供一些更具体的信息。</target>
        </trans-unit>
        <trans-unit id="6e74503c754d78c3ba0f9051478f8b0d722c72c1" translate="yes" xml:space="preserve">
          <source>If the filehandle came from a piped open, &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; returns false if one of the other syscalls involved fails or if its program exits with non-zero status. If the only problem was that the program exited non-zero, &lt;code&gt;$!&lt;/code&gt; will be set to &lt;code&gt;0&lt;/code&gt; . Closing a pipe also waits for the process executing on the pipe to exit--in case you wish to look at the output of the pipe afterwards--and implicitly puts the exit status value of that command into &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</source>
          <target state="translated">如果文件句柄来自管道打开，则如果所涉及的其他系统调用之一失败或其程序以非零状态退出，则 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 返回false。如果唯一的问题是程序退出了非零值，则 &lt;code&gt;$!&lt;/code&gt; 将设置为 &lt;code&gt;0&lt;/code&gt; 。关闭管道还需要等待在管道上执行的进程退出（以防您以后要查看管道的输出），并将该命令的退出状态值隐式地放入 &lt;code&gt;$?&lt;/code&gt; 中。和 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a275dda5ca271e5742fe50c27b80a1dea7fadc2a" translate="yes" xml:space="preserve">
          <source>If the filehandle came from a piped open, &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; returns false if one of the other syscalls involved fails or if its program exits with non-zero status. If the only problem was that the program exited non-zero, &lt;code&gt;$!&lt;/code&gt; will be set to &lt;code&gt;0&lt;/code&gt; . Closing a pipe also waits for the process executing on the pipe to exit--in case you wish to look at the output of the pipe afterwards--and implicitly puts the exit status value of that command into &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</source>
          <target state="translated">如果文件句柄来自管道打开，则如果所涉及的其他系统调用之一失败或其程序以非零状态退出，则 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 返回false。如果唯一的问题是程序退出了非零值，则 &lt;code&gt;$!&lt;/code&gt; 将设置为 &lt;code&gt;0&lt;/code&gt; 。关闭管道还需要等待在管道上执行的进程退出（以防您以后要查看管道的输出），并将该命令的退出状态值隐式地放入 &lt;code&gt;$?&lt;/code&gt; 中。和 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fc5e1415bd14e8d1ec6ad1e512653e073ea2d16" translate="yes" xml:space="preserve">
          <source>If the filename supplied contains directory separators (and so is an absolute or relative pathname), and if that file is not found, platforms that append file extensions will do so and try to look for the file with those extensions added, one by one.</source>
          <target state="translated">如果提供的文件名包含目录分隔符(所以是绝对或相对路径名),如果找不到该文件,附加文件扩展名的平台就会这样做,并试图逐一寻找添加了这些扩展名的文件。</target>
        </trans-unit>
        <trans-unit id="8b638dc989817125971a607e8fa00529b2b307c1" translate="yes" xml:space="preserve">
          <source>If the final value specified is not in the sequence that the magical increment would produce, the sequence goes until the next value would be longer than the final value specified.</source>
          <target state="translated">如果指定的最终值不在魔法增量所产生的序列中,则序列将继续进行,直到下一个值比指定的最终值长。</target>
        </trans-unit>
        <trans-unit id="d5f8e1e30b780f6553cc08550f9370ae0ed9b97a" translate="yes" xml:space="preserve">
          <source>If the first argument is a reference to an array, the pseudo-hash will be created with keys from that array. If a second argument is supplied, it must also be a reference to an array whose elements will be used as the values. If the second array contains less elements than the first, the trailing elements of the pseudo-hash will not be initialized. This makes it particularly useful for creating a pseudo-hash from subroutine arguments:</source>
          <target state="translated">如果第一个参数是一个数组的引用,那么伪哈希值将用该数组中的键创建。如果提供了第二个参数,它也必须是一个数组的引用,其元素将被用作值。如果第二个数组包含的元素比第一个数组少,伪哈希值的尾部元素将不会被初始化。这使得它对于从子程序参数创建伪哈希值特别有用。</target>
        </trans-unit>
        <trans-unit id="9f235f80bacbd6f2376896bcd2071e6b6ed89634" translate="yes" xml:space="preserve">
          <source>If the first argument is an empty string &quot;&quot; or is a volume name, i.e. matches the pattern /^[^:]+:/, the resulting path is &lt;b&gt;absolute&lt;/b&gt;.</source>
          <target state="translated">如果第一个参数是空字符串&amp;ldquo;&amp;rdquo;或卷名，即匹配模式/ ^ [^：] +：/，则结果路径为&lt;b&gt;absolute&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="89aa8ef2f6a6df7b419aa16ffe18ced8031ac672" translate="yes" xml:space="preserve">
          <source>If the first character after the &lt;b&gt;-M&lt;/b&gt; or &lt;b&gt;-m&lt;/b&gt; is a dash (&lt;b&gt;-&lt;/b&gt;) then the 'use' is replaced with 'no'.</source>
          <target state="translated">如果&lt;b&gt;-M&lt;/b&gt;或&lt;b&gt;-m&lt;/b&gt;之后的第一个字符是破折号（&lt;b&gt;-&lt;/b&gt;），则将'use'替换为'no'。</target>
        </trans-unit>
        <trans-unit id="781d0d29a2affd4018c32ec572f1b116a7081027" translate="yes" xml:space="preserve">
          <source>If the first chars of a Perl script are &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; , this line is treated as &lt;code&gt;#!&lt;/code&gt; -line, thus all the switches on this line are processed (twice if script was started via cmd.exe). See &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;DESCRIPTION in perlrun&lt;/a&gt;.</source>
          <target state="translated">如果Perl脚本的第一个字符为 &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; ，则此行将被视为 &lt;code&gt;#!&lt;/code&gt; 。-line，因此将处理此行上的所有开关（如果脚本是通过cmd.exe启动的，则为两次）。请参见&lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;perlrun中的DESCRIPTION&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f46518f452342a5c022fec8e53026c8608f2e02a" translate="yes" xml:space="preserve">
          <source>If the first digit following the backslash is a 0, it's an octal escape.</source>
          <target state="translated">如果反斜杠后面的第一个数字是0,那就是八进制转义。</target>
        </trans-unit>
        <trans-unit id="5675bafb3dc48482ba4a4f320234c0b4d704c9a0" translate="yes" xml:space="preserve">
          <source>If the first element of the return value (&lt;code&gt;success&lt;/code&gt; ) was 0, then some error occurred. This second element is the error message the command you requested exited with, if available. This is generally a pretty printed value of &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$@&lt;/code&gt; . See &lt;code&gt;perldoc perlvar&lt;/code&gt; for details on what they can contain. If the error was a timeout, the &lt;code&gt;error message&lt;/code&gt; will be prefixed with the string &lt;code&gt;IPC::Cmd::TimeOut&lt;/code&gt; , the timeout class.</source>
          <target state="translated">如果返回值的第一个元素（ &lt;code&gt;success&lt;/code&gt; ）为0，则发生一些错误。第二个元素是您请求退出的命令的错误消息（如果有）。通常这是 &lt;code&gt;$?&lt;/code&gt; 的漂亮印刷价值。或 &lt;code&gt;$@&lt;/code&gt; 。有关它们可以包含的内容的详细信息，请参见 &lt;code&gt;perldoc perlvar&lt;/code&gt; 。如果错误是超时，则 &lt;code&gt;error message&lt;/code&gt; 将以字符串 &lt;code&gt;IPC::Cmd::TimeOut&lt;/code&gt; 作为超时类的前缀。</target>
        </trans-unit>
        <trans-unit id="6a57fb9b1830952d24356efef9c0744590e7e139" translate="yes" xml:space="preserve">
          <source>If the first item in a bracket group is &quot;*&quot;, it's taken as shorthand for the so commonly called &quot;quant&quot; method. Similarly, if the first item in a bracket group is &quot;#&quot;, it's taken to be shorthand for &quot;numf&quot;.</source>
          <target state="translated">如果括号组中的第一项是 &quot;*&quot;,它就会被当作是通常所说的 &quot;quant &quot;方法的简写。同样,如果括号组中的第一项是 &quot;#&quot;,则作为 &quot;numf &quot;的速记。</target>
        </trans-unit>
        <trans-unit id="1953104edb77654c33631a60ba8219310b08e426" translate="yes" xml:space="preserve">
          <source>If the first item in a bracket group is the empty-string, or &quot;_*&quot; or &quot;_</source>
          <target state="translated">如果括号组中的第一项是空字符串,或&quot;_*&quot;或&quot;_&quot;。</target>
        </trans-unit>
        <trans-unit id="bf6e94a3fad4e68b50306c3295f243e0a73b5811" translate="yes" xml:space="preserve">
          <source>If the first item in a bracket group looks like a method name, then that group is interpreted like this:</source>
          <target state="translated">如果括号组中的第一项看起来像方法名,那么该组的解释是这样的。</target>
        </trans-unit>
        <trans-unit id="ccf14e3215a8aeb1aa87eb4f44052cead882fc98" translate="yes" xml:space="preserve">
          <source>If the first operand has a &quot;nomethod&quot; method then use that.</source>
          <target state="translated">如果第一个操作数有一个 &quot;nomethod &quot;方法,那么就使用该方法。</target>
        </trans-unit>
        <trans-unit id="a0dadbb13895f7c7975effc9602b93ea5e861379" translate="yes" xml:space="preserve">
          <source>If the first operand has declared a subroutine to overload the operator then use that implementation.</source>
          <target state="translated">如果第一个操作数已经声明了一个子程序来重载操作数,那么就使用该实现。</target>
        </trans-unit>
        <trans-unit id="63722d831a3c09d59c00e59b75ba5f74f6230f38" translate="yes" xml:space="preserve">
          <source>If the flag is present in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; will delete whitespace from the start of the subject string before it's operated on. What is considered whitespace depends on if the subject is a UTF-8 string and if the &lt;code&gt;RXf_PMf_LOCALE&lt;/code&gt; flag is set.</source>
          <target state="translated">如果该标志存在于 &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; 中,则 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 将在操作主题字符串之前从主题字符串的开头删除空格。空格取决于主题是否为UTF-8字符串以及是否设置了 &lt;code&gt;RXf_PMf_LOCALE&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="dbc08ae29def75bcb01866771948171d3f78fd50" translate="yes" xml:space="preserve">
          <source>If the function is used across several files, but intended only for Perl's internal use (and this should be the common case), do not export it to the public API. See the discussion about</source>
          <target state="translated">如果该函数在多个文件中使用,但仅用于 Perl 内部使用(这应该是常见的情况),不要将其导出到公共 API 中。参见关于</target>
        </trans-unit>
        <trans-unit id="0cd096b932efa03a9f98d53e47997c47f5475a48" translate="yes" xml:space="preserve">
          <source>If the function is used only inside one source code file, make it static. See the discussion about</source>
          <target state="translated">如果该函数只在一个源代码文件中使用,请将其静态化。参见关于</target>
        </trans-unit>
        <trans-unit id="d809f75a0fec341370456ffe5542097322b23570" translate="yes" xml:space="preserve">
          <source>If the function wants to handle the keyword, it first must parse anything following the keyword that is part of the syntax introduced by the keyword. See &lt;a href=&quot;#Lexer-interface&quot;&gt;Lexer interface&lt;/a&gt; for details.</source>
          <target state="translated">如果函数要处理关键字，则它首先必须解析关键字后面的所有内容，这是关键字引入的语法的一部分。有关详细信息，请参见&lt;a href=&quot;#Lexer-interface&quot;&gt;Lexer界面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4257aa9162577acd082afc2803cd5eba4d35b6a8" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;DESTROY&lt;/b&gt; then the C++ &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; function will be called and &lt;code&gt;THIS&lt;/code&gt; will be given as its parameter. The generated C++ code for</source>
          <target state="translated">如果该函数的名称为&lt;b&gt;DESTROY，&lt;/b&gt;则将调用C ++ &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 函数，并以 &lt;code&gt;THIS&lt;/code&gt; 作为其参数。为生成的C ++代码</target>
        </trans-unit>
        <trans-unit id="7a9d5afefb1f72725e3effbcde85fc42f858949b" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;new&lt;/b&gt; then the C++ &lt;code&gt;new&lt;/code&gt; function will be called to create a dynamic C++ object. The XSUB will expect the class name, which will be kept in a variable called &lt;code&gt;CLASS&lt;/code&gt; , to be given as the first argument.</source>
          <target state="translated">如果函数名称为&lt;b&gt;new，&lt;/b&gt;则将调用C ++ &lt;code&gt;new&lt;/code&gt; 函数来创建动态C ++对象。XSUB将期望将类名作为第一个参数给出，该类名将保留在名为 &lt;code&gt;CLASS&lt;/code&gt; 的变量中。</target>
        </trans-unit>
        <trans-unit id="cf92d6194fe17b6faa691c083e3aa66b73fd41bc" translate="yes" xml:space="preserve">
          <source>If the given file is a Storable image return a hash describing it. If the file is readable, but not a Storable image return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. If the file does not exist or is unreadable then croak.</source>
          <target state="translated">如果给定文件是可存储映像，则返回描述它的哈希值。如果文件可读，但不存储图像，则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。如果文件不存在或不可读，则发出嘶哑声。</target>
        </trans-unit>
        <trans-unit id="6f5f5dfa299a465aa9a0110ad7326e956c843743" translate="yes" xml:space="preserve">
          <source>If the given string is in FCD (&quot;Fast C or D&quot; form; cf. UTN #5), it returns the string without modification; otherwise it returns an FCD string.</source>
          <target state="translated">如果给定的字符串是FCD形式(&quot;快速C或D &quot;形式;参见UTN #5),它将不加修改地返回字符串;否则它将返回一个FCD字符串。</target>
        </trans-unit>
        <trans-unit id="12d092a8012a2b0bc17122d5b49e40f14ceca06d" translate="yes" xml:space="preserve">
          <source>If the global variable $KEEP_ALL is true, the file or directory will not be removed.</source>
          <target state="translated">如果全局变量$KEEP_ALL为真,文件或目录将不会被删除。</target>
        </trans-unit>
        <trans-unit id="cc1c6dee6d24dc894200423540415887a91afb83" translate="yes" xml:space="preserve">
          <source>If the groupings in a regex are nested, &lt;code&gt;$1&lt;/code&gt; gets the group with the leftmost opening parenthesis, &lt;code&gt;$2&lt;/code&gt; the next opening parenthesis, etc. For example, here is a complex regex and the matching variables indicated below it:</source>
          <target state="translated">如果正则表达式中的分组是嵌套的，则 &lt;code&gt;$1&lt;/code&gt; 会得到最左括号的组， &lt;code&gt;$2&lt;/code&gt; 是下一个括号的组，以此类推。例如，这是一个复杂的正则表达式，并在其下方指示了匹配的变量：</target>
        </trans-unit>
        <trans-unit id="83b41f5fdfcf62fc4686ef889212a3544a4d2078" translate="yes" xml:space="preserve">
          <source>If the groupings in a regexp are nested, &lt;code&gt;$1&lt;/code&gt; gets the group with the leftmost opening parenthesis, &lt;code&gt;$2&lt;/code&gt; the next opening parenthesis, etc. Here is a regexp with nested groups:</source>
          <target state="translated">如果一个正则表达式中的分组是嵌套的，则 &lt;code&gt;$1&lt;/code&gt; 将得到最左括号的组， &lt;code&gt;$2&lt;/code&gt; 将是下一个括号，等等。这是一个带有嵌套组的正则表达式：</target>
        </trans-unit>
        <trans-unit id="7672fac594e6a7dd98d2bae0c51d24e5065e39e4" translate="yes" xml:space="preserve">
          <source>If the gzip FEXTRA header field is present it must conform to the sub-field structure as defined in RFC 1952.</source>
          <target state="translated">如果存在gzip FEXTRA头字段,它必须符合RFC 1952中定义的子字段结构。</target>
        </trans-unit>
        <trans-unit id="948511a86fa3a757ed333c1057a05dc236b1ed7b" translate="yes" xml:space="preserve">
          <source>If the gzip header contains a comment field (FCOMMENT) it consists solely of ISO 8859-1 characters plus line-feed.</source>
          <target state="translated">如果gzip头包含注释字段(FCOMMENT),它仅由ISO 8859-1字符加换行组成。</target>
        </trans-unit>
        <trans-unit id="309f2d92f5e86ee4880748347a713d797525d1c3" translate="yes" xml:space="preserve">
          <source>If the gzip header contains a name field (FNAME) it consists solely of ISO 8859-1 characters.</source>
          <target state="translated">如果gzip头包含一个名称字段(FNAME),它只由ISO 8859-1字符组成。</target>
        </trans-unit>
        <trans-unit id="76da98a8a76e4650e3f026f7c68c78b99cc6936b" translate="yes" xml:space="preserve">
          <source>If the hash is very large, you might not want to create a long list of keys. To save some memory, you can grab one key-value pair at a time using &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt;, which returns a pair you haven't seen yet:</source>
          <target state="translated">如果哈希很大，则可能不想创建一长串的键。为了节省一些内存，您可以使用 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; 一次获取一个键-值对，它返回一个尚未出现的对：</target>
        </trans-unit>
        <trans-unit id="7d353d642decb66a3abbcefcf79e58c99b0ba1e9" translate="yes" xml:space="preserve">
          <source>If the hook is an array reference, its first element must be a subroutine reference. This subroutine is called as above, but the first parameter is the array reference. This lets you indirectly pass arguments to the subroutine.</source>
          <target state="translated">如果钩子是一个数组引用,它的第一个元素必须是一个子程序引用。这个子程序的调用和上面一样,但第一个参数是数组引用。这让你可以间接地将参数传递给子程序。</target>
        </trans-unit>
        <trans-unit id="089781c4ed94b59afd45ade73f63dd3ae0adcf17" translate="yes" xml:space="preserve">
          <source>If the hook is an object, it must provide an INC method that will be called as above, the first parameter being the object itself. (Note that you must fully qualify the sub's name, as unqualified &lt;code&gt;INC&lt;/code&gt; is always forced into package &lt;code&gt;main&lt;/code&gt; .) Here is a typical code layout:</source>
          <target state="translated">如果钩子是对象，则它必须提供将如上所述被调用的INC方法，第一个参数是对象本身。（请注意，您必须完全限定子名称，因为不合格的 &lt;code&gt;INC&lt;/code&gt; 总是被强制放入包 &lt;code&gt;main&lt;/code&gt; 中。）以下是典型的代码布局：</target>
        </trans-unit>
        <trans-unit id="dc5ac6730609a596bd949c3bb5ec01a23d4ffce0" translate="yes" xml:space="preserve">
          <source>If the initial value specified isn't part of a magical increment sequence (that is, a non-empty string matching &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; ), only the initial value will be returned. So the following will only return an alpha:</source>
          <target state="translated">如果指定的初始值不是魔术增量序列的一部分（即，非空字符串匹配 &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; ），则仅初始值会被退回。因此，以下内容将仅返回Alpha：</target>
        </trans-unit>
        <trans-unit id="ce1ecd771a78ded6bdca0c84c4a8624d300c4df7" translate="yes" xml:space="preserve">
          <source>If the initialization begins with &lt;code&gt;=&lt;/code&gt; , then it is output in the declaration for the input variable, replacing the initialization supplied by the typemap. If the initialization begins with &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; , then it is performed after all of the input variables have been declared. In the &lt;code&gt;;&lt;/code&gt; case the initialization normally supplied by the typemap is not performed. For the &lt;code&gt;+&lt;/code&gt; case, the declaration for the variable will include the initialization from the typemap. A global variable, &lt;code&gt;%v&lt;/code&gt; , is available for the truly rare case where information from one initialization is needed in another initialization.</source>
          <target state="translated">如果初始化以 &lt;code&gt;=&lt;/code&gt; 开头，那么它将在输入变量的声明中输出，取代了typemap提供的初始化。如果初始化以 &lt;code&gt;;&lt;/code&gt; 或 &lt;code&gt;+&lt;/code&gt; ，然后在声明所有输入变量之后执行。在 &lt;code&gt;;&lt;/code&gt; 如果通常不执行类型映射提供的初始化。对于 &lt;code&gt;+&lt;/code&gt; 情况，变量的声明将包括来自类型映射的初始化。全局变量 &lt;code&gt;%v&lt;/code&gt; 可用于非常罕见的情况，在这种情况下，一次初始化需要来自另一次初始化的信息。</target>
        </trans-unit>
        <trans-unit id="a641a3d375c74024ce1445924cf66af681f41ebd" translate="yes" xml:space="preserve">
          <source>If the input code point's name has more than one synonym, they are returned joined into a single comma-separated string.</source>
          <target state="translated">如果输入代码点的名称有一个以上的同义词,则将它们连接成一个逗号分隔的字符串返回。</target>
        </trans-unit>
        <trans-unit id="9e071ed158601437a7fd928632778e71dc9740aa" translate="yes" xml:space="preserve">
          <source>If the input file/buffer contains multiple compressed data streams, this option will uncompress the whole lot as a single data stream.</source>
          <target state="translated">如果输入文件/缓冲区包含多个压缩数据流,该选项将把整个文件/缓冲区解压缩为一个数据流。</target>
        </trans-unit>
        <trans-unit id="3c582e01c3ed1134227361002db4abc5ef87f0a6" translate="yes" xml:space="preserve">
          <source>If the input is a buffer, &lt;code&gt;trailingData&lt;/code&gt; will return everything from the end of the compressed data stream to the end of the buffer.</source>
          <target state="translated">如果输入是缓冲区，则 &lt;code&gt;trailingData&lt;/code&gt; 将返回从压缩数据流末尾到缓冲区末尾的所有内容。</target>
        </trans-unit>
        <trans-unit id="646ddea5cc7fe42fca7b5f673b48b7968e951a94" translate="yes" xml:space="preserve">
          <source>If the input is a filehandle, &lt;code&gt;trailingData&lt;/code&gt; will return the data that is left in the filehandle input buffer once the end of the compressed data stream has been reached. You can then use the filehandle to read the rest of the input file.</source>
          <target state="translated">如果输入是文件句柄，则在到达压缩数据流的末尾时， &lt;code&gt;trailingData&lt;/code&gt; 将返回文件句柄输入缓冲区中剩余的数据。然后，您可以使用文件句柄读取其余的输入文件。</target>
        </trans-unit>
        <trans-unit id="68ffb2242fbe49d90e0f353510f536b7c97b26ff" translate="yes" xml:space="preserve">
          <source>If the input is a gzip (RFC 1952) data stream, the following will be checked:</source>
          <target state="translated">如果输入的是gzip(RFC 1952)数据流,将检查以下内容。</target>
        </trans-unit>
        <trans-unit id="fbb62e9bad07668939b33bd6b3f35cbd2a29221c" translate="yes" xml:space="preserve">
          <source>If the input is an RFC 1950 data stream, the following will be checked:</source>
          <target state="translated">如果输入是RFC1950数据流,将检查以下内容。</target>
        </trans-unit>
        <trans-unit id="681895bf526e306295ee60c6f4d01df1e2e0e233" translate="yes" xml:space="preserve">
          <source>If the input is being interpreted as UTF-8 and a UTF-8 encoding error is encountered, an exception is generated.</source>
          <target state="translated">如果输入被解释为UTF-8,并且遇到UTF-8编码错误,就会产生一个异常。</target>
        </trans-unit>
        <trans-unit id="3c3ba700c41877fa613cc375e9afc8a49773890d" translate="yes" xml:space="preserve">
          <source>If the input is unknown &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned in scalar context; an empty-list in list context. If the input is known, the number of elements in the list is returned if called in scalar context.</source>
          <target state="translated">如果输入未知，则在标量上下文中返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ；否则，返回0。列表上下文中的空列表。如果输入是已知的，则在标量上下文中调用时，将返回列表中的元素数。</target>
        </trans-unit>
        <trans-unit id="a45a90c97d69c88324a18a4a975329202a110a46" translate="yes" xml:space="preserve">
          <source>If the input string is longer than needed, extra characters are ignored.</source>
          <target state="translated">如果输入的字符串比需要的长,多余的字符将被忽略。</target>
        </trans-unit>
        <trans-unit id="daec947152f5e00d64f719376318858935b663a6" translate="yes" xml:space="preserve">
          <source>If the input string is longer than needed, remaining characters are ignored.</source>
          <target state="translated">如果输入的字符串比需要的长,剩余的字符将被忽略。</target>
        </trans-unit>
        <trans-unit id="1a191161ccbd661c7961516bab02ad1f7aadb16a" translate="yes" xml:space="preserve">
          <source>If the interdependence of your &lt;code&gt;BOOT:&lt;/code&gt; section and Perl code is more complicated than this (e.g., the &lt;code&gt;BOOT:&lt;/code&gt; section makes calls to Perl functions which make calls to XSUBs with prototypes), get rid of the &lt;code&gt;BOOT:&lt;/code&gt; section altogether. Replace it with a function &lt;code&gt;onBOOT()&lt;/code&gt; , and call it like this:</source>
          <target state="translated">如果您的 &lt;code&gt;BOOT:&lt;/code&gt; 部分与Perl代码的相互依赖关系比这更复杂（例如， &lt;code&gt;BOOT:&lt;/code&gt; 部分进行对Perl函数的调用，而Perl函数对具有原型的XSUB进行了调用），则完全摆脱 &lt;code&gt;BOOT:&lt;/code&gt; 部分。将其替换为 &lt;code&gt;onBOOT()&lt;/code&gt; 函数，并按以下方式调用它：</target>
        </trans-unit>
        <trans-unit id="3e4a966e522ce068cba366c74c39330ba735c481" translate="yes" xml:space="preserve">
          <source>If the key does not exist the method returns 1.</source>
          <target state="translated">如果键不存在,该方法返回1。</target>
        </trans-unit>
        <trans-unit id="f74ad7c032adb69e8741c3ce089dbedf2af387c8" translate="yes" xml:space="preserve">
          <source>If the language handle has a &quot;fail&quot; attribute whose value is a coderef, then $lh-&amp;gt;maketext(</source>
          <target state="translated">如果语言句柄具有值为&amp;ldquo; coderef&amp;rdquo;的&amp;ldquo; fail&amp;rdquo;属性，则$ lh-&amp;gt; maketext（</target>
        </trans-unit>
        <trans-unit id="74b0a2c233bae54a5a0a22d4c6904ecf217ffcc9" translate="yes" xml:space="preserve">
          <source>If the language handle has no &quot;fail&quot; attribute, maketext will simply throw an exception (i.e., it calls &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, mentioning the</source>
          <target state="translated">如果语言句柄没有&amp;ldquo; fail&amp;rdquo;属性，则maketext只会抛出一个异常（即，它调用 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，提到</target>
        </trans-unit>
        <trans-unit id="11f576169bf47c87f2f0af12c0e2e1a4146c280c" translate="yes" xml:space="preserve">
          <source>If the last element of LIST does not end in a newline, the current script line number and input line number (if any) are also printed, and a newline is supplied. Note that the &quot;input line number&quot; (also known as &quot;chunk&quot;) is subject to whatever notion of &quot;line&quot; happens to be currently in effect, and is also available as the special variable &lt;code&gt;$.&lt;/code&gt; . See &lt;a href=&quot;../perlvar#%24%2f&quot;&gt;$/ in perlvar&lt;/a&gt; and &lt;a href=&quot;../perlvar#%24.&quot;&gt;$. in perlvar&lt;/a&gt;.</source>
          <target state="translated">如果LIST的最后一个元素未以换行符结尾，则还将打印当前脚本行号和输入行号（如果有），并提供换行符。请注意，&amp;ldquo;输入行号&amp;rdquo;（也称为&amp;ldquo;块&amp;rdquo;）受当前有效的任何&amp;ldquo;行&amp;rdquo;概念的约束，并且也可以作为特殊变量 &lt;code&gt;$.&lt;/code&gt; 。请参阅&lt;a href=&quot;../perlvar#%24%2f&quot;&gt;$ /在perlvar&lt;/a&gt;和&lt;a href=&quot;../perlvar#%24.&quot;&gt;$。在perlvar中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ddf8780e7e7d9b3df1dc954871c1e6b0c532c31" translate="yes" xml:space="preserve">
          <source>If the last element of LIST does not end in a newline, the current script line number and input line number (if any) are also printed, and a newline is supplied. Note that the &quot;input line number&quot; (also known as &quot;chunk&quot;) is subject to whatever notion of &quot;line&quot; happens to be currently in effect, and is also available as the special variable &lt;code&gt;$.&lt;/code&gt; . See &lt;a href=&quot;perlvar#%24%2f&quot;&gt;$/ in perlvar&lt;/a&gt; and &lt;a href=&quot;perlvar#%24.&quot;&gt;$. in perlvar&lt;/a&gt;.</source>
          <target state="translated">如果LIST的最后一个元素未以换行符结尾，则还将打印当前脚本行号和输入行号（如果有），并提供换行符。请注意，&amp;ldquo;输入行号&amp;rdquo;（也称为&amp;ldquo;块&amp;rdquo;）受当前有效的任何&amp;ldquo;行&amp;rdquo;概念的约束，并且也可以作为特殊变量 &lt;code&gt;$.&lt;/code&gt; 。请参阅&lt;a href=&quot;perlvar#%24%2f&quot;&gt;$ /在perlvar&lt;/a&gt;和&lt;a href=&quot;perlvar#%24.&quot;&gt;$。在perlvar中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e90835049bf9dceb2b3128f6e0da3805c87bc497" translate="yes" xml:space="preserve">
          <source>If the left hand side is neither a package name nor an object, then the method call will cause an error, but see the section on &lt;a href=&quot;#Method-Call-Variations&quot;&gt;Method Call Variations&lt;/a&gt; for more nuances.</source>
          <target state="translated">如果左侧既不是程序包名称也不是对象，则方法调用将导致错误，但是请参见&amp;ldquo; &lt;a href=&quot;#Method-Call-Variations&quot;&gt;方法调用变体&lt;/a&gt; &amp;rdquo;部分以获取更多细微差别。</target>
        </trans-unit>
        <trans-unit id="37bacecd2332508665ec81733fbdffa749ac5bfa" translate="yes" xml:space="preserve">
          <source>If the length of the input string is not even, it behaves as if padded by a null character at the end. Similarly, &quot;extra&quot; nybbles are ignored during unpacking.</source>
          <target state="translated">如果输入字符串的长度不是偶数,它的行为就像在末尾填充了一个空字符一样。同样,&quot;额外的 &quot;nybbles在解包过程中会被忽略。</target>
        </trans-unit>
        <trans-unit id="88b7864a27a0577ffff54b7d555aea0617e9d505" translate="yes" xml:space="preserve">
          <source>If the length of the input string is not evenly divisible by 8, the remainder is packed as if the input string were padded by null characters at the end. Similarly during unpacking, &quot;extra&quot; bits are ignored.</source>
          <target state="translated">如果输入字符串的长度不能被8整除,那么剩余的部分就会被打包,就像输入字符串的末尾被空字符填充一样。同样,在解包过程中,&quot;额外 &quot;位将被忽略。</target>
        </trans-unit>
        <trans-unit id="a2e67d3ea522ed96fe7a9c8431714f7f3d0ba5c5" translate="yes" xml:space="preserve">
          <source>If the library happens to be in a location not in &lt;code&gt;$Config{libpth}&lt;/code&gt; , you need:</source>
          <target state="translated">如果该库恰好不在 &lt;code&gt;$Config{libpth}&lt;/code&gt; ，则需要：</target>
        </trans-unit>
        <trans-unit id="96118a855a2f1b2515701521249ef16334052e1f" translate="yes" xml:space="preserve">
          <source>If the line number is &lt;code&gt;.&lt;/code&gt;, sets a breakpoint on the current line:</source>
          <target state="translated">如果行号是 &lt;code&gt;.&lt;/code&gt; ，在当前行上设置一个断点：</target>
        </trans-unit>
        <trans-unit id="f93c03970a56584f9fb61994432bc17cb7db5f12" translate="yes" xml:space="preserve">
          <source>If the list moderators tell you that you are not being civil, carefully consider how your words have appeared before responding in any way. You may protest, but repeated protest in the face of a repeatedly reaffirmed decision is not acceptable.</source>
          <target state="translated">如果列表版主告诉你,你不文明,在以任何方式回应之前,请仔细考虑你的话是如何出现的。你可以抗议,但面对一再重申的决定,反复抗议是不可接受的。</target>
        </trans-unit>
        <trans-unit id="e0a9f58b026642b9c9e8e7bb8deab3007d5236f6" translate="yes" xml:space="preserve">
          <source>If the locale from the user's environment is desired, there should be no need for XS code to set the locale except for &lt;code&gt;LC_NUMERIC&lt;/code&gt; , as perl has already set it up. XS code should avoid changing the locale, as it can adversely affect other, unrelated, code and may not be thread safe. However, some alien libraries that may be called do set it, such as &lt;code&gt;Gtk&lt;/code&gt; . This can cause problems for the perl core and other modules. Starting in v5.20.1, calling the function &lt;a href=&quot;perlapi#sync_locale&quot;&gt;sync_locale()&lt;/a&gt; from XS should be sufficient to avoid most of these problems. Prior to this, you need a pure Perl statement that does this:</source>
          <target state="translated">如果需要来自用户环境的语言环境，则除了 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 之外，不需要XS代码来设置语言环境，因为perl已经设置了它。XS代码应避免更改语言环境，因为它可能会对其他不相关的代码产生不利影响，并且可能不是线程安全的。但是，可能会调用某些外来库来设置它，例如 &lt;code&gt;Gtk&lt;/code&gt; 。这可能会导致perl核心和其他模块出现问题。从v5.20.1开始，从XS 调用函数&lt;a href=&quot;perlapi#sync_locale&quot;&gt;sync_locale（）&lt;/a&gt;应该足以避免大多数此类问题。在此之前，您需要执行以下操作的纯Perl语句：</target>
        </trans-unit>
        <trans-unit id="823e97e3e713d61f96695c0b7d66500ba0535b81" translate="yes" xml:space="preserve">
          <source>If the make process encounters trouble with either compilation or linking then try setting the _C89_CCMODE to 1. Assuming sh is your login shell then run:</source>
          <target state="translated">如果make进程在编译或链接时遇到问题,那么可以尝试将_C89_CCMODE设置为1。假设sh是你的登录shell,然后运行。</target>
        </trans-unit>
        <trans-unit id="2ae0fed8c834da6c72af01b4cce727e6b5ec751e" translate="yes" xml:space="preserve">
          <source>If the module &lt;code&gt;Module&lt;/code&gt; is already loaded, then the declaration</source>
          <target state="translated">如果模块 &lt;code&gt;Module&lt;/code&gt; 已被加载，则声明</target>
        </trans-unit>
        <trans-unit id="1b3cd9a44d834ecaba373518cdced67ef6882e1c" translate="yes" xml:space="preserve">
          <source>If the module &lt;code&gt;Module&lt;/code&gt; is not loaded yet, then the above declaration declares functions func1() and func2() in the current package. When these functions are called, they load the package &lt;code&gt;Module&lt;/code&gt; if needed, and substitute themselves with the correct definitions.</source>
          <target state="translated">如果尚未加载模块 &lt;code&gt;Module&lt;/code&gt; ，则上述声明在当前包中声明函数func1（）和func2（）。调用这些函数时，它们会在需要时加载程序包 &lt;code&gt;Module&lt;/code&gt; ，并用正确的定义替换它们。</target>
        </trans-unit>
        <trans-unit id="aa83e5ba98e2e00acddd7117050d321e4e9d54d9" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, &lt;code&gt;mark_as_loaded&lt;/code&gt; will carp about this and tell you from where the &lt;code&gt;PACKAGE&lt;/code&gt; has been loaded already.</source>
          <target state="translated">如果模块已经加载， &lt;code&gt;mark_as_loaded&lt;/code&gt; 会对此进行提示，并告诉您 &lt;code&gt;PACKAGE&lt;/code&gt; 从何处加载。</target>
        </trans-unit>
        <trans-unit id="e1cec740a866f3242f2245723f611d8e6a35a17e" translate="yes" xml:space="preserve">
          <source>If the module is already unloaded, &lt;code&gt;mark_as_unloaded&lt;/code&gt; will carp about this and tell you the &lt;code&gt;PACKAGE&lt;/code&gt; has been unloaded already.</source>
          <target state="translated">如果模块已经卸载，则 &lt;code&gt;mark_as_unloaded&lt;/code&gt; 会对此进行提示，并告诉您 &lt;code&gt;PACKAGE&lt;/code&gt; 已经卸载。</target>
        </trans-unit>
        <trans-unit id="55dd2ee6ad71be855cc8cea6dc45014e0de598b9" translate="yes" xml:space="preserve">
          <source>If the module is needed inside the</source>
          <target state="translated">如果该模块是需要内部的</target>
        </trans-unit>
        <trans-unit id="fab3a0f11307492451a39d88e9be980974dcb4d2" translate="yes" xml:space="preserve">
          <source>If the module will only be used inside a thread, you can try loading the module from inside the thread entry point function using &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; if needed):</source>
          <target state="translated">如果模块仅在线程内部使用，则可以尝试使用 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 从线程入口点函数内部加载模块（并在需要时 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="cc3b3934908dc77b79dcbb0b789e5b838d36463c" translate="yes" xml:space="preserve">
          <source>If the name is given in UTF-8, set this to &lt;code&gt;HVhek_UTF8&lt;/code&gt; . The value is passed direct as the parameter</source>
          <target state="translated">如果名称以UTF-8给出，请将其设置为 &lt;code&gt;HVhek_UTF8&lt;/code&gt; 。该值直接作为参数传递</target>
        </trans-unit>
        <trans-unit id="31ddfa3306f944720376a989f9d5fd87c400eb47" translate="yes" xml:space="preserve">
          <source>If the name is omitted, format &quot;STDOUT&quot; is defined. A single &quot;.&quot; in column 1 is used to terminate a format. FORMLIST consists of a sequence of lines, each of which may be one of three types:</source>
          <target state="translated">如果省略名称,则定义格式 &quot;STDOUT&quot;。第1列中的一个&quot;.&quot;用于终止一个格式。FORMLIST由一连串的行组成,每行可以是三种类型之一。</target>
        </trans-unit>
        <trans-unit id="0def4cf3757d0553a2341afef733c2c0849f1052" translate="yes" xml:space="preserve">
          <source>If the name is unknown, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned (or an empty list in list context). Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt; &quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt; . This function does not recognize those in the input, returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. Nor are they included in the output as possible synonyms.</source>
          <target state="translated">如果名称未知，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （或列表上下文中的空列表）。请注意，Perl通常在正则表达式中以前缀可选的 &lt;code&gt;&quot;Is_&lt;/code&gt; _&amp;rdquo;（带或不带下划线）的方式识别正则表达式中的属性名称，例如 &lt;code&gt;\p{isgc=punct}&lt;/code&gt; 。此函数无法识别输入中的那些，返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。它们也没有作为可能的同义词包含在输出中。</target>
        </trans-unit>
        <trans-unit id="a79bb3cadb8f975e939ef18071a526a4b5d3363e" translate="yes" xml:space="preserve">
          <source>If the named parameter &lt;code&gt;config_override&lt;/code&gt; is specified, it should be a reference to a hash which contains all information usually found in &lt;code&gt;%Config::Config&lt;/code&gt; . For example, you can obtain the configuration information for a separate perl installation and pass that in.</source>
          <target state="translated">如果指定了命名参数 &lt;code&gt;config_override&lt;/code&gt; ，则它应该是对哈希的引用，该哈希包含通常在 &lt;code&gt;%Config::Config&lt;/code&gt; 找到的所有信息。例如，您可以获取单独的perl安装的配置信息并将其传入。</target>
        </trans-unit>
        <trans-unit id="db3ef5746e8cd5bab310439aa50dba89f545a584" translate="yes" xml:space="preserve">
          <source>If the named parameter &lt;code&gt;skip_cwd&lt;/code&gt; is true, the current directory &lt;code&gt;.&lt;/code&gt; will be stripped from &lt;code&gt;@INC&lt;/code&gt; before searching for .packlists. This keeps ExtUtils::Installed from finding modules installed in other perls that happen to be located below the current directory.</source>
          <target state="translated">如果命名参数 &lt;code&gt;skip_cwd&lt;/code&gt; 为true，则为当前目录 &lt;code&gt;.&lt;/code&gt; 将在搜索.packlists之前从 &lt;code&gt;@INC&lt;/code&gt; 中删除。这样可以避免ExtUtils :: Installed找到其他安装在当前目录下的Perl中的模块。</target>
        </trans-unit>
        <trans-unit id="7f6facbdb87684a56df7a20a0d54e6b8073b8eb9" translate="yes" xml:space="preserve">
          <source>If the new version of the C library is ABI-compatible (that's Application Binary Interface compatible) with the version you're upgrading from, and if the shared library version didn't change, no re-compilation should be necessary.</source>
          <target state="translated">如果新版本的C库与你升级的版本是ABI兼容的(也就是应用二进制接口兼容),而且如果共享库的版本没有改变,就不需要重新编译。</target>
        </trans-unit>
        <trans-unit id="3f6451aaf2bf86188eece8b63b5bab6c7257462f" translate="yes" xml:space="preserve">
          <source>If the next character is in (or extends into) the next chunk of input text, the next chunk will be read in. Normally the current chunk will be discarded at the same time, but if</source>
          <target state="translated">如果下一个字符在下一个输入文本块中(或延伸到下一个文本块中),下一个文本块将被读入。通常,当前的文本块将被同时丢弃,但如果</target>
        </trans-unit>
        <trans-unit id="bf7862ebb65f1805f38240d9ec3614885b02e6ad" translate="yes" xml:space="preserve">
          <source>If the number following the backslash is N (in decimal), and Perl already has seen N capture groups, Perl considers this a backreference. Otherwise, it considers it an octal escape. If N has more than three digits, Perl takes only the first three for the octal escape; the rest are matched as is.</source>
          <target state="translated">如果反斜线后面的数字是N(十进制),并且Perl已经看到了N个捕获组,那么Perl认为这是一个反推。否则,它认为这是一个八进制转义。如果 N 有三个以上的数字,Perl 只取前三个数字作为八进制转义,其余的则按原样匹配。</target>
        </trans-unit>
        <trans-unit id="fad0df49da49393094ec039045da70fce50b5429" translate="yes" xml:space="preserve">
          <source>If the number of data bytes ($bytes) is given, that many data bytes are included in the ping packet sent to the remote host. The number of data bytes is ignored if the protocol is &quot;tcp&quot;. The minimum (and default) number of data bytes is 1 if the protocol is &quot;udp&quot; and 0 otherwise. The maximum number of data bytes that can be specified is 1024.</source>
          <target state="translated">如果给定了数据字节数($bytes),那么发送到远程主机的ping数据包中就会包含这么多数据字节。如果协议是 &quot;tcp&quot;,数据字节数会被忽略。如果协议是 &quot;udp&quot;,数据字节的最小(默认)数是1,否则是0。可以指定的最大数据字节数是1024。</target>
        </trans-unit>
        <trans-unit id="cf726231b3d599cdbe46b108046dbf7815381c4c" translate="yes" xml:space="preserve">
          <source>If the object has been passed to a child process during a fork, the file will be deleted when the object goes out of scope in the parent.</source>
          <target state="translated">如果对象在分叉过程中被传递给了子进程,那么当该对象在父进程中超出范围时,该文件将被删除。</target>
        </trans-unit>
        <trans-unit id="39e52d92c6b313ed3349d0401be82f80d273536a" translate="yes" xml:space="preserve">
          <source>If the only casing for a code point is locale-dependent, then the returned hash will not have any of the base keys, like &lt;code&gt;code&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , etc., but will contain only locale keys.</source>
          <target state="translated">如果代码点的唯一大小写依赖于语言环境，则返回的哈希将不包含任何基本键，如 &lt;code&gt;code&lt;/code&gt; ， &lt;code&gt;upper&lt;/code&gt; 等，而仅包含语言环境键。</target>
        </trans-unit>
        <trans-unit id="addcad10a864d1cffc4846608d394fea1feac09a" translate="yes" xml:space="preserve">
          <source>If the operands to a binary bitwise op are strings of different sizes, &lt;b&gt;|&lt;/b&gt; and &lt;b&gt;^&lt;/b&gt; ops act as though the shorter operand had additional zero bits on the right, while the &lt;b&gt;&amp;amp;&lt;/b&gt; op acts as though the longer operand were truncated to the length of the shorter. The granularity for such extension or truncation is one or more bytes.</source>
          <target state="translated">如果二进制按位运算的操作数是不同大小的字符串，&lt;b&gt;| &lt;/b&gt;和&lt;b&gt;^&lt;/b&gt; ops的作用就像较短的操作数在右侧具有附加的零位，而&lt;b&gt;＆&lt;/b&gt; op的作用就像较长的操作数被截短为较短的操作数。这种扩展或截断的粒度为一个或多个字节。</target>
        </trans-unit>
        <trans-unit id="c7870bd3c024159f240305b7047279e21ad1fe56" translate="yes" xml:space="preserve">
          <source>If the operating system supports it (for example BSD derived systems), the filehandle will be opened with O_EXLOCK (open with exclusive file lock). This can sometimes cause problems if the intention is to pass the filename to another system that expects to take an exclusive lock itself (such as DBD::SQLite) whilst ensuring that the tempfile is not reused. In this situation the &quot;EXLOCK&quot; option can be passed to tempfile. By default EXLOCK will be true (this retains compatibility with earlier releases).</source>
          <target state="translated">如果操作系统支持它(例如BSD衍生系统),文件柄将用O_EXLOCK(用专属文件锁打开)打开。如果打算将文件名传递给另一个期望自己使用独占锁的系统(例如DBD::SQLite),同时确保tempfile不被重复使用,这有时会引起问题。在这种情况下,&quot;EXLOCK &quot;选项可以传递给tempfile。默认情况下,EXLOCK将为true(这保留了与早期版本的兼容性)。</target>
        </trans-unit>
        <trans-unit id="e19b7bb4d69a3c985ce8931960025916d3561c3a" translate="yes" xml:space="preserve">
          <source>If the operation being timed out is system() or qx(), this technique is liable to generate zombies. If this matters to you, you'll need to do your own fork() and exec(), and kill the errant child process.</source>
          <target state="translated">如果被超时的操作是system()或qx(),这种技术就有可能产生僵尸。如果这对你很重要,你需要自己进行fork()和exec(),并杀死错误的子进程。</target>
        </trans-unit>
        <trans-unit id="05f4a71ea34fe9d7ddbd210db5290a2dfa223838" translate="yes" xml:space="preserve">
          <source>If the operation shown is &quot;ToFold&quot;, it means that case-insensitive matching in a regular expression was done on the code point.</source>
          <target state="translated">如果显示的操作是 &quot;ToFold&quot;,说明在代码点上进行了正则表达式的大小写不敏感匹配。</target>
        </trans-unit>
        <trans-unit id="a982ec5add551174c87d54c0c75cad924249147a" translate="yes" xml:space="preserve">
          <source>If the option destination is a reference to a hash, the option will take, as value, strings of the form</source>
          <target state="translated">如果选项的目标是对哈希的引用,那么选项的值将是以下形式的字符串</target>
        </trans-unit>
        <trans-unit id="ab8a370e734c2b7f25ad3475fabaef52fd095ddb" translate="yes" xml:space="preserve">
          <source>If the option is provided, and &lt;code&gt;PERL_PERTURB_KEYS&lt;/code&gt; is NOT set, then a value of '0' implies &lt;code&gt;PERL_PERTURB_KEYS=0&lt;/code&gt; and any other value implies &lt;code&gt;PERL_PERTURB_KEYS=2&lt;/code&gt; .</source>
          <target state="translated">如果提供了该选项，并且 &lt;code&gt;PERL_PERTURB_KEYS&lt;/code&gt; 设置PERL_PERTURB_KEYS，则值'0'表示 &lt;code&gt;PERL_PERTURB_KEYS=0&lt;/code&gt; ,而其他任何值表示 &lt;code&gt;PERL_PERTURB_KEYS=2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb774833de734f7b65efa56e3c7c5f53234542f8" translate="yes" xml:space="preserve">
          <source>If the option is set to false, the output buffer in the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method will be truncated before uncompressed data is written to it.</source>
          <target state="translated">如果该选项设置为false，则在将未压缩的数据写入 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 方法中的输出缓冲区之前，该缓冲区将被截断。</target>
        </trans-unit>
        <trans-unit id="a7e5a140437039036cbeabf084c8f96c887a93f7" translate="yes" xml:space="preserve">
          <source>If the option is set to true, uncompressed data will be appended to the output buffer by the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method.</source>
          <target state="translated">如果该选项设置为true，则将通过 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 方法将未压缩的数据附加到输出缓冲区。</target>
        </trans-unit>
        <trans-unit id="c22c2720bbc793b56d2bdb2031cd852762e79aba" translate="yes" xml:space="preserve">
          <source>If the option is set to true, uncompressed data will be appended to the output buffer in the &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; and &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; methods.</source>
          <target state="translated">如果该选项设置为true，则未压缩的数据将通过 &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; 和 &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; 方法添加到输出缓冲区。</target>
        </trans-unit>
        <trans-unit id="943c28148863687139f9e45e03407da89d7e13fa" translate="yes" xml:space="preserve">
          <source>If the option value is required, Getopt::Long will take the command line argument that follows the option and assign this to the option variable. If, however, the option value is specified as optional, this will only be done if that value does not look like a valid command line option itself.</source>
          <target state="translated">如果选项值是必需的,Getopt::Long 将取选项后面的命令行参数并将其赋值给选项变量。然而,如果选项值被指定为可选的,那么只有当该值本身看起来不像一个有效的命令行选项时,才会这样做。</target>
        </trans-unit>
        <trans-unit id="8b25fc0c82dd37f9c4b9d7996e6e001cd8c1c22e" translate="yes" xml:space="preserve">
          <source>If the order of &lt;code&gt;sv_setiv&lt;/code&gt; and &lt;code&gt;sv_setpv&lt;/code&gt; had been reversed, then the macro &lt;code&gt;SvPOK_on&lt;/code&gt; would need to be called instead of &lt;code&gt;SvIOK_on&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;sv_setiv&lt;/code&gt; 和 &lt;code&gt;sv_setpv&lt;/code&gt; 的顺序已颠倒，则需要调用宏 &lt;code&gt;SvPOK_on&lt;/code&gt; 而不是 &lt;code&gt;SvIOK_on&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b0f391156a0e1896106ec41b93d3c42cc8fd48b" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; already contains a value (typically from a previous eval) that value is reused after appending &lt;code&gt;&quot;\t...propagated&quot;&lt;/code&gt; . This is useful for propagating exceptions:</source>
          <target state="translated">如果输出为空，并且 &lt;code&gt;$@&lt;/code&gt; 已经包含一个值（通常来自先前的eval），则在附加 &lt;code&gt;&quot;\t...propagated&quot;&lt;/code&gt; 之后将重用该值。这对于传播异常很有用：</target>
        </trans-unit>
        <trans-unit id="25d81dad12165191ac2a4d2f3e667fda9ababd8e" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; already contains a value (typically from a previous eval) that value is used after appending &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; to &lt;code&gt;$@&lt;/code&gt; . This is useful for staying almost, but not entirely similar to &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果输出为空，并且 &lt;code&gt;$@&lt;/code&gt; 已经包含一个值（通常来自先前的评估），则在将 &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; 附加到 &lt;code&gt;$@&lt;/code&gt; 之后使用该值。这对于留下几乎但不完全像 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 物体很有用。</target>
        </trans-unit>
        <trans-unit id="65e420bc5858eb45a1dddd4a10cb455bd1ce4cc1" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; already contains a value (typically from a previous eval) that value is used after appending &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; to &lt;code&gt;$@&lt;/code&gt; . This is useful for staying almost, but not entirely similar to &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果输出为空，并且 &lt;code&gt;$@&lt;/code&gt; 已经包含一个值（通常来自先前的评估），则在将 &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; 附加到 &lt;code&gt;$@&lt;/code&gt; 之后使用该值。这对于留下几乎但不完全像 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 物体很有用。</target>
        </trans-unit>
        <trans-unit id="2cfa46357b1516decacabae244126181d8b80b21" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; contains an object reference that has a &lt;code&gt;PROPAGATE&lt;/code&gt; method, that method will be called with additional file and line number parameters. The return value replaces the value in &lt;code&gt;$@&lt;/code&gt; ; i.e., as if &lt;code&gt;$@ = &lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; were called.</source>
          <target state="translated">如果输出为空，并且 &lt;code&gt;$@&lt;/code&gt; 包含具有 &lt;code&gt;PROPAGATE&lt;/code&gt; 方法的对象引用，则将使用其他文件和行号参数调用该方法。返回值替换 &lt;code&gt;$@&lt;/code&gt; 的值；即，好像 &lt;code&gt;$@ = &lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; 被称为。</target>
        </trans-unit>
        <trans-unit id="a97492155e7589378bb301645dfa7c34b680ef04" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; contains an object reference that has a &lt;code&gt;PROPAGATE&lt;/code&gt; method, that method will be called with additional file and line number parameters. The return value replaces the value in &lt;code&gt;$@&lt;/code&gt; ; i.e., as if &lt;code&gt;$@ = &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; were called.</source>
          <target state="translated">如果输出为空，并且 &lt;code&gt;$@&lt;/code&gt; 包含具有 &lt;code&gt;PROPAGATE&lt;/code&gt; 方法的对象引用，则将使用其他文件和行号参数调用该方法。返回值替换 &lt;code&gt;$@&lt;/code&gt; 的值；即，好像 &lt;code&gt;$@ = &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; 被称为。</target>
        </trans-unit>
        <trans-unit id="4e71a254b15b38644afabad82376b2bb1e4f7fab" translate="yes" xml:space="preserve">
          <source>If the output of the &lt;code&gt;h h&lt;/code&gt; command (or any command, for that matter) scrolls past your screen, precede the command with a leading pipe symbol so that it's run through your pager, as in</source>
          <target state="translated">如果 &lt;code&gt;h h&lt;/code&gt; 命令（或其他任何命令）的输出滚动到屏幕之外，请在该命令之前加一个前置的管道符号，以便它在您的寻呼机中运行，如下所示：</target>
        </trans-unit>
        <trans-unit id="f7911c6fed712fb085afb893540153d04c3ba2b2" translate="yes" xml:space="preserve">
          <source>If the package has a mailing list, include a URL or subscription instructions here.</source>
          <target state="translated">如果软件包有邮件列表,请在这里附上URL或订阅说明。</target>
        </trans-unit>
        <trans-unit id="2bd5efd382acc87571dd747451ad45f157dd85d7" translate="yes" xml:space="preserve">
          <source>If the package has a web site, include a URL here.</source>
          <target state="translated">如果软件包有网站,请在这里附上网址。</target>
        </trans-unit>
        <trans-unit id="128d72462f8fdf7586cd07b73dc9169d6e753911" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, &lt;code&gt;U+FFFE&lt;/code&gt; has a minimal primary weight. The comparison between &lt;code&gt;&quot;$a1\x{FFFE}$a2&quot;&lt;/code&gt; and &lt;code&gt;&quot;$b1\x{FFFE}$b2&quot;&lt;/code&gt; first compares &lt;code&gt;$a1&lt;/code&gt; and &lt;code&gt;$b1&lt;/code&gt; at level 1, and then &lt;code&gt;$a2&lt;/code&gt; and &lt;code&gt;$b2&lt;/code&gt; at level 1, as followed.</source>
          <target state="translated">如果该参数为true，则 &lt;code&gt;U+FFFE&lt;/code&gt; 的主权重最小。之间的比较 &lt;code&gt;&quot;$a1\x{FFFE}$a2&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;$b1\x{FFFE}$b2&quot;&lt;/code&gt; 首先比较 &lt;code&gt;$a1&lt;/code&gt; 和 &lt;code&gt;$b1&lt;/code&gt; 在第1级，然后 &lt;code&gt;$a2&lt;/code&gt; 和 &lt;code&gt;$b2&lt;/code&gt; 在第1级，如随后。</target>
        </trans-unit>
        <trans-unit id="c1bc1d540aa212d81d3c27835031fe5adbb0eee1" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, &lt;code&gt;U+FFFF&lt;/code&gt; has a highest primary weight. When a boolean of &lt;code&gt;$coll-&amp;gt;ge($str, &quot;abc&quot;)&lt;/code&gt; and &lt;code&gt;$coll-&amp;gt;le($str, &quot;abc\x{FFFF}&quot;)&lt;/code&gt; is true, it is expected that &lt;code&gt;$str&lt;/code&gt; begins with &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , or another primary equivalent. &lt;code&gt;$str&lt;/code&gt; may be &lt;code&gt;&quot;abcd&quot;&lt;/code&gt; , &lt;code&gt;&quot;abc012&quot;&lt;/code&gt; , but should not include &lt;code&gt;U+FFFF&lt;/code&gt; such as &lt;code&gt;&quot;abc\x{FFFF}xyz&quot;&lt;/code&gt; .</source>
          <target state="translated">如果该参数为true，则 &lt;code&gt;U+FFFF&lt;/code&gt; 具有最高的主权重。当 &lt;code&gt;$coll-&amp;gt;ge($str, &quot;abc&quot;)&lt;/code&gt; 和 &lt;code&gt;$coll-&amp;gt;le($str, &quot;abc\x{FFFF}&quot;)&lt;/code&gt; 的布尔值为true时，则期望 &lt;code&gt;$str&lt;/code&gt; 以 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 开头，或其他主要等效项。 &lt;code&gt;$str&lt;/code&gt; 可以是 &lt;code&gt;&quot;abcd&quot;&lt;/code&gt; ， &lt;code&gt;&quot;abc012&quot;&lt;/code&gt; ，但不应包含 &lt;code&gt;U+FFFF&lt;/code&gt; ,例如 &lt;code&gt;&quot;abc\x{FFFF}xyz&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2379a678967ce11b206cce9256eec402c626744e" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, a final, tie-breaking level is used. If no difference of weights is found after the comparison through all the level specified by &lt;code&gt;level&lt;/code&gt; , the comparison with code points will be performed. For the tie-breaking comparison, the sort key has code points of the original string appended. Completely ignorable characters are not ignored.</source>
          <target state="translated">如果参数为true，则使用最终的平局决胜级别。如果通过所有规定的水平进行比较后发现没有权重的差异 &lt;code&gt;level&lt;/code&gt; ，与代码点的比较将被执行。对于平局比较，排序键附加了原始字符串的代码点。完全可忽略的字符不会被忽略。</target>
        </trans-unit>
        <trans-unit id="e6d70ed0cf4279c5cf91d7d6890341737c51d4df" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, accents (and other primary ignorable characters) are ignored, even though cases are taken into account.</source>
          <target state="translated">如果参数为真,则会忽略重音(和其他主要的可忽略字符),尽管会考虑到大小写。</target>
        </trans-unit>
        <trans-unit id="3ffce08d047eaee75c853cd8ab3be63e13efe5a7" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, for a contraction with three or more characters (here nicknamed &quot;long contraction&quot;), initial substrings will be handled. For example, a contraction ABC, where A is a starter, and B and C are non-starters (character with non-zero combining character class), will be detected even if there is not AB as a contraction.</source>
          <target state="translated">如果该参数为真,对于有3个或更多字符的收缩(这里称为 &quot;长收缩&quot;),将处理初始子串。例如,收缩ABC,其中A是起始字符,B和C是非起始字符(组合字符类别为非零的字符),即使没有AB作为收缩,也会被检测出来。</target>
        </trans-unit>
        <trans-unit id="6196ed90d85a5642d1f2bff307d9850731d3ee76" translate="yes" xml:space="preserve">
          <source>If the parameters to the INCLUDE: keyword are followed by a pipe (&lt;code&gt;|&lt;/code&gt;) then the compiler will interpret the parameters as a command. This feature is mildly deprecated in favour of the &lt;code&gt;INCLUDE_COMMAND:&lt;/code&gt; directive, as documented below.</source>
          <target state="translated">如果INCLUDE：关键字的参数后跟管道（ &lt;code&gt;|&lt;/code&gt; ），则编译器会将这些参数解释为命令。不推荐使用此功能，而推荐使用 &lt;code&gt;INCLUDE_COMMAND:&lt;/code&gt; 指令，如下所述。</target>
        </trans-unit>
        <trans-unit id="60984150a4a273c37051fdd1024089806a686df1" translate="yes" xml:space="preserve">
          <source>If the parent process is killed (either using Perl's kill() builtin, or using some external means) all the pseudo-processes are killed as well, and the whole process exits.</source>
          <target state="translated">如果父进程被杀死(无论是使用Perl的kill()内建函数,还是使用某种外部手段),所有的伪进程也会被杀死,整个进程退出。</target>
        </trans-unit>
        <trans-unit id="aa64f5b5dc3063c1ec88bf3714d6a78f8885563e" translate="yes" xml:space="preserve">
          <source>If the pattern contains embedded code, such as</source>
          <target state="translated">如果该模式包含嵌入式代码,如</target>
        </trans-unit>
        <trans-unit id="400ab285c2500104132be9cd3fcc1a752df8a4f5" translate="yes" xml:space="preserve">
          <source>If the pattern does not match any pathname, then bsd_glob() returns a list consisting of only the pattern. If &lt;code&gt;GLOB_QUOTE&lt;/code&gt; is set, its effect is present in the pattern returned.</source>
          <target state="translated">如果该模式与任何路径名都不匹配，则bsd_glob（）返回仅包含该模式的列表。如果设置了 &lt;code&gt;GLOB_QUOTE&lt;/code&gt; ，则其效果将出现在返回的模式中。</target>
        </trans-unit>
        <trans-unit id="6adde583f90fd2399e3928b4e6217841c09c97fb" translate="yes" xml:space="preserve">
          <source>If the pattern may match only at a handful of places, with &lt;code&gt;TYPE&lt;/code&gt; being &lt;code&gt;SBOL&lt;/code&gt; , &lt;code&gt;MBOL&lt;/code&gt; , or &lt;code&gt;GPOS&lt;/code&gt; . See the table below.</source>
          <target state="translated">如果该模式仅在少数几个地方匹配，且 &lt;code&gt;TYPE&lt;/code&gt; 为 &lt;code&gt;SBOL&lt;/code&gt; ， &lt;code&gt;MBOL&lt;/code&gt; 或 &lt;code&gt;GPOS&lt;/code&gt; 。请参阅下表。</target>
        </trans-unit>
        <trans-unit id="d0ce5cbb841f39a51912df72d9768f6a6a5fae33" translate="yes" xml:space="preserve">
          <source>If the pattern was used as follows</source>
          <target state="translated">如果使用的模式如下</target>
        </trans-unit>
        <trans-unit id="2dd05fadef47c4bd45462fdfaa94e04afc77ad22" translate="yes" xml:space="preserve">
          <source>If the performance in such cases is unacceptable, you may defer the actual writing, and then have it done all at once. The following loop will perform much better for large files:</source>
          <target state="translated">如果这种情况下的性能无法接受,可以推迟实际写入,然后一次性完成。下面的循环对于大文件的性能会好很多。</target>
        </trans-unit>
        <trans-unit id="956656b1b2d0c77e2fbe4d0d92677dc48070a8ed" translate="yes" xml:space="preserve">
          <source>If the platform is MS-DOS like and normally does CRLF to &quot;\n&quot; translation for text files then the default layers are :</source>
          <target state="translated">如果平台是像MS-DOS一样,通常对文本文件进行CRLF到&quot;\n &quot;的翻译,那么默认的层是.NET。</target>
        </trans-unit>
        <trans-unit id="fee788dad0c5b1cd15e2fa5ddb122d4f9bd910af" translate="yes" xml:space="preserve">
          <source>If the platform supports the &lt;code&gt;langinfo(CODESET)&lt;/code&gt; interface, the codeset returned is used as the default encoding for the open pragma.</source>
          <target state="translated">如果平台支持 &lt;code&gt;langinfo(CODESET)&lt;/code&gt; 接口，则返回的代码集将用作打开的编译指示的默认编码。</target>
        </trans-unit>
        <trans-unit id="e029b7bfe44b40ce79cdafd38dd9f57646af8f39" translate="yes" xml:space="preserve">
          <source>If the program exits without all threads having either been joined or detached, then a warning will be issued.</source>
          <target state="translated">如果程序在没有加入或脱离所有线程的情况下就退出,则会发出警告。</target>
        </trans-unit>
        <trans-unit id="68122aab68b9511758161a833aab14bd7cf8f3f4" translate="yes" xml:space="preserve">
          <source>If the program exits without all threads having either been joined or detached, then this warning will be issued.</source>
          <target state="translated">如果程序在没有加入或脱离所有线程的情况下退出,就会发出这个警告。</target>
        </trans-unit>
        <trans-unit id="3f05e0c9adcc7343a41a8d24201ee4c19ce64a54" translate="yes" xml:space="preserve">
          <source>If the program has been given to perl via the switches &lt;code&gt;-e&lt;/code&gt; or &lt;code&gt;-E&lt;/code&gt; , &lt;code&gt;$0&lt;/code&gt; will contain the string &lt;code&gt;&quot;-e&quot;&lt;/code&gt; .</source>
          <target state="translated">如果已通过开关 &lt;code&gt;-e&lt;/code&gt; 或 &lt;code&gt;-E&lt;/code&gt; 将程序提供给perl ，则 &lt;code&gt;$0&lt;/code&gt; 将包含字符串 &lt;code&gt;&quot;-e&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="187d3c3b9917db708f6b4997f1f577493d56ad38" translate="yes" xml:space="preserve">
          <source>If the program is syntactically correct, it is executed. If the program runs off the end without hitting an exit() or die() operator, an implicit &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(0)&lt;/a&gt;&lt;/code&gt; is provided to indicate successful completion.</source>
          <target state="translated">如果程序在语法上正确，则将执行该程序。如果程序运行到最后而没有命中exit（）或die（）运算符，则提供隐式 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(0)&lt;/a&gt;&lt;/code&gt; 表示成功完成。</target>
        </trans-unit>
        <trans-unit id="8cf82d5604429bbfe1cb41298b645fa1f014e9ae" translate="yes" xml:space="preserve">
          <source>If the property doesn't have such a restricted set, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果属性没有这样的限制集，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f736ee647a4d5e1589838b72f5b05af7545714ad" translate="yes" xml:space="preserve">
          <source>If the property name is unknown, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned. Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt; &quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt; . This function does not recognize those in the property parameter, returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果属性名称未知，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。请注意，Perl通常在正则表达式中以前缀可选的 &lt;code&gt;&quot;Is_&lt;/code&gt; _&amp;rdquo;（带或不带下划线）的方式识别正则表达式中的属性名称，例如 &lt;code&gt;\p{isgc=punct}&lt;/code&gt; 。此函数无法识别属性参数中的那些，返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afaf0816b79f3c9b4d1b468e6b1d9a01691cd781" translate="yes" xml:space="preserve">
          <source>If the protocol is set to &quot;tcp&quot;, this method may be called any number of times, and each call to the ping() method (below) will use the most recent $local_addr. If the protocol is &quot;icmp&quot; or &quot;udp&quot;, then bind() must be called at most once per object, and (if it is called at all) must be called before the first call to ping() for that object.</source>
          <target state="translated">如果协议设置为 &quot;tcp&quot;,那么这个方法可以被任意调用多次,每次调用ping()方法(如下)都会使用最近的$local_addr。如果协议是 &quot;icmp &quot;或 &quot;udp&quot;,那么每个对象最多只能调用一次bind(),而且(如果有调用的话)必须在第一次调用该对象的ping()之前调用。</target>
        </trans-unit>
        <trans-unit id="bd278d79ed04376a1ab23bc38f3813d0d8a95858" translate="yes" xml:space="preserve">
          <source>If the prototypes are enabled, you can disable it locally for a given XSUB as in the following example:</source>
          <target state="translated">如果启用了原型,你可以对给定的XSUB在本地禁用它,就像下面的例子一样。</target>
        </trans-unit>
        <trans-unit id="22222d2992db775cc93f4e6df7a745c81e01a6be" translate="yes" xml:space="preserve">
          <source>If the referenced object has been blessed into a package, then that package name is returned instead. But don't use that, as it's now considered &quot;bad practice&quot;. For one reason, an object could be using a class called &lt;code&gt;Regexp&lt;/code&gt; or &lt;code&gt;IO&lt;/code&gt; , or even &lt;code&gt;HASH&lt;/code&gt; . Also, &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; doesn't take into account subclasses, like &lt;code&gt;isa&lt;/code&gt; does.</source>
          <target state="translated">如果所引用的对象已被祝福到一个包中，则将返回该包名称。但是不要使用它，因为它现在被认为是&amp;ldquo;不好的做法&amp;rdquo;。由于一个原因，一个对象可能正在使用称为 &lt;code&gt;Regexp&lt;/code&gt; 或 &lt;code&gt;IO&lt;/code&gt; 甚至 &lt;code&gt;HASH&lt;/code&gt; 的类。同样， &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 不像 &lt;code&gt;isa&lt;/code&gt; 那样考虑子类。</target>
        </trans-unit>
        <trans-unit id="cf268542a8929b7e398cc1536659093d140d5216" translate="yes" xml:space="preserve">
          <source>If the referenced object has been blessed into a package, then that package name is returned instead. But don't use that, as it's now considered &quot;bad practice&quot;. For one reason, an object could be using a class called &lt;code&gt;Regexp&lt;/code&gt; or &lt;code&gt;IO&lt;/code&gt; , or even &lt;code&gt;HASH&lt;/code&gt; . Also, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; doesn't take into account subclasses, like &lt;code&gt;isa&lt;/code&gt; does.</source>
          <target state="translated">如果所引用的对象已被祝福到一个包中，则将返回该包名称。但是不要使用它，因为它现在被认为是&amp;ldquo;不好的做法&amp;rdquo;。由于一个原因，一个对象可能正在使用称为 &lt;code&gt;Regexp&lt;/code&gt; 或 &lt;code&gt;IO&lt;/code&gt; 甚至 &lt;code&gt;HASH&lt;/code&gt; 的类。同样， &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 不像 &lt;code&gt;isa&lt;/code&gt; 那样考虑子类。</target>
        </trans-unit>
        <trans-unit id="09e68bc71ae659a158de263698e821903752a759" translate="yes" xml:space="preserve">
          <source>If the referred library is an archive library, then it is treated as a simple collection of .o modules (all of which must contain PIC). These modules are then linked into the shared library.</source>
          <target state="translated">如果所引用的库是一个档案库,那么它将被视为一个简单的.o模块的集合(所有模块必须包含PIC)。然后将这些模块链接到共享库中。</target>
        </trans-unit>
        <trans-unit id="487c69f3c32cf6208263be856047bd1120b5cb11" translate="yes" xml:space="preserve">
          <source>If the regex engine was entered, the output may look like this:</source>
          <target state="translated">如果输入了regex引擎,输出可能是这样的。</target>
        </trans-unit>
        <trans-unit id="4071da6362bfae97335d6ccd04527e0675ca1ecf" translate="yes" xml:space="preserve">
          <source>If the remote server sends data a byte at time, and you need that data immediately without waiting for a newline (which might not happen), you may wish to replace the &lt;code&gt;while&lt;/code&gt; loop in the parent with the following:</source>
          <target state="translated">如果远程服务器一次发送一个字节的数据，并且您需要立即使用该数据而无需等待换行符（这种情况可能不会发生），则您可能希望用以下内容替换父级中的 &lt;code&gt;while&lt;/code&gt; 循环：</target>
        </trans-unit>
        <trans-unit id="78e886a06c0d6c64ae06980c39f4979b0d06c657" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;*&lt;/code&gt; , the offset is relative to the start of the packed string.</source>
          <target state="translated">如果重复计数为 &lt;code&gt;*&lt;/code&gt; ，则偏移量相对于打包字符串的开头。</target>
        </trans-unit>
        <trans-unit id="71535d2706781140ebf79d95c5c1eb0328f89697" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;0&lt;/code&gt; , it's relative to the current position.</source>
          <target state="translated">如果重复计数为 &lt;code&gt;0&lt;/code&gt; ，则相对于当前位置。</target>
        </trans-unit>
        <trans-unit id="adddd684b7b4b320c5c6cd3d4e144f8d42b00be2" translate="yes" xml:space="preserve">
          <source>If the requested class doesn't yet exist, this function will still succeed, and return &lt;code&gt;[ $classname ]&lt;/code&gt;</source>
          <target state="translated">如果所请求的类尚不存在，则此函数仍将成功，并返回 &lt;code&gt;[ $classname ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3c8df40676c5ef413c4d428cc8bce1edd4a74be" translate="yes" xml:space="preserve">
          <source>If the required version is older than Perl 5.10, the &quot;:default&quot; feature bundle is automatically loaded instead.</source>
          <target state="translated">如果所需的版本比Perl 5.10旧,则会自动加载&quot;:default &quot;功能捆绑包。</target>
        </trans-unit>
        <trans-unit id="d407bfa98e92001cef51aaea080c36419318c881" translate="yes" xml:space="preserve">
          <source>If the result is a fraction, it is converted into a floating point number to the accuracy of your platform.</source>
          <target state="translated">如果结果是分数,就会按照你的平台的精度转换成浮点数。</target>
        </trans-unit>
        <trans-unit id="a0f32bf4dd5015a300ddb6707d47fae5eba9e46c" translate="yes" xml:space="preserve">
          <source>If the result is multiple script names, they are returned joined into a single comma-separated string.</source>
          <target state="translated">如果结果是多个脚本名称,则将它们连接成一个逗号分隔的字符串。</target>
        </trans-unit>
        <trans-unit id="45ec7fbff805996e6714524f94283d541160e6c3" translate="yes" xml:space="preserve">
          <source>If the return type of the XSUB includes &lt;code&gt;static&lt;/code&gt; , the method is considered to be a static method. It will call the C++ function using the class::method() syntax. If the method is not static the function will be called using the THIS-&amp;gt;method() syntax.</source>
          <target state="translated">如果XSUB的返回类型包括 &lt;code&gt;static&lt;/code&gt; ，则该方法被视为静态方法。它将使用class :: method（）语法调用C ++函数。如果该方法不是静态的，则将使用THIS-&amp;gt; method（）语法调用该函数。</target>
        </trans-unit>
        <trans-unit id="95ff7ce638cb043eea1113e455241d4090a0ba15" translate="yes" xml:space="preserve">
          <source>If the return value of reval() is (or contains) any code reference, those code references are wrapped to be themselves executed always in the compartment. See &lt;a href=&quot;#wrap_code_refs_within&quot;&gt;wrap_code_refs_within&lt;/a&gt;.</source>
          <target state="translated">如果reval（）的返回值是（或包含）任何代码引用，则这些代码引用将被包装为始终在隔离专区中执行。参见&lt;a href=&quot;#wrap_code_refs_within&quot;&gt;wrap_code_refs_within&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b5b2e1517f57a24f52793e2d523bf3e3916b624" translate="yes" xml:space="preserve">
          <source>If the revision (previously &quot;tracking version&quot;) number of UCA is given, behavior of that revision is emulated on collating. If omitted, the return value of &lt;code&gt;UCA_Version()&lt;/code&gt; is used.</source>
          <target state="translated">如果给出了UCA的修订版本号（以前称为&amp;ldquo;跟踪版本&amp;rdquo;），则在整理时将模拟该修订版的行为。如果省略，则使用 &lt;code&gt;UCA_Version()&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="1a7a3bfd506eaa3a5969fb39449cbd90048c5cd5" translate="yes" xml:space="preserve">
          <source>If the right argument is an expression rather than a search pattern, substitution, or transliteration, it is interpreted as a search pattern at run time. Note that this means that its contents will be interpolated twice, so</source>
          <target state="translated">如果正确的参数是一个表达式,而不是搜索模式、替换或翻译,那么它在运行时被解释为搜索模式。请注意,这意味着它的内容将被插值两次,所以</target>
        </trans-unit>
        <trans-unit id="397d47eee4fc1ac1405170a336868a5dec199f77" translate="yes" xml:space="preserve">
          <source>If the same C type is used in several different contexts which require different translations, &lt;code&gt;typedef&lt;/code&gt; several new types mapped to this C type, and create separate</source>
          <target state="translated">如果在需要不同翻译的几种不同上下文中使用相同的C类型，请 &lt;code&gt;typedef&lt;/code&gt; 映射到该C类型的几种新类型，并创建单独的</target>
        </trans-unit>
        <trans-unit id="456756c29fcce7da570891f767727aa9e1c8ea70" translate="yes" xml:space="preserve">
          <source>If the same character (or a sequence of characters) exists in the collation element table through &lt;code&gt;table&lt;/code&gt; , mapping to collation elements is overridden. If it does not exist, the mapping is defined additionally.</source>
          <target state="translated">如果通过 &lt;code&gt;table&lt;/code&gt; 到排序规则元素表中存在相同的字符（或字符序列），则覆盖到排序规则元素的映射将被覆盖。如果不存在，则另外定义映射。</target>
        </trans-unit>
        <trans-unit id="250b229660b09d1a93cecb0077c43fdb021bc44f" translate="yes" xml:space="preserve">
          <source>If the scalar contains a number the raw SV will be leaner.</source>
          <target state="translated">如果标量包含一个数字,那么原始的SV就会变瘦。</target>
        </trans-unit>
        <trans-unit id="129cba7aa8d1059953f619ec45963493064daafb" translate="yes" xml:space="preserve">
          <source>If the scalar from the previous example had an extra reference:</source>
          <target state="translated">如果前一个例子中的标量有一个额外的引用。</target>
        </trans-unit>
        <trans-unit id="942a6cfe1787a0e79c2fbf6e9025269b48593e53" translate="yes" xml:space="preserve">
          <source>If the script says that your package is incomplete, and asks whether to continue, just answer with Y (this can only happen if you don't use long filenames or forget to issue &quot;set FNCASE=y&quot; first).</source>
          <target state="translated">如果脚本说你的包不完整,并询问是否要继续,只需回答Y即可(这只可能发生在你没有使用长文件名或忘记先发出 &quot;set FNCASE=y &quot;的情况下)。</target>
        </trans-unit>
        <trans-unit id="1ebc636a0a5f78fe0991b4d30678c7a47413c67b" translate="yes" xml:space="preserve">
          <source>If the second argument to a piped &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; contains shell metacharacters, perl &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;s, then &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;s a shell to decode the metacharacters and eventually run the desired program. If the program couldn't be run, it's the shell that gets the message, not Perl. All your Perl program can find out is whether the shell itself could be successfully started. You can still capture the shell's STDERR and check it for error messages. See &lt;a href=&quot;#How-can-I-capture-STDERR-from-an-external-command%3f&quot;&gt;How can I capture STDERR from an external command?&lt;/a&gt; elsewhere in this document, or use the &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt; module.</source>
          <target state="translated">如果传递给管道的 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 的第二个参数包含shell元字符，perl &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; ，则 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 是shell来解码元字符并最终运行所需的程序。如果无法运行该程序，则是获取消息的外壳程序，而不是Perl。您的Perl程序所能找到的就是shell本身是否可以成功启动。您仍然可以捕获外壳程序的STDERR并检查它是否有错误消息。请参阅&lt;a href=&quot;#How-can-I-capture-STDERR-from-an-external-command%3f&quot;&gt;如何从外部命令捕获STDERR？&lt;/a&gt;或在本文档的其他地方使用&lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="6a485d6980d01df96f56ec659ef159a6f3e30c7c" translate="yes" xml:space="preserve">
          <source>If the second operand has a &quot;nomethod&quot; method then use that.</source>
          <target state="translated">如果第二个操作数有一个 &quot;nomethod &quot;方法,那么就用它。</target>
        </trans-unit>
        <trans-unit id="d89fc930c903cfb2489602dfe78fa395aab16a02" translate="yes" xml:space="preserve">
          <source>If the second parameter (a boolean) is omitted or false, the decomposition is canonical decomposition; if the second parameter (a boolean) is true, the decomposition is compatibility decomposition.</source>
          <target state="translated">如果第二个参数(布尔值)省略或为假,则分解为规范分解;如果第二个参数(布尔值)为真,则分解为兼容性分解。</target>
        </trans-unit>
        <trans-unit id="cdc3a4f8b493e77f4b46b059968dc0b38f7409ec" translate="yes" xml:space="preserve">
          <source>If the selected element is outside the string, the value 0 is returned. If an element off the end of the string is written to, Perl will first extend the string with sufficiently many zero bytes. It is an error to try to write off the beginning of the string (i.e., negative OFFSET).</source>
          <target state="translated">如果选中的元素在字符串之外,则返回值0。如果向字符串末端以外的元素写入,Perl会先用足够多的0字节扩展字符串。如果试图写掉字符串的开头(即负OFFSET),则是一个错误。</target>
        </trans-unit>
        <trans-unit id="08309d3b072967d3ab275a7c77649be9b9f2f474" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will block until such time as the semaphore's count is greater than or equal to the amount you're &lt;code&gt;down&lt;/code&gt; ing the semaphore's count by.</source>
          <target state="translated">如果信号量的计数降至零以下，则此方法将一直阻塞，直到信号量的计数大于或等于您要 &lt;code&gt;down&lt;/code&gt; 信号量计数的量。</target>
        </trans-unit>
        <trans-unit id="49cf6efaba2d8b062462556a6172122cd62a7391" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will return</source>
          <target state="translated">如果semaphore的计数低于零,本方法将返回</target>
        </trans-unit>
        <trans-unit id="feaf413a0792a40fde39688dd7794f1b79d23f9d" translate="yes" xml:space="preserve">
          <source>If the shareable image isn't in any of these places, you'll need to define a logical name</source>
          <target state="translated">如果可共享图片不在这些地方,你需要定义一个逻辑名称。</target>
        </trans-unit>
        <trans-unit id="5d77daa474d5b520bbe270f2db415132f8e51945" translate="yes" xml:space="preserve">
          <source>If the socket is in a connected state, the peer address is returned. If the socket is not in a connected state, undef is returned.</source>
          <target state="translated">如果套接字处于连接状态,则返回对等体地址。如果套接字不在连接状态,则返回undef。</target>
        </trans-unit>
        <trans-unit id="bc839afaf75ab77ac378c573dd37cfe67fada222" translate="yes" xml:space="preserve">
          <source>If the source number can be represented in the target form, that representation is used.</source>
          <target state="translated">如果源号可以用目标形式表示,则使用该表示。</target>
        </trans-unit>
        <trans-unit id="ad2456e62439e41ca828e4d7a559faef86d9a12f" translate="yes" xml:space="preserve">
          <source>If the source number is between two numbers representable in the target form, a representation of one of these numbers is used. (</source>
          <target state="translated">如果源数在两个可以用目标形式表示的数之间,则使用其中一个数的表示。(</target>
        </trans-unit>
        <trans-unit id="5807a3edb0534ce60ac2857df2fbffa4467c6e15" translate="yes" xml:space="preserve">
          <source>If the source number is outside of the limits representable in the target form, a representation of the closest limit is used. (</source>
          <target state="translated">如果源数在目标表格中可表示的限制之外,则使用最接近的限制表示。(</target>
        </trans-unit>
        <trans-unit id="a2b6fc7f507aeb4c29a8733766d6c6136c45fda9" translate="yes" xml:space="preserve">
          <source>If the special input filename &quot;&quot;, &quot;-&quot; or &quot;&amp;lt;&amp;amp;STDIN&quot; is given then the STDIN filehandle is used for input (and no open or close is performed). If no input filename is specified then &quot;-&quot; is implied. Filehandle references, or objects that support the regular IO operations (like &lt;code&gt;&amp;lt;$fh&amp;gt;&lt;/code&gt; or &lt;code&gt;$fh-&amp;lt;Egt&lt;/code&gt;getline&amp;gt;) are also accepted; the handles must already be opened.</source>
          <target state="translated">如果给出了特殊的输入文件名&amp;ldquo;&amp;rdquo;，&amp;ldquo;-&amp;rdquo;或&amp;ldquo; &amp;lt;＆STDIN&amp;rdquo;，那么将使用STDIN文件句柄进行输入（并且不执行打开或关闭操作）。如果未指定输入文件名，则意味着&amp;ldquo;-&amp;rdquo;。也接受文件句柄引用或支持常规IO操作的对象（如 &lt;code&gt;&amp;lt;$fh&amp;gt;&lt;/code&gt; 或 &lt;code&gt;$fh-&amp;lt;Egt&lt;/code&gt; getline&amp;gt;）；手柄必须已经打开。</target>
        </trans-unit>
        <trans-unit id="0ec8f0307ac0cd29be9e31e20412d0003c85f12a" translate="yes" xml:space="preserve">
          <source>If the standard options aren't enough, you may want to subclass Pod::Simple::XHMTL. These are the most likely candidates for methods you'll want to override when subclassing.</source>
          <target state="translated">如果标准的选项还不够,你可能想要子类Pod::Simple::XHMTL。这些是你在子类时最有可能要覆盖的方法。</target>
        </trans-unit>
        <trans-unit id="95c4f5fed91805150d0fb1f5cc265445f3719afe" translate="yes" xml:space="preserve">
          <source>If the string happens to be encoded as UTF-8 internally (and thus has the UTF8 flag set), this is ignored by &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, and it operates on the internal byte string, not the conceptual character string, even if you only have characters with values less than 256.</source>
          <target state="translated">如果字符串恰好在内部被编码为UTF-8（并因此设置了UTF8标志），则 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 会忽略该字符串，并且它将对内部字节字符串（而不是概念性字符串）进行操作，即使您仅使用值小于256。</target>
        </trans-unit>
        <trans-unit id="e46f7dff46b6e909ca2a4c0f1cd989e3474f6367" translate="yes" xml:space="preserve">
          <source>If the string happens to be encoded as UTF-8 internally (and thus has the UTF8 flag set), this is ignored by &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, and it operates on the internal byte string, not the conceptual character string, even if you only have characters with values less than 256.</source>
          <target state="translated">如果字符串恰好在内部被编码为UTF-8（并因此设置了UTF8标志），则 &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 会忽略该字符串，并且它将对内部字节字符串（而不是概念性字符串）进行操作，即使您仅使用值小于256。</target>
        </trans-unit>
        <trans-unit id="556906a3727707516e15ba62fe70b3006b4bd52d" translate="yes" xml:space="preserve">
          <source>If the string is just one character in length, the Unicode numeric value is returned if it has one, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise. Note that this need not be a whole number. &lt;code&gt;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&lt;/code&gt; , for example returns -0.5.</source>
          <target state="translated">如果字符串长度只有一个字符，则返回Unicode数字值（如果包含一个字符），否则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。请注意，这不必是整数。 &lt;code&gt;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&lt;/code&gt; 例如返回-0.5。</target>
        </trans-unit>
        <trans-unit id="3c98175c6574b582a8455429e44a48ac7e74d895" translate="yes" xml:space="preserve">
          <source>If the string is more than one character, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned unless all its characters are decimal digits (that is, they would match &lt;code&gt;\d+&lt;/code&gt; ), from the same script. For example if you have an ASCII '0' and a Bengali '3', mixed together, they aren't considered a valid number, and &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned. A further restriction is that the digits all have to be of the same form. A half-width digit mixed with a full-width one will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. The Arabic script has two sets of digits; &lt;code&gt;num&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; unless all the digits in the string come from the same set.</source>
          <target state="translated">如果字符串不只一个字符，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，除非其所有字符都是十进制数字（即它们将匹配 &lt;code&gt;\d+&lt;/code&gt; ），都来自同一脚本。例如，如果您将ASCII'0'和孟加拉'3'混合在一起，则它们不会被视为有效数字，并返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。进一步的限制是所有数字都必须具有相同的形式。半角数字与全角数字混合将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。阿拉伯文字有两组数字；除非字符串中的所有数字都来自同一组，否则 &lt;code&gt;num&lt;/code&gt; 将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8c4922eb5c062cef768c57176fb78d4965487a5" translate="yes" xml:space="preserve">
          <source>If the subroutine is an XSUB, the elements to be compared are pushed on to the stack, the way arguments are usually passed to XSUBs. $a and $b are not set.</source>
          <target state="translated">如果子程序是XSUB,要比较的元素会被推到堆栈上,就像参数通常被传递给XSUB一样。$a和$b不被设置。</target>
        </trans-unit>
        <trans-unit id="976151f66fa723fd3131374feb62ee8e2fa9f3b7" translate="yes" xml:space="preserve">
          <source>If the subroutine needs to signal an error, it should call die() with the desired error message as its argument. GetOptions() will catch the die(), issue the error message, and record that an error result must be returned upon completion.</source>
          <target state="translated">如果子程序需要发出错误信号,它应该调用die(),并将所需的错误信息作为参数。GetOptions()将捕获die(),发出错误信息,并记录完成后必须返回一个错误结果。</target>
        </trans-unit>
        <trans-unit id="40540ec0b48601a220c70ec78c454bb0e1f51c33" translate="yes" xml:space="preserve">
          <source>If the subroutine returns a scalar with a newline or a filehandle, it will be interpreted as raw TAP or as a TAP stream, respectively.</source>
          <target state="translated">如果子程序返回一个带换行的标量或filehandle,它将分别被解释为原始TAP或TAP流。</target>
        </trans-unit>
        <trans-unit id="ca613cca9ddf94b18fd3a6da5979f02e2a0a3fcf" translate="yes" xml:space="preserve">
          <source>If the subroutine's prototype is &lt;code&gt;($$)&lt;/code&gt; , the elements to be compared are passed by reference in &lt;code&gt;@_&lt;/code&gt; , as for a normal subroutine. This is slower than unprototyped subroutines, where the elements to be compared are passed into the subroutine as the package global variables $a and $b (see example below). Note that in the latter case, it is usually highly counter-productive to declare $a and $b as lexicals.</source>
          <target state="translated">如果子例程的原型是 &lt;code&gt;($$)&lt;/code&gt; ， &lt;code&gt;@_&lt;/code&gt; 进行比较的元素将通过@_引用传递，就像普通子例程一样。这比未原型的子例程要慢，在该例程中要比较的元素作为包全局变量$ a和$ b传递到子例程中（请参见下面的示例）。请注意，在后一种情况下，将$ a和$ b声明为词汇通常会适得其反。</target>
        </trans-unit>
        <trans-unit id="1b8a697c5090fd8ce94c13b5cefb41955f99b010" translate="yes" xml:space="preserve">
          <source>If the sv already is UTF-8 (or if it is not POK), or if the encoding is not a reference, nothing is done to the sv. If the encoding is not an &lt;code&gt;Encode::XS&lt;/code&gt; Encoding object, bad things will happen. (See</source>
          <target state="translated">如果sv已经是UTF-8（或者不是POK），或者编码不是参考，则不会对该sv执行任何操作。如果编码不是 &lt;code&gt;Encode::XS&lt;/code&gt; 编码对象，则会发生不良情况。（看到</target>
        </trans-unit>
        <trans-unit id="25e6d11786b2dfdb0f52678b6850a3dff8731c46" translate="yes" xml:space="preserve">
          <source>If the sv is the target of a weak reference then it returns the back references structure associated with the sv; otherwise return NULL.</source>
          <target state="translated">如果sv是弱引用的目标,那么它将返回与sv相关联的后引用结构;否则返回NULL。</target>
        </trans-unit>
        <trans-unit id="82b0821b14cc4cbb805ab8ac00aa5900da22e409" translate="yes" xml:space="preserve">
          <source>If the symbol &lt;code&gt;:void&lt;/code&gt; appears in the import list, then functions named later in that import list raise an exception only when these are called in void context--that is, when their return values are ignored. For example</source>
          <target state="translated">如果符号 &lt;code&gt;:void&lt;/code&gt; 出现在导入列表中，则稍后在该导入列表中命名的函数仅在void上下文中调用时（即，其返回值被忽略时）才会引发异常。例如</target>
        </trans-unit>
        <trans-unit id="50cf7df5061941de64a11ddf12781ae7a8f3290f" translate="yes" xml:space="preserve">
          <source>If the system Perl is compiled in has thread-safe variants of such calls, they will be used. Beyond that, Perl is at the mercy of the thread-safety or -unsafety of the calls. Please consult your C library call documentation.</source>
          <target state="translated">如果 Perl 编译的系统有这种调用的线程安全变体,就会使用它们。除此以外,Perl 将会受到这些调用的线程安全或不安全的影响。请参考你的 C 库调用文档。</target>
        </trans-unit>
        <trans-unit id="d5b1234bec481f7f0fb540471e8867994b10762a" translate="yes" xml:space="preserve">
          <source>If the target machine is little-endian, we could write:</source>
          <target state="translated">如果目标机是小字型,我们可以写。</target>
        </trans-unit>
        <trans-unit id="ff635540edd5aea28a885e06a80c5c6844ba7c11" translate="yes" xml:space="preserve">
          <source>If the template is not specified, a template is always automatically generated. This temporary file is placed in tmpdir() (L&amp;lt;:spec&amp;gt;) unless a directory is specified explicitly with the DIR option.</source>
          <target state="translated">如果未指定模板，则始终自动生成模板。除非使用DIR选项明确指定目录，否则此临时文件将放置在tmpdir（）（L &amp;lt;：spec&amp;gt;）中。</target>
        </trans-unit>
        <trans-unit id="593ec0746d963b28de5ba2cf0799b3f4777c63c7" translate="yes" xml:space="preserve">
          <source>If the temporary file can not be created undef is returned. Currently this command will probably not work when the temporary directory is on an NFS file system.</source>
          <target state="translated">如果不能创建临时文件,则返回undef。目前,当临时目录在NFS文件系统上时,该命令可能无法使用。</target>
        </trans-unit>
        <trans-unit id="326e7cf804954bda3811121b38cb7c631e7575fe" translate="yes" xml:space="preserve">
          <source>If the terminating string is quoted, the type of quotes used determine the treatment of the text.</source>
          <target state="translated">如果终止字符串被引用,使用的引号类型决定了文本的处理方式。</target>
        </trans-unit>
        <trans-unit id="957eb5ae659823f7ba1c0183ec0ac873de8b4109" translate="yes" xml:space="preserve">
          <source>If the test is unplanned, this method will always return false. See &lt;code&gt;is_unplanned&lt;/code&gt; .</source>
          <target state="translated">如果计划外的测试，则此方法将始终返回false。参见 &lt;code&gt;is_unplanned&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bfabe273698ccd033cf292d0d277e005ca02c57" translate="yes" xml:space="preserve">
          <source>If the tests fail &lt;code&gt;prove&lt;/code&gt; will exit with non-zero status.</source>
          <target state="translated">如果测试失败，则 &lt;code&gt;prove&lt;/code&gt; 将以非零状态退出。</target>
        </trans-unit>
        <trans-unit id="269c79628ff3b9a7faad565d0d36f6d320d9b282" translate="yes" xml:space="preserve">
          <source>If the text of the L&amp;lt;&amp;gt; escape is entirely enclosed in double quotes, it's interpreted as a link to a section for backward compatibility.</source>
          <target state="translated">如果L &amp;lt;&amp;gt;转义符的文本完全用双引号引起来，则将其解释为指向节的链接，以实现向后兼容。</target>
        </trans-unit>
        <trans-unit id="f92e03b607dab58b8f2f2e3c224ccb0a3fc3ca6c" translate="yes" xml:space="preserve">
          <source>If the text of the error message starts with an exclamation mark &lt;code&gt;!&lt;/code&gt; it is interpreted specially by GetOptions(). There is currently one special command implemented: &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die(&quot;!FINISH&quot;)&lt;/a&gt;&lt;/code&gt; will cause GetOptions() to stop processing options, as if it encountered a double dash &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">如果错误消息的文本以感叹号开头 &lt;code&gt;!&lt;/code&gt; 它由GetOptions（）专门解释。当前实现了一个特殊命令： &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die(&quot;!FINISH&quot;)&lt;/a&gt;&lt;/code&gt; 将导致GetOptions（）停止处理选项，就像遇到了双破折号 &lt;code&gt;--&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54a21a0dcb36b1ce3d43912ccebce5a460b97864" translate="yes" xml:space="preserve">
          <source>If the third argument is</source>
          <target state="translated">如果第三个参数是</target>
        </trans-unit>
        <trans-unit id="b232866b6ad063c73d4ad37ea476edb565d6de63" translate="yes" xml:space="preserve">
          <source>If the third argument,</source>
          <target state="translated">如果第三个论点。</target>
        </trans-unit>
        <trans-unit id="66bf0740d3ced4e3ce4166e93bb8bdf81549240a" translate="yes" xml:space="preserve">
          <source>If the thread being &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;ed &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;d, the error it died with will be returned at this time. If you don't want the thread performing the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; to die as well, you should either wrap the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or use the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; thread method instead of &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果线程之中 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 编 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; d，它与死去的错误会在这个时候被退回。如果您不希望执行 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 的线程也消失，则应该将 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 包装在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中,或者使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; thread方法而不是 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3cd970acc5e28ee89d2e82334dde273c65bae5b7" translate="yes" xml:space="preserve">
          <source>If the title can't be found, then get_short_title returns empty-string (&quot;&quot;).</source>
          <target state="translated">如果找不到标题,那么get_short_title返回空字符串(&quot;&quot;)。</target>
        </trans-unit>
        <trans-unit id="697a489e14d5b870ec5510bd4b458c67ab45bad8" translate="yes" xml:space="preserve">
          <source>If the typeglob &lt;code&gt;gv&lt;/code&gt; can be expressed more succinctly, by having something other than a real GV in its place in the stash, replace it with the optimised form. Basic requirements for this are that &lt;code&gt;gv&lt;/code&gt; is a real typeglob, is sufficiently ordinary, and is only referenced from its package. This function is meant to be used when a GV has been looked up in part to see what was there, causing upgrading, but based on what was found it turns out that the real GV isn't required after all.</source>
          <target state="translated">如果可以通过在存储区中放置除真实GV之外的其他内容来更简洁地表示typeglob &lt;code&gt;gv&lt;/code&gt; ，请用优化形式替换它。对此的基本要求是 &lt;code&gt;gv&lt;/code&gt; 是一个实类型的glob，足够普通，并且只能从其包中引用。当部分地查看GV以查看其中存在的内容并导致升级时，可以使用此功能，但是基于找到的结果，事实证明根本不需要真正的GV。</target>
        </trans-unit>
        <trans-unit id="7e317e256420ab2a48b2f7e7b312c3d9f416e521" translate="yes" xml:space="preserve">
          <source>If the underlying &lt;code&gt;IO::Handle&lt;/code&gt; is closed, or if there are any read or write failures, the file handle will be forced closed, and &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Connection closed&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt; ). The _set_status_closed() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="translated">如果底层的 &lt;code&gt;IO::Handle&lt;/code&gt; 已关闭，或者存在任何读取或写入失败，则将强制关闭文件句柄，并且 &lt;code&gt;code()&lt;/code&gt; 将返回&amp;ldquo; 421&amp;rdquo;（临时连接失败），而 &lt;code&gt;message()&lt;/code&gt; 将返回&amp;ldquo; [ $ pkg]&amp;ldquo;连接已关闭&amp;rdquo;（其中$ pkg是 &lt;code&gt;Net::Cmd&lt;/code&gt; 子类的名称）。可以重写_set_status_closed（）方法以设置其他消息（通过调用set_status（）），否则可以捕获此错误。</target>
        </trans-unit>
        <trans-unit id="cdc3b2cf894256f273b0349af8d5d688d0cdcb39" translate="yes" xml:space="preserve">
          <source>If the user builds a shared</source>
          <target state="translated">如果用户建立了一个共享</target>
        </trans-unit>
        <trans-unit id="32324af5745fb70c85007da7a27faa556a189cfd" translate="yes" xml:space="preserve">
          <source>If the user didn't specify anything, it's interpreted as having used the &lt;code&gt;please&lt;/code&gt; tag. It's up to you to make this useful.</source>
          <target state="translated">如果用户未指定任何内容，则解释为使用了 &lt;code&gt;please&lt;/code&gt; 标签。有用的取决于您。</target>
        </trans-unit>
        <trans-unit id="cd074d1ec9315994a5770ffd227be188d8ea3674" translate="yes" xml:space="preserve">
          <source>If the user does not have HTML::Lint installed, the whole block of code</source>
          <target state="translated">如果用户没有安装HTML::Lint,则整个代码块会在</target>
        </trans-unit>
        <trans-unit id="b39c8811f479889c6eabed43038bf7a333557852" translate="yes" xml:space="preserve">
          <source>If the user has superuser privileges, and is not working on AFS or relatives, then the defaults for INSTALLPRIVLIB, INSTALLARCHLIB, INSTALLSCRIPT, etc. will be appropriate, and this incantation will be the best:</source>
          <target state="translated">如果用户有超级用户权限,而且不是在AFS或亲属上工作,那么INSTALLPRIVLIB、INSTALLARCHLIB、INSTALLSCRIPT等默认值就合适了,这个咒语最好。</target>
        </trans-unit>
        <trans-unit id="3d9745c4616cab220c27715466f7a222d8b72268" translate="yes" xml:space="preserve">
          <source>If the value</source>
          <target state="translated">如果该值</target>
        </trans-unit>
        <trans-unit id="1676523b419ae746e43ad6553d2687aea42c504e" translate="yes" xml:space="preserve">
          <source>If the value doesn't match the 'make' program you want to use, edit Config.pm to fix it.</source>
          <target state="translated">如果该值与你要使用的'make'程序不匹配,请编辑Config.pm来修正它。</target>
        </trans-unit>
        <trans-unit id="9aa86f4743abc7079a416abc9073771271ff4394" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; it is returned as a UV, the output flags are clear, and nothing is written to</source>
          <target state="translated">如果该值&amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; ,则将其作为UV返回，清除输出标志，并且不写入任何内容</target>
        </trans-unit>
        <trans-unit id="bd15952acdcd265d4f18a816b3be548c37a82d83" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= UV_MAX it is returned as a UV, the output flags are clear, and nothing is written to</source>
          <target state="translated">如果该值&amp;lt;= UV_MAX，则将其作为UV返回，清除输出标志，并且不写入任何内容</target>
        </trans-unit>
        <trans-unit id="c10d8690679793d91d603d7249997075229bffed" translate="yes" xml:space="preserve">
          <source>If the value is a coderef, we return &amp;amp;$value($lh, ...parameters...).</source>
          <target state="translated">如果该值是一个代码引用，则返回＆$ value（$ lh，... parameters ...）。</target>
        </trans-unit>
        <trans-unit id="ef50a320b2209faad43a3f8213d92ea4b618e424" translate="yes" xml:space="preserve">
          <source>If the value is a scalarref, the scalar is dereferenced and returned (and any parameters are ignored).</source>
          <target state="translated">如果值是一个标量ref,则标量会被取消引用并返回(并且忽略任何参数)。</target>
        </trans-unit>
        <trans-unit id="6f950a468109b8d39520112d3f58effdc56407fc" translate="yes" xml:space="preserve">
          <source>If the value is a string that</source>
          <target state="translated">如果值是一个字符串,那么</target>
        </trans-unit>
        <trans-unit id="034aa5dfb1d3fc388ace8815e3c3af316b7fe0f0" translate="yes" xml:space="preserve">
          <source>If the value is true, then the appropriate pragma is assumed to be in the ambient scope, otherwise not.</source>
          <target state="translated">如果该值为真,则假定相应的pragma在环境范围内,否则不在。</target>
        </trans-unit>
        <trans-unit id="c4b0ded1a1deef22b5fab46f3c6efeda2921b5b8" translate="yes" xml:space="preserve">
          <source>If the value of</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="3799e4ea2da2d340ca2beed8a5872250c216eb41" translate="yes" xml:space="preserve">
          <source>If the value of the number can fit in a UV, it is returned in the *valuep IS_NUMBER_IN_UV will be set to indicate that *valuep is valid, IS_NUMBER_IN_UV will never be set unless *valuep is valid, but *valuep may have been assigned to during processing even though IS_NUMBER_IN_UV is not set on return. If valuep is NULL, IS_NUMBER_IN_UV will be set for the same cases as when valuep is non-NULL, but no actual assignment (or SEGV) will occur.</source>
          <target state="translated">如果数字的值可以容纳在一个UV中,则在*valuep中返回IS_NUMBER_IN_UV将被设置为表示*valuep是有效的,除非*valuep是有效的,否则IS_NUMBER_IN_UV将永远不会被设置,但*valuep可能在处理过程中被分配到,即使IS_NUMBER_IN_UV在返回时没有被设置。如果valuep为NULL,IS_NUMBER_IN_UV将被设置,与valuep为非NULL时的情况相同,但不会发生实际的分配(或SEGV)。</target>
        </trans-unit>
        <trans-unit id="d417792987cefdc8fbbad820c7047930346b40c5" translate="yes" xml:space="preserve">
          <source>If the value to pack is too long, the result is truncated. If it's too long and an explicit count is provided, &lt;code&gt;Z&lt;/code&gt; packs only &lt;code&gt;$count-1&lt;/code&gt; bytes, followed by a null byte. Thus &lt;code&gt;Z&lt;/code&gt; always packs a trailing null, except when the count is 0.</source>
          <target state="translated">如果要打包的值太长，结果将被截断。如果太长并且提供了显式计数，则 &lt;code&gt;Z&lt;/code&gt; 仅打包 &lt;code&gt;$count-1&lt;/code&gt; 个字节，后跟一个空字节。因此，除非计数为0，否则 &lt;code&gt;Z&lt;/code&gt; 总是打包结尾的null。</target>
        </trans-unit>
        <trans-unit id="2b18faee7915986e7efaa1de04f931c2b8c71f1c" translate="yes" xml:space="preserve">
          <source>If the values are all small integers, you could use a simple indexed array. This kind of an array will take up less space:</source>
          <target state="translated">如果值都是小整数,你可以使用一个简单的索引数组。这种数组会占用较少的空间。</target>
        </trans-unit>
        <trans-unit id="5cc9e16e91b4a8896cd9faaa5f9549cbc7085c8f" translate="yes" xml:space="preserve">
          <source>If the values in question are integers instead of strings, you can save quite a lot of space by using bit strings instead:</source>
          <target state="translated">如果所涉及的值是整数而不是字符串,你可以通过使用比特字符串来节省不少空间。</target>
        </trans-unit>
        <trans-unit id="73e7da39372f108fea1077e432f6f8a5490ef1c9" translate="yes" xml:space="preserve">
          <source>If the variable is locked by another thread, the &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; call will block until it's available. &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; is recursive, so multiple calls to &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; are safe--the variable will remain locked until the outermost lock on the variable goes out of scope.</source>
          <target state="translated">如果变量被另一个线程锁定，则 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 调用将阻塞，直到可用为止。 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 是递归的，因此多次调用 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 是安全的-变量将保持锁定状态，直到变量的最外面的锁超出范围为止。</target>
        </trans-unit>
        <trans-unit id="82a274850c71686d34e3baa803737f0dedda24d3" translate="yes" xml:space="preserve">
          <source>If the variable is not set, or if the head of space-separated list is empty, the best available package is loaded.</source>
          <target state="translated">如果变量没有设置,或者空格分隔的列表头为空,则加载最佳的可用包。</target>
        </trans-unit>
        <trans-unit id="80b83d018cb7a8db8be65fb54c56d8b5b7e8cb24" translate="yes" xml:space="preserve">
          <source>If the warnings category, &lt;code&gt;$category&lt;/code&gt; , has been set to &quot;FATAL&quot; in the calling module then die. Otherwise return.</source>
          <target state="translated">如果在调用模块中将警告类别 &lt;code&gt;$category&lt;/code&gt; 设置为&amp;ldquo; FATAL&amp;rdquo;，则死机。否则返回。</target>
        </trans-unit>
        <trans-unit id="9de09cf9a89a26f0cb448619847689ec2527d3db" translate="yes" xml:space="preserve">
          <source>If the whole program is Unicode (signified by using 8-bit &lt;b&gt;U&lt;/b&gt;nicode &lt;b&gt;T&lt;/b&gt;ransformation &lt;b&gt;F&lt;/b&gt;ormat), then all strings within it must be Unicode.</source>
          <target state="translated">如果整个程序是Unicode（通过使用8位所指&lt;b&gt;&amp;ugrave;&lt;/b&gt; nicode &lt;b&gt;Ť&lt;/b&gt; ransformation &lt;b&gt;˚F&lt;/b&gt; ORMAT），然后在其内的所有字符串必须是Unicode。</target>
        </trans-unit>
        <trans-unit id="9cdf7f58b72ea89ccbb496e2eb6b9b4bc7fadaa5" translate="yes" xml:space="preserve">
          <source>If the word &lt;code&gt;while&lt;/code&gt; is replaced by the word &lt;code&gt;until&lt;/code&gt; , the sense of the test is reversed, but the conditional is still tested before the first iteration.</source>
          <target state="translated">如果将 &lt;code&gt;while&lt;/code&gt; 单词替换为 &lt;code&gt;until&lt;/code&gt; 单词，则测试的意义相反，但是在第一次迭代之前仍对条件语句进行测试。</target>
        </trans-unit>
        <trans-unit id="10166029e96e7fe67231308fbe3c16515584c847" translate="yes" xml:space="preserve">
          <source>If there are additional casing rules that apply only in certain locales, an additional key for each will be defined in the returned hash. Each such key will be its locale name, defined as a 2-letter ISO 3166 country code, possibly followed by a &quot;_&quot; and a 2-letter ISO language code (possibly followed by a &quot;_&quot; and a variant code). You can find the lists of all possible locales, see &lt;a href=&quot;../locale/country&quot;&gt;Locale::Country&lt;/a&gt; and &lt;a href=&quot;../locale/language&quot;&gt;Locale::Language&lt;/a&gt;. (In Unicode 6.0, the only locales returned by this function are &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;az&lt;/code&gt; .)</source>
          <target state="translated">如果还有其他仅适用于特定语言环境的大小写规则，则将在返回的哈希中定义每个规则的其他键。每个这样的键都是其区域名称，定义为2个字母的ISO 3166国家/地区代码，可能后跟一个&amp;ldquo; _&amp;rdquo;和一个2个字母的ISO语言代码（可能后跟一个&amp;ldquo; _&amp;rdquo;和一个变体代码）。您可以找到所有可能的语言环境的列表，请参见&lt;a href=&quot;../locale/country&quot;&gt;Locale :: Country&lt;/a&gt;和&lt;a href=&quot;../locale/language&quot;&gt;Locale :: Language&lt;/a&gt;。 （在Unicode 6.0中，此函数返回的唯一语言环境是 &lt;code&gt;lt&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;az&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="c264a98231858c182cc8e558543c798b7c30e957" translate="yes" xml:space="preserve">
          <source>If there are more pack codes or if the repeat count of a field or a group is larger than what the remainder of the input string allows, the result is not well defined: the repeat count may be decreased, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; may produce empty strings or zeros, or it may raise an exception. If the input string is longer than one described by the TEMPLATE, the remainder of that input string is ignored.</source>
          <target state="translated">如果有更多的打包代码，或者字段或组的重复计数大于输入字符串的其余部分所允许的数量，则结果定义不明确：重复计数可能会减少，或者 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 可能会产生空字符串或零，否则可能会引发异常。如果输入字符串长于TEMPLATE描述的字符串，则该输入字符串的其余部分将被忽略。</target>
        </trans-unit>
        <trans-unit id="b76f7ceb246d4c2d7fabcbfce30f4b0cda04fc65" translate="yes" xml:space="preserve">
          <source>If there are more pack codes or if the repeat count of a field or a group is larger than what the remainder of the input string allows, the result is not well defined: the repeat count may be decreased, or &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; may produce empty strings or zeros, or it may raise an exception. If the input string is longer than one described by the TEMPLATE, the remainder of that input string is ignored.</source>
          <target state="translated">如果有更多的打包代码，或者字段或组的重复计数大于输入字符串的其余部分所允许的数量，则结果定义不明确：重复计数可能会减少，或者 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 可能会产生空字符串或零，否则可能会引发异常。如果输入字符串长于TEMPLATE描述的字符串，则该输入字符串的其余部分将被忽略。</target>
        </trans-unit>
        <trans-unit id="cf8ae3d8fd9e42e9aba417d2727a1cef25f1654d" translate="yes" xml:space="preserve">
          <source>If there are multiple threads running, &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on a filehandle from a piped open returns true without waiting for the child process to terminate, if the filehandle is still open in another thread.</source>
          <target state="translated">如果有多个线程运行， &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 上一个文件句柄从管道开放的回报，而无需等待子进程终止，如果文件句柄仍然在另一个线程中打开真。</target>
        </trans-unit>
        <trans-unit id="2d703ea78c6bd312ccc4d4536374984caf742a2c" translate="yes" xml:space="preserve">
          <source>If there are multiple threads running, &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on a filehandle from a piped open returns true without waiting for the child process to terminate, if the filehandle is still open in another thread.</source>
          <target state="translated">如果有多个线程运行， &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 上一个文件句柄从管道开放的回报，而无需等待子进程终止，如果文件句柄仍然在另一个线程中打开真。</target>
        </trans-unit>
        <trans-unit id="c3ca3b8e4b7d3fd6327a3431ba332cb4654544b7" translate="yes" xml:space="preserve">
          <source>If there are no case mappings for the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;, or if all three possible mappings (</source>
          <target state="translated">如果&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数&lt;/a&gt;没有大小写映射，或者所有三个可能的映射（</target>
        </trans-unit>
        <trans-unit id="4d288bab40c0346d55a3c0eb77940eab7a6641ad" translate="yes" xml:space="preserve">
          <source>If there are no shell metacharacters in the argument of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, Perl runs the command directly, without using the shell, and can correctly report whether the command started.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 的参数中没有外壳元字符，则Perl无需使用外壳即可直接运行命令，并且可以正确报告命令是否已启动。</target>
        </trans-unit>
        <trans-unit id="83b3c9dc933e2482f8eba281e591135e3899389e" translate="yes" xml:space="preserve">
          <source>If there are no threads blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the variable, the signal is discarded.</source>
          <target state="translated">如果在变量的 &lt;code&gt;cond_wait&lt;/code&gt; 中没有线程被阻塞，则信号被丢弃。</target>
        </trans-unit>
        <trans-unit id="dcf5c5ee7e0424ea7ada5c7826f4b90fdb2a116c" translate="yes" xml:space="preserve">
          <source>If there are no threads blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the variable, the signal is discarded. By always locking before signaling, you can (with care), avoid signaling before another thread has entered cond_wait().</source>
          <target state="translated">如果在变量的 &lt;code&gt;cond_wait&lt;/code&gt; 中没有线程被阻塞，则信号被丢弃。通过始终在发信号之前锁定，您可以（小心）避免在另一个线程进入cond_wait（）之前发信号。</target>
        </trans-unit>
        <trans-unit id="a5de19948908467a5a983001d47b7d9a0689b746" translate="yes" xml:space="preserve">
          <source>If there are no valid digits between the braces, the generated character is the NULL character (&lt;code&gt;\x{00}&lt;/code&gt; ). However, an explicit empty brace (&lt;code&gt;\x{}&lt;/code&gt; ) will not cause a warning (currently).</source>
          <target state="translated">如果括号之间没有有效数字，则生成的字符为NULL字符（ &lt;code&gt;\x{00}&lt;/code&gt; ）。但是，显式的空括号（ &lt;code&gt;\x{}&lt;/code&gt; ）不会引起警告（当前）。</target>
        </trans-unit>
        <trans-unit id="b342c6d59112da790e47e12118a22cde8dbcaf22" translate="yes" xml:space="preserve">
          <source>If there are only a few field hashes to declare, it is simplest to</source>
          <target state="translated">如果只有几个字段哈希要声明,最简单的方法就是</target>
        </trans-unit>
        <trans-unit id="ae8e9a2c571cd018342d9c2118caec048fd77da4" translate="yes" xml:space="preserve">
          <source>If there are only three arguments and the third argument is a hash reference, the keys of that hash can have values &lt;code&gt;dict&lt;/code&gt; , &lt;code&gt;fold&lt;/code&gt; , and &lt;code&gt;comp&lt;/code&gt; or &lt;code&gt;xfrm&lt;/code&gt; (see below), and their corresponding values will be used as the parameters.</source>
          <target state="translated">如果只有三个参数，而第三个参数是哈希引用，则该哈希的键可以具有值 &lt;code&gt;dict&lt;/code&gt; ， &lt;code&gt;fold&lt;/code&gt; 和 &lt;code&gt;comp&lt;/code&gt; 或 &lt;code&gt;xfrm&lt;/code&gt; （请参见下文），并将它们的相应值用作参数。</target>
        </trans-unit>
        <trans-unit id="1e86b013905dd12651149e8ec83c3ae6cf6c6b73" translate="yes" xml:space="preserve">
          <source>If there are two modules using &lt;code&gt;FindBin&lt;/code&gt; from different directories under the same interpreter, this won't work. Since &lt;code&gt;FindBin&lt;/code&gt; uses a &lt;code&gt;BEGIN&lt;/code&gt; block, it'll be executed only once, and only the first caller will get it right. This is a problem under mod_perl and other persistent Perl environments, where you shouldn't use this module. Which also means that you should avoid using &lt;code&gt;FindBin&lt;/code&gt; in modules that you plan to put on CPAN. To make sure that &lt;code&gt;FindBin&lt;/code&gt; will work is to call the &lt;code&gt;again&lt;/code&gt; function:</source>
          <target state="translated">如果有两个模块在同一解释器下的不同目录中使用 &lt;code&gt;FindBin&lt;/code&gt; ，则此方法将无效。由于 &lt;code&gt;FindBin&lt;/code&gt; 使用 &lt;code&gt;BEGIN&lt;/code&gt; 块，因此它将仅执行一次，并且只有第一个调用者才能正确执行。在mod_perl和其他持久性Perl环境下，这是一个问题，在这些环境下您不应该使用此模块。这也意味着您应该避免在计划放入CPAN的模块中使用 &lt;code&gt;FindBin&lt;/code&gt; 。要确保 &lt;code&gt;FindBin&lt;/code&gt; 可以正常运行，请调用 &lt;code&gt;again&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="fcc3c3e2760c5e396f33222005be848fc9fe18e0" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK, it is always executed just before the conditional is about to be evaluated again. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">如果存在 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，则总是在即将再次评估条件之前执行它。因此，即使通过 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 一条语句继续执行循环，也可以使用它来增加循环变量。</target>
        </trans-unit>
        <trans-unit id="8b36be5061281671022cf399b379651681b1d4d0" translate="yes" xml:space="preserve">
          <source>If there is a case folding for that code point, a reference to a hash with the following fields is returned:</source>
          <target state="translated">如果该码点有大小写折叠,则返回一个包含以下字段的哈希引用。</target>
        </trans-unit>
        <trans-unit id="6424bf8b1f44f30e366f5038ca9bafadec447990" translate="yes" xml:space="preserve">
          <source>If there is a read or write timeout &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Timeout&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt; ). The _set_status_timeout() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="translated">如果存在读取或写入超时，则 &lt;code&gt;code()&lt;/code&gt; 将返回&amp;ldquo; 421&amp;rdquo;（临时连接失败），而 &lt;code&gt;message()&lt;/code&gt; 将返回&amp;ldquo; [$ pkg] Timeout&amp;rdquo;（其中$ pkg是 &lt;code&gt;Net::Cmd&lt;/code&gt; 子类的名称））。可以重写_set_status_timeout（）方法以设置其他消息（通过调用set_status（）），否则可以捕获此错误。</target>
        </trans-unit>
        <trans-unit id="11aba41a92baa1006f7ccfb764892fd564d365da" translate="yes" xml:space="preserve">
          <source>If there is a syntax error or runtime error, or a &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; statement is executed, &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context or an empty list in list context, and &lt;code&gt;$@&lt;/code&gt; is set to the error message. (Prior to 5.16, a bug caused &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to be returned in list context for syntax errors, but not for runtime errors.) If there was no error, &lt;code&gt;$@&lt;/code&gt; is set to the empty string. A control flow operator like &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; can bypass the setting of &lt;code&gt;$@&lt;/code&gt; . Beware that using &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; neither silences Perl from printing warnings to STDERR, nor does it stuff the text of warning messages into &lt;code&gt;$@&lt;/code&gt; . To do either of those, you have to use the &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; facility, or turn off warnings inside the BLOCK or EXPR using &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; . See &lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;, &lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt;, and &lt;a href=&quot;../warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">如果存在语法错误或运行时错误，或者执行了 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 语句，则 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 在标量上下文中返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或在列表上下文中返回空列表，并将 &lt;code&gt;$@&lt;/code&gt; 设置为错误消息。 （在5.16之前，一个错误导致 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 在语法语法错误而不是在运行时错误的列表上下文中返回。）如果没有错误，则将 &lt;code&gt;$@&lt;/code&gt; 设置为空字符串。诸如 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 之类的控制流运算符可以绕过 &lt;code&gt;$@&lt;/code&gt; 的设置。请注意，使用 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 既不会使Perl从打印警告到STDERR的操作保持静音，也不会将警告消息的文本填充到 &lt;code&gt;$@&lt;/code&gt; 。要执行上述任一操作，您必须使用 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 工具，或者在BLOCK或EXPR内部使用 &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; 来关闭警告。请参阅&lt;a href=&quot;warn&quot;&gt;警告&lt;/a&gt;，&lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt;和&lt;a href=&quot;../warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ebacccba519ce29c0edb6165a1d7c06041545422" translate="yes" xml:space="preserve">
          <source>If there is a syntax error or runtime error, or a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; statement is executed, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context or an empty list in list context, and &lt;code&gt;$@&lt;/code&gt; is set to the error message. (Prior to 5.16, a bug caused &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to be returned in list context for syntax errors, but not for runtime errors.) If there was no error, &lt;code&gt;$@&lt;/code&gt; is set to the empty string. A control flow operator like &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; can bypass the setting of &lt;code&gt;$@&lt;/code&gt; . Beware that using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; neither silences Perl from printing warnings to STDERR, nor does it stuff the text of warning messages into &lt;code&gt;$@&lt;/code&gt; . To do either of those, you have to use the &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; facility, or turn off warnings inside the BLOCK or EXPR using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; . See &lt;a href=&quot;#warn&quot;&gt;warn&lt;/a&gt;, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;, and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">如果存在语法错误或运行时错误，或者执行了 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 语句，则 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 在标量上下文中返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或在列表上下文中返回空列表，并将 &lt;code&gt;$@&lt;/code&gt; 设置为错误消息。 （在5.16之前，一个错误导致 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 在语法语法错误而不是在运行时错误的列表上下文中返回。）如果没有错误，则将 &lt;code&gt;$@&lt;/code&gt; 设置为空字符串。诸如 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 之类的控制流运算符可以绕过 &lt;code&gt;$@&lt;/code&gt; 的设置。请注意，使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 既不会使Perl从打印警告到STDERR的操作保持静音，也不会将警告消息的文本填充到 &lt;code&gt;$@&lt;/code&gt; 。要执行上述任一操作，您必须使用 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 工具，或者在BLOCK或EXPR内部使用 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; 来关闭警告。请参阅&lt;a href=&quot;#warn&quot;&gt;警告&lt;/a&gt;，&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;和&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5466934b0ce09952bbdf7a873d8e98baf5e63870" translate="yes" xml:space="preserve">
          <source>If there is an error then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">如果有错误，则将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="467d2ed550f37bc1b9fda912fd43e11ff12b4118" translate="yes" xml:space="preserve">
          <source>If there is any question about whether a given patch might merit inclusion in a maint release, then it almost certainly should not be included.</source>
          <target state="translated">如果有任何关于某个补丁是否值得包含在主版本中的问题,那么几乎可以肯定它不应该被包含在内。</target>
        </trans-unit>
        <trans-unit id="0f8376c45472eeb9e97a43b3d977d663509a5686" translate="yes" xml:space="preserve">
          <source>If there is more than one argument in LIST, this calls execvp(3) with the arguments in LIST. If there is only one element in LIST, the argument is checked for shell metacharacters, and if there are any, the entire argument is passed to the system's command shell for parsing (this is &lt;code&gt;/bin/sh -c&lt;/code&gt; on Unix platforms, but varies on other platforms). If there are no shell metacharacters in the argument, it is split into words and passed directly to &lt;code&gt;execvp&lt;/code&gt; , which is more efficient. Examples:</source>
          <target state="translated">如果LIST中有多个参数，则使用LIST中的参数调用execvp（3）。如果LIST中只有一个元素，则检查该参数是否包含shell元字符，如果有，则将整个参数传递给系统的命令shell进行解析（在Unix平台上为 &lt;code&gt;/bin/sh -c&lt;/code&gt; ，但有所不同在其他平台上）。如果参数中没有外壳元字符，则将其拆分为单词，然后直接传递给 &lt;code&gt;execvp&lt;/code&gt; ，这样效率更高。例子：</target>
        </trans-unit>
        <trans-unit id="2594b97a91aa3fa79863d35058be1a8172ac679a" translate="yes" xml:space="preserve">
          <source>If there is no</source>
          <target state="translated">如果没有</target>
        </trans-unit>
        <trans-unit id="836d7eec1f71c6b6f4181b3811b03cbac0e80430" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;\E&lt;/code&gt; , case is converted until the end of the string. The regexps &lt;code&gt;\L\u$word&lt;/code&gt; or &lt;code&gt;\u\L$word&lt;/code&gt; convert the first character of &lt;code&gt;$word&lt;/code&gt; to uppercase and the rest of the characters to lowercase.</source>
          <target state="translated">如果没有 &lt;code&gt;\E&lt;/code&gt; ，则转换大小写直到字符串的结尾。在正则表达式 &lt;code&gt;\L\u$word&lt;/code&gt; 或 &lt;code&gt;\u\L$word&lt;/code&gt; 转换的第一个字符 &lt;code&gt;$word&lt;/code&gt; 为大写和字符的其余小写。</target>
        </trans-unit>
        <trans-unit id="c73d7b3af9d178254858949bc270c269c6e2e60d" translate="yes" xml:space="preserve">
          <source>If there is no INSTALL.SKIP file in the make directory then this value can be used to provide a default.</source>
          <target state="translated">如果make目录下没有INSTALL.SKIP文件,那么这个值可以用来提供一个默认值。</target>
        </trans-unit>
        <trans-unit id="349639462c1781c6c7203933948097f1b032dbf1" translate="yes" xml:space="preserve">
          <source>If there is no case folding for the input code point, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果输入代码点没有大小写折叠，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20a8d9cc6cec6caebf969b32884584509dabbda2" translate="yes" xml:space="preserve">
          <source>If there is no corresponding capture group defined, then it is a fatal error. Recursing deeper than 50 times without consuming any input string will also result in a fatal error. The maximum depth is compiled into perl, so changing it requires a custom build.</source>
          <target state="translated">如果没有定义相应的捕获组,那么就是一个致命的错误。在没有消耗任何输入字符串的情况下,递归深度超过50次也会导致一个致命的错误。最大深度是编译到perl中的,所以改变它需要自定义构建。</target>
        </trans-unit>
        <trans-unit id="c5c7947682ddf8ce5897cbba5d096660017802ec" translate="yes" xml:space="preserve">
          <source>If there is no description, its the same as the parameter to WriteMakefile() documented in ExtUtils::MakeMaker.</source>
          <target state="translated">如果没有描述,它和ExtUtils::MakeMaker中记载的WriteMakefile()参数一样。</target>
        </trans-unit>
        <trans-unit id="9a08244ff3de5da70abd74d4f48bc9a98bd5fd63" translate="yes" xml:space="preserve">
          <source>If there is no error, then the method returns the value of the last expression evaluated, or a return statement may be used, just as with subroutines and &lt;b&gt;eval()&lt;/b&gt;. The context (list or scalar) is determined by the caller as usual.</source>
          <target state="translated">如果没有错误，则该方法将返回最后计算出的表达式的值，或者可以使用return语句，就像子例程和&lt;b&gt;eval（）一样&lt;/b&gt;。上下文（列表或标量）由调用者照常确定。</target>
        </trans-unit>
        <trans-unit id="9fcf9881e5055fcb38df136c867429f9722c1a7e" translate="yes" xml:space="preserve">
          <source>If there is no global precision or accuracy set, &lt;b&gt;and&lt;/b&gt; the operation in question was not called with a requested precision or accuracy, &lt;b&gt;and&lt;/b&gt; the input $x has no accuracy or precision set, then a fallback parameter will be used. For historical reasons, it is called &lt;code&gt;div_scale&lt;/code&gt; and can be accessed via:</source>
          <target state="translated">如果没有设置全局精度或精度，&lt;b&gt;并且&lt;/b&gt;没有以请求的精度或精度调用相关操作，&lt;b&gt;并且&lt;/b&gt;输入$ x没有设置精度或精度，则将使用后备参数。由于历史原因，它称为 &lt;code&gt;div_scale&lt;/code&gt; ，可以通过以下方式访问：</target>
        </trans-unit>
        <trans-unit id="bbd1fd130f18a572d29a93b5834a0fdb0347ebb7" translate="yes" xml:space="preserve">
          <source>If there is no interactivity then you may still want to look at using something like &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fmodule%2fTemplate&quot;&gt;Template Toolkit&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::TemplateToolkit&quot;&gt;Plack::Middleware::TemplateToolkit&lt;/a&gt; so maintenance of your HTML files (and other assets) is easier.</source>
          <target state="translated">如果没有交互性，那么您可能仍希望使用诸如&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fmodule%2fTemplate&quot;&gt;Template Toolkit&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::TemplateToolkit&quot;&gt;Plack :: Middleware :: TemplateToolkit之&lt;/a&gt;类的工具，以便更轻松地维护HTML文件（和其他资产）。</target>
        </trans-unit>
        <trans-unit id="8dd8956e9b63cae584008cf6c1bbe7cd26c8c5c5" translate="yes" xml:space="preserve">
          <source>If there is no matching entry found and there is no default defined, or no .netrc file is found, then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果找不到匹配的条目，并且没有定义默认值，或者没有找到.netrc文件，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40165726268e187e7ad5a226c93cb70fb5e7ae2c" translate="yes" xml:space="preserve">
          <source>If there is only one argument and it is a reference to an array then the array is assumed to contain a list of key-value pairs specifying the options. In this case the option &quot;from_to&quot; is mandatory. This style means that you do not have to supply a cryptic list of arguments and can use a self documenting argument list that is easier to understand.</source>
          <target state="translated">如果只有一个参数,并且是一个数组的引用,那么数组被认为包含了一个键值对的列表,指定了选项。在这种情况下,选项 &quot;from_to &quot;是必须的。这种风格意味着你不需要提供一个神秘的参数列表,可以使用一个更容易理解的自记录参数列表。</target>
        </trans-unit>
        <trans-unit id="663e6f7ad7626839945e055f61dd00fa139292d7" translate="yes" xml:space="preserve">
          <source>If there was an error authenticating the user then</source>
          <target state="translated">如果验证用户时出现错误,那么</target>
        </trans-unit>
        <trans-unit id="c4805e4afe7a0ccfe45caa54514a077972082082" translate="yes" xml:space="preserve">
          <source>If there's already an entry in &lt;code&gt;%table&lt;/code&gt; for the current &lt;code&gt;$country&lt;/code&gt; , then nothing is different. Line 6 will locate the value in &lt;code&gt;$table{$country}&lt;/code&gt; , which is a reference to an array, and push &lt;code&gt;$city&lt;/code&gt; into the array. But what does it do when &lt;code&gt;$country&lt;/code&gt; holds a key, say &lt;code&gt;Greece&lt;/code&gt; , that is not yet in &lt;code&gt;%table&lt;/code&gt; ?</source>
          <target state="translated">如果 &lt;code&gt;%table&lt;/code&gt; 中已经有当前 &lt;code&gt;$country&lt;/code&gt; 的条目，则没有什么不同。第6行将在 &lt;code&gt;$table{$country}&lt;/code&gt; 定位值，该值是对数组的引用，并将 &lt;code&gt;$city&lt;/code&gt; 推入数组。但是，当 &lt;code&gt;Greece&lt;/code&gt; 说 &lt;code&gt;$country&lt;/code&gt; 拥有尚未在 &lt;code&gt;%table&lt;/code&gt; 中的键时，该怎么办？</target>
        </trans-unit>
        <trans-unit id="b79b95fc8b6f0bdad9a42663607fbb6bbfce24c2" translate="yes" xml:space="preserve">
          <source>If there's no &lt;code&gt;\w&lt;/code&gt; in &lt;code&gt;s1&lt;/code&gt; nor in &lt;code&gt;s2&lt;/code&gt; , why does their concatenation have one?</source>
          <target state="translated">如果没有 &lt;code&gt;\w&lt;/code&gt; 在 &lt;code&gt;s1&lt;/code&gt; 也不是 &lt;code&gt;s2&lt;/code&gt; ，为什么他们的串联也有吗？</target>
        </trans-unit>
        <trans-unit id="4d867e0a4fd4a8ea827c16a08b87197c9c461d55" translate="yes" xml:space="preserve">
          <source>If these dependent libraries are not listed at shared library creation time, you will get fatal &quot;Unresolved symbol&quot; errors at run time when the library is loaded.</source>
          <target state="translated">如果在创建共享库时没有列出这些依赖库,那么在运行时加载库时就会出现致命的 &quot;Unresolved symbol &quot;错误。</target>
        </trans-unit>
        <trans-unit id="66c4d2d6f3874b5b92940f178682f9bbdd8c1db5" translate="yes" xml:space="preserve">
          <source>If these operators are not explicitly overloaded then they work in the normal way, yielding the underlying scalar, array, or whatever stores the object data (or the appropriate error message if the dereference operator doesn't match it). Defining a catch-all &lt;code&gt;'nomethod'&lt;/code&gt; (see &lt;a href=&quot;#nomethod&quot;&gt;below&lt;/a&gt;) makes no difference to this as the catch-all function will not be called to implement a missing dereference operator.</source>
          <target state="translated">如果这些运算符未显式重载，则它们将以正常方式工作，产生底层标量，数组或任何存储对象数据的内容（如果取消引用运算符不匹配，则会显示相应的错误消息）。定义一个 &lt;code&gt;'nomethod'&lt;/code&gt; （请参见&lt;a href=&quot;#nomethod&quot;&gt;下文&lt;/a&gt;）对此没有任何区别，因为将不会调用catch-all函数来实现缺少的解除引用运算符。</target>
        </trans-unit>
        <trans-unit id="e7e81ed1aafee87e39f3bf4df7400134171b1b47" translate="yes" xml:space="preserve">
          <source>If these were ordinary paragraphs, the Pod parser would try to expand the &quot;E&amp;lt;/em&amp;gt;&quot; (in the first paragraph) as a formatting code, just like &quot;E&amp;lt;lt&amp;gt;&quot; or &quot;E&amp;lt;eacute&amp;gt;&quot;. But since this is in a &quot;=begin</source>
          <target state="translated">如果这些是普通段落，则Pod解析器将尝试将&amp;ldquo; E &amp;lt;/ em&amp;gt;&amp;rdquo;（在第一段中）扩展为格式代码，就像&amp;ldquo; E &amp;lt;lt&amp;gt;&amp;rdquo;或&amp;ldquo; E &amp;lt;eacute&amp;gt;&amp;rdquo;一样。但是由于这是在&amp;ldquo; =开始</target>
        </trans-unit>
        <trans-unit id="4135dfc8a9407c20cefc1359ee43028a8d9e9a77" translate="yes" xml:space="preserve">
          <source>If they are not composable, it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果它们不可组合，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7928853cb29cf0ed7b6549f627a68e66710a9993" translate="yes" xml:space="preserve">
          <source>If they wanted to clobber something, they might say:</source>
          <target state="translated">如果他们想砸东西,他们可能会说:</target>
        </trans-unit>
        <trans-unit id="005637a170229ceb4ce45f18dce99b88396f9f92" translate="yes" xml:space="preserve">
          <source>If things aren't broken, upgrading perl may break them (or at least issue new warnings).</source>
          <target state="translated">如果事情没有被破坏,升级perl可能会破坏它们(或者至少发出新的警告)。</target>
        </trans-unit>
        <trans-unit id="af3184843a959ec8cbcadf6df48b4b495b6b3f78" translate="yes" xml:space="preserve">
          <source>If this behaviour is not desirable, the &lt;code&gt;error&lt;/code&gt; attribute may be used to hold a reference to a variable, which will be used to store the diagnostics. The variable is made a reference to an array of hash references. Each hash contain a single key/value pair where the key is the name of the file, and the value is the error message (including the contents of &lt;code&gt;$!&lt;/code&gt; when appropriate). If a general error is encountered the diagnostic key will be empty.</source>
          <target state="translated">如果这种行为是不希望的，则可以使用 &lt;code&gt;error&lt;/code&gt; 属性保存对变量的引用，该变量将用于存储诊断信息。将该变量作为对哈希引用数组的引用。每个哈希包含一个键/值对，其中键是文件名，值是错误消息（适当时包括 &lt;code&gt;$!&lt;/code&gt; 的内容）。如果遇到一般错误，诊断键将为空。</target>
        </trans-unit>
        <trans-unit id="cfffc413c869bcf00848584ef88629d0cba8d4b7" translate="yes" xml:space="preserve">
          <source>If this command lists any paths that don't exist on your system, then you may need to move the appropriate libraries to these locations, or create symbolic links, aliases, or shortcuts appropriately. &lt;code&gt;@INC&lt;/code&gt; is also printed as part of the output of</source>
          <target state="translated">如果此命令列出了系统上不存在的任何路径，则可能需要将适当的库移至这些位置，或适当地创建符号链接，别名或快捷方式。 &lt;code&gt;@INC&lt;/code&gt; 也作为输出的一部分打印</target>
        </trans-unit>
        <trans-unit id="4975023e8ced451b521e66f7c64344d22c9935aa" translate="yes" xml:space="preserve">
          <source>If this directory is exactly the same as the prefix which was compiled into</source>
          <target state="translated">如果这个目录与被编译为</target>
        </trans-unit>
        <trans-unit id="285c8028480f1bd9da414482302791b2b2e5917d" translate="yes" xml:space="preserve">
          <source>If this displays any &lt;code&gt;D&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt; symbols (or possibly &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; ), you have non-const data. The symbols the &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; removed are as follows: &lt;code&gt;Tt&lt;/code&gt; are</source>
          <target state="translated">如果显示任何 &lt;code&gt;D&lt;/code&gt; 或 &lt;code&gt;d&lt;/code&gt; 符号（或可能显示 &lt;code&gt;C&lt;/code&gt; 或 &lt;code&gt;c&lt;/code&gt; ），则说明您具有非常量数据。 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 删除的符号如下： &lt;code&gt;Tt&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="4abdac7aa391382bc2754c2374cb867d27e05580" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to a true value, all of the functions defined by this module (color(), colored(), and all of the constants not previously used in the program) will not output any escape sequences and instead will just return the empty string or pass through the original text as appropriate. This is intended to support easy use of scripts using this module on platforms that don't support ANSI escape sequences.</source>
          <target state="translated">如果这个环境变量设置为true,那么这个模块定义的所有函数(color(),colored(),以及所有之前没有在程序中使用的常量)将不会输出任何转义序列,而只是返回空字符串或者适当地通过原文。这样做的目的是为了支持在不支持ANSI转义序列的平台上使用本模块的脚本,方便使用。</target>
        </trans-unit>
        <trans-unit id="876cbaf8d98a55944949f12e34d25c434a20bad7" translate="yes" xml:space="preserve">
          <source>If this environment variable is true then normal install processes will always overwrite older identical files during the install process.</source>
          <target state="translated">如果这个环境变量为真,那么在安装过程中,正常的安装过程将总是覆盖旧的相同文件。</target>
        </trans-unit>
        <trans-unit id="07fe5d03fc19f605909f122565e563658cd995e6" translate="yes" xml:space="preserve">
          <source>If this field is zero then &lt;code&gt;PerlIO_pushed&lt;/code&gt; does not malloc anything and assumes layer's Pushed function will do any required layer stack manipulation - used to avoid malloc/free overhead for dummy layers. If the field is non-zero it must be at least the size of &lt;code&gt;PerlIOl&lt;/code&gt; , &lt;code&gt;PerlIO_pushed&lt;/code&gt; will allocate memory for the layer's data structures and link new layer onto the stream's stack. (If the layer's Pushed method returns an error indication the layer is popped again.)</source>
          <target state="translated">如果此字段为零，则 &lt;code&gt;PerlIO_pushed&lt;/code&gt; 不会分配任何内容，并假定层的Pushed函数将执行任何必需的层堆栈操作-用于避免虚拟层的malloc /空闲开销。如果该字段不为零，则必须至少为 &lt;code&gt;PerlIOl&lt;/code&gt; 的大小， &lt;code&gt;PerlIO_pushed&lt;/code&gt; 将为该层的数据结构分配内存，并将新层链接到流的堆栈上。（如果图层的Pushed方法返回错误指示，则该图层将再次弹出。）</target>
        </trans-unit>
        <trans-unit id="6eff879286b0f884c3e6b0dc473e05a91d80d4a8" translate="yes" xml:space="preserve">
          <source>If this function is being sourced in from a separate file via &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, then this is probably just fine. If it's all in the main program, you'll need to arrange for the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; to be executed early, either by putting the whole block above your main program, or more likely, placing merely a &lt;code&gt;BEGIN&lt;/code&gt; code block around it to make sure it gets executed before your program starts to run:</source>
          <target state="translated">如果此功能是通过 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 从单独的文件中获取的，那么可能就很好了。如果所有内容都在主程序中，则需要安排 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 尽早执行，方法是将整个代码块放在主程序上方，或者更有可能的是，仅在其周围放置一个 &lt;code&gt;BEGIN&lt;/code&gt; 代码块以确保其获得在程序开始运行之前执行：</target>
        </trans-unit>
        <trans-unit id="e5121e7b7256f6d0ab378dc9bff9a8c6dad43577" translate="yes" xml:space="preserve">
          <source>If this happens to you, there's not much you can do except switch to use a different locale or use &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; to translate from the locale into UTF-8; if that's impracticable, you have been warned that some things may break.</source>
          <target state="translated">如果您遇到这种情况，除了切换为使用其他语言环境或使用&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;将语言环境转换为UTF-8 之外，您无能为力。如果这不可行，则已警告您某些事情可能会中断。</target>
        </trans-unit>
        <trans-unit id="faa64c33180aaefa8582782daf214d7a2f4780a7" translate="yes" xml:space="preserve">
          <source>If this interior sequence is nested inside of another interior sequence, then the outer/parent sequence that contains it is returned. Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果此内部序列嵌套在另一个内部序列内部，则返回包含它的外部/父序列。否则，将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf7d995797b0338af1d03b9d03a8511323aeb269" translate="yes" xml:space="preserve">
          <source>If this is a TODO test and an 'ok' line, this method returns true. Otherwise, it will always return false (regardless of passing status on non-todo tests).</source>
          <target state="translated">如果这是一个TODO测试,并且是一个'ok'行,那么这个方法就会返回true,否则,它将总是返回false(不管非todo测试的通过状态如何)。否则,它将总是返回false(不管非待办事项测试的通过状态如何)。</target>
        </trans-unit>
        <trans-unit id="f7666722db0ac2cfa26e5cabc574e02e68556877" translate="yes" xml:space="preserve">
          <source>If this is being called as &lt;code&gt;re::regname&lt;/code&gt; , &lt;code&gt;re::regnames&lt;/code&gt; or &lt;code&gt;re::regnames_count&lt;/code&gt; , if any. The first two will be combined with &lt;code&gt;RXapif_ONE&lt;/code&gt; or &lt;code&gt;RXapif_ALL&lt;/code&gt; .</source>
          <target state="translated">如果将其称为 &lt;code&gt;re::regname&lt;/code&gt; ， &lt;code&gt;re::regnames&lt;/code&gt; 或 &lt;code&gt;re::regnames_count&lt;/code&gt; （如果有）。前两个将与 &lt;code&gt;RXapif_ONE&lt;/code&gt; 或 &lt;code&gt;RXapif_ALL&lt;/code&gt; 组合。</target>
        </trans-unit>
        <trans-unit id="9edbce2664bb4f91955d900ea95b27deaa6b5a4b" translate="yes" xml:space="preserve">
          <source>If this is in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; it will be passed to &lt;code&gt;Perl_fbm_instr&lt;/code&gt; by &lt;code&gt;pp_split&lt;/code&gt; which will treat the subject string as a multi-line string.</source>
          <target state="translated">如果这是在 &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; 它会被传递给 &lt;code&gt;Perl_fbm_instr&lt;/code&gt; 由 &lt;code&gt;pp_split&lt;/code&gt; 将治疗目标字符串作为多行字符串。</target>
        </trans-unit>
        <trans-unit id="3e0c042153cf9f6ff54247584b15672ab611a4af" translate="yes" xml:space="preserve">
          <source>If this is negative, and amounts to &lt;code&gt;HEf_SVKEY&lt;/code&gt; , it indicates the entry holds an &lt;code&gt;SV*&lt;/code&gt; key. Otherwise, holds the actual length of the key. Can be assigned to. The &lt;code&gt;HePV()&lt;/code&gt; macro is usually preferable for finding key lengths.</source>
          <target state="translated">如果为负，并且等于 &lt;code&gt;HEf_SVKEY&lt;/code&gt; ，则表明该条目包含 &lt;code&gt;SV*&lt;/code&gt; 密钥。否则，保留密钥的实际长度。可以分配给。通常，最好使用 &lt;code&gt;HePV()&lt;/code&gt; 宏来查找密钥长度。</target>
        </trans-unit>
        <trans-unit id="ddda819aeefa94d361f2fc0677ccc065e6c33f4f" translate="yes" xml:space="preserve">
          <source>If this is starting to sound scarier than it's worth, relax. Perl has some features to help you avoid its most common pitfalls. The best way to avoid getting confused is to start every program like this:</source>
          <target state="translated">如果这听起来很可怕,那么请放松。Perl有一些功能可以帮助你避免最常见的陷阱。避免混淆的最好方法是这样启动每个程序。</target>
        </trans-unit>
        <trans-unit id="c2cd7396387cdb373b2dd32a6d21ffa39a9fbdd0" translate="yes" xml:space="preserve">
          <source>If this is true, none of that will be done.</source>
          <target state="translated">如果这是真的,这些都不会做。</target>
        </trans-unit>
        <trans-unit id="998c59b2484753d1482d0ff9ba7497a84e80fcd4" translate="yes" xml:space="preserve">
          <source>If this is what you intended then you can silence the warning by using &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/${\}/&lt;/a&gt;&lt;/code&gt; (for example: &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo${\}s+bar/&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果您打算这样做，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/${\}/&lt;/a&gt;&lt;/code&gt; （例如： &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo${\}s+bar/&lt;/a&gt;&lt;/code&gt; ）使警告静音。</target>
        </trans-unit>
        <trans-unit id="b2f4b7328771b0d9e19ff0a7ce5f9c13e4b36300" translate="yes" xml:space="preserve">
          <source>If this is your first use of Sys::Syslog, you must read the doc.</source>
          <target state="translated">如果这是你第一次使用Sys::Syslog,你必须阅读文档。</target>
        </trans-unit>
        <trans-unit id="51861420a23f19227e776c6bc3a38fdcea309df1" translate="yes" xml:space="preserve">
          <source>If this option is not present, the value stored in XFL field will be determined by the setting of the &lt;code&gt;Level&lt;/code&gt; option.</source>
          <target state="translated">如果不存在此选项，则XFL字段中存储的值将由&amp;ldquo; &lt;code&gt;Level&lt;/code&gt; 选项的设置确定。</target>
        </trans-unit>
        <trans-unit id="415323d14a6e182890345d78f7ae3f3149cdff1f" translate="yes" xml:space="preserve">
          <source>If this option is set and the input file/buffer is not compressed data, the module will allow reading of it anyway.</source>
          <target state="translated">如果设置了这个选项,并且输入的文件/缓冲区不是压缩数据,那么无论如何模块都会允许读取它。</target>
        </trans-unit>
        <trans-unit id="805aae725ba9def01f764562edc887adcbc46d85" translate="yes" xml:space="preserve">
          <source>If this option is set, Pod::Man will instead output UTF-8. If your *roff implementation can handle it, this is the best output format to use and avoids corruption of documents containing non-ASCII characters. However, be warned that *roff source with literal UTF-8 characters is not supported by many implementations and may even result in segfaults and other bad behavior.</source>
          <target state="translated">如果设置了这个选项,Pod::Man将代替UTF-8输出,如果你的*roff实现能够处理它,这是最好的输出格式,并避免包含非ASCII字符的文件损坏。如果你的*roff实现可以处理它,这是最好的输出格式,可以避免包含非ASCII字符的文档损坏。然而,要注意的是,许多实现并不支持使用UTF-8字符的*roff源码,甚至可能导致 segfaults和其他不良行为。</target>
        </trans-unit>
        <trans-unit id="9276827e0a43ce0cd98e803156d215d94a1cfced" translate="yes" xml:space="preserve">
          <source>If this paragraph is a command paragraph, then this method will return the name of the command (</source>
          <target state="translated">如果这一段是一个命令段,那么这个方法将返回命令的名称(</target>
        </trans-unit>
        <trans-unit id="bcc44b3b4b66c03b7a2464f3e737f50efd9dbf21" translate="yes" xml:space="preserve">
          <source>If this paragraph is a command paragraph, then this method will return the prefix used to denote the command (which should be the string &quot;=&quot; or &quot;==&quot;).</source>
          <target state="translated">如果这个段落是一个命令段落,那么这个方法将返回用来表示命令的前缀(应该是字符串&quot;=&quot;或&quot;==&quot;)。</target>
        </trans-unit>
        <trans-unit id="97d5af9792754821d43f791eb7a3e99d0e1078a4" translate="yes" xml:space="preserve">
          <source>If this paragraph is a command paragraph, then this method will return the text used to separate the command name from the rest of the paragraph (if any).</source>
          <target state="translated">如果这个段落是一个命令段落,那么这个方法将返回用于将命令名称与段落的其余部分分开的文本(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="f1f4b76081f3628eb70be0fbee8dbf0d6e9f3ca4" translate="yes" xml:space="preserve">
          <source>If this parameter is not used, certain error conditions may raise a fatal error that will cause the program will halt, unless trapped in an &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block.</source>
          <target state="translated">如果不使用此参数，则某些错误条件可能会引发致命错误，除非程序陷入 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 块中，否则它将导致程序停止运行。</target>
        </trans-unit>
        <trans-unit id="0d2fb08e29fba6225fdf1f445f37f2366e459721" translate="yes" xml:space="preserve">
          <source>If this regexp matches, &lt;code&gt;$1&lt;/code&gt; contains a string starting with &lt;code&gt;'ab'&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; is either set to &lt;code&gt;'cd'&lt;/code&gt; or &lt;code&gt;'ef'&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; equals either &lt;code&gt;'gi'&lt;/code&gt; or &lt;code&gt;'j'&lt;/code&gt; , and &lt;code&gt;$4&lt;/code&gt; is either set to &lt;code&gt;'gi'&lt;/code&gt; , just like &lt;code&gt;$3&lt;/code&gt; , or it remains undefined.</source>
          <target state="translated">如果此正则表达式匹配，则 &lt;code&gt;$1&lt;/code&gt; 包含以 &lt;code&gt;'ab'&lt;/code&gt; 开头的字符串， &lt;code&gt;$2&lt;/code&gt; 设置为 &lt;code&gt;'cd'&lt;/code&gt; 或 &lt;code&gt;'ef'&lt;/code&gt; ， &lt;code&gt;$3&lt;/code&gt; 等于 &lt;code&gt;'gi'&lt;/code&gt; 或 &lt;code&gt;'j'&lt;/code&gt; ，而 &lt;code&gt;$4&lt;/code&gt; 设置为 &lt;code&gt;'gi'&lt;/code&gt; ，只是例如 &lt;code&gt;$3&lt;/code&gt; ，否则它仍未定义。</target>
        </trans-unit>
        <trans-unit id="f4f92dc123bfc535dc7925652fedf35a2b5f0876" translate="yes" xml:space="preserve">
          <source>If this seems like a lot, then feel free to inherit from merely the standard Tie::StdHash module for most of your methods, redefining only the interesting ones. See &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; for details.</source>
          <target state="translated">如果这看起来很多，请随意从大多数方法的标准Tie :: StdHash模块继承，仅重新定义有趣的方法。有关详细信息，请参见&lt;a href=&quot;tie/hash&quot;&gt;Tie :: Hash&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3f60efe640d39524c6e11c22deb74b1e7bd6e48" translate="yes" xml:space="preserve">
          <source>If this still doesn't work, look into the &lt;code&gt;clearerr&lt;/code&gt; method from &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;, which resets the error and end-of-file states on the handle.</source>
          <target state="translated">如果仍然 &lt;code&gt;clearerr&lt;/code&gt; ，请查看&lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt;的clearerr方法，该方法将重置句柄上的错误和文件结束状态。</target>
        </trans-unit>
        <trans-unit id="5f660c829995c0ccf8574939955dcb34cbb1fbc2" translate="yes" xml:space="preserve">
          <source>If this template key is true, enforces that if this key is provided by user input, its value is &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt;. This just means that the user is not allowed to pass &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as a value for this key and is equivalent to: allow =&amp;gt; sub { defined $_[0] &amp;amp;&amp;amp; OTHER TESTS }</source>
          <target state="translated">如果此模板密钥为true，则强制执行此操作（如果该密钥由用户输入提供），则将 &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 其值。这仅表示不允许用户将 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 作为此键的值传递，并且等效于：allow =&amp;gt; sub {defined $ _ [0] &amp;amp;&amp;amp; OTHER TESTS}</target>
        </trans-unit>
        <trans-unit id="76bbabb48932b2f041b390c777de07be84c85182" translate="yes" xml:space="preserve">
          <source>If this value is defined but false then such an operation has ocurred, but should not impact later operations.</source>
          <target state="translated">如果定义了这个值,但为假,那么这样的操作已经发生,但不应该影响以后的操作。</target>
        </trans-unit>
        <trans-unit id="cc6a20a1fa0fe02624d3822b74f6ca89396c5ee4" translate="yes" xml:space="preserve">
          <source>If this variable is set to a true value, then &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; on Windows will not try to open the file. This means that the link count cannot be determined and file attributes may be out of date if additional hardlinks to the file exist. On the other hand, not opening the file is considerably faster, especially for files on network drives.</source>
          <target state="translated">如果将此变量设置为true值，则Windows上的 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 将不会尝试打开文件。这意味着无法确定链接数，并且如果存在到文件的其他硬链接，则文件属性可能已过期。另一方面，不打开文件的速度要快得多，尤其是对于网络驱动器上的文件。</target>
        </trans-unit>
        <trans-unit id="65e9d7214894094637d48b5893992a1d4deebf1e" translate="yes" xml:space="preserve">
          <source>If this variable is true then such an operation has occurred and anything depending on this module cannot proceed until a reboot has occurred.</source>
          <target state="translated">如果这个变量为真,那么这样的操作就发生了,在重启之前,任何依赖于这个模块的操作都不能进行。</target>
        </trans-unit>
        <trans-unit id="41c3e520fc9953b8c23b0cb154effeffba4245f7" translate="yes" xml:space="preserve">
          <source>If three (or more) arguments are specified, the open mode (including optional encoding) in the second argument are distinct from the filename in the third. If MODE is &lt;code&gt;&amp;lt;&lt;/code&gt; or nothing, the file is opened for input. If MODE is &lt;code&gt;&amp;gt;&lt;/code&gt;, the file is opened for output, with existing files first being truncated (&quot;clobbered&quot;) and nonexisting files newly created. If MODE is &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , the file is opened for appending, again being created if necessary.</source>
          <target state="translated">如果指定了三个（或更多）参数，则第二个参数中的打开模式（包括可选编码）与第三个参数中的文件名不同。如果MODE为 &lt;code&gt;&amp;lt;&lt;/code&gt; 或为空，则打开文件进行输入。如果MODE为 &lt;code&gt;&amp;gt;&lt;/code&gt; ，则打开文件以进行输出，首先将现有文件截断（&amp;ldquo;弄皱&amp;rdquo;），然后新创建不存在的文件。如果MODE为 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ，则打开文件以进行追加，并在必要时再次创建。</target>
        </trans-unit>
        <trans-unit id="2e10a47d1100af2f4e741fa10c714b1d6eb83c05" translate="yes" xml:space="preserve">
          <source>If true (the default value), we autogenerate a JavaScript in the output directory, and set our HTML files to use it. Currently, the JavaScript is used only to get the browser to remember what stylesheet it prefers. TODO: continue</source>
          <target state="translated">如果为true(默认值),我们会在输出目录下自动生成一个JavaScript,并设置我们的HTML文件使用它。目前,JavaScript只是用来让浏览器记住它喜欢的样式表。待办事项:继续</target>
        </trans-unit>
        <trans-unit id="634c500cd04e5d0b913158c1c6e9ccddc0f9bc06" translate="yes" xml:space="preserve">
          <source>If true (the default value), we autogenerate some CSS files in the output directory, and set our HTML files to use those. TODO: continue</source>
          <target state="translated">如果为true(默认值),我们会在输出目录中自动生成一些CSS文件,并设置我们的HTML文件使用这些文件。待办事项:继续</target>
        </trans-unit>
        <trans-unit id="ed672b2b381b7d94345040cc4eb4667fc3d97c8b" translate="yes" xml:space="preserve">
          <source>If true and a code reference, will be called with the symbolic link name and the directory it lives in as arguments. Otherwise, if true and warnings are on, warning &quot;symbolic_link_name is a dangling symbolic link\n&quot; will be issued. If false, the dangling symbolic link will be silently ignored.</source>
          <target state="translated">如果为真且有代码引用,将调用符号链接名和它所在的目录作为参数。否则,如果为真且警告开启,将发出警告 &quot;symbolic_link_name是一个悬空的符号链接&quot;。如果为false,则会默默地忽略这个悬空的符号链接。</target>
        </trans-unit>
        <trans-unit id="3f3fdfd0a40c103a2211bdac354013485a8b6be3" translate="yes" xml:space="preserve">
          <source>If true is returned, those arguments &lt;b&gt;should&lt;/b&gt; in theory be processed with quadmath_snprintf(), but in case there is more than one such format specifier (see &lt;a href=&quot;#quadmath_format_single&quot;&gt;quadmath_format_single&lt;/a&gt;), and if there is anything else beyond that one (even just a single byte), they &lt;b&gt;cannot&lt;/b&gt; be processed because quadmath_snprintf() is very strict, accepting only one format spec, and nothing else. In this case, the code should probably fail.</source>
          <target state="translated">如果返回true，则这些参数&lt;b&gt;应&lt;/b&gt;在理论与quadmath_snprintf（）处理，但万一有不止一个这样的格式说明（见&lt;a href=&quot;#quadmath_format_single&quot;&gt;quadmath_format_single&lt;/a&gt;），如果有别的超出了一个（甚至只是一个字节），&lt;b&gt;无法&lt;/b&gt;处理它们，因为quadmath_snprintf（）非常严格，仅接受一种格式规范，而别无其他。在这种情况下，代码可能会失败。</target>
        </trans-unit>
        <trans-unit id="0653af7b3995880e12e86c1b6df46b2abdc8adcd" translate="yes" xml:space="preserve">
          <source>If true then &lt;code&gt;Configure&lt;/code&gt; will check each hostname given that it exists</source>
          <target state="translated">如果为true，则 &lt;code&gt;Configure&lt;/code&gt; 将检查每个存在的主机名</target>
        </trans-unit>
        <trans-unit id="5e192827bd7624c2eefa078600e9250f2fd8d099" translate="yes" xml:space="preserve">
          <source>If true then &lt;code&gt;make test&lt;/code&gt; may attempt to connect to hosts given in the configuration.</source>
          <target state="translated">如果为true，则 &lt;code&gt;make test&lt;/code&gt; 可以尝试连接到配置中给定的主机。</target>
        </trans-unit>
        <trans-unit id="1bd986bfa48b8d9de9607995da53c20f474abed0" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;Test::Harness&lt;/code&gt; will output the verbose results of running its tests. Setting &lt;code&gt;$Test::Harness::verbose&lt;/code&gt; will override this, or you can use the &lt;code&gt;-v&lt;/code&gt; switch in the</source>
          <target state="translated">如果为true，则 &lt;code&gt;Test::Harness&lt;/code&gt; 将输出运行其测试的详细结果。设置 &lt;code&gt;$Test::Harness::verbose&lt;/code&gt; 将覆盖这一点，或者你可以使用 &lt;code&gt;-v&lt;/code&gt; 在开关</target>
        </trans-unit>
        <trans-unit id="44529fee5d3eb44416500710e8dc9bea67c57ded" translate="yes" xml:space="preserve">
          <source>If true, STDERR and STDOUT are the same filehandle. This may cause breakage if STDERR contains anything resembling TAP format, but does allow exact synchronization.</source>
          <target state="translated">如果为真,STDERR和STDOUT是同一个文件柄。如果STDERR包含任何类似于TAP格式的内容,这可能会导致中断,但确实允许精确同步。</target>
        </trans-unit>
        <trans-unit id="fe1c5580c4e77a7f54f6b42fc274494bf3ad60b5" translate="yes" xml:space="preserve">
          <source>If true, make install will be verbose</source>
          <target state="translated">如果为真,则make install将是啰嗦的。</target>
        </trans-unit>
        <trans-unit id="fb2c5a318ef60df6e780dd24e4ef173dd23b6b3c" translate="yes" xml:space="preserve">
          <source>If true, uses proxy subs. See &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Constant::ProxySubs&quot;&gt;ExtUtils::Constant::ProxySubs&lt;/a&gt;.</source>
          <target state="translated">如果为true，则使用代理订阅。参见&lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Constant::ProxySubs&quot;&gt;ExtUtils :: Constant :: ProxySubs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33b670decc24a56dd9e5e0101143f31051cabe4b" translate="yes" xml:space="preserve">
          <source>If two arrays smartmatch each other, then they are deep copies of each others' values, as this example reports:</source>
          <target state="translated">如果两个数组互相smartmatch,那么它们就是彼此值的深度拷贝,就像这个例子所报告的那样。</target>
        </trans-unit>
        <trans-unit id="acee3e1d7871c445b42f87ba144a405a067cf53f" translate="yes" xml:space="preserve">
          <source>If two characters here and next (as code points) are composable (including Hangul Jamo/Syllables and Composition Exclusions), it returns the code point of the composite.</source>
          <target state="translated">如果这里和接下来的两个字符(作为代码点)是可以合成的(包括Hangul Jamo/音节和合成排除),它返回合成的代码点。</target>
        </trans-unit>
        <trans-unit id="42360b0ce037c1aa50c01166917adec5fecc2590" translate="yes" xml:space="preserve">
          <source>If type is non-Unix (see &lt;a href=&quot;#fileparse_set_fstype&quot;&gt;fileparse_set_fstype&lt;/a&gt;) then the pattern matching for suffix removal is performed case-insensitively, since those systems are not case-sensitive when opening existing files.</source>
          <target state="translated">如果type为非Unix（请参阅&lt;a href=&quot;#fileparse_set_fstype&quot;&gt;fileparse_set_fstype&lt;/a&gt;），则后缀删除的模式匹配不区分大小写，因为打开现有文件时，这些系统不区分大小写。</target>
        </trans-unit>
        <trans-unit id="2fd48f2e17e1f717f9f154bd3292076827285d01" translate="yes" xml:space="preserve">
          <source>If umask(2) is not implemented on your system and you are trying to restrict access for</source>
          <target state="translated">如果您的系统中没有实现umask(2),并且您试图限制对</target>
        </trans-unit>
        <trans-unit id="67a1f447b6ee3db12f569b14d8d5a13cc81a620d" translate="yes" xml:space="preserve">
          <source>If unsafe signals is in effect, then signal handling is not thread-safe, and the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; signalling method cannot be used.</source>
          <target state="translated">如果有效的信号不安全，则信号处理不是线程安全的，并且 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; 信号方法不能使用。</target>
        </trans-unit>
        <trans-unit id="70663a96a9c0a32a9a2fde13b31bf56729b3885e" translate="yes" xml:space="preserve">
          <source>If upgrading is in effect, returns PI, rounded to N digits with the current rounding mode:</source>
          <target state="translated">如果升级生效,返回PI,以当前的四舍五入模式四舍五入到N位。</target>
        </trans-unit>
        <trans-unit id="d763c9ab9f9ca920e89e5e82fe0a4c19ddec98c7" translate="yes" xml:space="preserve">
          <source>If used with a single argument in a scalar context, returns the string consisting of the code points of the named sequence, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if no named sequence by that name exists. If used with a single argument in a list context, it returns the list of the ordinals of the code points.</source>
          <target state="translated">如果在标量上下文中与单个参数一起使用，则返回由命名序列的代码点组成的字符串，如果不存在该名称的命名序列，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。如果在列表上下文中与单个参数一起使用，它将返回代码点的常规列表。</target>
        </trans-unit>
        <trans-unit id="beaceddc3b74ab2a5e89e9e5517463a3fd4ed9e1" translate="yes" xml:space="preserve">
          <source>If used with no arguments in a list context, it returns a hash with the names of all the named sequences as the keys and their sequences as strings as the values. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or an empty list depending on the context.</source>
          <target state="translated">如果在列表上下文中不带任何参数使用，它将返回一个哈希，其中所有命名序列的名称作为键，而其序列作为字符串的值。否则，它会根据上下文返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或一个空列表。</target>
        </trans-unit>
        <trans-unit id="6b1f504c6467cdb5b94820cfba3df9e446f6d20a" translate="yes" xml:space="preserve">
          <source>If using &lt;b&gt;BerkeleyDB&lt;/b&gt; isn't an option, there are a number of modules available on CPAN that can be used to implement locking. Each one implements locking differently and has different goals in mind. It is therefore worth knowing the difference, so that you can pick the right one for your application. Here are the three locking wrappers:</source>
          <target state="translated">如果不能选择使用&lt;b&gt;BerkeleyDB&lt;/b&gt;，则CPAN上有许多模块可用于实现锁定。每个人实现锁的方式都不一样，并且有不同的目标。因此，有必要了解它们之间的区别，以便您可以为自己的应用选择合适的。这是三个锁定包装器：</target>
        </trans-unit>
        <trans-unit id="b0d8dee3f60efc11f28b77ac32acb4a0d6da837c" translate="yes" xml:space="preserve">
          <source>If using a Perl file as a source, optional switches may be passed which will be used when invoking the perl executable.</source>
          <target state="translated">如果使用Perl文件作为源文件,可以传递一些可选的开关,这些开关将在调用perl可执行文件时使用。</target>
        </trans-unit>
        <trans-unit id="d2c2e41b4856cbf4192df9fdfdae8eb4debbc3b0" translate="yes" xml:space="preserve">
          <source>If using crypt() on a Unicode string (which</source>
          <target state="translated">如果在Unicode字符串上使用crypt()(这将是</target>
        </trans-unit>
        <trans-unit id="45cfcf2e0c855940dc64008801ae135f972cfd74" translate="yes" xml:space="preserve">
          <source>If using ftp remember to transfer the distribution in binary format.</source>
          <target state="translated">如果使用ftp,记得要以二进制格式传输发行版。</target>
        </trans-unit>
        <trans-unit id="b6fa09de90b513e62acb77e553ed8a67bf3a34b1" translate="yes" xml:space="preserve">
          <source>If using gcc, you can add the &lt;code&gt;-std=c89&lt;/code&gt; option which will hopefully catch most of these unportabilities. (However it might also catch incompatibilities in your system's header files.)</source>
          <target state="translated">如果使用gcc，则可以添加 &lt;code&gt;-std=c89&lt;/code&gt; 选项，该选项有望捕获大多数这些不可移植性。（但是，它也可能会捕获系统头文件中的不兼容性。）</target>
        </trans-unit>
        <trans-unit id="664754e120bf0080d8c4c2636edd9c4d43e0b86a" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; pragma without an explicit encoding name, the PERL_ENCODING environment variable is consulted for an encoding name.</source>
          <target state="translated">如果使用的是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; 没有明确的编码名称附注中，PERL_ENCODING环境变量征询编码名称。</target>
        </trans-unit>
        <trans-unit id="cfca052b74a8f394827d7f4faa9fd4f5bf5109bf" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;gcc -Wall&lt;/code&gt; note that not all the possible warnings (like &lt;code&gt;-Wunitialized&lt;/code&gt; ) are given unless you also compile with &lt;code&gt;-O&lt;/code&gt; .</source>
          <target state="translated">如果使用 &lt;code&gt;gcc -Wall&lt;/code&gt; 请注意，除非您也使用 &lt;code&gt;-O&lt;/code&gt; 进行编译，否则不会给出所有可能的警告（如 &lt;code&gt;-Wunitialized&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="95f6a03b7ab2b25638142acde2118920ba4f7593" translate="yes" xml:space="preserve">
          <source>If we add a &lt;code&gt;(*PRUNE)&lt;/code&gt; before the count like the following</source>
          <target state="translated">如果我们在计数之前添加 &lt;code&gt;(*PRUNE)&lt;/code&gt; ，如下所示</target>
        </trans-unit>
        <trans-unit id="f49196da102bf295b3091d7157018af8c9071a57" translate="yes" xml:space="preserve">
          <source>If we call a method on a &lt;code&gt;Child&lt;/code&gt; object and that method is not defined in the &lt;code&gt;Child&lt;/code&gt; class, Perl will look for that method in the &lt;code&gt;Parent&lt;/code&gt; class and then, if necessary, in the &lt;code&gt;Grandparent&lt;/code&gt; class.</source>
          <target state="translated">如果我们在 &lt;code&gt;Child&lt;/code&gt; 对象上调用一个方法，但未在 &lt;code&gt;Child&lt;/code&gt; 类中定义该方法，则Perl将在 &lt;code&gt;Parent&lt;/code&gt; 类中查找该方法，然后在必要时在 &lt;code&gt;Grandparent&lt;/code&gt; 类中查找该方法。</target>
        </trans-unit>
        <trans-unit id="ef968fd799fd1b1033f77f3853f27266c25aff48" translate="yes" xml:space="preserve">
          <source>If we can tell that there is no valid start point then we don't bother running the interpreter at all. Likewise, if we know from the analysis phase that we cannot detect a short-cut to the start position, we go straight to the interpreter.</source>
          <target state="translated">如果我们可以判断出没有有效的起始点,那么我们根本就不用去运行解释器。同样,如果我们从分析阶段就知道无法检测到通往起始位置的捷径,我们就直接进入解释器。</target>
        </trans-unit>
        <trans-unit id="2cd027f23ebc9bafdd0ef83ac988a2e8f6205abb" translate="yes" xml:space="preserve">
          <source>If we encrypt this with &lt;code&gt;mkrot13&lt;/code&gt; :</source>
          <target state="translated">如果我们使用 &lt;code&gt;mkrot13&lt;/code&gt; 对此进行加密：</target>
        </trans-unit>
        <trans-unit id="b742d69e435d1dc4ae57558eae468b9e3038bfd1" translate="yes" xml:space="preserve">
          <source>If we have a string which needs to be modified, while a regex will almost always be much more flexible, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;, an oft underused tool, can still be a useful. One scenario might be replace all vowels with another character. The regex solution might look like this:</source>
          <target state="translated">如果我们有一个需要修改的字符串，而一个正则表达式几乎总是更加灵活，那么经常使用的工具 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 仍然是有用的。一种情况是用其他字符替换所有元音。正则表达式解决方案可能如下所示：</target>
        </trans-unit>
        <trans-unit id="e9e855f5e5eecc49e2e1826c2e605b2358ee8b64" translate="yes" xml:space="preserve">
          <source>If we look at any of the C code generated by any of the examples except example 1, you will notice a number of references to ST(n), where n is usually 0. &quot;ST&quot; is actually a macro that points to the n'th argument on the argument stack. ST(0) is thus the first argument on the stack and therefore the first argument passed to the XSUB, ST(1) is the second argument, and so on.</source>
          <target state="translated">如果我们看一下除了例子1以外的任何一个例子所生成的C代码,你会注意到有很多对ST(n)的引用,其中n通常是0。&quot;ST &quot;实际上是一个宏,它指向参数堆栈上的第n'th个参数,因此ST(0)是堆栈上的第一个参数,因此传递给XSUB的第一个参数,ST(1)是第二个参数,等等。因此,ST(0)是堆栈中的第一个参数,因此也是传递给XSUB的第一个参数,ST(1)是第二个参数,以此类推。</target>
        </trans-unit>
        <trans-unit id="b4b727c2115d816f7a5edf98b373babd311821be" translate="yes" xml:space="preserve">
          <source>If we replace the &lt;code&gt; (?{local $c = $c + 1;})&lt;/code&gt; with &lt;code&gt; (?{$c = $c + 1;})&lt;/code&gt;, the variable changes are</source>
          <target state="translated">如果我们将 &lt;code&gt; (?{local $c = $c + 1;})&lt;/code&gt; 替换为 &lt;code&gt; (?{$c = $c + 1;})&lt;/code&gt; ，则变量更改为</target>
        </trans-unit>
        <trans-unit id="6b22701c7de1c1b18f83a3da253320877e6db57e" translate="yes" xml:space="preserve">
          <source>If we want to call the function in scalar context, we have to do a bit more work. We can really have any code we like inside the braces, so we simply have to end with the scalar reference, although how you do that is up to you, and you can use code inside the braces. Note that the use of parens creates a list context, so we need &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; to force the scalar context on the function:</source>
          <target state="translated">如果要在标量上下文中调用该函数，则必须做更多的工作。我们实际上可以在花括号内包含任何我们喜欢的代码，因此我们只需要以标量引用结尾，尽管您的操作取决于您自己，并且可以在花括号内使用代码。请注意，使用parens会创建一个列表上下文，因此我们需要 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 才能将标量上下文强制应用于该函数：</target>
        </trans-unit>
        <trans-unit id="2aa4af82f261a5bfccad859728bbc5e698f2ad5a" translate="yes" xml:space="preserve">
          <source>If we want to sort by the hash value instead, we use the hash key to look it up. We still get out a list of keys, but this time they are ordered by their value.</source>
          <target state="translated">如果我们想改用哈希值排序,我们就用哈希键来查找。我们仍然会得到一个键的列表,但这次是按其值排序。</target>
        </trans-unit>
        <trans-unit id="1a0a23be20e0afdc53dc3805694c934e04c1d63f" translate="yes" xml:space="preserve">
          <source>If we wanted to include the mp3's title in the greeting, we could override the method:</source>
          <target state="translated">如果我们想在问候语中包含mp3的标题,我们可以覆盖这个方法。</target>
        </trans-unit>
        <trans-unit id="215abf71d62aea6c4bacd7ab63842ca42cbc8d09" translate="yes" xml:space="preserve">
          <source>If we were interested in performance, not in code compactness, in the success branch we would not use &lt;code&gt;XPUSHs&lt;/code&gt; macros, but &lt;code&gt;PUSHs&lt;/code&gt; macros, and would pre-extend the stack before pushing the return values:</source>
          <target state="translated">如果我们对性能感兴趣，而不是对代码紧凑性感兴趣，那么在成功分支中，我们将不使用 &lt;code&gt;XPUSHs&lt;/code&gt; 宏，而使用 &lt;code&gt;PUSHs&lt;/code&gt; 宏，并在推送返回值之前预先扩展堆栈：</target>
        </trans-unit>
        <trans-unit id="ed55ede23a733b9689b8f241805b425f9dc0c341" translate="yes" xml:space="preserve">
          <source>If we've done things right, you'll probably want to write a new source, rather than sub-classing this (see &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; for that).</source>
          <target state="translated">如果我们做对了，您可能想编写一个新的源代码，而不是对其进行子类化（请参阅&lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="433a6e7876c97a91d0108a2079322b6917a252c6" translate="yes" xml:space="preserve">
          <source>If what the angle brackets contain is a simple scalar variable (for example, &lt;code&gt;$foo&lt;/code&gt; ), then that variable contains the name of the filehandle to input from, or its typeglob, or a reference to the same. For example:</source>
          <target state="translated">如果尖括号中包含的是一个简单的标量变量（例如 &lt;code&gt;$foo&lt;/code&gt; ），则该变量包含要从中输入的文件句柄的名称，其句柄或对它的引用。例如：</target>
        </trans-unit>
        <trans-unit id="0b51d046d4f4e47130f90dab13b7fc186caff6e3" translate="yes" xml:space="preserve">
          <source>If what's within the angle brackets is neither a filehandle nor a simple scalar variable containing a filehandle name, typeglob, or typeglob reference, it is interpreted as a filename pattern to be globbed, and either a list of filenames or the next filename in the list is returned, depending on context. This distinction is determined on syntactic grounds alone. That means &lt;code&gt;&amp;lt;$x&amp;gt;&lt;/code&gt; is always a &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; from an indirect handle, but &lt;code&gt;&amp;lt;$hash{key}&amp;gt;&lt;/code&gt; is always a &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt;. That's because &lt;code&gt;$x&lt;/code&gt; is a simple scalar variable, but &lt;code&gt;$hash{key}&lt;/code&gt; is not--it's a hash element. Even &lt;code&gt;&amp;lt;$x &amp;gt;&lt;/code&gt; (note the extra space) is treated as &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;$x &quot;)&lt;/code&gt; , not &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline($x)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果尖括号中的内容既不是文件句柄，也不是包含文件句柄名称，typeglob或typeglob引用的简单标量变量，则它将被解释为要被文件化的文件名模式，以及文件名列表或列表中的下一个文件名返回，具体取决于上下文。这种区别仅基于句法基础来确定。这意味着 &lt;code&gt;&amp;lt;$x&amp;gt;&lt;/code&gt; 始终是间接句柄的 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; ，而 &lt;code&gt;&amp;lt;$hash{key}&amp;gt;&lt;/code&gt; 始终是 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; 。这是因为 &lt;code&gt;$x&lt;/code&gt; 是一个简单的标量变量，但是 &lt;code&gt;$hash{key}&lt;/code&gt; 不是-它是一个哈希元素。即使 &lt;code&gt;&amp;lt;$x &amp;gt;&lt;/code&gt; （请注意多余的空格）也被视为 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;$x &quot;)&lt;/code&gt; ，不 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline($x)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b842d8a427447b55d56f0f86ffb1407d7bbf70b" translate="yes" xml:space="preserve">
          <source>If whitespace is mostly irrelevant, how does one include space characters in an extended regexp? The answer is to backslash it &lt;code&gt;'\ '&lt;/code&gt; or put it in a character class &lt;code&gt;[ ]&lt;/code&gt; . The same thing goes for pound signs: use &lt;code&gt;\#&lt;/code&gt; or &lt;code&gt;[#]&lt;/code&gt;. For instance, Perl allows a space between the sign and the mantissa or integer, and we could add this to our regexp as follows:</source>
          <target state="translated">如果空白大部分无关紧要，那么如何在扩展的正则表达式中包含空格字符？答案是将其反斜杠 &lt;code&gt;'\ '&lt;/code&gt; 或放在字符类 &lt;code&gt;[ ]&lt;/code&gt; 。英镑符号也是如此：使用 &lt;code&gt;\#&lt;/code&gt; 或 &lt;code&gt;[#]&lt;/code&gt; 。例如，Perl在符号和尾数或整数之间允许一个空格，我们可以按如下所示将其添加到正则表达式中：</target>
        </trans-unit>
        <trans-unit id="0ac523288e8907db49cd44aeec42c46983d54f41" translate="yes" xml:space="preserve">
          <source>If you</source>
          <target state="translated">如果你</target>
        </trans-unit>
        <trans-unit id="a97a499d1638eac60812016983597e71f2e68467" translate="yes" xml:space="preserve">
          <source>If you &quot;mmap&quot; the file with the File::Map module from CPAN, you can virtually load the entire file into a string without actually storing it in memory:</source>
          <target state="translated">如果你使用CPAN的File::Map模块对文件进行 &quot;mmap&quot;,你实际上可以将整个文件加载到一个字符串中,而无需实际存储在内存中。</target>
        </trans-unit>
        <trans-unit id="e9fdf3b9fc81571db27bb02cd29a8e0b53b10cc5" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; without ever waiting on your children, you will accumulate zombies. On some systems, you can avoid this by setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . See also &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for more examples of forking and reaping moribund children.</source>
          <target state="translated">如果您在没有等待孩子的情况下进行 &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; ，则会堆积僵尸。在某些系统上，可以通过将 &lt;code&gt;$SIG{CHLD}&lt;/code&gt; 为 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 来避免这种情况。另请参阅&lt;a href=&quot;../perlipc&quot;&gt;perlipc，&lt;/a&gt;以了解更多分叉和收养垂死儿童的例子。</target>
        </trans-unit>
        <trans-unit id="3342529f369584d116691354aca02d8a637cdc3f" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; without ever waiting on your children, you will accumulate zombies. On some systems, you can avoid this by setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . See also &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more examples of forking and reaping moribund children.</source>
          <target state="translated">如果您在没有等待孩子的情况下进行 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; ，则会堆积僵尸。在某些系统上，可以通过将 &lt;code&gt;$SIG{CHLD}&lt;/code&gt; 为 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 来避免这种情况。另请参阅&lt;a href=&quot;perlipc&quot;&gt;perlipc，&lt;/a&gt;以了解更多分叉和收养垂死儿童的例子。</target>
        </trans-unit>
        <trans-unit id="bb90d14b290d4320ac5634dcbc5bece03b18182e" translate="yes" xml:space="preserve">
          <source>If you actually need to be able to get a real reference back from each hash entry, you can use the Tie::RefHash module, which does the required work for you.</source>
          <target state="translated">如果你真的需要能够从每个哈希条目中得到一个真实的引用,你可以使用Tie::RefHash模块,它可以为你完成所需的工作。</target>
        </trans-unit>
        <trans-unit id="0863c378529bcaaf05a08fbe7b9d62fcdd40f533" translate="yes" xml:space="preserve">
          <source>If you actually want to bless into the stringified version of the reference supplied, you need to stringify it yourself, for example by:</source>
          <target state="translated">如果你真的想祝福到所提供的引用的字符串化版本,你需要自己对它进行字符串化,例如通过。</target>
        </trans-unit>
        <trans-unit id="7632fd79ddaeaed4fd83611844af65a8558ccb38" translate="yes" xml:space="preserve">
          <source>If you actually want to pack Unicode codepoints, use the &lt;code&gt;&quot;U&quot;&lt;/code&gt; format instead.</source>
          <target state="translated">如果您实际上要打包Unicode代码点，请改用 &lt;code&gt;&quot;U&quot;&lt;/code&gt; 格式。</target>
        </trans-unit>
        <trans-unit id="30a06cdba55cf94e2b0d8887615268f65da700c2" translate="yes" xml:space="preserve">
          <source>If you add the &lt;code&gt;stringify&lt;/code&gt; import option to your &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; declaration, then using a threads object in a string or a string context (e.g., as a hash key) will cause its ID to be used as the value:</source>
          <target state="translated">如果在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 线程声明中添加 &lt;code&gt;stringify&lt;/code&gt; import选项，则在字符串或字符串上下文中使用线程对象（例如，作为哈希键）将导致其ID用作值：</target>
        </trans-unit>
        <trans-unit id="77f0b688e7f7db776b8a41a0294b1be395b96046" translate="yes" xml:space="preserve">
          <source>If you already have the data in memory or if you want to keep your code simple, you can use one of the sv_cat*() variants, such as sv_catpvn(). If you want to insert anywhere in the string you can use sv_insert() or sv_insert_flags().</source>
          <target state="translated">如果你已经在内存中拥有数据,或者你想保持你的代码简单,你可以使用sv_cat*()的一个变体,比如sv_catpvn()。如果你想在字符串的任何地方插入,你可以使用sv_insert()或sv_insert_flags()。</target>
        </trans-unit>
        <trans-unit id="d0e6e027d69f3e21d5d8d4eaafdf5a18b7a271a0" translate="yes" xml:space="preserve">
          <source>If you also specify the &lt;code&gt;save&lt;/code&gt; option newly passing tests will be excluded from subsequent runs.</source>
          <target state="translated">如果您还指定 &lt;code&gt;save&lt;/code&gt; 选项，则新的通过测试将从随后的运行中排除。</target>
        </trans-unit>
        <trans-unit id="f2315b4f443374dc91536026901e2322007448a6" translate="yes" xml:space="preserve">
          <source>If you alter your @_ arguments in a subroutine (such as with &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;), the stack backtrace will not show the original values.</source>
          <target state="translated">如果您在子例程中更改@_参数（例如使用 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; ），则堆栈回溯将不显示原始值。</target>
        </trans-unit>
        <trans-unit id="bcce70763746b8ab89abce0fda8214efc82356bb" translate="yes" xml:space="preserve">
          <source>If you are accustomed to using perl from various command-line shells found in UNIX environments, you will be less than pleased with what Windows offers by way of a command shell.</source>
          <target state="translated">如果你习惯于从UNIX环境中的各种命令行shell中使用perl,那么你会对Windows提供的命令行shell不甚满意。</target>
        </trans-unit>
        <trans-unit id="75851b1a6055f8c9601d27bb8e4f2638f62e5f5e" translate="yes" xml:space="preserve">
          <source>If you are advanced enough with building C code, here is a suggestion to speed up building perl, and the later &lt;code&gt;make test&lt;/code&gt; . Try to keep your PATH enviromental variable with the least number of folders possible (remember to keep your C compiler's folders there). &lt;code&gt;C:\WINDOWS\system32&lt;/code&gt; or &lt;code&gt;C:\WINNT\system32&lt;/code&gt; depending on your OS version should be first folder in PATH, since &quot;cmd.exe&quot; is the most commonly launched program during the build and later testing.</source>
          <target state="translated">如果您对构建C代码有足够的了解，建议您加快构建Perl的速度，稍后再 &lt;code&gt;make test&lt;/code&gt; 。尝试使PATH环境变量的文件夹数尽可能少（请记住，将C编译器的文件夹保留在此处）。根据操作系统的版本， &lt;code&gt;C:\WINDOWS\system32&lt;/code&gt; 或 &lt;code&gt;C:\WINNT\system32&lt;/code&gt; 应该是PATH中的第一个文件夹，因为&amp;ldquo; cmd.exe&amp;rdquo;是在构建和后续测试过程中最常启动的程序。</target>
        </trans-unit>
        <trans-unit id="9e6e47c6af55350e3bd275924a9467fa5be92cb6" translate="yes" xml:space="preserve">
          <source>If you are author of a package and wonder if your $VERSION can be parsed, please try the above method.</source>
          <target state="translated">如果你是一个包的作者,不知道你的$VERSION是否可以被解析,请尝试以上方法。</target>
        </trans-unit>
        <trans-unit id="e9341f5fe0aca50dc1a438efa6a2a0829ec331a7" translate="yes" xml:space="preserve">
          <source>If you are building Perl from source, the Perl test suite file</source>
          <target state="translated">如果你是从源码中构建Perl,那么Perl测试套件文件中的</target>
        </trans-unit>
        <trans-unit id="fd709122178ec9749d3b052901d53a7e7c059f96" translate="yes" xml:space="preserve">
          <source>If you are calling &lt;b&gt;pod2usage()&lt;/b&gt; from a module and want to display that module's POD, you can use this:</source>
          <target state="translated">如果要从模块调用&lt;b&gt;pod2usage（）&lt;/b&gt;并想显示该模块的POD，则可以使用以下命令：</target>
        </trans-unit>
        <trans-unit id="f5b3eed9ee23b3eafd899b21c185d1c6a6521682" translate="yes" xml:space="preserve">
          <source>If you are careful, it is possible to mix API calls with the tied hash/array interface in the same piece of code. Although only a few of the methods used to implement the tied interface currently make use of the cursor, you should always assume that the cursor has been changed any time the tied hash/array interface is used. As an example, this code will probably not do what you expect:</source>
          <target state="translated">如果你小心的话,可以在同一段代码中混合使用API调用和绑定的哈希/数组接口。虽然目前只有少数用于实现绑定接口的方法使用了游标,但在使用绑定的哈希/数组接口时,你应该始终假设游标已经被改变。作为一个例子,这段代码可能不会像你期望的那样。</target>
        </trans-unit>
        <trans-unit id="46443ee64846124969f99d9a251a1b5c33defa28" translate="yes" xml:space="preserve">
          <source>If you are coming here because code of yours is being adversely affected by someone's use of this variable, you can usually work around it by doing this:</source>
          <target state="translated">如果你来这里是因为你的代码被别人使用了这个变量而受到不利影响,你通常可以通过这样做来解决。</target>
        </trans-unit>
        <trans-unit id="580a992ac4c85198002e3da1ab0af0114ef2843d" translate="yes" xml:space="preserve">
          <source>If you are compiling Perl on a remotely-mounted NFS filesystem, the test io/fs.t may fail on test #18. This appears to be a bug in HP-UX and no fix is currently available.</source>
          <target state="translated">如果你在远程安装的NFS文件系统上编译Perl,测试io/fs.t可能会在测试#18中失败。这似乎是HP-UX中的一个错误,目前还没有修复。</target>
        </trans-unit>
        <trans-unit id="3b33c19354a1a90e2387b434d12153c90f20f627" translate="yes" xml:space="preserve">
          <source>If you are compiling in PASE, then &quot;make install&quot; is the only thing you will need to do.</source>
          <target state="translated">如果你是用PASE编译,那么 &quot;make install &quot;是你唯一需要做的事情。</target>
        </trans-unit>
        <trans-unit id="81413ae9ed04e602e1a5e2aa34f9a9228c164afc" translate="yes" xml:space="preserve">
          <source>If you are compiling on AIX, simply do a &quot;make install&quot; on the AIX box. Once the install finishes, tar up the /QOpenSys/perl directory. Transfer the tarball to the OS/400 using FTP with the following commands:</source>
          <target state="translated">如果你是在AIX上编译,只需在AIX上进行 &quot;make install&quot;。一旦安装完成,将/QOpenSys/perl目录用tar压缩。使用下面的命令将 tar 包传输到 OS/400。</target>
        </trans-unit>
        <trans-unit id="24c32dcfc58ac17c09099d20bc9bc3a8e41bba8b" translate="yes" xml:space="preserve">
          <source>If you are content with the test result, just &quot;make install&quot;</source>
          <target state="translated">如果你对测试结果感到满意,只要 &quot;make install&quot;</target>
        </trans-unit>
        <trans-unit id="aa6a61423fd16b04dc17486be56b73db7a8c3506" translate="yes" xml:space="preserve">
          <source>If you are creating a PerlIO layer, you may want to be lazy, in other words, implement only the methods that interest you. The other methods you can either replace with the &quot;blank&quot; methods</source>
          <target state="translated">如果你正在创建一个PerlIO层,你可能想偷懒,换句话说,只实现你感兴趣的方法。其他的方法你可以用 &quot;空白 &quot;的方法来代替。</target>
        </trans-unit>
        <trans-unit id="4b2de75d9b2a463fc1f9325a0ae503a9f6861718" translate="yes" xml:space="preserve">
          <source>If you are developing a suite of related modules/classes it's good practice to use nested classes with a common prefix as this will avoid namespace clashes. For example: Xyz::Control, Xyz::View, Xyz::Model etc. Use the modules in this list as a naming guide.</source>
          <target state="translated">如果你正在开发一套相关的模块/类,最好的做法是使用具有共同前缀的嵌套类,这样可以避免命名空间的冲突。例如:Xyz::Control,Xyz::View,Xyz::View Xyz::Control,Xyz::View,Xyz::Model等。使用这个列表中的模块作为命名指南。</target>
        </trans-unit>
        <trans-unit id="cf3f54058ec5c3861eafa70f589fb5c16feca4d3" translate="yes" xml:space="preserve">
          <source>If you are doing a blocking &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread()&lt;/a&gt;&lt;/code&gt;, you'll have to arrange for an alarm handler to provide a timeout (see &lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;). If you have a non-blocking open, you'll likely have a non-blocking read, which means you may have to use a 4-arg &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; to determine whether I/O is ready on that device (see &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;.</source>
          <target state="translated">如果要执行阻塞的 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread()&lt;/a&gt;&lt;/code&gt; ，则必须安排警报处理程序以提供超时（请参阅&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;）。如果您打开的是非阻塞状态，则很可能会进行非阻塞读取，这意味着您可能必须使用4-arg &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 来确定该设备上的I / O是否准备就绪（请参见&lt;a href=&quot;functions/select&quot;&gt;select）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27eb5f2751e7b3c976fa3693eb1b047c9ea468b5" translate="yes" xml:space="preserve">
          <source>If you are doing something complex, such as moving through many pages and forms or a web site, you can use &lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW::Mechanize&lt;/a&gt;. See its documentation for all the details.</source>
          <target state="translated">如果您正在做复杂的事情，例如浏览许多页面和表单或一个网站，则可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW :: Mechanize&lt;/a&gt;。有关所有详细信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="1a9b4d7923308acf7ee68c13a2cd11f90f3c70ce" translate="yes" xml:space="preserve">
          <source>If you are experiencing variable suicide, that &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; in the subroutine doesn't pick up a fresh copy of the &lt;code&gt;$f&lt;/code&gt; whose value is &lt;code&gt;'foo'&lt;/code&gt; . The output shows that inside the subroutine the value of &lt;code&gt;$f&lt;/code&gt; leaks through when it shouldn't, as in this output:</source>
          <target state="translated">如果您遇到变量自杀，那 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; 在子程序不拿起的全新副本 &lt;code&gt;$f&lt;/code&gt; ，其值是 &lt;code&gt;'foo'&lt;/code&gt; 。输出显示，在子例程中， &lt;code&gt;$f&lt;/code&gt; 的值在不应该泄漏的情况下泄漏，如下所示：</target>
        </trans-unit>
        <trans-unit id="bbeae6d94c0568a9909c55582ce46133df1b3000" translate="yes" xml:space="preserve">
          <source>If you are familiar with the</source>
          <target state="translated">如果你熟悉</target>
        </trans-unit>
        <trans-unit id="09b5540260d1429f031cae6d4fea34d1c0219ed0" translate="yes" xml:space="preserve">
          <source>If you are forking many processes in parallel that are all creating temporary files, you may need to reset the random number seed using srand(EXPR) in each child else all the children will attempt to walk through the same set of random file names and may well cause themselves to give up if they exceed the number of retry attempts.</source>
          <target state="translated">如果你正在并行分叉许多进程,这些进程都在创建临时文件,你可能需要在每个子进程中使用srand(EXPR)重置随机数种子,否则所有的子进程都会尝试走过同一组随机文件名,如果它们超过了重试次数,很可能导致自己放弃。</target>
        </trans-unit>
        <trans-unit id="79eaecd3ef824520bc14f0a6f551bc580fb007f0" translate="yes" xml:space="preserve">
          <source>If you are going to convert the script to a module you can use the opportunity to redesign the interface. The guidelines for module creation above include many of the issues you should consider.</source>
          <target state="translated">如果你要把脚本转换为模块,你可以利用这个机会重新设计界面。上面的模块创建指南包括了许多你应该考虑的问题。</target>
        </trans-unit>
        <trans-unit id="37c8864889db08a398c2a1fd61fb5557dd86b1b1" translate="yes" xml:space="preserve">
          <source>If you are going to put something onto the Perl stack, you need to know where to put it. This is the purpose of the macro &lt;code&gt;dSP&lt;/code&gt; --it declares and initializes a</source>
          <target state="translated">如果要将东西放到Perl堆栈上，则需要知道将它放到哪里。这是宏 &lt;code&gt;dSP&lt;/code&gt; 的目的-它声明并初始化一个</target>
        </trans-unit>
        <trans-unit id="0cf3f133791811ca9201975358ebf1e226d3c50a" translate="yes" xml:space="preserve">
          <source>If you are going to use the HP DCE package, the library used for threading is /usr/lib/libcma.sl, but there have been multiple updates of that library over time. Perl will build with the first version, but it will not pass the test suite. Older Oracle versions might be a compelling reason not to update that library, otherwise please find a newer version in one of the following patches: PHSS_19739, PHSS_20608, or PHSS_23672</source>
          <target state="translated">如果你要使用HP DCE包,用于线程的库是/usr/lib/libcma.sl,但随着时间的推移,该库有过多次更新。Perl会用第一个版本来构建,但它不会通过测试套件。较旧的 Oracle 版本可能是不更新该库的一个令人信服的理由,否则请在以下补丁中找到一个较新的版本。PHSS_19739,PHSS_20608,或 PHSS_23672。</target>
        </trans-unit>
        <trans-unit id="330882464199f1a0851acc4b79e3a966cdc91c15" translate="yes" xml:space="preserve">
          <source>If you are going to use this method you have to be aware of a possible memory leak which can arise under very specific circumstances. To explain these circumstances you need to know a bit about the flow of control between Perl and the callback routine.</source>
          <target state="translated">如果你要使用这个方法,你必须意识到在非常特殊的情况下可能出现的内存泄漏。为了解释这些情况,你需要了解一下Perl和回调例程之间的控制流。</target>
        </trans-unit>
        <trans-unit id="91073f8278c247bf05c5742a59e2d0906bf12cbd" translate="yes" xml:space="preserve">
          <source>If you are going to write a platform specific MM package, please try to limit the necessary overrides to primitive methods, and if it is not possible to do so, let's work out how to achieve that gain.</source>
          <target state="translated">如果你要写一个特定平台的MM包,请尽量把必要的覆盖限制在原始方法上,如果做不到,我们就想办法实现这个收益。</target>
        </trans-unit>
        <trans-unit id="3470649433d76902fec9be392ea404a581213006" translate="yes" xml:space="preserve">
          <source>If you are having trouble with square brackets then consider switching your rlogin or telnet client. Try to avoid older 3270 emulators and ISHELL for working with Perl on USS.</source>
          <target state="translated">如果你在使用方括号时有问题,那么可以考虑换一个rlogin或者telnet客户端。在USS上使用Perl时,尽量避免使用老的3270模拟器和ISHELL。</target>
        </trans-unit>
        <trans-unit id="be777d0c50e7b77da7283f3ff8a7e540b7f7344c" translate="yes" xml:space="preserve">
          <source>If you are in any doubt about the license situation, contact either the Berkeley DB authors or the author of DB_File. See &lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt; for details.</source>
          <target state="translated">如果您对许可情况有任何疑问，请与Berkeley DB作者或DB_File作者联系。有关详细信息，请参见&lt;a href=&quot;#AUTHOR&quot;&gt;作者&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99320978b9537887ebc85e1dfd4bdf0910cbc812" translate="yes" xml:space="preserve">
          <source>If you are in doubt which package contains a file you are missing, try to find an installation that has that file. Then do a</source>
          <target state="translated">如果你不确定哪个软件包中包含了你所缺少的文件,请尝试找到一个有该文件的安装。然后执行</target>
        </trans-unit>
        <trans-unit id="92276bc0e44e1b658a5288e18f73cfbd284b63bb" translate="yes" xml:space="preserve">
          <source>If you are intending to manipulate bitstrings, be certain that you're supplying bitstrings: If an operand is a number, that will imply a &lt;b&gt;numeric&lt;/b&gt; bitwise operation. You may explicitly show which type of operation you intend by using &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;0+&lt;/code&gt; , as in the examples below.</source>
          <target state="translated">如果要操纵位串，请确保要提供位串：如果操作数是数字，则表示&lt;b&gt;数字&lt;/b&gt;按位运算。您可以使用 &lt;code&gt;&quot;&quot;&lt;/code&gt; 或 &lt;code&gt;0+&lt;/code&gt; 明确显示您打算使用哪种类型的操作，如以下示例所示。</target>
        </trans-unit>
        <trans-unit id="a0e74d8ccd8d67f221dc38d69397982438ef8887" translate="yes" xml:space="preserve">
          <source>If you are interested in the guts underlying these systems, check out &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">如果您对这些系统的内在结构感兴趣，请查看&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f81bce975381ffe867c89af365021d38913e30eb" translate="yes" xml:space="preserve">
          <source>If you are interested in the z/OS (formerly known as OS/390) and POSIX-BC (BS2000) ports of Perl then see the perl-mvs mailing list. To subscribe, send an empty message to perl-mvs-subscribe@perl.org.</source>
          <target state="translated">如果您对 Perl 的 z/OS (以前称为 OS/390)和 POSIX-BC (BS2000)端口感兴趣,请参见 perl-mvs 邮件列表。要订阅,请发送空邮件到 perl-mvs-subscribe@perl.org。</target>
        </trans-unit>
        <trans-unit id="38d9bbb97bd39f15f79a0ad6f3bd53d77bb54ef1" translate="yes" xml:space="preserve">
          <source>If you are looking for a &quot;bar&quot; that isn't preceded by a &quot;foo&quot;, &lt;code&gt;/(?!foo)bar/&lt;/code&gt; will not do what you want. That's because the &lt;code&gt;(?!foo)&lt;/code&gt; is just saying that the next thing cannot be &quot;foo&quot;--and it's not, it's a &quot;bar&quot;, so &quot;foobar&quot; will match. Use look-behind instead (see below).</source>
          <target state="translated">如果您要查找的&amp;ldquo; bar&amp;rdquo;前面没有&amp;ldquo; foo&amp;rdquo;，则 &lt;code&gt;/(?!foo)bar/&lt;/code&gt; 不会做您想要的事情。这是因为 &lt;code&gt;(?!foo)&lt;/code&gt; 只是说下一个东西不能是&amp;ldquo; foo&amp;rdquo;，不是，它是&amp;ldquo; bar&amp;rdquo;，因此&amp;ldquo; foobar&amp;rdquo;将匹配。改用后向（见下文）。</target>
        </trans-unit>
        <trans-unit id="f20427718038bfba8c53137f8646eb9abfc2ff46" translate="yes" xml:space="preserve">
          <source>If you are looking for a class that does everything for you you don't define yourself, use the &lt;code&gt;Tie::StdScalar&lt;/code&gt; class, not the &lt;code&gt;Tie::Scalar&lt;/code&gt; one.</source>
          <target state="translated">如果您正在寻找一个可以为您做所有事情的类，但您自己没有定义自己，请使用 &lt;code&gt;Tie::StdScalar&lt;/code&gt; 类，而不要使用 &lt;code&gt;Tie::Scalar&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="7787fb3feb00a627232c8ef4ce3954c9d7deed73" translate="yes" xml:space="preserve">
          <source>If you are looking for a table of contents to the Perl library modules documentation, see the &lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc&lt;/a&gt; page.</source>
          <target state="translated">如果要在Perl库模块文档中查找目录，请参阅&lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc&lt;/a&gt;页面。</target>
        </trans-unit>
        <trans-unit id="3fac826063cfc00ef4ae02f7626b0848d723ad5d" translate="yes" xml:space="preserve">
          <source>If you are looking for an example, I recommend that you look at the simple example in the Memoize::Expire documentation, or at the code for Memoize::Expire itself.</source>
          <target state="translated">如果你想找一个例子,我建议你看看 Memoize::Expire 文档中的简单例子,或者 Memoize::Expire 本身的代码。</target>
        </trans-unit>
        <trans-unit id="b33652a525614ae7d89321a43fb11331d7e5b6fa" translate="yes" xml:space="preserve">
          <source>If you are making use of the Perl stack pointer in your code you must always refresh the local copy using SPAGAIN whenever you make use of the</source>
          <target state="translated">如果你在代码中使用Perl堆栈指针,你必须在每次使用了</target>
        </trans-unit>
        <trans-unit id="0468c5bae6319f4655b5720508b9d190b598ea2a" translate="yes" xml:space="preserve">
          <source>If you are on a Unix-like system, you might be able to get away with a system call where you put an &lt;code&gt;&amp;amp;&lt;/code&gt; on the end of the command:</source>
          <target state="translated">如果您使用的是类似Unix的系统，则可以通过在命令末尾添加 &lt;code&gt;&amp;amp;&lt;/code&gt; 的系统调用来摆脱困境：</target>
        </trans-unit>
        <trans-unit id="74fb92ccab7935bd1e0cc2c8300a7bef29eb75de" translate="yes" xml:space="preserve">
          <source>If you are on a non-UNIX platform &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;, as some features may be unimplemented or work differently.</source>
          <target state="translated">如果您在非UNIX平台上的&lt;b&gt;perldoc &lt;/b&gt;&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;，则某些功能可能未实现或工作方式不同。</target>
        </trans-unit>
        <trans-unit id="5f59ff52a71652ecb89231c85ecae2ce17688eb9" translate="yes" xml:space="preserve">
          <source>If you are on a system that correctly implements &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; and you use the example appending code from &quot;perldoc -f flock&quot; everything will be OK even if the OS you are on doesn't implement append mode correctly (if such a system exists). So if you are happy to restrict yourself to OSs that implement &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; (and that's not really much of a restriction) then that is what you should do.</source>
          <target state="translated">如果您使用的系统正确实现了 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; ,并且使用了来自&amp;ldquo; perldoc -f flock&amp;rdquo;的示例附加代码示例，那么即使您所使用的操作系统未正确实现附加模式（如果存在这样的系统），一切都可以。因此，如果您很乐意将自己限制在实现 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 操作系统上（这实际上并不是很大的限制），那么您应该这样做。</target>
        </trans-unit>
        <trans-unit id="54d7fa3e38420fc843370b116c9be081ea5603e0" translate="yes" xml:space="preserve">
          <source>If you are only exporting function names it is recommended to omit the ampersand, as the implementation is faster this way.</source>
          <target state="translated">如果你只输出函数名,建议省略安培符,因为这样执行起来更快。</target>
        </trans-unit>
        <trans-unit id="2de91fd61e5dabce87e62b432c1af2d2e0384486" translate="yes" xml:space="preserve">
          <source>If you are overriding any of these methods in your Makefile.PL (in the MY class), please report that to the makemaker mailing list. We are trying to minimize the necessary method overrides and switch to data driven Makefile.PLs wherever possible. In the long run less methods will be overridable via the MY class.</source>
          <target state="translated">如果你在你的Makefile.PL中(在MY类中)覆盖了这些方法,请向makemaker邮件列表报告。我们正在努力减少必要的方法重写,并尽可能地转向数据驱动的Makefile.PLs。从长远来看,通过MY类可重写的方法将会减少。</target>
        </trans-unit>
        <trans-unit id="25095e5b9b6ab11015f95ba50809b8be1a58758d" translate="yes" xml:space="preserve">
          <source>If you are particularly interested in customizing this module's output even more, see the source and/or write to me.</source>
          <target state="translated">如果你对自定义这个模块的输出特别感兴趣,请看源码和/或写信给我。</target>
        </trans-unit>
        <trans-unit id="d40865e3f4f814dc75edbc20fbc8762037c6c824" translate="yes" xml:space="preserve">
          <source>If you are printing IVs, UVs, or NVS instead of the stdio(3) style formatting codes like &lt;code&gt;%d&lt;/code&gt; , &lt;code&gt;%ld&lt;/code&gt; , &lt;code&gt;%f&lt;/code&gt; , you should use the following macros for portability</source>
          <target state="translated">如果要打印IV，UV或NVS而不是诸如 &lt;code&gt;%d&lt;/code&gt; ， &lt;code&gt;%ld&lt;/code&gt; ， &lt;code&gt;%f&lt;/code&gt; 之类的stdio（3）样式格式代码，则应使用以下宏来实现可移植性</target>
        </trans-unit>
        <trans-unit id="b082a380f246d61dd682cd511f2ea77809e32735" translate="yes" xml:space="preserve">
          <source>If you are printing addresses of pointers, use UVxf combined with PTR2UV(), do not use %lx or %p.</source>
          <target state="translated">如果要打印指针的地址,请使用UVxf结合PTR2UV(),不要使用%lx或%p。</target>
        </trans-unit>
        <trans-unit id="b6f4ed221243b9dde4f0f2cc29b067e485bbf822" translate="yes" xml:space="preserve">
          <source>If you are reading this documentation, looking for a replacement for the &lt;code&gt;FileHandle&lt;/code&gt; package, then I suggest you read the documentation for &lt;code&gt;IO::File&lt;/code&gt; too.</source>
          <target state="translated">如果您正在阅读本文档，寻找 &lt;code&gt;FileHandle&lt;/code&gt; 包的替代品，那么我建议您也阅读 &lt;code&gt;IO::File&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="8c40246fed4e0a31f96c46a72d0a85e56bbe29c3" translate="yes" xml:space="preserve">
          <source>If you are reading this in the future then it's possible that the state of the art has changed. We recommend you start by reading the perlootut document in the latest stable release of Perl, rather than this version.</source>
          <target state="translated">如果你是在未来阅读这篇文章,那么有可能技术状态已经发生了变化。我们建议你先阅读Perl最新稳定版中的perlootut文档,而不是这个版本。</target>
        </trans-unit>
        <trans-unit id="d0add6c557074aa94dbce442362b0e5da76c5396" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Bzip2 can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您正在运行Perl 5.005或更高版本，则从IO :: Compress :: Bzip2返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输出文件操作。例如，要写入压缩文件/缓冲区，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="b7e4df4e4f27db0bf9a46e2a1941e85758d61068" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Deflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您运行的是Perl 5.005或更高版本，则从IO :: Compress :: Deflate返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输出文件操作。例如，要写入压缩文件/缓冲区，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="41e65ffc69fed189ecd525fba0988f92db4e7035" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Gzip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果运行的是Perl 5.005或更高版本，则从IO :: Compress :: Gzip返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输出文件操作。例如，要写入压缩文件/缓冲区，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="c6b6ef257ae9881b6bd3fd8eaa22b1a4c05c99ca" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::RawDeflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您运行的是Perl 5.005或更高版本，则从IO :: Compress :: RawDeflate返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输出文件操作。例如，要写入压缩文件/缓冲区，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="3c423a94c7fc5cb61812044d70c6c094354f683a" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Zip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果运行的是Perl 5.005或更高版本，则从IO :: Compress :: Zip返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输出文件操作。例如，要写入压缩文件/缓冲区，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="5fea5722273a1695c99b2d6f3f73bb1257cd24c3" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::AnyInflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您运行的是Perl 5.005或更高版本，则从IO :: Uncompress :: AnyInflate返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="b2972d5cdbb1eb98b989631b3ded397e40e59e75" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::AnyUncompress can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果运行的是Perl 5.005或更高版本，则从IO :: Uncompress :: AnyUncompress返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="18aa1921698d337e93a7e4edaa2b66e95de457bf" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Bunzip2 can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果运行的是Perl 5.005或更高版本，则从IO :: Uncompress :: Bunzip2返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="f86eb994b5def7f39f87b382b570ded31372309e" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Gunzip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您正在运行Perl 5.005或更高版本，则从IO :: Uncompress :: Gunzip返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="05ab40d4db9fa577fb79380b48870abe52f5c6be" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Inflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您运行的是Perl 5.005或更高版本，则从IO :: Uncompress :: Inflate返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="d70a4ecbd7bb1c964123dba102fe8a49b561cb00" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::RawInflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您运行的是Perl 5.005或更高版本，则从IO :: Uncompress :: RawInflate返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="3608890b582bffd465c544ac9e831ad2b06501a0" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Unzip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">如果您正在运行Perl 5.005或更高版本，则从IO :: Uncompress :: Unzip返回的对象 &lt;code&gt;$z&lt;/code&gt; 可以像&lt;a href=&quot;../file&quot;&gt;IO :: File文件&lt;/a&gt;句柄一样使用。这意味着可以使用 &lt;code&gt;$z&lt;/code&gt; 来执行所有正常的输入文件操作。例如，要从压缩文件/缓冲区读取一行，可以使用以下两种格式之一</target>
        </trans-unit>
        <trans-unit id="89f53b731da5c3618fcf6d87c9434da7f9ed2f65" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.6.0 or better, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma allows fine control of what warnings are produced. See &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; for more details.</source>
          <target state="translated">如果您运行的是Perl 5.6.0或更高版本，则 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 编译指示可以精确控制产生的警告。有关更多详细信息，请参见&lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af8514c8e63d77882efdff2789324ce75a2c20f4" translate="yes" xml:space="preserve">
          <source>If you are running VOS Release 14.4.1 or later, you can obtain a pre-compiled, supported copy of perl by purchasing the GNU Tools product from Stratus Technologies.</source>
          <target state="translated">如果您运行的是VOS 14.4.1或更高版本,您可以通过购买Stratus Technologies的GNU Tools产品来获得一个预编译的、受支持的perl副本。</target>
        </trans-unit>
        <trans-unit id="90113b08f2e5803b4f4fa9119cc6038c86b7bb42" translate="yes" xml:space="preserve">
          <source>If you are running a Unix derivative this value defaults to</source>
          <target state="translated">如果你运行的是Unix衍生产品,这个值默认为</target>
        </trans-unit>
        <trans-unit id="ae421a254aed7ffd059cb6be52110578a85cd308" translate="yes" xml:space="preserve">
          <source>If you are running experiments with embedding perl as a library into other applications, you might find MakeMaker is not sufficient. You'd better have a look at ExtUtils::Embed which is a collection of utilities for embedding.</source>
          <target state="translated">如果你正在进行将perl作为一个库嵌入到其他应用程序中的实验,你可能会发现MakeMaker是不够的。你最好看看ExtUtils::Embed,这是一个用于嵌入的实用程序集。</target>
        </trans-unit>
        <trans-unit id="743cbf656ee357233b7747fd85635a26f54ae749" translate="yes" xml:space="preserve">
          <source>If you are running the tests from a emacs shell window, you may see failures in op/stat.t. Run &quot;dmake test-notty&quot; in that case.</source>
          <target state="translated">如果你是在 emacs shell 窗口中运行测试,你可能会在 op/stat.t 中看到失败的情况。</target>
        </trans-unit>
        <trans-unit id="eb661707e45d0fa6207ff65030fca0e35ac953eb" translate="yes" xml:space="preserve">
          <source>If you are running under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; (and if you aren't, why in the world aren't you?), you'll have to add some declarations to make it happy:</source>
          <target state="translated">如果您 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; （如果不是，那么，为什么呢？），您必须添加一些声明使其满意：</target>
        </trans-unit>
        <trans-unit id="767de91007776d2ff4bd67fc3c5e04ab7cebdfa3" translate="yes" xml:space="preserve">
          <source>If you are seeing spaces between the elements of your array when you print the array, you are probably interpolating the array in double quotes:</source>
          <target state="translated">如果你在打印数组时看到数组元素之间有空格,那么你可能是在用双引号插补数组。</target>
        </trans-unit>
        <trans-unit id="16bb00dc57c212c5f89aeced92e2138d70407e36" translate="yes" xml:space="preserve">
          <source>If you are stuck with older Perls, you can do Unicode with the &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::String&quot;&gt;Unicode::String&lt;/a&gt; module, and character conversions using the &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map8&quot;&gt;Unicode::Map8&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map&quot;&gt;Unicode::Map&lt;/a&gt; modules. If you are using Japanese encodings, you might try using the jperl 5.005_03.</source>
          <target state="translated">如果您对较早的Perls &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map8&quot;&gt;感到困惑&lt;/a&gt;，则可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::String&quot;&gt;Unicode :: String&lt;/a&gt;模块执行Unicode ，并使用Unicode :: Map8和&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map&quot;&gt;Unicode :: Map&lt;/a&gt;模块进行字符转换。如果使用日语编码，则可以尝试使用jperl 5.005_03。</target>
        </trans-unit>
        <trans-unit id="a4539f5703f218245f234df49c0b9e75bd10857f" translate="yes" xml:space="preserve">
          <source>If you are submitting a code patch there are several things that you can do to help the Perl 5 Porters accept your patch.</source>
          <target state="translated">如果你提交了一个代码补丁,你可以做一些事情来帮助 Perl 5 Porters 接受你的补丁。</target>
        </trans-unit>
        <trans-unit id="9d2ae6978c448ceee8a44a91cddc4545fb9e5c5e" translate="yes" xml:space="preserve">
          <source>If you are targetting an ARM device -- which currently includes the vast majority of phones and tablets -- you'll want to pass -Dcc=arm-unknown-nto-qnx8.0.0eabi-gcc to Configure. Alternatively, if you are targetting an x86 device, or using the simulator provided with the NDK, you should specify -Dcc=ntox86-gcc instead.</source>
          <target state="translated">如果你的目标是ARM设备--目前包括绝大多数的手机和平板电脑--你会希望通过-Dcc=arm-unknown-nto-qnx8.0.0eabi-gcc来配置。另外,如果你的目标是x86设备,或者使用NDK提供的模拟器,你应该指定-Dcc=ntox86-gcc来代替。</target>
        </trans-unit>
        <trans-unit id="c81847f52511bd6e6f2d950ba6b028d46d7fda4c" translate="yes" xml:space="preserve">
          <source>If you are testing locales (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), there are helper functions in</source>
          <target state="translated">如果您正在测试语言环境（请参阅&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;），则在其中有辅助功能。</target>
        </trans-unit>
        <trans-unit id="1005d40b52c8fba9456ef2a3b1ec6cff90f7233f" translate="yes" xml:space="preserve">
          <source>If you are testing only once, the standard module &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; exports the function &lt;code&gt;first&lt;/code&gt; for this purpose. It works by stopping once it finds the element. It's written in C for speed, and its Perl equivalent looks like this subroutine:</source>
          <target state="translated">如果仅测试一次，则标准模块&lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt;为此 &lt;code&gt;first&lt;/code&gt; 导出功能。一旦找到元素，它便停止运行。它是用C语言编写的，以提高速度，它的Perl等效项类似于以下子例程：</target>
        </trans-unit>
        <trans-unit id="faf3c25ab12fb420d9fdf6ea0144e15dc43f0fe2" translate="yes" xml:space="preserve">
          <source>If you are trying to use this instead of &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; to capture the output, you may find it easier to open a filehandle to a scalar (&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ) and write to that instead.</source>
          <target state="translated">如果您试图使用它而不是 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 来捕获输出，则可能会发现打开标量文件句柄（ &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ）并写入它更容易。</target>
        </trans-unit>
        <trans-unit id="87f126d580b9d17eb9520e5adc6ebcd7b64cbce8" translate="yes" xml:space="preserve">
          <source>If you are trying to use this instead of &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; to capture the output, you may find it easier to open a filehandle to a scalar (&lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ) and write to that instead.</source>
          <target state="translated">如果您试图使用它而不是 &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 来捕获输出，则可能会发现打开标量文件句柄（ &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ）并写入它更容易。</target>
        </trans-unit>
        <trans-unit id="f0601abe3b8fe05fc06de5499fb9941a40db6bc0" translate="yes" xml:space="preserve">
          <source>If you are unable to send your report using &lt;b&gt;perlbug&lt;/b&gt; (most likely because your system doesn't have a way to send mail that perlbug recognizes), you may be able to use this tool to compose your report and save it to a file which you can then send to &lt;b&gt;perlbug@perl.org&lt;/b&gt; using your regular mail client.</source>
          <target state="translated">如果您无法使用&lt;b&gt;perlbug&lt;/b&gt;发送报告（很可能是因为系统无法发送perlbug可以识别的邮件），则可以使用此工具撰写报告并将其保存到文件中然后可以使用您的常规邮件客户端发送到&lt;b&gt;perlbug@perl.org&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="dd788f693f0912cff62f6c5004a3304201e94790" translate="yes" xml:space="preserve">
          <source>If you are used to working with a version of Perl prior to the introduction of lexically scoped warnings, or have code that uses both lexical warnings and &lt;code&gt;$^W&lt;/code&gt; , this section will describe how they interact.</source>
          <target state="translated">如果您习惯在引入词法范围警告之前使用过Perl版本，或者拥有同时使用词法警告和 &lt;code&gt;$^W&lt;/code&gt; ，本节将介绍它们如何交互。</target>
        </trans-unit>
        <trans-unit id="19c883172a7bd8c24338f9dd7a287c030969e4c2" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt; or one of its subclasses, you can call the &lt;code&gt;autoflush&lt;/code&gt; method to change the settings of the filehandle:</source>
          <target state="translated">如果使用的是&lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt;或其子类之一，则可以调用 &lt;code&gt;autoflush&lt;/code&gt; 方法来更改filehandle的设置：</target>
        </trans-unit>
        <trans-unit id="66ca3a901cfd38d2b33b77415f58b3c173825a91" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;HePV&lt;/code&gt; to get values to pass to &lt;code&gt;newSVpvn()&lt;/code&gt; to create a new SV, you should consider using &lt;code&gt;newSVhek(HeKEY_hek(he))&lt;/code&gt; as it is more efficient.</source>
          <target state="translated">如果您使用 &lt;code&gt;HePV&lt;/code&gt; 获取值以传递给 &lt;code&gt;newSVpvn()&lt;/code&gt; 以创建新的SV，则应考虑使用 &lt;code&gt;newSVhek(HeKEY_hek(he))&lt;/code&gt; ,因为这样做效率更高。</target>
        </trans-unit>
        <trans-unit id="987d668924ef21e965c8815374cd5ece61317689" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;nanosleep&lt;/code&gt; for something else than mixing sleeping with signals, give some thought to whether Perl is the tool you should be using for work requiring nanosecond accuracies.</source>
          <target state="translated">如果您将 &lt;code&gt;nanosleep&lt;/code&gt; 用于混合信号和睡眠之外的其他用途，请考虑一下Perl是否是您需要用于纳秒精度工作的工具。</target>
        </trans-unit>
        <trans-unit id="f9a45f762f42b66675541c22b88f50402f53057c" translate="yes" xml:space="preserve">
          <source>If you are using ACLs, there is a pragma called &lt;code&gt;filetest&lt;/code&gt; that may produce more accurate results than the bare stat() mode bits. When under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; the above-mentioned filetests test whether the permission can(not) be granted using the access(2) family of system calls. Also note that the &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; may under this pragma return true even if there are no execute permission bits set (nor any extra execute permission ACLs). This strangeness is due to the underlying system calls' definitions. Note also that, due to the implementation of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; , the &lt;code&gt;_&lt;/code&gt; special filehandle won't cache the results of the file tests when this pragma is in effect. Read the documentation for the &lt;code&gt;filetest&lt;/code&gt; pragma for more information.</source>
          <target state="translated">如果您使用的是ACL，则存在一个名为 &lt;code&gt;filetest&lt;/code&gt; 的编译指示，它可能会比裸stat（）模式位产生更准确的结果。在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; ，上述filetest测试是否可以使用access（2）系列系统调用来授予权限。还要注意，即使没有设置执行许可位（也没有任何额外的执行许可ACL），在该编译指示下 &lt;code&gt;-x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 仍可能返回true。这种奇怪是由于底层系统调用的定义引起的。还要注意，由于 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; 的实现， &lt;code&gt;_&lt;/code&gt; 当该编译指示生效时，特殊的文件句柄将不会缓存文件测试的结果。请阅读文档 &lt;code&gt;filetest&lt;/code&gt; 编译以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="536f259afd4833a386595561631d799b0872387d" translate="yes" xml:space="preserve">
          <source>If you are using ACLs, there is a pragma called &lt;code&gt;filetest&lt;/code&gt; that may produce more accurate results than the bare stat() mode bits. When under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; the above-mentioned filetests test whether the permission can(not) be granted using the access(2) family of system calls. Also note that the &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; may under this pragma return true even if there are no execute permission bits set (nor any extra execute permission ACLs). This strangeness is due to the underlying system calls' definitions. Note also that, due to the implementation of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; , the &lt;code&gt;_&lt;/code&gt; special filehandle won't cache the results of the file tests when this pragma is in effect. Read the documentation for the &lt;code&gt;filetest&lt;/code&gt; pragma for more information.</source>
          <target state="translated">如果您使用的是ACL，则存在一个名为 &lt;code&gt;filetest&lt;/code&gt; 的编译指示，它可能会比裸stat（）模式位产生更准确的结果。在 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; ，上述filetest测试是否可以使用access（2）系列系统调用来授予权限。还要注意，即使没有设置执行许可位（也没有任何额外的执行许可ACL），在该编译指示下 &lt;code&gt;-x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 仍可能返回true。这种奇怪是由于底层系统调用的定义引起的。还要注意，由于 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; 的实现， &lt;code&gt;_&lt;/code&gt; 当该编译指示生效时，特殊的文件句柄将不会缓存文件测试的结果。请阅读文档 &lt;code&gt;filetest&lt;/code&gt; 编译以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="4cb0cc5912b1065f25576985628bc261176328a3" translate="yes" xml:space="preserve">
          <source>If you are using MacOS, the same concerns apply. MacPerl (for Classic environments) comes with a simple editor. Popular external editors are BBEdit ( &lt;a href=&quot;http://www.barebones.com/products/bbedit/&quot;&gt;http://www.barebones.com/products/bbedit/&lt;/a&gt; ) or Alpha ( &lt;a href=&quot;http://www.his.com/~jguyer/Alpha/Alpha8.html&quot;&gt;http://www.his.com/~jguyer/Alpha/Alpha8.html&lt;/a&gt; ). MacOS X users can use Unix editors as well.</source>
          <target state="translated">如果您使用的是MacOS，则存在同样的问题。MacPerl（用于经典环境）带有一个简单的编辑器。流行的外部编辑器是BBEdit（&lt;a href=&quot;http://www.barebones.com/products/bbedit/&quot;&gt;http://www.barebones.com/products/bbedit/&lt;/a&gt;）或Alpha（&lt;a href=&quot;http://www.his.com/~jguyer/Alpha/Alpha8.html&quot;&gt;http://www.his.com/~jguyer/Alpha/Alpha8.html&lt;/a&gt;）。MacOS X用户也可以使用Unix编辑器。</target>
        </trans-unit>
        <trans-unit id="6e4548a312b12b5507979ee1df1e5c700b717005" translate="yes" xml:space="preserve">
          <source>If you are using Plack (which most frameworks do), then &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Rewrite&quot;&gt;Plack::Middleware::Rewrite&lt;/a&gt; is worth looking at if you are migrating from Apache or have URL's you want to always redirect.</source>
          <target state="translated">如果您正在使用Plack（大多数框架都在使用Plack），那么从Apache迁移或拥有要始终重定向的URL的情况下，&lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Rewrite&quot;&gt;Plack :: Middleware :: Rewrite&lt;/a&gt;值得一看。</target>
        </trans-unit>
        <trans-unit id="b1b08c775dc3592188f9dd4afa0190ccbb806664" translate="yes" xml:space="preserve">
          <source>If you are using Windows, you can use any editor that lets you work with plain text, such as NotePad or WordPad. Word processors, such as Microsoft Word or WordPerfect, typically do not work since they insert all sorts of behind-the-scenes information, although some allow you to save files as &quot;Text Only&quot;. You can also download text editors designed specifically for programming, such as Textpad ( &lt;a href=&quot;http://www.textpad.com/&quot;&gt;http://www.textpad.com/&lt;/a&gt; ) and UltraEdit ( &lt;a href=&quot;http://www.ultraedit.com/&quot;&gt;http://www.ultraedit.com/&lt;/a&gt; ), among others.</source>
          <target state="translated">如果使用的是Windows，则可以使用任何可用于处理纯文本的编辑器，例如NotePad或WordPad。文字处理器（例如Microsoft Word或WordPerfect）通常无法工作，因为它们会插入各种幕后信息，尽管有些处理器允许您将文件另存为&amp;ldquo;纯文本&amp;rdquo;。您还可以下载专门为编程设计的文本编辑器，例如Textpad（&lt;a href=&quot;http://www.textpad.com/&quot;&gt;http://www.textpad.com/&lt;/a&gt;）和UltraEdit（&lt;a href=&quot;http://www.ultraedit.com/&quot;&gt;http://www.ultraedit.com/&lt;/a&gt;）等。</target>
        </trans-unit>
        <trans-unit id="42b14c31c340803d7d1a8907e87c3b623cebca0d" translate="yes" xml:space="preserve">
          <source>If you are using a SOCKS firewall, you will need to compile perl and link it with the SOCKS library. This is what is normally called a 'socksified' perl. With this executable you will be able to connect to servers outside the firewall as if it were not there.</source>
          <target state="translated">如果你使用的是 SOCKS 防火墙,你需要编译 perl 并将其与 SOCKS 库链接。这就是通常所说的 &quot;socksified &quot;perl。有了这个可执行文件,你就可以连接到防火墙之外的服务器,就像它不存在一样。</target>
        </trans-unit>
        <trans-unit id="29c561106308348f3755c72923d0a263a80ca5d3" translate="yes" xml:space="preserve">
          <source>If you are using a regex here, you have to use the quotes as shown or it won't work. Also note that regex handling is tricky even for the experienced. Use this feature with caution.</source>
          <target state="translated">如果你在这里使用的是regex,你必须使用如图所示的引号,否则就无法使用。还要注意的是,即使是有经验的人,对regex的处理也是很棘手的。请谨慎使用这个功能。</target>
        </trans-unit>
        <trans-unit id="5a12a925a69a2c6041232d382cd6683ae36d2da6" translate="yes" xml:space="preserve">
          <source>If you are using a version of Perl earlier than 5.004_57, the tied array interface is quite limited. In the example script above &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; or determining the array length will not work with a tied array.</source>
          <target state="translated">如果使用的Perl版本早于5.004_57，则绑定数组接口非常有限。在 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 或确定数组长度的示例脚本中，对绑定数组不起作用。</target>
        </trans-unit>
        <trans-unit id="360a39abe6795afd63327f3e470a092ad595cbfe" translate="yes" xml:space="preserve">
          <source>If you are using cpan-mac, just drop the folder on the &lt;b&gt;installme&lt;/b&gt; droplet, and use the module.</source>
          <target state="translated">如果使用的是cpan-mac，只需将文件夹放在&lt;b&gt;installme小&lt;/b&gt;滴上，然后使用该模块。</target>
        </trans-unit>
        <trans-unit id="1fc1c37b5a3d2067860bd9ba4aa2038972693c34" translate="yes" xml:space="preserve">
          <source>If you are using gcc, just</source>
          <target state="translated">如果你使用的是gcc,只要</target>
        </trans-unit>
        <trans-unit id="8fd5d7695f8aa3649f7196f528604d5d3ae20e06" translate="yes" xml:space="preserve">
          <source>If you are using gcc, you would need to use -mcpu=v9 -m64 instead. This option is not yet supported as of gcc 2.95.2; from install/SPECIFIC in that release:</source>
          <target state="translated">如果你使用的是gcc,你需要使用-mcpu=v9 -m64来代替。这个选项从gcc 2.95.2开始就不支持了;从该版本的install/SPECIFIC开始。</target>
        </trans-unit>
        <trans-unit id="43b374ff761647040bfef238a2f344855f86b957" translate="yes" xml:space="preserve">
          <source>If you are using locale purely for its characteristics related to things like its numeric and time formatting (and not &lt;code&gt;LC_CTYPE&lt;/code&gt; ), consider using a restricted form of the locale pragma (see &lt;a href=&quot;perllocale#The-%22use-locale%22-pragma&quot;&gt;The use locale pragma in perllocale&lt;/a&gt;) like &quot;&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; &quot;.</source>
          <target state="translated">如果纯粹出于与数字和时间格式之类的东西相关的特性而使用语言环境（而不是 &lt;code&gt;LC_CTYPE&lt;/code&gt; ），请考虑使用语言环境编译指示的受限形式（请参阅&lt;a href=&quot;perllocale#The-%22use-locale%22-pragma&quot;&gt;在perllocale中使用语言环境编译指示&lt;/a&gt;），例如&amp;ldquo; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="63c7cadf9ebf06d221687f1101781684817f90c8" translate="yes" xml:space="preserve">
          <source>If you are using the DB_RECNO interface and you intend making use of &lt;code&gt;bval&lt;/code&gt; , you should check out &lt;a href=&quot;#The-'bval'-Option&quot;&gt;The 'bval' Option&lt;/a&gt;.</source>
          <target state="translated">如果您正在使用DB_RECNO接口，并且打算使用 &lt;code&gt;bval&lt;/code&gt; ，则应该签出&lt;a href=&quot;#The-'bval'-Option&quot;&gt;'bval'Option&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e34b95c988ef9ff5f011e4473a6842bbc8f305e" translate="yes" xml:space="preserve">
          <source>If you are using the Visual C compiler, you can get the C runtime's command line wildcard expansion built into perl binary. The resulting binary will always expand unquoted command lines, which may not be what you want if you use a shell that does that for you. The expansion done is also somewhat less powerful than the approach suggested above.</source>
          <target state="translated">如果你使用的是Visual C编译器,你可以在perl二进制中内置C运行时的命令行通配符扩展。由此产生的二进制文件总是会对未引用的命令行进行扩展,如果你使用shell为你做扩展,这可能不是你想要的。所做的扩展也比上面建议的方法要差一些。</target>
        </trans-unit>
        <trans-unit id="a368c00c8ef926e64658830003081d5eb361bb8d" translate="yes" xml:space="preserve">
          <source>If you are using zlib 1.2.0 or older, &lt;code&gt;zlibCompileFlags&lt;/code&gt; will return 0.</source>
          <target state="translated">如果您使用的是zlib 1.2.0或更早版本，则 &lt;code&gt;zlibCompileFlags&lt;/code&gt; 将返回0。</target>
        </trans-unit>
        <trans-unit id="9d19a794a39cad7420e5c34d0bb89a7b77ddba40" translate="yes" xml:space="preserve">
          <source>If you are willing to accept all the defaults run Configure with &lt;b&gt;-de&lt;/b&gt;. However, several useful customizations are available.</source>
          <target state="translated">如果您愿意接受所有默认设置，请运行Configure with &lt;b&gt;-de&lt;/b&gt;。但是，可以使用几种有用的自定义。</target>
        </trans-unit>
        <trans-unit id="fd5b1c2924a349d7291d8ad147e3c28043609419" translate="yes" xml:space="preserve">
          <source>If you are working with a git clone of the Perl repository, you will want to create a branch for your changes. This will make creating a proper patch much simpler. See the &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">如果您正在使用Perl存储库的git克隆，则需要为更改创建一个分支。这将使创建适当的补丁程序变得更加简单。有关如何执行此&lt;a href=&quot;perlgit&quot;&gt;操作&lt;/a&gt;的详细信息，请参见perlgit。</target>
        </trans-unit>
        <trans-unit id="d3a5c5d66921962ee5d2f131da55a853da5b0930" translate="yes" xml:space="preserve">
          <source>If you are working with data you know to be valid, you can speed your code up by using the &quot;nocheck&quot; variants, &lt;code&gt;timelocal_nocheck()&lt;/code&gt; and &lt;code&gt;timegm_nocheck()&lt;/code&gt; . These variants must be explicitly imported.</source>
          <target state="translated">如果使用已知有效的数据，则可以使用&amp;ldquo; nocheck&amp;rdquo;变体 &lt;code&gt;timelocal_nocheck()&lt;/code&gt; 和 &lt;code&gt;timegm_nocheck()&lt;/code&gt; 来加快代码的速度。这些变体必须显式导入。</target>
        </trans-unit>
        <trans-unit id="a9fdba02c2ad23e42f49d14ef3350c451024e80f" translate="yes" xml:space="preserve">
          <source>If you are writing a module to expand an already existing set of modules, please coordinate with the author of the package. It helps if you follow the same naming scheme and module interaction scheme as the original author.</source>
          <target state="translated">如果你写的模块是为了扩展已有的模块集,请与包的作者协调。如果您遵循与原作者相同的命名方案和模块交互方案,会有帮助。</target>
        </trans-unit>
        <trans-unit id="1cd2c8d5447831e253b224430edc3070841bc27c" translate="yes" xml:space="preserve">
          <source>If you are writing a package that &lt;code&gt;AUTOLOAD&lt;/code&gt; s, consider forcing an &lt;code&gt;AUTOLOAD&lt;/code&gt; for any constants explicitly imported by other packages or which are usually used when your package is &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;d.</source>
          <target state="translated">如果要编写一个包含 &lt;code&gt;AUTOLOAD&lt;/code&gt; 的软件包，请考虑对其他软件包明确导入的任何常量或在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; d 的软件包中通常使用的常量强制使用 &lt;code&gt;AUTOLOAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5966f6f48bbef92de0797373659162ca479de0d" translate="yes" xml:space="preserve">
          <source>If you are writing new code, your first port of call should be one of the new &lt;code&gt;IO::Compress&lt;/code&gt; or &lt;code&gt;IO::Uncompress&lt;/code&gt; modules.</source>
          <target state="translated">如果要编写新代码，则第一个调用端口应该是新的 &lt;code&gt;IO::Compress&lt;/code&gt; 或 &lt;code&gt;IO::Uncompress&lt;/code&gt; 模块之一。</target>
        </trans-unit>
        <trans-unit id="0d5955743a0fa060d529640f937e917d974a0fd9" translate="yes" xml:space="preserve">
          <source>If you ask for nothing in particular, you'll be asking for &lt;code&gt;less
'please'&lt;/code&gt; .</source>
          <target state="translated">如果您不要求任何特别的东西，您将要求 &lt;code&gt;less 'please'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d232183f686226b9e4d9f0a9749bb4ab75350724" translate="yes" xml:space="preserve">
          <source>If you ask it to unmemoize a function that was never memoized, it croaks.</source>
          <target state="translated">如果你要求它取消记忆一个从未被记忆的函数,它就会呱呱叫。</target>
        </trans-unit>
        <trans-unit id="5ac398bf0535c0d2bb95ebfd6fd6655ce0bd6b20" translate="yes" xml:space="preserve">
          <source>If you ask to override your chdir() built-in function,</source>
          <target state="translated">如果你要求覆盖你的chdir()内置函数。</target>
        </trans-unit>
        <trans-unit id="aae82346550e5f30641b00cfb651b5e652048f2e" translate="yes" xml:space="preserve">
          <source>If you attempt to compile Perl with (POSIX) threads on an 11.X system and also link in the GDBM library, then Perl will immediately core dump when it starts up. The only workaround at this point is to relink the GDBM library under 11.X, then relink it into Perl.</source>
          <target state="translated">如果你试图在11.X系统上用(POSIX)线程编译Perl,并同时链接到GDBM库中,那么Perl在启动时就会立即进行core dump。这时唯一的变通办法就是在11.X下重新链接GDBM库,然后再重新链接到Perl中。</target>
        </trans-unit>
        <trans-unit id="372756b443de4017a28427029bf0d506d7081a2a" translate="yes" xml:space="preserve">
          <source>If you believe the scalar comes back as UTF-8, you will most likely want the UTF8 flag restored:</source>
          <target state="translated">如果你认为标量返回的是UTF-8,你很可能希望恢复UTF8标志。</target>
        </trans-unit>
        <trans-unit id="1489e0cb25a613554ca1fb1509eb4766e09aaf06" translate="yes" xml:space="preserve">
          <source>If you believe you have found a security vulnerability in Perl, please email perl5-security-report@perl.org with details. This points to a closed subscription, unarchived mailing list. Please only use this address for security issues in the Perl core, not for modules independently distributed on CPAN.</source>
          <target state="translated">如果您认为您发现了Perl中的安全漏洞,请发邮件至 perl5-security-report@perl.org 提供详细信息。这指向的是一个封闭的订阅、未存档的邮件列表。请只用这个地址来处理Perl核心中的安全问题,而不是用于CPAN上独立发布的模块。</target>
        </trans-unit>
        <trans-unit id="2508e4352c00aad2e5cda3b21b798f7f8735a139" translate="yes" xml:space="preserve">
          <source>If you build with Visual C++ 2013 then three tests currently may fail with Daylight Saving Time related problems:</source>
          <target state="translated">如果你使用Visual C++2013进行构建,那么目前有三个测试可能会因为夏令时相关问题而失败。</target>
        </trans-unit>
        <trans-unit id="fc747a2308602b12226c600429d56710358ba8a4" translate="yes" xml:space="preserve">
          <source>If you build with certain versions (e.g. 4.8.1) of gcc from www.mingw.org then</source>
          <target state="translated">如果你使用某些版本的gcc(例如4.8.1)从www.mingw.org,那么</target>
        </trans-unit>
        <trans-unit id="fccb9cfffea038156e1e9bf29f1e74a06b7c692d" translate="yes" xml:space="preserve">
          <source>If you built perl with dynamic loading capability then that would also be the way to build xs based extensions. However, if you built perl with the default static linking you can still build xs based extensions for OS/390 but you will need to follow the instructions in ExtUtils::MakeMaker for building statically linked perl binaries. In the simplest configurations building a static perl + xs extension boils down to:</source>
          <target state="translated">如果你建立的perl具有动态加载功能,那么这也是建立基于xs的扩展的方法。然而,如果你用默认的静态链接来构建perl,你仍然可以为OS/390构建基于xs的扩展,但是你需要按照ExtUtils::MakeMaker中的说明来构建静态链接的perl二进制文件。在最简单的配置中,构建一个静态的perl+xs扩展归结为。</target>
        </trans-unit>
        <trans-unit id="b4bbe3ec8c3dbb9079b54edeba88cab20e6c6b9a" translate="yes" xml:space="preserve">
          <source>If you call $lh-&amp;gt;maketext(</source>
          <target state="translated">如果调用$ lh-&amp;gt; maketext（</target>
        </trans-unit>
        <trans-unit id="b2b245ecec2ba731bc1217986ab8fe3ce3832fb6" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;plan()&lt;/code&gt; , don't call any of the other methods below.</source>
          <target state="translated">如果调用 &lt;code&gt;plan()&lt;/code&gt; ，则不要调用下面的任何其他方法。</target>
        </trans-unit>
        <trans-unit id="f29b01f558f5cc8e37b47ab816256a32df3eb207" translate="yes" xml:space="preserve">
          <source>If you call a method that doesn't exist in a class, Perl will throw an error. However, if that class or any of its parent classes defines an &lt;code&gt;AUTOLOAD&lt;/code&gt; method, that &lt;code&gt;AUTOLOAD&lt;/code&gt; method is called instead.</source>
          <target state="translated">如果您调用的类中不存在的方法，Perl将抛出错误。但是，如果该类或其任何父类定义了 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法，则将调用该 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="945646515b442a128e465225a1d325a7ca2f3625" translate="yes" xml:space="preserve">
          <source>If you call a subroutine that is undefined, you would ordinarily get an immediate, fatal error complaining that the subroutine doesn't exist. (Likewise for subroutines being used as methods, when the method doesn't exist in any base class of the class's package.) However, if an &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is defined in the package or packages used to locate the original subroutine, then that &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is called with the arguments that would have been passed to the original subroutine. The fully qualified name of the original subroutine magically appears in the global $AUTOLOAD variable of the same package as the &lt;code&gt;AUTOLOAD&lt;/code&gt; routine. The name is not passed as an ordinary argument because, er, well, just because, that's why. (As an exception, a method call to a nonexistent &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;unimport&lt;/code&gt; method is just skipped instead. Also, if the AUTOLOAD subroutine is an XSUB, there are other ways to retrieve the subroutine name. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;Autoloading with XSUBs in perlguts&lt;/a&gt; for details.)</source>
          <target state="translated">如果调用未定义的子例程，通常会收到一个立即致命的错误，抱怨该子例程不存在。 （同样，对于用作方法的子例程，如果该方法在该类的程序包的任何基类中都不存在。）但是，如果在一个或多个用于定义原始子程序的程序包中定义了 &lt;code&gt;AUTOLOAD&lt;/code&gt; 子程序，则该 &lt;code&gt;AUTOLOAD&lt;/code&gt; 子程序使用将传递给原始子例程的参数调用。原来的子程序的全名奇迹般地出现在同一包的全球$ AUTOLOAD变量作为 &lt;code&gt;AUTOLOAD&lt;/code&gt; 常规。该名称未作为普通参数传递，因为，嗯，正因为如此。（通常，跳过对不存在的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;unimport&lt;/code&gt; 方法的方法调用。此外，如果AUTOLOAD子例程是XSUB，则还有其他方法可以检索该子例程的名称。有关详细信息，请参见&lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;在perlguts中使用XSUBs自动加载&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="a71cdebace5c6abb01b81af0b4383d9f3787c035" translate="yes" xml:space="preserve">
          <source>If you can arrange for everyone to deal with this through references, it's cleaner code, although not so nice to look at. Here's a function that takes two array references as arguments, returning the two array elements in order of how many elements they have in them:</source>
          <target state="translated">如果能安排大家通过引用来处理,虽然不那么好看,但代码更干净。这里有一个函数,它将两个数组引用作为参数,按照两个数组元素中元素的多少顺序返回。</target>
        </trans-unit>
        <trans-unit id="23b6ce07b51bd0ae187fbd5346ee2bf854f2bb10" translate="yes" xml:space="preserve">
          <source>If you can avoid it, don't, or if you can use a templating system, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text::Template&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Template&quot;&gt;Template&lt;/a&gt; Toolkit, do that instead. You might even be able to get the job done with &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">如果可以避免，请不要这样做，或者如果可以使用诸如&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text :: Template&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/Template&quot;&gt;Template&lt;/a&gt; Toolkit之类的模板系统，请改为这样做。您甚至可以使用 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 完成工作：</target>
        </trans-unit>
        <trans-unit id="f9556f6832194ce02eb38bf13ea3951955c6d164" translate="yes" xml:space="preserve">
          <source>If you can do these things, you've started on the long road to Perl porting. Thanks for wanting to help make Perl better - and happy hacking!</source>
          <target state="translated">如果你能做到这些,你就已经开始了漫长的 Perl 移植之路。谢谢你愿意帮助Perl变得更好--祝你黑客愉快!</target>
        </trans-unit>
        <trans-unit id="4e5e8e457d8aab789523193251b0cae471debcb4" translate="yes" xml:space="preserve">
          <source>If you can go through your firewall with e.g. lynx, presumably with a command such as</source>
          <target state="translated">如果你能通过你的防火墙,例如 lynx,大概可以用一个命令,如</target>
        </trans-unit>
        <trans-unit id="22d913b1c7a6af16ecff397b87485204b5a8ebbc" translate="yes" xml:space="preserve">
          <source>If you can not reach the author for some reason contact the PAUSE admins at modules@perl.org who may be able to help, but each case is treated separately.</source>
          <target state="translated">如果您因为某些原因无法联系到作者,请联系PAUSE管理员:modules@perl.org,他们可能会提供帮助,但每个案例都会单独处理。</target>
        </trans-unit>
        <trans-unit id="e0ff87acae1d2fe61dfcf4190a982955e52a9134" translate="yes" xml:space="preserve">
          <source>If you can't configure &lt;code&gt;TAP::Harness&lt;/code&gt; to do exactly what you want, and writing a plugin isn't an option, consider extending it. It is designed to be (mostly) easy to subclass, though the cases when sub-classing is necessary should be few and far between.</source>
          <target state="translated">如果您无法将 &lt;code&gt;TAP::Harness&lt;/code&gt; 配置为完全执行您想要的操作，并且不能编写插件，请考虑对其进行扩展。它被设计为（主要）易于子类化，尽管需要子类化的情况应该很少而且相去甚远。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
