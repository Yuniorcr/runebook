<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="8b9146b4f38600ca0e41fb96135f743cfdb11eec" translate="yes" xml:space="preserve">
          <source>BUG REPORTING</source>
          <target state="translated">错误报告</target>
        </trans-unit>
        <trans-unit id="664f572fef857b1dfc7d6e286d22026a2508e1e5" translate="yes" xml:space="preserve">
          <source>BUG REPORTS</source>
          <target state="translated">错误报告</target>
        </trans-unit>
        <trans-unit id="5dda8c520f4fbfda1830a8a497556d722a3fd113" translate="yes" xml:space="preserve">
          <source>BUGS</source>
          <target state="translated">BUGS</target>
        </trans-unit>
        <trans-unit id="9f989473548a594a947b969757db7fc06ca6a262" translate="yes" xml:space="preserve">
          <source>BUGS AND CAVEATS</source>
          <target state="translated">缺点和缺陷</target>
        </trans-unit>
        <trans-unit id="fe771929835192040a55c6b146d4bbdcf0038546" translate="yes" xml:space="preserve">
          <source>BUGS AND IRRITATIONS</source>
          <target state="translated">缺陷和故障</target>
        </trans-unit>
        <trans-unit id="affef23bcfe821a649489c10e4d45ae3607b1ccb" translate="yes" xml:space="preserve">
          <source>BUGS AND LIMITATIONS</source>
          <target state="translated">缺陷和限制</target>
        </trans-unit>
        <trans-unit id="118a34d613c11c790c196c946968113aa8bc32aa" translate="yes" xml:space="preserve">
          <source>BUGS AND PITFALLS</source>
          <target state="translated">缺点和缺陷</target>
        </trans-unit>
        <trans-unit id="a16fd7f9de623a809defab1d94048e0eded9677b" translate="yes" xml:space="preserve">
          <source>BUGS AND WARNINGS</source>
          <target state="translated">错误和警告</target>
        </trans-unit>
        <trans-unit id="2f8e6e225c82badf6f8a92aed6ef242d4dc4d03b" translate="yes" xml:space="preserve">
          <source>BUGS ON CYGWIN</source>
          <target state="translated">CYGWIN上的错误</target>
        </trans-unit>
        <trans-unit id="11f69a17d772a3f0d39aa116f097397dc1dac971" translate="yes" xml:space="preserve">
          <source>BUGS and CAVEATS</source>
          <target state="translated">缺点和缺陷</target>
        </trans-unit>
        <trans-unit id="6c450a35b54bd0a62e732cbab24c3d7221d9a194" translate="yes" xml:space="preserve">
          <source>BUGS is an email or url to post bug reports. For modules with UPSTREAM =&amp;gt; 'blead', use &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;mailto:perl5-porters@perl.org&lt;/a&gt;. rt.cpan.org appears to automatically provide a URL for CPAN modules; any value given here overrides the default: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=%24ModuleName&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=$ModuleName&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf8d27dca59cf8914b7de42279bcf54b381c80d" translate="yes" xml:space="preserve">
          <source>BUGS is an email or url to post bug reports. For modules with UPSTREAM =&amp;gt; 'blead', use perl5-porters@perl.org. rt.cpan.org appears to automatically provide a URL for CPAN modules; any value given here overrides the default: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=&lt;/a&gt;$ModuleName</source>
          <target state="translated">BUGS是用于发布错误报告的电子邮件或URL。对于具有UPSTREAM =&amp;gt;'blead'的模块，请使用perl5-porters@perl.org。rt.cpan.org似乎会自动为CPAN模块提供URL；此处给出的任何值都将覆盖默认值：&lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http:&lt;/a&gt; //rt.cpan.org/Public/Dist/Display.html?Name= $ ModuleName</target>
        </trans-unit>
        <trans-unit id="4fa4a173033ffa9b27f16cd2d7b309c255617591" translate="yes" xml:space="preserve">
          <source>BUGS/CAVEATS/etc</source>
          <target state="translated">BUGS/CAVEATS/etc</target>
        </trans-unit>
        <trans-unit id="9b8dfdff736c5b1dbf956b89d8a9d4fd925dacd2" translate="yes" xml:space="preserve">
          <source>BUILD</source>
          <target state="translated">BUILD</target>
        </trans-unit>
        <trans-unit id="0e162e98df920882beaaa37c9fd3fd9860be2bff" translate="yes" xml:space="preserve">
          <source>BUILD AND INSTALL</source>
          <target state="translated">建造和安装</target>
        </trans-unit>
        <trans-unit id="80ef3501d89bb441f42a9aac769a351966bde435" translate="yes" xml:space="preserve">
          <source>BUILD NEW EXTENSIONS</source>
          <target state="translated">建造新的扩建项目</target>
        </trans-unit>
        <trans-unit id="915ac3e12b39990a3ff0eb519c7c070afd799641" translate="yes" xml:space="preserve">
          <source>BUILDING</source>
          <target state="translated">BUILDING</target>
        </trans-unit>
        <trans-unit id="a5d9fc029fc161e583884fa605ea5dd4bf5b0226" translate="yes" xml:space="preserve">
          <source>BUILDING AND INSTALLING MODULES ON DOS</source>
          <target state="translated">在DOS上构建和安装模块。</target>
        </trans-unit>
        <trans-unit id="68c9d11aacf08e68cf9222616220471f55a4230e" translate="yes" xml:space="preserve">
          <source>BUILDING PERL FOR OPENVOS</source>
          <target state="translated">为OPENVOS建立PERL</target>
        </trans-unit>
        <trans-unit id="b603dd0f789cea0b71cf17b9cadf6a885369ee6d" translate="yes" xml:space="preserve">
          <source>BUILDING PERL ON AMIGAOS</source>
          <target state="translated">在AMIGAOS上建造PERL大楼。</target>
        </trans-unit>
        <trans-unit id="d40a175e7a653e9eaa67c4da87c76fc937184284" translate="yes" xml:space="preserve">
          <source>BUILD_REQUIRES</source>
          <target state="translated">BUILD_REQUIRES</target>
        </trans-unit>
        <trans-unit id="d5bdc31108d4219c97e8c1b7e29e0629da746aa9" translate="yes" xml:space="preserve">
          <source>BUNDLES</source>
          <target state="translated">BUNDLES</target>
        </trans-unit>
        <trans-unit id="92b48cc3d13ac12b362038111cf08e5cf8b03696" translate="yes" xml:space="preserve">
          <source>Back before Perl had the XS system for connecting with C libraries, programmers used to get library constants by reading through the C header files. You may still see &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; or similar around - the</source>
          <target state="translated">在Perl拥有用于与C库连接的XS系统之前，程序员通常通过读取C头文件来获取库常量。您可能仍会看到 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; 或类似内容-</target>
        </trans-unit>
        <trans-unit id="a14d8f418667d750d655e37f8fb2aa536926510a" translate="yes" xml:space="preserve">
          <source>Back before Perl had the XS system for connecting with C libraries, programmers used to get library constants by reading through the C header files. You may still see &lt;code&gt;require 'syscall.ph'&lt;/code&gt; or similar around - the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3e95e64a0aa298ba1dcd060974643f7be2839b" translate="yes" xml:space="preserve">
          <source>Back then, the range 0xD800-0xDFFF was not allocated. Let's split that range in half and use the first half to represent the &lt;code&gt;upper
half of a character&lt;/code&gt; and the second half to represent the &lt;code&gt;lower
half of a character&lt;/code&gt; . That way, you can represent 1024 * 1024 = 1048576 more characters. Now we can store character ranges up to \x{10ffff} even with 16-bit encodings. This pair of half-character is now called a</source>
          <target state="translated">那时，未分配范围0xD800-0xDFFF。让我们将该范围分成两半，使用前半部分代表 &lt;code&gt;upper half of a character&lt;/code&gt; 的上半部分，使用下半部分代表字符的 &lt;code&gt;lower half of a character&lt;/code&gt; 。这样，您可以表示更多的1024 * 1024 = 1048576个字符。现在，即使使用16位编码，我们也可以存储最大\ x {10ffff}的字符范围。这对半字符现在称为</target>
        </trans-unit>
        <trans-unit id="8b862d333105bea92e016a8abca6974a21d6cf0e" translate="yes" xml:space="preserve">
          <source>Back then, the range 0xD800-0xDFFF was not allocated. Let's split that range in half and use the first half to represent the &lt;code&gt;upper half of a character&lt;/code&gt; and the second half to represent the &lt;code&gt;lower half of a character&lt;/code&gt;. That way, you can represent 1024 * 1024 = 1048576 more characters. Now we can store character ranges up to \x{10ffff} even with 16-bit encodings. This pair of half-character is now called a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe6515e366531ac45779e3d5c9b5a456560e812" translate="yes" xml:space="preserve">
          <source>Back to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9a2a8bbfa8f04b97f0739e8cee87c19e9a7b1a" translate="yes" xml:space="preserve">
          <source>Back to converting data. If you have (or want) data in your system's native 8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you can use pack/unpack to convert to/from Unicode.</source>
          <target state="translated">回到转换数据。如果你有(或想要)系统的本机8位编码的数据(如Latin-1、EBCDIC等),你可以使用pack/unpack来转换为/从Unicode。</target>
        </trans-unit>
        <trans-unit id="917eb438525299e66d70b4deb11770f40a27eeaa" translate="yes" xml:space="preserve">
          <source>Backend for building test libraries</source>
          <target state="translated">构建测试库的后端</target>
        </trans-unit>
        <trans-unit id="60865a55d575470308929e5970d44edcbdb31366" translate="yes" xml:space="preserve">
          <source>Background Processes</source>
          <target state="translated">背景过程</target>
        </trans-unit>
        <trans-unit id="777d367a0813af1945dd6a57f416558fa99c5a72" translate="yes" xml:space="preserve">
          <source>Background and PERL_IMPLICIT_CONTEXT</source>
          <target state="translated">背景和PERL_IMPLICIT_CONTEXT。</target>
        </trans-unit>
        <trans-unit id="82139f465e7bfd51be69bcd2ba2252de65152f38" translate="yes" xml:space="preserve">
          <source>Background yourself like this:</source>
          <target state="translated">自己的背景是这样的。</target>
        </trans-unit>
        <trans-unit id="fec43a1301d416fe4b43d921e7178671d812a1b8" translate="yes" xml:space="preserve">
          <source>Background: &lt;code&gt;atoi&lt;/code&gt; has severe problems with illegal inputs, it cannot be used for incremental parsing, and therefore should be avoided &lt;code&gt;atoi&lt;/code&gt; and &lt;code&gt;strtol&lt;/code&gt; are also affected by locale settings, which can also be seen as a bug (global state controlled by user environment).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eced385684cc6954de21105c9b174aaf3bba4295" translate="yes" xml:space="preserve">
          <source>Backported version unknown</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422ea69f009b9513c410e1c50a5058f352b88507" translate="yes" xml:space="preserve">
          <source>Backreference to a named capture group. Equivalent to &lt;code&gt;\g{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7bd776caf410341796f267d0b5a33a3e4a0364" translate="yes" xml:space="preserve">
          <source>Backreference to a named capture group. Equivalent to &lt;code&gt;\g{NAME}&lt;/code&gt; .</source>
          <target state="translated">向后引用到命名捕获组。等效于 &lt;code&gt;\g{NAME}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b67830d6a194880657acd61864c65e3027fb02e" translate="yes" xml:space="preserve">
          <source>Backreferences</source>
          <target state="translated">Backreferences</target>
        </trans-unit>
        <trans-unit id="89d9017aad56d057f4819297fea6ec35a3d1c796" translate="yes" xml:space="preserve">
          <source>Backreferences in substitutions use &quot;$&quot; rather than &quot;\&quot;.</source>
          <target state="translated">在替换中使用&quot;$&quot;而不是&quot;\&quot;进行反向引用。</target>
        </trans-unit>
        <trans-unit id="f6f78ea4ce7c5612a0f7211383bd0176dfc079e5" translate="yes" xml:space="preserve">
          <source>Backslash Operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5cf510bfb36856574ecae34fa00822be8b9c589" translate="yes" xml:space="preserve">
          <source>Backslash Sequences</source>
          <target state="translated">反斜杠序列</target>
        </trans-unit>
        <trans-unit id="db35629fab3798cdd79f1bf42fa413127bebc425" translate="yes" xml:space="preserve">
          <source>Backslash is used, as usual, to escape the next character.</source>
          <target state="translated">反斜杠一样平常用于转义下一个字符。</target>
        </trans-unit>
        <trans-unit id="046c786ef212957156a16429eb6f369b2064b79d" translate="yes" xml:space="preserve">
          <source>Backslash sequence character classes cannot form one of the endpoints of a range. Thus, you can't say:</source>
          <target state="translated">反斜杠序列字符类不能构成一个范围的端点之一。因此,你不能说。</target>
        </trans-unit>
        <trans-unit id="9900e3acb0e0a2eba6b592f80668e5cc6828f6c1" translate="yes" xml:space="preserve">
          <source>Backslash sequences</source>
          <target state="translated">反斜杠序列</target>
        </trans-unit>
        <trans-unit id="c61c0b16c1836e4070c1986f40a121b830a65cf5" translate="yes" xml:space="preserve">
          <source>Backslashed characters are either replaced with corresponding literal strings (as with &lt;code&gt;\{&lt;/code&gt;), or else they generate special nodes in the finite automaton (as with &lt;code&gt;\b&lt;/code&gt; ). Characters special to the RE engine (such as &lt;code&gt;|&lt;/code&gt;) generate corresponding nodes or groups of nodes. &lt;code&gt;(?#...)&lt;/code&gt; comments are ignored. All the rest is either converted to literal strings to match, or else is ignored (as is whitespace and &lt;code&gt;#&lt;/code&gt; -style comments if &lt;code&gt;/x&lt;/code&gt; is present).</source>
          <target state="translated">反斜杠字符可以替换为相应的文字字符串（如 &lt;code&gt;\{&lt;/code&gt; ），也可以在有限自动机中生成特殊节点（如 &lt;code&gt;\b&lt;/code&gt; ）。 RE引擎专用的字符（例如 &lt;code&gt;|&lt;/code&gt; ）会生成相应的节点或节点组。 &lt;code&gt;(?#...)&lt;/code&gt; 注释将被忽略。其余的所有内容都将转换为文本字符串以匹配，否则将被忽略（如果存在 &lt;code&gt;/x&lt;/code&gt; ,则将空格和 &lt;code&gt;#&lt;/code&gt; 样式注释也是如此）。</target>
        </trans-unit>
        <trans-unit id="5aeb8eb150f9b708f4b9ee0e63969a864d6fc87f" translate="yes" xml:space="preserve">
          <source>Backslashed characters are either replaced with corresponding literal strings (as with &lt;code&gt;\{&lt;/code&gt;), or else they generate special nodes in the finite automaton (as with &lt;code&gt;\b&lt;/code&gt;). Characters special to the RE engine (such as &lt;code&gt;|&lt;/code&gt;) generate corresponding nodes or groups of nodes. &lt;code&gt;(?#...)&lt;/code&gt; comments are ignored. All the rest is either converted to literal strings to match, or else is ignored (as is whitespace and &lt;code&gt;#&lt;/code&gt;-style comments if &lt;code&gt;/x&lt;/code&gt; is present).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396b0c95d21c97a92647624c67163f81645740c9" translate="yes" xml:space="preserve">
          <source>Backslashed metacharacters in Perl are alphanumeric, such as &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; . Unlike some other regular expression languages, there are no backslashed symbols that aren't alphanumeric. So anything that looks like \\, \(, \), \[, \], \{, or \} is always interpreted as a literal character, not a metacharacter. This was once used in a common idiom to disable or quote the special meanings of regular expression metacharacters in a string that you want to use for a pattern. Simply quote all non-&quot;word&quot; characters:</source>
          <target state="translated">Perl中的反斜杠元字符是字母数字，例如 &lt;code&gt;\b&lt;/code&gt; ， &lt;code&gt;\w&lt;/code&gt; ， &lt;code&gt;\n&lt;/code&gt; 。与其他一些正则表达式语言不同，没有不是字母数字的反斜杠符号。因此，任何看起来像\\，\（，\），\ [，\]，\ {或\}的东西始终被解释为文字字符，而不是元字符。曾经在一个常见的习惯用法中使用它来禁用或引用要用于模式的字符串中正则表达式元字符的特殊含义。只需引用所有非&amp;ldquo;单词&amp;rdquo;字符：</target>
        </trans-unit>
        <trans-unit id="a9e4564a4cffc22857c4489a19486bf89ae25eff" translate="yes" xml:space="preserve">
          <source>Backslashed metacharacters in Perl are alphanumeric, such as &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;. Unlike some other regular expression languages, there are no backslashed symbols that aren't alphanumeric. So anything that looks like &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;\(&lt;/code&gt;, &lt;code&gt;\)&lt;/code&gt;, &lt;code&gt;\[&lt;/code&gt;, &lt;code&gt;\]&lt;/code&gt;, &lt;code&gt;\{&lt;/code&gt;, or &lt;code&gt;\}&lt;/code&gt; is always interpreted as a literal character, not a metacharacter. This was once used in a common idiom to disable or quote the special meanings of regular expression metacharacters in a string that you want to use for a pattern. Simply quote all non-&quot;word&quot; characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad3bd6856b2f78166ba432a9cdf4da8413a4090" translate="yes" xml:space="preserve">
          <source>Backslashes parentheses &lt;code&gt;()&lt;/code&gt; in command line arguments. Doesn't handle recursive Makefile &lt;code&gt;$(...)&lt;/code&gt; constructs, but handles simple ones.</source>
          <target state="translated">命令行参数中的反斜杠括号 &lt;code&gt;()&lt;/code&gt; 。不处理递归的Makefile &lt;code&gt;$(...)&lt;/code&gt; 构造，但处理简单的构造。</target>
        </trans-unit>
        <trans-unit id="a44d458ea8adc4ce2457e80d59480bf2444b0e2c" translate="yes" xml:space="preserve">
          <source>Backticks</source>
          <target state="translated">Backticks</target>
        </trans-unit>
        <trans-unit id="cada2d153702b188c804c9ed93a320132370a768" translate="yes" xml:space="preserve">
          <source>Backticks &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef1c0d1318e1460dedacce3731d309fc7ffbb8a" translate="yes" xml:space="preserve">
          <source>Backticks &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="translated">反引号 &lt;code&gt;``&lt;/code&gt; （请参阅perlop中的&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I / O运算符&lt;/a&gt;），该命令包含重定向或shell元字符;</target>
        </trans-unit>
        <trans-unit id="6e2b605f65ba36a3d929c62881915b96a794f8f1" translate="yes" xml:space="preserve">
          <source>Backticks create a subprocess, and pass the enclosed string to it for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt; , any valid DCL command string may be specified.</source>
          <target state="translated">反引号创建一个子进程，并将附带的字符串传递给它，以作为DCL命令执行。由于子过程是通过 &lt;code&gt;lib$spawn()&lt;/code&gt; 直接创建的，因此可以指定任何有效的DCL命令字符串。</target>
        </trans-unit>
        <trans-unit id="93a46463866e4337a557918eb7f92cb737fcdb4d" translate="yes" xml:space="preserve">
          <source>Backticks create a subprocess, and pass the enclosed string to it for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt;, any valid DCL command string may be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34532d18ad2d0f70e2d7b957fabc96ee06bc62fe" translate="yes" xml:space="preserve">
          <source>Backtracking</source>
          <target state="translated">Backtracking</target>
        </trans-unit>
        <trans-unit id="6e522c194b60635ece31d387544d1195051e629c" translate="yes" xml:space="preserve">
          <source>Backtracking control verbs</source>
          <target state="translated">回溯控制动词</target>
        </trans-unit>
        <trans-unit id="14496432005368ea983df3ea81b1252443b8ee8b" translate="yes" xml:space="preserve">
          <source>Backtracking during the relentless search for a match may be a waste of time, particularly when the match is bound to fail. Consider the simple pattern</source>
          <target state="translated">在无情的搜索匹配过程中,回溯可能会浪费时间,特别是当匹配必然失败时。考虑一下简单的模式</target>
        </trans-unit>
        <trans-unit id="0bce7971052281b2bb5edb4f3a21f79dd6904b31" translate="yes" xml:space="preserve">
          <source>Backtracking is more efficient than repeated tries with different regular expressions. If there are several regular expressions and a match with any of them is acceptable, then it is possible to combine them into a set of alternatives. If the individual expressions are input data, this can be done by programming a join operation. We'll exploit this idea in an improved version of the &lt;code&gt;simple_grep&lt;/code&gt; program: a program that matches multiple patterns:</source>
          <target state="translated">回溯比使用不同正则表达式的重复尝试更有效。如果有多个正则表达式，并且与它们中的任何一个匹配都是可接受的，则可以将它们组合为一组替代项。如果各个表达式是输入数据，则可以通过对联接操作进行编程来完成。我们将在 &lt;code&gt;simple_grep&lt;/code&gt; 程序的改进版本中利用这一思想：该程序可匹配多种模式：</target>
        </trans-unit>
        <trans-unit id="fd4a1f65749d89056abcaeac3722a7b7a8fe75a1" translate="yes" xml:space="preserve">
          <source>Backward Compatibility</source>
          <target state="translated">后向兼容性</target>
        </trans-unit>
        <trans-unit id="23a7808b48afc84b0dceb9136590ca7bfdbb9b77" translate="yes" xml:space="preserve">
          <source>Backward compatibility</source>
          <target state="translated">向后兼容性</target>
        </trans-unit>
        <trans-unit id="ec09211f4889a2c8a77bac08067eb8783a4cd974" translate="yes" xml:space="preserve">
          <source>Backward compatible boilerplate</source>
          <target state="translated">向后兼容的模板</target>
        </trans-unit>
        <trans-unit id="8fd78925dba59eef91afba0cdabe923520e5ee69" translate="yes" xml:space="preserve">
          <source>Backwards compatibility</source>
          <target state="translated">向后兼容性</target>
        </trans-unit>
        <trans-unit id="7d01557ea44942b942393d66060697fec065318a" translate="yes" xml:space="preserve">
          <source>Bad arg length for %s, is %u, should be %d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="165656139a26613694c64dbf201f062c5151055a" translate="yes" xml:space="preserve">
          <source>Bad color mapping %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ab08a2349cea719fd65e95a92efa2f68979a67" translate="yes" xml:space="preserve">
          <source>Bad escape sequence %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97e53bd47a32a9c5ca5b26c7f73e5af6cefd27e1" translate="yes" xml:space="preserve">
          <source>Bad evalled substitution pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cec2366e742bda57450610acf903181d2989bf8" translate="yes" xml:space="preserve">
          <source>Bad example:</source>
          <target state="translated">坏的例子。</target>
        </trans-unit>
        <trans-unit id="6b1ede25e2d280b57ab0ce582f6faf1b35cf90a7" translate="yes" xml:space="preserve">
          <source>Bad exit or wait status</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390acb944960513fda956a00da4e57aecfbdc40d" translate="yes" xml:space="preserve">
          <source>Bad filehandle: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2545bb8b8757d12600ee0fd7c8d21fd5ad24ec74" translate="yes" xml:space="preserve">
          <source>Bad free() ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d801fbd5f10bc4ae72d676efa25b3f102ac7bc5e" translate="yes" xml:space="preserve">
          <source>Bad hash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e025cf017a8d1ec1929f0fe963368b8537306db" translate="yes" xml:space="preserve">
          <source>Bad name after %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9adf2eb1c251e659c032b900434bcbefd880c7" translate="yes" xml:space="preserve">
          <source>Bad plugin affecting keyword '%s'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec81356ab8541823884a0a82a618613aa9cbd7b4" translate="yes" xml:space="preserve">
          <source>Bad realloc() ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da31fb3200e756607d3e2e50254f7cea20fa96d" translate="yes" xml:space="preserve">
          <source>Bad subroutine name for Fatal: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42447de9c1418f0e2c311d00634195d77eb4c7e0" translate="yes" xml:space="preserve">
          <source>Bad symbol for array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65b92f2abbe5aa53ce089c4d6d379ebd454bfc3" translate="yes" xml:space="preserve">
          <source>Bad symbol for dirhandle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66844a23804f5fa9fb3dbb57550acc9e7e5e7dd" translate="yes" xml:space="preserve">
          <source>Bad symbol for filehandle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f407c0868b2e3ed85e66aedb4e0f3e18c18e11" translate="yes" xml:space="preserve">
          <source>Bad symbol for hash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08cf554f79f8dc5600aa8436990c34983c96cb70" translate="yes" xml:space="preserve">
          <source>Bad symbol for scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1bd2e42ef1c41d1f7a37013a433505cff6f0d53" translate="yes" xml:space="preserve">
          <source>Badly placed ()'s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f60e950209318c3cca05ba1dcb8123b97e1b18f" translate="yes" xml:space="preserve">
          <source>Bailout</source>
          <target state="translated">Bailout</target>
        </trans-unit>
        <trans-unit id="55cc23ba5301ba2564daa62213188ebb8c917e57" translate="yes" xml:space="preserve">
          <source>Bailout result token.</source>
          <target state="translated">保释金结果名物。</target>
        </trans-unit>
        <trans-unit id="2e1aced5d91a77947ec0c1e15905db2c6dabdd2d" translate="yes" xml:space="preserve">
          <source>Bailout!</source>
          <target state="translated">Bailout!</target>
        </trans-unit>
        <trans-unit id="c9c7caaefe38d5bc0e42cffe87236c93a6e055ee" translate="yes" xml:space="preserve">
          <source>Bal&amp;aacute;zs Szab&amp;oacute; (dLux), dlux@kapu.hu</source>
          <target state="translated">Bal&amp;aacute;zsSzab&amp;oacute;（dLux），dlux @ kapu.hu</target>
        </trans-unit>
        <trans-unit id="fa6c3752cd00f7f1277fd7e5604ab8d2edaf26b8" translate="yes" xml:space="preserve">
          <source>Bangladesh</source>
          <target state="translated">Bangladesh</target>
        </trans-unit>
        <trans-unit id="528dadc6eada08b37b8564a84bbd615fedfa3a6d" translate="yes" xml:space="preserve">
          <source>Bar.pm</source>
          <target state="translated">Bar.pm</target>
        </trans-unit>
        <trans-unit id="991cc000e0ed51287d06994419ec5b5150b2fbbf" translate="yes" xml:space="preserve">
          <source>Bar.xs</source>
          <target state="translated">Bar.xs</target>
        </trans-unit>
        <trans-unit id="38e31cd750cd9c5c8abfa83e3cc07bbe5eb34dbc" translate="yes" xml:space="preserve">
          <source>Bare here-document terminators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f2f9eceeee98d7bac9099dfb477548bd0d00fe3" translate="yes" xml:space="preserve">
          <source>Bareword &quot;%s&quot; not allowed while &quot;strict subs&quot; in use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74184baa622016b052c2c66c26dc81d35681d05a" translate="yes" xml:space="preserve">
          <source>Bareword &quot;%s&quot; refers to nonexistent package</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f9425456098bc5db3b65fe0b670ee4dc328cf5" translate="yes" xml:space="preserve">
          <source>Bareword found in conditional</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c6c09ca8e54434a9e30a3ee7363deeca4c4687" translate="yes" xml:space="preserve">
          <source>Bareword in require contains &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99617bf4b7525e79f27dc14c638f75b9b86decd2" translate="yes" xml:space="preserve">
          <source>Bareword in require maps to disallowed filename &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e217673de1982c957abdb450217720b611015045" translate="yes" xml:space="preserve">
          <source>Bareword in require maps to empty filename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b08d7d96976813240018e31332af5b98b35fa0d" translate="yes" xml:space="preserve">
          <source>Bareword in require must not start with a double-colon: &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1ae41c7e90ad9133f0cec4b012d051f81574f4" translate="yes" xml:space="preserve">
          <source>Barewords</source>
          <target state="translated">Barewords</target>
        </trans-unit>
        <trans-unit id="6be542a3a79d103a3744357ed20ec40db010c97c" translate="yes" xml:space="preserve">
          <source>Barewords are not covered by overloaded string constants.</source>
          <target state="translated">裸词不在重载字符串常量的范围内。</target>
        </trans-unit>
        <trans-unit id="a58b8ede3c3c15995119146605014af774c7bcd7" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Compress modules</source>
          <target state="translated">IO::Compress模块的基类</target>
        </trans-unit>
        <trans-unit id="1aecc52f6145193c99cc41e745488c8d94f4db0b" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Uncompress modules</source>
          <target state="translated">IO::Uncompress模块的基类</target>
        </trans-unit>
        <trans-unit id="9410f6a2867439548603d6c52d5c59ef4562fa7b" translate="yes" xml:space="preserve">
          <source>Base Structures</source>
          <target state="translated">基础结构</target>
        </trans-unit>
        <trans-unit id="082fae7b28f65e5cb911e0f3f3f15b07bb66cbb1" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied handles</source>
          <target state="translated">绑定手柄的基础类定义</target>
        </trans-unit>
        <trans-unit id="007ee9121a8b9e57fcd866ceebd36b23a00f0fde" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied hashes</source>
          <target state="translated">绑定哈希的基类定义</target>
        </trans-unit>
        <trans-unit id="b6b455ad8f579493b53af2265bc184f2ba6c6cbb" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied scalars</source>
          <target state="translated">绑定标量的基类定义</target>
        </trans-unit>
        <trans-unit id="9cae4a150d12d8ffc0b3fa77692959a6c4bfb799" translate="yes" xml:space="preserve">
          <source>Base class for ALL classes (blessed references)</source>
          <target state="translated">所有类的基础类(祝福引用)</target>
        </trans-unit>
        <trans-unit id="35cd310da77bd29a53a2d4932d2eb92ae62a2b7e" translate="yes" xml:space="preserve">
          <source>Base class for CPAN shell extensions</source>
          <target state="translated">CPAN外壳扩展的基础类</target>
        </trans-unit>
        <trans-unit id="c3e0f91a5e302404f6913115b1263f4db4575024" translate="yes" xml:space="preserve">
          <source>Base class for ExtUtils::Constant objects</source>
          <target state="translated">ExtUtils::Constant对象的基类。</target>
        </trans-unit>
        <trans-unit id="5ce69fa0ba6f632f7e9c5c2e2e7602e063a7c7a9" translate="yes" xml:space="preserve">
          <source>Base class for TAP source iterators</source>
          <target state="translated">TAP源迭代器的基类</target>
        </trans-unit>
        <trans-unit id="37eb343993cd16220ab0f185a716f5c376429394" translate="yes" xml:space="preserve">
          <source>Base class for TAP::Parser output objects</source>
          <target state="translated">TAP::Parser输出对象的基类。</target>
        </trans-unit>
        <trans-unit id="a0880f8d682b9138475bd47a938947c12338445c" translate="yes" xml:space="preserve">
          <source>Base class for Test2 IPC drivers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cde81f5a0639d96966be94bffabdcc2cee72d19" translate="yes" xml:space="preserve">
          <source>Base class for all event facets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ab0f65808322aafffdf4f4c4569b0ca559cecd" translate="yes" xml:space="preserve">
          <source>Base class for all event objects that get passed through &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8befc5059605409ade42b4d099e397b207c906b" translate="yes" xml:space="preserve">
          <source>Base class for creating POD filters and translators</source>
          <target state="translated">用于创建POD过滤器和翻译器的基础类。</target>
        </trans-unit>
        <trans-unit id="78eefd2e412b4d4df740ff4fbfcce92bad174022" translate="yes" xml:space="preserve">
          <source>Base class for different TAP source handlers</source>
          <target state="translated">不同TAP源处理程序的基础类</target>
        </trans-unit>
        <trans-unit id="6d6b96a9e4df11d307d7125ce342fa82d8eb0fc3" translate="yes" xml:space="preserve">
          <source>Base class for events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4dfc8dbeda31aa613f1ab98bcf6af5cdb80223d" translate="yes" xml:space="preserve">
          <source>Base class for harness output delegates</source>
          <target state="translated">驾驭输出代表的基类</target>
        </trans-unit>
        <trans-unit id="7a74e67740b1a1d00bee0be3088f31fbc10821ea" translate="yes" xml:space="preserve">
          <source>Base class for test modules</source>
          <target state="translated">测试模块的基础类</target>
        </trans-unit>
        <trans-unit id="78996d2c61d5e3e13d981dd6371495a7dc1b0695" translate="yes" xml:space="preserve">
          <source>Base class for tied arrays</source>
          <target state="translated">绑定数组的基类</target>
        </trans-unit>
        <trans-unit id="4c8eae847ee205298317c9b96e374f69e5e9feb1" translate="yes" xml:space="preserve">
          <source>Base class package &quot;%s&quot; is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5134fdf6155e7a9843c83a26849d1aff846f4d88" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8811ba419e75aa7afad3c58a4392ff34e2f70b65" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to &lt;a href=&quot;tap/parser&quot;&gt;TAP::Parser&lt;/a&gt;</source>
          <target state="translated">为&lt;a href=&quot;tap/parser&quot;&gt;TAP :: Parser&lt;/a&gt;提供通用功能的基类</target>
        </trans-unit>
        <trans-unit id="0808d28ca43c79c7220c0b66b8832ca8877ecfdc" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to all &lt;code&gt;TAP::*&lt;/code&gt; modules</source>
          <target state="translated">为所有 &lt;code&gt;TAP::*&lt;/code&gt; 模块提供通用功能的基类</target>
        </trans-unit>
        <trans-unit id="7a76be2c1588f2035fb74a3a61c2be909fdefa70" translate="yes" xml:space="preserve">
          <source>Base for Pod::Perldoc formatters</source>
          <target state="translated">Pod::Perldoc formatters的基础。</target>
        </trans-unit>
        <trans-unit id="bf06e03b88934d434a87ce7787240b8e99aae0b0" translate="yes" xml:space="preserve">
          <source>Based on Stevan Little's &lt;a href=&quot;Class::C3&quot;&gt;Class::C3&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2291e71c9ac6320d0a4640a773f789651e805f6a" translate="yes" xml:space="preserve">
          <source>Based on Stevan Little's &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class::C3&lt;/a&gt;</source>
          <target state="translated">基于Stevan Little的&lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;课程：: C3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="560c120ffa51ce8d2dc3b95d35311dd465a3c278" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text()&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">基于Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;编写的&lt;b&gt;Pod :: Text :: pod2text（）的&lt;/b&gt;代码</target>
        </trans-unit>
        <trans-unit id="25b805dbff71baab76550b6af4db1656526ccb89" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">基于Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;编写的&lt;b&gt;Pod :: Text :: pod2text（1）的&lt;/b&gt;代码</target>
        </trans-unit>
        <trans-unit id="b781efd9c14a9bf17ea0a940b2c65ad0a21bc5c6" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">基于Tom Christiansen（tchrist@mox.perl.com）编写的&lt;b&gt;Pod :: Text&lt;/b&gt;代码</target>
        </trans-unit>
        <trans-unit id="d91768d646bf2b1ba37683cf7ff89c9b306d5b4f" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">基于Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;编写的&lt;b&gt;pod2text（1）的&lt;/b&gt;代码</target>
        </trans-unit>
        <trans-unit id="e809a71bc55e573d735398064fa73868c841b25e" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">基于Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;编写的&lt;b&gt;pod2text&lt;/b&gt;代码</target>
        </trans-unit>
        <trans-unit id="23082a2ee1ef553f8b8e9cc56e439b97636f01bf" translate="yes" xml:space="preserve">
          <source>Based on code written by Shigio Yamaguchi.</source>
          <target state="translated">基于山口重雄编写的代码。</target>
        </trans-unit>
        <trans-unit id="8e0d5bb83e47c2192346afc47fe774052eb51e39" translate="yes" xml:space="preserve">
          <source>Based on example that was initially added to MIME::QuotedPrint.pm for the 5.8.0 distribution of Perl.</source>
          <target state="translated">基于最初添加到MIME::QuotedPrint.pm中的Perl 5.8.0版本的例子。</target>
        </trans-unit>
        <trans-unit id="a800ab4559098c87aba7a8e90188704683d129b8" translate="yes" xml:space="preserve">
          <source>Based on ideas from Tim Bunce &amp;lt;&lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt; and</source>
          <target state="translated">基于Tim Bunce &amp;lt; &lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt;的想法，以及</target>
        </trans-unit>
        <trans-unit id="01bb16997fde52e47c429c6fd628c8c4ddf3054c" translate="yes" xml:space="preserve">
          <source>Based on ideas from Tim Bunce &amp;lt;&lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt;&amp;gt; and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef4b57022699f0d3f5da98a8d57cddc66db361df" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;:perlio&lt;/code&gt; layer.</source>
          <target state="translated">基于 &lt;code&gt;:perlio&lt;/code&gt; 层。</target>
        </trans-unit>
        <trans-unit id="6189eca4d6c06b60af97bb9ce0c1f1fc615c134d" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; code by Larry Wall and the Perl 5 Porters, which was released under the same license terms.</source>
          <target state="translated">基于Larry Wall和Perl 5 Porters 的 &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; 代码，该代码在相同的许可条款下发布。</target>
        </trans-unit>
        <trans-unit id="da8636da22477810e470724d83ddc721d3335da8" translate="yes" xml:space="preserve">
          <source>Based on the Glossary of</source>
          <target state="translated">根据《术语表》。</target>
        </trans-unit>
        <trans-unit id="f28c9a8ac3d744f82801c7cfbb9de24801e7c563" translate="yes" xml:space="preserve">
          <source>Based on xsubpp code, written by Larry Wall.</source>
          <target state="translated">基于xsubpp代码,由Larry Wall编写。</target>
        </trans-unit>
        <trans-unit id="02905231fdcd4472df63f80b291fb153344c31cd" translate="yes" xml:space="preserve">
          <source>Basic BLOCKs</source>
          <target state="translated">基本模块</target>
        </trans-unit>
        <trans-unit id="901e56ace2d31ac4485efe2aa588116787957443" translate="yes" xml:space="preserve">
          <source>Basic IO operations</source>
          <target state="translated">基本的IO操作</target>
        </trans-unit>
        <trans-unit id="8422cb1795fcef709d3e089320f56308fec39046" translate="yes" xml:space="preserve">
          <source>Basic Multilingual Plane</source>
          <target state="translated">基本多语种平面</target>
        </trans-unit>
        <trans-unit id="ccecd116866361404babdb87c039096fbb71e99c" translate="yes" xml:space="preserve">
          <source>Basic Structure</source>
          <target state="translated">基本结构</target>
        </trans-unit>
        <trans-unit id="39bbc4bee9f4a75c10797a6d328f733ea1124880" translate="yes" xml:space="preserve">
          <source>Basic Thread Support</source>
          <target state="translated">基本线程支持</target>
        </trans-unit>
        <trans-unit id="17f89c170a632afd0c0b0383dacf728c05a89851" translate="yes" xml:space="preserve">
          <source>Basic Utilities for Programmers</source>
          <target state="translated">程序员的基本工具</target>
        </trans-unit>
        <trans-unit id="148d2121cd077901af2d5cbf9aa363677304a06b" translate="yes" xml:space="preserve">
          <source>Basic commands:</source>
          <target state="translated">基本命令。</target>
        </trans-unit>
        <trans-unit id="7308cb8418c068204c128968b5967fdf3606cc09" translate="yes" xml:space="preserve">
          <source>Basic methods</source>
          <target state="translated">基本方法</target>
        </trans-unit>
        <trans-unit id="874d9df75ebdafc19870b90059bb69c04cb1fce7" translate="yes" xml:space="preserve">
          <source>Basic read operation.</source>
          <target state="translated">基本读操作。</target>
        </trans-unit>
        <trans-unit id="c4901220ad10be08f037f204182ab7f0bb55ef8b" translate="yes" xml:space="preserve">
          <source>Basic semaphores</source>
          <target state="translated">基本信号词</target>
        </trans-unit>
        <trans-unit id="cf61d93532db2a473529a2856c70f230829513f8" translate="yes" xml:space="preserve">
          <source>Basic syntax overview</source>
          <target state="translated">基本语法概述</target>
        </trans-unit>
        <trans-unit id="ce7944aa05e48b110f9c5b8903d70aed90358355" translate="yes" xml:space="preserve">
          <source>Basic utilities for writing tests.</source>
          <target state="translated">编写测试的基本工具。</target>
        </trans-unit>
        <trans-unit id="62b9ac85afbcfa7bd7a8e867b1f51756e30ca7d7" translate="yes" xml:space="preserve">
          <source>Basic write operation.</source>
          <target state="translated">基本的写操作。</target>
        </trans-unit>
        <trans-unit id="04e2b1373d1c985716d261c139c35de4bc421d62" translate="yes" xml:space="preserve">
          <source>Basically, Intel and VAX CPUs are little-endian, while everybody else, including Motorola m68k/88k, PPC, Sparc, HP PA, Power, and Cray, are big-endian. Alpha and MIPS can be either: Digital/Compaq uses (well, used) them in little-endian mode, but SGI/Cray uses them in big-endian mode.</source>
          <target state="translated">基本上,Intel和VAX的CPU都是小迭代的,而其他人,包括Motorola m68k/88k、PPC、Sparc、HP PA、Power和Cray,都是大迭代的。Alpha和MIPS都可以。Digital/Compaq公司用的是(好吧,用过的)小迭代模式,但SGI/Cray公司用的是大迭代模式。</target>
        </trans-unit>
        <trans-unit id="1f10fe5797c3d1f7733a7eb604c9de17cf9d91ac" translate="yes" xml:space="preserve">
          <source>Basically, you fetch individual results from the TAP. The six types, with examples of each, are as follows:</source>
          <target state="translated">基本上,你从TAP中获取个别结果。六种类型以及每种类型的例子如下。</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="4beb8f757ba4e13e29ffb8c6a2d654b5eee3dc8e" translate="yes" xml:space="preserve">
          <source>Baud rate values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3764ce6b277261088796ef6723dbaafdda0e32f0" translate="yes" xml:space="preserve">
          <source>Be aware of two important points:</source>
          <target state="translated">要注意两个重要点。</target>
        </trans-unit>
        <trans-unit id="9042cbc9bb8a8748d18e82d265eee86b54008013" translate="yes" xml:space="preserve">
          <source>Be aware that all exceptions are stringified during construction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4436a305cd04dc72f8078b037e6c2a662f1fa1d" translate="yes" xml:space="preserve">
          <source>Be aware that all filenames returned from File::Glob are tainted.</source>
          <target state="translated">要知道,所有从File::Glob返回的文件名都有污点。</target>
        </trans-unit>
        <trans-unit id="3297ac638d07f74b1cf62949925d4b3e23422ec7" translate="yes" xml:space="preserve">
          <source>Be aware that many files in the distribution are derivative--avoid patching them, because git won't see the changes to them, and the build process will overwrite them. Patch the originals instead. Most utilities (like perldoc) are in this category, i.e. patch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f217633ac67f75e40713203caa69acc0ee5347" translate="yes" xml:space="preserve">
          <source>Be aware that setting &lt;code&gt;@DB::args&lt;/code&gt; is</source>
          <target state="translated">请注意，设置 &lt;code&gt;@DB::args&lt;/code&gt; 为</target>
        </trans-unit>
        <trans-unit id="667b9a553537bba23ef30dd15f8a2bf40c9a72d6" translate="yes" xml:space="preserve">
          <source>Be aware that the digest routines silently convert UTF-8 input into its equivalent byte sequence in the native encoding (cf. utf8::downgrade). This side effect influences only the way Perl stores the data internally, but otherwise leaves the actual value of the data intact.</source>
          <target state="translated">请注意,digest例程会默默地将UTF-8输入转换为等价的本地编码字节序列(参见utf8::downgrade)。这个副作用只影响Perl内部存储数据的方式,但在其他情况下,数据的实际值是不变的。</target>
        </trans-unit>
        <trans-unit id="167d28f752fc336f0724d4becf42fb8c17cf60ad" translate="yes" xml:space="preserve">
          <source>Be aware that the file's type/creator and resource fork will be lost, which is usually what you want in cross-platform archives.</source>
          <target state="translated">请注意,文件的类型/创建者和资源分叉会丢失,这通常是你在跨平台存档中想要的。</target>
        </trans-unit>
        <trans-unit id="64b3ff265c6f33aa278b5fc7ab5adbd6a628d376" translate="yes" xml:space="preserve">
          <source>Be aware that the main value of this module is its simplicity. Note that there are already more ambitious modules out there, such as &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;Test::Unit&quot;&gt;Test::Unit&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a627d6aeb5bb9832269cd11d71094ebccabe8d0" translate="yes" xml:space="preserve">
          <source>Be aware that the main value of this module is its simplicity. Note that there are already more ambitious modules out there, such as &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test::Unit&lt;/a&gt;.</source>
          <target state="translated">请注意，此模块的主要价值在于其简单性。请注意，那里已经有更多雄心勃勃的模块，例如&lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test :: Unit&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f073a8ab4396a4ea1a82c329831db3a4c81e7bb9" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;a href=&quot;#caller-EXPR&quot;&gt;&lt;code&gt;caller&lt;/code&gt;&lt;/a&gt; had a chance to get the information. That means that &lt;code&gt;caller(N)&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt;. In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;a href=&quot;#caller-EXPR&quot;&gt;&lt;code&gt;caller&lt;/code&gt;&lt;/a&gt; was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31de5d87ee0c0608b86806f39ac15e28011be167" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">请注意，在 &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 有机会获取信息之前，优化器可能已经优化了呼叫帧。这意味着，对于 &lt;code&gt;N &amp;gt; 1&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; 可能不会返回有关您期望的呼叫帧的信息。特别是， &lt;code&gt;@DB::args&lt;/code&gt; 可能具有来自上一次 &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 信息。</target>
        </trans-unit>
        <trans-unit id="956f008e111339a547685e28f223bd6fbcba83d9" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">请注意，在 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 有机会获取信息之前，优化器可能已经优化了呼叫帧。这意味着，对于 &lt;code&gt;N &amp;gt; 1&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; 可能不会返回有关您期望的呼叫帧的信息。特别是， &lt;code&gt;@DB::args&lt;/code&gt; 可能具有来自上一次 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 信息。</target>
        </trans-unit>
        <trans-unit id="fd6d74606bcc17d1eb7f4b9d0cbb233b2fce04be" translate="yes" xml:space="preserve">
          <source>Be aware that the option to follow symbolic links can be dangerous. Depending on the structure of the directory tree (including symbolic links to directories) you might traverse a given (physical) directory more than once (only if &lt;code&gt;follow_fast&lt;/code&gt; is in effect). Furthermore, deleting or changing files in a symbolically linked directory might cause very unpleasant surprises, since you delete or change files in an unknown directory.</source>
          <target state="translated">请注意，遵循符号链接的选项可能很危险。根据目录树的结构（包括目录的符号链接），您可能会多次遍历给定的（物理）目录（仅当 &lt;code&gt;follow_fast&lt;/code&gt; 生效时）。此外，由于删除或更改了未知目录中的文件，因此删除或更改符号链接目录中的文件可能会引起非常不愉快的意外。</target>
        </trans-unit>
        <trans-unit id="b81ba14d3ce3de8180275845ca38e42a572b2c9a" translate="yes" xml:space="preserve">
          <source>Be aware that these operations are full Unix forks, which means they may not be correctly implemented on all alien systems.</source>
          <target state="translated">请注意,这些操作是完全的Unix分叉,这意味着它们可能无法在所有外来系统上正确实现。</target>
        </trans-unit>
        <trans-unit id="edbf362a8476b23d76d24466d122396a40549047" translate="yes" xml:space="preserve">
          <source>Be aware that these operations are full Unix forks, which means they may not be correctly implemented on all alien systems. See &lt;a href=&quot;perlport#open&quot;&gt;&quot;open&quot; in perlport&lt;/a&gt; for portability details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d4c04a6ec8f48645b28a87376c9f6999c39b61b" translate="yes" xml:space="preserve">
          <source>Be aware that this option makes you accept invalid JSON texts as if they were valid!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9573a203063d54f5dc27408bed7844c1be7ddce6" translate="yes" xml:space="preserve">
          <source>Be aware that this will export ANSI_COLORS_DISABLED to any child processes of your program as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9011ae4d69e158b2d5d9fa7d3f0fa4181ed416ab" translate="yes" xml:space="preserve">
          <source>Be aware that writing a multi-threaded application will not be portable to a platform which lacks the native thread-safe locale support. On systems that do have it, you automatically get this behavior for threaded perls, without having to do anything. If for some reason, you don't want to use this capability (perhaps the POSIX 2008 support is buggy on your system), you can manually compile Perl to use the old non-thread-safe implementation by passing the argument &lt;code&gt;-Accflags='-DNO_THREAD_SAFE_LOCALE'&lt;/code&gt; to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dac6d64c1feff1fddea48f799c315f06283805b" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source must be properly declared unless it is US-ASCII or Latin-1. POD input without an &lt;code&gt;=encoding&lt;/code&gt; command will be assumed to be in Latin-1, and if it's actually in UTF-8, the output will be double-encoded. See</source>
          <target state="translated">请注意，使用此选项时，除非是US-ASCII或Latin-1，否则必须正确声明POD源的输入编码。没有 &lt;code&gt;=encoding&lt;/code&gt; 命令的POD输入将被假定为Latin-1，如果实际上是UTF-8，则输出将被双重编码。看到</target>
        </trans-unit>
        <trans-unit id="112ebc66d2bbad303aae87da4af1076cd40b1dbe" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source should be properly declared unless it's US-ASCII. Pod::Simple will attempt to guess the encoding and may be successful if it's Latin-1 or UTF-8, but it will produce warnings. Use the &lt;code&gt;=encoding&lt;/code&gt; command to declare the encoding. See &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod(1)&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14539a0200a018d8bfd0c01f3ce67edac22b2e5e" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source should be properly declared unless it's US-ASCII. Pod::Simple will attempt to guess the encoding and may be successful if it's Latin-1 or UTF-8, but it will warn, which by default results in a &lt;b&gt;pod2man&lt;/b&gt; failure. Use the &lt;code&gt;=encoding&lt;/code&gt; command to declare the encoding. See &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod(1)&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b528c0888545102ae09966c077f548f42a0a07e8" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source should be properly declared unless it's US-ASCII. Pod::Simple will attempt to guess the encoding and may be successful if it's Latin-1 or UTF-8, but it will warn, which by default results in a &lt;b&gt;pod2text&lt;/b&gt; failure. Use the &lt;code&gt;=encoding&lt;/code&gt; command to declare the encoding. See &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod(1)&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e54fdab18656cd50e15f88c4bd2cd505cbcafa9" translate="yes" xml:space="preserve">
          <source>Be aware, moreover, that even among Unix-ish systems there are variations.</source>
          <target state="translated">此外,要知道,即使是在Unix左右的系统中,也存在着差异。</target>
        </trans-unit>
        <trans-unit id="56eaa37568b649078a87e40ea7bc8697501ac281" translate="yes" xml:space="preserve">
          <source>Be careful about the syntax,</source>
          <target state="translated">要注意语法。</target>
        </trans-unit>
        <trans-unit id="f8fdb4158175acb38dcf577960ceb71bd1d96eb9" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;a href=&quot;#formline-PICTURE%2CLIST&quot;&gt;&lt;code&gt;formline&lt;/code&gt;&lt;/a&gt; always returns true. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f347eeb5e9dd5ad6442952b1aeb5c318d4fa11" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">如果在图片两边加上双引号，请小心，因为 &lt;code&gt;@&lt;/code&gt; 字符可能表示数组名称的开头。 &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 始终返回true。有关其他示例，请参见&lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6906a7867a27a79ea2a227d91624d262e203f04e" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">如果在图片两边加上双引号，请小心，因为 &lt;code&gt;@&lt;/code&gt; 字符可能表示数组名称的开头。 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 始终返回true。有关其他示例，请参见&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4aaaf54937dcd1947fa04a848c937575a75bb3aa" translate="yes" xml:space="preserve">
          <source>Be careful in the tests you supply with your module or programs. Module code may be fully portable, but its tests might not be. This often happens when tests spawn off other processes or call external programs to aid in the testing, or when (as noted above) the tests assume certain things about the filesystem and paths. Be careful not to depend on a specific output style for errors, such as when checking &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; after a failed system call. Using &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; for anything else than displaying it as output is doubtful (though see the &lt;a href=&quot;errno&quot;&gt;&lt;code&gt;Errno&lt;/code&gt;&lt;/a&gt; module for testing reasonably portably for error value). Some platforms expect a certain output format, and Perl on those platforms may have been adjusted accordingly. Most specifically, don't anchor a regex when testing an error value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9293d7623c3a63a2528c6144b0e2f16fd9c21b7" translate="yes" xml:space="preserve">
          <source>Be careful in the tests you supply with your module or programs. Module code may be fully portable, but its tests might not be. This often happens when tests spawn off other processes or call external programs to aid in the testing, or when (as noted above) the tests assume certain things about the filesystem and paths. Be careful not to depend on a specific output style for errors, such as when checking &lt;code&gt;$!&lt;/code&gt; after a failed system call. Using &lt;code&gt;$!&lt;/code&gt; for anything else than displaying it as output is doubtful (though see the &lt;code&gt;Errno&lt;/code&gt; module for testing reasonably portably for error value). Some platforms expect a certain output format, and Perl on those platforms may have been adjusted accordingly. Most specifically, don't anchor a regex when testing an error value.</source>
          <target state="translated">在随模块或程序提供的测试中要小心。模块代码可能是完全可移植的，但其测试却可能不是。当测试派生其他进程或调用外部程序以帮助测试时，或者（如上文所述）测试假设文件系统和路径有某些规定时，通常会发生这种情况。注意不要依赖特定的输出样式来检查错误，例如在检查 &lt;code&gt;$!&lt;/code&gt; 时。系统调用失败后。使用 &lt;code&gt;$!&lt;/code&gt; 除了将其显示为输出外，其他任何方面都值得怀疑（尽管请参见 &lt;code&gt;Errno&lt;/code&gt; 模块以合理地移植其错误值）。一些平台期望某种输出格式，并且那些平台上的Perl可能已经进行了相应的调整。最具体地说，在测试错误值时不要锚定正则表达式。</target>
        </trans-unit>
        <trans-unit id="ae93e14e0d1be510a7665d0a55ac6aa4f668df14" translate="yes" xml:space="preserve">
          <source>Be careful to check that what you pass to chdir() is defined and not blank, else you might find yourself in your home directory.</source>
          <target state="translated">注意检查你传递给chdir()的内容是否被定义,而不是空白,否则你可能会发现自己的主目录。</target>
        </trans-unit>
        <trans-unit id="c85ebb348de7431489e7e78b8e62158b4eaa9740" translate="yes" xml:space="preserve">
          <source>Be careful to check the return values from both open() and close(). If you're</source>
          <target state="translated">要注意检查open()和close()的返回值。如果你是</target>
        </trans-unit>
        <trans-unit id="aee2df458bcc4bef02091d782f8436bc138473c7" translate="yes" xml:space="preserve">
          <source>Be careful to repeat this procedure every time you recompile an extension, unless you are sure the AFS installation directories are still valid.</source>
          <target state="translated">注意每次重新编译扩展时都要重复这个过程,除非你确定AFS安装目录仍然有效。</target>
        </trans-unit>
        <trans-unit id="fe76e94f1a35b852ed4a509f3683ff3f6a306181" translate="yes" xml:space="preserve">
          <source>Be careful when using the branch reset pattern in combination with named captures. Named captures are implemented as being aliases to numbered groups holding the captures, and that interferes with the implementation of the branch reset pattern. If you are using named captures in a branch reset pattern, it's best to use the same names, in the same order, in each of the alternations:</source>
          <target state="translated">当将分支重置模式与命名捕获结合使用时要小心。命名捕获的实现是对持有捕获的编号组的别名,这干扰了分支复位模式的实现。如果您在分支重置模式中使用命名捕获,最好在每一次交替中使用相同的名称,顺序相同。</target>
        </trans-unit>
        <trans-unit id="8f8df673aaa9f753cd8e9cf23c8cbbd3b2574c49" translate="yes" xml:space="preserve">
          <source>Be careful, though, to never combine text strings with binary strings. If you need text in a binary stream, encode your text strings first using the appropriate encoding, then join them with binary strings. See also: &quot;What if I don't encode?&quot;.</source>
          <target state="translated">但要注意,千万不要将文本字符串与二进制字符串结合起来。如果你需要二进制流中的文本,请先使用适当的编码对文本字符串进行编码,然后用二进制字符串加入它们。另请参见 &quot;如果我不编码怎么办?&quot;.</target>
        </trans-unit>
        <trans-unit id="cef4ef62c32e58e84f80436ec819bfd5a7afa02c" translate="yes" xml:space="preserve">
          <source>Be careful: qx(), system(), and some modules for calling external commands do a fork(), then wait() for the result. Thus, your signal handler will be called. Because wait() was already called by system() or qx(), the wait() in the signal handler will see no more zombies and will therefore block.</source>
          <target state="translated">小心:qx()、system()和一些调用外部命令的模块会先做fork(),然后等待()结果。这样,你的信号处理程序就会被调用。因为wait()已经被system()或qx()调用了,所以信号处理程序中的wait()不会再看到僵尸,因此会阻塞。</target>
        </trans-unit>
        <trans-unit id="02350f9e1a884f10cacbddf6be8d623a44b68fcb" translate="yes" xml:space="preserve">
          <source>Be consistent with existing modules.</source>
          <target state="translated">与现有模块保持一致。</target>
        </trans-unit>
        <trans-unit id="8f9f60dfc3f60d9409a16936419f8f9c34030221" translate="yes" xml:space="preserve">
          <source>Be consistent.</source>
          <target state="translated">要保持一致。</target>
        </trans-unit>
        <trans-unit id="0657b8fedf171a48206a6318d37358a77e53c6fb" translate="yes" xml:space="preserve">
          <source>Be descriptive (i.e. accurately describes the purpose of the module).</source>
          <target state="translated">要有描述性(即准确描述模块的目的);</target>
        </trans-unit>
        <trans-unit id="4866ce84e5913e3bbf14d1ef419eb24f1d72a52e" translate="yes" xml:space="preserve">
          <source>Be it &lt;code&gt;Compress::Zlib&lt;/code&gt; , &lt;code&gt;Apache::Request&lt;/code&gt; or any extension that has no mention of Unicode in the manpage, you need to make sure that the UTF8 flag is stripped off. Note that at the time of this writing (January 2012) the mentioned modules are not UTF-8-aware. Please check the documentation to verify if this is still true.</source>
          <target state="translated">无论是 &lt;code&gt;Compress::Zlib&lt;/code&gt; ， &lt;code&gt;Apache::Request&lt;/code&gt; 还是任何联机帮助页中未提及Unicode的扩展，都需要确保删除了UTF8标志。请注意，在撰写本文时（2012年1月），提到的模块尚不支持UTF-8。请检查文档以确认是否仍然正确。</target>
        </trans-unit>
        <trans-unit id="9583b4e268c09c5404dc953e2a7280e9a611066c" translate="yes" xml:space="preserve">
          <source>Be it &lt;code&gt;Compress::Zlib&lt;/code&gt;, &lt;code&gt;Apache::Request&lt;/code&gt; or any extension that has no mention of Unicode in the manpage, you need to make sure that the UTF8 flag is stripped off. Note that at the time of this writing (January 2012) the mentioned modules are not UTF-8-aware. Please check the documentation to verify if this is still true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec8bd9db93426cc5f677cbbc44d58f990b4ce4f" translate="yes" xml:space="preserve">
          <source>Be nice.</source>
          <target state="translated">乖一点</target>
        </trans-unit>
        <trans-unit id="455d700825e4b9a7601c1ce54b47786ce81ebe18" translate="yes" xml:space="preserve">
          <source>Be sure not to use a bareword as the name of a signal handler, lest you inadvertently call it.</source>
          <target state="translated">一定不要使用裸词作为信号处理程序的名称,以免无意中调用它。</target>
        </trans-unit>
        <trans-unit id="adcfe790c3214b8902aa2d9bdbc7f166d3aa2497" translate="yes" xml:space="preserve">
          <source>Be sure that your yacc installation is in place including any necessary parser template files. If you have not already done so then be sure to:</source>
          <target state="translated">请确认您的yacc已经安装到位,包括任何必要的解析器模板文件。如果您还没有安装,请务必安装。</target>
        </trans-unit>
        <trans-unit id="7a2fea634f3d3c3b87d0ddfbb5348eeeda046aad" translate="yes" xml:space="preserve">
          <source>Be sure to adequately comment your code. While commenting every line is unnecessary, anything that takes advantage of side effects of operators, that creates changes that will be felt outside of the function being patched, or that others may find confusing should be documented. If you are going to err, it is better to err on the side of adding too many comments than too few.</source>
          <target state="translated">一定要对你的代码进行充分的注释。虽然没有必要对每一行都进行注释,但任何利用运算符的副作用、在被修补的函数之外产生变化、或者其他人可能会感到困惑的东西都应该被记录下来。如果你要出错,最好是在添加太多注释的一边出错,而不是太少。</target>
        </trans-unit>
        <trans-unit id="df103353e12184ad2bab2c528d00c711c155c484" translate="yes" xml:space="preserve">
          <source>Be sure to include the &lt;b&gt;exact&lt;/b&gt; error messages, if any. &quot;Perl gave an error&quot; is not an exact error message.</source>
          <target state="translated">请确保包括&lt;b&gt;确切的&lt;/b&gt;错误消息（如果有）。&amp;ldquo; Perl提供了错误&amp;rdquo;不是确切的错误消息。</target>
        </trans-unit>
        <trans-unit id="fb3f786d0833cb9684920951669ea14a5f8c452b" translate="yes" xml:space="preserve">
          <source>Be sure to read &lt;a href=&quot;#ENCODING&quot;&gt;&quot;ENCODING&quot;&lt;/a&gt; if your Pod contains non-ASCII characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5cbd612657dfbf7a92d6606e16853c43b77addf" translate="yes" xml:space="preserve">
          <source>Be sure to read &lt;a href=&quot;#ENCODING&quot;&gt;ENCODING&lt;/a&gt; if your Pod contains non-ASCII characters.</source>
          <target state="translated">如果您的Pod包含非ASCII字符，请务必阅读&lt;a href=&quot;#ENCODING&quot;&gt;编码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2984603dd54138b13d352a1e3fd61b6408be6b9f" translate="yes" xml:space="preserve">
          <source>Be sure to read the instructions near the top of the makefiles carefully.</source>
          <target state="translated">请务必仔细阅读makefiles顶部附近的说明。</target>
        </trans-unit>
        <trans-unit id="7f00ff2068b10342c9156aa44f6e62fb9656c3bb" translate="yes" xml:space="preserve">
          <source>Be sure to specify Perl version requirements both in Makefile.PL or Build.PL and with &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; or similar. See the section on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; of &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for details.</source>
          <target state="translated">确保在Makefile.PL或Build.PL中以及 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; 或类似版本中指定Perl版本要求。查看部分 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; 的&lt;a href=&quot;functions/require&quot;&gt;要求&lt;/a&gt;了解详情。</target>
        </trans-unit>
        <trans-unit id="395569931cbd630cae76e8ec72604be440821c6b" translate="yes" xml:space="preserve">
          <source>Be sure to specify Perl version requirements both in Makefile.PL or Build.PL and with &lt;code&gt;require 5.6.1&lt;/code&gt; or similar. See the section on &lt;code&gt;use VERSION&lt;/code&gt; of &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c733e8a30868a3838b1dfa41af03cf511ee097ca" translate="yes" xml:space="preserve">
          <source>Be sure to use a tar program compiled under Solaris (not SunOS 4.x) to extract the perl-5.x.x.tar.gz file. Do not use GNU tar compiled for SunOS4 on Solaris. (GNU tar compiled for Solaris should be fine.) When you run SunOS4 binaries on Solaris, the run-time system magically alters pathnames matching m#lib/locale# so that when tar tries to create lib/locale.pm, a file named lib/oldlocale.pm gets created instead. If you found this advice too late and used a SunOS4-compiled tar anyway, you must find the incorrectly renamed file and move it back to lib/locale.pm.</source>
          <target state="translated">请务必使用在 Solaris 下编译的 tar 程序(不是 SunOS 4.x)来解压缩 perl-5.x.x.tar.gz 文件。不要在 Solaris 上使用为 SunOS4 编译的 GNU tar 程序。当你在 Solaris 上运行 SunOS4 二进制文件时,运行时系统会神奇地改变与 m#lib/locale#匹配的路径名,因此当 tar 尝试创建 lib/locale.pm 时,会创建一个名为 lib/oldlocale.pm 的文件。如果你发现这个建议太晚了,而且还是使用了 SunOS4 编译的 tar,你必须找到那个重命名错误的文件,并把它移回 lib/locale.pm。</target>
        </trans-unit>
        <trans-unit id="5d818ab86968387d2a89aaa4ecb39ab429064672" translate="yes" xml:space="preserve">
          <source>Be sure to use the libraries and modules shipped with the version being tested, not those that were already installed.</source>
          <target state="translated">请确保使用正在测试的版本所附带的库和模块,而不是那些已经安装的库和模块。</target>
        </trans-unit>
        <trans-unit id="e3d356b4e65052f33c752664cb97b29222d4870b" translate="yes" xml:space="preserve">
          <source>Be very careful with Perl operations that change the value of the variable. Appending something to the variable, for instance, might require reallocation of its storage, leaving you with a pointer into no-man's land.</source>
          <target state="translated">对于改变变量值的Perl操作要非常小心。例如,在变量中添加一些东西,可能需要重新分配它的存储空间,让你的指针进入无人之境。</target>
        </trans-unit>
        <trans-unit id="a9df705eca9ff235f56efac76a8ae2aff600e09f" translate="yes" xml:space="preserve">
          <source>Be warned that neither creation nor deletion of files is guaranteed to be an atomic operation over NFS. That is, two processes might both successfully create or unlink the same file! Therefore O_EXCL isn't as exclusive as you might wish.</source>
          <target state="translated">请注意,无论是创建还是删除文件,都不能保证在NFS上是一个原子操作。也就是说,两个进程可能会同时成功地创建或解除同一个文件的链接。因此O_EXCL并不像你希望的那样具有排他性。</target>
        </trans-unit>
        <trans-unit id="15b58e5a1a4863b537d4c8fb01a3a9bfffd23c29" translate="yes" xml:space="preserve">
          <source>Be warned that proxying an &lt;code&gt;https&lt;/code&gt; connection opens you to the risk of a man-in-the-middle attack by the proxy server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7184ad30ab6a73d32aaec035835bc55ad15b3389" translate="yes" xml:space="preserve">
          <source>Be warned that some formatters cannot reliably render characters outside 32-126; and many are able to handle 32-126 and 160-255, but nothing above 255.</source>
          <target state="translated">请注意,一些格式化程序不能可靠地渲染32-126以外的字符;许多格式化程序能够处理32-126和160-255,但不能处理255以上的字符。</target>
        </trans-unit>
        <trans-unit id="8235118c9cdc1cd037bd4ff9c8b6234c4eceb334" translate="yes" xml:space="preserve">
          <source>Be warned that this feature is considered experimental, and may be changed without notice.</source>
          <target state="translated">请注意,此功能被认为是试验性的,可能会在不通知的情况下进行更改。</target>
        </trans-unit>
        <trans-unit id="f60dd616afaa8860904852bce46c16c4c9385db0" translate="yes" xml:space="preserve">
          <source>Be warned, though, that unlike regular expressions, if the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; template doesn't match the incoming data, Perl will scream and die.</source>
          <target state="translated">但是请注意，与正则表达式不同，如果 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 模板与传入的数据不匹配，Perl将会尖叫并死亡。</target>
        </trans-unit>
        <trans-unit id="02d6d74dc9a4db2057c5683472b9fbbb7012f2b3" translate="yes" xml:space="preserve">
          <source>Be warned, though, that unlike regular expressions, if the &lt;code&gt;unpack&lt;/code&gt; template doesn't match the incoming data, Perl will scream and die.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34bea745032a10b52d62f12a9de185a88d00d76" translate="yes" xml:space="preserve">
          <source>Be warned: just as the C-preprocessor doesn't know C, the Debug filter doesn't know Perl. It can be fooled quite easily:</source>
          <target state="translated">请注意:就像C-预处理器不懂C一样,Debug过滤器也不懂Perl。它很容易被愚弄。</target>
        </trans-unit>
        <trans-unit id="29bff63d2a655090d41ce27755886c450bf1e989" translate="yes" xml:space="preserve">
          <source>BeOS is BeOS.</source>
          <target state="translated">BeOS就是BeOS。</target>
        </trans-unit>
        <trans-unit id="7127634cd20ce1300143c5a508c993ef4fdbd8f4" translate="yes" xml:space="preserve">
          <source>Because &quot;perlio.h&quot; is a thin layer (for efficiency) the semantics of these functions are somewhat dependent on the underlying implementation. Where these variations are understood they are noted below.</source>
          <target state="translated">因为 &quot;perlio.h &quot;是一个薄层(为了提高效率),这些函数的语义在某种程度上取决于底层的实现。在理解这些变化的情况下,它们在下面被指出。</target>
        </trans-unit>
        <trans-unit id="370f88e98782bfa7f114dbe532b100225210e150" translate="yes" xml:space="preserve">
          <source>Because 1 + 1 is 2, it prints:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e172ead13ccd2d2e8aa5c2a8960bb8d1e75406d" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;#scalar-EXPR&quot;&gt;&lt;code&gt;scalar&lt;/code&gt;&lt;/a&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b453ad82fa85092fb1368c3fb85257f0cedd1e" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ddac942d8eb120d517202681a1ab56648b51a75" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; is a global variable, be careful that analyzing an exception caught by &lt;code&gt;eval&lt;/code&gt; doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b63ce495f650d704c02d64d23b111efdfe40cd61" translate="yes" xml:space="preserve">
          <source>Because &lt;b&gt;perldoc&lt;/b&gt; does not run properly tainted, and is known to have security issues, when run as the superuser it will attempt to drop privileges by setting the effective and real IDs to nobody's or nouser's account, or -2 if unavailable. If it cannot relinquish its privileges, it will not run.</source>
          <target state="translated">由于&lt;b&gt;perldoc&lt;/b&gt;运行不正常，并且存在安全问题，因此当以超级用户身份运行时，它将尝试通过将有效和真实ID设置为任何人或nouser的帐户或-2（如果不可用）来放弃特权。如果它不能放弃其特权，它将不会运行。</target>
        </trans-unit>
        <trans-unit id="400d81a8582d02a7d364c167bb3655c111853cb4" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; trigger interpolation, you'll need to use something like &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; to match them literally.</source>
          <target state="translated">由于 &lt;code&gt;$&lt;/code&gt; 或 &lt;code&gt;@&lt;/code&gt; 触发插值，因此您需要使用 &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; 之类的字面值。</target>
        </trans-unit>
        <trans-unit id="b667c475fa92312c7083687d2886a12150dc73b8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$sv&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when the &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; operator is applied to it, the transliteration won't actually execute and the program won't &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. This is different to how 5.8 and earlier versions behaved since the capture variables were READONLY variables then; now they'll just die when assigned to in the default engine.</source>
          <target state="translated">由于在应用 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 运算符时 &lt;code&gt;$sv&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，因此音译将不会真正执行，程序也不会 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 。这与5.8和更早版本的行为方式不同，因为捕获变量当时是READONLY变量。现在，在默认引擎中将它们分配给它们时，它们只会死亡。</target>
        </trans-unit>
        <trans-unit id="6c984d748d72c5bb3b2196996f098ba27134cde9" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$sv&lt;/code&gt; is &lt;code&gt;undef&lt;/code&gt; when the &lt;code&gt;y///&lt;/code&gt; operator is applied to it, the transliteration won't actually execute and the program won't &lt;code&gt;die&lt;/code&gt;. This is different to how 5.8 and earlier versions behaved since the capture variables were READONLY variables then; now they'll just die when assigned to in the default engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b914e32b809fa7c48d9ec627188d82ebed09a33b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt;. The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt;s from the input list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5addc5234910932f591ed79ef1118cfac8717e21" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">因为当任何一个操作数为 &lt;code&gt;NaN&lt;/code&gt; （非数字）时 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，所以在使用类似 &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; 类的比较函数进行排序时，请小心任何可能包含 &lt;code&gt;NaN&lt;/code&gt; 的列表。以下示例利用 &lt;code&gt;NaN != NaN&lt;/code&gt; 来从输入列表中消除任何 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbfd747a0cfe35cb8ad11b2926956f99d4f77a54" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">因为当任何一个操作数为 &lt;code&gt;NaN&lt;/code&gt; （非数字）时 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，所以在使用类似 &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; 类的比较函数进行排序时，请小心任何可能包含 &lt;code&gt;NaN&lt;/code&gt; 的列表。以下示例利用 &lt;code&gt;NaN != NaN&lt;/code&gt; 来从输入列表中消除任何 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89d0f8e67a21f5d12b3d2f9f3bbfa73cf7cb9115" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; is special in regular expressions, and can match any single character, the regex &lt;code&gt;P.&lt;/code&gt; here has matched the &amp;lt;Pl&amp;gt; in the original string.</source>
          <target state="translated">因为 &lt;code&gt;.&lt;/code&gt; 在正则表达式中是特殊的，并且可以匹配任何单个字符，正则表达式 &lt;code&gt;P.&lt;/code&gt; 此处已匹配原始字符串中的&amp;lt;Pl&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="19a20b9f3a218df5a7c84d8e40e3cdca6928cac3" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; was in use as a directory separator and filenames could not be assumed to be unique after 10 characters, Acorn implemented the C compiler to strip the trailing &lt;code&gt;.c&lt;/code&gt;&lt;code&gt;.h&lt;/code&gt;&lt;code&gt;.s&lt;/code&gt; and &lt;code&gt;.o&lt;/code&gt; suffix from filenames specified in source code and store the respective files in subdirectories named after the suffix. Hence files are translated:</source>
          <target state="translated">因为 &lt;code&gt;.&lt;/code&gt; 用作目录分隔符，并且不能假定文件名在10个字符后是唯一的，Acorn实现了C编译器，从源代码中指定的文件名中删除结尾的 &lt;code&gt;.c&lt;/code&gt; &lt;code&gt;.h&lt;/code&gt; &lt;code&gt;.s&lt;/code&gt; 和 &lt;code&gt;.o&lt;/code&gt; 后缀并存储相应的文件在以后缀命名的子目录中。因此文件被翻译为：</target>
        </trans-unit>
        <trans-unit id="daf7ef166b9a7929b988f6a60b2c3afc2523b46d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; is a run-time operator, it gets executed each time through a loop. Consequently, it's more efficient to localize your variables outside the loop.</source>
          <target state="translated">因为 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 是运行时运算符，所以每次都会通过循环执行它。因此，将变量本地化到循环外会更有效。</target>
        </trans-unit>
        <trans-unit id="2f69348654d069c347e7c5732088634fa13b4fd6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">由于 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 是一元运算符，因此，如果您不小心在EXPR上使用了带括号的列表，则它的行为就像是标量逗号表达式，对空上下文中除最后一个元素以外的所有元素求值，并返回在标量上下文中求值的最终元素。这很少是您想要的。</target>
        </trans-unit>
        <trans-unit id="f2af4d959eb62b1a9bf83d9e5254d41aa11be74b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">因为 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 在编译时生效，所以它不尊重正在编译的代码的普通流控制。特别是，将 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 置于条件的false分支内不会阻止对其进行处理。如果仅需要有条件地加载模块或编译指示，则可以使用&lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;编译指示来完成：</target>
        </trans-unit>
        <trans-unit id="4bb9a434db491939507421e019d5c81a08c7de9d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">由于 &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 是一元运算符，因此，如果您不小心在EXPR上使用了带括号的列表，则它的行为就像是标量逗号表达式，对空上下文中除最后一个元素以外的所有元素求值，并返回在标量上下文中求值的最终元素。这很少是您想要的。</target>
        </trans-unit>
        <trans-unit id="c409d5f2e3bc5948e94957a82aeec5c28556f99d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">因为 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 在编译时生效，所以它不尊重正在编译的代码的普通流控制。特别是，将 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 置于条件的false分支内不会阻止对其进行处理。如果仅需要有条件地加载模块或编译指示，则可以使用&lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt;编译指示来完成：</target>
        </trans-unit>
        <trans-unit id="3f563a9178b31c7b0b34b9e11ab4a6bde66fbd45" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;DESTROY&lt;/code&gt; methods can be called at any time, you should localize any global status variables that might be set by anything you do in your &lt;code&gt;DESTROY&lt;/code&gt; method. If you are in doubt about a particular status variable, it doesn't hurt to localize it. There are five global status variables, and the safest way is to localize all five of them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ea34c50bf47a71dd29a5e22af22a7376e9666b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;DESTROY&lt;/code&gt; methods can be called at any time, you should localize any global variables you might update in your &lt;code&gt;DESTROY&lt;/code&gt; . In particular, if you use &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; you should localize &lt;code&gt;$@&lt;/code&gt; , and if you use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or backticks you should localize &lt;code&gt;$?&lt;/code&gt; .</source>
          <target state="translated">因为可以随时调用 &lt;code&gt;DESTROY&lt;/code&gt; 方法，所以您应该本地化可能在 &lt;code&gt;DESTROY&lt;/code&gt; 中更新的所有全局变量。特别是，如果您使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; ，则应本地化 &lt;code&gt;$@&lt;/code&gt; ；如果使用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 或反引号，则应本地化 &lt;code&gt;$?&lt;/code&gt; 。。</target>
        </trans-unit>
        <trans-unit id="1b1a7e8c9b3926d0057e1f91a59eec1bca6ac0fe" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt; prove passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even when prove is run in taint mode.</source>
          <target state="translated">因为在测试过程中经常使用 &lt;code&gt;PERL5LIB&lt;/code&gt; 将构建目录添加到 &lt;code&gt;@INC&lt;/code&gt; ， &lt;code&gt;PERL5LIB&lt;/code&gt; 将-I开关传递在PERL5LIB中找到的任何目录的名称。这样做的净效果是，即使在污点模式下运行证明， &lt;code&gt;PERL5LIB&lt;/code&gt; 也会受到尊重。</target>
        </trans-unit>
        <trans-unit id="8d8b86b2aa791fa81fa4a800514b6911cd4cea09" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt;&lt;code&gt;Test::Harness&lt;/code&gt; passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even in taint mode.</source>
          <target state="translated">因为在测试期间经常使用 &lt;code&gt;PERL5LIB&lt;/code&gt; 将构建目录添加到 &lt;code&gt;@INC&lt;/code&gt; &lt;code&gt;Test::Harness&lt;/code&gt; 会在-I切换时传递在 &lt;code&gt;PERL5LIB&lt;/code&gt; 中找到的任何目录的名称。这样做的最终结果是，即使在异味模式下， &lt;code&gt;PERL5LIB&lt;/code&gt; 也能获得荣誉。</target>
        </trans-unit>
        <trans-unit id="528ed40a74786c9daeb579970bad493df64c4a75" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PL_restartop&lt;/code&gt; is non-null, &lt;code&gt;run_body&lt;/code&gt; starts a new runops loop and execution continues.</source>
          <target state="translated">因为 &lt;code&gt;PL_restartop&lt;/code&gt; 不为null， &lt;code&gt;run_body&lt;/code&gt; 启动一个新的runops循环并继续执行。</target>
        </trans-unit>
        <trans-unit id="add12825d3665c5532bcf2a78d2469e31a8a7e9f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;STORABLE_attach&lt;/code&gt; is passed the class (rather than an object), it also returns the object directly, rather than modifying the passed object.</source>
          <target state="translated">因为 &lt;code&gt;STORABLE_attach&lt;/code&gt; 是通过类（而不是对象）传递的，所以它也直接返回对象，而不是修改传递的对象。</target>
        </trans-unit>
        <trans-unit id="65e2bf1b173528f8a073f03b46510698c20426ce" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;local&lt;/code&gt; is a run-time operator, it gets executed each time through a loop. Consequently, it's more efficient to localize your variables outside the loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308ec40cfa786d712d62a1e76733c4c3028b3e68" translate="yes" xml:space="preserve">
          <source>Because Acorns use ASCII with newlines (&lt;code&gt;\n&lt;/code&gt; ) in text files as &lt;code&gt;\012&lt;/code&gt; like Unix, and because Unix filename emulation is turned on by default, most simple scripts will probably work &quot;out of the box&quot;. The native filesystem is modular, and individual filesystems are free to be case-sensitive or insensitive, and are usually case-preserving. Some native filesystems have name length limits, which file and directory names are silently truncated to fit. Scripts should be aware that the standard filesystem currently has a name length limit of &lt;b&gt;10&lt;/b&gt; characters, with up to 77 items in a directory, but other filesystems may not impose such limitations.</source>
          <target state="translated">因为像橡树一样，橡子在文本文件中将ASCII和换行符（ &lt;code&gt;\n&lt;/code&gt; ）像 &lt;code&gt;\012&lt;/code&gt; 一样使用Unix，并且因为Unix文件名仿真默认情况下处于打开状态，所以大多数简单的脚本都可能&amp;ldquo;开箱即用&amp;rdquo;地工作。本机文件系统是模块化的，各个文件系统可以自由区分大小写或不区分大小写，并且通常保持大小写不变。某些本机文件系统具有名称长度限制，这些文件和目录名称会被自动截断以适合。脚本应注意，标准文件系统当前的名称长度限制为&lt;b&gt;10个&lt;/b&gt;字符，一个目录中最多可包含77个项目，但其他文件系统可能未施加此类限制。</target>
        </trans-unit>
        <trans-unit id="28c382ede78c908c2143af19dbf455bab6188b9c" translate="yes" xml:space="preserve">
          <source>Because Acorns use ASCII with newlines (&lt;code&gt;\n&lt;/code&gt;) in text files as &lt;code&gt;\012&lt;/code&gt; like Unix, and because Unix filename emulation is turned on by default, most simple scripts will probably work &quot;out of the box&quot;. The native filesystem is modular, and individual filesystems are free to be case-sensitive or insensitive, and are usually case-preserving. Some native filesystems have name length limits, which file and directory names are silently truncated to fit. Scripts should be aware that the standard filesystem currently has a name length limit of &lt;b&gt;10&lt;/b&gt; characters, with up to 77 items in a directory, but other filesystems may not impose such limitations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="828cb90cec8613e5d83ab546b1c59479cecb4072" translate="yes" xml:space="preserve">
          <source>Because C has no builtin function for integer exponentiation, let's make Perl's ** operator available to it (this is less useful than it sounds, because Perl implements ** with C's</source>
          <target state="translated">因为C语言没有内置的整数指数函数,所以我们让Perl的**运算符为它所用(这比听起来要有用,因为Perl用C语言的</target>
        </trans-unit>
        <trans-unit id="9459aa14a3cec514837284733b6c7f9c5dcb8910" translate="yes" xml:space="preserve">
          <source>Because Perl allows you to use barewords for package names and subroutine names, it sometimes interprets a bareword's meaning incorrectly. For example, the construct &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; can be interpreted as either &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; or &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; . In English, that second interpretation reads as &quot;call a subroutine named Class(), then call new() as a method on the return value of Class()&quot;. If there is a subroutine named &lt;code&gt;Class()&lt;/code&gt; in the current namespace, Perl will always interpret &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; as the second alternative: a call to &lt;code&gt;new()&lt;/code&gt; on the object returned by a call to &lt;code&gt;Class()&lt;/code&gt;</source>
          <target state="translated">因为Perl允许您将裸词用于程序包名称和子例程名称，所以有时它会错误地解释裸词的含义。例如，构造 &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; 可以解释为 &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; 或 &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; 。用英语来说，第二种解释为&amp;ldquo;调用一个名为Class（）的子例程，然后将new（）作为对Class（）返回值的方法进行调用&amp;rdquo;。如果当前名称空间中有一个名为 &lt;code&gt;Class()&lt;/code&gt; 的子例程，Perl将始终将 &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; 解释为第二种选择：对 &lt;code&gt;Class()&lt;/code&gt; 的调用返回的对象上的 &lt;code&gt;new()&lt;/code&gt; 的调用</target>
        </trans-unit>
        <trans-unit id="e0ebaa0b26d8e2869e78f420c4e273d09ec93726" translate="yes" xml:space="preserve">
          <source>Because Perl allows you to use barewords for package names and subroutine names, it sometimes interprets a bareword's meaning incorrectly. For example, the construct &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; can be interpreted as either &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; or &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt;. In English, that second interpretation reads as &quot;call a subroutine named Class(), then call new() as a method on the return value of Class()&quot;. If there is a subroutine named &lt;code&gt;Class()&lt;/code&gt; in the current namespace, Perl will always interpret &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; as the second alternative: a call to &lt;code&gt;new()&lt;/code&gt; on the object returned by a call to &lt;code&gt;Class()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aadc88ee4df674055a8e46229f25dab587fc29ec" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;../overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">由于Perl在显示之前对未捕获的异常消息进行了字符串化，因此您可能希望在异常对象上重载字符串化操作。有关详细信息，请参见&lt;a href=&quot;../overload&quot;&gt;重载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1c5024f83c23d4c6dafd0e63d9f2e92824de07b" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">由于Perl在显示之前对未捕获的异常消息进行了字符串化，因此您可能希望在异常对象上重载字符串化操作。有关详细信息，请参见&lt;a href=&quot;overload&quot;&gt;重载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="451d2525676f60927dbbc662f71037a75004b879" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; for details about that. The stringified message should be non-empty, and should end in a newline, in order to fit in with the treatment of string exceptions. Also, because an exception object reference cannot be stringified without destroying it, Perl doesn't attempt to append location or other information to a reference exception. If you want location information with a complex exception object, you'll have to arrange to put the location information into the object yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2faaff7512cd20cbdff5d0e25efe8bfe139f7156" translate="yes" xml:space="preserve">
          <source>Because Perl uses doubles (or long doubles, if configured) internally for all numeric calculation, converting from double into float and thence to double again loses precision, so &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt;) will not in general equal $foo.</source>
          <target state="translated">由于Perl内部使用双精度（或长双精度，如果已配置）进行所有数值计算，因此从double转换为float并因此再次变为double会失去精度，因此 &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt; ）不会通常等于$ foo。</target>
        </trans-unit>
        <trans-unit id="398f8b38f72125ad882bed6f196a0775e260d2ad" translate="yes" xml:space="preserve">
          <source>Because UTF-8 is one of Perl's internal formats, you can often just skip the encoding or decoding step, and manipulate the UTF8 flag directly.</source>
          <target state="translated">因为UTF-8是Perl的内部格式之一,所以你可以直接跳过编码或解码步骤,直接操作UTF8标志。</target>
        </trans-unit>
        <trans-unit id="6847617d71c84ec40d27c1365086ed8c20f1449c" translate="yes" xml:space="preserve">
          <source>Because UTF-EBCDIC is so similar to UTF-8, the differences are mostly hidden from you; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; (and NOT something like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; ) declares the the script is in the platform's &quot;native&quot; 8-bit encoding of Unicode. (Similarly for the &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; layer.)</source>
          <target state="translated">由于UTF-EBCDIC与UTF-8非常相似，因此差异几乎对您不可见。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; （不是像 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; ）声明脚本在统一的平台的&amp;ldquo;原生&amp;rdquo;的8位编码。（类似于 &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; 层。）</target>
        </trans-unit>
        <trans-unit id="f78470b23c3e4057a6f3bfa3fb579763a7c89c67" translate="yes" xml:space="preserve">
          <source>Because UTF-EBCDIC is so similar to UTF-8, the differences are mostly hidden from you; &lt;code&gt;use utf8&lt;/code&gt; (and NOT something like &lt;code&gt;use utfebcdic&lt;/code&gt;) declares the script is in the platform's &quot;native&quot; 8-bit encoding of Unicode. (Similarly for the &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; layer.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237849b1b007b545cf9244e10de8226da0ca3773" translate="yes" xml:space="preserve">
          <source>Because VMS's exit codes are much, much different than the rest of the universe, and perl does horrible mangling to them that gets in my way, it works like this on VMS.</source>
          <target state="translated">因为VMS的退出代码和其他宇宙的退出代码有很大的不同,而且perl对它们进行了可怕的篡改,妨碍了我的工作,所以它在VMS上是这样工作的。</target>
        </trans-unit>
        <trans-unit id="815d9b38e08d4ff6dad9bd30fba64b1ec6e8aeb8" translate="yes" xml:space="preserve">
          <source>Because XS modules require re-linking of the perl binary, you need both the perl binary distribution and the perl source distribution to build an XS extension module. In addition, you will have to have built your perl binary from the source distribution so that all of the components of the perl binary are available for the required link step.</source>
          <target state="translated">因为XS模块需要重新链接perl二进制文件,所以你需要perl二进制文件和perl源代码文件来构建XS扩展模块。此外,你必须从源码发行版中构建你的perl二进制文件,这样perl二进制文件的所有组件都可以用于所需的链接步骤。</target>
        </trans-unit>
        <trans-unit id="b57c6e3153bc9c89950406d1bdb5e4a01632a292" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">因为失败的 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; 匹配不会重置偏移量，所以在这种情况下 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 的返回值也不会改变。参见&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;和&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aac46af0a65c30c1278fb04116da06849260131d" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;../perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">因为失败的 &lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; 匹配不会重置偏移量，所以在这种情况下 &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 的返回值也不会改变。参见&lt;a href=&quot;../perlre&quot;&gt;perlre&lt;/a&gt;和&lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7ae901f4727ecaa2d777b8bd8dde60ff479daae" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;m//gc&lt;/code&gt; match doesn't reset the offset, the return from &lt;a href=&quot;#pos-SCALAR&quot;&gt;&lt;code&gt;pos&lt;/code&gt;&lt;/a&gt; won't change either in this case. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eb2a05168485f04f9e352bc656013c7106c3b67" translate="yes" xml:space="preserve">
          <source>Because a list of potential candidates is returned, the &lt;code&gt;while&lt;/code&gt; loop tries each in turn until it finds one that succeeds both the socket() and connect() calls.</source>
          <target state="translated">因为返回了潜在候选者列表，所以 &lt;code&gt;while&lt;/code&gt; 循环依次尝试每个候选者，直到找到同时调用socket（）和connect（）的候选者。</target>
        </trans-unit>
        <trans-unit id="93bb95979fc3bb902bf7566626913de80d560dcc" translate="yes" xml:space="preserve">
          <source>Because a name correction may be added in future Unicode releases, the name that &lt;code&gt;viacode&lt;/code&gt; returns may change as a result. This is a rare event, but it does happen.</source>
          <target state="translated">由于将来的Unicode版本中可能会添加名称更正，因此 &lt;code&gt;viacode&lt;/code&gt; 返回的名称可能会随之更改。这是罕见的事件，但是确实发生了。</target>
        </trans-unit>
        <trans-unit id="284e0db6a72cf3c4c7c4890513562109eb2a9995" translate="yes" xml:space="preserve">
          <source>Because a period is a metacharacter, it needs to be escaped to match as an ordinary period. Because, for example, &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; are sets of characters, it is incorrect to think of &lt;code&gt;[^\d\w]&lt;/code&gt; as &lt;code&gt;[\D\W]&lt;/code&gt; ; in fact &lt;code&gt;[^\d\w]&lt;/code&gt; is the same as &lt;code&gt;[^\w]&lt;/code&gt;, which is the same as &lt;code&gt;[\W]&lt;/code&gt; . Think DeMorgan's laws.</source>
          <target state="translated">由于句点是元字符，因此需要对其进行转义以使其与普通句点匹配。例如，因为 &lt;code&gt;\d&lt;/code&gt; 和 &lt;code&gt;\w&lt;/code&gt; 是字符集，所以将 &lt;code&gt;[^\d\w]&lt;/code&gt; 视为 &lt;code&gt;[\D\W]&lt;/code&gt; 是不正确的；实际上 &lt;code&gt;[^\d\w]&lt;/code&gt; 与 &lt;code&gt;[^\w]&lt;/code&gt; 相同，也与 &lt;code&gt;[\W]&lt;/code&gt; 相同。想想德摩根的定律。</target>
        </trans-unit>
        <trans-unit id="7b8b1120df9a594afd2813233aa665ec7f417ba1" translate="yes" xml:space="preserve">
          <source>Because a period is a metacharacter, it needs to be escaped to match as an ordinary period. Because, for example, &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; are sets of characters, it is incorrect to think of &lt;code&gt;[^\d\w]&lt;/code&gt; as &lt;code&gt;[\D\W]&lt;/code&gt;; in fact &lt;code&gt;[^\d\w]&lt;/code&gt; is the same as &lt;code&gt;[^\w]&lt;/code&gt;, which is the same as &lt;code&gt;[\W]&lt;/code&gt;. Think DeMorgan's laws.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df556755141c60db4ee1a86c658450735dbe881" translate="yes" xml:space="preserve">
          <source>Because a url like &lt;code&gt;http://myrepo.example.com/&lt;/code&gt; is ambiguous as to type, producers should provide a &lt;code&gt;type&lt;/code&gt; whenever a &lt;code&gt;url&lt;/code&gt; key is given. The &lt;code&gt;type&lt;/code&gt; field should be the name of the most common program used to work with the repository, e.g. &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;svn&lt;/code&gt;, &lt;code&gt;cvs&lt;/code&gt;, &lt;code&gt;darcs&lt;/code&gt;, &lt;code&gt;bzr&lt;/code&gt; or &lt;code&gt;hg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="934c60da6f18a9def8d944b8bcb6ee8755c35fe6" translate="yes" xml:space="preserve">
          <source>Because access() does not invoke stat() (at least not in a way visible to Perl), &lt;b&gt;the stat result cache &quot;_&quot; is not set&lt;/b&gt;. This means that the outcome of the following two tests is different. The first has the stat bits of</source>
          <target state="translated">因为access（）不会调用stat（）（至少不是以Perl可见的方式），&lt;b&gt;所以未设置stat结果缓存&amp;ldquo; _&amp;rdquo;&lt;/b&gt;。这意味着以下两个测试的结果是不同的。第一个具有stat位</target>
        </trans-unit>
        <trans-unit id="390a39256a176624bc85b17cecc4ce28e0fc7e67" translate="yes" xml:space="preserve">
          <source>Because assignment of a reference to a typeglob creates an alias, this can be used to create what is effectively a local function, or at least, a local alias.</source>
          <target state="translated">因为对 typeglob 的引用的赋值会创建一个别名,所以可以用来创建一个有效的本地函数,或者至少是一个本地别名。</target>
        </trans-unit>
        <trans-unit id="0fe40d9c5df21e57c6ec455bae627177153c51cf" translate="yes" xml:space="preserve">
          <source>Because backticks do not affect standard error, use shell file descriptor syntax (assuming the shell supports this) if you care to address this. To capture a command's STDERR and STDOUT together:</source>
          <target state="translated">因为反向标记不影响标准错误,如果你关心这个问题,请使用shell文件描述符语法(假设shell支持这个)。要把一个命令的STDERR和STDOUT一起捕获。</target>
        </trans-unit>
        <trans-unit id="58a3a4b137a2ac3042f5ce6d5ed31ccf52919b18" translate="yes" xml:space="preserve">
          <source>Because both CRLF and LF end in LF, the input record separator can be set to LF and any CR stripped later. Better to write:</source>
          <target state="translated">因为CRLF和LF都以LF结尾,所以可以将输入记录分隔符设置为LF,之后再剥离任何CR。最好写。</target>
        </trans-unit>
        <trans-unit id="a49e08801e09e4ade1a0feed4948dfc00925efc8" translate="yes" xml:space="preserve">
          <source>Because curly brackets (braces) are used for several other things including BLOCKs, you may occasionally have to disambiguate braces at the beginning of a statement by putting a &lt;code&gt;+&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in front so that Perl realizes the opening brace isn't starting a BLOCK. The economy and mnemonic value of using curlies is deemed worth this occasional extra hassle.</source>
          <target state="translated">由于花括号（花括号）还用于其他一些功能，包括BLOCK，因此有时可能需要在语句的开头通过在前面加上 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 来消除花括号的歧义，以使Perl意识到开头的花括号不是在开始BLOCK。 。使用冰壶的经济性和助记符的价值被认为值得这个偶尔的额外麻烦。</target>
        </trans-unit>
        <trans-unit id="06e52ad8990a21a081873c75e0650e648002cb3f" translate="yes" xml:space="preserve">
          <source>Because curly brackets (braces) are used for several other things including BLOCKs, you may occasionally have to disambiguate braces at the beginning of a statement by putting a &lt;code&gt;+&lt;/code&gt; or a &lt;code&gt;return&lt;/code&gt; in front so that Perl realizes the opening brace isn't starting a BLOCK. The economy and mnemonic value of using curlies is deemed worth this occasional extra hassle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b830bba46d3c56bd91aa88ed2e25a2ca316287" translate="yes" xml:space="preserve">
          <source>Because depending on a directory to just ensure it exists doesn't work too well (the modified time changes too often) dir_target() creates a .exists file in the created directory. It is this you should depend on. For portability purposes you should use the $(DIRFILESEP) macro rather than a '/' to separate the directory from the file.</source>
          <target state="translated">因为依赖一个目录来确保它的存在并不是太好用(修改时间变化太频繁),dir_target()在创建的目录中创建一个.exces文件。你应该依赖这个文件。为了便于移植,你应该使用$(DIRFILESEP)宏而不是'/'来分隔目录和文件。</target>
        </trans-unit>
        <trans-unit id="e43a24b825ab27b01432c41cd607e2f4d3328c51" translate="yes" xml:space="preserve">
          <source>Because each operand is evaluated in integer form, &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will return two elements in list context.</source>
          <target state="translated">因为每个操作数都以整数形式求值，所以 &lt;code&gt;2.18 .. 3.14&lt;/code&gt; 将在列表上下文中返回两个元素。</target>
        </trans-unit>
        <trans-unit id="d594331311925ecf9da3e16eb2cdc66b10c06327" translate="yes" xml:space="preserve">
          <source>Because even on non-Unix ports, Perl's glob function follows standard Unix globbing semantics. You'll need &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; to get all (non-hidden) files. This makes glob() portable even to legacy systems. Your port may include proprietary globbing functions as well. Check its documentation for details.</source>
          <target state="translated">因为即使在非Unix端口上，Perl的glob函数也遵循标准的Unix globlob语义。您需要 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; 来获取所有（非隐藏）文件。这使得glob（）甚至可以移植到旧系统。您的端口可能还包括专有的globing函数。查看其文档以了解详细信息。</target>
        </trans-unit>
        <trans-unit id="4527823ffed4457ee7db37d2aeb7752e646692c1" translate="yes" xml:space="preserve">
          <source>Because even on non-Unix ports, Perl's glob function follows standard Unix globbing semantics. You'll need &lt;code&gt;glob(&quot;*&quot;)&lt;/code&gt; to get all (non-hidden) files. This makes glob() portable even to legacy systems. Your port may include proprietary globbing functions as well. Check its documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a019fec3551e537f7d797537de86770f8cb583e9" translate="yes" xml:space="preserve">
          <source>Because historically some operating systems silently chopped off kernel interpretation of the &lt;code&gt;#!&lt;/code&gt; line after 32 characters, some switches may be passed in on the command line, and some may not; you could even get a &quot;-&quot; without its letter, if you're not careful. You probably want to make sure that all your switches fall either before or after that 32-character boundary. Most switches don't actually care if they're processed redundantly, but getting a &quot;-&quot; instead of a complete switch could cause Perl to try to execute standard input instead of your program. And a partial &lt;a href=&quot;#-Idirectory&quot;&gt;-I&lt;/a&gt; switch could also cause odd results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2981f551145cc9ed169b464d8c0a095e7cf58a72" translate="yes" xml:space="preserve">
          <source>Because historically some operating systems silently chopped off kernel interpretation of the &lt;code&gt;#!&lt;/code&gt; line after 32 characters, some switches may be passed in on the command line, and some may not; you could even get a &quot;-&quot; without its letter, if you're not careful. You probably want to make sure that all your switches fall either before or after that 32-character boundary. Most switches don't actually care if they're processed redundantly, but getting a &quot;-&quot; instead of a complete switch could cause Perl to try to execute standard input instead of your program. And a partial &lt;b&gt;-I&lt;/b&gt; switch could also cause odd results.</source>
          <target state="translated">因为历史上有些操作系统默默地砍掉了 &lt;code&gt;#!&lt;/code&gt; 内核解释！在32个字符后的行中，某些开关可能会在命令行中传递，而有些则不会。如果您不小心的话，甚至可以得到一个不带字母的&amp;ldquo;-&amp;rdquo;。您可能要确保所有开关都落在该32个字符的边界之前或之后。大多数开关实际上并不关心是否进行了冗余处理，但是获得&amp;ldquo;-&amp;rdquo;而不是完整的开关可能会导致Perl尝试执行标准输入而不是程序。而部分&lt;b&gt;-I&lt;/b&gt;开关也可能导致奇怪的结果。</target>
        </trans-unit>
        <trans-unit id="0e93d867e0e61a9f65c5551095616b09fa36af42" translate="yes" xml:space="preserve">
          <source>Because if _1 is one, you get &quot;1 document &lt;b&gt;were&lt;/b&gt; matched&quot;. An acceptable hack here is to do something like this:</source>
          <target state="translated">因为如果_1为1，则会得到&amp;ldquo; 1个文档&lt;b&gt;已&lt;/b&gt;匹配&amp;rdquo;。可以接受的修改方法如下：</target>
        </trans-unit>
        <trans-unit id="14e83724617636cdff52bc89c9135eb24a32b2c3" translate="yes" xml:space="preserve">
          <source>Because it is not possible to reliably tell UTF-8 from native 8 bit encodings, you need either a Byte Order Mark at the beginning of your source code, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; , to instruct perl.</source>
          <target state="translated">由于无法可靠地从本地8位编码中分辨出UTF-8，因此您需要在源代码的开头使用字节顺序标记，或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; ，以指导perl。</target>
        </trans-unit>
        <trans-unit id="ad4161b2b0cababc93ea492bc495fcb997c97d88" translate="yes" xml:space="preserve">
          <source>Because it is not possible to reliably tell UTF-8 from native 8 bit encodings, you need either a Byte Order Mark at the beginning of your source code, or &lt;code&gt;use utf8;&lt;/code&gt;, to instruct perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2126d70bfd6541291d6dfdce3ec02ad289bb688a" translate="yes" xml:space="preserve">
          <source>Because it's a module, not an integral part of the interpreter, &lt;code&gt;NEXT&lt;/code&gt; has to guess where the surrounding call was found in the method look-up sequence. In the presence of diamond inheritance patterns it occasionally guesses wrong.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c9a76f6de0976ec0aec1cbf80b933b451074248" translate="yes" xml:space="preserve">
          <source>Because it's a module, not an integral part of the interpreter, NEXT.pm has to guess where the surrounding call was found in the method look-up sequence. In the presence of diamond inheritance patterns it occasionally guesses wrong.</source>
          <target state="translated">因为它是一个模块,而不是解释器的一个组成部分,NEXT.pm必须猜测周围的调用在方法查找序列中的位置。在存在钻石继承模式的情况下,它偶尔会猜错。</target>
        </trans-unit>
        <trans-unit id="24e659fa848838e6ef33ca050446877416a84202" translate="yes" xml:space="preserve">
          <source>Because literal conversions also work on empty strings, it may surprise some people:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b07afd521e75a07298e5e250bb27a3b27578dea" translate="yes" xml:space="preserve">
          <source>Because loading in the &lt;code&gt;IO::Handle&lt;/code&gt; class is an expensive operation, you should learn how to use the regular built-in variables.</source>
          <target state="translated">因为在 &lt;code&gt;IO::Handle&lt;/code&gt; 类中加载是一项昂贵的操作，所以您应该学习如何使用常规的内置变量。</target>
        </trans-unit>
        <trans-unit id="fb1b328dbd0a94624aa3c89dafc392fc30581afd" translate="yes" xml:space="preserve">
          <source>Because many operating systems permit anyone with read access to the Perl program file to make a copy of it, patch the copy, and then execute the copy, the security-conscious Perl programmer should take care to invoke the installed copy of perl, not the copy referenced by &lt;code&gt;$^X&lt;/code&gt; . The following statements accomplish this goal, and produce a pathname that can be invoked as a command or referenced as a file.</source>
          <target state="translated">由于许多操作系统允许对Perl程序文件具有读取访问权限的任何人制作该文件的副本，修补该副本，然后执行该副本，因此，具有安全意识的Perl程序员应注意调用已安装的Perl副本，而不是调用Perl副本。 &lt;code&gt;$^X&lt;/code&gt; 引用的副本。以下语句可实现此目标，并产生可作为命令调用或作为文件引用的路径名。</target>
        </trans-unit>
        <trans-unit id="dd84b64cdc62e50ad281c65222f1464d48cdcca2" translate="yes" xml:space="preserve">
          <source>Because many operating systems permit anyone with read access to the Perl program file to make a copy of it, patch the copy, and then execute the copy, the security-conscious Perl programmer should take care to invoke the installed copy of perl, not the copy referenced by &lt;code&gt;$^X&lt;/code&gt;. The following statements accomplish this goal, and produce a pathname that can be invoked as a command or referenced as a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fda5ef27e15d5bae07e31ec0802921ed805374c" translate="yes" xml:space="preserve">
          <source>Because native operating system filehandles are global and are currently allocated down from 255, with 0 being a reserved value, the Unix emulation library emulates Unix filehandles. Consequently, you can't rely on passing &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , or &lt;code&gt;STDERR&lt;/code&gt; to your children.</source>
          <target state="translated">因为本机操作系统文件句柄是全局的，并且当前是从255向下分配的，而0是保留值，所以Unix仿真库将模拟Unix文件句柄。因此，您不能依赖于将 &lt;code&gt;STDIN&lt;/code&gt; ， &lt;code&gt;STDOUT&lt;/code&gt; 或 &lt;code&gt;STDERR&lt;/code&gt; 传递给孩子。</target>
        </trans-unit>
        <trans-unit id="775710224a556c9491575c5fd5adccb463f6fd25" translate="yes" xml:space="preserve">
          <source>Because native operating system filehandles are global and are currently allocated down from 255, with 0 being a reserved value, the Unix emulation library emulates Unix filehandles. Consequently, you can't rely on passing &lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt;, or &lt;code&gt;STDERR&lt;/code&gt; to your children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5e62ec9329120e24ef0d8c20f22f5389de7c7e2" translate="yes" xml:space="preserve">
          <source>Because objects in Perl are implemented as references, it's possible to have circular references with objects as well. Imagine a TreeNode class where each node references its parent and child nodes. Any node with a parent will be part of a circular reference.</source>
          <target state="translated">因为Perl中的对象是以引用的形式实现的,所以也可以用对象进行循环引用。想象一个TreeNode类,每个节点都会引用它的父节点和子节点。任何有父节点的节点都将是循环引用的一部分。</target>
        </trans-unit>
        <trans-unit id="0bd5958f518c949c2219a905e834fb00df87ae4a" translate="yes" xml:space="preserve">
          <source>Because of DST changes, there are many time zones where the same local time occurs for two different GMT times on the same day. For example, in the &quot;Europe/Paris&quot; time zone, the local time of 2001-10-28 02:30:00 can represent either 2001-10-28 00:30:00 GMT, &lt;b&gt;or&lt;/b&gt; 2001-10-28 01:30:00 GMT.</source>
          <target state="translated">由于DST的更改，在许多时间段中，同一天的同一本地时间发生在同一天的两个不同的GMT时间。例如，在&amp;ldquo;欧洲/巴黎&amp;rdquo;时区中，2001-10-28 02:30:00的本地时间可以表示格林尼治标准时间2001-10-28 00:30:00 &lt;b&gt;或&lt;/b&gt; 2001-10-28 01：格林尼治标准时间30:00。</target>
        </trans-unit>
        <trans-unit id="65864a7a85dc93ea309cdec582c118e5dd979f14" translate="yes" xml:space="preserve">
          <source>Because of a bug in perl (#19213), at least in version 5.6.1, we have to hardcode the path separator for a require on Win32 to be &lt;code&gt;/&lt;/code&gt;, like on Unix rather than the Win32 &lt;code&gt;\&lt;/code&gt; . Otherwise perl will not read its own %INC accurately double load files if they are required again, or in the worst case, core dump.</source>
          <target state="translated">由于perl（＃19213）中的错误，至少在5.6.1版中，我们必须对路径分隔符进行硬编码，以使Win32上的require为 &lt;code&gt;/&lt;/code&gt; ，例如在Unix而不是Win32 &lt;code&gt;\&lt;/code&gt; 上。否则，如果再次需要，或者在最坏的情况下是核心转储，则perl将无法读取其自己的％INC准确地将其加倍加载文件。</target>
        </trans-unit>
        <trans-unit id="bddbdae97f197ffe17554a082cd1e7f07c2861e6" translate="yes" xml:space="preserve">
          <source>Because of a bug in perl (#19213), at least in version 5.6.1, we have to hardcode the path separator for a require on Win32 to be &lt;code&gt;/&lt;/code&gt;, like on Unix rather than the Win32 &lt;code&gt;\&lt;/code&gt;. Otherwise perl will not read its own %INC accurately double load files if they are required again, or in the worst case, core dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f334a2266086aa81e3afdad8578b63a9a352bf3" translate="yes" xml:space="preserve">
          <source>Because of a lack of anything better, this module uses its own routines to pack and unpack ICMP packets. It would be better for a separate module to be written which understands all of the different kinds of ICMP packets.</source>
          <target state="translated">由于缺乏更好的东西,这个模块使用自己的例程来打包和解压ICMP数据包。最好是编写一个单独的模块,了解所有不同种类的ICMP数据包。</target>
        </trans-unit>
        <trans-unit id="c6dcc7b169aa07008925e53db149a044f2ea93db" translate="yes" xml:space="preserve">
          <source>Because of all the alias issues, and because in the general case encodings have state, &quot;Encode&quot; uses an encoding object internally once an operation is in progress.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50ff3946dd738899f690c4bd5e562356a6223d1" translate="yes" xml:space="preserve">
          <source>Because of all these problems, starting in v5.22, Perl will raise a warning if a multi-byte (hence Unicode) code point is used when a single-byte locale is in effect. (Although it doesn't check for this if doing so would unreasonably slow execution down.)</source>
          <target state="translated">由于这些问题,从 v5.22 开始,如果在单字节的语言环境中使用多字节(因此是 Unicode)代码点,Perl 会发出警告。(尽管如果这样做会不合理地减慢执行速度,它不会检查这个问题。)</target>
        </trans-unit>
        <trans-unit id="7eca024239d85bdb38cb09ea249ea5b41add05bc" translate="yes" xml:space="preserve">
          <source>Because of backward compatibility with legacy encodings, the &quot;a unique number for every character&quot; idea breaks down a bit: instead, there is &quot;at least one number for every character&quot;. The same character could be represented differently in several legacy encodings. The converse is not true: some code points do not have an assigned character. Firstly, there are unallocated code points within otherwise used blocks. Secondly, there are special Unicode control characters that do not represent true characters.</source>
          <target state="translated">由于与传统编码的向后兼容性,&quot;每个字符都有一个唯一的数字 &quot;的想法有点崩溃:相反,&quot;每个字符至少有一个数字&quot;。同一个字符在几种遗留编码中可以有不同的表示。反之则不然:有些码点没有分配的字符。首先,在本来使用的块内有未分配的码点。其次,有一些特殊的Unicode控制字符不代表真正的字符。</target>
        </trans-unit>
        <trans-unit id="6c5cc2c32fa019382bf3152d3598a8ccd6be4473" translate="yes" xml:space="preserve">
          <source>Because of being able to omit the curlies for the simple case of &lt;code&gt;$$x&lt;/code&gt; , people often make the mistake of viewing the dereferencing symbols as proper operators, and wonder about their precedence. If they were, though, you could use parentheses instead of braces. That's not the case. Consider the difference below; case 0 is a short-hand version of case 1,</source>
          <target state="translated">因为在 &lt;code&gt;$$x&lt;/code&gt; 的简单情况下可以省略掉curly，所以人们经常会犯错误，即将反引用符号视为适当的运算符，并对其优先级感到疑惑。如果是这样，则可以使用括号代替大括号。事实并非如此。考虑下面的区别；案例0是案例1的简写版本</target>
        </trans-unit>
        <trans-unit id="e8951f412eada97de516eafdeec177d3c0f76b4b" translate="yes" xml:space="preserve">
          <source>Because of being able to omit the curlies for the simple case of &lt;code&gt;$$x&lt;/code&gt;, people often make the mistake of viewing the dereferencing symbols as proper operators, and wonder about their precedence. If they were, though, you could use parentheses instead of braces. That's not the case. Consider the difference below; case 0 is a short-hand version of case 1,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e900a4e123821bf1949cbdd4fb9b5da407117914" translate="yes" xml:space="preserve">
          <source>Because of clock granularity, expiration times may occur up to one second sooner than you expect. For example, suppose you store a value with a lifetime of ten seconds, and you store it at 12:00:00.998 on a certain day. Memoize will look at the clock and see 12:00:00. Then 9.01 seconds later, at 12:00:10.008 you try to read it back. Memoize will look at the clock and see 12:00:10 and conclude that the value has expired. This will probably not occur if you have &lt;code&gt;Time::HiRes&lt;/code&gt; installed.</source>
          <target state="translated">由于时钟的粒度，到期时间可能比您预期的要早一秒。例如，假设您存储一个生命周期为十秒的值，并将其存储在特定日期的12：00：00.998。备忘录将查看时钟并看到12:00:00。然后9.01秒后，在12：00：10.008，您尝试将其读回。 Memoize将查看时钟并看到12:00:10，并得出该值已过期的结论。如果您安装了 &lt;code&gt;Time::HiRes&lt;/code&gt; 则可能不会发生。</target>
        </trans-unit>
        <trans-unit id="c6e7a0449744f95f7025dc0e8c4838b8d0860c99" translate="yes" xml:space="preserve">
          <source>Because of idiosyncrasies of OS/2 one cannot have all the eggs in the same basket (though EMX environment tries hard to overcome this limitations, so the situation may somehow improve). There are 4 executables for Perl provided by the distribution:</source>
          <target state="translated">由于OS/2的特殊性,我们不可能把所有的鸡蛋放在同一个篮子里(尽管EMX环境努力克服这种限制,所以这种情况可能会有所改善)。发行版中提供了4个Perl的可执行文件。</target>
        </trans-unit>
        <trans-unit id="38b54108e9558724b240349ad9589f54bf027fa2" translate="yes" xml:space="preserve">
          <source>Because of its global effect, this setting should not be used inside modules or the like.</source>
          <target state="translated">由于它的全局效果,这个设置不应该在模块等内部使用。</target>
        </trans-unit>
        <trans-unit id="cc4be6e39aa524fd29878685a03b1168c2bf5d9f" translate="yes" xml:space="preserve">
          <source>Because of our problems with the native yacc we used GNU bison to generate a pure (=reentrant) parser for perly.y. So our yacc is really the following script:</source>
          <target state="translated">由于我们的原生 yacc 存在问题,我们使用 GNU bison 为 perly.y 生成了一个纯粹的 (=reentrant)解析器,所以我们的 yacc 其实就是下面的脚本。</target>
        </trans-unit>
        <trans-unit id="57e65a7490f61f523f42c4deffd151e416a21006" translate="yes" xml:space="preserve">
          <source>Because of the &quot;text&quot; mode translation, DOSish perls have limitations in using &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; on a file accessed in &quot;text&quot; mode. Stick to &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;-ing to locations you got from &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; (and no others), and you are usually free to use &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; even in &quot;text&quot; mode. Using &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; or other file operations may be non-portable. If you use &lt;a href=&quot;perlfunc#binmode-FILEHANDLE&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; on a file, however, you can usually &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; with arbitrary values safely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9835e5c9cd0a637bdd223f60f76a72232d5d4783" translate="yes" xml:space="preserve">
          <source>Because of the &quot;text&quot; mode translation, DOSish perls have limitations in using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; on a file accessed in &quot;text&quot; mode. Stick to &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;-ing to locations you got from &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; (and no others), and you are usually free to use &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; even in &quot;text&quot; mode. Using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; or other file operations may be non-portable. If you use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; on a file, however, you can usually &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; with arbitrary values safely.</source>
          <target state="translated">由于采用了&amp;ldquo;文本&amp;rdquo;模式转换，DOSish perls在使用以&amp;ldquo;文本&amp;rdquo;模式访问的文件上 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 时存在局限性。坚持 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; （而没有其他人）得到的位置，通常即使在&amp;ldquo;文本&amp;rdquo;模式下，您也可以自由使用 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 或其他文件操作可能是不可移植的。但是，如果在文件上使用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; ，通常可以安全地 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 任意值。</target>
        </trans-unit>
        <trans-unit id="86b041b8cdbf2e2a44b563d3f9086435ec867343" translate="yes" xml:space="preserve">
          <source>Because of the 16-bitness, UTF-16 is byte-order dependent. UTF-16 itself can be used for in-memory computations, but if storage or transfer is required either UTF-16BE (big-endian) or UTF-16LE (little-endian) encodings must be chosen.</source>
          <target state="translated">由于UTF-16是16位的,所以UTF-16是依赖于字节顺序的,它本身可以用于内存计算,但如果需要存储或传输,则必须选择UTF-16BE(big-endian)或UTF-16LE(little-endian)编码。UTF-16本身可以用于内存计算,但如果需要存储或传输,则必须选择UTF-16BE(big-endian)或UTF-16LE(little-endian)编码。</target>
        </trans-unit>
        <trans-unit id="ddcee3f7b2710d631ab7d25c7c6ccf7f643a3fe9" translate="yes" xml:space="preserve">
          <source>Because of the algorithm used, ISO-8859 series and other single-byte encodings do not work well unless either one of ISO-8859 is the only one suspect (besides ascii and utf8).</source>
          <target state="translated">由于使用的算法,ISO-8859系列和其他单字节编码都不好用,除非ISO-8859中的任何一个都有嫌疑(除了ascii和utf8)。</target>
        </trans-unit>
        <trans-unit id="5cf1c92c7c06c92a6e6b33e7b9bd233615db8e45" translate="yes" xml:space="preserve">
          <source>Because of the nature of the Perl parsing and tokenizing routines, certain initialization values &lt;b&gt;must&lt;/b&gt; be quoted in order to correctly parse as the intended version, especially when using the &lt;code&gt;declare&lt;/code&gt; or &lt;a href=&quot;#qv%28%29&quot;&gt;&quot;qv()&quot;&lt;/a&gt; methods. While you do not have to quote decimal numbers when creating version objects, it is always safe to quote &lt;b&gt;all&lt;/b&gt; initial values when using version.pm methods, as this will ensure that what you type is what is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e124c1c916c9b7a769264558af430e4f129d0a7" translate="yes" xml:space="preserve">
          <source>Because of the nature of the features it enables, forward compatibility can not be guaranteed in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89787285641f86ade5feb7e0702432198446d5b1" translate="yes" xml:space="preserve">
          <source>Because of the overhead associated with obtaining the list of defined symbols for the tied hash iterator, it is only done once, and the list is reused for subsequent iterations. Changes to symbols made through this package are recorded, but in the rare event that someone changes the process' symbol table from outside (as is possible using some software from the net), the iterator will be out of sync with the symbol table. If you expect this to happen, you can reset the cache by calling this method. In addition, if you pass a FALSE value as the first argument, caching will be disabled. It can be re-enabled later by calling &lt;code&gt;clearcache&lt;/code&gt; again with a TRUE value as the first argument. It returns TRUE or FALSE to indicate whether caching was previously enabled or disabled, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46fd1b6b9fa8982a77e6c457f5e31e6dd1a8e6bb" translate="yes" xml:space="preserve">
          <source>Because of the unexpected behaviors associated with this modifier, you probably should only explicitly use it to maintain weird backward compatibilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b9a9053f80eaf386518a04692ab13e4782146b" translate="yes" xml:space="preserve">
          <source>Because of the unexpected behaviors associated with this modifier, you probably should only use it to maintain weird backward compatibilities.</source>
          <target state="translated">由于与这个修改器相关的意外行为,你可能只应该用它来保持奇怪的后向兼容性。</target>
        </trans-unit>
        <trans-unit id="033d419ed47a31e5b1999d8b2e6265eaff662dc3" translate="yes" xml:space="preserve">
          <source>Because of their special use by sort(), the variables $a and $b are exempted from this check.</source>
          <target state="translated">由于变量$a和$b在sort()中的特殊用途,它们被免除了这个检查。</target>
        </trans-unit>
        <trans-unit id="79393165c5e367768108e6eb51a718f96e4510a4" translate="yes" xml:space="preserve">
          <source>Because of this fallback feature of JSON.pm, JSON::PP tries not to be more JavaScript-friendly than JSON::XS (i.e. not to escape extra characters such as U+2028 and U+2029, etc), in order for you not to lose such JavaScript-friendliness silently when you use JSON.pm and install JSON::XS for speed or by accident. If you need JavaScript-friendly RFC7159-compliant pure perl module, try &lt;a href=&quot;JSON::Tiny&quot;&gt;JSON::Tiny&lt;/a&gt;, which is derived from &lt;a href=&quot;mojolicious&quot;&gt;Mojolicious&lt;/a&gt; web framework and is also smaller and faster than JSON::PP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c8809b3046a08b3452bb5931521fe0616806ce" translate="yes" xml:space="preserve">
          <source>Because of this mechanism it is important that &lt;b&gt;AutoLoader&lt;/b&gt; is always &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;d and not &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d.</source>
          <target state="translated">由于这种机制是很重要的&lt;b&gt;自动装载&lt;/b&gt;总是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; d，而不是 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; d。</target>
        </trans-unit>
        <trans-unit id="915eb569e5cd5ca772dbf6184e1e9e7f7c40e009" translate="yes" xml:space="preserve">
          <source>Because of this mechanism it is important that &lt;b&gt;AutoLoader&lt;/b&gt; is always &lt;code&gt;use&lt;/code&gt;d and not &lt;code&gt;require&lt;/code&gt;d.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9b61922d31b09cb33aab7bed1a50c499c2933e" translate="yes" xml:space="preserve">
          <source>Because of those two, the code paging approach used use in ucm-based Encoding SOMETIMES fails so this module was written.</source>
          <target state="translated">因为这两点,在基于ucm的Encoding中使用的代码分页方法SOMETIMES失败,所以写了这个模块。</target>
        </trans-unit>
        <trans-unit id="4732978c8da8f3cf527ff9f22b157a0776b9721a" translate="yes" xml:space="preserve">
          <source>Because patterns are processed as double-quoted strings, the following also work:</source>
          <target state="translated">因为模式是作为双引号字符串处理的,所以下面也可以使用。</target>
        </trans-unit>
        <trans-unit id="e94cf9546dd5c84d3c599b01ef4e83754d69c340" translate="yes" xml:space="preserve">
          <source>Because perl needs to parse the script before applying this pragma, such encodings as Shift_JIS and Big-5 that may contain &lt;code&gt;'\'&lt;/code&gt; (BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt; ) in the second byte fail because the second byte may accidentally escape the quoting character that follows.</source>
          <target state="translated">因为perl在应用此编译指示之前需要分析脚本，所以Shift_JIS和Big-5之类的编码在第二个字节中可能包含 &lt;code&gt;'\'&lt;/code&gt; （BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt; ）失败，因为第二个字节可能不小心转义了后面的引号字符。</target>
        </trans-unit>
        <trans-unit id="e3192cbde985ba3a61564abae80a07c49199034c" translate="yes" xml:space="preserve">
          <source>Because perl needs to parse the script before applying this pragma, such encodings as Shift_JIS and Big-5 that may contain &lt;code&gt;'\'&lt;/code&gt; (BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt;) in the second byte fail because the second byte may accidentally escape the quoting character that follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d20d737f3e8559e674f183083581c5bd074a26" translate="yes" xml:space="preserve">
          <source>Because pointer size does not necessarily equal integer size, use the follow macros to do it right.</source>
          <target state="translated">因为指针大小不一定等于整数大小,所以要用下面的宏来做好。</target>
        </trans-unit>
        <trans-unit id="1ab7d92c18b253929d90277eb1a2787d5ea83ae7" translate="yes" xml:space="preserve">
          <source>Because scripts differ in their directionality (Hebrew and Arabic are written right to left, for example) Unicode supplies a &lt;code&gt;Bidi_Class&lt;/code&gt; property. Some of the values this property can have are:</source>
          <target state="translated">因为脚本的方向性不同（例如，希伯来语和阿拉伯语是从右到左书写的），所以Unicode提供了 &lt;code&gt;Bidi_Class&lt;/code&gt; 属性。该属性可以具有的一些值是：</target>
        </trans-unit>
        <trans-unit id="5783acfed14f8a18cb2ce82232df112d8f4b39d0" translate="yes" xml:space="preserve">
          <source>Because taintedness is associated with each scalar value, some elements of an array or hash can be tainted and others not. The keys of a hash are &lt;b&gt;never&lt;/b&gt; tainted.</source>
          <target state="translated">因为污损与每个标量值相关联，所以可以污染数组或哈希的某些元素，而其他则不可以。哈希键&lt;b&gt;永远不会&lt;/b&gt;被污染。</target>
        </trans-unit>
        <trans-unit id="43efff829e58f5a1345657268ce9125ae02a8e64" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;ed value will have the separator reattached when it is written back to the file. There is no way to create a file whose trailing record separator string is missing.</source>
          <target state="translated">因为 &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; ed值写回文件时将重新附加分隔符。无法创建缺少尾随记录分隔符字符串的文件。</target>
        </trans-unit>
        <trans-unit id="1a39cf872a3f7b6aa066ba9c7802115aead55d6e" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; at end of file or upon error, you will sometimes see it used this way:</source>
          <target state="translated">由于 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 函数会在文件末尾或出现错误时返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，因此有时您会看到它以这种方式使用：</target>
        </trans-unit>
        <trans-unit id="2d7cdbb67a74f8d2c9c047551149590e9752d672" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement implies a &lt;code&gt;BEGIN&lt;/code&gt; block, the importing of semantics happens as soon as the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement is compiled, before the rest of the file is compiled. This is how it is able to function as a pragma mechanism, and also how modules are able to declare subroutines that are then visible as list or unary operators for the rest of the current file. This will not work if you use &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;. With &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; you can get into this problem:</source>
          <target state="translated">由于 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句暗含一个 &lt;code&gt;BEGIN&lt;/code&gt; 块，因此语义的导入是在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句编译后即文件的其余部分编译之前进行的。这就是它如何充当杂注机制的方式，以及模块如何能够声明子例程，这些子例程随后对于列表的剩余部分或一元运算符可见。如果使用 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ,则此方法将不起作用。使用 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 可以解决这个问题：</target>
        </trans-unit>
        <trans-unit id="3c3e36ebc253e6320dfa90cfe5b728b065ce3f37" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;chomp&lt;/code&gt;ed value will have the separator reattached when it is written back to the file. There is no way to create a file whose trailing record separator string is missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2ba8c1f36d75fd963bdb6706751e36d03bae43" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;here&lt;/code&gt; is before the &lt;code&gt;.*&lt;/code&gt; in the pattern, its position can be determined exactly. That's not true, however, for the &lt;code&gt;there&lt;/code&gt; ; it could appear at any point after where the anchored string appeared. Perl uses both for its optimisations, preferring the longer, or, if they are equal, the floating.</source>
          <target state="translated">由于 &lt;code&gt;here&lt;/code&gt; 位置在模式中的 &lt;code&gt;.*&lt;/code&gt; 之前，因此可以精确确定其位置。这是不正确的，但是，对于 &lt;code&gt;there&lt;/code&gt; ; 它可能出现在锚定字符串出现后的任何位置。Perl出于优化目的同时使用这两种方法，它们倾向于使用更长的时间，或者，如果相等，则选择浮动。</target>
        </trans-unit>
        <trans-unit id="fef986661cf1ec507db2ffa4c44fc0d6ca39bba4" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;here&lt;/code&gt; is before the &lt;code&gt;.*&lt;/code&gt; in the pattern, its position can be determined exactly. That's not true, however, for the &lt;code&gt;there&lt;/code&gt;; it could appear at any point after where the anchored string appeared. Perl uses both for its optimisations, preferring the longer, or, if they are equal, the floating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2431412f653ac2d48b2590f72b1ae7bed247322" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;mark&lt;/code&gt; variable is converted to a pointer on the value stack, extra care must be taken if &lt;code&gt;EXTEND&lt;/code&gt; or any of the &lt;code&gt;XPUSH&lt;/code&gt; macros are invoked within the function, because the stack may need to be moved to extend it and so the existing pointer will now be invalid. If this may be a problem, a possible solution is to track the mark offset as an integer and track the mark itself later on after the stack had been moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28a1dea2b8dc5fa2f3798b76ce3f11a720999a6b" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;readline&lt;/code&gt; function returns &lt;code&gt;undef&lt;/code&gt; at end of file or upon error, you will sometimes see it used this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206300e9a9cae7d4d33910fad6d81cd5f5d5cc80" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;use&lt;/code&gt; statement implies a &lt;code&gt;BEGIN&lt;/code&gt; block, the importing of semantics happens as soon as the &lt;code&gt;use&lt;/code&gt; statement is compiled, before the rest of the file is compiled. This is how it is able to function as a pragma mechanism, and also how modules are able to declare subroutines that are then visible as list or unary operators for the rest of the current file. This will not work if you use &lt;code&gt;require&lt;/code&gt; instead of &lt;code&gt;use&lt;/code&gt;. With &lt;code&gt;require&lt;/code&gt; you can get into this problem:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb97ff89f00546d3eb19d15e7c154022a6e40c9" translate="yes" xml:space="preserve">
          <source>Because the L&amp;lt;...&amp;gt; is the most complex construct in the language, it should not surprise you that the events it generates are the most complex in the language. Most of complexity is hidden away in the attribute values, so for those of you writing a Pod formatter that produces a non-hypertextual format, you can just ignore the attributes and treat an L event structure like a formatting element that (presumably) doesn't actually produce a change in formatting. That is, the content of the L event structure (as opposed to its attributes) is always what text should be displayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1ecaef6dcc4b2b01535ebf9f55c2fce3a55dd0" translate="yes" xml:space="preserve">
          <source>Because the arithmetic operators all have fixed arity and are postfixed, there is no need for operator precedence, nor for a grouping operator to override precedence. This is half of the point of RPN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f9c95f62f2ca8f51dfcabf085dd8aa40d54fc6" translate="yes" xml:space="preserve">
          <source>Because the assignment copies the values, this also has the effect of turning call-by-reference into call-by-value. Otherwise a function is free to do in-place modifications of &lt;code&gt;@_&lt;/code&gt; and change its caller's values.</source>
          <target state="translated">由于分配复制值，因此还具有将按引用调用转换为按值调用的效果。否则，函数可以随意对 &lt;code&gt;@_&lt;/code&gt; 进行就地修改并更改其调用者的值。</target>
        </trans-unit>
        <trans-unit id="ef6e720933c8cfb7b84641d15fcb0ddf15b2f13b" translate="yes" xml:space="preserve">
          <source>Because the bytes pragma breaks encapsulation (i.e. it exposes the innards of how the perl executable currently happens to store a string), the byte values that result are in an unspecified encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c5cdf7c11299fa442df7b9179d8baed60991f7f" translate="yes" xml:space="preserve">
          <source>Because the conversion happens in place, the data to be converted cannot be a string constant: it must be a scalar variable.</source>
          <target state="translated">因为转换发生在原地,所以要转换的数据不能是字符串常量:必须是标量变量。</target>
        </trans-unit>
        <trans-unit id="9be0ebeeed384a0006842b7e5b00f870be61a55a" translate="yes" xml:space="preserve">
          <source>Because the current implementation uses the table and key sizes for the hashing algorithm, there is no means by which to dynamically change the value of any of the initialization parameters.</source>
          <target state="translated">由于目前的实现使用表和密钥大小来进行散列算法,所以没有办法动态地改变任何初始化参数的值。</target>
        </trans-unit>
        <trans-unit id="a16d069c72d0455b6bbcd09050d9c581b9a31d6b" translate="yes" xml:space="preserve">
          <source>Because the intent of this feature is primarily to let you define subroutines that work like built-in functions, here are prototypes for some other functions that parse almost exactly like the corresponding built-in.</source>
          <target state="translated">因为这个功能的目的主要是让你定义像内置函数一样工作的子程序,这里有一些其他函数的原型,它们的解析几乎和相应的内置函数完全一样。</target>
        </trans-unit>
        <trans-unit id="286b10724045d4807f7e79831cdfb01b70d2bd21" translate="yes" xml:space="preserve">
          <source>Because the internal format is often UTF-8, these bugs are hard to spot, because UTF-8 is usually the encoding you wanted! But don't be lazy, and don't use the fact that Perl's internal format is UTF-8 to your advantage. Encode explicitly to avoid weird bugs, and to show to maintenance programmers that you thought this through.</source>
          <target state="translated">因为内部格式通常是UTF-8,所以这些bug很难被发现,因为UTF-8通常是你想要的编码! 但是不要偷懒,不要利用Perl的内部格式是UTF-8这个事实来为自己谋取利益。明确地进行编码以避免奇怪的错误,并向维护程序员表明你已经考虑到了这一点。</target>
        </trans-unit>
        <trans-unit id="92b5a68a7f930a6d97c59ffe2faa9fff5db40d0e" translate="yes" xml:space="preserve">
          <source>Because the magical increment only works on non-empty strings matching &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt;, the following will only return an alpha:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9f9af112f672f597ba8d8590f5548d9330b12e" translate="yes" xml:space="preserve">
          <source>Because the mode contains both the file type and its permissions, you should mask off the file type portion and (s)printf using a &lt;code&gt;&quot;%o&quot;&lt;/code&gt; if you want to see the real permissions.</source>
          <target state="translated">由于该模式同时包含文件类型及其权限，因此如果要查看实际权限，应使用 &lt;code&gt;&quot;%o&quot;&lt;/code&gt; 屏蔽文件类型部分和（s）printf 。</target>
        </trans-unit>
        <trans-unit id="f2423ea47c406258a59791ed602061d34ce7d19b" translate="yes" xml:space="preserve">
          <source>Because the result of &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; has all metacharacters quoted, there is no way to insert a literal &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; inside a &lt;code&gt;\Q\E&lt;/code&gt; pair. If protected by &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; will be quoted to become &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; ; if not, it is interpreted as the start of an interpolated scalar.</source>
          <target state="translated">由于 &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; 具有所有引号，因此无法在 &lt;code&gt;\Q\E&lt;/code&gt; 对中插入文字 &lt;code&gt;$&lt;/code&gt; 或 &lt;code&gt;@&lt;/code&gt; 。如果受 &lt;code&gt;\&lt;/code&gt; 保护，则 &lt;code&gt;$&lt;/code&gt; 将引用为 &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; ；如果不是，则将其解释为插值标量的开始。</target>
        </trans-unit>
        <trans-unit id="097258c8be4cbb48ed4be0fc9859bc5c3825bc9a" translate="yes" xml:space="preserve">
          <source>Because the result of &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; has all metacharacters quoted, there is no way to insert a literal &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; inside a &lt;code&gt;\Q\E&lt;/code&gt; pair. If protected by &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;$&lt;/code&gt; will be quoted to become &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt;; if not, it is interpreted as the start of an interpolated scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d152f048af7d90769fe2fc306e54559a9ec00ef1" translate="yes" xml:space="preserve">
          <source>Because the smartmatch operator recurses on nested arrays, this will still report that &quot;red&quot; is in the array.</source>
          <target state="translated">因为smartmatch操作符在嵌套数组上递归,这仍然会报告 &quot;红色 &quot;在数组中。</target>
        </trans-unit>
        <trans-unit id="2efc41902e93fe5cc4de4d763dfe32a371a96fe2" translate="yes" xml:space="preserve">
          <source>Because the standard failure message that &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; produces whenever a test fails will be a common occurrence in your test error output, and because it has changed between Test::Builder versions, rather than forcing you to call &lt;code&gt;test_err&lt;/code&gt; with the string all the time like so</source>
          <target state="translated">因为&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;每次测试失败时都会产生标准失败消息，这是您测试错误输出中的常见现象，并且因为它在Test :: Builder版本之间发生了变化，而不是强迫您使用字符串all 来调用 &lt;code&gt;test_err&lt;/code&gt; 。像这样的时间</target>
        </trans-unit>
        <trans-unit id="87490af32e5b48ef0bb10c89847f02a1cf0e7677" translate="yes" xml:space="preserve">
          <source>Because the standard failure message that &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; produces whenever a test fails will be a common occurrence in your test error output, and because it has changed between Test::Builder versions, rather than forcing you to call &lt;code&gt;test_err&lt;/code&gt; with the string all the time like so</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad62b1bf690da795c5cc2f593aa204a22c3e54b" translate="yes" xml:space="preserve">
          <source>Because the target is reused, you must be careful when pushing multiple values on the stack. The following code will not do what you think:</source>
          <target state="translated">因为目标是重用的,所以在堆栈上推送多个值时一定要小心。下面的代码不会像你想象的那样。</target>
        </trans-unit>
        <trans-unit id="bdc28270d2ca87731131681df34d184cd0aea361" translate="yes" xml:space="preserve">
          <source>Because the transliteration table is built at compile time, neither the</source>
          <target state="translated">因为翻译表是在编译时建立的,所以在编译时,无论是</target>
        </trans-unit>
        <trans-unit id="c4a2190965562aceb584191519393c161752b237" translate="yes" xml:space="preserve">
          <source>Because the value of &lt;a href=&quot;config#archname&quot;&gt;&lt;code&gt;$Config{archname}&lt;/code&gt;&lt;/a&gt; may depend on the hardware architecture, it can vary more than the value of &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5bc19b54b9930fd5e2dcb3e6dfb795d20462ff" translate="yes" xml:space="preserve">
          <source>Because the value of &lt;code&gt;$Config{archname}&lt;/code&gt; may depend on the hardware architecture, it can vary more than the value of &lt;code&gt;$^O&lt;/code&gt; .</source>
          <target state="translated">因为 &lt;code&gt;$Config{archname}&lt;/code&gt; 的值可能取决于硬件体系结构，所以它的变化可能大于 &lt;code&gt;$^O&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="e90ed527002ad403540a55eb78d4c5ab847fcd41" translate="yes" xml:space="preserve">
          <source>Because the values line may contain arbitrary expressions (for at fields, not caret fields), you can farm out more sophisticated processing to other functions, like sprintf() or one of your own. For example:</source>
          <target state="translated">因为values行可能包含任意表达式(对于at字段,而不是caret字段),你可以把更复杂的处理工作交给其他函数,比如sprintf()或你自己的函数。例如,你可以将更复杂的处理工作交给其他函数,比如sprintf()或你自己的函数。</target>
        </trans-unit>
        <trans-unit id="d8bc8ec23c88de9efd45beeefb8be0639f500936" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">因为在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; 情况下变量立即合法，所以只要范围内没有该名称的变量，就可以在同一条语句中再次引用包变量。</target>
        </trans-unit>
        <trans-unit id="da44b03f12b50aea312686ca3a3d0b93a5cee3d2" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">因为在 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; 情况下变量立即合法，所以只要范围内没有该名称的变量，就可以在同一条语句中再次引用包变量。</target>
        </trans-unit>
        <trans-unit id="10adcfecf1a02c362d02294237aa3b65ee35acfd" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;use strict 'vars'&lt;/code&gt;, so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1213676c8b2ebcfdeacd60c8eeb78e070a8906e8" translate="yes" xml:space="preserve">
          <source>Because there are more than three arguments to open(), forks the ps(1) command</source>
          <target state="translated">因为open()有三个以上的参数,所以将ps(1)命令打成叉。</target>
        </trans-unit>
        <trans-unit id="327e12e185eccd28ae382163925adec0406495ff" translate="yes" xml:space="preserve">
          <source>Because there are more than three arguments to open(), it forks the ps(1) command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c371b01d835f1b3e60dfea4284b4178cc48a57" translate="yes" xml:space="preserve">
          <source>Because there are people who have their precise expectations about who may install where in the @INC path and who uses which @INC array. In fine tuned environments &lt;code&gt;UNINST=1&lt;/code&gt; can cause damage.</source>
          <target state="translated">因为有些人对谁可以在@INC路径中的哪个位置以及谁使用哪个@INC数组有确切的期望。在微调的环境中， &lt;code&gt;UNINST=1&lt;/code&gt; 可能会造成损坏。</target>
        </trans-unit>
        <trans-unit id="61339e91fc8e465df58897366d437a1f422fcc97" translate="yes" xml:space="preserve">
          <source>Because there is currently no way for a distribution to specify a dependency on an optional feature of another dependency, the use of &lt;code&gt;optional_feature&lt;/code&gt; is discouraged. Instead, create a separate, installable distribution that ensures the desired feature is available. For example, if &lt;code&gt;Foo::Bar&lt;/code&gt; has a &lt;code&gt;Baz&lt;/code&gt; feature, release a separate &lt;code&gt;Foo-Bar-Baz&lt;/code&gt; distribution that satisfies requirements for the feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b691163394a932e3f6d352ebd6e7cd633110d322" translate="yes" xml:space="preserve">
          <source>Because these resource objects are considered to be owned by the entire process/system, and not the &quot;property&quot; of whatever is being serialized, no references underneath the object should be included in the serialized string. Thus, in any class that implements &lt;code&gt;STORABLE_attach&lt;/code&gt; , the &lt;code&gt;STORABLE_freeze&lt;/code&gt; method cannot return any references, and &lt;code&gt;Storable&lt;/code&gt; will throw an error if &lt;code&gt;STORABLE_freeze&lt;/code&gt; tries to return references.</source>
          <target state="translated">因为这些资源对象被认为是整个进程/系统的所有者，而不是序列化的任何东西的&amp;ldquo;属性&amp;rdquo;，所以序列化的字符串中不应包含对象下面的引用。因此，在任何实现 &lt;code&gt;STORABLE_attach&lt;/code&gt; 的类中， &lt;code&gt;STORABLE_freeze&lt;/code&gt; 方法无法返回任何引用，如果 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 尝试返回引用，则 &lt;code&gt;Storable&lt;/code&gt; 将引发错误。</target>
        </trans-unit>
        <trans-unit id="26af08e2f43bfef9b9e40cba2b2ed696b0549e29" translate="yes" xml:space="preserve">
          <source>Because these resource objects are considered to be owned by the entire process/system, and not the &quot;property&quot; of whatever is being serialized, no references underneath the object should be included in the serialized string. Thus, in any class that implements &lt;code&gt;STORABLE_attach&lt;/code&gt;, the &lt;code&gt;STORABLE_freeze&lt;/code&gt; method cannot return any references, and &lt;code&gt;Storable&lt;/code&gt; will throw an error if &lt;code&gt;STORABLE_freeze&lt;/code&gt; tries to return references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58a7f2a84e13b9fada5ed77ade53adda8ab6513" translate="yes" xml:space="preserve">
          <source>Because this command is in some senses new, a warning is issued if you appear to have accidentally entered a block instead. If that's what you mean to do, write it as with &lt;code&gt;;{ ... }&lt;/code&gt; or even &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; .</source>
          <target state="translated">因为此命令在某种意义上是新命令，所以如果您似乎意外输入了一个块，则会发出警告。如果这就是您要执行的操作，请使用 &lt;code&gt;;{ ... }&lt;/code&gt; 甚至 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; 编写。</target>
        </trans-unit>
        <trans-unit id="74266b6323d7ce62912d6c101e78cdb916449da7" translate="yes" xml:space="preserve">
          <source>Because this command is in some senses new, a warning is issued if you appear to have accidentally entered a block instead. If that's what you mean to do, write it as with &lt;code&gt;;{ ... }&lt;/code&gt; or even &lt;code&gt;do { ... }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afe0d4d00dfd6cabe863bda5f9354b347e13a163" translate="yes" xml:space="preserve">
          <source>Because this construct compiles under &lt;a href=&quot;re#%27strict%27-mode&quot;&gt;&lt;code&gt;use re 'strict&lt;/code&gt;&lt;/a&gt;, unrecognized escapes that generate warnings in normal classes are fatal errors here, as well as all other warnings from these class elements, as well as some practices that don't currently warn outside &lt;code&gt;re 'strict'&lt;/code&gt;. For example you cannot say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e618c1116f848d64cf69ade37db078db462072bd" translate="yes" xml:space="preserve">
          <source>Because this function operates at the byte level, and because of the inherent characteristics of UTF-8 (or UTF-EBCDIC), it will work properly if both the needle and the haystack are strings with the same UTF-8ness, but not if the UTF-8ness differs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa88e36be50b169e959caa4254fea74155063be" translate="yes" xml:space="preserve">
          <source>Because this function uses mktemp(), it can suffer from race conditions.</source>
          <target state="translated">因为这个函数使用了mktemp(),所以它可能会受到竞赛条件的影响。</target>
        </trans-unit>
        <trans-unit id="2478181856508c1cc91e32c539a156e07c17eb63" translate="yes" xml:space="preserve">
          <source>Because this information is not stored within the perl executable itself it is possible (but unlikely) that the information does not relate to the actual perl binary which is being used to access it.</source>
          <target state="translated">因为这些信息并不存储在perl可执行文件本身,所以这些信息有可能(但不太可能)与实际的perl二进制文件无关。</target>
        </trans-unit>
        <trans-unit id="ad52e097251691a48fd57b8bdbc852cffc9bb5f6" translate="yes" xml:space="preserve">
          <source>Because this is a wide-open interface, pragmas (compiler directives) are also implemented this way. Currently implemented pragmas are:</source>
          <target state="translated">因为这是一个开放的接口,所以pragmas(编译器指令)也是这样实现的。目前实现的pragmas有:</target>
        </trans-unit>
        <trans-unit id="872c328b526f9b9864d2cfe0b4165fd06ef13624" translate="yes" xml:space="preserve">
          <source>Because this is a wide-open interface, pragmas (compiler directives) are also implemented this way. Some of the currently implemented pragmas are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8055a645160d58d1aa3758824d7f3046e3cd0a9" translate="yes" xml:space="preserve">
          <source>Because this operator produces an assignable result, using assignments without parentheses will get you in trouble. For example, this:</source>
          <target state="translated">因为这个操作符会产生一个可赋值的结果,所以使用没有括号的赋值会给你带来麻烦。例如,这个。</target>
        </trans-unit>
        <trans-unit id="cda353c8b2d143f02b4da6818d79c64f57fb0765" translate="yes" xml:space="preserve">
          <source>Because this promotes action at a distance, this counterintuitive behavior may be fixed in a future release.</source>
          <target state="translated">因为这样可以促进远距离的行动,这种反直觉的行为可能会在未来的版本中得到修正。</target>
        </trans-unit>
        <trans-unit id="ece57b9cb9008cd6f8ed94726d6205b9428981dc" translate="yes" xml:space="preserve">
          <source>Because thread creation and thread joining may occur in different contexts, it may be desirable to state the context explicitly to the thread's entry point function. This may be done by calling &lt;code&gt;-&amp;gt;create()&lt;/code&gt; with a hash reference as the first argument:</source>
          <target state="translated">因为线程创建和线程连接可能发生在不同的上下文中，所以可能需要将上下文明确声明给线程的入口点函数。这可以通过使用哈希引用作为第一个参数调用 &lt;code&gt;-&amp;gt;create()&lt;/code&gt; 来完成：</target>
        </trans-unit>
        <trans-unit id="a311abdd84d17ec36b9f35316e74bcbefa1ccdb8" translate="yes" xml:space="preserve">
          <source>Because variable references always start with '$', '@', or '%', the &quot;reserved&quot; words aren't in fact reserved with respect to variable names. They</source>
          <target state="translated">因为变量引用总是以'$'、'@'或'%'开头,所以 &quot;保留 &quot;的字样实际上并不是对变量名的保留。它们</target>
        </trans-unit>
        <trans-unit id="cf7852aa0f7da3fa109ef4464da14b644fe19dd6" translate="yes" xml:space="preserve">
          <source>Because various errors may only be detected by close() (e.g. buffering could allow the &lt;code&gt;print&lt;/code&gt; in this example to return true even when the disk is full), it is dangerous to ignore its result. So when it happens implicitly, perl will signal errors by warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ac64477279b51b2f8ca41484de7b49285b3815c" translate="yes" xml:space="preserve">
          <source>Because we are now concerned with the return value from</source>
          <target state="translated">因为我们现在关注的是来自于</target>
        </trans-unit>
        <trans-unit id="9befd612f9b4e3c124f9ec128a96394cb71cf6fb" translate="yes" xml:space="preserve">
          <source>Because we are using an SV to call</source>
          <target state="translated">因为我们是用一个SV来调用</target>
        </trans-unit>
        <trans-unit id="ded04a0cee8ca9e46b88306d00153b5faa51a410" translate="yes" xml:space="preserve">
          <source>Because we created temporary values (by means of sv_2mortal() calls) we will have to tidy up the Perl stack and dispose of mortal SVs.</source>
          <target state="translated">因为我们创建了临时值(通过调用sv_2mortal()),所以我们必须整理Perl堆栈,并处理死亡的SV。</target>
        </trans-unit>
        <trans-unit id="aa34046474e322c81f9b04585e1a1d3d975224ac" translate="yes" xml:space="preserve">
          <source>Because we specified G_DISCARD, it is not necessary to check the value returned from</source>
          <target state="translated">因为我们指定了G_DISCARD,所以不需要检查从G_DISCARD返回的值。</target>
        </trans-unit>
        <trans-unit id="941fe97debd1bfb6b702aacc07a44435ca4e56b7" translate="yes" xml:space="preserve">
          <source>Because when &lt;code&gt;autochomp&lt;/code&gt; is disabled, &lt;code&gt;$a[10]&lt;/code&gt; will read back as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (or whatever the record separator string is.)</source>
          <target state="translated">因为禁用 &lt;code&gt;autochomp&lt;/code&gt; 时， &lt;code&gt;$a[10]&lt;/code&gt; 将读为 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; （或任何记录分隔符字符串）。</target>
        </trans-unit>
        <trans-unit id="b0a17ee4f4c080e1c09fd835e1c924855560fcaf" translate="yes" xml:space="preserve">
          <source>Because you just moved the existing &lt;b&gt;stdout&lt;/b&gt; to somewhere else.</source>
          <target state="translated">因为您只是将现有&lt;b&gt;标准输出&lt;/b&gt;移动到其他地方。</target>
        </trans-unit>
        <trans-unit id="aa628e92b3c4d485e932ec48525c963ebb2f9c63" translate="yes" xml:space="preserve">
          <source>Because you're using something like this, which truncates the file</source>
          <target state="translated">因为你正在使用类似这样的东西,它截断文件</target>
        </trans-unit>
        <trans-unit id="230b0b84c4580dce513ede6c977fdc5dbaffa5e2" translate="yes" xml:space="preserve">
          <source>Before Perl 5.10, setting &lt;code&gt;$*&lt;/code&gt; to a true value globally enabled multi-line matching within a string. This relique from the past lost its special meaning in 5.10. Use of this variable will be a fatal error in Perl 5.30, freeing the variable up for a future special meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973ca6acb768a5dd6330a5eade0b5d4dbc53ee84" translate="yes" xml:space="preserve">
          <source>Before Perl 5.10.0 and 5.8.8, PERL5SHELL was not taint checked when running external commands. It is recommended that you explicitly set (or delete) &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; when running in taint mode under Windows.</source>
          <target state="translated">在Perl 5.10.0和5.8.8之前，运行外部命令时未对PERL5SHELL进行污染检查。在Windows下以异味模式运行时，建议您显式设置（或删除） &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebab29b2af9a7a7c7ceefc18fae2257d84323d02" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the assignment to &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; occurred before restoration of localized variables, which means that for your code to run on older versions, a temporary is required if you want to mask some, but not all errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d386f00504590e35abdcaf1bc115cbe7c02503" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the assignment to &lt;code&gt;$@&lt;/code&gt; occurred before restoration of localized variables, which means that for your code to run on older versions, a temporary is required if you want to mask some but not all errors:</source>
          <target state="translated">在Perl 5.14之前，对 &lt;code&gt;$@&lt;/code&gt; 的赋值发生在恢复本地化变量之前，这意味着要使代码在较旧版本上运行，如果要掩盖部分但不是全部错误，则需要一个临时变量：</target>
        </trans-unit>
        <trans-unit id="512488ae279d498c1ee81f682f1f53229da4c6e2" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the relation between overloading and tie()ing was broken. Overloading was triggered or not based on the</source>
          <target state="translated">在Perl 5.14之前,超载和tie()ing之间的关系被打破了。超载的触发与否是基于</target>
        </trans-unit>
        <trans-unit id="b34cea36bce317a875588bd1ba293a621fd141d4" translate="yes" xml:space="preserve">
          <source>Before Perl 5.18, &lt;code&gt;given(EXPR)&lt;/code&gt; assigned the value of</source>
          <target state="translated">在Perl 5.18之前， &lt;code&gt;given(EXPR)&lt;/code&gt; 分配了</target>
        </trans-unit>
        <trans-unit id="8ed431b288a3361b742578011935581f2edfcced" translate="yes" xml:space="preserve">
          <source>Before Perl 5.28, the returned values are unreliable for the &lt;code&gt;RADIXCHAR&lt;/code&gt; and &lt;code&gt;THOUSEP&lt;/code&gt; locale constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ba6dd90f594f9b5d19255a91f0ae4487b358318" translate="yes" xml:space="preserve">
          <source>Before Perl 5.6, you had to use the &lt;code&gt;*FH&lt;/code&gt; or &lt;code&gt;\*FH&lt;/code&gt; notations. These are &quot;typeglobs&quot;--see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;&quot;Typeglobs and Filehandles&quot; in perldata&lt;/a&gt; and especially &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;&quot;Pass by Reference&quot; in perlsub&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54445efd0dc2c1e8891bd0fe2ff854e28637df1f" translate="yes" xml:space="preserve">
          <source>Before Perl 5.6, you had to use the &lt;code&gt;*FH&lt;/code&gt; or &lt;code&gt;\*FH&lt;/code&gt; notations. These are &quot;typeglobs&quot;--see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs and Filehandles in perldata&lt;/a&gt; and especially &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;Pass by Reference in perlsub&lt;/a&gt; for more information.</source>
          <target state="translated">在Perl 5.6之前，您必须使用 &lt;code&gt;*FH&lt;/code&gt; 或 &lt;code&gt;\*FH&lt;/code&gt; 表示法。这些是&amp;ldquo; typeglobs&amp;rdquo;- 有关更多信息，请参见&lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;perldata中的Typeglobs&lt;/a&gt;和Filehandles，尤其是&lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;perlsub中的&amp;ldquo;按引用传递&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2df4fb0a98f840a2555a3347deeff121cc142591" translate="yes" xml:space="preserve">
          <source>Before Perl 5.8.0, installing Perl code to deal with signals exposed you to danger from two things. First, few system library functions are re-entrant. If the signal interrupts while Perl is executing one function (like malloc(3) or printf(3)), and your signal handler then calls the same function again, you could get unpredictable behavior--often, a core dump. Second, Perl isn't itself re-entrant at the lowest levels. If the signal interrupts Perl while Perl is changing its own internal data structures, similarly unpredictable behavior may result.</source>
          <target state="translated">在Perl 5.8.0之前,安装处理信号的Perl代码会让你面临两方面的危险。首先,很少有系统库函数是重入的。如果信号在 Perl 执行一个函数的时候中断(比如 malloc(3)或 printf(3)),而你的信号处理程序又调用了同一个函数,你可能会得到不可预知的行为--通常是核心转储。其次,Perl本身并不是在最低层重入的。如果在Perl改变自己内部数据结构的时候,信号中断了Perl,那么同样会导致不可预测的行为。</target>
        </trans-unit>
        <trans-unit id="870cc998eebf778ddd06bc7ed2f1805b37f31d55" translate="yes" xml:space="preserve">
          <source>Before Perl v5.8.0, the use of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; was used to declare that operations in the current block or file would be Unicode-aware. This model was found to be wrong, or at least clumsy: the &quot;Unicodeness&quot; is now carried with the data, instead of being attached to the operations. Starting with Perl v5.8.0, only one case remains where an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
utf8&lt;/code&gt; is needed: if your Perl script itself is encoded in UTF-8, you can use UTF-8 in your identifier names, and in string and regular expression literals, by saying &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; . This is not the default because scripts with legacy 8-bit data in them would break. See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="translated">在Perl v5.8.0之前， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 来声明当前块或文件中的操作将支持Unicode。发现该模型是错误的，或至少是笨拙的：&amp;ldquo; Unicodeness&amp;rdquo;现在随数据一起携带，而不是附加到操作中。从Perl v5.8.0开始，只有一种情况需要显式 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; ：如果您的Perl脚本本身是以UTF-8编码的，则可以在标识符名称以及字符串和正则表达式文字中使用UTF-8，通过说 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 。这不是默认设置，因为其中包含旧式8位数据的脚本会中断。参见&lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4fa99c9f82e7be9fceb5a0c188011fae1cb7cad5" translate="yes" xml:space="preserve">
          <source>Before Perl v5.8.0, the use of &lt;code&gt;use utf8&lt;/code&gt; was used to declare that operations in the current block or file would be Unicode-aware. This model was found to be wrong, or at least clumsy: the &quot;Unicodeness&quot; is now carried with the data, instead of being attached to the operations. Starting with Perl v5.8.0, only one case remains where an explicit &lt;code&gt;use utf8&lt;/code&gt; is needed: if your Perl script itself is encoded in UTF-8, you can use UTF-8 in your identifier names, and in string and regular expression literals, by saying &lt;code&gt;use utf8&lt;/code&gt;. This is not the default because scripts with legacy 8-bit data in them would break. See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e04ef0cf482846e31d6720b49ae41928208ea3" translate="yes" xml:space="preserve">
          <source>Before Unicode, most encodings used 8 bits (a single byte) to encode each character. Thus a character was a byte, and a byte was a character, and there could be only 256 or fewer possible characters. &quot;Byte Semantics&quot; in the title of this section refers to this behavior. There was no need to distinguish between &quot;Byte&quot; and &quot;Character&quot;.</source>
          <target state="translated">在Unicode之前,大多数编码使用8位(一个字节)来编码每个字符。因此,一个字符就是一个字节,一个字节就是一个字符,而且只能有256个或更少的可能字符。本节标题中的 &quot;字节语义 &quot;指的就是这种行为。没有必要区分 &quot;字节 &quot;和 &quot;字符&quot;。</target>
        </trans-unit>
        <trans-unit id="98f333eb7b1048c01de83e53fdf2f8f76121657f" translate="yes" xml:space="preserve">
          <source>Before Unicode, when a character was a byte was a character, Perl knew only about the 128 characters defined by ASCII, code points 0 through 127 (except for under &lt;a href=&quot;perllocale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt;). That left the code points 128 to 255 as unassigned, and available for whatever use a program might want. The only semantics they have is their ordinal numbers, and that they are members of none of the non-negative character classes. None are considered to match &lt;code&gt;\w&lt;/code&gt; for example, but all match &lt;code&gt;\W&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290d67ae3ee387c5e4e99c79148af4efc4e204f2" translate="yes" xml:space="preserve">
          <source>Before Unicode, when a character was a byte was a character, Perl knew only about the 128 characters defined by ASCII, code points 0 through 127 (except for under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ). That left the code points 128 to 255 as unassigned, and available for whatever use a program might want. The only semantics they have is their ordinal numbers, and that they are members of none of the non-negative character classes. None are considered to match &lt;code&gt;\w&lt;/code&gt; for example, but all match &lt;code&gt;\W&lt;/code&gt; .</source>
          <target state="translated">在Unicode之前，当一个字符是一个字节即一个字符时，Perl仅知道ASCII定义的128个字符，代码点为0到127（ &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 除外）。剩下的代码点128至255未分配，并且可用于程序可能需要的任何用途。它们唯一的语义是它们的序数，并且它们都不是非负字符类的成员。无被视为匹配 &lt;code&gt;\w&lt;/code&gt; 的例子，但全部匹配 &lt;code&gt;\W&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d690a12b540a565baadfa57c599d5a868691200d" translate="yes" xml:space="preserve">
          <source>Before any command has executed or if an unexpected error occurs &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return undef.</source>
          <target state="translated">在执行任何命令之前或如果发生意外错误， &lt;code&gt;code()&lt;/code&gt; 将返回&amp;ldquo; 421&amp;rdquo;（临时连接失败），而 &lt;code&gt;message()&lt;/code&gt; 将返回undef。</target>
        </trans-unit>
        <trans-unit id="752f8552c1f4e0b002a40cffe2d75752a7a074d6" translate="yes" xml:space="preserve">
          <source>Before anything else, you need a testing plan. This basically declares how many tests your script is going to run to protect against premature failure.</source>
          <target state="translated">在任何其他事情之前,你需要一个测试计划。这基本上声明了你的脚本要运行多少次测试以防止过早失败。</target>
        </trans-unit>
        <trans-unit id="62bd9b6df52b51e065387fd43e36061f890b0944" translate="yes" xml:space="preserve">
          <source>Before calling copy() or move() on a filehandle, the caller should close or flush() the file to avoid writes being lost. Note that this is the case even for move(), because it may actually copy the file, depending on the OS-specific implementation, and the underlying filesystem(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bb0c278106c5fac84e8a238d47e490b85a41fa5" translate="yes" xml:space="preserve">
          <source>Before installing the patches to the IBM C-compiler you need to know the level of patching for the Operating System. IBM's command 'oslevel' will show the base, but is not always complete (in this example oslevel shows 4.3.NULL, whereas the system might run most of 4.3.THREE):</source>
          <target state="translated">在给IBM C-编译器安装补丁之前,你需要知道操作系统的补丁级别。IBM的命令'oslevel'会显示基础,但并不总是完整的(在这个例子中oslevel显示4.3.NULL,而系统可能会运行4.3.THREE的大部分)。</target>
        </trans-unit>
        <trans-unit id="b46ac14ab9ac97916ee87fb2735b65fa3bcb3084" translate="yes" xml:space="preserve">
          <source>Before perl5.6, you had to deal with various typeglob idioms which you may see in older code.</source>
          <target state="translated">在perl5.6之前,你必须处理各种tyeglob习语,这些习语你可能会在旧代码中看到。</target>
        </trans-unit>
        <trans-unit id="cb7ffbda991b922f283aad1fac8b7fea6f1f3918" translate="yes" xml:space="preserve">
          <source>Before pushing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ceb0c5361b0c57292563baaff9c21803203fbb" translate="yes" xml:space="preserve">
          <source>Before pushing any change to a maint version, make sure you've satisfied the steps in &lt;a href=&quot;#Committing-to-blead&quot;&gt;&quot;Committing to blead&quot;&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d24253ab2fd2c805f0d6bcaca41ee8bd8627285" translate="yes" xml:space="preserve">
          <source>Before release 5 of Perl it was difficult to represent complex data structures, because all references had to be symbolic--and even then it was difficult to refer to a variable instead of a symbol table entry. Perl now not only makes it easier to use symbolic references to variables, but also lets you have &quot;hard&quot; references to any piece of data or code. Any scalar may hold a hard reference. Because arrays and hashes contain scalars, you can now easily build arrays of arrays, arrays of hashes, hashes of arrays, arrays of hashes of functions, and so on.</source>
          <target state="translated">在Perl第5版之前,表示复杂的数据结构是很困难的,因为所有的引用都必须是符号的--即使如此,也很难引用一个变量而不是一个符号表项。现在,Perl 不仅使变量的符号引用变得更加容易,而且还允许你对任何数据或代码进行 &quot;硬 &quot;引用。任何标量都可以持有一个硬引用。因为数组和散列包含标量,所以你现在可以轻松地构建数组的数组、数组的散列、数组的散列、函数的散列等。</target>
        </trans-unit>
        <trans-unit id="ef266fb9e8f6dafd9b23077a1b88d8327a3a9667" translate="yes" xml:space="preserve">
          <source>Before submitting a bug, please make sure that the traditional method of building a Perl module package from a shell by following the installation instructions of that package still works in your environment.</source>
          <target state="translated">在提交bug之前,请确认从shell中按照软件包的安装说明来构建Perl模块包的传统方法在你的环境中仍然有效。</target>
        </trans-unit>
        <trans-unit id="852a62fb5185caad446c6f66da79350d77dac37e" translate="yes" xml:space="preserve">
          <source>Before terminating, the &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function must explicitly install the filter by calling &lt;code&gt;filter_add&lt;/code&gt; .</source>
          <target state="translated">在终止之前， &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 功能必须通过调用 &lt;code&gt;filter_add&lt;/code&gt; 显式安装过滤器。</target>
        </trans-unit>
        <trans-unit id="c19a9bcc3d0fce58bd4d9d25f82f4cb8c5d35503" translate="yes" xml:space="preserve">
          <source>Before terminating, the &lt;code&gt;import&lt;/code&gt; function must explicitly install the filter by calling &lt;code&gt;filter_add&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f512253f81c2fd706ba28a9ad84dc13dc48c3eb8" translate="yes" xml:space="preserve">
          <source>Before the Perl interpreter can execute a Perl script, it must first read it from a file into memory for parsing and compilation. If that script itself includes other scripts with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement, then each of those scripts will have to be read from their respective files as well.</source>
          <target state="translated">在Perl解释器可以执行Perl脚本之前，它必须首先将其从文件中读取到内存中以进行解析和编译。如果该脚本本身包括带有 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 语句的其他脚本，则每个脚本也必须从各自的文件中读取。</target>
        </trans-unit>
        <trans-unit id="c6081a0bc2c6ca5d40e9bce0501b5e221be236ae" translate="yes" xml:space="preserve">
          <source>Before the Perl interpreter can execute a Perl script, it must first read it from a file into memory for parsing and compilation. If that script itself includes other scripts with a &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; statement, then each of those scripts will have to be read from their respective files as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7056378ac690eaab80565ece696557496384c5bd" translate="yes" xml:space="preserve">
          <source>Before the introduction of Unicode support in Perl, The &lt;code&gt;eq&lt;/code&gt; operator just compared the strings represented by two scalars. Beginning with Perl 5.8, &lt;code&gt;eq&lt;/code&gt; compares two strings with simultaneous consideration of</source>
          <target state="translated">在Perl中引入Unicode支持之前， &lt;code&gt;eq&lt;/code&gt; 运算符仅比较了两个标量表示的字符串。从Perl 5.8开始， &lt;code&gt;eq&lt;/code&gt; 比较两个字符串，同时考虑</target>
        </trans-unit>
        <trans-unit id="07d7d02c48129829b963f0f9c3efb3625c646877" translate="yes" xml:space="preserve">
          <source>Before the introduction of lexical warnings, Perl had two classes of warnings: mandatory and optional.</source>
          <target state="translated">在引入词法警告之前,Perl有两类警告:强制警告和可选警告。</target>
        </trans-unit>
        <trans-unit id="759cf8f89c69b1e5d0ddf3e544f843b8c5c70ae3" translate="yes" xml:space="preserve">
          <source>Before we even start scraping out the code, there are a few things we'll want to do in advance.</source>
          <target state="translated">在我们开始刮出代码之前,有几件事我们要提前做。</target>
        </trans-unit>
        <trans-unit id="a2896a2a84e6fb1618d5a02150eb4f976c910264" translate="yes" xml:space="preserve">
          <source>Before we go any further, you'll want to know how to quit the debugger: use just the letter '&lt;b&gt;q&lt;/b&gt;', not the words 'quit' or 'exit':</source>
          <target state="translated">在我们进行下一步之前，您将需要知道如何退出调试器：仅使用字母&amp;ldquo; &lt;b&gt;q&lt;/b&gt; &amp;rdquo;，而不要使用&amp;ldquo; quit&amp;rdquo;或&amp;ldquo; exit&amp;rdquo;一词：</target>
        </trans-unit>
        <trans-unit id="10af6d27d8d05a680d682b1087a82d6e520c2fff" translate="yes" xml:space="preserve">
          <source>Before writing XS, read the &lt;a href=&quot;#CAVEATS&quot;&gt;&quot;CAVEATS&quot;&lt;/a&gt; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a4b62fae1d0e77e031397754824b30119b2b62a" translate="yes" xml:space="preserve">
          <source>Before writing XS, read the &lt;a href=&quot;#CAVEATS&quot;&gt;CAVEATS&lt;/a&gt; section below.</source>
          <target state="translated">在编写XS之前，请阅读下面的&lt;a href=&quot;#CAVEATS&quot;&gt;CAVEATS&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="1b5bba6a088484e3f244c7ed2d3c63206cbf13d5" translate="yes" xml:space="preserve">
          <source>Before you consider posting a bug report, please consult, and possibly post a message to the discussion forum to see if what you've encountered is a known problem.</source>
          <target state="translated">在您考虑发布错误报告之前,请咨询,并可能在讨论区发布消息,看看您遇到的是否是已知问题。</target>
        </trans-unit>
        <trans-unit id="528e582d94b55449ac3523f64dd0d0e5c7486531" translate="yes" xml:space="preserve">
          <source>Before you continue, note the sort order for variables. In general, we first list the variables in case-insensitive, almost-lexigraphical order (ignoring the &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt; preceding words, as in &lt;code&gt;${^UNICODE}&lt;/code&gt; or &lt;code&gt;$^T&lt;/code&gt; ), although &lt;code&gt;$_&lt;/code&gt; and &lt;code&gt;@_&lt;/code&gt; move up to the top of the pile. For variables with the same identifier, we list it in order of scalar, array, hash, and bareword.</source>
          <target state="translated">在继续之前，请注意变量的排序顺序。一般情况下，我们首先列表不区分大小写，几乎lexigraphical顺序变量（忽略 &lt;code&gt;{&lt;/code&gt; 或 &lt;code&gt;^&lt;/code&gt; 前述词语，如 &lt;code&gt;${^UNICODE}&lt;/code&gt; 或 &lt;code&gt;$^T&lt;/code&gt; ），虽然 &lt;code&gt;$_&lt;/code&gt; 和 &lt;code&gt;@_&lt;/code&gt; 向上移动到顶部一堆 对于具有相同标识符的变量，我们按标量，数组，哈希和裸字的顺序列出。</target>
        </trans-unit>
        <trans-unit id="e90a6f007e6fb64dd92c6079f36a3d06c252dda3" translate="yes" xml:space="preserve">
          <source>Before you continue, note the sort order for variables. In general, we first list the variables in case-insensitive, almost-lexigraphical order (ignoring the &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt; preceding words, as in &lt;code&gt;${^UNICODE}&lt;/code&gt; or &lt;code&gt;$^T&lt;/code&gt;), although &lt;code&gt;$_&lt;/code&gt; and &lt;code&gt;@_&lt;/code&gt; move up to the top of the pile. For variables with the same identifier, we list it in order of scalar, array, hash, and bareword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b11945139a380af16d5d49212f0306507606fb" translate="yes" xml:space="preserve">
          <source>Before you decide to merge two hashes, you have to decide what to do if both hashes contain keys that are the same and if you want to leave the original hashes as they were.</source>
          <target state="translated">在决定合并两个哈希值之前,你必须决定如果两个哈希值都包含相同的键,以及是否要保持原来的哈希值不变,该怎么做。</target>
        </trans-unit>
        <trans-unit id="7b25edaa05329b202d8bbb719df130a305f9a0e7" translate="yes" xml:space="preserve">
          <source>Before you do anything else, you can help yourself by ensuring that you let Perl tell you about problem areas in your code. By turning on warnings and strictures, you can head off many problems before they get too big. You can find out more about these in &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">在执行其他任何操作之前，可以通过确保让Perl告诉您代码中的问题区域来帮助自己。通过打开警告和约束，您可以避免许多问题变得太大。您可以在&lt;a href=&quot;strict&quot;&gt;严格&lt;/a&gt;和&lt;a href=&quot;warnings&quot;&gt;警告中&lt;/a&gt;找到更多关于这些的信息。</target>
        </trans-unit>
        <trans-unit id="054a146795bb49c5d92e2d968e739a1f63c7604c" translate="yes" xml:space="preserve">
          <source>Before you do that, first make sure the alias is nonexistent using &lt;code&gt;resolve_alias()&lt;/code&gt; , which returns the canonical name thereof. For example:</source>
          <target state="translated">在执行此操作之前，请首先使用 &lt;code&gt;resolve_alias()&lt;/code&gt; 确保别名不存在，该别名将返回其规范名称。例如：</target>
        </trans-unit>
        <trans-unit id="9fa55498f41c7cd4663e8d59ae7b91ebb05c3bad" translate="yes" xml:space="preserve">
          <source>Before you do that, first make sure the alias is nonexistent using &lt;code&gt;resolve_alias()&lt;/code&gt;, which returns the canonical name thereof. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4eb9d8b93fbec8607b4df5d4d1083567318fe5" translate="yes" xml:space="preserve">
          <source>Before you launch yourself head first into the rest of this document, it would be a good idea to have read the following two documents--&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">在开始阅读本文档的其余部分之前，先阅读以下两个文档（&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;和&lt;a href=&quot;perlguts&quot;&gt;perlguts）&lt;/a&gt;是一个好主意。</target>
        </trans-unit>
        <trans-unit id="dde9d3bcf2359cbba92e26ac6718964bcaacd3c3" translate="yes" xml:space="preserve">
          <source>Before you panic, know that many people do use &lt;code&gt;Moose&lt;/code&gt; for command-line tools and other startup-sensitive code. We encourage you to try &lt;code&gt;Moose&lt;/code&gt; out first before worrying about startup speed.</source>
          <target state="translated">在您惊慌失措之前，请知道许多人确实将 &lt;code&gt;Moose&lt;/code&gt; 用于命令行工具和其他对启动敏感的代码。我们建议您在担心启动速度之前先尝试 &lt;code&gt;Moose&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c445dd5994fd48a7f879efa85cd15aa5394f95f" translate="yes" xml:space="preserve">
          <source>Before you start</source>
          <target state="translated">在你开始之前</target>
        </trans-unit>
        <trans-unit id="fa35a8236ca3aecdca56f64d9f3832c8bf9e0996" translate="yes" xml:space="preserve">
          <source>Before you start, it's important to know a few things:</source>
          <target state="translated">在你开始之前,知道一些事情很重要。</target>
        </trans-unit>
        <trans-unit id="85435e88ea012cea6ee5f0e38fd4d12329633e18" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory to which the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">在你开始之前,你应该先浏览一下在解压Perl发行版的顶层目录中找到的README文件。确保你阅读并理解本软件发布的条款。</target>
        </trans-unit>
        <trans-unit id="82f236c12f0a7b2bfa05bcc6c77fce0d5554f74c" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory where the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">在你开始之前,你应该先浏览一下在解压Perl发行版的顶层目录中找到的README文件。确保你阅读并理解本软件发布的条款。</target>
        </trans-unit>
        <trans-unit id="e6dc5aa054869bdc5776548930fba90056a049b5" translate="yes" xml:space="preserve">
          <source>Begin the retrieval of a file called &lt;code&gt;FILE&lt;/code&gt; from the remote server.</source>
          <target state="translated">开始从远程服务器检索名为 &lt;code&gt;FILE&lt;/code&gt; 的文件。</target>
        </trans-unit>
        <trans-unit id="d1bae729fa6ba19a84ae13329bfa79bbfaf77e9b" translate="yes" xml:space="preserve">
          <source>Beginner note: In example 2, above &lt;code&gt;$columns&lt;/code&gt; is imported into the local namespace, and set locally. In example 3, &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; is set in its own namespace without importing it.</source>
          <target state="translated">初学者注意：在示例2中， &lt;code&gt;$columns&lt;/code&gt; 以上的元素被导入到本地名称空间，并在本地设置。在示例3中， &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; 在其自身的名称空间中设置，而无需导入。</target>
        </trans-unit>
        <trans-unit id="8c50d29cf088569a469311ef83bf39d51d30a011" translate="yes" xml:space="preserve">
          <source>Beginners often think they want to have a variable contain the name of a variable.</source>
          <target state="translated">初学者往往认为要让一个变量包含一个变量的名称。</target>
        </trans-unit>
        <trans-unit id="ddd5e0ea97f5ceda3171fdb3abe535bc421229c3" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.12, Perl accepts an ellipsis, &quot;&lt;code&gt;...&lt;/code&gt; &quot;, as a placeholder for code that you haven't implemented yet. This form of ellipsis, the unimplemented statement, should not be confused with the binary flip-flop &lt;code&gt;...&lt;/code&gt; operator. One is a statement and the other an operator. (Perl doesn't usually confuse them because usually Perl can tell whether it wants an operator or a statement, but see below for exceptions.)</source>
          <target state="translated">从Perl 5.12开始，Perl接受省略号&amp;ldquo; &lt;code&gt;...&lt;/code&gt; &amp;rdquo;作为尚未实现的代码的占位符。这种形式的省略号（未实现的语句）不应与二进制 &lt;code&gt;...&lt;/code&gt; 操作符混淆。一个是语句，另一个是运算符。（Perl通常不会混淆它们，因为通常Perl可以告诉它是想要运算符还是语句，但是请参阅下文以了解异常。）</target>
        </trans-unit>
        <trans-unit id="dc88deeacfc5c23c60a84d0e355d8d08bad0853c" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.12, Perl accepts an ellipsis, &quot;&lt;code&gt;...&lt;/code&gt;&quot;, as a placeholder for code that you haven't implemented yet. When Perl 5.12 or later encounters an ellipsis statement, it parses this without error, but if and when you should actually try to execute it, Perl throws an exception with the text &lt;code&gt;Unimplemented&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c724bcc9cdece1aeab2aab45c2518eb7791435" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.28, multi-threaded locale operation is supported on systems that implement either the POSIX 2008 or Windows-specific thread-safe locale operations. Many modern systems, such as various Unix variants and Darwin do have this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a346d69c5ac7465ea021c968ddc77fd7f137feb" translate="yes" xml:space="preserve">
          <source>Beginning in v5.20.0, a postfix syntax for using references is available. It behaves as described in &lt;a href=&quot;#Using-References&quot;&gt;&quot;Using References&quot;&lt;/a&gt;, but instead of a prefixed sigil, a postfixed sigil-and-star is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d48c3b20d2f80bac7595523990a9132ad0e311" translate="yes" xml:space="preserve">
          <source>Beginning in v5.20.0, a postfix syntax for using references is available. It behaves as described in &lt;a href=&quot;#Using-References&quot;&gt;Using References&lt;/a&gt;, but instead of a prefixed sigil, a postfixed sigil-and-star is used.</source>
          <target state="translated">从v5.20.0开始，提供了使用引用的后缀语法。它的行为如《&lt;a href=&quot;#Using-References&quot;&gt;使用参考》中所述&lt;/a&gt;，但使用前缀后缀的sigil-and-star代替前缀的sigil。</target>
        </trans-unit>
        <trans-unit id="e4fd9d1748abdc28d0efb1f242a157236c1c9529" translate="yes" xml:space="preserve">
          <source>Beginning in v5.22.0, the referencing operator can be assigned to. It performs an aliasing operation, so that the variable name referenced on the left-hand side becomes an alias for the thing referenced on the right-hand side:</source>
          <target state="translated">从v5.22.0开始,引用操作符可以被分配到。它执行了一个别名操作,这样左手边引用的变量名就变成了右手边引用的东西的别名。</target>
        </trans-unit>
        <trans-unit id="ffa0956923ab92c4c7492c5469e046b41154fb80" translate="yes" xml:space="preserve">
          <source>Beginning in v5.26.0, the referencing operator can come after &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt;, or &lt;code&gt;local&lt;/code&gt;. This syntax must be enabled with &lt;code&gt;use feature 'declared_refs'&lt;/code&gt;. It is experimental, and will warn by default unless &lt;code&gt;no warnings 'experimental::refaliasing'&lt;/code&gt; is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f7bcfa82e1deb0e3342e8510b04a376681f2a5" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX 11.00, programs compiled under HP-UX can take advantage of the LP64 programming environment (LP64 means Longs and Pointers are 64 bits wide), in which scalar variables will be able to hold numbers larger than 2^32 with complete precision. Perl has proven to be consistent and reliable in 64bit mode since 5.8.1 on all HP-UX 11.xx.</source>
          <target state="translated">从HP-UX 11.00开始,在HP-UX下编译的程序可以利用LP64编程环境(LP64的意思是Longs和Pointers是64位宽),其中标量变量将可以完全精确地容纳大于2^32的数字。自5.8.1以来,Perl在所有HP-UX 11.xx上被证明在64位模式下是稳定可靠的。</target>
        </trans-unit>
        <trans-unit id="7f252bceac885ebc51d1278ef820d426befd060f" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX version 10.20, files larger than 2GB (2^31 bytes) may be created and manipulated. Three separate methods of doing this are available. Of these methods, the best method for Perl is to compile using the -Duselargefiles flag to Configure. This causes Perl to be compiled using structures and functions in which these are 64 bits wide, rather than 32 bits wide. (Note that this will only work with HP's ANSI C compiler. If you want to compile Perl using gcc, you will have to get a version of the compiler that supports 64-bit operations. See above for where to find it.)</source>
          <target state="translated">从HP-UX 10.20版本开始,可以创建和操作大于2GB(2^31字节)的文件。有三种不同的方法可以做到这一点。在这些方法中,对于Perl来说,最好的方法是使用配置的-Duselargefiles标志进行编译。这将导致 Perl 使用 64 位宽的结构和函数进行编译,而不是 32 位宽。(注意,这只适用于 HP 的 ANSI C 编译器。如果你想用gcc编译Perl,你必须得到一个支持64位操作的编译器版本。参见上文,哪里可以找到它)。)</target>
        </trans-unit>
        <trans-unit id="7b1997a711dcb385772e62932a24b63be2ca5162" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.10.0, you can declare variables with the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword in place of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. For that to work, though, you must have enabled that feature beforehand, either by using the &lt;code&gt;feature&lt;/code&gt; pragma, or by using &lt;code&gt;-E&lt;/code&gt; on one-liners (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;). Beginning with Perl 5.16, the &lt;code&gt;CORE::state&lt;/code&gt; form does not require the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="translated">从Perl 5.10.0开始，您可以使用 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 关键字声明变量来代替 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 。但是，要使该功能正常工作，您必须预先启用该功能，方法是使用 &lt;code&gt;feature&lt;/code&gt; 杂注或在 &lt;code&gt;-E&lt;/code&gt; 上使用-E（请参阅&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;）。从Perl 5.16开始， &lt;code&gt;CORE::state&lt;/code&gt; 表单不需要 &lt;code&gt;feature&lt;/code&gt; 编译指示。</target>
        </trans-unit>
        <trans-unit id="043ad372200ab11184230c8b464cbbec604d0f73" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.10.0, you can declare variables with the &lt;code&gt;state&lt;/code&gt; keyword in place of &lt;code&gt;my&lt;/code&gt;. For that to work, though, you must have enabled that feature beforehand, either by using the &lt;code&gt;feature&lt;/code&gt; pragma, or by using &lt;code&gt;-E&lt;/code&gt; on one-liners (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;). Beginning with Perl 5.16, the &lt;code&gt;CORE::state&lt;/code&gt; form does not require the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd848af5e7c989b28a26cc1aec55564025fc4af9" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.18, you can declare a private subroutine with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;. As with state variables, the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword is only available under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; or higher.</source>
          <target state="translated">从Perl 5.18开始，您可以使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 声明一个私有子例程。与状态变量一样， &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 关键字仅在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; 或更高版本时可用。</target>
        </trans-unit>
        <trans-unit id="4f40c1f7eb582d4b15076061b6d0a8e085b355dc" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.18, you can declare a private subroutine with &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;state&lt;/code&gt;. As with state variables, the &lt;code&gt;state&lt;/code&gt; keyword is only available under &lt;code&gt;use feature 'state'&lt;/code&gt; or &lt;code&gt;use 5.010&lt;/code&gt; or higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb06f268b9e85c6ee8127ae9f07256660624d8e4" translate="yes" xml:space="preserve">
          <source>Beginning with Perl version 5.26, a much simpler and cleaner way to write indented here documents has been added to the language: the tilde (~) modifier. See &lt;a href=&quot;perlop#Indented-Here-docs&quot;&gt;&quot;Indented Here-docs&quot; in perlop&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eca9f03e4044bf99d10838840f25a5c4ae464b9" translate="yes" xml:space="preserve">
          <source>Beginning with perl 5.10.0, you can also use &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables to have lexicals that are initialized only once (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;):</source>
          <target state="translated">从perl 5.10.0开始，您还可以使用 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 变量来具有仅初始化一次的词法（请参阅&lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="62b599a702a0e45efa83ae9abd2c72ac9e40e2f7" translate="yes" xml:space="preserve">
          <source>Beginning with perl 5.10.0, you can also use &lt;code&gt;state&lt;/code&gt; variables to have lexicals that are initialized only once (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d269396692530a4c995cb59a2555fae5ff4dd172" translate="yes" xml:space="preserve">
          <source>Beginning with version 5.004, the following functions are also supported:</source>
          <target state="translated">从5.004版本开始,还支持以下功能。</target>
        </trans-unit>
        <trans-unit id="5a1a2270a454451ac22b568bca58999ca2a57b3c" translate="yes" xml:space="preserve">
          <source>Beginning/End of line positions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2dfcf5f267b41370cad897910ad80d037ac22ab" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;a href=&quot;#newCONSTSUB_flags&quot;&gt;&quot;newCONSTSUB_flags&quot;&lt;/a&gt;, except that &lt;code&gt;name&lt;/code&gt; is nul-terminated rather than of counted length, and no flags are set. (This means that &lt;code&gt;name&lt;/code&gt; is always interpreted as Latin-1.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6fd5b0516beaff8d8429855f694694659eb195" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;a href=&quot;http://man.he.net/man2/wait&quot;&gt;wait(2)&lt;/a&gt; on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt;&lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt;&lt;/a&gt;. Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb78858d773149c7141146370197d2f530d8902f" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;$_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34133685a790f2f2b5caab0cdf19417a300c4bef" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">行为类似于系统上的wait（2）：它等待子进程终止并返回已故进程的pid，如果没有子进程则返回 &lt;code&gt;-1&lt;/code&gt; 。状态以 &lt;code&gt;$?&lt;/code&gt; 返回？和 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 。请注意，返回值 &lt;code&gt;-1&lt;/code&gt; 可能意味着正在自动获得子进程，如&lt;a href=&quot;../perlipc&quot;&gt;perlipc中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f0c5491ce914759629c95815e914e921b25062e" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">行为类似于系统上的wait（2）：它等待子进程终止并返回已故进程的pid，如果没有子进程则返回 &lt;code&gt;-1&lt;/code&gt; 。状态以 &lt;code&gt;$?&lt;/code&gt; 返回？和 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 。请注意，返回值 &lt;code&gt;-1&lt;/code&gt; 可能意味着正在自动获得子进程，如&lt;a href=&quot;perlipc&quot;&gt;perlipc中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="756aaec531bd197c8baf40355b6e7560606340ee" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak&quot;&gt;&quot;croak&quot;&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be599b479dc1a9d62fd33cd4b25ae6147cf1069" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">除了返回类型外，其他行为与&lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;相同。仅应在需要 &lt;code&gt;OP *&lt;/code&gt; 返回类型的地方使用。该函数实际上不会返回。</target>
        </trans-unit>
        <trans-unit id="e3b8ea26eb4d496c3c9598880a77b0e504f2a647" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak_sv&quot;&gt;&quot;croak_sv&quot;&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c49c08082a231774a342ac5391eebbc26cb4596" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">除了返回类型外，其他行为与&lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt;相同。仅应在需要 &lt;code&gt;OP *&lt;/code&gt; 返回类型的地方使用。该函数实际上不会返回。</target>
        </trans-unit>
        <trans-unit id="fbf9c5863d4bbe3bd2490f1ad8ab93b461cdea43" translate="yes" xml:space="preserve">
          <source>Behavior of other Perl features in forked pseudo-processes</source>
          <target state="translated">其他Perl特性在分叉伪进程中的行为。</target>
        </trans-unit>
        <trans-unit id="546fd299e317f0cfab072f158d53c6046d080ef9" translate="yes" xml:space="preserve">
          <source>Behavior of this function varies wildly depending on your system implementation. For example, it will usually not work across file system boundaries, even though the system</source>
          <target state="translated">这个功能的行为根据你的系统实现而大相径庭。例如,它通常不会跨文件系统边界工作,即使系统的</target>
        </trans-unit>
        <trans-unit id="6296c0acaf0c68b8a708c260d5e620e45c188c21" translate="yes" xml:space="preserve">
          <source>Behaviour since version 2.11</source>
          <target state="translated">2.11版本以来的行为</target>
        </trans-unit>
        <trans-unit id="fc99a03494d30ac32472278376507c26adfb39ce" translate="yes" xml:space="preserve">
          <source>Behind The Scenes</source>
          <target state="translated">幕后花絮</target>
        </trans-unit>
        <trans-unit id="8e234f329fb33ee94403565f619b16d72bc67919" translate="yes" xml:space="preserve">
          <source>Behind the scenes the &lt;code&gt;globmap&lt;/code&gt; function does a combination of a file glob to match existing filenames followed by a substitute to create the new filenames.</source>
          <target state="translated">在后台， &lt;code&gt;globmap&lt;/code&gt; 函数对文件glob进行组合以匹配现有的文件名，然后通过替换来创建新的文件名。</target>
        </trans-unit>
        <trans-unit id="4f88b0aecf2344cf177fb22c2c1e4809d60f491d" translate="yes" xml:space="preserve">
          <source>Being Perl-specific, this function has evolved along time. It can currently be called as follow:</source>
          <target state="translated">作为Perl特有的函数,这个函数已经随着时间的推移而发展。目前,它的调用方式如下。</target>
        </trans-unit>
        <trans-unit id="0fc303a764ff6b60a94ad6969ea173a3382e1620" translate="yes" xml:space="preserve">
          <source>Being a mechanical process pl2pm is not bullet proof. The converted code will need careful checking, especially any package statements. Don't delete the original .pl file till the new .pm one works!</source>
          <target state="translated">作为一个机械过程,pl2pm并不是防弹的。转换后的代码需要仔细检查,特别是任何包的声明。在新的.pm工作之前,不要删除原来的.pl文件。</target>
        </trans-unit>
        <trans-unit id="7f0407ad618a0bd51d559ec6185eae8ed67ffedb" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt;. If you do just &lt;code&gt;open(my $A, &quot;&amp;gt;&amp;gt;&amp;amp;&quot;, $B)&lt;/code&gt;, the filehandle &lt;code&gt;$A&lt;/code&gt; will not have the same file descriptor as &lt;code&gt;$B&lt;/code&gt;, and therefore &lt;code&gt;flock($A)&lt;/code&gt; will not &lt;code&gt;flock($B)&lt;/code&gt; nor vice versa. But with &lt;code&gt;open(my $A, &quot;&amp;gt;&amp;gt;&amp;amp;=&quot;, $B)&lt;/code&gt;, the filehandles will share the same underlying system file descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e98f301c8128b87a5492d5177997df433005bc22" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">例如在某些情况下依赖于文件描述符时，例如在文件句柄上使用flock（）锁定，则在文件句柄上保持同等也很有用。如果仅 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; ，文件句柄A将与B没有相同的文件描述符，因此flock（A）不会flock（B），反之亦然。但是在 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; ，文件句柄将共享相同的基础系统文件描述符。</target>
        </trans-unit>
        <trans-unit id="eb7d6ff0d012000fe6eccb3c989a4ceae1efb833" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">例如在某些情况下依赖于文件描述符时，例如在文件句柄上使用flock（）锁定，则在文件句柄上保持同等也很有用。如果仅 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; ，文件句柄A将与B没有相同的文件描述符，因此flock（A）不会flock（B），反之亦然。但是在 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; ，文件句柄将共享相同的基础系统文件描述符。</target>
        </trans-unit>
        <trans-unit id="027a12c2fc8568e8b70b07ff536faf288a013670" translate="yes" xml:space="preserve">
          <source>Belarus</source>
          <target state="translated">Belarus</target>
        </trans-unit>
        <trans-unit id="5cb4c9d828175ed3931ec52305b32f47173a8e04" translate="yes" xml:space="preserve">
          <source>Belgium</source>
          <target state="translated">Belgium</target>
        </trans-unit>
        <trans-unit id="1b8a9f965c18d647b7a7bff03b9e0c4a68361224" translate="yes" xml:space="preserve">
          <source>Bell sounds when word completion fails.</source>
          <target state="translated">当单词完成失败时,会发出铃声。</target>
        </trans-unit>
        <trans-unit id="74d2e1c77a10412bd2a923bb84c1c65e97a50e55" translate="yes" xml:space="preserve">
          <source>Below are a few examples of globmaps</source>
          <target state="translated">以下是几个环球地图的例子</target>
        </trans-unit>
        <trans-unit id="8b537b36a224ab3855e5388cf5af4a7324861d08" translate="yes" xml:space="preserve">
          <source>Below comes a verbose discussion of these flags. Note that a &quot;codeset&quot; is simply an abstract set of character-codepoint pairs, while an encoding takes those codepoint numbers and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6238547f660d516d0fdf40f8de1337807f2955e" translate="yes" xml:space="preserve">
          <source>Below is a</source>
          <target state="translated">以下是</target>
        </trans-unit>
        <trans-unit id="eab1a70d36b9d2b495b3781776947aeb4b2fc004" translate="yes" xml:space="preserve">
          <source>Below is a list of a few frameworks with comments which might help you in making a decision, depending on your specific requirements. Start by reading the docs, then ask questions on the relevant mailing list or IRC channel.</source>
          <target state="translated">以下是一些框架的列表,并附有评论,这可能会帮助你做出决定,这取决于你的具体要求。从阅读文档开始,然后在相关的邮件列表或IRC频道上提问。</target>
        </trans-unit>
        <trans-unit id="1f47cec9db1010fb960d67042b7e30d1824cca4b" translate="yes" xml:space="preserve">
          <source>Below is a list of the files in the Unicode data base that Perl doesn't currently use, along with very brief descriptions of their purposes. Some of the names of the files have been shortened from those that Unicode uses, in order to allow them to be distinguishable from similarly named files on file systems for which only the first 8 characters of a name are significant.</source>
          <target state="translated">下面是Perl目前没有使用的Unicode数据库中的文件列表,以及对它们用途的简要描述。其中一些文件的名称与Unicode使用的文件名称相比有所缩短,以使它们能够与文件系统中类似名称的文件区分开来,因为对这些文件来说,名称的前8个字符才是重要的。</target>
        </trans-unit>
        <trans-unit id="80905719173a37bfcc2cab267e8366cac44b82fa" translate="yes" xml:space="preserve">
          <source>Below is a list of the methods available.</source>
          <target state="translated">以下是可用的方法列表。</target>
        </trans-unit>
        <trans-unit id="a5ddbb5a4ded78a58dd050a0a7bd8f09a53b44f8" translate="yes" xml:space="preserve">
          <source>Below is a list of the valid options:</source>
          <target state="translated">以下是有效选项的列表。</target>
        </trans-unit>
        <trans-unit id="f51c6d51b727cf7e1f4d3849980abd064bedf568" translate="yes" xml:space="preserve">
          <source>Below is a mapping of what utilities will be used in what order for what schemes, if available:</source>
          <target state="translated">以下是在有条件的情况下,哪些公用事业将按什么顺序用于什么计划的图谱。</target>
        </trans-unit>
        <trans-unit id="19c0c3663e2dbbc758912a1313a649285c7d7339" translate="yes" xml:space="preserve">
          <source>Below is a mod_perl Apache compression module, called &lt;code&gt;Apache::GZip&lt;/code&gt;, taken from &lt;a href=&quot;http://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression&quot;&gt;http://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beba98866f16c9dd2863b4a3ebd6b7ee815c3c45" translate="yes" xml:space="preserve">
          <source>Below is a possible implementation of a script to carry out the rename (error cases have been omitted)</source>
          <target state="translated">以下是执行重命名的脚本的一个可能的实现(省略了错误情况)</target>
        </trans-unit>
        <trans-unit id="58a01ebfbc11cd115ad51487cc4a5f70ba63da00" translate="yes" xml:space="preserve">
          <source>Below is a script which makes use of &lt;code&gt;gzreadline&lt;/code&gt; . It implements a very simple</source>
          <target state="translated">下面是一个使用 &lt;code&gt;gzreadline&lt;/code&gt; 的脚本。它实现了一个非常简单的</target>
        </trans-unit>
        <trans-unit id="dc35361ae28756350bcadeedc93fea7a717eda63" translate="yes" xml:space="preserve">
          <source>Below is a script which makes use of &lt;code&gt;gzreadline&lt;/code&gt;. It implements a very simple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffed42afdfaf25df4c7e5e8645b31ce92ca54e6" translate="yes" xml:space="preserve">
          <source>Below is a simple &quot;rename&quot; script that uses &lt;code&gt;globmap&lt;/code&gt; to determine the source and destination filenames.</source>
          <target state="translated">下面是一个简单的&amp;ldquo;重命名&amp;rdquo;脚本，该脚本使用 &lt;code&gt;globmap&lt;/code&gt; 确定源文件名和目标文件名。</target>
        </trans-unit>
        <trans-unit id="1ec37797cdff4399757b58637d8bd54b7066dfec" translate="yes" xml:space="preserve">
          <source>Below is an example module that makes use of the macros.</source>
          <target state="translated">下面是一个使用宏的例子模块。</target>
        </trans-unit>
        <trans-unit id="2be2899025a1fe4d200821c4ccbd79eabb3ab414" translate="yes" xml:space="preserve">
          <source>Below is an example program, &lt;code&gt;cpp_test&lt;/code&gt; , which makes use of this filter. Line numbers have been added to allow specific lines to be referenced easily.</source>
          <target state="translated">下面是一个示例程序 &lt;code&gt;cpp_test&lt;/code&gt; ，它使用了此过滤器。添加了行号，以便可以轻松引用特定的行。</target>
        </trans-unit>
        <trans-unit id="b304a8ff907f2b83be9fd715d004cdf9a531f584" translate="yes" xml:space="preserve">
          <source>Below is an example program, &lt;code&gt;cpp_test&lt;/code&gt;, which makes use of this filter. Line numbers have been added to allow specific lines to be referenced easily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e2cc23005bf69f272f1f19d9851308543cafdff" translate="yes" xml:space="preserve">
          <source>Below is just one example, illustrating the control verb &lt;code&gt;(*FAIL)&lt;/code&gt; , which may be abbreviated as &lt;code&gt;(*F)&lt;/code&gt; . If this is inserted in a regexp it will cause it to fail, just as it would at some mismatch between the pattern and the string. Processing of the regexp continues as it would after any &quot;normal&quot; failure, so that, for instance, the next position in the string or another alternative will be tried. As failing to match doesn't preserve capture groups or produce results, it may be necessary to use this in combination with embedded code.</source>
          <target state="translated">以下仅是一个示例，说明了控制动词 &lt;code&gt;(*FAIL)&lt;/code&gt; ，可以将其缩写为 &lt;code&gt;(*F)&lt;/code&gt; 。如果将其插入到正则表达式中，将导致它失败，就像在模式和字符串之间不匹配时一样。正则表达式的处理将像在任何&amp;ldquo;正常&amp;rdquo;失败之后一样继续进行，因此，例如，将尝试字符串中的下一个位置或其他替换方式。由于不匹配不会保留捕获组或产生结果，因此可能有必要将其与嵌入式代码结合使用。</target>
        </trans-unit>
        <trans-unit id="8dfcb4bdf0851e123d1da057d122d3eaadab35bd" translate="yes" xml:space="preserve">
          <source>Below is just one example, illustrating the control verb &lt;code&gt;(*FAIL)&lt;/code&gt;, which may be abbreviated as &lt;code&gt;(*F)&lt;/code&gt;. If this is inserted in a regexp it will cause it to fail, just as it would at some mismatch between the pattern and the string. Processing of the regexp continues as it would after any &quot;normal&quot; failure, so that, for instance, the next position in the string or another alternative will be tried. As failing to match doesn't preserve capture groups or produce results, it may be necessary to use this in combination with embedded code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994ae30ab39b91782977e3601a4b1c5958c55b6d" translate="yes" xml:space="preserve">
          <source>Below is the sample of what to do to reproduce the configuration on my machine. In</source>
          <target state="translated">以下是我的机器上重现配置的示例。在</target>
        </trans-unit>
        <trans-unit id="8d0833a6280a2357c9ec993c9c38bf06fc8a81e8" translate="yes" xml:space="preserve">
          <source>Below is typical code that shows how to use &lt;code&gt;LimitOutput&lt;/code&gt; .</source>
          <target state="translated">以下是显示如何使用 &lt;code&gt;LimitOutput&lt;/code&gt; 的典型代码。</target>
        </trans-unit>
        <trans-unit id="b7690c7bdc8f256fde6341fc38dc8edeb2bb2bde" translate="yes" xml:space="preserve">
          <source>Below is typical code that shows how to use &lt;code&gt;LimitOutput&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f28ac791ee08fb184476e4de12d634a0a1d7498" translate="yes" xml:space="preserve">
          <source>Ben Tilly</source>
          <target state="translated">Ben Tilly</target>
        </trans-unit>
        <trans-unit id="e231863abeba6b63203ae12c8ced1dd832bf1e27" translate="yes" xml:space="preserve">
          <source>Ben Tilly &amp;lt;btilly@gmail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="9a552526ddac8fc37648130a16d1381a6f9ad6fb" translate="yes" xml:space="preserve">
          <source>Benchmark - benchmark running times of Perl code</source>
          <target state="translated">基准 -Perl代码的基准运行时间。</target>
        </trans-unit>
        <trans-unit id="c6133998f601e0eb9b2fbe0a853d3f9116d43ce3" translate="yes" xml:space="preserve">
          <source>Benchmark Object</source>
          <target state="translated">基准对象</target>
        </trans-unit>
        <trans-unit id="0ff60c3e395ce6dcfa9869e330a91fa3d0e1a335" translate="yes" xml:space="preserve">
          <source>Benchmark inherits from no other class, except of course from Exporter.</source>
          <target state="translated">Benchmark不继承其他类,当然除了Exporter。</target>
        </trans-unit>
        <trans-unit id="bf40ff62878fab85612abb7b1055df933f606399" translate="yes" xml:space="preserve">
          <source>Benchmark running times of Perl code</source>
          <target state="translated">Perl代码的基准运行时间</target>
        </trans-unit>
        <trans-unit id="4b02607a2ea9a6953d07f941016201f155b468af" translate="yes" xml:space="preserve">
          <source>Benjamin Holzman contributed the tied variable support, Andrew Ford contributed the canonical order for hashes, and Gisle Aas fixed a few misunderstandings of mine regarding the perl internals, and optimized the emission of &quot;tags&quot; in the output streams by simply counting the objects instead of tagging them (leading to a binary incompatibility for the Storable image starting at version 0.6--older images are, of course, still properly understood). Murray Nesbitt made Storable thread-safe. Marc Lehmann added overloading and references to tied items support. Benjamin Holzman added a performance improvement for overloaded classes; thanks to Grant Street Group for footing the bill.</source>
          <target state="translated">Benjamin Holzman 贡献了绑定变量支持,Andrew Ford 贡献了哈希的规范顺序,Gisle Aas 修正了我对 perl 内部的一些误解,并优化了输出流中 &quot;标签 &quot;的发射,只对对象进行计数而不是标记(导致 Storable 图像从 0.6 版本开始出现二进制不兼容--当然,旧的图像仍然可以正确理解)。Murray Nesbitt 使 Storable 成为线程安全的。Marc Lehmann 增加了重载和对绑定项的引用支持。Benjamin Holzman 增加了对重载类的性能改进;感谢 Grant Street Group 的支持。</target>
        </trans-unit>
        <trans-unit id="97adf5b0f3e282d4b4c33cdd224636f12368207c" translate="yes" xml:space="preserve">
          <source>Benjamin Holzman contributed the tied variable support, Andrew Ford contributed the canonical order for hashes, and Gisle Aas fixed a few misunderstandings of mine regarding the perl internals, and optimized the emission of &quot;tags&quot; in the output streams by simply counting the objects instead of tagging them (leading to a binary incompatibility for the Storable image starting at version 0.6--older images are, of course, still properly understood). Murray Nesbitt made Storable thread-safe. Marc Lehmann added overloading and references to tied items support. Benjamin Holzman added a performance improvement for overloaded classes; thanks to Grant Street Group for footing the bill. Reini Urban took over maintainance from p5p, and added security fixes and huge object support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce63cc3b1fa95fc4c74ca1cad11a70531a58a69f" translate="yes" xml:space="preserve">
          <source>Benjamin Noggle &amp;lt;agwind@users.noreply.github.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75fc540bc0a50aa81831bc474ec860350d0bca6e" translate="yes" xml:space="preserve">
          <source>Berkeley DB allows the creation of in-memory databases by using NULL (that is, a &lt;code&gt;(char *)0&lt;/code&gt; in C) in place of the filename. &lt;b&gt;DB_File&lt;/b&gt; uses &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of NULL to provide this functionality.</source>
          <target state="translated">Berkeley DB允许使用NULL（即C中的 &lt;code&gt;(char *)0&lt;/code&gt; ）代替文件名来创建内存数据库。&lt;b&gt;DB_File&lt;/b&gt;使用 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 而不是NULL来提供此功能。</target>
        </trans-unit>
        <trans-unit id="b44f74f0eaff4623bb4f32a3bc9a77a5a293d873" translate="yes" xml:space="preserve">
          <source>Berkeley DB allows the creation of in-memory databases by using NULL (that is, a &lt;code&gt;(char *)0&lt;/code&gt; in C) in place of the filename. &lt;b&gt;DB_File&lt;/b&gt; uses &lt;code&gt;undef&lt;/code&gt; instead of NULL to provide this functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9268b246582cb1f8cd7166d3bdd75afc5afe74a7" translate="yes" xml:space="preserve">
          <source>Berkeley DB is a C library which provides a consistent interface to a number of database formats. &lt;b&gt;DB_File&lt;/b&gt; provides an interface to all three of the database types currently supported by Berkeley DB.</source>
          <target state="translated">Berkeley DB是一个C库，它为许多数据库格式提供一致的接口。&lt;b&gt;DB_File&lt;/b&gt;提供了Berkeley DB当前支持的所有三种数据库类型的接口。</target>
        </trans-unit>
        <trans-unit id="434964490ac8a77af87035de9e77b760d4b578ea" translate="yes" xml:space="preserve">
          <source>Berkeley DB uses the function dbopen() to open or create a database. Here is the C prototype for dbopen():</source>
          <target state="translated">Berkeley DB使用函数dbopen()来打开或创建一个数据库。这里是dbopen()的C语言原型。</target>
        </trans-unit>
        <trans-unit id="cbcc04a4e53af70d968fb1854369b92c28068d53" translate="yes" xml:space="preserve">
          <source>BerkeleyDB is available for Cygwin.</source>
          <target state="translated">BerkeleyDB可用于Cygwin。</target>
        </trans-unit>
        <trans-unit id="994ccae3d03329e5f7c9f11ecf6157dc38d89408" translate="yes" xml:space="preserve">
          <source>Beside import() and AUTOLOAD() there are only a few other methods.</source>
          <target state="translated">除了import()和AUTOLOAD()之外,只有其他几个方法。</target>
        </trans-unit>
        <trans-unit id="8eaf9c16309e0e030fec414bcececf296c9fd80c" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#Metacharacters&quot;&gt;&lt;code&gt;&quot;^&quot;&lt;/code&gt; and &lt;code&gt;&quot;$&quot;&lt;/code&gt;&lt;/a&gt;, Perl defines the following zero-width assertions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba06ebae884c8bbbcddfe487f2f73c4f3cbe88a" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#decode&quot;&gt;&quot;decode&quot;&lt;/a&gt; and &lt;a href=&quot;#encode&quot;&gt;&quot;encode&quot;&lt;/a&gt;, other methods are available as well. For instance, &lt;code&gt;name()&lt;/code&gt; returns the canonical name of the encoding object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc3e4e79500c47fb5b02fd6bd36bb30830d4b93" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#decode&quot;&gt;decode&lt;/a&gt; and &lt;a href=&quot;#encode&quot;&gt;encode&lt;/a&gt;, other methods are available as well. For instance, &lt;code&gt;name()&lt;/code&gt; returns the canonical name of the encoding object.</source>
          <target state="translated">除了&lt;a href=&quot;#decode&quot;&gt;解码&lt;/a&gt;和&lt;a href=&quot;#encode&quot;&gt;编码外&lt;/a&gt;，其他方法也可用。例如， &lt;code&gt;name()&lt;/code&gt; 返回编码对象的规范名称。</target>
        </trans-unit>
        <trans-unit id="c3f604e026977938c21e0b164fdc42c9575f5038" translate="yes" xml:space="preserve">
          <source>Besides being a metacharacter, the &lt;code&gt;&quot;.&quot;&lt;/code&gt; is an example of a &quot;character class&quot;, something that can match any single character of a given set of them. In its case, the set is just about all possible characters. Perl predefines several character classes besides the &lt;code&gt;&quot;.&quot;&lt;/code&gt;; there is a separate reference page about just these, &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212828aa9819262a5dba3e04d7db334b30f00e96" translate="yes" xml:space="preserve">
          <source>Besides being able to say &lt;code&gt;\p{Name=...}&lt;/code&gt;, the Name and Name_Aliases properties are accessible through the &lt;code&gt;\N{}&lt;/code&gt; interpolation in double-quoted strings and regular expressions; and functions &lt;code&gt;charnames::viacode()&lt;/code&gt;, &lt;code&gt;charnames::vianame()&lt;/code&gt;, and &lt;code&gt;charnames::string_vianame()&lt;/code&gt; (which require a &lt;code&gt;use charnames ();&lt;/code&gt; to be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7e42697322af6c9745acd371b634a7d3de7f9ce" translate="yes" xml:space="preserve">
          <source>Besides checking existing XS code, the script can also be used to retrieve compatibility information for various API calls using the &lt;code&gt;--api-info&lt;/code&gt; command line switch. For example:</source>
          <target state="translated">除了检查现有的XS代码外，该脚本还可用于使用 &lt;code&gt;--api-info&lt;/code&gt; 命令行开关检索各种API调用的兼容性信息。例如：</target>
        </trans-unit>
        <trans-unit id="38c540b359fe4177c8733f2554f7c8aac1cf7755" translate="yes" xml:space="preserve">
          <source>Besides many other tests, it will test every locale it finds on your system to see if they conform to the POSIX standard. If any have errors, it will include a summary near the end of the output of which locales passed all its tests, and which failed, and why.</source>
          <target state="translated">除了许多其他的测试,它还会测试它在你的系统中找到的每一个locale,看看它们是否符合POSIX标准。如果有任何错误,它将会在输出的结尾处包含一个总结,说明哪些locale通过了所有的测试,哪些失败了,以及原因。</target>
        </trans-unit>
        <trans-unit id="eaf1b9544c43d438f9e6f77acb1ab9f9247ce8b8" translate="yes" xml:space="preserve">
          <source>Besides putting the cross-compiler and the rest of the toolchain in your PATH, this will also provide the QNX_TARGET variable, which we will pass to Configure through -Dsysroot.</source>
          <target state="translated">除了将交叉编译器和其他工具链放在 PATH 中,还将提供 QNX_TARGET 变量,我们将通过 -Dsysroot 将其传递给配置。</target>
        </trans-unit>
        <trans-unit id="8731a27dfb4cb7bb97f8e5e387722a8377af9b68" translate="yes" xml:space="preserve">
          <source>Besides saving these hashes as the hashref attributes &lt;code&gt;name2path&lt;/code&gt; and &lt;code&gt;path2name&lt;/code&gt; , calling this function also returns these hashrefs. In list context, the return value of &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; is the list &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; . In scalar context, the return value is &lt;code&gt;\%name2path&lt;/code&gt; . Or you can just call this in void context.</source>
          <target state="translated">除了将这些哈希另存为hashref属性 &lt;code&gt;name2path&lt;/code&gt; 和 &lt;code&gt;path2name&lt;/code&gt; 之外，调用此函数还返回这些hashref。在列表上下文中， &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; 的返回值是列表 &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; 。在标量上下文中，返回值为 &lt;code&gt;\%name2path&lt;/code&gt; 。或者，您可以仅在无效上下文中调用它。</target>
        </trans-unit>
        <trans-unit id="68eae0359edab349209444648a1ef905188cfbd0" translate="yes" xml:space="preserve">
          <source>Besides saving these hashes as the hashref attributes &lt;code&gt;name2path&lt;/code&gt; and &lt;code&gt;path2name&lt;/code&gt;, calling this function also returns these hashrefs. In list context, the return value of &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; is the list &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt;. In scalar context, the return value is &lt;code&gt;\%name2path&lt;/code&gt;. Or you can just call this in void context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db52c932112966f376fe8b88f42b909a1d77f94" translate="yes" xml:space="preserve">
          <source>Besides taking away the special meaning of a metacharacter, a prefixed backslash changes some letter and digit characters away from matching just themselves to instead have special meaning. These are called &quot;escape sequences&quot;, and all such are described in &lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash&lt;/a&gt;. A backslash sequence (of a letter or digit) that doesn't currently have special meaning to Perl will raise a warning if warnings are enabled, as those are reserved for potential future use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d17cf41d34eb6f4b37b1b9cc872817585f3b1ca4" translate="yes" xml:space="preserve">
          <source>Besides the &lt;code&gt;$|&lt;/code&gt; special variable, you can use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to give your filehandle a &lt;code&gt;:unix&lt;/code&gt; layer, which is unbuffered:</source>
          <target state="translated">除了 &lt;code&gt;$|&lt;/code&gt; 特殊变量，您可以使用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 为文件句柄提供一个 &lt;code&gt;:unix&lt;/code&gt; 层，该层是无缓冲的：</target>
        </trans-unit>
        <trans-unit id="28b7e372985d4c31ff927994e7e34211eb124b71" translate="yes" xml:space="preserve">
          <source>Besides the &lt;code&gt;$|&lt;/code&gt; special variable, you can use &lt;code&gt;binmode&lt;/code&gt; to give your filehandle a &lt;code&gt;:unix&lt;/code&gt; layer, which is unbuffered:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c874def12573a04b6982ff2c45bf57742f038615" translate="yes" xml:space="preserve">
          <source>Besides the NBSP character discussed above, implementors are reminded of the existence of the other &quot;special&quot; character in Latin-1, the &quot;soft hyphen&quot; character, also known as &quot;discretionary hyphen&quot;, i.e. &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ). This character expresses an optional hyphenation point. That is, it normally renders as nothing, but may render as a &quot;-&quot; if a formatter breaks the word at that point. Pod formatters should, as appropriate, do one of the following: 1) render this with a code with the same meaning (e.g., &quot;\-&quot; in RTF), 2) pass it through in the expectation that the formatter understands this character as such, or 3) delete it.</source>
          <target state="translated">除了上面讨论的NBSP字符外，还提醒实现者拉丁语1中存在另一个&amp;ldquo;特殊&amp;rdquo;字符，即&amp;ldquo;软连字符&amp;rdquo;字符，也称为&amp;ldquo;自由连字符&amp;rdquo;，即 &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ）。此字符表示可选的连字符点。就是说，它通常不显示任何内容，但是如果格式化程序在该点中断了单词，则可能显示为&amp;ldquo;-&amp;rdquo;。 Pod格式化程序应适当地执行以下操作之一：1）使用具有相同含义的代码（例如RTF中的&amp;ldquo; \-&amp;rdquo;）渲染此代码，2）期望格式化程序将其理解为以下字符：或3）删除它。</target>
        </trans-unit>
        <trans-unit id="fb9d8bd5854ba8b088687eedfedb188dbc42540c" translate="yes" xml:space="preserve">
          <source>Besides the NBSP character discussed above, implementors are reminded of the existence of the other &quot;special&quot; character in Latin-1, the &quot;soft hyphen&quot; character, also known as &quot;discretionary hyphen&quot;, i.e. &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt;). This character expresses an optional hyphenation point. That is, it normally renders as nothing, but may render as a &quot;-&quot; if a formatter breaks the word at that point. Pod formatters should, as appropriate, do one of the following: 1) render this with a code with the same meaning (e.g., &quot;\-&quot; in RTF), 2) pass it through in the expectation that the formatter understands this character as such, or 3) delete it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383f64e6a803d40e90542694df252e926486880e" translate="yes" xml:space="preserve">
          <source>Besides the normal array index looping, &lt;code&gt;for&lt;/code&gt; can lend itself to many other interesting applications. Here's one that avoids the problem you get into if you explicitly test for end-of-file on an interactive file descriptor causing your program to appear to hang.</source>
          <target state="translated">除了普通的数组索引循环外， &lt;code&gt;for&lt;/code&gt; 还可用于许多其他有趣的应用程序。如果您在交互式文件描述符上显式测试文件结束时导致程序看上去挂起，那么这可以避免您遇到的问题。</target>
        </trans-unit>
        <trans-unit id="b788aba9c107e5a4eaba0767ff3be57caf43c88d" translate="yes" xml:space="preserve">
          <source>Besides the obvious documents, source code can be instructive. Some pathological examples of the use of references can be found in the</source>
          <target state="translated">除了显而易见的文件外,源代码也是有指导意义的。一些使用参考资料的病态例子可以在《》中找到。</target>
        </trans-unit>
        <trans-unit id="3cd8fe6552552b50530c70ff871d9df229c4d203" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man also takes care of formatting func(), func(3), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; makes C++ look right, puts a little space between double underscores, makes ALLCAPS a teeny bit smaller in &lt;b&gt;troff&lt;/b&gt;, and escapes stuff that *roff treats as special so that you don't have to.</source>
          <target state="translated">除了明显的pod转换之外，Pod :: Man还负责格式化func（），func（3）以及$ foo或@bar之类的简单变量引用，因此您不必为它们使用代码转义符。不过，仍然需要转义 &lt;code&gt;$fred{'stuff'}&lt;/code&gt; 类的复杂表达式。它还会将不用作连字符的破折号转换为破折号，将长破折号（如此类）转换为适当的破折号，修复&amp;ldquo;成对的引号&amp;rdquo;，使C ++看起来正确，在双下划线之间留一点空格，使ALLCAPS &lt;b&gt;troff的&lt;/b&gt;小一些，并且转义了* roff认为特殊的东西，因此您不必这样做。</target>
        </trans-unit>
        <trans-unit id="5bb351a96d9e7856a11971d899903843a4ce13f1" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man, and therefore pod2man also takes care of formatting func(), func(n), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; and takes care of several other troff-specific tweaks. See &lt;a href=&quot;Pod::Man&quot;&gt;Pod::Man&lt;/a&gt; for complete information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a063aa374e8d2e7cef3baa1877fd812efaeadbc4" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man, and therefore pod2man also takes care of formatting func(), func(n), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; and takes care of several other troff-specific tweaks. See &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; for complete information.</source>
          <target state="translated">除了显而易见的pod转换之外，Pod :: Man和因此pod2man还负责格式化func（），func（n）以及$ foo或@bar之类的简单变量引用，因此您不必为其使用代码转义符; 不过，仍然需要转义 &lt;code&gt;$fred{'stuff'}&lt;/code&gt; 类的复杂表达式。它还将不用作连字符的破折号转换为破折号，将长破折号（如此类）转换为适当的破折号，修复&amp;ldquo;成对的引号&amp;rdquo;，并处理其他一些针对troff的调整。有关完整的信息，请参见&lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b7e5467e3e0ec9a6b2fff1ef3ee081c7b986017" translate="yes" xml:space="preserve">
          <source>Besides the well-known &quot;E&amp;lt;lt&amp;gt;&quot; and &quot;E&amp;lt;gt&amp;gt;&quot; codes for less-than and greater-than, Pod parsers must understand &quot;E&amp;lt;sol&amp;gt;&quot; for &quot;/&quot; (solidus, slash), and &quot;E&amp;lt;verbar&amp;gt;&quot; for &quot;|&quot; (vertical bar, pipe). Pod parsers should also understand &quot;E&amp;lt;lchevron&amp;gt;&quot; and &quot;E&amp;lt;rchevron&amp;gt;&quot; as legacy codes for characters 171 and 187, i.e., &quot;left-pointing double angle quotation mark&quot; = &quot;left pointing guillemet&quot; and &quot;right-pointing double angle quotation mark&quot; = &quot;right pointing guillemet&quot;. (These look like little &quot;&amp;lt;&amp;lt;&quot; and &quot;&amp;gt;&amp;gt;&quot;, and they are now preferably expressed with the HTML/XHTML codes &quot;E&amp;lt;laquo&amp;gt;&quot; and &quot;E&amp;lt;raquo&amp;gt;&quot;.)</source>
          <target state="translated">除了众所周知的小于和大于的&amp;ldquo; E &amp;lt;lt&amp;gt;&amp;rdquo;和&amp;ldquo; E &amp;lt;gt&amp;gt;&amp;rdquo;代码外，Pod解析器还必须将&amp;ldquo; /&amp;rdquo;（固线，斜杠）和&amp;ldquo; E &amp;lt;verbar&amp;gt;&amp;ldquo;代表&amp;rdquo; |&amp;ldquo; （垂直杆，管道）。 Pod解析器还应该将&amp;ldquo; E &amp;lt;lchevron&amp;gt;&amp;rdquo;和&amp;ldquo; E &amp;lt;rchevron&amp;gt;&amp;rdquo;理解为字符171和187的旧代码，即&amp;ldquo;左指向双角引号&amp;rdquo; =&amp;ldquo;左指向吉尔梅特&amp;rdquo;和&amp;ldquo;右指向双精度&amp;rdquo;角引号&amp;rdquo; =&amp;ldquo;右指向吉尔梅特&amp;rdquo;。 （这些看起来有点像&amp;ldquo; &amp;lt;&amp;lt;&amp;rdquo;和&amp;ldquo; &amp;gt;&amp;gt;&amp;rdquo;，现在最好用HTML / XHTML代码&amp;ldquo; E &amp;lt;laquo&amp;gt;&amp;rdquo;和&amp;ldquo; E &amp;lt;raquo&amp;gt;&amp;rdquo;表示。）</target>
        </trans-unit>
        <trans-unit id="860a34f94eb6573e4bc9c4a64ff033a99b23eda5" translate="yes" xml:space="preserve">
          <source>Besides these, all the Unicode character properties mentioned above (except for those marked as for internal use by Perl) are also accessible by &lt;a href=&quot;Unicode::UCD#prop_invlist%28%29&quot;&gt;&quot;prop_invlist()&quot; in Unicode::UCD&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2158802b148a274c615dff49ad8ceaf2fe4a86" translate="yes" xml:space="preserve">
          <source>Besides these, all the Unicode character properties mentioned above (except for those marked as for internal use by Perl) are also accessible by &lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;prop_invlist() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">除此之外，上述所有Unicode字符属性（Perl标记为供内部使用的那些字符属性除外）也可以通过&lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;Unicode :: UCD中的prop_invlist（）&lt;/a&gt;访问。</target>
        </trans-unit>
        <trans-unit id="708a3f784c168edb7cbbe1a181dbe5bffd40a3cc" translate="yes" xml:space="preserve">
          <source>Besides whole phrases meant for output, anything language-dependent should be put into the class Projname::L10N::en_us, whether as methods, or as lexicon entries -- this is discussed in the section &quot;Entries in Each Lexicon&quot;, above.</source>
          <target state="translated">除了用于输出的整个短语之外,任何与语言相关的东西都应该放在 Projname::L10N::en_us 类中,无论是作为方法,还是作为词典条目 --这在上面的 &quot;每个词典中的条目 &quot;一节中讨论。</target>
        </trans-unit>
        <trans-unit id="ab1d9532fa300263b037333b93fafef9210c8c57" translate="yes" xml:space="preserve">
          <source>Besides, I don't know how to write the damned things.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd7916b96afe381cf04fb2aeca341eed5cca3a69" translate="yes" xml:space="preserve">
          <source>Best practices for making a new module.</source>
          <target state="translated">制作新模块的最佳做法。</target>
        </trans-unit>
        <trans-unit id="ae28545952ad516171bc8541be8a3d6e7dcf583f" translate="yes" xml:space="preserve">
          <source>Better diagnostics capabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d4f16c5fc7da807c79c20a2575508b93d90392" translate="yes" xml:space="preserve">
          <source>Between &lt;code&gt;pairs&lt;/code&gt; and &lt;code&gt;unpairs&lt;/code&gt;, a higher-order list function can be used to operate on the pairs as single scalars; such as the following near-equivalents of the other &lt;code&gt;pair*&lt;/code&gt; higher-order functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9760622e022594213ec306985fb05bd7325740" translate="yes" xml:space="preserve">
          <source>Between Mac OS X 10.3 &quot;Panther&quot; and 10.6 &quot;Snow Leopard&quot;, the 'Command Line Tools' bundle was called 'unix tools', and was usually supplied with Mac OS install DVDs.</source>
          <target state="translated">在Mac OS X 10.3 &quot;Panther &quot;和10.6 &quot;Snow Leopard &quot;之间,&quot;命令行工具 &quot;包被称为 &quot;unix工具&quot;,通常与Mac OS安装DVD一起提供。</target>
        </trans-unit>
        <trans-unit id="6249e6fb239ee6aed11ccf460f154f4ff6f24738" translate="yes" xml:space="preserve">
          <source>Between the &lt;code&gt;%&lt;/code&gt; and the format letter, you may specify several additional attributes controlling the interpretation of the format. In order, these are:</source>
          <target state="translated">在 &lt;code&gt;%&lt;/code&gt; 和格式字母之间，您可以指定几个其他属性来控制格式的解释。这些是：</target>
        </trans-unit>
        <trans-unit id="b8011f36b2088bc97398915695cf8abfb01b5b1d" translate="yes" xml:space="preserve">
          <source>Beware also of the order of more complicated expressions like:</source>
          <target state="translated">还要注意比较复杂的表达方式的顺序,比如。</target>
        </trans-unit>
        <trans-unit id="6cfef1757642ae2cc2b58e48199cf1ffe99563dc" translate="yes" xml:space="preserve">
          <source>Beware of casting the entire expression, as this would cast the result, at which point it is too late:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c100dc724a3253ddc31a97cdb43e9fdb264b604" translate="yes" xml:space="preserve">
          <source>Beware of simple &quot;casting&quot; the entire expression, this would only convert the already computed result:</source>
          <target state="translated">小心简单的 &quot;投掷 &quot;整个表达式,这样只会转换已经计算好的结果。</target>
        </trans-unit>
        <trans-unit id="993aa75891c2224a1f9c297f58bf1ffa758e779f" translate="yes" xml:space="preserve">
          <source>Beware of the &quot;else syndrome&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a9c3aa0cee4b1c15e1e5a6a65e3ca3cde192e4e" translate="yes" xml:space="preserve">
          <source>Beware of using &lt;code&gt;&quot;$&quot;&lt;/code&gt; to indicate to match the end of the string. It can too easily be interpreted as being a punctuation variable, like &lt;code&gt;$/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8bc77265aea976e7b646f3af43c05662f7e17da" translate="yes" xml:space="preserve">
          <source>Beware of:</source>
          <target state="translated">小心:</target>
        </trans-unit>
        <trans-unit id="6bac55531c21ad380bc95de89addf1faea92b643" translate="yes" xml:space="preserve">
          <source>Beware that if you put literal backslashes (those not inside interpolated variables) between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; , double-quotish backslash interpolation may lead to confusing results. If you</source>
          <target state="translated">请注意，如果在 &lt;code&gt;\Q&lt;/code&gt; 和 &lt;code&gt;\E&lt;/code&gt; 之间放置文字反斜杠（那些不在插入变量内），则双引号反斜杠插值可能会导致混淆。如果你</target>
        </trans-unit>
        <trans-unit id="eebfc88db53433dbd95a0208b9c35bedb078dc7e" translate="yes" xml:space="preserve">
          <source>Beware that if you put literal backslashes (those not inside interpolated variables) between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt;, double-quotish backslash interpolation may lead to confusing results. If you</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5349c42e3fc571db11577ff5f6cb8d88af8429b8" translate="yes" xml:space="preserve">
          <source>Beware that in a UTF-8 locale, anything you pass to this function must be in UTF-8; and when not in a UTF-8 locale, anything passed must not be UTF-8 encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca66f864461fdc36869edeb4abd6935993616b0" translate="yes" xml:space="preserve">
          <source>Beware that some command shells may place restrictions on the length of the command line. You must ensure your strings don't exceed this limit after any necessary interpolations. See the platform-specific release notes for more details about your particular environment.</source>
          <target state="translated">请注意,一些命令壳可能会对命令行的长度进行限制。你必须确保你的字符串在进行任何必要的插值后不超过这个限制。关于你的特定环境的更多细节,请参见特定平台的发布说明。</target>
        </trans-unit>
        <trans-unit id="9cd8d5856a80822f4c1d90c9c02e95de943bc843" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#join-EXPR%2CLIST&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd1204f447158c3ff1bfbe82d9a707a81d4fa56" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;#split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">注意，与 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 不会将模式作为其第一个参数。比较&lt;a href=&quot;#split&quot;&gt;split&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc2144e8f71ac4bf9140995eea7dc924e6bdda59" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">注意，与 &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 不会将模式作为其第一个参数。比较&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c39aa460c8cfb8c3295132732d48ee06e763b200" translate="yes" xml:space="preserve">
          <source>Beware: This feature is not fully implemented yet.</source>
          <target state="translated">小心。这个功能还没有完全实现。</target>
        </trans-unit>
        <trans-unit id="d3f2ff6e4b3a254c248f8c186f3f0868a1b1e7b1" translate="yes" xml:space="preserve">
          <source>Beware: This list is not complete.</source>
          <target state="translated">小心。这个名单并不完整。</target>
        </trans-unit>
        <trans-unit id="85c248dc6ba19bfc8397a2d612c997c46ad24985" translate="yes" xml:space="preserve">
          <source>Beware: after this function returns, &lt;code&gt;ptr&lt;/code&gt; and SvPVX_const(sv) may no longer refer to the same chunk of data.</source>
          <target state="translated">当心：此函数返回后， &lt;code&gt;ptr&lt;/code&gt; 和SvPVX_const（sv）可能不再引用同一数据块。</target>
        </trans-unit>
        <trans-unit id="40ca4e03748bbc6d9d8fdf7c985dd464c29b4a02" translate="yes" xml:space="preserve">
          <source>Beyond Unicode code points</source>
          <target state="translated">超越Unicode码点</target>
        </trans-unit>
        <trans-unit id="8d2086dee2d46aa5a491374a05ac5325e10530d7" translate="yes" xml:space="preserve">
          <source>Beyond make test</source>
          <target state="translated">超越测试</target>
        </trans-unit>
        <trans-unit id="16881dc1b286f9fd89e3c68a1307509ea4208790" translate="yes" xml:space="preserve">
          <source>Beyond raw access to the API calls and related constants, this module handles smart buffer allocation and translation of return codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7071855c582934ec0ec68ba51cead15591289a64" translate="yes" xml:space="preserve">
          <source>Beyond that help, the urllist config parameter is yours. You can add and remove sites at will. You should find out which sites have the best up-to-dateness, bandwidth, reliability, etc. and are topologically close to you. Some people prefer fast downloads, others up-to-dateness, others reliability. You decide which to try in which order.</source>
          <target state="translated">除了这些帮助,urllist配置参数就是你的了。你可以随意添加和删除站点。你应该找出哪些网站的更新速度、带宽、可靠性等都是最好的,并且在拓扑上离你很近。有些人喜欢快速下载,有些人喜欢最新的,有些人喜欢可靠性。你决定按哪种顺序去尝试。</target>
        </trans-unit>
        <trans-unit id="3f05839b089d755d215e2ff3af4aafe1ec68679d" translate="yes" xml:space="preserve">
          <source>Beyond that, the simplest debugger is the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function. Use it to look at values as you run your program:</source>
          <target state="translated">除此之外，最简单的调试器是 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 功能。在运行程序时使用它查看值：</target>
        </trans-unit>
        <trans-unit id="cc8c0bdbbf061aa1132ad0db52bd5ab409c1d5c4" translate="yes" xml:space="preserve">
          <source>Beyond that, the simplest debugger is the &lt;code&gt;print&lt;/code&gt; function. Use it to look at values as you run your program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3981fa65dd4a5a67077c84cbcab0e6d7e62ef4b1" translate="yes" xml:space="preserve">
          <source>Beyond that, you have to consider several things and decide which is best for you.</source>
          <target state="translated">除此之外,你还要考虑几件事,并决定哪件事情最适合你。</target>
        </trans-unit>
        <trans-unit id="44d69eda49b459248ce90b6917e4f918be54d8d4" translate="yes" xml:space="preserve">
          <source>Beyond the normal measures described to make general Perl programs faster or smaller, a CGI program has additional issues. It may be run several times per second. Given that each time it runs it will need to be re-compiled and will often allocate a megabyte or more of system memory, this can be a killer. Compiling into C &lt;b&gt;isn't going to help you&lt;/b&gt; because the process start-up overhead is where the bottleneck is.</source>
          <target state="translated">除了描述的使一般Perl程序更快或更小的常规措施之外，CGI程序还存在其他问题。它可能每秒运行几次。考虑到每次运行它都需要重新编译，并且通常会分配一兆字节或更多的系统内存，这可能是一个杀手.。编译为C &lt;b&gt;不会对您有帮助，&lt;/b&gt;因为过程启动开销是瓶颈所在。</target>
        </trans-unit>
        <trans-unit id="213d672c8ec1c5c132adb8f810eb6a5d6ae1c84f" translate="yes" xml:space="preserve">
          <source>Beyond the obvious problems that stem from giving special privileges to systems as flexible as scripts, on many versions of Unix, set-id scripts are inherently insecure right from the start. The problem is a race condition in the kernel. Between the time the kernel opens the file to see which interpreter to run and when the (now-set-id) interpreter turns around and reopens the file to interpret it, the file in question may have changed, especially if you have symbolic links on your system.</source>
          <target state="translated">除了赋予系统像脚本一样灵活的特殊权限所产生的明显问题之外,在许多版本的Unix上,set-id脚本从一开始就是不安全的。问题是内核中的一个竞赛条件。从内核打开文件看看要运行哪个解释器,到(现在的set-id)解释器转过身来重新打开文件进行解释,这段时间里,文件可能已经发生了变化,尤其是当你的系统上有符号链接的时候。</target>
        </trans-unit>
        <trans-unit id="cfa5b349eaf3622485b4949d5b4c1629b7136aa6" translate="yes" xml:space="preserve">
          <source>BhkDISABLE</source>
          <target state="translated">BhkDISABLE</target>
        </trans-unit>
        <trans-unit id="097eaa76fb990cb3c085617a09bb68f2d2dd28d0" translate="yes" xml:space="preserve">
          <source>BhkENABLE</source>
          <target state="translated">BhkENABLE</target>
        </trans-unit>
        <trans-unit id="56657a5c49e88295c9fdbd426498620306255970" translate="yes" xml:space="preserve">
          <source>BhkENTRY</source>
          <target state="translated">BhkENTRY</target>
        </trans-unit>
        <trans-unit id="eed78c8324c929e21a7725f018dc13f233941d2d" translate="yes" xml:space="preserve">
          <source>BhkENTRY_set</source>
          <target state="translated">BhkENTRY_set</target>
        </trans-unit>
        <trans-unit id="6303b515a179b4880dfa9b0c5bdeef24554d4d0d" translate="yes" xml:space="preserve">
          <source>BhkFLAGS</source>
          <target state="translated">BhkFLAGS</target>
        </trans-unit>
        <trans-unit id="619d65e1ae1a2704aa306451ac2a75a0cde345a8" translate="yes" xml:space="preserve">
          <source>Bibliography</source>
          <target state="translated">Bibliography</target>
        </trans-unit>
        <trans-unit id="c81d74ec4f5774b83707b81c40273f9931cc6799" translate="yes" xml:space="preserve">
          <source>BidiCharacterTest.txt</source>
          <target state="translated">BidiCharacterTest.txt</target>
        </trans-unit>
        <trans-unit id="69ecda50c93df6838e91e9e521a5ea42b19e7e09" translate="yes" xml:space="preserve">
          <source>BidiTest.txt</source>
          <target state="translated">BidiTest.txt</target>
        </trans-unit>
        <trans-unit id="603c926318562657586c9e1146fc9dbe3c25c988" translate="yes" xml:space="preserve">
          <source>Bidirectional Character Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4412d2ae1aa691608b316e9ad2227f4c8f05c5f" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Another Process</source>
          <target state="translated">与另一进程的双向通信</target>
        </trans-unit>
        <trans-unit id="20453df9f611f7ce81199fe2171f3b15f7db6ba1" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Yourself</source>
          <target state="translated">与自己的双向沟通</target>
        </trans-unit>
        <trans-unit id="de1698114af4355c5ccd60424049fded636df6a2" translate="yes" xml:space="preserve">
          <source>Big5</source>
          <target state="translated">Big5</target>
        </trans-unit>
        <trans-unit id="aaec1a206ed8540735d6653165ead4690d690a5c" translate="yes" xml:space="preserve">
          <source>BigInt's bcmp() routine currently returns undef to signal that a NaN was involved in a comparison. However, the overload code turns that into either 1 or '' and thus operations like &lt;code&gt;NaN != NaN&lt;/code&gt; might return wrong values.</source>
          <target state="translated">BigInt的bcmp（）例程当前返回undef，以表示比较中涉及NaN。但是，重载代码将其变为1或&amp;rdquo;，因此 &lt;code&gt;NaN != NaN&lt;/code&gt; 可能返回错误的值。</target>
        </trans-unit>
        <trans-unit id="b68a65a4af953b7e6ff32f4e519ad10e0c7af47b" translate="yes" xml:space="preserve">
          <source>Bigger Numbers</source>
          <target state="translated">更大的数字</target>
        </trans-unit>
        <trans-unit id="98032da695f3e799620752e98882e414e0196f49" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!=&quot;&lt;/code&gt; returns true if the left argument is numerically not equal to the right argument.</source>
          <target state="translated">如果左参数在数值上不等于右参数，则二进制 &lt;code&gt;&quot;!=&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="0806ad998452d5851f139bbe3f01d7066c39cefd" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; is just like &lt;code&gt;&quot;=~&quot;&lt;/code&gt; except the return value is negated in the logical sense.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;!~&quot;&lt;/code&gt; 类似于 &lt;code&gt;&quot;=~&quot;&lt;/code&gt; 只是返回值在逻辑上取反。</target>
        </trans-unit>
        <trans-unit id="958b8a1169468f4a63917c7ca8496d2c631c8da0" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; with a non-destructive substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt;) or transliteration (&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt;) is a syntax error.</source>
          <target state="translated">具有无损替换（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; ）或音译（ &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt; ）的二进制 &lt;code&gt;&quot;!~&quot;&lt;/code&gt; 是语法错误。</target>
        </trans-unit>
        <trans-unit id="669b5730a4de160e3201236f63831582ab97b4ad" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; with a non-destructive substitution (&lt;code&gt;s///r&lt;/code&gt;) or transliteration (&lt;code&gt;y///r&lt;/code&gt;) is a syntax error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26c16627064dbaf94b2accf763da8c7ea571aa3" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;%&quot;&lt;/code&gt; is the modulo operator, which computes the division remainder of its first argument with respect to its second argument. Given integer operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; : If &lt;code&gt;$n&lt;/code&gt; is positive, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the largest multiple of &lt;code&gt;$n&lt;/code&gt; less than or equal to &lt;code&gt;$m&lt;/code&gt; . If &lt;code&gt;$n&lt;/code&gt; is negative, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the smallest multiple of &lt;code&gt;$n&lt;/code&gt; that is not less than &lt;code&gt;$m&lt;/code&gt; (that is, the result will be less than or equal to zero). If the operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; are floating point values and the absolute value of &lt;code&gt;$n&lt;/code&gt; (that is &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is less than &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , only the integer portion of &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; will be used in the operation (Note: here &lt;code&gt;UV_MAX&lt;/code&gt; means the maximum of the unsigned integer type). If the absolute value of the right operand (&lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is greater than or equal to &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; computes the floating-point remainder &lt;code&gt;$r&lt;/code&gt; in the equation &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; where &lt;code&gt;$i&lt;/code&gt; is a certain integer that makes &lt;code&gt;$r&lt;/code&gt; have the same sign as the right operand &lt;code&gt;$n&lt;/code&gt; (&lt;b&gt;not&lt;/b&gt; as the left operand &lt;code&gt;$m&lt;/code&gt; like C function &lt;code&gt;fmod()&lt;/code&gt; ) and the absolute value less than that of &lt;code&gt;$n&lt;/code&gt; . Note that when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; is in scope, &lt;code&gt;&quot;%&quot;&lt;/code&gt; gives you direct access to the modulo operator as implemented by your C compiler. This operator is not as well defined for negative operands, but it will execute faster.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;%&quot;&lt;/code&gt; 是取模运算符，它计算第一个参数相对于第二个参数的除法余数。给定整数操作数 &lt;code&gt;$m&lt;/code&gt; 和 &lt;code&gt;$n&lt;/code&gt; ：如果 &lt;code&gt;$n&lt;/code&gt; 为正数，则 &lt;code&gt;$m % $n&lt;/code&gt; 为 &lt;code&gt;$m&lt;/code&gt; 减去 &lt;code&gt;$n&lt;/code&gt; 的最大倍数小于或等于 &lt;code&gt;$m&lt;/code&gt; 。如果 &lt;code&gt;$n&lt;/code&gt; 为负，则 &lt;code&gt;$m % $n&lt;/code&gt; 为 &lt;code&gt;$m&lt;/code&gt; 减去 &lt;code&gt;$n&lt;/code&gt; 的不小于 &lt;code&gt;$m&lt;/code&gt; 的最小倍数（也就是说，结果将小于或等于零）。如果操作数 &lt;code&gt;$m&lt;/code&gt; 和 &lt;code&gt;$n&lt;/code&gt; 是浮点值，并且 &lt;code&gt;$n&lt;/code&gt; 的绝对值（即 &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; ）小于 &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; ，操作中仅使用 &lt;code&gt;$m&lt;/code&gt; 和 &lt;code&gt;$n&lt;/code&gt; 的整数部分（注意：此处 &lt;code&gt;UV_MAX&lt;/code&gt; 表示无符号整数类型的最大值）。如果右操作数的绝对值（ &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; ）大于或等于 &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; ，则 &lt;code&gt;&quot;%&quot;&lt;/code&gt; 将计算公式中的浮点余数 &lt;code&gt;$r&lt;/code&gt; &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; 其中 &lt;code&gt;$i&lt;/code&gt; 是使 &lt;code&gt;$r&lt;/code&gt; 与右操作数具有相同符号的特定整数 &lt;code&gt;$n&lt;/code&gt; （&lt;b&gt;不&lt;/b&gt;作为左操作数 &lt;code&gt;$m&lt;/code&gt; 象C函数 &lt;code&gt;fmod()&lt;/code&gt; ）和绝对值小于的 &lt;code&gt;$n&lt;/code&gt; 。请注意，当在范围内 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 时， &lt;code&gt;&quot;%&quot;&lt;/code&gt; 使您可以直接访问由C编译器实现的模运算符。没有为负操作数定义此运算符，但执行速度更快。</target>
        </trans-unit>
        <trans-unit id="41e316d0ff24f3ca1a3464d44861dfcd88d324d8" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;%&quot;&lt;/code&gt; is the modulo operator, which computes the division remainder of its first argument with respect to its second argument. Given integer operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt;: If &lt;code&gt;$n&lt;/code&gt; is positive, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the largest multiple of &lt;code&gt;$n&lt;/code&gt; less than or equal to &lt;code&gt;$m&lt;/code&gt;. If &lt;code&gt;$n&lt;/code&gt; is negative, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the smallest multiple of &lt;code&gt;$n&lt;/code&gt; that is not less than &lt;code&gt;$m&lt;/code&gt; (that is, the result will be less than or equal to zero). If the operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; are floating point values and the absolute value of &lt;code&gt;$n&lt;/code&gt; (that is &lt;code&gt;abs($n)&lt;/code&gt;) is less than &lt;code&gt;(UV_MAX + 1)&lt;/code&gt;, only the integer portion of &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; will be used in the operation (Note: here &lt;code&gt;UV_MAX&lt;/code&gt; means the maximum of the unsigned integer type). If the absolute value of the right operand (&lt;code&gt;abs($n)&lt;/code&gt;) is greater than or equal to &lt;code&gt;(UV_MAX + 1)&lt;/code&gt;, &lt;code&gt;&quot;%&quot;&lt;/code&gt; computes the floating-point remainder &lt;code&gt;$r&lt;/code&gt; in the equation &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; where &lt;code&gt;$i&lt;/code&gt; is a certain integer that makes &lt;code&gt;$r&lt;/code&gt; have the same sign as the right operand &lt;code&gt;$n&lt;/code&gt; (&lt;b&gt;not&lt;/b&gt; as the left operand &lt;code&gt;$m&lt;/code&gt; like C function &lt;code&gt;fmod()&lt;/code&gt;) and the absolute value less than that of &lt;code&gt;$n&lt;/code&gt;. Note that when &lt;code&gt;use integer&lt;/code&gt; is in scope, &lt;code&gt;&quot;%&quot;&lt;/code&gt; gives you direct access to the modulo operator as implemented by your C compiler. This operator is not as well defined for negative operands, but it will execute faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a326cd0bd8e1d3d414fab02e5019eeeb66d4b5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; returns its operands ANDed together bit by bit. Although no warning is currently raised, the result is not well defined when this operation is performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68ed9e30d3d6543dd0a9f75b291cbc79357b65a9" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; returns its operands ANDed together bit by bit. Although no warning is currently raised, the result is not well defined when this operation is performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;).</source>
          <target state="translated">二进制 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 返回其操作数，并一点一点地相加在一起。尽管当前未发出警告，但是当对既不是数字（请参阅&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;）又不是&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;位字符串&lt;/a&gt;（请参阅按位字符串运算符）的操作数执行此操作时，结果定义不明确。</target>
        </trans-unit>
        <trans-unit id="c0937405123294a033856c6fea7344af89470f86" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; performs a short-circuit logical AND operation. That is, if the left operand is false, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; 执行短路逻辑&amp;ldquo;与&amp;rdquo;运算。也就是说，如果左操作数为false，则甚至不会评估右操作数。如果评估标量或列表上下文，则向下传播到正确的操作数。</target>
        </trans-unit>
        <trans-unit id="1f3f00bc4d3f1107e73b1aeb90803d21d2f7f5a5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; returns true if the left argument is numerically greater than the right argument.</source>
          <target state="translated">如果左参数在数值上大于右参数，则Binary &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="7b8b841de5eb99d0ccb88b329de6ee433524b771" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; returns the value of its left argument shifted right by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8e5f64ce960724d668657e4a1ad5261d933577" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; returns the value of its left argument shifted right by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;.)</source>
          <target state="translated">二进制 &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 返回其左参数的值，该值向右偏移右参数指定的位数。参数应为整数。（另请参阅&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;整数算术&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="9de554883aaffe5a62d4c8a36deea3a837fcd80d" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; returns true if the left argument is numerically greater than or equal to the right argument.</source>
          <target state="translated">如果左参数在数值上大于或等于右参数，则Binary &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="a7454742c96c82ff2ca0ce93cf67bcd19286a557" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; returns true if the left argument is numerically less than the right argument.</source>
          <target state="translated">如果左参数在数值上小于右参数，则二进制 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="699e70a5fa87498319583ad7600759912b343d42" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; returns the value of its left argument shifted left by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d03b55098c5e945a6cff21988ea84460d71573" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; returns the value of its left argument shifted left by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;.)</source>
          <target state="translated">二进制 &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; 返回其左参数的值，该值左移右参数指定的位数。参数应为整数。（另请参阅&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;整数算术&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="b5e75cae74350bd47fe89e9c43a86148805f25b1" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; returns true if the left argument is numerically less than or equal to the right argument.</source>
          <target state="translated">如果左参数在数值上小于或等于右参数，则二进制 &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="c4b96fdd4c2b42fee6d143e7f60bc5e53b9a1f53" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is numerically less than, equal to, or greater than the right argument. If your platform supports &lt;code&gt;NaN&lt;/code&gt; 's (not-a-numbers) as numeric values, using them with &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns undef. &lt;code&gt;NaN&lt;/code&gt; is not &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;==&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; or &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; anything (even &lt;code&gt;NaN&lt;/code&gt; ), so those 5 return false. &lt;code&gt;NaN != NaN&lt;/code&gt; returns true, as does &lt;code&gt;NaN !=&lt;/code&gt;</source>
          <target state="translated">二进制 &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; 返回-1、0或1，具体取决于左参数在数值上小于，等于还是大于右参数。如果您的平台支持 &lt;code&gt;NaN&lt;/code&gt; （非数字）作为数值，则将它们与 &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; 将返回undef。 &lt;code&gt;NaN&lt;/code&gt; 不是 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; ， &lt;code&gt;&quot;==&quot;&lt;/code&gt; ， &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; ， &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; 任何东西（甚至是 &lt;code&gt;NaN&lt;/code&gt; ），因此那5返回false。 &lt;code&gt;NaN != NaN&lt;/code&gt; 返回true， &lt;code&gt;NaN !=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac04a45698769168d1350bede297cc638685f279" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is numerically less than, equal to, or greater than the right argument. If your platform supports &lt;code&gt;NaN&lt;/code&gt;'s (not-a-numbers) as numeric values, using them with &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns undef. &lt;code&gt;NaN&lt;/code&gt; is not &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt;, &lt;code&gt;&quot;==&quot;&lt;/code&gt;, &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt;, &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; or &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; anything (even &lt;code&gt;NaN&lt;/code&gt;), so those 5 return false. &lt;code&gt;NaN != NaN&lt;/code&gt; returns true, as does &lt;code&gt;NaN !=&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d0148c51849abf03e9b94e765faa605e272cbf6" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;*&quot;&lt;/code&gt; multiplies two numbers.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 将两个数字相乘。</target>
        </trans-unit>
        <trans-unit id="01756f918936276dfa8f0de39e3d878d679ba39b" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;**&quot;&lt;/code&gt; is the exponentiation operator. It binds even more tightly than unary minus, so &lt;code&gt;-2**4&lt;/code&gt; is &lt;code&gt;-(2**4)&lt;/code&gt; , not &lt;code&gt;(-2)**4&lt;/code&gt; . (This is implemented using C's &lt;code&gt;pow(3)&lt;/code&gt; function, which actually works on doubles internally.)</source>
          <target state="translated">二进制 &lt;code&gt;&quot;**&quot;&lt;/code&gt; 是幂运算符。它的绑定比一元负数更紧密，因此 &lt;code&gt;-2**4&lt;/code&gt; 是 &lt;code&gt;-(2**4)&lt;/code&gt; ，而不是 &lt;code&gt;(-2)**4&lt;/code&gt; 。（这是使用C的 &lt;code&gt;pow(3)&lt;/code&gt; 函数实现的，该函数实际上在内部对double起作用。）</target>
        </trans-unit>
        <trans-unit id="ea1f5488b58109753bdbb42f40a1d426d3469962" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;**&quot;&lt;/code&gt; is the exponentiation operator. It binds even more tightly than unary minus, so &lt;code&gt;-2**4&lt;/code&gt; is &lt;code&gt;-(2**4)&lt;/code&gt;, not &lt;code&gt;(-2)**4&lt;/code&gt;. (This is implemented using C's &lt;code&gt;pow(3)&lt;/code&gt; function, which actually works on doubles internally.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e565dc6efc9becadb2f620e3b56356ece28d9ea9" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;+&quot;&lt;/code&gt; returns the sum of two numbers.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 返回两个数字的和。</target>
        </trans-unit>
        <trans-unit id="d264c2219fd49edff5b7c850ac6db5ce0ccf6345" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;,&quot;&lt;/code&gt; is the comma operator. In scalar context it evaluates its left argument, throws that value away, then evaluates its right argument and returns that value. This is just like C's comma operator.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;,&quot;&lt;/code&gt; 是逗号运算符。在标量上下文中，它评估其左自变量，将该值丢弃，然后评估其右自变量并返回该值。就像C的逗号运算符一样。</target>
        </trans-unit>
        <trans-unit id="afc59f330a0626c101e37690bb504039ec265210" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;-&quot;&lt;/code&gt; returns the difference of two numbers.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 返回两个数字的差。</target>
        </trans-unit>
        <trans-unit id="843c8445f5431d5cdfeffedb703a08e101bb0fa7" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;.&quot;&lt;/code&gt; concatenates two strings.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 连接两个字符串。</target>
        </trans-unit>
        <trans-unit id="20b0ad876d72e0a4e92413d3b855b37c16cdc3ee" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;..&quot;&lt;/code&gt; is the range operator, which is really two different operators depending on the context. In list context, it returns a list of values counting (up by ones) from the left value to the right value. If the left value is greater than the right value then it returns the empty list. The range operator is useful for writing &lt;code&gt;foreach (1..10)&lt;/code&gt; loops and for doing slice operations on arrays. In the current implementation, no temporary array is created when the range operator is used as the expression in &lt;code&gt;foreach&lt;/code&gt; loops, but older versions of Perl might burn a lot of memory when you write something like this:</source>
          <target state="translated">二进制 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 是范围运算符，根据上下文，它实际上是两个不同的运算符。在列表上下文中，它返回从左值到右值计数（逐个递增）的值列表。如果左值大于右值，则返回空列表。范围运算符对于编写 &lt;code&gt;foreach (1..10)&lt;/code&gt; 循环以及对数组执行切片操作很有用。在当前的实现中，当将range运算符用作 &lt;code&gt;foreach&lt;/code&gt; 循环中的表达式时，不会创建任何临时数组，但是当您编写如下代码时，较旧版本的Perl可能会消耗大量内存：</target>
        </trans-unit>
        <trans-unit id="11d1e4ec8e23351f5601e3a5d4e0c431e5c430e4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;/&quot;&lt;/code&gt; divides two numbers.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 将两个数字相除。</target>
        </trans-unit>
        <trans-unit id="f0b12adb8c84721a8d6934894abc35e4121a8c82" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;==&quot;&lt;/code&gt; returns true if the left argument is numerically equal to the right argument.</source>
          <target state="translated">如果左参数在数值上等于右参数，则二进制 &lt;code&gt;&quot;==&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="e8178e90952cecccc1b319f7d1d8a9d3454e685e" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;=~&quot;&lt;/code&gt; binds a scalar expression to a pattern match. Certain operations search or modify the string &lt;code&gt;$_&lt;/code&gt; by default. This operator makes that kind of operation work on some other string. The right argument is a search pattern, substitution, or transliteration. The left argument is what is supposed to be searched, substituted, or transliterated instead of the default &lt;code&gt;$_&lt;/code&gt; . When used in scalar context, the return value generally indicates the success of the operation. The exceptions are substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;) and transliteration (&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) with the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option, which cause the &lt;b&gt;r&lt;/b&gt;eturn value to be the result of the substitution. Behavior in list context depends on the particular operator. See &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators&lt;/a&gt; for details and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; for examples using these operators.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;=~&quot;&lt;/code&gt; 将标量表达式绑定到模式匹配。某些操作默认情况下会搜索或修改字符串 &lt;code&gt;$_&lt;/code&gt; 。该运算符使这种运算对其他字符串起作用。正确的参数是搜索模式，替换或音译。左参数是应该被搜索，替换或音译的东西，而不是默认的 &lt;code&gt;$_&lt;/code&gt; 。在标量环境中使用时，返回值通常表示操作成功。例外的是取代度（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ）和音译（ &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ）与 &lt;code&gt;/r&lt;/code&gt; （非破坏性）选项，该选项使&lt;b&gt;ř&lt;/b&gt;返回值是替换的结果。列表上下文中的行为取决于特定的运算符。有关详细信息，请参见&lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;Regexp类引用运算符&lt;/a&gt;；有关使用这些运算符的示例，请参见&lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="79a4495643878d498724e64ed7f89a0f4674d534" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;=~&quot;&lt;/code&gt; binds a scalar expression to a pattern match. Certain operations search or modify the string &lt;code&gt;$_&lt;/code&gt; by default. This operator makes that kind of operation work on some other string. The right argument is a search pattern, substitution, or transliteration. The left argument is what is supposed to be searched, substituted, or transliterated instead of the default &lt;code&gt;$_&lt;/code&gt;. When used in scalar context, the return value generally indicates the success of the operation. The exceptions are substitution (&lt;code&gt;s///&lt;/code&gt;) and transliteration (&lt;code&gt;y///&lt;/code&gt;) with the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option, which cause the &lt;b&gt;r&lt;/b&gt;eturn value to be the result of the substitution. Behavior in list context depends on the particular operator. See &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot;&lt;/a&gt; for details and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; for examples using these operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa78120f553c43180d2a32604d493af25ed233d4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;^&quot;&lt;/code&gt; returns its operands XORed together bit by bit.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 将其操作数逐位异或在一起。</target>
        </trans-unit>
        <trans-unit id="671e2c4625e970e48a9399520aaa4fa28b907022" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;and&quot;&lt;/code&gt; returns the logical conjunction of the two surrounding expressions. It's equivalent to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; except for the very low precedence. This means that it short-circuits: the right expression is evaluated only if the left expression is true.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;and&quot;&lt;/code&gt; 返回两个周围表达式的逻辑结合。它的优先级非常低，与 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 等效。这意味着它短路：仅当左表达式为true时，才对右表达式求值。</target>
        </trans-unit>
        <trans-unit id="d3c04971ab5e03274c19bebb1ecd8b4175eeef29" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is stringwise less than, equal to, or greater than the right argument.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; 返回-1、0或1，具体取决于左参数是按字符串方式小于，等于还是大于右参数。</target>
        </trans-unit>
        <trans-unit id="1aa12faad44cec6a4de324dfb2d0d28e5041c165" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;eq&quot;&lt;/code&gt; returns true if the left argument is stringwise equal to the right argument.</source>
          <target state="translated">如果左参数在字符串上等于右参数，则二进制 &lt;code&gt;&quot;eq&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="72766e64c0f2ce882d1581bc9a5363e487361650" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;ge&quot;&lt;/code&gt; returns true if the left argument is stringwise greater than or equal to the right argument.</source>
          <target state="translated">如果左参数在字符串上大于或等于右参数，则二进制 &lt;code&gt;&quot;ge&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="8cbbb7f7848eee7ea44e5adae43d5c8ad553b087" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;gt&quot;&lt;/code&gt; returns true if the left argument is stringwise greater than the right argument.</source>
          <target state="translated">如果左参数在字符串上大于右参数，则二进制 &lt;code&gt;&quot;gt&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="cbde6b024ab1e652daab583508091dcc611a1886" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;le&quot;&lt;/code&gt; returns true if the left argument is stringwise less than or equal to the right argument.</source>
          <target state="translated">如果左参数在字符串上小于或等于右参数，则二进制 &lt;code&gt;&quot;le&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="98038977bb137332bb318c163315bf5cd770bdda" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;lt&quot;&lt;/code&gt; returns true if the left argument is stringwise less than the right argument.</source>
          <target state="translated">如果左参数在字符串上小于右参数，则二进制 &lt;code&gt;&quot;lt&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="3426ef0b6b1032306f9e34d92f3217cb3cb8f9b5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;ne&quot;&lt;/code&gt; returns true if the left argument is stringwise not equal to the right argument.</source>
          <target state="translated">如果左参数沿字符串方向不等于右参数，则二进制 &lt;code&gt;&quot;ne&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="6e48afc6b41691d3b8112c62d6f3d75de7761a17" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;or&quot;&lt;/code&gt; returns the logical disjunction of the two surrounding expressions. It's equivalent to &lt;code&gt;||&lt;/code&gt; except for the very low precedence. This makes it useful for control flow:</source>
          <target state="translated">二进制 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 返回两个周围表达式的逻辑和。相当于 &lt;code&gt;||&lt;/code&gt; 除了非常低的优先级。这对于控制流很有用：</target>
        </trans-unit>
        <trans-unit id="6eadcc721bf945b4975372194a62fd2f4732fb22" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;x&quot;&lt;/code&gt; is the repetition operator. In scalar context or if the left operand is not enclosed in parentheses, it returns a string consisting of the left operand repeated the number of times specified by the right operand. In list context, if the left operand is enclosed in parentheses or is a list formed by &lt;code&gt;qw/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt;, it repeats the list. If the right operand is zero or negative (raising a warning on negative), it returns an empty string or an empty list, depending on the context.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 是重复运算符。在标量上下文中，或者如果左操作数未括在括号中，则它将返回由左操作数组成的字符串，该字符串重复右操作数指定的次数。在列表上下文中，如果左操作数用括号括起来或是由 &lt;code&gt;qw/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt; 的列表，则它会重复该列表。如果右操作数为零或负（在负数时发出警告），则根据上下文返回空字符串或空列表。</target>
        </trans-unit>
        <trans-unit id="9999af54fad183fd5d0cedce55d894dad6f9d4fe" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;xor&quot;&lt;/code&gt; returns the exclusive-OR of the two surrounding expressions. It cannot short-circuit (of course).</source>
          <target state="translated">二进制 &lt;code&gt;&quot;xor&quot;&lt;/code&gt; 返回两个周围表达式的异或。它不能短路（当然）。</target>
        </trans-unit>
        <trans-unit id="878a38ea354402b8caaeaced244837f05ba0dd57" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;|&quot;&lt;/code&gt; returns its operands ORed together bit by bit.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 返回其操作数进行逐位或运算。</target>
        </trans-unit>
        <trans-unit id="b1489d43a3216d7ad2c82c2a95acd60755df1162" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;||&quot;&lt;/code&gt; performs a short-circuit logical OR operation. That is, if the left operand is true, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;||&quot;&lt;/code&gt; 执行短路逻辑或运算。也就是说，如果左操作数为true，则甚至不会评估右操作数。如果评估标量或列表上下文，则向下传播到正确的操作数。</target>
        </trans-unit>
        <trans-unit id="f92bb398898c648f24279f387f99c6d49704c347" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;~~&quot;&lt;/code&gt; does a smartmatch between its arguments. Smart matching is described in the next section.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;~~&quot;&lt;/code&gt; 在其参数之间进行智能匹配。下一节将介绍智能匹配。</target>
        </trans-unit>
        <trans-unit id="474b37cbe0d6e0c72ec20c7e955273bab42d36ef" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;isa&lt;/code&gt; evaluates to true when the left argument is an object instance of the class (or a subclass derived from that class) given by the right argument. If the left argument is not defined, not a blessed object instance, nor does not derive from the class given by the right argument, the operator evaluates as false. The right argument may give the class either as a bareword or a scalar expression that yields a string class name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47cc7ad1e48a139eed3a38cd085aae1011cbc98f" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;x&lt;/code&gt; is the repetition operator. In scalar context, or if the left operand is neither enclosed in parentheses nor a &lt;code&gt;qw//&lt;/code&gt; list, it performs a string repetition. In that case it supplies scalar context to the left operand, and returns a string consisting of the left operand string repeated the number of times specified by the right operand. If the &lt;code&gt;x&lt;/code&gt; is in list context, and the left operand is either enclosed in parentheses or a &lt;code&gt;qw//&lt;/code&gt; list, it performs a list repetition. In that case it supplies list context to the left operand, and returns a list consisting of the left operand list repeated the number of times specified by the right operand. If the right operand is zero or negative (raising a warning on negative), it returns an empty string or an empty list, depending on the context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d7bf96b3a657465e5f87b07b34fa4dafeb1ef4" translate="yes" xml:space="preserve">
          <source>Binary backward compatibility; this function is a macro but also has a &lt;code&gt;Perl_&lt;/code&gt; implementation (which is exported).</source>
          <target state="translated">二进制向后兼容；该函数是一个宏，但也具有 &lt;code&gt;Perl_&lt;/code&gt; 实现（已导出）。</target>
        </trans-unit>
        <trans-unit id="be16b35ee218fa359867cb0e97728996cffd42bc" translate="yes" xml:space="preserve">
          <source>Binary distributions for some proprietary platforms can be found &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt; directory. Because these are not part of the standard distribution, they may and in fact do differ from the base perl port in a variety of ways. You'll have to check their respective release notes to see just what the differences are. These differences can be either positive (e.g. extensions for the features of the particular platform that are not supported in the source release of perl) or negative (e.g. might be based upon a less current source release of perl).</source>
          <target state="translated">某些专有平台的二进制发行版可在&lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt;目录中找到。因为这些不是标准发行版的一部分，所以它们实际上可能确实以多种方式与基本perl端口不同。您必须查看它们各自的发行说明，以了解它们之间的区别。这些差异可以是肯定的（例如，Perl的源代码发行版中不支持的特定平台功能的扩展）或否定的（例如，可能基于最新的Perl的源代码发行版）。</target>
        </trans-unit>
        <trans-unit id="55fd3c0a11bb58bb23e20465875244f2ca59b441" translate="yes" xml:space="preserve">
          <source>Binary installer also creates a folder on your desktop with some useful objects. If you need to change some aspects of the work of the binary installer, feel free to edit the file</source>
          <target state="translated">二进制安装程序也会在你的桌面上创建一个文件夹,里面有一些有用的对象。如果你需要改变二进制安装程序工作的某些方面,请随时编辑文件------。</target>
        </trans-unit>
        <trans-unit id="b3b1f88d8a58f93a423339c57b3f74f2d820a432" translate="yes" xml:space="preserve">
          <source>Binary number &amp;gt; 0b11111111111111111111111111111111 non-portable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c1ba08fb761b34a695ec927e7b1037b80a83ca" translate="yes" xml:space="preserve">
          <source>Binary strings (byte strings)</source>
          <target state="translated">二进制字符串(字节字符串)</target>
        </trans-unit>
        <trans-unit id="9a138af365fa894e34cab06b679f370e8157841c" translate="yes" xml:space="preserve">
          <source>Binding Operators</source>
          <target state="translated">绑定操作员</target>
        </trans-unit>
        <trans-unit id="73bb8553f0429ab1a4f3db6aa26eab8529fc1962" translate="yes" xml:space="preserve">
          <source>Binding together several statements in a macro</source>
          <target state="translated">将一个宏中的多个语句绑定在一起</target>
        </trans-unit>
        <trans-unit id="be19add4d0d70fd9e2b19a5940d1ed397561b92a" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as &lt;a href=&quot;http://man.he.net/man2/bind&quot;&gt;bind(2)&lt;/a&gt; does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;&quot;Sockets: Client/Server Communication&quot; in perlipc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee51bd7870301b5b50c94bd801894ab927735dc" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as &lt;code&gt;bind(2)&lt;/code&gt; does. Returns true if it succeeded, false otherwise. You should provide a packed address of the appropriate type for the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5549ae8d615ef700c81551ae6af123d2f95aacb7" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as bind(2) does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">就像bind（2）一样，将网络地址绑定到套接字。如果成功，则返回true，否则返回false。NAME应该是套接字的适当类型的压缩地址。请参阅&lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="9fa331f367a4577bd9809395dd5e94974930bded" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as bind(2) does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">就像bind（2）一样，将网络地址绑定到套接字。如果成功，则返回true，否则返回false。NAME应该是套接字的适当类型的压缩地址。请参阅&lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="1d4a984a59802112ea9e0afc9140f13f4e5333e8" translate="yes" xml:space="preserve">
          <source>Binmode</source>
          <target state="translated">Binmode</target>
        </trans-unit>
        <trans-unit id="6974d8c4576a73016b6ecc19f5a2ebc538fab746" translate="yes" xml:space="preserve">
          <source>Birrell, Andrew D. An Introduction to Programming with Threads. Digital Equipment Corporation, 1989, DEC-SRC Research Report #35 online as &lt;a href=&quot;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&quot;&gt;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&lt;/a&gt; (highly recommended)</source>
          <target state="translated">Birrell，AndrewD。《线程编程简介》。Digital Equipment Corporation，1989年，DEC-SRC研究报告＃35，网址为&lt;a href=&quot;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&quot;&gt;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&lt;/a&gt;（强烈建议）</target>
        </trans-unit>
        <trans-unit id="36b5cf92c2fb97a05ef7bf770fab59d48c1cb050" translate="yes" xml:space="preserve">
          <source>Birrell, Andrew D. An Introduction to Programming with Threads. Digital Equipment Corporation, 1989, DEC-SRC Research Report #35 online as &lt;a href=&quot;https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-35.pdf&quot;&gt;https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-35.pdf&lt;/a&gt; (highly recommended)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a110cc2137a88f53fa983eabf18c6a369cdd6cc9" translate="yes" xml:space="preserve">
          <source>Bisecting</source>
          <target state="translated">Bisecting</target>
        </trans-unit>
        <trans-unit id="f6106638b60c4b72e8832174afe58ef2d3da9922" translate="yes" xml:space="preserve">
          <source>Bit Complement Operator ~ And vec()</source>
          <target state="translated">位补码运算符 ~ And vec()</target>
        </trans-unit>
        <trans-unit id="c5e74747e30dab25d0878fbe61b78c61e44df4c0" translate="yes" xml:space="preserve">
          <source>Bit Strings</source>
          <target state="translated">位串</target>
        </trans-unit>
        <trans-unit id="ba34e7ebde4a9f60d96348693e30b97a898d1671" translate="yes" xml:space="preserve">
          <source>Bit vector size &amp;gt; 32 non-portable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833619884d42232d65498c141d5b13c648753213" translate="yes" xml:space="preserve">
          <source>Bits are the atoms in the memory world. Access to individual bits may have to be used either as a last resort or because it is the most convenient way to handle your data. Bit string (un)packing converts between strings containing a series of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; characters and a sequence of bytes each containing a group of 8 bits. This is almost as simple as it sounds, except that there are two ways the contents of a byte may be written as a bit string. Let's have a look at an annotated byte:</source>
          <target state="translated">位是内存世界中的原子。不得已只能使用对单个位的访问，或者因为这是处理数据的最便捷方法。位字符串（解包）在包含一系列 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 个字符的字符串以及每个包含一组8位的字节序列之间转换。除了用两种方法可以将字节的内容写为位字符串外，这几乎听起来很简单。让我们看一下带注释的字节：</target>
        </trans-unit>
        <trans-unit id="8d8367155a1b407dd5a8766f2b3e58679136cc71" translate="yes" xml:space="preserve">
          <source>Bits that the &lt;b&gt;owner&lt;/b&gt; of a file sets or unsets to allow or disallow access to other people. These flag bits are part of the &lt;b&gt;mode&lt;/b&gt; word returned by the &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; built-in when you ask about a file. On Unix systems, you can check the</source>
          <target state="translated">文件&lt;b&gt;所有者&lt;/b&gt;设置或取消设置的位，以允许或禁止其他人访问。当您询问文件时，这些标志位是 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 内置返回的&lt;b&gt;模式&lt;/b&gt;字的一部分。在Unix系统上，您可以检查</target>
        </trans-unit>
        <trans-unit id="aca05ef0109989b493ae0975df5c4747401f63d8" translate="yes" xml:space="preserve">
          <source>Bits that the &lt;b&gt;owner&lt;/b&gt; of a file sets or unsets to allow or disallow access to other people. These flag bits are part of the &lt;b&gt;mode&lt;/b&gt; word returned by the &lt;code&gt;stat&lt;/code&gt; built-in when you ask about a file. On Unix systems, you can check the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9166fa867213d69681d8dc9ba4c66e0e28bd7ae5" translate="yes" xml:space="preserve">
          <source>Bitstrings of any size may be manipulated by the bitwise operators (&lt;code&gt;~ | &amp;amp; ^&lt;/code&gt;).</source>
          <target state="translated">任何大小的位串都可以由按位运算符（ &lt;code&gt;~ | &amp;amp; ^&lt;/code&gt; ）操纵。</target>
        </trans-unit>
        <trans-unit id="55bcce66fdecceeb947a789cd32be9b93c7eca65" translate="yes" xml:space="preserve">
          <source>Bitwise And</source>
          <target state="translated">位元和</target>
        </trans-unit>
        <trans-unit id="b636b8ad1b24ac557aa4eb2c5b388de819e1c9dc" translate="yes" xml:space="preserve">
          <source>Bitwise Or and Exclusive Or</source>
          <target state="translated">Bitwise Or 和 Exclusive Or</target>
        </trans-unit>
        <trans-unit id="e12b00fd649b7b2d92cbde1fe11e2e094a03730b" translate="yes" xml:space="preserve">
          <source>Bitwise String Operators</source>
          <target state="translated">字符串操作符</target>
        </trans-unit>
        <trans-unit id="60dab14d1038a5ab6653c6e814d064d60e1699d8" translate="yes" xml:space="preserve">
          <source>Bitwise methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc97888788cc1b09dac9d2412a98d54e24f8b1e" translate="yes" xml:space="preserve">
          <source>Bitwise operators</source>
          <target state="translated">位元运算符</target>
        </trans-unit>
        <trans-unit id="8a7fb7c64ed6d34c679867c6172b911e0f987e0b" translate="yes" xml:space="preserve">
          <source>Bitwise operators during &lt;code&gt;use integer&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6124b539fbe18e72605192e10e84abc660b435" translate="yes" xml:space="preserve">
          <source>Bizarre SvTYPE [%d]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6569857bf0d6ff7a8e148a4adb3a9e8ee5c017ec" translate="yes" xml:space="preserve">
          <source>Bizarre copy of %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97eb984318634f0d968a3f61bf23fd2faf3f45b" translate="yes" xml:space="preserve">
          <source>Bizarre space in item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2480b20b616fff68feba2feb22ee1344013e9a" translate="yes" xml:space="preserve">
          <source>Blank lines between chunks that do different things.</source>
          <target state="translated">块之间的空白线,做不同的事情。</target>
        </trans-unit>
        <trans-unit id="920da8ab7902a7645d8456f5c8da1988c54e0d83" translate="yes" xml:space="preserve">
          <source>Blessed References and Class Objects</source>
          <target state="translated">受祝福的引用和类对象</target>
        </trans-unit>
        <trans-unit id="68214e18c0b1867aaa68202e63eba7567e9b30a9" translate="yes" xml:space="preserve">
          <source>Blessed objects are not directly representable in JSON, but &lt;code&gt;JSON::PP&lt;/code&gt; allows various ways of handling objects. See &lt;a href=&quot;#OBJECT-SERIALISATION&quot;&gt;&quot;OBJECT SERIALISATION&quot;&lt;/a&gt;, below, for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c23f408055d193d91f1b67442a45565695178a" translate="yes" xml:space="preserve">
          <source>Blesses an SV into a specified package. The SV must be an RV. The package must be designated by its stash (see &lt;code&gt;&lt;a href=&quot;#gv_stashpv&quot;&gt;&quot;gv_stashpv&quot;&lt;/a&gt;&lt;/code&gt;). The reference count of the SV is unaffected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7954a73ad696d763789ec0de2fb44af6092e878a" translate="yes" xml:space="preserve">
          <source>Blesses an SV into a specified package. The SV must be an RV. The package must be designated by its stash (see &lt;code&gt;gv_stashpv()&lt;/code&gt; ). The reference count of the SV is unaffected.</source>
          <target state="translated">将SV祝福到指定的软件包中。SV必须是RV。该软件包必须由其藏匿处指定（请参阅 &lt;code&gt;gv_stashpv()&lt;/code&gt; ）。SV的参考计数不受影响。</target>
        </trans-unit>
        <trans-unit id="e54f1e0cbee429156b492ed8b4b751701cbcbd26" translate="yes" xml:space="preserve">
          <source>Blessing</source>
          <target state="translated">Blessing</target>
        </trans-unit>
        <trans-unit id="548174d374d3a6d330e0dce28420c09b6c8a9390" translate="yes" xml:space="preserve">
          <source>Blessing a shared item after it has been nested in another shared item does not propagate the blessing to the shared reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e84551f3c75d4af55438233d1c2c7909c862fc3b" translate="yes" xml:space="preserve">
          <source>Blindly passing va_list</source>
          <target state="translated">盲目地通过va_list</target>
        </trans-unit>
        <trans-unit id="929de0b7c4802448411e951e5153fd25660c3b1f" translate="yes" xml:space="preserve">
          <source>Blindly using variadic macros</source>
          <target state="translated">盲目使用变量宏</target>
        </trans-unit>
        <trans-unit id="82dd2cdf36f9436d89f404454654ad3e53fd428d" translate="yes" xml:space="preserve">
          <source>Block</source>
          <target state="translated">Block</target>
        </trans-unit>
        <trans-unit id="3df7eee072ad8f186abf1b2d2565ea2787bb93b4" translate="yes" xml:space="preserve">
          <source>Block eval</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf3b25756dcb70819ec2e3fa0ac57e7ce3a0990" translate="yes" xml:space="preserve">
          <source>Block names are matched in the compound form, like &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; or &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; . Unlike most other properties, only a few block names have a Unicode-defined short name. But Perl does provide a (slight, no longer recommended) shortcut: You can say, for example &lt;code&gt;\p{In_Arrows}&lt;/code&gt; or &lt;code&gt;\p{In_Hebrew}&lt;/code&gt; .</source>
          <target state="translated">块名称以复合形式匹配，例如 &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; 或 &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; 。与大多数其他属性不同，只有少数块名称具有Unicode定义的短名称。但是Perl确实提供了一个（不再推荐的快捷方式）快捷方式：例如，您可以说 &lt;code&gt;\p{In_Arrows}&lt;/code&gt; 或 &lt;code&gt;\p{In_Hebrew}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75cda6989df1a079fcf560c9e780003cd931ab30" translate="yes" xml:space="preserve">
          <source>Block names are matched in the compound form, like &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; or &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt;. Unlike most other properties, only a few block names have a Unicode-defined short name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d785c0d4b3b9c24878b62f64a7bcf78e9506ab27" translate="yes" xml:space="preserve">
          <source>Blocking</source>
          <target state="translated">Blocking</target>
        </trans-unit>
        <trans-unit id="bbaa0510707f42633a5b2810cc339df2222d09f5" translate="yes" xml:space="preserve">
          <source>Blocking =&amp;gt; BOOL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c45c033f5eb914fae27a646cbd9e23d3750d19" translate="yes" xml:space="preserve">
          <source>Blocks</source>
          <target state="translated">Blocks</target>
        </trans-unit>
        <trans-unit id="91c2278276bfdf926da91f0d87d6f0041b36f310" translate="yes" xml:space="preserve">
          <source>Blocks versus Scripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06992d2c6a4fd06aa405eff11e7109cec33fa12f" translate="yes" xml:space="preserve">
          <source>Blueprint</source>
          <target state="translated">Blueprint</target>
        </trans-unit>
        <trans-unit id="9febcf64ddd4a1c589fafb6acc27a333296a03c8" translate="yes" xml:space="preserve">
          <source>Body of the report. If not included on the command line, or in a file with &lt;b&gt;-f&lt;/b&gt;, you will get a chance to edit the message.</source>
          <target state="translated">报告正文。如果未包含在命令行中或&lt;b&gt;-f&lt;/b&gt;文件中，您将有机会编辑该消息。</target>
        </trans-unit>
        <trans-unit id="b1b26c9b3704fe7427bfc6aa57886af38bc8fd15" translate="yes" xml:space="preserve">
          <source>Body of the report. If not included on the command line, or in a file with &lt;b&gt;-f&lt;/b&gt;, you will get a chance to edit the report.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2dcad692e8a39400b913368019fc7eef1d73269" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt; . Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">固定宽度字体的粗体斜体（可能实际上是斜体）版本。Pod :: Man不假定您具有此 &lt;code&gt;CB&lt;/code&gt; ，并且默认为CB。某些系统（例如Solaris）具有此字体的 &lt;code&gt;CX&lt;/code&gt; 。仅对&lt;b&gt;troff&lt;/b&gt;输出有效。</target>
        </trans-unit>
        <trans-unit id="9e34e43ca3b41295b323939a7bd9811db605af24" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt; . Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">固定宽度字体的粗体斜体（可能实际上是斜体）版本。Pod :: Man不假定您具有此 &lt;code&gt;CB&lt;/code&gt; ，并且默认为CB。某些系统（例如Solaris）具有此字体的 &lt;code&gt;CX&lt;/code&gt; 。仅对troff（1）输出有效。</target>
        </trans-unit>
        <trans-unit id="feeb11edec497ca4f54c665a95df5130b4c829b2" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt;. Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt;. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302306e8a29ac5f2d9ddbda14d6dbb86f08c19c5" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt;. Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt;. Only matters for troff(1) output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9abc1cd480871c700b51d43c9a44b554d40d55c" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">固定宽度字体的加粗版本。默认为 &lt;code&gt;CB&lt;/code&gt; 。仅对&lt;b&gt;troff&lt;/b&gt;输出有效。</target>
        </trans-unit>
        <trans-unit id="73204c593462d6c14f32f02ba63b55da40420528" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">固定宽度字体的加粗版本。默认为 &lt;code&gt;CB&lt;/code&gt; 。仅对troff（1）输出有效。</target>
        </trans-unit>
        <trans-unit id="4826fec0f048131f813dc8e60e9509d935802a38" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt;. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21be102197e929754c4d027624958a11458b8256" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt;. Only matters for troff(1) output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca3cddd25bd8f6bc4ce35a262e2e1398541ecf3d" translate="yes" xml:space="preserve">
          <source>Bookmarks</source>
          <target state="translated">Bookmarks</target>
        </trans-unit>
        <trans-unit id="fbe3448227f9beab3e352c0b7e28a363ba97c273" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, failing to have the required modules (or the right versions thereof) will be fatal. &lt;code&gt;perl Makefile.PL&lt;/code&gt; will &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; instead of simply informing the user of the missing dependencies.</source>
          <target state="translated">布尔 如果此参数为true，则缺少必需的模块（或其正确版本）将是致命的。 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 将 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 而不是简单地通知用户缺少的依赖项。</target>
        </trans-unit>
        <trans-unit id="aa02db7b0e1536fcc3f6de1b2a7dcf01412dc0c6" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, failing to have the required modules (or the right versions thereof) will be fatal. &lt;code&gt;perl Makefile.PL&lt;/code&gt; will &lt;code&gt;die&lt;/code&gt; instead of simply informing the user of the missing dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a706d5f747a56fb59b2b20adabd115aadfc3ab6" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, the prerequisites will be printed to stdout and MakeMaker will exit. The output format is an evalable hash ref.</source>
          <target state="translated">Bool.如果该参数为真,则先决条件将被打印到stdout,MakeMaker将退出。如果该参数为真,则先决条件将被打印到stdout,MakeMaker将退出。输出格式是一个可评价的哈希ref。</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="09eca632f0dfa4476bacf2f878b87c41a27eb16f" translate="yes" xml:space="preserve">
          <source>Boolean context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02eefeb78b1690ec4b9fb5543382dba69c8c96d9" translate="yes" xml:space="preserve">
          <source>Boolean logic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee421eba15aa24904646f6184653841c5c549d1" translate="yes" xml:space="preserve">
          <source>Boolean methods</source>
          <target state="translated">布尔方法</target>
        </trans-unit>
        <trans-unit id="02774d2bd49b309c70bcbf1cd2d7f51fdc3d2b2f" translate="yes" xml:space="preserve">
          <source>Boolean operators</source>
          <target state="translated">布尔运算符</target>
        </trans-unit>
        <trans-unit id="55aef5e3c5e0b75d499308ca6279e82ab808182b" translate="yes" xml:space="preserve">
          <source>Boolean operators &lt;code&gt;is_zero()&lt;/code&gt;, &lt;code&gt;is_one()&lt;/code&gt;, &lt;code&gt;is_inf()&lt;/code&gt;, etc. return true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e109ffb226c19879bd546df66c824f1e645625c" translate="yes" xml:space="preserve">
          <source>Boolean options:</source>
          <target state="translated">布尔选项。</target>
        </trans-unit>
        <trans-unit id="c8c3f1d753ec555418a750eeff6d7eaeba2abf76" translate="yes" xml:space="preserve">
          <source>Boolean value. If false, disables the &lt;code&gt;X/Y&lt;/code&gt; test count which shows up while tests are running.</source>
          <target state="translated">布尔值。如果为false，则禁用在运行测试时显示的 &lt;code&gt;X/Y&lt;/code&gt; 测试计数。</target>
        </trans-unit>
        <trans-unit id="f6906832f4c5efb1eff6981bd8a551cf05deba12" translate="yes" xml:space="preserve">
          <source>Boolean which tells MakeMaker that it should include the rules to make a perl. This is handled automatically as a switch by MakeMaker. The user normally does not need it.</source>
          <target state="translated">Boolean,它告诉MakeMaker应该包含规则来制作一个perl。这是由MakeMaker作为开关自动处理的。用户通常不需要它。</target>
        </trans-unit>
        <trans-unit id="a3aa9ead54da3d9f1481bd131dbbec1f59ea0c12" translate="yes" xml:space="preserve">
          <source>Boolean. Attribute to inhibit descending into subdirectories.</source>
          <target state="translated">布尔型。禁止进入子目录的属性。</target>
        </trans-unit>
        <trans-unit id="09273e0b3502cd35874b01a3ba91c106f87a667f" translate="yes" xml:space="preserve">
          <source>Bootstrapping</source>
          <target state="translated">Bootstrapping</target>
        </trans-unit>
        <trans-unit id="62ac59b7255ce5ff9fee8ac49157bdd9bc4445e2" translate="yes" xml:space="preserve">
          <source>Bosnia and Herzegovina</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf7bb36f8e532fed41b905555bc401b988f86c8" translate="yes" xml:space="preserve">
          <source>Boss/Worker</source>
          <target state="translated">Boss/Worker</target>
        </trans-unit>
        <trans-unit id="80bcf52e7840ffd18cf3865b5ebb50a306bef71b" translate="yes" xml:space="preserve">
          <source>Both &quot;objects&quot; which are blessed into the class &lt;code&gt;two_refs1&lt;/code&gt; are references to a reference to an array, thus references to a</source>
          <target state="translated">被祝福到类 &lt;code&gt;two_refs1&lt;/code&gt; 中的两个&amp;ldquo;对象&amp;rdquo; 都是对数组的引用，因此是对a的引用。</target>
        </trans-unit>
        <trans-unit id="fdd5582984ca6c53c867eacfa38935bd769631ff" translate="yes" xml:space="preserve">
          <source>Both #1 and #2 make $data consist of a completely valid UTF-8 string, but only #2 turns the UTF8 flag on. #1 is equivalent to:</source>
          <target state="translated">#1和#2都使$data由一个完全有效的UTF-8字符串组成,但只有#2打开了UTF8标志。#1相当于:</target>
        </trans-unit>
        <trans-unit id="e055e854ed20a46d2f7df7544241f7588b51f8b0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;bsstr()&lt;/code&gt; as well as automated stringify via overload now drop the leading '+'. The old code would return '+3', the new returns '3'. This is to be consistent with Perl and to make &lt;code&gt;cmp&lt;/code&gt; (especially with overloading) to work as you expect. It also solves problems with &lt;code&gt;Test.pm&lt;/code&gt; and &lt;a href=&quot;../test/more&quot;&gt;Test::More&lt;/a&gt;, which stringify arguments before comparing them.</source>
          <target state="translated">现在， &lt;code&gt;bstr()&lt;/code&gt; 和 &lt;code&gt;bsstr()&lt;/code&gt; 以及通过重载自动进行字符串化都将删除前导'+'。旧代码将返回&amp;ldquo; +3&amp;rdquo;，新代码将返回&amp;ldquo; 3&amp;rdquo;。这与Perl保持一致，并使 &lt;code&gt;cmp&lt;/code&gt; （尤其是在重载时）能够按预期工作。它还解决了 &lt;code&gt;Test.pm&lt;/code&gt; 和&lt;a href=&quot;../test/more&quot;&gt;Test :: More的问题&lt;/a&gt;，它们在比较参数之前先对其进行了字符串化处理。</target>
        </trans-unit>
        <trans-unit id="a620ebe99c93fe5ad5f0770d99e27217bee38fe8" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;bsstr()&lt;/code&gt; as well as stringify via overload drop the leading '+'. This is to be consistent with Perl and to make &lt;code&gt;cmp&lt;/code&gt; (especially with overloading) to work as you expect. It also solves problems with &lt;code&gt;Test.pm&lt;/code&gt; and &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;, which stringify arguments before comparing them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaeb9ffa94e14cf78c87073a072611e3232fa148" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; and &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; will return &lt;code&gt;MAYBE&lt;/code&gt; . &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is not in NFC (its NFC is &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; ), while &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is in NFC.</source>
          <target state="translated">既 &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; 和 &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; 将返回 &lt;code&gt;MAYBE&lt;/code&gt; 。NFC中没有 &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; （它的NFC是 &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; ），而NFC中没有 &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a5a39017b338373b526416f145175959e75a080" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; and &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; will return &lt;code&gt;MAYBE&lt;/code&gt;. &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is not in NFC (its NFC is &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt;), while &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is in NFC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0dc99557ca052a1f52b6aa9fe01653c0b56cfaf" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;cmp&lt;/code&gt; and &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; operators perform the same comparison between terms (upgrading to a version object automatically). Perl automatically generates all of the other comparison operators based on those two. In addition to the obvious equalities listed below, appending a single trailing 0 term does not change the value of a version for comparison purposes. In other words &quot;v1.2&quot; and &quot;1.2.0&quot; will compare as identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24cf9e2240da639243f4502d5aa3bda3947c5953" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; croak if given dates outside the supported range.</source>
          <target state="translated">无论 &lt;code&gt;timelocal()&lt;/code&gt; 和 &lt;code&gt;timegm()&lt;/code&gt; 如果有支持的范围以外的日期蛙鸣。</target>
        </trans-unit>
        <trans-unit id="9b6b1830495cedccd8298426103e7c2b6bedc5b6" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;wrap()&lt;/code&gt; and &lt;code&gt;fill()&lt;/code&gt; return a single string.</source>
          <target state="translated">这两个 &lt;code&gt;wrap()&lt;/code&gt; 和 &lt;code&gt;fill()&lt;/code&gt; 返回一个字符串。</target>
        </trans-unit>
        <trans-unit id="a3b45c366057bea34b5a8bb7824f2e8dd99b7496" translate="yes" xml:space="preserve">
          <source>Both Perl functions will expect an object as the first parameter. In the generated C++ code the object is called &lt;code&gt;THIS&lt;/code&gt; , and the method call will be performed on this object. So in the C++ code the blue() and set_blue() methods will be called as this:</source>
          <target state="translated">两个Perl函数都将一个对象作为第一个参数。在生成的C ++代码中，该对象称为 &lt;code&gt;THIS&lt;/code&gt; ，方法调用将在此对象上执行。因此，在C ++代码中，blue（）和set_blue（）方法将被这样调用：</target>
        </trans-unit>
        <trans-unit id="7be927e1ed4202312ce2dde8192f9556312f51fd" translate="yes" xml:space="preserve">
          <source>Both Perl functions will expect an object as the first parameter. In the generated C++ code the object is called &lt;code&gt;THIS&lt;/code&gt;, and the method call will be performed on this object. So in the C++ code the blue() and set_blue() methods will be called as this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642b008f0bb09ab02b4608dfe561ba3f906e665d" translate="yes" xml:space="preserve">
          <source>Both YAML.pm and YAML::Syck are capable of deserialising code. As this requires a string eval, which might be a security risk, you can use this option to enable or disable the deserialisation of code via CPAN::DeferredCode. (Note: This does not work under perl 5.6)</source>
          <target state="translated">YAML.pm和YAML::Syck都能够反序列化代码。由于这需要一个字符串评估,这可能是一个安全风险,你可以使用这个选项通过CPAN::DeferredCode来启用或禁用代码的反序列化。(注意:这在 perl 5.6 下不起作用)</target>
        </trans-unit>
        <trans-unit id="1092e6af8de8fc50cc6d06fd73a32b5d8423a7e9" translate="yes" xml:space="preserve">
          <source>Both are bad, and broken, and unportable. Use the PTR2IV() macro that does it right. (Likewise, there are PTR2UV(), PTR2NV(), INT2PTR(), and NUM2PTR().)</source>
          <target state="translated">两者都不好,而且坏了,无法移植。使用PTR2IV()宏就可以了。同样,还有PTR2UV()、PTR2NV()、INT2PTR()和NUM2PTR()。</target>
        </trans-unit>
        <trans-unit id="e8f3fbafa937e38c34348185c6cef931d0a050c2" translate="yes" xml:space="preserve">
          <source>Both colored() and many uses of the color constants will add the reset escape sequence after a newline. If a program mixes colored output to standard output with output to standard error, this can result in the standard error text having the wrong color because the reset escape sequence hasn't yet been flushed to the display (since standard output to a terminal is line-buffered by default). To avoid this, either set autoflush() on STDOUT or set $Term::ANSIColor::EACHLINE to &lt;code&gt;&quot;\n&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3767903b8fab9710d5f5dbf8d10a9f6252cdd29" translate="yes" xml:space="preserve">
          <source>Both efforts welcome volunteers. In order to get involved in smoke testing of the perl itself visit &lt;a href=&quot;http://search.cpan.org/dist/Test-Smoke/&quot;&gt;http://search.cpan.org/dist/Test-Smoke/&lt;/a&gt;. In order to start smoke testing CPAN modules visit &lt;a href=&quot;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&quot;&gt;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/dist/minismokebox/&quot;&gt;http://search.cpan.org/dist/minismokebox/&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/dist/CPAN-Reporter/&quot;&gt;http://search.cpan.org/dist/CPAN-Reporter/&lt;/a&gt;.</source>
          <target state="translated">双方的努力都欢迎志愿者。为了参与Perl本身的烟雾测试，请访问&lt;a href=&quot;http://search.cpan.org/dist/Test-Smoke/&quot;&gt;http://search.cpan.org/dist/Test-Smoke/&lt;/a&gt;。为了开始烟雾测试CPAN模块，请访问&lt;a href=&quot;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&quot;&gt;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/dist/minismokebox/&quot;&gt;http://search.cpan.org/dist/minismokebox/&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/dist/CPAN-Reporter/&quot;&gt;http://search.cpan.org / dist / CPAN-Reporter /&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae562d3087c6e461927df57072977056d07bc9d8" translate="yes" xml:space="preserve">
          <source>Both efforts welcome volunteers. In order to get involved in smoke testing of the perl itself visit &lt;a href=&quot;https://metacpan.org/release/Test-Smoke&quot;&gt;https://metacpan.org/release/Test-Smoke&lt;/a&gt;. In order to start smoke testing CPAN modules visit &lt;a href=&quot;https://metacpan.org/release/CPANPLUS-YACSmoke&quot;&gt;https://metacpan.org/release/CPANPLUS-YACSmoke&lt;/a&gt; or &lt;a href=&quot;https://metacpan.org/release/minismokebox&quot;&gt;https://metacpan.org/release/minismokebox&lt;/a&gt; or &lt;a href=&quot;https://metacpan.org/release/CPAN-Reporter&quot;&gt;https://metacpan.org/release/CPAN-Reporter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d4c4d23a88d207ea9fa065963f476f871b153f" translate="yes" xml:space="preserve">
          <source>Both encode and decode methods propagate &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;CHECK flags&lt;/a&gt; when encoding and decoding the MIME charset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1c59ffc42033f2c98187249f767826197ba8a8" translate="yes" xml:space="preserve">
          <source>Both forms are equivalent.</source>
          <target state="translated">这两种形式是等同的。</target>
        </trans-unit>
        <trans-unit id="143f2cf2fc37f6046de22ba46473032b532447b9" translate="yes" xml:space="preserve">
          <source>Both functions return equivalent information (like &lt;code&gt;gettimeofday&lt;/code&gt; ) but with different representations. The names &lt;code&gt;NVtime&lt;/code&gt; and &lt;code&gt;U2time&lt;/code&gt; were selected mainly because they are operating system independent. (&lt;code&gt;gettimeofday&lt;/code&gt; is Unix-centric, though some platforms like Win32 and VMS have emulations for it.)</source>
          <target state="translated">这两个函数都返回相等的信息（如 &lt;code&gt;gettimeofday&lt;/code&gt; ），但是具有不同的表示形式。选择名称 &lt;code&gt;NVtime&lt;/code&gt; 和 &lt;code&gt;U2time&lt;/code&gt; 的主要原因是它们与操作系统无关。（ &lt;code&gt;gettimeofday&lt;/code&gt; 以Unix为中心，尽管某些平台（如Win32和VMS对此具有仿真功能。）</target>
        </trans-unit>
        <trans-unit id="5c4e6f175302e55e83c34f1bf1849d831a9de257" translate="yes" xml:space="preserve">
          <source>Both functions return equivalent information (like &lt;code&gt;gettimeofday&lt;/code&gt;) but with different representations. The names &lt;code&gt;NVtime&lt;/code&gt; and &lt;code&gt;U2time&lt;/code&gt; were selected mainly because they are operating system independent. (&lt;code&gt;gettimeofday&lt;/code&gt; is Unix-centric, though some platforms like Win32 and VMS have emulations for it.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b934a70ce89ebfca7d59daaef7b8bcbcd00a0ef" translate="yes" xml:space="preserve">
          <source>Both install() and uninstall() are specific to the way ExtUtils::MakeMaker handles the installation and deinstallation of perl modules. They are not designed as general purpose tools.</source>
          <target state="translated">install()和uninstall()都是针对ExtUtils::MakeMaker处理perl模块的安装和卸载的方式。它们不是作为通用工具设计的。</target>
        </trans-unit>
        <trans-unit id="5627699dd1ad2924464995985beca5c6cf35ef97" translate="yes" xml:space="preserve">
          <source>Both methods will prevent the import() method from firing and exporting the &lt;code&gt;qv()&lt;/code&gt; sub.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9733ec84f2ee4e84fe6e0d43084959736e1c222c" translate="yes" xml:space="preserve">
          <source>Both numeric and string values are accepted, but note that string values are case sensitive. The default for this setting is &quot;RANDOM&quot; or 1.</source>
          <target state="translated">数字值和字符串值均可接受,但请注意,字符串值是区分大小写的。该设置的默认值是 &quot;RANDOM &quot;或1。</target>
        </trans-unit>
        <trans-unit id="4cf5f58736e6000e5a6bd77d8280326d1b82a931" translate="yes" xml:space="preserve">
          <source>Both of the above match the characters &lt;code&gt;\N{U+00}&lt;/code&gt;&lt;code&gt;\N{U+01}&lt;/code&gt; , ... &lt;code&gt;\N{U+08}&lt;/code&gt; , &lt;code&gt;\N{U+09}&lt;/code&gt; , but the &lt;code&gt;\x09&lt;/code&gt; looks like it could be a mistake so the warning is raised (under &lt;code&gt;re 'strict'&lt;/code&gt; ) for it.</source>
          <target state="translated">上面两个都匹配字符 &lt;code&gt;\N{U+00}&lt;/code&gt; &lt;code&gt;\N{U+01}&lt;/code&gt; ，... &lt;code&gt;\N{U+08}&lt;/code&gt; ， &lt;code&gt;\N{U+09}&lt;/code&gt; ，但是 &lt;code&gt;\x09&lt;/code&gt; 看起来可能是错误，因此会发出警告（在 &lt;code&gt;re 'strict'&lt;/code&gt; 之下）。</target>
        </trans-unit>
        <trans-unit id="6cba8f2c40b0b7e7464484e646fc77656ccf2181" translate="yes" xml:space="preserve">
          <source>Both of the above match the characters &lt;code&gt;\N{U+00}&lt;/code&gt;&lt;code&gt;\N{U+01}&lt;/code&gt;, ... &lt;code&gt;\N{U+08}&lt;/code&gt;, &lt;code&gt;\N{U+09}&lt;/code&gt;, but the &lt;code&gt;\x09&lt;/code&gt; looks like it could be a mistake so the warning is raised (under &lt;code&gt;re 'strict'&lt;/code&gt;) for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19034866ba0e5cf040b7023a16a969fddf08ed53" translate="yes" xml:space="preserve">
          <source>Both of the provided scalars are already compiled as regular expressions and do not contain either anchors or implicit groupings, so they can be included in your own regular expressions freely. For example, consider the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6fc8a94496c661c5e9f86f3352074c1b6a4eef2" translate="yes" xml:space="preserve">
          <source>Both of these methods will produce similar version objects, in that the default stringification will yield the version &lt;a href=&quot;#Normal-Form&quot;&gt;&quot;Normal Form&quot;&lt;/a&gt; only if required:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a103cc718ae6b6f4898e4597463858c0b08dfa7" translate="yes" xml:space="preserve">
          <source>Both or neither range ends should be Unicode in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4874cd0d5b99351b1bf775f190f16f304b87eaf" translate="yes" xml:space="preserve">
          <source>Both read and write access.</source>
          <target state="translated">读和写两种访问方式。</target>
        </trans-unit>
        <trans-unit id="e56fad1d57355bf08ff94859ec86b0170dc6755c" translate="yes" xml:space="preserve">
          <source>Both routines return a reference to the hash operated on.</source>
          <target state="translated">这两个例程都返回一个对哈希操作的引用。</target>
        </trans-unit>
        <trans-unit id="7a1480fdf3f98f2170cd256ce3b56c618e9acd2d" translate="yes" xml:space="preserve">
          <source>Both signify the monospace (c[ode] style) text consisting of &quot;$x&quot;, one space, &quot;?&quot;, one space, &quot;:&quot;, one space, &quot;$z&quot;. The difference is that in the latter, with the S code, those spaces are not &quot;normal&quot; spaces, but instead are non-breaking spaces.</source>
          <target state="translated">两者都表示由&quot;$x&quot;、一个空格、&quot;?&quot;、一个空格、&quot;:&quot;、一个空格、&quot;$z &quot;组成的单空格(c[颂]式)文字。不同的是,在后者的S码中,这些空格不是 &quot;正常 &quot;的空格,而是非断开的空格。</target>
        </trans-unit>
        <trans-unit id="ed699d8c766ffac9fc7609020189bb30a788c2d9" translate="yes" xml:space="preserve">
          <source>Both stringify and bstr() now drop the leading '+'. The old code would return '+1.23', the new returns '1.23'. See the documentation in &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; for reasoning and details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9280ff05f374fc2e82bcdbf91ea7cf106541bf" translate="yes" xml:space="preserve">
          <source>Both stringify and bstr() now drop the leading '+'. The old code would return '+1.23', the new returns '1.23'. See the documentation in &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for reasoning and details.</source>
          <target state="translated">现在，stringify和bstr（）都删除前导&amp;ldquo; +&amp;rdquo;。旧代码将返回&amp;ldquo; +1.23&amp;rdquo;，新代码将返回&amp;ldquo; 1.23&amp;rdquo;。有关推理和详细信息，请参见&lt;a href=&quot;bigint&quot;&gt;Math :: BigInt中&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="6e26a4aa31b6884fed4ace8e2ed5cfef52233768" translate="yes" xml:space="preserve">
          <source>Both styles work with either objects or typeglobs of real filehandles. (They might also work with strings under some circumstances, but this is risky.)</source>
          <target state="translated">这两种风格都可以使用对象或实际文件柄的类型格洛布(在某些情况下也可以使用字符串,但这是有风险的)。(在某些情况下,它们也可能适用于字符串,但这是有风险的。)</target>
        </trans-unit>
        <trans-unit id="40008ef1178df5187f4e9e86678b099b5c9935cc" translate="yes" xml:space="preserve">
          <source>Both subroutines here are called in a scalar context, while in:</source>
          <target state="translated">这里的两个子程序都是在标量上下文中调用的,而在。</target>
        </trans-unit>
        <trans-unit id="88a5a602af253e21581322ee44c47e54f2ad5148" translate="yes" xml:space="preserve">
          <source>Both sysread() and recv() currently use only the &lt;code&gt;:utf8&lt;/code&gt; flag for the stream, ignoring the actual layers. Since sysread() and recv() do no UTF-8 validation they can end up creating invalidly encoded scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b8819b78d506b9303c55ca1c6cd1ccf91f01b90" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;$key&lt;/code&gt; and &lt;code&gt;$value&lt;/code&gt; parameters will be set to the key/value pair read from the database.</source>
          <target state="translated">无论是 &lt;code&gt;$key&lt;/code&gt; 和 &lt;code&gt;$value&lt;/code&gt; 参数将被设置到该键/值对从数据库中读取。</target>
        </trans-unit>
        <trans-unit id="65ffa77ee21f2f134768654239d413a7ca561444" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;FETCH&lt;/code&gt; ing function and the &lt;code&gt;EXISTS&lt;/code&gt; functions have the same signature: the arguments are &lt;code&gt;$key, $data&lt;/code&gt; ; $data is the same value as given as argument during tie()ing. Both functions should return an empty list if the value does not exist. If &lt;code&gt;EXISTS&lt;/code&gt; function is different from the &lt;code&gt;FETCH&lt;/code&gt; ing function, it should return a TRUE value on success. The &lt;code&gt;FETCH&lt;/code&gt; ing function should return the intended value if the key is valid.</source>
          <target state="translated">无论是 &lt;code&gt;FETCH&lt;/code&gt; 荷兰国际集团功能和 &lt;code&gt;EXISTS&lt;/code&gt; 函数具有相同签名：参数是 &lt;code&gt;$key, $data&lt;/code&gt; ; $ data与tie（）处理期间作为参数给出的值相同。如果该值不存在，则两个函数均应返回一个空列表。如果 &lt;code&gt;EXISTS&lt;/code&gt; 函数与 &lt;code&gt;FETCH&lt;/code&gt; ing函数不同，则成功时应返回TRUE值。该 &lt;code&gt;FETCH&lt;/code&gt; 如果关键是有效ing功能可将返回预期值。</target>
        </trans-unit>
        <trans-unit id="26d9da8f5ad7069914e20430c62d4e761633b2e9" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;FETCH&lt;/code&gt;ing function and the &lt;code&gt;EXISTS&lt;/code&gt; functions have the same signature: the arguments are &lt;code&gt;$key, $data&lt;/code&gt;; $data is the same value as given as argument during tie()ing. Both functions should return an empty list if the value does not exist. If &lt;code&gt;EXISTS&lt;/code&gt; function is different from the &lt;code&gt;FETCH&lt;/code&gt;ing function, it should return a TRUE value on success. The &lt;code&gt;FETCH&lt;/code&gt;ing function should return the intended value if the key is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ed4eca63dc77f9c5ab93bb8224d63244af078a" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;\p&lt;/code&gt; counterparts always assume Unicode rules are in effect. On ASCII platforms, this means they assume that the code points from 128 to 255 are Latin-1, and that means that using them under locale rules is unwise unless the locale is guaranteed to be Latin-1 or UTF-8. In contrast, the POSIX character classes are useful under locale rules. They are affected by the actual rules in effect, as follows:</source>
          <target state="translated">&lt;code&gt;\p&lt;/code&gt; 两个对等总是假定Unicode规则有效。在ASCII平台上，这意味着它们假定从128到255的代码点是Latin-1，这意味着在语言环境规则下使用它们是不明智的，除非保证语言环境是Latin-1或UTF-8。相反，在区域设置规则下，POSIX字符类很有用。它们受有效的实际规则影响，如下所示：</target>
        </trans-unit>
        <trans-unit id="ce95f2fe752d4b23fc80e241799a0c7676e9a5d9" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;filter&lt;/code&gt; method used with a</source>
          <target state="translated">两种 &lt;code&gt;filter&lt;/code&gt; 方法都与</target>
        </trans-unit>
        <trans-unit id="16bb52db9f75f89e8e102ba17368f296bd30bb0a" translate="yes" xml:space="preserve">
          <source>Both the Store and Fetch filters manipulate &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">Store和Fetch过滤器都可操作 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fb703f0b0c3a852ad76e2cb00f9c501f48f8ec4" translate="yes" xml:space="preserve">
          <source>Both the Store and Fetch filters manipulate &lt;code&gt;$_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76973f944d78d30e634a5b0ebc6b4adb75da6f43" translate="yes" xml:space="preserve">
          <source>Both the functions can import the functions that are specified.</source>
          <target state="translated">这两个函数都可以导入指定的函数。</target>
        </trans-unit>
        <trans-unit id="2ad856a815b0ce3afb8156093d09ab25a9afd217" translate="yes" xml:space="preserve">
          <source>Both the main process and any child processes it forks share the same STDIN, STDOUT, and STDERR filehandles. If both processes try to access them at once, strange things can happen. You may also want to close or reopen the filehandles for the child. You can get around this by opening your pipe with open(), but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">主进程和它分叉的任何子进程都共享相同的STDIN、STDOUT和STDERR文件柄。如果两个进程同时试图访问它们,就会发生奇怪的事情。您可能还想关闭或重新打开子进程的文件柄。你可以通过使用open()打开管道来解决这个问题,但是在某些系统中,这意味着子进程的寿命不能超过父进程。</target>
        </trans-unit>
        <trans-unit id="449435c9cac23bf8a94ca4fcd8681004ec825181" translate="yes" xml:space="preserve">
          <source>Both the main process and the backgrounded one (the &quot;child&quot; process) share the same STDIN, STDOUT and STDERR filehandles. If both try to access them at once, strange things can happen. You may want to close or reopen these for the child. You can get around this with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;ing a pipe (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;) but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">主进程和后台进程（&amp;ldquo;子&amp;rdquo;进程）都共享相同的STDIN，STDOUT和STDERR文件句柄。如果两者都尝试一次访问它们，则可能会发生奇怪的事情。您可能要为孩子关闭或重新打开它们。您可以通过 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 管道来解决此问题（请参见&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;），但是在某些系统上，这意味着子进程无法超过父进程。</target>
        </trans-unit>
        <trans-unit id="f7d92bf0fef8c6d376360d3e96b538b59d69f577" translate="yes" xml:space="preserve">
          <source>Both the main process and the backgrounded one (the &quot;child&quot; process) share the same STDIN, STDOUT and STDERR filehandles. If both try to access them at once, strange things can happen. You may want to close or reopen these for the child. You can get around this with &lt;code&gt;open&lt;/code&gt;ing a pipe (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;) but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d89a0af2055da02fc83d8afed6e917b5cc66d525" translate="yes" xml:space="preserve">
          <source>Both the native cc and gcc seem to consume lots of memory when building Perl. toke.c is a known trouble spot when optimizing: 256 megabytes of data section seems to be enough. Another known trouble spot is the mktables script which builds the Unicode support tables. The default setting of the process data section in Tru64 should be one gigabyte, but some sites/setups might have lowered that. The configuration process of Perl checks for too low process limits, and lowers the optimization for the toke.c if necessary, and also gives advice on how to raise the process limits (for example: &lt;code&gt;ulimit -d 262144&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12969a7fe698e5db30d6dfa2ac116b77818d15ac" translate="yes" xml:space="preserve">
          <source>Both the special and normal mappings are stored in</source>
          <target state="translated">特殊的和正常的映射都存储于</target>
        </trans-unit>
        <trans-unit id="e87bc450de2089bfd62a5bd96629fc5b32ff6be9" translate="yes" xml:space="preserve">
          <source>Both these XS declarations correspond to the &lt;code&gt;char*&lt;/code&gt; C type, but they have different semantics, see &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;&quot;The &amp;amp; Unary Operator&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a5aa8697bdd1c4c4522254cc3fbbee82434df88" translate="yes" xml:space="preserve">
          <source>Both these XS declarations correspond to the &lt;code&gt;char*&lt;/code&gt; C type, but they have different semantics, see &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt;.</source>
          <target state="translated">这两个XS声明都对应于 &lt;code&gt;char*&lt;/code&gt; C类型，但是它们具有不同的语义，请参见&lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The＆Unary Operator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="457d0ea6cab97df36f6f6888a3f8a1c477cbe9c0" translate="yes" xml:space="preserve">
          <source>Both these methods insert &lt;code&gt;&quot;:full&quot;&lt;/code&gt; automatically as the first argument (if no other argument is given), and you can give the &lt;code&gt;&quot;:full&quot;&lt;/code&gt; explicitly as well, like</source>
          <target state="translated">这两种方法都会自动将 &lt;code&gt;&quot;:full&quot;&lt;/code&gt; 作为第一个参数（如果未提供其他参数），并且您也可以显式地给 &lt;code&gt;&quot;:full&quot;&lt;/code&gt; ，例如</target>
        </trans-unit>
        <trans-unit id="a673297be17d984a1ebfc2f484aa63db04fb7bb3" translate="yes" xml:space="preserve">
          <source>Both these problems can be cured. Say, if we want to overload hash dereference on a reference to an object which is</source>
          <target state="translated">这两个问题都是可以治愈的。比如说,如果我们想在一个对象的引用上重载Hash dereference,这个对象就是</target>
        </trans-unit>
        <trans-unit id="c67dbd5c074e12563a96469c299bb554a98bb89b" translate="yes" xml:space="preserve">
          <source>Both wdayname (day) and monname (month) allow passing in a list to use to index the name of the days against. This can be useful if you need to implement some form of localisation without actually installing or using locales.</source>
          <target state="translated">wdayname (day)和 monname (month)都允许传入一个列表,用来索引日期的名称。如果你需要在不实际安装或使用locales的情况下实现某种形式的本地化,这可能很有用。</target>
        </trans-unit>
        <trans-unit id="7251257be5507cef24fe3fb21a50fe67755c29b8" translate="yes" xml:space="preserve">
          <source>Both wdayname (day) and monname (month) allow passing in a list to use to index the name of the days against. This can be useful if you need to implement some form of localisation without actually installing or using locales. Note that this is a global override and will affect all Time::Piece instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f50d687ceecfadfb877f247a6453725043a7ffb" translate="yes" xml:space="preserve">
          <source>Bottom level UTF-8 decode routine. Returns the native code point value of the first character in the string &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, which is assumed to be in UTF-8 (or UTF-EBCDIC) encoding, and no longer than &lt;code&gt;curlen&lt;/code&gt; bytes; &lt;code&gt;*retlen&lt;/code&gt; (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) will be set to the length, in bytes, of that character.</source>
          <target state="translated">底层UTF-8解码例程。返回字符串 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 中第一个字符的本机代码点值，该值假定为UTF-8（或UTF-EBCDIC）编码，且长度不超过 &lt;code&gt;curlen&lt;/code&gt; 字节； &lt;code&gt;*retlen&lt;/code&gt; （如果 &lt;code&gt;retlen&lt;/code&gt; 不是NULL）将设置为该字符的长度（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="dfa04ba4cca5e78047dc43990129bc3ae3f19bff" translate="yes" xml:space="preserve">
          <source>Bottom level UTF-8 decode routine. Returns the native code point value of the first character in the string &lt;code&gt;s&lt;/code&gt;, which is assumed to be in UTF-8 (or UTF-EBCDIC) encoding, and no longer than &lt;code&gt;curlen&lt;/code&gt; bytes; &lt;code&gt;*retlen&lt;/code&gt; (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) will be set to the length, in bytes, of that character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ffac88340ff426b9b20077ea20bd37ed9bc04e3" translate="yes" xml:space="preserve">
          <source>Boundaries of Hangul syllables are determined according to conjoining Jamo behavior in</source>
          <target state="translated">韩语音节的界限是根据连体即墨行为来确定的。</target>
        </trans-unit>
        <trans-unit id="fa3c7716ef77e2c3385fc102b1a731781237c324" translate="yes" xml:space="preserve">
          <source>Boykin, Joseph, David Kirschen, Alan Langerman, and Susan LoVerso. Programming under Mach. Addison-Wesley, 1994, ISBN 0-201-52739-1.</source>
          <target state="translated">Boykin,Joseph,David Kirschen,Alan Langerman,and Susan LoVerso.马赫下的编程》。Addison-Wesley,1994,ISBN 0-201-52739-1。</target>
        </trans-unit>
        <trans-unit id="cbed39e2d9457a27b38ac123d4072c095875ce37" translate="yes" xml:space="preserve">
          <source>Brace yourself for thanks, bug reports, hate mail and spam coming as result of the previous step. No good deed should remain unpunished!</source>
          <target state="translated">准备好迎接上一步的感谢、错误报告、仇恨邮件和垃圾邮件。好事不出门,坏事传千里!</target>
        </trans-unit>
        <trans-unit id="5fde9354c8205697f6414265780ed0c53484415c" translate="yes" xml:space="preserve">
          <source>Braces are required in referring to named capture groups, but are optional for absolute or relative numbered ones. Braces are safer when creating a regex by concatenating smaller strings. For example if you have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt; , you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="translated">在引用命名的捕获组时，必须使用大括号，但对于绝对编号或相对编号的捕获组则为可选。通过连接较小的字符串创建正则表达式时，花括号更安全。例如，如果您有 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt; ，并且 &lt;code&gt;$a&lt;/code&gt; 包含 &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; ，而 &lt;code&gt;$b&lt;/code&gt; 包含 &lt;code&gt;&quot;37&quot;&lt;/code&gt; ，则将得到 &lt;code&gt;/\g137/&lt;/code&gt; ，这可能不是您想要的。</target>
        </trans-unit>
        <trans-unit id="18fd4ec0e937de91c70828b19eb3454f88d75941" translate="yes" xml:space="preserve">
          <source>Braces are required in referring to named capture groups, but are optional for absolute or relative numbered ones. Braces are safer when creating a regex by concatenating smaller strings. For example if you have &lt;code&gt;qr/$a$b/&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt;, and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt;, you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa9a0b57b5dc549e8decf6cc394f53167efa53b" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a crucial feature of Locale::Maketext. I mean Bracket Notation to provide a replacement for the use of sprintf formatting. Everything you do with Bracket Notation could be done with a sub block, but bracket notation is meant to be much more concise.</source>
          <target state="translated">Bracket Notation是Locale::Maketext的一个重要功能。我的意思是,括号符号提供了一个使用sprintf格式化的替代品。你用括号符号做的所有事情都可以用一个子块来完成,但是括号符号的目的是为了更简洁。</target>
        </trans-unit>
        <trans-unit id="bb9b16ff2deefe21cce7105f1030ffe04c9ef94b" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a like a miniature &quot;template&quot; system (in the sense of &lt;a href=&quot;Text::Template&quot;&gt;Text::Template&lt;/a&gt;, not in the sense of C++ templates), where normal text is passed thru basically as is, but text in special regions is specially interpreted. In Bracket Notation, you use square brackets (&quot;[...]&quot;), not curly braces (&quot;{...}&quot;) to note sections that are specially interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d31b6dcf28abb8afbf24fa97f7391fe87364415" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a like a miniature &quot;template&quot; system (in the sense of &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text::Template&lt;/a&gt;, not in the sense of C++ templates), where normal text is passed thru basically as is, but text in special regions is specially interpreted. In Bracket Notation, you use square brackets (&quot;[...]&quot;), not curly braces (&quot;{...}&quot;) to note sections that are specially interpreted.</source>
          <target state="translated">括号表示法就像一个微型的&amp;ldquo;模板&amp;rdquo;系统（在&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text :: Template&lt;/a&gt;的意义上，而不是在C ++模板的意义上），其中普通文本基本上按原样传递，但是特殊区域中的文本得到了特殊解释。在方括号表示法中，使用方括号（&amp;ldquo; [...]&amp;rdquo;）而不是大括号（&amp;ldquo; {...}&amp;rdquo;）来标注经过特殊解释的部分。</target>
        </trans-unit>
        <trans-unit id="c69ae72aa90270486c045c7a6541cf13d55632e9" translate="yes" xml:space="preserve">
          <source>Bracket Notation is discussed in a later section. Note that trying to compile a string into Bracket Notation can throw an exception if the string is not syntactically valid (say, by not balancing brackets right.)</source>
          <target state="translated">括号符号将在后面的章节中讨论。请注意,如果字符串在语法上无效(例如,没有正确地平衡括号),试图将字符串编译成括号符号会引发异常。</target>
        </trans-unit>
        <trans-unit id="046d4b6cd34c3e66bcd55c31ba3d01db5f8bac76" translate="yes" xml:space="preserve">
          <source>Bracket groups that are empty, or which consist only of whitespace, are ignored. (Examples: &quot;[]&quot;, &quot;[ ]&quot;, or a [ and a ] with returns and/or tabs and/or spaces between them.</source>
          <target state="translated">空的或只有空格的括号组会被忽略。例子:&quot;[]&quot;、&quot;[]&quot;或带有回车和/或制表符和/或空格的[和a]。&quot;[]&quot;、&quot;[]&quot;,或带有回车和/或制表符和/或空格的[和a]。</target>
        </trans-unit>
        <trans-unit id="d96a703ba2e31ec739345b11c90028f276d06d37" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes</source>
          <target state="translated">括号内的字符类</target>
        </trans-unit>
        <trans-unit id="1d6defc184cd831ef1a40a992a7bc00f4a08d7aa" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes and the /xx pattern modifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56159ead51e4e16a6e6e36a9eba26b713462d135" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes and the &lt;code&gt;/xx&lt;/code&gt; pattern modifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd31d2f7c96c6ebd02a583681a9f9dd8128bde2" translate="yes" xml:space="preserve">
          <source>Bracketed character classes are represented by &lt;code&gt;regnode_charclass&lt;/code&gt; structures, which have a four-byte argument and then a 32-byte (256-bit) bitmap indicating which characters in the Latin1 range are included in the class.</source>
          <target state="translated">方括号字符类由 &lt;code&gt;regnode_charclass&lt;/code&gt; 结构表示，该结构具有4字节参数，然后具有32字节（256位）位图，指示该类中包括Latin1范围内的哪些字符。</target>
        </trans-unit>
        <trans-unit id="4f10c5c48b8ce584bf50338e9ce1774e2c591ba3" translate="yes" xml:space="preserve">
          <source>Brackets around a symbolic reference can simply serve to isolate an identifier or variable name from the rest of an expression, just as they always have within a string. For example,</source>
          <target state="translated">符号引用周围的括号可以简单地将标识符或变量名称与表达式的其他部分隔离开来,就像在字符串中一样。例如</target>
        </trans-unit>
        <trans-unit id="ee4272402a91677e15417810bffa7f99811d776d" translate="yes" xml:space="preserve">
          <source>Brackets must be balanced -- every openbracket must have one matching closebracket, and vice versa. So these are all &lt;b&gt;invalid&lt;/b&gt;:</source>
          <target state="translated">括号必须平衡-每个开括号都必须有一个匹配的括号，反之亦然。所以这些都是&lt;b&gt;无效的&lt;/b&gt;：</target>
        </trans-unit>
        <trans-unit id="078f4a9c2a661144675f9e2bfab86b75d63064df" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;</source>
          <target state="translated">布拉德&amp;middot;阿普尔顿&amp;lt;bradapp@enteract.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="976a94f14824f930d58b9616017f2abefc3253d5" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt; (initial version), Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;（初始版本），Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6593228df02466d50b8cc0c36e813c08ba422fcb" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt; (initial version), Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;, Marc Green &amp;lt;marcgreen@cpan.org&amp;gt; (port to Pod::Simple) Ricardo Signes &amp;lt;rjbs@cpan.org&amp;gt; (more porting to Pod::Simple) Karl Williamson &amp;lt;khw@cpan.org&amp;gt; (more porting to Pod::Simple)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd85e7290aa8473e575a87a5fd8b95386788c86e" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;, Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">布拉德&amp;middot;阿普尔顿（Brad Appleton）&amp;lt;bradapp@enteract.com&amp;gt;，马瑞克&amp;middot;鲁沙（Marek Rouchal）&amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ace391da91b3b622751d8ebf145fd4091f241ba4" translate="yes" xml:space="preserve">
          <source>Brad Gilbert &amp;lt;bgills@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae43dcfe840a5e3a18a13f5b3acd9cb0f221ef8" translate="yes" xml:space="preserve">
          <source>Brandon Browning,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ea19e07547da7e5f6a43b6c0892e4265aeebb1" translate="yes" xml:space="preserve">
          <source>Brandon L. Black, &amp;lt;blblack@gmail.com&amp;gt;</source>
          <target state="translated">布兰登&amp;middot;布莱克（Brandon L.Black），&amp;lt;blblack@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6fb6fe57c36bfedd5ff6f16a948fc45d01c7d083" translate="yes" xml:space="preserve">
          <source>Branislav Zahradnik &amp;lt;barney@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37497aa5a2272c49714aee1b07e8edf973a95f59" translate="yes" xml:space="preserve">
          <source>Brazil</source>
          <target state="translated">Brazil</target>
        </trans-unit>
        <trans-unit id="eca2fc6f92666147ac6a607129bb8a0811237538" translate="yes" xml:space="preserve">
          <source>Break out of a &lt;code&gt;given()&lt;/code&gt; block.</source>
          <target state="translated">突破 &lt;code&gt;given()&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="70e84e284b7238bd647c1d2ad9dae3dcf040b2c5" translate="yes" xml:space="preserve">
          <source>Break out of a &lt;code&gt;given&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d93607f829e7fe2aafd920d3e1c2e3753bb301" translate="yes" xml:space="preserve">
          <source>Break the execution of your program if the module you &lt;code&gt;autouse&lt;/code&gt; d has some initialization which it expects to be done early.</source>
          <target state="translated">如果您要 &lt;code&gt;autouse&lt;/code&gt; 使用的模块进行了一些初始化，希望可以尽早完成，请中断程序的执行。</target>
        </trans-unit>
        <trans-unit id="848f64a4802a4e63379bfcaf66c37f0f07a8afee" translate="yes" xml:space="preserve">
          <source>Break the execution of your program if the module you &lt;code&gt;autouse&lt;/code&gt;d has some initialization which it expects to be done early.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e308eb5b16f38422b4dd55b2c10339c108233c" translate="yes" xml:space="preserve">
          <source>Break up text into lines according to Unicode rules.</source>
          <target state="translated">根据Unicode规则将文本分成几行。</target>
        </trans-unit>
        <trans-unit id="5ad0b6bff702cd07f8dbaf1cb4107d1095e60662" translate="yes" xml:space="preserve">
          <source>Break-out the reusable code into one or more separate module files.</source>
          <target state="translated">将可重用的代码分解成一个或多个独立的模块文件。</target>
        </trans-unit>
        <trans-unit id="f19f6b051659b65527c1cf48996b006f5fcd4db1" translate="yes" xml:space="preserve">
          <source>Breakable lines are marked with &lt;code&gt;:&lt;/code&gt; . Lines with breakpoints are marked by &lt;code&gt;b&lt;/code&gt; and those with actions by &lt;code&gt;a&lt;/code&gt; . The line that's about to be executed is marked by &lt;code&gt;==&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">易碎线标有 &lt;code&gt;:&lt;/code&gt; 。断点行被标记为 &lt;code&gt;b&lt;/code&gt; 和那些通过行动 &lt;code&gt;a&lt;/code&gt; 。将要执行的行由 &lt;code&gt;==&amp;gt;&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="4cca55190538278526fdb090660eae35486629fc" translate="yes" xml:space="preserve">
          <source>Breakable lines are marked with &lt;code&gt;:&lt;/code&gt;. Lines with breakpoints are marked by &lt;code&gt;b&lt;/code&gt; and those with actions by &lt;code&gt;a&lt;/code&gt;. The line that's about to be executed is marked by &lt;code&gt;==&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73cb8429b43020f4d84d456449c4c5b228dde417" translate="yes" xml:space="preserve">
          <source>Breaking gettext</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02352bb0ba7c8d9b86acca1b53f9d1e7553bf956" translate="yes" xml:space="preserve">
          <source>Breaking out</source>
          <target state="translated">突破</target>
        </trans-unit>
        <trans-unit id="b58f4abd812365aa3e9bf665a84c1fa3c88cdbc5" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a DBM file and a hash.</source>
          <target state="translated">破坏DBM文件和哈希之间的绑定。</target>
        </trans-unit>
        <trans-unit id="fece5a66de93443d7bff991c12beae4eb8074f61" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a variable and a package. (See &lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;tie&lt;/a&gt;.) Has no effect if the variable is not tied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4964084eb3d73be96dd1eeb1af8495c4dc61d5f9" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a variable and a package. (See &lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;tie&lt;/a&gt;.) Has no effect if the variable is not tied.</source>
          <target state="translated">中断变量和包之间的绑定。（请参见&lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;tie&lt;/a&gt;。）如果未绑定变量，则无效。</target>
        </trans-unit>
        <trans-unit id="ebcffdb904889257c266769aa18189925f0f7c13" translate="yes" xml:space="preserve">
          <source>Brent Powers has a &lt;code&gt;Memoize::ExpireLRU&lt;/code&gt; module that was designed to work with Memoize and provides expiration of least-recently-used data. The cache is held at a fixed number of entries, and when new data comes in, the least-recently used data is expired. See &lt;a href=&quot;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&quot;&gt;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&lt;/a&gt;.</source>
          <target state="translated">Brent Powers具有一个 &lt;code&gt;Memoize::ExpireLRU&lt;/code&gt; 模块，该模块旨在与Memoize一起使用，并提供最近最少使用的数据的到期时间。高速缓存保存在固定数量的条目中，当新数据进入时，最近最少使用的数据将过期。请参阅&lt;a href=&quot;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&quot;&gt;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c27cf707cf417ff0a776233c5044d0c0f1f7ca1a" translate="yes" xml:space="preserve">
          <source>Brian Fraser &amp;lt;fraserbn@gmail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f48c0d1bc27a1a6d3322c34a40dc48ed4836827" translate="yes" xml:space="preserve">
          <source>Brian Mowrey &amp;lt;brian@drlabs.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67acd53896f7915d6e2dc925e202a5731fc6800" translate="yes" xml:space="preserve">
          <source>Briefly, &lt;code&gt;/l&lt;/code&gt; sets the character set to that of whatever &lt;b&gt;L&lt;/b&gt;ocale is in effect at the time of the execution of the pattern match.</source>
          <target state="translated">简而言之， &lt;code&gt;/l&lt;/code&gt; 将字符集设置为执行模式匹配时有效的任何&lt;b&gt;L&lt;/b&gt; ocale 的字符集。</target>
        </trans-unit>
        <trans-unit id="617a3fbf545ee5333943d4e71b255277bef3b51a" translate="yes" xml:space="preserve">
          <source>Broadcast =&amp;gt; BOOL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1d6e87ca75e40a64b990a2d32b737b491cbea9" translate="yes" xml:space="preserve">
          <source>Broadly speaking, performing a match of a string against a pattern involves the following steps:</source>
          <target state="translated">广义上讲,将一个字符串与一个模式进行匹配包括以下步骤。</target>
        </trans-unit>
        <trans-unit id="b0f84539efd4151eb704c02dcc4f761c1702c86d" translate="yes" xml:space="preserve">
          <source>Broken systems</source>
          <target state="translated">破损的系统</target>
        </trans-unit>
        <trans-unit id="1def5ba77699f04961452989de376f438210ae2b" translate="yes" xml:space="preserve">
          <source>Bucket Order Perturbance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93b6657484eea5e944049ac0b3ddce1a19d87f5" translate="yes" xml:space="preserve">
          <source>Buffer overflow in prime_env_iter: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6990bb386cb0f2d9d5ad6fab5909ce4fbcb2fd" translate="yes" xml:space="preserve">
          <source>Buffer scalar containing the chunk currently under consideration of the text currently being lexed. This is always a plain string scalar (for which &lt;code&gt;SvPOK&lt;/code&gt; is true). It is not intended to be used as a scalar by normal scalar means; instead refer to the buffer directly by the pointer variables described below.</source>
          <target state="translated">缓冲区标量，其中包含当前正在考虑的当前正在处理的文本块。这始终是纯字符串标量（其 &lt;code&gt;SvPOK&lt;/code&gt; 为true）。不能将其用作常规标量方法的标量；而是直接通过下面描述的指针变量来引用缓冲区。</target>
        </trans-unit>
        <trans-unit id="aaf695eeaf0754918bfdf3c63ed153867d69dfcf" translate="yes" xml:space="preserve">
          <source>Bug reports and other feedback are most welcome.</source>
          <target state="translated">最欢迎BUG报告和其他反馈。</target>
        </trans-unit>
        <trans-unit id="4a6ed58e35768beb4922face36916e3eb34ceb32" translate="yes" xml:space="preserve">
          <source>Bug reports should be submitted to the GitHub issue tracker at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;. The &lt;b&gt;perlbug@perl.org&lt;/b&gt; address no longer automatically opens tickets. You can use this tool to compose your report and save it to a file which you can then submit to the issue tracker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3dfa0b6c5b9a870507e0243e43fe93803edb544" translate="yes" xml:space="preserve">
          <source>Bug reports, patches, and nagging provided by lots of folks-- thanks everybody! Special thanks to Michael Schwern &amp;lt;schwern@envirolink.org&amp;gt; for assuring me that a &amp;amp;nested_quotewords() would be useful, and to Jeff Friedl &amp;lt;jfriedl@yahoo-inc.com&amp;gt; for telling me not to worry about error-checking (sort of-- you had to be there).</source>
          <target state="translated">许多人提供的错误报告，补丁和na-谢谢大家！特别感谢Michael Schwern &amp;lt;schwern@envirolink.org&amp;gt;向我保证＆nested_quotewords（）很有用，并感谢Jeff Friedl &amp;lt;jfriedl@yahoo-inc.com&amp;gt;告诉我不要担心错误检查（有点像-您必须在那里。</target>
        </trans-unit>
        <trans-unit id="829fe5647d6ef5dc40cbf31334f7d303909516a7" translate="yes" xml:space="preserve">
          <source>Bug-fixing by Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2010-2011.</source>
          <target state="translated">Peter John Acklam的错误修复&amp;lt;pjacklam@online.no&amp;gt; 2010-2011。</target>
        </trans-unit>
        <trans-unit id="238715da3b418db89372b9015297a37b9b381344" translate="yes" xml:space="preserve">
          <source>Bug-fixing by Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2010-2016.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="60757698bb42548c3dda76e0d4ec377b0dd06d65" translate="yes" xml:space="preserve">
          <source>Bugs (and requests for new features) can be reported to the author though GitHub: &lt;a href=&quot;https://github.com/Test-More/test-more/issues&quot;&gt;https://github.com/Test-More/test-more/issues&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f308ba7fc80d9c9a972b67a64671b669a27d16c" translate="yes" xml:space="preserve">
          <source>Bugs (and requests for new features) can be reported to the author though the CPAN RT system: &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&lt;/a&gt;</source>
          <target state="translated">可以通过CPAN RT系统将错误（和对新功能的请求）报告给作者：&lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&quot;&gt;http&lt;/a&gt; ://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester</target>
        </trans-unit>
        <trans-unit id="888b6006f2872d22aaa1cd6bce9e12ccb31d9655" translate="yes" xml:space="preserve">
          <source>Bugs / Feature Requests</source>
          <target state="translated">错误/功能要求</target>
        </trans-unit>
        <trans-unit id="58d170e283eb8eb2d13abdce7bd1aa5026377f10" translate="yes" xml:space="preserve">
          <source>Bugs may be submitted at &lt;a href=&quot;https://github.com/houseabsolute/Time-Local/issues&quot;&gt;https://github.com/houseabsolute/Time-Local/issues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a450dc1be8865ad9e376ea507387ccd3c0e65886" translate="yes" xml:space="preserve">
          <source>Bugs may be submitted through &lt;a href=&quot;https://rt.cpan.org/Public/Dist/Display.html?Name=File-Temp&quot;&gt;the RT bug tracker&lt;/a&gt; (or &lt;a href=&quot;mailto:bug-File-Temp@rt.cpan.org&quot;&gt;bug-File-Temp@rt.cpan.org&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147820deb7b5b2f1e33d540237db5f728a826fed" translate="yes" xml:space="preserve">
          <source>Bugs may be submitted through &lt;a href=&quot;https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Metadata&quot;&gt;the RT bug tracker&lt;/a&gt; (or &lt;a href=&quot;mailto:bug-Module-Metadata@rt.cpan.org&quot;&gt;bug-Module-Metadata@rt.cpan.org&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798e9f12ff638512bcd89953d3735c6b7ab1cee3" translate="yes" xml:space="preserve">
          <source>Bugs you don't plan to fix. :-)</source>
          <target state="translated">你不打算修复的错误。 :-)</target>
        </trans-unit>
        <trans-unit id="bbd80cf7e2ded5efed8f4ee9151ab57a8ab66392" translate="yes" xml:space="preserve">
          <source>Build</source>
          <target state="translated">Build</target>
        </trans-unit>
        <trans-unit id="a3c79824d95086093512b52d7ab25ad53dd0d923" translate="yes" xml:space="preserve">
          <source>Build Anomalies with Perl on OS/390</source>
          <target state="translated">在OS/390上使用Perl构建异常点。</target>
        </trans-unit>
        <trans-unit id="8197039c73f48aefe4687141c68ac9ca58ef8d5e" translate="yes" xml:space="preserve">
          <source>Build FAQ</source>
          <target state="translated">构建常见问题</target>
        </trans-unit>
        <trans-unit id="4f1a5b2e8fc6f3c96b77575a0eaa73b7619bef70" translate="yes" xml:space="preserve">
          <source>Build Prerequisites for Perl on AmigaOS</source>
          <target state="translated">在AmigaOS上构建Perl的前提条件。</target>
        </trans-unit>
        <trans-unit id="431713be1df25e40d76ce4972f5897bc2ac46f53" translate="yes" xml:space="preserve">
          <source>Build an iterator which finds distroprefs files in the tree below the given directory. Within the tree directories matching &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m/^[._]/&lt;/a&gt;&lt;/code&gt; are pruned.</source>
          <target state="translated">构建一个迭代器，该迭代器在给定目录下的树中查找distroprefs文件。在树中，匹配 &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m/^[._]/&lt;/a&gt;&lt;/code&gt; 目录被修剪。</target>
        </trans-unit>
        <trans-unit id="1f5e8d7b401e7067eefc5a283830fcc846d1ee9e" translate="yes" xml:space="preserve">
          <source>Build an iterator which finds distroprefs files in the tree below the given directory. Within the tree directories matching &lt;code&gt;m/^[._]/&lt;/code&gt; are pruned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f0d013521af98c935739685e85fd389eb57d10" translate="yes" xml:space="preserve">
          <source>Build hash based classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025fef91894be2ceb7f450be64f484f9a3dfd148" translate="yes" xml:space="preserve">
          <source>Build instructions for OS/2, &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;</source>
          <target state="translated">OS / 2，&lt;a href=&quot;perlos2&quot;&gt;perlos2的&lt;/a&gt;构建说明</target>
        </trans-unit>
        <trans-unit id="6a0c26b6e73b4a14e003052fbfb474ae81ddeb3d" translate="yes" xml:space="preserve">
          <source>Build instructions for Win32 in &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;, or under the Cygnus environment in &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt;.</source>
          <target state="translated">在为Win32构建指令&lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;，或天鹅环境下&lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec272960803bf0c1141ddb2cc450b8e7bb399d9c" translate="yes" xml:space="preserve">
          <source>Build man pages, too</source>
          <target state="translated">构建人页,也</target>
        </trans-unit>
        <trans-unit id="6e79e48e57f84dbe7fa157bde2a3fead704bb75d" translate="yes" xml:space="preserve">
          <source>Build system</source>
          <target state="translated">构建系统</target>
        </trans-unit>
        <trans-unit id="857fee8f38d36d4d66b3ca310ad74ff4223ccbe4" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the UTF-8 encoded string &lt;code&gt;spv&lt;/code&gt;, length &lt;code&gt;len&lt;/code&gt;, the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &lt;code&gt;&quot;...&quot;&lt;/code&gt; will be appended).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f324587551677d6f64a6a55d81e5c02c33aaa350" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the scalar &lt;code&gt;sv&lt;/code&gt; , the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">在标量 &lt;code&gt;dsv&lt;/code&gt; 上构建标量 &lt;code&gt;sv&lt;/code&gt; 的可显示版本，该可显示版本最多为 &lt;code&gt;pvlim&lt;/code&gt; 字节长（如果更长，则其余部分将被截断并附加&amp;ldquo; ...&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="46af0313d23f0c460bfa1f3a9e5387975e8b2b74" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the scalar &lt;code&gt;sv&lt;/code&gt;, the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc42dbdb87c5e71f504c4dbe80214e6754c41fcb" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the string &lt;code&gt;spv&lt;/code&gt; , length &lt;code&gt;len&lt;/code&gt; , the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">将标量 &lt;code&gt;dsv&lt;/code&gt; 的可显示版本构建为字符串 &lt;code&gt;spv&lt;/code&gt; ，长度 &lt;code&gt;len&lt;/code&gt; ，该可显示版本最多为 &lt;code&gt;pvlim&lt;/code&gt; 个字节长（如果更长，则其余部分将被截断并附加&amp;ldquo; ...&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="c6bd3f51881e4d26f104fbcd7a9347aa8d6d5282" translate="yes" xml:space="preserve">
          <source>Build, Configure, Make, Install</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c215cd495fbe90044cc607bb79e970dde2b9028" translate="yes" xml:space="preserve">
          <source>Build, Test, Install Perl on OS/390</source>
          <target state="translated">在OS/390上构建、测试、安装Perl。</target>
        </trans-unit>
        <trans-unit id="249199540ceee6ec6b4a1f1daa24666f4aa042eb" translate="yes" xml:space="preserve">
          <source>Build.PL</source>
          <target state="translated">Build.PL</target>
        </trans-unit>
        <trans-unit id="4759bf14d7a511508e86c343c934894b6e8db533" translate="yes" xml:space="preserve">
          <source>Builder</source>
          <target state="translated">Builder</target>
        </trans-unit>
        <trans-unit id="52b5e661f9ecf45eed9a8b41756d5844802fbce9" translate="yes" xml:space="preserve">
          <source>Builder class for Windows platforms</source>
          <target state="translated">Windows平台的生成器类</target>
        </trans-unit>
        <trans-unit id="9d914bfcf1c5bc9e6b83d3232349cae23d392f30" translate="yes" xml:space="preserve">
          <source>Building</source>
          <target state="translated">Building</target>
        </trans-unit>
        <trans-unit id="2ed0dadcc70796d33055d55283657d04fb0c039a" translate="yes" xml:space="preserve">
          <source>Building 32-bit Perl in Irix</source>
          <target state="translated">在Irix中构建32位Perl</target>
        </trans-unit>
        <trans-unit id="977f968c44ef127f7e68a4bbd06a3bc09d574a03" translate="yes" xml:space="preserve">
          <source>Building 64-bit Perl in Irix</source>
          <target state="translated">在Irix中构建64位Perl</target>
        </trans-unit>
        <trans-unit id="a68801656d21c1742976b2a26b0d97ca179190db" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on AIX</source>
          <target state="translated">在AIX上构建动态扩展</target>
        </trans-unit>
        <trans-unit id="cdc5004f31232806335a1cd820513add0b5ef95f" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on AIX &amp;lt; 5L</source>
          <target state="translated">在AIX &amp;lt;5L上构建动态扩展</target>
        </trans-unit>
        <trans-unit id="60eeab40d6adc2fe265d128c48b6aa4e93a2fcb8" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on HP-UX</source>
          <target state="translated">在HP-UX上构建动态扩展</target>
        </trans-unit>
        <trans-unit id="e3d2578989b066f6d4e0e3d492f28b294aef6801" translate="yes" xml:space="preserve">
          <source>Building Extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cca0ab4039ae032282d3c4fa53d7e82995e8594" translate="yes" xml:space="preserve">
          <source>Building Non-XS Modules on DOS</source>
          <target state="translated">在DOS上构建非XS模块</target>
        </trans-unit>
        <trans-unit id="e58f39330e280e7de8b3b247f8f97aeb868e7743" translate="yes" xml:space="preserve">
          <source>Building Perl for WinCE</source>
          <target state="translated">为WinCE构建Perl</target>
        </trans-unit>
        <trans-unit id="9e84e0a9f11037f0b7fccbdd30b3def3e1270535" translate="yes" xml:space="preserve">
          <source>Building Perl on DOS</source>
          <target state="translated">在DOS上构建Perl</target>
        </trans-unit>
        <trans-unit id="107439a62a7c6f42562b678d76f2e80c36c5eb66" translate="yes" xml:space="preserve">
          <source>Building Prerequisites for Perl on DOS</source>
          <target state="translated">在DOS上构建Perl的前提条件</target>
        </trans-unit>
        <trans-unit id="b5ced49870fdf0851779593a86211e669aed437d" translate="yes" xml:space="preserve">
          <source>Building XS Modules on DOS</source>
          <target state="translated">在DOS上构建XS模块</target>
        </trans-unit>
        <trans-unit id="16ea3711da90cdc1ad8b70bb59bd87c31033d7af" translate="yes" xml:space="preserve">
          <source>Building a 64-bit capable gcc on PA-RISC from source is possible only when you have the HP C-ANSI C compiler or an already working 64-bit binary of gcc available. Best performance for perl is achieved with HP's native compiler.</source>
          <target state="translated">只有当你拥有HP C-ANSI C编译器或已经可以使用的64位gcc二进制文件时,才有可能在PA-RISC上从源码上构建一个64位的gcc。使用HP的原生编译器可以获得perl的最佳性能。</target>
        </trans-unit>
        <trans-unit id="b06d77f19e3d0e1947de8d417eb97b9240aba5fe" translate="yes" xml:space="preserve">
          <source>Building a binary distribution</source>
          <target state="translated">建立一个二进制分布</target>
        </trans-unit>
        <trans-unit id="5eaf641b2cc432d339298d2d7667c55e1df71877" translate="yes" xml:space="preserve">
          <source>Building a regexp</source>
          <target state="translated">建立一个regexp</target>
        </trans-unit>
        <trans-unit id="4f3097c147e745c265a4f8606c6e810a7ad5d9f4" translate="yes" xml:space="preserve">
          <source>Building an LP64 perl</source>
          <target state="translated">建立一个LP64的perl</target>
        </trans-unit>
        <trans-unit id="d601de14ddca518b95c2c6d816b3b797646fe162" translate="yes" xml:space="preserve">
          <source>Building custom</source>
          <target state="translated">定制建筑</target>
        </trans-unit>
        <trans-unit id="38b3b94607428da1a192459760b9b24f29336537" translate="yes" xml:space="preserve">
          <source>Building custom .EXE files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94d1d0131bb7b5bab11d8fd5a13a49d41b119105" translate="yes" xml:space="preserve">
          <source>Building custom _.EXE_ files</source>
          <target state="translated">建立自定义_.EXE_文件</target>
        </trans-unit>
        <trans-unit id="e10bbd8c13474666bee2a919ca9d0cf777bfbdb2" translate="yes" xml:space="preserve">
          <source>Building debugging-enabled binaries (with -g or -g3) will increase the chance of getting these errors. Prevent -g if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60333d2c51f8933ea40f3711d31effe77527e1a4" translate="yes" xml:space="preserve">
          <source>Building perl at older commits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58685fabffe8d566dcf90fc429e9988b44fb72cb" translate="yes" xml:space="preserve">
          <source>Building should proceed differently depending on whether the version of perl you install is already present and used on your system, or is a new version not yet used. The description below assumes that the version is new, so installing its DLLs and</source>
          <target state="translated">根据你安装的perl版本是否已经存在并在你的系统中使用,或者是尚未使用的新版本,构建过程应该有所不同。下面的描述假设这个版本是新的,所以安装它的DLLs和</target>
        </trans-unit>
        <trans-unit id="25399d44a6d52942b965d7741dfbe5b98c44e3b6" translate="yes" xml:space="preserve">
          <source>Building with threads in Irix</source>
          <target state="translated">在Irix中使用螺纹构建</target>
        </trans-unit>
        <trans-unit id="c882cff5cf66c8bc0ee9d0ac391aee6b3e4faba4" translate="yes" xml:space="preserve">
          <source>Buildtype.bat</source>
          <target state="translated">Buildtype.bat</target>
        </trans-unit>
        <trans-unit id="167534462e1810e98824021557fb475fd2cb9f52" translate="yes" xml:space="preserve">
          <source>Built-in Attributes</source>
          <target state="translated">内置属性</target>
        </trans-unit>
        <trans-unit id="03c641eb4ff3905fcf16d5ff9fd329806e0d8127" translate="yes" xml:space="preserve">
          <source>Built-in Encodings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a254cda26c62367280124a0a97ba97ac0047a0c1" translate="yes" xml:space="preserve">
          <source>Builtin operators and functions</source>
          <target state="translated">内置的运算器和功能</target>
        </trans-unit>
        <trans-unit id="82bac8de7c475e9a140fc89ca8b2ed3375482576" translate="yes" xml:space="preserve">
          <source>Builtin types include:</source>
          <target state="translated">内置类型包括:</target>
        </trans-unit>
        <trans-unit id="5c77726358c5daf98ad9cdccd0882bca0f718b88" translate="yes" xml:space="preserve">
          <source>Bulgaria</source>
          <target state="translated">Bulgaria</target>
        </trans-unit>
        <trans-unit id="572f7127eed71e662d147110ecd2618b7d80c972" translate="yes" xml:space="preserve">
          <source>Bultibuffer count</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c511a735d99d5e1aad2b7d21a4ed9e5dff3aca" translate="yes" xml:space="preserve">
          <source>Bumped version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbadec79c760a0615a7745522920ce54712b347a" translate="yes" xml:space="preserve">
          <source>Bundle/Snapshot_2012_05_21_00.pm</source>
          <target state="translated">Bundle/Snapshot_2012_05_21_00.pm</target>
        </trans-unit>
        <trans-unit id="c1d562515d11cd030821deea9c673716499b48ca" translate="yes" xml:space="preserve">
          <source>Bundled Encode::Locale</source>
          <target state="translated">捆绑式编码器::Locale</target>
        </trans-unit>
        <trans-unit id="9a033a116a34993104733ddb8e62da3f808f4b18" translate="yes" xml:space="preserve">
          <source>Bundles</source>
          <target state="translated">Bundles</target>
        </trans-unit>
        <trans-unit id="57402f7215532c14b5a4891e2bc99d5f27572992" translate="yes" xml:space="preserve">
          <source>Bundles are treated specially in the CPAN package. If you say 'install Bundle::Tkkit' (assuming such a bundle exists), CPAN will install all the modules in the CONTENTS section of the pod. You can install your own Bundles locally by placing a conformant Bundle file somewhere into your @INC path. The autobundle() command which is available in the shell interface does that for you by including all currently installed modules in a snapshot bundle file.</source>
          <target state="translated">捆绑包在CPAN包中被特殊处理。如果你说 &quot;install Bundle::Tkkit&quot;(假设存在这样一个Bundle),CPAN将安装pod的CONTENTS部分的所有模块。你可以通过在你的 @INC 路径中的某个地方放置一个符合要求的 Bundle 文件来在本地安装你自己的 Bundles。shell 界面中的 autobundle()命令通过将所有当前安装的模块包含在一个快照 bundle 文件中来实现。</target>
        </trans-unit>
        <trans-unit id="654a81f2d3a7234ab3c1e3ba078dd1e95b9d8acf" translate="yes" xml:space="preserve">
          <source>Bundling</source>
          <target state="translated">Bundling</target>
        </trans-unit>
        <trans-unit id="d01b7bc2d8bcb3e8147c5617d5cc44c01b525846" translate="yes" xml:space="preserve">
          <source>But</source>
          <target state="translated">But</target>
        </trans-unit>
        <trans-unit id="4409f482ed69df6dea8ad78ddaf1fc21ee472c98" translate="yes" xml:space="preserve">
          <source>But (for the foreseeable future), Pod does not provide any way for Pod authors to distinguish which grouping is meant by the above &quot;=item&quot;-cluster structure. So formatters should format it like so:</source>
          <target state="translated">但是(在可预见的将来),Pod并没有提供任何方法让Pod作者区分上述&quot;=item&quot;-cluster结构是指哪种分组。所以格式化者应该这样格式化。</target>
        </trans-unit>
        <trans-unit id="90e0c4e431de8ceb3ea88d2476b9cdf6b06e1777" translate="yes" xml:space="preserve">
          <source>But I consider that somewhat of a distraction from the work of getting the main code working -- to say nothing of the fact that I often have to play with the program a few times before I can decide exactly what wording I want in the messages (which in this case would require me to go changing three lines of code: the call to maketext with that key, and then the two lines in ThisProject/I18N/en.pm).</source>
          <target state="translated">但我认为这有点分散了我对主代码工作的注意力--更不用说我经常要在程序中玩几次才能准确地决定我想要的消息中的措辞(在这种情况下,我需要去改变三行代码:用那个键调用maketext,然后是ThisProject/I18N/en.pm中的两行)。</target>
        </trans-unit>
        <trans-unit id="68ec332e5b845e28e04fd0941baf17f046ea1744" translate="yes" xml:space="preserve">
          <source>But Perl treats &lt;code&gt;\n&lt;/code&gt; as the start- and end-line delimiter, whereas Unicode specifies more characters that should be so-interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab00dd7d452b56d9f0d69d34971f4ee775260627" translate="yes" xml:space="preserve">
          <source>But Unicode's intent is to unify the existing character set standards and practices, and several pre-existing standards have single characters that mean the same thing as some of these combinations, like ISO-8859-1, which has quite a few of them. For example, &lt;code&gt;&quot;LATIN CAPITAL LETTER E
WITH ACUTE&quot;&lt;/code&gt; was already in this standard when Unicode came along. Unicode therefore added it to its repertoire as that single character. But this character is considered by Unicode to be equivalent to the sequence consisting of the character &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; followed by the character &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; .</source>
          <target state="translated">但是Unicode的目的是统一现有的字符集标准和实践，并且几个预先存在的标准具有单个字符，这些字符与这些组合中的某些组合（例如ISO-8859-1）具有相同的含义。例如，当Unicode出现时， &lt;code&gt;&quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;&lt;/code&gt; 字母E&amp;rdquo;已经在此标准中。因此，Unicode将它作为单个字符添加到其库中。但是，Unicode认为此字符等效于由字符 &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; 大写字母E&amp;rdquo;和字符 &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; 组成的序列。</target>
        </trans-unit>
        <trans-unit id="cc372f6b713e0d837f8396fac1cbf07d86470ffa" translate="yes" xml:space="preserve">
          <source>But Unicode's intent is to unify the existing character set standards and practices, and several pre-existing standards have single characters that mean the same thing as some of these combinations, like ISO-8859-1, which has quite a few of them. For example, &lt;code&gt;&quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;&lt;/code&gt; was already in this standard when Unicode came along. Unicode therefore added it to its repertoire as that single character. But this character is considered by Unicode to be equivalent to the sequence consisting of the character &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; followed by the character &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e01ae5e7eb5b2bd27e52f97c45f989f3f7c27c0" translate="yes" xml:space="preserve">
          <source>But a warning is in order. When using the following to make a copy of a number, only a shallow copy will be made.</source>
          <target state="translated">但要提醒大家的是。当使用下面的方法对一个数字进行复制时,只能进行浅层复制。</target>
        </trans-unit>
        <trans-unit id="402f2e961d9afb45626c390dcfdcf325381214c3" translate="yes" xml:space="preserve">
          <source>But any modifiers will still apply to all the components:</source>
          <target state="translated">但任何修改器仍将适用于所有组件。</target>
        </trans-unit>
        <trans-unit id="066f97bc3c6fb6f4f0d1613419193dc5c411fa60" translate="yes" xml:space="preserve">
          <source>But as you might well imagine, this can get pretty rough on the reader.</source>
          <target state="translated">但正如你可以想象的那样,这对读者来说可能会变得相当粗糙。</target>
        </trans-unit>
        <trans-unit id="52f632f5c831c8135e210771e0889bbe7f7800a2" translate="yes" xml:space="preserve">
          <source>But assignment of weight for CJK unified ideographs in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, weights for CJK unified ideographs are treated as undefined. However when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8, &lt;code&gt;(overrideCJK =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; has no special meaning.</source>
          <target state="translated">但是在 &lt;code&gt;table&lt;/code&gt; 或 &lt;code&gt;entry&lt;/code&gt; 为CJK统一表意文字分配权重仍然有效。如果将 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 作为此键的值显式传递，则CJK统一表意文字的权重将被视为未定义。但是，当 &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8时， &lt;code&gt;(overrideCJK =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; 没有特殊含义。</target>
        </trans-unit>
        <trans-unit id="3d36eb62a097e882438bf9a3637e15c6d9e493e5" translate="yes" xml:space="preserve">
          <source>But assignment of weight for CJK unified ideographs in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid. If &lt;code&gt;undef&lt;/code&gt; is passed explicitly as the value for this key, weights for CJK unified ideographs are treated as undefined. However when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8, &lt;code&gt;(overrideCJK =&amp;gt; undef)&lt;/code&gt; has no special meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e716943619b45aa9ba23cbbf0f24483f934af2" translate="yes" xml:space="preserve">
          <source>But be quite sure that &lt;code&gt;ok&lt;/code&gt; is called exactly as many times in the first block as &lt;code&gt;skip&lt;/code&gt; is called in the second block.</source>
          <target state="translated">但是一定要确保在第一个块中调用 &lt;code&gt;ok&lt;/code&gt; 的次数与在第二个块中调用 &lt;code&gt;skip&lt;/code&gt; 的次数相同。</target>
        </trans-unit>
        <trans-unit id="6a9db2da200feea27e3e89ec89ca9f8bf249bcbc" translate="yes" xml:space="preserve">
          <source>But both are slower than assigning the empty list or undefining %HASH or @ARRAY, which is the customary way to empty out an aggregate:</source>
          <target state="translated">但这两种方法都比分配空列表或未定义%HASH或@ARRAY要慢,后者是清空集合的习惯方法。</target>
        </trans-unit>
        <trans-unit id="527a74597b28c7ec00ae7d09430ff9201f3f5a87" translate="yes" xml:space="preserve">
          <source>But don't bother him, he's retired.</source>
          <target state="translated">但不要打扰他,他已经退休了。</target>
        </trans-unit>
        <trans-unit id="04440d595d2cdff8c05a9e9393436d8792f429f8" translate="yes" xml:space="preserve">
          <source>But don't put</source>
          <target state="translated">但不要把</target>
        </trans-unit>
        <trans-unit id="9491e2071e60f65ae593369952ca1ddd75bbfad0" translate="yes" xml:space="preserve">
          <source>But due to an unfixable bug (fixing it would break lots of existing CPAN modules) in the typemap file, the reference count of the &lt;code&gt;AV *&lt;/code&gt; is not properly decremented. Thus, the above XSUB would leak memory whenever it is being called. The same problem exists for &lt;code&gt;HV *&lt;/code&gt; , &lt;code&gt;CV *&lt;/code&gt; , and &lt;code&gt;SVREF&lt;/code&gt; (which indicates a scalar reference, not a general &lt;code&gt;SV *&lt;/code&gt; ). In XS code on perls starting with perl 5.16, you can override the typemaps for any of these types with a version that has proper handling of refcounts. In your &lt;code&gt;TYPEMAP&lt;/code&gt; section, do</source>
          <target state="translated">但是由于类型图文件中存在无法修复的错误（修复该错误会破坏很多现有的CPAN模块），因此 &lt;code&gt;AV *&lt;/code&gt; 的引用计数未适当减少。因此，上述XSUB每当被调用时都会泄漏内存。 &lt;code&gt;HV *&lt;/code&gt; ， &lt;code&gt;CV *&lt;/code&gt; 和 &lt;code&gt;SVREF&lt;/code&gt; 存在相同的问题（这表示标量参考，而不是一般的 &lt;code&gt;SV *&lt;/code&gt; ）。在以perl 5.16开头的perl的XS代码中，您可以使用对引用计数进行适当处理的版本覆盖这些类型中的任何类型的类型映射。在您的 &lt;code&gt;TYPEMAP&lt;/code&gt; 部分中，执行</target>
        </trans-unit>
        <trans-unit id="3bda93cc7a8a89f24895e1ee457675fc5ec79f7f" translate="yes" xml:space="preserve">
          <source>But due to an unfixable bug (fixing it would break lots of existing CPAN modules) in the typemap file, the reference count of the &lt;code&gt;AV *&lt;/code&gt; is not properly decremented. Thus, the above XSUB would leak memory whenever it is being called. The same problem exists for &lt;code&gt;HV *&lt;/code&gt;, &lt;code&gt;CV *&lt;/code&gt;, and &lt;code&gt;SVREF&lt;/code&gt; (which indicates a scalar reference, not a general &lt;code&gt;SV *&lt;/code&gt;). In XS code on perls starting with perl 5.16, you can override the typemaps for any of these types with a version that has proper handling of refcounts. In your &lt;code&gt;TYPEMAP&lt;/code&gt; section, do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9ca11f359e927d9da9a4e640717e37037c1c98" translate="yes" xml:space="preserve">
          <source>But easiest is, if the character is specifiable as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;%&quot;&lt;/code&gt; , to use that; if not so specificable, you can use use &lt;code&gt;\N{}&lt;/code&gt; , if the side effects aren't troublesome. Simply specify all your characters in hex, using &lt;code&gt;\N{U+ZZ}&lt;/code&gt; instead of &lt;code&gt;\xZZ&lt;/code&gt; . &lt;code&gt;\N{}&lt;/code&gt; is the Unicode name, and so it always gives you the Unicode character. &lt;code&gt;\N{U+41}&lt;/code&gt; is the character whose Unicode code point is &lt;code&gt;0x41&lt;/code&gt; , hence is &lt;code&gt;'A'&lt;/code&gt; on all platforms. The side effects are:</source>
          <target state="translated">但是最简单的是，如果该字符可指定为文字，例如 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;%&quot;&lt;/code&gt; ，则使用它；如果不是很明确，则可以使用 &lt;code&gt;\N{}&lt;/code&gt; ，如果副作用没有问题。只需使用 &lt;code&gt;\N{U+ZZ}&lt;/code&gt; 而不是 &lt;code&gt;\xZZ&lt;/code&gt; ，以十六进制指定所有字符。 &lt;code&gt;\N{}&lt;/code&gt; 是Unicode名称，因此它始终为您提供Unicode字符。 &lt;code&gt;\N{U+41}&lt;/code&gt; 是Unicode代码点为 &lt;code&gt;0x41&lt;/code&gt; 的字符，因此在所有平台上均为 &lt;code&gt;'A'&lt;/code&gt; 。副作用是：</target>
        </trans-unit>
        <trans-unit id="2d7d9f0491fdf8f26d2ae8e336ebfac29d297c05" translate="yes" xml:space="preserve">
          <source>But easiest is, if the character is specifiable as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;%&quot;&lt;/code&gt;, to use that; if not so specificable, you can use &lt;code&gt;\N{}&lt;/code&gt; , if the side effects aren't troublesome. Simply specify all your characters in hex, using &lt;code&gt;\N{U+ZZ}&lt;/code&gt; instead of &lt;code&gt;\xZZ&lt;/code&gt;. &lt;code&gt;\N{}&lt;/code&gt; is the Unicode name, and so it always gives you the Unicode character. &lt;code&gt;\N{U+41}&lt;/code&gt; is the character whose Unicode code point is &lt;code&gt;0x41&lt;/code&gt;, hence is &lt;code&gt;'A'&lt;/code&gt; on all platforms. The side effects are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e336391004e93bf9adbf972f876990718b27f63" translate="yes" xml:space="preserve">
          <source>But failure_handler_auto, instead of dying or anything, compiles $key, caching it in</source>
          <target state="translated">但failail_handler_auto,并没有死掉,而是编译了$key,把它缓存在了</target>
        </trans-unit>
        <trans-unit id="d44c97279f7f106146fa21778196b89c19981fbb" translate="yes" xml:space="preserve">
          <source>But fear not, there's a simple solution. The module &lt;code&gt;Sub::Name&lt;/code&gt; will reach into the perl internals and assign a name to an anonymous subroutine for you. Simply do this:</source>
          <target state="translated">但是不要担心，有一个简单的解决方案。 &lt;code&gt;Sub::Name&lt;/code&gt; 模块将进入perl内部，并为您为匿名子例程分配一个名称。只需执行以下操作：</target>
        </trans-unit>
        <trans-unit id="6c88ebcfc6d7c83b843d2d6f3e737b05e79bf378" translate="yes" xml:space="preserve">
          <source>But for &quot;directory&quot;, you'd want &lt;code&gt;&quot;[quant,_1,directory,directories]&quot;&lt;/code&gt; so that our elementary &lt;code&gt;quant&lt;/code&gt; method doesn't think that the plural of &quot;directory&quot; is &quot;directorys&quot;. And you might find that the output may sound better if you specify a negative form, as in:</source>
          <target state="translated">但是对于&amp;ldquo;目录&amp;rdquo;，您需要 &lt;code&gt;&quot;[quant,_1,directory,directories]&quot;&lt;/code&gt; 以便我们的基本 &lt;code&gt;quant&lt;/code&gt; 方法不会认为&amp;ldquo; directory&amp;rdquo;的复数是&amp;ldquo; directorys&amp;rdquo;。如果您指定否定形式，您可能会发现输出听起来会更好，例如：</target>
        </trans-unit>
        <trans-unit id="490b6f6af7c2374cd5fd42c108629dc25f1e6fdb" translate="yes" xml:space="preserve">
          <source>But for now, let's look at general issues common to all these types of data structures.</source>
          <target state="translated">但现在,让我们看看所有这些类型的数据结构所共有的一般问题。</target>
        </trans-unit>
        <trans-unit id="44e2925861f8472f51f5341cbaaf661343ddc11e" translate="yes" xml:space="preserve">
          <source>But for other languages (as is discussed at length in &lt;a href=&quot;Locale::Maketext::TPJ13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;), simple &lt;code&gt;quant&lt;/code&gt;/&lt;code&gt;numf&lt;/code&gt; is not enough. For the particularly problematic Slavic languages, what you may need is a method which you provide with the number, the citation form of the noun to quantify, and the case and gender that the sentence's syntax projects onto that noun slot. The method would then be responsible for determining what grammatical number that numeral projects onto its noun phrase, and what case and gender it may override the normal case and gender with; and then it would look up the noun in a lexicon providing all needed inflected forms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38fcb950a418ab15715107f772519ba0899f4c7c" translate="yes" xml:space="preserve">
          <source>But for other languages (as is discussed at length in &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;), simple &lt;code&gt;quant&lt;/code&gt; /&lt;code&gt;numf&lt;/code&gt; is not enough. For the particularly problematic Slavic languages, what you may need is a method which you provide with the number, the citation form of the noun to quantify, and the case and gender that the sentence's syntax projects onto that noun slot. The method would then be responsible for determining what grammatical number that numeral projects onto its noun phrase, and what case and gender it may override the normal case and gender with; and then it would look up the noun in a lexicon providing all needed inflected forms.</source>
          <target state="translated">但是对于其他语言（如&lt;a href=&quot;maketext/tpj13&quot;&gt;Locale :: Maketext :: TPJ13中&lt;/a&gt;详细讨论的那样），简单的 &lt;code&gt;quant&lt;/code&gt; / &lt;code&gt;numf&lt;/code&gt; 是不够的。对于特别有问题的斯拉夫语言，您可能需要提供一种方法，该方法提供数字，名词的引用形式以进行量化，以及句子语法投射到该名词槽上的大小写和性别。然后，该方法将负责确定数字将什么语法数字投射到其名词短语上，以及该数字可能覆盖普通的大小写和性别。然后它将在词典中查找名词，并提供所有需要的变体形式。</target>
        </trans-unit>
        <trans-unit id="ef8dab0f4d9389f9bb5dc21779fdfd4e9a160e11" translate="yes" xml:space="preserve">
          <source>But for some processors/formats this cannot be easily controlled; as with the HTML example, the behavior of multiple ambiguous &amp;lt;a name=&quot;</source>
          <target state="translated">但是对于某些处理器/格式，这很难控制。与HTML示例一样，多个歧义&amp;lt;a name =&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8b46bf6bc073f2a792b2de8dc4b3f11e31f9c12f" translate="yes" xml:space="preserve">
          <source>But generally, a block is delimited by curly brackets, also known as braces. We will call this syntactic construct a BLOCK.</source>
          <target state="translated">但一般情况下,一个块是由大括号,也就是括号来限定的。我们将这种语法结构称为BLOCK。</target>
        </trans-unit>
        <trans-unit id="12fcc42a7dd22316cac44e40d51daa68deca033b" translate="yes" xml:space="preserve">
          <source>But generally, a block is delimited by curly brackets, also known as braces. We will call this syntactic construct a BLOCK. Because enclosing braces are also the syntax for hash reference constructor expressions (see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;), you may occasionally need to disambiguate by placing a &lt;code&gt;;&lt;/code&gt; immediately after an opening brace so that Perl realises the brace is the start of a block. You will more frequently need to disambiguate the other way, by placing a &lt;code&gt;+&lt;/code&gt; immediately before an opening brace to force it to be interpreted as a hash reference constructor expression. It is considered good style to use these disambiguating mechanisms liberally, not only when Perl would otherwise guess incorrectly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccefce54f83b7f4c3b397919dd3e84e700ff50bd" translate="yes" xml:space="preserve">
          <source>But if the client asks for &quot;i-Mingo&quot; or &quot;x-mingo&quot;, or &quot;Fr&quot;, then the lookup in %greetings fails. That's the Wrong Thing.</source>
          <target state="translated">但如果客户端要求 &quot;i-Mingo &quot;或 &quot;x-mingo&quot;,或 &quot;Fr&quot;,那么%greetings中的查找就会失败。这就是错误的地方。</target>
        </trans-unit>
        <trans-unit id="ec6083b91636d75d0495261998b67a37e19945dc" translate="yes" xml:space="preserve">
          <source>But if the document starts out:</source>
          <target state="translated">但如果文件一开始就。</target>
        </trans-unit>
        <trans-unit id="018410255214e3cce3a8b05ae3d7d99e0330f4d0" translate="yes" xml:space="preserve">
          <source>But if you subclass Pod::Simple::Methody, it will instead do this when it sees a &quot;=head1 Hi there&quot;:</source>
          <target state="translated">但如果你将Pod::Simple::Methody子类化,当它看到&quot;=head1 Hi there &quot;时,它反而会这样做。</target>
        </trans-unit>
        <trans-unit id="0cf73c47906927595e3043b178988fd87c4d5b4a" translate="yes" xml:space="preserve">
          <source>But if you try this:</source>
          <target state="translated">但如果你试试这个。</target>
        </trans-unit>
        <trans-unit id="90ee606d0538a1d21fc1f464d165e33c56162b66" translate="yes" xml:space="preserve">
          <source>But if you want nested occurrences of &lt;code&gt;START&lt;/code&gt; through &lt;code&gt;END&lt;/code&gt; , you'll run up against the problem described in the question in this section on matching balanced text.</source>
          <target state="translated">但是，如果您希望嵌套出现 &lt;code&gt;START&lt;/code&gt; 到 &lt;code&gt;END&lt;/code&gt; ，则会遇到本节中有关平衡文本匹配问题中描述的问题。</target>
        </trans-unit>
        <trans-unit id="3edd5ad7f10118d3c50f146510574f8277f3c749" translate="yes" xml:space="preserve">
          <source>But if you want nested occurrences of &lt;code&gt;START&lt;/code&gt; through &lt;code&gt;END&lt;/code&gt;, you'll run up against the problem described in the question in this section on matching balanced text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d91fb2e9c31e4e480c3aa19de7d332e4a9c236" translate="yes" xml:space="preserve">
          <source>But if you write code that uses &lt;code&gt;\005&lt;/code&gt; to mean a TAB or &lt;code&gt;\xC1&lt;/code&gt; to mean an &quot;A&quot;, or &lt;code&gt;\xDF&lt;/code&gt; to mean a &quot;&amp;yuml;&quot; (small &lt;code&gt;&quot;y&quot;&lt;/code&gt; with a diaeresis), then your code may well work on your EBCDIC platform, but not on an ASCII one. That's fine to do if no one will ever want to run your code on an ASCII platform; but the bias in this document will be in writing code portable between EBCDIC and ASCII systems. Again, if every character you care about is easily enterable from your keyboard, you don't have to know anything about ASCII, but many keyboards don't easily allow you to directly enter, say, the character &lt;code&gt;\xDF&lt;/code&gt; , so you have to specify it indirectly, such as by using the &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; escape sequence. In those cases it's easiest to know something about the ASCII/Unicode character sets. If you know that the small &quot;&amp;yuml;&quot; is &lt;code&gt;U+00FF&lt;/code&gt; , then you can instead specify it as &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; , and have the computer automatically translate it to &lt;code&gt;\xDF&lt;/code&gt; on your platform, and leave it as &lt;code&gt;\xFF&lt;/code&gt; on ASCII ones. Or you could specify it by name, &lt;code&gt;\N{LATIN
SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; and not have to know the numbers. Either way works, but require familiarity with Unicode.</source>
          <target state="translated">但是，如果您编写的代码使用 &lt;code&gt;\005&lt;/code&gt; 表示TAB或 &lt;code&gt;\xC1&lt;/code&gt; 表示&amp;ldquo; A&amp;rdquo;，或 &lt;code&gt;\xDF&lt;/code&gt; 表示&amp;ldquo;&amp;yuml;&amp;rdquo;（带有小写字母的小 &lt;code&gt;&quot;y&quot;&lt;/code&gt; ），那么您的代码很可能可以在您的计算机上正常工作EBCDIC平台，但不是在ASCII平台上。如果没有人愿意在ASCII平台上运行您的代码，那很好。但是本文的偏向在于编写可在EBCDIC和ASCII系统之间移植的代码。同样，如果您关心的每个字符都可以轻松地从键盘输入，那么您就不必了解ASCII，但是许多键盘都不容易让您直接输入字符 &lt;code&gt;\xDF&lt;/code&gt; ，因此您必须间接指定它，例如通过使用 &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; 转义序列。在这些情况下，最容易了解有关ASCII / Unicode字符集的知识。如果知道小&amp;ldquo;&amp;yuml;&amp;rdquo;是 &lt;code&gt;U+00FF&lt;/code&gt; ，则可以将其指定为 &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; ，并让计算机自动将其翻译为平台上的 &lt;code&gt;\xDF&lt;/code&gt; ，并将其保留为 &lt;code&gt;\xFF&lt;/code&gt; ASCII码上的xFF。或者，您可以使用名称 &lt;code&gt;\N{LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; 来指定它，而不必知道数字。两种方法都可以，但是需要熟悉Unicode。</target>
        </trans-unit>
        <trans-unit id="8c5b9a3f892143e75b663a18f94ea6753bbb8def" translate="yes" xml:space="preserve">
          <source>But if you write code that uses &lt;code&gt;\005&lt;/code&gt; to mean a TAB or &lt;code&gt;\xC1&lt;/code&gt; to mean an &quot;A&quot;, or &lt;code&gt;\xDF&lt;/code&gt; to mean a &quot;&amp;yuml;&quot; (small &lt;code&gt;&quot;y&quot;&lt;/code&gt; with a diaeresis), then your code may well work on your EBCDIC platform, but not on an ASCII one. That's fine to do if no one will ever want to run your code on an ASCII platform; but the bias in this document will be towards writing code portable between EBCDIC and ASCII systems. Again, if every character you care about is easily enterable from your keyboard, you don't have to know anything about ASCII, but many keyboards don't easily allow you to directly enter, say, the character &lt;code&gt;\xDF&lt;/code&gt;, so you have to specify it indirectly, such as by using the &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; escape sequence. In those cases it's easiest to know something about the ASCII/Unicode character sets. If you know that the small &quot;&amp;yuml;&quot; is &lt;code&gt;U+00FF&lt;/code&gt;, then you can instead specify it as &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt;, and have the computer automatically translate it to &lt;code&gt;\xDF&lt;/code&gt; on your platform, and leave it as &lt;code&gt;\xFF&lt;/code&gt; on ASCII ones. Or you could specify it by name, &lt;code&gt;\N{LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; and not have to know the numbers. Either way works, but both require familiarity with Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb0a7929d9be6d467d0702a4ca1482bdad00292" translate="yes" xml:space="preserve">
          <source>But if you're a perl programmer, then for you I have something much more wondrous than just a structure offset printer.</source>
          <target state="translated">但如果你是一个perl程序员,那么对于你来说,我有比结构胶印机更奇妙的东西。</target>
        </trans-unit>
        <trans-unit id="b5d1347e7974f3a5c8f6ee662fc96a7143711f4b" translate="yes" xml:space="preserve">
          <source>But if you're using &lt;code&gt;PerlIO_printf()&lt;/code&gt;, it's less typing and visual clutter to use the &lt;code&gt;%z&lt;/code&gt; length modifier (for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c71d4b40a76244fed8568f06f2e4623c952ed6" translate="yes" xml:space="preserve">
          <source>But in any case, try to keep the features and operating systems separate.</source>
          <target state="translated">但无论如何,尽量把功能和操作系统分开。</target>
        </trans-unit>
        <trans-unit id="f86252e7b4ed24cc14ced10c8828354685807171" translate="yes" xml:space="preserve">
          <source>But in case you find the need to...</source>
          <target state="translated">但万一你发现需要......</target>
        </trans-unit>
        <trans-unit id="3425ba57841c54a0c594ad2ebd352f7a60dfde42" translate="yes" xml:space="preserve">
          <source>But in general, such surprises are rare when entire sentences are being translated, especially when the functional context is restricted to that of a computer interacting with a user either to convey a fact or to prompt for a piece of information. So, for purposes of localization, translation by phrase (generally by sentence) is both the simplest and the least problematic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2d7167267546a3345c93288a69c7eaaae59c46" translate="yes" xml:space="preserve">
          <source>But in many cases, especially multi-byte CJK encodings, you have to tweak a little more. Your network connection may not accept any data with the Most Significant Bit set, and your computer may not be able to tell if a given byte is a whole character or just half of it. So you have to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56073db003479cbcc5aa02dbdcbc3839993740e4" translate="yes" xml:space="preserve">
          <source>But in other cases, it just is that no one has implemented support yet. Patches welcome! Some elements are ported backward for some releases, but not all the way to 5.003_07.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1b980e76b99df2ec3833fb22b3d48a26eb466f" translate="yes" xml:space="preserve">
          <source>But in this particular example, you probably really want</source>
          <target state="translated">但在这个特殊的例子中,你可能真的想要的是</target>
        </trans-unit>
        <trans-unit id="3cee8270da886ebc5c44d683d110f389adb2e169" translate="yes" xml:space="preserve">
          <source>But it actually compiles as this:</source>
          <target state="translated">但实际上是这样编译的。</target>
        </trans-unit>
        <trans-unit id="823e1d2128bc470581c23a9dfa7a058a23c8a7f1" translate="yes" xml:space="preserve">
          <source>But it also puts the same information in certain fields of the XSUB itself:</source>
          <target state="translated">但它也把同样的信息放在XSUB本身的某些字段中。</target>
        </trans-unit>
        <trans-unit id="f5f796fef481b4bfaedc4fb27aaba8e13316d437" translate="yes" xml:space="preserve">
          <source>But it also works on lexically declared aggregates.</source>
          <target state="translated">但它也适用于词法声明的聚合体。</target>
        </trans-unit>
        <trans-unit id="bce306df93e9efe810cd4909bfa7982e26681041" translate="yes" xml:space="preserve">
          <source>But it could equally well be a discussion of three (related or equivalent) items, &quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam Est&quot;, followed by a paragraph explaining them all, and then a new item &quot;Ut Enim&quot;. In that case, you'd probably want to format it like so:</source>
          <target state="translated">但它同样也可以是讨论三个(相关或相当的)项目,&quot;Neque&quot;、&quot;Porro &quot;和 &quot;Quisquam Est&quot;,然后用一段话解释它们,再加上一个新项目 &quot;Ut Enim&quot;。在这种情况下,你可能会想要这样的格式。</target>
        </trans-unit>
        <trans-unit id="ad75a36ebc7396598ae4020570b59b4dddb1d077" translate="yes" xml:space="preserve">
          <source>But it doesn't work at all in Perl 6. Instead, you should use the (parallelizable) &lt;code&gt;any&lt;/code&gt; operator:</source>
          <target state="translated">但是它在Perl 6中根本不起作用。相反，您应该使用（可并行化的） &lt;code&gt;any&lt;/code&gt; 运算符：</target>
        </trans-unit>
        <trans-unit id="5bdbc1f908497576f552335e7ff9cc35570484f5" translate="yes" xml:space="preserve">
          <source>But it doesn't work at all in Raku. Instead, you should use the (parallelizable) &lt;code&gt;any&lt;/code&gt; operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf7fd3170743bf29faac8bcfc9396e4e0b2afa0e" translate="yes" xml:space="preserve">
          <source>But it will croak if:</source>
          <target state="translated">但它会呱呱坠地,如果。</target>
        </trans-unit>
        <trans-unit id="934319e95a665a2a7425edac031de11ea5229dad" translate="yes" xml:space="preserve">
          <source>But most importantly, it works on systems that don't have &lt;code&gt;nl_langinfo&lt;/code&gt;, such as Windows, hence makes your code more portable. Of the fifty-some possible items specified by the POSIX 2008 standard, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&quot;&gt;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&lt;/a&gt;, only one is completely unimplemented, though on non-Windows platforms, another significant one is also not implemented). It uses various techniques to recover the other items, including calling &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/localeconv&quot;&gt;localeconv(3)&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/strftime&quot;&gt;strftime(3)&lt;/a&gt;&lt;/code&gt;, both of which are specified in C89, so should be always be available. Later &lt;code&gt;strftime()&lt;/code&gt; versions have additional capabilities; &lt;code&gt;&quot;&quot;&lt;/code&gt; is returned for those not available on your system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac22b7287d2aed5e7462242749c989d65753c887" translate="yes" xml:space="preserve">
          <source>But never use the bare &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; without having set up a default encoding first. Otherwise, Perl cannot know which of the many, many, many possible flavors of text file you have, and Perl will have no idea how to correctly map the data in your file into actual characters it can work with. Other common encoding formats including &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; , &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; , &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; , and even &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; . See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more about encodings.</source>
          <target state="translated">但切勿在未先设置默认编码的情况下使用裸露的 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 。否则，Perl将不知道您拥有多种形式的文本文件，而Perl将不知道如何将文件中的数据正确映射为可以使用的实际字符。其他常见的编码格式包括 &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; ， &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; ， &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; ， &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; ， &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; ，甚至是 &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; 。有关编码的更多信息，请参见&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a0747e69fd78e083ffa59b04def2af91b0c7abf3" translate="yes" xml:space="preserve">
          <source>But never use the bare &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; without having set up a default encoding first. Otherwise, Perl cannot know which of the many, many, many possible flavors of text file you have, and Perl will have no idea how to correctly map the data in your file into actual characters it can work with. Other common encoding formats including &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt;, &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt;, &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt;, &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt;, &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt;, and even &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt;. See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more about encodings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca085acb0ddeeb52a224b25677bc101217dcb2a" translate="yes" xml:space="preserve">
          <source>But note that these last three macros are valid only if &lt;code&gt;SvPOK()&lt;/code&gt; is true.</source>
          <target state="translated">但是请注意，仅当 &lt;code&gt;SvPOK()&lt;/code&gt; 为true时，这后三个宏才有效。</target>
        </trans-unit>
        <trans-unit id="5960a3f75e9619ab812c7dea1d6e781ac954880e" translate="yes" xml:space="preserve">
          <source>But note that this doesn't mean that any of the characters in the string are necessary UTF-8 encoded, or that any of the characters have code points greater than 0xFF (255) or even 0x80 (128), or that the string has any characters at all. All the &lt;code&gt;is_utf8()&lt;/code&gt; does is to return the value of the internal &quot;utf8ness&quot; flag attached to the &lt;code&gt;$string&lt;/code&gt; . If the flag is off, the bytes in the scalar are interpreted as a single byte encoding. If the flag is on, the bytes in the scalar are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded code points of the characters. Bytes added to a UTF-8 encoded string are automatically upgraded to UTF-8. If mixed non-UTF-8 and UTF-8 scalars are merged (double-quoted interpolation, explicit concatenation, or printf/sprintf parameter substitution), the result will be UTF-8 encoded as if copies of the byte strings were upgraded to UTF-8: for example,</source>
          <target state="translated">但是请注意，这并不意味着字符串中的任何字符都是必需的UTF-8编码，或者任何字符的代码点都大于0xFF（255）甚至是0x80（128），或者字符串具有任何字符。 &lt;code&gt;is_utf8()&lt;/code&gt; 所做的全部操作是返回附加在 &lt;code&gt;$string&lt;/code&gt; 上的内部&amp;ldquo; utf8ness&amp;rdquo;标志的值。如果该标志关闭，则标量中的字节将解释为单字节编码。如果标记打开，则标量中的字节将被解释为字符的（可变长度，可能为多字节）UTF-8编码的代码点。添加到UTF-8编码字符串的字节将自动升级为UTF-8。如果合并了混合的非UTF-8和UTF-8标量（双引号插值，显式级联或printf / sprintf参数替换），则结果将采用UTF-8编码，就好像字节字符串的副本已升级为UTF一样-8：例如，</target>
        </trans-unit>
        <trans-unit id="f3b88a9932e49bdc61514a0893c4a2b1cc99c884" translate="yes" xml:space="preserve">
          <source>But note that this doesn't mean that any of the characters in the string are necessary UTF-8 encoded, or that any of the characters have code points greater than 0xFF (255) or even 0x80 (128), or that the string has any characters at all. All the &lt;code&gt;is_utf8()&lt;/code&gt; does is to return the value of the internal &quot;utf8ness&quot; flag attached to the &lt;code&gt;$string&lt;/code&gt;. If the flag is off, the bytes in the scalar are interpreted as a single byte encoding. If the flag is on, the bytes in the scalar are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded code points of the characters. Bytes added to a UTF-8 encoded string are automatically upgraded to UTF-8. If mixed non-UTF-8 and UTF-8 scalars are merged (double-quoted interpolation, explicit concatenation, or printf/sprintf parameter substitution), the result will be UTF-8 encoded as if copies of the byte strings were upgraded to UTF-8: for example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed10f08c2a7b806d29712ea53fb65371e6dda25" translate="yes" xml:space="preserve">
          <source>But prior to v5.16, you must be explicit about which set of charnames you want. The &lt;code&gt;:full&lt;/code&gt; names are the official Unicode character name, alias, or sequence, which all share a namespace.</source>
          <target state="translated">但是在v5.16之前，您必须明确要使用的字符集。的 &lt;code&gt;:full&lt;/code&gt; 名是正式的Unicode字符的名称，别名或序列，它都共享一个命名空间。</target>
        </trans-unit>
        <trans-unit id="6ea0e56fa9cef58c93ebf2b8ef0ed82782b2271a" translate="yes" xml:space="preserve">
          <source>But recall that not all operating systems support forking or capturing of the output of commands, so this complex statement may not be portable.</source>
          <target state="translated">但请记住,并不是所有的操作系统都支持分叉或捕获命令的输出,所以这个复杂的语句可能无法移植。</target>
        </trans-unit>
        <trans-unit id="80db3d6002a0ea4be473c7d7a0631f6d66de4e4e" translate="yes" xml:space="preserve">
          <source>But second off, it's not isomorphic -- the &quot;solution&quot; (i.e., the phrasebook entries) for Chinese maps from these four English phrases to the one Chinese phrase that fits for all of them. In other words, the informal solution would be &quot;The way to say what you want in Chinese is with the one phrase 'For your question, in Y directories you would find X files'&quot; -- and so the implemented solution should be, isomorphically, just a straightforward way to spit out that one phrase, with numerals properly interpolated. It shouldn't have to map from the complexity of other languages to the simplicity of this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f098d4fba29dcb8c3c77666f8cde3d29b4074e10" translate="yes" xml:space="preserve">
          <source>But some modules cannot be built with this mantra. They try to get some extra data from the user via the environment, extra arguments, or interactively--thus disturbing the installation of large bundles like Phalanx100 or modules with many dependencies like Plagger.</source>
          <target state="translated">但是,有些模块不能用这个口号来构建,它们试图通过环境、额外的参数或交互式来从用户那里获取一些额外的数据--从而扰乱了像Phalanx100这样的大型捆绑包或像Plagger这样有许多依赖关系的模块的安装。它们试图通过环境、额外的参数或交互方式从用户那里获取一些额外的数据--从而干扰了像Phalanx100这样的大型捆绑包或像Plagger这样有许多依赖关系的模块的安装。</target>
        </trans-unit>
        <trans-unit id="b9343448796744b38fdcc31c04963c50f230e565" translate="yes" xml:space="preserve">
          <source>But stringify it and you get just the text content:</source>
          <target state="translated">但把它串起来,你得到的只是文字内容。</target>
        </trans-unit>
        <trans-unit id="420149069302ad928f47370a01dc8262cabda22d" translate="yes" xml:space="preserve">
          <source>But take care not to pass it as, for example</source>
          <target state="translated">但要注意不要把它传成,比如说</target>
        </trans-unit>
        <trans-unit id="f5ed605cf911baa94f53b7f6af1d782e89ccd2f6" translate="yes" xml:space="preserve">
          <source>But testing for taintedness gets you only so far. Sometimes you have just to clear your data's taintedness. Values may be untainted by using them as keys in a hash; otherwise the only way to bypass the tainting mechanism is by referencing subpatterns from a regular expression match. Perl presumes that if you reference a substring using $1, $2, etc. in a non-tainting pattern, that you knew what you were doing when you wrote that pattern. That means using a bit of thought--don't just blindly untaint anything, or you defeat the entire mechanism. It's better to verify that the variable has only good characters (for certain values of &quot;good&quot;) rather than checking whether it has any bad characters. That's because it's far too easy to miss bad characters that you never thought of.</source>
          <target state="translated">但测试污点只能让你走到这一步。有时你只需要清除数据的污点。通过将值作为哈希中的键来使用,可以不受污染;否则绕过污点机制的唯一方法是通过从正则表达式匹配中引用子模式。Perl假定,如果你在非污点模式中使用$1、$2等引用一个子串,那么你在写这个模式时就知道自己在做什么。这意味着要用点心思--不要盲目地取消任何东西,否则你就会打败整个机制。最好是验证变量是否只有好的字符(对于某些 &quot;好 &quot;的值),而不是检查它是否有坏的字符。这是因为太容易漏掉你从未想过的坏字符了。</target>
        </trans-unit>
        <trans-unit id="07ab01a33d4e7c1814e10d3a1451c86fcb0fab16" translate="yes" xml:space="preserve">
          <source>But that can produce ambiguous syntax in certain cases, so it's often better to use the direct method invocation approach:</source>
          <target state="translated">但这在某些情况下会产生模棱两可的语法,所以通常使用直接方法调用的方法更好。</target>
        </trans-unit>
        <trans-unit id="4081f5e36560816f0b341323008a11e961519754" translate="yes" xml:space="preserve">
          <source>But that isn't going to match; at least, not the way you're hoping. It claims that there is no 123 in the string. Here's a clearer picture of why that pattern matches, contrary to popular expectations:</source>
          <target state="translated">但这是不会匹配的,至少,不是你所希望的方式。它声称字符串中没有123。这里有一张更清晰的图片,说明为什么该模式会匹配,与大众的期望相反。</target>
        </trans-unit>
        <trans-unit id="07b885fe74e23c15de33bcf3d35cb8fafefcc846" translate="yes" xml:space="preserve">
          <source>But that second &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is rushing ahead. It isn't using a simple literal string for the template. So maybe we should introduce...</source>
          <target state="translated">但是第二次 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 正在紧锣密鼓地进行中。它没有为模板使用简单的文字字符串。所以也许我们应该介绍...</target>
        </trans-unit>
        <trans-unit id="ebd21a1f53afcb90bb2e6fa1c3ee1beda8c1e31a" translate="yes" xml:space="preserve">
          <source>But that second &lt;code&gt;unpack&lt;/code&gt; is rushing ahead. It isn't using a simple literal string for the template. So maybe we should introduce...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="861b5be1d3b22e874a1fd22ed51f10196d9c89e5" translate="yes" xml:space="preserve">
          <source>But that's not terribly pretty. You may find it simpler or clearer in the long run to just do things like this:</source>
          <target state="translated">但这不是非常漂亮。从长远来看,你可能会发现这样做更简单或更清晰。</target>
        </trans-unit>
        <trans-unit id="5d68c723e2845ae1a2c75f9213f2beec623c2f67" translate="yes" xml:space="preserve">
          <source>But that's rather inefficient. A better way to do it is to start your program with:</source>
          <target state="translated">但这样的效率相当低。更好的方法是用以下方式开始你的程序。</target>
        </trans-unit>
        <trans-unit id="3c5623d3d8f73ddcc75bce9ec5d80243561beb13" translate="yes" xml:space="preserve">
          <source>But the Arabic translator is the next to write back. First off, your code for &quot;I scanned %g directory.&quot; or &quot;I scanned %g directories.&quot; assumes there's only singular or plural. But, to use linguistic jargon again, Arabic has grammatical number, like English (but unlike Chinese), but it's a three-term category: singular, dual, and plural. In other words, the way you say &quot;directory&quot; depends on whether there's one directory, or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0666cc872d80abdc9e23386d6ece439d18c0915" translate="yes" xml:space="preserve">
          <source>But the HERE_TARGET must still be flush against the margin. If you want that indented also, you'll have to quote in the indentation.</source>
          <target state="translated">但是HERE_TARGET仍然必须与空白处齐平。如果你想让它也缩进,你就得在缩进处引用。</target>
        </trans-unit>
        <trans-unit id="3261d19f3d27e578566dcbff378ffaa4781a7162" translate="yes" xml:space="preserve">
          <source>But the following code is quite bad:</source>
          <target state="translated">但下面的代码相当糟糕。</target>
        </trans-unit>
        <trans-unit id="903f25d05dc48316bba755ecdc1e7944baec6c3c" translate="yes" xml:space="preserve">
          <source>But the marked code isn't syntactically correct to be such an interpolated class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9ae2e6c3f8a198a1ff872d901ef6ec6abf0329" translate="yes" xml:space="preserve">
          <source>But there are some cases where only this solution works (like &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;maybe::next::method&lt;/code&gt; );</source>
          <target state="translated">但是在某些情况下，只有此解决方案有效（例如 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;maybe::next::method&lt;/code&gt; ）；</target>
        </trans-unit>
        <trans-unit id="f444a7ccc18a957e30bdbe83f2e4500327151823" translate="yes" xml:space="preserve">
          <source>But there are some cases where only this solution works (like &lt;code&gt;goto &amp;amp;maybe::next::method&lt;/code&gt;);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bbd2ecd4d2700eece4600f310be07e3be1c2ebf" translate="yes" xml:space="preserve">
          <source>But there are some cases where you may want to know which character set you are running under. One possible example is doing &lt;a href=&quot;#SORTING&quot;&gt;sorting&lt;/a&gt; in inner loops where performance is critical.</source>
          <target state="translated">但是在某些情况下，您可能想知道要在哪个字符集下运行。一个可能的示例是在&lt;a href=&quot;#SORTING&quot;&gt;对&lt;/a&gt;性能至关重要的内部循环中进行排序。</target>
        </trans-unit>
        <trans-unit id="79f382a399e7acdac77923f9261c190aa9a11824" translate="yes" xml:space="preserve">
          <source>But there's no real need for &lt;b&gt;both&lt;/b&gt; to be tempfiles... the following should work just as well, without deadlocking:</source>
          <target state="translated">但实际上并不需要&lt;b&gt;两者&lt;/b&gt;都是临时文件...以下内容也应同样有效，而不会出现死锁：</target>
        </trans-unit>
        <trans-unit id="5a55d83408434c70f23ed8c60b8e212b2bfead28" translate="yes" xml:space="preserve">
          <source>But they may be arbitrarily long:</source>
          <target state="translated">但它们可能是任意长的。</target>
        </trans-unit>
        <trans-unit id="47bd7edd758647409df600b782dfd569cb2795d8" translate="yes" xml:space="preserve">
          <source>But they may span several (non-blank) lines:</source>
          <target state="translated">但它们可能会跨越几条(非空白)线。</target>
        </trans-unit>
        <trans-unit id="af1031e39fec41022cade090893d6211ac853b17" translate="yes" xml:space="preserve">
          <source>But this does not have the effect that someone reading the code would likely expect, as the intersection applies just to &lt;code&gt;\p{Thai}&lt;/code&gt; , excluding the Laotian. Pitfalls like this can be avoided by parenthesizing the component pieces:</source>
          <target state="translated">但这并不会产生阅读代码的人所期望的效果，因为交集仅适用于 &lt;code&gt;\p{Thai}&lt;/code&gt; ，不包括老挝语。可以通过在组成部分中加上括号来避免此类陷阱：</target>
        </trans-unit>
        <trans-unit id="3e961579d9e8252ea504999636a1d461e186d84b" translate="yes" xml:space="preserve">
          <source>But this does not have the effect that someone reading the source code would likely expect, as the intersection applies just to &lt;code&gt;\p{Thai}&lt;/code&gt;, excluding the Laotian. Its best to compile the subcomponents, but you could also parenthesize the component pieces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e39b52a31dfee971d175ae42a65864bfa50aedc" translate="yes" xml:space="preserve">
          <source>But this doesn't match, at least not the way one might expect. Only after inserting the interpolated &lt;code&gt;$a99a&lt;/code&gt; and looking at the resulting full text of the regexp is it obvious that the backreferences have backfired. The subexpression &lt;code&gt;(\w+)&lt;/code&gt; has snatched number 1 and demoted the groups in &lt;code&gt;$a99a&lt;/code&gt; by one rank. This can be avoided by using relative backreferences:</source>
          <target state="translated">但这不匹配，至少不符合人们的预期。只有插入内插的 &lt;code&gt;$a99a&lt;/code&gt; 并查看生成的正则表达式的全文之后，才可以明显看出反向引用适得其反。子表达式 &lt;code&gt;(\w+)&lt;/code&gt; 抢夺了数字1，并将 &lt;code&gt;$a99a&lt;/code&gt; 的组降级了一级。可以通过使用相对反向引用来避免这种情况：</target>
        </trans-unit>
        <trans-unit id="6783211af3a27626c9e0e73fe10e75f068ecbc7b" translate="yes" xml:space="preserve">
          <source>But this is not guaranteed to work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d71f7e1b353d405d0ac11988a391e51c106c8d8" translate="yes" xml:space="preserve">
          <source>But this is not:</source>
          <target state="translated">但这不是。</target>
        </trans-unit>
        <trans-unit id="b33d301cbe486111cdb963daebee73c9ce3e8834" translate="yes" xml:space="preserve">
          <source>But to avoid portability warnings (see &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;), you may prefer:</source>
          <target state="translated">但是为了避免可移植性警告（请参阅&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;），您可能更喜欢：</target>
        </trans-unit>
        <trans-unit id="f9f8099c8d1ed2b0fc4c9abd170ecd56ff0e63b5" translate="yes" xml:space="preserve">
          <source>But to avoid portability warnings (see &lt;a href=&quot;perlfunc#use&quot;&gt;&quot;use&quot; in perlfunc&lt;/a&gt;), you may prefer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="020939326fc990dde03b1b00ce335dbc09c9fc3e" translate="yes" xml:space="preserve">
          <source>But wait: doesn't &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; just return a sequence of bytes? How can we pass this string of bytes to some C code expecting a pointer which is, after all, nothing but a number? The answer is simple: We have to obtain the numeric address from the bytes returned by &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">但是等等：不 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 返回字节序列吗？我们如何将这个字节字符串传递给某些C语言代码，期望它的指针毕竟是一个数字呢？答案很简单：我们必须从 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 返回的字节中获取数字地址。</target>
        </trans-unit>
        <trans-unit id="9d8b172e82350b535193e00efe170bf43ca91d34" translate="yes" xml:space="preserve">
          <source>But wait: doesn't &lt;code&gt;pack&lt;/code&gt; just return a sequence of bytes? How can we pass this string of bytes to some C code expecting a pointer which is, after all, nothing but a number? The answer is simple: We have to obtain the numeric address from the bytes returned by &lt;code&gt;pack&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681fa12b5aa88395e6be12e5639cef0794d6ebaa" translate="yes" xml:space="preserve">
          <source>But what about user-defined subroutines from modules? If you use &lt;code&gt;autodie&lt;/code&gt; on a user-defined subroutine then it assumes the following behaviour to demonstrate failure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1178148d2666470319bf944b3a6373f8bd5ec43c" translate="yes" xml:space="preserve">
          <source>But what happens if your test program dies halfway through?! Since we didn't say how many tests we're going to run, how can we know it failed? No problem, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; employs some magic to catch that death and turn the test into a failure, even if every test passed up to that point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c582aeb02e8310ccc2268a23e2a13586d2230f" translate="yes" xml:space="preserve">
          <source>But what if we had an indeterminate number of words? This is the sort of task &lt;code&gt;//g&lt;/code&gt; was made for. To extract all words, form the simple regexp &lt;code&gt;(\w+)&lt;/code&gt; and loop over all matches with &lt;code&gt;/(\w+)/g&lt;/code&gt; :</source>
          <target state="translated">但是，如果我们的单词数量不确定，该怎么办？ &lt;code&gt;//g&lt;/code&gt; 是完成的任务。要提取所有单词，形成简单的正则表达式 &lt;code&gt;(\w+)&lt;/code&gt; 并使用 &lt;code&gt;/(\w+)/g&lt;/code&gt; 遍历所有匹配项：</target>
        </trans-unit>
        <trans-unit id="90358bd78c20e742086dbdc6ea3490a9deb3bfcc" translate="yes" xml:space="preserve">
          <source>But what if we had an indeterminate number of words? This is the sort of task &lt;code&gt;/g&lt;/code&gt; was made for. To extract all words, form the simple regexp &lt;code&gt;(\w+)&lt;/code&gt; and loop over all matches with &lt;code&gt;/(\w+)/g&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7271808fc8fe6737543912e6a4f4345f08e046" translate="yes" xml:space="preserve">
          <source>But when &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; is used instead of &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; :</source>
          <target state="translated">但当 &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; 代替 &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="818681641ebe6c47ebb66c7080c5a8f6b3070c54" translate="yes" xml:space="preserve">
          <source>But when &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; is used instead of &lt;code&gt;&quot;autotie&quot;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a237c274e15fc51e976c2366d2b1cd3f9bba3c7c" translate="yes" xml:space="preserve">
          <source>But when the following lines are added at the end:</source>
          <target state="translated">但如果在最后加上以下几行字。</target>
        </trans-unit>
        <trans-unit id="b3a7682b246bb8254bfcb416501b69b76a746fd6" translate="yes" xml:space="preserve">
          <source>But with the actual compile tree for &lt;code&gt;$a = $b + $c&lt;/code&gt; it is different: some nodes</source>
          <target state="translated">但是对于 &lt;code&gt;$a = $b + $c&lt;/code&gt; 的实际编译树，情况有所不同：某些节点</target>
        </trans-unit>
        <trans-unit id="4db6b75d323cb14de03fc556f71c215fa0254459" translate="yes" xml:space="preserve">
          <source>But won't work when called as:</source>
          <target state="translated">但当调用为时,就不能用了。</target>
        </trans-unit>
        <trans-unit id="41f61e687d338fbf08bd8ac1adb4bd20048487aa" translate="yes" xml:space="preserve">
          <source>But you don't actually have to make two pipe calls. If you have the socketpair() system call, it will do this all for you.</source>
          <target state="translated">但实际上你不需要进行两个管道调用。如果你有socketpair()系统调用,它将为你完成这一切。</target>
        </trans-unit>
        <trans-unit id="eb429c70b04342714cf4d23c433974bea348e678" translate="yes" xml:space="preserve">
          <source>But you put it aside for the moment, and optimistically hope that the other translators won't have this problem, and that their languages will be better behaved -- i.e., that they will be just like English.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc61709d9d36e283fe251c9894f7f9c70eff276" translate="yes" xml:space="preserve">
          <source>But you still cannot make assumptions about whether this is correct, unless your policy says it is. You really are best off asking the user.</source>
          <target state="translated">但你仍然不能假设这是否正确,除非你的政策规定是这样。你真的最好问一下用户。</target>
        </trans-unit>
        <trans-unit id="4b9905ad0aeb95ca50441bf7c28631173d039f82" translate="yes" xml:space="preserve">
          <source>But you still have those funny select()s. So just use the FileHandle module. Now, you can access these special variables using lowercase method names instead:</source>
          <target state="translated">但你仍然有那些有趣的select()s。所以只要使用FileHandle模块就可以了。现在,你可以使用小写的方法名来访问这些特殊变量。</target>
        </trans-unit>
        <trans-unit id="c127d3080f3bd57d92c9f856e712493975078203" translate="yes" xml:space="preserve">
          <source>But you still have to localize it for all the languages you're producing this software for, so you pull Locale::gettext off of CPAN so you can access the &lt;code&gt;gettext&lt;/code&gt; C functions you've heard are standard for localization tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a3c4f45d8b18ec4a584229683442d84d642772" translate="yes" xml:space="preserve">
          <source>But you then read in the gettext manual (Drepper, Miller, and Pinard 1995) that this is not a good idea, since how a single word like &quot;directory&quot; or &quot;directories&quot; is translated may depend on context -- and this is true, since in a case language like German or Russian, you'd may need these words with a different case ending in the first instance (where the word is the object of a verb) than in the second instance, which you haven't even gotten to yet (where the word is the object of a preposition, &quot;in %g directories&quot;) -- assuming these keep the same syntax when translated into those languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d919612387e489786e93250f1cb6101f4eb4f66e" translate="yes" xml:space="preserve">
          <source>But!</source>
          <target state="translated">But!</target>
        </trans-unit>
        <trans-unit id="45dd0cd91dc6886148fd373bfb4f17c3a9594ab0" translate="yes" xml:space="preserve">
          <source>But, by extracting the directive using &lt;code&gt;extract_codeblock($text, '{}', &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, '&amp;lt;&amp;gt;')&lt;/code&gt; the '&amp;gt;' character is only treated as a delimited at the outermost level of the code block, so the directive is parsed correctly.</source>
          <target state="translated">但是，通过使用 &lt;code&gt;extract_codeblock($text, '{}', &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, '&amp;lt;&amp;gt;')&lt;/code&gt; 提取指令，&lt;a href=&quot;../functions/undef&quot;&gt; undef&lt;/a&gt;，'&amp;lt;&amp;gt;'）仅将'&amp;gt;'字符视为代码块最外层的定界符，因此可以正确解析指令。</target>
        </trans-unit>
        <trans-unit id="30f80e7cf502991565c61822cae8756f6fbb85c6" translate="yes" xml:space="preserve">
          <source>But, by extracting the directive using &lt;code&gt;extract_codeblock($text, '{}', undef, '&amp;lt;&amp;gt;')&lt;/code&gt; the '&amp;gt;' character is only treated as a delimited at the outermost level of the code block, so the directive is parsed correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9550f9852e2d8ab541a52ef7f81900ea09883af" translate="yes" xml:space="preserve">
          <source>But, even for portable ranges, it is not generally obvious what is included without having to look things up in the manual. A sound principle is to use only ranges that both begin from, and end at, either ASCII alphabetics of equal case (&lt;code&gt;b-e&lt;/code&gt;, &lt;code&gt;B-E&lt;/code&gt;), or digits (&lt;code&gt;1-4&lt;/code&gt;). Anything else is unclear (and unportable unless &lt;code&gt;\N{...}&lt;/code&gt; is used). If in doubt, spell out the character sets in full.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64523236f0a5dcac7b40cdaff74c2e2dc5991adf" translate="yes" xml:space="preserve">
          <source>But, starting with Perl v5.28, locales are thread-safe on platforms that support this functionality. Windows has this starting with Visual Studio 2005. Many other modern platforms support the thread-safe POSIX 2008 functions. The C &lt;code&gt;#define&lt;/code&gt;&lt;code&gt;USE_THREAD_SAFE_LOCALE&lt;/code&gt; will be defined iff this build is using these. From Perl-space, the read-only variable &lt;code&gt;${SAFE_LOCALES}&lt;/code&gt; is 1 if either the build is not threaded, or if &lt;code&gt;USE_THREAD_SAFE_LOCALE&lt;/code&gt; is defined; otherwise it is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adebbf716096e26741f223bcfa719eec45495d73" translate="yes" xml:space="preserve">
          <source>Buzzword: Concision</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b968913e712f1017ea8c46a9442142f5b0258e4f" translate="yes" xml:space="preserve">
          <source>Buzzword: Inheritance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9a9237da961c2681cd1e9d5c45f274b009d9f4" translate="yes" xml:space="preserve">
          <source>Buzzword: Isomorphism</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caad58d09c49a59cd7461be6687704deef207767" translate="yes" xml:space="preserve">
          <source>Buzzwords: Abstraction and Encapsulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25b354100dcfbea76bd0e9e5a69bf58ebc32ab47" translate="yes" xml:space="preserve">
          <source>By calling the class method &lt;code&gt;Math::Complex::display_format&lt;/code&gt; and supplying either &lt;code&gt;&quot;polar&quot;&lt;/code&gt; or &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; as an argument, you override the default display style, which is &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; . Not supplying any argument returns the current settings.</source>
          <target state="translated">通过调用类方法 &lt;code&gt;Math::Complex::display_format&lt;/code&gt; 并提供 &lt;code&gt;&quot;polar&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; 作为参数，您可以覆盖默认的显示样式，即 &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; 。不提供任何参数将返回当前设置。</target>
        </trans-unit>
        <trans-unit id="43dd785845dcbec8cafe7f755ed628d733e41645" translate="yes" xml:space="preserve">
          <source>By calling the class method &lt;code&gt;Math::Complex::display_format&lt;/code&gt; and supplying either &lt;code&gt;&quot;polar&quot;&lt;/code&gt; or &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; as an argument, you override the default display style, which is &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt;. Not supplying any argument returns the current settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd6475e714f8f18a3dfbb9986cb52d7a25b9828" translate="yes" xml:space="preserve">
          <source>By carefully looking at the encoded byte sequence, you can find that the byte sequence conforms a unique number. In that sense, EUC is a CCS generated by a CES above from up to four CCS (complicated?). UTF-8 falls into this category. See &lt;a href=&quot;perlunicode#UTF-8&quot;&gt;&quot;UTF-8&quot; in perlUnicode&lt;/a&gt; to find out how UTF-8 maps Unicode to a byte sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d08c1f941525ad751e4a25955a26ef38161991" translate="yes" xml:space="preserve">
          <source>By contrast, if</source>
          <target state="translated">相反,如果</target>
        </trans-unit>
        <trans-unit id="d13b7913a7d5727103d5a0ff02bb43cd904ec898" translate="yes" xml:space="preserve">
          <source>By convention, CPAN Digest modules do &lt;b&gt;not&lt;/b&gt; pad their Base64 output. Problems can occur when feeding such digests to other software that expects properly padded Base64 encodings.</source>
          <target state="translated">按照惯例，CPAN摘要模块可以 &lt;b&gt;不&lt;/b&gt;填充其Base64输出。将此类摘要提供给其他需要正确填充Base64编码的软件时，可能会出现问题。</target>
        </trans-unit>
        <trans-unit id="fa63c3f7831848cc55dec885e0aadbe7e110091f" translate="yes" xml:space="preserve">
          <source>By convention, all the calls to OS/2 API should indicate their failures by resetting $^E. All the Perl-accessible functions which call OS/2 API may be broken into two classes: some die()s when an API error is encountered, the other report the error via a false return value (of course, this does not concern Perl-accessible functions which</source>
          <target state="translated">按照惯例,所有对OS/2 API的调用都应该通过重置$^E来表示其失败。所有调用OS/2 API的Perl可访问的函数都可以分为两类:一些函数在遇到API错误时死(),另一些函数则通过一个错误的返回值来报告错误(当然,这并不涉及到Perl可访问的函数,这些函数是</target>
        </trans-unit>
        <trans-unit id="98616871ec55526e1b310a455ba5f2d84e33363e" translate="yes" xml:space="preserve">
          <source>By convention, check routines have names &lt;code&gt;ck_*&lt;/code&gt; . They are usually called from &lt;code&gt;new*OP&lt;/code&gt; subroutines (or &lt;code&gt;convert&lt;/code&gt; ) (which in turn are called from</source>
          <target state="translated">按照惯例，检查例程的名称为 &lt;code&gt;ck_*&lt;/code&gt; 。它们通常是从 &lt;code&gt;new*OP&lt;/code&gt; 子例程（或 &lt;code&gt;convert&lt;/code&gt; ）中调用的（而后者又是从</target>
        </trans-unit>
        <trans-unit id="21e06347ae19cac9895adb4f7e858bf0ed8086b5" translate="yes" xml:space="preserve">
          <source>By convention, check routines have names &lt;code&gt;ck_*&lt;/code&gt;. They are usually called from &lt;code&gt;new*OP&lt;/code&gt; subroutines (or &lt;code&gt;convert&lt;/code&gt;) (which in turn are called from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac2669af1abb44ebf6531e7e05b8563aa92056a" translate="yes" xml:space="preserve">
          <source>By convention, each test is assigned a number in order. This is largely done automatically for you. However, it's often very useful to assign a name to each test. Which would you rather see:</source>
          <target state="translated">按照惯例,每个测试都会按顺序分配一个号码。这在很大程度上是为您自动完成的。然而,为每个测试指定一个名称往往是非常有用的。你想看哪个。</target>
        </trans-unit>
        <trans-unit id="9314c5f036387917642398c26237bf03490cfd4b" translate="yes" xml:space="preserve">
          <source>By default</source>
          <target state="translated">默认情况下</target>
        </trans-unit>
        <trans-unit id="a90acddb58b18220dbe08ab0b09969aa5f8ece27" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;$i-&amp;gt;inflate($input, $output)&lt;/code&gt; will uncompress</source>
          <target state="translated">默认情况下 &lt;code&gt;$i-&amp;gt;inflate($input, $output)&lt;/code&gt; 将解压缩</target>
        </trans-unit>
        <trans-unit id="2b6ad4cdfaab155648e7ab26ef526a2e2f9bb93e" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; will build with a private copy of version 1.2.5 of the zlib library. (See the</source>
          <target state="translated">默认情况下， &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; 将使用zlib库的1.2.5版的私有副本进行构建。（请参阅</target>
        </trans-unit>
        <trans-unit id="13d1bc9ce24c11cc5f6efdcd3fee51a91c8038f7" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Hash::Util&lt;/code&gt; does not export anything.</source>
          <target state="translated">默认情况下， &lt;code&gt;Hash::Util&lt;/code&gt; 不导出任何内容。</target>
        </trans-unit>
        <trans-unit id="62c898d4495e40824d05af53004d3c74a134ca35" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; will</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bbc45d166d6a142bcf7adafd5a3ff246af5dec6" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;IO::Uncompress::Bzip2&lt;/code&gt; will only uncompress the first bzip2 data stream in a pbzip2 file. To uncompress the complete pbzip2 file you must include the &lt;code&gt;MultiStream&lt;/code&gt; option, like this.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
