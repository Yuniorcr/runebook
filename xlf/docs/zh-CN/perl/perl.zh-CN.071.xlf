<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="3e543092d93dedef30b6a118c959f36cd73b7b20" translate="yes" xml:space="preserve">
          <source>Warns with &lt;code&gt;@message&lt;/code&gt; but the message will appear to come from the point where the original test function was called (&lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ).</source>
          <target state="translated">使用 &lt;code&gt;@message&lt;/code&gt; 发出警告，但消息似乎来自调用原始测试函数的位置（ &lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5d24c39aea457b02505102a29c905de4cac82e99" translate="yes" xml:space="preserve">
          <source>Warns with &lt;code&gt;@message&lt;/code&gt; but the message will appear to come from the point where the original test function was called (&lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a27a6644654593ac9e5d122b1155ff23752c8073" translate="yes" xml:space="preserve">
          <source>Washington</source>
          <target state="translated">Washington</target>
        </trans-unit>
        <trans-unit id="d321acbea9d4ab268b54e61d4d0b39001cfb34d4" translate="yes" xml:space="preserve">
          <source>Wayne Thompson</source>
          <target state="translated">韦恩-汤普森</target>
        </trans-unit>
        <trans-unit id="43464fb1e06d4c1bc9db7081e9ca038cc1269495" translate="yes" xml:space="preserve">
          <source>We &quot;officially&quot; support the two most recent stable release series. 5.16.x and earlier are now out of support. As of the release of 5.22.0, we will &quot;officially&quot; end support for Perl 5.18.x, other than providing security updates as described below.</source>
          <target state="translated">我们 &quot;正式 &quot;支持两个最新的稳定版本系列。5.16.x 和更早的版本现在已经不支持了。从 5.22.0 发布开始,我们将 &quot;正式 &quot;终止对 Perl 5.18.x 的支持,但会提供如下所述的安全更新。</target>
        </trans-unit>
        <trans-unit id="6d4d00accf40364d9a03449bdf5ad7e154d1f316" translate="yes" xml:space="preserve">
          <source>We &quot;officially&quot; support the two most recent stable release series. 5.26.x and earlier are now out of support. As of the release of 5.32.0, we will &quot;officially&quot; end support for Perl 5.28.x, other than providing security updates as described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a0049b3e8190b56f011a925a65f0578bf35206" translate="yes" xml:space="preserve">
          <source>We already talked about the special &lt;code&gt;@ISA&lt;/code&gt; array and the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma.</source>
          <target state="translated">我们已经讨论过特殊的 &lt;code&gt;@ISA&lt;/code&gt; 数组和&lt;a href=&quot;parent&quot;&gt;父级&lt;/a&gt;编译指示。</target>
        </trans-unit>
        <trans-unit id="99f6d15ea0dac8c570f259e877f08f9c6317a1cf" translate="yes" xml:space="preserve">
          <source>We also recommend using this method to check whether a module has a sufficient version. The internal implementation uses the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module to make sure that different types of version numbers are compared correctly.</source>
          <target state="translated">我们还建议使用此方法检查模块是否具有足够的版本。内部实现使用&lt;a href=&quot;version&quot;&gt;版本&lt;/a&gt;模块来确保正确比较不同类型的版本号。</target>
        </trans-unit>
        <trans-unit id="777641065ef9fefa679b6e058d833646233119c1" translate="yes" xml:space="preserve">
          <source>We are at the end of the regexp, so we are done! We have matched 'abcd' out of the string &quot;abcde&quot;.</source>
          <target state="translated">我们已经到了regexp的最后,所以我们完成了!我们已经从字符串 &quot;abcd &quot;中匹配出了 &quot;abcd&quot;。我们从字符串 &quot;abcde &quot;中匹配出了 &quot;abcd&quot;。</target>
        </trans-unit>
        <trans-unit id="88e6eb598d1ae4c98a1710166c586176804c4ac7" translate="yes" xml:space="preserve">
          <source>We are done!</source>
          <target state="translated">我们完成了!</target>
        </trans-unit>
        <trans-unit id="b8c42eb02770fa660f067266841b9afabfa1a1c9" translate="yes" xml:space="preserve">
          <source>We are performing only one hash operation in this function, which is storing a new scalar under a key using &lt;code&gt;hv_store&lt;/code&gt; . A hash is represented by an HV* pointer. Like arrays, the functions for manipulating hashes from an XSUB mirror the functionality available from Perl. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for details.</source>
          <target state="translated">我们在此函数中仅执行一个哈希操作，该操作使用 &lt;code&gt;hv_store&lt;/code&gt; 将新标量存储在键下。哈希由HV *指针表示。像数组一样，用于从XSUB处理哈希的功能也反映了Perl的功能。有关详细信息，请参见&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;和&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c6308f6a80327169a668ffa81bc777a5db0a8f1" translate="yes" xml:space="preserve">
          <source>We are performing only one hash operation in this function, which is storing a new scalar under a key using &lt;code&gt;hv_store&lt;/code&gt;. A hash is represented by an HV* pointer. Like arrays, the functions for manipulating hashes from an XSUB mirror the functionality available from Perl. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d6aa4a367d4b3962d66c4c93f795d417974b93" translate="yes" xml:space="preserve">
          <source>We are used to using the term (character)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd90ced3661ebd845235cda2b54db721e3957aec" translate="yes" xml:space="preserve">
          <source>We aren't interested in anything returned from</source>
          <target state="translated">我们对从以下地方返回的任何东西不感兴趣</target>
        </trans-unit>
        <trans-unit id="b554448ff034d8f0532aebe7287733b598ce6629" translate="yes" xml:space="preserve">
          <source>We aren't passing any parameters to</source>
          <target state="translated">我们没有向</target>
        </trans-unit>
        <trans-unit id="4e3a929680591b90a57e354fe70746318049b8f9" translate="yes" xml:space="preserve">
          <source>We build perl using GNU make. We tried the native make once and it worked too.</source>
          <target state="translated">我们使用GNU make构建perl。我们试过一次native make,也成功了。</target>
        </trans-unit>
        <trans-unit id="41071245738df49d45438a45bb484058bfc57858" translate="yes" xml:space="preserve">
          <source>We can also dump out this op: the current op is always stored in &lt;code&gt;PL_op&lt;/code&gt; , and we can dump it with &lt;code&gt;Perl_op_dump&lt;/code&gt; . This'll give us similar output to &lt;a href=&quot;b/debug&quot;&gt;B::Debug&lt;/a&gt;.</source>
          <target state="translated">我们还可以转储该op：当前op总是存储在 &lt;code&gt;PL_op&lt;/code&gt; 中，我们可以使用 &lt;code&gt;Perl_op_dump&lt;/code&gt; 进行转储。这将为我们提供与&lt;a href=&quot;b/debug&quot;&gt;B :: Debug&lt;/a&gt;类似的输出。</target>
        </trans-unit>
        <trans-unit id="6a951916387170e99fc981f4b1d58e4dc7bd8c60" translate="yes" xml:space="preserve">
          <source>We can also dump out this op: the current op is always stored in &lt;code&gt;PL_op&lt;/code&gt;, and we can dump it with &lt;code&gt;Perl_op_dump&lt;/code&gt;. This'll give us similar output to CPAN module B::Debug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961c3c25dd241cffc69783f122b1016732a7e65b" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;@&lt;/code&gt; to jump to an offset, with 0 being the position where we were when the last &lt;code&gt;(&lt;/code&gt; was encountered:</source>
          <target state="translated">我们还可以使用 &lt;code&gt;@&lt;/code&gt; 跳转到偏移量，其中0 是遇到最后一个 &lt;code&gt;(&lt;/code&gt; 时遇到的位置：</target>
        </trans-unit>
        <trans-unit id="dbea0db461430bae70d9c35bb3e6a3ab77cd3179" translate="yes" xml:space="preserve">
          <source>We can also use a variable to store a reference to the data structure that is being blessed as our object:</source>
          <target state="translated">我们也可以使用一个变量来存储对被祝福为我们对象的数据结构的引用。</target>
        </trans-unit>
        <trans-unit id="3ae43a4ae8c47d1af2dad91e0ab8b4c97424cc6a" translate="yes" xml:space="preserve">
          <source>We can also use the transliteration operator, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. In this example, the search list side of our &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; contains nothing, but the &lt;code&gt;c&lt;/code&gt; option complements that so it contains everything. The replacement list also contains nothing, so the transliteration is almost a no-op since it won't do any replacements (or more exactly, replace the character with itself). However, the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; option squashes duplicated and consecutive characters in the string so a character does not show up next to itself</source>
          <target state="translated">我们还可以使用音译运算符 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 。在此示例中， &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 的搜索列表端不包含任何内容，但是 &lt;code&gt;c&lt;/code&gt; 选项对其进行了补充，因此包含了所有内容。替换列表也不包含任何内容，因此音译几乎是空手，因为它不会进行任何替换（或更确切地说，将字符替换为自身）。但是， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 选项可压缩字符串中重复的和连续的字符，因此不会在其旁边显示一个字符</target>
        </trans-unit>
        <trans-unit id="0bc5ebb55ff053059629cd57779115c15a2ccce5" translate="yes" xml:space="preserve">
          <source>We can also use the transliteration operator, &lt;code&gt;tr///&lt;/code&gt;. In this example, the search list side of our &lt;code&gt;tr///&lt;/code&gt; contains nothing, but the &lt;code&gt;c&lt;/code&gt; option complements that so it contains everything. The replacement list also contains nothing, so the transliteration is almost a no-op since it won't do any replacements (or more exactly, replace the character with itself). However, the &lt;code&gt;s&lt;/code&gt; option squashes duplicated and consecutive characters in the string so a character does not show up next to itself</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5deb5cdcf6e21e86d4cfa078a33ffd7c085ef4" translate="yes" xml:space="preserve">
          <source>We can ask autodie to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dbd56817858a9e2d4db427c7f1f11d2cf2d4b00" translate="yes" xml:space="preserve">
          <source>We can combine the last 3 lines of the above like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9637ace5e985325b750e53a0a2e0777af26ff5" translate="yes" xml:space="preserve">
          <source>We can deal with this by using both an assertion and a negation. We'll say that the first part in $1 must be followed both by a digit and by something that's not &quot;123&quot;. Remember that the look-aheads are zero-width expressions--they only look, but don't consume any of the string in their match. So rewriting this way produces what you'd expect; that is, case 5 will fail, but case 6 succeeds:</source>
          <target state="translated">我们可以通过使用断言和否定来处理这个问题。我们可以说$1中的第一部分后面必须有一个数字和一个不是 &quot;123 &quot;的东西。请记住,look-aheads是零宽度的表达式--它们只看,但不消耗匹配中的任何字符串。所以这样重写会产生你所期望的结果;也就是说,case 5会失败,但case 6会成功。</target>
        </trans-unit>
        <trans-unit id="337b65de98d527cb6d5b86fba92bc577466c5413" translate="yes" xml:space="preserve">
          <source>We can deal with this by using both an assertion and a negation. We'll say that the first part in &lt;code&gt;$1&lt;/code&gt; must be followed both by a digit and by something that's not &quot;123&quot;. Remember that the lookaheads are zero-width expressions--they only look, but don't consume any of the string in their match. So rewriting this way produces what you'd expect; that is, case 5 will fail, but case 6 succeeds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e73838de4aed15f5d24b688fd13aef192fb3f9" translate="yes" xml:space="preserve">
          <source>We can extend the example above:</source>
          <target state="translated">我们可以扩展上面的例子。</target>
        </trans-unit>
        <trans-unit id="84c843f2491ce2ba91f8ea33bd419c025bcac31f" translate="yes" xml:space="preserve">
          <source>We can manipulate &lt;code&gt;@_&lt;/code&gt; in other ways too:</source>
          <target state="translated">我们也可以通过其他方式操纵 &lt;code&gt;@_&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c8e881a1155e87edea33bdbd7aaa36ea47df11e3" translate="yes" xml:space="preserve">
          <source>We can match different character strings with the &lt;b&gt;alternation&lt;/b&gt; metacharacter &lt;code&gt;'|'&lt;/code&gt; . To match &lt;code&gt;dog&lt;/code&gt; or &lt;code&gt;cat&lt;/code&gt; , we form the regex &lt;code&gt;dog|cat&lt;/code&gt; . As before, Perl will try to match the regex at the earliest possible point in the string. At each character position, Perl will first try to match the first alternative, &lt;code&gt;dog&lt;/code&gt; . If &lt;code&gt;dog&lt;/code&gt; doesn't match, Perl will then try the next alternative, &lt;code&gt;cat&lt;/code&gt; . If &lt;code&gt;cat&lt;/code&gt; doesn't match either, then the match fails and Perl moves to the next position in the string. Some examples:</source>
          <target state="translated">我们可以将不同的字符串与&lt;b&gt;替换&lt;/b&gt;元字符 &lt;code&gt;'|'&lt;/code&gt; 匹配 。为了匹配 &lt;code&gt;dog&lt;/code&gt; 或 &lt;code&gt;cat&lt;/code&gt; ，我们形成了正则表达式 &lt;code&gt;dog|cat&lt;/code&gt; 。和以前一样，Perl将尝试在字符串的最早点匹配正则表达式。在每个角色位置，Perl首先将尝试匹配第一个替代项 &lt;code&gt;dog&lt;/code&gt; 。如果 &lt;code&gt;dog&lt;/code&gt; 不匹配，Perl将尝试下一个选择 &lt;code&gt;cat&lt;/code&gt; 。如果 &lt;code&gt;cat&lt;/code&gt; 也不匹配，则匹配失败，Perl移至字符串中的下一个位置。一些例子：</target>
        </trans-unit>
        <trans-unit id="d6a0febb21ee098abccab9c8a03b765fef08617d" translate="yes" xml:space="preserve">
          <source>We can match different character strings with the &lt;b&gt;alternation&lt;/b&gt; metacharacter &lt;code&gt;'|'&lt;/code&gt;. To match &lt;code&gt;dog&lt;/code&gt; or &lt;code&gt;cat&lt;/code&gt;, we form the regex &lt;code&gt;dog|cat&lt;/code&gt;. As before, Perl will try to match the regex at the earliest possible point in the string. At each character position, Perl will first try to match the first alternative, &lt;code&gt;dog&lt;/code&gt;. If &lt;code&gt;dog&lt;/code&gt; doesn't match, Perl will then try the next alternative, &lt;code&gt;cat&lt;/code&gt;. If &lt;code&gt;cat&lt;/code&gt; doesn't match either, then the match fails and Perl moves to the next position in the string. Some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea854225fefa1280a29795bb4f271d273dbd77b0" translate="yes" xml:space="preserve">
          <source>We can modify principle 3 above to take into account non-greedy quantifiers:</source>
          <target state="translated">我们可以修改上面的原则3,以考虑到非贪婪的量化器。</target>
        </trans-unit>
        <trans-unit id="ab79fcd6910e13f271bf0f10b6fac2de440cb105" translate="yes" xml:space="preserve">
          <source>We can now use &lt;code&gt;Perl_sv_dump&lt;/code&gt; to investigate the SV:</source>
          <target state="translated">现在，我们可以使用 &lt;code&gt;Perl_sv_dump&lt;/code&gt; 研究SV：</target>
        </trans-unit>
        <trans-unit id="9e3ffbb12768a148e4cd9144c59ebb38f57598ff" translate="yes" xml:space="preserve">
          <source>We can override a parent's method in a child class. When we do so, we can still call the parent class's method with the &lt;code&gt;SUPER&lt;/code&gt; pseudo-class.</source>
          <target state="translated">我们可以在子类中重写父方法。这样做时，我们仍然可以使用 &lt;code&gt;SUPER&lt;/code&gt; 伪类调用父类的方法。</target>
        </trans-unit>
        <trans-unit id="2754e3aa57380296cb4f092e33ffe2f92fac593d" translate="yes" xml:space="preserve">
          <source>We can put another break point on any line beginning with a colon, we'll use line 17 as that's just as we come out of the subroutine, and we'd like to pause there later on:</source>
          <target state="translated">我们可以在任何以冒号开头的行上再加一个断点,我们用第17行,因为那是我们从子程序出来的时候,我们想稍后在那里暂停。</target>
        </trans-unit>
        <trans-unit id="8aece3bd543cbe6fe75eaf5ad6965a489841cbb4" translate="yes" xml:space="preserve">
          <source>We can put that into a test file which we can run to check which approach is the fastest, using a global &lt;code&gt;$STR&lt;/code&gt; variable to assign to the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $str&lt;/code&gt; variable so as to avoid perl trying to optimize any of the work away by noticing it's assigned only the once.</source>
          <target state="translated">我们可以将其放入测试文件中，然后使用全局 &lt;code&gt;$STR&lt;/code&gt; 变量将其分配给 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $str&lt;/code&gt; 变量，以检查哪种方法最快，从而避免perl注意到它的存在而试图优化任何工作只分配一次。</target>
        </trans-unit>
        <trans-unit id="3216d8a5e6dc84b8bbaa513843a9c89d95b551dc" translate="yes" xml:space="preserve">
          <source>We can put that into a test file which we can run to check which approach is the fastest, using a global &lt;code&gt;$STR&lt;/code&gt; variable to assign to the &lt;code&gt;my $str&lt;/code&gt; variable so as to avoid perl trying to optimize any of the work away by noticing it's assigned only the once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192c194669c26df922a17b7997201101414dafec" translate="yes" xml:space="preserve">
          <source>We can reduce some of the looping through slices</source>
          <target state="translated">我们可以减少一些通过切片的循环。</target>
        </trans-unit>
        <trans-unit id="e5d25f7f85d18366ec3d6895017e423d452f3199" translate="yes" xml:space="preserve">
          <source>We can see on line 4 that our token type is &lt;code&gt;ASSIGNOP&lt;/code&gt; (&lt;code&gt;OPERATOR&lt;/code&gt; is a macro, defined in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c1ace8b9cc4168efa6505ff7ef438700e9bd607" translate="yes" xml:space="preserve">
          <source>We cannot predict how long the database ping will take so we use Test::More's like() test to check that the diagnostic string is of the right form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661a62faa91fec217313353690ec40805d724e81" translate="yes" xml:space="preserve">
          <source>We check for duplicate entries in the typemap, but do not check for missing &lt;code&gt;TYPEMAP&lt;/code&gt; entries for &lt;code&gt;INPUTMAP&lt;/code&gt; or &lt;code&gt;OUTPUTMAP&lt;/code&gt; entries since these might be hidden in a different typemap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393d2cf123dc0cecdbadd1ca8c26943dc464db54" translate="yes" xml:space="preserve">
          <source>We could get more fancy in the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; block though. Instead of comparing the keys, we can compute a value with them and use that value as the comparison.</source>
          <target state="translated">不过，我们可以在 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 块中得到更多的效果。无需比较键，我们可以使用它们计算一个值并将该值用作比较。</target>
        </trans-unit>
        <trans-unit id="1bcc7cd7b768900689b6b050ac1c7aac10dad46e" translate="yes" xml:space="preserve">
          <source>We could get more fancy in the &lt;code&gt;sort()&lt;/code&gt; block though. Instead of comparing the keys, we can compute a value with them and use that value as the comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373abf531902aa68eac45baf244872a1e2626f66" translate="yes" xml:space="preserve">
          <source>We could have both classes inherit from a common parent, like &lt;code&gt;Machine&lt;/code&gt; , but not all machines have on/off switches. We could create a parent class called &lt;code&gt;HasOnOffSwitch&lt;/code&gt; , but that is very artificial. Radios and computers are not specializations of this parent. This parent is really a rather ridiculous creation.</source>
          <target state="translated">我们可以让这两个类都从一个共同的父类（例如 &lt;code&gt;Machine&lt;/code&gt; )继承，但是并非所有机器都具有on / off开关。我们可以创建一个名为 &lt;code&gt;HasOnOffSwitch&lt;/code&gt; 的父类，但这是非常人为的。收音机和计算机不是该父母的专业。这个父母确实是一个相当荒谬的创造。</target>
        </trans-unit>
        <trans-unit id="859c345eb5fe4bc62f73981c70642999b8e4b03c" translate="yes" xml:space="preserve">
          <source>We could have both classes inherit from a common parent, like &lt;code&gt;Machine&lt;/code&gt;, but not all machines have on/off switches. We could create a parent class called &lt;code&gt;HasOnOffSwitch&lt;/code&gt;, but that is very artificial. Radios and computers are not specializations of this parent. This parent is really a rather ridiculous creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ce6432aa57322234fa603b7b093664929a40c6" translate="yes" xml:space="preserve">
          <source>We could have used an unpack template &lt;code&gt;'b12'&lt;/code&gt; just as well, since the last 4 bits can be ignored anyway.</source>
          <target state="translated">我们也可以使用解压缩模板 &lt;code&gt;'b12'&lt;/code&gt; ，因为无论如何最后4位都可以忽略。</target>
        </trans-unit>
        <trans-unit id="737f5642c49143f79a5e632705526d6d3453018c" translate="yes" xml:space="preserve">
          <source>We do this by using the PPCODE: directive, rather than the CODE: directive. This tells &lt;b&gt;xsubpp&lt;/b&gt; that we will be managing the return values that will be put on the argument stack by ourselves.</source>
          <target state="translated">我们通过使用PPCODE：指令而不是CODE：指令来做到这一点。这告诉&lt;b&gt;xsubpp&lt;/b&gt;，我们将管理自己将放到参数堆栈中的返回值。</target>
        </trans-unit>
        <trans-unit id="bbf4d60422d93cc3418f9928672ab7a165e0c448" translate="yes" xml:space="preserve">
          <source>We don't have much experience with this yet, but try the following:</source>
          <target state="translated">我们还没有太多经验,但可以试试下面的方法。</target>
        </trans-unit>
        <trans-unit id="3714a8cbbcb3d8e34c4cf78e7eb46446670ccdf4" translate="yes" xml:space="preserve">
          <source>We don't have to hard-code patterns into the match operator (or anything else that works with regular expressions). We can put the pattern in a variable for later use.</source>
          <target state="translated">我们不必将模式硬编码到匹配操作符中(或其他任何与正则表达式一起使用的东西)。我们可以把模式放在一个变量中,供以后使用。</target>
        </trans-unit>
        <trans-unit id="9b9b047b90e6f20cc1587612f1c7f873786eee50" translate="yes" xml:space="preserve">
          <source>We encourage using this rather than calling print directly.</source>
          <target state="translated">我们鼓励使用这个而不是直接调用打印。</target>
        </trans-unit>
        <trans-unit id="7ef0cc263f45630948ec977db18c296d89495351" translate="yes" xml:space="preserve">
          <source>We encourage vendors to ship the most recent supported release of Perl at the time of their code freeze.</source>
          <target state="translated">我们鼓励厂商在冻结代码时提供最新支持的Perl版本。</target>
        </trans-unit>
        <trans-unit id="dd33c6dcc68f66e550d47a04957cd34a37a4f9d0" translate="yes" xml:space="preserve">
          <source>We encourage you to play with and evaluate &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class::Accessor&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt; to see which OO system is right for you.</source>
          <target state="translated">我们鼓励您使用&lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class :: Accessor&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class :: Tiny&lt;/a&gt;并对其进行评估，以查看哪种OO系统适合您。</target>
        </trans-unit>
        <trans-unit id="f6dd2243ed823c9d407fa450eaf7b53699b60af0" translate="yes" xml:space="preserve">
          <source>We encourage you to play with and evaluate &lt;a href=&quot;moose&quot;&gt;Moose&lt;/a&gt;, &lt;a href=&quot;moo&quot;&gt;Moo&lt;/a&gt;, &lt;a href=&quot;Class::Accessor&quot;&gt;Class::Accessor&lt;/a&gt;, and &lt;a href=&quot;Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt; to see which OO system is right for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75ee8e59a59e98ee82483d5a167a8e74430cf9d" translate="yes" xml:space="preserve">
          <source>We fix our quoting: 'tom' =&amp;gt; q(and jerry), and run it again, this time we get our expected output:</source>
          <target state="translated">我们更正了引号：'tom'=&amp;gt; q（和jerry），然后再次运行它，这一次我们获得了预期的输出：</target>
        </trans-unit>
        <trans-unit id="ad7822a7bc01015524040b6228bd7a714fe0ea5e" translate="yes" xml:space="preserve">
          <source>We have already introduced the matching operator in its default &lt;code&gt;/regexp/&lt;/code&gt; and arbitrary delimiter &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m!regexp!&lt;/a&gt;&lt;/code&gt; forms. We have used the binding operator &lt;code&gt;=~&lt;/code&gt; and its negation &lt;code&gt;!~&lt;/code&gt; to test for string matches. Associated with the matching operator, we have discussed the single line &lt;code&gt;//s&lt;/code&gt; , multi-line &lt;code&gt;//m&lt;/code&gt; , case-insensitive &lt;code&gt;//i&lt;/code&gt; and extended &lt;code&gt;//x&lt;/code&gt; modifiers. There are a few more things you might want to know about matching operators.</source>
          <target state="translated">我们已经在其默认的 &lt;code&gt;/regexp/&lt;/code&gt; 和任意定界符 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m!regexp!&lt;/a&gt;&lt;/code&gt; 中引入了匹配运算符！形式。我们已经使用绑定运算符 &lt;code&gt;=~&lt;/code&gt; 及其否定项 &lt;code&gt;!~&lt;/code&gt; 来测试字符串匹配。与匹配运算符相关联，我们讨论了单行 &lt;code&gt;//s&lt;/code&gt; ，多行 &lt;code&gt;//m&lt;/code&gt; ，不区分大小写的 &lt;code&gt;//i&lt;/code&gt; 和扩展的 &lt;code&gt;//x&lt;/code&gt; 修饰符。关于匹配运算符，您可能还需要了解几件事。</target>
        </trans-unit>
        <trans-unit id="4ec0698febe8baf604343239295eca801edc1950" translate="yes" xml:space="preserve">
          <source>We have already introduced the matching operator in its default &lt;code&gt;/regexp/&lt;/code&gt; and arbitrary delimiter &lt;code&gt;m!regexp!&lt;/code&gt; forms. We have used the binding operator &lt;code&gt;=~&lt;/code&gt; and its negation &lt;code&gt;!~&lt;/code&gt; to test for string matches. Associated with the matching operator, we have discussed the single line &lt;code&gt;/s&lt;/code&gt;, multi-line &lt;code&gt;/m&lt;/code&gt;, case-insensitive &lt;code&gt;/i&lt;/code&gt; and extended &lt;code&gt;/x&lt;/code&gt; modifiers. There are a few more things you might want to know about matching operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e2bfdcf3348ad31286e830869ab5ab9cf57a976" translate="yes" xml:space="preserve">
          <source>We have no nroff on BS2000 POSIX (yet), so we ignored any errors while installing the documentation.</source>
          <target state="translated">我们在BS2000 POSIX上没有nroff(还没有),所以我们在安装文档时忽略了任何错误。</target>
        </trans-unit>
        <trans-unit id="c5a4c49687cb5b4e725178b1ad770374684a7f19" translate="yes" xml:space="preserve">
          <source>We have to use a &lt;code&gt;CODE&lt;/code&gt; section because &lt;code&gt;PerlIO_puts()&lt;/code&gt; has the arguments reversed compared to &lt;code&gt;fputs()&lt;/code&gt; , and we want to keep the arguments the same.</source>
          <target state="translated">我们必须使用 &lt;code&gt;CODE&lt;/code&gt; 节，因为与 &lt;code&gt;fputs()&lt;/code&gt; 相比， &lt;code&gt;PerlIO_puts()&lt;/code&gt; 具有相反的参数，并且我们希望保持相同的参数。</target>
        </trans-unit>
        <trans-unit id="094b6bf4440df57d740fc419f243cfd8a6cfc13d" translate="yes" xml:space="preserve">
          <source>We have to use a &lt;code&gt;CODE&lt;/code&gt; section because &lt;code&gt;PerlIO_puts()&lt;/code&gt; has the arguments reversed compared to &lt;code&gt;fputs()&lt;/code&gt;, and we want to keep the arguments the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a78632eb571a6503bee4006e791fffefd6cf4ab" translate="yes" xml:space="preserve">
          <source>We have tried to make Perl aware of both VMS-style and Unix-style file specifications wherever possible. You may use either style, or both, on the command line and in scripts, but you may not combine the two styles within a single file specification. VMS Perl interprets Unix pathnames in much the same way as the CRTL (</source>
          <target state="translated">我们试图让Perl尽可能地了解VMS风格和Unix风格的文件规范。你可以在命令行和脚本中使用其中一种风格,或者两种风格都使用,但是你不能在一个文件规范中结合两种风格。VMS Perl 解释 Unix 路径名的方式与 CRTL(</target>
        </trans-unit>
        <trans-unit id="78dd390dcc77c45fe1854b3e48358f0f7f0c1ae7" translate="yes" xml:space="preserve">
          <source>We highly discourage this method. It should only be used if you know what you're doing and specifically need the PREFIX behavior. The PREFIX algorithm is complicated and focused on matching the system installation.</source>
          <target state="translated">我们非常不鼓励这种方法。只有当你知道自己在做什么,并且特别需要Prefix行为时,才应该使用它。PREFIX算法很复杂,而且专注于匹配系统安装。</target>
        </trans-unit>
        <trans-unit id="0d078f205cc7733f26f4527b8b9a508a7c925969" translate="yes" xml:space="preserve">
          <source>We highly recommend the install_base method, its the simplest and most closely approximates the expected behavior of an installation prefix.</source>
          <target state="translated">我们强烈推荐 install_base 方法,它是最简单的,最接近安装前缀的预期行为。</target>
        </trans-unit>
        <trans-unit id="cf829d6773d2acaf89ace4612301d748f71133de" translate="yes" xml:space="preserve">
          <source>We hope these notes will save you from confusion and lost sleep when writing Perl scripts on VMS. If you find we've missed something you think should appear here, please don't hesitate to drop a line to vmsperl@perl.org.</source>
          <target state="translated">我们希望这些说明能让您在VMS上编写Perl脚本时免于困惑和失眠。如果你发现我们遗漏了一些你认为应该出现在这里的东西,请不要犹豫,请发邮件到 vmsperl@perl.org。</target>
        </trans-unit>
        <trans-unit id="c62eabab19d963ec1dc9f96b723cb4b48b7d1ebd" translate="yes" xml:space="preserve">
          <source>We implement our own glob-style pattern matching for --rules. Here are the supported patterns:</source>
          <target state="translated">我们为--rules实现了我们自己的glob式模式匹配。以下是支持的模式。</target>
        </trans-unit>
        <trans-unit id="f3c2a6f9803dfeb38af1055d966366fc67acbab0" translate="yes" xml:space="preserve">
          <source>We implement our own glob-style pattern matching. Here are the patterns it supports:</source>
          <target state="translated">我们实现了自己的 glob 式模式匹配。以下是它支持的模式。</target>
        </trans-unit>
        <trans-unit id="821afd715774631771e27078ffd6e046b44c39d8" translate="yes" xml:space="preserve">
          <source>We know we're going to get &lt;code&gt;6&lt;/code&gt; from this, so let's finish the subroutine:</source>
          <target state="translated">我们知道我们将从中得到 &lt;code&gt;6&lt;/code&gt; ，所以让我们完成子例程：</target>
        </trans-unit>
        <trans-unit id="56ac7541ed28a7466aa3352e9da342249eeae09f" translate="yes" xml:space="preserve">
          <source>We looked at this bit of code before, and we said that &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; arranges for two &lt;code&gt;NV&lt;/code&gt; s to be placed into &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; - let's slightly expand it:</source>
          <target state="translated">我们期待在此位的代码之前，我们说 &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; 排列两 &lt;code&gt;NV&lt;/code&gt; s到被放置到 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; -让我们稍微展开：</target>
        </trans-unit>
        <trans-unit id="5ca3334b72be201a6a79c8d27231d9f82fb916a8" translate="yes" xml:space="preserve">
          <source>We looked at this bit of code before, and we said that &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; arranges for two &lt;code&gt;NV&lt;/code&gt;s to be placed into &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; - let's slightly expand it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8f7ecbf0eb0e715d021c51919b36afbf4f3b1d" translate="yes" xml:space="preserve">
          <source>We maintain the binary incompatibility.</source>
          <target state="translated">我们维持二进制的不兼容。</target>
        </trans-unit>
        <trans-unit id="0fd132a408c3e7900b7667b28ffdaffdc2cfda3e" translate="yes" xml:space="preserve">
          <source>We manipulate several arrays in this XSUB. Note that an array is represented internally by an AV* pointer. The functions and macros for manipulating arrays are similar to the functions in Perl: &lt;code&gt;av_top_index&lt;/code&gt; returns the highest index in an AV*, much like $#array; &lt;code&gt;av_fetch&lt;/code&gt; fetches a single scalar value from an array, given its index; &lt;code&gt;av_push&lt;/code&gt; pushes a scalar value onto the end of the array, automatically extending the array as necessary.</source>
          <target state="translated">我们在此XSUB中操纵几个数组。注意，数组在内部由AV *指针表示。操纵数组的函数和宏与Perl中的函数相似： &lt;code&gt;av_top_index&lt;/code&gt; 返回AV *中的最高索引，与$＃array相似； &lt;code&gt;av_fetch&lt;/code&gt; 从数组中获取给定索引的单个标量值； &lt;code&gt;av_push&lt;/code&gt; 将标量值推入数组的末尾，并根据需要自动扩展数组。</target>
        </trans-unit>
        <trans-unit id="6201b3e74828151a0b8123986740745576c51a04" translate="yes" xml:space="preserve">
          <source>We may change it so that things that remain legal uses in normal bracketed character classes might become illegal within this experimental construct. One proposal, for example, is to forbid adjacent uses of the same character, as in &lt;code&gt;(?[ [aa] ])&lt;/code&gt; . The motivation for such a change is that this usage is likely a typo, as the second &quot;a&quot; adds nothing.</source>
          <target state="translated">我们可能会对其进行更改，以使在正常的带括号的字符类中仍然合法使用的东西在此实验性构造中可能变得非法。例如，一个建议是禁止与 &lt;code&gt;(?[ [aa] ])&lt;/code&gt; 相同字符的相邻使用。进行此更改的动机是此用法可能是拼写错误，因为第二个&amp;ldquo; a&amp;rdquo;不添加任何内容。</target>
        </trans-unit>
        <trans-unit id="6f8e2edefd5e426a509917090b4bcf0d615987a3" translate="yes" xml:space="preserve">
          <source>We may change it so that things that remain legal uses in normal bracketed character classes might become illegal within this experimental construct. One proposal, for example, is to forbid adjacent uses of the same character, as in &lt;code&gt;(?[ [aa] ])&lt;/code&gt;. The motivation for such a change is that this usage is likely a typo, as the second &quot;a&quot; adds nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8db65a7f163486a998a7bf47269c4123bd2dc9" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that most Perl objects are implemented as hashes under the hood. The principle of encapsulation tells us that we should not rely on this. Instead, we should use accessor methods to access the data in that hash. The object systems that we recommend below all automate the generation of accessor methods. If you use one of them, you should never have to access the object as a hash directly.</source>
          <target state="translated">前面我们提到过,大多数Perl对象都是在引擎盖下以哈希的形式实现的。封装的原则告诉我们,我们不应该依赖这个。相反,我们应该使用访问器方法来访问该哈希中的数据。下面我们推荐的对象系统都能自动生成访问者方法。如果你使用了其中的一个,你应该永远都不用直接访问该对象作为哈希。</target>
        </trans-unit>
        <trans-unit id="fd2e3b2237cf2c9ebd6d21ee18dff2f93d4edaee" translate="yes" xml:space="preserve">
          <source>We mentioned multiple inheritance earlier. The main problem with multiple inheritance is that it greatly complicates method resolution. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more details.</source>
          <target state="translated">我们前面提到了多重继承。多重继承的主要问题在于，它极大地使方法解析变得复杂。有关更多详细信息，请参见&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05de83678232988de23cc08caee2a559bec4d96c" translate="yes" xml:space="preserve">
          <source>We must know how much to read.</source>
          <target state="translated">我们必须知道要读多少书。</target>
        </trans-unit>
        <trans-unit id="786b499d8e7780442a91c12acac79f0bab40bb9c" translate="yes" xml:space="preserve">
          <source>We now compile up Perl, and run it through the test suite. Our new tests pass, hooray!</source>
          <target state="translated">现在我们编译Perl,并在测试套件中运行它。我们的新测试通过了,万岁</target>
        </trans-unit>
        <trans-unit id="885cb8f93d773c304687f5c7d8f7995e03fd1f70" translate="yes" xml:space="preserve">
          <source>We now know how to create choices among classes of characters in a regexp. What about choices among words or character strings? Such choices are described in the next section.</source>
          <target state="translated">我们现在知道了如何在regexp中创建字符类的选择。那么在单词或字符串之间的选择呢?这种选择将在下一节中介绍。</target>
        </trans-unit>
        <trans-unit id="68e3b46c3317fe81b8a4f43f4375d9dc3eef2342" translate="yes" xml:space="preserve">
          <source>We often refer to inheritance relationships as &lt;b&gt;parent-child&lt;/b&gt; or &lt;code&gt;superclass/subclass&lt;/code&gt; relationships. Sometimes we say that the child has an &lt;b&gt;is-a&lt;/b&gt; relationship with its parent class.</source>
          <target state="translated">我们通常将继承关系称为&lt;b&gt;父子&lt;/b&gt;关系或 &lt;code&gt;superclass/subclass&lt;/code&gt; 关系。有时我们说孩子与其父类之间存在&lt;b&gt;is-a&lt;/b&gt;关系。</target>
        </trans-unit>
        <trans-unit id="99514bb04979cf0a47e2cf2b143ea1390fb7e139" translate="yes" xml:space="preserve">
          <source>We often refer to inheritance relationships as &lt;b&gt;parent-child&lt;/b&gt; or &lt;code&gt;superclass&lt;/code&gt;/&lt;code&gt;subclass&lt;/code&gt; relationships. Sometimes we say that the child has an &lt;b&gt;is-a&lt;/b&gt; relationship with its parent class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fd14d3b6f6bb386e0f6cc77e29f8b6538c7a73" translate="yes" xml:space="preserve">
          <source>We recognize that the Perl core, defined as the software distributed with the heart of Perl itself, is a joint project on the part of all of us. From time to time, a script, module, or set of modules (hereafter referred to simply as a &quot;module&quot;) will prove so widely useful and/or so integral to the correct functioning of Perl itself that it should be distributed with the Perl core. This should never be done without the author's explicit consent, and a clear recognition on all parts that this means the module is being distributed under the same terms as Perl itself. A module author should realize that inclusion of a module into the Perl core will necessarily mean some loss of control over it, since changes may occasionally have to be made on short notice or for consistency with the rest of Perl.</source>
          <target state="translated">我们认识到,Perl 核心(定义为与 Perl 本身的核心一起发布的软件)是我们所有人的共同项目。有时,一个脚本、模块或一组模块(以下简称为 &quot;模块&quot;)会被证明是非常有用的,或者说对 Perl 本身的正常运行是不可或缺的,因此它应该和 Perl 核心一起发布。如果没有作者的明确同意,并且所有的人都清楚地认识到这意味着该模块是在与 Perl 本身相同的条件下发布的,那么就不应该这样做。模块的作者应该意识到,将一个模块纳入 Perl 核心,必然意味着对它的控制权的丧失,因为有时可能需要在短时间内进行修改,或者为了与 Perl 的其他部分保持一致。</target>
        </trans-unit>
        <trans-unit id="adbff354730155d973632a844ddac8001f83317b" translate="yes" xml:space="preserve">
          <source>We recommend InfoZIP: &lt;a href=&quot;http://www.info-zip.org/Zip.html&quot;&gt;http://www.info-zip.org/Zip.html&lt;/a&gt;</source>
          <target state="translated">我们建议使用InfoZIP：&lt;a href=&quot;http://www.info-zip.org/Zip.html&quot;&gt;http&lt;/a&gt;：//www.info-zip.org/Zip.html</target>
        </trans-unit>
        <trans-unit id="4f1a977094921f3a67ec1b5d153f5c0398eec08d" translate="yes" xml:space="preserve">
          <source>We recommend ptar from Archive::Tar not older than 1.66 with '-C' option.</source>
          <target state="translated">我们建议使用'-C'选项从Archive::Tar中下载不超过1.66的ptar。</target>
        </trans-unit>
        <trans-unit id="cbe1fc263dadb40ca151eed92966c9248a04de8d" translate="yes" xml:space="preserve">
          <source>We recommend that you avoid this syntax, for several reasons.</source>
          <target state="translated">我们建议你避免使用这种语法,原因如下。</target>
        </trans-unit>
        <trans-unit id="579e792fc6edac0deca16c23591b561128b4c15e" translate="yes" xml:space="preserve">
          <source>We recommend that you only access attributes via &lt;b&gt;accessor&lt;/b&gt; methods. These are methods that can get or set the value of each attribute. We saw this earlier in the &lt;code&gt;print_info()&lt;/code&gt; example, which calls &lt;code&gt;$self-&amp;gt;path&lt;/code&gt; .</source>
          <target state="translated">我们建议您仅通过访问&lt;b&gt;器&lt;/b&gt;方法访问属性。这些方法可以获取或设置每个属性的值。我们在前面的 &lt;code&gt;print_info()&lt;/code&gt; 示例中看到了这一点，该示例调用 &lt;code&gt;$self-&amp;gt;path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c3f8a0812714182851aed9fbbd140faf18d7041" translate="yes" xml:space="preserve">
          <source>We recommend that you only access attributes via &lt;b&gt;accessor&lt;/b&gt; methods. These are methods that can get or set the value of each attribute. We saw this earlier in the &lt;code&gt;print_info()&lt;/code&gt; example, which calls &lt;code&gt;$self-&amp;gt;path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd090bb786563ac9394aa0d7f58e631fb54d86e" translate="yes" xml:space="preserve">
          <source>We recommend that you use this method to access another package's version, rather than looking directly at &lt;code&gt;$Package::VERSION&lt;/code&gt; . The package you are looking at could have overridden the &lt;code&gt;VERSION&lt;/code&gt; method.</source>
          <target state="translated">我们建议您使用此方法访问另一个软件包的版本，而不是直接查看 &lt;code&gt;$Package::VERSION&lt;/code&gt; 。您正在查看的软件包可能已覆盖 &lt;code&gt;VERSION&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="6418d5ecc21157f156342ad6f603ad1e78f241b1" translate="yes" xml:space="preserve">
          <source>We recommend that you use this method to access another package's version, rather than looking directly at &lt;code&gt;$Package::VERSION&lt;/code&gt;. The package you are looking at could have overridden the &lt;code&gt;VERSION&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3584759389d1a5c9463e1916b5f8cba299128724" translate="yes" xml:space="preserve">
          <source>We said that references spring into existence as necessary if they are undefined, but we didn't say what happens if a value used as a reference is already defined, but</source>
          <target state="translated">我们说过,如果引用未被定义,那么引用就会根据需要而产生,但我们没有说如果用作引用的值已经被定义了,会发生什么,但</target>
        </trans-unit>
        <trans-unit id="66792931fda90822c58a9263a870978d6e867c09" translate="yes" xml:space="preserve">
          <source>We saw in the section above that there were ordinary characters, which represented themselves, and special characters, which needed a backslash &lt;code&gt;'\'&lt;/code&gt; to represent themselves. The same is true in a character class, but the sets of ordinary and special characters inside a character class are different than those outside a character class. The special characters for a character class are &lt;code&gt;-]\^$&lt;/code&gt; (and the pattern delimiter, whatever it is). &lt;code&gt;']'&lt;/code&gt; is special because it denotes the end of a character class. &lt;code&gt;'$'&lt;/code&gt; is special because it denotes a scalar variable. &lt;code&gt;'\'&lt;/code&gt; is special because it is used in escape sequences, just like above. Here is how the special characters &lt;code&gt;]$\&lt;/code&gt; are handled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e706dab14e9082a067c69407d520e37d14c840" translate="yes" xml:space="preserve">
          <source>We saw in the section above that there were ordinary characters, which represented themselves, and special characters, which needed a backslash &lt;code&gt;\&lt;/code&gt; to represent themselves. The same is true in a character class, but the sets of ordinary and special characters inside a character class are different than those outside a character class. The special characters for a character class are &lt;code&gt;-]\^$&lt;/code&gt; (and the pattern delimiter, whatever it is). &lt;code&gt;]&lt;/code&gt; is special because it denotes the end of a character class. &lt;code&gt;$&lt;/code&gt; is special because it denotes a scalar variable. &lt;code&gt;\&lt;/code&gt; is special because it is used in escape sequences, just like above. Here is how the special characters &lt;code&gt;]$\&lt;/code&gt; are handled:</source>
          <target state="translated">我们在上一节中看到，有普通字符表示自己，而特殊字符则需要反斜杠 &lt;code&gt;\&lt;/code&gt; 表示自己。在字符类中也是如此，但是字符类内的普通字符和特殊字符集与字符类外的字符集不同。字符类的特殊字符是 &lt;code&gt;-]\^$&lt;/code&gt; （以及模式定界符，无论它是什么）。 &lt;code&gt;]&lt;/code&gt; 是特殊的，因为它表示字符类的结尾。 &lt;code&gt;$&lt;/code&gt; 之所以特殊是因为它表示一个标量变量。 &lt;code&gt;\&lt;/code&gt; 之所以很特殊，是因为它用于转义序列中，就像上面一样。以下是特殊字符 &lt;code&gt;]$\&lt;/code&gt; 的处理方式：</target>
        </trans-unit>
        <trans-unit id="91ab61be245cfbe060001be5799707fcb012f47d" translate="yes" xml:space="preserve">
          <source>We saw that the norm of &lt;code&gt;z&lt;/code&gt; was noted &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt; and was defined as the distance to the origin, also known as:</source>
          <target state="translated">我们看到的规范 &lt;code&gt;z&lt;/code&gt; 指出 &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt; ，并定义为原点，也被称为距离：</target>
        </trans-unit>
        <trans-unit id="e2c4be4000d0f7dd961c043239fc9f3b3b2b02bf" translate="yes" xml:space="preserve">
          <source>We saw that the norm of &lt;code&gt;z&lt;/code&gt; was noted &lt;code&gt;abs(z)&lt;/code&gt; and was defined as the distance to the origin, also known as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08920844359a9b99eec6c4ed6a36e0f532af1cca" translate="yes" xml:space="preserve">
          <source>We show the &quot;put&quot; form of the accessors below (i.e., the syntax you use for setting the accessor to a specific value). But you can also call each method with no parameters to get its current value. For example, &lt;code&gt;$self-&amp;gt;contents_file()&lt;/code&gt; returns the current value of the contents_file attribute.</source>
          <target state="translated">我们在下面显示访问器的&amp;ldquo; put&amp;rdquo;形式（即，用于将访问器设置为特定值的语法）。但是，您也可以不使用任何参数来调用每个方法以获取其当前值。例如， &lt;code&gt;$self-&amp;gt;contents_file()&lt;/code&gt; 返回contents_file属性的当前值。</target>
        </trans-unit>
        <trans-unit id="d711adc8921158fc2754824f56564036d9f3cc37" translate="yes" xml:space="preserve">
          <source>We specify a local port in the &lt;code&gt;LocalPort&lt;/code&gt; argument, which we didn't do for the client. This is service name or port number for which you want to be the server. (Under Unix, ports under 1024 are restricted to the superuser.) In our sample, we'll use port 9000, but you can use any port that's not currently in use on your system. If you try to use one already in used, you'll get an &quot;Address already in use&quot; message. Under Unix, the &lt;code&gt;netstat -a&lt;/code&gt; command will show which services current have servers.</source>
          <target state="translated">我们在 &lt;code&gt;LocalPort&lt;/code&gt; 参数中指定一个本地端口，而我们并未为客户端做此操作。这是您要用作服务器的服务名称或端口号。（在Unix下，低于1024的端口仅限于超级用户。）在我们的示例中，我们将使用端口9000，但是您可以使用系统上当前未使用的任何端口。如果您尝试使用已使用的地址，则会收到&amp;ldquo;地址已使用&amp;rdquo;消息。在Unix下， &lt;code&gt;netstat -a&lt;/code&gt; 命令将显示当前具有服务器的服务。</target>
        </trans-unit>
        <trans-unit id="d2e82c57891dd489170077bbfa6bd5d7eef124d7" translate="yes" xml:space="preserve">
          <source>We still got a few errors during &lt;code&gt;make test&lt;/code&gt; . Some of them are the result of using bison. Bison prints</source>
          <target state="translated">在进行 &lt;code&gt;make test&lt;/code&gt; 我们仍然有一些错误。其中一些是使用野牛的结果。野牛版画</target>
        </trans-unit>
        <trans-unit id="caf05cb06344b1573e32848467a1dff2088a1df3" translate="yes" xml:space="preserve">
          <source>We still got a few errors during &lt;code&gt;make test&lt;/code&gt;. Some of them are the result of using bison. Bison prints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d27fd099f66e666f815d6a063eb846b9d1e750a" translate="yes" xml:space="preserve">
          <source>We still use the normal yacc for a2p.y though!!! We made a softlink called byacc to distinguish between the two versions:</source>
          <target state="translated">不过我们还是用普通的yacc来做a2p.y!!! 我们做了一个名为byacc的软链接来区分这两个版本。</target>
        </trans-unit>
        <trans-unit id="f7a01cac535c65877c2cb721bb86383129124455" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use git if possible. It will make your life easier, and ours as well.</source>
          <target state="translated">我们强烈建议您尽可能使用 git。它将使您和我们的生活更加轻松。</target>
        </trans-unit>
        <trans-unit id="c1224f92134a2160e75f8a1e63e0730529cc456d" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use one of these systems. Even the most minimal of them eliminates a lot of repetitive boilerplate. There's really no good reason to write your classes from scratch in Perl.</source>
          <target state="translated">我们强烈建议你使用这些系统之一。即使是最简陋的系统,也能消除很多重复的模板。真的没有理由在Perl中从头开始写你的类。</target>
        </trans-unit>
        <trans-unit id="5f4fa8e578a8c0a7391c3d072ae8a1a053f0a384" translate="yes" xml:space="preserve">
          <source>We tend to avoid this term because it means so many things. It may mean a command-line &lt;b&gt;switch&lt;/b&gt; that takes no argument itself (such as Perl&amp;rsquo;s &lt;code&gt;&amp;ndash;n&lt;/code&gt; and &lt;code&gt;&amp;ndash;p&lt;/code&gt; flags) or, less frequently, a single-bit indicator (such as the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags used in &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;). Sometimes informally used to refer to certain regex modifiers.</source>
          <target state="translated">我们倾向于避免使用这个术语，因为它意味着很多东西。这可能意味着命令行&lt;b&gt;开关&lt;/b&gt;本身不带任何参数（例如Perl的 &lt;code&gt;&amp;ndash;n&lt;/code&gt; 和 &lt;code&gt;&amp;ndash;p&lt;/code&gt; 标志），或者不经常使用单个位的指示符（例如 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 中使用的 &lt;code&gt;O_CREAT&lt;/code&gt; 和 &lt;code&gt;O_EXCL&lt;/code&gt; 标志）。有时非正式地用于指代某些正则表达式修饰符。</target>
        </trans-unit>
        <trans-unit id="4d3626274dd1f26da66510777516b4ddde9437ec" translate="yes" xml:space="preserve">
          <source>We tend to avoid this term because it means so many things. It may mean a command-line &lt;b&gt;switch&lt;/b&gt; that takes no argument itself (such as Perl&amp;rsquo;s &lt;code&gt;&amp;ndash;n&lt;/code&gt; and &lt;code&gt;&amp;ndash;p&lt;/code&gt; flags) or, less frequently, a single-bit indicator (such as the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags used in &lt;code&gt;sysopen&lt;/code&gt;). Sometimes informally used to refer to certain regex modifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3b4e98c264bb32d9998c5d96e9cb12719e9b31" translate="yes" xml:space="preserve">
          <source>We then do (always a good idea) a syntax check before we try to run it again:</source>
          <target state="translated">然后,在我们再次尝试运行它之前,我们要做一次语法检查(总是一个好主意)。</target>
        </trans-unit>
        <trans-unit id="a54d539385035f7d9714e68587e437b9e809a0a4" translate="yes" xml:space="preserve">
          <source>We use the term &quot;nearly&quot;, because &lt;code&gt;:not_characters&lt;/code&gt; also turns on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; within its scope. This form is less useful in v5.20 and later, and is described fully in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;, but briefly, it tells Perl to not use the character portions of the locale definition, that is the &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt; categories. Instead it will use the native character set (extended by Unicode). When using this parameter, you are responsible for getting the external character set translated into the native/Unicode one (which it already will be if it is one of the increasingly popular UTF-8 locales). There are convenient ways of doing this, as described in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;.</source>
          <target state="translated">我们使用术语&amp;ldquo;几乎&amp;rdquo;，因为 &lt;code&gt;:not_characters&lt;/code&gt; 还会在其范围内启用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 。此格式在v5.20及更高版本中不太有用，并且在&lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode和UTF-8&lt;/a&gt;中进行了完整描述，但简要地说，它告诉Perl不要使用语言环境定义的字符部分，即 &lt;code&gt;LC_CTYPE&lt;/code&gt; 和 &lt;code&gt;LC_COLLATE&lt;/code&gt; 类别。相反，它将使用本机字符集（由Unicode扩展）。使用此参数时，您有责任将外部字符集转换为本地/ Unicode字符集（如果它是越来越流行的UTF-8语言环境之一，则已经存在）。有很方便的方法，如&lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode和UTF-8中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff19ea46c35bfebd3ad06b673f58043424fd7951" translate="yes" xml:space="preserve">
          <source>We use the term &quot;nearly&quot;, because &lt;code&gt;:not_characters&lt;/code&gt; also turns on &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; within its scope. This form is less useful in v5.20 and later, and is described fully in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;&quot;Unicode and UTF-8&quot;&lt;/a&gt;, but briefly, it tells Perl to not use the character portions of the locale definition, that is the &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt; categories. Instead it will use the native character set (extended by Unicode). When using this parameter, you are responsible for getting the external character set translated into the native/Unicode one (which it already will be if it is one of the increasingly popular UTF-8 locales). There are convenient ways of doing this, as described in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;&quot;Unicode and UTF-8&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72bbd81e111127cc31735e5170b3d3ebdc6c5df" translate="yes" xml:space="preserve">
          <source>We used version 1.2.4, which could be installed out of the box with one failure during 'make check'.</source>
          <target state="translated">我们使用的是1.2.4版本,在 &quot;make check &quot;过程中,只要有一次失败,就可以开箱安装。</target>
        </trans-unit>
        <trans-unit id="aff45f6c939582aab469b75158efc5869d3a2fcf" translate="yes" xml:space="preserve">
          <source>We want to be able to catch the</source>
          <target state="translated">我们希望能够抓住</target>
        </trans-unit>
        <trans-unit id="da129d4b3f31bc7e0cab0dd659997b6d3ef9282c" translate="yes" xml:space="preserve">
          <source>We want to ensure that Perl continues to grow and flourish in the coming years and decades, but not at the expense of our user community.</source>
          <target state="translated">我们希望确保Perl在未来的几年和几十年里继续发展和繁荣,但不能以牺牲我们的用户社区为代价。</target>
        </trans-unit>
        <trans-unit id="7602b11fb920ddd30994aa4313930abda93469a9" translate="yes" xml:space="preserve">
          <source>We wanted list context, so G_ARRAY was used.</source>
          <target state="translated">我们想要的是列表上下文,所以使用了G_ARRAY。</target>
        </trans-unit>
        <trans-unit id="8da0820534457147c458ba35d650b1d2014dcd98" translate="yes" xml:space="preserve">
          <source>We will accept 1.00 and 1.75 but not 0.50 or 2.00.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3134ffe8598077df7a151748c12e387529c7d2bc" translate="yes" xml:space="preserve">
          <source>We will be calling the test script through the command &quot;&lt;code&gt;make test&lt;/code&gt; &quot;. You should see output that looks something like this:</source>
          <target state="translated">我们将通过&amp;ldquo; &lt;code&gt;make test&lt;/code&gt; &amp;rdquo; 命令调用测试脚本。您应该看到如下所示的输出：</target>
        </trans-unit>
        <trans-unit id="bed8e3523336143bfae3d838324a0aad3e70112e" translate="yes" xml:space="preserve">
          <source>We will be calling the test script through the command &quot;&lt;code&gt;make test&lt;/code&gt;&quot;. You should see output that looks something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6f3f09fa5bfb41f8f72f761c01531e59969f1d" translate="yes" xml:space="preserve">
          <source>We will not provide security updates or bug fixes for development releases of Perl.</source>
          <target state="translated">我们不会为 Perl 的开发版本提供安全更新或错误修复。</target>
        </trans-unit>
        <trans-unit id="788212053c8b040e14cd53eba253eacd9f8cbdce" translate="yes" xml:space="preserve">
          <source>We will now create the main top-level Mytest2 files. Change to the directory above Mytest2 and run the following command:</source>
          <target state="translated">现在我们将创建主要的顶层Mytest2文件。换到Mytest2上面的目录,运行下面的命令。</target>
        </trans-unit>
        <trans-unit id="d22caa360403eba16e21b51e9ea68e688fb5cc28" translate="yes" xml:space="preserve">
          <source>We would all love to unmake some mistakes we've made over the past decades. Living with every design error we've ever made can lead to painful stagnation. Unwinding our mistakes is very, very difficult. Doing so without actively harming our users is nearly impossible.</source>
          <target state="translated">我们都很想解开过去几十年来所犯的一些错误。带着我们曾经犯过的每一个设计错误生活会导致痛苦的停滞。解除我们的错误是非常非常困难的。在不主动伤害我们的用户的情况下,这样做几乎是不可能的。</target>
        </trans-unit>
        <trans-unit id="461ccef8111ec963260713b6b25723c4d738d9a8" translate="yes" xml:space="preserve">
          <source>We'll come back to this city-country problem later, after we've seen some syntax for managing references.</source>
          <target state="translated">在我们看过一些管理引用的语法之后,我们以后再来讨论这个城乡问题。</target>
        </trans-unit>
        <trans-unit id="25d0051932de21aa64fc90927fc210fd1faca62f" translate="yes" xml:space="preserve">
          <source>We'll get to testing the contents of lists later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cbf9f8ec2dcbf019622a935f28d55742617ea78" translate="yes" xml:space="preserve">
          <source>We'll get to the meaning of those Perlish-looking variables in a little bit.</source>
          <target state="translated">我们稍后会了解这些看起来像Perlish的变量的含义。</target>
        </trans-unit>
        <trans-unit id="ccbe83524a5012d45f354f697c95fa9a1eb5367f" translate="yes" xml:space="preserve">
          <source>We'll have another string pointer in there:</source>
          <target state="translated">我们将有另一个字符串指针在那里。</target>
        </trans-unit>
        <trans-unit id="5672edbff82e9ae33e95bbfe34109b2db08b3398" translate="yes" xml:space="preserve">
          <source>We'll look at output first. Supposing we already have this structure, how do we print it out?</source>
          <target state="translated">我们先看输出。假设我们已经有了这个结构,那么我们如何将它打印出来呢?</target>
        </trans-unit>
        <trans-unit id="8801992116fa36a8b481455c1f17fda02ba0a864" translate="yes" xml:space="preserve">
          <source>We'll see a more tricky example of this when we consider Perl's macros below. &lt;code&gt;POPn&lt;/code&gt; gives you the NV (floating point value) of the top SV on the stack: the &lt;code&gt;$x&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos($x)&lt;/a&gt;&lt;/code&gt;. Then we compute the cosine, and push the result back as an NV. The &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;XPUSHn&lt;/code&gt; means that the stack should be extended if necessary - it can't be necessary here, because we know there's room for one more item on the stack, since we've just removed one! The &lt;code&gt;XPUSH*&lt;/code&gt; macros at least guarantee safety.</source>
          <target state="translated">当我们在下面考虑Perl的宏时，我们将看到一个更加棘手的示例。 &lt;code&gt;POPn&lt;/code&gt; 给你堆栈顶部SV的NV（浮点值）：在 &lt;code&gt;$x&lt;/code&gt; 中的 &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos($x)&lt;/a&gt;&lt;/code&gt; 。然后我们计算余弦，并将结果推回为NV。该 &lt;code&gt;X&lt;/code&gt; 在 &lt;code&gt;XPUSHn&lt;/code&gt; 意味着当堆栈应该在必要时延长- ，因为我们知道它没有必要在这里的房间栈上多了一个项目，因为我们刚刚删除了一个！该 &lt;code&gt;XPUSH*&lt;/code&gt; 至少保证安全的宏。</target>
        </trans-unit>
        <trans-unit id="56f64cd868fbb648df894ffa687bba0fcd06f58c" translate="yes" xml:space="preserve">
          <source>We'll see a more tricky example of this when we consider Perl's macros below. &lt;code&gt;POPn&lt;/code&gt; gives you the NV (floating point value) of the top SV on the stack: the &lt;code&gt;$x&lt;/code&gt; in &lt;code&gt;cos($x)&lt;/code&gt;. Then we compute the cosine, and push the result back as an NV. The &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;XPUSHn&lt;/code&gt; means that the stack should be extended if necessary - it can't be necessary here, because we know there's room for one more item on the stack, since we've just removed one! The &lt;code&gt;XPUSH*&lt;/code&gt; macros at least guarantee safety.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55bbd57ee31a3c27c5821f6c991f3bb8fbebc65" translate="yes" xml:space="preserve">
          <source>We'll simply continue down to our pre-set breakpoint with a '&lt;b&gt;c&lt;/b&gt;':</source>
          <target state="translated">我们将简单地继续使用' &lt;b&gt;c&lt;/b&gt; ' 到我们的预设断点：</target>
        </trans-unit>
        <trans-unit id="a9a2d405fbc50682e1a3c2bf95879ebe85538d93" translate="yes" xml:space="preserve">
          <source>We'll use &lt;code&gt;gdb&lt;/code&gt; for our examples here; the principles will apply to any debugger (many vendors call their debugger &lt;code&gt;dbx&lt;/code&gt; ), but check the manual of the one you're using.</source>
          <target state="translated">在这里，我们将使用 &lt;code&gt;gdb&lt;/code&gt; 作为示例；该原则将适用于任何调试器（许多供应商称其调试器为 &lt;code&gt;dbx&lt;/code&gt; ），但请查看所用调试器的手册。</target>
        </trans-unit>
        <trans-unit id="59bfed3e1550313113be0311ae2b9d42ec0cb5e3" translate="yes" xml:space="preserve">
          <source>We'll use &lt;code&gt;gdb&lt;/code&gt; for our examples here; the principles will apply to any debugger (many vendors call their debugger &lt;code&gt;dbx&lt;/code&gt;), but check the manual of the one you're using.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd00180725dcce313c6ef1b86501c9848503c2c0" translate="yes" xml:space="preserve">
          <source>We'll use Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">我们将使用Jarkko Hietaniemi &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f54f2656a6244346ba143809ce965c3e152258c1" translate="yes" xml:space="preserve">
          <source>We're Netware in addition to being Windows.</source>
          <target state="translated">我们除了是Windows之外,还是网件。</target>
        </trans-unit>
        <trans-unit id="89a6bcd8665abf52d39396f9fea984b5d7d01f5f" translate="yes" xml:space="preserve">
          <source>We're Unix and Cygwin.</source>
          <target state="translated">我们是Unix和Cygwin。</target>
        </trans-unit>
        <trans-unit id="bae7bf51fd64828a801e9cd04e2c5e1eac38f446" translate="yes" xml:space="preserve">
          <source>We're going to add two more items onto the argument stack: when you have a tied array, the &lt;code&gt;PUSH&lt;/code&gt; subroutine receives the object and the value to be pushed, and that's exactly what we have here - the tied object, retrieved with &lt;code&gt;SvTIED_obj&lt;/code&gt; , and the value, the SV &lt;code&gt;val&lt;/code&gt; .</source>
          <target state="translated">我们将在参数堆栈上再添加两个项目：当您有一个绑定数组时， &lt;code&gt;PUSH&lt;/code&gt; 子例程会接收对象和要推送的值，而这正是我们在这里-绑定对象，使用 &lt;code&gt;SvTIED_obj&lt;/code&gt; 检索，和值SV &lt;code&gt;val&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c85ee9a622e2cfbf55a87677c4c0c5ab7baea463" translate="yes" xml:space="preserve">
          <source>We're going to add two more items onto the argument stack: when you have a tied array, the &lt;code&gt;PUSH&lt;/code&gt; subroutine receives the object and the value to be pushed, and that's exactly what we have here - the tied object, retrieved with &lt;code&gt;SvTIED_obj&lt;/code&gt;, and the value, the SV &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81984db06bb6ffc7cc8657839e60eed19d2e59d4" translate="yes" xml:space="preserve">
          <source>We're going to be wanting to test a lot of dates here, trying to trick the code with lots of different edge cases. Does it work before 1970? After 2038? Before 1904? Do years after 10,000 give it trouble? Does it get leap years right? We could keep repeating the code above, or we could set up a little try/expect loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982b2dd7e00a50956cc41a996392e78491465b29" translate="yes" xml:space="preserve">
          <source>We're going to primarily concentrate on Perl-only modules here, rather than XS modules. XS modules serve a rather different purpose, and you should consider different things before distributing them - the popularity of the library you are gluing, the portability to other operating systems, and so on. However, the notes on preparing the Perl side of the module and packaging and distributing it will apply equally well to an XS module as a pure-Perl one.</source>
          <target state="translated">我们在这里主要集中在Perl专用模块上,而不是XS模块。XS模块的作用相当不同,你在发布它们之前应该考虑不同的事情--你所粘连的库的受欢迎程度,对其他操作系统的可移植性等等。然而,关于准备模块的Perl方面以及打包和发布的注意事项同样适用于XS模块和纯Perl模块。</target>
        </trans-unit>
        <trans-unit id="017f7465d1bdb163c7a89743859d67e419fc8784" translate="yes" xml:space="preserve">
          <source>We've added more detail about what we're testing and the ICal string itself we're trying out to the name. So you get results like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34118bf3962978ee960cb834c23b6a7907e48ac6" translate="yes" xml:space="preserve">
          <source>We've already seen how to print to standard output using &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; can also take an optional first argument specifying which filehandle to print to:</source>
          <target state="translated">我们已经看到了如何使用 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 打印到标准输出。但是， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 也可以使用可选的第一个参数，以指定要打印到的文件句柄：</target>
        </trans-unit>
        <trans-unit id="a86cb468eaa36ca78f91ded52784d1ac7c3b8af3" translate="yes" xml:space="preserve">
          <source>We've already seen how to print to standard output using &lt;code&gt;print()&lt;/code&gt;. However, &lt;code&gt;print()&lt;/code&gt; can also take an optional first argument specifying which filehandle to print to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a8063bdaca09993ddd8d252b857fa09a430a49" translate="yes" xml:space="preserve">
          <source>We've also told Perl about the library that we built in the mylib subdirectory. That required only the addition of the &lt;code&gt;MYEXTLIB&lt;/code&gt; variable to the WriteMakefile call and the replacement of the postamble subroutine to cd into the subdirectory and run make. The Makefile.PL for the library is a bit more complicated, but not excessively so. Again we replaced the postamble subroutine to insert our own code. This code simply specified that the library to be created here was a static archive library (as opposed to a dynamically loadable library) and provided the commands to build it.</source>
          <target state="translated">我们还告诉了Perl我们在mylib子目录中构建的库。只需向WriteMakefile调用中添加 &lt;code&gt;MYEXTLIB&lt;/code&gt; 变量，并替换postamble子例程即可将cd插入子目录并运行make。该库的Makefile.PL有点复杂，但并不过分。再次，我们替换了postamble子例程以插入我们自己的代码。该代码仅指定要在此处创建的库是静态存档库（与可动态加载的库相对），并提供了构建它的命令。</target>
        </trans-unit>
        <trans-unit id="6afd998315c2c6324bb813d112e9a8f30bf0d582" translate="yes" xml:space="preserve">
          <source>We've covered the workhorse parts of Perl's threading package, and with these tools you should be well on your way to writing threaded code and packages. There are a few useful little pieces that didn't really fit in anyplace else.</source>
          <target state="translated">我们已经介绍了Perl的线程包的主要部分,有了这些工具,你应该可以很好地编写线程代码和包。有一些有用的小部件并没有放在其他任何地方。</target>
        </trans-unit>
        <trans-unit id="b4d69ed91d0829df5cfa125f68b479f5de86f05f" translate="yes" xml:space="preserve">
          <source>We've gone past our check (where 'All OK' was printed) and have stopped just before the meat of our task. We could try to print out a couple of variables to see what is happening:</source>
          <target state="translated">我们已经通过了检查(打印了 &quot;All OK&quot;),在任务的实质之前停了下来。我们可以试着打印出几个变量来看看发生了什么。</target>
        </trans-unit>
        <trans-unit id="33a66a35950ff295dc8b9c6a23c44bcace53edc3" translate="yes" xml:space="preserve">
          <source>We've had Larry's h2ph translator, which helped, but that only works on cpp symbols, not real C, which was also very much needed. What I offer you is a symbolic way of getting at all the C structures. I've couched them in terms of packages and functions. Consider the following program:</source>
          <target state="translated">我们已经有了Larry的h2ph翻译器,这很有帮助,但那只对cpp符号有效,而不是真正的C,这也是非常需要的。我提供给你的是一种符号化的方式来获取所有的C结构。我把它们用包和函数来表述。考虑以下程序。</target>
        </trans-unit>
        <trans-unit id="f3af9852bf7e4f70a4af9b26111fb8e3956f866b" translate="yes" xml:space="preserve">
          <source>We've made some changes to Makefile.PL. In this case, we've specified an extra library to be linked into the extension's shared library, the math library libm in this case. We'll talk later about how to write XSUBs that can call every routine in a library.</source>
          <target state="translated">我们对Makefile.PL做了一些修改。在这种情况下,我们指定了一个额外的库来链接到扩展的共享库中,本例中的数学库libm。我们稍后将讨论如何编写XSUB,可以调用库中的每个例程。</target>
        </trans-unit>
        <trans-unit id="a904b7cf0e87b370c484aeda4a3fd7921273c345" translate="yes" xml:space="preserve">
          <source>We've seen how to encourage good coding practices with &lt;b&gt;use strict&lt;/b&gt; and &lt;b&gt;-w&lt;/b&gt;. We can run the perl debugger &lt;b&gt;perl -d scriptname&lt;/b&gt; to inspect your data from within the perl debugger with the &lt;b&gt;p&lt;/b&gt; and &lt;b&gt;x&lt;/b&gt; commands. You can walk through your code, set breakpoints with &lt;b&gt;b&lt;/b&gt; and step through that code with &lt;b&gt;s&lt;/b&gt; or &lt;b&gt;n&lt;/b&gt;, continue with &lt;b&gt;c&lt;/b&gt; and return from a sub with &lt;b&gt;r&lt;/b&gt;. Fairly intuitive stuff when you get down to it.</source>
          <target state="translated">我们已经看到了如何通过&lt;b&gt;使用strict&lt;/b&gt;和&lt;b&gt;-w&lt;/b&gt;鼓励良好的编码实践。我们可以运行perl调试器&lt;b&gt;perl -d脚本名&lt;/b&gt;，使用&lt;b&gt;p&lt;/b&gt;和&lt;b&gt;x&lt;/b&gt;命令从perl调试器中检查您的数据。您可以遍历代码，使用&lt;b&gt;b&lt;/b&gt;设置断点，并使用&lt;b&gt;s&lt;/b&gt;或&lt;b&gt;n&lt;/b&gt;逐步执行该代码，使用&lt;b&gt;c&lt;/b&gt;继续并使用&lt;b&gt;r&lt;/b&gt;从子返回。当您开始学习时，它会非常直观。</target>
        </trans-unit>
        <trans-unit id="9f4aba3ac8d090b513bcacbad039797adbe73abe" translate="yes" xml:space="preserve">
          <source>We've taken some pains to construct the template so that it matches the contents of our frame buffer. Otherwise we'd either get undefined values, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; could not unpack all. If &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; runs out of items, it will supply null strings (which are coerced into zeroes whenever the pack code says so).</source>
          <target state="translated">我们花了一些心思来构造模板，以使其与我们的帧缓冲区的内容匹配。否则，我们要么得到未定义的值，要么 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 无法解包全部。如果 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 中的项目用完了，它将提供null字符串（每当pack代码这样说时，它们就会强制为零）。</target>
        </trans-unit>
        <trans-unit id="f58946de758298d15363eecb7f69802745a7c62d" translate="yes" xml:space="preserve">
          <source>We've taken some pains to construct the template so that it matches the contents of our frame buffer. Otherwise we'd either get undefined values, or &lt;code&gt;unpack&lt;/code&gt; could not unpack all. If &lt;code&gt;pack&lt;/code&gt; runs out of items, it will supply null strings (which are coerced into zeroes whenever the pack code says so).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fc93f698eef77381e152ba1261b27e22014722" translate="yes" xml:space="preserve">
          <source>We've tried to make this also work with the TODO: syntax, but it's not guaranteed and its use is also discouraged:</source>
          <target state="translated">我们试图让这个也能使用TODO:语法,但这不能保证,也不鼓励使用它。</target>
        </trans-unit>
        <trans-unit id="d057d23b834db4b8d50936a9c8b48cc9bb56ac94" translate="yes" xml:space="preserve">
          <source>We've tried to minimize the dependence of Perl library modules on Unix syntax, but you may find that some of these, as well as some scripts written for Unix systems, will require that you use Unix syntax, since they will assume that '/' is the directory separator,</source>
          <target state="translated">我们已经尽量减少Perl库模块对Unix语法的依赖性,但是你可能会发现其中的一些模块,以及一些为Unix系统编写的脚本,会要求你使用Unix语法,因为它们会假定'/'是目录分隔符。</target>
        </trans-unit>
        <trans-unit id="f63c6786d8c83343c69f80cf76418c3681700514" translate="yes" xml:space="preserve">
          <source>We've used a hash slice in order to easily handle the fields of each row. Storing the keys in an array makes it easy to operate on them as a group or loop over them with &lt;code&gt;for&lt;/code&gt; . It also avoids polluting the program with global variables and using symbolic references.</source>
          <target state="translated">为了方便处理每一行的字段，我们使用了哈希切片。将键存储在数组中可以轻松地对它们进行分组操作或使用 &lt;code&gt;for&lt;/code&gt; 对其进行循环。它还避免了使用全局变量和使用符号引用来污染程序。</target>
        </trans-unit>
        <trans-unit id="bf3e9bec5bbd0148b6e7d79050e64cd6c33fa0da" translate="yes" xml:space="preserve">
          <source>We've used a hash slice in order to easily handle the fields of each row. Storing the keys in an array makes it easy to operate on them as a group or loop over them with &lt;code&gt;for&lt;/code&gt;. It also avoids polluting the program with global variables and using symbolic references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3244b33262d5fd2e0388c2e8910db847842e8800" translate="yes" xml:space="preserve">
          <source>Weak references are not implemented in the version of perl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e147d82cb4cdd9e073d031a1a26cd0222dd868d0" translate="yes" xml:space="preserve">
          <source>Weaken a reference: set the &lt;code&gt;SvWEAKREF&lt;/code&gt; flag on this RV; give the referred-to SV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; magic if it hasn't already; and push a back-reference to this RV onto the array of backreferences associated with that magic. If the RV is magical, set magic will be called after the RV is cleared.</source>
          <target state="translated">&lt;code&gt;SvWEAKREF&lt;/code&gt; 引用：在此RV上设置SvWEAKREF标志；如果尚未提供，请给所引用的SV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; 魔术；并将此RV的反向引用推到与该魔术关联的反向引用数组中。如果RV具有魔力，则清除RV后将召唤设定魔法。</target>
        </trans-unit>
        <trans-unit id="1b546f1ca2e1f3276683dab2157d9406b01bfa5c" translate="yes" xml:space="preserve">
          <source>Weaken a reference: set the &lt;code&gt;SvWEAKREF&lt;/code&gt; flag on this RV; give the referred-to SV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; magic if it hasn't already; and push a back-reference to this RV onto the array of backreferences associated with that magic. If the RV is magical, set magic will be called after the RV is cleared. Silently ignores &lt;code&gt;undef&lt;/code&gt; and warns on already-weak references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4b4063ed2668451305a4ea955df5abd08928f3" translate="yes" xml:space="preserve">
          <source>Weakrefs call uvar magic</source>
          <target state="translated">弱参考调用uvar magic</target>
        </trans-unit>
        <trans-unit id="d99719368087fdb5886c0da04e1ec7aa5bb1e097" translate="yes" xml:space="preserve">
          <source>Web::Simple</source>
          <target state="translated">Web::Simple</target>
        </trans-unit>
        <trans-unit id="a87a48da60ac110880ba420c176bfa3b966a1bbc" translate="yes" xml:space="preserve">
          <source>Websites</source>
          <target state="translated">Websites</target>
        </trans-unit>
        <trans-unit id="c46c01995b645fa6ced7ccd3bd695a2325cf2829" translate="yes" xml:space="preserve">
          <source>Weed out arguments that are not supported and warn about them to the user</source>
          <target state="translated">剔除不支持的论点,并向用户发出警告。</target>
        </trans-unit>
        <trans-unit id="5ff64b425852808bfa9bcc07404d47fe62f5255b" translate="yes" xml:space="preserve">
          <source>Week Number</source>
          <target state="translated">周数</target>
        </trans-unit>
        <trans-unit id="e47cfca7176dccc849b8b9085335ec9965e39788" translate="yes" xml:space="preserve">
          <source>Weighting CJK Unified Ideographs</source>
          <target state="translated">中日韩统一表意文字的权重</target>
        </trans-unit>
        <trans-unit id="6b33b573e9b7a7f05800470ad22d2691de1ad1d8" translate="yes" xml:space="preserve">
          <source>Weighting JIS KANJI for Unicode::Collate</source>
          <target state="translated">为Unicode::Collate加权JIS KANJI。</target>
        </trans-unit>
        <trans-unit id="b6757ec0e4d4ce4eae1496f199fc7aa0d085efea" translate="yes" xml:space="preserve">
          <source>Weighting may vary depending on collation element table. So ensure the weights defined in &lt;code&gt;entry&lt;/code&gt; will be consistent with those in the collation element table loaded via &lt;code&gt;table&lt;/code&gt; .</source>
          <target state="translated">权重可能因归类元素表而异。因此，请确保 &lt;code&gt;entry&lt;/code&gt; 定义的权重与通过 &lt;code&gt;table&lt;/code&gt; 加载的归类元素表中的权重保持一致。</target>
        </trans-unit>
        <trans-unit id="782d47b6879e710497644ef8bf508107805123e1" translate="yes" xml:space="preserve">
          <source>Weighting may vary depending on collation element table. So ensure the weights defined in &lt;code&gt;entry&lt;/code&gt; will be consistent with those in the collation element table loaded via &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6bdfd154d71780792f4f6d415a46881c01b84f" translate="yes" xml:space="preserve">
          <source>Weights in reverse order; ex. level 2 (diacritic ordering) in French. If omitted (or &lt;code&gt;$levelNumber&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;\@levelNumbers&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt; ), forwards at all the levels.</source>
          <target state="translated">权重相反；例如 法语2级（变音符号顺序）。如果省略（或 &lt;code&gt;$levelNumber&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;\@levelNumbers&lt;/code&gt; 为 &lt;code&gt;[]&lt;/code&gt; ），则在所有级别转发。</target>
        </trans-unit>
        <trans-unit id="07918c7bf0f5c02def4accb22b2496ee08472e26" translate="yes" xml:space="preserve">
          <source>Weights in reverse order; ex. level 2 (diacritic ordering) in French. If omitted (or &lt;code&gt;$levelNumber&lt;/code&gt; is &lt;code&gt;undef&lt;/code&gt; or &lt;code&gt;\@levelNumbers&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;), forwards at all the levels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cfee8775f2eb957a8724a08c2efd8dbdd2166cc" translate="yes" xml:space="preserve">
          <source>Well it may seem that way, but it does not. The verify method returns true if the command succeeded. If you pass verify an address which the server would normally have to forward to another machine, the command will succeed with something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ade9c702a20a6384a7a0b9552d289287a18c722" translate="yes" xml:space="preserve">
          <source>Well, apart from a bare &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; $fh&lt;/code&gt; , you shouldn't treat them specially. (The binmode is needed because otherwise Perl may convert line endings on Win32 systems.)</source>
          <target state="translated">好吧，除了简单的 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; $fh&lt;/code&gt; ，您不应该特别对待它们。（bin模式是必需的，因为否则Perl可能会在Win32系统上转换行尾。）</target>
        </trans-unit>
        <trans-unit id="48bbf4d297e0c1ca5f48035948fb4a98aa2511d6" translate="yes" xml:space="preserve">
          <source>Well, apart from a bare &lt;code&gt;binmode $fh&lt;/code&gt;, you shouldn't treat them specially. (The binmode is needed because otherwise Perl may convert line endings on Win32 systems.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504ec4c7237da89364f87b2aad3291cf833f70a8" translate="yes" xml:space="preserve">
          <source>Well, having several executables dynamically linked to the same huge library has its advantages, but this would not substantiate the additional work to make it compile. The reason is the complicated-to-developers but very quick and convenient-to-users &quot;hard&quot; dynamic linking used by OS/2.</source>
          <target state="translated">好吧,让几个可执行文件动态链接到同一个庞大的库中有它的优势,但这并不能证明要为编译而进行额外的工作。原因是OS/2使用的 &quot;硬 &quot;动态链接对开发者来说很复杂,但对用户来说却非常快速和方便。</target>
        </trans-unit>
        <trans-unit id="b4bf2ee14e4e81fc05f1087aeed820b042b0028b" translate="yes" xml:space="preserve">
          <source>Well, if you can, upgrade to the most recent, but certainly &lt;code&gt;5.8.1&lt;/code&gt; or newer. The tutorial and FAQ assume the latest release.</source>
          <target state="translated">好吧，如果可以的话，升级到最新的版本，但肯定是 &lt;code&gt;5.8.1&lt;/code&gt; 或更高版本。本教程和FAQ假定为最新版本。</target>
        </trans-unit>
        <trans-unit id="c922bdb3f23d6c5306883fe0bee806df01fe877f" translate="yes" xml:space="preserve">
          <source>Well, maybe not. Anyway, each op contains a function pointer, which stipulates the function which will actually carry out the operation. This function will return the next op in the sequence - this allows for things like &lt;code&gt;if&lt;/code&gt; which choose the next op dynamically at run time. The &lt;code&gt;PERL_ASYNC_CHECK&lt;/code&gt; makes sure that things like signals interrupt execution if required.</source>
          <target state="translated">好吧，也许不是。无论如何，每个操作都包含一个函数指针，该指针规定了将实际执行该操作的函数。该函数将返回下一个运算序列中-这使得喜欢的事情 &lt;code&gt;if&lt;/code&gt; 动态地选择下一个运算的运行时间。该 &lt;code&gt;PERL_ASYNC_CHECK&lt;/code&gt; 可以确保在需要的东西像信号中断执行。</target>
        </trans-unit>
        <trans-unit id="d89d9b138049ae3cace1b14aa62a037a00f5fd6b" translate="yes" xml:space="preserve">
          <source>Well, nowadays Perl DLL should be usable from a differently compiled program too... If you can run Perl code from REXX scripts (see &lt;a href=&quot;OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;), then there are some other aspect of interaction which are overlooked by the current hackish code to support differently-compiled principal programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb7d8a35468fea02bd934ea87237f211894a5751" translate="yes" xml:space="preserve">
          <source>Well, nowadays Perl DLL should be usable from a differently compiled program too... If you can run Perl code from REXX scripts (see &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;), then there are some other aspect of interaction which are overlooked by the current hackish code to support differently-compiled principal programs.</source>
          <target state="translated">好吧，如今，Perl DLL也应该可以从不同编译的程序中使用...如果您可以从REXX脚本中运行Perl代码（请参阅&lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2 :: REXX&lt;/a&gt;），那么当前的黑名单代码会忽略交互的其他方面支持不同编译的主体程序。</target>
        </trans-unit>
        <trans-unit id="61cb10844d83ee77c0e38f0deaf6e76838a94cbb" translate="yes" xml:space="preserve">
          <source>Well, okay, not entirely like C's arrays, actually. C doesn't know how to grow its arrays on demand. Perl does.</source>
          <target state="translated">好吧,好吧,其实不完全像C的数组。C不知道如何按需增长其数组。Perl知道。</target>
        </trans-unit>
        <trans-unit id="c4f3fa326a3af64f93426bcdac847f46a94f9b1b" translate="yes" xml:space="preserve">
          <source>Well, that's</source>
          <target state="translated">嗯,那是</target>
        </trans-unit>
        <trans-unit id="bf3871275db74807de50e10189deb9ba1201d5b4" translate="yes" xml:space="preserve">
          <source>Well, that's all fine if you want to send one command and get one answer, but what about setting up something fully interactive, somewhat like the way</source>
          <target state="translated">好吧,如果你想发送一个命令并得到一个答案,这一切都很好,但是设置一些完全互动的东西,有点像</target>
        </trans-unit>
        <trans-unit id="a4fcece5fae45fd55beac8d83dea4ffc7bb1546c" translate="yes" xml:space="preserve">
          <source>Well, that's because the rule is that on adjacent brackets only (whether square or curly), you are free to omit the pointer dereferencing arrow. But you cannot do so for the very first one if it's a scalar containing a reference, which means that $ref_to_AoA always needs it.</source>
          <target state="translated">好吧,那是因为规则是只在相邻的括号上(不管是方括号还是卷括号),你可以自由地省略指针去参考箭头。但是如果是一个包含引用的标量,你就不能对第一个标量这样做,这意味着$ref_to_AoA总是需要它。</target>
        </trans-unit>
        <trans-unit id="5937ea9ee293b2d54cd64fb9f3a778625f679e1c" translate="yes" xml:space="preserve">
          <source>Well, this isn't very easy to read, and using the helpful manual (&lt;b&gt;h h&lt;/b&gt;), the '&lt;b&gt;x&lt;/b&gt;' command looks promising:</source>
          <target state="translated">好吧，这不是很容易阅读，使用有用的手册（&lt;b&gt;hh&lt;/b&gt;），' &lt;b&gt;x&lt;/b&gt; '命令看起来很有希望：</target>
        </trans-unit>
        <trans-unit id="81775bcb15e4091e227d731dfdef1462a2bf3f2b" translate="yes" xml:space="preserve">
          <source>Well, you could keep them in sync, but there's no guarantee it will always hold on classes somebody else wrote. Besides, there is little to gain in doing so: a serializing hook could keep only one attribute of an object, which is probably not what should happen during a deep cloning of that same object.</source>
          <target state="translated">好吧,你可以让它们保持同步,但并不能保证它永远保持在别人写的类上。此外,这样做也没有什么好处:一个序列化钩子只能保持一个对象的一个属性,这可能不是同一个对象的深度克隆过程中应该发生的事情。</target>
        </trans-unit>
        <trans-unit id="97211a8888128314d9ca34d1005f08cb83ed5d9c" translate="yes" xml:space="preserve">
          <source>What</source>
          <target state="translated">What</target>
        </trans-unit>
        <trans-unit id="c6c58c114eba15fa1fde6b56057cb927734327d9" translate="yes" xml:space="preserve">
          <source>What *is* Unicode, anyway?</source>
          <target state="translated">统一码到底是什么?</target>
        </trans-unit>
        <trans-unit id="2948ac1effa2d43a9756f45e31fc4dfaf54b428e" translate="yes" xml:space="preserve">
          <source>What &lt;b&gt;is&lt;/b&gt; Unicode, anyway?</source>
          <target state="translated">Unicode &lt;b&gt;是&lt;/b&gt;什么？</target>
        </trans-unit>
        <trans-unit id="0c27997670ea19d058363ea936f9c5a132d90646" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; does</source>
          <target state="translated">什么 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 呢</target>
        </trans-unit>
        <trans-unit id="828c569308e99c356a11f905449002a24faaf00f" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\n&lt;/code&gt; represents depends on the type of file opened. It usually represents &lt;code&gt;\012&lt;/code&gt; but it could also be &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , &lt;code&gt;\015\012&lt;/code&gt; , &lt;code&gt;\000&lt;/code&gt; , &lt;code&gt;\040&lt;/code&gt; , or nothing depending on the file organization and record format. The &lt;code&gt;VMS::Stdio&lt;/code&gt; module provides access to the special &lt;code&gt;fopen()&lt;/code&gt; requirements of files with unusual attributes on VMS.</source>
          <target state="translated">&lt;code&gt;\n&lt;/code&gt; 代表什么取决于打开的文件类型。它通常表示 &lt;code&gt;\012&lt;/code&gt; 但也可以是 &lt;code&gt;\015&lt;/code&gt; ， &lt;code&gt;\012&lt;/code&gt; ， &lt;code&gt;\015\012&lt;/code&gt; ， &lt;code&gt;\000&lt;/code&gt; ， &lt;code&gt;\040&lt;/code&gt; 或什么都不是，这取决于文件的组织和记录格式。该 &lt;code&gt;VMS::Stdio&lt;/code&gt; 模块提供特殊的 &lt;code&gt;fopen()&lt;/code&gt; 函数与VMS不寻常的属性的文件的要求。</target>
        </trans-unit>
        <trans-unit id="87fe5c683c90e3c088c772e3615a1786c72c1f86" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\n&lt;/code&gt; represents depends on the type of file opened. It usually represents &lt;code&gt;\012&lt;/code&gt; but it could also be &lt;code&gt;\015&lt;/code&gt;, &lt;code&gt;\012&lt;/code&gt;, &lt;code&gt;\015\012&lt;/code&gt;, &lt;code&gt;\000&lt;/code&gt;, &lt;code&gt;\040&lt;/code&gt;, or nothing depending on the file organization and record format. The &lt;a href=&quot;VMS::Stdio&quot;&gt;&lt;code&gt;VMS::Stdio&lt;/code&gt;&lt;/a&gt; module provides access to the special &lt;code&gt;fopen()&lt;/code&gt; requirements of files with unusual attributes on VMS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcc1cc41a80c328b4eb792743f378eba1c9a93d1" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\p{Digit}&lt;/code&gt; means (and hence &lt;code&gt;\d&lt;/code&gt; except under the &lt;code&gt;/a&lt;/code&gt; modifier) is &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt; , or synonymously, &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt; . Starting with Unicode version 4.1, this is the same set of characters matched by &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt; . But Unicode also has a different property with a similar name, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; , which matches a completely different set of characters. These characters are things such as &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; or subscripts, or are from writing systems that lack all ten digits.</source>
          <target state="translated">什么 &lt;code&gt;\p{Digit}&lt;/code&gt; 的装置（并且因此 &lt;code&gt;\d&lt;/code&gt; 除下 &lt;code&gt;/a&lt;/code&gt; 改性剂）是 &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt; ，或同义地， &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt; 。从Unicode版本4.1开始，这是 &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt; 匹配的相同字符集。但是Unicode也具有另一个具有类似名称 &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; 属性，该属性与完全不同的字符集匹配。这些字符是诸如&amp;ldquo; &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; &amp;rdquo;或下标之类的字符，或者来自缺少所有十位数字的书写系统。</target>
        </trans-unit>
        <trans-unit id="7b5cbb478fdd2453286ebc21496037447f26240f" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\p{Digit}&lt;/code&gt; means (and hence &lt;code&gt;\d&lt;/code&gt; except under the &lt;code&gt;/a&lt;/code&gt; modifier) is &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt;, or synonymously, &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt;. Starting with Unicode version 4.1, this is the same set of characters matched by &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt;. But Unicode also has a different property with a similar name, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt;, which matches a completely different set of characters. These characters are things such as &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; or subscripts, or are from writing systems that lack all ten digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b14251f22912eca5254f7b79c2a9d632504f9a" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;import&lt;/code&gt; does</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23d8154ba31035b162983151d8a78e2e2dc45b35" translate="yes" xml:space="preserve">
          <source>What Compression Types do IO::Compress::Zip &amp;amp; IO::Uncompress::Unzip support?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e45028df29a344ed3d5dcfe47d49eff1e4e5b3d" translate="yes" xml:space="preserve">
          <source>What Is A Thread Anyway?</source>
          <target state="translated">到底什么是线?</target>
        </trans-unit>
        <trans-unit id="9f3aa83a51cae6aa5da8eadacc3922153fc22ffe" translate="yes" xml:space="preserve">
          <source>What Not to Export</source>
          <target state="translated">不要出口什么</target>
        </trans-unit>
        <trans-unit id="bcf1ef3ecb402df133384ad31b9f0ab2cd6f6d09" translate="yes" xml:space="preserve">
          <source>What Thread Am I In?</source>
          <target state="translated">我在哪条线上?</target>
        </trans-unit>
        <trans-unit id="bdf11c2c3fa2430fc36aec96902da89a7d6631c6" translate="yes" xml:space="preserve">
          <source>What Threads Are Running?</source>
          <target state="translated">什么线程在运行?</target>
        </trans-unit>
        <trans-unit id="39c91a7f2718b3f82718fcf2f41024f714a5a84f" translate="yes" xml:space="preserve">
          <source>What Unix would call a &quot;character special file&quot;, that is, a device that works on character streams such as a printer port or a console.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4628ec6a65c6ef207e94ed239509a432eb2d40b1" translate="yes" xml:space="preserve">
          <source>What You See Is What You Get. Usually used when something that appears on the screen matches how it will eventually look, like Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; declarations. Also used to mean the opposite of magic because everything works exactly as it appears, as in the three- argument form of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">你所看到的就是你得到的。通常在屏幕上出现的内容与最终外观匹配时使用，例如Perl的 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 声明。也用来表示魔术的反义词，因为一切都按其看起来完全一样地工作，如 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 的三参数形式。</target>
        </trans-unit>
        <trans-unit id="ed80ac1751c25893f1267129f7e46c8160dfe9c8" translate="yes" xml:space="preserve">
          <source>What You See Is What You Get. Usually used when something that appears on the screen matches how it will eventually look, like Perl&amp;rsquo;s &lt;code&gt;format&lt;/code&gt; declarations. Also used to mean the opposite of magic because everything works exactly as it appears, as in the three- argument form of &lt;code&gt;open&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71fba121999cf66c38da9b22673582805a4f1ef9" translate="yes" xml:space="preserve">
          <source>What a &lt;b&gt;process&lt;/b&gt; does when it has to wait for something: &amp;ldquo;My process blocked waiting for the disk.&amp;rdquo; As an unrelated noun, it refers to a large chunk of data, of a size that the &lt;b&gt;operating system&lt;/b&gt; likes to deal with (normally a power of 2 such as 512 or 8192). Typically refers to a chunk of data that&amp;rsquo;s coming from or going to a disk file.</source>
          <target state="translated">什么&lt;b&gt;过程&lt;/b&gt;呢，当它必须等待的东西：&amp;ldquo;我的进程阻塞等待磁盘&amp;rdquo;。作为不相关的名词，它指的是大数据块，其大小是&lt;b&gt;操作系统&lt;/b&gt;喜欢处理的大小（通常为2的幂，例如512或8192）。通常指的是来自磁盘文件或进入磁盘文件的数据块。</target>
        </trans-unit>
        <trans-unit id="2467e6e88d448cacf4a87d364e42c63b7d44c7b4" translate="yes" xml:space="preserve">
          <source>What a Unicode property matches is never subject to locale rules, and if locale rules are not otherwise in effect, the use of a Unicode property will force the regular expression into using Unicode rules, if it isn't already.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0f239768e941abba33a14d0c879853b4c42602" translate="yes" xml:space="preserve">
          <source>What about &lt;code&gt;pp_add&lt;/code&gt; , the function we examined earlier to implement the &lt;code&gt;+&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;pp_add&lt;/code&gt; 是什么，我们之前检查过的用于实现 &lt;code&gt;+&lt;/code&gt; 运算符的函数：</target>
        </trans-unit>
        <trans-unit id="4f1dc37cecc054d5c9ec7a5642d37fabf7ece164" translate="yes" xml:space="preserve">
          <source>What about &lt;code&gt;pp_add&lt;/code&gt;, the function we examined earlier to implement the &lt;code&gt;+&lt;/code&gt; operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06b49d955a9223ccdbf114f85c4f46fdc429b37" translate="yes" xml:space="preserve">
          <source>What about binary data, like images?</source>
          <target state="translated">那二进制数据呢,比如图像?</target>
        </trans-unit>
        <trans-unit id="904b144e4b71718e8b3ada176614f796ad653d66" translate="yes" xml:space="preserve">
          <source>What about read-write mode? You should probably pretend it doesn't exist, because opening text files in read-write mode is unlikely to do what you would like. See &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; for details.</source>
          <target state="translated">那读写模式呢？您可能应该假装它不存在，因为以读写模式打开文本文件不太可能做您想要的事情。有关详细信息，请参见&lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a98ea247bf23a0f2706e40c287b52d50377a4b2f" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 的用法如何？</target>
        </trans-unit>
        <trans-unit id="b08e1e06d029706420aa4cf6848aa2370810866c" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; pragma?</source>
          <target state="translated">怎么样 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; 编译？</target>
        </trans-unit>
        <trans-unit id="7033c56c28fec8ae85e45a62981e3d9e75105d87" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;use bytes&lt;/code&gt; pragma?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1190a2bf44048aa0cb955f799592720f84eed32" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;use encoding&lt;/code&gt; pragma?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3887d9c889fae85aa71ceab4eb1a53b1a8af8aa5" translate="yes" xml:space="preserve">
          <source>What about the use bytes pragma?</source>
          <target state="translated">那使用字节的pragma呢?</target>
        </trans-unit>
        <trans-unit id="77d5d80251afa9ef6da60c5e5fbcd215435339d8" translate="yes" xml:space="preserve">
          <source>What about the use encoding pragma?</source>
          <target state="translated">那使用编码原则呢?</target>
        </trans-unit>
        <trans-unit id="9087ece8c32ed3f277ff1480139f31375b459572" translate="yes" xml:space="preserve">
          <source>What about v-strings?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20f362258fa45c702309bd2513e61621aa1951d0" translate="yes" xml:space="preserve">
          <source>What are &lt;code&gt;decode_utf8&lt;/code&gt; and &lt;code&gt;encode_utf8&lt;/code&gt; ?</source>
          <target state="translated">什么是 &lt;code&gt;decode_utf8&lt;/code&gt; 和 &lt;code&gt;encode_utf8&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="eb35e14132d10d4b0ffea38066499e7c90c13f72" translate="yes" xml:space="preserve">
          <source>What are &lt;code&gt;decode_utf8&lt;/code&gt; and &lt;code&gt;encode_utf8&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cae90cb4f341d083e0d8337510fe30e0b15640" translate="yes" xml:space="preserve">
          <source>What are Perl 4, Perl 5, or Perl 6?</source>
          <target state="translated">什么是Perl 4、Perl 5或Perl 6?</target>
        </trans-unit>
        <trans-unit id="e6127384bd4c0a0328dc9c0ebe31629d55231702" translate="yes" xml:space="preserve">
          <source>What are Perl 4, Perl 5, or Raku (Perl 6)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01965e32414f80a123a1d37d107d508fa4c75578" translate="yes" xml:space="preserve">
          <source>What are all these $@%&amp;amp;* punctuation signs, and how do I know when to use them?</source>
          <target state="translated">这些$ @％＆*标点符号都是什么，我怎么知道何时使用它们？</target>
        </trans-unit>
        <trans-unit id="11092e508878fe9b88c670c816521fca7c847f2f" translate="yes" xml:space="preserve">
          <source>What are decode_utf8 and encode_utf8?</source>
          <target state="translated">什么是 decode_utf8 和 encode_utf8?</target>
        </trans-unit>
        <trans-unit id="29ffaa3b6cfc90d26e4503a77c7175830b80edb8" translate="yes" xml:space="preserve">
          <source>What are hints?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9717f99f8d2c332a1631b34f3cf973229add73" translate="yes" xml:space="preserve">
          <source>What breaks at what version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a2a28ac7fb746402e9baa692599b97fb2da048e" translate="yes" xml:space="preserve">
          <source>What can you do with a reference once you have it? It's a scalar value, and we've seen that you can store it as a scalar and get it back again just like any scalar. There are just two more ways to use it:</source>
          <target state="translated">一旦你拥有了一个引用,你可以用它做什么?它是一个标量值,我们已经看到,你可以把它作为一个标量来存储,并像任何一个标量一样再把它找回来。只是还有两种方法可以使用它。</target>
        </trans-unit>
        <trans-unit id="36be343f96dfd613d8c5cf587823d859ba4e947b" translate="yes" xml:space="preserve">
          <source>What character encodings does Perl support?</source>
          <target state="translated">Perl支持哪些字符编码?</target>
        </trans-unit>
        <trans-unit id="b31fdc311186d7b04a093fc56872b567ad32984f" translate="yes" xml:space="preserve">
          <source>What distribution contains a particular module?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d7467059fbc01c8f7e5073d6a60b1174890e226" translate="yes" xml:space="preserve">
          <source>What do you do with unsupported filetypes in an archive?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6aa1873fd68eba0f41fb53a3f8a2033690a4a51" translate="yes" xml:space="preserve">
          <source>What do you really want to know? If you merely want to know if one of your filehandles is connected to a terminal, you can try the &lt;code&gt;-t&lt;/code&gt; file test:</source>
          <target state="translated">您真正想知道什么？如果只想知道您的文件句柄之一是否已连接到终端，则可以尝试 &lt;code&gt;-t&lt;/code&gt; 文件测试：</target>
        </trans-unit>
        <trans-unit id="1c337f8d590673be03d6eb277fa1a70849d518ac" translate="yes" xml:space="preserve">
          <source>What do you think &lt;code&gt;$x&lt;/code&gt; will be? The answer, unfortunately, is</source>
          <target state="translated">您认为 &lt;code&gt;$x&lt;/code&gt; 是什么？不幸的是，答案是</target>
        </trans-unit>
        <trans-unit id="72e224b443b5da69c66ac0a14f3f8175aa612a15" translate="yes" xml:space="preserve">
          <source>What does &quot;Bareword 'DB_File' not allowed&quot; mean?</source>
          <target state="translated">裸词'DB_File'不允许 &quot;是什么意思?</target>
        </trans-unit>
        <trans-unit id="d0af16451ebfa2bdedb9044267c2bc5c148972de" translate="yes" xml:space="preserve">
          <source>What does &quot;Invalid Argument&quot; mean?</source>
          <target state="translated">什么叫 &quot;无效论证&quot;?</target>
        </trans-unit>
        <trans-unit id="f0a7abc8d37e669509493f3435ed1f9575fda404" translate="yes" xml:space="preserve">
          <source>What does &quot;bad interpreter&quot; mean?</source>
          <target state="translated">什么叫 &quot;不好翻译&quot;?</target>
        </trans-unit>
        <trans-unit id="128188e5871787fd7e8d0d232b299acadbde54ca" translate="yes" xml:space="preserve">
          <source>What does &quot;wide character in subroutine entry&quot; mean?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e47776a0ddea1129634daa43d411c09b05f88dc" translate="yes" xml:space="preserve">
          <source>What does it mean that regexes are greedy? How can I get around it?</source>
          <target state="translated">贪婪的regex是什么意思?怎样才能绕过它?</target>
        </trans-unit>
        <trans-unit id="fad85491a61b1ab9b17396e45b64b419ab4c8e77" translate="yes" xml:space="preserve">
          <source>What does this mean for regexps? Well, regexp users don't need to know much about Perl's internal representation of strings. But they do need to know 1) how to represent Unicode characters in a regexp and 2) that a matching operation will treat the string to be searched as a sequence of characters, not bytes. The answer to 1) is that Unicode characters greater than &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(255)&lt;/a&gt;&lt;/code&gt; are represented using the &lt;code&gt;\x{&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;}&lt;/code&gt; notation, because \x hex (without curly braces) doesn't go further than 255. (Starting in Perl 5.14, if you're an octal fan, you can also use &lt;code&gt;\o{&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;}&lt;/code&gt; .)</source>
          <target state="translated">这对正则表达式意味着什么？好的，regexp用户不需要了解Perl的字符串内部表示形式。但是他们确实需要知道1）如何在正则表达式中表示Unicode字符，以及2）匹配操作会将要搜索的字符串视为字符序列，而不是字节。对1）的答案是，大于 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(255)&lt;/a&gt;&lt;/code&gt; 的 Unicode字符用 &lt;code&gt;\x{&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;}&lt;/code&gt; 表示，因为\ x hex（不带花括号）不会超过255。（从Perl 5.14开始，如果您是八进制风扇，也可以使用 &lt;code&gt;\o{&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;}&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="975aae02ca21ed8ec96fd5f4735831339586ec7e" translate="yes" xml:space="preserve">
          <source>What does this mean for regexps? Well, regexp users don't need to know much about Perl's internal representation of strings. But they do need to know 1) how to represent Unicode characters in a regexp and 2) that a matching operation will treat the string to be searched as a sequence of characters, not bytes. The answer to 1) is that Unicode characters greater than &lt;code&gt;chr(255)&lt;/code&gt; are represented using the &lt;code&gt;\x{hex}&lt;/code&gt; notation, because &lt;code&gt;\x&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39fa5db720a03edc1fcba3370635f4d2d4adabe0" translate="yes" xml:space="preserve">
          <source>What exact layers are in this default stack depends on a lot of things: your operating system, Perl version, Perl compile time configuration, and Perl runtime configuration. See &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;, &lt;a href=&quot;perlrun#PERLIO&quot;&gt;&quot;PERLIO&quot; in perlrun&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d60263af797b45d08166a1e2276365e53b9c7d0" translate="yes" xml:space="preserve">
          <source>What exact layers are in this default stack depends on a lot of things: your operating system, Perl version, Perl compile time configuration, and Perl runtime configuration. See &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;, &lt;a href=&quot;perlrun#PERLIO&quot;&gt;PERLIO in perlrun&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; for more information.</source>
          <target state="translated">此默认堆栈中的确切层取决于很多因素：操作系统，Perl版本，Perl编译时配置和Perl运行时配置。请参阅&lt;a href=&quot;perlio&quot;&gt;perlrun&lt;/a&gt;中的&lt;a href=&quot;perlrun#PERLIO&quot;&gt;PerlIO，PERLIO&lt;/a&gt;，并&lt;a href=&quot;open&quot;&gt;打开&lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="07854a74e069ff620decff4308e92c81d6bd8098" translate="yes" xml:space="preserve">
          <source>What follows are the more advanced, less used, or sometimes esoteric capabilities of Perl regexps. In Part 2, we will assume you are comfortable with the basics and concentrate on the advanced features.</source>
          <target state="translated">下面将介绍Perl regexps中比较高级的、不常用的,或者有时是深奥的功能。在第二部分中,我们将假设你对基础知识已经很熟悉,并将注意力集中在高级功能上。</target>
        </trans-unit>
        <trans-unit id="565ee5d3831c954154cf4129999eb2ce193f0752" translate="yes" xml:space="preserve">
          <source>What follows is a detailed guide through these steps.</source>
          <target state="translated">下面是对这些步骤的详细指导。</target>
        </trans-unit>
        <trans-unit id="75d7e12868bcb8f2565578748be73375fac12333" translate="yes" xml:space="preserve">
          <source>What follows is a statement about artistic control, defined as the ability of authors of packages to guide the future of their code and maintain control over their work. It is a recognition that authors should have control over their work, and that it is a responsibility of the rest of the Perl community to ensure that they retain this control. It is an attempt to document the standards to which we, as Perl developers, intend to hold ourselves. It is an attempt to write down rough guidelines about the respect we owe each other as Perl developers.</source>
          <target state="translated">下面是关于艺术控制的声明,它被定义为包的作者指导其代码的未来和保持对其作品的控制的能力。它承认作者应该对他们的作品有控制权,而确保他们保持这种控制权是Perl社区其他成员的责任。它试图将我们作为 Perl 开发者所要达到的标准记录下来。它试图写下关于我们作为 Perl 开发者应该相互尊重的大致准则。</target>
        </trans-unit>
        <trans-unit id="374a8e110bb4c1d9c752734c71a27f6e3e497ea6" translate="yes" xml:space="preserve">
          <source>What follows is subject to change RSN.</source>
          <target state="translated">以下内容可能会有变化RSN。</target>
        </trans-unit>
        <trans-unit id="24917de591e0d7708ee26a13cd3362afc4f6c7c4" translate="yes" xml:space="preserve">
          <source>What formats output as a form feed. The default is &lt;code&gt;\f&lt;/code&gt; .</source>
          <target state="translated">什么格式输出为换页。默认值为 &lt;code&gt;\f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7f6f4d84ea57e45f2ca17815f8c029206bd9132" translate="yes" xml:space="preserve">
          <source>What formats output as a form feed. The default is &lt;code&gt;\f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d479059298a571f524af929b6aea396ec65a05e6" translate="yes" xml:space="preserve">
          <source>What gets returned depends on several factors:</source>
          <target state="translated">得到的回报取决于几个因素。</target>
        </trans-unit>
        <trans-unit id="8722b12ceccd8e92d99a716a04b297746411e5f8" translate="yes" xml:space="preserve">
          <source>What good is &lt;code&gt;\G&lt;/code&gt; in a regular expression?</source>
          <target state="translated">有什么好处 &lt;code&gt;\G&lt;/code&gt; 正则表达式？</target>
        </trans-unit>
        <trans-unit id="2f0a90d9f77866c3233e1aef1cc7a9560c6ec0c3" translate="yes" xml:space="preserve">
          <source>What good is \G in a regular expression?</source>
          <target state="translated">正则表达式中的\G有什么用?</target>
        </trans-unit>
        <trans-unit id="ebf8dc71994cee4560964d904824ac92b27fed19" translate="yes" xml:space="preserve">
          <source>What happens if I add or remove keys from a hash while iterating over it?</source>
          <target state="translated">如果我在迭代哈希时从哈希中添加或删除键会发生什么?</target>
        </trans-unit>
        <trans-unit id="ff08f48f056287d25a3dc5672938a653f78c0ce3" translate="yes" xml:space="preserve">
          <source>What happens is that after</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630083c407aaeb1fdb11b2f5b1e425a9f1a5879d" translate="yes" xml:space="preserve">
          <source>What happens when &lt;code&gt;JSON::PP&lt;/code&gt; encounters a Perl object depends on the &lt;code&gt;allow_blessed&lt;/code&gt;, &lt;code&gt;convert_blessed&lt;/code&gt;, &lt;code&gt;allow_tags&lt;/code&gt; and &lt;code&gt;allow_bignum&lt;/code&gt; settings, which are used in this order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6c83c5563cf3fe722575d6dd30278f0a9d68bc" translate="yes" xml:space="preserve">
          <source>What has gone on?</source>
          <target state="translated">到底发生了什么?</target>
        </trans-unit>
        <trans-unit id="148ce7ffb164566545434b0feef660c7bee4a489" translate="yes" xml:space="preserve">
          <source>What has happened here?</source>
          <target state="translated">这里发生了什么?</target>
        </trans-unit>
        <trans-unit id="21eec199e3d296f021d3cdb05af5afb550abb23b" translate="yes" xml:space="preserve">
          <source>What has happened is that &lt;code&gt;fred&lt;/code&gt; accesses the &lt;code&gt;@_&lt;/code&gt; array which belongs to &lt;code&gt;joe&lt;/code&gt; .</source>
          <target state="translated">发生的是， &lt;code&gt;fred&lt;/code&gt; 访问了属于 &lt;code&gt;joe&lt;/code&gt; 的 &lt;code&gt;@_&lt;/code&gt; 数组。</target>
        </trans-unit>
        <trans-unit id="4495f64a5a5a99cc3a0b71199a99723a37e9ed87" translate="yes" xml:space="preserve">
          <source>What has happened is that &lt;code&gt;fred&lt;/code&gt; accesses the &lt;code&gt;@_&lt;/code&gt; array which belongs to &lt;code&gt;joe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1061def72c9d3f6d8d9699c831f84918bba3a0be" translate="yes" xml:space="preserve">
          <source>What if I don't decode?</source>
          <target state="translated">如果我不解码呢?</target>
        </trans-unit>
        <trans-unit id="edc0c9ac4aa8c7b7a3fb61b68506b87d3c69f4bc" translate="yes" xml:space="preserve">
          <source>What if I don't encode?</source>
          <target state="translated">如果我不编码呢?</target>
        </trans-unit>
        <trans-unit id="0ddebc8779b4a58623bcc03eec19b9fd5bdcc57a" translate="yes" xml:space="preserve">
          <source>What if I don't know which encoding was used?</source>
          <target state="translated">如果我不知道使用的是哪种编码怎么办?</target>
        </trans-unit>
        <trans-unit id="b012d213b447ce5a8b3e4b308232eb1a6c342960" translate="yes" xml:space="preserve">
          <source>What if my question isn't answered in the FAQ?</source>
          <target state="translated">如果我的问题没有在FAQ中得到回答怎么办?</target>
        </trans-unit>
        <trans-unit id="30310a64f6e6f73114ef8ff5955e14d7deb5a4c5" translate="yes" xml:space="preserve">
          <source>What if the interface provided by the C callback doesn't contain a parameter which allows the file handle to Perl subroutine mapping? Say in the asynchronous i/o package, the callback function gets passed only the &lt;code&gt;buffer&lt;/code&gt; parameter like this</source>
          <target state="translated">如果C回调提供的接口不包含允许文件句柄到Perl子例程映射的参数，该怎么办？在异步I / O包中说，回调函数仅传递像这样的 &lt;code&gt;buffer&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="f9002d28fd7ee52f5e73c33c74a403efd3585ddf" translate="yes" xml:space="preserve">
          <source>What import does</source>
          <target state="translated">有什么意义?</target>
        </trans-unit>
        <trans-unit id="9281510e66c9b036bf0f2b1f98689d5dbd410309" translate="yes" xml:space="preserve">
          <source>What is &quot;the UTF8 flag&quot;?</source>
          <target state="translated">什么是 &quot;UTF8旗&quot;?</target>
        </trans-unit>
        <trans-unit id="48776d293c1cf7b50ee10897815e6e1c09782388" translate="yes" xml:space="preserve">
          <source>What is /o really for?</source>
          <target state="translated">/o到底是干什么的?</target>
        </trans-unit>
        <trans-unit id="f799c97279ef39d3426ad309ad7dfc5a7d36fff1" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;/o&lt;/code&gt; really for?</source>
          <target state="translated">什么是 &lt;code&gt;/o&lt;/code&gt; 真的？</target>
        </trans-unit>
        <trans-unit id="4da6343eb07811de611e2143a23a9e42def6f17c" translate="yes" xml:space="preserve">
          <source>What is C3?</source>
          <target state="translated">什么是C3?</target>
        </trans-unit>
        <trans-unit id="3f1ecd4984feb033599a0b8b92a1a9741f5b5e8e" translate="yes" xml:space="preserve">
          <source>What is Module::Build and how does it relate to MakeMaker?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda040c2e08659bcff6001c6dcad6149b2b71af9" translate="yes" xml:space="preserve">
          <source>What is Perl 6?</source>
          <target state="translated">什么是Perl 6?</target>
        </trans-unit>
        <trans-unit id="90e6903f9207d6b5637de9d9ec259575b1877362" translate="yes" xml:space="preserve">
          <source>What is Perl?</source>
          <target state="translated">什么是Perl?</target>
        </trans-unit>
        <trans-unit id="79dc15d896921a5be3532940c7478220c26d76f5" translate="yes" xml:space="preserve">
          <source>What is Plack and PSGI?</source>
          <target state="translated">什么是普拉克和PSGI?</target>
        </trans-unit>
        <trans-unit id="234e64d864b7e4e19b7d995b815d4db958366917" translate="yes" xml:space="preserve">
          <source>What is Raku (Perl 6)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c878af8c7031f81a5ddca206fc60a5a12f9ad1d" translate="yes" xml:space="preserve">
          <source>What is Unicode, anyway?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387b2d5d4628ca2a97a160cf17017d26f2363e65" translate="yes" xml:space="preserve">
          <source>What is a &quot;wide character&quot;?</source>
          <target state="translated">什么是 &quot;广字&quot;?</target>
        </trans-unit>
        <trans-unit id="6c07c0817bd40c0602c40f4eb163a577c33eb9e2" translate="yes" xml:space="preserve">
          <source>What is a 'record'? By default, the meaning is the same as for the &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; operator: It's a string terminated by &lt;code&gt;$/&lt;/code&gt; , which is probably &lt;code&gt;&quot;\n&quot;&lt;/code&gt; . (Minor exception: on DOS and Win32 systems, a 'record' is a string terminated by &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; .) You may change the definition of &quot;record&quot; by supplying the &lt;code&gt;recsep&lt;/code&gt; option in the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call:</source>
          <target state="translated">什么是&amp;ldquo;记录&amp;rdquo;？默认情况下，其含义与 &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; 运算符的含义相同：这是一个以 &lt;code&gt;$/&lt;/code&gt; 结尾的字符串，该字符串可能是 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 。（较小的例外：在DOS和Win32系统上，&amp;ldquo;记录&amp;rdquo;是以 &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; 结尾的字符串。）您可以通过在 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用中提供 &lt;code&gt;recsep&lt;/code&gt; 选项来更改&amp;ldquo;记录&amp;rdquo;的定义：</target>
        </trans-unit>
        <trans-unit id="046dcad9c1b5d6658ae493e5f69f47ba914f7843" translate="yes" xml:space="preserve">
          <source>What is a 'record'? By default, the meaning is the same as for the &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; operator: It's a string terminated by &lt;code&gt;$/&lt;/code&gt;, which is probably &lt;code&gt;&quot;\n&quot;&lt;/code&gt;. (Minor exception: on DOS and Win32 systems, a 'record' is a string terminated by &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;.) You may change the definition of &quot;record&quot; by supplying the &lt;code&gt;recsep&lt;/code&gt; option in the &lt;code&gt;tie&lt;/code&gt; call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a841a9e9e59dbc901dca478a52731689558d70" translate="yes" xml:space="preserve">
          <source>What is a DBM Filter?</source>
          <target state="translated">什么是DBM过滤器?</target>
        </trans-unit>
        <trans-unit id="75ea94c254fb7320b80e8d79c658d169412a3588" translate="yes" xml:space="preserve">
          <source>What is a JAPH?</source>
          <target state="translated">什么是JAPH?</target>
        </trans-unit>
        <trans-unit id="8e7e75800308f6339899e8db69308ae93f0337df" translate="yes" xml:space="preserve">
          <source>What is a regular expression engine?</source>
          <target state="translated">什么是正则表达式引擎?</target>
        </trans-unit>
        <trans-unit id="e7e08c44504e895661b69ab0d094008da5741e55" translate="yes" xml:space="preserve">
          <source>What is a regular expression? A regular expression is simply a string that describes a pattern. Patterns are in common use these days; examples are the patterns typed into a search engine to find web pages and the patterns used to list files in a directory, e.g., &lt;code&gt;ls *.txt&lt;/code&gt; or &lt;code&gt;dir *.*&lt;/code&gt;. In Perl, the patterns described by regular expressions are used to search strings, extract desired parts of strings, and to do search and replace operations.</source>
          <target state="translated">什么是正则表达式？正则表达式只是描述模式的字符串。如今，模式已经很普遍了。示例包括输入搜索引擎以查找网页的模式以及用于列出目录中文件的模式，例如 &lt;code&gt;ls *.txt&lt;/code&gt; 或 &lt;code&gt;dir *.*&lt;/code&gt; 。在Perl中，用正则表达式描述的模式用于搜索字符串，提取字符串的所需部分以及进行搜索和替换操作。</target>
        </trans-unit>
        <trans-unit id="ad1619062d7422922f56678f7cf58c8d2f19d36b" translate="yes" xml:space="preserve">
          <source>What is a regular expression? At its most basic, a regular expression is a template that is used to determine if a string has certain characteristics. The string is most often some text, such as a line, sentence, web page, or even a whole book, but less commonly it could be some binary data as well. Suppose we want to determine if the text in variable, &lt;code&gt;$var&lt;/code&gt; contains the sequence of characters &lt;code&gt;m u s h r o o m&lt;/code&gt; (blanks added for legibility). We can write in Perl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1f1924f0cab71521b063802ea721cd9de2bf43" translate="yes" xml:space="preserve">
          <source>What is an &quot;IV&quot;?</source>
          <target state="translated">什么是 &quot;静脉&quot;?</target>
        </trans-unit>
        <trans-unit id="778b266015494167ffcfb5699798ca074f01e4ed" translate="yes" xml:space="preserve">
          <source>What is libnet ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de138e681884a542d6a632e3d45af8060ecf685" translate="yes" xml:space="preserve">
          <source>What is meant here is unclear, as the &lt;code&gt;\N{...}&lt;/code&gt; escape is a sequence of code points, so this is made an error.</source>
          <target state="translated">这里的含义不清楚，因为 &lt;code&gt;\N{...}&lt;/code&gt; 转义是一系列代码点，因此这是一个错误。</target>
        </trans-unit>
        <trans-unit id="7e4d744a0a34b3ed6f2bacfcf8917df2728b341f" translate="yes" xml:space="preserve">
          <source>What is much worse, some DLLs change the floating point flags when in _DLLInitTerm() (e.g.,</source>
          <target state="translated">更糟糕的是,有些DLL在_DLLInitTerm()中改变了浮点标志(例如。</target>
        </trans-unit>
        <trans-unit id="b80f71784676643cac72b04d16a86ddd2aad93c3" translate="yes" xml:space="preserve">
          <source>What is perl.com? Perl Mongers? pm.org? perl.org? cpan.org?</source>
          <target state="translated">什么是perl.com?Perl Mongers? pm.org? perl.org? cpan.org?</target>
        </trans-unit>
        <trans-unit id="b4511cf9900e620f3e5c53ed90d05dd1b6347288" translate="yes" xml:space="preserve">
          <source>What is socket.ph and where do I get it?</source>
          <target state="translated">什么是socket.ph,我在哪里得到它?</target>
        </trans-unit>
        <trans-unit id="466ca1293cf697f510f855a869e855e56cd9f9c1" translate="yes" xml:space="preserve">
          <source>What is the difference between &quot;state&quot; subs and &quot;my&quot; subs? Each time that execution enters a block when &quot;my&quot; subs are declared, a new copy of each sub is created. &quot;State&quot; subroutines persist from one execution of the containing block to the next.</source>
          <target state="translated">&quot;状态 &quot;子和 &quot;我的 &quot;子有什么区别?当 &quot;我的 &quot;子程序被声明时,每次该执行进入一个块时,每个子程序都会创建一个新的副本。&quot;状态 &quot;子程序从包含块的一个执行到下一个执行都是持久的。</target>
        </trans-unit>
        <trans-unit id="fc949184376f42b77d53568413143ee5107891ea" translate="yes" xml:space="preserve">
          <source>What is the difference between $array[1] and @array[1]?</source>
          <target state="translated">$array[1]和@array[1]的区别是什么?</target>
        </trans-unit>
        <trans-unit id="e5e94a34863c5b06b0902ba29af6bbdd60a89b26" translate="yes" xml:space="preserve">
          <source>What is the difference between :encoding and :utf8?</source>
          <target state="translated">:编码和:utf8的区别是什么?</target>
        </trans-unit>
        <trans-unit id="87b2e888c908f6842e557ad8d646535f8dd07500" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;:encoding&lt;/code&gt; and &lt;code&gt;:utf8&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;:encoding&lt;/code&gt; 和 &lt;code&gt;:utf8&lt;/code&gt; 有什么区别？</target>
        </trans-unit>
        <trans-unit id="aa686143aeb2276da66fe372809de6163adbd5d8" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;:encoding&lt;/code&gt; and &lt;code&gt;:utf8&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd9348a87a0e037c9116062611c030ca4d85da9" translate="yes" xml:space="preserve">
          <source>What is the difference between a list and an array?</source>
          <target state="translated">列表和数组的区别是什么?</target>
        </trans-unit>
        <trans-unit id="aa2dc660c0cced5d46caea2cf443fe5e368244c8" translate="yes" xml:space="preserve">
          <source>What is this Perl statement all about? &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; is a simple double-quoted string. &lt;code&gt;World&lt;/code&gt; is the regular expression and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regexp match and produces a true value if the regexp matched, or false if the regexp did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; , so the expression is true. Expressions like this are useful in conditionals:</source>
          <target state="translated">这个Perl声明的全部含义是什么？ &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 是一个简单的双引号字符串。 &lt;code&gt;World&lt;/code&gt; 是正则表达式， &lt;code&gt;//&lt;/code&gt; 包含的 &lt;code&gt;/World/&lt;/code&gt; 告诉Perl在字符串中搜索匹配项。运算符 &lt;code&gt;=~&lt;/code&gt; 将字符串与regexp匹配相关联，如果regexp匹配，则生成true值；如果regexp不匹配，则生成false。在我们的例子中， &lt;code&gt;World&lt;/code&gt; 与 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 中的第二个单词匹配，因此该表达式为true。这样的表达式在条件语句中很有用：</target>
        </trans-unit>
        <trans-unit id="8288a589c4caf7bd2276d185a7bd5fbf595dc73f" translate="yes" xml:space="preserve">
          <source>What is this Perl statement all about? &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; is a simple double-quoted string. &lt;code&gt;World&lt;/code&gt; is the regular expression and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regexp match and produces a true value if the regexp matched, or false if the regexp did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt;, so the expression is true. Expressions like this are useful in conditionals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9fb4cb8e09b50cfb90602035114712466d59042" translate="yes" xml:space="preserve">
          <source>What is variable suicide and how can I prevent it?</source>
          <target state="translated">什么是变量自杀,如何预防?</target>
        </trans-unit>
        <trans-unit id="49ac75fc20864efd20e6c484dddbafd73db6a2e3" translate="yes" xml:space="preserve">
          <source>What is your favorite pager program?</source>
          <target state="translated">你最喜欢的寻呼机程序是什么?</target>
        </trans-unit>
        <trans-unit id="fd63f60b8b6a48f0264ba03539d262e0388b66e2" translate="yes" xml:space="preserve">
          <source>What is your favorite shell?</source>
          <target state="translated">你最喜欢的贝壳是什么?</target>
        </trans-unit>
        <trans-unit id="7a785a8e58c6a9e20c1539582a1a9c97e125374e" translate="yes" xml:space="preserve">
          <source>What kind of stuff is contained in this distribution. Most things on CPAN are &lt;code&gt;module&lt;/code&gt;s (which can also mean a collection of modules), but some things are &lt;code&gt;script&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cdeb97ea551b504f3da8bf43202e9fd344363cd" translate="yes" xml:space="preserve">
          <source>What kind of test? Possibilities include, skip, todo etc. See &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41b525bca416a73d68432b879e12cd6ce5cae2d" translate="yes" xml:space="preserve">
          <source>What kind of threads are Perl threads?</source>
          <target state="translated">什么样的线程是Perl线程?</target>
        </trans-unit>
        <trans-unit id="523c42f572591f0bfb9eb624031ecf0ded9f0a2a" translate="yes" xml:space="preserve">
          <source>What library to use?</source>
          <target state="translated">用什么图书馆?</target>
        </trans-unit>
        <trans-unit id="c9dcfd1a76d749e07495e332956ce4a77d52e8a9" translate="yes" xml:space="preserve">
          <source>What machines support Perl? Where do I get it?</source>
          <target state="translated">哪些机器支持Perl?我在哪里可以得到它?</target>
        </trans-unit>
        <trans-unit id="f891fe8a2be3f1ffe86b5a80057ef4ca6da1223d" translate="yes" xml:space="preserve">
          <source>What machines support libnet ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602afa592af7887a3bffb104fc775a95a31125b0" translate="yes" xml:space="preserve">
          <source>What mailing lists are there for Perl?</source>
          <target state="translated">有哪些邮件列表适合Perl?</target>
        </trans-unit>
        <trans-unit id="4862bb3e93457f890d9e122c5362daa5b89c1284" translate="yes" xml:space="preserve">
          <source>What makes a method special is</source>
          <target state="translated">一个方法的特殊之处在于</target>
        </trans-unit>
        <trans-unit id="c65301b41224a5b616b4c8a04b46b840cdda0ef5" translate="yes" xml:space="preserve">
          <source>What makes all of this important is that the Exporter module uses glob aliasing as the import/export mechanism. Whether or not you can properly localize a variable that has been exported from a module depends on how it was exported:</source>
          <target state="translated">这一切之所以重要,是因为Exporter模块使用glob别名作为导入/导出机制。你是否能正确地本地化一个从模块中导出的变量,取决于它是如何导出的。</target>
        </trans-unit>
        <trans-unit id="8fb5a283f17d0d098d1490569f3aaeb90f52254c" translate="yes" xml:space="preserve">
          <source>What makes for a good patch?</source>
          <target state="translated">怎样才是一个好的补丁?</target>
        </trans-unit>
        <trans-unit id="486e1e8fa6072821d31ad344e76845b470464a6d" translate="yes" xml:space="preserve">
          <source>What makes this pass interesting for perl developers is that some optimization may be performed on this pass. This is optimization by so-called &quot;check routines&quot;. The correspondence between node names and corresponding check routines is described in</source>
          <target state="translated">对于perl开发者来说,这个通证的有趣之处在于,在这个通证上可能会进行一些优化。这就是所谓的 &quot;检查例程 &quot;的优化。节点名和相应的检查例程之间的对应关系在</target>
        </trans-unit>
        <trans-unit id="7c3d71cb8c06e618edc314c89194f61b595a4c29" translate="yes" xml:space="preserve">
          <source>What modules and extensions are available for Perl? What is CPAN?</source>
          <target state="translated">Perl 有哪些模块和扩展?什么是CPAN?</target>
        </trans-unit>
        <trans-unit id="5eca61ede7bdc9f4a1c178015ba2713ba5ace84a" translate="yes" xml:space="preserve">
          <source>What modules does a particular distribution contain?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709f8e1c07fc1fe28e0f229bb8ce88d468c08c8e" translate="yes" xml:space="preserve">
          <source>What modules shipped with versions of perl</source>
          <target state="translated">perl版本中包含哪些模块</target>
        </trans-unit>
        <trans-unit id="bbb49ac4107bc251bf787f21f8a88fe7e30321ce" translate="yes" xml:space="preserve">
          <source>What most people need to know (superclasses on top.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b01351f5f724ad044096c916ace26f9169184a3" translate="yes" xml:space="preserve">
          <source>What other modules do I need ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f3978619a4438d900606a19c92b7d1f8afc742" translate="yes" xml:space="preserve">
          <source>What regop is next?</source>
          <target state="translated">接下来是什么regop?</target>
        </trans-unit>
        <trans-unit id="88176d2562c5c584253c31b2148c8703789870d4" translate="yes" xml:space="preserve">
          <source>What seems a successful strategy is the combination of &lt;code&gt;reload
cpan&lt;/code&gt; and the debugging switches. Add a new debug statement while running in the shell and then issue a &lt;code&gt;reload cpan&lt;/code&gt; and see the new debugging messages immediately without losing the current context.</source>
          <target state="translated">成功的策略似乎是 &lt;code&gt;reload cpan&lt;/code&gt; 和调试开关的组合。在Shell中运行时添加新的调试语句，然后发出 &lt;code&gt;reload cpan&lt;/code&gt; 并立即查看新的调试消息，而不会丢失当前上下文。</target>
        </trans-unit>
        <trans-unit id="494e70de221fde56713efc23ab1ca24064c718dc" translate="yes" xml:space="preserve">
          <source>What should I make into a module?</source>
          <target state="translated">我应该做成什么模块?</target>
        </trans-unit>
        <trans-unit id="0e5fb1910c7b0867ac71d8402069e7fbfc90bc05" translate="yes" xml:space="preserve">
          <source>What some helper &lt;b&gt;process&lt;/b&gt; did to transform the incoming data into a form more suitable for the current process. Often done with an incoming &lt;b&gt;pipe&lt;/b&gt;. See also &lt;b&gt;C preprocessor&lt;/b&gt;.</source>
          <target state="translated">某些帮助&lt;b&gt;程序流程&lt;/b&gt;将传入的数据转换为更适合当前流程的形式所做的工作。通常用进&lt;b&gt;水管&lt;/b&gt;来完成。另请参见&lt;b&gt;C预处理程序&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="05edee69ab0b091485f39a349759f585c24e0340" translate="yes" xml:space="preserve">
          <source>What the program or function returns, if successful. This section can be omitted for programs whose precise exit codes aren't important, provided they return 0 on success and non-zero on failure as is standard. It should always be present for functions. For modules, it may be useful to summarize return values from the module interface here, or it may be more useful to discuss return values separately in the documentation of each function or method the module provides.</source>
          <target state="translated">如果成功,程序或函数返回什么。对于那些精确的退出代码并不重要的程序,这部分可以省略,只要它们在成功时返回0,失败时返回非零即可。对于函数来说,这部分应该始终存在。对于模块来说,在这里总结模块接口的返回值可能是有用的,或者在模块提供的每个函数或方法的文档中单独讨论返回值可能更有用。</target>
        </trans-unit>
        <trans-unit id="b11685dda194db5e13d9f10a2284151cb724112f" translate="yes" xml:space="preserve">
          <source>What this does is creates a new binary op, and feeds it a number of variables. The variables refer to the tokens: &lt;code&gt;$1&lt;/code&gt; is the first token in the input, &lt;code&gt;$2&lt;/code&gt; the second, and so on - think regular expression backreferences. &lt;code&gt;$$&lt;/code&gt; is the op returned from this reduction. So, we call &lt;code&gt;newBINOP&lt;/code&gt; to create a new binary operator. The first parameter to &lt;code&gt;newBINOP&lt;/code&gt; , a function in</source>
          <target state="translated">这样做是创建一个新的二进制op，并为其提供许多变量。变量引用标记： &lt;code&gt;$1&lt;/code&gt; 是输入中的第一个标记， &lt;code&gt;$2&lt;/code&gt; 是输入中的第二个标记，依此类推-考虑正则表达式反向引用。 &lt;code&gt;$$&lt;/code&gt; 是此减少所返回的操作。因此，我们调用 &lt;code&gt;newBINOP&lt;/code&gt; 创建一个新的二进制运算符。 &lt;code&gt;newBINOP&lt;/code&gt; 的第一个参数，是</target>
        </trans-unit>
        <trans-unit id="b67434e808539a7f62532e0f74741a29eeb423fa" translate="yes" xml:space="preserve">
          <source>What this does is creates a new binary op, and feeds it a number of variables. The variables refer to the tokens: &lt;code&gt;$1&lt;/code&gt; is the first token in the input, &lt;code&gt;$2&lt;/code&gt; the second, and so on - think regular expression backreferences. &lt;code&gt;$$&lt;/code&gt; is the op returned from this reduction. So, we call &lt;code&gt;newBINOP&lt;/code&gt; to create a new binary operator. The first parameter to &lt;code&gt;newBINOP&lt;/code&gt;, a function in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc8ecd0e95182504b6e5e23619c1654db502160" translate="yes" xml:space="preserve">
          <source>What this means is that if you have data written by Storable 1.x running on perl 5.6.0 or 5.6.1 configured with 64 bit integers on Unix or Linux then by default this Storable will refuse to read it, giving the error</source>
          <target state="translated">这意味着,如果你的数据由运行在perl 5.6.0或5.6.1上的Storable 1.x写入,并在Unix或Linux上配置了64位整数,那么默认情况下,这个Storable将拒绝读取数据,并给出错误提示</target>
        </trans-unit>
        <trans-unit id="c1074e9471d381d1e3fa377b4baeab5a37484773" translate="yes" xml:space="preserve">
          <source>What this means is that unless the &lt;code&gt;/a&lt;/code&gt; modifier is in effect &lt;code&gt;\d&lt;/code&gt; not only matches the digits '0' - '9', but also Arabic, Devanagari, and digits from other languages. This may cause some confusion, and some security issues.</source>
          <target state="translated">这意味着除非 &lt;code&gt;/a&lt;/code&gt; 修饰符有效，否则 &lt;code&gt;\d&lt;/code&gt; 不仅与数字'0'-'9'匹配，而且还与阿拉伯语，梵文和其他语言的数字匹配。这可能会引起一些混乱和一些安全问题。</target>
        </trans-unit>
        <trans-unit id="024bfa55bc6c90f99bae14081b1ca78d49501b2e" translate="yes" xml:space="preserve">
          <source>What this says is: &lt;code&gt;1..1&lt;/code&gt; &quot;I'm going to run one test.&quot; [1] &lt;code&gt;ok 1&lt;/code&gt; &quot;The first test passed&quot;. And that's about all magic there is to testing. Your basic unit of testing is the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90ef1b55a5f8c0ad6415f98413e6a092c07a530" translate="yes" xml:space="preserve">
          <source>What to put after &quot;1/crontab&quot; in the URL. This option is not set by default.</source>
          <target state="translated">在URL中的 &quot;1/crontab &quot;后面放什么。这个选项默认不设置。</target>
        </trans-unit>
        <trans-unit id="616a4166af25f3f615ff259d316398355eca1fd7" translate="yes" xml:space="preserve">
          <source>What to put after &quot;Foo%3a%3aBar&quot; in the URL. This option is not set by default.</source>
          <target state="translated">在URL中的 &quot;Foo%3a%3aBar &quot;后面放什么。这个选项默认不设置。</target>
        </trans-unit>
        <trans-unit id="774021bac19bdf5e083a7ddf41b218a869e89eea" translate="yes" xml:space="preserve">
          <source>What to put before and after the title in the head. The values should already be &amp;amp;-escaped.</source>
          <target state="translated">标题之前和之后的内容。值应已＆换码。</target>
        </trans-unit>
        <trans-unit id="46d727439e117340febafb43135cffaac5ab87fa" translate="yes" xml:space="preserve">
          <source>What utilities shipped with versions of perl</source>
          <target state="translated">哪些实用程序随perl的版本一起发布?</target>
        </trans-unit>
        <trans-unit id="41d1f562b44341deaff0802951db706e407b9e33" translate="yes" xml:space="preserve">
          <source>What version of Perl you are running?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f6137e22ba58dcead1d29483955dc880eaf485" translate="yes" xml:space="preserve">
          <source>What was in this chunk of memory? Numbers, characters, or a mixture of both? Assuming that we're on a computer where ASCII (or some similar) encoding is used: hexadecimal values in the range &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; indicate an uppercase letter, and &lt;code&gt;0x20&lt;/code&gt; encodes a space. So we might assume it is a piece of text, which some are able to read like a tabloid; but others will have to get hold of an ASCII table and relive that firstgrader feeling. Not caring too much about which way to read this, we note that &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the template code &lt;code&gt;H&lt;/code&gt; converts the contents of a sequence of bytes into the customary hexadecimal notation. Since &quot;a sequence of&quot; is a pretty vague indication of quantity, &lt;code&gt;H&lt;/code&gt; has been defined to convert just a single hexadecimal digit unless it is followed by a repeat count. An asterisk for the repeat count means to use whatever remains.</source>
          <target state="translated">这块内存是什么？数字，字符还是两者的混合？假设我们其中ASCII（或一些类似的）编码用于在计算机上：十六进制值的范围在 &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; 指示大写字母，和 &lt;code&gt;0x20&lt;/code&gt; 的编码的空间。因此，我们可以假设它是一段文本，有些文本可以像小报一样阅读。但其他人则必须掌握ASCII表并重温这种firstgrader的感觉。我们不太在乎读取哪种方式，我们注意到用模板代码 &lt;code&gt;H&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 会将字节序列的内容转换为惯用的十六进制表示法。由于&amp;ldquo;序列的&amp;rdquo;是数量的模糊表示，因此 &lt;code&gt;H&lt;/code&gt; 已定义为仅转换一个十六进制数字，除非其后跟随重复计数。重复计数的星号表示要使用剩余的任何东西。</target>
        </trans-unit>
        <trans-unit id="0db88274915aa193b8762de0b1150e4497a2898f" translate="yes" xml:space="preserve">
          <source>What was in this chunk of memory? Numbers, characters, or a mixture of both? Assuming that we're on a computer where ASCII (or some similar) encoding is used: hexadecimal values in the range &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; indicate an uppercase letter, and &lt;code&gt;0x20&lt;/code&gt; encodes a space. So we might assume it is a piece of text, which some are able to read like a tabloid; but others will have to get hold of an ASCII table and relive that firstgrader feeling. Not caring too much about which way to read this, we note that &lt;code&gt;unpack&lt;/code&gt; with the template code &lt;code&gt;H&lt;/code&gt; converts the contents of a sequence of bytes into the customary hexadecimal notation. Since &quot;a sequence of&quot; is a pretty vague indication of quantity, &lt;code&gt;H&lt;/code&gt; has been defined to convert just a single hexadecimal digit unless it is followed by a repeat count. An asterisk for the repeat count means to use whatever remains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a26aa5328e43e90f045fe86149fb674a158916" translate="yes" xml:space="preserve">
          <source>What we actually need to do is expand the width of the fields. The &lt;code&gt;A&lt;/code&gt; format pads any non-existent characters with spaces, so we can use the additional spaces to line up our fields, like this:</source>
          <target state="translated">我们实际上需要做的是扩大字段的宽度。在 &lt;code&gt;A&lt;/code&gt; 格式垫任何不存在的字符空格，所以我们可以使用额外的空间来排队我们的田野，就像这样：</target>
        </trans-unit>
        <trans-unit id="b18ad647190599dbc6f89a0be950252c58677d5e" translate="yes" xml:space="preserve">
          <source>What we have described so far is the single form of the &lt;code&gt;\p{...}&lt;/code&gt; character classes. There is also a compound form which you may run into. These look like &lt;code&gt;\p{&lt;i&gt;name&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; or &lt;code&gt;\p{&lt;i&gt;name&lt;/i&gt;:&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; (the equals sign and colon can be used interchangeably). These are more general than the single form, and in fact most of the single forms are just Perl-defined shortcuts for common compound forms. For example, the script examples in the previous paragraph could be written equivalently as &lt;code&gt;\p{Script_Extensions=Latin}&lt;/code&gt;, &lt;code&gt;\p{Script_Extensions:Greek}&lt;/code&gt;, &lt;code&gt;\p{script_extensions=katakana}&lt;/code&gt;, and &lt;code&gt;\P{script_extensions=balinese}&lt;/code&gt; (case is irrelevant between the &lt;code&gt;{}&lt;/code&gt; braces). You may never have to use the compound forms, but sometimes it is necessary, and their use can make your code easier to understand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c37b176ea3009646e0be80ec6a53f25b8ff9dcd" translate="yes" xml:space="preserve">
          <source>What we have described so far is the single form of the &lt;code&gt;\p{...}&lt;/code&gt; character classes. There is also a compound form which you may run into. These look like &lt;code&gt;\p{name=value}&lt;/code&gt; or &lt;code&gt;\p{name:value}&lt;/code&gt; (the equals sign and colon can be used interchangeably). These are more general than the single form, and in fact most of the single forms are just Perl-defined shortcuts for common compound forms. For example, the script examples in the previous paragraph could be written equivalently as &lt;code&gt;\p{Script=Latin}&lt;/code&gt; , &lt;code&gt;\p{Script:Greek}&lt;/code&gt; , &lt;code&gt;\p{script=katakana}&lt;/code&gt; , and &lt;code&gt;\P{script=balinese}&lt;/code&gt; (case is irrelevant between the &lt;code&gt;{}&lt;/code&gt; braces). You may never have to use the compound forms, but sometimes it is necessary, and their use can make your code easier to understand.</source>
          <target state="translated">到目前为止，我们已经描述的是 &lt;code&gt;\p{...}&lt;/code&gt; 字符类的单一形式。您可能还会遇到一种复合形式。它们看起来像 &lt;code&gt;\p{name=value}&lt;/code&gt; 或 &lt;code&gt;\p{name:value}&lt;/code&gt; （等号和冒号可以互换使用）。它们比单一形式更通用，实际上，大多数单一形式只是Perl定义的常见复合形式的快捷方式。例如，上一段中的脚本示例可以等效地写为 &lt;code&gt;\p{Script=Latin}&lt;/code&gt; ， &lt;code&gt;\p{Script:Greek}&lt;/code&gt; ， &lt;code&gt;\p{script=katakana}&lt;/code&gt; 和 &lt;code&gt;\P{script=balinese}&lt;/code&gt; （大小写为与 &lt;code&gt;{}&lt;/code&gt; 之间无关大括号）。您可能永远不必使用复合形式，但有时是必须的，它们的使用可以使您的代码更易于理解。</target>
        </trans-unit>
        <trans-unit id="3384939add5296135f386c16a3d5a3c4d7477676" translate="yes" xml:space="preserve">
          <source>What you are told when someone thinks you should Read The Fine Manual.</source>
          <target state="translated">当有人认为你应该阅读《精美手册》时,会告诉你什么。</target>
        </trans-unit>
        <trans-unit id="5da1aaeac7913632bcb1c91e0e40a9b8f5b306d1" translate="yes" xml:space="preserve">
          <source>What you can do is calculate the MD5 checksum of the UTF-8 representation of such strings. This is achieved by filtering the string through encode_utf8() function:</source>
          <target state="translated">你可以做的是计算这种字符串的UTF-8表示的MD5校验和。这是通过 encode_utf8()函数对字符串进行过滤来实现的。</target>
        </trans-unit>
        <trans-unit id="bdac7845b72b0a0aaba866c488e59de83492ce2f" translate="yes" xml:space="preserve">
          <source>What you get from your ancestors, genetically or otherwise. If you happen to be a &lt;b&gt;class&lt;/b&gt;, your ancestors are called &lt;b&gt;base classes&lt;/b&gt; and your descendants are called &lt;b&gt;derived classes&lt;/b&gt;. See &lt;b&gt;single inheritance&lt;/b&gt; and &lt;b&gt;multiple inheritance&lt;/b&gt;.</source>
          <target state="translated">从遗传学或其他方面从祖先那里获得的收益。如果您碰巧是一个&lt;b&gt;类&lt;/b&gt;，那么您的祖先将被称为&lt;b&gt;基类，&lt;/b&gt;而您的后代将被称为&lt;b&gt;派生类&lt;/b&gt;。请参阅&lt;b&gt;单继承&lt;/b&gt;和&lt;b&gt;多继承&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2c06f68d01c975c0659982cd1d1ea555fe3696b9" translate="yes" xml:space="preserve">
          <source>What you get when you do &lt;code&gt;Perl++&lt;/code&gt; twice. Doing it only once will curl your hair. You have to increment it eight times to shampoo your hair. Lather, rinse, iterate.</source>
          <target state="translated">两次执行 &lt;code&gt;Perl++&lt;/code&gt; 会得到什么。只做一次会卷曲你的头发。您必须将其增加八倍才能洗头。泡沫，冲洗，反复。</target>
        </trans-unit>
        <trans-unit id="d8dd19339629eae0964d65277b9af39d2d940ac8" translate="yes" xml:space="preserve">
          <source>What you probably want instead is this:</source>
          <target state="translated">你可能想要的是这个。</target>
        </trans-unit>
        <trans-unit id="b04bf6a0eeeb74b4ebb74c0ffdfd7f57764ab34f" translate="yes" xml:space="preserve">
          <source>What you want to use instead is:</source>
          <target state="translated">你要用的是:</target>
        </trans-unit>
        <trans-unit id="f3ca9a26fe44a59f17183be2ef23ecb124cf272f" translate="yes" xml:space="preserve">
          <source>What's MakeMaker?</source>
          <target state="translated">什么是MakeMaker?</target>
        </trans-unit>
        <trans-unit id="42464d9de4a99557d583081f2fb3c257e19a8cfc" translate="yes" xml:space="preserve">
          <source>What's Really Stored in an SV?</source>
          <target state="translated">SV中到底存储了什么?</target>
        </trans-unit>
        <trans-unit id="8f84a94f1018dae65b2467147ba94f01d14ea50b" translate="yes" xml:space="preserve">
          <source>What's a closure?</source>
          <target state="translated">什么是封闭?</target>
        </trans-unit>
        <trans-unit id="a80aec1f19639cbbb28c71d9ddfac9f28b371cff" translate="yes" xml:space="preserve">
          <source>What's an extension?</source>
          <target state="translated">什么是扩展?</target>
        </trans-unit>
        <trans-unit id="96c69ba1e09918b49d4e34120c9bbb2d0968449e" translate="yes" xml:space="preserve">
          <source>What's in Plan 9 Perl</source>
          <target state="translated">Plan 9 Perl中的内容</target>
        </trans-unit>
        <trans-unit id="e9c4131b2629bb86dafeed8bcd2c9f6a25583f3a" translate="yes" xml:space="preserve">
          <source>What's in a name?</source>
          <target state="translated">名字里有什么?</target>
        </trans-unit>
        <trans-unit id="5131dc0eec6cff59e581098235ddc4625176b69a" translate="yes" xml:space="preserve">
          <source>What's new here?</source>
          <target state="translated">这里有什么新鲜事?</target>
        </trans-unit>
        <trans-unit id="22ab29c1c9e23b6be4d152ca0fbe8d1fd5003e73" translate="yes" xml:space="preserve">
          <source>What's not in Plan 9 Perl</source>
          <target state="translated">Plan 9 Perl中没有的内容</target>
        </trans-unit>
        <trans-unit id="5d2b08ade1fd6cb20cb499440eecabb1a859edc0" translate="yes" xml:space="preserve">
          <source>What's that &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;? Well, the arguments to a subroutine are available to us as a special array called &lt;code&gt;@_&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more on that). The default argument to the &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; function just happens to be &lt;code&gt;@_&lt;/code&gt; . So &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $logmessage = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; shifts the first item off the list of arguments and assigns it to &lt;code&gt;$logmessage&lt;/code&gt; .</source>
          <target state="translated">那是什么 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; ？好吧，子例程的参数可以作为称为 &lt;code&gt;@_&lt;/code&gt; 的特殊数组提供给我们（有关更多信息，请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;）。 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 函数的默认参数恰好是 &lt;code&gt;@_&lt;/code&gt; 。所以 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $logmessage = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; 将第一项移出参数列表，并将其分配给 &lt;code&gt;$logmessage&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f547a820f19e246c5a238efacc444f158add7954" translate="yes" xml:space="preserve">
          <source>What's that &lt;code&gt;shift&lt;/code&gt;? Well, the arguments to a subroutine are available to us as a special array called &lt;code&gt;@_&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more on that). The default argument to the &lt;code&gt;shift&lt;/code&gt; function just happens to be &lt;code&gt;@_&lt;/code&gt;. So &lt;code&gt;my $logmessage = shift;&lt;/code&gt; shifts the first item off the list of arguments and assigns it to &lt;code&gt;$logmessage&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46db4fba6102cb384fdb3af284b14f9799d7a634" translate="yes" xml:space="preserve">
          <source>What's the difference between &quot;delete&quot; and &quot;undef&quot; with hashes?</source>
          <target state="translated">&quot;删除 &quot;和 &quot;undef &quot;与哈希有什么区别?</target>
        </trans-unit>
        <trans-unit id="efcfc0c915c5ced8aa18fe665d7a6bf921317ac3" translate="yes" xml:space="preserve">
          <source>What's the difference between &quot;perl&quot; and &quot;Perl&quot;?</source>
          <target state="translated">&quot;perl &quot;和 &quot;Perl &quot;有什么区别?</target>
        </trans-unit>
        <trans-unit id="63f076d778aa21d0e84626f4c5e0c5b8d663503c" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;UTF-8&lt;/code&gt; and &lt;code&gt;utf8&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;UTF-8&lt;/code&gt; 和 &lt;code&gt;utf8&lt;/code&gt; 有什么区别？</target>
        </trans-unit>
        <trans-unit id="80de415750b641663470a45e8ab912ba377dfdef" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;UTF-8&lt;/code&gt; and &lt;code&gt;utf8&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1cf1781cda10277aefd4a7483c6c07d76809d8" translate="yes" xml:space="preserve">
          <source>What's the difference between UTF-8 and utf8?</source>
          <target state="translated">UTF-8和utf8有什么区别?</target>
        </trans-unit>
        <trans-unit id="1a32eae97c19fcd8cd7ae50ba5b1fb91847cfda9" translate="yes" xml:space="preserve">
          <source>What's the difference between calling a function as &amp;amp;foo and foo()?</source>
          <target state="translated">将函数调用为＆foo和foo（）有什么区别？</target>
        </trans-unit>
        <trans-unit id="def2247288e4f5204ba55472b4461e996492e2e7" translate="yes" xml:space="preserve">
          <source>What's the difference between deep and shallow binding?</source>
          <target state="translated">深装和浅装有什么区别?</target>
        </trans-unit>
        <trans-unit id="95fdb9749f45655e65a25dc015c0a84e8ebabe59" translate="yes" xml:space="preserve">
          <source>What's the difference between dynamic and lexical (static) scoping? Between local() and my()?</source>
          <target state="translated">动态和词法(静态)作用域之间的区别是什么?local()和my()之间的区别?</target>
        </trans-unit>
        <trans-unit id="83bcf34d32fd45bb7e4990d1041e30347690cdee" translate="yes" xml:space="preserve">
          <source>What's the difference between require and use?</source>
          <target state="translated">要求和使用之间有什么区别?</target>
        </trans-unit>
        <trans-unit id="623db2e6cf92d9577f09035416d4d1ab6a554bc6" translate="yes" xml:space="preserve">
          <source>What's the minimum perl version required to run Archive::Tar?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6475c25e2b2e180b098b671e2a15d671e687b92e" translate="yes" xml:space="preserve">
          <source>What's this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65cf3a0e365c639b428e364b59520ed78e55a70c" translate="yes" xml:space="preserve">
          <source>What's wrong the with gettext-using code like this...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20e3ec3698a540277cd6005030f3f2eae027cdc" translate="yes" xml:space="preserve">
          <source>What's wrong with *-w* and $^W</source>
          <target state="translated">*-w*和$^W有什么问题?</target>
        </trans-unit>
        <trans-unit id="0d7b30ea762ee4ef5180cde544a82675165a0f09" translate="yes" xml:space="preserve">
          <source>What's wrong with -w and $^W</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8abb891068053380c8e2c57ccfc03bd7f1c3bec" translate="yes" xml:space="preserve">
          <source>What's wrong with &lt;b&gt;-w&lt;/b&gt; and &lt;code&gt;$^W&lt;/code&gt;</source>
          <target state="translated">&lt;b&gt;-w&lt;/b&gt;和 &lt;code&gt;$^W&lt;/code&gt; 有什么问题</target>
        </trans-unit>
        <trans-unit id="86c8915176784b924b124a7df71bcedbc4d5aeac" translate="yes" xml:space="preserve">
          <source>What's wrong with always quoting &quot;$vars&quot;?</source>
          <target state="translated">总是引用&quot;$vars &quot;有什么问题?</target>
        </trans-unit>
        <trans-unit id="a6b6f35263a6c409ef4d9ea90bf4d23520808808" translate="yes" xml:space="preserve">
          <source>What's wrong with using backticks in a void context?</source>
          <target state="translated">在虚空语境中使用背标有什么问题?</target>
        </trans-unit>
        <trans-unit id="15b450eb4383c04ae9890e63ad467617d37b687c" translate="yes" xml:space="preserve">
          <source>What's wrong with using grep in a void context?</source>
          <target state="translated">在void上下文中使用grep有什么问题?</target>
        </trans-unit>
        <trans-unit id="48dabfbbabfdd23fd6a91f1e79b5b5393e8fc727" translate="yes" xml:space="preserve">
          <source>What's wrong?</source>
          <target state="translated">怎么了?</target>
        </trans-unit>
        <trans-unit id="81f7ea2721e1db165495605d1bf1128fca1fe7a9" translate="yes" xml:space="preserve">
          <source>Whatever a reference refers to, which may or may not have a name. Common types of referents include scalars, arrays, hashes, and subroutines.</source>
          <target state="translated">无论引用指的是什么,它都可以有名字,也可以没有名字。常见的引用类型包括标量、数组、哈希和子程序。</target>
        </trans-unit>
        <trans-unit id="088ce6907b9c85d16edc0ae58b2aca12ddc17aac" translate="yes" xml:space="preserve">
          <source>Whatever happens in the RE engine might be better discussed in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;, but for the sake of continuity, we shall do so here.</source>
          <target state="translated">RE引擎中发生的任何事情都可能会在&lt;a href=&quot;perlre&quot;&gt;Perlre中&lt;/a&gt;进行更好的讨论，但是出于连续性考虑，我们将在此处进行讨论。</target>
        </trans-unit>
        <trans-unit id="1858f2d67aca21222e3d2c00cfe67bcfdc61e6f3" translate="yes" xml:space="preserve">
          <source>Whatever the distribution configured with on the releaser's machine at release time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f153d99158c54cb43c1d3fc8596ddbfe423f08fe" translate="yes" xml:space="preserve">
          <source>Whatever you want to do with a reference, &lt;b&gt;Use Rule 1&lt;/b&gt; tells you how to do it. You just write the Perl code that you would have written for doing the same thing to a regular array or hash, and then replace the array or hash name with &lt;code&gt;{$reference}&lt;/code&gt; . &quot;How do I loop over an array when all I have is a reference?&quot; Well, to loop over an array, you would write</source>
          <target state="translated">无论您想对参考进行什么操作，&lt;b&gt;使用规则1都会&lt;/b&gt;告诉您如何做。您只需将为完成相同操作而编写的Perl代码写入常规数组或哈希，然后将数组或哈希名称替换为 &lt;code&gt;{$reference}&lt;/code&gt; 。&amp;ldquo;当我只有引用时，如何遍历数组？&amp;rdquo; 好吧，要遍历数组，您可以编写</target>
        </trans-unit>
        <trans-unit id="b5090b0a0f33f56f40ebfa24d96ae2ad1f9f57a8" translate="yes" xml:space="preserve">
          <source>Whatever you want to do with a reference, &lt;b&gt;Use Rule 1&lt;/b&gt; tells you how to do it. You just write the Perl code that you would have written for doing the same thing to a regular array or hash, and then replace the array or hash name with &lt;code&gt;{$reference}&lt;/code&gt;. &quot;How do I loop over an array when all I have is a reference?&quot; Well, to loop over an array, you would write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="7ae3880ea71f58f5dbf3834e6e0d70053eb70246" translate="yes" xml:space="preserve">
          <source>When &quot;&lt;code&gt;::&lt;/code&gt; &quot; is not in the name, &quot;&lt;code&gt;Encode::&lt;/code&gt; &quot; is assumed.</source>
          <target state="translated">当&amp;ldquo; &lt;code&gt;::&lt;/code&gt; &amp;rdquo;的名称不是&amp;ldquo; &lt;code&gt;Encode::&lt;/code&gt; &amp;rdquo;假设。</target>
        </trans-unit>
        <trans-unit id="8cc9e35707e78514053d0fbc759ccaa1c9412305" translate="yes" xml:space="preserve">
          <source>When &quot;&lt;code&gt;::&lt;/code&gt;&quot; is not in the name, &quot;&lt;code&gt;Encode::&lt;/code&gt;&quot; is assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89c66deca9575739eac57be484648de00b11290" translate="yes" xml:space="preserve">
          <source>When $data is present, sets the instance data to $data and returns the object itself. Otherwise, the current instance data is returned.</source>
          <target state="translated">当$data存在时,将实例数据设置为$data,并返回对象本身。否则,将返回当前的实例数据。</target>
        </trans-unit>
        <trans-unit id="5ea5db67e72bdcabd78dcc6373fac87d452cfae7" translate="yes" xml:space="preserve">
          <source>When $encoding is omitted, it defaults to utf8 if $data is already in utf8 or &quot;&quot; (empty string) otherwise.</source>
          <target state="translated">当省略$encoding时,如果$data已经是utf8或&quot;&quot;,则默认为utf8。(空字符串),否则。</target>
        </trans-unit>
        <trans-unit id="3a255f10977ad0e9fd4eef99c75ca5b6bedb2369" translate="yes" xml:space="preserve">
          <source>When $encoding is present, sets the instance encoding to $encoding and returns the object itself. Otherwise, the current instance encoding is returned.</source>
          <target state="translated">当存在$encoding时,将实例编码设置为$encoding并返回对象本身。否则,返回当前的实例编码。</target>
        </trans-unit>
        <trans-unit id="c1731c29e738a553728a82585755466ae75d0743" translate="yes" xml:space="preserve">
          <source>When $walker is called, it traverses the subroutines supplied when it was created, and renders them using the current style. You can change the style afterwards in several different ways:</source>
          <target state="translated">当调用$walker时,它会遍历创建它时提供的子程序,并使用当前的样式来渲染它们。你可以在之后用几种不同的方式改变风格。</target>
        </trans-unit>
        <trans-unit id="34501938bea4725e00e5d23af26af9e9de4937a2" translate="yes" xml:space="preserve">
          <source>When 'make clean' or similar is run, the $(FIRST_MAKEFILE) will be backed up at this location.</source>
          <target state="translated">当运行'make clean'或类似的程序时,$(FIRST_MAKEFILE)将在这个位置进行备份。</target>
        </trans-unit>
        <trans-unit id="0abdf7ca0a208a27b487c4c9ab6758614a97566c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt; had a host option, this host will be used. Without &lt;code&gt;$host&lt;/code&gt; argument, all hosts are scanned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e0d783eb05bd44a60d48045d09e1ab76b77d53" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;&quot;`STRING`&quot; in perlop&lt;/a&gt; and &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a194e79d9bd84bd7e1d0517e4cb70b910eba34" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt; (but not &lt;code&gt;use locale ':not_characters'&lt;/code&gt;) is in effect, &lt;code&gt;sort LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7a9b507455bc0f46d9bdf6728d0f728b33492c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; is set to &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;, when &lt;a href=&quot;#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; subsequently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a46234156e6749e9bc38b78f59bb3969925d8bf" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;--compat-version&lt;/b&gt; (&lt;b&gt;-b&lt;/b&gt;) is present the generated tests will use &lt;code&gt;Test::More&lt;/code&gt; rather than &lt;code&gt;Test&lt;/code&gt; which is the default for versions before 5.6.2. &lt;code&gt;Test::More&lt;/code&gt; will be added to PREREQ_PM in the generated &lt;code&gt;Makefile.PL&lt;/code&gt; .</source>
          <target state="translated">当出现&lt;b&gt;--compat-version&lt;/b&gt;（&lt;b&gt;-b&lt;/b&gt;）时，生成的测试将使用 &lt;code&gt;Test::More&lt;/code&gt; 而不是 &lt;code&gt;Test&lt;/code&gt; ，这是5.6.2之前版本的默认设置。 &lt;code&gt;Test::More&lt;/code&gt; 将添加到生成的 &lt;code&gt;Makefile.PL&lt;/code&gt; 中的 PREREQ_PM中。</target>
        </trans-unit>
        <trans-unit id="0c72e13c5aa4ae0a2cebdd6d17deca3e4c332c7a" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;--compat-version&lt;/b&gt; (&lt;b&gt;-b&lt;/b&gt;) is present the generated tests will use &lt;code&gt;Test::More&lt;/code&gt; rather than &lt;code&gt;Test&lt;/code&gt; which is the default for versions before 5.6.2. &lt;code&gt;Test::More&lt;/code&gt; will be added to PREREQ_PM in the generated &lt;code&gt;Makefile.PL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d44d0dc017c71b0f6cb1ffd43c417d3ee2ebe5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;S&quot;&lt;/code&gt; can match, it is a better match than when only &lt;code&gt;&quot;T&quot;&lt;/code&gt; can match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98323433c84745d96d2f69c24c5375707e53e818" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, when &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">当 &lt;code&gt;$/&lt;/code&gt; 设置为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 时，当 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 在标量上下文中（即，文件slurp模式），并且在读取空文件时，它第一次返回 &lt;code&gt;''&lt;/code&gt; ，随后是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7865066f4690dc076b5908415bb1b4ea7d2066d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, when &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">当 &lt;code&gt;$/&lt;/code&gt; 设置为 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 时，当 &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 在标量上下文中（即，文件slurp模式），并且在读取空文件时，它第一次返回 &lt;code&gt;''&lt;/code&gt; ，随后是 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a000e25ad164b5a4e8e6e794f33b40196ef9e9c8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$coderef&lt;/code&gt; is omitted or undefined, any existing callback will be removed and &lt;code&gt;decode&lt;/code&gt; will not change the deserialised hash in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5cdec40a0b802970de3c22418f7ef1894e05ac3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$coderef&lt;/code&gt; is specified, it will be called from &lt;code&gt;decode&lt;/code&gt; each time it decodes a JSON object. The only argument is a reference to the newly-created hash. If the code references returns a single scalar (which need not be a reference), this value (or rather a copy of it) is inserted into the deserialised data structure. If it returns an empty list (NOTE:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75765cbe47d6e2730ecd17d719657c6826993abb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple compressed files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer, after uncompression &lt;code&gt;$output_filename_or_reference&lt;/code&gt; will contain a concatenation of all the uncompressed data from each of the input files/buffers.</source>
          <target state="translated">当 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 映射到多个压缩文件/缓冲区并且 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是单个文件/缓冲区时，解压缩后 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 将包含来自每个输入文件/缓冲区的所有未压缩数据的串联。</target>
        </trans-unit>
        <trans-unit id="ead5ec1ebcf9002ff366c3f4b5ecf105bcef3b1c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer the input files/buffers will be stored in &lt;code&gt;$output_filename_or_reference&lt;/code&gt; as a concatenated series of compressed data streams.</source>
          <target state="translated">当 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 映射到多个文件/缓冲区，而 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是单个文件/缓冲区时，输入文件/缓冲区将作为一系列压缩数据流串联存储在 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="42c11e18ef09b7c84100ba9f7d909d637366a78e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer the input files/buffers will each be stored in &lt;code&gt;$output_filename_or_reference&lt;/code&gt; as a distinct entry.</source>
          <target state="translated">当 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 映射到多个文件/缓冲区，并且 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是单个文件/缓冲区时，输入文件/缓冲区将分别作为一个单独的条目存储在 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="161359b9eacea931dac1aa6e52278dc1eae64067" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is an fileglob string, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; must also be a fileglob string. Anything else is an error.</source>
          <target state="translated">当 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是fileglob字符串时， &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 也必须是fileglob字符串。其他所有都是错误。</target>
        </trans-unit>
        <trans-unit id="d2909a9438238d7274c21eee7293fc99c88b23e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, these options will be completely ignored. See &lt;a href=&quot;perlvar#%24%7B%5EUNICODE%7D&quot;&gt;&quot;&lt;code&gt;${^UNICODE}&lt;/code&gt;&quot; in perlvar&lt;/a&gt; and &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;&quot;&lt;code&gt;-C&lt;/code&gt;&quot; in perlrun&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2506bf0aaa0a66933521706c1367d6dcef56da1b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, these options will be completely ignored. See &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;${^UNICODE} in perlvar&lt;/a&gt; and &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C in perlrun&lt;/a&gt; for details.</source>
          <target state="translated">当 &lt;code&gt;${^UNICODE}&lt;/code&gt; （从v5.8.2开始可用）存在且不为零时，这些选项将被完全忽略。有关详细信息，请参见&lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;perlvar中的$ {^ UNICODE}&lt;/a&gt;和&lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;perlrun&lt;/a&gt;中的-C。</target>
        </trans-unit>
        <trans-unit id="b7dd1602a2fa020d33fb149e95e48b61aba92e31" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; and &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt; for details.</source>
          <target state="translated">当shell间接执行 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 的参数时，结果和返回码将受其怪癖的影响。有关详细信息，请参见&lt;a href=&quot;perlop#%60STRING%60&quot;&gt;perlop&lt;/a&gt;和&lt;a href=&quot;#exec&quot;&gt;exec中的&lt;/a&gt;`STRING`。</target>
        </trans-unit>
        <trans-unit id="ce37de4fd1569bb63f53c7c4c16cdb716157400b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (but not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; （但不 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ）有效时， &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; LIST根据当前的整理语言环境对 LIST进行排序。参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4b89dec84fb05fc282a0e80acf7739b8c5833a7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/flags'&lt;/code&gt; is specified, the given flags are automatically added to every regular expression till the end of the lexical scope.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/flags'&lt;/code&gt; 被指定时，给定的标志被自动添加到每一个正则表达式，直到词法作用域的末尾。</target>
        </trans-unit>
        <trans-unit id="826f4d022e4908a4bde930341263c135e67935f4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; is in effect, perl emits debugging messages when compiling and using regular expressions. The output is the same as that obtained by running a &lt;code&gt;-DDEBUGGING&lt;/code&gt; -enabled perl interpreter with the &lt;b&gt;-Dr&lt;/b&gt; switch. It may be quite voluminous depending on the complexity of the match. Using &lt;code&gt;debugcolor&lt;/code&gt; instead of &lt;code&gt;debug&lt;/code&gt; enables a form of output that can be used to get a colorful display on terminals that understand termcap color sequences. Set &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; to a comma-separated list of &lt;code&gt;termcap&lt;/code&gt; properties to use for highlighting strings on/off, pre-point part on/off. See &lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;Debugging Regular Expressions in perldebug&lt;/a&gt; for additional info.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; 有效时，perl在编译和使用正则表达式时会发出调试消息。输出与通过&lt;b&gt;-Dr&lt;/b&gt;开关运行启用 &lt;code&gt;-DDEBUGGING&lt;/code&gt; 的 perl解释器获得的输出相同。根据比赛的复杂程度，可能会非常庞大​​。使用 &lt;code&gt;debugcolor&lt;/code&gt; 代替 &lt;code&gt;debug&lt;/code&gt; 启用一种输出形式，该输出形式可用于在了解termcap颜色序列的终端上获得彩色显示。将 &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; 设置为 &lt;code&gt;termcap&lt;/code&gt; 属性的逗号分隔列表，以用于高亮显示字符串的开/关，指示部分的开/关。请参见&lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;在perldebug中调试正则表达式&lt;/a&gt;&lt;b&gt;&lt;/b&gt; 有关其他信息。</target>
        </trans-unit>
        <trans-unit id="6c428ad9961e409888285c5019a1884325617653" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; is in effect, a regexp is allowed to contain &lt;code&gt;(?{ ... })&lt;/code&gt; zero-width assertions and &lt;code&gt;(??{ ... })&lt;/code&gt; postponed subexpressions that are derived from variable interpolation, rather than appearing literally within the regexp. That is normally disallowed, since it is a potential security risk. Note that this pragma is ignored when the regular expression is obtained from tainted data, i.e. evaluation is always disallowed with tainted regular expressions. See &lt;a href=&quot;perlre#(%3f%7b-code-%7d)&quot;&gt;(?{ code }) in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#(%3f%3f%7b-code-%7d)&quot;&gt;(??{ code }) in perlre&lt;/a&gt;.</source>
          <target state="translated">有效 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; 正则表达式允许包含 &lt;code&gt;(?{ ... })&lt;/code&gt; 零宽度断言和 &lt;code&gt;(??{ ... })&lt;/code&gt; 从变量插值派生的延迟子表达式，而不是出现从字面上来看正则表达式。由于存在潜在的安全风险，因此通常不允许这样做。请注意，当从受污染的数据中获取正则表达式时，将忽略该杂项，即，始终禁止使用受污染的正则表达式进行评估。见&lt;a href=&quot;perlre#(%3f%7b-code-%7d)&quot;&gt;（{代码}）在perlre&lt;/a&gt;和&lt;a href=&quot;perlre#(%3f%3f%7b-code-%7d)&quot;&gt;（?? {代码}）在perlre&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c489bf5f6075f7a85a4147bc159e1965fa8ad2cd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; is in effect, stricter checks are applied than otherwise when compiling regular expressions patterns. These may cause more warnings to be raised than otherwise, and more things to be fatal instead of just warnings. The purpose of this is to find and report at compile time some things, which may be legal, but have a reasonable possibility of not being the programmer's actual intent. This automatically turns on the &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; warnings category (if not already on) within its scope.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; 生效时，与编译正则表达式模式时相比，将应用更严格的检查。这些可能导致发出更多警告，而不是其他警告，并且导致更多致命的事情。这样做的目的是在编译时查找并报告一些可能合法的东西，但是有可能不是程序员的实际意图。这会自动在其范围内打开 &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; 警告类别（如果尚未启用）。</target>
        </trans-unit>
        <trans-unit id="057f6216fa3faf81b159095b26d348ad7b06bd25" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'taint'&lt;/code&gt; is in effect, and a tainted string is the target of a regexp, the regexp memories (or values returned by the m// operator in list context) are tainted. This feature is useful when regexp operations on tainted data aren't meant to extract safe substrings, but to perform other transformations.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'taint'&lt;/code&gt; 有效时，且受污染的字符串是正则表达式的目标时，则将正则表达式内存（或m //运算符在列表上下文中返回的值）污染。当对受污染的数据进行正则表达式操作不是要提取安全子字符串，而是要执行其他转换时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="d35b2d737154679691874d190272f87d34f67d6b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; and &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; for details.</source>
          <target state="translated">当shell间接执行 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 的参数时，结果和返回码将受其怪癖的影响。有关详细信息，请参见&lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;perlop&lt;/a&gt;和&lt;a href=&quot;exec&quot;&gt;exec中的&lt;/a&gt;`STRING`。</target>
        </trans-unit>
        <trans-unit id="d249161b8d76a85447f9bcf8c19ecaa9c4041708" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (but not &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect, &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; （但不 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ）有效时， &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; LIST根据当前的整理语言环境对 LIST进行排序。参见&lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9cb0ac41f5c76b7790f54d079dd94b8ce0665510" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Append&lt;/code&gt; is specified, and set to true, it will</source>
          <target state="translated">当指定了 &lt;code&gt;Append&lt;/code&gt; 并将其设置为true时，它将</target>
        </trans-unit>
        <trans-unit id="74620e73df76b9793a4b5915498c084620ae1197" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutout&lt;/code&gt; is not specified &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; will use as much memory as it takes to write all the uncompressed data it creates by uncompressing the input buffer.</source>
          <target state="translated">当 &lt;code&gt;LimitOutout&lt;/code&gt; 没有指定 &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; 将尽可能多的内存，因为它需要所有通过解压缩的输入缓冲区写入其创建的未压缩数据使用。</target>
        </trans-unit>
        <trans-unit id="476db1003af9ea2b2d5dff0b4d9aae2335796a1b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutout&lt;/code&gt; is not specified &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; will use as much memory as it takes to write all the uncompressed data it creates by uncompressing the input buffer.</source>
          <target state="translated">当未指定 &lt;code&gt;LimitOutout&lt;/code&gt; 时, &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; inflate将使用尽可能多的内存来写入通过解压缩输入缓冲区而创建的所有未压缩数据。</target>
        </trans-unit>
        <trans-unit id="3a29eb1b7605b447e178aa583e1e3d0b18b3e32a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the 16k or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt; , whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="translated">当使用 &lt;code&gt;LimitOutput&lt;/code&gt; 时，使用的输出缓冲区的大小将为16k或已分配给 &lt;code&gt;$output&lt;/code&gt; 的内存量，以较大者为准。预测可用的输出大小非常棘手，因此不要依赖于获取确切的输出缓冲区大小。</target>
        </trans-unit>
        <trans-unit id="378bab7c46fb87434a4a31e87bab949c33fee48d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the 16k or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt;, whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6884e67243b247f9f83c1056f56446e2954b8717" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the value of the &lt;code&gt;Bufsize&lt;/code&gt; option or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt; , whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="translated">当使用 &lt;code&gt;LimitOutput&lt;/code&gt; 时，使用的输出缓冲区的大小将为 &lt;code&gt;Bufsize&lt;/code&gt; 选项的值或已分配给 &lt;code&gt;$output&lt;/code&gt; 的内存量（以较大者为准）。预测可用的输出大小非常棘手，因此不要依赖于获取确切的输出缓冲区大小。</target>
        </trans-unit>
        <trans-unit id="e109cef898586b284816d1d609f442757d09d9a8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the value of the &lt;code&gt;Bufsize&lt;/code&gt; option or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt;, whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3a312e83feddf95b646900a17ece38db487898" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; is active (see &lt;a href=&quot;#%24%3F&quot;&gt;&quot;$?&quot;&lt;/a&gt; below), the native VMS exit status value will have either one of the &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$^E&lt;/code&gt; or the Unix value 255 encoded into it in a way that the effective original value can be decoded by other programs written in C, including Perl and the GNV package. As per the normal non-VMS behavior of &lt;code&gt;die&lt;/code&gt; if either &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; are non-zero, one of those values will be encoded into a native VMS status value. If both of the Unix status values are 0, and the &lt;code&gt;$^E&lt;/code&gt; value is set one of ERROR or SEVERE_ERROR severity, then the &lt;code&gt;$^E&lt;/code&gt; value will be used as the exit code as is. If none of the above apply, the Unix value of 255 will be encoded into a native VMS exit status value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c4b51758778b88a3620755cd86e2bac9c6c0e5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; is active (see &lt;a href=&quot;#%24%3f&quot;&gt;$?&lt;/a&gt; below), the native VMS exit status value will have either one of the &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$^E&lt;/code&gt; or the Unix value 255 encoded into it in a way that the effective original value can be decoded by other programs written in C, including Perl and the GNV package. As per the normal non-VMS behavior of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; if either &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; are non-zero, one of those values will be encoded into a native VMS status value. If both of the Unix status values are 0, and the &lt;code&gt;$^E&lt;/code&gt; value is set one of ERROR or SEVERE_ERROR severity, then the &lt;code&gt;$^E&lt;/code&gt; value will be used as the exit code as is. If none of the above apply, the Unix value of 255 will be encoded into a native VMS exit status value.</source>
          <target state="translated">当 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 处于活动状态时（请参见下面的&lt;a href=&quot;#%24%3f&quot;&gt;$？&lt;/a&gt;），本机VMS退出状态值将具有 &lt;code&gt;$!&lt;/code&gt; 或 &lt;code&gt;$?&lt;/code&gt; 或 &lt;code&gt;$^E&lt;/code&gt; 或其中编码的Unix值255，以便有效的原始值可以用用C编写的其他程序（包括Perl和GNV包）进行解码。按照正常的非VMS行为，如果 &lt;code&gt;$!&lt;/code&gt; 要么 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ！或 &lt;code&gt;$?&lt;/code&gt; 如果为非零值，则这些值之一将被编码为本地VMS状态值。如果两个Unix状态值都为0，并且 &lt;code&gt;$^E&lt;/code&gt; 值设置为ERROR或SEVERE_ERROR严重性之一，则 &lt;code&gt;$^E&lt;/code&gt; 值将直接用作退出代码。如果上述都不适用，则Unix值255将被编码为本地VMS退出状态值。</target>
        </trans-unit>
        <trans-unit id="edf0ae2377a2b22abb92a09c7cbee6dad38f469d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;S&lt;/code&gt; can match, it is a better match than when only &lt;code&gt;T&lt;/code&gt; can match.</source>
          <target state="translated">当 &lt;code&gt;S&lt;/code&gt; 可以匹配时，比仅 &lt;code&gt;T&lt;/code&gt; 可以匹配时更好。</target>
        </trans-unit>
        <trans-unit id="5e7bb6aa4bca28bb16c16381fd1ea0fe317f098c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Strict&lt;/code&gt; is disabled the following behaviour will be policed:</source>
          <target state="translated">当 &lt;code&gt;Strict&lt;/code&gt; 禁止以下行为将进行监管：</target>
        </trans-unit>
        <trans-unit id="db687c97fb2b33423a8768bd320e4711c5ad7257" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Time::Local&lt;/code&gt; was first written, it was a common practice to represent years as a two-digit value like &lt;code&gt;99&lt;/code&gt; for &lt;code&gt;1999&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;2001&lt;/code&gt;. This caused all sorts of problems (google &quot;Y2K problem&quot; if you're very young) and developers eventually realized that this was a terrible idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792e600779793d69f3a4dfa3dfa3dd30d40ce8a4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt;= 22, the weights of out-of-range values can be overridden. Though &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; are available for them, out-of-range values are too many.</source>
          <target state="translated">当 &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; = 22时，超出范围值的权重可以被覆盖。尽管可以使用 &lt;code&gt;table&lt;/code&gt; 或 &lt;code&gt;entry&lt;/code&gt; ，但超出范围的值太多。</target>
        </trans-unit>
        <trans-unit id="a8376390a3e85be3e6ac52a52161522985c10ab7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;allow_bignum&lt;/code&gt; is enabled, big integer values and any numeric values will be converted into &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; and &lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt; objects respectively, without becoming string scalars or losing precision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88bdc0c0c759d08c6275afc07854842d8f95efa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;base&lt;/code&gt; tries to &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module, it will not die if it cannot find the module's file, but will die on any other error. After all this, should your base class be empty, containing no symbols, &lt;code&gt;base&lt;/code&gt; will die. This is useful for inheriting from classes in the same file as yourself but where the filename does not match the base module name, like so:</source>
          <target state="translated">当 &lt;code&gt;base&lt;/code&gt; 试图 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 一个模块时，如果找不到模块的文件，它将不会死亡，但是会因其他任何错误而死亡。毕竟，如果您的基类为空，不包含任何符号，则 &lt;code&gt;base&lt;/code&gt; 将消失。这对于从与您自己位于同一文件中但文件名与基本模块名称不匹配的类进行继承很有用，例如：</target>
        </trans-unit>
        <trans-unit id="7e10e7af3fdfd7341808494145f96d758dfe5848" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;base&lt;/code&gt; tries to &lt;code&gt;require&lt;/code&gt; a module, it will not die if it cannot find the module's file, but will die on any other error. After all this, should your base class be empty, containing no symbols, &lt;code&gt;base&lt;/code&gt; will die. This is useful for inheriting from classes in the same file as yourself but where the filename does not match the base module name, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1801ac03d31183f16ba294ce4fa7c937f1f41d11" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;dynamic_config&lt;/code&gt; is true, it is an error to presume that the prerequisites given in distribution metadata will have any relationship whatsoever to the actual prerequisites of the distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3f15dbf4bfac8ce422e1183a7c97c2a550a0582" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; are in effect, there is also a &lt;code&gt;$File::Find::fullname&lt;/code&gt; . The function may set &lt;code&gt;$File::Find::prune&lt;/code&gt; to prune the tree unless &lt;code&gt;bydepth&lt;/code&gt; was specified. Unless &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; is specified, for compatibility reasons (find.pl, find2perl) there are in addition the following globals available: &lt;code&gt;$File::Find::topdir&lt;/code&gt; , &lt;code&gt;$File::Find::topdev&lt;/code&gt; , &lt;code&gt;$File::Find::topino&lt;/code&gt; , &lt;code&gt;$File::Find::topmode&lt;/code&gt; and &lt;code&gt;$File::Find::topnlink&lt;/code&gt; .</source>
          <target state="translated">当 &lt;code&gt;follow&lt;/code&gt; 或 &lt;code&gt;follow_fast&lt;/code&gt; 生效时，还有一个 &lt;code&gt;$File::Find::fullname&lt;/code&gt; 。该函数可以设置 &lt;code&gt;$File::Find::prune&lt;/code&gt; 来修剪树，除非指定了 &lt;code&gt;bydepth&lt;/code&gt; 。除非指定了 &lt;code&gt;follow&lt;/code&gt; 或 &lt;code&gt;follow_fast&lt;/code&gt; ，否则出于兼容性原因（find.pl，find2perl），还可以使用以下全局变量： &lt;code&gt;$File::Find::topdir&lt;/code&gt; ， &lt;code&gt;$File::Find::topdev&lt;/code&gt; ， &lt;code&gt;$File::Find::topino&lt;/code&gt; ， &lt;code&gt;$File::Find::topmode&lt;/code&gt; 和 &lt;code&gt;$File::Find::topnlink&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e21f0f2ae6a786fecac14190bdb286ef45b2801" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; are in effect, there is also a &lt;code&gt;$File::Find::fullname&lt;/code&gt;. The function may set &lt;code&gt;$File::Find::prune&lt;/code&gt; to prune the tree unless &lt;code&gt;bydepth&lt;/code&gt; was specified. Unless &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; is specified, for compatibility reasons (find.pl, find2perl) there are in addition the following globals available: &lt;code&gt;$File::Find::topdir&lt;/code&gt;, &lt;code&gt;$File::Find::topdev&lt;/code&gt;, &lt;code&gt;$File::Find::topino&lt;/code&gt;, &lt;code&gt;$File::Find::topmode&lt;/code&gt; and &lt;code&gt;$File::Find::topnlink&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3af0ccfdbd0226b2c1c6a386ea7d1149b898de" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;get_handle&lt;/code&gt; is called with an empty parameter list, magic happens:</source>
          <target state="translated">当使用空参数列表调用 &lt;code&gt;get_handle&lt;/code&gt; 时，会发生魔术：</target>
        </trans-unit>
        <trans-unit id="0587cd71d3cd406da1e34d9f0121a501c139389a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;remove_tree&lt;/code&gt; returned from deleting files in a child directory, a check revealed that the parent directory it returned to wasn't the one it started out from. This is considered a sign of malicious activity.</source>
          <target state="translated">当 &lt;code&gt;remove_tree&lt;/code&gt; 从删除子目录中的文件中返回时，检查发现它返回的父目录不是从其开始的目录。这被认为是恶意活动的标志。</target>
        </trans-unit>
        <trans-unit id="0abaa039dcd0b20cc37827ce7e9a425281864469" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;share&lt;/code&gt; is used on arrays, hashes, array refs or hash refs, any data they contain will be lost.</source>
          <target state="translated">当在数组，哈希，数组引用或哈希引用上使用 &lt;code&gt;share&lt;/code&gt; 时，它们包含的任何数据都会丢失。</target>
        </trans-unit>
        <trans-unit id="f072734b6ff55766546071395774e151a8cea193" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;test_test&lt;/code&gt; is called and the output that your tests generate does not match that which you declared, &lt;code&gt;test_test&lt;/code&gt; will print out debug information showing the two conflicting versions. As this output itself is debug information it can be confusing which part of the output is from &lt;code&gt;test_test&lt;/code&gt; and which was the original output from your original tests. Also, it may be hard to spot things like extraneous whitespace at the end of lines that may cause your test to fail even though the output looks similar.</source>
          <target state="translated">当 &lt;code&gt;test_test&lt;/code&gt; 且测试生成的输出与声明的输出不匹配时， &lt;code&gt;test_test&lt;/code&gt; 将打印出调试信息，显示两个冲突的版本。由于此输出本身是调试信息，因此可能会混淆输出的哪一部分来自 &lt;code&gt;test_test&lt;/code&gt; ,以及哪一部分是原始测试的原始输出。另外，即使输出看起来相似，也很难在行尾发现类似多余的空格之类的东西，这可能会导致测试失败。</target>
        </trans-unit>
        <trans-unit id="100cf02e094db7d3754b0f2bd62e72f796e0a652" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re '/&lt;i&gt;flags&lt;/i&gt;'&lt;/code&gt; is specified, the given</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e437612ab773128746c34ed5e2418f0d2432e87" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'debug'&lt;/code&gt; is in effect, perl emits debugging messages when compiling and using regular expressions. The output is the same as that obtained by running a &lt;code&gt;-DDEBUGGING&lt;/code&gt;-enabled perl interpreter with the &lt;b&gt;-Dr&lt;/b&gt; switch. It may be quite voluminous depending on the complexity of the match. Using &lt;code&gt;debugcolor&lt;/code&gt; instead of &lt;code&gt;debug&lt;/code&gt; enables a form of output that can be used to get a colorful display on terminals that understand termcap color sequences. Set &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; to a comma-separated list of &lt;code&gt;termcap&lt;/code&gt; properties to use for highlighting strings on/off, pre-point part on/off. See &lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;&quot;Debugging Regular Expressions&quot; in perldebug&lt;/a&gt; for additional info.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffdd2a4a70c97e6482142a6afb44a0c24ab7f2c4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'eval'&lt;/code&gt; is in effect, a regexp is allowed to contain &lt;code&gt;(?{ ... })&lt;/code&gt; zero-width assertions and &lt;code&gt;(??{ ... })&lt;/code&gt; postponed subexpressions that are derived from variable interpolation, rather than appearing literally within the regexp. That is normally disallowed, since it is a potential security risk. Note that this pragma is ignored when the regular expression is obtained from tainted data, i.e. evaluation is always disallowed with tainted regular expressions. See &lt;a href=&quot;perlre#%28%3F%7B-code-%7D%29&quot;&gt;&quot;(?{ code })&quot; in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#%28%3F%3F%7B-code-%7D%29&quot;&gt;&quot;(??{ code })&quot; in perlre&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d8ac1a2fdcf9c532880e4f21577de40d0e705a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'strict'&lt;/code&gt; is in effect, stricter checks are applied than otherwise when compiling regular expressions patterns. These may cause more warnings to be raised than otherwise, and more things to be fatal instead of just warnings. The purpose of this is to find and report at compile time some things, which may be legal, but have a reasonable possibility of not being the programmer's actual intent. This automatically turns on the &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; warnings category (if not already on) within its scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d597df9736b57e5c279970bfb89c7002422580" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'taint'&lt;/code&gt; is in effect, and a tainted string is the target of a regexp, the regexp memories (or values returned by the m// operator in list context) are tainted. This feature is useful when regexp operations on tainted data aren't meant to extract safe substrings, but to perform other transformations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea81caddf6f1e1e3901216d09988417e561f49ac" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;utf8&lt;/code&gt; is disabled (the default), then &lt;code&gt;encode&lt;/code&gt;/&lt;code&gt;decode&lt;/code&gt; generate and expect Unicode strings, that is, characters with high ordinal Unicode values (&amp;gt; 255) will be encoded as such characters, and likewise such characters are decoded as-is, no changes to them will be done, except &quot;(re-)interpreting&quot; them as Unicode codepoints or Unicode characters, respectively (to Perl, these are the same thing in strings unless you do funny/weird/dumb stuff).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a8ac650ec538c50bdeb4cf6dbd53747bc753f1f" translate="yes" xml:space="preserve">
          <source>When BE or LE is explicitly stated as the name of encoding, BOM is simply treated as a normal character (ZERO WIDTH NO-BREAK SPACE).</source>
          <target state="translated">当BE或LE被明确表示为编码名称时,BOM被简单地视为普通字符(ZERO WIDTH NO-BREAK SPACE)。</target>
        </trans-unit>
        <trans-unit id="68ea7ed2b7146d8c990e48756af545235a644f6f" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during decode(), it checks if BOM is at the beginning of the string; if one is found, the endianness is set to what the BOM says.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fbaed27da231d1d0f199bebcb75bb30dedc0240" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during decode(), it checks if BOM is at the beginning of the string; if one is found, the endianness is set to what the BOM says. If no BOM is found, the routine dies.</source>
          <target state="translated">当在decode()过程中省略BE或LE时,它会检查BOM是否在字符串的开头;如果找到了,则将endianness设置为BOM所说的内容。如果没有发现BOM,则该例程死亡。</target>
        </trans-unit>
        <trans-unit id="420dd2e0afe91753dba538ca831997f9f3a56a48" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during encode(), it returns a BE-encoded string with BOM prepended. So when you want to encode a whole text file, make sure you encode() the whole text at once, not line by line or each line, not file, will have a BOM prepended.</source>
          <target state="translated">当在encode()过程中省略BE或LE时,它返回的是一个BE编码的字符串,前面有BOM。所以,当你想对整个文本文件进行编码时,请确保你一次编码()整个文本,而不是逐行编码,否则每一行,而不是文件,都会有一个BOM预注。</target>
        </trans-unit>
        <trans-unit id="dacba9cd09b7954f0b607de2124d67d55cdeb2ac" translate="yes" xml:space="preserve">
          <source>When CPAN runs, it sets the environment variable PERL5_CPAN_IS_RUNNING to the ID of the running process. It also sets PERL5_CPANPLUS_IS_RUNNING to prevent runaway processes which could happen with older versions of Module::Install.</source>
          <target state="translated">当CPAN运行时,它会将环境变量PERL5_CPAN_IS_RUNNING设置为运行进程的ID。它还设置PERL5_CPANPLUS_IS_RUNNING来防止失控进程,因为旧版本的Module::Install可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="652978d2789dfa7c2e88ae3ead48735cc4a8b7e9" translate="yes" xml:space="preserve">
          <source>When CPAN.pm extends @INC via PERL5LIB, it prints a list of directories added (or a summary of how many directories are added). Choose 'v' to get this message, 'none' to suppress it.</source>
          <target state="translated">当 CPAN.pm 通过 PERL5LIB 扩展 @INC 时,它会打印出一个添加的目录列表 (或者是添加了多少个目录的摘要)。选择'v'来获取这个消息,选择'none'来抑制它。</target>
        </trans-unit>
        <trans-unit id="ec2c74f66c6e4b429c5d3bf449f05522f381cd48" translate="yes" xml:space="preserve">
          <source>When CPAN.pm loads a module it needs for some optional feature, it usually reports about module name and version. Choose 'v' to get this message, 'none' to suppress it.</source>
          <target state="translated">当CPAN.pm加载一个它需要的模块时,它通常会报告模块的名称和版本。选择'v'可以得到这个消息,选择'none'可以抑制它。</target>
        </trans-unit>
        <trans-unit id="a6c2efe210167d6d16736590efab450901a5223c" translate="yes" xml:space="preserve">
          <source>When CPAN.pm uses the tar command, which switch for the verbosity shall be used? Choose 'none' for quiet operation, 'v' for file name listing, 'vv' for full listing.</source>
          <target state="translated">当CPAN.pm使用tar命令时,应使用哪一个开关来控制verbosity?选择'none'表示安静操作,选择'v'表示文件名列表,选择'vv'表示完全列表。</target>
        </trans-unit>
        <trans-unit id="09926237f4d026fd4275fa85769eac33da9c9434" translate="yes" xml:space="preserve">
          <source>When Configure asks about the extensions, I suggest IO and Fcntl, and if you want database handling then SDBM_File or GDBM_File (you need to install gdbm for this one). If you want to use the POSIX extension (this is the default), make sure that the stack size of your</source>
          <target state="translated">当Configure问及扩展时,我建议使用IO和Fcntl,如果你想要数据库处理,那么就使用SDBM_File或GDBM_File(这个需要安装gdbm)。如果你想使用POSIX扩展(这是默认的),确保你的堆栈大小在你的</target>
        </trans-unit>
        <trans-unit id="04e0b7cf71399471be99cb867416364c0df9f40e" translate="yes" xml:space="preserve">
          <source>When Democritus gave the word &amp;ldquo;atom&amp;rdquo; to the indivisible bits of matter, he meant literally something that could not be cut:</source>
          <target state="translated">当德cri克利特斯给不可分割的物质赋予&amp;ldquo;原子&amp;rdquo;一词时，他的意思是无法切割的东西：</target>
        </trans-unit>
        <trans-unit id="bed16fa39ff4d380815a5a95de03029e7764deee" translate="yes" xml:space="preserve">
          <source>When G_KEEPERR is used, any error in the called code will terminate the call as usual, and the error will not propagate beyond the call (as usual for G_EVAL), but it will not go into &lt;code&gt;$@&lt;/code&gt; . Instead the error will be converted into a warning, prefixed with the string &quot;\t(in cleanup)&quot;. This can be disabled using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'misc'&lt;/code&gt; . If there is no error, &lt;code&gt;$@&lt;/code&gt; will not be cleared.</source>
          <target state="translated">当使用G_KEEPERR时，被调用代码中的任何错误将照常终止该调用，并且该错误不会传播到整个调用之外（与G_EVAL一样），但不会进入 &lt;code&gt;$@&lt;/code&gt; 。而是将错误转换为警告，并以字符串&amp;ldquo; \ t（in cleanup）&amp;rdquo;为前缀。可以使用 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'misc'&lt;/code&gt; 禁用此功能。如果没有错误，则不会清除 &lt;code&gt;$@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd0879b5780d10481d395ff78c94006ad9de4758" translate="yes" xml:space="preserve">
          <source>When G_KEEPERR is used, any error in the called code will terminate the call as usual, and the error will not propagate beyond the call (as usual for G_EVAL), but it will not go into &lt;code&gt;$@&lt;/code&gt;. Instead the error will be converted into a warning, prefixed with the string &quot;\t(in cleanup)&quot;. This can be disabled using &lt;code&gt;no warnings 'misc'&lt;/code&gt;. If there is no error, &lt;code&gt;$@&lt;/code&gt; will not be cleared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6cefe86149d167c60485e01ab068ab4acc1c96d" translate="yes" xml:space="preserve">
          <source>When I install bundles or multiple modules with one command there is too much output to keep track of.</source>
          <target state="translated">当我用一个命令安装捆绑包或多个模块时,有太多的输出,无法跟踪。</target>
        </trans-unit>
        <trans-unit id="96aa2dd484c673b89bb47260df9f770fc3e65459" translate="yes" xml:space="preserve">
          <source>When I run CPAN's shell, I get an error message about things in my &lt;code&gt;/etc/inputrc&lt;/code&gt; (or &lt;code&gt;~/.inputrc&lt;/code&gt;) file.</source>
          <target state="translated">当我运行CPAN的外壳程序时，我在 &lt;code&gt;/etc/inputrc&lt;/code&gt; （或 &lt;code&gt;~/.inputrc&lt;/code&gt; ）文件中收到有关事情的错误消息。</target>
        </trans-unit>
        <trans-unit id="cc4c433cebf4d4f4606a91e341dbbd967898b31d" translate="yes" xml:space="preserve">
          <source>When I run my tests TAP::Harness creates a scheduler (TAP::Parser::Scheduler) to work out the running order for the tests, an aggregator (TAP::Parser::Aggregator) to collect and analyse the test results and a formatter (TAP::Formatter::Console) to display those results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712f9e473dcc2ba74a4ec66b73d3e2f5bccede0e" translate="yes" xml:space="preserve">
          <source>When I run prove it processes its arguments, figures out which test scripts to run and then passes control to TAP::Harness to run the tests, parse, analyse and present the results. By subclassing TAP::Harness I can customise many aspects of the test run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1064c03f1fc4073f4165a39d84f0e0127c6dd155" translate="yes" xml:space="preserve">
          <source>When I tell prove to save state it writes a file called '.prove' ('_prove' on Windows) in the current directory. It's a YAML document so it's quite easy to write tools of your own that work on the saved test state - but the format isn't officially documented so it might change without (much) warning in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b21be97219bbbb10df79f70e49405f833c3cad4" translate="yes" xml:space="preserve">
          <source>When I tried to run my script, I got this message. What does it mean?</source>
          <target state="translated">当我试图运行我的脚本时,我得到了这个消息。这是什么意思?</target>
        </trans-unit>
        <trans-unit id="e4bb48e8ad735dfd3ed959c0444d6089c891d679" translate="yes" xml:space="preserve">
          <source>When I/O, for example &quot;read&quot;, is requested, the request goes from Perl first down the stack using &quot;read&quot; functions of each layer, then at the bottom the input is requested from the operating system services, then the result is returned up the stack, finally being interpreted as Perl data.</source>
          <target state="translated">当请求I/O时,例如 &quot;读&quot;,请求从Perl先用各层的 &quot;读 &quot;函数向下堆栈,然后在最底层向操作系统服务请求输入,再将结果向上堆栈返回,最后被解释为Perl数据。</target>
        </trans-unit>
        <trans-unit id="e5e8467b062c382be485cbe69584b5d02adf0299" translate="yes" xml:space="preserve">
          <source>When Memoize needs to check to see if an entry is in the cache already, it will invoke &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt; . &lt;code&gt;key&lt;/code&gt; is the normalized function argument. MyExpirePolicy::EXISTS should return 0 if the key is not in the cache, or if it has expired, and 1 if an unexpired value is in the cache. It should</source>
          <target state="translated">当Memoize需要检查条目是否已在缓存中时，它将调用 &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt; 。 &lt;code&gt;key&lt;/code&gt; 是归一化函数参数。如果密钥不在高速缓存中或密钥已经过期，则MyExpirePolicy :: EXISTS应该返回0；如果高速缓存中没有未过期的值，则返回1。这应该</target>
        </trans-unit>
        <trans-unit id="de4b7c34cbf176c69c5c8a01cb2f47a2ef49c9de" translate="yes" xml:space="preserve">
          <source>When Memoize needs to check to see if an entry is in the cache already, it will invoke &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt;. &lt;code&gt;key&lt;/code&gt; is the normalized function argument. MyExpirePolicy::EXISTS should return 0 if the key is not in the cache, or if it has expired, and 1 if an unexpired value is in the cache. It should</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd887c91b9049b8dfb0bd1e032eea2b43f90690" translate="yes" xml:space="preserve">
          <source>When Perl 5.12 or later encounters an ellipsis statement, it parses this without error, but if and when you should actually try to execute it, Perl throws an exception with the text &lt;code&gt;Unimplemented&lt;/code&gt; :</source>
          <target state="translated">当Perl 5.12或更高版本遇到省略号语句时，它会解析此语句而不会出错，但是如果并且当您实际尝试执行它时，Perl会抛出一个带有文本 &lt;code&gt;Unimplemented&lt;/code&gt; 的异常：</target>
        </trans-unit>
        <trans-unit id="5b63aa2881910e0e5509ac7fb04463269b672b02" translate="yes" xml:space="preserve">
          <source>When Perl 5.6.0 was released, the decision was made to provide a transformation between the old-style decimal versions and new-style dotted-decimal versions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab4ce43e1ebabd776abd8a74c5e1d002b8bd8ffe" translate="yes" xml:space="preserve">
          <source>When Perl compiles the regular expression, it treats the parenthesis as the start of a memory match. When it doesn't find the closing parenthesis, it complains:</source>
          <target state="translated">当 Perl 编译正则表达式时,它将小括号视为内存匹配的开始。当它没有找到最后的小括号时,它就会抱怨。</target>
        </trans-unit>
        <trans-unit id="53c411ad4e1523024c43c3f84e8d99bfb2921a55" translate="yes" xml:space="preserve">
          <source>When Perl destroys the object referenced by $netconf it will send the object to the supplied XSUB DESTROY function. Perl cannot determine, and does not care, that this object is a C struct and not a Perl object. In this sense, there is no difference between the object created by the getnetconfigent() XSUB and an object created by a normal Perl subroutine.</source>
          <target state="translated">当Perl销毁$netconf引用的对象时,它将把这个对象发送到提供的XSUB DESTROY函数中。Perl无法确定,也不关心这个对象是C结构而不是Perl对象。在这个意义上,getnetconfigent()XSUB 创建的对象和普通 Perl 子程序创建的对象没有区别。</target>
        </trans-unit>
        <trans-unit id="954a1b48bf7dbf510303237ceeb967daf1def196" translate="yes" xml:space="preserve">
          <source>When Perl encounters a wildcard subpattern, (see &lt;a href=&quot;perlunicode#Wildcards-in-Property-Values&quot;&gt;&quot;Wildcards in Property Values&quot; in perlunicode&lt;/a&gt;), it suspends compilation of the main pattern, compiles the subpattern, and then matches that against all legal possibilities to determine the actual code points the subpattern matches. After that it adds these to the main pattern, and continues its compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e513aa6b4ab015986cab17c857cc3e0082b263e5" translate="yes" xml:space="preserve">
          <source>When Perl exchanges data with an extension, the extension should be able to understand the UTF8 flag and act accordingly. If the extension doesn't recognize that flag, it's likely that the extension will return incorrectly-flagged data.</source>
          <target state="translated">当Perl与扩展进行数据交换时,扩展应该能够理解UTF8标志并采取相应的行动。如果扩展不能识别该标志,那么扩展很可能会返回错误的标志数据。</target>
        </trans-unit>
        <trans-unit id="4850373be99ff07c49bae45c8a4c6f5b91630080" translate="yes" xml:space="preserve">
          <source>When Perl is being run under a Unix shell on OpenVMS, the defaults at a future time may be more appropriate for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f1776d7dcd16bb2da8426867ab48b032eaee97" translate="yes" xml:space="preserve">
          <source>When Perl is built with PERL_IMPLICIT_CONTEXT, extensions that call any functions in the Perl API will need to pass the initial context argument somehow. The kicker is that you will need to write it in such a way that the extension still compiles when Perl hasn't been built with PERL_IMPLICIT_CONTEXT enabled.</source>
          <target state="translated">当 Perl 以 PERL_IMPLICIT_CONTEXT 构建时,调用 Perl API 中任何函数的扩展都需要以某种方式传递初始上下文参数。更重要的是,你需要以这样的方式来编写它,以便在没有启用 PERL_IMPLICIT_CONTEXT 的情况下,扩展仍然能够编译。</target>
        </trans-unit>
        <trans-unit id="f6fb72d35777e36edb4c8c03f40429a73f9b258a" translate="yes" xml:space="preserve">
          <source>When Perl is built without options that set PERL_IMPLICIT_CONTEXT, there is no first argument containing the interpreter's context. The trailing underscore in the pTHX_ macro indicates that the macro expansion needs a comma after the context argument because other arguments follow it. If PERL_IMPLICIT_CONTEXT is not defined, pTHX_ will be ignored, and the subroutine is not prototyped to take the extra argument. The form of the macro without the trailing underscore is used when there are no additional explicit arguments.</source>
          <target state="translated">当Perl在构建时没有设置PERL_IMPLICIT_CONTEXT的选项时,没有包含解释器上下文的第一个参数。pTHX_宏中尾部的下划线表示宏的扩展需要在上下文参数后面加上逗号,因为其他参数都在后面。如果没有定义PERL_IMPLICIT_CONTEXT,那么pTHX_将被忽略,而且子程序也没有原型来接受额外的参数。当没有额外的显式参数时,会使用没有尾部下划线的宏的形式。</target>
        </trans-unit>
        <trans-unit id="8079f54267f5c6445383e49837ffc5d08d1d7078" translate="yes" xml:space="preserve">
          <source>When Perl is compiled for a platform, it looks at all of these characters to guess which EBCDIC character set the platform uses, and adapts itself accordingly to that platform. If the platform uses a character set that is not one of the three Perl knows about, Perl will either fail to compile, or mistakenly and silently choose one of the three.</source>
          <target state="translated">当Perl为某个平台编译时,它会查看所有这些字符,以猜测该平台使用的是哪种EBCDIC字符集,并据此使自己适应该平台。如果平台使用的字符集不是Perl知道的三种字符集之一,Perl就会编译失败,或者错误地默默地选择三种字符中的一种。</target>
        </trans-unit>
        <trans-unit id="80ed2279b39397e0ed205899926800b606fe0a42" translate="yes" xml:space="preserve">
          <source>When Perl is configured to use ithreads, it will use re-entrant library calls in preference to non-re-entrant versions. There is an incompatibility in OpenBSD's &lt;code&gt;getprotobyname_r&lt;/code&gt; and &lt;code&gt;getservbyname_r&lt;/code&gt; function in versions 3.7 and later that will cause a SEGV when called without doing a &lt;code&gt;bzero&lt;/code&gt; on their return structs prior to calling these functions. Current Perl's should handle this problem correctly. Older threaded Perls (5.8.6 or earlier) will run into this problem. If you want to run a threaded Perl on OpenBSD 3.7 or higher, you will need to upgrade to at least Perl 5.8.7.</source>
          <target state="translated">当Perl配置为使用ithreads时，它将优先使用非可重入版本的可重入库调用。 OpenBSD的3.7版及更高版本中的 &lt;code&gt;getprotobyname_r&lt;/code&gt; 和 &lt;code&gt;getservbyname_r&lt;/code&gt; 函数不兼容，这在调用这些函数之前在不对其返回结构执行 &lt;code&gt;bzero&lt;/code&gt; 的情况下调用时会导致SEGV 。当前的Perl应该可以正确处理此问题。较旧的线程Perls（5.8.6或更早版本）将遇到此问题。如果要在OpenBSD 3.7或更高版本上运行线程化的Perl，则需要至少升级到Perl 5.8.7。</target>
        </trans-unit>
        <trans-unit id="df300d221e04eb6da687f72d9bfb0bebe32d3fc0" translate="yes" xml:space="preserve">
          <source>When Perl is processing &quot;binary data&quot;, the programmer wants Perl to process &quot;sequences of bytes&quot;. This is not a problem for Perl: because a byte has 256 possible values, it easily fits in Perl's much larger &quot;logical character&quot;.</source>
          <target state="translated">当Perl处理 &quot;二进制数据 &quot;时,程序员希望Perl处理 &quot;字节序列&quot;。这对Perl来说并不是问题:因为一个字节有256种可能的值,所以它很容易适合Perl大得多的 &quot;逻辑字符&quot;。</target>
        </trans-unit>
        <trans-unit id="317f1e48aa507068045f8759d8c8badef1389fb8" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this GV contains the SV which holds the name of the sub being debugged. This is the C variable which corresponds to Perl's $DB::sub variable. See &lt;code&gt;&lt;a href=&quot;#PL_DBsingle&quot;&gt;&quot;PL_DBsingle&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc51149dee007d3915d8fd89443c351da938e4a2" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this GV contains the SV which holds the name of the sub being debugged. This is the C variable which corresponds to Perl's $DB::sub variable. See &lt;code&gt;PL_DBsingle&lt;/code&gt; .</source>
          <target state="translated">当Perl在调试模式下使用&lt;b&gt;-d&lt;/b&gt;开关运行时，此GV包含SV，该SV包含要调试的子程序的名称。这是C变量，它对应于Perl的$ DB :: sub变量。参见 &lt;code&gt;PL_DBsingle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a3d6fd090f13b8b7228c62f6dd0eea36d1d1e84" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this SV is a boolean which indicates whether subs are being single-stepped. Single-stepping is automatically turned on after every step. This is the C variable which corresponds to Perl's $DB::single variable. See &lt;code&gt;&lt;a href=&quot;#PL_DBsub&quot;&gt;&quot;PL_DBsub&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3590f13940a356a00f485512d64c10323ed9ae31" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this SV is a boolean which indicates whether subs are being single-stepped. Single-stepping is automatically turned on after every step. This is the C variable which corresponds to Perl's $DB::single variable. See &lt;code&gt;PL_DBsub&lt;/code&gt; .</source>
          <target state="translated">当Perl在调试模式下使用&lt;b&gt;-d&lt;/b&gt;开关运行时，此SV是一个布尔值，指示子程序是否为单步执行。每一步后单步自动打开。这是C变量，它对应于Perl的$ DB :: single变量。参见 &lt;code&gt;PL_DBsub&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="987fa57f3d6e2d1a009a00d587b9bac8f003a80c" translate="yes" xml:space="preserve">
          <source>When Perl is run with the &lt;b&gt;-Do&lt;/b&gt; switch or its equivalent, overloading induces diagnostic messages.</source>
          <target state="translated">当使用&lt;b&gt;-Do&lt;/b&gt;开关或等效开关运行Perl时，过载会产生诊断消息。</target>
        </trans-unit>
        <trans-unit id="0c8a95fea35938379cf32ffa88d674c595c3842a" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system with &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; enabled, a wild card directory name of &lt;code&gt;[...]&lt;/code&gt; cannot be translated to a valid Unix file specification. Also, directory file specifications will have their implied &quot;.dir;1&quot; removed, and a trailing &lt;code&gt;.&lt;/code&gt; character indicating a null extension will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba82f7be76137263de4d2fc5ab0c4a2f7bd88ccf" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system, if the &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; feature is enabled, this implies that the Unix pathname cannot have a version, and that a path consisting of three dots, &lt;code&gt;./.../&lt;/code&gt;, will be converted to &lt;code&gt;[.^.^.^.]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="180489f22e9451652052bb264b159682d8729956" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system, if the &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; feature is not enabled, extra dots in the file specification will be converted to underscore characters, and the &lt;code&gt;?&lt;/code&gt; character will be converted to a &lt;code&gt;%&lt;/code&gt; character, if a conversion is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207a022d8cbd197e2ed92d3189e5fa31c10891e3" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system, the following &lt;code&gt;DECC$&lt;/code&gt; feature settings will control how the filename is converted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b65aa4a8ccdb59770227d57464bc9d968a6a6c" translate="yes" xml:space="preserve">
          <source>When Perl searches for a method, it caches the lookup so that future calls to the method do not need to search for it again. Changing a class's parent class or adding subroutines to a class will invalidate the cache for that class.</source>
          <target state="translated">当Perl搜索一个方法时,它会缓存查找,这样以后对该方法的调用就不需要再次搜索了。改变一个类的父类或在一个类中添加子程序会使该类的缓存无效。</target>
        </trans-unit>
        <trans-unit id="dc44d70cd8e2f4c150d9b1a250549091ec350dff" translate="yes" xml:space="preserve">
          <source>When Perl sees a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; extension;&lt;/code&gt; , it searches for a file with the same name as the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;'d extension that has a .pm suffix. If that file cannot be found, Perl dies with a fatal error. The default search path is contained in the &lt;code&gt;@INC&lt;/code&gt; array.</source>
          <target state="translated">当Perl看到 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; extension;&lt;/code&gt; ，它将搜索具有相同名称的文件 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 具有的.pm后缀&amp;ldquo;d延伸。如果找不到该文件，则Perl死于致命错误。默认搜索路径包含在 &lt;code&gt;@INC&lt;/code&gt; 数组中。</target>
        </trans-unit>
        <trans-unit id="8000e169764f8e2a593f5f0dac76f4976f5abd8f" translate="yes" xml:space="preserve">
          <source>When Perl sees a &lt;code&gt;use extension;&lt;/code&gt;, it searches for a file with the same name as the &lt;code&gt;use&lt;/code&gt;'d extension that has a .pm suffix. If that file cannot be found, Perl dies with a fatal error. The default search path is contained in the &lt;code&gt;@INC&lt;/code&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2733cf2ae6a9ab4b9666de0ca99b049c5b762772" translate="yes" xml:space="preserve">
          <source>When PerlIO receives data from either direction, it fills a buffer (currently with 1024 bytes) and passes the buffer to Encode. Encode tries to convert the valid part and passes it back to PerlIO, leaving invalid parts (usually a partial character) in the buffer. PerlIO then appends more data to the buffer, calls Encode again, and so on until the data stream ends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45a181d0244e9e1141094875e09095d6414b083" translate="yes" xml:space="preserve">
          <source>When Pod::Simple sees a &quot;=head1 Hi there&quot;, for example, it basically does this:</source>
          <target state="translated">例如,当Pod::Simple看到&quot;=head1 Hi there &quot;时,它基本上会这样做。</target>
        </trans-unit>
        <trans-unit id="1cd158af5ecd016f5844a2f8d5f52d658dbd56fa" translate="yes" xml:space="preserve">
          <source>When STDERR is tied, its PRINT method will be called to issue warnings and error messages. This feature is temporarily disabled during the call, which means you can use &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; inside PRINT without starting a recursive loop. And just like &lt;code&gt;__WARN__&lt;/code&gt; and &lt;code&gt;__DIE__&lt;/code&gt; handlers, STDERR's PRINT method may be called to report parser errors, so the caveats mentioned under &lt;a href=&quot;perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; apply.</source>
          <target state="translated">绑定STDERR时，将调用其PRINT方法以发出警告和错误消息。调用期间会暂时禁用此功能，这意味着您可以在PRINT中使用 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; 而不启动递归循环。与 &lt;code&gt;__WARN__&lt;/code&gt; 和 &lt;code&gt;__DIE__&lt;/code&gt; 处理程序一样，可以调用STDERR的PRINT方法来报告解析器错误，因此适用&lt;a href=&quot;perlvar#%25SIG&quot;&gt;于perlvar中％SIG&lt;/a&gt;下提到的警告。</target>
        </trans-unit>
        <trans-unit id="22d03f9253db06fc5a737726d6333d6b64f0247b" translate="yes" xml:space="preserve">
          <source>When STDERR is tied, its PRINT method will be called to issue warnings and error messages. This feature is temporarily disabled during the call, which means you can use &lt;code&gt;warn()&lt;/code&gt; inside PRINT without starting a recursive loop. And just like &lt;code&gt;__WARN__&lt;/code&gt; and &lt;code&gt;__DIE__&lt;/code&gt; handlers, STDERR's PRINT method may be called to report parser errors, so the caveats mentioned under &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&quot;%SIG&quot; in perlvar&lt;/a&gt; apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776742a8703e38b8c7c180ad1bc1e1f2ea07cf1b" translate="yes" xml:space="preserve">
          <source>When Storable croaks, it tries to report the error via the &lt;code&gt;logcroak()&lt;/code&gt; routine from the &lt;code&gt;Log::Agent&lt;/code&gt; package, if it is available.</source>
          <target state="translated">当可存储杂音出现时，它将尝试通过 &lt;code&gt;Log::Agent&lt;/code&gt; 包中的 &lt;code&gt;logcroak()&lt;/code&gt; 例程报告错误（如果可用）。</target>
        </trans-unit>
        <trans-unit id="b63f06de34cfd6fe1d49dc6c54c0e1ae5c2131fc" translate="yes" xml:space="preserve">
          <source>When Storable throws the &quot;Max. recursion depth with nested structures exceeded&quot; error we are already out of stack space. Unfortunately on some earlier perl versions cleaning up a recursive data structure recurses into the free calls, which will lead to stack overflows in the cleanup. This data structure is not properly cleaned up then, it will only be destroyed during global destruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06dc1e20be879a4646c74d93b6d6dde474c28168" translate="yes" xml:space="preserve">
          <source>When UTF-8 becomes the standard source format, this pragma will effectively become a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6016e444b9f013774a61df21cb4a60b0edf43d8" translate="yes" xml:space="preserve">
          <source>When UTF-8 becomes the standard source format, this pragma will effectively become a no-op. For convenience in what follows the term</source>
          <target state="translated">当UTF-8成为标准的源码格式时,这个pragma实际上将成为一个无用的工具。为方便起见,下面的术语</target>
        </trans-unit>
        <trans-unit id="1e26f2f78b2d3c5f0bcbde15044bd5212be0247d" translate="yes" xml:space="preserve">
          <source>When Unicode Does Not Happen</source>
          <target state="translated">当Unicode不发生时</target>
        </trans-unit>
        <trans-unit id="7748cfda1edce223207e83e001d28dffb7bf724f" translate="yes" xml:space="preserve">
          <source>When Unicode rules are in effect:</source>
          <target state="translated">当Unicode规则生效时。</target>
        </trans-unit>
        <trans-unit id="a9436974a6cc23829e6eb2bd840fe00c99d5fdc2" translate="yes" xml:space="preserve">
          <source>When Unicode was first conceived, it was thought that all the world's characters could be represented using a 16-bit word; that is a maximum of &lt;code&gt;0x10000&lt;/code&gt; (or 65,536) characters would be needed, from &lt;code&gt;0x0000&lt;/code&gt; to &lt;code&gt;0xFFFF&lt;/code&gt; . This soon proved to be wrong, and since Unicode 2.0 (July 1996), Unicode has been defined all the way up to 21 bits (&lt;code&gt;0x10FFFF&lt;/code&gt; ), and Unicode 3.1 (March 2001) defined the first characters above &lt;code&gt;0xFFFF&lt;/code&gt; . The first &lt;code&gt;0x10000&lt;/code&gt; characters are called the</source>
          <target state="translated">最初设想Unicode时，人们认为可以使用16位字来表示世界上所有字符。最多需要 &lt;code&gt;0x10000&lt;/code&gt; 个字符（或65,536个），从 &lt;code&gt;0x0000&lt;/code&gt; 到 &lt;code&gt;0xFFFF&lt;/code&gt; 。很快就证明这是错误的，并且自Unicode 2.0（1996年7月）以来，一直到21位（ &lt;code&gt;0x10FFFF&lt;/code&gt; ）都定义了Unicode，而Unicode 3.1（2001年3月）定义了 &lt;code&gt;0xFFFF&lt;/code&gt; 以上的第一个字符。前 &lt;code&gt;0x10000&lt;/code&gt; 个字符称为</target>
        </trans-unit>
        <trans-unit id="235280477a8ab02cc7856eb55d9945ecaf55e478" translate="yes" xml:space="preserve">
          <source>When Unicode was first conceived, it was thought that all the world's characters could be represented using a 16-bit word; that is a maximum of &lt;code&gt;0x10000&lt;/code&gt; (or 65,536) characters would be needed, from &lt;code&gt;0x0000&lt;/code&gt; to &lt;code&gt;0xFFFF&lt;/code&gt;. This soon proved to be wrong, and since Unicode 2.0 (July 1996), Unicode has been defined all the way up to 21 bits (&lt;code&gt;0x10FFFF&lt;/code&gt;), and Unicode 3.1 (March 2001) defined the first characters above &lt;code&gt;0xFFFF&lt;/code&gt;. The first &lt;code&gt;0x10000&lt;/code&gt; characters are called the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e31ae8f51bc97ba41c3c0ff630526d3a83b94c44" translate="yes" xml:space="preserve">
          <source>When a &quot;=head1 ...&quot; directive is parsed, it produces this event structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824bf2e880285aa9c434d2acac5d910818e02e5d" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;SelectSaver&lt;/code&gt; is destroyed, it re-selects the file handle that was selected when it was created.</source>
          <target state="translated">当 &lt;code&gt;SelectSaver&lt;/code&gt; 被破坏，它会重新选择在创建时所选择的文件句柄。</target>
        </trans-unit>
        <trans-unit id="47dccd0143522691a9547f34d1ed5af302d02e22" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;given&lt;/code&gt; statement is also a valid expression (for example, when it's the last statement of a block), it evaluates to:</source>
          <target state="translated">当 &lt;code&gt;given&lt;/code&gt; 语句也是有效表达式时（例如，当它是块的最后一条语句时），其结果为：</target>
        </trans-unit>
        <trans-unit id="a06437bb92809b351f6a5100b5739a7e2454e5a6" translate="yes" xml:space="preserve">
          <source>When a CV has a reference count on its slab (&lt;code&gt;CvSLABBED&lt;/code&gt;), it is responsible for making sure it is freed. (Hence, no two CVs should ever have a reference count on the same slab.) The CV only needs to reference the slab during compilation. Once it is compiled and &lt;code&gt;CvROOT&lt;/code&gt; attached, it has finished its job, so it can forget the slab.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af006e8d26663a7078cc20a1292be03a5256d66" translate="yes" xml:space="preserve">
          <source>When a CV has a reference count on its slab (CvSLABBED), it is responsible for making sure it is freed. (Hence, no two CVs should ever have a reference count on the same slab.) The CV only needs to reference the slab during compilation. Once it is compiled and CvROOT attached, it has finished its job, so it can forget the slab.</source>
          <target state="translated">当一个 CV 在它的 slab 上有一个引用计数 (CvSLABBED),它有责任确保它被释放。(因此,任何两个 CV 都不应该在同一个 slab 上有一个引用计数。)CV 只需要在编译时引用 slab。一旦它被编译并连接了 CvROOT,它就完成了它的工作,所以它可以忘记 slab。</target>
        </trans-unit>
        <trans-unit id="5c03e144fe4a4613006ecf4b238cfa477e26c49c" translate="yes" xml:space="preserve">
          <source>When a DST change causes a locale clock to skip one hour forward, there will be an hour's worth of local times that don't exist. Again, for the &quot;Europe/Paris&quot; time zone, the local clock jumped from 2001-03-25 01:59:59 to 2001-03-25 03:00:00.</source>
          <target state="translated">当DST变化导致一个地区时钟向前跳过一个小时时,会有一个小时的当地时间不存在。同样,对于 &quot;欧洲/巴黎 &quot;时区,当地时钟从2001-03-25 01:59:59跳到2001-03-25 03:00:00。</target>
        </trans-unit>
        <trans-unit id="711842f215653a7ad792c5b86c0dd5c2fc228aee" translate="yes" xml:space="preserve">
          <source>When a L&amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34b3c17b138dcee1edbc75a046c702f3a8b9a07" translate="yes" xml:space="preserve">
          <source>When a Pod verbatim paragraph (AKA &quot;codeblock&quot;) is parsed, it produces this event structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8b5f7b3a10fd426ef30c3ec83c6b8baa679be4" translate="yes" xml:space="preserve">
          <source>When a block is preceded by a compilation phase keyword such as &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;END&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, or &lt;code&gt;UNITCHECK&lt;/code&gt;, then the block will run only during the corresponding phase of execution. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c769151f41d9f979bbea6aa6d7a29c398587207" translate="yes" xml:space="preserve">
          <source>When a block is preceding by a compilation phase keyword such as &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;END&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , or &lt;code&gt;UNITCHECK&lt;/code&gt; , then the block will run only during the corresponding phase of execution. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for more details.</source>
          <target state="translated">当一个块前面有一个编译阶段关键字，例如 &lt;code&gt;BEGIN&lt;/code&gt; ， &lt;code&gt;END&lt;/code&gt; ， &lt;code&gt;INIT&lt;/code&gt; ， &lt;code&gt;CHECK&lt;/code&gt; 或 &lt;code&gt;UNITCHECK&lt;/code&gt; 时，该块将仅在相应的执行阶段运行。有关更多详细信息，请参见&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d61af89d14aac150579ea072baeedb77daecc0a" translate="yes" xml:space="preserve">
          <source>When a class has multiple parents, the method lookup order becomes more complicated.</source>
          <target state="translated">当一个类有多个父类时,方法的查找顺序会变得更加复杂。</target>
        </trans-unit>
        <trans-unit id="bbfabd64dc538b19e52659b29026ea44adaac5bb" translate="yes" xml:space="preserve">
          <source>When a class inherits from another class, any methods defined in the parent class are available to the child class. If you attempt to call a method on an object that isn't defined in its own class, Perl will also look for that method in any parent classes it may have.</source>
          <target state="translated">当一个类从另一个类继承时,父类中定义的任何方法都可以被子类使用。如果你试图在一个对象上调用一个没有在它自己的类中定义的方法,Perl也会在它可能有的任何父类中寻找该方法。</target>
        </trans-unit>
        <trans-unit id="3fbe037b656bddc24c2846062762f1fce297b32a" translate="yes" xml:space="preserve">
          <source>When a comma-separated list of subroutine names is given as options, Showlex prints the lexical variables used in those subroutines. Otherwise, it prints the file-scope lexicals in the file.</source>
          <target state="translated">当给定一个以逗号分隔的子程序名称列表作为选项时,Showlex会打印这些子程序中使用的词汇变量。否则,它将打印文件中的文件范围词法。</target>
        </trans-unit>
        <trans-unit id="7150e31ab9e9cca66d69c6a47a4d5fc17ee83d01" translate="yes" xml:space="preserve">
          <source>When a constant is used in an expression, Perl replaces it with its value at compile time, and may then optimize the expression further. In particular, any code in an &lt;code&gt;if (CONSTANT)&lt;/code&gt; block will be optimized away if the constant is false.</source>
          <target state="translated">在表达式中使用常量时，Perl在编译时将其替换为其值，然后可以进一步优化表达式。特别是，如果常量为false，则 &lt;code&gt;if (CONSTANT)&lt;/code&gt; 块中的任何代码都将被优化。</target>
        </trans-unit>
        <trans-unit id="ff12ac8ff6a9fb5ab965d82a8adb8da16c238288" translate="yes" xml:space="preserve">
          <source>When a context for a part of compile tree is known, it is propagated down through the tree. At this time the context can have 5 values (instead of 2 for runtime context): void, boolean, scalar, list, and lvalue. In contrast with the pass 1 this pass is processed from top to bottom: a node's context determines the context for its children.</source>
          <target state="translated">当编译树的一部分上下文已知时,它会通过树向下传播。此时上下文可以有5个值(而不是运行时上下文的2个):void、boolean、scalar、list和lvalue。与通证1不同的是,这个通证是从上到下处理的:一个节点的上下文决定了其子节点的上下文。</target>
        </trans-unit>
        <trans-unit id="d87717a8777688d74cabbb2304d94b51341cc91d" translate="yes" xml:space="preserve">
          <source>When a core function calls another, it must pass the context. This is normally hidden via macros. Consider &lt;code&gt;sv_setiv&lt;/code&gt; . It expands into something like this:</source>
          <target state="translated">当一个核心函数调用另一个函数时，它必须传递上下文。通常通过宏将其隐藏。考虑 &lt;code&gt;sv_setiv&lt;/code&gt; 。它扩展为如下所示：</target>
        </trans-unit>
        <trans-unit id="89bb7cb6afe2aeb318bc31219fdbcf9684114fa1" translate="yes" xml:space="preserve">
          <source>When a core function calls another, it must pass the context. This is normally hidden via macros. Consider &lt;code&gt;sv_setiv&lt;/code&gt;. It expands into something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ceceb3dfac228f4dc1ea2316b05b14abb23395" translate="yes" xml:space="preserve">
          <source>When a dictionary is specified</source>
          <target state="translated">当指定一个字典时</target>
        </trans-unit>
        <trans-unit id="d409b69c538e75e300d571031fe6a755a4d085f3" translate="yes" xml:space="preserve">
          <source>When a distribution has already been tested by CPAN::Reporter on this machine, CPAN can skip the test phase and just rely on the test report history instead.</source>
          <target state="translated">当CPAN::Reporter已经在这台机器上测试过一个发行版时,CPAN可以跳过测试阶段,而只依靠测试报告历史记录。</target>
        </trans-unit>
        <trans-unit id="f71acc218a83c770a92fc1a815404b3d3de498a7" translate="yes" xml:space="preserve">
          <source>When a file is opened it is in either text or binary mode. In text mode a file is subject to CR/LF/Ctrl-Z translations. With Cygwin, the default mode for an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; is determined by the mode of the mount that underlies the file. See &lt;a href=&quot;#Cygwin%3a%3ais_binmount&quot;&gt;Cygwin::is_binmount&lt;/a&gt;(). Perl provides a &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; function to set binary mode on files that otherwise would be treated as text. &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;O_TEXT&lt;/code&gt; flag sets text mode on files that otherwise would be treated as binary:</source>
          <target state="translated">打开文件时，它处于文本或二进制模式。在文本模式下，文件需要进行CR / LF / Ctrl-Z转换。使用Cygwin时， &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 的默认模式由文件基础安装的模式决定。请参见&lt;a href=&quot;#Cygwin%3a%3ais_binmount&quot;&gt;Cygwin :: is_binmount&lt;/a&gt;（）。 Perl提供了 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; 函数来设置文件的二进制模式，否则该文件将被视为文本。带有 &lt;code&gt;O_TEXT&lt;/code&gt; 标志的 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; 在文件上设置文本模式，否则将被视为二进制文件：</target>
        </trans-unit>
        <trans-unit id="77b5bb5939b31598184beb720f013a6b65e23bf1" translate="yes" xml:space="preserve">
          <source>When a file is opened it is in either text or binary mode. In text mode a file is subject to CR/LF/Ctrl-Z translations. With Cygwin, the default mode for an &lt;code&gt;open()&lt;/code&gt; is determined by the mode of the mount that underlies the file. See &lt;a href=&quot;#Cygwin%3A%3Ais_binmount&quot;&gt;&quot;Cygwin::is_binmount&quot;&lt;/a&gt;(). Perl provides a &lt;code&gt;binmode()&lt;/code&gt; function to set binary mode on files that otherwise would be treated as text. &lt;code&gt;sysopen()&lt;/code&gt; with the &lt;code&gt;O_TEXT&lt;/code&gt; flag sets text mode on files that otherwise would be treated as binary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973bff9414f9daff4e8ac9353de5be029b42eafe" translate="yes" xml:space="preserve">
          <source>When a handle is so opened, then reads get bytes from the string value of</source>
          <target state="translated">当一个句柄被如此打开,那么从字符串值的</target>
        </trans-unit>
        <trans-unit id="17e8d47075484fcb067bf9d5f01cdea7dd0c053a" translate="yes" xml:space="preserve">
          <source>When a keyword is being handled, the plugin function must build a tree of &lt;code&gt;OP&lt;/code&gt; structures, representing the code that was parsed. The root of the tree must be stored in &lt;code&gt;*op_ptr&lt;/code&gt; . The function then returns a constant indicating the syntactic role of the construct that it has parsed: &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; if it is a complete statement, or &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; if it is an expression. Note that a statement construct cannot be used inside an expression (except via &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; and similar), and an expression is not a complete statement (it requires at least a terminating semicolon).</source>
          <target state="translated">处理关键字时，插件功能必须构建 &lt;code&gt;OP&lt;/code&gt; 结构树，以表示已解析的代码。树的根必须存储在 &lt;code&gt;*op_ptr&lt;/code&gt; 中。该函数然后返回指示结构的语法作用，它已解析的常数： &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; ，如果它是一个完整的语句，或者 &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; 如果它是一个表达式。注意，语句构造不能在表达式内部使用（通过 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; 和类似方法除外），并且表达式不是完整的语句（它至少需要一个终止分号）。</target>
        </trans-unit>
        <trans-unit id="a9174fe1323f2a0785f91a3ab7751748b2c8cde0" translate="yes" xml:space="preserve">
          <source>When a keyword is being handled, the plugin function must build a tree of &lt;code&gt;OP&lt;/code&gt; structures, representing the code that was parsed. The root of the tree must be stored in &lt;code&gt;*op_ptr&lt;/code&gt;. The function then returns a constant indicating the syntactic role of the construct that it has parsed: &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; if it is a complete statement, or &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; if it is an expression. Note that a statement construct cannot be used inside an expression (except via &lt;code&gt;do BLOCK&lt;/code&gt; and similar), and an expression is not a complete statement (it requires at least a terminating semicolon).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e79d667e2ee3be13474d3de61e4494ae38724c2" translate="yes" xml:space="preserve">
          <source>When a keyword is handled, the plugin function may also have (compile-time) side effects. It may modify &lt;code&gt;%^H&lt;/code&gt; , define functions, and so on. Typically, if side effects are the main purpose of a handler, it does not wish to generate any ops to be included in the normal compilation. In this case it is still required to supply an op tree, but it suffices to generate a single null op.</source>
          <target state="translated">处理关键字时，插件功能也可能具有（编译时）副作用。它可以修改 &lt;code&gt;%^H&lt;/code&gt; ，定义函数，等等。通常，如果副作用是处理程序的主要目的，则它不希望生成要包含在常规编译中的任何操作。在这种情况下，仍然需要提供一个op树，但是足以生成一个空op。</target>
        </trans-unit>
        <trans-unit id="96150c30b3160f65ac137db96b6444cc4c0b5dee" translate="yes" xml:space="preserve">
          <source>When a keyword is handled, the plugin function may also have (compile-time) side effects. It may modify &lt;code&gt;%^H&lt;/code&gt;, define functions, and so on. Typically, if side effects are the main purpose of a handler, it does not wish to generate any ops to be included in the normal compilation. In this case it is still required to supply an op tree, but it suffices to generate a single null op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d37ded835c420c7b9a32e56975a37c7bb1fd7d" translate="yes" xml:space="preserve">
          <source>When a lexical var hasn't yet been introduced, it already exists from the perspective of duplicate declarations, but not for variable lookups, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ad4f96e4d1cfbd5bc9ad7761654ce09c743746" translate="yes" xml:space="preserve">
          <source>When a line is rendered, the correct format-spec is copied and scanned for the following items; data is substituted in, and other manipulations like basic indenting are done, for each opcode rendered.</source>
          <target state="translated">当一行被渲染时,正确的格式-规格被复制,并扫描以下项目;数据被替换进去,并对每个操作码进行其他操作,如基本缩进。</target>
        </trans-unit>
        <trans-unit id="a843fab343a403fdde443c4b37520ec7d2e838fc" translate="yes" xml:space="preserve">
          <source>When a match has failed, and unless another verb has been involved in failing the match and has provided its own name to use, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816633f303f39f0cbcf02a62fbc386a09fe865f3" translate="yes" xml:space="preserve">
          <source>When a match has failed, and unless another verb has been involved in failing the match and has provided its own name to use, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:NAME)&lt;/code&gt;.</source>
          <target state="translated">如果匹配失败，并且除非另一个动词导致匹配失败并提供了自己的名称， &lt;code&gt;$REGERROR&lt;/code&gt; 变量将设置为最近执行的名称 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24e6f28f32721a0addc83e91cf8c10e71bc456ee" translate="yes" xml:space="preserve">
          <source>When a match is successful, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; that was involved in the match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166223375f2bf3db19459da46d44df6881e6c346" translate="yes" xml:space="preserve">
          <source>When a match is successful, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:NAME)&lt;/code&gt; that was involved in the match.</source>
          <target state="translated">匹配成功后， &lt;code&gt;$REGMARK&lt;/code&gt; 变量将设置为匹配中最近执行的名称 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4580d4e00986eec91e11abd53ea45f7e741116fe" translate="yes" xml:space="preserve">
          <source>When a module declares another one as a 'build_requires' prerequisite this means that the other module is only needed for building or testing the module but need not be installed permanently. In this case you may wish to install that other module nonetheless or just keep it in the 'build_dir' directory to have it available only temporarily. Installing saves time on future installations but makes the perl installation bigger.</source>
          <target state="translated">当一个模块声明另一个模块是'build_requires'的先决条件时,这意味着另一个模块只是在构建或测试该模块时才需要,而不需要永久安装。在这种情况下,您可能希望还是安装那个模块,或者只是把它放在'build_dir'目录下,让它暂时可用。安装可以节省以后安装的时间,但会使perl的安装变得更大。</target>
        </trans-unit>
        <trans-unit id="1496adc7bcbe4a50d48879cef9be976a3fb2e9c5" translate="yes" xml:space="preserve">
          <source>When a new language is being encoded, Unicode generally will choose a &lt;code&gt;block&lt;/code&gt; of consecutive unallocated code points for its characters. So far, the number of code points in these blocks has always been evenly divisible by 16. Extras in a block, not currently needed, are left unallocated, for future growth. But there have been occasions when a later release needed more code points than the available extras, and a new block had to allocated somewhere else, not contiguous to the initial one, to handle the overflow. Thus, it became apparent early on that &quot;block&quot; wasn't an adequate organizing principal, and so the &lt;code&gt;Script&lt;/code&gt; property was created. (Later an improved script property was added as well, the &lt;code&gt;Script_Extensions&lt;/code&gt; property.) Those code points that are in overflow blocks can still have the same script as the original ones. The script concept fits more closely with natural language: there is &lt;code&gt;Latin&lt;/code&gt; script, &lt;code&gt;Greek&lt;/code&gt; script, and so on; and there are several artificial scripts, like &lt;code&gt;Common&lt;/code&gt; for characters that are used in multiple scripts, such as mathematical symbols. Scripts usually span varied parts of several blocks. For more information about scripts, see &lt;a href=&quot;perlunicode#Scripts&quot;&gt;Scripts in perlunicode&lt;/a&gt;. The division into blocks exists, but it is almost completely accidental--an artifact of how the characters have been and still are allocated. (Note that this paragraph has oversimplified things for the sake of this being an introduction. Unicode doesn't really encode languages, but the writing systems for them--their scripts; and one script can be used by many languages. Unicode also encodes things that aren't really about languages, such as symbols like &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt; .)</source>
          <target state="translated">在对一种新语言进行编码时，Unicode通常会为其字符选择一个 &lt;code&gt;block&lt;/code&gt; 连续的未分配代码点。到目前为止，这些块中的代码点数量始终可以被16整除。为了将来的增长，该块中不需要的多余部分将不分配。但是，有些情况下，较新的发行版需要比可用附加功能更多的代码点，并且必须将新块分配到其他位置（与初始位置不相邻）来处理溢出。因此，很早就很明显，&amp;ldquo;块&amp;rdquo;不是足够的组织主体，因此创建了 &lt;code&gt;Script&lt;/code&gt; 属性。 （后来还添加了改进的脚本属性， &lt;code&gt;Script_Extensions&lt;/code&gt; 属性。）位于溢出块中的那些代码点仍可以具有与原始脚本相同的脚本。脚本概念更适合自然语言： &lt;code&gt;Latin&lt;/code&gt; ， &lt;code&gt;Greek&lt;/code&gt; 字母等；还有几种人工脚本，例如 &lt;code&gt;Common&lt;/code&gt; 表示用于多个脚本的字符，例如数学符号。脚本通常跨越几个块的不同部分。有关脚本的更多信息，请参见&lt;a href=&quot;perlunicode#Scripts&quot;&gt;perlunicode中的脚本。&lt;/a&gt;。虽然存在划分为块的情况，但是这几乎完全是偶然的-有关如何以及仍然分配字符的伪像。 （请注意，为了便于介绍，本段对事情进行了简化。Unicode并未真正对语言进行编码，但它们的书写系统是它们的脚本；多种语言可以使用一个脚本。Unicode也可以对事物进行编码。与语言无关，例如像 &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt; 之类的符号。）</target>
        </trans-unit>
        <trans-unit id="f7bd752f648e1f1f371051489dc3b8a7639c7fc7" translate="yes" xml:space="preserve">
          <source>When a new language is being encoded, Unicode generally will choose a &lt;code&gt;block&lt;/code&gt; of consecutive unallocated code points for its characters. So far, the number of code points in these blocks has always been evenly divisible by 16. Extras in a block, not currently needed, are left unallocated, for future growth. But there have been occasions when a later release needed more code points than the available extras, and a new block had to allocated somewhere else, not contiguous to the initial one, to handle the overflow. Thus, it became apparent early on that &quot;block&quot; wasn't an adequate organizing principle, and so the &lt;code&gt;Script&lt;/code&gt; property was created. (Later an improved script property was added as well, the &lt;code&gt;Script_Extensions&lt;/code&gt; property.) Those code points that are in overflow blocks can still have the same script as the original ones. The script concept fits more closely with natural language: there is &lt;code&gt;Latin&lt;/code&gt; script, &lt;code&gt;Greek&lt;/code&gt; script, and so on; and there are several artificial scripts, like &lt;code&gt;Common&lt;/code&gt; for characters that are used in multiple scripts, such as mathematical symbols. Scripts usually span varied parts of several blocks. For more information about scripts, see &lt;a href=&quot;perlunicode#Scripts&quot;&gt;&quot;Scripts&quot; in perlunicode&lt;/a&gt;. The division into blocks exists, but it is almost completely accidental--an artifact of how the characters have been and still are allocated. (Note that this paragraph has oversimplified things for the sake of this being an introduction. Unicode doesn't really encode languages, but the writing systems for them--their scripts; and one script can be used by many languages. Unicode also encodes things that aren't really about languages, such as symbols like &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbe3c04751e10d9bc078e9c200bbf898654f3d9" translate="yes" xml:space="preserve">
          <source>When a package is compiled, a line like this</source>
          <target state="translated">当一个软件包被编译时,会有这样一行字</target>
        </trans-unit>
        <trans-unit id="93bffad6a970da997c7854ebcbcae55a405a4802" translate="yes" xml:space="preserve">
          <source>When a perl script assigns a value to $0 then the perl runtime will try to make this value show up as the program name reported by &quot;ps&quot; by updating the memory pointed to by the argv passed to perl_parse() and also calling API functions like setproctitle() where available. This behaviour might not be appropriate when embedding perl and can be disabled by assigning the value &lt;code&gt;1&lt;/code&gt; to the variable &lt;code&gt;PL_origalen&lt;/code&gt; before perl_parse() is called.</source>
          <target state="translated">当perl脚本为$ 0赋值时，perl运行时将尝试通过更新传递给perl_parse（）的argv指向的内存并调用API函数（例如，&amp;ldquo; ps&amp;rdquo;报告的程序名称）来显示该值。 setproctitle（）（如果有）。嵌入perl时，此行为可能不合适，可以通过在调用perl_parse（）之前将值 &lt;code&gt;1&lt;/code&gt; 分配给变量 &lt;code&gt;PL_origalen&lt;/code&gt; 来禁用此行为。</target>
        </trans-unit>
        <trans-unit id="5dd94d34aa40052479abfe68a7305a1776af1c6b" translate="yes" xml:space="preserve">
          <source>When a regexp can match a string in several different ways, we can use the principles above to predict which way the regexp will match:</source>
          <target state="translated">当一个regexp可以用几种不同的方式来匹配一个字符串时,我们可以用上面的原理来预测regexp的匹配方式。</target>
        </trans-unit>
        <trans-unit id="5e93e818427f981a20b5cd3c2cdc058e4ee5f4c1" translate="yes" xml:space="preserve">
          <source>When a regexp is compiled, its &lt;code&gt;engine&lt;/code&gt; field is then set to point at the appropriate structure, so that when it needs to be used Perl can find the right routines to do so.</source>
          <target state="translated">编译正则表达式时，然后将其 &lt;code&gt;engine&lt;/code&gt; 字段设置为指向适当的结构，以便在需要使用它时，Perl可以找到正确的例程来执行此操作。</target>
        </trans-unit>
        <trans-unit id="1ee520116426a3c213440cc6f7664ca3ad684e60" translate="yes" xml:space="preserve">
          <source>When a signal is delivered (e.g., SIGINT from a control-C) the operating system breaks into IO operations like</source>
          <target state="translated">当一个信号传递过来时(例如,来自控制C的SIGINT),操作系统就会分解成IO操作,如</target>
        </trans-unit>
        <trans-unit id="232c6b5f6274d23859408b92a2808f3fc59dd734" translate="yes" xml:space="preserve">
          <source>When a space and a plus sign are given as the flags at once, a plus sign is used to prefix a positive number.</source>
          <target state="translated">当同时给出一个空格和一个加号作为标志时,加号用于正数的前缀。</target>
        </trans-unit>
        <trans-unit id="545ab55cd7ca990a06b2c4cf5e80c654c6ee269f" translate="yes" xml:space="preserve">
          <source>When a space and a plus sign are given as the flags at once, the space is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74001a7284f9d1373e15b508cdd1efa8fda60fc2" translate="yes" xml:space="preserve">
          <source>When a user-defined subroutine is wrapped by &lt;code&gt;autodie&lt;/code&gt;, it will use hints if they are available, and otherwise reverts to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3497a2701b51a3e1bca0e706937a383957b3a809" translate="yes" xml:space="preserve">
          <source>When a value is returned from a thread through a &lt;code&gt;join&lt;/code&gt; operation, the value and everything that it references is copied across to the joining thread, in much the same way that values are copied upon thread creation. This works fine for most kinds of value, including arrays, hashes, and subroutines. The copying recurses through array elements, reference scalars, variables closed over by subroutines, and other kinds of reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c0062970171773b2800c4b96cf35e1d153d560" translate="yes" xml:space="preserve">
          <source>When a variable is tied, it is associated with the object which is the return value of the TIESCALAR, TIEARRAY, or TIEHASH function. This object normally has only one reference, namely, the implicit reference from the tied variable. When untie() is called, that reference is destroyed. Then, as in the first example above, the object's destructor (DESTROY) is called, which is normal for objects that have no more valid references; and thus the file is closed.</source>
          <target state="translated">当一个变量被绑定时,它与对象相关联,这个对象是TIESCALAR、TIEARRAY或TIEHASH函数的返回值。这个对象通常只有一个引用,即来自绑定变量的隐式引用。当调用untie()时,这个引用会被销毁。然后,就像上面第一个例子一样,调用对象的destructor(DESTROY),这对于没有更多有效引用的对象来说是正常的;因此文件被关闭。</target>
        </trans-unit>
        <trans-unit id="4c087ed039f3d9aacb0c9c7c411e1eafe86f0a03" translate="yes" xml:space="preserve">
          <source>When a weak reference is stored in an &lt;code&gt;SV&lt;/code&gt; that has &quot;uvar&quot; magic, &lt;code&gt;set&lt;/code&gt; magic is called after the reference has gone stale. This hook can be used to trigger further garbage-collection activities associated with the referenced object.</source>
          <target state="translated">当弱引用存储在具有&amp;ldquo; uvar&amp;rdquo;魔术的 &lt;code&gt;SV&lt;/code&gt; 中时，在引用失效后将调用 &lt;code&gt;set&lt;/code&gt; magic。该钩子可用于触发与引用的对象关联的其他垃圾收集活动。</target>
        </trans-unit>
        <trans-unit id="9a9840147d7f095037a163c370bf370a7676a796" translate="yes" xml:space="preserve">
          <source>When all parsers are exhausted an empty list will be returned.</source>
          <target state="translated">当所有的解析器都用完后,将返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="4475cbc9efc3f925a7d535afa9908fb989684e90" translate="yes" xml:space="preserve">
          <source>When an &quot;=over ... =back&quot; block is parsed where the items are a bulleted list, it will produce this event structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d07ffe1c99de4f1b7f522c65bdd9eecb591a526c" translate="yes" xml:space="preserve">
          <source>When an &quot;=over ... =back&quot; block is parsed where the items are a numbered list, it will produce this event structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9420e774841a86eb3869701949ed03c728fe1309" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; enabled function fails, it generates an &lt;code&gt;autodie::exception&lt;/code&gt; object. This can be interrogated to determine further information about the error that occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58a9a2162a7d9db701502c02549ae6467f05b83" translate="yes" xml:space="preserve">
          <source>When an array or an array slice is interpolated into a double-quoted string or a similar context such as &lt;code&gt;/.../&lt;/code&gt; , its elements are separated by this value. Default is a space. For example, this:</source>
          <target state="translated">当将数组或数组切片插值到双引号字符串或类似的上下文（例如 &lt;code&gt;/.../&lt;/code&gt; )时，其元素由该值分隔。默认为空格。例如，这：</target>
        </trans-unit>
        <trans-unit id="1cef7d16c561803c2f66d1c8d9b2d86bf2638f56" translate="yes" xml:space="preserve">
          <source>When an array or an array slice is interpolated into a double-quoted string or a similar context such as &lt;code&gt;/.../&lt;/code&gt;, its elements are separated by this value. Default is a space. For example, this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ada78738410600725bc97a1fe2d577a540f0ef9" translate="yes" xml:space="preserve">
          <source>When an attribute list is present in a declaration, a check is made to see whether an attribute 'modify' handler is present in the appropriate package (or its @ISA inheritance tree). Similarly, when &lt;code&gt;attributes::get&lt;/code&gt; is called on a valid reference, a check is made for an appropriate attribute 'fetch' handler. See &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; to see how the &quot;appropriate package&quot; determination works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e576a7aca6fc0d7ad26c29db1ef25b646d312e24" translate="yes" xml:space="preserve">
          <source>When an attribute list is present in a declaration, a check is made to see whether an attribute 'modify' handler is present in the appropriate package (or its @ISA inheritance tree). Similarly, when &lt;code&gt;attributes::get&lt;/code&gt; is called on a valid reference, a check is made for an appropriate attribute 'fetch' handler. See &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; to see how the &quot;appropriate package&quot; determination works.</source>
          <target state="translated">当声明中存在属性列表时，将进行检查以查看适当的包（或其@ISA继承树）中是否存在&amp;ldquo;修改&amp;rdquo;属性处理程序。类似地，当在有效引用上调用 &lt;code&gt;attributes::get&lt;/code&gt; 时，将检查适当的属性&amp;ldquo;提取&amp;rdquo;处理程序。请参阅&lt;a href=&quot;#EXAMPLES&quot;&gt;示例，&lt;/a&gt;以了解&amp;ldquo;合适的包装&amp;rdquo;确定的工作原理。</target>
        </trans-unit>
        <trans-unit id="8cddb5e14177fc6acd8b55e0252f21e912b7951c" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is read, the locations to which</source>
          <target state="translated">读取 &lt;code&gt;%ENV&lt;/code&gt; 的元素时，</target>
        </trans-unit>
        <trans-unit id="0687a40bbb86ac6f75e3c72f51434b562de688d3" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the element is looked up as if it were being read, and if it is found, it is deleted. (An item &quot;deleted&quot; from the CRTL &lt;code&gt;environ&lt;/code&gt; array is set to the empty string.) Using &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; to remove an element from &lt;code&gt;%ENV&lt;/code&gt; has a similar effect, but after the element is deleted, another attempt is made to look up the element, so an inner-mode logical name or a name in another location will replace the logical name just deleted. In either case, only the first value found searching PERL_ENV_TABLES is altered. It is not possible at present to define a search list logical name via %ENV.</source>
          <target state="translated">当 &lt;code&gt;%ENV&lt;/code&gt; 的元素设置为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 时，将查找该元素，就像正在读取该元素一样；如果找到该元素，则将其删除。 （将从CRTL &lt;code&gt;environ&lt;/code&gt; 数组中&amp;ldquo;删除&amp;rdquo;的项设置为空字符串。）使用 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;%ENV&lt;/code&gt; 中删除元素具有类似的效果，但是在删除该元素之后，会再次尝试查找该元素，因此内部模式逻辑名称或其他位置的名称将替换刚刚删除的逻辑名称。在这两种情况下，只有搜索PERL_ENV_TABLES时找到的第一个值都会被更改。目前尚无法通过％ENV定义搜索列表逻辑名。</target>
        </trans-unit>
        <trans-unit id="0c072f9ffbeb43d95b6bbc690c50b27ac90e561f" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to &lt;code&gt;undef&lt;/code&gt;, the element is looked up as if it were being read, and if it is found, it is deleted. (An item &quot;deleted&quot; from the CRTL &lt;code&gt;environ&lt;/code&gt; array is set to the empty string.) Using &lt;code&gt;delete&lt;/code&gt; to remove an element from &lt;code&gt;%ENV&lt;/code&gt; has a similar effect, but after the element is deleted, another attempt is made to look up the element, so an inner-mode logical name or a name in another location will replace the logical name just deleted. In either case, only the first value found searching PERL_ENV_TABLES is altered. It is not possible at present to define a search list logical name via %ENV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3d5e830d380d586cadba3ebb3b0b5993def5162" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to a defined string, the corresponding definition is made in the location to which the first translation of</source>
          <target state="translated">当 &lt;code&gt;%ENV&lt;/code&gt; 的元素设置为已定义的字符串时，将在以下位置进行相应的定义：</target>
        </trans-unit>
        <trans-unit id="6e4667405eb0016e589d7ee3b3978551b835b138" translate="yes" xml:space="preserve">
          <source>When an install fails for some reason and then I correct the error condition and retry, CPAN.pm refuses to install the module, saying &lt;code&gt;Already tried without success&lt;/code&gt; .</source>
          <target state="translated">如果安装由于某种原因而失败，然后我纠正了错误情况并重试，则CPAN.pm拒绝安装该模块，并说&amp;ldquo; &lt;code&gt;Already tried without success&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88b449cc559ca252d850238032174c7042fa310e" translate="yes" xml:space="preserve">
          <source>When an undefined layer 'foo' is encountered in an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; layer specification then C code performs the equivalent of:</source>
          <target state="translated">当在 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 层或 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 层规范中遇到未定义的层'foo'时，C代码将执行以下操作：</target>
        </trans-unit>
        <trans-unit id="40fb6d5dfd2c6aa613f88a6e49dba73d8dca4cc3" translate="yes" xml:space="preserve">
          <source>When an undefined layer 'foo' is encountered in an &lt;code&gt;open&lt;/code&gt; or &lt;code&gt;binmode&lt;/code&gt; layer specification then C code performs the equivalent of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05eb98d8070a762d6a7fd65d464d57e96f47f0ef" translate="yes" xml:space="preserve">
          <source>When an updir path like &quot;:::lib::&quot; is passed as argument, the number of directories to climb up is handled correctly, not removing leading or trailing colons when necessary. E.g.</source>
          <target state="translated">当传递&quot;:::lib::&quot;这样的updir路径作为参数时,会正确处理要爬升的目录数,必要时不会去掉前导或尾部的冒号。例如</target>
        </trans-unit>
        <trans-unit id="fc030f96c1c92f54f8dacedeb177bdbc127fdac6" translate="yes" xml:space="preserve">
          <source>When an uppercase and lowercase letter both exist in the table, then the uppercase letter is typically used to represent some kind of composite type (a list or a hash), and the lowercase letter is used to represent an element of that composite type. Some internals code makes use of this case relationship. However, 'v' and 'V' (vec and v-string) are in no way related.</source>
          <target state="translated">当表中同时存在大写字母和小写字母时,那么大写字母通常用来表示某种复合类型(列表或哈希),小写字母用来表示该复合类型的一个元素。一些内部代码就利用了这种大小写关系。但是,'v'和'V'(vec和v-string)没有任何关系。</target>
        </trans-unit>
        <trans-unit id="34009ee0cae148f2a1680a702fb847661476a204" translate="yes" xml:space="preserve">
          <source>When and whether to use small caps is somewhat tricky, and Pod::Man doesn't necessarily get it right.</source>
          <target state="translated">什么时候用、是否用小写字母有些棘手,Pod::Man也不一定能做好。</target>
        </trans-unit>
        <trans-unit id="50a0e6b3c1e9721563cfa37763282c6acaf8fe8f" translate="yes" xml:space="preserve">
          <source>When applied to the following command line:</source>
          <target state="translated">当应用到以下命令行时。</target>
        </trans-unit>
        <trans-unit id="a01d1e59657f16ebb14cc78dbc769393ad07bd40" translate="yes" xml:space="preserve">
          <source>When auto-detecting the compressed format, try to test for lzma_alone content using the &lt;code&gt;IO::Uncompress::UnLzma&lt;/code&gt; module.</source>
          <target state="translated">当自动检测压缩格式时，请尝试使用 &lt;code&gt;IO::Uncompress::UnLzma&lt;/code&gt; 模块测试lzma_alone内容。</target>
        </trans-unit>
        <trans-unit id="3afc2592b2e6769a24dccd537ec52009da2c39f6" translate="yes" xml:space="preserve">
          <source>When auto-detecting the compressed format, try to test for raw-deflate (RFC 1951) content using the &lt;code&gt;IO::Uncompress::RawInflate&lt;/code&gt; module.</source>
          <target state="translated">自动检测压缩格式时，请尝试使用 &lt;code&gt;IO::Uncompress::RawInflate&lt;/code&gt; 模块测试原始压缩（RFC 1951）内容。</target>
        </trans-unit>
        <trans-unit id="9c2cde96752e55bde69311a35423f2dcc59f8d7b" translate="yes" xml:space="preserve">
          <source>When automatic selection of the nearest cpan mirrors is performed, this option can be used to turn on verbosity during the selection process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6884ba24d0a86a83e3adb2e1fb93cb3394961f06" translate="yes" xml:space="preserve">
          <source>When automatic selection of the nearest cpan mirrors is performed, turn on the use of the external ping via Net::Ping::External. This is recommended in the case the local network has a transparent proxy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22fe69040aadcae108c71d87a32f8d5b0102ff6a" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;'^'&lt;/code&gt; and &lt;code&gt;'$'&lt;/code&gt; are used at the same time, the regexp has to match both the beginning and the end of the string,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11c4b6b6311800f4181591dd698a41134ea1ef8b" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; are used at the same time, the regexp has to match both the beginning and the end of the string, i.e., the regexp matches the whole string. Consider</source>
          <target state="translated">当同时使用 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 时，正则表达式必须匹配字符串的开头和结尾，即，正则表达式匹配整个字符串。考虑</target>
        </trans-unit>
        <trans-unit id="0058d0939f56e0836aecac00731cc26dae5c908c" translate="yes" xml:space="preserve">
          <source>When both A and P are undefined, this is used as a fallback accuracy when dividing numbers.</source>
          <target state="translated">当A和P都未定义时,这是在除数时作为后备精度使用的。</target>
        </trans-unit>
        <trans-unit id="060766cfa822ddf97bd7bc65f3fc7e729b274423" translate="yes" xml:space="preserve">
          <source>When building 64-bit modules, it is your responsibility to ensure that linked external libraries and frameworks provide 64-bit support: if they do not, module building may appear to succeed, but attempts to use the module will result in run-time dynamic linking errors, and subsequent test failures. You can use &lt;code&gt;file&lt;/code&gt; to discover the architectures supported by a library:</source>
          <target state="translated">构建64位模块时，您有责任确保链接的外部库和框架提供64位支持：如果不提供，则模块构建可能会成功，但是尝试使用模块将导致运行时动态变化链接错误以及随后的测试失败。您可以使用 &lt;code&gt;file&lt;/code&gt; 来发现库支持的体系结构：</target>
        </trans-unit>
        <trans-unit id="d21008e482052b445cfd243ad8bc31adfd3249b5" translate="yes" xml:space="preserve">
          <source>When building Perl it will always return true, as nothing is installed yet.</source>
          <target state="translated">当构建Perl时,它将总是返回true,因为还没有安装任何东西。</target>
        </trans-unit>
        <trans-unit id="aaf49b07a212f715b8dd8f309b5c78af1bf1e342" translate="yes" xml:space="preserve">
          <source>When built on an ODS-5 volume with symbolic links enabled, Perl by default supports symbolic links when the requisite support is available in the filesystem and CRTL (generally 64-bit OpenVMS v8.3 and later). There are a number of limitations and caveats to be aware of when working with symbolic links on VMS. Most notably, the target of a valid symbolic link must be expressed as a Unix-style path and it must exist on a volume visible from your POSIX root (see the &lt;code&gt;SHOW ROOT&lt;/code&gt; command in DCL help). For further details on symbolic link capabilities and requirements, see chapter 12 of the CRTL manual that ships with OpenVMS v8.3 or later.</source>
          <target state="translated">当在启用了符号链接的ODS-5卷上构建时，默认情况下，当文件系统和CRTL（通常是64位OpenVMS v8.3和更高版本）中提供必要的支持时，Perl将支持符号链接。在VMS上使用符号链接时，需要注意许多限制和警告。最值得注意的是，有效符号链接的目标必须表示为Unix样式的路径，并且必须存在于POSIX根目录可见的卷上（请参阅DCL帮助中的 &lt;code&gt;SHOW ROOT&lt;/code&gt; 命令）。有关符号链接功能和要求的更多详细信息，请参阅OpenVMS v8.3或更高版本随附的CRTL手册的第12章。</target>
        </trans-unit>
        <trans-unit id="3274ae41eb972b48380cd0be38746ee76dc6d9df" translate="yes" xml:space="preserve">
          <source>When bundling is in effect, case is ignored on single-character options also.</source>
          <target state="translated">当捆绑生效时,单字符选项的大小写也会被忽略。</target>
        </trans-unit>
        <trans-unit id="534230020f5629c55b27da34563c08514a84a5c7" translate="yes" xml:space="preserve">
          <source>When calculating specific times, such as for tests in time or date modules, it may be appropriate to calculate an offset for the epoch.</source>
          <target state="translated">当计算特定的时间时,如在时间或日期模块中进行测试,可能需要计算一个纪元的偏移量。</target>
        </trans-unit>
        <trans-unit id="9da2af35b4e027fcb57324a97e158a9219d7749d" translate="yes" xml:space="preserve">
          <source>When called from a thread, this behaves like &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; (i.e., the exit status code is ignored).</source>
          <target state="translated">从线程调用时，其行为类似于 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; （即，退出状态代码将被忽略）。</target>
        </trans-unit>
        <trans-unit id="9c8531e379ee34158f961b216941a888acd13144" translate="yes" xml:space="preserve">
          <source>When called from the</source>
          <target state="translated">呼叫时,从</target>
        </trans-unit>
        <trans-unit id="43350391a792d394d51fbfdf3323ff9bf611b150" translate="yes" xml:space="preserve">
          <source>When called in a scalar context &lt;code&gt;strtod&lt;/code&gt; returns the parsed number.</source>
          <target state="translated">在标量上下文中调用时， &lt;code&gt;strtod&lt;/code&gt; 返回已解析的数字。</target>
        </trans-unit>
        <trans-unit id="da1211ed8e0b63c4bc2cdd7832083442b210dfa8" translate="yes" xml:space="preserve">
          <source>When called in a scalar context &lt;code&gt;strtol&lt;/code&gt; returns the parsed number.</source>
          <target state="translated">在标量上下文中调用时， &lt;code&gt;strtol&lt;/code&gt; 返回已解析的数字。</target>
        </trans-unit>
        <trans-unit id="cd23c4a922c775b095b3cd879f0e839934775a17" translate="yes" xml:space="preserve">
          <source>When called in list context, a filehandle to the open file and a filename are returned. This is achieved by calling mkstemp() after constructing a suitable template.</source>
          <target state="translated">当在列表上下文中调用时,将返回一个打开文件的filehandle和一个文件名。这是通过在构建一个合适的模板后调用mkstemp()实现的。</target>
        </trans-unit>
        <trans-unit id="c3dee4680a21f3b47b4b6c94d86c7920c11b3ca5" translate="yes" xml:space="preserve">
          <source>When called in scalar context, returns the full name (including path) of a temporary file (uses mktemp()). The only check is that the file does not already exist, but there is no guarantee that that condition will continue to apply.</source>
          <target state="translated">当在标量上下文中调用时,返回一个临时文件的全名(包括路径)(使用mktemp())。唯一的检查是该文件是否已经存在,但不保证该条件会继续适用。</target>
        </trans-unit>
        <trans-unit id="a89727e96b1fd47a54daec87adf9ead3599db8aa" translate="yes" xml:space="preserve">
          <source>When called on a hash in list context, returns a 2-element list consisting of the key and value for the next element of a hash. In Perl 5.12 and later only, it will also return the index and value for the next element of an array so that you can iterate over it; older Perls consider this a syntax error. When called in scalar context, returns only the key (not the value) in a hash, or the index in an array.</source>
          <target state="translated">当在列表上下文中调用哈希时,返回一个由哈希下一个元素的键和值组成的2元素列表。仅在Perl 5.12及以后的版本中,它还将返回数组中下一个元素的索引和值,这样你就可以在数组上进行迭代;旧版Perl认为这是一个语法错误。当在标量上下文中调用时,只返回哈希中的键(不是值),或者数组中的索引。</target>
        </trans-unit>
        <trans-unit id="a0114581d0437322ee0322acd573e8db3818a675" translate="yes" xml:space="preserve">
          <source>When called with a port number, the port number used to ping is set to $port_number rather than using the echo port. It also has the effect of calling &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; causing a ping to return a successful response only if that specific port is accessible. This function returns the value of the port that &lt;code&gt;ping()&lt;/code&gt; will connect to.</source>
          <target state="translated">当使用端口号调用时，用于ping的端口号设置为$ port_number而不是使用echo端口。它还具有调用 &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; 的作用，仅当该特定端口可访问时，ping才会返回成功的响应。此函数返回 &lt;code&gt;ping()&lt;/code&gt; 将连接的端口的值。</target>
        </trans-unit>
        <trans-unit id="bb2e5aa5eca539163667dc50950bd9be7faf4a0e" translate="yes" xml:space="preserve">
          <source>When called with a port number, the port number used to ping is set to &lt;code&gt;$port_number&lt;/code&gt; rather than using the echo port. It also has the effect of calling &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; causing a ping to return a successful response only if that specific port is accessible. This function returns the value of the port that &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; will connect to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e732b0f6b3939ab5bc51276cb4115c5f3c0e3c" translate="yes" xml:space="preserve">
          <source>When called with a property that is a Perl extension that isn't expressible in a compound form, this function currently returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, as the only two possible values are</source>
          <target state="translated">当使用无法以复合形式表示的Perl扩展属性来调用该函数时，此函数当前返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，因为只有两个可能的值是</target>
        </trans-unit>
        <trans-unit id="2e2733df3349090a28007f289ac824ddf07cc93b" translate="yes" xml:space="preserve">
          <source>When called with a property that is a Perl extension that isn't expressible in a compound form, this function currently returns &lt;code&gt;undef&lt;/code&gt;, as the only two possible values are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f088f6cc700d00236d5621c430de681ccc4d48" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;Mksymlists&lt;/code&gt; , one should always specify the NAME attribute. In most cases, this is all that's necessary. In the case of unusual extensions, however, the other attributes can be used to provide additional information to the linker.</source>
          <target state="translated">调用 &lt;code&gt;Mksymlists&lt;/code&gt; 时，应始终指定NAME属性。在大多数情况下，这就是必需的。但是，在异常扩展的情况下，其他属性可以用于向链接器提供其他信息。</target>
        </trans-unit>
        <trans-unit id="07b982cff05e80c95f9bd4378e83247343baa2a1" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;Mksymlists&lt;/code&gt;, one should always specify the NAME attribute. In most cases, this is all that's necessary. In the case of unusual extensions, however, the other attributes can be used to provide additional information to the linker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af437b4f9240cadad3ac33b8f68ddc8397121022" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;open&lt;/code&gt; with three or more arguments, the second argument -- labeled MODE here -- defines the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb764d0e74f6cde0aeec88532fcd886bfa4b9853" translate="yes" xml:space="preserve">
          <source>When choosing a language you should also be influenced by the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;resources&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpantesters.org%2f&quot;&gt;testing culture&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fcommunity.html&quot;&gt;community&lt;/a&gt; which surrounds it.</source>
          <target state="translated">选择语言时，还应该受到&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;资源&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpantesters.org%2f&quot;&gt;测试文化&lt;/a&gt;和周围&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fcommunity.html&quot;&gt;社区的&lt;/a&gt;影响。</target>
        </trans-unit>
        <trans-unit id="951b540f9fcad327b03714e446667ac4225ce0b0" translate="yes" xml:space="preserve">
          <source>When choosing a language you should also be influenced by the &lt;a href=&quot;http://www.cpan.org/&quot;&gt;resources&lt;/a&gt;, &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;testing culture&lt;/a&gt; and &lt;a href=&quot;http://www.perl.org/community.html&quot;&gt;community&lt;/a&gt; which surrounds it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28fc2ee6241766189106d0612895f0d6c35cb4ac" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; accepts.</source>
          <target state="translated">选择新的盐时，创建一个随机的两个字符串，其字符来自集合 &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; （例如 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ）。这组字符只是一个建议；盐中允许的字符仅取决于系统的crypt库，Perl不能限制 &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; 接受的盐。</target>
        </trans-unit>
        <trans-unit id="8df52c6dbe1d57b617631599c530a100984708ce" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; accepts.</source>
          <target state="translated">选择新的盐时，创建一个随机的两个字符串，其字符来自集合 &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; （例如 &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ）。这组字符只是一个建议；盐中允许的字符仅取决于系统的crypt库，Perl不能限制 &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; 接受的盐。</target>
        </trans-unit>
        <trans-unit id="e49bb7c565d73664ea0f3cf904e4a0b82673adbe" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;join '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]&lt;/code&gt;). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; accepts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45013cd9275f891a2dc688887309ce7d0907108" translate="yes" xml:space="preserve">
          <source>When combined with variable declaration, simple assignment to &lt;code&gt;state&lt;/code&gt; variables (as in &lt;code&gt;state $x = 42&lt;/code&gt;) is executed only the first time. When such statements are evaluated subsequent times, the assignment is ignored. The behavior of assignment to &lt;code&gt;state&lt;/code&gt; declarations where the left hand side of the assignment involves any parentheses is currently undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba90a2d042a133e843c0ea1363bae85f48e8fd9f" translate="yes" xml:space="preserve">
          <source>When combined with variable declaration, simple scalar assignment to &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables (as in &lt;code&gt;state $x = 42&lt;/code&gt; ) is executed only the first time. When such statements are evaluated subsequent times, the assignment is ignored. The behavior of this sort of assignment to non-scalar variables is undefined.</source>
          <target state="translated">与变量声明结合使用时，仅第一次执行对 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 变量的简单标量分配（如 &lt;code&gt;state $x = 42&lt;/code&gt; ）。以后评估此类语句时，将忽略该分配。此类分配给非标量变量的行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="8723e913d037ae6e1a9af1f510a75733eba10e88" translate="yes" xml:space="preserve">
          <source>When comparing &lt;code&gt;$]&lt;/code&gt; , string comparison operators are &lt;b&gt;highly recommended&lt;/b&gt;. The inherent limitations of binary floating point representation can sometimes lead to incorrect comparisons for some numbers on some architectures.</source>
          <target state="translated">比较 &lt;code&gt;$]&lt;/code&gt; 时，&lt;b&gt;强烈建议使用&lt;/b&gt;字符串比较运算符。二进制浮点表示法的固有局限性有时会导致在某些体系结构上对某些数字进行不正确的比较。</target>
        </trans-unit>
        <trans-unit id="d63ec10981e83d5b4bca0c38c0d5eae2039c39d3" translate="yes" xml:space="preserve">
          <source>When comparing &lt;code&gt;$]&lt;/code&gt;, numeric comparison operators should be used, but the variable should be stringified first to avoid issues where its original numeric value is inaccurate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65db1f7efa45a9d6174eb5b40e9d8d8f3e843e34" translate="yes" xml:space="preserve">
          <source>When compiled within the scope of &lt;code&gt;use locale&lt;/code&gt; (or the &lt;code&gt;/l&lt;/code&gt; regex modifier), this construct assumes that the execution-time locale will be a UTF-8 one, and the generated pattern always uses Unicode rules. What gets matched or not thus isn't dependent on the actual runtime locale, so tainting is not enabled. But a &lt;code&gt;locale&lt;/code&gt; category warning is raised if the runtime locale turns out to not be UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb0233568f5abd1d88fb8340be5337623b26d31" translate="yes" xml:space="preserve">
          <source>When compiling Perl in Tru64 you may (depending on the compiler release) see two warnings like this</source>
          <target state="translated">当在Tru64中编译Perl时,你可能会看到两个警告,比如说</target>
        </trans-unit>
        <trans-unit id="bfc6666c4c5744908a4efd082506a76f331670ff" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C compiler with AIX by default, but binary builds of gcc for AIX are widely available. A version of gcc is also included in the AIX Toolbox which is shipped with AIX.</source>
          <target state="translated">当编译Perl时,你必须使用ANSI C编译器。AIX默认不提供符合ANSI标准的C编译器,但AIX的gcc二进制编译器可以广泛使用。AIX工具箱中也包含了gcc的版本,它是随AIX一起提供的。</target>
        </trans-unit>
        <trans-unit id="f65988610c7d74b5ae9b07dd95c21b84e89fdc66" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C-compiler with AIX by default, but binary builds of gcc for AIX are widely available.</source>
          <target state="translated">当编译Perl时,你必须使用ANSI C编译器。AIX默认不提供符合ANSI标准的C编译器,但AIX的gcc二进制编译器可以广泛使用。</target>
        </trans-unit>
        <trans-unit id="e54d0f630f4052fa4f5e8949b94bd1a858274b61" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. The C compiler that ships with all HP-UX systems is a K&amp;amp;R compiler that should only be used to build new kernels.</source>
          <target state="translated">编译Perl时，必须使用ANSI C编译器。所有HP-UX系统随附的C编译器是K＆R编译器，仅应用于构建新内核。</target>
        </trans-unit>
        <trans-unit id="396066667b73652500c61d9a6b382668c31190fa" translate="yes" xml:space="preserve">
          <source>When compiling in PASE, there is no &quot;oslevel&quot; command. Therefore, you may want to create a script called &quot;oslevel&quot; that echoes the level of AIX that your version of PASE runtime supports. If you're unsure, consult your documentation or use &quot;4.3.3.0&quot;.</source>
          <target state="translated">当在PASE中编译时,没有 &quot;oslevel &quot;命令,因此,你可能需要创建一个名为 &quot;oslevel &quot;的脚本来呼应你的PASE运行时版本所支持的AIX级别。因此,你可能需要创建一个名为 &quot;oslevel &quot;的脚本,以呼应你的PASE运行时版本所支持的AIX级别。如果你不确定,请查阅你的文档或使用 &quot;4.3.3.0&quot;。</target>
        </trans-unit>
        <trans-unit id="975dca0ce3b92270da7ce263ccd6670142595f91" translate="yes" xml:space="preserve">
          <source>When complementing strings, if all characters have ordinal values under 256, then their complements will, also. But if they do not, all characters will be in either 32- or 64-bit complements, depending on your architecture. So for example, &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; is &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; on 32-bit machines and &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; on 64-bit machines.</source>
          <target state="translated">当对字符串进行补码时，如果所有字符的序数值都小于256，则它们的补码也将变为。但是，如果不这样做，则所有字符都将使用32位或64位补码，具体取决于您的体系结构。因此，例如，在32位计算机上， &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; 是 &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; ，在64位计算机上是 &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="927dc05b306a20a322eed6c8168ca784ea3ed41b" translate="yes" xml:space="preserve">
          <source>When configured for bundling, single-character options are matched case sensitive while long options are matched case insensitive. To have the single-character options matched case insensitive as well, use:</source>
          <target state="translated">当配置为捆绑时,单字符选项会区分大小写,而长选项则不区分大小写。要让单字符选项也不区分大小写,请使用:</target>
        </trans-unit>
        <trans-unit id="0832ec483e29be38d2d70bb452597a0c3e196f7f" translate="yes" xml:space="preserve">
          <source>When converting POD source from standard input, the name will be set to &lt;code&gt;STDIN&lt;/code&gt; if this option is not provided. Providing this option is strongly recommended to set a meaningful manual page name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4fb4623ce7c6c321834d001ce6f813a2fa89505" translate="yes" xml:space="preserve">
          <source>When creating and extending application programming interfaces (APIs) for Symbian or Series 60 or Series 80 or Series 90 it is suggested that trademarks, registered trademarks, or trade names are not used in the API names. Instead, developers should consider basing the API naming in the existing (C++, or maybe Java) public component and API naming, modified as appropriate by the rules of the programming language the new APIs are for.</source>
          <target state="translated">当为Symbian或Series 60或Series 80或Series 90创建和扩展应用程序编程接口(API)时,建议不要在API名称中使用商标、注册商标或商品名称。相反,开发者应该考虑以现有的(C++,或者Java)公共组件和API命名为基础,并根据新的API所使用的编程语言的规则进行适当修改。</target>
        </trans-unit>
        <trans-unit id="6e1a716be153bacd455cdea13693b585d200816e" translate="yes" xml:space="preserve">
          <source>When data are cleaned and standardized, missing or invalid fields will be replaced with sensible defaults when possible. This may be lossy or imprecise. For example, some badly structured META.yml files on CPAN have prerequisite modules listed as both keys and values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc80c71b0aa717f38046cb0d740616e9bd6381f" translate="yes" xml:space="preserve">
          <source>When dealing with C structures one should select either &lt;b&gt;T_PTROBJ&lt;/b&gt; or &lt;b&gt;T_PTRREF&lt;/b&gt; for the XS type. Both types are designed to handle pointers to complex objects. The T_PTRREF type will allow the Perl object to be unblessed while the T_PTROBJ type requires that the object be blessed. By using T_PTROBJ one can achieve a form of type-checking because the XSUB will attempt to verify that the Perl object is of the expected type.</source>
          <target state="translated">处理C结构时，应为XS类型选择&lt;b&gt;T_PTROBJ&lt;/b&gt;或&lt;b&gt;T_PTRREF&lt;/b&gt;。两种类型都旨在处理指向复杂对象的指针。T_PTRREF类型将使Perl对象不受祝福，而T_PTROBJ类型要求使对象受祝福。通过使用T_PTROBJ，可以实现一种类型检查，因为XSUB会尝试验证Perl对象是否为预期的类型。</target>
        </trans-unit>
        <trans-unit id="5ef807c417305a11bdb217741916eb3c09e8b5cd" translate="yes" xml:space="preserve">
          <source>When dealing with binary files (or text files in binary mode) be sure to explicitly set $/ to the appropriate value for your file format before using &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">处理二进制文件（或二进制模式的文本文件）时，请确保在使用 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; 之前将$ /显式设置为文件格式的适当值。</target>
        </trans-unit>
        <trans-unit id="c2eed87ac3725b6497a344941a7436efeb6e56a3" translate="yes" xml:space="preserve">
          <source>When dealing with binary files (or text files in binary mode) be sure to explicitly set &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; to the appropriate value for your file format before using &lt;a href=&quot;perlfunc#chomp-VARIABLE&quot;&gt;&lt;code&gt;chomp&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d089cbb7da6fb1de4b8e802beb51489b821fccc7" translate="yes" xml:space="preserve">
          <source>When dealing with references, it is important to handle them with caution. The &lt;code&gt;INIT:&lt;/code&gt; block first calls SvGETMAGIC(paths), in case paths is a tied variable. Then it checks that &lt;code&gt;SvROK&lt;/code&gt; returns true, which indicates that paths is a valid reference. (Simply checking &lt;code&gt;SvROK&lt;/code&gt; won't trigger FETCH on a tied variable.) It then verifies that the object referenced by paths is an array, using &lt;code&gt;SvRV&lt;/code&gt; to dereference paths, and &lt;code&gt;SvTYPE&lt;/code&gt; to discover its type. As an added test, it checks that the array referenced by paths is non-empty, using the &lt;code&gt;av_top_index&lt;/code&gt; function (which returns -1 if the array is empty). The XSRETURN_UNDEF macro is used to abort the XSUB and return the undefined value whenever all three of these conditions are not met.</source>
          <target state="translated">处理参考文献时，请务必谨慎处理。该 &lt;code&gt;INIT:&lt;/code&gt; 块首先调用SvGETMAGIC（路径），如果路径是并列的变量。然后，它检查 &lt;code&gt;SvROK&lt;/code&gt; 是否返回true，这表示路径是有效的引用。 （仅检查 &lt;code&gt;SvROK&lt;/code&gt; 不会触发绑定变量上的FETCH。）然后使用 &lt;code&gt;SvRV&lt;/code&gt; 取消引用路径，并使用 &lt;code&gt;SvTYPE&lt;/code&gt; 来发现路径引用的对象是否是数组。作为附加测试，它使用 &lt;code&gt;av_top_index&lt;/code&gt; 检查路径引用的数组是否为非空函数（如果数组为空，则返回-1）。XSRETURN_UNDEF宏用于中止XSUB并在不满足所有这三个条件的情况下返回未定义的值。</target>
        </trans-unit>
        <trans-unit id="38a7bf875048ed175efb40337595a64499d137a5" translate="yes" xml:space="preserve">
          <source>When dealing with strings containing characters that cannot be represented using an eight-bit character set, perl uses an internal representation that is a permissive version of Unicode's UTF-8 encoding[2]. This uses single bytes to represent characters from the ASCII character set, and sequences of two or more bytes for all other characters. (See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more information about the relationship between UTF-8 and perl's encoding, utf8. The difference isn't important for this discussion.)</source>
          <target state="translated">当处理包含无法使用八位字符集表示的字符的字符串时，perl使用内部表示形式，它是Unicode的UTF-8编码的允许版本[2]。它使用单个字节来表示ASCII字符集中的字符，并使用两个或多个字节的序列来表示所有其他字符。（有关UTF-8和perl编码utf8之间关系的更多信息，请参见&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;。区别对于本讨论而言并不重要。）</target>
        </trans-unit>
        <trans-unit id="ec373fa59b49b953efac841d6f570fdf4b7bbe64" translate="yes" xml:space="preserve">
          <source>When debugging a script that uses #! and is thus normally found in $PATH, the -S option causes perl to search $PATH for it, so you don't have to type the path or &lt;code&gt;which $scriptname&lt;/code&gt; .</source>
          <target state="translated">调试使用＃！的脚本时 因此通常在$ PATH中找到-S选项使perl在$ PATH中搜索它，因此您不必键入路径或 &lt;code&gt;which $scriptname&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="defb50e120fb7902c1ad7735f710efb52d461bf8" translate="yes" xml:space="preserve">
          <source>When debugging a script that uses #! and is thus normally found in $PATH, the -S option causes perl to search $PATH for it, so you don't have to type the path or &lt;code&gt;which $scriptname&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c091d3205ab1a4db30cd1f652d642a63585b86ed" translate="yes" xml:space="preserve">
          <source>When defined, remove the legacy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd1aac87a1a4ead57eced3127ad85f26b16823a" translate="yes" xml:space="preserve">
          <source>When defining hints, you can either supply both &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;scalar&lt;/code&gt; keywords,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6fa41bd97a298d1cd8b0e0f363528cda01ea2a0" translate="yes" xml:space="preserve">
          <source>When defining multiple constants, you cannot use the values of other constants defined in the same declaration. This is because the calling package doesn't know about any constant within that group until</source>
          <target state="translated">当定义多个常量时,您不能使用在同一声明中定义的其他常量的值。这是因为在调用包时,直到</target>
        </trans-unit>
        <trans-unit id="ffb15fb0d6730c3726c9bf86322c62258c95b95a" translate="yes" xml:space="preserve">
          <source>When deleting a definition, this bit causes each &lt;code&gt;$sTargetPath&lt;/code&gt; to be compared to the full-length definition when searching for the most recently added match. If this bit is not set, then &lt;code&gt;$sTargetPath&lt;/code&gt; only needs to match a prefix of the definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5777270f296102b587f7b9de510c0b0ddda1bbd9" translate="yes" xml:space="preserve">
          <source>When describing the merge commit, explain the purpose of the branch, and keep in mind that this description will probably be used by the eventual release engineer when reviewing the next perldelta document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9045da0fde8e0464c72a9687c675b21416ee8e" translate="yes" xml:space="preserve">
          <source>When designing Maketext, I chose to plan its main features in terms of &quot;buzzword compliance&quot;. And here are the buzzwords:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4723c71ed09d6ef17fa09da9076bcc24872495e5" translate="yes" xml:space="preserve">
          <source>When designing an interface between Perl and a C library a straight translation from C to XS (such as created by &lt;code&gt;h2xs -x&lt;/code&gt; ) is often sufficient. However, sometimes the interface will look very C-like and occasionally nonintuitive, especially when the C function modifies one of its parameters, or returns failure inband (as in &quot;negative return values mean failure&quot;). In cases where the programmer wishes to create a more Perl-like interface the following strategy may help to identify the more critical parts of the interface.</source>
          <target state="translated">在Perl和C库之间设计接口时，从C到XS的直接转换（例如由 &lt;code&gt;h2xs -x&lt;/code&gt; 创建）通常就足够了。但是，有时接口看起来会非常像C，有时甚至是非直觉的，特别是当C函数修改其参数之一或带内返回失败时（如&amp;ldquo;负返回值意味着失败&amp;rdquo;）。在程序员希望创建更像Perl的界面的情况下，以下策略可能有助于识别界面中更关键的部分。</target>
        </trans-unit>
        <trans-unit id="aa2910d5c8edb2a11952d853cabc19faa12f6ab8" translate="yes" xml:space="preserve">
          <source>When designing an interface between Perl and a C library a straight translation from C to XS (such as created by &lt;code&gt;h2xs -x&lt;/code&gt;) is often sufficient. However, sometimes the interface will look very C-like and occasionally nonintuitive, especially when the C function modifies one of its parameters, or returns failure inband (as in &quot;negative return values mean failure&quot;). In cases where the programmer wishes to create a more Perl-like interface the following strategy may help to identify the more critical parts of the interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a3b14a33a7328d3c4446b4818b46b0e10681a93" translate="yes" xml:space="preserve">
          <source>When developing interactive and/or potentially long-running applications, it's a good idea to maintain a persistent interpreter rather than allocating and constructing a new interpreter multiple times. The major reason is speed: since Perl will only be loaded into memory once.</source>
          <target state="translated">在开发交互式和/或潜在的长期运行的应用程序时,维护一个持久解释器而不是多次分配和构造一个新的解释器是个好主意。主要的原因是速度:因为Perl只会被载入一次内存。</target>
        </trans-unit>
        <trans-unit id="fbc30eeb77b449fcef99048d57b0caf5a9160153" translate="yes" xml:space="preserve">
          <source>When do I use SKIP vs. TODO?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6878bf07602f9398e0aebf78788b970eee0437" translate="yes" xml:space="preserve">
          <source>When doing XS / Symbian C++ programming include first the Symbian headers, then any standard C/POSIX headers, then Perl headers, and finally any application headers.</source>
          <target state="translated">当进行XS/Symbian C++编程时,首先包括Symbian头文件,然后是任何标准的C/POSIX头文件,然后是Perl头文件,最后是任何应用程序头文件。</target>
        </trans-unit>
        <trans-unit id="68e541a18f2f1ca2cdf86c535b1f959438918ee4" translate="yes" xml:space="preserve">
          <source>When downloading from CPAN, save your file with a &lt;code&gt;.tgz&lt;/code&gt; extension instead of &lt;code&gt;.tar.gz&lt;/code&gt;. All other periods in the filename should be replaced with underscores. For example, &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; should be downloaded as &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt;.</source>
          <target state="translated">从CPAN下载时，请使用 &lt;code&gt;.tgz&lt;/code&gt; 扩展名而不是 &lt;code&gt;.tar.gz&lt;/code&gt; 保存文件。文件名中的所有其他句点都应替换为下划线。例如，应将 &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; 下载为 &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a4bca7ef82b244e2bfab60f9ed2d006dc99b5fe" translate="yes" xml:space="preserve">
          <source>When each filter is called by Perl, a local copy of &lt;code&gt;$_&lt;/code&gt; will contain the key or value to be filtered. Filtering is achieved by modifying the contents of &lt;code&gt;$_&lt;/code&gt; . The return code from the filter is ignored.</source>
          <target state="translated">当Perl调用每个过滤器时， &lt;code&gt;$_&lt;/code&gt; 的本地副本将包含要过滤的键或值。通过修改 &lt;code&gt;$_&lt;/code&gt; 的内容来实现过滤。过滤器的返回码将被忽略。</target>
        </trans-unit>
        <trans-unit id="37bc6f2fee508f42f859a937c741e1314dc47c4d" translate="yes" xml:space="preserve">
          <source>When each filter is called by Perl, a local copy of &lt;code&gt;$_&lt;/code&gt; will contain the key or value to be filtered. Filtering is achieved by modifying the contents of &lt;code&gt;$_&lt;/code&gt;. The return code from the filter is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a0c84572d5c8f36ddeeedc2b34034d9368a3d3" translate="yes" xml:space="preserve">
          <source>When embedded code is quantified, successful matches will call the code once for each matched iteration of the quantifier. For example:</source>
          <target state="translated">当嵌入式代码被量化时,成功匹配的代码将对量化器的每一次匹配迭代调用一次。例如:</target>
        </trans-unit>
        <trans-unit id="b2de387631853c970d098f700c90774516567311" translate="yes" xml:space="preserve">
          <source>When evaluated, the typeglob produces a scalar value that represents all the objects of that name, including any filehandle, format, or subroutine. When assigned to, it causes the name mentioned to refer to whatever &lt;code&gt;*&lt;/code&gt; value was assigned to it. Example:</source>
          <target state="translated">在评估时，typeglob产生一个标量值，代表该名称的所有对象，包括任何文件句柄，格式或子例程。分配给它时，它使提到的名称引用分配给它的任何 &lt;code&gt;*&lt;/code&gt; 值。例：</target>
        </trans-unit>
        <trans-unit id="4c69b020552d0b8ae9319c611f51330e0fd5df99" translate="yes" xml:space="preserve">
          <source>When exec() is called inside a pseudo-process then DESTROY methods and END blocks will still be called after the external process returns.</source>
          <target state="translated">当在伪进程内部调用exec()时,那么在外部进程返回后,仍然会调用DESTROY方法和END块。</target>
        </trans-unit>
        <trans-unit id="8c7eebc997f4f93f028327a4f1ff0c0608dc29e2" translate="yes" xml:space="preserve">
          <source>When execution of the program reaches a subroutine call, a call to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</source>
          <target state="translated">当程序执行到达子例程调用时，将调用 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; （</target>
        </trans-unit>
        <trans-unit id="e34ca66c0a813d790613eb9e5cc3ba8d52f5c3fa" translate="yes" xml:space="preserve">
          <source>When execution of the program reaches a subroutine call, a call to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt;(</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b8b87da2107f5f6b07c4ad0b8f0c3bd9b3e2787" translate="yes" xml:space="preserve">
          <source>When execution of the program uses &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; to enter a non-XS subroutine and the 0x80 bit is set in &lt;code&gt;$^P&lt;/code&gt; , a call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; is made, with &lt;code&gt;$DB::sub&lt;/code&gt; holding the name of the subroutine being entered.</source>
          <target state="translated">当程序执行使用 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 输入非XS子例程，并且 &lt;code&gt;$^P&lt;/code&gt; 的0x80位置1时，将调用 &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; ，其中 &lt;code&gt;$DB::sub&lt;/code&gt; 保留要输入的子例程的名称。</target>
        </trans-unit>
        <trans-unit id="46697cf78f9bb3bd5dc8972ced50ec3e3d6c90ea" translate="yes" xml:space="preserve">
          <source>When execution of the program uses &lt;code&gt;goto&lt;/code&gt; to enter a non-XS subroutine and the 0x80 bit is set in &lt;code&gt;$^P&lt;/code&gt;, a call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; is made, with &lt;code&gt;$DB::sub&lt;/code&gt; set to identify the subroutine being entered. The call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; does not replace the &lt;code&gt;goto&lt;/code&gt;; the requested subroutine will still be entered once &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; has returned. &lt;code&gt;$DB::sub&lt;/code&gt; normally holds the name of the subroutine being entered, if it has one. Failing that, &lt;code&gt;$DB::sub&lt;/code&gt; will hold a reference to the subroutine being entered. Unlike when &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; is called, it is not guaranteed that &lt;code&gt;$DB::sub&lt;/code&gt; can be used as a reference to operate on the subroutine being entered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7780be4ab5e34307ca9834bebf3c5ea11f2bda2" translate="yes" xml:space="preserve">
          <source>When exitcode is non-zero, a message box appears, otherwise the console closes, so you might have to catch an exit with status 0 in your program to see any output.</source>
          <target state="translated">当exitcode为非零时,会出现一个消息框,否则控制台就会关闭,所以你可能要在程序中抓到一个状态为0的退出才能看到任何输出。</target>
        </trans-unit>
        <trans-unit id="6f3c5ccbe8b2049e627d85f2a9ec69ec19650c45" translate="yes" xml:space="preserve">
          <source>When false the information is not considered critical and may not be rendered in less-verbose modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b361c8c46cd947899ffa296e187a289b54d8046a" translate="yes" xml:space="preserve">
          <source>When field hashes are used, the basic structure remains the same. Each lexical hash will be made a field hash. The call to &lt;code&gt;refaddr&lt;/code&gt; can be omitted from the accessor methods. DESTROY and CLONE methods are not necessary.</source>
          <target state="translated">使用字段哈希时，基本结构保持不变。每个词法哈希将成为字段哈希。可以从访问器方法中省略对 &lt;code&gt;refaddr&lt;/code&gt; 的调用。不需要DESTROY和CLONE方法。</target>
        </trans-unit>
        <trans-unit id="7ff1c534eb53fb9adf1f1f7cdd902bdbfec52451" translate="yes" xml:space="preserve">
          <source>When finding a program to run, Perl first asks the OS to look for executables on &lt;code&gt;PATH&lt;/code&gt; (OS/2 adds extension</source>
          <target state="translated">找到要运行的程序时，Perl首先要求操作系统在 &lt;code&gt;PATH&lt;/code&gt; 上查找可执行文件（OS / 2添加了扩展名</target>
        </trans-unit>
        <trans-unit id="13a2688e14421cbafe067aeaa351f65e3474e11f" translate="yes" xml:space="preserve">
          <source>When finished, &lt;code&gt;$input&lt;/code&gt; will be completely processed (assuming there were no errors). If the deflation was successful it writes the deflated data to &lt;code&gt;$output&lt;/code&gt; and returns a status value of &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">完成后， &lt;code&gt;$input&lt;/code&gt; 将被完全处理（假设没有错误）。如果放气成功，则将放气的数据写入 &lt;code&gt;$output&lt;/code&gt; 并返回状态值 &lt;code&gt;Z_OK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98115fd081a8900c4523336f3adbeaa8265d8ece" translate="yes" xml:space="preserve">
          <source>When finished, &lt;code&gt;$input&lt;/code&gt; will be completely processed (assuming there were no errors). If the deflation was successful it writes the deflated data to &lt;code&gt;$output&lt;/code&gt; and returns a status value of &lt;code&gt;Z_OK&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fcfed4a8d779393f6607570b9bb7471da1de1d1" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; is actually a flow control statement rather than a function. If there is a &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt;), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; statement (which is similar to the C &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; statement).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d09ef2037aaa8553df4a9d1d56e3501c5f5a619" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">当后跟一个BLOCK时， &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 实际上是一个流控制语句而不是一个函数。如果有一个 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 连接到一个BLOCK（通常为BLOCK &lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;foreach&lt;/code&gt; ），前条件即将被再次评价，就像的第三部分它总是只执行 &lt;code&gt;for&lt;/code&gt; 在C.循环因此它可以是用于增加循环变量，即使通过 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 一条语句（类似于C的 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 语句）继续执行了循环也是如此。</target>
        </trans-unit>
        <trans-unit id="2cd67d2b65a87b65d002d9fa075eef11fc3372a5" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">当后跟一个BLOCK时， &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 实际上是一个流控制语句而不是一个函数。如果有一个 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 连接到一个BLOCK（通常为BLOCK &lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;foreach&lt;/code&gt; ），前条件即将被再次评价，就像的第三部分它总是只执行 &lt;code&gt;for&lt;/code&gt; 在C.循环因此它可以是用于增加循环变量，即使通过 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 一条语句（类似于C的 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 语句）继续执行了循环也是如此。</target>
        </trans-unit>
        <trans-unit id="aa8159a0d83694276288a2a5fe07fe61d16edc97" translate="yes" xml:space="preserve">
          <source>When functions within an XS source file must be separated into packages the PACKAGE keyword should be used. This keyword is used with the MODULE keyword and must follow immediately after it when used.</source>
          <target state="translated">当XS源文件中的函数必须被分离成包时,应该使用PACKAGE关键字。这个关键字与MODULE关键字一起使用,使用时必须紧跟在它后面。</target>
        </trans-unit>
        <trans-unit id="c6f577a0659ee785a75d16bfb954974346b28a9b" translate="yes" xml:space="preserve">
          <source>When given an ambiguous local time, the timelocal() function should always return the epoch for the</source>
          <target state="translated">当给定一个不明确的本地时间时,函数timelocal()应该总是返回该时间的纪元。</target>
        </trans-unit>
        <trans-unit id="905210e566be8553d344f14d5ca8c62a30b6a0a2" translate="yes" xml:space="preserve">
          <source>When handling output parameters with a PPCODE section, be sure to handle 'set' magic properly. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for details about 'set' magic.</source>
          <target state="translated">当使用PPCODE部分处理输出参数时，请确保正确处理&amp;ldquo; set&amp;rdquo;魔术。有关&amp;ldquo;设置&amp;rdquo;魔术的详细信息，请参见&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5bd61549e044c4efead59e04ed6605311709e2f3" translate="yes" xml:space="preserve">
          <source>When in doubt, before you do anything else, check your status and read it carefully, many questions are answered directly by the git status output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76666973f161e896d15ace4d3f87a7a9c3ef5759" translate="yes" xml:space="preserve">
          <source>When in doubt, parenthesize. At the very least it will let some poor schmuck bounce on the % key in &lt;b&gt;vi&lt;/b&gt;.</source>
          <target state="translated">如有疑问，请加上括号。至少它将使&lt;b&gt;vi中&lt;/b&gt;的％键有些糟糕的弹跳弹起。</target>
        </trans-unit>
        <trans-unit id="b4688043e9a06a71613858ea73f001a633497cb7" translate="yes" xml:space="preserve">
          <source>When in doubt, run the &lt;b&gt;awk&lt;/b&gt; construct through &lt;b&gt;a2p&lt;/b&gt; and see what it gives you.</source>
          <target state="translated">如有疑问，请通过&lt;b&gt;a2p&lt;/b&gt;运行&lt;b&gt;awk&lt;/b&gt;构造，并查看其提供的功能。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c9ab777cdba3a81e6f12be90b090ea8b365cf98" translate="yes" xml:space="preserve">
          <source>When in doubt, you can use</source>
          <target state="translated">当有疑问时,您可以使用</target>
        </trans-unit>
        <trans-unit id="6948014018e5357f830915cd0ed311117487ecb2" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">当作为 &lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; 调用时，将识别以下选项：</target>
        </trans-unit>
        <trans-unit id="cc36b4e11ce2156b2b41d828826a07de94fcec39" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">当作为 &lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; 调用时，将识别以下选项：</target>
        </trans-unit>
        <trans-unit id="ee150951d5eb2b6fd45fd97edec569546ed48f9b" translate="yes" xml:space="preserve">
          <source>When invoked using a single string, &lt;b&gt;parseopts&lt;/b&gt; treats the string as the name of a parse-option and returns its corresponding value if it exists (returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it doesn't).</source>
          <target state="translated">当使用单个字符串调用时，&lt;b&gt;parseopts&lt;/b&gt;将字符串视为parse-option的名称，如果存在则返回其对应的值（如果不存在则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7277cd46617f74f2842ee4af54a1d49db21e598b" translate="yes" xml:space="preserve">
          <source>When invoked with multiple arguments, &lt;b&gt;parseopts&lt;/b&gt; treats them as key/value pairs and the specified parse-option names are set to the given values. Any unspecified parse-options are unaffected.</source>
          <target state="translated">当使用多个参数调用时，&lt;b&gt;parseopts&lt;/b&gt;将它们视为键/值对，并且将指定的parse-option名称设置为给定值。任何未指定的解析选项均不受影响。</target>
        </trans-unit>
        <trans-unit id="f1033de63c389a24f6517627a4b9b4657247752f" translate="yes" xml:space="preserve">
          <source>When invoked with no additional arguments, &lt;b&gt;parseopts&lt;/b&gt; returns a hashtable of all the current parsing options.</source>
          <target state="translated">当不带其他参数调用时，&lt;b&gt;parseopts&lt;/b&gt;返回所有当前解析选项的哈希表。</target>
        </trans-unit>
        <trans-unit id="8a84fb9fbc48134e4aa29a0c0010fa21ec733eeb" translate="yes" xml:space="preserve">
          <source>When invoked with parameters the following are accepted and optional:</source>
          <target state="translated">当调用时,可以接受和选择以下参数。</target>
        </trans-unit>
        <trans-unit id="3db92287943a254b1a1b0d74b4c460a69a45306e" translate="yes" xml:space="preserve">
          <source>When is a bool not a bool?</source>
          <target state="translated">什么时候布尔不是布尔?</target>
        </trans-unit>
        <trans-unit id="7b77a4a5d5b65846fa5a3f0440157e545f392596" translate="yes" xml:space="preserve">
          <source>When it appears singly, it causes the sequences &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt; , and the Posix character classes to match only in the ASCII range. They thus revert to their pre-5.6, pre-Unicode meanings. Under &lt;code&gt;/a&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; always means precisely the digits &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &lt;code&gt;&quot;9&quot;&lt;/code&gt; ; &lt;code&gt;\s&lt;/code&gt; means the five characters &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; , and starting in Perl v5.18, the vertical tab; &lt;code&gt;\w&lt;/code&gt; means the 63 characters &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ; and likewise, all the Posix classes such as &lt;code&gt;[[:print:]]&lt;/code&gt; match only the appropriate ASCII-range characters.</source>
          <target state="translated">当它单独出现时，会导致序列 &lt;code&gt;\d&lt;/code&gt; ， &lt;code&gt;\s&lt;/code&gt; ， &lt;code&gt;\w&lt;/code&gt; 和Posix字符类仅在ASCII范围内匹配。因此，它们恢复为5.6之前的版本，Unicode之前的含义。在 &lt;code&gt;/a&lt;/code&gt; 下， &lt;code&gt;\d&lt;/code&gt; 始终精确地表示数字 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 至 &lt;code&gt;&quot;9&quot;&lt;/code&gt; ； &lt;code&gt;\s&lt;/code&gt; 表示五个字符 &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; ，从Perl v5.18（垂直标签）开始； &lt;code&gt;\w&lt;/code&gt; 表示63个字符 &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ；同样，所有Posix类（例如 &lt;code&gt;[[:print:]]&lt;/code&gt; )仅匹配适当的ASCII范围字符。</target>
        </trans-unit>
        <trans-unit id="1727801b4e8e5e0fc9f27e13c40d768e93c5839d" translate="yes" xml:space="preserve">
          <source>When it appears singly, it causes the sequences &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, and the Posix character classes to match only in the ASCII range. They thus revert to their pre-5.6, pre-Unicode meanings. Under &lt;code&gt;/a&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt; always means precisely the digits &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &lt;code&gt;&quot;9&quot;&lt;/code&gt;; &lt;code&gt;\s&lt;/code&gt; means the five characters &lt;code&gt;[ \f\n\r\t]&lt;/code&gt;, and starting in Perl v5.18, the vertical tab; &lt;code&gt;\w&lt;/code&gt; means the 63 characters &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;; and likewise, all the Posix classes such as &lt;code&gt;[[:print:]]&lt;/code&gt; match only the appropriate ASCII-range characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e96b083a5b2fe4b1dd3f7bbb3653cb24d7adf0" translate="yes" xml:space="preserve">
          <source>When it comes to altering the behaviour of the test harness there's more than one way to do it. Which way is best depends on my requirements. In general if I only want to observe test execution without changing the harness' behaviour (for example to log test results to a database) I choose callbacks. If I want to make the harness behave differently subclassing gives me more control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae018fd8a3823b08fc79c33ba2f6c60484d5a434" translate="yes" xml:space="preserve">
          <source>When it comes to time-space tradeoffs, Perl nearly always prefers to throw memory at a problem. Scalars in Perl use more memory than strings in C, arrays take more than that, and hashes use even more. While there's still a lot to be done, recent releases have been addressing these issues. For example, as of 5.004, duplicate hash keys are shared amongst all hashes using them, so require no reallocation.</source>
          <target state="translated">当涉及到时空权衡时,Perl几乎总是倾向于把内存扔给一个问题。Perl中的标量比C语言中的字符串占用更多的内存,数组占用更多的内存,哈希占用更多的内存。虽然还有很多工作要做,但最近的版本已经在解决这些问题。例如,从 5.004 开始,重复的哈希键会在所有使用它们的哈希中共享,因此不需要重新分配。</target>
        </trans-unit>
        <trans-unit id="e21264012009a4f52f16ff3209c2f52a03a6b032" translate="yes" xml:space="preserve">
          <source>When it comes to undefined variables that would trigger a warning under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , you can promote the warning to an error.</source>
          <target state="translated">对于在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 下会触发警告的未定义变量，您可以将警告升级为错误。</target>
        </trans-unit>
        <trans-unit id="f4053c4973cee39e429495f57f5734c7c3b59da1" translate="yes" xml:space="preserve">
          <source>When it comes to undefined variables that would trigger a warning under &lt;code&gt;use warnings&lt;/code&gt;, you can promote the warning to an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea78a63efa4e07bcbad222b4b53d8108119efd5b" translate="yes" xml:space="preserve">
          <source>When it converges, you got a functional variant of</source>
          <target state="translated">当它收敛时,你得到了一个功能变体的</target>
        </trans-unit>
        <trans-unit id="079267d57082e05e5aa6528a39e11837b4f6a244" translate="yes" xml:space="preserve">
          <source>When it starts, the debugger reads your rc file (</source>
          <target state="translated">当它启动时,调试器读取你的rc文件(</target>
        </trans-unit>
        <trans-unit id="ab2f1658320564cc0ad685bee8d4cc13fa19d54b" translate="yes" xml:space="preserve">
          <source>When items collide into a given hash bucket the order they are stored in the chain is no longer predictable in Perl 5.18. This has the intention to make it harder to observe a collision. This behavior can be overridden by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;&quot;PERL_PERTURB_KEYS&quot; in perlrun&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e1e6def162fe17764cc69d6d5531c8389ffa63" translate="yes" xml:space="preserve">
          <source>When items collide into a given hash bucket the order they are stored in the chain is no longer predictable in Perl 5.18. This has the intention to make it harder to observe a collision. This behavior can be overridden by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS in perlrun&lt;/a&gt;.</source>
          <target state="translated">当项目碰撞到给定的哈希桶中时，它们在链中的存储顺序在Perl 5.18中不再可预测。目的是使观察到碰撞更加困难。可以通过使用PERL_PERTURB_KEYS环境变量来覆盖此行为，请参见&lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;perlrun中的PERL_PERTURB_KEYS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65043d3a1d3f5988941ccbcf07e25510773d1e57" translate="yes" xml:space="preserve">
          <source>When loading &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;, you must &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; before you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . (&lt;code&gt;threads&lt;/code&gt; will emit a warning if you do it the other way around.)</source>
          <target state="translated">加载&lt;a href=&quot;threads/shared&quot;&gt;thread :: shared时&lt;/a&gt;，必须先 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 然后再 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; 。（如果相反， &lt;code&gt;threads&lt;/code&gt; 将发出警告。）</target>
        </trans-unit>
        <trans-unit id="ad743799b7c94d4ac0b3c71cf0ab2ce52219a004" translate="yes" xml:space="preserve">
          <source>When loading &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt;, you must &lt;code&gt;use threads&lt;/code&gt; before you &lt;code&gt;use threads::shared&lt;/code&gt;. (&lt;code&gt;threads&lt;/code&gt; will emit a warning if you do it the other way around.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541e2da58c9337557a4530af689d0206150a39ea" translate="yes" xml:space="preserve">
          <source>When local patches are applied with smoke testing, the test driver will automatically request regeneration of certain tables after the patches are applied. The Synology supplied Perl 5.8.6 (at least on the DS413) &lt;b&gt;is NOT capable&lt;/b&gt; of generating these tables. It will generate opcodes with bogus values, causing the build to fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d97ad32fbcc62b0394446ba4a901eea150b590d" translate="yes" xml:space="preserve">
          <source>When looking for &lt;code&gt;DBD::Oracle&lt;/code&gt; relative to a search path, we should find</source>
          <target state="translated">当寻找相对于搜索路径的 &lt;code&gt;DBD::Oracle&lt;/code&gt; ，我们应该找到</target>
        </trans-unit>
        <trans-unit id="e429da2f9f9d1870d8a34d9bf7c8fc15e19b17ad" translate="yes" xml:space="preserve">
          <source>When matching files are extracted, ignore the directory path from the archive and write to the current directory using the basename of the file from the archive. Beware: if two matching files in the archive have the same basename, the second file extracted will overwrite the first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eeb796371e192f654f19b82f3385e933e7f2600" translate="yes" xml:space="preserve">
          <source>When moving backward it will not move before &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3206ee6854b0880fdd3279a57398bcb52c78786" translate="yes" xml:space="preserve">
          <source>When moving forward it will not move beyond &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1306624a66d42061de8cb1de14bb165b2e9253e" translate="yes" xml:space="preserve">
          <source>When naming your module, consider the following:</source>
          <target state="translated">在给模块命名时,请考虑以下几点。</target>
        </trans-unit>
        <trans-unit id="52dec4ed188cfa5b52a02969dbe527c5dc433e3b" translate="yes" xml:space="preserve">
          <source>When no BOM is found, Encode 2.76 and blow croaked. Since Encode 2.77, it falls back to BE accordingly to RFC2781 and the Unicode Standard version 8.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f6fa234dea48f4123a74cda1902ae1a1335eb2" translate="yes" xml:space="preserve">
          <source>When no destination is specified for an option, GetOptions will store the resultant value in a global variable named &lt;code&gt;opt_&lt;/code&gt;</source>
          <target state="translated">如果没有为选项指定目的地，则GetOptions会将结果值存储在名为 &lt;code&gt;opt_&lt;/code&gt; 的全局变量中</target>
        </trans-unit>
        <trans-unit id="d995d17f45ad38c16e65d9df03d9013a6e8bd451" translate="yes" xml:space="preserve">
          <source>When non-&lt;code&gt;NULL&lt;/code&gt; , the function pointed by this variable will be called each time an OP is freed with the corresponding OP as the argument. This allows extensions to free any extra attribute they have locally attached to an OP. It is also assured to first fire for the parent OP and then for its kids.</source>
          <target state="translated">如果为非 &lt;code&gt;NULL&lt;/code&gt; ，则每次以相应的OP作为参数释放OP时，都会调用此变量指向的函数。这允许扩展释放它们在本地附加到OP的任何其他属性。还可以确保先为父级OP点火，然后为其子级点火。</target>
        </trans-unit>
        <trans-unit id="ff599e171f439dd0c6a6547247e21662b9941e75" translate="yes" xml:space="preserve">
          <source>When non-&lt;code&gt;NULL&lt;/code&gt;, the function pointed by this variable will be called each time an OP is freed with the corresponding OP as the argument. This allows extensions to free any extra attribute they have locally attached to an OP. It is also assured to first fire for the parent OP and then for its kids.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda14717d0ef780a84b7072c8af4b8c2a6e41355" translate="yes" xml:space="preserve">
          <source>When non-zero this options will make bzip2 use a decompression algorithm that uses less memory at the expense of increasing the amount of time taken for decompression.</source>
          <target state="translated">当这个选项不为零时,将使bzip2使用一种使用较少内存的解压算法,但代价是增加解压的时间。</target>
        </trans-unit>
        <trans-unit id="0ddf8b539ea05fcfe6aec1dc58d559038d4a8742" translate="yes" xml:space="preserve">
          <source>When not using &lt;code&gt;\o{...}&lt;/code&gt;, you wrote something like &lt;code&gt;\08&lt;/code&gt;, or &lt;code&gt;\179&lt;/code&gt; in a double-quotish string. The resolution is as indicated, with all but the last digit treated as a single character, specified in octal. The last digit is the next character in the string. To tell Perl that this is indeed what you want, you can use the &lt;code&gt;\o{ }&lt;/code&gt; syntax, or use exactly three digits to specify the octal for the character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e144afe4dd441bf4ca7ad26c550e29a83fc4df" translate="yes" xml:space="preserve">
          <source>When open() is given an explicit list of layers (with the three-arg syntax), they override the list declared using this pragma. open() can also be given a single colon (:) for a layer name, to override this pragma and use the default (&lt;code&gt;:raw&lt;/code&gt; on Unix, &lt;code&gt;:crlf&lt;/code&gt; on Windows).</source>
          <target state="translated">当为open（）提供了一个明确的层列表（使用三参数语法）时，它们将覆盖使用此编译指示声明的列表。还可以为open（）的层名称指定单个冒号（:)，以覆盖此杂注并使用默认值（在Unix上为 &lt;code&gt;:raw&lt;/code&gt; ，在Windows 上为 &lt;code&gt;:crlf&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c34ab00add652f226c09c30c65ec7e49ad76d8a0" translate="yes" xml:space="preserve">
          <source>When open() is given an explicit list of layers (with the three-arg syntax), they override the list declared using this pragma. open() can also be given a single colon (:) for a layer name, to override this pragma and use the default as detailed in &lt;a href=&quot;perlio#Defaults-and-how-to-override-them&quot;&gt;&quot;Defaults and how to override them&quot; in PerlIO&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea26acaec78382fd2c97d3e0f9466f873120022e" translate="yes" xml:space="preserve">
          <source>When opened for writing, empty parts of the file will have NULL (0x00) bytes written to them.</source>
          <target state="translated">当打开写入时,文件的空部分将有NULL(0x00)字节写入其中。</target>
        </trans-unit>
        <trans-unit id="4a6b9011509d11da3fcfb04f15c06a413aa28bf6" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">打开文件时，如果请求失败，最好不要继续，因此 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 通常与 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 一起使用。即使 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 不会做您想要的事情（例如，在CGI脚本中，您要在其中格式化适当的错误消息的格式（但是有一些模块可以帮助解决该问题））也始终检查打开文件的返回值。</target>
        </trans-unit>
        <trans-unit id="713d157f79aa607cdf5ba0f3803c5ba5ac49d060" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">打开文件时，如果请求失败，最好不要继续，因此 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 通常与 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 一起使用。即使 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 不会做您想要的事情（例如，在CGI脚本中，您要在其中格式化适当的错误消息的格式（但是有一些模块可以帮助解决该问题））也始终检查打开文件的返回值。</target>
        </trans-unit>
        <trans-unit id="162aabd310aabb9968a3811cefafecae90daf2da" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;open&lt;/code&gt; is frequently used with &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt;. Even if you want your code to do something other than &lt;code&gt;die&lt;/code&gt; on a failed open, you should still always check the return value from opening a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="892216513454a34d10fa999d477dbcc5ddbab374" translate="yes" xml:space="preserve">
          <source>When opening a handle, it will be opened with any layers specified explicitly in the open() call (or the platform defaults, if specified as a colon with no following layers).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136d8820f5385aeb92b2b0d8596ed06c40a27f32" translate="yes" xml:space="preserve">
          <source>When passed a single hash-ref, &lt;b&gt;parseopts&lt;/b&gt; uses that hash to completely reset the existing parse-options, all previous parse-option values are lost.</source>
          <target state="translated">当传递单个哈希引用时，&lt;b&gt;parseopts&lt;/b&gt;使用该哈希值完全重置现有的parse-options，所有先前的parse-option值都会丢失。</target>
        </trans-unit>
        <trans-unit id="47b91ab5f28f979fd8b5568f2d0f9b2f727e616c" translate="yes" xml:space="preserve">
          <source>When perl begins to parse any block construct that provides a lexical scope (e.g., eval body, required file, subroutine body, loop body, or conditional block), the existing value of &lt;code&gt;$^H&lt;/code&gt; is saved, but its value is left unchanged. When the compilation of the block is completed, it regains the saved value. Between the points where its value is saved and restored, code that executes within BEGIN blocks is free to change the value of &lt;code&gt;$^H&lt;/code&gt; .</source>
          <target state="translated">当perl开始解析任何提供词法范围的块构造时（例如eval主体，所需文件，子例程主体，循环主体或条件块），将保存 &lt;code&gt;$^H&lt;/code&gt; 的现有值，但其值保持不变。块的编译完成后，它将重新获得保存的值。在保存和恢复其值的点之间，在BEGIN块中执行的代码可以自由更改 &lt;code&gt;$^H&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="ae5f7f62c62b7d34f56ec3574375a08840be5dee" translate="yes" xml:space="preserve">
          <source>When perl begins to parse any block construct that provides a lexical scope (e.g., eval body, required file, subroutine body, loop body, or conditional block), the existing value of &lt;code&gt;$^H&lt;/code&gt; is saved, but its value is left unchanged. When the compilation of the block is completed, it regains the saved value. Between the points where its value is saved and restored, code that executes within BEGIN blocks is free to change the value of &lt;code&gt;$^H&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e10e03e69e1ff5f3a594f297790818dcb4b2f72" translate="yes" xml:space="preserve">
          <source>When perl executes something like &lt;code&gt;addop&lt;/code&gt; , how does it pass on its results to the next op? The answer is, through the use of stacks. Perl has a number of stacks to store things it's currently working on, and we'll look at the three most important ones here.</source>
          <target state="translated">当perl执行诸如 &lt;code&gt;addop&lt;/code&gt; 之类的操作时，如何将其结果传递给下一个op？答案是通过使用堆栈。Perl有许多堆栈来存储当前正在处理的内容，我们将在这里介绍三个最重要的堆栈。</target>
        </trans-unit>
        <trans-unit id="0ad42676f2cea160c10d6e67d7270b962893b05d" translate="yes" xml:space="preserve">
          <source>When perl executes something like &lt;code&gt;addop&lt;/code&gt;, how does it pass on its results to the next op? The answer is, through the use of stacks. Perl has a number of stacks to store things it's currently working on, and we'll look at the three most important ones here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b736497c10b0a6402c79bf644d3d7290bca7e8df" translate="yes" xml:space="preserve">
          <source>When perl executes the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; expression, it translates the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; calls in the C run-time library and thence to the operating system kernel. perl sets &lt;code&gt;$!&lt;/code&gt; to the C library's &lt;code&gt;errno&lt;/code&gt; if one of these calls fails.</source>
          <target state="translated">当perl执行 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 表达式时，它将转换C运行时库中的 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 调用，然后将其转换为操作系统内核。perl设置 &lt;code&gt;$!&lt;/code&gt; 如果这些调用之一失败，则返回C库的 &lt;code&gt;errno&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36c7954ee59f65366eedb8f27e4e9a6ca8de87ae" translate="yes" xml:space="preserve">
          <source>When perl executes the &lt;code&gt;eval()&lt;/code&gt; expression, it translates the &lt;code&gt;open()&lt;/code&gt;, &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt;, and &lt;code&gt;close&lt;/code&gt; calls in the C run-time library and thence to the operating system kernel. perl sets &lt;code&gt;$!&lt;/code&gt; to the C library's &lt;code&gt;errno&lt;/code&gt; if one of these calls fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ce54f632d505238352e1c6b81e21cf7c3c75f1" translate="yes" xml:space="preserve">
          <source>When perl is built with debugging enabled, there is a second part to this stack storing human-readable string names describing the type of stack context. Each push operation saves the name as well as the height of the save stack, and each pop operation checks the topmost name with what is expected, causing an assertion failure if the name does not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23db1f0df62364b5b67f120eb77a3d581033b3c" translate="yes" xml:space="preserve">
          <source>When perl is compiled with support for memory footprint debugging (default with Perl's malloc()), Devel::Peek provides an access to this API.</source>
          <target state="translated">当perl编译时支持内存占用调试(默认使用Perl的malloc()),Devel::Peek提供了对这个API的访问。</target>
        </trans-unit>
        <trans-unit id="215e17f5873c9b21cb203952a3ef2363b112bec3" translate="yes" xml:space="preserve">
          <source>When perl is configured to use ithreads, it will use re-entrant library calls in preference to non-re-entrant versions. There is a bug in FreeBSD's &lt;code&gt;readdir_r&lt;/code&gt; function in versions 4.5 and earlier that can cause a SEGV when reading large directories. A patch for FreeBSD libc is available (see &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&lt;/a&gt; ) which has been integrated into FreeBSD 4.6.</source>
          <target state="translated">将perl配置为使用ithreads时，它将优先使用非可重入版本的可重入库调用。FreeBSD 在4.5及更早版本中的 &lt;code&gt;readdir_r&lt;/code&gt; 函数中存在一个错误，在读取大目录时可能导致SEGV。提供了FreeBSD libc补丁（请参见&lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&lt;/a&gt;），该补丁已集成到FreeBSD 4.6中。</target>
        </trans-unit>
        <trans-unit id="09323de6d789f44fb18ba022fc8c8c24e89843b3" translate="yes" xml:space="preserve">
          <source>When present this option will limit the number of compressed bytes read from the input file/buffer to &lt;code&gt;$size&lt;/code&gt; . This option can be used in the situation where there is useful data directly after the compressed data stream and you know beforehand the exact length of the compressed data stream.</source>
          <target state="translated">如果存在此选项，则将从输入文件/缓冲区读取的压缩字节数限制为 &lt;code&gt;$size&lt;/code&gt; 。在压缩数据流之后直接有有用数据并且您事先知道压缩数据流的确切长度的情况下，可以使用此选项。</target>
        </trans-unit>
        <trans-unit id="000c8ae4987a475c6136e4e54de88628f059caa6" translate="yes" xml:space="preserve">
          <source>When present this option will limit the number of compressed bytes read from the input file/buffer to &lt;code&gt;$size&lt;/code&gt;. This option can be used in the situation where there is useful data directly after the compressed data stream and you know beforehand the exact length of the compressed data stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ede0a2d2bf6a5a00a9412db1d402428ce441463" translate="yes" xml:space="preserve">
          <source>When presented with something that might have several different interpretations, Perl uses the &lt;b&gt;DWIM&lt;/b&gt; (that's &quot;Do What I Mean&quot;) principle to pick the most probable interpretation. This strategy is so successful that Perl programmers often do not suspect the ambivalence of what they write. But from time to time, Perl's notions differ substantially from what the author honestly meant.</source>
          <target state="translated">当出现可能具有几种不同解释的内容时，Perl使用&lt;b&gt;DWIM&lt;/b&gt;（即&amp;ldquo;按我的意思做&amp;rdquo;）原则来选择最可能的解释。这种策略是如此成功，以至于Perl程序员通常不会怀疑自己编写的内容的模棱两可。但是，Perl的概念有时会与作者的真实含义大相径庭。</target>
        </trans-unit>
        <trans-unit id="3ad187dab51002d9f1db84c4af0c7454d06b80be" translate="yes" xml:space="preserve">
          <source>When printed, a complex number is usually shown under its cartesian style</source>
          <target state="translated">当打印时,一个复杂的数字通常显示在它的卡提斯样式下</target>
        </trans-unit>
        <trans-unit id="5caa7cd7539097bbbb349ec1e585b2c803d154a7" translate="yes" xml:space="preserve">
          <source>When prompted, pick a subject that summarizes your changes.</source>
          <target state="translated">提示时,选择一个主题,总结你的变化。</target>
        </trans-unit>
        <trans-unit id="0c308dc95015b79380949643660ba2048891c6cf" translate="yes" xml:space="preserve">
          <source>When putting items into &lt;code&gt;%^H&lt;/code&gt; , in order to avoid conflicting with other users of the hash there is a convention regarding which keys to use. A module should use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; .</source>
          <target state="translated">将项目放入 &lt;code&gt;%^H&lt;/code&gt; ，为了避免与哈希的其他用户冲突，存在关于使用哪些键的约定。模块只能使用以模块名称（其主软件包的名称）和&amp;ldquo; /&amp;rdquo;字符开头的键。例如，模块 &lt;code&gt;Foo::Bar&lt;/code&gt; 应该使用诸如 &lt;code&gt;Foo::Bar/baz&lt;/code&gt; 键。</target>
        </trans-unit>
        <trans-unit id="5a9430143108ce24dc19010d3dec0a88276a16a9" translate="yes" xml:space="preserve">
          <source>When putting items into &lt;code&gt;%^H&lt;/code&gt;, in order to avoid conflicting with other users of the hash there is a convention regarding which keys to use. A module should use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c16015d247b91d71c9d2f79344302034231eb3" translate="yes" xml:space="preserve">
          <source>When reading from a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before reading.</source>
          <target state="translated">从文件或文件句柄读取时， &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 在读取前设置binmode。</target>
        </trans-unit>
        <trans-unit id="0711f567d0b9b4a99904ebf4ffdf5f0a6e3dd27c" translate="yes" xml:space="preserve">
          <source>When reading from a socket, remember that the default input record separator &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;\n&lt;/code&gt;, but robust socket code will recognize as either &lt;code&gt;\012&lt;/code&gt; or &lt;code&gt;\015\012&lt;/code&gt; as end of line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0130766d53ae0779f7ffce6dac2883bf210c349" translate="yes" xml:space="preserve">
          <source>When reading from a socket, remember that the default input record separator &lt;code&gt;$/&lt;/code&gt; is &lt;code&gt;\n&lt;/code&gt; , but robust socket code will recognize as either &lt;code&gt;\012&lt;/code&gt; or &lt;code&gt;\015\012&lt;/code&gt; as end of line:</source>
          <target state="translated">从套接字读取时，请记住默认输入记录分隔符 &lt;code&gt;$/&lt;/code&gt; 为 &lt;code&gt;\n&lt;/code&gt; ，但是可靠的套接字代码将识别为 &lt;code&gt;\012&lt;/code&gt; 或 &lt;code&gt;\015\012&lt;/code&gt; 作为行尾：</target>
        </trans-unit>
        <trans-unit id="ff12069c161fb8190739473ed34f724f30594524" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">读取压缩的输入数据时，IO :: Uncompress :: AnyInflate将以 &lt;code&gt;$num&lt;/code&gt; 字节的块读取数据。</target>
        </trans-unit>
        <trans-unit id="16d4e8c4e7b7384f70b2f1766cc139537265740d" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyUncompress will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">读取压缩的输入数据时，IO :: Uncompress :: AnyUncompress将以 &lt;code&gt;$num&lt;/code&gt; 字节的块读取数据。</target>
        </trans-unit>
        <trans-unit id="32ca9aeb1f06332449d6eb9320261dff0e66b312" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Bunzip2 will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">读取压缩的输入数据时，IO :: Uncompress :: Bunzip2将以 &lt;code&gt;$num&lt;/code&gt; 字节的块读取数据。</target>
        </trans-unit>
        <trans-unit id="50715bb3c754686d721e8aea919c37db141e1994" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Gunzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">读取压缩的输入数据时，IO :: Uncompress :: Gunzip将以 &lt;code&gt;$num&lt;/code&gt; 字节的块读取数据。</target>
        </trans-unit>
        <trans-unit id="59f000056402b83ac85f2986c043bbc1a33d0339" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Inflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">读取压缩的输入数据时，IO :: Uncompress :: Inflate将以 &lt;code&gt;$num&lt;/code&gt; 字节的块读取数据。</target>
        </trans-unit>
        <trans-unit id="07686b740fde1338aeadfd29d15b206d9e710502" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::RawInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">读取压缩的输入数据时，IO :: Uncompress :: RawInflate将以 &lt;code&gt;$num&lt;/code&gt; 字节的块读取数据。</target>
        </trans-unit>
        <trans-unit id="f6933aca30493bfe2ae64d115f3d25c9d4614976" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Unzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">读取压缩的输入数据时，IO :: Uncompress ::: Unzip将以 &lt;code&gt;$num&lt;/code&gt; 字节的块读取它。</target>
        </trans-unit>
        <trans-unit id="4d74245b43f70a678ebe3b1f9167c1e1ba7b4408" translate="yes" xml:space="preserve">
          <source>When referenced, &lt;code&gt;$!&lt;/code&gt; retrieves the current value of the C &lt;code&gt;errno&lt;/code&gt; integer variable. If &lt;code&gt;$!&lt;/code&gt; is assigned a numerical value, that value is stored in &lt;code&gt;errno&lt;/code&gt; . When referenced as a string, &lt;code&gt;$!&lt;/code&gt; yields the system error string corresponding to &lt;code&gt;errno&lt;/code&gt; .</source>
          <target state="translated">当引用时， &lt;code&gt;$!&lt;/code&gt; 检索C &lt;code&gt;errno&lt;/code&gt; 整数变量的当前值。如果 &lt;code&gt;$!&lt;/code&gt; 被分配一个数值，该数值存储在 &lt;code&gt;errno&lt;/code&gt; 中。当引用为字符串时， &lt;code&gt;$!&lt;/code&gt; 产生对应于 &lt;code&gt;errno&lt;/code&gt; 的系统错误字符串。</target>
        </trans-unit>
        <trans-unit id="f4a6f2c4dbed65f11dd2dadedd0a40b92fb0de8b" translate="yes" xml:space="preserve">
          <source>When referenced, &lt;code&gt;$!&lt;/code&gt; retrieves the current value of the C &lt;code&gt;errno&lt;/code&gt; integer variable. If &lt;code&gt;$!&lt;/code&gt; is assigned a numerical value, that value is stored in &lt;code&gt;errno&lt;/code&gt;. When referenced as a string, &lt;code&gt;$!&lt;/code&gt; yields the system error string corresponding to &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e9bf02eb38760deb66646d65b7d40e7944e879" translate="yes" xml:space="preserve">
          <source>When referring to characters by using a E&amp;lt;n&amp;gt; numeric code, numbers in the range 32-126 refer to those well known US-ASCII characters (also defined there by Unicode, with the same meaning), which all Pod formatters must render faithfully. Characters whose E&amp;lt;&amp;gt; numbers are in the ranges 0-31 and 127-159 should not be used (neither as literals, nor as E&amp;lt;number&amp;gt; codes), except for the literal byte-sequences for newline (ASCII 13, ASCII 13 10, or ASCII 10), and tab (ASCII 9).</source>
          <target state="translated">当使用E &amp;lt;n&amp;gt;数字代码引用字符时，范围在32-126之间的数字是指所有Pod格式化程序必须忠实呈现的那些众所周知的US-ASCII字符（也由Unicode定义，具有相同的含义）。 。除换行符的文字字节序列（ASCII 13，ASCII 13）外，不应使用其E &amp;lt;&amp;gt;数字在0-31和127-159范围内的字符（既不作为文字，也不作为E &amp;lt;number&amp;gt;代码）。 10，或ASCII 10）和制表符（ASCII 9）。</target>
        </trans-unit>
        <trans-unit id="df6e47ff65713a910476ca008419bf15d9f92656" translate="yes" xml:space="preserve">
          <source>When registering new categories of warning, you can supply more names to warnings::register like this:</source>
          <target state="translated">当注册新的警告类别时,你可以像这样向 warnings::register 提供更多的名称。</target>
        </trans-unit>
        <trans-unit id="59e513d53fd0a8e9868f35002e2f8f73a3de8302" translate="yes" xml:space="preserve">
          <source>When removing directory trees, if you want to examine each file to decide whether to delete it (and possibly leaving large swathes alone),</source>
          <target state="translated">在删除目录树时,如果你想检查每一个文件,以决定是否删除它(可能会留下大片空白)。</target>
        </trans-unit>
        <trans-unit id="ca0ea7cec59778756e53aaa7191d9a85c0fefd1a" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that allows comments (i.e., to nearly any format other than plaintext), a Pod formatter must insert comment text identifying its name and version number, and the name and version numbers of any modules it might be using to process the Pod. Minimal examples:</source>
          <target state="translated">当将Pod渲染成允许注释的格式时(即,几乎可以渲染成除纯文本以外的任何格式),Pod格式化器必须插入注释文本,以确定其名称和版本号,以及可能用于处理Pod的任何模块的名称和版本号。最低限度的例子。</target>
        </trans-unit>
        <trans-unit id="2ad27da5819e821c8cd5bf0434eaf270b819ceff" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that has two kinds of hyphens (-), one that's a non-breaking hyphen, and another that's a breakable hyphen (as in &quot;object-oriented&quot;, which can be split across lines as &quot;object-&quot;, newline, &quot;oriented&quot;), formatters are encouraged to generally translate &quot;-&quot; to non-breaking hyphen, but may apply heuristics to convert some of these to breaking hyphens.</source>
          <target state="translated">当将Pod渲染成有两种连字符(-)的格式时,一种是非断裂连字符,另一种是可断裂连字符(如 &quot;面向对象&quot;,可跨行分割为 &quot;object-&quot;、newline、&quot;oriented&quot;),鼓励格式员一般将&quot;-&quot;翻译为非断裂连字符,但可以应用启发式方法将其中的一些连字符转换为断裂连字符。</target>
        </trans-unit>
        <trans-unit id="f52c5a574eb5f1fd47869d07460df5abd7dd5137" translate="yes" xml:space="preserve">
          <source>When reporting a bug, please run through this checklist:</source>
          <target state="translated">当报告一个错误时,请运行这个检查表。</target>
        </trans-unit>
        <trans-unit id="8b6bb8cb7867586650585befc2c1fd8387be0539" translate="yes" xml:space="preserve">
          <source>When reporting bugs/problems please include as much information as possible. It may be difficult for me to reproduce the problem as almost every setup is different.</source>
          <target state="translated">当报告错误/问题时,请尽可能多地包含信息。我可能很难重现这个问题,因为几乎每个设置都是不同的。</target>
        </trans-unit>
        <trans-unit id="f2af35fcfc2870add3a574f13c6598d925c1d896" translate="yes" xml:space="preserve">
          <source>When resolving a request for a global DLL, the table of already-loaded specific DLLs is (effectively) ignored; moreover, specific DLLs are</source>
          <target state="translated">当解析对全局DLL的请求时,已经加载的特定DLL的表会被(有效地)忽略;此外,特定的DLL会被称为</target>
        </trans-unit>
        <trans-unit id="62379e9d05e773d7f9a20bc63493ce786aebefd0" translate="yes" xml:space="preserve">
          <source>When returning a C array to Perl the XS writer must provide an integer variable called &lt;code&gt;size_$var&lt;/code&gt; containing the number of elements in the array. This is used to determine how many elements should be pushed onto the return argument stack. This is not required on input since Perl knows how many arguments are on the stack when the routine is called. Ordinarily this variable would be called &lt;code&gt;size_RETVAL&lt;/code&gt; .</source>
          <target state="translated">当将C数组返回给Perl时，XS &lt;code&gt;size_$var&lt;/code&gt; 必须提供一个名为size_ $ var的整数变量，其中包含数组中元素的数量。这用于确定应将多少个元素压入返回参数堆栈。输入不是必需的，因为Perl知道在调用例程时堆栈中有多少个参数。通常，此变量称为 &lt;code&gt;size_RETVAL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="977e07d16b270182693f540dd1711d684d80c08a" translate="yes" xml:space="preserve">
          <source>When returning a C array to Perl the XS writer must provide an integer variable called &lt;code&gt;size_$var&lt;/code&gt; containing the number of elements in the array. This is used to determine how many elements should be pushed onto the return argument stack. This is not required on input since Perl knows how many arguments are on the stack when the routine is called. Ordinarily this variable would be called &lt;code&gt;size_RETVAL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca08b2641f1d92e43e0d4ac166dca80cda23751" translate="yes" xml:space="preserve">
          <source>When returning a non-null result the type of the return is relevant. If it is an AV then the elements of the AV are the weak reference RVs which point at this item. If it is any other type then the item itself is the weak reference.</source>
          <target state="translated">当返回一个非空结果时,返回的类型是相关的。如果它是一个AV,那么AV的元素就是指向这个项目的弱引用RV。如果是其他类型,那么这个项目本身就是弱引用。</target>
        </trans-unit>
        <trans-unit id="97489cccab69eb1d35c1a341e128a78067c55f21" translate="yes" xml:space="preserve">
          <source>When rounding a number, different 'styles' or 'kinds' of rounding are possible. (Note that random rounding, as in Math::Round, is not implemented.)</source>
          <target state="translated">当对一个数字进行四舍五入时,可以采用不同的 &quot;风格 &quot;或 &quot;种类&quot;。(请注意,Math::Round中的随机四舍五入没有实现。)</target>
        </trans-unit>
        <trans-unit id="b2582b20778ca5521eeab7f1f747014dfe26c89f" translate="yes" xml:space="preserve">
          <source>When run it produces this output</source>
          <target state="translated">当运行时,它产生以下输出</target>
        </trans-unit>
        <trans-unit id="160ab26c7ebae1afd875b8a69bb2544386a0a133" translate="yes" xml:space="preserve">
          <source>When run, the script will produce this error message:</source>
          <target state="translated">当运行时,脚本会产生这个错误信息。</target>
        </trans-unit>
        <trans-unit id="5d4a1a1df4c481bafe8952728953b7a8106417f0" translate="yes" xml:space="preserve">
          <source>When running &lt;code&gt;perl Makefile.PL&lt;/code&gt; , the environment variable &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; is set to the full path of the &lt;code&gt;Makefile.PL&lt;/code&gt; that is being executed. This prevents runaway processes with newer versions of Module::Install.</source>
          <target state="translated">运行 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 时，环境变量 &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; 设置为正在执行的 &lt;code&gt;Makefile.PL&lt;/code&gt; 的完整路径。这样可以防止使用更高版本的Module :: Install导致进程失控。</target>
        </trans-unit>
        <trans-unit id="89350694f65316ce98eae1ce7d3a0891e9c042c8" translate="yes" xml:space="preserve">
          <source>When running as the superuser, don't attempt drop privileges for security. This option is implied with &lt;b&gt;-F&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04666da2a46dba8c376f71b404386c5bd13c8146" translate="yes" xml:space="preserve">
          <source>When running taint checks, either because the program was running setuid or setgid, or the &lt;a href=&quot;#-T&quot;&gt;&quot;-T&quot;&lt;/a&gt; or &lt;a href=&quot;#-t&quot;&gt;&quot;-t&quot;&lt;/a&gt; switch was specified, neither PERL5LIB nor &lt;a href=&quot;#PERLLIB&quot;&gt;&quot;PERLLIB&quot;&lt;/a&gt; is consulted. The program should instead say:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2495ae50df460c2e127a2a6fc0eec9930e9be952" translate="yes" xml:space="preserve">
          <source>When running taint checks, either because the program was running setuid or setgid, or the &lt;b&gt;-T&lt;/b&gt; or &lt;b&gt;-t&lt;/b&gt; switch was specified, neither PERL5LIB nor PERLLIB is consulted. The program should instead say:</source>
          <target state="translated">在运行taint检查时，由于程序正在运行setuid或setgid，或者已指定&lt;b&gt;-T&lt;/b&gt;或&lt;b&gt;-t&lt;/b&gt;开关，因此未查询PERL5LIB或PERLLIB。该程序应改为：</target>
        </trans-unit>
        <trans-unit id="7b3cb45c9a7da578dedba06cdb9f023a384333cd" translate="yes" xml:space="preserve">
          <source>When running this program, redirect &lt;code&gt;STDOUT&lt;/code&gt; so it is possible to check the output is correct from following test runs and use the system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility to check the overall runtime.</source>
          <target state="translated">运行此程序时，请重定向 &lt;code&gt;STDOUT&lt;/code&gt; ,以便可以从以下测试运行中检查输出是否正确，并使用系统 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 实用程序检查总体运行时间。</target>
        </trans-unit>
        <trans-unit id="206d7f06e0a05581fe8e0f140b59c4f2ebd75b9b" translate="yes" xml:space="preserve">
          <source>When running this program, redirect &lt;code&gt;STDOUT&lt;/code&gt; so it is possible to check the output is correct from following test runs and use the system &lt;code&gt;time&lt;/code&gt; utility to check the overall runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7975efeb25c8aaa03ac880e03163e48a54218208" translate="yes" xml:space="preserve">
          <source>When running under Eunice this variable contains a command which will convert a shell script to the proper form of text file for it to be executable by the shell. On other systems it is a no-op.</source>
          <target state="translated">当在Eunice下运行时,这个变量包含一个命令,它将把shell脚本转换为适当形式的文本文件,以便shell能够执行。在其他系统中,它是一个无操作的变量。</target>
        </trans-unit>
        <trans-unit id="e969971baf41c84189fecb4a510a18aaa7b43b6a" translate="yes" xml:space="preserve">
          <source>When running with taint checks enabled, indicates via &lt;code&gt;maybe_tainted&lt;/code&gt; if results are untrustworthy (often due to the use of locales).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6a46b32d19b77f807e82e4b0a5dbfd16227ea7" translate="yes" xml:space="preserve">
          <source>When safe signals is in effect (the default behavior - see &lt;a href=&quot;#Unsafe-signals&quot;&gt;&quot;Unsafe signals&quot;&lt;/a&gt; for more details), then signals may be sent and acted upon by individual threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401f0ab26dc2fddd741da0955da0f9c560a5d28d" translate="yes" xml:space="preserve">
          <source>When safe signals is in effect (the default behavior - see &lt;a href=&quot;#Unsafe-signals&quot;&gt;Unsafe signals&lt;/a&gt; for more details), then signals may be sent and acted upon by individual threads.</source>
          <target state="translated">当安全信号生效时（默认行为- 有关更多详细信息，请参阅&lt;a href=&quot;#Unsafe-signals&quot;&gt;不安全信号&lt;/a&gt;），则各个线程可以发送信号并对其采取行动。</target>
        </trans-unit>
        <trans-unit id="dba60ff6fd07f256c35eeeb0201541b7eaafeee0" translate="yes" xml:space="preserve">
          <source>When satisfied with the results, rerun the &lt;code&gt;installcmd&lt;/code&gt; target. Now you can copy &lt;code&gt;perl5.8.2.exe&lt;/code&gt; to &lt;code&gt;perl.exe&lt;/code&gt; , and install the other OMF-build executables: &lt;code&gt;perl__.exe&lt;/code&gt; etc. They are ready to be used.</source>
          <target state="translated">对结果满意后，请重新运行 &lt;code&gt;installcmd&lt;/code&gt; 目标。现在，您可以将 &lt;code&gt;perl5.8.2.exe&lt;/code&gt; 复制到 &lt;code&gt;perl.exe&lt;/code&gt; ，并安装其他OMF生成的可执行文件： &lt;code&gt;perl__.exe&lt;/code&gt; 等。它们已准备就绪，可以使用。</target>
        </trans-unit>
        <trans-unit id="f3274597eb7d5805f670851614bcfbd7d2f840a5" translate="yes" xml:space="preserve">
          <source>When satisfied with the results, rerun the &lt;code&gt;installcmd&lt;/code&gt; target. Now you can copy &lt;code&gt;perl5.8.2.exe&lt;/code&gt; to &lt;code&gt;perl.exe&lt;/code&gt;, and install the other OMF-build executables: &lt;code&gt;perl__.exe&lt;/code&gt; etc. They are ready to be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d487e30347818adf665d0d1f254f13a4106809" translate="yes" xml:space="preserve">
          <source>When saving source, include evals that generate no subroutines.</source>
          <target state="translated">当保存源时,包括不产生子程序的evals。</target>
        </trans-unit>
        <trans-unit id="c90d39de52f44bc4955e7d1999e5bc6bf1c25af5" translate="yes" xml:space="preserve">
          <source>When saving source, include source that did not compile.</source>
          <target state="translated">保存源码时,包括没有编译的源码。</target>
        </trans-unit>
        <trans-unit id="398d8ece97f780e7acaac52b6e525bbaea7d6236" translate="yes" xml:space="preserve">
          <source>When searching for single-character delimiters, escaped delimiters and &lt;code&gt;\\&lt;/code&gt; are skipped. For example, while searching for terminating &lt;code&gt;/&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\/&lt;/code&gt; are skipped. If the delimiters are bracketing, nested pairs are also skipped. For example, while searching for a closing &lt;code&gt;]&lt;/code&gt; paired with the opening &lt;code&gt;[&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; , &lt;code&gt;\]&lt;/code&gt;, and &lt;code&gt;\[&lt;/code&gt; are all skipped, and nested &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; are skipped as well. However, when backslashes are used as the delimiters (like &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt;), nothing is skipped. During the search for the end, backslashes that escape delimiters or other backslashes are removed (exactly speaking, they are not copied to the safe location).</source>
          <target state="translated">搜索单字符定界符时，将跳过转义的定界符和 &lt;code&gt;\\&lt;/code&gt; 。例如，在搜索终止符 &lt;code&gt;/&lt;/code&gt; 时，将跳过 &lt;code&gt;\\&lt;/code&gt; 和 &lt;code&gt;\/&lt;/code&gt; 组合。如果定界符放在括号内，则也将跳过嵌套对。例如，在搜索与开始 &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; 配对的 &lt;code&gt;\\&lt;/code&gt; ，\\， &lt;code&gt;\]&lt;/code&gt; 和 &lt;code&gt;\[&lt;/code&gt; 都被跳过，嵌套的 &lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 也被跳过。但是，将反斜杠用作分隔符时（例如 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt; ），则不会跳过任何内容。在搜索末尾期间，会删除转义定界符的反斜杠或其他反斜杠（确切地说，它们不会复制到安全位置）。</target>
        </trans-unit>
        <trans-unit id="15bd46317800c6a271d171bbf86328e23d6c92d4" translate="yes" xml:space="preserve">
          <source>When searching for single-character delimiters, escaped delimiters and &lt;code&gt;\\&lt;/code&gt; are skipped. For example, while searching for terminating &lt;code&gt;/&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\/&lt;/code&gt; are skipped. If the delimiters are bracketing, nested pairs are also skipped. For example, while searching for a closing &lt;code&gt;]&lt;/code&gt; paired with the opening &lt;code&gt;[&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;\]&lt;/code&gt;, and &lt;code&gt;\[&lt;/code&gt; are all skipped, and nested &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; are skipped as well. However, when backslashes are used as the delimiters (like &lt;code&gt;qq\\&lt;/code&gt; and &lt;code&gt;tr\\\&lt;/code&gt;), nothing is skipped. During the search for the end, backslashes that escape delimiters or other backslashes are removed (exactly speaking, they are not copied to the safe location).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680861791c99e55f56913fa6b0dc2bd7ba150950" translate="yes" xml:space="preserve">
          <source>When sending an initial request to the security email address, please don't Cc any other parties, because if they reply to all, the reply will generate yet another new ticket. Once you have received an initial reply with a &lt;code&gt;[perl #NNNNNN]&lt;/code&gt; ticket number in the headline, it's okay to Cc subsequent replies to third parties: all emails to the perl5-security-report address with the ticket number in the subject line will be added to the ticket; without it, a new ticket will be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c34df309dbf3ee7f15cd5785f504c8f035d38f" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;1&quot;&lt;/code&gt; or &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; then traversing keys will be randomized. Every time a hash is inserted into the key order will change in a random fashion. The order may not be repeatable in a following program run even if the PERL_HASH_SEED has been specified. This is the default mode for perl.</source>
          <target state="translated">当设置为 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; 遍历键将被随机化。每次将哈希插入密钥顺序时，都会以随机方式更改。即使已指定PERL_HASH_SEED，该顺序在以后的程序运行中也可能无法重复。这是perl的默认模式。</target>
        </trans-unit>
        <trans-unit id="04d0e5e2f5a4ede1100f0e4584215cbbf899e23b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;2&quot;&lt;/code&gt; or &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; then inserting keys into a hash will cause the key order to change, but in a way that is repeatable from program run to program run.</source>
          <target state="translated">当设置为 &lt;code&gt;&quot;2&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; 将键插入到哈希中将导致键顺序发生更改，但是这种方式在程序运行到程序运行之间是可重复的。</target>
        </trans-unit>
        <trans-unit id="9e7128c2c7dce5a0a3a9029329df5cbd50b2f0b7" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause &lt;code&gt;remove_tree&lt;/code&gt; to skip the files for which the process lacks the required privileges needed to delete files, such as delete privileges on VMS. In other words, the code will make no attempt to alter file permissions. Thus, if the process is interrupted, no filesystem object will be left in a more permissive mode.</source>
          <target state="translated">设置为true值时，将导致 &lt;code&gt;remove_tree&lt;/code&gt; 跳过进程缺少删除文件所需的必需特权（例如VMS上的删除特权）的文件。换句话说，该代码不会尝试更改文件权限。因此，如果该过程被中断，则没有文件系统对象将处于更宽松的模式。</target>
        </trans-unit>
        <trans-unit id="c7f5dc6825eff7e1f171e69f42059c82111432c0" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause all files and subdirectories to be removed, except the initially specified directories. This comes in handy when cleaning out an application's scratch directory.</source>
          <target state="translated">当设置为true时,将导致除最初指定的目录外的所有文件和子目录被删除。这在清理应用程序的scratch目录时很方便。</target>
        </trans-unit>
        <trans-unit id="a98ff16a4db26e40074379a02c1ac4736cef2e29" translate="yes" xml:space="preserve">
          <source>When set to true (default is false) this will reject any facets where a facet class cannot be found. Normally facets without classes are assumed to be custom and are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff22a09dbb1fd01f1d9e27ed6ec106512c2eedc" translate="yes" xml:space="preserve">
          <source>When set, Data::Dumper will emit single, non-self-referential values as atoms/terms rather than statements. This means that the &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">设置后，Data :: Dumper将发出单个非自我引用的值作为原子/项，而不是语句。这意味着 &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe8e786dd3039d8dd6d2bfab15396a2a2af496f5" translate="yes" xml:space="preserve">
          <source>When set, controls the network timeout (counted in seconds).</source>
          <target state="translated">设置时,控制网络超时(以秒为单位)。</target>
        </trans-unit>
        <trans-unit id="b5e8c42abd62cd10178b1f40a287ed255997e01d" translate="yes" xml:space="preserve">
          <source>When set, enables the use of double quotes for representing string values. Whitespace other than space will be represented as &lt;code&gt;[\n\t\r]&lt;/code&gt; , &quot;unsafe&quot; characters will be backslashed, and unprintable characters will be output as quoted octal integers. The default is 0.</source>
          <target state="translated">设置后，启用双引号表示字符串值。除空格以外的空白将表示为 &lt;code&gt;[\n\t\r]&lt;/code&gt; ，&amp;ldquo; unsafe&amp;rdquo;字符将被反斜杠，并且不可打印字符将被输出为带引号的八进制整数。默认值为0。</target>
        </trans-unit>
        <trans-unit id="9d1d9ef1336068db5d1ba9928d2591d51c52c62c" translate="yes" xml:space="preserve">
          <source>When set, enables the use of double quotes for representing string values. Whitespace other than space will be represented as &lt;code&gt;[\n\t\r]&lt;/code&gt;, &quot;unsafe&quot; characters will be backslashed, and unprintable characters will be output as quoted octal integers. The default is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c58b77eb133eea8c15ca3a9398533c775f314b" translate="yes" xml:space="preserve">
          <source>When should I decode or encode?</source>
          <target state="translated">什么时候应该解码或编码?</target>
        </trans-unit>
        <trans-unit id="1dc62984ecca7c09ade87153ed4ccd6695dd04ce" translate="yes" xml:space="preserve">
          <source>When shouldn't I program in Perl?</source>
          <target state="translated">什么时候不应该用Perl编程?</target>
        </trans-unit>
        <trans-unit id="ab11b33195a0de9ef0d3f4bb14477223addc7e28" translate="yes" xml:space="preserve">
          <source>When some mandatory fields are missing or invalid, the conversion will attempt to provide a sensible default or will fill them with a value of 'unknown'. For example a missing or unrecognized &lt;code&gt;license&lt;/code&gt; field will result in a &lt;code&gt;license&lt;/code&gt; field of 'unknown'. Fields that may get an 'unknown' include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a0e44be6c1f4e08e2750d9d92dbacbb5e6685b" translate="yes" xml:space="preserve">
          <source>When something is contained in something else, particularly when that might be considered surprising: &amp;ldquo;I&amp;rsquo;ve embedded a complete Perl interpreter in my editor!&amp;rdquo;</source>
          <target state="translated">当其他内容中包含某些内容时，尤其是在令人惊讶的情况下：&amp;ldquo;我在编辑器中嵌入了完整的Perl解释器！&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0a4af2a22b89ee59f46fa6ec1a2f89f7c8de8e00" translate="yes" xml:space="preserve">
          <source>When speaking about regexes we need to distinguish between their source code form and their internal form. In this document we will use the term &quot;pattern&quot; when we speak of their textual, source code form, and the term &quot;program&quot; when we speak of their internal representation. These correspond to the terms</source>
          <target state="translated">在谈到regexes时,我们需要区分它们的源代码形式和内部形式。在本文档中,当我们谈到它们的文本、源代码形式时,我们将使用术语 &quot;模式&quot;,而当我们谈到它们的内部表示时,将使用术语 &quot;程序&quot;。这些术语对应的是</target>
        </trans-unit>
        <trans-unit id="71fc37572f09658b981cd729d4958d3d9535564d" translate="yes" xml:space="preserve">
          <source>When specified (localised) in a module's</source>
          <target state="translated">当在模块的</target>
        </trans-unit>
        <trans-unit id="0b48aaafd2407a97f05ee6a676562dca0cfeebf8" translate="yes" xml:space="preserve">
          <source>When starting scripts directly, Perl uses exactly the same algorithm as for the search of script given by &lt;b&gt;-S&lt;/b&gt; command-line option: it will look in the current directory, then on components of &lt;code&gt;$ENV{PATH}&lt;/code&gt; using the following order of appended extensions: no extension,</source>
          <target state="translated">直接启动脚本时，Perl使用与&lt;b&gt;-S&lt;/b&gt;命令行选项给出的脚本搜索完全相同的算法：它将在当前目录中查找，然后使用以下扩展名顺序查找 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 组件：没有扩展名，</target>
        </trans-unit>
        <trans-unit id="31501718ea48b1c7c96923d7f9ebcfb80e76fc7d" translate="yes" xml:space="preserve">
          <source>When storing doubles in network order, their value is stored as text. However, you should also not expect non-numeric floating-point values such as infinity and &quot;not a number&quot; to pass successfully through a nstore()/retrieve() pair.</source>
          <target state="translated">当按网络顺序存储双数时,它们的值被存储为文本。然而,你也不应该期望非数字浮点值,如无穷大和 &quot;不是一个数字&quot;,能够成功地通过nstore()/retrieve()对。</target>
        </trans-unit>
        <trans-unit id="4e11b655699381504305f7887609ab8d634e504a" translate="yes" xml:space="preserve">
          <source>When stringified, &lt;code&gt;autodie::exception::system&lt;/code&gt; objects currently use the message generated by &lt;a href=&quot;IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85058aaefb4d2e0a77cba44540a9a1fa5a2d7ef7" translate="yes" xml:space="preserve">
          <source>When submitting a bug or request, please include a test-file or a patch to an existing test-file that illustrates the bug or desired feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aadbffec66a30c1a002a47c90a7b1248371d0324" translate="yes" xml:space="preserve">
          <source>When testing applications, often you find yourself needing to provide functionality in your test environment that would usually be provided by external modules. Rather than munging the &lt;code&gt;%INC&lt;/code&gt; by hand to mark these external modules as loaded, so they are not attempted to be loaded by perl, this module offers you a very simple way to mark modules as loaded and/or unloaded.</source>
          <target state="translated">在测试应用程序时，通常会发现自己需要在测试环境中提供通常由外部模块提供的功能。该模块为您提供了一种非常简单的方式来将模块标记为已加载和/或卸载，而不是手动修改 &lt;code&gt;%INC&lt;/code&gt; 来将这些外部模块标记为已加载，因此不会尝试由perl加载它们。</target>
        </trans-unit>
        <trans-unit id="2ecf844cc9f858984bae81698225ab3522c9600d" translate="yes" xml:space="preserve">
          <source>When that is parsed and events are about to be called on it, it may actually seem to be four different text events, one right after another: one event for &quot;I just LOVE &quot;, one for &quot;hot&quot;, one for &quot; &quot;, and one for &quot;apple pie!&quot;. But if you have merge_text on, then you're guaranteed that it will be fired as one text event: &quot;I just LOVE hot apple pie!&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961c445e33a9a31bd9e2652fe106daffb549bbdf" translate="yes" xml:space="preserve">
          <source>When that string is compiled from bracket notation into a real Perl sub, it's basically turned into:</source>
          <target state="translated">当这个字符串从括号符号编译成一个真正的Perl子时,基本上就变成了。</target>
        </trans-unit>
        <trans-unit id="956082e29333281c1000de72a422a6d173c77cc1" translate="yes" xml:space="preserve">
          <source>When the # flag and a precision are given in the %o conversion, the precision is incremented if it's necessary for the leading &quot;0&quot;.</source>
          <target state="translated">当在%o转换中给出#标志和一个精度时,如果需要前导 &quot;0&quot;,精度会递增。</target>
        </trans-unit>
        <trans-unit id="aa880a320400827152fdc9bea63191360399d514" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;CVf_SLABBED&lt;/code&gt; flag is set, the CV takes responsibility for freeing the slab. If &lt;code&gt;CvROOT&lt;/code&gt; is not set when the CV is freed or undeffed, it is assumed that a compilation error has occurred, so the op slab is traversed and all the ops are freed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c77bd95ba1c8037180b07d06856855d317ef69" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is omitted or false, then the tied hash elements will be the contents of the leftmost defined buffer with the name of the associated hash key. In other words, the tied hash will behave as &lt;code&gt;%+&lt;/code&gt; .</source>
          <target state="translated">当 &lt;code&gt;all&lt;/code&gt; 参数省略或为false时，绑定的哈希元素将是最左侧定义的缓冲区的内容，并带有关联的哈希键的名称。换句话说，绑定哈希将表现为 &lt;code&gt;%+&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b92065de5607bb0c7a77a48e1cfce97eed7a26ac" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is omitted or false, then the tied hash elements will be the contents of the leftmost defined buffer with the name of the associated hash key. In other words, the tied hash will behave as &lt;code&gt;%+&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d840453ed70b6c8cd04f568b5e24263c8a47ca21" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is provided, then the tied hash elements will be array refs listing the contents of each capture buffer whose name is the same as the associated hash key. If none of these buffers were involved in the match, the contents of that array ref will be as many &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; values as there are capture buffers with that name. In other words, the tied hash will behave as &lt;code&gt;%-&lt;/code&gt; .</source>
          <target state="translated">当提供 &lt;code&gt;all&lt;/code&gt; 参数时，绑定的哈希元素将是数组引用，列出每个捕获缓冲区的内容，这些缓冲区的名称与关联的哈希键相同。如果匹配中没有这些缓冲区，则该数组ref的内容将是与具有该名称的捕获缓冲区一样多的 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值。换句话说，绑定哈希将表现为 &lt;code&gt;%-&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e2197c6d3b3d6c61f6564ab44ac2b44c0344d23" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is provided, then the tied hash elements will be array refs listing the contents of each capture buffer whose name is the same as the associated hash key. If none of these buffers were involved in the match, the contents of that array ref will be as many &lt;code&gt;undef&lt;/code&gt; values as there are capture buffers with that name. In other words, the tied hash will behave as &lt;code&gt;%-&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad645af5beffff4dcf298e97bda326c957e193d6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnix2&lt;/code&gt; option is present it will trigger the creation of a Unix2 extra field (ID is &quot;Ux&quot;) in the local zip header. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . An empty Unix2 extra field will also be created in the central zip header.</source>
          <target state="translated">如果存在 &lt;code&gt;exUnix2&lt;/code&gt; 选项，它将触发在本地zip标头中创建Unix2额外字段（ID为&amp;ldquo; Ux&amp;rdquo;）。这将填充 &lt;code&gt;$uid&lt;/code&gt; 和 &lt;code&gt;$gid&lt;/code&gt; 。在中央zip标头中还将创建一个空的Unix2额外字段。</target>
        </trans-unit>
        <trans-unit id="0db2965770fe8514e3fb9dd21cb17bd93496e99e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnix2&lt;/code&gt; option is present it will trigger the creation of a Unix2 extra field (ID is &quot;Ux&quot;) in the local zip header. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt;. An empty Unix2 extra field will also be created in the central zip header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f9a81cf7aa8b00ade31d3ca1a070fc29516dbb" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnixN&lt;/code&gt; option is present it will trigger the creation of a UnixN extra field (ID is &quot;ux&quot;) in both the local and central zip headers. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . The UID &amp;amp; GID are stored as 32-bit integers.</source>
          <target state="translated">如果存在 &lt;code&gt;exUnixN&lt;/code&gt; 选项，它将在本地和中央zip标头中触发创建UnixN额外字段（ID为&amp;ldquo; ux&amp;rdquo;）。这将填充 &lt;code&gt;$uid&lt;/code&gt; 和 &lt;code&gt;$gid&lt;/code&gt; 。UID和GID存储为32位整数。</target>
        </trans-unit>
        <trans-unit id="f94a510aaa8dc7a162e9738895fa3812cc690de5" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnixN&lt;/code&gt; option is present it will trigger the creation of a UnixN extra field (ID is &quot;ux&quot;) in both the local and central zip headers. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt;. The UID &amp;amp; GID are stored as 32-bit integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ce970ca586eb9f9dd65ce4eb91d435bcb2b455" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;frame&lt;/code&gt; option is set, the debugger would print entered (and optionally exited) subroutines in different styles. See &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; for incredibly long examples of these.</source>
          <target state="translated">当 &lt;code&gt;frame&lt;/code&gt; 选项设置时，调试器将打印输入的（和可选地退出）子程序在不同的风格。有关这些示例的冗长示例，请参见&lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="801df7cc1a118615aee66edb536ee9e06cf840b5" translate="yes" xml:space="preserve">
          <source>When the CPAN module is used for the first time, a configuration dialogue tries to determine a couple of site specific options. The result of the dialog is stored in a hash reference &lt;code&gt; $CPAN::Config &lt;/code&gt; in a file CPAN/Config.pm.</source>
          <target state="translated">首次使用CPAN模块时，配置对话框会尝试确定几个特定于站点的选项。对话框的结果存储在文件CPAN / Config.pm 中的哈希引用 &lt;code&gt; $CPAN::Config &lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="7cb924f6e524bd0e1830b8259c680c4e75924eac" translate="yes" xml:space="preserve">
          <source>When the CPAN shell enters a subshell via the look command, it sets the environment CPAN_SHELL_LEVEL to 1, or increments that variable if it is already set.</source>
          <target state="translated">当CPAN shell通过look命令进入子shell时,会将环境CPAN_SHELL_LEVEL设置为1,如果已经设置,则将该变量递增。</target>
        </trans-unit>
        <trans-unit id="3650ff6a9d15f4cddf8e012952c2eb6d79121733" translate="yes" xml:space="preserve">
          <source>When the CPAN shell is started it normally displays a greeting message that contains the running version and the status of readline support.</source>
          <target state="translated">当CPAN shell启动时,它通常会显示一个问候信息,其中包含运行的版本和读线支持的状态。</target>
        </trans-unit>
        <trans-unit id="3b2e82923d74c1d230a5130604df06c8f537a860" translate="yes" xml:space="preserve">
          <source>When the SV is read from or written to, the &lt;code&gt;uf_val&lt;/code&gt; or &lt;code&gt;uf_set&lt;/code&gt; function will be called with &lt;code&gt;uf_index&lt;/code&gt; as the first arg and a pointer to the SV as the second. A simple example of how to add &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic is shown below. Note that the ufuncs structure is copied by sv_magic, so you can safely allocate it on the stack.</source>
          <target state="translated">读取或写入SV时，将以 &lt;code&gt;uf_index&lt;/code&gt; 作为第一个arg并以指向SV的指针作为第二个调用 &lt;code&gt;uf_val&lt;/code&gt; 或 &lt;code&gt;uf_set&lt;/code&gt; 函数。下面显示了如何添加 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 魔术的简单示例。请注意，ufuncs结构是由sv_magic复制的，因此您可以安全地在堆栈上分配它。</target>
        </trans-unit>
        <trans-unit id="7cf75e5eda3afd46688cf75f69b185773f733453" translate="yes" xml:space="preserve">
          <source>When the Storable engine does not find any &lt;code&gt;STORABLE_thaw&lt;/code&gt; hook routine, it tries to load the class by requiring the package dynamically (using the blessed package name), and then re-attempts the lookup. If at that time the hook cannot be located, the engine croaks. Note that this mechanism will fail if you define several classes in the same file, but &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; warned you.</source>
          <target state="translated">当Storable引擎找不到任何 &lt;code&gt;STORABLE_thaw&lt;/code&gt; 钩子例程时，它将尝试通过动态要求软件包（使用受祝福的软件包名称）来加载类，然后重新尝试查找。如果那时无法找到挂钩，则发动机发出嘶哑声。请注意，如果您在同一文件中定义多个类，则此机制将失败，但是&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;警告您。</target>
        </trans-unit>
        <trans-unit id="d71b47dffe6d13e95919a44f8b1aab3c74c9a2ad" translate="yes" xml:space="preserve">
          <source>When the Windows and Arm DLLs are built do not be scared by a very long messages whizzing by: it is the &quot;export freeze&quot; phase where the whole (rather large) API of Perl is listed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44a6516f88b32cd0929f74947668f35c10106658" translate="yes" xml:space="preserve">
          <source>When the actual VMS termination status of the child is an error, internally the &lt;code&gt;$!&lt;/code&gt; value will be set to the closest Unix errno value to that error so that Perl scripts that test for error messages will see the expected Unix style error message instead of a VMS message.</source>
          <target state="translated">当子级的实际VMS终止状态为错误时，在内部 &lt;code&gt;$!&lt;/code&gt; 值将设置为与该错误最接近的Unix errno值，以便测试错误消息的Perl脚本将看到预期的Unix样式错误消息，而不是VMS消息。</target>
        </trans-unit>
        <trans-unit id="2e8f0d2ae12a2e39fe8c86870d0da6c283532175" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">当参数通过系统外壳执行时，结果受其怪癖和能力的影响。有关详细信息，请参见&lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;perlop中的&amp;ldquo; STRING&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ca28137b7d4a24f80f2a308158da006f7dc35dce" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;&quot;`STRING`&quot; in perlop&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb744771cfcd60aec9ab66ef08b4b0d1508a2fd" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">当参数通过系统外壳执行时，结果受其怪癖和能力的影响。有关详细信息，请参见&lt;a href=&quot;perlop#%60STRING%60&quot;&gt;perlop中的&amp;ldquo; STRING&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7a639b80ea13083bb656ad3ace22f1641521ba99" translate="yes" xml:space="preserve">
          <source>When the base greater than 36, and no collation sequence is given, the default collation sequence contains both uppercase and lowercase letters, so the letter case in the input is not ignored:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="569274b14b45a92ddaed7462d32bdd3f4354e2b9" translate="yes" xml:space="preserve">
          <source>When the base is less than or equal to 36, and no collation sequence is given, the letter case is ignored, so both of these also return 250:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ba3a0afa8ccd6c06c8d4acfe9a1d04b1ddc937" translate="yes" xml:space="preserve">
          <source>When the build environment has been set up, building and testing Perl is straightforward. The only thing you need to do is download the sources as usual, and add a file Policy.sh as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ca0edd57c85a2b69cd25fb457d6653721de135" translate="yes" xml:space="preserve">
          <source>When the class is inverted (&lt;code&gt;[^...]&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af5d3dc3800fc64d81a21bf6e187c8743b336401" translate="yes" xml:space="preserve">
          <source>When the class is to match caselessly under &lt;code&gt;/i&lt;/code&gt; matching rules, and a character that is explicitly mentioned inside the class matches a multiple-character sequence caselessly under Unicode rules, the class will also match that sequence. For example, Unicode says that the letter &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; should match the sequence &lt;code&gt;ss&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; rules. Thus,</source>
          <target state="translated">如果该类要在 &lt;code&gt;/i&lt;/code&gt; 匹配规则下进行不区分大小写的匹配，并且在类内部明确提到的字符在Unicode规则下不区分大小写地匹配一个多字符序列，则该类也将匹配该序列。例如，Unicode表示字母 &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; 应该与 &lt;code&gt;/i&lt;/code&gt; 规则下的序列 &lt;code&gt;ss&lt;/code&gt; 相匹配。从而，</target>
        </trans-unit>
        <trans-unit id="4739858b160d44355cadf7e584ea672d7f556732" translate="yes" xml:space="preserve">
          <source>When the code will run on only two or three operating systems, you may need to consider only the differences of those particular systems. The important thing is to decide where the code will run and to be deliberate in your decision.</source>
          <target state="translated">当代码只在两三个操作系统上运行时,你可能只需要考虑这些特定系统的差异。重要的是要决定代码将在哪里运行,并且在决定时要慎重。</target>
        </trans-unit>
        <trans-unit id="dfc1084fa585e179656ac972bdfbaccc526f6fbd" translate="yes" xml:space="preserve">
          <source>When the config variable ftp_passive is set, all downloads will be run with the environment variable FTP_PASSIVE set to this value. This is in general a good idea as it influences both Net::FTP and LWP based connections. The same effect can be achieved by starting the cpan shell with this environment variable set. For Net::FTP alone, one can also always set passive mode by running libnetcfg.</source>
          <target state="translated">当配置变量ftp_aspsive被设置时,所有的下载将在环境变量FTP_PASSIVE被设置为该值时运行。一般来说,这是一个好主意,因为它同时影响Net::FTP和基于LWP的连接。同样的效果也可以通过启动cpan shell时设置这个环境变量来实现。单纯对于Net::FTP来说,也可以通过运行libnetcfg随时设置被动模式。</target>
        </trans-unit>
        <trans-unit id="b1c69bf3ddadf947bad50c1663c482207ed7bb54" translate="yes" xml:space="preserve">
          <source>When the database contains only UTF-8, a wrapper function or method is a convenient way to replace all your &lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt; calls. A wrapper function will also make it easier to adapt to future enhancements in your database driver. Note that at the time of this writing (January 2012), the DBI has no standardized way to deal with UTF-8 data. Please check the &lt;a href=&quot;dbi&quot;&gt;DBI documentation&lt;/a&gt; to verify if that is still true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78466bcc2cdd4ead9e6349b03cf49de5263729eb" translate="yes" xml:space="preserve">
          <source>When the database contains only UTF-8, a wrapper function or method is a convenient way to replace all your &lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt; calls. A wrapper function will also make it easier to adapt to future enhancements in your database driver. Note that at the time of this writing (January 2012), the DBI has no standardized way to deal with UTF-8 data. Please check the &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI documentation&lt;/a&gt; to verify if that is still true.</source>
          <target state="translated">当数据库仅包含UTF-8时，包装函数或方法是替换所有 &lt;code&gt;fetchrow_array&lt;/code&gt; 和 &lt;code&gt;fetchrow_hashref&lt;/code&gt; 调用的便捷方法。包装函数还将使您更容易适应数据库驱动程序中将来的增强。请注意，在撰写本文时（2012年1月），DBI还没有标准化的方式来处理UTF-8数据。请检查&lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI文档&lt;/a&gt;以验证是否仍然正确。</target>
        </trans-unit>
        <trans-unit id="424c9b91abc16b60883f34954f20bc0920b45171" translate="yes" xml:space="preserve">
          <source>When the execution of your program reaches a point that can hold a breakpoint, the &lt;code&gt;DB::DB()&lt;/code&gt; subroutine is called if any of the variables &lt;code&gt;$DB::trace&lt;/code&gt; , &lt;code&gt;$DB::single&lt;/code&gt; , or &lt;code&gt;$DB::signal&lt;/code&gt; is true. These variables are not &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;izable. This feature is disabled when executing inside &lt;code&gt;DB::DB()&lt;/code&gt; , including functions called from it unless &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; is true.</source>
          <target state="translated">当程序的执行到达可以保存断点的点时，如果任何变量 &lt;code&gt;$DB::trace&lt;/code&gt; ， &lt;code&gt;$DB::single&lt;/code&gt; 或 &lt;code&gt;$DB::signal&lt;/code&gt; 为true ，则调用 &lt;code&gt;DB::DB()&lt;/code&gt; 子例程。。这些变量不可 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 。在 &lt;code&gt;DB::DB()&lt;/code&gt; 内部执行时，禁用此功能，包括从其调用的函数，除非 &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; 为true。</target>
        </trans-unit>
        <trans-unit id="203a255f166a15d5d314005ac0db0ee5bd633f84" translate="yes" xml:space="preserve">
          <source>When the execution of your program reaches a point that can hold a breakpoint, the &lt;code&gt;DB::DB()&lt;/code&gt; subroutine is called if any of the variables &lt;code&gt;$DB::trace&lt;/code&gt;, &lt;code&gt;$DB::single&lt;/code&gt;, or &lt;code&gt;$DB::signal&lt;/code&gt; is true. These variables are not &lt;code&gt;local&lt;/code&gt;izable. This feature is disabled when executing inside &lt;code&gt;DB::DB()&lt;/code&gt;, including functions called from it unless &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4013fd718fab58c3590b6ef9433727cc8d4f1b2" translate="yes" xml:space="preserve">
          <source>When the file</source>
          <target state="translated">当文件</target>
        </trans-unit>
        <trans-unit id="0e9d22cf15c89f0be579b7cac8b2920cd0618fca" translate="yes" xml:space="preserve">
          <source>When the files you're processing are small, it doesn't much matter which way you do it, but it makes a huge difference when they start getting larger.</source>
          <target state="translated">当你要处理的文件很小的时候,你用哪种方式处理并不太重要,但是当文件开始变大的时候,就会有很大的不同。</target>
        </trans-unit>
        <trans-unit id="d42ad95e8f7eb1ea8f7a7febcc136ac0e51ac7e9" translate="yes" xml:space="preserve">
          <source>When the first bad commit is isolated, &lt;code&gt;git bisect&lt;/code&gt; will tell you so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc397f7438e86b99c564236153e8faa95f5c6e3" translate="yes" xml:space="preserve">
          <source>When the first parameter is a scalar containing a value that either is a PV string or can be forced into one, the return value is the number of bytes occupied by the first character of that string; or 0 if that first character is the wide NUL character; or negative if there is an error. This is based on the locale that currently underlies the program, regardless of whether or not the function is called from Perl code that is within the scope of &lt;code&gt;use locale&lt;/code&gt;. Perl makes no attempt at hiding from your code any differences in the &lt;code&gt;errno&lt;/code&gt; setting between &lt;code&gt;mblen&lt;/code&gt; and &lt;code&gt;mbrlen&lt;/code&gt;. It does set &lt;code&gt;errno&lt;/code&gt; to 0 before calling them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f6d7004331625d3362cc91973ffa26e2885b63" translate="yes" xml:space="preserve">
          <source>When the first parameter is a scalar, the code point contained in the scalar second parameter is converted into a multi-byte string and stored into the first parameter scalar. This is based on the locale that currently underlies the program, regardless of whether or not the function is called from Perl code that is within the scope of &lt;code&gt;use locale&lt;/code&gt;. The return value is the number of bytes stored; or negative if the code point isn't representable in the current locale. Perl makes no attempt at hiding from your code any differences in the &lt;code&gt;errno&lt;/code&gt; setting between &lt;code&gt;wctomb&lt;/code&gt; and &lt;code&gt;wcrtomb&lt;/code&gt;. It does set &lt;code&gt;errno&lt;/code&gt; to 0 before calling them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67993cdc0054c70b8cf1f3b164eab66d68fabca" translate="yes" xml:space="preserve">
          <source>When the hash is tied dispatches through to the SCALAR method, otherwise returns a mortal SV containing the number of keys in the hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3edca323b0aa2a8c22d79426f73f2c12bb6d2e6d" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's lexical subroutine as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the lexical subroutine. In other words, it will no longer be shared. This will especially make a difference if the lexical subroutines accesses lexical variables declared in its surrounding scope.</source>
          <target state="translated">当内子程序被调用时,它将看到外子程序的词性子程序的值,就像在*次调用外子程序之前和期间一样;在这种情况下,在第一次调用外子程序完成后,内子程序和外子程序将不再共享词性子程序的共同值。换句话说,它将不再被共享。如果词法子程序访问在其周围作用域中声明的词法变量,这一点尤其会有所区别。</target>
        </trans-unit>
        <trans-unit id="c8e896e8cfb6883a198899b3b354096b8ef21889" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's variable as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the variable. In other words, the variable will no longer be shared.</source>
          <target state="translated">当内子程序被调用时,它将看到外子程序的变量值,就像在*次调用外子程序之前和期间一样;在这种情况下,在第一次调用外子程序完成后,内子程序和外子程序将不再共享变量的共同值。换句话说,该变量将不再被共享。</target>
        </trans-unit>
        <trans-unit id="631ef295238142aad88b3365a36b169f7f950bf1" translate="yes" xml:space="preserve">
          <source>When the last reference to an object goes away, the object is destroyed. If you only have one reference to an object stored in a lexical scalar, the object is destroyed when that scalar goes out of scope. If you store the object in a package global, that object may not go out of scope until the program exits.</source>
          <target state="translated">当一个对象的最后一个引用消失时,这个对象就会被销毁。如果你对一个存储在词法标量中的对象只有一个引用,那么当这个标量超出范围时,这个对象就会被销毁。如果你将对象存储在包全局中,该对象可能不会离开范围,直到程序退出。</target>
        </trans-unit>
        <trans-unit id="c4bd6e1ab0ed4ba3f062fe2340aa266f01cbc661" translate="yes" xml:space="preserve">
          <source>When the layer is pushed as part of an &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;PUSHED&lt;/code&gt; will be called</source>
          <target state="translated">当将图层作为 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 调用的一部分推送时，将调用 &lt;code&gt;PUSHED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01a59251b1866e239efdc75d52f126badadf6773" translate="yes" xml:space="preserve">
          <source>When the layer is pushed as part of an &lt;code&gt;open&lt;/code&gt; call, &lt;code&gt;PUSHED&lt;/code&gt; will be called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0128971f85240b4f39abca0c6ce4a11b4e096972" translate="yes" xml:space="preserve">
          <source>When the layer is pushed, the current value of &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; is saved and used as the CHECK argument when calling the Encode methods encode() and decode().</source>
          <target state="translated">推入该层时，将保存 &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; 的当前值，并在调用Encode方法encode（）和encode（）时用作CHECK参数。</target>
        </trans-unit>
        <trans-unit id="8cb85b7bdde203de76612ce7dec71db2d2570629" translate="yes" xml:space="preserve">
          <source>When the lib module is first loaded it records the current value of @INC in an array &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; . To restore @INC to that value you can say</source>
          <target state="translated">首次加载lib模块时，它将@INC的当前值记录在数组 &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; 。要将@INC恢复为该值，您可以说</target>
        </trans-unit>
        <trans-unit id="e9f47c78a4b7c6bf48658f90ad7bb90a6f2c2f03" translate="yes" xml:space="preserve">
          <source>When the lib module is first loaded it records the current value of @INC in an array &lt;code&gt;@lib::ORIG_INC&lt;/code&gt;. To restore @INC to that value you can say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="415f4830f0a5c60f55a1d0556cdab8350fdd12bf" translate="yes" xml:space="preserve">
          <source>When the match runs, the first part of the regular expression (&lt;code&gt;\b(foo)&lt;/code&gt; ) finds a possible match right at the beginning of the string, and loads up $1 with &quot;Foo&quot;. However, as soon as the matching engine sees that there's no whitespace following the &quot;Foo&quot; that it had saved in $1, it realizes its mistake and starts over again one character after where it had the tentative match. This time it goes all the way until the next occurrence of &quot;foo&quot;. The complete regular expression matches this time, and you get the expected output of &quot;table follows foo.&quot;</source>
          <target state="translated">当匹配运行时，正则表达式的第一部分（ &lt;code&gt;\b(foo)&lt;/code&gt; ）在字符串的开头找到一个可能的匹配，并用&amp;ldquo; Foo&amp;rdquo;加载$ 1。但是，只要匹配引擎发现保存在$ 1中的&amp;ldquo; Foo&amp;rdquo;后面没有空格，它就会意识到自己的错误，并在尝试性匹配之后重新开始一个字符。这次一直进行到下一次出现&amp;ldquo; foo&amp;rdquo;为止。这次完整的正则表达式匹配，您将获得&amp;ldquo; table following foo&amp;rdquo;的预期输出。</target>
        </trans-unit>
        <trans-unit id="59438c31be63ed00a2828de2f2dbb82ccfc7a3c2" translate="yes" xml:space="preserve">
          <source>When the match runs, the first part of the regular expression (&lt;code&gt;\b(foo)&lt;/code&gt;) finds a possible match right at the beginning of the string, and loads up &lt;code&gt;$1&lt;/code&gt; with &quot;Foo&quot;. However, as soon as the matching engine sees that there's no whitespace following the &quot;Foo&quot; that it had saved in &lt;code&gt;$1&lt;/code&gt;, it realizes its mistake and starts over again one character after where it had the tentative match. This time it goes all the way until the next occurrence of &quot;foo&quot;. The complete regular expression matches this time, and you get the expected output of &quot;table follows foo.&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a3d6c13049ca137ffa9c8c06a835f3079e4b4a" translate="yes" xml:space="preserve">
          <source>When the object goes out of scope, the destructor is called. This destructor will attempt to unlink the file (using &lt;a href=&quot;#unlink1&quot;&gt;unlink1&lt;/a&gt;) if the constructor was called with UNLINK set to 1 (the default state if UNLINK is not specified).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9aa22c95db143c4f71ce6060fc0fa951e547b8" translate="yes" xml:space="preserve">
          <source>When the object goes out of scope, the destructor is called. This destructor will attempt to unlink the file (using L</source>
          <target state="translated">当对象超出范围时,会调用destructor。这个析构器将尝试解开文件的链接(使用 L</target>
        </trans-unit>
        <trans-unit id="08260b550e8cbd87b7894a9886c2e5f84f74a639" translate="yes" xml:space="preserve">
          <source>When the optimisation criteria have been satisfied, &lt;code&gt;reg_try()&lt;/code&gt; is called to perform the match.</source>
          <target state="translated">满足优化条件后，将调用 &lt;code&gt;reg_try()&lt;/code&gt; 进行匹配。</target>
        </trans-unit>
        <trans-unit id="5ec2c96e37a54667487e24f12619de8d206380fe" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any compressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any compressed data is output.</source>
          <target state="translated">当输出是文件名时,它将在写入任何压缩数据之前截断文件的内容。如果输出是一个文件柄,它的位置将不会被改变。如果输出是一个缓冲区,它将在输出任何压缩数据之前被擦除。</target>
        </trans-unit>
        <trans-unit id="490632792a6bd230d4b7574b0a1ce3af888c0fe9" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any uncompressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any uncompressed data is output.</source>
          <target state="translated">当输出是文件名时,它将在写入任何未压缩的数据之前截断文件的内容。如果输出是一个文件柄,它的位置将不会被改变。如果输出是一个缓冲区,它将在输出任何未压缩数据之前被擦除。</target>
        </trans-unit>
        <trans-unit id="923167a1de1c89698b7cefa97410f6784a41b41c" translate="yes" xml:space="preserve">
          <source>When the program has terminated, the output may be examined and sorted using any standard text filtering utilities. Something like the following may be sufficient:</source>
          <target state="translated">当程序终止后,可以使用任何标准的文本过滤工具对输出进行检查和排序。类似下面的工具就足够了。</target>
        </trans-unit>
        <trans-unit id="a2704235b2d8eb8f428696670573c7525bbfe494" translate="yes" xml:space="preserve">
          <source>When the script ends, and you want to change some values in the generated</source>
          <target state="translated">当脚本结束后,你想改变生成的</target>
        </trans-unit>
        <trans-unit id="116008ef85147614241af5722a4a2daf4c0fac34" translate="yes" xml:space="preserve">
          <source>When the script terminates the profiler will create a database of the profile information that you can turn into reports using the profiler's tools. See &amp;lt;perlperf&amp;gt; for details.</source>
          <target state="translated">当脚本终止时，探查器将创建一个包含探查器信息的数据库，您可以使用探查器的工具将其转换为报告。有关详细信息，请参见&amp;lt;perlperf&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="bd423c011519f7f605565c27b285e9b7433164a6" translate="yes" xml:space="preserve">
          <source>When the second parameter is a scalar containing a value that either is a PV string or can be forced into one, the return value is the number of bytes occupied by the first character of that string; or 0 if that first character is the wide NUL character; or negative if there is an error. This is based on the locale that currently underlies the program, regardless of whether or not the function is called from Perl code that is within the scope of &lt;code&gt;use locale&lt;/code&gt;. Perl makes no attempt at hiding from your code any differences in the &lt;code&gt;errno&lt;/code&gt; setting between &lt;code&gt;mbtowc&lt;/code&gt; and &lt;code&gt;mbrtowc&lt;/code&gt;. It does set &lt;code&gt;errno&lt;/code&gt; to 0 before calling them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7811c9ae79cafa461b23dd21d92c2852fa57021" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode named code point &lt;code&gt;\N{...}&lt;/code&gt;</source>
          <target state="translated">当字符串包含以Unicode命名的代码点 &lt;code&gt;\N{...}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="219689a8c46c6da015ee7181b846d635f06ea57d" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode-only code point</source>
          <target state="translated">当字符串中包含一个Unicode-only码点时。</target>
        </trans-unit>
        <trans-unit id="dff4dc2cfa7ab4f3143ca1c8cea9659a2fba0df1" translate="yes" xml:space="preserve">
          <source>When the string has been upgraded to UTF-8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5aaa6f97ab5589891e81e58fbc94f58509000ee" translate="yes" xml:space="preserve">
          <source>When the string has come from an external source marked as Unicode</source>
          <target state="translated">当字符串来自标记为Unicode的外部来源时。</target>
        </trans-unit>
        <trans-unit id="33e82ba1ad1caecfef00b667970977ee30c1a1ff" translate="yes" xml:space="preserve">
          <source>When the taint mode (&lt;code&gt;-T&lt;/code&gt; ) is in effect, the &quot;.&quot; directory is removed from &lt;code&gt;@INC&lt;/code&gt; , and the environment variables &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERLLIB&lt;/code&gt; are ignored by Perl. You can still adjust &lt;code&gt;@INC&lt;/code&gt; from outside the program by using the &lt;code&gt;-I&lt;/code&gt; command line option as explained in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. The two environment variables are ignored because they are obscured, and a user running a program could be unaware that they are set, whereas the &lt;code&gt;-I&lt;/code&gt; option is clearly visible and therefore permitted.</source>
          <target state="translated">当异味模式（ &lt;code&gt;-T&lt;/code&gt; ）生效时，&amp;ldquo;。&amp;rdquo;从 &lt;code&gt;@INC&lt;/code&gt; 删除目录，Perl忽略环境变量 &lt;code&gt;PERL5LIB&lt;/code&gt; 和 &lt;code&gt;PERLLIB&lt;/code&gt; 。您仍然可以使用 &lt;code&gt;-I&lt;/code&gt; 命令行选项从程序外部调整 &lt;code&gt;@INC&lt;/code&gt; ，如&lt;a href=&quot;perlrun&quot;&gt;perlrun中所述&lt;/a&gt;。这两个环境变量会被忽略，因为它们被模糊了，并且运行程序的用户可能不知道已设置它们，而 &lt;code&gt;-I&lt;/code&gt; 选项清晰可见，因此可以使用。</target>
        </trans-unit>
        <trans-unit id="e34514e5e3372fed96ae586191867c70ca14aae4" translate="yes" xml:space="preserve">
          <source>When the taint mode (&lt;code&gt;-T&lt;/code&gt;) is in effect, the environment variables &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERLLIB&lt;/code&gt; are ignored by Perl. You can still adjust &lt;code&gt;@INC&lt;/code&gt; from outside the program by using the &lt;code&gt;-I&lt;/code&gt; command line option as explained in &lt;a href=&quot;perlrun#-Idirectory&quot;&gt;perlrun&lt;/a&gt;. The two environment variables are ignored because they are obscured, and a user running a program could be unaware that they are set, whereas the &lt;code&gt;-I&lt;/code&gt; option is clearly visible and therefore permitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05614cc2a7184900b0ce6634ffcfa41b43df8b62" translate="yes" xml:space="preserve">
          <source>When the test file finishes, outputs the summary, together.</source>
          <target state="translated">当测试文件完成后,输出总结,一起。</target>
        </trans-unit>
        <trans-unit id="5d3ce74817cdede8942c8b771dd9c729dbff5404" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;given&lt;/code&gt;. In Perl 5.14 and earlier, this form of &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; was only available when the &lt;a href=&quot;feature#The-%27switch%27-feature&quot;&gt;&lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature&lt;/a&gt; was enabled. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;&quot;Switch Statements&quot; in perlsyn&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7dc2674104ea2267f99aaaacf86ff6b7f8474b" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt;. In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">当没有BLOCK时， &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 是一个会落在当前 &lt;code&gt;when&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; 块中的函数，而不是迭代动态封闭的 &lt;code&gt;foreach&lt;/code&gt; 或退出 &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt; 的词汇封闭的函数。在Perl 5.14和更早版本中，仅当启用 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 功能时，这种 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 形式才可用。有关更多信息，请参见&lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;perlsyn中的&lt;/a&gt;&lt;a href=&quot;../feature&quot;&gt;功能&lt;/a&gt;和开关语句。</target>
        </trans-unit>
        <trans-unit id="d0601e1c27a0dc14d5d3038756194559ec0b7177" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;given&lt;/code&gt; . In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">当没有BLOCK时， &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 是一个函数，该函数会落在当前 &lt;code&gt;when&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; 块中，而不是迭代动态封闭的 &lt;code&gt;foreach&lt;/code&gt; 或退出 &lt;code&gt;given&lt;/code&gt; 的词法封闭。在Perl 5.14和更早版本中，仅当启用 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 功能时，这种 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 形式才可用。有关更多信息，请参见&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;perlsyn中的&lt;/a&gt;&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;和开关语句。</target>
        </trans-unit>
        <trans-unit id="d14e56899b59096c05cd14ff3a8ecfb95a7d60b7" translate="yes" xml:space="preserve">
          <source>When there is no method, it takes the method name as the name of the encoding and encodes the instance</source>
          <target state="translated">当没有方法时,它将方法名作为编码的名称,并将实例编码为</target>
        </trans-unit>
        <trans-unit id="b009ed76d6586de96f41fbede53e1b376b816ad5" translate="yes" xml:space="preserve">
          <source>When these are embedded in another pattern, what they match does not change, regardless of parenthesization or what modifiers are in effect in that outer pattern.</source>
          <target state="translated">当这些图案被嵌入到另一个图案中时,它们所匹配的内容不会改变,无论该图案中的括号或修饰符是否有效。</target>
        </trans-unit>
        <trans-unit id="dc5872b9a322af5576c1ac03e71331c1716252c8" translate="yes" xml:space="preserve">
          <source>When these are embedded in another pattern, what they match does not change, regardless of parenthesization or what modifiers are in effect in that outer pattern. If you fail to compile the subcomponents, you can get some nasty surprises. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1810832e010e811c7366d9b862298011ff2e0aa6" translate="yes" xml:space="preserve">
          <source>When this bit is set, &lt;code&gt;$sNewName&lt;/code&gt; can be &lt;code&gt;[]&lt;/code&gt; [for &lt;code&gt;NULL&lt;/code&gt;] to indicate that &lt;code&gt;$sOldName&lt;/code&gt; should be deleted during the next boot rather than renamed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c33d2bb86243cd92baa102e04bd026d16cffb4" translate="yes" xml:space="preserve">
          <source>When this code is executed there is no output. Here's why:</source>
          <target state="translated">当这段代码执行时,没有任何输出。这就是原因。</target>
        </trans-unit>
        <trans-unit id="7f61484b00c940e7437bf32bc5684d2e69d1807c" translate="yes" xml:space="preserve">
          <source>When this code is run only the &lt;code&gt;Derived&lt;/code&gt; object, &lt;code&gt;$b&lt;/code&gt; , will generate a warning.</source>
          <target state="translated">运行此代码时，只有 &lt;code&gt;Derived&lt;/code&gt; 对象 &lt;code&gt;$b&lt;/code&gt; 会生成警告。</target>
        </trans-unit>
        <trans-unit id="9309453554803d7d3570d025f7e35cec80cda5d1" translate="yes" xml:space="preserve">
          <source>When this code is run only the &lt;code&gt;Derived&lt;/code&gt; object, &lt;code&gt;$b&lt;/code&gt;, will generate a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917174880fc77c13ccda7d2e62ec7ea358e2a066" translate="yes" xml:space="preserve">
          <source>When this code is run with the &lt;b&gt;-w&lt;/b&gt; flag, a warning will be produced for the &lt;code&gt;$a&lt;/code&gt; line: &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; .</source>
          <target state="translated">当此代码与&lt;b&gt;-w&lt;/b&gt;标志一起运行时，将对 &lt;code&gt;$a&lt;/code&gt; 行产生警告： &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2388e2ced3b75ec3bd369e3152eae13dfe498282" translate="yes" xml:space="preserve">
          <source>When this code is run with the &lt;b&gt;-w&lt;/b&gt; flag, a warning will be produced for the &lt;code&gt;$a&lt;/code&gt; line: &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16748736985dd4c981bc264b989b01547f68e378" translate="yes" xml:space="preserve">
          <source>When this form of the pragma is used, only the non-character portions of locales are used by Perl, for example &lt;code&gt;LC_NUMERIC&lt;/code&gt; . Perl assumes that you have translated all the characters it is to operate on into Unicode (actually the platform's native character set (ASCII or EBCDIC) plus Unicode). For data in files, this can conveniently be done by also specifying</source>
          <target state="translated">使用这种形式的编译指示时，Perl仅使用语言环境的非字符部分，例如 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 。Perl假定您已将要操作的所有字符都转换为Unicode（实际上是平台的本机字符集（ASCII或EBCDIC）加上Unicode）。对于文件中的数据，也可以通过指定</target>
        </trans-unit>
        <trans-unit id="db1567ebb35e094978d64dee42e25f3b2f3257aa" translate="yes" xml:space="preserve">
          <source>When this form of the pragma is used, only the non-character portions of locales are used by Perl, for example &lt;code&gt;LC_NUMERIC&lt;/code&gt;. Perl assumes that you have translated all the characters it is to operate on into Unicode (actually the platform's native character set (ASCII or EBCDIC) plus Unicode). For data in files, this can conveniently be done by also specifying</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b915026102758b5ff7da846b6098df7e775168" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by</source>
          <target state="translated">当此函数被调用时,由</target>
        </trans-unit>
        <trans-unit id="e9e65ea3d452091e9942f0f5039cb9a617322586" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by &lt;code&gt;new_checker&lt;/code&gt; must be ready to be called, except for &lt;code&gt;*old_checker_p&lt;/code&gt; being unfilled. In a threading situation, &lt;code&gt;new_checker&lt;/code&gt; may be called immediately, even before this function has returned. &lt;code&gt;*old_checker_p&lt;/code&gt; will always be appropriately set before &lt;code&gt;new_checker&lt;/code&gt; is called. If &lt;code&gt;new_checker&lt;/code&gt; decides not to do anything special with an op that it is given (which is the usual case for most uses of op check hooking), it must chain the check function referenced by &lt;code&gt;*old_checker_p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc4ee6516decf05e05dd9bd8fd17984cd79424b" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by &lt;code&gt;new_plugin&lt;/code&gt; must be ready to be called, except for &lt;code&gt;*old_plugin_p&lt;/code&gt; being unfilled. In a threading situation, &lt;code&gt;new_plugin&lt;/code&gt; may be called immediately, even before this function has returned. &lt;code&gt;*old_plugin_p&lt;/code&gt; will always be appropriately set before &lt;code&gt;new_plugin&lt;/code&gt; is called. If &lt;code&gt;new_plugin&lt;/code&gt; decides not to do anything special with the identifier that it is given (which is the usual case for most calls to a keyword plugin), it must chain the plugin function referenced by &lt;code&gt;*old_plugin_p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa02f2fe554bd2a9b6a103fe9beb89d9b4e4476" translate="yes" xml:space="preserve">
          <source>When this happens, you can just</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01472604570ddd05a81c224b83daf7199b2292ca" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;OBJECT&lt;/code&gt; will be automagically derived from &lt;code&gt;O_FILES&lt;/code&gt; .</source>
          <target state="translated">设置为 &lt;code&gt;1&lt;/code&gt; 时，将自动从 &lt;code&gt;O_FILES&lt;/code&gt; 派生 &lt;code&gt;OBJECT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="447329d526fb82114543e70fb22d4772337fe346" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;OBJECT&lt;/code&gt; will be automagically derived from &lt;code&gt;O_FILES&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4611cd8d92449087862ca322a574ebe794802885" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt;, multiple XS files may be placed under</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e7dd367eef2d9f8124f8f23ef52e931a536491c" translate="yes" xml:space="preserve">
          <source>When this is true, CPAN will set PERL_MM_USE_DEFAULT to a true value. This causes ExtUtils::MakeMaker (and compatible) prompts to use default values instead of stopping to prompt you to answer questions. It also sets NONINTERACTIVE_TESTING to a true value to signal more generally that distributions should not try to interact with you.</source>
          <target state="translated">当该值为真时,CPAN 将把 PERL_MM_USE_DEFAULT 设置为真值。这将导致 ExtUtils::MakeMaker (和兼容的)提示使用默认值,而不是停止提示您回答问题。它还将 NONINTERACTIVE_TESTING 设置为真值,以更普遍地表明发行版不应该尝试与您交互。</target>
        </trans-unit>
        <trans-unit id="e48ad08805e823db4cab572ed48a495b3413c960" translate="yes" xml:space="preserve">
          <source>When this option is set to true AND the zip archive being read has the &quot;Language Encoding Flag&quot; (EFS) set, the member name is assumed to be encoded in UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ca05f5323dff5f446952bd69ac6477b5186d11" translate="yes" xml:space="preserve">
          <source>When to Still Use local()</source>
          <target state="translated">什么时候仍然使用local()</target>
        </trans-unit>
        <trans-unit id="84389d029ef5726370dd8c2cf19105277288fbc8" translate="yes" xml:space="preserve">
          <source>When to Use OO</source>
          <target state="translated">何时使用OO</target>
        </trans-unit>
        <trans-unit id="7fe9c30c4e2d69806274da4a183bd0637abe22d6" translate="yes" xml:space="preserve">
          <source>When true the entire test should be skipped. This is usually paired with an explanation in the &lt;code&gt;details&lt;/code&gt; field, and a &lt;code&gt;control&lt;/code&gt; facet that has &lt;code&gt;terminate&lt;/code&gt; set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aff41766b1c1facad70ba1087945ce4b9ff69fd" translate="yes" xml:space="preserve">
          <source>When true this parameter will set the FLG.FHCRC bit to 1 in the gzip header and set the CRC16 header field to the CRC of the complete gzip header except the CRC16 field itself.</source>
          <target state="translated">当为真时,该参数将把gzip头中的FLG.FHCRC位设置为1,并将CRC16头字段设置为除CRC16字段本身以外的完整gzip头的CRC。</target>
        </trans-unit>
        <trans-unit id="71e94facdb69a355a340449fba8e5c34fbd178ec" translate="yes" xml:space="preserve">
          <source>When true, perform the generation and addition to the MANIFEST of the SIGNATURE file in the distdir during 'make distdir', via 'cpansign -s'.</source>
          <target state="translated">当为 &quot;true &quot;时,在'make distdir'时,通过'cpansign -s'在distdir中生成并添加SIGNATURE文件的MANIFEST。</target>
        </trans-unit>
        <trans-unit id="2f8d8efe7dc5d620dd4b31a7d176203c2784135f" translate="yes" xml:space="preserve">
          <source>When true, suppresses the appending of installations to &lt;code&gt;perllocal&lt;/code&gt; .</source>
          <target state="translated">为true时，禁止将安装追加到 &lt;code&gt;perllocal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff5bff80188d068a00e6b218733a6d5345f2c3a2" translate="yes" xml:space="preserve">
          <source>When true, suppresses the appending of installations to &lt;code&gt;perllocal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a480e39d3219d70893b100f9cf0554ca8d0e6e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation and addition to the MANIFEST of the META.yml and META.json module meta-data files during 'make distdir'.</source>
          <target state="translated">当为 &quot;true &quot;时,在 &quot;make distdir &quot;时,抑制META.yml和META.json模块元数据文件的生成和添加到MANIFEST中。</target>
        </trans-unit>
        <trans-unit id="8f0d56eaaf65617686939dad5c1d3b6bcfce688e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation of MYMETA.yml and MYMETA.json module meta-data files during 'perl Makefile.PL'.</source>
          <target state="translated">当为真时,在'perl Makefile.PL'时抑制生成MYMETA.yml和MYMETA.json模块元数据文件。</target>
        </trans-unit>
        <trans-unit id="b0686c4aa533a7288139fdb7b691343d38cb093e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the writing of &lt;code&gt;packlist&lt;/code&gt; files for installs.</source>
          <target state="translated">为true时，禁止写入要安装的 &lt;code&gt;packlist&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="72af2071def396f7be81fd1ce806195fb7b786b5" translate="yes" xml:space="preserve">
          <source>When true, the tempdir used by the IPC driver will not be deleted when the test is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79c2493f27b952ee97bbc3534495620a8d27f41" translate="yes" xml:space="preserve">
          <source>When trying to explain stacks, most computer science textbooks mumble something about spring-loaded columns of cafeteria plates: the last thing you pushed on the stack is the first thing you pop off. That'll do for our purposes: your C program will push some arguments onto &quot;the Perl stack&quot;, shut its eyes while some magic happens, and then pop the results--the return value of your Perl subroutine--off the stack.</source>
          <target state="translated">当试图解释堆栈时,大多数计算机科学教科书都会喃喃自语,说是食堂盘子的弹簧柱:你推到堆栈上的最后一件事,就是你弹出的第一件事。对于我们的目的来说,这就足够了:你的C程序将把一些参数推到 &quot;Perl堆栈 &quot;上,在一些神奇的事情发生时闭上眼睛,然后把结果--Perl子程序的返回值--从堆栈上弹出。</target>
        </trans-unit>
        <trans-unit id="d64835545d5a37bef9d2f55b36f2fe943d1540a7" translate="yes" xml:space="preserve">
          <source>When tying a handle, the first argument to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; should begin with an asterisk. So, if you are tying STDOUT, use &lt;code&gt;*STDOUT&lt;/code&gt; . If you have assigned it to a scalar variable, say &lt;code&gt;$handle&lt;/code&gt; , use &lt;code&gt;*$handle&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; ties the scalar variable &lt;code&gt;$handle&lt;/code&gt; , not the handle inside it.</source>
          <target state="translated">系上手柄时，要 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 的第一个参数应以星号开头。因此，如果要捆绑STDOUT，请使用 &lt;code&gt;*STDOUT&lt;/code&gt; 。如果已将其分配给标量变量，例如 &lt;code&gt;$handle&lt;/code&gt; ，请使用 &lt;code&gt;*$handle&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; 标量变量 &lt;code&gt;$handle&lt;/code&gt; ，而不是其内部的句柄。</target>
        </trans-unit>
        <trans-unit id="db73b1d8c34ba44728cad3d2b1f319f02e5b59fc" translate="yes" xml:space="preserve">
          <source>When tying a handle, the first argument to &lt;code&gt;tie&lt;/code&gt; should begin with an asterisk. So, if you are tying STDOUT, use &lt;code&gt;*STDOUT&lt;/code&gt;. If you have assigned it to a scalar variable, say &lt;code&gt;$handle&lt;/code&gt;, use &lt;code&gt;*$handle&lt;/code&gt;. &lt;code&gt;tie $handle&lt;/code&gt; ties the scalar variable &lt;code&gt;$handle&lt;/code&gt;, not the handle inside it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec3ae376ab632badfb7a32a894228e134f3e11c" translate="yes" xml:space="preserve">
          <source>When uncompressing with &lt;code&gt;IO-Uncompress-Unzip&lt;/code&gt;, it will automatically detect if the zip file is zip64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47eb3f77b1aa39c24f8302cc0873a61651a1ff55" translate="yes" xml:space="preserve">
          <source>When used as a class method (&lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; , sometimes referred to as a static method), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">当用作类方法（ &lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; ，有时称为静态方法）时， &lt;code&gt;isa&lt;/code&gt; 返回</target>
        </trans-unit>
        <trans-unit id="1f0c66833fbe6e1b03af60ec0fe15b9334c1979b" translate="yes" xml:space="preserve">
          <source>When used as a class method (&lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt;, sometimes referred to as a static method), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd75a54bcbf3526f0df59166b3d1ecbeabab7eb5" translate="yes" xml:space="preserve">
          <source>When used as a class method the &lt;code&gt;\%facet_data&lt;/code&gt; argument is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162b9c04aadf8419ca082eaa8547d0e2ff3e950b" translate="yes" xml:space="preserve">
          <source>When used as a filter we want to invoke it like this:</source>
          <target state="translated">当作为过滤器使用时,我们要这样调用它。</target>
        </trans-unit>
        <trans-unit id="b4db60389b8735ef282c0fba599e707380d0e9b0" translate="yes" xml:space="preserve">
          <source>When used as an instance or class method (&lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">当用作实例或类方法（ &lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ）时， &lt;code&gt;isa&lt;/code&gt; 返回</target>
        </trans-unit>
        <trans-unit id="0c835a1bdea740af7b69e93efd47e9739cc62c50" translate="yes" xml:space="preserve">
          <source>When used as an instance or class method (&lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt;), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee80d9e31f7273254ea3de17e8c9cb461c0c08a0" translate="yes" xml:space="preserve">
          <source>When used as an object method the &lt;code&gt;\%facet_data&lt;/code&gt; argument may be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dac020145ba791bbcde686e21207104ab4efac0" translate="yes" xml:space="preserve">
          <source>When used as methods, all these subroutines call &lt;code&gt;$e-&amp;gt;facet_data()&lt;/code&gt;. The default &lt;code&gt;facet_data()&lt;/code&gt; method in &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; relies on the legacy methods this module emulates in order to work. As a result of this it is very easy to create infinite recursion bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e6ec0259043a949cd69ad7f24d41a6b32189cc3" translate="yes" xml:space="preserve">
          <source>When used like this, options and their possible values are removed from &lt;code&gt;@myopts&lt;/code&gt; , the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched at all.</source>
          <target state="translated">像这样使用时，选项及其可能的值将从 &lt;code&gt;@myopts&lt;/code&gt; 中删除，根本不会触摸全局 &lt;code&gt;@ARGV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80c8f7c123cd2630d333f7d9131c53ccb92cec1a" translate="yes" xml:space="preserve">
          <source>When used like this, options and their possible values are removed from &lt;code&gt;@myopts&lt;/code&gt;, the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea41fdab3a3ea375bf5d28665d083eb7efcab0b4" translate="yes" xml:space="preserve">
          <source>When used like this:</source>
          <target state="translated">当使用这样的。</target>
        </trans-unit>
        <trans-unit id="55e5fa91bb111ccb9cef7a1998ea49cd864765f0" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;#exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">在哈希元素上使用时，它告诉您是否定义了值，而不是键是否存在于哈希中。使用&lt;a href=&quot;#exists&quot;&gt;存在&lt;/a&gt;后者的目的。</target>
        </trans-unit>
        <trans-unit id="3ea5744253b0aebebea0a675efdda097478c50c9" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;#exists-EXPR&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt; for the latter purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6188971c7d17d6c416874631a361633fc0e0a7" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">在哈希元素上使用时，它告诉您是否定义了值，而不是键是否存在于哈希中。使用&lt;a href=&quot;exists&quot;&gt;存在&lt;/a&gt;后者的目的。</target>
        </trans-unit>
        <trans-unit id="50c2719662a96956c6434b730a2ed7499859c514" translate="yes" xml:space="preserve">
          <source>When used on an element of an array or hash, &lt;code&gt;is_shared&lt;/code&gt; checks if the specified element belongs to a shared array or hash. (It does not check the contents of that element.)</source>
          <target state="translated">当用于数组或哈希的元素时， &lt;code&gt;is_shared&lt;/code&gt; 检查指定的元素是否属于共享数组或哈希。（它不检查该元素的内容。）</target>
        </trans-unit>
        <trans-unit id="4c68152ee142aad2a08fe0b7ebba2ea1aa45f4fa" translate="yes" xml:space="preserve">
          <source>When used to pass a perl list to C the XS writer must provide a function (named after the array type but with 'Ptr' substituted for '*') to allocate the memory required to hold the list. A pointer should be returned. It is up to the XS writer to free the memory on exit from the function. The variable &lt;code&gt;ix_$var&lt;/code&gt; is set to the number of elements in the new array.</source>
          <target state="translated">当用于将Perl列表传递给C时，XS编写器必须提供一个函数（以数组类型命名，但用'Ptr'代替'*'）来分配保存列表所需的内存。应该返回一个指针。由XS编写器决定在函数退出时释放内存。变量 &lt;code&gt;ix_$var&lt;/code&gt; 设置为新数组中的元素数。</target>
        </trans-unit>
        <trans-unit id="39279e0ab9adf92c0d9845ce33153aaae548b141" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;.&lt;/code&gt;, the repeat count determines the starting position to calculate the value offset as follows:</source>
          <target state="translated">与一起使用时 &lt;code&gt;.&lt;/code&gt; ，重复计数确定计算值偏移量的起始位置，如下所示：</target>
        </trans-unit>
        <trans-unit id="059dd6ca0ad7f29f71f81bb70c2d0a3da8cc3820" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;@&lt;/code&gt; , the repeat count represents an offset from the start of the innermost &lt;code&gt;()&lt;/code&gt; group.</source>
          <target state="translated">与 &lt;code&gt;@&lt;/code&gt; 一起使用时，重复计数表示从最里面 &lt;code&gt;()&lt;/code&gt; 组的开始的偏移量。</target>
        </trans-unit>
        <trans-unit id="452ac7244192f1d1049652316194fb25f11bd124" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;@&lt;/code&gt;, the repeat count represents an offset from the start of the innermost &lt;code&gt;()&lt;/code&gt; group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745e9758fddddfd17b1f8070f37c73b6ef6dd2f4" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt; , a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="translated">当与 &lt;code&gt;Z&lt;/code&gt; 一起使用时，保证使用 &lt;code&gt;*&lt;/code&gt; 作为重复计数来添加尾随的空字节，因此，所得字符串始终比项目本身的字节长一个字节。</target>
        </trans-unit>
        <trans-unit id="3e309ae810b7ba69caf1b083747a6f0e33a6ad11" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt;, a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501ee2b6d5b82410bf49c6ef557d5b8111f9b9e9" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; .</source>
          <target state="translated">与类方法一起使用时，问题甚至更加严重。由于Perl允许将子例程名称写为裸词，因此Perl必须猜测方法后的裸词是类名称还是子例程名称。换句话说，Perl可以将语法解析为 &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt; &lt;b&gt;或&lt;/b&gt; &lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4f8a19419e9cae531fd00a5faf3b4b95c08f01c" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87eff678443c76527dd2ab6f92ce339964a9f84" translate="yes" xml:space="preserve">
          <source>When used with command line options:</source>
          <target state="translated">当使用命令行选项时。</target>
        </trans-unit>
        <trans-unit id="034d2956d3ab35d5d0a3009bf9f647819ce96d9f" translate="yes" xml:space="preserve">
          <source>When userelocatableinc is true, this variable holds the location that make install should copy the perl binary to, with all the run-time relocatable paths calculated from this at install time. When used, it is initialized to the original value of binexp, and then binexp is set to</source>
          <target state="translated">当userelocatableinc为true时,这个变量保存了make install应该将perl二进制文件复制到的位置,所有运行时的可重定位路径都是在安装时据此计算出来的。当使用时,它被初始化为binexp的原始值,然后将binexp设置为</target>
        </trans-unit>
        <trans-unit id="52d8c19f5d99981fe4c4d2fcb09c34b0b19ca9a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; on a &lt;code&gt;()&lt;/code&gt; group, this affects all types inside the group that accept byte-order modifiers, including all subgroups. It is silently ignored for all other types. You are not allowed to override the byte-order within a group that already has a byte-order modifier suffix.</source>
          <target state="translated">在 &lt;code&gt;()&lt;/code&gt; 组上使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&lt;/code&gt; 时，这会影响该组内所有接受字节顺序修饰符的类型，包括所有子组。对于所有其他类型，它将被静默忽略。不允许覆盖已经有字节顺序修饰符后缀的组中的字节顺序。</target>
        </trans-unit>
        <trans-unit id="834a7e8ec8b7da2f955444b22e5081d5fee5d139" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt; , &lt;code&gt;@EXPORT&lt;/code&gt; , &lt;code&gt;@ISA&lt;/code&gt; , etc.</source>
          <target state="translated">当将 &lt;code&gt;Exporter&lt;/code&gt; 与标准 &lt;code&gt;strict&lt;/code&gt; 和 &lt;code&gt;warnings&lt;/code&gt; 编译指示一起使用时，需要 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 关键字来声明包变量@ &lt;code&gt;@EXPORT_OK&lt;/code&gt; ，@ &lt;code&gt;@EXPORT&lt;/code&gt; ，@ &lt;code&gt;@ISA&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="ff82b6a088bd3949701c2e9690b32b71bbe25933" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;our&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt;, &lt;code&gt;@EXPORT&lt;/code&gt;, &lt;code&gt;@ISA&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098b7ca0910242ebfe289953bb787b86df641163" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="translated">当使用 &lt;code&gt;IPC::Open3&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 时，如果您提供一个字符串作为 &lt;code&gt;command&lt;/code&gt; 参数，则假定它已被适当地转义。您可以使用 &lt;code&gt;QUOTE&lt;/code&gt; 常量用作可移植的引号字符（请参见上文）。但是，如果提供数组引用，则适用特殊规则：</target>
        </trans-unit>
        <trans-unit id="d2f0399c3e8df8b441dc7a3e6752ac0ac539b907" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac72f6ccde75b586d99f93dce2fef690fbdd778e" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt; , if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="translated">当使用 &lt;code&gt;IPC::Run&lt;/code&gt; ，如果您提供一个字符串作为 &lt;code&gt;command&lt;/code&gt; 参数，则该字符串将在空白处分割以确定命令的各个元素。尽管这通常只会执行您的意思，但是如果其中包含空格的文件或命令可能会中断。</target>
        </trans-unit>
        <trans-unit id="cb299ab15bb95a67fd9da59509a66d398c459654" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd114611c2ad871f0c8eb7b6bb0b00563bb8b3c" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Perl_langinfo&lt;/code&gt; on systems that don't have a native &lt;code&gt;nl_langinfo()&lt;/code&gt;, you must</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887f4ef11aea133bd95f7e158dd018aa1d9071b1" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; , or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="translated">当将 &lt;code&gt;autodie&lt;/code&gt; 或 &lt;code&gt;Fatal&lt;/code&gt; 与用户子例程一起使用时，这些子例程的声明必须出现在首次使用 &lt;code&gt;Fatal&lt;/code&gt; 或 &lt;code&gt;autodie&lt;/code&gt; 之前，或者已经从模块中导出。尝试在其他用户子例程上使用 &lt;code&gt;Fatal&lt;/code&gt; 或 &lt;code&gt;autodie&lt;/code&gt; 会导致编译时错误。</target>
        </trans-unit>
        <trans-unit id="d38b1b6fe53eaefb297f9d879236a334c99468e3" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt;, or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ea0745997af7ee70fec196994401476b7830212" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt; , objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;fd_retrieve&lt;/code&gt; 时，将按顺序检索对象，每个关联的 &lt;code&gt;store_fd&lt;/code&gt; 检索一个对象（即一棵递归树）。</target>
        </trans-unit>
        <trans-unit id="12e3df8bd541ba3c998025aaa4430e3500847d06" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt;, objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d48fc5105eb38ba5d5e3af6a3868bf8d76aac7" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt; ) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt; .</source>
          <target state="translated">使用GCC时，该条目指定MakeMaker应该首先在 &lt;code&gt;$Config{libpth}&lt;/code&gt; 指定的所有位置中寻找 &lt;code&gt;libgl.a&lt;/code&gt; （后跟 &lt;code&gt;gl.a&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2c8cc8b7dc989aa2e0c54fa773dd36d96d318229" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt;) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c3fbdf4905ed574790e43ad2b1e958281ade4d" translate="yes" xml:space="preserve">
          <source>When using Module::Build, this will usually be:</source>
          <target state="translated">当使用Module::Build时,这通常会是。</target>
        </trans-unit>
        <trans-unit id="04e10d3b847f5d46ec45809bdc9654ea510527e6" translate="yes" xml:space="preserve">
          <source>When using PUSHCOLOR, POPCOLOR, and LOCALCOLOR, it's particularly important to not put commas between the constants.</source>
          <target state="translated">当使用PUSHCOLOR、POPCOLOR和LOCALCOLOR时,特别重要的是不要在常量之间加逗号。</target>
        </trans-unit>
        <trans-unit id="0fcdfebaed2e26ac7b40fe2bc2a6520f86b06a73" translate="yes" xml:space="preserve">
          <source>When using Term::ReadLine, you can turn ornaments on so that your input stands out against the output from CPAN.pm.</source>
          <target state="translated">当使用Term::ReadLine时,你可以打开饰品,使你的输入与CPAN.pm的输出形成鲜明对比。</target>
        </trans-unit>
        <trans-unit id="3bb24a915046f34ce04a56f60336d0fb58d6c025" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; for file paths.</source>
          <target state="translated">当使用Unix或MSDOS语法时，它会模拟 &lt;code&gt;dirname(1)&lt;/code&gt; shell函数，该函数与 &lt;code&gt;fileparse()&lt;/code&gt; 的工作方式稍有不同。即使最后一级显然是目录，它也会返回文件路径的最后一级以外的所有内容。实际上，它不是返回目录部分，而只是返回上一级的路径，类似于文件路径的 &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83acdc7454980247f70cca18686669a6056893a4" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;chop()&lt;/code&gt; for file paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd36b103bb843eb67404d1ba086bba3444a9a91a" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt; ).</source>
          <target state="translated">当使用GCC以外的编译器时，以上条目将搜索 &lt;code&gt;gl.lib&lt;/code&gt; （紧随其后的是 &lt;code&gt;libgl.lib&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c33d34fd00e0ffeecdde05351cb8111bf653102c" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a204d7a3df2c41a83e110893f714e673583621f8" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="translated">当使用不支持内联修饰符的 &lt;code&gt;(?:)&lt;/code&gt; 构造的自定义引擎时，最好将 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 字符串化为所提供的模式，请注意，在以下情况下，这将创建不需要的模式：</target>
        </trans-unit>
        <trans-unit id="5336937191442d7debf67f5b96f41e967c4d55af" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;qr//&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa29772ff0d1046f60f263e930495cc6300916c4" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt; , in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="translated">使用签名时，除了签名的词法变量之外，特殊数组变量 &lt;code&gt;@_&lt;/code&gt; 中的参数仍然可用。两种访问参数的方式有所不同： &lt;code&gt;@_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e523513d7b0658b27eb8124687617b728e5c9ac2" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt;, in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551ef8173c29847114a58bb1f60332f351498c93" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt; ), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="translated">当使用这些例程中的任何一个（ &lt;code&gt;call_argv&lt;/code&gt; 除外）时，程序员必须操纵Perl堆栈。这些包括以下宏和函数：</target>
        </trans-unit>
        <trans-unit id="b91da188fa3782ad027e51e622e75b65bd3a446d" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt;), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83deb7885e7123190175e707dccaec554d080b8" translate="yes" xml:space="preserve">
          <source>When using look-ahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="translated">当使用前瞻断言和否定时,这一切可能会变得更加棘手。想象一下,你想找到一个不以 &quot;123 &quot;开头的非数字序列。你可以试着写成</target>
        </trans-unit>
        <trans-unit id="8056637c2c9cbcfa303f8f1dbc6790e418dcb403" translate="yes" xml:space="preserve">
          <source>When using lookahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f069b81fc03a5abd7bd819f6288faad34de8014e" translate="yes" xml:space="preserve">
          <source>When using non-blocking mode, the caller must repeatedly check for writeability on the filehandle (for instance using &lt;code&gt;select&lt;/code&gt; or &lt;code&gt;IO::Poll&lt;/code&gt;). Each time the filehandle is ready to write, the &lt;code&gt;connect&lt;/code&gt; method must be called, with no arguments. Note that some operating systems, most notably &lt;code&gt;MSWin32&lt;/code&gt; do not report a &lt;code&gt;connect()&lt;/code&gt; failure using write-ready; so you must also &lt;code&gt;select()&lt;/code&gt; for exceptional status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104bb1d18df407b49f695cf681f4f8244f6c16f3" translate="yes" xml:space="preserve">
          <source>When using perl on OS/390 please keep in mind that the EBCDIC and ASCII character sets are different. See perlebcdic.pod for more on such character set issues. Perl builtin functions that may behave differently under EBCDIC are also mentioned in the perlport.pod document.</source>
          <target state="translated">当在OS/390上使用perl时,请记住EBCDIC和ASCII字符集是不同的。有关此类字符集问题的更多信息,请参见 perlebcdic.pod。perlport.pod文档中也提到了在EBCDIC下可能表现不同的Perl内置函数。</target>
        </trans-unit>
        <trans-unit id="1ef7e739e319a736386db6464491dd098d4f2bf1" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; . A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt; . (Don't judge me.)</source>
          <target state="translated">在 &lt;code&gt;-m&lt;/code&gt; 模式（显示模块源代码）下使用perldoc时， &lt;code&gt;perldoc&lt;/code&gt; 将尝试使用 &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; 中设置的寻呼机。该命令的一个有用设置是您喜欢的编辑器，如 &lt;code&gt;/usr/bin/nano&lt;/code&gt; 。（不要判断我）</target>
        </trans-unit>
        <trans-unit id="ca44e9fc9c83d8e97acbec5970188d530099b61d" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt;. A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt;. (Don't judge me.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f3d08e19ee9978bf8615d5e1fb391a30ff5fc30" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, and the dotted ip string will be returned instead of just the host. If the optional $host argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than syn.</source>
          <target state="translated">当使用 &quot;syn &quot;协议时,使用这个方法来确定远程主机的可到达性。这个方法的调用次数与调用ping()的次数一样多。每次调用都会返回带有TCP ACK的主机(如传递给ping()的那样)。返回主机的顺序不一定与使用ping()方法进行SYN排队的顺序相同。如果在收到TCP ACK之前就达到了超时,或者远程主机没有在尝试的端口上监听,那么TCP连接将无法建立,ack()将返回undef。在列表上下文中,将返回主机、ack时间和点号ip字符串,而不是只返回主机。如果指定了可选的$host参数,返回值将只与该主机有关。如果你使用的是除syn以外的其他协议,这个调用根本没有任何作用。</target>
        </trans-unit>
        <trans-unit id="420afa8aef5868ada909527b4d0cf95eed4c31dc" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, the dotted ip string, and the port number will be returned instead of just the host. If the optional &lt;code&gt;$host&lt;/code&gt; argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than &quot;syn&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8669a447d2a5338b38de691880feda228a223459" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;+&lt;/code&gt; prototype, your function must check that the argument is of an acceptable type.</source>
          <target state="translated">使用 &lt;code&gt;+&lt;/code&gt; 原型时，您的函数必须检查参数是否为可接受的类型。</target>
        </trans-unit>
        <trans-unit id="665e3521b5bde08e89b6fb412400db5ea3876686" translate="yes" xml:space="preserve">
          <source>When using the Borland compiler, the second item is returned as &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt;, and MakeMaker takes care of moving the &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; to the correct place in the linker command line.</source>
          <target state="translated">使用Borland编译器时，第二项以 &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt; ，MakeMaker负责将 &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; 移动到链接器命令行中的正确位置。</target>
        </trans-unit>
        <trans-unit id="182973d530ef056d12686b9b768cbe121c56d846" translate="yes" xml:space="preserve">
          <source>When using the GUI version of SAM, click on the Kernel Configuration icon, then the Configurable Parameters icon. Scroll down and select the maxdsiz line. From the Actions menu, select the Modify Configurable Parameter item. Insert the new formula into the Formula/Value box. Then follow the instructions to rebuild your kernel and reboot your system.</source>
          <target state="translated">当使用GUI版本的SAM时,点击内核配置图标,然后点击可配置参数图标。向下滚动并选择maxdsiz行。从Actions菜单中,选择Modify Configurable Parameter项目。在Formula/Value框中插入新的公式。然后按照说明重建内核并重启系统。</target>
        </trans-unit>
        <trans-unit id="7f3f457ad81c7a19053f3621a5ae319fe9cb4521" translate="yes" xml:space="preserve">
          <source>When using the Visual C compiler, the second item is returned as &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt;.</source>
          <target state="translated">使用Visual C编译器时，第二项作为 &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa76c289706bb600b3c9b3e3777d7935b3662cb5" translate="yes" xml:space="preserve">
          <source>When using the constants, if you don't want to have to remember to add the &lt;code&gt;, RESET&lt;/code&gt; at the end of each print line, you can set $Term::ANSIColor::AUTORESET to a true value. Then, the display mode will automatically be reset if there is no comma after the constant. In other words, with that variable set:</source>
          <target state="translated">使用常量时，如果不想记住在每个打印行的末尾添加 &lt;code&gt;, RESET&lt;/code&gt; ，则可以将$ Term :: ANSIColor :: AUTORESET设置为真实值。然后，如果常量后面没有逗号，则显示模式将自动重置。换句话说，设置该变量：</target>
        </trans-unit>
        <trans-unit id="a51c1c8c0eb3074d9df3759b3281e7508c8091a5" translate="yes" xml:space="preserve">
          <source>When using this compiler to build Perl, you should make sure that the flag -Aa is added to the cpprun and cppstdin variables in the config.sh file (though see the section on 64-bit perl below). If you are using a recent version of the Perl distribution, these flags are set automatically.</source>
          <target state="translated">当使用这个编译器来编译Perl时,你应该确保在config.sh文件中的cpprun和cppstdin变量中加入了标志-Aa(参见下面关于64位perl的章节)。如果你使用的是最新版本的 Perl 发行版,这些标志会自动设置。</target>
        </trans-unit>
        <trans-unit id="a190d4d20525775f69d139675c3dc51cef5fb8f2" translate="yes" xml:space="preserve">
          <source>When using tools like &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; that can generate the &lt;code&gt;provides&lt;/code&gt; mapping for your distribution automatically, make sure you examine what it generates to make sure it makes sense - indexers will usually trust the &lt;code&gt;provides&lt;/code&gt; field if it's present, rather than scanning through the distribution files themselves to figure out packages and versions. This is a good thing, because it means you can use the &lt;code&gt;provides&lt;/code&gt; field to tell the indexers precisely what you want indexed about your distribution, rather than relying on them to essentially guess what you want indexed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d278a4b7e876e4a2527267176d89369b93fdace" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">验证现有摘要字符串时，应将摘要用作盐（例如 &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ）。用于创建摘要的SALT作为摘要的一部分可见。这样可以确保crypt（）使用与摘要相同的盐值来哈希新字符串。这使您的代码可以与标准&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;以及更多奇异的实现一起使用。换句话说，对于返回的字符串本身或SALT多少字节可能无关紧要。</target>
        </trans-unit>
        <trans-unit id="1154d04d428d0c152c2ffba2d49aad6c93079515" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">验证现有摘要字符串时，应将摘要用作盐（例如 &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ）。用于创建摘要的SALT作为摘要的一部分可见。这样可以确保crypt（）使用与摘要相同的盐值来哈希新字符串。这使您的代码可以与标准&lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt;以及更多奇异的实现一起使用。换句话说，对于返回的字符串本身或SALT多少字节可能无关紧要。</target>
        </trans-unit>
        <trans-unit id="213bdf210d4174fda29ca99ffa2edc52c2a2b3fb" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;crypt($plain, $digest) eq $digest&lt;/code&gt;). The SALT used to create the digest is visible as part of the digest. This ensures &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ffe4a395b717a174f8af1eb199172f9bf8e1018" translate="yes" xml:space="preserve">
          <source>When we bless something, we are not blessing the variable which contains a reference to that thing, nor are we blessing the reference that the variable stores; we are blessing the thing that the variable refers to (sometimes known as the</source>
          <target state="translated">当我们祝福某件事时,我们不是祝福包含对该事物的引用的变量,也不是祝福变量所存储的引用;我们是祝福变量所引用的事物(有时也被称为该事物的</target>
        </trans-unit>
        <trans-unit id="7f1d89cf9a7bec3f0e241604b9f6d2928198590e" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="translated">当我们对变量调用 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 时，实际上是在祝福该变量所引用的基础数据结构。我们没有祝福引用本身，也没有祝福包含该引用的变量。这就是第二次对 &lt;code&gt;blessed( $bar )&lt;/code&gt; 调用返回false的原因。那时， &lt;code&gt;$bar&lt;/code&gt; 不再存储对对象的引用。</target>
        </trans-unit>
        <trans-unit id="6555170698fd78a17d09b080573745f1fb3e931d" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;bless&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c70879bf53ea832ca0790a74069f648240179f77" translate="yes" xml:space="preserve">
          <source>When we make a method call, Perl arranges for the method's &lt;b&gt;invocant&lt;/b&gt; to be passed as the first argument. &lt;b&gt;Invocant&lt;/b&gt; is a fancy name for the thing on the left side of the arrow. The invocant can either be a class name or an object. We can also pass additional arguments to the method:</source>
          <target state="translated">当我们把一个方法调用，Perl的安排方法的&lt;b&gt;调用者&lt;/b&gt;，以作为第一个参数传递。&lt;b&gt;Invocant&lt;/b&gt;是箭头左侧的东西的奇特名称。发起人可以是类名或对象。我们还可以将其他参数传递给该方法：</target>
        </trans-unit>
        <trans-unit id="8e5660d78c1c3767afae15f24a83c561307c4b20" translate="yes" xml:space="preserve">
          <source>When we say &quot;Mac OS&quot; below, we mean Mac OS 7, 8, and 9, and</source>
          <target state="translated">下面我们说的 &quot;Mac OS &quot;是指Mac OS 7、8、9和</target>
        </trans-unit>
        <trans-unit id="32e492af43a84b7607b727f8ffe43ea47c5296c8" translate="yes" xml:space="preserve">
          <source>When we want to place values to be returned to the caller onto the stack, we use the series of macros that begin with &quot;XPUSH&quot;. There are five different versions, for placing integers, unsigned integers, doubles, strings, and Perl scalars on the stack. In our example, we placed a Perl scalar onto the stack. (In fact this is the only macro which can be used to return multiple values.)</source>
          <target state="translated">当我们要将返回给调用者的值放置在栈上时,我们使用一系列以 &quot;XPUSH &quot;开头的宏。有五个不同的版本,用于将整数、无符号整数、双数、字符串和Perl标量放在栈上。在我们的例子中,我们将Perl标量放置在堆栈上。(事实上,这是唯一一个可以用来返回多个值的宏。)</target>
        </trans-unit>
        <trans-unit id="5c32617504af087d7eaf74d60f9f81f18d15e5a1" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt; . This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="translated">当遇到长度超过 &lt;code&gt;$columns&lt;/code&gt; 单词时，它们将被分解。 &lt;code&gt;wrap()&lt;/code&gt; 在 &lt;code&gt;$columns&lt;/code&gt; 添加 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 。可以通过将 &lt;code&gt;$huge&lt;/code&gt; 设置为 'die'或'overflow' 来覆盖此行为。当设置为'die'时，较大的单词将导致 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 被调用。设置为&amp;ldquo;溢出&amp;rdquo;时，大字将保持不变。</target>
        </trans-unit>
        <trans-unit id="5ebaaddfa0e00536f0f1b77f056696aff48f065e" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt;. This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;die()&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a8fd5862d63d0243193e3a0106e35c7816b525" translate="yes" xml:space="preserve">
          <source>When writing a DBM filter it is</source>
          <target state="translated">当编写一个DBM过滤器时,它是</target>
        </trans-unit>
        <trans-unit id="6e29ef5da6dd2ada1107f66b4d19daef44972a34" translate="yes" xml:space="preserve">
          <source>When writing a Perl extension for general consumption, one should expect that the extension will be used with versions of Perl different from the version available on your machine. Since you are reading this document, the version of Perl on your machine is probably 5.005 or later, but the users of your extension may have more ancient versions.</source>
          <target state="translated">当编写一个用于一般消费的Perl扩展时,我们应该预料到该扩展将与你机器上的Perl版本不同。由于你正在阅读这篇文档,你的机器上的Perl版本可能是5.005或更高版本,但你的扩展的用户可能有更古老的版本。</target>
        </trans-unit>
        <trans-unit id="b339c5d874b742d033a9c15bc59a2eb32b3fde03" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt; , unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt; .</source>
          <target state="translated">将字符UV写入UTF-8字符串时，请&lt;b&gt;始终&lt;/b&gt;使用 &lt;code&gt;uvchr_to_utf8&lt;/code&gt; ，除非使用 &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; 在这种情况下可以使用 &lt;code&gt;*s = uv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ffec04c54d59e59616907c7e9e4db0144cb75f4" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt;, unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f50a991a4544cc3b4a29ac32fb9e95a158b8cf9" translate="yes" xml:space="preserve">
          <source>When writing a gzip file this interface will</source>
          <target state="translated">当写一个gzip文件时,这个接口将</target>
        </trans-unit>
        <trans-unit id="bb628954db56a328fb9c77ac1ab1c6c9e5566f04" translate="yes" xml:space="preserve">
          <source>When writing to a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before writing to the file.</source>
          <target state="translated">写入文件或文件句柄时，在写入文件之前设置 &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b83d473ca051f901386a9b5075ab3cc8642b96d1" translate="yes" xml:space="preserve">
          <source>When you</source>
          <target state="translated">当你</target>
        </trans-unit>
        <trans-unit id="2677cbf7ed31e30ff85aaafd2211c14bcf4260ba" translate="yes" xml:space="preserve">
          <source>When you are content with suspects list, you can now</source>
          <target state="translated">当您对嫌疑人名单感到满意时,您现在可以进行以下操作</target>
        </trans-unit>
        <trans-unit id="2f2f89e3cbdda44107d5b7350f0150202920760d" translate="yes" xml:space="preserve">
          <source>When you are done, the XS-module install process will have added information to your &quot;perllocal&quot; information telling that the perl binary has been replaced, and what module was installed. You can view this information at any time by using the command:</source>
          <target state="translated">当你完成后,XS-module安装过程会在你的 &quot;perllocal &quot;信息中添加信息,告诉你perl二进制文件已经被替换,以及安装了什么模块。你可以在任何时候使用命令来查看这些信息。</target>
        </trans-unit>
        <trans-unit id="b326342faabbb3f551d027918413fb764e7ae496" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself (if you feel masochistic enough) from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081b49cdc45047c15c231503ee57d721c9ac98ea" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="translated">当您要使用GNU C编译器（gcc）且还没有gcc时，您可以从源代码自己构建它（例如，可以从&lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html获得&lt;/a&gt;）。或从&lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt;的HP移植中心获取预构建的二进制文件，或者从&lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://www.hp.com/go/DSPP&lt;/a&gt;（您需要成为成员）：？//h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801 CIID = 2a08725cc2f02110725cc2f02110275d6e10RCRD＆jumpid = reg_r1002_usen_c-001_title_r0001（浏览列表，因为经常有同一个包的多个版本）。</target>
        </trans-unit>
        <trans-unit id="1e1fba30b9427287c1016e2b2ee037287889c225" translate="yes" xml:space="preserve">
          <source>When you are manually creating a UCM file, you should copy ascii.ucm or an existing encoding which is close to yours, rather than write your own from scratch.</source>
          <target state="translated">当您手动创建UCM文件时,您应该复制ascii.ucm或与您的编码相近的现有编码,而不是从头开始编写自己的编码。</target>
        </trans-unit>
        <trans-unit id="4780d196081ec9146c3e56c719b52c3ce1654983" translate="yes" xml:space="preserve">
          <source>When you are satisfied with the results of tests, install the build C libraries for extensions:</source>
          <target state="translated">当你对测试结果满意后,安装扩展的构建C库。</target>
        </trans-unit>
        <trans-unit id="a59f72a1e66eb8909341fcc7e63f4b0c726287dd" translate="yes" xml:space="preserve">
          <source>When you are sure that only a few subdirectories lead to failures, you may want to add &lt;code&gt;-j4&lt;/code&gt; option to &lt;code&gt;make&lt;/code&gt; to speed up skipping subdirectories with already finished build.</source>
          <target state="translated">当你确信只有几个子目录导致故障，您可能要添加 &lt;code&gt;-j4&lt;/code&gt; 选项 &lt;code&gt;make&lt;/code&gt; 加快与已经完成构建跳过子目录。</target>
        </trans-unit>
        <trans-unit id="7b2f8e90d6f4d4294f6e2dcda859cd96193b4ae7" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;icmp&quot; protocol, this call permit to change the message type to 'echo' or 'timestamp' (only for IPv4, see RFC 792).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0610c400691e07d6b5c5967ea7cb5f197bdd7da" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="translated">当您使用&amp;ldquo;流&amp;rdquo;协议时，此调用会预先打开tcp套接字。仅当您要在创建连接时提供不同的超时时间时才需要执行此操作，或者从第一次ping中消除建立连接的开销。如果不调用 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; ，则在第一次调用 &lt;code&gt;ping()&lt;/code&gt; 时会自动打开连接。如果您使用流以外的任何协议，则此调用完全不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="53d7ace59a255ce0dee603a0e82c9350ed60c845" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;open()&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19030bdd1652e63fb5fe9a91af20f3234d06d23f" translate="yes" xml:space="preserve">
          <source>When you assign a list of scalars to an array, all previous values in that array are wiped out and the number of elements in the array will now be equal to the number of elements in the right-hand list -- the list from which assignment was made. The array will automatically resize itself to precisely accommodate each element in the right-hand list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9fd269eddc721c08a06a789973e8783627db576" translate="yes" xml:space="preserve">
          <source>When you build modules, tell Perl where to install the modules.</source>
          <target state="translated">当你构建模块时,告诉Perl安装模块的位置。</target>
        </trans-unit>
        <trans-unit id="d2efe854f0b34964ee2879b9748bb899c2079d18" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt; :</source>
          <target state="translated">当您使用参数调用 &lt;code&gt;bar&lt;/code&gt; 时，您会看到 &lt;code&gt;foo&lt;/code&gt; 拥有相同的 &lt;code&gt;@_&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c91152667ee3ebf07dbc40066530c9ec19f3697d" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835f87385a105654b52b3b81d31156a333d91b09" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;open&lt;/code&gt; this way, Perl invokes the given command directly, bypassing the shell. As such, the shell won't try to interpret any special characters within the command's argument list, which might overwise have unwanted effects. This can make for safer, less error-prone &lt;code&gt;open&lt;/code&gt; calls, useful in cases such as passing in variables as arguments, or even just referring to filenames with spaces in them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685020a1713f908c5ec69a7f573fc741004b77c1" translate="yes" xml:space="preserve">
          <source>When you call Perl's &lt;code&gt;open&lt;/code&gt; to set a Perl file handle [like &lt;code&gt;STDOUT&lt;/code&gt;], Perl calls C's &lt;code&gt;fopen&lt;/code&gt; to set a stdio &lt;code&gt;FILE *&lt;/code&gt;. C's &lt;code&gt;fopen&lt;/code&gt; calls something like Unix's &lt;code&gt;open&lt;/code&gt;, that is, Win32's &lt;code&gt;_sopen&lt;/code&gt;, to get an integer file descriptor [where 0 is for &lt;code&gt;STDIN&lt;/code&gt;, 1 for &lt;code&gt;STDOUT&lt;/code&gt;, etc.]. Win32's &lt;code&gt;_sopen&lt;/code&gt; calls &lt;code&gt;CreateFile&lt;/code&gt; to set a &lt;code&gt;HANDLE&lt;/code&gt;, a Win32 native file handle. So every Perl file handle [like &lt;code&gt;STDOUT&lt;/code&gt;] has an integer file descriptor associated with it that you can get via &lt;code&gt;fileno&lt;/code&gt;. And, under Win32, every file descriptor has a Win32 native file handle associated with it. &lt;code&gt;FdGetOsFHandle&lt;/code&gt; lets you get access to that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e313737a6b3963a3bf8908006a0a820d6e4555f" translate="yes" xml:space="preserve">
          <source>When you call a fully qualified method name like &lt;code&gt;File::save&lt;/code&gt;, the method resolution search for the &lt;code&gt;save&lt;/code&gt; method starts in the &lt;code&gt;File&lt;/code&gt; class, skipping any &lt;code&gt;save&lt;/code&gt; method the &lt;code&gt;File::MP3&lt;/code&gt; class may have defined. It still searches the &lt;code&gt;File&lt;/code&gt; class's parents if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010f5217ea46f708fe21b0efa65632329708b27e" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; , the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; , the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt; .</source>
          <target state="translated">调用方法时，箭头左侧的内容将作为第一个参数传递给该方法。这意味着当我们调用 &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; 时， &lt;code&gt;new()&lt;/code&gt; 方法将接收字符串 &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; 作为其第一个参数。当我们调用 &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; ，会将 &lt;code&gt;$fred&lt;/code&gt; 变量作为第一个参数传递给talk &lt;code&gt;speak()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fae81431a82ed2b7245ab26b577216b20acfee24" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt;, the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt;, the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210c4bda966e8ba5f3d3dd89593f4b86c57dc0ef" translate="yes" xml:space="preserve">
          <source>When you call the &lt;code&gt;tie&lt;/code&gt; function to bind an associative array to this package, you may specify as an optional argument the symbol table in which you wish to create and delete symbols. If the argument is the string 'GLOBAL', then the global symbol table is used; any other string causes the local symbol table to be used. Note that this argument does not affect attempts to read symbols; if a symbol with the specified name exists in the local symbol table, it is always returned in preference to a symbol by the same name in the global symbol table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ac7d5348373bdb94113353aa9433d2aa26a56e" translate="yes" xml:space="preserve">
          <source>When you change a &lt;b&gt;value&lt;/b&gt; as it is being copied. [From French &amp;ldquo;in passing&amp;rdquo;, as in the exotic pawn-capturing maneuver in chess.]</source>
          <target state="translated">当您更改要复制的&lt;b&gt;值时&lt;/b&gt;。[摘自法语&amp;ldquo;通过&amp;rdquo;，如国际象棋中充满异国情调的典当捕获动作。]</target>
        </trans-unit>
        <trans-unit id="f19e6c82fbc2b2542cdae76f95f1a0c2e0deb19b" translate="yes" xml:space="preserve">
          <source>When you chop() a mathemagical object it is promoted to a string and its mathemagical properties are lost. The same can happen with other operations as well.</source>
          <target state="translated">当你砍()一个数学对象时,它会被提升为一个字符串,并且它的数学属性会丢失。同样的情况也会发生在其他操作上。</target>
        </trans-unit>
        <trans-unit id="ffb591449d98f90fa2f19a8fc5d8c220dd517b21" translate="yes" xml:space="preserve">
          <source>When you combine legacy data and Unicode, the legacy data needs to be upgraded to Unicode. Normally the legacy data is assumed to be ISO 8859-1 (or EBCDIC, if applicable).</source>
          <target state="translated">当您将遗留数据和Unicode结合起来时,需要将遗留数据升级为Unicode。通常,遗留数据被假定为ISO 8859-1(或EBCDIC,如果适用)。</target>
        </trans-unit>
        <trans-unit id="177eeefc399a73cfd5bfb70b98c9df5de8601114" translate="yes" xml:space="preserve">
          <source>When you create a map, you SHOULD make your mappings round-trip safe. That is, &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq
$data&lt;/code&gt; stands for all characters that are marked as &lt;code&gt;|0&lt;/code&gt;. Here is how to make sure:</source>
          <target state="translated">创建地图时，应确保地图往返安全。也就是说， &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq $data&lt;/code&gt; 表示标记为 &lt;code&gt;|0&lt;/code&gt; 所有字符。这是如何确保：</target>
        </trans-unit>
        <trans-unit id="bb9cd7b8a4ff60818aa2eb01184f94103173f0c2" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt; .</source>
          <target state="translated">当使用上述方法声明诸如 &lt;code&gt;PI&lt;/code&gt; 之类的常量时，运行脚本的每台计算机都可以使用尽可能多的精度。同样，您的程序将更易于阅读，更易于维护（并正确维护），并且不太可能向错误的行星发送空间探测器，因为没有人注意到您编写 &lt;code&gt;3.14195&lt;/code&gt; 的公式。</target>
        </trans-unit>
        <trans-unit id="4e2b5a1dcab630574856b807ba52f00dea975f20" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ad5430f738cd6a6ba4f6afa7a8297067c10fdd" translate="yes" xml:space="preserve">
          <source>When you decode(=?</source>
          <target state="translated">当你解码(=?</target>
        </trans-unit>
        <trans-unit id="1f9cd5bf8b9a9dc5c6c543459671e6a174da6ded" translate="yes" xml:space="preserve">
          <source>When you decode, &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; is inserted for a malformed character, where</source>
          <target state="translated">解码时，会为格式错误的字符插入 &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="3c3e41e00e97aaa41946f9404604a3e16daeabbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8903ce8817b2306a386e9e7bf122e6808d15508e" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b2a9b37643890f116ac0184e9ac142f63cbe26" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3fe5c47178db8be10e4d3c50152806e0a7dfbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="translated">在&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;对象上执行$ parser-&amp;gt; get_token时，您可能会得到此类的对象。</target>
        </trans-unit>
        <trans-unit id="fdee2ab8e3f283c88595afe8fae4920b1af2e43f" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="translated">在&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;上执行$ parser-&amp;gt; get_token时，您可能会得到此类的对象。</target>
        </trans-unit>
        <trans-unit id="e49f09f58c9d01d7e0d1ab18e02275ef3d85f650" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="translated">在&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;上执行$ parser-&amp;gt; get_token时，您应该获得Pod :: Simple :: PullParserToken子类的对象。</target>
        </trans-unit>
        <trans-unit id="e5d10bb84f2ae2965aec52096372e0823e1ccc9f" translate="yes" xml:space="preserve">
          <source>When you do an open() and specify extra PerlIO layers to be deployed, the layers you specify are &quot;pushed&quot; on top of the already existing default stack. One way to see it is that &quot;operating system is on the left&quot; and &quot;Perl is on the right&quot;.</source>
          <target state="translated">当你进行open()并指定额外的PerlIO层进行部署时,你指定的层会被 &quot;推送 &quot;到已有的默认栈之上。有一种说法是 &quot;操作系统在左边&quot;,&quot;Perl在右边&quot;。</target>
        </trans-unit>
        <trans-unit id="deae100a89ba77dc88cb549c116cc2863e7500d7" translate="yes" xml:space="preserve">
          <source>When you do so, make sure you leave at least &lt;b&gt;U0000&lt;/b&gt; to &lt;b&gt;U0020&lt;/b&gt; as is, unless your environment is EBCDIC.</source>
          <target state="translated">这样做时，除非您的环境是EBCDIC，否则请确保至少&lt;b&gt;保留U0000&lt;/b&gt;到&lt;b&gt;U0020&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="5f9d98bf0fca35661c7810840d0018afb1d2ce55" translate="yes" xml:space="preserve">
          <source>When you do this, you replace ordinary Perl ops with custom ops by creating ops with the type &lt;code&gt;OP_CUSTOM&lt;/code&gt; and the &lt;code&gt;op_ppaddr&lt;/code&gt; of your own PP function. This should be defined in XS code, and should look like the PP ops in &lt;code&gt;pp_*.c&lt;/code&gt;. You are responsible for ensuring that your op takes the appropriate number of values from the stack, and you are responsible for adding stack marks if necessary.</source>
          <target state="translated">执行此操作时，可以通过创建类型为您自己的PP函数的 &lt;code&gt;OP_CUSTOM&lt;/code&gt; 和 &lt;code&gt;op_ppaddr&lt;/code&gt; 的操作，用自定义操作替换普通的Perl操作。这应该在XS代码中定义，并且应该看起来像 &lt;code&gt;pp_*.c&lt;/code&gt; 的PP ops 。您有责任确保您的op从堆栈中获取适当数量的值，并且有责任在必要时添加堆栈标记。</target>
        </trans-unit>
        <trans-unit id="f0737e549db78c3f56b6cebadc591bd894132914" translate="yes" xml:space="preserve">
          <source>When you encode, it just encodes UTF-8 string with</source>
          <target state="translated">当你进行编码时,它只是将UTF-8字符串与</target>
        </trans-unit>
        <trans-unit id="2cb93abd34cd25594e79f391f2b423cc436f1f2e" translate="yes" xml:space="preserve">
          <source>When you execute this script, Perl creates a source stream for the file. Before the parser processes any of the lines from the file, the source stream looks like this:</source>
          <target state="translated">当你执行这个脚本时,Perl会为文件创建一个源流。在解析器处理文件中的任何一行之前,源流看起来是这样的。</target>
        </trans-unit>
        <trans-unit id="c978bab6e05df288a1696970dbd630fd132c029f" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;Data::Dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542d61dee2b7e163e5110ea366ba8573d821b115" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="translated">当您厌倦了为数据结构编写自定义打印时，可以查看标准的&lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt;或&lt;a href=&quot;data/dumper&quot;&gt;Data :: Dumper&lt;/a&gt;模块。前者是Perl调试器使用的东西，而后者则生成可分析的Perl代码。例如：</target>
        </trans-unit>
        <trans-unit id="18b18f51c5b3a1ef29698b4db45e17c63b163a2a" translate="yes" xml:space="preserve">
          <source>When you have Module::Build installed and a module comes with both a Makefile.PL and a Build.PL, which shall have precedence?</source>
          <target state="translated">当您安装了 Module::Build,并且一个模块同时带有 Makefile.PL 和 Build.PL 时,哪个应该优先?</target>
        </trans-unit>
        <trans-unit id="90be52d2f2a07a95a09a611578f9d43f7cd9edea" translate="yes" xml:space="preserve">
          <source>When you have Term::ANSIColor installed, you can turn on colorized output to have some visual differences between normal CPAN.pm output, warnings, debugging output, and the output of the modules being installed. Set your favorite colors after some experimenting with the Term::ANSIColor module.</source>
          <target state="translated">当你安装了Term::ANSIColor后,你可以开启彩色化输出,让正常的CPAN.pm输出、警告、调试输出和正在安装的模块输出有一些视觉上的区别。在对Term::ANSIColor模块进行一些实验后,可以设置自己喜欢的颜色。</target>
        </trans-unit>
        <trans-unit id="805d35dab8fe4274cb0dab9ee72a05d301e431cf" translate="yes" xml:space="preserve">
          <source>When you have a &lt;code&gt;$normalized&lt;/code&gt; string and an &lt;code&gt;$unnormalized&lt;/code&gt; string following it, a simple concatenation is wrong:</source>
          <target state="translated">当您有一个 &lt;code&gt;$normalized&lt;/code&gt; 字符串和紧随其后的 &lt;code&gt;$unnormalized&lt;/code&gt; 字符串时，简单的串联是错误的：</target>
        </trans-unit>
        <trans-unit id="5fc33624ab4cb034a50a1d77e4381e870301d931" translate="yes" xml:space="preserve">
          <source>When you have a duplicate entry, mark either one with '|1' or '|3'.</source>
          <target state="translated">当您有重复的条目时,用&quot;|1 &quot;或&quot;|3 &quot;标记其中一个。</target>
        </trans-unit>
        <trans-unit id="c0776eaeac3f4218a7b8598aad81420ef0246911" translate="yes" xml:space="preserve">
          <source>When you list the arguments to the XSUB in the .xs file, that tells &lt;b&gt;xsubpp&lt;/b&gt; which argument corresponds to which of the argument stack (i.e., the first one listed is the first argument, and so on). You invite disaster if you do not list them in the same order as the function expects them.</source>
          <target state="translated">当您在.xs文件中列出XSUB的参数时，将告诉&lt;b&gt;xsubpp&lt;/b&gt;哪个参数对应于哪个参数堆栈（即，列出的第一个参数是第一个参数，依此类推）。如果您未按函数预期的顺序列出灾难，则会引发灾难。</target>
        </trans-unit>
        <trans-unit id="4fe7c5d2090255d1c2f0cf1a507f4b889f93bbfd" translate="yes" xml:space="preserve">
          <source>When you make a script executable, in order to make it usable as a command, the system will pass switches to perl from the script's #! line. Perl checks that any command line switches given to a setuid (or setgid) script actually match the ones set on the #! line. Some Unix and Unix-like environments impose a one-switch limit on the #! line, so you may need to use something like &lt;code&gt;-wU&lt;/code&gt; instead of &lt;code&gt;-w -U&lt;/code&gt; under such systems. (This issue should arise only in Unix or Unix-like environments that support #! and setuid or setgid scripts.)</source>
          <target state="translated">当使脚本可执行时，为了使其可用作命令，系统将从脚本的＃！将开关传递给perl！线。 Perl检查提供给setuid（或setgid）脚本的任何命令行开关是否确实与＃！上设置的那些匹配！线。某些Unix和类似Unix的环境对＃！施加一键限制。行，因此在这种系统下，可能需要使用 &lt;code&gt;-wU&lt;/code&gt; 之类的东西，而不是 &lt;code&gt;-w -U&lt;/code&gt; 之类的东西。 （仅在支持＃！以及setuid或setgid脚本的Unix或类似Unix的环境中才会出现此问题。）</target>
        </trans-unit>
        <trans-unit id="66b392aea5e0dde426270cd749894810ea22ea80" translate="yes" xml:space="preserve">
          <source>When you obtain a context object it is made specifically for your tool and any tools nested within. If you pass a context around you run the risk of polluting other tools with incorrect context information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95cff40ad5c3e10b014358530a3857e4311a17f" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;).</source>
          <target state="translated">覆盖内置时，替换项应与内置本机语法保持一致（如果可能）。您可以通过使用合适的原型来实现。要获取可覆盖的内置 &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; ，请使用带有参数 &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; 的prototype函数（请参见&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="403deb8cf132584282b80991028fcc8f4fae8ae6" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;prototype&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;perlfunc#prototype&quot;&gt;&quot;prototype&quot; in perlfunc&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde2c695557d23e73e52834a17ed471dd59562aa" translate="yes" xml:space="preserve">
          <source>When you replace this variable, it is considered a good practice to store the possibly previously installed hook and that you recall it inside your own.</source>
          <target state="translated">当你更换这个变量时,它被认为是一个很好的做法,存储可能以前安装的钩子,你在你自己的内部调用它。</target>
        </trans-unit>
        <trans-unit id="582bd31e20cc087ebfe2ecd8d499eadfcfa005d7" translate="yes" xml:space="preserve">
          <source>When you run Makefile.PL, it makes a Makefile. That's the whole point of MakeMaker. The Makefile.PL is a simple program which loads ExtUtils::MakeMaker and runs the WriteMakefile() function to generate a Makefile.</source>
          <target state="translated">当你运行Makefile.PL时,它就会生成一个Makefile。这就是MakeMaker的全部意义。Makefile.PL是一个简单的程序,它加载ExtUtils::MakeMaker,并运行WriteMakefile()函数来生成一个Makefile。</target>
        </trans-unit>
        <trans-unit id="b579e440e9d1d7b9d0889bfe36abfaf0be29b72d" translate="yes" xml:space="preserve">
          <source>When you run a Perl script, something else is running the script for you, and that something else may output error messages. The script might emit its own warnings and error messages. Most of the time you cannot tell who said what.</source>
          <target state="translated">当你运行一个Perl脚本时,有其他东西在为你运行这个脚本,而这个其他东西可能会输出错误信息。脚本可能会发出自己的警告和错误信息。大多数时候,你无法判断谁说了什么。</target>
        </trans-unit>
        <trans-unit id="b459c97000689bfb2a9636d9e9707ca71827210e" translate="yes" xml:space="preserve">
          <source>When you run this program, you should get something back that looks like this:</source>
          <target state="translated">当你运行这个程序时,你应该得到类似这样的东西。</target>
        </trans-unit>
        <trans-unit id="a4188abf09b28b37cfb9f20a3ac1868d9c6a543c" translate="yes" xml:space="preserve">
          <source>When you say &quot;make test&quot;, Perl uses the</source>
          <target state="translated">当你说 &quot;make test &quot;时,Perl使用的是</target>
        </trans-unit>
        <trans-unit id="76a6e68fd11c4b70b5a87d525381faf69633be4b" translate="yes" xml:space="preserve">
          <source>When you say &lt;code&gt;make test&lt;/code&gt; it will run with taint mode on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7919c60f354343e7a5369000b965c8d2d0632381" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt; . Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="translated">当您在邮件和网页上看到 &lt;code&gt;charset=gb2312&lt;/code&gt; 时，它们实际上是 &lt;code&gt;euc-cn&lt;/code&gt; 编码。为了解决这个问题， &lt;code&gt;gb2312&lt;/code&gt; 被别名为 &lt;code&gt;euc-cn&lt;/code&gt; 。真正使用时，请使用 &lt;code&gt;gb2312-raw&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c4e1c3fce7decd6f02607f653534397608ae09a" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt;. Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17139aebb0fce79faa8dece070270ecb6b39cc8b" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; on mails and web pages, they really mean &quot;cp949&quot; encodings. To fix that, the following aliases are set;</source>
          <target state="translated">当您在邮件和网页上看到 &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; 时，它们实际上是&amp;ldquo; cp949&amp;rdquo;编码。为了解决这个问题，设置了以下别名；</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
