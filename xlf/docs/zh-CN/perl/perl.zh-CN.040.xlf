<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="bda6d4349e03cdc3822accb764cf2332f0d166cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct()&lt;/code&gt; function</source>
          <target state="translated">的 &lt;code&gt;struct()&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="7a95e760c73406947e7da7714b03782e42d5fa06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct&lt;/code&gt; function has three forms of parameter-list.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 的功能有三种形式参数列表中。</target>
        </trans-unit>
        <trans-unit id="ca2248434d315d7f4555ab09ed558fffeb25af18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv&lt;/code&gt; argument is a pointer to the SV that is to acquire a new magical feature.</source>
          <target state="translated">该 &lt;code&gt;sv&lt;/code&gt; 参数是一个指向是获取一个新的神奇功能的SV。</target>
        </trans-unit>
        <trans-unit id="9d1732cdeea04b3b5302655756ff012b4b97e760" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv&lt;/code&gt; argument must be a reference value. The &lt;code&gt;stash&lt;/code&gt; argument specifies which class the reference will belong to. See &lt;a href=&quot;#Stashes-and-Globs&quot;&gt;Stashes and Globs&lt;/a&gt; for information on converting class names into stashes.</source>
          <target state="translated">的 &lt;code&gt;sv&lt;/code&gt; 参数必须是一个参考值。该 &lt;code&gt;stash&lt;/code&gt; 参数指定哪一个类的引用将属于。有关将类名转换为存储的信息，请参见&lt;a href=&quot;#Stashes-and-Globs&quot;&gt;存储和全局&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5aa9fb7196f50b878b4d2185150e32ef86a1a0ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_cat*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; later in this document.</source>
          <target state="translated">该 &lt;code&gt;sv_cat*()&lt;/code&gt; 函数不是通用的，足以对具有&amp;ldquo;魔力&amp;rdquo;的值进行操作。请参阅本文档后面的&lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="451bffe03c920b337c26d3f6c5c7b3d0a90a952c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_set*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; later in this document.</source>
          <target state="translated">该 &lt;code&gt;sv_set*()&lt;/code&gt; 函数不是通用的，足以对具有&amp;ldquo;魔力&amp;rdquo;的值进行操作。请参阅本文档后面的&lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="264e3c8ac2fdd944cc02ae92713944fc8cf6494f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;taint&lt;/code&gt; pragma causes any substrings from a match with a tainted variable to be tainted as well. This is not normally the case, as regexps are often used to extract the safe bits from a tainted variable. Use &lt;code&gt;taint&lt;/code&gt; when you are not extracting safe bits, but are performing some other processing. Both &lt;code&gt;taint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; pragmas are lexically scoped, which means they are in effect only until the end of the block enclosing the pragmas.</source>
          <target state="translated">的 &lt;code&gt;taint&lt;/code&gt; 编译会导致从与被感染的可变匹配任何子被污染，以及。通常情况并非如此，因为经常使用正则表达式从受污染的变量中提取安全位。当您不提取安全位而是执行其他处理时，请使用 &lt;code&gt;taint&lt;/code&gt; 。两个 &lt;code&gt;taint&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; pragma可词法作用域的，这意味着它们在效果仅直到包围编译指示所述块的端部。</target>
        </trans-unit>
        <trans-unit id="0e22b53957ab545ec5f1fe43f2463dbb75fb5bef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test_diag&lt;/code&gt; function prepends comment hashes and spacing to the start and newlines to the end of the expected output passed to it and adds it to the list of expected error output. So, instead of writing</source>
          <target state="translated">该 &lt;code&gt;test_diag&lt;/code&gt; 功能前添加评论散列和间隔的开始和新行的预期产出传递给它的结束，并将其添加到预期的错误输出的列表。所以，而不是写</target>
        </trans-unit>
        <trans-unit id="9a044497bbeccf899d123e744ac60158148d66b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thing&lt;/code&gt; argument can be any of an &lt;code&gt;SV*&lt;/code&gt; , &lt;code&gt;AV*&lt;/code&gt; , or &lt;code&gt;HV*&lt;/code&gt; . The functions are identical except that &lt;code&gt;newRV_inc&lt;/code&gt; increments the reference count of the &lt;code&gt;thing&lt;/code&gt; , while &lt;code&gt;newRV_noinc&lt;/code&gt; does not. For historical reasons, &lt;code&gt;newRV&lt;/code&gt; is a synonym for &lt;code&gt;newRV_inc&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;thing&lt;/code&gt; 参数可以是任何一个的 &lt;code&gt;SV*&lt;/code&gt; ， &lt;code&gt;AV*&lt;/code&gt; 或者 &lt;code&gt;HV*&lt;/code&gt; 。这些函数是相同的，除了 &lt;code&gt;newRV_inc&lt;/code&gt; 增加 &lt;code&gt;thing&lt;/code&gt; 的引用计数，而 &lt;code&gt;newRV_noinc&lt;/code&gt; 不增加。由于历史原因， &lt;code&gt;newRV&lt;/code&gt; 是一个代名词 &lt;code&gt;newRV_inc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="764690cb5a9a1e69711deb7f1d4bd7570cd33533" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;threads-&amp;gt;self()&lt;/code&gt; class method provides your program with a way to get an object representing the thread it's currently in. You can use this object in the same way as the ones returned from thread creation.</source>
          <target state="translated">该 &lt;code&gt;threads-&amp;gt;self()&lt;/code&gt; 类方法提供了一种方式来获得代表它目前在线程对象的程序，你可以以同样的方式从创建线程返回的人使用这个对象。</target>
        </trans-unit>
        <trans-unit id="5cb77a0f1c56daabcc9daa1cb20e1afceca163c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tid&lt;/code&gt; method returns the tid of a thread. The tid is a monotonically increasing integer assigned when a thread is created. The main thread of a program will have a tid of zero, while subsequent threads will have tids assigned starting with one.</source>
          <target state="translated">该 &lt;code&gt;tid&lt;/code&gt; 方法返回一个线程的TID。tid是创建线程时分配的单调递增整数。程序的主线程的tid为零，而后续线程的tid则从1开始分配。</target>
        </trans-unit>
        <trans-unit id="62cae6d3e02f73d7641c7861d0693bc4b08d5c81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; functions perform range checking on the input $sec, $min, $hour, $mday, and $mon values by default.</source>
          <target state="translated">所述 &lt;code&gt;timelocal()&lt;/code&gt; 和 &lt;code&gt;timegm()&lt;/code&gt; 函数的输入$秒，$分钟，$小时，$ MDAY和$周一个值默认执行范围检查。</target>
        </trans-unit>
        <trans-unit id="3444ad2f99e605827ac849ba41549cb93537c5ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timelocal()&lt;/code&gt; function is implemented using the same cache. We just assume that we're translating a GMT time, and then fudge it when we're done for the timezone and daylight savings arguments. Note that the timezone is evaluated for each date because countries occasionally change their official timezones. Assuming that &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; corrects for these changes, this routine will also be correct.</source>
          <target state="translated">该 &lt;code&gt;timelocal()&lt;/code&gt; 函数使用相同的高速缓存来实现。我们只是假设我们正在翻译GMT时间，然后在完成时区和夏令时参数时将其弄乱了。请注意，每个国家都会评估时区，因为国家有时会更改其官方时区。假设 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 可以纠正这些更改，则此例程也将是正确的。</target>
        </trans-unit>
        <trans-unit id="7969d03acba8ec22322bc524970a2e67bf531eeb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument should be equal to the &lt;code&gt;how&lt;/code&gt; value when the &lt;code&gt;SV&lt;/code&gt; was initially made magical.</source>
          <target state="translated">该 &lt;code&gt;type&lt;/code&gt; 参数应该是等于 &lt;code&gt;how&lt;/code&gt; 当值 &lt;code&gt;SV&lt;/code&gt; 最初是由神奇。</target>
        </trans-unit>
        <trans-unit id="e605c3e8404b3b1569b2a8f6ee2a28bb09c8e25f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u&lt;/code&gt; template to &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; will render EBCDIC data in EBCDIC characters equivalent to their ASCII counterparts. For example, the following will print &quot;Yes indeed\n&quot; on either an ASCII or EBCDIC computer:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;u&lt;/code&gt; 模板将以EBCDIC字符（与ASCII对等物相同）呈现EBCDIC数据。例如，以下代码将在ASCII或EBCDIC计算机上打印&amp;ldquo; Yes确实\ n&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="6a1909f52d28496be25968c9641232bd70a050cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;up&lt;/code&gt; method increases the semaphore's count by the number specified (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">该 &lt;code&gt;up&lt;/code&gt; 方法由指定的数量，如果没有指定数目（它必须是整数&amp;gt; = 1），或由一个增加信号量的计数。</target>
        </trans-unit>
        <trans-unit id="3bfafbe930277e35ea02604239f7cd015c3326fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade&lt;/code&gt; command first runs an &lt;code&gt;r&lt;/code&gt; command with the given arguments and then installs the newest versions of all modules that were listed by that.</source>
          <target state="translated">该 &lt;code&gt;upgrade&lt;/code&gt; 命令首次运行 &lt;code&gt;r&lt;/code&gt; 与给定的参数命令，然后安装由上市的所有模块的最新版本。</target>
        </trans-unit>
        <trans-unit id="ed2a8ecd68dda5352fc1303d01e5cd582863eba1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;urllist&lt;/code&gt; parameter of the configuration table contains a list of URLs used for downloading. If the list contains any &lt;code&gt;file&lt;/code&gt; URLs, CPAN always tries there first. This feature is disabled for index files. So the recommendation for the owner of a CD-ROM with CPAN contents is: include your local, possibly outdated CD-ROM as a &lt;code&gt;file&lt;/code&gt; URL at the end of urllist, e.g.</source>
          <target state="translated">配置表的 &lt;code&gt;urllist&lt;/code&gt; 参数包含用于下载的URL列表。如果列表中包含任何 &lt;code&gt;file&lt;/code&gt; URL，则CPAN总是首先尝试在那里。索引文件禁用此功能。因此，对于具有CPAN内容的CD-ROM的所有者的建议是：在urllist的末尾包含本地的，可能已过时的CD-ROM作为 &lt;code&gt;file&lt;/code&gt; URL，例如</target>
        </trans-unit>
        <trans-unit id="468aa2690cfac4f39947fa49f9490387f38518f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; and &lt;code&gt;utf8::upgrade()&lt;/code&gt; aren't needed if the argument is above 0xFF, so the above could have been written as</source>
          <target state="translated">该 &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; 和 &lt;code&gt;utf8::upgrade()&lt;/code&gt; 是不需要的，如果参数高于0xFF的，所以上面的程序可以写为</target>
        </trans-unit>
        <trans-unit id="0a270d12703e96872d5ec49cc2bfa5c1ab0eb455" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vars&lt;/code&gt; pragma (see &lt;a href=&quot;perlmod#vars&quot;&gt;vars in perlmod&lt;/a&gt;) may be used in such situations as an alternative to explicitly qualifying all globals with the package namespace. Variables pre-declared with this pragma will be visible to any autoloaded routines (but will not be invisible outside the package, unfortunately).</source>
          <target state="translated">的 &lt;code&gt;vars&lt;/code&gt; 编译指示（见&lt;a href=&quot;perlmod#vars&quot;&gt;瓦尔在perlmod的&lt;/a&gt;）可以在这种情况下被使用来替代明确资格所有全局与包命名空间。使用此编译指示预先声明的变量将对任何自动加载的例程可见（但不幸的是，在程序包外部将不可见）。</target>
        </trans-unit>
        <trans-unit id="8a981f510b5bc1a31c1fe6f83ee184b884a41beb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;verbose&lt;/code&gt; and &lt;code&gt;inc&lt;/code&gt; attributes influence the behavior of this search; notably, &lt;code&gt;inc&lt;/code&gt; , if true, adds @INC</source>
          <target state="translated">在 &lt;code&gt;verbose&lt;/code&gt; 和 &lt;code&gt;inc&lt;/code&gt; 属性影响该搜索的行为; 值得注意的是， &lt;code&gt;inc&lt;/code&gt; ，如果为true，则添加@INC</target>
        </trans-unit>
        <trans-unit id="42e9db15fd405837558fc69a3922cf4c07b0d66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; return type for this function tells the &lt;b&gt;xsubpp&lt;/b&gt; compiler that the RETVAL variable is not needed or used and that it should not be created. In most scenarios the void return type should be used with the PPCODE: directive.</source>
          <target state="translated">此函数的 &lt;code&gt;void&lt;/code&gt; 返回类型告诉&lt;b&gt;xsubpp&lt;/b&gt;编译器不需要或不使用RETVAL变量，并且不应创建该变量。在大多数情况下，void返回类型应与PPCODE：指令一起使用。</target>
        </trans-unit>
        <trans-unit id="0803129a0bffe56a31c42b951ef5b3d0fb1885a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wanted()&lt;/code&gt; function does whatever verifications you want on each file and directory. Note that despite its name, the &lt;code&gt;wanted()&lt;/code&gt; function is a generic callback function, and does &lt;b&gt;not&lt;/b&gt; tell File::Find if a file is &quot;wanted&quot; or not. In fact, its return value is ignored.</source>
          <target state="translated">本 &lt;code&gt;wanted()&lt;/code&gt; 函数，你想要做的每个文件和目录的任何核查。需要注意的是，尽管它的名字，在 &lt;code&gt;wanted()&lt;/code&gt; 函数是一个通用的回调函数，并&lt;b&gt;没有&lt;/b&gt;告诉文件::查找一个文件是&amp;ldquo;通缉令&amp;rdquo;与否。实际上，它的返回值被忽略。</target>
        </trans-unit>
        <trans-unit id="31b1fe49028e0123810b9a17034fff70bf1be6cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warnings&lt;/code&gt; pragma gives control over which warnings are enabled in which parts of a Perl program. It's a more flexible alternative for both the command line flag &lt;b&gt;-w&lt;/b&gt; and the equivalent Perl variable, &lt;code&gt;$^W&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;warnings&lt;/code&gt; 编译给出了该警告的Perl程序的这部分功能的控制。对于命令行标志&lt;b&gt;-w&lt;/b&gt;和等效的Perl变量 &lt;code&gt;$^W&lt;/code&gt; ，这是一种更加灵活的替代方法。</target>
        </trans-unit>
        <trans-unit id="4d599e8a7252be8237239500a33b9cae49be5da2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warnings&lt;/code&gt; pragma provides a number of functions that are useful for module authors. These are used when you want to report a module-specific warning to a calling module has enabled warnings via the &lt;code&gt;warnings&lt;/code&gt; pragma.</source>
          <target state="translated">该 &lt;code&gt;warnings&lt;/code&gt; 编译提供的一定数量的是模块的作者有用的功能。当您要向警告模块报告特定于模块的警告时，可以使用这些 &lt;code&gt;warnings&lt;/code&gt; 。警告模块已通过警告编译指示启用了警告。</target>
        </trans-unit>
        <trans-unit id="eaaf2c2b19accccb92902e0f89453388a8136ad7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; modifier is an experimental feature that first appeared in Perl 5.14. To use it, you should include a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.14&lt;/code&gt; declaration. (Technically, it requires only the &lt;code&gt;switch&lt;/code&gt; feature, but that aspect of it was not available before 5.14.) Operative only from within a &lt;code&gt;foreach&lt;/code&gt; loop or a &lt;code&gt;given&lt;/code&gt; block, it executes the statement only if the smartmatch &lt;code&gt;$_ ~~ &lt;i&gt;EXPR&lt;/i&gt;&lt;/code&gt; is true. If the statement executes, it is followed by a &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; from inside a &lt;code&gt;foreach&lt;/code&gt; and &lt;code&gt;break&lt;/code&gt; from inside a &lt;code&gt;given&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;when&lt;/code&gt; 改性剂是一种实验性的功能最早出现在Perl 5.14。要使用它，您应该包括一个 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.14&lt;/code&gt; 声明。 （从技术上讲，它仅需要 &lt;code&gt;switch&lt;/code&gt; 功能，但该方面在5.14之前不可用。）仅在 &lt;code&gt;foreach&lt;/code&gt; 循环或 &lt;code&gt;given&lt;/code&gt; 块内可操作，它仅在smartmatch &lt;code&gt;$_ ~~ &lt;i&gt;EXPR&lt;/i&gt;&lt;/code&gt; 为true 时才执行该语句。如果执行该语句，则从 &lt;code&gt;foreach&lt;/code&gt; 内部执行 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 语句，并从 &lt;code&gt;given&lt;/code&gt; 内部 &lt;code&gt;break&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e19be3044d8f18bead09bab3403090b34e1156d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;until&lt;/code&gt; modifiers have the usual &quot;&lt;code&gt;while&lt;/code&gt; loop&quot; semantics (conditional evaluated first), except when applied to a &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;-BLOCK (or to the Perl4 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;-SUBROUTINE statement), in which case the block executes once before the conditional is evaluated.</source>
          <target state="translated">的 &lt;code&gt;while&lt;/code&gt; 和 &lt;code&gt;until&lt;/code&gt; 改性剂具有通常的&amp;ldquo; &lt;code&gt;while&lt;/code&gt; 循环&amp;rdquo;语义（有条件的第一计算的），当施加至除了 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; （或到Perl4样式-嵌段 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; -SUBROUTINE语句），在这种情况下，块执行一次前的条件被评估。</target>
        </trans-unit>
        <trans-unit id="3d5b06f931731acb22dad061fcd52f2783c874b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement executes the block as long as the expression is &lt;a href=&quot;#Truth-and-Falsehood&quot;&gt;true&lt;/a&gt;. The &lt;code&gt;until&lt;/code&gt; statement executes the block as long as the expression is false. The LABEL is optional, and if present, consists of an identifier followed by a colon. The LABEL identifies the loop for the loop control statements &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;. If the LABEL is omitted, the loop control statement refers to the innermost enclosing loop. This may include dynamically looking back your call-stack at run time to find the LABEL. Such desperate behavior triggers a warning if you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; flag.</source>
          <target state="translated">只要表达式为&lt;a href=&quot;#Truth-and-Falsehood&quot;&gt;true&lt;/a&gt;， &lt;code&gt;while&lt;/code&gt; 语句就会执行该块。只要表达式为假， &lt;code&gt;until&lt;/code&gt; 语句将执行该块。 LABEL是可选的，并且如果存在，则由标识符和冒号组成。 LABEL为 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 的循环控制语句标识循环。如果省略了LABEL，则循环控制语句引用最内层的循环。这可能包括在运行时动态回顾您的调用堆栈以找到LABEL。如果使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; warnings编译指示或&lt;b&gt;-w&lt;/b&gt;标志，则这种绝望的行为将触发警告。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="42f557fbb89c75fd2ab740d93d25721ccbf0fda2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; function allows another thread to take control of the CPU. The exact results are implementation-dependent.</source>
          <target state="translated">的 &lt;code&gt;yield&lt;/code&gt; 函数允许另一个线程来采取CPU的控制。确切的结果取决于实现。</target>
        </trans-unit>
        <trans-unit id="246e63b2eb0074027eaf6b6fe6bf0995cbbb987b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;//&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operators return the last value evaluated (unlike C's &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, which return 0 or 1). Thus, a reasonably portable way to find out the home directory might be:</source>
          <target state="translated">该 &lt;code&gt;||&lt;/code&gt; ， &lt;code&gt;//&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 运算符返回最后计算的值（不同于C的 &lt;code&gt;||&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ，它们返回0或1）。因此，找出主目录的合理移植方式可能是：</target>
        </trans-unit>
        <trans-unit id="11f57b3d94eabb5c19fb9360ab6afe8316dfa0a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~~&lt;/code&gt; operator compares its operands &quot;polymorphically&quot;, determining how to compare them according to their actual types (numeric, string, array, hash, etc.) Like the equality operators with which it shares the same precedence, &lt;code&gt;~~&lt;/code&gt; returns 1 for true and &lt;code&gt;&quot;&quot;&lt;/code&gt; for false. It is often best read aloud as &quot;in&quot;, &quot;inside of&quot;, or &quot;is contained in&quot;, because the left operand is often looked for</source>
          <target state="translated">的 &lt;code&gt;~~&lt;/code&gt; 操作其操作数&amp;ldquo;多晶型&amp;rdquo;进行比较，确定如何根据他们的实际类型（数值，字符串数组，散列等）喜欢用它共享相同的优先级相等的运营商，他们比较 &lt;code&gt;~~&lt;/code&gt; 返回1为正确， &lt;code&gt;&quot;&quot;&lt;/code&gt; 代表错误。通常最好将其大声读为&amp;ldquo;在...中&amp;rdquo;，&amp;ldquo;在...中&amp;rdquo;或&amp;ldquo;包含在其中&amp;rdquo;，因为通常会寻找左操作数</target>
        </trans-unit>
        <trans-unit id="ef321bd7088ac81817f2231db61c1174692aaac0" translate="yes" xml:space="preserve">
          <source>The ADLER32 checksum field must be present.</source>
          <target state="translated">ADLER32校验字段必须存在。</target>
        </trans-unit>
        <trans-unit id="9c4519701849f27da68be727b95e63207f2a9abf" translate="yes" xml:space="preserve">
          <source>The AIX tar does not fill all unused space in the tar archive with 0x00. This sometimes leads to warning messages from &lt;code&gt;Archive::Tar&lt;/code&gt; .</source>
          <target state="translated">AIX tar不会用0x00填充tar归档中所有未使用的空间。有时这会导致来自 &lt;code&gt;Archive::Tar&lt;/code&gt; 警告消息。</target>
        </trans-unit>
        <trans-unit id="b5549afa573e8454744ea43299cd8d8505147fcd" translate="yes" xml:space="preserve">
          <source>The ALIAS: Keyword</source>
          <target state="translated">ALIAS:关键字</target>
        </trans-unit>
        <trans-unit id="2ce9242faeeab07eef2f7afd701bea6933de8059" translate="yes" xml:space="preserve">
          <source>The ALIAS: keyword allows an XSUB to have two or more unique Perl names and to know which of those names was used when it was invoked. The Perl names may be fully-qualified with package names. Each alias is given an index. The compiler will setup a variable called &lt;code&gt;ix&lt;/code&gt; which contain the index of the alias which was used. When the XSUB is called with its declared name &lt;code&gt;ix&lt;/code&gt; will be 0.</source>
          <target state="translated">ALIAS：关键字允许XSUB具有两个或多个唯一的Perl名称，并知道在调用它时使用了哪个名称。Perl名称可以使用包名称来完全限定。每个别名都有一个索引。编译器将设置一个名为 &lt;code&gt;ix&lt;/code&gt; 的变量，其中包含使用的别名的索引。当使用其声明的名称调用XSUB时， &lt;code&gt;ix&lt;/code&gt; 将为0。</target>
        </trans-unit>
        <trans-unit id="15fd0430aabb02304def7c36146cf671599d3942" translate="yes" xml:space="preserve">
          <source>The API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="9ed04c99d7b2c6a9ba47b9e4b73c73bb3ccc347c" translate="yes" xml:space="preserve">
          <source>The API was changed in the 2.0 branch. For a time, &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; tried, unsuccessfully, to deal with the two different calling mechanisms. This approach was considered a failure.</source>
          <target state="translated">该API已在2.0分支中更改。一段时间以来， &lt;code&gt;mkpath&lt;/code&gt; 和 &lt;code&gt;rmtree&lt;/code&gt; 尝试处理两种不同的调用机制均未成功。这种方法被认为是失败的。</target>
        </trans-unit>
        <trans-unit id="009ead0f6ffd2c056d27d3bfda98818a54d2faea" translate="yes" xml:space="preserve">
          <source>The ASCII region (0x00-0x7f) is preserved for all encodings, even though this conflicts with mappings by the Unicode Consortium.</source>
          <target state="translated">ASCII区域(0x00-0x7f)在所有编码中都被保留,尽管这与Unicode联盟的映射有冲突。</target>
        </trans-unit>
        <trans-unit id="b3c4e287eeab5aae5482e7df8b6e409cada7c372" translate="yes" xml:space="preserve">
          <source>The ASCII/Latin-1/Unicode character with that number. A leading &quot;0x&quot; means that</source>
          <target state="translated">带有该数字的ASCII/拉丁语1/Unicode字符。前面的 &quot;0x &quot;表示</target>
        </trans-unit>
        <trans-unit id="e2afefe4f37ea14f731718bb07a4d6306f1639c5" translate="yes" xml:space="preserve">
          <source>The AUTOLOAD method, discussed in &lt;a href=&quot;perlsub#Autoloading&quot;&gt;Autoloading in perlsub&lt;/a&gt; lets you capture calls to undefined functions and methods.</source>
          <target state="translated">&lt;a href=&quot;perlsub#Autoloading&quot;&gt;在perlsub的自动加载中&lt;/a&gt;讨论的AUTOLOAD方法使您可以捕获对未定义函数和方法的调用。</target>
        </trans-unit>
        <trans-unit id="31231455a0cef5b5794db63f07a47d2f6efab12c" translate="yes" xml:space="preserve">
          <source>The ActiveState Pages, &lt;a href=&quot;http://www.activestate.com/&quot;&gt;http://www.activestate.com/&lt;/a&gt;</source>
          <target state="translated">ActiveState页面，&lt;a href=&quot;http://www.activestate.com/&quot;&gt;http&lt;/a&gt;：//www.activestate.com/</target>
        </trans-unit>
        <trans-unit id="fbbc6fc0e5dd1ef33879bfc672f5e3e8813e4f97" translate="yes" xml:space="preserve">
          <source>The Adventures of Tom Bombadil</source>
          <target state="translated">汤姆-本巴迪尔历险记</target>
        </trans-unit>
        <trans-unit id="e2e0a5aea5199e87efc4db9939033262cf1e73b8" translate="yes" xml:space="preserve">
          <source>The Alignment Pit</source>
          <target state="translated">校准坑</target>
        </trans-unit>
        <trans-unit id="68a751b9c456def01d238b0c06471f4927931bb2" translate="yes" xml:space="preserve">
          <source>The American Standard Code for Information Interchange (ASCII or US-ASCII) is a set of integers running from 0 to 127 (decimal) that have standardized interpretations by the computers which use ASCII. For example, 65 means the letter &quot;A&quot;. The range 0..127 can be covered by setting the bits in a 7-bit binary digit, hence the set is sometimes referred to as &quot;7-bit ASCII&quot;. ASCII was described by the American National Standards Institute document ANSI X3.4-1986. It was also described by ISO 646:1991 (with localization for currency symbols). The full ASCII set is given in the table &lt;a href=&quot;#recipe-3&quot;&gt;below&lt;/a&gt; as the first 128 elements. Languages that can be written adequately with the characters in ASCII include English, Hawaiian, Indonesian, Swahili and some Native American languages.</source>
          <target state="translated">美国信息交换标准代码（ASCII或US-ASCII）是一组从0到127（十进制）的整数，这些整数由使用ASCII的计算机进行了标准化的解释。例如，65表示字母&amp;ldquo; A&amp;rdquo;。可以通过将位设置为7位二进制数字来覆盖范围0..127，因此该设置有时称为&amp;ldquo; 7位ASCII&amp;rdquo;。 ASCII由美国国家标准协会文件ANSI X3.4-1986描述。 ISO 646：1991也对此进行了描述（货币符号的本地化）。完整的ASCII集&lt;a href=&quot;#recipe-3&quot;&gt;在下&lt;/a&gt;表中作为前128个元素给出。可以使用ASCII字符充分书写的语言包括英语，夏威夷语，印度尼西亚语，斯瓦希里语和某些美洲原住民语言。</target>
        </trans-unit>
        <trans-unit id="f3ff218a8809c68d0eb083f2cf66b8207142d4f0" translate="yes" xml:space="preserve">
          <source>The American Standard Code for Information Interchange (a 7-bit character set adequate only for poorly representing English text). Often used loosely to describe the lowest 128 values of the various ISO-8859-X character sets, a bunch of mutually incompatible 8-bit codes best described as half ASCII. See also &lt;b&gt;Unicode&lt;/b&gt;.</source>
          <target state="translated">美国信息交换标准代码（一个7位字符集，仅适用于表示较差的英文文本）。通常宽松地描述各种ISO-8859-X字符集的最低128个值，一堆相互不兼容的8位代码最好用半个ASCII描述。另请参见&lt;b&gt;Unicode&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="fd1c7da39d90054f5c4c81dc1a1fa13bcbbe82e7" translate="yes" xml:space="preserve">
          <source>The Anatomy of an XSUB</source>
          <target state="translated">XSUB的解剖</target>
        </trans-unit>
        <trans-unit id="0746d95bfde5c5ba18bf27b5d1463ad01ffdafa1" translate="yes" xml:space="preserve">
          <source>The Argument Stack</source>
          <target state="translated">争论堆栈</target>
        </trans-unit>
        <trans-unit id="59f8369b68ee932dd97b5ec57202b3f3969c4a83" translate="yes" xml:space="preserve">
          <source>The Arrow Operator</source>
          <target state="translated">箭头操作员</target>
        </trans-unit>
        <trans-unit id="e40e5d487b331e1f7f4c2477322a84662ea1dcde" translate="yes" xml:space="preserve">
          <source>The Art of Computer Programming</source>
          <target state="translated">计算机编程的艺术</target>
        </trans-unit>
        <trans-unit id="e6a71a9e8ae70e8f61fd0c5d80d8189dbf3cf681" translate="yes" xml:space="preserve">
          <source>The AutoSplit and &lt;b&gt;AutoLoader&lt;/b&gt; modules automate the creation of forward declarations. The AutoSplit module creates an 'index' file containing forward declarations of all the AutoSplit subroutines. When the AutoLoader module is 'use'd it loads these declarations into its callers package.</source>
          <target state="translated">AutoSplit和&lt;b&gt;AutoLoader&lt;/b&gt;模块可自动创建前向声明。AutoSplit模块创建一个&amp;ldquo;索引&amp;rdquo;文件，其中包含所有AutoSplit子例程的前向声明。当&amp;ldquo;使用&amp;rdquo; AutoLoader模块时，它将这些声明加载到其调用程序包中。</target>
        </trans-unit>
        <trans-unit id="547ca45f60093a7fb15745aaa1976d8399cc0918" translate="yes" xml:space="preserve">
          <source>The B-determined class of the OP, in all caps.</source>
          <target state="translated">上文中的B定类,大写的。</target>
        </trans-unit>
        <trans-unit id="fad9fed447a0e7963d894765232a4acc4b663de9" translate="yes" xml:space="preserve">
          <source>The B::Xref module is used to generate a cross reference listing of all definitions and uses of variables, subroutines and formats in a Perl program. It is implemented as a backend for the Perl compiler.</source>
          <target state="translated">B::Xref 模块用于生成一个交叉引用列表,列出 Perl 程序中所有变量、子程序和格式的定义和用法。它是作为Perl编译器的后端实现的。</target>
        </trans-unit>
        <trans-unit id="8026a52e63f99adbefc0e084618e1f479fd95572" translate="yes" xml:space="preserve">
          <source>The BITS mode (&quot;0&quot;) interprets the contents of</source>
          <target state="translated">BITS模式(&quot;0&quot;)解释了以下内容</target>
        </trans-unit>
        <trans-unit id="ba88dd1d9005852348725927325ddcf383a69f7c" translate="yes" xml:space="preserve">
          <source>The BLOCK construct can be used to emulate case structures.</source>
          <target state="translated">BLOCK结构可以用来模拟案例结构。</target>
        </trans-unit>
        <trans-unit id="6dfef44d3b22aafe27912b6966e2a486d9c0c14d" translate="yes" xml:space="preserve">
          <source>The BOOT: Keyword</source>
          <target state="translated">的BOOT。关键字</target>
        </trans-unit>
        <trans-unit id="d4a87a13d39a77a50a617134650c09dd8bdc8e3b" translate="yes" xml:space="preserve">
          <source>The BOOT: keyword is used to add code to the extension's bootstrap function. The bootstrap function is generated by the &lt;b&gt;xsubpp&lt;/b&gt; compiler and normally holds the statements necessary to register any XSUBs with Perl. With the BOOT: keyword the programmer can tell the compiler to add extra statements to the bootstrap function.</source>
          <target state="translated">BOOT：关键字用于将代码添加到扩展的引导功能。引导程序功能由&lt;b&gt;xsubpp&lt;/b&gt;编译器生成，并且通常包含向Perl注册任何&lt;b&gt;XSUB&lt;/b&gt;所必需的语句。使用BOOT：关键字，程序员可以告诉编译器向启动函数添加额外的语句。</target>
        </trans-unit>
        <trans-unit id="ad4a573da9545ff1a8eab5e0d4f5f08622036178" translate="yes" xml:space="preserve">
          <source>The BTREE file type optionally allows a single key to be associated with an arbitrary number of values. This option is enabled by setting the flags element of &lt;code&gt;$DB_BTREE&lt;/code&gt; to R_DUP when creating the database.</source>
          <target state="translated">BTREE文件类型可选地允许单个键与任意数量的值相关联。通过在创建数据库时将 &lt;code&gt;$DB_BTREE&lt;/code&gt; 的flags元素设置为R_DUP来启用此选项。</target>
        </trans-unit>
        <trans-unit id="4a8451f6eedb6a6056c8ac828a203a8cf8bdc79c" translate="yes" xml:space="preserve">
          <source>The BTREE interface has a feature which allows partial keys to be matched. This functionality is</source>
          <target state="translated">BTREE接口有一个功能,允许匹配部分密钥。这个功能是</target>
        </trans-unit>
        <trans-unit id="19350bba9c33f125fd021dceab5ff7633dce372c" translate="yes" xml:space="preserve">
          <source>The BUILD and INSTALL steps are identical to those for Unix. Some modules generate Makefiles that work better with GNU make, which is available from &lt;a href=&quot;http://www.mks.com/s390/gnu/&quot;&gt;http://www.mks.com/s390/gnu/&lt;/a&gt;</source>
          <target state="translated">BUILD和INSTALL步骤与Unix相同。某些模块会生成与GNU make更好地配合使用的Makefile，可从&lt;a href=&quot;http://www.mks.com/s390/gnu/&quot;&gt;http://www.mks.com/s390/gnu/&lt;/a&gt;获得。</target>
        </trans-unit>
        <trans-unit id="06987733f8223bbe1dde5201da803a816622002c" translate="yes" xml:space="preserve">
          <source>The Basic Principle</source>
          <target state="translated">基本原则</target>
        </trans-unit>
        <trans-unit id="afdc8705dda034aabf31fc65386bddfb61c3e95b" translate="yes" xml:space="preserve">
          <source>The Benchmark module encapsulates a number of routines to help you figure out how long it takes to execute some code.</source>
          <target state="translated">Benchmark模块封装了一些例程,帮助你计算出执行一些代码所需的时间。</target>
        </trans-unit>
        <trans-unit id="869885b765935f032e1e45165248683c4d860661" translate="yes" xml:space="preserve">
          <source>The Berkeley DB 4.1.25 has been tested with Tru64 V5.1A and found to work. The latest Berkeley DB can be found from &lt;a href=&quot;http://www.sleepycat.com&quot;&gt;http://www.sleepycat.com&lt;/a&gt;.</source>
          <target state="translated">Berkeley DB 4.1.25已通过Tru64 V5.1A进行了测试，并且可以正常工作。可以从&lt;a href=&quot;http://www.sleepycat.com&quot;&gt;http://www.sleepycat.com&lt;/a&gt;找到最新的Berkeley DB 。</target>
        </trans-unit>
        <trans-unit id="1425da38b0881b20e7239aedd72aa0c3d5db10c1" translate="yes" xml:space="preserve">
          <source>The Bessel function of the first kind of the order zero.</source>
          <target state="translated">阶为零的第一种贝塞尔函数。</target>
        </trans-unit>
        <trans-unit id="95802efdaca31b27a14913bfe1089183b4ec8875" translate="yes" xml:space="preserve">
          <source>The C API for the backtrace is as follows:</source>
          <target state="translated">回溯的C API如下。</target>
        </trans-unit>
        <trans-unit id="89f382052ffa523340ba739809ce6ebbf65c53dd" translate="yes" xml:space="preserve">
          <source>The C array of a padlist, containing the pads. Only subscript it with numbers &amp;gt;= 1, as the 0th entry is not guaranteed to remain usable.</source>
          <target state="translated">填充列表的C数组，包含填充。仅用数字&amp;gt; = 1下标，因为不能保证第0个条目保持可用。</target>
        </trans-unit>
        <trans-unit id="9d9a695f29b97a18f6840062c9b13365fc424c17" translate="yes" xml:space="preserve">
          <source>The C array of pad entries.</source>
          <target state="translated">C数组的焊盘条目。</target>
        </trans-unit>
        <trans-unit id="82cdebaae9f3b94b2c40ce92be9ab7f40abcb4e4" translate="yes" xml:space="preserve">
          <source>The C array of pad names.</source>
          <target state="translated">垫名的C数组。</target>
        </trans-unit>
        <trans-unit id="66ccfe4f23602b2282c83a4407f8d3eb55b4ce47" translate="yes" xml:space="preserve">
          <source>The C code asks for:</source>
          <target state="translated">C代码要求:</target>
        </trans-unit>
        <trans-unit id="1755acfd3f32daf3e3ba7fab9fbb3582e6e7bc1c" translate="yes" xml:space="preserve">
          <source>The C function required to call</source>
          <target state="translated">调用所需的C函数</target>
        </trans-unit>
        <trans-unit id="593e19336c2ea1e5b6f3c47a320c97c9b260fd7c" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, wrapped if necessary, to ensure that it will return the length of the string written to the buffer. Only rare pre-ANSI systems need the wrapper function - usually this is a direct call to &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">C库 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; ，如果有必要包装，以确保它将返回写入缓冲区的字符串的长度。只有罕见的pre-ANSI系统需要包装函数-通常这是对 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 的直接调用。</target>
        </trans-unit>
        <trans-unit id="9f593f0f7e2f42e16decd49842d3eba832ba134e" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;snprintf&lt;/code&gt; functionality, if available and standards-compliant (uses &lt;code&gt;vsnprintf&lt;/code&gt; , actually). However, if the &lt;code&gt;vsnprintf&lt;/code&gt; is not available, will unfortunately use the unsafe &lt;code&gt;vsprintf&lt;/code&gt; which can overrun the buffer (there is an overrun check, but that may be too late). Consider using &lt;code&gt;sv_vcatpvf&lt;/code&gt; instead, or getting &lt;code&gt;vsnprintf&lt;/code&gt; .</source>
          <target state="translated">C库 &lt;code&gt;snprintf&lt;/code&gt; 功能（如果可用）并且符合标准（实际上使用 &lt;code&gt;vsnprintf&lt;/code&gt; ）。但是，如果 &lt;code&gt;vsnprintf&lt;/code&gt; 不可用，将不幸地使用不安全的 &lt;code&gt;vsprintf&lt;/code&gt; ，它可能会使缓冲区溢出（存在溢出检查，但这可能为时已晚）。考虑改用 &lt;code&gt;sv_vcatpvf&lt;/code&gt; 或获取 &lt;code&gt;vsnprintf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="661ddafc70911db04cf396a10417bb22f9c9013f" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;strlcat&lt;/code&gt; if available, or a Perl implementation of it. This operates on C &lt;code&gt;NUL&lt;/code&gt; -terminated strings.</source>
          <target state="translated">C库 &lt;code&gt;strlcat&lt;/code&gt; (如果可用）或其Perl实现。这对C &lt;code&gt;NUL&lt;/code&gt; 终止的字符串起作用。</target>
        </trans-unit>
        <trans-unit id="8f1fcfbd88c7e47c13102ec9e5c6df21938df7a0" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;strlcpy&lt;/code&gt; if available, or a Perl implementation of it. This operates on C &lt;code&gt;NUL&lt;/code&gt; -terminated strings.</source>
          <target state="translated">C库 &lt;code&gt;strlcpy&lt;/code&gt; (如果可用）或其Perl实现。这对C &lt;code&gt;NUL&lt;/code&gt; 终止的字符串起作用。</target>
        </trans-unit>
        <trans-unit id="6e368fd4b911113fa139d4b324c13f128de90489" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;vsnprintf&lt;/code&gt; if available and standards-compliant. However, if if the &lt;code&gt;vsnprintf&lt;/code&gt; is not available, will unfortunately use the unsafe &lt;code&gt;vsprintf&lt;/code&gt; which can overrun the buffer (there is an overrun check, but that may be too late). Consider using &lt;code&gt;sv_vcatpvf&lt;/code&gt; instead, or getting &lt;code&gt;vsnprintf&lt;/code&gt; .</source>
          <target state="translated">C库 &lt;code&gt;vsnprintf&lt;/code&gt; (如果有）并且符合标准。但是，如果 &lt;code&gt;vsnprintf&lt;/code&gt; 不可用，将不幸使用不安全的 &lt;code&gt;vsprintf&lt;/code&gt; ，它会溢出缓冲区（有溢出检查，但可能为时已晚）。考虑改用 &lt;code&gt;sv_vcatpvf&lt;/code&gt; 或获取 &lt;code&gt;vsnprintf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5183e1e6aa36fa93c903a6e7e44a0cb72c213922" translate="yes" xml:space="preserve">
          <source>The C library routines listed in the table below return values based on the current locale. Use the entries in the final column for that functionality. The other two columns always assume a POSIX (or C) locale. The entries in the ASCII column are only meaningful for ASCII inputs, returning FALSE for anything else. Use these only when you &lt;b&gt;know&lt;/b&gt; that is what you want. The entries in the Latin1 column assume that the non-ASCII 8-bit characters are as Unicode defines, them, the same as ISO-8859-1, often called Latin 1.</source>
          <target state="translated">下表中列出的C库例程根据当前语言环境返回值。在最后一列中使用该功能。其他两列始终采用POSIX（或C）语言环境。ASCII列中的条目仅对ASCII输入有意义，对于其他任何内容均返回FALSE。仅当您&lt;b&gt;知道&lt;/b&gt;自己想要的时才使用这些。Latin1列中的条目假定非ASCII 8位字符是Unicode定义的，它们与ISO-8859-1相同，通常称为Latin 1。</target>
        </trans-unit>
        <trans-unit id="a28b4e51a54be7620c06b31ca4a6442c8879a612" translate="yes" xml:space="preserve">
          <source>The C pre-processor macro to use in the &lt;code&gt;#ifdef&lt;/code&gt; . This defaults to the</source>
          <target state="translated">在 &lt;code&gt;#ifdef&lt;/code&gt; 中使用的C预处理程序宏。默认为</target>
        </trans-unit>
        <trans-unit id="e289a8cac4c6625ed2e896b05f021cd0b663f2cc" translate="yes" xml:space="preserve">
          <source>The C signature of the corresponding function should be</source>
          <target state="translated">相应函数的C签名应该是</target>
        </trans-unit>
        <trans-unit id="434fa80b2289a7e8297f9f4dbd629257d6d523b1" translate="yes" xml:space="preserve">
          <source>The C source code and header files mostly live in the root of the source tree. There are a few platform-specific directories which contain C code. In addition, some of the modules shipped with Perl include C or XS code.</source>
          <target state="translated">C源代码和头文件大多生活在源代码树的根目录下。有一些特定平台的目录包含C代码。此外,Perl中的一些模块也包含C或XS代码。</target>
        </trans-unit>
        <trans-unit id="128905b571f66231b1c910d09a2688b981aad8fb" translate="yes" xml:space="preserve">
          <source>The C standard defines the &lt;code&gt;LC_MONETARY&lt;/code&gt; category, but not a function that is affected by its contents. (Those with experience of standards committees will recognize that the working group decided to punt on the issue.) Consequently, Perl essentially takes no notice of it. If you really want to use &lt;code&gt;LC_MONETARY&lt;/code&gt; , you can query its contents--see &lt;a href=&quot;#The-localeconv-function&quot;&gt;The localeconv function&lt;/a&gt;--and use the information that it returns in your application's own formatting of currency amounts. However, you may well find that the information, voluminous and complex though it may be, still does not quite meet your requirements: currency formatting is a hard nut to crack.</source>
          <target state="translated">C标准定义了 &lt;code&gt;LC_MONETARY&lt;/code&gt; 类别，但没有定义受其内容影响的函数。 （那些有标准委员会经验的人会认识到工作组决定对此问题进行讨论。）因此，Perl基本上不理会它。如果您确实要使用 &lt;code&gt;LC_MONETARY&lt;/code&gt; ，则可以查询其内容（请参阅&lt;a href=&quot;#The-localeconv-function&quot;&gt;localeconv函数）&lt;/a&gt;，并使用它以应用程序自己的货币金额格式返回的信息。但是，您可能会发现，尽管信息量很大且很复杂，但仍不能完全满足您的要求：货币格式设置很难破解。</target>
        </trans-unit>
        <trans-unit id="9998f45e4c7233897bbe30273f117556d7539b74" translate="yes" xml:space="preserve">
          <source>The C structures used by Perl's internals to hold SV and OP information (PVIV, AV, HV, ..., OP, SVOP, UNOP, ...) are modelled on a class hierarchy and the &lt;code&gt;B&lt;/code&gt; module gives access to them via a true object hierarchy. Structure fields which point to other objects (whether types of SV or types of OP) are represented by the &lt;code&gt;B&lt;/code&gt; module as Perl objects of the appropriate class.</source>
          <target state="translated">Perl内部使用的用于保存SV和OP信息（PVIV，AV，HV，...，OP，SVOP，UNOP等）的 &lt;code&gt;B&lt;/code&gt; 结构是在类层次结构上建模的，而B模块则通过真正的对象层次结构。指向其他对象（无论是SV类型还是OP类型）的结构字段由 &lt;code&gt;B&lt;/code&gt; 模块表示为适当类的Perl对象。</target>
        </trans-unit>
        <trans-unit id="e52cd1f128c9fdf3705990415e2a1725ce8c0daa" translate="yes" xml:space="preserve">
          <source>The C style for loop is rarely needed in Perl since Perl provides the more friendly list scanning &lt;code&gt;foreach&lt;/code&gt; loop.</source>
          <target state="translated">在Perl中很少需要C风格的循环，因为Perl提供了更友好的列表扫描 &lt;code&gt;foreach&lt;/code&gt; 循环。</target>
        </trans-unit>
        <trans-unit id="41766adf1b20a48cee72fe6667e88ebc85cdc6f9" translate="yes" xml:space="preserve">
          <source>The C variable which corresponds to Perl's $^W warning variable.</source>
          <target state="translated">C变量,对应Perl的$^W警告变量。</target>
        </trans-unit>
        <trans-unit id="dfa119354e27d0075a95b6198dbb34324da3f2fb" translate="yes" xml:space="preserve">
          <source>The C-level function pointer is returned in</source>
          <target state="translated">C级函数指针以</target>
        </trans-unit>
        <trans-unit id="230e53618d509a745420dd7ed8f916298cb8a1f6" translate="yes" xml:space="preserve">
          <source>The C-level function pointer is supplied in</source>
          <target state="translated">C级函数指针提供在</target>
        </trans-unit>
        <trans-unit id="1e1b0aeffa7ba38a3388c23b72c5a0f47c58d0b1" translate="yes" xml:space="preserve">
          <source>The C3 MRO</source>
          <target state="translated">C3 MRO</target>
        </trans-unit>
        <trans-unit id="0890f76e297e8a69278390e1b8b2216c138a276e" translate="yes" xml:space="preserve">
          <source>The C3 order also lets you call methods in sibling classes with the &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; pseudo-class. See the &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; documentation for more details on this feature.</source>
          <target state="translated">C3顺序还允许您使用 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 伪类在同级类中调用方法。有关此功能的更多详细信息，请参见&lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="d0ff2a087cbd21d4354452514069e5aa62203f63" translate="yes" xml:space="preserve">
          <source>The CASE: Keyword</source>
          <target state="translated">CASE:嵉。</target>
        </trans-unit>
        <trans-unit id="c34759e310ffd05ba41a3c6d9e4717368401e66b" translate="yes" xml:space="preserve">
          <source>The CASE: keyword allows an XSUB to have multiple distinct parts with each part acting as a virtual XSUB. CASE: is greedy and if it is used then all other XS keywords must be contained within a CASE:. This means nothing may precede the first CASE: in the XSUB and anything following the last CASE: is included in that case.</source>
          <target state="translated">CASE:关键字允许一个XSUB有多个不同的部分,每个部分作为一个虚拟的XSUB。CASE:是贪婪的,如果使用它,那么所有其他XS关键字必须包含在CASE:中。这意味着XSUB中第一个CASE:之前不能有任何东西,而最后一个CASE:之后的任何东西都包含在其中。</target>
        </trans-unit>
        <trans-unit id="fae674d05cdd7c7c93ed58176b2c5091862f5184" translate="yes" xml:space="preserve">
          <source>The CLEANUP: Keyword</source>
          <target state="translated">CLEANUP:关键词</target>
        </trans-unit>
        <trans-unit id="241f3ed896c795a2f153c574bd096719fc549cce" translate="yes" xml:space="preserve">
          <source>The CODE: Keyword</source>
          <target state="translated">该CODE。关键字</target>
        </trans-unit>
        <trans-unit id="75462a30b7eda0a1256e9e78d46c9b66a39ca496" translate="yes" xml:space="preserve">
          <source>The CODEHASHREF is a reference to a hash containing names as keys and either a string to eval or a code reference for each value. For each (KEY, VALUE) pair in the CODEHASHREF, this routine will call</source>
          <target state="translated">CODEHASHREF是对一个哈希的引用,这个哈希包含了作为键的名称和要评估的字符串或每个值的代码引用。对于CODEHASHREF中的每个(KEY,VALUE)对,这个例程将调用</target>
        </trans-unit>
        <trans-unit id="2d375a6aa9b8906ba2ffceffe206a677c43a7349" translate="yes" xml:space="preserve">
          <source>The COP's hint flags, rendered with abbreviated names if possible. An empty string if this is not a COP. Here are the symbols used:</source>
          <target state="translated">COP的提示标志,如果可能的话,用缩写名称表示。如果不是COP,则为空字符串。下面是使用的符号。</target>
        </trans-unit>
        <trans-unit id="1edd5ccb6f317807268c4d710f3579aef8a9d833" translate="yes" xml:space="preserve">
          <source>The COUNT can be zero or negative, see timethis().</source>
          <target state="translated">COUNT可以是零,也可以是负数,参见timethis()。</target>
        </trans-unit>
        <trans-unit id="d7abd867e28669bc36a83d10cc2868dd307bb204" translate="yes" xml:space="preserve">
          <source>The COUNT can be zero or negative: this means the</source>
          <target state="translated">COUNT可以是零或负数:这意味着</target>
        </trans-unit>
        <trans-unit id="7180933318067029f5e634690ac1d29792da70f9" translate="yes" xml:space="preserve">
          <source>The CPAN indexes are usually rebuilt once or twice per hour, but the typical CPAN mirror mirrors only once or twice per day. Depending on the quality of your mirror and your desire to be on the bleeding edge, you may want to set the following value to more or less than one day (which is the default). It determines after how many days CPAN.pm downloads new indexes.</source>
          <target state="translated">CPAN 索引通常每小时重建一到两次,但典型的 CPAN 镜像每天只镜像一到两次。根据你的镜像质量和你想走在前沿的愿望,你可能想把下面的值设置为多于或少于一天(这是默认值)。它决定了CPAN.pm在多少天后会下载新的索引。</target>
        </trans-unit>
        <trans-unit id="377d91db5cfe6b5bd06da1ed353fc316766187b9" translate="yes" xml:space="preserve">
          <source>The CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ExtendedColor&quot;&gt;Term::ExtendedColor&lt;/a&gt; provides a different and more comprehensive interface for 256-color emulators that may be more convenient. The CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console::ANSI&quot;&gt;Win32::Console::ANSI&lt;/a&gt; provides ANSI color (and other escape sequence) support in the Win32 Console environment.</source>
          <target state="translated">CPAN模块&lt;a href=&quot;http://search.cpan.org/perldoc/Term::ExtendedColor&quot;&gt;Term :: ExtendedColor&lt;/a&gt;为256色仿真器提供了一个不同且更全面的接口，该接口可能更方便。CPAN模块&lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console::ANSI&quot;&gt;Win32 :: Console :: ANSI&lt;/a&gt;在Win32 Console环境中提供ANSI颜色（和其他转义序列）支持。</target>
        </trans-unit>
        <trans-unit id="d6b4425af9b4e8fb2b471139f3e26220141f7951" translate="yes" xml:space="preserve">
          <source>The CPAN module also supports named and versioned</source>
          <target state="translated">CPAN模块还支持命名和版本化的</target>
        </trans-unit>
        <trans-unit id="0c026574d1a86a555bc568a8cb4ff270316b96bc" translate="yes" xml:space="preserve">
          <source>The CPAN module automates or at least simplifies the make and install of perl modules and extensions. It includes some primitive searching capabilities and knows how to use LWP, HTTP::Tiny, Net::FTP and certain external download clients to fetch distributions from the net.</source>
          <target state="translated">CPAN模块可以自动或至少简化perl模块和扩展的制作和安装。它包括一些基本的搜索功能,并且知道如何使用 LWP、HTTP::Tiny、Net::FTP 和某些外部下载客户端从网络上获取发行版。</target>
        </trans-unit>
        <trans-unit id="4e178ebb5191d2f8095d21912890034971c23f17" translate="yes" xml:space="preserve">
          <source>The CPAN module can detect when a module which you are trying to build depends on prerequisites. If this happens, it can build the prerequisites for you automatically ('follow'), ask you for confirmation ('ask'), or just ignore them ('ignore'). Choosing 'follow' also sets PERL_AUTOINSTALL and PERL_EXTUTILS_AUTOINSTALL for &quot;--defaultdeps&quot; if not already set.</source>
          <target state="translated">CPAN模块可以检测到您要构建的模块是否依赖于先决条件,如果发生这种情况,它可以自动为您构建先决条件(follow),要求您确认(ask),或者直接忽略它们(ignore)。如果发生这种情况,它可以自动为您构建先决条件('follow'),要求您确认('ask'),或者直接忽略它们('ignore')。选择'follow'也会设置PERL_AUTOINSTALL和PERL_EXTUTILS_AUTOINSTALL为&quot;--defaultdeps&quot;(如果没有设置)。</target>
        </trans-unit>
        <trans-unit id="6c6573c37a2e4b0e2c1f6ecf5ee527de52c79b5e" translate="yes" xml:space="preserve">
          <source>The CPAN program is trying to depend on as little as possible so the user can use it in hostile environment. It works better the more goodies the environment provides. For example if you try in the CPAN shell</source>
          <target state="translated">CPAN程序尽量少依赖,让用户在恶劣的环境下也能使用。环境提供的好东西越多,它的效果越好。例如,如果你在CPAN的shell中试着做以下操作</target>
        </trans-unit>
        <trans-unit id="85d1aee245c3b6a287276d71fb8b02358e6086ca" translate="yes" xml:space="preserve">
          <source>The CPAN testers ( &lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt; ) are a group of volunteers who test CPAN modules on a variety of platforms.</source>
          <target state="translated">CPAN测试人员（&lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt;）是一组志愿者，他们在各种平台上测试CPAN模块。</target>
        </trans-unit>
        <trans-unit id="e02636a6cb280626a26310497466ab4002dc994b" translate="yes" xml:space="preserve">
          <source>The CRC32 and ISIZE trailer fields must be present.</source>
          <target state="translated">CRC32和ISIZE拖车字段必须存在。</target>
        </trans-unit>
        <trans-unit id="9feb874c73b191dd9599e9b2017419a0da4abb3d" translate="yes" xml:space="preserve">
          <source>The C_ARGS: Keyword</source>
          <target state="translated">C_ARGS:关键字</target>
        </trans-unit>
        <trans-unit id="701e155d0ecdee0723938fe9c7bf1396f627436a" translate="yes" xml:space="preserve">
          <source>The C_ARGS: keyword allows creating of XSUBS which have different calling sequence from Perl than from C, without a need to write CODE: or PPCODE: section. The contents of the C_ARGS: paragraph is put as the argument to the called C function without any change.</source>
          <target state="translated">C_ARGS:关键字允许创建与 Perl 不同的调用序列的 XSUBS,而不需要写 CODE:或 PPCODE:部分。C_ARGS:段的内容将作为被调用的C函数的参数,不做任何修改。</target>
        </trans-unit>
        <trans-unit id="8dd34313e432c589bd3beca248664e04fa335c40" translate="yes" xml:space="preserve">
          <source>The Carp module first appeared in Larry Wall's perl 5.000 distribution. Since then it has been modified by several of the perl 5 porters. Andrew Main (Zefram) &amp;lt;zefram@fysh.org&amp;gt; divested Carp into an independent distribution.</source>
          <target state="translated">鲤鱼模块首先出现在Larry Wall的perl 5.000发行版中。从那时起，perl 5搬运工中的一些搬运工对其进行了修改。Andrew Main（Zefram）&amp;lt;zefram@fysh.org&amp;gt;将Carp出售给独立发行商。</target>
        </trans-unit>
        <trans-unit id="73aa54f605c75d537db25ae13f844b387570066b" translate="yes" xml:space="preserve">
          <source>The Carp routines are useful in your own modules because they act like &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt;, but with a message which is more likely to be useful to a user of your module. In the case of &lt;code&gt;cluck()&lt;/code&gt; and &lt;code&gt;confess()&lt;/code&gt; , that context is a summary of every call in the call-stack; &lt;code&gt;longmess()&lt;/code&gt; returns the contents of the error message.</source>
          <target state="translated">Carp例程在您自己的模块中很有用，因为它们的行为类似于 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; ，但带有一条消息，该消息更可能对您的模块用户有用。在 &lt;code&gt;cluck()&lt;/code&gt; 和 &lt;code&gt;confess()&lt;/code&gt; 的情况下，该上下文是调用堆栈中每个调用的摘要。 &lt;code&gt;longmess()&lt;/code&gt; 返回错误消息的内容。</target>
        </trans-unit>
        <trans-unit id="0a9dcee0d40bd7f4aac08fafa5945185600a2589" translate="yes" xml:space="preserve">
          <source>The Carp routines don't handle exception objects currently. If called with a first argument that is a reference, they simply call die() or warn(), as appropriate.</source>
          <target state="translated">Carp例程目前不处理异常对象。如果调用的第一个参数是一个引用,它们只是简单地调用die()或warning(),视情况而定。</target>
        </trans-unit>
        <trans-unit id="f74ecb659d2dae844024a2a7edc2eb73241a6948" translate="yes" xml:space="preserve">
          <source>The Color Stack</source>
          <target state="translated">颜色栈</target>
        </trans-unit>
        <trans-unit id="0e751c2cd8e75382ca856116ff4097eafeafab18" translate="yes" xml:space="preserve">
          <source>The Comprehensive Perl Archive Network (CPAN) offers a wealth of extensions, some of which require a C compiler to build. Look in &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; for more information on CPAN.</source>
          <target state="translated">综合Perl存档网络（CPAN）提供了许多扩展，其中一些扩展需要C编译器来构建。在&lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/中&lt;/a&gt;查找有关CPAN的更多信息。</target>
        </trans-unit>
        <trans-unit id="2a3290ed25612a4eaac36507c34578ae080df3b2" translate="yes" xml:space="preserve">
          <source>The Comprehensive Perl Archive Network. (See the Camel Preface and Camel chapter 19, &amp;ldquo;CPAN&amp;rdquo; for details.)</source>
          <target state="translated">全面的Perl存档网络。（有关详细信息，请参见Camel前言和Camel第19章&amp;ldquo; CPAN&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="fbde9b6a7a92989c5e72924e954088639a082096" translate="yes" xml:space="preserve">
          <source>The Config module contains all the information that was available to the &lt;code&gt;Configure&lt;/code&gt; program at Perl build time (over 900 values).</source>
          <target state="translated">Config模块包含Perl构建时可用于 &lt;code&gt;Configure&lt;/code&gt; 程序的所有信息（超过900个值）。</target>
        </trans-unit>
        <trans-unit id="f82ec628dc6b60e59ddc0aa4e8da2f644e35b47f" translate="yes" xml:space="preserve">
          <source>The Config module is installed into the architecture and version specific library directory ($Config{installarchlib}) and it checks the perl version number when loaded.</source>
          <target state="translated">Config模块安装到架构和版本特定的库目录下($Config{installarchlib}),加载时它会检查perl版本号。</target>
        </trans-unit>
        <trans-unit id="cfdfb921abaaac3f8f467a1db7786aa8a018327d" translate="yes" xml:space="preserve">
          <source>The Config::Extensions module provides a hash &lt;code&gt;%Extensions&lt;/code&gt; containing all the core extensions that were enabled for this perl. The hash is keyed by extension name, with each entry having one of 3 possible values:</source>
          <target state="translated">Config :: Extensions模块提供了哈希 &lt;code&gt;%Extensions&lt;/code&gt; ,其中包含为此Perl启用的所有核心扩展。哈希由扩展名键入，每个条目具有3个可能值之一：</target>
        </trans-unit>
        <trans-unit id="93bfc257b83bc0f3f1d509f0feed1135175ce382" translate="yes" xml:space="preserve">
          <source>The Conformance Test for the UCA is available under &lt;a href=&quot;http://www.unicode.org/Public/UCA/&quot;&gt;http://www.unicode.org/Public/UCA/&lt;/a&gt;.</source>
          <target state="translated">可在&lt;a href=&quot;http://www.unicode.org/Public/UCA/&quot;&gt;http://www.unicode.org/Public/UCA/&lt;/a&gt;下获得UCA的一致性测试。</target>
        </trans-unit>
        <trans-unit id="a9099e439d69987253b372d83d6abc9bc4c12963" translate="yes" xml:space="preserve">
          <source>The Curses module from CPAN provides a dynamically loadable object module interface to a curses library. A small demo can be found at the directory &lt;a href=&quot;http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz&quot;&gt;http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz&lt;/a&gt; ; this program repeats a command and updates the screen as needed, rendering &lt;b&gt;rep ps axu&lt;/b&gt; similar to &lt;b&gt;top&lt;/b&gt;.</source>
          <target state="translated">CPAN的Curses模块为curses库提供了可动态加载的对象模块接口。可以在目录&lt;a href=&quot;http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz&quot;&gt;http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz中&lt;/a&gt;找到一个小型演示；该程序重复执行命令并根据需要更新屏幕，从而使&lt;b&gt;rep ps axu&lt;/b&gt;类似于&lt;b&gt;top&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="e14abdffc22e514738def0dbe442a1a41dfd62a8" translate="yes" xml:space="preserve">
          <source>The CvDEPTH'th entry of a PADLIST is a PAD (an AV) which is the stack frame at that depth of recursion into the CV. The 0th slot of a frame AV is an AV which is @_. Other entries are storage for variables and op targets.</source>
          <target state="translated">PADLIST的CvDEPTH'th条目是一个PAD(一个AV),它是该深度递归到CV的堆栈帧。帧AV的第0个槽是一个AV,它是@_。其他条目是变量和操作目标的存储。</target>
        </trans-unit>
        <trans-unit id="4c8b698edc086f6d5f09074b59ab49b539df94b8" translate="yes" xml:space="preserve">
          <source>The Cygwin &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot()&lt;/a&gt;&lt;/code&gt; implementation has holes (it can not restrict file access by native Win32 programs).</source>
          <target state="translated">Cygwin &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot()&lt;/a&gt;&lt;/code&gt; 实现有漏洞（它不能限制本地Win32程序对文件的访问）。</target>
        </trans-unit>
        <trans-unit id="24d81b19eab85eca5ef9e9f2cae5a86c87573ad6" translate="yes" xml:space="preserve">
          <source>The Cygwin &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink()&lt;/a&gt;&lt;/code&gt; functions make the</source>
          <target state="translated">Cygwin &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink()&lt;/a&gt;&lt;/code&gt; 函数使</target>
        </trans-unit>
        <trans-unit id="ba192629e74cc31eca240e3c966c286bb927abba" translate="yes" xml:space="preserve">
          <source>The Cygwin environment for Win32;</source>
          <target state="translated">Win32的Cygwin环境。</target>
        </trans-unit>
        <trans-unit id="1c285b2bd2bfb42d86890b2e5f1ea0881773f57b" translate="yes" xml:space="preserve">
          <source>The Cygwin tools are ports of the popular GNU development tools for Win32 platforms. They run thanks to the Cygwin library which provides the UNIX system calls and environment these programs expect. More information about this project can be found at:</source>
          <target state="translated">Cygwin工具是流行的GNU开发工具在Win32平台上的移植。它们的运行得益于Cygwin库,它提供了这些程序所期望的UNIX系统调用和环境。更多关于这个项目的信息可以在下面找到。</target>
        </trans-unit>
        <trans-unit id="b1c1f15ff329b2e8194094e815d08360dc942cc0" translate="yes" xml:space="preserve">
          <source>The DB_BTREE format is useful when you want to store data in a given order. By default the keys will be stored in lexical order, but as you will see from the example shown in the next section, it is very easy to define your own sorting function.</source>
          <target state="translated">当你想按给定的顺序存储数据时,DB_BTREE格式非常有用。默认情况下,键将按词法顺序存储,但从下一节所示的例子中可以看出,定义自己的排序功能非常容易。</target>
        </trans-unit>
        <trans-unit id="da84dd6e821316467ab753b852b3c6f56039e638" translate="yes" xml:space="preserve">
          <source>The DB_File interface was written by Paul Marquess &amp;lt;pmqs@cpan.org&amp;gt;.</source>
          <target state="translated">DB_File接口由Paul Marquess &amp;lt;pmqs@cpan.org&amp;gt;编写。</target>
        </trans-unit>
        <trans-unit id="bc4b830fc8435dde71447902321a40e9b54b9e85" translate="yes" xml:space="preserve">
          <source>The DB_File tests (db-btree.t, db-hash.t, db-recno.t) may fail you have installed a newer version of Berkeley DB into the system and the -I and -L compiler and linker flags introduce version conflicts with the DB 1.85 headers and libraries that came with the Tru64. For example, mixing a DB v2 library with the DB v1 headers is a bad idea. Watch out for Configure options -Dlocincpth and -Dloclibpth, and check your /usr/local/include and /usr/local/lib since they are included by default.</source>
          <target state="translated">DB_File测试(db-btree.t,db-hash.t,db-recno.t)可能会失败,你已经在系统中安装了较新版本的Berkeley DB,并且-I和-L编译器和链接器标志引入了与Tru64附带的DB 1.85头文件和库的版本冲突。例如,将 DB v2 库与 DB v1 头文件混合使用是个坏主意。注意配置选项 -Dlocincpth 和 -Dloclibpth,并检查您的 /usr/local/include 和 /usr/local/lib,因为它们是默认包含的。</target>
        </trans-unit>
        <trans-unit id="4aa7475384871e821eca8486a731a00b705b7453" translate="yes" xml:space="preserve">
          <source>The DB_HASH file format is probably the most commonly used of the three file formats that &lt;b&gt;DB_File&lt;/b&gt; supports. It is also very straightforward to use.</source>
          <target state="translated">DB_HASH文件格式可能是&lt;b&gt;DB_File&lt;/b&gt;支持的三种文件格式中最常用的格式。使用起来也非常简单。</target>
        </trans-unit>
        <trans-unit id="093622558089c2ef694fcbf575b62744b7d5e02e" translate="yes" xml:space="preserve">
          <source>The DEBUGGING define exposes more code to the compiler, therefore more ways for things to go wrong. You should try it.</source>
          <target state="translated">DEBUGGING定义向编译器暴露了更多的代码,因此有更多的方式出错。你应该试试。</target>
        </trans-unit>
        <trans-unit id="cd3218b27f646c5b1da0c16a7d86f78d988008e7" translate="yes" xml:space="preserve">
          <source>The DECC$FILENAME_UNIX_REPORT logical name controls how Perl interprets filenames to the extent that Perl uses the CRTL internally for many purposes, and attempts to follow CRTL conventions for reporting filenames. The DECC$FILENAME_UNIX_ONLY feature differs in that it expects all filenames passed to the C run-time to be already in Unix format. This feature is not yet supported in Perl since Perl uses traditional OpenVMS file specifications internally and in the test harness, and it is not yet clear whether this mode will be useful or useable. The feature logical name DECC$POSIX_COMPLIANT_PATHNAMES is new with the RMS Symbolic Link SDK and included with OpenVMS v8.3, but is not yet supported in Perl.</source>
          <target state="translated">DECC$FILENAME_UNIX_REPORT逻辑名控制Perl如何解释文件名,因为Perl在内部使用CRTL做许多用途,并试图遵循CRTL惯例来报告文件名。DECC$FILENAME_UNIX_ONLY特性的不同之处在于,它希望传递给C运行时的所有文件名都已经是Unix格式。Perl中还不支持这个特性,因为Perl在内部和测试线束中使用传统的OpenVMS文件规范,目前还不清楚这个模式是否有用或可使用。该特性逻辑名DECC$POSIX_COMPLIANT_PATHNAMES是RMS符号链路SDK的新特性,包含在OpenVMS v8.3中,但在Perl中还不支持。</target>
        </trans-unit>
        <trans-unit id="9d134d51441969270625bd1289ca90b131d940f8" translate="yes" xml:space="preserve">
          <source>The DOS FAT filesystem can accommodate only &quot;8.3&quot; style filenames. Under the &quot;case-insensitive, but case-preserving&quot; HPFS (OS/2) and NTFS (NT) filesystems you may have to be careful about case returned with functions like &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; or used with functions like &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">DOS FAT文件系统只能容纳&amp;ldquo; 8.3&amp;rdquo;样式的文件名。在&amp;ldquo;不区分大小写，但保留大小写&amp;rdquo;的HPFS（OS / 2）和NTFS（NT）文件系统下，您可能必须小心使用 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 之类的函数返回的大小写，或与 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; 之类的函数一起使用的大小写。</target>
        </trans-unit>
        <trans-unit id="37eace57ea45e399a72f8107235f1e100b1ee8bb" translate="yes" xml:space="preserve">
          <source>The DynaLoader is designed to be a very simple high-level interface that is sufficiently general to cover the requirements of SunOS, HP-UX, Linux, VMS and other platforms.</source>
          <target state="translated">DynaLoader被设计成一个非常简单的高级接口,其通用性足以覆盖SunOS、HP-UX、Linux、VMS和其他平台的需求。</target>
        </trans-unit>
        <trans-unit id="f912c465834fcee4d486c53fdce3a5c5359e646e" translate="yes" xml:space="preserve">
          <source>The EBCDIC code page in use on Siemens' BS2000 system is distinct from 1047 and 0037. It is identified below as the POSIX-BC set. Like 0037 and 1047, it is the same as ISO 8859-1 in 20 code point values.</source>
          <target state="translated">西门子BS2000系统上使用的EBCDIC码页与1047和0037不同。下面将其确定为POSIX-BC集。与0037和1047一样,它与ISO 8859-1的20个码点值相同。</target>
        </trans-unit>
        <trans-unit id="79364f1341ebeff610668d7a68e618ee03998d55" translate="yes" xml:space="preserve">
          <source>The EBCDIC controls provide three possible line terminator characters, CR (0x0D), LF (0x25), and NL (0x15). On ASCII platforms, the symbols &quot;NL&quot; and &quot;LF&quot; refer to the same character, but in strict EBCDIC terminology they are different ones. The EBCDIC NL is mapped to the C1 control called &quot;NEL&quot; (&quot;Next Line&quot;; here's a case where the mapping makes quite a bit of sense, and hence isn't just arbitrary). On some EBCDIC platforms, this NL or NEL is the typical line terminator. This is true of z/OS and BS2000. In these platforms, the C compilers will swap the LF and NEL code points, so that &lt;code&gt;&quot;\n&quot;&lt;/code&gt; is 0x15, and refers to NL. Perl does that too; you can see it in the code chart &lt;a href=&quot;#recipe-3&quot;&gt;below&lt;/a&gt;. This makes things generally &quot;just work&quot; without you even having to be aware that there is a swap.</source>
          <target state="translated">EBCDIC控件提供了三个可能的行终止符：CR（0x0D），LF（0x25）和NL（0x15）。在ASCII平台上，符号&amp;ldquo; NL&amp;rdquo;和&amp;ldquo; LF&amp;rdquo;指的是同一字符，但在严格的EBCDIC术语中，它们是不同的字符。 EBCDIC NL映射到名为&amp;ldquo; NEL&amp;rdquo;（&amp;ldquo;下一行&amp;rdquo;）的C1控件；在这种情况下，这种映射具有一定的意义，因此不仅是任意的。在某些EBCDIC平台上，此NL或NEL是典型的线路终结器。 z / OS和BS2000都是如此。在这些平台上，C编译器将交换LF和NEL代码点，因此 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 为0x15，并引用NL。 Perl也这样做。您可以在&lt;a href=&quot;#recipe-3&quot;&gt;下面&lt;/a&gt;的代码表中看到它。这通常使事情&amp;ldquo;正常工作&amp;rdquo;甚至无需知道有交换。</target>
        </trans-unit>
        <trans-unit id="ebf0849b9c64cecc2853f7671dcdaa67dfb5bd40" translate="yes" xml:space="preserve">
          <source>The EMX environment for DOS, OS/2, etc. emx@iaehv.nl, &lt;a href=&quot;ftp://hobbes.nmsu.edu/pub/os2/dev/emx/&quot;&gt;ftp://hobbes.nmsu.edu/pub/os2/dev/emx/&lt;/a&gt; Also &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;.</source>
          <target state="translated">用于DOS，OS / 2等的EMX环境。emx@iaehv.nl，&lt;a href=&quot;ftp://hobbes.nmsu.edu/pub/os2/dev/emx/&quot;&gt;ftp://hobbes.nmsu.edu/pub/os2/dev/emx/&lt;/a&gt;还有&lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="256f82d42fe9ffdaee741a9745d27494e5988357" translate="yes" xml:space="preserve">
          <source>The EXPORT_XSUB_SYMBOLS: Keyword</source>
          <target state="translated">EXPORT_XSUB_SYMBOLS:关键字</target>
        </trans-unit>
        <trans-unit id="dc2d72754e20f4d7576339fd0b632f9904767606" translate="yes" xml:space="preserve">
          <source>The EXPORT_XSUB_SYMBOLS: keyword is likely something you will never need. In perl versions earlier than 5.16.0, this keyword does nothing. Starting with 5.16, XSUB symbols are no longer exported by default. That is, they are &lt;code&gt;static&lt;/code&gt; functions. If you include</source>
          <target state="translated">您可能永远不需要EXPORT_XSUB_SYMBOLS：关键字。在5.16.0之前的perl版本中，此关键字不起作用。从5.16开始，默认情况下不再导出XSUB符号。也就是说，它们是 &lt;code&gt;static&lt;/code&gt; 函数。如果包括</target>
        </trans-unit>
        <trans-unit id="617a336bda8dcf8d5dea55c8c402db880f815331" translate="yes" xml:space="preserve">
          <source>The EXPR can be arbitrarily complicated provided its final operation is an element or slice of an aggregate:</source>
          <target state="translated">EXPR可以任意复杂化,只要它的最终操作是一个集合的元素或片断。</target>
        </trans-unit>
        <trans-unit id="c1575f71c727dbc3cc08a704b1c6455476c26b21" translate="yes" xml:space="preserve">
          <source>The EXTEND() macro is used to make room on the argument stack for 2 return values. The PPCODE: directive causes the &lt;b&gt;xsubpp&lt;/b&gt; compiler to create a stack pointer available as &lt;code&gt;SP&lt;/code&gt; , and it is this pointer which is being used in the EXTEND() macro. The values are then pushed onto the stack with the PUSHs() macro.</source>
          <target state="translated">EXTEND（）宏用于在参数堆栈上为2个返回值腾出空间。PPCODE：指令使&lt;b&gt;xsubpp&lt;/b&gt;编译器创建可作为 &lt;code&gt;SP&lt;/code&gt; 使用的堆栈指针，而该指针正在EXTEND（）宏中使用。然后使用PUSHs（）宏将这些值压入堆栈。</target>
        </trans-unit>
        <trans-unit id="24d94044d20d73e1e217702a7997adf3573359ef" translate="yes" xml:space="preserve">
          <source>The Eclipse Perl Integration Project integrates Perl editing/debugging with Eclipse.</source>
          <target state="translated">Eclipse Perl集成项目将Perl编辑/调试与Eclipse集成。</target>
        </trans-unit>
        <trans-unit id="089e76f353c6f78abb99ad80ce2ae65f3d8d4946" translate="yes" xml:space="preserve">
          <source>The Eighth, and Final Rule of Sys::Syslog is:</source>
          <target state="translated">第八条,也是Sys::Syslog的最终规则是:</target>
        </trans-unit>
        <trans-unit id="45e6da0d5cb898ad01f0a9bae1837646548ecfe3" translate="yes" xml:space="preserve">
          <source>The Ellipsis Statement</source>
          <target state="translated">省略号声明</target>
        </trans-unit>
        <trans-unit id="e36201c57b08755e4246cc5ce75f450c34e846b3" translate="yes" xml:space="preserve">
          <source>The Encode module is not available.</source>
          <target state="translated">编码模块不可用。</target>
        </trans-unit>
        <trans-unit id="a85df1c32e44ae493b3d9d47f5ce746d47a72805" translate="yes" xml:space="preserve">
          <source>The Encode package comes with</source>
          <target state="translated">Encode软件包带有</target>
        </trans-unit>
        <trans-unit id="1795442e49f2b33213fac82a59f9aa602577ec9d" translate="yes" xml:space="preserve">
          <source>The End Of Cargo Cult Programming</source>
          <target state="translated">货物崇拜编程的终结</target>
        </trans-unit>
        <trans-unit id="8b81b46699720b949c812be3aaed26b804f52e55" translate="yes" xml:space="preserve">
          <source>The English module, loaded via</source>
          <target state="translated">英语模块,通过</target>
        </trans-unit>
        <trans-unit id="f6ae3dbecbd56f2fb799d619d775a492c5918b30" translate="yes" xml:space="preserve">
          <source>The English name $EXCEPTIONS_BEING_CAUGHT is slightly misleading, because the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value does not indicate whether exceptions are being caught, since compilation of the main program does not catch exceptions.</source>
          <target state="translated">英文名称$ EXCEPTIONS_BEING_CAUGHT有点误导，因为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值不表示是否正在捕获异常，因为主程序的编译未捕获异常。</target>
        </trans-unit>
        <trans-unit id="a563900434d5f24e6b403136d7617e396332a2c1" translate="yes" xml:space="preserve">
          <source>The Execution of this file takes 2 parameters as input. The first being the NetWare SDK path, second being the path for CodeWarrior Compiler &amp;amp; tools. Execution of this file sets these paths and also sets the build type to Release by default.</source>
          <target state="translated">该文件的执行采用2个参数作为输入。第一个是NetWare SDK路径，第二个是CodeWarrior编译器和工具的路径。执行此文件将设置这些路径，并且还将构建类型默认设置为Release。</target>
        </trans-unit>
        <trans-unit id="f147b2a13785e77381665ed5dff1c497a9b6d450" translate="yes" xml:space="preserve">
          <source>The Exporter module implements an &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method which allows a module to export functions and variables to its users' namespaces. Many modules use Exporter rather than implementing their own &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method because Exporter provides a highly flexible interface, with an implementation optimised for the common case.</source>
          <target state="translated">Exporter模块实现了 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法，该方法允许模块将函数和变量导出到其用户的名称空间。许多模块使用Exporter而不是实现自己的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法，因为Exporter提供了高度灵活的界面，并针对常见情况进行了优化。</target>
        </trans-unit>
        <trans-unit id="f4abee164dbbeb51e77682498dd2aaadf957faf7" translate="yes" xml:space="preserve">
          <source>The Exporter module will convert an attempt to import a number from a module into a call to &lt;code&gt;$module_name-&amp;gt;VERSION($value)&lt;/code&gt; . This can be used to validate that the version of the module being used is greater than or equal to the required version.</source>
          <target state="translated">导出器模块会将尝试从模块导入数字的尝试转换为对 &lt;code&gt;$module_name-&amp;gt;VERSION($value)&lt;/code&gt; 的调用。这可用于验证所使用模块的版本大于或等于所需版本。</target>
        </trans-unit>
        <trans-unit id="7c52e8ff54cbaf19ce5405ab1f4fcb23fdb70082" translate="yes" xml:space="preserve">
          <source>The Extended Binary Coded Decimal Interchange Code refers to a large collection of single- and multi-byte coded character sets that are quite different from ASCII and ISO 8859-1, and are all slightly different from each other; they typically run on host computers. The EBCDIC encodings derive from 8-bit byte extensions of Hollerith punched card encodings, which long predate ASCII. The layout on the cards was such that high bits were set for the upper and lower case alphabetic characters &lt;code&gt;[a-z]&lt;/code&gt; and &lt;code&gt;[A-Z]&lt;/code&gt; , but there were gaps within each Latin alphabet range, visible in the table &lt;a href=&quot;#recipe-3&quot;&gt;below&lt;/a&gt;. These gaps can cause complications.</source>
          <target state="translated">扩展二进制编码的十进制交换码是指大量的单字节和多字节编码字符集，这些字符集与ASCII和ISO 8859-1完全不同，并且彼此之间都稍有不同。它们通常在主机上运行。 EBCDIC编码源自Hollerith打孔卡编码的8位字节扩展名，该扩展名早于ASCII。卡上的布局使高位和低位字母字符 &lt;code&gt;[a-z]&lt;/code&gt; 和 &lt;code&gt;[A-Z]&lt;/code&gt; 都设置了高位，但是在每个拉丁字母范围内都有空隙，&lt;a href=&quot;#recipe-3&quot;&gt;如下&lt;/a&gt;表所示。这些间隙可能导致并发症。</target>
        </trans-unit>
        <trans-unit id="6f06c8685e10bb2298b3fbb853d3946ef5600f7b" translate="yes" xml:space="preserve">
          <source>The Extended Time field (ID &quot;UT&quot;), set using the &lt;code&gt;exTime&lt;/code&gt; option, and the Unix2 extra field (ID &quot;Ux), set using the &lt;code&gt;exUnix2&lt;/code&gt; option, are examples of extra fields.</source>
          <target state="translated">在延长的时间字段（ID&amp;ldquo;UT&amp;rdquo;），使用设置 &lt;code&gt;exTime&lt;/code&gt; 选项和Unix2额外的字段（ID&amp;ldquo;UX），使用set &lt;code&gt;exUnix2&lt;/code&gt; 选项，都是多余的字段的例子。</target>
        </trans-unit>
        <trans-unit id="fcb46fea1b1fd4aac6612092ac926ea662164c18" translate="yes" xml:space="preserve">
          <source>The FALLBACK: Keyword</source>
          <target state="translated">FALLBACK:嵉。</target>
        </trans-unit>
        <trans-unit id="81e67da9b589fcad262531decfe34d5e04ad538d" translate="yes" xml:space="preserve">
          <source>The FTP protocol allows files to be sent to or fetched from the server. Each transfer involves a &lt;b&gt;local file&lt;/b&gt; (on the client) and a &lt;b&gt;remote file&lt;/b&gt; (on the server). In this module, the same file name will be used for both local and remote if only one is specified. This means that transferring remote file &lt;code&gt;/path/to/file&lt;/code&gt; will try to put that file in &lt;code&gt;/path/to/file&lt;/code&gt; locally, unless you specify a local file name.</source>
          <target state="translated">FTP协议允许将文件发送到服务器或从服务器获取文件。每次传输都涉及一个&lt;b&gt;本地文件&lt;/b&gt;（在客户端上）和一个&lt;b&gt;远程文件&lt;/b&gt;（在服务器上）。在此模块中，如果仅指定一个，则本地和远程将使用相同的文件名。这意味着传输远程文件 &lt;code&gt;/path/to/file&lt;/code&gt; 会尝试将该 &lt;code&gt;/path/to/file&lt;/code&gt; 本地放置在/ path / to / file中，除非您指定本地文件名。</target>
        </trans-unit>
        <trans-unit id="19ca5c1f27cf809b055786ff82f78ffa209098e1" translate="yes" xml:space="preserve">
          <source>The Field @* for Variable-Width Multi-Line Text</source>
          <target state="translated">用于可变宽度多行文本的字段@*。</target>
        </trans-unit>
        <trans-unit id="e40af0a7d64eded8997f1df4aaf651855caff401" translate="yes" xml:space="preserve">
          <source>The Field ^* for Variable-Width One-line-at-a-time Text</source>
          <target state="translated">可变宽度单行文本的字段^*。</target>
        </trans-unit>
        <trans-unit id="051fa4e84ae2fee9062644631a452abe1ffe1819" translate="yes" xml:space="preserve">
          <source>The Fifth Rule of Sys::Syslog is:</source>
          <target state="translated">Sys::Syslog的第五条规则是。</target>
        </trans-unit>
        <trans-unit id="916ba58ad633c9294928c7ea005c39a240dcf055" translate="yes" xml:space="preserve">
          <source>The File::Compare::compare function compares the contents of two sources, each of which can be a file or a file handle. It is exported from File::Compare by default.</source>
          <target state="translated">File::Compare::compare 函数比较两个源的内容,每个源可以是一个文件或一个文件句柄。它默认从File::Compare导出。</target>
        </trans-unit>
        <trans-unit id="ca8ebdce3138f1ac959e2447b9991cb0fe638baf" translate="yes" xml:space="preserve">
          <source>The File::Copy module provides two basic functions, &lt;code&gt;copy&lt;/code&gt; and &lt;code&gt;move&lt;/code&gt; , which are useful for getting the contents of a file from one place to another.</source>
          <target state="translated">File :: Copy模块提供了两个基本功能，即 &lt;code&gt;copy&lt;/code&gt; 和 &lt;code&gt;move&lt;/code&gt; ，这对于将文件内容从一个位置获取到另一个位置非常有用。</target>
        </trans-unit>
        <trans-unit id="09b1bcb4dc016e97cb98e50f74998315b3fcc200" translate="yes" xml:space="preserve">
          <source>The File::Temp has been a standard module since Perl 5.6.1. If you don't have a modern enough Perl installed, use the &lt;code&gt;new_tmpfile&lt;/code&gt; class method from the IO::File module to get a filehandle opened for reading and writing. Use it if you don't need to know the file's name:</source>
          <target state="translated">自Perl 5.6.1起，File :: Temp一直是标准模块。如果您没有安装足够现代的Perl，请使用IO :: File模块中的 &lt;code&gt;new_tmpfile&lt;/code&gt; 类方法获取打开的文件句柄以进行读取和写入。如果您不需要知道文件名，请使用它：</target>
        </trans-unit>
        <trans-unit id="b913943216bac4cfd103b39436c3d12211246595" translate="yes" xml:space="preserve">
          <source>The Filter</source>
          <target state="translated">过滤器</target>
        </trans-unit>
        <trans-unit id="43340f79f355f6131007a53845317a0044b9a6f5" translate="yes" xml:space="preserve">
          <source>The Filter::Simple module exports into the package that calls &lt;code&gt;FILTER&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;s it directly) -- such as package &quot;BANG&quot; in the above example -- two automagically constructed subroutines -- &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;unimport&lt;/code&gt; -- which take care of all the nasty details.</source>
          <target state="translated">过滤器::单模出口到封装的呼叫 &lt;code&gt;FILTER&lt;/code&gt; （或 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 直接的IT） -诸如包&amp;ldquo;砰&amp;rdquo;在上面的例子- 2自动的构造子程序- &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;unimport&lt;/code&gt; -这采取所有的护理令人讨厌的细节。</target>
        </trans-unit>
        <trans-unit id="6e7c10894c7b8df4a2736098e84057abd21e37b8" translate="yes" xml:space="preserve">
          <source>The Filter::Simple module provides a simplified interface to Filter::Util::Call; one that is sufficient for most common cases.</source>
          <target state="translated">Filter::Simple模块为Filter::Util::Call提供了一个简化的接口,这个接口足以满足大多数常见的情况。</target>
        </trans-unit>
        <trans-unit id="bddf2be2229684864beadb4258752319125e5d27" translate="yes" xml:space="preserve">
          <source>The First Rule of Sys::Syslog is:</source>
          <target state="translated">Sys::Syslog的第一条规则是。</target>
        </trans-unit>
        <trans-unit id="c785438975752290d77a3cbc9b618a56d2ef340f" translate="yes" xml:space="preserve">
          <source>The Fourth Rule of Sys::Syslog is:</source>
          <target state="translated">Sys::Syslog的第四条规则是。</target>
        </trans-unit>
        <trans-unit id="9fc0887978d7a0f1367b4c9ada979ec50584ea98" translate="yes" xml:space="preserve">
          <source>The FreeBSD extensions to the POSIX standard are the following flags:</source>
          <target state="translated">FreeBSD 对 POSIX 标准的扩展有以下标志。</target>
        </trans-unit>
        <trans-unit id="ab3e557141760f9299f04ad34f2deeabfcc7fef0" translate="yes" xml:space="preserve">
          <source>The FreeMiNT port uses GNU dld for loadable module capabilities. So ensure you have that library installed when building perl.</source>
          <target state="translated">FreeMiNT port 使用 GNU dld 来实现可加载模块功能。所以在构建 perl 时,请确保您已经安装了该库。</target>
        </trans-unit>
        <trans-unit id="f0fd999d74111938e315c20e741e008d3fd7c5c7" translate="yes" xml:space="preserve">
          <source>The GNU C Compiler</source>
          <target state="translated">GNU C编译器</target>
        </trans-unit>
        <trans-unit id="d9d4765228818a588c101c574dcfb1a870a89ab7" translate="yes" xml:space="preserve">
          <source>The GV returned from &lt;code&gt;gv_fetchmeth&lt;/code&gt; may be a method cache entry, which is not visible to Perl code. So when calling &lt;code&gt;call_sv&lt;/code&gt; , you should not use the GV directly; instead, you should use the method's CV, which can be obtained from the GV with the &lt;code&gt;GvCV&lt;/code&gt; macro.</source>
          <target state="translated">从 &lt;code&gt;gv_fetchmeth&lt;/code&gt; 返回的GV 可能是方法缓存项，这对Perl代码不可见。因此，在调用 &lt;code&gt;call_sv&lt;/code&gt; 时，您不应直接使用GV。相反，您应该使用方法的CV，该CV可通过 &lt;code&gt;GvCV&lt;/code&gt; 宏从GV获得。</target>
        </trans-unit>
        <trans-unit id="b49130058618570dadbdb5fe7db0bf1f3977aebe" translate="yes" xml:space="preserve">
          <source>The GV which was last used for a filehandle input operation. (&lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; )</source>
          <target state="translated">最后用于文件句柄输入操作的GV。（ &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f9210879f69c79f8b2c57a2c424d2e90c56d2548" translate="yes" xml:space="preserve">
          <source>The G_KEEPERR flag is meant to be used in conjunction with G_EVAL in</source>
          <target state="translated">G_KEEPERR标志是和G_EVAL一起使用的。</target>
        </trans-unit>
        <trans-unit id="270052086120a712d1ce772352a3feccf55ed3d1" translate="yes" xml:space="preserve">
          <source>The G_KEEPERR flag was introduced in Perl version 5.002.</source>
          <target state="translated">G_KEEPERR标志是在Perl 5.002版本中引入的。</target>
        </trans-unit>
        <trans-unit id="c166e1d44ca297aba655d34fc5c35cdba6de63b6" translate="yes" xml:space="preserve">
          <source>The Gamma function [C99].</source>
          <target state="translated">伽马函数[C99]。</target>
        </trans-unit>
        <trans-unit id="c28a373a90d22851cb6b0c5d6429010695515e8d" translate="yes" xml:space="preserve">
          <source>The Generic Object</source>
          <target state="translated">通用对象</target>
        </trans-unit>
        <trans-unit id="be19e055acdc9d4cfa79691a16d99bc6afcec772" translate="yes" xml:space="preserve">
          <source>The Getopt::Long module implements an extended getopt function called GetOptions(). It parses the command line from &lt;code&gt;@ARGV&lt;/code&gt; , recognizing and removing specified options and their possible values.</source>
          <target state="translated">Getopt :: Long模块实现了名为getOptions（）的扩展getopt函数。它从 &lt;code&gt;@ARGV&lt;/code&gt; 解析命令行，识别并删除指定的选项及其可能的值。</target>
        </trans-unit>
        <trans-unit id="2070520f96de2fb3aff1e83e6888cb8e89e845b4" translate="yes" xml:space="preserve">
          <source>The Gods Must Be Crazy</source>
          <target state="translated">诸神一定是疯了</target>
        </trans-unit>
        <trans-unit id="95a2e8168d41f50bb6b37295098c965f76153807" translate="yes" xml:space="preserve">
          <source>The Guide</source>
          <target state="translated">指南</target>
        </trans-unit>
        <trans-unit id="5298e135f008dcbe68c1cb6c5368e25d31e290a3" translate="yes" xml:space="preserve">
          <source>The HP ANSI C Compiler</source>
          <target state="translated">HP ANSI C编译器</target>
        </trans-unit>
        <trans-unit id="cbc8f650d8669a3292691821f3fcd62a7f570f6f" translate="yes" xml:space="preserve">
          <source>The HP porting centres are limited in what systems they are allowed to port to and they usually choose the two most recent OS versions available.</source>
          <target state="translated">HP 移植中心在允许移植到什么系统上是有限制的,他们通常会选择两个最新的操作系统版本。</target>
        </trans-unit>
        <trans-unit id="f122712cd3f618cf66f5c1f12ee353af13431595" translate="yes" xml:space="preserve">
          <source>The HTML/XML character reference modes are about the same. In place of &lt;code&gt;\x{&lt;i&gt;HHHH&lt;/i&gt;}&lt;/code&gt;, HTML uses &lt;code&gt;&amp;amp;#&lt;i&gt;NNN&lt;/i&gt;;&lt;/code&gt; where</source>
          <target state="translated">HTML / XML字符引用模式大致相同。代替 &lt;code&gt;\x{&lt;i&gt;HHHH&lt;/i&gt;}&lt;/code&gt; ，HTML用途 &lt;code&gt;&amp;amp;#&lt;i&gt;NNN&lt;/i&gt;;&lt;/code&gt; 哪里</target>
        </trans-unit>
        <trans-unit id="36100c08868e01dc8cc43e522dca19e6917bba7c" translate="yes" xml:space="preserve">
          <source>The Hitchhiker's Guide to the Galaxy</source>
          <target state="translated">银河系漫游指南(The Hitchhiker's Guide to the Galaxy)</target>
        </trans-unit>
        <trans-unit id="e1c3679460c98c3b3c6c4ab57a10e09b7a1778d9" translate="yes" xml:space="preserve">
          <source>The Hobbit</source>
          <target state="translated">霍比特人</target>
        </trans-unit>
        <trans-unit id="ff076bcca2d7f3f3bc21f192dd45509aa2d50344" translate="yes" xml:space="preserve">
          <source>The I/O layers can also be specified more flexibly with the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma. See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;, or look at the following example.</source>
          <target state="translated">I / O层也可以使用 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 编译指示更灵活地指定。请参见&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;，或查看以下示例。</target>
        </trans-unit>
        <trans-unit id="9bb410ea518f5686bb8957c03ada154b43330468" translate="yes" xml:space="preserve">
          <source>The IANA is responsible for delegating management of the top level country domains. The country domains are the two-letter (lowercase) codes from ISO 3166 with a few other additions.</source>
          <target state="translated">IANA负责委托管理最高级别的国家域。国家域是ISO 3166中的双字母(小写)代码,并增加了一些其他内容。</target>
        </trans-unit>
        <trans-unit id="494453dbfde6185be2550cd595666629ce3cd776" translate="yes" xml:space="preserve">
          <source>The IANA language subtag registry.</source>
          <target state="translated">IANA语言子标签注册表。</target>
        </trans-unit>
        <trans-unit id="14ed0108ca9064725768107f673bb9f9f4c35fe4" translate="yes" xml:space="preserve">
          <source>The IBM ANSI C Compiler</source>
          <target state="translated">IBM ANSI C编译器</target>
        </trans-unit>
        <trans-unit id="02dd8ba3a34ffd809cf07605a9d86d87105f9946" translate="yes" xml:space="preserve">
          <source>The IBM APAR number for this problem is IZ50240 (Reported component ID: 5765G0300 / AIX 5.3). It is possible to get an ifix for that problem. If you need an ifix please contact your local IBM AIX support.</source>
          <target state="translated">这个问题的IBM APAR号是IZ50240(报告组件ID:5765G0300/AIX 5.3)。可以获得该问题的ifix。如果你需要一个ifix,请联系你当地的IBM AIX支持。</target>
        </trans-unit>
        <trans-unit id="a6c290ab208815021765007f305a8fc14c88a6b4" translate="yes" xml:space="preserve">
          <source>The IBM's compiler patch levels 5.0.0.0 and 5.0.1.0 have compiler optimization bugs that affect compiling perl.c and regcomp.c, respectively. If Perl's configuration detects those compiler patch levels, optimization is turned off for the said source code files. Upgrading to at least 5.0.2.0 is recommended.</source>
          <target state="translated">IBM的编译器补丁级别5.0.0.0和5.0.1.0存在编译器优化错误,分别影响到编译perl.c和regcomp.c。如果Perl的配置检测到这些编译器补丁级别,则会关闭对上述源代码文件的优化。建议至少升级到5.0.2.0。</target>
        </trans-unit>
        <trans-unit id="9495fe8f41686bc61a5fe351f28585160b7d92af" translate="yes" xml:space="preserve">
          <source>The ID header in an &lt;code&gt;ExtraField&lt;/code&gt; sub-field can consist of any two bytes.</source>
          <target state="translated">&lt;code&gt;ExtraField&lt;/code&gt; 子字段中的ID标头可以包含任何两个字节。</target>
        </trans-unit>
        <trans-unit id="e1d154173604900e6d649a0362f6607140bc599a" translate="yes" xml:space="preserve">
          <source>The IDs of all objects available within a program are strings that can be expanded to the corresponding real objects with the &lt;code&gt;CPAN::Shell-&amp;gt;expand(&quot;Module&quot;,@things)&lt;/code&gt; method. Expand returns a list of CPAN::Module objects according to the &lt;code&gt;@things&lt;/code&gt; arguments given. In scalar context, it returns only the first element of the list.</source>
          <target state="translated">程序中所有可用对象的ID是可以使用 &lt;code&gt;CPAN::Shell-&amp;gt;expand(&quot;Module&quot;,@things)&lt;/code&gt; 方法扩展为相应实际对象的字符串。Expand根据给定的 &lt;code&gt;@things&lt;/code&gt; 参数返回CPAN :: Module对象的列表。在标量上下文中，它仅返回列表的第一个元素。</target>
        </trans-unit>
        <trans-unit id="10ac6c437c9901ca659c989f66f60ed9a2a13418" translate="yes" xml:space="preserve">
          <source>The IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT Keywords</source>
          <target state="translated">IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT关键字。</target>
        </trans-unit>
        <trans-unit id="348998c68227b2675b00049ded155d9a2e0cebf4" translate="yes" xml:space="preserve">
          <source>The INCLUDE: Keyword</source>
          <target state="translated">的INCLUDE。关键字</target>
        </trans-unit>
        <trans-unit id="2fd635a1ef0c21453ce812dc91933d7964a41662" translate="yes" xml:space="preserve">
          <source>The INCLUDE_COMMAND: Keyword</source>
          <target state="translated">INCLUDE_COMMAND:关键字。</target>
        </trans-unit>
        <trans-unit id="edaf758a314e34d83c79323397c8453ba48d6649" translate="yes" xml:space="preserve">
          <source>The INIT: Keyword</source>
          <target state="translated">INIT:关键字</target>
        </trans-unit>
        <trans-unit id="c2a1ae034dc0e7090561071ada28079423ed98bf" translate="yes" xml:space="preserve">
          <source>The INIT: directive contains code that will be placed immediately after the argument stack is decoded. C does not allow variable declarations at arbitrary locations inside a function, so this is usually the best way to declare local variables needed by the XSUB. (Alternatively, one could put the whole &lt;code&gt;PPCODE:&lt;/code&gt; section into braces, and put these declarations on top.)</source>
          <target state="translated">INIT：指令包含将在对参数堆栈进行解码之后立即放置的代码。C不允许在函数内部的任意位置声明变量，因此，这通常是声明XSUB所需的局部变量的最佳方法。（或者，可以将整个 &lt;code&gt;PPCODE:&lt;/code&gt; 部分放在花括号中，并将这些声明放在顶部。）</target>
        </trans-unit>
        <trans-unit id="08f7558037e95071c749920f4074890a9d7217ea" translate="yes" xml:space="preserve">
          <source>The INIT: keyword allows initialization to be inserted into the XSUB before the compiler generates the call to the C function. Unlike the CODE: keyword above, this keyword does not affect the way the compiler handles RETVAL.</source>
          <target state="translated">INIT:关键字允许在编译器产生对C函数的调用之前,将初始化插入XSUB中。与上面的CODE:关键字不同,这个关键字不影响编译器处理RETVAL的方式。</target>
        </trans-unit>
        <trans-unit id="05bebe82f53ea5f020b6b0d4fe1069dcc8a1edbb" translate="yes" xml:space="preserve">
          <source>The INPUT and OUTPUT sections substitute underscores for double-colons on the fly, giving the desired effect. This example demonstrates some of the power and versatility of the typemap facility.</source>
          <target state="translated">INPUT和OUTPUT部分用下划线代替了双冒号,从而达到了预期的效果。这个例子展示了类型图工具的一些功能和多样性。</target>
        </trans-unit>
        <trans-unit id="970adbac5d031ff3f8daeef101bb8b55901dc870" translate="yes" xml:space="preserve">
          <source>The INPUT: Keyword</source>
          <target state="translated">INPUT的。关键字</target>
        </trans-unit>
        <trans-unit id="21ee92ef918e68068f302b993af8bd2d49672033" translate="yes" xml:space="preserve">
          <source>The INSTALL file in the perl top-level has much information that is only relevant to people building Perl on Unix-like systems. In particular, you can safely ignore any information that talks about &quot;Configure&quot;.</source>
          <target state="translated">perl顶层的INSTALL文件中有很多信息只与在类似Unix系统上构建Perl的人有关。尤其是,你可以放心地忽略任何关于 &quot;Configure &quot;的信息。</target>
        </trans-unit>
        <trans-unit id="0adfc9336795bed66f7e1ae7c7424119e43e300c" translate="yes" xml:space="preserve">
          <source>The INSTALL... macros in turn default to their %Config ($Config{installprivlib}, $Config{installarchlib}, etc.) counterparts.</source>
          <target state="translated">INSTALL...宏则默认为其对应的 %Config ($Config{installprivlib},$Config{installarchlib}等)。</target>
        </trans-unit>
        <trans-unit id="9023b649b609edcd17550081d28e4a80cf681ce5" translate="yes" xml:space="preserve">
          <source>The INTERFACE: Keyword</source>
          <target state="translated">INTERFACE:关键字</target>
        </trans-unit>
        <trans-unit id="e1fc34a9a712c8a8848d549ec748ba68c13f33e7" translate="yes" xml:space="preserve">
          <source>The INTERFACE_MACRO: Keyword</source>
          <target state="translated">INTERFACE_MACRO:关键字</target>
        </trans-unit>
        <trans-unit id="1dc68d829f3e7afebf9178286cb38cc376f6ec35" translate="yes" xml:space="preserve">
          <source>The IO::Pty and Expect modules from CPAN can help with this, as they provide a real tty (well, a pseudo-tty, actually), which gets you back to line buffering in the invoked command again.</source>
          <target state="translated">CPAN中的IO::Pty和Expect模块可以帮助解决这个问题,因为它们提供了一个真正的tty(好吧,实际上是一个伪tty),这让你再次回到调用命令中的行缓冲。</target>
        </trans-unit>
        <trans-unit id="99807f53289794deab86efdaf9d7a76fb60defb6" translate="yes" xml:space="preserve">
          <source>The IO::Socket(3) manpage describes the object library, and the Socket(3) manpage describes the low-level interface to sockets. Besides the obvious functions in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, you should also check out the</source>
          <target state="translated">IO :: Socket（3）联机帮助页描述了对象库，而Socket（3）联机帮助页描述了套接字的低级接口。除了&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;明显的功能外，您还应该查看</target>
        </trans-unit>
        <trans-unit id="dd19329497c4746f419d864be77ab0a23a7089f7" translate="yes" xml:space="preserve">
          <source>The ISO 4217 data.</source>
          <target state="translated">ISO 4217日期。</target>
        </trans-unit>
        <trans-unit id="9aedc742ca6fb2dc7b951347169405aefc47d178" translate="yes" xml:space="preserve">
          <source>The ISO 8601 standard defines the date format to be YYYY-MM-DD, and the time format to be hh:mm:ss (24 hour clock), and if combined, they should be concatenated with date first and with a capital 'T' in front of the time.</source>
          <target state="translated">ISO 8601标准定义的日期格式为YYYY-MM-DD,时间格式为hh:mm:ss(24小时钟),如果将它们组合在一起,应先连接日期,并在时间前面加上大写的 &quot;T&quot;。</target>
        </trans-unit>
        <trans-unit id="b1897fe9f53f26e8ee1d177c372171adf09aeabb" translate="yes" xml:space="preserve">
          <source>The ISO 8859-</source>
          <target state="translated">ISO 8859-</target>
        </trans-unit>
        <trans-unit id="be3a3d5a87727d649fad4e25cef60372ccbe4e20" translate="yes" xml:space="preserve">
          <source>The IVdf will expand to whatever is the correct format for the IVs.</source>
          <target state="translated">IVdf将扩展到任何正确的IVs格式。</target>
        </trans-unit>
        <trans-unit id="2438b4ecbe3dbd078f85fcd76de3ac8517dfbe33" translate="yes" xml:space="preserve">
          <source>The Inside-out Technique</source>
          <target state="translated">由内而外的技巧</target>
        </trans-unit>
        <trans-unit id="bfd4ccd468ad208229b8e304f3f53a782dd6a87c" translate="yes" xml:space="preserve">
          <source>The Intent</source>
          <target state="translated">意图</target>
        </trans-unit>
        <trans-unit id="94771cb0c8e4f1f0a6f837c00d85c8dc460252be" translate="yes" xml:space="preserve">
          <source>The Internet line terminator is &quot;\015\012&quot;. Under ASCII variants of Unix, that could usually be written as &quot;\r\n&quot;, but under other systems, &quot;\r\n&quot; might at times be &quot;\015\015\012&quot;, &quot;\012\012\015&quot;, or something completely different. The standards specify writing &quot;\015\012&quot; to be conformant (be strict in what you provide), but they also recommend accepting a lone &quot;\012&quot; on input (be lenient in what you require). We haven't always been very good about that in the code in this manpage, but unless you're on a Mac from way back in its pre-Unix dark ages, you'll probably be ok.</source>
          <target state="translated">互联网线路终结器是 &quot;015/012&quot;。在Unix的ASCII变体下,通常可以写成&quot;\r\n&quot;,但在其他系统下,&quot;\r\n &quot;有时可能是&quot;\015\012&quot;,&quot;\012\012\015&quot;,或完全不同的东西。标准规定写&quot;\015\012 &quot;是为了符合标准(在你提供的东西上要严格),但他们也建议在输入上接受一个孤独的&quot;\012&quot;(在你要求的东西上要宽松)。在这个manpage的代码中,我们并不总是很好地做到这一点,但除非你使用的是Mac,从它的前Unix黑暗时代开始,你可能就会没事了。</target>
        </trans-unit>
        <trans-unit id="501b92baa8d232237960cf668a9120aec4afdddd" translate="yes" xml:space="preserve">
          <source>The Keyed-Hash Message Authentication Code (HMAC):</source>
          <target state="translated">钥匙哈希信息认证码(HMAC)。</target>
        </trans-unit>
        <trans-unit id="d65b2222a8c282dae9b3cd28518dc29329740227" translate="yes" xml:space="preserve">
          <source>The LAYER parameter of the binmode() function is described as &quot;DISCIPLINE&quot; in &quot;Programming Perl, 3rd Edition&quot;. However, since the publishing of this book, by many known as &quot;Camel III&quot;, the consensus of the naming of this functionality has moved from &quot;discipline&quot; to &quot;layer&quot;. All documentation of this version of Perl therefore refers to &quot;layers&quot; rather than to &quot;disciplines&quot;. Now back to the regularly scheduled documentation...</source>
          <target state="translated">binmode()函数的LAYER参数在《Programming Perl,3rd Edition》中被描述为 &quot;discipline&quot;。然而,自从这本被许多人称为 &quot;Camel III &quot;的书出版后,人们对这个功能的命名的共识已经从 &quot;discipline &quot;转移到了 &quot;layer&quot;。因此,这个版本的Perl的所有文档都是指 &quot;层 &quot;而不是 &quot;学科&quot;。现在回到定期安排的文档中...</target>
        </trans-unit>
        <trans-unit id="c5a27ef16f958a529f7db36014226c11d0b2a269" translate="yes" xml:space="preserve">
          <source>The LENGTH must be less than or equal to the buffer size.</source>
          <target state="translated">LENGTH必须小于或等于缓冲区大小。</target>
        </trans-unit>
        <trans-unit id="ea2784880355655cd5260296b326df11e2887853" translate="yes" xml:space="preserve">
          <source>The LLP64 data model is different from the LP64 data model that is the norm on 64-bit Unix platforms. In the former, &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt; are both 32-bit data types, while pointers are 64 bits wide. In addition, there is a separate 64-bit wide integral type, &lt;code&gt;__int64&lt;/code&gt; . In contrast, the LP64 data model that is pervasive on Unix platforms provides &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; as the 32-bit type, while both the &lt;code&gt;long&lt;/code&gt; type and pointers are of 64-bit precision. Note that both models provide for 64-bits of addressability.</source>
          <target state="translated">LLP64数据模型不同于LP64数据模型，后者是64位Unix平台上的规范。在前者中， &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;long&lt;/code&gt; 都是32位数据类型，而指针是64位宽。此外，还有一个单独的64位宽整数类型 &lt;code&gt;__int64&lt;/code&gt; 。相反，在Unix平台上普遍使用的LP64数据模型将 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 作为32位类型提供，而 &lt;code&gt;long&lt;/code&gt; 类型和指针都具有64位精度。请注意，两个模型都提供64位寻址能力。</target>
        </trans-unit>
        <trans-unit id="89a865b15f025e4125f9521e0cbb444b319a7463" translate="yes" xml:space="preserve">
          <source>The Layout</source>
          <target state="translated">布局</target>
        </trans-unit>
        <trans-unit id="3892e7769cde3def977297b2fd107c985947cfbb" translate="yes" xml:space="preserve">
          <source>The Lays of Beleriand</source>
          <target state="translated">贝利兰的土地</target>
        </trans-unit>
        <trans-unit id="b0afa09df1fad56be5d5842b1eca124439a7ca1c" translate="yes" xml:space="preserve">
          <source>The LimitOutput option.</source>
          <target state="translated">LimitOutput选项。</target>
        </trans-unit>
        <trans-unit id="7609c4332cdddf67282a426dcc844b81450f8724" translate="yes" xml:space="preserve">
          <source>The Locale-Codes distribution.</source>
          <target state="translated">本地代码分布。</target>
        </trans-unit>
        <trans-unit id="4371d0e1d710e94eadf09e06051f14e2003db5e7" translate="yes" xml:space="preserve">
          <source>The Locale/Maketext.pm source. Observe that the module is much shorter than its documentation!</source>
          <target state="translated">Locale/Maketext.pm源码。请注意,该模块比它的文档要短得多!</target>
        </trans-unit>
        <trans-unit id="38bb5321e46a281dda4ae130db97eaa961627a32" translate="yes" xml:space="preserve">
          <source>The Lord of the Rings</source>
          <target state="translated">指环王</target>
        </trans-unit>
        <trans-unit id="65d1f880f060efd8bb95b4c1ef3aa2f9bbc16903" translate="yes" xml:space="preserve">
          <source>The MANIFEST file contains the names of all the files just created in the Mytest directory.</source>
          <target state="translated">MANIFEST文件包含了刚才在Mytest目录下创建的所有文件的名称。</target>
        </trans-unit>
        <trans-unit id="cc342c2add9e7769b6276801f43191956bbbeb6e" translate="yes" xml:space="preserve">
          <source>The MD5 algorithm is defined in RFC 1321. This implementation is derived from the reference C code in RFC 1321 which is covered by the following copyright statement:</source>
          <target state="translated">MD5算法在RFC 1321中定义。该算法的实现源自RFC 1321中的参考C代码,其版权声明如下:</target>
        </trans-unit>
        <trans-unit id="a517aaaef144e51dda68ffaef4baabb6659f9741" translate="yes" xml:space="preserve">
          <source>The MODULE Keyword</source>
          <target state="translated">模組關鍵字</target>
        </trans-unit>
        <trans-unit id="d640b9c0318e742980f68cffc45a40affd82cb5f" translate="yes" xml:space="preserve">
          <source>The MODULE keyword is used to start the XS code and to specify the package of the functions which are being defined. All text preceding the first MODULE keyword is considered C code and is passed through to the output with POD stripped, but otherwise untouched. Every XS module will have a bootstrap function which is used to hook the XSUBs into Perl. The package name of this bootstrap function will match the value of the last MODULE statement in the XS source files. The value of MODULE should always remain constant within the same XS file, though this is not required.</source>
          <target state="translated">MODULE关键字用于启动XS代码,并指定正在定义的函数包。在第一个MODULE关键字之前的所有文本都被认为是C代码,并被传递到输出端,其中的POD被剥离,但其他部分未被触及。每个XS模块都会有一个引导函数,用来将XSUBs挂到Perl中。这个引导函数的包名将与XS源文件中最后一条MODULE语句的值相匹配。在同一个XS文件中,MODULE的值应该始终保持不变,尽管这不是必须的。</target>
        </trans-unit>
        <trans-unit id="eb4b2ce583f381cfbe7f078522f5b75cf8b0acdd" translate="yes" xml:space="preserve">
          <source>The MY_CXT_INIT macro initializes storage for the &lt;code&gt;my_cxt_t&lt;/code&gt; struct.</source>
          <target state="translated">MY_CXT_INIT宏初始化 &lt;code&gt;my_cxt_t&lt;/code&gt; 结构的存储。</target>
        </trans-unit>
        <trans-unit id="2dd4eb6a77854464c830f76b78c6ac15e92b669d" translate="yes" xml:space="preserve">
          <source>The Makefile to be produced may be altered by adding arguments of the form &lt;code&gt;KEY=VALUE&lt;/code&gt; . E.g.</source>
          <target state="translated">可以通过添加 &lt;code&gt;KEY=VALUE&lt;/code&gt; 形式的参数来更改要生成的Makefile 。例如</target>
        </trans-unit>
        <trans-unit id="ad78ec4ae3b5a4c78156cf44036606a40c32aaf5" translate="yes" xml:space="preserve">
          <source>The Mantra</source>
          <target state="translated">咒语</target>
        </trans-unit>
        <trans-unit id="1b194ffb2833786ebe5362ee6e09704940be3454" translate="yes" xml:space="preserve">
          <source>The Memoize man page.</source>
          <target state="translated">Memoize人页。</target>
        </trans-unit>
        <trans-unit id="8b07a539021a149c75372ae5a8d60bcacade8512" translate="yes" xml:space="preserve">
          <source>The Microsoft Visual C++ compilers are also now being given away free. They are available as &quot;Visual C++ Toolkit 2003&quot; or &quot;Visual C++ 2005-2013 Express Edition&quot; (and also as part of the &quot;.NET Framework SDK&quot;) and are the same compilers that ship with &quot;Visual C++ .NET 2003 Professional&quot; or &quot;Visual C++ 2005-2013 Professional&quot; respectively.</source>
          <target state="translated">微软Visual C++编译器现在也在免费赠送。它们以 &quot;Visual C++Toolkit 2003 &quot;或 &quot;Visual C++2005-2013 Express Edition &quot;的形式提供(也是&quot;.NET Framework SDK &quot;的一部分),分别与 &quot;Visual C++.NET 2003 Professional &quot;或 &quot;Visual C++2005-2013 Professional &quot;中的编译器相同。</target>
        </trans-unit>
        <trans-unit id="b6efbee1ed83675ffebd32144ba8248768436ab5" translate="yes" xml:space="preserve">
          <source>The NAME section (&lt;code&gt;=head1 NAME&lt;/code&gt; ) should consist of a single paragraph with the script/module name, followed by a dash `-' and a very short description of what the thing is good for.</source>
          <target state="translated">NAME部分（ &lt;code&gt;=head1 NAME&lt;/code&gt; ）应该由一个带有脚本/模块名称的段落组成，后跟一个破折号'-'和对该内容有好处的简短描述。</target>
        </trans-unit>
        <trans-unit id="552a987af386f5239d1d91c8f3cd7d6b46b27cbb" translate="yes" xml:space="preserve">
          <source>The NAME section should be recognized specially and index entries emitted for everything in that section. This would have to be deferred until the next section, since extraneous things in NAME tends to confuse various man page processors. Currently, no index entries are emitted for anything in NAME.</source>
          <target state="translated">NAME部分应该被特别识别,并为该部分的所有内容发出索引条目。这将不得不推迟到下一节,因为NAME中无关的东西往往会让各种man page处理器感到困惑。目前,NAME中的任何内容都不会发出索引条目。</target>
        </trans-unit>
        <trans-unit id="eede37533894539b6f0e561b631aee0b3870de35" translate="yes" xml:space="preserve">
          <source>The NEVER keyword must appear by itself if used within the Notify option and &quot;requests that a DSN not be returned to the sender under any conditions.&quot;</source>
          <target state="translated">如果在 &quot;通知 &quot;选项中使用NEVER关键字,并且 &quot;请求在任何情况下都不将DSN返回给发件人&quot;,则该关键字必须单独出现。</target>
        </trans-unit>
        <trans-unit id="1dccb0bb054644651ad0c69767bda009b1d0637b" translate="yes" xml:space="preserve">
          <source>The NO_INIT Keyword</source>
          <target state="translated">NO_INIT关键字</target>
        </trans-unit>
        <trans-unit id="23729fabcc944859639583f78edb8c8ef05b2818" translate="yes" xml:space="preserve">
          <source>The NO_INIT keyword is used to indicate that a function parameter is being used only as an output value. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will normally generate code to read the values of all function parameters from the argument stack and assign them to C variables upon entry to the function. NO_INIT will tell the compiler that some parameters will be used for output rather than for input and that they will be handled before the function terminates.</source>
          <target state="translated">NO_INIT关键字用于指示功能参数仅用作输出值。该&lt;b&gt;xsubpp&lt;/b&gt;编译器通常会产生的代码从参数堆栈读取所有功能参数的值，并将它们在进入的功能分配给C变量。NO_INIT将告诉编译器某些参数将用于输出而不是输入，并且将在函数终止之前对其进行处理。</target>
        </trans-unit>
        <trans-unit id="8fd6dba18911a57231232a7c939d805f823c76e7" translate="yes" xml:space="preserve">
          <source>The NO_OUTPUT Keyword</source>
          <target state="translated">NO_OUTPUT关键字</target>
        </trans-unit>
        <trans-unit id="03379df3fc9b65eb904066ecff904227f6ca6017" translate="yes" xml:space="preserve">
          <source>The NO_OUTPUT can be placed as the first token of the XSUB. This keyword indicates that while the C subroutine we provide an interface to has a non-&lt;code&gt;void&lt;/code&gt; return type, the return value of this C subroutine should not be returned from the generated Perl subroutine.</source>
          <target state="translated">可以将NO_OUTPUT放置为XSUB的第一个令牌。此关键字指示尽管我们提供的接口C子例程具有非 &lt;code&gt;void&lt;/code&gt; 返回类型，但不应从生成的Perl子例程返回此C子例程的返回值。</target>
        </trans-unit>
        <trans-unit id="904e01c3e307ff335e43430a3d4bc1ddd9643078" translate="yes" xml:space="preserve">
          <source>The Name_Alias property is also of this form. But each scalar consists of two components: 1) the name, and 2) the type of alias this is. They are separated by a colon and a space. In Unicode 6.1, there are several alias types:</source>
          <target state="translated">Name_Alias属性也是这种形式。但每个标量都由两部分组成。1)名称,和2)别名的类型。它们之间用一个冒号和一个空格隔开。在Unicode 6.1中,有几种别名类型。</target>
        </trans-unit>
        <trans-unit id="b8335e651ec579d0644f75bd5c6369bb3697cc7b" translate="yes" xml:space="preserve">
          <source>The Nestable version works by looking for hash references being stored and converting them to tied hashes so that they too can have references as keys. This will happen without warning whenever you store a reference to one of your own hashes in the tied hash.</source>
          <target state="translated">嵌套版本的工作原理是寻找正在存储的哈希引用,并将它们转换为绑定哈希,这样它们也可以将引用作为键。每当你在绑定哈希中存储一个对你自己的哈希的引用时,这种情况就会毫无预警地发生。</target>
        </trans-unit>
        <trans-unit id="1aaccf615c02a846abe966f8242837a674850c5a" translate="yes" xml:space="preserve">
          <source>The Net::FTP class is a subclass of Net::Cmd and IO::Socket::INET.</source>
          <target state="translated">Net::FTP类是Net::Cmd和IO::Socket::INET的一个子类。</target>
        </trans-unit>
        <trans-unit id="01eaa0b5dde8380e0c7a54964e805d8bfcf3acc6" translate="yes" xml:space="preserve">
          <source>The Net::NNTP class is a subclass of Net::Cmd and IO::Socket::INET.</source>
          <target state="translated">Net::NNTP类是Net::Cmd和IO::Socket::INET的一个子类。</target>
        </trans-unit>
        <trans-unit id="da23b39231b794a7054fda91fbd214625459379e" translate="yes" xml:space="preserve">
          <source>The Net::POP3 class is a subclass of Net::Cmd and IO::Socket::INET.</source>
          <target state="translated">Net::POP3类是Net::Cmd和IO::Socket::INET的一个子类。</target>
        </trans-unit>
        <trans-unit id="8d68199e14c6e60b44de999602d0fae86539eba2" translate="yes" xml:space="preserve">
          <source>The Net::SMTP class is a subclass of Net::Cmd and IO::Socket::INET.</source>
          <target state="translated">Net::SMTP类是Net::Cmd和IO::Socket::INET的一个子类。</target>
        </trans-unit>
        <trans-unit id="64f60cb8e2581437bfdc17a813e7b06233279924" translate="yes" xml:space="preserve">
          <source>The OP's flags, abbreviated as a series of symbols.</source>
          <target state="translated">上位者的旗帜,简写为一系列符号。</target>
        </trans-unit>
        <trans-unit id="895a69280490efde337cd0fd19af585a8e383312" translate="yes" xml:space="preserve">
          <source>The OP's name, in all caps.</source>
          <target state="translated">上级的名字,大写的。</target>
        </trans-unit>
        <trans-unit id="02eabb0cd331fbbf23966749354f0c2df6db1d07" translate="yes" xml:space="preserve">
          <source>The OP's name.</source>
          <target state="translated">上司的名字。</target>
        </trans-unit>
        <trans-unit id="2e25dacc5e61c7fb0d63f53483335a706cbf1613" translate="yes" xml:space="preserve">
          <source>The OP's private flags, rendered with abbreviated names if possible.</source>
          <target state="translated">上位者的私人标志,如果可能的话,用简写的名字来表示。</target>
        </trans-unit>
        <trans-unit id="59e423cd50aec687154fc4dc506adc4e55e686ff" translate="yes" xml:space="preserve">
          <source>The OP-specific information of the OP (such as the SV for an SVOP, the non-local exit pointers for a LOOP, etc.) enclosed in parentheses.</source>
          <target state="translated">括号内为OP的特定信息(如SVOP的SV、LOOP的非本地退出指针等)。</target>
        </trans-unit>
        <trans-unit id="0f586844a0e8ae4292abb29dd5184b53fc4b9536" translate="yes" xml:space="preserve">
          <source>The OS/390 and z/OS C run-time libraries provide &lt;code&gt;_atoe()&lt;/code&gt; and &lt;code&gt;_etoa()&lt;/code&gt; functions.</source>
          <target state="translated">OS / 390和z / OS C运行时库提供 &lt;code&gt;_atoe()&lt;/code&gt; 和 &lt;code&gt;_etoa()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="efc93b2b68cdc27d26189d3924b12fba2216cd16" translate="yes" xml:space="preserve">
          <source>The OUTPUT: Keyword</source>
          <target state="translated">OUTPUT。关键字</target>
        </trans-unit>
        <trans-unit id="6558e5f212b7172c05e18d1a7261588a3081027f" translate="yes" xml:space="preserve">
          <source>The OUTPUT: keyword can also be used to indicate that function parameters are output variables. This may be necessary when a parameter has been modified within the function and the programmer would like the update to be seen by Perl.</source>
          <target state="translated">OUTPUT:关键字也可以用来表示函数参数是输出变量。当一个参数在函数中被修改,而程序员希望Perl能看到更新时,这可能是必要的。</target>
        </trans-unit>
        <trans-unit id="73a9f4665d98e2b1d4598fa0b47867a5d82b1767" translate="yes" xml:space="preserve">
          <source>The OUTPUT: keyword indicates that certain function parameters should be updated (new values made visible to Perl) when the XSUB terminates or that certain values should be returned to the calling Perl function. For simple functions which have no CODE: or PPCODE: section, such as the sin() function above, the RETVAL variable is automatically designated as an output value. For more complex functions the &lt;b&gt;xsubpp&lt;/b&gt; compiler will need help to determine which variables are output variables.</source>
          <target state="translated">OUTPUT：关键字指示XSUB终止时应更新某些函数参数（使新值对Perl可见），或应将某些值返回给调用Perl函数。对于没有CODE：或PPCODE：部分的简单函数，例如上面的sin（）函数，RETVAL变量将自动指定为输出值。对于更复杂的功能，&lt;b&gt;xsubpp&lt;/b&gt;编译器将需要帮助来确定哪些变量是输出变量。</target>
        </trans-unit>
        <trans-unit id="4cc5401f4b3edfb0209daaa58ea92639a885ffb3" translate="yes" xml:space="preserve">
          <source>The OUTPUT: keyword will also allow an output parameter to be mapped to a matching piece of code rather than to a typemap.</source>
          <target state="translated">OUTPUT:关键字也将允许输出参数被映射到匹配的代码,而不是类型映射。</target>
        </trans-unit>
        <trans-unit id="9ee72e50bec09b405c45fd6861c78e461f0c9260" translate="yes" xml:space="preserve">
          <source>The OVERLOAD: Keyword</source>
          <target state="translated">OVERLOAD。关键字</target>
        </trans-unit>
        <trans-unit id="7288e63116c84272f399850db852020e0cc73247" translate="yes" xml:space="preserve">
          <source>The Opcode module allow you to define an</source>
          <target state="translated">Opcode模块允许您定义一个</target>
        </trans-unit>
        <trans-unit id="959cf82efacd7e02d3ef8885dabccff7457e7125" translate="yes" xml:space="preserve">
          <source>The Opcode module is not usually used directly. See the ops pragma and Safe modules for more typical uses.</source>
          <target state="translated">Opcode模块通常不直接使用。更多的典型用法请参考OPS pragma和Safe模块。</target>
        </trans-unit>
        <trans-unit id="fc2df1bcfc1883b7877806492c6187e99dd073c7" translate="yes" xml:space="preserve">
          <source>The Opcode package contains functions for manipulating operator names tags and sets. All are available for export by the package.</source>
          <target state="translated">Opcode包包含了用于操作操作符名称标签和集合的函数。所有的函数都可以通过该包导出。</target>
        </trans-unit>
        <trans-unit id="d8d0c8d509c42bd9d64cbd39302a78c4a8138b0f" translate="yes" xml:space="preserve">
          <source>The Output File Glob is a normal string, with 2 glob-like features.</source>
          <target state="translated">输出文件Glob是一个普通的字符串,有2个类似glob的功能。</target>
        </trans-unit>
        <trans-unit id="84f8f10721f91385f97d9092c39e5e78fd029d2f" translate="yes" xml:space="preserve">
          <source>The PACKAGE Keyword</source>
          <target state="translated">PACKAGE关键字</target>
        </trans-unit>
        <trans-unit id="865d0a1c65f77bfae0d9586920617d375bc6acfd" translate="yes" xml:space="preserve">
          <source>The PADLIST has a C array where pads are stored.</source>
          <target state="translated">PADLIST有一个C数组,在这个数组中存储了焊盘。</target>
        </trans-unit>
        <trans-unit id="14a42650858d4f29fe76f5f506d61c2fcd72c3a0" translate="yes" xml:space="preserve">
          <source>The PASE environment is a runtime environment for OS/400 that can run executables built for PowerPC AIX in OS/400; see &lt;a href=&quot;perlos400&quot;&gt;perlos400&lt;/a&gt;. PASE is ASCII-based, not EBCDIC-based as the ILE.</source>
          <target state="translated">PASE环境是OS / 400的运行时环境，可以运行为OS / 400中的PowerPC AIX构建的可执行文件。参见&lt;a href=&quot;perlos400&quot;&gt;perlos400&lt;/a&gt;。PASE是基于ASCII的，而不是基于EBCDIC的ILE。</target>
        </trans-unit>
        <trans-unit id="1f72b8482ed4bc7cb03eba7f8d7c5860c8cba587" translate="yes" xml:space="preserve">
          <source>The PATH isn't the only environment variable which can cause problems. Because some shells may use the variables IFS, CDPATH, ENV, and BASH_ENV, Perl checks that those are either empty or untainted when starting subprocesses. You may wish to add something like this to your setid and taint-checking scripts.</source>
          <target state="translated">PATH 并不是唯一一个会引起问题的环境变量。因为有些shell可能会使用IFS、CDPATH、ENV和BASH_ENV等变量,所以Perl会在启动子进程时检查这些变量是否为空或未被污染。你可能希望在你的setid和污点检查脚本中添加类似这样的内容。</target>
        </trans-unit>
        <trans-unit id="74d39bcf239c4e87e009e146ae36fe8545147ee4" translate="yes" xml:space="preserve">
          <source>The PATHEXT env variable will be used to get a list of extensions that might indicate a command, otherwise .com, .exe, .bat and .cmd will be used by default.</source>
          <target state="translated">PATHEXT env变量将用于获取可能表示命令的扩展名列表,否则将默认使用.com、.exe、.bat和.cmd。</target>
        </trans-unit>
        <trans-unit id="7243f6ac7c83fe20c93feefd9b08218632215bc2" translate="yes" xml:space="preserve">
          <source>The PATTERN need not be constant; an expression may be used to specify a pattern that varies at runtime.</source>
          <target state="translated">PATTERN不需要是常数;可以使用一个表达式来指定一个在运行时变化的模式。</target>
        </trans-unit>
        <trans-unit id="692a1dbebc7770986f39cc91bf3402c713778957" translate="yes" xml:space="preserve">
          <source>The PERL5DB environment variable is only used when Perl is started with a bare &lt;b&gt;-d&lt;/b&gt; switch.</source>
          <target state="translated">仅当使用裸机&lt;b&gt;-d&lt;/b&gt;开关启动Perl时，才使用PERL5DB环境变量。</target>
        </trans-unit>
        <trans-unit id="1eee98df1ea759ea4940bac25b454fb3fd49fcab" translate="yes" xml:space="preserve">
          <source>The PERL5LIB and PERLLIB logical names work as documented in &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt;, except that the element separator is '|' instead of ':'. The directory specifications may use either VMS or Unix syntax.</source>
          <target state="translated">PERL5LIB和PERLLIB逻辑名称按&lt;a href=&quot;perl&quot;&gt;perl中的&lt;/a&gt;说明工作，除了元素分隔符为'|' 代替 '：'。目录规范可以使用VMS或Unix语法。</target>
        </trans-unit>
        <trans-unit id="368f8cf4322638139da678fdc3327c77e1a054e7" translate="yes" xml:space="preserve">
          <source>The PERLIO environment variable is completely ignored when Perl is run in taint mode.</source>
          <target state="translated">当Perl以污点模式运行时,PERLIO环境变量会被完全忽略。</target>
        </trans-unit>
        <trans-unit id="054efbf018fd73b713cd0bc442abab0d7792d243" translate="yes" xml:space="preserve">
          <source>The PERLLIB environment variable is completely ignored when Perl is run in taint mode.</source>
          <target state="translated">当Perl在污点模式下运行时,PERLLIB环境变量会被完全忽略。</target>
        </trans-unit>
        <trans-unit id="d86bdeabcf0cc9f48a3238fc1e1e9701f94852a2" translate="yes" xml:space="preserve">
          <source>The PERL_MAGIC_uvar interface for hashes</source>
          <target state="translated">用于哈希的PERL_MAGIC_uvar接口。</target>
        </trans-unit>
        <trans-unit id="fb91b23c022ab8bc327b326b9c283bc9250f0c0a" translate="yes" xml:space="preserve">
          <source>The PERL_VMS_EXCEPTION_DEBUG being defined as &quot;ENABLE&quot; will cause the VMS debugger to be invoked if a fatal exception that is not otherwise handled is raised. The purpose of this is to allow debugging of internal Perl problems that would cause such a condition.</source>
          <target state="translated">被定义为 &quot;ENABLE &quot;的PERL_VMS_EXCEPTION_DEBUG将使VMS调试器在出现没有被处理的致命异常时被调用。这样做的目的是为了允许调试会导致这种情况的Perl内部问题。</target>
        </trans-unit>
        <trans-unit id="7e2373bae9a9b5526191c72b5feebb5b501ede90" translate="yes" xml:space="preserve">
          <source>The POD file has some &lt;code&gt;=item&lt;/code&gt; and/or &lt;code&gt;=head&lt;/code&gt; commands that have the same text. Potential hyperlinks to such a text cannot be unique then. This warning is printed only with warning level greater than one.</source>
          <target state="translated">POD文件具有一些 &lt;code&gt;=item&lt;/code&gt; 和/或 &lt;code&gt;=head&lt;/code&gt; 命令，它们具有相同的文本。这样，指向此类文本的潜在超链接就不能唯一。仅在警告级别大于一的情况下打印此警告。</target>
        </trans-unit>
        <trans-unit id="6a2061d2e11b2e67b0037b468d2ff510b08d969a" translate="yes" xml:space="preserve">
          <source>The POD names of files are the plain basenames with any Perl-like extension (.pm, .pl, .pod) stripped, and path separators replaced by &lt;code&gt;::&lt;/code&gt; 's.</source>
          <target state="translated">文件的POD名称是纯基本名称，带有任何类似于Perl的扩展名（.pm，.pl，.pod），并且路径分隔符由 &lt;code&gt;::&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="d3f7ef3aaed3b96c670ec2c717b4d27aac5d999a" translate="yes" xml:space="preserve">
          <source>The POSIX class matches according to the locale, except:</source>
          <target state="translated">POSIX类根据locale匹配,除了。</target>
        </trans-unit>
        <trans-unit id="d05b25c0d51d4520f59dbd5e7b83c675d81a2280" translate="yes" xml:space="preserve">
          <source>The POSIX class matches the same as its Full-range counterpart.</source>
          <target state="translated">POSIX类与Full-range类的匹配相同。</target>
        </trans-unit>
        <trans-unit id="a91522989698e72a81436ce9d52c71f12180a429" translate="yes" xml:space="preserve">
          <source>The POSIX class matches the same as the ASCII range counterpart.</source>
          <target state="translated">POSIX类与ASCII范围对应的匹配相同。</target>
        </trans-unit>
        <trans-unit id="45eac6affb7dfd81e7b1ef63dd7e0a2e6da662a9" translate="yes" xml:space="preserve">
          <source>The POSIX class matches the same as the Full-range counterpart.</source>
          <target state="translated">POSIX类的匹配与Full-range对应的相同。</target>
        </trans-unit>
        <trans-unit id="dc901c76cdcb97dea7310ea8ea924293bb5949f6" translate="yes" xml:space="preserve">
          <source>The POSIX defined flags for bsd_glob() are:</source>
          <target state="translated">bsd_glob()的POSIX定义的标志是。</target>
        </trans-unit>
        <trans-unit id="0fced43544b15278205eeaf1ce05bf21af49dca0" translate="yes" xml:space="preserve">
          <source>The POSIX module (part of the standard perl distribution) implements &lt;code&gt;ceil()&lt;/code&gt; , &lt;code&gt;floor()&lt;/code&gt; , and other mathematical and trigonometric functions. The &lt;code&gt;&lt;a href=&quot;math/complex&quot;&gt;Math::Complex&lt;/a&gt;&lt;/code&gt; module (part of the standard perl distribution) defines mathematical functions that work on both the reals and the imaginary numbers. &lt;code&gt;Math::Complex&lt;/code&gt; is not as efficient as POSIX, but POSIX can't work with complex numbers.</source>
          <target state="translated">POSIX模块（标准perl发行版的一部分）实现 &lt;code&gt;ceil()&lt;/code&gt; ， &lt;code&gt;floor()&lt;/code&gt; 以及其他数学和三角函数。的 &lt;code&gt;&lt;a href=&quot;math/complex&quot;&gt;Math::Complex&lt;/a&gt;&lt;/code&gt; 模组（标准perl的一部分）限定的数学函数，关于实数和虚数都工作。 &lt;code&gt;Math::Complex&lt;/code&gt; 不如POSIX高效，但是POSIX无法处理复数。</target>
        </trans-unit>
        <trans-unit id="58a76e828b7178504f0efaab58e9fc7ae8c408e4" translate="yes" xml:space="preserve">
          <source>The POSIX module permits you to access all (or nearly all) the standard POSIX 1003.1 identifiers. Many of these identifiers have been given Perl-ish interfaces.</source>
          <target state="translated">POSIX模块允许你访问所有(或几乎所有)标准POSIX 1003.1标识符。这些标识符中的许多已经被赋予了Perl式的接口。</target>
        </trans-unit>
        <trans-unit id="bb00001e36c555e321a2c3180d9872e8c4493925" translate="yes" xml:space="preserve">
          <source>The POSIX provided &lt;code&gt;GLOB_APPEND&lt;/code&gt; , &lt;code&gt;GLOB_DOOFFS&lt;/code&gt; , and the FreeBSD extensions &lt;code&gt;GLOB_ALTDIRFUNC&lt;/code&gt; , and &lt;code&gt;GLOB_MAGCHAR&lt;/code&gt; flags have not been implemented in the Perl version because they involve more complex interaction with the underlying C structures.</source>
          <target state="translated">POSIX提供的 &lt;code&gt;GLOB_APPEND&lt;/code&gt; ， &lt;code&gt;GLOB_DOOFFS&lt;/code&gt; 和FreeBSD扩展 &lt;code&gt;GLOB_ALTDIRFUNC&lt;/code&gt; 和 &lt;code&gt;GLOB_MAGCHAR&lt;/code&gt; 标志在Perl版本中尚未实现，因为它们涉及与基础C结构的更复杂的交互。</target>
        </trans-unit>
        <trans-unit id="a0d47d53c93142215e84e50218c868cd954904f3" translate="yes" xml:space="preserve">
          <source>The POSIX::strftime() approach has the benefit of being, in theory, independent of the current locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for details.</source>
          <target state="translated">从理论上讲，POSIX :: strftime（）方法的好处是独立于当前语言环境。有关详细信息，请参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4be5af1b8c4f7ec96a716021937a3c9561f2d5c" translate="yes" xml:space="preserve">
          <source>The POSTCALL: Keyword</source>
          <target state="translated">POSTCALL:关键词</target>
        </trans-unit>
        <trans-unit id="58e421a82995ac1225598edc3f8a16b394004724" translate="yes" xml:space="preserve">
          <source>The POSTCALL: block does not make a lot of sense when the C subroutine call is supplied by user by providing either CODE: or PPCODE: section.</source>
          <target state="translated">当用户通过提供CODE:或PPCODE:部分来提供C子程序调用时,POSTCALL:块的意义不大。</target>
        </trans-unit>
        <trans-unit id="b336bc59359478eb80f69f21fc081230df6f7578" translate="yes" xml:space="preserve">
          <source>The PPCODE: Keyword</source>
          <target state="translated">PPCODE。关键字</target>
        </trans-unit>
        <trans-unit id="cfd48109a24f72ee93cb2960e4b31f2a2958e886" translate="yes" xml:space="preserve">
          <source>The PPCODE: keyword is an alternate form of the CODE: keyword and is used to tell the &lt;b&gt;xsubpp&lt;/b&gt; compiler that the programmer is supplying the code to control the argument stack for the XSUBs return values. Occasionally one will want an XSUB to return a list of values rather than a single value. In these cases one must use PPCODE: and then explicitly push the list of values on the stack. The PPCODE: and CODE: keywords should not be used together within the same XSUB.</source>
          <target state="translated">PPCODE：关键字是CODE：关键字的替代形式，用于告诉&lt;b&gt;xsubpp&lt;/b&gt;编译器程序员正在提供代码来控制XSUBs返回值的参数堆栈。有时，人们希望XSUB返回值列表，而不是单个值。在这种情况下，必须使用PPCODE :，然后将值列表明确推入堆栈。PPCODE：和CODE：关键字不应在同一XSUB中一起使用。</target>
        </trans-unit>
        <trans-unit id="6f7f4e638293474e32a1342be9b48c14f4f2f5af" translate="yes" xml:space="preserve">
          <source>The PREFIX Keyword</source>
          <target state="translated">PREFIX关键字</target>
        </trans-unit>
        <trans-unit id="52a603903d899ccd2bb20a31b53d728d154bd0a6" translate="yes" xml:space="preserve">
          <source>The PREFIX keyword designates prefixes which should be removed from the Perl function names. If the C function is &lt;code&gt;rpcb_gettime()&lt;/code&gt; and the PREFIX value is &lt;code&gt;rpcb_&lt;/code&gt; then Perl will see this function as &lt;code&gt;gettime()&lt;/code&gt; .</source>
          <target state="translated">PREFIX关键字指定应从Perl函数名称中删除的前缀。如果C函数是 &lt;code&gt;rpcb_gettime()&lt;/code&gt; ，而PREFIX值是 &lt;code&gt;rpcb_&lt;/code&gt; ,则Perl将把此函数视为 &lt;code&gt;gettime()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88877bb4605c88019ee2001796614ad12f854190" translate="yes" xml:space="preserve">
          <source>The PREINIT: Keyword</source>
          <target state="translated">PREINIT:关键词</target>
        </trans-unit>
        <trans-unit id="81434e6a015b3cc52c205c8d0096aa1b8047f180" translate="yes" xml:space="preserve">
          <source>The PREINIT: keyword allows extra variables to be declared immediately before or after the declarations of the parameters from the INPUT: section are emitted.</source>
          <target state="translated">PREINIT:关键字允许在INPUT:部分的参数声明发出之前或之后立即声明额外的变量。</target>
        </trans-unit>
        <trans-unit id="fe7bb955840f60bbf203155b0452f242dc963bed" translate="yes" xml:space="preserve">
          <source>The PROTOTYPE: Keyword</source>
          <target state="translated">PROTOTYPE。关键字</target>
        </trans-unit>
        <trans-unit id="88332a599c2ebe7acc31d1e6540ad41d11fdae24" translate="yes" xml:space="preserve">
          <source>The PROTOTYPES: Keyword</source>
          <target state="translated">PROTOTYPES。关键字</target>
        </trans-unit>
        <trans-unit id="4762c608488c900a25e5c9ce4a388703783fff72" translate="yes" xml:space="preserve">
          <source>The PROTOTYPES: keyword corresponds to &lt;b&gt;xsubpp&lt;/b&gt;'s &lt;code&gt;-prototypes&lt;/code&gt; and &lt;code&gt;-noprototypes&lt;/code&gt; options. This keyword overrides the command line options. Prototypes are enabled by default. When prototypes are enabled XSUBs will be given Perl prototypes. This keyword may be used multiple times in an XS module to enable and disable prototypes for different parts of the module.</source>
          <target state="translated">原型：关键字对应&lt;b&gt;xsubpp&lt;/b&gt;的 &lt;code&gt;-prototypes&lt;/code&gt; 和 &lt;code&gt;-noprototypes&lt;/code&gt; 选项。此关键字将覆盖命令行选项。默认情况下启用原型。启用原型后，将为XSUB提供Perl原型。在XS模块中，可以多次使用此关键字来启用和禁用模块不同部分的原型。</target>
        </trans-unit>
        <trans-unit id="32ef6835ed63a718cf287a36ed5a59d894d8bfe4" translate="yes" xml:space="preserve">
          <source>The PV of the sv is returned.</source>
          <target state="translated">返回sv的PV。</target>
        </trans-unit>
        <trans-unit id="cbea6ce0d8ba0f98747339e84eb8596aa1948b13" translate="yes" xml:space="preserve">
          <source>The Perl 5 core includes mechanisms to help porters make backwards incompatible changes more compatible such as the &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;deprecate&quot;&gt;deprecate&lt;/a&gt; modules. Please use them when appropriate.</source>
          <target state="translated">Perl 5核心包括帮助搬运工使向后不兼容的更改更兼容的机制，例如&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;和&lt;a href=&quot;deprecate&quot;&gt;弃用&lt;/a&gt;模块。请在适当的时候使用它们。</target>
        </trans-unit>
        <trans-unit id="bab276840135536c5b050850ebb3b382c1feec45" translate="yes" xml:space="preserve">
          <source>The Perl 5 smartmatch and &lt;code&gt;given&lt;/code&gt; /&lt;code&gt;when&lt;/code&gt; constructs are not compatible with their Perl 6 analogues. The most visible difference and least important difference is that, in Perl 5, parentheses are required around the argument to &lt;code&gt;given()&lt;/code&gt; and &lt;code&gt;when()&lt;/code&gt; (except when this last one is used as a statement modifier). Parentheses in Perl 6 are always optional in a control construct such as &lt;code&gt;if()&lt;/code&gt; , &lt;code&gt;while()&lt;/code&gt; , or &lt;code&gt;when()&lt;/code&gt; ; they can't be made optional in Perl 5 without a great deal of potential confusion, because Perl 5 would parse the expression</source>
          <target state="translated">Perl 5 smartmatch和 &lt;code&gt;given&lt;/code&gt; / &lt;code&gt;when&lt;/code&gt; 构造与其Perl 6类似物不兼容。最明显的区别和最不重要的区别是，在Perl 5中，给 &lt;code&gt;given()&lt;/code&gt; 和 &lt;code&gt;when()&lt;/code&gt; 的参数周围需要括号（除非将最后一个用作语句修饰符）。Perl 6中的括号在控制结构（例如 &lt;code&gt;if()&lt;/code&gt; ， &lt;code&gt;while()&lt;/code&gt; 或 &lt;code&gt;when()&lt;/code&gt; )中始终是可选的；在没有很多潜在混乱的情况下，它们不能在Perl 5中成为可选的，因为Perl 5会解析表达式</target>
        </trans-unit>
        <trans-unit id="5d32638db8a1c22afb3b560c2715ac8287958e39" translate="yes" xml:space="preserve">
          <source>The Perl 5 source code is available at &amp;lt;&lt;a href=&quot;http://perl5.git.perl.org/perl.git&quot;&gt;http://perl5.git.perl.org/perl.git&lt;/a&gt;&amp;gt; and ExtUtils-CBuilder may be found in the</source>
          <target state="translated">可在&amp;lt; &lt;a href=&quot;http://perl5.git.perl.org/perl.git&quot;&gt;http://perl5.git.perl.org/perl.git&lt;/a&gt; &amp;gt;上获得Perl 5源代码，并且可以在以下位置找到ExtUtils-CBuilder。</target>
        </trans-unit>
        <trans-unit id="afeaca8df1b6424181f3a66ccbb3b6382d64c41b" translate="yes" xml:space="preserve">
          <source>The Perl API changes over time. New functions are added or the interfaces of existing functions are changed. The &lt;code&gt;Devel::PPPort&lt;/code&gt; module tries to provide compatibility code for some of these changes, so XS writers don't have to code it themselves when supporting multiple versions of Perl.</source>
          <target state="translated">Perl API随时间变化。添加了新功能或更改了现有功能的接口。该 &lt;code&gt;Devel::PPPort&lt;/code&gt; 模块尝试一些这些变化提供兼容性代码，因此支持的Perl的多个版本时XS作家不必代码它自己。</target>
        </trans-unit>
        <trans-unit id="b3ddaaeb977cd171a0809e4c9d46db7115a9f674" translate="yes" xml:space="preserve">
          <source>The Perl Archive Toolkit ( &lt;a href=&quot;http://par.perl.org/&quot;&gt;http://par.perl.org/&lt;/a&gt; ) is Perl's analog to Java's JAR. It's freely available and on CPAN ( &lt;a href=&quot;http://search.cpan.org/dist/PAR/&quot;&gt;http://search.cpan.org/dist/PAR/&lt;/a&gt; ).</source>
          <target state="translated">Perl存档工具包（&lt;a href=&quot;http://par.perl.org/&quot;&gt;http://par.perl.org/&lt;/a&gt;）是Perl与Java的JAR类似的东西。它是免费的，可以在CPAN（&lt;a href=&quot;http://search.cpan.org/dist/PAR/&quot;&gt;http://search.cpan.org/dist/PAR/&lt;/a&gt;）上获得。</target>
        </trans-unit>
        <trans-unit id="f01c36b942223cd02d483b2f8710a5fcbe7b3f1a" translate="yes" xml:space="preserve">
          <source>The Perl Authors Upload SErver (&lt;a href=&quot;http://pause.perl.org&quot;&gt;http://pause.perl.org&lt;/a&gt;), the gateway for &lt;b&gt;modules&lt;/b&gt; on their way to &lt;b&gt;CPAN&lt;/b&gt;.</source>
          <target state="translated">Perl的作者上传服务器（&lt;a href=&quot;http://pause.perl.org&quot;&gt;http://pause.perl.org&lt;/a&gt;），用于网关&lt;b&gt;模块&lt;/b&gt;的道路上&lt;b&gt;CPAN&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="b633506d32991c982d57371e8ff5e8e620c6651c" translate="yes" xml:space="preserve">
          <source>The Perl Compiler Backend</source>
          <target state="translated">Perl编译器后端</target>
        </trans-unit>
        <trans-unit id="528f579664ac974a57416a02a9f4d6f1fb344d5b" translate="yes" xml:space="preserve">
          <source>The Perl DLL is installed in \System\Libs\. The Perl libraries and extension DLLs are installed in \System\Libs\Perl\X.Y.Z\. The PerlApp is installed in \System\Apps\, and the SIS also installs a couple of demo scripts in \Perl\ (C:\Mydocs\Perl\ on Nokia 7710).</source>
          <target state="translated">Perl DLLs 安装在 \SystemLibs 中。Perl库和扩展DLLs安装在SystemLibs/Perl/X.Y.Z/中。PerlApp安装在System\Apps中,SIS还在Perl中安装了几个演示脚本(C:Mydocs\Perl on Nokia 7710)。</target>
        </trans-unit>
        <trans-unit id="b0d4827468980c5df0784a8af4ce7848ecde4b66" translate="yes" xml:space="preserve">
          <source>The Perl Debugger</source>
          <target state="translated">Perl调试器</target>
        </trans-unit>
        <trans-unit id="003a86b939921d18b908afadb31a1624a5c158e1" translate="yes" xml:space="preserve">
          <source>The Perl Dev Kit ( &lt;a href=&quot;http://www.activestate.com/Products/Perl_Dev_Kit/&quot;&gt;http://www.activestate.com/Products/Perl_Dev_Kit/&lt;/a&gt; ) from ActiveState can &quot;Turn your Perl programs into ready-to-run executables for HP-UX, Linux, Solaris and Windows.&quot;</source>
          <target state="translated">ActiveState提供的Perl开发工具包（&lt;a href=&quot;http://www.activestate.com/Products/Perl_Dev_Kit/&quot;&gt;http://www.activestate.com/Products/Perl_Dev_Kit/&lt;/a&gt;）可以&amp;ldquo;将您的Perl程序转换为可立即用于HP-UX，Linux，Solaris和Windows的可执行文件。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="1c56af5a226a11b5977e777d4fb79e3fb6c794f9" translate="yes" xml:space="preserve">
          <source>The Perl Forked Debugger</source>
          <target state="translated">Perl Forked调试器</target>
        </trans-unit>
        <trans-unit id="076abbe7cec0580634f13cf92571ce869da1bf79" translate="yes" xml:space="preserve">
          <source>The Perl Foundation is an advocacy organization for the Perl language which maintains the web site &lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt; as a general advocacy site for the Perl language. It uses the domain to provide general support services to the Perl community, including the hosting of mailing lists, web sites, and other services. There are also many other sub-domains for special topics like learning Perl and jobs in Perl, such as:</source>
          <target state="translated">Perl基金会是Perl语言的宣传组织，该网站将&lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt;保留为Perl语言的一般宣传站点。它使用该域为Perl社区提供常规支持服务，包括托管邮件列表，网站和其他服务。对于特殊主题，还有许多其他子域，例如学习Perl和Perl中的工作，例如：</target>
        </trans-unit>
        <trans-unit id="d177a21aa5a9fba680e844771ded5bc126e66e5c" translate="yes" xml:space="preserve">
          <source>The Perl Journal</source>
          <target state="translated">Perl杂志</target>
        </trans-unit>
        <trans-unit id="b540cf823fa7d059f14c61e7a0646ec955faa0d9" translate="yes" xml:space="preserve">
          <source>The Perl Profiler</source>
          <target state="translated">Perl分析器</target>
        </trans-unit>
        <trans-unit id="b016030ffb60704d0c5d1297b6257d8c67a0ebea" translate="yes" xml:space="preserve">
          <source>The Perl Review, &lt;a href=&quot;http://www.theperlreview.com&quot;&gt;http://www.theperlreview.com&lt;/a&gt; maintains a website and Google calendar (&lt;a href=&quot;http://www.theperlreview.com/community_calendar&quot;&gt;http://www.theperlreview.com/community_calendar&lt;/a&gt;) for tracking workshops, hackathons, Perl Mongers meetings, and other events. Views of this calendar are at &lt;a href=&quot;http://www.perl.org/events.html&quot;&gt;http://www.perl.org/events.html&lt;/a&gt; and &lt;a href=&quot;http://www.yapc.org&quot;&gt;http://www.yapc.org&lt;/a&gt;.</source>
          <target state="translated">Perl的评论，&lt;a href=&quot;http://www.theperlreview.com&quot;&gt;http://www.theperlreview.com&lt;/a&gt;维持一个网站和谷歌日历（&lt;a href=&quot;http://www.theperlreview.com/community_calendar&quot;&gt;http://www.theperlreview.com/community_calendar&lt;/a&gt;跟踪车间，这种形式的比赛，Perl的贩子会议和其他活动）。该日历的视图位于&lt;a href=&quot;http://www.perl.org/events.html&quot;&gt;http://www.perl.org/events.html&lt;/a&gt;和&lt;a href=&quot;http://www.yapc.org&quot;&gt;http://www.yapc.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6955a584a390227f3bb9df6a8ce1cb0fe482186c" translate="yes" xml:space="preserve">
          <source>The Perl argument stack is used to store the values which are sent as parameters to the XSUB and to store the XSUB's return value(s). In reality all Perl functions (including non-XSUB ones) keep their values on this stack all the same time, each limited to its own range of positions on the stack. In this document the first position on that stack which belongs to the active function will be referred to as position 0 for that function.</source>
          <target state="translated">Perl参数栈用于存储作为XSUB参数发送的值和XSUB的返回值。实际上,所有的Perl函数(包括非XSUB的函数)都会在同一时间将它们的值保存在这个栈中,每个函数都被限制在栈中自己的位置范围内。在本文中,堆栈上属于活动函数的第一个位置将被称为该函数的0号位置。</target>
        </trans-unit>
        <trans-unit id="1afd605920f29e13092c6aa9a01dbc8ba4878de1" translate="yes" xml:space="preserve">
          <source>The Perl build system starts with the</source>
          <target state="translated">Perl构建系统从</target>
        </trans-unit>
        <trans-unit id="337328dc6570faaca13781601b8dac575ac43697" translate="yes" xml:space="preserve">
          <source>The Perl community has a rather large IRC presence. For starters, it has its own IRC network, &lt;a href=&quot;irc://irc.perl.org&quot;&gt;irc://irc.perl.org&lt;/a&gt;. General (not help-oriented) chat can be found at &lt;a href=&quot;irc://irc.perl.org/#perl&quot;&gt;irc://irc.perl.org/#perl&lt;/a&gt;. Many other more specific chats are also hosted on the network. Information about irc.perl.org is located on the network's website: &lt;a href=&quot;http://www.irc.perl.org&quot;&gt;http://www.irc.perl.org&lt;/a&gt;. For a more help-oriented #perl, check out &lt;a href=&quot;irc://irc.freenode.net/#perl&quot;&gt;irc://irc.freenode.net/#perl&lt;/a&gt;. Perl 6 development also has a presence in &lt;a href=&quot;irc://irc.freenode.net/#perl6&quot;&gt;irc://irc.freenode.net/#perl6&lt;/a&gt;. Most Perl-related channels will be kind enough to point you in the right direction if you ask nicely.</source>
          <target state="translated">Perl社区在IRC中占有相当大的份额。首先，它有自己的IRC网络&lt;a href=&quot;irc://irc.perl.org&quot;&gt;irc：//irc.perl.org&lt;/a&gt;。可在&lt;a href=&quot;irc://irc.perl.org/#perl&quot;&gt;irc：//irc.perl.org/#perl中&lt;/a&gt;找到常规（非面向帮助）聊天。网络上还托管了许多其他更具体的聊天记录。有关irc.perl.org的信息位于网络的网站上：&lt;a href=&quot;http://www.irc.perl.org&quot;&gt;http&lt;/a&gt; : //www.irc.perl.org。要获得更多面向帮助的#perl，请查看&lt;a href=&quot;irc://irc.freenode.net/#perl&quot;&gt;irc：//irc.freenode.net/#perl&lt;/a&gt;。 Perl 6开发也存在于&lt;a href=&quot;irc://irc.freenode.net/#perl6&quot;&gt;irc：//irc.freenode.net/#perl6中&lt;/a&gt;。如果您的要求很好，大多数与Perl相关的渠道将很友好，可以为您指明正确的方向。</target>
        </trans-unit>
        <trans-unit id="1e71a9470b64a2480ea7c8c2886a8ca9bc8c982c" translate="yes" xml:space="preserve">
          <source>The Perl community is as diverse as Perl, and there is a large amount of evidence that the Perl users apply TMTOWTDI to all endeavors, not just programming. From websites, to IRC, to mailing lists, there is more than one way to get involved in the community.</source>
          <target state="translated">Perl社区就像Perl一样多样化,有大量的证据表明,Perl用户将TMTOWTDI应用到所有的工作中,而不仅仅是编程。从网站,到IRC,再到邮件列表,参与社区的方式不止一种。</target>
        </trans-unit>
        <trans-unit id="75fca85980fcb62b1837d386b956468cb5d6629f" translate="yes" xml:space="preserve">
          <source>The Perl community is geared toward supporting the most recent releases, so you'll have an easier time finding help for those.</source>
          <target state="translated">Perl 社区的宗旨是支持最新的版本,所以你会更容易找到这些版本的帮助。</target>
        </trans-unit>
        <trans-unit id="660fe5fd6a64acb9219ffd0837bb1e282e990fa7" translate="yes" xml:space="preserve">
          <source>The Perl core has an extensive test suite. If you add new tests (or new modules with tests), you may need to update the</source>
          <target state="translated">Perl核心有一个广泛的测试套件。如果你添加了新的测试(或带有测试的新模块),你可能需要更新测试套件的</target>
        </trans-unit>
        <trans-unit id="8f13ce29b0232702f230a3b4d47d029f48d1ff8a" translate="yes" xml:space="preserve">
          <source>The Perl core uses a handful of keys in &lt;code&gt;%^H&lt;/code&gt; which do not follow this convention, because they predate it. Keys that follow the convention won't conflict with the core's historical keys.</source>
          <target state="translated">Perl内核在 &lt;code&gt;%^H&lt;/code&gt; 使用了少数几个不遵循该约定的键，因为它们早于它。遵循约定的密钥不会与核心的历史密钥冲突。</target>
        </trans-unit>
        <trans-unit id="40fdaea2f094775674cd40eee5e41200dd9b0a76" translate="yes" xml:space="preserve">
          <source>The Perl development team are called Perl 5 Porters, and their organization is described at &lt;a href=&quot;http://perldoc.perl.org/perlpolicy.html&quot;&gt;http://perldoc.perl.org/perlpolicy.html&lt;/a&gt;. The organizational rules really just boil down to one: Larry is always right, even when he was wrong.</source>
          <target state="translated">Perl开发团队称为Perl 5 Porters，其组织描述在&lt;a href=&quot;http://perldoc.perl.org/perlpolicy.html&quot;&gt;http://perldoc.perl.org/perlpolicy.html上&lt;/a&gt;。组织规则实际上可以归结为一个：Larry总是对的，即使他错了。</target>
        </trans-unit>
        <trans-unit id="85f7977946f345bcbaa5f5a8afb688bfb2d58512" translate="yes" xml:space="preserve">
          <source>The Perl development team occasionally make changes to the internal core of the language, but all possible efforts are made toward backward compatibility.</source>
          <target state="translated">Perl开发团队偶尔会对语言的内部核心进行修改,但会尽一切努力向后兼容。</target>
        </trans-unit>
        <trans-unit id="bef6ea773b29bc42d6bc39580b413ba88c9c2941" translate="yes" xml:space="preserve">
          <source>The Perl engine/interpreter and the host are orthogonal entities. There could be one or more interpreters in a process, and one or more &quot;hosts&quot;, with free association between them.</source>
          <target state="translated">Perl引擎/解释器和主机是正交的实体。一个进程中可以有一个或多个解释器,也可以有一个或多个 &quot;宿主&quot;,它们之间可以自由关联。</target>
        </trans-unit>
        <trans-unit id="be2ab355cd62828f3bbc09e8a520aa45842fe8c2" translate="yes" xml:space="preserve">
          <source>The Perl equivalent for this is &lt;code&gt;$#myarray&lt;/code&gt; .</source>
          <target state="translated">Perl的等效项是 &lt;code&gt;$#myarray&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bbb1426c72d3038d784b1de2b64c8aea8f60fd1" translate="yes" xml:space="preserve">
          <source>The Perl executables can be easily rebuilt at any moment. Moreover, one can use the</source>
          <target state="translated">Perl可执行文件可以在任何时候轻松重建。此外,人们还可以使用</target>
        </trans-unit>
        <trans-unit id="d136d03bdd5714dfcd154602e7c27ff31ede4518" translate="yes" xml:space="preserve">
          <source>The Perl forked debugger places the debugger commands and output in a separate X-11 terminal window so that commands and output from multiple processes are not mixed together.</source>
          <target state="translated">Perl分叉调试器将调试器命令和输出放在一个单独的X-11终端窗口中,这样就不会将多个进程的命令和输出混在一起。</target>
        </trans-unit>
        <trans-unit id="fa02d08b07357f1b109729d24eaf520757219ddc" translate="yes" xml:space="preserve">
          <source>The Perl functions for dealing with sockets have the same names as the corresponding system calls in C, but their arguments tend to differ for two reasons. First, Perl filehandles work differently than C file descriptors. Second, Perl already knows the length of its strings, so you don't need to pass that information.</source>
          <target state="translated">处理套接字的Perl函数与C语言中相应的系统调用具有相同的名称,但它们的参数往往不同,原因有二。首先,Perl文件柄的工作方式与C文件描述符不同。第二,Perl 已经知道其字符串的长度,所以你不需要传递这些信息。</target>
        </trans-unit>
        <trans-unit id="92147dd8f1d29e8ce474756b4726d9b1d8e42e16" translate="yes" xml:space="preserve">
          <source>The Perl interface was written by Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;, and is released under the artistic license. Further modifications were made by Greg Bacon &amp;lt;gbacon@cs.uah.edu&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, and Thomas Wegner &amp;lt;wegner_thomas@yahoo.com&amp;gt;. The C glob code has the following copyright:</source>
          <target state="translated">Perl接口是由Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;编写的，并已根据艺术许可发布。Greg Bacon &amp;lt;gbacon@cs.uah.edu&amp;gt;，Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;和Thomas Wegner &amp;lt;wegner_thomas@yahoo.com&amp;gt;进行了进一步的修改。C全局代码具有以下版权：</target>
        </trans-unit>
        <trans-unit id="99bc4ac3d59eed09e1d0f94b3a3f01535d2fc89d" translate="yes" xml:space="preserve">
          <source>The Perl interpreter can be regarded as a closed box: it has an API for feeding it code or otherwise making it do things, but it also has functions for its own use. This smells a lot like an object, and there are ways for you to build Perl so that you can have multiple interpreters, with one interpreter represented either as a C structure, or inside a thread-specific structure. These structures contain all the context, the state of that interpreter.</source>
          <target state="translated">Perl解释器可以被看作是一个封闭的盒子:它有一个API,可以给它输入代码或者以其他方式让它做一些事情,但是它也有自己使用的函数。这闻起来很像一个对象,你有办法构建Perl,使你可以拥有多个解释器,一个解释器可以用一个C结构来表示,或者在一个线程专用结构里面。这些结构包含了所有的上下文,该解释器的状态。</target>
        </trans-unit>
        <trans-unit id="4ec97d45bb2f6ea56e5a238f738362154db298f5" translate="yes" xml:space="preserve">
          <source>The Perl logo is a trademark of the Perl Foundation.</source>
          <target state="translated">Perl标志是Perl基金会的商标。</target>
        </trans-unit>
        <trans-unit id="6b8a4b8bd5fc4d36250e80003bd49d95bed77a10" translate="yes" xml:space="preserve">
          <source>The Perl model for function call and return values is simple: all functions are passed as parameters one single flat list of scalars, and all functions likewise return to their caller one single flat list of scalars. Any arrays or hashes in these call and return lists will collapse, losing their identities--but you may always use pass-by-reference instead to avoid this. Both call and return lists may contain as many or as few scalar elements as you'd like. (Often a function without an explicit return statement is called a subroutine, but there's really no difference from Perl's perspective.)</source>
          <target state="translated">函数调用和返回值的Perl模型很简单:所有的函数都会被传递一个标量的平坦列表作为参数,而所有的函数同样也会返回一个标量的平坦列表给调用者。在这些调用和返回列表中的任何数组或散列都会崩溃,失去它们的身份--但你可以总是使用逐条引用来避免这种情况。调用和返回列表中可以包含任意数量的标量元素。(通常一个没有明确返回语句的函数被称为子程序,但从 Perl 的角度来看,其实没有什么区别。)</target>
        </trans-unit>
        <trans-unit id="b9ee0cf4ab63cf1be081346d4784ae92aedc21e4" translate="yes" xml:space="preserve">
          <source>The Perl motto is &quot;There's more than one way to do it.&quot; Divining how many more is left as an exercise to the reader.</source>
          <target state="translated">Perl的座右铭是 &quot;有不止一种方法可以做&quot;。&quot;至于还有多少种方法,那就留给读者去研究了。</target>
        </trans-unit>
        <trans-unit id="b25f4bf878cf14a357970d887adcbf624e87e118" translate="yes" xml:space="preserve">
          <source>The Perl parser will expand $variable and @variable references in regular expressions unless the delimiter is a single quote. Remember, too, that the right-hand side of a &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; substitution is considered a double-quoted string (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details). Remember also that any regex special characters will be acted on unless you precede the substitution with \Q. Here's an example:</source>
          <target state="translated">除非定界符是单引号，否则Perl解析器将在正则表达式中扩展$ variable和@variable引用。&lt;a href=&quot;perlop&quot;&gt;还要&lt;/a&gt;记住，将 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 替换的右侧视为双引号字符串（有关更多详细信息，请参见perlop）。还要记住，除非使用\ Q替换，否则任何正则表达式特殊字符都将起作用。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="0bc52b1056fd349e5d759d3b05d91376e2d9a16e" translate="yes" xml:space="preserve">
          <source>The Perl port has been done for the most part using the Symbian standard POSIX-ish STDLIB library. It is a reasonably complete library, but certain corners of such emulation libraries that tend to be left unimplemented on non-UNIX platforms have been left unimplemented also this time: fork(), signals(), user/group ids, select() working for sockets, non-blocking sockets, and so forth. See the file</source>
          <target state="translated">移植Perl的过程中,大部分使用了Symbian标准的POSIX-like STDLIB库。这是一个相当完整的库,但这类仿真库的某些角落,在非UNIX平台上往往没有实现,这次也没有实现:fork()、signal()、用户/组id、select()工作的socket、非阻塞socket等等。参见文件</target>
        </trans-unit>
        <trans-unit id="b67868d8a32ed03bc87b830fb6a6b1a5f3f79a34" translate="yes" xml:space="preserve">
          <source>The Perl regular expression &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs give access to most of the Unicode character properties. The table below shows all these constructs, both single and compound forms.</source>
          <target state="translated">Perl正则表达式 &lt;code&gt;\p{}&lt;/code&gt; 和 &lt;code&gt;\P{}&lt;/code&gt; 构造可访问大多数Unicode字符属性。下表显示了所有这些构建体，包括单一形式和复合形式。</target>
        </trans-unit>
        <trans-unit id="f0e8425fc37fe67a70d8b01bf266a53e0f530848" translate="yes" xml:space="preserve">
          <source>The Perl source tree is big. Here's some of the thing you'll find in it:</source>
          <target state="translated">Perl的源代码树很大。下面是一些你会在其中找到的东西。</target>
        </trans-unit>
        <trans-unit id="6a0d4acb6c550a60d6a38a5a63678cce3e904bee" translate="yes" xml:space="preserve">
          <source>The Perl subroutine,</source>
          <target state="translated">Perl的子程序。</target>
        </trans-unit>
        <trans-unit id="df3a691d5cbb91293ddf18af01bb5af5f01bbb73" translate="yes" xml:space="preserve">
          <source>The Perl syntax error message from the last &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; operator. If &lt;code&gt;$@&lt;/code&gt; is the null string, the last &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; parsed and executed correctly (although the operations you invoked may have failed in the normal fashion).</source>
          <target state="translated">来自最后一个 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 运算符的Perl语法错误消息。如果 &lt;code&gt;$@&lt;/code&gt; 是空字符串，则最后一个 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 会正确解析并执行（尽管您调用的操作可能以常规方式失败了）。</target>
        </trans-unit>
        <trans-unit id="968a791625fe0d4ef7287cb8aaab8e329d603dbe" translate="yes" xml:space="preserve">
          <source>The Perl test suite may still report some errors on the Hurd. The &quot;lib/anydbm&quot; and &quot;pragma/warnings&quot; tests will almost certainly fail. Both failures are not really specific to the Hurd, as indicated by the test suite output.</source>
          <target state="translated">Perl 测试套件可能仍然会在 Hurd 上报告一些错误,&quot;lib/anydbm &quot;和 &quot;pragma/warnings &quot;测试几乎肯定会失败。lib/anydbm&quot; 和 &quot;pragma/warnings&quot; 测试几乎肯定会失败。正如测试套件的输出所显示的那样,这两个失败其实并不是Hurd所特有的。</target>
        </trans-unit>
        <trans-unit id="f6abf53e543be5d8676f05668af9e144a63af4c4" translate="yes" xml:space="preserve">
          <source>The Perl variables that are available for interpolation into typemaps are the following:</source>
          <target state="translated">可用于插值成类型图的Perl变量如下。</target>
        </trans-unit>
        <trans-unit id="6bcd8c322dd20c222b91b35688318973e6596a5a" translate="yes" xml:space="preserve">
          <source>The Perl warning &quot;Wide character in ...&quot; is caused by such a character. With no specified encoding layer, Perl tries to fit things into a single byte. When it can't, it emits this warning (if warnings are enabled), and uses UTF-8 encoded data instead.</source>
          <target state="translated">Perl警告 &quot;Wide character in ...&quot;就是由这样一个字符引起的。在没有指定编码层的情况下,Perl 试图把东西装进一个字节中。当它做不到时,就会发出这个警告(如果启用了警告),并使用UTF-8编码的数据来代替。</target>
        </trans-unit>
        <trans-unit id="4d7feb5052b0fb54136f812ed2c2ffa2175dab42" translate="yes" xml:space="preserve">
          <source>The Perl-QA list attempted to ensure backwards compatibility with &lt;a href=&quot;../test/harness&quot;&gt;Test::Harness&lt;/a&gt;. However, there are some minor differences.</source>
          <target state="translated">Perl-QA列表试图确保与&lt;a href=&quot;../test/harness&quot;&gt;Test :: Harness的&lt;/a&gt;向后兼容性。但是，有一些细微的差异。</target>
        </trans-unit>
        <trans-unit id="a9ec1c232da33c6ab26241322f9069a9704be0af" translate="yes" xml:space="preserve">
          <source>The PerlApp also is started when the &quot;Perl recognizer&quot; (also included and installed) detects a Perl file being activated through the GUI, and offers either to install it under \Perl (if the Perl file is in the inbox of the messaging application) or to run it (if the Perl file is under \Perl).</source>
          <target state="translated">当 &quot;Perl识别器&quot;(也包含并安装了)检测到一个Perl文件通过GUI被激活时,PerlApp也会被启动,并提供在\Perl下安装它(如果Perl文件在消息应用程序的收件箱中)或运行它(如果Perl文件在\Perl下)。</target>
        </trans-unit>
        <trans-unit id="c6111a686e0ef0ac50573a59b08dc1b8aeb3287a" translate="yes" xml:space="preserve">
          <source>The PerlApp application demonstrates how to embed Perl interpreters to a Symbian application. The &quot;Time&quot; menu item runs the following Perl code: &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &quot;Running in &quot;, $^O, &quot;\n&quot;, &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; , the &quot;Oneliner&quot; allows one to type in Perl code, and the &quot;Run&quot; opens a file chooser for selecting a Perl file to run.</source>
          <target state="translated">PerlApp应用程序演示了如何将Perl解释器嵌入到Symbian应用程序中。 &amp;ldquo;时间&amp;rdquo;菜单项，运行以下Perl代码： &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &quot;Running in &quot;, $^O, &quot;\n&quot;, &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; ，在&amp;ldquo;Oneliner&amp;rdquo;允许一个在Perl代码类型，&amp;ldquo;运行&amp;rdquo;打开文件选择器，用于选择要运行的Perl文件。</target>
        </trans-unit>
        <trans-unit id="b43fd89b2979a98b7d902f7d0334218ba2ca529e" translate="yes" xml:space="preserve">
          <source>The PerlIO abstraction was introduced in perl5.003_02 but languished as just an abstraction until perl5.7.0. However during that time a number of perl extensions switched to using it, so the API is mostly fixed to maintain (source) compatibility.</source>
          <target state="translated">PerlIO抽象是在perl5.003_02中引入的,但在perl5.7.0之前,它一直作为一个抽象概念存在。然而在那段时间里,许多perl扩展都改用了它,所以API主要是为了保持(源代码)的兼容性而固定下来的。</target>
        </trans-unit>
        <trans-unit id="43641046aefdabfa554afe6cf89fa8594b9147ac" translate="yes" xml:space="preserve">
          <source>The PerlIO is set to textmode. Use PerlIO_binmode if this is not the desired mode.</source>
          <target state="translated">PerlIO被设置为textmode。如果不是需要的模式,请使用PerlIO_binmode。</target>
        </trans-unit>
        <trans-unit id="df2a9946f78c97c4cb0379505dfaf42cfc784763" translate="yes" xml:space="preserve">
          <source>The PerlIO::via module allows you to develop PerlIO layers in Perl, without having to go into the nitty gritty of programming C with XS as the interface to Perl.</source>
          <target state="translated">PerlIO::via模块允许你在Perl中开发PerlIO层,而不需要用XS作为Perl的接口,进入C语言编程的细节。</target>
        </trans-unit>
        <trans-unit id="69b9d42402dbac92bb5f313095f98e57d920e008" translate="yes" xml:space="preserve">
          <source>The Pod format is not necessarily sufficient for writing a book. Pod is just meant to be an idiot-proof common source for nroff, HTML, TeX, and other markup languages, as used for online documentation. Translators exist for &lt;b&gt;pod2text&lt;/b&gt;, &lt;b&gt;pod2html&lt;/b&gt;, &lt;b&gt;pod2man&lt;/b&gt; (that's for nroff(1) and troff(1)), &lt;b&gt;pod2latex&lt;/b&gt;, and &lt;b&gt;pod2fm&lt;/b&gt;. Various others are available in CPAN.</source>
          <target state="translated">Pod格式不一定足以写书。 Pod只是要成为nroff，HTML，TeX和其他标记语言的防白痴通用资源，用于在线文档。存在针对&lt;b&gt;pod2text&lt;/b&gt;，&lt;b&gt;pod2html&lt;/b&gt;，&lt;b&gt;pod2man&lt;/b&gt;（用于nroff（1）和troff（1）），&lt;b&gt;pod2latex&lt;/b&gt;和&lt;b&gt;pod2fm的翻译器&lt;/b&gt;。 CPAN中提供了其他各种选项。</target>
        </trans-unit>
        <trans-unit id="5181d340ea28e7004e1fc926376f0269c6a7af0c" translate="yes" xml:space="preserve">
          <source>The Pod parser normally expects to read octets and to convert those octets to characters based on the &lt;code&gt;=encoding&lt;/code&gt; declaration in the Pod source. Set this option to a true value to indicate that the Pod source is already a Perl character stream. This tells the parser to ignore any &lt;code&gt;=encoding&lt;/code&gt; command and to skip all the code paths involving decoding octets.</source>
          <target state="translated">Pod解析器通常希望读取八位字节，并根据Pod源中的 &lt;code&gt;=encoding&lt;/code&gt; 声明将这些八位字节转换为字符。将此选项设置为true值表示Pod源已经是Perl字符流。这告诉解析器忽略任何 &lt;code&gt;=encoding&lt;/code&gt; 命令，并跳过涉及解码八位位组的所有代码路径。</target>
        </trans-unit>
        <trans-unit id="d54e40195036f1a1a1b5551f96370345ff64638a" translate="yes" xml:space="preserve">
          <source>The Pod::Simple parser expects to read &lt;b&gt;octets&lt;/b&gt;. The parser will decode the octets into Perl's internal character string representation using the value of the &lt;code&gt;=encoding&lt;/code&gt; declaration in the POD source.</source>
          <target state="translated">Pod :: Simple解析器希望读取&lt;b&gt;八位字节&lt;/b&gt;。解析器将使用POD源中 &lt;code&gt;=encoding&lt;/code&gt; 声明的值将八位字节解码为Perl的内部字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="a52e0eb3298b4fa461fa923215cc1e681ac40256" translate="yes" xml:space="preserve">
          <source>The Pod::Usage distribution comes with a script pod2usage which offers a command line interface to the functionality of Pod::Usage. See &lt;a href=&quot;../pod2usage&quot;&gt;pod2usage&lt;/a&gt;.</source>
          <target state="translated">Pod :: Usage分发带有脚本pod2usage，该脚本提供了一个命令行界面，可用于Pod :: Usage的功能。参见&lt;a href=&quot;../pod2usage&quot;&gt;pod2usage&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27cf4d4fc397867d0e2a99e5b7bffdeae843c96c" translate="yes" xml:space="preserve">
          <source>The Portable Operating System Interface specification.</source>
          <target state="translated">便携式操作系统接口规范。</target>
        </trans-unit>
        <trans-unit id="355c15d3884285cbe9de6e8c0623457a61fdc6ca" translate="yes" xml:space="preserve">
          <source>The Problem</source>
          <target state="translated">问题</target>
        </trans-unit>
        <trans-unit id="cca8ca027231a86237a6c4dda51f169cc4d16c32" translate="yes" xml:space="preserve">
          <source>The Pugs prototype Perl 6 Object Model uses C3</source>
          <target state="translated">Pugs原型Perl 6对象模型使用C3</target>
        </trans-unit>
        <trans-unit id="77d5d72ac418e20fd29b7eec3b6c8de1afc54920" translate="yes" xml:space="preserve">
          <source>The REGEXP struct is defined in</source>
          <target state="translated">REGEXP结构定义在</target>
        </trans-unit>
        <trans-unit id="2ad89d37eadf28843f6bcc04fe292798559736be" translate="yes" xml:space="preserve">
          <source>The REGEXP structure</source>
          <target state="translated">REGEXP结构</target>
        </trans-unit>
        <trans-unit id="8da65302c118d1898dddaf19bb76877bb8166258" translate="yes" xml:space="preserve">
          <source>The REGEXP structure contains all the data that Perl needs to be aware of to properly work with the regular expression. It includes data about optimisations that Perl can use to determine if the regex engine should really be used, and various other control info that is needed to properly execute patterns in various contexts, such as if the pattern anchored in some way, or what flags were used during the compile, or if the program contains special constructs that Perl needs to be aware of.</source>
          <target state="translated">REGEXP结构包含了Perl正确使用正则表达式所需要了解的所有数据。它包含了Perl可以用来确定是否真的应该使用regex引擎的优化数据,以及在各种情况下正确执行模式所需要的其他各种控制信息,例如模式是否以某种方式锚定,或者在编译过程中使用了什么标志,或者程序是否包含Perl需要注意的特殊结构。</target>
        </trans-unit>
        <trans-unit id="1d6f38948819f825c1778442bfb0bf54fd236038" translate="yes" xml:space="preserve">
          <source>The REQUIRE: Keyword</source>
          <target state="translated">REQUIRE:关键字</target>
        </trans-unit>
        <trans-unit id="eb7911fb319180325559ab93300e4a8e754d4918" translate="yes" xml:space="preserve">
          <source>The REQUIRE: keyword is used to indicate the minimum version of the &lt;b&gt;xsubpp&lt;/b&gt; compiler needed to compile the XS module. An XS module which contains the following statement will compile with only &lt;b&gt;xsubpp&lt;/b&gt; version 1.922 or greater:</source>
          <target state="translated">REQUIRE：关键字用于指示编译XS模块所需的&lt;b&gt;xsubpp&lt;/b&gt;编译器的最低版本。包含以下语句的XS模块将仅使用&lt;b&gt;xsubpp&lt;/b&gt;版本1.922或更高版本进行编译：</target>
        </trans-unit>
        <trans-unit id="325d9dc6bcb33887233fc6bb3fee83c1db779aa6" translate="yes" xml:space="preserve">
          <source>The RETVAL Variable</source>
          <target state="translated">RETVAL变量</target>
        </trans-unit>
        <trans-unit id="2c001438878b5f3376fc8700b6556da0eb7ce7c1" translate="yes" xml:space="preserve">
          <source>The RETVAL variable is a special C variable that is declared automatically for you. The C type of RETVAL matches the return type of the C library function. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will declare this variable in each XSUB with non-&lt;code&gt;void&lt;/code&gt; return type. By default the generated C function will use RETVAL to hold the return value of the C library function being called. In simple cases the value of RETVAL will be placed in ST(0) of the argument stack where it can be received by Perl as the return value of the XSUB.</source>
          <target state="translated">RETVAL变量是一个特殊的C变量，它会自动为您声明。RETVAL的C类型与C库函数的返回类型匹配。该&lt;b&gt;xsubpp&lt;/b&gt;编译器将与非每个XSUB声明这个变量 &lt;code&gt;void&lt;/code&gt; 返回类型。默认情况下，生成的C函数将使用RETVAL来保存正在调用的C库函数的返回值。在简单的情况下，RETVAL的值将放置在参数堆栈的ST（0）中，Perl可以将其作为XSUB的返回值接收。</target>
        </trans-unit>
        <trans-unit id="b5719fca838ea2f703064b736671d8a5c53c2b7c" translate="yes" xml:space="preserve">
          <source>The Ram is a cookbook with hundreds of examples of using Perl to accomplish specific tasks:</source>
          <target state="translated">Ram是一本包含数百个使用Perl来完成特定任务的例子的烹饪书。</target>
        </trans-unit>
        <trans-unit id="bda5eb8009d503d3f7d7ac84a0313722c46a6dc4" translate="yes" xml:space="preserve">
          <source>The Rest</source>
          <target state="translated">其余</target>
        </trans-unit>
        <trans-unit id="c06052540c4d2319036f128e767c17cbef7e664e" translate="yes" xml:space="preserve">
          <source>The Role of the typemap File in Your Distribution</source>
          <target state="translated">typemap文件在您的发行中的作用。</target>
        </trans-unit>
        <trans-unit id="5afe900033efd0b8bef5b765a85f46485e313663" translate="yes" xml:space="preserve">
          <source>The SCOPE: Keyword</source>
          <target state="translated">SCOPE。关键字</target>
        </trans-unit>
        <trans-unit id="3f77c1166b9eee5ec219ef962a60436e0a2f2130" translate="yes" xml:space="preserve">
          <source>The SCOPE: keyword allows scoping to be enabled for a particular XSUB. If enabled, the XSUB will invoke ENTER and LEAVE automatically.</source>
          <target state="translated">SCOPE:关键字允许对特定XSUB启用范围。如果启用,XSUB将自动调用ENTER和LEAVE。</target>
        </trans-unit>
        <trans-unit id="3f3c8dbe377ba2fb462f83142477acc2c9fed9b5" translate="yes" xml:space="preserve">
          <source>The SEEK_* constants can be imported from the &lt;code&gt;Fcntl&lt;/code&gt; module if you don't wish to use the numbers &lt;code&gt;0&lt;/code&gt;&lt;code&gt;1&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt; in your code.</source>
          <target state="translated">如果您不希望在代码中使用数字 &lt;code&gt;0&lt;/code&gt; &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;2&lt;/code&gt; ，则可以从 &lt;code&gt;Fcntl&lt;/code&gt; 模块导入SEEK_ *常量。</target>
        </trans-unit>
        <trans-unit id="6874e0e71dff8b677770e211cb23f7a0bc03af61" translate="yes" xml:space="preserve">
          <source>The STDIN filehandle used by the command is inherited from Perl's STDIN. For example:</source>
          <target state="translated">命令使用的STDIN文件柄是继承自Perl的STDIN。例如</target>
        </trans-unit>
        <trans-unit id="c9698c556df2cef5c4ee4e944157366d894bd711" translate="yes" xml:space="preserve">
          <source>The SV arena serves the secondary purpose of allowing still-live SVs to be located and destroyed during final cleanup.</source>
          <target state="translated">SV竞技场的次要目的是允许在最后清理过程中找到并销毁仍然活着的SV。</target>
        </trans-unit>
        <trans-unit id="82e45de5e22cb3332054cbfb0b3a963e2aa8939b" translate="yes" xml:space="preserve">
          <source>The SV returned has a refcount of 1.</source>
          <target state="translated">返回的SV的refcount为1。</target>
        </trans-unit>
        <trans-unit id="3397a37f03fe6e25c10e0df218712221b41b076a" translate="yes" xml:space="preserve">
          <source>The SV* corresponding to the $_ variable. Works even if there is a lexical $_ in scope.</source>
          <target state="translated">对应$_变量的SV*。即使在范围内有一个词法$_,也可以使用。</target>
        </trans-unit>
        <trans-unit id="166ec7ce6ae952f37ed9ee7074b722386bfc06c5" translate="yes" xml:space="preserve">
          <source>The SYS:/temp is preferred in Novell NetWare and the C:\system\temp for Symbian (the File::Spec::Win32 is used also for those platforms).</source>
          <target state="translated">在Novell NetWare中使用SYS:/temp,在Symbian中使用C:/system/temp(这些平台也使用File::Spec::Win32)。</target>
        </trans-unit>
        <trans-unit id="c305a702522737f58ad2f086c3a8baae101bf7fa" translate="yes" xml:space="preserve">
          <source>The Safe extension module allows the creation of compartments in which perl code can be evaluated. Each compartment has</source>
          <target state="translated">安全扩展模块允许创建可以评估perl代码的隔间。每个隔间有</target>
        </trans-unit>
        <trans-unit id="f3ebdf6626009aca2f7b1117ac99eeb3a50e8a0f" translate="yes" xml:space="preserve">
          <source>The Second Rule of Sys::Syslog is:</source>
          <target state="translated">Sys::Syslog的第二条规则是。</target>
        </trans-unit>
        <trans-unit id="59ce582565e3aa2e433ddd5ed3ee6bdecbd67e3d" translate="yes" xml:space="preserve">
          <source>The Secure Hash Standard (Draft FIPS PUB 180-4) can be found at:</source>
          <target state="translated">安全散列标准(FIPS PUB 180-4草案)可在以下网址找到:</target>
        </trans-unit>
        <trans-unit id="a0cf9a0044474cf0b7a47510d7ab73b298c8894f" translate="yes" xml:space="preserve">
          <source>The SelfLoader can load stubs automatically at module initialization with the statement 'SelfLoader-&amp;gt;load_stubs()';, but you may wish to avoid having the stub loading overhead associated with your initialization (though note that the SelfLoader::load_stubs method will be called sooner or later - at latest when the first sub is being autoloaded). In this case, you can put the sub stubs before the __DATA__ token. This can be done manually, but this module allows automatic generation of the stubs.</source>
          <target state="translated">SelfLoader可以使用语句'SelfLoader-&amp;gt; load_stubs（）';在模块初始化时自动加载存根，但是您可能希望避免与初始化相关的存根加载开销（尽管请注意，将调用SelfLoader :: load_stubs方法）迟早-最晚在第一个子程序被自动加载时）。在这种情况下，可以将子存根放在__DATA__令牌之前。这可以手动完成，但是此模块允许自动生成存根。</target>
        </trans-unit>
        <trans-unit id="c273113828f1c56d85466a94fe42bd54d051b33a" translate="yes" xml:space="preserve">
          <source>The Seventh Rule of Sys::Syslog is:</source>
          <target state="translated">Sys::Syslog的第七条规则是。</target>
        </trans-unit>
        <trans-unit id="48b5fdd7473bc512821401bfc6bdb55846607392" translate="yes" xml:space="preserve">
          <source>The Silmarillion</source>
          <target state="translated">西尔玛利特</target>
        </trans-unit>
        <trans-unit id="3d872a2e6f315517170676af6926b6bd336f2e79" translate="yes" xml:space="preserve">
          <source>The Sixth Rule of Sys::Syslog is:</source>
          <target state="translated">Sys::Syslog的第六条规则是。</target>
        </trans-unit>
        <trans-unit id="2615af73b1e9a8107739890b278d6bb8e8c58b89" translate="yes" xml:space="preserve">
          <source>The Socket library makes this slightly easier:</source>
          <target state="translated">Socket库让这一切变得稍微简单。</target>
        </trans-unit>
        <trans-unit id="0346baceabdf020f1948aaad1950b71c29c8313d" translate="yes" xml:space="preserve">
          <source>The Solaris FAQ is available at &lt;a href=&quot;http://www.science.uva.nl/pub/solaris/solaris2.html&quot;&gt;http://www.science.uva.nl/pub/solaris/solaris2.html&lt;/a&gt;.</source>
          <target state="translated">有关Solaris常见问题的信息，&lt;a href=&quot;http://www.science.uva.nl/pub/solaris/solaris2.html&quot;&gt;请&lt;/a&gt;访问http://www.science.uva.nl/pub/solaris/solaris2.html。</target>
        </trans-unit>
        <trans-unit id="c6524b148594d89baefb15f79bab2c7c15e79227" translate="yes" xml:space="preserve">
          <source>The Solution</source>
          <target state="translated">解决方案</target>
        </trans-unit>
        <trans-unit id="f8bdb1b7f6851c01f4e6dd6b9335a25cbb9f32fe" translate="yes" xml:space="preserve">
          <source>The Source Filters distribution is available on CPAN, in</source>
          <target state="translated">源过滤器发行版可在CPAN上获得,网址是</target>
        </trans-unit>
        <trans-unit id="c95deb069230cbfe43ae345e5dcb1b877dd184d4" translate="yes" xml:space="preserve">
          <source>The Storable engine can also store data into a Perl scalar instead, to later retrieve them. This is mainly used to freeze a complex structure in some safe compact memory place (where it can possibly be sent to another process via some IPC, since freezing the structure also serializes it in effect). Later on, and maybe somewhere else, you can thaw the Perl scalar out and recreate the original complex structure in memory.</source>
          <target state="translated">Storable引擎也可以将数据存储到一个Perl标量中,以便以后检索。这主要是用来将一个复杂的结构冻结在某个安全紧凑的内存地方(在那里,它有可能通过一些 IPC 发送给另一个进程,因为冻结结构实际上也是将其序列化)。以后,也许在其他地方,你可以将Perl标量解冻,在内存中重新创建原来的复杂结构。</target>
        </trans-unit>
        <trans-unit id="b46a98161104ffbf830836edabb2204067559b45" translate="yes" xml:space="preserve">
          <source>The Storable package brings persistence to your Perl data structures containing SCALAR, ARRAY, HASH or REF objects, i.e. anything that can be conveniently stored to disk and retrieved at a later time.</source>
          <target state="translated">Storable包为你的Perl数据结构带来了持久性,这些数据结构包含SCALAR、ARRAY、HASH或REF对象,也就是说,任何可以方便地存储到磁盘上并在以后检索的东西。</target>
        </trans-unit>
        <trans-unit id="1c31479831ac23c24002214051aef3521fbb967b" translate="yes" xml:space="preserve">
          <source>The Sun Managers' FAQ is available at &lt;a href=&quot;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&quot;&gt;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&lt;/a&gt;</source>
          <target state="translated">可在&lt;a href=&quot;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&quot;&gt;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&lt;/a&gt;上找到《 Sun Managers FAQ》。</target>
        </trans-unit>
        <trans-unit id="6e4005ffb38cdcce66cf2552b3af0aed0d38d327" translate="yes" xml:space="preserve">
          <source>The Symbian port is licensed under the same terms as Perl itself.</source>
          <target state="translated">Symbian 移植版的授权条款与 Perl 本身相同。</target>
        </trans-unit>
        <trans-unit id="2d3f94b6eeafe888e9cb15f1090b03b3cc5b3e69" translate="yes" xml:space="preserve">
          <source>The Syntax of Variable Names</source>
          <target state="translated">变量名称的语法</target>
        </trans-unit>
        <trans-unit id="0dcb2ce1d39ebcd7787f9ace607f3511d6d60bc4" translate="yes" xml:space="preserve">
          <source>The SysV IPC code above was written long ago, and it's definitely clunky looking. For a more modern look, see the IPC::SysV module.</source>
          <target state="translated">上面的SysV IPC代码是很久以前写的,看起来肯定很笨拙。如果想了解更现代的外观,请看IPC::SysV模块。</target>
        </trans-unit>
        <trans-unit id="81ef1999f4ab1d77c16c0134c1c911b0b6e377cd" translate="yes" xml:space="preserve">
          <source>The TEMPLATE has the same format as in the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function. Here's a subroutine that does substring:</source>
          <target state="translated">模板具有与 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 功能相同的格式。这是一个执行子字符串的子例程：</target>
        </trans-unit>
        <trans-unit id="14ab3be603ef17e174d5422d8fa9db4cbcd8a394" translate="yes" xml:space="preserve">
          <source>The TEMPLATE has the same format as in the &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function. Here's a subroutine that does substring:</source>
          <target state="translated">模板具有与 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 功能相同的格式。这是一个执行子字符串的子例程：</target>
        </trans-unit>
        <trans-unit id="c84fad0e6672900e0ccb385df9c5a53aa073119f" translate="yes" xml:space="preserve">
          <source>The TEMPLATE is a sequence of characters that give the order and type of values, as follows:</source>
          <target state="translated">TEMPLATE是一个字符序列,它给出了值的顺序和类型,如下所示。</target>
        </trans-unit>
        <trans-unit id="aa18d821da8b238046aafed6e970f790f7308b97" translate="yes" xml:space="preserve">
          <source>The TTY to use for debugging I/O.</source>
          <target state="translated">用于调试I/O的TTY。</target>
        </trans-unit>
        <trans-unit id="28ac83583a93c3bbe04e5be7ac1ae0bf8d97eb60" translate="yes" xml:space="preserve">
          <source>The TYPEMAP file</source>
          <target state="translated">TYPEMAP文件</target>
        </trans-unit>
        <trans-unit id="10a06ea76a05d039fe9de3770c4f7ea4ca5db2f3" translate="yes" xml:space="preserve">
          <source>The TYPEMAP: Keyword</source>
          <target state="translated">TYPEMAP。关键字</target>
        </trans-unit>
        <trans-unit id="a995c45f782f6eac7b2e49619c36fb98f70351d5" translate="yes" xml:space="preserve">
          <source>The T_SYSRET typemap is used to process return values from system calls. It is only meaningful when passing values from C to perl (there is no concept of passing a system return value from Perl to C).</source>
          <target state="translated">T_SYSRET类型映射用于处理系统调用的返回值。它只有在从C向perl传递值时才有意义(没有从Perl向C传递系统返回值的概念)。</target>
        </trans-unit>
        <trans-unit id="c00d492559cf23114ccf6a4416bb2a3622dd118a" translate="yes" xml:space="preserve">
          <source>The Tale of the Children of Hurin</source>
          <target state="translated">胡林的孩子们的故事</target>
        </trans-unit>
        <trans-unit id="dc20618b36ece0cca578d0aaf6a793d399b51768" translate="yes" xml:space="preserve">
          <source>The Tamil digits (U+0BE6 - U+0BEF) can also legally be used in old-style Tamil numbers in which they would appear no more than one in a row, separated by characters that mean &quot;times 10&quot;, &quot;times 100&quot;, etc. (See &lt;a href=&quot;http://www.unicode.org/notes/tn21&quot;&gt;http://www.unicode.org/notes/tn21&lt;/a&gt;.)</source>
          <target state="translated">泰米尔语数字（U + 0BE6-U + 0BEF）也可以合法地用于老式泰米尔语数字，其中它们连续出现的次数不得超过一个，并用表示&amp;ldquo;乘以10&amp;rdquo;，&amp;ldquo;乘以100&amp;rdquo;的字符分隔等（请参阅&lt;a href=&quot;http://www.unicode.org/notes/tn21&quot;&gt;http://www.unicode.org/notes/tn21）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47ba114bf39e8b27a93263e54d8b1d42bd44b898" translate="yes" xml:space="preserve">
          <source>The Term::ReadKey module from CPAN may be easier to use. Recent versions include also support for non-portable systems as well.</source>
          <target state="translated">CPAN的Term::ReadKey模块可能更容易使用。最近的版本还包括对非便携式系统的支持。</target>
        </trans-unit>
        <trans-unit id="35a1f7393254a3b1337f16135889cbf5d4ddbd76" translate="yes" xml:space="preserve">
          <source>The Third Rule of Sys::Syslog is:</source>
          <target state="translated">Sys::Syslog的第三条规则是。</target>
        </trans-unit>
        <trans-unit id="93fb358185964087944f1d6c1078da04b430b4f0" translate="yes" xml:space="preserve">
          <source>The Tree subsubsection in XML::Parser</source>
          <target state="translated">XML::Parser中的Tree子节</target>
        </trans-unit>
        <trans-unit id="8dd1d72b0140a01ec4804e7eb5bb38229499e0d2" translate="yes" xml:space="preserve">
          <source>The U/WIN environment for Win32, &lt;a href=&quot;http://www.research.att.com/sw/tools/uwin/&quot;&gt;http://www.research.att.com/sw/tools/uwin/&lt;/a&gt;</source>
          <target state="translated">Win32的U / WIN环境，&lt;a href=&quot;http://www.research.att.com/sw/tools/uwin/&quot;&gt;http：//www.research.att.com/sw/tools/uwin/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="769648b0d99f3965f04ad4c0ff49f028dec18b56" translate="yes" xml:space="preserve">
          <source>The UNICODE_WARN_NONCHAR and UNICODE_DISALLOW_NONCHAR flags affect how the function handles a Unicode non-character. And likewise, the UNICODE_WARN_SUPER and UNICODE_DISALLOW_SUPER flags affect the handling of code points that are above the Unicode maximum of 0x10FFFF. Code points above 0x7FFF_FFFF (which are even less portable) can be warned and/or disallowed even if other above-Unicode code points are accepted, by the UNICODE_WARN_FE_FF and UNICODE_DISALLOW_FE_FF flags.</source>
          <target state="translated">UNICODE_WARN_NONCHAR和UNICODE_DISALLOW_NONCHAR标志会影响函数如何处理Unicode非字符。同样,UNICODE_WARN_SUPER和UNICODE_DISALLOW_SUPER标志也会影响对高于Unicode最大0x10FFFF的代码点的处理。超过0x7FFF_FFFF的代码点(可移植性更差)可以通过UNICODE_WARN_FE_FF和UNICODE_DISALLOW_FE_FF标志被警告和/或禁止,即使其他高于Unicode的代码点被接受。</target>
        </trans-unit>
        <trans-unit id="b1a9962a264046baa6e654280499186de4c8dcb8" translate="yes" xml:space="preserve">
          <source>The UNIVERSAL Class</source>
          <target state="translated">通用类</target>
        </trans-unit>
        <trans-unit id="626ffdf925f7f1a1535b1e7a24ab5f1836995ec2" translate="yes" xml:space="preserve">
          <source>The URL or relative path of a CSS file to include. This option is not set by default.</source>
          <target state="translated">要包含的CSS文件的URL或相对路径。默认情况下,这个选项没有设置。</target>
        </trans-unit>
        <trans-unit id="40bee207a472a4fd5b0841568ca70dbba8442ce0" translate="yes" xml:space="preserve">
          <source>The URL or relative path of a JavaScript file to pull in. This option is not set by default.</source>
          <target state="translated">要拉入的JavaScript文件的URL或相对路径。默认情况下,这个选项没有设置。</target>
        </trans-unit>
        <trans-unit id="da88ae39f79698f8a366077011136f1217b89d12" translate="yes" xml:space="preserve">
          <source>The USE_PERLIO implementation is described in &lt;a href=&quot;perliol&quot;&gt;perliol&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;perliol&quot;&gt;perliol中&lt;/a&gt;描述了USE_PERLIO实现。</target>
        </trans-unit>
        <trans-unit id="5daf05eaea510ba5b0017fb9c306e9890c51ff94" translate="yes" xml:space="preserve">
          <source>The UTF-32 family is pretty much like the UTF-16 family, except that the units are 32-bit, and therefore the surrogate scheme is not needed. UTF-32 is a fixed-width encoding. The &lt;code&gt;BOM&lt;/code&gt; signatures are &lt;code&gt;0x00 0x00 0xFE 0xFF&lt;/code&gt; for BE and &lt;code&gt;0xFF 0xFE 0x00 0x00&lt;/code&gt; for LE.</source>
          <target state="translated">UTF-32系列与UTF-16系列非常相似，不同之处在于这些单元是32位的，因此不需要替代方案。UTF-32是固定宽度的编码。该 &lt;code&gt;BOM&lt;/code&gt; 签名是 &lt;code&gt;0x00 0x00 0xFE 0xFF&lt;/code&gt; 用于BE和 &lt;code&gt;0xFF 0xFE 0x00 0x00&lt;/code&gt; 为LE。</target>
        </trans-unit>
        <trans-unit id="1dd8debe441de21cb20cb60141841b3943f5b160" translate="yes" xml:space="preserve">
          <source>The UTF8 flag</source>
          <target state="translated">UTF8标志</target>
        </trans-unit>
        <trans-unit id="e84247eff9f0cf26586d5f7b3851d2932bd10a42" translate="yes" xml:space="preserve">
          <source>The UTF8 flag, also called SvUTF8, is an internal flag that indicates that the current internal representation is UTF-8. Without the flag, it is assumed to be ISO-8859-1. Perl converts between these automatically. (Actually Perl usually assumes the representation is ASCII; see &lt;a href=&quot;#Why-do-regex-character-classes-sometimes-match-only-in-the-ASCII-range%3f&quot;&gt;Why do regex character classes sometimes match only in the ASCII range?&lt;/a&gt; above.)</source>
          <target state="translated">UTF8标志（也称为SvUTF8）是一个内部标志，指示当前的内部表示形式是UTF-8。如果没有该标志，则假定为ISO-8859-1。Perl在这些之间自动转换。（实际上，Perl通常假定表示形式为ASCII；请参见上面的&lt;a href=&quot;#Why-do-regex-character-classes-sometimes-match-only-in-the-ASCII-range%3f&quot;&gt;正则表达式字符类有时仅在ASCII范围内匹配？&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0c156f969a0dd40349df4b801ec75724f31841f0" translate="yes" xml:space="preserve">
          <source>The UTF8_CHECK_ONLY flag overrides the behavior when a non-allowed (by other flags) malformation is found. If this flag is set, the routine assumes that the caller will raise a warning, and this function will silently just set &lt;code&gt;retlen&lt;/code&gt; to &lt;code&gt;-1&lt;/code&gt; (cast to &lt;code&gt;STRLEN&lt;/code&gt; ) and return zero.</source>
          <target state="translated">当发现不允许（由其他标志）格式错误时，UTF8_CHECK_ONLY标志将覆盖行为。如果设置了此标志，则例程假定调用方将发出警告，并且此函数将仅将 &lt;code&gt;retlen&lt;/code&gt; 设置为 &lt;code&gt;-1&lt;/code&gt; （ &lt;code&gt;STRLEN&lt;/code&gt; 到STRLEN）并返回零。</target>
        </trans-unit>
        <trans-unit id="fe051c2554d575b5ef8dd3483cd37e0f3f831882" translate="yes" xml:space="preserve">
          <source>The Unicode &lt;code&gt;Script&lt;/code&gt; and &lt;code&gt;Script_Extensions&lt;/code&gt; properties give what script a given character is in. Either property can be specified with the compound form like &lt;code&gt;\p{Script=Hebrew}&lt;/code&gt; (short: &lt;code&gt;\p{sc=hebr}&lt;/code&gt; ), or &lt;code&gt;\p{Script_Extensions=Javanese}&lt;/code&gt; (short: &lt;code&gt;\p{scx=java}&lt;/code&gt; ). In addition, Perl furnishes shortcuts for all &lt;code&gt;Script&lt;/code&gt; property names. You can omit everything up through the equals (or colon), and simply write &lt;code&gt;\p{Latin}&lt;/code&gt; or &lt;code&gt;\P{Cyrillic}&lt;/code&gt; . (This is not true for &lt;code&gt;Script_Extensions&lt;/code&gt; , which is required to be written in the compound form.)</source>
          <target state="translated">Unicode &lt;code&gt;Script&lt;/code&gt; 和 &lt;code&gt;Script_Extensions&lt;/code&gt; 属性提供给定字符所在的脚本。可以使用 &lt;code&gt;\p{Script=Hebrew}&lt;/code&gt; （简称： &lt;code&gt;\p{sc=hebr}&lt;/code&gt; ）或 &lt;code&gt;\p{Script_Extensions=Javanese}&lt;/code&gt; （简称： &lt;code&gt;\p{scx=java}&lt;/code&gt; ）。另外，Perl为所有 &lt;code&gt;Script&lt;/code&gt; 属性名称提供了快捷方式。您可以通过等号（或冒号）省略所有内容，而只需编写 &lt;code&gt;\p{Latin}&lt;/code&gt; 或 &lt;code&gt;\P{Cyrillic}&lt;/code&gt; 。 （对于 &lt;code&gt;Script_Extensions&lt;/code&gt; 而言并非如此，它必须以复合形式编写。）</target>
        </trans-unit>
        <trans-unit id="68ace88196ee8ab90b1eb6e05c27ca6293cc1949" translate="yes" xml:space="preserve">
          <source>The Unicode &lt;code&gt;\p{Script}&lt;/code&gt; property is used to categorize every Unicode character into the language script it is written in. For example, English, French, and a bunch of other European languages are written in the Latin script. But there is also the Greek script, the Thai script, the Katakana script, etc. You can test whether a character is in a particular script with, for example &lt;code&gt;\p{Latin}&lt;/code&gt; , &lt;code&gt;\p{Greek}&lt;/code&gt; , or &lt;code&gt;\p{Katakana}&lt;/code&gt; . To test if it isn't in the Balinese script, you would use &lt;code&gt;\P{Balinese}&lt;/code&gt; .</source>
          <target state="translated">Unicode &lt;code&gt;\p{Script}&lt;/code&gt; 属性用于将每个Unicode字符归类为所编写的语言脚本。例如，英语，法语和许多其他欧洲语言均以拉丁脚本编写。但是也有希腊文字，泰语文字，片假名文字等。您可以使用 &lt;code&gt;\p{Latin}&lt;/code&gt; ， &lt;code&gt;\p{Greek}&lt;/code&gt; 或 &lt;code&gt;\p{Katakana}&lt;/code&gt; 来测试字符是否在特定文字中}。要测试它是否不在巴厘岛脚本中，请使用 &lt;code&gt;\P{Balinese}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c137959e417f1d80c5a78f30067a032e5b5cba1e" translate="yes" xml:space="preserve">
          <source>The Unicode CLDR project extracts the POSIX portion of many of its locales, available at</source>
          <target state="translated">Unicode CLDR项目提取了其中许多locales的POSIX部分,可在以下网址获得</target>
        </trans-unit>
        <trans-unit id="d486f8bf02133ca434524335056eb02772644059" translate="yes" xml:space="preserve">
          <source>The Unicode Character Map</source>
          <target state="translated">统一码字符表</target>
        </trans-unit>
        <trans-unit id="c5ce90a3e4de6a4acbbf53c0744b1a0991c6efd2" translate="yes" xml:space="preserve">
          <source>The Unicode Consortium has a list of articles and books, some of which give a much more in depth treatment of Unicode: &lt;a href=&quot;http://unicode.org/resources/readinglist.html&quot;&gt;http://unicode.org/resources/readinglist.html&lt;/a&gt;</source>
          <target state="translated">Unicode联盟提供了一系列文章和书籍，其中一些文章和文章对Unicode进行了更深入的介绍：&lt;a href=&quot;http://unicode.org/resources/readinglist.html&quot;&gt;http&lt;/a&gt; : //unicode.org/resources/readinglist.html</target>
        </trans-unit>
        <trans-unit id="6f47c9f664ce4e52a0db000d2410941371e77032" translate="yes" xml:space="preserve">
          <source>The Unicode Standard, Version 6.1</source>
          <target state="translated">統一碼標準,6.1版</target>
        </trans-unit>
        <trans-unit id="ceaf176fe24089b589f5a8df64bfcb78329c82a1" translate="yes" xml:space="preserve">
          <source>The Unicode character sets associates characters with integers. Encoding these numbers in an equal number of bytes would more than double the requirements for storing texts written in Latin alphabets. The UTF-8 encoding avoids this by storing the most common (from a western point of view) characters in a single byte while encoding the rarer ones in three or more bytes.</source>
          <target state="translated">Unicode字符集将字符与整数联系在一起。如果将这些数字编码在相同数量的字节中,那么存储拉丁字母文字的要求将增加一倍以上。UTF-8编码避免了这一问题,它将最常见的字符存储在一个字节中(从西方的角度来看),而将较罕见的字符编码在三个或更多的字节中。</target>
        </trans-unit>
        <trans-unit id="b01639a1272db3c72594d5482698c9a198da2486" translate="yes" xml:space="preserve">
          <source>The Unicode code points are just abstract numbers. To input and output these abstract numbers, the numbers must be</source>
          <target state="translated">Unicode码点只是抽象的数字。要输入和输出这些抽象的数字,这些数字必须是</target>
        </trans-unit>
        <trans-unit id="fee82003cf69ee996e6b6206be19d9eb1e9b4ae7" translate="yes" xml:space="preserve">
          <source>The Unicode data base is delivered in two different formats. The XML version is valid for more modern Unicode releases. The other version is a collection of files. The two are intended to give equivalent information. Perl uses the older form; this allows you to recompile Perl to use early Unicode releases.</source>
          <target state="translated">Unicode数据库以两种不同的格式提供。XML版本对更现代的Unicode版本有效。另一个版本是文件的集合。这两种格式的目的是提供同等的信息。Perl使用较旧的形式;这允许你重新编译Perl以使用早期的Unicode版本。</target>
        </trans-unit>
        <trans-unit id="0af64faddaa46b640051dd4c06cacd9bdf1c61ba" translate="yes" xml:space="preserve">
          <source>The Unicode name for each of the control characters (such as LINE FEED) is the empty string. However almost all had names assigned by other standards, such as the ASCII Standard, or were in common use. &lt;code&gt;viacode&lt;/code&gt; returns these names as the &quot;best&quot; ones available. Unicode 6.1 has created Name_Aliases for each of them, including alternate names, like NEW LINE. &lt;code&gt;viacode&lt;/code&gt; uses the original name, &quot;LINE FEED&quot; in preference to the alternate. Similarly the name returned for U+FEFF is &quot;ZERO WIDTH NO-BREAK SPACE&quot;, not &quot;BYTE ORDER MARK&quot;.</source>
          <target state="translated">每个控制字符（例如LINE FEED）的Unicode名称是空字符串。但是，几乎所有名称都有其他标准（例如ASCII标准）分配的名称，或者它们是常用名称。 &lt;code&gt;viacode&lt;/code&gt; 将这些名称作为&amp;ldquo;最佳&amp;rdquo;名称返回。 Unicode 6.1为它们每个创建了Name_Aliases，包括备用名称，例如NEW LINE。 &lt;code&gt;viacode&lt;/code&gt; 优先使用原始名称&amp;ldquo; LINE FEED&amp;rdquo;。同样，为U + FEFF返回的名称是&amp;ldquo;零宽度无间隔&amp;rdquo;，而不是&amp;ldquo;字节顺序标记&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="1ac858cb298c00054e86b0d115cb91b95f10f3cf" translate="yes" xml:space="preserve">
          <source>The Unicode standard prefers using hexadecimal notation because that more clearly shows the division of Unicode into blocks of 256 characters. Hexadecimal is also simply shorter than decimal. You can use decimal notation, too, but learning to use hexadecimal just makes life easier with the Unicode standard. The &lt;code&gt;U+HHHH&lt;/code&gt; notation uses hexadecimal, for example.</source>
          <target state="translated">Unicode标准更喜欢使用十六进制表示法，因为这样可以更清楚地显示Unicode分为256个字符的块。十六进制也比十进制短。您也可以使用十进制表示法，但是学习使用十六进制只会简化Unicode标准的工作。该 &lt;code&gt;U+HHHH&lt;/code&gt; 符号使用十六进制，例如。</target>
        </trans-unit>
        <trans-unit id="e6fd7f938d86967a9161a418271cce0d06cd2600" translate="yes" xml:space="preserve">
          <source>The Unicode standard prefers using hexadecimal notation for the code points. If numbers like &lt;code&gt;0x0041&lt;/code&gt; are unfamiliar to you, take a peek at a later section, &lt;a href=&quot;#Hexadecimal-Notation&quot;&gt;Hexadecimal Notation&lt;/a&gt;. The Unicode standard uses the notation &lt;code&gt;U+0041 LATIN CAPITAL LETTER A&lt;/code&gt;, to give the hexadecimal code point and the normative name of the character.</source>
          <target state="translated">Unicode标准更喜欢对代码点使用十六进制表示法。如果您不熟悉 &lt;code&gt;0x0041&lt;/code&gt; 之类的数字，请查看下一节&amp;ldquo; &lt;a href=&quot;#Hexadecimal-Notation&quot;&gt;十六进制表示法&amp;rdquo;&lt;/a&gt;。Unicode标准使用符号 &lt;code&gt;U+0041 LATIN CAPITAL LETTER A&lt;/code&gt; 大写字母A来给出十六进制代码点和字符的规范名称。</target>
        </trans-unit>
        <trans-unit id="c02514a64c1d2f4e4fce35a40ef0864ea99b3007" translate="yes" xml:space="preserve">
          <source>The Unicode::Collate module for perl was written by SADAHIRO Tomoyuki, &amp;lt;SADAHIRO@cpan.org&amp;gt;. This module is Copyright(C) 2001-2014, SADAHIRO Tomoyuki. Japan. All rights reserved.</source>
          <target state="translated">Perl的Unicode :: Collat​​e模块由SADAHIRO Tomoyuki（&amp;lt;SADAHIRO@cpan.org&amp;gt;）编写。该模块是SADAHIRO Tomoyuki版权所有（C）2001-2014。日本。版权所有。</target>
        </trans-unit>
        <trans-unit id="473e3f8c820ceadead01839cdf7e14621c8d192f" translate="yes" xml:space="preserve">
          <source>The Unicode::UCD module offers a series of functions that provide a simple interface to the Unicode Character Database.</source>
          <target state="translated">Unicode::UCD模块提供了一系列功能,为Unicode字符数据库提供了一个简单的接口。</target>
        </trans-unit>
        <trans-unit id="26e3ce0808d98a59d29700d316741aae764f2a61" translate="yes" xml:space="preserve">
          <source>The Unix System V IPC (&lt;code&gt;msg*(), sem*(), shm*()&lt;/code&gt; ) is not available even on all Unix platforms.</source>
          <target state="translated">Unix系统V IPC（ &lt;code&gt;msg*(), sem*(), shm*()&lt;/code&gt; ）在所有Unix平台上都不可用。</target>
        </trans-unit>
        <trans-unit id="fae3b6a0c7efbf25175bd611a319e0fb66e5613e" translate="yes" xml:space="preserve">
          <source>The Unix column assumes that you are not accessing a serial line (like a tty) in canonical mode. If you are, then CR on input becomes &quot;\n&quot;, and &quot;\n&quot; on output becomes CRLF.</source>
          <target state="translated">Unix列假设你不是在规范模式下访问串行线(如tty),如果你是,那么输入的CR就会变成&quot;\n&quot;,输出的&quot;\n &quot;就会变成CRLF。如果你是,那么输入的CR就变成了&quot;\n&quot;,输出的&quot;\n &quot;就变成了CRLF。</target>
        </trans-unit>
        <trans-unit id="dd39418cfe05cee0fae6b087e55e6c5b32837941" translate="yes" xml:space="preserve">
          <source>The Unix emulation library's translation of filenames to native assumes that this sort of translation is required, and it allows a user-defined list of known suffixes that it will transpose in this fashion. This may seem transparent, but consider that with these rules</source>
          <target state="translated">Unix 仿真库将文件名翻译成本地名的过程中,假设需要这种翻译,它允许用户定义一个已知的后缀列表,并以这种方式进行转换。这可能看起来很透明,但考虑到这些规则</target>
        </trans-unit>
        <trans-unit id="fb551ea7181334bc4b0216d63d17835797e645a3" translate="yes" xml:space="preserve">
          <source>The Unix permission &lt;code&gt;rwxr-x---&lt;/code&gt; is represented as three sets of three bits, or three octal digits: &lt;code&gt;0750&lt;/code&gt; (the leading 0 indicates octal and isn't one of the digits). The &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; value is such a number representing disabled permissions bits. The permission (or &quot;mode&quot;) values you pass &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; are modified by your umask, so even if you tell &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; to create a file with permissions &lt;code&gt;0777&lt;/code&gt; , if your umask is &lt;code&gt;0022&lt;/code&gt; , then the file will actually be created with permissions &lt;code&gt;0755&lt;/code&gt; . If your &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; were &lt;code&gt;0027&lt;/code&gt; (group can't write; others can't read, write, or execute), then passing &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;&lt;code&gt;0666&lt;/code&gt; would create a file with mode &lt;code&gt;0640&lt;/code&gt; (because &lt;code&gt;0666 &amp;amp;~ 027&lt;/code&gt; is &lt;code&gt;0640&lt;/code&gt; ).</source>
          <target state="translated">Unix权限 &lt;code&gt;rwxr-x---&lt;/code&gt; 表示为三组三位或三位八进制数字： &lt;code&gt;0750&lt;/code&gt; （前导0表示八进制，不是数字之一）。所述 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 值是表示禁用权限比特这样的号码。您通过 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 修改了传递给 &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; 或sysopen的许可权（或&amp;ldquo;模式&amp;rdquo;）值，因此，即使您告诉 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 创建具有许可权 &lt;code&gt;0777&lt;/code&gt; 的文件，如果您的umask是 &lt;code&gt;0022&lt;/code&gt; ，那么该文件实际上将以许可权 &lt;code&gt;0755&lt;/code&gt; 创建。如果您的 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;0027&lt;/code&gt; （组不能写；其他人不能读，写或执行），然后传递 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; &lt;code&gt;0666&lt;/code&gt; 将创建一个模式为 &lt;code&gt;0640&lt;/code&gt; 的文件（因为 &lt;code&gt;0666 &amp;amp;~ 027&lt;/code&gt; 为 &lt;code&gt;0640&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="96615142b96c010257cd138eceafdbdb1fcfb3bc" translate="yes" xml:space="preserve">
          <source>The Unix permission &lt;code&gt;rwxr-x---&lt;/code&gt; is represented as three sets of three bits, or three octal digits: &lt;code&gt;0750&lt;/code&gt; (the leading 0 indicates octal and isn't one of the digits). The &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; value is such a number representing disabled permissions bits. The permission (or &quot;mode&quot;) values you pass &lt;code&gt;&lt;a href=&quot;mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; are modified by your umask, so even if you tell &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; to create a file with permissions &lt;code&gt;0777&lt;/code&gt; , if your umask is &lt;code&gt;0022&lt;/code&gt; , then the file will actually be created with permissions &lt;code&gt;0755&lt;/code&gt; . If your &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; were &lt;code&gt;0027&lt;/code&gt; (group can't write; others can't read, write, or execute), then passing &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;&lt;code&gt;0666&lt;/code&gt; would create a file with mode &lt;code&gt;0640&lt;/code&gt; (because &lt;code&gt;0666 &amp;amp;~ 027&lt;/code&gt; is &lt;code&gt;0640&lt;/code&gt; ).</source>
          <target state="translated">Unix权限 &lt;code&gt;rwxr-x---&lt;/code&gt; 表示为三组三位或三位八进制数字： &lt;code&gt;0750&lt;/code&gt; （前导0表示八进制，不是数字之一）。所述 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 值是表示禁用权限比特这样的号码。您通过 &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 修改了传递给 &lt;code&gt;&lt;a href=&quot;mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; 或sysopen的许可权（或&amp;ldquo;模式&amp;rdquo;）值，因此，即使您告诉 &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 创建具有许可权 &lt;code&gt;0777&lt;/code&gt; 的文件，如果您的umask是 &lt;code&gt;0022&lt;/code&gt; ，那么该文件实际上将以许可权 &lt;code&gt;0755&lt;/code&gt; 创建。如果您的 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;0027&lt;/code&gt; （组不能写；其他人不能读，写或执行），然后传递 &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; &lt;code&gt;0666&lt;/code&gt; 将创建一个模式为 &lt;code&gt;0640&lt;/code&gt; 的文件（因为 &lt;code&gt;0666 &amp;amp;~ 027&lt;/code&gt; 为 &lt;code&gt;0640&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d68f3b12b3008b73f340d97bbe8121b4ae3d9886" translate="yes" xml:space="preserve">
          <source>The Unix program that displays online documentation (manual pages) for you.</source>
          <target state="translated">为您显示在线文档(手册页面)的Unix程序。</target>
        </trans-unit>
        <trans-unit id="025899dcfc40460b6af9f2e480800fa184584302" translate="yes" xml:space="preserve">
          <source>The VERSIONCHECK: Keyword</source>
          <target state="translated">VERSIONCHECK:关键字</target>
        </trans-unit>
        <trans-unit id="191f8a3a602b994bc056ffe04831bd5feed30108" translate="yes" xml:space="preserve">
          <source>The VERSIONCHECK: keyword corresponds to &lt;b&gt;xsubpp&lt;/b&gt;'s &lt;code&gt;-versioncheck&lt;/code&gt; and &lt;code&gt;-noversioncheck&lt;/code&gt; options. This keyword overrides the command line options. Version checking is enabled by default. When version checking is enabled the XS module will attempt to verify that its version matches the version of the PM module.</source>
          <target state="translated">VERSIONCHECK：关键字对应于&lt;b&gt;xsubpp&lt;/b&gt;的 &lt;code&gt;-versioncheck&lt;/code&gt; 和 &lt;code&gt;-noversioncheck&lt;/code&gt; 选项。此关键字将覆盖命令行选项。默认情况下启用版本检查。启用版本检查后，XS模块将尝试验证其版本是否与PM模块的版本匹配。</target>
        </trans-unit>
        <trans-unit id="04e7acc0343752ab985314abfd05d75387072015" translate="yes" xml:space="preserve">
          <source>The VMS operating system has two filesystems, designated by their on-disk structure (ODS) level: ODS-2 and its successor ODS-5. The initial port of Perl to VMS pre-dates ODS-5, but all current testing and development assumes ODS-5 and its capabilities, including case preservation, extended characters in filespecs, and names up to 8192 bytes long.</source>
          <target state="translated">VMS操作系统有两个文件系统,按其盘上结构(ODS)级别指定。ODS-2及其后续的ODS-5。最初将Perl移植到VMS的时间早于ODS-5,但目前所有的测试和开发都是以ODS-5及其功能为前提的,包括大小写保留、文件规格中的扩展字符和长达8192字节的名称。</target>
        </trans-unit>
        <trans-unit id="b30b00a3df196d84b7a24a918a3d0aa60756c262" translate="yes" xml:space="preserve">
          <source>The VOS mailing list.</source>
          <target state="translated">VOS邮件列表;</target>
        </trans-unit>
        <trans-unit id="1e59303fe7c8cd36efc35383c5bbb06ef61bf43f" translate="yes" xml:space="preserve">
          <source>The Win95/NT installation, when using the ActiveState installer for Perl, will modify the Registry to associate the</source>
          <target state="translated">当使用Perl的ActiveState安装程序时,Win95/NT的安装将修改注册表,使其与</target>
        </trans-unit>
        <trans-unit id="f858558f020a34e7480b07972a3c08c5fd6984b6" translate="yes" xml:space="preserve">
          <source>The Win95/NT installation, when using the ActiveState port of Perl, will modify the Registry to associate the &lt;code&gt;.pl&lt;/code&gt; extension with the perl interpreter. If you install another port, perhaps even building your own Win95/NT Perl from the standard sources by using a Windows port of gcc (e.g., with cygwin or mingw32), then you'll have to modify the Registry yourself. In addition to associating &lt;code&gt;.pl&lt;/code&gt; with the interpreter, NT people can use: &lt;code&gt;SET PATHEXT=%PATHEXT%;.PL&lt;/code&gt; to let them run the program &lt;code&gt;install-linux.pl&lt;/code&gt; merely by typing &lt;code&gt;install-linux&lt;/code&gt; .</source>
          <target state="translated">当使用Perl的ActiveState端口安装Win95 / NT时，将修改注册表以将 &lt;code&gt;.pl&lt;/code&gt; 扩展名与perl解释器关联。如果安装另一个端口，甚至使用Windows的gcc端口（例如，使用cygwin或mingw32）从标准源构建自己的Win95 / NT Perl，那么您都必须自己修改注册表。除了将 &lt;code&gt;.pl&lt;/code&gt; 与解释器相关联外，NT人员还可以使用： &lt;code&gt;SET PATHEXT=%PATHEXT%;.PL&lt;/code&gt; 让他们只需键入 &lt;code&gt;install-linux&lt;/code&gt; 即可运行程序 &lt;code&gt;install-linux.pl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="beb45e4cde225026f4e16a740e28e45e50f2309b" translate="yes" xml:space="preserve">
          <source>The Windows SDK can be downloaded from &lt;a href=&quot;http://www.microsoft.com/&quot;&gt;http://www.microsoft.com/&lt;/a&gt;. The MinGW64 compiler is available at &lt;a href=&quot;http://sourceforge.net/projects/mingw-w64&quot;&gt;http://sourceforge.net/projects/mingw-w64&lt;/a&gt;. The latter is actually a cross-compiler targeting Win64. There's also a trimmed down compiler (no java, or gfortran) suitable for building perl available at: &lt;a href=&quot;http://strawberryperl.com/package/kmx/64_gcctoolchain/&quot;&gt;http://strawberryperl.com/package/kmx/64_gcctoolchain/&lt;/a&gt;</source>
          <target state="translated">Windows SDK可以从&lt;a href=&quot;http://www.microsoft.com/&quot;&gt;http://www.microsoft.com/&lt;/a&gt;下载。MinGW64编译器可从&lt;a href=&quot;http://sourceforge.net/projects/mingw-w64&quot;&gt;http://sourceforge.net/projects/mingw-w64获得&lt;/a&gt;。后者实际上是针对Win64的交叉编译器。还有一个经过精简的编译器（没有Java或gfortran）可用于构建perl，&lt;a href=&quot;http://strawberryperl.com/package/kmx/64_gcctoolchain/&quot;&gt;网址&lt;/a&gt;为：http : //strawberryperl.com/package/kmx/64_gcctoolchain/</target>
        </trans-unit>
        <trans-unit id="c1dd1e762380b02f42ad88590f07ac599a582c23" translate="yes" xml:space="preserve">
          <source>The Windows documentation describes the shell parsing rules here: &lt;a href=&quot;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true&quot;&gt;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true&lt;/a&gt; and the C runtime parsing rules here: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft%28v=VS.100%29.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/17w5ykft%28v=VS.100%29.aspx&lt;/a&gt;.</source>
          <target state="translated">Windows文档在此处描述了shell解析规则：&lt;a href=&quot;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true&quot;&gt;http&lt;/a&gt; : //www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx? mfr=true和C运行时解析规则在此处：&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft%28v=VS.100%29.aspx&quot;&gt;http&lt;/a&gt; : //msdn.microsoft.com/en-us/library/17w5ykft%28v=VS.100%29.aspx。</target>
        </trans-unit>
        <trans-unit id="0944600f567f37796a44d203cb305a8c3dc31877" translate="yes" xml:space="preserve">
          <source>The World Factbook maintained by the CIA is a potential source of the data. Unfortunately, it adds/preserves non-standard codes, so it is no longer used as a source of data.</source>
          <target state="translated">中央情报局保存的《世界概况》是一个潜在的数据来源。遗憾的是,它增加/保留了非标准代码,因此不再用作数据来源。</target>
        </trans-unit>
        <trans-unit id="91e3c6e2754b93eaf46a2a00de960a8c0e2e11b1" translate="yes" xml:space="preserve">
          <source>The XL C for AIX is integrated in the XL C/C++ for AIX compiler and therefore also supported.</source>
          <target state="translated">XL C for AIX集成在XL C/C++for AIX编译器中,因此也支持。</target>
        </trans-unit>
        <trans-unit id="26b303e7615c750693be69ec473b2f4dff6fc26e" translate="yes" xml:space="preserve">
          <source>The XPUSH* macros will automatically extend the return stack to prevent it from being overrun. You push values onto the stack in the order you want them seen by the calling program.</source>
          <target state="translated">XPUSH*宏会自动扩展返回堆栈,以防止它被溢出。您可以按照您希望调用程序看到的顺序将值推送到栈中。</target>
        </trans-unit>
        <trans-unit id="a60c05b1221aad4f1b3aa2c5d4dc4eb83e2bb2ba" translate="yes" xml:space="preserve">
          <source>The XROVER command returns reference information for the article(s) specified.</source>
          <target state="translated">XROVER命令返回指定物品的参考信息。</target>
        </trans-unit>
        <trans-unit id="11313e63e9f00be77c380f5038dabb62b6e1dd06" translate="yes" xml:space="preserve">
          <source>The XS code, with ellipsis, follows.</source>
          <target state="translated">XS代码,省略号如下:</target>
        </trans-unit>
        <trans-unit id="f7fa3ea30854edb41afcb9fc07a8de31e1d1857c" translate="yes" xml:space="preserve">
          <source>The XS compiler is called &lt;b&gt;xsubpp&lt;/b&gt;. This compiler creates the constructs necessary to let an XSUB manipulate Perl values, and creates the glue necessary to let Perl call the XSUB. The compiler uses &lt;b&gt;typemaps&lt;/b&gt; to determine how to map C function parameters and output values to Perl values and back. The default typemap (which comes with Perl) handles many common C types. A supplementary typemap may also be needed to handle any special structures and types for the library being linked. For more information on typemaps, see &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;.</source>
          <target state="translated">XS编译器称为&lt;b&gt;xsubpp&lt;/b&gt;。该编译器创建让XSUB操纵Perl值所必需的构造，并创建让Perl调用XSUB所必需的粘合。编译器使用类型&lt;b&gt;映射&lt;/b&gt;来确定如何将C函数参数和输出值映射到Perl值并返回。默认的typemap（Perl附带）处理许多常见的C类型。可能还需要补充类型图来处理所链接库的任何特殊结构和类型。有关类型映射的更多信息，请参见&lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7b25a71b5ed14cc6ac2648af9eea46c98febfb6" translate="yes" xml:space="preserve">
          <source>The XS implementation uses code from metamail. Copyright 1991 Bell Communications Research, Inc. (Bellcore)</source>
          <target state="translated">XS的实现使用了metamail的代码。版权所有1991年贝尔通信研究公司。(Bellcore)</target>
        </trans-unit>
        <trans-unit id="d9806f72759923810498b1550dc8fe607f007c38" translate="yes" xml:space="preserve">
          <source>The XS language allows one to describe the mapping between how the C routine is used, and how the corresponding Perl routine is used. It also allows creation of Perl routines which are directly translated to C code and which are not related to a pre-existing C function. In cases when the C interface coincides with the Perl interface, the XSUB declaration is almost identical to a declaration of a C function (in K&amp;amp;R style). In such circumstances, there is another tool called &lt;code&gt;h2xs&lt;/code&gt; that is able to translate an entire C header file into a corresponding XS file that will provide glue to the functions/macros described in the header file.</source>
          <target state="translated">XS语言允许人们描述如何使用C例程以及如何使用相应的Perl例程之间的映射。它还允许创建Perl例程，这些例程可以直接转换为C代码，并且与预先存在的C函数无关。在C接口与Perl接口重合的情况下，XSUB声明几乎与C函数的声明（K＆R样式）相同。在这种情况下，存在另一个名为 &lt;code&gt;h2xs&lt;/code&gt; 的工具，该工具能够将整个C头文件转换为相应的XS文件，从而为头文件中描述的功能/宏提供粘合。</target>
        </trans-unit>
        <trans-unit id="5ec313ae92b11ca169ff5d7233881fd7bd18d45a" translate="yes" xml:space="preserve">
          <source>The XS module can use INCLUDE: to pull that file into it.</source>
          <target state="translated">XS模块可以使用INCLUDE:将该文件拉入其中。</target>
        </trans-unit>
        <trans-unit id="218e35287369aa01c3e7fcdd8962b5804ec13123" translate="yes" xml:space="preserve">
          <source>The XSUB follows.</source>
          <target state="translated">XSUB如下:</target>
        </trans-unit>
        <trans-unit id="8e74c8817464edf988ad4bdeab912f47c5f34e75" translate="yes" xml:space="preserve">
          <source>The XSUB mechanism is a simple way for Perl programs to access C subroutines. An XSUB routine will have a stack that contains the arguments from the Perl program, and a way to map from the Perl data structures to a C equivalent.</source>
          <target state="translated">XSUB机制是Perl程序访问C子程序的一种简单方法。一个XSUB例程将有一个包含Perl程序参数的堆栈,以及一种从Perl数据结构映射到C语言等价物的方法。</target>
        </trans-unit>
        <trans-unit id="5d59b445869847df575ae1068c63533e2dbc9b4f" translate="yes" xml:space="preserve">
          <source>The XSUB will look like the code which follows. A CODE: block is used to call the real rpcb_gettime() function with the parameters in the correct order for that function.</source>
          <target state="translated">XSUB看起来像下面的代码。CODE:块用于调用真正的rpcb_gettime()函数,参数的顺序正确。</target>
        </trans-unit>
        <trans-unit id="4912ec37b73cb1d3321d6d839b0519b8e1f0ad32" translate="yes" xml:space="preserve">
          <source>The XSUB's parameters are usually evaluated immediately after entering the XSUB. The INPUT: keyword can be used to force those parameters to be evaluated a little later. The INPUT: keyword can be used multiple times within an XSUB and can be used to list one or more input variables. This keyword is used with the PREINIT: keyword.</source>
          <target state="translated">XSUB的参数通常在进入XSUB后立即被评估。INPUT:关键字可以用来强制这些参数在稍后进行评估。INPUT:关键字可以在一个XSUB中多次使用,并且可以用来列出一个或多个输入变量。这个关键字与PREINIT:关键字一起使用。</target>
        </trans-unit>
        <trans-unit id="889ae69f0e646c6957d38054ac7106368e38cd84" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's equivalent of &lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;. The returned &lt;code&gt;PERL_CONTEXT&lt;/code&gt; structure can be interrogated to find all the information returned to Perl by &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt;. Note that XSUBs don't get a stack frame, so &lt;code&gt;caller_cx(0, NULL)&lt;/code&gt; will return information for the immediately-surrounding Perl code.</source>
          <target state="translated">XSUB-writer等效于&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;。可以查询返回的 &lt;code&gt;PERL_CONTEXT&lt;/code&gt; 结构以查找 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 返回给Perl的所有信息。请注意， &lt;code&gt;caller_cx(0, NULL)&lt;/code&gt; 不会获得堆栈帧，因此caller_cx（0，NULL）将返回立即环绕的Perl代码的信息。</target>
        </trans-unit>
        <trans-unit id="cf42b7fd9e4e74da90d9e8ca347b2091c98166db" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's equivalent to Perl's &lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;&lt;/code&gt;. Returns &lt;code&gt;G_VOID&lt;/code&gt; , &lt;code&gt;G_SCALAR&lt;/code&gt; or &lt;code&gt;G_ARRAY&lt;/code&gt; for void, scalar or list context, respectively. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; for a usage example.</source>
          <target state="translated">XSUB编写器等效于Perl的 &lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;&lt;/code&gt; 。分别针对void，标量或列表上下文返回 &lt;code&gt;G_VOID&lt;/code&gt; ， &lt;code&gt;G_SCALAR&lt;/code&gt; 或 &lt;code&gt;G_ARRAY&lt;/code&gt; 。有关用法示例，请参见&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="75d69996de0f1c3559d54da444421bb8a65343e9" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;free&lt;/code&gt; function.</source>
          <target state="translated">XSUB编写器的C &lt;code&gt;free&lt;/code&gt; 功能接口。</target>
        </trans-unit>
        <trans-unit id="407a1fe0a1b35df310a191803c348a1466dc758e" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;malloc&lt;/code&gt; function, with cast. See also &lt;code&gt;Newx&lt;/code&gt; .</source>
          <target state="translated">X SUB编写器到C &lt;code&gt;malloc&lt;/code&gt; 函数的接口，带有强制转换。另请参阅 &lt;code&gt;Newx&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03573c77e22afa37657d3ab695d4f1f77625b4b6" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;malloc&lt;/code&gt; function.</source>
          <target state="translated">XSUB编写器与C &lt;code&gt;malloc&lt;/code&gt; 函数的接口。</target>
        </trans-unit>
        <trans-unit id="bb6fbdec07f505cf20563b49cda07ec35e3c5893" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;malloc&lt;/code&gt; function. The allocated memory is zeroed with &lt;code&gt;memzero&lt;/code&gt; . See also &lt;code&gt;Newx&lt;/code&gt; .</source>
          <target state="translated">XSUB编写器与C &lt;code&gt;malloc&lt;/code&gt; 函数的接口。使用 &lt;code&gt;memzero&lt;/code&gt; 将分配的内存清零。另请参阅 &lt;code&gt;Newx&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="012775e63d169c2ca0d945eee45190f976576a44" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;memcpy&lt;/code&gt; function. The &lt;code&gt;src&lt;/code&gt; is the source, &lt;code&gt;dest&lt;/code&gt; is the destination, &lt;code&gt;nitems&lt;/code&gt; is the number of items, and &lt;code&gt;type&lt;/code&gt; is the type. May fail on overlapping copies. See also &lt;code&gt;Move&lt;/code&gt; .</source>
          <target state="translated">X SUB编写器的C &lt;code&gt;memcpy&lt;/code&gt; 函数接口。该 &lt;code&gt;src&lt;/code&gt; 为源， &lt;code&gt;dest&lt;/code&gt; 是目的地， &lt;code&gt;nitems&lt;/code&gt; 是项目数，和 &lt;code&gt;type&lt;/code&gt; 是类型。重叠副本可能会失败。另请参阅 &lt;code&gt;Move&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45005a2398999be54551083e5df9a69f712a0c93" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;memmove&lt;/code&gt; function. The &lt;code&gt;src&lt;/code&gt; is the source, &lt;code&gt;dest&lt;/code&gt; is the destination, &lt;code&gt;nitems&lt;/code&gt; is the number of items, and &lt;code&gt;type&lt;/code&gt; is the type. Can do overlapping moves. See also &lt;code&gt;Copy&lt;/code&gt; .</source>
          <target state="translated">X SUB编写器的C &lt;code&gt;memmove&lt;/code&gt; 功能接口。该 &lt;code&gt;src&lt;/code&gt; 为源， &lt;code&gt;dest&lt;/code&gt; 是目的地， &lt;code&gt;nitems&lt;/code&gt; 是项目数，和 &lt;code&gt;type&lt;/code&gt; 是类型。可以做重叠动作。另请参见 &lt;code&gt;Copy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a4b16e416d5be5fce93e4644cc50a90934125a5" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;memzero&lt;/code&gt; function. The &lt;code&gt;dest&lt;/code&gt; is the destination, &lt;code&gt;nitems&lt;/code&gt; is the number of items, and &lt;code&gt;type&lt;/code&gt; is the type.</source>
          <target state="translated">&lt;code&gt;memzero&lt;/code&gt; 的C memzero函数接口。所述 &lt;code&gt;dest&lt;/code&gt; 是目的地， &lt;code&gt;nitems&lt;/code&gt; 是项目数，和 &lt;code&gt;type&lt;/code&gt; 是类型。</target>
        </trans-unit>
        <trans-unit id="37176570a3748e41537c9ad870ca5c052d9042c5" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;realloc&lt;/code&gt; function, with cast.</source>
          <target state="translated">XSUB编写器到C &lt;code&gt;realloc&lt;/code&gt; 函数的接口，带强制转换。</target>
        </trans-unit>
        <trans-unit id="c8ea9501eaec9d4dc35b91e9053fafc1e103de32" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;realloc&lt;/code&gt; function.</source>
          <target state="translated">XSUB编写器与C &lt;code&gt;realloc&lt;/code&gt; 函数的接口。</target>
        </trans-unit>
        <trans-unit id="b5f612b4df0e6a83ff9d89b145ebd6884b1f570e" translate="yes" xml:space="preserve">
          <source>The XSUBPP Program</source>
          <target state="translated">XSUBPP计划</target>
        </trans-unit>
        <trans-unit id="1e85e39271c3e660414eb16aa8d858f60416c1a5" translate="yes" xml:space="preserve">
          <source>The XSUBs for the blue() and set_blue() methods are defined with the class name but the parameter for the object (THIS, or &quot;self&quot;) is implicit and is not listed.</source>
          <target state="translated">blue()和set_blue()方法的XSUB是用类名定义的,但对象的参数(this,或 &quot;self&quot;)是隐式的,没有列出。</target>
        </trans-unit>
        <trans-unit id="f515a1ddc8e361ef2e2c6d0f98a0db815d43b99f" translate="yes" xml:space="preserve">
          <source>The YAML files themselves must have the &lt;code&gt;.yml&lt;/code&gt; extension; all other files are ignored (for two exceptions see</source>
          <target state="translated">YAML文件本身必须具有 &lt;code&gt;.yml&lt;/code&gt; 扩展名；其他所有文件都将被忽略（有关两个例外，请参见</target>
        </trans-unit>
        <trans-unit id="d674c081d1720c0407789140462f1119f634eb87" translate="yes" xml:space="preserve">
          <source>The Zxxx, Zyyy, and Zzzz codes are not used.</source>
          <target state="translated">不使用Zxxx、Zyyy和Zzzz代码。</target>
        </trans-unit>
        <trans-unit id="eb61dbdf150df0568557c97e9633ab5164b764f0" translate="yes" xml:space="preserve">
          <source>The __DATA__ token</source>
          <target state="translated">__DATA__标记</target>
        </trans-unit>
        <trans-unit id="463e37f3f7783165c25668e9edcd6bb8f407a3e5" translate="yes" xml:space="preserve">
          <source>The _splain_ Program</source>
          <target state="translated">解释程序</target>
        </trans-unit>
        <trans-unit id="14c9176f141fa52e2e9b370433e3e5dfafe8e555" translate="yes" xml:space="preserve">
          <source>The ability of an independent subexpression to prevent backtracking can be quite useful. Suppose we want to match a non-empty string enclosed in parentheses up to two levels deep. Then the following regexp matches:</source>
          <target state="translated">独立子表达式防止回溯的能力是相当有用的。假设我们想匹配一个用括号括起来的非空字符串,最多只能匹配两层。那么下面的regexp就可以匹配。</target>
        </trans-unit>
        <trans-unit id="d9ff4522b539fedb72c69d4e7d1a591065047a06" translate="yes" xml:space="preserve">
          <source>The ability to create &quot;canned&quot; filters. These allow commonly used filters to be packaged into a stand-alone module.</source>
          <target state="translated">创建 &quot;罐装 &quot;过滤器的能力。这使得常用的过滤器可以打包成一个独立的模块。</target>
        </trans-unit>
        <trans-unit id="76b03d5ecb823d555d353e5848c41c73876ec792" translate="yes" xml:space="preserve">
          <source>The ability to easily apply multiple filters to a single DBM file.</source>
          <target state="translated">能够轻松地将多个过滤器应用到单个DBM文件中。</target>
        </trans-unit>
        <trans-unit id="2a644c13f043d9a916e16c6cb02fd3b3d632a99e" translate="yes" xml:space="preserve">
          <source>The ability to put additional declarations before the typemap entries are processed is very handy in the cases when typemap conversions manipulate some global state:</source>
          <target state="translated">在处理tyemap条目之前放入额外的声明的能力,在tyemap转换操纵某些全局状态的情况下非常方便。</target>
        </trans-unit>
        <trans-unit id="bca0d0a62c6e09e5d5a84f9c8ee968851fbd9ea7" translate="yes" xml:space="preserve">
          <source>The ability to specify a different outermost delimiter bracket is useful in some circumstances. For example, in the Parse::RecDescent module, parser actions which are to be performed only on a successful parse are specified using a &lt;code&gt;&amp;lt;defer:...&amp;gt;&lt;/code&gt; directive. For example:</source>
          <target state="translated">在某些情况下，指定其他最外面的定界符括号的功能很有用。例如，在Parse :: RecDescent模块中，使用 &lt;code&gt;&amp;lt;defer:...&amp;gt;&lt;/code&gt; 指令指定仅在成功的解析上执行的解析器动作。例如：</target>
        </trans-unit>
        <trans-unit id="7bc890528d2492bad24f35a51d7d007c56cdbd51" translate="yes" xml:space="preserve">
          <source>The above attempts to show how the layer scheme works in a simple case. The application's &lt;code&gt;PerlIO *&lt;/code&gt; points to an entry in the table(s) representing open (allocated) handles. For example the first three slots in the table correspond to &lt;code&gt;stdin&lt;/code&gt; ,&lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; . The table in turn points to the current &quot;top&quot; layer for the handle - in this case an instance of the generic buffering layer &quot;perlio&quot;. That layer in turn points to the next layer down - in this case the low-level &quot;unix&quot; layer.</source>
          <target state="translated">上面的尝试展示了在简单情况下分层方案的工作方式。应用程序的 &lt;code&gt;PerlIO *&lt;/code&gt; 指向表中代表打开（已分配）句柄的条目。例如，表中的前三个插槽对应于 &lt;code&gt;stdin&lt;/code&gt; ， &lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt; 。该表又指向句柄的当前&amp;ldquo;顶层&amp;rdquo;层-在这种情况下，是通用缓冲层&amp;ldquo; perlio&amp;rdquo;的实例。该层又指向下一层-在这种情况下是低级的&amp;ldquo; unix&amp;rdquo;层。</target>
        </trans-unit>
        <trans-unit id="abf94dbab29db68325894cd60a65f3c2a1fc56fa" translate="yes" xml:space="preserve">
          <source>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</source>
          <target state="translated">上述版权声明和本许可声明应包含在软件的所有副本或主要部分中。</target>
        </trans-unit>
        <trans-unit id="267b118ff06011e806ac608fae00f2938fa2a609" translate="yes" xml:space="preserve">
          <source>The above example works only if &lt;code&gt;&quot;s&quot;&lt;/code&gt; is &lt;code&gt;NUL&lt;/code&gt; -terminated; otherwise you have to pass its length to &lt;code&gt;newSVpv&lt;/code&gt; .</source>
          <target state="translated">上面的示例仅在 &lt;code&gt;&quot;s&quot;&lt;/code&gt; 为 &lt;code&gt;NUL&lt;/code&gt; 终止的情况下有效；否则，您必须将其长度传递给 &lt;code&gt;newSVpv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a24a47b6e29ea30653b134f5da5c978447aa0575" translate="yes" xml:space="preserve">
          <source>The above example would print out the message:</source>
          <target state="translated">上面的例子会打印出信息。</target>
        </trans-unit>
        <trans-unit id="f4ebb52f7b218814c788462297b6da7a43f52650" translate="yes" xml:space="preserve">
          <source>The above four are optional except in other formatting codes, notably &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; , and when preceded by a capital letter.</source>
          <target state="translated">除其他格式代码（特别是 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; ）以及大写字母后，上述四个是可选的。</target>
        </trans-unit>
        <trans-unit id="dd54f214af2e16fd555100563837da248db5495d" translate="yes" xml:space="preserve">
          <source>The above is a somewhat simplified view of what really happens. Since Perl allows more flexible calling conventions than C, XSUBs may do much more in practice, such as checking input parameters for validity, throwing exceptions (or returning undef/empty list) if the return value from the C function indicates failure, calling different C functions based on numbers and types of the arguments, providing an object-oriented interface, etc.</source>
          <target state="translated">以上是对真实情况的某种简化看法。由于Perl允许比C语言更灵活的调用约定,XSUB在实践中可能会做更多的事情,比如检查输入参数的有效性,如果C函数的返回值表示失败就抛出异常(或返回undef/空列表),根据参数的数量和类型调用不同的C函数,提供面向对象的接口等等。</target>
        </trans-unit>
        <trans-unit id="754ca936a964e1d5816b54783f4e5f1ce663020d" translate="yes" xml:space="preserve">
          <source>The above is roughly equivalent to a &quot;stdio&quot; buffered stream, but with much more flexibility:</source>
          <target state="translated">以上大致相当于 &quot;stdio &quot;缓冲流,但灵活性更大。</target>
        </trans-unit>
        <trans-unit id="7fcad7cfc523d43a196084786f96b8329cc3ac60" translate="yes" xml:space="preserve">
          <source>The above module is very primitive. It does not implement mutator methods (&lt;code&gt;++&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; and so on), does not do deep copying (not required without mutators!), and implements only those arithmetic operations which are used in the example.</source>
          <target state="translated">上面的模块非常原始。它不实现增变器方法（ &lt;code&gt;++&lt;/code&gt; ， &lt;code&gt;-=&lt;/code&gt; 等），不进行深度复制（没有增变器就不需要！），并且仅实现示例中使用的那些算术运算。</target>
        </trans-unit>
        <trans-unit id="281ac3a4234dba5767807b1f7ef90bcb868fb84e" translate="yes" xml:space="preserve">
          <source>The above recipes describe the ordering of matches</source>
          <target state="translated">以上配方描述了火柴的顺序</target>
        </trans-unit>
        <trans-unit id="abb826d1f92a77f8ee5fb15c131983e89da595f3" translate="yes" xml:space="preserve">
          <source>The above search for &quot;interpreter&quot; is recursive: if</source>
          <target state="translated">以上对 &quot;解释者 &quot;的搜索是递归的:如果</target>
        </trans-unit>
        <trans-unit id="b606cf43c801f260cbdfb890db240a19d58a3f8e" translate="yes" xml:space="preserve">
          <source>The above subroutine may be called with either one or two arguments. The default value expression is evaluated when the subroutine is called, so it may provide different default values for different calls. It is only evaluated if the argument was actually omitted from the call. For example,</source>
          <target state="translated">上述子程序可以用一个或两个参数来调用。当调用子程序时,默认值表达式会被评估,因此它可以为不同的调用提供不同的默认值。只有在调用中实际省略了该参数时,才会对其进行评估。例如</target>
        </trans-unit>
        <trans-unit id="54c21b6df45da0f9df4499ebff5512482a22c709" translate="yes" xml:space="preserve">
          <source>The above test passes two values to &lt;code&gt;ok(arg1, arg2)&lt;/code&gt; -- the first a coderef, and the second is the number 4. Before &lt;code&gt;ok&lt;/code&gt; compares them, it calls the coderef, and uses its return value as the real value of this parameter. Assuming that &lt;code&gt;$bytecount&lt;/code&gt; returns 4, &lt;code&gt;ok&lt;/code&gt; ends up testing &lt;code&gt;4 eq 4&lt;/code&gt; . Since that's true, this test passes.</source>
          <target state="translated">上面的测试将两个值传递给 &lt;code&gt;ok(arg1, arg2)&lt;/code&gt; -第一个是coderef，第二个是数字4。在 &lt;code&gt;ok&lt;/code&gt; 比较它们之前，它将调用coderef，并将其返回值用作此参数的实际值。 。假设 &lt;code&gt;$bytecount&lt;/code&gt; 返回4，则 &lt;code&gt;ok&lt;/code&gt; 测试 &lt;code&gt;4 eq 4&lt;/code&gt; 。既然是真的，那么这个测试就通过了。</target>
        </trans-unit>
        <trans-unit id="b1ef6a2bf455cf77affd01d5de26884f122aeca1" translate="yes" xml:space="preserve">
          <source>The above variables have all been localized and may be changed without affecting data outside of the wanted function.</source>
          <target state="translated">以上变量均已本地化,可以在不影响想要的函数外的数据的情况下更改。</target>
        </trans-unit>
        <trans-unit id="ae51a1ce20f245092ecaad634de2dfa1ff5d3441" translate="yes" xml:space="preserve">
          <source>The above won't happen every time competing process update the same &lt;b&gt;DB_File&lt;/b&gt; database, but it does illustrate why the technique should not be used.</source>
          <target state="translated">每次竞争过程更新相同的&lt;b&gt;DB_File&lt;/b&gt;数据库时，都不会发生上述情况，但这确实说明了为什么不应该使用该技术。</target>
        </trans-unit>
        <trans-unit id="3f1ad066d4a66bd948f60c33d21673c18f0eb993" translate="yes" xml:space="preserve">
          <source>The accessor method provided by &lt;code&gt;struct&lt;/code&gt; for an element depends on the declared type of the element.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 为元素提供的访问器方法取决于元素的声明类型。</target>
        </trans-unit>
        <trans-unit id="2cc7abc6dcf89e4b9609885153970267df830f15" translate="yes" xml:space="preserve">
          <source>The accessor methods assume that the actual storage for the data in the tied hash is in the hash referenced by &lt;code&gt;(&lt;a href=&quot;../functions/tied&quot;&gt;tied&lt;/a&gt;(%tiedhash))-&amp;gt;[0]&lt;/code&gt; . Thus overwritten &lt;code&gt;TIEHASH&lt;/code&gt; method should return an array reference with the first element being a hash reference, and the remaining methods should operate on the hash &lt;code&gt;%{ $_[0]-&amp;gt;[0] }&lt;/code&gt; :</source>
          <target state="translated">访问器方法假定绑定哈希中数据的实际存储位于 &lt;code&gt;(&lt;a href=&quot;../functions/tied&quot;&gt;tied&lt;/a&gt;(%tiedhash))-&amp;gt;[0]&lt;/code&gt; 引用的哈希中。因此，重写的 &lt;code&gt;TIEHASH&lt;/code&gt; 方法应返回一个数组引用，且第一个元素为哈希引用，而其余方法应在哈希 &lt;code&gt;%{ $_[0]-&amp;gt;[0] }&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="225d5409f9e31ec1fd3549dba0dd919b3904ec0c" translate="yes" xml:space="preserve">
          <source>The accessor methods assume that the actual storage for the data in the tied hash is in the hash referenced by &lt;code&gt;&lt;a href=&quot;../functions/tied&quot;&gt;tied(%tiedhash)&lt;/a&gt;&lt;/code&gt;. Thus overwritten &lt;code&gt;TIEHASH&lt;/code&gt; method should return a hash reference, and the remaining methods should operate on the hash referenced by the first argument:</source>
          <target state="translated">访问器方法假定绑定哈希中的数据的实际存储在 &lt;code&gt;&lt;a href=&quot;../functions/tied&quot;&gt;tied(%tiedhash)&lt;/a&gt;&lt;/code&gt; 引用的哈希中。因此，重写的 &lt;code&gt;TIEHASH&lt;/code&gt; 方法应返回哈希引用，其余方法应对第一个参数引用的哈希进行操作：</target>
        </trans-unit>
        <trans-unit id="2198a837e059e4191004ad59c18436a206b5087a" translate="yes" xml:space="preserve">
          <source>The accessor's argument, if any, is assigned to the element.</source>
          <target state="translated">访问者的参数(如果有的话)被分配给元素。</target>
        </trans-unit>
        <trans-unit id="0a55122025df9d01179435aa1526880dbd188b0d" translate="yes" xml:space="preserve">
          <source>The accessor's argument, if any, is assigned to the element. The accessor will &lt;code&gt;croak&lt;/code&gt; if this is not an appropriate object reference.</source>
          <target state="translated">访问者的参数（如果有）已分配给该元素。如果这不是适当的对象引用，则访问器将发出 &lt;code&gt;croak&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc291805bbdf71f35da9613fd10fc72effdd81d3" translate="yes" xml:space="preserve">
          <source>The act of calling up a deity, daemon, program, method, subroutine, or function to get it to do what you think it&amp;rsquo;s supposed to do. We usually &amp;ldquo;call&amp;rdquo; subroutines but &amp;ldquo;invoke&amp;rdquo; methods, since it sounds cooler.</source>
          <target state="translated">调用神，守护程序，程序，方法，子例程或函数以使其执行您认为应该执行的操作。我们通常&amp;ldquo;调用&amp;rdquo;子例程，但&amp;ldquo;调用&amp;rdquo;方法，因为它听起来更酷。</target>
        </trans-unit>
        <trans-unit id="0aae7e6b56823ac18d0d863614b52f8ccee20556" translate="yes" xml:space="preserve">
          <source>The act of emptying a &lt;b&gt;buffer&lt;/b&gt;, often before it&amp;rsquo;s full.</source>
          <target state="translated">清空&lt;b&gt;缓冲区&lt;/b&gt;的行为，通常是在&lt;b&gt;缓冲区&lt;/b&gt;满之前。</target>
        </trans-unit>
        <trans-unit id="da4cbb2e16fc1345262c617dbbfacc0e9a82482b" translate="yes" xml:space="preserve">
          <source>The action begins in</source>
          <target state="translated">行动开始于</target>
        </trans-unit>
        <trans-unit id="c50575ea6cd15b6f99786b019f7fd7d151291681" translate="yes" xml:space="preserve">
          <source>The actual &lt;code&gt;SvUTF8&lt;/code&gt; flag of the &lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt; scalar is significant, but not the whole story regarding the input character encoding. Normally, when a file is being read, the scalar contains octets and its &lt;code&gt;SvUTF8&lt;/code&gt; flag is off, but the octets should be interpreted as UTF-8 if the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma is in effect. During a string eval, however, the scalar may have the &lt;code&gt;SvUTF8&lt;/code&gt; flag on, and in this case its octets should be interpreted as UTF-8 unless the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma is in effect. This logic may change in the future; use this function instead of implementing the logic yourself.</source>
          <target state="translated">&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt; linestr&lt;/a&gt;标量的实际 &lt;code&gt;SvUTF8&lt;/code&gt; 标志很重要，但有关输入字符编码的整个故事并不重要。通常，在读取文件时，标量包含八位字节，并且其 &lt;code&gt;SvUTF8&lt;/code&gt; 标志处于关闭状态，但是如果有效 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; utf8编译指示，则八位字节应解释为UTF-8 。但是，在字符串评估期间，标量可能会打开 &lt;code&gt;SvUTF8&lt;/code&gt; 标志，在这种情况下，除非 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 字节有效，否则应将其八位字节解释为UTF-8 。这种逻辑将来可能会改变；使用此功能代替自己实现逻辑。</target>
        </trans-unit>
        <trans-unit id="7dd5fba3f25088e2897b2cb955245840fd943e5f" translate="yes" xml:space="preserve">
          <source>The actual difference between PPCODE: and CODE: sections is in the initialization of &lt;code&gt;SP&lt;/code&gt; macro (which stands for the</source>
          <target state="translated">PPCODE：和CODE：部分之间的实际区别在于 &lt;code&gt;SP&lt;/code&gt; 宏的初始化（代表SP宏）。</target>
        </trans-unit>
        <trans-unit id="c8adbcba0e7f4d6240d43127016adb7bebb0e850" translate="yes" xml:space="preserve">
          <source>The actual functions called are known as PP code, and they're spread between four files:</source>
          <target state="translated">实际调用的函数称为PP代码,它们分布在四个文件中。</target>
        </trans-unit>
        <trans-unit id="9fed5c7ec6f1ab01c643aa93a8adb0f82c40adfa" translate="yes" xml:space="preserve">
          <source>The actual numbers are stored as unsigned big integers (with separate sign).</source>
          <target state="translated">实际的数字以无符号大整数的形式存储(有单独的符号)。</target>
        </trans-unit>
        <trans-unit id="7371146aaafc3d93e00f035ea0ab638040fbcf08" translate="yes" xml:space="preserve">
          <source>The actual permissions set depend on the value of the &lt;code&gt;CYGWIN&lt;/code&gt; in the SYSTEM environment settings. (Cygwin)</source>
          <target state="translated">实际的权限设置取决于系统环境设置中 &lt;code&gt;CYGWIN&lt;/code&gt; 的值。（Cygwin）</target>
        </trans-unit>
        <trans-unit id="6f09daaa018160f529d356d689ea131810985b7e" translate="yes" xml:space="preserve">
          <source>The actual sizes (in bytes) of native shorts, ints, longs, and long longs on the platform where Perl was built are also available from the command line:</source>
          <target state="translated">在Perl构建的平台上,原生的short、ints、long和long长的实际大小(以字节为单位)也可以从命令行中获得。</target>
        </trans-unit>
        <trans-unit id="b9688cf79c9a25cc4e9f2e8b4c5ac878b783210d" translate="yes" xml:space="preserve">
          <source>The actual values on the argument stack are pointers to the values passed in. When an argument is listed as being an OUTPUT value, its corresponding value on the stack (i.e., ST(0) if it was the first argument) is changed. You can verify this by looking at the C code generated for Example 3. The code for the round() XSUB routine contains lines that look like this:</source>
          <target state="translated">参数栈上的实际值是传递进来的值的指针。当一个参数被列为OUTPUT值时,它在栈中的对应值(即ST(0),如果它是第一个参数)就会被改变。你可以通过查看例3生成的C代码来验证这一点。round()XSUB例程的代码包含这样的行。</target>
        </trans-unit>
        <trans-unit id="9efd0030f2fab9c72c68391b18e8706f0e577dc3" translate="yes" xml:space="preserve">
          <source>The add_bits() method is an alternative to add() that allow partial bytes to be appended to the message. Most users should just ignore this method as partial bytes is very unlikely to be of any practical use.</source>
          <target state="translated">add_bits()方法是add()的替代方法,它允许将部分字节附加到消息中。大多数用户应该忽略这个方法,因为部分字节不太可能有任何实际用途。</target>
        </trans-unit>
        <trans-unit id="4385ce0c6decd2654eecaf2223aa22c33620d447" translate="yes" xml:space="preserve">
          <source>The addfile() method will croak() if it fails reading data for some reason. If it croaks it is unpredictable what the state of the $ctx object will be in. The addfile() method might have been able to read the file partially before it failed. It is probably wise to discard or reset the $ctx object if this occurs.</source>
          <target state="translated">addfile()方法如果因为某些原因读取数据失败,就会呱呱叫()。如果它呱呱坠地,那么$ctx对象的状态将是不可预知的。addfile()方法在失败之前可能已经能够部分读取文件了。如果发生这种情况,丢弃或重置$ctx对象可能是明智之举。</target>
        </trans-unit>
        <trans-unit id="29515a29b800fb1b3a5d264f9d3d2a8c7827591b" translate="yes" xml:space="preserve">
          <source>The addfile() method will croak() if it fails reading data for some reason. If it croaks it is unpredictable what the state of the $md5 object will be in. The addfile() method might have been able to read the file partially before it failed. It is probably wise to discard or reset the $md5 object if this occurs.</source>
          <target state="translated">addfile()方法如果因为某些原因读取数据失败,就会呱呱叫()。如果它呱呱坠地,那么$md5对象的状态将是不可预知的。addfile()方法在失败之前可能已经能够部分读取文件了。如果发生这种情况,丢弃或重置$md5对象可能是明智之举。</target>
        </trans-unit>
        <trans-unit id="bad770ef214b3ea483bf0a738f9ad60704fafe4f" translate="yes" xml:space="preserve">
          <source>The addition of threads has changed Perl's internals substantially. There are implications for people who write modules with XS code or external libraries. However, since Perl data is not shared among threads by default, Perl modules stand a high chance of being thread-safe or can be made thread-safe easily. Modules that are not tagged as thread-safe should be tested or code reviewed before being used in production code.</source>
          <target state="translated">线程的加入使Perl的内部结构发生了很大的变化。对于用XS代码或外部库编写模块的人来说,是有影响的。然而,由于Perl数据默认情况下不会在线程之间共享,所以Perl模块很有可能是线程安全的,或者可以很容易地使其成为线程安全的。没有被标记为线程安全的模块在用于生产代码之前应该进行测试或代码审查。</target>
        </trans-unit>
        <trans-unit id="9fb5062c416df742306ccabb4b5f706bc8df9b28" translate="yes" xml:space="preserve">
          <source>The additional state of being</source>
          <target state="translated">额外的存在状态</target>
        </trans-unit>
        <trans-unit id="e003249c8de3365551eedf50a46a7442176acc5e" translate="yes" xml:space="preserve">
          <source>The address family (e.g. &lt;code&gt;AF_INET&lt;/code&gt; )</source>
          <target state="translated">地址族（例如 &lt;code&gt;AF_INET&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f126536906b38b811e2283014aef5b17fb2a2bb1" translate="yes" xml:space="preserve">
          <source>The address in a packed string (such as would be returned by pack_sockaddr_in())</source>
          <target state="translated">包装好的字符串中的地址(如pack_sockaddr_in()返回的地址)</target>
        </trans-unit>
        <trans-unit id="9ca884174256cffd8e2121d14b1b2f9600471f92" translate="yes" xml:space="preserve">
          <source>The address of the OP's SV, if it has an SV, in hexadecimal.</source>
          <target state="translated">OP的SV地址,如果有SV的话,用十六进制表示。</target>
        </trans-unit>
        <trans-unit id="452ef6486bc83e321d333ed85c0a567a4e8c1783" translate="yes" xml:space="preserve">
          <source>The address of the OP's first child, in hexadecimal.</source>
          <target state="translated">OP的第一个孩子的地址,十六进制。</target>
        </trans-unit>
        <trans-unit id="2838690d17f05c70e3e67bc06eecc94e3f275b6e" translate="yes" xml:space="preserve">
          <source>The address of the OP's last child, in hexadecimal.</source>
          <target state="translated">OP的最后一个孩子的地址,十六进制。</target>
        </trans-unit>
        <trans-unit id="e332f1e7f698853a5727152a76eca59b2c2b494a" translate="yes" xml:space="preserve">
          <source>The address of the OP's next OP, in hexadecimal.</source>
          <target state="translated">OP的下一个OP的地址,用十六进制表示。</target>
        </trans-unit>
        <trans-unit id="1290cc2c32604c72580d6a56eb9a2ca86ec89ccf" translate="yes" xml:space="preserve">
          <source>The address of the OP's next youngest sibling, in hexadecimal.</source>
          <target state="translated">上诉人下一个最小的兄弟姐妹的地址,用十六进制表示。</target>
        </trans-unit>
        <trans-unit id="b68836e0a8059af6d65948c4349c2eade8a16af3" translate="yes" xml:space="preserve">
          <source>The address of the OP, in hexadecimal.</source>
          <target state="translated">OP的地址,十六进制。</target>
        </trans-unit>
        <trans-unit id="09ebb8cc7d0fd73db86fd8a64bea18fe0c098b0c" translate="yes" xml:space="preserve">
          <source>The address tables of DLLs are patched only once, when they are loaded. The addresses of the entry points into DLLs are guaranteed to be the same for all the programs which use the same DLL. This removes the runtime fixup - once DLL is loaded, its code is read-only.</source>
          <target state="translated">DLLs的地址表只在加载时打一次补丁。DLL的入口点的地址保证对所有使用同一DLL的程序都是一样的。这就消除了运行时的修补--一旦DLL被加载,其代码就是只读的。</target>
        </trans-unit>
        <trans-unit id="c74bfa2ec2baf330be7b8d46296fdd61de05ff99" translate="yes" xml:space="preserve">
          <source>The advantage of this approach comparing to ALIAS: keyword is that there is no need to code a switch statement, each Perl function (which shares the same XSUB) knows which C function it should call. Additionally, one can attach an extra function remainder() at runtime by using</source>
          <target state="translated">与ALIAS:关键字相比,这种方法的优点是不需要编写switch语句,每个Perl函数(共享同一个XSUB)都知道它应该调用哪个C函数。此外,我们可以在运行时附加一个额外的函数remaxinder(),通过使用</target>
        </trans-unit>
        <trans-unit id="1ba0a293372a8086f2c3cb8bd66f4ad49631031c" translate="yes" xml:space="preserve">
          <source>The advantage of this technique is that you have complete control over the implementation of your filter. The big disadvantage is the increased complexity required to write the filter - not only do you need to understand the source filter hooks, but you also need a reasonable knowledge of Perl guts. One of the few times it is worth going to this trouble is when writing a source scrambler. The &lt;code&gt;decrypt&lt;/code&gt; filter (which unscrambles the source before Perl parses it) included with the source filter distribution is an example of a C source filter (see Decryption Filters, below).</source>
          <target state="translated">此技术的优点是您可以完全控制过滤器的实现。最大的缺点是编写过滤器需要增加复杂性-不仅需要了解源过滤器挂钩，而且还需要对Perl胆量有一定的了解。编写源加扰器是值得解决此问题的少数情况之一。包含在源过滤器分发中的 &lt;code&gt;decrypt&lt;/code&gt; 过滤器（在Perl解析源之前对源进行解密）是C源过滤器的示例（请参见下面的解密过滤器）。</target>
        </trans-unit>
        <trans-unit id="072e0efbeb225d357c21442cc8c46a3dcf93b381" translate="yes" xml:space="preserve">
          <source>The advantage of using the above macros is that you don't have to setup an extra function for &lt;code&gt;call_*&lt;/code&gt; , and that using these macros is faster than using &lt;code&gt;call_*&lt;/code&gt; .</source>
          <target state="translated">使用上述宏的优点是您不必为 &lt;code&gt;call_*&lt;/code&gt; 设置额外的功能，并且使用这些宏比使用 &lt;code&gt;call_*&lt;/code&gt; 更快。</target>
        </trans-unit>
        <trans-unit id="53174719bc4a34362607e16e39670825ed959235" translate="yes" xml:space="preserve">
          <source>The agent on whose behalf a &lt;b&gt;method&lt;/b&gt; is invoked. In a &lt;b&gt;class&lt;/b&gt; method, the invocant is a package name. In an &lt;b&gt;instance&lt;/b&gt; method, the invocant is an object reference.</source>
          <target state="translated">代表&lt;b&gt;方法&lt;/b&gt;调用的代理。在&lt;b&gt;类&lt;/b&gt;方法中，倡导者是程序包名称。在&lt;b&gt;实例&lt;/b&gt;方法中，主体是对象引用。</target>
        </trans-unit>
        <trans-unit id="3e3cbe3ecc5eb1d553a5d35837bcb40ffd7eda37" translate="yes" xml:space="preserve">
          <source>The aim of the implementation is to provide the PerlIO API in a flexible and platform neutral manner. It is also a trial of an &quot;Object Oriented C, with vtables&quot; approach which may be applied to Perl 6.</source>
          <target state="translated">实现的目的是以一种灵活和平台中立的方式提供PerlIO API。它也是对 &quot;面向对象的C语言,与vtables &quot;方法的一种尝试,这种方法可以应用于Perl 6。</target>
        </trans-unit>
        <trans-unit id="eca34d276a1e0da5bdcd3481f3be5f1fa01ec807" translate="yes" xml:space="preserve">
          <source>The aim of this stage is to take the Perl source, and turn it into an op tree. We'll see what one of those looks like later. Strictly speaking, there's three things going on here.</source>
          <target state="translated">这个阶段的目的是把Perl源代码,变成一棵op树。我们稍后会看到其中一个是什么样子的。严格来说,这里有三件事。</target>
        </trans-unit>
        <trans-unit id="1c84b06bf15cbe5bd96e34833737cbd3f8f36b72" translate="yes" xml:space="preserve">
          <source>The alarm() test failure is caused by system() apparently blocking alarm(). That is probably a libc bug, and given that SunOS 4.x has been end-of-lifed years ago, don't hold your breath for a fix. In addition to that, don't try anything too Unicode-y, especially with Encode, and you should be fine in SunOS 4.x.</source>
          <target state="translated">alarm()测试失败的原因是system()明显阻塞了 alarm()。这可能是libc的一个bug,鉴于SunOS 4.x已经在几年前就已经寿终正寝了,所以不要抱着侥幸心理去修复。除此之外,不要尝试任何太过Unicode的东西,尤其是使用Encode,在SunOS 4.x中应该没有问题。</target>
        </trans-unit>
        <trans-unit id="ac23951d81146a4c25773847fcd1353c10dfdb5b" translate="yes" xml:space="preserve">
          <source>The alias_code function is deprecated and will be removed in the December 2014 release.</source>
          <target state="translated">alias_code函数已被废弃,将在2014年12月的版本中删除。</target>
        </trans-unit>
        <trans-unit id="f5829e682c777d3809510d4e74d665806fe75e9a" translate="yes" xml:space="preserve">
          <source>The alias_code function is preserved for backwards compatibility, but the following two are identical:</source>
          <target state="translated">为了向后兼容,保留了alias_code函数,但下面两个函数是相同的。</target>
        </trans-unit>
        <trans-unit id="70cc56ad5f5fa00e1dcd91a0319ec7c86448a5ca" translate="yes" xml:space="preserve">
          <source>The alloc command allows you to give the ftp server a hint about the size of the file about to be transferred using the ALLO ftp command. Some storage systems use this to make intelligent decisions about how to store the file. The &lt;code&gt;SIZE&lt;/code&gt; argument represents the size of the file in bytes. The &lt;code&gt;RECORD_SIZE&lt;/code&gt; argument indicates a maximum record or page size for files sent with a record or page structure.</source>
          <target state="translated">alloc命令允许您使用ALLO ftp命令为ftp服务器提供有关即将传输的文件大小的提示。一些存储系统使用它来做出有关如何存储文件的明智决策。该 &lt;code&gt;SIZE&lt;/code&gt; 参数表示以字节为单位的文件的大小。该 &lt;code&gt;RECORD_SIZE&lt;/code&gt; 参数指示与一个记录或页结构发送的文件最大记录或页面大小。</target>
        </trans-unit>
        <trans-unit id="b33892c53e0bb40f7871a5fed62579159a0f62e4" translate="yes" xml:space="preserve">
          <source>The alternative &lt;code&gt;STORABLE_attach&lt;/code&gt; method provides a solution for these shared objects. Instead of &lt;code&gt;STORABLE_freeze&lt;/code&gt; --&amp;gt; &lt;code&gt;STORABLE_thaw&lt;/code&gt; , you implement &lt;code&gt;STORABLE_freeze&lt;/code&gt; --&amp;gt; &lt;code&gt;STORABLE_attach&lt;/code&gt; instead.</source>
          <target state="translated">替代的 &lt;code&gt;STORABLE_attach&lt;/code&gt; 方法为这些共享库提供了解决方案。取而代之的 &lt;code&gt;STORABLE_freeze&lt;/code&gt; - &amp;gt; &lt;code&gt;STORABLE_thaw&lt;/code&gt; ，你实现 &lt;code&gt;STORABLE_freeze&lt;/code&gt; - &amp;gt; &lt;code&gt;STORABLE_attach&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="402e3151897f6beaece02f0ebb7344497fe45587" translate="yes" xml:space="preserve">
          <source>The alternative is to put the stubs in before the &lt;code&gt;__DATA__&lt;/code&gt; token BEFORE releasing the module, and for this purpose the &lt;code&gt;Devel::SelfStubber&lt;/code&gt; module is available. However this does require the extra step of ensuring that the stubs are in the module. If this is done I strongly recommend that this is done BEFORE releasing the module - it should NOT be done at install time in general.</source>
          <target state="translated">另一种方法是在释放模块之前将存根放在 &lt;code&gt;__DATA__&lt;/code&gt; 令牌之前，为此目的，可以使用 &lt;code&gt;Devel::SelfStubber&lt;/code&gt; 模块。但是，这确实需要确保存根位于模块中的额外步骤。如果完成了此操作，我强烈建议您在释放模块之前完成此操作-通常不应在安装时执行此操作。</target>
        </trans-unit>
        <trans-unit id="6f8e08a6bd15bdf7cb57a249a2eb325f0bdb259e" translate="yes" xml:space="preserve">
          <source>The amount of sbrk(2)ed memory needed to keep buckets aligned.</source>
          <target state="translated">保持桶对齐所需的sbrk(2)ed内存量。</target>
        </trans-unit>
        <trans-unit id="24d94fd90247d993fe24e78a68e00db6f524e13c" translate="yes" xml:space="preserve">
          <source>The anger you feel when the computer is being lazy. This makes you write programs that don&amp;rsquo;t just react to your needs, but actually anticipate them. Or at least that pretend to. Hence, the second great virtue of a programmer. See also &lt;b&gt;laziness&lt;/b&gt; and &lt;b&gt;hubris&lt;/b&gt;.</source>
          <target state="translated">懒惰时，您会感到愤怒。这使您编写的程序不仅可以满足您的需求，而且可以真正预期它们。或至少假装如此。因此，程序员的第二个优点。另请参见&lt;b&gt;懒惰&lt;/b&gt;和&lt;b&gt;傲慢&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2d396c6c924a9cda1b9caf0839be7530a8ba7f62" translate="yes" xml:space="preserve">
          <source>The anonymous subroutine returned by add_function_generator() isn't technically a closure because it refers to no lexicals outside its own scope. Using a closure gives you a</source>
          <target state="translated">add_function_generator()返回的匿名子程序从技术上讲并不是一个闭包,因为它没有引用自己作用域之外的词法。使用闭包可以得到一个</target>
        </trans-unit>
        <trans-unit id="7c26228772d7852b95995c9f2def9a6401f105ab" translate="yes" xml:space="preserve">
          <source>The answer is &lt;b&gt;recursion&lt;/b&gt;, and maybe &lt;b&gt;threads&lt;/b&gt;. Both these can create several execution pointers going into the same subroutine. For the subroutine-child not write over the temporaries for the subroutine-parent (lifespan of which covers the call to the child), the parent and the child should have different scratchpads. (</source>
          <target state="translated">答案是&lt;b&gt;递归&lt;/b&gt;，也许是&lt;b&gt;线程&lt;/b&gt;。这两个都可以创建进入同一子例程的多个执行指针。为了使子例程子项不覆盖子例程父项的临时项（其寿命涵盖对子项的调用），父项和子项应具有不同的暂存器。（</target>
        </trans-unit>
        <trans-unit id="352a5795d3c7f4b3f3c9dafd2990d2244d787ba4" translate="yes" xml:space="preserve">
          <source>The answer is that our regexp works well until we get past the last real match. Then the regexp will fail to match a synchronized &lt;code&gt;TGA&lt;/code&gt; and start stepping ahead one character position at a time, not what we want. The solution is to use &lt;code&gt;\G&lt;/code&gt; to anchor the match to the codon alignment:</source>
          <target state="translated">答案是我们的正则表达式工作良好，直到我们超过了最后一个真正的比赛。这样，正则表达式将无法匹配同步的 &lt;code&gt;TGA&lt;/code&gt; ,并且一次开始向前移动一个字符位置，而不是我们想要的。解决方案是使用 &lt;code&gt;\G&lt;/code&gt; 将匹配项锚定到密码子对齐方式：</target>
        </trans-unit>
        <trans-unit id="08cdc226d03f36a2e4fc74ff822641ef90ed1cc6" translate="yes" xml:space="preserve">
          <source>The answer lies in the optimizations the regex engine makes. In the first case, all the engine sees are plain old characters (aside from the &lt;code&gt;?{}&lt;/code&gt; construct). It's smart enough to realize that the string 'ddd' doesn't occur in our target string before actually running the pattern through. But in the second case, we've tricked it into thinking that our pattern is more complicated. It takes a look, sees our character class, and decides that it will have to actually run the pattern to determine whether or not it matches, and in the process of running it hits the print statement before it discovers that we don't have a match.</source>
          <target state="translated">答案在于正则表达式引擎进行的优化。在第一种情况下，引擎看到的所有内容都是普通的旧字符（除了 &lt;code&gt;?{}&lt;/code&gt; 构造之外）。足够聪明地意识到在实际运行模式之前，字符串&amp;ldquo; ddd&amp;rdquo;不会出现在目标字符串中。但是在第二种情况下，我们欺骗了它，以为我们的模式更加复杂。它进行查看，查看我们的角色类，并确定它必须实际运行该模式以确定其是否匹配，并且在运行过程中，它会在未发现我们没有字符的情况下命中print语句。比赛。</target>
        </trans-unit>
        <trans-unit id="a5831b08e8cef23b3074e1a04c2a596b4fb392c8" translate="yes" xml:space="preserve">
          <source>The answer to requirement 2) is that a regexp (mostly) uses Unicode characters. The &quot;mostly&quot; is for messy backward compatibility reasons, but starting in Perl 5.14, any regex compiled in the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (which is automatically turned on within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher) will turn that &quot;mostly&quot; into &quot;always&quot;. If you want to handle Unicode properly, you should ensure that &lt;code&gt;'unicode_strings'&lt;/code&gt; is turned on. Internally, this is encoded to bytes using either UTF-8 or a native 8 bit encoding, depending on the history of the string, but conceptually it is a sequence of characters, not bytes. See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for a tutorial about that.</source>
          <target state="translated">要求2）的答案是（大多数）正则表达式使用Unicode字符。 &amp;ldquo;大部分&amp;rdquo;是出于混乱的向后兼容性原因，但是从Perl 5.14开始，在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; （在使用范围 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 或更高的&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;范围内自动打开）范围内编译的任何正则表达式都会使&amp;ldquo;大部分&amp;rdquo;变成&amp;ldquo;总是&amp;rdquo;。如果要正确处理Unicode，则应确保已打开 &lt;code&gt;'unicode_strings'&lt;/code&gt; 。在内部，根据字符串的历史记录，使用UTF-8或本地8位编码将其编码为字节，但从概念上讲，它是字符序列，而不是字节。请参阅&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;以获得有关此内容的教程。</target>
        </trans-unit>
        <trans-unit id="ab2461c5e3f0cff2ecb68a3151a2d92b8a70b40b" translate="yes" xml:space="preserve">
          <source>The answers may be off by few percentages because of the irregular (slightly aspherical) form of the Earth. The errors are at worst about 0.55%, but generally below 0.3%.</source>
          <target state="translated">由于地球的形状不规则(略呈非球面),答案可能会有几个百分点的偏差。误差最差约为0.55%,但一般低于0.3%。</target>
        </trans-unit>
        <trans-unit id="d59be2ed12ab2165af09c3bf2c28e33ef82222db" translate="yes" xml:space="preserve">
          <source>The appended output looks like:</source>
          <target state="translated">附带的输出是这样的。</target>
        </trans-unit>
        <trans-unit id="0bd30cce9c74d0ed491dced5ecc139a5a1ba48e4" translate="yes" xml:space="preserve">
          <source>The appropriate string for the capability will be returned.</source>
          <target state="translated">将返回相应的能力字符串。</target>
        </trans-unit>
        <trans-unit id="3156ec770160eccf0b831e893b19fba7da139602" translate="yes" xml:space="preserve">
          <source>The arcus (also known as the inverse) functions of the sine, cosine, and tangent</source>
          <target state="translated">正弦、余弦、正切的弧度(也称反)函数。</target>
        </trans-unit>
        <trans-unit id="ef155b03ef2bd4353f5f3ae9ce3143e92ce08f0b" translate="yes" xml:space="preserve">
          <source>The arcus cofunctions of the sine, cosine, and tangent (acosec/acsc and acotan/acot are aliases). Note that atan2(0, 0) is not well-defined.</source>
          <target state="translated">正弦、余弦和正切的弧形共轭(acosec/acsc和acotan/acot是别名)。需要注意的是,atan2(0,0)的定义不明确。</target>
        </trans-unit>
        <trans-unit id="d90394bf6d1003afd92e57075638d8ec96a8f149" translate="yes" xml:space="preserve">
          <source>The area (also known as the inverse) functions of the hyperbolic sine, cosine, and tangent</source>
          <target state="translated">双曲正弦、余弦、正切的面积(也称反)函数。</target>
        </trans-unit>
        <trans-unit id="96b07ebcfe3eb3364fc6d5a9b44430b864f7f185" translate="yes" xml:space="preserve">
          <source>The area cofunctions of the hyperbolic sine, cosine, and tangent (acsch/acosech and acoth/acotanh are aliases)</source>
          <target state="translated">双曲正弦、余弦和正切的面积协函数(acsch/acosech和acoth/acotanh为别名)。</target>
        </trans-unit>
        <trans-unit id="5ccdfb64dc7931913963c31e04d78b0a9af3ae93" translate="yes" xml:space="preserve">
          <source>The area in which a particular invocation of a particular file or subroutine keeps some of its temporary values, including any lexically scoped variables.</source>
          <target state="translated">特定文件或子程序的特定调用保存其部分临时值的区域,包括任何词法范围的变量。</target>
        </trans-unit>
        <trans-unit id="d10c9af72d3c8216f90487b0cb07489720300b93" translate="yes" xml:space="preserve">
          <source>The arg variable is initially set by taking the value from ST(0), then is stored back into ST(0) at the end of the routine.</source>
          <target state="translated">arg变量最初是通过从ST(0)中取值来设置的,然后在例程结束时存储回ST(0)中。</target>
        </trans-unit>
        <trans-unit id="4d814bb4a725af841ef1489f2dfafba121655945" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;level&lt;/code&gt; should be either 0 or -1. If &lt;code&gt;level==0&lt;/code&gt; , as a side-effect creates a glob with the given &lt;code&gt;name&lt;/code&gt; in the given &lt;code&gt;stash&lt;/code&gt; which in the case of success contains an alias for the subroutine, and sets up caching info for this glob.</source>
          <target state="translated">参数 &lt;code&gt;level&lt;/code&gt; 应为0或-1。如果 &lt;code&gt;level==0&lt;/code&gt; ，则副作用是在给定 &lt;code&gt;stash&lt;/code&gt; 中使用给定 &lt;code&gt;name&lt;/code&gt; 创建了一个glob，在成功的情况下，该glob包含该子例程的别名，并为此glob设置了缓存信息。</target>
        </trans-unit>
        <trans-unit id="46a90c11604ca06c6858b07026656614cf325b22" translate="yes" xml:space="preserve">
          <source>The argument after &lt;code&gt;'autotie'&lt;/code&gt; is a reference to a hash in which each key is the name of an attribute to be created, and each value is the class to which variables ascribed that attribute should be tied.</source>
          <target state="translated">&lt;code&gt;'autotie'&lt;/code&gt; 之后的参数是对哈希的引用，其中每个键是要创建的属性的名称，每个值是应该将归属于该属性的变量绑定到的类。</target>
        </trans-unit>
        <trans-unit id="de7c9584c8050b2d0fdb24caf50ee070b0a90073" translate="yes" xml:space="preserve">
          <source>The argument specification can be</source>
          <target state="translated">参数规格可以是</target>
        </trans-unit>
        <trans-unit id="e56eb85000cd23825e22500ebb61377895023bf6" translate="yes" xml:space="preserve">
          <source>The argument specification is optional. If omitted, the option is considered boolean, a value of 1 will be assigned when the option is used on the command line.</source>
          <target state="translated">参数规格是可选的。如果省略,该选项被认为是布尔值,当在命令行中使用该选项时,将分配一个1的值。</target>
        </trans-unit>
        <trans-unit id="f70b3fa6aabdcb387bd854a30ff21340870477da" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;LIST_CACHE&lt;/code&gt; or &lt;code&gt;SCALAR_CACHE&lt;/code&gt; must either be one of the following four strings:</source>
          <target state="translated">&lt;code&gt;LIST_CACHE&lt;/code&gt; 或 &lt;code&gt;SCALAR_CACHE&lt;/code&gt; 的参数必须是以下四个字符串之一：</target>
        </trans-unit>
        <trans-unit id="c5464d59534d6182be5453dd048427e6d0c50353" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;$heading1&lt;/code&gt; , &lt;code&gt;$heading2&lt;/code&gt; , etc. are the heading titles of the corresponding sections, subsections, etc. to try and match. If &lt;code&gt;$headingN&lt;/code&gt; is omitted then it defaults to the current corresponding section heading title in the input.</source>
          <target state="translated">参数 &lt;code&gt;$heading1&lt;/code&gt; ， &lt;code&gt;$heading2&lt;/code&gt; 等是要尝试匹配的相应节，小节等的标题。如果省略 &lt;code&gt;$headingN&lt;/code&gt; ，则默认为输入中当前对应的节标题。</target>
        </trans-unit>
        <trans-unit id="0c2d811d7e533f13a02dc5ccb0c9cf2822f648ef" translate="yes" xml:space="preserve">
          <source>The arguments after the</source>
          <target state="translated">后面的参数</target>
        </trans-unit>
        <trans-unit id="c3ee6db939d4bf6fb2dbd132ec653ceddc879c3d" translate="yes" xml:space="preserve">
          <source>The arguments and expected behaviour of these methods are described in &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt;.</source>
          <target state="translated">这些方法的论点和预期行为在&lt;a href=&quot;../digest&quot;&gt;Digest中&lt;/a&gt;进行了描述。</target>
        </trans-unit>
        <trans-unit id="b5c76d2b203709556f900b75ce0e52a9ac994219" translate="yes" xml:space="preserve">
          <source>The arguments are available via @ARGV, not $1, $2, etc.</source>
          <target state="translated">参数可以通过@ARGV获得,而不是1元、2元等。</target>
        </trans-unit>
        <trans-unit id="6cb92f325e1877b21a75fa1acba0a791fd4726a3" translate="yes" xml:space="preserve">
          <source>The arguments of &lt;code&gt;sv_setpvf&lt;/code&gt; are processed like &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, and the formatted output becomes the value.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 一样处理 &lt;code&gt;sv_setpvf&lt;/code&gt; 的参数，并且格式化的输出成为值。</target>
        </trans-unit>
        <trans-unit id="839631a833c7558b199549ece29ff396d5371aa7" translate="yes" xml:space="preserve">
          <source>The arguments passed to the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement which invokes &lt;b&gt;sigtrap&lt;/b&gt; are processed in order. When a signal name or the name of one of &lt;b&gt;sigtrap&lt;/b&gt;'s signal lists is encountered a handler is immediately installed, when an option is encountered it affects subsequently installed handlers.</source>
          <target state="translated">传递给调用&lt;b&gt;sigtrap&lt;/b&gt;的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句的参数&lt;b&gt;将按&lt;/b&gt;顺序处理。当遇到信号名称或&lt;b&gt;sigtrap&lt;/b&gt;信号列表之一的名称时，将立即安装处理程序，而在遇到选项时，它将影响随后安装的处理程序。</target>
        </trans-unit>
        <trans-unit id="a181ad8a8d3a3252da75be7994d668c484c4410f" translate="yes" xml:space="preserve">
          <source>The arguments should be a hashref with</source>
          <target state="translated">参数应该是一个hashref,其中包括</target>
        </trans-unit>
        <trans-unit id="01c93f64cbaa573f1e972a244178e4f2a83875d0" translate="yes" xml:space="preserve">
          <source>The arguments themselves are any values following the &lt;code&gt;flags&lt;/code&gt; argument.</source>
          <target state="translated">参数本身是 &lt;code&gt;flags&lt;/code&gt; 参数之后的任何值。</target>
        </trans-unit>
        <trans-unit id="380902efca5b9b3a75f7c59abab4db85bec7e897" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;given&lt;/code&gt; and &lt;code&gt;when&lt;/code&gt; are in scalar context, and &lt;code&gt;given&lt;/code&gt; assigns the &lt;code&gt;$_&lt;/code&gt; variable its topic value.</source>
          <target state="translated">给 &lt;code&gt;given&lt;/code&gt; 和 &lt;code&gt;when&lt;/code&gt; 的参数在标量上下文中， &lt;code&gt;given&lt;/code&gt; 为 &lt;code&gt;$_&lt;/code&gt; 变量分配其主题值。</target>
        </trans-unit>
        <trans-unit id="bee53666a69514e40c684814c2f3de57ce34649e" translate="yes" xml:space="preserve">
          <source>The arguments to layers are by default returned in parentheses after the name of the layer, and certain layers (like &lt;code&gt;utf8&lt;/code&gt; ) are not real layers but instead flags on real layers; to get all of these returned separately, use the optional &lt;code&gt;details&lt;/code&gt; argument:</source>
          <target state="translated">默认情况下，图层的参数在图层名称后的括号中返回，某些图层（例如 &lt;code&gt;utf8&lt;/code&gt; ）不是真实图层，而是真实图层上的标志；要使所有这些单独返回，请使用可选的 &lt;code&gt;details&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="6e693a7b71ba349ddefc634c4aa1cd90dc56ea7f" translate="yes" xml:space="preserve">
          <source>The arithmetics with pure imaginary numbers works just like you would expect it with real numbers... you just have to remember that</source>
          <target state="translated">纯虚数的算术就像实数的算术一样...你只需要记得</target>
        </trans-unit>
        <trans-unit id="27b0340458e5b6bada543e551d3178c4f1de6919" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;@ARGV&lt;/code&gt; contains the command-line arguments intended for the script. &lt;code&gt;$#ARGV&lt;/code&gt; is generally the number of arguments minus one, because &lt;code&gt;$ARGV[0]&lt;/code&gt; is the first argument,</source>
          <target state="translated">&lt;code&gt;@ARGV&lt;/code&gt; 数组包含用于脚本的命令行参数。 &lt;code&gt;$#ARGV&lt;/code&gt; 通常是参数个数减一个，因为 &lt;code&gt;$ARGV[0]&lt;/code&gt; 是第一个参数，</target>
        </trans-unit>
        <trans-unit id="5e6fff9bfd20cc94284be277039aa46feebe2516" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;@F&lt;/code&gt; contains the fields of each line read in when autosplit mode is turned on. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for the &lt;b&gt;-a&lt;/b&gt; switch. This array is package-specific, and must be declared or given a full package name if not in package main when running under &lt;code&gt;strict 'vars'&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;@F&lt;/code&gt; 数组包含打开自动拆分模式时读取的每一行的字段。参见&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;的&lt;b&gt;-a&lt;/b&gt;开关。此数组是特定于程序包的，如果在 &lt;code&gt;strict 'vars'&lt;/code&gt; 下运行，则必须在包主目录中声明该数组或为其指定完整的包名。</target>
        </trans-unit>
        <trans-unit id="c8441a1e4197d6b374d0c52606833f2a1d2d3753" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;@INC&lt;/code&gt; contains the list of places that the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; EXPR&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; constructs look for their library files. It initially consists of the arguments to any &lt;b&gt;-I&lt;/b&gt; command-line switches, followed by the default Perl library, probably</source>
          <target state="translated">&lt;code&gt;@INC&lt;/code&gt; 数组包含 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; EXPR&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 构造查找其库文件的位置列表。它最初由任何&lt;b&gt;-I&lt;/b&gt;命令行开关的参数组成，其后是默认的Perl库，可能是</target>
        </trans-unit>
        <trans-unit id="a14a26b2dd6454634cc1107915a7a3aee19dc784" translate="yes" xml:space="preserve">
          <source>The array indices start with 0. A negative subscript retrieves its value from the end. In our example, &lt;code&gt;$myarray[-1]&lt;/code&gt; would have been 5000, and &lt;code&gt;$myarray[-2]&lt;/code&gt; would have been 500.</source>
          <target state="translated">数组索引从0开始。负下标从末尾检索其值。在我们的示例中， &lt;code&gt;$myarray[-1]&lt;/code&gt; 5000，而 &lt;code&gt;$myarray[-2]&lt;/code&gt; 为500。</target>
        </trans-unit>
        <trans-unit id="5870f5124d5a86e2473fbde56d4d16aa6bdafbce" translate="yes" xml:space="preserve">
          <source>The array returned by the &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; operator is divided up according to the same rules the CRTL &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; routine. Therefore, the &quot;system time&quot; elements will always be 0, since there is no difference between &quot;user time&quot; and &quot;system&quot; time under VMS, and the time accumulated by a subprocess may or may not appear separately in the &quot;child time&quot; field, depending on whether &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; keeps track of subprocesses separately. Note especially that the VAXCRTL (at least) keeps track only of subprocesses spawned using &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;; it will not accumulate the times of subprocesses spawned via pipes, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;, or backticks.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; 操作符返回的数组根据CRTL &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; 例程的相同规则进行划分。因此，&amp;ldquo;系统时间&amp;rdquo;元素将始终为0，因为在VMS下&amp;ldquo;用户时间&amp;rdquo;和&amp;ldquo;系统&amp;rdquo;时间之间没有区别，并且子进程累积的时间可能会或可能不会单独出现在&amp;ldquo;子时间&amp;rdquo;中字段，具体取决于 &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; 是否单独跟踪子流程。特别要注意的是，VAXCRTL（至少）仅跟踪使用 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 产生的子进程；它不会累积通过管道， &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 或反引号产生的子流程的时间。</target>
        </trans-unit>
        <trans-unit id="3e203923e4bb3b1b85d85c3be6cf6dca987c9241" translate="yes" xml:space="preserve">
          <source>The arrays &lt;code&gt;@EXPORT&lt;/code&gt; and &lt;code&gt;@EXPORT_OK&lt;/code&gt; in a module hold lists of symbols that are going to be exported into the users name space by default, or which they can request to be exported, respectively. The symbols can represent functions, scalars, arrays, hashes, or typeglobs. The symbols must be given by full name with the exception that the ampersand in front of a function is optional, e.g.</source>
          <target state="translated">模块中的 &lt;code&gt;@EXPORT&lt;/code&gt; 和 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 数组包含默认情况下将要导出到用户名称空间中的符号列表，或者它们可以分别请求导出的列表。这些符号可以表示函数，标量，数组，哈希或typeglob。符号必须全名，但函数前面的&amp;ldquo;＆&amp;rdquo;号是可选的，例如</target>
        </trans-unit>
        <trans-unit id="6be6541bf2f3c9c38b314f884349aae8de53fdfb" translate="yes" xml:space="preserve">
          <source>The arrays completely specify the mappings for all possible code points. The final element in an inversion map returned by this function will always be for the range that consists of all the code points that aren't legal Unicode, but that are expressible on the platform. (That is, it starts with code point 0x110000, the first code point above the legal Unicode maximum, and extends to infinity.) The value for that range will be the same that any typical unassigned code point has for the specified property. (Certain unassigned code points are not &quot;typical&quot;; for example the non-character code points, or those in blocks that are to be written right-to-left. The above-Unicode range's value is not based on these atypical code points.) It could be argued that, instead of treating these as unassigned Unicode code points, the value for this range should be &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. If you wish, you can change the returned arrays accordingly.</source>
          <target state="translated">数组完全指定了所有可能代码点的映射。此函数返回的反转映射中的最后一个元素将始终位于由合法Unicode以外但可在平台上表示的所有代码点组成的范围内。 （也就是说，它从代码点0x110000开始，这是合法Unicode最大值之上的第一个代码点，并一直扩展到无穷大。）该范围的值将与任何典型的未分配代码点对指定属性所具有的值相同。 （某些未分配的代码点不是&amp;ldquo;典型的&amp;rdquo;；例如，非字符代码点或要从右到左写入的块中的代码点。Unicode以上范围的值并不基于这些非典型代码点。 ）可以争辩说，与其将这些视为未分配的Unicode代码点，不如将其视为该范围的值应为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。如果需要，可以相应地更改返回的数组。</target>
        </trans-unit>
        <trans-unit id="215f34a814c5d96aebb0e5a01677224428736e62" translate="yes" xml:space="preserve">
          <source>The arrays.h/arrays.c code in the &lt;a href=&quot;http://search.cpan.org/perldoc/PGPLOT&quot;&gt;PGPLOT&lt;/a&gt; module on CPAN does just this. If you're doing a lot of float or double processing, consider using the &lt;a href=&quot;http://search.cpan.org/perldoc/PDL&quot;&gt;PDL&lt;/a&gt; module from CPAN instead--it makes number-crunching easy.</source>
          <target state="translated">CPAN上&lt;a href=&quot;http://search.cpan.org/perldoc/PGPLOT&quot;&gt;PGPLOT&lt;/a&gt;模块中的arrays.h / arrays.c代码就是这样做的。如果您要进行大量浮点或双精度处理，请考虑改用CPAN 的&lt;a href=&quot;http://search.cpan.org/perldoc/PDL&quot;&gt;PDL&lt;/a&gt;模块-这样可以简化数字运算。</target>
        </trans-unit>
        <trans-unit id="7c674ebc98c67a6b78e8bff2084920a9483e6761" translate="yes" xml:space="preserve">
          <source>The arrow points to the sequence number of the next op; they're not displayed in -exec mode, for obvious reasons.</source>
          <target state="translated">箭头指向下一个操作的序列号;由于显而易见的原因,它们在-exec模式下不显示。</target>
        </trans-unit>
        <trans-unit id="d3369ef5421624f50c9461a4385bdfc6e73878c8" translate="yes" xml:space="preserve">
          <source>The art of defining something (at least partly) in terms of itself, which is a naughty no-no in dictionaries but often works out okay in computer programs if you&amp;rsquo;re careful not to recurse forever (which is like an infinite loop with more spectacular failure modes).</source>
          <target state="translated">定义某种东西（至少部分地）本身的艺术，这在字典中是一个顽皮的禁忌，但是如果您注意不要永远递归，那在计算机程序中通常会行得通（这就像无限循环，壮观的故障模式）。</target>
        </trans-unit>
        <trans-unit id="44c6ad6b4370d28f2449d941c6198878c199473e" translate="yes" xml:space="preserve">
          <source>The article &quot;Constants in Perl&quot;, in</source>
          <target state="translated">文章 &quot;Perl中的常量&quot;,在</target>
        </trans-unit>
        <trans-unit id="f1506bf3257cec0583c1b75ddabb2245f7506472" translate="yes" xml:space="preserve">
          <source>The assignment to &lt;code&gt;$^R&lt;/code&gt; above is properly localized, so the old value of &lt;code&gt;$^R&lt;/code&gt; is restored if the assertion is backtracked; compare &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;.</source>
          <target state="translated">上面 &lt;code&gt;$^R&lt;/code&gt; 的赋值已正确定位，因此如果断言回溯，将恢复 &lt;code&gt;$^R&lt;/code&gt; 的旧值；比较&lt;a href=&quot;#Backtracking&quot;&gt;回溯&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="afaa9c220de769e54d663ab2c9c6d4f430c692cd" translate="yes" xml:space="preserve">
          <source>The assignment variants of these operators (&lt;code&gt;&amp;amp;= |= ^= &amp;amp;.= |.= ^.=&lt;/code&gt; ) behave likewise under the feature.</source>
          <target state="translated">这些运算符的赋值变体（ &lt;code&gt;&amp;amp;= |= ^= &amp;amp;.= |.= ^.=&lt;/code&gt; ）在该功能下的行为也相同。</target>
        </trans-unit>
        <trans-unit id="71ba6eda663c17eb85a62c08062fb7adfc8e5822" translate="yes" xml:space="preserve">
          <source>The association between the filter object and the source stream is made with the &lt;code&gt;filter_add()&lt;/code&gt; function. This takes a filter object as a parameter (&lt;code&gt;$ref&lt;/code&gt; in this case) and installs it in the source stream.</source>
          <target state="translated">过滤器对象和源流之间的关联是通过 &lt;code&gt;filter_add()&lt;/code&gt; 函数进行的。这将过滤器对象作为参数（在这种情况下 &lt;code&gt;$ref&lt;/code&gt; ）并将其安装在源流中。</target>
        </trans-unit>
        <trans-unit id="12a98cd04a6eb830d540ea5356e8449610414ff4" translate="yes" xml:space="preserve">
          <source>The atmark() functionality is also exportable as sockatmark() function:</source>
          <target state="translated">atmark()功能也可以作为sockatmark()函数导出。</target>
        </trans-unit>
        <trans-unit id="30252fd845cfc7120c5fe1c8c4bfc41149abe5bb" translate="yes" xml:space="preserve">
          <source>The atmark() implementation: Copyright 2001, Lincoln Stein &amp;lt;lstein@cshl.org&amp;gt;. This module is distributed under the same terms as Perl itself. Feel free to use, modify and redistribute it as long as you retain the correct attribution.</source>
          <target state="translated">atmark（）实现：版权所有2001，Lincoln Stein &amp;lt;lstein@cshl.org&amp;gt;。该模块的分发术语与Perl本身相同。只要您保留正确的出处，就可以随意使用，修改和重新分发它。</target>
        </trans-unit>
        <trans-unit id="82c21f7a3ae183ec4d3047341406ff01ae50460f" translate="yes" xml:space="preserve">
          <source>The attribute list is passed as a list of constant strings to the code which associates them with the subroutine. In particular, the second example of valid syntax above currently looks like this in terms of how it's parsed and invoked:</source>
          <target state="translated">属性列表以常量字符串列表的形式传递给代码,代码将它们与子程序关联起来。尤其是上面第二个有效语法的例子,目前在解析和调用方式上是这样的。</target>
        </trans-unit>
        <trans-unit id="b657a6989977956f6b98ac68863da82534e8cebe" translate="yes" xml:space="preserve">
          <source>The attributes must be valid as simple identifier names (without any punctuation other than the '_' character). They may have a parameter list appended, which is only checked for whether its parentheses ('(',')') nest properly.</source>
          <target state="translated">属性必须是有效的简单标识符名称(除了'_'字符外,没有任何标点符号),它们可以附加参数列表,只检查其括号('(',')')是否正确嵌套。它们可以附加一个参数列表,只检查其括号('(',')')是否正确嵌套。</target>
        </trans-unit>
        <trans-unit id="6773066d674b1f4d653955ef73a085c07f393513" translate="yes" xml:space="preserve">
          <source>The author is particularly grateful to</source>
          <target state="translated">笔者特别感谢</target>
        </trans-unit>
        <trans-unit id="a93ac8e5cbb3f89224036c2390524cda7879089a" translate="yes" xml:space="preserve">
          <source>The author that PAUSE allows to assign &lt;b&gt;co-maintainer&lt;/b&gt; permissions to a &lt;b&gt;namespace&lt;/b&gt;. A primary maintainer can give up this distinction by assigning it to another PAUSE author. See Camel chapter 19, &amp;ldquo;CPAN&amp;rdquo;.</source>
          <target state="translated">暂停的作者允许将&lt;b&gt;共同维护者&lt;/b&gt;权限分配给&lt;b&gt;命名空间&lt;/b&gt;。主维护者可以通过将其分配给另一位PAUSE作者来放弃此区别。请参阅骆驼第19章&amp;ldquo; CPAN&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="08620722332423b72a0cf9f7ae67e151d08d71e3" translate="yes" xml:space="preserve">
          <source>The author would like to thank Jeff Pinyan, Andrew Johnson, Peter Haworth, Ronald J Kimball, and Joe Smith for all their helpful comments.</source>
          <target state="translated">笔者要感谢Jeff Pinyan、Andrew Johnson、Peter Haworth、Ronald J Kimball和Joe Smith的有益意见。</target>
        </trans-unit>
        <trans-unit id="7842e70d44fa0066b01f00b794f28e99cc120d48" translate="yes" xml:space="preserve">
          <source>The author would like to thank Mark-Jason Dominus, Tom Christiansen, Ilya Zakharevich, Brad Hughes, and Mike Giroux for all their helpful comments.</source>
          <target state="translated">作者要感谢Mark-Jason Dominus、Tom Christiansen、Ilya Zakharevich、Brad Hughes和Mike Giroux提出的所有有益意见。</target>
        </trans-unit>
        <trans-unit id="d5ab428bb4c4aa590bf7abb081e2b965dbe912a0" translate="yes" xml:space="preserve">
          <source>The author's book</source>
          <target state="translated">作者的书</target>
        </trans-unit>
        <trans-unit id="c9e7cff5bfc96623d1a90b00467d7f7914fdeb06" translate="yes" xml:space="preserve">
          <source>The authors make &lt;b&gt;no warranty&lt;/b&gt;, implied or otherwise, about the suitability of this software for safety or security purposes.</source>
          <target state="translated">作者对本软件出于安全性目的的适用性不做&lt;b&gt;任何&lt;/b&gt;暗示或其他形式的&lt;b&gt;保证&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="9dd8067e06812735b51136d8d5ba18979e5deef6" translate="yes" xml:space="preserve">
          <source>The authors shall not in any case be liable for special, incidental, consequential, indirect or other similar damages arising from the use of this software.</source>
          <target state="translated">作者在任何情况下都不对因使用本软件而造成的特殊的、偶然的、后果性的、间接的或其他类似的损害负责。</target>
        </trans-unit>
        <trans-unit id="bac4f3e7625a4b29694017ee1288427918dba79c" translate="yes" xml:space="preserve">
          <source>The auto-decrement operator is not magical.</source>
          <target state="translated">自动递减运算符并不神奇。</target>
        </trans-unit>
        <trans-unit id="c93a7c7b52c97bf0962eebd109f5c679236979ad" translate="yes" xml:space="preserve">
          <source>The auto-increment operator has a little extra builtin magic to it. If you increment a variable that is numeric, or that has ever been used in a numeric context, you get a normal increment. If, however, the variable has been used in only string contexts since it was set, and has a value that is not the empty string and matches the pattern &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; , the increment is done as a string, preserving each character within its range, with carry:</source>
          <target state="translated">自动增量运算符具有一些额外的内置魔术。如果递增一个数字变量或曾经在数字上下文中使用过的变量，则将获得正常的递增。但是，如果变量自设置以来仅在字符串上下文中使用，并且其值不是空字符串并且匹配模式 &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; ，增量以字符串形式完成，并在每个字符范围内保留进位：</target>
        </trans-unit>
        <trans-unit id="2fa846bc3447cd43bb267eb92f634f66df9d2ff7" translate="yes" xml:space="preserve">
          <source>The autodie pragma &lt;b&gt;&amp;lt;does not check calls to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;&lt;/b&gt;&amp;gt;.</source>
          <target state="translated">自动拼写pragma &lt;b&gt;&amp;lt;不检查 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; &lt;/b&gt;&lt;b&gt;呼叫&lt;/b&gt; &amp;gt;。</target>
        </trans-unit>
        <trans-unit id="6a915a44546183301bc1ab2da7f5d31390cf86d3" translate="yes" xml:space="preserve">
          <source>The autodocumentation system was originally added to the Perl core by Benjamin Stuhl. Documentation is by whoever was kind enough to document their functions.</source>
          <target state="translated">自动文档系统最初是由Benjamin Stuhl添加到Perl核心中的。文档是由谁来记录他们的功能。</target>
        </trans-unit>
        <trans-unit id="3c574214b5c14cf6b803beb9ac59c1988cd63384" translate="yes" xml:space="preserve">
          <source>The automatic and manual perl installation leave precompiled paths inside perl executables. While these paths are overwriteable (see &lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;PERLLIB_PREFIX&lt;/a&gt;, &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;), some people may prefer binary editing of paths inside the executables/DLLs.</source>
          <target state="translated">自动和手动安装perl会将预编译路径保留在perl可执行文件中。尽管这些路径是可覆盖的（请参阅&lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;PERLLIB_PREFIX&lt;/a&gt;和&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;），但有些人可能更喜欢对可执行文件/ DLL中的路径进行二进制编辑。</target>
        </trans-unit>
        <trans-unit id="ff6dd9cd9205a8a816f4c19d3aaf08bb26c3152c" translate="yes" xml:space="preserve">
          <source>The available binary operators are:</source>
          <target state="translated">可用的二进制运算符有:</target>
        </trans-unit>
        <trans-unit id="68bb2a0daa0abd0313002b533bf42c71219aad2d" translate="yes" xml:space="preserve">
          <source>The available diagnostics are:</source>
          <target state="translated">可用的诊断方法有:</target>
        </trans-unit>
        <trans-unit id="d8dc3fd07c3386d7e5ad61722c90a54b40f250e5" translate="yes" xml:space="preserve">
          <source>The available fields in the structure are:</source>
          <target state="translated">该结构中可用的字段有:</target>
        </trans-unit>
        <trans-unit id="191f1bb9111a3757ed2ccf45e0e506ae45f1cb2d" translate="yes" xml:space="preserve">
          <source>The available locales depend on your operating system; try whether &lt;code&gt;locale -a&lt;/code&gt; shows them or man pages for &quot;locale&quot; or &quot;nlsinfo&quot; or the direct approach &lt;code&gt;ls /usr/lib/nls/loc&lt;/code&gt; or &lt;code&gt;ls /usr/lib/nls&lt;/code&gt; or &lt;code&gt;ls /usr/lib/locale&lt;/code&gt; . Not all the locales that your vendor supports are necessarily installed: please consult your operating system's documentation and possibly your local system administration. The locale names are probably something like &lt;code&gt;xx_XX.(ISO)?8859-N&lt;/code&gt; or &lt;code&gt;xx_XX.(ISO)?8859N&lt;/code&gt;, for example &lt;code&gt;fr_CH.ISO8859-1&lt;/code&gt; is the Swiss (CH) variant of French (fr), ISO Latin (8859) 1 (-1) which is the Western European character set.</source>
          <target state="translated">可用的语言环境取决于您的操作系统。尝试使用 &lt;code&gt;locale -a&lt;/code&gt; 显示它们还是&amp;ldquo; locale&amp;rdquo;或&amp;ldquo; nlsinfo&amp;rdquo;的手册页，或直接方法 &lt;code&gt;ls /usr/lib/nls/loc&lt;/code&gt; 或 &lt;code&gt;ls /usr/lib/nls&lt;/code&gt; 或 &lt;code&gt;ls /usr/lib/locale&lt;/code&gt; 。并非必须安装您的供应商支持的所有区域设置：请查阅操作系统的文档，也可以查阅本地系统管理信息。语言环境名称可能类似于 &lt;code&gt;xx_XX.(ISO)?8859-N&lt;/code&gt; 或 &lt;code&gt;xx_XX.(ISO)?8859N&lt;/code&gt; ，例如 &lt;code&gt;fr_CH.ISO8859-1&lt;/code&gt; 是法语（fr），ISO Latin（8859）的瑞士（CH）变体1（-1），这是西欧字符集。</target>
        </trans-unit>
        <trans-unit id="7b104fea0c3b585be7abd9fdcae3632fd9df0849" translate="yes" xml:space="preserve">
          <source>The available mechanisms are:</source>
          <target state="translated">现有的机制是:</target>
        </trans-unit>
        <trans-unit id="54ed46c150718473d8504c434e30cd577b337e90" translate="yes" xml:space="preserve">
          <source>The available options are:</source>
          <target state="translated">可用的选项有:</target>
        </trans-unit>
        <trans-unit id="456a0ea0217776b650b3498424ef7ee39f3e2d1e" translate="yes" xml:space="preserve">
          <source>The backend for the &lt;code&gt;SvPVbytex_force&lt;/code&gt; macro. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvPVbytex_force&lt;/code&gt; 宏的后端。始终改用宏。</target>
        </trans-unit>
        <trans-unit id="6595fe0b01dc35e2c9393282a00929c691d16bd4" translate="yes" xml:space="preserve">
          <source>The backend for the &lt;code&gt;SvPVutf8x_force&lt;/code&gt; macro. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvPVutf8x_force&lt;/code&gt; 宏的后端。始终改用宏。</target>
        </trans-unit>
        <trans-unit id="77f66884acce6cf3a3939cb28b0a48cb55b42d47" translate="yes" xml:space="preserve">
          <source>The backslash</source>
          <target state="translated">反斜杠</target>
        </trans-unit>
        <trans-unit id="d905ecd546099386ec13c3559da83e50955fb3c5" translate="yes" xml:space="preserve">
          <source>The backslash character &lt;code&gt;'\'&lt;/code&gt; is a metacharacter itself and needs to be backslashed:</source>
          <target state="translated">反斜杠字符 &lt;code&gt;'\'&lt;/code&gt; 本身是一个元字符，需要反斜杠：</target>
        </trans-unit>
        <trans-unit id="3991be487f455d5a6205c52bea36150b4cf4f97a" translate="yes" xml:space="preserve">
          <source>The backslash sequence can mean either ASCII- or Full-range Unicode, depending on various factors as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;.</source>
          <target state="translated">反斜杠序列可以表示ASCII或全范围Unicode，具体取决于各种因素，如&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符有效？在&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6d38a5acb41572fd3f6bf7b206aa3e31dca4b0b" translate="yes" xml:space="preserve">
          <source>The backtick operator does no translation of the return value, unlike &lt;b&gt;csh&lt;/b&gt;.</source>
          <target state="translated">与&lt;b&gt;csh&lt;/b&gt;不同，backtick运算符不转换返回值。</target>
        </trans-unit>
        <trans-unit id="ee45daa9d8b6e8559dda882c9eead013ce496d22" translate="yes" xml:space="preserve">
          <source>The backtick operator does variable interpolation without regard to the presence of single quotes in the command.</source>
          <target state="translated">反曲运算符进行变量插值,而不考虑命令中是否有单引号。</target>
        </trans-unit>
        <trans-unit id="8cd2b3706bb4ede8bd356d31a0615f4df40a7834" translate="yes" xml:space="preserve">
          <source>The backtrace returns the stack trace of the C call frames, with the symbol names (function names), the object names (like &quot;perl&quot;), and if it can, also the source code locations (&lt;a href=&quot;file:line&quot;&gt;file:line&lt;/a&gt;).</source>
          <target state="translated">backtrace返回C调用帧的堆栈跟踪，包括符号名称（函数名称），对象名称（如&amp;ldquo; perl&amp;rdquo;），如果可以的话，还返回源代码位置（&lt;a href=&quot;file:line&quot;&gt;file：line&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8bed32736e1b2815ccd999741f9407d4d43d0e8b" translate="yes" xml:space="preserve">
          <source>The base class implementation of the &lt;b&gt;interior_sequence()&lt;/b&gt; method simply returns the raw text of the interior sequence (as it occurred in the input) to the caller.</source>
          <target state="translated">&lt;b&gt;interior_sequence（）&lt;/b&gt;方法的基类实现只是将内部序列的原始文本（在输入中出现）返回给调用者。</target>
        </trans-unit>
        <trans-unit id="c9ddcb47643cb89116a0a922b50075bea2f25a0e" translate="yes" xml:space="preserve">
          <source>The base class implementation of this method returns the given text.</source>
          <target state="translated">该方法的基类实现返回给定的文本。</target>
        </trans-unit>
        <trans-unit id="3f5a827dc5c599719e7ecb28e524afa3505acc67" translate="yes" xml:space="preserve">
          <source>The base class implementation of this method simply prints the text block as it occurred in the input stream).</source>
          <target state="translated">该方法的基类实现只是简单地打印输入流中发生的文本块)。)</target>
        </trans-unit>
        <trans-unit id="df7aaeb92a14b1f8eaf4aa28b1e80496ba8b43fa" translate="yes" xml:space="preserve">
          <source>The base class implementation of this method simply prints the textblock (unmodified) to the output filehandle.</source>
          <target state="translated">该方法的基类实现只是简单地将文本块(未修改)打印到输出文件柄。</target>
        </trans-unit>
        <trans-unit id="303eecbc86fd9c0b4febc57eac0a317dd40331d4" translate="yes" xml:space="preserve">
          <source>The base class implementation of this method simply treats the raw POD command as normal block of paragraph text (invoking the &lt;b&gt;textblock()&lt;/b&gt; method with the command paragraph).</source>
          <target state="translated">此方法的基类实现仅将原始POD命令视为段落文本的常规块&lt;b&gt;（&lt;/b&gt;使用命令段落调用&lt;b&gt;textblock（）&lt;/b&gt;方法）。</target>
        </trans-unit>
        <trans-unit id="b322d5503c2a18a0550bcf3559879c8738ef1a3f" translate="yes" xml:space="preserve">
          <source>The base class' &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method is &lt;b&gt;not&lt;/b&gt; called.</source>
          <target state="translated">&lt;b&gt;不&lt;/b&gt;调用基类的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="869b6928181db8fd7439173a04a65a2b691f1a82" translate="yes" xml:space="preserve">
          <source>The base function, e.g., &lt;code&gt;isALPHA()&lt;/code&gt; , takes an octet (either a &lt;code&gt;char&lt;/code&gt; or a &lt;code&gt;U8&lt;/code&gt; ) as input and returns a boolean as to whether or not the character represented by that octet is (or on non-ASCII platforms, corresponds to) an ASCII character in the named class based on platform, Unicode, and Perl rules. If the input is a number that doesn't fit in an octet, FALSE is returned.</source>
          <target state="translated">基本函数（例如 &lt;code&gt;isALPHA()&lt;/code&gt; )将一个八位位组（ &lt;code&gt;char&lt;/code&gt; 或 &lt;code&gt;U8&lt;/code&gt; ）作为输入，并返回一个布尔值，该布尔值表示该八位位组所表示的字符是否为（或在非ASCII平台上对应）基于平台，Unicode和Perl规则的命名类中的ASCII字符。如果输入的数字不适合八位字节，则返回FALSE。</target>
        </trans-unit>
        <trans-unit id="b4a446b2fbdd7a1f128f546637cc4e95f828763e" translate="yes" xml:space="preserve">
          <source>The base port of Perl to Symbian only implements the basic POSIX-like functionality; it does not implement any further Symbian or Series 60, Series 80, or UIQ bindings for Perl.</source>
          <target state="translated">Perl 到 Symbian 的基本移植只实现了类似 POSIX 的基本功能;它没有为 Perl 实现任何进一步的 Symbian 或 60 系列、80 系列或 UIQ 绑定。</target>
        </trans-unit>
        <trans-unit id="7b0c0715021b7093caa628303290fd7be9406317" translate="yes" xml:space="preserve">
          <source>The base revision level of this package, from the</source>
          <target state="translated">这套软件的基本修订级别,是从</target>
        </trans-unit>
        <trans-unit id="1f81368d64cf4514ffa26dd1724286707ec25460" translate="yes" xml:space="preserve">
          <source>The base should be zero or between 2 and 36, inclusive. When the base is zero or omitted &lt;code&gt;strtol&lt;/code&gt; will use the string itself to determine the base: a leading &quot;0x&quot; or &quot;0X&quot; means hexadecimal; a leading &quot;0&quot; means octal; any other leading characters mean decimal. Thus, &quot;1234&quot; is parsed as a decimal number, &quot;01234&quot; as an octal number, and &quot;0x1234&quot; as a hexadecimal number.</source>
          <target state="translated">底数应为零或2到36（含）之间。当基数为零或省略时， &lt;code&gt;strtol&lt;/code&gt; 将使用字符串本身来确定基数：前导&amp;ldquo; 0x&amp;rdquo;或&amp;ldquo; 0X&amp;rdquo;表示十六进制；前导&amp;ldquo; 0&amp;rdquo;表示八进制；其他任何前导字符表示十进制。因此，&amp;ldquo; 1234&amp;rdquo;被解析为十进制数，&amp;ldquo; 01234&amp;rdquo;被解析为八进制数，&amp;ldquo; 0x1234&amp;rdquo;被解析为十六进制数。</target>
        </trans-unit>
        <trans-unit id="d0bf4e2fa899dc153c411be4c5898369064784f4" translate="yes" xml:space="preserve">
          <source>The base structure of a regop is defined in</source>
          <target state="translated">regop的基础结构定义在</target>
        </trans-unit>
        <trans-unit id="29446f6b360bcce933609abf092817cd60b4c651" translate="yes" xml:space="preserve">
          <source>The base64 encoded string returned is not padded to be a multiple of 4 bytes long. If you want interoperability with other base64 encoded md5 digests you might want to append the string &quot;==&quot; to the result.</source>
          <target state="translated">返回的 base64 编码字符串不会被填充为 4 字节长的倍数。如果你想与其他base64编码的md5摘要互操作,你可能需要在结果中添加字符串&quot;==&quot;。</target>
        </trans-unit>
        <trans-unit id="d8ffce64bc52685123cf17779b3bc30ab4b06b36" translate="yes" xml:space="preserve">
          <source>The basic &lt;code&gt;quant&lt;/code&gt; method that Locale::Maketext provides should be good for many languages. For some languages, it might be useful to modify it (or its constituent &lt;code&gt;numerate&lt;/code&gt; method) to take a plural form in the two-argument call to &lt;code&gt;quant&lt;/code&gt; (as in &quot;[quant,_1,files]&quot;) if it's all-around easier to infer the singular form from the plural, than to infer the plural form from the singular.</source>
          <target state="translated">基本的 &lt;code&gt;quant&lt;/code&gt; 方法地点:: Maketext提供应该是许多语言好。对于某些语言，如果它更容易实现，则对它（或其组成的 &lt;code&gt;numerate&lt;/code&gt; 方法）进行修改，使其在对 &lt;code&gt;quant&lt;/code&gt; 的两个参数的调用中采用复数形式（例如在&amp;ldquo; [quant，_1，files]&amp;rdquo;中）从复数推断单数形式，而不是从单数推断复数形式。</target>
        </trans-unit>
        <trans-unit id="bd8f1357516762bbb931d125e3d2a8b11599ee5f" translate="yes" xml:space="preserve">
          <source>The basic IPC facilities of Perl are built out of the good old Unix signals, named pipes, pipe opens, the Berkeley socket routines, and SysV IPC calls. Each is used in slightly different situations.</source>
          <target state="translated">Perl的基本IPC设施是由古老的Unix信号、命名管道、管道打开、Berkeley套接字例程和SysV IPC调用构建而成的。每一种都是在稍微不同的情况下使用的。</target>
        </trans-unit>
        <trans-unit id="9eaaba65a1dac8dd5fd38c2dd581e65245159383" translate="yes" xml:space="preserve">
          <source>The basic building block of Perl strings has always been a &quot;character&quot;. The changes basically come down to that the implementation no longer thinks that a character is always just a single byte.</source>
          <target state="translated">Perl字符串的基本构件一直是 &quot;字符&quot;。这些变化基本上归结为,实现不再认为一个字符总是只有一个字节。</target>
        </trans-unit>
        <trans-unit id="bf944598ad68a6908fe4ecd014a8a61a7b06d00e" translate="yes" xml:space="preserve">
          <source>The basic data structure is a PerlIOl:</source>
          <target state="translated">基本数据结构是一个PerlIOl。</target>
        </trans-unit>
        <trans-unit id="b5815b577f436fdec50339dbc9340f9c6b027e08" translate="yes" xml:space="preserve">
          <source>The basic design of Locale::Maketext is object-oriented, and Locale::Maketext is an abstract base class, from which you derive a &quot;project class&quot;. The project class (with a name like &quot;TkBocciBall::Localize&quot;, which you then use in your module) is in turn the base class for all the &quot;language classes&quot; for your project (with names &quot;TkBocciBall::Localize::it&quot;, &quot;TkBocciBall::Localize::en&quot;, &quot;TkBocciBall::Localize::fr&quot;, etc.).</source>
          <target state="translated">Locale::Maketext的基本设计是面向对象的,Locale::Maketext是一个抽象的基类,你可以从这个基类中派生出一个 &quot;项目类&quot;。这个项目类(名称为 &quot;TkBocciBall::Localize&quot;,然后在你的模块中使用)又是你的项目中所有 &quot;语言类&quot;(名称为 &quot;TkBocciBall::Localize::it&quot;、&quot;TkBocciBall::Localize::en&quot;、&quot;TkBocciBall::Localize::fr &quot;等)的基类。</target>
        </trans-unit>
        <trans-unit id="7d3d2515e50dae3561d665210b7c755d11c489ee" translate="yes" xml:space="preserve">
          <source>The basic design of Math::BigInt allows simple subclasses with very little work, as long as a few simple rules are followed:</source>
          <target state="translated">Math::BigInt的基本设计允许简单的子类,只要遵循一些简单的规则,几乎没有什么工作。</target>
        </trans-unit>
        <trans-unit id="1933c32469836b92b1e6ed87797ae53de2e4a98a" translate="yes" xml:space="preserve">
          <source>The basic files in a module look something like this.</source>
          <target state="translated">一个模块中的基本文件是这样的。</target>
        </trans-unit>
        <trans-unit id="341f2c68b6960d075517d469051ae07bb1f926b7" translate="yes" xml:space="preserve">
          <source>The basic idea of inserting, changing, or deleting a line from a text file involves reading and printing the file to the point you want to make the change, making the change, then reading and printing the rest of the file. Perl doesn't provide random access to lines (especially since the record input separator, &lt;code&gt;$/&lt;/code&gt; , is mutable), although modules such as &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; can fake it.</source>
          <target state="translated">从文本文件中插入，更改或删除行的基本思想涉及读取和打印文件至要进行更改的位置，进行更改，然后读取并打印文件的其余部分。Perl不提供对行的随机访问（特别是因为记录输入分隔符 &lt;code&gt;$/&lt;/code&gt; 是可变的），尽管诸如&lt;a href=&quot;tie/file&quot;&gt;Tie :: File之类的&lt;/a&gt;模块可以伪造它。</target>
        </trans-unit>
        <trans-unit id="99456abf05b5371483583dbfe86305dc116a350f" translate="yes" xml:space="preserve">
          <source>The basic purpose of this module is to print out either &quot;ok #&quot; or &quot;not ok #&quot; depending on if a given test succeeded or failed. Everything else is just gravy.</source>
          <target state="translated">这个模块的基本目的是打印出 &quot;ok #&quot;或 &quot;not ok #&quot;,这取决于某个测试是否成功或失败。其他的都是肉汁。</target>
        </trans-unit>
        <trans-unit id="64db8342329369b417d189ab1b4fe97232b396bf" translate="yes" xml:space="preserve">
          <source>The basic structure of this routine is to try to find the start- and/or end-points of where the pattern could match, and to ensure that the string is long enough to match the pattern. It tries to use more efficient methods over less efficient methods and may involve considerable cross-checking of constraints to find the place in the string that matches. For instance it may try to determine that a given fixed string must be not only present but a certain number of chars before the end of the string, or whatever.</source>
          <target state="translated">这个例程的基本结构是试图找到模式可能匹配的起始点和/或终点,并确保字符串足够长以匹配模式。它试图使用效率较高的方法,而不是效率较低的方法,并可能涉及大量的约束条件交叉检查,以找到字符串中匹配的位置。例如,它可能会尝试确定一个给定的固定字符串不仅必须存在,而且必须在字符串结束前有一定数量的字符,或者其他什么。</target>
        </trans-unit>
        <trans-unit id="80dbc79bfdbd83bc8576245228c2b94ef265f584" translate="yes" xml:space="preserve">
          <source>The basic unit of Perl testing is the ok. For each thing you want to test your program will print out an &quot;ok&quot; or &quot;not ok&quot; to indicate pass or fail. You do this with the &lt;code&gt;ok()&lt;/code&gt; function (see below).</source>
          <target state="translated">Perl测试的基本单元是可以的。对于您要测试的程序，将打印出&amp;ldquo; ok&amp;rdquo;或&amp;ldquo; not ok&amp;rdquo;以表示通过或失败。您可以使用 &lt;code&gt;ok()&lt;/code&gt; 函数执行此操作（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="9d2230b748e4308cffef19ddef65b44d6210c473" translate="yes" xml:space="preserve">
          <source>The behavior implied by the &lt;b&gt;use warnings&lt;/b&gt; pragma is not mandatory.</source>
          <target state="translated">&lt;b&gt;使用警告&lt;/b&gt;编译指示所隐含的行为不是强制性的。</target>
        </trans-unit>
        <trans-unit id="b5f143aadeaa7a8e64e344e87d8748a02f3060a4" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if LENGTH is greater than the length of the file.</source>
          <target state="translated">如果LENGTH大于文件的长度,则未定义该行为。</target>
        </trans-unit>
        <trans-unit id="2f1c51d0082c9a007ed014e64f75cf7ba3d7eb5f" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; on a directory handle depends on the operating system. On a system with dirfd(3) or similar, &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; on a directory handle returns the underlying file descriptor associated with the handle; on systems with no such support, it returns the undefined value, and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 在目录句柄上的行为取决于操作系统。在具有dirfd（3）或类似 &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 上，目录句柄上的fileno返回与该句柄相关联的基础文件描述符。在没有此类支持的系统上，它将返回未定义的值，并设置 &lt;code&gt;$!&lt;/code&gt; （errno）。</target>
        </trans-unit>
        <trans-unit id="ac7e84891cea0201bfbd9008ae17bfca2f62f2a2" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; within a regex code block (such as &lt;code&gt;/(?{...})/&lt;/code&gt; ) is subject to change.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; 表达式代码块（例如 &lt;code&gt;/(?{...})/&lt;/code&gt; ）中__SUB__的行为可能会更改。</target>
        </trans-unit>
        <trans-unit id="57f854aca9536e1cea9a0904019b31bc3e9f0356" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; on a directory handle depends on the operating system. On a system with dirfd(3) or similar, &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; on a directory handle returns the underlying file descriptor associated with the handle; on systems with no such support, it returns the undefined value, and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 在目录句柄上的行为取决于操作系统。在具有dirfd（3）或类似 &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 上，目录句柄上的fileno返回与该句柄相关联的基础文件描述符。在没有此类支持的系统上，它将返回未定义的值，并设置 &lt;code&gt;$!&lt;/code&gt; （errno）。</target>
        </trans-unit>
        <trans-unit id="00c21c5f299927d5b3bf2172e0cf7aff5e3373e8" translate="yes" xml:space="preserve">
          <source>The behavior of PREFIX is complicated and depends closely on how your Perl is configured. The resulting installation locations will vary from machine to machine and even different installations of Perl on the same machine. Because of this, its difficult to document where prefix will place your modules.</source>
          <target state="translated">PREFIX 的行为是复杂的,它取决于你的 Perl 的配置方式。由此产生的安装位置会因机器而异,甚至在同一台机器上安装的 Perl 也会不同。正因为如此,我们很难记录prefix将你的模块放在哪里。</target>
        </trans-unit>
        <trans-unit id="93dc5bd5efb782736e0942603b0c8fa1c754b397" translate="yes" xml:space="preserve">
          <source>The behavior of a smartmatch depends on what type of things its arguments are, as determined by the following table. The first row of the table whose types apply determines the smartmatch behavior. Because what actually happens is mostly determined by the type of the second operand, the table is sorted on the right operand instead of on the left.</source>
          <target state="translated">智能匹配的行为取决于它的参数是什么类型的东西,由下表决定。类型适用的表的第一行决定了smartmatch的行为。因为实际发生的事情主要是由第二个操作数的类型决定的,所以这个表是按右边的操作数而不是左边的操作数排序的。</target>
        </trans-unit>
        <trans-unit id="f414c994d5bce7014330ec5990bba640279929f3" translate="yes" xml:space="preserve">
          <source>The behavior of binary arithmetic operators depends on whether they're used on numbers or strings. The operators treat a string as a series of bits and work with that (the string &lt;code&gt;&quot;3&quot;&lt;/code&gt; is the bit pattern &lt;code&gt;00110011&lt;/code&gt; ). The operators work with the binary form of a number (the number &lt;code&gt;3&lt;/code&gt; is treated as the bit pattern &lt;code&gt;00000011&lt;/code&gt; ).</source>
          <target state="translated">二进制算术运算符的行为取决于它们是用于数字还是用于字符串。操作员将字符串视为一系列位并对其进行处理（字符串 &lt;code&gt;&quot;3&quot;&lt;/code&gt; 是位模式 &lt;code&gt;00110011&lt;/code&gt; ）。运算符使用数字的二进制形式（数字 &lt;code&gt;3&lt;/code&gt; 被视为位模式 &lt;code&gt;00000011&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="31eed332c2e58a5c0964723f7df67ca11212685a" translate="yes" xml:space="preserve">
          <source>The behavior of kill when a</source>
          <target state="translated">杀人的行为,当一个</target>
        </trans-unit>
        <trans-unit id="d59b4319820011355ea137761a33247562041027" translate="yes" xml:space="preserve">
          <source>The behavior of local() on non-existent members of composite types is subject to change in future.</source>
          <target state="translated">Local()在复合类型不存在的成员上的行为在未来可能会改变。</target>
        </trans-unit>
        <trans-unit id="7ad390bfcc2f23a71fab54461bd3359a98aa3f6d" translate="yes" xml:space="preserve">
          <source>The behavior of these operators is problematic (and subject to change) if either or both of the strings are encoded in UTF-8 (see &lt;a href=&quot;perlunicode#Byte-and-Character-Semantics&quot;&gt;Byte and Character Semantics in perlunicode&lt;/a&gt;.</source>
          <target state="translated">如果两个字符串中的一个或两个都以UTF-8编码，则这些运算符的行为是有问题的（并且可能会发生变化）（请参见&lt;a href=&quot;perlunicode#Byte-and-Character-Semantics&quot;&gt;perlunicode中的字节和字符语义）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a64f313f128b7624f16c0e92b9e3e3d919ea21bc" translate="yes" xml:space="preserve">
          <source>The behavior of tied arrays is not precisely the same as for regular arrays. For example:</source>
          <target state="translated">绑定数组的行为与普通数组的行为并不完全相同。比如说</target>
        </trans-unit>
        <trans-unit id="e661f036702b62721315aa1d02abc1020897293c" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;code&gt;%-&lt;/code&gt; is implemented via the &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;%-&lt;/code&gt; 的行为是通过&lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt;模块实现的。</target>
        </trans-unit>
        <trans-unit id="9f2f442d7e61435532ac3ebe398b46e4cb8b23b2" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;code&gt;&lt;a href=&quot;__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; within a regex code block (such as &lt;code&gt;/(?{...})/&lt;/code&gt; ) is subject to change.</source>
          <target state="translated">正则表达式代码块（例如 &lt;code&gt;/(?{...})/&lt;/code&gt; ）中 &lt;code&gt;&lt;a href=&quot;__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; 的行为可能会更改。</target>
        </trans-unit>
        <trans-unit id="ecf97494e2dabd3d3c4d6cda259bfc77c61ec233" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; within a regex code block (such as &lt;code&gt;/(?{...})/&lt;/code&gt; ) is subject to change.</source>
          <target state="translated">正则表达式代码块（例如 &lt;code&gt;/(?{...})/&lt;/code&gt; ）中 &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; 的行为可能会更改。</target>
        </trans-unit>
        <trans-unit id="893a97392f7263bab5a8304f6d49e881ca91ba83" translate="yes" xml:space="preserve">
          <source>The behaviour of File::Fetch can be altered by changing the following global variables:</source>
          <target state="translated">File::Fetch 的行为可以通过改变以下全局变量来改变。</target>
        </trans-unit>
        <trans-unit id="9225f0f55c56aed5c676f19da54d01c0121ae5ab" translate="yes" xml:space="preserve">
          <source>The behaviour of IPC::Cmd can be altered by changing the following global variables:</source>
          <target state="translated">IPC::Cmd的行为可以通过改变以下全局变量来改变。</target>
        </trans-unit>
        <trans-unit id="d64ba516b01f1b6dc31324edef30defa2d23432c" translate="yes" xml:space="preserve">
          <source>The behaviour of Module::Load::Conditional can be altered by changing the following global variables:</source>
          <target state="translated">Module::Load::Conditional 的行为可以通过改变以下全局变量来改变。</target>
        </trans-unit>
        <trans-unit id="47460fd55663b585106f39954f79fa9625db07e7" translate="yes" xml:space="preserve">
          <source>The behaviour of Params::Check can be altered by changing the following global variables:</source>
          <target state="translated">Params::Check的行为可以通过改变以下全局变量来改变。</target>
        </trans-unit>
        <trans-unit id="deb69a58f590c98de917558022e0254d1d774946" translate="yes" xml:space="preserve">
          <source>The behaviour of the function depends on the arguments:</source>
          <target state="translated">函数的行为取决于参数。</target>
        </trans-unit>
        <trans-unit id="6ec80595e1c021e2b98071cdf1e5337bff9c960f" translate="yes" xml:space="preserve">
          <source>The behaviour of this option is dependent on the type of &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">此选项的行为取决于 &lt;code&gt;$output&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="db32480c737ba8d1007a7ce0c4ddf37612954128" translate="yes" xml:space="preserve">
          <source>The behaviour of this option is dependent on the type of output data stream.</source>
          <target state="translated">该选项的行为取决于输出数据流的类型。</target>
        </trans-unit>
        <trans-unit id="ae8ebb83ae7fe5dc9eabc5af8c2815aedcfc7b2d" translate="yes" xml:space="preserve">
          <source>The belief that &amp;ldquo;small is beautiful&amp;rdquo;. Paradoxically, if you say something in a small language, it turns out big, and if you say it in a big language, it turns out small. Go figure.</source>
          <target state="translated">相信&amp;ldquo;小就是美&amp;rdquo;。矛盾的是，如果你用一种小语言说的话，结果就很大，而如果你用一种大语言说的话，结果就很小。去搞清楚。</target>
        </trans-unit>
        <trans-unit id="5dcff025d12c2edfa9fc4a567fa29e7990ea6873" translate="yes" xml:space="preserve">
          <source>The benefit of using &lt;code&gt;-Mlib=/foo&lt;/code&gt; over &lt;code&gt;-I/foo&lt;/code&gt; , is that the former will automagically remove any duplicated directories, while the latter will not.</source>
          <target state="translated">使用 &lt;code&gt;-Mlib=/foo&lt;/code&gt; 而不是 &lt;code&gt;-I/foo&lt;/code&gt; 的好处是，前者将自动删除所有重复的目录，而后者则不会。</target>
        </trans-unit>
        <trans-unit id="18900f73de54d7de200d866c09a29fdcc8cd53a3" translate="yes" xml:space="preserve">
          <source>The best algorithm depends on many things. On average, mergesort does fewer comparisons than quicksort, so it may be better when complicated comparison routines are used. Mergesort also takes advantage of pre-existing order, so it would be favored for using &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; to merge several sorted arrays. On the other hand, quicksort is often faster for small arrays, and on arrays of a few distinct values, repeated many times. You can force the choice of algorithm with this pragma, but this feels heavy-handed, so the subpragmas beginning with a &lt;code&gt;_&lt;/code&gt; may not persist beyond Perl 5.8. The default algorithm is mergesort, which will be stable even if you do not explicitly demand it. But the stability of the default sort is a side-effect that could change in later versions. If stability is important, be sure to say so with a</source>
          <target state="translated">最佳算法取决于很多事情。平均而言，mergesort的比较少于quicksort，因此使用复杂的比较例程时可能会更好。 Mergesort还利用了预先存在的顺序，因此，使用 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 合并多个排序的数组将受到青睐。另一方面，对于小型阵列，快速排序通常更快，而在具有几个不同值的阵列上，重复排序多次。您可以使用此编译指示来强制选择算法，但是这种感觉比较笨拙，因此子编译开头以 &lt;code&gt;_&lt;/code&gt; 开头可能不会在Perl 5.8之后持续存在。默认算法是mergesort，即使您没有明确要求，它也会保持稳定。但是默认排序的稳定性是一个副作用，在更高版本中可能会发生变化。如果稳定性很重要，请务必使用</target>
        </trans-unit>
        <trans-unit id="25c86820424aca2962f29e4f76c6234dbf83f89d" translate="yes" xml:space="preserve">
          <source>The best comments explain</source>
          <target state="translated">最佳评论解释</target>
        </trans-unit>
        <trans-unit id="97fb423abf47c78c911e5c1b325aae0069b921b4" translate="yes" xml:space="preserve">
          <source>The best way to avoid this oddity is to use this pragma RIGHT AFTER other modules are loaded. i.e.</source>
          <target state="translated">避免这种怪现象的最好方法是在加载完其他模块后立即使用这个参数,即</target>
        </trans-unit>
        <trans-unit id="7c4c0bd8f72ca6e9c0f331a5d5955e9a813aecd9" translate="yes" xml:space="preserve">
          <source>The best way to do this is to come up with a better algorithm. This can often make a dramatic difference. Jon Bentley's book</source>
          <target state="translated">最好的方法是提出一个更好的算法。这往往能带来戏剧性的变化。乔恩-本特利的书</target>
        </trans-unit>
        <trans-unit id="98421bf65e01fd86f5f0e0be25fe15a961951223" translate="yes" xml:space="preserve">
          <source>The best way to know for sure, and pick up many helpful suggestions, is to ask someone who knows. Comp.lang.perl.misc is read by just about all the people who develop modules and it's the best place to ask.</source>
          <target state="translated">最好的方法是去问那些知道的人,这样才能确定,并得到很多有用的建议。Comp.lang.perl.misc几乎被所有开发模块的人阅读,是询问的最好地方。</target>
        </trans-unit>
        <trans-unit id="f32d03eab0e341d80074007f2d5b494b8f3cdcfe" translate="yes" xml:space="preserve">
          <source>The best way to prevent this issue is to use waitpid(), as in the following example:</source>
          <target state="translated">防止这个问题的最好方法是使用waitpid(),如下面的例子。</target>
        </trans-unit>
        <trans-unit id="832c6230c64f67a2bd05effe72650dfa3f10cba9" translate="yes" xml:space="preserve">
          <source>The best way to unlock a file is to discard the object and untie the array. It is probably unsafe to unlock the file without also untying it, because if you do, changes may remain unwritten inside the object. That is why there is no shortcut for unlocking. If you really want to unlock the file prematurely, you know what to do; if you don't know what to do, then don't do it.</source>
          <target state="translated">解锁文件的最好方法是丢弃对象并解开数组。在没有解开绑定的情况下解锁文件可能是不安全的,因为如果你这样做了,更改可能会在对象中保持未写入的状态。这就是为什么没有解锁的捷径。如果你真的想提前解锁文件,你知道该怎么做;如果你不知道该怎么做,那就不要做。</target>
        </trans-unit>
        <trans-unit id="7b82cd1f6eaec920a028950cb809a9a88e952b55" translate="yes" xml:space="preserve">
          <source>The big advantage of this form is that it makes it much easier to write patterns with references that can be interpolated in larger patterns, even if the larger pattern also contains capture groups.</source>
          <target state="translated">这种形式的最大优点是,它使编写具有引用的模式变得更加容易,可以在更大的模式中进行插值,即使更大的模式也包含捕获组。</target>
        </trans-unit>
        <trans-unit id="d54be9133193e99a54a3311620e4e293b6619ef3" translate="yes" xml:space="preserve">
          <source>The big difference between the two types of filter is that the</source>
          <target state="translated">两种滤波器的最大区别是</target>
        </trans-unit>
        <trans-unit id="f4cd1959ad69d1f5686957182fd610eaea766644" translate="yes" xml:space="preserve">
          <source>The big difference between this filter and the previous example is the use of context data in the filter object. The filter object is based on a hash reference, and is used to keep various pieces of context information between calls to the filter function. All but two of the hash fields are used for error reporting. The first of those two, Enabled, is used by the filter to determine whether the debugging code should be given to the Perl parser. The second, InTraceBlock, is true when the filter has encountered a &lt;code&gt;DEBUG_BEGIN&lt;/code&gt; line, but has not yet encountered the following &lt;code&gt;DEBUG_END&lt;/code&gt; line.</source>
          <target state="translated">此过滤器与前面的示例之间的最大区别是在过滤器对象中使用了上下文数据。过滤器对象基于哈希引用，用于在过滤器调用之间保留各种上下文信息。除了两个散列字段外，所有其他字段均用于错误报告。过滤器使用这两个中的第一个Enabled来确定是否应将调试代码提供给Perl解析器。当过滤器遇到 &lt;code&gt;DEBUG_BEGIN&lt;/code&gt; 行但尚未遇到以下 &lt;code&gt;DEBUG_END&lt;/code&gt; 行时，第二个InTraceBlock为true 。</target>
        </trans-unit>
        <trans-unit id="52b096e99c9cb93102a3127548a39ec46a5e6a20" translate="yes" xml:space="preserve">
          <source>The big problem with this approach is that if you don't have control over source code being run in the child process, you can't control what it does with pipe buffering. Thus you can't just open a pipe to &lt;code&gt;cat -v&lt;/code&gt; and continually read and write a line from it.</source>
          <target state="translated">这种方法的最大问题是，如果您无法控制在子进程中运行的源代码，则无法控制其对管道缓冲的作用。因此，您不能只打开到 &lt;code&gt;cat -v&lt;/code&gt; 的管道并不断从中读取和写入一行。</target>
        </trans-unit>
        <trans-unit id="6486f0bee06ebbaca6cfa5b06fc46e3b4ab031bf" translate="yes" xml:space="preserve">
          <source>The biggest difference between Perl</source>
          <target state="translated">与Perl最大的区别是</target>
        </trans-unit>
        <trans-unit id="10223441fe4732f3b2ec434dced2b599c8ca3725" translate="yes" xml:space="preserve">
          <source>The biggest difference is that the first construction would reinstate the initial value of $var, irrespective of how control exits the block: &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, etc. It is a little bit more efficient as well.</source>
          <target state="translated">最大的不同是，第一个构造将恢复$ var的初始值，而不管控制如何退出该块： &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 等。它的效率也更高。</target>
        </trans-unit>
        <trans-unit id="3dfc4089faf0bdc2fe8184811a388d88572e3199" translate="yes" xml:space="preserve">
          <source>The biggest trap of all is forgetting to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; or use the &lt;b&gt;-w&lt;/b&gt; switch; see &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; and &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. The second biggest trap is not making your entire program runnable under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; . The third biggest trap is not reading the list of changes in this version of Perl; see &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perldelta.html&quot;&gt;perldelta&lt;/a&gt;.</source>
          <target state="translated">所有最大的陷阱就是忘记 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 或使用&lt;b&gt;-w&lt;/b&gt;开关。请参阅&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;和&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;。第二大陷阱是不能使整个程序在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 条件下严格运行。第三大陷阱是不阅读此版本的Perl中的更改列表。见&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perldelta.html&quot;&gt;perldelta&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86312f7a492ad492d886bde4c3d6e414b56f1879" translate="yes" xml:space="preserve">
          <source>The binary can be installed into the directory where perl normally resides on your machine with</source>
          <target state="translated">二进制文件可以安装到你的机器上perl通常所在的目录下,并使用</target>
        </trans-unit>
        <trans-unit id="153cbfaf81971e19f89aca8f0baea516f2171a06" translate="yes" xml:space="preserve">
          <source>The binary number may optionally be prefixed with &quot;0b&quot; or &quot;b&quot; unless &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; is set in</source>
          <target state="translated">除非在 &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; 位置设置了PERL_SCAN_DISALLOW_PREFIX，否则二进制数可以选择以&amp;ldquo; 0b&amp;rdquo;或&amp;ldquo; b&amp;rdquo;为前缀。</target>
        </trans-unit>
        <trans-unit id="5cc1bf2dab8b81eb0899313841a54927fbe7de16" translate="yes" xml:space="preserve">
          <source>The binary operators &lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;%&lt;/code&gt;&lt;code&gt;==&lt;/code&gt;&lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt; and the unary operators &lt;code&gt;-&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; will attempt to convert arguments to integers. If both conversions are possible without loss of precision, and the operation can be performed without loss of precision then the integer result is used. Otherwise arguments are converted to floating point format and the floating point result is used. The caching of conversions (as described above) means that the integer conversion does not throw away fractional parts on floating point numbers.</source>
          <target state="translated">二元运算符 &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; &lt;code&gt;==&lt;/code&gt; &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; 和一元运算符 &lt;code&gt;-&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 将尝试转换参数为整数。如果两次转换均可以进行而不会损失精度，并且可以执行运算而不会损失精度，则使用整数结果。否则，参数将转换为浮点格式，并使用浮点结果。转换的缓存（如上所述）意味着整数转换不会丢弃浮点数上的小数部分。</target>
        </trans-unit>
        <trans-unit id="1bc82db291b733618e76b84e58f74ac2a34e10aa" translate="yes" xml:space="preserve">
          <source>The bit complement operator &lt;code&gt;~&lt;/code&gt; may produce surprising results if used on strings containing characters with ordinal values above 255. In such a case, the results are consistent with the internal encoding of the characters, but not with much else. So don't do that. Similarly for &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt;: you will be operating on the internally-encoded bit patterns of the Unicode characters, not on the code point values, which is very probably not what you want.</source>
          <target state="translated">如果对包含序数值大于255的字符的字符串使用位补运算符 &lt;code&gt;~&lt;/code&gt; 可能会产生令人惊讶的结果。在这种情况下，结果与字符的内部编码一致，但与其他字符却没有太大的区别。所以不要那样做。对于 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt; 同样：您将对Unicode字符的内部编码位模式进行操作，而不是对代码点值进行操作，这可能不是您想要的。</target>
        </trans-unit>
        <trans-unit id="d35eca1d1b5259b3fe2499ebc8287ac008c74743" translate="yes" xml:space="preserve">
          <source>The bit of magic mentioned in the section title occurs when the regexp backtracks in the process of searching for a match. If the regexp backtracks over a code expression and if the variables used within are localized using &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;, the changes in the variables produced by the code expression are undone! Thus, if we wanted to count how many times a character got matched inside a group, we could use, e.g.,</source>
          <target state="translated">当正则表达式在搜索匹配项的过程中后退时，会出现标题部分中提到的神奇之处。如果正则表达式在代码表达式上回溯，并且其中使用的变量是使用 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 本地化的，则由代码表达式产生的变量的更改将被撤消！因此，如果我们想计算一个字符在一个组中匹配的次数，可以使用例如</target>
        </trans-unit>
        <trans-unit id="37e1e5bfe9f52e71b4a679c89e1ebe8060bbbb9c" translate="yes" xml:space="preserve">
          <source>The bit string operators, &lt;code&gt;&amp;amp; | ^ ~&lt;/code&gt; and (starting in v5.22) &lt;code&gt;&amp;amp;. |. ^.  ~.&lt;/code&gt; can operate on characters that don't fit into a byte. However, the current behavior is likely to change. You should not use these operators on strings that are encoded in UTF-8. If you're not sure about the encoding of a string, downgrade it before using any of these operators; you can use &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::utf8_downgrade() &lt;/a&gt;.</source>
          <target state="translated">位字符串运算符 &lt;code&gt;&amp;amp; | ^ ~&lt;/code&gt; 和（从v5.22开始） &lt;code&gt;&amp;amp;. |. ^. ~.&lt;/code&gt; 可以对不适合字节的字符进行操作。但是，当前的行为可能会改变。您不应在以UTF-8编码的字符串上使用这些运算符。如果不确定字符串的编码，请在使用任何这些运算符之前将其降级；否则，请执行以下操作。您可以使用&lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: utf8_downgrade（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="798f07dedaf152fa64ff8f36aa832d747a59dede" translate="yes" xml:space="preserve">
          <source>The bitmask</source>
          <target state="translated">位掩码</target>
        </trans-unit>
        <trans-unit id="7f65bb852dcddd2ea289cb9a819f8b8574f5d891" translate="yes" xml:space="preserve">
          <source>The bitwise operators such as &amp;amp; ^ | may return different results when operating on string or character data in a Perl program running on an EBCDIC platform than when run on an ASCII platform. Here is an example adapted from the one in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;:</source>
          <target state="translated">按位运算符，例如＆^ | 在EBCDIC平台上运行的Perl程序中对字符串或字符数据进行操作时，与在ASCII平台上运行时，可能返回不同的结果。这是从&lt;a href=&quot;perlop&quot;&gt;perlop中&lt;/a&gt;改编而成的示例：</target>
        </trans-unit>
        <trans-unit id="6f959154b03d16bc90e316f48db81d6452186e11" translate="yes" xml:space="preserve">
          <source>The bless() operator may be used to associate the object a reference points to with a package functioning as an object class. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">bless（）运算符可用于将参考指向的对象与充当对象类的包相关联。参见&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="62c6e0f6d8c3596c1d5e718f86c80115574f39a3" translate="yes" xml:space="preserve">
          <source>The blibdirs.ts target is deprecated. Depend on blibdirs instead.</source>
          <target state="translated">blibdirs.ts目标已被废弃。取而代之的是blibdirs。</target>
        </trans-unit>
        <trans-unit id="a0e8f481ec3e68f2eee488cdec2641a9ee4fc58d" translate="yes" xml:space="preserve">
          <source>The body of an object is never examined by an inside-out class, only its reference address is used. This allows for the body of an actual object to be</source>
          <target state="translated">对象的主体从来不会被内部类检查,只使用它的引用地址。这就使得实际对象的主体可以是</target>
        </trans-unit>
        <trans-unit id="5f03e7d3d4bcb5b96cdb3a0cb31e708fb5a607fe" translate="yes" xml:space="preserve">
          <source>The bond between a magical variable and its implementation class. See the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo; and Camel chapter 14, &amp;ldquo;Tied Variables&amp;rdquo;.</source>
          <target state="translated">魔术变量与其实现类之间的纽带。请参见Camel第27章&amp;ldquo;函数&amp;rdquo;中的 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 函数和Camel第14章&amp;ldquo;绑定变量&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3d1559aa0f7fe592165823ac05e1383677536c15" translate="yes" xml:space="preserve">
          <source>The boss thread does relatively little work. While tasks aren't necessarily performed faster than with any other method, it tends to have the best user-response times.</source>
          <target state="translated">老板线程做的工作相对较少。虽然任务的执行速度不一定比其他方法快,但它的用户响应时间往往是最好的。</target>
        </trans-unit>
        <trans-unit id="4d643dd67e77ce12596be6c04808856092685be2" translate="yes" xml:space="preserve">
          <source>The boss/worker model usually has one</source>
          <target state="translated">老板/工人模式通常有一个</target>
        </trans-unit>
        <trans-unit id="7cb25d97420dee45b6ff8e8d1d3ce98bc5f8cf9f" translate="yes" xml:space="preserve">
          <source>The bottom line is that Perl has always practiced &quot;Character Semantics&quot;, but with the advent of Unicode, that is now different than &quot;Byte Semantics&quot;.</source>
          <target state="translated">最重要的是,Perl一直奉行 &quot;字符语义&quot;,但随着Unicode的出现,现在已经不同于 &quot;字节语义 &quot;了。</target>
        </trans-unit>
        <trans-unit id="b78f42ecd2e198ccb02cbf24e0cb3e2f279a41cb" translate="yes" xml:space="preserve">
          <source>The bottom line is that using &lt;code&gt;/o&lt;/code&gt; is almost never a good idea.</source>
          <target state="translated">最重要的是，使用 &lt;code&gt;/o&lt;/code&gt; 几乎绝不是一个好主意。</target>
        </trans-unit>
        <trans-unit id="d9acf6e820cb60c3e92eccf3aa1b7d56933e4bb1" translate="yes" xml:space="preserve">
          <source>The bracketing construct &lt;code&gt;( ... )&lt;/code&gt; creates capture groups (also referred to as capture buffers). To refer to the current contents of a group later on, within the same pattern, use &lt;code&gt;\g1&lt;/code&gt; (or &lt;code&gt;\g{1}&lt;/code&gt; ) for the first, &lt;code&gt;\g2&lt;/code&gt; (or &lt;code&gt;\g{2}&lt;/code&gt; ) for the second, and so on. This is called a</source>
          <target state="translated">包围结构 &lt;code&gt;( ... )&lt;/code&gt; 创建捕获组（也称为捕获缓冲区）。要稍后在同一模式下引用组的当前内容，请首先使用 &lt;code&gt;\g1&lt;/code&gt; （或 &lt;code&gt;\g{1}&lt;/code&gt; ），然后使用 &lt;code&gt;\g2&lt;/code&gt; （或 &lt;code&gt;\g{2}&lt;/code&gt; ），依此类推。这叫做</target>
        </trans-unit>
        <trans-unit id="e36070a31e90d55267b22c4c53ba4bb76bc4e98b" translate="yes" xml:space="preserve">
          <source>The btree format allows arbitrary key/value pairs to be stored in a sorted, balanced binary tree.</source>
          <target state="translated">btree格式允许任意键/值对存储在一个排序的、平衡的二进制树中。</target>
        </trans-unit>
        <trans-unit id="3d23a8ab70ee632140bebef4fc4a9cc18111b1ba" translate="yes" xml:space="preserve">
          <source>The bucket usage information provided by &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(%hash)&lt;/a&gt;&lt;/code&gt; is not available. What this means is that using %tied_hash in boolean context doesn't work right (currently this always tests false, regardless of whether the hash is empty or hash elements).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(%hash)&lt;/a&gt;&lt;/code&gt; 提供的存储桶使用情况信息不可用。这意味着在布尔上下文中使用％tied_hash不能正常工作（当前，无论哈希为空还是哈希元素，它始终测试为false）。</target>
        </trans-unit>
        <trans-unit id="ca05fef836743ccb209a85580910e15958fde72d" translate="yes" xml:space="preserve">
          <source>The buffer for this layer currently holds data written to it but not sent to next layer.</source>
          <target state="translated">本层的缓冲区目前保存着写入它的数据,但没有发送到下一层。</target>
        </trans-unit>
        <trans-unit id="7906bb96b8244bc39b3b8a2c3c66a3c0af5824fe" translate="yes" xml:space="preserve">
          <source>The buffer for this layer currently holds unconsumed data read from layer below.</source>
          <target state="translated">本层的缓冲区目前保存着从下层读取的未消耗的数据。</target>
        </trans-unit>
        <trans-unit id="6ea453ad94b47d04a0aaf4ba8a7c5a8d66aac757" translate="yes" xml:space="preserve">
          <source>The buffer for this layer should be filled (for read) from layer below. When you &quot;subclass&quot; PerlIOBuf layer, you want to use its</source>
          <target state="translated">这个层的缓冲区应该由下面的层来填充(用于读取)。当你 &quot;子类 &quot;PerlIOBuf层时,你想使用它的</target>
        </trans-unit>
        <trans-unit id="0b0da711f6da8dbe92866cc34757189eaf594fa5" translate="yes" xml:space="preserve">
          <source>The buffer parameters can either be a scalar or a scalar reference.</source>
          <target state="translated">缓冲区参数可以是一个标量,也可以是一个标量引用。</target>
        </trans-unit>
        <trans-unit id="3180fcf8985754e2c180a612db1e7626b0444c64" translate="yes" xml:space="preserve">
          <source>The buffer size parameter is ignored. If either argument to &lt;code&gt;copy&lt;/code&gt; is a handle to an opened file, then data is copied using Perl operators, and no effort is made to preserve file attributes or record structure.</source>
          <target state="translated">缓冲区大小参数将被忽略。如果要 &lt;code&gt;copy&lt;/code&gt; 任何一个参数都是打开文件的句柄，则使用Perl运算符复制数据，并且不进行任何操作来保留文件属性或记录结构。</target>
        </trans-unit>
        <trans-unit id="3a3e5d3d24ac3da5ee8782f3b635bd002510477d" translate="yes" xml:space="preserve">
          <source>The build procedure is completely standard:</source>
          <target state="translated">构建程序是完全标准的。</target>
        </trans-unit>
        <trans-unit id="eb86001bb0f7c51ab8f75bc125c6599630a9618e" translate="yes" xml:space="preserve">
          <source>The build process is dependent on the location of the NetWare SDK. Once the Tools &amp;amp; SDK are installed, the build environment has to be setup. The following batch files setup the environment.</source>
          <target state="translated">生成过程取决于NetWare SDK的位置。安装工具和SDK后，必须设置构建环境。以下批处理文件设置了环境。</target>
        </trans-unit>
        <trans-unit id="66dc024a88d2f72023e3d27090cc749788a83502" translate="yes" xml:space="preserve">
          <source>The build requires CodeWarrior compiler and linker. In addition, the &quot;NetWare SDK&quot;, &quot;NLM &amp;amp; NetWare Libraries for C&quot; and &quot;NetWare Server Protocol Libraries for C&quot;, all available at &lt;a href=&quot;http://developer.novell.com/wiki/index.php/Category:Novell_Developer_Kit&quot;&gt;http://developer.novell.com/wiki/index.php/Category:Novell_Developer_Kit&lt;/a&gt;, are required. Microsoft Visual C++ version 4.2 or later is also required.</source>
          <target state="translated">该构建需要CodeWarrior编译器和链接器。此外，&amp;ldquo; NetWare SDK&amp;rdquo;，&amp;ldquo; C的NLM和NetWare库&amp;rdquo;和&amp;ldquo; C的NetWare服务器协议库&amp;rdquo;可从&lt;a href=&quot;http://developer.novell.com/wiki/index.php/Category:Novell_Developer_Kit&quot;&gt;http://developer.novell.com/wiki/index.php/Category:Novell_Developer_Kit获得&lt;/a&gt;，是必须的。还需要Microsoft Visual C ++ 4.2或更高版本。</target>
        </trans-unit>
        <trans-unit id="2ba6778f7060ad4df8f24bbc1bdc4f90be4ddf10" translate="yes" xml:space="preserve">
          <source>The build system that Perl uses is called metaconfig. This system is maintained separately from the Perl core.</source>
          <target state="translated">Perl使用的构建系统叫做metaconfig。这个系统与Perl核心是分开维护的。</target>
        </trans-unit>
        <trans-unit id="942228e32ca9b0927fd55428e4055983f76b4ec4" translate="yes" xml:space="preserve">
          <source>The built-ins &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; can also be overridden, but due to special magic, their original syntax is preserved, and you don't have to define a prototype for their replacements. (You can't override the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; syntax, though).</source>
          <target state="translated">内置的 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 也可以被覆盖，但是由于特殊的魔法，它们的原始语法得以保留，您不必为它们的替换定义原型。（不过，您不能覆盖 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; 语法）。</target>
        </trans-unit>
        <trans-unit id="296da44de5630b90165936266a71322d333ad173" translate="yes" xml:space="preserve">
          <source>The bulk of the &lt;code&gt;B&lt;/code&gt; module is the methods for accessing fields of these structures.</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; 模块的大部分是用于访问这些结构的字段的方法。</target>
        </trans-unit>
        <trans-unit id="8b0e07205f847f3c71cfbfff3ef8429008605c63" translate="yes" xml:space="preserve">
          <source>The bulk of the work is done by the &lt;code&gt;check_num()&lt;/code&gt; subroutine, which takes a reference to its input queue and a prime number that it's responsible for. After pulling in the input queue and the prime that the subroutine is checking (line 11), we create a new queue (line 13) and reserve a scalar for the thread that we're likely to create later (line 12).</source>
          <target state="translated">大部分工作由 &lt;code&gt;check_num()&lt;/code&gt; 子例程完成，该子例程引用其输入队列和它负责的质数。在输入了输入队列和子例程正在检查的素数之后（第11行），我们创建了一个新队列（第13行），并为以后可能创建的线程保留了标量（第12行）。</target>
        </trans-unit>
        <trans-unit id="791442532861b4bafb692d53705783ee9bec0932" translate="yes" xml:space="preserve">
          <source>The byteorder on the platform where Perl was built is also available via &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">还可以通过&lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;获得构建Perl的平台上的字节序：</target>
        </trans-unit>
        <trans-unit id="2a22ccaf7c6bd804cab616f223b89fb4c998d9e8" translate="yes" xml:space="preserve">
          <source>The byteorder on the platform where Perl was built is also available via &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">还可以通过&lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;获得构建Perl的平台上的字节序：</target>
        </trans-unit>
        <trans-unit id="95b43b81c5e8935337a225eeb872942eb25c3b63" translate="yes" xml:space="preserve">
          <source>The cache itself consumes about 310 bytes per cached record, so if your file has many short records, you may want to decrease the cache memory limit, or else the cache overhead may exceed the size of the cached data.</source>
          <target state="translated">缓存本身每条缓存记录大约消耗310字节,所以如果你的文件有很多短记录,你可能要减少缓存内存限制,否则缓存开销可能超过缓存数据的大小。</target>
        </trans-unit>
        <trans-unit id="64eab8d82090d9e1801adf3ce396bf3e93f4b8ee" translate="yes" xml:space="preserve">
          <source>The call graph looks like this:</source>
          <target state="translated">调用图是这样的。</target>
        </trans-unit>
        <trans-unit id="438b1deafb199f6d78cd53708e2c5819899363df" translate="yes" xml:space="preserve">
          <source>The call is implemented in terms of either Perl's or your system's native fread(3) library function. To get a true read(2) system call, see &lt;a href=&quot;#sysread-FILEHANDLE%2cSCALAR%2cLENGTH%2cOFFSET&quot;&gt;sysread&lt;/a&gt;.</source>
          <target state="translated">该调用是根据Perl或系统的本机fread（3）库函数实现的。要获得真正的read（2）系统调用，请参见&lt;a href=&quot;#sysread-FILEHANDLE%2cSCALAR%2cLENGTH%2cOFFSET&quot;&gt;sysread&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="743d372bad1a8cad2381aca07cbb441a9da8196f" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;XSLoader::load()&lt;/code&gt; (or &lt;code&gt;bootstrap()&lt;/code&gt; ) calls the module's bootstrap code. For modules build by</source>
          <target state="translated">对 &lt;code&gt;XSLoader::load()&lt;/code&gt; （或 &lt;code&gt;bootstrap()&lt;/code&gt; ）的调用将调用模块的引导代码。对于模块构建者</target>
        </trans-unit>
        <trans-unit id="3ec6acbf7a32681ee91fb2a933c9fbfbb9c3da0d" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;from_to()&lt;/code&gt; changes the bytes in &lt;code&gt;$data&lt;/code&gt; , but nothing material about the nature of the string has changed as far as Perl is concerned. Both before and after the call, the string &lt;code&gt;$data&lt;/code&gt; contains just a bunch of 8-bit bytes. As far as Perl is concerned, the encoding of the string remains as &quot;system-native 8-bit bytes&quot;.</source>
          <target state="translated">对 &lt;code&gt;from_to()&lt;/code&gt; 的调用更改了 &lt;code&gt;$data&lt;/code&gt; 的字节，但是就Perl而言，关于字符串性质的任何实质性更改都没有改变。在调用之前和之后，字符串 &lt;code&gt;$data&lt;/code&gt; 仅包含一堆8位字节。就Perl而言，字符串的编码仍为&amp;ldquo;系统本地8位字节&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ad70e5f54776fc0924c4e470d4ee9b439b4f2953" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;warnings::register&lt;/code&gt; will create a new warnings category called &quot;MyMod::Abc&quot;, i.e. the new category name matches the current package name. The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; function in the module will display a warning message if it gets given a relative path as a parameter. This warnings will only be displayed if the code that uses &lt;code&gt;MyMod::Abc&lt;/code&gt; has actually enabled them with the &lt;code&gt;warnings&lt;/code&gt; pragma like below.</source>
          <target state="translated">对 &lt;code&gt;warnings::register&lt;/code&gt; 的调用将创建一个名为&amp;ldquo; MyMod :: Abc&amp;rdquo;的新警告类别，即新类别名称与当前程序包名称匹配。如果给定相对路径作为参数，则模块中的 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 函数将显示警告消息。仅当使用 &lt;code&gt;MyMod::Abc&lt;/code&gt; 的代码实际启用了 &lt;code&gt;warnings&lt;/code&gt; 如下所示）时才显示此警告。</target>
        </trans-unit>
        <trans-unit id="de39aad93d96a8313ed651448e2dc806dfea3c70" translate="yes" xml:space="preserve">
          <source>The call to GetOptions() parses the command line arguments that are present in &lt;code&gt;@ARGV&lt;/code&gt; and sets the option variable to the value &lt;code&gt;1&lt;/code&gt; if the option did occur on the command line. Otherwise, the option variable is not touched. Setting the option value to true is often called</source>
          <target state="translated">调用GetOptions（）会解析 &lt;code&gt;@ARGV&lt;/code&gt; 中存在的命令行参数，如果选项确实出现在命令行中，则将选项变量设置为值 &lt;code&gt;1&lt;/code&gt; 。否则，不会触碰选项变量。通常将选项值设置为true</target>
        </trans-unit>
        <trans-unit id="171eeffe94ffcbbb77d480c5aae1700315d244fd" translate="yes" xml:space="preserve">
          <source>The call to the program that is able to compile perlmain.c. Defaults to $(CC).</source>
          <target state="translated">调用能够编译perlmain.c的程序,默认为$(CC)。</target>
        </trans-unit>
        <trans-unit id="acb2e8bffbae50387da55c62d3573564cf939bc2" translate="yes" xml:space="preserve">
          <source>The call to this method is currently made</source>
          <target state="translated">目前对该方法的调用是</target>
        </trans-unit>
        <trans-unit id="af59be20c7eb663137f8b78548e36aec5ac0b8fe" translate="yes" xml:space="preserve">
          <source>The callback methods &lt;code&gt;start_code&lt;/code&gt; and &lt;code&gt;end_code&lt;/code&gt; emits the &lt;code&gt;code&lt;/code&gt; tags before and after &lt;code&gt;handle_code&lt;/code&gt; is invoked, so you might want to override these together with &lt;code&gt;handle_code&lt;/code&gt; if this wrapping isn't suitable.</source>
          <target state="translated">调用 &lt;code&gt;handle_code&lt;/code&gt; 之前和之后，回调方法 &lt;code&gt;start_code&lt;/code&gt; 和 &lt;code&gt;end_code&lt;/code&gt; 都会发出 &lt;code&gt;code&lt;/code&gt; 标签，因此，如果此包装不适合，则可能需要将它们与 &lt;code&gt;handle_code&lt;/code&gt; 一起重写。</target>
        </trans-unit>
        <trans-unit id="6e4b93d3f2cc24bc6cb3f704f926b3838cfb6c18" translate="yes" xml:space="preserve">
          <source>The callback routine's return value is not used for anything.</source>
          <target state="translated">回调例程的返回值不用于任何事情。</target>
        </trans-unit>
        <trans-unit id="df4f95aac52b872cdb00cff71137de388b659b49" translate="yes" xml:space="preserve">
          <source>The callbacks are called for each opcode visited by Concise, in the same order as they are added. Each subroutine is passed five parameters.</source>
          <target state="translated">Concise所访问的每一个操作码都会调用回调,顺序与它们被添加的顺序相同。每个子程序都会被传递五个参数。</target>
        </trans-unit>
        <trans-unit id="cf3ef404c2544a6e1a747fcdf0563fa6c44b7664" translate="yes" xml:space="preserve">
          <source>The caller is responsible for incrementing the reference count of the array returned if it wants to keep the structure. Hence, if you have created a temporary value that you keep no pointer to, &lt;code&gt;sv_2mortal()&lt;/code&gt; to ensure that it is disposed of correctly. If you have cached your return value, then return a pointer to it without changing the reference count.</source>
          <target state="translated">如果要保留结构，则调用方负责递增返回数组的引用计数。因此，如果您创建了一个没有指针的临时值，请使用 &lt;code&gt;sv_2mortal()&lt;/code&gt; 来确保正确处理该值。如果您已缓存了返回值，则在不更改引用计数的情况下返回指向它的指针。</target>
        </trans-unit>
        <trans-unit id="261ce3b0bcf399d133cb40e0b62c874dd44f485a" translate="yes" xml:space="preserve">
          <source>The calling context of the function (scalar or list context) is propagated to the normalizer. This means that if the memoized function will treat its arguments differently in list context than it would in scalar context, you can have the normalizer function select its behavior based on the results of &lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;&lt;/code&gt;. Even if called in a list context, a normalizer should still return a single string.</source>
          <target state="translated">函数的调用上下文（标量或列表上下文）被传播到规范化器。这意味着如果备注函数在列表上下文中与在标量上下文中对参数的处理方式不同，则可以使normalizer函数根据 &lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;&lt;/code&gt; 的结果选择其行为。即使在列表上下文中调用，规范化器仍应返回单个字符串。</target>
        </trans-unit>
        <trans-unit id="8bf2965af27484a7764a15d3bbb805341a4c18b1" translate="yes" xml:space="preserve">
          <source>The canonical list of operator names is the contents of the array PL_op_name defined and initialised in file</source>
          <target state="translated">操作员名称的规范列表是在文件PL_op_name中定义和初始化的数组PL_op_name的内容。</target>
        </trans-unit>
        <trans-unit id="c754480a0b53533e23d99a04ff3b99e5ce4e8f9f" translate="yes" xml:space="preserve">
          <source>The canonical name for the host if the &lt;code&gt;AI_CANONNAME&lt;/code&gt; flag was provided, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise. This field will only be present on the first returned address.</source>
          <target state="translated">如果提供了 &lt;code&gt;AI_CANONNAME&lt;/code&gt; 标志，则为主机的规范名称，否则为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。该字段仅出现在第一个返回的地址上。</target>
        </trans-unit>
        <trans-unit id="2ddb3e29fbb2261125aa3969a5b44d4db9de4c6e" translate="yes" xml:space="preserve">
          <source>The canonical name of a delegate distribution to install instead. Useful when a new version, although it tests OK itself, breaks something else or a developer release or a fork is already uploaded that is better than the last released version.</source>
          <target state="translated">代替安装的委托发行版的规范名称。当一个新的版本,虽然它本身测试正常,但是它破坏了一些其他的东西,或者已经上传了一个比上一个版本更好的开发者版本或fork时,这个名字很有用。</target>
        </trans-unit>
        <trans-unit id="69da2adf0aadd37547ac813fb993aa6ad1179ac5" translate="yes" xml:space="preserve">
          <source>The canonical name of a given encoding does not necessarily agree with IANA Character Set Registry, commonly seen as &lt;code&gt;Content-Type:
text/plain; charset=&lt;i&gt;WHATEVER&lt;/i&gt;&lt;/code&gt;. For most cases, the canonical name works, but sometimes it does not, most notably with &quot;utf-8-strict&quot;.</source>
          <target state="translated">给定编码的规范名称不一定与IANA字符集注册中心一致，通常被视为 &lt;code&gt;Content-Type: text/plain; charset=&lt;i&gt;WHATEVER&lt;/i&gt;&lt;/code&gt; 。在大多数情况下，规范名称有效，但有时不起作用，最明显的是使用&amp;ldquo; utf-8-strict&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7959d4667d41c3277e70505dbf41353d2303db33" translate="yes" xml:space="preserve">
          <source>The capability whose string is to be output.</source>
          <target state="translated">要输出字符串的能力。</target>
        </trans-unit>
        <trans-unit id="a744fed76bc528e01936c6092d667062609b77e5" translate="yes" xml:space="preserve">
          <source>The caret allows for simpler stringification of compiled regular expressions. These look like</source>
          <target state="translated">撇号允许对编译后的正则表达式进行更简单的字符串化。这些表达式看起来像</target>
        </trans-unit>
        <trans-unit id="743958808118b71ad904b9a5f8eed52c69df8dc0" translate="yes" xml:space="preserve">
          <source>The caret tells Perl that this cluster doesn't inherit the flags of any surrounding pattern, but uses the system defaults (&lt;code&gt;d-imsx&lt;/code&gt; ), modified by any flags specified.</source>
          <target state="translated">插入符号告诉Perl，此集群不继承任何周围模式的标志，而是使用系统默认值（ &lt;code&gt;d-imsx&lt;/code&gt; ），该默认值由指定的任何标志修改。</target>
        </trans-unit>
        <trans-unit id="d4cdf247822c1c118e5e2a91cdbbd856905f935f" translate="yes" xml:space="preserve">
          <source>The case used for capitals that are followed by lowercase characters instead of by more capitals. Sometimes called sentence case or headline case. English doesn&amp;rsquo;t use Unicode titlecase, but casing rules for English titles are more complicated than simply capitalizing each word&amp;rsquo;s first character.</source>
          <target state="translated">大小写用于大写字母，后跟小写字符，而不是大写字母。有时称为句子大小写或标题大写。英文不使用Unicode标题，但是英文标题的大小写规则比简单地大写每个单词的第一个字符更为复杂。</target>
        </trans-unit>
        <trans-unit id="d711d105fb7ff9ba5105330930cd96c20b047fd3" translate="yes" xml:space="preserve">
          <source>The casemap used in Unicode when comparing or matching without regard to case. Comparing lower-, title-, or uppercase are all unreliable due to Unicode&amp;rsquo;s complex, one-to-many case mappings. Foldcase is a &lt;b&gt;lowercase&lt;/b&gt; variant (using a partially decomposed &lt;b&gt;normalization&lt;/b&gt; form for certain codepoints) created specifically to resolve this.</source>
          <target state="translated">比较或匹配时不考虑大小写的情况下，Unicode中使用的casemap。由于Unicode复杂的一对多大小写映射，因此比较小写，标题或大写都是不可靠的。折叠大写是专门为解决此问题而创建的&lt;b&gt;小写&lt;/b&gt;变体（对某些代码点使用部分分解的&lt;b&gt;标准化&lt;/b&gt;形式）。</target>
        </trans-unit>
        <trans-unit id="f16ecea32ddc45aef48d30c6428e765b0124d50c" translate="yes" xml:space="preserve">
          <source>The cases when the shell is used are:</source>
          <target state="translated">壳时的情况是:</target>
        </trans-unit>
        <trans-unit id="90158421e0d058f44be7171e42f898369c12eafb" translate="yes" xml:space="preserve">
          <source>The categories are currently:</source>
          <target state="translated">这些类别目前是:</target>
        </trans-unit>
        <trans-unit id="998a96285bef3fbf35e88e13ee25ef0e94c840c0" translate="yes" xml:space="preserve">
          <source>The character following &lt;code&gt;\c&lt;/code&gt; is mapped to some other character as shown in the table:</source>
          <target state="translated">&lt;code&gt;\c&lt;/code&gt; 的字符映射到其他一些字符，如下表所示：</target>
        </trans-unit>
        <trans-unit id="0182edc494649671b24bec81ea32f4948632cbbf" translate="yes" xml:space="preserve">
          <source>The character set /adul flags cancel each other out. So, in this example,</source>
          <target state="translated">字符集/adul标志相互抵消。所以,在这个例子中,</target>
        </trans-unit>
        <trans-unit id="9d4fb2a2ad59e5fb5f2e1ac776d2184744805bf9" translate="yes" xml:space="preserve">
          <source>The character set rules are determined by an enum that is contained in this field. This is still experimental and subject to change, but the current interface returns the rules by use of the in-line function &lt;code&gt;get_regex_charset(const U32 flags)&lt;/code&gt; . The only currently documented value returned from it is REGEX_LOCALE_CHARSET, which is set if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect. If present in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; will use the locale dependent definition of whitespace when RXf_SKIPWHITE or RXf_WHITE is in effect. ASCII whitespace is defined as per &lt;a href=&quot;perlapi#isSPACE&quot;&gt;isSPACE&lt;/a&gt;, and by the internal macros &lt;code&gt;is_utf8_space&lt;/code&gt; under UTF-8, and &lt;code&gt;isSPACE_LC&lt;/code&gt; under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
locale&lt;/code&gt; .</source>
          <target state="translated">字符集规则由此字段中包含的枚举确定。这仍然是实验性的，并且可能会发生变化，但是当前接口使用 &lt;code&gt;get_regex_charset(const U32 flags)&lt;/code&gt; 函数get_regex_charset（const U32 flags）返回规则。从它返回的当前唯一记录的值是REGEX_LOCALE_CHARSET，如果 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 有效，则设置该值。如果存在于 &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; 中，则当RXf_SKIPWHITE或RXf_WHITE有效时， &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 将使用与语言环境有关的空白定义。空格被定义为每ASCII &lt;a href=&quot;perlapi#isSPACE&quot;&gt;isspace为&lt;/a&gt;，与由内部宏 &lt;code&gt;is_utf8_space&lt;/code&gt; 下UTF-8，和 &lt;code&gt;isSPACE_LC&lt;/code&gt; 下 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a9c5d866ba1d6358a34fce2d9ed9c3acf7a55d6" translate="yes" xml:space="preserve">
          <source>The character set to declare in the Content-Type meta tag created by default for &lt;code&gt;html_header_tags&lt;/code&gt; . Note that this option will be ignored if the value of &lt;code&gt;html_header_tags&lt;/code&gt; is changed. Defaults to &quot;ISO-8859-1&quot;.</source>
          <target state="translated">在默认情况下为 &lt;code&gt;html_header_tags&lt;/code&gt; 创建的Content-Type元标记中声明的字符集。请注意，如果更改 &lt;code&gt;html_header_tags&lt;/code&gt; 的值，则将忽略此选项。默认为&amp;ldquo; ISO-8859-1&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="71daab686bee256e6d597c2f8159505d9e02d07d" translate="yes" xml:space="preserve">
          <source>The characters &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; are special in the L&amp;lt;...&amp;gt; context. Although the hyperlink parser does its best to determine which &quot;/&quot; is text and which is a delimiter in case of doubt, one ought to escape these literal characters like this:</source>
          <target state="translated">人物 &lt;code&gt;|&lt;/code&gt; 和 &lt;code&gt;/&lt;/code&gt; 在L &amp;lt;...&amp;gt;上下文中是特殊的。尽管超链接解析器会尽力确定哪个&amp;ldquo; /&amp;rdquo;是文本，哪个是定界符（在有疑问的情况下），但应该避免这样的文字字符：</target>
        </trans-unit>
        <trans-unit id="9e5d809d420604eb5bdc15b23bb82aec938490ad" translate="yes" xml:space="preserve">
          <source>The characters used to recall a command or spawn a shell. By default, both are set to &lt;code&gt;!&lt;/code&gt; , which is unfortunate.</source>
          <target state="translated">用于重新调用命令或生成外壳的字符。默认情况下，两者都设置为 &lt;code&gt;!&lt;/code&gt; ，这是不幸的。</target>
        </trans-unit>
        <trans-unit id="ffd9954b7982718c7437be17e29fbfd3df1a4fe1" translate="yes" xml:space="preserve">
          <source>The check routine returns the node which should be inserted into the tree (if the top-level node was not modified, check routine returns its argument).</source>
          <target state="translated">检查例程返回应该插入树中的节点(如果顶层节点没有被修改,检查例程返回其参数)。</target>
        </trans-unit>
        <trans-unit id="47475762ffe9e435213b5064a86af730e143c18a" translate="yes" xml:space="preserve">
          <source>The chunk of memory which is pointed to by &lt;code&gt;p&lt;/code&gt; is Safefree()ed at the end of</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 指向的内存块在末尾进行Safefree（）</target>
        </trans-unit>
        <trans-unit id="16a3c0a4c50db86e628588170d93fcb36250d2c0" translate="yes" xml:space="preserve">
          <source>The class created by &lt;code&gt;struct&lt;/code&gt; must not be a subclass of another class other than &lt;code&gt;UNIVERSAL&lt;/code&gt; .</source>
          <target state="translated">由 &lt;code&gt;struct&lt;/code&gt; 创建的类不得为 &lt;code&gt;UNIVERSAL&lt;/code&gt; 以外的其他类的子类。</target>
        </trans-unit>
        <trans-unit id="232a87cc5cdc58df0837defb5b9c5d4aee8a3bd8" translate="yes" xml:space="preserve">
          <source>The class method &lt;code&gt;less-&amp;gt;of( NAME )&lt;/code&gt; returns a boolean to tell you whether your user requested less of something.</source>
          <target state="translated">类方法 &lt;code&gt;less-&amp;gt;of( NAME )&lt;/code&gt; 返回一个布尔值，以告诉您用户是否要求较少的东西。</target>
        </trans-unit>
        <trans-unit id="94cc64c25f30949cf122aa35d8a463e7d89e7056" translate="yes" xml:space="preserve">
          <source>The class method is invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; @array, classname&lt;/code&gt; . Associates an array instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association. The method should return an object of a class which provides the methods below.</source>
          <target state="translated">class方法由命令 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; @array, classname&lt;/code&gt; 调用。将数组实例与指定的类关联。 &lt;code&gt;LIST&lt;/code&gt; 将代表完成关联所需的其他参数（沿着&lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt;和同胞）。该方法应返回提供以下方法的类的对象。</target>
        </trans-unit>
        <trans-unit id="d36e86369efaf1df03cb1d3f2a6ee7366375ea68" translate="yes" xml:space="preserve">
          <source>The class methods invoked for modifying and fetching are these:</source>
          <target state="translated">修改和获取时调用的类方法有这些。</target>
        </trans-unit>
        <trans-unit id="16f1f45dc986b853b9f9c28d5e7c510f2818ec6c" translate="yes" xml:space="preserve">
          <source>The class of the OP's SV, if it has one, in all caps (e.g., 'IV').</source>
          <target state="translated">OP的SV的类别,如果有的话,用大写字母表示(例如,'IV')。</target>
        </trans-unit>
        <trans-unit id="1a1cd2e1aca2f382b8e61ec8f61c8bcfacf6a4ed" translate="yes" xml:space="preserve">
          <source>The classic example of where callbacks are used is when writing an event driven program, such as for an X11 application. In this case you register functions to be called whenever specific events occur, e.g., a mouse button is pressed, the cursor moves into a window or a menu item is selected.</source>
          <target state="translated">使用回调的经典例子是在编写一个事件驱动的程序时,如X11应用程序。在这种情况下,你注册的函数在特定事件发生时被调用,例如,鼠标按钮被按下,光标移动到窗口中或菜单项被选择。</target>
        </trans-unit>
        <trans-unit id="99430da67a315f54b20e2f72a5fd52a7326fcd42" translate="yes" xml:space="preserve">
          <source>The clobber method is simply:</source>
          <target state="translated">clobber方法很简单。</target>
        </trans-unit>
        <trans-unit id="d62999c9944be1bb3aba520e7d0e62efb63cb438" translate="yes" xml:space="preserve">
          <source>The clone method creates a copy of the digest state object and returns a reference to the copy.</source>
          <target state="translated">clone方法创建一个摘要状态对象的副本,并返回副本的引用。</target>
        </trans-unit>
        <trans-unit id="32e3ee7a8f238c3dc42124d9afe27b0f78dc70db" translate="yes" xml:space="preserve">
          <source>The code</source>
          <target state="translated">代码</target>
        </trans-unit>
        <trans-unit id="563ad7ecb10abdc47d619f7b3d0884f86cf94b31" translate="yes" xml:space="preserve">
          <source>The code above can be rearranged to get around the problem, like this:</source>
          <target state="translated">上面的代码可以重新编排来绕过这个问题,像这样。</target>
        </trans-unit>
        <trans-unit id="ecf14a60f040b746943a04d158c46f884d48943b" translate="yes" xml:space="preserve">
          <source>The code above uses DB_File, but again it will work with any of the DBM modules.</source>
          <target state="translated">上面的代码使用了DB_File,但同样也可以和任何一个DBM模块一起工作。</target>
        </trans-unit>
        <trans-unit id="6d3c51612c2ccbd720904d0ac0d50a474014ffdd" translate="yes" xml:space="preserve">
          <source>The code above uses SDBM_File, but it will work with any of the DBM modules.</source>
          <target state="translated">上面的代码使用的是SDBM_File,但它可以和任何DBM模块一起工作。</target>
        </trans-unit>
        <trans-unit id="d0ef4aba54c8ec4419ef4523d1390067d9ff6620" translate="yes" xml:space="preserve">
          <source>The code below can be used to traverse a zip file, one compressed data stream at a time.</source>
          <target state="translated">下面的代码可以用来遍历一个压缩文件,一次一个压缩数据流。</target>
        </trans-unit>
        <trans-unit id="d29217257764218057a5c39c6d3e329014141e5b" translate="yes" xml:space="preserve">
          <source>The code below for</source>
          <target state="translated">以下代码用于</target>
        </trans-unit>
        <trans-unit id="1d78d26d7e9f445a9bc052e60af207768e7330c6" translate="yes" xml:space="preserve">
          <source>The code below is the example given in the section</source>
          <target state="translated">下面的代码是章节中给出的例子。</target>
        </trans-unit>
        <trans-unit id="6e196e9f225b5138a983bdb659d302d31a1c384a" translate="yes" xml:space="preserve">
          <source>The code below makes use of both modules, but it only enables warnings from &lt;code&gt;Derived&lt;/code&gt; .</source>
          <target state="translated">以下代码使用了这两个模块，但仅启用了 &lt;code&gt;Derived&lt;/code&gt; 的警告。</target>
        </trans-unit>
        <trans-unit id="4b70175bee574db6d4bbb54ae246e1319c020349" translate="yes" xml:space="preserve">
          <source>The code block introduces a new scope from the perspective of lexical variable declarations, but &lt;b&gt;not&lt;/b&gt; from the perspective of &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; and similar localizing behaviours. So later code blocks within the same pattern will still see the values which were localized in earlier blocks. These accumulated localizations are undone either at the end of a successful match, or if the assertion is backtracked (compare &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;). For example,</source>
          <target state="translated">该代码块从词汇变量声明的角度引入了新的作用域，但&lt;b&gt;没有&lt;/b&gt;从 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 和类似的局部行为的角度引入。因此，同一模式中的后续代码块仍将看到在较早代码块中本地化的值。这些累积的本地化将在成功匹配结束时或断言断言（比较&lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;）时撤消。例如，</target>
        </trans-unit>
        <trans-unit id="e98d3c5b00844f7eee566f69a2fd1ffcc0553db1" translate="yes" xml:space="preserve">
          <source>The code can only see the compartment's namespace (as returned by the &lt;b&gt;root&lt;/b&gt; method). The compartment's root package appears to be the &lt;code&gt;main::&lt;/code&gt; package to the code inside the compartment.</source>
          <target state="translated">该代码只能看到隔离专区的名称空间（由&lt;b&gt;root&lt;/b&gt;方法返回）。隔离专区的根包似乎是 &lt;code&gt;main::&lt;/code&gt; 包，位于隔离专区内的代码中。</target>
        </trans-unit>
        <trans-unit id="7cc1bb98d53bdcc3465bf9409e43dfe68967ea92" translate="yes" xml:space="preserve">
          <source>The code in the enclosing block has warnings enabled, but the inner block has them disabled. In this case that means the assignment to the scalar &lt;code&gt;$c&lt;/code&gt; will trip the &lt;code&gt;&quot;Scalar value @a[0] better written as $a[0]&quot;&lt;/code&gt; warning, but the assignment to the scalar &lt;code&gt;$b&lt;/code&gt; will not.</source>
          <target state="translated">封闭块中的代码已启用警告，但内部块已将其禁用。在这种情况下，这意味着对标量 &lt;code&gt;$c&lt;/code&gt; 的分配将 &lt;code&gt;&quot;Scalar value @a[0] better written as $a[0]&quot;&lt;/code&gt; 警告，但对标量 &lt;code&gt;$b&lt;/code&gt; 的分配则不会。</target>
        </trans-unit>
        <trans-unit id="3bbef419a6073b40632618263de6b83e9a3b2f8c" translate="yes" xml:space="preserve">
          <source>The code involved in &lt;code&gt;study_chunk()&lt;/code&gt; is extremely cryptic. Be careful. :-)</source>
          <target state="translated">&lt;code&gt;study_chunk()&lt;/code&gt; 中涉及的代码非常含糊。小心。:-)</target>
        </trans-unit>
        <trans-unit id="fa55939059730530d1f6070150cdfbb84afaa7d4" translate="yes" xml:space="preserve">
          <source>The code is executed</source>
          <target state="translated">该代码执行</target>
        </trans-unit>
        <trans-unit id="8fe7ae8735b35c106099f4a767ac8bec4145c55c" translate="yes" xml:space="preserve">
          <source>The code is executed in the package &lt;code&gt;DB&lt;/code&gt; . Note that</source>
          <target state="translated">该代码在包 &lt;code&gt;DB&lt;/code&gt; 中执行。注意</target>
        </trans-unit>
        <trans-unit id="5bdd192de0a16314fb946ed4a5f124bbba34ce51" translate="yes" xml:space="preserve">
          <source>The code is hosted on Github: https://github.com/jonathanstowe/Term-Cap please feel free to fork, submit patches etc, etc there.</source>
          <target state="translated">代码托管在Github上:https://github.com/jonathanstowe/Term-Cap,请随时在那里fork、提交补丁等。</target>
        </trans-unit>
        <trans-unit id="6188bbd338f5f4453ec5eefb9a596ee762c4a047" translate="yes" xml:space="preserve">
          <source>The code is not optimized for speed, especially because we use &lt;code&gt;Math::Complex&lt;/code&gt; and thus go quite near complex numbers while doing the computations even when the arguments are not. This, however, cannot be completely avoided if we want things like &lt;code&gt;asin(2)&lt;/code&gt; to give an answer instead of giving a fatal runtime error.</source>
          <target state="translated">该代码并未针对速度进行优化，尤其是因为我们使用 &lt;code&gt;Math::Complex&lt;/code&gt; ，因此即使在参数未设置的情况下，在执行计算时也会接近复杂的数字。但是，如果我们希望像 &lt;code&gt;asin(2)&lt;/code&gt; 这样的事情给出答案而不是给出致命的运行时错误，就无法完全避免这种情况。</target>
        </trans-unit>
        <trans-unit id="eeb45ce8e4c72e0b27d2dd4e6b03aed6d8283a3c" translate="yes" xml:space="preserve">
          <source>The code isn't pretty as I mentioned -- I never thought it would be a 1000- line program when I started, or I might not have begun. :-) But I would have been less cavalier in how the parts of the program communicated with each other, etc. It might also have helped if I didn't have to divine the makeup of the stabs on the fly, and then account for micro differences between my compiler and gcc.</source>
          <target state="translated">我提到的代码并不漂亮--我开始的时候从来没有想过这是一个1000行的程序,否则我可能不会开始。:-)但我在程序的各个部分如何相互沟通等方面就不会那么草率了。如果我不需要在飞行过程中预知这些刺的构成,然后考虑到我的编译器和gcc之间的微观差异,这可能也会有帮助。</target>
        </trans-unit>
        <trans-unit id="9e137833ea36c6bb446c1454de0e7f32827ac2db" translate="yes" xml:space="preserve">
          <source>The code reference associated with &lt;code&gt;Store&lt;/code&gt; will be called before any key/value is written to the database and the code reference associated with &lt;code&gt;Fetch&lt;/code&gt; will be called after any key/value is read from the database.</source>
          <target state="translated">与 &lt;code&gt;Store&lt;/code&gt; 相关的代码引用将在将任何键/值写入数据库之前被调用，而与 &lt;code&gt;Fetch&lt;/code&gt; 相关的代码引用将在从数据库中读取任何键/值之后被调用。</target>
        </trans-unit>
        <trans-unit id="9112803a8d3c96a68465b0bcde1920f2e7e6a455" translate="yes" xml:space="preserve">
          <source>The code to be parsed comes from</source>
          <target state="translated">要解析的代码来自于</target>
        </trans-unit>
        <trans-unit id="ab517e2a8ba12a27ab2bbd36c075257a2d62e599" translate="yes" xml:space="preserve">
          <source>The code:</source>
          <target state="translated">代码:</target>
        </trans-unit>
        <trans-unit id="43bd0609e5f4f6c76dfb80ec0b3769b0a1ce5867" translate="yes" xml:space="preserve">
          <source>The codes generated by this module are standard terminal control codes, complying with ECMA-048 and ISO 6429 (generally referred to as &quot;ANSI color&quot; for the color codes). The non-color control codes (bold, dark, italic, underline, and reverse) are part of the earlier ANSI X3.64 standard for control sequences for video terminals and peripherals.</source>
          <target state="translated">该模块生成的代码是标准的终端控制代码,符合ECMA-048和ISO 6429标准(一般称为 &quot;ANSI颜色 &quot;的颜色代码)。非彩色控制代码(粗体、深色、斜体、下划线和反向)是早期ANSI X3.64标准的一部分,用于视频终端和外围设备的控制序列。</target>
        </trans-unit>
        <trans-unit id="6fab56ccb009185913550effa31ed3b9edd378e9" translate="yes" xml:space="preserve">
          <source>The codesets currently supported are:</source>
          <target state="translated">目前支持的代码集有:</target>
        </trans-unit>
        <trans-unit id="71e94bac38239334b6900c0a017267aa1a8ae397" translate="yes" xml:space="preserve">
          <source>The cofunctions of the hyperbolic sine, cosine, and tangent (cosech/csch and cotanh/coth are aliases)</source>
          <target state="translated">双曲正弦、余弦和正切的共轭(cosech/csch和cotanh/coth是别名)。</target>
        </trans-unit>
        <trans-unit id="28a5561373d2289312316102a3c2581ebe7698d3" translate="yes" xml:space="preserve">
          <source>The cofunctions of the sine, cosine, and tangent (cosec/csc and cotan/cot are aliases)</source>
          <target state="translated">正弦、余弦和正切的共轭(cosec/csc和cotan/cot是别名)。</target>
        </trans-unit>
        <trans-unit id="4a1e9fabea4570a18aadb2a0be8b117d7c1d1876" translate="yes" xml:space="preserve">
          <source>The collective set of &lt;b&gt;environment variables&lt;/b&gt; your &lt;b&gt;process&lt;/b&gt; inherits from its parent. Accessed via &lt;code&gt;%ENV&lt;/code&gt; .</source>
          <target state="translated">您的&lt;b&gt;过程&lt;/b&gt;从其父级继承的&lt;b&gt;环境变量&lt;/b&gt;的集合。通过 &lt;code&gt;%ENV&lt;/code&gt; 访问。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="54dbe0de410d1fee14f151bad669e4e7f64514b7" translate="yes" xml:space="preserve">
          <source>The color function doesn't work unless &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; is compatible with your terminal.</source>
          <target state="translated">除非&lt;a href=&quot;../../term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt;与您的终端兼容，否则颜色功能将不起作用。</target>
        </trans-unit>
        <trans-unit id="d494da03d1029e001559e320101aec67b6081a14" translate="yes" xml:space="preserve">
          <source>The color stack, including the &lt;code&gt;:pushpop&lt;/code&gt; import tag, PUSHCOLOR, POPCOLOR, LOCALCOLOR, and the $Term::ANSIColor::AUTOLOCAL variable, was added in Term::ANSIColor 2.00, included in Perl 5.10.1.</source>
          <target state="translated">颜色堆栈，包括 &lt;code&gt;:pushpop&lt;/code&gt; 导入标签，PUSHCOLOR，POPCOLOR，LOCALCOLOR和$ Term :: ANSIColor :: AUTOLOCAL变量，已添加到Perl 5.10.1中包含的Term :: ANSIColor 2.00中。</target>
        </trans-unit>
        <trans-unit id="99f186121577072655b8ffd874560fdf2ec9538e" translate="yes" xml:space="preserve">
          <source>The column at which to wrap text on the right-hand side. Defaults to 76, unless &lt;b&gt;-t&lt;/b&gt; is given, in which case it's two columns less than the width of your terminal device.</source>
          <target state="translated">右侧要换行的列。除非给出&lt;b&gt;-t&lt;/b&gt;，否则默认为76，在这种情况下，它比终端设备的宽度小两列。</target>
        </trans-unit>
        <trans-unit id="dc0da64614756f754ff954c33b5269fabc02fce0" translate="yes" xml:space="preserve">
          <source>The column at which to wrap text on the right-hand side. Defaults to 76.</source>
          <target state="translated">右侧文字的包围列。默认值为76。</target>
        </trans-unit>
        <trans-unit id="e8623930908f634360f3d6d3225f352295877e28" translate="yes" xml:space="preserve">
          <source>The combination of &lt;code&gt;//g&lt;/code&gt; and &lt;code&gt;\G&lt;/code&gt; allows us to process the string a bit at a time and use arbitrary Perl logic to decide what to do next. Currently, the &lt;code&gt;\G&lt;/code&gt; anchor is only fully supported when used to anchor to the start of the pattern.</source>
          <target state="translated">&lt;code&gt;//g&lt;/code&gt; 和 &lt;code&gt;\G&lt;/code&gt; 的组合使我们可以一次处理该字符串，并使用任意Perl逻辑来决定下一步要做什么。当前， &lt;code&gt;\G&lt;/code&gt; 锚仅在用于锚定到模式的开始时才完全受支持。</target>
        </trans-unit>
        <trans-unit id="970e7f15d0c6ab9e35629ba58fe853786b66b02c" translate="yes" xml:space="preserve">
          <source>The combination of multiple command- line switches (</source>
          <target state="translated">多个命令行开关的组合 (</target>
        </trans-unit>
        <trans-unit id="e655e997e08648320978a6ff86ae273d24047f81" translate="yes" xml:space="preserve">
          <source>The combined effect of 3 &amp;amp; 4 is that it will allow code which uses the &lt;code&gt;warnings&lt;/code&gt; pragma to control the warning behavior of $^W-type code (using a &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $^W=0&lt;/code&gt; ) if it really wants to, but not vice-versa.</source>
          <target state="translated">3和4的综合效果是，如果确实需要，它将允许使用 &lt;code&gt;warnings&lt;/code&gt; 编译指示的代码控制$ ^ W类型代码的警告行为（使用 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $^W=0&lt;/code&gt; ），但不会这样做-反之亦然。</target>
        </trans-unit>
        <trans-unit id="c5195e2f756a78470c45dda1ae8fbd38d00cbe08" translate="yes" xml:space="preserve">
          <source>The command &quot;=for</source>
          <target state="translated">命令&quot;=for</target>
        </trans-unit>
        <trans-unit id="3d8aeb4458c1560b0d5ab2e46d755733e3bb6324" translate="yes" xml:space="preserve">
          <source>The command does not start.</source>
          <target state="translated">该命令没有启动。</target>
        </trans-unit>
        <trans-unit id="7e6f4f93a21a7f88a65ff2221b6911802d75f842" translate="yes" xml:space="preserve">
          <source>The command is killed by a signal.</source>
          <target state="translated">该命令被一个信号杀死。</target>
        </trans-unit>
        <trans-unit id="914be5b158c3cc5be779f3d3fed5d23185a3c4a4" translate="yes" xml:space="preserve">
          <source>The command line interface is tightly integrated with an &lt;b&gt;emacs&lt;/b&gt; extension and there's a &lt;b&gt;vi&lt;/b&gt; interface too.</source>
          <target state="translated">命令行界面与&lt;b&gt;emacs&lt;/b&gt;扩展紧密集成，并且还有&lt;b&gt;vi&lt;/b&gt;界面。</target>
        </trans-unit>
        <trans-unit id="f789ad4d35bca82f26a9236e86bce7a57e057b98" translate="yes" xml:space="preserve">
          <source>The command line is not split by GetOptions, but by the command line interpreter (CLI). On Unix, this is the shell. On Windows, it is COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.</source>
          <target state="translated">命令行不是由GetOptions分割的,而是由命令行解释器(CLI)分割的。在Unix上,这就是shell。在Windows上,它是COMMAND.COM或CMD.EXE。其他操作系统还有其他CLI。</target>
        </trans-unit>
        <trans-unit id="a12dc653b968ec55d9bfea4484d747acafd8c027" translate="yes" xml:space="preserve">
          <source>The command returns a non-zero exit value (but see below).</source>
          <target state="translated">该命令返回一个非零的退出值(但见下文)。</target>
        </trans-unit>
        <trans-unit id="ccf7fbf7b3dd60fe57ca23a7e47b3c4eeb05e932" translate="yes" xml:space="preserve">
          <source>The command used to load the debugger code. The default is:</source>
          <target state="translated">用于加载调试器代码的命令。默认值是:</target>
        </trans-unit>
        <trans-unit id="35175a977556088d11ca4a7b0e7332f1ce787324" translate="yes" xml:space="preserve">
          <source>The command's STDOUT and STDERR (and possibly STDIN, depending on your shell) will be the same as the parent's. You won't need to catch SIGCHLD because of the double-fork taking place; see below for details.</source>
          <target state="translated">命令的STDOUT和STDERR(可能还有STDIN,取决于你的shell)将与父命令的相同。由于发生了双叉,你不需要抓住SIGCHLD;详情请看下文。</target>
        </trans-unit>
        <trans-unit id="75337684a9346d140506f8cf5d632c3a6fe46276" translate="yes" xml:space="preserve">
          <source>The command-line mentioned in the SYNOPSIS section corresponds to the Perl code</source>
          <target state="translated">SYNOPSIS部分提到的命令行对应的是Perl代码。</target>
        </trans-unit>
        <trans-unit id="ea72136c38b086284678c74c52f83815bf874db4" translate="yes" xml:space="preserve">
          <source>The commands &lt;code&gt;=pod&lt;/code&gt; and &lt;code&gt;=cut&lt;/code&gt; do not take any arguments.</source>
          <target state="translated">命令 &lt;code&gt;=pod&lt;/code&gt; 和 &lt;code&gt;=cut&lt;/code&gt; 不带任何参数。</target>
        </trans-unit>
        <trans-unit id="f1e3cdc1d66a6ddbc94785be80a34d0a817fb94d" translate="yes" xml:space="preserve">
          <source>The commands available in the shell interface are methods in the package CPAN::Shell. If you enter the shell command, your input is split by the Text::ParseWords::shellwords() routine, which acts like most shells do. The first word is interpreted as the method to be invoked, and the rest of the words are treated as the method's arguments. Continuation lines are supported by ending a line with a literal backslash.</source>
          <target state="translated">shell接口中的命令是CPAN::Shell包中的方法。如果你输入shell命令,你的输入会被Text::ParseWords::shellwords()例程分割,它的行为就像大多数shell一样。第一个词被解释为要调用的方法,其余的词被视为方法的参数。通过以反斜杠结束一行来支持续行。</target>
        </trans-unit>
        <trans-unit id="50c172c64b8304a2667bbd4145cf67a46b69892f" translate="yes" xml:space="preserve">
          <source>The commit message should include a description of the problem that the patch corrects or new functionality that the patch adds.</source>
          <target state="translated">提交信息中应该包含补丁所修正的问题或补丁所增加的新功能的描述。</target>
        </trans-unit>
        <trans-unit id="a48a6b9a39f2c1e8f05ac68afbc7708f295daa69" translate="yes" xml:space="preserve">
          <source>The common (and original) usage of B::Concise was for command-line renderings of simple code, as given in EXAMPLE. But you can also use &lt;b&gt;B::Concise&lt;/b&gt; from your code, and call compile() directly, and repeatedly. By doing so, you can avoid the compile-time only operation of O.pm, and even use the debugger to step through B::Concise::compile() itself.</source>
          <target state="translated">B :: Concise的常见（原始）用法是用于简单代码的命令行呈现，如Example中所给出。但是，您也可以在代码中使用&lt;b&gt;B :: Concise&lt;/b&gt;，然后直接且重复地调用compile（）。这样，您可以避免O.pm的仅编译时操作，甚至可以使用调试器逐步浏览B :: Concise :: compile（）本身。</target>
        </trans-unit>
        <trans-unit id="092b88432af421400f5d15e398af7e25459b6caf" translate="yes" xml:space="preserve">
          <source>The comparison function is required to behave. If it returns inconsistent results (sometimes saying &lt;code&gt;$x[1]&lt;/code&gt; is less than &lt;code&gt;$x[2]&lt;/code&gt; and sometimes saying the opposite, for example) the results are not well-defined.</source>
          <target state="translated">比较功能是必需的。如果返回不一致的结果（例如，有时 &lt;code&gt;$x[1]&lt;/code&gt; 小于 &lt;code&gt;$x[2]&lt;/code&gt; ，有时相反），则结果定义不明确。</target>
        </trans-unit>
        <trans-unit id="edfa309c58fb1bf1eba2e1c0e1a54aa1aefcb60b" translate="yes" xml:space="preserve">
          <source>The compilation of a subroutine can be affected by a few compiler directives, &lt;b&gt;pragmas&lt;/b&gt;. These are:</source>
          <target state="translated">子例程的编译可能会受到一些编译器指令&lt;b&gt;pragmas的影响&lt;/b&gt;。这些是：</target>
        </trans-unit>
        <trans-unit id="ecde94171862ef8b275c6d67c44a792fcd8d5efd" translate="yes" xml:space="preserve">
          <source>The compile tree is executed in a runops function. There are two runops functions, in</source>
          <target state="translated">编译树是在runops函数中执行的。有两个runops函数,在</target>
        </trans-unit>
        <trans-unit id="79a77bf1e2569d28ea6eda34147b4768d49e28ad" translate="yes" xml:space="preserve">
          <source>The compiler will search for typemap files called</source>
          <target state="translated">编译器将搜索名为 &quot;typemap &quot;的文件。</target>
        </trans-unit>
        <trans-unit id="111471390604961ec6523ced1b372373b53d8003" translate="yes" xml:space="preserve">
          <source>The compiler would immediately flag that as an error</source>
          <target state="translated">编译器会立即将其标记为错误。</target>
        </trans-unit>
        <trans-unit id="89f4eed42cf9fec88c7f54948d286e3b27120ba8" translate="yes" xml:space="preserve">
          <source>The complementary error function [C99].</source>
          <target state="translated">补差函数[C99]。</target>
        </trans-unit>
        <trans-unit id="ed6f778f02ef1fa177aa048ce5ee5aeaef666a7f" translate="yes" xml:space="preserve">
          <source>The complete Perl documentation is available with the Perl distribution. If you have Perl installed locally, you probably have the documentation installed as well: type &lt;code&gt;perldoc perl&lt;/code&gt; in a terminal or &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fperldoc.perl.org%2fperl.html&quot;&gt;view online&lt;/a&gt;.</source>
          <target state="translated">Perl发行版中提供了完整的Perl文档。如果您在本地安装了Perl，则可能还需要安装文档：在终端中输入 &lt;code&gt;perldoc perl&lt;/code&gt; 或&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fperldoc.perl.org%2fperl.html&quot;&gt;在线查看&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="068df1cb71064dd3af102dcffe784783c3c8d76f" translate="yes" xml:space="preserve">
          <source>The complete array will be walked to ensure that it only contains valid filenames before any data is compressed.</source>
          <target state="translated">在任何数据被压缩之前,完整的数组将被走过,以确保它只包含有效的文件名。</target>
        </trans-unit>
        <trans-unit id="3bc7e120c73e8eddc193ee78a2c4c1f364b17641" translate="yes" xml:space="preserve">
          <source>The complete array will be walked to ensure that it only contains valid filenames before any data is uncompressed.</source>
          <target state="translated">在任何数据被解压之前,完整的数组将被走过,以确保它只包含有效的文件名。</target>
        </trans-unit>
        <trans-unit id="98b6ca723bf0fecfbf2258563e5ac721bc8076d0" translate="yes" xml:space="preserve">
          <source>The complete list of keys that can be specified in the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive are given, separated by spaces, in the values of the hash &lt;code&gt;%overload::ops&lt;/code&gt; :</source>
          <target state="translated">可在指定键的完整列表， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 指令给出，用空格分隔，哈希值 &lt;code&gt;%overload::ops&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="52c281d1dec7eebd9b6bf4d9cf26bf4311a392cc" translate="yes" xml:space="preserve">
          <source>The complete table can be found in the Sun Managers' FAQ &lt;a href=&quot;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&quot;&gt;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&lt;/a&gt; under &quot;9.1) Which Sun models run which versions of SunOS?&quot;.</source>
          <target state="translated">完整的表可以在Sun Managers的FAQ &lt;a href=&quot;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&quot;&gt;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq中的&lt;/a&gt; &amp;ldquo; 9.1）哪些Sun模型运行哪个版本的SunOS？&amp;rdquo;中找到。</target>
        </trans-unit>
        <trans-unit id="243520c31a219c7d1aad4ef85de5d88764701e20" translate="yes" xml:space="preserve">
          <source>The completion character &amp;lt;tab&amp;gt; cannot be changed.</source>
          <target state="translated">补全字符&amp;lt;tab&amp;gt;不能更改。</target>
        </trans-unit>
        <trans-unit id="57f8fbb5c61dbf32a6295f7091431384e77ad0b9" translate="yes" xml:space="preserve">
          <source>The complicated syntaxes of this code are discussed at length in &lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;Formatting Codes in perlpod&lt;/a&gt;, and implementation details are discussed below, in &lt;a href=&quot;#About-L%3c...%3e-Codes&quot;&gt;About L&amp;lt;...&amp;gt; Codes&lt;/a&gt;. Parsing the contents of L&amp;lt;content&amp;gt; is tricky. Notably, the content has to be checked for whether it looks like a URL, or whether it has to be split on literal &quot;|&quot; and/or &quot;/&quot; (in the right order!), and so on,</source>
          <target state="translated">该代码的复杂语法&lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;在perlpod&lt;/a&gt;中的Formatting Codes中进行了详细讨论，实现细节在下面的&lt;a href=&quot;#About-L%3c...%3e-Codes&quot;&gt;About L .... Code中&lt;/a&gt;进行了讨论。解析L &amp;lt;content&amp;gt;的内容很棘手。值得注意的是，必须检查内容是否看起来像URL，还是必须在文字&amp;ldquo; |&amp;rdquo;上拆分？和/或&amp;ldquo; /&amp;rdquo;（顺序正确！），依此类推，</target>
        </trans-unit>
        <trans-unit id="3e080e954af33f166a94bcfa488743e85b7e060c" translate="yes" xml:space="preserve">
          <source>The compound way of writing these is like &lt;code&gt;\p{General_Category=Number}&lt;/code&gt; (short: &lt;code&gt;\p{gc:n}&lt;/code&gt; ). But Perl furnishes shortcuts in which everything up through the equal or colon separator is omitted. So you can instead just write &lt;code&gt;\pN&lt;/code&gt; .</source>
          <target state="translated">复合的编写方式类似于 &lt;code&gt;\p{General_Category=Number}&lt;/code&gt; （简称： &lt;code&gt;\p{gc:n}&lt;/code&gt; ）。但是Perl提供了快捷方式，其中省略了通过等号或冒号分隔符开始的所有内容。因此，您可以只写 &lt;code&gt;\pN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4be8f3e8beb322b0e55f10e2929087827e8f380" translate="yes" xml:space="preserve">
          <source>The computer on which a program or other data resides.</source>
          <target state="translated">程序或其他数据所在的计算机。</target>
        </trans-unit>
        <trans-unit id="cfcbad8d7cd3118bc2c84750149f972c9d76bac3" translate="yes" xml:space="preserve">
          <source>The concatenation operator is &quot;.&quot;, not the null string. (Using the null string would render &lt;code&gt;/pat/ /pat/&lt;/code&gt; unparsable, because the third slash would be interpreted as a division operator--the tokenizer is in fact slightly context sensitive for operators like &quot;/&quot;, &quot;?&quot;, and &quot;&amp;gt;&quot;. And in fact, &quot;.&quot; itself can be the beginning of a number.)</source>
          <target state="translated">串联运算符为&amp;ldquo;。&amp;rdquo;，而不是空字符串。（使用null字符串将使 &lt;code&gt;/pat/ /pat/&lt;/code&gt; 无法解析，因为第三个斜杠将被解释为除法运算符-标记符实际上对于&amp;ldquo; /&amp;rdquo;，&amp;ldquo;？&amp;rdquo;和&amp;ldquo;&amp;gt; &amp;ldquo;。实际上，&amp;ldquo;。&amp;rdquo;本身可以是数字的开头。）</target>
        </trans-unit>
        <trans-unit id="7397c296c9007588d87f382f9ceff5394823ef48" translate="yes" xml:space="preserve">
          <source>The concise style uses symbols to convey maximum info with minimal clutter (like hex addresses). With just a little practice, you can start to see the flowers, not just the branches, in the trees.</source>
          <target state="translated">简洁的风格使用符号以最小的杂乱(如十六进制地址)来传达最大的信息。只要稍加练习,你就可以开始看到树上的花朵,而不仅仅是树枝。</target>
        </trans-unit>
        <trans-unit id="d9749679dc3561ae81ba863d8e80238321089767" translate="yes" xml:space="preserve">
          <source>The concrete formatter must implement</source>
          <target state="translated">具体的格式器必须实现</target>
        </trans-unit>
        <trans-unit id="ec6253a94addb83f76f25a71c4752860278fa23c" translate="yes" xml:space="preserve">
          <source>The conditions can be any Perl expression. See the list of operators in the next section for information on comparison and boolean logic operators, which are commonly used in conditional statements.</source>
          <target state="translated">条件可以是任何Perl表达式。关于条件语句中常用的比较和布尔逻辑运算符,请参见下一节的运算符列表。</target>
        </trans-unit>
        <trans-unit id="543b88d3ab70df9ad92d2d1112ca25224746b1f5" translate="yes" xml:space="preserve">
          <source>The configuration data is held globally in a file in the perl installation tree, but a user may override any of these values by providing their own. This can be done by having a &lt;code&gt;.libnetrc&lt;/code&gt; file in their home directory. This file should return a reference to a HASH containing the keys described below. For example</source>
          <target state="translated">配置数据全局保存在perl安装树中的文件中，但是用户可以通过提供自己的值覆盖这些值中的任何一个。这可以通过在其主目录中具有 &lt;code&gt;.libnetrc&lt;/code&gt; 文件来完成。该文件应返回对包含以下所述密钥的HASH的引用。例如</target>
        </trans-unit>
        <trans-unit id="9a78f97fbb5cf4075595c0b03128bde7af0266c1" translate="yes" xml:space="preserve">
          <source>The configuration dialog can be started any time later again by issuing the command &lt;code&gt; o conf init &lt;/code&gt; in the CPAN shell. A subset of the configuration dialog can be run by issuing &lt;code&gt;o conf init WORD&lt;/code&gt; where WORD is any valid config variable or a regular expression.</source>
          <target state="translated">通过在CPAN Shell中发出命令 &lt;code&gt; o conf init &lt;/code&gt; ，可以在以后任何时间再次启动配置对话框。可以通过发出 &lt;code&gt;o conf init WORD&lt;/code&gt; 来运行配置对话框的子集，其中WORD是任何有效的配置变量或正则表达式。</target>
        </trans-unit>
        <trans-unit id="b4c7562be2672acce7fe43e87808c7f47379f387" translate="yes" xml:space="preserve">
          <source>The configuration parameter check_sigs is there to turn signature checking on or off.</source>
          <target state="translated">配置参数check_sigs的作用是开启或关闭签名检查。</target>
        </trans-unit>
        <trans-unit id="92e8c71c043d1ee5895cf5c5a239168a7f0a8975" translate="yes" xml:space="preserve">
          <source>The confusion arises because people incorrectly assume that the sigil denotes the variable type.</source>
          <target state="translated">之所以出现这种混乱,是因为人们错误地认为sigil表示变量类型。</target>
        </trans-unit>
        <trans-unit id="72def2ab61e0c7e7dccd965b3f9393136d20aa03" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;pi&lt;/code&gt; and some handy multiples of it (pi2, pi4, and pip2 (pi/2) and pip4 (pi/4)) are also available if separately exported:</source>
          <target state="translated">如果单独导出，则常数 &lt;code&gt;pi&lt;/code&gt; 及其一些方便的倍数（pi2，pi4和pip2（pi / 2）和pip4（pi / 4））也可用：</target>
        </trans-unit>
        <trans-unit id="c81821f9e03375c52f91dde5667119328458dcfd" translate="yes" xml:space="preserve">
          <source>The constant function &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; returns a comparable number that represents the highest file version number that this version of Storable fully supports (but see discussion of &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; above). The constant &lt;code&gt;Storable::BIN_WRITE_VERSION_NV&lt;/code&gt; function returns what file version is written and might be less than &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; in some configurations.</source>
          <target state="translated">常量函数 &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; 返回一个可比较的数字，该数字表示该版本的Storable完全支持的最高文件版本号（但请参见上面有关 &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; 讨论）。常量 &lt;code&gt;Storable::BIN_WRITE_VERSION_NV&lt;/code&gt; 函数返回写入的文件版本，在某些配置中，该版本可能小于 &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9018d00ba0cf85500f9049cabc293077c6a815d2" translate="yes" xml:space="preserve">
          <source>The construct</source>
          <target state="translated">构造</target>
        </trans-unit>
        <trans-unit id="8226460345430ec3df47c2bd35c2d238766995a6" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;\$v{timep}=@{[$v{timep}=$arg]}&lt;/code&gt; used in the above example has a two-fold purpose: first, when this line is processed by &lt;b&gt;xsubpp&lt;/b&gt;, the Perl snippet &lt;code&gt;$v{timep}=$arg&lt;/code&gt; is evaluated. Second, the text of the evaluated snippet is output into the generated C file (inside a C comment)! During the processing of &lt;code&gt;char *host&lt;/code&gt; line, &lt;code&gt;$arg&lt;/code&gt; will evaluate to &lt;code&gt;ST(0)&lt;/code&gt; , and &lt;code&gt;$v{timep}&lt;/code&gt; will evaluate to &lt;code&gt;ST(1)&lt;/code&gt; .</source>
          <target state="translated">上例中使用的结构 &lt;code&gt;\$v{timep}=@{[$v{timep}=$arg]}&lt;/code&gt; 有两个目的：首先，当该行由&lt;b&gt;xsubpp&lt;/b&gt;处理时，Perl代码段 &lt;code&gt;$v{timep}=$arg&lt;/code&gt; 被求值。其次，将评估代码段的文本输出到生成的C文件中（在C注释内部）！在处理 &lt;code&gt;char *host&lt;/code&gt; 行时， &lt;code&gt;$arg&lt;/code&gt; 将评估为 &lt;code&gt;ST(0)&lt;/code&gt; ，而 &lt;code&gt;$v{timep}&lt;/code&gt; 将评估为 &lt;code&gt;ST(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b59007854896f819ee065a798da86e7867bce96e" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;new&lt;/code&gt; creates and returns an empty &lt;code&gt;TAP::Parser::YAMLish::Reader&lt;/code&gt; object.</source>
          <target state="translated">构造函数 &lt;code&gt;new&lt;/code&gt; 创建并返回一个空的 &lt;code&gt;TAP::Parser::YAMLish::Reader&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="1bad8668cdf1d431ad701326f6748ece18b79658" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;new&lt;/code&gt; creates and returns an empty &lt;code&gt;TAP::Parser::YAMLish::Writer&lt;/code&gt; object.</source>
          <target state="translated">构造函数 &lt;code&gt;new&lt;/code&gt; 创建并返回一个空的 &lt;code&gt;TAP::Parser::YAMLish::Writer&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="4c2fcf35a44aabf097cd59f3a3854953c70e5fcd" translate="yes" xml:space="preserve">
          <source>The constructor can also accept additional parameters that define the object. Let's write a real constructor for the &lt;code&gt;File&lt;/code&gt; class we used earlier:</source>
          <target state="translated">构造函数还可以接受定义该对象的其他参数。让我们为之前使用的 &lt;code&gt;File&lt;/code&gt; 类编写一个真正的构造函数：</target>
        </trans-unit>
        <trans-unit id="3a88176407788666ff0021721dd4e56b3400cf3f" translate="yes" xml:space="preserve">
          <source>The constructor creates a new object and optionally initialises it with a set of handles.</source>
          <target state="translated">构造函数创建一个新的对象,并可选择用一组句柄来初始化它。</target>
        </trans-unit>
        <trans-unit id="26002f2b8ad63b7adc28307355437aa48afa5d7b" translate="yes" xml:space="preserve">
          <source>The constructor for a &lt;code&gt;Net::Netrc&lt;/code&gt; object is not called new as it does not really create a new object. But instead is called &lt;code&gt;lookup&lt;/code&gt; as this is essentially what it does.</source>
          <target state="translated">&lt;code&gt;Net::Netrc&lt;/code&gt; 对象的构造函数未称为new，因为它实际上并未创建新对象。而是将其称为 &lt;code&gt;lookup&lt;/code&gt; 因为它本质上就是它的工作。</target>
        </trans-unit>
        <trans-unit id="5e4047980f5ac3eb3127d3d68b5f254e9299a0fd" translate="yes" xml:space="preserve">
          <source>The constructor for all the singletons used to represent modules, distributions, authors, and bundles. If the object already exists, this method returns the object; otherwise, it calls the constructor.</source>
          <target state="translated">用于表示模块、发行版、作者和捆绑的所有单子的构造函数。如果对象已经存在,本方法返回对象;否则,调用构造函数。</target>
        </trans-unit>
        <trans-unit id="a54cf785d15de998f3ac18ade864f218319b1ee1" translate="yes" xml:space="preserve">
          <source>The constructor of a generated class can be passed a list of</source>
          <target state="translated">生成的类的构造函数可以传递一个列表,其中包括</target>
        </trans-unit>
        <trans-unit id="bb7df7aab984a9c0e691c8f805de279350cf56e0" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;Digest::MD5&lt;/code&gt; object which encapsulate the state of the MD5 message-digest algorithm.</source>
          <target state="translated">构造函数返回一个新的 &lt;code&gt;Digest::MD5&lt;/code&gt; 对象，该对象封装了MD5消息摘要算法的状态。</target>
        </trans-unit>
        <trans-unit id="2e6b2441df01bfc969fd7dfde15484f966dcaf52" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Color&lt;/code&gt; object. If &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; is not installed, returns undef.</source>
          <target state="translated">构造函数返回一个新的 &lt;code&gt;TAP::Formatter::Color&lt;/code&gt; 对象。如果未安装&lt;a href=&quot;../../term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt;，则返回undef。</target>
        </trans-unit>
        <trans-unit id="972195b07373ba2fa384173c37fb399dc7626fb1" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Console::Session&lt;/code&gt; object.</source>
          <target state="translated">构造函数返回一个新的 &lt;code&gt;TAP::Formatter::Console::Session&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="64d08d3b354e3667ab5da2f82eaec44dd6d25ea5" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; object. If a &lt;a href=&quot;../harness&quot;&gt;TAP::Harness&lt;/a&gt; is created with no &lt;code&gt;formatter&lt;/code&gt; a &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; is automatically created. If any of the following options were given to TAP::Harness-&amp;gt;new they well be passed to this constructor which accepts an optional hashref whose allowed keys are:</source>
          <target state="translated">构造函数返回一个新的 &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; 对象。如果&lt;a href=&quot;../harness&quot;&gt;TAP ::线束&lt;/a&gt;与没有创建 &lt;code&gt;formatter&lt;/code&gt; 一个 &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; 自动创建。如果为TAP :: Harness-&amp;gt; new提供了以下任何选项，则可以将它们传递给此构造函数，该构造函数接受可选的hashref，其允许的键为：</target>
        </trans-unit>
        <trans-unit id="cdf8ec5d8f9e8688b8b1e013d18928a0b5fdbbeb" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Harness&lt;/code&gt; object. It accepts an optional hashref whose allowed keys are:</source>
          <target state="translated">构造函数返回一个新的 &lt;code&gt;TAP::Harness&lt;/code&gt; 对象。它接受可选的hashref，其允许的键为：</target>
        </trans-unit>
        <trans-unit id="093c7ac00d4bfb4c1a8deee532d1b8ad2334e8c0" translate="yes" xml:space="preserve">
          <source>The constructor returns some object that encapsulate the state of the message-digest algorithm. You can add data to the object and finally ask for the digest. The &quot;XXX&quot; should of course be replaced by the proper name of the digest algorithm you want to use.</source>
          <target state="translated">构造函数返回一些封装了消息摘要算法状态的对象。你可以向该对象添加数据,最后要求得到摘要。当然,&quot;XXX &quot;应该用你要使用的摘要算法的正确名称来代替。</target>
        </trans-unit>
        <trans-unit id="f4ebdab724a22632fec3a1d054882b1bc817c7d6" translate="yes" xml:space="preserve">
          <source>The content of the here doc is treated just as it would be if the string were embedded in backticks. Thus the content is interpolated as though it were double quoted and then executed via the shell, with the results of the execution returned.</source>
          <target state="translated">Here doc的内容会被处理成和字符串被嵌入到反引号中一样。因此,内容会被插值,就像它是双引号一样,然后通过shell执行,并返回执行结果。</target>
        </trans-unit>
        <trans-unit id="6af50a9986dd8fc345d5bd2a482a8608eafdf212" translate="yes" xml:space="preserve">
          <source>The content of the text chunk in the buffer is commonly exactly one complete line of input, up to and including a newline terminator, but there are situations where it is otherwise. The octets of the buffer may be intended to be interpreted as either UTF-8 or Latin-1. The function &lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt; tells you which. Do not use the &lt;code&gt;SvUTF8&lt;/code&gt; flag on this scalar, which may disagree with it.</source>
          <target state="translated">缓冲区中文本块的内容通常恰好是一个完整的输入行，直到并包括换行符终止符，但是在某些情况下则不是这样。缓冲区的八位位组可以解释为UTF-8或Latin-1。函数&lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt;告诉您哪个。不要在此标量上使用 &lt;code&gt;SvUTF8&lt;/code&gt; 标志，这可能会与它不同。</target>
        </trans-unit>
        <trans-unit id="3c50b9c6cd39ffa60fa752e0357613216ec7e1d3" translate="yes" xml:space="preserve">
          <source>The contents of &lt;code&gt;$/&lt;/code&gt; are used to determine what constitutes a line terminator.</source>
          <target state="translated">&lt;code&gt;$/&lt;/code&gt; 的内容用于确定什么构成行终止符。</target>
        </trans-unit>
        <trans-unit id="18d18ed7c7a8db27a58a80fd58640cc3bbfe1bce" translate="yes" xml:space="preserve">
          <source>The contents of the Comment header field, if present. If no comment is present, the value will be undef. Note this is different from a zero length comment, which will return an empty string.</source>
          <target state="translated">评论头字段的内容(如果存在)。如果没有注释,值将为undef。注意,这与零长度的注释不同,后者将返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="f67589a8aeaaf0494de7c02234d42e486e771e87" translate="yes" xml:space="preserve">
          <source>The contents of the Name header field, if present. If no name is present, the value will be undef. Note this is different from a zero length name, which will return an empty string.</source>
          <target state="translated">Name头的内容(如果存在)。如果不存在名称,该值将为undef。注意,这与零长度的名称不同,后者将返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="9456b1413183ce2a7cacbf69ac958ec33df9e078" translate="yes" xml:space="preserve">
          <source>The contents of the above &quot;=begin :yetanotherformat&quot; ... &quot;=end :yetanotherformat&quot; region</source>
          <target state="translated">上述&quot;=begin :yetanotherformat&quot;...的内容。&quot;=end :yetanotherformat &quot;区域的内容。</target>
        </trans-unit>
        <trans-unit id="7bdc8b3d3c8ea3698e851bea6c870ef22be74842" translate="yes" xml:space="preserve">
          <source>The contents of the string are split into arguments using a call to &lt;code&gt;Text::ParseWords::shellwords&lt;/code&gt; . As with &lt;code&gt;GetOptionsFromArray&lt;/code&gt; , the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched.</source>
          <target state="translated">字符串的内容通过调用 &lt;code&gt;Text::ParseWords::shellwords&lt;/code&gt; 分为参数。与 &lt;code&gt;GetOptionsFromArray&lt;/code&gt; 一样，全局 &lt;code&gt;@ARGV&lt;/code&gt; 不会被触摸。</target>
        </trans-unit>
        <trans-unit id="ee0a191734836657a10b5b7b1f37002c95e61a13" translate="yes" xml:space="preserve">
          <source>The contents of the string changes, but not the nature of the string. Perl doesn't know any more after the call than before that the contents of the string indicates the affirmative.</source>
          <target state="translated">字符串的内容发生了变化,但字符串的性质没有改变。Perl在调用后并不比调用前更知道字符串的内容表示肯定。</target>
        </trans-unit>
        <trans-unit id="fa23695f3fe9b71ce5ed23d56ccd05be2c1e1b36" translate="yes" xml:space="preserve">
          <source>The contents should be an integer; different bits of it are used for different pragmatic flags. Here's an example:</source>
          <target state="translated">内容应该是一个整数;其中不同的位用于不同的实用性标志。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="29b067c45824f7dfd004988f65509a605101a269" translate="yes" xml:space="preserve">
          <source>The context (void, scalar or list) for the return value(s) for &lt;code&gt;-&amp;gt;join()&lt;/code&gt; is determined at the time of thread creation.</source>
          <target state="translated">&lt;code&gt;-&amp;gt;join()&lt;/code&gt; 的返回值的上下文（无效，标量或列表）是在创建线程时确定的。</target>
        </trans-unit>
        <trans-unit id="cafef0e58c037c46bb556fc0f1a1471183c9edb3" translate="yes" xml:space="preserve">
          <source>The context type may also be used as the</source>
          <target state="translated">该上下文类型也可以作为</target>
        </trans-unit>
        <trans-unit id="cd3e46d3e11cb302e5746c299ddd22b0f06326e3" translate="yes" xml:space="preserve">
          <source>The context-free version of Perl_warner is called Perl_warner_nocontext, and does not take the extra argument. Instead it does dTHX; to get the context from thread-local storage. We &lt;code&gt;#define warner Perl_warner_nocontext&lt;/code&gt; so that extensions get source compatibility at the expense of performance. (Passing an arg is cheaper than grabbing it from thread-local storage.)</source>
          <target state="translated">Perl_warner的上下文无关版本称为Perl_warner_nocontext，并且不使用额外的参数。相反，它执行dTHX。从线程本地存储中获取上下文。我们 &lt;code&gt;#define warner Perl_warner_nocontext&lt;/code&gt; ,以便扩展获得源兼容性，但会降低性能。（传递一个arg比从线程本地存储中获取它便宜。）</target>
        </trans-unit>
        <trans-unit id="a306525389293789c4d3b564d2695ad27f640911" translate="yes" xml:space="preserve">
          <source>The conversion from Perl to C is left as an exercise to the reader, but the prototype would be:</source>
          <target state="translated">从Perl到C的转换留给读者去练习,但原型将是。</target>
        </trans-unit>
        <trans-unit id="5dab7a329fdfbc3426218724b9a43e87edffc6ee" translate="yes" xml:space="preserve">
          <source>The copy constructor is called only before a call to a function declared to implement a mutator, for example, if &lt;code&gt;++$b;&lt;/code&gt; in the code above is effected via a method declared for key &lt;code&gt;'++'&lt;/code&gt; (or 'nomethod', passed &lt;code&gt;'++'&lt;/code&gt; as the fourth argument) or, by autogeneration, &lt;code&gt;'+='&lt;/code&gt; . It is not called if the increment operation is effected by a call to the method for &lt;code&gt;'+'&lt;/code&gt; since, in the equivalent code,</source>
          <target state="translated">复制构造函数仅在调用声明为实现可变器的函数之前被调用，例如 &lt;code&gt;++$b;&lt;/code&gt; 上面代码中的代码是通过为键 &lt;code&gt;'++'&lt;/code&gt; 声明的方法（或'nomethod'，将 &lt;code&gt;'++'&lt;/code&gt; 作为第四个参数传递）或自动生成的 &lt;code&gt;'+='&lt;/code&gt; 来实现的。如果增量操作是通过调用 &lt;code&gt;'+'&lt;/code&gt; 方法来实现的，则不会被调用，因为在等效代码中，</target>
        </trans-unit>
        <trans-unit id="ed73a5b2044d7fb703c52c07bf589cfde908abd5" translate="yes" xml:space="preserve">
          <source>The copy constructor is not called if Perl determines that it is unnecessary because there is no other reference to the data being modified.</source>
          <target state="translated">如果Perl认为不需要复制构造函数,因为没有其他被修改的数据的引用,那么复制构造函数就不会被调用。</target>
        </trans-unit>
        <trans-unit id="dd210b745dfa94e566cd092061cca3c4c3e619ac" translate="yes" xml:space="preserve">
          <source>The core &lt;a href=&quot;devel/peek&quot;&gt;Devel::Peek&lt;/a&gt; module lets us examine SVs from a Perl program. Let's see, for instance, how Perl treats the constant &lt;code&gt;&quot;hello&quot;&lt;/code&gt; .</source>
          <target state="translated">核心的&lt;a href=&quot;devel/peek&quot;&gt;Devel :: Peek&lt;/a&gt;模块使我们可以从Perl程序中检查SV。例如，让我们看看Perl如何对待常量 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="216872d0879be12be32ab51a2f74dd9e0b301e2c" translate="yes" xml:space="preserve">
          <source>The core development team (known as the Perl Porters) are a group of highly altruistic individuals committed to producing better software for free than you could hope to purchase for money. You may snoop on pending developments via the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.nntp.perl.org%2fgroup%2fperl.perl5.porters%2f&quot;&gt;archives&lt;/a&gt; or read the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fdev.perl.org%2fperl5%2fdocs%2fp5p-faq.html&quot;&gt;faq&lt;/a&gt;, or you can subscribe to the mailing list by sending perl5-porters-subscribe@perl.org a subscription request (an empty message with no subject is fine).</source>
          <target state="translated">核心开发团队（称为Perl Porters）是一群高度利他的人，他们致力于免费生产比您希望花钱买的更好的软件。您可以通过&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.nntp.perl.org%2fgroup%2fperl.perl5.porters%2f&quot;&gt;归档文件&lt;/a&gt;窥探未完成的开发或阅读&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fdev.perl.org%2fperl5%2fdocs%2fp5p-faq.html&quot;&gt;常见问题&lt;/a&gt;解答，也可以通过向perl5-porters-subscribe@perl.org发送订阅请求来订阅邮件列表（无主题的空消息是可以的）。</target>
        </trans-unit>
        <trans-unit id="0cd6f3115d2d6dbe91a070c10c729356bd227008" translate="yes" xml:space="preserve">
          <source>The core distribution can now run its regression tests in parallel on Unix-like platforms. Instead of running &lt;code&gt;make test&lt;/code&gt; , set &lt;code&gt;TEST_JOBS&lt;/code&gt; in your environment to the number of tests to run in parallel, and run &lt;code&gt;make test_harness&lt;/code&gt; . On a Bourne-like shell, this can be done as</source>
          <target state="translated">现在，核心发行版可以在类似Unix的平台上并行运行其回归测试。不必运行 &lt;code&gt;make test&lt;/code&gt; ， &lt;code&gt;TEST_JOBS&lt;/code&gt; 将环境中的TEST_JOBS设置为要并行运行的测试数，然后运行 &lt;code&gt;make test_harness&lt;/code&gt; 。在类似Bourne的外壳上，可以这样完成</target>
        </trans-unit>
        <trans-unit id="e662bc8801eef788dff3d6316ec77e7ad811db79" translate="yes" xml:space="preserve">
          <source>The core uses the same testing style as the rest of Perl, a simple &quot;ok/not ok&quot; run through Test::Harness, but there are a few special considerations.</source>
          <target state="translated">该核心使用与Perl其他部分相同的测试风格,即通过Test::Harness运行简单的 &quot;ok/not ok&quot;,但有一些特殊的考虑。</target>
        </trans-unit>
        <trans-unit id="a3ac8ff08d630fcfeea5350e81e0c2b799df3c84" translate="yes" xml:space="preserve">
          <source>The corpse of a &lt;b&gt;process&lt;/b&gt;, in the form of a file left in the &lt;b&gt;working directory&lt;/b&gt; of the process, usually as a result of certain kinds of fatal errors.</source>
          <target state="translated">&lt;b&gt;进程&lt;/b&gt;的尸体，通常是某些致命错误的结果，以文件形式保留在进程的&lt;b&gt;工作目录&lt;/b&gt;中。</target>
        </trans-unit>
        <trans-unit id="ad72ec528dbf7e40ea844e46e3a129f3b3eadb6f" translate="yes" xml:space="preserve">
          <source>The correct code is &lt;code&gt;MAN3PODS =&amp;gt; { }&lt;/code&gt; .</source>
          <target state="translated">正确的代码是 &lt;code&gt;MAN3PODS =&amp;gt; { }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7eb7322d9e711d10a989215f61754b35fdcb57a5" translate="yes" xml:space="preserve">
          <source>The correct procedure, then, is to use &lt;code&gt;newRV_noinc&lt;/code&gt; instead of &lt;code&gt;newRV_inc&lt;/code&gt; . Then, if and when the last reference is destroyed, the reference count of the SV will go to zero and it will be destroyed, stopping any memory leak.</source>
          <target state="translated">因此，正确的过程是使用 &lt;code&gt;newRV_noinc&lt;/code&gt; 而不是 &lt;code&gt;newRV_inc&lt;/code&gt; 。然后，如果并且当最后一个引用被销毁时，SV的引用计数将变为零并被销毁，从而停止任何内存泄漏。</target>
        </trans-unit>
        <trans-unit id="e90480b056b891e1197a3bfca2f65f9341469925" translate="yes" xml:space="preserve">
          <source>The correspondence between OPs and</source>
          <target state="translated">业务方案和执行部分之间的对应关系</target>
        </trans-unit>
        <trans-unit id="3e632bae0f91b7fe9b42695b7f4eb9541547d7ab" translate="yes" xml:space="preserve">
          <source>The corresponding bright foreground color attributes (colors 8 to 15) are:</source>
          <target state="translated">对应的亮丽前景色属性(颜色8至15)为:。</target>
        </trans-unit>
        <trans-unit id="15d3a8f91abd0b678be46a5c74457eb9c1a22a59" translate="yes" xml:space="preserve">
          <source>The corresponding command to get the current value of &lt;code&gt;$version&lt;/code&gt; is:</source>
          <target state="translated">获取 &lt;code&gt;$version&lt;/code&gt; 当前值的相应命令是：</target>
        </trans-unit>
        <trans-unit id="05b1215b3085d02b291dbd96e47ab01de8dfb44a" translate="yes" xml:space="preserve">
          <source>The corresponding values are interpreted as regular expressions. The &lt;code&gt;distribution&lt;/code&gt; related one will be matched against the canonical distribution name, e.g. &quot;AUTHOR/Foo-Bar-3.14.tar.gz&quot;.</source>
          <target state="translated">相应的值被解释为正则表达式。与该 &lt;code&gt;distribution&lt;/code&gt; 相关的发行版将与规范的发行版名称匹配，例如&amp;ldquo; AUTHOR / Foo-Bar-3.14.tar.gz&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="128893376b086988df0b6fe82266dcff7ded3c2c" translate="yes" xml:space="preserve">
          <source>The corresponding values are references to functions which take three arguments: the first one is the</source>
          <target state="translated">相应的值是对函数的引用,这些函数有三个参数:第一个参数是</target>
        </trans-unit>
        <trans-unit id="6d3c7b629f0ebabb7666a1418d689e5fcefefd4a" translate="yes" xml:space="preserve">
          <source>The count of the saved lines in the history (assuming &lt;code&gt;HistFile&lt;/code&gt; above).</source>
          <target state="translated">历史记录中已保存的行数（假设上面的 &lt;code&gt;HistFile&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8a76e9ed23620e2d0138b893f98a44b589dac036" translate="yes" xml:space="preserve">
          <source>The cpd tool detects cut-and-paste coding. If one instance of the cut-and-pasted code changes, all the other spots should probably be changed, too. Therefore such code should probably be turned into a subroutine or a macro.</source>
          <target state="translated">cpd工具可以检测剪切和粘贴的代码。如果剪切和粘贴的代码的一个实例发生了变化,那么其他所有的点可能也应该被改变。因此,这样的代码可能应该变成一个子程序或一个宏。</target>
        </trans-unit>
        <trans-unit id="4315b91912980da8ee0d1d0ed73982372319566a" translate="yes" xml:space="preserve">
          <source>The critical thing when considering performance is to remember there is no such thing as a &lt;code&gt;Golden Bullet&lt;/code&gt; , which is why there are no rules, only guidelines.</source>
          <target state="translated">考虑性能时，关键是要记住没有&amp;ldquo; &lt;code&gt;Golden Bullet&lt;/code&gt; 类的东西，这就是为什么没有规则，只有准则的原因。</target>
        </trans-unit>
        <trans-unit id="2b2f6d378553efd3b9ab7bab3a4069e081f7b24e" translate="yes" xml:space="preserve">
          <source>The crucial thing to understand about the Windows environment is that the command line you type in is processed twice before Perl sees it. First, your command shell (usually CMD.EXE) preprocesses the command line, to handle redirection, environment variable expansion, and location of the executable to run. Then, the perl executable splits the remaining command line into individual arguments, using the C runtime library upon which Perl was built.</source>
          <target state="translated">关于Windows环境,最关键的一点是,你输入的命令行在Perl看到它之前会被处理两次。首先,你的命令壳(通常是 CMD.EXE)会对命令行进行预处理,以处理重定向、环境变量扩展和可执行文件的位置。然后,perl可执行文件将剩余的命令行分割成各个参数,使用Perl赖以建立的C运行库。</target>
        </trans-unit>
        <trans-unit id="1bc259f8a74780b8f0344bb67ea81414fbf6762f" translate="yes" xml:space="preserve">
          <source>The crypt package distributed with Cygwin is a Linux compatible 56-bit DES crypt port by Corinna Vinschen.</source>
          <target state="translated">与Cygwin一起发布的加密包是Corinna Vinschen的一个Linux兼容的56位DES加密端口。</target>
        </trans-unit>
        <trans-unit id="831281b1eb1b6cf65cdf498d326c123b4d2ac980" translate="yes" xml:space="preserve">
          <source>The csh_glob() function can also be exported, but you should not use it directly unless you really know what you are doing. It splits the pattern into words and feeds each one to bsd_glob(). Perl's own glob() function uses this internally.</source>
          <target state="translated">csh_glob()函数也可以导出,但是你不应该直接使用它,除非你真的知道你在做什么。它将模式分割成单词,并将每个单词喂给bsd_glob()。Perl 自己的 glob()函数在内部使用了这个。</target>
        </trans-unit>
        <trans-unit id="bb0c5fc2762311ff2f0c2ca9c51463e63c575d45" translate="yes" xml:space="preserve">
          <source>The ctime() function provides a way of getting at the scalar sense of the original CORE::localtime() function.</source>
          <target state="translated">ctime()函数提供了一种获取原始CORE::localtime()函数的标量意义的方法。</target>
        </trans-unit>
        <trans-unit id="cc603efa123dedf5ee9218533c5f2218c02b0847" translate="yes" xml:space="preserve">
          <source>The cube root [C99].</source>
          <target state="translated">立方根【C99】。</target>
        </trans-unit>
        <trans-unit id="64523d7c78b273edb939e95b2a44e78339d21a0e" translate="yes" xml:space="preserve">
          <source>The current format name is stored in the variable &lt;code&gt;$~&lt;/code&gt; (&lt;code&gt;$FORMAT_NAME&lt;/code&gt; ), and the current top of form format name is in &lt;code&gt;$^&lt;/code&gt; (&lt;code&gt;$FORMAT_TOP_NAME&lt;/code&gt; ). The current output page number is stored in &lt;code&gt;$%&lt;/code&gt; (&lt;code&gt;$FORMAT_PAGE_NUMBER&lt;/code&gt; ), and the number of lines on the page is in &lt;code&gt;$=&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_PER_PAGE&lt;/code&gt; ). Whether to autoflush output on this handle is stored in &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$OUTPUT_AUTOFLUSH&lt;/code&gt; ). The string output before each top of page (except the first) is stored in &lt;code&gt;$^L&lt;/code&gt; (&lt;code&gt;$FORMAT_FORMFEED&lt;/code&gt; ). These variables are set on a per-filehandle basis, so you'll need to select() into a different one to affect them:</source>
          <target state="translated">当前格式名称存储在变量 &lt;code&gt;$~&lt;/code&gt; （ &lt;code&gt;$FORMAT_NAME&lt;/code&gt; ）中，当前表单格式名称的顶部位于 &lt;code&gt;$^&lt;/code&gt; （ &lt;code&gt;$FORMAT_TOP_NAME&lt;/code&gt; ）中。当前输出页码存储在 &lt;code&gt;$%&lt;/code&gt; （ &lt;code&gt;$FORMAT_PAGE_NUMBER&lt;/code&gt; ）中，页面上的行数存储在 &lt;code&gt;$=&lt;/code&gt; （ &lt;code&gt;$FORMAT_LINES_PER_PAGE&lt;/code&gt; ）中。是否自动刷新此句柄上的输出存储在 &lt;code&gt;$|&lt;/code&gt; （ &lt;code&gt;$OUTPUT_AUTOFLUSH&lt;/code&gt; ）。每个页面顶部（第一个顶部除外）之前输出的字符串存储在 &lt;code&gt;$^L&lt;/code&gt; （ &lt;code&gt;$FORMAT_FORMFEED&lt;/code&gt; ）。这些变量是在每个文件句柄的基础上设置的，因此您需要将select（）放入另一个变量中以影响它们：</target>
        </trans-unit>
        <trans-unit id="bbbf873260d45973f075c0f7d16575580f2c6333" translate="yes" xml:space="preserve">
          <source>The current hierarchy is:</source>
          <target state="translated">目前的等级制度是:</target>
        </trans-unit>
        <trans-unit id="824b38e0c77c472868114a17d1e97b269bb0ba11" translate="yes" xml:space="preserve">
          <source>The current implementation does not allow specification of the required version of the module.</source>
          <target state="translated">目前的实施方式不允许指定模块的所需版本。</target>
        </trans-unit>
        <trans-unit id="282bec354d0f4d4b762dd47ad0eb5b6ecfd1f6ce" translate="yes" xml:space="preserve">
          <source>The current input line is normally in $_, not $0. It generally does not have the newline stripped. ($0 is the name of the program executed.) See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">当前输入行通常在$ _中，而不是$ 0中。它通常不会删除换行符。（$ 0是执行的程序的名称。）请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18f618cc025364ce800e5f345611b3c1497a1ed6" translate="yes" xml:space="preserve">
          <source>The current kinds of Magic Virtual Tables are:</source>
          <target state="translated">目前魔幻虚拟表的种类有。</target>
        </trans-unit>
        <trans-unit id="5c4fde69768c885a1c05aaf0e69e2380f88e2b66" translate="yes" xml:space="preserve">
          <source>The current leading implementation of Perl 6, Rakudo, released a &quot;useful, usable, 'early adopter'&quot; distribution of Perl 6 (called Rakudo Star) in July of 2010. Please see &lt;a href=&quot;http://rakudo.org/&quot;&gt;http://rakudo.org/&lt;/a&gt; for more information.</source>
          <target state="translated">Perl 6 Rakudo的当前领先实现在2010年7月发布了Perl 6（称为Rakudo Star）的&amp;ldquo;有用，可用，'早期采用者'&amp;rdquo;发行版。有关更多信息，请访问&lt;a href=&quot;http://rakudo.org/&quot;&gt;http://rakudo.org/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22d3f495bb4240a9d3bab6ec75da601351d12c2b" translate="yes" xml:space="preserve">
          <source>The current locale is exposed to XS code except possibly &lt;code&gt;LC_NUMERIC&lt;/code&gt; (explained in the next paragraph). There have not been reports of problems with the other categories. Perl initializes things on start-up so that the current locale is the one which is indicated by the user's environment in effect at that time. See &lt;a href=&quot;perllocale#ENVIRONMENT&quot;&gt;ENVIRONMENT in perllocale&lt;/a&gt;.</source>
          <target state="translated">除了 &lt;code&gt;LC_NUMERIC&lt;/code&gt; （在下一段中说明）之外，当前语言环境都暴露于XS代码。尚未有其他类别问题的报告。Perl在启动时初始化事物，以便当前的语言环境是当时有效的用户环境所指示的语言环境。请参见&lt;a href=&quot;perllocale#ENVIRONMENT&quot;&gt;perllocale中的环境&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="061c069ca3fcc48e2c1a6a5055f7be81ca6838c7" translate="yes" xml:space="preserve">
          <source>The current locale is set at execution time by &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; described below. If that function hasn't yet been called in the course of the program's execution, the current locale is that which was determined by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; in effect at the start of the program. If there is no valid environment, the current locale is whatever the system default has been set to. On POSIX systems, it is likely, but not necessarily, the &quot;C&quot; locale. On Windows, the default is set via the computer's &lt;code&gt;Control Panel-&amp;gt;Regional &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; Language Options&lt;/code&gt; (or its current equivalent).</source>
          <target state="translated">当前语言环境是在执行时通过以下描述的&lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale（）&lt;/a&gt;设置的。如果尚未在程序执行过程中调用该函数，则当前语言环境是由程序启动时有效的&lt;a href=&quot;#ENVIRONMENT&quot;&gt;环境&lt;/a&gt;确定的语言环境。如果没有有效的环境，则当前语言环境将是系统默认设置。在POSIX系统上，它可能是（但不一定是）&amp;ldquo; C&amp;rdquo;语言环境。在Windows上，默认值是通过计算机的&amp;ldquo; &lt;code&gt;Control Panel-&amp;gt;Regional &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; Language Options&lt;/code&gt; （或其当前等效项）设置的。</target>
        </trans-unit>
        <trans-unit id="b7f42f27fb52f98cb07c551fabc648053a689c30" translate="yes" xml:space="preserve">
          <source>The current locale is used when going outside of Perl with operations like &lt;a href=&quot;functions/system&quot;&gt;system LIST&lt;/a&gt; or &lt;a href=&quot;perlop#qx%2fSTRING%2f&quot;&gt;qx//&lt;/a&gt;, if those operations are locale-sensitive.</source>
          <target state="translated">如果在Perl之外进行&lt;a href=&quot;functions/system&quot;&gt;系统LIST&lt;/a&gt;或&lt;a href=&quot;perlop#qx%2fSTRING%2f&quot;&gt;qx //之类的&lt;/a&gt;操作，则使用当前语言环境（如果这些操作对语言环境敏感）。</target>
        </trans-unit>
        <trans-unit id="ea51628874f50840c20248e49e31ecc39bc8aab0" translate="yes" xml:space="preserve">
          <source>The current major release of Perl is Perl 5, first released in 1994. It can run scripts from the previous major release, Perl 4 (March 1991), but has significant differences.</source>
          <target state="translated">目前Perl的主要版本是Perl 5,1994年首次发布。它可以运行前一个主要版本Perl 4(1991年3月)的脚本,但有重大区别。</target>
        </trans-unit>
        <trans-unit id="1ad75b57a59621fb77288b117b229032ac9f513f" translate="yes" xml:space="preserve">
          <source>The current naming convention is:</source>
          <target state="translated">目前的命名惯例是:</target>
        </trans-unit>
        <trans-unit id="b2e2b3b69c2218e4d8359acb1335a4024632d82a" translate="yes" xml:space="preserve">
          <source>The current offset on the Perl internal stack (cf. &lt;code&gt;SP&lt;/code&gt; ) is restored at the end of</source>
          <target state="translated">Perl内部堆栈（请参阅 &lt;code&gt;SP&lt;/code&gt; ）上的当前偏移量将在</target>
        </trans-unit>
        <trans-unit id="c030186501458b34adb46e2d42aa7b81f218a056" translate="yes" xml:space="preserve">
          <source>The current page length (printable lines) of the currently selected output channel. The default is 60.</source>
          <target state="translated">当前选定的输出通道的当前页长(可打印行数)。默认值为60。</target>
        </trans-unit>
        <trans-unit id="3d4eb19bb10369473283d32cc7dd71a86ff46c90" translate="yes" xml:space="preserve">
          <source>The current page number of the currently selected output channel.</source>
          <target state="translated">当前选择的输出通道的当前页码。</target>
        </trans-unit>
        <trans-unit id="770296232bd3d822ead8ffe492b7e0e282b9f95e" translate="yes" xml:space="preserve">
          <source>The current phase of the perl interpreter.</source>
          <target state="translated">当前阶段的perl解释器。</target>
        </trans-unit>
        <trans-unit id="a2857cd700aaf0537f04949257bdb10786ea5148" translate="yes" xml:space="preserve">
          <source>The current set of characters after which a string may be broken to fill continuation fields (starting with &lt;code&gt;^&lt;/code&gt;) in a format. The default is &quot; \n-&quot;, to break on a space, newline, or a hyphen.</source>
          <target state="translated">当前字符集，字符串之后可以被打断以填充格式中的连续字段（以 &lt;code&gt;^&lt;/code&gt; 开头）。默认值为&amp;ldquo; \ n-&amp;rdquo;，以空格，换行符或连字符开头。</target>
        </trans-unit>
        <trans-unit id="981300e195cac4e7353f833304330d8ac58b67a9" translate="yes" xml:space="preserve">
          <source>The current set of warning checks enabled by the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma. It has the same scoping as the &lt;code&gt;$^H&lt;/code&gt; and &lt;code&gt;%^H&lt;/code&gt; variables. The exact values are considered internal to the &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; pragma and may change between versions of Perl.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 编译指示启用的当前警告检查集。它具有与 &lt;code&gt;$^H&lt;/code&gt; 和 &lt;code&gt;%^H&lt;/code&gt; 变量相同的作用域。确切的值被认为是&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;实用程序内部的值，并且可能在Perl版本之间发生变化。</target>
        </trans-unit>
        <trans-unit id="e48b124af22e055d2f998460eddfa2b05c504d05" translate="yes" xml:space="preserve">
          <source>The current setting for a particular CV can be retrieved by &lt;a href=&quot;#cv_get_call_checker&quot;&gt;cv_get_call_checker&lt;/a&gt;.</source>
          <target state="translated">特定CV的当前设置可以通过&lt;a href=&quot;#cv_get_call_checker&quot;&gt;cv_get_call_checker&lt;/a&gt;检索。</target>
        </trans-unit>
        <trans-unit id="b952480064e555e874a4e5bab67374e0afa43170" translate="yes" xml:space="preserve">
          <source>The current state is quite close to this target. Known limitations:</source>
          <target state="translated">目前的状态与这个目标相当接近。已知的限制。</target>
        </trans-unit>
        <trans-unit id="8b45957d0c48ff5a61159add09d1cced4fe06354" translate="yes" xml:space="preserve">
          <source>The current value of &lt;code&gt;$,&lt;/code&gt; (if any) is printed between each LIST item. The current value of &lt;code&gt;$\&lt;/code&gt; (if any) is printed after the entire LIST has been printed. Because print takes a LIST, anything in the LIST is evaluated in list context, including any subroutines whose return lists you pass to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;. Be careful not to follow the print keyword with a left parenthesis unless you want the corresponding right parenthesis to terminate the arguments to the print; put parentheses around all arguments (or interpose a &lt;code&gt;+&lt;/code&gt; , but that doesn't look as good).</source>
          <target state="translated">&lt;code&gt;$,&lt;/code&gt; 的当前值（如果有）在每个LIST项目之间打印。 &lt;code&gt;$\&lt;/code&gt; （如果有的话）的当前值在打印整个LIST之后打印。因为print需要一个LIST，所以LIST中的所有内容都会在列表上下文中进行评估，包括将其返回列表传递给 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 的所有子例程。注意不要在print关键字后面加上左括号，除非您希望相应的右括号终止打印的参数。在所有参数周围加上括号（或插入 &lt;code&gt;+&lt;/code&gt; ，但这看起来不太好）。</target>
        </trans-unit>
        <trans-unit id="d3b381c8d22a96ce946901e90864741d92df1af5" translate="yes" xml:space="preserve">
          <source>The current value of &lt;code&gt;$,&lt;/code&gt; (if any) is printed between each LIST item. The current value of &lt;code&gt;$\&lt;/code&gt; (if any) is printed after the entire LIST has been printed. Because print takes a LIST, anything in the LIST is evaluated in list context, including any subroutines whose return lists you pass to &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;. Be careful not to follow the print keyword with a left parenthesis unless you want the corresponding right parenthesis to terminate the arguments to the print; put parentheses around all arguments (or interpose a &lt;code&gt;+&lt;/code&gt; , but that doesn't look as good).</source>
          <target state="translated">&lt;code&gt;$,&lt;/code&gt; 的当前值（如果有）在每个LIST项目之间打印。 &lt;code&gt;$\&lt;/code&gt; （如果有的话）的当前值在打印整个LIST之后打印。因为print需要一个LIST，所以LIST中的所有内容都会在列表上下文中进行评估，包括将其返回列表传递给 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 的所有子例程。注意不要在print关键字后面加上左括号，除非您希望相应的右括号终止打印的参数。在所有参数周围加上括号（或插入 &lt;code&gt;+&lt;/code&gt; ，但这看起来不太好）。</target>
        </trans-unit>
        <trans-unit id="16a7c40e8bbfe13e91d735da741af8520eabede2" translate="yes" xml:space="preserve">
          <source>The current value of &lt;code&gt;$archname&lt;/code&gt; can be found with this command:</source>
          <target state="translated">&lt;code&gt;$archname&lt;/code&gt; 的当前值可以通过以下命令找到：</target>
        </trans-unit>
        <trans-unit id="db4a25bfed587546962de5c8d6543f967c92521a" translate="yes" xml:space="preserve">
          <source>The current value of the &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; accumulator for &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; lines. A format contains &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; calls that put their result into &lt;code&gt;$^A&lt;/code&gt; . After calling its format, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; prints out the contents of &lt;code&gt;$^A&lt;/code&gt; and empties. So you never really see the contents of &lt;code&gt;$^A&lt;/code&gt; unless you call &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; yourself and then look at it. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; and &lt;a href=&quot;functions/formline&quot;&gt;formline PICTURE,LIST&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; 行的 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 累加器的当前值。一个格式包含 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; 是把他们的结果为调用 &lt;code&gt;$^A&lt;/code&gt; 。调用其格式后， &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 打印 &lt;code&gt;$^A&lt;/code&gt; 的内容并为空。因此，除非您自己调用 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; 然后再查看它，否则您将永远看不到 &lt;code&gt;$^A&lt;/code&gt; 的内容。请参见&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;和&lt;a href=&quot;functions/formline&quot;&gt;formline PICTURE，LIST&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed07dc52d8f87fe5efbcd1795acd592cb2bcdd55" translate="yes" xml:space="preserve">
          <source>The current value of the debugging flags. May be read or set. Like its command-line equivalent, you can use numeric or symbolic values, eg &lt;code&gt;$^D = 10&lt;/code&gt; or &lt;code&gt;$^D = &quot;st&quot;&lt;/code&gt; .</source>
          <target state="translated">调试标志的当前值。可以读取或设置。像其命令行等效项一样，您可以使用数字或符号值，例如 &lt;code&gt;$^D = 10&lt;/code&gt; 或 &lt;code&gt;$^D = &quot;st&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="761048a9f6779920117c38b6975281ec2824cbaa" translate="yes" xml:space="preserve">
          <source>The current value of the flag associated with the &lt;b&gt;-c&lt;/b&gt; switch. Mainly of use with &lt;b&gt;-MO=...&lt;/b&gt; to allow code to alter its behavior when being compiled, such as for example to &lt;code&gt;AUTOLOAD&lt;/code&gt; at compile time rather than normal, deferred loading. Setting &lt;code&gt;$^C = 1&lt;/code&gt; is similar to calling &lt;code&gt;B::minus_c&lt;/code&gt; .</source>
          <target state="translated">与&lt;b&gt;-c&lt;/b&gt;开关关联的标志的当前值。主要与&lt;b&gt;-MO = ...&lt;/b&gt;一起使用，以允许代码在编译时更改其行为，例如在编译时更改为 &lt;code&gt;AUTOLOAD&lt;/code&gt; ，而不是正常的延迟加载。设置 &lt;code&gt;$^C = 1&lt;/code&gt; 类似于调用 &lt;code&gt;B::minus_c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5468ce0ac69ee02e09a591df294df02b8e8e00dd" translate="yes" xml:space="preserve">
          <source>The current value of the inplace-edit extension. Use &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to disable inplace editing.</source>
          <target state="translated">Inplace-Edit扩展的当前值。使用 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 禁用就地编辑。</target>
        </trans-unit>
        <trans-unit id="ab0d30902e8f62034444f0c46f34be59caec65d2" translate="yes" xml:space="preserve">
          <source>The current value of the regex debugging flags. Set to 0 for no debug output even when the &lt;code&gt;re 'debug'&lt;/code&gt; module is loaded. See &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; for details.</source>
          <target state="translated">regex调试标志的当前值。即使加载了 &lt;code&gt;re 'debug'&lt;/code&gt; 模块，也没有任何调试输出，设置为0 。有关详细信息，请参见&lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a22922d7a166dbc35ec6d0a0c534fd11892caf1b" translate="yes" xml:space="preserve">
          <source>The current value of the warning switch, initially true if &lt;b&gt;-w&lt;/b&gt; was used, false otherwise, but directly modifiable.</source>
          <target state="translated">警告开关的当前值，如果使用&lt;b&gt;-w&lt;/b&gt;，则最初为true ，否则为false，但可以直接修改。</target>
        </trans-unit>
        <trans-unit id="434ca8d76bd8ecc27a064789f98b19395ab4f212" translate="yes" xml:space="preserve">
          <source>The current version of the standards for &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; is available at &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&lt;/a&gt;上提供了 &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; 标准的当前版本。</target>
        </trans-unit>
        <trans-unit id="6af70deb3b449e89c48e84135fbdeb7d79f07a9c" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/ansicolor/&quot;&gt;http://www.eyrie.org/~eagle/software/ansicolor/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">该模块的当前版本始终可以从其网站&lt;a href=&quot;http://www.eyrie.org/~eagle/software/ansicolor/&quot;&gt;http://www.eyrie.org/~eagle/software/ansicolor/中获得&lt;/a&gt;。从5.6.0版开始，它也是Perl核心发行版的一部分。</target>
        </trans-unit>
        <trans-unit id="b31c3cebc8faae4e8a4925e48535264d89073d95" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;.</source>
          <target state="translated">该模块的当前版本始终可以从其网站上获得，网址为&lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f5a8854edfd01b7a5e559e1a5294ccbba9d0afe6" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">该模块的当前版本始终可以从其网站上获得，网址为&lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;。从5.6.0版开始，它也是Perl核心发行版的一部分。</target>
        </trans-unit>
        <trans-unit id="c47cd4fd8d9bd245ee61848360efac4088607cb6" translate="yes" xml:space="preserve">
          <source>The current version of this script is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">该脚本的当前版本始终可以从其网站&lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/中获得&lt;/a&gt;。从5.6.0版开始，它也是Perl核心发行版的一部分。</target>
        </trans-unit>
        <trans-unit id="9d8fe5626c6979a9718f106c0652b7d905296f64" translate="yes" xml:space="preserve">
          <source>The current version was written by Graham Barr.</source>
          <target state="translated">目前的版本是由Graham Barr撰写的。</target>
        </trans-unit>
        <trans-unit id="7c32f08e82229236d88693ec9eaad5ec8a635209" translate="yes" xml:space="preserve">
          <source>The current working directory of the program is</source>
          <target state="translated">当前程序的工作目录是</target>
        </trans-unit>
        <trans-unit id="588f5e820c106e9822f858102bdf0e7ae9b574c7" translate="yes" xml:space="preserve">
          <source>The customary Perl approach for processing all the lines in a file is to do so one line at a time:</source>
          <target state="translated">习惯的Perl处理文件中所有行的方法是一次只处理一行。</target>
        </trans-unit>
        <trans-unit id="a4504c4a63cdd557da723133c8d2b75666dc8630" translate="yes" xml:space="preserve">
          <source>The cwd() is the most natural form for the current architecture. For most systems it is identical to `pwd` (but without the trailing line terminator).</source>
          <target state="translated">cwd()是当前结构中最自然的形式。对于大多数系统来说,它与 &quot;pwd &quot;相同(但没有尾行结束符)。</target>
        </trans-unit>
        <trans-unit id="40c9ebfbdf9a557c5ad182c1d60f03fd99fa74ef" translate="yes" xml:space="preserve">
          <source>The data argument passes in the value (if any) associated with the attribute. For example, if &lt;code&gt;&amp;amp;foo&lt;/code&gt; had been declared:</source>
          <target state="translated">数据参数传入与属性关联的值（如果有）。例如，如果已声明 &lt;code&gt;&amp;amp;foo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4057a2800ea2edef8acd376fce4a738947ca16f2" translate="yes" xml:space="preserve">
          <source>The data can be aggregated into obvious structures, especially if there's a large amount of data in each aggregate.</source>
          <target state="translated">可以将数据聚合成明显的结构,特别是当每个聚合中的数据量很大时。</target>
        </trans-unit>
        <trans-unit id="f1737bbb402e005395886a66a62fefd166798f8a" translate="yes" xml:space="preserve">
          <source>The data is stored as a list of values from the time and times functions:</source>
          <target state="translated">数据以时间和时间函数的值列表的形式存储。</target>
        </trans-unit>
        <trans-unit id="083ecdb4eb83b1283f9d7370b6905eb300e214e7" translate="yes" xml:space="preserve">
          <source>The data may be retrieved using the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; function if the underlying type of the byte stream is known.</source>
          <target state="translated">如果字节流的基础类型是已知的，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 函数来检索数据。</target>
        </trans-unit>
        <trans-unit id="9bb2c0f943e4592858ab2d05373119174b2d2dda" translate="yes" xml:space="preserve">
          <source>The data was added as a Unicode string and when writing it out to disk, the &lt;code&gt;:utf8&lt;/code&gt; line discipline wasn't set by &lt;code&gt;Archive::Tar&lt;/code&gt; , so Perl tried to convert the string to ISO-8859 and failed. The written file now contains garbage.</source>
          <target state="translated">数据作为Unicode字符串添加，并且在将其写到磁盘时， &lt;code&gt;Archive::Tar&lt;/code&gt; 并未设置 &lt;code&gt;:utf8&lt;/code&gt; 行规则，因此Perl尝试将字符串转换为ISO-8859并失败。写入的文件现在包含垃圾。</target>
        </trans-unit>
        <trans-unit id="93ccb288f67ba8fe0c8510721b3e70886d45432a" translate="yes" xml:space="preserve">
          <source>The date and day names in dates formatted by &lt;code&gt;strftime()&lt;/code&gt; could be manipulated to advantage by a malicious user able to subvert the &lt;code&gt;LC_DATE&lt;/code&gt; locale. (&quot;Look--it says I wasn't in the building on Sunday.&quot;)</source>
          <target state="translated">能够颠覆 &lt;code&gt;LC_DATE&lt;/code&gt; 区域设置的恶意用户可以利用 &lt;code&gt;strftime()&lt;/code&gt; 格式化的日期中的日期和日期名称加以利用。（&amp;ldquo;看，它说我星期天不在大楼里。&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="c40b16f78ce75cc859be91a0613f27d3f68c2364" translate="yes" xml:space="preserve">
          <source>The day of the year is in the list returned by the &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; function. Without an argument &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; uses the current time.</source>
          <target state="translated">一年中的哪一天在 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 函数返回的列表中。不带参数的 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 使用当前时间。</target>
        </trans-unit>
        <trans-unit id="32d7e957f2b60e8e8af1a45f78007f3a710223c2" translate="yes" xml:space="preserve">
          <source>The days of just flinging strings around are over. It's well established that modern programs need to be capable of communicating funny accented letters, and things like euro symbols. This means that programmers need new habits. It's easy to program Unicode capable software, but it does require discipline to do it right.</source>
          <target state="translated">仅仅是甩动字符串的日子已经结束了。现代程序需要能够交流有趣的重音字母,以及像欧元符号这样的东西,这是公认的。这意味着程序员需要新的习惯。编写具有Unicode功能的软件是很容易的,但要做好它确实需要纪律。</target>
        </trans-unit>
        <trans-unit id="7d9856be0d4d4aa47742843ac8ee15803c0a6dbf" translate="yes" xml:space="preserve">
          <source>The debugger does not currently work in conjunction with the &lt;b&gt;-W&lt;/b&gt; command-line switch, because it itself is not free of warnings.</source>
          <target state="translated">调试器当前不能与&lt;b&gt;-W&lt;/b&gt;命令行开关一起使用，因为它本身没有警告。</target>
        </trans-unit>
        <trans-unit id="bff20683f233c3b1a43e85dddcc26c68e9457e08" translate="yes" xml:space="preserve">
          <source>The debugger has numerous options settable using the &lt;code&gt;o&lt;/code&gt; command, either interactively or from the environment or an rc file. (./.perldb or ~/.perldb under Unix.)</source>
          <target state="translated">调试器具有可使用 &lt;code&gt;o&lt;/code&gt; 命令设置的众多选项，可以交互地或从环境或rc文件中设置。（./.perldb或Unix下的〜/ .perldb。）</target>
        </trans-unit>
        <trans-unit id="2b8f02d76c62b5ac783a580e7846d6536aa86d85" translate="yes" xml:space="preserve">
          <source>The debugger probably contains enough configuration hooks that you won't ever have to modify it yourself. You may change the behaviour of the debugger from within the debugger using its &lt;code&gt;o&lt;/code&gt; command, from the command line via the &lt;code&gt;PERLDB_OPTS&lt;/code&gt; environment variable, and from customization files.</source>
          <target state="translated">调试器可能包含足够的配置挂钩，您无需亲自对其进行修改。您可以使用调试器的 &lt;code&gt;o&lt;/code&gt; 命令在调试器中，通过 &lt;code&gt;PERLDB_OPTS&lt;/code&gt; 环境变量在命令行中以及在自定义文件中更改调试器的行为。</target>
        </trans-unit>
        <trans-unit id="24bc00b2a7165b041b9ffd101df7fc63fd2218dd" translate="yes" xml:space="preserve">
          <source>The debugger prompt is something like</source>
          <target state="translated">调试器的提示是这样的</target>
        </trans-unit>
        <trans-unit id="f8e855d0dba7087b2dc163f59ea22e7610600301" translate="yes" xml:space="preserve">
          <source>The debugging output at compile time looks like this:</source>
          <target state="translated">编译时的调试输出是这样的。</target>
        </trans-unit>
        <trans-unit id="5cc26823ddc27c25d44117d4b49405e558f3683c" translate="yes" xml:space="preserve">
          <source>The declared variable is not introduced (is not visible) until after the current statement. Thus,</source>
          <target state="translated">声明的变量在当前语句之后才会被引入(不可见)。因此:</target>
        </trans-unit>
        <trans-unit id="9ae51c467cb04a1b525475d0b1964978fbf97d39" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;:perlio&lt;/code&gt; layer retries &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; as described above; interrupted &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; calls will always be retried.</source>
          <target state="translated">默认的 &lt;code&gt;:perlio&lt;/code&gt; 层如上所述重试 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; ；中断的 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 调用将始终重试。</target>
        </trans-unit>
        <trans-unit id="7af57631245798d230b9a42590aed5504edc7411" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;TIEHASH&lt;/code&gt; method stores &quot;extra&quot; arguments to tie() starting from offset 1 in the array referenced by &lt;code&gt;&lt;a href=&quot;../functions/tied&quot;&gt;tied(%tiedhash)&lt;/a&gt;&lt;/code&gt;; this is the same storage algorithm as in TIEHASH subroutine above. Hence, a typical package inheriting from &lt;b&gt;Tie::ExtraHash&lt;/b&gt; does not need to overwrite this method.</source>
          <target state="translated">缺省的 &lt;code&gt;TIEHASH&lt;/code&gt; 方法从&amp;ldquo; tie &lt;code&gt;&lt;a href=&quot;../functions/tied&quot;&gt;tied(%tiedhash)&lt;/a&gt;&lt;/code&gt; 引用的数组中的偏移量1开始，将&amp;ldquo;额外&amp;rdquo;参数存储到tie（）中。这与上面的TIEHASH子例程中的存储算法相同。因此，继承自&lt;b&gt;Tie :: ExtraHash&lt;/b&gt;的典型程序包不需要覆盖此方法。</target>
        </trans-unit>
        <trans-unit id="8bacf1d67275db56db4c207815d6942a42814176" translate="yes" xml:space="preserve">
          <source>The default behavior is restored with the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; pragma, or upon reaching the end of the block enclosing &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . Note that &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; calls may be nested, and that what is in effect within an inner scope will revert to the outer scope's rules at the end of the inner scope.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; 编译命令或在包含 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 的块结束时恢复默认行为。请注意， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 调用可能是嵌套的，内部作用域内有效的内容将在内部作用域末尾恢复为外部作用域的规则。</target>
        </trans-unit>
        <trans-unit id="ebc252c3cc028e1614732f1daa492845981dc49a" translate="yes" xml:space="preserve">
          <source>The default behavior is to allow either VMS or Unix syntax on input and to return VMS syntax on output unless Unix syntax has been explicitly requested via the &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; CRTL feature.</source>
          <target state="translated">缺省行为是允许在输入上使用VMS或Unix语法，并在输出上返回VMS语法，除非已通过 &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; CRTL功能明确请求Unix语法。</target>
        </trans-unit>
        <trans-unit id="6dccc7bf2df4ee545fc6ed04ddf3f01c1358bdf3" translate="yes" xml:space="preserve">
          <source>The default behaviour of file test operators is to use the simple mode bits as returned by the stat() family of system calls. However, many operating systems have additional features to define more complex access rights, for example ACLs (Access Control Lists). For such environments, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; may help the permission operators to return results more consistent with other tools.</source>
          <target state="translated">文件测试操作员的默认行为是使用stat（）系列系统调用返回的简单模式位。但是，许多操作系统具有其他功能来定义更复杂的访问权限，例如ACL（访问控制列表）。对于此类环境， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; 可以帮助权限操作员返回与其他工具更一致的结果。</target>
        </trans-unit>
        <trans-unit id="1e443bdcb2163a4573139a1dc139dfc380443bd8" translate="yes" xml:space="preserve">
          <source>The default blacklist is [qw|ftp|], as &lt;code&gt;/bin/ftp&lt;/code&gt; is rather unreliable.</source>
          <target state="translated">默认的黑名单是[qw | ftp |]，因为 &lt;code&gt;/bin/ftp&lt;/code&gt; 相当不可靠。</target>
        </trans-unit>
        <trans-unit id="ed0767b7e5643475189138ab836319b55629d878" translate="yes" xml:space="preserve">
          <source>The default buffer size is 4096.</source>
          <target state="translated">默认的缓冲区大小为4096。</target>
        </trans-unit>
        <trans-unit id="8bc00fd19b1a0edf6b2c0d08377dcc6685c37357" translate="yes" xml:space="preserve">
          <source>The default can be overridden by setting the environment variable PERLIO to a space separated list of layers (&lt;code&gt;unix&lt;/code&gt; or platform low level layer is always pushed first).</source>
          <target state="translated">可以通过将环境变量PERLIO设置为以空格分隔的层列表来覆盖默认值（始终首先推送 &lt;code&gt;unix&lt;/code&gt; 或平台低层层）。</target>
        </trans-unit>
        <trans-unit id="34b91bbcac281ec343e20574aee63c504ba37c87" translate="yes" xml:space="preserve">
          <source>The default command shells on DOS descendant operating systems (such as they are) usually do not expand wildcard arguments supplied to programs. They consider it the application's job to handle that. This is commonly achieved by linking the application (in our case, perl) with startup code that the C runtime libraries usually provide. However, doing that results in incompatible perl versions (since the behavior of the argv expansion code differs depending on the compiler, and it is even buggy on some compilers). Besides, it may be a source of frustration if you use such a perl binary with an alternate shell that *does* expand wildcards.</source>
          <target state="translated">DOS后代操作系统上的默认命令壳(如它们)通常不会扩展提供给程序的通配符参数。它们认为处理这些参数是应用程序的工作。这通常是通过将应用程序(在我们的例子中,perl)与C运行时库通常提供的启动代码链接来实现的。然而,这样做会导致不兼容的perl版本(因为argv扩展代码的行为根据编译器的不同而不同,甚至在某些编译器上是错误的)。此外,如果你使用这样的perl二进制文件和一个替代的shell,而这个shell是*可以扩展通配符的,那么这可能是一个挫败感的来源。</target>
        </trans-unit>
        <trans-unit id="83afe3e15499ebffd14384524a4838c21ad9ac57" translate="yes" xml:space="preserve">
          <source>The default delivery policy of signals changed in Perl v5.8.0 from immediate (also known as &quot;unsafe&quot;) to deferred, also known as &quot;safe signals&quot;. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more information.</source>
          <target state="translated">信号的默认传递策略在Perl v5.8.0中从即时（也称为&amp;ldquo;不安全&amp;rdquo;）更改为递延（也称为&amp;ldquo;安全信号&amp;rdquo;）。有关更多信息，请参见&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f60de20ca32864441bb2ece16480b765adbc68d5" translate="yes" xml:space="preserve">
          <source>The default filename translation is roughly &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr|/.|./|;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">默认的文件名翻译大约是 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr|/.|./|;&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="141616a08e099cc503e54695ac44f2c439029e1f" translate="yes" xml:space="preserve">
          <source>The default for this option is off.</source>
          <target state="translated">该选项的默认值为关闭。</target>
        </trans-unit>
        <trans-unit id="841e53532f4d336433d317d532f99affc692102b" translate="yes" xml:space="preserve">
          <source>The default hash function has been modified with the intention of making it harder to infer the hash seed.</source>
          <target state="translated">默认的哈希函数已经被修改,目的是为了增加推断哈希种子的难度。</target>
        </trans-unit>
        <trans-unit id="917b792910290b9f104f9e9bb1c1c376f6e62a1b" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing.</source>
          <target state="translated">默认的实现什么也不做。</target>
        </trans-unit>
        <trans-unit id="ba4a564c2fb984db1b9ac70f6b103f10fd3f2c07" translate="yes" xml:space="preserve">
          <source>The default in Perl 5.8.0 and later is to automatically use the &lt;code&gt;:perlio&lt;/code&gt; layer.</source>
          <target state="translated">Perl 5.8.0和更高版本中的默认设置是自动使用 &lt;code&gt;:perlio&lt;/code&gt; 层。</target>
        </trans-unit>
        <trans-unit id="c034d8cea0ccefbe74b407c47763a2d7febf85bd" translate="yes" xml:space="preserve">
          <source>The default input &lt;b&gt;stream&lt;/b&gt; for your program, which if possible shouldn&amp;rsquo;t care where its data is coming from. Represented within a Perl program by the &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDIN&lt;/code&gt; .</source>
          <target state="translated">程序的默认输入&lt;b&gt;流&lt;/b&gt;，如果可能的话，不要理会其数据来自何处。在Perl程序中由&lt;b&gt;文件句柄&lt;/b&gt; &lt;code&gt;STDIN&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="c65b453abcd65763f1788a5bfac88b6cf8e06702" translate="yes" xml:space="preserve">
          <source>The default input and pattern-searching space. The following pairs are equivalent:</source>
          <target state="translated">默认的输入和模式搜索空间。以下对子是等价的。</target>
        </trans-unit>
        <trans-unit id="cea52ce10c001ee673712587e9b895266781fd26" translate="yes" xml:space="preserve">
          <source>The default installation directory of Perl under PASE is /QOpenSys/perl. This can be modified if needed with Configure parameter -Dprefix=/some/dir.</source>
          <target state="translated">PASE下Perl的默认安装目录是/QOpenSys/perl,如果需要,可以通过配置参数-Dprefix=/some/dir来修改。如果需要,可以通过配置参数-Dprefix=/some/dir来修改。</target>
        </trans-unit>
        <trans-unit id="c02bd4590e22b3fdced3d71cd3c3281cc1a0a660" translate="yes" xml:space="preserve">
          <source>The default installation location for this release uses the traditional UNIX directory layout under /usr/local. This is the recommended location for most users, and will leave the Apple-supplied Perl and its modules undisturbed.</source>
          <target state="translated">这个版本的默认安装位置使用传统的 UNIX 目录布局,在 /usr/local 下。对于大多数用户来说,这是推荐的安装位置,它将使 Apple 提供的 Perl 及其模块不受干扰。</target>
        </trans-unit>
        <trans-unit id="2cf27b908bba58a1adbe27495a165db5ad0a8770" translate="yes" xml:space="preserve">
          <source>The default is 0.</source>
          <target state="translated">默认为0。</target>
        </trans-unit>
        <trans-unit id="b6e007f998a46a63459c07f21e8e579bcd3ddb9e" translate="yes" xml:space="preserve">
          <source>The default is 0;</source>
          <target state="translated">默认为0。</target>
        </trans-unit>
        <trans-unit id="2fede1b14731afaa7b9b9368ecc641901f9fa509" translate="yes" xml:space="preserve">
          <source>The default is 1 when &lt;a href=&quot;../warnings&quot;&gt;warnings&lt;/a&gt; are enabled, 0 otherwise;</source>
          <target state="translated">启用&lt;a href=&quot;../warnings&quot;&gt;警告后&lt;/a&gt;，默认值为1 ；否则为0；否则为0。</target>
        </trans-unit>
        <trans-unit id="515832f976590cbb3c71bc0d7d3d0a86a107732b" translate="yes" xml:space="preserve">
          <source>The default is 1.</source>
          <target state="translated">默认为1。</target>
        </trans-unit>
        <trans-unit id="895305ba9904fa755bf8e86c105e9e415a01803b" translate="yes" xml:space="preserve">
          <source>The default is 15 seconds. If you set this value to 0, no timeout will occur, but this is not recommended.</source>
          <target state="translated">默认值是15秒。如果将此值设置为0,则不会发生超时,但不建议这样做。</target>
        </trans-unit>
        <trans-unit id="df47c42104d45d72a320a61c09a39d1b3d97871e" translate="yes" xml:space="preserve">
          <source>The default is 1;</source>
          <target state="translated">默认为1。</target>
        </trans-unit>
        <trans-unit id="f462ad28c3fd0db899a9c6ebf2e36d1b531777fa" translate="yes" xml:space="preserve">
          <source>The default is 4096.</source>
          <target state="translated">默认值为4096。</target>
        </trans-unit>
        <trans-unit id="32bc975de1e1a4635ed927b65955622d6412a442" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;0&lt;/code&gt; .</source>
          <target state="translated">默认值为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b05c3b862baf5dbb3b6628baf4b68b1570abdb4" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;1&lt;/code&gt; .</source>
          <target state="translated">默认值为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e7ce922e57105bce0e95e91cfca276a6a4bf1ac" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;1&lt;/code&gt; for the root user and &lt;code&gt;0&lt;/code&gt; for normal users.</source>
          <target state="translated">对于root用户，默认值为 &lt;code&gt;1&lt;/code&gt; ；对于普通用户，默认值为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbf2b1ea0900573472d5b071e3de19f7567ee6bd" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b961dbd8be6b25800dc4b37b67546efccad28f8e" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; .</source>
          <target state="translated">默认值为 &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc194b0254a7cf1688815756a4f2837510b9b267" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; .</source>
          <target state="translated">默认值为 &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb390eebfd5c04071c6f9ae432a01e30ec460a80" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;pod&lt;/code&gt; .</source>
          <target state="translated">默认值为 &lt;code&gt;pod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d0a0f1ca8eef2f6fbf6f39dbd7668ad5fbc612a" translate="yes" xml:space="preserve">
          <source>The default is Z_DEFAULT_COMPRESSION.</source>
          <target state="translated">默认为Z_DEFAULT_COMPRESSION。</target>
        </trans-unit>
        <trans-unit id="ae93ce6388b29eb983caf1def75b439a9873a0b9" translate="yes" xml:space="preserve">
          <source>The default is Z_DEFAULT_STRATEGY.</source>
          <target state="translated">默认为Z_DEFAULT_STRATEGY。</target>
        </trans-unit>
        <trans-unit id="b30329767ad59c2dc5630061d1ce79106ced2716" translate="yes" xml:space="preserve">
          <source>The default is no dictionary.</source>
          <target state="translated">默认是没有字典。</target>
        </trans-unit>
        <trans-unit id="0eaff3b0b1b9eb661e7fc7bd656a07d77ba2a1ef" translate="yes" xml:space="preserve">
          <source>The default is not to cuddle.</source>
          <target state="translated">默认情况下是不抱团的。</target>
        </trans-unit>
        <trans-unit id="9c65dc0d3752b5562d0e04006d66de6352709010" translate="yes" xml:space="preserve">
          <source>The default is to try &lt;code&gt;native&lt;/code&gt; , &lt;code&gt;tcp&lt;/code&gt; , &lt;code&gt;udp&lt;/code&gt; , &lt;code&gt;unix&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;stream&lt;/code&gt; , &lt;code&gt;console&lt;/code&gt; . Under systems with the Win32 API, &lt;code&gt;eventlog&lt;/code&gt; will be added as the first mechanism to try if &lt;code&gt;Win32::EventLog&lt;/code&gt; is available.</source>
          <target state="translated">默认是尝试使用 &lt;code&gt;native&lt;/code&gt; ， &lt;code&gt;tcp&lt;/code&gt; ， &lt;code&gt;udp&lt;/code&gt; ， &lt;code&gt;unix&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;stream&lt;/code&gt; ， &lt;code&gt;console&lt;/code&gt; 。在使用Win32 API的系统下，将添加 &lt;code&gt;eventlog&lt;/code&gt; 作为尝试 &lt;code&gt;Win32::EventLog&lt;/code&gt; 是否可用的第一种机制。</target>
        </trans-unit>
        <trans-unit id="69bb3e1a426b5cc38eac62d98ea857e63ed9b5dd" translate="yes" xml:space="preserve">
          <source>The default iterator variable in a &lt;code&gt;foreach&lt;/code&gt; loop if no other variable is supplied.</source>
          <target state="translated">如果未提供其他变量，则为 &lt;code&gt;foreach&lt;/code&gt; 循环中的默认迭代器变量。</target>
        </trans-unit>
        <trans-unit id="375ddf0ab7799023484d02f8a221ca6afd3b2054" translate="yes" xml:space="preserve">
          <source>The default memory limit is 2Mib. You can adjust the maximum read cache size by supplying the &lt;code&gt;memory&lt;/code&gt; option. The argument is the desired cache size, in bytes.</source>
          <target state="translated">默认的内存限制是2Mib。您可以通过提供 &lt;code&gt;memory&lt;/code&gt; 选项来调整最大读取缓存大小。参数是所需的缓存大小，以字节为单位。</target>
        </trans-unit>
        <trans-unit id="97d617432e38273ff2337188090afe707d321e91" translate="yes" xml:space="preserve">
          <source>The default method is ZIP_CM_DEFLATE.</source>
          <target state="translated">默认的方法是ZIP_CM_DEFLATE。</target>
        </trans-unit>
        <trans-unit id="d06faea5104288d8b0b633dc0567b8b191f0df74" translate="yes" xml:space="preserve">
          <source>The default name of the new configuration file is &quot;libnet.cfg&quot;, and by default it is written to the current directory, unless otherwise specified using the -o option, &lt;code&gt;-o newfile&lt;/code&gt; .</source>
          <target state="translated">新的配置文件的默认名称为&amp;ldquo; libnet.cfg&amp;rdquo;，默认情况下，它将写入当前目录，除非使用-o选项 &lt;code&gt;-o newfile&lt;/code&gt; 另行指定。</target>
        </trans-unit>
        <trans-unit id="2e5074809750e6c620d635552cb416989d3d15b2" translate="yes" xml:space="preserve">
          <source>The default name of the old configuration file is by default &quot;libnet.cfg&quot;, unless otherwise specified using the -i option, &lt;code&gt;-i oldfile&lt;/code&gt; , and it is searched first from the current directory, and then from your module path.</source>
          <target state="translated">除非使用-i选项 &lt;code&gt;-i oldfile&lt;/code&gt; 另行指定，否则旧配置文件的缺省名称默认为&amp;ldquo; libnet.cfg&amp;rdquo; ，并且首先从当前目录中搜索，然后从模块路径中搜索。</target>
        </trans-unit>
        <trans-unit id="5eb6185afb472dae00827acf41154ba83b345446" translate="yes" xml:space="preserve">
          <source>The default normalizer just concatenates the arguments with character 28 in between. (In ASCII, this is called FS or control-\.) This always works correctly for functions with only one string argument, and also when the arguments never contain character 28. However, it can confuse certain argument lists:</source>
          <target state="translated">默认的规范化处理只是将参数与中间的字符28连在一起。(在ASCII码中,这被称为FS或control-\。)这对于只有一个字符串参数的函数总是正确的,而且当参数从不包含字符28时也是如此。然而,它可能会混淆某些参数列表。</target>
        </trans-unit>
        <trans-unit id="b39e82de8afe051a851d53770ae84cf3c68d41cb" translate="yes" xml:space="preserve">
          <source>The default normalizer will turn this into something like &lt;code&gt;&quot;13\034ARRAY(0x436c1f)&quot;&lt;/code&gt; . That would be all right, except that a subsequent array of numbers might be stored at a different location even though it contains the same data. If this happens, &lt;code&gt;Memoize&lt;/code&gt; will think that the arguments are different, even though they are equivalent. In this case, a normalizer like this is appropriate:</source>
          <target state="translated">默认的规范化器将把它变成类似 &lt;code&gt;&quot;13\034ARRAY(0x436c1f)&quot;&lt;/code&gt; 。没关系，除了后续的数字数组可能存储在不同的位置，即使它包含相同的数据也是如此。如果发生这种情况，即使它们等效， &lt;code&gt;Memoize&lt;/code&gt; 也会认为参数是不同的。在这种情况下，合适的标准化器是这样的：</target>
        </trans-unit>
        <trans-unit id="e5d60aed408340ddef56e731c14beba1f193a756" translate="yes" xml:space="preserve">
          <source>The default of building Perl statically may cause problems with complex applications like Tk: in that case consider building shared Perl</source>
          <target state="translated">默认的静态构建Perl可能会导致像Tk这样的复杂应用程序出现问题:在这种情况下,可以考虑构建共享的Perl。</target>
        </trans-unit>
        <trans-unit id="ac5f6413f6edd9db793b85ce42ea2d862be3c9a0" translate="yes" xml:space="preserve">
          <source>The default operator mask for a newly created compartment is the ':default' optag.</source>
          <target state="translated">新建隔间的默认操作符掩码是':default'opag。</target>
        </trans-unit>
        <trans-unit id="cd7a35f6ae99c836f5d425b35999dec2510b2218" translate="yes" xml:space="preserve">
          <source>The default options gathered by Configure with the assistance of</source>
          <target state="translated">配置收集到的默认选项,并借助于</target>
        </trans-unit>
        <trans-unit id="340bacd1cab82a806d284b26719b4d768c188a8d" translate="yes" xml:space="preserve">
          <source>The default output &lt;b&gt;stream&lt;/b&gt; for nasty remarks that don&amp;rsquo;t belong in &lt;b&gt;standard output&lt;/b&gt;. Represented within a Perl program by the output&amp;gt; &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDERR&lt;/code&gt; . You can use this stream explicitly, but the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; built-ins write to your standard error stream automatically (unless trapped or otherwise intercepted).</source>
          <target state="translated">不属于&lt;b&gt;标准输出的&lt;/b&gt;令人讨厌的评论的默认输出&lt;b&gt;流&lt;/b&gt;。在Perl程序中由output&amp;gt; &lt;b&gt;文件句柄&lt;/b&gt; &lt;code&gt;STDERR&lt;/code&gt; 表示。您可以显式使用此流，但是 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 内置函数会自动写入标准错误流（除非被捕获或以其他方式拦截）。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aa254ec270a416bb3ac03f5a884b155a435c80cb" translate="yes" xml:space="preserve">
          <source>The default output &lt;b&gt;stream&lt;/b&gt; for your program, which if possible shouldn&amp;rsquo;t care where its data is going. Represented within a Perl program by the &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="translated">程序的默认输出&lt;b&gt;流&lt;/b&gt;，如果可能的话，它不必理会数据的流向。在Perl程序中由&lt;b&gt;文件句柄&lt;/b&gt; &lt;code&gt;STDOUT&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="e96d4d616212a6cfd4d2816b5ab3f17c9db66319" translate="yes" xml:space="preserve">
          <source>The default output of self-referential structures can be &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed, but the nested references to &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">可以对自引用结构的默认输出进行 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，但是对 &lt;code&gt;$VAR&lt;/code&gt; 的嵌套引用</target>
        </trans-unit>
        <trans-unit id="a5f2d9e51d87e9b71a9bd992e69d11af3ccda88f" translate="yes" xml:space="preserve">
          <source>The default path for perl binary is /QOpenSys/perl/bin/perl. You'll want to symlink /QOpenSys/usr/bin/perl to this file so you don't have to modify your path.</source>
          <target state="translated">perl二进制文件的默认路径是/QOpenSys/perl/bin/perl。你需要将/QOpenSys/usr/bin/perl链接到这个文件,这样你就不用修改路径了。</target>
        </trans-unit>
        <trans-unit id="c0e7903465e131bba24e8f9fa0f5926ebf1b8dce" translate="yes" xml:space="preserve">
          <source>The default per-thread stack size for different platforms varies significantly, and is almost always far more than is needed for most applications. On Win32, Perl's makefile explicitly sets the default stack to 16 MB; on most other platforms, the system default is used, which again may be much larger than is needed.</source>
          <target state="translated">不同平台上默认的每线程堆栈大小差异很大,几乎总是远远超过大多数应用程序的需要。在Win32平台上,Perl的makefile明确地将默认栈设置为16MB;在其他大多数平台上,则使用系统默认值,但也可能比需要的大得多。</target>
        </trans-unit>
        <trans-unit id="02fbe3c9bc6d319100d5d82a643c83d45a2aaf27" translate="yes" xml:space="preserve">
          <source>The default per-thread stack size may be set at the start of the application through the use of the environment variable &lt;code&gt;PERL5_ITHREADS_STACK_SIZE&lt;/code&gt; :</source>
          <target state="translated">可以使用环境变量 &lt;code&gt;PERL5_ITHREADS_STACK_SIZE&lt;/code&gt; 在应用程序启动时设置默认的每线程堆栈大小：</target>
        </trans-unit>
        <trans-unit id="d17c04396f5d2338f66524479b64e4296e2bc5c4" translate="yes" xml:space="preserve">
          <source>The default perl executable is flexible enough to support most usages. However, one may want something yet more flexible; for example, one may want to find Perl DLL relatively to the location of the EXE file; or one may want to ignore the environment when setting the Perl-library search patch, etc.</source>
          <target state="translated">默认的perl可执行文件足够灵活,可以支持大多数用途。然而,人们可能想要一些更灵活的东西;例如,人们可能想要相对于EXE文件的位置来查找Perl DLL;或者人们可能想要在设置Perl库搜索补丁时忽略环境等等。</target>
        </trans-unit>
        <trans-unit id="7009bdcf386245a7873fc69dc2c48c3bfdcf71d9" translate="yes" xml:space="preserve">
          <source>The default permissions to use if a new file is created. The actual permissions will be modified by the user's umask, so you should probably use 0666 here. (See &lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;.)</source>
          <target state="translated">创建新文件时使用的默认权限。实际的权限将由用户的umask修改，因此您可能应该在此处使用0666。（请参见&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="af672db5716c0b823ab6d08666d2a653d572eae5" translate="yes" xml:space="preserve">
          <source>The default place to put the next value or input record when a &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; operation's result is tested by itself as the sole criterion of a &lt;code&gt;while&lt;/code&gt; test. Outside a &lt;code&gt;while&lt;/code&gt; test, this will not happen.</source>
          <target state="translated">当单独测试 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 操作的结果时，放置下一个值或输入记录的默认位置是 &lt;code&gt;while&lt;/code&gt; 测试的唯一标准。经过一段 &lt;code&gt;while&lt;/code&gt; 测试，这不会发生。</target>
        </trans-unit>
        <trans-unit id="c5df9208ed1f779ba0f9d5864d277d9b22483511" translate="yes" xml:space="preserve">
          <source>The default rendering is top-down, so they're not in execution order. This form reflects the way the stack is used to parse and evaluate expressions; the add operates on the two terms below it in the tree.</source>
          <target state="translated">默认的呈现方式是自上而下,所以它们的执行顺序并不一致。这种形式反映了堆栈用来解析和评估表达式的方式,添加是对树中它下面的两个项进行操作。</target>
        </trans-unit>
        <trans-unit id="2fc20ab6a2146e41cd4461ac23c56be7f29f5c25" translate="yes" xml:space="preserve">
          <source>The default rounding mode is 'even'. By using &lt;code&gt;Math::BigFloat-&amp;gt;round_mode($round_mode);&lt;/code&gt; you can get and set the default mode for subsequent rounding. The usage of &lt;code&gt;$Math::BigFloat::$round_mode&lt;/code&gt; is no longer supported. The second parameter to the round functions then overrides the default temporarily.</source>
          <target state="translated">默认舍入模式为&amp;ldquo;偶数&amp;rdquo;。通过使用 &lt;code&gt;Math::BigFloat-&amp;gt;round_mode($round_mode);&lt;/code&gt; 您可以获取并设置默认模式以进行后续舍入。不再支持 &lt;code&gt;$Math::BigFloat::$round_mode&lt;/code&gt; 的用法。然后，舍入函数的第二个参数临时覆盖默认值。</target>
        </trans-unit>
        <trans-unit id="0c0082ed0ee0f68ac7247af3405f6e36532a7d14" translate="yes" xml:space="preserve">
          <source>The default set of layers should give acceptable results on all platforms</source>
          <target state="translated">默认的图层集应该在所有平台上都能提供可接受的结果。</target>
        </trans-unit>
        <trans-unit id="98f212f2163021f600388dfedb85757788b2ee77" translate="yes" xml:space="preserve">
          <source>The default sort function is cmp, string comparison, which would sort &lt;code&gt;(1, 2, 10)&lt;/code&gt; into &lt;code&gt;(1, 10, 2)&lt;/code&gt; . &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; , used above, is the numerical comparison operator.</source>
          <target state="translated">缺省排序功能是CMP，字符串比较，这将排序 &lt;code&gt;(1, 2, 10)&lt;/code&gt; 到 &lt;code&gt;(1, 10, 2)&lt;/code&gt; 。上面使用的 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 是数值比较运算符。</target>
        </trans-unit>
        <trans-unit id="baa9ec2a72f812d2fff5978a7051ec1d9ead2a46" translate="yes" xml:space="preserve">
          <source>The default subscript separator is &quot;\034&quot;, the same as SUBSEP in &lt;b&gt;awk&lt;/b&gt;.</source>
          <target state="translated">默认的下标分隔符为&amp;ldquo; \ 034&amp;rdquo;，与&lt;b&gt;awk中的&lt;/b&gt; SUBSEP相同。</target>
        </trans-unit>
        <trans-unit id="fedbef30ad12f7c78358c3195161f7bf65ed2265" translate="yes" xml:space="preserve">
          <source>The default text formatter is &lt;a href=&quot;text&quot;&gt;Pod::Text&lt;/a&gt;. The base class for Pod::Usage can be defined by pre-setting &lt;code&gt;$Pod::Usage::Formatter&lt;/code&gt;</source>
          <target state="translated">默认的文本格式为&lt;a href=&quot;text&quot;&gt;Pod :: Text&lt;/a&gt;。可以通过预先设置 &lt;code&gt;$Pod::Usage::Formatter&lt;/code&gt; 来定义Pod :: Usage的基类。</target>
        </trans-unit>
        <trans-unit id="2eca7e39567cc3a4e38f07441f8e4f7046f9b14f" translate="yes" xml:space="preserve">
          <source>The default type for the constants. If not specified &lt;code&gt;IV&lt;/code&gt; is assumed.</source>
          <target state="translated">常量的默认类型。如果未指定，则假定为 &lt;code&gt;IV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a6f652439685a6a403073936eade467faa79602" translate="yes" xml:space="preserve">
          <source>The default typemap in the</source>
          <target state="translated">中的默认类型图。</target>
        </trans-unit>
        <trans-unit id="82f3cb0c641077271c3068ea9c85e22ba715cfbb" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;div_scale&lt;/code&gt; is 40.</source>
          <target state="translated">&lt;code&gt;div_scale&lt;/code&gt; 的默认值为40。</target>
        </trans-unit>
        <trans-unit id="609bf4918ead31f720f19323f5cf2348643f6d2e" translate="yes" xml:space="preserve">
          <source>The default value for CCHOME in the makefiles for Visual C++ may not be correct for some versions. Make sure the default exists and is valid.</source>
          <target state="translated">在Visual C++的makefiles中,CCHOME的默认值对某些版本来说可能不正确。请确保默认值存在并且有效。</target>
        </trans-unit>
        <trans-unit id="1f34862d6782defbe2c5b2a0445c8f00de39fa4d" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;XSINTERFACE_FUNC&lt;/code&gt; and &lt;code&gt;XSINTERFACE_FUNC_SET&lt;/code&gt; . An INTERFACE keyword with an empty list of functions can be omitted if INTERFACE_MACRO keyword is used.</source>
          <target state="translated">默认值为 &lt;code&gt;XSINTERFACE_FUNC&lt;/code&gt; 和 &lt;code&gt;XSINTERFACE_FUNC_SET&lt;/code&gt; 。如果使用INTERFACE_MACRO关键字，则可以省略带有空函数列表的INTERFACE关键字。</target>
        </trans-unit>
        <trans-unit id="3ae2f809fd681df4fcb45c0c13d99a0283fc66b8" translate="yes" xml:space="preserve">
          <source>The definition used for complex arguments of atan2() is</source>
          <target state="translated">用于atan2()的复杂参数的定义是</target>
        </trans-unit>
        <trans-unit id="6431fb44fb840f90a758f20a67dcf8b7a9374aa9" translate="yes" xml:space="preserve">
          <source>The del_dup() Method</source>
          <target state="translated">del_dup()方法</target>
        </trans-unit>
        <trans-unit id="ed1ded41373481d9b3a2afdb892465f6f5d0d39d" translate="yes" xml:space="preserve">
          <source>The delimiter provided to &lt;code&gt;extract_bracketed&lt;/code&gt; was not one of &lt;code&gt;'()[]&amp;lt;&amp;gt;{}'&lt;/code&gt; .</source>
          <target state="translated">提供给 &lt;code&gt;extract_bracketed&lt;/code&gt; 的分隔符不是 &lt;code&gt;'()[]&amp;lt;&amp;gt;{}'&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="0e6b6844fe43a8d8ec1aad6ff952638a46635ab3" translate="yes" xml:space="preserve">
          <source>The denizens of makemaker@perl.org.</source>
          <target state="translated">makemaker@perl.org 的居民。</target>
        </trans-unit>
        <trans-unit id="d6c12d31655a68b617bd8f8ac7d7b41ffa97d8df" translate="yes" xml:space="preserve">
          <source>The dereferencing cases (as opposed to method-calling cases) are somewhat extended by the experimental &lt;code&gt;postderef&lt;/code&gt; feature. For the details of that feature, consult &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;Postfix Dereference Syntax in perlref&lt;/a&gt;.</source>
          <target state="translated">取消引用的情况（与方法调用的情况相反）通过实验性的 &lt;code&gt;postderef&lt;/code&gt; 功能得到了扩展。有关该功能的详细信息，请参阅&lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;perlref中的Postfix Dereference Syntax&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c06b4b9a1d8e7058531ada60d67614dbcf01dfd0" translate="yes" xml:space="preserve">
          <source>The deserializing hook called on the object during deserialization. But wait: if we're deserializing, there's no object yet... right?</source>
          <target state="translated">在反序列化过程中,反序列化钩子对对象进行了调用。但是等等:如果我们在反序列化,还没有对象......对吗?</target>
        </trans-unit>
        <trans-unit id="8a2f99ef5bda346c32f63e70a7361acb83da8b02" translate="yes" xml:space="preserve">
          <source>The design intent is for &lt;code&gt;\d&lt;/code&gt; to exactly match the set of characters that can safely be used with &quot;normal&quot; big-endian positional decimal syntax, where, for example 123 means one 'hundred', plus two 'tens', plus three 'ones'. This positional notation does not necessarily apply to characters that match the other type of &quot;digit&quot;, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; , and so &lt;code&gt;\d&lt;/code&gt; doesn't match them.</source>
          <target state="translated">设计意图是使 &lt;code&gt;\d&lt;/code&gt; 完全匹配可以安全地与&amp;ldquo;常规&amp;rdquo;大端位置十进制语法一起使用的字符集，例如123表示一个&amp;ldquo;百&amp;rdquo;，两个&amp;ldquo;十&amp;rdquo;，三个&amp;ldquo;那些'。此位置标记不一定适用于与其他类型的&amp;ldquo;数字&amp;rdquo;匹配的字符 &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; ，因此 &lt;code&gt;\d&lt;/code&gt; 与它们不匹配。</target>
        </trans-unit>
        <trans-unit id="d6ec3b1b57d74d9cf92c20c7537d430a4cb91982" translate="yes" xml:space="preserve">
          <source>The desire of users to express filenames of the form &lt;code&gt;&amp;lt;Foo$Dir&amp;gt;.Bar&lt;/code&gt; on the command line unquoted causes problems, too: &lt;code&gt;``&lt;/code&gt; command output capture has to perform a guessing game. It assumes that a string &lt;code&gt;&amp;lt;[^&amp;lt;&amp;gt;]+\$[^&amp;lt;&amp;gt;]&amp;gt;&lt;/code&gt; is a reference to an environment variable, whereas anything else involving &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; is redirection, and generally manages to be 99% right. Of course, the problem remains that scripts cannot rely on any Unix tools being available, or that any tools found have Unix-like command line arguments.</source>
          <target state="translated">用户希望以 &lt;code&gt;&amp;lt;Foo$Dir&amp;gt;.Bar&lt;/code&gt; 形式表示文件名而在命令行上未引用也会引起问题： &lt;code&gt;``&lt;/code&gt; 命令输出捕获必须执行猜测游戏。它假定字符串 &lt;code&gt;&amp;lt;[^&amp;lt;&amp;gt;]+\$[^&amp;lt;&amp;gt;]&amp;gt;&lt;/code&gt; 是对环境变量的引用，而涉及 &lt;code&gt;&amp;lt;&lt;/code&gt; 或 &lt;code&gt;&amp;gt;&lt;/code&gt; 的其他任何东西都是重定向的，通常正确率是99％。当然，问题仍然在于脚本不能依赖任何可用的Unix工具，或者找到的任何工具都具有类似Unix的命令行参数。</target>
        </trans-unit>
        <trans-unit id="a11af240187e8ce0ea57c0f5d9817fa72798ba59" translate="yes" xml:space="preserve">
          <source>The desired exit status to pass to the &lt;b&gt;exit()&lt;/b&gt; function. This should be an integer, or else the string &quot;NOEXIT&quot; to indicate that control should simply be returned without terminating the invoking process.</source>
          <target state="translated">所需的退出状态，以传递给&lt;b&gt;exit（）&lt;/b&gt;函数。它应该是一个整数，或者是字符串&amp;ldquo; NOEXIT&amp;rdquo;，以指示应该简单地返回控件而不终止调用过程。</target>
        </trans-unit>
        <trans-unit id="a47bdc95431692c8deb0f97084523a81a5887de3" translate="yes" xml:space="preserve">
          <source>The desired level of &quot;verboseness&quot; to use when printing the usage message. If the corresponding value is 0, then only the &quot;SYNOPSIS&quot; section of the pod documentation is printed. If the corresponding value is 1, then the &quot;SYNOPSIS&quot; section, along with any section entitled &quot;OPTIONS&quot;, &quot;ARGUMENTS&quot;, or &quot;OPTIONS AND ARGUMENTS&quot; is printed. If the corresponding value is 2 or more then the entire manpage is printed.</source>
          <target state="translated">打印使用信息时需要使用的 &quot;verboseness &quot;级别。如果对应的值为 0,则只打印 pod 文档的 &quot;SYNOPSIS &quot;部分。如果对应值为 1,则打印 &quot;SYNOPSIS &quot;部分,以及任何题为 &quot;OPTIONS&quot;、&quot;ARGUMENTS &quot;或 &quot;OPTIONS AND ARGUMENTS &quot;的部分。如果对应值为2或更多,则打印整个页面。</target>
        </trans-unit>
        <trans-unit id="2b3e64d006f3001c3df4472f5962fd664df30c48" translate="yes" xml:space="preserve">
          <source>The desired level of verbosity to use:</source>
          <target state="translated">所需使用的口头禅程度。</target>
        </trans-unit>
        <trans-unit id="1f8c4d84dbcf0f5f2d69ca16b4ced3235af3fefd" translate="yes" xml:space="preserve">
          <source>The destination for the option must be an array or array reference.</source>
          <target state="translated">选项的目标必须是一个数组或数组引用。</target>
        </trans-unit>
        <trans-unit id="2940ce84da888fbb72c23c514c9cdd4e2c7bab4a" translate="yes" xml:space="preserve">
          <source>The detection algorithm works something like this:</source>
          <target state="translated">检测算法的工作原理是这样的。</target>
        </trans-unit>
        <trans-unit id="cfd0b50108607e59344e69b0de3bc9fd4f301247" translate="yes" xml:space="preserve">
          <source>The diagnostics Pragma</source>
          <target state="translated">诊断原则</target>
        </trans-unit>
        <trans-unit id="9e8272da23da05393615d77b37bcea56278deff5" translate="yes" xml:space="preserve">
          <source>The diagnostics of this test normally just refer to 'the object'. If you'd like them to be more specific, you can supply an $object_name (for example 'Test customer').</source>
          <target state="translated">这个测试的诊断程序通常只提到 &quot;对象&quot;。如果你想让它们更具体,你可以提供一个$object_name (例如'Test customer')。</target>
        </trans-unit>
        <trans-unit id="67027b213e7e98e89fd8e5ebf75f4789f0806d73" translate="yes" xml:space="preserve">
          <source>The diagram below represents a single source stream, with the flow of source from a Perl script file on the left into the Perl parser on the right. This is how Perl normally operates.</source>
          <target state="translated">下图表示一个单一的源流,源流从左边的Perl脚本文件进入右边的Perl解析器。这就是Perl的正常操作方式。</target>
        </trans-unit>
        <trans-unit id="09d12bc25e1c17128a784d1b2ff7f2b3ea6c5f9e" translate="yes" xml:space="preserve">
          <source>The die on line 4 pops the context stack back down to the CxEVAL, leaving it as:</source>
          <target state="translated">第4行的模子将上下文堆栈弹回CxEVAL,使其为。</target>
        </trans-unit>
        <trans-unit id="930610eed704196a6c02e9606fed36fd7cdf0a59" translate="yes" xml:space="preserve">
          <source>The die pops the first &lt;code&gt;CxEVAL&lt;/code&gt; off the context stack, sets &lt;code&gt;PL_restartop&lt;/code&gt; from it, does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; , and control returns to the top &lt;code&gt;docatch&lt;/code&gt; . This then starts another third-level runops level, which executes the nextstate, pushmark and die ops on line 4. At the point that the second &lt;code&gt;pp_die&lt;/code&gt; is called, the C call stack looks exactly like that above, even though we are no longer within an inner eval; this is because of the optimization mentioned earlier. However, the context stack now looks like this, ie with the top CxEVAL popped:</source>
          <target state="translated">模具将第一个 &lt;code&gt;CxEVAL&lt;/code&gt; 从上下文堆栈中弹出，从中设置 &lt;code&gt;PL_restartop&lt;/code&gt; ，执行 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; ，然后控制返回到顶部 &lt;code&gt;docatch&lt;/code&gt; 。然后，这将启动另一个第三级运行级别，该运行级别在第4行执行nextstate，pushmark和die ops。在第二个 &lt;code&gt;pp_die&lt;/code&gt; 被调用的时刻，C调用堆栈看起来与上面的完全一样，即使我们不再位于内部评估 这是由于前面提到的优化。但是，上下文堆栈现在看起来像这样，即弹出顶部的CxEVAL：</target>
        </trans-unit>
        <trans-unit id="6ed5acbfe1a4a69e2eecb34b13c8306880da82cf" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;extract_tagged&lt;/code&gt; and the anonymous subroutines generated by &lt;code&gt;gen_extract_tagged&lt;/code&gt; , is that those generated subroutines:</source>
          <target state="translated">&lt;code&gt;extract_tagged&lt;/code&gt; 和 &lt;code&gt;gen_extract_tagged&lt;/code&gt; 生成的匿名子例程之间的区别在于，这些子例程生成的：</target>
        </trans-unit>
        <trans-unit id="7e6f28f40692ae97e2ea2e8080e59d267505ccf0" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;minlen&lt;/code&gt; and &lt;code&gt;minlenret&lt;/code&gt; can be seen in the following pattern:</source>
          <target state="translated">&lt;code&gt;minlen&lt;/code&gt; 和 &lt;code&gt;minlenret&lt;/code&gt; 之间的差异可以通过以下模式看出：</target>
        </trans-unit>
        <trans-unit id="f8ae9fbf98646f2ef8526e7b39bf817f11262438" translate="yes" xml:space="preserve">
          <source>The difference between a block and a script is that scripts are closer to the linguistic notion of a set of code points required to represent languages, while block is more of an artifact of the Unicode code point numbering and separation into blocks of consecutive code points (so far the size of a block is some multiple of 16, like 128 or 256).</source>
          <target state="translated">块和脚本的区别在于,脚本更接近语言学上的概念,即表示语言所需的一组码点,而块更多的是Unicode码点编号和分离成连续码点块的产物(到目前为止,块的大小是16的某个倍数,比如128或256)。</target>
        </trans-unit>
        <trans-unit id="4e0fd5df1eb8c3e578915cd6f8934c4fe5cf676a" translate="yes" xml:space="preserve">
          <source>The difference between these two properties involves characters that are used in multiple scripts. For example the digits '0' through '9' are used in many parts of the world. These are placed in a script named &lt;code&gt;Common&lt;/code&gt; . Other characters are used in just a few scripts. For example, the &lt;code&gt;&quot;KATAKANA-HIRAGANA DOUBLE HYPHEN&quot;&lt;/code&gt; is used in both Japanese scripts, Katakana and Hiragana, but nowhere else. The &lt;code&gt;Script&lt;/code&gt; property places all characters that are used in multiple scripts in the &lt;code&gt;Common&lt;/code&gt; script, while the &lt;code&gt;Script_Extensions&lt;/code&gt; property places those that are used in only a few scripts into each of those scripts; while still using &lt;code&gt;Common&lt;/code&gt; for those used in many scripts. Thus both these match:</source>
          <target state="translated">这两个属性之间的差异涉及在多个脚本中使用的字符。例如，数字'0'到'9'在世界许多地方使用。这些被放置在名为 &lt;code&gt;Common&lt;/code&gt; 的脚本中。其他字符仅在少数脚本中使用。例如，日文片假名和平假名都使用了 &lt;code&gt;&quot;KATAKANA-HIRAGANA DOUBLE HYPHEN&quot;&lt;/code&gt; ，但其他地方都没有。该 &lt;code&gt;Script&lt;/code&gt; 属性放在那些在多个脚本中使用的所有字符， &lt;code&gt;Common&lt;/code&gt; 的脚本，而 &lt;code&gt;Script_Extensions&lt;/code&gt; 财产地方那些只有几个剧本到每个这些脚本的使用;同时仍将 &lt;code&gt;Common&lt;/code&gt; 用于许多脚本中使用的那些。因此，这两个匹配：</target>
        </trans-unit>
        <trans-unit id="f324cedd823e628f1ed8025386bfb26cab3778ab" translate="yes" xml:space="preserve">
          <source>The difference is clear to see and the dereferencing approach is slower. While it managed to execute an average of 628,930 times a second during our test, the direct approach managed to run an additional 204,403 times, unfortunately. Unfortunately, because there are many examples of code written using the multiple layer direct variable access, and it's usually horrible. It is, however, minusculy faster. The question remains whether the minute gain is actually worth the eyestrain, or the loss of maintainability.</source>
          <target state="translated">差别显而易见,去参考方法的速度更慢。虽然在我们的测试过程中,它平均每秒能执行628,930次,但不幸的是,直接方法却能额外运行204,403次。不幸的是,因为有很多使用多层直接变量访问写的代码的例子,而且它通常是可怕的。然而,它的速度是迷你的。问题是,这一分钟的收益是否真的值得眼花缭乱,或者可维护性的损失。</target>
        </trans-unit>
        <trans-unit id="c9d466e6cdc3e3b171ba671cc22acace7243054b" translate="yes" xml:space="preserve">
          <source>The difference is the sigil, that special character in front of the array name. The &lt;code&gt;$&lt;/code&gt; sigil means &quot;exactly one item&quot;, while the &lt;code&gt;@&lt;/code&gt; sigil means &quot;zero or more items&quot;. The &lt;code&gt;$&lt;/code&gt; gets you a single scalar, while the &lt;code&gt;@&lt;/code&gt; gets you a list.</source>
          <target state="translated">区别在于符号，即数组名称前面的特殊字符。在 &lt;code&gt;$&lt;/code&gt; 印记的意思是&amp;ldquo;只有一个项目&amp;rdquo;，而 &lt;code&gt;@&lt;/code&gt; 印记的意思是&amp;ldquo;零个或多个项目&amp;rdquo;。在 &lt;code&gt;$&lt;/code&gt; 让你一个标，而 &lt;code&gt;@&lt;/code&gt; 让你列表。</target>
        </trans-unit>
        <trans-unit id="c2b0921f524dbbf7564616e5853365d0c767bfc6" translate="yes" xml:space="preserve">
          <source>The digest can be delivered in three formats:</source>
          <target state="translated">文摘可以以三种格式提供。</target>
        </trans-unit>
        <trans-unit id="0155d0c091234cee22dc790957626f27306487e0" translate="yes" xml:space="preserve">
          <source>The direction you must follow the great circle (also known as</source>
          <target state="translated">你必须遵循的方向是大圆(又称 &quot;大圆&quot;)。</target>
        </trans-unit>
        <trans-unit id="03d134305af0df1045ab396312ef86cfab55c5d9" translate="yes" xml:space="preserve">
          <source>The direction you would have to go from London to Tokyo (in radians, straight north being zero, straight east being pi/2).</source>
          <target state="translated">从伦敦到东京的方向(以弧度为单位,直北为0,直东为pi/2)。</target>
        </trans-unit>
        <trans-unit id="9159a72a045b505fc788bec97c5202fb7f87247c" translate="yes" xml:space="preserve">
          <source>The directory portion may or may not be returned with a trailing '/'.</source>
          <target state="translated">目录部分可能会也可能不会以'/'结尾返回。</target>
        </trans-unit>
        <trans-unit id="efd54b0e8774d4521e37e9c7dad7074640dfad53" translate="yes" xml:space="preserve">
          <source>The directory you are put into when you log in. On a Unix system, the name is often placed into &lt;code&gt;$ENV{HOME}&lt;/code&gt; or &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; by</source>
          <target state="translated">登录时放置的目录。在Unix系统上，名称通常通过以下方式放置在 &lt;code&gt;$ENV{HOME}&lt;/code&gt; 或 &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0f834768c044521ed2139a347066ecd1f6fd454d" translate="yes" xml:space="preserve">
          <source>The directory, if specified, must appear immediately following the &lt;b&gt;-x&lt;/b&gt; with no intervening whitespace.</source>
          <target state="translated">如果指定了该目录，则该目录必须立即出现在&lt;b&gt;-x之后&lt;/b&gt;且中间没有空格。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
