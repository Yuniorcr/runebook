<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="700d8f92e3038752feec96509274cbd7256d79dc" translate="yes" xml:space="preserve">
          <source>If you can't configure &lt;code&gt;TAP::Harness&lt;/code&gt; to do what you want, and you can't find an existing plugin, consider writing one.</source>
          <target state="translated">如果您无法配置 &lt;code&gt;TAP::Harness&lt;/code&gt; 做您想做的事，并且找不到现有的插件，请考虑编写一个插件。</target>
        </trans-unit>
        <trans-unit id="edcd365c3753fb0814dbbf4b5f1da5978fabe2e0" translate="yes" xml:space="preserve">
          <source>If you can't use &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt;, you'll have to do the work yourself: open the original file, open the destination file, then print to the destination file as you read the original. You also have to remember to copy the permissions, owner, and group to the new file.</source>
          <target state="translated">如果您不能使用&lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt;，则必须自己做：打开原始文件，打开目标文件，然后在阅读原始文件时打印到目标文件。您还必须记住将权限，所有者和组复制到新文件。</target>
        </trans-unit>
        <trans-unit id="2431416836e7be159e91db05fdcbf62b13f365c1" translate="yes" xml:space="preserve">
          <source>If you cannot achieve the desired Makefile behaviour by specifying attributes you may define private subroutines in the Makefile.PL. Each subroutine returns the text it wishes to have written to the Makefile. To override a section of the Makefile you can either say:</source>
          <target state="translated">如果你不能通过指定属性来实现所需的Makefile行为,你可以在Makefile.PL中定义私有子程序。每个子程序都会返回它希望写入Makefile的文本。要覆盖Makefile的某一节,你可以说。</target>
        </trans-unit>
        <trans-unit id="069db45c3cccee54b16dacbbc26ce2a59fc37a49" translate="yes" xml:space="preserve">
          <source>If you cannot upgrade your Perl to 5.8.0 or later, you can still do some Unicode processing by using the modules &lt;code&gt;Unicode::String&lt;/code&gt; , &lt;code&gt;Unicode::Map8&lt;/code&gt; , and &lt;code&gt;Unicode::Map&lt;/code&gt; , available from CPAN. If you have the GNU recode installed, you can also use the Perl front-end &lt;code&gt;Convert::Recode&lt;/code&gt; for character conversions.</source>
          <target state="translated">如果无法将Perl升级到5.8.0或更高版本，则仍可以使用CPAN提供的模块 &lt;code&gt;Unicode::String&lt;/code&gt; ， &lt;code&gt;Unicode::Map8&lt;/code&gt; 和 &lt;code&gt;Unicode::Map&lt;/code&gt; 进行一些Unicode处理。如果安装了GNU重新编码，则还可以使用Perl前端的 &lt;code&gt;Convert::Recode&lt;/code&gt; 进行字符转换。</target>
        </trans-unit>
        <trans-unit id="7f06f83624114fcf502e132fac57a686e4d7a4ee" translate="yes" xml:space="preserve">
          <source>If you cannot use &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt;, you can make your own loop to do the same thing. Once you find the element, you stop the loop with last.</source>
          <target state="translated">如果您不能使用&lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt;，则可以使自己的循环执行相同的操作。找到元素后，您就停止了last循环。</target>
        </trans-unit>
        <trans-unit id="83e89259781d3b7bf972995b7c8dc74ef7aacff4" translate="yes" xml:space="preserve">
          <source>If you cannot use the git protocol for firewall reasons, you can also clone via http, though this is much slower:</source>
          <target state="translated">如果因为防火墙的原因不能使用git协议,也可以通过http进行克隆,不过这个速度要慢很多。</target>
        </trans-unit>
        <trans-unit id="794395d65809aff375720f1da63fe61351840429" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;$pattern&lt;/code&gt; after the first substitution happens, Perl will ignore it. If you don't want any substitutions at all, use the special delimiter &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">如果在第一次替换发生后更改 &lt;code&gt;$pattern&lt;/code&gt; ，Perl将忽略它。如果根本不需要任何替换，请使用特殊的定界符 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bca560012b71cc8dce8e6a03ec54196daca3d350" translate="yes" xml:space="preserve">
          <source>If you check &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;, you'll see that several of the ways to call open() should do the trick. For example:</source>
          <target state="translated">如果选中&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;，您会发现调用open（）的几种方法应该可以解决问题。例如：</target>
        </trans-unit>
        <trans-unit id="e4dedfaceb9670f08b0798c739b80203032d536c" translate="yes" xml:space="preserve">
          <source>If you chomp a list, each element is chomped, and the total number of characters removed is returned.</source>
          <target state="translated">如果你对一个列表进行分解,每个元素都会被分解,并返回删除的总字符数。</target>
        </trans-unit>
        <trans-unit id="716512a060dd3d5999bac2b4045e2b9123dc9b1b" translate="yes" xml:space="preserve">
          <source>If you choose XL C/C++ V11 you need the April 2010 PTF (or newer) installed otherwise you will not get a working Perl version.</source>
          <target state="translated">如果您选择XL C/C++V11,您需要安装2010年4月的PTF(或更新版本),否则您将无法使用Perl版本。</target>
        </trans-unit>
        <trans-unit id="c10052f207d29ada4465d2d73fcdfabf3621a0b6" translate="yes" xml:space="preserve">
          <source>If you choose XL C/C++ V9 you need APAR IZ35785 installed otherwise the integrated SDBM_File do not compile correctly due to an optimization bug. You can circumvent this problem by adding -qipa to the optimization flags (-Doptimize='-O -qipa'). The PTF for APAR IZ35785 which solves this problem is available from IBM (April 2009 PTF for XL C/C++ Enterprise Edition for AIX, V9.0).</source>
          <target state="translated">如果您选择XL C/C++V9,您需要安装APAR IZ35785,否则由于优化错误,集成的SDBM_File不能正确编译。你可以通过在优化标志中添加-qipa来规避这个问题(-Doptimize='-O -qipa')。解决这个问题的APAR IZ35785的PTF可以从IBM获得(2009年4月PTF for XL C/C++Enterprise Edition for AIX,V9.0)。</target>
        </trans-unit>
        <trans-unit id="fb54bcde599a5f03b31c1ac1b1fac745b31dc5b8" translate="yes" xml:space="preserve">
          <source>If you choose for the PTH package, use swinstall to install pth in the default location (/opt/pth), and then make symbolic links to the libraries from /usr/lib</source>
          <target state="translated">如果选择PTH包,使用swinstall将pth安装到默认位置(/opt/pth),然后从/usr/lib中建立符号链接到库。</target>
        </trans-unit>
        <trans-unit id="5ca7b309ef65dd317303754f8c4a5fd3689e4197" translate="yes" xml:space="preserve">
          <source>If you choose gcc to compile 64-bit Perl then you need to add the following option:</source>
          <target state="translated">如果你选择gcc来编译64位Perl,那么你需要添加以下选项。</target>
        </trans-unit>
        <trans-unit id="875c1fe2de9773e7e9366d0703f2a602deb9c197" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果切列表，则每个元素都被切。仅返回最后一个 &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="03160d33f05c1b78628995f8692e16c5933ebe05" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果切列表，则每个元素都被切。仅返回最后一个 &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="caf1e734b10683713e7d496bb52630f5b34525d0" translate="yes" xml:space="preserve">
          <source>If you compile and run</source>
          <target state="translated">如果你编译并运行</target>
        </trans-unit>
        <trans-unit id="4359b9f0177138527f6b61e374c639bb3caf7642" translate="yes" xml:space="preserve">
          <source>If you completely hide the short forms of the Perl public API, add -DPERL_NO_SHORT_NAMES to the compilation flags. This means that for example instead of writing</source>
          <target state="translated">如果你完全隐藏了Perl公共API的简写,请在编译标志中添加-DPERL_NO_SHORT_NAMES。这意味着,比如说,我们不需要写</target>
        </trans-unit>
        <trans-unit id="7e117fe20aeb505e6fb3bd26d20ee9983d45c623" translate="yes" xml:space="preserve">
          <source>If you consult &lt;code&gt;perldoc -f &lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; you will see that &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; will behave differently when given a bareword or a string.</source>
          <target state="translated">如果您咨询 &lt;code&gt;perldoc -f &lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ,您将看到 &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 在给出裸字或字符串时的行为会有所不同。</target>
        </trans-unit>
        <trans-unit id="e933e27b4b6affb17bacc2be8545945df23e47f1" translate="yes" xml:space="preserve">
          <source>If you create interpreters in one thread and then proceed to call them in another, you need to make sure perl's own Thread Local Storage (TLS) slot is initialized correctly in each of those threads.</source>
          <target state="translated">如果你在一个线程中创建了解释器,然后在另一个线程中继续调用它们,你需要确保perl自己的线程本地存储(TLS)槽在每个线程中都被正确初始化。</target>
        </trans-unit>
        <trans-unit id="4e50c2bd9e835a3a7f1961b7856f6dac61424cbe" translate="yes" xml:space="preserve">
          <source>If you decide to ignore this advice and use the GNU versions anyway, then be sure that they are relatively recent. Versions newer than 2.7 are apparently new enough. Older versions may have trouble with dynamic loading.</source>
          <target state="translated">如果您决定无视这个建议而使用GNU版本,那么请确保它们是相对较新的版本。比2.7新的版本显然已经足够新了。旧的版本可能在动态加载方面有问题。</target>
        </trans-unit>
        <trans-unit id="ff55c7f7dfadd85537843d3b167612c0ffcaee31" translate="yes" xml:space="preserve">
          <source>If you decide to use a different version of the zlib library, you need to be aware of the following issues</source>
          <target state="translated">如果你决定使用不同版本的zlib库,你需要注意以下问题。</target>
        </trans-unit>
        <trans-unit id="dea32ebc2834b73dcbf2cbd2fdecffa9453ead2d" translate="yes" xml:space="preserve">
          <source>If you decide to use gcc, make sure your installation is recent and complete, and be sure to read the Perl INSTALL file for more gcc-specific details.</source>
          <target state="translated">如果你决定使用gcc,请确保你的安装是最新的和完整的,并且一定要阅读Perl的INSTALL文件来了解更多关于gcc的细节。</target>
        </trans-unit>
        <trans-unit id="275ebe9364d1067d763d9e8ee83a9ef9cef15d89" translate="yes" xml:space="preserve">
          <source>If you decide to use gcc, make sure your installation is recent and complete, and be sure to read the Perl INSTALL file for more gcc-specific details. Please report any hoops you had to jump through to the development team.</source>
          <target state="translated">如果你决定使用gcc,请确保你的安装是最新的和完整的,并且一定要阅读Perl的INSTALL文件来了解更多关于gcc的细节。请向开发团队报告任何你不得不跳过的障碍。</target>
        </trans-unit>
        <trans-unit id="129ecc12b1557dd3798539452dbf9b9ea8476c0d" translate="yes" xml:space="preserve">
          <source>If you define an &lt;code&gt;AUTOLOAD&lt;/code&gt; in your class, then Perl will call your &lt;code&gt;AUTOLOAD&lt;/code&gt; to handle the &lt;code&gt;DESTROY&lt;/code&gt; method. You can prevent this by defining an empty &lt;code&gt;DESTROY&lt;/code&gt; , like we did in the autoloading example. You can also check the value of &lt;code&gt;$AUTOLOAD&lt;/code&gt; and return without doing anything when called to handle &lt;code&gt;DESTROY&lt;/code&gt; .</source>
          <target state="translated">如果您在类中定义了 &lt;code&gt;AUTOLOAD&lt;/code&gt; ，则Perl将调用您的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 来处理 &lt;code&gt;DESTROY&lt;/code&gt; 方法。您可以通过定义一个空的 &lt;code&gt;DESTROY&lt;/code&gt; 来避免这种情况，就像我们在自动加载示例中所做的那样。您还可以检查 &lt;code&gt;$AUTOLOAD&lt;/code&gt; 的值，并在调用 &lt;code&gt;DESTROY&lt;/code&gt; 时不做任何事情就返回。</target>
        </trans-unit>
        <trans-unit id="94eb8ac68c4fb558c46d1ee64b3833ca570000ed" translate="yes" xml:space="preserve">
          <source>If you define more than one name for the code point, it is indeterminate which one will be returned.</source>
          <target state="translated">如果你为代码点定义了一个以上的名字,那么返回的是不确定的。</target>
        </trans-unit>
        <trans-unit id="04b2ed76508ea6501a561cd368f25fd856dfc7e2" translate="yes" xml:space="preserve">
          <source>If you develop any useful expiration managers that you think should be distributed with Memoize, please let me know.</source>
          <target state="translated">如果你开发了任何你认为应该与Memoize一起发布的有用的到期管理程序,请告诉我。</target>
        </trans-unit>
        <trans-unit id="0cf4a8657eebfe97ba9c4e743bd983d09e5edaa6" translate="yes" xml:space="preserve">
          <source>If you didn't use &lt;code&gt;openlog()&lt;/code&gt; before using &lt;code&gt;syslog()&lt;/code&gt; , &lt;code&gt;syslog()&lt;/code&gt; will try to guess the &lt;code&gt;$ident&lt;/code&gt; by extracting the shortest prefix of &lt;code&gt;$format&lt;/code&gt; that ends in a &lt;code&gt;&quot;:&quot;&lt;/code&gt; .</source>
          <target state="translated">如果您没有使用 &lt;code&gt;openlog()&lt;/code&gt; 使用前 &lt;code&gt;syslog()&lt;/code&gt; ， &lt;code&gt;syslog()&lt;/code&gt; 函数将尝试猜测 &lt;code&gt;$ident&lt;/code&gt; 通过提取的最短前缀 &lt;code&gt;$format&lt;/code&gt; ，在一个两端 &lt;code&gt;&quot;:&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06ed1961687b0abd10e165d61c48cda9ac3ae785" translate="yes" xml:space="preserve">
          <source>If you discover some glitches, move directories of problematic modules to a different location; if these modules are non-XS modules, you may just ignore them - they are already installed; the remaining, XS, modules you need to install manually one by one.</source>
          <target state="translated">如果你发现了一些小问题,就把有问题的模块目录移到另一个位置;如果这些模块是非XS模块,你可以忽略它们--它们已经安装好了;剩下的XS模块,你需要一个个手动安装。</target>
        </trans-unit>
        <trans-unit id="43d56dedc7192e637755e1fdcd48fbf68cbff70a" translate="yes" xml:space="preserve">
          <source>If you do</source>
          <target state="translated">如果你这样做</target>
        </trans-unit>
        <trans-unit id="87ef7e6c621828b29eab79e96b5fb6269cd00a77" translate="yes" xml:space="preserve">
          <source>If you do not enter the shell, shell commands are available both as methods (&lt;code&gt;CPAN::Shell-&amp;gt;install(...)&lt;/code&gt; ) and as functions in the calling package (&lt;code&gt;install(...)&lt;/code&gt; ). Before calling low-level commands, it makes sense to initialize components of CPAN you need, e.g.:</source>
          <target state="translated">如果不输入外壳程序，则外壳程序命令既可以用作方法（ &lt;code&gt;CPAN::Shell-&amp;gt;install(...)&lt;/code&gt; ），也可以用作调用包中的函数（ &lt;code&gt;install(...)&lt;/code&gt; ）。在调用低级命令之前，有必要初始化所需的CPAN组件，例如：</target>
        </trans-unit>
        <trans-unit id="bc816a9fd08d7a00464780adbf72cc89737d7fde" translate="yes" xml:space="preserve">
          <source>If you do not have</source>
          <target state="translated">如果你没有</target>
        </trans-unit>
        <trans-unit id="69ced298dbf1c87fefd1662253cccc2e7a8bde7d" translate="yes" xml:space="preserve">
          <source>If you do not have a copy of the GNU General Public License write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</source>
          <target state="translated">如果您没有GNU通用公共许可证的副本,请写信给自由软件基金会公司,675 Mass Ave,Cambridge,MA 02139,USA。</target>
        </trans-unit>
        <trans-unit id="f9c124bac0783d0b5dcccc34a0dbf3566f426f11" translate="yes" xml:space="preserve">
          <source>If you do not have that module, you can do the same thing with &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt; which is part of the standard library:</source>
          <target state="translated">如果没有该模块，则可以使用标准库中的&lt;a href=&quot;file/find&quot;&gt;File :: Find&lt;/a&gt;进行相同的操作：</target>
        </trans-unit>
        <trans-unit id="bd07d5a5c26be6eca98f51764342db5783f35fa8" translate="yes" xml:space="preserve">
          <source>If you do not know what shell you have, consult your local helpdesk or the equivalent.</source>
          <target state="translated">如果您不知道您所使用的是什么外壳,请咨询您当地的服务台或同等机构。</target>
        </trans-unit>
        <trans-unit id="1de6e3279f2bd155e7f8bf6759e637927cce20be" translate="yes" xml:space="preserve">
          <source>If you do not set this flag then it is</source>
          <target state="translated">如果您不设置这个标志,那么它就是</target>
        </trans-unit>
        <trans-unit id="926a166805dd3b0aef3dd1d472d192955fb1ec52" translate="yes" xml:space="preserve">
          <source>If you do not specify a package name, the variable is created in the current package.</source>
          <target state="translated">如果没有指定包名,则在当前包中创建变量。</target>
        </trans-unit>
        <trans-unit id="3b6ac2382b8b465b26d1901487c44646a3e50e04" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="translated">如果您不想调用包的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法（例如，阻止更改名称空间），请显式提供空列表：</target>
        </trans-unit>
        <trans-unit id="ea10c1ff3a243c28f284c149e22c1d185c65b318" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="translated">如果您不想调用包的 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法（例如，阻止更改名称空间），请显式提供空列表：</target>
        </trans-unit>
        <trans-unit id="8470234c0d68b289fd8da0f074a387fae1ae490f" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="translated">如果您不想使用这些默认值，则可以通过显式设置 &lt;code&gt;Name&lt;/code&gt; ， &lt;code&gt;Time&lt;/code&gt; ， &lt;code&gt;TextFlag&lt;/code&gt; ， &lt;code&gt;ExtAttr&lt;/code&gt; ， &lt;code&gt;exUnixN&lt;/code&gt; 和 &lt;code&gt;exTime&lt;/code&gt; 选项或设置 &lt;code&gt;Minimal&lt;/code&gt; 参数来覆盖它们。</target>
        </trans-unit>
        <trans-unit id="f15a287c32e6f66173e359fbddfbe362d18b693a" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Time&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="translated">如果您不想使用这些默认值，则可以通过显式设置&amp;ldquo; &lt;code&gt;Name&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;Time&lt;/code&gt; 选项或通过设置&amp;ldquo; &lt;code&gt;Minimal&lt;/code&gt; 参数来覆盖它们。</target>
        </trans-unit>
        <trans-unit id="c647e4788bb29e5dcf3d258b1e0dc34c9ef54f62" translate="yes" xml:space="preserve">
          <source>If you do not wish this to happen, you should provide an array reference, where all parts of your command are already separated out. Note however, if there are extra or spurious whitespaces in these parts, the parser or underlying code may not interpret it correctly, and cause an error.</source>
          <target state="translated">如果你不希望发生这种情况,你应该提供一个数组引用,在这个数组中,你的命令的所有部分都已经被分离出来,但是请注意,如果在这些部分中有额外的或虚假的空白,解析器或底层代码可能不会正确解释,并导致错误。但是请注意,如果这些部分有额外的或虚假的空白,解析器或底层代码可能无法正确解释,并导致错误。</target>
        </trans-unit>
        <trans-unit id="1f09ee5e6b9af0c82c4326addc62e789f8443f5c" translate="yes" xml:space="preserve">
          <source>If you do not wish to install the &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module::Starter&lt;/a&gt; package from CPAN,</source>
          <target state="translated">如果您不想从CPAN 安装&lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module :: Starter&lt;/a&gt;软件包，</target>
        </trans-unit>
        <trans-unit id="0549310bae0dd74950be604da632c91876f7d8c0" translate="yes" xml:space="preserve">
          <source>If you do set &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; to 1, you will notice slow-downs.</source>
          <target state="translated">如果确实将 &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; 为1，您会注意到速度变慢。</target>
        </trans-unit>
        <trans-unit id="feef0b7ae2868ad2a4e1f83d30c63fb0d93e6be4" translate="yes" xml:space="preserve">
          <source>If you do this in a binary operator, you will actually change one of the strings that came into the operator, and, while it shouldn't be noticeable by the end user, it can cause problems in deficient code.</source>
          <target state="translated">如果你在二进制操作符中这样做,你实际上会改变进入操作符的其中一个字符串,虽然终端用户应该不会注意到,但它可能会导致缺陷代码的问题。</target>
        </trans-unit>
        <trans-unit id="32f0578310d415019b09f619288e373d3b705f8d" translate="yes" xml:space="preserve">
          <source>If you do want this subroutine to be a closure that reflects future changes to the variable that it closes over, add an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">如果您确实希望此子例程是一个闭合函数，以反映对该变量结束的将来更改，请添加显式 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7553259d39face4afb80ca316b04630713e25671" translate="yes" xml:space="preserve">
          <source>If you do want to work with large integers like under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; , try &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint;&lt;/code&gt; :</source>
          <target state="translated">如果您确实想使用大整数，例如 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; ，请尝试 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a338314884729930813df6e4dec44b70118fce2d" translate="yes" xml:space="preserve">
          <source>If you don't ask for any feature, you get the list of features that the user requested you to be nice to. This has the nice side effect that if you don't respect anything in particular then you can just ask for it and use it like a boolean.</source>
          <target state="translated">如果你不要求任何功能,你会得到用户要求你对其好的功能列表。这有一个很好的副作用,如果你不尊重任何特别的东西,那么你可以直接要求它,并像布尔值一样使用它。</target>
        </trans-unit>
        <trans-unit id="d5b6d156d7cf6f2a797778536a48c223724f9360" translate="yes" xml:space="preserve">
          <source>If you don't care about the order of the elements, you could just create the hash then extract the keys. It's not important how you create that hash: just that you use &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; to get the unique elements.</source>
          <target state="translated">如果您不关心元素的顺序，则可以只创建哈希然后提取键。创建散列并不重要：只是使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 来获取唯一元素。</target>
        </trans-unit>
        <trans-unit id="e21625178e6b6545fac5abe6f5027d91ef293d91" translate="yes" xml:space="preserve">
          <source>If you don't care about where digits and underscore sort to, you can do something like this</source>
          <target state="translated">如果你不关心数字和下划线的排序,你可以这样做</target>
        </trans-unit>
        <trans-unit id="f92e493c5048826b06ef70fc4669cac080dfe915" translate="yes" xml:space="preserve">
          <source>If you don't care that one hash overwrites keys and values from the other, you could just use a hash slice to add one hash to another. In this case, values from &lt;code&gt;%hash2&lt;/code&gt; replace values from &lt;code&gt;%hash1&lt;/code&gt; when they have keys in common:</source>
          <target state="translated">如果您不关心一个哈希值会覆盖另一个哈希值的键和值，则可以使用一个哈希片将一个哈希值添加到另一个哈希值中。在这种情况下，从值 &lt;code&gt;%hash2&lt;/code&gt; 从替代值 &lt;code&gt;%hash1&lt;/code&gt; 时，他们有共同的键：</target>
        </trans-unit>
        <trans-unit id="c43d001ee345c63043409156142b64f915867634" translate="yes" xml:space="preserve">
          <source>If you don't get a paragraph or two of expanded discussion, it might not be perl's message.</source>
          <target state="translated">如果你没有得到一两段扩展的讨论,可能不是perl的信息。</target>
        </trans-unit>
        <trans-unit id="7a12cb113cb2e2457200764dfd73d419fb8973d7" translate="yes" xml:space="preserve">
          <source>If you don't have File::Stream, you have to do a little more work.</source>
          <target state="translated">如果你没有File::Stream,你必须做更多的工作。</target>
        </trans-unit>
        <trans-unit id="ea4a8fbdbdee9b250414a6cc40a6c3e590cef92d" translate="yes" xml:space="preserve">
          <source>If you don't have data written with specific configuration of perl described above, then you do not and should not do anything. Don't set the flag - not only will Storable on an identically configured perl refuse to load them, but Storable a differently configured perl will load them believing them to be correct for it, and then may well fail or crash part way through reading them.</source>
          <target state="translated">如果你没有用上面描述的perl的特定配置来写数据,那么你不要也不应该做任何事情。不要设置这个标志--不仅在相同配置的perl上Storable会拒绝加载它们,而且不同配置的perl也会加载它们,认为它们是正确的,然后很可能在读取它们的过程中失败或崩溃。</target>
        </trans-unit>
        <trans-unit id="36289d77701a121889713d6277f544f12a871bb4" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; to trap the error.</source>
          <target state="translated">如果您没有对该DBM文件的写访问权，则只能读取哈希变量，而不能设置它们。如果要测试是否可以写入，请使用文件测试或尝试在 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中设置虚拟哈希条目以捕获错误。</target>
        </trans-unit>
        <trans-unit id="bdbbd37031df2f33535ed6549b499d32ea9aa9e5" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; to trap the error.</source>
          <target state="translated">如果您没有对该DBM文件的写访问权，则只能读取哈希变量，而不能设置它们。如果要测试是否可以写入，请使用文件测试或尝试在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中设置虚拟哈希条目以捕获错误。</target>
        </trans-unit>
        <trans-unit id="8f4b767528b9f98c2858aad05fc8520eae2c1d33" translate="yes" xml:space="preserve">
          <source>If you don't import any of these functions, assume a &lt;code&gt;&amp;amp;I18N::LangTags::&lt;/code&gt; in front of all the function names in the following examples.</source>
          <target state="translated">如果您不导入任何这些函数，则在以下示例中，在所有函数名称之前假定 &lt;code&gt;&amp;amp;I18N::LangTags::&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="107952179f7076da25aad77d14c209ced7df48df" translate="yes" xml:space="preserve">
          <source>If you don't know how many tests you're going to run, you can issue the plan when you're done running tests.</source>
          <target state="translated">如果你不知道你要运行多少测试,你可以在运行测试完成后发出计划。</target>
        </trans-unit>
        <trans-unit id="209c65929fc8bcea028a0c96cf1f684c89334602" translate="yes" xml:space="preserve">
          <source>If you don't know what license to use, dual licensing under the GPL and Artistic licenses (the same as Perl itself) is a good idea. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt; and &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;.</source>
          <target state="translated">如果您不知道要使用什么许可证，那么根据GPL和Artistic许可证（与Perl本身相同）进行双重许可是个好主意。参见&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt;和&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0afa056a783c1ff17e6396cee6d067cb1e22c33a" translate="yes" xml:space="preserve">
          <source>If you don't know whether a string contains YAML or JSON data, this method will use some heuristics and guess. If it can't tell, it assumes YAML.</source>
          <target state="translated">如果你不知道一个字符串是否包含YAML或JSON数据,这个方法会使用一些启发式的方法,并进行猜测。如果它无法判断,就会假设是YAML。</target>
        </trans-unit>
        <trans-unit id="d34593d2a30bd46dc846ad60717c333d071ef181" translate="yes" xml:space="preserve">
          <source>If you don't mind shelling out, the &lt;code&gt;wc&lt;/code&gt; command is usually the fastest, even with the extra interprocess overhead. Ensure that you have an untainted filename though:</source>
          <target state="translated">如果您不介意炮击，即使有额外的进程间开销， &lt;code&gt;wc&lt;/code&gt; 命令通常也是最快的。不过，请确保文件名没有污染：</target>
        </trans-unit>
        <trans-unit id="ab42639abd5abd9367c12d1d0ad1d1482fb0d4b6" translate="yes" xml:space="preserve">
          <source>If you don't need the existing content of the SV, you can avoid some copying with:</source>
          <target state="translated">如果你不需要SV的现有内容,你可以用避免一些复制。</target>
        </trans-unit>
        <trans-unit id="bd9e10a2452b68c075fcb32cabd703d0209267ed" translate="yes" xml:space="preserve">
          <source>If you don't need to know the name of the file, you can use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in place of the file name. In Perl 5.8 or later, the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function creates an anonymous temporary file:</source>
          <target state="translated">如果您不需要知道文件名，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 代替文件名。在Perl 5.8或更高版本中， &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 函数创建一个匿名临时文件：</target>
        </trans-unit>
        <trans-unit id="b260604ab4c441d85ae092e22c063810eb4d30c0" translate="yes" xml:space="preserve">
          <source>If you don't provide an exact inverse transformation, you will find that code like this will not behave as you expect.</source>
          <target state="translated">如果你不提供精确的逆向变换,你会发现这样的代码不会像你期望的那样。</target>
        </trans-unit>
        <trans-unit id="da9f240e2e4669201b3520ed7f3f5a0edd014292" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="translated">如果您真的不想执行第一个参数，而是想对正在执行的程序使用自己的名字说谎，则可以在其中指定要实际运行的程序作为&amp;ldquo;间接对象&amp;rdquo;（不带逗号）。 LIST的前面，如 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 。 （即使列表中只有一个标量，这始终会强制将LIST解释为多值列表。）示例：</target>
        </trans-unit>
        <trans-unit id="90475a6e4998e8131a7d71a411d5204a133b0a81" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="translated">如果您真的不想执行第一个参数，而是想对正在执行的程序使用自己的名字说谎，则可以在其中指定要实际运行的程序作为&amp;ldquo;间接对象&amp;rdquo;（不带逗号）。 LIST的前面，如 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 。 （即使列表中只有一个标量，这始终会强制将LIST解释为多值列表。）示例：</target>
        </trans-unit>
        <trans-unit id="1d09c87ff03423122d55e0fe04c7fdafafae320f" translate="yes" xml:space="preserve">
          <source>If you don't see an error message, you have the module. (If you do see an error message, it's still possible you have the module, but that it's not in your path, which you can display with &lt;code&gt;perl -e
&quot;print qq(@INC)&quot;&lt;/code&gt; .) For the remainder of this document, we'll assume that you really honestly truly lack an installed module, but have found it on the CPAN.</source>
          <target state="translated">如果没有看到错误消息，则说明您拥有该模块。（如果确实看到错误消息，则仍然有可能拥有该模块，但该模块不在您的路径中，可以使用 &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt; 显示该路径。）对于本文档的其余部分，我们将假设您确实缺乏安装的模块，但是已经在CPAN上找到了它。</target>
        </trans-unit>
        <trans-unit id="22a71969f2b2e317963f5563c127a63079459334" translate="yes" xml:space="preserve">
          <source>If you don't specify a &lt;code&gt;dw_size&lt;/code&gt; , it defaults to the entire memory limit.</source>
          <target state="translated">如果不指定 &lt;code&gt;dw_size&lt;/code&gt; ，则默认为整个内存限制。</target>
        </trans-unit>
        <trans-unit id="d559d6056536d78595c17d437dfe78484f93f47a" translate="yes" xml:space="preserve">
          <source>If you don't understand this question, just press ENTER.</source>
          <target state="translated">如果你不明白这个问题,就按回车键。</target>
        </trans-unit>
        <trans-unit id="e1a9da1b5f8c61c5b3d264532c0386f7656b5414" translate="yes" xml:space="preserve">
          <source>If you don't want &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; to change your original variable you can use the non-destructive substitute modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt;. This changes the behavior so that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; returns the final substituted string (instead of the number of substitutions):</source>
          <target state="translated">如果您不希望 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 更改原始变量，则可以使用非破坏性替换修饰符 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 。这将改变行为，以便 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 返回最终的替换字符串（而不是替换数）：</target>
        </trans-unit>
        <trans-unit id="b63f96d379f7a46f61c3872f0a57972ef07d6947" translate="yes" xml:space="preserve">
          <source>If you don't want any output should all modules be up to date, parse the output of above command for the regular expression &lt;code&gt;/modules are up to date/&lt;/code&gt; and decide to mail the output only if it doesn't match.</source>
          <target state="translated">如果您不希望所有模块都是最新的输出，请解析上述命令的输出以获取正则表达式 &lt;code&gt;/modules are up to date/&lt;/code&gt; 并决定仅在不匹配时才通过邮件发送。</target>
        </trans-unit>
        <trans-unit id="717adb67f10193acb40c16a22305c4dc8ba0e791" translate="yes" xml:space="preserve">
          <source>If you don't want to create a new hash, you can still use this looping technique; just change the &lt;code&gt;%new_hash&lt;/code&gt; to &lt;code&gt;%hash1&lt;/code&gt; .</source>
          <target state="translated">如果您不想创建新的哈希，则仍然可以使用此循环技术。只需更改 &lt;code&gt;%new_hash&lt;/code&gt; 到 &lt;code&gt;%hash1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5861b9dcca59001a7ac94c68a3d243558acaf640" translate="yes" xml:space="preserve">
          <source>If you don't want to install the compiled Perl in AIX into /QOpenSys (for packaging it before copying it to PASE), you can use a Configure parameter: -Dinstallprefix=/tmp/QOpenSys/perl. This will cause the &quot;make install&quot; to install everything into that directory, while the installed files still think they are (will be) in /QOpenSys/perl.</source>
          <target state="translated">如果你不想把在 AIX 中编译的 Perl 安装到 /QOpenSys 中 (为了在复制到 PASE 之前打包),你可以使用 Configure 参数:-Dinstallprefix=/tmp/QOpenSys/perl。这将导致 &quot;make install &quot;把所有的东西都安装到该目录下,而安装的文件仍然认为它们在/QOpenSys/perl中。</target>
        </trans-unit>
        <trans-unit id="ebe8a5460a3cd2a89a4ca3fccf1f4c546c9647e5" translate="yes" xml:space="preserve">
          <source>If you don't want to keep the defaults for the INSTALL* macros, MakeMaker helps you to minimize the typing needed: the usual relationship between INSTALLPRIVLIB and INSTALLARCHLIB is determined by Configure at perl compilation time. MakeMaker supports the user who sets INSTALLPRIVLIB. If INSTALLPRIVLIB is set, but INSTALLARCHLIB not, then MakeMaker defaults the latter to be the same subdirectory of INSTALLPRIVLIB as Configure decided for the counterparts in %Config, otherwise it defaults to INSTALLPRIVLIB. The same relationship holds for INSTALLSITELIB and INSTALLSITEARCH.</source>
          <target state="translated">如果你不想保留INSTALL*宏的默认值,MakeMaker可以帮助你尽量减少所需的键入:INSTALLPRIVLIB和INSTALLARCHLIB之间通常的关系是在perl编译时由Configure决定的。MakeMaker支持设置INSTALLPRIVLIB的用户。如果设置了INSTALLPRIVLIB,但没有设置INSTALLARCHLIB,那么MakeMaker默认后者是INSTALLPRIVLIB的同一个子目录,就像Configure决定的%Config中的对应目录一样,否则默认为INSTALLPRIVLIB。同样的关系也适用于INSTALLSITELIB和INSTALLSITEARCH。</target>
        </trans-unit>
        <trans-unit id="5f0e1c4bb41a9dbee49413981e4f4536890ac2a6" translate="yes" xml:space="preserve">
          <source>If you don't want to modify your source code, but still have on-the-fly warnings, do this:</source>
          <target state="translated">如果你不想修改你的源代码,但仍然有飞行中的警告,可以这样做。</target>
        </trans-unit>
        <trans-unit id="883af52a64cbec821f8f52f9cf06fce4facdd6ad" translate="yes" xml:space="preserve">
          <source>If you don't want to use the objects, you may import the &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method into your namespace as a regular function called &lt;code&gt;stat_cando&lt;/code&gt; . This takes an arrayref containing the return values of &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; as its first argument, and interprets it for you.</source>
          <target state="translated">如果您不想使用对象，则可以将 &lt;code&gt;-&amp;gt;cando&lt;/code&gt; 方法作为名为 &lt;code&gt;stat_cando&lt;/code&gt; 的常规函数导入到您的命名空间中。这将一个包含 &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 返回值的arrayref 作为其第一个参数，并为您解释它。</target>
        </trans-unit>
        <trans-unit id="8ca8817e625d3ffbecabec4b725646c93f6f8e36" translate="yes" xml:space="preserve">
          <source>If you don't wish to do this, set this variable to &lt;code&gt;false&lt;/code&gt; . Understand then that version comparisons are not possible, and Module::Load::Conditional can not tell you what module version you have installed. This may be desirable from a security or performance point of view. Note that &lt;code&gt;$FIND_VERSION&lt;/code&gt; code runs safely under &lt;code&gt;taint mode&lt;/code&gt; .</source>
          <target state="translated">如果您不想这样做，请将此变量设置为 &lt;code&gt;false&lt;/code&gt; 。然后了解不可能进行版本比较，并且Module :: Load :: Conditional无法告诉您已安装的模块版本。从安全性或性能的角度来看，这可能是理想的。请注意， &lt;code&gt;$FIND_VERSION&lt;/code&gt; 代码可以在taint &lt;code&gt;taint mode&lt;/code&gt; 安全运行。</target>
        </trans-unit>
        <trans-unit id="1341f2f78549b1827b1d11fb4b0cc0463ec09d6c" translate="yes" xml:space="preserve">
          <source>If you don't, you may experience strange build errors.</source>
          <target state="translated">如果你不这样做,你可能会遇到奇怪的构建错误。</target>
        </trans-unit>
        <trans-unit id="dae8c74471266a8218d010f2ece1eeec7e339df7" translate="yes" xml:space="preserve">
          <source>If you edit</source>
          <target state="translated">如果您编辑</target>
        </trans-unit>
        <trans-unit id="2fb01cc36906ab2ae202731906c27291970214ff" translate="yes" xml:space="preserve">
          <source>If you either have Perl 5.8.0 or later installed, or if you have Scalar-List-Utils 1.03 or later installed, you can say:</source>
          <target state="translated">如果你安装了Perl 5.8.0或更高版本,或者安装了Scalar-List-Utils 1.03或更高版本,你可以说。</target>
        </trans-unit>
        <trans-unit id="b892a658ce0764f4b064036e5d8f58bd78f5e370" translate="yes" xml:space="preserve">
          <source>If you evaluate a hash in scalar context, it returns false if the hash is empty. If there are any key/value pairs, it returns true; more precisely, the value returned is a string consisting of the number of used buckets and the number of allocated buckets, separated by a slash. This is pretty much useful only to find out whether Perl's internal hashing algorithm is performing poorly on your data set. For example, you stick 10,000 things in a hash, but evaluating %HASH in scalar context reveals &lt;code&gt;&quot;1/16&quot;&lt;/code&gt; , which means only one out of sixteen buckets has been touched, and presumably contains all 10,000 of your items. This isn't supposed to happen. If a tied hash is evaluated in scalar context, the &lt;code&gt;SCALAR&lt;/code&gt; method is called (with a fallback to &lt;code&gt;FIRSTKEY&lt;/code&gt; ).</source>
          <target state="translated">如果在标量上下文中评估哈希，则如果哈希为空，则返回false。如果有任何键/值对，则返回true；否则，返回true。更确切地说，返回的值是一个字符串，该字符串由已使用的存储桶数和已分配的存储桶数组成，并用斜杠分隔。这仅在发现Perl的内部哈希算法在数据集上是否表现不佳时非常有用。例如，您将10,000个东西粘贴在一个散列中，但是在标量上下文中评估％HASH会显示 &lt;code&gt;&quot;1/16&quot;&lt;/code&gt; ，这意味着仅触摸了16个存储桶中的一个，大概包含了所有10,000个项。这是不应该发生的。如果在标量上下文中计算绑定哈希，则将调用 &lt;code&gt;SCALAR&lt;/code&gt; 方法（回 &lt;code&gt;FIRSTKEY&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8b7212a78497ddedc16438e486691b2144fe7186" translate="yes" xml:space="preserve">
          <source>If you evaluate an array in scalar context, it returns the length of the array. (Note that this is not true of lists, which return the last value, like the C comma operator, nor of built-in functions, which return whatever they feel like returning.) The following is always true:</source>
          <target state="translated">如果你在标量上下文中评估一个数组,它会返回数组的长度。(请注意,这对列表来说不是真的,因为列表会返回最后一个值,就像C语言中的逗号运算符一样,对内置函数来说也不是真的,因为内置函数会返回它们想返回的任何值。)下面的内容永远是真的。</target>
        </trans-unit>
        <trans-unit id="ae75f4b9e5f451131a1e22cec2a555eb5370ed40" translate="yes" xml:space="preserve">
          <source>If you ever see a string that looks like this, you'll know you printed out a reference by mistake.</source>
          <target state="translated">如果你看到一个看起来像这样的字符串,你就会知道你打印出来的引用是错误的。</target>
        </trans-unit>
        <trans-unit id="d2eae54bf1fbe9ae68c160098f500a78269b550c" translate="yes" xml:space="preserve">
          <source>If you execute the &lt;code&gt;T&lt;/code&gt; command from inside an active &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, the backtrace will contain both a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; frame and an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; frame.</source>
          <target state="translated">如果从活动 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句内部执行 &lt;code&gt;T&lt;/code&gt; 命令，则回溯将同时包含 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 框架和 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 框架。</target>
        </trans-unit>
        <trans-unit id="e5fd5107f38bc928d4af20adedacdcf1cb44e019" translate="yes" xml:space="preserve">
          <source>If you expect characters to get to your device when you &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; them, you'll want to autoflush that filehandle. You can use &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;$|&lt;/code&gt; variable to control autoflushing (see</source>
          <target state="translated">如果您希望字符在 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 时进入设备，则需要自动刷新该文件句柄。您可以使用 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;$|&lt;/code&gt; 变量以控制自动冲洗（请参见</target>
        </trans-unit>
        <trans-unit id="b65a4bc3927cbd6d7618d76eb545351eb5d8a945" translate="yes" xml:space="preserve">
          <source>If you expect to use both read and write operations on the device, you'll have to open it for update (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for details). You may wish to open it without running the risk of blocking by using &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module (part of the standard perl distribution). See &lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt; for more on this approach.</source>
          <target state="translated">如果您希望在设备上同时使用读写操作，则必须将其打开以进行更新（有关详细信息，请参见&lt;a href=&quot;functions/open&quot;&gt;打开&lt;/a&gt;）。通过使用&lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt;模块（标准perl发行版的一部分 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; ，您可能希望打开它而不会产生阻塞的风险。有关此方法的更多信息，请参见&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="086943bc39b9078514791bccbde5ea2eddf63045" translate="yes" xml:space="preserve">
          <source>If you fail more than 254 tests, it will be reported as 254.</source>
          <target state="translated">如果你的测试不合格的次数超过254次,就会被报成254次。</target>
        </trans-unit>
        <trans-unit id="cba05a1f1e542bc35030ada7de3e6bf8ced79b98" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt; . Note that you will then need &lt;code&gt;IO::String&lt;/code&gt; installed to support writing stringified archives.</source>
          <target state="translated">如果您强烈希望禁用它，请将此变量设置为 &lt;code&gt;false&lt;/code&gt; 。请注意，然后您将需要安装 &lt;code&gt;IO::String&lt;/code&gt; 以支持编写字符串化的存档。</target>
        </trans-unit>
        <trans-unit id="0eb03812b9a06455d8a297e6d6e18c05b28becbc" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt; . Note that you will then need &lt;code&gt;perlio&lt;/code&gt; support from your perl to be able to write stringified archives.</source>
          <target state="translated">如果您强烈希望禁用它，请将此变量设置为 &lt;code&gt;false&lt;/code&gt; 。请注意，然后您将需要perl的 &lt;code&gt;perlio&lt;/code&gt; 支持，以便能够编写字符串化的存档。</target>
        </trans-unit>
        <trans-unit id="8b50f7e3c982f4c5e423c530952e3d4ee9e5c5f1" translate="yes" xml:space="preserve">
          <source>If you feel the urge to write Perl modules, &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt; will give you good advice.</source>
          <target state="translated">如果您渴望编写Perl模块，&lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt;将为您提供很好的建议。</target>
        </trans-unit>
        <trans-unit id="1ab4e553b43f57ec6c364e3642fd9276b76ed300" translate="yes" xml:space="preserve">
          <source>If you fill comfortable with</source>
          <target state="translated">如果你觉得舒服</target>
        </trans-unit>
        <trans-unit id="d37bfff208b4893c857f8a0e5567752243d86aa9" translate="yes" xml:space="preserve">
          <source>If you find any bugs, &lt;code&gt;Devel::PPPort&lt;/code&gt; doesn't seem to build on your system, or any of its tests fail, please file an issue here: &lt;a href=&quot;https://github.com/mhx/Devel-PPPort/issues/&quot;&gt;https://github.com/mhx/Devel-PPPort/issues/&lt;/a&gt;</source>
          <target state="translated">如果发现任何错误， &lt;code&gt;Devel::PPPort&lt;/code&gt; 似乎未在您的系统上构建，或者其任何测试失败，请在此处提出问题：&lt;a href=&quot;https://github.com/mhx/Devel-PPPort/issues/&quot;&gt;https&lt;/a&gt; : //github.com/mhx/Devel-PPPort/issues/</target>
        </trans-unit>
        <trans-unit id="b5ef4696f943b05c3aef9d5f207bfe62cada2927" translate="yes" xml:space="preserve">
          <source>If you find bugs in perl, you can run &lt;code&gt;perlbug&lt;/code&gt; to create a bug report (you may have to send it manually if &lt;code&gt;perlbug&lt;/code&gt; cannot find a mailer on your system).</source>
          <target state="translated">如果在perl中发现错误，则可以运行 &lt;code&gt;perlbug&lt;/code&gt; 来创建错误报告（如果 &lt;code&gt;perlbug&lt;/code&gt; 在系统上找不到邮件，则可能必须手动发送它）。</target>
        </trans-unit>
        <trans-unit id="549be5a33ff1eaf5b330339ea140d5f50a8a508b" translate="yes" xml:space="preserve">
          <source>If you find bugs or if it does not work at all on your device, send mail to the address below. Please report the details of your device (processor, ceversion, devicetype (hpc/palm/pocket)) and the date of the downloaded files.</source>
          <target state="translated">如果您发现错误或在您的设备上根本无法使用,请发送邮件到以下地址。请报告您设备的详细信息(处理器、版本、设备类型(HPC/Palm/Pocket))和下载文件的日期。</target>
        </trans-unit>
        <trans-unit id="ce181ab3a1836691a411c40b59cfd6c2a33af266" translate="yes" xml:space="preserve">
          <source>If you find instances of this in the Perl distribution itself, please let us know, so we can try to work around them.</source>
          <target state="translated">如果你在Perl发行版中发现了这种情况,请告诉我们,这样我们就可以尝试解决这些问题。</target>
        </trans-unit>
        <trans-unit id="a35b038d2558b01a66b6ce215ee08874b540cf15" translate="yes" xml:space="preserve">
          <source>If you find that you do need to update the system Perl, one issue worth keeping in mind is the question of static vs. dynamic libraries. If you upgrade using the default static libperl, you will find that the dynamic libperl supplied by Apple will not be deleted. If both libraries are present when an application that links against libperl is built, ld will link against the dynamic library by default. So, if you need to replace Apple's dynamic libperl with a static libperl, you need to be sure to delete the older dynamic library after you've installed the update.</source>
          <target state="translated">如果你发现确实需要更新系统Perl,有一个问题值得注意,那就是静态库与动态库的问题。如果你使用默认的静态libperl升级,你会发现苹果提供的动态libperl不会被删除。如果在构建针对libperl链接的应用程序时,这两个库都存在,那么ld会默认针对动态库进行链接。所以,如果你需要用静态libperl替换苹果的动态libperl,在安装更新后,你需要确保删除旧的动态库。</target>
        </trans-unit>
        <trans-unit id="8facfef28f917f827b51a8dc9cc5203934df7f46" translate="yes" xml:space="preserve">
          <source>If you find that you need to speed up a specific part of a Perl application (not something you often need) you may want to use C, but you can access this from your Perl code with &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;.</source>
          <target state="translated">如果发现需要加快Perl应用程序的特定部分（不是您经常需要的部分）的速度，则可以使用C，但是您可以使用&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;从Perl代码中访问它。</target>
        </trans-unit>
        <trans-unit id="6d6f2d3762fd66cb49c45a26180601ab0ecbaf26" translate="yes" xml:space="preserve">
          <source>If you find the Calc module to slow, try to install any of the replacement modules and see if they help you.</source>
          <target state="translated">如果你发现Calc模块速度很慢,请尝试安装任何一个替换模块,看看它们是否能帮助你。</target>
        </trans-unit>
        <trans-unit id="9507dd44f0fdbd974fde8543eaceef56a9bf59da" translate="yes" xml:space="preserve">
          <source>If you find the implementation document unclear or not sufficient, look at the existing PerlIO layer implementations, which include:</source>
          <target state="translated">如果你觉得实现文档不清楚或不充分,可以看看现有的PerlIO层实现,其中包括。</target>
        </trans-unit>
        <trans-unit id="bb1a29c843961bd016421afc69613b486ab41b5a" translate="yes" xml:space="preserve">
          <source>If you find this module useful, please consider rating it on the CPAN Ratings service at &lt;a href=&quot;http://cpanratings.perl.org/rate?distribution=autodie&quot;&gt;http://cpanratings.perl.org/rate?distribution=autodie&lt;/a&gt; .</source>
          <target state="translated">如果您发现此模块有用，请考虑在&lt;a href=&quot;http://cpanratings.perl.org/rate?distribution=autodie&quot;&gt;http://cpanratings.perl.org/rate?distribution=autodie&lt;/a&gt;的CPAN评分服务上对其进行评分。</target>
        </trans-unit>
        <trans-unit id="5afed98244534d5e7bd9f07d6f953a138ea4f8e9" translate="yes" xml:space="preserve">
          <source>If you find you need to provide custom functionality (as you would have using &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;), you're in luck: &lt;code&gt;TAP::Parser&lt;/code&gt; and friends are designed to be easily plugged-into and/or subclassed.</source>
          <target state="translated">如果您发现需要提供自定义功能（就像使用&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test :: Harness :: Straps一样&lt;/a&gt;），那么您会很幸运： &lt;code&gt;TAP::Parser&lt;/code&gt; 和朋友被设计为易于插入和/或子类化。</target>
        </trans-unit>
        <trans-unit id="7eaae25128643ba9a8e9cd9fd035b84dc1c8a6c4" translate="yes" xml:space="preserve">
          <source>If you find you really need to use your own iterator factory you can still do so without sub-classing &lt;code&gt;TAP::Parser&lt;/code&gt; by setting &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt;.</source>
          <target state="translated">如果发现确实需要使用自己的迭代器工厂，则仍然可以通过设置&lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class来对&lt;/a&gt; &lt;code&gt;TAP::Parser&lt;/code&gt; 进行子类化而无需这样做。</target>
        </trans-unit>
        <trans-unit id="ef253d4b5355af7bdf0e5249c9becef0fb63f08e" translate="yes" xml:space="preserve">
          <source>If you for some reason (such as binary backward compatibility) really need to use perl's malloc, you can rebuild perl from the sources and Configure the build with</source>
          <target state="translated">如果你出于某些原因(比如二进制后向兼容)真的需要使用perl的malloc,你可以从源码中重建perl,然后用以下方法配置构建。</target>
        </trans-unit>
        <trans-unit id="a38ea3094c2349d48a8464c8b2ede590e7cc8393" translate="yes" xml:space="preserve">
          <source>If you forget &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , high bytes will be misunderstood as separate characters, and nothing will work right.</source>
          <target state="translated">如果您忘记 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; ，高字节将被误认为是单独的字符，并且将无法正常工作。</target>
        </trans-unit>
        <trans-unit id="5c73cb5a6222b98080e0788ac4c8f896039ff111" translate="yes" xml:space="preserve">
          <source>If you forget to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , you'll miss out entirely on the helpful diagnostic message:</source>
          <target state="translated">如果您忘记 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ，则会完全忽略有用的诊断消息：</target>
        </trans-unit>
        <trans-unit id="4e4db242421a858aa14b9bcaa4e5f3862b8a23c5" translate="yes" xml:space="preserve">
          <source>If you get a core dump (or equivalent), you may use a debugger (&lt;b&gt;dbx&lt;/b&gt;, &lt;b&gt;gdb&lt;/b&gt;, etc) to produce a stack trace to include in the bug report.</source>
          <target state="translated">如果获得核心转储（或等效的转储），则可以使用调试器（&lt;b&gt;dbx&lt;/b&gt;，&lt;b&gt;gdb&lt;/b&gt;等）来生成要包含在错误报告中的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="722060cb13bfb62427a93bad15761822b6a7686d" translate="yes" xml:space="preserve">
          <source>If you get a message like &quot;perl: command not found&quot;, perl is not in your PATH, which might also mean that the location of perl is not where you expect it so you need to adjust your shebang line.</source>
          <target state="translated">如果你收到 &quot;perl:command not found &quot;这样的消息,说明perl不在你的PATH里,这也可能意味着perl的位置不在你期望的地方,所以你需要调整你的shebang行。</target>
        </trans-unit>
        <trans-unit id="6bc5836fc16b720e6dc1a4fbf9bbeb14813f0dae" translate="yes" xml:space="preserve">
          <source>If you get an error like</source>
          <target state="translated">如果你得到一个错误,如</target>
        </trans-unit>
        <trans-unit id="e71cc5ed2d43a688912302c22a7a0e3e08b5d7b1" translate="yes" xml:space="preserve">
          <source>If you get an error message</source>
          <target state="translated">如果你得到一个错误信息</target>
        </trans-unit>
        <trans-unit id="8b6135f8eeab8f4ac6ffe0b88df52abad52ae3b4" translate="yes" xml:space="preserve">
          <source>If you get complaints about so_locations then search in the file hints/irix_6.sh for &quot;lddflags&quot; and do the suggested adjustments. (David Billinghurst &amp;lt;David.Billinghurst@riotinto.com.au&amp;gt;)</source>
          <target state="translated">如果您对so_locations有所投诉，请在hints / irix_6.sh文件中搜索&amp;ldquo; lddflags&amp;rdquo;，然后进行建议的调整。（戴维&amp;middot;比林赫斯特&amp;lt;David.Billinghurst@riotinto.com.au&amp;gt;）</target>
        </trans-unit>
        <trans-unit id="0d74278837310505aa97f12b787c58f0bb90e74c" translate="yes" xml:space="preserve">
          <source>If you get lots of errors of the form</source>
          <target state="translated">如果你得到很多错误的形式</target>
        </trans-unit>
        <trans-unit id="0e2cd49639ef6344568879d541e1a269a34ede3d" translate="yes" xml:space="preserve">
          <source>If you get the error</source>
          <target state="translated">如果你收到错误信息</target>
        </trans-unit>
        <trans-unit id="91993b40c91822c3454671d4c8a24b32c3e646ba" translate="yes" xml:space="preserve">
          <source>If you get this message on SunOS or Solaris, and you're using gcc, it's probably the GNU as or GNU ld problem in the previous item &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as and GNU ld&lt;/a&gt;.</source>
          <target state="translated">如果您在SunOS或Solaris上收到此消息，并且使用的是gcc，则可能是前一项&lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as和GNU ld中&lt;/a&gt;的GNU as或GNU ld问题。</target>
        </trans-unit>
        <trans-unit id="36f4dbd793640e550ca076d30024d627de795ab8" translate="yes" xml:space="preserve">
          <source>If you get tired of being subject to your platform's native integers, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; pragma neatly sidesteps the issue altogether:</source>
          <target state="translated">如果您厌倦了受制于平台的本机整数，则 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; pragma会巧妙地完全避开该问题：</target>
        </trans-unit>
        <trans-unit id="a28e8a38182dc716f4c7bb3a2e2a63a098694e97" translate="yes" xml:space="preserve">
          <source>If you get tired of constantly saying &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; $lh-&amp;gt;maketext&lt;/code&gt; , consider making a functional wrapper for it, like so:</source>
          <target state="translated">如果您厌倦了不停地说 &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; $lh-&amp;gt;maketext&lt;/code&gt; ，请考虑为其创建一个功能包装器，如下所示：</target>
        </trans-unit>
        <trans-unit id="693c393f75e992e3003bea94747936126a6b0327" translate="yes" xml:space="preserve">
          <source>If you get tired of remembering which element of the return list contains which return value, by-name interfaces are provided in standard modules: &lt;code&gt;File::stat&lt;/code&gt; , &lt;code&gt;Net::hostent&lt;/code&gt; , &lt;code&gt;Net::netent&lt;/code&gt; , &lt;code&gt;Net::protoent&lt;/code&gt; , &lt;code&gt;Net::servent&lt;/code&gt; , &lt;code&gt;Time::gmtime&lt;/code&gt; , &lt;code&gt;Time::localtime&lt;/code&gt; , and &lt;code&gt;User::grent&lt;/code&gt; . These override the normal built-ins, supplying versions that return objects with the appropriate names for each field. For example:</source>
          <target state="translated">如果您厌倦了记住返回列表中的哪个元素包含哪个返回值，则在标准模块中提供按名称命名的接口： &lt;code&gt;File::stat&lt;/code&gt; ， &lt;code&gt;Net::hostent&lt;/code&gt; ， &lt;code&gt;Net::netent&lt;/code&gt; ， &lt;code&gt;Net::protoent&lt;/code&gt; ， &lt;code&gt;Net::servent&lt;/code&gt; ， &lt;code&gt;Time::gmtime&lt;/code&gt; ， &lt;code&gt;Time::localtime&lt;/code&gt; 和 &lt;code&gt;User::grent&lt;/code&gt; 。它们覆盖了普通的内置组件，提供的版本会为每个字段返回具有适当名称的对象。例如：</target>
        </trans-unit>
        <trans-unit id="b8e0fc194ad5e5c2cd16a3f242684fe425f3428b" translate="yes" xml:space="preserve">
          <source>If you get used to writing odd things like these:</source>
          <target state="translated">如果你习惯了写这种奇怪的东西。</target>
        </trans-unit>
        <trans-unit id="0cd15dd92a142244892a9be7434b98670ff15dc6" translate="yes" xml:space="preserve">
          <source>If you had &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %Foo::Bar::QUUX&lt;/code&gt; to check whether such a package variable exists then that's never really been reliable, and isn't a good way to enquire about the features of a package, or whether it's loaded, etc.</source>
          <target state="translated">如果您已 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %Foo::Bar::QUUX&lt;/code&gt; 来检查是否存在这样的程序包变量，那么这将永远是不可靠的，并且不是查询程序包功能或是否已加载程序包的好方法。</target>
        </trans-unit>
        <trans-unit id="4ef8417488b5df9f33f3d1b38e3847657756981c" translate="yes" xml:space="preserve">
          <source>If you had to get a variable through, you could do this:</source>
          <target state="translated">如果你必须要把一个变量打通,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="67b4946ef744afdd9a1b21f685b5b8e140afa4b4" translate="yes" xml:space="preserve">
          <source>If you have</source>
          <target state="translated">如果你有</target>
        </trans-unit>
        <trans-unit id="8ebbe151437cc5de6b126287c5035e996e85c741" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;http://search.cpan.org/perldoc/File::Stream&quot;&gt;File::Stream&lt;/a&gt;, this is easy.</source>
          <target state="translated">如果您有&lt;a href=&quot;http://search.cpan.org/perldoc/File::Stream&quot;&gt;File :: Stream&lt;/a&gt;，这很容易。</target>
        </trans-unit>
        <trans-unit id="8477c0614e083a37a8e560c57638a0b5f36ef52b" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module installed from CPAN, you can use it to fetch the width and height in characters and in pixels:</source>
          <target state="translated">如果从CPAN安装了&lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt;模块，则可以使用它来获取字符和像素的宽度和高度：</target>
        </trans-unit>
        <trans-unit id="240e14e2dd47b4fb473147b6d297b2d7726b59cc" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;IPC::Run&lt;/code&gt; installed, and the variable &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; is set to true (See the &lt;a href=&quot;#Global-Variables&quot;&gt;Global Variables&lt;/a&gt; section) use that to execute the command. You will have the full output available in buffers, interactive commands are sure to work and you are guaranteed to have your verbosity settings honored cleanly.</source>
          <target state="translated">如果安装了 &lt;code&gt;IPC::Run&lt;/code&gt; ，并且变量 &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; 设置为true（请参阅&amp;ldquo; &lt;a href=&quot;#Global-Variables&quot;&gt;全局变量&amp;rdquo;&lt;/a&gt;部分），则可以使用该命令执行命令。您将在缓冲区中获得完整的输出，交互式命令确保可以正常工作，并且确保您的详细程度设置明确无误。</target>
        </trans-unit>
        <trans-unit id="b8acd2601ad065393113859c8a7e3855297ce5ac" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;man&lt;/code&gt; installed on your system, and you installed perl manpages, use something like this:</source>
          <target state="translated">如果您的系统上安装了 &lt;code&gt;man&lt;/code&gt; ，并且安装了perl手册页，请使用以下命令：</target>
        </trans-unit>
        <trans-unit id="d6036be6bd4d2a23f70dfe8c9f989a5911198ccc" translate="yes" xml:space="preserve">
          <source>If you have Perl 5.10 or later, and you just want to store a value against the reference for lookup later, you can use the core Hash::Util::Fieldhash module. This will also handle renaming the keys if you use multiple threads (which causes all variables to be reallocated at new addresses, changing their stringification), and garbage-collecting the entries when the referenced variable goes out of scope.</source>
          <target state="translated">如果你使用的是Perl 5.10或更高版本,并且你只是想存储一个值以备以后查找,你可以使用核心的Hash::Util::Fieldhash模块。如果你使用多个线程,它还会处理键的重命名(这会导致所有变量在新的地址上被重新分配,改变它们的字符串化),以及当被引用的变量超出范围时垃圾回收条目。</target>
        </trans-unit>
        <trans-unit id="1ff5e330b4023d9ffe19df36972bfcc73814fd9b" translate="yes" xml:space="preserve">
          <source>If you have Perl 5.10 or later, this is almost trivial. You just smart match against an array of regular expression objects:</source>
          <target state="translated">如果你有Perl 5.10或更高版本,这几乎是微不足道的。你只需对一个正则表达式对象数组进行智能匹配。</target>
        </trans-unit>
        <trans-unit id="2fe696e9056ea562cb89c9b2f102390c60db24f0" translate="yes" xml:space="preserve">
          <source>If you have Perl v5.16, the problems mentioned above go away if you use the &lt;code&gt;:not_characters&lt;/code&gt; parameter to the locale pragma (except for vendor bugs in the non-character portions). If you don't have v5.16, and you</source>
          <target state="translated">如果您具有Perl v5.16，则对区域设置用法使用 &lt;code&gt;:not_characters&lt;/code&gt; 参数，上述问题将消失（非字符部分中的供应商错误除外）。如果您没有v5.16，并且您</target>
        </trans-unit>
        <trans-unit id="6642f62c4bfdebf5e62452d5d72c26f1bd89b8ec" translate="yes" xml:space="preserve">
          <source>If you have YAML.pm (or some other YAML module configured in &lt;code&gt;yaml_module&lt;/code&gt; ) installed, CPAN.pm collects a few statistical data about recent downloads. You can view the statistics with the &lt;code&gt;hosts&lt;/code&gt; command or inspect them directly by looking into the &lt;code&gt;FTPstats.yml&lt;/code&gt; file in your &lt;code&gt;cpan_home&lt;/code&gt; directory.</source>
          <target state="translated">如果您安装了YAML.pm（或在 &lt;code&gt;yaml_module&lt;/code&gt; 中配置的其他一些YAML模块），则CPAN.pm会收集一些有关最近下载的统计数据。您可以使用 &lt;code&gt;hosts&lt;/code&gt; 命令查看统计信息，也可以通过查看 &lt;code&gt;cpan_home&lt;/code&gt; 目录中的 &lt;code&gt;FTPstats.yml&lt;/code&gt; 文件直接检查统计信息。</target>
        </trans-unit>
        <trans-unit id="225c354ad980b0b7bb691380c5b2f0d3c2643a5a" translate="yes" xml:space="preserve">
          <source>If you have a ReadLine module installed, you can hit TAB at any point of the commandline and &lt;code&gt;o conf&lt;/code&gt; will offer you completion for the built-in subcommands and/or config variable names.</source>
          <target state="translated">如果安装了ReadLine模块，则可以在命令行的任何位置点击TAB， &lt;code&gt;o conf&lt;/code&gt; 将为您提供内置子命令和/或配置变量名称的完成信息。</target>
        </trans-unit>
        <trans-unit id="86d2e902132f610059a158729cf105aa2e1d4e91" translate="yes" xml:space="preserve">
          <source>If you have a buffer allocated with Newx() and want to set that as the SV's value, you can use sv_usepvn_flags(). That has some requirements if you want to avoid perl re-allocating the buffer to fit the trailing NUL:</source>
          <target state="translated">如果你有一个用Newx()分配的缓冲区,并且想把它设置为SV的值,你可以使用sv_usepvn_flags()。如果你想避免perl重新分配缓冲区以适应尾部的NUL,这有一些要求。</target>
        </trans-unit>
        <trans-unit id="28b93e0d6dcdb9743374e046e2c50f7ec24b530d" translate="yes" xml:space="preserve">
          <source>If you have a burning desire to tell the world about your release, post an announcement to the moderated &lt;code&gt;comp.lang.perl.announce&lt;/code&gt; newsgroup.</source>
          <target state="translated">如果您有向世人讲述发布的强烈愿望，请在主持人的 &lt;code&gt;comp.lang.perl.announce&lt;/code&gt; 新闻组中发布公告。</target>
        </trans-unit>
        <trans-unit id="2ed22a427a030ed732816620f86f5c52ec466566" translate="yes" xml:space="preserve">
          <source>If you have a command-line program that does the job, you can call it in backticks to capture whatever it outputs so you can use it later:</source>
          <target state="translated">如果你有一个命令行程序来完成这项工作,你可以用回标调用它来捕捉它输出的任何东西,以便你以后可以使用它。</target>
        </trans-unit>
        <trans-unit id="aabc7446c5d3e0c2ebc9233bf601a7899d673f9d" translate="yes" xml:space="preserve">
          <source>If you have a commit bit, please see &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt; for more details on using git.</source>
          <target state="translated">如果您有提交位，请参阅&lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt;以获得有关使用git的更多详细信息。</target>
        </trans-unit>
        <trans-unit id="392daf22cd236f28ba9ceee336856176b759059d" translate="yes" xml:space="preserve">
          <source>If you have a complicated function needed to pull out the part you want to sort on, then don't do it inside the sort function. Pull it out first, because the sort BLOCK can be called many times for the same element. Here's an example of how to pull out the first word after the first number on each item, and then sort those words case-insensitively.</source>
          <target state="translated">如果你有一个复杂的函数需要拉出你要排序的部分,那么不要在排序函数里面做。先把它拉出来,因为同一个元素的排序BLOCK可以被调用很多次。下面是一个例子,如何在每个项目上拉出第一个数字后面的第一个单词,然后对这些单词进行大小写不敏感的排序。</target>
        </trans-unit>
        <trans-unit id="b0e6b3bda8c96c33f56e6b729af6c8286cbfdc17" translate="yes" xml:space="preserve">
          <source>If you have a legacy encoding, you can use the &lt;code&gt;:encoding(...)&lt;/code&gt; tag.</source>
          <target state="translated">如果您使用的是旧版编码，则可以使用 &lt;code&gt;:encoding(...)&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="01656c2b4f7ea5f69bae8d5caaac9ea48410bb3e" translate="yes" xml:space="preserve">
          <source>If you have a library that provides an API, you can make any component of it available as just another Perl function or variable using a Perl extension written in C or C++ and dynamically linked into your main perl interpreter. You can also go the other direction, and write your main program in C or C++, and then link in some Perl code on the fly, to create a powerful application. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">如果您有提供API的库，则可以使用以C或C ++编写的Perl扩展并将其动态链接到您的主要perl解释器中，使其任何组件仅作为另一个Perl函数或变量可用。您也可以朝另一个方向发展，用C或C ++编写主程序，然后动态链接一些Perl代码，以创建功能强大的应用程序。见&lt;a href=&quot;perlembed&quot;&gt;临危&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51f9e3f6122598346b767c490154d73f3d45b4f6" translate="yes" xml:space="preserve">
          <source>If you have a list of tests (or URLs, or anything else you want to test) in a file, you can add them to your tests by using a '-':</source>
          <target state="translated">如果你有一个文件中的测试列表(或URL,或其他任何你想测试的东西),你可以通过使用'-'将它们添加到你的测试中。</target>
        </trans-unit>
        <trans-unit id="a1add680b7e930dc8542127166a2c6922328bade" translate="yes" xml:space="preserve">
          <source>If you have a local mirror of CPAN and can access all files with &quot;file:&quot; URLs, then you only need a perl later than perl5.003 to run this module. Otherwise Net::FTP is strongly recommended. LWP may be required for non-UNIX systems, or if your nearest CPAN site is associated with a URL that is not &lt;code&gt;ftp:&lt;/code&gt; .</source>
          <target state="translated">如果您具有CPAN的本地镜像，并且可以访问带有&amp;ldquo; file：&amp;rdquo; URL的所有文件，则只需要晚于perl5.003的perl即可运行此模块。否则，强烈建议使用Net :: FTP。对于非UNIX系统，或者如果您最近的CPAN站点与非 &lt;code&gt;ftp:&lt;/code&gt; 的URL关联，则可能需要LWP 。</target>
        </trans-unit>
        <trans-unit id="3c6b091f1c2f3916b6f982ec5d76127aba417742" translate="yes" xml:space="preserve">
          <source>If you have a question you'd like to see added to the FAQ (whether or not you have the answer) please send it to makemaker@perl.org.</source>
          <target state="translated">如果你有一个问题想添加到FAQ中(无论你是否有答案),请将其发送到makemaker@perl.org。</target>
        </trans-unit>
        <trans-unit id="883ef441e28a9d839f80a61f11348168ebf17cd9" translate="yes" xml:space="preserve">
          <source>If you have a raw sequence of bytes that you know should be interpreted via a particular encoding, you can use &lt;code&gt;Encode&lt;/code&gt; :</source>
          <target state="translated">如果您知道应通过特定编码解释的原始字节序列，则可以使用 &lt;code&gt;Encode&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4977b6a1b7796edc98abe66364bdbf5af8c6caa8" translate="yes" xml:space="preserve">
          <source>If you have a really hairy regular expression, use the &lt;code&gt;/x&lt;/code&gt; modifier and put in some whitespace to make it look a little less like line noise. Don't use slash as a delimiter when your regexp has slashes or backslashes.</source>
          <target state="translated">如果您的正则表达式真的很毛茸茸，请使用 &lt;code&gt;/x&lt;/code&gt; 修饰符并放入一些空格，使其看起来更像行噪。当您的regexp有斜杠或反斜杠时，请勿使用斜杠作为分隔符。</target>
        </trans-unit>
        <trans-unit id="c4670adaa2657eda2badbded5180916956105a77" translate="yes" xml:space="preserve">
          <source>If you have a sequence of bytes you &lt;b&gt;know&lt;/b&gt; is valid UTF-8, but Perl doesn't know it yet, you can make Perl a believer, too:</source>
          <target state="translated">如果您有一个字节序列，则&lt;b&gt;知道&lt;/b&gt;是有效的UTF-8，但Perl尚不知道，您也可以使Perl成为一个信徒：</target>
        </trans-unit>
        <trans-unit id="9756e7acda84539ead2e5f85f560f283b75aed93" translate="yes" xml:space="preserve">
          <source>If you have a single string that you want to check for &quot;equality in locale&quot; against several others, you might think you could gain a little efficiency by using &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; in conjunction with &lt;code&gt;eq&lt;/code&gt; :</source>
          <target state="translated">如果您有一个字符串要与其他字符串检查&amp;ldquo;语言环境是否相等&amp;rdquo;，您可能会认为通过将 &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; 与 &lt;code&gt;eq&lt;/code&gt; 结合使用可以提高效率：</target>
        </trans-unit>
        <trans-unit id="f645dc4bb8034c3799b831d6996356797ca7be48" translate="yes" xml:space="preserve">
          <source>If you have a small patch to submit, please submit it via perlbug. You can also send email directly to perlbug@perl.org. Please note that messages sent to perlbug may be held in a moderation queue, so you won't receive a response immediately.</source>
          <target state="translated">如果你有一个小补丁要提交,请通过perlbug提交。您也可以直接发送电子邮件到 perlbug@perl.org。请注意,发送至 perlbug 的消息可能会被保留在管理队列中,因此您不会立即收到回复。</target>
        </trans-unit>
        <trans-unit id="42845d8c8c875f89de9dd2d1b7586e0d3ad16bc8" translate="yes" xml:space="preserve">
          <source>If you have a specific romanization scheme in mind, use the specific module:</source>
          <target state="translated">如果你有特定的罗马化方案,请使用特定的模块。</target>
        </trans-unit>
        <trans-unit id="fb355db0f3f4b40524a1c3ff445d923be623d546" translate="yes" xml:space="preserve">
          <source>If you have a working &lt;code&gt;DynaLoader&lt;/code&gt; then there is rarely any need to statically link in any other extensions.</source>
          <target state="translated">如果您有一个可用的 &lt;code&gt;DynaLoader&lt;/code&gt; ,那么几乎不需要任何其他扩展中的静态链接。</target>
        </trans-unit>
        <trans-unit id="fd5f81af8a4a7363d6132316fb90657fc9d4e232" translate="yes" xml:space="preserve">
          <source>If you have a zip file that contains multiple members and want to read a specific member from the file, say &lt;code&gt;&quot;data1&quot;&lt;/code&gt; , use the &lt;code&gt;Name&lt;/code&gt; option</source>
          <target state="translated">如果您的zip文件包含多个成员，并且想从该文件中读取特定成员，请说 &lt;code&gt;&quot;data1&quot;&lt;/code&gt; ，请使用&amp;ldquo; &lt;code&gt;Name&lt;/code&gt; 选项</target>
        </trans-unit>
        <trans-unit id="e8e60773a7086adcadd9997f1e4e60bf13f42c27" translate="yes" xml:space="preserve">
          <source>If you have an FTP proxy firewall (&lt;b&gt;NOT&lt;/b&gt; an HTTP or SOCKS firewall) then this value should be set to the firewall hostname. If your firewall does not listen to port 21, then this value should be set to &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; (eg &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt; )</source>
          <target state="translated">如果您有FTP代理防火墙（&lt;b&gt;不是&lt;/b&gt; HTTP或SOCKS防火墙），则应将此值设置为防火墙主机名。如果您的防火墙不侦听端口21，则此值应设置为 &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; （例如 &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3a37d9c6262b12c7aa2b49bfbcebb4a375757d2e" translate="yes" xml:space="preserve">
          <source>If you have an SV and want to know what kind of data Perl thinks is stored in it, you can use the following macros to check the type of SV you have.</source>
          <target state="translated">如果你有一个SV,并且想知道Perl认为里面存储了什么样的数据,你可以使用下面的宏来检查你所拥有的SV的类型。</target>
        </trans-unit>
        <trans-unit id="2bc4f67186bf30ca57f017f1cea8612b943dd146" translate="yes" xml:space="preserve">
          <source>If you have an array of &lt;code&gt;@string&lt;/code&gt; that should be concatenated and then normalized, you can do like this:</source>
          <target state="translated">如果您有一个 &lt;code&gt;@string&lt;/code&gt; 数组，应该将其连接起来然后再进行规范化，则可以这样进行：</target>
        </trans-unit>
        <trans-unit id="403ab04dd713d2cfe6f16d5487fb0193f691f18c" translate="yes" xml:space="preserve">
          <source>If you have an empty directory, you can use Perl's built-in &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt;. If the directory is not empty (so, no files or subdirectories), you either have to empty it yourself (a lot of work) or use a module to help you.</source>
          <target state="translated">如果目录为空，则可以使用Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; 。如果目录不为空（因此没有文件或子目录），则您必须自己清空（很多工作）或使用模块来帮助您。</target>
        </trans-unit>
        <trans-unit id="6898ea8c69aa4a0ff2b81092a3457a58f7bdc010" translate="yes" xml:space="preserve">
          <source>If you have an existing inside-out class, simply making all hashes field hashes with no other change should make no difference. Through the calls to &lt;code&gt;refaddr&lt;/code&gt; or equivalent, the field hashes never get to see a reference and work like normal hashes. Your DESTROY (and CLONE) methods are still needed.</source>
          <target state="translated">如果您有一个现有的由内而外的类，则仅进行所有哈希字段哈希而不进行其他任何更改就不会有任何区别。通过调用 &lt;code&gt;refaddr&lt;/code&gt; 或等效项，字段散列永远不会看到引用，并且像普通散列一样工作。仍然需要您的DESTROY（和CLONE）方法。</target>
        </trans-unit>
        <trans-unit id="03fcf475306c60d974596613b76c03a9f344e66a" translate="yes" xml:space="preserve">
          <source>If you have an older version of Perl, the &lt;code&gt;$^W&lt;/code&gt; variable (documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;) controls runtime warnings for a block:</source>
          <target state="translated">如果您使用的是Perl的旧版本，则 &lt;code&gt;$^W&lt;/code&gt; 变量（在&lt;a href=&quot;perlvar&quot;&gt;perlvar中记录&lt;/a&gt;）控制着块的运行时警告：</target>
        </trans-unit>
        <trans-unit id="55ec04844d40449455953b5a185c6050647bf370" translate="yes" xml:space="preserve">
          <source>If you have any other characters you need to escape, please install the &lt;code&gt;URI::Escape&lt;/code&gt; module from CPAN, and pre-encode your URI before passing it to &lt;code&gt;File::Fetch&lt;/code&gt; . You can read about the details of URIs and URI encoding here:</source>
          <target state="translated">如果您还有其他需要转义的字符，请从CPAN 安装 &lt;code&gt;URI::Escape&lt;/code&gt; 模块，并在将其传递到 &lt;code&gt;File::Fetch&lt;/code&gt; 之前对其进行预编码。您可以在此处阅读有关URI和URI编码的详细信息：</target>
        </trans-unit>
        <trans-unit id="59ef038a12de814aa0cdf806e88e5a326fdaf2d5" translate="yes" xml:space="preserve">
          <source>If you have any suggested changes for this page, let me know. Please don't send me mail asking for help on how to install your modules. There are too many modules, and too few Orwants, for me to be able to answer or even acknowledge all your questions. Contact the module author instead, or post to comp.lang.perl.modules, or ask someone familiar with Perl on your operating system.</source>
          <target state="translated">如果你对这个页面有任何修改建议,请告诉我。请不要给我发邮件询问如何安装您的模块。模块太多,Orwants也太少,我无法回答甚至确认你所有的问题。请联系模块的作者,或者在comp.lang.perl.modules上发帖,或者询问熟悉Perl的人。</target>
        </trans-unit>
        <trans-unit id="e2545920681caa56966e901dca47f4688bdb95ac" translate="yes" xml:space="preserve">
          <source>If you have built this module with zlib &amp;gt;= 1.2.0, the &lt;code&gt;$eof&lt;/code&gt; parameter is ignored. You can still set it if you want, but it won't be used behind the scenes.</source>
          <target state="translated">如果您使用zlib&amp;gt; = 1.2.0构建了该模块，则 &lt;code&gt;$eof&lt;/code&gt; 参数将被忽略。您仍然可以根据需要进行设置，但是不会在幕后使用它。</target>
        </trans-unit>
        <trans-unit id="bd7c754383786ab750ba8d8b8b5b2710b62cfc9e" translate="yes" xml:space="preserve">
          <source>If you have built this module with zlib 1.2.3 or better, two more CRC-related functions are available.</source>
          <target state="translated">如果您使用zlib 1.2.3或更高版本来构建这个模块,还有两个CRC相关的函数可以使用。</target>
        </trans-unit>
        <trans-unit id="b49d178439aabd6902535000d809a8c4d8c6c0d0" translate="yes" xml:space="preserve">
          <source>If you have compile-time executable statements (such as code within BEGIN, UNITCHECK and CHECK blocks or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statements), these will</source>
          <target state="translated">如果您具有编译时可执行语句（例​​如BEGIN，UNITCHECK和CHECK块中的代码或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句），这些将</target>
        </trans-unit>
        <trans-unit id="4a053828197d3de496e658e2f64e31f462c0e7ce" translate="yes" xml:space="preserve">
          <source>If you have experience with other thread implementations, you might find that things aren't quite what you expect. It's very important to remember when dealing with Perl threads that</source>
          <target state="translated">如果你有其他线程实现的经验,你可能会发现事情并不像你期望的那样。在处理Perl线程时,记住以下几点是非常重要的</target>
        </trans-unit>
        <trans-unit id="0ffa35b58c4462159f2ea02872365ed984d54889" translate="yes" xml:space="preserve">
          <source>If you have found a bug with a non-standard port (one that was not part of the</source>
          <target state="translated">如果您发现了一个非标准 port 的错误 (一个不属于</target>
        </trans-unit>
        <trans-unit id="0e1af930aa8bf951949bff6fef33b900fd538735" translate="yes" xml:space="preserve">
          <source>If you have generated such a statically-linked executable by choice, then instead of saying &quot;&lt;code&gt;make test&lt;/code&gt; &quot;, you should say &quot;&lt;code&gt;make test_static&lt;/code&gt; &quot;. On systems that cannot build dynamically-loadable libraries at all, simply saying &quot;&lt;code&gt;make test&lt;/code&gt; &quot; is sufficient.</source>
          <target state="translated">如果通过选择生成了这样的静态链接的可执行文件，则应该说&amp;ldquo; &lt;code&gt;make test_static&lt;/code&gt; &amp;rdquo; ，而不是说&amp;ldquo; &lt;code&gt;make test&lt;/code&gt; &amp;rdquo;。在根本无法构建可动态加载的库的系统上，只需说&amp;ldquo; &lt;code&gt;make test&lt;/code&gt; &amp;rdquo;就足够了。</target>
        </trans-unit>
        <trans-unit id="ea57a23a75f969a9e5ed037d598a374a300583a4" translate="yes" xml:space="preserve">
          <source>If you have gotten this far into the tutorial, you can probably guess what the different parts of the debugging output tell you. The first part</source>
          <target state="translated">如果你已经走到了本教程的这一步,你可能会猜到调试输出的不同部分告诉你什么。第一部分</target>
        </trans-unit>
        <trans-unit id="9d264a66a026ef716495bcfe67d5b82c2fd75d79" translate="yes" xml:space="preserve">
          <source>If you have installed a signal handler for &lt;code&gt;SIGCHLD&lt;/code&gt; , the value of &lt;code&gt;$?&lt;/code&gt; will usually be wrong outside that handler.</source>
          <target state="translated">如果您已为 &lt;code&gt;SIGCHLD&lt;/code&gt; 安装了信号处理程序，则 &lt;code&gt;$?&lt;/code&gt; 的值。在该处理程序之外通常将是错误的。</target>
        </trans-unit>
        <trans-unit id="d59e8efecc586326d2ab32c89e976a471be555e8" translate="yes" xml:space="preserve">
          <source>If you have installed extra libraries such as GDBM through Fink (in other words, you have libraries under</source>
          <target state="translated">如果您通过Fink安装了额外的库,如GDBM(换句话说,您在</target>
        </trans-unit>
        <trans-unit id="adf0535478f796f8c19ba9c98c90186d9fd4978f" translate="yes" xml:space="preserve">
          <source>If you have more than two files, this is the place where you should boot extra XS files from.</source>
          <target state="translated">如果你有两个以上的文件,你应该从这里启动额外的XS文件。</target>
        </trans-unit>
        <trans-unit id="47f402ce95a3894708d131d4f57afb65a8408c3a" translate="yes" xml:space="preserve">
          <source>If you have neither Net::FTP nor LWP, there is a fallback mechanism implemented for an external ftp command or for an external lynx command.</source>
          <target state="translated">如果你既没有Net::FTP,也没有LWP,就会有一个回退机制,用于外部ftp命令或外部lynx命令。</target>
        </trans-unit>
        <trans-unit id="24c715fba81da2278914f96579f9af2c125fe732" translate="yes" xml:space="preserve">
          <source>If you have never been to a hackathon, here are a few basic things you need to know before attending: have a working laptop and know how to use it; check out the involved projects beforehand; have the necessary version control client; and bring backup equipment (an extra LAN cable, additional power strips, etc.) because someone will forget.</source>
          <target state="translated">如果你从来没有参加过黑客马拉松,那么在参加之前,你需要知道以下几件基本的事情:有一台可以使用的笔记本电脑,并且知道如何使用它;事先查看所涉及的项目;准备好必要的版本控制客户端;带好备用设备(一根额外的局域网线、额外的电源条等),因为有人会忘记。</target>
        </trans-unit>
        <trans-unit id="1eb2a3bd6bb2269e089bc5caced075f60ca01d0a" translate="yes" xml:space="preserve">
          <source>If you have never defined your own &lt;code&gt;urllist&lt;/code&gt; in your configuration then &lt;code&gt;CPAN.pm&lt;/code&gt; will be hesitant to use the built in default sites for downloading. It will ask you once per session if a connection to the internet is OK and only if you say yes, it will try to connect. But to avoid this question, you can choose your favorite download sites once and get away with it. Or, if you have no favorite download sites answer yes to the following question.</source>
          <target state="translated">如果您从未在配置中定义自己的 &lt;code&gt;urllist&lt;/code&gt; ，则 &lt;code&gt;CPAN.pm&lt;/code&gt; 会犹豫使用内置的默认站点进行下载。它将在每个会话中询问您一次是否可以正常连接到互联网，并且仅当您说&amp;ldquo;是&amp;rdquo;时，它才会尝试连接。但是要避免这个问题，您可以一次选择自己喜欢的下载站点并摆脱它。或者，如果您没有喜欢的下载站点，请回答以下问题。</target>
        </trans-unit>
        <trans-unit id="7a84d97dce110800ef0a7f4d11d992d7a0415274" translate="yes" xml:space="preserve">
          <source>If you have never uploaded a module to CPAN before (and even if you have), you are strongly encouraged to get feedback on &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fprepan.org&quot;&gt;PrePAN&lt;/a&gt;. PrePAN is a site dedicated to discussing ideas for CPAN modules with other Perl developers and is a great resource for new (and experienced) Perl developers.</source>
          <target state="translated">如果您从未（甚至没有）从未将模块上传到CPAN，则强烈建议您获取有关&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fprepan.org&quot;&gt;PrePAN的&lt;/a&gt;反馈。PrePAN是一个致力于与其他Perl开发人员讨论CPAN模块想法的站点，并且是新的（和经验丰富的）Perl开发人员的宝贵资源。</target>
        </trans-unit>
        <trans-unit id="eb6ae544b0243a12b93b26e3f0b3956b5515717f" translate="yes" xml:space="preserve">
          <source>If you have one of the readline packages (Term::ReadLine::Perl, Term::ReadLine::Gnu, possibly others) installed, the interactive CPAN shell will have history support. The next two questions deal with the filename of the history file and with its size. If you do not want to set this variable, please hit SPACE ENTER to the following question.</source>
          <target state="translated">如果你安装了一个读线包 (Term::ReadLine::Perl,Term::ReadLine::Gnu,可能还有其它的),交互式 CPAN shell 将会有历史记录支持。接下来的两个问题是关于历史文件的文件名和大小。如果你不想设置这个变量,请在下面的问题中按空格回车。</target>
        </trans-unit>
        <trans-unit id="bb7b55bdb52c9b6a39041d0271244a521cb3ff47" translate="yes" xml:space="preserve">
          <source>If you have perl documentation in the source form, perl utilities installed, and GNU groff installed, you may use</source>
          <target state="translated">如果你已经安装了源码形式的perl文档、perl实用程序和GNU groff,你可以使用</target>
        </trans-unit>
        <trans-unit id="841004095d25b3d59f531a821f770d0871403ca9" translate="yes" xml:space="preserve">
          <source>If you have previously used &lt;code&gt;Compress::Zlib&lt;/code&gt; 1.x, the following enhancements/changes have been made to the &lt;code&gt;gzopen&lt;/code&gt; interface:</source>
          <target state="translated">如果您以前使用过 &lt;code&gt;Compress::Zlib&lt;/code&gt; 1.x，则对 &lt;code&gt;gzopen&lt;/code&gt; 接口进行了以下增强/更改：</target>
        </trans-unit>
        <trans-unit id="d2a37b8d2199c6cd81ec323e698311d35b1e6c13" translate="yes" xml:space="preserve">
          <source>If you have problems with dynamic loading using gcc on SunOS or Solaris, and you are using GNU as and GNU ld, see the section &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as and GNU ld&lt;/a&gt; above.</source>
          <target state="translated">如果在SunOS或Solaris上使用gcc进行动态加载时遇到问题，并且将GNU as和GNU ld一起使用，请参见上面的&lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as和GNU ld&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="ea5710225473b92c4d4337a393fa28ea045d7828" translate="yes" xml:space="preserve">
          <source>If you have questions about DJGPP, try posting to the DJGPP newsgroup: comp.os.msdos.djgpp, or use the email gateway djgpp@delorie.com.</source>
          <target state="translated">如果您有关于DJGPP的问题,请尝试发帖到DJGPP新闻组:comp.os.msdos.djgpp,或者使用电子邮件网关djgpp@delorie.com。</target>
        </trans-unit>
        <trans-unit id="fe0f8d11e3dbd4746ff7b4eeb245a0d52d534f6e" translate="yes" xml:space="preserve">
          <source>If you have questions, I will be happy to answer them if you send them to mjd-perl-memoize+@plover.com.</source>
          <target state="translated">如果你有问题,如果你把问题发到mjd-perl-memoize+@plover.com,我很乐意回答。</target>
        </trans-unit>
        <trans-unit id="f26f03ce6e7bfe1cbb7f3ba37413ced07d1e0917" translate="yes" xml:space="preserve">
          <source>If you have read this far, congratulations! You now have all the basic tools needed to use regular expressions to solve a wide range of text processing problems. If this is your first time through the tutorial, why not stop here and play around with regexps a while.... Part 2 concerns the more esoteric aspects of regular expressions and those concepts certainly aren't needed right at the start.</source>
          <target state="translated">如果你已经读到这里,恭喜你!你现在已经掌握了使用正则表达式解决各种文本处理问题所需的所有基本工具。你现在已经掌握了使用正则表达式来解决各种文本处理问题所需的所有基本工具。如果这是你第一次阅读本教程,为什么不在这里停下来玩一会儿正则表达式呢......?第2部分涉及正则表达式更深奥的方面,这些概念当然不是一开始就需要的。</target>
        </trans-unit>
        <trans-unit id="75f3eda9f9b422ec46068b583597695f9e1e075d" translate="yes" xml:space="preserve">
          <source>If you have some WWW browser available, installed the Perl documentation in the source form, and Perl utilities, you can build HTML docs. Cd to directory with</source>
          <target state="translated">如果你有一些WWW浏览器,安装了Perl文档的源码,以及Perl实用工具,你就可以建立HTML文档。把它放到带有</target>
        </trans-unit>
        <trans-unit id="15919d939102f998b0d1a3071b0bdc4ec9361810" translate="yes" xml:space="preserve">
          <source>If you have some WWW browser available, you can build &lt;b&gt;HTML&lt;/b&gt; docs. Cd to directory with</source>
          <target state="translated">如果您有一些WWW浏览器，则可以构建&lt;b&gt;HTML&lt;/b&gt;文档。CD到目录</target>
        </trans-unit>
        <trans-unit id="760a427c6aacab9e74e50c0e342e67f06ea0a89d" translate="yes" xml:space="preserve">
          <source>If you have some working code for &lt;code&gt;OS2::Cmd&lt;/code&gt; , please send it to me, I will include it into distribution. I have no need for such a module, so cannot test it.</source>
          <target state="translated">如果您有 &lt;code&gt;OS2::Cmd&lt;/code&gt; 一些工作代码，请将其发送给我，我会将其包含在发行版中。我不需要这样的模块，因此无法对其进行测试。</target>
        </trans-unit>
        <trans-unit id="c766c1d4e406f5a8fab49e64104f5bd544a7e67b" translate="yes" xml:space="preserve">
          <source>If you have test cases that fail, check for the existence of spool files. The test case may be trying to use a syscall that is not implemented in PASE. To avoid the SIGILL, try setting the PASE_SYSCALL_NOSIGILL environment variable or have a handler for the SIGILL. If you can compile programs for PASE, run the config script and edit config.sh when it gives you the option. If you want to remove fchdir(), which isn't implement in V5R1, simply change the line that says:</source>
          <target state="translated">如果测试用例失败,请检查是否存在spool文件。测试用例可能试图使用 PASE 中没有实现的系统调用。为了避免 SIGILL,可以尝试设置 PASE_SYSCALL_NOSIGILL 环境变量,或者为 SIGILL 设置一个处理程序。如果你能编译 PASE 的程序,运行 config 脚本,并在它给你选项时编辑 config.sh。如果你想删除fchdir(),因为它在V5R1中没有实现,只需修改下面的一行。</target>
        </trans-unit>
        <trans-unit id="c895956df28d2a0d520a665ed39e5054b694f69f" translate="yes" xml:space="preserve">
          <source>If you have the &lt;code&gt;Kwalify&lt;/code&gt; module installed (which is part of the Bundle::CPANxxl), then all your distroprefs files are checked for syntactic correctness.</source>
          <target state="translated">如果您安装了 &lt;code&gt;Kwalify&lt;/code&gt; 模块（它是Bundle :: CPANxxl的一部分），则将检查所有Distroprefs文件的语法正确性。</target>
        </trans-unit>
        <trans-unit id="310e2cf6fe93a96344e5f48617c55b650052b357" translate="yes" xml:space="preserve">
          <source>If you have the &lt;code&gt;uncompress&lt;/code&gt; program available, you can use this to read compressed files</source>
          <target state="translated">如果您有可用的 &lt;code&gt;uncompress&lt;/code&gt; 程序，则可以使用它来读取压缩文件</target>
        </trans-unit>
        <trans-unit id="a48f13710ced892050924fc9519945fba0fac1d0" translate="yes" xml:space="preserve">
          <source>If you have the GNU's version of &lt;b&gt;emacs&lt;/b&gt; installed on your system, it can interact with the Perl debugger to provide an integrated software development environment reminiscent of its interactions with C debuggers.</source>
          <target state="translated">如果您的系统上安装了GNU版本的&lt;b&gt;emacs&lt;/b&gt;，则它可以与Perl调试器进行交互，以提供一个集成的软件开发环境，让人联想到它与C调试器的交互。</target>
        </trans-unit>
        <trans-unit id="831bd1aa0f0b4a83cdb4f8d8c798aaee5e24ba5d" translate="yes" xml:space="preserve">
          <source>If you have the LD_LIBRARY_PATH environment variable set, be sure that it does NOT include /lib or /usr/lib. If you will be building extensions that call third-party shared libraries (e.g. Berkeley DB) then make sure that your LD_LIBRARY_PATH environment variable includes the directory with that library (e.g. /usr/local/lib).</source>
          <target state="translated">如果你设置了LD_LIBRARY_PATH环境变量,请确保它不包括/lib或/usr/lib。如果你将构建调用第三方共享库的扩展(例如Berkeley DB),那么请确保你的LD_LIBRARY_PATH环境变量包括该库的目录(例如/usr/local/lib)。</target>
        </trans-unit>
        <trans-unit id="7b99419c67def721d2695cd48d34dc88cb8c781c" translate="yes" xml:space="preserve">
          <source>If you have to deal with a lot of C structures, and don't want to hack all your template strings manually, you'll probably want to have a look at the CPAN module &lt;code&gt;Convert::Binary::C&lt;/code&gt; . Not only can it parse your C source directly, but it also has built-in support for all the odds and ends described further on in this section.</source>
          <target state="translated">如果你要处理大量的C结构，而不想手动破解所有的模板字符串，你可能会想看看CPAN的模块 &lt;code&gt;Convert::Binary::C&lt;/code&gt; 。它不仅可以直接解析您的C源代码，而且还内置了对本节中进一步描述的所有杂物的支持。</target>
        </trans-unit>
        <trans-unit id="fedff50b6bdfc3eaf8ccc29c03df5c84e0ff6a06" translate="yes" xml:space="preserve">
          <source>If you have trouble compiling the scripts in this documentation, you're not alone. The cardinal rule: COMPILE THE PROGRAMS IN EXACTLY THE SAME WAY THAT YOUR PERL WAS COMPILED. (Sorry for yelling.)</source>
          <target state="translated">如果你在编译本文档中的脚本时遇到困难,你并不孤单。最重要的规则是:&quot;完全按照你的PERL编译方式来编译程序。完全按照你的PERL编译方式来编译这些程序。(对不起,我大喊大叫了。)</target>
        </trans-unit>
        <trans-unit id="899489485e48eb6acab0142eabbf325712e8b44a" translate="yes" xml:space="preserve">
          <source>If you have updated your Solaris version, you may also have to update your gcc. For example, if you are running Solaris 2.6 and your gcc is installed under /usr/local, check in /usr/local/lib/gcc-lib and make sure you have the appropriate directory, sparc-sun-solaris2.6/ or i386-pc-solaris2.6/. If gcc's directory is for a different version of Solaris than you are running, then you will need to rebuild gcc for your new version of Solaris.</source>
          <target state="translated">如果你更新了你的Solaris版本,你可能也需要更新你的gcc。例如,如果你正在运行Solaris 2.6,而你的gcc安装在/usr/local下,请检查/usr/local/lib/gcc-lib,并确保你有合适的目录,sparc-sun-solaris2.6/或i386-pc-solaris2.6/.如果gcc的目录与你正在运行的Solaris版本不同,那么你将需要为你的新版本Solaris重建gcc。</target>
        </trans-unit>
        <trans-unit id="d44abb6ca108f95533f7bd86193633f514940a80" translate="yes" xml:space="preserve">
          <source>If you have your perl compiled for debugging (usually done with &lt;code&gt;-DDEBUGGING&lt;/code&gt; on the &lt;code&gt;Configure&lt;/code&gt; command line), you may examine the compiled tree by specifying &lt;code&gt;-Dx&lt;/code&gt; on the Perl command line. The output takes several lines per node, and for &lt;code&gt;$b+$c&lt;/code&gt; it looks like this:</source>
          <target state="translated">如果已经编译了Perl以进行调试（通常在 &lt;code&gt;Configure&lt;/code&gt; 命令行中使用 &lt;code&gt;-DDEBUGGING&lt;/code&gt; 完成），则可以通过在Perl命令行中指定 &lt;code&gt;-Dx&lt;/code&gt; 来检查编译的树。输出每个节点花费几行，对于 &lt;code&gt;$b+$c&lt;/code&gt; 它看起来像这样：</target>
        </trans-unit>
        <trans-unit id="4be3c9c74002e27258a38e4f113b05f31396c7de" translate="yes" xml:space="preserve">
          <source>If you haven't already guessed, the location string is stored with a terminating NULL. This means you need to be careful when accessing the database.</source>
          <target state="translated">如果你还没有猜到,位置字符串是以终止的NULL存储的。这意味着你在访问数据库时需要小心。</target>
        </trans-unit>
        <trans-unit id="f0a36e2858858b02958d2f9bb2e7a02778b6e7c8" translate="yes" xml:space="preserve">
          <source>If you haven't already, before reading this document, you should become familiar with both &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; and &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">如果还没有，请在阅读本文档之前熟悉&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;和&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f5cd5895b74e660a355a89bb89cfe0d64a65e68" translate="yes" xml:space="preserve">
          <source>If you haven't read &lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; and &lt;a href=&quot;perlhacktut&quot;&gt;perlhacktut&lt;/a&gt; yet, you might want to do that first.</source>
          <target state="translated">如果您还没有阅读&lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt;和&lt;a href=&quot;perlhacktut&quot;&gt;perlhacktut&lt;/a&gt;，则可能要先阅读。</target>
        </trans-unit>
        <trans-unit id="9d18cc6d1bb045c22ff75a5143e7edc7882d3f36" translate="yes" xml:space="preserve">
          <source>If you haven't read &lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; yet, go do that first! You might also want to read through &lt;a href=&quot;perlsource&quot;&gt;perlsource&lt;/a&gt; too.</source>
          <target state="translated">如果您还没有阅读过&lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt;，请先进行操作！您可能还需要阅读&lt;a href=&quot;perlsource&quot;&gt;perlsource&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c78c6e524a1994f83a33a6fe7a18f30be9a7fce" translate="yes" xml:space="preserve">
          <source>If you haven't used regular expressions before, a quick-start introduction is available in &lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt;, and a longer tutorial introduction is available in &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;.</source>
          <target state="translated">如果您以前没有使用过正则表达式，则可以在&lt;a href=&quot;perlrequick&quot;&gt;perlrequick中&lt;/a&gt;找到快速入门介绍，而在&lt;a href=&quot;perlretut&quot;&gt;perlretut中&lt;/a&gt;可以找到更长的教程介绍。</target>
        </trans-unit>
        <trans-unit id="3a7a1d83ca677617a38c3a7af6a10c7ed341f9e8" translate="yes" xml:space="preserve">
          <source>If you haven't yet moved &lt;code&gt;perl*.dll&lt;/code&gt; onto LIBPATH, do it now.</source>
          <target state="translated">如果尚未将 &lt;code&gt;perl*.dll&lt;/code&gt; 移至LIBPATH，请立即执行。</target>
        </trans-unit>
        <trans-unit id="83593b846f63af31e001bdf82839b9a46da47025" translate="yes" xml:space="preserve">
          <source>If you ignore all the error checking that most of the code does, the essence of the filter is as follows:</source>
          <target state="translated">如果你忽略了大部分代码所做的错误检查,过滤器的本质如下。</target>
        </trans-unit>
        <trans-unit id="4660b183b00b39c6b2b92484fb7503359beb8635" translate="yes" xml:space="preserve">
          <source>If you import &lt;code&gt;:constants256&lt;/code&gt; , you can use the following constants directly:</source>
          <target state="translated">如果导入 &lt;code&gt;:constants256&lt;/code&gt; ，则可以直接使用以下常量：</target>
        </trans-unit>
        <trans-unit id="f87b608eeb1cdc6eb4d8977d4b889a03e6d083dd" translate="yes" xml:space="preserve">
          <source>If you intend making use of the object returned from either tie() or tied(), and if the tie's target class defines a destructor, there is a subtle gotcha you</source>
          <target state="translated">如果你打算使用从 tie()或 tied()返回的对象,并且如果 tie 的目标类定义了一个析构器,那么你就会发现一个微妙的陷阱,那就是</target>
        </trans-unit>
        <trans-unit id="8bc6f9a7f0a4b90e4946e190029eff70ef889753" translate="yes" xml:space="preserve">
          <source>If you intend to manipulate the Zip64 zip files created with this module using an external zip/unzip, make sure that it supports Zip64.</source>
          <target state="translated">如果你打算使用外部的zip/unzip来操作用该模块创建的Zip64压缩文件,请确保它支持Zip64。</target>
        </trans-unit>
        <trans-unit id="fd3a1f6a190142b4a94b8f1071ccacb0e45694c8" translate="yes" xml:space="preserve">
          <source>If you intend to run only on FAT (or if using AnyDBM_File on FAT), run Configure with the -Ui_ndbm and -Ui_dbm options to prevent NDBM_File and ODBM_File being built.</source>
          <target state="translated">如果你打算只在 FAT 上运行 (或者在 FAT 上使用 AnyDBM_File),使用 -Ui_ndbm 和 -Ui_dbm 选项运行 Configure 以防止 NDBM_File 和 ODBM_File 被构建。</target>
        </trans-unit>
        <trans-unit id="3f04b70c5edf0d8a2ff6b52a2e5a3c4237fee493" translate="yes" xml:space="preserve">
          <source>If you intend using the Filter::Call functionality, I would strongly recommend that you check out Damian Conway's excellent Filter::Simple module. Damian's module provides a much cleaner interface than Filter::Util::Call. Although it doesn't allow the fine control that Filter::Util::Call does, it should be adequate for the majority of applications. It's available at</source>
          <target state="translated">如果你打算使用Filter::Call功能,我会强烈建议你查看Damian Conway的优秀的Filter::Simple模块。Damian的模块提供了一个比Filter::Util::Call更简洁的界面。虽然它不允许像Filter::Util::Call那样的精细控制,但它应该足以满足大多数应用程序的需求。它可以在</target>
        </trans-unit>
        <trans-unit id="e2cffac6976f9820e2e90021e812ad7d58d0f5b4" translate="yes" xml:space="preserve">
          <source>If you intended for the subroutine to be eligible for inlining, then make sure the variable is not referenced elsewhere, possibly by copying it:</source>
          <target state="translated">如果你打算让这个子程序符合内联的条件,那么请确保这个变量没有被引用到其他地方,可能是通过复制它。</target>
        </trans-unit>
        <trans-unit id="9dab4bde5120fee3a0a7f6db844ef859c18d4c68" translate="yes" xml:space="preserve">
          <source>If you invoke Concise more than once in a program, you should know that the options are 'sticky'. This means that the options you provide in the first call will be remembered for the 2nd call, unless you re-specify or change them.</source>
          <target state="translated">如果你在程序中调用 Concise 多次,你应该知道这些选项是 &quot;粘性 &quot;的,这意味着你在第一次调用时提供的选项会在第二次调用时被记住,除非你重新指定或更改它们。这意味着你在第一次调用时提供的选项将在第二次调用时被记住,除非你重新指定或更改它们。</target>
        </trans-unit>
        <trans-unit id="50093622d9b6b20299be5b789440addca54eb16b" translate="yes" xml:space="preserve">
          <source>If you invoke Perl with the &lt;b&gt;-d&lt;/b&gt; switch, your script runs under the Perl source debugger. This works like an interactive Perl environment, prompting for debugger commands that let you examine source code, set breakpoints, get stack backtraces, change the values of variables, etc. This is so convenient that you often fire up the debugger all by itself just to test out Perl constructs interactively to see what they do. For example:</source>
          <target state="translated">如果使用&lt;b&gt;-d&lt;/b&gt;开关调用Perl，则脚本将在Perl源调试器下运行。它的工作方式类似于交互式Perl环境，会提示您输入调试器命令，这些命令可让您检查源代码，设置断点，获取堆栈回溯，更改变量的值等。这非常方便，因此您经常自己单独启动调试器即可以交互方式测试Perl构造以查看其作用。例如：</target>
        </trans-unit>
        <trans-unit id="5f165a45e66d1014a54e531d87cac35b6f25f848" translate="yes" xml:space="preserve">
          <source>If you iterate through the hash with each(), you can delete the key most recently returned without worrying about it. If you delete or add other keys, the iterator may skip or double up on them since perl may rearrange the hash table. See the entry for &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">如果使用each（）遍历哈希，则可以删除最近返回的密钥，而不必担心。如果删除或添加其他键，则迭代器可能会跳过或加倍使用它们，因为perl可能会重新排列哈希表。请参阅进入 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; 在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="96bb290aa78bc388524149987ffa684a6cd88006" translate="yes" xml:space="preserve">
          <source>If you just need to customize the objects on creation, subclass &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_iterator_factory&quot;&gt;make_iterator_factory&lt;/a&gt;.</source>
          <target state="translated">如果只需要在创建时自定义对象，请子类&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;并覆盖&lt;a href=&quot;#make_iterator_factory&quot;&gt;make_iterator_factory&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1eae7a7eb8bcc1fc11d062386801944953ed61fe" translate="yes" xml:space="preserve">
          <source>If you just want to extract, use the &lt;code&gt;extract_archive&lt;/code&gt; class method instead. It will optimize and write to disk immediately.</source>
          <target state="translated">如果只想提取，请改用 &lt;code&gt;extract_archive&lt;/code&gt; 类方法。它将优化并立即写入磁盘。</target>
        </trans-unit>
        <trans-unit id="205b6c9376bdc41030a3ba0411b3c133175a1cfb" translate="yes" xml:space="preserve">
          <source>If you just want to know how to use the utilities described here,</source>
          <target state="translated">如果你只是想知道如何使用这里介绍的实用程序。</target>
        </trans-unit>
        <trans-unit id="5ca84053d1241bb168ed3733abf9fe5fef328612" translate="yes" xml:space="preserve">
          <source>If you just want to load a module in a test, we recommend simply using &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directly. It will cause the test to stop.</source>
          <target state="translated">如果您只想在测试中加载模块，我们建议直接使用 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 。这将导致测试停止。</target>
        </trans-unit>
        <trans-unit id="58d9e2fc3089c3ee91bde03c8a168aabda14adca" translate="yes" xml:space="preserve">
          <source>If you just want to submit a single small patch like a pod fix, a test for a bug, comment fixes, etc., it's easy! Here's how:</source>
          <target state="translated">如果你只是想提交一个小补丁,比如一个pod的修复,一个bug的测试,评论的修复等等,这很容易!你可以在这里提交一个小补丁。下面是如何提交的。</target>
        </trans-unit>
        <trans-unit id="a3962095233ae6bded8cb1555c84a52ea4fc9a0c" translate="yes" xml:space="preserve">
          <source>If you just want to test a module can be loaded, use &lt;code&gt;require_ok&lt;/code&gt; .</source>
          <target state="translated">如果您只是想测试模块是否可以加载，请使用 &lt;code&gt;require_ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42e3b970aadb68ea3a8923d019f70d26e7a5a350" translate="yes" xml:space="preserve">
          <source>If you know</source>
          <target state="translated">如果你知道</target>
        </trans-unit>
        <trans-unit id="9c14b8eb60486ad1003f5f292ba8d0aaf7f2284e" translate="yes" xml:space="preserve">
          <source>If you know one name for a Unicode property, you can use &lt;code&gt;prop_aliases&lt;/code&gt; to find either the long name (when called in scalar context), or a list of all of the names, somewhat ordered so that the short name is in the 0th element, the long name in the next element, and any other synonyms are in the remaining elements, in no particular order.</source>
          <target state="translated">如果您知道Unicode属性的名称，则可以使用 &lt;code&gt;prop_aliases&lt;/code&gt; 查找长名称（在标量上下文中调用时）或所有名称的列表，并按一定顺序排列，以使短名称位于第0个元素中，下一个元素中的长名称，以及其他任何同义词都在其余元素中，没有特定的顺序。</target>
        </trans-unit>
        <trans-unit id="4a59a33095f0058eebdfd05ced2318493337053a" translate="yes" xml:space="preserve">
          <source>If you know the columns that contain the data, you can use &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; to extract a single column.</source>
          <target state="translated">如果知道包含数据的列，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; 提取单个列。</target>
        </trans-unit>
        <trans-unit id="9eb4c97e122131b8720d6a259fed14fb554c1b02" translate="yes" xml:space="preserve">
          <source>If you know the directory already, you can add it to &lt;code&gt;@INC&lt;/code&gt; as you would for any other directory. You might &amp;lt;use lib&amp;gt; if you know the directory at compile time:</source>
          <target state="translated">如果您已经知道目录，则可以将其添加到 &lt;code&gt;@INC&lt;/code&gt; ,就像将其添加到任何其他目录一样。如果您在编译时知道目录，则可以&amp;lt;use lib&amp;gt;：</target>
        </trans-unit>
        <trans-unit id="e98e61c08f8371d445ada91d42b0a6e31509fa7c" translate="yes" xml:space="preserve">
          <source>If you know the exact length in bits, it can be used in place of the &lt;code&gt;*&lt;/code&gt; .</source>
          <target state="translated">如果您知道确切的长度（以位为单位），则可以用它代替 &lt;code&gt;*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="927bf5e4096ddfb3b14c96fc89123708e7ddad90" translate="yes" xml:space="preserve">
          <source>If you know the length of the compressed data stream before you start uncompressing, you can avoid having to use &lt;code&gt;trailingData&lt;/code&gt; by setting the &lt;code&gt;InputLength&lt;/code&gt; option in the constructor.</source>
          <target state="translated">如果您知道压缩数据流的长度，你开始解压之前，你能避免使用 &lt;code&gt;trailingData&lt;/code&gt; 通过设置 &lt;code&gt;InputLength&lt;/code&gt; 在构造函数中的选项。</target>
        </trans-unit>
        <trans-unit id="f21638ec12744a0da920d55488938e9726007614" translate="yes" xml:space="preserve">
          <source>If you know the length of the compressed data stream before you start uncompressing, you can avoid having to use &lt;code&gt;trailingData&lt;/code&gt; by setting the &lt;code&gt;InputLength&lt;/code&gt; option.</source>
          <target state="translated">如果您知道压缩数据流的长度，你开始解压之前，你能避免使用 &lt;code&gt;trailingData&lt;/code&gt; 通过设置 &lt;code&gt;InputLength&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="d2ae57604fb0c858677a8a7bba0d622df68f1d53" translate="yes" xml:space="preserve">
          <source>If you know the name of a hash variable, you can get a pointer to its HV by using the following:</source>
          <target state="translated">如果你知道一个哈希变量的名字,你可以通过使用下面的方法获得指向它的HV的指针。</target>
        </trans-unit>
        <trans-unit id="eb63e6aa11dc04fb3c005505a5dc56980b836dee" translate="yes" xml:space="preserve">
          <source>If you know the name of a scalar variable, you can get a pointer to its SV by using the following:</source>
          <target state="translated">如果你知道一个标量变量的名称,你可以通过使用下面的方法获得指向它的SV的指针。</target>
        </trans-unit>
        <trans-unit id="71cc5e317d663fb79a1bf1ed454222ec34ef184d" translate="yes" xml:space="preserve">
          <source>If you know the name of an array variable, you can get a pointer to its AV by using the following:</source>
          <target state="translated">如果你知道一个数组变量的名称,你可以通过使用下面的方法来获得它的AV指针。</target>
        </trans-unit>
        <trans-unit id="cd318c8126ae3cf5cfc9e3d9345bc2d0fc779cdb" translate="yes" xml:space="preserve">
          <source>If you know what you are doing you can turn off this warning by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'non_unicode';&lt;/code&gt; .</source>
          <target state="translated">如果您知道自己在做什么，则可以通过 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'non_unicode';&lt;/code&gt; 警告来关闭此警告。。</target>
        </trans-unit>
        <trans-unit id="b884b7f1740fc7317e54fef08f2f9cd3cb14f5e3" translate="yes" xml:space="preserve">
          <source>If you know what you are doing you can turn off this warning by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'surrogate';&lt;/code&gt; .</source>
          <target state="translated">如果您知道自己在做什么，则可以通过 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'surrogate';&lt;/code&gt; 来关闭此警告。。</target>
        </trans-unit>
        <trans-unit id="9e7e8e09f3e73c52948b41c1fa2c3d1d138db3f3" translate="yes" xml:space="preserve">
          <source>If you know you are only going to use a system that does correctly implement appending (i.e. not Win32) then you can omit the &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; from the code in the previous answer.</source>
          <target state="translated">如果您知道只使用能够正确实现附加的系统（即不是Win32），则可以忽略上一个答案中的代码 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1148f14b2fe4053075a5db927cd2f992ce530c8c" translate="yes" xml:space="preserve">
          <source>If you know you are only writing code to run on an OS and filesystem that does implement append mode correctly (a local filesystem on a modern Unix for example), and you keep the file in block-buffered mode and you write less than one buffer-full of output between each manual flushing of the buffer then each bufferload is almost guaranteed to be written to the end of the file in one chunk without getting intermingled with anyone else's output. You can also use the &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; function which is simply a wrapper around your system's &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write(2)&lt;/a&gt;&lt;/code&gt; system call.</source>
          <target state="translated">如果您知道您只是在编写可以在正确实现附加模式的操作系统和文件系统上运行的代码（例如，在现代Unix上为本地文件系统），并且将文件保持在块缓冲模式下，并且编写的缓冲区少于一个-在每次手动刷新缓冲区之间都充满了输出，然后几乎可以保证将每个bufferload以一个块的形式写入文件的末尾，而不会与其他任何人的输出混合在一起。您还可以使用 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 函数，该函数只是系统的 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write(2)&lt;/a&gt;&lt;/code&gt; 系统调用的包装器。</target>
        </trans-unit>
        <trans-unit id="01c8e667e3ed1b51f8f2d44670f827394972704b" translate="yes" xml:space="preserve">
          <source>If you know your package, you can just mention it explicitly, as in $Some_Pack::var. Note that the notation $::var is &lt;b&gt;not&lt;/b&gt; the dynamic $var in the current package, but rather the one in the &quot;main&quot; package, as though you had written $main::var.</source>
          <target state="translated">如果您知道您的软件包，则可以像$ Some_Pack :: var一样明确地提及它。请注意，符号$ :: var &lt;b&gt;不是&lt;/b&gt;当前程序包中的动态$ var，而是&amp;ldquo; main&amp;rdquo;程序包中的动态$ var，就像您已编写$ main :: var一样。</target>
        </trans-unit>
        <trans-unit id="283a4b9fbff3cde02d8b49d7e007e0e9915125fc" translate="yes" xml:space="preserve">
          <source>If you like a more web-like approach, a good start point can be &lt;a href=&quot;http://www14.software.ibm.com/webapp/download/downloadaz.jsp&quot;&gt;http://www14.software.ibm.com/webapp/download/downloadaz.jsp&lt;/a&gt; and click &quot;C for AIX&quot;, and follow the instructions.</source>
          <target state="translated">如果您喜欢一种更像Web的方法，那么可以从&lt;a href=&quot;http://www14.software.ibm.com/webapp/download/downloadaz.jsp&quot;&gt;http://www14.software.ibm.com/webapp/download/downloadaz.jsp&lt;/a&gt;开始，然后单击&amp;ldquo; C for AIX&amp;rdquo;，然后按照说明进行操作。</target>
        </trans-unit>
        <trans-unit id="b95d71103315a260f526ee0388cdf401d8ff3b71" translate="yes" xml:space="preserve">
          <source>If you like the &lt;code&gt;prove&lt;/code&gt; utility and &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; but you want your own harness, all you need to do is write one and provide &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;runtests&lt;/code&gt; methods. Then you can use the &lt;code&gt;prove&lt;/code&gt; utility like so:</source>
          <target state="translated">如果你喜欢 &lt;code&gt;prove&lt;/code&gt; 效用和&lt;a href=&quot;parser&quot;&gt;TAP ::分析器&lt;/a&gt;但你想你自己的安全带，所有你需要做的是写一个，并提供 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;runtests&lt;/code&gt; 方法。然后，您可以像这样使用 &lt;code&gt;prove&lt;/code&gt; 工具：</target>
        </trans-unit>
        <trans-unit id="fbd3ba27ff3a08207feb966e075b2fa08e7cf809" translate="yes" xml:space="preserve">
          <source>If you like, you can store these filehandles in an array or a hash. If you access them directly, they aren't simple scalars and you need to give &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; a little help by placing the filehandle reference in braces. Perl can only figure it out on its own when the filehandle reference is a simple scalar.</source>
          <target state="translated">如果愿意，可以将这些文件句柄存储在数组或哈希中。如果直接访问它们，它们不是简单的标量，您需要通过将文件句柄引用放在花括号中来给 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 一点帮助。当文件句柄引用是简单的标量时，Perl只能自行解决。</target>
        </trans-unit>
        <trans-unit id="d730d69794a1a0d8df4bc0eb2edfe8040f78af15" translate="yes" xml:space="preserve">
          <source>If you localize a special variable, you'll be giving a new value to it, but its magic won't go away. That means that all side-effects related to this magic still work with the localized value.</source>
          <target state="translated">如果你本地化一个特殊变量,你会给它一个新的值,但它的魔力不会消失。这意味着与这个魔法有关的所有副作用仍然会对这个本地化的值起作用。</target>
        </trans-unit>
        <trans-unit id="c90f343f24019c1da72c48d70c317941a7498b61" translate="yes" xml:space="preserve">
          <source>If you localize an exported variable in a module, its exported value will not change. The local name becomes an alias to a new value but the external name is still an alias for the original.</source>
          <target state="translated">如果您在一个模块中本地化了一个导出的变量,那么它的导出值不会改变。本地名称变成了一个新值的别名,但外部名称仍然是原始值的别名。</target>
        </trans-unit>
        <trans-unit id="dafcf35a82f601b489cfb5dd0eef86e45cb1372b" translate="yes" xml:space="preserve">
          <source>If you look at its source, you'll see that open2() uses low-level primitives like the pipe() and exec() syscalls to create all the connections. Although it might have been more efficient by using socketpair(), this would have been even less portable than it already is. The open2() and open3() functions are unlikely to work anywhere except on a Unix system, or at least one purporting POSIX compliance.</source>
          <target state="translated">如果你看一下它的源码,你会发现open2()使用了低级的基元,比如pipe()和exec()syscalls来创建所有的连接。虽然使用socketpair()可能会更有效率,但这将比现在的可移植性更差。open2()和open3()函数不可能在任何地方工作,除非是在Unix系统上,或者至少是在一个声称符合POSIX的系统上。</target>
        </trans-unit>
        <trans-unit id="dba57ac6d2e87e59b7cd30bc2efe7662859d4f78" translate="yes" xml:space="preserve">
          <source>If you look at the contents of a database file created by DB_File, there can sometimes be part of a Perl script included in it.</source>
          <target state="translated">如果你查看DB_File创建的数据库文件的内容,有时会有一部分Perl脚本包含在其中。</target>
        </trans-unit>
        <trans-unit id="6e077c0b0a12316fa45027aa958a68eefe5eb38b" translate="yes" xml:space="preserve">
          <source>If you make use of the Berkeley DB API, it is</source>
          <target state="translated">如果你使用Berkeley DB API,那么它就是</target>
        </trans-unit>
        <trans-unit id="044615c04770ac7a0002f5e8d4d8dd2908b76278" translate="yes" xml:space="preserve">
          <source>If you may assume POSIX (a rather large assumption), you may read more about the POSIX locale system from &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;. The locale system at least attempts to make things a little bit more portable, or at least more convenient and native-friendly for non-English users. The system affects character sets and encoding, and date and time formatting--amongst other things.</source>
          <target state="translated">如果您假设使用POSIX（相当大的假设），则可以从&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;阅读有关POSIX语言环境系统的更多信息。区域设置系统至少尝试使事情变得更便携一些，或者至少对于非英语用户来说更加方便和本机友好。该系统会影响字符集和编码以及日期和时间格式等。</target>
        </trans-unit>
        <trans-unit id="a25944da5356d5910252ea9238bbb196b425ee18" translate="yes" xml:space="preserve">
          <source>If you memoize &lt;code&gt;getusers&lt;/code&gt; here, it will work right exactly once. The reference to the users list will be stored in the memo table. &lt;code&gt;main&lt;/code&gt; will discard the first element from the referenced list. The next time you invoke &lt;code&gt;main&lt;/code&gt; , &lt;code&gt;Memoize&lt;/code&gt; will not call &lt;code&gt;getusers&lt;/code&gt; ; it will just return the same reference to the same list it got last time. But this time the list has already had its head removed; &lt;code&gt;main&lt;/code&gt; will erroneously remove another element from it. The list will get shorter and shorter every time you call &lt;code&gt;main&lt;/code&gt; .</source>
          <target state="translated">如果您在此处记住 &lt;code&gt;getusers&lt;/code&gt; ，它将只正确运行一次。对用户列表的引用将存储在备忘录表中。 &lt;code&gt;main&lt;/code&gt; 将丢弃引用列表中的第一个元素。下次调用 &lt;code&gt;main&lt;/code&gt; 时， &lt;code&gt;Memoize&lt;/code&gt; 将不会调用 &lt;code&gt;getusers&lt;/code&gt; ；它只会将相同的引用返回到上一次获得的相同列表。但是这次，名单已经被删除了。 &lt;code&gt;main&lt;/code&gt; 会错误地从其中删除另一个元素。每次您调用 &lt;code&gt;main&lt;/code&gt; 时，列表将越来越短。</target>
        </trans-unit>
        <trans-unit id="babf77ebcd09b5b6b24f3181921a88c6ea58626a" translate="yes" xml:space="preserve">
          <source>If you need a copy of the string, see &lt;a href=&quot;#bytes_from_utf8&quot;&gt;bytes_from_utf8&lt;/a&gt;.</source>
          <target state="translated">如果需要字符串的副本，请参见&lt;a href=&quot;#bytes_from_utf8&quot;&gt;bytes_from_utf8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e5f94b7a22fe122cef06ac242e6fea05a7455fe1" translate="yes" xml:space="preserve">
          <source>If you need a notation that's that powerful, use normal Perl:</source>
          <target state="translated">如果你需要一个这么强大的符号,就用普通的Perl。</target>
        </trans-unit>
        <trans-unit id="d3c247b2226d86ce39340fe5128412de0478e397" translate="yes" xml:space="preserve">
          <source>If you need an empty attribute list, for example in a code generator, add a space before the &lt;code&gt;=&lt;/code&gt; .</source>
          <target state="translated">如果您需要一个空的属性列表（例如在代码生成器中），请在 &lt;code&gt;=&lt;/code&gt; 之前添加一个空格。</target>
        </trans-unit>
        <trans-unit id="82f75e54b3d41cd48a9f47dcdc6a65f36e63ccd0" translate="yes" xml:space="preserve">
          <source>If you need more advanced management of what runs in parallel vs in sequence, see the associated 'rules' documentation in &lt;a href=&quot;tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; and &lt;a href=&quot;tap/parser/scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;. If what's possible directly through &lt;code&gt;prove&lt;/code&gt; is not sufficient, you can write your own harness to access these features directly.</source>
          <target state="translated">如果您需要对并行运行和顺序运行进行更高级的管理，请参阅&lt;a href=&quot;tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt;和&lt;a href=&quot;tap/parser/scheduler&quot;&gt;TAP :: Parser :: Scheduler中&lt;/a&gt;的相关&amp;ldquo;规则&amp;rdquo;文档。如果直接通过 &lt;code&gt;prove&lt;/code&gt; 功能还不够，您可以编写自己的工具来直接访问这些功能。</target>
        </trans-unit>
        <trans-unit id="bcc2262a79a5dbdf9359e3765fbc56f15e34b33f" translate="yes" xml:space="preserve">
          <source>If you need more fine-grained control over shared variable access, see &lt;a href=&quot;../thread/semaphore&quot;&gt;Thread::Semaphore&lt;/a&gt;.</source>
          <target state="translated">如果您需要对共享变量访问进行更细粒度的控制，请参见&lt;a href=&quot;../thread/semaphore&quot;&gt;Thread :: Semaphore&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06a1402305f2d5c348929119dfbe7d1b16bea038" translate="yes" xml:space="preserve">
          <source>If you need more memory (larger data segment) for your Perl programs you can set:</source>
          <target state="translated">如果你的Perl程序需要更多的内存(更大的数据段),你可以设置。</target>
        </trans-unit>
        <trans-unit id="a733f66f7ebcddfc5bced382948b822560f8102b" translate="yes" xml:space="preserve">
          <source>If you need non-ASCII characters in your source code, make it a UTF-8 encoded file and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; .</source>
          <target state="translated">如果您的源代码中需要非ASCII字符，请使其成为UTF-8编码文件，然后 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de2791275bc33103874a494cba3668a34d497a88" translate="yes" xml:space="preserve">
          <source>If you need not it (say, in the case when you need not handle any combining characters), assign &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; explicitly.</source>
          <target state="translated">如果不需要（例如，在不需要处理任何组合字符的情况下），则显式分配 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d24eea4a069716d3cfb8ce322b04914e0b52151" translate="yes" xml:space="preserve">
          <source>If you need something like this functionality, you should use the &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; pragma, which is also deprecated, but has fewer nasty side effects.</source>
          <target state="translated">如果您需要类似此功能的内容，则应使用&lt;a href=&quot;encoding&quot;&gt;编码&lt;/a&gt;用法，该方法也已弃用，但副作用较少。</target>
        </trans-unit>
        <trans-unit id="74399fe1ce7a1f4f506a06b60ded39ec27cea334" translate="yes" xml:space="preserve">
          <source>If you need something much more sophisticated and controllable, Leon Brocard's &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::ebug&quot;&gt;Devel::ebug&lt;/a&gt; (which you can call with the &lt;code&gt;-D&lt;/code&gt; switch as &lt;code&gt;-Debug&lt;/code&gt; ) gives you the programmatic hooks into everything you need to write your own (without too much pain and suffering).</source>
          <target state="translated">如果你需要一些更复杂的，可控的，莱昂Brocard的&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::ebug&quot;&gt;杰韦利:: ebug&lt;/a&gt;（可以与呼叫 &lt;code&gt;-D&lt;/code&gt; 交换机 &lt;code&gt;-Debug&lt;/code&gt; ）为您提供了纲领性钩到你需要将所有内容写你自己的（没有太多的痛苦和折磨）。</target>
        </trans-unit>
        <trans-unit id="77f3f2631a368e380813c177575d4bf78bb0f7fd" translate="yes" xml:space="preserve">
          <source>If you need the string representation of a character that doesn't have a mnemonic name in C, you should add it to the list in</source>
          <target state="translated">如果你需要一个在C语言中没有记忆名的字符的字符串表示,你应该在</target>
        </trans-unit>
        <trans-unit id="c2b8ba636abce4657c8c0f922660904cfc7228c1" translate="yes" xml:space="preserve">
          <source>If you need to be able to read a block which has an exact size, you can use the function &lt;code&gt;filter_read_exact&lt;/code&gt; . It works identically to &lt;code&gt;filter_read&lt;/code&gt; in block mode, except it will try to read a block which is exactly &lt;code&gt;$size&lt;/code&gt; bytes in length. The only circumstances when it will not return a block which is &lt;code&gt;$size&lt;/code&gt; bytes long is on EOF or error.</source>
          <target state="translated">如果您需要读取具有确切大小的块，则可以使用 &lt;code&gt;filter_read_exact&lt;/code&gt; 函数。它会与块模式下的 &lt;code&gt;filter_read&lt;/code&gt; 相同，除了它将尝试读取长度为 &lt;code&gt;$size&lt;/code&gt; 字节的块。它不会返回 &lt;code&gt;$size&lt;/code&gt; 为$ size个字节的块的唯一情况是在EOF或错误上。</target>
        </trans-unit>
        <trans-unit id="18a6ebad8222234ffca6c9871e53dc4619a2ca40" translate="yes" xml:space="preserve">
          <source>If you need to bless or re-bless an object you can use the following function:</source>
          <target state="translated">如果您需要对一个对象进行祝福或重新祝福,您可以使用以下功能。</target>
        </trans-unit>
        <trans-unit id="d70c6e2df233bb6ffd0181bcff94f18d3b389825" translate="yes" xml:space="preserve">
          <source>If you need to customize the objects on creation, subclass &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_grammar&quot;&gt;make_grammar&lt;/a&gt;</source>
          <target state="translated">如果需要在创建时自定义对象，请子类&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;并覆盖&lt;a href=&quot;#make_grammar&quot;&gt;make_grammar&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="28d9937fb82713ba1f2c783a5af6bd5ed96f1469" translate="yes" xml:space="preserve">
          <source>If you need to customize the objects on creation, subclass &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_result&quot;&gt;make_result&lt;/a&gt;.</source>
          <target state="translated">如果需要在创建时自定义对象，请子类&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;并覆盖&lt;a href=&quot;#make_result&quot;&gt;make_result&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9bf36336c456165d1f557c63d917cf367e24c8a2" translate="yes" xml:space="preserve">
          <source>If you need to distinguish between endian architectures you could use either of the variables set like so:</source>
          <target state="translated">如果你需要区分endian架构,你可以使用像这样设置的任一变量。</target>
        </trans-unit>
        <trans-unit id="a6c8b4493aa37d00a1808e45469530aac89fd5c8" translate="yes" xml:space="preserve">
          <source>If you need to do something more complicated, you can use &lt;a href=&quot;http://search.cpan.org/perldoc/LWP::UserAgent&quot;&gt;LWP::UserAgent&lt;/a&gt; module to create your own user-agent (e.g. browser) to get the job done. If you want to simulate an interactive web browser, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW::Mechanize&lt;/a&gt; module.</source>
          <target state="translated">如果您需要做一些更复杂的事情，可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/LWP::UserAgent&quot;&gt;LWP :: UserAgent&lt;/a&gt;模块创建自己的用户代理（例如浏览器）来完成工作。如果要模拟交互式Web浏览器，则可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW :: Mechanize&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="a7852e983dc45b1c4fb37cf3f05367219e6ca843" translate="yes" xml:space="preserve">
          <source>If you need to do this check often, define your own macro like this:</source>
          <target state="translated">如果你需要经常做这个检查,可以像这样定义自己的宏。</target>
        </trans-unit>
        <trans-unit id="6466ffd2aaaebc3946b351828c459bde58bed891" translate="yes" xml:space="preserve">
          <source>If you need to include C code or C library interfaces use h2xs. h2xs will create the module distribution structure and the initial interface files. &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; explain the details.</source>
          <target state="translated">如果需要包括C代码或C库接口，请使用h2xs。h2xs将创建模块分发结构和初始接口文件。&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;和&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;解释了细节。</target>
        </trans-unit>
        <trans-unit id="132d01927536564513220be940287f0a7e0711cd" translate="yes" xml:space="preserve">
          <source>If you need to make sure your diagnostics are displayed in the correct order relative to test results you can use the &lt;code&gt;--merge&lt;/code&gt; option to merge the test scripts' STDERR into their STDOUT.</source>
          <target state="translated">如果需要确保诊断以相对于测试结果的正确顺序显示，则可以使用 &lt;code&gt;--merge&lt;/code&gt; 选项将测试脚本的STDERR合并到其STDOUT中。</target>
        </trans-unit>
        <trans-unit id="f121bbe2a75e4529feda5970b07f0e59291a1000" translate="yes" xml:space="preserve">
          <source>If you need to pad with a character other than blank or zero you can use one of the following methods. They all generate a pad string with the &lt;code&gt;x&lt;/code&gt; operator and combine that with &lt;code&gt;$text&lt;/code&gt; . These methods do not truncate &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">如果您需要使用非空白或零以外的字符进行填充，则可以使用以下方法之一。它们都使用 &lt;code&gt;x&lt;/code&gt; 运算符生成一个填充字符串，并将其与 &lt;code&gt;$text&lt;/code&gt; 结合在一起。这些方法不会截断 &lt;code&gt;$text&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5db19b81a16545df9a2691c134fe238aff01db6b" translate="yes" xml:space="preserve">
          <source>If you need to pass the handle to something that expects a filename then on a unix system you can use C for arbitrary programs. Perl code that uses the 2-argument version of C&amp;lt;&amp;lt; open &amp;gt;&amp;gt; can be passed C&amp;lt;&amp;lt; &quot;+&amp;lt;=&amp;amp;&quot; . fileno($fh) &amp;gt;&amp;gt;. Otherwise you will need to pass the filename. You will have to clear the close-on-exec bit on that file descriptor before passing it to another process.</source>
          <target state="translated">如果需要将句柄传递给需要文件名的内容，则在Unix系统上，可以将C用于任意程序。可以将使用C &amp;lt;&amp;lt; open &amp;gt;&amp;gt;的2参数版本的Perl代码传递给C &amp;lt;&amp;lt;&amp;ldquo; + &amp;lt;=＆&amp;rdquo;。fileno（$ fh）&amp;gt;&amp;gt;。否则，您将需要传递文件名。您必须先清除该文件描述符上的close-on-exec位，然后再将其传递给另一个进程。</target>
        </trans-unit>
        <trans-unit id="a1479a86a7c4f92b2a893038ca84d0e7634155ed" translate="yes" xml:space="preserve">
          <source>If you need to perform any preprocessing of input before it is parsed you may want to override one or more of &lt;b&gt;preprocess_line()&lt;/b&gt; and/or &lt;b&gt;preprocess_paragraph()&lt;/b&gt;.</source>
          <target state="translated">如果您需要在解析输入之前执行任何预处理，则可能需要覆盖&lt;b&gt;preprocess_line（）&lt;/b&gt;和/或&lt;b&gt;preprocess_paragraph（）中的&lt;/b&gt;一个或多个。</target>
        </trans-unit>
        <trans-unit id="6fb6f27c51e4262718886f54bfa50ac616a6eb28" translate="yes" xml:space="preserve">
          <source>If you need to push multiple different values then you should either use the &lt;code&gt;(X)PUSHs&lt;/code&gt; macros, or else use the new &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; macros, none of which make use of &lt;code&gt;TARG&lt;/code&gt; . The &lt;code&gt;(X)PUSHs&lt;/code&gt; macros simply push an SV* on the stack, which, as noted under &lt;a href=&quot;#XSUBs-and-the-Argument-Stack&quot;&gt;XSUBs and the Argument Stack&lt;/a&gt;, will often need to be &quot;mortal&quot;. The new &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; macros make this a little easier to achieve by creating a new mortal for you (via &lt;code&gt;(X)PUSHmortal&lt;/code&gt;), pushing that onto the stack (extending it if necessary in the case of the &lt;code&gt;mXPUSH[iunp]&lt;/code&gt; macros), and then setting its value. Thus, instead of writing this to &quot;fix&quot; the example above:</source>
          <target state="translated">如果需要推入多个不同的值，则应该使用 &lt;code&gt;(X)PUSHs&lt;/code&gt; 宏，或者使用新的 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; 宏，这些宏都不使用 &lt;code&gt;TARG&lt;/code&gt; 。该 &lt;code&gt;(X)PUSHs&lt;/code&gt; 宏只需按下一个SV *栈，这下作为注意到&lt;a href=&quot;#XSUBs-and-the-Argument-Stack&quot;&gt;XSUBs和参数堆栈&lt;/a&gt;，将经常需要&amp;ldquo;凡间&amp;rdquo;。新的 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; 宏通过（通过 &lt;code&gt;(X)PUSHmortal&lt;/code&gt; ）为您创建一个新的凡人，将其推入堆栈（如果需要，在 &lt;code&gt;mXPUSH[iunp]&lt;/code&gt; 扩展，可以扩展），从而使实现起来更加容易iunp]宏），然后设置其值。因此，不是将其编写为&amp;ldquo;修复&amp;rdquo;上面的示例：</target>
        </trans-unit>
        <trans-unit id="b45e0c901cd619f7527093c4d9dc59b922de91c4" translate="yes" xml:space="preserve">
          <source>If you need to run code under taint mode, updating to the latest L&amp;lt;:spec&amp;gt; is highly recommended.</source>
          <target state="translated">如果需要在污点模式下运行代码，强烈建议更新为最新的L &amp;lt;：spec&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="0a26debdab35f4d9006770f7ff9dd97352bd60fc" translate="yes" xml:space="preserve">
          <source>If you need to set the encoding for STDIN, STDOUT, and STDERR, for example based on the user's locale, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">例如，如果需要基于用户的语言环境设置STDIN，STDOUT和STDERR的编码，请 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6d6ae28c61f9ab4be958ec28b43ea876d12f0ac" translate="yes" xml:space="preserve">
          <source>If you need to sort on several fields, the following paradigm is useful.</source>
          <target state="translated">如果你需要对多个字段进行排序,下面的范式是有用的。</target>
        </trans-unit>
        <trans-unit id="bcb30e833a46ba05085b508093073afbb52be3c6" translate="yes" xml:space="preserve">
          <source>If you need to use</source>
          <target state="translated">如果您需要使用</target>
        </trans-unit>
        <trans-unit id="dd52c7b44ac55aa77cc0e377ad21781b36b65218" translate="yes" xml:space="preserve">
          <source>If you need to use Perl in the ILE environment, you may want to consider using Qp2RunPase() to call the PASE version of Perl.</source>
          <target state="translated">如果你需要在ILE环境中使用Perl,你可以考虑使用Qp2RunPase()来调用Perl的PASE版本。</target>
        </trans-unit>
        <trans-unit id="b4808d5e77c37aaf035853f43eef1fd731c05497" translate="yes" xml:space="preserve">
          <source>If you need to, your program can pass parameters to the subroutine as part of the thread startup. Just include the list of parameters as part of the &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; call, like this:</source>
          <target state="translated">如果需要，您的程序可以在线程启动过程中将参数传递给子例程。只需将参数列表包含在 &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; 调用中即可，如下所示：</target>
        </trans-unit>
        <trans-unit id="1710a33b911c663eb696834835df2f1e23df21c3" translate="yes" xml:space="preserve">
          <source>If you needed to know the length of the string in bytes, now's the perfect time for that. Because &lt;code&gt;$body&lt;/code&gt; is now a byte string, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; will report the number of bytes, instead of the number of characters. The number of characters is no longer known, because characters only exist in text strings.</source>
          <target state="translated">如果您需要知道字符串的长度（以字节为单位），那么现在是最佳时机。因为 &lt;code&gt;$body&lt;/code&gt; 现在是一个字节字符串，所以 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 将报告字节数，而不是字符数。字符数不再已知，因为字符仅存在于文本字符串中。</target>
        </trans-unit>
        <trans-unit id="be13b7e49abdf9671c1c203318c86c5b390da880" translate="yes" xml:space="preserve">
          <source>If you now say</source>
          <target state="translated">如果你现在说</target>
        </trans-unit>
        <trans-unit id="4e07afe42e8e4906b74c8de7f97562b41c673c72" translate="yes" xml:space="preserve">
          <source>If you only have to do this once, you can print individually to each filehandle.</source>
          <target state="translated">如果您只需要做一次,您可以分别打印到每个文件柄。</target>
        </trans-unit>
        <trans-unit id="ef4f1155d60201a5a642377c105def023a28c8a3" translate="yes" xml:space="preserve">
          <source>If you open a pipe on the command &lt;code&gt;-&lt;/code&gt; (that is, specify either &lt;code&gt;|-&lt;/code&gt; or &lt;code&gt;-|&lt;/code&gt; with the one- or two-argument forms of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;), an implicit &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is done, so &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; returns twice: in the parent process it returns the pid of the child process, and in the child process it returns (a defined) &lt;code&gt;0&lt;/code&gt; . Use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;//&lt;/code&gt; to determine whether the open was successful.</source>
          <target state="translated">如果您在命令打开一个管道 &lt;code&gt;-&lt;/code&gt; （即中，指定 &lt;code&gt;|-&lt;/code&gt; 或者 &lt;code&gt;-|&lt;/code&gt; 用的一个或两个参数的形式 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ），一个隐含的 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 完成，所以 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 的回报两次：在父进程返回子进程的pid，并在子进程中返回（已定义） &lt;code&gt;0&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;//&lt;/code&gt; 确定打开是否成功。</target>
        </trans-unit>
        <trans-unit id="3ae4797a620c0cf454989f9d7b82f21950740479" translate="yes" xml:space="preserve">
          <source>If you open a pipe on the command &lt;code&gt;-&lt;/code&gt; (that is, specify either &lt;code&gt;|-&lt;/code&gt; or &lt;code&gt;-|&lt;/code&gt; with the one- or two-argument forms of &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;), an implicit &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is done, so &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; returns twice: in the parent process it returns the pid of the child process, and in the child process it returns (a defined) &lt;code&gt;0&lt;/code&gt; . Use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;//&lt;/code&gt; to determine whether the open was successful.</source>
          <target state="translated">如果您在命令打开一个管道 &lt;code&gt;-&lt;/code&gt; （即中，指定 &lt;code&gt;|-&lt;/code&gt; 或者 &lt;code&gt;-|&lt;/code&gt; 用的一个或两个参数的形式 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ），一个隐含的 &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 完成，所以 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 的回报两次：在父进程返回子进程的pid，并在子进程中返回（已定义） &lt;code&gt;0&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;//&lt;/code&gt; 确定打开是否成功。</target>
        </trans-unit>
        <trans-unit id="b60263df2e1568250aacc0155390b54bbc574b26" translate="yes" xml:space="preserve">
          <source>If you opted to uncomment &lt;code&gt;INST_VER&lt;/code&gt; and &lt;code&gt;INST_ARCH&lt;/code&gt; in the makefile then the installation structure is a little more complicated and you will need to add two new PATH components instead: &lt;code&gt;$INST_TOP\$INST_VER\bin&lt;/code&gt; and &lt;code&gt;$INST_TOP\$INST_VER\bin\$ARCHNAME&lt;/code&gt; , e.g.</source>
          <target state="translated">如果选择在makefile中取消注释 &lt;code&gt;INST_VER&lt;/code&gt; 和 &lt;code&gt;INST_ARCH&lt;/code&gt; ，则安装结构会稍微复杂一些，您需要添加两个新的PATH组件： &lt;code&gt;$INST_TOP\$INST_VER\bin&lt;/code&gt; 和 &lt;code&gt;$INST_TOP\$INST_VER\bin\$ARCHNAME&lt;/code&gt; ，例如</target>
        </trans-unit>
        <trans-unit id="3281995d9866c6fc2125672694920f44e26bcb98" translate="yes" xml:space="preserve">
          <source>If you override this method, it should never throw an exception.</source>
          <target state="translated">如果你覆盖了这个方法,它应该永远不会抛出异常。</target>
        </trans-unit>
        <trans-unit id="a202baf38183d44995c2fcf3449035cd37813ae8" translate="yes" xml:space="preserve">
          <source>If you pass a perl version you get the release date for that version only.</source>
          <target state="translated">如果你通过一个perl版本,你只得到该版本的发布日期。</target>
        </trans-unit>
        <trans-unit id="1538bf7a76ecb948f65bf6e3cd597e0fef6beddd" translate="yes" xml:space="preserve">
          <source>If you pass a version argument (value of &lt;code&gt;$]&lt;/code&gt; , like &lt;code&gt;5.00503&lt;/code&gt; or &lt;code&gt;5.008008&lt;/code&gt; ), you get a list of all the modules and their respective versions. (If you have the &lt;code&gt;version&lt;/code&gt; module, you can also use new-style version numbers, like &lt;code&gt;5.8.8&lt;/code&gt; .)</source>
          <target state="translated">如果传递版本参数（值 &lt;code&gt;$]&lt;/code&gt; ，如 &lt;code&gt;5.00503&lt;/code&gt; 或 &lt;code&gt;5.008008&lt;/code&gt; ，则将获得所有模块及其各自版本的列表。（如果您具有 &lt;code&gt;version&lt;/code&gt; 模块，则还可以使用新的版本号，例如 &lt;code&gt;5.8.8&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="93bac64f7444e2412e1719cee4ee931ff2c82b7b" translate="yes" xml:space="preserve">
          <source>If you pass the &lt;code&gt;-q&lt;/code&gt; option to the module, then the STDOUT filehandle will be redirected into the variable &lt;code&gt;$O::BEGIN_output&lt;/code&gt; during compilation. This has the effect that any output printed to STDOUT by BEGIN blocks or use'd modules will be stored in this variable rather than printed. It's useful with those backends which produce output themselves (&lt;code&gt;Deparse&lt;/code&gt; , &lt;code&gt;Concise&lt;/code&gt; etc), so that their output is not confused with that generated by the code being compiled.</source>
          <target state="translated">如果将 &lt;code&gt;-q&lt;/code&gt; 选项传递给模块，则STDOUT文件句柄将在编译期间重定向到变量 &lt;code&gt;$O::BEGIN_output&lt;/code&gt; 中。这样的结果是，任何由BEGIN块或使用的模块打印到STDOUT的输出都将存储在此变量中，而不是打印出来。对于那些自己产生输出的后端（ &lt;code&gt;Deparse&lt;/code&gt; ， &lt;code&gt;Concise&lt;/code&gt; 等）很有用，这样它们的输出就不会与正在编译的代码所产生的输出相混淆。</target>
        </trans-unit>
        <trans-unit id="eb6ebb2e5d7084d0bbbc51b71dbc71d3b131a896" translate="yes" xml:space="preserve">
          <source>If you perform a new installation, then (a newer) Perl will be installed automatically. Pre-installed HP-UX systems now have more recent versions of Perl and the updated modules.</source>
          <target state="translated">如果你进行新的安装,那么(较新的)Perl将被自动安装。预装的HP-UX系统现在有较新版本的Perl和更新的模块。</target>
        </trans-unit>
        <trans-unit id="3e9cb6c101da46aadecf5f8c5c109de4412a1005" translate="yes" xml:space="preserve">
          <source>If you pick the right test function, you'll usually get a good idea of what went wrong when it failed. But sometimes it doesn't work out that way. So here we have ways for you to write your own diagnostic messages which are safer than just &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; STDERR&lt;/code&gt; .</source>
          <target state="translated">如果选择正确的测试功能，通常会很好地了解失败的地方。但是有时候，这种方式行不通。因此，在这里我们有多种方法可以让您编写自己的诊断消息，而不仅仅是 &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; STDERR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1f8c3042df990d0caf7e15fec6410a8229928ec" translate="yes" xml:space="preserve">
          <source>If you plan on doing serious C hacking, make sure to read this.</source>
          <target state="translated">如果你打算做严肃的C语言黑客,一定要阅读这个。</target>
        </trans-unit>
        <trans-unit id="ea674be45f6eda0998926e34d1adb1941baadfc8" translate="yes" xml:space="preserve">
          <source>If you plan to link Perl to any module that requires thread-support, like DBD::Oracle, it is better to use the _r version of the compiler. This will not build a threaded Perl, but a thread-enabled Perl. See also &lt;a href=&quot;#Threaded-Perl&quot;&gt;Threaded Perl&lt;/a&gt; later on.</source>
          <target state="translated">如果您打算将Perl链接到任何需要线程支持的模块，例如DBD :: Oracle，最好使用_r版本的编译器。这将不会构建线程化的Perl，而是构建启用线程的Perl。稍后也请参见&lt;a href=&quot;#Threaded-Perl&quot;&gt;Threaded Perl&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a59862b4b635be40786928d6e580b97f5fccb229" translate="yes" xml:space="preserve">
          <source>If you prefer 'regex' over 'regexp' in this tutorial, you could use the following program to replace it:</source>
          <target state="translated">如果你在本教程中喜欢 &quot;regex &quot;而不是 &quot;regexp&quot;,你可以用下面的程序来代替它。</target>
        </trans-unit>
        <trans-unit id="e975a86edf7cf3f2a85267ea19c5e7fb97348443" translate="yes" xml:space="preserve">
          <source>If you prefer &lt;code&gt;CPANPLUS&lt;/code&gt; , it's just as easy:</source>
          <target state="translated">如果您更喜欢 &lt;code&gt;CPANPLUS&lt;/code&gt; ，那就很简单：</target>
        </trans-unit>
        <trans-unit id="88b2286238e8c1ea0536c07d5d33ab84bc86bbaa" translate="yes" xml:space="preserve">
          <source>If you prefer not to import these routines into your namespace, you can call them as:</source>
          <target state="translated">如果你不想把这些例程导入到你的命名空间,你可以把它们调用为。</target>
        </trans-unit>
        <trans-unit id="02b429d0fbb0524681e65be7d6f8ab7830a0723a" translate="yes" xml:space="preserve">
          <source>If you prefer something more legible, use the File::stat module (part of the standard distribution in version 5.004 and later):</source>
          <target state="translated">如果你喜欢更清晰的东西,可以使用File::stat模块(5.004和更高版本的标准发行版的一部分)。</target>
        </trans-unit>
        <trans-unit id="f0813e4f27c28bf6e883076eecebd37913fd5b51" translate="yes" xml:space="preserve">
          <source>If you prefer to do it more in a programmerish style in one single process, something like this may better suit you:</source>
          <target state="translated">如果你更喜欢以程序员的风格在一个过程中完成,这样的东西可能更适合你。</target>
        </trans-unit>
        <trans-unit id="ec90d5c6994006bb5fd89f190c78b5cdc340ee30" translate="yes" xml:space="preserve">
          <source>If you prefer to run your program first and look at its problem afterwards, do this:</source>
          <target state="translated">如果你喜欢先运行程序,然后再看它的问题,可以这样做。</target>
        </trans-unit>
        <trans-unit id="3870b14accf24c65cf812dc3594ebf250f4f78e6" translate="yes" xml:space="preserve">
          <source>If you properly encode your strings for output, none of this is of your concern, and you can just &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; dumped data as always.</source>
          <target state="translated">如果您对输出的字符串进行了适当的编码，那么您就 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 担心这些了，您可以像往常一样评估转储的数据。</target>
        </trans-unit>
        <trans-unit id="065fd2bf37d0cb46e6971e495f8f9b0d94012ccb" translate="yes" xml:space="preserve">
          <source>If you provide a $name, that will be printed along with the &quot;ok/not ok&quot; to make it easier to find your test when if fails (just search for the name). It also makes it easier for the next guy to understand what your test is for. It's highly recommended you use test names.</source>
          <target state="translated">如果你提供了一个$name,那就会和 &quot;ok/not ok &quot;一起打印出来,以便在失败的时候更容易找到你的测试(只要搜索这个名字)。这也让下一个人更容易理解你的测试是为了什么。强烈建议你使用测试名称。</target>
        </trans-unit>
        <trans-unit id="b7880cf2049cee53a05bb2b9ece1c4d6f2c66f65" translate="yes" xml:space="preserve">
          <source>If you put a &lt;code&gt;\&lt;/code&gt; in front of a variable, you get a reference to that variable.</source>
          <target state="translated">如果在变量前面加上 &lt;code&gt;\&lt;/code&gt; ，则会得到对该变量的引用。</target>
        </trans-unit>
        <trans-unit id="34b57973357474bb06b6216c6a1396c52f47b8be" translate="yes" xml:space="preserve">
          <source>If you put extensions in unusual places, you can set PERL5LIB to a list of paths separated by semicolons where you want perl to look for libraries. Look for descriptions of other environment variables you can set in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">如果将扩展名放在不寻常的位置，则可以将PERL5LIB设置为由分号分隔的路径列表，在该路径中您希望perl查找库。查找可以在&lt;a href=&quot;perlrun&quot;&gt;perlrun中&lt;/a&gt;设置的其他环境变量的描述。</target>
        </trans-unit>
        <trans-unit id="4498166e1dac5738a547d2b9e86da7f11d00c4e8" translate="yes" xml:space="preserve">
          <source>If you put two contiguous tilde characters &quot;~~&quot; anywhere into a line, the line will be repeated until all the fields on the line are exhausted, i.e. undefined. For special (caret) text fields this will occur sooner or later, but if you use a text field of the at variety, the expression you supply had better not give the same value every time forever! (&lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@f)&lt;/a&gt;&lt;/code&gt; is a simple example that would work.) Don't use a regular (at) numeric field in such lines, because it will never go blank.</source>
          <target state="translated">如果将两个连续的波浪号&amp;ldquo; ~~&amp;rdquo;放置在一行中的任何位置，则该行将重复进行，直到该行上的所有字段都用尽，即未定义。对于特殊的（插入符号）文本字段，迟早会出现这种情况，但是如果您使用at变体的文本字段，则提供的表达式最好不要每次都给出相同的值！（ &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@f)&lt;/a&gt;&lt;/code&gt; 是一个简单的示例，可以使用。）不要在此类行中使用常规的（at）数字字段，因为它永远不会为空。</target>
        </trans-unit>
        <trans-unit id="a6608312c76270dd048459022213c207db61db43" translate="yes" xml:space="preserve">
          <source>If you really do mean it, explicitly numify your reference, like so: &lt;code&gt;$array[0+$ref]&lt;/code&gt; . This warning is not given for overloaded objects, however, because you can overload the numification and stringification operators and then you presumably know what you are doing.</source>
          <target state="translated">如果确实如此，请显式地将您的引用数字化，例如： &lt;code&gt;$array[0+$ref]&lt;/code&gt; 。但是，不会为重载对象发出此警告，因为您可以重载numification和stringification运算符，然后大概知道自己在做什么。</target>
        </trans-unit>
        <trans-unit id="2e6ee3c0e5f77f2901d0e16f7c2a62b5dc496ad9" translate="yes" xml:space="preserve">
          <source>If you really need to see whether the change has been accepted simply examine the return value of C</source>
          <target state="translated">如果你真的需要查看更改是否被接受,只需检查C的返回值。</target>
        </trans-unit>
        <trans-unit id="dd150284dfc14b1b33a794d882418a56b32b28b6" translate="yes" xml:space="preserve">
          <source>If you really want a subroutine with a &lt;code&gt;()&lt;/code&gt; prototype that returns a lexical variable you can easily force it to not be inlined by adding an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">如果您确实想要带有 &lt;code&gt;()&lt;/code&gt; 原型的子例程返回一个词法变量，则可以通过添加显式 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 来轻松地使其不被内联：</target>
        </trans-unit>
        <trans-unit id="f0166a5725d2770573e3a305750b9dd3edf5c05f" translate="yes" xml:space="preserve">
          <source>If you really want comments, build your list the old-fashioned way, with quotes and commas:</source>
          <target state="translated">如果你真的想要评论,就用老式的方式建立你的列表,用引号和逗号。</target>
        </trans-unit>
        <trans-unit id="eb99b666d9e169ba81737784680da343f375dd69" translate="yes" xml:space="preserve">
          <source>If you really want just plain byte strings, use my_snprintf() and my_vsnprintf() instead, which will try to use snprintf() and vsnprintf() if those safer APIs are available. If you want something fancier than a plain byte string, use &lt;a href=&quot;perlapi#form&quot;&gt;Perl_form ()&lt;/a&gt; or SVs and &lt;a href=&quot;perlapi#sv_catpvf&quot;&gt;Perl_sv_catpvf() &lt;/a&gt;.</source>
          <target state="translated">如果您确实只需要纯字节字符串，请改用my_snprintf（）和my_vsnprintf（），如果可以使用那些更安全的API，它们将尝试使用snprintf（）和vsnprintf（）。如果您想要一个比普通字节字符串更好的东西，请使用&lt;a href=&quot;perlapi#form&quot;&gt;Perl_form（）&lt;/a&gt;或&lt;a href=&quot;perlapi#sv_catpvf&quot;&gt;SVs&lt;/a&gt;和Perl_sv_catpvf（）。</target>
        </trans-unit>
        <trans-unit id="1c2d9e52e0617d90849665511b4fb2b333643750" translate="yes" xml:space="preserve">
          <source>If you really want to be international, you should consider Unicode. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for more information.</source>
          <target state="translated">如果您真的想成为国际用户，则应考虑使用Unicode。有关更多信息，请参见&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;和&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a1586770541996a5a05c7da504fe6b4a6bdef4c" translate="yes" xml:space="preserve">
          <source>If you really want to do this, you can use &lt;code&gt;ExtUtils::Manifest::manifind()&lt;/code&gt; to read the MANIFEST and File::Find to delete the files. But you have to be careful. Here's a script to do that. Use at your own risk. Have fun blowing holes in your foot.</source>
          <target state="translated">如果确实要执行此操作，则可以使用 &lt;code&gt;ExtUtils::Manifest::manifind()&lt;/code&gt; 读取MANIFEST，然后使用File :: Find删除文件。但是您必须要小心。这是执行此操作的脚本。使用风险自负。祝您脚下有洞。</target>
        </trans-unit>
        <trans-unit id="bd0128791efed65e3bbb8d082044be49dfce046e" translate="yes" xml:space="preserve">
          <source>If you really want to, you can use the standard open2() from the &lt;code&gt;IPC::Open2&lt;/code&gt; module to catch both ends. There's also an open3() in &lt;code&gt;IPC::Open3&lt;/code&gt; for tridirectional I/O so you can also catch your child's STDERR, but doing so would then require an awkward select() loop and wouldn't allow you to use normal Perl input operations.</source>
          <target state="translated">如果确实需要，可以使用 &lt;code&gt;IPC::Open2&lt;/code&gt; 模块中的标准open2（）捕获两端。 &lt;code&gt;IPC::Open3&lt;/code&gt; 还有一个用于三向I / O 的open3（），因此您还可以捕获孩子的STDERR，但是这样做将需要笨拙的select（）循环，并且将不允许您使用常规的Perl输入操作。</target>
        </trans-unit>
        <trans-unit id="53be29d9aa606768bcbe9e3309afe9ba5b57da03" translate="yes" xml:space="preserve">
          <source>If you recognized the quote about the Road above, you're in luck.</source>
          <target state="translated">如果你认出了上面关于 &quot;路 &quot;的名言,那么你很幸运。</target>
        </trans-unit>
        <trans-unit id="39a2ad311b79ed3072c37af199bf41f9f9aebf15" translate="yes" xml:space="preserve">
          <source>If you redefine a subroutine that was eligible for inlining, you'll get a warning by default. You can use this warning to tell whether or not a particular subroutine is considered inlinable, since it's different than the warning for overriding non-inlined subroutines:</source>
          <target state="translated">如果你重新定义了一个符合内联条件的子程序,你会默认得到一个警告。你可以用这个警告来判断一个特定的子程序是否被认为是可以内联的,因为它与覆盖非内联子程序的警告不同。</target>
        </trans-unit>
        <trans-unit id="432e76406abd8db96136b5a2df1a568bbdde9d3f" translate="yes" xml:space="preserve">
          <source>If you resize the array with deferred writing enabled, the file will be resized immediately, but deferred records will not be written. This has a surprising consequence: &lt;code&gt;@a = (...)&lt;/code&gt; erases the file immediately, but the writing of the actual data is deferred. This might be a bug. If it is a bug, it will be fixed in a future version.</source>
          <target state="translated">如果在启用延迟写入的情况下调整数组大小，则将立即调整文件大小，但不会写入延迟记录。这产生了令人惊讶的结果： &lt;code&gt;@a = (...)&lt;/code&gt; 立即删除了文件，但是实际数据的写入被推迟了。这可能是一个错误。如果是错误，它将在将来的版本中修复。</target>
        </trans-unit>
        <trans-unit id="b95da308b81d0840cacd6821e3c3f91e04b82e8a" translate="yes" xml:space="preserve">
          <source>If you run Perl with the &lt;b&gt;-w&lt;/b&gt; switch it can warn you about this. For example, the third line above produces:</source>
          <target state="translated">如果使用&lt;b&gt;-w&lt;/b&gt;开关运行Perl，它可能会警告您。例如，上面的第三行产生：</target>
        </trans-unit>
        <trans-unit id="1983e4f73a942cb1a7c7741631cd3c3e344c8e03" translate="yes" xml:space="preserve">
          <source>If you run the script with the &lt;code&gt;-w&lt;/code&gt; flag the error message becomes:</source>
          <target state="translated">如果使用 &lt;code&gt;-w&lt;/code&gt; 标志运行脚本，则错误消息将变为：</target>
        </trans-unit>
        <trans-unit id="a9ad6a9bb0a2be45f4030cad900647a4bc2c1db1" translate="yes" xml:space="preserve">
          <source>If you run this code twice, the contents of the</source>
          <target state="translated">如果你运行这段代码两次,则在</target>
        </trans-unit>
        <trans-unit id="80dfce6f2a878c8f488ddf11e051d8fa78b7f75e" translate="yes" xml:space="preserve">
          <source>If you run your program with the &lt;code&gt;-w&lt;/code&gt; switch, or if you use the &lt;code&gt;warnings&lt;/code&gt; pragma, File::Find will report warnings for several weird situations. You can disable these warnings by putting the statement</source>
          <target state="translated">如果使用 &lt;code&gt;-w&lt;/code&gt; 开关运行程序，或者使用 &lt;code&gt;warnings&lt;/code&gt; 编译指示，则File :: Find将报告几种奇怪情况的警告。您可以通过放置以下语句来禁用这些警告</target>
        </trans-unit>
        <trans-unit id="84e83e7869cb30f17fc9ab2b3dafef8f917abf86" translate="yes" xml:space="preserve">
          <source>If you say yes to the following question, CPAN will try to store enough information about the build process so that it can pick up in future sessions at the same state of affairs as it left a previous session.</source>
          <target state="translated">如果你对下面的问题说 &quot;是&quot;,CPAN将尝试存储足够的关于构建过程的信息,以便在未来的会话中能够以离开前一个会话时的状态进行接收。</target>
        </trans-unit>
        <trans-unit id="3a116108872049154f6c27d6353e551d6d6917b4" translate="yes" xml:space="preserve">
          <source>If you see &quot;bad interpreter - no such file or directory&quot;, the first line in your perl script (the &quot;shebang&quot; line) does not contain the right path to perl (or any other program capable of running scripts). Sometimes this happens when you move the script from one machine to another and each machine has a different path to perl--/usr/bin/perl versus /usr/local/bin/perl for instance. It may also indicate that the source machine has CRLF line terminators and the destination machine has LF only: the shell tries to find /usr/bin/perl&amp;lt;CR&amp;gt;, but can't.</source>
          <target state="translated">如果看到&amp;ldquo;错误的解释器-没有这样的文件或目录&amp;rdquo;，则perl脚本中的第一行（&amp;ldquo; shebang&amp;rdquo;行）不包含指向perl（或任何其他能够运行脚本的程序）的正确路径。有时，当您将脚本从一台机器移动到另一台机器时，每台机器都有不同的perl路径-例如，/ usr / bin / perl与/ usr / local / bin / perl相对。它还可能表明源计算机具有CRLF行终止符，而目标计算机仅具有LF：shell尝试查找/ usr / bin / perl &amp;lt;CR&amp;gt;，但是找不到。</target>
        </trans-unit>
        <trans-unit id="2f85a9726440183decd897c1fff5988cce63ccf9" translate="yes" xml:space="preserve">
          <source>If you see &quot;bad interpreter: Permission denied&quot;, you need to make your script executable.</source>
          <target state="translated">如果你看到 &quot;bad interpreter.Permission denied&quot;,你需要让你的脚本可以执行。Permission denied&quot;,你需要让你的脚本可以执行。</target>
        </trans-unit>
        <trans-unit id="8de6b12e8e3d869536fad39850a1db08fd9bac7f" translate="yes" xml:space="preserve">
          <source>If you see in a debugger a memory area mysteriously full of 0xABABABAB or 0xEFEFEFEF, you may be seeing the effect of the Poison() macros, see &lt;a href=&quot;perlclib&quot;&gt;perlclib&lt;/a&gt;.</source>
          <target state="translated">如果在调试器中看到一个神秘的充满0xABABABAB或0xEFEFEFEF的内存区域，则可能是在看到Poison（）宏的作用，请参见&lt;a href=&quot;perlclib&quot;&gt;perlclib&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d3df616229a0ebfcb7922d24bec233001d332f4" translate="yes" xml:space="preserve">
          <source>If you see right after &quot;make&quot; this</source>
          <target state="translated">如果你在 &quot;制作 &quot;之后看到这个</target>
        </trans-unit>
        <trans-unit id="d8e7a131ddc6c256b7162ac7f1766e22fd038d65" translate="yes" xml:space="preserve">
          <source>If you see that you're leaking memory at runtime, but neither valgrind nor &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; will find anything, you're probably leaking SVs that are still reachable and will be properly cleaned up during destruction of the interpreter. In such cases, using the &lt;code&gt;-Dm&lt;/code&gt; switch can point you to the source of the leak. If the executable was built with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; , &lt;code&gt;-Dm&lt;/code&gt; will output SV allocations in addition to memory allocations. Each SV allocation has a distinct serial number that will be written on creation and destruction of the SV. So if you're executing the leaking code in a loop, you need to look for SVs that are created, but never destroyed between each cycle. If such an SV is found, set a conditional breakpoint within &lt;code&gt;new_SV()&lt;/code&gt; and make it break only when &lt;code&gt;PL_sv_serial&lt;/code&gt; is equal to the serial number of the leaking SV. Then you will catch the interpreter in exactly the state where the leaking SV is allocated, which is sufficient in many cases to find the source of the leak.</source>
          <target state="translated">如果看到运行时正在泄漏内存，但是valgrind和 &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; 都找不到任何内容，则可能是泄漏了仍可访问的SV，并且将在解释器销毁期间对其进行了适当的清理。在这种情况下，使用 &lt;code&gt;-Dm&lt;/code&gt; 开关可以将您指向泄漏源。如果可执行文件是使用 &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; 构建的，则 &lt;code&gt;-Dm&lt;/code&gt; 除了内存分配外，还将输出SV分配。每个SV分配都有一个不同的序列号，该序列号将在SV创建和销毁时写入。因此，如果要循环执行泄漏的代码，则需要查找已创建但从未在每个周期之间销毁的SV。如果找到了这样的SV，请在 &lt;code&gt;new_SV()&lt;/code&gt; 中设置一个条件断点，并使其仅在 &lt;code&gt;PL_sv_serial&lt;/code&gt; 等于泄漏的SV的序列号时才中断。然后，您将恰好在分配泄漏SV的状态下捕获解释器，这在许多情况下足以找到泄漏的来源。</target>
        </trans-unit>
        <trans-unit id="2bbf4110deb94dbc624ccee947cca19c596a9010" translate="yes" xml:space="preserve">
          <source>If you see this</source>
          <target state="translated">如果你看到这个</target>
        </trans-unit>
        <trans-unit id="4203dc6863ea2ff3c77a2428ddc46eaf1f7849d3" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;$DB::single&lt;/code&gt; to 2, it's equivalent to having just typed the &lt;code&gt;n&lt;/code&gt; command, whereas a value of 1 means the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; command. The &lt;code&gt;$DB::trace&lt;/code&gt; variable should be set to 1 to simulate having typed the &lt;code&gt;t&lt;/code&gt; command.</source>
          <target state="translated">如果将 &lt;code&gt;$DB::single&lt;/code&gt; 设置为 2，则等效于刚刚键入 &lt;code&gt;n&lt;/code&gt; 命令，而值1表示 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 命令。在 &lt;code&gt;$DB::trace&lt;/code&gt; 变量应设置为1，模拟输入具有的 &lt;code&gt;t&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="a5d30ba8967fd6c8924240ee40d5a140a986b280" translate="yes" xml:space="preserve">
          <source>If you set a value for this attribute, the value is expected to be an object (probably of a class that you define) that has a &lt;code&gt;reach&lt;/code&gt; method and a &lt;code&gt;done&lt;/code&gt; method. This is meant for reporting progress during the search, if you don't want to use a simple callback.</source>
          <target state="translated">如果为此属性设置一个值，则该值应该是一个具有 &lt;code&gt;reach&lt;/code&gt; 方法和 &lt;code&gt;done&lt;/code&gt; 方法的对象（可能是您定义的类）。如果您不想使用简单的回调，则用于报告搜索过程中的进度。</target>
        </trans-unit>
        <trans-unit id="bcde195e379d8e8445763e6616418aa0a7c91d66" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;parse_characters&lt;/code&gt; option to a true value the parser will expect characters rather than octets; will ignore any &lt;code&gt;=encoding&lt;/code&gt; ; and will make no attempt to decode the input.</source>
          <target state="translated">如果将 &lt;code&gt;parse_characters&lt;/code&gt; 选项设置为true，则解析器将使用字符而不是八位字节；否则，解析器将保留字符。将忽略任何 &lt;code&gt;=encoding&lt;/code&gt; ; 并且不会尝试解码输入。</target>
        </trans-unit>
        <trans-unit id="24318749936760c8c43beac827cb9d11fbd59672" translate="yes" xml:space="preserve">
          <source>If you set this attribute to a true value, it will send reports of parsing errors to STDERR. By default, this attribute's value is false, meaning that no output is sent to STDERR.</source>
          <target state="translated">如果您将此属性设置为真值,它将向STDERR发送解析错误报告。默认情况下,此属性的值为false,意味着不会向STDERR发送任何输出。</target>
        </trans-unit>
        <trans-unit id="b5b8252659bce51d0b80d2e62f37a533a1cac341" translate="yes" xml:space="preserve">
          <source>If you set this attribute to a true value, you will stop the parser from generating a &quot;POD ERRORS&quot; section at the end of the document. By default, this attribute's value is false, meaning that an errata section will be generated, as necessary.</source>
          <target state="translated">如果你把这个属性设置为true,你就会阻止解析器在文档末尾生成 &quot;POD ERRORS &quot;部分。默认情况下,这个属性的值为false,这意味着将在必要时生成勘误部分。</target>
        </trans-unit>
        <trans-unit id="551f3a0a87736ea2dc54ed40fd31f1fb500e9541" translate="yes" xml:space="preserve">
          <source>If you set this attribute to a true value, you will suppress the parser's complaints about irregularities in the Pod coding. By default, this attribute's value is false, meaning that irregularities will be reported.</source>
          <target state="translated">如果将此属性设置为true,则会抑制解析器对Pod编码中的不规则现象的投诉。默认情况下,这个属性的值为false,意味着将报告不规则的情况。</target>
        </trans-unit>
        <trans-unit id="e0f5cb1c277b98516d80bdfac1209f73af95fdc5" translate="yes" xml:space="preserve">
          <source>If you set this flag, all keys passed in the following manner:</source>
          <target state="translated">如果你设置了这个标志,所有的键都会以如下方式传递。</target>
        </trans-unit>
        <trans-unit id="90adec0aabd8555567c00e54faf42cc1c5fd95da" translate="yes" xml:space="preserve">
          <source>If you set this flag, unknown options will still be present in the return value, rather than filtered out. This is useful if your subroutine is only interested in a few arguments, and wants to pass the rest on blindly to perhaps another subroutine.</source>
          <target state="translated">如果你设置了这个标志,未知选项仍然会出现在返回值中,而不是被过滤掉。如果你的子程序只对几个参数感兴趣,而想把剩下的参数盲目地传递给另一个子程序,那么这个标志就很有用。</target>
        </trans-unit>
        <trans-unit id="71c1c224b5079dff6437c4c296c3882a0dbe0842" translate="yes" xml:space="preserve">
          <source>If you set this value to 0, these processes will wait forever. This is the default and recommended setting.</source>
          <target state="translated">如果将此值设置为0,这些进程将永远等待。这是默认和推荐的设置。</target>
        </trans-unit>
        <trans-unit id="57bb7a66b14f683a002bf6e9ed419bdbfaba4540" translate="yes" xml:space="preserve">
          <source>If you simply need to check quickly to see if a module is available, you can check for its documentation. If you can read the documentation the module is most likely installed. If you cannot read the documentation, the module might not have any (in rare cases):</source>
          <target state="translated">如果您只是需要快速检查一个模块是否可用,您可以检查它的文档。如果您能读懂文档,那么该模块很可能已经安装了。如果您无法阅读文档,则该模块可能没有任何文档(在极少数情况下)。</target>
        </trans-unit>
        <trans-unit id="8217a1604a7e6dedea6a0a5e3eee8fea23c61b15" translate="yes" xml:space="preserve">
          <source>If you simply want &lt;code&gt;TAP::Parser&lt;/code&gt; to handle a new source of TAP you probably don't need to subclass &lt;code&gt;TAP::Parser&lt;/code&gt; itself. Rather, you'll need to create a new &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; class, and just plug it into the parser using the</source>
          <target state="translated">如果您只是希望 &lt;code&gt;TAP::Parser&lt;/code&gt; 处理TAP的新源，则可能无需继承 &lt;code&gt;TAP::Parser&lt;/code&gt; 本身。相反，您需要创建一个新的&lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;类，然后使用将其插入解析器。</target>
        </trans-unit>
        <trans-unit id="bccc23097030849c37e4990da975ad564b128d6e" translate="yes" xml:space="preserve">
          <source>If you simply want to check that a variable contains an object reference, we recommend that you use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; blessed($object)&lt;/code&gt; , since &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; returns true values for all references, not just objects.</source>
          <target state="translated">如果您只是想检查一个变量是否包含对象引用，我们建议您使用已 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; blessed($object)&lt;/code&gt; ，因为 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 会为所有引用而不是对象返回真值。</target>
        </trans-unit>
        <trans-unit id="538504cf71c29fca71496cb30f3e2c1293640623" translate="yes" xml:space="preserve">
          <source>If you simply want to do a little tweaking of how the tests behave, you can access the underlying &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; object like so:</source>
          <target state="translated">如果您只是想稍微调整一下测试的行为，则可以像下面这样访问底层的&lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt;对象：</target>
        </trans-unit>
        <trans-unit id="e8d0959c4e3749a28ef9e062bf2ea64f531c9a4d" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;'&amp;lt;&amp;amp;=X'&lt;/code&gt; , where &lt;code&gt;X&lt;/code&gt; is a file descriptor number or a filehandle, then Perl will do an equivalent of C's &lt;code&gt;fdopen&lt;/code&gt; of that file descriptor (and not call &lt;code&gt;dup(2)&lt;/code&gt; ); this is more parsimonious of file descriptors. For example:</source>
          <target state="translated">如果指定 &lt;code&gt;'&amp;lt;&amp;amp;=X'&lt;/code&gt; ，其中 &lt;code&gt;X&lt;/code&gt; 是文件描述符号或文件句柄，则Perl将执行C 对该文件描述符的 &lt;code&gt;fdopen&lt;/code&gt; 的等效操作（并且不调用 &lt;code&gt;dup(2)&lt;/code&gt; ）；这更简化了文件描述符。例如：</target>
        </trans-unit>
        <trans-unit id="180f2fd51c0d498482504f1f96654a60c731b6ff" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;NUM_USES&lt;/code&gt; with an argument of</source>
          <target state="translated">如果您指定 &lt;code&gt;NUM_USES&lt;/code&gt; 且参数为</target>
        </trans-unit>
        <trans-unit id="8d4306b9666c2a3ba16744fba22e147888a1f901" translate="yes" xml:space="preserve">
          <source>If you specify COMPRESS, then SUFFIX should also be altered, as it is needed to tell make the target file of the compression. Setting DIST_CP to ln can be useful, if you need to preserve the timestamps on your files. DIST_CP can take the values 'cp', which copies the file, 'ln', which links the file, and 'best' which copies symbolic links and links the rest. Default is 'best'.</source>
          <target state="translated">如果你指定了COMPRESS,那么SUFFIX也应该被改变,因为它需要告诉使目标文件的压缩。如果你需要保留文件上的时间戳,将DIST_CP设置为ln是很有用的。DIST_CP 可以取值 'cp',复制文件,'ln',链接文件,'best',复制符号链接并链接其他文件。默认值是'best'。</target>
        </trans-unit>
        <trans-unit id="fc451ad5db1446b8366614b6922be5421ce289a8" translate="yes" xml:space="preserve">
          <source>If you specify LIB or any INSTALL* variables they will not be affected by the PREFIX.</source>
          <target state="translated">如果你指定了 LIB 或任何 INSTALL*变量,它们将不受 PREFIX 的影响。</target>
        </trans-unit>
        <trans-unit id="9241abdeaef157dc233bd737d1c5964fbf4c453e" translate="yes" xml:space="preserve">
          <source>If you specify both arguments, data will be discarded from the cache when either expiration condition holds.</source>
          <target state="translated">如果您指定了这两个参数,当任何一个过期条件成立时,数据将被从缓存中丢弃。</target>
        </trans-unit>
        <trans-unit id="ec224c3d56f48a286860fa26eb84c5ac4d399f4c" translate="yes" xml:space="preserve">
          <source>If you start with bullets or numbers, stick with them, as formatters use the first &quot;=item&quot; type to decide how to format the list.</source>
          <target state="translated">如果你从子弹或数字开始,坚持使用它们,因为格式化人员使用第一个&quot;=item &quot;类型来决定如何格式化列表。</target>
        </trans-unit>
        <trans-unit id="583108dc3c7ca5413e3c465d6f2c5b41f57d07b1" translate="yes" xml:space="preserve">
          <source>If you still need a different solution, try to develop another subroutine that fits your needs and submit the diffs to &lt;code&gt;makemaker@perl.org&lt;/code&gt;</source>
          <target state="translated">如果仍然需要其他解决方案，请尝试开发另一个适合您需求的子例程，并将差异提交到 &lt;code&gt;makemaker@perl.org&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a47b80b17f146bdd2f697c181154024073445f0f" translate="yes" xml:space="preserve">
          <source>If you still need commercial support &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActiveState&lt;/a&gt; offers this.</source>
          <target state="translated">如果您仍需要商业支持，&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActiveState会&lt;/a&gt;提供此服务。</target>
        </trans-unit>
        <trans-unit id="5b1b0c04cf56825c214a1e0c17a804ce5039d636" translate="yes" xml:space="preserve">
          <source>If you supply a code reference the subroutine will be called once for each line of output with the line as its only argument. Passed lines will have no trailing newline.</source>
          <target state="translated">如果您提供了一个代码引用,子程序将对每行输出调用一次,并将该行作为唯一的参数。通过的行将没有尾部的换行。</target>
        </trans-unit>
        <trans-unit id="9c870447a33109e08d6ac4807e8b39152cd8060a" translate="yes" xml:space="preserve">
          <source>If you supply a function name with &lt;code&gt;INSTALL&lt;/code&gt; , memoize will install the new, memoized version of the function under the name you give. For example,</source>
          <target state="translated">如果您使用 &lt;code&gt;INSTALL&lt;/code&gt; 提供函数名称，则memoize将在您提供的名称下安装该函数的新的，经过记忆的版本。例如，</target>
        </trans-unit>
        <trans-unit id="f6165205f1f599d384067c9f25ff1f7dd1d17430" translate="yes" xml:space="preserve">
          <source>If you supply data which is not valid (month 27, second 1,000) the results will be unpredictable (so don't do that).</source>
          <target state="translated">如果你提供的数据是无效的(第27个月,第二个1000),结果将是不可预测的(所以不要这样做)。</target>
        </trans-unit>
        <trans-unit id="f2f171e34560b51f24a2295b658a384f71202d5b" translate="yes" xml:space="preserve">
          <source>If you think geographically the</source>
          <target state="translated">如果你从地理上考虑</target>
        </trans-unit>
        <trans-unit id="50a6625675c788b39661b9a604d74414a739f593" translate="yes" xml:space="preserve">
          <source>If you think that you want to add a new command to Pod (like, say, a &quot;=biblio&quot; command), consider whether you could get the same effect with a for or begin/end sequence: &quot;=for biblio ...&quot; or &quot;=begin biblio&quot; ... &quot;=end biblio&quot;. Pod processors that don't understand &quot;=for biblio&quot;, etc, will simply ignore it, whereas they may complain loudly if they see &quot;=biblio&quot;.</source>
          <target state="translated">如果你认为你想在Pod中添加一个新的命令(比如,&quot;=biblio &quot;命令),考虑一下你是否可以用for或begin/end序列来获得同样的效果。&quot;=for biblio ...&quot;或者&quot;=begin biblio&quot; ...&quot;=end biblio&quot;。不懂&quot;=for biblio &quot;等的花苞处理器会直接忽略,而如果看到&quot;=biblio&quot;,他们可能会大声抱怨。</target>
        </trans-unit>
        <trans-unit id="0dc7def89e2edc18a212cddb050ecfe26b36c107" translate="yes" xml:space="preserve">
          <source>If you trust the archive, or have other reasons to allow the archive to write files outside your current working directory, set this variable to &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">如果您信任存档，或者出于其他原因允许存档在当前工作目录之外写入文件，请将此变量设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6aec72dc70a1ee4a43ad060e5bdfa6e98825b4f" translate="yes" xml:space="preserve">
          <source>If you try &lt;code&gt;Moose&lt;/code&gt; and find that one of these issues is preventing you from using &lt;code&gt;Moose&lt;/code&gt; , we encourage you to consider &lt;a href=&quot;http://search.cpan.org/perldoc/Moo&quot;&gt;Moo&lt;/a&gt; next. &lt;code&gt;Moo&lt;/code&gt; implements a subset of &lt;code&gt;Moose&lt;/code&gt; 's functionality in a simpler package. For most features that it does implement, the end-user API is</source>
          <target state="translated">如果您尝试 &lt;code&gt;Moose&lt;/code&gt; 并发现其中一个问题阻止了您使用 &lt;code&gt;Moose&lt;/code&gt; ，那么我们建议您接下来考虑使用&lt;a href=&quot;http://search.cpan.org/perldoc/Moo&quot;&gt;Moo&lt;/a&gt;。 &lt;code&gt;Moo&lt;/code&gt; 在更简单的程序包中实现 &lt;code&gt;Moose&lt;/code&gt; 功能的子集。对于它实现的大多数功能，最终用户API为</target>
        </trans-unit>
        <trans-unit id="ce64d2eb6b26fca2ba64557ff812899e21e2cf8b" translate="yes" xml:space="preserve">
          <source>If you try to add a file to @INC as follows:</source>
          <target state="translated">如果你试图向@INC添加一个文件,如下所示。</target>
        </trans-unit>
        <trans-unit id="e1047e2245ed732ddd158d44ef63171c1040f4d7" translate="yes" xml:space="preserve">
          <source>If you try to dereference the key, it won't do a hard dereference, and you won't accomplish what you're attempting. You might want to do something more like</source>
          <target state="translated">如果你试图去定义键,它就不会进行硬性的去定义,你就不会完成你的尝试。你可能想做一些更像</target>
        </trans-unit>
        <trans-unit id="b64e549b9d0f70c710cd7ee8a843df08eb7e123c" translate="yes" xml:space="preserve">
          <source>If you try to do something insecure, you will get a fatal error saying something like &quot;Insecure dependency&quot; or &quot;Insecure $ENV{PATH}&quot;.</source>
          <target state="translated">如果你试图做一些不安全的事情,你会得到一个致命的错误,比如 &quot;不安全的依赖 &quot;或 &quot;不安全的$ENV{PATH}&quot;。</target>
        </trans-unit>
        <trans-unit id="baaf467929bddd8fa5b7aa6c26404c219da0153b" translate="yes" xml:space="preserve">
          <source>If you try to do the same thing with what you think is a list, you get a quite different result. Although it looks like you have a list on the righthand side, Perl actually sees a bunch of scalars separated by a comma:</source>
          <target state="translated">如果你试图用你认为是列表的东西做同样的事情,你会得到一个完全不同的结果。虽然看起来你在右面有一个列表,但Perl实际上看到的是一堆用逗号隔开的标量。</target>
        </trans-unit>
        <trans-unit id="e39b81693bb33881d5354ed40ab1aa5e5e421f38" translate="yes" xml:space="preserve">
          <source>If you try to import an unimplemented function in the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement it will fail at compile time.</source>
          <target state="translated">如果尝试在 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句中导入未实现的函数，它将在编译时失败。</target>
        </trans-unit>
        <trans-unit id="ce84b9139b9e943d624385f2da9d34f42bd6117a" translate="yes" xml:space="preserve">
          <source>If you try to read from the child's stdout writer and their stderr writer, you'll have problems with blocking, which means you'll want to use select() or the IO::Select, which means you'd best use sysread() instead of readline() for normal stuff.</source>
          <target state="translated">如果你试图从子程序的stdout写作者和他们的stderr写作者那里读取,你会遇到阻塞的问题,这意味着你要使用select()或IO::Select,这意味着你最好使用sysread()而不是readline()来处理普通的东西。</target>
        </trans-unit>
        <trans-unit id="8629095d12898edeef813ea5adb0d8466406ccc7" translate="yes" xml:space="preserve">
          <source>If you try to use a reference like a string, you get strings like</source>
          <target state="translated">如果你尝试使用像字符串一样的引用,你会得到这样的字符串。</target>
        </trans-unit>
        <trans-unit id="39dd9c9407d1478c40154f713c3d3db1f745db97" translate="yes" xml:space="preserve">
          <source>If you try to use an alphanumeric sequence in a prototype you will generate an optional warning - &quot;Illegal character in prototype...&quot;. Unfortunately earlier versions of Perl allowed the prototype to be used as long as its prefix was a valid prototype. The warning may be upgraded to a fatal error in a future version of Perl once the majority of offending code is fixed.</source>
          <target state="translated">如果你试图在原型中使用字母数字序列,你会产生一个可选的警告--&quot;Illegal character in prototype...&quot;。不幸的是,早期版本的Perl允许使用原型,只要它的前缀是一个有效的原型。一旦大部分违规代码被修复,该警告可能会在未来版本的Perl中升级为致命错误。</target>
        </trans-unit>
        <trans-unit id="fe9a752d3dfb5ae4ddbce9b50462b1f6d85d68b3" translate="yes" xml:space="preserve">
          <source>If you try to use code expressions where the code text is contained within an interpolated variable, rather than appearing literally in the pattern, Perl may surprise you:</source>
          <target state="translated">如果你尝试使用代码表达式,其中代码文本包含在一个内插变量中,而不是按字面意思出现在模式中,Perl可能会让你感到惊讶。</target>
        </trans-unit>
        <trans-unit id="b74ccad2ea9ca8d857dc7afb6d54fa03395dd0f9" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; in your handler for $SIG{CHLD}, it may accidentally wait for the child created by qx() or system(). See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">如果在处理程序中为$ SIG {CHLD} 使用 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; ，则可能会意外地等待qx（）或system（）创建的子级。有关详细信息，请参见&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f489bb10b3438e3010da06cd3b95ce427029dc2" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; in your handler for $SIG{CHLD}, it may accidentally wait for the child created by qx() or system(). See &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">如果在处理程序中为$ SIG {CHLD} 使用 &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; ，则可能会意外地等待qx（）或system（）创建的子级。有关详细信息，请参见&lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46bb44efb62948225ccf4e92dee64ae61f103a13" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;FilterName&lt;/code&gt; to modify the filename, it is your responsibility to keep the filename in Unix format.</source>
          <target state="translated">如果使用 &lt;code&gt;FilterName&lt;/code&gt; 修改文件名，则有责任将文件名保持为Unix格式。</target>
        </trans-unit>
        <trans-unit id="16f11d3777f6f8b6ecfda56c2150f1df3c1a440a" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;harness&lt;/code&gt; for testing, you have several command line options available to you. The arguments are as follows, and are in the order that they must appear if used together.</source>
          <target state="translated">如果使用 &lt;code&gt;harness&lt;/code&gt; 进行测试，则可以使用几个命令行选项。自变量如下，并按在一起使用时必须出现的顺序排列。</target>
        </trans-unit>
        <trans-unit id="5dace6a8fabe0f3fff4268587985038c8aa60a8e" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;man&lt;/code&gt; , either move the installed</source>
          <target state="translated">如果使用 &lt;code&gt;man&lt;/code&gt; ，请移动已安装的</target>
        </trans-unit>
        <trans-unit id="f77d31c25362c9be9687e6ee59543d3904970c3a" translate="yes" xml:space="preserve">
          <source>If you use Sun's C compiler, make sure the correct directory (usually /opt/SUNWspro/bin/) is in your PATH (before /usr/ucb/).</source>
          <target state="translated">如果你使用的是Sun的C编译器,请确保正确的目录(通常是/opt/SUNWspro/bin/)在你的PATH中(在/usr/ucb/之前)。</target>
        </trans-unit>
        <trans-unit id="694a362a82c6e3cfa50f1318ad85b6fb37d17685" translate="yes" xml:space="preserve">
          <source>If you use a Unicode editor to edit your program, Unicode characters may occur directly within the literal strings in UTF-8 encoding, or UTF-16. (The former requires a &lt;code&gt;BOM&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , the latter requires a &lt;code&gt;BOM&lt;/code&gt; .)</source>
          <target state="translated">如果您使用Unicode编辑器来编辑程序，则Unicode字符可能直接出现在UTF-8编码或UTF-16的文字字符串中。（前者需要 &lt;code&gt;BOM&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; ，后者需要 &lt;code&gt;BOM&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="87cf615c227432610de49accfafc5d497f5d3f61" translate="yes" xml:space="preserve">
          <source>If you use a deprecated feature or module and believe that its removal from the Perl core would be a mistake, please contact the perl5-porters mailinglist and plead your case. We don't deprecate things without a good reason, but sometimes there's a counterargument we haven't considered. Historically, we did not distinguish between &quot;deprecated&quot; and &quot;discouraged&quot; features.</source>
          <target state="translated">如果你使用了一个被废弃的功能或模块,并且认为将其从 Perl 核心中移除是一个错误,请联系 perl5-porters 邮件列表并说明你的理由。我们不会在没有充分理由的情况下弃用某些东西,但有时会有我们没有考虑到的反驳意见。历史上,我们并没有区分 &quot;废弃 &quot;和 &quot;不鼓励 &quot;的特性。</target>
        </trans-unit>
        <trans-unit id="5dd282c0cc211cebd60be34d73466e199fdff472" translate="yes" xml:space="preserve">
          <source>If you use a here-doc within a delimited construct, such as in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///eg&lt;/a&gt;&lt;/code&gt;, the quoted material must still come on the line following the &lt;code&gt;&amp;lt;&amp;lt;FOO&lt;/code&gt; marker, which means it may be inside the delimited construct:</source>
          <target state="translated">如果在带分隔符的结构（例如 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///eg&lt;/a&gt;&lt;/code&gt; 使用here-doc ，则引用的材料仍必须位于 &lt;code&gt;&amp;lt;&amp;lt;FOO&lt;/code&gt; 标记之后的行中，这意味着它可能位于带分隔符的结构中：</target>
        </trans-unit>
        <trans-unit id="6ae0c0867250fd5a479e543aea928a9a77d11b83" translate="yes" xml:space="preserve">
          <source>If you use deferred writing (See &lt;a href=&quot;#Deferred-Writing&quot;&gt;Deferred Writing&lt;/a&gt;, below) then data you write into the array will not be written directly to the file; instead, it will be saved in the</source>
          <target state="translated">如果您使用延迟写入（请参见下面的&amp;ldquo; &lt;a href=&quot;#Deferred-Writing&quot;&gt;延迟写入&amp;rdquo;&lt;/a&gt;），那么您写入数组的数据将不会直接写入文件；而是将其保存在</target>
        </trans-unit>
        <trans-unit id="4f2793be84e03f881815cfd6cbd437f560ace728" translate="yes" xml:space="preserve">
          <source>If you use either the R_IAFTER or R_IBEFORE flags, the &lt;code&gt;$key&lt;/code&gt; parameter will have the record number of the inserted key/value pair set.</source>
          <target state="translated">如果使用R_IAFTER或R_IBEFORE标志，则 &lt;code&gt;$key&lt;/code&gt; 参数将设置插入的键/值对的记录号。</target>
        </trans-unit>
        <trans-unit id="7804e89f419dfb4afe57d175e577f649678035a8" translate="yes" xml:space="preserve">
          <source>If you use gcc, make sure your installation is recent and complete. perl versions since 5.6.0 build fine with gcc &amp;gt; 2.8.1 on Solaris &amp;gt;= 2.6.</source>
          <target state="translated">如果您使用gcc，请确保您的安装是最新且完整的。从5.6.0开始的perl版本可以在Solaris&amp;gt; = 2.6上使用gcc&amp;gt; 2.8.1很好地构建。</target>
        </trans-unit>
        <trans-unit id="c133e612772c5c91ca38653bb618cdde5ecf7eea" translate="yes" xml:space="preserve">
          <source>If you use one of the undocumented functions below, you may wish to consider creating and submitting documentation for it. If your patch is accepted, this will indicate that the interface is stable (unless it is explicitly marked otherwise).</source>
          <target state="translated">如果你使用了以下未记录的功能,你可能会考虑为它创建并提交文档。如果你的补丁被接受,这将表明该接口是稳定的(除非它有明确的标记)。</target>
        </trans-unit>
        <trans-unit id="97a1d75ada82bbf9f654420e7c70ad3899b98121" translate="yes" xml:space="preserve">
          <source>If you use preprocessor directives to choose one of two versions of a function, use</source>
          <target state="translated">如果你使用预处理器指令来选择一个函数的两个版本中的一个,使用</target>
        </trans-unit>
        <trans-unit id="32e7fdaa4b2e816b8b9a792f2d7c56bbe0d52ad7" translate="yes" xml:space="preserve">
          <source>If you use the 4DOS/NT or similar command shell, note that &quot;pl2bat&quot; uses the &quot;%*&quot; variable in the generated batch file to refer to all the command line arguments, so you may need to make sure that construct works in batch files. As of this writing, 4DOS/NT users will need a &quot;ParameterChar = *&quot; statement in their 4NT.INI file or will need to execute &quot;setdos /p*&quot; in the 4DOS/NT startup file to enable this to work.</source>
          <target state="translated">如果您使用4DOS/NT或类似的命令外壳,请注意 &quot;pl2bat &quot;在生成的批处理文件中使用&quot;%*&quot;变量来引用所有的命令行参数,所以您可能需要确保该结构在批处理文件中工作。在写这篇文章时,4DOS/NT用户将需要在他们的4NT.INI文件中使用 &quot;ParameterChar=*&quot;语句,或者需要在4DOS/NT启动文件中执行 &quot;setdos /p*&quot;来使其工作。</target>
        </trans-unit>
        <trans-unit id="91300f437c633a42a75ef31ebaae0d2065c281bd" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; PerlIO layer for input, invalid byte sequences are handled gracefully, but if you use &lt;code&gt;:utf8&lt;/code&gt; , the flag is set without validating the data, possibly resulting in this error message.</source>
          <target state="translated">如果将 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; PerlIO层用作输入，则可以正常处理无效的字节序列，但是如果使用 &lt;code&gt;:utf8&lt;/code&gt; ，则将设置标志而不验证数据，这可能会导致此错误消息。</target>
        </trans-unit>
        <trans-unit id="3eecf6412d7114c8844a3dfb8554c44c0eb8598c" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;SA_SIGINFO&lt;/code&gt; flag, the signal handler will in addition to the first argument, the signal name, also receive a second argument, a hash reference, inside which are the following keys with the following semantics, as defined by POSIX/SUSv3:</source>
          <target state="translated">如果使用 &lt;code&gt;SA_SIGINFO&lt;/code&gt; 标志，则信号处理程序除了第一个参数（信号名称）之外，还将接收第二个参数（哈希引用），在其中包含具有POSIX / SUSv3定义的下列语义的键：</target>
        </trans-unit>
        <trans-unit id="dc06c253841f15b9de0c355618356ed5550da10d" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;\G&lt;/code&gt; anchor, you force the match after &lt;code&gt;22&lt;/code&gt; to start with the &lt;code&gt;a&lt;/code&gt; . The regular expression cannot match there since it does not find a digit, so the next match fails and the match operator returns the pairs it already found.</source>
          <target state="translated">如果你使用 &lt;code&gt;\G&lt;/code&gt; 主播，你强迫赛后 &lt;code&gt;22&lt;/code&gt; 开始与 &lt;code&gt;a&lt;/code&gt; 。正则表达式无法在此处匹配，因为它找不到数字，因此下一次匹配失败，并且match运算符返回它已经找到的对。</target>
        </trans-unit>
        <trans-unit id="fbb20a66ed661494874fa5e98a73f246a9cc34cc" translate="yes" xml:space="preserve">
          <source>If you use the English module, you can even read the variable names:</source>
          <target state="translated">如果你使用英文模块,你甚至可以读取变量名。</target>
        </trans-unit>
        <trans-unit id="abbbac8010fcf4e1f8177dc8b18103356d7c1579" translate="yes" xml:space="preserve">
          <source>If you use the form &lt;code&gt;\N{&lt;i&gt;character name&lt;/i&gt;}&lt;/code&gt;, the &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt; module gets automatically loaded. This may not be suitable for the test level you are doing.</source>
          <target state="translated">如果您使用 &lt;code&gt;\N{&lt;i&gt;character name&lt;/i&gt;}&lt;/code&gt; 格式，则&lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;模块将自动加载。这可能不适合您正在执行的测试级别。</target>
        </trans-unit>
        <trans-unit id="b6639f5cfc711b71b35423e81c784a209aabfc93" translate="yes" xml:space="preserve">
          <source>If you use the hash syntax, you have no control over the order in which the ExtraSubFields are stored, plus you cannot have SubFields with duplicate ID.</source>
          <target state="translated">如果你使用哈希语法,你就无法控制ExtraSubFields的存储顺序,另外你也不能拥有ID重复的SubFields。</target>
        </trans-unit>
        <trans-unit id="cf9048b3298377c86c20ad5d8b5d02655bc3f8b6" translate="yes" xml:space="preserve">
          <source>If you use the raw format, and the &lt;code&gt;Strict&lt;/code&gt; option is enabled, &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; will check that &lt;code&gt;$rawdata&lt;/code&gt; consists of zero or more conformant sub-fields. When &lt;code&gt;Strict&lt;/code&gt; is disabled, &lt;code&gt;$rawdata&lt;/code&gt; can consist of any arbitrary byte stream.</source>
          <target state="translated">如果您使用原始格式，并且启用了 &lt;code&gt;Strict&lt;/code&gt; 选项，则 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 将检查 &lt;code&gt;$rawdata&lt;/code&gt; 包含零个或更多个一致的子字段。当 &lt;code&gt;Strict&lt;/code&gt; 禁止， &lt;code&gt;$rawdata&lt;/code&gt; 可以由任意字节流的。</target>
        </trans-unit>
        <trans-unit id="c067123fb137430de0f256b297d516b2001d264a" translate="yes" xml:space="preserve">
          <source>If you use utf8 or other non-ASCII characters with Test::More you might get a &quot;Wide character in print&quot; warning. Using &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt; STDOUT, &quot;:utf8&quot;&lt;/code&gt; will not fix it. &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; (which powers Test::More) duplicates STDOUT and STDERR. So any changes to them, including changing their output disciplines, will not be seem by Test::More.</source>
          <target state="translated">如果在Test :: More中使用utf8或其他非ASCII字符，则可能会收到&amp;ldquo;正在打印宽字符&amp;rdquo;警告。使用 &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt; STDOUT, &quot;:utf8&quot;&lt;/code&gt; 将无法修复它。&lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt;（为Test :: More提供动力）复制了STDOUT和STDERR。因此，Test :: More不会对它们进行任何更改，包括更改其输出学科。</target>
        </trans-unit>
        <trans-unit id="630840ae944c06429550447e9540c0ca707dbc1a" translate="yes" xml:space="preserve">
          <source>If you used WinZip, this was already done for you.</source>
          <target state="translated">如果你使用的是WinZip,这已经为你完成了。</target>
        </trans-unit>
        <trans-unit id="8c53b3ef6362ad03c7dbea52d0c4786e608f8e77" translate="yes" xml:space="preserve">
          <source>If you used git to check out the Perl source, then using &lt;code&gt;git
format-patch&lt;/code&gt; will produce a patch in a style suitable for Perl. The &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format-patch&lt;/a&gt;&lt;/code&gt; command produces one patch file for each commit you made. If you prefer to send a single patch for all commits, you can use &lt;code&gt;git diff&lt;/code&gt; .</source>
          <target state="translated">如果您使用git签出Perl源代码，则使用 &lt;code&gt;git format-patch&lt;/code&gt; 将以适合Perl的样式生成补丁。该 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format-patch&lt;/a&gt;&lt;/code&gt; 命令会为每一个承诺，你做一个补丁文件。如果您希望为所有提交发送一个补丁，则可以使用 &lt;code&gt;git diff&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bc21e512fb418bd39c6e536f3bdd95478cb7d3c" translate="yes" xml:space="preserve">
          <source>If you want $x to have a certain sign, use one of the following methods:</source>
          <target state="translated">如果你想让$x有一个特定的符号,使用以下方法之一。</target>
        </trans-unit>
        <trans-unit id="1553678828e2328fa0aa14746ccfdd7229ce26f6" translate="yes" xml:space="preserve">
          <source>If you want *.ucm installed together with the modules, do as follows;</source>
          <target state="translated">如果你想让*.ucm和模块一起安装,请按以下步骤进行。</target>
        </trans-unit>
        <trans-unit id="791324333537699862b9ce903fa1af5980ed496f" translate="yes" xml:space="preserve">
          <source>If you want a &quot;real&quot; C &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; (see</source>
          <target state="translated">如果要 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; &amp;ldquo;真实的&amp;rdquo; C （请参阅</target>
        </trans-unit>
        <trans-unit id="c13df57b95397c5f1d723459f0b855e899e41a8a" translate="yes" xml:space="preserve">
          <source>If you want a &quot;real&quot; C &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; (see</source>
          <target state="translated">如果要 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; &amp;ldquo;真实的&amp;rdquo; C （请参阅</target>
        </trans-unit>
        <trans-unit id="cb1d7bd468d379f255df6d0a8a45090fecae8882" translate="yes" xml:space="preserve">
          <source>If you want a Perl application to process and present your data according to a particular locale, the application code should include the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma (see &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;The use locale pragma&lt;/a&gt;) where appropriate, and &lt;b&gt;at least one&lt;/b&gt; of the following must be true:</source>
          <target state="translated">如果您希望Perl应用程序根据特定的语言环境处理和显示数据，则该应用程序代码应在适当的地方包含 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma（请参阅Use &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;locale pragma&lt;/a&gt;），并且&lt;b&gt;以下至少一项&lt;/b&gt;必须为true：</target>
        </trans-unit>
        <trans-unit id="dc8f1faa6c36903ecd5d1abeecfdbd92380ab3a3" translate="yes" xml:space="preserve">
          <source>If you want a better approximation of the square root, then use:</source>
          <target state="translated">如果你想要一个更好的平方根近似值,那就用。</target>
        </trans-unit>
        <trans-unit id="409579e935815d3f9b1b191e4808eba939430e40" translate="yes" xml:space="preserve">
          <source>If you want a completely new Test::Builder object different from the singleton, use &lt;code&gt;create&lt;/code&gt; .</source>
          <target state="translated">如果您想要一个不同于单例的全新Test :: Builder对象，请使用 &lt;code&gt;create&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="364287807494857e0923c716161b8323aaaa85ad" translate="yes" xml:space="preserve">
          <source>If you want a list of all of the Perl module filenames, you can use &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt;:</source>
          <target state="translated">如果要列出所有Perl模块文件名，可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File :: Find :: Rule&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="20d03f9f8d59c035c39fd85e8955d33568507a9f" translate="yes" xml:space="preserve">
          <source>If you want a real Perl scalar, use &lt;code&gt;numify()&lt;/code&gt; :</source>
          <target state="translated">如果您想要一个真正的Perl标量，请使用 &lt;code&gt;numify()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9309fd012fc6beaef72da428ac578230d08f400e" translate="yes" xml:space="preserve">
          <source>If you want a supported version of perl for OpenVOS, purchase the OpenVOS GNU Tools product from Stratus Technologies, along with a support contract (or from anyone else who will sell you support).</source>
          <target state="translated">如果你想要一个支持OpenVOS的perl版本,请从Stratus Technologies购买OpenVOS GNU Tools产品,同时购买一份支持合同(或者从其他愿意向你提供支持的人那里购买)。</target>
        </trans-unit>
        <trans-unit id="6584c0a384e584f13abe302cec979af6b67c1d61" translate="yes" xml:space="preserve">
          <source>If you want a true copy of $x, use:</source>
          <target state="translated">如果你想得到$x的真实副本,使用:</target>
        </trans-unit>
        <trans-unit id="2bd3ed425ef919c14360d525b51cc98be9af477c" translate="yes" xml:space="preserve">
          <source>If you want access to threads, you must &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; before you &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . &lt;a href=&quot;../threads&quot;&gt;threads&lt;/a&gt; will emit a warning if you use it after &lt;a href=&quot;shared&quot;&gt;threads::shared&lt;/a&gt;.</source>
          <target state="translated">如果要访问线程，则必须先 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 然后再 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; 。如果在&lt;a href=&quot;shared&quot;&gt;thread :: shared&lt;/a&gt;之后使用&lt;a href=&quot;../threads&quot;&gt;线程，&lt;/a&gt;则线程将发出警告。</target>
        </trans-unit>
        <trans-unit id="2ffb4d0fb6b209221b80f1da704496ad8ce1ebe0" translate="yes" xml:space="preserve">
          <source>If you want an IDE, check the following (in alphabetical order, not order of preference):</source>
          <target state="translated">如果你想要一个IDE,请检查以下内容(按字母顺序,而不是偏好顺序)。</target>
        </trans-unit>
        <trans-unit id="fe93301108d8dca54392bf8f900a5e24a5258416" translate="yes" xml:space="preserve">
          <source>If you want anything fancier, consider overriding this with something that uses &lt;a href=&quot;http://search.cpan.org/perldoc/Number::Format&quot;&gt;Number::Format&lt;/a&gt;, or does something else entirely.</source>
          <target state="translated">如果您需要任何高级功能，请考虑使用&lt;a href=&quot;http://search.cpan.org/perldoc/Number::Format&quot;&gt;Number :: Format&lt;/a&gt;或完全执行其他操作来替代它。</target>
        </trans-unit>
        <trans-unit id="03e2f095ee9c1b96484a23c04f5e5dfef232e04c" translate="yes" xml:space="preserve">
          <source>If you want build some core extensions statically into perl's dll, specify them in the STATIC_EXT macro.</source>
          <target state="translated">如果你想把一些核心扩展静态地构建到perl的dll中,在STATIC_EXT宏中指定它们。</target>
        </trans-unit>
        <trans-unit id="18b0e9b36c2f4eaca25552fa7c7631a4398f6336" translate="yes" xml:space="preserve">
          <source>If you want finer granularity than the 1 second that the &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; function provides, the easiest way is to use the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; function as documented in &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;. Try the &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; and the &lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Itimer&quot;&gt;BSD::Itimer&lt;/a&gt; modules (available from CPAN, and starting from Perl 5.8 &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; is part of the standard distribution).</source>
          <target state="translated">如果你想超过1秒的更细的粒度 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 函数提供了最简单的方法是使用 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 函数中记载&lt;a href=&quot;functions/select&quot;&gt;选择&lt;/a&gt;。尝试使用&lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Itimer&quot;&gt;BSD :: Itimer&lt;/a&gt;模块（可从CPAN获得，从Perl 5.8开始，&lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt;是标准发行版的一部分）。</target>
        </trans-unit>
        <trans-unit id="e14afa459a95e2ee1097bdb5d465fc670f04bf72" translate="yes" xml:space="preserve">
          <source>If you want it to be a Unicode string (because you want character semantics with operations like regular expression matching), you need to decode the UTF8-encoded content and have Perl convert it into a Unicode string:</source>
          <target state="translated">如果你想让它成为一个Unicode字符串(因为你想通过正则表达式匹配等操作获得字符语义),你需要对UTF8编码的内容进行解码,并让Perl将其转换为Unicode字符串。</target>
        </trans-unit>
        <trans-unit id="b68288a6982fc2b55a1d1fa4ad5b3ecc68be5d47" translate="yes" xml:space="preserve">
          <source>If you want more flexibility, you need to configure your CPAN client for your particular situation.</source>
          <target state="translated">如果您想要更多的灵活性,您需要根据您的特殊情况配置您的CPAN客户端。</target>
        </trans-unit>
        <trans-unit id="212545de9d894bed7fa89be5bf884693fe7c603b" translate="yes" xml:space="preserve">
          <source>If you want no headers or footers output in the HTML, set these options to the empty string.</source>
          <target state="translated">如果您不想在HTML中输出页眉或页脚,请将这些选项设置为空字符串。</target>
        </trans-unit>
        <trans-unit id="2be3f922578397a2f9698c9c71abc2a55e6ed43d" translate="yes" xml:space="preserve">
          <source>If you want perl to use globbing that emulates the quirks of DOS filename conventions, you might want to consider using File::DosGlob to override the internal glob() implementation. See &lt;a href=&quot;file/dosglob&quot;&gt;File::DosGlob&lt;/a&gt; for details.</source>
          <target state="translated">如果您希望perl使用模仿DOS文件名约定古怪的globbing，则可能要考虑使用File :: DosGlob覆盖内部glob（）实现。有关详细信息，请参见&lt;a href=&quot;file/dosglob&quot;&gt;File :: DosGlob&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="08c46a24da2bb06c6e1c6ef38a1abe76f47d9a13" translate="yes" xml:space="preserve">
          <source>If you want read lines, you must read in list context.</source>
          <target state="translated">如果你想读行,你必须在列表上下文中读。</target>
        </trans-unit>
        <trans-unit id="9bfb8a43a2ce5fcca125d20e873c4c7b11aed7e7" translate="yes" xml:space="preserve">
          <source>If you want the &lt;code&gt;atexit()&lt;/code&gt; syntax (and an &lt;code&gt;rmexit()&lt;/code&gt; as well), try the &lt;code&gt;AtExit&lt;/code&gt; module available from CPAN.</source>
          <target state="translated">如果需要 &lt;code&gt;atexit()&lt;/code&gt; 语法（以及 &lt;code&gt;rmexit()&lt;/code&gt; ），请尝试使用CPAN 的 &lt;code&gt;AtExit&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="124ea0ab66186e4216274d303cbf33e4b47044f9" translate="yes" xml:space="preserve">
          <source>If you want the array index, use the &lt;code&gt;firstidx()&lt;/code&gt; function from &lt;code&gt;List::MoreUtils&lt;/code&gt; :</source>
          <target state="translated">如果需要数组索引，请使用 &lt;code&gt;List::MoreUtils&lt;/code&gt; 的 &lt;code&gt;firstidx()&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="7615fa2a66b55733775cb5d887a00d84846653ee" translate="yes" xml:space="preserve">
          <source>If you want the code to die instead of falling back, use &lt;code&gt;only&lt;/code&gt; instead:</source>
          <target state="translated">如果您想使代码消失而不是回退，请 &lt;code&gt;only&lt;/code&gt; 使用：</target>
        </trans-unit>
        <trans-unit id="5f643e51c29ad1dcf8382df154f107e9e891d49b" translate="yes" xml:space="preserve">
          <source>If you want the code to die instead, replace &quot;try&quot; with &quot;only&quot;:</source>
          <target state="translated">如果你想让代码死掉,把 &quot;try &quot;改为 &quot;only&quot;。</target>
        </trans-unit>
        <trans-unit id="444d833c4fe34c4ebf55ce0643031f3aa4615d34" translate="yes" xml:space="preserve">
          <source>If you want the equivalent of &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Foo ()&lt;/code&gt; , use a module but not import anything, use &lt;code&gt;require_ok&lt;/code&gt; .</source>
          <target state="translated">如果要 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Foo ()&lt;/code&gt; 等效，请使用模块但不导入任何内容，请使用 &lt;code&gt;require_ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ebff181122cf920b540aa12f6f2468119acea8d" translate="yes" xml:space="preserve">
          <source>If you want the old signal behavior back despite possible memory corruption, set the environment variable &lt;code&gt;PERL_SIGNALS&lt;/code&gt; to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; . This feature first appeared in Perl 5.8.1.</source>
          <target state="translated">如果尽管内存可能损坏，也希望恢复旧的信号行为，请将环境变量 &lt;code&gt;PERL_SIGNALS&lt;/code&gt; 设置为 &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; 。此功能最早出现在Perl 5.8.1中。</target>
        </trans-unit>
        <trans-unit id="35e2e89a1af9e4f4ab883e1fb265f28d997edb48" translate="yes" xml:space="preserve">
          <source>If you want these output in a sorted order, see &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;: &quot;How do I sort a hash (optionally by value instead of key)?&quot;.</source>
          <target state="translated">如果要按排序顺序输出这些输出，请参见&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;：&amp;ldquo;如何对哈希进行排序（可选地按值而不是键）？&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="1340d84f704d5f6a74163cc5fe06ae9be150fb8b" translate="yes" xml:space="preserve">
          <source>If you want to &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; into a string, you just have to &amp;lt;open&amp;gt; a filehandle to a string, which Perl has been able to do since Perl 5.6:</source>
          <target state="translated">如果要 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 字符串，只需&amp;lt;open&amp;gt;字符串的文件句柄，这是Perl自Perl 5.6起就能做到的：</target>
        </trans-unit>
        <trans-unit id="7953e238f104e2cdb7abf22e43568bf172380a8b" translate="yes" xml:space="preserve">
          <source>If you want to CLONE all objects you will need to keep track of them per package. This is simply done using a hash and Scalar::Util::weaken().</source>
          <target state="translated">如果你想克隆所有的对象,你需要对每个包进行跟踪。这可以通过使用哈希和Scalar::Util::weaken()来完成。</target>
        </trans-unit>
        <trans-unit id="8a750f90ba1cfc2d81f044342057667c6ac1726e" translate="yes" xml:space="preserve">
          <source>If you want to actually extract the matching elements, simply use grep in list context.</source>
          <target state="translated">如果你想实际提取匹配的元素,只需在列表上下文中使用grep。</target>
        </trans-unit>
        <trans-unit id="d026b5d2f0b8d0ebf6352db336c8a293bea0fac9" translate="yes" xml:space="preserve">
          <source>If you want to add your encoding to Encode's demand-loading list (so you don't have to &quot;use Encode::YourEncoding&quot;), run</source>
          <target state="translated">如果您想将您的编码添加到Encode的需求加载列表中(所以您不必 &quot;使用Encode::YourEncoding&quot;),运行</target>
        </trans-unit>
        <trans-unit id="3ceac82578bb19fb50532d7256faa44ce8c265df" translate="yes" xml:space="preserve">
          <source>If you want to append something to the end of string stored in an &lt;code&gt;SV*&lt;/code&gt; , you can use the following functions:</source>
          <target state="translated">如果要将某些内容附加到 &lt;code&gt;SV*&lt;/code&gt; 存储的字符串的末尾，可以使用以下功能：</target>
        </trans-unit>
        <trans-unit id="5fbae8e9319ec5948bcc63aa24cae46d2c786676" translate="yes" xml:space="preserve">
          <source>If you want to be sure that you're calling &lt;code&gt;isa&lt;/code&gt; as a method, not a class, check the invocand with &lt;code&gt;blessed&lt;/code&gt; from &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; first:</source>
          <target state="translated">如果你想确保你调用 &lt;code&gt;isa&lt;/code&gt; 作为一种方法，而不是一个班，请与invocand &lt;code&gt;blessed&lt;/code&gt; 从&lt;a href=&quot;scalar/util&quot;&gt;标量::的Util&lt;/a&gt;第一：</target>
        </trans-unit>
        <trans-unit id="363081145dde14f7c8fd4e2bf011a936ad34c73a" translate="yes" xml:space="preserve">
          <source>If you want to break apart an entire line of fixed columns, you can use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the A (ASCII) format. By using a number after the format specifier, you can denote the column width. See the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; entries in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="translated">如果要分解固定行的整行，可以使用A（ASCII）格式的 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 。通过在格式说明符后面使用数字，可以表示列宽。见 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 的条目&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;更多细节。</target>
        </trans-unit>
        <trans-unit id="10e8c447f2a79196fb827a87399f6352fddeb35d" translate="yes" xml:space="preserve">
          <source>If you want to build the docs yourself, and have</source>
          <target state="translated">如果你想自己建立文档,并拥有</target>
        </trans-unit>
        <trans-unit id="3016ac8f3431196221d3334c73f10b4a58c7afce" translate="yes" xml:space="preserve">
          <source>If you want to call C from Perl, start with &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;, moving on to &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;, &lt;a href=&quot;xsubpp&quot;&gt;xsubpp&lt;/a&gt;, and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;. If you want to call Perl from C, then read &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;, &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;, and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;. Don't forget that you can learn a lot from looking at how the authors of existing extension modules wrote their code and solved their problems.</source>
          <target state="translated">如果要从Perl调用C，请从&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;开始，然后转到&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;，&lt;a href=&quot;xsubpp&quot;&gt;xsubpp&lt;/a&gt;和&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;。如果要从C调用Perl，请阅读&lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;，&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;和&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;。不要忘记，通过查看现有扩展模块的作者如何编写代码并解决问题，您可以学到很多东西。</target>
        </trans-unit>
        <trans-unit id="548a69c6108c24555301c111e716c92968ea1230" translate="yes" xml:space="preserve">
          <source>If you want to check exactly, compare the string with its NFC/NFKC/FCC.</source>
          <target state="translated">如果你想确切地检查,将该字符串与其NFC/NFKC/FCC进行比较。</target>
        </trans-unit>
        <trans-unit id="59c2fb7af17b706fe9c70e8baa09126e5a3d250b" translate="yes" xml:space="preserve">
          <source>If you want to compress all</source>
          <target state="translated">如果你想压缩所有的</target>
        </trans-unit>
        <trans-unit id="6bcfdbb5379f221cca1d97f7787d1bc312424003" translate="yes" xml:space="preserve">
          <source>If you want to control warnings on the fly, do something like this. Make sure you do the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; first, or you won't be able to get at the enable() or disable() methods.</source>
          <target state="translated">如果您想即时控制警告，请执行以下操作。确保先 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ，否则将无法使用enable（）或disable（）方法。</target>
        </trans-unit>
        <trans-unit id="a42c1db2cee198b239c3cde06a946cab4e064353" translate="yes" xml:space="preserve">
          <source>If you want to control what functions Test::More will export, you have to use the 'import' option. For example, to import everything but 'fail', you'd do:</source>
          <target state="translated">如果你想控制 Test::More 会导出哪些函数,你必须使用 'import' 选项。例如,要导入除 &quot;fail &quot;以外的所有函数,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="be1e5234b80eb1f923a376bc3491ec3ca6b109b2" translate="yes" xml:space="preserve">
          <source>If you want to convert the returned map to entirely scalar numbers, you can use something like this:</source>
          <target state="translated">如果你想把返回的地图完全转换为标量数,你可以使用类似这样的方法。</target>
        </trans-unit>
        <trans-unit id="5ba04eeea7231f6480afed51584cd45a160a944a" translate="yes" xml:space="preserve">
          <source>If you want to convert to UTF-8 from encodings other than the native (Latin1 or EBCDIC), see &lt;a href=&quot;#sv_recode_to_utf8&quot;&gt;sv_recode_to_utf8&lt;/a&gt;().</source>
          <target state="translated">如果要从非本地编码（Latin1或EBCDIC）转换为UTF-8，请参见&lt;a href=&quot;#sv_recode_to_utf8&quot;&gt;sv_recode_to_utf8&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="53c24008e3ed2beeee61bb3c00b23e9cec000bd1" translate="yes" xml:space="preserve">
          <source>If you want to create many anonymous handles, you should check out the Symbol or IO::Handle modules.</source>
          <target state="translated">如果你想创建许多匿名句柄,你应该查看Symbol或IO::Handle模块。</target>
        </trans-unit>
        <trans-unit id="d3f92af00462a48927ab51881cd3156c2dfab08a" translate="yes" xml:space="preserve">
          <source>If you want to create the file if it does not already exist then bitwise-OR (&lt;code&gt;|&lt;/code&gt;) &lt;code&gt;O_CREAT&lt;/code&gt; too. If you omit &lt;code&gt;O_CREAT&lt;/code&gt; and the database does not already exist then the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call will fail.</source>
          <target state="translated">如果要创建尚不存在的文件，则也可以按位或（ &lt;code&gt;|&lt;/code&gt; ） &lt;code&gt;O_CREAT&lt;/code&gt; 。如果省略 &lt;code&gt;O_CREAT&lt;/code&gt; 并且数据库尚不存在，则 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用将失败。</target>
        </trans-unit>
        <trans-unit id="a116b633c8c619c49052dbd9a5c72113a8975d85" translate="yes" xml:space="preserve">
          <source>If you want to create the file if it does not exist, add &lt;code&gt;O_CREAT&lt;/code&gt; to any of these, as in the example. If you omit &lt;code&gt;O_CREAT&lt;/code&gt; and the file does not already exist, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call will fail.</source>
          <target state="translated">如果要创建不存在的文件，请在示例中将 &lt;code&gt;O_CREAT&lt;/code&gt; 添加到其中的任何一个。如果省略 &lt;code&gt;O_CREAT&lt;/code&gt; 且该文件尚不存在，则 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用将失败。</target>
        </trans-unit>
        <trans-unit id="0e3b712f48285cffa7900ceeb1af82270cd7a609" translate="yes" xml:space="preserve">
          <source>If you want to cycle through an array endlessly, you can increment the index modulo the number of elements in the array:</source>
          <target state="translated">如果你想无休止地循环浏览一个数组,你可以用数组中元素的数量来递增索引。</target>
        </trans-unit>
        <trans-unit id="6cfb6d26bc5df670c402213d4036f3bf58558df4" translate="yes" xml:space="preserve">
          <source>If you want to debug some other testfile, set the &lt;code&gt;TEST_FILE&lt;/code&gt; variable thusly:</source>
          <target state="translated">如果要调试其他测试文件，请按以下方式设置 &lt;code&gt;TEST_FILE&lt;/code&gt; 变量：</target>
        </trans-unit>
        <trans-unit id="b931492f8ba265d923d9e6b394913c2adf2d8e1f" translate="yes" xml:space="preserve">
          <source>If you want to disallow any rearrangement, pass &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;[]&lt;/code&gt; (a reference to empty list) as the value for this key.</source>
          <target state="translated">如果要禁止任何重新排列，请将 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;[]&lt;/code&gt; （对空列表的引用）作为此键的值传递。</target>
        </trans-unit>
        <trans-unit id="e399c3f8eff9b2e3be1dfd1cb3c6e184f3c80005" translate="yes" xml:space="preserve">
          <source>If you want to do something when the object is destroyed, you can define a &lt;code&gt;DESTROY&lt;/code&gt; method in your class. This method will always be called by Perl at the appropriate time, unless the method is empty.</source>
          <target state="translated">如果要在销毁对象时执行某些操作，则可以在类中定义 &lt;code&gt;DESTROY&lt;/code&gt; 方法。除非该方法为空，否则Perl将始终在适当的时间调用此方法。</target>
        </trans-unit>
        <trans-unit id="028499023abecf52141490b3dc52996a2e6540e8" translate="yes" xml:space="preserve">
          <source>If you want to do something with the REGEXP* later use SvRX instead and check for NULL.</source>
          <target state="translated">如果你以后想用REGEXP*做一些事情,就用SvRX代替,并检查是否为NULL。</target>
        </trans-unit>
        <trans-unit id="5bec0b0d71b7e3b535fad4f2a98d0fdea0b5611d" translate="yes" xml:space="preserve">
          <source>If you want to do the same thing to modify the values of the hash, you can use the &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; function. As of Perl 5.6 the values are not copied, so if you modify $orbit (in this case), you modify the value.</source>
          <target state="translated">如果您想做同样的事情来修改哈希值，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 函数。从Perl 5.6开始，不会复制值，因此，如果您修改$ orbit（在这种情况下），则会修改该值。</target>
        </trans-unit>
        <trans-unit id="1befe6f0c8cce90a523721cdcb6a3e759a8bf613" translate="yes" xml:space="preserve">
          <source>If you want to downgrade a warning that has been escalated into a fatal error back to a normal warning, you can use the &quot;NONFATAL&quot; keyword. For example, the code below will promote all warnings into fatal errors, except for those in the &quot;syntax&quot; category.</source>
          <target state="translated">如果你想把已经升级为致命错误的警告降级为正常警告,可以使用 &quot;NONFATAL &quot;关键字。例如,下面的代码将把所有的警告升级为致命错误,除了那些 &quot;语法 &quot;类的警告。</target>
        </trans-unit>
        <trans-unit id="aaac7464ef1e41e8e3656bb3c9f1373b9810c3d2" translate="yes" xml:space="preserve">
          <source>If you want to encode a large file, you should encode it in chunks that are a multiple of 57 bytes. This ensures that the base64 lines line up and that you do not end up with padding in the middle. 57 bytes of data fills one complete base64 line (76 == 57*4/3):</source>
          <target state="translated">如果你想对一个大文件进行编码,你应该以57字节的倍数进行编码。这可以确保base64行的行数,而且你不会在中间有填充物。57个字节的数据填满一个完整的base64行(76 ==57*4/3)。</target>
        </trans-unit>
        <trans-unit id="526764856cb11f1625c51adabbc0827d170cf65b" translate="yes" xml:space="preserve">
          <source>If you want to enter a multi-line command, such as a subroutine definition with several statements or a format, escape the newline that would normally end the debugger command with a backslash. Here's an example:</source>
          <target state="translated">如果你想输入一个多行命令,比如一个子程序定义有几条语句或一个格式,请用反斜杠转义通常会结束调试器命令的新行。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="1c27e6ce335738d835ec3fdd82f6c0809ffefc5e" translate="yes" xml:space="preserve">
          <source>If you want to find out how many characters are waiting, there's also the FIONREAD ioctl call to be looked at. The</source>
          <target state="translated">如果你想知道有多少字符在等待,还可以看看FIONREAD ioctl调用。这个</target>
        </trans-unit>
        <trans-unit id="1da1084e18df9224120de5015e0f47b55cae04d1" translate="yes" xml:space="preserve">
          <source>If you want to find out how many entries have a defined value, that's a bit different. You have to check each value. A &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; is handy:</source>
          <target state="translated">如果要找出有多少个条目具有定义的值，那有点不同。您必须检查每个值。一个 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 很方便：</target>
        </trans-unit>
        <trans-unit id="308cd4ff0bf951ae1c4968d0825997ff4ae0e702" translate="yes" xml:space="preserve">
          <source>If you want to find the package calling your code, perhaps to give better diagnostics as &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; does, use the &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; built-in:</source>
          <target state="translated">如果您想找到调用您代码的包，也许像&lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt;一样可以提供更好的诊断，请使用内置的 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 程序：</target>
        </trans-unit>
        <trans-unit id="e1f109680f15bd3886268c0dd93d91471450a599" translate="yes" xml:space="preserve">
          <source>If you want to get at a slice (part of a row) in a multidimensional array, you're going to have to do some fancy subscripting. That's because while we have a nice synonym for single elements via the pointer arrow for dereferencing, no such convenience exists for slices.</source>
          <target state="translated">如果你想在一个多维数组中获取一个切片(行的一部分),你将不得不做一些花哨的下标。这是因为,虽然我们有一个很好的同义词,可以通过指针箭头来实现单元素的取消引用,但对于切片却没有这样的便利。</target>
        </trans-unit>
        <trans-unit id="ac8d06c0714514adee4900ccc907acf01c17734d" translate="yes" xml:space="preserve">
          <source>If you want to get warned when the fallback occurs, replace &quot;try&quot; with &quot;lib&quot;:</source>
          <target state="translated">如果你想在回退发生时得到警告,用 &quot;lib &quot;代替 &quot;try&quot;。</target>
        </trans-unit>
        <trans-unit id="c34f1861cd969edfd158d72b53e2b8bf861c0838" translate="yes" xml:space="preserve">
          <source>If you want to have arrays of constant strings, note carefully the right combination of &lt;code&gt;const&lt;/code&gt; s:</source>
          <target state="translated">如果要使用常量字符串数组，请仔细注意 &lt;code&gt;const&lt;/code&gt; 的正确组合：</target>
        </trans-unit>
        <trans-unit id="cc85c01bbb2e5546a912901548bde68e7f312959" translate="yes" xml:space="preserve">
          <source>If you want to have static strings, make them constant:</source>
          <target state="translated">如果你想拥有静态字符串,就把它们变成常量。</target>
        </trans-unit>
        <trans-unit id="5f28aad16a41ad668dc6d2a20ee81e5f9b0af321" translate="yes" xml:space="preserve">
          <source>If you want to have your cake and eat it too, you need a more complicated boilerplate.</source>
          <target state="translated">如果你想吃你的蛋糕,也想吃它,你需要一个更复杂的模板。</target>
        </trans-unit>
        <trans-unit id="732754bf3b16a13d947b836156896a3b2cedc031" translate="yes" xml:space="preserve">
          <source>If you want to indent the text in the here document, you can do this:</source>
          <target state="translated">如果你想在这里的文档中缩进文字,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="d6b9e98bf75fad13fa324d37df3fb0822a303c98" translate="yes" xml:space="preserve">
          <source>If you want to influence compilation of calls to a specific subroutine, then use &lt;a href=&quot;#cv_set_call_checker&quot;&gt;cv_set_call_checker&lt;/a&gt; rather than hooking checking of all &lt;code&gt;entersub&lt;/code&gt; ops.</source>
          <target state="translated">如果要影响对特定子例程的调用的编译，请使用&lt;a href=&quot;#cv_set_call_checker&quot;&gt;cv_set_call_checker&lt;/a&gt;而不是对所有 &lt;code&gt;entersub&lt;/code&gt; op进行挂钩检查。</target>
        </trans-unit>
        <trans-unit id="168d6eb05b72021bb2cefd5586f5642721fb25b0" translate="yes" xml:space="preserve">
          <source>If you want to install a distribution from the current directory, you can tell &lt;code&gt;CPAN.pm&lt;/code&gt; to install &lt;code&gt;.&lt;/code&gt; (the full stop):</source>
          <target state="translated">如果要从当前目录安装发行版，可以告诉 &lt;code&gt;CPAN.pm&lt;/code&gt; 安装 &lt;code&gt;.&lt;/code&gt; （句号）：</target>
        </trans-unit>
        <trans-unit id="33e2d2f8b434b4a1cc7c6346d405264c8380bf51" translate="yes" xml:space="preserve">
          <source>If you want to install modules for your own use, the easiest way might be &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local::lib&lt;/a&gt;, which you can download from CPAN. It sets various installation settings for you, and uses those same settings within your programs.</source>
          <target state="translated">如果要安装自己使用的模块，最简单的方法可能是&lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local :: lib&lt;/a&gt;，可以从CPAN下载。它为您设置各种安装设置，并在程序中使用相同的设置。</target>
        </trans-unit>
        <trans-unit id="58d2dc539671f427bbae58845aceababd0159c6c" translate="yes" xml:space="preserve">
          <source>If you want to know as little about Perl as possible but need to add a new encoding, just read this chapter and forget the rest.</source>
          <target state="translated">如果你想尽可能少地了解Perl,但又需要添加一个新的编码,只要读完这一章,其他的就不用管了。</target>
        </trans-unit>
        <trans-unit id="56e1fbcaca6130206229f6c3c8cb0c2d52fb54b7" translate="yes" xml:space="preserve">
          <source>If you want to know how Perl OO works under the hood, the &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; document explains the nitty gritty details.</source>
          <target state="translated">如果您想了解Perl OO的&lt;a href=&quot;perlobj&quot;&gt;幕后&lt;/a&gt;工作原理，请参阅perlobj文档，以了解具体细节。</target>
        </trans-unit>
        <trans-unit id="9f23a106d53e80c8c0f8d1f2b0c84d08d1054140" translate="yes" xml:space="preserve">
          <source>If you want to know how to handle automated testing for your distribution, you can check the environment. The CPAN Testers, for instance, set the value of &lt;code&gt;AUTOMATED_TESTING&lt;/code&gt; :</source>
          <target state="translated">如果您想知道如何处理发行版的自动化测试，则可以检查环境。例如，CPAN测试器设置 &lt;code&gt;AUTOMATED_TESTING&lt;/code&gt; 的值：</target>
        </trans-unit>
        <trans-unit id="1a57ed6abdc67a27c928054414c38fcc1c565d58" translate="yes" xml:space="preserve">
          <source>If you want to know if the scalar value is TRUE, you can use:</source>
          <target state="translated">如果你想知道标量值是否为TRUE,你可以使用。</target>
        </trans-unit>
        <trans-unit id="f0f2be398a4f429a704b8881af39ff31858188bb" translate="yes" xml:space="preserve">
          <source>If you want to know if this variable (or any other SV) is actually &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt;, you can call:</source>
          <target state="translated">如果您想知道是否实际 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 此变量（或任何其他SV），可以调用：</target>
        </trans-unit>
        <trans-unit id="4282549729bb35373ef94d2e2b64ea8af51a5d06" translate="yes" xml:space="preserve">
          <source>If you want to know whether a particular scalar refers to an object, you can use the &lt;code&gt;blessed&lt;/code&gt; function exported by &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;, which is shipped with the Perl core.</source>
          <target state="translated">如果您想知道特定的标量是否指向对象，可以使用Perl核心附带的&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;导出的 &lt;code&gt;blessed&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="056d8ddf16a11d708261878d4f200cc28e75de75" translate="yes" xml:space="preserve">
          <source>If you want to learn more about Perl 6, or have a desire to help in the crusade to make Perl a better place then read the Perl 6 developers page at &lt;a href=&quot;http://www.perl6.org/&quot;&gt;http://www.perl6.org/&lt;/a&gt; and get involved.</source>
          <target state="translated">如果您想了解有关Perl 6的更多信息，或者希望帮助他们使Perl变得更好，请阅读位于&lt;a href=&quot;http://www.perl6.org/&quot;&gt;http://www.perl6.org/&lt;/a&gt;的Perl 6开发人员页面，并参与其中。</target>
        </trans-unit>
        <trans-unit id="00255f60e5cd77d55f44acd05aa25f0d59366611" translate="yes" xml:space="preserve">
          <source>If you want to learn the basics of Perl, you might start with the Llama book, which assumes that you already know a little about programming:</source>
          <target state="translated">如果你想学习Perl的基础知识,你可以从Llama这本书开始,这本书假设你已经对编程有一点了解。</target>
        </trans-unit>
        <trans-unit id="859f839c744c136d7bdf5037e58bd0e9887e2618" translate="yes" xml:space="preserve">
          <source>If you want to load a subclass from a file that &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; would not consider an eligible filename (that is, it does not end in either &lt;code&gt;.pm&lt;/code&gt; or &lt;code&gt;.pmc&lt;/code&gt;), use the following code:</source>
          <target state="translated">如果要从 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 不考虑合格文件名的文件中加载子类（即，文件名不以 &lt;code&gt;.pm&lt;/code&gt; 或 &lt;code&gt;.pmc&lt;/code&gt; 结尾），请使用以下代码：</target>
        </trans-unit>
        <trans-unit id="63bacba7c0db3c9f406fbf3ba9dec50a07c74303" translate="yes" xml:space="preserve">
          <source>If you want to load the entire file, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Path::Tiny&quot;&gt;Path::Tiny&lt;/a&gt; module to do it in one simple and efficient step:</source>
          <target state="translated">如果要加载整个文件，可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/Path::Tiny&quot;&gt;Path :: Tiny&lt;/a&gt;模块通过一个简单而有效的步骤来完成它：</target>
        </trans-unit>
        <trans-unit id="b17927939e60f1cedd222b2461104e02f72f02d9" translate="yes" xml:space="preserve">
          <source>If you want to make a real copy, use the following:</source>
          <target state="translated">如果你想做一个真正的副本,请使用以下方法。</target>
        </trans-unit>
        <trans-unit id="011cab076badf929a664e79819f2251ac21c5335" translate="yes" xml:space="preserve">
          <source>If you want to make the SV drop its string buffer, use &lt;code&gt;sv_force_normal_flags(sv, SV_COW_DROP_PV)&lt;/code&gt; or simply &lt;code&gt;sv_setsv(sv, NULL)&lt;/code&gt; .</source>
          <target state="translated">如果要使SV删除其字符串缓冲区，请使用 &lt;code&gt;sv_force_normal_flags(sv, SV_COW_DROP_PV)&lt;/code&gt; 或仅使用 &lt;code&gt;sv_setsv(sv, NULL)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b7523637fc2645186f899696d73931e051d6c52" translate="yes" xml:space="preserve">
          <source>If you want to make use of the new features available in Berkeley DB 2.x or greater, use the Perl module &lt;b&gt;BerkeleyDB&lt;/b&gt; instead.</source>
          <target state="translated">如果要利用Berkeley DB 2.x或更高版本中可用的新功能，请改用Perl模块&lt;b&gt;BerkeleyDB&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="610bb38fb99d325c8e7fefe0a23a02b343634382" translate="yes" xml:space="preserve">
          <source>If you want to modify the debugger, copy</source>
          <target state="translated">如果你想修改调试器,请复制</target>
        </trans-unit>
        <trans-unit id="68a89277cf24a3194f901f3f723f1840c4c2f27b" translate="yes" xml:space="preserve">
          <source>If you want to open either STDIN or STDOUT with &lt;code&gt;gzopen&lt;/code&gt; , you can now optionally use the special filename &quot;&lt;code&gt;-&lt;/code&gt; &quot; as a synonym for &lt;code&gt;\*STDIN&lt;/code&gt; and &lt;code&gt;\*STDOUT&lt;/code&gt; .</source>
          <target state="translated">如果要使用 &lt;code&gt;gzopen&lt;/code&gt; 打开STDIN或STDOUT ，则现在可以选择使用特殊文件名&amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;rdquo;作为 &lt;code&gt;\*STDIN&lt;/code&gt; 和 &lt;code&gt;\*STDOUT&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="e41fd5af244837759f6e880c0fa8c36bc7f07f26" translate="yes" xml:space="preserve">
          <source>If you want to overload a Perl operator, such as &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;**&lt;/code&gt; , then you'll want to use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; pragma, documented in &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;.</source>
          <target state="translated">如果要重载Perl运算符（例如 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;**&lt;/code&gt; )，则需要使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 编译指示，该&lt;a href=&quot;overload&quot;&gt;重载&lt;/a&gt;记录在重载中。</target>
        </trans-unit>
        <trans-unit id="945aa8bcea0076aea35d4a81e4ba840ff11ec82e" translate="yes" xml:space="preserve">
          <source>If you want to override a predefined function, such as open(), then you'll have to import the new definition from a different module. See &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;Overriding Built-in Functions in perlsub&lt;/a&gt;.</source>
          <target state="translated">如果要覆盖预定义的函数，例如open（），则必须从其他模块导入新定义。请参见&lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;在perlsub中重写内置函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa48921f25a631295f915526fc8a70c73af7fbf8" translate="yes" xml:space="preserve">
          <source>If you want to override the mapping of Hangul syllables, NFD and NFKD are not appropriate, since NFD and NFKD will decompose Hangul syllables before overriding. FCD may decompose Hangul syllables as the case may be.</source>
          <target state="translated">如果要覆盖Hangul音节的映射,NFD和NFKD是不合适的,因为NFD和NFKD会在覆盖之前分解Hangul音节。FCD可以根据情况分解Hangul音节。</target>
        </trans-unit>
        <trans-unit id="5c827c3a5508b73a4c675d093f91220233b7dc11" translate="yes" xml:space="preserve">
          <source>If you want to pass arguments to the Perl subroutine, you can add strings to the &lt;code&gt;NULL&lt;/code&gt; -terminated &lt;code&gt;args&lt;/code&gt; list passed to</source>
          <target state="translated">如果要将参数传递给Perl子例程，则可以将字符串添加到传递给 &lt;code&gt;NULL&lt;/code&gt; 终止的 &lt;code&gt;args&lt;/code&gt; 列表中</target>
        </trans-unit>
        <trans-unit id="5c0b08e235edf0d26d308eb349b59ea3ef72cb9d" translate="yes" xml:space="preserve">
          <source>If you want to pass more than one array or hash into a function--or return them from it--and have them maintain their integrity, then you're going to have to use an explicit pass-by-reference. Before you do that, you need to understand references as detailed in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. This section may not make much sense to you otherwise.</source>
          <target state="translated">如果您想将多个数组或哈希传递给一个函数（或从中返回它们）并保持它们的完整性，那么您将不得不使用显式的按引用传递。在此之前，您需要了解&lt;a href=&quot;perlref&quot;&gt;perlref中&lt;/a&gt;详细介绍的参考。否则，本节对您可能没有多大意义。</target>
        </trans-unit>
        <trans-unit id="c8a70766df71ba2d4b4ce04954ec69dff30a7c0f" translate="yes" xml:space="preserve">
          <source>If you want to pass switches into your script, you can use one of the &lt;code&gt;Getopts&lt;/code&gt; modules or put a loop on the front like this:</source>
          <target state="translated">如果要将开关传递到脚本中，则可以使用 &lt;code&gt;Getopts&lt;/code&gt; 模块之一，也可以像这样在前面放置一个循环：</target>
        </trans-unit>
        <trans-unit id="f4bd2c5192aedd065d255be14f3583448bb4e171" translate="yes" xml:space="preserve">
          <source>If you want to port your own favourite c-lib for big numbers to the Math::BigInt interface, you can take any of the already existing modules as a rough guideline. You should really wrap up the latest BigInt and BigFloat testsuites with your module, and replace in them any of the following:</source>
          <target state="translated">如果你想把你自己喜欢的大数c-lib移植到Math::BigInt接口上,你可以把任何一个已经存在的模块作为一个粗略的指导方针。你应该将最新的BigInt和BigFloat测试套件与你的模块一起打包,并替换其中的任何一个模块。</target>
        </trans-unit>
        <trans-unit id="376b22a241cce9ba252fd1c8a6df064f6b6eac08" translate="yes" xml:space="preserve">
          <source>If you want to position the file for &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;, don't use &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, because buffering makes its effect on the file's read-write position unpredictable and non-portable. Use &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果要将文件定位为 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; ，请不要使用 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; ，因为缓冲会使它对文件的读写位置的影响不可预测且不可移植。请改用 &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab53baa73269bc54f793e2d56860c5115ebd11f4" translate="yes" xml:space="preserve">
          <source>If you want to position the file for &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;, don't use &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, because buffering makes its effect on the file's read-write position unpredictable and non-portable. Use &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果要将文件定位为 &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; ，请不要使用 &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; ，因为缓冲会使它对文件的读写位置的影响不可预测且不可移植。请改用 &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0c3e6b22044730d55d9a0c06443157660dba6ef" translate="yes" xml:space="preserve">
          <source>If you want to preserve any existing contents, then you want to open the file in append mode. As in the shell, in Perl you use &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; to open an existing file in append mode. &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; creates the file if it does not already exist.</source>
          <target state="translated">如果要保留任何现有内容，则要以附加模式打开文件。与在Shell中一样，在Perl中，您可以使用 &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 以附加模式打开现有文件。如果文件不存在，则 &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 创建该文件。</target>
        </trans-unit>
        <trans-unit id="17bd731415d5d66dc3d1ddceae18e6e16a628145" translate="yes" xml:space="preserve">
          <source>If you want to preserve the original hashes, copy one hash (&lt;code&gt;%hash1&lt;/code&gt; ) to a new hash (&lt;code&gt;%new_hash&lt;/code&gt; ), then add the keys from the other hash (&lt;code&gt;%hash2&lt;/code&gt; to the new hash. Checking that the key already exists in &lt;code&gt;%new_hash&lt;/code&gt; gives you a chance to decide what to do with the duplicates:</source>
          <target state="translated">如果要保留原始哈希， &lt;code&gt;%hash1&lt;/code&gt; 一个哈希（％hash1）复制到新哈希（ &lt;code&gt;%new_hash&lt;/code&gt; ），然后将另一个哈希（ &lt;code&gt;%hash2&lt;/code&gt; ）中的密钥添加到新哈希中。检查密钥是否已存在于 &lt;code&gt;%new_hash&lt;/code&gt; 中让您有机会决定如何处理重复项：</target>
        </trans-unit>
        <trans-unit id="50f7b3c025841bfcdb1aab514c8e2d8e36fbc766" translate="yes" xml:space="preserve">
          <source>If you want to print the whole thing, though, you can't say</source>
          <target state="translated">不过,如果你想把整个事情打印出来,你不能说</target>
        </trans-unit>
        <trans-unit id="93f1e3a9ebfe45627e0241306de345142f514db8" translate="yes" xml:space="preserve">
          <source>If you want to provide config to the source you can use:</source>
          <target state="translated">如果你想为源码提供配置,你可以使用。</target>
        </trans-unit>
        <trans-unit id="9f3a66952ab51429c329502faae26a704977a338" translate="yes" xml:space="preserve">
          <source>If you want to read a gzip file a line at a time and have it respect the &lt;code&gt;$/&lt;/code&gt; variable (or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; , or &lt;code&gt;$RS&lt;/code&gt; when &lt;code&gt;English&lt;/code&gt; is in use) see &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt;.</source>
          <target state="translated">如果你想读一个gzip文件在一个时间线，并把它尊重 &lt;code&gt;$/&lt;/code&gt; 变量（或 &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; ，或 &lt;code&gt;$RS&lt;/code&gt; 当 &lt;code&gt;English&lt;/code&gt; 在使用中）看到&lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO ::解压缩::用gunzip&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d31f53859a4168c72e90a2128210958319d4f50" translate="yes" xml:space="preserve">
          <source>If you want to read from a text file, first open it in read-only mode like this:</source>
          <target state="translated">如果你想从一个文本文件中读取,首先以只读模式打开它,像这样。</target>
        </trans-unit>
        <trans-unit id="d4ab6b15624972e8c18a42d8d83c1cd6a30cfb30" translate="yes" xml:space="preserve">
          <source>If you want to release a 'beta' or 'alpha' version of a module but don't want CPAN.pm to list it as most recent use an '_' after the regular version number followed by at least 2 digits, eg. 1.20_01. If you do this, the following idiom is recommended:</source>
          <target state="translated">如果您想发布一个模块的 &quot;beta &quot;或 &quot;alpha &quot;版本,但又不想让CPAN.pm把它列为最新版本,请在常规版本号后面加上一个&quot;_&quot;,后面至少跟两个数字,例如:1.20_01。如果您这样做,建议使用以下的习惯用语。</target>
        </trans-unit>
        <trans-unit id="aec7d886a6e5c93bd394402ec290052fc195c585" translate="yes" xml:space="preserve">
          <source>If you want to remove the line terminator from your here-docs, use &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果要从here-docs中删除行终止符，请使用 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db615c188722d8560c52e776e317416a34e011c1" translate="yes" xml:space="preserve">
          <source>If you want to report a bug in Perl, you must use the</source>
          <target state="translated">如果你想报告Perl中的一个错误,你必须使用</target>
        </trans-unit>
        <trans-unit id="f2154f64aff6e9940c9fb796b1289c8d854d7ca5" translate="yes" xml:space="preserve">
          <source>If you want to represent quotation marks inside a quotation-mark-delimited field, escape them with backslashes (eg, &lt;code&gt;&quot;like \&quot;this\&quot;&quot;&lt;/code&gt; .</source>
          <target state="translated">如果要在用引号引起来的字段中表示引号，请使用反斜杠对其进行转义（例如 &lt;code&gt;&quot;like \&quot;this\&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="824f7654e0ed811f4acc48396871cdac5a94cdda" translate="yes" xml:space="preserve">
          <source>If you want to retain the UTF-x code points then in script form you might want to write:</source>
          <target state="translated">如果你想保留UTF-x码点,那么在脚本形式下,你可以写。</target>
        </trans-unit>
        <trans-unit id="2c2c9c1a65a810709ccd4ab8e9bc83e0091df0bc" translate="yes" xml:space="preserve">
          <source>If you want to retrieve the time at which the file was last read, written, or had its meta-data (owner, etc) changed, you use the &lt;b&gt;-A&lt;/b&gt;, &lt;b&gt;-M&lt;/b&gt;, or &lt;b&gt;-C&lt;/b&gt; file test operations as documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. These retrieve the age of the file (measured against the start-time of your program) in days as a floating point number. Some platforms may not have all of these times. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for details. To retrieve the &quot;raw&quot; time in seconds since the epoch, you would call the stat function, then use &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;POSIX::strftime()&lt;/code&gt; to convert this into human-readable form.</source>
          <target state="translated">如果要检索文件的上一次读取，写入或更改其元数据（所有者等）的时间，请使用&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;记录的&lt;b&gt;-A&lt;/b&gt;，&lt;b&gt;-M&lt;/b&gt;或&lt;b&gt;-C&lt;/b&gt;文件测试操作。它们以天为单位检索文件的生存期（以程序的开始时间为准），以天为单位。某些平台可能没有所有这些时间。有关详细信息，请参见&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;。要检索自该纪元以来的&amp;ldquo;原始&amp;rdquo;时间（以秒为单位），您可以调用stat函数，然后使用 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;POSIX::strftime()&lt;/code&gt; 将其转换为人类可读的形式。</target>
        </trans-unit>
        <trans-unit id="ea86bc2e0842c32d086b82e0b936c78284136301" translate="yes" xml:space="preserve">
          <source>If you want to run an external command and still keep your Perl process going, look at a piped &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果您想运行外部命令并且仍然保持Perl进程继续进行，请查看管道的 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ec243e8883915ce98e61a2fb629a6bec35df46c" translate="yes" xml:space="preserve">
          <source>If you want to run any of the tests yourself manually using e.g. valgrind, please note that by default perl &lt;b&gt;does not&lt;/b&gt; explicitly cleanup all the memory it has allocated (such as global memory arenas) but instead lets the exit() of the whole program &quot;take care&quot; of such allocations, also known as &quot;global destruction of objects&quot;.</source>
          <target state="translated">如果您想使用valgrind等手动运行任何测试，请注意，默认情况下，perl &lt;b&gt;不会&lt;/b&gt;显式清除其已分配的所有内存（例如全局内存竞技场），而是让整个程序的exit（）照顾&amp;rdquo;这样的分配，也称为&amp;ldquo;对象的全局销毁&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c579d4f4691b7da6dbe69f3dde05c84842ed87a2" translate="yes" xml:space="preserve">
          <source>If you want to run particular test files, set the &lt;code&gt;TEST_FILES&lt;/code&gt; variable. It is possible to use globbing with this mechanism.</source>
          <target state="translated">如果要运行特定的测试文件，请设置 &lt;code&gt;TEST_FILES&lt;/code&gt; 变量。可以通过这种机制使用globbing。</target>
        </trans-unit>
        <trans-unit id="cab446873fde6bc4766b7caa4c1c83cdf5ad957d" translate="yes" xml:space="preserve">
          <source>If you want to see the command History, type an '&lt;b&gt;H&lt;/b&gt;':</source>
          <target state="translated">如果要查看历史记录命令，请输入&amp;ldquo; &lt;b&gt;H&lt;/b&gt; &amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="852c71f5265989b791fcb0bad50a31c13ad56ee6" translate="yes" xml:space="preserve">
          <source>If you want to see what perl is doing when parsing/lexing your code, you can use &lt;code&gt;BEGIN {}&lt;/code&gt; :</source>
          <target state="translated">如果您想查看在解析/编写代码时perl在做什么，可以使用 &lt;code&gt;BEGIN {}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3175d2c86530c83d13669e65994d9eb74402053d" translate="yes" xml:space="preserve">
          <source>If you want to see what the parser/lexer is doing inside of &lt;code&gt;if&lt;/code&gt; blocks and the like you need to be a little trickier:</source>
          <target state="translated">如果要查看解析器/词法分析器在 &lt;code&gt;if&lt;/code&gt; 块等内部的工作，则需要增加一些技巧：</target>
        </trans-unit>
        <trans-unit id="8bca41d076fff99126cd66f621ea4770f98d22fe" translate="yes" xml:space="preserve">
          <source>If you want to select on many filehandles, you may wish to write a subroutine like this:</source>
          <target state="translated">如果你想在许多文件柄上进行选择,你可能希望写一个像这样的子程序。</target>
        </trans-unit>
        <trans-unit id="933790916a521b582a0514fa93b65b7620fb02f6" translate="yes" xml:space="preserve">
          <source>If you want to separate your lines with something other than &lt;code&gt;\n&lt;/code&gt; then set &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; to your preference. This replaces all newlines with &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; . If you just want to preserve existing newlines but add new breaks with something else, set &lt;code&gt;$Text::Wrap::separator2&lt;/code&gt; instead.</source>
          <target state="translated">如果要用 &lt;code&gt;\n&lt;/code&gt; 以外的内容分隔行，则将 &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; 为您的首选项。这将所有换行符替换为 &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; 。如果您只想保留现有的换行符，但添加其他新的换行符，请设置 &lt;code&gt;$Text::Wrap::separator2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f22c0f1a9c1e2e9b3f3593f17d9d5d341e79a144" translate="yes" xml:space="preserve">
          <source>If you want to set &lt;code&gt;@ARGV&lt;/code&gt; to your own list of files, go right ahead. This sets &lt;code&gt;@ARGV&lt;/code&gt; to all plain text files if no &lt;code&gt;@ARGV&lt;/code&gt; was given:</source>
          <target state="translated">如果要将 &lt;code&gt;@ARGV&lt;/code&gt; 设置为自己的文件列表，请继续。如果未提供 &lt;code&gt;@ARGV&lt;/code&gt; ，则会将 &lt;code&gt;@ARGV&lt;/code&gt; 设置为所有纯文本文件：</target>
        </trans-unit>
        <trans-unit id="c597fab938b142e9f257da003c8529a2b550cc0b" translate="yes" xml:space="preserve">
          <source>If you want to set your encoding layers based on your locale environment variables, you can use the &lt;code&gt;:locale&lt;/code&gt; tag. For example:</source>
          <target state="translated">如果要基于区域设置环境变量设置编码层，则可以使用 &lt;code&gt;:locale&lt;/code&gt; 标记。例如：</target>
        </trans-unit>
        <trans-unit id="f93a5a664c0fedc0848a47a9e0bdfdba8a57c6b9" translate="yes" xml:space="preserve">
          <source>If you want to specify perl options &lt;code&gt;-my_opts&lt;/code&gt; to the perl itself (as opposed to your program), use</source>
          <target state="translated">如果要为perl本身（与程序相反）指定perl选项 &lt;code&gt;-my_opts&lt;/code&gt; ，请使用</target>
        </trans-unit>
        <trans-unit id="16a2b27e854284e5624b52325615871e56858329" translate="yes" xml:space="preserve">
          <source>If you want to specify the version of Perl, but don't care about the version of the module, pass &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for the module version:</source>
          <target state="translated">如果要指定Perl的版本，但不关心模块的版本，请为模块版本传递 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4170c2908419d9f1f4a325cd881e413a4558b490" translate="yes" xml:space="preserve">
          <source>If you want to suppress man page installation for all modules you have to reconfigure Perl and tell it 'none' when it asks where to install man pages.</source>
          <target state="translated">如果你想抑制所有模块的man page安装,你必须重新配置Perl,并在它询问安装man page的位置时告诉它 &quot;none&quot;。</target>
        </trans-unit>
        <trans-unit id="73be2d5223229972e63c46363d25a8b4ecd5d388" translate="yes" xml:space="preserve">
          <source>If you want to take advantage of this new implicit dereferencing behavior, go right ahead: it makes code easier on the eye and wrist. Just understand that older releases will choke on it during compilation. Whenever you make use of something that works only in some given release of Perl and later, but not earlier, you should place a prominent</source>
          <target state="translated">如果你想利用这种新的隐式解除引用行为,请继续:它使代码更容易看清,也更方便。只是要明白,旧版本在编译过程中会被它噎住。每当你使用一些只在某个给定的Perl版本及以后的版本中工作的东西,而不是在更早的版本中工作的东西时,你应该把一个突出的</target>
        </trans-unit>
        <trans-unit id="e1677e0d939fbca31e3c5c86eaef838b1e761cee" translate="yes" xml:space="preserve">
          <source>If you want to take into account the &lt;a href=&quot;bytes&quot;&gt;bytes&lt;/a&gt; pragma, use &lt;code&gt;&lt;a href=&quot;#DO_UTF8&quot;&gt;DO_UTF8&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果要考虑&lt;a href=&quot;bytes&quot;&gt;字节&lt;/a&gt;编译指示，请改用 &lt;code&gt;&lt;a href=&quot;#DO_UTF8&quot;&gt;DO_UTF8&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be8af06e2253191bf1cfa1761503b16d4281bf21" translate="yes" xml:space="preserve">
          <source>If you want to trap errors when loading an XS module, some problems with the binary interface (such as Perl version skew) may be fatal even with &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; unless &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; is set. See &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">如果要在加载XS模块时捕获错误，则除非设置 &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; 否则即使使用 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，二进制接口的某些问题（例如Perl版本偏斜）也可能是致命的。参见&lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7dc2a0aef2f5b8c2b438b365b49a4c2f0d40f6ac" translate="yes" xml:space="preserve">
          <source>If you want to trap errors when loading an XS module, some problems with the binary interface (such as Perl version skew) may be fatal even with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; unless &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; is set. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">如果要在加载XS模块时捕获错误，则除非设置 &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; 否则即使使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，二进制接口的某些问题（例如Perl版本偏斜）也可能是致命的。参见&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6ffd07b12749a1692d47d579873dc74d6c4dfaf" translate="yes" xml:space="preserve">
          <source>If you want to try to install a distribution by yourself, resolving all dependencies on your own, you follow one of two possible build paths.</source>
          <target state="translated">如果你想尝试自己安装一个发行版,自己解决所有的依赖关系,你遵循两种可能的构建路径之一。</target>
        </trans-unit>
        <trans-unit id="fbe14747549d8ad4516b4e89ba086fe45d5bc952" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;$.&lt;/code&gt; , you can reduce it to a simple one-liner, like one of these:</source>
          <target state="translated">如果要使用 &lt;code&gt;$.&lt;/code&gt; ，您可以将其简化为简单的一线式，例如以下一种：</target>
        </trans-unit>
        <trans-unit id="638caf8fdb384503ed24e0af4c2fa1fdaedcfe89" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; to time out a system call you need to use an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; pair. You can't rely on the alarm causing the system call to fail with &lt;code&gt;$!&lt;/code&gt; set to &lt;code&gt;EINTR&lt;/code&gt; because Perl sets up signal handlers to restart system calls on some systems. Using &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; always works, modulo the caveats given in &lt;a href=&quot;../perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt;.</source>
          <target state="translated">如果要使用 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 使系统调用超时，则需要使用 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 对。您不能依靠导致 &lt;code&gt;$!&lt;/code&gt; 的系统调用失败的警报！设置为 &lt;code&gt;EINTR&lt;/code&gt; 是因为Perl设置了信号处理程序以重新启动某些系统上的系统调用。使用 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 始终有效，&lt;a href=&quot;../perlipc#Signals&quot;&gt;以perlipc&lt;/a&gt;中的Signals中给出的警告为模。</target>
        </trans-unit>
        <trans-unit id="47fc081d4f98f1098211a1c78312dbb51873804c" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; to time out a system call you need to use an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; pair. You can't rely on the alarm causing the system call to fail with &lt;code&gt;$!&lt;/code&gt; set to &lt;code&gt;EINTR&lt;/code&gt; because Perl sets up signal handlers to restart system calls on some systems. Using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; always works, modulo the caveats given in &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt;.</source>
          <target state="translated">如果要使用 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 使系统调用超时，则需要使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 对。您不能依靠导致 &lt;code&gt;$!&lt;/code&gt; 的系统调用失败的警报！设置为 &lt;code&gt;EINTR&lt;/code&gt; 是因为Perl设置了信号处理程序以重新启动某些系统上的系统调用。使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 始终有效，&lt;a href=&quot;perlipc#Signals&quot;&gt;以perlipc&lt;/a&gt;中的Signals中给出的警告为模。</target>
        </trans-unit>
        <trans-unit id="95a0ee4afc73cc3c28bb4ee34fc5e5c78c608e7d" translate="yes" xml:space="preserve">
          <source>If you want to use Perl on a non-z/OS EBCDIC machine, please let us know by sending mail to perlbug@perl.org</source>
          <target state="translated">如果你想在非z/OS的EBCDIC机器上使用Perl,请通过发送邮件到 perlbug@perl.org 告诉我们。</target>
        </trans-unit>
        <trans-unit id="e5b580ca1f65ec0f5a604fbeb668e8741070d520" translate="yes" xml:space="preserve">
          <source>If you want to use Perl on the Hurd, I recommend using the Debian GNU/Hurd distribution ( see &lt;a href=&quot;http://www.debian.org/&quot;&gt;http://www.debian.org/&lt;/a&gt; ), even if an official, stable release has not yet been made. The old &quot;gnu-0.2&quot; binary distribution will most certainly have additional problems.</source>
          <target state="translated">如果您想在Hurd上使用Perl，我建议您使用Debian GNU / Hurd发行版（请参阅&lt;a href=&quot;http://www.debian.org/&quot;&gt;http://www.debian.org/&lt;/a&gt;），即使尚未发布正式的稳定版本。当然，旧的&amp;ldquo; gnu-0.2&amp;rdquo;二进制发行版肯定会存在其他问题。</target>
        </trans-unit>
        <trans-unit id="7687d514ed5fdcc15efde5d3bf9ba63b53f53add" translate="yes" xml:space="preserve">
          <source>If you want to use a module, try the &lt;code&gt;uniq&lt;/code&gt; function from &lt;a href=&quot;http://search.cpan.org/perldoc/List::MoreUtils&quot;&gt;List::MoreUtils&lt;/a&gt;. In list context it returns the unique elements, preserving their order in the list. In scalar context, it returns the number of unique elements.</source>
          <target state="translated">如果要使用模块，请尝试使用&lt;a href=&quot;http://search.cpan.org/perldoc/List::MoreUtils&quot;&gt;List :: MoreUtils中&lt;/a&gt;的 &lt;code&gt;uniq&lt;/code&gt; 函数。在列表上下文中，它返回唯一元素，并在列表中保留其顺序。在标量上下文中，它返回唯一元素的数量。</target>
        </trans-unit>
        <trans-unit id="655bd3463f5ce3b5ada699426719c6ddc69d4f2a" translate="yes" xml:space="preserve">
          <source>If you want to use multiple patterns, e.g. &lt;code&gt;bsd_glob(&quot;a* b*&quot;)&lt;/code&gt; , you should probably throw them in a set as in &lt;code&gt;bsd_glob(&quot;{a*,b*}&quot;)&lt;/code&gt; . This is because the argument to bsd_glob() isn't subjected to parsing by the C shell. Remember that you can use a backslash to escape things.</source>
          <target state="translated">如果要使用多种模式，例如 &lt;code&gt;bsd_glob(&quot;a* b*&quot;)&lt;/code&gt; ，则应该像 &lt;code&gt;bsd_glob(&quot;{a*,b*}&quot;)&lt;/code&gt; 那样将它们放入一个集合中。这是因为C外壳程序不对bsd_glob（）的参数进行解析。请记住，可以使用反斜杠来转义。</target>
        </trans-unit>
        <trans-unit id="daaf83327da114b41b8c24aa71d08a4f5617620d" translate="yes" xml:space="preserve">
          <source>If you want to use non-ASCII bytes (outside the bytes 0x00..0x7f) in the &quot;source code&quot; of your code, to be portable you have to be explicit about what bytes they are. Someone might for example be using your code under a UTF-8 locale, in which case random native bytes might be illegal (&quot;Malformed UTF-8 ...&quot;) This means that for example embedding ISO 8859-1 bytes beyond 0x7f into your strings might cause trouble later. If the bytes are native 8-bit bytes, you can use the &lt;code&gt;bytes&lt;/code&gt; pragma. If the bytes are in a string (regular expressions being curious strings), you can often also use the &lt;code&gt;\xHH&lt;/code&gt; or more portably, the &lt;code&gt;\N{U+HH}&lt;/code&gt; notations instead of embedding the bytes as-is. If you want to write your code in UTF-8, you can use &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="translated">如果要在代码的&amp;ldquo;源代码&amp;rdquo;中使用非ASCII字节（字节0x00..0x7f之外），要想移植，必须明确它们是什么字节。例如，可能有人在UTF-8语言环境下使用您的代码，在这种情况下，随机的本地字节可能是非法的（&amp;ldquo;格式错误的UTF-8 ...&amp;rdquo;），这意味着例如将0x7f之后的ISO 8859-1字节嵌入到您的代码中字符串可能会在以后引起麻烦。如果字节是本机8位字节，则可以使用 &lt;code&gt;bytes&lt;/code&gt; 编译指示。如果字节在字符串中（正则表达式是奇怪的字符串），则通常也可以使用 &lt;code&gt;\xHH&lt;/code&gt; 或更可移植地使用 &lt;code&gt;\N{U+HH}&lt;/code&gt; 表示法，而不是照原样嵌入字节。如果要使用UTF-8编写代码，则可以使用&lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bfe339f2912f8f17fbf2b42472a9d509e3a576bf" translate="yes" xml:space="preserve">
          <source>If you want to use the same literal digits (644) in Perl, you have to tell Perl to treat them as octal numbers either by prefixing the digits with a &lt;code&gt;0&lt;/code&gt; or using &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">如果要在Perl中使用相同的文字数字（644），则必须告诉Perl通过在数字前面加上 &lt;code&gt;0&lt;/code&gt; 或使用 &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 将它们视为八进制数字：</target>
        </trans-unit>
        <trans-unit id="ee36968e514e749df3ac1a70b3903aee1ab0ec1b" translate="yes" xml:space="preserve">
          <source>If you want to use threads, you should primarily use the Perl 5.8.0 threads model by running Configure with -Duseithreads.</source>
          <target state="translated">如果你想使用线程,你应该主要使用Perl 5.8.0线程模型,用-Duseithreads运行Configure。</target>
        </trans-unit>
        <trans-unit id="f0b79aac4ab0e44b3e5cf20ea8795f9b26be612e" translate="yes" xml:space="preserve">
          <source>If you want to work with comma-separated values, don't do this since that format is a bit more complicated. Use one of the modules that handle that format, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV&quot;&gt;Text::CSV&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_XS&quot;&gt;Text::CSV_XS&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_PP&quot;&gt;Text::CSV_PP&lt;/a&gt;.</source>
          <target state="translated">如果要使用逗号分隔的值，请不要这样做，因为该格式要复杂一些。使用处理该格式的模块之一，例如&lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV&quot;&gt;Text :: CSV&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_XS&quot;&gt;Text :: CSV_XS&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_PP&quot;&gt;Text :: CSV_PP&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="37acc7e93925635a2960bac98f19ec762c55738f" translate="yes" xml:space="preserve">
          <source>If you want to work with formatted dates, the &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date::Manip&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; modules can help you.</source>
          <target state="translated">如果要使用格式化的日期，则&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date :: Manip&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;模块可以为您提供帮助。</target>
        </trans-unit>
        <trans-unit id="c337db840462e094257c46f34c19710018f93799" translate="yes" xml:space="preserve">
          <source>If you want to write to an existing SV's buffer and set its value to a string, use SvPV_force() or one of its variants to force the SV to be a PV. This will remove any of various types of non-stringness from the SV while preserving the content of the SV in the PV. This can be used, for example, to append data from an API function to a buffer without extra copying:</source>
          <target state="translated">如果你想写入一个现有的SV的缓冲区,并将其值设置为一个字符串,使用SvPV_force()或它的一个变体来强制SV成为一个PV。这将从SV中删除任何类型的非字符串,同时保留PV中SV的内容。例如,这可以用来将API函数中的数据追加到缓冲区中,而不需要额外的复制。</target>
        </trans-unit>
        <trans-unit id="17fab6cd5cfc4d3a8699ee4d492a9132990d5dbf" translate="yes" xml:space="preserve">
          <source>If you want to zap all predefined aliases, you can use</source>
          <target state="translated">如果您想扎掉所有预定义的别名,您可以使用</target>
        </trans-unit>
        <trans-unit id="6dad17422598919d77ad32018e1ee73ac029ac1c" translate="yes" xml:space="preserve">
          <source>If you want your code to be portable, your format (&lt;code&gt;fmt&lt;/code&gt; ) argument should use only the conversion specifiers defined by the ANSI C standard (C89, to play safe). These are &lt;code&gt;aAbBcdHIjmMpSUwWxXyYZ%&lt;/code&gt; . But even then, the &lt;b&gt;results&lt;/b&gt; of some of the conversion specifiers are non-portable. For example, the specifiers &lt;code&gt;aAbBcpZ&lt;/code&gt; change according to the locale settings of the user, and both how to set locales (the locale names) and what output to expect are non-standard. The specifier &lt;code&gt;c&lt;/code&gt; changes according to the timezone settings of the user and the timezone computation rules of the operating system. The &lt;code&gt;Z&lt;/code&gt; specifier is notoriously unportable since the names of timezones are non-standard. Sticking to the numeric specifiers is the safest route.</source>
          <target state="translated">如果您希望代码具有可移植性，那么您的format（ &lt;code&gt;fmt&lt;/code&gt; ）参数应仅使用ANSI C标准（为了安全起见，C89）定义的转换说明符。这些是 &lt;code&gt;aAbBcdHIjmMpSUwWxXyYZ%&lt;/code&gt; 。但是即使这样，某些转换说明符的&lt;b&gt;结果&lt;/b&gt;还是不可移植的。例如，说明符 &lt;code&gt;aAbBcpZ&lt;/code&gt; 根据用户的语言环境设置而改变，并且如何设置语言环境（语言环境名称）以及期望的输出都是非标准的。指定符 &lt;code&gt;c&lt;/code&gt; 根据用户的时区设置和操作系统的时区计算规则而变化。该 &lt;code&gt;Z&lt;/code&gt; 由于时区的名称是非标准的，因此说明符是众所周知的不可移植的。坚持数字说明符是最安全的方法。</target>
        </trans-unit>
        <trans-unit id="b8922cb8873f110b4ceb1333b3f31e99ca5b2eb1" translate="yes" xml:space="preserve">
          <source>If you want your encoding to work with &lt;a href=&quot;../encoding&quot;&gt;encoding&lt;/a&gt; pragma, you should also implement the method below.</source>
          <target state="translated">如果您希望您的编码与&lt;a href=&quot;../encoding&quot;&gt;编码&lt;/a&gt;编译指示一起使用，则还应该实现以下方法。</target>
        </trans-unit>
        <trans-unit id="e7210c4e7ce82b46e9e62a14e14a71ab868752cc" translate="yes" xml:space="preserve">
          <source>If you want your here-docs to be indented with the rest of the code, you'll need to remove leading whitespace from each line manually:</source>
          <target state="translated">如果你想让你的 her-docs 和其他代码一起缩进,你需要手动删除每行的前导空格。</target>
        </trans-unit>
        <trans-unit id="eb763454ad4db2bd6193f7e99d444faca44a82eb" translate="yes" xml:space="preserve">
          <source>If you want your program to be compatible with versions of Perl before 5.20, you must use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; instead. (In previous versions of Perl, the behavior of the statements &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'NONFATAL';&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; was unspecified; they did not behave as if they included the &lt;code&gt;=&amp;gt; 'all'&lt;/code&gt; portion. As of 5.20, they do.)</source>
          <target state="translated">如果您希望程序与5.20之前的Perl版本兼容，则必须使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; 代替。（在Perl的早期版本中，语句的行为 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'NONFATAL';&lt;/code&gt; 而 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; 为未指定的，他们并没有表现得好像它们包括 &lt;code&gt;=&amp;gt; 'all'&lt;/code&gt; 部分从5.20开始，他们这样做了。）</target>
        </trans-unit>
        <trans-unit id="3d68917c192fee56b1141df74b8f16f9fa5100fe" translate="yes" xml:space="preserve">
          <source>If you want, you may make low-level pipe() and fork() syscalls to stitch this together by hand. This example only talks to itself, but you could reopen the appropriate handles to STDIN and STDOUT and call other processes. (The following example lacks proper error checking.)</source>
          <target state="translated">如果你愿意,你可以做低级别的管道()和fork()系统调用来手工拼接。这个例子只和自己对话,但你可以重新打开STDIN和STDOUT的适当句柄,并调用其他进程。(下面的例子缺乏适当的错误检查。)</target>
        </trans-unit>
        <trans-unit id="9a78398c052f882736bece8b1553a1b8e0dc056b" translate="yes" xml:space="preserve">
          <source>If you wanted just to append to a row, you'd have to do something a bit funnier looking:</source>
          <target state="translated">如果你只想追加到一行,你就得做一些看起来更有趣的事情。</target>
        </trans-unit>
        <trans-unit id="2260da4124856b0020df29775382e24cb7c28087" translate="yes" xml:space="preserve">
          <source>If you wanted text and not lines, you would use</source>
          <target state="translated">如果你想要的是文字而不是线条,你会使用</target>
        </trans-unit>
        <trans-unit id="b649b444ce3825b2b868566f3609222a2cd25baa" translate="yes" xml:space="preserve">
          <source>If you wanted the commas preserved as separate fields (i.e. like split does if your split pattern has capturing parentheses), you would just make the last parameter undefined (or remove it).</source>
          <target state="translated">如果你想把逗号作为单独的字段保留下来(例如,如果你的分割模式有括号的话,就像分割一样),你只需要把最后一个参数变成未定义的(或者删除它)。</target>
        </trans-unit>
        <trans-unit id="5fba67ea1fbf1509f7d61f0bae5321559a412330" translate="yes" xml:space="preserve">
          <source>If you wanted to do the same thing for lines, you wouldn't need a regular expression:</source>
          <target state="translated">如果你想对行做同样的事情,你就不需要正则表达式了。</target>
        </trans-unit>
        <trans-unit id="ed640c7d7a4ae2cd65ac815fdaa4ce3af7479470" translate="yes" xml:space="preserve">
          <source>If you wanted to have a $ref_to_AoA variable as a reference to an array, you'd have to do something like this:</source>
          <target state="translated">如果你想让$ref_to_AoA变量作为一个数组的引用,你必须做这样的事情。</target>
        </trans-unit>
        <trans-unit id="fed8c5d580fcbca1e699420a58d9ad3cd67321fd" translate="yes" xml:space="preserve">
          <source>If you wanted to keep track of subscripts, you might do this:</source>
          <target state="translated">如果你想跟踪订阅,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="fbf69379e2b3dc67cd59111850ee63e9c65dd9db" translate="yes" xml:space="preserve">
          <source>If you wanted to see the inverse tables, you would first have to sort on the desired numbers column as in recipes 4, 5 or 6, then take the output of the first numbers column.</source>
          <target state="translated">如果你想看反表,你首先要在所需的数字列上进行排序,就像食谱4、5或6一样,然后取第一个数字列的输出。</target>
        </trans-unit>
        <trans-unit id="1d598a9db20ad75da95def7772f5c1aab9645a1d" translate="yes" xml:space="preserve">
          <source>If you were into Schwartzian Transforms, you would probably have selected map for that</source>
          <target state="translated">如果你是进入Schwartzian Transforms,你可能会选择地图的。</target>
        </trans-unit>
        <trans-unit id="ad840be29267c1ff305e523c8e88cf5317d35dc5" translate="yes" xml:space="preserve">
          <source>If you were to set &lt;code&gt;$b[3] = 4&lt;/code&gt; , then instead of reporting that &quot;a and b are deep copies of each other&quot;, it now reports that &lt;code&gt;&quot;b smartmatches in a&quot;&lt;/code&gt; . That's because the corresponding position in &lt;code&gt;@a&lt;/code&gt; contains an array that (eventually) has a 4 in it.</source>
          <target state="translated">如果您要设置 &lt;code&gt;$b[3] = 4&lt;/code&gt; ，那么它现在将报告 &lt;code&gt;&quot;b smartmatches in a&quot;&lt;/code&gt; &amp;rdquo;，而不是报告&amp;ldquo; a和b是彼此的深拷贝&amp;rdquo;。这是因为 &lt;code&gt;@a&lt;/code&gt; 中的相应位置包含一个数组（最终）（其中最后有一个4）。</target>
        </trans-unit>
        <trans-unit id="25e66b6a4d3408c5b81e396702004bd84b8fbf9d" translate="yes" xml:space="preserve">
          <source>If you wish to compile with the Socket extension, you need to have the TCP/IP toolkit, and you need to make sure that -lsocket locates the correct copy of socket3r.lib. Beware that the Watcom compiler ships with a stub version of socket3r.lib which has very little functionality. Also beware the order in which wlink searches directories for libraries. You may have /usr/lib/socket3r.lib pointing to the correct library, but wlink may pick up /usr/watcom/10.6/usr/lib/socket3r.lib instead. Make sure they both point to the correct library, that is, /usr/tcptk/current/usr/lib/socket3r.lib.</source>
          <target state="translated">如果你想用Socket扩展来编译,你需要有TCP/IP工具包,并且你需要确保-lsocket能找到socket3r.lib的正确副本。要注意Watcom编译器提供了一个stub版本的socket3r.lib,它的功能非常少。同时也要注意wlink搜索库的顺序。你可能有 /usr/lib/socket3r.lib 指向正确的库,但 wlink 可能会找到 /usr/watcom/10.6/usr/lib/socket3r.lib。确保它们都指向正确的库,即/usr/tcptk/current/usr/lib/socket3r.lib。</target>
        </trans-unit>
        <trans-unit id="743a9842bd7eb1c587a8ceb73e47cc40eff3e0ec" translate="yes" xml:space="preserve">
          <source>If you wish to install perl versions for all architectures (68020, mips, sparc and 386) run:</source>
          <target state="translated">如果你想为所有架构(68020,mips,sparc和386)安装perl版本,请运行。</target>
        </trans-unit>
        <trans-unit id="fe0f0e4408b545cb1ecebca491d9be266bb67e8f" translate="yes" xml:space="preserve">
          <source>If you wish to supply an alternative debugger for Perl to run, invoke your script with a colon and a package argument given to the &lt;b&gt;-d&lt;/b&gt; flag. Perl's alternative debuggers include a Perl profiler, &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt;, which is available separately as a CPAN distribution. To profile your Perl program in the file</source>
          <target state="translated">如果希望为Perl提供替代调试器以运行，请使用冒号和给&lt;b&gt;-d&lt;/b&gt;标志的package参数调用脚本。Perl的替代调试器包括Perl分析器&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel :: NYTProf&lt;/a&gt;，它可以作为CPAN发行版单独提供。在文件中分析您的Perl程序</target>
        </trans-unit>
        <trans-unit id="b105ef1f647cb2687215fb2803b65285f6c51529" translate="yes" xml:space="preserve">
          <source>If you wish to turn an entire POD document into a parse-tree, that process is fairly straightforward. The &lt;b&gt;parse_text()&lt;/b&gt; method is the key to doing this successfully. Every paragraph-callback (i.e. the polymorphic methods for &lt;b&gt;command()&lt;/b&gt;, &lt;b&gt;verbatim()&lt;/b&gt;, and &lt;b&gt;textblock()&lt;/b&gt; paragraphs) takes a &lt;b&gt;Pod::Paragraph&lt;/b&gt; object as an argument. Each paragraph object has a &lt;b&gt;parse_tree()&lt;/b&gt; method that can be used to get or set a corresponding parse-tree. So for each of those paragraph-callback methods, simply call &lt;b&gt;parse_text()&lt;/b&gt; with the options you desire, and then use the returned parse-tree to assign to the given paragraph object.</source>
          <target state="translated">如果您希望将整个POD文档变成一个分析树，那么这个过程非常简单。该&lt;b&gt;parse_Text在（）&lt;/b&gt;方法的关键在于成功地这样做。每个段落回调（即&lt;b&gt;command（）&lt;/b&gt;，&lt;b&gt;verbatim（）&lt;/b&gt;和&lt;b&gt;textblock（）&lt;/b&gt;段落的多态方法）都将&lt;b&gt;Pod :: Paragraph&lt;/b&gt;对象作为参数。每个段落对象都有一个&lt;b&gt;parse_tree（）&lt;/b&gt;方法，该方法可用于获取或设置相应的解析树。因此，对于每个这些段落回调方法，只需使用所需的选项调用&lt;b&gt;parse_text（）&lt;/b&gt;，然后使用返回的解析树将其分配给给定的段落对象。</target>
        </trans-unit>
        <trans-unit id="77c82d86f4fb285fcd145d9c870b966041509421" translate="yes" xml:space="preserve">
          <source>If you wish to use GNU ld, then you need to pass it the -Wl,-E flag. The hints/solaris_2.sh file tries to do this automatically by setting the following Configure variables:</source>
          <target state="translated">如果你想使用GNU ld,那么你需要传递-Wl,-E标志。hints/solaris_2.sh文件试图通过设置以下的Configure变量来自动做到这一点。</target>
        </trans-unit>
        <trans-unit id="5c10ef4b4d7cf77ba9367b0a5ba13535a2314b3d" translate="yes" xml:space="preserve">
          <source>If you wish to use gcc to build add-on modules for use with the perl shipped with Solaris, you should use the Solaris::PerlGcc module which is available from CPAN. The perl shipped with Solaris is configured and built with the Sun compilers, and the compiler configuration information stored in Config.pm is therefore only relevant to the Sun compilers. The Solaris:PerlGcc module contains a replacement Config.pm that is correct for gcc - see the module for details.</source>
          <target state="translated">如果你希望使用gcc来构建附加模块,以便与Solaris附带的perl一起使用,你应该使用CPAN提供的Solaris::PerlGcc模块。Solaris 中的 perl 是用 Sun 编译器配置和构建的,因此存储在 Config.pm 中的编译器配置信息只与 Sun 编译器有关。Solaris:PerlGcc模块包含了一个对gcc正确的替换Config.pm--详见该模块。</target>
        </trans-unit>
        <trans-unit id="461c22560c9b4e2d096c9a209fc41fbc9b8e1805" translate="yes" xml:space="preserve">
          <source>If you wonder what complex numbers are, they were invented to be able to solve the following equation:</source>
          <target state="translated">如果你想知道什么是复数,那么发明复数就是为了能解下面的方程。</target>
        </trans-unit>
        <trans-unit id="58f2be2cb41014bdf8c7d1f6da3d5ed7b3a57878" translate="yes" xml:space="preserve">
          <source>If you wonder why defaults for conversion are different for str() and num(), note how easy it was to write the symbolic calculator. This simplicity is due to an appropriate choice of defaults. One extra note: due to the explicit recursion num() is more fragile than sym(): we need to explicitly check for the type of $a and $b. If components $a and $b happen to be of some related type, this may lead to problems.</source>
          <target state="translated">如果你想知道为什么str()和num()的转换默认值不同,请注意写符号计算器是多么的简单。这种简单性是由于适当地选择了默认值。一个额外的说明:由于显式递归num()比sym()更脆弱:我们需要显式检查$a和$b的类型。如果组件$a和$b恰好是一些相关的类型,这可能会导致问题。</target>
        </trans-unit>
        <trans-unit id="f88d82472c17285676b32563ec0b930b79f27b19" translate="yes" xml:space="preserve">
          <source>If you would like to know about a version dependency before you start running the program, put something like this at its top:</source>
          <target state="translated">如果你想在开始运行程序之前了解版本依赖性,请在程序顶部写上这样的内容。</target>
        </trans-unit>
        <trans-unit id="c3bc63e78a724b45aa4c8fcf7d5d3a90c3663440" translate="yes" xml:space="preserve">
          <source>If you would like to print out a lot of man page continuously, you probably want to set the C and D registers to set contiguous page numbering and even/odd paging, at least on some versions of man(7).</source>
          <target state="translated">如果你想连续打印出大量的man页,你可能想设置C和D寄存器来设置连续页码和偶数/多数分页,至少在man(7)的某些版本上是这样。</target>
        </trans-unit>
        <trans-unit id="4e270feabb28d65fb97bce6b5a62077129b3eed4" translate="yes" xml:space="preserve">
          <source>If you would rather see it in CCSID 1047 order then change the number 34 in the last line to 39, like this:</source>
          <target state="translated">如果你想按CCSID 1047的顺序看,那就把最后一行的数字34改为39,就像这样。</target>
        </trans-unit>
        <trans-unit id="7ab3cc4dd9f42b386f286d85d40432c48d4dbc0d" translate="yes" xml:space="preserve">
          <source>If you would rather see it in POSIX-BC order then change the number 34 in the last line to 44, like this:</source>
          <target state="translated">如果你想按POSIX-BC的顺序看,那就把最后一行的数字34改为44,像这样。</target>
        </trans-unit>
        <trans-unit id="4685079e88ddb435b412b9c5b1c049410dc612d3" translate="yes" xml:space="preserve">
          <source>If you would rather see the above table in CCSID 0037 order rather than ASCII + Latin-1 order then run the table through:</source>
          <target state="translated">如果您希望以CCSID 0037的顺序而不是ASCII+拉丁语1的顺序查看上表,那么请运行该表。</target>
        </trans-unit>
        <trans-unit id="32ccbee06ab47d2346ade36365b388768fa75f8c" translate="yes" xml:space="preserve">
          <source>If you would rather see this table listing hexadecimal values then run the table through:</source>
          <target state="translated">如果你想看这个列出十六进制值的表格,那么就把这个表格运行一遍。</target>
        </trans-unit>
        <trans-unit id="ee951a76c16a66932dc3802ba31a24c5d5d45366" translate="yes" xml:space="preserve">
          <source>If you write just &lt;code&gt;[]&lt;/code&gt; , you get a new, empty anonymous array. If you write just &lt;code&gt;{}&lt;/code&gt; , you get a new, empty anonymous hash.</source>
          <target state="translated">如果只写 &lt;code&gt;[]&lt;/code&gt; ，则会得到一个新的空匿名数组。如果仅写 &lt;code&gt;{}&lt;/code&gt; ，则会得到一个新的空匿名哈希。</target>
        </trans-unit>
        <trans-unit id="6e5ce930a64c177374e0a87543a2b84b1ca0633d" translate="yes" xml:space="preserve">
          <source>If you write your own test, use the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2ftestanything.org&quot;&gt;Test Anything Protocol&lt;/a&gt;.</source>
          <target state="translated">如果您编写自己的测试，请使用&amp;ldquo; &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2ftestanything.org&quot;&gt;测试任何协议&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4b7f29b396f8216559006548d8b8987bccc01b5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a C or C++ programmer, you might be looking for Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword.</source>
          <target state="translated">如果您是C或C ++程序员，则可能正在寻找Perl的 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="65480a92112439353360a0f2410e7e3031db6948" translate="yes" xml:space="preserve">
          <source>If you'd like a graphical user interface and you have &lt;a href=&quot;http://search.cpan.org/perldoc/Tk&quot;&gt;Tk&lt;/a&gt;, you can use &lt;code&gt;ptkdb&lt;/code&gt; . It's on CPAN and available for free.</source>
          <target state="translated">如果您想要图形用户界面并且拥有&lt;a href=&quot;http://search.cpan.org/perldoc/Tk&quot;&gt;Tk&lt;/a&gt;，则可以使用 &lt;code&gt;ptkdb&lt;/code&gt; 。它在CPAN上免费提供。</target>
        </trans-unit>
        <trans-unit id="c82ff6955ec720dbffdb6e597947e26e8c52b3d3" translate="yes" xml:space="preserve">
          <source>If you'd like to disable the use of one or more of these utilities and/or modules, see the &lt;code&gt;$BLACKLIST&lt;/code&gt; variable further down.</source>
          <target state="translated">如果您想禁用这些实用程序和/或模块中的一个或多个，请参阅 &lt;code&gt;$BLACKLIST&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="52486225415552ac3d601c87ba41d238a14d5679" translate="yes" xml:space="preserve">
          <source>If you'd like to make &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; (and many other bits of Perl) die on error, have a look at the &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; pragma.</source>
          <target state="translated">如果您想使 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; （以及Perl的许多其他功能）因错误而死亡，请查看自动模具&lt;a href=&quot;autodie&quot;&gt;实用程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1efbce8f9e88ed4ba8cc94bb84af468b14e5c10a" translate="yes" xml:space="preserve">
          <source>If you'd like to make &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; (and many other bits of Perl) die on error, have a look at the &lt;a href=&quot;../autodie&quot;&gt;autodie&lt;/a&gt; pragma.</source>
          <target state="translated">如果您想使 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; （以及Perl的许多其他功能）因错误而死亡，请查看自动模具&lt;a href=&quot;../autodie&quot;&gt;实用程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="73a95e0734804b8dcc4d934eb0b4ac64271a89fa" translate="yes" xml:space="preserve">
          <source>If you'd like to manually inspect &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s failure, you can check all possible failure modes by inspecting &lt;code&gt;$?&lt;/code&gt; like this:</source>
          <target state="translated">如果您想手动检查 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 的故障，可以通过检查 &lt;code&gt;$?&lt;/code&gt; 检查所有可能的故障模式。像这样：</target>
        </trans-unit>
        <trans-unit id="c50262b9b752d6c3a022a1f95bc5efa143b999d6" translate="yes" xml:space="preserve">
          <source>If you'd like to manually inspect &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s failure, you can check all possible failure modes by inspecting &lt;code&gt;$?&lt;/code&gt; like this:</source>
          <target state="translated">如果您想手动检查 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 的故障，可以通过检查 &lt;code&gt;$?&lt;/code&gt; 检查所有可能的故障模式。像这样：</target>
        </trans-unit>
        <trans-unit id="b7d0d2c6ab654703248e935ebd07682399b01f80" translate="yes" xml:space="preserve">
          <source>If you'd like to see the raw output of your tests, set the &lt;code&gt;TEST_VERBOSE&lt;/code&gt; variable to true.</source>
          <target state="translated">如果您想查看测试的原始输出，请将 &lt;code&gt;TEST_VERBOSE&lt;/code&gt; 变量设置为true。</target>
        </trans-unit>
        <trans-unit id="15cb39149b7ad3616c39f88b2becd39a6aed03b0" translate="yes" xml:space="preserve">
          <source>If you'd rather treat each line individually, you can do that, too, by just transforming them in-place in the code reference and returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. Say that you don't want</source>
          <target state="translated">如果您希望单独对待每一行，也可以通过在代码引用中就地转换它们并返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 来实现。说你不想</target>
        </trans-unit>
        <trans-unit id="ffd95bdd9903099e5f9ecacdcf9a08a9aec1e1ad" translate="yes" xml:space="preserve">
          <source>If you're a plugin author, you'll be interested in how to &lt;a href=&quot;#register_handler&quot;&gt;register_handler&lt;/a&gt;s, how &lt;a href=&quot;#detect_source&quot;&gt;detect_source&lt;/a&gt; works.</source>
          <target state="translated">如果您是插件作者，那么您将对如何&lt;a href=&quot;#register_handler&quot;&gt;register_handler&lt;/a&gt;以及&lt;a href=&quot;#detect_source&quot;&gt;detect_source的&lt;/a&gt;工作方式感兴趣。</target>
        </trans-unit>
        <trans-unit id="ec02db45e6d3a34d0a303395b0efb8490d821d7c" translate="yes" xml:space="preserve">
          <source>If you're committed to creating a temporary file by hand, use the process ID and/or the current time-value. If you need to have many temporary files in one process, use a counter:</source>
          <target state="translated">如果你致力于手工创建临时文件,请使用进程ID和/或当前时间值。如果你需要在一个进程中拥有许多临时文件,请使用计数器。</target>
        </trans-unit>
        <trans-unit id="6a57c8d5168852184b3e7f9eacd5e84a511755f4" translate="yes" xml:space="preserve">
          <source>If you're concerned about 8-bit textual data then see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;. If you want to deal with multibyte characters, however, there are some gotchas. See the section on Regular Expressions.</source>
          <target state="translated">如果您担心8位文本数据，请参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。但是，如果要处理多字节字符，则有一些陷阱。请参阅正则表达式部分。</target>
        </trans-unit>
        <trans-unit id="a4a17aeb59ac658e17124a0d2eb0b805c011e3c8" translate="yes" xml:space="preserve">
          <source>If you're concerned about people profiting from your code, then the bottom line is that nothing but a restrictive license will give you legal security. License your software and pepper it with threatening statements like &quot;This is unpublished proprietary software of XYZ Corp. Your access to it does not give you permission to use it blah blah blah.&quot; We are not lawyers, of course, so you should see a lawyer if you want to be sure your license's wording will stand up in court.</source>
          <target state="translated">如果你担心人们从你的代码中获利,那么底线是,除了限制性的许可证之外,什么都不能给你带来法律上的保障。给你的软件颁发许可证,并在其中加入威胁性的声明,比如 &quot;这是XYZ公司未发布的专有软件,你对它的访问并不允许你使用它等等。你对它的访问并没有给你使用它的许可等等等等。&quot; 当然,我们不是律师,所以如果你想确保你的许可证的措辞能在法庭上站住脚,你应该去见律师。</target>
        </trans-unit>
        <trans-unit id="20f5afeb7883b43b071ad0d90c989471842051d6" translate="yes" xml:space="preserve">
          <source>If you're concerned about people profiting from your code, then the bottom line is that nothing but a restrictive license will give you legal security. License your software and pepper it with threatening statements like &quot;This is unpublished proprietary software of XYZ Corp. Your access to it does not give you permission to use it blah blah blah.&quot; You should see a lawyer to be sure your license's wording will stand up in court.</source>
          <target state="translated">如果你担心人们从你的代码中获利,那么底线是,除了限制性的许可证之外,什么都不能给你带来法律上的保障。给你的软件颁发许可证,并在其中加入威胁性的声明,比如 &quot;这是XYZ公司未发布的专有软件,你对它的访问并不允许你使用它等等。你对它的访问并没有给你使用它的许可等等等等。&quot; 你应该去见律师,以确保你的许可证的措辞能在法庭上站住脚。</target>
        </trans-unit>
        <trans-unit id="28d412e72884dbac279b68cd8636bc53150a9095" translate="yes" xml:space="preserve">
          <source>If you're confused about why you use an '@' there on a hash slice instead of a '%', think of it like this. The type of bracket (square or curly) governs whether it's an array or a hash being looked at. On the other hand, the leading symbol ('$' or '@') on the array or hash indicates whether you are getting back a singular value (a scalar) or a plural one (a list).</source>
          <target state="translated">如果你对为什么在哈希片上使用'@'而不是'%'感到困惑,可以这样想。括号的类型(方括号或卷括号)决定了看的是数组还是哈希。另一方面,数组或散列上的前导符号('$'或'@')表示你得到的是一个单数值(标量)还是一个复数值(列表)。</target>
        </trans-unit>
        <trans-unit id="2fdaeb94f7920871da7274b75b49a557aeabaf4a" translate="yes" xml:space="preserve">
          <source>If you're creating a completely new result</source>
          <target state="translated">如果你正在创建一个全新的结果</target>
        </trans-unit>
        <trans-unit id="6e2a7b543e2f454e92700f7b1967ab94c4b894e7" translate="yes" xml:space="preserve">
          <source>If you're currently linking your perl executable to a shared</source>
          <target state="translated">如果你目前正在将你的perl可执行文件链接到一个共享的</target>
        </trans-unit>
        <trans-unit id="5ae9e7742fc3a996e99839cc61f7b8352d875d18" translate="yes" xml:space="preserve">
          <source>If you're debugging a script that uses #!, and normally relies on the shell's $PATH search, the -S option causes perl to do that search, so you don't have to type the path or &lt;code&gt;`which $scriptname`&lt;/code&gt; .</source>
          <target state="translated">如果您正在调试使用＃！的脚本，并且通常依赖于shell的$ PATH搜索，则-S选项会使perl进行该搜索，因此您不必键入路径或 &lt;code&gt;`which $scriptname`&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c253632d224aa0744dad2b2922eca154c4278dec" translate="yes" xml:space="preserve">
          <source>If you're deprecating a feature with the intent of later simplifying another bit of code, say so. If you're fixing a performance problem or adding a new feature to support some other bit of the core, mention that.</source>
          <target state="translated">如果你废止一个功能的目的是为了以后简化另一部分代码,那么就说出来。如果你正在修复一个性能问题或添加一个新的功能来支持核心的其他部分,请提及。</target>
        </trans-unit>
        <trans-unit id="b41a3856c0dbc6e888db5696272009c4533b95af" translate="yes" xml:space="preserve">
          <source>If you're developing a CPAN distribution using XS, you may add your own file called</source>
          <target state="translated">如果你正在使用XS开发一个CPAN发行版,你可以添加你自己的文件,叫做</target>
        </trans-unit>
        <trans-unit id="897c140e9db65d769b3515a8af2bf69889950440" translate="yes" xml:space="preserve">
          <source>If you're getting this error from a here-document, you may have included unseen whitespace before or after your closing tag or there may not be a linebreak after it. A good programmer's editor will have a way to help you find these characters (or lack of characters). See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for the full details on here-documents.</source>
          <target state="translated">如果您从此处文档中收到此错误，则可能是在结束标记之前或之后包含了看不见的空格，或者在其后可能没有换行符。一个好的程序员编辑器将有一种方法来帮助您找到这些字符（或缺少字符）。有关此处文档的完整详细信息，请参见&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4fd5cbfd79a1c891c020d447f65eef0d65886a8" translate="yes" xml:space="preserve">
          <source>If you're going to put your Pod at the end of the file, and you're using an &lt;code&gt;__END__&lt;/code&gt; or &lt;code&gt;__DATA__&lt;/code&gt; cut mark, make sure to put an empty line there before the first Pod command.</source>
          <target state="translated">如果要将Pod放在文件末尾，并且使用的是 &lt;code&gt;__END__&lt;/code&gt; 或 &lt;code&gt;__DATA__&lt;/code&gt; 剪切标记，请确保在第一个Pod命令之前在其中放置一个空行。</target>
        </trans-unit>
        <trans-unit id="0fef8c8a09918fb182d2a0653d091964fe4d5654" translate="yes" xml:space="preserve">
          <source>If you're in a slow syscall (like &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;ing, &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt;ing, or &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;ing from your keyboard or a socket) and haven't set up your own &lt;code&gt;$SIG{INT}&lt;/code&gt; handler, then you won't be able to CTRL-C your way back to the debugger, because the debugger's own &lt;code&gt;$SIG{INT}&lt;/code&gt; handler doesn't understand that it needs to raise an exception to longjmp(3) out of slow syscalls.</source>
          <target state="translated">如果您的系统调用速度很慢（例如 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; 或从键盘或套接字 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; ），并且尚未设置自己的 &lt;code&gt;$SIG{INT}&lt;/code&gt; 处理程序，则将无法进行CTRL -C以您的方式返回调试器，因为调试器自己的 &lt;code&gt;$SIG{INT}&lt;/code&gt; 处理程序不了解它需要从缓慢的系统调用中向longjmp（3）引发异常。</target>
        </trans-unit>
        <trans-unit id="14f4284650d0a24b2d57ce770464abe6b8363cfa" translate="yes" xml:space="preserve">
          <source>If you're just trying to get a print out of each line of Perl code as it executes, the way that &lt;code&gt;sh -x&lt;/code&gt; provides for shell scripts, you can't use Perl's &lt;b&gt;-D&lt;/b&gt; switch. Instead do this</source>
          <target state="translated">如果您只是想在执行Perl代码的每一行中打印出打印内容时，即 &lt;code&gt;sh -x&lt;/code&gt; 为shell脚本提供的方式，则不能使用Perl的&lt;b&gt;-D&lt;/b&gt;开关。而是这样做</target>
        </trans-unit>
        <trans-unit id="e1d724a87dfd2f97b8c95cc8c3b05426d4d76542" translate="yes" xml:space="preserve">
          <source>If you're just trying to patch a binary, in many cases something as simple as this works:</source>
          <target state="translated">如果你只是想给一个二进制文件打补丁,在很多情况下,像这样简单的东西就可以了。</target>
        </trans-unit>
        <trans-unit id="beae682a73c10931e4ab41819afea65e05d531cf" translate="yes" xml:space="preserve">
          <source>If you're looking for an EBNF grammar, see &lt;a href=&quot;parser/grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt;.</source>
          <target state="translated">如果您正在寻找EBNF语法，请参见&lt;a href=&quot;parser/grammar&quot;&gt;TAP :: Parser :: Grammar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55c4ac9978b7084a6172dad11c1733f741ff1455" translate="yes" xml:space="preserve">
          <source>If you're looking for something a bit more rigorous, try &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;.</source>
          <target state="translated">如果您正在寻找更严格的东西，请尝试&lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7091178e821abb2a7bce9c92cae74d109146a9a0" translate="yes" xml:space="preserve">
          <source>If you're looking for the information on how to use here-documents, which used to be here, that's been moved to &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">如果您要查找有关如何使用here-documents的信息（以前是在此处），则已将其移至&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlop中的Quote和类似Quote的运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="889cd4ec91070da4d939fc8ed6a3a8c2e2067138" translate="yes" xml:space="preserve">
          <source>If you're looking to write your own object system, or you need to maintain code which implements objects from scratch then this document will help you understand exactly how Perl does object orientation.</source>
          <target state="translated">如果你想写自己的对象系统,或者你需要维护从头开始实现对象的代码,那么这个文档将帮助你了解Perl到底是如何做对象定向的。</target>
        </trans-unit>
        <trans-unit id="ddf0bc3794c8ee98c81f65ada98d73c84a0b3b0d" translate="yes" xml:space="preserve">
          <source>If you're lucky enough to be using a system that supports non-blocking reads (most Unixish systems do), you need only to use the &lt;code&gt;O_NDELAY&lt;/code&gt; or &lt;code&gt;O_NONBLOCK&lt;/code&gt; flag from the &lt;code&gt;Fcntl&lt;/code&gt; module in conjunction with &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">如果您有幸使用支持非阻塞读取的系统（大多数Unixish系统支持），则只需将 &lt;code&gt;Fcntl&lt;/code&gt; 模块中的 &lt;code&gt;O_NDELAY&lt;/code&gt; 或 &lt;code&gt;O_NONBLOCK&lt;/code&gt; 标志与 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; 结合使用：</target>
        </trans-unit>
        <trans-unit id="1442d0654a360821d205030d12b7c46d2249369f" translate="yes" xml:space="preserve">
          <source>If you're lucky you should see &quot;All tests successful&quot;. But there can be a few failed subtests (less than 5 hopefully) depending on some external conditions (e.g. some subtests fail under linux/dosemu or plain dos with short filenames only).</source>
          <target state="translated">如果你幸运的话,你应该会看到 &quot;All tests succeed&quot;。但是可能会有一些失败的子测试(希望少于5个),这取决于一些外部条件(例如,一些子测试在linux/dosemu或只有短文件名的普通dos下失败)。</target>
        </trans-unit>
        <trans-unit id="81d8181270fe0a221e4cfe0273d672eeca038de7" translate="yes" xml:space="preserve">
          <source>If you're matching against &lt;code&gt;$_&lt;/code&gt; , the &lt;code&gt;$_ =~&lt;/code&gt; part can be omitted:</source>
          <target state="translated">如果要与 &lt;code&gt;$_&lt;/code&gt; 匹配，则可以省略 &lt;code&gt;$_ =~&lt;/code&gt; 部分：</target>
        </trans-unit>
        <trans-unit id="8dff24fd1b5ec5a9dffa27b27da41b1f996870a7" translate="yes" xml:space="preserve">
          <source>If you're matching against the special default variable &lt;code&gt;$_&lt;/code&gt; , the &lt;code&gt;$_ =~&lt;/code&gt; part can be omitted:</source>
          <target state="translated">如果要与特殊的默认变量 &lt;code&gt;$_&lt;/code&gt; 匹配，则可以省略 &lt;code&gt;$_ =~&lt;/code&gt; 部分：</target>
        </trans-unit>
        <trans-unit id="426f58876b20aa644c87cac6d34c02796b1541e8" translate="yes" xml:space="preserve">
          <source>If you're mixing UTF-8 and non-UTF-8 strings, it is necessary to upgrade the non-UTF-8 strings to UTF-8. If you've got an SV, the easiest way to do this is:</source>
          <target state="translated">如果你把UTF-8和非UTF-8的字符串混合在一起,就需要把非UTF-8的字符串升级到UTF-8。如果你有一个SV,最简单的方法是。</target>
        </trans-unit>
        <trans-unit id="0b4dc2534030724a7fd2a22ed631de91b923d0d4" translate="yes" xml:space="preserve">
          <source>If you're more familiar with writing in HTML than with writing in Pod, you can try your hand at writing documentation in simple HTML, and converting it to Pod with the experimental &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::HTML2Pod&quot;&gt;Pod::HTML2Pod&lt;/a&gt; module, (available in CPAN), and looking at the resulting code. The experimental &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt; module in CPAN might also be useful.</source>
          <target state="translated">如果您比使用Pod编写更熟悉HTML编写，则可以尝试用简单的HTML编写文档，并使用实验性&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::HTML2Pod&quot;&gt;Pod :: HTML2Pod&lt;/a&gt;模块（在CPAN中可用）将其转换为Pod ，然后查找在生成的代码。CPAN中的实验性&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;模块也可能有用。</target>
        </trans-unit>
        <trans-unit id="661a15733b02e1bde18a48ee6f26023806e52abe" translate="yes" xml:space="preserve">
          <source>If you're more from the object-oriented camp, you can inherit from Storable and directly store your objects by invoking &lt;code&gt;store&lt;/code&gt; as a method. The fact that the root of the to-be-stored tree is a blessed reference (i.e. an object) is special-cased so that the retrieve does not provide a reference to that object but rather the blessed object reference itself. (Otherwise, you'd get a reference to that blessed object).</source>
          <target state="translated">如果您来自面向对象阵营，则可以从Storable继承并通过调用 &lt;code&gt;store&lt;/code&gt; 作为一种方法直接存储对象。待存储树的根是祝福引用（即对象）的事实是特殊情况，因此检索不会提供对该对象的引用，而是提供祝福对象引用本身。（否则，您将获得对该受祝福对象的引用）。</target>
        </trans-unit>
        <trans-unit id="90c11316b76d508e073f9fc77a3e623b3eada282" translate="yes" xml:space="preserve">
          <source>If you're new to Perl, you should start by running &lt;code&gt;perldoc perlintro&lt;/code&gt; , which is a general intro for beginners and provides some background to help you navigate the rest of Perl's extensive documentation. Run &lt;code&gt;perldoc
perldoc&lt;/code&gt; to learn more things you can do with</source>
          <target state="translated">如果您不 &lt;code&gt;perldoc perlintro&lt;/code&gt; Perl，则应该先运行perldoc perlintro，这是初学者的一般介绍，并提供了一些背景知识来帮助您浏览Perl的其他大量文档。运行 &lt;code&gt;perldoc perldoc&lt;/code&gt; 以了解更多您可以使用的功能</target>
        </trans-unit>
        <trans-unit id="744942d070c981ce6cf7077125a9b1fdb8807cc7" translate="yes" xml:space="preserve">
          <source>If you're new to the Perl debugger, you may prefer to read &lt;a href=&quot;perldebtut&quot;&gt;perldebtut&lt;/a&gt;, which is a tutorial introduction to the debugger.</source>
          <target state="translated">如果您不&lt;a href=&quot;perldebtut&quot;&gt;熟悉&lt;/a&gt; Perl调试器，则可能更喜欢阅读perldebtut，这是调试器的教程介绍。</target>
        </trans-unit>
        <trans-unit id="c2727aad3001460d90c1014c2e79041ef3c0a256" translate="yes" xml:space="preserve">
          <source>If you're not running VMS, this module does nothing.</source>
          <target state="translated">如果你没有运行VMS,这个模块什么都不做。</target>
        </trans-unit>
        <trans-unit id="57b30f05d7f8cbe152533a07743b1d8313aa4f82" translate="yes" xml:space="preserve">
          <source>If you're not sure what you have (the &lt;code&gt;VAL&lt;/code&gt; case), wrap the method call in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block to catch the exception if &lt;code&gt;VAL&lt;/code&gt; is undefined.</source>
          <target state="translated">如果不确定自己所拥有的内容（ &lt;code&gt;VAL&lt;/code&gt; 情况），则将方法调用包装在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 块中，以在 &lt;code&gt;VAL&lt;/code&gt; 未定义时捕获异常。</target>
        </trans-unit>
        <trans-unit id="92ef540b5bff7fa8b60e3b8701e23d84d3552eb5" translate="yes" xml:space="preserve">
          <source>If you're not the Perl administrator you probably don't have permission to install a module to its default location. Then you should install it for your own use into your home directory like so:</source>
          <target state="translated">如果你不是Perl的管理员,你可能没有权限安装一个模块到它的默认位置。那么你应该像这样把它安装到你的主目录下供自己使用。</target>
        </trans-unit>
        <trans-unit id="9feed406758bc42352583f962fb6765533ea27d0" translate="yes" xml:space="preserve">
          <source>If you're not used to reading BNF grammars, this is how it works: You're fed certain things by the tokeniser, which generally end up in upper case. Here, &lt;code&gt;ADDOP&lt;/code&gt; , is provided when the tokeniser sees &lt;code&gt;+&lt;/code&gt; in your code. &lt;code&gt;ASSIGNOP&lt;/code&gt; is provided when &lt;code&gt;=&lt;/code&gt; is used for assigning. These are &quot;terminal symbols&quot;, because you can't get any simpler than them.</source>
          <target state="translated">如果您不习惯阅读BNF语法，那么它就是这样工作的：令牌生成器将某些内容提供给您，通常以大写字母结尾。在这里， &lt;code&gt;ADDOP&lt;/code&gt; ，是当tokeniser看到提供 &lt;code&gt;+&lt;/code&gt; 在你的代码。当使用 &lt;code&gt;=&lt;/code&gt; 进行分配时，将提供 &lt;code&gt;ASSIGNOP&lt;/code&gt; 。这些是&amp;ldquo;终端符号&amp;rdquo;，因为您无法获得比它们更简单的符号。</target>
        </trans-unit>
        <trans-unit id="d41cee3341b958945c48519633ed1e0a770e7261" translate="yes" xml:space="preserve">
          <source>If you're not writing a server/client for an existing protocol like NNTP or SMTP, you should give some thought to how your server will know when the client has finished talking, and vice-versa. Most protocols are based on one-line messages and responses (so one party knows the other has finished when a &quot;\n&quot; is received) or multi-line messages and responses that end with a period on an empty line (&quot;\n.\n&quot; terminates a message/response).</source>
          <target state="translated">如果你不是为现有的协议(如NNTP或SMTP)编写服务器/客户端,你应该考虑一下你的服务器如何知道客户端何时结束通话,反之亦然。大多数协议都是基于单行消息和响应(所以当收到&quot;\n &quot;时,一方知道另一方已经结束了)或多行消息和响应,在空行上以句号结束(&quot;\n.\n &quot;终止一个消息/响应)。</target>
        </trans-unit>
        <trans-unit id="1904985e3da30cf5eb915cfb278068985854bae1" translate="yes" xml:space="preserve">
          <source>If you're not writing such a tool, then whether you accept noncharacters as input is up to you (though the Standard recommends that you not). If you do strict input stream checking with Perl, these code points continue to be forbidden. This is to maintain backward compatibility (otherwise potential security holes could open up, as an unsuspecting application that was written assuming the noncharacters would be filtered out before getting to it, could now, without warning, start getting them). To do strict checking, you can use the layer &lt;code&gt;:encoding('UTF-8')&lt;/code&gt; .</source>
          <target state="translated">如果您不编写此类工具，则是否接受非字符作为输入取决于您（尽管标准建议您不这样做）。如果使用Perl进行严格的输入流检查，则将继续禁止使用这些代码点。这是为了保持向后兼容性（否则可能会打开潜在的安全漏洞，因为编写的一个毫无怀疑的应用程序假设非字符在进入非字符之前将被过滤掉，现在可以不加警告地开始获取它们）。要进行严格检查，可以使用 &lt;code&gt;:encoding('UTF-8')&lt;/code&gt; 层。</target>
        </trans-unit>
        <trans-unit id="6e740be7e86f98ca86a316e7e6f108d26ec4db83" translate="yes" xml:space="preserve">
          <source>If you're on Unix, you already have an IDE--Unix itself. The Unix philosophy is the philosophy of several small tools that each do one thing and do it well. It's like a carpenter's toolbox.</source>
          <target state="translated">如果你在Unix上,你已经有了一个IDE--Unix本身。Unix的哲学是几个小工具各做一件事,而且做得很好。这就像一个木匠的工具箱。</target>
        </trans-unit>
        <trans-unit id="27b6c4407588281e5e7fdb718dd9826644dbabc0" translate="yes" xml:space="preserve">
          <source>If you're on a POSIX system, Perl supports the &lt;code&gt;POSIX::strtod&lt;/code&gt; function for converting strings to doubles (and also &lt;code&gt;POSIX::strtol&lt;/code&gt; for longs). Its semantics are somewhat cumbersome, so here's a &lt;code&gt;getnum&lt;/code&gt; wrapper function for more convenient access. This function takes a string and returns the number it found, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for input that isn't a C float. The &lt;code&gt;is_numeric&lt;/code&gt; function is a front end to &lt;code&gt;getnum&lt;/code&gt; if you just want to say, &quot;Is this a float?&quot;</source>
          <target state="translated">如果您使用的是POSIX系统，则Perl支持 &lt;code&gt;POSIX::strtod&lt;/code&gt; 函数，用于将字符串转换为双精度型（以及 &lt;code&gt;POSIX::strtol&lt;/code&gt; 使用POSIX :: strtol的功能）。它的语义有些繁琐，因此这里有一个 &lt;code&gt;getnum&lt;/code&gt; 包装函数，用于更方便的访问。此函数接受一个字符串并返回找到的数字，对于不是C浮点数的输入，则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。如果您只想说&amp;ldquo;这是浮点数吗？&amp;rdquo; ， &lt;code&gt;is_numeric&lt;/code&gt; 函数是 &lt;code&gt;getnum&lt;/code&gt; 的前端。</target>
        </trans-unit>
        <trans-unit id="fe652d8671f9747b2b27fba3ba0a6953bf5a58ab" translate="yes" xml:space="preserve">
          <source>If you're only a C programmer, than this is the end of the message for you. You can quit right now, and if you care to, save off the source and run it when you feel like it. Or not.</source>
          <target state="translated">如果你只是一个C语言程序员,比你的信息就到此为止了。你可以马上退出,如果你愿意的话,可以把源码保存下来,等你喜欢的时候再运行。也可以不运行。</target>
        </trans-unit>
        <trans-unit id="5f443393381ebb2ba3b4781af2f167f994444b4f" translate="yes" xml:space="preserve">
          <source>If you're passing a filehandle to a function, you can write the function in two ways:</source>
          <target state="translated">如果你要把一个filehandle传给一个函数,你可以用两种方式写函数。</target>
        </trans-unit>
        <trans-unit id="3681c9d29e3cea8b052a12522cde089c668422cf" translate="yes" xml:space="preserve">
          <source>If you're passing around filehandles, you could usually just use the bare typeglob, like &lt;code&gt;*STDOUT&lt;/code&gt; , but typeglobs references work, too. For example:</source>
          <target state="translated">如果要传递文件句柄，通常可以只使用裸机的typeglob，例如 &lt;code&gt;*STDOUT&lt;/code&gt; ，但是typeglobs引用也可以。例如：</target>
        </trans-unit>
        <trans-unit id="8f816f45cbfc0eef6f9ae6c1011d3c4a6ca61924" translate="yes" xml:space="preserve">
          <source>If you're planning on generating new filehandles, you could do this. Notice to pass back just the bare *FH, not its reference.</source>
          <target state="translated">如果你打算生成新的filehandles,你可以这样做。注意只传回裸的*FH,而不是它的引用。</target>
        </trans-unit>
        <trans-unit id="e8bfd94e153d8978fbc196c7118de9fb39d2dab3" translate="yes" xml:space="preserve">
          <source>If you're planning to do more extensive work than a single small fix, we encourage you to read the documentation below. This will help you focus your work and make your patches easier to incorporate into the Perl source.</source>
          <target state="translated">如果你打算做比单一的小修复更广泛的工作,我们鼓励你阅读下面的文档。这将帮助你集中精力,并使你的补丁更容易纳入Perl源代码。</target>
        </trans-unit>
        <trans-unit id="304b9d32f29eb0f2f218ff94e8f5f53580345dcb" translate="yes" xml:space="preserve">
          <source>If you're planning to filetest the return values out of a &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, you'd better prepend the directory in question. Otherwise, because we didn't &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; there, it would have been testing the wrong file.</source>
          <target state="translated">如果你打算filetest返回值出的 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; ，你最好在前面加上有问题的目录。否则，因为我们在那里没有 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; ，它将一直在测试错误的文件。</target>
        </trans-unit>
        <trans-unit id="f907870b50e1902094cd7a51307296876f77264b" translate="yes" xml:space="preserve">
          <source>If you're planning to filetest the return values out of a &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, you'd better prepend the directory in question. Otherwise, because we didn't &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; there, it would have been testing the wrong file.</source>
          <target state="translated">如果你打算filetest返回值出的 &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; ，你最好在前面加上有问题的目录。否则，因为我们在那里没有 &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; ，它将一直在测试错误的文件。</target>
        </trans-unit>
        <trans-unit id="fcece448e0aa8ee8873fb9b13cee8077eaed1e18" translate="yes" xml:space="preserve">
          <source>If you're reading this document because you want to write a formatter subclass, continue reading it and then read &lt;a href=&quot;simple/subclassing&quot;&gt;Pod::Simple::Subclassing&lt;/a&gt;, and then possibly even read &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt; (some of which is for parser-writers, but much of which is notes to formatter-writers).</source>
          <target state="translated">如果您由于要编写格式化程序子类而正在阅读本文档，请继续阅读该文档，然后阅读&lt;a href=&quot;simple/subclassing&quot;&gt;Pod :: Simple :: Subclassing&lt;/a&gt;，然后甚至可能阅读&lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;（其中一些是用于解析器-编写器的，但其中很多是是给格式化作者的注释）。</target>
        </trans-unit>
        <trans-unit id="3eca1cf4cac957f4047c12a2cccf4d8bf7c0618e" translate="yes" xml:space="preserve">
          <source>If you're reading this document just because you have a Pod-processing subclass that you want to use, this document (plus the documentation for the subclass) is probably all you need to read.</source>
          <target state="translated">如果你读这个文档只是因为你有一个你想使用的Pod处理子类,这个文档(加上子类的文档)可能是你需要阅读的全部内容。</target>
        </trans-unit>
        <trans-unit id="b7d2d7b7f7d3b1824419996342901896caf3e1ec" translate="yes" xml:space="preserve">
          <source>If you're running Perl on a system that distinguishes between text files and binary files, then you should check out &lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt; for tips for dealing with this. The key distinction between systems that need &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; and those that don't is their text file formats. Systems like Unix, Mac OS, and Plan 9, that end lines with a single character and encode that character in C as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; do not need &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt;. The rest need it.</source>
          <target state="translated">如果要在区分文本文件和二进制文件的系统上运行Perl，则应查看&lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt;中有关处理此问题的技巧。需要 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 的系统和不需要binmode的系统之间的主要区别是其文本文件格式。像Unix，Mac OS和Plan 9这样的系统，它们的结尾行带有单个字符并将该字符在C中编码为 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 则不需要 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 。其余的需要它。</target>
        </trans-unit>
        <trans-unit id="ffabd87b995f6de8b55fa057fefd0560b9ffddaf" translate="yes" xml:space="preserve">
          <source>If you're running Perl on a system that distinguishes between text files and binary files, then you should check out &lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt; for tips for dealing with this. The key distinction between systems that need &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; and those that don't is their text file formats. Systems like Unix, Mac OS, and Plan 9, that end lines with a single character and encode that character in C as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; do not need &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt;. The rest need it.</source>
          <target state="translated">如果要在区分文本文件和二进制文件的系统上运行Perl，则应查看&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;中有关处理此问题的技巧。需要 &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 的系统和不需要binmode的系统之间的主要区别是其文本文件格式。像Unix，Mac OS和Plan 9这样的系统，它们的结尾行带有单个字符并将该字符在C中编码为 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 则不需要 &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 。其余的需要它。</target>
        </trans-unit>
        <trans-unit id="39c1b50b544a3df322b75f65dc11d5ac4c69a35f" translate="yes" xml:space="preserve">
          <source>If you're storing handles in an array or hash, or in general whenever you're using any expression more complex than a bareword handle or a plain, unsubscripted scalar variable to retrieve it, you will have to use a block returning the filehandle value instead, in which case the LIST may not be omitted:</source>
          <target state="translated">如果你在数组或哈希中存储句柄,或者在一般情况下,只要你使用任何比裸词句柄或普通的无标量变量更复杂的表达式来检索它,你将不得不使用一个返回filehandle值的块来代替,在这种情况下,LIST可能不会被省略。</target>
        </trans-unit>
        <trans-unit id="1ed2a4901ca871ef8cee85b2ad371ae78f316632" translate="yes" xml:space="preserve">
          <source>If you're submitting values using the GET method, create a URL and encode the form using the &lt;code&gt;query_form&lt;/code&gt; method:</source>
          <target state="translated">如果要使用GET方法提交值，请创建一个URL并使用 &lt;code&gt;query_form&lt;/code&gt; 方法对表单进行编码：</target>
        </trans-unit>
        <trans-unit id="d5f5ca288d27f19393728db02ea58b007b723ea8" translate="yes" xml:space="preserve">
          <source>If you're talking about obscuring method calls in parent classes, see &lt;a href=&quot;perlootut#Overriding-methods-and-method-resolution&quot;&gt;Overriding methods and method resolution in perlootut&lt;/a&gt;.</source>
          <target state="translated">如果您要讨论父类中的方法调用，请参阅&lt;a href=&quot;perlootut#Overriding-methods-and-method-resolution&quot;&gt;在perlootut中覆盖方法和方法解析&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9fb0313a494e266734d606dab0fb4c3f5c1638a" translate="yes" xml:space="preserve">
          <source>If you're trying to do variable interpolation, it's definitely better to use the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; function, because the older notation can cause people to become confused with the indirect filehandle notation.</source>
          <target state="translated">如果您尝试进行变量插值，则最好使用 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; 函数，因为较旧的表示法可能会使人们与间接文件句柄表示法混淆。</target>
        </trans-unit>
        <trans-unit id="b2f801c8c750d6402e7dad5eddfca92a856a8093" translate="yes" xml:space="preserve">
          <source>If you're unsure of the meaning of an error message you've run across, &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; for an explanation. If the message isn't in perldiag, it probably isn't generated by Perl. You may have luck consulting your operating system documentation instead.</source>
          <target state="translated">如果不确定所遇到的错误消息的含义，请使用&lt;b&gt;perldoc &lt;/b&gt;&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;进行解释。如果消息不在perldiag中，则可能不是Perl生成的。您可能会改而查阅操作系统文档。</target>
        </trans-unit>
        <trans-unit id="4b93133a107f3dc1672015bebe523f72dafb6b9f" translate="yes" xml:space="preserve">
          <source>If you're uploading to CPAN, the automated gremlins will extract the README file and place that in your CPAN directory. It'll also appear in the main</source>
          <target state="translated">如果你要上传到CPAN,自动化的Gremlins会提取README文件,并把它放在你的CPAN目录中。它也会出现在主目录下的</target>
        </trans-unit>
        <trans-unit id="3ad89e38e60f381b4a7eacce6c02e2db727251db" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;Archive::Tar&lt;/code&gt; 's &lt;code&gt;extract()&lt;/code&gt; method, &lt;code&gt;setcwd()&lt;/code&gt; will be called for you.</source>
          <target state="translated">如果您使用 &lt;code&gt;Archive::Tar&lt;/code&gt; 的 &lt;code&gt;extract()&lt;/code&gt; 方法， &lt;code&gt;setcwd()&lt;/code&gt; 为您调用setcwd（）。</target>
        </trans-unit>
        <trans-unit id="0cc14a892bad71218591bbe7bbef35b81fe36647" translate="yes" xml:space="preserve">
          <source>If you're using VMStar:</source>
          <target state="translated">如果你使用的是VMStar。</target>
        </trans-unit>
        <trans-unit id="76511f6d042eedee604ffae23aa88974c6f04729" translate="yes" xml:space="preserve">
          <source>If you're using a module that's not thread-safe for some reason, you can protect yourself by using it from one, and only one thread at all. If you need multiple threads to access such a module, you can use semaphores and lots of programming discipline to control access to it. Semaphores are covered in &lt;a href=&quot;#Basic-semaphores&quot;&gt;Basic semaphores&lt;/a&gt;.</source>
          <target state="translated">如果您出于某种原因使用的模块不是线程安全的，则可以通过一个模块（仅一个线程）使用它来保护自己。如果您需要多个线程来访问此类模块，则可以使用信号量和大量编程规范来控制对其的访问。信号量包含在&lt;a href=&quot;#Basic-semaphores&quot;&gt;基本信号量中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9aa1259aa5ab1edcbb7c8ec755fbb7d9933607e8" translate="yes" xml:space="preserve">
          <source>If you're using a version of Perl before 5.004, you must call &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; once at the start of your program to seed the random number generator.</source>
          <target state="translated">如果您使用的是5.004之前的Perl版本，则必须在程序开始时调用 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 一次，以播种随机数生成器。</target>
        </trans-unit>
        <trans-unit id="9ff91ee4a99e5bbc7fa9f896e9934c1f57633ce3" translate="yes" xml:space="preserve">
          <source>If you're using localization in an application that keeps a configuration file, you might consider something like this in your project class:</source>
          <target state="translated">如果你在一个保存配置文件的应用程序中使用本地化,你可以考虑在你的项目类中使用这样的东西。</target>
        </trans-unit>
        <trans-unit id="e98919158b85262f93e6e1cca66f69e28561af51" translate="yes" xml:space="preserve">
          <source>If you're using references as keys within your hash tables, you're bound to be disappointed when retrieving your data. Indeed, Perl stringifies references used as hash table keys. If you later wish to access the items via another reference stringification (i.e. using the same reference that was used for the key originally to record the value into the hash table), it will work because both references stringify to the same string.</source>
          <target state="translated">如果你在哈希表中使用引用作为键,那么在检索数据时,你一定会失望。事实上,Perl对用作哈希表键的引用进行了字符串化处理。如果你以后想通过另一个引用串化(即使用最初用于键的同一个引用将值记录到哈希表中)来访问这些项目,就会成功,因为两个引用都串化成了同一个字符串。</target>
        </trans-unit>
        <trans-unit id="cda64e05edf4afefc7befad6697f98377f63d5c2" translate="yes" xml:space="preserve">
          <source>If you're using strict, you</source>
          <target state="translated">如果你使用严格的,你</target>
        </trans-unit>
        <trans-unit id="5149a95571d7bad870cf9d14644f05c40d4e4c11" translate="yes" xml:space="preserve">
          <source>If you're using the POST method, create your own user agent and encode the content appropriately.</source>
          <target state="translated">如果你使用的是POST方式,请创建自己的用户代理,并对内容进行适当的编码。</target>
        </trans-unit>
        <trans-unit id="94dea5f329a320df5b1676d594bbe7ddb6af4d25" translate="yes" xml:space="preserve">
          <source>If you're using untarzipme or StuffIt, the archive should be extracted now. &lt;b&gt;Or&lt;/b&gt;, you can use the freeware &lt;b&gt;suntar&lt;/b&gt; or</source>
          <target state="translated">如果您使用的是untarzipme或StuffIt，则应立即提取存档。&lt;b&gt;或者&lt;/b&gt;，您可以使用免费软件&lt;b&gt;suntar&lt;/b&gt;或</target>
        </trans-unit>
        <trans-unit id="03aaa8fe5a352318fc187dc162360b47448bfe8d" translate="yes" xml:space="preserve">
          <source>If you're working with globs at runtime, and need to disambiguate *^G from *{&quot;^G&quot;}, then you should use the raw NAME method.</source>
          <target state="translated">如果您在运行时使用 globs,并且需要从 *{&quot;^G&quot;}中辨别出 *^G,那么您应该使用 raw NAME 方法。</target>
        </trans-unit>
        <trans-unit id="86326ce985c6268f6aa266be33a273db0ac99980" translate="yes" xml:space="preserve">
          <source>If you're worried about users selecting bad passwords, you should proactively check when they try to change their password (by modifying</source>
          <target state="translated">如果你担心用户选择了不好的密码,你应该在他们试图更改密码时主动检查(通过修改</target>
        </trans-unit>
        <trans-unit id="c631e014f0d55506d4df289cf9b8b44d3544afb4" translate="yes" xml:space="preserve">
          <source>If you're writing code, such as an editor, that is supposed to be able to handle any Unicode text data, then you shouldn't be using these code points yourself, and instead allow them in the input. If you need sentinels, they should instead be something that isn't legal Unicode. For UTF-8 data, you can use the bytes 0xC1 and 0xC2 as sentinels, as they never appear in well-formed UTF-8. (There are equivalents for UTF-EBCDIC). You can also store your Unicode code points in integer variables and use negative values as sentinels.</source>
          <target state="translated">如果你写的代码,比如编辑器,应该能够处理任何Unicode文本数据,那么你不应该自己使用这些代码点,而应该在输入中允许使用。如果你需要哨兵,他们反而应该是一些不合法的Unicode。对于UTF-8数据,你可以使用字节0xC1和0xC2作为哨兵,因为它们从来不会出现在格式良好的UTF-8中。(UTF-EBCDIC也有等价物)。您也可以将Unicode码点存储在整数变量中,并使用负值作为哨兵。</target>
        </trans-unit>
        <trans-unit id="a276dfc7f44e7268960d2975b30664b78a301f5a" translate="yes" xml:space="preserve">
          <source>If you're writing your own &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, you may need to create your own iterators too. If so you'll need to subclass &lt;a href=&quot;parser/iterator&quot;&gt;TAP::Parser::Iterator&lt;/a&gt;.</source>
          <target state="translated">如果您正在编写自己的&lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;，则可能还需要创建自己的迭代器。如果是这样，则需要子类&lt;a href=&quot;parser/iterator&quot;&gt;TAP :: Parser :: Iterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d3ca82cb6d85e36f098b04f831321b68f9f28ab" translate="yes" xml:space="preserve">
          <source>If you're writing your own documentation in POD, the</source>
          <target state="translated">如果你是在POD中编写自己的文档,那么在POD中的</target>
        </trans-unit>
        <trans-unit id="609941eec97975f4a0354cdbfbac32c60f31f261" translate="yes" xml:space="preserve">
          <source>If you've already got some other kind of email object, consider passing it to &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Abstract&quot;&gt;Email::Abstract&lt;/a&gt; and then using its cast method to get an &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; object:</source>
          <target state="translated">如果您已经有了其他类型的电子邮件对象，请考虑将其传递给&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Abstract&quot;&gt;Email :: Abstract&lt;/a&gt;，然后使用其强制转换方法来获取&lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email :: MIME&lt;/a&gt;对象：</target>
        </trans-unit>
        <trans-unit id="49b89fe4b531fe550fa8cdc2584e0b4d10940e84" translate="yes" xml:space="preserve">
          <source>If you've been around Perl a while, all this talk of escape sequences may seem familiar. Similar escape sequences are used in double-quoted strings and in fact the regexps in Perl are mostly treated as double-quoted strings. This means that variables can be used in regexps as well. Just like double-quoted strings, the values of the variables in the regexp will be substituted in before the regexp is evaluated for matching purposes. So we have:</source>
          <target state="translated">如果你在Perl中呆过一段时间,那么这些关于转义序列的说法可能会显得很熟悉。类似的转义序列在双引号字符串中也有使用,事实上Perl中的regexps大多被当作双引号字符串。这意味着变量也可以在regexps中使用。就像双引号字符串一样,在评估 regexp 之前,变量的值会被替换进去,以达到匹配的目的。所以我们有</target>
        </trans-unit>
        <trans-unit id="3fd6cd86298d336909fb8326200590d5396e0f52" translate="yes" xml:space="preserve">
          <source>If you've chosen to use vac 4, be sure to run 4.4.0.3. Older versions will turn up nasty later on. For vac 5 be sure to run at least 5.0.1.0, but vac 5.0.2.6 or up is highly recommended. Note that since IBM has removed vac 5.0.2.1 through 5.0.2.5 from the software depot, these versions should be considered obsolete.</source>
          <target state="translated">如果你选择了使用vac 4,一定要运行4.4.0.3。旧版本以后会出现讨厌的情况。对于vac 5一定要至少运行5.0.1.0,但强烈建议使用vac 5.0.2.6或以上版本。请注意,由于IBM已经从软件仓库中删除了vac 5.0.2.1到5.0.2.5,这些版本应该被认为是过时的。</target>
        </trans-unit>
        <trans-unit id="7f36de392e6562a98fef168bd0f4fd2b6d55a056" translate="yes" xml:space="preserve">
          <source>If you've found a bug with the perl interpreter or one of the modules in the standard library (those that come with Perl), you can use the &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; utility that comes with Perl (&amp;gt;= 5.004). It collects information about your installation to include with your message, then sends the message to the right place.</source>
          <target state="translated">如果在perl解释器或标准库中的一个模块（Perl 随附的模块）中发现了错误，则可以使用Perl随附的&lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt;实用程序（&amp;gt; = 5.004）。它收集有关安装的信息以包括在消息中，然后将消息发送到正确的位置。</target>
        </trans-unit>
        <trans-unit id="b588af6702d40920fe6ce77142ddd4be23c82335" translate="yes" xml:space="preserve">
          <source>If you've just implemented a new feature, complete with doc, tests and well-commented code, a brief commit message will often suffice. If, however, you've just changed a single character deep in the parser or lexer, you might need to write a small novel to ensure that future readers understand what you did and why you did it.</source>
          <target state="translated">如果你刚刚实现了一个新的功能,包括文档、测试和注释完整的代码,那么一个简短的提交信息通常就足够了。然而,如果你只是在解析器或词典的深处修改了一个字符,你可能需要写一篇小小说,以确保未来的读者明白你做了什么以及为什么这么做。</target>
        </trans-unit>
        <trans-unit id="f8a6a3763262120fa20c3dbe30b8abff9d5efbc9" translate="yes" xml:space="preserve">
          <source>If you've played with the examples above and tried to embed a script that</source>
          <target state="translated">如果你玩过上面的例子,并试图嵌入一个脚本,那就是</target>
        </trans-unit>
        <trans-unit id="b894c5ed183f4f7ceceb8937af0c436c24867f7d" translate="yes" xml:space="preserve">
          <source>If you've read all the documentation in the document and the ones listed above, you're more than ready to hack on Perl.</source>
          <target state="translated">如果你已经阅读了文档中的所有文档和上面列出的文档,你已经做好了在Perl上黑客的准备。</target>
        </trans-unit>
        <trans-unit id="f7a6adb80f0b785d2ca1e30e58d59926760d3865" translate="yes" xml:space="preserve">
          <source>If you've read this far in the docs, you've seen this:</source>
          <target state="translated">如果你读了这么多文档,你已经看到了这个。</target>
        </trans-unit>
        <trans-unit id="a5397b1b280e497ccfa7136829a3dcfe46903bd5" translate="yes" xml:space="preserve">
          <source>If you've selected VMS syntax, and the file specification you pass to one of these routines contains a &quot;/&quot;, they assume you are using Unix emulation and apply the Unix syntax rules instead, for that function call only.</source>
          <target state="translated">如果你选择了VMS语法,并且你传递给这些例程的文件规范中包含了&quot;/&quot;,那么它们会假设你使用的是Unix仿真,并且仅对该函数调用应用Unix语法规则。</target>
        </trans-unit>
        <trans-unit id="33caaa832315103fc3c31014628789c923502260" translate="yes" xml:space="preserve">
          <source>If you, as a user, do not need explicit access to the &quot;seen&quot; hash, then you can set the &lt;code&gt;Sparseseen&lt;/code&gt; option to allow Data::Dumper to eschew building the &quot;seen&quot; hash for scalars that are known not to possess more than one reference. This speeds up serialization considerably if you use the XS implementation.</source>
          <target state="translated">如果您作为用户不需要显式访问&amp;ldquo;看到的&amp;rdquo;哈希，则可以设置 &lt;code&gt;Sparseseen&lt;/code&gt; 选项以允许Data :: Dumper避开为已知的标量不拥有超过的标量构建&amp;ldquo;看到的&amp;rdquo;哈希一个参考。如果使用XS实现，则可以大大加快序列化速度。</target>
        </trans-unit>
        <trans-unit id="5641fffcc326bff3bce0a7d7f55bb29dc536ec90" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;DESTROY&lt;/code&gt; method issues a warning during global destruction, the Perl interpreter will append the string &quot; during global destruction&quot; to the warning.</source>
          <target state="translated">如果您的 &lt;code&gt;DESTROY&lt;/code&gt; 方法在全局销毁期间发出警告，则Perl解释器会将字符串&amp;ldquo;全局销毁期间&amp;rdquo;附加到警告中。</target>
        </trans-unit>
        <trans-unit id="e35bc3de6478c74b3aa05b11b90d2c08a9c1eb35" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;DESTROY&lt;/code&gt; method throws an error, this error will be ignored. It will not be sent to &lt;code&gt;STDERR&lt;/code&gt; and it will not cause the program to die. However, if your destructor is running inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; block, then the error will change the value of &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">如果您的 &lt;code&gt;DESTROY&lt;/code&gt; 方法抛出错误，则将忽略此错误。它不会被发送到 &lt;code&gt;STDERR&lt;/code&gt; ，也不会导致程序死亡。但是，如果析构函数在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 块内运行，则该错误将更改 &lt;code&gt;$@&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="bd8f1a46e80e1b05c149003c578cc17ee1529e3e" translate="yes" xml:space="preserve">
          <source>If your AIX is installed with 64-bit support, you can expect 64-bit configurations to work. In combination with threads some tests might still fail.</source>
          <target state="translated">如果你的AIX安装了64位支持,你可以期待64位配置能够工作。结合线程,一些测试可能仍然会失败。</target>
        </trans-unit>
        <trans-unit id="91cec945ceabbd679cf0509d145b2a724547b098" translate="yes" xml:space="preserve">
          <source>If your AIX system is installed with 64-bit support, you can expect 64-bit configurations to work. If you want to use 64-bit Perl on AIX 6.1 you need an APAR for a libc.a bug which affects (n)dbm_XXX functions. The APAR number for this problem is IZ39077.</source>
          <target state="translated">如果你的AIX系统安装了64位支持,你可以期待64位的配置能够工作。如果你想在 AIX 6.1 上使用 64 位的 Perl,你需要一个 APAR 来解决 libc.a 的 bug,这个 bug 会影响 (n)dbm_XXX 函数。这个问题的 APAR 编号是 IZ39077。</target>
        </trans-unit>
        <trans-unit id="70f3f72afc2e138648aa89e71840c2969a866fbe" translate="yes" xml:space="preserve">
          <source>If your EXISTS function returns true, Memoize will try to fetch the cached value by invoking &lt;code&gt;C-&amp;gt;FETCH(key)&lt;/code&gt; . MyExpirePolicy::FETCH should return the cached value. Otherwise, Memoize will call the memoized function to compute the appropriate value, and will store it into the cache by calling &lt;code&gt;C-&amp;gt;STORE(key, value)&lt;/code&gt; .</source>
          <target state="translated">如果您的EXISTS函数返回true，则Memoize将尝试通过调用 &lt;code&gt;C-&amp;gt;FETCH(key)&lt;/code&gt; 来获取缓存的值。MyExpirePolicy :: FETCH应该返回缓存的值。否则，Memoize将调用被记忆的函数来计算适当的值，并通过调用 &lt;code&gt;C-&amp;gt;STORE(key, value)&lt;/code&gt; 将其存储到缓存中。</target>
        </trans-unit>
        <trans-unit id="0e28af787c875d4ef84c9b0c4d899259d2721791" translate="yes" xml:space="preserve">
          <source>If your PO and MO files are under a path elsewhere than &lt;code&gt;auto/&lt;/code&gt; , you may specify it using the &lt;code&gt;Path&lt;/code&gt; option.</source>
          <target state="translated">如果您的PO和MO文件位于 &lt;code&gt;auto/&lt;/code&gt; 之外的其他路径下，则可以使用&amp;ldquo; &lt;code&gt;Path&lt;/code&gt; 选项进行指定。</target>
        </trans-unit>
        <trans-unit id="58c89e96cd32d30e30553bcd6fbdd11d2690ecc7" translate="yes" xml:space="preserve">
          <source>If your Perl book isn't listed and you think it should be, let us know.</source>
          <target state="translated">如果您的 Perl 书籍没有被列出,而您又认为它应该被列出,请告诉我们。</target>
        </trans-unit>
        <trans-unit id="6d6e9b58c49da08447f00e52e9068c5bb7576426" translate="yes" xml:space="preserve">
          <source>If your Perl script is itself encoded in &lt;a href=&quot;#Unicode-Encodings&quot;&gt;UTF-8&lt;/a&gt;, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma must be explicitly included to enable recognition of that (in string or regular expression literals, or in identifier names). &lt;b&gt;This is the only time when an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
utf8&lt;/code&gt; is needed.&lt;/b&gt; (See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;).</source>
          <target state="translated">如果您的Perl脚本本身是用&lt;a href=&quot;#Unicode-Encodings&quot;&gt;UTF-8&lt;/a&gt;编码的，则必须明确包括 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;用法&lt;/a&gt;，以便能够识别它（在字符串或正则表达式文字中或在标识符名称中）。&lt;b&gt;这是唯一需要显式 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 时间。&lt;/b&gt;（请参阅&lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1456eed38b989e671412e5dabebc6b17a35fdee8" translate="yes" xml:space="preserve">
          <source>If your Perl success stories and testimonials may be of help to others who wish to advocate the use of Perl in their applications, or if you wish to simply express your gratitude to Larry and the Perl developers, please write to perl-thanks@perl.org .</source>
          <target state="translated">如果您的Perl成功案例和推荐对其他希望在应用程序中使用Perl的人有帮助,或者您只想表达对Larry和Perl开发者的感激之情,请写信到 perl-thanks@perl.org 。</target>
        </trans-unit>
        <trans-unit id="bb4511b53500ce7e796c6be816fd150d579ce6bd" translate="yes" xml:space="preserve">
          <source>If your Perl was configured with &lt;b&gt;-Accflags=-DPERL_MEM_LOG&lt;/b&gt;, setting the environment variable &lt;code&gt;PERL_MEM_LOG&lt;/code&gt; enables logging debug messages. The value has the form &lt;code&gt;&amp;lt;&lt;i&gt;number&lt;/i&gt;&amp;gt;[m][s][t]&lt;/code&gt;, where &lt;code&gt;&lt;i&gt;number&lt;/i&gt;&lt;/code&gt; is the file descriptor number you want to write to (2 is default), and the combination of letters specifies that you want information about (m)emory and/or (s)v, optionally with (t)imestamps. For example, &lt;code&gt;PERL_MEM_LOG=1mst&lt;/code&gt; logs all information to stdout. You can write to other opened file descriptors in a variety of ways:</source>
          <target state="translated">如果您的Perl是使用&lt;b&gt;-Accflags = -DPERL_MEM_LOG&lt;/b&gt;配置的，则设置环境变量 &lt;code&gt;PERL_MEM_LOG&lt;/code&gt; 会启用日志记录调试消息。该值的格式为 &lt;code&gt;&amp;lt;&lt;i&gt;number&lt;/i&gt;&amp;gt;[m][s][t]&lt;/code&gt; ，其中 &lt;code&gt;&lt;i&gt;number&lt;/i&gt;&lt;/code&gt; 是要写入的文件描述符号（默认为2），字母组合指定您需要有关（m）的信息emory和/或（s）v，可选地包含（t）imestamp。例如， &lt;code&gt;PERL_MEM_LOG=1mst&lt;/code&gt; 将所有信息记录到stdout。您可以通过多种方式写入其他打开的文件描述符：</target>
        </trans-unit>
        <trans-unit id="283276e9d183ad9eef7a4c2f27ba79df3995c5ec" translate="yes" xml:space="preserve">
          <source>If your algorithm requires that &lt;code&gt;reduce&lt;/code&gt; produce an identity value, then make sure that you always pass that identity value as the first argument to prevent &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; being returned</source>
          <target state="translated">如果您的算法要求 &lt;code&gt;reduce&lt;/code&gt; 产生一个标识值，请确保始终将该标识值作为第一个参数传递，以防止返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="826651d97de1fb76050036181700ee31a9d7cf34" translate="yes" xml:space="preserve">
          <source>If your application requires accepting data from untrusted sources, you are best off with a less powerful and more-likely safe serialization format and implementation. If your data is sufficiently simple, JSON is a good choice and offers maximum interoperability.</source>
          <target state="translated">如果你的应用需要接受来自不受信任的数据,你最好使用功能较弱、更可能安全的序列化格式和实现。如果你的数据足够简单,JSON是一个不错的选择,并提供了最大的互操作性。</target>
        </trans-unit>
        <trans-unit id="6fedf0cadcf133b09c8efb7dc310cff7b7302cdf" translate="yes" xml:space="preserve">
          <source>If your changes are in a single git commit, run the following commands to generate the patch file and attach it to your bug report:</source>
          <target state="translated">如果您的修改是在一次 git 提交中完成的,请运行以下命令来生成补丁文件,并将其附加到您的错误报告中。</target>
        </trans-unit>
        <trans-unit id="db2c1fd426ed9f2c60db2929723c4b3e4c8b99fa" translate="yes" xml:space="preserve">
          <source>If your changes are in multiple commits, generate a patch file for each one and provide them to perlbug's &lt;code&gt;-p&lt;/code&gt; option separated by commas:</source>
          <target state="translated">如果您所做的更改是多次提交，请为每个提交生成一个补丁文件，并将其提供给perlbug的 &lt;code&gt;-p&lt;/code&gt; 选项（以逗号分隔）：</target>
        </trans-unit>
        <trans-unit id="e23115cc45aeaf527b25ea3227a4ca58a4bbcf8b" translate="yes" xml:space="preserve">
          <source>If your class does have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method, we strongly recommend that you override &lt;code&gt;can&lt;/code&gt; in your class as well. Your overridden &lt;code&gt;can&lt;/code&gt; method should return a subroutine reference for any method that your &lt;code&gt;AUTOLOAD&lt;/code&gt; responds to.</source>
          <target state="translated">如果您的类确实具有 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法，则强烈建议您也覆盖类中的 &lt;code&gt;can&lt;/code&gt; 。覆盖的 &lt;code&gt;can&lt;/code&gt; 方法应该为 &lt;code&gt;AUTOLOAD&lt;/code&gt; 响应的任何方法返回子例程引用。</target>
        </trans-unit>
        <trans-unit id="ce7692bb0712bd055e295162eb35d771d86fcad6" translate="yes" xml:space="preserve">
          <source>If your class responds to method calls via &lt;code&gt;AUTOLOAD&lt;/code&gt; , you may want to overload &lt;code&gt;can&lt;/code&gt; to return a subroutine reference for methods which your &lt;code&gt;AUTOLOAD&lt;/code&gt; method handles.</source>
          <target state="translated">如果您的类通过 &lt;code&gt;AUTOLOAD&lt;/code&gt; 响应方法调用，则您可能希望重载 &lt;code&gt;can&lt;/code&gt; 返回 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法处理的方法的子例程引用。</target>
        </trans-unit>
        <trans-unit id="d51ef4c74c99126a798f834a23d66ffbb341d516" translate="yes" xml:space="preserve">
          <source>If your code is destined for systems with severely constrained (or missing!) virtual memory systems then you want to be</source>
          <target state="translated">如果你的代码注定要用在虚拟内存系统严重受限(或缺失!)的系统上,那么你要在你的代码中加入</target>
        </trans-unit>
        <trans-unit id="b8ec960b62faa8f2d9e01172beeee1747d962ecd" translate="yes" xml:space="preserve">
          <source>If your code is to run on Perl versions earlier than 5.20, it is worthwhile to note that using &lt;code&gt;$`&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; slows down regexp matching quite a bit, while &lt;code&gt;$&amp;amp;&lt;/code&gt; slows it down to a lesser extent, because if they are used in one regexp in a program, they are generated for</source>
          <target state="translated">如果您的代码要在5.20之前的Perl版本上运行，则值得注意的是，使用 &lt;code&gt;$`&lt;/code&gt; 和 &lt;code&gt;$'&lt;/code&gt; 会大大降低regexp匹配的速度，而 &lt;code&gt;$&amp;amp;&lt;/code&gt; 则会使其速度降低一些，因为如果在一个程序中的一个正则表达式，它们是为</target>
        </trans-unit>
        <trans-unit id="f35b1b808d1504007b3ea085214451b1ee61358c" translate="yes" xml:space="preserve">
          <source>If your code just uses the 52 letters A-Z and a-z, plus SPACE, the digits 0-9, and the punctuation characters that Perl uses, plus a few controls that are denoted by escape sequences like &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\t&lt;/code&gt; , then there's nothing special about using Perl, and your code may very well work on an ASCII machine without change.</source>
          <target state="translated">如果您的代码只使用52个字母AZ和az，再加上SPACE，数字0-9和Perl使用的标点字符，再加上一些由转义序列（如 &lt;code&gt;\n&lt;/code&gt; 和 &lt;code&gt;\t&lt;/code&gt; 表示的控件，那么没有什么特别的有关使用Perl的信息，您的代码可以很好地在ASCII机器上正常工作而无需更改。</target>
        </trans-unit>
        <trans-unit id="8e9b4a996206aa3ecbfc36df229dca4fb6c7a7b5" translate="yes" xml:space="preserve">
          <source>If your code still needs to run on older versions, stick to &lt;code&gt;foreach&lt;/code&gt; for your topicalizer and you will be less unhappy.</source>
          <target state="translated">如果您的代码仍需要在较旧的版本上运行，请坚持使用 &lt;code&gt;foreach&lt;/code&gt; 作为topicalizer，这样您会感到不满。</target>
        </trans-unit>
        <trans-unit id="dcc0823ff9797cfd85918a8c234e7eca9a51dc4f" translate="yes" xml:space="preserve">
          <source>If your command contains &lt;b&gt;special characters&lt;/b&gt; (&amp;lt; &amp;gt; | &amp;amp;), it will be internally stringified before executing the command, to avoid that these special characters are escaped and passed as arguments instead of retaining their special meaning.</source>
          <target state="translated">如果您的命令包含&lt;b&gt;特殊字符&lt;/b&gt;（&amp;lt;&amp;gt; |＆），则会在执行命令之前对其内部进行字符串化处理，以避免这些特殊字符被转义并作为参数传递而不保留其特殊含义。</target>
        </trans-unit>
        <trans-unit id="cf42d5b15f10438a9ce2c86e1004158d46b18003" translate="yes" xml:space="preserve">
          <source>If your copy of Perl is recent enough to contain this documentation (version 5.002 or later), then the perl library (and</source>
          <target state="translated">如果你的Perl版本足够新,包含了这个文档(5.002或更高版本),那么perl库(和</target>
        </trans-unit>
        <trans-unit id="2fc9b0cc9eec68d672ffff71ad1ff12aed25c2cc" translate="yes" xml:space="preserve">
          <source>If your encoding can work with PerlIO but needs line buffering, you MUST define this method so it returns true. 7bit ISO-2022 encodings are one example that needs this. When this method is missing, false is assumed.</source>
          <target state="translated">如果你的编码可以和PerlIO一起工作,但需要行缓冲,你必须定义这个方法,使它返回true。7bit ISO-2022 编码就是一个需要这个方法的例子。当这个方法缺失时,就会假定为false。</target>
        </trans-unit>
        <trans-unit id="d924438284770c83006ec82d036605b95adc1613" translate="yes" xml:space="preserve">
          <source>If your encoding does not support PerlIO for some reasons, just;</source>
          <target state="translated">如果你的编码因为某些原因不支持PerlIO,只要。</target>
        </trans-unit>
        <trans-unit id="1bb14712099b199ef0cd902ac0e502361e5d3ab8" translate="yes" xml:space="preserve">
          <source>If your executables start with something like #!perl or #!/usr/bin/perl MakeMaker will change this to the path of the perl 'Makefile.PL' was invoked with so the programs will be sure to run properly even if perl is not in /usr/bin/perl.</source>
          <target state="translated">如果你的可执行文件以#!perl或#!/usr/bin/perl这样的开头,MakeMaker会把它改成perl'Makefile.PL'被调用的路径,这样即使perl不在/usr/bin/perl中,程序也能保证正常运行。</target>
        </trans-unit>
        <trans-unit id="0c644837e9e9bd2635823c6fa674e7d01fcd0f60" translate="yes" xml:space="preserve">
          <source>If your extension uses some features of Perl which are not available on older releases of Perl, your users would appreciate an early meaningful warning. You would probably put this information into the</source>
          <target state="translated">如果你的扩展使用了Perl的一些功能,而这些功能在旧版本的Perl上是不可用的,那么你的用户会希望得到一个有意义的早期警告。你可能会把这些信息放在</target>
        </trans-unit>
        <trans-unit id="adbe147193e70e68bb2371038fd445f29bb86c7b" translate="yes" xml:space="preserve">
          <source>If your function already returns a reference, you don't need to create the reference yourself.</source>
          <target state="translated">如果你的函数已经返回一个引用,你不需要自己创建引用。</target>
        </trans-unit>
        <trans-unit id="8e3814e00e4bd2f311a16402f4ba979bbd48ac96" translate="yes" xml:space="preserve">
          <source>If your gcc is configured to use GNU as and ld but you want to use the Solaris ones instead to build perl, then you'll need to add -B/usr/ccs/bin/ to the gcc command line. One convenient way to do that is with</source>
          <target state="translated">如果你的gcc配置为使用GNU as和ld,但你想用Solaris的来编译perl,那么你需要在gcc命令行中添加-B/usr/ccs/bin/。一个方便的方法是用</target>
        </trans-unit>
        <trans-unit id="5872fc905315842d011082a682a6367cfb7ca9e6" translate="yes" xml:space="preserve">
          <source>If your hash could have repeated values, the methods above will only find one of the associated keys. This may or may not worry you. If it does worry you, you can always reverse the hash into a hash of arrays instead:</source>
          <target state="translated">如果你的哈希可能有重复的值,上面的方法只能找到其中一个关联键。这可能让你担心,也可能不担心。如果你确实担心,你可以随时将哈希反转为数组的哈希。</target>
        </trans-unit>
        <trans-unit id="a7de42f17abf69fc8056c809db5d175a47bd9c23" translate="yes" xml:space="preserve">
          <source>If your input is binary, and is supposed to remain binary, you shouldn't decode it to a text string, of course. But in all other cases, you should decode it.</source>
          <target state="translated">如果你的输入是二进制的,并且应该保持二进制,你当然不应该把它解码成一个文本字符串。但在所有其他情况下,你应该对它进行解码。</target>
        </trans-unit>
        <trans-unit id="d2667a072564b25eaaca13a334f7f9d262c4dc4d" translate="yes" xml:space="preserve">
          <source>If your lexicon is a tied hash the simple act of caching the compiled value can be fatal.</source>
          <target state="translated">如果你的词库是一个绑定的哈希,简单的缓存编译值的行为可能是致命的。</target>
        </trans-unit>
        <trans-unit id="84a874bfb13cfbdc7a992429f47c0892596ec6c2" translate="yes" xml:space="preserve">
          <source>If your locale environment variables (&lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_CTYPE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; ) contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching), the default encoding of your &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , and &lt;code&gt;STDERR&lt;/code&gt; , and of &lt;b&gt;any subsequent file open&lt;/b&gt;, is UTF-8.</source>
          <target state="translated">如果您的区域设置环境变量（ &lt;code&gt;LC_ALL&lt;/code&gt; ， &lt;code&gt;LC_CTYPE&lt;/code&gt; ， &lt;code&gt;LANG&lt;/code&gt; ）包含字符串'UTF-8'或'UTF8'（不区分大小写的匹配）， &lt;code&gt;STDIN&lt;/code&gt; ， &lt;code&gt;STDOUT&lt;/code&gt; 和 &lt;code&gt;STDERR&lt;/code&gt; 以及&lt;b&gt;所有后续文件open&lt;/b&gt;的默认编码，是UTF-8。</target>
        </trans-unit>
        <trans-unit id="6549b9662c9333f9038a43e101cb863214588ba8" translate="yes" xml:space="preserve">
          <source>If your locale is a UTF-8 locale, starting in Perl v5.20, Perl works well for all categories except &lt;code&gt;LC_COLLATE&lt;/code&gt; dealing with sorting and the &lt;code&gt;cmp&lt;/code&gt; operator.</source>
          <target state="translated">如果您的语言环境是UTF-8语言环境，则从Perl v5.20开始，Perl可以很好地适用于除 &lt;code&gt;LC_COLLATE&lt;/code&gt; 处理排序和 &lt;code&gt;cmp&lt;/code&gt; 运算符之外的所有类别。</target>
        </trans-unit>
        <trans-unit id="b3b150d3cc1b32cbef03e749b88c3f5c90012ceb" translate="yes" xml:space="preserve">
          <source>If your newly minted styles refer to any new #variables, you'll need to define a callback subroutine that will populate (or modify) those variables. They are then available for use in the style you've chosen.</source>
          <target state="translated">如果你的新样式引用了任何新的#变量,你需要定义一个回调子程序来填充(或修改)这些变量。然后它们就可以在你选择的样式中使用了。</target>
        </trans-unit>
        <trans-unit id="db09b35e2a7d627ad25d25e5e66ae789bbe364b8" translate="yes" xml:space="preserve">
          <source>If your operating system supports a proper mv(1) utility or its functional equivalent, this works:</source>
          <target state="translated">如果你的操作系统支持适当的mv(1)工具或其功能等同物,这就可以了。</target>
        </trans-unit>
        <trans-unit id="b728e9092f3f9368f8a8be6c5ce7886b0a62de25" translate="yes" xml:space="preserve">
          <source>If your patch changes code (rather than just changing documentation), you should also include one or more test cases which illustrate the bug you're fixing or validate the new functionality you're adding. In general, you should update an existing test file rather than create a new one.</source>
          <target state="translated">如果你的补丁改变了代码 (而不仅仅是改变文档),你还应该包含一个或多个测试用例,以说明你正在修复的错误或验证你正在添加的新功能。一般来说,你应该更新一个现有的测试文件,而不是创建一个新的测试文件。</target>
        </trans-unit>
        <trans-unit id="78a3de11301e669e248cee7c9e70b2562ff6e9f5" translate="yes" xml:space="preserve">
          <source>If your perl does not support times larger than &lt;code&gt;2^31&lt;/code&gt; seconds then this module is likely to fail at processing dates beyond the year 2038. There are moves afoot to fix that in perl. Alternatively use 64 bit perl. Or if none of those are options, use the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module which has support for years well into the future and past.</source>
          <target state="translated">如果您的perl不支持大于 &lt;code&gt;2^31&lt;/code&gt; 秒的时间，则此模块可能在2038年以后的处理日期失败。正在采取一些措施来修复perl中的问题。或者使用64位perl。或者，如果这些都不是选项，请使用&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;模块，该模块具有对未来和过去多年的支持。</target>
        </trans-unit>
        <trans-unit id="b5f6d77f27ea6c645390efe18bf989b76fa95e9b" translate="yes" xml:space="preserve">
          <source>If your perl is compiled with &lt;code&gt;-DDEBUGGING&lt;/code&gt; , you may use the &lt;b&gt;-Dr&lt;/b&gt; flag on the command line.</source>
          <target state="translated">如果您的perl是使用 &lt;code&gt;-DDEBUGGING&lt;/code&gt; 编译的，则可以在命令行上使用&lt;b&gt;-Dr&lt;/b&gt;标志。</target>
        </trans-unit>
        <trans-unit id="6fb3bbcc486c0ac676b28f725bda572e8ce7d210" translate="yes" xml:space="preserve">
          <source>If your perl is using Perl's malloc() and was compiled with the necessary switches (this is the default), then it will print memory usage statistics after compiling your code when &lt;code&gt;$ENV{PERL_DEBUG_MSTATS}
&amp;gt; 1&lt;/code&gt; , and before termination of the program when &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt;= 1&lt;/code&gt; . The report format is similar to the following example:</source>
          <target state="translated">如果您的perl使用Perl的malloc（）并使用必需的开关进行了编译（这是默认设置），则当 &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt; 1&lt;/code&gt; 且在程序终止之前，它将在编译代码后打印内存使用情况统计信息 &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt;= 1&lt;/code&gt; 。报告格式类似于以下示例：</target>
        </trans-unit>
        <trans-unit id="a0ec21abacef113106404f37c8ffeaf0991584f3" translate="yes" xml:space="preserve">
          <source>If your perl supports &lt;code&gt;PerlIO&lt;/code&gt; (which is the default), you can use a &lt;code&gt;PerlIO&lt;/code&gt; layer to decode and encode directly via a filehandle. The following two examples are fully identical in functionality:</source>
          <target state="translated">如果您的perl支持 &lt;code&gt;PerlIO&lt;/code&gt; （默认设置），则可以使用 &lt;code&gt;PerlIO&lt;/code&gt; 层直接通过文件句柄进行解码和编码。以下两个示例在功能上完全相同：</target>
        </trans-unit>
        <trans-unit id="091f7db96070043c9514e8ee2a91acbe99a23b27" translate="yes" xml:space="preserve">
          <source>If your rc file contains:</source>
          <target state="translated">如果你的rc文件包含:</target>
        </trans-unit>
        <trans-unit id="1cc732c143d69a605c4a486fe1919dbc8511b3b7" translate="yes" xml:space="preserve">
          <source>If your routine iterates through some kind of list (such as a list of files, or records in a database) you may consider providing a callback so that users can manipulate each element of the list in turn. File::Find provides an example of this with its &lt;code&gt;find(\&amp;amp;wanted, $dir)&lt;/code&gt; syntax.</source>
          <target state="translated">如果您的例程遍历某种类型的列表（例如文件列表或数据库中的记录），则可以考虑提供回调，以便用户可以依次操纵列表中的每个元素。File :: Find使用 &lt;code&gt;find(\&amp;amp;wanted, $dir)&lt;/code&gt; 语法提供了一个示例。</target>
        </trans-unit>
        <trans-unit id="20d69711a4dff3eb5c2c54e4925f7a2d49b42d0e" translate="yes" xml:space="preserve">
          <source>If your script works with huge numbers and Calc is too slow for them, you can also for the loading of one of these libraries and if none of them can be used, the code will die:</source>
          <target state="translated">如果你的脚本与巨大的数字一起工作,而Calc对它们来说太慢,你也可以为加载这些库中的一个,如果它们都不能被使用,代码就会死掉。</target>
        </trans-unit>
        <trans-unit id="686d70af0d50a3bff3e29e104e2f82c37c794acd" translate="yes" xml:space="preserve">
          <source>If your stdio requires a seek or eof between reads and writes on a particular stream, so does Perl. (This doesn't apply to sysread() and syswrite().)</source>
          <target state="translated">如果你的 stdio 在特定流的读写之间需要一个 seek 或 eof,Perl 也需要。(这不适用于 sysread()和 syswrite()。)</target>
        </trans-unit>
        <trans-unit id="34ff0a2e68bd649cc4624def7ce4b58902e2e24e" translate="yes" xml:space="preserve">
          <source>If your subsecond sleeping is implemented with &lt;code&gt;nanosleep()&lt;/code&gt; instead of &lt;code&gt;usleep()&lt;/code&gt; , you can mix subsecond sleeping with signals since &lt;code&gt;nanosleep()&lt;/code&gt; does not use signals. This, however, is not portable, and you should first check for the truth value of &lt;code&gt;&amp;amp;Time::HiRes::d_nanosleep&lt;/code&gt; to see whether you have nanosleep, and then carefully read your &lt;code&gt;nanosleep()&lt;/code&gt; C API documentation for any peculiarities.</source>
          <target state="translated">如果使用 &lt;code&gt;nanosleep()&lt;/code&gt; 而不是 &lt;code&gt;usleep()&lt;/code&gt; （）来实现亚秒级睡眠，则可以将亚秒级睡眠与信号混合，因为 &lt;code&gt;nanosleep()&lt;/code&gt; 不使用信号。但是，这不是可移植的，您应该首先检查 &lt;code&gt;&amp;amp;Time::HiRes::d_nanosleep&lt;/code&gt; 的真值，以查看您是否具有nanosleep，然后仔细阅读您的 &lt;code&gt;nanosleep()&lt;/code&gt; C API文档以了解是否有任何特殊之处。</target>
        </trans-unit>
        <trans-unit id="7033933f15e134ae512f052ac986d8b0ac72a9af" translate="yes" xml:space="preserve">
          <source>If your system doesn't support dynamic loading, you still probably ought to use &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;. See &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; and &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; for more information (in brief, just use &lt;b&gt;make perl&lt;/b&gt; instead of a plain &lt;b&gt;make&lt;/b&gt; to rebuild perl with a new static extension).</source>
          <target state="translated">如果您的系统不支持动态加载，您可能仍应该使用&lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;。有关更多信息，请参见&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;和&lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt;。（总之，只需使用&lt;b&gt;make perl&lt;/b&gt;而不是普通&lt;b&gt;make&lt;/b&gt;即可使用新的静态扩展名重建perl）。</target>
        </trans-unit>
        <trans-unit id="976a5d23704d8a7827f274e64a1b65ab7ed369e5" translate="yes" xml:space="preserve">
          <source>If your system has a strange pointer size--meaning a pointer is neither as big as an int nor as big as a long--it may not be possible to pack or unpack pointers in big- or little-endian byte order. Attempting to do so raises an exception.</source>
          <target state="translated">如果你的系统有一个奇怪的指针大小--意味着一个指针既没有int那么大,也没有long那么大--可能无法按照大字节或小字节的顺序打包或解包指针。试图这样做会引发一个异常。</target>
        </trans-unit>
        <trans-unit id="c8f634435d2540d4ac325a2965a4ae17a54489a6" translate="yes" xml:space="preserve">
          <source>If your system has the &lt;code&gt;sigaction()&lt;/code&gt; function then signal handlers are installed using it. This means you get reliable signal handling.</source>
          <target state="translated">如果您的系统具有 &lt;code&gt;sigaction()&lt;/code&gt; 函数，则使用该函数安装信号处理程序。这意味着您可以获得可靠的信号处理。</target>
        </trans-unit>
        <trans-unit id="fd4695d7aa352602cd4c4febe7f1355134b6280c" translate="yes" xml:space="preserve">
          <source>If your system lacks &lt;code&gt;gettimeofday()&lt;/code&gt; or an emulation of it you don't get &lt;code&gt;gettimeofday()&lt;/code&gt; or the one-argument form of &lt;code&gt;tv_interval()&lt;/code&gt; . If your system lacks all of &lt;code&gt;nanosleep()&lt;/code&gt; , &lt;code&gt;usleep()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;poll&lt;/code&gt; , you don't get &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt; , or &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; . If your system lacks both &lt;code&gt;ualarm()&lt;/code&gt; and &lt;code&gt;setitimer()&lt;/code&gt; you don't get &lt;code&gt;Time::HiRes::ualarm()&lt;/code&gt; or &lt;code&gt;Time::HiRes::alarm()&lt;/code&gt; .</source>
          <target state="translated">如果您的系统缺少 &lt;code&gt;gettimeofday()&lt;/code&gt; 或其仿真，则不会获得 &lt;code&gt;gettimeofday()&lt;/code&gt; 或 &lt;code&gt;tv_interval()&lt;/code&gt; 的单参数形式。如果您的系统缺少所有 &lt;code&gt;nanosleep()&lt;/code&gt; ， &lt;code&gt;usleep()&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;poll&lt;/code&gt; ，则不会得到 &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; ， &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt; 或 &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; 。如果您的系统同时缺少 &lt;code&gt;ualarm()&lt;/code&gt; 和 &lt;code&gt;setitimer()&lt;/code&gt; ，则不会获得 &lt;code&gt;Time::HiRes::ualarm()&lt;/code&gt; 或 &lt;code&gt;Time::HiRes::alarm()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3404e2a55faf84740517a5a0e24d39c3bdace4c" translate="yes" xml:space="preserve">
          <source>If your system supports dynamic loading, for reasons of portability and sanity you probably ought to use &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; (also part of the standard perl distribution). This tool converts C header files to Perl extensions. See &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; for how to get started with &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;.</source>
          <target state="translated">如果您的系统支持动态加载，则出于便携性和完整性的考虑，您可能应该使用&lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;（也是标准perl发行版的一部分）。此工具将C头文件转换为Perl扩展名。有关如何开始使用&lt;a href=&quot;h2xs&quot;&gt;h2xs的信息，&lt;/a&gt;请参见&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c32ad1b9a818a02634ef64d7fbd9495e5b9eebf0" translate="yes" xml:space="preserve">
          <source>If your system supports the portable operating system programming interface (POSIX), you can use the following code, which you'll note turns off echo processing as well.</source>
          <target state="translated">如果你的系统支持可移植操作系统编程接口(POSIX),你可以使用下面的代码,你会注意到它也会关闭回声处理。</target>
        </trans-unit>
        <trans-unit id="cf51a5f9f685e20ec9fa41065bc4bbf9f512757f" translate="yes" xml:space="preserve">
          <source>If z is a pure real number (i.e. &lt;code&gt;b == 0&lt;/code&gt; ), then the above yields:</source>
          <target state="translated">如果z是纯实数（即 &lt;code&gt;b == 0&lt;/code&gt; ），则上面的结果为：</target>
        </trans-unit>
        <trans-unit id="866f3e73958b23adbe3e41bd3c02c8704cd81475" translate="yes" xml:space="preserve">
          <source>If, and only if, a token is a bailout token, you can get an &quot;explanation&quot; via this method. The explanation is the text after the mystical &quot;Bail out!&quot; words which appear in the tap output.</source>
          <target state="translated">如果,也只有当一个令牌是保送令牌时,你才可以通过这个方法获得 &quot;解释&quot;。解释就是在点选输出中出现的神秘的 &quot;Bail out!&quot;字样后的文字。</target>
        </trans-unit>
        <trans-unit id="4f07d749cb3d9f280003a3874694f44dd0f9a196" translate="yes" xml:space="preserve">
          <source>If, at the end of a run you get the message</source>
          <target state="translated">如果在运行结束时,你得到的信息是</target>
        </trans-unit>
        <trans-unit id="748ad1a2344142dff26b49b0321a5e20db97e62e" translate="yes" xml:space="preserve">
          <source>If, for a given file, Perl is unable to create the backup file as specified in the extension then it will skip that file and continue on with the next one (if it exists).</source>
          <target state="translated">如果对于某个文件,Perl 无法创建扩展名中指定的备份文件,那么它将跳过该文件,继续下一个文件(如果存在的话)。</target>
        </trans-unit>
        <trans-unit id="3190be8312e8fef021a8d99a686331f02896c645" translate="yes" xml:space="preserve">
          <source>If, for some odd reason, you really want to see the whole file at once rather than processing line-by-line, you can slurp it in (as long as you can fit the whole thing in memory!):</source>
          <target state="translated">如果出于某些奇怪的原因,你真的想一次性看到整个文件,而不是逐行处理,你可以把它啧啧地放进去(只要你能把整个文件放进内存!)。</target>
        </trans-unit>
        <trans-unit id="8294d55294098cd1496efb3523c86ff173cf45ca" translate="yes" xml:space="preserve">
          <source>If, for some reason, you have a file descriptor instead of a filehandle (perhaps you used &lt;code&gt;POSIX::open&lt;/code&gt; ), you can use the &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; function from the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module:</source>
          <target state="translated">如果由于某种原因，您有一个文件描述符而不是一个文件句柄（也许您使用了 &lt;code&gt;POSIX::open&lt;/code&gt; ），则可以使用&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块中的 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="e7db8cc8d76b7ab2eda9890eb0170658ba11e9d0" translate="yes" xml:space="preserve">
          <source>If, surprisingly, the implementor of a Pod formatter can't find a satisfactory pre-existing table mapping from Unicode characters to escapes in the target format (e.g., a decent table of Unicode characters to *roff escapes), it will be necessary to build such a table. If you are in this circumstance, you should begin with the characters in the range 0x00A0 - 0x00FF, which is mostly the heavily used accented characters. Then proceed (as patience permits and fastidiousness compels) through the characters that the (X)HTML standards groups judged important enough to merit mnemonics for. These are declared in the (X)HTML specifications at the www.W3.org site. At time of writing (September 2001), the most recent entity declaration files are:</source>
          <target state="translated">如果出人意料的是,Pod格式器的实现者找不到一个令人满意的从Unicode字符到目标格式中转义符的预先存在的表(例如,一个像样的Unicode字符到*roff转义符的表),那么就需要建立这样一个表。如果你在这种情况下,你应该从0x00A0-0x00FF范围内的字符开始,这主要是大量使用的重音字符。然后(在耐心和细心的驱使下)继续(在耐心和细心的驱使下)寻找(X)HTML标准组认为足够重要的字符,以便为这些字符提供记忆符号。这些字符在 www.W3.org 网站上的 (X)HTML 规范中有所声明。在撰写本文时(2001年9月),最新的实体声明文件是:</target>
        </trans-unit>
        <trans-unit id="3906f56da4298c4e536de3ebef7105b8dabd75e9" translate="yes" xml:space="preserve">
          <source>Ignore &lt;code&gt;dSP&lt;/code&gt; and &lt;code&gt;PUSHMARK(SP)&lt;/code&gt; for now. They will be discussed in the next example.</source>
          <target state="translated">现在 &lt;code&gt;PUSHMARK(SP)&lt;/code&gt; 忽略 &lt;code&gt;dSP&lt;/code&gt; 和PUSHMARK（SP）。在下一个示例中将讨论它们。</target>
        </trans-unit>
        <trans-unit id="51be86b7131a2f6dd784631a551ad5a124bca532" translate="yes" xml:space="preserve">
          <source>Ignore ASCII vs. EBCDIC sort differences.</source>
          <target state="translated">忽略ASCII与EBCDIC的排序差异。</target>
        </trans-unit>
        <trans-unit id="be1854061543f14642d8f6508b59d601baedc0d4" translate="yes" xml:space="preserve">
          <source>Ignore case.</source>
          <target state="translated">忽略案例。</target>
        </trans-unit>
        <trans-unit id="2e352eadd6b1808d1d1be87c9129c2b0edb3ffba" translate="yes" xml:space="preserve">
          <source>Ignore the message about missing &lt;code&gt;ln&lt;/code&gt; , and about &lt;code&gt;-c&lt;/code&gt; option to tr</source>
          <target state="translated">忽略有关缺少 &lt;code&gt;ln&lt;/code&gt; 和tr的 &lt;code&gt;-c&lt;/code&gt; 选项的消息</target>
        </trans-unit>
        <trans-unit id="28a9d1669608fdb03cba836ec390fdcfb1aebfee" translate="yes" xml:space="preserve">
          <source>Ignore the warning.</source>
          <target state="translated">忽略这个警告。</target>
        </trans-unit>
        <trans-unit id="2789be88625c10d2c36088f497ee1c896ef071b5" translate="yes" xml:space="preserve">
          <source>Ignore them: in IRIX 5.3 there is no way to quieten ld about this.</source>
          <target state="translated">忽略他们:在IRIX 5.3中,没有办法让ld安静下来。</target>
        </trans-unit>
        <trans-unit id="2b4603ab54eaf129f7b585f0908e9724e9831b25" translate="yes" xml:space="preserve">
          <source>Ignores any arguments and returns a new &lt;code&gt;TAP::Parser::Scheduler::Spinner&lt;/code&gt; object.</source>
          <target state="translated">忽略任何参数，并返回一个新的 &lt;code&gt;TAP::Parser::Scheduler::Spinner&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="870e1aa14cd979f7f1df9488b978998300179625" translate="yes" xml:space="preserve">
          <source>Ignoring A Thread</source>
          <target state="translated">忽略一个主题</target>
        </trans-unit>
        <trans-unit id="817c7ffeee7200e3277cebf23a0b3dcda06d9829" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &amp;lt;</source>
          <target state="translated">伊利亚&amp;middot;扎克哈列维奇&amp;lt;</target>
        </trans-unit>
        <trans-unit id="91b2e058cf65f0cabffee0e92051934b87d3bc3b" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich (ilya@math.ohio-state.edu)</source>
          <target state="translated">Ilya Zakharevich (ilya@math.ohio-state.edu)</target>
        </trans-unit>
        <trans-unit id="031c817d16973027b8790762eb4b0c35cafca1e9" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &lt;a href=&quot;mailto:ilyaz@cpan.org&quot;&gt;mailto:ilyaz@cpan.org&lt;/a&gt;.</source>
          <target state="translated">Ilya Zakharevich &lt;a href=&quot;mailto:ilyaz@cpan.org&quot;&gt;mailto：ilyaz@cpan.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="afff5ba88102f80e4aa07d73498f8952aca29188" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &lt;a href=&quot;mailto:perl-module-hash-memoize@ilyaz.org&quot;&gt;mailto:perl-module-hash-memoize@ilyaz.org&lt;/a&gt;.</source>
          <target state="translated">Ilya Zakharevich &lt;a href=&quot;mailto:perl-module-hash-memoize@ilyaz.org&quot;&gt;mailto：perl-module-hash-memoize@ilyaz.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4248a84d563fa7da7c5bae89f2669c77f908cab3" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt;</source>
          <target state="translated">伊利亚&amp;middot; &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; Ilya Zakharevich）ilya@math.ohio-state.edu</target>
        </trans-unit>
        <trans-unit id="33d5a3e7b454b4e36eb89767df3980ae73e9890b" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich ilya@math.ohio-state.edu</source>
          <target state="translated">Ilya Zakharevich ilya@math.ohio-state.edu</target>
        </trans-unit>
        <trans-unit id="0182df78996d3eb0a76431c398a0f49f0059b1f4" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich originally extracted &lt;code&gt;XSLoader&lt;/code&gt; from &lt;code&gt;DynaLoader&lt;/code&gt; .</source>
          <target state="translated">伊利亚Zakharevich最初提取 &lt;code&gt;XSLoader&lt;/code&gt; 从 &lt;code&gt;DynaLoader&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b5ae6dbba6c0391c239461a326224f80e808d8a" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich, cpan@ilyaz.org</source>
          <target state="translated">Ilya Zakharevich,cpan@ilyaz.org。</target>
        </trans-unit>
        <trans-unit id="f84c916319b1f129948f110816b58ce5079819de" translate="yes" xml:space="preserve">
          <source>Images, Pixmap and Bitmap Manipulation, Drawing, and Graphing</source>
          <target state="translated">图像、Pixmap和位图操作、绘图和制图。</target>
        </trans-unit>
        <trans-unit id="6a42b9040934c9280685a56f5dc127e9e6ee5b8d" translate="yes" xml:space="preserve">
          <source>Imagine that the here-doc end marker is at the beginning of the line. Now you can use &lt;code&gt;\p{InKana}&lt;/code&gt; and &lt;code&gt;\P{InKana}&lt;/code&gt; .</source>
          <target state="translated">想象一下，here-doc结束标记在该行的开头。现在，您可以使用 &lt;code&gt;\p{InKana}&lt;/code&gt; 和 &lt;code&gt;\P{InKana}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fae6fb5571f38013c7696bd62a49c387d5a5d68" translate="yes" xml:space="preserve">
          <source>Immediate Filters</source>
          <target state="translated">即时过滤器</target>
        </trans-unit>
        <trans-unit id="8a696df97fa48af3310dcba0d55250b2371b7422" translate="yes" xml:space="preserve">
          <source>Immediate filters are useful for one-off situations. For more generic problems it can be useful to package the filter up in its own module.</source>
          <target state="translated">即时过滤器对一次性的情况很有用。对于更普遍的问题,可以将过滤器打包在自己的模块中。</target>
        </trans-unit>
        <trans-unit id="42b04d9e2ede4faefd5e97013f894508883e5ac4" translate="yes" xml:space="preserve">
          <source>Immediately after the check routine is called the returned node is checked for being compile-time executable. If it is (the value is judged to be constant) it is immediately executed, and a</source>
          <target state="translated">在检查例程被调用后,立即检查返回的节点是否是编译时可执行的。如果它是(值被判断为常数),它就会被立即执行,并且一个</target>
        </trans-unit>
        <trans-unit id="5d2ecc7281cc6015d762f885a1871742572e70d2" translate="yes" xml:space="preserve">
          <source>Immediately after the filter has been applied to the source, Filter::Simple will pass control to Exporter, so it can do its magic too.</source>
          <target state="translated">当过滤器被应用到源中后,Filter::Simple会立即将控制权传递给Exporter,这样它也可以发挥它的魔力。</target>
        </trans-unit>
        <trans-unit id="10353737d8f43f937641dff0028a206109a7686a" translate="yes" xml:space="preserve">
          <source>Implementation can adjust its idea of number of bytes in the buffer. Do not use this - use PerlIO_fast_gets.</source>
          <target state="translated">实现可以调整它对缓冲区中字节数的想法。不要使用这个--使用PerlIO_fast_gets。</target>
        </trans-unit>
        <trans-unit id="2c98a52672a4f466f688e44c536060b9826553e9" translate="yes" xml:space="preserve">
          <source>Implementation can return pointer to current position in the &quot;buffer&quot; and a count of bytes available in the buffer. Do not use this - use PerlIO_fast_gets.</source>
          <target state="translated">实现时可以返回指向 &quot;缓冲区 &quot;中当前位置的指针和缓冲区中可用字节数。不要使用这个--使用PerlIO_fast_gets。</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">实施细节</target>
        </trans-unit>
        <trans-unit id="867f93d010e1413848b9511b5f08d11efe452a94" translate="yes" xml:space="preserve">
          <source>Implementation of sv_copypv and sv_copypv_nomg. Calls get magic iff flags include SV_GMAGIC.</source>
          <target state="translated">sv_copypv和sv_copypv_nomg的实现。调用得到的魔力 iff标志包括SV_GMAGIC。</target>
        </trans-unit>
        <trans-unit id="93a44ec01f30940976c8468009fd696e0d07c0cd" translate="yes" xml:space="preserve">
          <source>Implementations of mktemp(), tmpnam(), and tempnam() are provided, but should be used with caution since they return only a filename that was valid when function was called, so cannot guarantee that the file will not exist by the time the caller opens the filename.</source>
          <target state="translated">提供了mktemp()、tmpnam()和tempnam()的实现,但应谨慎使用,因为它们只返回一个在函数被调用时有效的文件名,所以不能保证在调用者打开文件名时文件已经不存在。</target>
        </trans-unit>
        <trans-unit id="472357ef916af9461389e46cdf6fcf7419adc52b" translate="yes" xml:space="preserve">
          <source>Implementations should detect the error as soon as it occurs in any of the other functions and save the corresponding message for later retrieval. This will avoid problems on some platforms (such as SunOS) where the error message is very temporary (e.g., dlerror()).</source>
          <target state="translated">实现应该在任何其他函数发生错误时立即检测到错误,并保存相应的信息以便以后检索。这将避免在某些平台(如SunOS)上出现问题,因为在这些平台上,错误信息是非常临时的(例如,dlerror())。</target>
        </trans-unit>
        <trans-unit id="7772f795eb98ffae1df16f5f22b8f9f0482251d7" translate="yes" xml:space="preserve">
          <source>Implemented on 64 bit VMS 8.3. VMS requires the symbolic link to be in Unix syntax if it is intended to resolve to a valid path.</source>
          <target state="translated">在64位VMS 8.3上实现。VMS要求符号链接必须使用Unix语法,如果它是为了解析到一个有效的路径。</target>
        </trans-unit>
        <trans-unit id="5c327b5ffaa641fc9ab42ad686d92c062f812101" translate="yes" xml:space="preserve">
          <source>Implementing PerlIO Layers</source>
          <target state="translated">实现PerlIO层</target>
        </trans-unit>
        <trans-unit id="d1d235ff6e6c8fe294165e40ee8fb7af96b238c6" translate="yes" xml:space="preserve">
          <source>Implements a customized option parser used for &lt;a href=&quot;../perldoc&quot;&gt;Pod::Perldoc&lt;/a&gt;.</source>
          <target state="translated">实现用于&lt;a href=&quot;../perldoc&quot;&gt;Pod :: Perldoc&lt;/a&gt;的自定义选项解析器。</target>
        </trans-unit>
        <trans-unit id="4b6d8e1ab41db2682597810f350ac0e642396e48" translate="yes" xml:space="preserve">
          <source>Implements default import method for modules</source>
          <target state="translated">执行模块的默认导入方法</target>
        </trans-unit>
        <trans-unit id="600b4d0a91fb59ceef4048c760197d5c6d1f4db1" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">实现 &lt;code&gt;prove&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="500351adb27caa795501b65867b0b58aab9da04f" translate="yes" xml:space="preserve">
          <source>Implements the fcntl(2) function. You'll probably have to say</source>
          <target state="translated">实现fcntl(2)函数。你可能不得不说</target>
        </trans-unit>
        <trans-unit id="345a4b053fd3ba6ba91b9b4a311d01970f38b745" translate="yes" xml:space="preserve">
          <source>Implements the ioctl(2) function. You'll probably first have to say</source>
          <target state="translated">实现ioctl(2)函数。你可能会先说</target>
        </trans-unit>
        <trans-unit id="a755dd53c48e0431df0fb3c83a53268941625f80" translate="yes" xml:space="preserve">
          <source>Implicit context</source>
          <target state="translated">隐含的背景</target>
        </trans-unit>
        <trans-unit id="690e1538d5a86cb3fc7e71c1d7249c0d6e3e0181" translate="yes" xml:space="preserve">
          <source>Import all symbolic constants. Same as doing this</source>
          <target state="translated">导入所有符号常量。和这样做一样</target>
        </trans-unit>
        <trans-unit id="f641b0147eed755158e9f661a30e441db68a2b9a" translate="yes" xml:space="preserve">
          <source>Important Caveats</source>
          <target state="translated">重要注意事项</target>
        </trans-unit>
        <trans-unit id="49b3bb070775e7c46535f7d9ea2b7446b904f0e4" translate="yes" xml:space="preserve">
          <source>Important platform-specific changes</source>
          <target state="translated">平台特有的重要变化</target>
        </trans-unit>
        <trans-unit id="90ab5ed3bb3e27748d586ad9b9b11e2ab9efaaf8" translate="yes" xml:space="preserve">
          <source>Importing</source>
          <target state="translated">Importing</target>
        </trans-unit>
        <trans-unit id="a56aac727c58f5874136fceda15607b87290a37d" translate="yes" xml:space="preserve">
          <source>Importing a particular constant may not be very portable, because the import will fail on platforms that do not have that constant. A more portable way to set &lt;code&gt;$!&lt;/code&gt; to a valid value is to use:</source>
          <target state="translated">导入特定常数可能不是很容易移植，因为在没有该常数的平台上导入会失败。设置 &lt;code&gt;$!&lt;/code&gt; 更便捷的方式！有效值是使用：</target>
        </trans-unit>
        <trans-unit id="d4eab83913c9890e5e3e1ea6b76a702ac39df78f" translate="yes" xml:space="preserve">
          <source>Importing this module causes the subroutine color in Test::Builder::Tester to be called with a true value causing colour highlighting to be turned on in debug output.</source>
          <target state="translated">导入该模块后,Test::Builder::Tester中的子程序color会被调用,并带有真值,导致在调试输出中开启颜色高亮。</target>
        </trans-unit>
        <trans-unit id="b94be8f7a2bde6a23ee55b54ee8fc9eb76bd786e" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;anyinflate&lt;/code&gt; and &lt;code&gt;$AnyInflateError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;anyinflate&lt;/code&gt; 和 &lt;code&gt;$AnyInflateError&lt;/code&gt; 。与此相同</target>
        </trans-unit>
        <trans-unit id="a47d4827ba5d67c837818053a8d62f3b22e590b8" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;anyuncompress&lt;/code&gt; and &lt;code&gt;$AnyUncompressError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;anyuncompress&lt;/code&gt; 和 &lt;code&gt;$AnyUncompressError&lt;/code&gt; 。与此相同</target>
        </trans-unit>
        <trans-unit id="95b77142aa14b6211216f5a16e3e213d0c392505" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;bunzip2&lt;/code&gt; and &lt;code&gt;$Bunzip2Error&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;bunzip2&lt;/code&gt; 和 &lt;code&gt;$Bunzip2Error&lt;/code&gt; 。与此相同</target>
        </trans-unit>
        <trans-unit id="611c05e07552b8091c699fb7c8b34e627de5035f" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;bzip2&lt;/code&gt; and &lt;code&gt;$Bzip2Error&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;bzip2&lt;/code&gt; 和 &lt;code&gt;$Bzip2Error&lt;/code&gt; 。与此相同</target>
        </trans-unit>
        <trans-unit id="0f1d5114934adc139dbbd5be66e7aa4d256c7031" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;deflate&lt;/code&gt; , &lt;code&gt;$DeflateError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;deflate&lt;/code&gt; ， &lt;code&gt;$DeflateError&lt;/code&gt; 和 &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 可以使用的所有符号常量。与此相同</target>
        </trans-unit>
        <trans-unit id="c0b3cbf51bdd7f4f367077b86b68d9bc7e23e42e" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;gunzip&lt;/code&gt; and &lt;code&gt;$GunzipError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;gunzip&lt;/code&gt; 和 &lt;code&gt;$GunzipError&lt;/code&gt; 。与此相同</target>
        </trans-unit>
        <trans-unit id="d34135d0717f9ce2e7a0257450b1f62fae7932dc" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;gzip&lt;/code&gt; , &lt;code&gt;$GzipError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;gzip&lt;/code&gt; ， &lt;code&gt;$GzipError&lt;/code&gt; 和 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 可以使用的所有符号常量。与此相同</target>
        </trans-unit>
        <trans-unit id="115a4b04735017c59cebd861430122e98ed196f8" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;inflate&lt;/code&gt; and &lt;code&gt;$InflateError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">进口 &lt;code&gt;inflate&lt;/code&gt; 和 &lt;code&gt;$InflateError&lt;/code&gt; 。与此相同</target>
        </trans-unit>
        <trans-unit id="1ee8ff5937f6a57c492292c874195f1b43a7fe78" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;rawdeflate&lt;/code&gt; , &lt;code&gt;$RawDeflateError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;rawdeflate&lt;/code&gt; ， &lt;code&gt;$RawDeflateError&lt;/code&gt; 和 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 可以使用的所有符号常量。与此相同</target>
        </trans-unit>
        <trans-unit id="e767570633f5f871775c917a3828a5e9681f4ffd" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;rawinflate&lt;/code&gt; and &lt;code&gt;$RawInflateError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;rawinflate&lt;/code&gt; 和 &lt;code&gt;$RawInflateError&lt;/code&gt; 。与此相同</target>
        </trans-unit>
        <trans-unit id="fce5310acfbe49b368b9871554a40ed6e277e8c4" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;unzip&lt;/code&gt; and &lt;code&gt;$UnzipError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;unzip&lt;/code&gt; 和 &lt;code&gt;$UnzipError&lt;/code&gt; 。与此相同</target>
        </trans-unit>
        <trans-unit id="1c2f9178eea45bfd7d471760d92c394f1bace450" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;zip&lt;/code&gt; , &lt;code&gt;$ZipError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; . Same as doing this</source>
          <target state="translated">导入 &lt;code&gt;zip&lt;/code&gt; ， &lt;code&gt;$ZipError&lt;/code&gt; 和 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 可以使用的所有符号常量。与此相同</target>
        </trans-unit>
        <trans-unit id="2699b28db29be60d4c03ef4c15f7b6c27c20980d" translate="yes" xml:space="preserve">
          <source>Imports all the functions.</source>
          <target state="translated">导入所有功能。</target>
        </trans-unit>
        <trans-unit id="4e34e9af4ba46ea0c9c8bc6002dd0b4972427661" translate="yes" xml:space="preserve">
          <source>Imports some semantics into the current package from the named module, generally by aliasing certain subroutine or variable names into your package. It is exactly equivalent to</source>
          <target state="translated">将一些语义从命名的模块中导入到当前包中,通常是通过将某些子程序或变量名别名到你的包中。它完全等同于将一些语义从命名的模块中导入到当前包中,一般是通过将某些子程序或变量名别名到你的包中。</target>
        </trans-unit>
        <trans-unit id="3c2be47729bab4d065b481df08ff204f1f40d914" translate="yes" xml:space="preserve">
          <source>Imports the selected functions.</source>
          <target state="translated">导入选定的函数。</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="e283b44852c55b8cc7c5d3c10f2fb1158a34c408" translate="yes" xml:space="preserve">
          <source>In 5.000 to 5.003 perls, trigonometry was done in the &lt;a href=&quot;math/complex&quot;&gt;Math::Complex&lt;/a&gt; module. With 5.004, the &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt; module (part of the standard Perl distribution) implements the trigonometric functions. Internally it uses the &lt;a href=&quot;math/complex&quot;&gt;Math::Complex&lt;/a&gt; module and some functions can break out from the real axis into the complex plane, for example the inverse sine of 2.</source>
          <target state="translated">在5.000至5.003 perls中，三角函数是在&lt;a href=&quot;math/complex&quot;&gt;Math :: Complex&lt;/a&gt;模块中完成的。使用5.004，&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt;模块（标准Perl发行版的一部分）实现了三角函数。它在内部使用&lt;a href=&quot;math/complex&quot;&gt;Math :: Complex&lt;/a&gt;模块，某些函数可以从实轴分解为复数平面，例如2的反正弦。</target>
        </trans-unit>
        <trans-unit id="608cccc0c9bbe325204a599a0810ba75fef50b66" translate="yes" xml:space="preserve">
          <source>In 5.9.3, Newx() and friends replace the older New() API, and drops the first parameter,</source>
          <target state="translated">在5.9.3中,Newx()和friends取代了旧的New()API,并且放弃了第一个参数。</target>
        </trans-unit>
        <trans-unit id="05edeadfa5f882c58e75733f9ca5c3ffa7b75300" translate="yes" xml:space="preserve">
          <source>In 5.9.3, newSV() replaces the older NEWSV() API, and drops the first parameter,</source>
          <target state="translated">在5.9.3中,newSV()取代了旧的NEWSV()API,并删除了第一个参数。</target>
        </trans-unit>
        <trans-unit id="a0bd3ec2d46f47a7c53bb5eb7fb75ed665e3e0d8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#EXAMPLE-4&quot;&gt;EXAMPLE 4&lt;/a&gt; the second part of .xs file contained the following description of an XSUB:</source>
          <target state="translated">在&lt;a href=&quot;#EXAMPLE-4&quot;&gt;示例4&lt;/a&gt;中，.xs文件的第二部分包含XSUB的以下描述：</target>
        </trans-unit>
        <trans-unit id="f10507678ddeb0946365b72294700c17d41e824f" translate="yes" xml:space="preserve">
          <source>In &lt;b&gt;Use Rule 1&lt;/b&gt;, you can omit the curly brackets whenever the thing inside them is an atomic scalar variable like &lt;code&gt;$aref&lt;/code&gt; . For example, &lt;code&gt;@$aref&lt;/code&gt; is the same as &lt;code&gt;@{$aref}&lt;/code&gt; , and &lt;code&gt;$$aref[1]&lt;/code&gt; is the same as &lt;code&gt;${$aref}[1]&lt;/code&gt; . If you're just starting out, you may want to adopt the habit of always including the curly brackets.</source>
          <target state="translated">在&lt;b&gt;使用规则1中&lt;/b&gt;，只要其中的东西是原子标量变量（例如 &lt;code&gt;$aref&lt;/code&gt; ，就可以省略花括号。例如， &lt;code&gt;@$aref&lt;/code&gt; 与 &lt;code&gt;@{$aref}&lt;/code&gt; ，而 &lt;code&gt;$$aref[1]&lt;/code&gt; 与 &lt;code&gt;${$aref}[1]&lt;/code&gt; 。如果您只是刚入门，则可能要养成始终包含大括号的习惯。</target>
        </trans-unit>
        <trans-unit id="557547e0e5d90bb8da914cf09cde8cf85870da5a" translate="yes" xml:space="preserve">
          <source>In &lt;b&gt;shell&lt;/b&gt; programming, the syntactic combination of a program name and its arguments. More loosely, anything you type to a shell (a command interpreter) that starts it doing something. Even more loosely, a Perl &lt;b&gt;statement&lt;/b&gt;, which might start with a &lt;b&gt;label&lt;/b&gt; and typically ends with a semicolon.</source>
          <target state="translated">在&lt;b&gt;Shell&lt;/b&gt;编程中，程序名称及其参数的语法组合。更宽松地说，您键入到外壳程序（命令解释器）中的任何东西都会启动它执行某项操作。更宽松地说，Perl &lt;b&gt;语句&lt;/b&gt;可能以&lt;b&gt;标签&lt;/b&gt;开头，通常以分号结尾。</target>
        </trans-unit>
        <trans-unit id="893925583fca341ee58483bd99d5162198b9d0c6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;(?...)&lt;/code&gt; both absolute and relative backreferences may be used. The entire pattern can be reinserted with &lt;code&gt;(?R)&lt;/code&gt; or &lt;code&gt;(?0)&lt;/code&gt;. If you prefer to name your groups, you can use &lt;code&gt;(?&amp;amp;name)&lt;/code&gt; to recurse into that group.</source>
          <target state="translated">在 &lt;code&gt;(?...)&lt;/code&gt; 中，绝对引用和相对引用都可以使用。可以使用 &lt;code&gt;(?R)&lt;/code&gt; 或 &lt;code&gt;(?0)&lt;/code&gt; 重新插入整个模式。如果您想命名组，则可以使用 &lt;code&gt;(?&amp;amp;name)&lt;/code&gt; 递归到该组。</target>
        </trans-unit>
        <trans-unit id="38fa69a28fd92dcbb1d20c664855898c29a90ccb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; or its inline equivalent &lt;code&gt;\Q&lt;/code&gt; .</source>
          <target state="translated">用 &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; 或其内联等效 &lt;code&gt;\Q&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1fe5fe4877107e3688ff937058cd386854f2587" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Compress::Zlib&lt;/code&gt; version 1.x, &lt;code&gt;gzopen&lt;/code&gt; used the zlib library to open the underlying file. This made things especially tricky when a Perl filehandle was passed to &lt;code&gt;gzopen&lt;/code&gt; . Behind the scenes the numeric C file descriptor had to be extracted from the Perl filehandle and this passed to the zlib library.</source>
          <target state="translated">在 &lt;code&gt;Compress::Zlib&lt;/code&gt; 版本1.x中， &lt;code&gt;gzopen&lt;/code&gt; 使用zlib库打开基础文件。当将Perl文件句柄传递给 &lt;code&gt;gzopen&lt;/code&gt; 时，这使事情特别棘手。在幕后，必须从Perl文件句柄中提取数字C文件描述符，然后将其传递到zlib库。</target>
        </trans-unit>
        <trans-unit id="bccc4f78696454721af791a75896e8b3d0106582" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Compress::Zlib&lt;/code&gt; version 2.x, the &lt;code&gt;gzopen&lt;/code&gt; interface has been completely rewritten to use the &lt;a href=&quot;../io/compress/gzip&quot;&gt;IO::Compress::Gzip&lt;/a&gt; for writing gzip files and &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt; for reading gzip files. None of the limitations mentioned above apply.</source>
          <target state="translated">在 &lt;code&gt;Compress::Zlib&lt;/code&gt; 版本2.x中，已完全重写 &lt;code&gt;gzopen&lt;/code&gt; 接口，以使用&lt;a href=&quot;../io/compress/gzip&quot;&gt;IO :: Compress :: Gzip&lt;/a&gt;来编写gzip文件，并使用&lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO :: Uncompress :: Gunzip&lt;/a&gt;来读取gzip文件。上述限制均不适用。</target>
        </trans-unit>
        <trans-unit id="e00aec70e3db954ff900ae2d1de9b4a90ac0844b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Encode&lt;/code&gt; 2.10 or later, &lt;code&gt;LEAVE_SRC&lt;/code&gt; is also implied.</source>
          <target state="translated">在 &lt;code&gt;Encode&lt;/code&gt; 2.10或更高版本中，也暗含了 &lt;code&gt;LEAVE_SRC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51676bb8ef9795bee4bcbafed10516b2d6301ddf" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;native floating point --&amp;gt; native integer&lt;/code&gt; conversions the magnitude of the result is less than or equal to the magnitude of the source. (</source>
          <target state="translated">在 &lt;code&gt;native floating point --&amp;gt; native integer&lt;/code&gt; 转换中，结果的大小小于或等于源的大小。（</target>
        </trans-unit>
        <trans-unit id="67145b5258ab605d487808bb8f38203833e35128" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;simple_replace&lt;/code&gt; we used the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; modifier to replace all occurrences of the regexp on each line. (Even though the regular expression appears in a loop, Perl is smart enough to compile it only once.) As with &lt;code&gt;simple_grep&lt;/code&gt; , both the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/$regexp/$replacement/g&lt;/a&gt;&lt;/code&gt; use &lt;code&gt;$_&lt;/code&gt; implicitly.</source>
          <target state="translated">在 &lt;code&gt;simple_replace&lt;/code&gt; 中,我们使用 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; 修饰符替换了每行上所有出现的regexp。（即使正则表达式出现在循环中，Perl也足够聪明，只可以编译一次。）与 &lt;code&gt;simple_grep&lt;/code&gt; 一样， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/$regexp/$replacement/g&lt;/a&gt;&lt;/code&gt; 隐式使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d077e5ff0102748fbe2d5e45a0e1e202f0802167" translate="yes" xml:space="preserve">
          <source>In AIX 4.2 Perl extensions that use C++ functions that use statics may have problems in that the statics are not getting initialized. In newer AIX releases this has been solved by linking Perl with the libC_r library, but unfortunately in AIX 4.2 the said library has an obscure bug where the various functions related to time (such as time() and gettimeofday()) return broken values, and therefore in AIX 4.2 Perl is not linked against the libC_r.</source>
          <target state="translated">在AIX 4.2中,使用静态的C++函数的Perl扩展可能会出现静态没有被初始化的问题。在较新的AIX版本中,这个问题已经通过将Perl与libC_r库链接来解决,但不幸的是,在AIX 4.2中,该库有一个不明显的bug,即与时间有关的各种函数(如time()和gettimeofday())会返回破损的值,因此在AIX 4.2中,Perl不能与libC_r链接。</target>
        </trans-unit>
        <trans-unit id="5c64677f24dcacb245231383a983d4852fe14280" translate="yes" xml:space="preserve">
          <source>In BigInt, all numbers except &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; and &lt;code&gt;-inf&lt;/code&gt; are integers.</source>
          <target state="translated">在BigInt中，除了 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;+inf&lt;/code&gt; 和 &lt;code&gt;-inf&lt;/code&gt; 之外的所有数字都是整数。</target>
        </trans-unit>
        <trans-unit id="f83bdc44eedb56878bfa30e1ea8c050d2167ca73" translate="yes" xml:space="preserve">
          <source>In BigInt, unless upgrading is in effect, the result is truncated to an integer.</source>
          <target state="translated">在BigInt中,除非升级生效,否则结果将被截断为一个整数。</target>
        </trans-unit>
        <trans-unit id="a6200922eb25a34272b79346b2b9f5be87e701ac" translate="yes" xml:space="preserve">
          <source>In CVS and RCS version 1.9 is followed by 1.10. Since CPAN compares version numbers numerically we use a sprintf() to convert 1.9 to 1.009 and 1.10 to 1.010 which compare properly.</source>
          <target state="translated">在CVS和RCS中,1.9版本后面是1.10。由于CPAN用数字比较版本号,所以我们用sprintf()把1.9转换成1.009,把1.10转换成1.010,这样就能正确比较了。</target>
        </trans-unit>
        <trans-unit id="e6d98db49c1b068959bb3c31358e246a1630b67a" translate="yes" xml:space="preserve">
          <source>In CVS, RCS and SVN you use $Revision$ (see the documentation of your version control system for details). Every time the file is checked in the $Revision$ will be updated, updating your $VERSION.</source>
          <target state="translated">在 CVS、RCS 和 SVN 中,你可以使用 $Revision$ (详见你的版本控制系统的文档)。每次检查文件时,$Revision$都会被更新,更新你的$VERSION。</target>
        </trans-unit>
        <trans-unit id="562c80499b9073a3905b98e95f6a9c71ca119547" translate="yes" xml:space="preserve">
          <source>In Cray UNICOS there is some strange numerical instability that results in root(), cos(), sin(), cosh(), sinh(), losing accuracy fast. Beware. The bug may be in UNICOS math libs, in UNICOS C compiler, in Math::Complex. Whatever it is, it does not manifest itself anywhere else where Perl runs.</source>
          <target state="translated">在Cray UNICOS中,有一些奇怪的数值不稳定,导致root()、cos()、sin()、cosh()、sinh(),快速失去精度。请注意。这个bug可能存在于UNICOS数学库、UNICOS C编译器、Math::Complex中。不管是什么,在Perl运行的其他地方都没有表现出来。</target>
        </trans-unit>
        <trans-unit id="c2148313df160c8d66540765266d0deaea355ab2" translate="yes" xml:space="preserve">
          <source>In DUCET v4.0.0, primary weight of &lt;code&gt;C&lt;/code&gt; is &lt;code&gt;0E60&lt;/code&gt; and that of &lt;code&gt;D&lt;/code&gt; is &lt;code&gt;0E6D&lt;/code&gt; . So setting primary weight of &lt;code&gt;CH&lt;/code&gt; to &lt;code&gt;0E6A&lt;/code&gt; (as a value between &lt;code&gt;0E60&lt;/code&gt; and &lt;code&gt;0E6D&lt;/code&gt; ) makes ordering as &lt;code&gt;C &amp;lt; CH &amp;lt; D&lt;/code&gt; . Exactly speaking DUCET already has some characters between &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; : &lt;code&gt;small capital C&lt;/code&gt; (&lt;code&gt;U+1D04&lt;/code&gt;) with primary weight &lt;code&gt;0E64&lt;/code&gt; , &lt;code&gt;c-hook/C-hook&lt;/code&gt; (&lt;code&gt;U+0188/U+0187&lt;/code&gt;) with &lt;code&gt;0E65&lt;/code&gt; , and &lt;code&gt;c-curl&lt;/code&gt; (&lt;code&gt;U+0255&lt;/code&gt; ) with &lt;code&gt;0E69&lt;/code&gt; . Then primary weight &lt;code&gt;0E6A&lt;/code&gt; for &lt;code&gt;CH&lt;/code&gt; makes &lt;code&gt;CH&lt;/code&gt; ordered between &lt;code&gt;c-curl&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; .</source>
          <target state="translated">在DUCET v4.0.0中， &lt;code&gt;C&lt;/code&gt; 的主要权重为 &lt;code&gt;0E60&lt;/code&gt; ， &lt;code&gt;D&lt;/code&gt; 的主要权重为 &lt;code&gt;0E6D&lt;/code&gt; 。因此，将 &lt;code&gt;CH&lt;/code&gt; 的主要权重设置为 &lt;code&gt;0E6A&lt;/code&gt; （作为介于 &lt;code&gt;0E60&lt;/code&gt; 和 &lt;code&gt;0E6D&lt;/code&gt; 之间的值）可使排序为 &lt;code&gt;C &amp;lt; CH &amp;lt; D&lt;/code&gt; 。准确地说DUCET已有之间某些字符 &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; ： &lt;code&gt;small capital C&lt;/code&gt; （ &lt;code&gt;U+1D04&lt;/code&gt; 与主配重） &lt;code&gt;0E64&lt;/code&gt; ， &lt;code&gt;c-hook/C-hook&lt;/code&gt; （ &lt;code&gt;U+0188/U+0187&lt;/code&gt; ）与 &lt;code&gt;0E65&lt;/code&gt; 和 &lt;code&gt;c-curl&lt;/code&gt; （ &lt;code&gt;U+0255&lt;/code&gt; ）和 &lt;code&gt;0E69&lt;/code&gt; 。然后， &lt;code&gt;CH&lt;/code&gt; 的主要权重 &lt;code&gt;0E6A&lt;/code&gt; 使 &lt;code&gt;CH&lt;/code&gt; 在 &lt;code&gt;c-curl&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 之间有序。</target>
        </trans-unit>
        <trans-unit id="3cbd5bc5a38769b2182dd3a8ac3c64a575d3f230" translate="yes" xml:space="preserve">
          <source>In English grammar, a short noun phrase between a verb and its direct object indicating the beneficiary or recipient of the action. In Perl, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; STDOUT &quot;$foo\n&quot;;&lt;/code&gt; can be understood as &amp;ldquo;verb indirect-object object&amp;rdquo;, where &lt;code&gt;STDOUT&lt;/code&gt; is the recipient of the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; action, and &lt;code&gt;&quot;$foo&quot;&lt;/code&gt; is the object being printed. Similarly, when invoking a &lt;b&gt;method&lt;/b&gt;, you might place the invocant in the dative slot between the method and its arguments:</source>
          <target state="translated">在英语语法中，动词与其直接宾语之间的简短名词短语，指示操作的受益者或接受者。在Perl中， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; STDOUT &quot;$foo\n&quot;;&lt;/code&gt; 可以理解为&amp;ldquo;动词间接对象对象&amp;rdquo;，其中 &lt;code&gt;STDOUT&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 操作的接收者， &lt;code&gt;&quot;$foo&quot;&lt;/code&gt; 是要打印的对象。同样，在调用&lt;b&gt;方法时&lt;/b&gt;，您可以将倡导者放在方法与其参数之间的固定位置中：</target>
        </trans-unit>
        <trans-unit id="217cde63e66af3805baaae8b61bf234934e3a17f" translate="yes" xml:space="preserve">
          <source>In IRIX 5.3 and with Perl 5.8.1 (Perl 5.8.0 didn't compile in IRIX 5.3) the following failures are known.</source>
          <target state="translated">在IRIX 5.3和Perl 5.8.1中(Perl 5.8.0没有在IRIX 5.3中编译),已知有以下故障。</target>
        </trans-unit>
        <trans-unit id="ae875351a921c55e10385097f1ce568f0cc36c5c" translate="yes" xml:space="preserve">
          <source>In MakeMaker-based installations,</source>
          <target state="translated">在基于MakeMaker的安装中。</target>
        </trans-unit>
        <trans-unit id="a8ca889adcc661187e58d592f4912a7f93ee302a" translate="yes" xml:space="preserve">
          <source>In Math::BigInt, passing a negative number precision has no effect since no numbers have digits after the dot. In &lt;a href=&quot;bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;, it will round all results to P digits after the dot.</source>
          <target state="translated">在Math :: BigInt中，传递负数精度无效，因为没有数字在点后有数字。在&lt;a href=&quot;bigfloat&quot;&gt;Math :: BigFloat中&lt;/a&gt;，它将所有结果四舍五入到点后的P位。</target>
        </trans-unit>
        <trans-unit id="846e78092ad74f765fcf7c9c94ce51c84e742d1b" translate="yes" xml:space="preserve">
          <source>In Memory Databases</source>
          <target state="translated">内存数据库</target>
        </trans-unit>
        <trans-unit id="3f860bffab3d111dbe427091c4d724eab7972b48" translate="yes" xml:space="preserve">
          <source>In Part 1 we mentioned that Perl compiles a regexp into a compact sequence of opcodes. Thus, a compiled regexp is a data structure that can be stored once and used again and again. The regexp quote &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; does exactly that: &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/string/&lt;/a&gt;&lt;/code&gt; compiles the &lt;code&gt;string&lt;/code&gt; as a regexp and transforms the result into a form that can be assigned to a variable:</source>
          <target state="translated">在第1部分中，我们提到了Perl将正则表达式编译为紧凑的操作码序列。因此，已编译的正则表达式是一种数据结构，可以存储一次并反复使用。正则表达式报价 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 正是如此： &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/string/&lt;/a&gt;&lt;/code&gt; 编译 &lt;code&gt;string&lt;/code&gt; 作为正则表达式，并将结果转换成可被分配给一个变量的一种形式：</target>
        </trans-unit>
        <trans-unit id="b8e23998d4d31cf53431494db737762f35860793" translate="yes" xml:space="preserve">
          <source>In Perl 5.005, the thread model was that all data is implicitly shared, and shared access to data has to be explicitly synchronized. This model is called</source>
          <target state="translated">在Perl 5.005中,线程模型是所有的数据都是隐式共享的,共享访问数据必须显式同步。这个模型被称为</target>
        </trans-unit>
        <trans-unit id="0ef40fb67bd5325ef3bc9871c79bffa2a2f9def8" translate="yes" xml:space="preserve">
          <source>In Perl 5.10, declare the variable with &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; declaration creates the lexical variable that persists between calls to the subroutine:</source>
          <target state="translated">在Perl 5.10中，使用 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 声明变量。该 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 的声明创建词法变量调用子程序之间挖墙角：</target>
        </trans-unit>
        <trans-unit id="fcad1e403285c6c0597be1e44d89e383fc28fe4e" translate="yes" xml:space="preserve">
          <source>In Perl 5.10, the</source>
          <target state="translated">在Perl 5.10中,</target>
        </trans-unit>
        <trans-unit id="3754647e31be439690cdc120d0f37bbfc1ee49d5" translate="yes" xml:space="preserve">
          <source>In Perl 5.10, use the &lt;code&gt;given-when&lt;/code&gt; construct described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;:</source>
          <target state="translated">在Perl 5.10中，使用&lt;a href=&quot;perlsyn&quot;&gt;perlsyn中&lt;/a&gt;描述的 &lt;code&gt;given-when&lt;/code&gt; 结构：</target>
        </trans-unit>
        <trans-unit id="ef6f20b95a614e3c70a519351a658bbdee2e34af" translate="yes" xml:space="preserve">
          <source>In Perl 5.10.0 the &lt;code&gt;/p&lt;/code&gt; match operator flag and the &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; , and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables were introduced, that allowed you to suffer the penalties only on patterns marked with &lt;code&gt;/p&lt;/code&gt;.</source>
          <target state="translated">在Perl 5.10.0中，引入了 &lt;code&gt;/p&lt;/code&gt; 匹配运算符标志以及 &lt;code&gt;${^PREMATCH}&lt;/code&gt; ， &lt;code&gt;${^MATCH}&lt;/code&gt; 和 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 变量，它们使您仅能对标有 &lt;code&gt;/p&lt;/code&gt; 的模式进行惩罚。</target>
        </trans-unit>
        <trans-unit id="bfdfceeeffa73fd56622a7e4fbcd615a7de619f1" translate="yes" xml:space="preserve">
          <source>In Perl 5.16 and earlier, copy-on-write (see the next section) shared a flag bit with read-only scalars. So the only way to test whether &lt;code&gt;sv_setsv&lt;/code&gt; , etc., will raise a &quot;Modification of a read-only value&quot; error in those versions is:</source>
          <target state="translated">在Perl 5.16和更早版本中，写时复制（请参阅下一节）与只读标量共享一个标志位。因此，测试 &lt;code&gt;sv_setsv&lt;/code&gt; 等在这​​些版本中是否会引发&amp;ldquo;只读值的修改&amp;rdquo;错误的唯一方法是：</target>
        </trans-unit>
        <trans-unit id="9c29d499be725da440aa9799fa65cef604b0abdb" translate="yes" xml:space="preserve">
          <source>In Perl 5.18.0 onwards, perl started noting the presence of each of the three variables separately, and only copied that part of the string required; so in</source>
          <target state="translated">在Perl 5.18.0以后,perl开始分别注意到这三个变量的存在,并且只复制字符串中需要的那部分;所以在</target>
        </trans-unit>
        <trans-unit id="ac74f29244f42c123f550a223146503cf87cca65" translate="yes" xml:space="preserve">
          <source>In Perl 5.20 and earlier, the only pragmas to be completely supported are: &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . (&lt;code&gt;$[&lt;/code&gt; , which behaves like a pragma, is also supported.)</source>
          <target state="translated">在Perl 5.20及更早版本中，唯一受完全支持的编译指示是： &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; 。（也支持 &lt;code&gt;$[&lt;/code&gt; ，其行为类似于杂注。）</target>
        </trans-unit>
        <trans-unit id="a99daea546c9fc521d28b295e0227c75c1c77163" translate="yes" xml:space="preserve">
          <source>In Perl 5.20 and higher this is ignored. Due to a new copy-on-write mechanism, ${^PREMATCH}, ${^MATCH}, and ${^POSTMATCH} will be available after the match regardless of the modifier.</source>
          <target state="translated">在 Perl 5.20 或更高版本中,这个功能会被忽略。由于采用了新的写后复制机制,${^PREMATCH}、${^MATCH}和 ${^POSTMATCH}将在匹配后可用,而不考虑修饰符。</target>
        </trans-unit>
        <trans-unit id="5dd87335d7944293ee760ce3fce6d463be42dedd" translate="yes" xml:space="preserve">
          <source>In Perl 5.20.0 a new copy-on-write system was enabled by default, which finally fixes all performance issues with these three variables, and makes them safe to use anywhere.</source>
          <target state="translated">在Perl 5.20.0中,默认启用了一个新的copy-on-write系统,终于解决了这三个变量的所有性能问题,使它们可以安全地在任何地方使用。</target>
        </trans-unit>
        <trans-unit id="f3bfdc8baf280a72c47cbbea941ae21c16b028e7" translate="yes" xml:space="preserve">
          <source>In Perl 5.20.0 this was changed so that it would be &lt;b&gt;exactly&lt;/b&gt; the same as setting &lt;code&gt;$/&lt;/code&gt; to undef, with the exception that this warning would be thrown.</source>
          <target state="translated">在Perl 5.20.0中对此进行了更改，使其与将 &lt;code&gt;$/&lt;/code&gt; 设置为 undef &lt;b&gt;完全相同&lt;/b&gt;，不同之处在于将抛出此警告。</target>
        </trans-unit>
        <trans-unit id="b9a5cb481a025f6680fe2e560f757bef411f0354" translate="yes" xml:space="preserve">
          <source>In Perl 5.22 and later, all groups within a regexp can be set to non-capturing by using the new &lt;code&gt;/n&lt;/code&gt; flag:</source>
          <target state="translated">在Perl 5.22和更高版本中，可以使用新的 &lt;code&gt;/n&lt;/code&gt; 标志将正则表达式中的所有组设置为不捕获：</target>
        </trans-unit>
        <trans-unit id="829f62b5d0005de3966076a8745c273476071683" translate="yes" xml:space="preserve">
          <source>In Perl 5.6 and some books the &lt;code&gt;:raw&lt;/code&gt; layer (previously sometimes also referred to as a &quot;discipline&quot;) is documented as the inverse of the &lt;code&gt;:crlf&lt;/code&gt; layer. That is no longer the case - other layers which would alter the binary nature of the stream are also disabled. If you want UNIX line endings on a platform that normally does CRLF translation, but still want UTF-8 or encoding defaults, the appropriate thing to do is to add &lt;code&gt;:perlio&lt;/code&gt; to the PERLIO environment variable.</source>
          <target state="translated">在Perl 5.6和一些书籍中， &lt;code&gt;:raw&lt;/code&gt; 层（以前有时也称为&amp;ldquo;学科&amp;rdquo;）被记录为 &lt;code&gt;:crlf&lt;/code&gt; 层的反面。情况不再如此-会更改流的二进制性质的其他层也被禁用。如果要在通常执行CRLF转换的平台上使用UNIX行结尾，但仍希望使用UTF-8或编码默认值，则适当的做法是将 &lt;code&gt;:perlio&lt;/code&gt; 添加到PERLIO环境变量中。</target>
        </trans-unit>
        <trans-unit id="8fac8c7e82a994285a91ea520c95723e026d4360" translate="yes" xml:space="preserve">
          <source>In Perl 5.6, a new model was introduced in which all is was thread local and shared access to data has to be explicitly declared. This model is called</source>
          <target state="translated">在Perl 5.6中,引入了一个新的模型,在这个模型中,所有的数据都是线程本地的,对数据的共享访问必须要明确声明。这个模型被称为</target>
        </trans-unit>
        <trans-unit id="c2abdf6c9d513612683e10abfef7f22af8c5271f" translate="yes" xml:space="preserve">
          <source>In Perl 5.6, the</source>
          <target state="translated">在Perl 5.6中,</target>
        </trans-unit>
        <trans-unit id="26c0c53508feac78fbf5a2c99792e045ffa03c8a" translate="yes" xml:space="preserve">
          <source>In Perl 5.6.0 the &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; dynamic arrays were introduced that supply the indices of successful matches. So you could for example do this:</source>
          <target state="translated">在Perl 5.6.0中，引入了 &lt;code&gt;@-&lt;/code&gt; 和 &lt;code&gt;@+&lt;/code&gt; 动态数组，它们提供成功匹配的索引。因此，您可以例如执行以下操作：</target>
        </trans-unit>
        <trans-unit id="523c10b75565b9e0e195e0700fdbbd2ed237ae32" translate="yes" xml:space="preserve">
          <source>In Perl 5.8, the</source>
          <target state="translated">在Perl 5.8中,</target>
        </trans-unit>
        <trans-unit id="a58322d6122d01dd67612b6444328927a4d69bfc" translate="yes" xml:space="preserve">
          <source>In Perl 5.8.0 the slowness was often quite spectacular; in Perl 5.8.1 a caching scheme was introduced which improved the situation. In general, operations with UTF-8 encoded strings are still slower. As an example, the Unicode properties (character classes) like &lt;code&gt;\p{Nd}&lt;/code&gt; are known to be quite a bit slower (5-20 times) than their simpler counterparts like &lt;code&gt;[0-9]&lt;/code&gt; (then again, there are hundreds of Unicode characters matching &lt;code&gt;Nd&lt;/code&gt; compared with the 10 ASCII characters matching &lt;code&gt;[0-9]&lt;/code&gt; ).</source>
          <target state="translated">在Perl 5.8.0中，速度通常非常惊人。在Perl 5.8.1中引入了一种缓存方案，从而改善了这种情况。通常，使用UTF-8编码的字符串的操作仍然较慢。例如，已知 &lt;code&gt;\p{Nd}&lt;/code&gt; 类的Unicode属性（字符类）比 &lt;code&gt;[0-9]&lt;/code&gt; 之类的简单属性（5-20倍）要慢得多（5-20​​倍）（然后，还有数百种Unicode匹配 &lt;code&gt;Nd&lt;/code&gt; 的字符和匹配 &lt;code&gt;[0-9]&lt;/code&gt; 的10个ASCII字符）。</target>
        </trans-unit>
        <trans-unit id="0c85305fdff4b0749bfcf24c2c7a107269854de9" translate="yes" xml:space="preserve">
          <source>In Perl 6, &lt;code&gt;when()&lt;/code&gt; will always do an implicit smartmatch with its argument, while in Perl 5 it is convenient (albeit potentially confusing) to suppress this implicit smartmatch in various rather loosely-defined situations, as roughly outlined above. (The difference is largely because Perl 5 does not have, even internally, a boolean type.)</source>
          <target state="translated">在Perl 6中， &lt;code&gt;when()&lt;/code&gt; 将始终对其参数进行隐式智能匹配，而在Perl 5中，在各种相当松散定义的情况下抑制该隐式智能匹配很方便（尽管可能会造成混淆），如上所述。 （差异主要是因为Perl 5甚至在内部都没有布尔类型。）</target>
        </trans-unit>
        <trans-unit id="ca97d510355543881848d3f320ae7ab2b8841db0" translate="yes" xml:space="preserve">
          <source>In Perl most objects are hashes, but the OO systems we recommend keep you from having to worry about this. In practice, it's best to consider an object's internal data structure opaque.</source>
          <target state="translated">在Perl中,大多数对象都是哈希,但我们推荐的OO系统让你不必担心这个问题。在实践中,最好将对象的内部数据结构视为不透明的。</target>
        </trans-unit>
        <trans-unit id="243bad753f535e22807612697dcecab4311e323e" translate="yes" xml:space="preserve">
          <source>In Perl regular expressions, most regexp elements 'eat up' a certain amount of string when they match. For instance, the regexp element &lt;code&gt;[abc}]&lt;/code&gt; eats up one character of the string when it matches, in the sense that Perl moves to the next character position in the string after the match. There are some elements, however, that don't eat up characters (advance the character position) if they match. The examples we have seen so far are the anchors. The anchor &lt;code&gt;^&lt;/code&gt; matches the beginning of the line, but doesn't eat any characters. Similarly, the word boundary anchor &lt;code&gt;\b&lt;/code&gt; matches wherever a character matching &lt;code&gt;\w&lt;/code&gt; is next to a character that doesn't, but it doesn't eat up any characters itself. Anchors are examples of</source>
          <target state="translated">在Perl正则表达式中，大多数regexp元素匹配时会&amp;ldquo;吃掉&amp;rdquo;一定数量的字符串。例如，正则表达式元素 &lt;code&gt;[abc}]&lt;/code&gt; 在匹配时会吃掉字符串中的一个字符，从某种意义上说，Perl会在匹配后移到字符串中的下一个字符位置。但是，有些元素在匹配时不会消耗字符（提前字符位置）。到目前为止，我们看到的示例都是锚。锚点 &lt;code&gt;^&lt;/code&gt; 与行的开头匹配，但不占用任何字符。同样，单词边界锚 &lt;code&gt;\b&lt;/code&gt; 与匹配 &lt;code&gt;\w&lt;/code&gt; 的字符在不存在但不占用任何字符的字符旁边匹配。锚是</target>
        </trans-unit>
        <trans-unit id="905e1c7e56de580fc4af4b17e4c486804586d33e" translate="yes" xml:space="preserve">
          <source>In Perl terms this means that supplying the usual Perl numbers (also known as scalars, please see &lt;a href=&quot;../perldata&quot;&gt;perldata&lt;/a&gt;) as input for the trigonometric functions might produce as output results that no more are simple real numbers: instead they are complex numbers.</source>
          <target state="translated">用Perl术语来说，这意味着提供常用的Perl数（也称为标量，请参见&lt;a href=&quot;../perldata&quot;&gt;perldata&lt;/a&gt;）作为三角函数的输入可能会产生输出结果，不再是简单的实数：而是复杂的数。</target>
        </trans-unit>
        <trans-unit id="7f326f4fd32f12380a2d175a436e985d3f4c2edf" translate="yes" xml:space="preserve">
          <source>In Perl v5.14, all non-ASCII characters are quoted in non-UTF-8-encoded strings, but not quoted in UTF-8 strings.</source>
          <target state="translated">在Perl v5.14中,所有非ASCII字符在非UTF-8编码的字符串中都会被引用,但在UTF-8字符串中不会被引用。</target>
        </trans-unit>
        <trans-unit id="0ffdb19ef413239753228d33908dad38e29d542e" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^MATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$MATCH&lt;/code&gt; .</source>
          <target state="translated">在Perl v5.18及更早版本中，仅保证在使用 &lt;code&gt;/p&lt;/code&gt; 修饰符编译或执行模式时返回定义的值。在Perl v5.20中， &lt;code&gt;/p&lt;/code&gt; 修饰符不执行任何操作，因此 &lt;code&gt;${^MATCH}&lt;/code&gt; 与 &lt;code&gt;$MATCH&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="b4dbbc56c5f11021be8e37601f6986f49dc8e148" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^POSTMATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$POSTMATCH&lt;/code&gt; .</source>
          <target state="translated">在Perl v5.18及更早版本中，仅保证在使用 &lt;code&gt;/p&lt;/code&gt; 修饰符编译或执行模式时返回定义的值。在Perl v5.20中， &lt;code&gt;/p&lt;/code&gt; 修饰符不执行任何操作，因此 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 与 &lt;code&gt;$POSTMATCH&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="05c22186f7acbb5a1c00ca1269cc907a18af05f8" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^PREMATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$PREMATCH&lt;/code&gt; .</source>
          <target state="translated">在Perl v5.18及更早版本中，仅保证在使用 &lt;code&gt;/p&lt;/code&gt; 修饰符编译或执行模式时返回定义的值。在Perl v5.20中， &lt;code&gt;/p&lt;/code&gt; 修饰符不执行任何操作，因此 &lt;code&gt;${^PREMATCH}&lt;/code&gt; 与 &lt;code&gt;$PREMATCH&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="5432c77569fd0514eaa8844532d6c5cc637bdaa6" translate="yes" xml:space="preserve">
          <source>In Perl versions 5.6 and earlier the quicksort algorithm was used to implement &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;, but in Perl 5.8 a mergesort algorithm was also made available, mainly to guarantee worst case O(N log N) behaviour: the worst case of quicksort is O(N**2). In Perl 5.8 and later, quicksort defends against quadratic behaviour by shuffling large arrays before sorting.</source>
          <target state="translated">在Perl 5.6版和更早的版本中，使用了quicksort算法来实现 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; ，但是在Perl 5.8中，还提供了mergesort算法，主要是为了确保最差情况下的O（N log N）行为：quicksort的最差情况是O（N N ** 2）。在Perl 5.8和更高版本中，quicksort通过在排序之前对大型数组进行混洗来防御二次行为。</target>
        </trans-unit>
        <trans-unit id="8b481016607f0afb6a75f448e44a95f87a802232" translate="yes" xml:space="preserve">
          <source>In Perl you will get a floating point value if you do one of the following:</source>
          <target state="translated">在Perl中,如果你做了以下操作之一,你将得到一个浮点值。</target>
        </trans-unit>
        <trans-unit id="7d663b5a48798d90608073d23eaf6d6597db1534" translate="yes" xml:space="preserve">
          <source>In Perl, &lt;code&gt;else if&lt;/code&gt; is spelled &lt;code&gt;elsif&lt;/code&gt; .</source>
          <target state="translated">在Perl中， &lt;code&gt;else if&lt;/code&gt; 拼写为 &lt;code&gt;elsif&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49774beef30ebf83ad6beb68cfd55f59cc0e76e3" translate="yes" xml:space="preserve">
          <source>In Perl, a class is just a package, and methods are just subroutines. Perl doesn't get more formal than that and lets you set up the package just the way that you like it (that is, it doesn't set up anything for you).</source>
          <target state="translated">在Perl中,一个类只是一个包,而方法只是子程序。Perl不会比这更正式,它让你按照自己喜欢的方式来设置包(也就是说,它不会为你设置任何东西)。</target>
        </trans-unit>
        <trans-unit id="983e915935b5fb68c2f1bb82bb4cf04272a6754a" translate="yes" xml:space="preserve">
          <source>In Perl, a sequence of statements that defines a scope is called a block. Sometimes a block is delimited by the file containing it (in the case of a required file, or the program as a whole), and sometimes a block is delimited by the extent of a string (in the case of an eval).</source>
          <target state="translated">在Perl中,定义作用域的语句序列称为块。有时,一个块是以包含它的文件为界(如果是所需的文件,或整个程序),有时,一个块是以字符串的范围为界(如果是eval)。</target>
        </trans-unit>
        <trans-unit id="476c5432e1fcd1b2c55042740329df48b50efcfd" translate="yes" xml:space="preserve">
          <source>In Perl, an object is a blessed reference. The standard way of associating data with an object is to store the data inside the object's body, that is, the piece of data pointed to by the reference.</source>
          <target state="translated">在Perl中,一个对象是一个祝福的引用。将数据与对象关联起来的标准方法是将数据存储在对象的主体内,也就是引用所指向的那块数据。</target>
        </trans-unit>
        <trans-unit id="6459245c83006474d0636721805e8f89399cea54" translate="yes" xml:space="preserve">
          <source>In Perl, any package can be a class. The difference between a package which is a class and one which isn't is based on how the package is used. Here's our &quot;class declaration&quot; for the &lt;code&gt;File&lt;/code&gt; class:</source>
          <target state="translated">在Perl中，任何包都可以是一个类。属于类的包与不属于类的包之间的区别取决于该包的使用方式。这是 &lt;code&gt;File&lt;/code&gt; 类的&amp;ldquo;类声明&amp;rdquo; ：</target>
        </trans-unit>
        <trans-unit id="935b815c5b098d8ca1c1e87b1e728cb47b24fb51" translate="yes" xml:space="preserve">
          <source>In Perl, any value that would look like &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;&quot;0&quot;&lt;/code&gt; if evaluated in a string context. Since undefined values evaluate to &lt;code&gt;&quot;&quot;&lt;/code&gt; , all undefined values are false, but not all false values are undefined.</source>
          <target state="translated">在Perl中，如果在字符串上下文中求值，则任何看起来像 &lt;code&gt;&quot;&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 值。由于未定义的值计算为 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，因此所有未定义的值均为false，但并非所有的false值都未定义。</target>
        </trans-unit>
        <trans-unit id="56beb88cb62afd75b5b76cfb0ba20b6ebe456c89" translate="yes" xml:space="preserve">
          <source>In Perl, binary &lt;code&gt;+&lt;/code&gt; is always addition. &lt;code&gt;$string1 + $string2&lt;/code&gt; converts both strings to numbers and then adds them. To concatenate two strings, use the &lt;code&gt;.&lt;/code&gt; operator.</source>
          <target state="translated">在Perl中，二进制 &lt;code&gt;+&lt;/code&gt; 总是加法。 &lt;code&gt;$string1 + $string2&lt;/code&gt; 将两个字符串都转换为数字，然后将它们相加。要连接两个字符串，请使用 &lt;code&gt;.&lt;/code&gt; 操作员。</target>
        </trans-unit>
        <trans-unit id="a33a4933eab4c192832e758c7f44c0a0303ba50a" translate="yes" xml:space="preserve">
          <source>In Perl, methods are simply subroutines that live in a class's package. Methods are always written to receive the object as their first argument:</source>
          <target state="translated">在Perl中,方法只是存在于类的包中的子程序。方法的编写总是以接收对象作为其第一个参数。</target>
        </trans-unit>
        <trans-unit id="ea72a9a423acf3df90a345514eea4421a19ceb17" translate="yes" xml:space="preserve">
          <source>In Perl, the debugger is not a separate program the way it usually is in the typical compiled environment. Instead, the &lt;b&gt;-d&lt;/b&gt; flag tells the compiler to insert source information into the parse trees it's about to hand off to the interpreter. That means your code must first compile correctly for the debugger to work on it. Then when the interpreter starts up, it preloads a special Perl library file containing the debugger.</source>
          <target state="translated">在Perl中，调试器不是典型的编译环境中通常所用的独立程序。相反，&lt;b&gt;-d&lt;/b&gt;标志告诉编译器将源信息插入要移交给解释器的解析树中。这意味着您的代码必须首先正确编译，调试器才能对其进行处理。然后，当解释器启动时，它会预加载一个包含调试器的特殊Perl库文件。</target>
        </trans-unit>
        <trans-unit id="3c642476c3d73c23016f66bc533c3f6f2db6cded" translate="yes" xml:space="preserve">
          <source>In Perl, the operator determines what operation is performed, independent of the type of the operands. For example &lt;code&gt;$x + $y&lt;/code&gt; is always a numeric addition, and if &lt;code&gt;$x&lt;/code&gt; or &lt;code&gt;$y&lt;/code&gt; do not contain numbers, an attempt is made to convert them to numbers first.</source>
          <target state="translated">在Perl中，运算符确定执行什么运算，而与操作数的类型无关。例如， &lt;code&gt;$x + $y&lt;/code&gt; 始终是数字加法，如果 &lt;code&gt;$x&lt;/code&gt; 或 &lt;code&gt;$y&lt;/code&gt; 不包含数字，则会尝试首先将它们转换为数字。</target>
        </trans-unit>
        <trans-unit id="05577297c46ae0d2cd55a130e9e49792d0bf233a" translate="yes" xml:space="preserve">
          <source>In Perl, there is no special keyword for constructing an object. However, most OO modules on CPAN use a method named &lt;code&gt;new()&lt;/code&gt; to construct a new object:</source>
          <target state="translated">在Perl中，没有用于构造对象的特殊关键字。但是，CPAN上的大多数OO模块都使用名为 &lt;code&gt;new()&lt;/code&gt; 的方法来构造新对象：</target>
        </trans-unit>
        <trans-unit id="e4aecd76031e1346a21238102ea29667311ebe2a" translate="yes" xml:space="preserve">
          <source>In Perl, you just can't access memory at random, but the structural and representational conversion provided by &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is an excellent alternative. The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function converts values to a byte sequence containing representations according to a given specification, the so-called &quot;template&quot; argument. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is the reverse process, deriving some values from the contents of a string of bytes. (Be cautioned, however, that not all that has been packed together can be neatly unpacked - a very common experience as seasoned travellers are likely to confirm.)</source>
          <target state="translated">在Perl中，您只是不能随机访问内存，但是 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 提供的结构和表示转换是一个很好的选择。所述 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 函数转换值，以根据给定的规范包含表示一个字节序列，即所谓的&amp;ldquo;模板&amp;rdquo;的说法。 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 是相反的过程，它从一串字节的内容中得出一些值。（但是请注意，并不是所有打包在一起的东西都可以整齐地打包-经验丰富的旅行者很可能会证实这是非常普遍的体验。）</target>
        </trans-unit>
        <trans-unit id="3a69ee0657acfe60fc783ea37121861ef3e8b2c7" translate="yes" xml:space="preserve">
          <source>In Practice</source>
          <target state="translated">在实践中</target>
        </trans-unit>
        <trans-unit id="9c9de61f162399b6dd1501b64047f173f7ebabe0" translate="yes" xml:space="preserve">
          <source>In SVN, $Revision$ should be the same for every file in the project so they would all have the same $VERSION. CVS and RCS have a different $Revision$ per file so each file will have a different $VERSION. Distributed version control systems, such as SVK, may have a different $Revision$ based on who checks out the file, leading to a different $VERSION on each machine! Finally, some distributed version control systems, such as darcs, have no concept of revision number at all.</source>
          <target state="translated">在SVN中,$Revision$对项目中的每个文件都应该是相同的,所以它们都有相同的$VERSION。CVS和RCS的每个文件有不同的$Revision$,所以每个文件将有不同的$VERSION。分布式版本控制系统,如SVK,可能有一个不同的$Revision$根据谁检查出的文件,导致在每台机器上的$VERSION不同!最后,一些分布式版本控制系统,如SVK,可能有一个不同的$Revision$根据谁检查出的文件,导致在每台机器上的$VERSION不同!最后,一些分布式版本控制系统,如SVK,可能有一个不同的$Revision$根据谁检查出的文件,导致在每台机器上的$VERSION不同!最后,一些分布式版本控制系统,如SVK,可能有一个不同的$Revision$根据谁检查出的文件,导致在每台机器上的$VERSION不同!最后,一些分布式版本控制系统,如SVK,可能有一个不同的$Revision$根据谁检查出的文件,导致在每台机器上的$VERSION不同 最后,一些分布式版本控制系统,如darcs,根本没有版本号的概念。</target>
        </trans-unit>
        <trans-unit id="35c376db5dd46f66500036f6b8bff5133701d987" translate="yes" xml:space="preserve">
          <source>In SunOS 4.x you most probably want to use the SunOS ld, /usr/bin/ld, since the more recent versions of GNU ld (like 2.13) do not seem to work for building Perl anymore. When linking the extensions, the GNU ld gets very unhappy and spews a lot of errors like this</source>
          <target state="translated">在 SunOS 4.x 中,你可能最想使用 SunOS 的 ld,即 /usr/bin/ld,因为较新版本的 GNU ld(如 2.13)似乎已经不能用于构建 Perl 了。当连接扩展时,GNU ld 会变得非常不高兴,并发出许多错误信息,比如说</target>
        </trans-unit>
        <trans-unit id="ef1e3aace4bede70eba3cee6d6eb0864ab35df15" translate="yes" xml:space="preserve">
          <source>In Tru64 Perl is automatically able to use large files, that is, files larger than 2 gigabytes, there is no need to use the Configure -Duselargefiles option as described in INSTALL (though using the option is harmless).</source>
          <target state="translated">在Tru64中Perl是可以自动使用大文件的,也就是大于2千兆字节的文件,没有必要使用INSTALL中描述的Configure -Duselargefiles选项(虽然使用该选项是无害的)。</target>
        </trans-unit>
        <trans-unit id="cc19255447bc355361ae2f45799e7311a851742c" translate="yes" xml:space="preserve">
          <source>In Tru64 Perl's integers are automatically 64-bit wide, there is no need to use the Configure -Duse64bitint option as described in INSTALL. Similarly, there is no need for -Duse64bitall since pointers are automatically 64-bit wide.</source>
          <target state="translated">在 Tru64 Perl 中,整数自动是 64 位宽,因此不需要使用 INSTALL 中描述的 Configure -Duse64bitint 选项。同样地,也不需要使用 -Duse64bitall 选项,因为指针自动是 64 位宽的。</target>
        </trans-unit>
        <trans-unit id="92e8004abe586abe7845a841b1a5b8acbf9b5035" translate="yes" xml:space="preserve">
          <source>In Tru64 V5 (at least V5.1A, V5.1B) you cannot build threaded Perl with gcc because the system header &amp;lt;pthread.h&amp;gt; explicitly checks for supported C compilers, gcc (at least 3.2.2) not being one of them. But the system C compiler should work just fine.</source>
          <target state="translated">在Tru64 V5（至少V5.1A，V5.1B）中，无法使用gcc构建线程化的Perl，因为系统头文件&amp;lt;pthread.h&amp;gt;明确检查受支持的C编译器，gcc（至少3.2.2）不是其中之一。 。但是系统C编译器应该可以正常工作。</target>
        </trans-unit>
        <trans-unit id="6303bf4cf60f3cd73bbb5bee3d92ebf1b27db248" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, it is not guaranteed that the lexer buffer actually contains valid UTF-8. Lexing code must be robust in the face of invalid encoding.</source>
          <target state="translated">在UTF-8模式下,并不能保证词典缓冲区实际包含有效的UTF-8。在面对无效编码的情况下,词法代码必须是稳健的。</target>
        </trans-unit>
        <trans-unit id="5587dff620034120288215aaa5eec31db833ac28" translate="yes" xml:space="preserve">
          <source>In Unicode 4.1.0, the definition D2 of canonical composition (which affects NFC and NFKC) has been changed (see Public Review Issue #29 and recent UAX #15). This module has used the newer definition since the version 0.07 (Oct 31, 2001). This module will not support the normalization according to the older definition, even if the Unicode version implemented by perl is lower than 4.1.0.</source>
          <target state="translated">在Unicode 4.1.0中,规范构成的D2定义(影响NFC和NFKC)已被修改(见公共评论问题#29和最近的UAX#15)。这个模块从0.07版本(2001年10月31日)开始就使用了新的定义。即使perl实现的Unicode版本低于4.1.0,本模块也不支持按照旧定义进行规范化。</target>
        </trans-unit>
        <trans-unit id="4add5639cbd0356c9e63afa54113a4c2eb6433cf" translate="yes" xml:space="preserve">
          <source>In Unicode terminology a</source>
          <target state="translated">在Unicode术语中,一个</target>
        </trans-unit>
        <trans-unit id="f8ecaf55c52d72cac38172d4d214a7acd326645e" translate="yes" xml:space="preserve">
          <source>In Unicode, not just characters with the General Category of Lowercase Letter, but any character with the Lowercase property, including Modifier Letters, Letter Numbers, some Other Symbols, and one Combining Mark.</source>
          <target state="translated">在Unicode中,不仅仅是小写字母一般类别的字符,而是任何具有小写属性的字符,包括修饰字母、字母数字、一些其他符号和一个组合标记。</target>
        </trans-unit>
        <trans-unit id="6d6e7c6b62a7207f53debc7941773b1adb72b5b5" translate="yes" xml:space="preserve">
          <source>In Unicode, not just characters with the General Category of Uppercase Letter, but any character with the Uppercase property, including some Letter Numbers and Symbols. Not to be confused with &lt;b&gt;titlecase&lt;/b&gt;.</source>
          <target state="translated">在Unicode中，不仅具有大写字母常规类别的字符，而且具有大写字母属性的任何字符，包括一些字母数字和符号。不要与&lt;b&gt;titlecase&lt;/b&gt;混淆。</target>
        </trans-unit>
        <trans-unit id="b113bf75921160dcb55ede1f720912618b376337" translate="yes" xml:space="preserve">
          <source>In Unix, a sequence of zero or more nonnewline characters terminated with a &lt;b&gt;newline&lt;/b&gt; character. On non-Unix machines, this is emulated by the C library even if the underlying &lt;b&gt;operating system&lt;/b&gt; has different ideas.</source>
          <target state="translated">在Unix中，零个或多个非&lt;b&gt;换行&lt;/b&gt;字符序列以&lt;b&gt;换行符&lt;/b&gt;终止。在非Unix机器上，即使底层&lt;b&gt;操作系统&lt;/b&gt;有不同的想法，也可以由C库来模拟。</target>
        </trans-unit>
        <trans-unit id="1bf9694eb8cd962c6afbe1434566f7218f970b1f" translate="yes" xml:space="preserve">
          <source>In Windows platforms, &lt;code&gt;$^O&lt;/code&gt; is not very helpful: since it is always &lt;code&gt;MSWin32&lt;/code&gt; , it doesn't tell the difference between 95/98/ME/NT/2000/XP/CE/.NET. Use &lt;code&gt;Win32::GetOSName()&lt;/code&gt; or Win32::GetOSVersion() (see &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt; and &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;) to distinguish between the variants.</source>
          <target state="translated">在Windows平台上， &lt;code&gt;$^O&lt;/code&gt; 并不是很有帮助：由于它始终是 &lt;code&gt;MSWin32&lt;/code&gt; ，因此无法区分95/98 / ME / NT / 2000 / XP / CE / .NET。使用 &lt;code&gt;Win32::GetOSName()&lt;/code&gt; 或Win32 :: GetOSVersion（）（请参阅&lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt;和&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;）来区分这些变体。</target>
        </trans-unit>
        <trans-unit id="d8d2f9cdc2abce1c37c00210e5a99994671e5e54" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt; code, text may contain formatting codes for formatting or for E&amp;lt;...&amp;gt; escapes, as in:</source>
          <target state="translated">在 &lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt; 代码中，文本可能包含用于格式化或E &amp;lt;...&amp;gt;转义的格式化代码，如下所示：</target>
        </trans-unit>
        <trans-unit id="01e19714f7b922e3746b1633bf7eecd4c7104aed" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loop, &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; can be used to detect the end of each file, whereas &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; will detect the end of the very last file only. Examples:</source>
          <target state="translated">在 &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; 循环中，可以使用 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; 检测每个文件的结尾，而 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 仅检测最后一个文件的结尾。例子：</target>
        </trans-unit>
        <trans-unit id="41690d136fbd264eb140c8b8c6cc615177c5eb14" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loop, &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; can be used to detect the end of each file, whereas &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; will detect the end of the very last file only. Examples:</source>
          <target state="translated">在 &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; 循环中，可以使用 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; 检测每个文件的结尾，而 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 仅检测最后一个文件的结尾。例子：</target>
        </trans-unit>
        <trans-unit id="bc099e33e27d3f3cccb59648c75894207f5a15fa" translate="yes" xml:space="preserve">
          <source>In a Perl built for debugging, some buckets may have negative usable size. This means that these buckets cannot (and will not) be used. For larger buckets, the memory footprint may be one page greater than a power of 2. If so, the corresponding power of two is printed in the &lt;code&gt;APPROX&lt;/code&gt; field above.</source>
          <target state="translated">在为调试而构建的Perl中，某些存储桶可能具有负的可用大小。这意味着这些存储桶不能（也不会）被使用。对于较大的存储桶，内存占用量可能比2的幂大1页。如果是，则在上面的 &lt;code&gt;APPROX&lt;/code&gt; 字段中打印相应的2幂。</target>
        </trans-unit>
        <trans-unit id="9d530f843344f7a394d5586d561f13c274faa0f4" translate="yes" xml:space="preserve">
          <source>In a Perl version number such as 5.6.2, this is the 2. Values greater than 50 represent potentially unstable development subversions. This value is manually set in</source>
          <target state="translated">在Perl的版本号中,比如5.6.2,这个值是2,大于50的值代表潜在的不稳定的开发subversion。这个值是在</target>
        </trans-unit>
        <trans-unit id="0f808181882ea1893d708887496cf67865ae159d" translate="yes" xml:space="preserve">
          <source>In a Perl version number such as 5.6.2, this is the 5. This value is manually set in</source>
          <target state="translated">在Perl的版本号中,比如5.6.2,就是5,这个值是在</target>
        </trans-unit>
        <trans-unit id="9adb69905ef42f7e50e2708e20623f57aec71e19" translate="yes" xml:space="preserve">
          <source>In a Perl version number such as 5.6.2, this is the 6. This value is manually set in</source>
          <target state="translated">在Perl的版本号中,比如5.6.2,这个值是6,这个值是在</target>
        </trans-unit>
        <trans-unit id="00e75241de38f496d3e98c78e65b223be163fce0" translate="yes" xml:space="preserve">
          <source>In a UTF-8 locale in v5.20 and later, the only visible difference between locale and non-locale in regular expressions should be tainting (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;).</source>
          <target state="translated">在v5.20及更高版本中的UTF-8语言环境中，在正则表达式中语言环境和非语言环境之间唯一可见的区别应该是污点（请参阅&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="684ae84268e30b89f35130d6bd4027aeb36b7294" translate="yes" xml:space="preserve">
          <source>In a bracketed character class in a regular expression pattern, you had a range which has exactly one end of it specified using &lt;code&gt;\N{}&lt;/code&gt; , and the other end is specified using a non-portable mechanism. Perl treats the range as a Unicode range, that is, all the characters in it are considered to be the Unicode characters, and which may be different code points on some platforms Perl runs on. For example, &lt;code&gt;[\N{U+06}-\x08]&lt;/code&gt; is treated as if you had instead said &lt;code&gt;[\N{U+06}-\N{U+08}]&lt;/code&gt; , that is it matches the characters whose code points in Unicode are 6, 7, and 8. But that &lt;code&gt;\x08&lt;/code&gt; might indicate that you meant something different, so the warning gets raised.</source>
          <target state="translated">在正则表达式模式中的带括号的字符类中，您具有一个范围，该范围的一端恰好使用 &lt;code&gt;\N{}&lt;/code&gt; 指定，而另一端则使用非便携式机制指定。Perl将范围视为Unicode范围，也就是说，其中的所有字符都被视为Unicode字符，并且在Perl运行的某些平台上可能是不同的代码点。例如，将 &lt;code&gt;[\N{U+06}-\x08]&lt;/code&gt; 视为您说了 &lt;code&gt;[\N{U+06}-\N{U+08}]&lt;/code&gt; ，即它与代码点指向的字符匹配Unicode中的6、7和8。但是 &lt;code&gt;\x08&lt;/code&gt; 可能表示您的意思有所不同，因此会出现警告。</target>
        </trans-unit>
        <trans-unit id="1004ce202059ee590c51b52b194413677ea17ca4" translate="yes" xml:space="preserve">
          <source>In a context not requiring a list value, the value of what appears to be a list literal is simply the value of the final element, as with the C comma operator. For example,</source>
          <target state="translated">在不需要列表值的上下文中,看似列表文字的值只是最后一个元素的值,就像C逗号操作符一样。例如</target>
        </trans-unit>
        <trans-unit id="4c9fb939bd1697123252f0ff4192d8603d7b42ba" translate="yes" xml:space="preserve">
          <source>In a future version of Storable, we intend to provide options to disable loading modules for classes and to disable deserializing objects altogether.</source>
          <target state="translated">在Storable的未来版本中,我们打算提供选项来禁用类的加载模块和完全禁用对象的反序列化。</target>
        </trans-unit>
        <trans-unit id="7f48268e7084e302cd8de3636cf3c45d91f67d83" translate="yes" xml:space="preserve">
          <source>In a list context it returns a list of all the operator names. (Not yet implemented, use @names = opset_to_ops(full_opset).)</source>
          <target state="translated">在列表上下文中,它返回一个所有操作者名称的列表。(尚未实现,使用 @names=opset_to_ops(full_opset))。</target>
        </trans-unit>
        <trans-unit id="b5d9986ae8bd12e0cac8222f9f5aeaf66d07a75b" translate="yes" xml:space="preserve">
          <source>In a list context it returns the inflation object, &lt;code&gt;$i&lt;/code&gt; , and the</source>
          <target state="translated">在列表上下文中，它返回通胀对象 &lt;code&gt;$i&lt;/code&gt; 和</target>
        </trans-unit>
        <trans-unit id="145c4668502bd10d7409835c5418f6cbabe20a25" translate="yes" xml:space="preserve">
          <source>In a list context it returns the inflation stream, &lt;code&gt;$i&lt;/code&gt; , and the</source>
          <target state="translated">在列表上下文中，它返回通货膨胀流 &lt;code&gt;$i&lt;/code&gt; 和</target>
        </trans-unit>
        <trans-unit id="1cf4f84fa82dd8ae218d529ba322249a8b367063" translate="yes" xml:space="preserve">
          <source>In a list context, &lt;code&gt;extract_quotelike&lt;/code&gt; would return the list</source>
          <target state="translated">在列表上下文中， &lt;code&gt;extract_quotelike&lt;/code&gt; 将返回列表</target>
        </trans-unit>
        <trans-unit id="7602890513e241f884402d4ec0723dbc5ab2f461" translate="yes" xml:space="preserve">
          <source>In a list context, all the functions return &lt;code&gt;(&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;,$original_text)&lt;/code&gt; on failure. In a scalar context, failure is indicated by returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (in this case the input text is not modified in any way).</source>
          <target state="translated">在列表上下文中，所有函数在失败时都将返回 &lt;code&gt;(&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;,$original_text)&lt;/code&gt; 。在标量上下文中，失败通过返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 来指示（在这种情况下，输入文本不会进行任何修改）。</target>
        </trans-unit>
        <trans-unit id="9a94ef45d6203b10b750123aea4390fcb5b00e20" translate="yes" xml:space="preserve">
          <source>In a list context, all the subroutines return a list, the first three elements of which are always:</source>
          <target state="translated">在列表上下文中,所有的子程序都返回一个列表,其中前三个元素总是。</target>
        </trans-unit>
        <trans-unit id="f3d0f0be64532af27f8e2b721243720c0db92d9a" translate="yes" xml:space="preserve">
          <source>In a list context, an array of 11 elements is returned. The elements are:</source>
          <target state="translated">在列表上下文中,返回一个包含11个元素的数组。这些元素是:</target>
        </trans-unit>
        <trans-unit id="8d3d6cbfb7caf07ade67b0cd6e1a9dc2096892c7" translate="yes" xml:space="preserve">
          <source>In a pinch, if you cannot wait for Configure to be educated, or if you have a good hunch of where quux() might be available, you can temporarily try the following:</source>
          <target state="translated">在紧要关头,如果你等不到Configure的教育,或者你预感到quux()可能在哪里可用,你可以临时尝试以下方法。</target>
        </trans-unit>
        <trans-unit id="8692c1987c2bd18d4696b2de38e79ce9a490834f" translate="yes" xml:space="preserve">
          <source>In a real situation, care should be taken that all threads are finished executing before the program exits. That care has &lt;b&gt;not&lt;/b&gt; been taken in these examples in the interest of simplicity. Running these examples</source>
          <target state="translated">在实际情况下，应注意在程序退出之前所有线程均已完成执行。这种保健已&lt;b&gt;不&lt;/b&gt;采取在简单的利益这些例子。运行这些示例</target>
        </trans-unit>
        <trans-unit id="81c10dc0ae0ebb18c61b259ddfe6843d666964b7" translate="yes" xml:space="preserve">
          <source>In a reciprocal fashion, an operation provides either a scalar or a list context to each of its arguments. For example, if you say</source>
          <target state="translated">以一种互惠的方式,一个操作为它的每个参数提供一个标量或一个列表上下文。例如,如果你说</target>
        </trans-unit>
        <trans-unit id="c78cf6df929776e529a74a77e45234f404202f1c" translate="yes" xml:space="preserve">
          <source>In a regular expression, the backslash can perform one of two tasks: it either takes away the special meaning of the character following it (for instance, &lt;code&gt;\|&lt;/code&gt; matches a vertical bar, it's not an alternation), or it is the start of a backslash or escape sequence.</source>
          <target state="translated">在正则表达式中，反斜杠可以执行以下两项任务之一：它消除了紧跟其后的字符的特殊含义（例如 &lt;code&gt;\|&lt;/code&gt; 匹配竖线，而不是交替字符），或者它是a的开始反斜杠或转义序列。</target>
        </trans-unit>
        <trans-unit id="81b5d9cd571e9943815277ab89c7fe545d260e8a" translate="yes" xml:space="preserve">
          <source>In a scalar context &lt;code&gt;deflate&lt;/code&gt; will return &lt;code&gt;$out&lt;/code&gt; only.</source>
          <target state="translated">在标量环境中， &lt;code&gt;deflate&lt;/code&gt; 仅返回 &lt;code&gt;$out&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d751225aea131e8c18607565afa032c5caedabd6" translate="yes" xml:space="preserve">
          <source>In a scalar context &lt;code&gt;flush&lt;/code&gt; will return &lt;code&gt;$out&lt;/code&gt; only.</source>
          <target state="translated">在标量上下文中， &lt;code&gt;flush&lt;/code&gt; 将仅返回 &lt;code&gt;$out&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24a49c87bdb8b460c4017296f34ddb336c87c832" translate="yes" xml:space="preserve">
          <source>In a scalar context it returns the group name.</source>
          <target state="translated">在标量上下文中,它返回组名。</target>
        </trans-unit>
        <trans-unit id="32d6c6f3bf39438d4047ce657137dce5d3577d7c" translate="yes" xml:space="preserve">
          <source>In a scalar context opcodes returns the number of opcodes in this version of perl (around 350 for perl-5.7.0).</source>
          <target state="translated">在一个标量上下文中,opcodes 返回这个版本 perl 中的 opcodes 数量(对于 perl-5.7.0,大约 350 个)。</target>
        </trans-unit>
        <trans-unit id="208f6e20787f24b907ff451f1741888a45d23759" translate="yes" xml:space="preserve">
          <source>In a scalar context the method returns the number of values associated with the key, &lt;code&gt;$key&lt;/code&gt; .</source>
          <target state="translated">在标量上下文中，该方法返回与键 &lt;code&gt;$key&lt;/code&gt; 关联的值的数量。</target>
        </trans-unit>
        <trans-unit id="cec0bad3cd5e75ede69094662ac02e11b4300440" translate="yes" xml:space="preserve">
          <source>In a scalar context the new socket is returned, or undef upon failure. In a list context a two-element array is returned containing the new socket and the peer address; the list will be empty upon failure.</source>
          <target state="translated">在标量上下文中,返回新的套接字,或者在失败时返回undef。在列表上下文中,返回一个包含新套接字和对等体地址的双元素数组;失败时列表为空。</target>
        </trans-unit>
        <trans-unit id="92d1e3370613f74b8985a6b3b39b4a2c46223d16" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_quotelike&lt;/code&gt; returns just the complete substring that matched a quotelike operation (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on failure). In a scalar or void context, the input text has the same substring (and any specified prefix) removed.</source>
          <target state="translated">在标量上下文中， &lt;code&gt;extract_quotelike&lt;/code&gt; 仅返回与quotelike操作（或失败时 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ）匹配的完整子字符串。在标量或空上下文中，输入文本将删除相同的子字符串（和任何指定的前缀）。</target>
        </trans-unit>
        <trans-unit id="b5b8dc86dc00a1f2952c9a2e48c451d832e4c066" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_tagged&lt;/code&gt; returns just the complete substring that matched a tagged text (including the start and end tags). &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned on failure. In addition, the original input text has the returned substring (and any prefix) removed from it.</source>
          <target state="translated">在标量上下文中， &lt;code&gt;extract_tagged&lt;/code&gt; 仅返回与已标记文本（包括开始和结束标记）匹配的完整子字符串。如果失败，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。此外，原始输入文本中还删除了返回的子字符串（和任何前缀）。</target>
        </trans-unit>
        <trans-unit id="f9900a2af209760381e75d8f7a14615b5a9bdbec" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_variable&lt;/code&gt; returns just the complete substring that matched a variablish expression. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned on failure. In addition, the original input text has the returned substring (and any prefix) removed from it.</source>
          <target state="translated">在标量上下文中， &lt;code&gt;extract_variable&lt;/code&gt; 仅返回与可变表达式匹配的完整子字符串。如果失败，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。此外，原始输入文本中还删除了返回的子字符串（和任何前缀）。</target>
        </trans-unit>
        <trans-unit id="945278245cb407350f6bc45cb3b502fc5ad85d58" translate="yes" xml:space="preserve">
          <source>In a scalar context, just the extracted substring is returned. In a void context, the extracted substring (and any prefix) are simply removed from the beginning of the first argument.</source>
          <target state="translated">在标量上下文中,只返回提取的子串。在虚空上下文中,提取的子串(和任何前缀)只是从第一个参数的开头删除。</target>
        </trans-unit>
        <trans-unit id="7e3e24a2a724494140e588e3803a95e574330808" translate="yes" xml:space="preserve">
          <source>In a scalar context, the extracted string is returned, having first been removed from the input text. Thus, the following code also processes each quote-like operation, but actually removes them from $text:</source>
          <target state="translated">在一个标量上下文中,提取的字符串会被返回,因为它已经首先从输入文本中被删除。因此,下面的代码也会处理每个类似引号的操作,但实际上是将它们从$text中删除。</target>
        </trans-unit>
        <trans-unit id="0d5544cfc850136e8726fbbd9c72234c9b7ae747" translate="yes" xml:space="preserve">
          <source>In a sense, perl (the C program) is a good example of embedding Perl (the language), so I'll demonstrate embedding with</source>
          <target state="translated">从某种意义上说,perl(C程序)是嵌入Perl(语言)的一个很好的例子,所以我将以</target>
        </trans-unit>
        <trans-unit id="ff595beb69ecf8f38b6337a9d03b24a9b262246c" translate="yes" xml:space="preserve">
          <source>In a similar fashion, overriding the &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; function also overrides the equivalent I/O operator &lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt; . Also, overriding &lt;code&gt;&lt;a href=&quot;functions/readpipe&quot;&gt;readpipe&lt;/a&gt;&lt;/code&gt; also overrides the operators &lt;code&gt;``&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以类似的方式，覆盖 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 函数也将覆盖等效的I / O运算符 &lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt; 。同样，覆盖 &lt;code&gt;&lt;a href=&quot;functions/readpipe&quot;&gt;readpipe&lt;/a&gt;&lt;/code&gt; 也将覆盖运算符 &lt;code&gt;``&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d250c896d3f5eb11d7a648b3bc78f5925e2fcce" translate="yes" xml:space="preserve">
          <source>In a void context the behaviour of the extraction subroutines is exactly the same as in a scalar context, except (of course) that the extracted substring is not returned.</source>
          <target state="translated">在void上下文中,提取子程序的行为与标量上下文中的行为完全相同,只是(当然)提取的子串不会返回。</target>
        </trans-unit>
        <trans-unit id="164ac7c993944f12e7319a81a34bfbc9042d71d4" translate="yes" xml:space="preserve">
          <source>In a void context, the input text just has the matched substring (and any specified prefix) removed.</source>
          <target state="translated">在void上下文中,输入的文本只是被删除了匹配的子串(以及任何指定的前缀)。</target>
        </trans-unit>
        <trans-unit id="a9b13f420194df675e5068f5af3ab2ba48ac53e8" translate="yes" xml:space="preserve">
          <source>In a word - don't, at least not without a *very* good reason. Your scripts can just as easily begin with &quot;#!/usr/local/bin/perl&quot; as with &quot;#!/usr/bin/perl&quot;. Scripts supplied by Apple and other third parties as part of installation packages and such have generally only been tested with the /usr/bin/perl that's installed by Apple.</source>
          <target state="translated">一句话--不要,至少不要没有一个*好的理由。你的脚本可以很容易地以 &quot;#!/usr/local/bin/perl &quot;和 &quot;#!/usr/bin/perl &quot;开头。苹果公司和其他第三方提供的脚本作为安装包的一部分等等,一般只用苹果公司安装的/usr/bin/perl进行测试。</target>
        </trans-unit>
        <trans-unit id="fcf1ea0b348743b5d23b285ecea8c108896961cc" translate="yes" xml:space="preserve">
          <source>In academia, a curriculum vit&amp;aelig;, a fancy kind of r&amp;eacute;sum&amp;eacute;. In Perl, an internal &amp;ldquo;code value&amp;rdquo; typedef holding a &lt;b&gt;subroutine&lt;/b&gt;. The &lt;code&gt;CV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">在学术界，课程是一种花哨的简历。在Perl中，内部的&amp;ldquo;代码值&amp;rdquo; typedef包含一个&lt;b&gt;子例程&lt;/b&gt;。该 &lt;code&gt;CV&lt;/code&gt; 类型的子类&lt;b&gt;SV&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="b2f52867b2f837c43cc5640194de947dbf1e2090" translate="yes" xml:space="preserve">
          <source>In actuality, the period and &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations are themselves types of character classes, so the ones surrounded by brackets are just one type of character class. When we need to make a distinction, we refer to them as &quot;bracketed character classes.&quot;</source>
          <target state="translated">实际上，句号和 &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; 缩写本身就是字符类的类型，因此用方括号括起来的字符只是字符类的一种类型。当需要区分时，我们将它们称为&amp;ldquo;括号字符类&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="46e3a38016d86ba7214b26757c2cfc95f05dd8d8" translate="yes" xml:space="preserve">
          <source>In addition</source>
          <target state="translated">另外</target>
        </trans-unit>
        <trans-unit id="7e82af699df6da7e07e9ea8a98307994127655f1" translate="yes" xml:space="preserve">
          <source>In addition EXTEND will be called when perl would have pre-extended allocation in a real array.</source>
          <target state="translated">此外,当perl在实数组中进行预扩展分配时,EXTEND将被调用。</target>
        </trans-unit>
        <trans-unit id="ed2d1a9f24dc62aaee4efacb9df22dbcc5333d73" translate="yes" xml:space="preserve">
          <source>In addition it contains two fields that are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and &lt;code&gt;pprivate&lt;/code&gt; members. &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure, whose use and management is the responsibility of the compiling engine. Perl will never modify either of these values.</source>
          <target state="translated">此外，它包含两个字段，专用于编译模式的regex引擎。这些是 &lt;code&gt;intflags&lt;/code&gt; 和 &lt;code&gt;pprivate&lt;/code&gt; 成员。 &lt;code&gt;pprivate&lt;/code&gt; 是指向任意结构的无效指针，其使用和管理是编译引擎的责任。Perl绝不会修改这些值中的任何一个。</target>
        </trans-unit>
        <trans-unit id="7aa9ca3525844fd7a1f1f038ab777e0241661c46" translate="yes" xml:space="preserve">
          <source>In addition it contains two fields that are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and pprivate members. The &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values.</source>
          <target state="translated">此外，它包含两个字段，专用于编译模式的regex引擎。这些是 &lt;code&gt;intflags&lt;/code&gt; 和私有成员。该 &lt;code&gt;pprivate&lt;/code&gt; 是一个空指针到任意的结构，其使用和管理是编译引擎的责任。perl永远不会修改这些值中的任何一个。</target>
        </trans-unit>
        <trans-unit id="152b5f495da9efbec00e14f0ef1bc85e80c4a061" translate="yes" xml:space="preserve">
          <source>In addition to &lt;b&gt;scripts&lt;/b&gt;, Unicode also defines &lt;b&gt;blocks&lt;/b&gt; of characters. The difference between scripts and blocks is that the concept of scripts is closer to natural languages, while the concept of blocks is more of an artificial grouping based on groups of Unicode characters with consecutive ordinal values. For example, the &lt;code&gt;&quot;Basic Latin&quot;&lt;/code&gt; block is all the characters whose ordinals are between 0 and 127, inclusive; in other words, the ASCII characters. The &lt;code&gt;&quot;Latin&quot;&lt;/code&gt; script contains some letters from this as well as several other blocks, like &lt;code&gt;&quot;Latin-1 Supplement&quot;&lt;/code&gt; , &lt;code&gt;&quot;Latin Extended-A&quot;&lt;/code&gt; ,</source>
          <target state="translated">除&lt;b&gt;脚本外&lt;/b&gt;，Unicode还定义了字符&lt;b&gt;块&lt;/b&gt;。脚本和块之间的区别在于，脚本的概念更接近自然语言，而块的概念更多是基于具有连续序数值的Unicode字符组的人工分组。例如， &lt;code&gt;&quot;Basic Latin&quot;&lt;/code&gt; 块是所有序数在0到127之间（包括0和127）的字符。换句话说，ASCII字符。在 &lt;code&gt;&quot;Latin&quot;&lt;/code&gt; 脚本包含一些字母从这个以及其他若干块，像 &lt;code&gt;&quot;Latin-1 Supplement&quot;&lt;/code&gt; ， &lt;code&gt;&quot;Latin Extended-A&quot;&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="f86a4eaf10c727caafeb64d3a643f53ff65e9454" translate="yes" xml:space="preserve">
          <source>In addition to adding seconds, there are two APIs for adding months and years:</source>
          <target state="translated">除了添加秒,还有两个API可以添加月和年。</target>
        </trans-unit>
        <trans-unit id="b2fd5a60f4cdde51801210d2d64a0096f9f11eee" translate="yes" xml:space="preserve">
          <source>In addition to an editor/IDE you might be interested in a more powerful shell environment for Win32. Your options include</source>
          <target state="translated">除了编辑器/IDE,你可能会对一个更强大的Win32的shell环境感兴趣。你的选择包括</target>
        </trans-unit>
        <trans-unit id="1749590c161975b92597e609a16d593c1ab667da" translate="yes" xml:space="preserve">
          <source>In addition to being Unix, we're U/WIN.</source>
          <target state="translated">除了是Unix,我们还是U/WIN。</target>
        </trans-unit>
        <trans-unit id="59ad52f794c0c2f95e95db00a5db4b0758359fc7" translate="yes" xml:space="preserve">
          <source>In addition to computing what you expected, the last example also does &lt;b&gt;not&lt;/b&gt; &quot;taint&quot; the result with an accuracy or precision setting, which would influence any further operation.</source>
          <target state="translated">除了计算你所期望的，过去的例子也确实&lt;b&gt;没有&lt;/b&gt; &amp;ldquo;污点&amp;rdquo;，其准确度或精度设置，这将影响任何进一步的操作结果。</target>
        </trans-unit>
        <trans-unit id="ae2d9c47551f30ac79ac4fb8a4a7835684b54313" translate="yes" xml:space="preserve">
          <source>In addition to fields allowed in pack(), you may prefix a field with a %&amp;lt;number&amp;gt; to indicate that you want a &amp;lt;number&amp;gt;-bit checksum of the items instead of the items themselves. Default is a 16-bit checksum. Checksum is calculated by summing numeric values of expanded values (for string fields the sum of &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; is taken; for bit fields the sum of zeroes and ones).</source>
          <target state="translated">除了pack（）中允许的字段外，您还可以在字段前加上％&amp;lt;number&amp;gt;前缀，以指示您想要的是项目的&amp;lt;number&amp;gt;位校验和，而不是项目本身。默认值为16位校验和。通过对扩展值的数值求和来计算校验和（对于字符串字段，采用 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; 的总和；对于位字段，采用零和一的总和）。</target>
        </trans-unit>
        <trans-unit id="8fab1ee4cfb63b6e2e7d76c7cfd5888f6ab2e679" translate="yes" xml:space="preserve">
          <source>In addition to fields allowed in pack(), you may prefix a field with a %&amp;lt;number&amp;gt; to indicate that you want a &amp;lt;number&amp;gt;-bit checksum of the items instead of the items themselves. Default is a 16-bit checksum. Checksum is calculated by summing numeric values of expanded values (for string fields the sum of &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; is taken; for bit fields the sum of zeroes and ones).</source>
          <target state="translated">除了pack（）中允许的字段外，您还可以在字段前加上％&amp;lt;number&amp;gt;前缀，以指示您想要的是项目的&amp;lt;number&amp;gt;位校验和，而不是项目本身。默认值为16位校验和。通过对扩展值的数值求和来计算校验和（对于字符串字段，采用 &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; 的总和；对于位字段，采用零和一的总和）。</target>
        </trans-unit>
        <trans-unit id="40ec63aed202427c78ae99bf79365c2b0344aea9" translate="yes" xml:space="preserve">
          <source>In addition to interacting with the &lt;code&gt;(*SKIP)&lt;/code&gt; pattern, &lt;code&gt;(*MARK:NAME)&lt;/code&gt; can be used to &quot;label&quot; a pattern branch, so that after matching, the program can determine which branches of the pattern were involved in the match.</source>
          <target state="translated">除了与 &lt;code&gt;(*SKIP)&lt;/code&gt; 模式进行交互之外， &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 还可用于&amp;ldquo;标记&amp;rdquo;模式分支，以便在匹配后，程序可以确定模式中的哪些分支参与了匹配。</target>
        </trans-unit>
        <trans-unit id="cea68ca5519ffc8129501826ad0bb9062eef1e64" translate="yes" xml:space="preserve">
          <source>In addition to possible bugs and an inability to follow changes to the translation policy with off/on switches of TERMIO translation, this introduces a serious incompatible change: before sysread() on text-mode filehandles would go through the translation layer, now it would not.</source>
          <target state="translated">除了可能的bug和无法跟随TERMIO翻译的关闭/开启开关对翻译策略的改变之外,这还引入了一个严重的不兼容的改变:以前文本模式文件柄上的sysread()会经过翻译层,现在不会。</target>
        </trans-unit>
        <trans-unit id="d4d69cf9bd1e25a37f285dc63efc29fb797f0fe0" translate="yes" xml:space="preserve">
          <source>In addition to standard-like API defined so far above there is an &quot;implementation&quot; interface which allows perl to get at internals of PerlIO. The following calls correspond to the various FILE_xxx macros determined by Configure - or their equivalent in other implementations. This section is really of interest to only those concerned with detailed perl-core behaviour, implementing a PerlIO mapping or writing code which can make use of the &quot;read ahead&quot; that has been done by the IO system in the same way perl does. Note that any code that uses these interfaces must be prepared to do things the traditional way if a handle does not support them.</source>
          <target state="translated">除了上面定义的类似标准的API之外,还有一个 &quot;实现 &quot;接口,它允许perl获取PerlIO的内部结构。下面的调用对应于由Configure确定的各种FILE_xxx宏--或者它们在其它实现中的等价物。这一节真正感兴趣的只是那些关心详细的perl核心行为的人,实现PerlIO映射或编写代码,这些代码可以像perl一样利用IO系统已经完成的 &quot;提前读&quot;。请注意,任何使用这些接口的代码都必须准备好,如果一个句柄不支持这些接口,就必须用传统的方式做事。</target>
        </trans-unit>
        <trans-unit id="17eaea3931a67cb37ce8cb0cb3c4e8d09398b8c0" translate="yes" xml:space="preserve">
          <source>In addition to the MEDIUM security checks, also check for the possibility of ``chown() giveaway'' using the L</source>
          <target state="translated">除了中度安全检查外,还要检查是否有可能使用L.Chown()giveaway&quot;。</target>
        </trans-unit>
        <trans-unit id="89182cb06f6668d208e0619e4cbe15cde7591879" translate="yes" xml:space="preserve">
          <source>In addition to the OVERLOAD keyword, if you need to control how Perl autogenerates missing overloaded operators, you can set the FALLBACK keyword in the module header section, like this:</source>
          <target state="translated">除了OVERLOAD关键字,如果你需要控制Perl如何自动生成缺失的过载操作符,你可以在模块头部分设置FALLBACK关键字,像这样。</target>
        </trans-unit>
        <trans-unit id="cf43e38422f03f19f7c8bc12dfe3cf7238322b4f" translate="yes" xml:space="preserve">
          <source>In addition to the STANDARD security, the output directory is checked to make sure that it is owned either by root or the user running the program. If the directory is writable by group or by other, it is then checked to make sure that the sticky bit is set.</source>
          <target state="translated">除了 STANDARD 安全性之外,还要检查输出目录是否为 root 或运行程序的用户所有。如果该目录可由组或其他用户写入,则要检查是否设置了粘性位。</target>
        </trans-unit>
        <trans-unit id="a6827bb11452b38549da194a0e9f946e676fb6ab" translate="yes" xml:space="preserve">
          <source>In addition to the compiler flags used to select the SDK, also add the flags for creating a universal binary:</source>
          <target state="translated">除了用于选择SDK的编译器标志外,还要添加创建通用二进制的标志。</target>
        </trans-unit>
        <trans-unit id="73c76010fe3f7536529c60cd357cfa7c8e4a0b21" translate="yes" xml:space="preserve">
          <source>In addition to the different levels of OS involvement in threads, different OSes (and different thread implementations for a particular OS) allocate CPU cycles to threads in different ways.</source>
          <target state="translated">除了操作系统对线程的参与程度不同外,不同的操作系统(以及特定操作系统的不同线程实现)对线程的CPU周期分配方式也不同。</target>
        </trans-unit>
        <trans-unit id="79a96fb0aa6c1ca892c14d42638abd6240d03e9c" translate="yes" xml:space="preserve">
          <source>In addition to the file and subroutine-related variables mentioned above, the debugger also maintains various magical internal variables.</source>
          <target state="translated">除了上面提到的文件和子程序相关的变量外,调试器还维护着各种神奇的内部变量。</target>
        </trans-unit>
        <trans-unit id="bab0de29db31c89ae8ab9839888cf6f1bf406c03" translate="yes" xml:space="preserve">
          <source>In addition to the key-value pairs accepted by &lt;a href=&quot;../socket&quot;&gt;IO::Socket&lt;/a&gt;, &lt;code&gt;IO::Socket::INET&lt;/code&gt; provides.</source>
          <target state="translated">除了&lt;a href=&quot;../socket&quot;&gt;IO :: Socket&lt;/a&gt;接受的键值对之外， &lt;code&gt;IO::Socket::INET&lt;/code&gt; 还提供。</target>
        </trans-unit>
        <trans-unit id="7a72b31c557cda8bc1b722b2e6a26c2c901af09d" translate="yes" xml:space="preserve">
          <source>In addition to the key-value pairs accepted by &lt;a href=&quot;../socket&quot;&gt;IO::Socket&lt;/a&gt;, &lt;code&gt;IO::Socket::UNIX&lt;/code&gt; provides.</source>
          <target state="translated">除了&lt;a href=&quot;../socket&quot;&gt;IO :: Socket&lt;/a&gt;接受的键值对之外， &lt;code&gt;IO::Socket::UNIX&lt;/code&gt; 还提供。</target>
        </trans-unit>
        <trans-unit id="7c45e877ad35106ffbe7de68a1cdc70a047e523f" translate="yes" xml:space="preserve">
          <source>In addition to the metacharacters, there are some ASCII characters which don't have printable character equivalents and are instead represented by</source>
          <target state="translated">除了元字符外,还有一些ASCII字符没有可打印的等价字符,而用以下方式表示</target>
        </trans-unit>
        <trans-unit id="08676326b07558d72976a15d2e5ea67b5354d4ab" translate="yes" xml:space="preserve">
          <source>In addition to the perl API described above, a C API is available for extension writers. The following C functions are available in the modglobal hash:</source>
          <target state="translated">除了上述的perl API之外,还有一个C API供扩展作者使用。以下是modglobal哈希中的C函数。</target>
        </trans-unit>
        <trans-unit id="ef88c015cd90a62555639afdea15aa945900339f" translate="yes" xml:space="preserve">
          <source>In addition to the quote delimiters &lt;code&gt;'&lt;/code&gt;, &lt;code&gt;&quot;&lt;/code&gt;, and &lt;code&gt;`&lt;/code&gt;, full Perl quote-like quoting (i.e. q{string}, qq{string}, etc) can be specified by including the letter 'q' as a delimiter. Hence:</source>
          <target state="translated">除了引号分隔符 &lt;code&gt;'&lt;/code&gt; ， &lt;code&gt;&quot;&lt;/code&gt; 和 &lt;code&gt;`&lt;/code&gt; 之外，还可以通过包含字母'q'作为分隔符来指定完整的Perl引用形式的引号（即q {string}，qq {string}等）。</target>
        </trans-unit>
        <trans-unit id="3ee26c7c2937194436d9d08c9a82ea42e06abcd1" translate="yes" xml:space="preserve">
          <source>In addition to the six exported functions there exists one function that can only be accessed with a fully qualified function call.</source>
          <target state="translated">除了六个导出的函数外,还有一个函数只能通过完全限定的函数调用来访问。</target>
        </trans-unit>
        <trans-unit id="1fd0fd0dfb0a01af1b34dd0a74cf43897f0a81ea" translate="yes" xml:space="preserve">
          <source>In addition to the tie() interface, it is also possible to access most of the functions provided in the Berkeley DB API directly. See &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;THE API INTERFACE&lt;/a&gt;.</source>
          <target state="translated">除了tie（）接口之外，还可以直接访问Berkeley DB API中提供的大多数功能。请参阅&lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;API接口&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53b1ffa79f559c5952d0b2eca922c0eb1fe018a7" translate="yes" xml:space="preserve">
          <source>In addition to the traditional Perl default MRO (depth first search, called &lt;code&gt;DFS&lt;/code&gt; here), Perl now offers the C3 MRO as well. Perl's support for C3 is based on the work done in Stevan Little's module &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class::C3&lt;/a&gt;, and most of the C3-related documentation here is ripped directly from there.</source>
          <target state="translated">除了传统的Perl默认MRO（深度优先搜索，在这里称为 &lt;code&gt;DFS&lt;/code&gt; ）之外，Perl现在还提供C3 MRO。Perl对C3的支持基于Stevan Little的模块&lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class :: C3中&lt;/a&gt;完成的工作，并且这里直接有许多与C3相关的文档的直接摘录。</target>
        </trans-unit>
        <trans-unit id="8eca212407dc344e58d9927ac55df67e502679ba" translate="yes" xml:space="preserve">
          <source>In addition to the two arrays that form the inversion map, &lt;code&gt;prop_invmap&lt;/code&gt; returns two other values; one is a scalar that gives some details as to the format of the entries of the map array; the other is a default value, useful in maps whose format name begins with the letter &lt;code&gt;&quot;a&quot;&lt;/code&gt; , as described &lt;a href=&quot;#a&quot;&gt;below in its subsection&lt;/a&gt;; and for specialized purposes, such as converting to another data structure, described at the end of this main section.</source>
          <target state="translated">除了构成反转映射的两个数组之外， &lt;code&gt;prop_invmap&lt;/code&gt; 还返回其他两个值。一个是标量，它给出了有关映射数组的条目格式的一些细节；另一种是一个缺省值，在地图其格式名字开头字母有用 &lt;code&gt;&quot;a&quot;&lt;/code&gt; ，如所描述&lt;a href=&quot;#a&quot;&gt;如下在其第&lt;/a&gt; ; 并且出于特殊目的（例如转换为其他数据结构），在本主要部分的末尾进行了介绍。</target>
        </trans-unit>
        <trans-unit id="dab2897e25695e7867181ff90ba23794c8c60c0d" translate="yes" xml:space="preserve">
          <source>In addition to using the &lt;code&gt;\p{Blk=...}&lt;/code&gt; and &lt;code&gt;\P{Blk=...}&lt;/code&gt; constructs, you can also test whether a code point is in the</source>
          <target state="translated">除了使用 &lt;code&gt;\p{Blk=...}&lt;/code&gt; 和 &lt;code&gt;\P{Blk=...}&lt;/code&gt; 构造之外，您还可以测试代码点是否位于</target>
        </trans-unit>
        <trans-unit id="dac7bc321eb3333dc44a14f1d9acf1fbd74fd29b" translate="yes" xml:space="preserve">
          <source>In addition to what was matched, Perl also provides the positions of what was matched as contents of the &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; arrays. &lt;code&gt;$-[0]&lt;/code&gt; is the position of the start of the entire match and &lt;code&gt;$+[0]&lt;/code&gt; is the position of the end. Similarly, &lt;code&gt;$-[n]&lt;/code&gt; is the position of the start of the &lt;code&gt;$n&lt;/code&gt; match and &lt;code&gt;$+[n]&lt;/code&gt; is the position of the end. If &lt;code&gt;$n&lt;/code&gt; is undefined, so are &lt;code&gt;$-[n]&lt;/code&gt; and &lt;code&gt;$+[n]&lt;/code&gt; . Then this code</source>
          <target state="translated">除了匹配的内容外，Perl还提供匹配的位置作为 &lt;code&gt;@-&lt;/code&gt; 和 &lt;code&gt;@+&lt;/code&gt; 数组的内容。 &lt;code&gt;$-[0]&lt;/code&gt; 是整个比赛开始的位置， &lt;code&gt;$+[0]&lt;/code&gt; 是比赛结束的位置。类似地， &lt;code&gt;$-[n]&lt;/code&gt; 是 &lt;code&gt;$n&lt;/code&gt; 比赛开始的位置， &lt;code&gt;$+[n]&lt;/code&gt; 是结束位置。如果未定义 &lt;code&gt;$n&lt;/code&gt; ，则 &lt;code&gt;$-[n]&lt;/code&gt; 和 &lt;code&gt;$+[n]&lt;/code&gt; 也是如此。然后这段代码</target>
        </trans-unit>
        <trans-unit id="340df59f8245bd9d352756a2f3fe84ca2ba2b14a" translate="yes" xml:space="preserve">
          <source>In addition, Perl defines the following:</source>
          <target state="translated">此外,Perl还定义了以下内容:</target>
        </trans-unit>
        <trans-unit id="7b18dfd70f7fb70cb969c8b7231702490b8ef572" translate="yes" xml:space="preserve">
          <source>In addition, Perl permits the following widely-supported conversions:</source>
          <target state="translated">此外,Perl还允许进行以下广泛支持的转换。</target>
        </trans-unit>
        <trans-unit id="58a30b45039ea55ccfbff7c03b534706dd5f4a4e" translate="yes" xml:space="preserve">
          <source>In addition, a second package variable (&lt;code&gt;@Filter::Simple::components&lt;/code&gt; ) contains a list of the various pieces of &lt;code&gt;$_&lt;/code&gt; , as they were originally split up to allow placeholders to be inserted.</source>
          <target state="translated">另外，第二个包变量（ &lt;code&gt;@Filter::Simple::components&lt;/code&gt; ）包含 &lt;code&gt;$_&lt;/code&gt; 的各个部分的列表，因为它们最初是拆分为允许插入占位符的。</target>
        </trans-unit>
        <trans-unit id="8b824cddab0454f6fa746f5f5efb2df055e6a062" translate="yes" xml:space="preserve">
          <source>In addition, an attempt is made to recognize several common Unix library names, and filter them out or convert them to their VMS equivalents, as appropriate.</source>
          <target state="translated">此外,我们还试图识别几个常见的Unix库名,并将它们筛选出来,或酌情将它们转换为VMS的对应名称。</target>
        </trans-unit>
        <trans-unit id="20f0764c130ac7b7bb4ff76a14f2a6cf3a71b811" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a simple filename, the default values for the &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options will be sourced from that file.</source>
          <target state="translated">另外，如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是一个简单的文件名，则 &lt;code&gt;Name&lt;/code&gt; ， &lt;code&gt;Time&lt;/code&gt; ， &lt;code&gt;TextFlag&lt;/code&gt; ， &lt;code&gt;ExtAttr&lt;/code&gt; ， &lt;code&gt;exUnixN&lt;/code&gt; 和 &lt;code&gt;exTime&lt;/code&gt; 选项的默认值将从该文件中获取。</target>
        </trans-unit>
        <trans-unit id="bdc3e8410e98f27c3f135fcd34c0e133beddff18" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a simple filename, the default values for the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Time&lt;/code&gt; options will be sourced from that file.</source>
          <target state="translated">另外，如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是一个简单的文件名，则 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Time&lt;/code&gt; 选项的默认值将从该文件中获取。</target>
        </trans-unit>
        <trans-unit id="91ed0a2f179c5ac2d45e1e913820f71e61b32911" translate="yes" xml:space="preserve">
          <source>In addition, if the input file/buffer does contain compressed data and there is non-compressed data immediately following it, setting this option will make this module treat the whole file/buffer as a single data stream.</source>
          <target state="translated">此外,如果输入的文件/缓冲区确实包含压缩数据,而且紧接着还有非压缩数据,设置这个选项将使这个模块把整个文件/缓冲区当作一个单一的数据流。</target>
        </trans-unit>
        <trans-unit id="a03250cf8d36596835773013a7ed159131abe9f9" translate="yes" xml:space="preserve">
          <source>In addition, on failure in</source>
          <target state="translated">此外,在失败时</target>
        </trans-unit>
        <trans-unit id="289227a7d3ba6bcbce57645ed49463f1d7e46764" translate="yes" xml:space="preserve">
          <source>In addition, other &lt;a href=&quot;getopt/long&quot;&gt;Getopt::Long&lt;/a&gt; error messages may result from invalid command-line options.</source>
          <target state="translated">此外，其他&lt;a href=&quot;getopt/long&quot;&gt;Getopt :: Long&lt;/a&gt;错误消息可能是由无效的命令行选项引起的。</target>
        </trans-unit>
        <trans-unit id="147a39b11e58c10277c6a279d8224a769b9bb498" translate="yes" xml:space="preserve">
          <source>In addition, output may be piped to a subprocess, using the character '|'. Anything after this character on the command line is passed to a subprocess for execution; the subprocess takes the output of Perl as its input.</source>
          <target state="translated">此外,还可以使用字符'|'将输出传送到子进程。命令行中这个字符之后的任何内容都会被传递给子进程执行;子进程将 Perl 的输出作为其输入。</target>
        </trans-unit>
        <trans-unit id="99121fa175239d30527a66db54352aec9e7f4845" translate="yes" xml:space="preserve">
          <source>In addition, plenty of code in the wild does all of its OO &quot;by hand&quot;, using just the Perl built-in OO features. If you need to maintain such code, you should read &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; to understand exactly how Perl's built-in OO works.</source>
          <target state="translated">此外，仅使用Perl内置的OO功能，大量的代码&amp;ldquo;手工&amp;rdquo;完成了所有OO。如果您需要维护这样的代码，则应该阅读&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;以准确了解Perl的内置OO的工作方式。</target>
        </trans-unit>
        <trans-unit id="df2c5f9f6d74347865f1b7d8c718b9166dce24c6" translate="yes" xml:space="preserve">
          <source>In addition, subroutines are named with an initial '&amp;amp;', though this is optional when unambiguous, just as the word &quot;do&quot; is often redundant in English. Symbol table entries can be named with an initial '*', but you don't really care about that yet (if ever :-).</source>
          <target state="translated">此外，子例程以一个首字母&amp;ldquo;＆&amp;rdquo;命名，尽管在明确的情况下这是可选的，就像&amp;ldquo; do&amp;rdquo;一词在英语中通常是多余的。符号表条目可以以&amp;ldquo; *&amp;rdquo;开头，但是您实际上并不在意（如果有的话：-）。</target>
        </trans-unit>
        <trans-unit id="e4639b7e9ac66cd60ee8c3525c4580bbed98b234" translate="yes" xml:space="preserve">
          <source>In addition, the generated &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine passes its own argument list to the filtering subroutine, so the BANG.pm filter could easily be made parametric:</source>
          <target state="translated">另外，生成的 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程将其自己的参数列表传递给过滤子例程，因此可以轻松地将BANG.pm过滤器设为参数化：</target>
        </trans-unit>
        <trans-unit id="3e36eb4b4d16be01e13411f12c4f853328d8d124" translate="yes" xml:space="preserve">
          <source>In addition, the returned value will be unique within the context of the Pod::Simple::XHTML object unless a second argument is passed a true value. ID attributes should always be unique within a single XHTML document, but pass the true value if you are creating not an ID but a URL hash to point to an ID (i.e., if you need to put the &quot;#foo&quot; in &lt;code&gt;&amp;lt;a href=&quot;#foo&quot;&amp;gt;foo&amp;lt;/a&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">此外，返回值在Pod :: Simple :: XHTML对象的上下文中将是唯一的，除非为第二个参数传递了真值。ID属性在单个XHTML文档中应该始终是唯一的，但是如果您不是创建ID，而是创建指向ID的URL哈希（即，如果需要在 &lt;code&gt;&amp;lt;a href=&quot;#foo&quot;&amp;gt;foo&amp;lt;/a&amp;gt;&lt;/code&gt; 放入&amp;ldquo; #foo&amp;rdquo;，=&amp;ldquo;＃foo&amp;rdquo;&amp;gt; foo &amp;lt;/a&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="de0edea48e0434c59597ceff4d726d410f442fce" translate="yes" xml:space="preserve">
          <source>In addition, when ldopts is called with parameters, it will return the argument string rather than print it to STDOUT.</source>
          <target state="translated">此外,当ldopts带参数被调用时,它将返回参数字符串,而不是打印到STDOUT。</target>
        </trans-unit>
        <trans-unit id="0fe8a6e2911b84e5bf182d375e70d71ebf4dcde5" translate="yes" xml:space="preserve">
          <source>In all Perl versions you can use &lt;code&gt;as_number()&lt;/code&gt; or &lt;code&gt;as_int&lt;/code&gt; for the same effect:</source>
          <target state="translated">在所有Perl版本中，可以使用 &lt;code&gt;as_number()&lt;/code&gt; 或 &lt;code&gt;as_int&lt;/code&gt; 来达到相同的效果：</target>
        </trans-unit>
        <trans-unit id="9a826c545f2fecb5bd50e173dbd7f3d696f12f03" translate="yes" xml:space="preserve">
          <source>In all Perl versions, &lt;code&gt;\s&lt;/code&gt; matches the 5 characters [\t\n\f\r ]; that is, the horizontal tab, the newline, the form feed, the carriage return, and the space. Starting in Perl v5.18, it also matches the vertical tab, &lt;code&gt;\cK&lt;/code&gt; . See note &lt;code&gt;[1]&lt;/code&gt; below for a discussion of this.</source>
          <target state="translated">在所有Perl版本中， &lt;code&gt;\s&lt;/code&gt; 匹配5个字符[\ t \ n \ f \ r]；即水平制表符，换行符，换页符，回车符和空格。从Perl v5.18开始，它还与垂直选项卡 &lt;code&gt;\cK&lt;/code&gt; 匹配。有关此内容的讨论，请参见下面的注释 &lt;code&gt;[1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="781b45f1e32e901ab32d784bb9ee31c8ef4d8da4" translate="yes" xml:space="preserve">
          <source>In all but the most memory-paranoid configurations (ex: PURIFY), heads and bodies are allocated out of arenas, which by default are approximately 4K chunks of memory parcelled up into N heads or bodies. Sv-bodies are allocated by their sv-type, guaranteeing size consistency needed to allocate safely from arrays.</source>
          <target state="translated">在所有的配置中,除了最偏执的内存配置(如:PURIFY),头和体都是从arena中分配出来的,默认情况下,arena是大约4K的内存块,被分割成N个头或体。Sv-body 是通过它们的 sv-type 来分配的,保证了从数组中安全分配所需的大小一致性。</target>
        </trans-unit>
        <trans-unit id="82cf0166b1026f5214dc5e9dee6752fb9c70f2f9" translate="yes" xml:space="preserve">
          <source>In all cases shown above, the line indentation shows the call tree. If bit 2 of &lt;code&gt;frame&lt;/code&gt; is set, a line is printed on exit from a subroutine as well. If bit 4 is set, the arguments are printed along with the caller info. If bit 8 is set, the arguments are printed even if they are tied or references. If bit 16 is set, the return value is printed, too.</source>
          <target state="translated">在上面显示的所有情况下，行缩进都会显示调用树。如果设置了 &lt;code&gt;frame&lt;/code&gt; 位2，则在子例程的出口处也会打印一行。如果设置了位4，则将参数和呼叫者信息一起打印。如果设置了位8，则即使已绑定参数或引用，也将打印自变量。如果设置了位16，则也将打印返回值。</target>
        </trans-unit>
        <trans-unit id="6061ee2ae8dec0f2b671e0d3e14bae7a6b818d83" translate="yes" xml:space="preserve">
          <source>In all cases where the very common phenomenon of quantification (saying &quot;</source>
          <target state="translated">在所有的情况下,很常见的量化现象(说&quot;</target>
        </trans-unit>
        <trans-unit id="e3c2c7f74b86dde15a7c489ee7be1789b4697e9f" translate="yes" xml:space="preserve">
          <source>In all dealings with contributed modules, everyone maintaining Perl should keep in mind that the code belongs to the original author, that they may not be on perl5-porters at any given time, and that a patch is not official unless it has been integrated into the author's copy of the module. To aid with this, and with points #1, #2, and #3 above, contact information for the authors of all contributed modules should be kept with the Perl distribution.</source>
          <target state="translated">在所有与贡献模块打交道的过程中,每个维护 Perl 的人都应该记住,代码是属于原作者的,他们可能在任何时候都不在 perl5-porters 上,而且一个补丁如果没有被集成到作者的模块副本中,就不是正式的。为了帮助解决这个问题,以及上面的#1、#2和#3,所有贡献模块的作者的联系信息都应该保存在Perl发行版中。</target>
        </trans-unit>
        <trans-unit id="9f633a9cd1f1e79fef8f8eaa0a6cfd15cedc67ef" translate="yes" xml:space="preserve">
          <source>In all of the above cases, option values may be inserted in the bundle. For example:</source>
          <target state="translated">在上述所有情况下,可以在捆绑中插入选项值。例如:</target>
        </trans-unit>
        <trans-unit id="2383a8bd7489fcdd2f83ac67cbbc873796c97eb5" translate="yes" xml:space="preserve">
          <source>In all operations on %ENV, the key string is treated as if it were entirely uppercase, regardless of the case actually specified in the Perl expression.</source>
          <target state="translated">在对 %ENV 的所有操作中,无论 Perl 表达式中实际指定的是什么大小写,都会将键串当作完全大写的字符串处理。</target>
        </trans-unit>
        <trans-unit id="95b3792cd6f5e2af35835ac883e0e6a53f125114" translate="yes" xml:space="preserve">
          <source>In all the above examples, &lt;code&gt;minus()&lt;/code&gt; is required only to return the result of the subtraction: Perl takes care of the assignment to $x. In fact, such methods should</source>
          <target state="translated">在以上所有示例中，仅需要 &lt;code&gt;minus()&lt;/code&gt; 才能返回减法结果：Perl负责分配给$ x。实际上，这种方法应该</target>
        </trans-unit>
        <trans-unit id="97f2c173d7ed4e9aee1d1f9fb64f4d9f9b0ea2fe" translate="yes" xml:space="preserve">
          <source>In all the previous examples I have 'hard-wired' the name of the Perl subroutine to be called from C. Most of the time though, it is more convenient to be able to specify the name of the Perl subroutine from within the Perl script.</source>
          <target state="translated">在前面所有的例子中,我都 &quot;硬生生 &quot;地把Perl子程序的名字从C语言中调用出来。不过大多数时候,在Perl脚本中指定Perl子程序的名字会更方便。</target>
        </trans-unit>
        <trans-unit id="aaae17ed6f36eac3220705015e0ea930013f7c8e" translate="yes" xml:space="preserve">
          <source>In all these cases, the user can override this stubborn behaviour by prepending the command with the word force, for example:</source>
          <target state="translated">在所有这些情况下,用户都可以通过在命令前加上force一词来覆盖这种顽固行为,例如。</target>
        </trans-unit>
        <trans-unit id="4cbe02d68ddbd502acef7d9e9916746fae4beca6" translate="yes" xml:space="preserve">
          <source>In almost all cases like this, it's usually a far, far better idea to use the structured control flow mechanisms of &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; instead of resorting to a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. For certain applications, the catch and throw pair of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; and die() for exception processing can also be a prudent approach.</source>
          <target state="translated">在几乎所有这种情况下，使用 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 的结构化控制流机制而不是求助于 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 通常是一个更好的主意。对于某些应用程序，捕获和抛出 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 和die（）对以进行异常处理也是一种谨慎的方法。</target>
        </trans-unit>
        <trans-unit id="8cf0558a3828c482ff92b5a9786f51b397db3041" translate="yes" xml:space="preserve">
          <source>In an array context &lt;code&gt;extract_multiple&lt;/code&gt; returns an array of substrings of the original string, as extracted by the specified extractors. In a scalar context, &lt;code&gt;extract_multiple&lt;/code&gt; returns the first substring successfully extracted from the original string. In both scalar and void contexts the original string has the first successfully extracted substring removed from it. In all contexts &lt;code&gt;extract_multiple&lt;/code&gt; starts at the current &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; of the string, and sets that &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; appropriately after it matches.</source>
          <target state="translated">在数组上下文中， &lt;code&gt;extract_multiple&lt;/code&gt; 返回由指定提取器提取的原始字符串的子字符串数组。在标量上下文中， &lt;code&gt;extract_multiple&lt;/code&gt; 返回成功从原始字符串中提取的第一个子字符串。在标量和无效上下文中，原始字符串都会从其中删除第一个成功提取的子字符串。在所有上下文 &lt;code&gt;extract_multiple&lt;/code&gt; 在当前启动 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 字符串，并设置 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 它匹配后适当。</target>
        </trans-unit>
        <trans-unit id="0bf045366670deb82562441b69ea96760a43c736" translate="yes" xml:space="preserve">
          <source>In an array context the return value is a list containing, the number of articles in the group, the number of the first article, the number of the last article and the group name.</source>
          <target state="translated">在数组上下文中,返回值是一个列表,包含,组中的文章数量,第一篇文章的数量,最后一篇文章的数量和组名。</target>
        </trans-unit>
        <trans-unit id="5a5982cddd4d8975197c2744da1608d9e4548d41" translate="yes" xml:space="preserve">
          <source>In an array context, returns a list of lines returned from the server. In a scalar context, returns a reference to a list.</source>
          <target state="translated">在数组上下文中,返回一个从服务器返回的行的列表。在标量上下文中,返回一个列表的引用。</target>
        </trans-unit>
        <trans-unit id="c41a798a42099e75be11d7d0369af1bc79b214a4" translate="yes" xml:space="preserve">
          <source>In an interpolated literal, whether a double-quoted string or a regex, you may specify a character by its number using the &lt;code&gt;\x{&lt;i&gt;HHHHHH&lt;/i&gt;}&lt;/code&gt; escape.</source>
          <target state="translated">在插值文字中，无论是双引号字符串还是正则表达式，都可以使用 &lt;code&gt;\x{&lt;i&gt;HHHHHH&lt;/i&gt;}&lt;/code&gt; 转义符通过数字指定字符。</target>
        </trans-unit>
        <trans-unit id="4918ab5fdbd686e859250551837a7ee9a52207eb" translate="yes" xml:space="preserve">
          <source>In ancient times, Unix was also used to refer to some code that a couple of people at Bell Labs wrote to make use of a PDP-7 computer that wasn&amp;rsquo;t doing much of anything else at the time.</source>
          <target state="translated">在远古时代，Unix还被用来指代Bell实验室的一些人编写的使用PDP-7计算机的一些代码，该计算机当时没有做任何其他事情。</target>
        </trans-unit>
        <trans-unit id="d17b1ed4f6399a33863173b63d7cf4eeef9ce1db" translate="yes" xml:space="preserve">
          <source>In any case do not expect nanosecond resolution, or even a microsecond resolution. Also note that the modify/access timestamps might have different resolutions, and that they need not be synchronized, e.g. if the operations are</source>
          <target state="translated">在任何情况下,都不要指望有纳秒级的分辨率,甚至是微秒级的分辨率。还要注意的是,修改/访问的时间戳可能有不同的分辨率,而且它们不需要同步,例如,如果操作为</target>
        </trans-unit>
        <trans-unit id="a2ea48b73fadf70f92647ed4cbbc7d19e3016b8b" translate="yes" xml:space="preserve">
          <source>In any case you will be prompted with the correct invocation of the &lt;code&gt;inst_perl&lt;/code&gt; target that installs the new binary into INSTALLBIN.</source>
          <target state="translated">无论如何，系统都会提示您正确调用将新二进制文件安装到INSTALLBIN 中的 &lt;code&gt;inst_perl&lt;/code&gt; 目标。</target>
        </trans-unit>
        <trans-unit id="416ebb085a2d5e940040c711d2f8d1e17ddebb19" translate="yes" xml:space="preserve">
          <source>In any way, if you're seeing failures beyond those mentioned in this document, please consider upgrading to the latest Hurd before reporting the failure as a bug.</source>
          <target state="translated">无论如何,如果你看到的故障超出了本文档中提到的范围,请考虑升级到最新的Hurd,然后再将故障报告为bug。</target>
        </trans-unit>
        <trans-unit id="86069d4fc266f927b18d767a1cba7026af51c3e5" translate="yes" xml:space="preserve">
          <source>In array context returns a two-element array with the seconds and microseconds since the epoch. In scalar context returns floating seconds like &lt;code&gt;Time::HiRes::time()&lt;/code&gt; (see below).</source>
          <target state="translated">在数组上下文中，返回一个带有两个元素的数组，其中包含自纪元以来的秒和微秒。在标量上下文中，返回浮动秒，如 &lt;code&gt;Time::HiRes::time()&lt;/code&gt; （请参见下文）。</target>
        </trans-unit>
        <trans-unit id="16582d55b272e81d53e1e61c0aba11a653333faf" translate="yes" xml:space="preserve">
          <source>In between two &lt;b&gt;subscripts&lt;/b&gt;, the arrow is optional.</source>
          <target state="translated">在两个&lt;b&gt;下标&lt;/b&gt;之间，箭头是可选的。</target>
        </trans-unit>
        <trans-unit id="e15bc0bc69692882714387f5e16ad85b014d51b1" translate="yes" xml:space="preserve">
          <source>In block mode, &lt;code&gt;filter_read&lt;/code&gt; will append a block of data which is &amp;lt;= &lt;code&gt;$size&lt;/code&gt; to the end of the &lt;code&gt;$_&lt;/code&gt; scalar. It is important to emphasise the that &lt;code&gt;filter_read&lt;/code&gt; will not necessarily read a block which is</source>
          <target state="translated">在块模式下， &lt;code&gt;filter_read&lt;/code&gt; 会将一个&amp;lt;= &lt;code&gt;$size&lt;/code&gt; 的数据块附加到 &lt;code&gt;$_&lt;/code&gt; 标量的末尾。需要强调的是， &lt;code&gt;filter_read&lt;/code&gt; 不一定会读取一个</target>
        </trans-unit>
        <trans-unit id="86311b9447535cd22a0807e557574828944f0087" translate="yes" xml:space="preserve">
          <source>In bootstrapping situations it is usually sufficient to translate only a few YAML files to Data::Dumper for crucial modules like &lt;code&gt;YAML::Syck&lt;/code&gt; , &lt;code&gt;YAML.pm&lt;/code&gt; and &lt;code&gt;Expect.pm&lt;/code&gt; . If you prefer Storable over Data::Dumper, remember to pull out a Storable version that writes an older format than all the other Storable versions that will need to read them.</source>
          <target state="translated">在自举情况下，通常只需要将几个YAML文件转换为Data :: Dumper即可用于关键模块，例如 &lt;code&gt;YAML::Syck&lt;/code&gt; ， &lt;code&gt;YAML.pm&lt;/code&gt; 和 &lt;code&gt;Expect.pm&lt;/code&gt; 。如果您更喜欢使用Storable而不是Data :: Dumper，请记住拔出一个Storable版本，该版本写入的格式要比需要读取它们的所有其他Storable版本的格式要旧。</target>
        </trans-unit>
        <trans-unit id="7d32bdf3cfc0bcbd8616099443aea4c2f02bae5f" translate="yes" xml:space="preserve">
          <source>In both cases this should only be considered to be a temporary measure - you should upgrade to the later version of perl as soon as is practicable.</source>
          <target state="translated">在这两种情况下,这只能算是一种临时措施--你应该在可行的情况下尽快升级到较新版本的perl。</target>
        </trans-unit>
        <trans-unit id="d2a841147fc72cc4482e0a7e84067a22e8db15fe" translate="yes" xml:space="preserve">
          <source>In both cases, if you want access to the original, unaltered routine, use the &lt;code&gt;CORE::&lt;/code&gt; prefix:</source>
          <target state="translated">在这两种情况下，如果您想访问未经更改的原始例程，请使用 &lt;code&gt;CORE::&lt;/code&gt; 前缀：</target>
        </trans-unit>
        <trans-unit id="3b49d045d120cddc991a05308fecf5d02438bfd9" translate="yes" xml:space="preserve">
          <source>In both cases, it is strongly recommended that you use these flags when you run Configure. If you do not use do this, but later answer the questions about 64-bit numbers when Configure asks you, you may get a configuration that cannot be compiled, or that does not function as expected.</source>
          <target state="translated">在这两种情况下,强烈建议你在运行Configure时使用这些标志。如果你不这样做,但后来在Configure询问你时回答了有关64位数字的问题,你可能会得到一个不能编译的配置,或者不能按预期的方式运行。</target>
        </trans-unit>
        <trans-unit id="28f5f411ebc893dbf219e8f06f5338fdd368072e" translate="yes" xml:space="preserve">
          <source>In both forms, the value returned is the value of the last expression evaluated inside the mini-program; a return statement may be also used, just as with subroutines. The expression providing the return value is evaluated in void, scalar, or list context, depending on the context of the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself. See &lt;a href=&quot;wantarray&quot;&gt;wantarray&lt;/a&gt; for more on how the evaluation context can be determined.</source>
          <target state="translated">在这两种形式中，返回的值都是小程序内部最后一个表达式的值；就像子例程一样，也可以使用return语句。根据 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 本身的上下文，在void，标量或列表上下文中评估提供返回值的表达式。有关如何确定评估上下文的更多信息，请参见&lt;a href=&quot;wantarray&quot;&gt;wantarray&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a7857febf47f6d9d7d4d6147004e7ae7af4e0b5" translate="yes" xml:space="preserve">
          <source>In both forms, the value returned is the value of the last expression evaluated inside the mini-program; a return statement may be also used, just as with subroutines. The expression providing the return value is evaluated in void, scalar, or list context, depending on the context of the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself. See &lt;a href=&quot;#wantarray&quot;&gt;wantarray&lt;/a&gt; for more on how the evaluation context can be determined.</source>
          <target state="translated">在这两种形式中，返回的值都是小程序内部最后一个表达式的值；就像子例程一样，也可以使用return语句。根据 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 本身的上下文，在void，标量或列表上下文中评估提供返回值的表达式。有关如何确定评估上下文的更多信息，请参见&lt;a href=&quot;#wantarray&quot;&gt;wantarray&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9f62f445147592772dba8cf7d0b7f085f6d5d1f" translate="yes" xml:space="preserve">
          <source>In both last cases, the last expression is evaluated in the context that was applied to the &lt;code&gt;given&lt;/code&gt; block.</source>
          <target state="translated">在这两种情况下，最后一个表达式都是在应用于给 &lt;code&gt;given&lt;/code&gt; 块的上下文中求值的。</target>
        </trans-unit>
        <trans-unit id="faca50452b363bafe8294bb759677cc9d971a027" translate="yes" xml:space="preserve">
          <source>In both the case of unquoted command line arguments or in calls to &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; VMS wildcard expansion is performed. (csh-style wildcard expansion is available if you use &lt;code&gt;File::Glob::glob&lt;/code&gt; .) If the wildcard filespec contains a device or directory specification, then the resultant filespecs will also contain a device and directory; otherwise, device and directory information are removed. VMS-style resultant filespecs will contain a full device and directory, while Unix-style resultant filespecs will contain only as much of a directory path as was present in the input filespec. For example, if your default directory is Perl_Root:[000000], the expansion of &lt;code&gt;[.t]*.*&lt;/code&gt; will yield filespecs like &quot;perl_root:[t]base.dir&quot;, while the expansion of &lt;code&gt;t/*/*&lt;/code&gt; will yield filespecs like &quot;t/base.dir&quot;. (This is done to match the behavior of glob expansion performed by Unix shells.)</source>
          <target state="translated">在不带引号的命令行参数或调用 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; 的情况下，都将执行VMS通配符扩展。 （如果使用 &lt;code&gt;File::Glob::glob&lt;/code&gt; 则可以使用csh样式的通配符扩展。）如果通配符filespec包含设备或目录规范，则生成的文件规范还将包含设备和目录；否则，设备和目录信息将被删除。 VMS风格的结果文件规范将包含完整的设备和目录，而Unix风格的结果文件规范将仅包含与输入文件规范中一样多的目录路径。例如，如果您的默认目录为Perl_Root：[000000]，则扩展名 &lt;code&gt;[.t]*.*&lt;/code&gt; 将产生文件规范，例如&amp;ldquo; perl_root：[t] base.dir&amp;rdquo;，而扩展名 &lt;code&gt;t/*/*&lt;/code&gt; 会产生类似&amp;ldquo; t / base.dir&amp;rdquo;的文件规范。（这样做是为了匹配由Unix shell执行的全局扩展行为。）</target>
        </trans-unit>
        <trans-unit id="7acbdc4bab7e93326f2e293e78aa137135b956f7" translate="yes" xml:space="preserve">
          <source>In both these examples, the character being matched is non-Unicode, so Unicode doesn't define how it should match. It clearly isn't an ASCII hex digit, so the first example clearly should fail, and so it does, with no warning. But it is arguable that the second example should have an undefined, hence &lt;code&gt;FALSE&lt;/code&gt; , result. So a warning is raised for it.</source>
          <target state="translated">在这两个示例中，匹配的字符都是非Unicode字符，因此Unicode并未定义应如何匹配。它显然不是ASCII十六进制数字，因此第一个示例显然应该失败，并且确实如此，并且没有警告。但是有争议的是第二个示例应该有一个未定义的结果，即 &lt;code&gt;FALSE&lt;/code&gt; 。因此，对此提出了警告。</target>
        </trans-unit>
        <trans-unit id="9f0223354df20f59a567232c3197191e5bff5d52" translate="yes" xml:space="preserve">
          <source>In both usages of the autosplitter, only subroutines defined following the perl</source>
          <target state="translated">在自动分纸机的这两种用法中,只有按照perl</target>
        </trans-unit>
        <trans-unit id="e541d9732ad7ef01278201444dc42735718b9c21" translate="yes" xml:space="preserve">
          <source>In case of L&amp;lt;...&amp;gt; codes with no &quot;text|&quot; part in them, older formatters have exhibited great variation in actually displaying the link or cross reference. For example, L&amp;lt;crontab(5)&amp;gt; would render as &quot;the &lt;code&gt;crontab(5)&lt;/code&gt; manpage&quot;, or &quot;in the &lt;code&gt;crontab(5)&lt;/code&gt; manpage&quot; or just &quot;&lt;code&gt;crontab(5)&lt;/code&gt; &quot;.</source>
          <target state="translated">如果是L &amp;lt;...&amp;gt;代码而没有&amp;ldquo; text |&amp;rdquo; 在其中，较旧的格式化程序在实际显示链接或交叉引用方面表现出很大的差异。例如，L &amp;lt;crontab（5）&amp;gt;将呈现为&amp;ldquo; &lt;code&gt;crontab(5)&lt;/code&gt; 联机帮助页&amp;rdquo;或&amp;ldquo;在 &lt;code&gt;crontab(5)&lt;/code&gt; 联机帮助页中&amp;rdquo;​​或仅显示为&amp;ldquo; &lt;code&gt;crontab(5)&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="365d296ccf4014f926ba35dfa5ea9a2c360d66e7" translate="yes" xml:space="preserve">
          <source>In case of doubt, insert the following statement in front of your Perl program:</source>
          <target state="translated">如果有疑问,请在你的Perl程序前面插入以下语句。</target>
        </trans-unit>
        <trans-unit id="dfdb2521cd21a1ef333094706d67bdf22192a8cc" translate="yes" xml:space="preserve">
          <source>In case the advice in this guide has been updated recently, read the latest version directly from the perl source:</source>
          <target state="translated">如果本指南中的建议最近有更新,请直接从perl源码中阅读最新版本。</target>
        </trans-unit>
        <trans-unit id="23c62db8a34f2416b1d1b03ee56f5f1471c6e5f5" translate="yes" xml:space="preserve">
          <source>In case the result of one operation has more digits than specified, it is rounded. The rounding mode taken is either the default mode, or the one supplied to the operation after the</source>
          <target state="translated">如果一个操作的结果比指定的数字多,则进行四舍五入。四舍五入的模式是默认模式,或者是在运算后提供给运算的模式。</target>
        </trans-unit>
        <trans-unit id="4ff81268a14bba4a99da29ff2559bdaaf817ec79" translate="yes" xml:space="preserve">
          <source>In case you can choose between running a Makefile.PL or a Build.PL, which installer would you prefer (EUMM or MB or RAND)?</source>
          <target state="translated">如果你可以选择运行Makefile.PL或Build.PL,你更喜欢哪个安装程序(EUMM或MB或RAND)?</target>
        </trans-unit>
        <trans-unit id="4bcc550b219bf3be3a6806897874d6bb2e99f2b2" translate="yes" xml:space="preserve">
          <source>In case you're not familiar with the &quot;regular&quot; Version 8 regex routines, here are the pattern-matching rules not described above.</source>
          <target state="translated">如果你不熟悉 &quot;常规 &quot;的第8版regex例程,这里有上面没有描述的模式匹配规则。</target>
        </trans-unit>
        <trans-unit id="62dab9a7c702990dbb833dc9d9dafc87377a09a8" translate="yes" xml:space="preserve">
          <source>In cases of exceptionally aberrant documents, Pod parsers may abort the parse. Even then, using &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;ing/&lt;code&gt;croak&lt;/code&gt; ing is to be avoided; where possible, the parser library may simply close the input file and add text like &quot;*** Formatting Aborted ***&quot; to the end of the (partial) in-memory document.</source>
          <target state="translated">如果文档异常异常，则Pod解析器可能会中止解析。即使这样，也要避免使用 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;croak&lt;/code&gt; 。在可能的情况下，解析器库可以简单地关闭输入文件，并在（部分）内存文档的末尾添加诸如&amp;ldquo; ***格式已中止***&amp;rdquo;之类的文本。</target>
        </trans-unit>
        <trans-unit id="59b86d710288939d8eb974b61f2bbf30d7a131a6" translate="yes" xml:space="preserve">
          <source>In cases where get_title can't find the title, it will return empty-string (&quot;&quot;).</source>
          <target state="translated">在get_title找不到标题的情况下,它会返回空字符串(&quot;&quot;)。</target>
        </trans-unit>
        <trans-unit id="8bf9664b1f4d1fbea5b6e435c9a6c227eff0e2f3" translate="yes" xml:space="preserve">
          <source>In certain cases, the OS-level handles created by the pipe(), socket(), and accept() operators are apparently not duplicated accurately in pseudo-processes. This only happens in some situations, but where it does happen, it may result in deadlocks between the read and write ends of pipe handles, or inability to send or receive data across socket handles.</source>
          <target state="translated">在某些情况下,pipe()、socket()和accept()操作符创建的OS级句柄显然没有在伪进程中准确复制。这种情况只发生在某些情况下,但如果真的发生了,则可能会导致管道句柄的读端和写端之间的死锁,或者无法跨socket句柄发送或接收数据。</target>
        </trans-unit>
        <trans-unit id="f0057891cced8b178aba4808a03218c5201e0280" translate="yes" xml:space="preserve">
          <source>In certain systems, the operating system's locale support is broken and cannot be fixed or used by Perl. Such deficiencies can and will result in mysterious hangs and/or Perl core dumps when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect. When confronted with such a system, please report in excruciating detail to &amp;lt;</source>
          <target state="translated">在某些系统中，操作系统的语言环境支持已损坏，Perl无法修复或使用该语言环境。有效 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 时，此类缺陷可能会导致神秘的挂起和/或Perl核心转储。遇到这样的系统时，请向&amp;lt;</target>
        </trans-unit>
        <trans-unit id="60c7a29f6dd0bd0c499c2a79f889945240814e67" translate="yes" xml:space="preserve">
          <source>In code that currently says &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader; @ISA = qw(AutoLoader);&lt;/code&gt; you should remove AutoLoader from @ISA and change &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader 'AUTOLOAD';&lt;/code&gt; .</source>
          <target state="translated">在当前显示的代码中 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader; @ISA = qw(AutoLoader);&lt;/code&gt; 您应该从@ISA中删除AutoLoader并更改 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader;&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader 'AUTOLOAD';&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b746a74a7b045be066091fe7c51bf38b893c45a1" translate="yes" xml:space="preserve">
          <source>In comparison to the standard implementation where the object is a hash and the fields correspond to hash keys, here the fields correspond to hashes, and the object determines the hash key. Thus the hashes appear to be turned</source>
          <target state="translated">与标准实现相比,在标准实现中,对象是哈希,字段对应哈希键,这里字段对应哈希,对象决定哈希键。因此,哈希值似乎变成了</target>
        </trans-unit>
        <trans-unit id="402b2ae815c1f3f49820717ee0f679511f29fbf5" translate="yes" xml:space="preserve">
          <source>In connection with &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; simply adds bits, and this can be put to good use to count set bits efficiently:</source>
          <target state="translated">结合 &lt;code&gt;b&lt;/code&gt; 或 &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;%&lt;/code&gt; 只是添加位，并且可以很好地用于有效地计数设置的位：</target>
        </trans-unit>
        <trans-unit id="ed09b7a66d2eaa93bbb9724cd18388dac9e53c52" translate="yes" xml:space="preserve">
          <source>In consequence, if two or more classes want to access an object they</source>
          <target state="translated">因此,如果两个或更多的类想要访问一个对象,它们就会</target>
        </trans-unit>
        <trans-unit id="f69c1a7795cd05f1f7a1c806e629e11c671e5598" translate="yes" xml:space="preserve">
          <source>In contrast, &lt;code&gt;\b{...}&lt;/code&gt; and &lt;code&gt;\B{...}&lt;/code&gt; may or may not match at the beginning and end of the line, depending on the boundary type. These implement the Unicode default boundaries, specified in &lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/&lt;/a&gt;. The boundary types currently available are:</source>
          <target state="translated">相反， &lt;code&gt;\b{...}&lt;/code&gt; 和 &lt;code&gt;\B{...}&lt;/code&gt; 在行的开头和结尾可能匹配，也可能不匹配，具体取决于边界类型。它们实现了&lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/中&lt;/a&gt;指定的Unicode默认边界。当前可用的边界类型为：</target>
        </trans-unit>
        <trans-unit id="01521aaa27588449bcad287436418e3fa90af89f" translate="yes" xml:space="preserve">
          <source>In contrast, INSTALL_BASE has predictable, easy to explain installation locations. Now that Module::Build and MakeMaker both have INSTALL_BASE there is little reason to use PREFIX other than to preserve your existing installation locations. If you are starting a fresh Perl installation we encourage you to use INSTALL_BASE. If you have an existing installation installed via PREFIX, consider moving it to an installation structure matching INSTALL_BASE and using that instead.</source>
          <target state="translated">相比之下,INSTALL_BASE有可预测的、易于解释的安装位置。既然 Module::Build 和 MakeMaker 都有 INSTALL_BASE,除了保留现有的安装位置之外,几乎没有理由使用 PREFIX。如果你要开始一个新的Perl安装,我们鼓励你使用INSTALL_BASE。如果你有一个通过 PREFIX 安装的现有安装,请考虑将它移到一个与 INSTALL_BASE 相匹配的安装结构中,然后再使用它。</target>
        </trans-unit>
        <trans-unit id="b83a5099aeab352d7a9903a13c782e0d912d2e78" translate="yes" xml:space="preserve">
          <source>In contrast, hard references are more like hard links in a Unix file system: They are used to access an underlying object without concern for what its (other) name is. When the word &quot;reference&quot; is used without an adjective, as in the following paragraph, it is usually talking about a hard reference.</source>
          <target state="translated">相比之下,硬引用更像是Unix文件系统中的硬链接。它们被用来访问一个底层对象,而不关心它的(其他)名称是什么。当使用 &quot;reference &quot;这个词时,没有形容词,就像下面这段话一样,它通常是在说硬引用。</target>
        </trans-unit>
        <trans-unit id="4fefb1775bf2d6d801dc0e18387b980f80b2a1f8" translate="yes" xml:space="preserve">
          <source>In contrast, modules in the</source>
          <target state="translated">与此相反,模块中的</target>
        </trans-unit>
        <trans-unit id="d9d8046b6af82f0d0498eb1133f08ab96606ff69" translate="yes" xml:space="preserve">
          <source>In corporate life, to grant official approval to a thing, as in, &amp;ldquo;The VP of Engineering has blessed our WebCruncher project.&amp;rdquo; Similarly, in Perl, to grant official approval to a &lt;b&gt;referent&lt;/b&gt; so that it can function as an &lt;b&gt;object&lt;/b&gt;, such as a WebCruncher object. See the &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">在企业生活中，要对事物进行正式批准，例如，&amp;ldquo;工程副总裁祝福我们的WebCruncher项目。&amp;rdquo;类似地，在Perl中，对&lt;b&gt;引用对象&lt;/b&gt;给予正式批准，以便它可以用作&lt;b&gt;对象&lt;/b&gt;（例如WebCruncher对象）。见 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 骆驼第27章，&amp;ldquo;功能&amp;rdquo;功能。</target>
        </trans-unit>
        <trans-unit id="d9b2433b690bbfb6a8d4a6c1783fb717c5f969db" translate="yes" xml:space="preserve">
          <source>In deep binding, lexical variables mentioned in anonymous subroutines are the same ones that were in scope when the subroutine was created. In shallow binding, they are whichever variables with the same names happen to be in scope when the subroutine is called. Perl always uses deep binding of lexical variables (i.e., those created with my()). However, dynamic variables (aka global, local, or package variables) are effectively shallowly bound. Consider this just one more reason not to use them. See the answer to &lt;a href=&quot;#What's-a-closure%3f&quot;&gt;What's a closure?&lt;/a&gt;.</source>
          <target state="translated">在深度绑定中，匿名子例程中提到的词汇变量与创建子例程时作用域内的词汇变量相同。在浅表绑定中，当子程序被调用时，它们是范围内具有相同名称的变量。 Perl始终使用深度绑定词法变量（即，使用my（）创建的词法变量）。但是，动态变量（又称全局变量，局部变量或程序包变量）实际上是浅层绑定的。考虑这只是不使用它们的另一个原因。看到&lt;a href=&quot;#What's-a-closure%3f&quot;&gt;什么是封闭&lt;/a&gt;的答案？。</target>
        </trans-unit>
        <trans-unit id="20fadc3ec5ca97e1da30f076e8b9de4f5b9c66b4" translate="yes" xml:space="preserve">
          <source>In directories where either &lt;code&gt;Makefile.PL&lt;/code&gt; or &lt;code&gt;Build.PL&lt;/code&gt; exist, &lt;code&gt;perldoc&lt;/code&gt; will add &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; first to its search path, and as long as you're not the superuser will add &lt;code&gt;blib&lt;/code&gt; too. This is really helpful if you're working inside of a build directory and want to read through the docs even if you have a version of a module previously installed.</source>
          <target state="translated">在存在 &lt;code&gt;Makefile.PL&lt;/code&gt; 或 &lt;code&gt;Build.PL&lt;/code&gt; 的目录中， &lt;code&gt;perldoc&lt;/code&gt; 将添加 &lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;lib&lt;/code&gt; 首先进入其搜索路径，并且只要您不是超级用户，它也会添加 &lt;code&gt;blib&lt;/code&gt; 。如果您在构建目录中工作，并且即使您先前安装了某个模块的版本，也想通读文档，这将非常有用。</target>
        </trans-unit>
        <trans-unit id="b98ec9678a77351791b177991b84c25fc1205921" translate="yes" xml:space="preserve">
          <source>In each of the following groups, there may be many more constants provided than just the ones given as examples in the section heading. If the heading ends &lt;code&gt;...&lt;/code&gt; then this means there are likely more; the exact constants provided will depend on the OS and headers found at compile-time.</source>
          <target state="translated">在下面的每组中，可能提供的常量要比在节标题中作为示例给出的常量多得多。如果标题结束 &lt;code&gt;...&lt;/code&gt; 则表示可能还有更多；提供的确切常量将取决于操作系统和在编译时找到的标头。</target>
        </trans-unit>
        <trans-unit id="6cd886bd81b2389456301c1edaca970f0fd117a3" translate="yes" xml:space="preserve">
          <source>In earlier versions, when byte and character data were concatenated, the new string was sometimes created by decoding the byte strings as</source>
          <target state="translated">在早期的版本中,当字节和字符数据被连接时,新的字符串有时是通过将字节字符串解码为</target>
        </trans-unit>
        <trans-unit id="7dc7a0656f22946eb4e770e46a3f69e5d6f40e31" translate="yes" xml:space="preserve">
          <source>In effect, your search prefix is ignored and $Config{vms_prefix} is used instead.</source>
          <target state="translated">实际上,你的搜索前缀会被忽略,取而代之的是$Config{vms_prefix}。</target>
        </trans-unit>
        <trans-unit id="4c62ad53bb4b783795294732eef580256b60e336" translate="yes" xml:space="preserve">
          <source>In either case, you should still be able to run the scripts with perl explicitly:</source>
          <target state="translated">不管是哪种情况,你都应该能够使用perl显式运行脚本。</target>
        </trans-unit>
        <trans-unit id="fb41a30683f07ad432fb7627b6f4d0b50b059664" translate="yes" xml:space="preserve">
          <source>In extreme cases, &lt;b&gt;perlbug&lt;/b&gt; may not work well enough on your system to guide you through composing a bug report. In those cases, you may be able to use &lt;b&gt;perlbug -d&lt;/b&gt; to get system configuration information to include in a manually composed bug report to &lt;b&gt;perlbug@perl.org&lt;/b&gt;.</source>
          <target state="translated">在极端情况下，&lt;b&gt;perlbug&lt;/b&gt;在您的系统上可能无法正常工作，无法指导您编写错误报告。在这些情况下，您也许可以使用&lt;b&gt;perlbug -d&lt;/b&gt;获取系统配置信息，以将其包含在发送给&lt;b&gt;perlbug@perl.org&lt;/b&gt;的手动编写的错误报告中。</target>
        </trans-unit>
        <trans-unit id="abe9c1f86e0ce32785f02f8f2556f43d9ccd3599" translate="yes" xml:space="preserve">
          <source>In fact it is not 100% true that a compiled unit contains a pointer to the scratchpad AV. In fact it contains a pointer to an AV of (initially) one element, and this element is the scratchpad AV. Why do we need an extra level of indirection?</source>
          <target state="translated">事实上,一个编译单元包含一个指向scratchpad AV的指针并不是100%正确的。事实上,它包含了一个指向(最初)一个元素的AV的指针,这个元素就是scratchpad AV。为什么我们需要一个额外的间接层次?</target>
        </trans-unit>
        <trans-unit id="e844204f376cced819af429b122503a8c0eba54a" translate="yes" xml:space="preserve">
          <source>In fact mangling of</source>
          <target state="translated">事实上,杂乱无章的</target>
        </trans-unit>
        <trans-unit id="3370e0fda40977698cd4fccd53b4e05e504a7a69" translate="yes" xml:space="preserve">
          <source>In fact numbers stored in the native integer format may be stored either in the signed native form, or in the unsigned native form. Thus the limits for Perl numbers stored as native integers would typically be -2**31..2**32-1, with appropriate modifications in the case of 64-bit integers. Again, this does not mean that Perl can do operations only over integers in this range: it is possible to store many more integers in floating point format.</source>
          <target state="translated">事实上,以本机整数格式存储的数字既可以以有符号的本机形式存储,也可以以无符号的本机形式存储。因此,以本机整数形式存储的Perl数字的限制通常是-2**31...2**32-1,在64位整数的情况下进行适当修改。同样,这并不意味着Perl只能对这个范围内的整数进行操作:可以用浮点格式存储更多的整数。</target>
        </trans-unit>
        <trans-unit id="58c12119d45a0a6b7a7d70173ad8a47276ea5e91" translate="yes" xml:space="preserve">
          <source>In fact, a dynamic variable (also known as package or global variables) are still accessible using the fully qualified &lt;code&gt;::&lt;/code&gt; notation even while a lexical of the same name is also visible:</source>
          <target state="translated">实际上，即使也可以看到同名的词汇，仍然可以使用完全合格的 &lt;code&gt;::&lt;/code&gt; 符号来访问动态变量（也称为包或全局变量）：</target>
        </trans-unit>
        <trans-unit id="43fe617e28edf5522d6d7a7c2fe5c4bc3af16527" translate="yes" xml:space="preserve">
          <source>In fact, a simple identifier within such curlies is forced to be a string, and likewise within a hash subscript. Neither need quoting. Our earlier example, &lt;code&gt;$days{'Feb'}&lt;/code&gt; can be written as &lt;code&gt;$days{Feb}&lt;/code&gt; and the quotes will be assumed automatically. But anything more complicated in the subscript will be interpreted as an expression. This means for example that &lt;code&gt;$version{2.0}++&lt;/code&gt; is equivalent to &lt;code&gt;$version{2}++&lt;/code&gt; , not to &lt;code&gt;$version{'2.0'}++&lt;/code&gt; .</source>
          <target state="translated">实际上，在此类curl内的简单标识符被迫为字符串，并且同样被迫为哈希下标。都不需要报价。我们前面的示例 &lt;code&gt;$days{'Feb'}&lt;/code&gt; 可以写为 &lt;code&gt;$days{Feb}&lt;/code&gt; ，引号将被自动假定。但是下标中任何更复杂的内容都将被解释为表达式。例如，这意味着 &lt;code&gt;$version{2.0}++&lt;/code&gt; 等效于 &lt;code&gt;$version{2}++&lt;/code&gt; ，而不是 &lt;code&gt;$version{'2.0'}++&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="721f4b0102ec5d45627b4acee4d7283205201fd1" translate="yes" xml:space="preserve">
          <source>In fact, if you predeclare functions you want to call that way, you don't even need parentheses:</source>
          <target state="translated">事实上,如果你预先声明你想这样调用的函数,你甚至不需要括号。</target>
        </trans-unit>
        <trans-unit id="84798f732a21afa219bddab775dec767e752c195" translate="yes" xml:space="preserve">
          <source>In fact, one can put this check into a POSTCALL: section as well. Together with PREINIT: simplifications, this leads to:</source>
          <target state="translated">其实,也可以把这个检查放到POSTCALL:部分。加上PREINIT:的简化,这就导致:</target>
        </trans-unit>
        <trans-unit id="ebdfc7c600521f2938c49c5c2856e2e2b5dd3018" translate="yes" xml:space="preserve">
          <source>In fact, the above is a specific instance of a more general problem: we can't guarantee to produce BEGIN blocks or &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declarations in exactly the right place. So if you use a module which affects compilation (such as by over-riding keywords, overloading constants or whatever) then the output code might not work as intended.</source>
          <target state="translated">实际上，以上是一个更普遍问题的特定实例：我们不能保证产生BEGIN块或在正确的位置 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 声明。因此，如果您使用会影响编译的模块（例如，通过覆盖关键字，重载常量等），则输出代码可能无法按预期工作。</target>
        </trans-unit>
        <trans-unit id="ee7429eb30ff20d649952850c91750d9f7b5208e" translate="yes" xml:space="preserve">
          <source>In fact, the skeleton modules shown above are fully functional</source>
          <target state="translated">事实上,上图所示的骨架模块是功能齐全的</target>
        </trans-unit>
        <trans-unit id="c08ff00d22228fb68d08d8dbc97cd530161909a6" translate="yes" xml:space="preserve">
          <source>In fact, what can happen is that the Perl subroutine you have called can access the &lt;code&gt;@_&lt;/code&gt; array from a previous Perl subroutine. This will occur when the code that is executing the</source>
          <target state="translated">实际上，可能发生的是，您调用的Perl子例程可以从先前的Perl子例程访问 &lt;code&gt;@_&lt;/code&gt; 数组。当正在执行的代码</target>
        </trans-unit>
        <trans-unit id="5159536cbfaf213ba408ca2109f0a550ad3339ea" translate="yes" xml:space="preserve">
          <source>In fact, you can use as many repeated angle-brackets as you like so long as you have the same number of them in the opening and closing delimiters, and make sure that whitespace immediately follows the last '&amp;lt;' of the opening delimiter, and immediately precedes the first '&amp;gt;' of the closing delimiter. (The whitespace is ignored.) So the following will also work:</source>
          <target state="translated">实际上，您可以使用任意多个重复的尖括号，只要在开始和结束定界符中使用相同的数量，并确保空格紧跟在最后定界符的最后一个&amp;ldquo; &amp;lt;&amp;rdquo;之后，紧接在结束定界符的第一个'&amp;gt;'之前。（空格被忽略。）因此，以下内容也将起作用：</target>
        </trans-unit>
        <trans-unit id="eeef4cfd76862c3bdd64f8624b59be39f324bbb5" translate="yes" xml:space="preserve">
          <source>In former versions of FindBin there was no &lt;code&gt;again&lt;/code&gt; function. The workaround was to force the &lt;code&gt;BEGIN&lt;/code&gt; block to be executed again:</source>
          <target state="translated">在以前版本的FindBin中，没有 &lt;code&gt;again&lt;/code&gt; 起作用。解决方法是强制再次执行 &lt;code&gt;BEGIN&lt;/code&gt; 块：</target>
        </trans-unit>
        <trans-unit id="81bdf0d224677096b960b752cf09cb19f280de31" translate="yes" xml:space="preserve">
          <source>In function definitions, name starts in column 0 (return value-type is on previous line)</source>
          <target state="translated">在函数定义中,名称从第0列开始(返回值类型在前面一行)。</target>
        </trans-unit>
        <trans-unit id="bd418e3b4eaab23d82d37560db5e07798de430bc" translate="yes" xml:space="preserve">
          <source>In general the flags should be preserved in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; after compilation, although the regex engine might want to add or delete some of them to invoke or disable some special behavior in Perl. The flags along with any special behavior they cause are documented below:</source>
          <target state="translated">通常，尽管正则表达式引擎可能希望添加或删除其中一些标记以调用或禁用Perl中的某些特殊行为，但编译后这些标记应保留在 &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; 中。这些标志及其引起的任何特殊行为记录在下面：</target>
        </trans-unit>
        <trans-unit id="cf0fc22fd30f9556953173964854405f4701bcb8" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Module ()&lt;/code&gt; is recommended over &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Module&lt;/code&gt; , because it determines module availability at compile time, not in the middle of your program's execution. An exception would be if two modules each tried to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; each other, and each also called a function from that other module. In that case, it's easy to use &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">通常，建议 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Module ()&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Module&lt;/code&gt; ，因为它确定了编译时的模块可用性，而不是在程序执行过程中。如果两个模块各自尝试彼此 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ，并且每个模块又从另一个模块中调用一个函数，则将是一个例外。在这种情况下，可以轻松使用 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 来代替。</target>
        </trans-unit>
        <trans-unit id="f587f957aa9f0d170955c8740a69ee20fd8f9433" translate="yes" xml:space="preserve">
          <source>In general, a value of 256MB (or &quot;256*1024*1024&quot;) is sufficient for Perl to compile at maximum optimization.</source>
          <target state="translated">一般来说,256MB(或 &quot;256*1024*1024&quot;)的值足以让Perl在最大优化下进行编译。</target>
        </trans-unit>
        <trans-unit id="131ff1b059b6e02af211bb33de067db4f34cad70" translate="yes" xml:space="preserve">
          <source>In general, any generated Makefile checks for the current version of MakeMaker and the version the Makefile was built under. If NO_VC is set, the version check is neglected. Do not write this into your Makefile.PL, use it interactively instead.</source>
          <target state="translated">一般来说,任何生成的Makefile都会检查MakeMaker的当前版本和Makefile的版本。如果设置了NO_VC,版本检查就会被忽略。不要把这个写进你的Makefile.PL中,而是用交互式的方式。</target>
        </trans-unit>
        <trans-unit id="ed1c758f94f821404f1b8e30ece4cfe61ee49211" translate="yes" xml:space="preserve">
          <source>In general, binmode() should be called after open() but before any I/O is done on the filehandle. Calling binmode() normally flushes any pending buffered output data (and perhaps pending input data) on the handle. An exception to this is the &lt;code&gt;:encoding&lt;/code&gt; layer that changes the default character encoding of the handle; see &lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;. The &lt;code&gt;:encoding&lt;/code&gt; layer sometimes needs to be called in mid-stream, and it doesn't flush the stream. The &lt;code&gt;:encoding&lt;/code&gt; also implicitly pushes on top of itself the &lt;code&gt;:utf8&lt;/code&gt; layer because internally Perl operates on UTF8-encoded Unicode characters.</source>
          <target state="translated">通常，binmode（）应该在open（）之后但在文件句柄上完成任何I / O之前调用。调用binmode（）通常会刷新句柄上所有暂挂的缓冲输出数据（可能还有暂挂的输入数据）。 &lt;code&gt;:encoding&lt;/code&gt; 层是一个例外，它更改了句柄的默认字符编码。见&lt;a href=&quot;#open&quot;&gt;开放&lt;/a&gt;。的 &lt;code&gt;:encoding&lt;/code&gt; 层有时需要在中流被调用，并且它不冲洗流。的 &lt;code&gt;:encoding&lt;/code&gt; 也隐含在其本身上推动 &lt;code&gt;:utf8&lt;/code&gt; 因为内部的Perl上UTF8编码的Unicode字符操作层。</target>
        </trans-unit>
        <trans-unit id="fcb23e7c19f51e6c8ab203413d609cc6c59591a8" translate="yes" xml:space="preserve">
          <source>In general, binmode() should be called after open() but before any I/O is done on the filehandle. Calling binmode() normally flushes any pending buffered output data (and perhaps pending input data) on the handle. An exception to this is the &lt;code&gt;:encoding&lt;/code&gt; layer that changes the default character encoding of the handle; see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;. The &lt;code&gt;:encoding&lt;/code&gt; layer sometimes needs to be called in mid-stream, and it doesn't flush the stream. The &lt;code&gt;:encoding&lt;/code&gt; also implicitly pushes on top of itself the &lt;code&gt;:utf8&lt;/code&gt; layer because internally Perl operates on UTF8-encoded Unicode characters.</source>
          <target state="translated">通常，binmode（）应该在open（）之后但在文件句柄上完成任何I / O之前调用。调用binmode（）通常会刷新句柄上所有暂挂的缓冲输出数据（可能还有暂挂的输入数据）。 &lt;code&gt;:encoding&lt;/code&gt; 层是一个例外，它更改了句柄的默认字符编码。见&lt;a href=&quot;open&quot;&gt;开放&lt;/a&gt;。的 &lt;code&gt;:encoding&lt;/code&gt; 层有时需要在中流被调用，并且它不冲洗流。的 &lt;code&gt;:encoding&lt;/code&gt; 也隐含在其本身上推动 &lt;code&gt;:utf8&lt;/code&gt; 因为内部的Perl上UTF8编码的Unicode字符操作层。</target>
        </trans-unit>
        <trans-unit id="9112f219636184c8537b2886b966af1ac78ce610" translate="yes" xml:space="preserve">
          <source>In general, documentation should describe what Perl does &quot;now&quot; rather than what it used to do. It's perfectly reasonable to include notes in documentation about how behaviour has changed from previous releases, but, with very few exceptions, documentation isn't &quot;dual-life&quot; -- it doesn't need to fully describe how all old versions used to work.</source>
          <target state="translated">一般来说,文档应该描述Perl &quot;现在 &quot;做了什么,而不是过去做了什么。在文档中加入关于以前版本行为变化的说明是完全合理的,但是,除了极少数例外,文档并不是 &quot;双重生活&quot;--它不需要完全描述所有旧版本过去是如何工作的。</target>
        </trans-unit>
        <trans-unit id="c3bded401bb84dc2978238aa4ca8d1e409847f99" translate="yes" xml:space="preserve">
          <source>In general, don't directly access the system in code meant to be portable. That means, no &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;``&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;|&lt;/code&gt;, nor any of the other things that makes being a Perl hacker worth being.</source>
          <target state="translated">通常，不要直接使用可移植的代码直接访问系统。这意味着，没有 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;``&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 一个 &lt;code&gt;|&lt;/code&gt; ，也没有其他值得成为Perl黑客的东西。</target>
        </trans-unit>
        <trans-unit id="4812a1f34a0b31a652cad991bba82f8957d788f2" translate="yes" xml:space="preserve">
          <source>In general, functions in Perl that serve as wrappers for system calls (&quot;syscalls&quot;) of the same name (like chown(2), fork(2), closedir(2), etc.) return true when they succeed and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise, as is usually mentioned in the descriptions below. This is different from the C interfaces, which return &lt;code&gt;-1&lt;/code&gt; on failure. Exceptions to this rule include &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt;. System calls also set the special &lt;code&gt;$!&lt;/code&gt; variable on failure. Other functions do not, except accidentally.</source>
          <target state="translated">通常，Perl中充当相同名称（例如chown（2），fork（2），closedir（2）等）的系统调用（&amp;ldquo; syscalls&amp;rdquo;）的包装的函数在成功时返回true，否则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，如以下说明中通常提到的。这与C接口不同，后者在失败时返回 &lt;code&gt;-1&lt;/code&gt; 。该规则的例外包括 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 。系统调用还设置了特殊的 &lt;code&gt;$!&lt;/code&gt; 失败变量。除了偶然，其他功能没有。</target>
        </trans-unit>
        <trans-unit id="2d920741739edbfdbddc6a5906e0b7d1f697b74b" translate="yes" xml:space="preserve">
          <source>In general, if something strange has gone wrong with your program and you're not sure where you should look for help, try making your code comply with &lt;b&gt;use strict&lt;/b&gt; and &lt;b&gt;use warnings&lt;/b&gt;. These will often point out exactly where the trouble is.</source>
          <target state="translated">通常，如果您的程序出现了一些奇怪的问题，并且您不确定应该在哪里寻求帮助，请尝试使您的代码符合&lt;b&gt;use strict&lt;/b&gt;和&lt;b&gt;use warnings&lt;/b&gt;。这些通常会指出问题出在哪里。</target>
        </trans-unit>
        <trans-unit id="4f338449d4134d94449e7a10434356d790a883d8" translate="yes" xml:space="preserve">
          <source>In general, it is better to create directories with a permissive MASK and let the user modify that with their &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; than it is to supply a restrictive MASK and give the user no way to be more permissive. The exceptions to this rule are when the file or directory should be kept private (mail files, for instance). The perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; discusses the choice of MASK in more detail.</source>
          <target state="translated">通常，最好使用允许的MASK创建目录，并让用户使用其 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 对其进行修改，而不是提供限制性的MASK并为用户提供更多允许的方法。该规则的例外情况是文件或目录应保持私有状态（例如，邮件文件）。 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 上的perlfunc（1）条目详细讨论了MASK的选择。</target>
        </trans-unit>
        <trans-unit id="859fd0676cfab168da7696f014146535cbe0534d" translate="yes" xml:space="preserve">
          <source>In general, it is better to create directories with a permissive MASK and let the user modify that with their &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; than it is to supply a restrictive MASK and give the user no way to be more permissive. The exceptions to this rule are when the file or directory should be kept private (mail files, for instance). The perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; discusses the choice of MASK in more detail.</source>
          <target state="translated">通常，最好使用允许的MASK创建目录，并让用户使用其 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 对其进行修改，而不是提供限制性的MASK并为用户提供更多允许的方法。该规则的例外情况是文件或目录应保持私有状态（例如，邮件文件）。 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 上的perlfunc（1）条目详细讨论了MASK的选择。</target>
        </trans-unit>
        <trans-unit id="cad59e50fb94fade64091c926ff1356d37dc6324" translate="yes" xml:space="preserve">
          <source>In general, it's not a good idea to write extensions that modify their input parameters, as in Example 3. Instead, you should probably return multiple values in an array and let the caller handle them (we'll do this in a later example). However, in order to better accommodate calling pre-existing C routines, which often do modify their input parameters, this behavior is tolerated.</source>
          <target state="translated">一般来说,像例3那样,编写修改输入参数的扩展不是一个好主意。相反,你可能应该在一个数组中返回多个值,并让调用者处理它们(我们将在后面的例子中这样做)。然而,为了更好地适应对已有的C例程的调用,这些例程通常会修改它们的输入参数,这种行为是可以容忍的。</target>
        </trans-unit>
        <trans-unit id="183640340bc430e8d749b47027dff4d3c19e6dde" translate="yes" xml:space="preserve">
          <source>In general, memory allocation and de-allocation isn't something you can or should be worrying about much in Perl.</source>
          <target state="translated">一般来说,在Perl中,内存的分配和去分配并不是你可以或者应该多操心的事情。</target>
        </trans-unit>
        <trans-unit id="694bbd0c5ca4e3fe0dcb487e904ca0b8ccaba6cd" translate="yes" xml:space="preserve">
          <source>In general, please follow the particular style of the code you are patching.</source>
          <target state="translated">一般来说,请遵循你所打补丁的代码的特定风格。</target>
        </trans-unit>
        <trans-unit id="76448cd179f9ee3d08189e3b4f4ab1ba0deb68f0" translate="yes" xml:space="preserve">
          <source>In general, production code should not have file paths hardcoded. Making them user-supplied or read from a configuration file is better, keeping in mind that file path syntax varies on different machines.</source>
          <target state="translated">一般来说,生产代码不应该硬编码文件路径。最好让它们由用户提供或从配置文件中读取,记住文件路径语法在不同的机器上有所不同。</target>
        </trans-unit>
        <trans-unit id="15ebd5f7d0f38eb2ba1e333ec5e5f7197b5f77f7" translate="yes" xml:space="preserve">
          <source>In general, the VMS version of ext() should properly handle input from extensions originally designed for a Unix or VMS environment. If you encounter problems, or discover cases where the search could be improved, please let us know.</source>
          <target state="translated">一般来说,VMS版本的ext()应该正确处理最初为Unix或VMS环境设计的扩展的输入。如果你遇到问题,或者发现搜索可以改进的情况,请告诉我们。</target>
        </trans-unit>
        <trans-unit id="6fd9faf570da706152bccbfe022ff5b9665bb3b0" translate="yes" xml:space="preserve">
          <source>In general, the benefit of a language is closely related to the skill of the people using that language. If you or your team can be faster, better, and stronger through Perl, you'll deliver more value. Remember, people often respond better to what they get out of it. If you run into resistance, figure out what those people get out of the other choice and how Perl might satisfy that requirement.</source>
          <target state="translated">一般来说,一门语言的好处与使用该语言的人的技能密切相关。如果你或你的团队能够通过Perl更快、更好、更强,你就能提供更多的价值。记住,人们往往会对他们所得到的东西做出更好的反应。如果你遇到了阻力,请弄清楚这些人从其他选择中得到了什么,以及Perl可能如何满足这一要求。</target>
        </trans-unit>
        <trans-unit id="c1872d2ad517d8a6c01a447283eab0112566170f" translate="yes" xml:space="preserve">
          <source>In general, the distributed kit for a Perl extension includes a file named Makefile.PL, which is a Perl program which is used to create a</source>
          <target state="translated">一般来说,Perl扩展名的分布式工具包包括一个名为Makefile.PL的文件,它是一个Perl程序,用来创建一个</target>
        </trans-unit>
        <trans-unit id="3997a59e30d7c4c978daa07218b367eb8d7c9173" translate="yes" xml:space="preserve">
          <source>In general, the easiest path to portability is always to specify filenames in Unix format unless they will need to be processed by native commands or utilities. Because of this latter consideration, the File::Spec module by default returns native format specifications regardless of input format. This default may be reversed so that filenames are always reported in Unix format by specifying the &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; feature logical in the environment.</source>
          <target state="translated">通常，最容易移植的方法始终是以Unix格式指定文件名，除非它们需要由本机命令或实用程序处理。由于后面的考虑，因此File :: Spec模块默认情况下返回本机格式规范，而不管输入格式如何。可以颠倒默认设置，以便通过在环境中指定逻辑 &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; 功能始终以Unix格式报告文件名。</target>
        </trans-unit>
        <trans-unit id="28770c3025c0aede638f676bb8209a09acd6f0b6" translate="yes" xml:space="preserve">
          <source>In general, the perl interpreter views itself as the center of the universe as far as the Perl program goes. XS code is viewed as a help-mate, to accomplish things that perl doesn't do, or doesn't do fast enough, but always subservient to perl. The closer XS code adheres to this model, the less likely conflicts will occur.</source>
          <target state="translated">一般来说,就Perl程序而言,perl解释器将自己视为宇宙的中心。XS代码被看作是一个帮助伙伴,来完成perl没有做的事情,或者做得不够快,但始终服从于perl。XS代码越接近这种模式,就越不容易发生冲突。</target>
        </trans-unit>
        <trans-unit id="a1d0e4d941599d8b8058171587801ee612197c61" translate="yes" xml:space="preserve">
          <source>In general, the standard modules work across platforms. Notable exceptions are the &lt;code&gt;CPAN&lt;/code&gt; module (which currently makes connections to external programs that may not be available), platform-specific modules (like &lt;code&gt;ExtUtils::MM_VMS&lt;/code&gt; ), and DBM modules.</source>
          <target state="translated">通常，标准模块可跨平台工作。值得注意的例外是 &lt;code&gt;CPAN&lt;/code&gt; 模块（当前无法连接到可能不可用的外部程序），特定于平台的模块（例如 &lt;code&gt;ExtUtils::MM_VMS&lt;/code&gt; ）和DBM模块。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
