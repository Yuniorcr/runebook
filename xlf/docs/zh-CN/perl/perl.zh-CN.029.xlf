<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="95121980b89b7a9fb796f03c8d74599823515afb" translate="yes" xml:space="preserve">
          <source>In general, there's no need to worry about the order of calls. They will be left-to-right, breadth-first, most-derived-first. This works perfectly for most inherited methods (including destructors), but is inappropriate for some kinds of methods (such as constructors, cloners, debuggers, and initializers) where it's more appropriate that the least-derived methods be called first (as more-derived methods may rely on the behaviour of their &quot;ancestors&quot;). In that case, instead of using the &lt;code&gt;EVERY&lt;/code&gt; pseudo-class:</source>
          <target state="translated">通常，无需担心呼叫顺序。他们将是从左到右，广度优先，派生最广的优先。这对于大多数继承的方法（包括析构函数）而言是完美的，但不适用于某些类型的方法（例如构造函数，克隆器，调试器和初始化器），在这种情况下，首先应将最少派生的方法称为更合理的方法（因为派生性更高）方法可能取决于其&amp;ldquo;祖先&amp;rdquo;的行为）。在这种情况下，不要使用 &lt;code&gt;EVERY&lt;/code&gt; 伪类：</target>
        </trans-unit>
        <trans-unit id="294f7f9dd3d63c6c658291241c38389ef5522490" translate="yes" xml:space="preserve">
          <source>In general, though, it's best to use the &lt;code&gt;Sv*V&lt;/code&gt; macros.</source>
          <target state="translated">但是，一般而言，最好使用 &lt;code&gt;Sv*V&lt;/code&gt; 宏。</target>
        </trans-unit>
        <trans-unit id="aabaf80efaeb23cca024ae206403fa19e6f8a255" translate="yes" xml:space="preserve">
          <source>In general, with &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; enabled, more detailed information will be available in the exit status for DCL scripts or other native VMS tools, and will give the expected information for Posix programs. It has not been made the default in order to preserve backward compatibility.</source>
          <target state="translated">通常，启用 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 后，将在DCL脚本或其他本机VMS工具的退出状态中提供更多详细信息，并将提供Posix程序的预期信息。为了保持向后兼容性，尚未将其设置为默认值。</target>
        </trans-unit>
        <trans-unit id="d941c018a8912081ee9a18eaddf237ed10e20a20" translate="yes" xml:space="preserve">
          <source>In general, you can't do this. There are some things that may work for your situation though. People usually ask this question because they want to distribute their works without giving away the source code, and most solutions trade disk space for convenience. You probably won't see much of a speed increase either, since most solutions simply bundle a Perl interpreter in the final product (but see &lt;a href=&quot;#How-can-I-make-my-Perl-program-run-faster%3f&quot;&gt;How can I make my Perl program run faster?&lt;/a&gt;).</source>
          <target state="translated">通常，您无法执行此操作。但是有些事情可能会适合您的情况。人们通常会问这个问题，因为他们希望在不放弃源代码的情况下分发其作品，并且大多数解决方案都是为了方便而交换磁盘空间。您可能也不会看到速度的提高，因为大多数解决方案只是在最终产品中捆绑了一个Perl解释器（但请参见&lt;a href=&quot;#How-can-I-make-my-Perl-program-run-faster%3f&quot;&gt;如何使我的Perl程序运行得更快？&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a9eadd2908a4639d8decf9b9f18aef810c6f9990" translate="yes" xml:space="preserve">
          <source>In general, you don't &quot;declare&quot; a structure. Just use a (probably anonymous) hash reference. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; and &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt; for details. Here's an example:</source>
          <target state="translated">通常，您不会&amp;ldquo;声明&amp;rdquo;结构。只需使用（可能是匿名的）哈希引用即可。有关详细信息，请参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;和&lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt;。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="7f00c5d5b02fc95d1502392b2b9783083f707dee" translate="yes" xml:space="preserve">
          <source>In general, you don't, because you don't know whether the recipient has a color-aware display device. If you know that they have an ANSI terminal that understands color, you can use the &lt;a href=&quot;term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; module from CPAN:</source>
          <target state="translated">通常，您不会，因为您不知道收件人是否具有可识别颜色的显示设备。如果您知道他们的ANSI终端可以识别颜色，则可以使用CPAN中的&lt;a href=&quot;term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt;模块：</target>
        </trans-unit>
        <trans-unit id="2f87cb8b42da40e06ddcf5b3026af1eac6aa3d5a" translate="yes" xml:space="preserve">
          <source>In general, you either have to know what you're dealing with, or you have to guess. The API function &lt;code&gt;is_utf8_string&lt;/code&gt; can help; it'll tell you if a string contains only valid UTF-8 characters, and the chances of a non-UTF-8 string looking like valid UTF-8 become very small very quickly with increasing string length. On a character-by-character basis, &lt;code&gt;isUTF8_CHAR&lt;/code&gt; will tell you whether the current character in a string is valid UTF-8.</source>
          <target state="translated">通常，您要么必须知道要处理的内容，要么就必须猜测。API函数 &lt;code&gt;is_utf8_string&lt;/code&gt; 可以提供帮助；它会告诉您字符串是否仅包含有效的UTF-8字符，并且随着字符串长度的增加，非UTF-8字符串看起来像有效UTF-8的机会会非常小。在每个字符的基础上， &lt;code&gt;isUTF8_CHAR&lt;/code&gt; 会告诉您字符串中的当前字符是否为有效的UTF-8。</target>
        </trans-unit>
        <trans-unit id="26ea48aedd1cf988ca4c353ab67e2113694ba714" translate="yes" xml:space="preserve">
          <source>In human terms, it's a funny way of passing arguments to a subroutine when you define it as well as when you call it. It's useful for setting up little bits of code to run later, such as callbacks. You can even do object-oriented stuff with it, though Perl already provides a different mechanism to do that--see &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">用人类的话来说，这是一种在定义和调用子例程时将参数传递给子例程的有趣方式。这对于设置一些稍后运行的代码很有用，例如回调。您甚至可以用它来做面向对象的工作，尽管Perl已经提供了一种不同的机制来做到这一点-参见&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ba4c53f21b8779523425f16e680264ebae0decb" translate="yes" xml:space="preserve">
          <source>In inverted bracketed character classes, Perl ignores the Unicode rules that normally say that named sequence, and certain characters should match a sequence of multiple characters use under caseless &lt;code&gt;/i&lt;/code&gt; matching. Following those rules could lead to highly confusing situations:</source>
          <target state="translated">在倒置括号字符类中，Perl忽略通常说命名序列的Unicode规则，并且某些字符应与在无大小写 &lt;code&gt;/i&lt;/code&gt; 匹配下使用的多个字符序列匹配。遵循这些规则可能会导致高度混乱的情况：</target>
        </trans-unit>
        <trans-unit id="60a70875c03150cbfc8e14e2cc2dec49ecd50454" translate="yes" xml:space="preserve">
          <source>In its most basic usage, &lt;code&gt;ok(...)&lt;/code&gt; simply takes a single scalar expression. If its value is true, the test passes; if false, the test fails. Examples:</source>
          <target state="translated">在最基本的用法中， &lt;code&gt;ok(...)&lt;/code&gt; 仅采用单个标量表达式。如果其值为true，则测试通过。如果为假，则测试失败。例子：</target>
        </trans-unit>
        <trans-unit id="4d817298c353371e9d0b73c75cf1950195e64063" translate="yes" xml:space="preserve">
          <source>In its second form, &lt;code&gt;cond_wait&lt;/code&gt; takes a shared, &lt;b&gt;unlocked&lt;/b&gt; variable followed by a shared, &lt;b&gt;locked&lt;/b&gt; variable. The second variable is unlocked and thread execution suspended until another thread signals the first variable.</source>
          <target state="translated">在第二种形式中， &lt;code&gt;cond_wait&lt;/code&gt; 接受一个共享的，&lt;b&gt;未锁定的&lt;/b&gt;变量，然后是一个共享的，&lt;b&gt;锁定的&lt;/b&gt;变量。第二个变量被解锁，线程执行被挂起，直到另一个线程通知第一个变量。</target>
        </trans-unit>
        <trans-unit id="4c9702efe584ddf3df38f0a305879394e6c945fd" translate="yes" xml:space="preserve">
          <source>In its two-argument form, &lt;code&gt;cond_timedwait&lt;/code&gt; takes a &lt;b&gt;locked&lt;/b&gt; variable and an absolute timeout in</source>
          <target state="translated">&lt;code&gt;cond_timedwait&lt;/code&gt; 以其两个参数的形式接受一个&lt;b&gt;锁定的&lt;/b&gt;变量和一个绝对超时</target>
        </trans-unit>
        <trans-unit id="fbaa31119043f388b0d536e0c6af6beff83b01ef" translate="yes" xml:space="preserve">
          <source>In its two-argument form, &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; compares the two scalar values to see if they match. They match if both are undefined, or if</source>
          <target state="translated">&lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; 以其两个参数的形式比较两个标量值，看它们是否匹配。如果两者都未定义，或者如果</target>
        </trans-unit>
        <trans-unit id="278b05f5c861132c7f4bc86f277c1645adbbdf57" translate="yes" xml:space="preserve">
          <source>In less grandiose terms, the first part of the job is to turn a pattern into something the computer can efficiently use to find the matching point in the string, and the second part is performing the search itself.</source>
          <target state="translated">用不太夸张的话来说,第一部分的工作是把一个模式变成计算机可以有效利用的东西,以找到字符串中的匹配点,第二部分是执行搜索本身。</target>
        </trans-unit>
        <trans-unit id="f53ef23dfb1a32e84061a4ee3198583f6963d3be" translate="yes" xml:space="preserve">
          <source>In line 7, we make sure that the SV will have enough room to accommodate the old string, the new string and the null terminator. If &lt;code&gt;LEN&lt;/code&gt; isn't big enough, &lt;code&gt;SvGROW&lt;/code&gt; will reallocate space for us.</source>
          <target state="translated">在第7行中，我们确保SV有足够的空间容纳旧字符串，新字符串和空终止符。如果 &lt;code&gt;LEN&lt;/code&gt; 不够大， &lt;code&gt;SvGROW&lt;/code&gt; 将为我们重新分配空间。</target>
        </trans-unit>
        <trans-unit id="6338eafb38b19e3533d3d49a05621b9aaa4f97d8" translate="yes" xml:space="preserve">
          <source>In line mode, &lt;code&gt;filter_read&lt;/code&gt; will append the next source line to the end of the &lt;code&gt;$_&lt;/code&gt; scalar.</source>
          <target state="translated">在行模式下， &lt;code&gt;filter_read&lt;/code&gt; 将下一个源代码行附加到 &lt;code&gt;$_&lt;/code&gt; 标量的末尾。</target>
        </trans-unit>
        <trans-unit id="a450e27bd36ea332e7d75f6381cc8a12782b5b7a" translate="yes" xml:space="preserve">
          <source>In list context (which is usually what you want), the function returns a (possibly empty) list of language tags representing (best first) what languages the user apparently would accept output in. You will probably want to pass the output of this through &lt;code&gt;I18N::LangTags::implicate_supers_tightly(...)&lt;/code&gt; or &lt;code&gt;I18N::LangTags::implicate_supers(...)&lt;/code&gt; , like so:</source>
          <target state="translated">在列表上下文（通常是您想要的）中，该函数返回（可能是空的）语言标签列表，这些列表表示（最好是第一）用户显然将接受输出的语言。您可能希望将其输出传递给 &lt;code&gt;I18N::LangTags::implicate_supers_tightly(...)&lt;/code&gt; 或 &lt;code&gt;I18N::LangTags::implicate_supers(...)&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="239ff52c002bacbd9ef8a650976d52e44cb1392b" translate="yes" xml:space="preserve">
          <source>In list context it returns a two element list, the first element containing the pattern and the second containing the modifiers used when the pattern was compiled.</source>
          <target state="translated">在列表上下文中,它返回一个双元素列表,第一个元素包含模式,第二个元素包含模式编译时使用的修饰符。</target>
        </trans-unit>
        <trans-unit id="a8954af69f3e9417a81eb4843c66328678eb290e" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;//g&lt;/code&gt; returns a list of matched groupings, or if there are no groupings, a list of matches to the whole regex. So</source>
          <target state="translated">在列表上下文中， &lt;code&gt;//g&lt;/code&gt; 返回匹配的分组列表，或者如果没有分组，则返回与整个正则表达式匹配的列表。所以</target>
        </trans-unit>
        <trans-unit id="4a59e7f9e300ced2156a7bfdcb5c2ed656175ffd" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;//g&lt;/code&gt; returns a list of matched groupings, or if there are no groupings, a list of matches to the whole regexp. So if we wanted just the words, we could use</source>
          <target state="translated">在列表上下文中， &lt;code&gt;//g&lt;/code&gt; 返回匹配的分组的列表，或者如果没有分组，则返回与整个正则表达式匹配的列表。因此，如果我们只想要这些单词，我们可以使用</target>
        </trans-unit>
        <trans-unit id="ce23af9639d689001f6ad6f1b438efaee509bdfe" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;extract_delimited&lt;/code&gt; returns a array of three elements, the extracted substring (</source>
          <target state="translated">在列表上下文中， &lt;code&gt;extract_delimited&lt;/code&gt; 返回包含三个元素的数组，即提取的子字符串（</target>
        </trans-unit>
        <trans-unit id="85fefe43cf3ce99aee8bf62db2fc923ea0e22144" translate="yes" xml:space="preserve">
          <source>In list context, a match &lt;code&gt;/regex/&lt;/code&gt; with groupings will return the list of matched values &lt;code&gt;($1,$2,...)&lt;/code&gt; . So we could rewrite it as</source>
          <target state="translated">在列表上下文中，具有分组的匹配 &lt;code&gt;/regex/&lt;/code&gt; 将返回匹配值的列表 &lt;code&gt;($1,$2,...)&lt;/code&gt; 。因此我们可以将其重写为</target>
        </trans-unit>
        <trans-unit id="c008355e8673133191ef9e0d9724c780f81e596e" translate="yes" xml:space="preserve">
          <source>In list context, both the remaining time and the interval are returned.</source>
          <target state="translated">在列表上下文中,剩余时间和时间间隔都会返回。</target>
        </trans-unit>
        <trans-unit id="4ff8ef7b7f3933511d227abc0760c6958871615f" translate="yes" xml:space="preserve">
          <source>In list context, both the remaining time and the interval are returned. The interval is always what you put in using &lt;code&gt;setitimer()&lt;/code&gt; .</source>
          <target state="translated">在列表上下文中，将返回剩余时间和间隔。间隔始终是您使用 &lt;code&gt;setitimer()&lt;/code&gt; 输入的间隔。</target>
        </trans-unit>
        <trans-unit id="1f52db4aa7cef4591f6ad21954e80ef3d1ce4ff3" translate="yes" xml:space="preserve">
          <source>In list context, if the second parameter is present and evaluates TRUE, the method returns an associative array. The keys of the associative array correspond to the values that matched in the BTREE and the values of the array are a count of the number of times that particular value occurred in the BTREE.</source>
          <target state="translated">在列表上下文中,如果第二个参数存在且值为TRUE,则该方法返回一个关联数组。关联数组的键对应于BTREE中匹配的值,数组的值是该特定值在BTREE中出现的次数。</target>
        </trans-unit>
        <trans-unit id="611c9c24bc1f7655268ae0a922a1bafe9f75484e" translate="yes" xml:space="preserve">
          <source>In list context, it returns all the values which match &lt;code&gt;$key&lt;/code&gt; . Note that the values will be returned in an apparently random order.</source>
          <target state="translated">在列表上下文中，它返回与 &lt;code&gt;$key&lt;/code&gt; 匹配的所有值。请注意，这些值将以明显随机的顺序返回。</target>
        </trans-unit>
        <trans-unit id="b9e8a08a17d7e9ccb66ceef8551ab60c5578a3cb" translate="yes" xml:space="preserve">
          <source>In list context, it's just the list argument separator, and inserts both its arguments into the list. These arguments are also evaluated from left to right.</source>
          <target state="translated">在列表上下文中,它只是列表参数分隔符,并将其两个参数都插入到列表中。这些参数也从左到右进行评估。</target>
        </trans-unit>
        <trans-unit id="d53a53afd4d30e8bf9ee4f38d18899b7c7ca7c4f" translate="yes" xml:space="preserve">
          <source>In list context, returns a (possibly empty) list of filename expansions on the value of EXPR such as the standard Unix shell</source>
          <target state="translated">在列表上下文中,返回一个(可能是空的)EXPR值的文件名扩展列表,如标准的Unix shell。</target>
        </trans-unit>
        <trans-unit id="6f4ce95673df56dca54efc694ff26b54d19e3c4c" translate="yes" xml:space="preserve">
          <source>In list context, returns a list consisting of all the values of the named hash. In Perl 5.12 or later only, will also return a list of the values of an array; prior to that release, attempting to use an array argument will produce a syntax error. In scalar context, returns the number of values.</source>
          <target state="translated">在列表上下文中,返回一个由命名的哈希值的所有值组成的列表,在Perl 5.12或更高版本中,也将返回一个数组值的列表;在该版本之前,试图使用数组参数会产生语法错误。仅在Perl 5.12或更高版本中,还将返回一个数组值的列表;在该版本之前,试图使用数组参数将产生语法错误。在标量上下文中,返回值的数量。</target>
        </trans-unit>
        <trans-unit id="7bcc561bb33b529c7d0fa7662daf305595924e45" translate="yes" xml:space="preserve">
          <source>In list context, returns a list value consisting of the elements of LIST in the opposite order. In scalar context, concatenates the elements of LIST and returns a string value with all characters in the opposite order.</source>
          <target state="translated">在list上下文中,返回一个由LIST元素按相反顺序组成的list值。在标量上下文中,将LIST的元素连接起来,并以相反的顺序返回一个包含所有字符的字符串值。</target>
        </trans-unit>
        <trans-unit id="8b48751518b742e90690dec941b028dbd41c2485" translate="yes" xml:space="preserve">
          <source>In list context, returns the value or values deleted, or the last such element in scalar context. The return list's length always matches that of the argument list: deleting non-existent elements returns the undefined value in their corresponding positions.</source>
          <target state="translated">在列表上下文中,返回被删除的值,或者在标量上下文中返回最后一个这样的元素。返回列表的长度总是与参数列表的长度相匹配:删除不存在的元素,返回其相应位置的未定义值。</target>
        </trans-unit>
        <trans-unit id="14dda5a0315cd38b494f1396d6549e05a88ce769" translate="yes" xml:space="preserve">
          <source>In list context, this sorts the LIST and returns the sorted list value. In scalar context, the behaviour of &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; is undefined.</source>
          <target state="translated">在列表上下文中，这对LIST排序并返回排序后的列表值。在标量上下文中， &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 的行为未定义。</target>
        </trans-unit>
        <trans-unit id="c275967193060ed0f99b2fe8baeb485ea49b9b81" translate="yes" xml:space="preserve">
          <source>In list context, this sorts the LIST and returns the sorted list value. In scalar context, the behaviour of &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; is undefined.</source>
          <target state="translated">在列表上下文中，这对LIST排序并返回排序后的列表值。在标量上下文中， &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 的行为未定义。</target>
        </trans-unit>
        <trans-unit id="f04d016b9064bf9bf9d2d6da3b96e6acf6fd1521" translate="yes" xml:space="preserve">
          <source>In literal patterns, the code is parsed at the same time as the surrounding code. While within the pattern, control is passed temporarily back to the perl parser, until the logically-balancing closing brace is encountered. This is similar to the way that an array index expression in a literal string is handled, for example</source>
          <target state="translated">在文字模式中,代码与周围的代码同时被解析。当在模式中时,控制权被暂时传回给perl解析器,直到遇到逻辑平衡的结束括号。这类似于处理字面字符串中的数组索引表达式的方式,如</target>
        </trans-unit>
        <trans-unit id="1a35afb8085f46becc13477af444009e4d377a40" translate="yes" xml:space="preserve">
          <source>In many cases, methods that are used to set the internal state of the object will return the object itself, so method calls can be conveniently chained together.</source>
          <target state="translated">在很多情况下,用于设置对象内部状态的方法会返回对象本身,所以可以方便地将方法调用链在一起。</target>
        </trans-unit>
        <trans-unit id="e9b8eb0a3ccf1ee1e198f508015d1976e62c80e9" translate="yes" xml:space="preserve">
          <source>In many systems the &lt;code&gt;O_EXCL&lt;/code&gt; flag is available for opening files in exclusive mode. This is &lt;b&gt;not&lt;/b&gt; locking: exclusiveness means here that if the file already exists, sysopen() fails. &lt;code&gt;O_EXCL&lt;/code&gt; may not work on network filesystems, and has no effect unless the &lt;code&gt;O_CREAT&lt;/code&gt; flag is set as well. Setting &lt;code&gt;O_CREAT|O_EXCL&lt;/code&gt; prevents the file from being opened if it is a symbolic link. It does not protect against symbolic links in the file's path.</source>
          <target state="translated">在许多系统中， &lt;code&gt;O_EXCL&lt;/code&gt; 标志可用于以独占模式打开文件。这&lt;b&gt;不是&lt;/b&gt;锁定的：排他性意味着如果文件已经存在，则sysopen（）失败。 &lt;code&gt;O_EXCL&lt;/code&gt; 可能不适用于网络文件系统，并且除非也设置了 &lt;code&gt;O_CREAT&lt;/code&gt; 标志，否则它无效。设置 &lt;code&gt;O_CREAT|O_EXCL&lt;/code&gt; 阻止文件打开（如果它是符号链接）。它不能防止文件路径中的符号链接。</target>
        </trans-unit>
        <trans-unit id="8450d241305d74878facdc73fccc0a1c6ea4d3de" translate="yes" xml:space="preserve">
          <source>In module</source>
          <target state="translated">在模块中</target>
        </trans-unit>
        <trans-unit id="286bdc943117014c33efb93a016a5d1869678221" translate="yes" xml:space="preserve">
          <source>In module filtering context, it can be used as Perl version filter.</source>
          <target state="translated">在模块过滤上下文中,它可以作为Perl版本过滤器使用。</target>
        </trans-unit>
        <trans-unit id="a173a70aa245271ccb4f943a053fd8f7539c03d6" translate="yes" xml:space="preserve">
          <source>In more practical terms, the typemap is a collection of code fragments which are used by the &lt;b&gt;xsubpp&lt;/b&gt; compiler to map C function parameters and values to Perl values. The typemap file may consist of three sections labelled &lt;code&gt;TYPEMAP&lt;/code&gt; , &lt;code&gt;INPUT&lt;/code&gt; , and &lt;code&gt;OUTPUT&lt;/code&gt; . An unlabelled initial section is assumed to be a &lt;code&gt;TYPEMAP&lt;/code&gt; section. The INPUT section tells the compiler how to translate Perl values into variables of certain C types. The OUTPUT section tells the compiler how to translate the values from certain C types into values Perl can understand. The TYPEMAP section tells the compiler which of the INPUT and OUTPUT code fragments should be used to map a given C type to a Perl value. The section labels &lt;code&gt;TYPEMAP&lt;/code&gt; , &lt;code&gt;INPUT&lt;/code&gt; , or &lt;code&gt;OUTPUT&lt;/code&gt; must begin in the first column on a line by themselves, and must be in uppercase.</source>
          <target state="translated">实际上，类型映射是&lt;b&gt;xsubpp&lt;/b&gt;编译器用来将C函数参数和值映射到Perl值的代码片段的集合。类型映射文件可以包括三个部分，分别标记为 &lt;code&gt;TYPEMAP&lt;/code&gt; ， &lt;code&gt;INPUT&lt;/code&gt; 和 &lt;code&gt;OUTPUT&lt;/code&gt; 。假定未标记的初始节是 &lt;code&gt;TYPEMAP&lt;/code&gt; 节。 INPUT部分告诉编译器如何将Perl值转换为某些C类型的变量。 OUTPUT部分告诉编译器如何将某些C类型的值转换为Perl可以理解的值。 TYPEMAP部分告诉编译器应使用INPUT和OUTPUT代码片段中的哪一个将给定的C类型映射到Perl值。部分标签为 &lt;code&gt;TYPEMAP&lt;/code&gt; ， &lt;code&gt;INPUT&lt;/code&gt; 或 &lt;code&gt;OUTPUT&lt;/code&gt; 必须单独在一行的第一列中开始，并且必须大写。</target>
        </trans-unit>
        <trans-unit id="428ffc575a57b1bff79640b48a60fb8f688d9deb" translate="yes" xml:space="preserve">
          <source>In most cases people have reported better results with GNU make rather than the system's /bin/make program, whether for plain modules or for xs based extensions.</source>
          <target state="translated">在大多数情况下,人们报告说使用GNU make比使用系统的/bin/make程序效果更好,无论是普通模块还是基于xs的扩展。</target>
        </trans-unit>
        <trans-unit id="f5afec4e8618986f557789f84e21b385879c2564" translate="yes" xml:space="preserve">
          <source>In most cases you want to make sure that the $io_handle is in &quot;binmode&quot; before you pass it as argument to the addfile() method.</source>
          <target state="translated">在大多数情况下,你希望在将$io_handle作为参数传递给addfile()方法之前,确保它处于 &quot;binmode &quot;状态。</target>
        </trans-unit>
        <trans-unit id="c59025c8c8f5462c9fb0d9eec8118a96c3e872c2" translate="yes" xml:space="preserve">
          <source>In most cases you want to make sure that the $io_handle is in &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before you pass it as argument to the addfile() method.</source>
          <target state="translated">在大多数情况下，您需要先确保$ io_handle处于 &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; ,然后再将其作为参数传递给addfile（）方法。</target>
        </trans-unit>
        <trans-unit id="525f40bb529483f51193d29f821ebe7da0a52cf3" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; is implemented via the undocumented system service &lt;code&gt;$SIGPRC&lt;/code&gt; , which has the same calling sequence as &lt;code&gt;$FORCEX&lt;/code&gt; , but throws an exception in the target process rather than forcing it to call &lt;code&gt;$EXIT&lt;/code&gt; . Generally speaking, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; follows the behavior of the CRTL's &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; function, but unlike that function can be called from within a signal handler. Also, unlike the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; in some versions of the CRTL, Perl's &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; checks the validity of the signal passed in and returns an error rather than attempting to send an unrecognized signal.</source>
          <target state="translated">在大多数情况下， &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 是通过未记录的系统服务 &lt;code&gt;$SIGPRC&lt;/code&gt; 来实现的，该服务具有与 &lt;code&gt;$FORCEX&lt;/code&gt; 相同的调用顺序，但是会在目标进程中引发异常，而不是强制其调用 &lt;code&gt;$EXIT&lt;/code&gt; 。一般来说， &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 遵循CRTL的 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; 函数的行为，但是与之不同的是，可以从信号处理程序中调用该函数。此外，不像 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 在CRTL的某些版本中，Perl的 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 信号的检查有效性，并返回一个错误传递，而不是试图发送一个无法识别的信号。</target>
        </trans-unit>
        <trans-unit id="eede988897716aa1422cf3adeb53444b2cab13f0" translate="yes" xml:space="preserve">
          <source>In most cases, it is probably easier to simply use string concatenation, which also forces scalar context.</source>
          <target state="translated">在大多数情况下,可能更容易简单地使用字符串连接,这也迫使标量上下文。</target>
        </trans-unit>
        <trans-unit id="ace8b1ddef61865f0aa48c02a6d220e56f6740dd" translate="yes" xml:space="preserve">
          <source>In most cases, patches to modules in</source>
          <target state="translated">在大多数情况下,模块的补丁在</target>
        </trans-unit>
        <trans-unit id="3d608639121073b361e23e425be9ba9c84646ab9" translate="yes" xml:space="preserve">
          <source>In most cases, you can just run it interactively from a command line without any special arguments and follow the prompts.</source>
          <target state="translated">在大多数情况下,你可以直接从命令行交互式运行,不需要任何特殊的参数,按照提示进行操作。</target>
        </trans-unit>
        <trans-unit id="2f1846566ce8422fbda676e86cc15846d05061a2" translate="yes" xml:space="preserve">
          <source>In most cases, you should probably round the results explicitly using one of &lt;a href=&quot;#round()&quot;&gt;round()&lt;/a&gt;, &lt;a href=&quot;#bround()&quot;&gt;bround()&lt;/a&gt; or &lt;a href=&quot;#bfround()&quot;&gt;bfround()&lt;/a&gt; or by passing the desired accuracy to the math operation as additional parameter:</source>
          <target state="translated">在大多数情况下，你应该轮结果明确使用的一个&lt;a href=&quot;#round()&quot;&gt;圆（） &lt;/a&gt;，&lt;a href=&quot;#bround()&quot;&gt;bround（）&lt;/a&gt;或&lt;a href=&quot;#bfround()&quot;&gt;bfround（）&lt;/a&gt;或将所需的精度数学运算的附加参数：</target>
        </trans-unit>
        <trans-unit id="fbf91aec7f60195ab2e4c16d72de4bd0b0dad318" translate="yes" xml:space="preserve">
          <source>In most cases, you should probably round the results explicitly using one of &lt;a href=&quot;bigint#round()&quot;&gt;round() in Math::BigInt&lt;/a&gt;, &lt;a href=&quot;bigint#bround()&quot;&gt;bround() in Math::BigInt&lt;/a&gt; or &lt;a href=&quot;bigint#bfround()&quot;&gt;bfround() in Math::BigInt&lt;/a&gt; or by passing the desired accuracy to the math operation as additional parameter:</source>
          <target state="translated">在大多数情况下，你应该轮结果明确使用的一个&lt;a href=&quot;bigint#round()&quot;&gt;圆（）数学:: BigInt有&lt;/a&gt;，&lt;a href=&quot;bigint#bround()&quot;&gt;bround（）数学:: BigInt有&lt;/a&gt;或&lt;a href=&quot;bigint#bfround()&quot;&gt;数学:: BigInt有bfround（）&lt;/a&gt;或将所需精度的数学运算作为附加参数：</target>
        </trans-unit>
        <trans-unit id="a42b298f707283d45326f409618401d12bc90d6e" translate="yes" xml:space="preserve">
          <source>In most cases, you write an external module to do it--see the answer to &quot;Where can I learn about linking C with Perl? [h2xs, xsubpp]&quot;. However, if the function is a system call, and your system supports &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall()&lt;/a&gt;&lt;/code&gt;, you can use the &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; function (documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;).</source>
          <target state="translated">在大多数情况下，您可以编写一个外部模块来执行此操作-请参阅&amp;ldquo;我在哪里可以了解如何将C与Perl链接？[h2xs，xsubpp]&amp;rdquo;的答案。但是，如果该函数是系统调用，并且您的系统支持 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall()&lt;/a&gt;&lt;/code&gt; ，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 函数（在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中记录&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d19f51a558abe46dfdc218b96bc734b3c276b079" translate="yes" xml:space="preserve">
          <source>In most operating systems, lines in files are terminated by newlines. Just what is used as a newline may vary from OS to OS. Unix traditionally uses &lt;code&gt;\012&lt;/code&gt; , one type of DOSish I/O uses &lt;code&gt;\015\012&lt;/code&gt; , Mac OS uses &lt;code&gt;\015&lt;/code&gt; , and z/OS uses &lt;code&gt;\025&lt;/code&gt; .</source>
          <target state="translated">在大多数操作系统中，文件中的行以换行符终止。用作换行符的内容可能因操作系统而异。Unix传统上使用 &lt;code&gt;\012&lt;/code&gt; ，一种类型的DOSish I / O使用 &lt;code&gt;\015\012&lt;/code&gt; ，Mac OS使用 &lt;code&gt;\015&lt;/code&gt; ，而z / OS使用 &lt;code&gt;\025&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59c4293bfbaf72968d51c71aab642ca2822c9579" translate="yes" xml:space="preserve">
          <source>In multithreaded scripts Perl coordinates the threads so that any thread may modify its copy of the &lt;code&gt;$0&lt;/code&gt; and the change becomes visible to ps(1) (assuming the operating system plays along). Note that the view of &lt;code&gt;$0&lt;/code&gt; the other threads have will not change since they have their own copies of it.</source>
          <target state="translated">在多线程脚本中，Perl协调线程，以便任何线程都可以修改其 &lt;code&gt;$0&lt;/code&gt; 副本，并且更改对ps（1）可见（假定操作系统在运行）。请注意，其他线程具有的 &lt;code&gt;$0&lt;/code&gt; 视图将不会更改，因为它们具有自己的副本。</target>
        </trans-unit>
        <trans-unit id="2ff5aa25fe59ffebaa3d9b983e6ed41dcfbb4c10" translate="yes" xml:space="preserve">
          <source>In networking, a &lt;b&gt;process&lt;/b&gt; that either advertises a &lt;b&gt;service&lt;/b&gt; or just hangs around at a known location and waits for &lt;b&gt;clients&lt;/b&gt; who need service to get in touch with it.</source>
          <target state="translated">在网络中，一个&lt;b&gt;过程&lt;/b&gt;，要么通告&lt;b&gt;服务&lt;/b&gt;的或在已知位置周围只是挂起并等待&lt;b&gt;客户&lt;/b&gt;谁需要服务与它取得联系。</target>
        </trans-unit>
        <trans-unit id="fe020f31c58d30517974e8b54ebe9cc4a8fb1397" translate="yes" xml:space="preserve">
          <source>In networking, a &lt;b&gt;process&lt;/b&gt; that initiates contact with a &lt;b&gt;server&lt;/b&gt; process in order to exchange data and perhaps receive a service.</source>
          <target state="translated">在网络中，一个&lt;b&gt;过程&lt;/b&gt;与发起接触&lt;b&gt;服务器&lt;/b&gt;进程，以便进行数据交换，也许接收服务。</target>
        </trans-unit>
        <trans-unit id="b7faa009c2918d4804b660feca8b23ad35925a6e" translate="yes" xml:space="preserve">
          <source>In networking, an agreed-upon way of sending messages back and forth so that neither correspondent will get too confused.</source>
          <target state="translated">在网络中,一种约定俗成的来回发送消息的方式,使通信者都不会太混乱。</target>
        </trans-unit>
        <trans-unit id="71b3fd1615492dc9bf230d9f033afbf83da86082" translate="yes" xml:space="preserve">
          <source>In normal &amp;ldquo;computerese&amp;rdquo;, the piece of data of the size most efficiently handled by your computer, typically 32 bits or so, give or take a few powers of 2. In Perl culture, it more often refers to an alphanumeric &lt;b&gt;identifier&lt;/b&gt; (including underscores), or to a string of nonwhitespace &lt;b&gt;characters&lt;/b&gt; bounded by whitespace or string boundaries.</source>
          <target state="translated">在普通的&amp;ldquo;计算机&amp;rdquo;中，由计算机最有效地处理的大小的数据（通常为32位左右）赋予或取2的幂。在Perl文化中，它通常是指字母数字&lt;b&gt;标识符&lt;/b&gt;（包括下划线） ），或者对非空白的字符串&lt;b&gt;的字符&lt;/b&gt;由空格或字符串边界限定。</target>
        </trans-unit>
        <trans-unit id="2b1437a6901ce1f87cee7f4d6385fbba76b51c73" translate="yes" xml:space="preserve">
          <source>In object-oriented code, we often find that one object references another object. This is called &lt;b&gt;composition&lt;/b&gt;, or a &lt;b&gt;has-a&lt;/b&gt; relationship.</source>
          <target state="translated">在面向对象的代码中，我们经常发现一个对象引用了另一个对象。这称为&amp;ldquo; &lt;b&gt;组合&lt;/b&gt; &amp;rdquo;或&amp;ldquo; &lt;b&gt;具有&amp;rdquo;&lt;/b&gt;关系。</target>
        </trans-unit>
        <trans-unit id="0840885f4ae0e15a9e1a64e6e2f2e63bb6055bf6" translate="yes" xml:space="preserve">
          <source>In olden days, the act of looking up a &lt;b&gt;key&lt;/b&gt; in an actual index (such as a phone book). But now it's merely the act of using any kind of key or position to find the corresponding &lt;b&gt;value&lt;/b&gt;, even if no index is involved. Things have degenerated to the point that Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; function merely locates the position (index) of one string in another.</source>
          <target state="translated">在过去，这是在实际索引（例如电话簿）中查找&lt;b&gt;键&lt;/b&gt;的行为。但是现在，即使不涉及索引，也只是使用任何键或位置来查找对应&lt;b&gt;值&lt;/b&gt;的行为。事情变得如此糟糕，以至于Perl的 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 函数仅将一个字符串在另一个字符串中的位置（索引）定位。</target>
        </trans-unit>
        <trans-unit id="8954164487b10a1a06bdaedbfbaa22faf258c328" translate="yes" xml:space="preserve">
          <source>In older Unicode versions, a small number of characters (all of which are CJK compatibility ideographs as far as they have been found) may have an erroneous decomposition mapping (see</source>
          <target state="translated">在旧的Unicode版本中,有一小部分字符(就目前发现的所有字符都是中日韩兼容表意文字)可能会有错误的分解映射(见</target>
        </trans-unit>
        <trans-unit id="25564a5fe1398dbc91939b7e3cb0a5bccfb1e2c1" translate="yes" xml:space="preserve">
          <source>In one sense, what you are asking doesn't make much sense: encodings are for characters, and binary data are not &quot;characters&quot;, so converting &quot;data&quot; into some encoding isn't meaningful unless you know in what character set and encoding the binary data is in, in which case it's not just binary data, now is it?</source>
          <target state="translated">从某种意义上说,你的要求并没有什么意义:编码是针对字符的,而二进制数据并不是 &quot;字符&quot;,所以把 &quot;数据 &quot;转换成某种编码并没有什么意义,除非你知道二进制数据是用什么字符集和编码的,在这种情况下,它就不仅仅是二进制数据了吧?</target>
        </trans-unit>
        <trans-unit id="0665aadb9203e48ab11fdbdc61f426bdf069c8ef" translate="yes" xml:space="preserve">
          <source>In one's own MANIFEST.SKIP file, certain directives can be used to include the contents of other MANIFEST.SKIP files. At present two such directives are recognized.</source>
          <target state="translated">在自己的MANIFEST.SKIP文件中,可以使用某些指令来包含其他MANIFEST.SKIP文件的内容。目前,有两个这样的指令被认可。</target>
        </trans-unit>
        <trans-unit id="775d518fe37c14b3f79041d34b5efaca033dd3ab" translate="yes" xml:space="preserve">
          <source>In one-liner form:</source>
          <target state="translated">以单行本的形式。</target>
        </trans-unit>
        <trans-unit id="3a599813be17001915e0601602237bd798d15d3b" translate="yes" xml:space="preserve">
          <source>In one-shot mode this flag will be set to true if the Perl &lt;code&gt;-T&lt;/code&gt; operator thinks the file contains text.</source>
          <target state="translated">在单发模式下，如果Perl &lt;code&gt;-T&lt;/code&gt; 运算符认为该文件包含文本，则此标志将设置为true 。</target>
        </trans-unit>
        <trans-unit id="0a387689b89f7b0ad51aa990a4b2c214ffa94375" translate="yes" xml:space="preserve">
          <source>In order for object method lookup and/or prototype checking to operate correctly even when methods have not yet been defined it is necessary to &quot;forward declare&quot; each subroutine (as in &lt;code&gt;sub NAME;&lt;/code&gt; ). See &lt;a href=&quot;perlsub#SYNOPSIS&quot;&gt;SYNOPSIS in perlsub&lt;/a&gt;. Such forward declaration creates &quot;subroutine stubs&quot;, which are place holders with no code.</source>
          <target state="translated">为了使对象方法查找和/或原型检查即使在尚未定义方法的情况下也能正确运行，有必要&amp;ldquo;转发声明&amp;rdquo;每个子例程（如 &lt;code&gt;sub NAME;&lt;/code&gt; 中所示）。请参见&lt;a href=&quot;perlsub#SYNOPSIS&quot;&gt;perlsub中的提要&lt;/a&gt;。这种前向声明会创建&amp;ldquo;子例程存根&amp;rdquo;，它们是没有代码的占位符。</target>
        </trans-unit>
        <trans-unit id="f0241ec9af4c551ca21dc35ad3b6791e44a33543" translate="yes" xml:space="preserve">
          <source>In order to allow for multiple big integer libraries, Math::BigInt was rewritten to use a plug-in library for core math routines. Any module which conforms to the API can be used by Math::BigInt by using this in your program:</source>
          <target state="translated">为了允许多个大整数库,Math::BigInt被重写为使用一个核心数学例程的插件库。任何符合API的模块都可以通过在程序中使用这个模块被Math::BigInt使用。</target>
        </trans-unit>
        <trans-unit id="db68f3a19f1d4b1da9de666e4465352494a86e3b" translate="yes" xml:space="preserve">
          <source>In order to allow for multiple big integer libraries, Math::BigInt was rewritten to use library modules for core math routines. Any module which follows the same API as this can be used instead by using the following:</source>
          <target state="translated">为了允许使用多个大整数库,Math::BigInt被重写为使用库模块作为核心数学例程。任何遵循与此相同的API的模块都可以通过使用以下方式来代替。</target>
        </trans-unit>
        <trans-unit id="79f9d107daff2d5afbf356c8809d8a77ed4fb993" translate="yes" xml:space="preserve">
          <source>In order to build your own version of Perl you will need 'make', which is part of Apple's developer tools - also known as Xcode. From Mac OS X 10.7 &quot;Lion&quot; onwards, it can be downloaded separately as the 'Command Line Tools' bundle directly from &lt;a href=&quot;https://developer.apple.com/downloads/&quot;&gt;https://developer.apple.com/downloads/&lt;/a&gt; (you will need a free account to log in), or as a part of the Xcode suite, freely available at the App Store. Xcode is a pretty big app, so unless you already have it or really want it, you are advised to get the 'Command Line Tools' bundle separately from the link above. If you want to do it from within Xcode, go to Xcode -&amp;gt; Preferences -&amp;gt; Downloads and select the 'Command Line Tools' option.</source>
          <target state="translated">为了构建自己的Perl版本，您将需要&amp;ldquo; make&amp;rdquo;，这是Apple开发人员工具的一部分-也称为Xcode。从Mac OS X 10.7&amp;ldquo; Lion&amp;rdquo;开始，可以直接从&lt;a href=&quot;https://developer.apple.com/downloads/&quot;&gt;https://developer.apple.com/downloads/&lt;/a&gt;（作为一个命令行工具）捆绑包单独下载（您将需要一个免费帐户登录），或者作为Xcode套件的一部分，可在App Store免费获得。 Xcode是一个非常大的应用程序，因此，除非您已经拥有或真的想要它，否则建议您从上面的链接单独获得&amp;ldquo;命令行工具&amp;rdquo;捆绑包。如果要在Xcode中执行此操作，请转到Xcode-&amp;gt;&amp;ldquo;首选项&amp;rdquo;-&amp;gt;&amp;ldquo;下载&amp;rdquo;，然后选择&amp;ldquo;命令行工具&amp;rdquo;选项。</target>
        </trans-unit>
        <trans-unit id="a93cd8781d8e041e8355a0aefc4276597d7a98e8" translate="yes" xml:space="preserve">
          <source>In order to convert a string of characters from one character set to another a simple list of numbers, such as in the right columns in the above table, along with Perl's &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; operator is all that is needed. The data in the table are in ASCII/Latin1 order, hence the EBCDIC columns provide easy-to-use ASCII/Latin1 to EBCDIC operations that are also easily reversed.</source>
          <target state="translated">为了将字符串从一个字符集转换为另一个字符，只需一个简单的数字列表（例如上表的右列）以及Perl的 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 运算符。表中的数据按ASCII / Latin1顺序排列，因此EBCDIC列提供了易于使用的ASCII / Latin1到EBCDIC操作，这些操作也很容易反转。</target>
        </trans-unit>
        <trans-unit id="2f5fa67b20e8cfe8e347f59bf69babb07bc272aa" translate="yes" xml:space="preserve">
          <source>In order to install a new regexp handler, &lt;code&gt;$^H{regcomp}&lt;/code&gt; is set to an integer which (when casted appropriately) resolves to one of these structures. When compiling, the &lt;code&gt;comp&lt;/code&gt; method is executed, and the resulting &lt;code&gt;regexp&lt;/code&gt; structure's engine field is expected to point back at the same structure.</source>
          <target state="translated">为了安装新的regexp处理程序，将 &lt;code&gt;$^H{regcomp}&lt;/code&gt; 设置为一个整数（在正确转换时）解析为这些结构之一。编译时，将执行 &lt;code&gt;comp&lt;/code&gt; 方法，并且预期得到的 &lt;code&gt;regexp&lt;/code&gt; 结构的engine字段将指向同一结构。</target>
        </trans-unit>
        <trans-unit id="437d80cea54e562ec941100e6a72df58383866f9" translate="yes" xml:space="preserve">
          <source>In order to keep lib.pm small and simple, it only works with Unix filepaths. This doesn't mean it only works on Unix, but non-Unix users must first translate their file paths to Unix conventions.</source>
          <target state="translated">为了保持lib.pm的小巧和简单,它只适用于Unix文件路径。这并不意味着它只能在Unix上工作,但非Unix用户必须首先将他们的文件路径翻译成Unix惯例。</target>
        </trans-unit>
        <trans-unit id="364bb5f6d99dcae74466742fdf303cf213f25184" translate="yes" xml:space="preserve">
          <source>In order to maintain maximum compatibility with earlier versions of Perl, this function will return either the floating point notation or the multiple dotted notation, depending on whether the original version contained 1 or more dots, respectively.</source>
          <target state="translated">为了最大限度地保持与早期版本的Perl的兼容性,该函数将根据原始版本是否包含1个或多个点,分别返回浮点符号或多点符号。</target>
        </trans-unit>
        <trans-unit id="381ea4e1bb108f2a93fb8d7c5edae34da5e15c66" translate="yes" xml:space="preserve">
          <source>In order to maintain portability of attributes with older versions of MakeMaker you may want to use &lt;a href=&quot;http://search.cpan.org/perldoc/App::EUMM::Upgrade&quot;&gt;App::EUMM::Upgrade&lt;/a&gt; with your &lt;code&gt;Makefile.PL&lt;/code&gt; .</source>
          <target state="translated">为了保持属性与旧版本的MakeMaker的可移植性，您可能需要将&lt;a href=&quot;http://search.cpan.org/perldoc/App::EUMM::Upgrade&quot;&gt;App :: EUMM :: Upgrade&lt;/a&gt;与 &lt;code&gt;Makefile.PL&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="9248f937d9955a6043a592d635bc82f1867f0186" translate="yes" xml:space="preserve">
          <source>In order to make RECNO more compatible with Perl, the array offset for all RECNO arrays begins at 0 rather than 1 as in Berkeley DB.</source>
          <target state="translated">为了使RECNO与Perl更加兼容,所有RECNO数组的数组偏移量从0开始,而不是像Berkeley DB那样从1开始。</target>
        </trans-unit>
        <trans-unit id="c8f50d2afd74c2c616567dbb29c3d95a6bbbba68" translate="yes" xml:space="preserve">
          <source>In order to make it impossible to know what seed to generate an attack key set for, this seed is randomly initialized at process start. This may be overridden by using the PERL_HASH_SEED environment variable, see &lt;a href=&quot;perlrun#PERL_HASH_SEED&quot;&gt;PERL_HASH_SEED in perlrun&lt;/a&gt;. This environment variable controls how items are actually stored, not how they are presented via &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">为了使无法知道要为其生成攻击密钥集的种子，该种子在过程开始时被随机初始化。这可以通过使用PERL_HASH_SEED环境变量来覆盖，请参见&lt;a href=&quot;perlrun#PERL_HASH_SEED&quot;&gt;perlrun中的PERL_HASH_SEED&lt;/a&gt;。此环境变量控制项目的实际存储方式，而不是如何通过 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 来显示项目。</target>
        </trans-unit>
        <trans-unit id="e1eda6692f2f4e28d3303c1b91852403d3cf17be" translate="yes" xml:space="preserve">
          <source>In order to make sense of Maketext and how all its components fit together, you should probably go read &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;, and</source>
          <target state="translated">为了理解Maketext及其所有组件如何组合在一起，您可能应该阅读&lt;a href=&quot;maketext/tpj13&quot;&gt;Locale :: Maketext :: TPJ13&lt;/a&gt;和</target>
        </trans-unit>
        <trans-unit id="5ff6fc777d96f10921d74c27d5ed5e70b4334507" translate="yes" xml:space="preserve">
          <source>In order to make use of the rot13 filter we need some way of encoding the source file in rot13 format. The script below, &lt;code&gt;mkrot13&lt;/code&gt; , does just that.</source>
          <target state="translated">为了使用rot13过滤器，我们需要某种方式以rot13格式编码源文件。下面的脚本 &lt;code&gt;mkrot13&lt;/code&gt; 就是这样做的。</target>
        </trans-unit>
        <trans-unit id="21d2fc600dcdd5c6cb297e557194c37b7f0f485a" translate="yes" xml:space="preserve">
          <source>In order to preserve backward compatibility, Perl does not turn on full internal Unicode support unless the pragma &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;use feature 'unicode_strings' &lt;/a&gt; is specified. (This is automatically selected if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher.) Failure to do this can trigger unexpected surprises. See &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt; below.</source>
          <target state="translated">为了保持向后兼容性，除非指定了编译指示&lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;使用功能'unicode_strings'，&lt;/a&gt;否则Perl不会打开对内部Unicode的完全支持。（如果 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 或更高版本，则将自动选择它。）否则可能会引发意外的意外。请参阅&lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;下面的Unicode错误&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd47550c4a48b602de1804d810fabdd19f1a7062" translate="yes" xml:space="preserve">
          <source>In order to process interior sequences, subclasses implementations of this method will probably want to invoke either &lt;b&gt;interpolate()&lt;/b&gt; or &lt;b&gt;parse_text()&lt;/b&gt;, passing it the text block &lt;code&gt;$text&lt;/code&gt; , and the corresponding line number in &lt;code&gt;$line_num&lt;/code&gt; , and then perform any desired processing upon the returned result.</source>
          <target state="translated">为了处理内部序列，此方法的子类实现可能需要调用&lt;b&gt;interpolate（）&lt;/b&gt;或&lt;b&gt;parse_text（）&lt;/b&gt;，&lt;b&gt;向其&lt;/b&gt;传递文本块 &lt;code&gt;$text&lt;/code&gt; ，并在 &lt;code&gt;$line_num&lt;/code&gt; 传递相应的行号，然后根据需要执行任何所需的处理。返回的结果。</target>
        </trans-unit>
        <trans-unit id="96a9bbcaad8032f3708be9f9aad29a52e4a152b3" translate="yes" xml:space="preserve">
          <source>In order to test that our extension works, we now need to look at the file Mytest.t. This file is set up to imitate the same kind of testing structure that Perl itself has. Within the test script, you perform a number of tests to confirm the behavior of the extension, printing &quot;ok&quot; when the test is correct, &quot;not ok&quot; when it is not.</source>
          <target state="translated">为了测试我们的扩展名是否工作,我们现在需要查看 Mytest.t 文件。这个文件的设置是为了模仿 Perl 本身的测试结构。在测试脚本中,你会执行一些测试来确认扩展的行为,当测试正确时打印 &quot;ok&quot;,当不正确时打印 &quot;not ok&quot;。</target>
        </trans-unit>
        <trans-unit id="e8108d3bcd39eeb2141d68d5707c2daf6f01568e" translate="yes" xml:space="preserve">
          <source>In order to understand Perl objects, you first need to understand references in Perl. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for details.</source>
          <target state="translated">为了了解Perl对象，您首先需要了解Perl中的引用。有关详细信息，请参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="769d36508232140bd94018f22812d43183fa9db1" translate="yes" xml:space="preserve">
          <source>In order to use &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD subroutine you</source>
          <target state="translated">为了使用&lt;b&gt;AutoLoader&lt;/b&gt;的AUTOLOAD子例程，您需要</target>
        </trans-unit>
        <trans-unit id="af99082b46921b802ae95263001ef07cb7aa2040" translate="yes" xml:space="preserve">
          <source>In ordinary paragraphs and in some command paragraphs, various formatting codes (a.k.a. &quot;interior sequences&quot;) can be used:</source>
          <target state="translated">在普通段落和一些命令段落中,可以使用各种格式代码(也就是 &quot;内部序列&quot;)。</target>
        </trans-unit>
        <trans-unit id="de5a0be2abf85a22324ace726b3f113f3ddb049b" translate="yes" xml:space="preserve">
          <source>In other boolean contexts, &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; without an explicit &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; test or comparison elicits a warning if the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; command-line switch (the &lt;code&gt;$^W&lt;/code&gt; variable) is in effect.</source>
          <target state="translated">在其他布尔上下文中，如果 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 警告用法编译指示或&lt;b&gt;-w&lt;/b&gt;命令行开关（ &lt;code&gt;$^W&lt;/code&gt; 变量）有效，则没有明确 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 测试或比较的 &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; 引发警告。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="633c40ae3272eb641ed90a2b64f933bcfc1ab4fa" translate="yes" xml:space="preserve">
          <source>In other cases, the patch will need more work or discussion. That will happen on the p5p list.</source>
          <target state="translated">在其他情况下,补丁将需要更多的工作或讨论。这将发生在p5p列表中。</target>
        </trans-unit>
        <trans-unit id="7b3796099c87e59fc24644465a4e8f63a8bac8d4" translate="yes" xml:space="preserve">
          <source>In other files which wish to use &lt;code&gt;YourModule&lt;/code&gt; :</source>
          <target state="translated">在其他希望使用 &lt;code&gt;YourModule&lt;/code&gt; 的文件中：</target>
        </trans-unit>
        <trans-unit id="3b8bb595443598bbfebd43734b72b246e5109db8" translate="yes" xml:space="preserve">
          <source>In other files which wish to use your module there are three basic ways for them to load your module and import its symbols:</source>
          <target state="translated">在其他希望使用您的模块的文件中,有三种基本的方法来加载您的模块并导入它的符号。</target>
        </trans-unit>
        <trans-unit id="dac5b44cbcccec7c46874f1c0dae34c3e4179f83" translate="yes" xml:space="preserve">
          <source>In other words, a call to &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; resumes the depth-first, left-to-right search of &lt;code&gt;$self&lt;/code&gt; 's class hierarchy that resulted in the original call to &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">换句话说，对 &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; 的调用将恢复对 &lt;code&gt;$self&lt;/code&gt; 的类层次结构的深度优先，从左到右的搜索，从而导致对 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 的原始调用。</target>
        </trans-unit>
        <trans-unit id="4828bb0cda42f406a7ca05570f3e0910c8f19571" translate="yes" xml:space="preserve">
          <source>In other words, each type of bracket specified as a delimiter must be balanced and correctly nested within the substring, and any other kind of (&quot;non-delimiter&quot;) bracket in the substring is ignored.</source>
          <target state="translated">换句话说,每一种指定为定界符的括号都必须平衡,并正确地嵌套在子串中,子串中的任何其他类型的(&quot;非定界符&quot;)括号将被忽略。</target>
        </trans-unit>
        <trans-unit id="74fd5671e652ca312e8092bc1ce538f5b223a43a" translate="yes" xml:space="preserve">
          <source>In other words, if you try this:</source>
          <target state="translated">换句话说,如果你试试这个。</target>
        </trans-unit>
        <trans-unit id="877ca893c0d0ee5563d6603bca839b1fc7617192" translate="yes" xml:space="preserve">
          <source>In other words, implicate_supers_strictly takes a list of strings (which are presumed to be language-tags; strings that aren't, are ignored) and after the whole given list, it inserts the super-ordinate forms of all given tags, minus any tags that already appear in the input list.</source>
          <target state="translated">换句话说,implicate_supers_strictly接受一个字符串列表(假定这些字符串是语言标记,不是语言标记的字符串,则被忽略),在整个给定列表之后,它插入所有给定标记的上位形式,减去已经出现在输入列表中的任何标记。</target>
        </trans-unit>
        <trans-unit id="25d319aebdebcd5625f4059cfe98447477589bac" translate="yes" xml:space="preserve">
          <source>In other words, in the &quot;C&quot; (or English) locale the above will probably print something like:</source>
          <target state="translated">换句话说,在 &quot;C&quot;(或英文)地区,上面的内容可能会被打印成这样。</target>
        </trans-unit>
        <trans-unit id="550ff39ed161b9edd0e84b02fed3dec9d30c2e67" translate="yes" xml:space="preserve">
          <source>In other words, it does not check the full recursion stack.</source>
          <target state="translated">换句话说,它不检查完整的递归栈。</target>
        </trans-unit>
        <trans-unit id="e0fc4bff9ab6a124fdea1a036cef443002eab13f" translate="yes" xml:space="preserve">
          <source>In other words, it takes this:</source>
          <target state="translated">换句话说,它需要这个。</target>
        </trans-unit>
        <trans-unit id="9c65668195992fe68f06679feb8eacf4cd2f8800" translate="yes" xml:space="preserve">
          <source>In other words, it's the character whose code point has had 64 xor'd with its uppercase. &lt;code&gt;\c?&lt;/code&gt; is DELETE on ASCII platforms because &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;?&quot;) ^ 64&lt;/code&gt; is 127, and &lt;code&gt;\c@&lt;/code&gt; is NULL because the ord of &lt;code&gt;&quot;@&quot;&lt;/code&gt; is 64, so xor'ing 64 itself produces 0.</source>
          <target state="translated">换句话说，它是其代码点的大写字符已与64异或的字符。 &lt;code&gt;\c?&lt;/code&gt; 在ASCII平台上为DELETE，因为 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;?&quot;) ^ 64&lt;/code&gt; 为127，而 &lt;code&gt;\c@&lt;/code&gt; 为NULL，因为 &lt;code&gt;&quot;@&quot;&lt;/code&gt; 的ord 为64，因此xor'ing 64本身产生0。</target>
        </trans-unit>
        <trans-unit id="2b7ead3432ce6ef0a214c631da3fb65f28ad59d4" translate="yes" xml:space="preserve">
          <source>In other words, it's the projection of the vector onto the</source>
          <target state="translated">换句话说,它是矢量在上的投影。</target>
        </trans-unit>
        <trans-unit id="173982625284de4ecdaf57b42d11dd41503a3a62" translate="yes" xml:space="preserve">
          <source>In other words, once the &lt;code&gt;(*COMMIT)&lt;/code&gt; has been entered, and if the pattern does not match, the regex engine will not try any further matching on the rest of the string.</source>
          <target state="translated">换句话说，一旦输入 &lt;code&gt;(*COMMIT)&lt;/code&gt; ，并且如果模式不匹配，则正则表达式引擎将不会在字符串的其余部分尝试任何进一步的匹配。</target>
        </trans-unit>
        <trans-unit id="080def995649dc7c78c927509a6265da0f050d82" translate="yes" xml:space="preserve">
          <source>In other words, text outside bracket groups is turned into string literals. Text in brackets is rather more complex, and currently follows these rules:</source>
          <target state="translated">换句话说,括号组之外的文本会被转化为字符串字面。括号内的文字比较复杂,目前遵循这些规则。</target>
        </trans-unit>
        <trans-unit id="f68e3679fc5753d52f8311d0156c23ac089d43c6" translate="yes" xml:space="preserve">
          <source>In other words, the Pod processing handler for &quot;head1&quot; will apply the same processing to &quot;Did You Remember to C&amp;lt;use strict;&amp;gt;?&quot; that it would to an ordinary paragraph (i.e., formatting codes like &quot;C&amp;lt;...&amp;gt;&quot;) are parsed and presumably formatted appropriately, and whitespace in the form of literal spaces and/or tabs is not significant.</source>
          <target state="translated">换句话说，&amp;ldquo; head1&amp;rdquo;的Pod处理处理程序将对&amp;ldquo;您是否还记得C &amp;lt;use strict;&amp;gt;？&amp;rdquo;进行了相同的处理。它将解析为普通段落（即，诸如&amp;ldquo; C &amp;lt;...&amp;gt;&amp;rdquo;之类的格式代码）并可能对其进行了适当的格式化，而文字空间和/或制表符形式的空格并不重要。</target>
        </trans-unit>
        <trans-unit id="d0443748797b84576038c7f78a4ac322e4d4dc07" translate="yes" xml:space="preserve">
          <source>In other words, the author of a module should be considered to have final say on modifications to their module whenever possible (bearing in mind that it's expected that everyone involved will work together and arrive at reasonable compromises when there are disagreements).</source>
          <target state="translated">换句话说,在可能的情况下,应认为模块的作者对其模块的修改有最终的决定权(要记住,在有分歧的情况下,希望每个人都能共同合作,达成合理的妥协)。</target>
        </trans-unit>
        <trans-unit id="585a94d48c61cb81b39fc84dfe81f19ca97413b7" translate="yes" xml:space="preserve">
          <source>In other words, the implementation of &lt;code&gt;extract_tagged&lt;/code&gt; is exactly equivalent to:</source>
          <target state="translated">换句话说， &lt;code&gt;extract_tagged&lt;/code&gt; 的实现完全等同于：</target>
        </trans-unit>
        <trans-unit id="6437ac2d46829a1156ddedffd3475d352ba0e256" translate="yes" xml:space="preserve">
          <source>In other words, the previous example, would become:</source>
          <target state="translated">换句话说,前面的例子,会变成。</target>
        </trans-unit>
        <trans-unit id="bb35ba757de61444a9e16187e2167074637a80ae" translate="yes" xml:space="preserve">
          <source>In other words, the two zero-width assertions next to each other work as though they're ANDed together, just as you'd use any built-in assertions: &lt;code&gt;/^$/&lt;/code&gt; matches only if you're at the beginning of the line AND the end of the line simultaneously. The deeper underlying truth is that juxtaposition in regular expressions always means AND, except when you write an explicit OR using the vertical bar. &lt;code&gt;/ab/&lt;/code&gt; means match &quot;a&quot; AND (then) match &quot;b&quot;, although the attempted matches are made at different positions because &quot;a&quot; is not a zero-width assertion, but a one-width assertion.</source>
          <target state="translated">换句话说，彼此相邻的两个零宽度断言就像它们被AND在一起一样工作，就像您将使用任何内置断言一样： &lt;code&gt;/^$/&lt;/code&gt; 仅在您位于行和行尾同时显示。更深层的事实是，除了使用竖线写显式&amp;ldquo;或&amp;rdquo;外，正则表达式中的并置始终意味着&amp;ldquo;与&amp;rdquo;。 &lt;code&gt;/ab/&lt;/code&gt; 表示匹配&amp;ldquo; a&amp;rdquo;并且（然后）匹配&amp;ldquo; b&amp;rdquo;，尽管尝试的匹配是在不同的位置进行的，因为&amp;ldquo; a&amp;rdquo;不是零宽度的断言，而是单宽度的断言。</target>
        </trans-unit>
        <trans-unit id="459d5640fff6f70049a1cb4e21dd9d95f811c50c" translate="yes" xml:space="preserve">
          <source>In other words, this is valid:</source>
          <target state="translated">换句话说,这是有效的。</target>
        </trans-unit>
        <trans-unit id="b1e37082db8f86fab9970e0f78a995b4a26a2a25" translate="yes" xml:space="preserve">
          <source>In other words, you can write:</source>
          <target state="translated">换句话说,你可以写。</target>
        </trans-unit>
        <trans-unit id="760e520ac926fbcbcf184f0f289efd734964ab6f" translate="yes" xml:space="preserve">
          <source>In other words: regardless of platform, use binmode() on binary data, like images, for example.</source>
          <target state="translated">换句话说:无论在哪个平台,都可以在二进制数据上使用binmode(),比如图像。</target>
        </trans-unit>
        <trans-unit id="9c34e83f6eab1310b3613a944eb5e27cd7e611dd" translate="yes" xml:space="preserve">
          <source>In other words: replace &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; DynaLoader&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; , remove &lt;code&gt;DynaLoader&lt;/code&gt; from &lt;code&gt;@ISA&lt;/code&gt; , change &lt;code&gt;bootstrap&lt;/code&gt; by &lt;code&gt;XSLoader::load&lt;/code&gt; . Do not forget to quote the name of your package on the &lt;code&gt;XSLoader::load&lt;/code&gt; line, and add comma (&lt;code&gt;,&lt;/code&gt; ) before the arguments (&lt;code&gt;$VERSION&lt;/code&gt; above).</source>
          <target state="translated">换句话说：更换 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; DynaLoader&lt;/code&gt; 由 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; ，删除 &lt;code&gt;DynaLoader&lt;/code&gt; 从 &lt;code&gt;@ISA&lt;/code&gt; ，改变 &lt;code&gt;bootstrap&lt;/code&gt; 通过 &lt;code&gt;XSLoader::load&lt;/code&gt; 。不要忘记在 &lt;code&gt;XSLoader::load&lt;/code&gt; 行上引用软件包的名称，并在参数（上面的 &lt;code&gt;$VERSION&lt;/code&gt; ）之前添加逗号（ &lt;code&gt;,&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cc33d1c173d87ad8a862029ec4420d308b38832f" translate="yes" xml:space="preserve">
          <source>In our case, Mytest.pm tells perl that it will need the Exporter and Dynamic Loader extensions. It then sets the &lt;code&gt;@ISA&lt;/code&gt; and &lt;code&gt;@EXPORT&lt;/code&gt; arrays and the &lt;code&gt;$VERSION&lt;/code&gt; scalar; finally it tells perl to bootstrap the module. Perl will call its dynamic loader routine (if there is one) and load the shared library.</source>
          <target state="translated">在我们的例子中，Mytest.pm告诉perl，它将需要Exporter和Dynamic Loader扩展。然后，它设置 &lt;code&gt;@ISA&lt;/code&gt; 和 &lt;code&gt;@EXPORT&lt;/code&gt; 数组以及 &lt;code&gt;$VERSION&lt;/code&gt; 标量；最后，它告诉perl引导模块。Perl将调用其动态加载程序例程（如果有的话）并加载共享库。</target>
        </trans-unit>
        <trans-unit id="92b4893cf24b728e0fae1966639d9078e63fc3f7" translate="yes" xml:space="preserve">
          <source>In our example we can just call &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; on the underlying hash referenced by &lt;code&gt;$self-&amp;gt;{LIST}&lt;/code&gt; :</source>
          <target state="translated">在我们的示例中，我们可以只对 &lt;code&gt;$self-&amp;gt;{LIST}&lt;/code&gt; 引用的基础哈希调用 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bc1f779d9a34032474fc9a65f77cb8d2776cbce1" translate="yes" xml:space="preserve">
          <source>In our example we're going to create a shouting handle.</source>
          <target state="translated">在我们的例子中,我们要创建一个喊话柄。</target>
        </trans-unit>
        <trans-unit id="a13dbabebbc5437dccc50e5be8ddf3c33a642ee8" translate="yes" xml:space="preserve">
          <source>In our example, 'undef' is really an element containing &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; number of spaces. Observe:</source>
          <target state="translated">在我们的示例中，&amp;ldquo; undef&amp;rdquo;实际上是一个包含 &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; 个空格的元素。观察：</target>
        </trans-unit>
        <trans-unit id="aabcb2149f4617fcf7efa6bbc92a17b687ef3353" translate="yes" xml:space="preserve">
          <source>In our example, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is really &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; number of spaces so we have a little more work to do here:</source>
          <target state="translated">在我们的示例中， &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 实际上是 &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; 个空格，因此我们在这里还有更多工作要做：</target>
        </trans-unit>
        <trans-unit id="1f1787ee08eebed75ede8020208e3ff9eccca1a6" translate="yes" xml:space="preserve">
          <source>In our example, a deleted item is &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; spaces:</source>
          <target state="translated">在我们的示例中，删除的项目为 &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; 空格：</target>
        </trans-unit>
        <trans-unit id="91424799b59a91080c214218f5e7f8c9b0b084d8" translate="yes" xml:space="preserve">
          <source>In our example, just to show you that you don't</source>
          <target state="translated">在我们的例子中,只是为了告诉你,你不需要</target>
        </trans-unit>
        <trans-unit id="11b35d0e0b09647c243a787b95c24ae27233aecd" translate="yes" xml:space="preserve">
          <source>In our example, that would remove all the user's dot files! It's such a dangerous thing that they'll have to set CLOBBER to something higher than 1 to make it happen.</source>
          <target state="translated">在我们的例子中,这将删除用户的所有点文件! 这是个很危险的事情,他们必须将CLOBBER设置为高于1的东西才行。</target>
        </trans-unit>
        <trans-unit id="8f92d427a1809586b396dc516bf348aaa08bbed7" translate="yes" xml:space="preserve">
          <source>In our example, we want to make sure there are no blank (&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) entries, so &lt;code&gt;EXTEND&lt;/code&gt; will make use of &lt;code&gt;STORESIZE&lt;/code&gt; to fill elements as needed:</source>
          <target state="translated">在我们的示例中，我们要确保没有空白（ &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ）条目，因此 &lt;code&gt;EXTEND&lt;/code&gt; 将根据需要使用 &lt;code&gt;STORESIZE&lt;/code&gt; 来填充元素：</target>
        </trans-unit>
        <trans-unit id="24d1f4e04fd957695cb0fc036193c59fca0468cd" translate="yes" xml:space="preserve">
          <source>In our example, we will determine that if an element consists of &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; spaces only, it does not exist:</source>
          <target state="translated">在我们的示例中，我们将确定如果元素仅由 &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; 空间组成，则该元素不存在：</target>
        </trans-unit>
        <trans-unit id="9241072dd02f63704e06d0e4788fd47ef3eca294" translate="yes" xml:space="preserve">
          <source>In our example, we'll use a little shortcut if there is a</source>
          <target state="translated">在我们的例子中,我们将使用一个小的快捷方式,如果有一个</target>
        </trans-unit>
        <trans-unit id="6a2c73ee683cc447274fd115e41a8a6212c0860c" translate="yes" xml:space="preserve">
          <source>In our intranet, we have many modules for internal use. How can I integrate these modules with CPAN.pm but without uploading the modules to CPAN?</source>
          <target state="translated">在我们的内部网中,我们有许多模块供内部使用。如何将这些模块与CPAN.pm整合在一起,但又不需要将模块上传到CPAN?</target>
        </trans-unit>
        <trans-unit id="e3d33b8a8cd9ee1cbb39097ccf83087f357647e8" translate="yes" xml:space="preserve">
          <source>In our tied hash DotFiles example, we use a regular hash for the object containing several important fields, of which only the &lt;code&gt;{LIST}&lt;/code&gt; field will be what the user thinks of as the real hash.</source>
          <target state="translated">在我们绑定的哈希DotFiles示例中，我们对包含几个重要字段的对象使用常规哈希，其中只有 &lt;code&gt;{LIST}&lt;/code&gt; 字段才是用户认为的真实哈希。</target>
        </trans-unit>
        <trans-unit id="07709450f49a2785357dceda9bbcd6e033ef5380" translate="yes" xml:space="preserve">
          <source>In paragraphs where formatting codes (like E&amp;lt;...&amp;gt;, B&amp;lt;...&amp;gt;) are understood (i.e.,</source>
          <target state="translated">在理解格式代码（如E &amp;lt;...&amp;gt;，B &amp;lt;...&amp;gt;）的段落中（即，</target>
        </trans-unit>
        <trans-unit id="fb0742f46f732e81f9ef6b26f9dd077a50514538" translate="yes" xml:space="preserve">
          <source>In parsing Pod, a notably tricky part is the correct parsing of (potentially nested!) formatting codes. Implementors should consult the code in the &lt;code&gt;parse_text&lt;/code&gt; routine in Pod::Parser as an example of a correct implementation.</source>
          <target state="translated">在解析Pod时，一个特别棘手的部分是正确解析（可能嵌套！）格式代码。实现者应参考Pod :: Parser中 &lt;code&gt;parse_text&lt;/code&gt; 例程中的代码，作为正确实现的示例。</target>
        </trans-unit>
        <trans-unit id="e44b2915e9ebcfa80eaf0cd0b8fc6a537b378a7a" translate="yes" xml:space="preserve">
          <source>In parsing an L&amp;lt;...&amp;gt; code, Pod parsers must distinguish at least four attributes:</source>
          <target state="translated">在解析L &amp;lt;...&amp;gt;代码时，Pod解析器必须区分至少四个属性：</target>
        </trans-unit>
        <trans-unit id="173ae1b4c7abf280ed9de2a2e4233e82968c1ade" translate="yes" xml:space="preserve">
          <source>In parsing these constructs, Perl always ignores Upper/lower case differences everywhere within the {braces}. Thus &lt;code&gt;\p{Greek}&lt;/code&gt; means the same thing as &lt;code&gt;\p{greek}&lt;/code&gt; . But note that changing the case of the &lt;code&gt;&quot;p&quot;&lt;/code&gt; or &lt;code&gt;&quot;P&quot;&lt;/code&gt; before the left brace completely changes the meaning of the construct, from &quot;match&quot; (for &lt;code&gt;\p{}&lt;/code&gt; ) to &quot;doesn't match&quot; (for &lt;code&gt;\P{}&lt;/code&gt; ). Casing in this document is for improved legibility.</source>
          <target state="translated">在解析这些构造时，Perl始终在{大括号}内各处忽略大小写差异。因此 &lt;code&gt;\p{Greek}&lt;/code&gt; 含义与 &lt;code&gt;\p{greek}&lt;/code&gt; 。但是请注意，在左括号之前更改 &lt;code&gt;&quot;p&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;P&quot;&lt;/code&gt; 的大小写会完全更改构造的含义，从&amp;ldquo; match&amp;rdquo;（对于 &lt;code&gt;\p{}&lt;/code&gt; ）变为&amp;ldquo; not match&amp;rdquo;（对于 &lt;code&gt;\P{}&lt;/code&gt; ）。本文档中的外壳用于提高可读性。</target>
        </trans-unit>
        <trans-unit id="9aaf8e25ca7ca9dd8d4b03a35ad6a47a7f371c04" translate="yes" xml:space="preserve">
          <source>In particular</source>
          <target state="translated">特别是</target>
        </trans-unit>
        <trans-unit id="2f4b20effb603658d4594f20068f3202a019f207" translate="yes" xml:space="preserve">
          <source>In particular have a hunt around for the following:</source>
          <target state="translated">特别是对以下内容进行搜索。</target>
        </trans-unit>
        <trans-unit id="549a73d37bd647b3d02bdfb1ed4587a94e6c791c" translate="yes" xml:space="preserve">
          <source>In particular the following metacharacters have their standard</source>
          <target state="translated">特别是下面的元字符有它们的标准值</target>
        </trans-unit>
        <trans-unit id="d9ca3d8c112df43cded72f31c7db395214aede20" translate="yes" xml:space="preserve">
          <source>In particular,</source>
          <target state="translated">特别是:</target>
        </trans-unit>
        <trans-unit id="ef80eb5daee93a0d4fde8126fc49aefdc4e89c82" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;Tie::File&lt;/code&gt; will</source>
          <target state="translated">特别是， &lt;code&gt;Tie::File&lt;/code&gt; 将</target>
        </trans-unit>
        <trans-unit id="2db3c0671aba0d3ee80c31fffb1da43c83f4160e" translate="yes" xml:space="preserve">
          <source>In particular, braces do not need to be balanced:</source>
          <target state="translated">尤其是牙套不需要平衡。</target>
        </trans-unit>
        <trans-unit id="2cbf0bbf93ed5b0e470ae4c77978f151618da6e4" translate="yes" xml:space="preserve">
          <source>In particular, follow these general guidelines for patching Perl sources:</source>
          <target state="translated">特别是,请遵循以下一般准则来为Perl源代码打补丁。</target>
        </trans-unit>
        <trans-unit id="588a69fc1734910196fa33dcc3398592c9c2b486" translate="yes" xml:space="preserve">
          <source>In particular, if you are using Info-Zip you need to have zip version 3.x or better to update a Zip64 archive and unzip version 6.x to read a zip64 archive.</source>
          <target state="translated">特别是,如果你使用的是Info-Zip,你需要有3.x或更高版本的zip来更新Zip64存档,并解压6.x版本来读取zip64存档。</target>
        </trans-unit>
        <trans-unit id="b8504eca27d4d7dd980e055d06368ef344507bf5" translate="yes" xml:space="preserve">
          <source>In particular, if you opened the pipe using &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; , then you cannot simply use close() in the parent process to close an unwanted writer. Consider this code:</source>
          <target state="translated">特别是，如果使用 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; 打开管道，则不能简单地在父进程中使用close（）关闭不需要的编写器。考虑以下代码：</target>
        </trans-unit>
        <trans-unit id="55f883bf0e56efd410000618d8c0d414be5f0032" translate="yes" xml:space="preserve">
          <source>In particular, it is not possible to write general-purpose classes in this technique, classes that can advertise themselves as &quot;Put me on your @ISA list and use my methods&quot;. If the other class has different ideas about how the object body is used, there is trouble.</source>
          <target state="translated">特别是,用这种技术写通用类是不行的,这种类可以标榜自己是 &quot;把我放到你的@ISA列表中,使用我的方法&quot;。如果其他类对对象体的使用有不同的想法,那就麻烦了。</target>
        </trans-unit>
        <trans-unit id="2fd11e0201dc297df1cba370809db0d5939f0ec0" translate="yes" xml:space="preserve">
          <source>In particular, the extensions &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; and &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; are not supported under EBCDIC; likewise for the (now deprecated) &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; pragma.</source>
          <target state="translated">尤其是EBCDIC不支持&lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collat​​e&lt;/a&gt;和&lt;a href=&quot;unicode/normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt;扩展；同样（对于已弃用的）&lt;a href=&quot;encoding&quot;&gt;编码&lt;/a&gt;编译指示也是如此。</target>
        </trans-unit>
        <trans-unit id="b491336832fe24926f813912697f1c74d79ed48d" translate="yes" xml:space="preserve">
          <source>In particular, the special &lt;code&gt;${^_XYZ}&lt;/code&gt; variables are always taken to be in package &lt;code&gt;main&lt;/code&gt; , regardless of any &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; declarations presently in scope.</source>
          <target state="translated">特别是，特殊的 &lt;code&gt;${^_XYZ}&lt;/code&gt; 变量始终被视为在包 &lt;code&gt;main&lt;/code&gt; 中，而不管当前作用域中是否有任何 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="5adbc38d169db3c0edbc488274012a781b34d025" translate="yes" xml:space="preserve">
          <source>In particular, this API does &lt;b&gt;not&lt;/b&gt; provide the following functions:</source>
          <target state="translated">特别是，该API并&lt;b&gt;没有&lt;/b&gt;提供以下功能：</target>
        </trans-unit>
        <trans-unit id="26d259999f6bd5eabc0e32bc92fd018cffcba101" translate="yes" xml:space="preserve">
          <source>In particular, this is applicable to the structure of &lt;code&gt;@INC&lt;/code&gt; used for testing not-yet-installed extensions. This means that running uninstalled extensions may have much more overhead than running the same extensions after &lt;code&gt;make install&lt;/code&gt; .</source>
          <target state="translated">特别是，这适用于用于测试尚未安装的扩展名的 &lt;code&gt;@INC&lt;/code&gt; 结构。这意味着，与在 &lt;code&gt;make install&lt;/code&gt; 之后运行相同的扩展相比，运行卸载的扩展可能会有更多的开销。</target>
        </trans-unit>
        <trans-unit id="da2e58986eb4f3be556785c248e50c152e1a4485" translate="yes" xml:space="preserve">
          <source>In particular, this means that you shouldn't use this for selecting between two aggregates for assignment:</source>
          <target state="translated">特别是,这意味着你不应该用它来选择两个聚合体之间的分配。</target>
        </trans-unit>
        <trans-unit id="6b654969e8b0fb9bedec078843fc01697a0cd123" translate="yes" xml:space="preserve">
          <source>In particular:</source>
          <target state="translated">特别是:</target>
        </trans-unit>
        <trans-unit id="f7e08b6bdc00b0694ecd1bf1d445c34c08eeec2b" translate="yes" xml:space="preserve">
          <source>In patterns where the text of the code is derived from run-time information rather than appearing literally in a source code /pattern/, the code is compiled at the same time that the pattern is compiled, and for reasons of security, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; must be in scope. This is to stop user-supplied patterns containing code snippets from being executable.</source>
          <target state="translated">在模式代码是从运行时信息派生而不是从字面上出现在源代码/ pattern /中的模式中，代码在模式编译的同时进行编译，并且出于安全原因，请 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; 必须在范围内。这是为了阻止用户提供的包含代码段的模式是可执行的。</target>
        </trans-unit>
        <trans-unit id="1ea88d26430c6d46158be27b80e4634d3a9d07c0" translate="yes" xml:space="preserve">
          <source>In perl 5.14 and higher, on systems other than Windows that do not support the &lt;code&gt;fchdir&lt;/code&gt; C function, directory handles (see &lt;a href=&quot;functions/opendir&quot;&gt;opendir DIRHANDLE,EXPR&lt;/a&gt;) will not be copied to new threads. You can use the &lt;code&gt;d_fchdir&lt;/code&gt; variable in &lt;a href=&quot;config&quot;&gt;Config.pm&lt;/a&gt; to determine whether your system supports it.</source>
          <target state="translated">在Perl 5.14和更高版本中，在Windows之外的其他不支持 &lt;code&gt;fchdir&lt;/code&gt; C函数的系统上，目录句柄（请参见&lt;a href=&quot;functions/opendir&quot;&gt;opendir DIRHANDLE，EXPR&lt;/a&gt;）不会复制到新线程。您可以使用 &lt;code&gt;d_fchdir&lt;/code&gt; 变量&lt;a href=&quot;config&quot;&gt;Config.pm&lt;/a&gt;以确定您的系统是否支持它。</target>
        </trans-unit>
        <trans-unit id="978dbedfe97270c6d04770e8f1b09ed5adf8e8d1" translate="yes" xml:space="preserve">
          <source>In perl 5.8.0, &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; was also used to mark placeholders in restricted hashes. This caused such hash entries not to appear when iterating over the hash or when checking for the keys with the &lt;code&gt;hv_exists&lt;/code&gt; function.</source>
          <target state="translated">在perl 5.8.0中， &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 也用于在受限哈希中标记占位符。这导致在遍历哈希或使用 &lt;code&gt;hv_exists&lt;/code&gt; 函数检查键时，这些哈希条目不会出现。</target>
        </trans-unit>
        <trans-unit id="e2d10ca79661f6cd0c4cfd21cf2e8aa0ee582a6a" translate="yes" xml:space="preserve">
          <source>In perl 5.8.1 and later, Test::Builder is thread-safe. The test number is shared amongst all threads. This means if one thread sets the test number using &lt;code&gt;current_test()&lt;/code&gt; they will all be effected.</source>
          <target state="translated">在perl 5.8.1和更高版本中，Test :: Builder是线程安全的。测试号在所有线程之间共享。这意味着，如果一个线程使用 &lt;code&gt;current_test()&lt;/code&gt; 设置测试编号，则它们都会全部生效。</target>
        </trans-unit>
        <trans-unit id="1269cc2ad1ea6f2d742e35bd480e05b3838a6225" translate="yes" xml:space="preserve">
          <source>In perl v5.8.0, you can work around this as follows;</source>
          <target state="translated">在perl v5.8.0中,你可以通过以下方式解决这个问题。</target>
        </trans-unit>
        <trans-unit id="3903f5f9bb5ec2db6467ae7e05ade21cf24078e9" translate="yes" xml:space="preserve">
          <source>In perls older than 5.8.1, map suffers from this problem as well. But since 5.8.1, this has been fixed, and map is context aware - in void context, no lists are constructed.</source>
          <target state="translated">在5.8.1以前的perls中,map也存在这个问题。但是从5.8.1开始,这个问题已经被修正了,而且map是上下文感知的--在void上下文中,不会构造列表。</target>
        </trans-unit>
        <trans-unit id="201c993ba430d2b34780a5f6bce751f372ee2124" translate="yes" xml:space="preserve">
          <source>In portable Perl code, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;(9, $child)&lt;/code&gt; must not be used on forked processes. Killing a forked process is unsafe and has unpredictable results. See &lt;a href=&quot;#kill()&quot;&gt;kill()&lt;/a&gt;, above.</source>
          <target state="translated">在可移植的Perl代码中，必须不要在派生的进程上使用 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;(9, $child)&lt;/code&gt; 。杀死一个分叉的过程是不安全的，而且结果不可预测。参见上面的&lt;a href=&quot;#kill()&quot;&gt;kill（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64e70c5c9f546a348d8be9f13ed9b3d5b217325e" translate="yes" xml:space="preserve">
          <source>In practice this logic is better performed by &lt;a href=&quot;io/socket/ip&quot;&gt;IO::Socket::IP&lt;/a&gt;.</source>
          <target state="translated">实际上，此逻辑最好由&lt;a href=&quot;io/socket/ip&quot;&gt;IO :: Socket :: IP执行&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f10d5bbc85368eaaed58b49509d8d5537fcea2c6" translate="yes" xml:space="preserve">
          <source>In practice this makes seldom a difference as &lt;b&gt;parts and results&lt;/b&gt; of expressions will be truncated anyway, but this can, for instance, affect the return value of subroutines:</source>
          <target state="translated">实际上，这几乎没有什么区别，因为无论如何表达式的&lt;b&gt;部分和结果&lt;/b&gt;都将被截断，但这可能会影响子例程的返回值：</target>
        </trans-unit>
        <trans-unit id="2c8bdda291d4d16e099108c0540471c243257c86" translate="yes" xml:space="preserve">
          <source>In practice, Perl scripts that call programs that return _POSIX_EXIT type status values will be expecting those values, and programs that call traditional VMS programs will either be expecting the previous behavior or just checking for a non-zero status.</source>
          <target state="translated">在实践中,调用返回_POSIX_EXIT类型状态值的程序的Perl脚本会期待这些值,而调用传统VMS程序的程序要么期待之前的行为,要么只是检查非零状态。</target>
        </trans-unit>
        <trans-unit id="6ed326b6d59e850419b57af366a49ca220934029" translate="yes" xml:space="preserve">
          <source>In practice, it is anticipated that this character will not be used often, but formatters should either support it, or delete it.</source>
          <target state="translated">在实践中,预计这个字符不会经常使用,但格式化人员应该支持它,或者删除它。</target>
        </trans-unit>
        <trans-unit id="796550631a5df07b05a560a67d63d7ad67fdf7c5" translate="yes" xml:space="preserve">
          <source>In previous sections we have seen how to pack numbers and character strings. If it were not for a couple of snags we could conclude this section right away with the terse remark that C structures don't contain anything else, and therefore you already know all there is to it. Sorry, no: read on, please.</source>
          <target state="translated">在前面的章节中,我们已经看到了如何打包数字和字符串。如果不是有几个小插曲,我们可以用一句简短的话来结束这一节,那就是C结构不包含任何其他东西,因此你已经知道了所有的内容。对不起,不:请继续阅读。</target>
        </trans-unit>
        <trans-unit id="692b842adc759f56816c9c058cae643b8a51086a" translate="yes" xml:space="preserve">
          <source>In principle the unpack() command can be used to convert the bytes back to a number (if the underlying type is known to be a number).</source>
          <target state="translated">原则上,unpack()命令可以用来将字节转换回数字(如果已知底层类型是数字)。</target>
        </trans-unit>
        <trans-unit id="1221515422031848620efe6d264c7054adcd4f04" translate="yes" xml:space="preserve">
          <source>In prior perl versions, spawning threads with open directory handles would crash the interpreter. &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2frt.perl.org%2frt3%2fPublic%2fBug%2fDisplay.html%3fid%3d75154&quot;&gt;[perl #75154]&lt;/a&gt;</source>
          <target state="translated">在以前的perl版本中，生成带有打开目录句柄的线程会使解释器崩溃。&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2frt.perl.org%2frt3%2fPublic%2fBug%2fDisplay.html%3fid%3d75154&quot;&gt;[perl＃75154]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d807cc153636cb39c76e4cb0277ef6012694dae7" translate="yes" xml:space="preserve">
          <source>In programs:</source>
          <target state="translated">在节目中。</target>
        </trans-unit>
        <trans-unit id="48c74c56dfa96426cf79d4567af2599b0fde094e" translate="yes" xml:space="preserve">
          <source>In recent years, vendors have begun to supply systems free of this inherent security bug. On such systems, when the kernel passes the name of the set-id script to open to the interpreter, rather than using a pathname subject to meddling, it instead passes</source>
          <target state="translated">近年来,厂商已经开始提供没有这个固有安全漏洞的系统。在这样的系统中,当内核把要打开的set-id脚本的名字传给解释器时,它不是使用一个可被干涉的路径名,而是传给了</target>
        </trans-unit>
        <trans-unit id="fc7a0ac9fe9f163678a08865a8ae2ec22fbc06ff" translate="yes" xml:space="preserve">
          <source>In regex speak, a word boundary (\b) is a &quot;zero width assertion&quot;, meaning that it doesn't represent a character in the string, but a condition at a certain position.</source>
          <target state="translated">用regex的说法,字界(\b)是 &quot;零宽度断言&quot;,也就是说,它并不代表字符串中的一个字符,而是代表某个位置的一个条件。</target>
        </trans-unit>
        <trans-unit id="1b5ca67e58e909ea0b763b445166b0dc50f9fff9" translate="yes" xml:space="preserve">
          <source>In regular expressions, the &lt;code&gt;${foo[2]}&lt;/code&gt; syntax is sometimes necessary to disambiguate between array subscripts and character classes. &lt;code&gt;/$length[2345]/&lt;/code&gt; , for instance, will be interpreted as &lt;code&gt;$length&lt;/code&gt; followed by the character class &lt;code&gt;[2345]&lt;/code&gt; . If an array subscript is what you want, you can avoid the warning by changing &lt;code&gt;/${length[2345]}/&lt;/code&gt; to the unsightly &lt;code&gt;/${\$length[2345]}/&lt;/code&gt; , by renaming your array to something that does not coincide with a built-in keyword, or by simply turning off warnings with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'ambiguous';&lt;/code&gt; .</source>
          <target state="translated">在正则表达式中，有时需要使用 &lt;code&gt;${foo[2]}&lt;/code&gt; 语法来消除数组下标和字符类之间的歧义。例如， &lt;code&gt;/$length[2345]/&lt;/code&gt; 将被解释为 &lt;code&gt;$length&lt;/code&gt; 后跟字符类 &lt;code&gt;[2345]&lt;/code&gt; 。如果需要数组下标，则可以通过将 &lt;code&gt;/${length[2345]}/&lt;/code&gt; 更改为难看的 &lt;code&gt;/${\$length[2345]}/&lt;/code&gt; 来避免警告，方法是将数组重命名为不匹配的内容使用内置关键字，或者简单地关闭 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'ambiguous';&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="870f19d24df4b4eee6c062f874fd2afacdfc9f30" translate="yes" xml:space="preserve">
          <source>In scalar context it returns the same as perl would when stringifying a raw &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; with the same pattern inside. If the argument is not a compiled reference then this routine returns false but defined in scalar context, and the empty list in list context. Thus the following</source>
          <target state="translated">在标量上下文中，当对原始 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 进行内部字符串化时，其返回的结果与perl 相同。如果参数不是编译的引用，则此例程返回false，但在标量上下文中定义，而空列表在列表上下文中。因此以下</target>
        </trans-unit>
        <trans-unit id="0a19f93e8a70aa3709a4c5eb5c497d67c74952ec" translate="yes" xml:space="preserve">
          <source>In scalar context will return just the IP address.</source>
          <target state="translated">在标量上下文中,将只返回IP地址。</target>
        </trans-unit>
        <trans-unit id="1370034b95e83c1602601f8f2c93a5f4f13c28ad" translate="yes" xml:space="preserve">
          <source>In scalar context without arguments, this method returns the number of parsers aggregated. In list context without arguments, returns the parsers in the order they were added.</source>
          <target state="translated">在没有参数的标量上下文中,本方法返回汇总的解析器数量。在没有参数的列表上下文中,按添加顺序返回解析器。</target>
        </trans-unit>
        <trans-unit id="3e333b48f248d91366426a74dfbbc3da65c8ea7d" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&quot;..&quot;&lt;/code&gt; returns a boolean value. The operator is bistable, like a flip-flop, and emulates the line-range (comma) operator of &lt;b&gt;sed&lt;/b&gt;, &lt;b&gt;awk&lt;/b&gt;, and various editors. Each &lt;code&gt;&quot;..&quot;&lt;/code&gt; operator maintains its own boolean state, even across calls to a subroutine that contains it. It is false as long as its left operand is false. Once the left operand is true, the range operator stays true until the right operand is true,</source>
          <target state="translated">在标量上下文中， &lt;code&gt;&quot;..&quot;&lt;/code&gt; 返回布尔值。该运算符是双稳态的，就像触发器一样，它模拟&lt;b&gt;sed&lt;/b&gt;，&lt;b&gt;awk&lt;/b&gt;和各种编辑器的行范围（逗号）运算符。每个 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 运算符都保持其自己的布尔状态，即使在包含该状态的子例程的调用之间也是如此。只要其左操作数为false，它就是false。一旦左操作数为true，则范围运算符将保持为true，直到右操作数为true，</target>
        </trans-unit>
        <trans-unit id="4702696bd1a6606f8c00bfa48b7462e238b219f8" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; returns the ctime(3) value:</source>
          <target state="translated">在标量上下文中， &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 返回ctime（3）值：</target>
        </trans-unit>
        <trans-unit id="50ab8480db61cacd9dd3820b8d1635a7c8fbf2e8" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; returns a boolean value indicating success or failure, and, if successful, sets the information associated with the special filehandle &lt;code&gt;_&lt;/code&gt; .</source>
          <target state="translated">在标量上下文中， &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 返回一个布尔值，指示成功或失败，如果成功，则设置与特殊文件句柄 &lt;code&gt;_&lt;/code&gt; 关联的信息。</target>
        </trans-unit>
        <trans-unit id="d1818a475de168c2b1a7d2bb086c2af5a3f3a97b" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;$user&lt;/code&gt; .</source>
          <target state="translated">在标量上下文中， &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;$user&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d16f2c8ac24f3fef816016a050127e8baea1e4f0" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; returns the ctime(3) value:</source>
          <target state="translated">在标量上下文中， &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 返回ctime（3）值：</target>
        </trans-unit>
        <trans-unit id="c038fe7af8fd4fba37237e821dee5726e03d9bcf" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; returns a boolean value indicating success or failure, and, if successful, sets the information associated with the special filehandle &lt;code&gt;_&lt;/code&gt; .</source>
          <target state="translated">在标量上下文中， &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 返回一个布尔值，指示成功或失败，如果成功，则设置与特殊文件句柄 &lt;code&gt;_&lt;/code&gt; 关联的信息。</target>
        </trans-unit>
        <trans-unit id="f361652bf48a4a2a1736272eaacbdbdece5ad741" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;$user&lt;/code&gt; .</source>
          <target state="translated">在标量上下文中， &lt;code&gt;&lt;a href=&quot;times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;$user&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67f63380dd91d8509df2b85f67d144a31345d453" translate="yes" xml:space="preserve">
          <source>In scalar context, each execution of &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; finds the next match, returning true if it matches, and false if there is no further match. The position after the last match can be read or set using the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function; see &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;. A failed match normally resets the search position to the beginning of the string, but you can avoid that by adding the &lt;code&gt;/c&lt;/code&gt; modifier (for example, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt;). Modifying the target string also resets the search position.</source>
          <target state="translated">在标量上下文中，每次执行 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; 找到下一个匹配项，如果匹配则返回true，如果没有其他匹配则返回false。可以使用 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 函数读取或设置最后一次匹配之后的位置；见&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;。匹配失败通常会将搜索位置重置为字符串的开头，但是您可以通过添加 &lt;code&gt;/c&lt;/code&gt; 修饰符（例如 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; ）来避免这种情况。修改目标字符串也会重置搜索位置。</target>
        </trans-unit>
        <trans-unit id="8800b54c59ca34fbb2fd00902e130cb43eb3acc5" translate="yes" xml:space="preserve">
          <source>In scalar context, evaluating a filehandle in angle brackets yields the next line from that file (the newline, if any, included), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; at end-of-file or on error. When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (sometimes known as file-slurp mode) and the file is empty, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">在标量上下文，在尖括号评估文件句柄产生从该文件，或下一行（换行，如果有的话，包括） &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 在结束文件或错误。当 &lt;code&gt;$/&lt;/code&gt; 设置为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （有时称为文件抓取模式）并且文件为空时，它第一次返回 &lt;code&gt;''&lt;/code&gt; ，随后是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90d5e99280edc013a52bda47119a081391fd852e" translate="yes" xml:space="preserve">
          <source>In scalar context, just the filehandle is returned.</source>
          <target state="translated">在标量上下文中,只返回filehandle。</target>
        </trans-unit>
        <trans-unit id="26e7b891880cf2546cd4182b9d0f0a5ab5924094" translate="yes" xml:space="preserve">
          <source>In scalar context, the function returns the most preferred language tag (or undef if no preference was seen).</source>
          <target state="translated">在标量上下文中,函数返回最喜欢的语言标签(如果没有看到偏好,则返回 undef)。</target>
        </trans-unit>
        <trans-unit id="b1d9f6c7ff92d9e4431c44fd49623f31abe26893" translate="yes" xml:space="preserve">
          <source>In scalar context, the remaining time in the timer is returned.</source>
          <target state="translated">在标量上下文中,返回定时器的剩余时间。</target>
        </trans-unit>
        <trans-unit id="f286b508bea32b55376de76bb51800a879183e4c" translate="yes" xml:space="preserve">
          <source>In scalar context, the remaining time is returned.</source>
          <target state="translated">在标量上下文中,返回剩余时间。</target>
        </trans-unit>
        <trans-unit id="1fc032fde56245f910fbc6d13638ce22e45ea79e" translate="yes" xml:space="preserve">
          <source>In scalar context, you get the name, unless the function was a lookup by name, in which case you get the other thing, whatever it is. (If the entry doesn't exist you get the undefined value.) For example:</source>
          <target state="translated">在标量上下文中,你得到的是名称,除非函数是按名称查找的,在这种情况下,你得到的是其他东西,不管它是什么。(如果条目不存在,你就会得到未定义的值。)例如。</target>
        </trans-unit>
        <trans-unit id="070ead24adcf97bbf0458e41cddfaf9060fd1c75" translate="yes" xml:space="preserve">
          <source>In scopes where &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; is in force, nearly all the operators listed above will force their argument(s) into integer format, and return an integer result. The exceptions, &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; , do not change their behavior with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 范围内；如果有效，上面列出的几乎所有运算符都会将其参数强制转换为整数格式，并返回整数结果。异常 &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 不会 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 整数更改其行为；</target>
        </trans-unit>
        <trans-unit id="d3fd63b759e64d942882eb1c88a05afcfdaffadf" translate="yes" xml:space="preserve">
          <source>In searching for &lt;code&gt;/\bfoo\b/&lt;/code&gt; , only locations in &lt;code&gt;$_&lt;/code&gt; that contain &lt;code&gt;f&lt;/code&gt; will be looked at, because &lt;code&gt;f&lt;/code&gt; is rarer than &lt;code&gt;o&lt;/code&gt; . In general, this is a big win except in pathological cases. The only question is whether it saves you more time than it took to build the linked list in the first place.</source>
          <target state="translated">在搜索 &lt;code&gt;/\bfoo\b/&lt;/code&gt; ，将仅查看 &lt;code&gt;$_&lt;/code&gt; 中包含 &lt;code&gt;f&lt;/code&gt; 的位置，因为 &lt;code&gt;f&lt;/code&gt; 比 &lt;code&gt;o&lt;/code&gt; 稀有。通常，除了病理情况外，这是一个很大的胜利。唯一的问题是，与最初建立链接列表相比，它是否节省了更多时间。</target>
        </trans-unit>
        <trans-unit id="d510b9d55974c5ad5785f6cfe4077983c695078d" translate="yes" xml:space="preserve">
          <source>In short, Perl 4 is the parent to both Perl 5 and Perl 6. Perl 5 is the older sibling, and though they are different languages, someone who knows one will spot many similarities in the other.</source>
          <target state="translated">简而言之,Perl 4是Perl 5和Perl 6的母体。Perl 5是老大哥,虽然它们是不同的语言,但懂得其中一种语言的人,会发现另一种语言有很多相似之处。</target>
        </trans-unit>
        <trans-unit id="a022deee593194afb675e77892be1749073d500f" translate="yes" xml:space="preserve">
          <source>In simple cases, it is equivalent to:</source>
          <target state="translated">在简单的情况下,它相当于。</target>
        </trans-unit>
        <trans-unit id="ffcc65b4ec59c10cd981321f645c18e2c2833005" translate="yes" xml:space="preserve">
          <source>In simple terms, this is what happens:</source>
          <target state="translated">简单来说,就是这样。</target>
        </trans-unit>
        <trans-unit id="d121139946109160493990901ec9a05c62500b61" translate="yes" xml:space="preserve">
          <source>In situations where you need to enable this with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; , you should also have taint checking enabled. Better yet, use the carefully constrained evaluation within a Safe compartment. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for details about both these mechanisms.</source>
          <target state="translated">在需要 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; 启用它的情况下，还应该启用污点检查。更好的是，在保险柜中使用经过严格约束的评估。有关这两种机制的详细信息，请参见&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2046d35bd71cc3166ad97adddb890d2444c1f0f" translate="yes" xml:space="preserve">
          <source>In some cases (starting server processes, for instance) you'll want to completely dissociate the child process from the parent. This is often called daemonization. A well-behaved daemon will also chdir() to the root directory so it doesn't prevent unmounting the filesystem containing the directory from which it was launched, and redirect its standard file descriptors from and to</source>
          <target state="translated">在某些情况下(例如,启动服务器进程),你会希望将子进程与父进程完全分离。这通常被称为守护进程化。一个行为良好的守护进程也会对根目录进行chdir()操作,这样它就不会阻止卸载包含它所启动的目录的文件系统,并将其标准文件描述符从和重定向到</target>
        </trans-unit>
        <trans-unit id="fd4562e3425450ab12fc121ff9cd696fd05153a4" translate="yes" xml:space="preserve">
          <source>In some cases files created by File::Temp are removed from within an END block. Since END blocks are triggered when a child process exits (unless C&amp;lt;:_exit&amp;gt; is used by the child) File::Temp takes care to only remove those temp files created by a particular process ID. This means that a child will not attempt to remove temp files created by the parent process.</source>
          <target state="translated">在某些情况下，将从File :: Temp创建的文件从END块中删除。由于在子进程退出时会触发END块（除非子进程使用C &amp;lt;：_ exit&amp;gt;），所以File :: Temp注意只删除由特定进程ID创建的那些临时文件。这意味着子进程将不会尝试删除由父进程创建的临时文件。</target>
        </trans-unit>
        <trans-unit id="4cd284f272380bf09ca4f9468d05eb334cb95414" translate="yes" xml:space="preserve">
          <source>In some cases the 'application' can then be reduced to a small</source>
          <target state="translated">在某些情况下,&quot;应用 &quot;可以被简化为一个小的</target>
        </trans-unit>
        <trans-unit id="df381c2814bde8cd15795ab2d100f8c130800cb5" translate="yes" xml:space="preserve">
          <source>In some cases this</source>
          <target state="translated">在某些情况下,这</target>
        </trans-unit>
        <trans-unit id="cde62ba475df964750a3cdf495be48e1d052051b" translate="yes" xml:space="preserve">
          <source>In some cases, files will only be retained if this variable is true when the file is created. This means that you can not create a temporary file, set this variable and expect the temp file to still be around when the program exits.</source>
          <target state="translated">在某些情况下,只有在创建文件时这个变量为真时,文件才会被保留。这意味着你不能创建一个临时文件,设置这个变量,并期望在程序退出时临时文件仍然存在。</target>
        </trans-unit>
        <trans-unit id="3905e6a37b63c12afc3763addc4e36a653fc636f" translate="yes" xml:space="preserve">
          <source>In some cases, using substr() or vec() to simulate arrays can be highly beneficial. For example, an array of a thousand booleans will take at least 20,000 bytes of space, but it can be turned into one 125-byte bit vector--a considerable memory savings. The standard Tie::SubstrHash module can also help for certain types of data structure. If you're working with specialist data structures (matrices, for instance) modules that implement these in C may use less memory than equivalent Perl modules.</source>
          <target state="translated">在某些情况下,使用substr()或vec()来模拟数组是非常有益的。例如,一个由1000个布尔值组成的数组至少需要20000个字节的空间,但它可以变成一个125个字节的位向量--这是一个相当大的内存节省。标准的 Tie::SubstrHash 模块也可以帮助处理某些类型的数据结构。如果你正在处理专业的数据结构(例如矩阵),用 C 语言实现这些结构的模块可能比同等的 Perl 模块使用更少的内存。</target>
        </trans-unit>
        <trans-unit id="24e84c8e00f2a5bb70e605cd2c69e1dd80d922f5" translate="yes" xml:space="preserve">
          <source>In some cases, yes. You can use the &lt;code&gt;iter&lt;/code&gt; class method to iterate over the files in the tarball without reading them all in memory at once.</source>
          <target state="translated">在某些情况下，是的。您可以使用 &lt;code&gt;iter&lt;/code&gt; 类方法遍历tarball中的文件，而无需一次读取它们在内存中的所有内容。</target>
        </trans-unit>
        <trans-unit id="da7c53f5c4edfd54be873e35b150cbb2e0f64102" translate="yes" xml:space="preserve">
          <source>In some cases, you may be able to make several patterns into a single regular expression. Beware of situations that require backtracking though.</source>
          <target state="translated">在某些情况下,你可能可以将几个模式组成一个正则表达式。不过要注意需要回溯的情况。</target>
        </trans-unit>
        <trans-unit id="55ed1ae3a3af36b978490ace319abb286ca584e8" translate="yes" xml:space="preserve">
          <source>In some cases, you'll want to completely skip an entire testing script.</source>
          <target state="translated">在某些情况下,你会想完全跳过整个测试脚本。</target>
        </trans-unit>
        <trans-unit id="b444fb6bd755ce68abe6b0c45e2101b6fb938848" translate="yes" xml:space="preserve">
          <source>In some contexts, a backslash followed by two or even one octal digits may be interpreted as an octal escape, sometimes with a warning, and because of some bugs, sometimes with surprising results. Also, if you are creating a regex out of smaller snippets concatenated together, and you use fewer than three digits, the beginning of one snippet may be interpreted as adding digits to the ending of the snippet before it. See &lt;a href=&quot;#Absolute-referencing&quot;&gt;Absolute referencing&lt;/a&gt; for more discussion and examples of the snippet problem.</source>
          <target state="translated">在某些情况下，反斜杠后跟两个或什至一个八进制数字可能被解释为八进制转义，有时带有警告，并且由于某些错误而有时导致令人惊讶的结果。另外，如果您是用连接在一起的较小代码段创建正则表达式的，并且使用的数字少于三位，则一个代码段的开头可能会解释为在该代码段的末尾添加数字。有关代码段问题的更多讨论和示例，请参见&lt;a href=&quot;#Absolute-referencing&quot;&gt;绝对引用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="941b228759db0ad2f21515f9edebce99234327a5" translate="yes" xml:space="preserve">
          <source>In some future version of I18N::LangTags, I plan to include support for RFC2482-style language tags -- which are basically just normal language tags with their ASCII characters shifted into Plane 14.</source>
          <target state="translated">在 I18N::LangTags 的未来版本中,我计划加入对 RFC2482 风格的语言标签的支持 --基本上就是将 ASCII 字符移到平面 14 的普通语言标签。</target>
        </trans-unit>
        <trans-unit id="b0260d31b907a523df71ffe831436a5256c0c0bb" translate="yes" xml:space="preserve">
          <source>In some literature this construct is called &quot;atomic matching&quot; or &quot;possessive matching&quot;.</source>
          <target state="translated">在一些文献中,这种构造被称为 &quot;原子匹配 &quot;或 &quot;占有式匹配&quot;。</target>
        </trans-unit>
        <trans-unit id="79419ef5fc7d87682a2736d33053a4e99ddcc17b" translate="yes" xml:space="preserve">
          <source>In some platforms it is not possible to get an alarm with subsecond resolution and later than one second.</source>
          <target state="translated">在一些平台上,无法获得亚秒级分辨率和晚于一秒的报警。</target>
        </trans-unit>
        <trans-unit id="6aef2a6b389cc51b9d270ade7d87dfa403f876dd" translate="yes" xml:space="preserve">
          <source>In some platforms there may be arbitrary amount of padding, for example space characters, after the modified name as shown by &lt;code&gt;ps&lt;/code&gt; . In some platforms this padding may extend all the way to the original length of the argument area, no matter what you do (this is the case for example with Linux 2.2).</source>
          <target state="translated">在某些平台上，如 &lt;code&gt;ps&lt;/code&gt; 所示，在修改后的名称之后可以有任意数量的填充，例如空格字符。在某些平台上，无论您做什么，此填充都可能一直扩展到参数区域的原始长度（例如在Linux 2.2中就是这种情况）。</target>
        </trans-unit>
        <trans-unit id="08216ba09095e01bafc1d8f5f89aaf1f507c0440" translate="yes" xml:space="preserve">
          <source>In some situations you may want to prevent certain symbols from being exported. Typically this applies to extensions which have functions or constants that may not exist on some systems.</source>
          <target state="translated">在某些情况下,您可能希望阻止某些符号被导出。通常,这适用于那些在某些系统上可能不存在的函数或常量的扩展。</target>
        </trans-unit>
        <trans-unit id="6f0ffd2574e55bd73781b2f238993d92b6b53578" translate="yes" xml:space="preserve">
          <source>In spite of its name,</source>
          <target state="translated">尽管它的名字。</target>
        </trans-unit>
        <trans-unit id="3a8cbd2876234fb0eafe4d9966f4f375e97df144" translate="yes" xml:space="preserve">
          <source>In such cases, to force an additional variable to be declared together with declarations of other variables, place the declaration into a PREINIT: section. The PREINIT: keyword may be used one or more times within an XSUB.</source>
          <target state="translated">在这种情况下,为了迫使一个额外的变量与其他变量的声明一起被声明,可以将声明放在PREINIT:部分。PREINIT:关键字可以在XSUB中使用一次或多次。</target>
        </trans-unit>
        <trans-unit id="ac9198f5929b9dd8df4d3b09d9577116cbbad276" translate="yes" xml:space="preserve">
          <source>In such cases, you are advised to either split the test file into smaller ones, or use a reverse approach, doing &quot;normal&quot; (code) compares and triggering &lt;code&gt;fail()&lt;/code&gt; should anything go unexpected.</source>
          <target state="translated">在这种情况下，建议您将测试文件拆分为较小的文件，或使用相反的方法，进行&amp;ldquo;正常&amp;rdquo;（代码）比较，并在出现意外情况时触发 &lt;code&gt;fail()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4b3a6172283064c4d2c38bcdfc1abf019578af1" translate="yes" xml:space="preserve">
          <source>In summary, Perl now normally treats non-Unicode code points as typical Unicode unassigned code points for regular expression matches, raising a warning only when it is arguable what the result should be. However, if this warning has been made fatal, it isn't skipped.</source>
          <target state="translated">总而言之,Perl现在通常将非Unicode码点视为正则表达式匹配的典型Unicode未分配码点,只有当其结果应该是什么时才会引发警告。然而,如果这个警告已经被定为致命警告,它就不会被跳过。</target>
        </trans-unit>
        <trans-unit id="bdfe847eef52d0f5e340cab498d8b20a1e1ac3a3" translate="yes" xml:space="preserve">
          <source>In summary, a compiler backend module should be called &quot;B::Foo&quot; for some foo and live in the appropriate directory for that name. It should define a function called &lt;code&gt;compile&lt;/code&gt; . When the user types</source>
          <target state="translated">总之，对于某些foo，编译器后端模块应称为&amp;ldquo; B :: Foo&amp;rdquo;，并位于该名称的相应目录中。它应该定义一个称为 &lt;code&gt;compile&lt;/code&gt; 的函数。用户输入时</target>
        </trans-unit>
        <trans-unit id="fc74db358d542b3438f19ea437ddcca2306a63f1" translate="yes" xml:space="preserve">
          <source>In summary, local() doesn't make what you think of as private, local variables. It gives a global variable a temporary value. my() is what you're looking for if you want private variables.</source>
          <target state="translated">总而言之,local()并不能让你认为的私有变量、局部变量。如果你想要私有变量,my()才是你要找的。</target>
        </trans-unit>
        <trans-unit id="ec6a62285f67e2d7161b800ebd3c834d396ca9bd" translate="yes" xml:space="preserve">
          <source>In summary:</source>
          <target state="translated">综上所述:</target>
        </trans-unit>
        <trans-unit id="f27d5775b98cc1edc00b71d0a359c25acea44018" translate="yes" xml:space="preserve">
          <source>In telephony, the temporary electrical circuit between the caller&amp;rsquo;s and the callee&amp;rsquo;s phone. In networking, the same kind of temporary circuit between a &lt;b&gt;client&lt;/b&gt; and a &lt;b&gt;server&lt;/b&gt;.</source>
          <target state="translated">在电话中，呼叫者和被呼叫者电话之间的临时电路。在网络中，&lt;b&gt;客户机&lt;/b&gt;和&lt;b&gt;服务器&lt;/b&gt;之间的同类临时电路。</target>
        </trans-unit>
        <trans-unit id="8a961ce11a5972421c4f26b07fe69c91b0c3c7f5" translate="yes" xml:space="preserve">
          <source>In the .xs file, there's now a #include directive with the absolute path to the mylib.h header file. We changed this to a relative path so that we could move the extension directory if we wanted to.</source>
          <target state="translated">在.xs文件中,现在有一个#include指令,是mylib.h头文件的绝对路径。我们将其改为相对路径,这样我们就可以在需要时移动扩展目录。</target>
        </trans-unit>
        <trans-unit id="f2ed93444f2e4f61ea8ed89fb84f5492a5e66658" translate="yes" xml:space="preserve">
          <source>In the 5.9.x development version of perl you can &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re Debug =&amp;gt; 'PARSE'&lt;/code&gt; to see some trace information about the parse process. We will start with some simple patterns and build up to more complex patterns.</source>
          <target state="translated">在Perl的5.9.x开发版本中，可以 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re Debug =&amp;gt; 'PARSE'&lt;/code&gt; 来查看有关解析过程的一些跟踪信息。我们将从一些简单的模式开始，然后发展到更复杂的模式。</target>
        </trans-unit>
        <trans-unit id="695cc6d82e9a098f429aaf4feaee8cd47933f5d7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;Encode&lt;/code&gt; module, &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; is actually a canonical name for &lt;code&gt;&quot;utf-8-strict&quot;&lt;/code&gt; . That hyphen between the &lt;code&gt;&quot;UTF&quot;&lt;/code&gt; and the &lt;code&gt;&quot;8&quot;&lt;/code&gt; is critical; without it, &lt;code&gt;Encode&lt;/code&gt; goes &quot;liberal&quot; and (perhaps overly-)permissive:</source>
          <target state="translated">在 &lt;code&gt;Encode&lt;/code&gt; 模块中， &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; 实际上是 &lt;code&gt;&quot;utf-8-strict&quot;&lt;/code&gt; 的规范名称。 &lt;code&gt;&quot;UTF&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;8&quot;&lt;/code&gt; 之间的连字符至关重要。没有它， &lt;code&gt;Encode&lt;/code&gt; 变得&amp;ldquo;自由&amp;rdquo;，并且（可能过度）宽松：</target>
        </trans-unit>
        <trans-unit id="b4feedfc56c9ca92e3c18dcd179dd65dfefb5217" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;SvPV&lt;/code&gt; macro, the length of the string returned is placed into the variable &lt;code&gt;len&lt;/code&gt; (this is a macro, so you do</source>
          <target state="translated">在 &lt;code&gt;SvPV&lt;/code&gt; 宏中，返回的字符串的长度位于变量 &lt;code&gt;len&lt;/code&gt; 中（这是一个宏，因此您可以</target>
        </trans-unit>
        <trans-unit id="070901afbf1f09255274e8877eb8bc2c70b45164" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; form,</source>
          <target state="translated">以 &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; 形式，</target>
        </trans-unit>
        <trans-unit id="95cc687da96e0b7f7623a95a00b37de925f9f2e9" translate="yes" xml:space="preserve">
          <source>In the C part of the XS file (above the first MODULE line) you have</source>
          <target state="translated">在XS文件的C部分(在第一行MODULE上面),你可以看到</target>
        </trans-unit>
        <trans-unit id="9da81592ea409347d5f06bd8bb3e9dfa81794242" translate="yes" xml:space="preserve">
          <source>In the RE above, which is intentionally obfuscated for illustration, the delimiter is &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;, the modifier is &lt;code&gt;mx&lt;/code&gt; , and after delimiter-removal the RE is the same as for &lt;code&gt;m/ ^ a \s* b /mx&lt;/code&gt; . There's more than one reason you're encouraged to restrict your delimiters to non-alphanumeric, non-whitespace choices.</source>
          <target state="translated">在上面的RE中，有意混淆以进行说明，分隔符为 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; ，修饰符为 &lt;code&gt;mx&lt;/code&gt; ，删除分隔符后的RE与 &lt;code&gt;m/ ^ a \s* b /mx&lt;/code&gt; 。鼓励您将分隔符限制为非字母数字，非空白选项的原因不只一种。</target>
        </trans-unit>
        <trans-unit id="e13a699e1847e4e4560a850a3ff6592656db6884" translate="yes" xml:space="preserve">
          <source>In the above &quot;TAP&quot;, the second and fourth lines will generate &quot;Unknown&quot; tokens.</source>
          <target state="translated">在上述 &quot;TAP &quot;中,第二行和第四行会生成 &quot;未知 &quot;的代币。</target>
        </trans-unit>
        <trans-unit id="058e91307a10961fd993a819105cb638818d3bdd" translate="yes" xml:space="preserve">
          <source>In the above [A, C] example, the &lt;code&gt;STORABLE_freeze&lt;/code&gt; hook could return:</source>
          <target state="translated">在上面的[A，C]示例中， &lt;code&gt;STORABLE_freeze&lt;/code&gt; 钩子可能返回：</target>
        </trans-unit>
        <trans-unit id="eb159de765838e35dcdde7356fd1bd005beb7684" translate="yes" xml:space="preserve">
          <source>In the above, the threads object is returned to the parent thread in scalar context, and the thread's entry point function &lt;code&gt;foo&lt;/code&gt; will be called in list (array) context such that the parent thread can receive a list (array) from the &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call. (&lt;code&gt;'array'&lt;/code&gt; is synonymous with &lt;code&gt;'list'&lt;/code&gt; .)</source>
          <target state="translated">在上面的代码中，threads对象在标量上下文中返回到父线程，并且线程的入口点函数 &lt;code&gt;foo&lt;/code&gt; 将在list（数组）上下文中调用，以便父线程可以从 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 接收列表（数组）（）致电。（ &lt;code&gt;'array'&lt;/code&gt; 与 &lt;code&gt;'list'&lt;/code&gt; 同义。）</target>
        </trans-unit>
        <trans-unit id="9d73b10ae1520507352b424e24dd93e5f334c96c" translate="yes" xml:space="preserve">
          <source>In the above, your &lt;code&gt;frobnicate&lt;/code&gt; function has been changed to be made aware of whether or not it's dealing with UTF-8 data, so that it can handle the string appropriately.</source>
          <target state="translated">在上面，您对 &lt;code&gt;frobnicate&lt;/code&gt; 函数进行了更改，以使其知道是否正在处理UTF-8数据，以便可以适当地处理字符串。</target>
        </trans-unit>
        <trans-unit id="e3c7cb8befa26cf8853246bc9e4f9d7c53539559" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_COLLATE&lt;/code&gt; chooses the collation (sorting) locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the collation locale.</source>
          <target state="translated">如果没有 &lt;code&gt;LC_ALL&lt;/code&gt; ，则 &lt;code&gt;LC_COLLATE&lt;/code&gt; 选择排序规则（排序）语言环境。在 &lt;code&gt;LC_ALL&lt;/code&gt; 和 &lt;code&gt;LC_COLLATE&lt;/code&gt; 都不存在的情况下， &lt;code&gt;LANG&lt;/code&gt; 选择排序规则语言环境。</target>
        </trans-unit>
        <trans-unit id="15ce031d9fce06ed575c3914c8c9ea6101622d1e" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_CTYPE&lt;/code&gt; chooses the character type locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the character type locale.</source>
          <target state="translated">在没有 &lt;code&gt;LC_ALL&lt;/code&gt; 的情况下， &lt;code&gt;LC_CTYPE&lt;/code&gt; 选择字符类型的语言环境。在没有 &lt;code&gt;LC_ALL&lt;/code&gt; 和 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的情况下， &lt;code&gt;LANG&lt;/code&gt; 选择字符类型的语言环境。</target>
        </trans-unit>
        <trans-unit id="6468a6eaf61ca1746bc5af34d7e2d7db949b3755" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_MONETARY&lt;/code&gt; chooses the monetary formatting locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the monetary formatting locale.</source>
          <target state="translated">在没有 &lt;code&gt;LC_ALL&lt;/code&gt; 的情况下， &lt;code&gt;LC_MONETARY&lt;/code&gt; 选择货币格式的语言环境。在 &lt;code&gt;LC_ALL&lt;/code&gt; 和 &lt;code&gt;LC_MONETARY&lt;/code&gt; 都不存在的情况下， &lt;code&gt;LANG&lt;/code&gt; 选择货币格式设置区域。</target>
        </trans-unit>
        <trans-unit id="aa4035e23872d9d83606fa0ea98c9a044e6d0674" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_NUMERIC&lt;/code&gt; chooses the numeric format locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_NUMERIC&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the numeric format.</source>
          <target state="translated">如果没有 &lt;code&gt;LC_ALL&lt;/code&gt; ，则 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 选择数字格式的语言环境。在 &lt;code&gt;LC_ALL&lt;/code&gt; 和 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 都不存在的情况下， &lt;code&gt;LANG&lt;/code&gt; 选择数字格式。</target>
        </trans-unit>
        <trans-unit id="6ab8079d22785df117a0b766ea8b7c3baae6e9c3" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_TIME&lt;/code&gt; chooses the date and time formatting locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_TIME&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the date and time formatting locale.</source>
          <target state="translated">在没有 &lt;code&gt;LC_ALL&lt;/code&gt; 的情况下， &lt;code&gt;LC_TIME&lt;/code&gt; 选择日期和时间格式的语言环境。在 &lt;code&gt;LC_ALL&lt;/code&gt; 和 &lt;code&gt;LC_TIME&lt;/code&gt; 都不存在的情况下， &lt;code&gt;LANG&lt;/code&gt; 选择日期和时间格式设置区域。</target>
        </trans-unit>
        <trans-unit id="68e71f53c7f8acf89933bfc63a04da9641a2aa37" translate="yes" xml:space="preserve">
          <source>In the absence of parentheses, the precedence of list operators such as &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; is either very high or very low depending on whether you are looking at the left side or the right side of the operator. For example, in</source>
          <target state="translated">在没有括号的情况下，列表运算符（例如 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; ）的优先级是很高还是很低，这取决于您是看运算符的左侧还是右侧。例如，在</target>
        </trans-unit>
        <trans-unit id="8e8c77934a4391ccf6a1b211036cc4430a6aec4a" translate="yes" xml:space="preserve">
          <source>In the argument hashref,</source>
          <target state="translated">在参数hashref中。</target>
        </trans-unit>
        <trans-unit id="c8faecb0e00885cd9d3471fff022824b0e193793" translate="yes" xml:space="preserve">
          <source>In the beginning there was ASCII, the &quot;American Standard Code for Information Interchange&quot;, which works quite well for Americans with their English alphabet and dollar-denominated currency. But it doesn't work so well even for other English speakers, who may use different currencies, such as the pound sterling (as the symbol for that currency is not in ASCII); and it's hopelessly inadequate for many of the thousands of the world's other languages.</source>
          <target state="translated">最初有ASCII,即 &quot;美国信息交换标准代码&quot;,对于使用英文字母和美元货币的美国人来说,它的效果相当好。但是,即使对于其他讲英语的人来说,它也不太行得通,因为他们可能使用不同的货币,如英镑(因为该货币的符号不在ASCII中);而且对于世界上成千上万的其他语言来说,它也是无可奈何的。</target>
        </trans-unit>
        <trans-unit id="4d58fb76f14dae3b712c2d1ef16b33d41abd7aa5" translate="yes" xml:space="preserve">
          <source>In the case of &lt;b&gt;-M&lt;/b&gt; and &lt;b&gt;-m&lt;/b&gt;, this is an error because those options are not intended for use inside scripts. Use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; pragma instead.</source>
          <target state="translated">对于&lt;b&gt;-M&lt;/b&gt;和&lt;b&gt;-m&lt;/b&gt;，这是一个错误，因为这些选项不适用于脚本内部。请 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; pragma。</target>
        </trans-unit>
        <trans-unit id="468d95254e2569de4c93c44e90ecaaab6e1c8a96" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;(normalization =&amp;gt; &quot;prenormalized&quot;)&lt;/code&gt; , any normalization is not performed, but discontiguous contractions with combining characters are performed. Therefore &lt;code&gt;(normalization =&amp;gt; 'prenormalized', preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt;&lt;b&gt;is&lt;/b&gt; equivalent to &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; . If source strings are finely prenormalized, &lt;code&gt;(normalization =&amp;gt; 'prenormalized')&lt;/code&gt; may save time for normalization.</source>
          <target state="translated">在 &lt;code&gt;(normalization =&amp;gt; &quot;prenormalized&quot;)&lt;/code&gt; 的情况下，不执行任何归一化，而是执行具有组合字符的不连续收缩。因此 &lt;code&gt;(normalization =&amp;gt; 'prenormalized', preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt; &lt;b&gt;是&lt;/b&gt;等效于 &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; 。如果对源字符串进行了很好的预 &lt;code&gt;(normalization =&amp;gt; 'prenormalized')&lt;/code&gt; ，则（规范化=&amp;gt;'prenormalized'）可以节省规范化时间。</target>
        </trans-unit>
        <trans-unit id="5830f7641c2c9f00de57771005c708cf9a4d5c74" translate="yes" xml:space="preserve">
          <source>In the case of a perl test suite, typically</source>
          <target state="translated">在perl测试套件的情况下,通常是指</target>
        </trans-unit>
        <trans-unit id="93b5501796f0c8e106f09c3c3a171aba6b8b3835" translate="yes" xml:space="preserve">
          <source>In the case of a shared array, all the array's elements are shared, and for a shared hash, all the keys and values are shared. This places restrictions on what may be assigned to shared array and hash elements: only simple values or references to shared variables are allowed - this is so that a private variable can't accidentally become shared. A bad assignment will cause the thread to die. For example:</source>
          <target state="translated">在共享数组的情况下,数组的所有元素都是共享的,而对于共享哈希,所有的键和值都是共享的。这就对共享数组和哈希元素的赋值进行了限制:只允许对共享变量进行简单的赋值或引用--这是为了防止私有变量意外地成为共享变量。一个错误的赋值将导致线程死亡。比如说</target>
        </trans-unit>
        <trans-unit id="2e771b6edcf0a67e48248188d99cc8c1ee77f6d9" translate="yes" xml:space="preserve">
          <source>In the case of a string, &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; assumes you are wanting to load a file. But in the case of a bareword, it assumes you mean a module.</source>
          <target state="translated">对于字符串， &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 假定您要加载文件。但是对于裸字，它假设您是一个模块。</target>
        </trans-unit>
        <trans-unit id="92d133184cc1d94941d92f9ddbb74be254d7536c" translate="yes" xml:space="preserve">
          <source>In the case of an unrestricted hash this will be equivalent to</source>
          <target state="translated">在非限制性哈希的情况下,这将相当于</target>
        </trans-unit>
        <trans-unit id="9c7996f6bbe611631e0062a5b0c8688fa0df75c4" translate="yes" xml:space="preserve">
          <source>In the case of an unrestricted hash this will return an empty list.</source>
          <target state="translated">在非限制性哈希的情况下,这将返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="bbcb89949ef30fa331653e26c292cc6bfd5402d5" translate="yes" xml:space="preserve">
          <source>In the case of branching constructs like the following:</source>
          <target state="translated">在像下面这样的分支构造的情况下:</target>
        </trans-unit>
        <trans-unit id="235ed9f8205c1cb0e0f0c89543ab0c301b45cc8b" translate="yes" xml:space="preserve">
          <source>In the case where bsd_glob() has found some matching paths, but is interrupted by an error, it will return a list of filenames &lt;b&gt;and&lt;/b&gt; set &amp;amp;File::Glob::ERROR.</source>
          <target state="translated">如果bsd_glob（）找到了一些匹配的路径，但是由于错误而中断，它将返回文件名列表&lt;b&gt;并&lt;/b&gt;设置＆File :: Glob :: ERROR。</target>
        </trans-unit>
        <trans-unit id="ab44e54a843289d8fb48be15296e74831fd77123" translate="yes" xml:space="preserve">
          <source>In the cases of NFD, NFKD, and FCD, the answer must be either &lt;code&gt;YES&lt;/code&gt; or &lt;code&gt;NO&lt;/code&gt; . The answer &lt;code&gt;MAYBE&lt;/code&gt; may be returned in the cases of NFC, NFKC, and FCC.</source>
          <target state="translated">对于NFD，NFKD和FCD，答案必须为 &lt;code&gt;YES&lt;/code&gt; 或 &lt;code&gt;NO&lt;/code&gt; 。答案 &lt;code&gt;MAYBE&lt;/code&gt; 可以在NFC，NFKC和FCC的情况下返回。</target>
        </trans-unit>
        <trans-unit id="94e0ab2727afbd4185da2de81e38250408bd5cc4" translate="yes" xml:space="preserve">
          <source>In the code below, the use of &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; can all produce a &lt;code&gt;&quot;Useless use of xxx in void context&quot;&lt;/code&gt; warning.</source>
          <target state="translated">在下面的代码中，对 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 的使用都会产生 &lt;code&gt;&quot;Useless use of xxx in void context&quot;&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="8fd1596cdd97dc35baf217614ea25fccb283e4de" translate="yes" xml:space="preserve">
          <source>In the consideration of speed against memory requirements the balance has been tilted in favor of faster execution. This has influenced the way C compilers allocate memory for structures: On architectures where a 16-bit or 32-bit operand can be moved faster between places in memory, or to or from a CPU register, if it is aligned at an even or multiple-of-four or even at a multiple-of eight address, a C compiler will give you this speed benefit by stuffing extra bytes into structures. If you don't cross the C shoreline this is not likely to cause you any grief (although you should care when you design large data structures, or you want your code to be portable between architectures (you do want that, don't you?)).</source>
          <target state="translated">在考虑速度与内存需求的时候,平衡点一直倾向于更快的执行速度。这影响了C编译器为结构分配内存的方式。在一些架构上,16位或32位的操作数可以更快地在内存中的各个位置之间移动,或者从CPU寄存器中移动,如果它是在一个偶数或4的倍数甚至是8的倍数地址上对齐,C编译器会通过在结构中塞入额外的字节来给你速度上的好处。如果你不越过C岸线,这不可能给你带来任何麻烦(尽管当你设计大型数据结构时,或者你希望你的代码在不同架构之间可移植时,你应该在意(你确实希望这样,不是吗?))。</target>
        </trans-unit>
        <trans-unit id="9d33a076ef77a2ea3c1cd018606852167138e6c8" translate="yes" xml:space="preserve">
          <source>In the context of the</source>
          <target state="translated">在《公约》方面</target>
        </trans-unit>
        <trans-unit id="d491c48b25f3ad65e82b4c5c2097be0b50a9588c" translate="yes" xml:space="preserve">
          <source>In the current implementation, scalar constants are actually inlinable subroutines. As of version 5.004 of Perl, the appropriate scalar constant is inserted directly in place of some subroutine calls, thereby saving the overhead of a subroutine call. See &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;Constant Functions in perlsub&lt;/a&gt; for details about how and when this happens.</source>
          <target state="translated">在当前实现中，标量常量实际上是可插入的子例程。从Perl的5.004版本开始，直接插入适当的标量常量来代替某些子例程调用，从而节省了子例程调用的开销。有关如何以及何时发生这种情况的详细信息，请参见&lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;perlsub中的常量函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c0455a3b2b53d95f4e20ec0b4340a717b68f76c" translate="yes" xml:space="preserve">
          <source>In the default case where no value is explicitly assigned to &lt;code&gt;fallback&lt;/code&gt; , magic autogeneration is enabled.</source>
          <target state="translated">在默认情况下，未将值显式分配给 &lt;code&gt;fallback&lt;/code&gt; ，将启用魔术自动生成。</target>
        </trans-unit>
        <trans-unit id="9e4e78aa2b33a6d6dac51bbc3211d37de72733b0" translate="yes" xml:space="preserve">
          <source>In the default configuration, options names may be abbreviated to uniqueness, case does not matter, and a single dash is sufficient, even for long option names. Also, options may be placed between non-option arguments. See &lt;a href=&quot;#Configuring-Getopt%3a%3aLong&quot;&gt;Configuring Getopt::Long&lt;/a&gt; for more details on how to configure Getopt::Long.</source>
          <target state="translated">在默认配置中，选项名称可以缩写为唯一性，大小写无关紧要，即使长的选项名称也可以使用一个破折号。同样，可以在非选项参数之间放置选项。有关如何&lt;a href=&quot;#Configuring-Getopt%3a%3aLong&quot;&gt;配置Getopt :: Long&lt;/a&gt;的更多详细信息，请参见配置Getopt :: Long。</target>
        </trans-unit>
        <trans-unit id="e72101fd159fd0afaf983f558f5b87febb7113ce" translate="yes" xml:space="preserve">
          <source>In the description it is mentioned that</source>
          <target state="translated">说明中提到:</target>
        </trans-unit>
        <trans-unit id="ef03d8c00322da2ed4dc98f0803a382ee30a4ed1" translate="yes" xml:space="preserve">
          <source>In the diagram, the further right you go the more deeply nested the scope is. It is only when control is back with perl on the extreme left of the diagram that you will have dropped back to the enclosing scope and any temporaries you have left hanging around will be freed.</source>
          <target state="translated">在图中,越往右走,作用域的嵌套就越深。只有当控制与perl一起回到图的最左边时,你才会跌回包围的作用域,你留在周围的任何临时变量才会被释放。</target>
        </trans-unit>
        <trans-unit id="6f416a980a416e375bc66bc2d4fa36e45d3dee04" translate="yes" xml:space="preserve">
          <source>In the event that your XS code may need the underlying &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale, there are macros available to access this; see &lt;a href=&quot;perlapi#Locale-related-functions-and-macros&quot;&gt;Locale-related functions and macros in perlapi&lt;/a&gt;.</source>
          <target state="translated">如果您的XS代码可能需要底层的 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境，则可以使用宏来访问它。请参阅&lt;a href=&quot;perlapi#Locale-related-functions-and-macros&quot;&gt;perlapi中与语言环境相关的功能和宏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf76bf6bac3fdd00f94042b70f25cd2c0127da6a" translate="yes" xml:space="preserve">
          <source>In the example above $DB_HASH is actually a pre-defined reference to a hash object. &lt;b&gt;DB_File&lt;/b&gt; has three of these pre-defined references. Apart from $DB_HASH, there is also $DB_BTREE and $DB_RECNO.</source>
          <target state="translated">在上面的示例中，$ DB_HASH实际上是对哈希对象的预定义引用。&lt;b&gt;DB_File&lt;/b&gt;具有这些预定义引用中的三个。除了$ DB_HASH，还有$ DB_BTREE和$ DB_RECNO。</target>
        </trans-unit>
        <trans-unit id="383bad82dbf36df5fcbc2607474fc2833874c49f" translate="yes" xml:space="preserve">
          <source>In the example above, no file in</source>
          <target state="translated">在上面的例子中,没有文件在</target>
        </trans-unit>
        <trans-unit id="a6fdb80f186445ea957d140c9ee93d85c7f7bc67" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; method returns as soon as the thread ends. In addition to waiting for a thread to finish and gathering up any values that the thread might have returned, &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; also performs any OS cleanup necessary for the thread. That cleanup might be important, especially for long-running programs that spawn lots of threads. If you don't want the return values and don't want to wait for the thread to finish, you should call the &lt;code&gt;detach()&lt;/code&gt; method instead, as described next.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; 方法在线程结束时立即返回。除了等待线程完成并收集线程可能返回的任何值外， &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; 还执行该线程所需的所有OS清理。清理可能很重要，特别是对于产生大量线程的长时间运行的程序而言。如果您不希望返回值并且不想等待线程完成，则应改为调用 &lt;code&gt;detach()&lt;/code&gt; 方法，如下所述。</target>
        </trans-unit>
        <trans-unit id="e4fb9b67eb5a1d7e86fa97df408aad4ebc6c2e68" translate="yes" xml:space="preserve">
          <source>In the example above, the true parent does not want to write to the WRITER filehandle, so it closes it. However, because WRITER was opened using &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; , it has a special behavior: closing it calls waitpid() (see &lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;), which waits for the subprocess to exit. If the child process ends up waiting for something happening in the section marked &quot;do something else&quot;, you have deadlock.</source>
          <target state="translated">在上面的示例中，真正的父级不想写入WRITER文件句柄，因此将其关闭。但是，由于WRITER是使用 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; ，因此它具有特殊的行为：关闭它会调用waitpid（）（请参见&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;），该等待子进程退出。如果子进程最终在等待标记为&amp;ldquo;执行其他操作&amp;rdquo;的部分中发生的事情，则说明您陷入了僵局。</target>
        </trans-unit>
        <trans-unit id="e18ac50c69f2e5daf082fad97b93479b32118e7a" translate="yes" xml:space="preserve">
          <source>In the example above, we've created a global variable to temporarily store the computed value of our eval'ed expression. It is also possible and in most cases a better strategy to fetch the return value from</source>
          <target state="translated">在上面的例子中,我们创建了一个全局变量来暂时存储我们的 eval'ed 表达式的计算值。在大多数情况下,我们也可以从</target>
        </trans-unit>
        <trans-unit id="215f011f187069670df6baefac97d219cfd4d544" translate="yes" xml:space="preserve">
          <source>In the example above, you can see that we passed &lt;code&gt;isa =&amp;gt; 'Bool'&lt;/code&gt; to &lt;code&gt;has()&lt;/code&gt; when creating our &lt;code&gt;is_on&lt;/code&gt; attribute. This tells &lt;code&gt;Moose&lt;/code&gt; that this attribute must be a boolean value. If we try to set it to an invalid value, our code will throw an error.</source>
          <target state="translated">在上面的示例中，您可以看到在创建 &lt;code&gt;is_on&lt;/code&gt; 属性时，我们将 &lt;code&gt;isa =&amp;gt; 'Bool'&lt;/code&gt; 传递给 &lt;code&gt;has()&lt;/code&gt; 。这告诉 &lt;code&gt;Moose&lt;/code&gt; 该属性必须是布尔值。如果我们尝试将其设置为无效值，我们的代码将引发错误。</target>
        </trans-unit>
        <trans-unit id="7091546bde153dd7889f18e20c48c8bc55eaa567" translate="yes" xml:space="preserve">
          <source>In the example filter, the object (&lt;code&gt;$ref&lt;/code&gt; ) is blessed just like any other Perl object. Our example uses an anonymous array, but this isn't a requirement. Because this example doesn't need to store any context information, we could have used a scalar or hash reference just as well. The next section demonstrates context data.</source>
          <target state="translated">在示例过滤器中，对象（ &lt;code&gt;$ref&lt;/code&gt; ）就像其他任何Perl对象一样受到祝福。我们的示例使用匿名数组，但这不是必需的。因为此示例不需要存储任何上下文信息，所以我们也可以使用标量或哈希引用。下一节将演示上下文数据。</target>
        </trans-unit>
        <trans-unit id="7cad79aaf9d1ce6eabd545156fa679d72897f6d5" translate="yes" xml:space="preserve">
          <source>In the example script below, the &lt;code&gt;match&lt;/code&gt; sub uses this feature to find and print the first matching key/value pair given a partial key.</source>
          <target state="translated">在下面的示例脚本中， &lt;code&gt;match&lt;/code&gt; 子项使用此功能查找并打印给定部分键的第一个匹配键/值对。</target>
        </trans-unit>
        <trans-unit id="874b0ca5f6d74bc36f1a8bf750e4d758cb8b0d1e" translate="yes" xml:space="preserve">
          <source>In the examples above, we assigned the filehandle to a scalar variable before using it. That is because only simple scalar variables, not expressions or subscripts of hashes or arrays, can be used with built-ins like &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, or the diamond operator. Using something other than a simple scalar variable as a filehandle is illegal and won't even compile:</source>
          <target state="translated">在上面的示例中，我们在使用文件句柄之前将其分配给了标量变量。这是因为只能将简单的标量变量（而不是哈希或数组的表达式或下标）与诸如 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 或diamond运算符之类的内置函数一起使用。将简单标量变量以外的内容用作文件句柄是非法的，甚至不会编译：</target>
        </trans-unit>
        <trans-unit id="1d5cb1050428e1b3c39a6dbeac5fa82c4e3ee30c" translate="yes" xml:space="preserve">
          <source>In the examples given to date, any temporaries created in the callback (i.e., parameters passed on the stack to the</source>
          <target state="translated">在迄今为止给出的例子中,在回调中创建的任何时序(即在堆栈上传递给</target>
        </trans-unit>
        <trans-unit id="52df5ff09c57ff6bd4a65152023282e8e3fdf423" translate="yes" xml:space="preserve">
          <source>In the extended usage form, the references to be dumped can be given user-specified names. If a name begins with a &lt;code&gt;*&lt;/code&gt; , the output will describe the dereferenced type of the supplied reference for hashes and arrays, and coderefs. Output of names will be avoided where possible if the &lt;code&gt;Terse&lt;/code&gt; flag is set.</source>
          <target state="translated">在扩展使用形式中，可以为用户转储的引用指定用户指定的名称。如果名称以 &lt;code&gt;*&lt;/code&gt; 开头，则输出将描述哈希，数组和coderefs所提供引用的解引用类型。如果设置了 &lt;code&gt;Terse&lt;/code&gt; 标志，将尽可能避免输出名称。</target>
        </trans-unit>
        <trans-unit id="1e093183cde30fbf5834bc8c2f2306668f0a93ab" translate="yes" xml:space="preserve">
          <source>In the eyes of the operating system, pseudo-processes created via the fork() emulation are simply threads in the same process. This means that any process-level limits imposed by the operating system apply to all pseudo-processes taken together. This includes any limits imposed by the operating system on the number of open file, directory and socket handles, limits on disk space usage, limits on memory size, limits on CPU utilization etc.</source>
          <target state="translated">在操作系统看来,通过fork()仿真创建的伪进程只是同一进程中的线程。这意味着操作系统施加的任何进程级限制都适用于所有伪进程。这包括操作系统对打开的文件、目录和套接字句柄数量的任何限制,对磁盘空间使用的限制,对内存大小的限制,对CPU使用的限制等。</target>
        </trans-unit>
        <trans-unit id="c87855f737ebcf54612bd0d985e7951567552bdc" translate="yes" xml:space="preserve">
          <source>In the final example above, the first ASCII Hex digit is code point 48, the character &quot;0&quot;, and all code points from it through 57 (a &quot;9&quot;) are ASCII hex digits. Code points 58 through 64 aren't, but 65 (an &quot;A&quot;) through 70 (an &quot;F&quot;) are, as are 97 (&quot;a&quot;) through 102 (&quot;f&quot;). 103 starts a range of code points that aren't ASCII hex digits. That range extends to infinity, which on your computer can be found in the variable &lt;code&gt;$Unicode::UCD::MAX_CP&lt;/code&gt; . (This variable is as close to infinity as Perl can get on your platform, and may be too high for some operations to work; you may wish to use a smaller number for your purposes.)</source>
          <target state="translated">在上面的最后一个示例中，第一个ASCII十六进制数字是代码点48，字符&amp;ldquo; 0&amp;rdquo;，从此到57的所有代码点（&amp;ldquo; 9&amp;rdquo;）都是ASCII十六进制数字。代码点58到64不是，而代码点65（&amp;ldquo; A&amp;rdquo;）到70（&amp;ldquo; F&amp;rdquo;）则是97（&amp;ldquo; a&amp;rdquo;）到102（&amp;ldquo; f&amp;rdquo;）。 103会启动一系列非ASCII十六进制数字的代码点。该范围扩展到无穷大，您可以在计算机上的 &lt;code&gt;$Unicode::UCD::MAX_CP&lt;/code&gt; 变量中找到它。 （此变量与Perl可以在您的平台上获得的无限接近，并且对于某些操作而言可能太高；您可能希望为您的目的使用较小的数字。）</target>
        </trans-unit>
        <trans-unit id="acc9782ed3f3e2b680013d144689804f90d54bf6" translate="yes" xml:space="preserve">
          <source>In the first example, an error handler, the flow of control could be as follows. You have created an interface to an external library. Control can reach the external library like this</source>
          <target state="translated">在第一个例子中,一个错误处理程序,控制流程如下。你已经创建了一个外部库的接口。控制可以像这样到达外部库</target>
        </trans-unit>
        <trans-unit id="837426c8f21e7781853f5f83912529e607900661" translate="yes" xml:space="preserve">
          <source>In the first form, often referred to as a &quot;string eval&quot;, the return value of EXPR is parsed and executed as if it were a little Perl program. The value of the expression (which is itself determined within scalar context) is first parsed, and if there were no errors, executed as a block within the lexical context of the current Perl program. This means, that in particular, any outer lexical variables are visible to it, and any package variable settings or subroutine and format definitions remain afterwards.</source>
          <target state="translated">在第一种形式中,通常被称为 &quot;字符串评价&quot;,EXPR的返回值被解析,并像一个小Perl程序一样执行。首先对表达式的值(它本身是在标量上下文中确定的)进行解析,如果没有错误,则在当前Perl程序的词法上下文中作为一个块执行。这就意味着,特别是任何外在的词法变量对它都是可见的,而任何包变量设置或子程序和格式定义都会在之后保留。</target>
        </trans-unit>
        <trans-unit id="9907ef81620f333168bdff52969249681c5309f5" translate="yes" xml:space="preserve">
          <source>In the first form, registers an object to work with for the function &lt;code&gt;id_2obj()&lt;/code&gt; . In the second form, it additionally marks the given hashrefs down for garbage collection. This means that when the object goes out of scope, any entries in the given hashes under the key of &lt;code&gt;id($obj)&lt;/code&gt; will be deleted from the hashes.</source>
          <target state="translated">在第一种形式中，为功能 &lt;code&gt;id_2obj()&lt;/code&gt; 注册要使用的对象。在第二种形式中，它另外将给定的hashref标记为垃圾回收。这意味着，当对象超出范围时，将从 &lt;code&gt;id($obj)&lt;/code&gt; 中删除给定哈希中id（$ obj）键下的所有条目。</target>
        </trans-unit>
        <trans-unit id="886a42840b4db0f0804225c4bdd1da338f8eaea4" translate="yes" xml:space="preserve">
          <source>In the first form, the anonymous hash is being blessed into the class in &lt;code&gt;$class&lt;/code&gt; . In the second form, the anonymous hash is blessed into the current package.</source>
          <target state="translated">在第一种形式中，匿名哈希被加到 &lt;code&gt;$class&lt;/code&gt; 。在第二种形式中，匿名哈希被加到当前包中。</target>
        </trans-unit>
        <trans-unit id="5ba19d40237087370736921c2b055d0f9f4e8621" translate="yes" xml:space="preserve">
          <source>In the first two versions, the body of the subroutine is lexically in the main package,</source>
          <target state="translated">在前两个版本中,子程序的主体在主包中是词性的。</target>
        </trans-unit>
        <trans-unit id="78475acfd51fd678e0727a44ada7dcef5de0bc33" translate="yes" xml:space="preserve">
          <source>In the first version above, you let the appropriate encoding layer handle the conversion. In the second, you explicitly translate from one encoding to the other.</source>
          <target state="translated">在上面的第一个版本中,你让适当的编码层处理转换。在第二个版本中,你明确地从一种编码翻译到另一种编码。</target>
        </trans-unit>
        <trans-unit id="2414010bede2999a6fc168db89c621d8bb7bb77d" translate="yes" xml:space="preserve">
          <source>In the following all questions and explanations regarding config variables are collected.</source>
          <target state="translated">下面收集了所有关于配置变量的问题和解释。</target>
        </trans-unit>
        <trans-unit id="33eb6a227648440eaeed500f955607df47c5aa25" translate="yes" xml:space="preserve">
          <source>In the following examples, &lt;code&gt;$pad_len&lt;/code&gt; is the length to which you wish to pad the string, &lt;code&gt;$text&lt;/code&gt; or &lt;code&gt;$num&lt;/code&gt; contains the string to be padded, and &lt;code&gt;$pad_char&lt;/code&gt; contains the padding character. You can use a single character string constant instead of the &lt;code&gt;$pad_char&lt;/code&gt; variable if you know what it is in advance. And in the same way you can use an integer in place of &lt;code&gt;$pad_len&lt;/code&gt; if you know the pad length in advance.</source>
          <target state="translated">在以下示例中， &lt;code&gt;$pad_len&lt;/code&gt; 是希望填充字符串的长度， &lt;code&gt;$text&lt;/code&gt; 或 &lt;code&gt;$num&lt;/code&gt; 包含要填充的字符串，而 &lt;code&gt;$pad_char&lt;/code&gt; 包含填充字符。如果事先知道它是什么，则可以使用单个字符串常量代替 &lt;code&gt;$pad_char&lt;/code&gt; 变量。如果您事先知道填充长度，可以用同样的方式在 &lt;code&gt;$pad_len&lt;/code&gt; 处使用整数。</target>
        </trans-unit>
        <trans-unit id="76ac42f7d8b0a7d53378ec8bb6883cc947c8612a" translate="yes" xml:space="preserve">
          <source>In the following sections, these operators are covered in precedence order.</source>
          <target state="translated">在下面的章节中,这些运算符将按照优先顺序进行介绍。</target>
        </trans-unit>
        <trans-unit id="4b178b275b86ca37ae6642cdcf850388ebe0add6" translate="yes" xml:space="preserve">
          <source>In the following tables, numbers indicate priority. For example, the table below states that, if no implementation for &lt;code&gt;'!'&lt;/code&gt; has been defined then Perl will implement it using &lt;code&gt;'bool'&lt;/code&gt; (that is, by inverting the value returned by the method for &lt;code&gt;'bool'&lt;/code&gt; ); if boolean conversion is also unimplemented then Perl will use &lt;code&gt;'0+'&lt;/code&gt; or, failing that, &lt;code&gt;'&quot;&quot;'&lt;/code&gt; .</source>
          <target state="translated">在下表中，数字表示优先级。例如，下表指出，如果没有实现 &lt;code&gt;'!'&lt;/code&gt; 已经定义，那么Perl将使用 &lt;code&gt;'bool'&lt;/code&gt; 实现它（即，通过将 &lt;code&gt;'bool'&lt;/code&gt; 方法返回的值求反）；如果布尔转换也未实现，则Perl将使用 &lt;code&gt;'0+'&lt;/code&gt; ，否则将使用 &lt;code&gt;'&quot;&quot;'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8a38bcdad9de0c83d52fd95f8565a94b07788e8" translate="yes" xml:space="preserve">
          <source>In the following tables:</source>
          <target state="translated">在下表中:</target>
        </trans-unit>
        <trans-unit id="770598786b9fb05b86d05d808ab206b9dce08c07" translate="yes" xml:space="preserve">
          <source>In the form of pipe opens taking three or more arguments, if LIST is specified (extra arguments after the command name) then LIST becomes arguments to the command invoked if the platform supports it. The meaning of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; with more than three arguments for non-pipe modes is not yet defined, but experimental &quot;layers&quot; may give extra LIST arguments meaning.</source>
          <target state="translated">以管道打开的形式，接受三个或更多参数，如果指定了LIST（命令名后的其他参数），则LIST成为调用的命令的参数（如果平台支持）。对于非管道模式，具有三个以上自变量的 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 的含义尚未定义，但是实验性的&amp;ldquo;层&amp;rdquo;可能会提供额外的LIST自变量含义。</target>
        </trans-unit>
        <trans-unit id="351023ba55a42928810e8ea146d7f9a69c7e4007" translate="yes" xml:space="preserve">
          <source>In the form of pipe opens taking three or more arguments, if LIST is specified (extra arguments after the command name) then LIST becomes arguments to the command invoked if the platform supports it. The meaning of &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; with more than three arguments for non-pipe modes is not yet defined, but experimental &quot;layers&quot; may give extra LIST arguments meaning.</source>
          <target state="translated">以管道打开的形式，接受三个或更多参数，如果指定了LIST（命令名后的其他参数），则LIST成为调用的命令的参数（如果平台支持）。对于非管道模式，具有三个以上自变量的 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 的含义尚未定义，但是实验性的&amp;ldquo;层&amp;rdquo;可能会提供额外的LIST自变量含义。</target>
        </trans-unit>
        <trans-unit id="0d9756e636c498fe9304eb168ab8f26e641d5c72" translate="yes" xml:space="preserve">
          <source>In the future, this module will likely use File::Spec for determining paths, as it does now for Mac OS (where Unix-style or Mac-style paths work, and Unix-style paths are converted properly to Mac-style paths before being added to @INC).</source>
          <target state="translated">将来,这个模块可能会像现在的Mac OS一样,使用File::Spec来确定路径(Unix-style或Mac-style的路径都可以使用,Unix-style的路径在被添加到@INC之前会被适当地转换为Mac-style的路径)。</target>
        </trans-unit>
        <trans-unit id="46cedf56be184729e0d91d65fc9c0d53cad92704" translate="yes" xml:space="preserve">
          <source>In the last example, the end of the string is considered a word boundary.</source>
          <target state="translated">在最后一个例子中,字符串的结尾被认为是一个词的边界。</target>
        </trans-unit>
        <trans-unit id="6405a42cdbbb08be1356ae610a2c353a3021f6e3" translate="yes" xml:space="preserve">
          <source>In the last example, the whole string was matched, but only the part inside the single quotes was grouped. With the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. are immediately available for use in the replacement expression, so we use &lt;code&gt;$1&lt;/code&gt; to replace the quoted string with just what was quoted. With the global modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; will search and replace all occurrences of the regexp in the string:</source>
          <target state="translated">在最后一个示例中，整个字符串都已匹配，但是仅将单引号内的部分进行了分组。使用 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 运算符，匹配的变量 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等可立即在替换表达式中使用，因此我们使用 &lt;code&gt;$1&lt;/code&gt; 用引用的字符串替换引用的字符串。使用global修饰符， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; 将搜索并替换字符串中所有出现的regexp：</target>
        </trans-unit>
        <trans-unit id="06c06ffd743a05cb45342ceadd66f34d1f6c47cc" translate="yes" xml:space="preserve">
          <source>In the last regex, the forward slash &lt;code&gt;'/'&lt;/code&gt; is also backslashed, because it is used to delimit the regex.</source>
          <target state="translated">在最后一个正则表达式中，正斜杠 &lt;code&gt;'/'&lt;/code&gt; 也要反斜杠，因为它用于分隔正则表达式。</target>
        </trans-unit>
        <trans-unit id="11c4a29ccb7ab2ebd1eeaf108124208b060d0f4a" translate="yes" xml:space="preserve">
          <source>In the last regexp, the forward slash &lt;code&gt;'/'&lt;/code&gt; is also backslashed, because it is used to delimit the regexp. This can lead to LTS (leaning toothpick syndrome), however, and it is often more readable to change delimiters.</source>
          <target state="translated">在最后一个正则表达式中，正斜杠 &lt;code&gt;'/'&lt;/code&gt; 也要反斜杠，因为它用于分隔正则表达式。但是，这可能导致LTS（倾斜牙签综合征），并且更改分隔符通常更易读。</target>
        </trans-unit>
        <trans-unit id="3c351aa56c66843f422f8613ab5ba80764ad66e0" translate="yes" xml:space="preserve">
          <source>In the last statement, even though &lt;code&gt;'c'&lt;/code&gt; is the first character in the class, &lt;code&gt;'a'&lt;/code&gt; matches because the first character position in the string is the earliest point at which the regexp can match.</source>
          <target state="translated">在最后一条语句，即使 &lt;code&gt;'c'&lt;/code&gt; 是班上第一个字符， &lt;code&gt;'a'&lt;/code&gt; 匹配上，因为字符串中的第一个字符位置是最早的点，其正则表达式可以匹配。</target>
        </trans-unit>
        <trans-unit id="eb7827ba059fba337cd380ecde1e864bd7488e84" translate="yes" xml:space="preserve">
          <source>In the last statement, even though &lt;code&gt;'c'&lt;/code&gt; is the first character in the class, the earliest point at which the regex can match is &lt;code&gt;'a'&lt;/code&gt; .</source>
          <target state="translated">在最后一个语句中，即使 &lt;code&gt;'c'&lt;/code&gt; 是类中的第一个字符，但正则表达式可以匹配的最早点是 &lt;code&gt;'a'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d9813d8232f26905286fe72c0fb88aaeece44db" translate="yes" xml:space="preserve">
          <source>In the latter case, characters that map to 0212 are first converted to U+3013 (0xA2AE in EUC-JP; a white square also known as 'Tofu' or 'geta mark') then fed to the decoding engine. U+FFFD is not used, in order to preserve text layout as much as possible.</source>
          <target state="translated">在后一种情况下,映射到0212的字符首先被转换为U+3013(EUC-JP中的0xA2AE;一个白色的方块,也被称为 &quot;豆腐 &quot;或 &quot;geta mark&quot;),然后输入解码引擎。U+FFFD不用,是为了尽量保留文字布局。</target>
        </trans-unit>
        <trans-unit id="a8f8d594e47a7aed4b47d21c04c8b5fc5ac50b38" translate="yes" xml:space="preserve">
          <source>In the latter, foo.h is taken as</source>
          <target state="translated">在后一种情况下,foo.h被看作是</target>
        </trans-unit>
        <trans-unit id="9b81dfce26cb69eddfbb13b42d7a921ee8ba05af" translate="yes" xml:space="preserve">
          <source>In the list of parameters for an XSUB, one can precede parameter names by the &lt;code&gt;IN&lt;/code&gt; /&lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; keywords. &lt;code&gt;IN&lt;/code&gt; keyword is the default, the other keywords indicate how the Perl interface should differ from the C interface.</source>
          <target state="translated">在XSUB的参数列表中，可以在参数名称之前加上 &lt;code&gt;IN&lt;/code&gt; / &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; 关键字。 &lt;code&gt;IN&lt;/code&gt; 关键字是默认值，其他关键字指示Perl接口与C接口应该如何不同。</target>
        </trans-unit>
        <trans-unit id="6c32d4238ee6ff96fa8bb06b99ee3f8b0689422e" translate="yes" xml:space="preserve">
          <source>In the method descriptions below</source>
          <target state="translated">在下面的方法说明中</target>
        </trans-unit>
        <trans-unit id="1b237b2ec2e195bf52f7f15f0ad99e5a2c78e4b1" translate="yes" xml:space="preserve">
          <source>In the more general case, you can use the &lt;code&gt;/g&lt;/code&gt; modifier in a &lt;code&gt;while&lt;/code&gt; loop, keeping count of matches.</source>
          <target state="translated">在更一般的情况下，可以在 &lt;code&gt;while&lt;/code&gt; 循环中使用 &lt;code&gt;/g&lt;/code&gt; 修饰符，以保持匹配计数。</target>
        </trans-unit>
        <trans-unit id="784f063825aaf77ec4d5f9b15d7c0e7efc2377c9" translate="yes" xml:space="preserve">
          <source>In the mylib directory, create a file mylib.h that looks like this:</source>
          <target state="translated">在mylib目录下,创建一个mylib.h文件,看起来像这样。</target>
        </trans-unit>
        <trans-unit id="79fbf0c13d713302225cff8f61abd9dd7ac74b43" translate="yes" xml:space="preserve">
          <source>In the next paragraph follows a short description of terms used here (because these may differ from terms used by others people or documentation).</source>
          <target state="translated">在下一段中,将对这里使用的术语进行简要说明(因为这些术语可能与其他人或文件中使用的术语不同)。</target>
        </trans-unit>
        <trans-unit id="5152e34177e8a3d4c184b97093704f88de6ca9db" translate="yes" xml:space="preserve">
          <source>In the notation discussed so far, the characters &quot;[&quot; and &quot;]&quot; are given special meaning, for opening and closing bracket groups, and &quot;,&quot; has a special meaning inside bracket groups, where it separates items in the group. This begs the question of how you'd express a literal &quot;[&quot; or &quot;]&quot; in a Bracket Notation string, and how you'd express a literal comma inside a bracket group. For this purpose I've adopted &quot;~&quot; (tilde) as an escape character: &quot;~[&quot; means a literal '[' character anywhere in Bracket Notation (i.e., regardless of whether you're in a bracket group or not), and ditto for &quot;~]&quot; meaning a literal ']', and &quot;~,&quot; meaning a literal comma. (Altho &quot;,&quot; means a literal comma outside of bracket groups -- it's only inside bracket groups that commas are special.)</source>
          <target state="translated">在目前讨论的符号中,&quot;[&quot;和&quot;]&quot;这两个字符被赋予了特殊的含义,用于打开和关闭括号组,而&quot;,&quot;在括号组内有特殊的含义,在括号组内它分隔了组内的项目。这就引出了一个问题,那就是如何在括号符号字符串中表达字面的&quot;[&quot;或&quot;]&quot;,以及如何在括号组中表达字面的逗号。为此,我采用了&quot;~&quot;(tilde)作为转义字符。&quot;~[&quot;表示在括号内任何地方的'['字符 (也就是说,不管你是否在括号组内),&quot;~]&quot;表示']',&quot;~&quot;表示逗号。(虽然&quot;,&quot;表示在括号组之外的逗号--只有在括号组内,逗号才是特殊的。)</target>
        </trans-unit>
        <trans-unit id="9c42fcbdbf3cd24cfb1dac2e8ba1cbc829f18933" translate="yes" xml:space="preserve">
          <source>In the olden, less enlightened times, we all used to use ASCII. Most of us did, anyway. The big problem with ASCII is that it's American. Well, no, that's not actually the problem; the problem is that it's not particularly useful for people who don't use the Roman alphabet. What used to happen was that particular languages would stick their own alphabet in the upper range of the sequence, between 128 and 255. Of course, we then ended up with plenty of variants that weren't quite ASCII, and the whole point of it being a standard was lost.</source>
          <target state="translated">在以前,不那么开明的时代,我们都用ASCII码。反正我们大多数人都是这样做的。ASCII的最大问题是它是美国的。不,其实这不是问题,问题是它对不使用罗马字母的人来说并不是特别有用。过去发生的情况是,特定的语言会把自己的字母表贴在序列的上部范围,在128和255之间。当然,我们最后会有很多不完全是ASCII的变体,这就失去了作为标准的意义。</target>
        </trans-unit>
        <trans-unit id="50b947f69a6b2d22a725a2d7ba0813fc1f66f21b" translate="yes" xml:space="preserve">
          <source>In the one case the code, which does exactly the same thing as far as outputting any debugging information is concerned, in other words nothing, takes 14 seconds, and in the other case the code takes one hundredth of a second. Looks fairly definitive. Use a &lt;code&gt;$DEBUG&lt;/code&gt; variable BEFORE you call the subroutine, rather than relying on the smart functionality inside it.</source>
          <target state="translated">在一种情况下，该代码在输出任何调试信息方面的作用完全相同，换句话说，什么也没有，花费14秒，而在另一种情况下，该代码花费百分之一秒。看起来相当确定。在调用子例程之前，请使用 &lt;code&gt;$DEBUG&lt;/code&gt; 变量，而不要依赖其内部的智能功能。</target>
        </trans-unit>
        <trans-unit id="9cd2461949e5dab65a2af380d7f878aad8f12946" translate="yes" xml:space="preserve">
          <source>In the one- and two-argument forms of the call, the mode and filename should be concatenated (in that order), preferably separated by white space. You can--but shouldn't--omit the mode in these forms when that mode is &lt;code&gt;&amp;lt;&lt;/code&gt; . It is always safe to use the two-argument form of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; if the filename argument is a known literal.</source>
          <target state="translated">在调用的一参数和二参数形式中，应将模式和文件名连接起来（按此顺序），最好用空格隔开。当该模式为 &lt;code&gt;&amp;lt;&lt;/code&gt; 时，您可以-但不应-以这些形式省略该模式。如果filename参数是已知文字，则使用 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 的两个参数形式总是安全的。</target>
        </trans-unit>
        <trans-unit id="6c1895cc93a277f17a7d9aa8c8fca89d99b0c8a2" translate="yes" xml:space="preserve">
          <source>In the one- and two-argument forms of the call, the mode and filename should be concatenated (in that order), preferably separated by white space. You can--but shouldn't--omit the mode in these forms when that mode is &lt;code&gt;&amp;lt;&lt;/code&gt; . It is always safe to use the two-argument form of &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; if the filename argument is a known literal.</source>
          <target state="translated">在调用的一参数和二参数形式中，应将模式和文件名连接起来（按此顺序），最好用空格隔开。当该模式为 &lt;code&gt;&amp;lt;&lt;/code&gt; 时，您可以-但不应-以这些形式省略该模式。如果filename参数是已知文字，则使用 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 的两个参数形式总是安全的。</target>
        </trans-unit>
        <trans-unit id="9baa512a702be95a00f5cdfa9d3fa8d7a2a0b696" translate="yes" xml:space="preserve">
          <source>In the opposite way, to resolve a hostname to the IP address you can write this:</source>
          <target state="translated">反过来说,如果要把主机名解析成IP地址,可以这样写。</target>
        </trans-unit>
        <trans-unit id="ecb2e91137fed6da0013b83630021f3d72198be0" translate="yes" xml:space="preserve">
          <source>In the option specification, the option name is followed by an equals sign &lt;code&gt;=&lt;/code&gt; and the letter &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;. The equals sign indicates that this option requires a value. The letter &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; indicates that this value is an arbitrary string. Other possible value types are &lt;code&gt;i&lt;/code&gt; for integer values, and &lt;code&gt;f&lt;/code&gt; for floating point values. Using a colon &lt;code&gt;:&lt;/code&gt; instead of the equals sign indicates that the option value is optional. In this case, if no suitable value is supplied, string valued options get an empty string &lt;code&gt;''&lt;/code&gt; assigned, while numeric options are set to &lt;code&gt;0&lt;/code&gt; .</source>
          <target state="translated">在选项说明中，选项名称后跟等号 &lt;code&gt;=&lt;/code&gt; 和字母 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 。等号表示此选项需要一个值。字母 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 表示此值是一个任意字符串。其他可能的值类型是 &lt;code&gt;i&lt;/code&gt; (代表整数值）和 &lt;code&gt;f&lt;/code&gt; (代表浮点值）。使用冒号 &lt;code&gt;:&lt;/code&gt; 代替等号表示选项值是可选的。在这种情况下，如果没有提供合适的值，则将字符串值选项分配为空字符串 &lt;code&gt;''&lt;/code&gt; ，而将数字选项设置为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53db56988ad2d32c572da0df498153024ad7a10e" translate="yes" xml:space="preserve">
          <source>In the past, the Perl community experimented with a technique called &quot;inside-out objects&quot;. An inside-out object stores its data outside of the object's reference, indexed on a unique property of the object, such as its memory address, rather than in the object itself. This has the advantage of enforcing the encapsulation of object attributes, since their data is not stored in the object itself.</source>
          <target state="translated">过去,Perl社区曾试验过一种叫做 &quot;inside-out对象 &quot;的技术。内向外对象将其数据存储在对象的引用之外,以对象的一个独特属性为索引,例如其内存地址,而不是存储在对象本身。这样做的好处是强制封装对象的属性,因为它们的数据不存储在对象本身。</target>
        </trans-unit>
        <trans-unit id="8a3a725cb056826efb62b17fb21f5a5c69a3ce79" translate="yes" xml:space="preserve">
          <source>In the past, the leading &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; was optional, but omitting it would produce a deprecation warning. As of v5.22.0, omitting it produces a syntax error. If you encounter this construct in older code, you can just add &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">过去，以 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 开头的 &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; 是可选的，但是省略它会产生弃用警告。从v5.22.0开始，省略它会产生语法错误。如果您在较早的代码中遇到此构造，则只需添加 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 即可。</target>
        </trans-unit>
        <trans-unit id="3a63857af592db7e75d88e816c7c7a1180f9eb89" translate="yes" xml:space="preserve">
          <source>In the pathological case that a script is called via a relative path</source>
          <target state="translated">在病理情况下,脚本是通过相对路径调用。</target>
        </trans-unit>
        <trans-unit id="b5cb98f00aa6aaa22eb71c271690cbb1ebc9df81" translate="yes" xml:space="preserve">
          <source>In the pattern /\Bam\B/, there must be a word character before the &quot;a&quot; and after the &quot;m&quot;. These patterns match /\Bam\B/:</source>
          <target state="translated">在模式/Bam/B/中,&quot;a &quot;之前和 &quot;m &quot;之后必须有一个字。这些模式与/BamB/相匹配。</target>
        </trans-unit>
        <trans-unit id="d454ee791b9ae0c5bbb81657f656033f3c0c5a24" translate="yes" xml:space="preserve">
          <source>In the peculiar &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; form, VERSION may be either a positive decimal fraction such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a v-string of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter; Perl will not attempt to parse the rest of the file. Compare with &lt;a href=&quot;#require&quot;&gt;require&lt;/a&gt;, which can do a similar check at run time. Symmetrically, &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; allows you to specify that you want a version of Perl older than the specified one.</source>
          <target state="translated">在特殊 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; 格式中，VERSION可以是正十进制小数，例如5.006，将与 &lt;code&gt;$]&lt;/code&gt; 进行比较；也可以是v5.6.1形式的v字符串，将与 &lt;code&gt;$^V&lt;/code&gt; （也称为$ PERL_VERSION）。如果VERSION大于当前Perl解释器的版本，则会引发异常。 Perl不会尝试解析文件的其余部分。与&lt;a href=&quot;#require&quot;&gt;require相比&lt;/a&gt;，后者可以在运行时进行类似的检查。对称地， &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; 允许您指定要比指定版本早的Perl版本。</target>
        </trans-unit>
        <trans-unit id="74d3b7e92857ff92a78ee1a11cb1e6022b249cb3" translate="yes" xml:space="preserve">
          <source>In the peculiar &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; form, VERSION may be either a positive decimal fraction such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a v-string of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter; Perl will not attempt to parse the rest of the file. Compare with &lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;, which can do a similar check at run time. Symmetrically, &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; allows you to specify that you want a version of Perl older than the specified one.</source>
          <target state="translated">在特殊 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; 格式中，VERSION可以是正十进制小数，例如5.006，将与 &lt;code&gt;$]&lt;/code&gt; 进行比较；也可以是v5.6.1形式的v字符串，将与 &lt;code&gt;$^V&lt;/code&gt; （也称为$ PERL_VERSION）。如果VERSION大于当前Perl解释器的版本，则会引发异常。 Perl不会尝试解析文件的其余部分。与&lt;a href=&quot;require&quot;&gt;require相比&lt;/a&gt;，后者可以在运行时进行类似的检查。对称地， &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; 允许您指定要比指定版本早的Perl版本。</target>
        </trans-unit>
        <trans-unit id="a5da666074fc2ec75362b3b68f86858be734f6e9" translate="yes" xml:space="preserve">
          <source>In the presence of multiple classes it can be non-trivial to make sure that every relevant destructor is called for every object. Perl calls the first one it finds on the inheritance tree (if any) and that's it.</source>
          <target state="translated">在有多个类的情况下,要确保每个对象都调用了相关的析构器,这可能是一件不容易的事情。Perl 调用它在继承树上找到的第一个类(如果有的话),就这样。</target>
        </trans-unit>
        <trans-unit id="cd34d34a3c68755abc29d11ed297638bd9fdb29d" translate="yes" xml:space="preserve">
          <source>In the presence of the &lt;code&gt;REXEC_COPY_STR&lt;/code&gt; flag, but with the addition of the &lt;code&gt;REXEC_COPY_SKIP_PRE&lt;/code&gt; or &lt;code&gt;REXEC_COPY_SKIP_POST&lt;/code&gt; flags, an engine can choose not to copy the full buffer (although it must still do so in the presence of &lt;code&gt;RXf_PMf_KEEPCOPY&lt;/code&gt; or the relevant bits being set in &lt;code&gt;PL_sawampersand&lt;/code&gt; ). In this case, it may set &lt;code&gt;suboffset&lt;/code&gt; to indicate the number of bytes from the logical start of the buffer to the physical start (i.e. &lt;code&gt;subbeg&lt;/code&gt; ). It should also set &lt;code&gt;subcoffset&lt;/code&gt; , the number of characters in the offset. The latter is needed to support &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; which work in characters, not bytes.</source>
          <target state="translated">在存在 &lt;code&gt;REXEC_COPY_STR&lt;/code&gt; 标志的情况下，但添加了 &lt;code&gt;REXEC_COPY_SKIP_PRE&lt;/code&gt; 或 &lt;code&gt;REXEC_COPY_SKIP_POST&lt;/code&gt; 标志，引擎可以选择不复制完整缓冲区（尽管在 &lt;code&gt;RXf_PMf_KEEPCOPY&lt;/code&gt; 或PL_sawampersand中设置了相关位的情况下，它仍必须 &lt;code&gt;PL_sawampersand&lt;/code&gt; ） 。在这种情况下，它可以设置 &lt;code&gt;suboffset&lt;/code&gt; 来指示从缓冲区的逻辑开始到物理开始（即 &lt;code&gt;subbeg&lt;/code&gt; ）的字节数。它还应该设置 &lt;code&gt;subcoffset&lt;/code&gt; ，即偏移量中的字符数。需要后者来支持 &lt;code&gt;@-&lt;/code&gt; 和 &lt;code&gt;@+&lt;/code&gt; ，它们以字符而不是字节工作。</target>
        </trans-unit>
        <trans-unit id="b073c0a34c41b3ba5f06418d694ba351020d4acc" translate="yes" xml:space="preserve">
          <source>In the previous example, you created a function-private variable because only one function remembered its reference. You could define multiple functions while the variable is in scope, and each function can share the &quot;private&quot; variable. It's not really &quot;static&quot; because you can access it outside the function while the lexical variable is in scope, and even create references to it. In this example, &lt;code&gt;increment_count&lt;/code&gt; and &lt;code&gt;return_count&lt;/code&gt; share the variable. One function adds to the value and the other simply returns the value. They can both access &lt;code&gt;$count&lt;/code&gt; , and since it has gone out of scope, there is no other way to access it.</source>
          <target state="translated">在前面的示例中，您创建了一个function-private变量，因为只有一个函数记住了它的引用。您可以在变量处于范围内时定义多个函数，并且每个函数可以共享&amp;ldquo;私有&amp;rdquo;变量。它并不是真正的&amp;ldquo;静态&amp;rdquo;，因为您可以在词法变量处于范围内时在函数外部访问它，甚至创建对其的引用。在此示例中， &lt;code&gt;increment_count&lt;/code&gt; 和 &lt;code&gt;return_count&lt;/code&gt; 共享变量。一个函数加到值上，另一个简单地返回值。他们都可以访问 &lt;code&gt;$count&lt;/code&gt; ，并且由于它超出了范围，因此没有其他方法可以访问它。</target>
        </trans-unit>
        <trans-unit id="d099eddc17fd02123a62f3b5a7b0e3fc3ac46d20" translate="yes" xml:space="preserve">
          <source>In the previous examples, the &lt;code&gt;{}&lt;/code&gt; code creates a reference to an empty anonymous hash. The &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function then takes that reference and associates the hash with the class in &lt;code&gt;$class&lt;/code&gt; . In the simplest case, the &lt;code&gt;$class&lt;/code&gt; variable will end up containing the string &quot;File&quot;.</source>
          <target state="translated">在前面的示例中， &lt;code&gt;{}&lt;/code&gt; 代码创建对空匿名哈希的引用。然后， &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 函数获取该引用，并将哈希与 &lt;code&gt;$class&lt;/code&gt; 的类相关联。在最简单的情况下， &lt;code&gt;$class&lt;/code&gt; 变量最终将包含字符串&amp;ldquo; File&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c1001ba58ff0530a993f349b4836f78782ab43f8" translate="yes" xml:space="preserve">
          <source>In the previous section we've seen a network message that was constructed by prefixing the binary message length to the actual message. You'll find that packing a length followed by so many bytes of data is a frequently used recipe since appending a null byte won't work if a null byte may be part of the data. Here is an example where both techniques are used: after two null terminated strings with source and destination address, a Short Message (to a mobile phone) is sent after a length byte:</source>
          <target state="translated">在上一节中,我们已经看到了一个网络消息,它是通过将二进制消息长度前缀到实际消息中来构造的。你会发现,在这么多字节的数据后面包装一个长度是一个经常使用的秘诀,因为如果一个空字节可能是数据的一部分,那么附加一个空字节是行不通的。下面是一个同时使用两种技术的例子:在两个带有源地址和目的地址的空端字符串之后,在一个长度字节之后发送一个短消息(到手机)。</target>
        </trans-unit>
        <trans-unit id="4d306b4b58fb980badf24b06473c4af8a30ac12e" translate="yes" xml:space="preserve">
          <source>In the previous sections we've learned how to use &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; to pack and unpack integers with big- or little-endian byte-order. While this is nice, it's still rather limited because it leaves out all kinds of signed integers as well as 64-bit integers. For example, if you wanted to unpack a sequence of signed big-endian 16-bit integers in a platform-independent way, you would have to write:</source>
          <target state="translated">在前面的部分中，我们学习了如何使用 &lt;code&gt;n&lt;/code&gt; ， &lt;code&gt;N&lt;/code&gt; ， &lt;code&gt;v&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 打包和解包具有大尾数字节顺序的字节序。尽管这很好，但是它仍然相当有限，因为它忽略了所有有符号整数和64位整数。例如，如果要以独立于平台的方式解压缩有符号的大端16位整数序列，则必须编写：</target>
        </trans-unit>
        <trans-unit id="4bb18f0a7b082417093abe50cb091ae0ce9d7c1a" translate="yes" xml:space="preserve">
          <source>In the rare case in which you need to discover at run time whether a particular constant has been declared via this module, you may use this function to examine the hash &lt;code&gt;%constant::declared&lt;/code&gt; . If the given constant name does not include a package name, the current package is used.</source>
          <target state="translated">在极少数情况下，您需要在运行时发现是否已通过此模块声明了特定的常量，可以使用此函数检查哈希 &lt;code&gt;%constant::declared&lt;/code&gt; 。如果给定的常量名称不包含程序包名称，则使用当前程序包。</target>
        </trans-unit>
        <trans-unit id="b3168d71bbd1d6362a03e87b3b6357cbc463ee97" translate="yes" xml:space="preserve">
          <source>In the scalar context, returns the modified collator (but it is &lt;b&gt;not&lt;/b&gt; a clone from the original).</source>
          <target state="translated">在标量上下文中，返回修改后的排序规则（但它&lt;b&gt;不是&lt;/b&gt;原始副本的副本）。</target>
        </trans-unit>
        <trans-unit id="4e123d33b9c36acd15c038a592d06bccf26e5a4c" translate="yes" xml:space="preserve">
          <source>In the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , Perl obeys the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale setting. This controls the application's notion of which characters are alphabetic, numeric, punctuation,</source>
          <target state="translated">在包含 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 形式的范围内，Perl遵循 &lt;code&gt;LC_CTYPE&lt;/code&gt; 语言环境设置。这控制了应用程序的字母，数字，标点符号，</target>
        </trans-unit>
        <trans-unit id="ea3c9a616e33a3cad4631e8af654cde72ce4e1bd" translate="yes" xml:space="preserve">
          <source>In the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes collation, Perl looks to the &lt;code&gt;LC_COLLATE&lt;/code&gt; environment variable to determine the application's notions on collation (ordering) of characters. For example, &quot;b&quot; follows &quot;a&quot; in Latin alphabets, but where do &quot;&amp;aacute;&quot; and &quot;&amp;aring;&quot; belong? And while &quot;color&quot; follows &quot;chocolate&quot; in English, what about in traditional Spanish?</source>
          <target state="translated">在包括排序规则的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 形式的范围内，Perl会查找 &lt;code&gt;LC_COLLATE&lt;/code&gt; 环境变量，以确定应用程序的字符排序规则（排序）概念。例如，拉丁字母中的&amp;ldquo; b&amp;rdquo;后面是&amp;ldquo; b&amp;rdquo;，但是&amp;ldquo;&amp;aacute;&amp;rdquo;和&amp;ldquo;&amp;aring;&amp;rdquo;在哪里？虽然英语中的&amp;ldquo;颜色&amp;rdquo;跟在&amp;ldquo;巧克力&amp;rdquo;之后，但传统的西班牙呢？</target>
        </trans-unit>
        <trans-unit id="85dc6b4df5881b7609167c49737d8fd061975bdc" translate="yes" xml:space="preserve">
          <source>In the second example, an event driven program, the flow of control will be more like this</source>
          <target state="translated">在第二个例子中,一个事件驱动的程序,控制的流程将更像这样</target>
        </trans-unit>
        <trans-unit id="0aec5f41df04fa608d73972b5b60d0e21665dd44" translate="yes" xml:space="preserve">
          <source>In the second example, however, we have stored another reference to the tied object in $x. That means that when untie() gets called there will still be a valid reference to the object in existence, so the destructor is not called at that time, and thus the file is not closed. The reason there is no output is because the file buffers have not been flushed to disk.</source>
          <target state="translated">然而,在第二个例子中,我们在$x中存储了对绑定对象的另一个引用。这意味着当untie()被调用时,仍然会有一个有效的对象引用存在,所以当时没有调用destructor,因此文件没有被关闭。之所以没有输出,是因为文件缓冲区没有被刷新到磁盘。</target>
        </trans-unit>
        <trans-unit id="69631891c8053c89e0b6bca3447bddf1c255a6c7" translate="yes" xml:space="preserve">
          <source>In the second form, the code within the BLOCK is parsed only once--at the same time the code surrounding the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself was parsed--and executed within the context of the current Perl program. This form is typically used to trap exceptions more efficiently than the first (see below), while also providing the benefit of checking the code within BLOCK at compile time.</source>
          <target state="translated">在第二种形式中，仅对BLOCK中的代码进行一次解析-同时解析与 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 本身相关的代码-并在当前Perl程序的上下文中执行。这种形式通常用于比第一种形式更有效地捕获异常（请参见下文），同时还具有在编译时检查BLOCK中的代码的好处。</target>
        </trans-unit>
        <trans-unit id="4a4b1f50ba31b2407de5a923935b79599705457e" translate="yes" xml:space="preserve">
          <source>In the second form, the code within the BLOCK is parsed only once--at the same time the code surrounding the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself was parsed--and executed within the context of the current Perl program. This form is typically used to trap exceptions more efficiently than the first (see below), while also providing the benefit of checking the code within BLOCK at compile time.</source>
          <target state="translated">在第二种形式中，仅对BLOCK中的代码进行一次解析-同时解析与 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 本身相关的代码-并在当前Perl程序的上下文中执行。这种形式通常用于比第一种形式更有效地捕获异常（请参见下文），同时还具有在编译时检查BLOCK中的代码的好处。</target>
        </trans-unit>
        <trans-unit id="0d9a2ff0446afe648b7cb9385c3e87c463ddf6fa" translate="yes" xml:space="preserve">
          <source>In the second match, &lt;code&gt;$`&lt;/code&gt; equals &lt;code&gt;''&lt;/code&gt; because the regexp matched at the first character position in the string and stopped; it never saw the second 'the'.</source>
          <target state="translated">在第二个匹配项中， &lt;code&gt;$`&lt;/code&gt; 等于 &lt;code&gt;''&lt;/code&gt; 因为正则表达式在字符串的第一个字符位置匹配并停止；它从未见过第二个&amp;ldquo; the&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="37e9c3cdd59dd9ca84f70e11b37a63713067a365" translate="yes" xml:space="preserve">
          <source>In the second step, the free inheritability of the implementation (or lack thereof) is demonstrated. For this purpose it constructs a class called &lt;code&gt;NamedFile&lt;/code&gt; which is a common subclass of &lt;code&gt;Name&lt;/code&gt; and the standard class &lt;code&gt;IO::File&lt;/code&gt; . This puts inheritability to the test because objects of &lt;code&gt;IO::File&lt;/code&gt;</source>
          <target state="translated">在第二步中，演示了实现的自由继承性（或缺少实现）。为此，它构造了一个名为 &lt;code&gt;NamedFile&lt;/code&gt; 的类，该类是 &lt;code&gt;Name&lt;/code&gt; 的常见子类，并且是标准类 &lt;code&gt;IO::File&lt;/code&gt; 。由于 &lt;code&gt;IO::File&lt;/code&gt; 对象，因此对可继承性进行了测试</target>
        </trans-unit>
        <trans-unit id="979450caa584768989298a5e328245eeac253de3" translate="yes" xml:space="preserve">
          <source>In the strictest sense, it can't be done--the script executes as a different process from the shell it was started from. Changes to a process are not reflected in its parent--only in any children created after the change. There is shell magic that may allow you to fake it by &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;ing the script's output in your shell; check out the comp.unix.questions FAQ for details.</source>
          <target state="translated">从最严格的意义上讲，这是无法完成的-脚本执行的过程与启动时所执行的shell不同。对流程的更改不会反映在其父级中，而只会反映在更改后创建的任何子级中。有一些外壳魔术可以让您通过在外壳中通过 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 脚本输出来伪造它。有关详细信息，请查看comp.unix.questions常见问题解答。</target>
        </trans-unit>
        <trans-unit id="8d5c6294b971049c13607515864de8d9b4202e94" translate="yes" xml:space="preserve">
          <source>In the symbian subdirectory there is</source>
          <target state="translated">在symbian子目录下有</target>
        </trans-unit>
        <trans-unit id="a6664c3e7887f18c07bf996abcbf98da47057e7d" translate="yes" xml:space="preserve">
          <source>In the syntax descriptions that follow, list operators that expect a list (and provide list context for elements of the list) are shown with LIST as an argument. Such a list may consist of any combination of scalar arguments or list values; the list values will be included in the list as if each individual element were interpolated at that point in the list, forming a longer single-dimensional list value. Commas should separate literal elements of the LIST.</source>
          <target state="translated">在下面的语法描述中,期望得到一个列表(并为列表中的元素提供列表上下文)的列表运算符以LIST作为参数显示。这样的列表可以由标量参数或列表值的任意组合组成;列表值将被包含在列表中,就像每个单独的元素在列表中的那个点被插值一样,形成一个较长的单维列表值。逗号应分隔list的文字元素。</target>
        </trans-unit>
        <trans-unit id="fe67245ac84887f626543e24a3e6a624b4a7332b" translate="yes" xml:space="preserve">
          <source>In the tie() call, &lt;code&gt;VARIABLE&lt;/code&gt; is the name of the variable to be enchanted. &lt;code&gt;CLASSNAME&lt;/code&gt; is the name of a class implementing objects of the correct type. Any additional arguments in the &lt;code&gt;LIST&lt;/code&gt; are passed to the appropriate constructor method for that class--meaning TIESCALAR(), TIEARRAY(), TIEHASH(), or TIEHANDLE(). (Typically these are arguments such as might be passed to the dbminit() function of C.) The object returned by the &quot;new&quot; method is also returned by the tie() function, which would be useful if you wanted to access other methods in &lt;code&gt;CLASSNAME&lt;/code&gt; . (You don't actually have to return a reference to a right &quot;type&quot; (e.g., HASH or &lt;code&gt;CLASSNAME&lt;/code&gt; ) so long as it's a properly blessed object.) You can also retrieve a reference to the underlying object using the tied() function.</source>
          <target state="translated">在tie（）调用中， &lt;code&gt;VARIABLE&lt;/code&gt; 是要附魔的变量的名称。 &lt;code&gt;CLASSNAME&lt;/code&gt; 是实现正确类型的对象的类的名称。 &lt;code&gt;LIST&lt;/code&gt; 中的所有其他参数都将传递给该类的适当的构造方法-意味着TIESCALAR（），TIEARRAY（），TIEHASH（）或TIEHANDLE（）。 （通常这些参数可以传递给C的dbminit（）函数。）&amp;ldquo; new&amp;rdquo;方法返回的对象也由tie（）函数返回，如果您想访问其他方法，这将很有用。在 &lt;code&gt;CLASSNAME&lt;/code&gt; 中。 （实际上，您不必返回对正确的&amp;ldquo;类型&amp;rdquo;的引用（例如，HASH或 &lt;code&gt;CLASSNAME&lt;/code&gt; ），只要它是正确的对象即可。）您还可以使用tie（）函数检索对基础对象的引用。</target>
        </trans-unit>
        <trans-unit id="72e605f529d11854bba56a166fe10700b1dd88fb" translate="yes" xml:space="preserve">
          <source>In the two-argument (and one-argument) form, opening &lt;code&gt;&amp;lt;-&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; opens STDIN and opening &lt;code&gt;&amp;gt;-&lt;/code&gt; opens STDOUT.</source>
          <target state="translated">在两个参数（和一个参数）形式中，打开 &lt;code&gt;&amp;lt;-&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; 打开STDIN，打开 &lt;code&gt;&amp;gt;-&lt;/code&gt; 打开STDOUT。</target>
        </trans-unit>
        <trans-unit id="305b7a93b43681322f3469e0f0cb84a704ec6817" translate="yes" xml:space="preserve">
          <source>In the unlikely case of a SV requiring more complex initialization, you can create an empty SV with newSV(len). If &lt;code&gt;len&lt;/code&gt; is 0 an empty SV of type NULL is returned, else an SV of type PV is returned with len + 1 (for the &lt;code&gt;NUL&lt;/code&gt; ) bytes of storage allocated, accessible via SvPVX. In both cases the SV has the undef value.</source>
          <target state="translated">在不太可能的SV需要更复杂的初始化的情况下，可以使用newSV（len）创建一个空SV。如果 &lt;code&gt;len&lt;/code&gt; 为0，则返回NULL类型的空SV，否则返回PV类型的SV，并分配len + 1（对于 &lt;code&gt;NUL&lt;/code&gt; ）字节的已分配存储空间，可通过SvPVX访问。在这两种情况下，SV都具有undef值。</target>
        </trans-unit>
        <trans-unit id="e08f73822da4db28b0244d63be2806e6742a13f9" translate="yes" xml:space="preserve">
          <source>In the words of Chaim Frenkel: &quot;Perl's grammar can not be reduced to BNF. The work of parsing perl is distributed between yacc, the lexer, smoke and mirrors.&quot;</source>
          <target state="translated">用Chaim Frenkel的话说:&quot;Perl的语法不能简化为BNF。解析perl的工作是在yacc、词典、烟雾和镜子之间进行的&quot;。</target>
        </trans-unit>
        <trans-unit id="eea8935b77be896004ea3b86596d8c4b9f389127" translate="yes" xml:space="preserve">
          <source>In the work crew model, several threads are created that do essentially the same thing to different pieces of data. It closely mirrors classical parallel processing and vector processors, where a large array of processors do the exact same thing to many pieces of data.</source>
          <target state="translated">在工作团队模型中,创建了多个线程,这些线程对不同的数据做着基本相同的事情。它密切反映了经典的并行处理和向量处理器,在这些处理器中,大量的处理器对许多数据做着完全相同的事情。</target>
        </trans-unit>
        <trans-unit id="c55ef95af3c2d0a3702a06238a73d0da82b1e62b" translate="yes" xml:space="preserve">
          <source>In the year 2010 App::cpanminus was launched as a new approach to a cpan shell with a considerably smaller footprint. Very cool stuff.</source>
          <target state="translated">在2010年,App::cpanminus作为一个新的方法,推出了一个小得多的cpan shell。非常酷的东西。</target>
        </trans-unit>
        <trans-unit id="113762dd3316218250364ac4d21aa3eda82fed63" translate="yes" xml:space="preserve">
          <source>In theory &lt;code&gt;Strtol&lt;/code&gt; and &lt;code&gt;Strtoul&lt;/code&gt; may not be defined if the machine perl is built on doesn't actually have strtol and strtoul. But as those 2 functions are part of the 1989 ANSI C spec we suspect you'll find them everywhere by now.</source>
          <target state="translated">从理论 &lt;code&gt;Strtol&lt;/code&gt; ，如果构建在机器perl上的机器实际上没有strtol和strtoul ， &lt;code&gt;Strtoul&lt;/code&gt; 可能不会定义Strtol和Strtoul。但是，由于这两个函数是1989年ANSI C规范的一部分，因此我们怀疑您到处都可以找到它们。</target>
        </trans-unit>
        <trans-unit id="d524f396baff67e45d81dc7f8d13d5cf1e77d980" translate="yes" xml:space="preserve">
          <source>In theory, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; is reliable from -2**63 to 2**63-1. However, because work arounds in the implementation use floating point numbers, it will become inaccurate as the time gets larger. This is a bug and will be fixed in the future.</source>
          <target state="translated">从理论上讲， &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 在-2 ** 63到2 ** 63-1之间是可靠的。但是，由于实现中的变通方法使用浮点数，因此随着时间变大，它将变得不准确。这是一个错误，将来会修复。</target>
        </trans-unit>
        <trans-unit id="cbe5df9e111a076eb83a7b1ca2b907e2c293b988" translate="yes" xml:space="preserve">
          <source>In these loop constructs, the assigned value (whether assignment is automatic or explicit) is then tested to see whether it is defined. The defined test avoids problems where the line has a string value that would be treated as false by Perl; for example a &quot;&quot; or a &lt;code&gt;&quot;0&quot;&lt;/code&gt; with no trailing newline. If you really mean for such values to terminate the loop, they should be tested for explicitly:</source>
          <target state="translated">在这些循环结构中，然后测试分配的值（分配是自动的还是显式的），以查看其是否已定义。定义的测试可避免出现以下问题：当行中的字符串值被Perl视为false时；例如没有尾随换行符的&amp;ldquo;&amp;rdquo;或 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 。如果您真的想让这些值终止循环，则应该对其进行显式测试：</target>
        </trans-unit>
        <trans-unit id="6e44b8059bd25cac80d7a80701ceeb87c0cc485a" translate="yes" xml:space="preserve">
          <source>In this -exec rendering, each opcode is executed in the order shown. The add opcode, marked with '*', is discussed in more detail.</source>
          <target state="translated">在这个-exec渲染中,每个操作码都是按照所示顺序执行的。用'*'标记的add opcode将被详细讨论。</target>
        </trans-unit>
        <trans-unit id="fd1f4af2f36f22296f6e12cb734299d228fd203a" translate="yes" xml:space="preserve">
          <source>In this alternation, it is important to put &lt;code&gt;'\d+\.\d+'&lt;/code&gt; before &lt;code&gt;'\d+\.'&lt;/code&gt; . If &lt;code&gt;'\d+\.'&lt;/code&gt; were first, the regexp would happily match that and ignore the fractional part of the number.</source>
          <target state="translated">在这种替换方式中，将 &lt;code&gt;'\d+\.\d+'&lt;/code&gt; 放在'\ d + \'前面很重要 &lt;code&gt;'\d+\.'&lt;/code&gt; 。如果是 &lt;code&gt;'\d+\.'&lt;/code&gt; 首先，正则表达式会很高兴地与之匹配，而忽略数字的小数部分。</target>
        </trans-unit>
        <trans-unit id="c0e19afab75cca33f669db41034484d08b958820" translate="yes" xml:space="preserve">
          <source>In this call,</source>
          <target state="translated">在这个电话里。</target>
        </trans-unit>
        <trans-unit id="6f085ed6c4e3052eb0bb052f156e9a4157a1fe5d" translate="yes" xml:space="preserve">
          <source>In this call, the two arrays will be populated as shown below (for Unicode 6.0):</source>
          <target state="translated">在这个调用中,两个数组将被填充,如下所示(对于Unicode 6.0)。</target>
        </trans-unit>
        <trans-unit id="9ebdd72fd702032acef9641f741ed417c8e827d9" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;IO::Compress::Zip&lt;/code&gt; will check that &lt;code&gt;$rawdata&lt;/code&gt; consists of zero or more conformant sub-fields.</source>
          <target state="translated">在这种情况下， &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 将检查 &lt;code&gt;$rawdata&lt;/code&gt; 包含零个或更多个一致的子字段。</target>
        </trans-unit>
        <trans-unit id="7445390dec364c96fb636b6c3a3e08bbc004467f" translate="yes" xml:space="preserve">
          <source>In this case a possible way around this problem is to predefine a series of C functions to act as the interface to Perl, thus</source>
          <target state="translated">在这种情况下,解决这个问题的一个可能的方法是预先定义一系列的C函数作为Perl的接口,因此</target>
        </trans-unit>
        <trans-unit id="e58eeb1fce65fa0151692bc12dbf74ccd83c8127" translate="yes" xml:space="preserve">
          <source>In this case it is possible to speed up the routine (often quite substantially) by using the lightweight callback API. The idea is that the calling context only needs to be created and destroyed once, and the sub can be called arbitrarily many times in between.</source>
          <target state="translated">在这种情况下,可以通过使用轻量级回调API来加快例程的运行速度(通常是相当大的速度)。我们的想法是,调用上下文只需要创建和销毁一次,而子可以在中间任意调用很多次。</target>
        </trans-unit>
        <trans-unit id="7a45b342cd0260187347347f25fa6f1ce0fc4500" translate="yes" xml:space="preserve">
          <source>In this case the flow of control can consist of only the repeated sequence</source>
          <target state="translated">在这种情况下,控制流可以只包括重复的序列,即</target>
        </trans-unit>
        <trans-unit id="de52280d051bfe1e84ce26c045f4bd463f4ae0ee" translate="yes" xml:space="preserve">
          <source>In this case the functions &lt;code&gt;fn1&lt;/code&gt; , &lt;code&gt;fn2&lt;/code&gt; , and &lt;code&gt;fn3&lt;/code&gt; are used to remember the Perl subroutine to be called. Each of the functions holds a separate hard-wired index which is used in the function &lt;code&gt;Pcb&lt;/code&gt; to access the &lt;code&gt;Map&lt;/code&gt; array and actually call the Perl subroutine.</source>
          <target state="translated">在这种情况下，函数 &lt;code&gt;fn1&lt;/code&gt; ， &lt;code&gt;fn2&lt;/code&gt; 和 &lt;code&gt;fn3&lt;/code&gt; 用于记住要调用的Perl子例程。每个函数都有一个单独的硬连线索引，该索引在函数 &lt;code&gt;Pcb&lt;/code&gt; 中用于访问 &lt;code&gt;Map&lt;/code&gt; 数组并实际调用Perl子例程。</target>
        </trans-unit>
        <trans-unit id="4ba717b73fce507fddc399244f240ef5b6f054dd" translate="yes" xml:space="preserve">
          <source>In this case the input fileglob &lt;code&gt;*.tar.gz&lt;/code&gt; will be transformed into this Perl regular expression</source>
          <target state="translated">在这种情况下，输入文件glob &lt;code&gt;*.tar.gz&lt;/code&gt; 将转换为此Perl正则表达式</target>
        </trans-unit>
        <trans-unit id="779676f9752f28e10579e10de2beca329de72fea" translate="yes" xml:space="preserve">
          <source>In this case the main point to note is that only the last item in the list is returned from the subroutine.</source>
          <target state="translated">在这种情况下,要注意的是,子程序只返回列表中的最后一项。</target>
        </trans-unit>
        <trans-unit id="570da359699c43b4bafeef5621d77b9bbf97eae1" translate="yes" xml:space="preserve">
          <source>In this case the program will be run multiple times using each target file.</source>
          <target state="translated">在这种情况下,程序将使用每个目标文件运行多次。</target>
        </trans-unit>
        <trans-unit id="2b0f3bc0334984124b9519a2c06691727251a21f" translate="yes" xml:space="preserve">
          <source>In this case we know that the string must contain a &lt;code&gt;foo&lt;/code&gt; which must be followed by &lt;code&gt;bar&lt;/code&gt; . We can use Fast Boyer-Moore matching as implemented in &lt;code&gt;fbm_instr()&lt;/code&gt; to find the location of these strings. If they don't exist then we don't need to resort to the much more expensive regex engine. Even better, if they do exist then we can use their positions to reduce the search space that the regex engine needs to cover to determine if the entire pattern matches.</source>
          <target state="translated">在这种情况下，我们知道字符串必须包含一个 &lt;code&gt;foo&lt;/code&gt; ，之后必须是 &lt;code&gt;bar&lt;/code&gt; 。我们可以使用 &lt;code&gt;fbm_instr()&lt;/code&gt; 中实现的Fast Boyer-Moore匹配来找到这些字符串的位置。如果它们不存在，那么我们就不必诉诸更昂贵的正则表达式引擎。更好的是，如果它们确实存在，那么我们可以使用它们的位置来减少正则表达式引擎确定整个模式是否匹配所需的搜索空间。</target>
        </trans-unit>
        <trans-unit id="7adf1e07cf7e2de470c351018728e0b1e6d507de" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be substituted for the item to be cloned. If set to zero:</source>
          <target state="translated">在这种情况下， &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 将代替要克隆的项目。如果设置为零：</target>
        </trans-unit>
        <trans-unit id="6c66364cb0f3415ad0b76d2776349bcfcc95f50e" translate="yes" xml:space="preserve">
          <source>In this case, because the &lt;code&gt;JMPENV&lt;/code&gt; level recorded in the &lt;code&gt;CxEVAL&lt;/code&gt; differs from the current one, &lt;code&gt;docatch&lt;/code&gt; just does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; and the C stack unwinds to:</source>
          <target state="translated">在这种情况下，由于 &lt;code&gt;JMPENV&lt;/code&gt; 记录的JMPENV级别与当前 &lt;code&gt;CxEVAL&lt;/code&gt; 不同，因此 &lt;code&gt;docatch&lt;/code&gt; 只是执行 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 并且C堆栈展开为：</target>
        </trans-unit>
        <trans-unit id="38ba605349bb20448e174208a445c574b3bbbe89" translate="yes" xml:space="preserve">
          <source>In this case, if</source>
          <target state="translated">在这种情况下,如果</target>
        </trans-unit>
        <trans-unit id="bb541d2c2f3bc8d3faf27ff1a86aae9a349b1c56" translate="yes" xml:space="preserve">
          <source>In this case, it finds a &lt;code&gt;save()&lt;/code&gt; method in the &lt;code&gt;File&lt;/code&gt; class. Note that the object passed to &lt;code&gt;save()&lt;/code&gt; in this case is still a &lt;code&gt;File::MP3&lt;/code&gt; object, even though the method is found in the &lt;code&gt;File&lt;/code&gt; class.</source>
          <target state="translated">在这种情况下，它将在 &lt;code&gt;File&lt;/code&gt; 类中找到一个 &lt;code&gt;save()&lt;/code&gt; 方法。请注意，即使在 &lt;code&gt;File&lt;/code&gt; 类中找到了该方法，在这种情况下传递给 &lt;code&gt;save()&lt;/code&gt; 的对象仍然是 &lt;code&gt;File::MP3&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="d9ed12158dee993299753ff9f1084ddd79644a4a" translate="yes" xml:space="preserve">
          <source>In this case, the BEGIN is freed immediately after execution since there are no active references to it: the anon sub prototype has &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; set since it's not a closure, and $a points to the same CV, so it doesn't contribute to BEGIN's refcount either. When $a is executed, the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; '$x'&lt;/code&gt; causes the chain of &lt;code&gt;CvOUTSIDE&lt;/code&gt; s to be followed, and the freed BEGIN is accessed.</source>
          <target state="translated">在这种情况下，BEGIN在执行后立即释放，因为没有活动引用：anon子原型已设置 &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; ,因为它不是闭包，并且$ a指向相同的CV，因此它对BEGIN的贡献不大。引用计数。执行$ a时， &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; '$x'&lt;/code&gt; 使 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 链遵循，并访问释放的BEGIN。</target>
        </trans-unit>
        <trans-unit id="445e238a2cf161c353789dd6ff6ac3c0dc14cd3f" translate="yes" xml:space="preserve">
          <source>In this case, the data flow from the pipeline can be represented as follows:</source>
          <target state="translated">在这种情况下,管道的数据流可以表示为:。</target>
        </trans-unit>
        <trans-unit id="76ef174320084e5b9df3d70ddc86b3f46c5bccd4" translate="yes" xml:space="preserve">
          <source>In this case, the function will overload both of the three way comparison operators. For all overload operations using non-alpha characters, you must type the parameter without quoting, separating multiple overloads with whitespace. Note that &quot;&quot; (the stringify overload) should be entered as \&quot;\&quot; (i.e. escaped).</source>
          <target state="translated">在这种情况下,函数将重载三个比较运算符中的两个。对于所有使用非阿尔法字符的重载操作,你必须键入不带引号的参数,用空格分隔多个重载。请注意,&quot;&quot;(字符串化重载)应该输入为&quot;/&quot;(即转义)。</target>
        </trans-unit>
        <trans-unit id="3d4b7be359855c6b427d300bbc65846d64f8cf9d" translate="yes" xml:space="preserve">
          <source>In this case, the reference count for the variables will never reach 0, and the references will never be garbage-collected. This can lead to memory leaks.</source>
          <target state="translated">在这种情况下,变量的引用数永远不会达到0,引用也永远不会被垃圾回收。这可能导致内存泄漏。</target>
        </trans-unit>
        <trans-unit id="cc6f51a2de8f8d888eeb99016141d99a3d195bd9" translate="yes" xml:space="preserve">
          <source>In this case, the yes-pattern is never directly executed, and no no-pattern is allowed. Similar in spirit to &lt;code&gt;(?{0})&lt;/code&gt; but more efficient. See below for details.</source>
          <target state="translated">在这种情况下，绝对不会直接执行yes模式，并且不允许使用no模式。与 &lt;code&gt;(?{0})&lt;/code&gt; 相似，但效率更高。有关详情，请参见下文。</target>
        </trans-unit>
        <trans-unit id="18c031d44e01689714a7d1be31709243cd683ac5" translate="yes" xml:space="preserve">
          <source>In this case, there's not much to see, but of course normally there's pages of stuff to wade through, and 'l' can be very useful. To reset your view to the line we're about to execute, type a lone period '.':</source>
          <target state="translated">在这种情况下,没有什么可看的,当然通常有几页的东西要涉猎,而'l'可以非常有用。要将你的视图重置到我们即将执行的行,键入一个孤独的句号'.'。</target>
        </trans-unit>
        <trans-unit id="d6cf564bd8d8897a564d43efb035ccf8128bfa59" translate="yes" xml:space="preserve">
          <source>In this case, you cannot omit the first</source>
          <target state="translated">在这种情况下,你不能省略第一个</target>
        </trans-unit>
        <trans-unit id="c6ff251bc24fa4db8e24130b2fd6042c3837352e" translate="yes" xml:space="preserve">
          <source>In this case, you use the &lt;code&gt;detach()&lt;/code&gt; method. Once a thread is detached, it'll run until it's finished; then Perl will clean up after it automatically.</source>
          <target state="translated">在这种情况下，请使用 &lt;code&gt;detach()&lt;/code&gt; 方法。线程分离后，它将一直运行到完成为止。然后Perl将自动清除它。</target>
        </trans-unit>
        <trans-unit id="f06a2a722f183edc4aa583848f94d04c7c5ace33" translate="yes" xml:space="preserve">
          <source>In this document, &quot;must&quot; / &quot;must not&quot;, &quot;should&quot; / &quot;should not&quot;, and &quot;may&quot; have their conventional (cf. RFC 2119) meanings: &quot;X must do Y&quot; means that if X doesn't do Y, it's against this specification, and should really be fixed. &quot;X should do Y&quot; means that it's recommended, but X may fail to do Y, if there's a good reason. &quot;X may do Y&quot; is merely a note that X can do Y at will (although it is up to the reader to detect any connotation of &quot;and I think it would be</source>
          <target state="translated">在本文档中,&quot;必须&quot;/&quot;不得&quot;、&quot;应该&quot;/&quot;不应该 &quot;和 &quot;可以 &quot;有其传统的含义(参考RFC 2119)。&quot;X必须做Y &quot;的意思是,如果X不做Y,就违反了这个规范,真的应该被修正。&quot;X应该做Y &quot;的意思是,建议做,但如果有充分的理由,X可以不做Y。&quot;X可以做Y &quot;仅仅是说明X可以随意做Y(虽然要看读者是否能发现 &quot;而且我认为这将是</target>
        </trans-unit>
        <trans-unit id="f65b8f5200f2d0ab93731dfb5d397ad4f5889d0a" translate="yes" xml:space="preserve">
          <source>In this documentation, &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; on the first line of the program will stand in for whatever method works on your system. You are advised to use a specific path if you care about a specific version.</source>
          <target state="translated">在本文档中，程序第一行上的 &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; 将代表您系统上可用的任何方法。如果您关心特定的版本，建议您使用特定的路径。</target>
        </trans-unit>
        <trans-unit id="317bfd052c319e12e1dcc797f6ad498f8171149f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;--all&lt;/code&gt; will</source>
          <target state="translated">在此示例中，-- &lt;code&gt;--all&lt;/code&gt; 将</target>
        </trans-unit>
        <trans-unit id="e92bf3ad9ffe37a0d52db0112f7aacb357e3a712" translate="yes" xml:space="preserve">
          <source>In this example, a new &lt;code&gt;$x&lt;/code&gt; is created when &lt;code&gt;whatever&lt;/code&gt; is called, and also a new &lt;code&gt;inner&lt;/code&gt; , which can see the new &lt;code&gt;$x&lt;/code&gt; . A &quot;state&quot; sub will only see the &lt;code&gt;$x&lt;/code&gt; from the first call to &lt;code&gt;whatever&lt;/code&gt; .</source>
          <target state="translated">在此示例中，在调用 &lt;code&gt;whatever&lt;/code&gt; 内容时都会创建一个新的 &lt;code&gt;$x&lt;/code&gt; ，并且还会看到一个新的 &lt;code&gt;inner&lt;/code&gt; ，可以看到新的 &lt;code&gt;$x&lt;/code&gt; 。&amp;ldquo;状态&amp;rdquo;子从第一次调用到 &lt;code&gt;whatever&lt;/code&gt; 只会看到 &lt;code&gt;$x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd205d2b3e2dec6816acf70e5f088db6d1ebf4c2" translate="yes" xml:space="preserve">
          <source>In this example, only the first two assignments will be done immediately; after this, all the changes to the file will be deferred up to the user-specified memory limit.</source>
          <target state="translated">在这个例子中,只有前两个分配会立即完成;之后,对文件的所有更改将被推迟到用户指定的内存限制。</target>
        </trans-unit>
        <trans-unit id="19c920ce6f8f3e81b20912d17931330182ad0a53" translate="yes" xml:space="preserve">
          <source>In this example, we will accept a reference to an array as an input parameter, and return a reference to an array of hashes. This will demonstrate manipulation of complex Perl data types from an XSUB.</source>
          <target state="translated">在这个例子中,我们将接受一个数组的引用作为输入参数,并返回一个哈希数组的引用。这将演示如何从XSUB中操作复杂的Perl数据类型。</target>
        </trans-unit>
        <trans-unit id="b22f4e4bd19dab41fd1e0219238248b0317aa35c" translate="yes" xml:space="preserve">
          <source>In this example, we will get the following output:</source>
          <target state="translated">在这个例子中,我们将得到以下输出。</target>
        </trans-unit>
        <trans-unit id="ee2620c9071c60e99d08be588513a407e9d8d25d" translate="yes" xml:space="preserve">
          <source>In this example, we'll do some more work with the argument stack. The previous examples have all returned only a single value. We'll now create an extension that returns an array.</source>
          <target state="translated">在这个例子中,我们将对参数栈做一些更多的工作。前面的例子都只返回一个值。现在我们将创建一个返回数组的扩展。</target>
        </trans-unit>
        <trans-unit id="bc42a21b3f25368390b359d2c6a1e02f5038d3de" translate="yes" xml:space="preserve">
          <source>In this example, we'll now begin to write XSUBs that will interact with pre-defined C libraries. To begin with, we will build a small library of our own, then let h2xs write our .pm and .xs files for us.</source>
          <target state="translated">在这个例子中,我们现在将开始编写XSUB,与预先定义的C库进行交互。首先,我们将建立一个自己的小库,然后让h2xs为我们编写.pm和.xs文件。</target>
        </trans-unit>
        <trans-unit id="ccfbfd9001b68d4bb9123e9a75f5be994042b170" translate="yes" xml:space="preserve">
          <source>In this form, it is easier to see a way to simplify the alternation. Alternatives 1, 2, and 4 all start with &lt;code&gt;\d+&lt;/code&gt; , so it could be factored out:</source>
          <target state="translated">以这种形式，更容易看到简化交替的方法。选项1、2和4都以 &lt;code&gt;\d+&lt;/code&gt; 开头，因此可以将其排除在外：</target>
        </trans-unit>
        <trans-unit id="5b24fb7d07c9db355f07769493a9de293acc8111" translate="yes" xml:space="preserve">
          <source>In this hash each key represents a category of functions and the value is a short description of that category.</source>
          <target state="translated">在这个哈希中,每个键代表一个函数类别,值是该类别的简短描述。</target>
        </trans-unit>
        <trans-unit id="3f56d8b8bdb8c26426f0b6660b2be0710caeb9c2" translate="yes" xml:space="preserve">
          <source>In this hash each key represents a function and the value is a short description of that function.</source>
          <target state="translated">在这个哈希中,每个键代表一个函数,值是该函数的简短描述。</target>
        </trans-unit>
        <trans-unit id="4112ec477caea48107dc76ca327ecc26b9559568" translate="yes" xml:space="preserve">
          <source>In this hash each key represents a function and the value is the category. The category can be a comma separated list.</source>
          <target state="translated">在这个哈希中,每个键代表一个函数,值是类别。类别可以是一个逗号分隔的列表。</target>
        </trans-unit>
        <trans-unit id="5b991cc90d42bab8c037a6310ce95c7fd23aada4" translate="yes" xml:space="preserve">
          <source>In this instance the &quot;Store&quot; and &quot;Fetch&quot; methods are encapsulated inside a &quot;Filter&quot; method.</source>
          <target state="translated">在本例中,&quot;Store &quot;和 &quot;Fetch &quot;方法被封装在一个 &quot;Filter &quot;方法中。</target>
        </trans-unit>
        <trans-unit id="d35ad5c2c0618e945079ac0ca929cf4d613d24d9" translate="yes" xml:space="preserve">
          <source>In this library, the numbers are represented in base B = 10**N, where N is the largest possible value that does not cause overflow in the intermediate computations. The base B elements are stored in an array, with the least significant element stored in array element zero. There are no leading zero elements, except a single zero element when the number is zero.</source>
          <target state="translated">在这个库中,数字用基数B=10**N表示,其中N是在中间计算中不引起溢出的最大可能值。基数B元素存储在一个数组中,其中最小的元素存储在数组元素0中。除数字为零时有一个零元素外,没有前导零元素。</target>
        </trans-unit>
        <trans-unit id="df68cfd3648ab58a91a7f368ccaceffbf7d1f325" translate="yes" xml:space="preserve">
          <source>In this particular case we don't have to call</source>
          <target state="translated">在这种特殊情况下,我们不必调用</target>
        </trans-unit>
        <trans-unit id="dad6a924b2e38abcfe4b4ffded7acf8266a85c31" translate="yes" xml:space="preserve">
          <source>In this pass the input pattern is parsed in order to calculate how much space is needed for each regop we would need to emit. The size is also used to determine whether long jumps will be required in the program.</source>
          <target state="translated">在这个通道中,输入模式被解析,以便计算我们需要发出的每个regop需要多少空间。这个大小也用于确定程序中是否需要长距离跳转。</target>
        </trans-unit>
        <trans-unit id="41f31a4be766288871cf075eb0ef8be8f75f8e7b" translate="yes" xml:space="preserve">
          <source>In this pod section each line obeys the format</source>
          <target state="translated">在这一节中,每一行都遵守以下格式</target>
        </trans-unit>
        <trans-unit id="2a40391b3aa03b91dc32950cbb01e23eafc7a333" translate="yes" xml:space="preserve">
          <source>In this regexp, you might expect the first minimal quantifier &lt;code&gt;.*?&lt;/code&gt; to match the empty string, because it is not constrained by a &lt;code&gt;^&lt;/code&gt; anchor to match the beginning of the word. Principle 0 applies here, however. Because it is possible for the whole regexp to match at the start of the string, it</source>
          <target state="translated">在此正则表达式中，您可能希望第一个最小量词 &lt;code&gt;.*?&lt;/code&gt; 匹配空字符串，因为它不受 &lt;code&gt;^&lt;/code&gt; 锚约束以匹配单词的开头。但是，原则0在这里适用。因为整个正则表达式有可能在字符串的开头匹配，所以它</target>
        </trans-unit>
        <trans-unit id="1677ca4d68d5b3cd757901e02552a2ca6071fc8c" translate="yes" xml:space="preserve">
          <source>In this regular expression, the alternation matches either at the beginning or the end of the string since the anchors have a lower precedence than the alternation. With the &lt;code&gt;/g&lt;/code&gt; flag, the substitution makes all possible matches, so it gets both. Remember, the trailing newline matches the &lt;code&gt;\s+&lt;/code&gt;, and the &lt;code&gt;$&lt;/code&gt; anchor can match to the absolute end of the string, so the newline disappears too. Just add the newline to the output, which has the added benefit of preserving &quot;blank&quot; (consisting entirely of whitespace) lines which the &lt;code&gt;^\s+&lt;/code&gt; would remove all by itself:</source>
          <target state="translated">在此正则表达式中，交替匹配在字符串的开头或结尾处匹配，因为锚的优先级低于交替。使用 &lt;code&gt;/g&lt;/code&gt; 标志，替换将使所有可能的匹配都匹配，因此两者都将得到。请记住，结尾的换行符匹配 &lt;code&gt;\s+&lt;/code&gt; ，并且 &lt;code&gt;$&lt;/code&gt; 锚可以匹配到字符串的绝对结尾，因此换行符也消失了。只需在输出中添加换行符即可，它的另一个好处是保留了&amp;ldquo;空白&amp;rdquo;（完全由空格组成）行， &lt;code&gt;^\s+&lt;/code&gt; 会自动删除所有行：</target>
        </trans-unit>
        <trans-unit id="77b676e373d337a1558a3681668f6ee37714295f" translate="yes" xml:space="preserve">
          <source>In this statement, &lt;code&gt;World&lt;/code&gt; is a regex and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regex match and produces a true value if the regex matched, or false if the regex did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; , so the expression is true. This idea has several variations.</source>
          <target state="translated">在此语句中， &lt;code&gt;World&lt;/code&gt; 是一个正则表达式， &lt;code&gt;//&lt;/code&gt; 包含 &lt;code&gt;/World/&lt;/code&gt; 告诉Perl在字符串中搜索匹配项。运算符 &lt;code&gt;=~&lt;/code&gt; 将字符串与正则表达式匹配相关联，如果正则表达式匹配则产生一个真值，如果正则表达式不匹配则产生一个假值。在我们的例子中， &lt;code&gt;World&lt;/code&gt; 与 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 中的第二个单词匹配，因此该表达式为true。这个想法有几个变种。</target>
        </trans-unit>
        <trans-unit id="c818981124c0efd397c772e8c5a5bccf099d60f4" translate="yes" xml:space="preserve">
          <source>In this way (as for perl's scalars) a pointer to a PerlIOBuf can be treated as a pointer to a PerlIOl.</source>
          <target state="translated">这样一来(就像perl的标量一样),一个指向PerlIOBuf的指针可以被当作指向PerlIOl的指针。</target>
        </trans-unit>
        <trans-unit id="47c607bae4c1c842072097188930b7f5e712b730" translate="yes" xml:space="preserve">
          <source>In those 8 cases above, the value of EXPR is used directly as a boolean, so no smartmatching is done. You may think of &lt;code&gt;when&lt;/code&gt; as a smartsmartmatch.</source>
          <target state="translated">在上述8种情况下，EXPR的值直接用作布尔值，因此不会进行智能匹配。您可能会认为 &lt;code&gt;when&lt;/code&gt; 是smartsmartmatch。</target>
        </trans-unit>
        <trans-unit id="9186d74e76b80422b13adb44366ed78c8afac4f7" translate="yes" xml:space="preserve">
          <source>In those cases, it is easier to just append the filtering subroutine and any terminator specification directly to the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement that loads Filter::Simple, like so:</source>
          <target state="translated">在这些情况下，将过滤子例程和任何终止符规范直接附加到加载Filter :: Simple 的 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句会更容易，如下所示：</target>
        </trans-unit>
        <trans-unit id="95167fe0e36a49f5080da73352ed44710a152f26" translate="yes" xml:space="preserve">
          <source>In those cases, you would turn off &lt;code&gt;strict 'refs'&lt;/code&gt; temporarily so you can play around with the symbol table. For example:</source>
          <target state="translated">在这种情况下，您将暂时关闭 &lt;code&gt;strict 'refs'&lt;/code&gt; 以便可以使用符号表。例如：</target>
        </trans-unit>
        <trans-unit id="c6200c4c82d6daee49dcd17953c7919b7352b65f" translate="yes" xml:space="preserve">
          <source>In time-critical applications, it is worthwhile to avoid splitting into more fields than necessary. Thus, when assigning to a list, if LIMIT is omitted (or zero), then LIMIT is treated as though it were one larger than the number of variables in the list; for the following, LIMIT is implicitly 3:</source>
          <target state="translated">在时间紧迫的应用中,值得避免分割成超过必要的字段。因此,在分配给一个列表时,如果省略了LIMIT(或为零),那么LIMIT就会被当作比列表中的变量数大一的变量来处理;对于以下情况,LIMIT隐含为3。</target>
        </trans-unit>
        <trans-unit id="61aec1693f3cca77d878f9993860b197db04ab69" translate="yes" xml:space="preserve">
          <source>In turning &lt;a href=&quot;http://search.cpan.org/perldoc/Foo::Bar&quot;&gt;Foo::Bar&lt;/a&gt; into &lt;a href=&quot;http://whatever/Foo%3a%3aBar&quot;&gt;http://whatever/Foo%3a%3aBar&lt;/a&gt;, what to put before the &quot;Foo%3a%3aBar&quot;. The default value is &quot;&lt;a href=&quot;http://search.cpan.org/perldoc&quot;&gt;http://search.cpan.org/perldoc&lt;/a&gt;?&quot;.</source>
          <target state="translated">在将&lt;a href=&quot;http://search.cpan.org/perldoc/Foo::Bar&quot;&gt;Foo :: Bar&lt;/a&gt;转换为&lt;a href=&quot;http://whatever/Foo%3a%3aBar&quot;&gt;http：// whatever / Foo％3a％3aBar时&lt;/a&gt;，应在&amp;ldquo; Foo％3a％3aBar&amp;rdquo;之前添加什么。默认值为&amp;ldquo; &lt;a href=&quot;http://search.cpan.org/perldoc&quot;&gt;http://search.cpan.org/perldoc&lt;/a&gt;？&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="fe66d5d405c8ef8a7eac08fc91eff0a843fd6e3f" translate="yes" xml:space="preserve">
          <source>In turning &lt;code&gt;&lt;i&gt;crontab(5)&lt;/i&gt;&lt;/code&gt; into &lt;a href=&quot;http://whatever/man/1/crontab&quot;&gt;http://whatever/man/1/crontab&lt;/a&gt;, what to put before the &quot;1/crontab&quot;. The default value is &quot;&lt;a href=&quot;http://man.he.net/man&quot;&gt;http://man.he.net/man&lt;/a&gt;&quot;.</source>
          <target state="translated">将 &lt;code&gt;&lt;i&gt;crontab(5)&lt;/i&gt;&lt;/code&gt; 转换为&lt;a href=&quot;http://whatever/man/1/crontab&quot;&gt;http：// whatever / man / 1 / crontab时&lt;/a&gt;，应在&amp;ldquo; 1 / crontab&amp;rdquo;之前放置什么。默认值为&amp;ldquo; &lt;a href=&quot;http://man.he.net/man&quot;&gt;http://man.he.net/man&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="43281809d91fd31f1807b9436030386775e6651b" translate="yes" xml:space="preserve">
          <source>In typical VMS style, only the first letter of the value of this logical name is actually checked in a case insensitive mode, and it is considered enabled if it is the value &quot;T&quot;,&quot;1&quot; or &quot;E&quot;.</source>
          <target state="translated">在典型的VMS风格中,在不区分大小写的模式下,实际上只检查该逻辑名的值的第一个字母,如果是 &quot;T&quot;、&quot;1 &quot;或 &quot;E &quot;的值,则视为启用。</target>
        </trans-unit>
        <trans-unit id="573e7b50018345b4e76799c05af940dc27c74f2b" translate="yes" xml:space="preserve">
          <source>In ualarm() you tried to use number of microseconds or interval (also in microseconds) more than 1_000_000 and setitimer() is not available in your system to emulate that case.</source>
          <target state="translated">在ualarm()中,你试图使用超过1_000_000的微秒数或间隔(也是以微秒为单位),而setitimer()在你的系统中不可用来模拟这种情况。</target>
        </trans-unit>
        <trans-unit id="f02423b74e4b6df478931aa6ac2f4633241db988" translate="yes" xml:space="preserve">
          <source>In verbose mode, a warning is printed if shadows are found (i.e., more than one POD file with the same POD name is found, e.g.</source>
          <target state="translated">在verbose模式下,如果发现阴影,就会打印出一个警告(例如,发现了多个具有相同POD名称的POD文件,例如。</target>
        </trans-unit>
        <trans-unit id="8a3ebab20ae57eb43347721d9e5a409b1ce17a43" translate="yes" xml:space="preserve">
          <source>In version 2.37 the first argument to the callback function was changed from string to object. This was done to make room for extensions and more detailed control. The object stringifies to the option name so this change should not introduce compatibility problems.</source>
          <target state="translated">在2.37版本中,回调函数的第一个参数从字符串改为对象。这样做是为了给扩展和更详细的控制腾出空间。对象字符串化为选项名称,所以这个变化不会带来兼容性问题。</target>
        </trans-unit>
        <trans-unit id="880a8be23ba2ee8779ff63078e49dfc5216b39eb" translate="yes" xml:space="preserve">
          <source>In versions 5.000 and 5.001, instead of using the above line, you will need to use the following line:</source>
          <target state="translated">在5.000和5.001版本中,您需要使用下面的行,而不是使用上面的行。</target>
        </trans-unit>
        <trans-unit id="1cc474b32c69cb459158c3dcaef8e4f4b651d874" translate="yes" xml:space="preserve">
          <source>In versions 5.6 and later, Perl won't recompile the regular expression if the variable hasn't changed, so you probably don't need the &lt;code&gt;/o&lt;/code&gt; option. It doesn't hurt, but it doesn't help either. If you want any version of Perl to compile the regular expression only once even if the variable changes (thus, only using its initial value), you still need the &lt;code&gt;/o&lt;/code&gt;.</source>
          <target state="translated">在5.6版和更高版本中，如果变量未更改，Perl将不会重新编译正则表达式，因此您可能不需要 &lt;code&gt;/o&lt;/code&gt; 选项。它没有伤害，但也没有帮助。如果您希望任何版本的Perl都只编译一次正则表达式，即使变量发生更改（因此，仅使用其初始值），则仍然需要 &lt;code&gt;/o&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb448bdd461c35050663768e40f737fb69d01266" translate="yes" xml:space="preserve">
          <source>In versions of 5.002 prior to the gamma version, the test script in Example 1 will not function properly. You need to change the &quot;use lib&quot; line to read:</source>
          <target state="translated">在gamma版本之前的5.002版本中,例1中的测试脚本将无法正常运行。你需要把 &quot;使用lib &quot;这一行改为。</target>
        </trans-unit>
        <trans-unit id="47fb4d46b782f60712d6e476480e232acaeda83d" translate="yes" xml:space="preserve">
          <source>In versions of 5.002 prior to version 5.002b1h, the test.pl file was not automatically created by h2xs. This means that you cannot say &quot;make test&quot; to run the test script. You will need to add the following line before the &quot;use extension&quot; statement:</source>
          <target state="translated">在5.002b1h之前的5.002版本中,test.pl文件不是由h2xs自动创建的。这意味着你不能说 &quot;make test &quot;来运行测试脚本。您需要在 &quot;使用扩展名 &quot;语句前添加以下一行。</target>
        </trans-unit>
        <trans-unit id="ac1080be96df0c995d03afc96266140d8a96249c" translate="yes" xml:space="preserve">
          <source>In versions of Perl prior to 5.004, per-locale collation was possible using the &lt;code&gt;I18N::Collate&lt;/code&gt; library module. This module is now mildly obsolete and should be avoided in new applications. The &lt;code&gt;LC_COLLATE&lt;/code&gt; functionality is now integrated into the Perl core language: One can use locale-specific scalar data completely normally with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , so there is no longer any need to juggle with the scalar references of &lt;code&gt;I18N::Collate&lt;/code&gt; .</source>
          <target state="translated">在5.004之前的Perl版本中，可以使用 &lt;code&gt;I18N::Collate&lt;/code&gt; 库模块按区域进行排序。现在，该模块已过时，应在新应用中避免使用。该 &lt;code&gt;LC_COLLATE&lt;/code&gt; 功能现已集成到Perl的核心语言：一个完全可以正常使用区域设置特定的标量数据与 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ，所以没有必要再玩花样用的标量引用 &lt;code&gt;I18N::Collate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48a813c6d738225545b449a151bcdc156058f932" translate="yes" xml:space="preserve">
          <source>In your XS code, when you define an argument with a C type or when you are using a &lt;code&gt;CODE:&lt;/code&gt; and an &lt;code&gt;OUTPUT:&lt;/code&gt; section together with a C return type of your XSUB, it'll be the typemapping mechanism that makes this easy.</source>
          <target state="translated">在XS代码中，当您定义C类型的参数或使用 &lt;code&gt;CODE:&lt;/code&gt; 和 &lt;code&gt;OUTPUT:&lt;/code&gt; 部分以及XSUB的C返回类型时，这将是使这种操作变得容易的类型映射机制。</target>
        </trans-unit>
        <trans-unit id="9357861451f0b2f036dafa4da40d9ece429bcae6" translate="yes" xml:space="preserve">
          <source>In-line functions that are in headers that are accessible to XS code need to be able to compile without warnings with commonly used extra compilation flags, such as gcc's &lt;code&gt;-Wswitch-default&lt;/code&gt; which warns whenever a switch statement does not have a &quot;default&quot; case. The use of these extra flags is to catch potential problems in legal C code, and is often used by Perl aggregators, such as Linux distributors.</source>
          <target state="translated">XS代码可访问的标头中的内联函数必须能够使用常用的额外编译标志在没有警告的情况下进行编译，例如gcc的 &lt;code&gt;-Wswitch-default&lt;/code&gt; ，当switch语句不具有&amp;ldquo; default&amp;rdquo;大小写时会发出警告。这些额外的标志的使用是为了捕获合法C代码中的潜在问题，并且经常被Perl聚合器（例如Linux发行商）使用。</target>
        </trans-unit>
        <trans-unit id="1fac261b8677bb294fa8e76c7f44d73a02d84ebb" translate="yes" xml:space="preserve">
          <source>In-memory IO, scalar IO</source>
          <target state="translated">内存IO,标量IO</target>
        </trans-unit>
        <trans-unit id="022b1dbe77251c047456c4feb5d0409e122d6848" translate="yes" xml:space="preserve">
          <source>In-place upgrade of the supplied SV to a version object.</source>
          <target state="translated">将提供的SV就地升级为版本对象。</target>
        </trans-unit>
        <trans-unit id="1930e5219f1534978185f9ba376df01339047154" translate="yes" xml:space="preserve">
          <source>Inappropriate documentation</source>
          <target state="translated">不适当的文件</target>
        </trans-unit>
        <trans-unit id="72a5f6c42a6c39ea891ecb24d22128fd281d0e18" translate="yes" xml:space="preserve">
          <source>Inc</source>
          <target state="translated">Inc</target>
        </trans-unit>
        <trans-unit id="70b0bede26554e7ae42316f8d3fd932a7cdc066c" translate="yes" xml:space="preserve">
          <source>Incidentally, note that each class's &lt;code&gt;%Lexicon&lt;/code&gt; inherits-and-extends the lexicons in its superclasses. This is not because these are special hashes</source>
          <target state="translated">顺便提一下，请注意，每个类的 &lt;code&gt;%Lexicon&lt;/code&gt; 都继承并扩展了其超类中的词典。这不是因为这些是特殊的哈希</target>
        </trans-unit>
        <trans-unit id="56c1bcd0fe0c175606142de66e47a332c19454ad" translate="yes" xml:space="preserve">
          <source>Incidentally, note that there's no easy way to express a data paragraph starting with something that looks like a command. Consider:</source>
          <target state="translated">顺便说一下,注意,没有一个简单的方法来表达一个数据段,以一个看起来像命令的东西开始。考虑一下:</target>
        </trans-unit>
        <trans-unit id="af23144864617d68a82ad427e6d70d917f0fe977" translate="yes" xml:space="preserve">
          <source>Incidentally, note the variance in the result values between the two examples; this is typical of benchmarking. If this were a real benchmark, you would probably want to run a lot more iterations.</source>
          <target state="translated">顺便提一下,注意两个例子之间结果值的差异;这是典型的基准测试。如果这是一个真正的基准,你可能会想要运行更多的迭代。</target>
        </trans-unit>
        <trans-unit id="11c54a59d8a9668fa20146e40c46116f6e7acc35" translate="yes" xml:space="preserve">
          <source>Include</source>
          <target state="translated">Include</target>
        </trans-unit>
        <trans-unit id="7f36757a0ff9e21d096da46852dca59689517203" translate="yes" xml:space="preserve">
          <source>Include /usr/ccs/bin/ in your PATH.</source>
          <target state="translated">在你的PATH中加入/usr/ccs/bin/。</target>
        </trans-unit>
        <trans-unit id="5f7213221d8f17a14d6c7b8882fe3f1c79362499" translate="yes" xml:space="preserve">
          <source>Include a &quot;POD ERRORS&quot; section in the outfile if there were any POD errors in the infile (default behaviour).</source>
          <target state="translated">如果infile中有任何POD错误,在outfile中包含 &quot;POD ERRORS &quot;部分(默认行为)。</target>
        </trans-unit>
        <trans-unit id="1f63d3adcc78e2a751c9de88b5a592a5d6f05fed" translate="yes" xml:space="preserve">
          <source>Include a &quot;POD ERRORS&quot; section in the outfile if there were any POD errors in the infile. This section is included by default.</source>
          <target state="translated">如果 infile 中有任何 POD 错误,则在 outfile 中包含 &quot;POD ERRORS&quot; 部分。这个部分是默认包含的。</target>
        </trans-unit>
        <trans-unit id="1be836334b7992bf64bdd66feaf2cdd670e862a6" translate="yes" xml:space="preserve">
          <source>Include a single css source in the header:</source>
          <target state="translated">在头中加入一个css源。</target>
        </trans-unit>
        <trans-unit id="82da13ca7b8da7d4d7bd6d25f32b5e4df5ab790d" translate="yes" xml:space="preserve">
          <source>Include a single javascript source:</source>
          <target state="translated">包括一个单一的javascript源代码。</target>
        </trans-unit>
        <trans-unit id="dacfcf246f0e94f511558260bbdd933b10ed8af6" translate="yes" xml:space="preserve">
          <source>Include any non-POD text from the input file in the output as well. Useful for viewing code documented with POD blocks with the POD rendered and the code left intact.</source>
          <target state="translated">将输入文件中的任何非POD文本也包含在输出中。对于查看带有POD块的代码,在POD被渲染的情况下,代码保持原样是很有用的。</target>
        </trans-unit>
        <trans-unit id="b3aefa9c8a28918cfdeb274cb63c2499f4f13ccf" translate="yes" xml:space="preserve">
          <source>Include code for safely storing static data in the .xs file. Extensions that do no make use of static data can ignore this option.</source>
          <target state="translated">在.xs文件中包含安全存储静态数据的代码。不使用静态数据的扩展可以忽略这个选项。</target>
        </trans-unit>
        <trans-unit id="73830e720872f365cfd2f2dbd3697deb29a3d139" translate="yes" xml:space="preserve">
          <source>Include file dirs eg: &lt;code&gt;&quot;-I/usr/5include -I/path/to/inc&quot;&lt;/code&gt;</source>
          <target state="translated">包含文件目录，例如： &lt;code&gt;&quot;-I/usr/5include -I/path/to/inc&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf7dea1bf3fcc056eca7b649b6605fbf3217e27a" translate="yes" xml:space="preserve">
          <source>Include tests with your module</source>
          <target state="translated">在您的模块中包含测试</target>
        </trans-unit>
        <trans-unit id="44cae264b95e40204b6c9817100d817393044faa" translate="yes" xml:space="preserve">
          <source>Include the `nstore' option to have the &lt;code&gt;Storable&lt;/code&gt; database written in `network order'. (See &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; for more details about this.)</source>
          <target state="translated">包含&amp;ldquo; nstore&amp;rdquo;选项，以&amp;ldquo;网络顺序&amp;rdquo;编写 &lt;code&gt;Storable&lt;/code&gt; 数据库。（有关此问题的更多详细信息，请参见&lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="428c39cb578db360bfc5803c8ec5f4e60b61ea16" translate="yes" xml:space="preserve">
          <source>Include the code from the &lt;b&gt;.h&lt;/b&gt; file as a comment in the &lt;b&gt;.ph&lt;/b&gt; file. This is primarily used for debugging</source>
          <target state="translated">将&lt;b&gt;.h&lt;/b&gt;文件中的代码作为注释包含在&lt;b&gt;.ph&lt;/b&gt;文件中。这主要用于调试</target>
        </trans-unit>
        <trans-unit id="5318c44a39f5f77944d683ed2f0ae1a7ab04539f" translate="yes" xml:space="preserve">
          <source>Include the following line in the XS section of your XS file: (don't break the line)</source>
          <target state="translated">在XS文件的XS部分加入以下一行。(不要断行)</target>
        </trans-unit>
        <trans-unit id="eb7645ad7831d7d6fd6181e27396b77155390482" translate="yes" xml:space="preserve">
          <source>Include the main program in the output, even if subroutines were also specified. This rendering is normally suppressed when a subroutine name or reference is given.</source>
          <target state="translated">在输出中包含主程序,即使子程序也被指定。当给出子程序名称或引用时,通常会抑制这种渲染。</target>
        </trans-unit>
        <trans-unit id="39d690d519d42e4c1222e708f1a7882603060ecf" translate="yes" xml:space="preserve">
          <source>Include verbose configuration data in the report.</source>
          <target state="translated">在报告中包含详细的配置数据。</target>
        </trans-unit>
        <trans-unit id="7af107d55e07795d28db937bc5e2e6b3d1acdce5" translate="yes" xml:space="preserve">
          <source>Included in the official Perl distribution, as in a standard module, a standard tool, or a standard Perl &lt;b&gt;manpage&lt;/b&gt;.</source>
          <target state="translated">包含在官方Perl发行版中，如标准模块，标准工具或标准Perl手册&lt;b&gt;页中&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="0c36d5529b0434732ae50f5c4cfddc9ab638ebdc" translate="yes" xml:space="preserve">
          <source>Included recommended modules?</source>
          <target state="translated">包括推荐模块?</target>
        </trans-unit>
        <trans-unit id="2d5cfde693773293f9c93c5da459379d1390e74a" translate="yes" xml:space="preserve">
          <source>Included suggested modules?</source>
          <target state="translated">包括建议的模块?</target>
        </trans-unit>
        <trans-unit id="fd1eb7c27a0ef162dc3c74b06bcd124d36810aee" translate="yes" xml:space="preserve">
          <source>Included with the standard Cygwin netrelease is the inetutils package which includes libutil.a.</source>
          <target state="translated">标准的Cygwin netrelease中包含了inetutils包,其中包括libutil.a。</target>
        </trans-unit>
        <trans-unit id="62deb9b6c9960c6cf27bcef72a0cb725d958b5ee" translate="yes" xml:space="preserve">
          <source>Includes the closing tag of &amp;lt;/title&amp;gt; and through the rest of the head till the opening of the body</source>
          <target state="translated">包括&amp;lt;/ title&amp;gt;的结束标签，并贯穿头部的其余部分，直到身体打开为止</target>
        </trans-unit>
        <trans-unit id="9abdbb8c9871ea5d015e2e60e10f71a6f7c5bffa" translate="yes" xml:space="preserve">
          <source>Inclusion of library modules is better done with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; operators, which also do automatic error checking and raise an exception if there's a problem.</source>
          <target state="translated">库模块的包含可以通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 运算符来更好地完成，它们也可以执行自动错误检查并在出现问题时引发异常。</target>
        </trans-unit>
        <trans-unit id="fc7468d33bdeb93695da594528f2501435fe4708" translate="yes" xml:space="preserve">
          <source>Inclusion of library modules is better done with the &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; operators, which also do automatic error checking and raise an exception if there's a problem.</source>
          <target state="translated">库模块的包含可以通过 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 运算符来更好地完成，它们也可以执行自动错误检查并在出现问题时引发异常。</target>
        </trans-unit>
        <trans-unit id="d536a03f0c3143f6e1f810634a3c64f1cee1463a" translate="yes" xml:space="preserve">
          <source>Incompatibility with AIX Toolbox lib gdbm</source>
          <target state="translated">与AIX工具箱lib gdbm不兼容。</target>
        </trans-unit>
        <trans-unit id="e53b7251c10e4fb16639ff0eb74e48d3fdb255f3" translate="yes" xml:space="preserve">
          <source>Increment OBJ by one.</source>
          <target state="translated">将OBJ增加一个。</target>
        </trans-unit>
        <trans-unit id="a3b00269821fb57d8ea2de1fc824b0f5f9a60902" translate="yes" xml:space="preserve">
          <source>Increment an SV's reference count. Use the &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; wrapper instead.</source>
          <target state="translated">增加SV的参考计数。请改用 &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; 包装器。</target>
        </trans-unit>
        <trans-unit id="0e74e496959812fcc073992ca705206317cb9544" translate="yes" xml:space="preserve">
          <source>Increment the reference count of a &lt;code&gt;refcounted_he&lt;/code&gt; . The pointer to the &lt;code&gt;refcounted_he&lt;/code&gt; is also returned. It is safe to pass a null pointer to this function: no action occurs and a null pointer is returned.</source>
          <target state="translated">增加 &lt;code&gt;refcounted_he&lt;/code&gt; 的引用计数。还返回指向 &lt;code&gt;refcounted_he&lt;/code&gt; 的指针。将空指针传递给此函数是安全的：不执行任何操作，并且返回空指针。</target>
        </trans-unit>
        <trans-unit id="e3802b6aa343742e73ae6047c081fca9075a08d1" translate="yes" xml:space="preserve">
          <source>Increment the version number for every change, no matter how small</source>
          <target state="translated">每一次更改都会增加版本号,无论多小的更改。</target>
        </trans-unit>
        <trans-unit id="4c98c7bfa60bc9d7d9626649411d920868a3e57d" translate="yes" xml:space="preserve">
          <source>Increments &lt;code&gt;PL_sub_generation&lt;/code&gt; , which invalidates method caching in all packages.</source>
          <target state="translated">增加 &lt;code&gt;PL_sub_generation&lt;/code&gt; ，这会使所有包中的方法缓存无效。</target>
        </trans-unit>
        <trans-unit id="3272c368109726f88d497737f134b46e95de8369" translate="yes" xml:space="preserve">
          <source>Increments the reference count of the given SV, returning the SV.</source>
          <target state="translated">增加给定SV的引用次数,返回SV。</target>
        </trans-unit>
        <trans-unit id="b3fb59bb686d8260401f92a3aa6f2bbde8cfdc66" translate="yes" xml:space="preserve">
          <source>Indeed, a negative real number can be noted &lt;code&gt;[x,pi]&lt;/code&gt; (the modulus</source>
          <target state="translated">实际上，可以指出一个负实数 &lt;code&gt;[x,pi]&lt;/code&gt; （模</target>
        </trans-unit>
        <trans-unit id="a04774d4b73d320e20f71b059e1b914a71747c31" translate="yes" xml:space="preserve">
          <source>Indeed, to terminate the cycle, the $cnt should become false. However, the operator &lt;code&gt;bool&lt;/code&gt; for checking falsity is overloaded (this time via overloaded &lt;code&gt;&quot;&quot;&lt;/code&gt; ), and returns a long string, thus any object of type &lt;code&gt;symbolic&lt;/code&gt; is true. To overcome this, we need a way to compare an object to 0. In fact, it is easier to write a numeric conversion routine.</source>
          <target state="translated">实际上，要终止周期，$ cnt应该变为false。但是，用于检查虚假性的运算符 &lt;code&gt;bool&lt;/code&gt; 重载了（这次是通过重载的 &lt;code&gt;&quot;&quot;&lt;/code&gt; ），并且返回了一个长字符串，因此任何 &lt;code&gt;symbolic&lt;/code&gt; 类型的对象都是true。为了克服这个问题，我们需要一种将对象与0比较的方法。实际上，编写数字转换例程更加容易。</target>
        </trans-unit>
        <trans-unit id="62ba8e1b3397c92c36fc4b8d835f19b0c882946b" translate="yes" xml:space="preserve">
          <source>Indent lines by multiples of</source>
          <target state="translated">缩进行数的倍数</target>
        </trans-unit>
        <trans-unit id="62114f3245956b96ef644ac166335fb4a4e9a90b" translate="yes" xml:space="preserve">
          <source>Independent of which seed is used in the hash function, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; return items in a per-hash randomized order. Modifying a hash by insertion will change the iteration order of that hash. This behavior can be overridden by using &lt;code&gt;hash_traversal_mask()&lt;/code&gt; from &lt;a href=&quot;hash/util&quot;&gt;Hash::Util&lt;/a&gt; or by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS in perlrun&lt;/a&gt;. Note that this feature controls the &quot;visible&quot; order of the keys, and not the actual order they are stored in.</source>
          <target state="translated">与哈希函数中使用的种子无关， &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 返回项均按哈希随机顺序排列。通过插入修改哈希将更改该哈希的迭代顺序。这种行为可以通过覆盖 &lt;code&gt;hash_traversal_mask()&lt;/code&gt; 从&lt;a href=&quot;hash/util&quot;&gt;哈希::的Util&lt;/a&gt;或使用PERL_PERTURB_KEYS环境变量，看&lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;在perlrun PERL_PERTURB_KEYS&lt;/a&gt;。请注意，此功能控制键的&amp;ldquo;可见&amp;rdquo;顺序，而不是它们存储的实际顺序。</target>
        </trans-unit>
        <trans-unit id="074fa110a121b41d1fc8547d15dc9f9c647ba94b" translate="yes" xml:space="preserve">
          <source>Independent subexpressions</source>
          <target state="translated">独立子表达式</target>
        </trans-unit>
        <trans-unit id="f095033a2da35066ce69235bfd888bf108da82db" translate="yes" xml:space="preserve">
          <source>Index/Value Array Slices</source>
          <target state="translated">索引/值阵列切片</target>
        </trans-unit>
        <trans-unit id="9376bb53130ade1b5bef94ae526efe4afa9ba571" translate="yes" xml:space="preserve">
          <source>India Pale Ale. Also the International Phonetic Alphabet, the standard alphabet used for phonetic notation worldwide. Draws heavily on Unicode, including many combining characters.</source>
          <target state="translated">印度淡味啤酒。也是国际音标字母表,是世界上用于音标的标准字母表。大量采用Unicode,包括许多组合字符。</target>
        </trans-unit>
        <trans-unit id="7939b23cc59e5fecb713c284b9570bf5c06bc4a8" translate="yes" xml:space="preserve">
          <source>Indicate if List::Util was compiled with a C compiler</source>
          <target state="translated">表明List::Util是否是用C编译器编译的。</target>
        </trans-unit>
        <trans-unit id="257f1f56edc7d22d13ca3e932a232d7b1ce1cb6a" translate="yes" xml:space="preserve">
          <source>Indicates how many bits are produced by the function used to generate normalized random numbers.</source>
          <target state="translated">表示用于生成归一化随机数的函数所产生的位数。</target>
        </trans-unit>
        <trans-unit id="9e61b5d3c6d9951043a7c42ee4ac908615e6dda5" translate="yes" xml:space="preserve">
          <source>Indicates if the test suite is currently passing.</source>
          <target state="translated">表示测试套件目前是否通过。</target>
        </trans-unit>
        <trans-unit id="89c8d4afc13dccaac0824429842e2b3486822df1" translate="yes" xml:space="preserve">
          <source>Indicates that a user-supplied typemap should take precedence over the default typemaps. A single typemap may be specified as a string, or multiple typemaps can be specified in an array reference, with the last typemap having the highest precedence.</source>
          <target state="translated">表示用户提供的类型图应优先于默认类型图。单个类型地图可以指定为字符串,也可以在数组引用中指定多个类型地图,最后一个类型地图具有最高优先权。</target>
        </trans-unit>
        <trans-unit id="a07031906aeffe3119baa721e29202522fd91917" translate="yes" xml:space="preserve">
          <source>Indicates that a user-supplied typemap should take precedence over the default typemaps. This option may be used multiple times, with the last typemap having the highest precedence.</source>
          <target state="translated">表示用户提供的类型图应优先于默认类型图。此选项可多次使用,最后一个类型图具有最高优先权。</target>
        </trans-unit>
        <trans-unit id="2a6c6be6a26747d93fbb6c3ceadc3f2de48a2c99" translate="yes" xml:space="preserve">
          <source>Indicates that arguments returned from a callback should be discarded. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">指示应放弃从回调返回的参数。参见&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0527e8a268302f8a5a261750f72fb958d828bf1d" translate="yes" xml:space="preserve">
          <source>Indicates that no arguments are being sent to a callback. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">指示没有参数发送到回调。参见&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a1a4d2b29fe4bc866080992a5b7a34bdbecb2aeb" translate="yes" xml:space="preserve">
          <source>Indicates that the caller is not interested in the hostname of the result, so it does not have to be converted. &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned as the hostname.</source>
          <target state="translated">指示调用者对结果的主机名不感兴趣，因此不必进行转换。 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 将作为主机名返回。</target>
        </trans-unit>
        <trans-unit id="b7ec72841bfda828e77f110fabfe3b01a8c116ba" translate="yes" xml:space="preserve">
          <source>Indicates that the caller is not interested in the service name of the result, so it does not have to be converted. &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned as the service name.</source>
          <target state="translated">指示调用者对结果的服务名称不感兴趣，因此不必进行转换。 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 将作为服务名称返回。</target>
        </trans-unit>
        <trans-unit id="f532e8b4a0494e58b3d4e84b40bc705bd9387b6c" translate="yes" xml:space="preserve">
          <source>Indicates that the caller will pass a numeric address, rather than a hostname, and that getaddrinfo() must not perform a resolve operation on this name. This flag will prevent a possibly-slow network lookup operation, and instead return an error if a hostname is passed.</source>
          <target state="translated">表示调用者将传递一个数字地址,而不是主机名,并且getaddrinfo()不能对这个名字执行解析操作。这个标志可以防止可能很慢的网络查找操作,如果传递的是主机名,则会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="3c8087750e8c32a23d6ccd2949d0b7dadc5ebeea" translate="yes" xml:space="preserve">
          <source>Indicates that the caller wishes the canonical hostname (&lt;code&gt;canonname&lt;/code&gt; ) field of the result to be filled in.</source>
          <target state="translated">指示呼叫者希望填写结果的规范主机名（ &lt;code&gt;canonname&lt;/code&gt; ）字段。</target>
        </trans-unit>
        <trans-unit id="0a02454d6f3918d6c495eef14a92688abca3837e" translate="yes" xml:space="preserve">
          <source>Indicates that the referenced subroutine is a method. A subroutine so marked will not trigger the &quot;Ambiguous call resolved as CORE::%s&quot; warning.</source>
          <target state="translated">表示被引用的子程序是一个方法。这样标记的子程序不会触发 &quot;模糊调用解析为CORE::%s &quot;警告。</target>
        </trans-unit>
        <trans-unit id="1c805274f5974d7ec81414a21a79ac4005ac17f0" translate="yes" xml:space="preserve">
          <source>Indicates that the referenced subroutine is a valid lvalue and can be assigned to. The subroutine must return a modifiable value such as a scalar variable, as described in &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">指示所引用的子例程是有效的左值，可以分配给该子例程。子例程必须返回可修改的值，例如标量变量，如&lt;a href=&quot;perlsub&quot;&gt;perlsub中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="945cc6067d92cdd88f1d4d49015ca5f672222998" translate="yes" xml:space="preserve">
          <source>Indicates that the referenced variable can be shared across different threads when used in conjunction with the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; modules.</source>
          <target state="translated">指示与&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;和&lt;a href=&quot;threads/shared&quot;&gt;thread :: shared&lt;/a&gt;模块一起使用时，可以在不同的线程之间共享引用的变量。</target>
        </trans-unit>
        <trans-unit id="f5dc796b3c6e09f2adbe1df261ece3a878874b6e" translate="yes" xml:space="preserve">
          <source>Indicates that the socket address relates to a &lt;code&gt;SOCK_DGRAM&lt;/code&gt; socket, for the services whose name differs between TCP and UDP protocols.</source>
          <target state="translated">指示套接字名称与 &lt;code&gt;SOCK_DGRAM&lt;/code&gt; 套接字相关，用于服务名称在TCP和UDP协议之间不同​​的服务。</target>
        </trans-unit>
        <trans-unit id="d2c743e25365a9bdf3ff9b009f1ca948b97e6afb" translate="yes" xml:space="preserve">
          <source>Indicates that this resolution is for a local bind() for a passive (i.e. listening) socket, rather than an active (i.e. connecting) socket.</source>
          <target state="translated">表示该解析是针对被动(即监听)套接字的本地绑定(),而不是主动(即连接)套接字。</target>
        </trans-unit>
        <trans-unit id="1f10eaccf1b997cf7e5e0f8a8f4fab0ca55e7525" translate="yes" xml:space="preserve">
          <source>Indicates the macro to be used to generate normalized random numbers. Uses randfunc, often divided by (double) (((unsigned long) 1 &amp;lt;&amp;lt; randbits)) in order to normalize the result. In C programs, the macro &lt;code&gt;Drand01&lt;/code&gt; is mapped to drand01.</source>
          <target state="translated">指示用于生成标准化随机数的宏。使用randfunc，通常将其除以（double）（（（（unsigned long）1 1 randbits）））以标准化结果。在C程序中，宏 &lt;code&gt;Drand01&lt;/code&gt; 映射到drand01。</target>
        </trans-unit>
        <trans-unit id="46fbaffe89877f1dd0586f026a063f6bfd1ece0d" translate="yes" xml:space="preserve">
          <source>Indicates the name of the random number function to use. Values include drand48, random, and rand. In C programs, the &lt;code&gt;Drand01&lt;/code&gt; macro is defined to generate uniformly distributed random numbers over the range [0., 1.[ (see drand01 and nrand).</source>
          <target state="translated">指示要使用的随机数函数的名称。值包括drand48，random和rand。在C程序中，将 &lt;code&gt;Drand01&lt;/code&gt; 宏定义为生成范围为[0.，1。[（请参阅drand01和nrand））的均匀分布的随机数。</target>
        </trans-unit>
        <trans-unit id="0e9d38aea41337c4a340bd6ff37e0fceaaf530c7" translate="yes" xml:space="preserve">
          <source>Indicates the random number generating seed function. Values include srand48, srandom, and srand.</source>
          <target state="translated">表示随机数生成的种子函数,值包括srand48、srandom和srand。值包括srand48、srandom和srand。</target>
        </trans-unit>
        <trans-unit id="90e351cd851905a73031d78312feecb33ffe731a" translate="yes" xml:space="preserve">
          <source>Indicates the type of the argument of the seedfunc.</source>
          <target state="translated">表示 seedfunc 的参数类型。</target>
        </trans-unit>
        <trans-unit id="2261f14a4235af1795b8d1185c5372fb55826237" translate="yes" xml:space="preserve">
          <source>Indicates to the &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; that things are going so badly all testing should terminate. This includes running any additional test scripts.</source>
          <target state="translated">向&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt;表示事情进展很糟，所有测试都应终止。这包括运行任何其他测试脚本。</target>
        </trans-unit>
        <trans-unit id="fe441aac507416c2ecf5fefc2720f5a5e7cc6991" translate="yes" xml:space="preserve">
          <source>Indicates to the harness that things are going so badly all testing should terminate. This includes the running of any additional test scripts.</source>
          <target state="translated">向线束表明,事情进展得非常糟糕,所有测试都应该终止。这包括运行任何额外的测试脚本。</target>
        </trans-unit>
        <trans-unit id="bdde223b122eaee17c31cfd6ef76f52ec58ce6f0" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the current item is a YAML block.</source>
          <target state="translated">表示当前项目是否是YAML块。</target>
        </trans-unit>
        <trans-unit id="2ac3f8f7cb3f69c816245189833fb5047e4be353" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the current line could be parsed.</source>
          <target state="translated">表示当前行是否可以解析。</target>
        </trans-unit>
        <trans-unit id="765249e9b3e3ba66799eb3c3e692065e2ef4bdde" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the given result has a SKIP directive.</source>
          <target state="translated">表示给定结果是否有SKIP指令。</target>
        </trans-unit>
        <trans-unit id="1e5feadbfd972a9ef3f2203c437baf1b81be3303" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the given result has a TODO directive.</source>
          <target state="translated">表示给定结果是否有TODO指令。</target>
        </trans-unit>
        <trans-unit id="5ae3ac2f7146f745d483818a88c053580ae4ad1e" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the given result has a TODO or SKIP directive.</source>
          <target state="translated">表示给定结果是否有TODO或SKIP指令。</target>
        </trans-unit>
        <trans-unit id="33c1162df0e994c2dba92771958227447c3c8740" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a TAP version line.</source>
          <target state="translated">表示是否为TAP版本行。</target>
        </trans-unit>
        <trans-unit id="82a274793f5ee26247829ddf91f4a9bd5a24bbd9" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a YAML chunk.</source>
          <target state="translated">表示这是否是一个YAML块。</target>
        </trans-unit>
        <trans-unit id="551b037463cdc6d8ee7a155c709c206438a14ea9" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a comment.</source>
          <target state="translated">表示这是否是一条评论。</target>
        </trans-unit>
        <trans-unit id="fa47f2a4b95862bdf9eb043bb9b755ecb73bbd6f" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a comment. Comments will generally only appear in the TAP stream if STDERR is merged to STDOUT. See the &lt;code&gt;merge&lt;/code&gt; option.</source>
          <target state="translated">指示这是否为评论。如果将STDERR合并到STDOUT，则注释通常只会出现在TAP流中。请参阅 &lt;code&gt;merge&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="5add899043fa2f2909dd47a1020e2ad33a37e66d" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a pragma line.</source>
          <target state="translated">表示这是否是一个pragma行。</target>
        </trans-unit>
        <trans-unit id="7023aeaf089510f19833c997992b3c941c8dc92d" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a test line.</source>
          <target state="translated">表示这是否是一条测试线。</target>
        </trans-unit>
        <trans-unit id="9f9b15b44f69cccc124e6789e9d93a4a06a7d51c" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is bailout line.</source>
          <target state="translated">表示是否为保送线。</target>
        </trans-unit>
        <trans-unit id="7a3a5d84e52530eeac47fceba7db01f6e0dcbe22" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is the test plan line.</source>
          <target state="translated">表示是否为测试计划线。</target>
        </trans-unit>
        <trans-unit id="9010b0739ea277aa1257ee6d74e58336f2039de7" translate="yes" xml:space="preserve">
          <source>Indicates whether the octets in the lexer buffer (&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;) should be interpreted as the UTF-8 encoding of Unicode characters. If not, they should be interpreted as Latin-1 characters. This is analogous to the &lt;code&gt;SvUTF8&lt;/code&gt; flag for scalars.</source>
          <target state="translated">指示是否应将词法分析器缓冲区（&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt; linestr&lt;/a&gt;）中的八位字节解释为Unicode字符的UTF-8编码。如果不是，则应将其解释为Latin-1字符。这类似于标量的 &lt;code&gt;SvUTF8&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="6add24acec866ad90335d7337161ba97a738a82e" translate="yes" xml:space="preserve">
          <source>Indicating the Film::Rating() method is broken.</source>
          <target state="translated">表示Film::Rating()方法被破坏。</target>
        </trans-unit>
        <trans-unit id="065a6d5ea3be3a587038269a904d146bb9a0a3c1" translate="yes" xml:space="preserve">
          <source>Indirect Object Syntax</source>
          <target state="translated">间接对象语法</target>
        </trans-unit>
        <trans-unit id="3fba9ca2a9139d262136aa9779aba86f7f14b1e8" translate="yes" xml:space="preserve">
          <source>Individual Results</source>
          <target state="translated">个人成绩</target>
        </trans-unit>
        <trans-unit id="cb52fbb620cf2997c4aa4b5107c331f4b77d2de2" translate="yes" xml:space="preserve">
          <source>Individual test results.</source>
          <target state="translated">个人测试结果。</target>
        </trans-unit>
        <trans-unit id="a6118403aceb71cf86308ba3cff213cbc8856dc0" translate="yes" xml:space="preserve">
          <source>Individual test suite results.</source>
          <target state="translated">单个测试套件的结果。</target>
        </trans-unit>
        <trans-unit id="a1d71ca242908209d7ea479076e7d5102e909486" translate="yes" xml:space="preserve">
          <source>Inf</source>
          <target state="translated">Inf</target>
        </trans-unit>
        <trans-unit id="68dcf262960464f7812ef1f6844ea3187d8ab76d" translate="yes" xml:space="preserve">
          <source>Infinity and Not a Number</source>
          <target state="translated">无限而非数字</target>
        </trans-unit>
        <trans-unit id="ec4c72e2c7996edd7fe98bac862051d171e8f331" translate="yes" xml:space="preserve">
          <source>Inflate Interface</source>
          <target state="translated">充气接口</target>
        </trans-unit>
        <trans-unit id="ae8803342c993280c888b28837c9da6527d39370" translate="yes" xml:space="preserve">
          <source>Inflates the complete contents of &lt;code&gt;$buffer&lt;/code&gt; . The buffer can either be a scalar or a scalar reference.</source>
          <target state="translated">扩充 &lt;code&gt;$buffer&lt;/code&gt; 的完整内容。缓冲区可以是标量或标量引用。</target>
        </trans-unit>
        <trans-unit id="beedaffabd6b03c265ffb648f984a13e030e2063" translate="yes" xml:space="preserve">
          <source>Inflates the complete contents of &lt;code&gt;$input&lt;/code&gt; and writes the uncompressed data to &lt;code&gt;$output&lt;/code&gt; . The &lt;code&gt;$input&lt;/code&gt; and &lt;code&gt;$output&lt;/code&gt; parameters can either be scalars or scalar references.</source>
          <target state="translated">扩充 &lt;code&gt;$input&lt;/code&gt; 的全部内容，并将未压缩的数据写入 &lt;code&gt;$output&lt;/code&gt; 。在 &lt;code&gt;$input&lt;/code&gt; 和 &lt;code&gt;$output&lt;/code&gt; 参数可以是标量或标量引用。</target>
        </trans-unit>
        <trans-unit id="75ddcc47830d9749b1f6958774d6b7383d928afa" translate="yes" xml:space="preserve">
          <source>Information on installing the Perl documentation in HTML format can be found in the</source>
          <target state="translated">关于安装HTML格式的Perl文档的信息可以在</target>
        </trans-unit>
        <trans-unit id="63a11938f1b7522fad4baac591e5655e30cc1a15" translate="yes" xml:space="preserve">
          <source>Information on the git commit from which the current perl binary was compiled can be found in the variable &lt;code&gt;$Config::Git_Data&lt;/code&gt; . The variable is a structured string that looks something like this:</source>
          <target state="translated">可以从变量 &lt;code&gt;$Config::Git_Data&lt;/code&gt; 找到有关编译当前perl二进制文件的git commit的信息。变量是一个结构化的字符串，看起来像这样：</target>
        </trans-unit>
        <trans-unit id="4fa18069a4aed5716a8df64d9e082aca15aa5195" translate="yes" xml:space="preserve">
          <source>Informative call that array is likely to grow to have</source>
          <target state="translated">告知性调用,数组很可能成长为有</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="fdd8dbf1164cff77c53c1fcf6f05a5248f3597e3" translate="yes" xml:space="preserve">
          <source>Inheritance allows two classes to share code. By default, every method in the parent class is also available in the child. The child can explicitly &lt;b&gt;override&lt;/b&gt; a parent's method to provide its own implementation. For example, if we have an &lt;code&gt;File::MP3&lt;/code&gt; object, it has the &lt;code&gt;print_info()&lt;/code&gt; method from &lt;code&gt;File&lt;/code&gt; :</source>
          <target state="translated">继承允许两个类共享代码。默认情况下，父类中的每个方法在子类中也可用。子级可以显式&lt;b&gt;重写&lt;/b&gt;父级的方法以提供其自己的实现。例如，如果我们有一个 &lt;code&gt;File::MP3&lt;/code&gt; 对象，它具有 &lt;code&gt;print_info()&lt;/code&gt; 从方法 &lt;code&gt;File&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bbc41c48400edb2d66f46abd2eeeb9f193aa61fe" translate="yes" xml:space="preserve">
          <source>Inheritance and Overloading</source>
          <target state="translated">继承和重载</target>
        </trans-unit>
        <trans-unit id="b4102e1cbc70e34f207d4b05daf2f7d154eb2cce" translate="yes" xml:space="preserve">
          <source>Inheriting from *Tie::ExtraHash*</source>
          <target state="translated">继承自*Tie::ExtraHash*。</target>
        </trans-unit>
        <trans-unit id="07845e4fa81351b41e3aca0473590f0745f203e3" translate="yes" xml:space="preserve">
          <source>Inheriting from *Tie::Memoize*</source>
          <target state="translated">继承自*Tie::Memoize*。</target>
        </trans-unit>
        <trans-unit id="c5a788b89ced595ecbe83baf444c015d5af4ed62" translate="yes" xml:space="preserve">
          <source>Inheriting from *Tie::StdHash*</source>
          <target state="translated">继承自*Tie::StdHash*。</target>
        </trans-unit>
        <trans-unit id="2af015f1a7a88588d2bedaaf274af7c154500941" translate="yes" xml:space="preserve">
          <source>Inheriting from &lt;b&gt;Tie::ExtraHash&lt;/b&gt;</source>
          <target state="translated">从&lt;b&gt;Tie :: ExtraHash&lt;/b&gt;继承&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0ee435be5e637cbc759b674414f3dfaaeaa6a310" translate="yes" xml:space="preserve">
          <source>Inheriting from &lt;b&gt;Tie::Memoize&lt;/b&gt;</source>
          <target state="translated">从&lt;b&gt;Tie :: Memoize&lt;/b&gt;继承&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0942164c538c56917cf82fee8d95de867370af98" translate="yes" xml:space="preserve">
          <source>Inheriting from &lt;b&gt;Tie::StdHash&lt;/b&gt;</source>
          <target state="translated">从&lt;b&gt;Tie :: StdHash&lt;/b&gt;继承&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="697bba69426638bf8ad3245a38ff2084b17b3805" translate="yes" xml:space="preserve">
          <source>Init methods</source>
          <target state="translated">启动方法</target>
        </trans-unit>
        <trans-unit id="469d92ba331e1f193a058b9d59b36d9c2695f1be" translate="yes" xml:space="preserve">
          <source>Init.U</source>
          <target state="translated">Init.U</target>
        </trans-unit>
        <trans-unit id="188fedc6f79203e40eb5a91d186ec6c30916e7f9" translate="yes" xml:space="preserve">
          <source>Initial discussion of the ability to modify IO streams behaviour used the term &quot;discipline&quot; for the entities which were added. This came (I believe) from the use of the term in &quot;sfio&quot;, which in turn borrowed it from &quot;line disciplines&quot; on Unix terminals. However, this document (and the C code) uses the term &quot;layer&quot;.</source>
          <target state="translated">最初关于修改IO流行为的能力的讨论中,使用了 &quot;纪律 &quot;一词来表示所添加的实体,这来自于 &quot;sfio &quot;中对这个词的使用,而这个词又借用了Unix终端上的 &quot;行纪律&quot;。这来自于(我相信)&quot;sfio &quot;中对这个术语的使用,而 &quot;sfio &quot;又从Unix终端的 &quot;行纪律 &quot;中借用了这个术语。然而,本文档(和C代码)使用的是 &quot;层 &quot;这个术语。</target>
        </trans-unit>
        <trans-unit id="af26189aae099c8b0074103f2d4d6fbc19c70e2f" translate="yes" xml:space="preserve">
          <source>Initial port of perl to WinCE. It was performed in separate directory named</source>
          <target state="translated">将 perl 移植到 WinCE 的初始版本。它是在单独的目录下进行的,名为</target>
        </trans-unit>
        <trans-unit id="64a1cc8196dec5ffb0b6abf423df9a7b0c6e0219" translate="yes" xml:space="preserve">
          <source>Initial version (GSAR 20-FEB-97)</source>
          <target state="translated">初版(GSAR 20-FEB-97)</target>
        </trans-unit>
        <trans-unit id="681e3458dd2b1a02b6b17850e74b7b6f830be8ea" translate="yes" xml:space="preserve">
          <source>Initialisation in &lt;code&gt;pregcomp()&lt;/code&gt; mostly involves the creation and data-filling of a special structure, &lt;code&gt;RExC_state_t&lt;/code&gt; (defined in</source>
          <target state="translated">&lt;code&gt;pregcomp()&lt;/code&gt; 中的初始化主要涉及特殊结构 &lt;code&gt;RExC_state_t&lt;/code&gt; （在</target>
        </trans-unit>
        <trans-unit id="c7a9076545ffc08af19383275c9bb0a670aaa64a" translate="yes" xml:space="preserve">
          <source>Initialises a deflation object.</source>
          <target state="translated">初始化一个放气对象。</target>
        </trans-unit>
        <trans-unit id="b36a0f0079e64fa2a033c629779d3f623a057d8c" translate="yes" xml:space="preserve">
          <source>Initialises a deflation stream.</source>
          <target state="translated">初始化一个放气流。</target>
        </trans-unit>
        <trans-unit id="6050c58e3e77b97a8c7a9c2f34e629bf70ca3f1a" translate="yes" xml:space="preserve">
          <source>Initialises an inflation object.</source>
          <target state="translated">初始化一个充气对象。</target>
        </trans-unit>
        <trans-unit id="d6dc7f91e03e45468b8ef5863382d6fe3515a834" translate="yes" xml:space="preserve">
          <source>Initialises an inflation stream.</source>
          <target state="translated">初始化一个通货膨胀流。</target>
        </trans-unit>
        <trans-unit id="a08fb78f0ee25d9e540249a9eb4c3ec2aebf86f6" translate="yes" xml:space="preserve">
          <source>Initialization values for some globals</source>
          <target state="translated">一些globals的初始化值</target>
        </trans-unit>
        <trans-unit id="d7a3ea6043299cfce500bdda50fb23f6cbea5c5c" translate="yes" xml:space="preserve">
          <source>Initialize MAKE from either a MAKE environment variable or $Config{make}.</source>
          <target state="translated">通过MAKE环境变量或$Config{make}来初始化MAKE。</target>
        </trans-unit>
        <trans-unit id="8a7c7a1b384ad47d60773edd82ad26376d621207" translate="yes" xml:space="preserve">
          <source>Initialize any macros which are for platform specific use only.</source>
          <target state="translated">初始化任何仅用于平台特定用途的宏。</target>
        </trans-unit>
        <trans-unit id="4476040d6adc770412cdb2150cb39c32735c92d5" translate="yes" xml:space="preserve">
          <source>Initialize macros representing versions of MakeMaker and other tools</source>
          <target state="translated">初始化代表MakeMaker和其他工具版本的宏。</target>
        </trans-unit>
        <trans-unit id="fa2a269c8bcaa8f7394ce2454e1f32bd30c51822" translate="yes" xml:space="preserve">
          <source>Initialize macros which have to do with linking.</source>
          <target state="translated">初始化与链接有关的宏。</target>
        </trans-unit>
        <trans-unit id="cf8b76ad5759b00cf83505f7cf706fcbd53a36ab" translate="yes" xml:space="preserve">
          <source>Initialize the SigSet object to be empty.</source>
          <target state="translated">初始化SigSet对象为空。</target>
        </trans-unit>
        <trans-unit id="553a04fdd695ae3cee805a386f6c72d5ee7c6e5d" translate="yes" xml:space="preserve">
          <source>Initialize the SigSet object to include all signals.</source>
          <target state="translated">初始化SigSet对象以包含所有信号。</target>
        </trans-unit>
        <trans-unit id="7ff28902a2edd7a86041272b550eea681cfd2a0b" translate="yes" xml:space="preserve">
          <source>Initializes AR, AR_STATIC_ARGS, BASEEXT, CONFIG, DISTNAME, DLBASE, EXE_EXT, FULLEXT, FULLPERL, FULLPERLRUN, FULLPERLRUNINST, INST_*, INSTALL*, INSTALLDIRS, LIB_EXT, LIBPERL_A, MAP_TARGET, NAME, OBJ_EXT, PARENT_NAME, PERL, PERL_ARCHLIB, PERL_INC, PERL_LIB, PERL_SRC, PERLRUN, PERLRUNINST, PREFIX, VERSION, VERSION_SYM, XS_VERSION.</source>
          <target state="translated">初始化AR,AR_STATIC_ARGS,BASEEXT,CONFIG,DISTNAME,DLBASE,EXE_EXT,FULLEXT,FULLPERL,FULLPERLRUN,FULLPERLRUNINST,INST_*,INSTALL*,INSTALLDIRS,LIB_EXT。LIBPERL_A,MAP_TARGET,NAME,OBJ_EXT,PARENT_NAME,PERL,PERL_ARCHLIB,PERL_INC,PERL_LIB,PERL_SRC,PERLRUN,PERLRUNINST,PREFIX,VERSION,VERSION_SYM,XS_VERSION。</target>
        </trans-unit>
        <trans-unit id="9b0af4794c1652a453537aa4d31bc51217044cfb" translate="yes" xml:space="preserve">
          <source>Initializes MAN1PODS from the list of EXE_FILES.</source>
          <target state="translated">从EXE_FILES列表中初始化MAN1PODS。</target>
        </trans-unit>
        <trans-unit id="9908a02e0ec97a9887147642e25f6d00ba2bba87" translate="yes" xml:space="preserve">
          <source>Initializes MAN3PODS from the list of PM files.</source>
          <target state="translated">从PM文件列表中初始化MAN3PODS。</target>
        </trans-unit>
        <trans-unit id="78aa0c8b31d0aa9e4f082b472e25049793a28d4c" translate="yes" xml:space="preserve">
          <source>Initializes PMLIBDIRS and PM from PMLIBDIRS.</source>
          <target state="translated">从PMLIBDIRS初始化PMLIBDIRS和PM。</target>
        </trans-unit>
        <trans-unit id="f52193e05865340eb9150e274aa92320b071b3c6" translate="yes" xml:space="preserve">
          <source>Initializes a new Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">初始化新的Perl解释器。见&lt;a href=&quot;perlembed&quot;&gt;临危&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d157e4855cf1cd1f0584d861b76b87bbd1430bbd" translate="yes" xml:space="preserve">
          <source>Initializes a new object. This method is a stub by default, you should override it as appropriate.</source>
          <target state="translated">初始化一个新对象。这个方法默认是个存根,你应该适当地覆盖它。</target>
        </trans-unit>
        <trans-unit id="9cf6c0c33242d2abf005967a6623b3ae8501f304" translate="yes" xml:space="preserve">
          <source>Initializes the DIRFILESEP macro which is the separator between the directory and filename in a filepath. ie. / on Unix, \ on Win32 and nothing on VMS.</source>
          <target state="translated">初始化DIRFILESEP宏,它是文件路径中目录和文件名之间的分隔符,即在Unix上是/,在Win32上是\,在VMS上是无。</target>
        </trans-unit>
        <trans-unit id="1f6be944d9e52d97024d9034508b4cacc682c441" translate="yes" xml:space="preserve">
          <source>Initializes the macro definitions having to do with compiling and linking used by tools_other() and places them in the $MM object.</source>
          <target state="translated">初始化与 tools_other()使用的编译和链接有关的宏定义,并将它们放在 $MM 对象中。</target>
        </trans-unit>
        <trans-unit id="e775d4b4b0bd3712f9f514299a1d05c1a00cf523" translate="yes" xml:space="preserve">
          <source>Initializes the simple macro definitions used by tools_other() and places them in the $MM object. These use conservative cross platform versions and should be overridden with platform specific versions for performance.</source>
          <target state="translated">初始化 tools_other()所使用的简单宏定义,并将其放置在 $MM 对象中。这些定义使用了保守的跨平台版本,为了保证性能,应该用特定平台的版本来覆盖。</target>
        </trans-unit>
        <trans-unit id="282f9af1f24130bc9182b79671b3debcbe420b2a" translate="yes" xml:space="preserve">
          <source>Initializes tools to use their common (and faster) Unix commands.</source>
          <target state="translated">初始化工具以使用其常用(和更快)的Unix命令。</target>
        </trans-unit>
        <trans-unit id="7a196e34c731e5f3af1e31be4705513bd9e1800a" translate="yes" xml:space="preserve">
          <source>Initializing Function Parameters</source>
          <target state="translated">初始化函数参数</target>
        </trans-unit>
        <trans-unit id="f762e2df9b5c50638aa3c3cbbaf63d08b1a096ce" translate="yes" xml:space="preserve">
          <source>Initializing with &lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">用 &lt;code&gt;new&lt;/code&gt; 初始化</target>
        </trans-unit>
        <trans-unit id="5374c9bb7d82a306aff38df30638934a3bedb34d" translate="yes" xml:space="preserve">
          <source>Initializing with new</source>
          <target state="translated">初始化与新</target>
        </trans-unit>
        <trans-unit id="16e4c7e9d2fa46d1492e494337cfb9b14642fd7d" translate="yes" xml:space="preserve">
          <source>Initiate the sending of the data from the current message.</source>
          <target state="translated">启动当前消息的数据发送。</target>
        </trans-unit>
        <trans-unit id="fe9280fcef1f95066c459792b601f0a568c68ff3" translate="yes" xml:space="preserve">
          <source>Inplace editing &lt;code&gt;perl -i&lt;/code&gt; of files doesn't work without doing a backup of the file being edited &lt;code&gt;perl -i.bak&lt;/code&gt; because of windowish restrictions, therefore Perl adds the suffix &lt;code&gt;.bak&lt;/code&gt; automatically if you use &lt;code&gt;perl -i&lt;/code&gt; without specifying a backup extension.</source>
          <target state="translated">由于 &lt;code&gt;perl -i.bak&lt;/code&gt; 限制，如果不对正在编辑的文件perl -i.bak进行备份，就不能进行文件就地编辑 &lt;code&gt;perl -i&lt;/code&gt; ，因此，如果您使用 &lt;code&gt;perl -i&lt;/code&gt; 而未指定备份扩展名，则Perl会自动添加后缀 &lt;code&gt;.bak&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="f2166976e1182028cf4a602c00df0206990e4b61" translate="yes" xml:space="preserve">
          <source>Input File Glob</source>
          <target state="translated">输入文件全球</target>
        </trans-unit>
        <trans-unit id="2dc35a576a410b10bc60ae6d2130c68130a12559" translate="yes" xml:space="preserve">
          <source>Input and Output Parameters</source>
          <target state="translated">输入和输出参数</target>
        </trans-unit>
        <trans-unit id="fca6ebb3af2e2ddf731c9ba341152d5ee6d08083" translate="yes" xml:space="preserve">
          <source>Input and output pipes to Perl filehandles are supported; the &quot;file name&quot; is passed to lib$spawn() for asynchronous execution. You should be careful to close any pipes you have opened in a Perl script, lest you leave any &quot;orphaned&quot; subprocesses around when Perl exits.</source>
          <target state="translated">支持指向 Perl 文件柄的输入和输出管道;&quot;文件名 &quot;会被传递给 lib$spawn()用于异步执行。你应该小心关闭在 Perl 脚本中打开的任何管道,以免在 Perl 退出时留下任何 &quot;孤儿 &quot;子进程。</target>
        </trans-unit>
        <trans-unit id="25e7b83bd15298faf6fd8f002de9128fb08ea38f" translate="yes" xml:space="preserve">
          <source>Input from, or output to, a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;device&lt;/b&gt;.</source>
          <target state="translated">来自&lt;b&gt;文件&lt;/b&gt;或&lt;b&gt;设备的&lt;/b&gt;输入或输出。</target>
        </trans-unit>
        <trans-unit id="f6047072eebf842c882d2d1ca55ea7667206a889" translate="yes" xml:space="preserve">
          <source>Input library and path specifications are accepted with or without the &lt;code&gt;-l&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt; prefixes used by Unix linkers.</source>
          <target state="translated">接受或不包含Unix链接程序使用的 &lt;code&gt;-l&lt;/code&gt; 和 &lt;code&gt;-L&lt;/code&gt; 前缀的输入库和路径规范。</target>
        </trans-unit>
        <trans-unit id="db35c0f2c45290c19fd136029a213ad284b80e55" translate="yes" xml:space="preserve">
          <source>Input library and path specifications are accepted with or without the &lt;code&gt;-l&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt; prefixes used by Unix linkers. If neither prefix is present, a token is considered a directory to search if it is in fact a directory, and a library to search for otherwise. Authors who wish their extensions to be portable to Unix or OS/2 should use the Unix prefixes, since the Unix-OS/2 version of ext() requires them.</source>
          <target state="translated">接受或不包含Unix链接程序使用的 &lt;code&gt;-l&lt;/code&gt; 和 &lt;code&gt;-L&lt;/code&gt; 前缀的输入库和路径规范。如果两个前缀都不存在，则将令牌视为要搜索的目录，如果它实际上是目录，则将其视为要搜索的库。希望其扩展可移植到Unix或OS / 2的作者应使用Unix前缀，因为ext（）的Unix-OS / 2版本需要它们。</target>
        </trans-unit>
        <trans-unit id="a1f8b7d0598aac2b8e4ba4b9244e4a933dc9e6b4" translate="yes" xml:space="preserve">
          <source>Input strings are decode()d then encode()d. A straight two-step implementation.</source>
          <target state="translated">输入的字符串是解码()d然后再编码()d。直接两步实现。</target>
        </trans-unit>
        <trans-unit id="ff3057c52ba4da6e1ddf88eb538e9f34e59f7ee9" translate="yes" xml:space="preserve">
          <source>Input to these routines are either BigFloat objects, or strings of the following four forms:</source>
          <target state="translated">这些例程的输入可以是BigFloat对象,也可以是以下四种形式的字符串。</target>
        </trans-unit>
        <trans-unit id="0c0281be753361164d1d0fc4c9f4d612cf39dd2d" translate="yes" xml:space="preserve">
          <source>Input values to these routines may be any string, that looks like a number and results in an integer, including hexadecimal and binary numbers.</source>
          <target state="translated">这些例程的输入值可以是任何字符串,看起来像一个数字,结果是一个整数,包括十六进制和二进制数字。</target>
        </trans-unit>
        <trans-unit id="09ede375a150e967e64e7e2d887a232d51f368fa" translate="yes" xml:space="preserve">
          <source>Insert LIST elements at the beginning of the array, moving existing elements up to make room.</source>
          <target state="translated">在数组的开头插入LIST元素,将现有元素向上移动以腾出空间。</target>
        </trans-unit>
        <trans-unit id="8b5af2a8ac2266ac1fdb8694203bf8a7b5999fb5" translate="yes" xml:space="preserve">
          <source>Insert LIST elements at the beginning of the array, moving existing elements up to make room. For example:</source>
          <target state="translated">在数组的开头插入LIST元素,将现有元素向上移动以腾出空间。例如:</target>
        </trans-unit>
        <trans-unit id="0c8d991df77bf00e29c21cb93175839fa481ea2b" translate="yes" xml:space="preserve">
          <source>Insert characters into the lexer buffer (&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;), immediately after the current lexing point (&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt;), reallocating the buffer if necessary. This means that lexing code that runs later will see the characters as if they had appeared in the input. It is not recommended to do this as part of normal parsing, and most uses of this facility run the risk of the inserted characters being interpreted in an unintended manner.</source>
          <target state="translated">将字符插入到词法分析器缓冲区（&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt; linestr&lt;/a&gt;）中，紧接在当前词法分析点（&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr&lt;/a&gt;）之后，如有必要，请重新分配缓冲区。这意味着稍后运行的词法分析代码将看到字符，就好像它们已出现在输入中一样。不建议将其作为常规解析的一部分进行，并且此功能的大多数使用都存在插入字符被意外解释的风险。</target>
        </trans-unit>
        <trans-unit id="d46d273f43c1298f3a09e3049502d6b87af98707" translate="yes" xml:space="preserve">
          <source>Inserting POD, Comments and C Preprocessor Directives</source>
          <target state="translated">插入POD、注释和C预处理器指令</target>
        </trans-unit>
        <trans-unit id="3ddc278de0a82017be1546343c053adba747b534" translate="yes" xml:space="preserve">
          <source>Inserting records that</source>
          <target state="translated">插入以下记录</target>
        </trans-unit>
        <trans-unit id="762d7f10b7a5cbbfbd3a51bba1f8d6e37c660a81" translate="yes" xml:space="preserve">
          <source>Inserts a string at the specified offset/length within the SV. Similar to the Perl substr() function. Handles get magic.</source>
          <target state="translated">在SV中以指定的偏移量/长度插入一个字符串。类似于Perl中的substr()函数。处理get魔术。</target>
        </trans-unit>
        <trans-unit id="ac3e05759f66cf1dafff1c764cc8c3b6a42a2c61" translate="yes" xml:space="preserve">
          <source>Inserts the sharpbang or equivalent magic number to a set of @files.</source>
          <target state="translated">将锐邦或等效的魔数插入到一组@文件中。</target>
        </trans-unit>
        <trans-unit id="bfb7a36a7ca33fb28f326fe5eacde6cacf000521" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;(?{...})&lt;/code&gt; block, &lt;code&gt;$_&lt;/code&gt; refers to the string the regular expression is matching against. You can also use &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; to know what is the current position of matching within this string.</source>
          <target state="translated">在 &lt;code&gt;(?{...})&lt;/code&gt; 块中， &lt;code&gt;$_&lt;/code&gt; 表示正则表达式要匹配的字符串。您还可以使用 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 来了解此字符串中匹配项的当前位置。</target>
        </trans-unit>
        <trans-unit id="60f1ba3b99ef99e8ed328c9a98bf927d5f0a5518" translate="yes" xml:space="preserve">
          <source>Inside a Perl program, you can use the &lt;a href=&quot;extutils/installed&quot;&gt;ExtUtils::Installed&lt;/a&gt; module to show all installed distributions, although it can take awhile to do its magic. The standard library which comes with Perl just shows up as &quot;Perl&quot; (although you can get those with &lt;a href=&quot;module/corelist&quot;&gt;Module::CoreList&lt;/a&gt;).</source>
          <target state="translated">在Perl程序中，您可以使用&lt;a href=&quot;extutils/installed&quot;&gt;ExtUtils :: Installed&lt;/a&gt;模块来显示所有已安装的发行版，尽管这可能需要一些时间才能完成。Perl附带的标准库只是显示为&amp;ldquo; Perl&amp;rdquo;（尽管您可以使用&lt;a href=&quot;module/corelist&quot;&gt;Module :: CoreList&lt;/a&gt;获得它们）。</target>
        </trans-unit>
        <trans-unit id="2ac6e4915bcad5900cd6401a5966f997e137a0c9" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; code block, &lt;code&gt;$?&lt;/code&gt; contains the value that the program is going to pass to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; to change the exit value of the program. Beware of changing &lt;code&gt;$?&lt;/code&gt; by accident (e.g. by running something via &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">在 &lt;code&gt;END&lt;/code&gt; 代码块中， &lt;code&gt;$?&lt;/code&gt; 包含程序要传递给 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 的值。您可以修改 &lt;code&gt;$?&lt;/code&gt; 更改程序的退出值。当心改变 &lt;code&gt;$?&lt;/code&gt; 偶然（例如通过 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 运行某些东西）。</target>
        </trans-unit>
        <trans-unit id="2a3aa49ae51d12807c062f5debba3be515ca72cb" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; subroutine &lt;code&gt;$?&lt;/code&gt; contains the value that is going to be given to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; in an &lt;code&gt;END&lt;/code&gt; subroutine to change the exit status of your program. For example:</source>
          <target state="translated">在 &lt;code&gt;END&lt;/code&gt; 子程序 &lt;code&gt;$?&lt;/code&gt; 包含将要提供给 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 的值。您可以修改 &lt;code&gt;$?&lt;/code&gt; 在 &lt;code&gt;END&lt;/code&gt; 子程序中更改程序的退出状态。例如：</target>
        </trans-unit>
        <trans-unit id="6a3aafbb284a68739c4fb1ae1f60eb5141dcdda7" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;CHECK&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt; .</source>
          <target state="translated">里面的 &lt;code&gt;CHECK&lt;/code&gt; 块，价值 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 将 &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77fd9286042f60d2513d71db2f202e6d15711855" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;END&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;END&quot;&lt;/code&gt; .</source>
          <target state="translated">里面的 &lt;code&gt;END&lt;/code&gt; 块，价值 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 将 &lt;code&gt;&quot;END&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a193b063515ab15da965bd3478de34c4b7d0830" translate="yes" xml:space="preserve">
          <source>Inside of an &lt;code&gt;INIT&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;INIT&quot;&lt;/code&gt; .</source>
          <target state="translated">一个内部 &lt;code&gt;INIT&lt;/code&gt; 块，价值 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 将 &lt;code&gt;&quot;INIT&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b24121a7266e78f12986b250ed98974d9cfcc24b" translate="yes" xml:space="preserve">
          <source>Inside such a</source>
          <target state="translated">在这样一个</target>
        </trans-unit>
        <trans-unit id="f7a01b93c52f9dee6e4b496cdb9ca5fafa7aa5b5" translate="yes" xml:space="preserve">
          <source>Inside the Perl core (&lt;code&gt;PERL_CORE&lt;/code&gt; defined), you can get at the functions either with or without the &lt;code&gt;Perl_&lt;/code&gt; prefix, thanks to a bunch of defines that live in</source>
          <target state="translated">在Perl内核中（定义了 &lt;code&gt;PERL_CORE&lt;/code&gt; ），可以使用带有或不 &lt;code&gt;Perl_&lt;/code&gt; 前缀的函数，这要感谢存在于其中的许多定义。</target>
        </trans-unit>
        <trans-unit id="0daafc0685af0d01e22cebc44846559b24d94dc9" translate="yes" xml:space="preserve">
          <source>Inside your block, you can use a &lt;code&gt;;&lt;/code&gt; before the ellipsis to denote that the &lt;code&gt;{ ... }&lt;/code&gt; is a block and not a hash reference constructor. Now the ellipsis works:</source>
          <target state="translated">在您的区块中，您可以使用 &lt;code&gt;;&lt;/code&gt; 在省略号之前表示 &lt;code&gt;{ ... }&lt;/code&gt; 是一个块，而不是哈希引用构造函数。现在省略号起作用了：</target>
        </trans-unit>
        <trans-unit id="c37269c429f2ad22959db0e60ac4d8827e7e42ce" translate="yes" xml:space="preserve">
          <source>Inside-Out objects</source>
          <target state="translated">由内而外的对象</target>
        </trans-unit>
        <trans-unit id="7a4af927ec1e221d9c738e75cdfca5e119205956" translate="yes" xml:space="preserve">
          <source>Inside-out classes give us freedom of inheritance, but as usual there is a price.</source>
          <target state="translated">内外班给了我们继承的自由,但照旧有代价的。</target>
        </trans-unit>
        <trans-unit id="ec3c84ba848d8b0d780dabe6d5db65999ccfe2b2" translate="yes" xml:space="preserve">
          <source>Inside-out implementation based on the &lt;code&gt;id()&lt;/code&gt; function with explicit object registry. No destructor is needed and objects are thread safe.</source>
          <target state="translated">基于 &lt;code&gt;id()&lt;/code&gt; 函数的内外实现与显式对象注册表。不需要析构函数，并且对象是线程安全的。</target>
        </trans-unit>
        <trans-unit id="093639ed82951fb2c05d82fa61065038c4a3f59b" translate="yes" xml:space="preserve">
          <source>Inside-out implementation based on the &lt;code&gt;id()&lt;/code&gt; function. It needs a &lt;code&gt;DESTROY&lt;/code&gt; method. For thread support a &lt;code&gt;CLONE&lt;/code&gt; method (not shown) would also be needed. Instead of &lt;code&gt;Hash::Util::FieldHash::id()&lt;/code&gt; the function &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; could be used with very little functional difference. This is the basic pattern of an inside-out class.</source>
          <target state="translated">基于 &lt;code&gt;id()&lt;/code&gt; 函数的由内而外的实现。它需要一个 &lt;code&gt;DESTROY&lt;/code&gt; 方法。对于线程支持，也将需要 &lt;code&gt;CLONE&lt;/code&gt; 方法（未显示）。代替 &lt;code&gt;Hash::Util::FieldHash::id()&lt;/code&gt; ，可以使用功能 &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; ，而功能差异很小。这是由内而外的类的基本模式。</target>
        </trans-unit>
        <trans-unit id="26f7dff6871418123fc5bf54019b9bfae13765ed" translate="yes" xml:space="preserve">
          <source>Inspecting &lt;code&gt;$UTF8{Euro}&lt;/code&gt; shows that it contains 3 bytes: &quot;\xe2\x82\xac&quot;. However, it contains only 1 character, number 0x20AC. The round trip can be completed with &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">检查 &lt;code&gt;$UTF8{Euro}&lt;/code&gt; 显示它包含3个字节：&amp;ldquo; \ xe2 \ x82 \ xac&amp;rdquo;。但是，它仅包含1个字符，编号为0x20AC。往返旅行可以通过 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 完成：</target>
        </trans-unit>
        <trans-unit id="59207d175da65683910680d9c040a0c388fa1f23" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2005 first, then the Platform SDK. Setup your environment as follows (assuming default installation locations were chosen):</source>
          <target state="translated">首先安装Visual C++2005,然后安装Platform SDK。设置环境如下(假设选择了默认的安装位置)。</target>
        </trans-unit>
        <trans-unit id="33cbab1690c07ca74d0ff29dfe5b56b37a842899" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2008-2013 Express, then setup your environment using, e.g.</source>
          <target state="translated">安装Visual C++2008-2013 Express,然后使用,例如,设置你的环境。</target>
        </trans-unit>
        <trans-unit id="2f196edb7ca2b342cfc8b1c8d1c16c051256d43c" translate="yes" xml:space="preserve">
          <source>Install a callback for a named event.</source>
          <target state="translated">为一个命名的事件安装一个回调。</target>
        </trans-unit>
        <trans-unit id="098146decab9cf9682dd20a4b2bc8c4001fb20aa" translate="yes" xml:space="preserve">
          <source>Install a signal mask and suspend process until signal arrives. This uses &lt;code&gt;POSIX::SigSet&lt;/code&gt; objects for the &lt;code&gt;signal_mask&lt;/code&gt; argument. Consult your system's &lt;code&gt;sigsuspend&lt;/code&gt; manpage for details.</source>
          <target state="translated">安装信号罩并暂停过程，直到信号到达。这使用 &lt;code&gt;POSIX::SigSet&lt;/code&gt; 对象作为 &lt;code&gt;signal_mask&lt;/code&gt; 参数。有关详细信息，请查阅系统的 &lt;code&gt;sigsuspend&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="5064d1cdb752ce928134eb0a4e8326765bed0d5e" translate="yes" xml:space="preserve">
          <source>Install all distributions that have been tested successfully but have not yet been installed. See also &lt;code&gt;is_tested&lt;/code&gt; .</source>
          <target state="translated">安装已成功测试但尚未安装的所有发行版。另请参见 &lt;code&gt;is_tested&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30bb41e456f55898b9a816d97d83d13570e789d0" translate="yes" xml:space="preserve">
          <source>Install files from here to there</source>
          <target state="translated">从这里到那里安装文件</target>
        </trans-unit>
        <trans-unit id="be838642bc4439dddc0a654f23d9ebf8387685d2" translate="yes" xml:space="preserve">
          <source>Install my_handler() as the handler for the &lt;b&gt;normal-signals&lt;/b&gt;:</source>
          <target state="translated">安装my_handler（）作为&lt;b&gt;常规信号&lt;/b&gt;的处理程序：</target>
        </trans-unit>
        <trans-unit id="f8eeec02705f1ef8eb9bf0619d6a4de1e15c32de" translate="yes" xml:space="preserve">
          <source>Install my_handler() as the handler for the normal-signals, provide a Perl stack trace on receipt of one of the error-signals:</source>
          <target state="translated">安装my_handler()作为正常信号的处理程序,在收到一个错误信号时提供一个Perl堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="e64dce2583dfe013eb849f3d2d103a519b4f693d" translate="yes" xml:space="preserve">
          <source>Install the Toolkit first, then the Platform SDK, then the .NET Framework SDK. Setup your environment as follows (assuming default installation locations were chosen):</source>
          <target state="translated">首先安装工具包,然后安装Platform SDK,再安装.NET Framework SDK。按以下方式设置您的环境(假设选择了默认的安装位置)。</target>
        </trans-unit>
        <trans-unit id="cd990d98fdc32595b067d42fc715d5ce94d57be2" translate="yes" xml:space="preserve">
          <source>Install the bundle &lt;code&gt;Bundle::OS2_default&lt;/code&gt;</source>
          <target state="translated">安装包 &lt;code&gt;Bundle::OS2_default&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b20b73b1de67223c2bd9207fae1a1e9b72c2233d" translate="yes" xml:space="preserve">
          <source>Install the bundle file you produced in the first step with something like</source>
          <target state="translated">安装你在第一步制作的bundle文件,使用类似于</target>
        </trans-unit>
        <trans-unit id="a972b5a9d813b2528044bfdb606fb493e85bedb6" translate="yes" xml:space="preserve">
          <source>Install will copy the files into the Windows machine where NetWare Perl is installed and these files may have to be copied to the NetWare server manually. Alternatively, pass</source>
          <target state="translated">安装将把文件复制到安装 NetWare Perl 的 Windows 机器中,这些文件可能需要手动复制到 NetWare 服务器中。另外,也可以通过</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="5170591ca8711f15e1b20c47f412774e19b0fe70" translate="yes" xml:space="preserve">
          <source>Installation Anomalies with Perl on OS/390</source>
          <target state="translated">在OS/390上使用Perl的安装异常现象</target>
        </trans-unit>
        <trans-unit id="8744a89757a103643f2c85c220b914d085ffdf88" translate="yes" xml:space="preserve">
          <source>Installation Prefix</source>
          <target state="translated">安装前缀</target>
        </trans-unit>
        <trans-unit id="180cc178e07c1743ecf9dbe37bab2bf2dabe5bb5" translate="yes" xml:space="preserve">
          <source>Installation of Perl on DOS</source>
          <target state="translated">在DOS上安装Perl</target>
        </trans-unit>
        <trans-unit id="cfb2e768feadc8837cc7fc759954e96ac60a95b5" translate="yes" xml:space="preserve">
          <source>Installation of Perl on Windows</source>
          <target state="translated">在Windows上安装Perl</target>
        </trans-unit>
        <trans-unit id="4ca02b48dd8aa7c8862ef964b8ef23527a77760c" translate="yes" xml:space="preserve">
          <source>Installing Perl Documentation on Plan 9</source>
          <target state="translated">在Plan 9上安装Perl文档</target>
        </trans-unit>
        <trans-unit id="2ae981a52ea5c2d2aafd4355287d2406dc0ef314" translate="yes" xml:space="preserve">
          <source>Installing Perl in OS/400 PASE</source>
          <target state="translated">在OS/400 PASE中安装Perl</target>
        </trans-unit>
        <trans-unit id="b61a365b42d75d8e047fa9fe92ff65b4f60e9701" translate="yes" xml:space="preserve">
          <source>Installing Perl on BS2000</source>
          <target state="translated">在BS2000上安装Perl</target>
        </trans-unit>
        <trans-unit id="0417ed1ca822a227853883f689e9fa61b7253133" translate="yes" xml:space="preserve">
          <source>Installing dynamic extensions</source>
          <target state="translated">安装动态扩展</target>
        </trans-unit>
        <trans-unit id="d551e6ba21a76c8b829c9fd66b0f82cb57a2e6c1" translate="yes" xml:space="preserve">
          <source>Installing handlers into UNIVERSAL, makes them...err..universal. For example:</source>
          <target state="translated">将处理程序安装到UNIVERSAL中,使得它们......呃......通用。例如:</target>
        </trans-unit>
        <trans-unit id="0cfc88ee57d518bf7af556a12ced2b10a8287ca8" translate="yes" xml:space="preserve">
          <source>Installing static extensions</source>
          <target state="translated">安装静态扩展</target>
        </trans-unit>
        <trans-unit id="257dd2466c69ad9b24149fb3bc3f1813543ba72a" translate="yes" xml:space="preserve">
          <source>Installing the built Perl on AmigaOS</source>
          <target state="translated">在AmigaOS上安装建立的Perl</target>
        </trans-unit>
        <trans-unit id="db29ef231e31119424ca9f0f93b9223b833e4152" translate="yes" xml:space="preserve">
          <source>Installing the built perl</source>
          <target state="translated">安装内置的perl</target>
        </trans-unit>
        <trans-unit id="d904df04db30e9f6033f6ecb3f32eb4c2b0e5b70" translate="yes" xml:space="preserve">
          <source>Installing your Extension</source>
          <target state="translated">安装您的分机</target>
        </trans-unit>
        <trans-unit id="dd4a61ab3dc44ab9b5a205303724a68f74a735a7" translate="yes" xml:space="preserve">
          <source>Instance Methods</source>
          <target state="translated">实例方法</target>
        </trans-unit>
        <trans-unit id="e18280b32ffbeebedfcc0fc6dbe9b749315b6ea6" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt; , we can write &lt;code&gt;$a[1][2]&lt;/code&gt; ; it means the same thing. Instead of &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt; , we can write &lt;code&gt;$a[0][1] = 23&lt;/code&gt; ; it means the same thing.</source>
          <target state="translated">代替 &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt; ，我们可以写 &lt;code&gt;$a[1][2]&lt;/code&gt; ；这意味着同一件事。代替 &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt; ，我们可以写 &lt;code&gt;$a[0][1] = 23&lt;/code&gt; ; 这意味着同一件事。</target>
        </trans-unit>
        <trans-unit id="ba491ba1ec8ef4be8f85786b6a781edf6fccddb7" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; , you can simply use &lt;code&gt;:utf8&lt;/code&gt; , which skips the encoding step if the data was already represented as UTF8 internally. This is widely accepted as good behavior when you're writing, but it can be dangerous when reading, because it causes internal inconsistency when you have invalid byte sequences. Using &lt;code&gt;:utf8&lt;/code&gt; for input can sometimes result in security breaches, so please use &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; instead.</source>
          <target state="translated">代替 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; ，您可以简单地使用 &lt;code&gt;:utf8&lt;/code&gt; ，如果数据已经在内部表示为UTF8，则跳过编码步骤。在编写时，这被普遍认为是一种良好的行为，但在读取时可能会很危险，因为当字节序列无效时，这会导致内部不一致。使用 &lt;code&gt;:utf8&lt;/code&gt; 进行输入有时可能会导致安全漏洞，因此请改用 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77ad0b5725694a222d6ac24da3bbb122aa3a958a" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;decode&lt;/code&gt; and &lt;code&gt;encode&lt;/code&gt; , you could use &lt;code&gt;_utf8_on&lt;/code&gt; and &lt;code&gt;_utf8_off&lt;/code&gt; , but this is considered bad style. Especially &lt;code&gt;_utf8_on&lt;/code&gt; can be dangerous, for the same reason that &lt;code&gt;:utf8&lt;/code&gt; can.</source>
          <target state="translated">可以使用 &lt;code&gt;_utf8_on&lt;/code&gt; 和 &lt;code&gt;_utf8_off&lt;/code&gt; 代替 &lt;code&gt;decode&lt;/code&gt; 和 &lt;code&gt;encode&lt;/code&gt; ，但这被认为是不好的样式。尤其是 &lt;code&gt;_utf8_on&lt;/code&gt; 可能很危险，原因与 &lt;code&gt;:utf8&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="1f30761f7bbd31f759ef384a9ad19f6187329e7a" translate="yes" xml:space="preserve">
          <source>Instead of a filename, you can also pass it an existing &lt;code&gt;Archive::Tar::File&lt;/code&gt; object from, for example, another archive. The object will be clone, and effectively be a copy of the original, not an alias.</source>
          <target state="translated">除了文件名，您还可以向它传递来自另一个归档 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 的现有Archive :: Tar :: File对象。该对象将被克隆，并且实际上是原始副本的副本，而不是别名。</target>
        </trans-unit>
        <trans-unit id="3d7794c8d2e8209f9cf8a080564bc83932d1de0d" translate="yes" xml:space="preserve">
          <source>Instead of a number, you can use &lt;code&gt;*&lt;/code&gt; to mean &quot;consume everything else left&quot;.</source>
          <target state="translated">可以用 &lt;code&gt;*&lt;/code&gt; 代替数字，以表示&amp;ldquo;消耗掉剩下的所有东西&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2d5ef8b3223bf8e72260629cb76365a1c7d119c3" translate="yes" xml:space="preserve">
          <source>Instead of an actual C function that has to fetch the thread context using &lt;code&gt;dTHX&lt;/code&gt; , you can define macros of the same name and avoid the overhead. Also, keep in mind to possibly free the memory allocated by &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt; .</source>
          <target state="translated">不必使用 &lt;code&gt;dTHX&lt;/code&gt; 使用dTHX获取线程上下文的实际C函数，您可以定义相同名称的宏并避免开销。另外，请记住可能释放 &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt; 分配的内存。</target>
        </trans-unit>
        <trans-unit id="efec145a63aada8917ea862470d1c559b417d5a8" translate="yes" xml:space="preserve">
          <source>Instead of it, do like this:</source>
          <target state="translated">与其这样,不如这样做。</target>
        </trans-unit>
        <trans-unit id="18bf50916f725e20e492e415ffe30f1d8deec329" translate="yes" xml:space="preserve">
          <source>Instead of loading feature bundles by name, it is easier to let Perl do implicit loading of a feature bundle for you.</source>
          <target state="translated">与其按名称加载功能包,不如让Perl为你隐式加载功能包。</target>
        </trans-unit>
        <trans-unit id="4549985addea58856a2589a95661e1f3d1246c4e" translate="yes" xml:space="preserve">
          <source>Instead of setting &lt;code&gt;$SIG{ALRM}&lt;/code&gt; :</source>
          <target state="translated">而不是设置 &lt;code&gt;$SIG{ALRM}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a4cf4072b6ecd93f69baec56cef0a223f95f5666" translate="yes" xml:space="preserve">
          <source>Instead of specifying the VERSION in the Makefile.PL you can let MakeMaker parse a file to determine the version number. The parsing routine requires that the file named by VERSION_FROM contains one single line to compute the version number. The first line in the file that contains something like a $VERSION assignment or &lt;code&gt;package Name
VERSION&lt;/code&gt; will be used. The following lines will be parsed o.k.:</source>
          <target state="translated">您可以让MakeMaker解析文件以确定版本号，而不是在Makefile.PL中指定版本。解析例程要求VERSION_FROM命名的文件包含一行以计算版本号。文件中的第一行将包含$ VERSION赋值或 &lt;code&gt;package Name VERSION&lt;/code&gt; 内容。可以解析以下行：</target>
        </trans-unit>
        <trans-unit id="c9d067c5eb0ad6111602fcfc2b4a14a7fd5906ed" translate="yes" xml:space="preserve">
          <source>Instead of the</source>
          <target state="translated">取而代之的是</target>
        </trans-unit>
        <trans-unit id="52ef12851a02520ecdc1bb50b94ab80ca32cf34d" translate="yes" xml:space="preserve">
          <source>Instead of the above process, with Filter::Simple the task of setting up a source code filter is reduced to:</source>
          <target state="translated">有了Filter::Simple,设置源代码过滤器的任务就不再是上述过程,而是简化为。</target>
        </trans-unit>
        <trans-unit id="08d78413d66ea6fc10e343adae82dd66dad36d77" translate="yes" xml:space="preserve">
          <source>Instead of the shell's &lt;code&gt;expand&lt;/code&gt; command, use:</source>
          <target state="translated">代替shell的 &lt;code&gt;expand&lt;/code&gt; 命令，使用：</target>
        </trans-unit>
        <trans-unit id="c97f35f08c784710202f7afd89947e84d996ff4b" translate="yes" xml:space="preserve">
          <source>Instead of the shell's &lt;code&gt;unexpand -a&lt;/code&gt; command, use:</source>
          <target state="translated">代替shell的 &lt;code&gt;unexpand -a&lt;/code&gt; 命令，使用：</target>
        </trans-unit>
        <trans-unit id="6ba67eec9e92df05acdf46af85244d2e3cb47ac2" translate="yes" xml:space="preserve">
          <source>Instead of this:</source>
          <target state="translated">而不是这样。</target>
        </trans-unit>
        <trans-unit id="f550302de10f6528309a1269c83c4106b886739f" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;$*&lt;/code&gt; you should use the &lt;code&gt;/m&lt;/code&gt; (and maybe &lt;code&gt;/s&lt;/code&gt;) regexp modifiers. You can enable &lt;code&gt;/m&lt;/code&gt; for a lexical scope (even a whole file) with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/m'&lt;/code&gt; . (In older versions: when &lt;code&gt;$*&lt;/code&gt; was set to a true value then all regular expressions behaved as if they were written using &lt;code&gt;/m&lt;/code&gt;.)</source>
          <target state="translated">而不是使用 &lt;code&gt;$*&lt;/code&gt; 您应该使用 &lt;code&gt;/m&lt;/code&gt; （也许是 &lt;code&gt;/s&lt;/code&gt; ）正则表达式修饰符。您可以 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/m'&lt;/code&gt; re'/ m'为词法作用域（甚至整个文件）启用 &lt;code&gt;/m&lt;/code&gt; 。（在较早的版本中：当 &lt;code&gt;$*&lt;/code&gt; 设置为true值时，所有正则表达式的行为就像使用 &lt;code&gt;/m&lt;/code&gt; 编写的一样。）</target>
        </trans-unit>
        <trans-unit id="6e1ae30c884ab234189c910ec5202733bc2390ed" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;given()&lt;/code&gt; , you can use a &lt;code&gt;foreach()&lt;/code&gt; loop. For example, here's one way to count how many times a particular string occurs in an array:</source>
          <target state="translated">而不是使用 &lt;code&gt;given()&lt;/code&gt; ，您可以使用 &lt;code&gt;foreach()&lt;/code&gt; 循环。例如，这是一种计算特定字符串在数组中出现多少次的方法：</target>
        </trans-unit>
        <trans-unit id="ccf329df99c7b872b2b1eb49834514d53120f89e" translate="yes" xml:space="preserve">
          <source>Instead of writing an overloaded interface using pure Perl, you can also use the OVERLOAD keyword to define additional Perl names for your functions (like the ALIAS: keyword above). However, the overloaded functions must be defined with three parameters (except for the nomethod() function which needs four parameters). If any function has the OVERLOAD: keyword, several additional lines will be defined in the c file generated by xsubpp in order to register with the overload magic.</source>
          <target state="translated">与使用纯Perl编写重载接口不同,你也可以使用OVERLOAD关键字为你的函数定义额外的Perl名称(就像上面的ALIAS:关键字)。但是,重载函数必须用三个参数来定义(除了nomethod()函数需要四个参数)。如果任何函数有OVERLOAD:关键字,那么在xsubpp生成的c文件中会有几行额外的定义,以便注册重载魔法。</target>
        </trans-unit>
        <trans-unit id="638fcabfcb5cd72cef4275780294bf41068d5ea4" translate="yes" xml:space="preserve">
          <source>Instead of writing multiple &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; statements, you may define multiple constants in a single statement by giving, instead of the constant name, a reference to a hash where the keys are the names of the constants to be defined. Obviously, all constants defined using this method must have a single value.</source>
          <target state="translated">除了编写多个 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; 语句外，还可以在单​​个语句中定义多个常量，方法是给散列（而不是常量名）提供对哈希的引用，其中键是要定义的常量的名称。显然，使用此方法定义的所有常量都必须具有单个值。</target>
        </trans-unit>
        <trans-unit id="6782b252ab0c32bd42d86fbd7b3f79af4ff565e5" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toFOLD_utf8&quot;&gt;toFOLD_utf8&lt;/a&gt;.</source>
          <target state="translated">而是使用&lt;a href=&quot;#toFOLD_utf8&quot;&gt;toFOLD_utf8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d1f6743fcc3e6286f6e367f0b73ab61c02242a50" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toLOWER_utf8&quot;&gt;toLOWER_utf8&lt;/a&gt;.</source>
          <target state="translated">而是使用&lt;a href=&quot;#toLOWER_utf8&quot;&gt;toLOWER_utf8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef6bd3b06361be7e68d9b7223a3d403afc7f30fb" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toTITLE_utf8&quot;&gt;toTITLE_utf8&lt;/a&gt;.</source>
          <target state="translated">而是使用&lt;a href=&quot;#toTITLE_utf8&quot;&gt;toTITLE_utf8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f68321016539906487e3d1b25d1d9b7700cb63a1" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toUPPER_utf8&quot;&gt;toUPPER_utf8&lt;/a&gt;.</source>
          <target state="translated">而是使用&lt;a href=&quot;#toUPPER_utf8&quot;&gt;toUPPER_utf8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8ee82e6fa25bfd2bc478049adfc2e72d633951e" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;, or rarely, &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt;.</source>
          <target state="translated">而是使用&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;，或者很少使用&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a1e3be314ffd2bc3abc3de781de1fea85191bb5" translate="yes" xml:space="preserve">
          <source>Instead you almost certainly want to use &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; or &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;.</source>
          <target state="translated">相反，您几乎可以肯定要使用&lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt;或&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c61a7798941b565eb0ca8902a985ea083443b8b" translate="yes" xml:space="preserve">
          <source>Instead, &lt;code&gt;bytes_to_utf8&lt;/code&gt; will give you a UTF-8-encoded &lt;b&gt;copy&lt;/b&gt; of its string argument. This is useful for having the data available for comparisons and so on, without harming the original SV. There's also &lt;code&gt;utf8_to_bytes&lt;/code&gt; to go the other way, but naturally, this will fail if the string contains any characters above 255 that can't be represented in a single byte.</source>
          <target state="translated">相反， &lt;code&gt;bytes_to_utf8&lt;/code&gt; 将为您提供其字符串参数的UTF-8编码&lt;b&gt;副本&lt;/b&gt;。这对于使数据可用于比较等很有用，而又不会损害原始SV。另外还有 &lt;code&gt;utf8_to_bytes&lt;/code&gt; ，但是很自然，如果字符串中包含任何不能用单个字节表示的255以上的字符，则失败。</target>
        </trans-unit>
        <trans-unit id="1d682bf7489c4d815717f3faba809d2c01f4ea4b" translate="yes" xml:space="preserve">
          <source>Instead, all available methods to execute plain text files on Windows rely on the file &quot;extension&quot;. There are three methods to use this to execute perl scripts:</source>
          <target state="translated">相反,在Windows上执行纯文本文件的所有可用方法都依赖于文件的 &quot;扩展名&quot;。有三种方法可以用来执行perl脚本。</target>
        </trans-unit>
        <trans-unit id="1b6f6bc21ad6a818717c640ad98e7196014d29c9" translate="yes" xml:space="preserve">
          <source>Instead, have it like this:</source>
          <target state="translated">而是要这样。</target>
        </trans-unit>
        <trans-unit id="767f1cd6299c67c930c8d9fe765261f308e05da4" translate="yes" xml:space="preserve">
          <source>Instead, the following solution works rather well. The nice things about it are 1) you can start using it right away; 2) it is more powerful, because it will do the right thing with a pattern like */*/*.c; 3) you can decide whether you do/don't want to use it; and 4) you can extend the method to add any customizations (or even entirely different kinds of wildcard expansion).</source>
          <target state="translated">相反,下面的解决方案相当好用。它的好处是:1)你可以马上开始使用它;2)它的功能更强大,因为它会用*/*/*.c这样的模式做正确的事情;3)你可以决定是否使用/不使用它;4)你可以扩展该方法以添加任何自定义(甚至是完全不同种类的通配符扩展)。</target>
        </trans-unit>
        <trans-unit id="ca3e6ac1b90019684415c1dbba6b4a76bfa88d1e" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;blessed&lt;/code&gt; (in the &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module) for boolean checks, &lt;code&gt;isa&lt;/code&gt; for specific class checks and &lt;code&gt;reftype&lt;/code&gt; (also from &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;) for type checks. (See &lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt; for details and a &lt;code&gt;blessed/isa&lt;/code&gt; example.)</source>
          <target state="translated">取而代之的是，将 &lt;code&gt;blessed&lt;/code&gt; （在&lt;a href=&quot;../scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;模块中）用于布尔检查，将 &lt;code&gt;isa&lt;/code&gt; 用于特定的类检查，将 &lt;code&gt;reftype&lt;/code&gt; （也来自&lt;a href=&quot;../scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;）用于类型检查。（有关详细信息和 &lt;code&gt;blessed/isa&lt;/code&gt; 示例，请参见&lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="ff6123faf0e0d43395bbeea664d72b0be06f73ad" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;blessed&lt;/code&gt; (in the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module) for boolean checks, &lt;code&gt;isa&lt;/code&gt; for specific class checks and &lt;code&gt;reftype&lt;/code&gt; (also from &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;) for type checks. (See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for details and a &lt;code&gt;blessed/isa&lt;/code&gt; example.)</source>
          <target state="translated">取而代之的是，将 &lt;code&gt;blessed&lt;/code&gt; （在&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;模块中）用于布尔检查，将 &lt;code&gt;isa&lt;/code&gt; 用于特定的类检查，将 &lt;code&gt;reftype&lt;/code&gt; （也来自&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;）用于类型检查。（有关详细信息和 &lt;code&gt;blessed/isa&lt;/code&gt; 示例，请参见&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="4b239d64a76a8342f4a5e3f91a8ae44b81bce472" translate="yes" xml:space="preserve">
          <source>Instead, use double-quotes with a single backslash:</source>
          <target state="translated">取而代之的是使用双引号与单反斜杠。</target>
        </trans-unit>
        <trans-unit id="d6975d2303b579219cd1ad4ae114ac6792c64260" translate="yes" xml:space="preserve">
          <source>Instead, use the definitions IV, UV, IVSIZE, I32SIZE, and so forth. Avoid things like I32 because they are &lt;b&gt;not&lt;/b&gt; guaranteed to be</source>
          <target state="translated">而是使用定义IV，UV，IVSIZE，I32SIZE等。避免使用I32之类的东西，因为&lt;b&gt;不能&lt;/b&gt;保证</target>
        </trans-unit>
        <trans-unit id="08114352d8e01718b9f4310cee2e4e9e17e09b27" translate="yes" xml:space="preserve">
          <source>Instructions on how to install your module along with any dependencies. Suggested information to include here:</source>
          <target state="translated">说明如何安装你的模块以及所有的依赖关系。建议在这里包含的信息。</target>
        </trans-unit>
        <trans-unit id="ecdea140cf34e5fdf5440492ab0f9ef1743393d2" translate="yes" xml:space="preserve">
          <source>Insure that colons marking targets are preceded by space, in order to distinguish the target delimiter from a colon appearing as part of a filespec.</source>
          <target state="translated">确保标示目标的冒号前面有空格,以便将目标定界符与作为 filespec 的一部分出现的冒号区分开来。</target>
        </trans-unit>
        <trans-unit id="683987ee4aeb538cfdf37663a8c0ab7ac90a2019" translate="yes" xml:space="preserve">
          <source>Integer Arithmetic</source>
          <target state="translated">整数算术</target>
        </trans-unit>
        <trans-unit id="efbf94ff9c1725858eeaef5462e64f2f9beabf82" translate="yes" xml:space="preserve">
          <source>Integer binary logarithm [C99]</source>
          <target state="translated">整数二进制对数[C99]</target>
        </trans-unit>
        <trans-unit id="0bbddfa82bfc58cb4fa39eff708183ee398ca07e" translate="yes" xml:space="preserve">
          <source>Integer binary logarithm [C99].</source>
          <target state="translated">整数二进制对数[C99]。</target>
        </trans-unit>
        <trans-unit id="d2e40742eb38c2f7d8587ad34912b36536447d35" translate="yes" xml:space="preserve">
          <source>Integer. An optional leading plus or minus sign, followed by a sequence of digits.</source>
          <target state="translated">整数。一个可选的前导加号或后导减号,后面是一个数字序列。</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="4b35a75e337792a14859048b5fe4c1f4a2d46a86" translate="yes" xml:space="preserve">
          <source>Integrating local directories</source>
          <target state="translated">整合本地目录</target>
        </trans-unit>
        <trans-unit id="f3a43fe57e64c611c07e7f0722fcf5e81fd02d7e" translate="yes" xml:space="preserve">
          <source>Intel HEX</source>
          <target state="translated">英特尔HEX</target>
        </trans-unit>
        <trans-unit id="283a7688f976826bc81b0d15b139b8fb7bc39125" translate="yes" xml:space="preserve">
          <source>Intel HEX is a file format for representing binary data, mostly for programming various chips, as a text file. (See &lt;a href=&quot;http://en.wikipedia.org/wiki/.hex&quot;&gt;http://en.wikipedia.org/wiki/.hex&lt;/a&gt; for a detailed description, and &lt;a href=&quot;http://en.wikipedia.org/wiki/SREC_&quot;&gt;http://en.wikipedia.org/wiki/SREC_&lt;/a&gt;(file_format) for the Motorola S-record format, which can be unravelled using the same technique.) Each line begins with a colon (':') and is followed by a sequence of hexadecimal characters, specifying a byte count</source>
          <target state="translated">Intel HEX是一种文件格式，用于表示二进制数据（主要用于对各种芯片进行编程）作为文本文件。（参见&lt;a href=&quot;http://en.wikipedia.org/wiki/.hex&quot;&gt;http://en.wikipedia.org/wiki/.hex&lt;/a&gt;要详细描述，以及&lt;a href=&quot;http://en.wikipedia.org/wiki/SREC_&quot;&gt;http://en.wikipedia.org/wiki/SREC_&lt;/a&gt;（file_format）为摩托罗拉S-记录格式，其可以被解开（使用相同的技术。）每行以冒号（'：'）开头，后跟一系列十六进制字符，并指定字节数</target>
        </trans-unit>
        <trans-unit id="380d7ac3123e0e68ffb5963fc34784cfb9731163" translate="yes" xml:space="preserve">
          <source>Intended for use on command line with &lt;b&gt;-M&lt;/b&gt; option as a way of testing arbitrary scripts against an uninstalled version of a package.</source>
          <target state="translated">旨在与&lt;b&gt;-M&lt;/b&gt;选项一起在命令行上使用，以针对卸载的软件包版本测试任意脚本。</target>
        </trans-unit>
        <trans-unit id="d75d6528effe0d95b951e2f70179256a5a75c5b0" translate="yes" xml:space="preserve">
          <source>Interacting with Perl from the Digital Command Language (DCL) shell often requires a different set of quotation marks than Unix shells do. For example:</source>
          <target state="translated">从数字命令语言(DCL)shell中与Perl进行交互时,通常需要一组不同于Unix shell的引号。例如:</target>
        </trans-unit>
        <trans-unit id="39c574bcdb6de6c0029ded259821021591e578be" translate="yes" xml:space="preserve">
          <source>Interaction with Extensions</source>
          <target state="translated">与扩展部分的互动</target>
        </trans-unit>
        <trans-unit id="36743263147e4579bf65378679da63cd8385f8a2" translate="yes" xml:space="preserve">
          <source>Interactive Client with IO::Socket</source>
          <target state="translated">使用IO::Socket的交互式客户端</target>
        </trans-unit>
        <trans-unit id="a16954cde7a599ddba4d577acd1b685762317ea3" translate="yes" xml:space="preserve">
          <source>Interactive mode:</source>
          <target state="translated">互动模式。</target>
        </trans-unit>
        <trans-unit id="bdcd0f2bf481dc531fd0fd8a96b470b347913b64" translate="yes" xml:space="preserve">
          <source>Interactive sessions maintain a lockfile, by default &lt;code&gt;~/.cpan/.&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; . Batch jobs can run without a lockfile and not disturb each other.</source>
          <target state="translated">交互式会话维护一个 &lt;code&gt;~/.cpan/.&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 文件，默认情况下为〜/ .cpan /。锁。批处理作业可以在没有锁定文件的情况下运行，并且不会互相干扰。</target>
        </trans-unit>
        <trans-unit id="4049be05b318660a87d35f9664cb17d1ca51f690" translate="yes" xml:space="preserve">
          <source>Interactively supply an arbitrary &lt;code&gt;expression&lt;/code&gt; using &lt;code&gt;-e&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;-e&lt;/code&gt; 交互式提供任意 &lt;code&gt;expression&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f4333051573407ec799c7bafee1c6ca09470f1b" translate="yes" xml:space="preserve">
          <source>Interestingly we get slightly different results, which is mostly because the algorithm which generates the report is different, even though the output file format was allegedly identical. The elapsed, user and system times are clearly showing the time it took for &lt;code&gt;Devel::Profiler&lt;/code&gt; to execute its own run, but the column listings feel more accurate somehow than the ones we had earlier from &lt;code&gt;Devel::DProf&lt;/code&gt; . The 102% figure has disappeared, for example. This is where we have to use the tools at our disposal, and recognise their pros and cons, before using them. Interestingly, the numbers of calls for each subroutine are identical in the two reports, it's the percentages which differ. As the author of &lt;code&gt;Devel::Proviler&lt;/code&gt; writes:</source>
          <target state="translated">有趣的是，我们得到的结果略有不同，这主要是因为尽管据称输出文件格式相同，但生成报告的算法却有所不同。经过的时间，用户和系统时间清楚地显示了 &lt;code&gt;Devel::Profiler&lt;/code&gt; 执行其自己的运行所花费的时间，但是与我们之前从 &lt;code&gt;Devel::DProf&lt;/code&gt; 获得的列表相比，该列列表在某种程度上感觉更准确。例如，102％的数字消失了。在这里，我们必须使用可用的工具，并在使用它们之前认识它们的优缺点。有趣的是，在两个报告中，每个子例程的调用次数是相同的，只是百分比不同。正如 &lt;code&gt;Devel::Proviler&lt;/code&gt; 的作者写道：</target>
        </trans-unit>
        <trans-unit id="8fe9cc8d59c908d2dfc528838b1b4b5192a00c09" translate="yes" xml:space="preserve">
          <source>Interface Strategy</source>
          <target state="translated">界面策略</target>
        </trans-unit>
        <trans-unit id="e9bdbdb9fc26f525c1a8ecbeb7cc8ceb768f4d54" translate="yes" xml:space="preserve">
          <source>Interface between CPAN.pm and Kwalify.pm</source>
          <target state="translated">CPAN.pm和Kwalify.pm之间的接口。</target>
        </trans-unit>
        <trans-unit id="7481e39dedf2d2f4c332b82f6502c28043c6929e" translate="yes" xml:space="preserve">
          <source>Interface to Berkeley DB</source>
          <target state="translated">与Berkeley DB的接口</target>
        </trans-unit>
        <trans-unit id="8e2ccff2c57048b71f1d307b6edb8f11b2c43b05" translate="yes" xml:space="preserve">
          <source>Interface to cwd from EMX. Used by &lt;code&gt;Cwd::cwd&lt;/code&gt; .</source>
          <target state="translated">从EMX到cwd的接口。由 &lt;code&gt;Cwd::cwd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dae2466aff78641921461ec62c4d4ef5f0f5b074" translate="yes" xml:space="preserve">
          <source>Interface to zlib compression library</source>
          <target state="translated">zlib压缩库的接口</target>
        </trans-unit>
        <trans-unit id="e346886e4b9cdfd6ef396ff466a7b37cd952cc6d" translate="yes" xml:space="preserve">
          <source>Interfaces to / Emulations of Other Programming Languages</source>
          <target state="translated">与其他编程语言的接口/模拟。</target>
        </trans-unit>
        <trans-unit id="2188689d5ae5f33a21007d13b3dcb52813873257" translate="yes" xml:space="preserve">
          <source>Interfaces to some Win32 API Functions</source>
          <target state="translated">一些Win32 API函数的接口</target>
        </trans-unit>
        <trans-unit id="e20643cb83b71e3458cd8974c42d3daa3e1288a1" translate="yes" xml:space="preserve">
          <source>Internal Format</source>
          <target state="translated">内部格式</target>
        </trans-unit>
        <trans-unit id="61d67a4869b5e28886ef542cee4befaab340cf82" translate="yes" xml:space="preserve">
          <source>Internal Functions</source>
          <target state="translated">内部功能</target>
        </trans-unit>
        <trans-unit id="5af8acca69afbd9c6d39218e0bb28d32d199f366" translate="yes" xml:space="preserve">
          <source>Internal configuration handling for CPAN.pm</source>
          <target state="translated">CPAN.pm的内部配置处理</target>
        </trans-unit>
        <trans-unit id="0806883110f04db9f91191aca94f31996b0d72ea" translate="yes" xml:space="preserve">
          <source>Internal debugging for CPAN.pm</source>
          <target state="translated">CPAN.pm的内部调试</target>
        </trans-unit>
        <trans-unit id="4c898c3410ed0ae8d99f5b87b9783ee59e1feeaf" translate="yes" xml:space="preserve">
          <source>Internal debugging messages are enabled when $dl_debug is set true. Currently setting $dl_debug only affects the Perl side of the DynaLoader. These messages should help an application developer to resolve any DynaLoader usage problems.</source>
          <target state="translated">当$dl_debug被设置为true时,内部调试信息将被启用。目前设置$dl_debug只影响DynaLoader的Perl端。这些信息应该可以帮助应用开发者解决任何DynaLoader使用问题。</target>
        </trans-unit>
        <trans-unit id="d873f4a2f97ab05d24f6fa0f06cef45d8aeae3b7" translate="yes" xml:space="preserve">
          <source>Internal format</source>
          <target state="translated">内部格式</target>
        </trans-unit>
        <trans-unit id="a7b06547359f2b157e33961f9b748082a4eb9b46" translate="yes" xml:space="preserve">
          <source>Internal function Hash::Util::FieldHash::_fieldhash</source>
          <target state="translated">内部函数 Hash::Util::FieldHash::_fieldhash。</target>
        </trans-unit>
        <trans-unit id="51b9dd26770184bcb91b7be8acd8ff5db510c8df" translate="yes" xml:space="preserve">
          <source>Internal function which adds the filter, based on the &lt;a href=&quot;http://search.cpan.org/perldoc/filter_add&quot;&gt;filter_add&lt;/a&gt; argument type.</source>
          <target state="translated">基于&lt;a href=&quot;http://search.cpan.org/perldoc/filter_add&quot;&gt;filter_add&lt;/a&gt;参数类型添加过滤器的内部函数。</target>
        </trans-unit>
        <trans-unit id="5fee2b9c80ad50aec00177a91487a9d17942074f" translate="yes" xml:space="preserve">
          <source>Internal handling of tar archives for CPAN.pm</source>
          <target state="translated">CPAN.pm的焦油存档的内部处理。</target>
        </trans-unit>
        <trans-unit id="f7017225658a0f9fba19af865f848f427597c31a" translate="yes" xml:space="preserve">
          <source>Internal method for printing errors and warnings. If no options are given, simply prints &quot;@_&quot;. The following options are recognized and used to form the output:</source>
          <target state="translated">打印错误和警告的内部方法。如果没有给定选项,只打印&quot;@_&quot;。以下选项被识别并用于形成输出。</target>
        </trans-unit>
        <trans-unit id="d524d9cfc678704c162c4cb4460355871a08ade5" translate="yes" xml:space="preserve">
          <source>Internal object used by Time::gmtime and Time::localtime</source>
          <target state="translated">Time::gmtime 和 Time::localtime 使用的内部对象。</target>
        </trans-unit>
        <trans-unit id="dec6a2c45a2bdd64a3ec8fcc2511727cc99b5b26" translate="yes" xml:space="preserve">
          <source>Internal queue support for CPAN.pm</source>
          <target state="translated">CPAN.pm的内部队列支持</target>
        </trans-unit>
        <trans-unit id="1de0eedbd92548d18bf918a068ea4b60732f9cf3" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; are implemented with a real tied interface via &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt;. The methods in that package will call back into these functions. However the usage of &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; for this purpose might change in future releases. For instance this might be implemented by magic instead (would need an extension to mgvtbl).</source>
          <target state="translated">内部 &lt;code&gt;%+&lt;/code&gt; 和 &lt;code&gt;%-&lt;/code&gt; 通过&lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt;通过真正的绑定接口实现。该软件包中的方法将回调这些函数。但是，在将来的发行版中，为此使用&lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt;可能会发生变化。例如，这可以通过魔术来实现（将需要扩展到mgvtbl）。</target>
        </trans-unit>
        <trans-unit id="1b09ff7b696f900f84f4dabc94d78d0ec9f89714" translate="yes" xml:space="preserve">
          <source>Internally CPAN.pm uses the UTF-8 charset. If your terminal is expecting ISO-8859-1 charset, a converter can be activated by setting term_is_latin to a true value in your config file. One way of doing so would be</source>
          <target state="translated">CPAN.pm内部使用的是UTF-8字符集,如果你的终端希望使用ISO-8859-1字符集,可以通过在配置文件中设置term_is_latin为true来激活转换器。如果你的终端希望使用ISO-8859-1字符集,可以通过在配置文件中设置term_is_latin为true来激活一个转换器。一种方法是</target>
        </trans-unit>
        <trans-unit id="80378d1e7d2da0cf424eca7e07458848627808d4" translate="yes" xml:space="preserve">
          <source>Internally Encoding -&amp;gt; Unicode and Unicode -&amp;gt; Encoding Map looks like this;</source>
          <target state="translated">内部编码-&amp;gt; Unicode和Unicode-&amp;gt;编码映射如下所示；</target>
        </trans-unit>
        <trans-unit id="8ac21d3e9553672475ffa22a2c6fb0c3420e3cc6" translate="yes" xml:space="preserve">
          <source>Internally the Benchmark object holds timing values, described in &lt;a href=&quot;#NOTES&quot;&gt;NOTES&lt;/a&gt; below. The following methods can be used to access them:</source>
          <target state="translated">基准对象在内部保存时序值，如以下&lt;a href=&quot;#NOTES&quot;&gt;注释中&lt;/a&gt;所述。可以使用以下方法访问它们：</target>
        </trans-unit>
        <trans-unit id="a523262f74789d99cb822f252d727c1f77360575" translate="yes" xml:space="preserve">
          <source>Internally this is set to &lt;code&gt;NULL&lt;/code&gt; unless a custom engine is specified in &lt;code&gt;$^H{regcomp}&lt;/code&gt; , Perl's own set of callbacks can be accessed in the struct pointed to by &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt; .</source>
          <target state="translated">在内部，除非在 &lt;code&gt;$^H{regcomp}&lt;/code&gt; 指定了自定义引擎，否则将其设置为 &lt;code&gt;NULL&lt;/code&gt; ，可以在 &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt; 指向的结构中访问Perl自己的回调集。</target>
        </trans-unit>
        <trans-unit id="1d5951d905f459e1665d8721f731d5fdbea427b7" translate="yes" xml:space="preserve">
          <source>Internally used by Encode</source>
          <target state="translated">Encode内部使用</target>
        </trans-unit>
        <trans-unit id="e76ceb49e27718344d5ee1ece08b4b732be4cccc" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::??::ISO_2022_*</source>
          <target state="translated">内部用于Encode::?:ISO_2022_*。</target>
        </trans-unit>
        <trans-unit id="2bebc443d25f2caf9161712ece027e6af3e9145b" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::CN</source>
          <target state="translated">Encode::CN内部使用</target>
        </trans-unit>
        <trans-unit id="449dbdf27f0aebf5b3ec15f606b3cbc5adf19193" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::JP</source>
          <target state="translated">Encode::JP内部使用</target>
        </trans-unit>
        <trans-unit id="c43fcf4d81bc5dc37c2f1693cf4046ad46e8bf06" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::JP::2022_JP*</source>
          <target state="translated">Encode::JP::2022_JP*内部使用。</target>
        </trans-unit>
        <trans-unit id="b7211781b63a5b485cff3f483aa4493e62335113" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::KR</source>
          <target state="translated">Encode::KR内部使用</target>
        </trans-unit>
        <trans-unit id="87865024ef8da5f651d4b8f2dfd42f62371e839c" translate="yes" xml:space="preserve">
          <source>Internally, Perl currently uses either whatever the native eight-bit character set of the platform (for example Latin-1) is, defaulting to UTF-8, to encode Unicode strings. Specifically, if all code points in the string are &lt;code&gt;0xFF&lt;/code&gt; or less, Perl uses the native eight-bit character set. Otherwise, it uses UTF-8.</source>
          <target state="translated">在内部，Perl当前使用平台的本机八位字符集（例如Latin-1）（默认为UTF-8）来编码Unicode字符串。具体来说，如果字符串中的所有代码点都为 &lt;code&gt;0xFF&lt;/code&gt; 或更小，则Perl将使用本机八位字符集。否则，它将使用UTF-8。</target>
        </trans-unit>
        <trans-unit id="5c9c0562b20651bd210573c4a3cd205f4716cb6a" translate="yes" xml:space="preserve">
          <source>Internally, native integer arithmetic (as provided by your C compiler) is used. This means that Perl's own semantics for arithmetic operations may not be preserved. One common source of trouble is the modulus of negative numbers, which Perl does one way, but your hardware may do another.</source>
          <target state="translated">在内部,我们使用的是本机整数算术(由你的 C 编译器提供)。这意味着 Perl 自己的算术运算语义可能不会被保留。一个常见的麻烦来源是负数的模数,Perl用一种方式来处理,但你的硬件可能用另一种方式来处理。</target>
        </trans-unit>
        <trans-unit id="b7fbfab5bd07346d2a0d188d0642fad2cf67e914" translate="yes" xml:space="preserve">
          <source>Internally, we often set this to an object of class Pod::Simple::Progress. That class is probably undocumented, but you may wish to look at its source.</source>
          <target state="translated">在内部,我们经常将其设置为类Pod::Simple::Progress的对象。这个类可能没有被记录下来,但你可以看看它的源代码。</target>
        </trans-unit>
        <trans-unit id="4e1f47a6ca884b2242a2daaec979f4c9e4628f25" translate="yes" xml:space="preserve">
          <source>Internally, your computer represents floating-point numbers in binary. Digital (as in powers of two) computers cannot store all numbers exactly. Some real numbers lose precision in the process. This is a problem with how computers store numbers and affects all computer languages, not just Perl.</source>
          <target state="translated">在内部,你的计算机用二进制表示浮点数字。数字(如二的幂)计算机不可能精确地存储所有数字。一些实数在这个过程中会失去精度。这是计算机存储数字的一个问题,影响了所有的计算机语言,而不仅仅是Perl。</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="f3272f534c54bc991446f61c8eb13e09347dc7ac" translate="yes" xml:space="preserve">
          <source>Internals and C Language Interface</source>
          <target state="translated">内部和C语言接口</target>
        </trans-unit>
        <trans-unit id="56e7980ec1f234461f5c5cc8a7f141d36197c7ac" translate="yes" xml:space="preserve">
          <source>Internationalisation</source>
          <target state="translated">Internationalisation</target>
        </trans-unit>
        <trans-unit id="31cadca51461dbf1ea6607e7802c11fbe6ff93d3" translate="yes" xml:space="preserve">
          <source>Internationalization (I18N) and localization (L10N) are supported at least in principle even on EBCDIC platforms. The details are system-dependent and discussed under the &lt;a href=&quot;#OS-ISSUES&quot;&gt;OS ISSUES&lt;/a&gt; section below.</source>
          <target state="translated">即使在EBCDIC平台上，至少在原则上也支持国际化（I18N）和本地化（L10N）。详细信息取决于系统，并在下面的&amp;ldquo; &lt;a href=&quot;#OS-ISSUES&quot;&gt;操作系统问题&amp;rdquo;&lt;/a&gt;部分中进行了讨论。</target>
        </trans-unit>
        <trans-unit id="06442c59ec9f24811c5d9eb359e2f21b42d4c792" translate="yes" xml:space="preserve">
          <source>Internationalization and Locale</source>
          <target state="translated">国际化和本地化</target>
        </trans-unit>
        <trans-unit id="f7421cfdcae4df82cd94a16e9b01d52930cf4a8c" translate="yes" xml:space="preserve">
          <source>Internationalization, as defined in the C and POSIX standards, can be criticized as incomplete, ungainly, and having too large a granularity. (Locales apply to a whole process, when it would arguably be more useful to have them apply to a single thread, window group, or whatever.) They also have a tendency, like standards groups, to divide the world into nations, when we all know that the world can equally well be divided into bankers, bikers, gamers, and so on.</source>
          <target state="translated">在C和POSIX标准中定义的国际化,可以被批评为不完整、不美观和粒度太大。(Locales适用于整个进程,而让它们适用于单个线程、窗口组或其他什么东西可能会更有用。)它们也有一种倾向,就像标准组一样,把世界划分为国家,而我们都知道,世界同样可以划分为银行家、自行车手、游戏玩家等等。</target>
        </trans-unit>
        <trans-unit id="2e18cc52391003fa5303fbdac90ff76add1db9f3" translate="yes" xml:space="preserve">
          <source>Internet Line Terminators</source>
          <target state="translated">互联网线路终端机</target>
        </trans-unit>
        <trans-unit id="1ace89f6b9c54bf536f959a6a92a52a0f9188777" translate="yes" xml:space="preserve">
          <source>Internet Protocol, or Intellectual Property.</source>
          <target state="translated">互联网协议,或知识产权。</target>
        </trans-unit>
        <trans-unit id="6aafd8134caf0f288faa302a3a8189c60711fc0c" translate="yes" xml:space="preserve">
          <source>Internet TCP Clients and Servers</source>
          <target state="translated">互联网TCP客户端和服务器</target>
        </trans-unit>
        <trans-unit id="f4a9147272ff83f2cf2d940d5441a60e554132ae" translate="yes" xml:space="preserve">
          <source>Internet language tags, as defined in RFC 3066, are a formalism for denoting human languages. The two-letter ISO 639-1 language codes are well known (as &quot;en&quot; for English), as are their forms when qualified by a country code (&quot;en-US&quot;). Less well-known are the arbitrary-length non-ISO codes (like &quot;i-mingo&quot;), and the recently (in 2001) introduced three-letter ISO-639-2 codes.</source>
          <target state="translated">RFC 3066中定义的因特网语言标记是表示人类语言的一种形式。双字母的ISO 639-1语言代码是众所周知的(如英语的 &quot;en&quot;),当它们被国家代码限定时,其形式也是如此(&quot;en-US&quot;)。较不知名的是任意长度的非ISO代码(如 &quot;i-mingo&quot;),以及最近(2001年)推出的三字母ISO-639-2代码。</target>
        </trans-unit>
        <trans-unit id="645bb0cb3effc0c464d1fa2ee02c7473d9c16ab6" translate="yes" xml:space="preserve">
          <source>Interpolated scalars and arrays are converted internally to the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&quot;.&quot;&lt;/code&gt; catenation operations. Thus, &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; becomes:</source>
          <target state="translated">内插标量和数组在内部转换为 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 分类操作。因此， &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; 变为：</target>
        </trans-unit>
        <trans-unit id="1fc8312ce8a1d5c2a7ed5ed38a0c5c565ab477c8" translate="yes" xml:space="preserve">
          <source>Interpolating an array or slice interpolates the elements in order, separated by the value of &lt;code&gt;$&quot;&lt;/code&gt; , so is equivalent to interpolating &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; $&quot;, @array&lt;/code&gt; . &quot;Punctuation&quot; arrays such as &lt;code&gt;@*&lt;/code&gt; are usually interpolated only if the name is enclosed in braces &lt;code&gt;@{*}&lt;/code&gt;, but the arrays &lt;code&gt;@_&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; , and &lt;code&gt;@-&lt;/code&gt; are interpolated even without braces.</source>
          <target state="translated">插值数组或切片按顺序插值元素，以 &lt;code&gt;$&quot;&lt;/code&gt; 的值分隔，因此等效于插值 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; $&quot;, @array&lt;/code&gt; 。 &amp;ldquo;标点符号&amp;rdquo;阵列如 &lt;code&gt;@*&lt;/code&gt; 如果名称被包围在括号通常只内插 &lt;code&gt;@{*}&lt;/code&gt; ，但阵列 &lt;code&gt;@_&lt;/code&gt; ， &lt;code&gt;@+&lt;/code&gt; ，和 &lt;code&gt;@-&lt;/code&gt; 甚至没有括号内插。</target>
        </trans-unit>
        <trans-unit id="938c8acd8c9d50a2d8734d4eebce781a661d4c88" translate="yes" xml:space="preserve">
          <source>Interpolation in patterns has several quirks: &lt;code&gt;$|&lt;/code&gt; , &lt;code&gt;$(&lt;/code&gt; , &lt;code&gt;$)&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; and &lt;code&gt;@-&lt;/code&gt; are not interpolated, and constructs &lt;code&gt;$var[SOMETHING]&lt;/code&gt; are voted (by several different estimators) to be either an array element or &lt;code&gt;$var&lt;/code&gt; followed by an RE alternative. This is where the notation &lt;code&gt;${arr[$bar]}&lt;/code&gt; comes handy: &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; is interpreted as array element &lt;code&gt;-9&lt;/code&gt; , not as a regular expression from the variable &lt;code&gt;$arr&lt;/code&gt; followed by a digit, which would be the interpretation of &lt;code&gt;/$arr[0-9]/&lt;/code&gt; . Since voting among different estimators may occur, the result is not predictable.</source>
          <target state="translated">插值模式有几个怪癖： &lt;code&gt;$|&lt;/code&gt; ， &lt;code&gt;$(&lt;/code&gt; ， &lt;code&gt;$)&lt;/code&gt; ， &lt;code&gt;@+&lt;/code&gt; 和 &lt;code&gt;@-&lt;/code&gt; 不进行插值，并且构造 &lt;code&gt;$var[SOMETHING]&lt;/code&gt; 被投票（由几个不同的估计量）为数组元素或 &lt;code&gt;$var&lt;/code&gt; 后跟RE替代项。这是符号 &lt;code&gt;${arr[$bar]}&lt;/code&gt; 派上用场的地方： &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; 被解释为数组元素 &lt;code&gt;-9&lt;/code&gt; ，而不是变量 &lt;code&gt;$arr&lt;/code&gt; 的正则表达式，后跟数字，这就是对 &lt;code&gt;/$arr[0-9]/&lt;/code&gt; 。由于可能会发生不同估算器之间的投票，因此结果是不可预测的。</target>
        </trans-unit>
        <trans-unit id="73b1ed4106cc19f9516b8700eff6b51f8a50bc7e" translate="yes" xml:space="preserve">
          <source>Interpret input as a hexadecimal string. A &quot;0x&quot; or &quot;x&quot; prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">将输入内容解释为十六进制字符串。前缀 &quot;0x &quot;或 &quot;x &quot;是可选的。如果存在前缀,一个下划线字符可以放在前缀之后,或者放在任何两个数字之间。如果输入无效,将返回一个NaN。</target>
        </trans-unit>
        <trans-unit id="70a91bb371c7a5d73707f3bf850be5ff775864c2" translate="yes" xml:space="preserve">
          <source>Interpret results strictly.</source>
          <target state="translated">严格解释结果。</target>
        </trans-unit>
        <trans-unit id="7bc19d89b05f97e1ecec77b1cd80333965f8eac8" translate="yes" xml:space="preserve">
          <source>Interpret the input as a binary string. A &quot;0b&quot; or &quot;b&quot; prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">将输入内容解释为二进制字符串。前缀 &quot;0b &quot;或 &quot;b &quot;是可选的。一个下划线字符可以放在前缀之后,如果存在的话,或者放在任何两个数字之间。如果输入无效,将返回一个NaN。</target>
        </trans-unit>
        <trans-unit id="0fb708839bb76c97a78f59fb0d153db3bcac65ad" translate="yes" xml:space="preserve">
          <source>Interpret the input as an octal string and return the corresponding value. A &quot;0&quot; (zero) prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">将输入的内容解释为八进制字符串,并返回相应的值。前缀 &quot;0&quot;(零)是可选的。一个下划线字符可以放在前缀之后(如果存在的话),或者放在任何两个数字之间。如果输入无效,将返回一个NaN。</target>
        </trans-unit>
        <trans-unit id="b29af10220daeb6f80d20ec4774b2643643e00f8" translate="yes" xml:space="preserve">
          <source>Interpretation of the &lt;code&gt;gecos&lt;/code&gt; field varies between systems, but traditionally holds 4 comma-separated fields containing the user's full name, office location, work phone number, and home phone number. An &lt;code&gt;&amp;amp;&lt;/code&gt; in the gecos field should be replaced by the user's properly capitalized login &lt;code&gt;name&lt;/code&gt; . The &lt;code&gt;shell&lt;/code&gt; field, if blank, must be assumed to be</source>
          <target state="translated">&lt;code&gt;gecos&lt;/code&gt; 字段的解释在系统之间有所不同，但传统上会保留4个以逗号分隔的字段，其中包含用户的全名，办公室位置，工作电话号码和家庭电话号码。gecos字段中的 &lt;code&gt;&amp;amp;&lt;/code&gt; 应当替换为用户正确大写的登录 &lt;code&gt;name&lt;/code&gt; 。该 &lt;code&gt;shell&lt;/code&gt; 字段，如果空白，必须假定</target>
        </trans-unit>
        <trans-unit id="f5cfbb6233c7812b488cce8d6bd3af2af9ab5bc6" translate="yes" xml:space="preserve">
          <source>Interpretation of the buffer's octets can be abstracted out by using the slightly higher-level functions &lt;a href=&quot;#lex_peek_unichar&quot;&gt;lex_peek_unichar&lt;/a&gt; and &lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt;.</source>
          <target state="translated">可以通过使用稍微更高级别的函数&lt;a href=&quot;#lex_peek_unichar&quot;&gt;lex_peek_unichar&lt;/a&gt;和&lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt;来抽象出缓冲区八位位组的解释。</target>
        </trans-unit>
        <trans-unit id="92d3f8b03230be860eb13ba99ed5e322ec25a6b0" translate="yes" xml:space="preserve">
          <source>Interpreter</source>
          <target state="translated">Interpreter</target>
        </trans-unit>
        <trans-unit id="c4c7c558d92a61d6a4e1c001e4a147b288928483" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding value. (To convert strings that might start with either &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; , or &lt;code&gt;0b&lt;/code&gt;, see &lt;a href=&quot;#oct&quot;&gt;oct&lt;/a&gt;.) If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">将EXPR解释为十六进制字符串，并返回相应的值。（要转换可能与任一开头的字符串 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;0x&lt;/code&gt; ，或 &lt;code&gt;0b&lt;/code&gt; ，见&lt;a href=&quot;#oct&quot;&gt;年10月&lt;/a&gt;）。如果省略EXPR，使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80995a80c008a9c2a1eb866370afb34599cdd244" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding value. (To convert strings that might start with either &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; , or &lt;code&gt;0b&lt;/code&gt;, see &lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt;.) If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">将EXPR解释为十六进制字符串，并返回相应的值。（要转换可能与任一开头的字符串 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;0x&lt;/code&gt; ，或 &lt;code&gt;0b&lt;/code&gt; ，见&lt;a href=&quot;oct&quot;&gt;年10月&lt;/a&gt;）。如果省略EXPR，使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58710e925b06b5bcd617d0a02276a6d507de1826" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as an octal string and returns the corresponding value. (If EXPR happens to start off with &lt;code&gt;0x&lt;/code&gt; , interprets it as a hex string. If EXPR starts off with &lt;code&gt;0b&lt;/code&gt;, it is interpreted as a binary string. Leading whitespace is ignored in all three cases.) The following will handle decimal, binary, octal, and hex in standard Perl notation:</source>
          <target state="translated">将EXPR解释为八进制字符串，并返回相应的值。（如果EXPR恰好以 &lt;code&gt;0x&lt;/code&gt; 开头，则将其解释为十六进制字符串。如果EXPR是以 &lt;code&gt;0b&lt;/code&gt; 开头，则将其解释为二进制字符串。在所有三种情况下都将忽略前导空格。）以下将处理十进制，二进制，八进制，标准Perl表示法为十六进制：</target>
        </trans-unit>
        <trans-unit id="92d683f7db5d587ede8e14b4d88e6c417a5847d7" translate="yes" xml:space="preserve">
          <source>Interprocess Communication (IPC)</source>
          <target state="translated">进程间通信(IPC)</target>
        </trans-unit>
        <trans-unit id="1e11457cea032ab0c21c71c69e4211f081e8849e" translate="yes" xml:space="preserve">
          <source>Interprocess Communication.</source>
          <target state="translated">进程间通信。</target>
        </trans-unit>
        <trans-unit id="58447a233c711f903a2587b91bb291042f4b45da" translate="yes" xml:space="preserve">
          <source>Intersection is used generally for getting the common characters matched by two (or more) classes. It's important to remember not to use &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; for the first set; that would be intersecting with nothing, resulting in an empty set.</source>
          <target state="translated">交集通常用于获取由两个（或更多）类匹配的公共字符。重要的是要记住不要在第一组中使用 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 。那将没有任何东西相交，从而导致一个空集。</target>
        </trans-unit>
        <trans-unit id="c4724a76d8bc17dfefb1daee3b6d5be588f4c613" translate="yes" xml:space="preserve">
          <source>Introduce the</source>
          <target state="translated">介绍一下</target>
        </trans-unit>
        <trans-unit id="dde62d185b627cf5b7ce046a41566f84e22267ed" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.005</source>
          <target state="translated">在Perl 5.005中引入</target>
        </trans-unit>
        <trans-unit id="25641bc26420a80c8ddbcf38615ca35ce5d7cb63" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.10.0</source>
          <target state="translated">在Perl 5.10.0中引入</target>
        </trans-unit>
        <trans-unit id="b91aad730399f200ac6a5b6dba6fed9c61c025f5" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.12</source>
          <target state="translated">在Perl 5.12中引入</target>
        </trans-unit>
        <trans-unit id="be57168adcd5cd07b75f1c9b6124df0daf76c3bd" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.14.0</source>
          <target state="translated">在Perl 5.14.0中引入</target>
        </trans-unit>
        <trans-unit id="b294ac0a4f8c5992774c8112441dc302d5816a1f" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.20.0</source>
          <target state="translated">在Perl 5.20.0中引入</target>
        </trans-unit>
        <trans-unit id="0c3a6017cbcf96eeafb4387eedc602152339297c" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.22.0</source>
          <target state="translated">在Perl 5.22.0中引入</target>
        </trans-unit>
        <trans-unit id="7993785cfbc9e7981dcd229895be4a20fdb9620c" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.6.0</source>
          <target state="translated">在Perl 5.6.0中引入</target>
        </trans-unit>
        <trans-unit id="31cd408fa26c1acb52eade6304b9c5ef7d3abe35" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.6.1</source>
          <target state="translated">在Perl 5.6.1中引入</target>
        </trans-unit>
        <trans-unit id="51378bbd1f0bc4027eee05ffb1e7f6b0f83420b0" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.8.0</source>
          <target state="translated">在Perl 5.8.0中引入</target>
        </trans-unit>
        <trans-unit id="79667c9718432940922f2e42f6facd3cdd4d3deb" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.9.0</source>
          <target state="translated">在Perl 5.9.0中引入</target>
        </trans-unit>
        <trans-unit id="bb8c7b3973c6116a9525785ab93801f9d4d4fd02" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.9.2</source>
          <target state="translated">在Perl 5.9.2中引入</target>
        </trans-unit>
        <trans-unit id="7ef8951301d241cbc829612e64580020e610d91f" translate="yes" xml:space="preserve">
          <source>Introduced in: 5.11.2</source>
          <target state="translated">引入:5.11.2</target>
        </trans-unit>
        <trans-unit id="a01d17d00de94eaa77554eca767e361f42130168" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.10</source>
          <target state="translated">引入。Perl 5.10</target>
        </trans-unit>
        <trans-unit id="1e5c7e1205af583a405c6c00903c26fad40a5e6a" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.11.2</source>
          <target state="translated">引入。Perl 5.11.2</target>
        </trans-unit>
        <trans-unit id="d272e647109f1769e2b49a3e24be3094dd708435" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.18</source>
          <target state="translated">引入。Perl 5.18</target>
        </trans-unit>
        <trans-unit id="a5210098032cc4bc65f6c8263851cc2d7666b61d" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.22.0</source>
          <target state="translated">引入。Perl 5.22.0</target>
        </trans-unit>
        <trans-unit id="5a3a1683287083d64acee02ab986003bcf802274" translate="yes" xml:space="preserve">
          <source>Introduced just after perl5.7.0, this is a re-implementation of the above abstraction which allows perl more control over how IO is done as it decouples IO from the way the operating system and C library choose to do things. For USE_PERLIO PerlIO * has an extra layer of indirection - it is a pointer-to-a-pointer. This allows the PerlIO * to remain with a known value while swapping the implementation around underneath</source>
          <target state="translated">这是在 perl5.7.0 之后引入的,是对上述抽象的重新实现,它允许 perl 对 IO 的处理方式有更多的控制,因为它将 IO 与操作系统和 C 库选择的处理方式解耦。对于 USE_PERLIO,PerlIO*多了一层间接性--它是一个指针到指针。这使得 PerlIO*可以保持一个已知的值,同时在下面的实现中进行交换。</target>
        </trans-unit>
        <trans-unit id="df90fec901ab6b3e3c92b7090f061ccf2d6c4aa2" translate="yes" xml:space="preserve">
          <source>Introduces a catch block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Exception Handling in perlguts&lt;/a&gt;.</source>
          <target state="translated">引入了一个捕获块。请参阅&lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;perlguts中的异常处理&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0c2f1d96cf5d9698341444cc5bc1eb344088014" translate="yes" xml:space="preserve">
          <source>Introducing (non-read-only) globals</source>
          <target state="translated">介绍(非只读)globals</target>
        </trans-unit>
        <trans-unit id="154cc0bb0700575719a65b65f0bfb0fc9a438358" translate="yes" xml:space="preserve">
          <source>Introducing read-only (const) globals is okay, as long as you verify with e.g. &lt;code&gt;nm libperl.a|egrep -v ' [TURtr] '&lt;/code&gt; (if your &lt;code&gt;nm&lt;/code&gt; has BSD-style output) that the data you added really is read-only. (If it is, it shouldn't show up in the output of that command.)</source>
          <target state="translated">只要您使用 &lt;code&gt;nm libperl.a|egrep -v ' [TURtr] '&lt;/code&gt; （如果您的 &lt;code&gt;nm&lt;/code&gt; 具有BSD风格的输出）进行验证，就可以真正引入只读的（常量）全局变量，只要。（如果是，则不应在该命令的输出中显示它。）</target>
        </trans-unit>
        <trans-unit id="dcba11e20d56606a737ad2a86071e282fcf184cf" translate="yes" xml:space="preserve">
          <source>Introducing variables inside for()</source>
          <target state="translated">在for()中引入变量</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="cad0875833b290c88f0275f52c45f410d897ca9f" translate="yes" xml:space="preserve">
          <source>Introductory Texts</source>
          <target state="translated">介绍性文本</target>
        </trans-unit>
        <trans-unit id="a7111e9430dac55fd4a6c0b16ea2e92ba2187d8a" translate="yes" xml:space="preserve">
          <source>Invalidates method caching on any child classes of the given stash, so that they might notice the changes in this one.</source>
          <target state="translated">使给定储藏的任何子类的方法缓存无效,这样他们可能会注意到这个储藏的变化。</target>
        </trans-unit>
        <trans-unit id="6254374b19c61ff561460206a4f9194f4bcd1a52" translate="yes" xml:space="preserve">
          <source>Invalidates the method cache of any classes dependent on the given class. This is not normally necessary. The only known case where pure perl code can confuse the method cache is when you manually install a new constant subroutine by using a readonly scalar value, like the internals of &lt;a href=&quot;constant&quot;&gt;constant&lt;/a&gt; do. If you find another case, please report it so we can either fix it or document the exception here.</source>
          <target state="translated">使依赖于给定类的任何类的方法缓存无效。通常这不是必需的。纯perl代码可能会使方法缓存混乱的唯一已知情况是，当您使用只读标量值手动安装新的常量子例程时，就像&lt;a href=&quot;constant&quot;&gt;constant&lt;/a&gt;内部一样。如果您发现其他情况，请报告，以便我们进行修复或在此处记录例外情况。</target>
        </trans-unit>
        <trans-unit id="c0df4881ff3f493d5106f68dbab35c513534aed4" translate="yes" xml:space="preserve">
          <source>Inventory management of installed modules</source>
          <target state="translated">已安装模块的库存管理</target>
        </trans-unit>
        <trans-unit id="14c5c3735ce54ff56e113f2608fb558c2d638a18" translate="yes" xml:space="preserve">
          <source>Inversion lists are a compact way of specifying Unicode property-value definitions. The 0th item in the list is the lowest code point that has the property-value. The next item (item [1]) is the lowest code point beyond that one that does NOT have the property-value. And the next item beyond that ([2]) is the lowest code point beyond that one that does have the property-value, and so on. Put another way, each element in the list gives the beginning of a range that has the property-value (for even numbered elements), or doesn't have the property-value (for odd numbered elements). The name for this data structure stems from the fact that each element in the list toggles (or inverts) whether the corresponding range is or isn't on the list.</source>
          <target state="translated">反转列表是指定Unicode属性值定义的一种紧凑方式。列表中的第0项是拥有属性值的最低码点。下一个项目(项目[1])是该项目之外不具有属性值的最低码点。下一个项目([2])是有属性值的那个项目之外的最低码点,以此类推。换句话说,列表中的每个元素都给出了一个范围的开始,这个范围有属性值(对于偶数元素),或者没有属性值(对于奇数元素)。这个数据结构的名称源于列表中的每个元素都会切换(或反转)相应的范围是否在列表中。</target>
        </trans-unit>
        <trans-unit id="d8e6379916ac816d709ea169dcdb0ea2c85538b2" translate="yes" xml:space="preserve">
          <source>Invocation requires the command to be executed or a coderef and optionally a hashref of options:</source>
          <target state="translated">调用需要执行的命令或coderef和可选的选项hashref。</target>
        </trans-unit>
        <trans-unit id="9866e55ebd73eaa4dfd6d462e055f3a88a4fa2b2" translate="yes" xml:space="preserve">
          <source>Invoke a magic method (like FETCH).</source>
          <target state="translated">援用一种神奇的方法(如FETCH)。</target>
        </trans-unit>
        <trans-unit id="729e0ead914d111524b46b874fed43976337fb94" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_comment&lt;/code&gt; returns true.</source>
          <target state="translated">如果 &lt;code&gt;$result-&amp;gt;is_comment&lt;/code&gt; 返回true，则调用。</target>
        </trans-unit>
        <trans-unit id="b6d3760550f46e7b28bbf7a09042b6769acf3c7e" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_plan&lt;/code&gt; returns true.</source>
          <target state="translated">如果 &lt;code&gt;$result-&amp;gt;is_plan&lt;/code&gt; 返回true，则调用。</target>
        </trans-unit>
        <trans-unit id="4d5c6b94ee048c918e4535240e958632aecb1a6d" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; returns true.</source>
          <target state="translated">如果 &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; 返回true，则调用。</target>
        </trans-unit>
        <trans-unit id="136fe5e37a3fd848b78d877c253e754a822cac52" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_unknown&lt;/code&gt; returns true.</source>
          <target state="translated">如果 &lt;code&gt;$result-&amp;gt;is_unknown&lt;/code&gt; 返回true，则调用此方法。</target>
        </trans-unit>
        <trans-unit id="632983081cf348fad68b5fcc938bef7d785aa8ce" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_version&lt;/code&gt; returns true.</source>
          <target state="translated">如果 &lt;code&gt;$result-&amp;gt;is_version&lt;/code&gt; 返回true，则调用。</target>
        </trans-unit>
        <trans-unit id="dab118fbd97b5abfc5d3df38d7cc4bb27d7a5389" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_yaml&lt;/code&gt; returns true.</source>
          <target state="translated">如果 &lt;code&gt;$result-&amp;gt;is_yaml&lt;/code&gt; 返回true，则调用此方法。</target>
        </trans-unit>
        <trans-unit id="b4fc12fcbbbf739e9ecf3604f9dbc469d9a9587a" translate="yes" xml:space="preserve">
          <source>Invoked when there are no more lines to be parsed. Since there is no accompanying &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object the &lt;code&gt;TAP::Parser&lt;/code&gt; object is passed instead.</source>
          <target state="translated">当没有更多行需要解析时调用。由于没有随附的&lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;对象，因此将传递 &lt;code&gt;TAP::Parser&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="430786511bff9aaafff5936e905ad653f2aebe92" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_get&lt;/code&gt; on an SV if it has 'get' magic. For example, this will call &lt;code&gt;FETCH&lt;/code&gt; on a tied variable. This macro evaluates its argument more than once.</source>
          <target state="translated">如果SV具有&amp;ldquo;魔力&amp;rdquo;，则在SV 上调用 &lt;code&gt;mg_get&lt;/code&gt; 。例如，这将在绑定变量上调用 &lt;code&gt;FETCH&lt;/code&gt; 。该宏多次评估其自变量。</target>
        </trans-unit>
        <trans-unit id="63770cbaa11ab2ed8431af406f1283f32bff5b08" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_set&lt;/code&gt; on an SV if it has 'set' magic. This is necessary after modifying a scalar, in case it is a magical variable like &lt;code&gt;$|&lt;/code&gt; or a tied variable (it calls &lt;code&gt;STORE&lt;/code&gt; ). This macro evaluates its argument more than once.</source>
          <target state="translated">如果SV具有&amp;ldquo;设置&amp;rdquo;魔法，则在SV 上调用 &lt;code&gt;mg_set&lt;/code&gt; 。修改标量后，如果它是 &lt;code&gt;$|&lt;/code&gt; 类的神奇变量，这是必需的。或绑定变量（它调用 &lt;code&gt;STORE&lt;/code&gt; ）。该宏多次评估其自变量。</target>
        </trans-unit>
        <trans-unit id="6065fa2fda8beaeb12ea495b85a947dc1c32d666" translate="yes" xml:space="preserve">
          <source>Invokes VMS debugger. (VMS)</source>
          <target state="translated">调用VMS调试器。(VMS)</target>
        </trans-unit>
        <trans-unit id="4a48ee301f0abac2cf4e91d0e45258fd858ca888" translate="yes" xml:space="preserve">
          <source>Invokes debugging mode. Primarily for Encode hackers.</source>
          <target state="translated">调用调试模式。主要针对Encode黑客。</target>
        </trans-unit>
        <trans-unit id="24bad1e8c0ab13d7138af070e6f8fd5104a0af38" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce a library file from object files. In scalar context, the name of the library file is returned. In list context, the library file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The following parameters are optional:</source>
          <target state="translated">调用链接器以从目标文件生成库文件。在标量上下文中，将返回库文件的名称。在列表上下文中，将返回库文件和创建的任何临时文件。必需的 &lt;code&gt;objects&lt;/code&gt; 参数以字符串（对于一个目标文件）或列表引用（对于一个或多个文件）的形式包含要处理的目标文件的名称。以下参数是可选的：</target>
        </trans-unit>
        <trans-unit id="d6dc74aaf36821077c0007a98c7212fc4b3fa1fa" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce an executable file from object files. In scalar context, the name of the executable file is returned. In list context, the executable file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The optional parameters are the same as &lt;code&gt;&lt;a href=&quot;../functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; with exception for</source>
          <target state="translated">调用链接器以从目标文件生成可执行文件。在标量上下文中，将返回可执行文件的名称。在列表上下文中，将返回可执行文件和创建的任何临时文件。必需的 &lt;code&gt;objects&lt;/code&gt; 参数以字符串（对于一个目标文件）或列表引用（对于一个或多个文件）的形式包含要处理的目标文件的名称。可选参数与 &lt;code&gt;&lt;a href=&quot;../functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; 相同，但有例外</target>
        </trans-unit>
        <trans-unit id="b673c6a72896107ce4c1c1720830db2d7090b84b" translate="yes" xml:space="preserve">
          <source>Invoking</source>
          <target state="translated">Invoking</target>
        </trans-unit>
        <trans-unit id="ad7d6999362a94f744230122565df0fb30cec02f" translate="yes" xml:space="preserve">
          <source>Invoking Class Methods</source>
          <target state="translated">调用类方法</target>
        </trans-unit>
        <trans-unit id="36b849bf1b11efdfda1ba9f83f6937c3f5f3d9b5" translate="yes" xml:space="preserve">
          <source>Invoking Perl</source>
          <target state="translated">调用Perl</target>
        </trans-unit>
        <trans-unit id="d893e9caa1e5c938c432bca17fd828ff27fd449c" translate="yes" xml:space="preserve">
          <source>Invoking all versions of a method with a single call</source>
          <target state="translated">只需一次调用就可以调用一个方法的所有版本。</target>
        </trans-unit>
        <trans-unit id="24170ec2bba17eb099637b415016216327bba9b2" translate="yes" xml:space="preserve">
          <source>Invoking the test script via &quot;&lt;code&gt;make test&lt;/code&gt; &quot; did something very important. It invoked perl with all those &lt;code&gt;-I&lt;/code&gt; arguments so that it could find the various files that are part of the extension. It is</source>
          <target state="translated">通过&amp;ldquo; &lt;code&gt;make test&lt;/code&gt; &amp;rdquo; 调用测试脚本做了非常重要的事情。它使用所有这些 &lt;code&gt;-I&lt;/code&gt; 参数调用了perl，以便它可以找到扩展名中的各种文件。它是</target>
        </trans-unit>
        <trans-unit id="5a017d9fae08fe8b742594c766cac2cd8dcf3595" translate="yes" xml:space="preserve">
          <source>Irish for the whole McGillicuddy. In Perl culture, a portmanteau of &amp;ldquo;sharp&amp;rdquo; and &amp;ldquo;bang&amp;rdquo;, meaning the &lt;code&gt;#!&lt;/code&gt; sequence that tells the system where to find the interpreter.</source>
          <target state="translated">整个McGillicuddy爱尔兰人。在Perl文化中，&amp;ldquo;尖锐&amp;rdquo;和&amp;ldquo;爆炸&amp;rdquo;的组合，代表 &lt;code&gt;#!&lt;/code&gt; 告诉系统在哪里可以找到解释器的序列。</target>
        </trans-unit>
        <trans-unit id="eb88b49be9395cb953eb1205ce4b4ea6acad6f1e" translate="yes" xml:space="preserve">
          <source>Irix 5.3</source>
          <target state="translated">Irix 5.3</target>
        </trans-unit>
        <trans-unit id="280a8973708779722e3c6e60a42a133ed8d4613c" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples here are in the public domain. You are permitted and encouraged to use this code and any derivatives thereof in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit to the FAQ would be courteous but is not required.</source>
          <target state="translated">不管它的分布情况如何,这里的所有代码例子都是在公共领域。我们允许并鼓励您在您自己的程序中使用这段代码和任何衍生的代码,并在您认为合适的情况下用于娱乐或盈利。在代码中简单地注释一下,并将功劳归功于FAQ将是礼貌的,但不是必须的。</target>
        </trans-unit>
        <trans-unit id="e6e987fe64dde20e286f30fd90c6b90ffeedb494" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples in these files are hereby placed into the public domain. You are permitted and encouraged to use this code in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit would be courteous but is not required.</source>
          <target state="translated">不管它的分布情况如何,这些文件中的所有代码示例都在此被置于公共领域。我们允许并鼓励您在您自己的程序中使用这些代码,以获得您认为合适的乐趣或利润。在代码中作简单的注释以示感谢将是礼貌的,但不是必需的。</target>
        </trans-unit>
        <trans-unit id="16778fd5503d73f3e7cd989fda95007a4e44c18a" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples in this file are hereby placed into the public domain. You are permitted and encouraged to use this code in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit would be courteous but is not required.</source>
          <target state="translated">不管它的发行情况如何,本文件中的所有代码示例都在此被置于公共领域。我们允许并鼓励您在您自己的程序中使用这些代码,以获得您认为合适的乐趣或利润。在代码中写上简单的注释以示感谢是礼貌的,但不是必须的。</target>
        </trans-unit>
        <trans-unit id="3b1335a849872557c30733349f1e4699d629a12c" translate="yes" xml:space="preserve">
          <source>Is Perl difficult to learn?</source>
          <target state="translated">Perl难学吗?</target>
        </trans-unit>
        <trans-unit id="ac0736b6a42e76cbb8b7ea3d82d9347dd47ba779" translate="yes" xml:space="preserve">
          <source>Is better written:</source>
          <target state="translated">是比较好写的。</target>
        </trans-unit>
        <trans-unit id="32906667b7957f587634c3ad2cf7b982992ddda0" translate="yes" xml:space="preserve">
          <source>Is it safe to return a reference to local or lexical data?</source>
          <target state="translated">返回对本地或词法数据的引用是否安全?</target>
        </trans-unit>
        <trans-unit id="a15088679e31d0c4822e89f1a281a86a46e94dee" translate="yes" xml:space="preserve">
          <source>Is it the same? Well, maybe so--and maybe not. The subtle difference is that when you assign something in square brackets, you know for sure it's always a brand new reference with a new</source>
          <target state="translated">是一样的吗?嗯,也许是,也许不是。微妙的区别在于,当你把某物赋值在方括号中时,你可以确定它总是一个全新的引用,有一个新的</target>
        </trans-unit>
        <trans-unit id="c842dccd002c594c47398d7b81a3f350518d446b" translate="yes" xml:space="preserve">
          <source>Is not supported for process identification number of 0 or negative numbers. (VMS)</source>
          <target state="translated">不支持工艺识别号为0或负数。(VMS)</target>
        </trans-unit>
        <trans-unit id="892d60f6405f23f25c6b3ae4379071e72ec47d11" translate="yes" xml:space="preserve">
          <source>Is the feature generic enough?</source>
          <target state="translated">该功能是否足够通用?</target>
        </trans-unit>
        <trans-unit id="21550a0f41b5f7c0792d01f174b9eb78bb2eb4ca" translate="yes" xml:space="preserve">
          <source>Is the implementation generic enough to be portable?</source>
          <target state="translated">执行是否足够通用,可以移植?</target>
        </trans-unit>
        <trans-unit id="ef5914893715ffaab39210a601dc4f727d6ff4af" translate="yes" xml:space="preserve">
          <source>Is the implementation robust?</source>
          <target state="translated">执行是否有力?</target>
        </trans-unit>
        <trans-unit id="78090775b623989661f8da8dfe386a79dbfa661d" translate="yes" xml:space="preserve">
          <source>Is the implementation tested?</source>
          <target state="translated">执行情况是否经过测试?</target>
        </trans-unit>
        <trans-unit id="a9f6ff8d209700b0f72a5230b6fb85c97fcff80b" translate="yes" xml:space="preserve">
          <source>Is there a pretty-printer (formatter) for Perl?</source>
          <target state="translated">有没有针对Perl的pretty-printer(formatter)?</target>
        </trans-unit>
        <trans-unit id="4de697ef2e229f75e5104bfc892c512110a431a3" translate="yes" xml:space="preserve">
          <source>Is there a way to automatically decode or encode?</source>
          <target state="translated">有没有一种方法可以自动解码或编码?</target>
        </trans-unit>
        <trans-unit id="39ca1c79bbe21712b9201250f2255ac5dedb029e" translate="yes" xml:space="preserve">
          <source>Is there a way to hide perl's command line from programs such as &quot;ps&quot;?</source>
          <target state="translated">有没有办法隐藏perl的命令行,不让 &quot;ps &quot;等程序看到?</target>
        </trans-unit>
        <trans-unit id="3501dfd2cd1d66a0e5956cd00d200fac2bcfba23" translate="yes" xml:space="preserve">
          <source>Is there an IDE or Windows Perl Editor?</source>
          <target state="translated">是否有IDE或Windows Perl编辑器?</target>
        </trans-unit>
        <trans-unit id="d38604e1470c164361620c8174e47b26e8405b57" translate="yes" xml:space="preserve">
          <source>Is there another way to do it?</source>
          <target state="translated">还有其他方法吗?</target>
        </trans-unit>
        <trans-unit id="14fcbaecb1fe49a8bbbcabb376a8c49b63c6d0ee" translate="yes" xml:space="preserve">
          <source>Is there anything else I need to know?</source>
          <target state="translated">还有什么我需要知道的吗?</target>
        </trans-unit>
        <trans-unit id="3079a95c08daf3fbe9a6f4a2b3424c5019e5caa9" translate="yes" xml:space="preserve">
          <source>Is there enough documentation?</source>
          <target state="translated">是否有足够的文件?</target>
        </trans-unit>
        <trans-unit id="a850886339587a195217b1d8cceb0d4cff588e20" translate="yes" xml:space="preserve">
          <source>Is this something that only the submitter wants added to the language, or is it broadly useful? Sometimes, instead of adding a feature with a tight focus, the porters might decide to wait until someone implements the more generalized feature.</source>
          <target state="translated">这是只有提交者希望添加到语言中的东西,还是广泛有用的东西?有时,移植者可能会决定等到有人实现了更广泛的功能之后,再添加一个重点突出的功能。</target>
        </trans-unit>
        <trans-unit id="c6c3f322bd4a89ec99cd36027dacc62c0c50b0bf" translate="yes" xml:space="preserve">
          <source>Is this the document you were after?</source>
          <target state="translated">这是你要找的文件吗?</target>
        </trans-unit>
        <trans-unit id="71a13751965545486650d22819d11cd32442498c" translate="yes" xml:space="preserve">
          <source>Issue a command as follows;</source>
          <target state="translated">发出命令如下:</target>
        </trans-unit>
        <trans-unit id="e65cf3242e05b4d2c344ded5e0824a537ad64ec2" translate="yes" xml:space="preserve">
          <source>Issues a &lt;code&gt;ualarm&lt;/code&gt; call; the &lt;code&gt;$interval_useconds&lt;/code&gt; is optional and will be zero if unspecified, resulting in &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;-like behaviour.</source>
          <target state="translated">发出 &lt;code&gt;ualarm&lt;/code&gt; 呼叫；在 &lt;code&gt;$interval_useconds&lt;/code&gt; 是可选的，将是零，如果未指定，导致 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 般的行为。</target>
        </trans-unit>
        <trans-unit id="8f58a9877a43ede1a54c6d1cffca7950a04cb0e9" translate="yes" xml:space="preserve">
          <source>Issues the warning:</source>
          <target state="translated">发出警告。</target>
        </trans-unit>
        <trans-unit id="d7acc4a63bfa4b603392fb8adfd2d4ca89c11f46" translate="yes" xml:space="preserve">
          <source>It</source>
          <target state="translated">It</target>
        </trans-unit>
        <trans-unit id="38eb0bc8056860c92fb5c583bff73f1456dae838" translate="yes" xml:space="preserve">
          <source>It allows you to fetch any file pointed to by a &lt;code&gt;ftp&lt;/code&gt; , &lt;code&gt;http&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;rsync&lt;/code&gt; uri by a number of different means.</source>
          <target state="translated">它允许您通过多种不同方式来获取 &lt;code&gt;ftp&lt;/code&gt; ， &lt;code&gt;http&lt;/code&gt; ， &lt;code&gt;file&lt;/code&gt; ， &lt;code&gt;git&lt;/code&gt; 或 &lt;code&gt;rsync&lt;/code&gt; uri 指向的任何文件。</target>
        </trans-unit>
        <trans-unit id="0b28d021dc9b9966369f90f11dc74db9e607087c" translate="yes" xml:space="preserve">
          <source>It allows you to validate input via a template. The only requirement is that the arguments must be named.</source>
          <target state="translated">它允许你通过一个模板来验证输入。唯一的要求是参数必须命名。</target>
        </trans-unit>
        <trans-unit id="5e1f97bb7137990bbbfbdc73b45154ab6a87edc2" translate="yes" xml:space="preserve">
          <source>It also flags things that need to behave specially in an lvalue context, such as &lt;code&gt;$$x = 5&lt;/code&gt; which might have to vivify a reference in &lt;code&gt;$x&lt;/code&gt; .</source>
          <target state="translated">它还标记需要在左值上下文中特殊行为的事物，例如 &lt;code&gt;$$x = 5&lt;/code&gt; ，这可能必须使 &lt;code&gt;$x&lt;/code&gt; 的引用生效。</target>
        </trans-unit>
        <trans-unit id="908ce366021e2b55b694a1cc88f5df405de36e15" translate="yes" xml:space="preserve">
          <source>It also has embedded documentation, so you can use</source>
          <target state="translated">它还嵌入了文档,所以你可以使用</target>
        </trans-unit>
        <trans-unit id="2ac24af0ec1c7cfa5374898a3526976fbf4e475c" translate="yes" xml:space="preserve">
          <source>It also made it impossible to pass a perl filehandle that wasn't associated with a real filesystem file, like, say, an &lt;code&gt;IO::String&lt;/code&gt; .</source>
          <target state="translated">这也使得无法传递与真实文件系统文件无关的perl文件句柄，例如 &lt;code&gt;IO::String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50072e7f3665a297dafc9a98026d2ece625b9337" translate="yes" xml:space="preserve">
          <source>It also provides a convenient alias via the MM class (I didn't want MakeMaker modules outside of ExtUtils/).</source>
          <target state="translated">它还通过MM类提供了一个方便的别名(我不希望MakeMaker模块在ExtUtils/之外)。</target>
        </trans-unit>
        <trans-unit id="915bbb1cff409394c98921945b825ccfd726cf97" translate="yes" xml:space="preserve">
          <source>It also provides a convenient alias via the MY class.</source>
          <target state="translated">它还通过MY类提供了一个方便的别名。</target>
        </trans-unit>
        <trans-unit id="f7728ec4984f8aa9520af281a21430a4fa58511c" translate="yes" xml:space="preserve">
          <source>It also sets the effective names (&lt;code&gt;HvENAME&lt;/code&gt; ) on all the stashes as appropriate.</source>
          <target state="translated">它还会在所有存储中适当地设置有效名称（ &lt;code&gt;HvENAME&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0cefa68e3cb791475c8c4a04f377e9985e23ade2" translate="yes" xml:space="preserve">
          <source>It also turns out that EBCDIC has nearly precise equivalents for the ASCII/Latin1 C0 controls and the DELETE control. (The C0 controls are those whose ASCII code points are 0..0x1F; things like TAB, ACK, BEL, etc.) A mapping is set up between these ASCII/EBCDIC controls. There isn't such a precise mapping between the C1 controls on ASCII platforms and the remaining EBCDIC controls. What has been done is to map these controls, mostly arbitrarily, to some otherwise unmatched character in the other character set. Most of these are very very rarely used nowadays in EBCDIC anyway, and their names have been dropped, without much complaint. For example the EO (Eight Ones) EBCDIC control (consisting of eight one bits = 0xFF) is mapped to the C1 APC control (0x9F), and you can't use the name &quot;EO&quot;.</source>
          <target state="translated">事实证明,EBCDIC对于ASCII/Latin1的C0控件和DELETE控件有几乎精确的等价物,(C0控件是那些ASCII码点为0...0x1F的控件,如TAB、ACK、BEL等)。(C0控件是那些ASCII码点为0...0x1F的控件,比如TAB、ACK、BEL等)这些ASCII/EBCDIC控件之间建立了一个映射。在ASCII平台上的C1控件和其余EBCDIC控件之间并没有如此精确的映射。所做的是将这些控件,大部分是任意地映射到其他字符集中一些其他不匹配的字符上。反正这些控件现在在EBCDIC中已经很少使用了,它们的名字也被删掉了,没有多少人抱怨。比如EO(八个一)EBCDIC控件(由八个一位=0xFF组成)被映射到C1 APC控件(0x9F)上,就不能用 &quot;EO &quot;这个名字了。</target>
        </trans-unit>
        <trans-unit id="3c6076aff0ee21a62fd6a390261efc5e5f0afb16" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;croak&lt;/code&gt; on failure.</source>
          <target state="translated">它在失败时发出 &lt;code&gt;croak&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04dc7e22ec9e3426f178763cb4c63c8305c033ad" translate="yes" xml:space="preserve">
          <source>It calls several other routines, such as &lt;code&gt;fbm_instr()&lt;/code&gt; which does Fast Boyer Moore matching and &lt;code&gt;find_byclass()&lt;/code&gt; which is responsible for finding the start using the first mandatory regop in the program.</source>
          <target state="translated">它调用其他几个例程，如 &lt;code&gt;fbm_instr()&lt;/code&gt; 这确实快博耶&amp;middot;摩尔匹配和 &lt;code&gt;find_byclass()&lt;/code&gt; 负责使用查找程序中的第一个强制性regop开始。</target>
        </trans-unit>
        <trans-unit id="497f49c37ce971a4a73fa1723da212a9045a166f" translate="yes" xml:space="preserve">
          <source>It can also be extended to be an application from &lt;b&gt;C&lt;/b&gt; to &lt;b&gt;C&lt;/b&gt;, whilst its restriction to &lt;b&gt;R&lt;/b&gt; behaves as defined above by using the following definition:</source>
          <target state="translated">也可以将其扩展为从&lt;b&gt;C&lt;/b&gt;到&lt;b&gt;C&lt;/b&gt;的应用程序，同时其对&lt;b&gt;R的&lt;/b&gt;限制的行为如上所定义，使用以下定义：</target>
        </trans-unit>
        <trans-unit id="037c189042a08e857fa9c25c861179516385e907" translate="yes" xml:space="preserve">
          <source>It can also be that long doubles and doubles are the same thing:</source>
          <target state="translated">也可以是长双打和双打是一回事。</target>
        </trans-unit>
        <trans-unit id="5a15f67a53851e31c8be84ee1922d871c9c74ea2" translate="yes" xml:space="preserve">
          <source>It can also store the resource directly in a file:</source>
          <target state="translated">它也可以直接将资源存储在文件中。</target>
        </trans-unit>
        <trans-unit id="2eb713583608cebc3ea2998759255bff9599a6ef" translate="yes" xml:space="preserve">
          <source>It can be called on an object or a class, of course.</source>
          <target state="translated">当然,它可以在一个对象或一个类上调用。</target>
        </trans-unit>
        <trans-unit id="e5c905f1665a696bdc789794d07c2a84423a378d" translate="yes" xml:space="preserve">
          <source>It can be used in the regular procedural way by calling &lt;code&gt;store&lt;/code&gt; with a reference to the object to be stored, along with the file name where the image should be written.</source>
          <target state="translated">通过调用 &lt;code&gt;store&lt;/code&gt; 并引用要存储的对象以及应在其中写入图像的文件名，可以按常规过程使用它。</target>
        </trans-unit>
        <trans-unit id="1b6d3eb9169140a9a6274f80ff5e86670958b748" translate="yes" xml:space="preserve">
          <source>It can easily be defined like this:</source>
          <target state="translated">它可以很容易地被这样定义。</target>
        </trans-unit>
        <trans-unit id="86ba6d37f32935701376ea8939425dea235ee2d1" translate="yes" xml:space="preserve">
          <source>It can load perl dynamic extensions, and it can fork().</source>
          <target state="translated">它可以加载perl动态扩展,也可以fork()。</target>
        </trans-unit>
        <trans-unit id="64f9135ce7da4c20ac152391823b647cbbeb33a6" translate="yes" xml:space="preserve">
          <source>It can take one of the following forms:</source>
          <target state="translated">它可以采取以下形式之一:</target>
        </trans-unit>
        <trans-unit id="2f904ea9d1b7cc3495a54fb96cf0850f9e5fd878" translate="yes" xml:space="preserve">
          <source>It can, however, be used as a superclass for other classes. To facilitate this, the generated constructor method uses a two-argument blessing. Furthermore, if the class is hash-based, the key of each element is prefixed with the class name (see</source>
          <target state="translated">但是,它可以作为其他类的超类使用。为了方便这一点,生成的构造函数方法使用了两个参数的祝福。此外,如果这个类是基于哈希的,那么每个元素的键都会在类名前加上前缀(见</target>
        </trans-unit>
        <trans-unit id="09d8ef54917c31dc7c7e7dced0a11cfba194a124" translate="yes" xml:space="preserve">
          <source>It combines the features of the</source>
          <target state="translated">它结合了以下特点</target>
        </trans-unit>
        <trans-unit id="6de2e6681db9e2aba6bd7eace100b8a569aebcfe" translate="yes" xml:space="preserve">
          <source>It constructs and returns a $treewalker coderef, which when invoked, traverses, or walks, and renders the optrees of the given arguments to STDOUT. You can reuse this, and can change the rendering style used each time; thereafter the coderef renders in the new style.</source>
          <target state="translated">它构造并返回一个$treewalker coderef,当调用时,它将遍历或行走,并将给定参数的optrees渲染到STDOUT。你可以重复使用这个函数,并且可以改变每次使用的渲染样式;此后coderef将以新的样式进行渲染。</target>
        </trans-unit>
        <trans-unit id="4b00062db32c6f6da9356b09e0e38ccf6b4650d6" translate="yes" xml:space="preserve">
          <source>It creates a database of the profile information that you can turn into reports. The &lt;code&gt;nytprofhtml&lt;/code&gt; command turns the data into an HTML report similar to the &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::Cover&quot;&gt;Devel::Cover&lt;/a&gt; report:</source>
          <target state="translated">它创建一个配置文件信息数据库，您可以将其转换为报告。该 &lt;code&gt;nytprofhtml&lt;/code&gt; 命令将数据放入类似HTML报告&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::Cover&quot;&gt;杰韦利::封面&lt;/a&gt;报道：</target>
        </trans-unit>
        <trans-unit id="ea6e392f63285a19a0d452d50c54df585744488e" translate="yes" xml:space="preserve">
          <source>It currently does</source>
          <target state="translated">目前是</target>
        </trans-unit>
        <trans-unit id="7dad9241afc4fe54f1d9bdea5f00177fb19d962a" translate="yes" xml:space="preserve">
          <source>It depends just what you mean by &quot;escape&quot;. URL escapes are dealt with in &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;. Shell escapes with the backslash (&lt;code&gt;\&lt;/code&gt; ) character are removed with</source>
          <target state="translated">这取决于您所说的&amp;ldquo;转义&amp;rdquo;。URL转义在&lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;中处理。带有反斜杠（ &lt;code&gt;\&lt;/code&gt; ）字符的外壳转义符用</target>
        </trans-unit>
        <trans-unit id="c581007e3ef08adcb3306414f7f2463e871ac22e" translate="yes" xml:space="preserve">
          <source>It does have the drawback of putting the wrong thing in $-[0] and $+[0], but this usually can be worked around.</source>
          <target state="translated">它的缺点是把错误的东西放在$-[0]和$+[0]中,但这通常可以解决。</target>
        </trans-unit>
        <trans-unit id="79d1a39f53aab3a73596d5fd9d9372e7a56d671b" translate="yes" xml:space="preserve">
          <source>It does implement the full UTS#18 grouping, intersection, union, and removal (subtraction) syntax.</source>
          <target state="translated">它确实实现了完整的UTS#18分组、交集、联合和删除(减法)语法。</target>
        </trans-unit>
        <trans-unit id="3283ccec35b62f9d69fc01d0b0127572cdbbfb86" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">它确实像 &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt; 。请注意， &lt;code&gt;$unprocessed&lt;/code&gt; 将被修改为副作用。</target>
        </trans-unit>
        <trans-unit id="781b506fec7893fd5e327ee69d14b0d379ec072d" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">它确实像 &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt; 。请注意， &lt;code&gt;$unprocessed&lt;/code&gt; 将被修改为副作用。</target>
        </trans-unit>
        <trans-unit id="98073979e598afdba9b1edfe5653068ff476e437" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">它确实像 &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt; 。请注意， &lt;code&gt;$unprocessed&lt;/code&gt; 将被修改为副作用。</target>
        </trans-unit>
        <trans-unit id="47a16bde88f189f6ad288e03cf560598f2698ec6" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">它确实像 &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt; 。请注意， &lt;code&gt;$unprocessed&lt;/code&gt; 将被修改为副作用。</target>
        </trans-unit>
        <trans-unit id="23674d2d232acdb766b500c08327a83816f04c97" translate="yes" xml:space="preserve">
          <source>It does not protect &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; , so that variables can still be substituted.</source>
          <target state="translated">它不保护 &lt;code&gt;$&lt;/code&gt; 或 &lt;code&gt;@&lt;/code&gt; ，因此仍可以替换变量。</target>
        </trans-unit>
        <trans-unit id="b4b096762458cc1c67705fc722b1b5c19a799e9a" translate="yes" xml:space="preserve">
          <source>It doesn't handle all C constructs, but it does attempt to isolate definitions inside evals so that you can get at the definitions that it can translate.</source>
          <target state="translated">它并不能处理所有的C结构,但它确实试图在evals中隔离定义,这样你就可以得到它能翻译的定义。</target>
        </trans-unit>
        <trans-unit id="661f04839377963b6531cde75241eb25f024872a" translate="yes" xml:space="preserve">
          <source>It doesn't matter whether those elements are already there or not: it'll gladly create them for you, setting intervening elements to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as need be.</source>
          <target state="translated">这些元素是否已经存在都没有关系：它将很高兴为您创建它们，并根据需要将中间元素设置为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3d56e0602580738fb050f4b637c11809b2b2552" translate="yes" xml:space="preserve">
          <source>It ensures that all items returned from the subroutine will be accessible when control returns from the</source>
          <target state="translated">它确保了当控制权从</target>
        </trans-unit>
        <trans-unit id="257a0d1f1aa9bffe5b6fec0d0193d78bda64cf97" translate="yes" xml:space="preserve">
          <source>It ensures that nothing is actually returned from the subroutine.</source>
          <target state="translated">它确保了没有任何东西从子程序中实际返回。</target>
        </trans-unit>
        <trans-unit id="9073e4e615d570b658e9c1dc5b31fb9fbc2e51c4" translate="yes" xml:space="preserve">
          <source>It ensures that only a scalar is actually returned from the subroutine. The subroutine can, of course, ignore the</source>
          <target state="translated">它确保子程序实际只返回一个标量。当然,子程序可以忽略</target>
        </trans-unit>
        <trans-unit id="6ce1e8c1dec22e7fcef7a08df4a73a6d708c188c" translate="yes" xml:space="preserve">
          <source>It exports the following variables:</source>
          <target state="translated">它输出的变量如下:</target>
        </trans-unit>
        <trans-unit id="c5eede2c3ff2d6a126d9a37fe7b6a2f7c7fef7c9" translate="yes" xml:space="preserve">
          <source>It goes without saying that bundling can be quite confusing.</source>
          <target state="translated">毋庸置疑,捆绑是相当混乱的。</target>
        </trans-unit>
        <trans-unit id="15f1fa29899dc9be4d2a29da0c1ebb962d996294" translate="yes" xml:space="preserve">
          <source>It implements just a very simple class to manage an array. Apart from the constructor, &lt;code&gt;new&lt;/code&gt; , it declares methods, one static and one virtual. The static method, &lt;code&gt;PrintID&lt;/code&gt; , prints out simply the class name and a version number. The virtual method, &lt;code&gt;Display&lt;/code&gt; , prints out a single element of the array. Here is an all-Perl example of using it.</source>
          <target state="translated">它仅实现了一个非常简单的类来管理数组。除了构造函数 &lt;code&gt;new&lt;/code&gt; 之外，它还声明方法，一种是静态的，另一种是虚拟的。静态方法 &lt;code&gt;PrintID&lt;/code&gt; 仅打印出类名和版本号。虚拟方法 &lt;code&gt;Display&lt;/code&gt; 可以打印出数组的单个元素。这是使用它的全Perl示例。</target>
        </trans-unit>
        <trans-unit id="4643eacc5a23fd6cfe7dbaa4ae9405cefd594ff8" translate="yes" xml:space="preserve">
          <source>It includes the TAP::Parser Cookbook:</source>
          <target state="translated">它包括TAP::Parser Cookbook。</target>
        </trans-unit>
        <trans-unit id="0b24215ad07cf4400cc22f004d70379859a91675" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a list context (if it executes</source>
          <target state="translated">它向被调用的子程序表明,它是在列表上下文中执行的(如果它执行了</target>
        </trans-unit>
        <trans-unit id="fd952552f08ee5c64a4b5cd1472fcbc55f52ff32" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a scalar context (if it executes</source>
          <target state="translated">它向被调用的子程序表明它是在标量上下文中执行的(如果它执行了</target>
        </trans-unit>
        <trans-unit id="d334572d38ec1bf7625437e6802d9ceede41a62a" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a void context (if it executes</source>
          <target state="translated">它向被调用的子程序表明,它是在void上下文中执行的(如果它执行了</target>
        </trans-unit>
        <trans-unit id="3dd5d5b49f19e1af8608ede7c4aa585a51f279cb" translate="yes" xml:space="preserve">
          <source>It is</source>
          <target state="translated">它是</target>
        </trans-unit>
        <trans-unit id="4593c265ea2a96fff8349127e24d6f8f64bc8930" translate="yes" xml:space="preserve">
          <source>It is a VIO application.</source>
          <target state="translated">它是一个VIO应用。</target>
        </trans-unit>
        <trans-unit id="15edb9eea808da9feee1a21d84ef34931e249422" translate="yes" xml:space="preserve">
          <source>It is a common feature of applications (whether run directly, or via the Web) for them to be &quot;localized&quot; -- i.e., for them to a present an English interface to an English-speaker, a German interface to a German-speaker, and so on for all languages it's programmed with. Locale::Maketext is a framework for software localization; it provides you with the tools for organizing and accessing the bits of text and text-processing code that you need for producing localized applications.</source>
          <target state="translated">应用程序(无论是直接运行,还是通过网络)的一个共同特点是 &quot;本地化&quot;--也就是说,它们向英语使用者提供一个英语界面,向德语使用者提供一个德语界面,以此类推,对所有语言进行编程。Locale::Maketext是一个软件本地化的框架;它为你提供了组织和访问文本位和文本处理代码的工具,你需要这些代码来制作本地化的应用程序。</target>
        </trans-unit>
        <trans-unit id="dd0c9650fee6ca5253a38ac00e6dc732d4f0e459" translate="yes" xml:space="preserve">
          <source>It is a common problem to want to detect what language(s) the user would prefer output in.</source>
          <target state="translated">想要检测用户希望用什么语言输出是一个常见的问题。</target>
        </trans-unit>
        <trans-unit id="0c07216f6ed146b3d5f5f41f5151571003ed974c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1950 data stream.</source>
          <target state="translated">当 &lt;code&gt;$output&lt;/code&gt; 不是RFC 1950数据流时，尝试使用此选项是一个致命错误。</target>
        </trans-unit>
        <trans-unit id="f26fad9b2ea8dad78ce0ae0159c499c446261e46" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1951 data stream.</source>
          <target state="translated">当 &lt;code&gt;$output&lt;/code&gt; 不是RFC 1951数据流时，尝试使用此选项是一个致命错误。</target>
        </trans-unit>
        <trans-unit id="f52e23ce1b9c7d458b13fea7c76a357d80aa0ef3" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1952 data stream.</source>
          <target state="translated">当 &lt;code&gt;$output&lt;/code&gt; 不是RFC 1952数据流时，尝试使用此选项是一个致命错误。</target>
        </trans-unit>
        <trans-unit id="951fc5c4a5b5cf258c0f54c435f4794f721e0f6c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to call this function except in list context.</source>
          <target state="translated">除了在列表上下文中调用这个函数是一个致命的错误。</target>
        </trans-unit>
        <trans-unit id="84e04c4e01865ff456f52f410d5f957caeadfc3c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to register a non-reference $obj. Any non-hashrefs among the following arguments are silently ignored.</source>
          <target state="translated">注册一个非引用的$obj是一个致命的错误。以下参数中的任何非散列值都将被忽略。</target>
        </trans-unit>
        <trans-unit id="62c55db6ed1bb1f62b509a530f9b2d3c904a4f20" translate="yes" xml:space="preserve">
          <source>It is a hash of hashes that is keyed on perl version. Each keyed hash will have the following keys:</source>
          <target state="translated">它是一个在perl版本上进行键控的哈希。每个键的哈希都有以下键。</target>
        </trans-unit>
        <trans-unit id="25ddadae24c0653c00410eac3e43d9a6483af1b0" translate="yes" xml:space="preserve">
          <source>It is a little bit easier to do so while</source>
          <target state="translated">这样做的时候会比较容易一些。</target>
        </trans-unit>
        <trans-unit id="41ddae9f4920a415092a3be5fefb0262a7109fa2" translate="yes" xml:space="preserve">
          <source>It is a simple matter to expand out an inversion list to a full list of all code points that have the property-value:</source>
          <target state="translated">很简单,将一个反转列表扩展出一个具有属性值的所有代码点的完整列表。</target>
        </trans-unit>
        <trans-unit id="fa408a04e809363f2b269a35a2338df430b18e1f" translate="yes" xml:space="preserve">
          <source>It is a syntax error to use &lt;code&gt;\N{NAME}&lt;/code&gt; where &lt;code&gt;NAME&lt;/code&gt; is unknown.</source>
          <target state="translated">它是一个语法错误，以使用 &lt;code&gt;\N{NAME}&lt;/code&gt; 其中 &lt;code&gt;NAME&lt;/code&gt; 是未知的。</target>
        </trans-unit>
        <trans-unit id="3189cdee5a11207a5d4b78afa8dc9c2b8ecc076f" translate="yes" xml:space="preserve">
          <source>It is able to load multiple modules at once or none at all if one of them was not able to load. It also takes care of any error checking and so forth.</source>
          <target state="translated">它能够同时加载多个模块,如果其中一个模块无法加载,则完全不加载。它还负责任何错误检查等。</target>
        </trans-unit>
        <trans-unit id="5224d6c644e7d334b02295922c6a21bf88351e6e" translate="yes" xml:space="preserve">
          <source>It is advised that formatnames match the regexp &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/a&gt;&lt;/code&gt;. Everything following whitespace after the formatname is a parameter that may be used by the formatter when dealing with this region. This parameter must not be repeated in the &quot;=end&quot; paragraph. Implementors should anticipate future expansion in the semantics and syntax of the first parameter to &quot;=begin&quot;/&quot;=end&quot;/&quot;=for&quot;.</source>
          <target state="translated">建议格式名称与regexp &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/a&gt;&lt;/code&gt; 相匹配。格式名后面的空格后面的所有内容都是格式化程序在处理此区域时可以使用的参数。在&amp;ldquo; = end&amp;rdquo;段落中不得重复此参数。实现者应预料将来第一个参数的语义和语法将扩展到&amp;ldquo; = begin&amp;rdquo; /&amp;ldquo; = end&amp;rdquo; /&amp;ldquo; = for&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5bdc4a6dded231914c04e13e61b945f48f5268b4" translate="yes" xml:space="preserve">
          <source>It is also highly desirable that encoding classes inherit from &lt;code&gt;Encode::Encoding&lt;/code&gt; as a base class. This allows that class to define additional behaviour for all encoding objects.</source>
          <target state="translated">还非常需要编码类从 &lt;code&gt;Encode::Encoding&lt;/code&gt; 作为基类继承。这允许该类为所有编码对象定义其他行为。</target>
        </trans-unit>
        <trans-unit id="04e94392102301dd0cfd3e0e0b7cc900aa1df8a8" translate="yes" xml:space="preserve">
          <source>It is also hoped that the interface will cover the needs of OS/2, NT etc and also allow pseudo-dynamic linking (using &lt;code&gt;ld -A&lt;/code&gt; at runtime).</source>
          <target state="translated">还希望该接口将满足OS / 2，NT等的需求，并且还允许伪动态链接（在运行时使用 &lt;code&gt;ld -A&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c5a799ae9f844383ae213d6362def23a82f89603" translate="yes" xml:space="preserve">
          <source>It is also important to realize that these are default boundary definitions, and that implementations may wish to tailor the results for particular purposes and locales.</source>
          <target state="translated">同样重要的是要认识到,这些是默认的边界定义,实现者可能希望为特定的目的和地区定制结果。</target>
        </trans-unit>
        <trans-unit id="f04f0bafdb5580f449ee2f59e8c42ace66bb7312" translate="yes" xml:space="preserve">
          <source>It is also possible for the reverse to happen: &lt;code&gt;prop_aliases('isc')&lt;/code&gt; returns the list &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt; ; whereas &lt;code&gt;prop_aliases('c')&lt;/code&gt; returns &lt;code&gt;(C, Other)&lt;/code&gt; (the latter being a Perl extension meaning &lt;code&gt;General_Category=Other&lt;/code&gt; . &lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;Properties accessible through Unicode::UCD in perluniprops&lt;/a&gt; lists the available forms, including which ones are discouraged from use.</source>
          <target state="translated">相反的情况也有可能发生： &lt;code&gt;prop_aliases('isc')&lt;/code&gt; 返回列表 &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt; ; 而 &lt;code&gt;prop_aliases('c')&lt;/code&gt; 返回 &lt;code&gt;(C, Other)&lt;/code&gt; （后者是Perl扩展，表示 &lt;code&gt;General_Category=Other&lt;/code&gt; 。）&lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;在perluniprops&lt;/a&gt;中可通过Unicode :: UCD访问的属性列出了可用的形式，包括不鼓励使用的形式。</target>
        </trans-unit>
        <trans-unit id="da8c00abb531749489f64809eab7af330894c553" translate="yes" xml:space="preserve">
          <source>It is also possible to generate Symbian executables for &quot;miniperl&quot; and &quot;perl&quot;, but since there is no standard command line interface for Symbian (nor full keyboards in the devices), these are useful mainly as demonstrations.</source>
          <target state="translated">也可以为 &quot;miniperl &quot;和 &quot;perl &quot;生成Symbian可执行文件,但由于Symbian没有标准的命令行界面(设备中也没有完整的键盘),所以这些文件主要是作为演示用的。</target>
        </trans-unit>
        <trans-unit id="fba88eaeb368c964f0dd8f74cbc321efcbbc3751" translate="yes" xml:space="preserve">
          <source>It is also possible to have a complex number as either argument of the &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; : the appropriate component of the argument will be used.</source>
          <target state="translated">&lt;code&gt;make&lt;/code&gt; ， &lt;code&gt;emake&lt;/code&gt; ， &lt;code&gt;cplx&lt;/code&gt; 和 &lt;code&gt;cplxe&lt;/code&gt; 的任何一个参数也可能具有复数：将使用该参数的适当组成部分。</target>
        </trans-unit>
        <trans-unit id="b1daabab3a866899ef9c74e4b9b632751383e7e2" translate="yes" xml:space="preserve">
          <source>It is also possible to instead list the characters you do not want to match. You can do so by using a caret (&lt;code&gt;^&lt;/code&gt;) as the first character in the character class. For instance, &lt;code&gt;[^a-z]&lt;/code&gt; matches any character that is not a lowercase ASCII letter, which therefore includes more than a million Unicode code points. The class is said to be &quot;negated&quot; or &quot;inverted&quot;.</source>
          <target state="translated">也可以列出您不想匹配的字符。您可以通过使用尖号（ &lt;code&gt;^&lt;/code&gt; ）作为字符类中的第一个字符来实现。例如， &lt;code&gt;[^a-z]&lt;/code&gt; 匹配不是小写ASCII字母的任何字符，因此包含超过一百万个Unicode代码点。该类被称为&amp;ldquo;取反&amp;rdquo;或&amp;ldquo;取反&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d1b81a5a48e226bc85d367f9c052e3692ba4d679" translate="yes" xml:space="preserve">
          <source>It is also possible to just require Math::BigFloat:</source>
          <target state="translated">也可以只要求Math::BigFloat。</target>
        </trans-unit>
        <trans-unit id="b0f73d924849030d9c9bafff98a0dd19b4f629df" translate="yes" xml:space="preserve">
          <source>It is also possible to omit the filename parameter as well, so the call:</source>
          <target state="translated">也可以省略文件名参数,所以调用。</target>
        </trans-unit>
        <trans-unit id="c92bd63c5290ef43a80924b5bd4775d90c01eb70" translate="yes" xml:space="preserve">
          <source>It is also possible to return values directly via the parameter list--whether it is actually desirable to do it is another matter entirely.</source>
          <target state="translated">也可以通过参数列表直接返回值--是否真的需要这样做是另一回事。</target>
        </trans-unit>
        <trans-unit id="50a5455e17306f508cbf1a77905bc1e3511b26df" translate="yes" xml:space="preserve">
          <source>It is also possible to specify the minimal and maximal number of arguments an option takes. &lt;code&gt;foo=s{2,4}&lt;/code&gt; indicates an option that takes at least two and at most 4 arguments. &lt;code&gt;foo=s{1,}&lt;/code&gt; indicates one or more values; &lt;code&gt;foo:s{,}&lt;/code&gt; indicates zero or more option values.</source>
          <target state="translated">也可以指定选项采用的最小和最大数量的参数。 &lt;code&gt;foo=s{2,4}&lt;/code&gt; 表示一个选项，该选项至少接受两个，最多四个参数。 &lt;code&gt;foo=s{1,}&lt;/code&gt; 表示一个或多个值； &lt;code&gt;foo:s{,}&lt;/code&gt; 表示零个或多个选项值。</target>
        </trans-unit>
        <trans-unit id="b77bfd84df66369a6b31eeda1a74a3114d66c160" translate="yes" xml:space="preserve">
          <source>It is also possible to test whether the pre-defined warnings categories are set in the calling module with the &lt;code&gt;warnings::enabled&lt;/code&gt; function. Consider this snippet of code:</source>
          <target state="translated">也可以使用 &lt;code&gt;warnings::enabled&lt;/code&gt; 功能测试在调用模块中是否设置了预定义的警告类别。考虑以下代码片段：</target>
        </trans-unit>
        <trans-unit id="3db1f66552fc819722dedb12482e309bce26efa4" translate="yes" xml:space="preserve">
          <source>It is also unique in that all other Perl operators impose a context (usually string or numeric context) on their operands, autoconverting those operands to those imposed contexts. In contrast, smartmatch</source>
          <target state="translated">它的独特之处在于,所有其他的Perl运算符都会在它们的操作数上施加一个上下文(通常是字符串或数字上下文),将这些操作数自动转换为这些施加的上下文。相比之下,smartmatch</target>
        </trans-unit>
        <trans-unit id="fac8d72d737b1435638a2eef2e2bc6f98342f178" translate="yes" xml:space="preserve">
          <source>It is also worth noting that &lt;code&gt;nextStream&lt;/code&gt; can be called at any time -- you don't have to wait until you have exhausted a compressed data stream before skipping to the next one.</source>
          <target state="translated">还值得注意的是，可以随时调用 &lt;code&gt;nextStream&lt;/code&gt; －您不必等到耗尽压缩数据流之后再跳到下一个。</target>
        </trans-unit>
        <trans-unit id="acc49eaced7d721523b5bd759190363e32250fa1" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name not defined by a &lt;code&gt;(?&amp;lt;NAME&amp;gt;)&lt;/code&gt; earlier in the pattern.</source>
          <target state="translated">引用未由模式中的 &lt;code&gt;(?&amp;lt;NAME&amp;gt;)&lt;/code&gt; 定义的名称是错误的。</target>
        </trans-unit>
        <trans-unit id="13ee6665661c6d90800f41308ee104afc7c23af8" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name that is not declared somewhere in the pattern.</source>
          <target state="translated">引用一个没有在模式中声明的名称是错误的。</target>
        </trans-unit>
        <trans-unit id="65cfdd54d892c74c51301f814a65bd9d932d410a" translate="yes" xml:space="preserve">
          <source>It is an error to try to</source>
          <target state="translated">试图进行以下操作是错误的</target>
        </trans-unit>
        <trans-unit id="2f0a90fe17f957e846e3b518ba860308d4237cf1" translate="yes" xml:space="preserve">
          <source>It is assumed that if a module name is supplied, that that name matches the file name. Pods are not opened to check for the 'NAME' entry.</source>
          <target state="translated">如果提供了一个模块名,则假定该名称与文件名一致。Pods不会被打开来检查 &quot;NAME &quot;条目。</target>
        </trans-unit>
        <trans-unit id="c5af0c152794fef2b12ee8e78572d2cb96b0bb53" translate="yes" xml:space="preserve">
          <source>It is at this stage that &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; silently optimizes &lt;code&gt;/^/&lt;/code&gt; to mean &lt;code&gt;/^/m&lt;/code&gt; .</source>
          <target state="translated">正是在这个阶段， &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; 默默地将 &lt;code&gt;/^/&lt;/code&gt; 优化为 &lt;code&gt;/^/m&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8c668d4a29eb47ae15a72aa4d1dd8cfb718abf5" translate="yes" xml:space="preserve">
          <source>It is at this step that &lt;code&gt;\1&lt;/code&gt; is begrudgingly converted to &lt;code&gt;$1&lt;/code&gt; in the replacement text of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, in order to correct the incorrigible</source>
          <target state="translated">正是在此步骤中，将 &lt;code&gt;\1&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 的替换文本中转换为 &lt;code&gt;$1&lt;/code&gt; ，以纠正不可修正的错误</target>
        </trans-unit>
        <trans-unit id="4466ca0969a2662c5b072bf7cd93ebda9f966a8c" translate="yes" xml:space="preserve">
          <source>It is basically equivalent to:</source>
          <target state="translated">基本等同于。</target>
        </trans-unit>
        <trans-unit id="c77b015f95e7c8d0f9144f6b141dfe36a63eb292" translate="yes" xml:space="preserve">
          <source>It is clear that inline code is going to be faster than subroutine or method calls, because there is less overhead, but this approach has the disadvantage of being less maintainable and comes at the cost of greater memory usage - there is no such thing as a free lunch. If you are searching for an element in a list, it can be more efficient to store the data in a hash structure, and then simply look to see whether the key is defined, rather than to loop through the entire array using grep() for instance. substr() may be (a lot) faster than grep() but not as flexible, so you have another trade-off to access. Your code may contain a line which takes 0.01 of a second to execute which if you call it 1,000 times, quite likely in a program parsing even medium sized files for instance, you already have a 10 second delay, in just one single code location, and if you call that line 100,000 times, your entire program will slow down to an unbearable crawl.</source>
          <target state="translated">很明显,内联代码要比子程序或方法调用更快,因为开销更少,但这种方法的缺点是可维护性较差,而且要以更大的内存使用量为代价,天下没有免费的午餐。如果你要在一个列表中搜索一个元素,那么将数据存储在一个哈希结构中,然后简单地查看是否定义了键,而不是使用grep()等方法循环浏览整个数组,可能会更有效率。substr()可能比grep()快(很多),但没有那么灵活,所以你要进行另一种权衡来访问。你的代码可能包含了一行需要0.01秒的执行时间,如果你调用它1000次,很有可能在一个程序中,比如说解析中等大小的文件,你已经有了10秒的延迟,只是在一个单一的代码位置,如果你调用这一行100,000次,你的整个程序会慢到无法忍受的地步。</target>
        </trans-unit>
        <trans-unit id="f6122f662407715d120a73ec05bd2bbbf07e1b28" translate="yes" xml:space="preserve">
          <source>It is common to simply say &lt;code&gt;$filename = Pod::Simple::Search-&amp;gt; new
-&amp;gt;find(&quot;perlvar&quot;)&lt;/code&gt; so that just the @INC (well, and scriptdir) directories are searched. (This happens because the &lt;code&gt;inc&lt;/code&gt; attribute is true by default.)</source>
          <target state="translated">通常，简单地说 &lt;code&gt;$filename = Pod::Simple::Search-&amp;gt; new -&amp;gt;find(&quot;perlvar&quot;)&lt;/code&gt; 以便只搜索@INC目录（以及脚本目录）。（这是因为 &lt;code&gt;inc&lt;/code&gt; 属性默认为true。）</target>
        </trans-unit>
        <trans-unit id="94fd6736ac13c38aadc8d6ee40bf099cf30a2334" translate="yes" xml:space="preserve">
          <source>It is commonly thought that if a system does not have the capability to dynamically load a library, you cannot build XSUBs. This is incorrect. You</source>
          <target state="translated">人们通常认为,如果一个系统不具备动态加载库的能力,就不能构建XSUB。这是不正确的。您可以</target>
        </trans-unit>
        <trans-unit id="7b3776ce40b36ce2eb6604faa164797c0a666707" translate="yes" xml:space="preserve">
          <source>It is convenient to think that the indirection operator &lt;code&gt;*&lt;/code&gt; should be considered as a part of the type and the address operator &lt;code&gt;&amp;amp;&lt;/code&gt; should be considered part of the variable. See &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; for more info about handling qualifiers and unary operators in C types.</source>
          <target state="translated">方便地认为，应该将间接运算符 &lt;code&gt;*&lt;/code&gt; 视为类型的一部分，并将地址运算符 &lt;code&gt;&amp;amp;&lt;/code&gt; 视为变量的一部分。有关在C类型中处理限定符和一元运算符的更多信息，请参见&lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e49556be27809812b1f952c88dbd0fb8ac73080a" translate="yes" xml:space="preserve">
          <source>It is conventional to start layer names with a colon (for example, &lt;code&gt;:perlio&lt;/code&gt; ) to emphasize their similarity to variable &quot;attributes&quot;. But the code that parses layer specification strings, which is also used to decode the PERLIO environment variable, treats the colon as a separator.</source>
          <target state="translated">通常以冒号（例如 &lt;code&gt;:perlio&lt;/code&gt; ）开头图层名称，以强调其与变量&amp;ldquo;属性&amp;rdquo;的相似性。但是，用于解析层规范字符串的代码（也用于解码PERLIO环境变量）将冒号视为分隔符。</target>
        </trans-unit>
        <trans-unit id="9ddbcb8555d7ffc2811c34458dc5e23aebe16a93" translate="yes" xml:space="preserve">
          <source>It is eagerly hoped that in the future, increasing numbers of formats (and formatters) will support Unicode characters directly (as (X)HTML does with &lt;code&gt;&amp;amp;infin;&lt;/code&gt; , &lt;code&gt;&amp;amp;#8734;&lt;/code&gt;, or &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt;), reducing the need for idiosyncratic mappings of Unicode-to-</source>
          <target state="translated">热切希望将来，越来越多的格式（和格式化程序）将直接支持Unicode字符（如（X）HTML使用 &lt;code&gt;&amp;amp;infin;&lt;/code&gt; ， &lt;code&gt;&amp;amp;#8734;&lt;/code&gt; 或 &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt; ），从而减少了对特殊字符的需求Unicode到</target>
        </trans-unit>
        <trans-unit id="1feb840e61338fb8d69eab115197ceb6e4d8f195" translate="yes" xml:space="preserve">
          <source>It is easier to see with comments:</source>
          <target state="translated">有评论就更容易看到。</target>
        </trans-unit>
        <trans-unit id="deebd2bf2cb329548cf17163d065366c59ebd497" translate="yes" xml:space="preserve">
          <source>It is entirely possible for a subroutine to have both a prototype and a signature. They do different jobs: the prototype affects compilation of calls to the subroutine, and the signature puts argument values into lexical variables at runtime. You can therefore write</source>
          <target state="translated">一个子程序完全有可能同时拥有原型和签名。它们做着不同的工作:原型会影响对子程序的调用的编译,而签名会在运行时将参数值放入词法变量中。因此你可以写</target>
        </trans-unit>
        <trans-unit id="e8705c44d271d802e23ff6717b34393b3365f69d" translate="yes" xml:space="preserve">
          <source>It is even possible to give your own names to characters and character sequences. For details, see &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">甚至可以给您自己的名字命名字符和字符序列。有关详细信息，请参见&lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c3622fe65f713ae38110b205b49d3188003c82c" translate="yes" xml:space="preserve">
          <source>It is expected that arguments to methods that are not explicitly supposed to be changed are constant (but this is not enforced).</source>
          <target state="translated">人们希望那些没有明确表示应该改变的方法的参数是不变的(但这并没有被强制执行)。</target>
        </trans-unit>
        <trans-unit id="776c3073c10966ce7532e508c1ba6620f8fcb74a" translate="yes" xml:space="preserve">
          <source>It is expected that what exactly &lt;code&gt;'strict'&lt;/code&gt; does will evolve over time as we gain experience with it. This means that programs that compile under it in today's Perl may not compile, or may have more or fewer warnings, in future Perls. There is no backwards compatibility promises with regards to it. Also there are already proposals for an alternate syntax for enabling it. For these reasons, using it will raise a &lt;code&gt;experimental::re_strict&lt;/code&gt; class warning, unless that category is turned off.</source>
          <target state="translated">可以预料，随着我们积累经验，确切的 &lt;code&gt;'strict'&lt;/code&gt; 行为会随着时间而发展。这意味着在今天的Perl中使用它进行编译的程序在将来的Perls中可能不会编译，或者可能有更多或更少的警告。没有向后兼容性的保证。也已经有人提出了启用它的替代语法的建议。由于这些原因，除非关闭了该类别，否则使用它会产生 &lt;code&gt;experimental::re_strict&lt;/code&gt; 类警告。</target>
        </trans-unit>
        <trans-unit id="743ffcd338b65d877bd2bc22191ffd5f5bc78800" translate="yes" xml:space="preserve">
          <source>It is exported upon request.</source>
          <target state="translated">它是根据要求出口的。</target>
        </trans-unit>
        <trans-unit id="fc922ccc86e1ddfa603184a6c1df119e90d551a2" translate="yes" xml:space="preserve">
          <source>It is generally a bad idea to mix non-UTF-8 locales and Unicode, and this issue is one of the reasons why. This warning is raised when Unicode rules would normally cause the result of this operation to contain a character that is in the range specified by the locale, 0..255, and hence is subject to the locale's rules, not Unicode's.</source>
          <target state="translated">一般来说,将非UTF-8的locale和Unicode混合使用是个坏主意,这个问题是其中一个原因。当Unicode规则通常会导致该操作的结果包含一个在locale指定的范围内的字符,0...255,因此受locale规则而不是Unicode规则的约束时,就会发出这个警告。</target>
        </trans-unit>
        <trans-unit id="4425fdf4018e2e8fba242ccf31d9fb769e12dacd" translate="yes" xml:space="preserve">
          <source>It is guaranteed that</source>
          <target state="translated">保证</target>
        </trans-unit>
        <trans-unit id="a6f4741397b5a8e1cbfacb47c2230423a05f8010" translate="yes" xml:space="preserve">
          <source>It is guaranteed that an</source>
          <target state="translated">它保证了</target>
        </trans-unit>
        <trans-unit id="13b4603391d295cad7c663188ece67a47ecf1dc6" translate="yes" xml:space="preserve">
          <source>It is hard to understand without digging what exactly matches ranges other than subsets of &lt;code&gt;[A-Z]&lt;/code&gt; , &lt;code&gt;[a-z]&lt;/code&gt; , and &lt;code&gt;[0-9]&lt;/code&gt; . A sound principle is to use only ranges that begin from and end at either alphabetics of equal case ([a-e], [A-E]), or digits ([0-9]). Anything else is unsafe or unclear. If in doubt, spell out the range in full.</source>
          <target state="translated">如果不挖掘 &lt;code&gt;[A-Z]&lt;/code&gt; ， &lt;code&gt;[a-z]&lt;/code&gt; 和 &lt;code&gt;[0-9]&lt;/code&gt; 的子集以外的范围，则很难理解。合理的原则是仅使用以大小写相同的字母（[ae]，[AE]）或数字（[0-9]）开头和结尾的范围。还有其他不安全或不清楚的地方。如有疑问，请完整说明范围。</target>
        </trans-unit>
        <trans-unit id="32102cc598d5c6f1883220e9be88e26b0126c4bb" translate="yes" xml:space="preserve">
          <source>It is highly recommended to use the new interface.</source>
          <target state="translated">强烈建议使用新界面。</target>
        </trans-unit>
        <trans-unit id="ca5fa5ba1e81b193ad6d8416f6d80a9e68a2d380" translate="yes" xml:space="preserve">
          <source>It is however guaranteed that backslash or escape sequences never have a punctuation character following the backslash, not now, and not in a future version of Perl 5. So it is safe to put a backslash in front of a non-word character.</source>
          <target state="translated">然而,我们可以保证反斜杠或转义序列的后面永远不会有标点符号,现在不会,将来的 Perl 5 版本也不会,所以在非单词字符前面加上反斜杠是安全的。</target>
        </trans-unit>
        <trans-unit id="77f0274e9c470893b80643add674cf709738754d" translate="yes" xml:space="preserve">
          <source>It is implemented using the standard perl TIEHASH interface. Please see the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; entry in perlfunc(1) and perltie(1) for more information.</source>
          <target state="translated">它使用标准的perl TIEHASH接口实现。有关更多信息，请参见perlfunc（1）和perltie（1）中的 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="53ed786f282bde3aa8de3b1b643efa3bb560a2fd" translate="yes" xml:space="preserve">
          <source>It is important that you read the &lt;a href=&quot;opcode&quot;&gt;Opcode&lt;/a&gt; module documentation for more information, especially for detailed definitions of opnames, optags and opsets.</source>
          <target state="translated">请阅读&lt;a href=&quot;opcode&quot;&gt;Opcode&lt;/a&gt;模块文档以获取更多信息，尤其是关于操作名，操作标签和操作集的详细定义，这一点很重要。</target>
        </trans-unit>
        <trans-unit id="2977106e878eb3427358dec08f1824351409ba37" translate="yes" xml:space="preserve">
          <source>It is important that you use a supported 'make' program, and ensure Config.pm knows about it. If you don't have nmake, you can either get dmake from the location mentioned earlier or get an old version of nmake reportedly available from:</source>
          <target state="translated">重要的是,你必须使用一个支持的 &quot;make &quot;程序,并确保Config.pm知道它。如果你没有 nmake,你可以从前面提到的地方获取 dmake,或者从以下地方获取旧版本的 nmake。</target>
        </trans-unit>
        <trans-unit id="ff64ea14bb1b01f98f924406ee57c3ed5e8b95d4" translate="yes" xml:space="preserve">
          <source>It is important to do &lt;code&gt;make dist&lt;/code&gt; as early as possible. This way you can easily merge(1) your changes to autogenerated files if you decide to edit your &lt;code&gt;.h&lt;/code&gt; files and rerun h2xs.</source>
          <target state="translated">尽早 &lt;code&gt;make dist&lt;/code&gt; 是很重要的。这样，如果您决定编辑 &lt;code&gt;.h&lt;/code&gt; 文件并重新运行h2xs，则可以轻松地合并（1）对自动生成的文件的更改。</target>
        </trans-unit>
        <trans-unit id="a9a567c14d6791400f926d0994fcc8f3b056f648" translate="yes" xml:space="preserve">
          <source>It is important to know that these CLIs may behave different when the command line contains special characters, in particular quotes or backslashes. For example, with Unix shells you can use single quotes (&lt;code&gt;'&lt;/code&gt;) and double quotes (&lt;code&gt;&quot;&lt;/code&gt;) to group words together. The following alternatives are equivalent on Unix:</source>
          <target state="translated">重要的是要知道，当命令行包含特殊字符（特别是引号或反斜杠）时，这些CLI的行为可能会有所不同。例如，在Unix shell中，您可以使用单引号（ &lt;code&gt;'&lt;/code&gt; ）和双引号（ &lt;code&gt;&quot;&lt;/code&gt; ）将单词组合在一起。以下替代方法在Unix上是等效的：</target>
        </trans-unit>
        <trans-unit id="dcb1aa33844e3457c736e676b2e42e15c5425cfa" translate="yes" xml:space="preserve">
          <source>It is important to note that the variable can be notified even if no thread &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; on the variable. It is therefore important to check the value of the variable and go back to waiting if the requirement is not fulfilled. For example, to pause until a shared counter drops to zero:</source>
          <target state="translated">重要的是要注意，即使在变量上没有线程 &lt;code&gt;cond_signal&lt;/code&gt; 或 &lt;code&gt;cond_broadcast&lt;/code&gt; ，也可以通知该变量。因此，重要的是检查变量的值并在未满足要求时返回等待状态。例如，要暂停直到共享计数器降为零：</target>
        </trans-unit>
        <trans-unit id="07be512ccc5c73682b884e92456cd275f3ff5ced" translate="yes" xml:space="preserve">
          <source>It is important to realize when you use these Unicode boundaries, that you are taking a risk that a future version of Perl which contains a later version of the Unicode Standard will not work precisely the same way as it did when your code was written. These rules are not considered stable and have been somewhat more subject to change than the rest of the Standard. Unicode reserves the right to change them at will, and Perl reserves the right to update its implementation to Unicode's new rules. In the past, some changes have been because new characters have been added to the Standard which have different characteristics than all previous characters, so new rules are formulated for handling them. These should not cause any backward compatibility issues. But some changes have changed the treatment of existing characters because the Unicode Technical Committee has decided that the change is warranted for whatever reason. This could be to fix a bug, or because they think better results are obtained with the new rule.</source>
          <target state="translated">当你使用这些Unicode边界时,你必须意识到你正在承担一个风险,即未来的Perl版本如果包含了Unicode标准的较新版本,那么它的工作方式将与你的代码编写时不完全相同。这些规则不被认为是稳定的,而且比标准的其他部分更容易改变。Unicode 保留了随意更改它们的权利,Perl 也保留了根据 Unicode 的新规则更新其实现的权利。在过去,有些变化是因为标准中加入了新的字符,这些字符与以前所有的字符有不同的特性,所以制定了新的规则来处理它们。这些应该不会引起任何后向兼容性问题。但有些变化是由于Unicode技术委员会决定出于某种原因而改变了对现有字符的处理。这可能是为了修复一个错误,或者因为他们认为新规则可以获得更好的结果。</target>
        </trans-unit>
        <trans-unit id="6b377275b56d69ca0e60d3e0cbc10a16f405fe04" translate="yes" xml:space="preserve">
          <source>It is important to remember that &lt;code&gt;yield()&lt;/code&gt; is only a hint to give up the CPU, it depends on your hardware, OS and threading libraries what actually happens. &lt;b&gt;On many operating systems, yield() is a no-op.&lt;/b&gt; Therefore it is important to note that one should not build the scheduling of the threads around &lt;code&gt;yield()&lt;/code&gt; calls. It might work on your platform but it won't work on another platform.</source>
          <target state="translated">重要的是要记住， &lt;code&gt;yield()&lt;/code&gt; 仅是放弃CPU的提示，它取决于您的硬件，操作系统和线程库实际发生的情况。&lt;b&gt;在许多操作系统上，yield（）是禁止操作的。&lt;/b&gt;因此，重要的是要注意，不应围绕 &lt;code&gt;yield()&lt;/code&gt; 调用构建线程的调度。它可能会在您的平台上运行，但不会在另一个平台上运行。</target>
        </trans-unit>
        <trans-unit id="bb902098169f8bf10c78af87761104595e279d51" translate="yes" xml:space="preserve">
          <source>It is intended to be called in this manner:</source>
          <target state="translated">拟以这种方式称呼。</target>
        </trans-unit>
        <trans-unit id="6c67b173e9f7ca15b0d9849fa732dc6b9c27b1b9" translate="yes" xml:space="preserve">
          <source>It is legal to intermix calls to &lt;code&gt;gzread&lt;/code&gt; and &lt;code&gt;gzreadline&lt;/code&gt; .</source>
          <target state="translated">将调用 &lt;code&gt;gzread&lt;/code&gt; 和 &lt;code&gt;gzreadline&lt;/code&gt; 混合在一起是合法的。</target>
        </trans-unit>
        <trans-unit id="b081e40b0dd1e97c28fc968fc88db21c07110075" translate="yes" xml:space="preserve">
          <source>It is less confusing to either calculate the result fully, and afterwards round it explicitly, or use the additional parameters to the math functions like so:</source>
          <target state="translated">要么充分计算结果,事后明确四舍五入,要么像这样使用数学函数的附加参数,这样就不那么混乱了。</target>
        </trans-unit>
        <trans-unit id="38f913862bf185692af7e2eaaf2148c65356aec6" translate="yes" xml:space="preserve">
          <source>It is most convenient to use in a &lt;code&gt;foreach&lt;/code&gt; loop, for example:</source>
          <target state="translated">在 &lt;code&gt;foreach&lt;/code&gt; 循环中使用最方便，例如：</target>
        </trans-unit>
        <trans-unit id="69bffc928e3fa117d0fd3dd3376d4295ace44212" translate="yes" xml:space="preserve">
          <source>It is no longer possible to compile PA-RISC 1.0 executables on either the PA-RISC 1.1 or 2.0 platforms. The command-line flags are accepted, but the resulting executable will not run when transferred to a PA-RISC 1.0 system.</source>
          <target state="translated">在PA-RISC 1.1或2.0平台上编译PA-RISC 1.0可执行文件已不再可能。命令行标志被接受,但当转移到PA-RISC 1.0系统时,产生的可执行文件将无法运行。</target>
        </trans-unit>
        <trans-unit id="09c5f6dc5c28104c8b1496a7745505dfd0c3755b" translate="yes" xml:space="preserve">
          <source>It is no longer possible to link PA-RISC 1.0 shared libraries (even though the command-line flags are still present).</source>
          <target state="translated">现在已经不可能链接PA-RISC 1.0共享库了(即使命令行标志仍然存在)。</target>
        </trans-unit>
        <trans-unit id="5e391513315c3abeec46220661da8fc25e5f09fd" translate="yes" xml:space="preserve">
          <source>It is not considered an error for &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; to return false if it fails due to an &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (or equivalent) condition. This means one can still use the common convention of testing the return value of &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; when called with the &lt;code&gt;LOCK_NB&lt;/code&gt; option:</source>
          <target state="translated">如果由于 &lt;code&gt;EWOULDBLOCK&lt;/code&gt; （或等效条件）而失败，则 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 返回false 不会被认为是错误。这意味着当使用 &lt;code&gt;LOCK_NB&lt;/code&gt; 选项调用时，仍然可以使用测试 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 返回值的通用约定：</target>
        </trans-unit>
        <trans-unit id="eb49901ab613cbcc1013bad05870bde6b73a1f49" translate="yes" xml:space="preserve">
          <source>It is not desirable to import the functions &lt;code&gt;fieldhash&lt;/code&gt; and/or &lt;code&gt;fieldhashes&lt;/code&gt; into every class that is going to use them. They are only used once to set up the class. When the class is up and running, these functions serve no more purpose.</source>
          <target state="translated">不希望将函数 &lt;code&gt;fieldhash&lt;/code&gt; 和/或 &lt;code&gt;fieldhashes&lt;/code&gt; 导入要使用它们的每个类中。它们仅用于设置课程一次。当类启动并运行时，这些功能不再起作用。</target>
        </trans-unit>
        <trans-unit id="c5fbc8d597bc2a95fe72ba36ecdd3925f81ca3bb" translate="yes" xml:space="preserve">
          <source>It is not necessary for voting to be held on cherry-picking perldelta entries associated with changes that have already been cherry-picked, nor for the maint-pumpking to obtain votes on changes required by the</source>
          <target state="translated">对与已经采摘的变更相关的采摘perldelta条目不需要进行投票,也不需要主推对所需变更进行投票。</target>
        </trans-unit>
        <trans-unit id="fee4bc3261e1d5762f4a782cbbcca1c13a9e84eb" translate="yes" xml:space="preserve">
          <source>It is not necessary to include every change meeting these criteria, and in general the focus should be on addressing security issues, crashing bugs, regressions and serious installation issues. The temptation to include a plethora of minor changes that don't affect the installation or execution of perl (e.g. spelling corrections in documentation) should be resisted in order to reduce the overall risk of overlooking something. The intention is to create maintenance releases which are both worthwhile and which users can have full confidence in the stability of. (A secondary concern is to avoid burning out the maint-pumpking or overwhelming other committers voting on changes to be included (see &lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;Getting changes into a maint branch&lt;/a&gt; below).)</source>
          <target state="translated">不必包括所有符合这些条件的变更，通常，重点应放在解决安全性问题，崩溃的bug，回归和严重的安装问题上。为了减少总体上忽略某些内容的风险，应该抵制诱惑，包括不影响perl的安装或执行的大量次要更改（例如，文档中的拼写更正）。目的是创建既值得而且用户可以对其稳定性完全放心的维护版本。 （第二个注意事项是避免耗尽主干泵或压倒其他提交者对要包含的更改进行投票（请参阅下面的将&lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;更改放入主干分支&lt;/a&gt;）。）</target>
        </trans-unit>
        <trans-unit id="90bcb58fb92d14a7b685940a550af6acd8800f2a" translate="yes" xml:space="preserve">
          <source>It is not necessary to mention DynaLoader or the current extension when filling in INCLUDE_EXT. If the INCLUDE_EXT is mentioned but is empty then only DynaLoader and the current extension will be included in the build.</source>
          <target state="translated">在填写INCLUDE_EXT时,不需要提及DynaLoader或当前的扩展。如果INCLUDE_EXT被提及但为空,那么只有DynaLoader和当前扩展会被包含在构建中。</target>
        </trans-unit>
        <trans-unit id="6c22235436c0d9c88ea34e3651dd185b541bd55a" translate="yes" xml:space="preserve">
          <source>It is not possible to have a subroutine or a keyword with the same name as a constant in the same package. This is probably a Good Thing.</source>
          <target state="translated">在同一个包中,不可能有一个子程序或一个与常量同名的关键字。这可能是一件好事。</target>
        </trans-unit>
        <trans-unit id="f4712dd85edea86a32c5bfd8ffd1fe49536a91d9" translate="yes" xml:space="preserve">
          <source>It is not possible to pack or unpack bit fields - just integral bytes. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; always starts at the next byte boundary and &quot;rounds up&quot; to the next multiple of 8 by adding zero bits as required. (If you do want bit fields, there is &lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;. Or you could implement bit field handling at the character string level, using split, substr, and concatenation on unpacked bit strings.)</source>
          <target state="translated">不能打包或解包位字段-只能是整数字节。 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 总是从下一个字节边界开始，并通过按要求添加零位来&amp;ldquo;舍入&amp;rdquo;为8的下一个倍数。（如果确实需要位字段，则可以使用&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;。也可以在字符串级别使用未打包的位字符串上的split，substr和concatenation来实现位字段处理。）</target>
        </trans-unit>
        <trans-unit id="3efe75bc9ad9fbe460b3b9a87287e6aa69baa4d8" translate="yes" xml:space="preserve">
          <source>It is not safe to use the value of &lt;code&gt;$^X&lt;/code&gt; as a path name of a file, as some operating systems that have a mandatory suffix on executable files do not require use of the suffix when invoking a command. To convert the value of &lt;code&gt;$^X&lt;/code&gt; to a path name, use the following statements:</source>
          <target state="translated">将 &lt;code&gt;$^X&lt;/code&gt; 的值用作文件的路径名是不安全的，因为某些在可执行文件上带有强制后缀的操作系统在调用命令时不需要使用后缀。要将 &lt;code&gt;$^X&lt;/code&gt; 的值转换为路径名，请使用以下语句：</target>
        </trans-unit>
        <trans-unit id="17f49b3471db481f432117951bcb8866bb533894" translate="yes" xml:space="preserve">
          <source>It is not uncommon to want to match a range of characters. Luckily, instead of listing all characters in the range, one may use the hyphen (&lt;code&gt;-&lt;/code&gt; ). If inside a bracketed character class you have two characters separated by a hyphen, it's treated as if all characters between the two were in the class. For instance, &lt;code&gt;[0-9]&lt;/code&gt; matches any ASCII digit, and &lt;code&gt;[a-m]&lt;/code&gt; matches any lowercase letter from the first half of the ASCII alphabet.</source>
          <target state="translated">想要匹配一定范围的字符并不少见。幸运的是，与其列出该范围内的所有字符，不如使用连字符（ &lt;code&gt;-&lt;/code&gt; ）。如果在带括号的字符类中，您有两个字符用连字符分隔，则将这两个字符之间的所有字符都视为类中的字符。例如， &lt;code&gt;[0-9]&lt;/code&gt; 匹配任何ASCII数字， &lt;code&gt;[a-m]&lt;/code&gt; 匹配ASCII字母表前半部分的任何小写字母。</target>
        </trans-unit>
        <trans-unit id="ea195389d2ab8304dae6a2be37001201928a81bd" translate="yes" xml:space="preserve">
          <source>It is now being maintained separately from the Perl core by Dave Rolsky, &amp;lt;autarch@urth.org&amp;gt;.</source>
          <target state="translated">现在，Dave Rolsky（&amp;lt;autarch@urth.org&amp;gt;）与Perl核心分开进行维护。</target>
        </trans-unit>
        <trans-unit id="0a2d81d68cd0e192d7fee2715fc04989d662c22e" translate="yes" xml:space="preserve">
          <source>It is often more readable to use the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator between key/value pairs. The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is mostly just a more visually distinctive synonym for a comma, but it also arranges for its left-hand operand to be interpreted as a string if it's a bareword that would be a legal simple identifier. &lt;code&gt;=&amp;gt;&lt;/code&gt; doesn't quote compound identifiers, that contain double colons. This makes it nice for initializing hashes:</source>
          <target state="translated">在键/值对之间使用 &lt;code&gt;=&amp;gt;&lt;/code&gt; 运算符通常更易读。该 &lt;code&gt;=&amp;gt;&lt;/code&gt; 运营商大多只是视觉上更加鲜明的逗号代名词，但它也安排了左边的操作数，如果它是这将是一个合法的简单标识的裸词被解释为一个字符串。 &lt;code&gt;=&amp;gt;&lt;/code&gt; 不引用包含双冒号的复合标识符。这非常适合初始化哈希：</target>
        </trans-unit>
        <trans-unit id="ca5507a15a15ea470ddab20bdff08a946fb003e3" translate="yes" xml:space="preserve">
          <source>It is often not wise to share an object unless the class itself has been written to support sharing. For example, an object's destructor may get called multiple times, once for each thread's scope exit. Another danger is that the contents of hash-based objects will be lost due to the above mentioned limitation. See</source>
          <target state="translated">通常情况下,共享一个对象是不明智的,除非类本身已经被编写成支持共享。例如,一个对象的destructor可能会被多次调用,每个线程的作用域退出都会被调用一次。另一个危险是,基于哈希的对象的内容会因为上述限制而丢失。请看</target>
        </trans-unit>
        <trans-unit id="c69ba08cbdace146eeaa3088aa2fbd7151747d45" translate="yes" xml:space="preserve">
          <source>It is okay for the lines starting at the &quot;CODE:&quot; line to not be indented. However, for readability purposes, it is suggested that you indent CODE: one level and the lines following one more level.</source>
          <target state="translated">从 &quot;CODE:&quot;开始的行可以不缩进。但是,为了便于阅读,建议将CODE:缩进一级,后面的行再缩进一级。</target>
        </trans-unit>
        <trans-unit id="65df07e3fa6135b82df3a9d6866989ee7ae4d5d2" translate="yes" xml:space="preserve">
          <source>It is only used on OS/2 and Win32.</source>
          <target state="translated">它只在OS/2和Win32上使用。</target>
        </trans-unit>
        <trans-unit id="6661787e0f495e149a6ee0b4ddf2a5d46d4df496" translate="yes" xml:space="preserve">
          <source>It is particularly important to note that neither the shell nor the C runtime do any wildcard expansions of command-line arguments (so wildcards need not be quoted). Also, the quoting behaviours of the shell and the C runtime are rudimentary at best (and may, if you are using a non-standard shell, be inconsistent). The only (useful) quote character is the double quote (&quot;). It can be used to protect spaces and other special characters in arguments.</source>
          <target state="translated">特别需要注意的是,shell和C运行时都不对命令行参数进行通配符扩展(所以通配符不需要引用)。另外,shell和C运行时的引号行为充其量只是初级的(如果你使用的是非标准的shell,可能会有不一致的地方)。唯一(有用的)引号字符是双引号(&quot;)。它可以用来保护参数中的空格和其他特殊字符。</target>
        </trans-unit>
        <trans-unit id="b08f708cd4767406ca484e1891baf6f457b1498f" translate="yes" xml:space="preserve">
          <source>It is possible for the Perl subroutine you are calling to terminate abnormally, e.g., by calling</source>
          <target state="translated">你所调用的Perl子程序有可能会异常终止,例如,通过调用</target>
        </trans-unit>
        <trans-unit id="68748e768505aa715cf11b4ae34ec36bb19593be" translate="yes" xml:space="preserve">
          <source>It is possible that, upon completion, not all arguments in the string have been processed. &lt;code&gt;GetOptionsFromString&lt;/code&gt; will, when called in list context, return both the return status and an array reference to any remaining arguments:</source>
          <target state="translated">完成后，可能未处理完字符串中的所有参数。在列表上下文中调用时， &lt;code&gt;GetOptionsFromString&lt;/code&gt; 将返回返回状态和对任何剩余参数的数组引用：</target>
        </trans-unit>
        <trans-unit id="da1fb645dee4eb2dcf81d78a3bbd52439eec6574" translate="yes" xml:space="preserve">
          <source>It is possible to add &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;END blocks&lt;/a&gt; to threads by using &lt;a href=&quot;functions/require&quot;&gt;require VERSION&lt;/a&gt; or &lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt; with the appropriate code. These &lt;code&gt;END&lt;/code&gt; blocks will then be executed when the thread's interpreter is destroyed (i.e., either during a &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call, or at program termination).</source>
          <target state="translated">通过使用带有适当代码的&lt;a href=&quot;functions/require&quot;&gt;require VERSION&lt;/a&gt;或&lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt;，可以向线程添加&lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;END块&lt;/a&gt;。然后，当线程的解释器被销毁时（即，在 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 调用期间或程序终止时），将执行这些 &lt;code&gt;END&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="103a4ec3966b9d4c47f8bb4d45cb27898db88b92" translate="yes" xml:space="preserve">
          <source>It is possible to ask for a different method resolution order with the &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma.</source>
          <target state="translated">可以使用&lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma 要求不同的方法解析顺序。</target>
        </trans-unit>
        <trans-unit id="214e8fa8e052ffd8fef627a3a69587c1d8000f20" translate="yes" xml:space="preserve">
          <source>It is possible to ask for such a statistic at arbitrary points in your execution using the mstat() function out of the standard Devel::Peek module.</source>
          <target state="translated">可以使用标准的Devel::Peek模块中的mstat()函数在执行过程中的任意点要求这样一个统计。</target>
        </trans-unit>
        <trans-unit id="b3c2ec1b334ee0d70dae2975648b13f78c06cb41" translate="yes" xml:space="preserve">
          <source>It is possible to build a threaded version of perl on Solaris. The entire perl thread implementation is still experimental, however, so beware.</source>
          <target state="translated">在Solaris上可以构建一个线程版的perl。然而,整个perl线程的实现仍然是实验性的,所以要注意。</target>
        </trans-unit>
        <trans-unit id="5dcdcf19c7450b4c54b9304c481faacc66e7c2fc" translate="yes" xml:space="preserve">
          <source>It is possible to compile a version of threaded Perl on any version of HP-UX before 10.30, but it is strongly suggested that you be running on HP-UX 11.00 at least.</source>
          <target state="translated">可以在10.30之前的任何HP-UX版本上编译一个线程Perl的版本,但强烈建议你至少在HP-UX 11.00上运行。</target>
        </trans-unit>
        <trans-unit id="fda7319a695e60b7430ed01765a1f487df41c0cc" translate="yes" xml:space="preserve">
          <source>It is possible to control which characters terminate words by modifying &lt;code&gt;$Text::Wrap::break&lt;/code&gt; . Set this to a string such as &lt;code&gt;'[\s:]'&lt;/code&gt; (to break before spaces or colons) or a pre-compiled regexp such as &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/[\s']/&lt;/a&gt;&lt;/code&gt; (to break before spaces or apostrophes). The default is simply &lt;code&gt;'\s'&lt;/code&gt; ; that is, words are terminated by spaces. (This means, among other things, that trailing punctuation such as full stops or commas stay with the word they are &quot;attached&quot; to.) Setting &lt;code&gt;$Text::Wrap::break&lt;/code&gt; to a regular expression that doesn't eat any characters (perhaps just a forward look-ahead assertion) will cause warnings.</source>
          <target state="translated">通过修改 &lt;code&gt;$Text::Wrap::break&lt;/code&gt; 可以控制哪些字符终止单词。将其设置为字符串，例如 &lt;code&gt;'[\s:]'&lt;/code&gt; （在空格或冒号之前中断）或预编译的正则表达式（例如 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/[\s']/&lt;/a&gt;&lt;/code&gt; （在空格或撇号之前中断）。默认是简单的 &lt;code&gt;'\s'&lt;/code&gt; ;也就是说，单词以空格结尾。 （这意味着，除其他事项外，诸如句号或逗号之类的标点符号都与它们&amp;ldquo;附加&amp;rdquo;在一起。）将 &lt;code&gt;$Text::Wrap::break&lt;/code&gt; 设置为不吃任何字符的正则表达式（也许只是一个前瞻性的断言）会引起警告。</target>
        </trans-unit>
        <trans-unit id="7fe767cd6ad41a1bf2749df0593b7a56afc9ca68" translate="yes" xml:space="preserve">
          <source>It is possible to create a &quot;circular reference&quot; in Perl, which can lead to memory leaks. A circular reference occurs when two references contain a reference to each other, like this:</source>
          <target state="translated">在Perl中可以创建一个 &quot;循环引用&quot;,这可能会导致内存泄漏。当两个引用包含一个相互引用时,就会出现循环引用,就像这样。</target>
        </trans-unit>
        <trans-unit id="c791c22192baa95a06c328176e1b85eddd8c69ea" translate="yes" xml:space="preserve">
          <source>It is possible to determine which character set you are operating under. But first you need to be really really sure you need to do this. Your code will be simpler and probably just as portable if you don't have to test the character set and do different things, depending. There are actually only very few circumstances where it's not easy to write straight-line code portable to all character sets. See &lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;Unicode and EBCDIC in perluniintro&lt;/a&gt; for how to portably specify characters.</source>
          <target state="translated">可以确定要使用的字符集。但是首先，您必须非常确定要执行此操作。如果您不必测试字符集并执行其他操作（取决于具体情况），您的代码将更加简单，并且可能具有可移植性。实际上，在极少数情况下，编写可移植到所有字符集的直线代码并不容易。有关如何可移植地指定字符，请参见&lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;perluniintro中的Unicode和EBCDIC&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0813f66fef4fb95209b9bd5234a37222cb817c4" translate="yes" xml:space="preserve">
          <source>It is possible to explicitly call a parent method from a child:</source>
          <target state="translated">可以从子方法中显式调用父方法。</target>
        </trans-unit>
        <trans-unit id="d19734113aaf232e977540f9be066f896f4d50e8" translate="yes" xml:space="preserve">
          <source>It is possible to get special treatment for a lone dash. This can be achieved by adding an option specification with an empty name, for example:</source>
          <target state="translated">可以对孤零零的破折号进行特殊处理。这可以通过添加一个空名的选项规范来实现,例如。</target>
        </trans-unit>
        <trans-unit id="484490759459d1a463406a9ec978f4abc6c5898b" translate="yes" xml:space="preserve">
          <source>It is possible to inspect both the string given to RE engine and the resulting finite automaton. See the arguments &lt;code&gt;debug&lt;/code&gt; /&lt;code&gt;debugcolor&lt;/code&gt; in the &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; pragma, as well as Perl's &lt;b&gt;-Dr&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;Command Switches in perlrun&lt;/a&gt;.</source>
          <target state="translated">既可以检查提供给RE引擎的字符串，也可以检查生成的有限自动机。参见参数 &lt;code&gt;debug&lt;/code&gt; / &lt;code&gt;debugcolor&lt;/code&gt; 在 &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; 编译，以及Perl的&lt;b&gt;-Dr&lt;/b&gt;中记录的命令行开关&lt;a href=&quot;perlrun#Command-Switches&quot;&gt;命令开关在perlrun&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4987e0746709787de44b276c954d3dc160982cc" translate="yes" xml:space="preserve">
          <source>It is possible to intermix print()s with write()s on the same output channel, but you'll have to handle &lt;code&gt;$-&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt; ) yourself.</source>
          <target state="translated">可以在同一输出通道上将print（）与write（）混合在一起，但是您必须自己处理 &lt;code&gt;$-&lt;/code&gt; （ &lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8fe4bd11a84db5fbf18822129f597065dac28979" translate="yes" xml:space="preserve">
          <source>It is possible to make &lt;code&gt;NEXT&lt;/code&gt; redispatch more demandingly (i.e. like &lt;code&gt;SUPER&lt;/code&gt; does), so that the redispatch throws an exception if it cannot find a &quot;next&quot; method to call.</source>
          <target state="translated">可以使 &lt;code&gt;NEXT&lt;/code&gt; 重新分配的要求更高（例如，像 &lt;code&gt;SUPER&lt;/code&gt; 一样），以便重新分配无法找到要调用的&amp;ldquo;下一个&amp;rdquo;方法时引发异常。</target>
        </trans-unit>
        <trans-unit id="41c5e618b60091d8c922ad7e0e5ebbcfaa2cb4df" translate="yes" xml:space="preserve">
          <source>It is possible to manually set &lt;code&gt;@ISA&lt;/code&gt; , and you may see this in older Perl code. Much older code also uses the &lt;a href=&quot;base&quot;&gt;base&lt;/a&gt; pragma. For new code, we recommend that you use the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma to declare your parents. This pragma will take care of setting &lt;code&gt;@ISA&lt;/code&gt; . It will also load the parent classes and make sure that the package doesn't inherit from itself.</source>
          <target state="translated">可以手动设置 &lt;code&gt;@ISA&lt;/code&gt; ，并且您可能会在较早的Perl代码中看到它。许多较旧的代码也使用&lt;a href=&quot;base&quot;&gt;基本的&lt;/a&gt;编译指示。对于新代码，我们建议您使用&lt;a href=&quot;parent&quot;&gt;父级&lt;/a&gt;编译指示来声明您的父级。此实用程序将负责设置 &lt;code&gt;@ISA&lt;/code&gt; 。它还将加载父类，并确保该包不会从其自身继承。</target>
        </trans-unit>
        <trans-unit id="0bf520fb97ddb7d66d056d630c6c0c7c679c7af2" translate="yes" xml:space="preserve">
          <source>It is possible to omit some or all of the final 4 parameters in the call to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; and let them take default values. As DB_HASH is the most common file format used, the call:</source>
          <target state="translated">可以在 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用中省略最后4个参数中的部分或全部，并让它们采用默认值。由于DB_HASH是最常用的文件格式，因此调用：</target>
        </trans-unit>
        <trans-unit id="03c72d0292032af6dedc904ed64f2438fc661321" translate="yes" xml:space="preserve">
          <source>It is possible to provide aliases that will be displayed in place of the test name by supplying the test as a reference to an array containing &lt;code&gt;[ $test, $alias ]&lt;/code&gt; :</source>
          <target state="translated">通过提供测试作为对包含 &lt;code&gt;[ $test, $alias ]&lt;/code&gt; 的数组的引用，可以提供将代替测试名称显示的别名：</target>
        </trans-unit>
        <trans-unit id="25625bc71a3769321141057e7fb45e78f8f3581c" translate="yes" xml:space="preserve">
          <source>It is possible to replace such an alphanumeric name with an expression that returns a reference to the appropriate type. For a description of this, see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">可以使用返回对适当类型的引用的表达式替换此类字母数字名称。有关此内容的描述，请参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f8a33f0d5f0df1acec3703c5fa0463900e9dcf6" translate="yes" xml:space="preserve">
          <source>It is possible to return a modifiable value from a subroutine. To do this, you have to declare the subroutine to return an lvalue.</source>
          <target state="translated">可以从一个子程序中返回一个可修改的值。要做到这一点,你必须声明子程序要返回一个l值。</target>
        </trans-unit>
        <trans-unit id="deb2736fd66852d74a632f14d09ceb41fcda537d" translate="yes" xml:space="preserve">
          <source>It is possible to stack multiple here-docs in a row:</source>
          <target state="translated">可以连续堆叠多个here-doc。</target>
        </trans-unit>
        <trans-unit id="3f9957642dc32b5a7c0c0eefbd7b6c39d5efef50" translate="yes" xml:space="preserve">
          <source>It is possible to strip the EXEs and DLLs created by the build process. The resulting binaries will be significantly smaller. If you want the binaries to be stripped, you can either add a &lt;b&gt;-s&lt;/b&gt; option when Configure prompts you,</source>
          <target state="translated">可以剥离由构建过程创建的EXE和DLL。生成的二进制文件将大大减小。如果您要删除二进制文件，则可以在配置提示您时添加&lt;b&gt;-s&lt;/b&gt;选项，</target>
        </trans-unit>
        <trans-unit id="0ddc0840c422187183750aec88a33c70a57206b1" translate="yes" xml:space="preserve">
          <source>It is possible to supply arguments to tests. To do so separate them from prove's own arguments with the arisdottle, '::'. For example</source>
          <target state="translated">可以为测试提供参数。要做到这一点,可以用 arisdottle,'::'将它们与 prove 自己的参数分开。例如</target>
        </trans-unit>
        <trans-unit id="aa6e659dc24039769282bd1c1079f9c11cd8c6ba" translate="yes" xml:space="preserve">
          <source>It is possible to write custom layers in addition to the above builtin ones, both in C/XS and Perl. Two such layers (and one example written in Perl using the latter) come with the Perl distribution.</source>
          <target state="translated">除了上述内置的层之外,还可以用C/XS和Perl编写自定义层。在Perl发行版中,有两个这样的图层(还有一个用Perl编写的例子)。</target>
        </trans-unit>
        <trans-unit id="af11e539efd7b5740f9d5c0eba044f8aebf92a4a" translate="yes" xml:space="preserve">
          <source>It is possible to write:</source>
          <target state="translated">可以写。</target>
        </trans-unit>
        <trans-unit id="0b89c8d09aeaea53d5ae118db445020ec34e8b36" translate="yes" xml:space="preserve">
          <source>It is probably useful only when combined with &lt;code&gt;(?{})&lt;/code&gt; or &lt;code&gt;(??{})&lt;/code&gt; .</source>
          <target state="translated">仅当与 &lt;code&gt;(?{})&lt;/code&gt; 或 &lt;code&gt;(??{})&lt;/code&gt; 结合使用时，它才有用。</target>
        </trans-unit>
        <trans-unit id="cf00d26aa745eb3ee05b04278f9eed1956a14d27" translate="yes" xml:space="preserve">
          <source>It is proposed to change this behavior in a future release of Perl so that whether or not Unicode rules are in effect would not change the behavior: Outside of locale, the POSIX classes would behave like their ASCII-range counterparts. If you wish to comment on this proposal, send email to &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; .</source>
          <target state="translated">建议在Perl的将来版本中更改此行为，以使Unicode规则是否有效都不会更改该行为：在区域设置之外，POSIX类的行为类似于其ASCII范围的对应对象。如果您想对此建议发表评论，请发送电子邮件至 &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6c7a14017f055e8f9bd10d510eabf5bf071a9ca" translate="yes" xml:space="preserve">
          <source>It is recommended that for this usage you put the DEFINE block at the end of the pattern, and that you name any subpatterns defined within it.</source>
          <target state="translated">建议在这种情况下,将DEFINE块放在模式的结尾,并命名其中定义的任何子模式。</target>
        </trans-unit>
        <trans-unit id="b57d669e4107366ea65426a960e0887b522f0627" translate="yes" xml:space="preserve">
          <source>It is recommended that you enable this option unless you really need to create a non-standard Zip file.</source>
          <target state="translated">建议你启用这个选项,除非你真的需要创建一个非标准的Zip文件。</target>
        </trans-unit>
        <trans-unit id="fe9f6b9b410e95d779e30fb9ae34ddfb1f7f1185" translate="yes" xml:space="preserve">
          <source>It is reported that the following archives contain enough utils to build perl:</source>
          <target state="translated">据悉,以下档案包含了足够的实用程序来构建perl。</target>
        </trans-unit>
        <trans-unit id="eb8af118e1b3c0f503fae4e488d7355647e3de10" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that applications using Opcode should use a leading capital letter on their tag names since lowercase names are reserved for use by the Opcode module. If using Opcode within a module you should prefix your tags names with the name of your module to ensure uniqueness and thus avoid clashes with other modules.</source>
          <target state="translated">强烈建议使用Opcode的应用程序应该在他们的标签名上使用大写字母,因为小写字母的名字是保留给Opcode模块使用的。如果在一个模块中使用Opcode,您应该在您的标签名称前加上您的模块名称,以确保唯一性,从而避免与其他模块发生冲突。</target>
        </trans-unit>
        <trans-unit id="2739f66ac90ce9cc53c7717d098a81a175c0dbe7" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you enable threads via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; as early as possible in your script.</source>
          <target state="translated">强烈建议您在脚本中尽早通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 来启用线程。</target>
        </trans-unit>
        <trans-unit id="23330295b88e2dfe22f823906399d30b69678a8c" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you use this flag when you run Configure. If you do not do this, but later answer the question about large files when Configure asks you, you may get a configuration that cannot be compiled, or that does not function as expected.</source>
          <target state="translated">强烈建议您在运行Configure时使用该标志。如果您不这样做,但后来在Configure询问您有关大文件的问题时回答了这个问题,您可能会得到一个无法编译的配置,或者无法按照预期的方式运行。</target>
        </trans-unit>
        <trans-unit id="d4398ad9975e0145dd25fc7bc9a7058eb6696304" translate="yes" xml:space="preserve">
          <source>It is suggested that you enable the version of malloc that is distributed with Perl. It keeps pools of various sizes of unallocated memory in order to satisfy allocation requests more quickly. However, on some platforms, it may cause spurious malloc or free errors.</source>
          <target state="translated">建议你启用随 Perl 发行的 malloc 版本。它保留了不同大小的未分配内存池,以便更快地满足分配请求。然而,在某些平台上,它可能会导致虚假的malloc或free错误。</target>
        </trans-unit>
        <trans-unit id="09d04d7278d56b78f672ffa08fd362fe3b4bb9cb" translate="yes" xml:space="preserve">
          <source>It is the appropriate method to use if you need to get the name of a lexical variable from a padname array. Lexical variable names are always stored with a null terminator, and the length field (CUR) is overloaded for other purposes and can't be relied on here.</source>
          <target state="translated">如果你需要从padname数组中获取一个词法变量的名称,那么这是一个合适的方法。词法变量的名称总是以null结束符存储,长度字段(CUR)因为其他目的而被重载,在这里不能依靠它。</target>
        </trans-unit>
        <trans-unit id="6f04d78fbcc86fbb7196577b1692934e2955d725" translate="yes" xml:space="preserve">
          <source>It is therefore strongly recommended that these macros be used by all XS modules that make use of static data.</source>
          <target state="translated">因此,强烈建议所有使用静态数据的XS模块都使用这些宏。</target>
        </trans-unit>
        <trans-unit id="6ddce18b6b5d6c4ef9a5cf7c34f05793b72112fd" translate="yes" xml:space="preserve">
          <source>It is typically used to add extra directories to perl's search path so that later &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statements will find modules which are not located on perl's default search path.</source>
          <target state="translated">它通常用于在perl的搜索路径中添加额外的目录，以便以后 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 语句将查找不在perl的默认搜索路径中的模块。</target>
        </trans-unit>
        <trans-unit id="1a7559da192e0561816f87fb94aa112a7e9ecc6d" translate="yes" xml:space="preserve">
          <source>It is up to individual Pod formatter to display good judgement when confronted with an unrenderable character (which is distinct from an unknown E&amp;lt;thing&amp;gt; sequence that the parser couldn't resolve to anything, renderable or not). It is good practice to map Latin letters with diacritics (like &quot;E&amp;lt;eacute&amp;gt;&quot;/&quot;E&amp;lt;233&amp;gt;&quot;) to the corresponding unaccented US-ASCII letters (like a simple character 101, &quot;e&quot;), but clearly this is often not feasible, and an unrenderable character may be represented as &quot;?&quot;, or the like. In attempting a sane fallback (as from E&amp;lt;233&amp;gt; to &quot;e&quot;), Pod formatters may use the %Latin1Code_to_fallback table in &lt;a href=&quot;pod/escapes&quot;&gt;Pod::Escapes&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Unidecode&quot;&gt;Text::Unidecode&lt;/a&gt;, if available.</source>
          <target state="translated">遇到无法渲染的字符（与解析器无法解析为任何东西（无论是否可渲染）的未知E &amp;lt;thing&amp;gt;序列不同）时，由个人Pod格式化程序显示良好的判断。将带有变音符号的拉丁字母（例如&amp;ldquo; E &amp;lt;eacute&amp;gt;&amp;rdquo; /&amp;ldquo; E &amp;lt;233&amp;gt;&amp;rdquo;）映射到相应的未重音US-ASCII字母（例如简单字符101，&amp;ldquo; e&amp;rdquo;）是一种很好的做法，但这显然是通常无法实现，并且不可呈现的字符可以表示为&amp;ldquo;？&amp;rdquo;等。在尝试进行合理的回退时（从E &amp;lt;233&amp;gt;到&amp;ldquo; e&amp;rdquo;），Pod格式化程序可以使用&lt;a href=&quot;pod/escapes&quot;&gt;Pod :: Escapes&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Unidecode&quot;&gt;Text :: Unidecode中&lt;/a&gt;的％Latin1Code_to_fallback表（如果有）。</target>
        </trans-unit>
        <trans-unit id="d3fe171c1e178608bc5f92e9c9efc16598ce4a39" translate="yes" xml:space="preserve">
          <source>It is up to you to use this information to populate</source>
          <target state="translated">您可以使用这些信息来填报</target>
        </trans-unit>
        <trans-unit id="ce530e54cb38df50f2b9795b42ad1b0802239f94" translate="yes" xml:space="preserve">
          <source>It is usual to pass parameters using global variables (typically $_ for one parameter, or $a and $b for two parameters) rather than via @_. (It is possible to use the @_ mechanism if you know what you're doing, though there is as yet no supported API for it. It's also inherently slower.)</source>
          <target state="translated">通常使用全局变量传递参数(通常$_代表一个参数,或者$a和$b代表两个参数),而不是通过@_。(如果你知道自己在做什么,也可以使用@_机制,尽管目前还没有支持的API。它本身也比较慢)。)</target>
        </trans-unit>
        <trans-unit id="69c5d14186ab57b1e0629e917b8215f824fb1b8c" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; may be internally implemented on your system with &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">混入 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 呼叫通常是一个错误，因为 &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 可能是在系统内部使用 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 实施的。</target>
        </trans-unit>
        <trans-unit id="18d1691040dfd4fd0aeb2ca9801dad0c1249aa8e" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; may be internally implemented on your system with &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">混入 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 呼叫通常是一个错误，因为 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 可能是在系统内部使用 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 实施的。</target>
        </trans-unit>
        <trans-unit id="f94317c7d8a68b955ef8fad7379f1f684a3e243d" translate="yes" xml:space="preserve">
          <source>It is usually impossible to add new syntax to Perl without breaking some existing programs. This pragma provides a way to minimize that risk. New syntactic constructs, or new semantic meanings to older constructs, can be enabled by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'foo'&lt;/code&gt; , and will be parsed only when the appropriate feature pragma is in scope. (Nevertheless, the &lt;code&gt;CORE::&lt;/code&gt; prefix provides access to all Perl keywords, regardless of this pragma.)</source>
          <target state="translated">在不破坏某些现有程序的情况下，通常不可能向Perl添加新语法。这种实用性提供了一种将风险最小化的方法。可以通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'foo'&lt;/code&gt; 启用新的句法构造或旧构造的新语义，并且仅当适当的功能用法在范围内时才进行解析。（尽管如此，使用 &lt;code&gt;CORE::&lt;/code&gt; 前缀可以访问所有Perl关键字，而不管该编译指示如何。）</target>
        </trans-unit>
        <trans-unit id="60c64d5138091e34ac4e66a3176bc2904d419a6d" translate="yes" xml:space="preserve">
          <source>It is very common when filtering source to only want to apply the filter to the non-character-string parts of the code, or alternatively to</source>
          <target state="translated">在过滤源码时,通常只想将过滤器应用于代码中的非字符串部分,或者将其应用于</target>
        </trans-unit>
        <trans-unit id="7df1696685d7983c694bb3c5409a0395bf0e003f" translate="yes" xml:space="preserve">
          <source>It is very easy to dead-lock a process using this form of open(), or indeed with any use of pipe() with multiple subprocesses. The example above is &quot;safe&quot; because it is simple and calls exec(). See &lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;Avoiding Pipe Deadlocks&lt;/a&gt; for general safety principles, but there are extra gotchas with Safe Pipe Opens.</source>
          <target state="translated">使用这种形式的open（）或完全不使用带有多个子进程的pipe（）来死锁一个进程非常容易。上面的示例很&amp;ldquo;安全&amp;rdquo;，因为它很简单，并调用exec（）。有关一般安全原则，请参阅&lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;避免管道死锁&lt;/a&gt;，但是安全管道打开还有其他陷阱。</target>
        </trans-unit>
        <trans-unit id="1f2733d85a83af59b86ea7ca3eeb7a8a21d68e5a" translate="yes" xml:space="preserve">
          <source>It is very easy to get tripped up using a mixture of other programs, external utilities, and Perl scripts that are in varying states of being able to handle case preservation. For example, a file created by an older version of an archive utility or a build utility such as MMK or MMS may generate a filename in all upper case even on an ODS-5 volume. If this filename is later retrieved by a Perl script or module in a case preserving environment, that upper case name may not match the mixed-case or lower-case expectations of the Perl code. Your best bet is to follow an all-or-nothing approach to case preservation: either don't use it at all, or make sure your entire toolchain and application environment support and use it.</source>
          <target state="translated">在使用其他程序、外部工具和Perl脚本时很容易被绊倒,因为这些程序在处理大小写方面的状态各不相同。例如,一个由旧版本的归档工具或诸如MMK或MMS等构建工具创建的文件,即使在ODS-5卷上也可能生成一个全大写的文件名。如果这个文件名后来被Perl脚本或模块在保全大小写的环境中检索到,那么这个大写的文件名可能不符合Perl代码的混合大写或小写的要求。你最好的选择是遵循一种全有或全无的方法来处理大小写保留:要么完全不使用它,要么确保你的整个工具链和应用环境都支持并使用它。</target>
        </trans-unit>
        <trans-unit id="1057ac1e814cd9a3566a8fed96cf94293953ec7a" translate="yes" xml:space="preserve">
          <source>It is very easy to recover the source of Perl programs. You simply feed the program to the perl interpreter and use the modules in the B:: hierarchy. The B::Deparse module should be able to defeat most attempts to hide source. Again, this is not unique to Perl.</source>
          <target state="translated">恢复Perl程序的源码非常容易。你只需将程序送入 perl 解释器并使用 B::层次结构中的模块。B::Deparse 模块应该能够击败大多数隐藏源代码的尝试。同样,这也不是Perl所独有的。</target>
        </trans-unit>
        <trans-unit id="d5b6f5cbb4ab2d2416457262d0018311cb6ac8d2" translate="yes" xml:space="preserve">
          <source>It is very possible that this document will fall far short of being useful to the casual reader. The reader is expected to understand the material in the first few sections of &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">该文档很有可能远远不够对临时读者有用。希望读者了解&lt;a href=&quot;../perlguts&quot;&gt;Perlguts&lt;/a&gt;的前几节中的内容。</target>
        </trans-unit>
        <trans-unit id="5424072f53b20136acc827f23a7b8403963d2596" translate="yes" xml:space="preserve">
          <source>It is worth drawing particular attention to the expected ranges for the values provided. The value for the day of the month is the actual day (ie 1..31), while the month is the number of months since January (0..11). This is consistent with the values returned from &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">值得特别注意所提供值的预期范围。月中某天的值是实际日期（即1..31），而月中该值是自一月以来的月数（0..11）。这与从 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 返回的值一致。</target>
        </trans-unit>
        <trans-unit id="c12cfe0a130e1abce3e789227eb445dc3d70c311" translate="yes" xml:space="preserve">
          <source>It is worth emphasizing that &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , etc, match single characters, not complete numbers or words. To match a number (that consists of digits), use &lt;code&gt;\d+&lt;/code&gt; ; to match a word, use &lt;code&gt;\w+&lt;/code&gt; . But be aware of the security considerations in doing so, as mentioned above.</source>
          <target state="translated">值得强调的是 &lt;code&gt;\d&lt;/code&gt; ， &lt;code&gt;\w&lt;/code&gt; 等匹配单个字符，而不是完整的数字或单词。要匹配数字（由数字组成），请使用 &lt;code&gt;\d+&lt;/code&gt; ；要匹配单词，请使用 &lt;code&gt;\w+&lt;/code&gt; 。但是，如上所述，请注意这样做的安全性注意事项。</target>
        </trans-unit>
        <trans-unit id="78ab6d3ec3a28b829b407073297587d950173f49" translate="yes" xml:space="preserve">
          <source>It is worth noting that &lt;code&gt;\G&lt;/code&gt; improperly used can result in an infinite loop. Take care when using patterns that include &lt;code&gt;\G&lt;/code&gt; in an alternation.</source>
          <target state="translated">值得注意的是 &lt;code&gt;\G&lt;/code&gt; 使用不当会导致无限循环。使用交替包含 &lt;code&gt;\G&lt;/code&gt; 模式时要小心。</target>
        </trans-unit>
        <trans-unit id="db9514e6a01f9d85b4ef7b0e350a06b34e756aba" translate="yes" xml:space="preserve">
          <source>It is worth stressing that there are several different sets of digits in Unicode that are equivalent to 0-9 and are matchable by &lt;code&gt;\d&lt;/code&gt; in a regular expression. If they are used in a single language only, they are in that language's &lt;code&gt;Script&lt;/code&gt; and &lt;code&gt;Script_Extension&lt;/code&gt; . If they are used in more than one script, they will be in &lt;code&gt;sc=Common&lt;/code&gt; , but only if they are used in many scripts should they be in &lt;code&gt;scx=Common&lt;/code&gt; .</source>
          <target state="translated">值得强调的是，Unicode中有几个不同的数字集，它们等效于0-9，并且可以在正则表达式中与 &lt;code&gt;\d&lt;/code&gt; 匹配。如果仅使用一种语言，则使用该语言的 &lt;code&gt;Script&lt;/code&gt; 和 &lt;code&gt;Script_Extension&lt;/code&gt; 。如果在多个脚本中使用它们，则它们将在 &lt;code&gt;sc=Common&lt;/code&gt; 中使用，但只有在许多脚本中使用它们时，才应在 &lt;code&gt;scx=Common&lt;/code&gt; 中使用它们。</target>
        </trans-unit>
        <trans-unit id="bb73a60f536c984fec748fd56250217ac857070f" translate="yes" xml:space="preserve">
          <source>It is, after all, just a guess. You should alway be explicit when it comes to encodings. But there are some, especially Japanese, environment that guess-coding is a must. Use this module with care.</source>
          <target state="translated">毕竟,这只是一个猜测。在编码的时候,你总是应该明确。但在某些环境下,尤其是日语,猜测编码是必须的。请谨慎使用这个模块。</target>
        </trans-unit>
        <trans-unit id="b1fd4c29544df6031e0c7f381c345fa955c2ddef" translate="yes" xml:space="preserve">
          <source>It is, however, very simple, pure Perl, and it has no non-core dependencies. It also provides a &quot;Moose-like&quot; API on demand for the features it supports.</source>
          <target state="translated">不过,它非常简单,是纯粹的Perl,而且它没有非核心的依赖。它还为它支持的功能提供了一个 &quot;类似于Moose &quot;的按需API。</target>
        </trans-unit>
        <trans-unit id="358ba9c90802ce677d93df629a1697c0599e5843" translate="yes" xml:space="preserve">
          <source>It isn't possible to create a true reference to an IO handle (filehandle or dirhandle) using the backslash operator. The most you can get is a reference to a typeglob, which is actually a complete symbol table entry. But see the explanation of the &lt;code&gt;*foo{THING}&lt;/code&gt; syntax below. However, you can still use type globs and globrefs as though they were IO handles.</source>
          <target state="translated">使用反斜杠运算符无法创建对IO句柄（文件句柄或dirhandle）的真实引用。您所能获得的最多是对typeglob的引用，它实际上是完整的符号表条目。但是请参阅下面的 &lt;code&gt;*foo{THING}&lt;/code&gt; 语法说明。但是，您仍然可以像使用IO句柄一样使用类型的globs和globrefs。</target>
        </trans-unit>
        <trans-unit id="be4ec9fbbf231e40204d7019d3f997c286ceaaf0" translate="yes" xml:space="preserve">
          <source>It lets by &lt;code&gt;$(...)&lt;/code&gt;.</source>
          <target state="translated">它可以让用 &lt;code&gt;$(...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1272cce995365257b29707c07e056e98c158a0d6" translate="yes" xml:space="preserve">
          <source>It may also be useful to create a batch file called lib.bat in C:\Program Files\Microsoft Visual C++ Toolkit 2003\bin containing:</source>
          <target state="translated">在C://Program Files/Microsoft Visual C++Toolkit 2003/bin中创建一个名为lib.bat的批处理文件也可能是有用的,其中包含。</target>
        </trans-unit>
        <trans-unit id="c3ee59300b49b89fa621ccf66f9ee189105bf2cd" translate="yes" xml:space="preserve">
          <source>It may also indicate a misspelled constant that has been interpreted as a bareword:</source>
          <target state="translated">它也可能表示一个拼写错误的常量,被解释为一个裸词。</target>
        </trans-unit>
        <trans-unit id="3d71937f4e01c4691f8ad6115319d1b1a1cc17dc" translate="yes" xml:space="preserve">
          <source>It may be handy to add a function or method to retrieve the number. Use the number in announcements and archive file names when releasing the module (ModuleName-1.02.tar.Z). See perldoc ExtUtils::MakeMaker.pm for details.</source>
          <target state="translated">添加一个函数或方法来检索这个数字可能会很方便。当发布模块时,在公告和归档文件名中使用这个编号(ModuleName-1.02.tar.Z)。详情请参见 perldoc ExtUtils::MakeMaker.pm。</target>
        </trans-unit>
        <trans-unit id="4aba7fcd954a7d79c58b4c5db5fcca156f49cb64" translate="yes" xml:space="preserve">
          <source>It may be helpful to always use the forked debugger so that script I/O is separated from debugger I/O. You can force the debugger to be forked by assigning a value to the logical name &amp;lt;PERLDB_PIDS&amp;gt; that is not a process identification number.</source>
          <target state="translated">始终使用叉式调试器可能会有所帮助，以便将脚本I / O与调试器I / O分开。您可以通过为逻辑名称&amp;lt;PERLDB_PIDS&amp;gt;分配一个值而不是进程标识号来强制调试器派生。</target>
        </trans-unit>
        <trans-unit id="9cf5a525be6e13a9a7b1dd1dbd184cb474cd50ab" translate="yes" xml:space="preserve">
          <source>It may be more portable to use the &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt; module instead. You just copy to the new file to the new name (checking return values), then delete the old one. This isn't really the same semantically as a &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt;, which preserves meta-information like permissions, timestamps, inode info, etc.</source>
          <target state="translated">改为使用&lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt;模块更可移植。您只需将新文件复制到新名称（检查返回值），然后删除旧文件即可。从语义 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; ，这与rename（）并不完全相同，rename（）保留诸如权限，时间戳，inode信息等元信息。</target>
        </trans-unit>
        <trans-unit id="db6d5d1cd198cf53911efce9b9d95d5989e30fc0" translate="yes" xml:space="preserve">
          <source>It may be possible to code a simple workaround which would</source>
          <target state="translated">也许可以编写一个简单的变通方法,这样就可以做到</target>
        </trans-unit>
        <trans-unit id="2d1547ff72328148f73028b4bf53e65cca15e95b" translate="yes" xml:space="preserve">
          <source>It may be possible to use the Entropy Gathering Daemon (written in Perl!), available from &lt;a href=&quot;http://www.lothar.com/tech/crypto/&quot;&gt;http://www.lothar.com/tech/crypto/&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;http://www.lothar.com/tech/crypto/&quot;&gt;http://www.lothar.com/tech/crypto/上&lt;/a&gt;的Entropy Gathering Daemon（用Perl！编写）。</target>
        </trans-unit>
        <trans-unit id="ea7e33e821e865ae246a0ffae0bdba930182de6b" translate="yes" xml:space="preserve">
          <source>It may seem obvious to say, but Perl is useful only when users can easily find it. When possible, it's good for both</source>
          <target state="translated">说起来似乎很明显,但Perl只有在用户能很容易找到它的时候才有用。在可能的情况下,它对以下两方面都有好处</target>
        </trans-unit>
        <trans-unit id="fd3430c5befbd819886aa0fff01863d985392126" translate="yes" xml:space="preserve">
          <source>It might conceivably chdir() you out of a directory that it can't chdir() you back into. If fastcwd encounters a problem it will return undef but will probably leave you in a different directory. For a measure of extra security, if everything appears to have worked, the fastcwd() function will check that it leaves you in the same directory that it started in. If it has changed it will &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with the message &quot;Unstable directory path, current directory changed unexpectedly&quot;. That should never happen.</source>
          <target state="translated">可以想象，它会将您chdir（）移出无法chdir（）的目录。如果fastcwd遇到问题，它将返回undef，但可能会将您留在其他目录中。为了提高安全性，如果一切正常，fastcwd（）函数将检查是否将您留在了开始时所在的目录中。如果更改，它将 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 消息&amp;ldquo;不稳定的目录路径，当前目录意外更改&amp;rdquo;。那永远不会发生。</target>
        </trans-unit>
        <trans-unit id="106694ead18b1135cc07d2ae597d50b20a4d8af6" translate="yes" xml:space="preserve">
          <source>It must be stressed that the DynaLoader, by itself, is practically useless for accessing non-Perl libraries because it provides almost no Perl-to-C 'glue'. There is, for example, no mechanism for calling a C library function or supplying arguments. A C::DynaLib module is available from CPAN sites which performs that function for some common system types. And since the year 2000, there's also Inline::C, a module that allows you to write Perl subroutines in C. Also available from your local CPAN site.</source>
          <target state="translated">必须强调的是,DynaLoader本身在访问非Perl库时实际上是无用的,因为它几乎没有提供Perl到C库的 &quot;胶合&quot;。例如,没有调用C库函数或提供参数的机制。在CPAN网站上有一个C::DynaLib模块,它可以为一些常见的系统类型执行该功能。自 2000 年以来,还有 Inline::C,一个允许你用 C 写 Perl 子程序的模块,也可以从本地 CPAN 站点获得。</target>
        </trans-unit>
        <trans-unit id="04aa081b59ff3888239972218e3f56b3b6581f1f" translate="yes" xml:space="preserve">
          <source>It particular, it's important to &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize $_ in any routine that assigns to it. Look out for implicit assignments in &lt;code&gt;while&lt;/code&gt; conditionals.</source>
          <target state="translated">尤其重要的是，在分配给它的任何例程中 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; $ _。在 &lt;code&gt;while&lt;/code&gt; 条件中查找隐式赋值。</target>
        </trans-unit>
        <trans-unit id="cd14db27f979e38e1e8d4c1576f9b693597877fa" translate="yes" xml:space="preserve">
          <source>It performs the following actions:</source>
          <target state="translated">它执行以下行动:</target>
        </trans-unit>
        <trans-unit id="3a77cf9922a9fef0374667dd7650f3414798d318" translate="yes" xml:space="preserve">
          <source>It prints (without so many line breaks)</source>
          <target state="translated">它可以打印(没有那么多换行符)。</target>
        </trans-unit>
        <trans-unit id="f4bd0cc34b746267dc944192fe3c01787ec4e363" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder since print calls &lt;code&gt;bdiv()&lt;/code&gt; in list context. Also, &lt;code&gt;bdiv()&lt;/code&gt; will modify $c, so be careful. You probably want to use</source>
          <target state="translated">因为print 在列表上下文中调用 &lt;code&gt;bdiv()&lt;/code&gt; ，所以它同时打印商和余数。另外， &lt;code&gt;bdiv()&lt;/code&gt; 会修改$ c，因此要小心。您可能要使用</target>
        </trans-unit>
        <trans-unit id="eeeedb6aa3743486c6e5b956ff78abba71960946" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder since print works in list context. Also, bdiv() will modify $c, so be careful. You probably want to use</source>
          <target state="translated">它同时打印商和余数,因为print在列表上下文中工作。另外,bdiv()会修改 $c,所以要小心。你可能想使用</target>
        </trans-unit>
        <trans-unit id="f734db0d61221ca40b0fe2bebce3caa4e0b18089" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder, since print calls &lt;code&gt;brsft()&lt;/code&gt; in list context. Also, &lt;code&gt;$c-&amp;gt;brsft()&lt;/code&gt; will modify $c, so be careful. You probably want to use</source>
          <target state="translated">因为print 在列表上下文中调用 &lt;code&gt;brsft()&lt;/code&gt; ，所以它同时打印商和余数。另外， &lt;code&gt;$c-&amp;gt;brsft()&lt;/code&gt; 会修改$ c，因此要小心。您可能要使用</target>
        </trans-unit>
        <trans-unit id="ce7853179bda4d7415dfcdbc4fb24a48d915ca39" translate="yes" xml:space="preserve">
          <source>It prints both the number of digits in the number and in the fraction part since print calls &lt;code&gt;&lt;a href=&quot;../functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; in list context. Use something like:</source>
          <target state="translated">因为print 在列表上下文中调用 &lt;code&gt;&lt;a href=&quot;../functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; ，所以它同时打印数字和小数部分中的数字。使用类似：</target>
        </trans-unit>
        <trans-unit id="29cdbd5e538c2f505e08e3d1eef02e06fd63d99d" translate="yes" xml:space="preserve">
          <source>It prints the sequence number of each subroutine call and the name of the called subroutine. Note that &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; is being compiled into the package &lt;code&gt;DB&lt;/code&gt; through the use of the &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; directive.</source>
          <target state="translated">它打印每个子例程调用的序列号和被调用子例程的名称。请注意，正在通过使用 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 指令将 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 编译到Package &lt;code&gt;DB&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="1eb15b033b8c4d79b1e008f6b581eebb8e9cf4d5" translate="yes" xml:space="preserve">
          <source>It provides a number of mechanisms for querying this information.</source>
          <target state="translated">它提供了一些查询这些信息的机制。</target>
        </trans-unit>
        <trans-unit id="b8c1724bc25d41f7c44c94651a6709f709b79e5f" translate="yes" xml:space="preserve">
          <source>It provides default implementations for the methods</source>
          <target state="translated">它提供了以下方法的默认实现</target>
        </trans-unit>
        <trans-unit id="991237cf5d3fbec5f0d4f7d308f07d6c33c5c843" translate="yes" xml:space="preserve">
          <source>It rarely happens, but sometimes a harness might encounter 'missing tests:</source>
          <target state="translated">这种情况很少发生,但有时线束可能会遇到 &quot;漏测&quot;。</target>
        </trans-unit>
        <trans-unit id="58b94065e144f3ae0a0ee1916ab6d2ce54ccb558" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property Comp_Ex (Full_Composition_Exclusion). This property is generated from Composition Exclusions + Singletons + Non-Starter Decompositions.</source>
          <target state="translated">它返回派生属性Comp_Ex (Full_Composition_Exclusion)的布尔值。这个属性是由组成排除+单子+非启动分解生成的。</target>
        </trans-unit>
        <trans-unit id="2104ee6f115c01f93c99709b67d509e11442417d" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFC_MAYBE (NFC_Quick_Check=Maybe).</source>
          <target state="translated">它返回派生属性NFC_MAYBE(NFC_Quick_Check=Maybe)的布尔值。</target>
        </trans-unit>
        <trans-unit id="8eddd31c0562defd83827f48a88a17884adf60ac" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFC_NO (NFC_Quick_Check=No).</source>
          <target state="translated">它返回派生属性NFC_NO (NFC_Quick_Check=No)的布尔值。</target>
        </trans-unit>
        <trans-unit id="5a5415660523b78bb56fd5e9c17b5e348185ce86" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFD_NO (NFD_Quick_Check=No).</source>
          <target state="translated">它返回派生属性NFD_NO (NFD_Quick_Check=No)的布尔值。</target>
        </trans-unit>
        <trans-unit id="670fe547c9b7a29b855ab5f7d41534d43d1e9f4c" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKC_MAYBE (NFKC_Quick_Check=Maybe).</source>
          <target state="translated">它返回派生属性NFKC_MAYBE (NFKC_Quick_Check=Maybe)的布尔值。</target>
        </trans-unit>
        <trans-unit id="904cbf02d71113df93de970071185a11138630e4" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKC_NO (NFKC_Quick_Check=No).</source>
          <target state="translated">它返回派生属性NFKC_NO (NFKC_Quick_Check=No)的布尔值。</target>
        </trans-unit>
        <trans-unit id="829ea5ef8a5200c844ee7c02042a32bc63c04771" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKD_NO (NFKD_Quick_Check=No).</source>
          <target state="translated">它返回派生属性NFKD_NO(NFKD_Quick_Check=No)的布尔值。</target>
        </trans-unit>
        <trans-unit id="8784205d909df0b9a984780fc90733905a3103a1" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the character of the specified codepoint may be composed with the previous one in a certain composition (including Hangul Compositions, but excluding Composition Exclusions and Non-Starter Decompositions).</source>
          <target state="translated">它返回一个布尔值,表示在某种构图(包括汉字构图,但不包括构图排除和非起始分解)中,指定码点的字符是否可以与前一个码点进行构图。</target>
        </trans-unit>
        <trans-unit id="32fdbc7eddb18b1a419ce2d35092783f07d4af22" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point has Non-Starter Decomposition.</source>
          <target state="translated">它返回代码点是否具有非启动分解的布尔值。</target>
        </trans-unit>
        <trans-unit id="05cafc23e99e3bc76eb241d5b7b7627390e2da71" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point is a composition exclusion.</source>
          <target state="translated">它返回一个布尔值,是否该代码点是一个组成排除。</target>
        </trans-unit>
        <trans-unit id="53705043824b274a980c94b9c5b624aa7db18ac7" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point is a singleton</source>
          <target state="translated">它返回一个布尔值,即该代码点是否是一个单体。</target>
        </trans-unit>
        <trans-unit id="3bdd6ab415e1d7803474768a9f82c375da3c7e8f" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$Bzip2Error&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功返回 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 对象，失败返回undef。变量 &lt;code&gt;$Bzip2Error&lt;/code&gt; 将包含有关失败的错误消息。</target>
        </trans-unit>
        <trans-unit id="7b202b09f5eedc56f3eae8328563e18bb8bb267b" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$DeflateError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功时返回 &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 对象，失败时返回undef。变量 &lt;code&gt;$DeflateError&lt;/code&gt; 将包含有关失败的错误消息。</target>
        </trans-unit>
        <trans-unit id="0d7bf22968af56755cc48cf3e5eb1866df93fb4a" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$GzipError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功返回 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 对象，失败返回undef。变量 &lt;code&gt;$GzipError&lt;/code&gt; 将包含有关失败的错误消息。</target>
        </trans-unit>
        <trans-unit id="e02c10ad441b5cb12d98ff7ac04d2bec29b76002" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$RawDeflateError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功时返回 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 对象，失败时返回undef。变量 &lt;code&gt;$RawDeflateError&lt;/code&gt; 将包含有关失败的错误消息。</target>
        </trans-unit>
        <trans-unit id="733e2aec8845350fd889ee56ce6b2b1905e8c50e" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Zip&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$ZipError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功返回 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 对象，失败返回undef。变量 &lt;code&gt;$ZipError&lt;/code&gt; 将包含有关失败的错误消息。</target>
        </trans-unit>
        <trans-unit id="55f5b32339878811a57c6c9adb8fddab3c155d6c" translate="yes" xml:space="preserve">
          <source>It returns an array of four or five scalar values: EXTRALIBS, BSLOADLIBS, LDLOADLIBS, LD_RUN_PATH, and, optionally, a reference to the array of the filenames of actual libraries. Some of these don't mean anything unless on Unix. See the details about those platform specifics below. The list of the filenames is returned only if $need_names argument is true.</source>
          <target state="translated">它返回一个由四个或五个标量值组成的数组。EXTRALIBS,BSLOADLIBS,LDLOADLIBS,LD_RUN_PATH,以及一个对实际库的文件名数组的引用。其中一些除非在Unix上,否则没有任何意义。请看下面关于这些平台的细节。只有当$need_names参数为true时,才会返回文件名列表。</target>
        </trans-unit>
        <trans-unit id="1b60723356123e31c4f819b7b57959bd345247e2" translate="yes" xml:space="preserve">
          <source>It returns falls if &lt;code&gt;PACKAGE&lt;/code&gt; has not been loaded yet and the location from where it is said to be loaded on success.</source>
          <target state="translated">如果尚未装入 &lt;code&gt;PACKAGE&lt;/code&gt; ，则返回跌落；如果成功装入PACKAGE，则返回该位置。</target>
        </trans-unit>
        <trans-unit id="ab042aac65d23a49c795444acd76a148a334187c" translate="yes" xml:space="preserve">
          <source>It returns the FCC form (&quot;Fast C Contiguous&quot;; cf. UTN #5).</source>
          <target state="translated">它返回FCC表格(&quot;Fast C Contiguous&quot;;参见UTN #5)。</target>
        </trans-unit>
        <trans-unit id="a80e6baf3c3b2c9535a05b4bf410d7b9c5dde971" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form C (formed by canonical decomposition followed by canonical composition).</source>
          <target state="translated">它返回归一化形式C(由规范分解后再由规范组成)。</target>
        </trans-unit>
        <trans-unit id="a2c5e52810047ee1962e46371ac68fc8dc9054e8" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form D (formed by canonical decomposition).</source>
          <target state="translated">它返回归一化形式D(由规范分解形成)。</target>
        </trans-unit>
        <trans-unit id="1383c6449aad07f7997fc3ec42b0ae3c98ca4a0b" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form KC (formed by compatibility decomposition followed by &lt;b&gt;canonical&lt;/b&gt; composition).</source>
          <target state="translated">它返回规范化形式KC（由兼容性分解和&lt;b&gt;规范&lt;/b&gt;组成组成）。</target>
        </trans-unit>
        <trans-unit id="1d675fdcf5ef1f2056866497e81d752934809791" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form KD (formed by compatibility decomposition).</source>
          <target state="translated">它返回归一化形式KD(由兼容性分解形成)。</target>
        </trans-unit>
        <trans-unit id="4b300118aa94b87649f21e9834526f64818158d8" translate="yes" xml:space="preserve">
          <source>It returns the combining class (as an integer) of the character.</source>
          <target state="translated">它返回字符的组合类(为整数)。</target>
        </trans-unit>
        <trans-unit id="eb22d3dace2d05fa601426312363eea62fa0226b" translate="yes" xml:space="preserve">
          <source>It returns the concatenation of the decomposition of each character in the string.</source>
          <target state="translated">它返回字符串中每个字符的分解连接。</target>
        </trans-unit>
        <trans-unit id="8a852534b28496d947f4c8e100a132748793361d" translate="yes" xml:space="preserve">
          <source>It returns the normalization form of &lt;code&gt;$form_name&lt;/code&gt; .</source>
          <target state="translated">它返回 &lt;code&gt;$form_name&lt;/code&gt; 的规范化形式。</target>
        </trans-unit>
        <trans-unit id="b49fbb316b9278a17d532265fe4cd4e754492934" translate="yes" xml:space="preserve">
          <source>It returns the remainder &lt;code&gt;$r = $x - $n*$y&lt;/code&gt; , where &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt; . The &lt;code&gt;$r&lt;/code&gt; has the same sign as &lt;code&gt;$x&lt;/code&gt; and magnitude (absolute value) less than the magnitude of &lt;code&gt;$y&lt;/code&gt; .</source>
          <target state="translated">它返回其余的 &lt;code&gt;$r = $x - $n*$y&lt;/code&gt; ，其中 &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt; 。该 &lt;code&gt;$r&lt;/code&gt; 具有相同的符号为 &lt;code&gt;$x&lt;/code&gt; 和大小（绝对值）小于幅度 &lt;code&gt;$y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="837e320b920fba38b4782fb970e5ba4d1738747b" translate="yes" xml:space="preserve">
          <source>It returns the result of canonical composition without applying any decomposition.</source>
          <target state="translated">它在不应用任何分解的情况下返回规范合成的结果。</target>
        </trans-unit>
        <trans-unit id="97c8ed595d7942de577ac5b60184bc3e70b57d00" translate="yes" xml:space="preserve">
          <source>It returns the result of reordering the combining characters according to Canonical Ordering Behavior.</source>
          <target state="translated">它返回根据 Canonical Ordering Behavior 对合并字符重新排序的结果。</target>
        </trans-unit>
        <trans-unit id="30e13862ba07278e0519e9e4b0230517dc0328cb" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt; ) if &lt;code&gt;YES&lt;/code&gt; ; false (&lt;code&gt;empty string&lt;/code&gt; ) if &lt;code&gt;NO&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;YES&lt;/code&gt; ，则返回true（ &lt;code&gt;1&lt;/code&gt; ）; 如果为 &lt;code&gt;NO&lt;/code&gt; ,则返回false（ &lt;code&gt;empty string&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b1aae34c500721c408b0788928293058d1fef3fa" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt; ) if &lt;code&gt;YES&lt;/code&gt; ; false (&lt;code&gt;empty string&lt;/code&gt; ) if &lt;code&gt;NO&lt;/code&gt; ; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;MAYBE&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;YES&lt;/code&gt; ，则返回true（ &lt;code&gt;1&lt;/code&gt; ）; 如果为 &lt;code&gt;NO&lt;/code&gt; ，则返回false（ &lt;code&gt;empty string&lt;/code&gt; ）。如果 &lt;code&gt;MAYBE&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a729a5529269a29252f3c2bf2eddc2d7ae807d5" translate="yes" xml:space="preserve">
          <source>It returns true if everything was ok. Otherwise it will &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; with one of the messages in the DIAGNOSTICS section.</source>
          <target state="translated">如果一切正常，则返回true。否则，它将与DIAGNOSTICS部分中的消息之一一起 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="714b64110a6e486db425b221e1f3c962f9afdc59" translate="yes" xml:space="preserve">
          <source>It returns true if the key matched the criteria, or false otherwise.</source>
          <target state="translated">如果键符合标准,则返回true,否则返回false。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
