<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="48d16a26d9f41be014d7cb3e5f6b9f3ee7edffee" translate="yes" xml:space="preserve">
          <source>specify (in &lt;code&gt;WriteMakefile()&lt;/code&gt; ):</source>
          <target state="translated">指定（在 &lt;code&gt;WriteMakefile()&lt;/code&gt; 中）：</target>
        </trans-unit>
        <trans-unit id="2f223b9c4e5f0defc1f0dc33d65dcd3a8b1a20b4" translate="yes" xml:space="preserve">
          <source>specify dependencies the original maintainer forgot</source>
          <target state="translated">指定原维护者遗忘的依赖关系</target>
        </trans-unit>
        <trans-unit id="95eeb58adbf5f519ec33bbad9c33c334a529f0d2" translate="yes" xml:space="preserve">
          <source>specify that the normal Perl @INC</source>
          <target state="translated">指定正常的Perl @INC</target>
        </trans-unit>
        <trans-unit id="a209d61567c7f4b583a143710470e25b5d5366af" translate="yes" xml:space="preserve">
          <source>specify the variable's name, including leading sigil.</source>
          <target state="translated">指定变量的名称,包括前导符。</target>
        </trans-unit>
        <trans-unit id="a13e0c7dace3c97deaa75f3b60d13568b970c225" translate="yes" xml:space="preserve">
          <source>specify the variable's name, including leading sigil. If</source>
          <target state="translated">指定变量的名称,包括前导符。如果</target>
        </trans-unit>
        <trans-unit id="5ee5fc55eefeeffa3b134d3232f7012a33185cc1" translate="yes" xml:space="preserve">
          <source>specifying the task in detail,</source>
          <target state="translated">详细说明任务。</target>
        </trans-unit>
        <trans-unit id="08ca65393cebed736f19ed46250af41bd90eac3f" translate="yes" xml:space="preserve">
          <source>spitshell.U</source>
          <target state="translated">spitshell.U</target>
        </trans-unit>
        <trans-unit id="bc9f74ff779f8e7d55cf3e8a4de59aac940853a9" translate="yes" xml:space="preserve">
          <source>splain</source>
          <target state="translated">splain</target>
        </trans-unit>
        <trans-unit id="b7baa4c262f38bec530fae7b1314e401653644d6" translate="yes" xml:space="preserve">
          <source>splice</source>
          <target state="translated">splice</target>
        </trans-unit>
        <trans-unit id="2616fb7f6e6f1c46a52ca21a3f1381cbca36ce42" translate="yes" xml:space="preserve">
          <source>splice ARRAY</source>
          <target state="translated">拼接阵列</target>
        </trans-unit>
        <trans-unit id="12a712e89d96498abeb93ffbead46760f3934649" translate="yes" xml:space="preserve">
          <source>splice ARRAY,OFFSET</source>
          <target state="translated">拼接ARRAY,OFFSET</target>
        </trans-unit>
        <trans-unit id="63c64236a41d11a045bbea0d757b827b7ee17940" translate="yes" xml:space="preserve">
          <source>splice ARRAY,OFFSET,LENGTH</source>
          <target state="translated">拼接ARRAY,OFFSET,LENGTH。</target>
        </trans-unit>
        <trans-unit id="4c42b6952c9f22cbcc9a78cb2ff96c595091af27" translate="yes" xml:space="preserve">
          <source>splice ARRAY,OFFSET,LENGTH,LIST</source>
          <target state="translated">拼接ARRAY,OFFSET,LENGTH,LIST。</target>
        </trans-unit>
        <trans-unit id="eba49a93ed234086f77b0e62128e87c1d2a1ff96" translate="yes" xml:space="preserve">
          <source>splice EXPR</source>
          <target state="translated">拼接 EXPR</target>
        </trans-unit>
        <trans-unit id="d5750018faf83eb7bad6754381ffbc60920f6901" translate="yes" xml:space="preserve">
          <source>splice EXPR,OFFSET</source>
          <target state="translated">拼接EXPR,OFFSET</target>
        </trans-unit>
        <trans-unit id="8cad940b2fcd46f4dcad5340cafaaef0845136c9" translate="yes" xml:space="preserve">
          <source>splice EXPR,OFFSET,LENGTH</source>
          <target state="translated">拼接EXPR,OFFSET,LENGTH。</target>
        </trans-unit>
        <trans-unit id="d3dfa0f1ed8ab1e87c6e2e585bd9d172e8a83ced" translate="yes" xml:space="preserve">
          <source>splice EXPR,OFFSET,LENGTH,LIST</source>
          <target state="translated">拼接EXPR,OFFSET,LENGTH,LIST。</target>
        </trans-unit>
        <trans-unit id="94d5cab6f5fe3422a447ab15436e7a672bc0c09a" translate="yes" xml:space="preserve">
          <source>split</source>
          <target state="translated">split</target>
        </trans-unit>
        <trans-unit id="ac948e3fe139383bc50a7b7b6bec28341556da4e" translate="yes" xml:space="preserve">
          <source>split /PATTERN/</source>
          <target state="translated">split /PATTERN/</target>
        </trans-unit>
        <trans-unit id="c29c06c429f689ab3f15c34cf0f05bf3279fe35a" translate="yes" xml:space="preserve">
          <source>split /PATTERN/,EXPR</source>
          <target state="translated">分割/PATTERN/,EXPR。</target>
        </trans-unit>
        <trans-unit id="9c02a35452960b8061c5041058a979fc004ed8c0" translate="yes" xml:space="preserve">
          <source>split /PATTERN/,EXPR,LIMIT</source>
          <target state="translated">split /PATTERN/,EXPR,LIMIT。</target>
        </trans-unit>
        <trans-unit id="6268dfe06a8fec82c4cba1c4f3435d05fc39b73b" translate="yes" xml:space="preserve">
          <source>split.exe</source>
          <target state="translated">split.exe</target>
        </trans-unit>
        <trans-unit id="0943d6a64642e994ec69f6f5d1b659f14f3f33b5" translate="yes" xml:space="preserve">
          <source>split_command</source>
          <target state="translated">split_command</target>
        </trans-unit>
        <trans-unit id="28e7617692334dfe7e5fa6201d64cc35b4288116" translate="yes" xml:space="preserve">
          <source>sprintf</source>
          <target state="translated">sprintf</target>
        </trans-unit>
        <trans-unit id="9b7e408b5634f7134a2d3dbcbae42c51ca665f1f" translate="yes" xml:space="preserve">
          <source>sprintf FORMAT, LIST</source>
          <target state="translated">sprintf FORMAT,LIST</target>
        </trans-unit>
        <trans-unit id="f4c905336d42a8c4402119e9f334f17321f1c67d" translate="yes" xml:space="preserve">
          <source>sprintf(3)</source>
          <target state="translated">sprintf(3)</target>
        </trans-unit>
        <trans-unit id="72f3153cdbbfbaaca9285b4d7d97df1c90194172" translate="yes" xml:space="preserve">
          <source>sqrt</source>
          <target state="translated">sqrt</target>
        </trans-unit>
        <trans-unit id="79d759ce8028b457162866a6ec2a9c4130a0bd40" translate="yes" xml:space="preserve">
          <source>sqrt EXPR</source>
          <target state="translated">sqrt EXPR</target>
        </trans-unit>
        <trans-unit id="51480679cc628618e1f82224a11a2de1db4a36e5" translate="yes" xml:space="preserve">
          <source>srand</source>
          <target state="translated">srand</target>
        </trans-unit>
        <trans-unit id="bb6cd71c2a8f6f02e4e795e14fedad3fb3530832" translate="yes" xml:space="preserve">
          <source>srand EXPR</source>
          <target state="translated">srand EXPR</target>
        </trans-unit>
        <trans-unit id="c882e08c62ca1c7dbf71100bd166aa6cf2cdecbc" translate="yes" xml:space="preserve">
          <source>src.U</source>
          <target state="translated">src.U</target>
        </trans-unit>
        <trans-unit id="116db8d07776534b8e26a3f599fe37fe92d4c357" translate="yes" xml:space="preserve">
          <source>src/misc/db.1.85.tar.gz</source>
          <target state="translated">src/misc/db.1.85.tar.gz</target>
        </trans-unit>
        <trans-unit id="efe2e01d62234b754918ef1aa109c13d8f720f71" translate="yes" xml:space="preserve">
          <source>ssizetype.U</source>
          <target state="translated">ssizetype.U</target>
        </trans-unit>
        <trans-unit id="763b379567b67648805ccb4dea79440bd48adb24" translate="yes" xml:space="preserve">
          <source>st_ino_def.U</source>
          <target state="translated">st_ino_def.U</target>
        </trans-unit>
        <trans-unit id="239cae3c920814c7711f11d4adceadaf14e6ced9" translate="yes" xml:space="preserve">
          <source>stability might matter because elements that compare equal on the first 3 characters may be distinguished based on subsequent characters. In Perl 5.8 and later, quicksort can be stabilized, but doing so will add overhead, so it should only be done if it matters.</source>
          <target state="translated">稳定性可能会很重要,因为前三个字符比较相同的元素可能会根据后面的字符被区分开来,所以在Perl 5.8和更高版本中,quicksort可以稳定化,但这样做会增加开销,所以只有在重要的情况下才应该这样做。在 Perl 5.8 及以后的版本中,quicksort 可以被稳定化,但这样做会增加开销,所以只有在重要的情况下才应该这样做。</target>
        </trans-unit>
        <trans-unit id="4fbacc2fa0ffdbb11bf1ad6925b886ebd08dd15f" translate="yes" xml:space="preserve">
          <source>stable</source>
          <target state="translated">stable</target>
        </trans-unit>
        <trans-unit id="0b5cceaafa4cc072ea5e5f558cd1e99a8f503c2d" translate="yes" xml:space="preserve">
          <source>standalone</source>
          <target state="translated">standalone</target>
        </trans-unit>
        <trans-unit id="0ace4a105e3e3861037fb829606a3a0ada08413c" translate="yes" xml:space="preserve">
          <source>standard distribution</source>
          <target state="translated">标准分布</target>
        </trans-unit>
        <trans-unit id="2b020927d3c6eb407223a1baa3d6ce3597a3f88d" translate="yes" xml:space="preserve">
          <source>start</source>
          <target state="translated">start</target>
        </trans-unit>
        <trans-unit id="08cadc9ae2fc836f49d3941318f63f6218b5f018" translate="yes" xml:space="preserve">
          <source>start is the node preceding the first node to be spliced. Node(s) following it will be deleted, and ops will be inserted after it. If it is NULL, the first node onwards is deleted, and nodes are inserted at the beginning.</source>
          <target state="translated">start是第一个要拼接的节点之前的节点。它之后的节点将被删除,而ops将被插入到它之后。如果它是NULL,则第一个节点以后的节点将被删除,而节点将被从头插入。</target>
        </trans-unit>
        <trans-unit id="022400803c64233cb27fac5fe69aee61d23ec98b" translate="yes" xml:space="preserve">
          <source>start-of-range</source>
          <target state="translated">start-of-range</target>
        </trans-unit>
        <trans-unit id="786f0ed95a949ed86fa180801d114d5051e41805" translate="yes" xml:space="preserve">
          <source>starting at</source>
          <target state="translated">始于</target>
        </trans-unit>
        <trans-unit id="b9dd521b01030edc79b01f7e6d88d0e24deca83f" translate="yes" xml:space="preserve">
          <source>startperl.U</source>
          <target state="translated">startperl.U</target>
        </trans-unit>
        <trans-unit id="b681dba1be4594e15b104bbb4b4ac55b2b7f57c2" translate="yes" xml:space="preserve">
          <source>starts as zero but can be altered via &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, and determined via &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">开头为零，但可以通过 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 进行更改，并通过 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 进行确定。</target>
        </trans-unit>
        <trans-unit id="9bbcb38aa983cb766fa8c10755823f139e8fc0b7" translate="yes" xml:space="preserve">
          <source>startsh.U</source>
          <target state="translated">startsh.U</target>
        </trans-unit>
        <trans-unit id="fc165ac761802cfe0b77c55f9ed07e23a41650fb" translate="yes" xml:space="preserve">
          <source>stat</source>
          <target state="translated">stat</target>
        </trans-unit>
        <trans-unit id="9998a9a739cd3695e043f9af6c3f38dcec8458f2" translate="yes" xml:space="preserve">
          <source>stat DIRHANDLE</source>
          <target state="translated">统计 DIRHANDLE</target>
        </trans-unit>
        <trans-unit id="a0eabf5cc5996f6337f0d5b9ea19584ff39f13ee" translate="yes" xml:space="preserve">
          <source>stat EXPR</source>
          <target state="translated">统计数据EXPR</target>
        </trans-unit>
        <trans-unit id="807c6114a86022734d0861751c6b95f83419c8a3" translate="yes" xml:space="preserve">
          <source>stat FILEHANDLE</source>
          <target state="translated">统计 FILEHANDLE</target>
        </trans-unit>
        <trans-unit id="21e1087fb4f7788c00ef05c2e2c2da50af5a29a4" translate="yes" xml:space="preserve">
          <source>stat.h</source>
          <target state="translated">stat.h</target>
        </trans-unit>
        <trans-unit id="aa4a5f8125f234182e2dea92805afdfb747a86be" translate="yes" xml:space="preserve">
          <source>state</source>
          <target state="translated">state</target>
        </trans-unit>
        <trans-unit id="ced396f1a90896f9811c09bfcbb9a8cad6dac141" translate="yes" xml:space="preserve">
          <source>state TYPE VARLIST</source>
          <target state="translated">状态 类型 VARLIST</target>
        </trans-unit>
        <trans-unit id="20d5cc99dcfd66fdc07b4e75841debc2dbd7d70f" translate="yes" xml:space="preserve">
          <source>state TYPE VARLIST : ATTRS</source>
          <target state="translated">状态 VARLIST 类型:ATTRS</target>
        </trans-unit>
        <trans-unit id="d5eff69b9e8fd7a7b90b3b815fc5d71ed187aa47" translate="yes" xml:space="preserve">
          <source>state VARLIST</source>
          <target state="translated">VARLIST状态</target>
        </trans-unit>
        <trans-unit id="271b33ffeedf25183ca3d81c88764b12f1081666" translate="yes" xml:space="preserve">
          <source>state VARLIST : ATTRS</source>
          <target state="translated">状态 VARLIST:ATTRS</target>
        </trans-unit>
        <trans-unit id="8c7aac7672f65451267eb994144065eff5989afe" translate="yes" xml:space="preserve">
          <source>state, and so does not appear in the list returned by &lt;code&gt;threads-&amp;gt;list()&lt;/code&gt; .</source>
          <target state="translated">状态，因此不会出现在 &lt;code&gt;threads-&amp;gt;list()&lt;/code&gt; 返回的列表中。</target>
        </trans-unit>
        <trans-unit id="cc1f418fb6974a4fe2f3ea007621265ac0e28236" translate="yes" xml:space="preserve">
          <source>state. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl58delta.html#Safe-Signals&quot;&gt;Safe Signals in perl58delta&lt;/a&gt; and &lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals) in perlipc&lt;/a&gt; for more details.</source>
          <target state="translated">州。有关更多详细信息，请参见&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl58delta.html#Safe-Signals&quot;&gt;perl58delta中的&amp;ldquo;安全信号&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;perlipc中的&amp;ldquo;延迟信号&amp;rdquo;（安全信号）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="932d01c17ae82cda4efa38f751587dcb8a781099" translate="yes" xml:space="preserve">
          <source>state_version</source>
          <target state="translated">state_version</target>
        </trans-unit>
        <trans-unit id="bbb930cc426507ed3f6b7c343c75dd0e041494b7" translate="yes" xml:space="preserve">
          <source>statement</source>
          <target state="translated">statement</target>
        </trans-unit>
        <trans-unit id="54bdb88217df66cde42436678a4c375cc9a099b4" translate="yes" xml:space="preserve">
          <source>statement in the subroutine</source>
          <target state="translated">子程序中的语句</target>
        </trans-unit>
        <trans-unit id="a381562afa0e16c5548e829b2f1a659a8c2e7c11" translate="yes" xml:space="preserve">
          <source>static</source>
          <target state="translated">static</target>
        </trans-unit>
        <trans-unit id="b02321af0b16972951f62b2fe2e1c6a51072419b" translate="yes" xml:space="preserve">
          <source>statistical time-sampling</source>
          <target state="translated">统计时间抽样</target>
        </trans-unit>
        <trans-unit id="48a3661d846478fa991a825ebd10b78671444b5b" translate="yes" xml:space="preserve">
          <source>status</source>
          <target state="translated">status</target>
        </trans-unit>
        <trans-unit id="024e63225e76cd46ebb2de279b11dcbc5eccacce" translate="yes" xml:space="preserve">
          <source>status code (&lt;code&gt;$status&lt;/code&gt; ). In a scalar context it returns the inflation object only.</source>
          <target state="translated">状态码（ &lt;code&gt;$status&lt;/code&gt; ）。在标量上下文中，它仅返回通胀对象。</target>
        </trans-unit>
        <trans-unit id="4572c83a149c0e163e85aadf01cbfc2705fd4d98" translate="yes" xml:space="preserve">
          <source>status code in &lt;code&gt;$status&lt;/code&gt; . In a scalar context it returns the inflation stream only.</source>
          <target state="translated">&lt;code&gt;$status&lt;/code&gt; 状态码。在标量上下文中，它仅返回通胀流。</target>
        </trans-unit>
        <trans-unit id="65ab6178b5bb65263f1d2b6dbfe9770716f945ed" translate="yes" xml:space="preserve">
          <source>stdarg.h</source>
          <target state="translated">stdarg.h</target>
        </trans-unit>
        <trans-unit id="a9fa8e1c580e694c07ff1d29bd6b91ea91fd7705" translate="yes" xml:space="preserve">
          <source>stdchar.U</source>
          <target state="translated">stdchar.U</target>
        </trans-unit>
        <trans-unit id="45dba8aa65b0debb3a7090a0ee8ff83caa794b20" translate="yes" xml:space="preserve">
          <source>stderr.txt</source>
          <target state="translated">stderr.txt</target>
        </trans-unit>
        <trans-unit id="992c2711fc506e6dc28f2ea8eedab248c1567bf2" translate="yes" xml:space="preserve">
          <source>stdin.txt</source>
          <target state="translated">stdin.txt</target>
        </trans-unit>
        <trans-unit id="406ce85c8f803ee40b9e12ea03120d86d05edbbc" translate="yes" xml:space="preserve">
          <source>stdio.h</source>
          <target state="translated">stdio.h</target>
        </trans-unit>
        <trans-unit id="87e34339d4e6b16a542d3988dadda8ddb3937f31" translate="yes" xml:space="preserve">
          <source>stdio_streams.U</source>
          <target state="translated">stdio_streams.U</target>
        </trans-unit>
        <trans-unit id="12f3f549b822f5e7a5827ea917abe581dcfe2da3" translate="yes" xml:space="preserve">
          <source>stdlib.h</source>
          <target state="translated">stdlib.h</target>
        </trans-unit>
        <trans-unit id="68ad3077ff5a452a1c6af2d3070fc26a224fb69e" translate="yes" xml:space="preserve">
          <source>stdout.txt</source>
          <target state="translated">stdout.txt</target>
        </trans-unit>
        <trans-unit id="fb3a873781fcf5e4d0153021f030ffb2478296c7" translate="yes" xml:space="preserve">
          <source>stdout/stderr now go into the files</source>
          <target state="translated">stdout/stderr 现在进入文件</target>
        </trans-unit>
        <trans-unit id="92fc138bc7e25a36921b6e305ce7eee716d0f9ce" translate="yes" xml:space="preserve">
          <source>step over</source>
          <target state="translated">跨越</target>
        </trans-unit>
        <trans-unit id="7583e62e3d3829835245dd94568102b8618a99ff" translate="yes" xml:space="preserve">
          <source>stepping off</source>
          <target state="translated">下车</target>
        </trans-unit>
        <trans-unit id="803e4c41bbd2212a675dbe73defc33a72fea64e6" translate="yes" xml:space="preserve">
          <source>sticks</source>
          <target state="translated">sticks</target>
        </trans-unit>
        <trans-unit id="3d48292e4d2714f11c2adf276b610971e068a519" translate="yes" xml:space="preserve">
          <source>storage</source>
          <target state="translated">storage</target>
        </trans-unit>
        <trans-unit id="c82e3d7279efa3eca576370af952c815d48ce41f" translate="yes" xml:space="preserve">
          <source>stream</source>
          <target state="translated">stream</target>
        </trans-unit>
        <trans-unit id="41eaab877ca3a0e3aa14f5a4b7981f590e3c2bd6" translate="yes" xml:space="preserve">
          <source>strict</source>
          <target state="translated">strict</target>
        </trans-unit>
        <trans-unit id="96f25d4f3e97a1ef0603aee48b48d787241b153f" translate="yes" xml:space="preserve">
          <source>strict - Perl pragma to restrict unsafe constructs</source>
          <target state="translated">strict-限制不安全结构的Perl pragma。</target>
        </trans-unit>
        <trans-unit id="170929fc44f4ddbc242c5b0f1e2624d778f09128" translate="yes" xml:space="preserve">
          <source>strict.pm</source>
          <target state="translated">strict.pm</target>
        </trans-unit>
        <trans-unit id="ecb252044b5ea0f679ee78ec1a12904739e2904d" translate="yes" xml:space="preserve">
          <source>string</source>
          <target state="translated">string</target>
        </trans-unit>
        <trans-unit id="a4fc86cc3e0b9869ed563caa0d277d34cd15cf05" translate="yes" xml:space="preserve">
          <source>string form of the constant, the second one is how Perl interprets this constant, the third one is how the constant is used. Note that the initial string form does not contain string delimiters, and has backslashes in backslash-delimiter combinations stripped (thus the value of delimiter is not relevant for processing of this string). The return value of this function is how this constant is going to be interpreted by Perl. The third argument is undefined unless for overloaded &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;- and &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt;- constants, it is &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; in single-quote context (comes from strings, regular expressions, and single-quote HERE documents), it is &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; for arguments of &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; operators, it is &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; for right-hand side of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;-operator, and it is &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">常量的字符串形式，第二个是Perl解释该常量的方式，第三个是常量的使用方式。请注意，初始字符串形式不包含字符串定界符，并且在反斜杠分隔符组合中去除了反斜杠（因此分隔符的值与该字符串的处理无关）。该函数的返回值是Perl将如何解释此常数。第三个参数是不确定的，除非是重载 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; -和 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt; -常量，它是 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; 在单引号上下文（来自字符串，正则表达式和单引号HERE文档），它是 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 为参数 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 运营商，它是 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 对于 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; -operator的右侧，否则为 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c32ff0561e50c22a71e602a7d98c4e5fe27e6270" translate="yes" xml:space="preserve">
          <source>string is an &quot;&lt;code&gt;fopen()&lt;/code&gt; -like&quot; string which would match the regular expression &lt;code&gt;/^[I#]?[rwa]\+?[bt]?$/&lt;/code&gt; .</source>
          <target state="translated">string是一个 &lt;code&gt;fopen()&lt;/code&gt; 的字符串，它将与正则表达式 &lt;code&gt;/^[I#]?[rwa]\+?[bt]?$/&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="887785b307fb41905fac3f5f27b08b3a6b98290a" translate="yes" xml:space="preserve">
          <source>string is true, it really should (for backwards compatibility with older Test.pm versions) start with the string &quot;Skip&quot;, as shown in the above examples.</source>
          <target state="translated">字符串为真,它确实应该以字符串 &quot;Skip &quot;开头(为了向后兼容旧版的Test.pm),如上例所示。</target>
        </trans-unit>
        <trans-unit id="3a44afe5fc8faf20ca2e98b939c7c9f025af24e3" translate="yes" xml:space="preserve">
          <source>string is used instead of reading a termcap file. If it does begin with a slash, the string is used as a path name of the termcap file to search. If</source>
          <target state="translated">字符串被用来代替读取 termcap 文件。如果该字符串以斜杠开头,则该字符串将被用作要搜索的 termcap 文件的路径名。如果</target>
        </trans-unit>
        <trans-unit id="1855951a0178eff72d32106e82cadc99cd03510c" translate="yes" xml:space="preserve">
          <source>string.c</source>
          <target state="translated">string.c</target>
        </trans-unit>
        <trans-unit id="59ffa46484e85b209f6ba7ff12829a1375a063ec" translate="yes" xml:space="preserve">
          <source>stringification</source>
          <target state="translated">stringification</target>
        </trans-unit>
        <trans-unit id="a63050cdf83721e499d02d2f3d432f267f922d5e" translate="yes" xml:space="preserve">
          <source>strings to be used. This time we will use a</source>
          <target state="translated">字符串来使用。这次我们将使用一个</target>
        </trans-unit>
        <trans-unit id="6e77d135758c9c845119b28e12b65a1430e1224f" translate="yes" xml:space="preserve">
          <source>strongly</source>
          <target state="translated">strongly</target>
        </trans-unit>
        <trans-unit id="c36cf7d6ebb6072d7f9cc8640d54bdf9d904b71b" translate="yes" xml:space="preserve">
          <source>strongly discouraged</source>
          <target state="translated">坚决反对</target>
        </trans-unit>
        <trans-unit id="6ad323d1a641c0194e65ef7bbcf4f2ff123ba15a" translate="yes" xml:space="preserve">
          <source>strongly recommended that you read &lt;a href=&quot;perltie#The-untie-Gotcha&quot;&gt;The untie Gotcha in perltie&lt;/a&gt;.</source>
          <target state="translated">强烈建议您阅读&lt;a href=&quot;perltie#The-untie-Gotcha&quot;&gt;perltie中的Unt Gotcha&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cfb18e81efbda9473cefbd150d9be1eb0ac7840b" translate="yes" xml:space="preserve">
          <source>stuck</source>
          <target state="translated">stuck</target>
        </trans-unit>
        <trans-unit id="885534c19d5f8389b4cc0a7fcd699206bacdbd86" translate="yes" xml:space="preserve">
          <source>study</source>
          <target state="translated">study</target>
        </trans-unit>
        <trans-unit id="58e6b3cd9d8a5fb746718c9cee025688cbb60efb" translate="yes" xml:space="preserve">
          <source>study SCALAR</source>
          <target state="translated">研究SCALAR</target>
        </trans-unit>
        <trans-unit id="5eee38381388b6f30efdd5c5c6f067dbf32c0bb3" translate="yes" xml:space="preserve">
          <source>stuff</source>
          <target state="translated">stuff</target>
        </trans-unit>
        <trans-unit id="26ec8d00fb6b55466b3a115f1d559422a7fa7aac" translate="yes" xml:space="preserve">
          <source>style</source>
          <target state="translated">style</target>
        </trans-unit>
        <trans-unit id="5f6547f5a43b3c1ea0d4ef2b58b8d397690fc8eb" translate="yes" xml:space="preserve">
          <source>style not</source>
          <target state="translated">风格不</target>
        </trans-unit>
        <trans-unit id="4e4b909a7c014ffa3745433641ad629adbd7314f" translate="yes" xml:space="preserve">
          <source>style shells should be aware that each of these file specifications may have subtle differences:</source>
          <target state="translated">风格的shell应该意识到,这些文件规范可能有细微的差别。</target>
        </trans-unit>
        <trans-unit id="5d85613a56c124e3a3ff8ce6fc95d10cdcb5001e" translate="yes" xml:space="preserve">
          <source>sub</source>
          <target state="translated">sub</target>
        </trans-unit>
        <trans-unit id="258e29fa2366e170bfad52a706cf0d9aeef2946b" translate="yes" xml:space="preserve">
          <source>sub NAME (PROTO) : ATTRS BLOCK</source>
          <target state="translated">子名称(PROTO):ATTRS BLOCK</target>
        </trans-unit>
        <trans-unit id="7de160be2446e3a60b5145a242fc479ecd855f54" translate="yes" xml:space="preserve">
          <source>sub NAME (PROTO) BLOCK</source>
          <target state="translated">子名称(PROTO)BLOCK</target>
        </trans-unit>
        <trans-unit id="17ca004b29b99a8eefba7528721764cc8c00fe3c" translate="yes" xml:space="preserve">
          <source>sub NAME : ATTRS BLOCK</source>
          <target state="translated">子名称:ATTRS BLOCK</target>
        </trans-unit>
        <trans-unit id="df052d5ba6d8a7b78532317d8816aac43a513f30" translate="yes" xml:space="preserve">
          <source>sub NAME BLOCK</source>
          <target state="translated">子名字块</target>
        </trans-unit>
        <trans-unit id="7a7c7d7dcc3ffdc428e4ce436230f0049d747f34" translate="yes" xml:space="preserve">
          <source>subbeg sublen saved_copy suboffset subcoffset</source>
          <target state="translated">subbeg sublen saved_copy suboffset subcoffset</target>
        </trans-unit>
        <trans-unit id="5218231c03a7fc0030512f9e357d0222b012972d" translate="yes" xml:space="preserve">
          <source>subchar</source>
          <target state="translated">subchar</target>
        </trans-unit>
        <trans-unit id="1cf8c73561acb61f0940922c4e13aeb013e81b64" translate="yes" xml:space="preserve">
          <source>subdirectories and performs a build of each extension in turn.</source>
          <target state="translated">子目录,并依次执行每个扩展的构建。</target>
        </trans-unit>
        <trans-unit id="2dfc1829a74a17416d23bbd2f98f59da5af5c27f" translate="yes" xml:space="preserve">
          <source>subdirectories for each module, like a standard CPAN distribution.</source>
          <target state="translated">每个模块的子目录,就像一个标准的CPAN发行版。</target>
        </trans-unit>
        <trans-unit id="c2d8ed2d8c0dbda3cc79ff51ec1fb8b37d8c8287" translate="yes" xml:space="preserve">
          <source>subdirectory can be used to help mail in a bug report.</source>
          <target state="translated">子目录可以用来帮助邮寄错误报告。</target>
        </trans-unit>
        <trans-unit id="48d43d070d4b22fd04b4e54d56a4c62626b13780" translate="yes" xml:space="preserve">
          <source>subdirectory of one of the directories in &lt;code&gt;@INC&lt;/code&gt; (where</source>
          <target state="translated">&lt;code&gt;@INC&lt;/code&gt; 中目录之一的子目录（其中</target>
        </trans-unit>
        <trans-unit id="5e3b28ba75a4522feb49d7d2c15c806c7d8c4311" translate="yes" xml:space="preserve">
          <source>subdirectory of the Perl distribution.</source>
          <target state="translated">Perl发行版的子目录。</target>
        </trans-unit>
        <trans-unit id="81e77ccd1352246340045d9a85572778e0626f09" translate="yes" xml:space="preserve">
          <source>subdirectory of the build tree (as well as</source>
          <target state="translated">子目录下的构建树(以及</target>
        </trans-unit>
        <trans-unit id="35af8711767d4fe546b17463c98de5c438da956a" translate="yes" xml:space="preserve">
          <source>subdirectory under one of the directories in &lt;code&gt;@INC&lt;/code&gt; , where</source>
          <target state="translated">子目录位于 &lt;code&gt;@INC&lt;/code&gt; 中的目录之一下，其中</target>
        </trans-unit>
        <trans-unit id="69ac5c899be5939edfe7aeed22446cf364b8945a" translate="yes" xml:space="preserve">
          <source>subdirectory) to find how it should be done &quot;correctly&quot;.</source>
          <target state="translated">子目录)来寻找应该如何 &quot;正确 &quot;地进行。</target>
        </trans-unit>
        <trans-unit id="3870e1bf219c5068ace9baad9108071e9fa0e62d" translate="yes" xml:space="preserve">
          <source>subdirectory).</source>
          <target state="translated">subdirectory).</target>
        </trans-unit>
        <trans-unit id="ab0a47899af061959cec192ad2de3931d9bb5e3b" translate="yes" xml:space="preserve">
          <source>subdirectory, then it is searched. (That's how we manage to find</source>
          <target state="translated">子目录,然后进行搜索。这就是我们如何找到</target>
        </trans-unit>
        <trans-unit id="335ce16b3fe40346cc3af2a4efce2ef04bc4ea55" translate="yes" xml:space="preserve">
          <source>subject</source>
          <target state="translated">subject</target>
        </trans-unit>
        <trans-unit id="7d474ca7bc06197f0a3630d40d84be8f9d45bffd" translate="yes" xml:space="preserve">
          <source>subject to the caveat about reallocated elements), so &lt;code&gt;@DB::args&lt;/code&gt; is actually a hybrid of the current state and initial state of &lt;code&gt;@_&lt;/code&gt; . Buyer beware.</source>
          <target state="translated">取决于有关重新分配元素的警告），因此 &lt;code&gt;@DB::args&lt;/code&gt; 实际上是 &lt;code&gt;@_&lt;/code&gt; 的当前状态和初始状态的混合。买家当心。</target>
        </trans-unit>
        <trans-unit id="ae8b08091c15ec5245e6edf0be64bcdef1cea42c" translate="yes" xml:space="preserve">
          <source>subject to the loose matching of encoding names. Also note that currently &lt;code&gt;:utf8&lt;/code&gt; is unsafe for input, because it accepts the data without validating that it is indeed valid UTF-8; you should instead use &lt;code&gt;:encoding(utf-8)&lt;/code&gt; (with or without a hyphen).</source>
          <target state="translated">取决于编码名称的松散匹配。还要注意，当前 &lt;code&gt;:utf8&lt;/code&gt; 对于输入是不安全的，因为它接受数据而不验证其确实是有效的UTF-8。您应该改用 &lt;code&gt;:encoding(utf-8)&lt;/code&gt; （带或不带连字符）。</target>
        </trans-unit>
        <trans-unit id="a9dcc3bae592b9027755e382fb248039dc5a2464" translate="yes" xml:space="preserve">
          <source>subname</source>
          <target state="translated">subname</target>
        </trans-unit>
        <trans-unit id="0a6e2d7628cf0474c6c912a6bba3b83770aa6e9e" translate="yes" xml:space="preserve">
          <source>subroutine</source>
          <target state="translated">subroutine</target>
        </trans-unit>
        <trans-unit id="5fa26688e44b972471d55441246623cdcb9a64ac" translate="yes" xml:space="preserve">
          <source>subroutine declarations that can be loaded in later - usually because they may never be called.</source>
          <target state="translated">子程序声明,可以在以后加载--通常是因为它们可能永远不会被调用。</target>
        </trans-unit>
        <trans-unit id="e9d331efbf733d0c5c35bcd40c2205975593c355" translate="yes" xml:space="preserve">
          <source>subroutine in a file called</source>
          <target state="translated">子程序在一个名为</target>
        </trans-unit>
        <trans-unit id="ad03cbd9e1be45399cc464a20b88353a10eefc22" translate="yes" xml:space="preserve">
          <source>subroutine is referencing a &quot;my&quot; subroutine defined in an outer named subroutine.</source>
          <target state="translated">子程序正在引用一个定义在外部命名子程序中的 &quot;my &quot;子程序。</target>
        </trans-unit>
        <trans-unit id="44cb6377f9c1380130016d7ecdddaca2e9c8c6ad" translate="yes" xml:space="preserve">
          <source>subroutine is referencing a lexical variable defined in an outer named subroutine.</source>
          <target state="translated">子程序正在引用一个定义在外部命名子程序中的词汇变量。</target>
        </trans-unit>
        <trans-unit id="17faa80a0b42a473e0e0882cfa952a6f7696a21f" translate="yes" xml:space="preserve">
          <source>subroutine of the class.</source>
          <target state="translated">类的子程序。</target>
        </trans-unit>
        <trans-unit id="c78c2978b287abedc4733e47d45c9b3f394278cf" translate="yes" xml:space="preserve">
          <source>subs</source>
          <target state="translated">subs</target>
        </trans-unit>
        <trans-unit id="8dbaf7827ebf384a07dd9abc68263ad9e81fd84d" translate="yes" xml:space="preserve">
          <source>subs - Perl pragma to predeclare sub names</source>
          <target state="translated">subs-用Perl pragma来预先声明子名称。</target>
        </trans-unit>
        <trans-unit id="df85a3fa4cab8cb59c20a9638f3c316f42a1cd49" translate="yes" xml:space="preserve">
          <source>subscript</source>
          <target state="translated">subscript</target>
        </trans-unit>
        <trans-unit id="6529d3df81c7d2e924bf1d009d4a8c9984cdc67f" translate="yes" xml:space="preserve">
          <source>substitute()</source>
          <target state="translated">substitute()</target>
        </trans-unit>
        <trans-unit id="ddd5fb4848e0a4f26098f2a25184c8d751fa402b" translate="yes" xml:space="preserve">
          <source>substitution character</source>
          <target state="translated">替换字</target>
        </trans-unit>
        <trans-unit id="e6fbe0ef6cab1da5a2948575b3a43ad97329e8bf" translate="yes" xml:space="preserve">
          <source>substitution).</source>
          <target state="translated">substitution).</target>
        </trans-unit>
        <trans-unit id="b79cd1299d045c6fdf4cc098af396543ad594122" translate="yes" xml:space="preserve">
          <source>substitution). The standard distribution will put nothing in this directory. After perl has been installed, users may install their own local architecture-dependent modules in this directory with MakeMaker</source>
          <target state="translated">替换)。)标准发行版不会在这个目录下放任何东西。在安装了perl之后,用户可以在这个目录下安装自己的本地架构依赖的模块,用MakeMaker</target>
        </trans-unit>
        <trans-unit id="590d07b8733e44e115f2ce0a52ae1e6e7b3cac50" translate="yes" xml:space="preserve">
          <source>substitution). The standard distribution will put nothing in this directory. After perl has been installed, users may install their own local architecture-independent modules in this directory with MakeMaker</source>
          <target state="translated">替换)。)标准发行版不会在这个目录下放任何东西。在安装了perl之后,用户可以在这个目录下安装自己的本地架构无关的模块,用MakeMaker</target>
        </trans-unit>
        <trans-unit id="fae1c7d34515216afb9e0c37ccfb61a0925a3258" translate="yes" xml:space="preserve">
          <source>substitution.</source>
          <target state="translated">substitution.</target>
        </trans-unit>
        <trans-unit id="48a600287dc56932d89eef8c9264fbf8710a38f7" translate="yes" xml:space="preserve">
          <source>substitution. The standard distribution will put nothing in this directory. After perl has been installed, users may install their own local executables in this directory with MakeMaker</source>
          <target state="translated">替换。标准发行版将不会在这个目录中放任何东西。在安装了perl之后,用户可以在这个目录下安装自己的本地可执行文件,用 MakeMaker</target>
        </trans-unit>
        <trans-unit id="f682054e7fa0c949ce854defb25264133d6f6f0c" translate="yes" xml:space="preserve">
          <source>substitution. The standard distribution will put nothing in this directory. After perl has been installed, users may install their own local scripts in this directory with MakeMaker</source>
          <target state="translated">替换。标准发行版会在这个目录下什么都不放。安装好perl后,用户可以在这个目录下安装自己的本地脚本,用MakeMaker</target>
        </trans-unit>
        <trans-unit id="72face471a629a5739e9760b45e749a5dab417a1" translate="yes" xml:space="preserve">
          <source>substr</source>
          <target state="translated">substr</target>
        </trans-unit>
        <trans-unit id="18ede6b1a478ffea5b6b13552e119cd6cd6fe856" translate="yes" xml:space="preserve">
          <source>substr EXPR,OFFSET</source>
          <target state="translated">substr EXPR,OFFSET</target>
        </trans-unit>
        <trans-unit id="5355044a2beffcd33cbc1a5488febf4a20325c5e" translate="yes" xml:space="preserve">
          <source>substr EXPR,OFFSET,LENGTH</source>
          <target state="translated">substr EXPR,OFFSET,LENGTH。</target>
        </trans-unit>
        <trans-unit id="1d3434b4d59555253b1410b196d7120ac727e861" translate="yes" xml:space="preserve">
          <source>substr EXPR,OFFSET,LENGTH,REPLACEMENT</source>
          <target state="translated">substr EXPR,OFFSET,LENGTH,REPLACEMENT。</target>
        </trans-unit>
        <trans-unit id="2253eac9c79aa036f9511dc664828785ee209400" translate="yes" xml:space="preserve">
          <source>substrs</source>
          <target state="translated">substrs</target>
        </trans-unit>
        <trans-unit id="2ef3a6fd919f65915228636166c56a2a3ad17fb5" translate="yes" xml:space="preserve">
          <source>subversions are not the same &quot;latest&quot; on all OS versions. For example, the latest xlC-5 on aix41 is 5.0.2.9, while on aix43, it is 5.0.2.7.</source>
          <target state="translated">子版本在所有操作系统版本上的 &quot;最新 &quot;是不一样的。例如,aix41上最新的xlC-5是5.0.2.9,而aix43上是5.0.2.7。</target>
        </trans-unit>
        <trans-unit id="85193e237d55185fa99df9f3a73c538c8af45be0" translate="yes" xml:space="preserve">
          <source>successfully</source>
          <target state="translated">successfully</target>
        </trans-unit>
        <trans-unit id="1edd685781818eb0737fd5086f1593fef8487aab" translate="yes" xml:space="preserve">
          <source>such roots, returned as a list. Getting the number mathematicians call &lt;code&gt;j&lt;/code&gt; such that:</source>
          <target state="translated">这样的根，作为列表返回。得到数学家叫 &lt;code&gt;j&lt;/code&gt; 的数字是：</target>
        </trans-unit>
        <trans-unit id="6c634901c45fff2c45e6f5bcc0216f13bc34a921" translate="yes" xml:space="preserve">
          <source>suggested for server programs and any program run on behalf of someone else, such as a CGI script. Once taint mode is on, it's on for the remainder of your script.</source>
          <target state="translated">建议用于服务器程序和任何代表他人运行的程序,如CGI脚本。一旦污点模式开启,它就会在你的脚本的其余部分开启。</target>
        </trans-unit>
        <trans-unit id="757cf865cda72f6e2abf0a08e2dab4aae64b5d11" translate="yes" xml:space="preserve">
          <source>suited to XSUBs which return multiple results. For that, either stick to the &lt;code&gt;(X)PUSHs&lt;/code&gt; macros shown above, or use the new &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; macros instead; see &lt;a href=&quot;#Putting-a-C-value-on-Perl-stack&quot;&gt;Putting a C value on Perl stack&lt;/a&gt;.</source>
          <target state="translated">适用于返回多个结果的XSUB。为此，要么坚持上面显示的 &lt;code&gt;(X)PUSHs&lt;/code&gt; 宏，要么使用新的 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; 宏；请参见&lt;a href=&quot;#Putting-a-C-value-on-Perl-stack&quot;&gt;在Perl堆栈上放置C值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e9dff3557ded7414ae530834de7011f1388d202a" translate="yes" xml:space="preserve">
          <source>sum</source>
          <target state="translated">sum</target>
        </trans-unit>
        <trans-unit id="7937d42266c04fd6255de322d23a060f48ed9405" translate="yes" xml:space="preserve">
          <source>sum0</source>
          <target state="translated">sum0</target>
        </trans-unit>
        <trans-unit id="88d8dc26e91d5c2c0f7f30a117afb59c4fee6579" translate="yes" xml:space="preserve">
          <source>sunds@asictest.sc.ti.com</source>
          <target state="translated">sunds@asictest.sc.ti.com</target>
        </trans-unit>
        <trans-unit id="710909e48995b01d80cf75d091da54473bf5cb4f" translate="yes" xml:space="preserve">
          <source>suntar</source>
          <target state="translated">suntar</target>
        </trans-unit>
        <trans-unit id="e50b96444800ecf6eec36732f694781a4da0a0c1" translate="yes" xml:space="preserve">
          <source>supplied in the binary distribution), you need to follow the syntax specified in &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;Command Switches in perlrun&lt;/a&gt;.</source>
          <target state="translated">（在二进制发行版中提供），您需要遵循&lt;a href=&quot;perlrun#Command-Switches&quot;&gt;perlrun&lt;/a&gt;中&amp;ldquo; 命令开关&amp;rdquo;中指定的语法。</target>
        </trans-unit>
        <trans-unit id="5c1510fd6d0fcd8311c7e14dad06bd66bf0fa3bb" translate="yes" xml:space="preserve">
          <source>supplies a constant method name; it must be a shared COW string. Supported optypes: OP_METHOD_NAMED.</source>
          <target state="translated">提供一个常量方法名,它必须是一个共享的COW字符串。支持的optypes。OP_METHOD_NAMED。</target>
        </trans-unit>
        <trans-unit id="bb41dc1b2398adba08e8036114097d5a46866fe0" translate="yes" xml:space="preserve">
          <source>supplies a scalar context.</source>
          <target state="translated">提供一个标量上下文。</target>
        </trans-unit>
        <trans-unit id="67b616efdb07b97c3465690c9eca99ce8963969d" translate="yes" xml:space="preserve">
          <source>supplies a scalar context. But the following declares only one variable:</source>
          <target state="translated">提供一个标量上下文。但下面只声明了一个变量。</target>
        </trans-unit>
        <trans-unit id="933c89c5f6e634b4c9c2db8f2102e1f3da1f8414" translate="yes" xml:space="preserve">
          <source>supplies an op which evaluates method name; it is consumed by this function and become part of the constructed op tree. Supported optypes: OP_METHOD.</source>
          <target state="translated">提供一个计算方法名的 op,它被函数消耗并成为构造的 op 树的一部分。支持的op类型。OP_METHOD.</target>
        </trans-unit>
        <trans-unit id="3b33802543ff3a4fc14e1b17a45b1fe7c0ef8182" translate="yes" xml:space="preserve">
          <source>supplies an optional op to be the direct child of the unary op; it is consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">提供一个可选的 op,作为 unary op 的直接子函数;它被该函数消耗,成为构造的 op 树的一部分。</target>
        </trans-unit>
        <trans-unit id="39c192e97bd3454aecd66cb7b0a5db494f3caacd" translate="yes" xml:space="preserve">
          <source>supplies the C-level pointer, which must have been allocated using &lt;code&gt;PerlMemShared_malloc&lt;/code&gt; ; the memory will be freed when the op is destroyed.</source>
          <target state="translated">提供C级指针，该指针必须已经使用 &lt;code&gt;PerlMemShared_malloc&lt;/code&gt; 分配了；操作销毁后，内存将被释放。</target>
        </trans-unit>
        <trans-unit id="fbde2aabbb9071eec9811c89a64b364c289bb70b" translate="yes" xml:space="preserve">
          <source>supplies the block that will be executed if the test evaluates to true; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">提供了如果测试值为真时将被执行的块;它们被该函数消耗并成为构造的运算树的一部分。</target>
        </trans-unit>
        <trans-unit id="3b54f30d9a3501f63fdf1d5e1cbe966dbb72f290" translate="yes" xml:space="preserve">
          <source>supplies the body of the &lt;code&gt;given&lt;/code&gt; construct; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">提供 &lt;code&gt;given&lt;/code&gt; 结构的主体；它们被该功能消耗，并成为已构建的操作树的一部分。</target>
        </trans-unit>
        <trans-unit id="386ba25d3f00fcac706478c7828c082d00ee683a" translate="yes" xml:space="preserve">
          <source>supplies the body of the loop; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">提供循环的主体;它们被这个函数消耗,成为构造的op树的一部分。</target>
        </trans-unit>
        <trans-unit id="fc80cb2b22ab2b5fec7d8694b53c099ccff06104" translate="yes" xml:space="preserve">
          <source>supplies the expression controlling loop iteration, and</source>
          <target state="translated">提供控制循环迭代的表达式,以及</target>
        </trans-unit>
        <trans-unit id="61d5c314b7d12e8ae116f80dc72c292591d27e13" translate="yes" xml:space="preserve">
          <source>supplies the expression controlling the flow, and</source>
          <target state="translated">提供控制流量的表达式,以及</target>
        </trans-unit>
        <trans-unit id="c1e0d2b57ee87057e0548f8357c19a29361d989a" translate="yes" xml:space="preserve">
          <source>supplies the expression selecting between the two branches, and</source>
          <target state="translated">提供了在两个分支之间选择的表达式,以及</target>
        </trans-unit>
        <trans-unit id="b4fbbc3cd37cb7bf4e5e35a91e68c31c0d6c8c32" translate="yes" xml:space="preserve">
          <source>supplies the expression that will be locally assigned to a lexical variable, and</source>
          <target state="translated">提供将在本地分配给一个词法变量的表达式,而</target>
        </trans-unit>
        <trans-unit id="5b82a63c35e5a1e34e24f2280fe8c5767ba58cc4" translate="yes" xml:space="preserve">
          <source>supplies the list of values to iterate over.</source>
          <target state="translated">提供要遍历的值的列表。</target>
        </trans-unit>
        <trans-unit id="53e35637bee3034f1a757673311c9b320e9692bb" translate="yes" xml:space="preserve">
          <source>supplies the loop's controlling expression.</source>
          <target state="translated">提供循环的控制表达式。</target>
        </trans-unit>
        <trans-unit id="dccde9799aebcb5135581021583fc0ea950a3848" translate="yes" xml:space="preserve">
          <source>supplies the main body of the loop, and</source>
          <target state="translated">供应环路的主体,以及</target>
        </trans-unit>
        <trans-unit id="5c4d56d04eec48a3e496e124a63806cd67c55f9e" translate="yes" xml:space="preserve">
          <source>supplies the name that should be used by the check function to refer to the callee of the &lt;code&gt;entersub&lt;/code&gt; op if it needs to emit any diagnostics. It is permitted to apply the check function in non-standard situations, such as to a call to a different subroutine or to a method call.</source>
          <target state="translated">提供了check函数应该使用的名称，以便在需要发出任何诊断信息时引用 &lt;code&gt;entersub&lt;/code&gt; op 的被调用方。允许在非标准情况下应用检查功能，例如，对其他子例程的调用或对方法的调用。</target>
        </trans-unit>
        <trans-unit id="89932dca862c5f9e322348fa88b913ec514806ce" translate="yes" xml:space="preserve">
          <source>supplies the parameter determining the target of the op; it is consumed by this function and becomes part of the constructed op tree.</source>
          <target state="translated">提供了决定 op 目标的参数;它被该函数消耗,成为构造的 op 树的一部分。</target>
        </trans-unit>
        <trans-unit id="3cd2bc227f0480cf175bcd8e2f6e52bc74c4fb70" translate="yes" xml:space="preserve">
          <source>supplies the prototype of the function: its code, pad structure, and other attributes. The prototype is combined with a capture of outer lexicals to which the code refers, which are taken from the currently-executing instance of the immediately surrounding code.</source>
          <target state="translated">提供了函数的原型:它的代码、焊盘结构和其他属性。原型与代码所指向的外部词汇的捕获相结合,这些词汇来自当前正在执行的紧邻代码的实例。</target>
        </trans-unit>
        <trans-unit id="95a7e97ffdcc6e850084abeb7f7dd799d028d9c8" translate="yes" xml:space="preserve">
          <source>supplies the remainder of the source.</source>
          <target state="translated">供应源的其余部分。</target>
        </trans-unit>
        <trans-unit id="e86bbb1d3fa5335e2ddd651e4551e6b24badd33f" translate="yes" xml:space="preserve">
          <source>supplies the side (alternate) chain of ops; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">提供侧(备用)操作链;它们被该函数消耗并成为构造的操作树的一部分。</target>
        </trans-unit>
        <trans-unit id="dce53627503fb602891cc0400d01773b2d72a730" translate="yes" xml:space="preserve">
          <source>supplies the subroutine prototype to be applied to the call, or indicates that there is no prototype. It may be a normal scalar, in which case if it is defined then the string value will be used as a prototype, and if it is undefined then there is no prototype. Alternatively, for convenience, it may be a subroutine object (a &lt;code&gt;CV*&lt;/code&gt; that has been cast to &lt;code&gt;SV*&lt;/code&gt; ), of which the prototype will be used if it has one. The prototype (or lack thereof) supplied, in whichever form, does not need to match the actual callee referenced by the op tree.</source>
          <target state="translated">提供要应用于该调用的子例程原型，或者指示没有原型。它可能是普通标量，在这种情况下，如果定义了该值，则字符串值将用作原型；如果未定义，则不存在原型。另外，为方便起见，它可能是子例程对象（已转换为 &lt;code&gt;SV*&lt;/code&gt; 的 &lt;code&gt;CV*&lt;/code&gt; *），如果有原型，则将使用其原型。以任何形式提供的原型（或缺少原型）都不需要与op树引用的实际被调用方匹配。</target>
        </trans-unit>
        <trans-unit id="b59ae3b289a0c71fcc267eb12f8eefe2bfc7f4f0" translate="yes" xml:space="preserve">
          <source>supplies the subroutine prototype to be applied to the call. It may be a normal defined scalar, of which the string value will be used. Alternatively, for convenience, it may be a subroutine object (a &lt;code&gt;CV*&lt;/code&gt; that has been cast to &lt;code&gt;SV*&lt;/code&gt; ) which has a prototype. The prototype supplied, in whichever form, does not need to match the actual callee referenced by the op tree.</source>
          <target state="translated">提供要应用于该调用的子例程原型。它可以是标准定义的标量，将使用字符串值。另外，为方便起见，它可能是具有原型的子例程对象（已转换为 &lt;code&gt;SV*&lt;/code&gt; 的 &lt;code&gt;CV*&lt;/code&gt; *）。提供的原型以任何形式都不需要匹配op树引用的实际被调用方。</target>
        </trans-unit>
        <trans-unit id="261f10d115d93cba3ad204b2cdb1cfa33c1909b0" translate="yes" xml:space="preserve">
          <source>supplies the test expression, and</source>
          <target state="translated">提供测试表达式,而</target>
        </trans-unit>
        <trans-unit id="49ca365c7a662f2fb7b2b700c4565b2a8df4a3e6" translate="yes" xml:space="preserve">
          <source>supply the branches; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">提供分支;它们被这个函数消耗,成为构造的op树的一部分。</target>
        </trans-unit>
        <trans-unit id="276438cc69a199ed3efd23b2780b03ecd8482b20" translate="yes" xml:space="preserve">
          <source>supply the expressions controlling the endpoints of the range; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">提供控制范围端点的表达式;它们被该函数消耗,成为构造的运算树的一部分。</target>
        </trans-unit>
        <trans-unit id="feed11b722d6590561e7a3eae42ae547bbdeb0ac" translate="yes" xml:space="preserve">
          <source>supply the parameters of the assignment; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">提供赋值的参数;它们被该函数消耗,成为构造的运算树的一部分。</target>
        </trans-unit>
        <trans-unit id="cf0db103b0f4ba44f838eaa30af4fbcda3dc6051" translate="yes" xml:space="preserve">
          <source>supply the parameters of the slice; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">提供切片的参数;它们被该函数消耗,成为构造的运算树的一部分。</target>
        </trans-unit>
        <trans-unit id="43250c0b01630df5961aade1f437a2ddd9f1e6f7" translate="yes" xml:space="preserve">
          <source>supply up to two ops to be direct children of the list op; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">提供最多两个操作作为列表操作的直接子代,它们被该函数消耗并成为构造的操作树的一部分。</target>
        </trans-unit>
        <trans-unit id="8494c6478c26491ae2fba064a9716c40d97db065" translate="yes" xml:space="preserve">
          <source>supply up to two ops to be the direct children of the binary op; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">提供最多两个操作,作为二进制操作的直接子代;它们被该函数消耗,成为构造的操作树的一部分。</target>
        </trans-unit>
        <trans-unit id="8c6e0711286fd2ac6c8125bae8cb887b7f4566b1" translate="yes" xml:space="preserve">
          <source>support yet.</source>
          <target state="translated">支持尚未。</target>
        </trans-unit>
        <trans-unit id="f50c937ac0b3408d972fde532e7c1747c54283c4" translate="yes" xml:space="preserve">
          <source>supports Perl versions from 5.003 to 5.20 in threaded and non-threaded configurations.</source>
          <target state="translated">在有线程和无线程的配置下,支持Perl 5.003到5.20的版本。</target>
        </trans-unit>
        <trans-unit id="57d058868c63f0b52e6ab62577cbd58701ac11d0" translate="yes" xml:space="preserve">
          <source>supports long doubles (12 bytes). However, several additional long double math functions are necessary to use them within Perl (</source>
          <target state="translated">支持长双数(12 字节)。然而,要在Perl中使用它们,还需要几个额外的长双数数学函数(</target>
        </trans-unit>
        <trans-unit id="9ac847bd073d24a33c5464b281e0db2bf06a41ef" translate="yes" xml:space="preserve">
          <source>supposed to be treated normally. Which characters are to be treated specially as metacharacters varies greatly from context to context. Your &lt;b&gt;shell&lt;/b&gt; will have certain metacharacters, double-quoted Perl &lt;b&gt;strings&lt;/b&gt; have other metacharacters, and &lt;b&gt;regular expression&lt;/b&gt; patterns have all the double-quote metacharacters plus some extra ones of their own.</source>
          <target state="translated">应该得到正常治疗。哪些字符将被特别视为元字符，因上下文而异。您的&lt;b&gt;外壳&lt;/b&gt;将具有某些元字符，带双引号的Perl &lt;b&gt;字符串&lt;/b&gt;具有其他元字符，并且&lt;b&gt;正则表达式&lt;/b&gt;模式具有所有双引号元字符以及它们自己的一些额外字符。</target>
        </trans-unit>
        <trans-unit id="3246144a36566f1fea3eeaf4af473c1eb1e160ad" translate="yes" xml:space="preserve">
          <source>sure no one will ever want to use your code on a non-ASCII platform. Starting in Perl v5.22, calls to it on ASCII platforms are optimized out, so there's no performance penalty at all in adding it. Or you can simply use the other constructs that don't require it.</source>
          <target state="translated">确保没有人愿意在非 ASCII 平台上使用你的代码。从 Perl v5.22 开始,在 ASCII 平台上对它的调用已经被优化掉了,所以添加它不会有任何性能上的损失。或者你可以直接使用其他不需要它的构造。</target>
        </trans-unit>
        <trans-unit id="60dad2979bb9769c615fca37ac2fd3f5b69bfd73" translate="yes" xml:space="preserve">
          <source>surrogate pair</source>
          <target state="translated">代孕对</target>
        </trans-unit>
        <trans-unit id="7a92ecd20fec541443895aab5fc8266242f2bfa3" translate="yes" xml:space="preserve">
          <source>surrogate pairs</source>
          <target state="translated">代孕对</target>
        </trans-unit>
        <trans-unit id="b0134bd3893d0bc62d53f4846d15e6c877818c93" translate="yes" xml:space="preserve">
          <source>surrogates</source>
          <target state="translated">surrogates</target>
        </trans-unit>
        <trans-unit id="2aba9cbc844313bac08f8a99c304485574c65476" translate="yes" xml:space="preserve">
          <source>surrounded by</source>
          <target state="translated">四周</target>
        </trans-unit>
        <trans-unit id="0899ba1484ec8bdf0e19ff52c695e70ccdff2f28" translate="yes" xml:space="preserve">
          <source>suspects</source>
          <target state="translated">suspects</target>
        </trans-unit>
        <trans-unit id="b6f0c43f69fad2bd2df597f8c1f9289bf8ebf0a2" translate="yes" xml:space="preserve">
          <source>suspend</source>
          <target state="translated">suspend</target>
        </trans-unit>
        <trans-unit id="0a6190df9675de3c18b12fd3fc97648581780661" translate="yes" xml:space="preserve">
          <source>sv</source>
          <target state="translated">sv</target>
        </trans-unit>
        <trans-unit id="4167b98037f232f9707fdc8e12ffe855560656d2" translate="yes" xml:space="preserve">
          <source>sv.c</source>
          <target state="translated">sv.c</target>
        </trans-unit>
        <trans-unit id="351327455dde4d5627bbfd064b4140b27e6b13c6" translate="yes" xml:space="preserve">
          <source>sv.c.gcov</source>
          <target state="translated">sv.c.gcov</target>
        </trans-unit>
        <trans-unit id="ade3217578be1546a1b2a6827e4b13aa6d48d141" translate="yes" xml:space="preserve">
          <source>swap</source>
          <target state="translated">swap</target>
        </trans-unit>
        <trans-unit id="119ea8efe7cf5f360bf61b98304628fcf9561388" translate="yes" xml:space="preserve">
          <source>switch. If</source>
          <target state="translated">开关。如果</target>
        </trans-unit>
        <trans-unit id="4ddcd899e3a665a4c256ed0027578627191a6538" translate="yes" xml:space="preserve">
          <source>symbian/README</source>
          <target state="translated">symbian/README</target>
        </trans-unit>
        <trans-unit id="e6b784e0d86036408dc0e6e95997db41cc7044f1" translate="yes" xml:space="preserve">
          <source>symbian/TODO</source>
          <target state="translated">symbian/TODO</target>
        </trans-unit>
        <trans-unit id="d4f839b54fa310d171f4bea87426a6ad792eed38" translate="yes" xml:space="preserve">
          <source>symbian/config.sh</source>
          <target state="translated">symbian/config.sh</target>
        </trans-unit>
        <trans-unit id="bb31235f86ec74784e4ba03ef93781603ddc7690" translate="yes" xml:space="preserve">
          <source>symbian\config.pl</source>
          <target state="translated">symbian\config.pl</target>
        </trans-unit>
        <trans-unit id="06f9b0facd2dfc678efcc6e3cc423ec6633a5623" translate="yes" xml:space="preserve">
          <source>symbolic</source>
          <target state="translated">symbolic</target>
        </trans-unit>
        <trans-unit id="8217d9e6e8b6c267382c8ea8fb35416350f71980" translate="yes" xml:space="preserve">
          <source>symbolic reference</source>
          <target state="translated">参考文献</target>
        </trans-unit>
        <trans-unit id="3b7aed21a4dfc14581cb1ebfa269455b383b8369" translate="yes" xml:space="preserve">
          <source>symbolic.pm</source>
          <target state="translated">symbolic.pm</target>
        </trans-unit>
        <trans-unit id="b282128e9f472cade38f541670d05c997f5edf7a" translate="yes" xml:space="preserve">
          <source>symlink</source>
          <target state="translated">symlink</target>
        </trans-unit>
        <trans-unit id="591e699a63659714471ab440c4a1a73661f5761d" translate="yes" xml:space="preserve">
          <source>symlink OLDFILE,NEWFILE</source>
          <target state="translated">符号链接OLDFILE,NEWFILE</target>
        </trans-unit>
        <trans-unit id="fda22ac0b555bc0ceca6a0a60cd133986cffbc5f" translate="yes" xml:space="preserve">
          <source>symmetric difference</source>
          <target state="translated">对称差</target>
        </trans-unit>
        <trans-unit id="1d260b870cb7b1e776ab4d6ddb6d6740ec7c8b51" translate="yes" xml:space="preserve">
          <source>syntactically</source>
          <target state="translated">syntactically</target>
        </trans-unit>
        <trans-unit id="c9a99c9c1c389927fb79a3bd444e10e4f3f91677" translate="yes" xml:space="preserve">
          <source>syntax &lt;code&gt;&amp;lt;$var&amp;gt;&lt;/code&gt; and</source>
          <target state="translated">语法 &lt;code&gt;&amp;lt;$var&amp;gt;&lt;/code&gt; 和</target>
        </trans-unit>
        <trans-unit id="3540e626f064a80d72c15fb4736d5189f7091bde" translate="yes" xml:space="preserve">
          <source>syntax &lt;code&gt;&amp;lt;${var}&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">语法 &lt;code&gt;&amp;lt;${var}&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c4f85fcddbb9d4aafff48a6f33e59be855c88b3" translate="yes" xml:space="preserve">
          <source>syntax error</source>
          <target state="translated">句法错误</target>
        </trans-unit>
        <trans-unit id="35dddcaea633fd2c905d552fbf07e741cc4ac346" translate="yes" xml:space="preserve">
          <source>sys/ioctl.ph</source>
          <target state="translated">sys/ioctl.ph</target>
        </trans-unit>
        <trans-unit id="fa1d4b596386e46fdb9e2f76a44d26eb373c2ad4" translate="yes" xml:space="preserve">
          <source>sys/mount.h</source>
          <target state="translated">sys/mount.h</target>
        </trans-unit>
        <trans-unit id="f6e092e7415b3e9bb613389f2837e1e04090ed3c" translate="yes" xml:space="preserve">
          <source>sys/param.h</source>
          <target state="translated">sys/param.h</target>
        </trans-unit>
        <trans-unit id="7f404f2c9c6977d56171c76a5aaa4f21c1ed0191" translate="yes" xml:space="preserve">
          <source>sys/shm.h</source>
          <target state="translated">sys/shm.h</target>
        </trans-unit>
        <trans-unit id="4d146410ad4f7b43d4d468be07418dbf46020585" translate="yes" xml:space="preserve">
          <source>sys/statfs.h</source>
          <target state="translated">sys/statfs.h</target>
        </trans-unit>
        <trans-unit id="783ee8b47e33ccf886c07946f0a74af226d1a8b9" translate="yes" xml:space="preserve">
          <source>sys/un.h</source>
          <target state="translated">sys/un.h</target>
        </trans-unit>
        <trans-unit id="66290592fca9d25372168ea6386e64cac4dc40e3" translate="yes" xml:space="preserve">
          <source>sys:\Perl</source>
          <target state="translated">sys:\Perl</target>
        </trans-unit>
        <trans-unit id="341b0b4c78cf0c5e3aa256cfd9905f0ea8a551eb" translate="yes" xml:space="preserve">
          <source>sys:\perl\system</source>
          <target state="translated">sys:\perl\system</target>
        </trans-unit>
        <trans-unit id="4a23474c62a33cb53f128847252503120f2da803" translate="yes" xml:space="preserve">
          <source>sys:\system</source>
          <target state="translated">sys:\system</target>
        </trans-unit>
        <trans-unit id="d7cbea74df93b67d6611b9ce87cf4f9a6b0c258f" translate="yes" xml:space="preserve">
          <source>syscall</source>
          <target state="translated">syscall</target>
        </trans-unit>
        <trans-unit id="2d721dd599bf9f7efe4139c8e55b4488c7c8731b" translate="yes" xml:space="preserve">
          <source>syscall NUMBER, LIST</source>
          <target state="translated">syscall NUMBER,LIST</target>
        </trans-unit>
        <trans-unit id="4545606e0a81be230767d641a85d5093e11d9aee" translate="yes" xml:space="preserve">
          <source>syscall.h</source>
          <target state="translated">syscall.h</target>
        </trans-unit>
        <trans-unit id="0009f423fd8c556aae96a7fb362d2f8b60f12691" translate="yes" xml:space="preserve">
          <source>sysconf() function. If this is a possibility, each directory in the path is checked in turn for safeness, recursively walking back to the root directory.</source>
          <target state="translated">sysconf()函数。如果有这种可能性,则依次检查路径中的每个目录是否安全,递归走回根目录。</target>
        </trans-unit>
        <trans-unit id="dc3ab98bfbf4b4509cbf370fd445674ef17da0cd" translate="yes" xml:space="preserve">
          <source>syslog(3)</source>
          <target state="translated">syslog(3)</target>
        </trans-unit>
        <trans-unit id="2705412b5383de38b034f8c0d6ce583dae807d9c" translate="yes" xml:space="preserve">
          <source>syslog.ph</source>
          <target state="translated">syslog.ph</target>
        </trans-unit>
        <trans-unit id="4be85e443ee56ff14d2c333ccc70eda9e7ba9ed1" translate="yes" xml:space="preserve">
          <source>sysman.U</source>
          <target state="translated">sysman.U</target>
        </trans-unit>
        <trans-unit id="a12380cce4f1fed0e70dde8b07f53bd9459b698f" translate="yes" xml:space="preserve">
          <source>sysopen</source>
          <target state="translated">sysopen</target>
        </trans-unit>
        <trans-unit id="4787eb13ee480169b313b635bddada9ad931c8e5" translate="yes" xml:space="preserve">
          <source>sysopen FILEHANDLE,FILENAME,MODE</source>
          <target state="translated">sysopen FILEHANDLE,FILENAME,MODE。</target>
        </trans-unit>
        <trans-unit id="4c1420b8cd8bb3efd6fb3fb61369d7345e3fc78e" translate="yes" xml:space="preserve">
          <source>sysopen FILEHANDLE,FILENAME,MODE,PERMS</source>
          <target state="translated">sysopen FILEHANDLE,FILENAME,MODE,PERMS。</target>
        </trans-unit>
        <trans-unit id="4fbd3fedd6187ac2cd8e58ce04d22e34ef544a8c" translate="yes" xml:space="preserve">
          <source>sysopen() operates (unsurprisingly) at a lower level in the stack than open(). For example in Unix or Unix-like systems sysopen() operates directly at the level of file descriptors: in the terms of PerlIO layers, it uses only the &quot;unix&quot; layer, which is a rather thin wrapper on top of the Unix file descriptors.</source>
          <target state="translated">sysopen()比open()在堆栈的较低层次上操作(毫不奇怪)。例如在Unix或类似Unix的系统中,sysopen()直接在文件描述符的层次上操作:在PerlIO层的术语中,它只使用 &quot;unix &quot;层,它是Unix文件描述符之上的一个相当薄的包装。</target>
        </trans-unit>
        <trans-unit id="07ada4381247db645f430708361ebf3855c33687" translate="yes" xml:space="preserve">
          <source>sysread</source>
          <target state="translated">sysread</target>
        </trans-unit>
        <trans-unit id="e65d3193feed181d232efe689dce3350eb1f3c5c" translate="yes" xml:space="preserve">
          <source>sysread FILEHANDLE,SCALAR,LENGTH</source>
          <target state="translated">sysread FILEHANDLE,SCALAR,LENGTH。</target>
        </trans-unit>
        <trans-unit id="75c76a4f6be568624e87183a3151c781d03826f9" translate="yes" xml:space="preserve">
          <source>sysread FILEHANDLE,SCALAR,LENGTH,OFFSET</source>
          <target state="translated">sysread FILEHANDLE,SCALAR,LENGTH,OFFSET。</target>
        </trans-unit>
        <trans-unit id="304681ee42f0eba7ccba17a001425e45b09c7497" translate="yes" xml:space="preserve">
          <source>sysseek</source>
          <target state="translated">sysseek</target>
        </trans-unit>
        <trans-unit id="83c1d37a632e2e38fc094f4858eb94e603659ce9" translate="yes" xml:space="preserve">
          <source>sysseek FILEHANDLE,POSITION,WHENCE</source>
          <target state="translated">SYSSEEK FILEHANDLE,POSITION,WHENCE。</target>
        </trans-unit>
        <trans-unit id="d7668815a85c1035fd99f4ecbb6d385417fc2e73" translate="yes" xml:space="preserve">
          <source>sysseek() bypasses normal buffered IO, so mixing it with reads other than &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; (for example &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; or read()) &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion.</source>
          <target state="translated">sysseek（）绕过正常的缓冲IO，因此将其与 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 以外的其他读取（例如 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 或read（））混合使用 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 可能会造成混乱。</target>
        </trans-unit>
        <trans-unit id="45611416cc3031d66c8afdfb344421333c1cc8c2" translate="yes" xml:space="preserve">
          <source>sysseek() bypasses normal buffered IO, so mixing it with reads other than &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; (for example &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; or read()) &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion.</source>
          <target state="translated">sysseek（）绕过正常的缓冲IO，因此将其与 &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 以外的其他读取（例如 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 或read（））混合使用 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 可能会造成混乱。</target>
        </trans-unit>
        <trans-unit id="317f1e761f2faa8da781a4762b9dcc2c5cad209a" translate="yes" xml:space="preserve">
          <source>system</source>
          <target state="translated">system</target>
        </trans-unit>
        <trans-unit id="dceea694ca2d34f416959e52db08f905f267df2f" translate="yes" xml:space="preserve">
          <source>system LIST</source>
          <target state="translated">系统列表</target>
        </trans-unit>
        <trans-unit id="568ba46c449d31b288ecb379c56e0ad3eb6c2b4d" translate="yes" xml:space="preserve">
          <source>system PROGRAM LIST</source>
          <target state="translated">系统程序列表</target>
        </trans-unit>
        <trans-unit id="854f3d75247050945cc3d0feda0bc17cd37d0ffe" translate="yes" xml:space="preserve">
          <source>system call),</source>
          <target state="translated">系统调用)。)</target>
        </trans-unit>
        <trans-unit id="f6bcb19c9c9bf6848b258d824185d881f9f2bf92" translate="yes" xml:space="preserve">
          <source>system malloc().</source>
          <target state="translated">系统malloc()。</target>
        </trans-unit>
        <trans-unit id="442b66e780a7ea69ca491b81816b380896f9ce12" translate="yes" xml:space="preserve">
          <source>system time</source>
          <target state="translated">系统时间</target>
        </trans-unit>
        <trans-unit id="c32e251015d1274fbaa35f79158261c5aae1ceae" translate="yes" xml:space="preserve">
          <source>system()</source>
          <target state="translated">system()</target>
        </trans-unit>
        <trans-unit id="d9a846494d49f26dc29c6fac98d2f2d5a0c06b34" translate="yes" xml:space="preserve">
          <source>system, any clocks and timers will be imprecise, especially so if you are working in a pre-emptive multiuser system. Understand the difference between</source>
          <target state="translated">系统,任何时钟和定时器都将是不精确的,尤其是当你在一个先发制人的多用户系统中工作时更是如此。理解两者的区别</target>
        </trans-unit>
        <trans-unit id="e25c2a11e92a207ae0e29b09f80156162671bdf1" translate="yes" xml:space="preserve">
          <source>system/exec</source>
          <target state="translated">system/exec</target>
        </trans-unit>
        <trans-unit id="4d9523f4dcf8348b3ea80ad6dbace327ea62be3d" translate="yes" xml:space="preserve">
          <source>syswrite</source>
          <target state="translated">syswrite</target>
        </trans-unit>
        <trans-unit id="7bb5b35c4b0c54818135f2c7049ab72e94211174" translate="yes" xml:space="preserve">
          <source>syswrite FILEHANDLE,SCALAR</source>
          <target state="translated">syswrite FILEHANDLE,SCALAR...。</target>
        </trans-unit>
        <trans-unit id="403d98d06f5d49aadde890226fda0bb63c8906d7" translate="yes" xml:space="preserve">
          <source>syswrite FILEHANDLE,SCALAR,LENGTH</source>
          <target state="translated">syswrite FILEHANDLE,SCALAR,LENGTH。</target>
        </trans-unit>
        <trans-unit id="b4439105bf641cc33e0e27376f6c1c00352f8653" translate="yes" xml:space="preserve">
          <source>syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET</source>
          <target state="translated">syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET。</target>
        </trans-unit>
        <trans-unit id="8efd86fb78a56a5145ed7739dcb00c78581c5375" translate="yes" xml:space="preserve">
          <source>t</source>
          <target state="translated">t</target>
        </trans-unit>
        <trans-unit id="5803be03c07dec623c10871bddf83fa1a67341be" translate="yes" xml:space="preserve">
          <source>t/</source>
          <target state="translated">t/</target>
        </trans-unit>
        <trans-unit id="ee32657b3853ea5d4d1670ab32e6838c58649a19" translate="yes" xml:space="preserve">
          <source>t/00compile.t</source>
          <target state="translated">t/00compile.t</target>
        </trans-unit>
        <trans-unit id="016c131011f5ed722060f71107c0a10476a50817" translate="yes" xml:space="preserve">
          <source>t/TEST</source>
          <target state="translated">t/TEST</target>
        </trans-unit>
        <trans-unit id="e3e6c5553377ad0a37c1ffc0f6a17cc0e4b6f1ac" translate="yes" xml:space="preserve">
          <source>t/bar.t</source>
          <target state="translated">t/bar.t</target>
        </trans-unit>
        <trans-unit id="f76303257eb4699503af2247b4b761a701c7d5fe" translate="yes" xml:space="preserve">
          <source>t/base</source>
          <target state="translated">t/base</target>
        </trans-unit>
        <trans-unit id="424df0294680ae7d16ff6cd26441e5860a8ed592" translate="yes" xml:space="preserve">
          <source>t/baz.t</source>
          <target state="translated">t/baz.t</target>
        </trans-unit>
        <trans-unit id="4b9d7747567ab3d4648e2b09ef21537b8c0742e9" translate="yes" xml:space="preserve">
          <source>t/bigmem/</source>
          <target state="translated">t/bigmem/</target>
        </trans-unit>
        <trans-unit id="e631ee7a25fffad8c78393ce1420fa1fece1eb4c" translate="yes" xml:space="preserve">
          <source>t/charset_tools.pl</source>
          <target state="translated">t/charset_tools.pl</target>
        </trans-unit>
        <trans-unit id="f6d93b7b01a8e1b5601426c2b2c860d6a688dcc3" translate="yes" xml:space="preserve">
          <source>t/cmd</source>
          <target state="translated">t/cmd</target>
        </trans-unit>
        <trans-unit id="4e4e7621a9ecf0aa721716a241ff936621e1745a" translate="yes" xml:space="preserve">
          <source>t/comp</source>
          <target state="translated">t/comp</target>
        </trans-unit>
        <trans-unit id="da64a82ccf4f15dc335eec9d8a5562ddfc8d56c1" translate="yes" xml:space="preserve">
          <source>t/foo.t</source>
          <target state="translated">t/foo.t</target>
        </trans-unit>
        <trans-unit id="bd919ec3c418f4ac67b6e4ba5e73c676e39055d5" translate="yes" xml:space="preserve">
          <source>t/harness</source>
          <target state="translated">t/harness</target>
        </trans-unit>
        <trans-unit id="e1ec93346a387203f7effcdd1140428bd2ede5fa" translate="yes" xml:space="preserve">
          <source>t/io</source>
          <target state="translated">t/io</target>
        </trans-unit>
        <trans-unit id="35a315d28b2dc3fe449b8e299312a0950ea4fc61" translate="yes" xml:space="preserve">
          <source>t/io/fs.t</source>
          <target state="translated">t/io/fs.t</target>
        </trans-unit>
        <trans-unit id="d1c6620bff42ece36d97d026673254c65b674807" translate="yes" xml:space="preserve">
          <source>t/io/tell.t: Subtest 27 is failing. We are still investigating.</source>
          <target state="translated">t/io/tell.t:次测试27失败。我们仍在调查。</target>
        </trans-unit>
        <trans-unit id="21c2765f64e902f1eba2b7fa3bada80c6d3df699" translate="yes" xml:space="preserve">
          <source>t/lib/posix.t</source>
          <target state="translated">t/lib/posix.t</target>
        </trans-unit>
        <trans-unit id="fbb78755c57da1a3fb44a764f63e3b8c4f7adfdb" translate="yes" xml:space="preserve">
          <source>t/loc_tools.pl</source>
          <target state="translated">t/loc_tools.pl</target>
        </trans-unit>
        <trans-unit id="7d6e69712da3d67d7d06bcdbd1e0b862cb8e710c" translate="yes" xml:space="preserve">
          <source>t/mro</source>
          <target state="translated">t/mro</target>
        </trans-unit>
        <trans-unit id="68a9f264e91ff2cda2216e7130ef4807da5039af" translate="yes" xml:space="preserve">
          <source>t/mytest.t</source>
          <target state="translated">t/mytest.t</target>
        </trans-unit>
        <trans-unit id="54b4a1de3b24f1785e9c8144185b3a3644bedb60" translate="yes" xml:space="preserve">
          <source>t/op</source>
          <target state="translated">t/op</target>
        </trans-unit>
        <trans-unit id="c6ef3c15071f030077437030bb790555f4926475" translate="yes" xml:space="preserve">
          <source>t/op/</source>
          <target state="translated">t/op/</target>
        </trans-unit>
        <trans-unit id="34af4c076cb471c9be9f5451dadfb98625e1214e" translate="yes" xml:space="preserve">
          <source>t/op/pack.t</source>
          <target state="translated">t/op/pack.t</target>
        </trans-unit>
        <trans-unit id="3875953b6416be4c969e133db8a303297a260ab9" translate="yes" xml:space="preserve">
          <source>t/op/pack.t has a sensible ok() function, but if it didn't we could use the one from t/test.pl.</source>
          <target state="translated">t/op/pack.t有一个合理的ok()函数,但如果没有的话,我们可以使用t/test.pl的函数。</target>
        </trans-unit>
        <trans-unit id="c961927b2b9a6c7008e1916e3412ec3ae14c421c" translate="yes" xml:space="preserve">
          <source>t/op/pack.t~</source>
          <target state="translated">t/op/pack.t~</target>
        </trans-unit>
        <trans-unit id="20d04fa0a6c2c3fcf28a0352b9c3a34d69852d97" translate="yes" xml:space="preserve">
          <source>t/op/ref.t</source>
          <target state="translated">t/op/ref.t</target>
        </trans-unit>
        <trans-unit id="9ae690daefb740733f2a0bbdc6545df6de84b3bd" translate="yes" xml:space="preserve">
          <source>t/opbasic</source>
          <target state="translated">t/opbasic</target>
        </trans-unit>
        <trans-unit id="bf79631a18f7d933909b144eca32ca6dd9629744" translate="yes" xml:space="preserve">
          <source>t/perf/benchmarks</source>
          <target state="translated">t/perf/benchmarks</target>
        </trans-unit>
        <trans-unit id="8358e4410308554c4c4f2875a578685a4eaba637" translate="yes" xml:space="preserve">
          <source>t/perf/opcount.t</source>
          <target state="translated">t/perf/opcount.t</target>
        </trans-unit>
        <trans-unit id="0c7ca3dfae849cb7a4c6b36f2a65675c57dd647a" translate="yes" xml:space="preserve">
          <source>t/perf/speed.t</source>
          <target state="translated">t/perf/speed.t</target>
        </trans-unit>
        <trans-unit id="ba669aaaf039bcdd6bcfd75a726dc3118b0b20e2" translate="yes" xml:space="preserve">
          <source>t/perl.supp</source>
          <target state="translated">t/perl.supp</target>
        </trans-unit>
        <trans-unit id="3cf3a91d371ba2dbcee0ae2089496fadf026d232" translate="yes" xml:space="preserve">
          <source>t/porting/libperl.t</source>
          <target state="translated">t/porting/libperl.t</target>
        </trans-unit>
        <trans-unit id="4a89aad45864df97cfa9234b17eaf171075fbb25" translate="yes" xml:space="preserve">
          <source>t/re/speed.t</source>
          <target state="translated">t/re/speed.t</target>
        </trans-unit>
        <trans-unit id="f5fe7c8dfa39f3e5da7e23a84b14a12426c231eb" translate="yes" xml:space="preserve">
          <source>t/run</source>
          <target state="translated">t/run</target>
        </trans-unit>
        <trans-unit id="10190fe7b344dc9baf90d3ff5fefefac424d6eca" translate="yes" xml:space="preserve">
          <source>t/run/fresh_perl</source>
          <target state="translated">t/run/fresh_perl</target>
        </trans-unit>
        <trans-unit id="4d68fac0225a60482ebbf10a58fad6248bff10be" translate="yes" xml:space="preserve">
          <source>t/test.pl</source>
          <target state="translated">t/test.pl</target>
        </trans-unit>
        <trans-unit id="f8f9a8a8728847ce5ef1c0b6547c7fa8e7dd509a" translate="yes" xml:space="preserve">
          <source>t/test.t</source>
          <target state="translated">t/test.t</target>
        </trans-unit>
        <trans-unit id="818ef307ac2faa364a61ab49c2cb0f145f80e207" translate="yes" xml:space="preserve">
          <source>t/testrules.yml</source>
          <target state="translated">t/testrules.yml</target>
        </trans-unit>
        <trans-unit id="7f860db1a8b044397bcca547962b9b25178ffd30" translate="yes" xml:space="preserve">
          <source>t/uni</source>
          <target state="translated">t/uni</target>
        </trans-unit>
        <trans-unit id="9eacb4862221e4385a9f07398dd633ab1ad24621" translate="yes" xml:space="preserve">
          <source>taint checks</source>
          <target state="translated">污点检查</target>
        </trans-unit>
        <trans-unit id="380c7001d26889309c6bebb309431e810ba04153" translate="yes" xml:space="preserve">
          <source>taint mode</source>
          <target state="translated">污点模式</target>
        </trans-unit>
        <trans-unit id="de5ba98bdc71f7370934c9ddb55b4313c58a672b" translate="yes" xml:space="preserve">
          <source>tainted</source>
          <target state="translated">tainted</target>
        </trans-unit>
        <trans-unit id="64415fe9f8fd796c4e298baff1c7f87ff20ab108" translate="yes" xml:space="preserve">
          <source>taints</source>
          <target state="translated">taints</target>
        </trans-unit>
        <trans-unit id="53bd7d992ed7edf9a271056d254d8f7797462f27" translate="yes" xml:space="preserve">
          <source>take</source>
          <target state="translated">take</target>
        </trans-unit>
        <trans-unit id="ead9c1de852b36ad6a43cc16bf6c5fadd340e3e1" translate="yes" xml:space="preserve">
          <source>take a pointer to one of these structures as their first argument, with the name &lt;code&gt;pRExC_state&lt;/code&gt; . This structure is used to store the compilation state and contains many fields. Likewise there are many macros which operate on this variable: anything that looks like &lt;code&gt;RExC_xxxx&lt;/code&gt; is a macro that operates on this pointer/structure.</source>
          <target state="translated">将指向这些结构之一的指针作为第一个参数，名称为 &lt;code&gt;pRExC_state&lt;/code&gt; 。此结构用于存储编译状态，并且包含许多字段。同样，有许多宏在此变量上运行：看起来像 &lt;code&gt;RExC_xxxx&lt;/code&gt; 的任何事物都是在此指针/结构上运行的宏。</target>
        </trans-unit>
        <trans-unit id="14c150c786d9c122dcce02469ba16c110f538736" translate="yes" xml:space="preserve">
          <source>take away read permission, because the source code has to be readable in order to be compiled and interpreted. (That doesn't mean that a CGI script's source is readable by people on the web, though--only by people with access to the filesystem.) So you have to leave the permissions at the socially friendly 0755 level.</source>
          <target state="translated">取消读取权限,因为源代码必须是可读的才能被编译和解释。(这并不意味着一个CGI脚本的源代码可以被网络上的人读取--只有能够访问文件系统的人才能读取)。所以你必须把权限留在社会友好的0755级别。</target>
        </trans-unit>
        <trans-unit id="7086187cc2f49ad3d0fc7256140ce3bcc78fcfc3" translate="yes" xml:space="preserve">
          <source>take away read permission, because the source code has to be readable in order to be compiled and interpreted. (That doesn't mean that a CGI script's source is readable by people on the web, though.) So you have to leave the permissions at the socially friendly 0755 level. This lets people on your local system only see your source.</source>
          <target state="translated">取消读取权限,因为源代码必须是可读的才能被编译和解释。不过这并不意味着CGI脚本的源代码可以被网络上的人读取)。所以你必须把权限留在社会友好的0755级别。这让你本地系统上的人只能看到你的源代码。</target>
        </trans-unit>
        <trans-unit id="9612d40a7a23745c0940dd8566c84227f846409b" translate="yes" xml:space="preserve">
          <source>takes a pair of address and length of data at this address, so it is better to rewrite this function as</source>
          <target state="translated">在这个地址上取一对地址和长度的数据,所以最好把这个函数改写成</target>
        </trans-unit>
        <trans-unit id="fa377875a902e75fd09f473f871e8b460c9ae29b" translate="yes" xml:space="preserve">
          <source>takes two arguments which are input filehandle and output filehandle. Switches to use these filehandles.</source>
          <target state="translated">需要两个参数,分别是输入 filehandle 和输出 filehandle。切换使用这些文件柄。</target>
        </trans-unit>
        <trans-unit id="6ecf9b149669120d3138a2c22ea10d67174a079e" translate="yes" xml:space="preserve">
          <source>takes two parameters. The first, &lt;code&gt;sv&lt;/code&gt; , is an SV*. This allows you to specify the Perl subroutine to be called either as a C string (which has first been converted to an SV) or a reference to a subroutine. The section,</source>
          <target state="translated">有两个参数。第一个 &lt;code&gt;sv&lt;/code&gt; 是SV *。这使您可以指定将Perl子例程作为C字符串（已首先转换为SV）或对子例程的引用进行调用。这部分，</target>
        </trans-unit>
        <trans-unit id="d0b833e106b7a26b37dcbc250ed5c537f0eba48c" translate="yes" xml:space="preserve">
          <source>takes two positional parameters, which must be filled at runtime by two arguments. By default the parameters are mandatory, and it is not permitted to pass more arguments than expected. So the above is equivalent to</source>
          <target state="translated">取两个位置参数,在运行时必须由两个参数来填充。默认情况下,参数是强制性的,不允许传递比预期更多的参数。因此,上面相当于</target>
        </trans-unit>
        <trans-unit id="25f30d353d672994bc46f110e821d857b2525e65" translate="yes" xml:space="preserve">
          <source>tap</source>
          <target state="translated">tap</target>
        </trans-unit>
        <trans-unit id="680254bad1d7ca0d65ec46aaa315d363abf6a50a" translate="yes" xml:space="preserve">
          <source>tar</source>
          <target state="translated">tar</target>
        </trans-unit>
        <trans-unit id="d43c1ce91546a4ad0a5c0d689190bc2b6abb2c24" translate="yes" xml:space="preserve">
          <source>tar xvzpf perl-$VERSION-bin.tgz</source>
          <target state="translated">tar xvzpf perl-$VERSION-bin.tgz</target>
        </trans-unit>
        <trans-unit id="4d04586fe3fd2dca811b9680136d0aeb1ba69218" translate="yes" xml:space="preserve">
          <source>tar(1), &lt;a href=&quot;archive/tar&quot;&gt;Archive::Tar&lt;/a&gt;.</source>
          <target state="translated">tar（1），&lt;a href=&quot;archive/tar&quot;&gt;存档:: Tar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e8a3ad980ec179856012b7eecf4327e99cd44cd" translate="yes" xml:space="preserve">
          <source>target</source>
          <target state="translated">target</target>
        </trans-unit>
        <trans-unit id="80607933b393d425630df8feb65c2d3d2122453d" translate="yes" xml:space="preserve">
          <source>target of the generated Makefile copies the files found below each of the INST_* directories to their INSTALL* counterparts. Which counterparts are chosen depends on the setting of INSTALLDIRS according to the following table:</source>
          <target state="translated">生成的 Makefile 的目标将在 INST_*目录下找到的文件复制到 INSTALL*的对应目录中。选择哪些对应文件取决于 INSTALLDIRS 的设置,如下表所示。</target>
        </trans-unit>
        <trans-unit id="b68453cfafaf03d760bb9dc7658681aa08f3e49e" translate="yes" xml:space="preserve">
          <source>tassilo.von.parseval@rwth-aachen.de</source>
          <target state="translated">tassilo.von.parseval@rwth-aachen.de</target>
        </trans-unit>
        <trans-unit id="d61e3363def3f4e448c68105abdea736e4532873" translate="yes" xml:space="preserve">
          <source>tc</source>
          <target state="translated">tc</target>
        </trans-unit>
        <trans-unit id="0149c18dabcd96bae2f25a7e00ae9ecea78b9611" translate="yes" xml:space="preserve">
          <source>tcgrep</source>
          <target state="translated">tcgrep</target>
        </trans-unit>
        <trans-unit id="29c0d8eff9f163cb6a8896d13bbe15bb612a918a" translate="yes" xml:space="preserve">
          <source>tchrist (at) perl.com</source>
          <target state="translated">tchrist (at)perl.com.</target>
        </trans-unit>
        <trans-unit id="68a09c4b5159b8e368e5d1bceac981c56c50e973" translate="yes" xml:space="preserve">
          <source>tchrist@mox.perl.com</source>
          <target state="translated">tchrist@mox.perl.com</target>
        </trans-unit>
        <trans-unit id="496b57d4f5b2e6a3f4b8499a5536eb48d3ba5c9b" translate="yes" xml:space="preserve">
          <source>tchrist@perl.com</source>
          <target state="translated">tchrist@perl.com</target>
        </trans-unit>
        <trans-unit id="47b8015d98d5103a8a6981a979514855cac10ebc" translate="yes" xml:space="preserve">
          <source>tell</source>
          <target state="translated">tell</target>
        </trans-unit>
        <trans-unit id="a2e2d5e4967eb691adb3cb90a64f4254b2a1dc46" translate="yes" xml:space="preserve">
          <source>tell FILEHANDLE</source>
          <target state="translated">告诉PHILEHANDLE</target>
        </trans-unit>
        <trans-unit id="92794ee7e6ac81c9d0817ebf20684a58c197e63c" translate="yes" xml:space="preserve">
          <source>telldir</source>
          <target state="translated">telldir</target>
        </trans-unit>
        <trans-unit id="0b71e99628dd6430e7fea176d4129b7a8ec37b08" translate="yes" xml:space="preserve">
          <source>telldir DIRHANDLE</source>
          <target state="translated">telldir DIRHANDLE</target>
        </trans-unit>
        <trans-unit id="b0c0a02ffde3c44fa00b63c51cbb72effceae586" translate="yes" xml:space="preserve">
          <source>telling the class of the argument [C99].</source>
          <target state="translated">告诉争论的类[C99]。</target>
        </trans-unit>
        <trans-unit id="59b3aa384d6a9c476a221a2eda4917392e16c2d7" translate="yes" xml:space="preserve">
          <source>tells Perl that the program is embedded in a larger chunk of unrelated text, such as in a mail message. Leading garbage will be discarded until the first line that starts with &lt;code&gt;#!&lt;/code&gt; and contains the string &quot;perl&quot;. Any meaningful switches on that line will be applied.</source>
          <target state="translated">告诉Perl，该程序已嵌入到一大段无关的文本中，例如邮件中。前导垃圾将被丢弃，直到以 &lt;code&gt;#!&lt;/code&gt; 开头的第一行！并包含字符串&amp;ldquo; perl&amp;rdquo;。该行上任何有意义的开关都将被应用。</target>
        </trans-unit>
        <trans-unit id="22e9f56882c87c3da193be3fe6d8c77ffdaf27bc" translate="yes" xml:space="preserve">
          <source>telnet</source>
          <target state="translated">telnet</target>
        </trans-unit>
        <trans-unit id="e17be14d891796d29c88b561a3f5c6c8310bbdc3" translate="yes" xml:space="preserve">
          <source>temporarily makes $Here::blue an alias for $There::green, but doesn't make @Here::blue an alias for @There::green, or %Here::blue an alias for %There::green, etc. See &lt;a href=&quot;perlmod#Symbol-Tables&quot;&gt;Symbol Tables in perlmod&lt;/a&gt; for more examples of this. Strange though this may seem, this is the basis for the whole module import/export system.</source>
          <target state="translated">暂时使$ Here :: blue为$ There :: green的别名，但不会使@Here :: blue为@There :: green的别名，或使％Here :: blue为％There :: green的别名，等等。有关更多示例，请参见&lt;a href=&quot;perlmod#Symbol-Tables&quot;&gt;perlmod中的符号表&lt;/a&gt;。尽管这看起来很奇怪，但这是整个模块导入/导出系统的基础。</target>
        </trans-unit>
        <trans-unit id="35825a61520f1c2ed79153398a1a3b55fc959ba6" translate="yes" xml:space="preserve">
          <source>temporarily override assorted &lt;code&gt;CPAN.pm&lt;/code&gt; configuration variables</source>
          <target state="translated">临时覆盖各种 &lt;code&gt;CPAN.pm&lt;/code&gt; 配置变量</target>
        </trans-unit>
        <trans-unit id="91ad65ee0c085dfce15fcf8c596de36b7d3e5bed" translate="yes" xml:space="preserve">
          <source>tended Unicode character.</source>
          <target state="translated">倾向于Unicode字符。</target>
        </trans-unit>
        <trans-unit id="0c710463aba09fea37318d6a1e322bde072ae43c" translate="yes" xml:space="preserve">
          <source>termcap(5)</source>
          <target state="translated">termcap(5)</target>
        </trans-unit>
        <trans-unit id="9a9c106ef0b7b5f35055988715406d563a4b3327" translate="yes" xml:space="preserve">
          <source>terminal capacities</source>
          <target state="translated">终端容量</target>
        </trans-unit>
        <trans-unit id="e715ccd5a1a578c299a8d942b4b10bbeb1c3b460" translate="yes" xml:space="preserve">
          <source>test 4 may fail if you are on a tmpfs of some sort. Building in /tmp sometimes shows this behavior. The test suite detects if you are building in /tmp, but it may not be able to catch all tmpfs situations.</source>
          <target state="translated">如果你在某个tmpfs上,测试4可能会失败。在/tmp中构建有时会出现这种行为。测试套件会检测你是否在/tmp中构建,但它可能无法捕捉到所有的tmpfs情况。</target>
        </trans-unit>
        <trans-unit id="3baa493ec3f690bb6e71fbdecd667bead97dd08b" translate="yes" xml:space="preserve">
          <source>test and install by</source>
          <target state="translated">试装</target>
        </trans-unit>
        <trans-unit id="ab9e5c896f4e6e83350f7e6655ffaca65aa5faa7" translate="yes" xml:space="preserve">
          <source>test fails. More precisely: the subtests using datagram sockets fail. Unix datagram sockets aren't implemented in Haiku yet.</source>
          <target state="translated">测试失败。更准确地说:使用数据报套接字的子测试失败了。Unix数据报套接字在Haiku中还没有实现。</target>
        </trans-unit>
        <trans-unit id="2e335b5beb93717af185fbf36192a610a92fac52" translate="yes" xml:space="preserve">
          <source>test fails. This is due to Haiku not implementing</source>
          <target state="translated">测试失败。这是由于Haiku没有实现</target>
        </trans-unit>
        <trans-unit id="46fa1990856d6bfc5aa426d6de0036a2f3e6f778" translate="yes" xml:space="preserve">
          <source>test hangs (subtest #51, FWIW) for some unknown reason. Just stop the test and kill that particular Perl process.</source>
          <target state="translated">测试挂起 (子测试 #51,FWIW),原因不明。只要停止测试,并杀死那个特定的Perl进程。</target>
        </trans-unit>
        <trans-unit id="1745a2b1e1df23d1d960c6a914693643c4d35ef0" translate="yes" xml:space="preserve">
          <source>test methods</source>
          <target state="translated">测试方法</target>
        </trans-unit>
        <trans-unit id="06069cf41f09b0e9e006f68445efe0b43e5710d7" translate="yes" xml:space="preserve">
          <source>test which will simply check that your code compiles and stop &quot;make test&quot; prematurely if it doesn't. See &lt;a href=&quot;../test/more#BAIL_OUT&quot;&gt;BAIL_OUT in Test::More&lt;/a&gt; for more details.</source>
          <target state="translated">测试，它将简单地检查您的代码是否已编译，如果没有，则过早地停止&amp;ldquo;进行测试&amp;rdquo;。有关&lt;a href=&quot;../test/more#BAIL_OUT&quot;&gt;更多&lt;/a&gt;详细信息，请参见Test :: More中的BAIL_OUT。</target>
        </trans-unit>
        <trans-unit id="5ab50aa4c10a2157c2768ce7cbfe05ab8151cfe2" translate="yes" xml:space="preserve">
          <source>test). Do not forget to unset &lt;code&gt;PERL_EMXLOAD_SEC&lt;/code&gt; in environment.</source>
          <target state="translated">测试）。不要忘记在环境中取消设置 &lt;code&gt;PERL_EMXLOAD_SEC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33c341554523e86b3f9130f24b43a7e89a4a0a09" translate="yes" xml:space="preserve">
          <source>test. These failures have been suppressed in the current release of Perl by making the test ignore the broken locale. If you need to use the eu_ES locale, you should contact Apple support.</source>
          <target state="translated">测试。在当前版本的Perl中,这些故障已经被抑制,因为测试忽略了错误的locale。如果你需要使用 eu_ES 本地化,你应该联系 Apple 支持。</target>
        </trans-unit>
        <trans-unit id="a7cd61938a0a91df8c916296b3b0f681386d5536" translate="yes" xml:space="preserve">
          <source>test.pl</source>
          <target state="translated">test.pl</target>
        </trans-unit>
        <trans-unit id="abcdea9505604adb409a5d5ccd0cb809dd18e42a" translate="yes" xml:space="preserve">
          <source>test; binary files are processed with no translation whatsoever.</source>
          <target state="translated">测试;二进制文件的处理不需要任何翻译。</target>
        </trans-unit>
        <trans-unit id="3513b382c069b0fd8b3d292ba2ef971e3becdb2a" translate="yes" xml:space="preserve">
          <source>test_class</source>
          <target state="translated">test_class</target>
        </trans-unit>
        <trans-unit id="7f1ada35b851823cf91787553404eba4704dc7a4" translate="yes" xml:space="preserve">
          <source>test_via_harness</source>
          <target state="translated">test_via_harness</target>
        </trans-unit>
        <trans-unit id="3bffec6eb2d501ce6398ddc2723cd9ac30610307" translate="yes" xml:space="preserve">
          <source>test_via_script</source>
          <target state="translated">test_via_script</target>
        </trans-unit>
        <trans-unit id="3206488df435bc6923ead2447a155e7c1f00933c" translate="yes" xml:space="preserve">
          <source>testfile.valgrind</source>
          <target state="translated">testfile.valgrind</target>
        </trans-unit>
        <trans-unit id="c1bb9bde819ec6d35d0f58572f8df6e36e4c2bf3" translate="yes" xml:space="preserve">
          <source>testname.valgrind</source>
          <target state="translated">testname.valgrind</target>
        </trans-unit>
        <trans-unit id="59e66e0e48871942840a17df9ee6e297fe40f6c2" translate="yes" xml:space="preserve">
          <source>testperl.cmd</source>
          <target state="translated">testperl.cmd</target>
        </trans-unit>
        <trans-unit id="e96f8663d0844a8d17b749192ecfb428c6302f95" translate="yes" xml:space="preserve">
          <source>testrules.yml</source>
          <target state="translated">testrules.yml</target>
        </trans-unit>
        <trans-unit id="d44f2bc95b0b12466d2814becdc0fd3ca48f3c86" translate="yes" xml:space="preserve">
          <source>tests.</source>
          <target state="translated">tests.</target>
        </trans-unit>
        <trans-unit id="381c53b73f80ba38b12ab16a309f35591b7a80f5" translate="yes" xml:space="preserve">
          <source>tet.</source>
          <target state="translated">tet.</target>
        </trans-unit>
        <trans-unit id="372ea08cab33e71c02c651dbc83a474d32c676ea" translate="yes" xml:space="preserve">
          <source>text</source>
          <target state="translated">text</target>
        </trans-unit>
        <trans-unit id="441549601c13844544e8e096a23806454251355e" translate="yes" xml:space="preserve">
          <source>text of the POD interior sequence, exactly as it appeared in the input.</source>
          <target state="translated">POD内部序列的文本,与输入的内容一模一样。</target>
        </trans-unit>
        <trans-unit id="5854731dd9ff4ac55f9ae30f794b63778a1f38b3" translate="yes" xml:space="preserve">
          <source>text of the POD paragraph, exactly as it appeared in the input.</source>
          <target state="translated">POD段的文字,与输入的文字一模一样。</target>
        </trans-unit>
        <trans-unit id="ec9e1fb1bdd5ff95f2ef0e5a4bf1f898a6f466e1" translate="yes" xml:space="preserve">
          <source>text of the POD parse-tree exactly as it appeared in the input.</source>
          <target state="translated">POD解析树的文本与输入的文本一模一样。</target>
        </trans-unit>
        <trans-unit id="4c95279946893e6de448e06e614d4ac86b109eed" translate="yes" xml:space="preserve">
          <source>text should ignored.</source>
          <target state="translated">文本应被忽略。</target>
        </trans-unit>
        <trans-unit id="cb46ca32d20cdfb81305bac97aa109b83dc1b07c" translate="yes" xml:space="preserve">
          <source>text, but</source>
          <target state="translated">文,但</target>
        </trans-unit>
        <trans-unit id="99928878118e841388df9f386a36622511ce6080" translate="yes" xml:space="preserve">
          <source>text. (This distinction may or may not be evident in the particular tree/event model implemented by the Pod parser.) For example, consider this unusual case:</source>
          <target state="translated">文本。这种区别在Pod解析器实现的特定树/事件模型中可能明显,也可能不明显)。例如,考虑这个不寻常的情况。</target>
        </trans-unit>
        <trans-unit id="95271a946f22c453ade18117f4cca5dc0f833cc4" translate="yes" xml:space="preserve">
          <source>text...</source>
          <target state="translated">text...</target>
        </trans-unit>
        <trans-unit id="38e9be6401e62f7d1555230d9df956fb85c2ba6e" translate="yes" xml:space="preserve">
          <source>text1</source>
          <target state="translated">text1</target>
        </trans-unit>
        <trans-unit id="8057ce4541a822035c1ef56a5b6686508928ea3b" translate="yes" xml:space="preserve">
          <source>text2</source>
          <target state="translated">text2</target>
        </trans-unit>
        <trans-unit id="9ccace0a1ad010c2a1855debb151e0bb936e66ba" translate="yes" xml:space="preserve">
          <source>th element of this array holds the offset of the</source>
          <target state="translated">数组中的第th个元素存放了</target>
        </trans-unit>
        <trans-unit id="0ecc97d66bd161e24f5253814be739b1ade3945b" translate="yes" xml:space="preserve">
          <source>th group before the &lt;code&gt;\g{-&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\g{-&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; 之前的第th组。</target>
        </trans-unit>
        <trans-unit id="8eb3ae1a9ace25086621583ab7192613b95dc786" translate="yes" xml:space="preserve">
          <source>th innermost &lt;code&gt;( )&lt;/code&gt; group, or to the start of the string if</source>
          <target state="translated">最里面的 &lt;code&gt;( )&lt;/code&gt; 组，如果是，则返回字符串的开头</target>
        </trans-unit>
        <trans-unit id="2ebcfb27ee2bfc8009de717d401cdb448c047d64" translate="yes" xml:space="preserve">
          <source>th root directly by &lt;code&gt;root(z, n, k)&lt;/code&gt; , indexing starting from</source>
          <target state="translated">根直接由 &lt;code&gt;root(z, n, k)&lt;/code&gt; 索引，从</target>
        </trans-unit>
        <trans-unit id="3aa3461c082e7dae7d60c4657a925fe45e7c519d" translate="yes" xml:space="preserve">
          <source>th root for &lt;code&gt;z = [r,t]&lt;/code&gt; is given by:</source>
          <target state="translated">&lt;code&gt;z = [r,t]&lt;/code&gt; 根为下式：</target>
        </trans-unit>
        <trans-unit id="055966868aa553760505967c00a7c5d6818ef82f" translate="yes" xml:space="preserve">
          <source>th submatch, so &lt;code&gt;$+[1]&lt;/code&gt; is the offset past where &lt;code&gt;$1&lt;/code&gt; ends, &lt;code&gt;$+[2]&lt;/code&gt; the offset past where &lt;code&gt;$2&lt;/code&gt; ends, and so on. You can use &lt;code&gt;$#+&lt;/code&gt; to determine how many subgroups were in the last successful match. See the examples given for the &lt;code&gt;@-&lt;/code&gt; variable.</source>
          <target state="translated">th子匹配，因此 &lt;code&gt;$+[1]&lt;/code&gt; 是 &lt;code&gt;$1&lt;/code&gt; 结束处的偏移量， &lt;code&gt;$+[2]&lt;/code&gt; 是 &lt;code&gt;$2&lt;/code&gt; 结束处的偏移量，依此类推。您可以使用 &lt;code&gt;$#+&lt;/code&gt; 确定上一次成功匹配中有多少个子组。请参阅为 &lt;code&gt;@-&lt;/code&gt; 变量提供的示例。</target>
        </trans-unit>
        <trans-unit id="b4d58221efef7dcc072ec5d5895f2fe6ca83de0e" translate="yes" xml:space="preserve">
          <source>th submatch, so &lt;code&gt;$-[1]&lt;/code&gt; is the offset where &lt;code&gt;$1&lt;/code&gt; begins, &lt;code&gt;$-[2]&lt;/code&gt; the offset where &lt;code&gt;$2&lt;/code&gt; begins, and so on.</source>
          <target state="translated">第一个子匹配项，因此 &lt;code&gt;$-[1]&lt;/code&gt; 是 &lt;code&gt;$1&lt;/code&gt; 开始的偏移量， &lt;code&gt;$-[2]&lt;/code&gt; 是 &lt;code&gt;$2&lt;/code&gt; 开始的偏移量，依此类推。</target>
        </trans-unit>
        <trans-unit id="b1fbf7c34837b574b0c78077af027bd61f3e43b9" translate="yes" xml:space="preserve">
          <source>th subpattern later in the pattern using the metacharacter \</source>
          <target state="translated">的子模式,在模式的后面使用元字符</target>
        </trans-unit>
        <trans-unit id="993c608b59dc5dfe8f8f24f36d08ea885a7e97f7" translate="yes" xml:space="preserve">
          <source>th time you access it. When a data item is looked up afresh, its number of uses is reset.</source>
          <target state="translated">当您访问它时,它的使用次数会被重置。当一个数据项被重新查询时,它的使用次数会被重置。</target>
        </trans-unit>
        <trans-unit id="d820aa5f8750fdde33200083b0702a32578a6c95" translate="yes" xml:space="preserve">
          <source>than</source>
          <target state="translated">than</target>
        </trans-unit>
        <trans-unit id="f8d56f0d78517ccac80725a473ad26543c1149da" translate="yes" xml:space="preserve">
          <source>than the current value of $^F (by default 2 for &lt;code&gt;STDERR&lt;/code&gt; ). See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">比$ ^ F的当前值（默认为 &lt;code&gt;STDERR&lt;/code&gt; 2 ）。见&lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$ ^ F在perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="37e161466a88c9a41a96b5e1a785469a7cc68706" translate="yes" xml:space="preserve">
          <source>than the current value of $^F (by default 2 for &lt;code&gt;STDERR&lt;/code&gt; ). See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">比$ ^ F的当前值（默认为 &lt;code&gt;STDERR&lt;/code&gt; 2 ）。见&lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$ ^ F在perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ea263d2427ffcfcca02154008ed63f280ffe403" translate="yes" xml:space="preserve">
          <source>than the indentation level, followed by one copy of</source>
          <target state="translated">比缩进水平更高的,然后是一个拷贝的</target>
        </trans-unit>
        <trans-unit id="33b82201081ec7c438cb5d9a36cd72bcb153050b" translate="yes" xml:space="preserve">
          <source>that</source>
          <target state="translated">that</target>
        </trans-unit>
        <trans-unit id="712f902c58bdfbf92dc3035820fbc97dac3d7f9c" translate="yes" xml:space="preserve">
          <source>that Mark Jason Dominus employs in his paper on &quot;Rx&quot; ([1] in &lt;a href=&quot;#REFERENCES&quot;&gt;REFERENCES&lt;/a&gt;).</source>
          <target state="translated">是Mark Jason Dominus在其关于&amp;ldquo; Rx&amp;rdquo;的论文中使用的（&lt;a href=&quot;#REFERENCES&quot;&gt;参考文献中的&lt;/a&gt; [1] ）。</target>
        </trans-unit>
        <trans-unit id="c9c5244833fb206b954415ab3f54654400b7eb3c" translate="yes" xml:space="preserve">
          <source>that are not available in older versions of perl. The problem is that the version number for Fcntl is the same in perl 5.6.0 and in 5.005_03 even though they are different versions.</source>
          <target state="translated">在旧版本的perl中是不可用的。问题是Fcntl的版本号在perl 5.6.0和5.005_03中是一样的,尽管它们是不同的版本。</target>
        </trans-unit>
        <trans-unit id="9eee5aaf9d09fc3579f3f15ad3d8b52f452536af" translate="yes" xml:space="preserve">
          <source>that are not in the list of</source>
          <target state="translated">列表中没有的</target>
        </trans-unit>
        <trans-unit id="97950f338e4ed29ff49961cf2229ebd2cb383e46" translate="yes" xml:space="preserve">
          <source>that can also be run as a Perl script. To generate</source>
          <target state="translated">也可以作为Perl脚本运行。要生成</target>
        </trans-unit>
        <trans-unit id="29212c899911ccfcbbe5cbf6f831e9088556a7bc" translate="yes" xml:space="preserve">
          <source>that comes with the package, if that</source>
          <target state="translated">附带的,如果那</target>
        </trans-unit>
        <trans-unit id="4090dd20c552b4219c34c03221f437018fa823a5" translate="yes" xml:space="preserve">
          <source>that contains all the perlguts necessary to push the two arguments into</source>
          <target state="translated">包含了将两个参数推送到</target>
        </trans-unit>
        <trans-unit id="d9a7d75f21aba5d2b3adbb588b8f62a714350deb" translate="yes" xml:space="preserve">
          <source>that function is called and is passed those OPTIONS (split on commas). It should return a sub ref to the main compilation function. After the user's program is loaded and parsed, that returned sub ref is invoked which can then go ahead and do the compilation, usually by making use of the &lt;code&gt;B&lt;/code&gt; module's functionality.</source>
          <target state="translated">该函数将被调用并传递给那些OPTIONS（以逗号分隔）。它应该向主编译函数返回一个子引用。加载并解析用户程序后，通常会利用 &lt;code&gt;B&lt;/code&gt; 模块的功能来调用返回的sub ref，然后可以继续进行编译。</target>
        </trans-unit>
        <trans-unit id="49f6845d8cc6762655e9d8d5279b965b50bc34d9" translate="yes" xml:space="preserve">
          <source>that is the single character at &lt;code&gt;0xABC&lt;/code&gt; . Under &lt;code&gt;'strict'&lt;/code&gt; it is an error to not follow &lt;code&gt;\x&lt;/code&gt; with exactly two hex digits. When not under &lt;code&gt;'strict'&lt;/code&gt; a warning is generated if there is only one hex digit, and no warning is raised if there are more than two.</source>
          <target state="translated">那是 &lt;code&gt;0xABC&lt;/code&gt; 处的单个字符。在 &lt;code&gt;'strict'&lt;/code&gt; 下，没有在 &lt;code&gt;\x&lt;/code&gt; 后面紧跟两个十六进制数字是一个错误。如果不在 &lt;code&gt;'strict'&lt;/code&gt; ，则只有一个十六进制数字会生成警告，而如果有两个以上十六进制数字，则不会发出警告。</target>
        </trans-unit>
        <trans-unit id="e4f20743e591fca32ea867ef45df47d1193856a5" translate="yes" xml:space="preserve">
          <source>that is to be analyzed and use the permissible values on the left hand side of the matching operations. As an example for this somewhat paradoxical situation, let's assume that our input contains a command verb which should match one out of a set of available command verbs, with the additional twist that commands may be abbreviated as long as the given string is unique. The program below demonstrates the basic algorithm.</source>
          <target state="translated">并在匹配操作的左侧使用允许的值进行分析。作为这种有点矛盾的情况的例子,让我们假设我们的输入包含一个命令动词,它应该匹配一组可用的命令动词中的一个,还有一个额外的变化是,只要给定的字符串是唯一的,命令可以被缩写。下面的程序演示了基本算法。</target>
        </trans-unit>
        <trans-unit id="64e4455297c586a9db29d5096ca7b93d57de5fe5" translate="yes" xml:space="preserve">
          <source>that is, the character whose code point value is &lt;code&gt;0xAB&lt;/code&gt; , followed by the letter &lt;code&gt;C&lt;/code&gt; . But since &lt;code&gt;C&lt;/code&gt; is a a hex digit, there is a reasonable chance that the intent was</source>
          <target state="translated">即，其代码点值是字符 &lt;code&gt;0xAB&lt;/code&gt; ，后跟字母 &lt;code&gt;C&lt;/code&gt; 。但是，由于 &lt;code&gt;C&lt;/code&gt; 是一个十六进制数字，因此有合理的机会表明意图是</target>
        </trans-unit>
        <trans-unit id="1bc56929a849385fc4d0db6d314427d5b8dbddcd" translate="yes" xml:space="preserve">
          <source>that it was compiled in the package &lt;code&gt;main&lt;/code&gt; ;</source>
          <target state="translated">它是在包 &lt;code&gt;main&lt;/code&gt; 中编译的;</target>
        </trans-unit>
        <trans-unit id="5106349904c16b5fab53fb5e99dc60b9956ff5a3" translate="yes" xml:space="preserve">
          <source>that prints:</source>
          <target state="translated">该打印。</target>
        </trans-unit>
        <trans-unit id="2147c04b3cf47c1027e8b48decbbe54f8d12d79d" translate="yes" xml:space="preserve">
          <source>that specifies the value&amp;rsquo;s &lt;b&gt;offset&lt;/b&gt; in the sequence.</source>
          <target state="translated">在序列中指定值的&lt;b&gt;偏移量&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="9c0471ac111ba85b51a34c13abf7375fbf05cdbf" translate="yes" xml:space="preserve">
          <source>that superordinates of $lang1 are mutually intelligible with $lang1. Consider this carefully.</source>
          <target state="translated">即$lang1的上级与$lang1是可以相互理解的。仔细考虑这个问题。</target>
        </trans-unit>
        <trans-unit id="2def5546b6eb47219f92a8fa7761c3e0fa1be7b9" translate="yes" xml:space="preserve">
          <source>that the STRING holds only well-formed UTF-8. Returns the previous state of the UTF8 flag (so please don't treat the return value as indicating success or failure), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if</source>
          <target state="translated">STRING仅包含格式正确的UTF-8。返回的UTF8标志的先前状态（所以请不要把返回值指示成功或失败），或者 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 如果</target>
        </trans-unit>
        <trans-unit id="9330bf46ed7a31ad2571adf2313ea72910827fa1" translate="yes" xml:space="preserve">
          <source>that the parent has a &lt;code&gt;&amp;amp;&lt;/code&gt; pad slot pointing back to us. In this case, we set the &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; flag in the child. This allows us to determine under what circumstances we should decrement the refcount of the parent when freeing the child.</source>
          <target state="translated">父母有一个 &lt;code&gt;&amp;amp;&lt;/code&gt; 填充槽指向我们。在这种情况下，我们在子级中设置 &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; 标志。这使我们能够确定在什么情况下释放孩子时应减少父母的引用计数。</target>
        </trans-unit>
        <trans-unit id="c4b9eedbce74c74b8ab418c048257b665e5984fc" translate="yes" xml:space="preserve">
          <source>that this package generates, if that</source>
          <target state="translated">如果这个软件包产生的</target>
        </trans-unit>
        <trans-unit id="eaf21ed55aa93ffd795263ddba3f077b7975f18c" translate="yes" xml:space="preserve">
          <source>that will almost never be a problem, but if you install a filtering subroutine by passing it directly to the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; statement:</source>
          <target state="translated">几乎永远不会有问题，但是如果您通过直接将其传递给 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; 语句来安装过滤子例程，则：</target>
        </trans-unit>
        <trans-unit id="832edde3d5e2767ac60905e79c547b9f88b893ac" translate="yes" xml:space="preserve">
          <source>that you can find (e.g. by generating it with the latest &lt;code&gt;Devel::PPPort&lt;/code&gt; release from CPAN), copy it into your project, adjust your project to use it, and distribute the header along with your module.</source>
          <target state="translated">您可以找到的（例如，通过CPAN 的最新 &lt;code&gt;Devel::PPPort&lt;/code&gt; 版本生成它），将其复制到您的项目中，调整项目以使用它，然后将标头与模块一起分发。</target>
        </trans-unit>
        <trans-unit id="bbccdf2efb33b52e6c9d0a14dd70b2d415fbea6e" translate="yes" xml:space="preserve">
          <source>the</source>
          <target state="translated">the</target>
        </trans-unit>
        <trans-unit id="fb4c660642c3786a6682f598d0a3ab6b2413a9c7" translate="yes" xml:space="preserve">
          <source>the &lt;b&gt;preprocess_paragraph()&lt;/b&gt; method. After all (possibly preprocessed) lines in a paragraph have been assembled together and either it has been determined that the paragraph is part of the POD documentation from one of the selected sections or the &lt;code&gt;-want_nonPODs&lt;/code&gt; option is true, then &lt;b&gt;preprocess_paragraph()&lt;/b&gt; is invoked.</source>
          <target state="translated">所述&lt;b&gt;preprocess_paragraph（）&lt;/b&gt;方法。在将段落中的所有（可能是经过预处理的）行组合在一起之后，或者从所选节之一确定该段落是POD文档的一部分，或者 &lt;code&gt;-want_nonPODs&lt;/code&gt; 选项为true，然后调用&lt;b&gt;preprocess_paragraph（）&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="d015472d9b89357d87fe6b5b8a3955a70873fd98" translate="yes" xml:space="preserve">
          <source>the &lt;b&gt;preprocess_paragraph()&lt;/b&gt; method. After all (possibly preprocessed) lines in a paragraph have been assembled together and it has been determined that the paragraph is part of the POD documentation from one of the selected sections, then &lt;b&gt;preprocess_paragraph()&lt;/b&gt; is invoked.</source>
          <target state="translated">所述&lt;b&gt;preprocess_paragraph（）&lt;/b&gt;方法。将一个段落中的所有（可能是经过预处理的）行组合在一起，并且确定该段落是所选部分之一中的POD文档的一部分之后，将调用&lt;b&gt;preprocess_paragraph（）&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="1ecf3d6a18b09451ed79cad0f9c2d47da85bdc74" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement is finished.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句执行完毕。</target>
        </trans-unit>
        <trans-unit id="9da4ea008b0d3e45aac714865e3efcab30e81afa" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;SvPV&lt;/code&gt; call), and act accordingly:</source>
          <target state="translated">在 &lt;code&gt;SvPV&lt;/code&gt; 调用），并做相应处理：</target>
        </trans-unit>
        <trans-unit id="d3ee9bbc572a709eb30d7bbdde11096841bab10e" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;warnings::warnif&lt;/code&gt; function will detect this and die after displaying the warning message.</source>
          <target state="translated">该 &lt;code&gt;warnings::warnif&lt;/code&gt; 功能会检测到这一点，并显示警告消息后死亡。</target>
        </trans-unit>
        <trans-unit id="5c42b113d5039ee22489d974cb36f9a7666caa3f" translate="yes" xml:space="preserve">
          <source>the UTF8 flag</source>
          <target state="translated">UTF8旗</target>
        </trans-unit>
        <trans-unit id="ea839584ddb420310c9f3ec76a311a74c5cd61a6" translate="yes" xml:space="preserve">
          <source>the Unicode Standard</source>
          <target state="translated">统一码标准</target>
        </trans-unit>
        <trans-unit id="35fcc443e2d015d49e54156560cccc0fe8aa8232" translate="yes" xml:space="preserve">
          <source>the XSUBs are made accessible from Perl</source>
          <target state="translated">XSUBs可以从Perl中访问</target>
        </trans-unit>
        <trans-unit id="d8d781c395f2b10a1ab0f9dd5d80819da9e7f0c0" translate="yes" xml:space="preserve">
          <source>the absolute path to the file</source>
          <target state="translated">文件的绝对路径</target>
        </trans-unit>
        <trans-unit id="59b69eb80989a1f9e7b09d9edab871ebd857e043" translate="yes" xml:space="preserve">
          <source>the access time stamp from t2 need not be greater-than the modify time stamp from t1: it may be equal or</source>
          <target state="translated">来自t2的访问时间戳不必大于来自t1的修改时间戳:它可以等于或等于</target>
        </trans-unit>
        <trans-unit id="31ec033d4119bfbdee88e6c35979bdf5b199fb26" translate="yes" xml:space="preserve">
          <source>the actual open occurs, whether that be via &lt;code&gt;OPEN&lt;/code&gt; , &lt;code&gt;SYSOPEN&lt;/code&gt; , &lt;code&gt;FDOPEN&lt;/code&gt; or by letting a lower layer do the open.</source>
          <target state="translated">实际的打开发生，无论是通过 &lt;code&gt;OPEN&lt;/code&gt; ， &lt;code&gt;SYSOPEN&lt;/code&gt; ， &lt;code&gt;FDOPEN&lt;/code&gt; 还是通过下层进行打开。</target>
        </trans-unit>
        <trans-unit id="61f80c2f1cd841c0f568a34a400477ec514d3d76" translate="yes" xml:space="preserve">
          <source>the actually executed command is</source>
          <target state="translated">实际执行的命令是</target>
        </trans-unit>
        <trans-unit id="11c6e5f1977cc3206ae0e58800729e6f410a3e7c" translate="yes" xml:space="preserve">
          <source>the address, not the string!</source>
          <target state="translated">地址,而不是字符串</target>
        </trans-unit>
        <trans-unit id="fd3d54ca662c0c2684de323985f811bec22bd1c7" translate="yes" xml:space="preserve">
          <source>the applications in the system, this means a complete unpredictability of floating point flags on systems using such HOOK DLLs. E.g.,</source>
          <target state="translated">系统中的应用程序,这意味着在使用这种HOOK DLL的系统上,浮点标志完全无法预测。如:。</target>
        </trans-unit>
        <trans-unit id="05f3d9ddc3900af01143c7b2a3e5153aabb90af6" translate="yes" xml:space="preserve">
          <source>the arguments, but the signature variables get</source>
          <target state="translated">的参数,但签名变量会得到</target>
        </trans-unit>
        <trans-unit id="f4e158dd3c24f0129db3d82bff02272453579fe5" translate="yes" xml:space="preserve">
          <source>the bit-oriented &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">面向比特的 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="44783b99ba624e2dd48d49637548b64060361a97" translate="yes" xml:space="preserve">
          <source>the block</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542b55c7fb7ff0a1d714925fc7ac958077c6109e" translate="yes" xml:space="preserve">
          <source>the block of text for the a POD paragraph</source>
          <target state="translated">POD段的文字块。</target>
        </trans-unit>
        <trans-unit id="aeeab916789b5b521be02e67178d8a43feaa0e51" translate="yes" xml:space="preserve">
          <source>the block of text for the verbatim paragraph</source>
          <target state="translated">句号</target>
        </trans-unit>
        <trans-unit id="c7bac64afd3313d8818026799b8430d1c87920d4" translate="yes" xml:space="preserve">
          <source>the byte ordering: whether the first byte is the least or most significant byte (or: little-endian or big-endian, respectively).</source>
          <target state="translated">字节排序:第一个字节是最小的还是最重要的字节(或:分别是little-endian或big-endian)。</target>
        </trans-unit>
        <trans-unit id="c938f5030b0fa62c0dd034b19c1afbd25a5be589" translate="yes" xml:space="preserve">
          <source>the byte-oriented &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&quot;C&quot;&lt;/code&gt; format</source>
          <target state="translated">面向字节的 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&quot;C&quot;&lt;/code&gt; 格式</target>
        </trans-unit>
        <trans-unit id="df0540c941ef1d583ac55c355b64fd5941bb42bc" translate="yes" xml:space="preserve">
          <source>the cached data. The argument may be a function name or a reference to a function. For finer control over when data is discarded or expired, see the documentation for &lt;code&gt;Memoize::Expire&lt;/code&gt; , included in this package.</source>
          <target state="translated">缓存的数据。参数可以是函数名称或对函数的引用。为了更好地控制数据何时被丢弃或过期，请参阅此软件包中包含的 &lt;code&gt;Memoize::Expire&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="2acb51fb1aaf7311d7872477d62b8f21a28f8ae1" translate="yes" xml:space="preserve">
          <source>the character strings.</source>
          <target state="translated">字符串。</target>
        </trans-unit>
        <trans-unit id="c731556f14a6292f08e47a5dff92437af6238ab2" translate="yes" xml:space="preserve">
          <source>the closing delimiter of the here document), which would cause the earlier &quot; || die;\nexit;&quot; to be skipped in any sequence of code fragment extractions.</source>
          <target state="translated">here文档的结束定界符),这将导致在任何代码片段提取序列中跳过前面的&quot; || die;\nexit;&quot;。</target>
        </trans-unit>
        <trans-unit id="aab39bfbe0a7c70c1895d1af4eb651fc1e701058" translate="yes" xml:space="preserve">
          <source>the closing tag (or &quot;&quot; if no closing tag was found)</source>
          <target state="translated">结束标签(如果没有找到结束标签,则用&quot;&quot;)</target>
        </trans-unit>
        <trans-unit id="157b41d2b634c5bd10fddb35da9de75d247bc255" translate="yes" xml:space="preserve">
          <source>the code by adding</source>
          <target state="translated">在代码中加入</target>
        </trans-unit>
        <trans-unit id="d315aab2b081580801bce5775047436139f6f3cc" translate="yes" xml:space="preserve">
          <source>the code does what it does, not</source>
          <target state="translated">代码做它所做的,而不是</target>
        </trans-unit>
        <trans-unit id="61801a1e0739c9c513bb5a98dbb30d9d43a9bad8" translate="yes" xml:space="preserve">
          <source>the code point belongs to, e.g. &lt;code&gt;Basic Latin&lt;/code&gt; . The old-style block name is returned (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;). The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the block name.</source>
          <target state="translated">该代码点属于，例如 &lt;code&gt;Basic Latin&lt;/code&gt; 。返回旧样式块名称（请参阅&lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;旧样式块名称与新样式块名称&lt;/a&gt;）。该&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;函数可用于获取块名称的所有同义词。</target>
        </trans-unit>
        <trans-unit id="3f740a37880db96fc9c17587892331ec08337334" translate="yes" xml:space="preserve">
          <source>the code point belongs to, e.g., &lt;code&gt;Latin&lt;/code&gt; , &lt;code&gt;Greek&lt;/code&gt; , &lt;code&gt;Han&lt;/code&gt; . If the code point is unassigned or the Unicode version being used is so early that it doesn't have scripts, this function returns &lt;code&gt;&quot;Unknown&quot;&lt;/code&gt; . The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the script name.</source>
          <target state="translated">该代码点属于例如 &lt;code&gt;Latin&lt;/code&gt; ， &lt;code&gt;Greek&lt;/code&gt; ， &lt;code&gt;Han&lt;/code&gt; 。如果未分配代码点或使用的Unicode版本太早以至于没有脚本，则此函数返回 &lt;code&gt;&quot;Unknown&quot;&lt;/code&gt; 。该&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;函数可用于获取脚本名称的所有同义词。</target>
        </trans-unit>
        <trans-unit id="17f78cf6f96569dfc482468db33ab5d6f1b57d15" translate="yes" xml:space="preserve">
          <source>the combining class number for</source>
          <target state="translated">合班号</target>
        </trans-unit>
        <trans-unit id="2bd53f225cc971376af4c684c177d1bda41015ca" translate="yes" xml:space="preserve">
          <source>the command &lt;code&gt;cpan .&lt;/code&gt; does all of this at once. It figures out which of the two mantras is appropriate, fetches and installs all prerequisites, takes care of them recursively, and finally finishes the installation of the module in the current directory, be it a CPAN module or not.</source>
          <target state="translated">命令 &lt;code&gt;cpan .&lt;/code&gt; 一次完成所有这些操作。它找出这两个咒语中的哪一个是适当的，获取并安装所有先决条件，然后递归地处理它们，最后完成当前目录中模块的安装，无论该目录是否为CPAN模块。</target>
        </trans-unit>
        <trans-unit id="5612fc997c8cb9a486d63ef7bf675962eedd7639" translate="yes" xml:space="preserve">
          <source>the commas on the right of the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; are evaluated before the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, but the commas on the left are evaluated after. In other words, list operators tend to gobble up all arguments that follow, and then act like a simple TERM with regard to the preceding expression. Be careful with parentheses:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 右边的逗号在排序之前进行评估，而左边的逗号在 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 之后进行评估。换句话说，列表运算符倾向于吞噬后面的所有参数，然后就前面的表达式而言就像一个简单的TERM。注意括号：</target>
        </trans-unit>
        <trans-unit id="2ea5806650c2d66f92a06b399e855bb23c546b4e" translate="yes" xml:space="preserve">
          <source>the compiler precomputes the number which that expression represents so that the interpreter won't have to.</source>
          <target state="translated">编译器预先计算该表达式所代表的数字,这样解释器就不需要这样做。</target>
        </trans-unit>
        <trans-unit id="b590edf2b5459e947f26c3b792a11ee5b69155bd" translate="yes" xml:space="preserve">
          <source>the condition is true (or while the condition is false):</source>
          <target state="translated">条件为真(或条件为假)。</target>
        </trans-unit>
        <trans-unit id="86884d36b82542d454bba7bddac4a77b22d6fb75" translate="yes" xml:space="preserve">
          <source>the condition is true (that is, if the condition is false).</source>
          <target state="translated">条件为真(即如果条件为假)。</target>
        </trans-unit>
        <trans-unit id="cd2f84b37e4990a4cdb084747345787afb430fab" translate="yes" xml:space="preserve">
          <source>the condition is true. &lt;code&gt;until&lt;/code&gt; does the opposite, it repeats the statement</source>
          <target state="translated">条件是真的。 &lt;code&gt;until&lt;/code&gt; 相反，它重复语句</target>
        </trans-unit>
        <trans-unit id="0b85c87e5cffade4a9922fbfed79cacba15c13fb" translate="yes" xml:space="preserve">
          <source>the conditions for the mappings to be valid. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the mappings are always valid. When defined, this field is a list of conditions, all of which must be true for the mappings to be valid. The list consists of one or more</source>
          <target state="translated">映射有效的条件。如果为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则映射始终有效。定义后，此字段是条件列表，所有条件都必须为true才能使映射有效。该列表包含一个或多个</target>
        </trans-unit>
        <trans-unit id="9b0638bead3b3df68f86f19c3a14de1a6bd30e21" translate="yes" xml:space="preserve">
          <source>the correct subexpression to match the comment delimiter, because it may &quot;give up&quot; some whitespace if the remainder of the pattern can be made to match that way. The correct answer is either one of these:</source>
          <target state="translated">正确的子表达式来匹配注释定界符,因为如果模式的其余部分可以这样匹配,它可能会 &quot;放弃 &quot;一些空白。正确的答案是其中之一。</target>
        </trans-unit>
        <trans-unit id="49b2f2aa6cf4102d30e4466e987b20729a1c1858" translate="yes" xml:space="preserve">
          <source>the current one.</source>
          <target state="translated">当前的。</target>
        </trans-unit>
        <trans-unit id="f931ec421d5bf3d3b08aae794827e76698391462" translate="yes" xml:space="preserve">
          <source>the data is assumed to be in (Latin 1 and) Unicode, not in your native encoding. In other words, this will match in &quot;greek&quot;:</source>
          <target state="translated">的数据被假定为(拉丁语1和)Unicode,而不是您的本地编码。换句话说,这将与 &quot;希腊语 &quot;相匹配。</target>
        </trans-unit>
        <trans-unit id="ca54e1fd49bc4a6778d016e9f59ee0f6e72284bf" translate="yes" xml:space="preserve">
          <source>the data referred to by &lt;code&gt;$a&lt;/code&gt; is unchanged by the assignment to &lt;code&gt;$b&lt;/code&gt; of a reference to new object data.</source>
          <target state="translated">通过将对新对象数据的引用分配给 &lt;code&gt;$b&lt;/code&gt; ，由 &lt;code&gt;$a&lt;/code&gt; 引用的数据将保持不变。</target>
        </trans-unit>
        <trans-unit id="73209f90d9d86d440950888ee02a95bcd44d45ad" translate="yes" xml:space="preserve">
          <source>the debugger hooks (but still before the opcode itself is executed).</source>
          <target state="translated">调试器钩子(但仍在操作码本身被执行之前)。</target>
        </trans-unit>
        <trans-unit id="d4a89a5f8efeb10956bd5035175680bd86c4055c" translate="yes" xml:space="preserve">
          <source>the declaration. You cannot write &lt;code&gt;$x = 1; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $x;&lt;/code&gt; and expect the first assignment to affect the same variable. It will instead assign to an &lt;code&gt;$x&lt;/code&gt; declared previously in an outer scope, or to a global variable.</source>
          <target state="translated">声明。你不能写 &lt;code&gt;$x = 1; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $x;&lt;/code&gt; 并期望第一个分配影响相同的变量。而是将其分配给外部范围中先前声明的 &lt;code&gt;$x&lt;/code&gt; 或全局变量。</target>
        </trans-unit>
        <trans-unit id="6bf7f3909d5cb420150d508cb1f4a30ca1987a1f" translate="yes" xml:space="preserve">
          <source>the differences being that it generates a real list at compile time, and in scalar context it returns the last element in the list. So this expression:</source>
          <target state="translated">不同的是,它在编译时生成一个真实的列表,而在标量上下文中,它返回列表中的最后一个元素。所以这个表达式。</target>
        </trans-unit>
        <trans-unit id="85b968ca06524fd795c08850a7f7f0ce5c3baeda" translate="yes" xml:space="preserve">
          <source>the directory the file was read from</source>
          <target state="translated">读取文件的目录</target>
        </trans-unit>
        <trans-unit id="b05011b947d845e0f9cffdcd079fb878ae1595be" translate="yes" xml:space="preserve">
          <source>the effect is to pass the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call an extra reference to the variable being tied:</source>
          <target state="translated">效果是通过 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用传递对被绑定变量的额外引用：</target>
        </trans-unit>
        <trans-unit id="24fdc39732587c01a485c44d61e61763164109d8" translate="yes" xml:space="preserve">
          <source>the elements in the array, only several first (depending on how deep it already went into the report tree).</source>
          <target state="translated">数组中的元素,只是先有几个(取决于它已经进入报告树的深度)。</target>
        </trans-unit>
        <trans-unit id="da9e783c4554e1b5cab3e0647438bcc9a853ead9" translate="yes" xml:space="preserve">
          <source>the end of the script.</source>
          <target state="translated">脚本的结尾。</target>
        </trans-unit>
        <trans-unit id="f7db5864c9ae797ba455c07e9a33679734cf02a5" translate="yes" xml:space="preserve">
          <source>the error message (usually either &lt;code&gt;$!&lt;/code&gt; or a YAML error)</source>
          <target state="translated">错误消息（通常是 &lt;code&gt;$!&lt;/code&gt; 或YAML错误）</target>
        </trans-unit>
        <trans-unit id="7e9cc741fe4b132b7994345e5740c2efe34cbcb9" translate="yes" xml:space="preserve">
          <source>the error might show something like:</source>
          <target state="translated">该错误可能会显示这样的内容。</target>
        </trans-unit>
        <trans-unit id="8bb3b69c49ba7467556b8814bc9da23ade9275bf" translate="yes" xml:space="preserve">
          <source>the exact number of times &quot;a&quot; or &quot;b&quot; are printed out is unspecified for failure, but you may assume they will be printed at least once during a successful match, additionally you may assume that if &quot;b&quot; is printed, it will be preceded by at least one &quot;a&quot;.</source>
          <target state="translated">确切的 &quot;a &quot;或 &quot;b &quot;被打印出来的次数是没有规定的,但您可以假设在一次成功的比赛中它们至少会被打印一次,另外您可以假设如果 &quot;b &quot;被打印出来,它的前面至少会有一个 &quot;a&quot;。</target>
        </trans-unit>
        <trans-unit id="af071f22416397889c6368582b0fa9e1dd2f95c7" translate="yes" xml:space="preserve">
          <source>the extension needs an &lt;code&gt;HMQ&lt;/code&gt; only because some API will not work otherwise. Use &lt;code&gt;serve = 0&lt;/code&gt; below.</source>
          <target state="translated">该扩展仅需要 &lt;code&gt;HMQ&lt;/code&gt; ,因为某些API否则将无法工作。在下面使用 &lt;code&gt;serve = 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68653d9ba062184ae14c759dbc109e73f199c9ee" translate="yes" xml:space="preserve">
          <source>the extension needs an &lt;code&gt;HMQ&lt;/code&gt; since it wants to engage in a PM event loop. Use &lt;code&gt;serve = 1&lt;/code&gt; below.</source>
          <target state="translated">该扩展需要 &lt;code&gt;HMQ&lt;/code&gt; ,因为它想参与PM事件循环。在下面使用 &lt;code&gt;serve = 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cf3f84a1f238cbd74e98add44f2ddd490e3387b" translate="yes" xml:space="preserve">
          <source>the external libraries to be linked to dynamic extensions. This may be needed if the linker is one-pass, and Perl includes some overrides for C RTL functions, such as malloc().</source>
          <target state="translated">要链接到动态扩展的外部库。如果链接器是单通道的,而且 Perl 包含了一些 C RTL 函数的覆盖,比如 malloc(),就可能需要这样做。</target>
        </trans-unit>
        <trans-unit id="66ad2c58db4994c73cc010974641256709477f2b" translate="yes" xml:space="preserve">
          <source>the extracted quotelike substring (including trailing modifiers),</source>
          <target state="translated">提取的类似于引号的子串(包括尾部修饰符)。</target>
        </trans-unit>
        <trans-unit id="42d35ba5b2fb00e37e2c984e477ebc13cdfdf21b" translate="yes" xml:space="preserve">
          <source>the extracted tagged substring (including the outermost tags),</source>
          <target state="translated">提取的标签子串(包括最外层的标签)。</target>
        </trans-unit>
        <trans-unit id="3b49d2c5db6f2ef2aea9cd05887358917fb03add" translate="yes" xml:space="preserve">
          <source>the extracted variable, or variablish expression</source>
          <target state="translated">变量</target>
        </trans-unit>
        <trans-unit id="016bf1faef4ea8a64bf0b8c954cc8c806ed5c738" translate="yes" xml:space="preserve">
          <source>the fields $quota, $comment, and $expire are special in that they are unsupported on many systems. If the $quota is unsupported, it is an empty scalar. If it is supported, it usually encodes the disk quota. If the $comment field is unsupported, it is an empty scalar. If it is supported it usually encodes some administrative comment about the user. In some systems the $quota field may be $change or $age, fields that have to do with password aging. In some systems the $comment field may be $class. The $expire field, if present, encodes the expiration period of the account or the password. For the availability and the exact meaning of these fields in your system, please consult getpwnam(3) and your system's</source>
          <target state="translated">字段$quota、$comment和$expire是特殊的,因为它们在许多系统中是不支持的。如果不支持$quota,它是一个空标量。如果它被支持,它通常会对磁盘配额进行编码。如果$comment字段不被支持,它是一个空标量。如果它被支持,它通常会对用户的一些管理注释进行编码。在某些系统中,$quota字段可能是$change或$age,这些字段与密码老化有关。在某些系统中,$comment字段可能是$class。如果存在$expire字段,则对账户或密码的到期时间进行编码。关于这些字段在你的系统中的可用性和确切含义,请参考 getpwnam(3)和你系统的</target>
        </trans-unit>
        <trans-unit id="4e6284d9ef77c16fa7441dbe48390b1ff7f11a75" translate="yes" xml:space="preserve">
          <source>the file from which these prefs were read, or to which this error refers (relative filename)</source>
          <target state="translated">读取这些预设文件的文件,或该错误所指的文件(相对文件名)。</target>
        </trans-unit>
        <trans-unit id="a49a7390520e745f712d707cf39a8ada8dd959c6" translate="yes" xml:space="preserve">
          <source>the file's extension, which determines how to load it</source>
          <target state="translated">文件的扩展名,它决定了如何加载它。</target>
        </trans-unit>
        <trans-unit id="8a39339004def4392cf2fce8539f1c9fa6e9e17a" translate="yes" xml:space="preserve">
          <source>the filename in which the handler is being invoked;</source>
          <target state="translated">处理程序被调用的文件名。</target>
        </trans-unit>
        <trans-unit id="b5524a08a7a872ca1ac27bd75f06b0da87774a8b" translate="yes" xml:space="preserve">
          <source>the filter is installed. If you use &lt;code&gt;FILTER&lt;/code&gt; to install the filter:</source>
          <target state="translated">过滤器已安装。如果使用 &lt;code&gt;FILTER&lt;/code&gt; 安装过滤器：</target>
        </trans-unit>
        <trans-unit id="836f7fa685865677b2a2c2f0109bf7a3edc63603" translate="yes" xml:space="preserve">
          <source>the first call to this function.</source>
          <target state="translated">该函数的第一次调用。</target>
        </trans-unit>
        <trans-unit id="3fc99dcf1fde0f1020c083b9f2e3c54eaa07013a" translate="yes" xml:space="preserve">
          <source>the first component of an absolute path is read as the device name for the VMS file specification). There are a set of functions provided in the &lt;code&gt;VMS::Filespec&lt;/code&gt; package for explicit interconversion between VMS and Unix syntax; its documentation provides more details.</source>
          <target state="translated">绝对路径的第一部分被读取为VMS文件规范的设备名称）。 &lt;code&gt;VMS::Filespec&lt;/code&gt; 包中提供了一组功能，用于在VMS和Unix语法之间进行显式的相互转换。其文档提供了更多详细信息。</target>
        </trans-unit>
        <trans-unit id="637e558c791eda9940492a71c91f36f4329c09c6" translate="yes" xml:space="preserve">
          <source>the first run-time executable statement (but see below regarding compile-time statements) and ask you to enter a debugger command. Contrary to popular expectations, whenever the debugger halts and shows you a line of code, it always displays the line it's</source>
          <target state="translated">的第一个运行时可执行语句(但请看下面关于编译时语句的内容),并要求你输入一个调试器命令。与一般人的期望相反,每当调试器停止并向你显示一行代码时,它总是显示它的</target>
        </trans-unit>
        <trans-unit id="27d75fc186bcb6caedfcf9d78e7e42f8dd826b81" translate="yes" xml:space="preserve">
          <source>the following (overloaded) operations are supported on complex numbers:</source>
          <target state="translated">在复数上支持以下(重载)操作。</target>
        </trans-unit>
        <trans-unit id="9900b62173a80d309d8d5d7804ced752318e7429" translate="yes" xml:space="preserve">
          <source>the following can all be used:</source>
          <target state="translated">以下都可以使用。</target>
        </trans-unit>
        <trans-unit id="f663eecb1d5e037a8b3023bffacae20c2edff826" translate="yes" xml:space="preserve">
          <source>the following service is available:</source>
          <target state="translated">可提供以下服务:</target>
        </trans-unit>
        <trans-unit id="6cf109d190f58d0cff05b560c507ed0c4b28dea2" translate="yes" xml:space="preserve">
          <source>the following two lines:</source>
          <target state="translated">以下两行:</target>
        </trans-unit>
        <trans-unit id="4255eecaa2211c75003fae1cac3a175c59a648c8" translate="yes" xml:space="preserve">
          <source>the following will be printed</source>
          <target state="translated">以下内容将被打印出来</target>
        </trans-unit>
        <trans-unit id="a359ea19d6e48fb338ab79b0de2cf3c5b08da2b3" translate="yes" xml:space="preserve">
          <source>the full Perl quotelike operations are all extracted correctly.</source>
          <target state="translated">完整的Perl quotelike操作都被正确提取出来。</target>
        </trans-unit>
        <trans-unit id="665373964dd300520c5ea8a5e5f85dae234c0a3f" translate="yes" xml:space="preserve">
          <source>the function &lt;code&gt;f&lt;/code&gt; is called with the implicit context argument (if any), and &lt;code&gt;p&lt;/code&gt; .</source>
          <target state="translated">使用隐式上下文参数（如果有）和 &lt;code&gt;p&lt;/code&gt; 调用函数 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e46835aaeb90870490c67b35e66c766b0c603b8" translate="yes" xml:space="preserve">
          <source>the function &lt;code&gt;f&lt;/code&gt; is called with the only argument &lt;code&gt;p&lt;/code&gt; .</source>
          <target state="translated">使用唯一参数 &lt;code&gt;p&lt;/code&gt; 调用函数 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="850abfb0a7900ca16bb5b9403d6bbfc093cbaf0c" translate="yes" xml:space="preserve">
          <source>the global copy.</source>
          <target state="translated">全局拷贝。</target>
        </trans-unit>
        <trans-unit id="f434ae09e827a25a29a618e48cd45a236fb5d87c" translate="yes" xml:space="preserve">
          <source>the group it refers to, it is now possible to apply pattern matching to tasks that hitherto required a recursive parser.</source>
          <target state="translated">指的组,现在可以将模式匹配应用于迄今为止需要递归解析器的任务。</target>
        </trans-unit>
        <trans-unit id="b84befde5d1a886c007587e3a95889cb406da1f9" translate="yes" xml:space="preserve">
          <source>the hash &lt;code&gt;%defines&lt;/code&gt; (or &lt;code&gt;%$defines&lt;/code&gt; ) will contain two keys, &lt;code&gt;&quot;os&quot;&lt;/code&gt; with value &lt;code&gt;&quot;linux&quot;&lt;/code&gt; and &lt;code&gt;&quot;vendor&quot;&lt;/code&gt; with value &lt;code&gt;&quot;redhat&quot;&lt;/code&gt; . It is also possible to specify that only integer or floating point numbers are acceptable values. The keys are always taken to be strings.</source>
          <target state="translated">哈希 &lt;code&gt;%defines&lt;/code&gt; （或 &lt;code&gt;%$defines&lt;/code&gt; ）将包含两个键，分别是值 &lt;code&gt;&quot;linux&quot;&lt;/code&gt; &lt;code&gt;&quot;os&quot;&lt;/code&gt; &amp;rdquo;和值 &lt;code&gt;&quot;redhat&quot;&lt;/code&gt; &lt;code&gt;&quot;vendor&quot;&lt;/code&gt; &amp;rdquo;。也可以指定仅整数或浮点数为可接受的值。键始终被视为字符串。</target>
        </trans-unit>
        <trans-unit id="5de606e1b8fb6cf1a474fddc76a9d896f8dab695" translate="yes" xml:space="preserve">
          <source>the hash of dot file names and content mappings</source>
          <target state="translated">点文件名和内容映射的哈希值。</target>
        </trans-unit>
        <trans-unit id="f1cd96b5f21ad238f5015969ec918856f8eea2c7" translate="yes" xml:space="preserve">
          <source>the identifier &quot;html&quot; doesn't begin have a &quot;:&quot; prefix, the contents of this region are stored as data paragraphs, instead of being processed as ordinary paragraphs (or if they began with a spaces and/or tabs, as verbatim paragraphs).</source>
          <target state="translated">标识符 &quot;html &quot;开头没有&quot;:&quot;前缀,该区域的内容将被存储为数据段落,而不是作为普通段落处理(或者如果它们以空格和/或制表符开头,则作为逐字段落)。</target>
        </trans-unit>
        <trans-unit id="74997a5db61b1cd6b27805f5b2e5dd2aa25c9e37" translate="yes" xml:space="preserve">
          <source>the include files by hand:</source>
          <target state="translated">手工制作包含文件。</target>
        </trans-unit>
        <trans-unit id="0639a40b39994bddd5c923a37a742c0525b745c4" translate="yes" xml:space="preserve">
          <source>the input native &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; expressed in hexadecimal, with leading zeros added if necessary to make it contain at least four hexdigits</source>
          <target state="translated">以十六进制表示的输入本机&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数&lt;/a&gt;，并在必要时添加前导零以使其至少包含四个十六进制数字</target>
        </trans-unit>
        <trans-unit id="61ca6011deda6931eab08814d67f17903705c3cc" translate="yes" xml:space="preserve">
          <source>the input stream used by the current invocation of this method.</source>
          <target state="translated">本方法的当前调用所使用的输入流。</target>
        </trans-unit>
        <trans-unit id="5de1329fbaf0573c7809c0fde48792ca86cde1a3" translate="yes" xml:space="preserve">
          <source>the integer operation provides scalar context for the &amp;lt;&amp;gt; operator, which responds by reading one line from STDIN and passing it back to the integer operation, which will then find the integer value of that line and return that. If, on the other hand, you say</source>
          <target state="translated">整数运算为&amp;lt;&amp;gt;运算符提供标量上下文，该运算符通过从STDIN读取一行并将其传递回整数运算来进行响应，整数运算然后将找到该行的整数值并返回该整数值。另一方面，如果您说</target>
        </trans-unit>
        <trans-unit id="3c6c16bacb789d14f0c6c80b16288c33e3f368b9" translate="yes" xml:space="preserve">
          <source>the invocand performs the operations, merely that it does. (&lt;code&gt;isa&lt;/code&gt; of course mandates an inheritance relationship. Other relationships include aggregation, delegation, and mocking.)</source>
          <target state="translated">受话者执行操作，仅是执行操作。（ &lt;code&gt;isa&lt;/code&gt; 当然要求继承关系。其他关系包括聚合，委托和模拟。）</target>
        </trans-unit>
        <trans-unit id="ebbeb0be019cd7f66404e317364ede716923212f" translate="yes" xml:space="preserve">
          <source>the key 12345 will get stored in the DBM database as the 5 byte string &quot;12345&quot;. If you actually want the key to be stored in the DBM database as a C int, you will have to use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; when writing, and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; when reading.</source>
          <target state="translated">密钥12345将作为5字节字符串&amp;ldquo; 12345&amp;rdquo;存储在DBM数据库中。如果您实际上希望将密钥作为C int存储在DBM数据库中，则在写入时必须使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ，在读取时必须使用 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="767f35eec2056ec4a9c8dfce5c06b61f7815ff96" translate="yes" xml:space="preserve">
          <source>the left delimiter of the first block of the operation,</source>
          <target state="translated">操作的第一块的左定界符。</target>
        </trans-unit>
        <trans-unit id="76aa8b9cbe9e34630c0db1543914a121410c5ea7" translate="yes" xml:space="preserve">
          <source>the left delimiter of the second block of the operation (that is, if it is a &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;),</source>
          <target state="translated">该操作第二个块的左定界符（即，如果是 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; ），</target>
        </trans-unit>
        <trans-unit id="b06df6449e28067bcdeaaba89205c5a942c211c0" translate="yes" xml:space="preserve">
          <source>the length of the array via &lt;code&gt;$x = &lt;a href=&quot;../functions/scalar&quot;&gt;scalar&lt;/a&gt; @tied_file&lt;/code&gt; accesses &lt;b&gt;all&lt;/b&gt; records and stores their offsets. The same for &lt;code&gt;foreach (@tied_file)&lt;/code&gt; , even if you exit the loop early.</source>
          <target state="translated">通过 &lt;code&gt;$x = &lt;a href=&quot;../functions/scalar&quot;&gt;scalar&lt;/a&gt; @tied_file&lt;/code&gt; 的数组长度访问&lt;b&gt;所有&lt;/b&gt;记录并存储它们的偏移量。对于 &lt;code&gt;foreach (@tied_file)&lt;/code&gt; 也是如此，即使您提早退出循环。</target>
        </trans-unit>
        <trans-unit id="6ccb0b24c3db89622ef2ccbd74733225119dada0" translate="yes" xml:space="preserve">
          <source>the lexicals should be separate anyway!)</source>
          <target state="translated">词性应该是分开的!)</target>
        </trans-unit>
        <trans-unit id="b3350ff0610525714cd0795ab7665285a8cf78f9" translate="yes" xml:space="preserve">
          <source>the line number in this file.</source>
          <target state="translated">该文件的行号。</target>
        </trans-unit>
        <trans-unit id="26eb9a372a343a276c4a513a17b9005def4ede8b" translate="yes" xml:space="preserve">
          <source>the line-number of the beginning of the paragraph</source>
          <target state="translated">段首行数</target>
        </trans-unit>
        <trans-unit id="3b67453a7d975f1bc1459469c850c239cfab6efb" translate="yes" xml:space="preserve">
          <source>the list of statically loaded extensions. We discuss this case only here.</source>
          <target state="translated">静态加载的扩展列表。我们在这里只讨论这种情况。</target>
        </trans-unit>
        <trans-unit id="051f0efa2b53b111aaca897cc0e249865ec7115d" translate="yes" xml:space="preserve">
          <source>the listed operators from being used when compiling code in the compartment (</source>
          <target state="translated">所列的运算符在编译车厢内的代码时不被使用(</target>
        </trans-unit>
        <trans-unit id="d8e84d0ea6af468855c18cc5c4165d6c2edf43f5" translate="yes" xml:space="preserve">
          <source>the listed operators to be used when compiling code in the compartment (</source>
          <target state="translated">所列出的运算符在编译车厢内的代码时要使用 (</target>
        </trans-unit>
        <trans-unit id="31de264c7a353042751dac7324ee677917f37a3f" translate="yes" xml:space="preserve">
          <source>the name of the attribute;</source>
          <target state="translated">属性的名称。</target>
        </trans-unit>
        <trans-unit id="9a6dd96ba410443fbba39f655ba62d36a863540d" translate="yes" xml:space="preserve">
          <source>the name of the command for this POD paragraph</source>
          <target state="translated">该POD段的命令名称。</target>
        </trans-unit>
        <trans-unit id="2c087f6dc6a4c7745ab845d35d36946b340507ca" translate="yes" xml:space="preserve">
          <source>the name of the distribution file). The rest of the line is optional. The comment part is delimited by a dash just as in the man page header.</source>
          <target state="translated">分发文件的名称)。)其余部分是可选的。注释部分用破折号分隔,就像在手册页头一样。</target>
        </trans-unit>
        <trans-unit id="ca482cb8c936ba1473c739bc3144869ba0ef4341" translate="yes" xml:space="preserve">
          <source>the name of the package into which it was declared;</source>
          <target state="translated">它被声明的包的名称。</target>
        </trans-unit>
        <trans-unit id="14146974f9eb8a14ac07caec61bf51bf5504d35b" translate="yes" xml:space="preserve">
          <source>the name of the phase in which the handler is being invoked;</source>
          <target state="translated">正在调用处理程序的阶段的名称。</target>
        </trans-unit>
        <trans-unit id="7cfba45823ccfce6febf457efcadfb34ef2605e6" translate="yes" xml:space="preserve">
          <source>the name of the quotelike operator (if any),</source>
          <target state="translated">quotelike运算符的名称(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="89dfd16b868608208dc5e268bb3cefacf7817535" translate="yes" xml:space="preserve">
          <source>the newline. In general, lines in Perl do not need any form of continuation mark, because &lt;b&gt;whitespace&lt;/b&gt; (including newlines) is gleefully ignored. Usually.</source>
          <target state="translated">换行符。通常，Perl中的行不需要任何形式的延续标记，因为&lt;b&gt;空白&lt;/b&gt;（包括换行符）会被忽略。通常。</target>
        </trans-unit>
        <trans-unit id="372fe5c4d24ded7bde11806c2356f0b5e1e0ace4" translate="yes" xml:space="preserve">
          <source>the next interpreter is constructed. By default, when perl is not built with any special options, the global variable &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt; , since extra cleaning isn't usually needed when a program only ever creates a single interpreter in its entire lifetime.</source>
          <target state="translated">下一个解释器被构建。默认情况下，当未使用任何特殊选项构建perl时，全局变量 &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; 设置为 &lt;code&gt;0&lt;/code&gt; ，因为当程序在其整个生命周期中仅创建一个解释器时，通常不需要额外的清理。</target>
        </trans-unit>
        <trans-unit id="39b65447e9246a75ec1295250c74aaaa79fc46a4" translate="yes" xml:space="preserve">
          <source>the number of bytes used for storing the integer,</source>
          <target state="translated">用于存储整数的字节数。</target>
        </trans-unit>
        <trans-unit id="6a32bdad61a31a90e6bb104533ea9d93e395672b" translate="yes" xml:space="preserve">
          <source>the number of elements of each. It's so easy to make that mistake in reading &lt;code&gt;ok @foo, @bar&lt;/code&gt; that you might want to be very explicit about it, and instead write &lt;code&gt;ok &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;(@foo),
&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;(@bar)&lt;/code&gt; .</source>
          <target state="translated">每个元素的数量。在读取 &lt;code&gt;ok @foo, @bar&lt;/code&gt; 容易犯这样的错误，以至于您可能想对它非常明确，而改写 &lt;code&gt;ok &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;(@foo), &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;(@bar)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="823166c6684adfe84aefb20864f10ef5d6cd3d28" translate="yes" xml:space="preserve">
          <source>the numeric value of $c becomes 13. There is no doubt now that the module symbolic provides a</source>
          <target state="translated">c的数值就变成了13。现在毫无疑问的是,模块符号提供了一个叫做</target>
        </trans-unit>
        <trans-unit id="1ac3c3d918bc81daf5c65f159136b230693ee8fc" translate="yes" xml:space="preserve">
          <source>the offset from SvPVX back to the true start of the allocated buffer, which will be non-zero if &lt;code&gt;sv_chop&lt;/code&gt; has been used to efficiently remove characters from start of the buffer. Implemented as a macro, which takes the address of</source>
          <target state="translated">从SvPVX返回分配的缓冲区的真实起始位置的偏移量，如果已使用 &lt;code&gt;sv_chop&lt;/code&gt; 从缓冲区的起始位置有效删除字符，则偏移量将为非零。实现为一个宏，它使用以下地址</target>
        </trans-unit>
        <trans-unit id="7ea73421a1bf18378d7ef84367c0382aecac8634" translate="yes" xml:space="preserve">
          <source>the opening tag</source>
          <target state="translated">开头语</target>
        </trans-unit>
        <trans-unit id="3b0998471797c48420431e27eecb5eb2cb35a85a" translate="yes" xml:space="preserve">
          <source>the opposite of &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;. Unfortunately.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 相反。不幸。</target>
        </trans-unit>
        <trans-unit id="80df94a93d5470e4069dee2128b3a3694259c404" translate="yes" xml:space="preserve">
          <source>the opposite of &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;. Unfortunately.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 相反。不幸。</target>
        </trans-unit>
        <trans-unit id="93d702a52abd879c9ef0db6a688f9798f839daa7" translate="yes" xml:space="preserve">
          <source>the option.</source>
          <target state="translated">的选项。</target>
        </trans-unit>
        <trans-unit id="350cdcf12a74c00b21d0c4d53a770475da27efeb" translate="yes" xml:space="preserve">
          <source>the other way round, some texts define the</source>
          <target state="translated">反过来说,有的文本将 &quot;不可能 &quot;定义为 &quot;不可能&quot;,有的文本将 &quot;不可能 &quot;定义为 &quot;不可能&quot;,有的文本将 &quot;不可能 &quot;定义为 &quot;不可能&quot;。</target>
        </trans-unit>
        <trans-unit id="2f75519c4c0e14572b57dc5211980f1b5e587f4d" translate="yes" xml:space="preserve">
          <source>the output produced should be the following:</source>
          <target state="translated">产生的输出应该是以下内容:</target>
        </trans-unit>
        <trans-unit id="5c767ed6a2f2639fc062b9d28d7dc0b33633147a" translate="yes" xml:space="preserve">
          <source>the output string will be UTF-8-encoded &lt;code&gt;ab\x80c = \x{100}\n&lt;/code&gt; , but &lt;code&gt;$a&lt;/code&gt; will stay byte-encoded.</source>
          <target state="translated">输出字符串将是UTF-8编码的 &lt;code&gt;ab\x80c = \x{100}\n&lt;/code&gt; ，但是 &lt;code&gt;$a&lt;/code&gt; 将保持字节编码。</target>
        </trans-unit>
        <trans-unit id="b4a8c523528b0d85f392e6ce4200ec9cbaf77eae" translate="yes" xml:space="preserve">
          <source>the paragraph text for the given POD paragraph command.</source>
          <target state="translated">给定的POD段落命令的段落文本。</target>
        </trans-unit>
        <trans-unit id="f822b49959962d70befcbfcacaf19dd9565d4689" translate="yes" xml:space="preserve">
          <source>the parser to provide an option for turning off whatever feature Y is (like expanding tabs in verbatim paragraphs), although it implicates that such an option</source>
          <target state="translated">解析器提供了一个选项,可以关闭任何功能Y(比如在逐字段中展开制表符),尽管它意味着这样的选项</target>
        </trans-unit>
        <trans-unit id="88570ffa7933968d627f1b08ec22739c075ae741" translate="yes" xml:space="preserve">
          <source>the pattern explicitly mentions a code point that is above 255 (say by &lt;code&gt;\x{100}&lt;/code&gt; ); or</source>
          <target state="translated">该模式明确提到一个高于255的代码点（用 &lt;code&gt;\x{100}&lt;/code&gt; ）；要么</target>
        </trans-unit>
        <trans-unit id="d194fb71a02627a887a473822a155aa2e1f901a9" translate="yes" xml:space="preserve">
          <source>the pattern is encoded in UTF-8; or</source>
          <target state="translated">该模式以UTF-8编码;或</target>
        </trans-unit>
        <trans-unit id="ce1751b05d1676c44a794cb888d1e90f057639f9" translate="yes" xml:space="preserve">
          <source>the pattern that matched the tag). For example, if the opening tag pattern is specified as &lt;code&gt;'{{\w+}}'&lt;/code&gt; and actually matched the opening tag &lt;code&gt;&quot;{{DATA}}&quot;&lt;/code&gt; , then the constructed closing tag would be &lt;code&gt;&quot;{{/DATA}}&quot;&lt;/code&gt; .</source>
          <target state="translated">与代码匹配的模式）。例如，如果将开始标记模式指定为 &lt;code&gt;'{{\w+}}'&lt;/code&gt; 并且实际上与开始标记 &lt;code&gt;&quot;{{DATA}}&quot;&lt;/code&gt; 相匹配，则构造的结束标记将为 &lt;code&gt;&quot;{{/DATA}}&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="805958852b9fabd97d8cb3a18bac20800a22b67b" translate="yes" xml:space="preserve">
          <source>the pattern uses &lt;a href=&quot;#(%3f%5b-%5d)&quot;&gt;(?[ ])&lt;/a&gt;</source>
          <target state="translated">模式使用&lt;a href=&quot;#(%3f%5b-%5d)&quot;&gt;（？[]）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a8bb7e10331595813f75125fc26a7f202e7e37c1" translate="yes" xml:space="preserve">
          <source>the pattern uses a Unicode break (&lt;code&gt;\b{...}&lt;/code&gt; or &lt;code&gt;\B{...}&lt;/code&gt; ); or</source>
          <target state="translated">该模式使用Unicode中断（ &lt;code&gt;\b{...}&lt;/code&gt; 或 &lt;code&gt;\B{...}&lt;/code&gt; ）；要么</target>
        </trans-unit>
        <trans-unit id="a330eac785acc5b1bb1635b3789e2d14f4710fa2" translate="yes" xml:space="preserve">
          <source>the pattern uses a Unicode name (&lt;code&gt;\N{...}&lt;/code&gt; ); or</source>
          <target state="translated">模式使用Unicode名称（ &lt;code&gt;\N{...}&lt;/code&gt; ）；要么</target>
        </trans-unit>
        <trans-unit id="319de4125fd648dad000c6e1c9a4045715bad67c" translate="yes" xml:space="preserve">
          <source>the pattern uses a Unicode property (&lt;code&gt;\p{...}&lt;/code&gt; or &lt;code&gt;\P{...}&lt;/code&gt; ); or</source>
          <target state="translated">该模式使用Unicode属性（ &lt;code&gt;\p{...}&lt;/code&gt; 或 &lt;code&gt;\P{...}&lt;/code&gt; ）；要么</target>
        </trans-unit>
        <trans-unit id="953fba431cfe195c351926c788501983650a8200" translate="yes" xml:space="preserve">
          <source>the perlfaq1 manpage: General Questions About Perl</source>
          <target state="translated">perlfaq1 manpage。关于Perl的一般问题</target>
        </trans-unit>
        <trans-unit id="c962ba6946dbfccd85f3f5271a7003191ebd8887" translate="yes" xml:space="preserve">
          <source>the perlfaq2 manpage: Obtaining and Learning about Perl</source>
          <target state="translated">的 perlfaq2 manpage。获取和学习Perl</target>
        </trans-unit>
        <trans-unit id="55228c77c8f20b7e875b18ee26f839f3183d399f" translate="yes" xml:space="preserve">
          <source>the perlfaq3 manpage: Programming Tools</source>
          <target state="translated">perlfaq3 manpage。编程工具</target>
        </trans-unit>
        <trans-unit id="c72ba9d1250ab34429dfe558dcf1ad599418504b" translate="yes" xml:space="preserve">
          <source>the perlfaq4 manpage: Data Manipulation</source>
          <target state="translated">perlfaq4 manpage:数据处理</target>
        </trans-unit>
        <trans-unit id="05f2cb3f31b45754271926a93a37e613128fc1a3" translate="yes" xml:space="preserve">
          <source>the perlfaq5 manpage: Files and Formats</source>
          <target state="translated">perlfaq5 manpage。文件和格式</target>
        </trans-unit>
        <trans-unit id="68004027bca85f0a1316b9b13a10b7b5846e0a1b" translate="yes" xml:space="preserve">
          <source>the perlfaq6 manpage: Regular Expressions</source>
          <target state="translated">的 perlfaq6 manpage。正则表达式</target>
        </trans-unit>
        <trans-unit id="244f6e549e1a7c9b4840cdb2b7c4f9d9cf311f72" translate="yes" xml:space="preserve">
          <source>the perlfaq7 manpage: General Perl Language Issues</source>
          <target state="translated">perlfaq7 manpage。一般的Perl语言问题</target>
        </trans-unit>
        <trans-unit id="b09ef579f2deb212ce34e20f6e0845f53a94647e" translate="yes" xml:space="preserve">
          <source>the perlfaq8 manpage: System Interaction</source>
          <target state="translated">perlfaq8 manpage:系统交互</target>
        </trans-unit>
        <trans-unit id="bbac669f56b77bc0a865f02b9aa3ccb0fa2fd2de" translate="yes" xml:space="preserve">
          <source>the perlfaq9 manpage: Web, Email and Networking</source>
          <target state="translated">perlfaq9 manpage。网络、电子邮件和网络</target>
        </trans-unit>
        <trans-unit id="6bfc9a7a2833aaf0aa50c76f44094717b420d8b5" translate="yes" xml:space="preserve">
          <source>the pref information as a hashref, suitable for e.g. passing to Kwalify</source>
          <target state="translated">pref信息作为一个hashref,适用于例如传递给Kwalify。</target>
        </trans-unit>
        <trans-unit id="d6f629b5712722c77da1582162b0d1da4ce910df" translate="yes" xml:space="preserve">
          <source>the prefix substring (if any),</source>
          <target state="translated">前缀子串(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="c7e0fd34e186fae12bf85657d77257670a5ce766" translate="yes" xml:space="preserve">
          <source>the processing of the declaration. In particular, this means that a subroutine reference will probably be for an undefined subroutine, even if this declaration is actually part of the definition.</source>
          <target state="translated">声明的处理。特别是,这意味着一个子程序引用很可能是针对一个未定义的子程序,即使这个声明实际上是定义的一部分。</target>
        </trans-unit>
        <trans-unit id="b351ba6a6e6888ee3c37542cb09a710b8b82c7ea" translate="yes" xml:space="preserve">
          <source>the program's command name itself. See &lt;a href=&quot;#%240&quot;&gt;$0&lt;/a&gt; for the command name.</source>
          <target state="translated">程序的命令名称本身。命令名称请参见&lt;a href=&quot;#%240&quot;&gt;$ 0&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d7c7188cc51913744a65950d8ac98c6b2024d7e" translate="yes" xml:space="preserve">
          <source>the record separator string is not supported by this module. It will probably produce a reasonable result, but what this result will be may change in a future version. Use 'splice' to insert records or to replace one record with several.</source>
          <target state="translated">本模块不支持记录分隔符字符串。它可能会产生一个合理的结果,但是这个结果在未来的版本中可能会改变。使用'拼接'来插入记录或用多个记录替换一个记录。</target>
        </trans-unit>
        <trans-unit id="d9590ce68e648fe5245544ed53294f3198783eab" translate="yes" xml:space="preserve">
          <source>the remainder of the input text,</source>
          <target state="translated">输入文本的剩余部分。</target>
        </trans-unit>
        <trans-unit id="2480552762ce0f7abb766d5aad5385526748ef25" translate="yes" xml:space="preserve">
          <source>the result is case-insensitive, but dotless and dotted I's are not distinguished</source>
          <target state="translated">结果是不区分大小写的,但无点和有点的I是不区分的。</target>
        </trans-unit>
        <trans-unit id="e02477c839224237a3c3acbfe105933f3d8288fa" translate="yes" xml:space="preserve">
          <source>the result is not fully case-insensitive, but dotless and dotted I's are distinguished</source>
          <target state="translated">结果并不完全区分大小写,但无点和有点的I是有区别的。</target>
        </trans-unit>
        <trans-unit id="0fe1d2372ef544a5efce8a965e686132c2b4c0e1" translate="yes" xml:space="preserve">
          <source>the result will be false).</source>
          <target state="translated">结果将是假的)。)</target>
        </trans-unit>
        <trans-unit id="b06be03c9501d35691a73d29665e3b477dbd827b" translate="yes" xml:space="preserve">
          <source>the result will be the undefined value).</source>
          <target state="translated">结果将是未定义的值)。)</target>
        </trans-unit>
        <trans-unit id="27760396d0989c824fad36d89d509e322049bf0f" translate="yes" xml:space="preserve">
          <source>the result will be this:</source>
          <target state="translated">结果将是这样的。</target>
        </trans-unit>
        <trans-unit id="367913a66fb3ed48526d213b1374566f40feb169" translate="yes" xml:space="preserve">
          <source>the result will be true).</source>
          <target state="translated">结果将为真)。)</target>
        </trans-unit>
        <trans-unit id="5be9ceecc2f03bc42e4d234aec808162f9c2f9d1" translate="yes" xml:space="preserve">
          <source>the result would be:</source>
          <target state="translated">结果将是:</target>
        </trans-unit>
        <trans-unit id="241bdcd79cc64588f799c8af99318c6a86f527b4" translate="yes" xml:space="preserve">
          <source>the returned arrays look like this:</source>
          <target state="translated">返回的数组是这样的。</target>
        </trans-unit>
        <trans-unit id="4b13e4f057405f08d33690de1235c5ad2d9163da" translate="yes" xml:space="preserve">
          <source>the right delimiter of the first block of the operation,</source>
          <target state="translated">操作的第一块的右边定界符。</target>
        </trans-unit>
        <trans-unit id="60b10a956ccb270d29db4fedcf97954e7d906c61" translate="yes" xml:space="preserve">
          <source>the right delimiter of the second block of the operation (if any),</source>
          <target state="translated">操作的第二块的右边定界符(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="ad88a8d6474f71e4dc65118e206ccce36d69c740" translate="yes" xml:space="preserve">
          <source>the right operand. That makes the order of the operands to the smartmatch operand often opposite that of the regular match operator. In other words, the &quot;smaller&quot; thing is usually placed in the left operand and the larger one in the right.</source>
          <target state="translated">的正确操作数。这使得smartmatch操作数的操作数顺序往往与常规匹配操作数的顺序相反。换句话说,&quot;小 &quot;的东西通常放在左边操作数中,大的放在右边。</target>
        </trans-unit>
        <trans-unit id="2cfb8735544da2f4a5ef7ac3c46c65d846bf586e" translate="yes" xml:space="preserve">
          <source>the run-time component of the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; before those attributes will get applied. For example:</source>
          <target state="translated">这些属性之前的 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 的运行时组件将被应用。例如：</target>
        </trans-unit>
        <trans-unit id="6d94dd13fa0ce302453b0c13e41fb22167f72ae8" translate="yes" xml:space="preserve">
          <source>the same as</source>
          <target state="translated">一样</target>
        </trans-unit>
        <trans-unit id="4a54b07cf28d2bc23ffe3bae6be39ad94b599265" translate="yes" xml:space="preserve">
          <source>the same as deleting the first quote-like pattern. For instance, if &lt;code&gt;$text&lt;/code&gt; contained the string:</source>
          <target state="translated">与删除第一个类似引号的模式相同。例如，如果 &lt;code&gt;$text&lt;/code&gt; 包含字符串：</target>
        </trans-unit>
        <trans-unit id="4469a15edc678368007d1292ad39f49f19322ee8" translate="yes" xml:space="preserve">
          <source>the same as other handles and so can be compared to other handles with C&amp;lt;==&amp;gt;.</source>
          <target state="translated">与其他句柄相同，因此可以与使用C &amp;lt;==&amp;gt;的其他句柄进行比较。</target>
        </trans-unit>
        <trans-unit id="6b5e2a5e0bc0ec284b2d2c3c088213d01cf46e05" translate="yes" xml:space="preserve">
          <source>the same as saying</source>
          <target state="translated">异曲同工</target>
        </trans-unit>
        <trans-unit id="bec4472defb167aab839db0f227cd83d65a998d5" translate="yes" xml:space="preserve">
          <source>the same as writing:</source>
          <target state="translated">和写作一样。</target>
        </trans-unit>
        <trans-unit id="f928cb2e61789033643a88e1121c24fc6aa53ad7" translate="yes" xml:space="preserve">
          <source>the same thing as &lt;code&gt;$array-&amp;gt;[$x]&lt;/code&gt; here:</source>
          <target state="translated">与 &lt;code&gt;$array-&amp;gt;[$x]&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7166971113169815fd6133fa5f7f6afb0631ef1f" translate="yes" xml:space="preserve">
          <source>the same way as a &lt;code&gt;(?{ code })&lt;/code&gt; code block as described above, except that its return value, rather than being assigned to &lt;code&gt;$^R&lt;/code&gt; , is treated as a pattern, compiled if it's a string (or used as-is if its a qr// object), then matched as if it were inserted instead of this construct.</source>
          <target state="translated">与上述 &lt;code&gt;(?{ code })&lt;/code&gt; 代码块的方式相同，不同之处在于，它的返回值而不是被分配给 &lt;code&gt;$^R&lt;/code&gt; ，被视为一种模式，如果它是字符串（或按原样使用，则按原样编译） （它是一个qr //对象），然后进行匹配，就好像是插入它而不是插入此结构一样。</target>
        </trans-unit>
        <trans-unit id="e89f36e67616aec49128c0b99a888a103286f66b" translate="yes" xml:space="preserve">
          <source>the same. The behavior is nearly the same as well: as of version 2.15, &lt;code&gt;cp&lt;/code&gt; will preserve the source file's permission bits like the shell utility &lt;code&gt;cp(1)&lt;/code&gt; would do, while &lt;code&gt;copy&lt;/code&gt; uses the default permissions for the target file (which may depend on the process' &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;, file ownership, inherited ACLs, etc.). If an error occurs in setting permissions, &lt;code&gt;cp&lt;/code&gt; will return 0, regardless of whether the file was successfully copied.</source>
          <target state="translated">相同。行为也几乎相同：从2.15版开始， &lt;code&gt;cp&lt;/code&gt; 会像外壳实用程序 &lt;code&gt;cp(1)&lt;/code&gt; 一样保留源文件的权限位，而 &lt;code&gt;copy&lt;/code&gt; 使用目标文件的默认权限（这可能取决于进程） ' &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; ，文件所有权，继承的ACL等）。如果设置权限时发生错误，则无论文件是否被成功复制， &lt;code&gt;cp&lt;/code&gt; 都将返回0。</target>
        </trans-unit>
        <trans-unit id="bf9d556cf0621f4c68ec518e9dbcab9943fe668e" translate="yes" xml:space="preserve">
          <source>the same:</source>
          <target state="translated">同样的。</target>
        </trans-unit>
        <trans-unit id="22e84aae25abedf582a9044f2441d71f8b951ea0" translate="yes" xml:space="preserve">
          <source>the scope of $answer extends from its declaration through the rest of that conditional, including any &lt;code&gt;elsif&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; clauses, but not beyond it. See &lt;a href=&quot;perlsyn#Simple-Statements&quot;&gt;Simple Statements in perlsyn&lt;/a&gt; for information on the scope of variables in statements with modifiers.</source>
          <target state="translated">$ answer的范围从其声明一直延伸到该条件的其余部分，包括任何 &lt;code&gt;elsif&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 子句，但不超出此范围。有关带修饰符的语句中的变量范围的信息，请参见&lt;a href=&quot;perlsyn#Simple-Statements&quot;&gt;perlsyn中的&amp;ldquo;简单语句&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="baa05056e9f40151df0cbff4c98ca1c83f4d8879" translate="yes" xml:space="preserve">
          <source>the scope of $i extends to the end of the loop, but not beyond it, rendering the value of $i inaccessible within &lt;code&gt;some_function()&lt;/code&gt; .</source>
          <target state="translated">$ i的范围扩展到循环的末尾，但不超出循环的末尾，从而使 &lt;code&gt;some_function()&lt;/code&gt; 中无法访问$ i的值。</target>
        </trans-unit>
        <trans-unit id="0ea8f8d788deb7fb70a6641a871bdc6c17293aa9" translate="yes" xml:space="preserve">
          <source>the scope of $line extends from its declaration throughout the rest of the loop construct (including the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; clause), but not beyond it. Similarly, in the conditional</source>
          <target state="translated">$ line的范围从其声明扩展到循环构造的其余部分（包括 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 子句），但不超出其范围。同样，在条件</target>
        </trans-unit>
        <trans-unit id="3f6957153140ae22aa9fb9f71b401aed8cd16dbb" translate="yes" xml:space="preserve">
          <source>the script</source>
          <target state="translated">脚本</target>
        </trans-unit>
        <trans-unit id="7da89157d34955ad49945f6b9e381b3b8cdb2cc8" translate="yes" xml:space="preserve">
          <source>the script itself changes the current working directory (see &lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;)</source>
          <target state="translated">脚本本身会更改当前的工作目录（请参阅&lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="449cd9f9078af9f79eb882318ecbc550b179c573" translate="yes" xml:space="preserve">
          <source>the script name does not contain a directory, then Perl translates the logical name DCL$PATH as a searchlist, using each translation as a directory in which to look for the script. In addition, if no file type is specified, Perl looks in each directory for a file matching the name specified, with a blank type, a type of</source>
          <target state="translated">脚本名中不包含目录,那么Perl将逻辑名DCL$PATH翻译成搜索列表,将每一个翻译作为查找脚本的目录。另外,如果没有指定文件类型,Perl会在每个目录中寻找一个与指定的名称相匹配的文件,类型为空白,类型为</target>
        </trans-unit>
        <trans-unit id="10c6aaa2aa56b4f5e5a61251f8e8a6475ffdd863" translate="yes" xml:space="preserve">
          <source>the second &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; does an implicit &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; re '/u'&lt;/code&gt; .</source>
          <target state="translated">第二个 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; 做一个隐式的 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; re '/u'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8b60cf9d6b9393388855bd42dd0e785a9edbee2" translate="yes" xml:space="preserve">
          <source>the second time</source>
          <target state="translated">第二次</target>
        </trans-unit>
        <trans-unit id="9004c8b4d7ed31914a23183d7f8197de30d808db" translate="yes" xml:space="preserve">
          <source>the smart match does</source>
          <target state="translated">聪明的匹配</target>
        </trans-unit>
        <trans-unit id="567e73c3060ea80a1dc0e2145bdf534f89c50aba" translate="yes" xml:space="preserve">
          <source>the specified dependencies with those declared by the package maintainer. In a future implementation this may be changed to override the original declaration.</source>
          <target state="translated">指定的依赖关系和包维护者声明的依赖关系。在未来的实现中,这可能会被改变,以覆盖原来的声明。</target>
        </trans-unit>
        <trans-unit id="42c5a1faa14a0d961afee6ffbea9c14d7c74f8e9" translate="yes" xml:space="preserve">
          <source>the subroutine is not an XSUB (since &lt;code&gt;START&lt;/code&gt; and &lt;code&gt;ROOT&lt;/code&gt; are non-zero, and &lt;code&gt;XSUB&lt;/code&gt; is not listed, and is thus null);</source>
          <target state="translated">子例程不是XSUB（因为 &lt;code&gt;START&lt;/code&gt; 和 &lt;code&gt;ROOT&lt;/code&gt; 不为零，并且未列出 &lt;code&gt;XSUB&lt;/code&gt; ，因此为null）；</target>
        </trans-unit>
        <trans-unit id="10fe1ebc16aeab11a3ad827ebaddc82decca14de" translate="yes" xml:space="preserve">
          <source>the substring is also matched by an opposite (right or left) delimiter bracket</source>
          <target state="translated">子串也由一个相反的(左右)定界括号匹配</target>
        </trans-unit>
        <trans-unit id="31843bb5ce90f38eb71cec4b5f5deffaacdc2b46" translate="yes" xml:space="preserve">
          <source>the taint-check warnings.</source>
          <target state="translated">玷污检查警告。</target>
        </trans-unit>
        <trans-unit id="dcde512fbbc017dd10c0c524e289f30144aabb32" translate="yes" xml:space="preserve">
          <source>the target string is encoded in UTF-8; or</source>
          <target state="translated">目标字符串以UTF-8编码;或</target>
        </trans-unit>
        <trans-unit id="78afcfad97482e9240ebe12dabc194b0f2c3b3ec" translate="yes" xml:space="preserve">
          <source>the test, not</source>
          <target state="translated">检验,而非</target>
        </trans-unit>
        <trans-unit id="2d6be7e9a29d2284e4a1c1d564d8757213f95f64" translate="yes" xml:space="preserve">
          <source>the text between the opening and closing tags</source>
          <target state="translated">开头和结尾标签之间的文字</target>
        </trans-unit>
        <trans-unit id="a58d49e34d8f22b121d4886a9dee68a05b2211a0" translate="yes" xml:space="preserve">
          <source>the text of the first block of the operation (that is, the contents of a quote, the regex of a match or substitution or the target list of a translation),</source>
          <target state="translated">操作的第一个块的文本(即引号的内容、匹配或替换的regex或翻译的目标列表)。</target>
        </trans-unit>
        <trans-unit id="f5cb25bf17d198d49f2635bab666ce500ee6f816" translate="yes" xml:space="preserve">
          <source>the text of the second block of the operation (that is, the replacement of a substitution or the translation list of a translation),</source>
          <target state="translated">第二块操作的文本(即替换的替换或翻译的翻译列表)。</target>
        </trans-unit>
        <trans-unit id="54e46f0757b022318bd5a239679cf0f1339e841d" translate="yes" xml:space="preserve">
          <source>the tied array will appear to contain &lt;code&gt;(&quot;Gold&quot;, &quot;Frankincense&quot;,
&quot;Myrrh&quot;)&lt;/code&gt; . If you set &lt;code&gt;autochomp&lt;/code&gt; to a false value, the record separator will not be removed. If the file above was tied with</source>
          <target state="translated">绑定的数组似乎包含 &lt;code&gt;(&quot;Gold&quot;, &quot;Frankincense&quot;, &quot;Myrrh&quot;)&lt;/code&gt; 。如果将 &lt;code&gt;autochomp&lt;/code&gt; 设置为false值，则不会删除记录分隔符。如果上面的文件与</target>
        </trans-unit>
        <trans-unit id="2fd283a094fc7f97781b054050f5816883290ed9" translate="yes" xml:space="preserve">
          <source>the trailing modifiers on the operation (if any).</source>
          <target state="translated">操作的尾部修饰符(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="c2a06a77006eafdbaa9e871f0888edc9d2c95d03" translate="yes" xml:space="preserve">
          <source>the type specifier for files nor the name of the handle. It is the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator applied to the handle FILE. It reads one line (well, record--see &lt;a href=&quot;perlvar#%24%2f&quot;&gt;$/ in perlvar&lt;/a&gt;) from the handle FILE in scalar context, or</source>
          <target state="translated">文件的类型说明符或句柄的名称。它是应用于句柄FILE 的 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符。它在标量上下文中从句柄FILE 读取一行（好，记录-参见&lt;a href=&quot;perlvar#%24%2f&quot;&gt;$ /在perlvar中&lt;/a&gt;），或者</target>
        </trans-unit>
        <trans-unit id="1c4360009fff54302b1156b6832fe5d026c5d637" translate="yes" xml:space="preserve">
          <source>the uncompressed data has been written to the output buffer - the size of &lt;code&gt;$output&lt;/code&gt; is unbounded.</source>
          <target state="translated">未压缩的数据已写入输出缓冲区- &lt;code&gt;$output&lt;/code&gt; 的大小不受限制。</target>
        </trans-unit>
        <trans-unit id="72c4cb01ed9c295c259e9012dc844c21ed4b9c75" translate="yes" xml:space="preserve">
          <source>the user will see something like this:</source>
          <target state="translated">用户会看到这样的东西。</target>
        </trans-unit>
        <trans-unit id="09d1d1059ffc788eba4027840dd9c61844d867ea" translate="yes" xml:space="preserve">
          <source>the value for that key is true (since it's not 0 or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), so the next skips that iteration and the loop goes to the next element.</source>
          <target state="translated">该键的值是true（因为它不是0或 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），因此下一个跳过该迭代，并且循环转到下一个元素。</target>
        </trans-unit>
        <trans-unit id="10f60af7d3da39c8283e440b7b68c1b0162b43c3" translate="yes" xml:space="preserve">
          <source>the value to format. Where an argument is specified by an explicit index, this does not affect the normal order for the arguments, even when the explicitly specified index would have been the next argument.</source>
          <target state="translated">的值进行格式化。如果一个参数是由显式索引指定的,这不会影响参数的正常顺序,即使显式指定的索引本来是下一个参数。</target>
        </trans-unit>
        <trans-unit id="98edb59e477d5f73aabed933ed88c199f2e02581" translate="yes" xml:space="preserve">
          <source>the way you want.</source>
          <target state="translated">你想要的方式。</target>
        </trans-unit>
        <trans-unit id="fb6fef64bdf2aef98be4e3412576b2eb3744b578" translate="yes" xml:space="preserve">
          <source>them if you start &lt;code&gt;perl__.exe&lt;/code&gt; from a PM program which emulates a console window, like</source>
          <target state="translated">如果您从模拟控制台窗口的PM程序中启动 &lt;code&gt;perl__.exe&lt;/code&gt; ，则它们</target>
        </trans-unit>
        <trans-unit id="6f8f8e9f767353d846d34ea5a451c83849c1b01b" translate="yes" xml:space="preserve">
          <source>then</source>
          <target state="translated">then</target>
        </trans-unit>
        <trans-unit id="88a7a77aa5c568f548a7b47a898fe68e7d901cc1" translate="yes" xml:space="preserve">
          <source>then $parser-&amp;gt;get_short_title on that document will return &quot;Hoo::Boy::Wowza&quot;.</source>
          <target state="translated">那么该文档上的$ parser-&amp;gt; get_short_title将返回&amp;ldquo; Hoo :: Boy :: Wowza&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="23f4cf92407a7fe5d8794a5c9a42f3e2ead3acdc" translate="yes" xml:space="preserve">
          <source>then $parser-&amp;gt;get_short_title on that document will return &quot;Hooboy, stuff wow yeah!&quot;. If the document starts with:</source>
          <target state="translated">然后该文档上的$ parser-&amp;gt; get_short_title将返回&amp;ldquo; Hooboy，东西哇！&amp;rdquo;。如果文档开头为：</target>
        </trans-unit>
        <trans-unit id="29f40a8c4032e6fbcf21306bda70e2933fe3eafc" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are &lt;code&gt;$main::a&lt;/code&gt; and &lt;code&gt;$main::b&lt;/code&gt; (or &lt;code&gt;$::a&lt;/code&gt; and &lt;code&gt;$::b&lt;/code&gt; ), but if you're in the &lt;code&gt;FooPack&lt;/code&gt; package, it's the same as typing</source>
          <target state="translated">那么 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 分别是 &lt;code&gt;$main::a&lt;/code&gt; 和 &lt;code&gt;$main::b&lt;/code&gt; （或 &lt;code&gt;$::a&lt;/code&gt; 和 &lt;code&gt;$::b&lt;/code&gt; ），但是如果您在 &lt;code&gt;FooPack&lt;/code&gt; 包中，则与键入相同</target>
        </trans-unit>
        <trans-unit id="d5a02d02cd5da551d503521fe8e892f975abdae4" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;$y&lt;/code&gt; is the number closest to zero, and with the same sign as &lt;code&gt;$mod&lt;/code&gt; , satisfying</source>
          <target state="translated">那么 &lt;code&gt;$y&lt;/code&gt; 是最接近零的数字，并且与 &lt;code&gt;$mod&lt;/code&gt; 符号相同，满足</target>
        </trans-unit>
        <trans-unit id="427cce61752fee17f0671abdaf38ee0fa428d694" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;%hash&lt;/code&gt; will have at least 200 buckets allocated for it--256 of them, in fact, since it rounds up to the next power of two. These buckets will be retained even if you do &lt;code&gt;%hash = ()&lt;/code&gt; , use &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;
%hash&lt;/code&gt; if you want to free the storage while &lt;code&gt;%hash&lt;/code&gt; is still in scope. You can't shrink the number of buckets allocated for the hash using &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; in this way (but you needn't worry about doing this by accident, as trying has no effect). &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; in an lvalue context is a syntax error.</source>
          <target state="translated">那么 &lt;code&gt;%hash&lt;/code&gt; 将为其分配至少200个存储桶-实际上，其中有256个存储桶，因为它向上取整为2的下一个幂。即使您执行 &lt;code&gt;%hash = ()&lt;/code&gt; ，这些存储桶也将保留，如果要在 &lt;code&gt;%hash&lt;/code&gt; 仍在作用域内时释放存储，请使用 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; 。您不能以这种方式使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 来缩小为哈希分配的存储桶的数量（但是您不必担心会偶然这样做，因为尝试没有效果）。左值上下文中的 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; @array是语法错误。</target>
        </trans-unit>
        <trans-unit id="0a4706c04d224c9ee392da7cf321cfda0cdbc86d" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;%hash&lt;/code&gt; will have at least 200 buckets allocated for it--256 of them, in fact, since it rounds up to the next power of two. These buckets will be retained even if you do &lt;code&gt;%hash = ()&lt;/code&gt; , use &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;
%hash&lt;/code&gt; if you want to free the storage while &lt;code&gt;%hash&lt;/code&gt; is still in scope. You can't shrink the number of buckets allocated for the hash using &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; in this way (but you needn't worry about doing this by accident, as trying has no effect). &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; in an lvalue context is a syntax error.</source>
          <target state="translated">那么 &lt;code&gt;%hash&lt;/code&gt; 将为其分配至少200个存储桶-实际上，其中有256个存储桶，因为它向上取整为2的下一个幂。即使您执行 &lt;code&gt;%hash = ()&lt;/code&gt; ，这些存储桶也将保留，如果要在 &lt;code&gt;%hash&lt;/code&gt; 仍在作用域内时释放存储，请使用 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; 。您不能以这种方式使用 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 来缩小为哈希分配的存储桶的数量（但是您不必担心会偶然这样做，因为尝试没有效果）。左值上下文中的 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; @array是语法错误。</target>
        </trans-unit>
        <trans-unit id="e0e0f1b2564679b330f3326cd8ff2c67fa198367" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; will attempt to create all the directories in the given path.</source>
          <target state="translated">然后 &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; 将尝试在给定路径中创建所有目录。</target>
        </trans-unit>
        <trans-unit id="07f9429b97c09875ec099fb7f4d7f8efc6e3196e" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;&lt;a href=&quot;../functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; will attempt to delete everything inside the directory.</source>
          <target state="translated">然后 &lt;code&gt;&lt;a href=&quot;../functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; 将尝试删除目录中的所有内容。</target>
        </trans-unit>
        <trans-unit id="be79a8197efa4a6581e5f87f07d768e642f44dc3" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;. If you have a choice, it's better to lowercase things to avoid the problems of the two Latin-1 characters whose uppercase is outside Latin-1: &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt; ). If you do need to upppercase, you can; with a Unicode-enabled Perl, do:</source>
          <target state="translated">然后 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 。如果可以选择，最好使用小写形式，以避免出现两个大写字母在Latin-1之外的Latin-1字符的问题：&amp;ldquo;&amp;yuml;&amp;rdquo;（小 &lt;code&gt;y WITH DIAERESIS&lt;/code&gt; ）和&amp;ldquo; &amp;micro;&amp;rdquo;（ &lt;code&gt;MICRO SIGN&lt;/code&gt; ）。如果确实需要大写，则可以；使用启用Unicode的Perl，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="c4df6b08143f1ed133e0751bce9a14ce00f15fee" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;mypush()&lt;/code&gt; takes arguments exactly like &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push()&lt;/a&gt;&lt;/code&gt; does.</source>
          <target state="translated">然后 &lt;code&gt;mypush()&lt;/code&gt; 接受参数与 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push()&lt;/a&gt;&lt;/code&gt; 完全一样。</target>
        </trans-unit>
        <trans-unit id="d4963e7b580a13c7a47350916f5f4701a5cea5b0" translate="yes" xml:space="preserve">
          <source>then a call to &lt;code&gt;extract_bracketed&lt;/code&gt; in a list context:</source>
          <target state="translated">然后在列表上下文中调用 &lt;code&gt;extract_bracketed&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8fa8d133f35b2e1ecd715f6ea92a4465b64cd21e" translate="yes" xml:space="preserve">
          <source>then a link to it would look like this:</source>
          <target state="translated">那么它的链接会是这样的。</target>
        </trans-unit>
        <trans-unit id="c2d9821598cc4028dc478ca6b184ee82c9a150e8" translate="yes" xml:space="preserve">
          <source>then a reference to an array containing the string &lt;code&gt;&quot;turn it up to 11, man!&quot;&lt;/code&gt; would be passed as the last argument.</source>
          <target state="translated">然后对包含字符串的数组的引用 &lt;code&gt;&quot;turn it up to 11, man!&quot;&lt;/code&gt; 将作为最后一个参数传递。</target>
        </trans-unit>
        <trans-unit id="daefb5fdb08ac51e4ca09289fd271c065db65227" translate="yes" xml:space="preserve">
          <source>then after the deletion it would contain:</source>
          <target state="translated">那么在删除之后,它将包含。</target>
        </trans-unit>
        <trans-unit id="16a5f58b325c405e1b9bf68a059e0e8cba7507e5" translate="yes" xml:space="preserve">
          <source>then answer a few questions and go out for coffee (possibly even in a different city).</source>
          <target state="translated">然后回答几个问题,然后出去喝咖啡(甚至可能在不同的城市)。</target>
        </trans-unit>
        <trans-unit id="c864362dfe8b6f418c3b8afbb4438cb559f4ad66" translate="yes" xml:space="preserve">
          <source>then any bareword that would NOT be interpreted as a subroutine call produces a compile-time error instead. The restriction lasts to the end of the enclosing block. An inner block may countermand this by saying &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict 'subs'&lt;/code&gt; .</source>
          <target state="translated">那么任何不会被解释为子例程调用的裸字都会产生编译时错误。限制持续到封闭块的末尾。内部块可以说这种反对命令 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict 'subs'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a6042bd89492effbfd5f6e8c4f5ed13a20bf888" translate="yes" xml:space="preserve">
          <source>then any variable mentioned from there to the end of the enclosing block must either refer to a lexical variable, be predeclared via &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; , or else must be fully qualified with the package name. A compilation error results otherwise. An inner block may countermand this with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict 'vars'&lt;/code&gt; .</source>
          <target state="translated">那么从那里到封闭块末尾提到的任何变量都必须引用一个词法变量，可以通过 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 进行预先声明，或者必须完全具有包名。否则，将导致编译错误。内部块可以 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict 'vars'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a57900be2b5fa8c20199347f883e5b7b3be9857" translate="yes" xml:space="preserve">
          <source>then call the appropriate routines, casting the returned &lt;code&gt;SV*&lt;/code&gt; to either an &lt;code&gt;AV*&lt;/code&gt; or &lt;code&gt;HV*&lt;/code&gt; , if required.</source>
          <target state="translated">然后调用适当的例程，如果需要，将返回的 &lt;code&gt;SV*&lt;/code&gt; 转换为 &lt;code&gt;AV*&lt;/code&gt; 或 &lt;code&gt;HV*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42e84eb677476703d809f722b1ff2f0066df6dbd" translate="yes" xml:space="preserve">
          <source>then derived classes may (re-)inherit base-class methods through two or more distinct paths (e.g. in the way &lt;code&gt;E&lt;/code&gt; inherits &lt;code&gt;A::foo&lt;/code&gt; twice -- through &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; ). In such cases, a sequence of &lt;code&gt;NEXT&lt;/code&gt; redispatches will invoke the multiply inherited method as many times as it is inherited. For example, the above code prints:</source>
          <target state="translated">然后派生类可以通过两个或更多不同的路径（例如， &lt;code&gt;E&lt;/code&gt; 通过 &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 两次继承 &lt;code&gt;A::foo&lt;/code&gt; 的方式）（重新）继承基类方法。在这种情况下，一系列 &lt;code&gt;NEXT&lt;/code&gt; 重新分派将调用多次继承的方法，使其次数被继承。例如，上面的代码显示：</target>
        </trans-unit>
        <trans-unit id="a614f37aaecfc8d29fe068560e973149cfa5cf7c" translate="yes" xml:space="preserve">
          <source>then here is the output</source>
          <target state="translated">那么下面是输出</target>
        </trans-unit>
        <trans-unit id="622feee1f62a60a311e5e227e74693233442f30c" translate="yes" xml:space="preserve">
          <source>then it would print:</source>
          <target state="translated">就会打印出来。</target>
        </trans-unit>
        <trans-unit id="d3a00c98cd406c22e4b6f2f3ffd7a3f3467e5e23" translate="yes" xml:space="preserve">
          <source>then perl will recompile each time, even though the pattern string hasn't changed, to ensure that the current value of &lt;code&gt;$x&lt;/code&gt; is seen each time. Use &lt;code&gt;/o&lt;/code&gt; if you want to avoid this.</source>
          <target state="translated">然后，即使模式字符串没有更改，perl也会每次重新编译，以确保每次都能看到 &lt;code&gt;$x&lt;/code&gt; 的当前值。如果要避免这种情况，请使用 &lt;code&gt;/o&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c4f205545ab62b2b3e328d72a718521c54e0a64" translate="yes" xml:space="preserve">
          <source>then the &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; substitution will be performed silently.</source>
          <target state="translated">那么 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 替换将以静默方式执行。</target>
        </trans-unit>
        <trans-unit id="3cbb088c80c134614593e2f6eee1e46c2fcede39" translate="yes" xml:space="preserve">
          <source>then the &lt;code&gt;@array&lt;/code&gt; would appear to have four elements:</source>
          <target state="translated">那么 &lt;code&gt;@array&lt;/code&gt; 似乎具有四个元素：</target>
        </trans-unit>
        <trans-unit id="51647320b30c0cdeeeedc259248ba22707613c81" translate="yes" xml:space="preserve">
          <source>then the array &lt;code&gt;@gifts&lt;/code&gt; would appear to contain &lt;code&gt;(&quot;Gold\n&quot;,
&quot;Frankincense\n&quot;, &quot;Myrrh\n&quot;)&lt;/code&gt; , or (on Win32 systems) &lt;code&gt;(&quot;Gold\r\n&quot;,
&quot;Frankincense\r\n&quot;, &quot;Myrrh\r\n&quot;)&lt;/code&gt; .</source>
          <target state="translated">那么数组 &lt;code&gt;@gifts&lt;/code&gt; 似乎包含 &lt;code&gt;(&quot;Gold\n&quot;, &quot;Frankincense\n&quot;, &quot;Myrrh\n&quot;)&lt;/code&gt; 或（在Win32系统上） &lt;code&gt;(&quot;Gold\r\n&quot;, &quot;Frankincense\r\n&quot;, &quot;Myrrh\r\n&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5705bd36756a8f0f099992bbd5c5e2309a6a622c" translate="yes" xml:space="preserve">
          <source>then the binary number may use '_' characters to separate digits.</source>
          <target state="translated">那么二进制数可以使用'_'字符来分隔数字。</target>
        </trans-unit>
        <trans-unit id="8cbf74d1a22f4c12bb5419eef66a0debb65f9111" translate="yes" xml:space="preserve">
          <source>then the external</source>
          <target state="translated">那么外部</target>
        </trans-unit>
        <trans-unit id="dabfa7fd2b9ed457d1e61c46bf829f66a1b108f0" translate="yes" xml:space="preserve">
          <source>then the hex number may use '_' characters to separate digits.</source>
          <target state="translated">那么十六进制数可以使用'_'字符来分隔数字。</target>
        </trans-unit>
        <trans-unit id="b631c3c134aba1a964ce5976afb151eddc3f3c1b" translate="yes" xml:space="preserve">
          <source>then the octal number may use '_' characters to separate digits.</source>
          <target state="translated">那么八进制数字可以使用'_'字符来分隔数字。</target>
        </trans-unit>
        <trans-unit id="74fabb78efcde6da4ccf9db38ed749c11f7c9fa1" translate="yes" xml:space="preserve">
          <source>then the operation</source>
          <target state="translated">那么这个操作</target>
        </trans-unit>
        <trans-unit id="874355591d490dee5442696b955dde5b7234454e" translate="yes" xml:space="preserve">
          <source>then the output will be</source>
          <target state="translated">则输出为</target>
        </trans-unit>
        <trans-unit id="045743d8f9d34f5f6f47ab4d7191f2b38f0e9606" translate="yes" xml:space="preserve">
          <source>then the sort operation provides list context for &amp;lt;&amp;gt;, which will proceed to read every line available up to the end of file, and pass that list of lines back to the sort routine, which will then sort those lines and return them as a list to whatever the context of the sort was.</source>
          <target state="translated">然后sort操作为&amp;lt;&amp;gt;提供列表上下文，该上下文将继续读取直到文件末尾的所有可用行，并将该行列表传递回sort例程，然后该例程对这些行进行排序并将其作为列表返回无论排序的上下文如何。</target>
        </trans-unit>
        <trans-unit id="3009a9d43c2b1f0d7cb92e3fe3c04935627a9d8b" translate="yes" xml:space="preserve">
          <source>then there will be a problem later when the tarfile gets written out to disk via &lt;code&gt;$tar-&lt;/code&gt; write()&amp;gt;:</source>
          <target state="translated">那么以后通过 &lt;code&gt;$tar-&lt;/code&gt; write（）&amp;gt; 将tarfile写出到磁盘时，就会出现问题：</target>
        </trans-unit>
        <trans-unit id="11f83d0fa9475f3a84586f0df189a5ef0cec1361" translate="yes" xml:space="preserve">
          <source>then use the following to get the package name itself:</source>
          <target state="translated">然后使用下面的方法来获取软件包本身的名称。</target>
        </trans-unit>
        <trans-unit id="be0d3cf429c3ee73a23ab767015fb8466fde14fb" translate="yes" xml:space="preserve">
          <source>then use this to access the &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; member</source>
          <target state="translated">然后使用它来访问 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 成员</target>
        </trans-unit>
        <trans-unit id="063029591eda4124365817de430c9e3536123f63" translate="yes" xml:space="preserve">
          <source>then would use an #ifdef guard.</source>
          <target state="translated">然后会使用#ifdef防护。</target>
        </trans-unit>
        <trans-unit id="bca9b0367ec1fa4243df295292555c374501f059" translate="yes" xml:space="preserve">
          <source>then you can do a non-blocking wait for all pending zombie processes. Non-blocking wait is available on machines supporting either the waitpid(2) or wait4(2) syscalls. However, waiting for a particular pid with FLAGS of &lt;code&gt;0&lt;/code&gt; is implemented everywhere. (Perl emulates the system call by remembering the status values of processes that have exited but have not been harvested by the Perl script yet.)</source>
          <target state="translated">那么您可以对所有待处理的僵尸进程进行非阻塞等待。非阻塞等待在支持waitpid（2）或wait4（2）系统调用的机器上可用。但是，随处都实现了等待FLAGS为 &lt;code&gt;0&lt;/code&gt; 的特定pid 。（Perl通过记住已退出但尚未被Perl脚本捕获的进程的状态值来模拟系统调用。）</target>
        </trans-unit>
        <trans-unit id="24e3673901b12a352e45bfe1a29cd357600f2223" translate="yes" xml:space="preserve">
          <source>then you must make sure that your &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine appears before that &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">那么您必须确保您的 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程出现在该 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句之前。</target>
        </trans-unit>
        <trans-unit id="fbcfd002f79bf258f39d2d725e545e20557407da" translate="yes" xml:space="preserve">
          <source>then you would configure CPAN.pm with the command</source>
          <target state="translated">然后你可以用命令来配置CPAN.pm。</target>
        </trans-unit>
        <trans-unit id="fb0a1fd2595bcd62801102e76923b7858beb8c22" translate="yes" xml:space="preserve">
          <source>then your LIBPATH does not have the location of libperl.x and either libperl.dll or libperl.so in it. Add that directory to your LIBPATH and proceed.</source>
          <target state="translated">那么你的 LIBPATH 中没有 libperl.x 和 libperl.dll 或 libperl.so 的位置。将该目录添加到你的 LIBPATH 中,然后继续。</target>
        </trans-unit>
        <trans-unit id="3d3083ee3ba5313a634dabd04c969303606edcbb" translate="yes" xml:space="preserve">
          <source>then your PWD environment variable will be kept up to date. Note that it will only be kept up to date if all packages which use chdir import it from Cwd.</source>
          <target state="translated">那么你的 PWD 环境变量就会保持更新。请注意,只有当所有使用chdir的软件包都从Cwd中导入chdir时,它才会保持最新。</target>
        </trans-unit>
        <trans-unit id="b677073f08588ee6a96aff7b9290e34f7f2c31d3" translate="yes" xml:space="preserve">
          <source>then your script will run without human intervention, putting trace information into the file</source>
          <target state="translated">然后,你的脚本将在没有人为干预的情况下运行,将跟踪信息存入文件</target>
        </trans-unit>
        <trans-unit id="fdc01276daa17eba9f35c662cb1e1a3ce12fc436" translate="yes" xml:space="preserve">
          <source>there's more than one way to do it</source>
          <target state="translated">大道至简</target>
        </trans-unit>
        <trans-unit id="1460929c0c47b645e55308f3833bf025fb32ab4f" translate="yes" xml:space="preserve">
          <source>there.</source>
          <target state="translated">there.</target>
        </trans-unit>
        <trans-unit id="8c5900f2075a21520e816c3509bd71ab5f03dcb9" translate="yes" xml:space="preserve">
          <source>thereby giving the user automatic anonymous login to machines not specified in .netrc.</source>
          <target state="translated">从而让用户自动匿名登录到.netrc中没有指定的机器。</target>
        </trans-unit>
        <trans-unit id="844a579d2ac78e752d68592ad05f19175c7d315a" translate="yes" xml:space="preserve">
          <source>these EMX functions do not work if the path contains a trailing &lt;code&gt;/&lt;/code&gt;. Perl contains a workaround for this.</source>
          <target state="translated">如果路径中包含尾随 &lt;code&gt;/&lt;/code&gt; ,则这些EMX函数将不起作用。 Perl包含一个解决方法。</target>
        </trans-unit>
        <trans-unit id="8f140f5b64c2fb4e240cd7cafc5e3b9a858bd13a" translate="yes" xml:space="preserve">
          <source>these days.</source>
          <target state="translated">这些天</target>
        </trans-unit>
        <trans-unit id="f24426b9ff82a9ecca01636f4317d4a7fdba1697" translate="yes" xml:space="preserve">
          <source>theta</source>
          <target state="translated">theta</target>
        </trans-unit>
        <trans-unit id="f9076a004ebe7521f2460d54a3606de78e10e9f7" translate="yes" xml:space="preserve">
          <source>they would get the default imports without overrides.</source>
          <target state="translated">他们会得到默认的导入,而不会被覆盖。</target>
        </trans-unit>
        <trans-unit id="a3381da6627be60591dc894ff1000a09075d2a79" translate="yes" xml:space="preserve">
          <source>they'll be politely informed that</source>
          <target state="translated">他们会被婉转地告知</target>
        </trans-unit>
        <trans-unit id="a5409d55c4a06a27b55a5136e1dec7d1ae0285e0" translate="yes" xml:space="preserve">
          <source>things. The effective gid is the group that's</source>
          <target state="translated">的事情。有效的吉德是集团的。</target>
        </trans-unit>
        <trans-unit id="7d80d88438d6ad166c5f496a3372a4f27aea9bcf" translate="yes" xml:space="preserve">
          <source>things. The real gid is the group you</source>
          <target state="translated">的事情。真正的吉德是你的群体</target>
        </trans-unit>
        <trans-unit id="c2543fff3bfa6f144c2f06a7de6cd10c0b650cae" translate="yes" xml:space="preserve">
          <source>this</source>
          <target state="translated">this</target>
        </trans-unit>
        <trans-unit id="79df13086927aaa527620acac1e6650e2085d774" translate="yes" xml:space="preserve">
          <source>this TODO</source>
          <target state="translated">此待办事项</target>
        </trans-unit>
        <trans-unit id="852fdaa8c7ce7f8e6638658e6c5843489c4652e6" translate="yes" xml:space="preserve">
          <source>this code could and probably should be written as</source>
          <target state="translated">这段代码可以而且可能应该写成</target>
        </trans-unit>
        <trans-unit id="547fc135c0c908d9b4b5f50835f5c52b636693d6" translate="yes" xml:space="preserve">
          <source>this has the advantage of being backward compatible with how such things have had to be coded on some platforms for years.</source>
          <target state="translated">这样做的好处是可以向后兼容这些东西多年来在一些平台上的编码方式。</target>
        </trans-unit>
        <trans-unit id="5ab21a1ad37e0d8f33b9d32fccefe0d0f9927964" translate="yes" xml:space="preserve">
          <source>this last step may or may not require UID=0 privileges depending on how you answered the questions that Configure asked and whether or not you have write access to the directories you specified.</source>
          <target state="translated">最后一步可能需要UID=0权限,也可能不需要,这取决于您如何回答Configure提出的问题,以及您是否对您指定的目录有写权限。</target>
        </trans-unit>
        <trans-unit id="f7030489b8bb3c6a1f199877396c1b8f99049140" translate="yes" xml:space="preserve">
          <source>this value. In fact this value may be inspected in debugger (see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;), but only if &lt;code&gt;bareStringify&lt;/code&gt;&lt;b&gt;O&lt;/b&gt;ption is set, and not via &lt;code&gt;p&lt;/code&gt; command.</source>
          <target state="translated">这个值。实际上这个值可以在调试器（见待检查&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;），但仅当 &lt;code&gt;bareStringify&lt;/code&gt; &lt;b&gt;&amp;ouml;&lt;/b&gt; ption被设置，而不是通过 &lt;code&gt;p&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="d54ca3cc20a62b1a149415f45240c3a04f288da6" translate="yes" xml:space="preserve">
          <source>this will attempt to remove '/usr' from the front of the $MM-&amp;gt;{INSTALLMAN1DIR} path (initializing it to $Config{installman1dir} if necessary) and replace it with '/home/foo'. If this fails it will simply use '/home/foo/man/man1'.</source>
          <target state="translated">这将尝试从$ MM-&amp;gt; {INSTALLMAN1DIR}路径的开头删除&amp;ldquo; / usr&amp;rdquo;（如有必要，将其初始化为$ Config {installman1dir}），并将其替换为&amp;ldquo; / home / foo&amp;rdquo;。如果失败，它将仅使用&amp;ldquo; / home / foo / man / man1&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="cf99bf2a32d5b6c5bb486fc0e533a4767bda09be" translate="yes" xml:space="preserve">
          <source>thoroughly before using it to submit a bug report.</source>
          <target state="translated">在使用它来提交错误报告之前,要彻底了解它。</target>
        </trans-unit>
        <trans-unit id="9f70a3b0dfe456892cdf57582747cdf3a63728a5" translate="yes" xml:space="preserve">
          <source>those loaded by the base name from &lt;code&gt;LIBPATH&lt;/code&gt; ; including those associated at link time;</source>
          <target state="translated">由 &lt;code&gt;LIBPATH&lt;/code&gt; 的基本名称加载的那些; 包括在链接时关联的那些；</target>
        </trans-unit>
        <trans-unit id="524cd37ee4c7405f7efcc0020d541eb55192c55c" translate="yes" xml:space="preserve">
          <source>though the use of these constructs during run-time is questionable.</source>
          <target state="translated">尽管在运行时使用这些构造是值得怀疑的。</target>
        </trans-unit>
        <trans-unit id="ebb820ea5438310928a21485a7027cfe032626d2" translate="yes" xml:space="preserve">
          <source>thread and one or more</source>
          <target state="translated">螺纹和一个或多个</target>
        </trans-unit>
        <trans-unit id="be00c0bf8bd61a841d302e53df235310f4c7c683" translate="yes" xml:space="preserve">
          <source>thread associated with the specified thread ID. If &lt;code&gt;$tid&lt;/code&gt; is the value for the current thread, then this call works the same as &lt;code&gt;-&amp;gt;self()&lt;/code&gt; . Otherwise, returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there is no thread associated with the TID, if the thread is joined or detached, if no TID is specified or if the specified TID is undef.</source>
          <target state="translated">与指定线程ID关联的线程。如果 &lt;code&gt;$tid&lt;/code&gt; 是当前线程的值，则此调用的工作方式与 &lt;code&gt;-&amp;gt;self()&lt;/code&gt; 相同。否则，返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 如果没有与TID相关的线程，如果线程连接或分离，如果未指定TID或者指定的TID是联合国民主基金。</target>
        </trans-unit>
        <trans-unit id="2b1aaf78f7385dec07cce860bf6f1ce1534ad089" translate="yes" xml:space="preserve">
          <source>thread exits, then this warning cannot be suppressed using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'threads';&lt;/code&gt; as suggested below.</source>
          <target state="translated">线程退出，则不能使用 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'threads';&lt;/code&gt; 来抑制此警告；如下所示。</target>
        </trans-unit>
        <trans-unit id="df2e34e3cdb0a60c4d04443ed90e706147fd9b35" translate="yes" xml:space="preserve">
          <source>thread is unaffected by this call.</source>
          <target state="translated">线程不受此调用的影响。</target>
        </trans-unit>
        <trans-unit id="1ba2970dd88ad4b4e72572ffdf22c1deb7f60a35" translate="yes" xml:space="preserve">
          <source>thread is unaffected by this setting.</source>
          <target state="translated">线程不受此设置的影响。</target>
        </trans-unit>
        <trans-unit id="dc0153b46f92c9aa69c2610e01a4d11d889157f9" translate="yes" xml:space="preserve">
          <source>thread safe when using the older (experimental and now obsolete) threads implementation that was added to Perl 5.005.</source>
          <target state="translated">当使用Perl 5.005中加入的旧的(实验性的、现在已经过时的)线程实现时,线程安全。</target>
        </trans-unit>
        <trans-unit id="065606106bace6e1bb589c52e0923b46b92fe690" translate="yes" xml:space="preserve">
          <source>thread support</source>
          <target state="translated">线程支持</target>
        </trans-unit>
        <trans-unit id="d67afc3417d4958f3ed82fd0be1bd179bac68b33" translate="yes" xml:space="preserve">
          <source>thread yield</source>
          <target state="translated">产量</target>
        </trans-unit>
        <trans-unit id="f021c519858ead3d56da5875f6a26d3e07030faa" translate="yes" xml:space="preserve">
          <source>thread, this behaves the same as &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(0)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">线程，其行为与 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(0)&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="7a6089c4861a7d61af8bfceb243bdda56ad1f409" translate="yes" xml:space="preserve">
          <source>thread, this behaves the same as &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(status)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">线程，其行为与 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(status)&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="29c60465c379bf1644566a78609304cb3aa69b61" translate="yes" xml:space="preserve">
          <source>thread, try modifying your application so that the module is loaded (again using &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;-&amp;gt;import()&lt;/code&gt; ) after any threads are started, and in such a way that no other threads are started afterwards.</source>
          <target state="translated">线程，请尝试修改您的应用程序，以便在启动任何线程之后加载该模块（再次使用 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;-&amp;gt;import()&lt;/code&gt; ），并在这种方式之后再启动其他线程。</target>
        </trans-unit>
        <trans-unit id="0e92998455c09ed4e96524633947d3882bf21535" translate="yes" xml:space="preserve">
          <source>thread-safe</source>
          <target state="translated">thread-safe</target>
        </trans-unit>
        <trans-unit id="322b4598be3f1d250c204de6245d6c3281828f5e" translate="yes" xml:space="preserve">
          <source>thread. In other words, changes made to &lt;code&gt;%ENV&lt;/code&gt; in a thread will not be visible in</source>
          <target state="translated">线。换句话说，在线程中对 &lt;code&gt;%ENV&lt;/code&gt; 所做的更改在</target>
        </trans-unit>
        <trans-unit id="c91e11a1f2a2f6f290fe5039f78f07f318049442" translate="yes" xml:space="preserve">
          <source>threads</source>
          <target state="translated">threads</target>
        </trans-unit>
        <trans-unit id="d87386329ab23fe84cf857fa28d7406622a9a3cb" translate="yes" xml:space="preserve">
          <source>threads - Perl interpreter-based threads</source>
          <target state="translated">线程-基于Perl解释器的线程。</target>
        </trans-unit>
        <trans-unit id="64cc47f9346b8151a8e1bff1bf7a7575d5c6a720" translate="yes" xml:space="preserve">
          <source>threads is released under the same license as Perl.</source>
          <target state="translated">线程是在与Perl相同的许可下发布的。</target>
        </trans-unit>
        <trans-unit id="0845f72ee5a4a2716804978863f8393b6a1597f6" translate="yes" xml:space="preserve">
          <source>threads while there are still existing</source>
          <target state="translated">线程,而仍然存在</target>
        </trans-unit>
        <trans-unit id="b496a5f4b694561f23d5585cda62ccf1df1b03ee" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;wantarray()</source>
          <target state="translated">threads-&amp;gt;wantarray()</target>
        </trans-unit>
        <trans-unit id="3e03e1e2552cb929142ffa79d30112ff5706e673" translate="yes" xml:space="preserve">
          <source>threads.</source>
          <target state="translated">threads.</target>
        </trans-unit>
        <trans-unit id="f7f5cb25f9bc9773be646466ec1376299a475b0d" translate="yes" xml:space="preserve">
          <source>threads. The boss thread gathers or generates tasks that need to be done, then parcels those tasks out to the appropriate worker thread.</source>
          <target state="translated">线程。老大线程收集或生成需要完成的任务,然后将这些任务解析给相应的工作者线程。</target>
        </trans-unit>
        <trans-unit id="d5a02881a442580d4c3de9e92a5357a1d6618663" translate="yes" xml:space="preserve">
          <source>threads.pm</source>
          <target state="translated">threads.pm</target>
        </trans-unit>
        <trans-unit id="74b6e8e1e1109a88c34e023c749582b0ed7d1e40" translate="yes" xml:space="preserve">
          <source>threads.xs</source>
          <target state="translated">threads.xs</target>
        </trans-unit>
        <trans-unit id="2faa69fbc196ece0d11da3fece8bb8cb4878a304" translate="yes" xml:space="preserve">
          <source>threads::shared</source>
          <target state="translated">threads::shared</target>
        </trans-unit>
        <trans-unit id="09e213c9ca6e90ca64b57886a4b8e0006db860c7" translate="yes" xml:space="preserve">
          <source>threads::shared - Perl extension for sharing data structures between threads</source>
          <target state="translated">threads::shared-用于线程间共享数据结构的Perl扩展。</target>
        </trans-unit>
        <trans-unit id="a8527497cd0587a8b9759bc72fbec2309abe6a87" translate="yes" xml:space="preserve">
          <source>threads::shared is released under the same license as Perl.</source>
          <target state="translated">threads::shared是在与Perl相同的许可证下发布的。</target>
        </trans-unit>
        <trans-unit id="ee06316257bae7813945d7b7cd55387706b32fcf" translate="yes" xml:space="preserve">
          <source>three-argument</source>
          <target state="translated">three-argument</target>
        </trans-unit>
        <trans-unit id="48f476deb04384be740b2036dcbe7970821de566" translate="yes" xml:space="preserve">
          <source>through a microscope. (Also known as &lt;b&gt;static scoping&lt;/b&gt;, because dictionaries don&amp;rsquo;t change very fast.) Similarly, looking at variables stored in a private dictionary (namespace) for each scope, which are visible only from their point of declaration down to the end of the lexical scope in which they are declared. &amp;mdash;Syn. &lt;b&gt;static scoping&lt;/b&gt;. &amp;mdash;Ant. &lt;b&gt;dynamic scoping&lt;/b&gt;.</source>
          <target state="translated">通过显微镜。（也称为&lt;b&gt;静态作用域&lt;/b&gt;，因为字典的变化不会很快。）类似地，查看每个范围存储在私有字典（名称空间）中的变量，这些变量仅从声明点到词法末尾才可见。声明它们的范围。&amp;mdash;Syn。&lt;b&gt;静态作用域&lt;/b&gt;。-蚂蚁。&lt;b&gt;动态范围&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="7d093729d13d411c553442c16ac6b1f0df0bcc0c" translate="yes" xml:space="preserve">
          <source>tical</source>
          <target state="translated">tical</target>
        </trans-unit>
        <trans-unit id="d2aac84308e80b4fb63b151dc37c7c4a2e32fe22" translate="yes" xml:space="preserve">
          <source>tie</source>
          <target state="translated">tie</target>
        </trans-unit>
        <trans-unit id="b4e33c910b4e7eb71286c936a6c361332078399f" translate="yes" xml:space="preserve">
          <source>tie VARIABLE,CLASSNAME,LIST</source>
          <target state="translated">领带 VARIABLE,CLASSNAME,LIST.</target>
        </trans-unit>
        <trans-unit id="e4928b42c73f84e34a4cbffbf2834087ad0cee19" translate="yes" xml:space="preserve">
          <source>tied</source>
          <target state="translated">tied</target>
        </trans-unit>
        <trans-unit id="df86b3e8a462b28b236db851a750887038103f20" translate="yes" xml:space="preserve">
          <source>tied VARIABLE</source>
          <target state="translated">平局变量</target>
        </trans-unit>
        <trans-unit id="714eea0f4c980736bde0065fe73f573487f08e3a" translate="yes" xml:space="preserve">
          <source>time</source>
          <target state="translated">time</target>
        </trans-unit>
        <trans-unit id="09ac2572253aca925ef88ce7e1e28523c07089a9" translate="yes" xml:space="preserve">
          <source>time it extracts a</source>
          <target state="translated">萃取时间</target>
        </trans-unit>
        <trans-unit id="07286d112af431ae059ec72f379797b0649ee105" translate="yes" xml:space="preserve">
          <source>time.h</source>
          <target state="translated">time.h</target>
        </trans-unit>
        <trans-unit id="0fa9094ae420cc07dd72cc2146bd0ac470eb7764" translate="yes" xml:space="preserve">
          <source>time_size.U</source>
          <target state="translated">time_size.U</target>
        </trans-unit>
        <trans-unit id="f5cce0aae7b188c70da27428d158685b039f43e7" translate="yes" xml:space="preserve">
          <source>timeit - run a chunk of code and see how long it goes</source>
          <target state="translated">timeit-运行一大段代码,看它能运行多长时间</target>
        </trans-unit>
        <trans-unit id="954670b8c73f5c7bb2168e45afdf2a0fb1c32f04" translate="yes" xml:space="preserve">
          <source>timelocal() and timegm()</source>
          <target state="translated">timelocal()和timegm()</target>
        </trans-unit>
        <trans-unit id="5dd09c96f8b5aa673fdf3f282372ee443a332317" translate="yes" xml:space="preserve">
          <source>timelocal_nocheck() and timegm_nocheck()</source>
          <target state="translated">timelocal_nocheck()和timegm_nocheck()</target>
        </trans-unit>
        <trans-unit id="7196b5875f713c826bd279dbda843c897e2a60c2" translate="yes" xml:space="preserve">
          <source>times</source>
          <target state="translated">times</target>
        </trans-unit>
        <trans-unit id="be23d236f3757f152a1f24f600012c1e1d600a93" translate="yes" xml:space="preserve">
          <source>times). Any attempt to sleep for X seconds will most probably end up sleeping &lt;b&gt;more&lt;/b&gt; than that, but don't be surprised if you end up sleeping slightly &lt;b&gt;less&lt;/b&gt;.</source>
          <target state="translated">次）。任何企图睡眠X秒将最有可能最终睡觉&lt;b&gt;更&lt;/b&gt;重要的是，但是如果你最终小幅睡觉时不要感到惊讶&lt;b&gt;少&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="3019ee89018972ae13827b09b3ebf41868413d56" translate="yes" xml:space="preserve">
          <source>timethese - run several chunks of code several times</source>
          <target state="translated">timethese-多次运行多个代码块。</target>
        </trans-unit>
        <trans-unit id="926b35fe102bbad8d28cfd9994879a682f7cc677" translate="yes" xml:space="preserve">
          <source>timethis - run a chunk of code several times</source>
          <target state="translated">timethis-多次运行一个代码块</target>
        </trans-unit>
        <trans-unit id="3c6de1b7dd91465d437ef415f94f36afc1fbc8a8" translate="yes" xml:space="preserve">
          <source>title</source>
          <target state="translated">title</target>
        </trans-unit>
        <trans-unit id="79f74fe9e99b6f6214a6214ba235a7cd2a04e0fd" translate="yes" xml:space="preserve">
          <source>title_postfix</source>
          <target state="translated">title_postfix</target>
        </trans-unit>
        <trans-unit id="667355ec302a4f025bcf6e8ed2687c08bee45df9" translate="yes" xml:space="preserve">
          <source>title_prefix</source>
          <target state="translated">title_prefix</target>
        </trans-unit>
        <trans-unit id="7d41631407b52413c97b7d1100dc6276733f6fbb" translate="yes" xml:space="preserve">
          <source>title_prefix, title_postfix</source>
          <target state="translated">标题_前缀,标题_后缀。</target>
        </trans-unit>
        <trans-unit id="11a6a2b3d697cfef5e657a3e04cbf393218a9c74" translate="yes" xml:space="preserve">
          <source>tkpod</source>
          <target state="translated">tkpod</target>
        </trans-unit>
        <trans-unit id="d515a572ec8566ae3c51d8bbe24ee44fc7ce67ea" translate="yes" xml:space="preserve">
          <source>tmon.out</source>
          <target state="translated">tmon.out</target>
        </trans-unit>
        <trans-unit id="7856988903cb6f9b1e8c44315fcc780abf2cd6b2" translate="yes" xml:space="preserve">
          <source>tmpfile</source>
          <target state="translated">tmpfile</target>
        </trans-unit>
        <trans-unit id="efa1858ae39d33be07d0ea70cf91a0217532af0d" translate="yes" xml:space="preserve">
          <source>tmpfile=/tmp/bison.$$.y echo %pure_parser &amp;gt; $tmpfile cat $1&amp;gt;&amp;gt; $tmpfile</source>
          <target state="translated">tmpfile = / tmp / bison。$$。y echo％pure_parser&amp;gt; $ tmpfile cat $ 1 &amp;gt;&amp;gt; $ tmpfile</target>
        </trans-unit>
        <trans-unit id="f67b82204486a97f18d5668c8a238d5eb98d90cc" translate="yes" xml:space="preserve">
          <source>tmptype</source>
          <target state="translated">tmptype</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="185a97a9a27d738e3e05a1447711e0289b354cc0" translate="yes" xml:space="preserve">
          <source>to 0 if &lt;code&gt;SvOOK(sv)&lt;/code&gt; is false.</source>
          <target state="translated">如果 &lt;code&gt;SvOOK(sv)&lt;/code&gt; 为false，则为 0 。</target>
        </trans-unit>
        <trans-unit id="a7a8440a5b466b35a00b7232359b592f1e66aaab" translate="yes" xml:space="preserve">
          <source>to 0 when it calls your function - the parameter is provided to allow your implementation to track depth if it needs to recurse.</source>
          <target state="translated">为0,当它调用你的函数时--提供这个参数是为了让你的实现在需要递归时跟踪深度。</target>
        </trans-unit>
        <trans-unit id="ea2a29e8310cf767872af505eeae2dea9e6cd141" translate="yes" xml:space="preserve">
          <source>to &lt;code&gt;LIBPATH&lt;/code&gt; (here for Perl DLL</source>
          <target state="translated">到 &lt;code&gt;LIBPATH&lt;/code&gt; （此处为Perl DLL）</target>
        </trans-unit>
        <trans-unit id="267663db9589a3745d5aef238877fd9533c61f70" translate="yes" xml:space="preserve">
          <source>to &lt;code&gt;Moose&lt;/code&gt; , meaning you can switch from &lt;code&gt;Moo&lt;/code&gt; to &lt;code&gt;Moose&lt;/code&gt; quite easily.</source>
          <target state="translated">到 &lt;code&gt;Moose&lt;/code&gt; ，这意味着您可以轻松地从 &lt;code&gt;Moo&lt;/code&gt; 切换到 &lt;code&gt;Moose&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25de92114260dd84a38a4dd129b16fa441223f76" translate="yes" xml:space="preserve">
          <source>to &lt;code&gt;hv_common()&lt;/code&gt; .</source>
          <target state="translated">到 &lt;code&gt;hv_common()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d86da4acbcdf14e86c5caa9f3ed9dcbc5be77df" translate="yes" xml:space="preserve">
          <source>to EXPR1 only (which might itself be a higher-precedence AND operator, for example, and thus subject to the previous rule), not to EXPR2. If EXPR1 is to use smartmatching, then EXPR2 also does so, no matter what EXPR2 contains. But if EXPR2 does not get to use smartmatching, then the second argument will not be either. This is quite different from the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; case just described, so be careful.</source>
          <target state="translated">仅适用于EXPR1（例如，本身可能是优先级较高的AND运算符，因此要遵守先前的规则），而不适用于EXPR2。如果EXPR1要使用智能匹配，则EXPR2也会这样做，无论EXPR2包含什么内容。但是，如果EXPR2没有使用smartmatching，则第二个参数也不是。这与刚才描述的 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 情况完全不同，因此请小心。</target>
        </trans-unit>
        <trans-unit id="6154e47cbb357e834cd236e827be6a1934f7b9d2" translate="yes" xml:space="preserve">
          <source>to Encode canonical encoding name.</source>
          <target state="translated">Encode canonical encoding name。</target>
        </trans-unit>
        <trans-unit id="ddbb5ed60cafc5157e96fb7243d2b67c73cd14b3" translate="yes" xml:space="preserve">
          <source>to GetOptions(). For each option that is specified on the command line, the option value will be stored in the hash with the option name as key. Options that are not actually used on the command line will not be put in the hash, on other words, &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists($h{option})&lt;/a&gt;&lt;/code&gt; (or defined()) can be used to test if an option was used. The drawback is that warnings will be issued if the program runs under &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and uses &lt;code&gt;$h{option}&lt;/code&gt; without testing with exists() or defined() first.</source>
          <target state="translated">到GetOptions（）。对于在命令行上指定的每个选项，选项值将以选项名称作为键存储在哈希中。命令行上未实际使用的选项将不会放入哈希中，换句话说， &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists($h{option})&lt;/a&gt;&lt;/code&gt; （或define（））可用于测试是否使用了选项。缺点是，如果程序在 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 条件下运行并且使用 &lt;code&gt;$h{option}&lt;/code&gt; 而不先对exist（）或define（）进行测试，则会发出警告。</target>
        </trans-unit>
        <trans-unit id="bfed2d9357f25a5be1ef229590525d9382ab9044" translate="yes" xml:space="preserve">
          <source>to POSITION; &lt;code&gt;1&lt;/code&gt; to set it to the current position plus POSITION; and &lt;code&gt;2&lt;/code&gt; to set it to EOF plus POSITION, typically negative. For WHENCE you may use the constants &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , and &lt;code&gt;SEEK_END&lt;/code&gt; (start of the file, current position, end of the file) from the &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; module. Returns &lt;code&gt;1&lt;/code&gt; on success, false otherwise.</source>
          <target state="translated">到位置； &lt;code&gt;1&lt;/code&gt; 将其设置为当前位置加上POSITION；和 &lt;code&gt;2&lt;/code&gt; 将其设置为EOF加POSITION，通常为负数。对于WHENCE您可以使用常量 &lt;code&gt;SEEK_SET&lt;/code&gt; ， &lt;code&gt;SEEK_CUR&lt;/code&gt; 和 &lt;code&gt;SEEK_END&lt;/code&gt; （启动文件，当前位置，文件月底）从&lt;a href=&quot;../fcntl&quot;&gt;FCNTL&lt;/a&gt;模块。成功返回 &lt;code&gt;1&lt;/code&gt; ，否则返回false。</target>
        </trans-unit>
        <trans-unit id="defce8e2effd8a4c5cb2f53c0955b6344cd557d2" translate="yes" xml:space="preserve">
          <source>to POSITION; &lt;code&gt;1&lt;/code&gt; to set it to the current position plus POSITION; and &lt;code&gt;2&lt;/code&gt; to set it to EOF plus POSITION, typically negative. For WHENCE you may use the constants &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , and &lt;code&gt;SEEK_END&lt;/code&gt; (start of the file, current position, end of the file) from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module. Returns &lt;code&gt;1&lt;/code&gt; on success, false otherwise.</source>
          <target state="translated">到位置； &lt;code&gt;1&lt;/code&gt; 将其设置为当前位置加上POSITION；和 &lt;code&gt;2&lt;/code&gt; 将其设置为EOF加POSITION，通常为负数。对于WHENCE您可以使用常量 &lt;code&gt;SEEK_SET&lt;/code&gt; ， &lt;code&gt;SEEK_CUR&lt;/code&gt; 和 &lt;code&gt;SEEK_END&lt;/code&gt; （启动文件，当前位置，文件月底）从&lt;a href=&quot;fcntl&quot;&gt;FCNTL&lt;/a&gt;模块。成功返回 &lt;code&gt;1&lt;/code&gt; ，否则返回false。</target>
        </trans-unit>
        <trans-unit id="75b325578f050782c8fcb428bd57b6b901bcfa73" translate="yes" xml:space="preserve">
          <source>to ThisProject/I18N/en.pm, because if _AUTO is true there, then just looking for an entry with the key &quot;Couldn't find file \&quot;[_1]\&quot;!\n&quot; in that lexicon will cause it to be added, with that value!</source>
          <target state="translated">到ThisProject/I18N/en.pm,因为如果那里的_AUTO为真,那么只要在该词库中寻找一个带有 &quot;Couldn't find file \&quot;[_1]\&quot;!\n &quot;的条目,就会导致它被添加,并带有该值!</target>
        </trans-unit>
        <trans-unit id="e87b45ec9b1a049ec58cd24d01f2b883881dc6b1" translate="yes" xml:space="preserve">
          <source>to a fixed number of given keys. Methods for creating and dealing with restricted hashes are exported by the &lt;a href=&quot;hash/util&quot;&gt;Hash::Util&lt;/a&gt; module.</source>
          <target state="translated">固定数量的给定密钥。&lt;a href=&quot;hash/util&quot;&gt;Hash :: Util&lt;/a&gt;模块导出用于创建和处理受限哈希的方法。</target>
        </trans-unit>
        <trans-unit id="4e4a587937f5eb29db9d3748369255d25b711ed0" translate="yes" xml:space="preserve">
          <source>to a location on your LIBPATH.</source>
          <target state="translated">到你的LIBPATH上的一个位置。</target>
        </trans-unit>
        <trans-unit id="18bb49c1ef9ac587c558bd725670f0c267932208" translate="yes" xml:space="preserve">
          <source>to a location on your PATH,</source>
          <target state="translated">到你的PATH上的一个位置。</target>
        </trans-unit>
        <trans-unit id="2b3bd4b5b703698e2ad6b1562ddbab4a68189abf" translate="yes" xml:space="preserve">
          <source>to a location on your PATH.</source>
          <target state="translated">到你的PATH上的一个位置。</target>
        </trans-unit>
        <trans-unit id="939b8956446b9c496d5bc76687ea6d90606d1987" translate="yes" xml:space="preserve">
          <source>to a named subroutine, e.g. a counter that gets initialized at creation time of the sub and can only be modified from within the sub. This is sometimes used with a BEGIN block in package files to make sure a variable doesn't get meddled with during the lifetime of the package:</source>
          <target state="translated">到一个命名的子程序,例如一个计数器在子程序创建时被初始化,并且只能在子程序中修改。这有时与包文件中的BEGIN块一起使用,以确保一个变量在包的生命周期内不会被干扰。</target>
        </trans-unit>
        <trans-unit id="8b7626ae679ea958fb7e5cdec6a9ba3c92474dbf" translate="yes" xml:space="preserve">
          <source>to a pipe, you should also trap SIGPIPE. Otherwise, think of what happens when you start up a pipe to a command that doesn't exist: the open() will in all likelihood succeed (it only reflects the fork()'s success), but then your output will fail--spectacularly. Perl can't know whether the command worked, because your command is actually running in a separate process whose exec() might have failed. Therefore, while readers of bogus commands return just a quick EOF, writers to bogus commands will get hit with a signal, which they'd best be prepared to handle. Consider:</source>
          <target state="translated">到一个管道,你也应该捕获SIGPIPE。否则,想想当你为一个不存在的命令启动管道时会发生什么:open()很可能会成功 (它只反映了fork()的成功),但是你的输出会失败--很明显。Perl无法知道命令是否成功,因为你的命令实际上是在一个单独的进程中运行,而这个进程的exec()可能已经失败了。因此,虽然假命令的读取者只返回一个快速的 EOF,但假命令的写入者会收到一个信号,他们最好做好处理的准备。考虑一下</target>
        </trans-unit>
        <trans-unit id="b23d84faa8fd585b1ad0710623852a699603f544" translate="yes" xml:space="preserve">
          <source>to a test program the intermediate directories used by &lt;code&gt;make&lt;/code&gt; are added to @INC.</source>
          <target state="translated">在测试程序中， &lt;code&gt;make&lt;/code&gt; 使用的中间目录将添加到@INC。</target>
        </trans-unit>
        <trans-unit id="526cecdce9a6fa0844944fe2657ec40470921035" translate="yes" xml:space="preserve">
          <source>to access documentation for different components of Perl. Start with</source>
          <target state="translated">来访问Perl不同组件的文档。从</target>
        </trans-unit>
        <trans-unit id="a2ba8c1859afb35af5e779dbe13b3f995b3be717" translate="yes" xml:space="preserve">
          <source>to access the perl documentation in the text form (note that you may get better results using perl manpages).</source>
          <target state="translated">以文本形式访问 perl 文档 (注意,使用 perl manpages 可能会得到更好的结果)。</target>
        </trans-unit>
        <trans-unit id="35a2c51838834c5c5405f168c5893280ce6cc0fe" translate="yes" xml:space="preserve">
          <source>to access these files.</source>
          <target state="translated">来访问这些文件。</target>
        </trans-unit>
        <trans-unit id="a373051c463e8242de6c723e14201a15eb5f2163" translate="yes" xml:space="preserve">
          <source>to accommodate Unix conventions used in some ported software.</source>
          <target state="translated">以适应一些移植软件中使用的 Unix 惯例。</target>
        </trans-unit>
        <trans-unit id="190b00af4099b5490f23b24ef3dc8e2fe342b61b" translate="yes" xml:space="preserve">
          <source>to accomplish this, but full details are in &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8 in perllocale&lt;/a&gt;, including gotchas that happen if you don't specify &lt;code&gt;:not_characters&lt;/code&gt; .</source>
          <target state="translated">要做到这一点，但完整细节&lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;在perllocale&lt;/a&gt;中的Unicode和UTF-8中，包括如果不指定 &lt;code&gt;:not_characters&lt;/code&gt; 就会发生的陷阱。</target>
        </trans-unit>
        <trans-unit id="a73a7bc7d432310b47d7dadb7338f6296927937c" translate="yes" xml:space="preserve">
          <source>to add your own encoding to perl. No knowledge of XS is necessary.</source>
          <target state="translated">来添加自己的编码到perl中。不需要XS的知识。</target>
        </trans-unit>
        <trans-unit id="b89fc290c98c21f78eb1c3d3de205c05b005a94d" translate="yes" xml:space="preserve">
          <source>to allocate memory for a Perl interpreter. It's quite a simple function, and the guts of it looks like this:</source>
          <target state="translated">来为Perl解释器分配内存。这是一个非常简单的函数,它的内涵是这样的。</target>
        </trans-unit>
        <trans-unit id="5df238e4f59f47ed3e559a86abb5276789fd76b7" translate="yes" xml:space="preserve">
          <source>to and</source>
          <target state="translated">向和</target>
        </trans-unit>
        <trans-unit id="39a68d5c47c1ad6ff50ff1f20660276dfbe7b579" translate="yes" xml:space="preserve">
          <source>to any operators already permitted).</source>
          <target state="translated">对任何已获准的运营商)。)</target>
        </trans-unit>
        <trans-unit id="3a7e4483f93948ccc15b247fcdc95d124ee3e0d4" translate="yes" xml:space="preserve">
          <source>to be</source>
          <target state="translated">将要</target>
        </trans-unit>
        <trans-unit id="e893999fc61c9f9942e8865609ed6dc8816fc20e" translate="yes" xml:space="preserve">
          <source>to be able to use these macros:</source>
          <target state="translated">才能使用这些宏。</target>
        </trans-unit>
        <trans-unit id="cf5d8c9c97a4054f2de2d35e98379bb8f2987a69" translate="yes" xml:space="preserve">
          <source>to be an @AoA, but rather just a reference to it, you could do something more like this:</source>
          <target state="translated">为了成为一个@AoA,而只是一个参考,你可以做一些更像这样的事情。</target>
        </trans-unit>
        <trans-unit id="019a46c6c83d83e2e7dd74db5f7d357036618f87" translate="yes" xml:space="preserve">
          <source>to be appended to the stream. The</source>
          <target state="translated">要附加到流中。的</target>
        </trans-unit>
        <trans-unit id="138b1321ccfe075171a68061e5a1117b091492e4" translate="yes" xml:space="preserve">
          <source>to be considered as the location of an error. The &lt;code&gt;carp()&lt;/code&gt; and &lt;code&gt;cluck()&lt;/code&gt; functions will skip over callers when reporting where an error occurred.</source>
          <target state="translated">被视为错误的位置。报告错误发生位置时， &lt;code&gt;carp()&lt;/code&gt; 和 &lt;code&gt;cluck()&lt;/code&gt; 函数将跳过调用方。</target>
        </trans-unit>
        <trans-unit id="3d8894d272d9670db059eb36fa388b92f6748964" translate="yes" xml:space="preserve">
          <source>to be created. The</source>
          <target state="translated">要建立。该。</target>
        </trans-unit>
        <trans-unit id="84fb3256daf84c2b7c36def5c86135fead88552e" translate="yes" xml:space="preserve">
          <source>to be fed. (Since you see _1 and a _2 being used in the key there.)</source>
          <target state="translated">来喂养。(因为你看到_1和一个_2被用在那里的关键。)</target>
        </trans-unit>
        <trans-unit id="98524352b3e61275f42e3fc522841353e48b08c2" translate="yes" xml:space="preserve">
          <source>to be in effect when perl</source>
          <target state="translated">的时候生效。</target>
        </trans-unit>
        <trans-unit id="76f8048f660e2d2cd4ca7c267d990f0c9732b9fb" translate="yes" xml:space="preserve">
          <source>to be less precisely specified. Details are in &lt;a href=&quot;#LOOSE-MATCHES&quot;&gt;LOOSE MATCHES&lt;/a&gt;.</source>
          <target state="translated">不那么精确地指定。详细信息在&lt;a href=&quot;#LOOSE-MATCHES&quot;&gt;LOOSE MATCHES中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a25cde4d1302e9dba53eb4907caba9ff77c35bd" translate="yes" xml:space="preserve">
          <source>to be null. This function is also thread safe on the small scale. It uses appropriate locking to avoid race conditions in accessing &lt;a href=&quot;#PL_check&quot;&gt;PL_check&lt;/a&gt;.</source>
          <target state="translated">为空。此功能在小范围内也是线程安全的。它使用适当的锁定来避免在访问&lt;a href=&quot;#PL_check&quot;&gt;PL_check时出现&lt;/a&gt;争用情况。</target>
        </trans-unit>
        <trans-unit id="3d0279bbb98c4fed8cbeea6e8338eb32180ee838" translate="yes" xml:space="preserve">
          <source>to be symlinks to the actual binary. If that can't be done, system administrators are strongly encouraged to put (symlinks to) perl and its accompanying utilities into a directory typically found along a user's PATH, or in some other obvious and convenient place.</source>
          <target state="translated">是指向实际二进制文件的符号链接。如果做不到这一点,我们强烈建议系统管理员将 perl 和它所附带的实用程序(符号链接)放到用户的 PATH 目录中,或者其他一些明显而方便的地方。</target>
        </trans-unit>
        <trans-unit id="c1312f43c3145ddd16b2a7f06695a0db02e8b75a" translate="yes" xml:space="preserve">
          <source>to be used to determine if a constant is to be defined.</source>
          <target state="translated">用来确定是否要定义一个常数。</target>
        </trans-unit>
        <trans-unit id="6dfaa48eefc09804912e9e020597db19ee8f8e41" translate="yes" xml:space="preserve">
          <source>to be written out later. Data in the deferred write buffer is also charged against the memory limit you set with the &lt;code&gt;memory&lt;/code&gt; option.</source>
          <target state="translated">待以后写出来。延迟写入缓冲区中的数据也将按照您使用 &lt;code&gt;memory&lt;/code&gt; 选项设置的内存限制收费。</target>
        </trans-unit>
        <trans-unit id="f6eae6f36fad068d13506b3de1e258315a973b7f" translate="yes" xml:space="preserve">
          <source>to become the heir to MakeMaker. MakeMaker's maintainers have long said that it is a dead end and should be kept functioning, but not extended with new features. It's complicated enough as it is!</source>
          <target state="translated">以成为MakeMaker的继承者。MakeMaker的维护者早就说过,它是个死胡同,应该保持功能,但不能扩展新功能。它已经够复杂的了!</target>
        </trans-unit>
        <trans-unit id="e42231196dcb18697b456290fa711408575dbc64" translate="yes" xml:space="preserve">
          <source>to both EXPR1 and EXPR2. Only if</source>
          <target state="translated">到EXPR1和EXPR2。只有当</target>
        </trans-unit>
        <trans-unit id="924eea1cd1b5f3404a8c17a7ccb24dd497472a1c" translate="yes" xml:space="preserve">
          <source>to build perl with support for 64-bit integers (&lt;code&gt;use64bitint&lt;/code&gt; ) or both 64-bit integers and 64-bit addressing (&lt;code&gt;use64bitall&lt;/code&gt; ). In the latter case, the resulting binary will run only on G5-based hosts.</source>
          <target state="translated">构建支持64位整数（ &lt;code&gt;use64bitint&lt;/code&gt; ）或64位整数和64位寻址（ &lt;code&gt;use64bitall&lt;/code&gt; ）的perl。在后一种情况下，生成的二进制文件将仅在基于G5的主机上运行。</target>
        </trans-unit>
        <trans-unit id="c2960ffda3ff18124ff7f6c2b946df0ddafabbc1" translate="yes" xml:space="preserve">
          <source>to calculate checksums. For the Perl interface, the order of the two parameters in both functions has been reversed. This allows both running checksums and one off calculations to be done.</source>
          <target state="translated">来计算校验和。在Perl接口中,两个函数中的两个参数的顺序被颠倒了。这使得运行中的校验和和一次性计算都可以进行。</target>
        </trans-unit>
        <trans-unit id="216f4d2f0bbcf6e74daa148b9f8a286adfde05e3" translate="yes" xml:space="preserve">
          <source>to change if the message change in some way. Another property is that digest functions are one-way functions, that is it should be</source>
          <target state="translated">如果消息发生了某种变化,它就会改变。另一个特性是,摘要函数是单向函数,即它应该是</target>
        </trans-unit>
        <trans-unit id="103883c712727958c6de7ae9820b677419a7e766" translate="yes" xml:space="preserve">
          <source>to check for DCL procedure. If this fails, checks directories in DCL$PATH and finally</source>
          <target state="translated">来检查DCL过程。如果失败,检查DCL$PATH中的目录,最后检查</target>
        </trans-unit>
        <trans-unit id="731aa951e967b4db2f011ced9dc08b9a36920510" translate="yes" xml:space="preserve">
          <source>to command pipes is to use &lt;code&gt;&quot;|-&quot;&lt;/code&gt; in place of &lt;code&gt;&quot;-|&quot;&lt;/code&gt; .</source>
          <target state="translated">命令管道使用 &lt;code&gt;&quot;|-&quot;&lt;/code&gt; 代替 &lt;code&gt;&quot;-|&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33a43350f70aed99b64d60955734bbec9e9f87af" translate="yes" xml:space="preserve">
          <source>to compile Perl 32-bit. Don't bother with -n32 unless you have 7.1 or later compilers (use cc -version to check).</source>
          <target state="translated">来编译 32 位的 Perl。除非你有 7.1 或更高版本的编译器,否则不要使用 -n32(使用 cc -version 来检查)。</target>
        </trans-unit>
        <trans-unit id="743d2eefcb5e3c10bbc64054994c2c15486d8e77" translate="yes" xml:space="preserve">
          <source>to convert perl utilities to</source>
          <target state="translated">将perl实用程序转换为</target>
        </trans-unit>
        <trans-unit id="7b210708522f858c74dc655b94df0449b71778b2" translate="yes" xml:space="preserve">
          <source>to create a &lt;code&gt;float&lt;/code&gt; , and</source>
          <target state="translated">创建一个 &lt;code&gt;float&lt;/code&gt; ，并且</target>
        </trans-unit>
        <trans-unit id="cf2348a6ec6eaf3d48ed051b15a33749f439c666" translate="yes" xml:space="preserve">
          <source>to create a string:</source>
          <target state="translated">来创建一个字符串。</target>
        </trans-unit>
        <trans-unit id="1c8c7bdde3e8f34c6791da2b20254e6dd797fa43" translate="yes" xml:space="preserve">
          <source>to create an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">创建一个 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="6abff830d9aee9d0e01d8789752ed03356a1172e" translate="yes" xml:space="preserve">
          <source>to create an object with &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt; {Name =&amp;gt; ...}, $class&lt;/code&gt; , and call define_encoding. They inherit their &lt;code&gt;name&lt;/code&gt; method from &lt;code&gt;Encode::Encoding&lt;/code&gt; .</source>
          <target state="translated">用 &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt; {Name =&amp;gt; ...}, $class&lt;/code&gt; 创建对象，然后调用define_encoding。他们从 &lt;code&gt;Encode::Encoding&lt;/code&gt; 继承其 &lt;code&gt;name&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="13fb3853d5ec1540d5748eb0dd803110ae60da5e" translate="yes" xml:space="preserve">
          <source>to define a &lt;code&gt;run&lt;/code&gt; method. If you're writing a Pod-formatter class, you should define a &lt;code&gt;run&lt;/code&gt; just so that users can call &lt;code&gt;parse_file&lt;/code&gt; etc, but you don't</source>
          <target state="translated">定义 &lt;code&gt;run&lt;/code&gt; 方法。如果要编写Pod格式程序类，则应定义 &lt;code&gt;run&lt;/code&gt; ，以便用户可以调用 &lt;code&gt;parse_file&lt;/code&gt; 等，但不要</target>
        </trans-unit>
        <trans-unit id="a5a63182de86c8a3e6163d98d58dd2623e455299" translate="yes" xml:space="preserve">
          <source>to denote a capturing group of the form &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(?PARNO)&lt;/a&gt;, but omitted the &lt;code&gt;&quot;)&quot;&lt;/code&gt; .</source>
          <target state="translated">表示形式为&lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;（？PARNO）&lt;/a&gt;的捕获组，但省略了 &lt;code&gt;&quot;)&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95c7af9d6ca4741280ae12ff21ab09e9cdf25647" translate="yes" xml:space="preserve">
          <source>to display it; if</source>
          <target state="translated">来显示它;如果</target>
        </trans-unit>
        <trans-unit id="e3e5845a22ed917abc0126267df7df44ea895291" translate="yes" xml:space="preserve">
          <source>to display the path to the module. In some cases (for example, the &lt;code&gt;AutoLoader&lt;/code&gt; module), this command will show the path to a separate &lt;code&gt;pod&lt;/code&gt; file; the module itself should be in the same directory, with a 'pm' file extension.</source>
          <target state="translated">显示模块的路径。在某些情况下（例如， &lt;code&gt;AutoLoader&lt;/code&gt; 模块），此命令将显示单独的 &lt;code&gt;pod&lt;/code&gt; 文件的路径。该模块本身应位于同一目录中，文件扩展名为&amp;ldquo; pm&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="876e43e0908079d66a492e080439c57dff35438a" translate="yes" xml:space="preserve">
          <source>to do so. And</source>
          <target state="translated">以此。还有</target>
        </trans-unit>
        <trans-unit id="b947a7d83a90fd93960468bbd8002c295475ab0c" translate="yes" xml:space="preserve">
          <source>to enable an experimental switch feature. This is loosely based on an old version of a Perl 6 proposal, but it no longer resembles the Perl 6 construct. You also get the switch feature whenever you declare that your code prefers to run under a version of Perl that is 5.10 or later. For example:</source>
          <target state="translated">来实现一个实验性的切换功能。这大致是基于 Perl 6 建议的一个旧版本,但它不再像 Perl 6 的结构。每当你声明你的代码更喜欢在 5.10 或更高版本的 Perl 下运行时,你也会得到 switch 功能。例如</target>
        </trans-unit>
        <trans-unit id="82473b502decf667eb5cf57e3f13cb772ed8ed58" translate="yes" xml:space="preserve">
          <source>to enable you to see what locales there are on the current platform.</source>
          <target state="translated">以使您能够看到当前平台上有哪些区域。</target>
        </trans-unit>
        <trans-unit id="1f092c62aa2cf37ff8e36cf49d58d75de683036e" translate="yes" xml:space="preserve">
          <source>to execute, rather than the one it has just executed.</source>
          <target state="translated">要执行的,而不是刚刚执行的。</target>
        </trans-unit>
        <trans-unit id="524e0ea0502df43dfa1f4421c6984ecb109dc7fd" translate="yes" xml:space="preserve">
          <source>to extract an ASCII tar archive on OS/390, try this:</source>
          <target state="translated">要在OS/390上解压一个ASCII压缩包,可以试试这个。</target>
        </trans-unit>
        <trans-unit id="c7f1cc49694bdea53f292e349a4d22a16060be85" translate="yes" xml:space="preserve">
          <source>to extract the data itself, you'll need a dereference: $$s1</source>
          <target state="translated">为了提取数据本身,你需要一个派生引用:$$s1</target>
        </trans-unit>
        <trans-unit id="4d5ac57125dea2095aaaa7c0c7b7f13d75e8dcb7" translate="yes" xml:space="preserve">
          <source>to fetch or store the record at line &lt;code&gt;$n&lt;/code&gt; , respectively; similarly the other tied array methods. (See &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; for details.) You may also call the following methods on this object:</source>
          <target state="translated">分别在 &lt;code&gt;$n&lt;/code&gt; 行获取或存储记录；类似的其他绑定数组方法。（有关详细信息，请参见&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;。）您还可以在此对象上调用以下方法：</target>
        </trans-unit>
        <trans-unit id="c2fa42d27aad6d50b2bc31ff51bcae0729ca7103" translate="yes" xml:space="preserve">
          <source>to find a message that correspond to some given digest. Algorithms differ in how &quot;likely&quot; and how &quot;hard&quot;, as well as how efficient they are to compute.</source>
          <target state="translated">来寻找与某个给定摘要对应的信息。算法在 &quot;可能性 &quot;和 &quot;难度 &quot;以及计算效率上都有所不同。</target>
        </trans-unit>
        <trans-unit id="3e21a74ff876d5884a9cd3e42c0a803a127bfc89" translate="yes" xml:space="preserve">
          <source>to find out more about how to use it.</source>
          <target state="translated">以了解更多关于如何使用它。</target>
        </trans-unit>
        <trans-unit id="8087a685db9dd787b7e7ce5d9406c7b5f62f7733" translate="yes" xml:space="preserve">
          <source>to find suspiciously skipped tests, and other fishy events.</source>
          <target state="translated">以发现可疑的跳考等蹊跷事件。</target>
        </trans-unit>
        <trans-unit id="c3817e3dfa074e1068e390eca87ad8f05b3f5748" translate="yes" xml:space="preserve">
          <source>to get Perl to work well with them. The catch is that you have to translate from the locale character set to/from Unicode yourself. See &lt;a href=&quot;#Unicode-I%2fO&quot;&gt;Unicode I/O&lt;/a&gt; above for how to</source>
          <target state="translated">使Perl与他们合作良好。问题是您必须自己将语言环境字符集转换为Unicode。有关如何操作，请参见上面的&lt;a href=&quot;#Unicode-I%2fO&quot;&gt;Unicode I / O。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ac0a825f6340f8ac1be51fe954ab53df2d302874" translate="yes" xml:space="preserve">
          <source>to get Unicode rules, as the &lt;code&gt;\L&lt;/code&gt; in the former (but not necessarily the latter) would also use Unicode rules.</source>
          <target state="translated">获取Unicode规则，因为前者中的 &lt;code&gt;\L&lt;/code&gt; （但不一定是后者）也将使用Unicode规则。</target>
        </trans-unit>
        <trans-unit id="cdb6284e25e399322757d97afb2ac2e493d2f13d" translate="yes" xml:space="preserve">
          <source>to get a hexadecimal digit, or</source>
          <target state="translated">得到一个十六进制数字,或用</target>
        </trans-unit>
        <trans-unit id="6dff39424d11acaf9846ad1872f40e67f2726554" translate="yes" xml:space="preserve">
          <source>to get a list of anonymous hashes each with only one entry apiece.</source>
          <target state="translated">得到一个匿名哈希列表,每个列表只有一个条目。</target>
        </trans-unit>
        <trans-unit id="df95aa7d96ad35561dea936c7dfdb0c59259e424" translate="yes" xml:space="preserve">
          <source>to get all normal letters of the English alphabet, or</source>
          <target state="translated">以获得所有正常的英文字母,或者是</target>
        </trans-unit>
        <trans-unit id="9453fbce4c219f28d8e1fe0f3939d307058adf72" translate="yes" xml:space="preserve">
          <source>to get both unique invocation</source>
          <target state="translated">以获得两个独特的调用</target>
        </trans-unit>
        <trans-unit id="aa4caba4c31a5fb34a97e1d00d7e9e413e73365c" translate="yes" xml:space="preserve">
          <source>to get dates with leading zeros.</source>
          <target state="translated">获取带前导零的日期。</target>
        </trans-unit>
        <trans-unit id="42b10c1b27c37e1c3b1556a16293d2db17e7beb7" translate="yes" xml:space="preserve">
          <source>to get four files containing &quot;Hello World!\n&quot; in ASCII, CP 0037 EBCDIC, ISO 8859-1 (Latin-1) (in this example identical to ASCII since only ASCII characters were printed), and UTF-EBCDIC (in this example identical to normal EBCDIC since only characters that don't differ between EBCDIC and UTF-EBCDIC were printed). See the documentation of &lt;a href=&quot;encode/perlio&quot;&gt;Encode::PerlIO&lt;/a&gt; for details.</source>
          <target state="translated">获取四个包含ASCII，CP 0037 EBCDIC，ISO 8859-1（Latin-1）（在此示例中与ASCII相同，因为仅打印ASCII字符）和UTF-EBCDIC的文件，其中包含&amp;ldquo; Hello World！\ n&amp;rdquo;示例与普通EBCDIC相同，因为只打印了在EBCDIC和UTF-EBCDIC之间没有区别的字符）。有关详细信息，请参见&lt;a href=&quot;encode/perlio&quot;&gt;Encode :: PerlIO&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="28603ac6b28eec67b3e188373d6a6a06869faeb7" translate="yes" xml:space="preserve">
          <source>to get the correct function definitions. If</source>
          <target state="translated">以获得正确的函数定义。如果</target>
        </trans-unit>
        <trans-unit id="470ba0f2f1c7ef2528debf493d9f58f588db9ebf" translate="yes" xml:space="preserve">
          <source>to get the repaired variant. For backward compatibility with older versions of perl, you can instead decrement the reference count manually when you're returning one of the aforementioned types using &lt;code&gt;sv_2mortal&lt;/code&gt; :</source>
          <target state="translated">获得修复的变体。为了与旧版本的perl向后兼容，当您使用 &lt;code&gt;sv_2mortal&lt;/code&gt; 返回上述类型之一时，可以改为手动减少引用计数：</target>
        </trans-unit>
        <trans-unit id="48d35469aac726018b9cbf58b42ec28989fe44ca" translate="yes" xml:space="preserve">
          <source>to get the value of this into the proper command. You must be prepared to do the</source>
          <target state="translated">来将其值输入到正确的命令中。你必须准备好做</target>
        </trans-unit>
        <trans-unit id="abac24d2e236e321f06c59d2c39149a3827039e7" translate="yes" xml:space="preserve">
          <source>to get two files containing &quot;Hello World!\n&quot; in ASCII, EBCDIC, ISO Latin-1 (in this example identical to ASCII) respective UTF-EBCDIC (in this example identical to normal EBCDIC). See the documentation of Encode::PerlIO for details.</source>
          <target state="translated">得到两个包含 &quot;Hello World!\n &quot;的ASCII、EBCDIC、ISO Latin-1(本例中与ASCII相同)、各自的UTF-EBCDIC(本例中与普通EBCDIC相同)的文件。详情请看Encode::PerlIO的文档。</target>
        </trans-unit>
        <trans-unit id="be7707df760253ac698371ee35058456da264ad3" translate="yes" xml:space="preserve">
          <source>to give the output</source>
          <target state="translated">赋予输出</target>
        </trans-unit>
        <trans-unit id="6234813623d065b30366ac94d161191137eaa4a6" translate="yes" xml:space="preserve">
          <source>to have the same value, namely &lt;code&gt;Larry&lt;/code&gt; . The problem is caused by the way that the associative array interface works. Basically, when the associative array interface is used to fetch the value associated with a given key, it will only ever retrieve the first value.</source>
          <target state="translated">具有相同的值，即 &lt;code&gt;Larry&lt;/code&gt; 。该问题是由关联数组接口的工作方式引起的。基本上，当关联数组接口用于获取与给定键关联的值时，它将仅检索第一个值。</target>
        </trans-unit>
        <trans-unit id="052b0b761fb9034f5ea9b20f5549120959dfbd83" translate="yes" xml:space="preserve">
          <source>to hold an entire symbol table entry. The type prefix of a typeglob is a &lt;code&gt;*&lt;/code&gt; , because it represents all types. This used to be the preferred way to pass arrays and hashes by reference into a function, but now that we have real references, this is seldom needed.</source>
          <target state="translated">容纳整个符号表条目。typeglob的类型前缀为 &lt;code&gt;*&lt;/code&gt; ，因为它表示所有类型。这曾经是通过引用将数组和哈希传递到函数中的首选方法，但是现在我们有了真实的引用，因此几乎不需要。</target>
        </trans-unit>
        <trans-unit id="2a7f2b88fab3883f2a61c5f5e56375cc228d7086" translate="yes" xml:space="preserve">
          <source>to implement your class.</source>
          <target state="translated">来实现你的类。</target>
        </trans-unit>
        <trans-unit id="9288e371db7100023b08879f0e4418c3566949b3" translate="yes" xml:space="preserve">
          <source>to incorporate the new code.</source>
          <target state="translated">以纳入新的守则。</target>
        </trans-unit>
        <trans-unit id="82d8dafd0d3e9763c0065dba7872f47129cd0ee6" translate="yes" xml:space="preserve">
          <source>to install it locally. (Remember that if you do this, you'll have to put &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib &quot;/my/perl_directory&quot;;&lt;/code&gt; near the top of the program that is to use this module.</source>
          <target state="translated">在本地安装。（请记住，如果执行此操作，则必须在使用此模块的程序顶部附近放置 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib &quot;/my/perl_directory&quot;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16a7203162e974acc6e6c3f1d7e8eb2095e9ba68" translate="yes" xml:space="preserve">
          <source>to invoke the Perl subroutine.</source>
          <target state="translated">来调用Perl子程序。</target>
        </trans-unit>
        <trans-unit id="d2094dc8f62bd8afcfca075e224337bbb8e418f3" translate="yes" xml:space="preserve">
          <source>to it, see &lt;code&gt;emxbind&lt;/code&gt; . Note that under DOS for best results one should use RSX runtime, which has much more functions working (like &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;popen&lt;/code&gt; and so on). In fact RSX is required if there is no VCPI present. Note the RSX requires DPMI. Many implementations of DPMI are known to be very buggy, beware!</source>
          <target state="translated">为此，请参见 &lt;code&gt;emxbind&lt;/code&gt; 。请注意，在DOS下，为了获得最佳效果，应该使用RSX运行时，它具有更多的功能（例如 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;popen&lt;/code&gt; 等）。实际上，如果不存在VCPI，则需要RSX。请注意，RSX需要DPMI。请注意，DPMI的许多实现都非常容易出错！</target>
        </trans-unit>
        <trans-unit id="1e7c69bdd02005a68c5a0491f7b22563882513e5" translate="yes" xml:space="preserve">
          <source>to let Perl see the &lt;b&gt;-p&lt;/b&gt; switch.</source>
          <target state="translated">让Perl看到&lt;b&gt;-p&lt;/b&gt;开关。</target>
        </trans-unit>
        <trans-unit id="1ff1c6954004cf196e1c94a305ba6e22060530e7" translate="yes" xml:space="preserve">
          <source>to list some (not all may be available simultaneously), or it may be read</source>
          <target state="translated">列举一些(不是所有的人都可以同时获得),也可以将其改为</target>
        </trans-unit>
        <trans-unit id="fb94ceb0e63eca810548f16a667eaaf1f49016f4" translate="yes" xml:space="preserve">
          <source>to loop through the</source>
          <target state="translated">绕过</target>
        </trans-unit>
        <trans-unit id="17fd8d3f491879c310e35f1017671959de50087e" translate="yes" xml:space="preserve">
          <source>to make Configure look only into the system libraries. If you have some extra library directories that you really want to use (such as newer Berkeley DB libraries in pre-Panther systems), add those to the libpth:</source>
          <target state="translated">使得Configure只查找系统库。如果你有一些你真正想使用的额外的库目录(比如Panther之前系统中较新的Berkeley DB库),请将这些库添加到libpth中。</target>
        </trans-unit>
        <trans-unit id="fee487ddca5f479ff130a7872bae8c3bd3026aad" translate="yes" xml:space="preserve">
          <source>to make it loadable, that's not recommended. And while you may wish to INSTALL the image for performance reasons, you should not install it with privileges; if you do, the result will not be what you expect as image privileges are disabled during Perl start-up.</source>
          <target state="translated">来使它可以加载,但不建议这样做。虽然出于性能的考虑,你可能希望安装镜像,但你不应该用特权来安装;如果你这样做了,结果就不会像你所期望的那样,因为在Perl启动时,镜像的特权是被禁止的。</target>
        </trans-unit>
        <trans-unit id="7e8b91fe91200b67fd11849738943032a8974f07" translate="yes" xml:space="preserve">
          <source>to merely a lexically scoped</source>
          <target state="translated">以至于只是一个词法范围内的</target>
        </trans-unit>
        <trans-unit id="65db7660c749d5fcb9c05bfb31af1aed3a85d7da" translate="yes" xml:space="preserve">
          <source>to not evaluate &lt;code&gt;foo($bar)&lt;/code&gt; and &lt;code&gt;baz($quux)&lt;/code&gt; when the test is being skipped. But in reality, they</source>
          <target state="translated">跳过测试时不评估 &lt;code&gt;foo($bar)&lt;/code&gt; 和 &lt;code&gt;baz($quux)&lt;/code&gt; 。但实际上，他们</target>
        </trans-unit>
        <trans-unit id="0b442daf0bb11680f2bfe3b64bf4e03e8bea49d4" translate="yes" xml:space="preserve">
          <source>to obtain the text of an HTML-file in an array with all the HTML-tags automagically removed.</source>
          <target state="translated">以数组形式获取HTML文件的文本,并自动删除所有HTML标签。</target>
        </trans-unit>
        <trans-unit id="4b2182d04008a6c4483613ec47473dff2770a53d" translate="yes" xml:space="preserve">
          <source>to other arrays or hashes.</source>
          <target state="translated">到其他数组或哈希。</target>
        </trans-unit>
        <trans-unit id="15de79039ea4eec6320dd0634c5be1d5bee366ab" translate="yes" xml:space="preserve">
          <source>to other threading models is the fact that for each new thread created, a complete copy of all the variables and data of the parent thread has to be taken. Thus, thread creation can be quite expensive, both in terms of memory usage and time spent in creation. The ideal way to reduce these costs is to have a relatively short number of long-lived threads, all created fairly early on (before the base thread has accumulated too much data). Of course, this may not always be possible, so compromises have to be made. However, after a thread has been created, its performance and extra memory usage should be little different than ordinary code.</source>
          <target state="translated">与其他线程模型不同的是,每创建一个新的线程,都要对父线程的所有变量和数据进行完整的复制。因此,线程创建的成本相当高,无论是从内存的使用还是从创建的时间来看都是如此。降低这些成本的理想方法是拥有数量相对较少的长寿命线程,所有线程都在相当早的时候(在基础线程积累了太多数据之前)就被创建。当然,这可能并不总是可能的,所以必须做出妥协。然而,在一个线程被创建之后,它的性能和额外的内存使用量应该和普通代码没有什么区别。</target>
        </trans-unit>
        <trans-unit id="6d9f660d23753136c732ed3417bb35f81b614dbf" translate="yes" xml:space="preserve">
          <source>to overload &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;-quoted strings, constant pieces of &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt;- and &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt;-quoted strings and here-documents,</source>
          <target state="translated">重载 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; 引号的字符串， &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; 的常量和 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; 引号的字符串以及此处的文档，</target>
        </trans-unit>
        <trans-unit id="fb28b87e78501f2d3eca0d75953390d95bf41915" translate="yes" xml:space="preserve">
          <source>to overload constant pieces of regular expressions.</source>
          <target state="translated">来重载正则表达式的常量片段。</target>
        </trans-unit>
        <trans-unit id="7518dc6c2decddb256b0beec05b88725ea598d80" translate="yes" xml:space="preserve">
          <source>to overload floating point constants,</source>
          <target state="translated">来重载浮点常数。</target>
        </trans-unit>
        <trans-unit id="a9ea6185dd3a9dac0c2c5aa1392ed399b440469d" translate="yes" xml:space="preserve">
          <source>to overload integer constants,</source>
          <target state="translated">来重载整数常数。</target>
        </trans-unit>
        <trans-unit id="1c08091b29060daf620ad3d7ec2c2d06ecc69649" translate="yes" xml:space="preserve">
          <source>to overload octal and hexadecimal constants,</source>
          <target state="translated">来过载八进制和十六进制常量。</target>
        </trans-unit>
        <trans-unit id="29f192cae973f004ae05716dbe6e5ada512317df" translate="yes" xml:space="preserve">
          <source>to prevent both obvious and subtle traps. Some of these checks are reasonably simple, such as verifying that path directories aren't writable by others; careful programmers have always used checks like these. Other checks, however, are best supported by the language itself, and it is these checks especially that contribute to making a set-id Perl program more secure than the corresponding C program.</source>
          <target state="translated">来防止明显和细微的陷阱。其中有些检查相当简单,比如验证路径目录是否不可被他人写入;细心的程序员总是使用这样的检查。然而,其他的检查最好由语言本身来支持,特别是这些检查有助于使一个set-id Perl程序比相应的C程序更安全。</target>
        </trans-unit>
        <trans-unit id="51a61bd662ae21c882779433ed339801bd6a9c26" translate="yes" xml:space="preserve">
          <source>to properly restore the &lt;code&gt;LC_NUMERIC&lt;/code&gt; state.</source>
          <target state="translated">正确还原 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="da0f2469f8436e8ff32aedc3a2323005a898d520" translate="yes" xml:space="preserve">
          <source>to put wrappers around your scripts.</source>
          <target state="translated">把包装器放在你的脚本周围。</target>
        </trans-unit>
        <trans-unit id="cfa21274611a5bd065878064455b524270569032" translate="yes" xml:space="preserve">
          <source>to refer a cross-compilation that was created last time.</source>
          <target state="translated">来引用上次创建的交叉编译。</target>
        </trans-unit>
        <trans-unit id="12fc5bdacdc78921dfce599673ebebe3fcce9f11" translate="yes" xml:space="preserve">
          <source>to reflect this.</source>
          <target state="translated">以反映这一点。</target>
        </trans-unit>
        <trans-unit id="659a407adecfa0f6a484510887ce5ba33ab3d34a" translate="yes" xml:space="preserve">
          <source>to reflect where did you put the files. Note that if you have some primitive unzipper (like &lt;code&gt;pkunzip&lt;/code&gt; ), you may get a lot of warnings/errors during unzipping. Upgrade to &lt;code&gt;(w)unzip&lt;/code&gt;.</source>
          <target state="translated">反映您将文件放在何处。请注意，如果您有一些原始的 &lt;code&gt;pkunzip&lt;/code&gt; （例如pkunzip），则在解压缩过程中可能会收到很多警告/错误。升级到 &lt;code&gt;(w)unzip&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d2ba7014727c3cc2499d98334c80eba94773412" translate="yes" xml:space="preserve">
          <source>to reflect your system and run it.</source>
          <target state="translated">以反映你的系统并运行它。</target>
        </trans-unit>
        <trans-unit id="ec73e98b9f1082cb61c5dad4025d258ca0df1374" translate="yes" xml:space="preserve">
          <source>to remove all the leading comments on the fly during the build. The extra \\ are necessary, unfortunately, because this variable is interpolated within the context of a Perl program built on the command line, and double quotes are what is used with the -e switch to build that command line. The # is escaped for the Makefile, since what is going to be generated will then be:</source>
          <target state="translated">来删除所有在构建过程中的前导注释。不幸的是,额外的 \\是必要的,因为这个变量是在命令行上构建的Perl程序的上下文中插值的,而双引号是用-e开关来构建命令行的。在Makefile中,#被转义,因为将要生成的是。</target>
        </trans-unit>
        <trans-unit id="9495b5887b6df8e7d2cf4b53399b33d3bb6d5092" translate="yes" xml:space="preserve">
          <source>to report and view bugs.</source>
          <target state="translated">以报告和查看错误。</target>
        </trans-unit>
        <trans-unit id="1b4afcbda2b19adfed5bf43ff3a2fceb0b887353" translate="yes" xml:space="preserve">
          <source>to resume where the calculation left off.</source>
          <target state="translated">继续计算的地方。</target>
        </trans-unit>
        <trans-unit id="4dbe32b44e63c55a1908194065d741dad727fd9a" translate="yes" xml:space="preserve">
          <source>to return a list and we didn't check for that possibility and take appropriate action the Perl stack would end up in an inconsistent state. That is something you</source>
          <target state="translated">来返回一个列表,而我们没有检查这种可能性并采取适当的行动,Perl 堆栈最终会处于不一致的状态。这就是你</target>
        </trans-unit>
        <trans-unit id="1de7ba1a0f349839e616c4dfb1b79ba2ff660b67" translate="yes" xml:space="preserve">
          <source>to run &lt;code&gt;make install&lt;/code&gt; . If you are not, you must have write access to the directories in question.</source>
          <target state="translated">运行 &lt;code&gt;make install&lt;/code&gt; 。如果不是，那么您必须对相关目录具有写权限。</target>
        </trans-unit>
        <trans-unit id="27c25c5a7db8dc8fe81c102692d1f0f0767d22d3" translate="yes" xml:space="preserve">
          <source>to run under DOS without any external support by binding</source>
          <target state="translated">在DOS下运行,无需任何外部支持,通过绑定</target>
        </trans-unit>
        <trans-unit id="885ddcd0e32212c4767b159144995a96f781aa74" translate="yes" xml:space="preserve">
          <source>to run. A zero signifies the default of 3 seconds. For example to run at least for 10 seconds:</source>
          <target state="translated">运行。0表示默认的3秒。例如,至少运行10秒。</target>
        </trans-unit>
        <trans-unit id="a9f69c5df4d7b34c9f46f4c5644a4993567dda9e" translate="yes" xml:space="preserve">
          <source>to safeguard against your test script blowing up.</source>
          <target state="translated">以防止你的测试脚本被炸毁。</target>
        </trans-unit>
        <trans-unit id="3b5c2aba92e878120336a2bb3d81910b6a90f820" translate="yes" xml:space="preserve">
          <source>to see how Perl does this:</source>
          <target state="translated">来看看Perl是如何做到这一点的。</target>
        </trans-unit>
        <trans-unit id="9ec0179b4e855771865ee056ca147a37ba135ec0" translate="yes" xml:space="preserve">
          <source>to see the call stack at the time of death. By supplying the &lt;b&gt;-warntrace&lt;/b&gt; (or just &lt;b&gt;-w&lt;/b&gt;) flag, any warnings emitted will also come with a stack trace.</source>
          <target state="translated">在死亡时查看调用堆栈。通过提供&lt;b&gt;-warntrace&lt;/b&gt;（或只是&lt;b&gt;-w&lt;/b&gt;）标志，发出的任何警告也将带有堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="1abae5e0b93215dca78b4df050c4b2bb23c4c165" translate="yes" xml:space="preserve">
          <source>to see whether it leads to the list of available locales (search for the</source>
          <target state="translated">来查看它是否导致可用的locales列表(搜索</target>
        </trans-unit>
        <trans-unit id="48e0fbc5536b8ff51cbb0d8c98b627bbd206f258" translate="yes" xml:space="preserve">
          <source>to send a signal to it (that means, to be brief, that the process is owned by the same user, or we are the super-user). This is useful to check that a child process is still alive (even if only as a zombie) and hasn't changed its UID. See &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of this construct.</source>
          <target state="translated">向其发送信号（简而言之，意味着该进程由同一用户拥有，或者我们是超级用户）。这对于检查子进程是否仍处于活动状态（即使仅作为僵尸程序）并且未更改其UID很有用。有关此结构可移植性的说明，请参见&lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db1b23209691204230924770cc7c68e2837b9854" translate="yes" xml:space="preserve">
          <source>to send a signal to it (that means, to be brief, that the process is owned by the same user, or we are the super-user). This is useful to check that a child process is still alive (even if only as a zombie) and hasn't changed its UID. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of this construct.</source>
          <target state="translated">向其发送信号（简而言之，意味着该进程由同一用户拥有，或者我们是超级用户）。这对于检查子进程是否仍处于活动状态（即使仅作为僵尸程序）并且未更改其UID很有用。有关此结构可移植性的说明，请参见&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d97c2933b59d9259995298ef3fafce6e5797cd5" translate="yes" xml:space="preserve">
          <source>to spaces in</source>
          <target state="translated">到空间的</target>
        </trans-unit>
        <trans-unit id="47795bd83bb68151673944f901d2c50b79dcbeb8" translate="yes" xml:space="preserve">
          <source>to specify any code point portably. &lt;code&gt;LATIN1_TO_NATIVE(0xDF)&lt;/code&gt; is going to be the code point that means LATIN SMALL LETTER SHARP S on whatever platform you are running on (on ASCII platforms it compiles without adding any extra code, so there is zero performance hit on those). The acceptable inputs to &lt;code&gt;LATIN1_TO_NATIVE&lt;/code&gt; are from &lt;code&gt;0x00&lt;/code&gt; through &lt;code&gt;0xFF&lt;/code&gt; . If your input isn't guaranteed to be in that range, use &lt;code&gt;UNICODE_TO_NATIVE&lt;/code&gt; instead. &lt;code&gt;NATIVE_TO_LATIN1&lt;/code&gt; and &lt;code&gt;NATIVE_TO_UNICODE&lt;/code&gt; translate the opposite direction.</source>
          <target state="translated">指定可移植的任何代码点。 &lt;code&gt;LATIN1_TO_NATIVE(0xDF)&lt;/code&gt; 将成为代码点，这意味着您正在运行的任何平台上的&amp;ldquo;拉丁小写字母SHARP S&amp;rdquo;（在ASCII平台上编译时都不会添加任何额外的代码，因此对它们的性能影响为零）。 &lt;code&gt;LATIN1_TO_NATIVE&lt;/code&gt; 的可接受输入是从 &lt;code&gt;0x00&lt;/code&gt; 到 &lt;code&gt;0xFF&lt;/code&gt; 。如果不能保证您的输入在该范围内，请改用 &lt;code&gt;UNICODE_TO_NATIVE&lt;/code&gt; 。 &lt;code&gt;NATIVE_TO_LATIN1&lt;/code&gt; 和 &lt;code&gt;NATIVE_TO_UNICODE&lt;/code&gt; 的方向相反。</target>
        </trans-unit>
        <trans-unit id="1197feefbd9420667cdd5a4dd6a4aa3594104c2e" translate="yes" xml:space="preserve">
          <source>to start from the horizontal plane, some texts use</source>
          <target state="translated">从水平面开始,有的文本使用了</target>
        </trans-unit>
        <trans-unit id="5f251a862463ec2d75b253af31e6138a544bfb10" translate="yes" xml:space="preserve">
          <source>to suit the layout of current version of Perl first. Do not forget to pack the necessary external DLLs accordingly. Include the description of the bugs and test suite failures you could not fix. Include the small-stack versions of Perl executables from Perl build directory.</source>
          <target state="translated">以适应当前 Perl 版本的布局。不要忘记相应地打包必要的外部 DLLs。包括您无法修复的 bug 和测试套件失败的描述。包括来自 Perl build 目录的小栈版本的 Perl 可执行文件。</target>
        </trans-unit>
        <trans-unit id="d1c024f5a78b5c864f433d9aa8be1a594410912a" translate="yes" xml:space="preserve">
          <source>to text in verbatim paragraphs.</source>
          <target state="translated">逐字逐句地写成文字。</target>
        </trans-unit>
        <trans-unit id="82ccf1b1bbc5c3b63172011418c70aeccf1f6b30" translate="yes" xml:space="preserve">
          <source>to the &quot;new&quot;</source>
          <target state="translated">到 &quot;新 &quot;的</target>
        </trans-unit>
        <trans-unit id="76d71a404d5345ef6d530d878a49399365e670e1" translate="yes" xml:space="preserve">
          <source>to the &lt;code&gt;Encode&lt;/code&gt; object that is used to convert the source code to Unicode. Thanks to this variable your Perl script does not have to be written in UTF-8. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">到用于将源代码转换为Unicode 的 &lt;code&gt;Encode&lt;/code&gt; 对象。由于有了这个变量，您的Perl脚本不必用UTF-8编写。默认值为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef269923d5b7dae5520c4b226e661ab154e306ec" translate="yes" xml:space="preserve">
          <source>to the array. For example:</source>
          <target state="translated">到数组中。例如:</target>
        </trans-unit>
        <trans-unit id="216f5d19c604dee2234673a86b502cfd302349ee" translate="yes" xml:space="preserve">
          <source>to the corresponding character sequence. That is, it replaces each sequence of characters in the string whose ords represent a valid UTF-X byte sequence, with the corresponding single character. The UTF-8 flag is turned on only if the source string contains multiple-byte</source>
          <target state="translated">到相应的字符序列。也就是说,它将字符串中的每一个字符序列(其ords代表一个有效的UTF-X字节序列)替换为相应的单个字符。UTF-8标志只有在源字符串含有多字节的</target>
        </trans-unit>
        <trans-unit id="df3d9a1670821c7cf27d25bf5204f4ccff8c1fdf" translate="yes" xml:space="preserve">
          <source>to the distribution. That file may contain typemaps that either map types that are specific to your code or that override the core typemap file's mappings for common C types.</source>
          <target state="translated">的文件。该文件可能包含了类型映射,这些类型映射既可以是你的代码所特有的类型,也可以是覆盖核心类型映射文件的普通C类型的类型映射。</target>
        </trans-unit>
        <trans-unit id="5ec04bffb5a640e2121f16fb9848428ade56baa9" translate="yes" xml:space="preserve">
          <source>to the equivalent octet sequence in the native encoding (Latin-1 or EBCDIC). The logical character sequence itself is unchanged. If</source>
          <target state="translated">到本地编码中的等效八位数序列(Latin-1或EBCDIC)。逻辑字符序列本身不变。如果</target>
        </trans-unit>
        <trans-unit id="82e5d8f0d33f3fc1c4fe24b9dc376060a9b0b882" translate="yes" xml:space="preserve">
          <source>to the file</source>
          <target state="translated">到文件</target>
        </trans-unit>
        <trans-unit id="90227e286453c7d696a369902dc40165bb310c1b" translate="yes" xml:space="preserve">
          <source>to the internal suspects list.</source>
          <target state="translated">在内部嫌疑人名单中。</target>
        </trans-unit>
        <trans-unit id="bd12956f16da3a5cd11f46459e6fbfa6aaa9eb4f" translate="yes" xml:space="preserve">
          <source>to the list of directories to search.</source>
          <target state="translated">到要搜索的目录列表中。</target>
        </trans-unit>
        <trans-unit id="8b76166173a60a9172a00fdc4b02f8ec0fddaa92" translate="yes" xml:space="preserve">
          <source>to the package &lt;code&gt;symbolic&lt;/code&gt; . After this change one can do</source>
          <target state="translated">以包装为 &lt;code&gt;symbolic&lt;/code&gt; 。进行此更改后，可以执行</target>
        </trans-unit>
        <trans-unit id="127369588e3806f5dfab2b9107e9f8ad65279c04" translate="yes" xml:space="preserve">
          <source>to the root object is returned. In case an I/O error occurs while reading, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned instead. Other serious errors are propagated via &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回到根对象。如果读取时发生I / O错误，则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。其他严重错误也会通过 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 传播。</target>
        </trans-unit>
        <trans-unit id="f6e9d0a538125eee9f8d6f4cbaa30a1b1fff30fb" translate="yes" xml:space="preserve">
          <source>to the rounded value.</source>
          <target state="translated">到四舍五入的值。</target>
        </trans-unit>
        <trans-unit id="8e225bf1778d80454bbe7a90c5d48ef2598d7c96" translate="yes" xml:space="preserve">
          <source>to this sample program ensures that the output is completely UTF-8, and removes the program's warning.</source>
          <target state="translated">以确保输出完全是UTF-8,并删除程序的警告。</target>
        </trans-unit>
        <trans-unit id="c2e0e9641a1cfa05ec7cd1760997deb3abf87d90" translate="yes" xml:space="preserve">
          <source>to translate POD (Plain Old Documentation - see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; for an explanation) into a manpage, and then run</source>
          <target state="translated">将POD（普通的旧文档- 有关解释，请参见&lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;）转换为联机帮助页，然后运行</target>
        </trans-unit>
        <trans-unit id="394511bb26b8cb98ffae20ceec14f71843c11b8f" translate="yes" xml:space="preserve">
          <source>to translate to the number of seconds which need to be added to UTC to get local time.</source>
          <target state="translated">来翻译成需要添加到UTC的秒数,以获得当地时间。</target>
        </trans-unit>
        <trans-unit id="8b5522aa687ede8069f95ce7a57a06f86362ef8d" translate="yes" xml:space="preserve">
          <source>to undo the feature-enabling side effects of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; .</source>
          <target state="translated">撤消 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; 的启用功能的副作用。</target>
        </trans-unit>
        <trans-unit id="4c8814f0c0136ae299e1d978d9223309dc3f3753" translate="yes" xml:space="preserve">
          <source>to undo the feature-enabling side effects of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; .</source>
          <target state="translated">撤消 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; 的启用功能的副作用。</target>
        </trans-unit>
        <trans-unit id="8ff66ab810bf6e49f296603698cb9fb951159b36" translate="yes" xml:space="preserve">
          <source>to update Encode::ConfigLocal, a module that controls local settings. After that, &quot;use Encode;&quot; is enough to load your encodings on demand.</source>
          <target state="translated">来更新Encode::ConfigLocal,一个控制本地设置的模块。之后,&quot;使用Encode;&quot;就可以按需加载你的编码了。</target>
        </trans-unit>
        <trans-unit id="508860c3910e4168b4709c6d24074c802ac6c067" translate="yes" xml:space="preserve">
          <source>to use Perl debugger (see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;) to debug your PM application (but beware of the message loop lockups - this will not work if you have a message queue to serve, unless you hook the serving into the getc() function of the debugger).</source>
          <target state="translated">使用Perl调试器（请参阅&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;）来调试您的PM应用程序（但要注意消息循环锁定-如果您要服务一个消息队列，这将不起作用，除非您将服务挂接到调试器的getc（）函数中） 。</target>
        </trans-unit>
        <trans-unit id="6c9ee0e1ac650adceaf23fd25a2609a5e096e7ba" translate="yes" xml:space="preserve">
          <source>to use literal backslashes within &lt;code&gt;\Q...\E&lt;/code&gt; , consult &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;Gory details of parsing quoted constructs in perlop&lt;/a&gt;.</source>
          <target state="translated">要在 &lt;code&gt;\Q...\E&lt;/code&gt; 使用文字反斜杠，请查阅&lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;在perlop中解析引用的构造的Gory详细信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f4243d26108dc891c09891b9e0d53323cc3f1aa" translate="yes" xml:space="preserve">
          <source>to use long longs for the 64-bit integer type, in case you don't have a 64-bit CPU.</source>
          <target state="translated">使用长长的64位整数类型,以防你没有64位CPU。</target>
        </trans-unit>
        <trans-unit id="71eaa770d8f526077b4f3192342bbb1dc3e73f22" translate="yes" xml:space="preserve">
          <source>to use the following @INC:</source>
          <target state="translated">来使用以下@INC。</target>
        </trans-unit>
        <trans-unit id="c41a5a2ce143dfaf438913c7854dc4c3a8171d12" translate="yes" xml:space="preserve">
          <source>to verify how your CLI passes the arguments to the program.</source>
          <target state="translated">来验证你的CLI如何将参数传递给程序。</target>
        </trans-unit>
        <trans-unit id="c1b9231e94fd8b3c3cab617ce687784026021ccb" translate="yes" xml:space="preserve">
          <source>to work as expected.</source>
          <target state="translated">以达到预期的效果。</target>
        </trans-unit>
        <trans-unit id="86f28e5ec97934fa33153df2fc5e2b5b65583051" translate="yes" xml:space="preserve">
          <source>to.</source>
          <target state="translated">to.</target>
        </trans-unit>
        <trans-unit id="ba1cfdcd865f3b87bcc9595dd395087b084ac080" translate="yes" xml:space="preserve">
          <source>to:</source>
          <target state="translated">to:</target>
        </trans-unit>
        <trans-unit id="9461b677437869b4caa6ae020e205909485b9fed" translate="yes" xml:space="preserve">
          <source>toke.c</source>
          <target state="translated">toke.c</target>
        </trans-unit>
        <trans-unit id="3b1ebaa6a9e7c2d892d7a35c0681619b6af90370" translate="yes" xml:space="preserve">
          <source>token are split out into separate files. Some routines may be placed prior to this marker to force their immediate loading and parsing.</source>
          <target state="translated">token被分割成不同的文件。一些例程可以放在这个标记之前,以强制其立即加载和解析。</target>
        </trans-unit>
        <trans-unit id="ac1c3db3f21e326855ec671f236713cdbe520c2c" translate="yes" xml:space="preserve">
          <source>tolerate arbitrarily large amounts of text in the &quot;=item</source>
          <target state="translated">容忍&quot;=item &quot;中任意大量的文字。</target>
        </trans-unit>
        <trans-unit id="d9ae998ab9e8ebfc629710b723541fc505ed244c" translate="yes" xml:space="preserve">
          <source>tom (at) compton.nu</source>
          <target state="translated">tom (at)compton.nu</target>
        </trans-unit>
        <trans-unit id="903d7da65d624842b5db58b63ef8eaae82b048be" translate="yes" xml:space="preserve">
          <source>tom@compton.nu</source>
          <target state="translated">tom@compton.nu</target>
        </trans-unit>
        <trans-unit id="164a5c24f5df5918f285228443ab87209785293f" translate="yes" xml:space="preserve">
          <source>too</source>
          <target state="translated">too</target>
        </trans-unit>
        <trans-unit id="b47f0da3aa6e0a239f5e94e0877b31f25e13bf8a" translate="yes" xml:space="preserve">
          <source>too.</source>
          <target state="translated">too.</target>
        </trans-unit>
        <trans-unit id="426267451d2aab91845a1f7b22772772450c1009" translate="yes" xml:space="preserve">
          <source>too. Add this line BEFORE any section definition:</source>
          <target state="translated">也是。在任何章节定义之前添加这一行。</target>
        </trans-unit>
        <trans-unit id="90edf77c811db872526b3b484bef9279ab6440fb" translate="yes" xml:space="preserve">
          <source>tool can then display the collected data in various ways. Usually</source>
          <target state="translated">工具可以将收集到的数据以各种方式显示出来。通常情况下</target>
        </trans-unit>
        <trans-unit id="ccb51450d25446e81f4942d86de10a8c406492b5" translate="yes" xml:space="preserve">
          <source>tool included with Perl 5. Bug reports will be included in the Perl 5 ticket system at &lt;a href=&quot;http://rt.perl.org&quot;&gt;http://rt.perl.org&lt;/a&gt;.</source>
          <target state="translated">Perl 5附带的工具。错误报告将包含在&lt;a href=&quot;http://rt.perl.org&quot;&gt;http://rt.perl.org&lt;/a&gt;的Perl 5票务系统中。</target>
        </trans-unit>
        <trans-unit id="8f39224c5c445b7f4c4eea9f381baa177eb7cb91" translate="yes" xml:space="preserve">
          <source>tool installed.</source>
          <target state="translated">安装的工具。</target>
        </trans-unit>
        <trans-unit id="88aa984e8c2d55237b91314cbcf92140805cfef9" translate="yes" xml:space="preserve">
          <source>tool that comes with Perl tries to convert C include files to Perl code, which can be &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d. FIONREAD ends up defined as a function in the</source>
          <target state="translated">Perl随附的工具尝试将C包含文件转换为Perl代码，这可能是 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 。FIONREAD最终定义为</target>
        </trans-unit>
        <trans-unit id="f92adaa38df139e8b7202b087183871bcb1dd01c" translate="yes" xml:space="preserve">
          <source>tool. If you fix or enhance a performance issue, you may want to add a representative code sample to the file, then run</source>
          <target state="translated">工具。如果您修复或增强了性能问题,您可能需要在文件中添加一个有代表性的代码样本,然后运行</target>
        </trans-unit>
        <trans-unit id="8cd3fb1667a905290c5b0e870e6cf4f615dde4f7" translate="yes" xml:space="preserve">
          <source>tool_autosplit</source>
          <target state="translated">tool_autosplit</target>
        </trans-unit>
        <trans-unit id="b8623287e2d342133af98c4af1a3151d917692c2" translate="yes" xml:space="preserve">
          <source>tools_other</source>
          <target state="translated">tools_other</target>
        </trans-unit>
        <trans-unit id="156806de8ef990a34b3ac6280c26b4ecca6c2b47" translate="yes" xml:space="preserve">
          <source>top_anchor</source>
          <target state="translated">top_anchor</target>
        </trans-unit>
        <trans-unit id="b415e16fbe4ca40f22707a97322b49cb9bc5e487" translate="yes" xml:space="preserve">
          <source>topic</source>
          <target state="translated">topic</target>
        </trans-unit>
        <trans-unit id="4f83d880aeb0e2a0498a5bc0e8ac975990e97449" translate="yes" xml:space="preserve">
          <source>tored by Gurusamy Sarathy (&amp;lt;gsar@activestate.com&amp;gt;), Tom Christiansen (&amp;lt;tchrist@perl.com&amp;gt;), Nathan Torkington (&amp;lt;gnat@frii.com&amp;gt;), Charles F. Randall (&amp;lt;cfr@pobox.com&amp;gt;), Mike Guy (&amp;lt;mjtg@cam.ac.uk&amp;gt;), Dominic Dunlop (&amp;lt;domo@computer.org&amp;gt;), Hugo van der Sanden (&amp;lt;hv@crypt.org&amp;gt;), Jarkko Hietaniemi (&amp;lt;jhi@iki.fi&amp;gt;), Chris Nandor (&amp;lt;pudge@pobox.com&amp;gt;), Jon Orwant (&amp;lt;orwant@media.mit.edu&amp;gt;, Richard Foley (&amp;lt;richard.foley@rfi.net&amp;gt;), Jesse Vincent (&amp;lt;jesse@bestpractical.com&amp;gt;), and Craig A. Berry (&amp;lt;craigberry@mac.com&amp;gt;).</source>
          <target state="translated">由Gurusamy Sarathy（&amp;lt;gsar@activestate.com&amp;gt;），Tom Christiansen（&amp;lt;tchrist@perl.com&amp;gt;），Nathan Torkington（&amp;lt;gnat@frii.com&amp;gt;），Charles F.Randall（&amp;lt;cfr@pobox.com&amp;gt; ），Mike Guy（&amp;lt;mjtg@cam.ac.uk&amp;gt;），Dominic Dunlop（&amp;lt;domo@computer.org&amp;gt;），Hugo van der Sanden（&amp;lt;hv@crypt.org&amp;gt;），Jarkko Hietaniemi（&amp;lt;jhi @ iki。 fi&amp;gt;），克里斯&amp;middot;南多（Chris Nandor）（&amp;lt;pudge@pobox.com&amp;gt;），乔恩&amp;middot;奥万特（Jon Orwant）（&amp;lt;orwant@media.mit.edu&amp;gt;，理查德&amp;middot;弗利（Richard Foley）（&amp;lt;richard.foley@rfi.net&amp;gt;），杰西&amp;middot;文森特（Jesse Vincent）（&amp;lt;jesse @ bestpractical .com&amp;gt;）和Craig A. Berry（&amp;lt;craigberry@mac.com&amp;gt;）。</target>
        </trans-unit>
        <trans-unit id="f946bb4c412cec0161b446353e7e1a4ee67a20e7" translate="yes" xml:space="preserve">
          <source>total number of bytes</source>
          <target state="translated">总字节数</target>
        </trans-unit>
        <trans-unit id="d9e83874d260f2f10d48d98c0b773b836096d426" translate="yes" xml:space="preserve">
          <source>tr</source>
          <target state="translated">tr</target>
        </trans-unit>
        <trans-unit id="c39522f52c3ec29023c219c19d4067a9b3eee877" translate="yes" xml:space="preserve">
          <source>tr///</source>
          <target state="translated">tr///</target>
        </trans-unit>
        <trans-unit id="536783780cbdb29a264e212e15753a5bedd082e3" translate="yes" xml:space="preserve">
          <source>trailingData</source>
          <target state="translated">trailingData</target>
        </trans-unit>
        <trans-unit id="15c4593ae86e3bf2017dc51f07fb9e08cc13291e" translate="yes" xml:space="preserve">
          <source>translates a list of numbers to the corresponding characters.</source>
          <target state="translated">将一个数字列表翻译成相应的字符。</target>
        </trans-unit>
        <trans-unit id="34d7fc1774ad1e06f48d4d6adb73b20c2ab97c2b" translate="yes" xml:space="preserve">
          <source>translates a list of numbers to their squared values.</source>
          <target state="translated">将一个数字列表转换为它们的平方值。</target>
        </trans-unit>
        <trans-unit id="b957f6243dc857b0d32b836fc652ac09fad6dc17" translate="yes" xml:space="preserve">
          <source>translates to any other string, that string is used as the name of a logical name table, which is consulted using</source>
          <target state="translated">翻译为任何其他字符串,该字符串将被用作逻辑名称表的名称,该表将使用</target>
        </trans-unit>
        <trans-unit id="b83065734825ace6b5d6e623f5d8b917a787ab2d" translate="yes" xml:space="preserve">
          <source>translating the small parts into regexps,</source>
          <target state="translated">将小部件翻译成regexps。</target>
        </trans-unit>
        <trans-unit id="7982afa4ce12a15076ad30ff5a7c216bd7dd8013" translate="yes" xml:space="preserve">
          <source>transliterates into</source>
          <target state="translated">译成</target>
        </trans-unit>
        <trans-unit id="38bedfbdef70fc53b2e50e67a65d5f48bdccc217" translate="yes" xml:space="preserve">
          <source>trap (OP, ...), untrap (OP, ...)</source>
          <target state="translated">诱捕器</target>
        </trans-unit>
        <trans-unit id="ce03721ca3b28ce2f21226c122a3dc4ab883c73d" translate="yes" xml:space="preserve">
          <source>treated</source>
          <target state="translated">treated</target>
        </trans-unit>
        <trans-unit id="42dc828341bea99e4235ff61dd8d9128d8bccb29" translate="yes" xml:space="preserve">
          <source>trial.gz</source>
          <target state="translated">trial.gz</target>
        </trans-unit>
        <trans-unit id="d67deefa1e5c2dfdd8fc91aa3b6e2acaad1cff89" translate="yes" xml:space="preserve">
          <source>tries to load optional library but also dies if library is not available</source>
          <target state="translated">试图加载可选的库,但如果库不可用,也会死机。</target>
        </trans-unit>
        <trans-unit id="d32c5b68132ef2211100518b2ca2f7847b516c84" translate="yes" xml:space="preserve">
          <source>trnl.U</source>
          <target state="translated">trnl.U</target>
        </trans-unit>
        <trans-unit id="cc4728d0763649871c56fd8cb6de629f5fbf5b84" translate="yes" xml:space="preserve">
          <source>troff(1)</source>
          <target state="translated">troff(1)</target>
        </trans-unit>
        <trans-unit id="5ffe533b830f08a0326348a9160afafc8ada44db" translate="yes" xml:space="preserve">
          <source>true</source>
          <target state="translated">true</target>
        </trans-unit>
        <trans-unit id="438789e48d4c0e2a17e93fb22d092028b03bb360" translate="yes" xml:space="preserve">
          <source>true if the Perl library was compiled in AOUT format.</source>
          <target state="translated">如果Perl库是以AOUT格式编译的,则为true。</target>
        </trans-unit>
        <trans-unit id="59e4766fb49e429a8314ef2500009926b97e90d6" translate="yes" xml:space="preserve">
          <source>true if the current executable is an AOUT EMX executable, so Perl can fork. Do not use this, use the portable check for $Config::Config{dfork}.</source>
          <target state="translated">true,如果当前可执行文件是AOUT EMX可执行文件,那么Perl可以fork。不要使用这个,请使用 $Config::Config{dfork}的可移植检查。</target>
        </trans-unit>
        <trans-unit id="1bcf5542764919cf26fda2e66c73aa29f02ef9a2" translate="yes" xml:space="preserve">
          <source>true if this pref has a 'match' attribute and at least one valid match attribute</source>
          <target state="translated">如果这个pref有一个'match'属性和至少一个有效的match属性,则为true。</target>
        </trans-unit>
        <trans-unit id="3fce60a5697d8001beb7164eaf5a9b21b4de4c72" translate="yes" xml:space="preserve">
          <source>true if this pref has a 'match' attribute at all</source>
          <target state="translated">true,如果这个pref有'match'属性的话。</target>
        </trans-unit>
        <trans-unit id="1e9cc6decc0c9571c723bb4ad00488c48abdc585" translate="yes" xml:space="preserve">
          <source>true if this pref matches the passed-in hashref, which must have a value for each of the &lt;code&gt;match_attributes&lt;/code&gt; (above)</source>
          <target state="translated">如果此首选项与传入的hashref匹配，则返回true，该哈希引用必须具有每个 &lt;code&gt;match_attributes&lt;/code&gt; 的值（上述）</target>
        </trans-unit>
        <trans-unit id="cb4b42b99367dbaef3b308097c9d0a1cff17603b" translate="yes" xml:space="preserve">
          <source>true in &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub{}&lt;/a&gt;&lt;/code&gt;, or contrary to popular belief &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; blocks, which do</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub{}&lt;/a&gt;&lt;/code&gt; true ，或者与流行的信念 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; 块相反，</target>
        </trans-unit>
        <trans-unit id="66fe2fdee953072a309daa163ca5ed615049d0c2" translate="yes" xml:space="preserve">
          <source>trueop</source>
          <target state="translated">trueop</target>
        </trans-unit>
        <trans-unit id="90099b2e34aa9d96304e9cb4c2b9ae07073445c0" translate="yes" xml:space="preserve">
          <source>truly</source>
          <target state="translated">truly</target>
        </trans-unit>
        <trans-unit id="f283ea9bea0e80213ac091021420ffc9b3415914" translate="yes" xml:space="preserve">
          <source>truncate</source>
          <target state="translated">truncate</target>
        </trans-unit>
        <trans-unit id="a1261bf96d8d4c6b4b727d215938b97e14a121ae" translate="yes" xml:space="preserve">
          <source>truncate EXPR,LENGTH</source>
          <target state="translated">截断EXPR,LENGTH。</target>
        </trans-unit>
        <trans-unit id="c0a4a0ea2c037915554ed29699877c89805a57bd" translate="yes" xml:space="preserve">
          <source>truncate FILEHANDLE,LENGTH</source>
          <target state="translated">截断FILEHANDLE,LENGTH。</target>
        </trans-unit>
        <trans-unit id="53028b90056316570dad36dc627a6b17c0330b6d" translate="yes" xml:space="preserve">
          <source>truncation invariably removes all digits following the rounding place, replacing them with zeros. Thus, 987.65 rounded to tens (P=1) becomes 980, and rounded to the fourth sigdig becomes 987.6 (A=4). 123.456 rounded to the second place after the decimal point (P=-2) becomes 123.46.</source>
          <target state="translated">截断必然会去掉四舍五入后的所有数字,用0代替。因此,987.65四舍五入到十位(P=1)变成980,四舍五入到第四位sigdig变成987.6(A=4)。123.456四舍五入到小数点后第二位(P=-2)变成123.46。</target>
        </trans-unit>
        <trans-unit id="45fa151bf9a11c0e25734df135de9edd4ff738df" translate="yes" xml:space="preserve">
          <source>truth</source>
          <target state="translated">truth</target>
        </trans-unit>
        <trans-unit id="823fca4f1093d64814a9d2afbcda71b935d03e40" translate="yes" xml:space="preserve">
          <source>try something like the following:</source>
          <target state="translated">试着做一些类似下面的事情。</target>
        </trans-unit>
        <trans-unit id="ce6d1c45f4e5ab6843ee500a73af34957d4c92aa" translate="yes" xml:space="preserve">
          <source>try to equate new (and never-used, and unusable) ISO639-2 three-letter tags to old (and still in use) ISO639-1 two-letter equivalents -- like &quot;ara&quot; -&amp;gt; &quot;ar&quot; -- because &quot;ara&quot; has</source>
          <target state="translated">尝试将新的（且从未使用过且无法使用的）ISO639-2三字母标签等同于旧的（仍在使用中）ISO639-1两字母标签（例如&amp;ldquo; ara&amp;rdquo;-&amp;gt;&amp;ldquo; ar&amp;rdquo;），因为&amp;ldquo; ara&amp;rdquo;有</target>
        </trans-unit>
        <trans-unit id="cb050805b03c907314122eca2548681495db1636" translate="yes" xml:space="preserve">
          <source>tst.fil</source>
          <target state="translated">tst.fil</target>
        </trans-unit>
        <trans-unit id="9f160f66c4d781a33c60820b496697aaf2bd47ff" translate="yes" xml:space="preserve">
          <source>tty(1)</source>
          <target state="translated">tty(1)</target>
        </trans-unit>
        <trans-unit id="6b7c4b72eb87c9f9986fb12efd7d83af95caa365" translate="yes" xml:space="preserve">
          <source>turkic</source>
          <target state="translated">turkic</target>
        </trans-unit>
        <trans-unit id="bb900dfa419ab730b52dadfa0dfec48b9c5a6aba" translate="yes" xml:space="preserve">
          <source>turns debugging on for all packages.</source>
          <target state="translated">打开所有软件包的调试功能。</target>
        </trans-unit>
        <trans-unit id="8a1f73e9662f187f57c576ccd9399ebd14ab3421" translate="yes" xml:space="preserve">
          <source>turns into</source>
          <target state="translated">变成</target>
        </trans-unit>
        <trans-unit id="85691f9a0ab6bb1c21ccb666a6135b2368136c66" translate="yes" xml:space="preserve">
          <source>turns on &quot;taint&quot; so you can test them. Ordinarily these checks are done only when running setuid or setgid. It's a good idea to turn them on explicitly for programs that run on behalf of someone else whom you might not necessarily trust, such as CGI programs or any internet servers you might write in Perl. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for details. For security reasons, this option must be seen by Perl quite early; usually this means it must appear early on the command line or in the &lt;code&gt;#!&lt;/code&gt; line for systems which support that construct.</source>
          <target state="translated">打开&amp;ldquo;污点&amp;rdquo;，以便您可以对其进行测试。通常，仅在运行setuid或setgid时才进行这些检查。最好为代表您可能不一定信任的其他人运行的程序（例如CGI程序或您可能在Perl中编写的任何Internet服务器）显式打开它们的一个好主意。有关详细信息，请参见&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;。出于安全原因，Perl必须很早就看到此选项。通常，这意味着它必须早在命令行或 &lt;code&gt;#!&lt;/code&gt; 中出现!支持该构造的系统的生产线。</target>
        </trans-unit>
        <trans-unit id="ef46c243925d2af48b614f7b9635e2daf263b6a6" translate="yes" xml:space="preserve">
          <source>turns on autosplit mode when used with a &lt;b&gt;-n&lt;/b&gt; or &lt;b&gt;-p&lt;/b&gt;. An implicit split command to the @F array is done as the first thing inside the implicit while loop produced by the &lt;b&gt;-n&lt;/b&gt; or &lt;b&gt;-p&lt;/b&gt;.</source>
          <target state="translated">与&lt;b&gt;-n&lt;/b&gt;或&lt;b&gt;-p&lt;/b&gt;一起使用时，打开自动拆分模式。对@F数组的隐式split命令是由&lt;b&gt;-n&lt;/b&gt;或&lt;b&gt;-p&lt;/b&gt;生成的隐式while循环中的第一件事。</target>
        </trans-unit>
        <trans-unit id="eee45a4f6e1f6f37d3488c8a9faeb95e80168595" translate="yes" xml:space="preserve">
          <source>tv_interval ( $ref_to_gettimeofday [, $ref_to_later_gettimeofday] )</source>
          <target state="translated">tv_interval($ref_to_gettimeofday [,$ref_to_later_gettimeofday])</target>
        </trans-unit>
        <trans-unit id="ad782ecdac770fc6eb9a62e44f90873fb97fb26b" translate="yes" xml:space="preserve">
          <source>two</source>
          <target state="translated">two</target>
        </trans-unit>
        <trans-unit id="9c545de6bb84eb94b6126add62f1eef381366296" translate="yes" xml:space="preserve">
          <source>two-dimensional slice</source>
          <target state="translated">二维片</target>
        </trans-unit>
        <trans-unit id="a123eaabf183286fe1b857fb9fc12040b8b4df03" translate="yes" xml:space="preserve">
          <source>two_face.pm</source>
          <target state="translated">two_face.pm</target>
        </trans-unit>
        <trans-unit id="d0a3e7f81a9885e99049d1cae0336d269d5e47a9" translate="yes" xml:space="preserve">
          <source>type</source>
          <target state="translated">type</target>
        </trans-unit>
        <trans-unit id="5f7b4d8120e3abb8a993bd8c9369e8e492554273" translate="yes" xml:space="preserve">
          <source>type of $bar is a scalar reference, and we do not overload the scalar dereference. Thus we can get the</source>
          <target state="translated">类型的$bar是一个标量引用,我们不重载标量的析出。因此我们可以得到</target>
        </trans-unit>
        <trans-unit id="0f846c66a3d5e2d04d7dad5376934b529b97a76f" translate="yes" xml:space="preserve">
          <source>type of &lt;code&gt;File&lt;/code&gt; . All mp3 files are files, but not all files are mp3 files.</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 类型。所有mp3文件都是文件，但并非所有文件都是mp3文件。</target>
        </trans-unit>
        <trans-unit id="4d48747c7234e695806a5ec0475ca088f8de7d2c" translate="yes" xml:space="preserve">
          <source>type of damage only: FP flags changed when loading a DLL.</source>
          <target state="translated">类型的损害而已。加载DLL时FP标志改变。</target>
        </trans-unit>
        <trans-unit id="609d101b171f19730b086799c893b4bced74e281" translate="yes" xml:space="preserve">
          <source>typeglob</source>
          <target state="translated">typeglob</target>
        </trans-unit>
        <trans-unit id="3f6b0af8d4178fa799abd02b53080eb8e0e9d792" translate="yes" xml:space="preserve">
          <source>typemap</source>
          <target state="translated">typemap</target>
        </trans-unit>
        <trans-unit id="e7b1fff7007b635892a8f2c7c17f4fabc7aa2f8c" translate="yes" xml:space="preserve">
          <source>types</source>
          <target state="translated">types</target>
        </trans-unit>
        <trans-unit id="c3c57ccf025216fd17025a5cd72ba43c150e0712" translate="yes" xml:space="preserve">
          <source>typestash</source>
          <target state="translated">typestash</target>
        </trans-unit>
        <trans-unit id="51e69892ab49df85c6230ccc57f8e1d1606caccc" translate="yes" xml:space="preserve">
          <source>u</source>
          <target state="translated">u</target>
        </trans-unit>
        <trans-unit id="4914c57306212f2cc515f07c8cf90f3fabf5399e" translate="yes" xml:space="preserve">
          <source>ualarm(0) will cancel an outstanding ualarm().</source>
          <target state="translated">ualarm(0)将取消一个未完成的ualarm()。</target>
        </trans-unit>
        <trans-unit id="3519ace88affd1d0bcd984e15dfaf7b1c1479e99" translate="yes" xml:space="preserve">
          <source>uc</source>
          <target state="translated">uc</target>
        </trans-unit>
        <trans-unit id="46680910c867722cf1e95037ec06eee09df4a0d5" translate="yes" xml:space="preserve">
          <source>uc EXPR</source>
          <target state="translated">uc EXPR</target>
        </trans-unit>
        <trans-unit id="62a2132e3a00127b1e64e2e50602c12c4f218bce" translate="yes" xml:space="preserve">
          <source>ucfirst</source>
          <target state="translated">ucfirst</target>
        </trans-unit>
        <trans-unit id="46c5616dab2749d151e0c53b59ef03e6d4e5ee52" translate="yes" xml:space="preserve">
          <source>ucfirst EXPR</source>
          <target state="translated">ucfirst EXPR</target>
        </trans-unit>
        <trans-unit id="92e6f746eff84e65c584e48e78614108b0c4500a" translate="yes" xml:space="preserve">
          <source>ucmlint</source>
          <target state="translated">ucmlint</target>
        </trans-unit>
        <trans-unit id="85b193ef62ce5bd8f0d8f72987c5acefe070a801" translate="yes" xml:space="preserve">
          <source>ucmsort</source>
          <target state="translated">ucmsort</target>
        </trans-unit>
        <trans-unit id="c9915ec6eb1c1121af4deacd2838d47d88af181c" translate="yes" xml:space="preserve">
          <source>ucsort</source>
          <target state="translated">ucsort</target>
        </trans-unit>
        <trans-unit id="9ab3443b0dd255d92dea875958de03ac53cd401e" translate="yes" xml:space="preserve">
          <source>uid and gid, in that order. A value of -1 in either position is interpreted by most systems to leave that value unchanged. Returns the number of files successfully changed.</source>
          <target state="translated">uid和gid,依次类推。其中任何一个位置的值为-1,都会被大多数系统解释为保持该值不变。返回成功更改的文件数量。</target>
        </trans-unit>
        <trans-unit id="b14ef85c6823dc1f2ef811c9a63a44faab1dfccc" translate="yes" xml:space="preserve">
          <source>uidf.U</source>
          <target state="translated">uidf.U</target>
        </trans-unit>
        <trans-unit id="4f266624b4cab00c3fa39590bc3e4d402c6054f9" translate="yes" xml:space="preserve">
          <source>uidsign.U</source>
          <target state="translated">uidsign.U</target>
        </trans-unit>
        <trans-unit id="49d287411193cd0643e68cecc7793271c3750fe3" translate="yes" xml:space="preserve">
          <source>uidsize.U</source>
          <target state="translated">uidsize.U</target>
        </trans-unit>
        <trans-unit id="ef4e5b306b52e07f68c82e7e4824b1b0139a919a" translate="yes" xml:space="preserve">
          <source>uidtype.U</source>
          <target state="translated">uidtype.U</target>
        </trans-unit>
        <trans-unit id="4b824f445e8d64ec6f262547c18a3ab02a6fd22c" translate="yes" xml:space="preserve">
          <source>umask</source>
          <target state="translated">umask</target>
        </trans-unit>
        <trans-unit id="36e21e5c3a8f3b270b5c9c2576b01408eed47929" translate="yes" xml:space="preserve">
          <source>umask EXPR</source>
          <target state="translated">掩码EXPR</target>
        </trans-unit>
        <trans-unit id="eb6198103dad02d1c9dcb61d16d9ffbac78237d4" translate="yes" xml:space="preserve">
          <source>umask() works, but the correct permissions are only set when the file is finally close()d</source>
          <target state="translated">umask()工作,但只有在最后关闭()d文件时才会设置正确的权限。</target>
        </trans-unit>
        <trans-unit id="7de840c4a5d7a3a264136f73eb4f2de7198cc159" translate="yes" xml:space="preserve">
          <source>unable to run</source>
          <target state="translated">跑不动</target>
        </trans-unit>
        <trans-unit id="5c9d9a1ee71ab26f80b55634148ddbec55d054c0" translate="yes" xml:space="preserve">
          <source>uncolor() performs the opposite translation as color(), turning escape sequences into a list of strings corresponding to the attributes being set by those sequences.</source>
          <target state="translated">uncolor()执行与color()相反的翻译,将转义序列变成与这些序列所设置的属性相对应的字符串列表。</target>
        </trans-unit>
        <trans-unit id="894a40dce8e5591059922ff5808e4c093326c141" translate="yes" xml:space="preserve">
          <source>undef</source>
          <target state="translated">undef</target>
        </trans-unit>
        <trans-unit id="98feb57f02fa68186d8b891aea735323789452c7" translate="yes" xml:space="preserve">
          <source>undef EXPR</source>
          <target state="translated">undef EXPR</target>
        </trans-unit>
        <trans-unit id="2e6e324398420050bcebe65786c1ee784c78a29b" translate="yes" xml:space="preserve">
          <source>undefined symbols when it loads a dynamic library. The default behaviour is to resolve symbols when they are used. Setting this variable is useful during testing of extensions, as it ensures that you get an error on misspelled function names even if the test suite doesn't call them.</source>
          <target state="translated">当它加载一个动态库时,未定义的符号。默认的行为是在使用符号时进行解析。设置这个变量在测试扩展时很有用,因为它可以确保即使测试套件没有调用这些函数,也会在拼写错误的函数名时出现错误。</target>
        </trans-unit>
        <trans-unit id="b514a784ac2399d445614c88fc7a8533a4e033a5" translate="yes" xml:space="preserve">
          <source>under Unix), which can set important options. (A subroutine (&lt;code&gt;&amp;amp;afterinit&lt;/code&gt; ) can be defined here as well; it is executed after the debugger completes its own initialization.)</source>
          <target state="translated">（在Unix下），可以设置重要选项。（也可以在此处定义子例程（ &lt;code&gt;&amp;amp;afterinit&lt;/code&gt; ；在调试器完成其自身的初始化之后执行）。</target>
        </trans-unit>
        <trans-unit id="9dafb5899098e6cb8288d8485a2851027cdacf0a" translate="yes" xml:space="preserve">
          <source>under Unixy systems.] but here we've specified the port number (13) in parentheses. Using just the number would have also worked, but numeric literals make careful programmers nervous.</source>
          <target state="translated">但这里我们在括号里指定了端口号 (13)。只用数字也可以,但数字的字面意思会让细心的程序员感到紧张。</target>
        </trans-unit>
        <trans-unit id="4fd1ca9b1cc4b71ec35a6a6dcfdad1203f30fb09" translate="yes" xml:space="preserve">
          <source>under control of the &lt;code&gt;$^F&lt;/code&gt; variable. This is so any filehandles you didn't explicitly route to the STDIN, STDOUT or STDERR of a child</source>
          <target state="translated">在 &lt;code&gt;$^F&lt;/code&gt; 变量的控制之下。这样一来，您没有显式路由到子代的STDIN，STDOUT或STDERR的任何文件句柄</target>
        </trans-unit>
        <trans-unit id="7881ed7a3c041a4c372935ce39c3487feea2f64f" translate="yes" xml:space="preserve">
          <source>under the name &lt;code&gt;MY::top_targets&lt;/code&gt; ;</source>
          <target state="translated">以 &lt;code&gt;MY::top_targets&lt;/code&gt; 名称命名；</target>
        </trans-unit>
        <trans-unit id="9f01b49453b711076f00ff8b4dd47a7886a96fc1" translate="yes" xml:space="preserve">
          <source>under the specified locations are automatically included if they exist, with this lookup done at interpreter startup time. In addition, any directories matching the entries in &lt;code&gt;$Config{inc_version_list}&lt;/code&gt; are added. (These typically would be for older compatible perl versions installed in the same directory tree.)</source>
          <target state="translated">如果存在，则将自动包含指定位置下的，将在解释器启动时进行此查找。此外， &lt;code&gt;$Config{inc_version_list}&lt;/code&gt; 添加与$ Config {inc_version_list}中的条目匹配的所有目录。（这些通常用于安装在同一目录树中的较早兼容的Perl版本。）</target>
        </trans-unit>
        <trans-unit id="c82b67c88e6911c321806d35b9d8f040d8726133" translate="yes" xml:space="preserve">
          <source>underline</source>
          <target state="translated">underline</target>
        </trans-unit>
        <trans-unit id="7455d50fd345c0e29f3dcf49611be6ce0df37457" translate="yes" xml:space="preserve">
          <source>understands the following options:</source>
          <target state="translated">了解以下选项:</target>
        </trans-unit>
        <trans-unit id="5ddb3081295d2039a2ce92ed30ca850d53c716e6" translate="yes" xml:space="preserve">
          <source>undone during backtracking, and we get</source>
          <target state="translated">在回溯过程中解开,我们得到的是</target>
        </trans-unit>
        <trans-unit id="3f9c012699681359b2d4c5c0da4c0c319f7b4851" translate="yes" xml:space="preserve">
          <source>undump</source>
          <target state="translated">undump</target>
        </trans-unit>
        <trans-unit id="8b77486db5e737dfba2f215ad3f09d26e7574ce4" translate="yes" xml:space="preserve">
          <source>ungetc</source>
          <target state="translated">ungetc</target>
        </trans-unit>
        <trans-unit id="611ef7f3e74e93a2d99c8502e80be88ed14c4b7a" translate="yes" xml:space="preserve">
          <source>unicaps</source>
          <target state="translated">unicaps</target>
        </trans-unit>
        <trans-unit id="d0621ea6db045280a171ba1bfb3a6dfa337b7d85" translate="yes" xml:space="preserve">
          <source>unichars</source>
          <target state="translated">unichars</target>
        </trans-unit>
        <trans-unit id="8236ccc893aa3b688923006cde5ef7c867e1200f" translate="yes" xml:space="preserve">
          <source>unicore/</source>
          <target state="translated">unicore/</target>
        </trans-unit>
        <trans-unit id="34819feb4a120661fd90c7edb70e9578267e83cd" translate="yes" xml:space="preserve">
          <source>unicore/README.perl</source>
          <target state="translated">unicore/README.perl</target>
        </trans-unit>
        <trans-unit id="9cef115904c9a43eab6bd725f98fb0e895022817" translate="yes" xml:space="preserve">
          <source>unicore/mktables</source>
          <target state="translated">unicore/mktables</target>
        </trans-unit>
        <trans-unit id="695753c5963950095c0928d372a2deb661f1bf28" translate="yes" xml:space="preserve">
          <source>unifmt</source>
          <target state="translated">unifmt</target>
        </trans-unit>
        <trans-unit id="c2b5c55f0827d9c553bdc5a4de94a5d8d20f474b" translate="yes" xml:space="preserve">
          <source>unilook</source>
          <target state="translated">unilook</target>
        </trans-unit>
        <trans-unit id="b1217427083e0f38e61077d9500c698e2f3ef93b" translate="yes" xml:space="preserve">
          <source>unimplemented in this platform</source>
          <target state="translated">在这个平台上没有实现</target>
        </trans-unit>
        <trans-unit id="c9f59799203ace15feeda610ffd283211d4c8395" translate="yes" xml:space="preserve">
          <source>uninames</source>
          <target state="translated">uninames</target>
        </trans-unit>
        <trans-unit id="e375ed02e8215d5defda8610a10331083ab72346" translate="yes" xml:space="preserve">
          <source>uninarrow</source>
          <target state="translated">uninarrow</target>
        </trans-unit>
        <trans-unit id="328bff70ae4c6a47b6b25e9441f490474af8e448" translate="yes" xml:space="preserve">
          <source>uniprops</source>
          <target state="translated">uniprops</target>
        </trans-unit>
        <trans-unit id="247380163f42421ae2d703eb8679cd83b34870e9" translate="yes" xml:space="preserve">
          <source>uniquote</source>
          <target state="translated">uniquote</target>
        </trans-unit>
        <trans-unit id="4c65113b300dbe7d18a1abac20294d929a7ffe75" translate="yes" xml:space="preserve">
          <source>unisubs</source>
          <target state="translated">unisubs</target>
        </trans-unit>
        <trans-unit id="81fb19e7a4af499b20a01cf4f84c2eb70605d5c9" translate="yes" xml:space="preserve">
          <source>unisupers</source>
          <target state="translated">unisupers</target>
        </trans-unit>
        <trans-unit id="4a58aa07cd9c7fe995d8e039ce466daabed183ad" translate="yes" xml:space="preserve">
          <source>unititle</source>
          <target state="translated">unititle</target>
        </trans-unit>
        <trans-unit id="4869ecdc8289baa1bc191dbc361750e4e3bdf4ad" translate="yes" xml:space="preserve">
          <source>uniwc</source>
          <target state="translated">uniwc</target>
        </trans-unit>
        <trans-unit id="2a82b2c6779fce7a27aa805912edf1a4e6a2a894" translate="yes" xml:space="preserve">
          <source>uniwide</source>
          <target state="translated">uniwide</target>
        </trans-unit>
        <trans-unit id="dc9206a6415e9837c874d5d503ed24b6c771aaa0" translate="yes" xml:space="preserve">
          <source>unknown methods</source>
          <target state="translated">未知方法</target>
        </trans-unit>
        <trans-unit id="42e184930956d048c819e40f18f94f0094d47bc6" translate="yes" xml:space="preserve">
          <source>unless</source>
          <target state="translated">unless</target>
        </trans-unit>
        <trans-unit id="15358cd04268c58ca1fc4bee824af0b4d7a6f722" translate="yes" xml:space="preserve">
          <source>unless its already there.</source>
          <target state="translated">除非它已经在那里。</target>
        </trans-unit>
        <trans-unit id="17ad721591ccd7748e1c7959af21fb641d063512" translate="yes" xml:space="preserve">
          <source>unless needed (metachars found).</source>
          <target state="translated">除非需要(发现元词)。</target>
        </trans-unit>
        <trans-unit id="d8416865eb0efe0f795590dee12d7f0bc0f6bdd0" translate="yes" xml:space="preserve">
          <source>unless stated otherwise.</source>
          <target state="translated">除非另有说明。</target>
        </trans-unit>
        <trans-unit id="7b91025887687e8951f32135d89cf33a54553e45" translate="yes" xml:space="preserve">
          <source>unlink</source>
          <target state="translated">unlink</target>
        </trans-unit>
        <trans-unit id="2f7ab4d1414a38eaf72b218d2bc6396a10c7c03b" translate="yes" xml:space="preserve">
          <source>unlink LIST</source>
          <target state="translated">解除链接列表</target>
        </trans-unit>
        <trans-unit id="ca9428c77b6e9175521ac643429f5441f83e1362" translate="yes" xml:space="preserve">
          <source>unlock_hash() does the opposite of lock_hash(). All keys and values are made writable. All values can be changed and keys can be added and deleted.</source>
          <target state="translated">unlock_hash()的作用与lock_hash()相反。所有的键和值都是可写的。所有的值都可以被改变,键值可以被添加和删除。</target>
        </trans-unit>
        <trans-unit id="05e5c85735ed74105bc5422998ce82f311785a5b" translate="yes" xml:space="preserve">
          <source>unlock_hash_recurse() does the opposite of lock_hash_recurse(). All keys and values are made writable. All values can be changed and keys can be added and deleted. Identical recursion restrictions apply as to lock_hash_recurse().</source>
          <target state="translated">unlock_hash_recurse()的作用与lock_hash_recurse()相反。所有的键和值都是可写的。所有的值可以被改变,键可以被添加和删除。和lock_hash_recurse()一样,同样的递归限制也适用于lock_hash_recurse()。</target>
        </trans-unit>
        <trans-unit id="15e49863432c89071dddfddf04017fe4b06da4a4" translate="yes" xml:space="preserve">
          <source>unmemoize</source>
          <target state="translated">unmemoize</target>
        </trans-unit>
        <trans-unit id="9a106745b32b1bc24d96df74906aa49ca0a5bab7" translate="yes" xml:space="preserve">
          <source>unpack</source>
          <target state="translated">unpack</target>
        </trans-unit>
        <trans-unit id="ad26ce7bca64b2cdad8c6ebcce728e4fe4dc8d68" translate="yes" xml:space="preserve">
          <source>unpack TEMPLATE</source>
          <target state="translated">解压TEMPLATE</target>
        </trans-unit>
        <trans-unit id="d51158b8ba32894fc3f16c818771c4ff1c948b25" translate="yes" xml:space="preserve">
          <source>unpack TEMPLATE,EXPR</source>
          <target state="translated">解包TEMPLATE,EXPR</target>
        </trans-unit>
        <trans-unit id="519f72fe3d89c3099ea41ae1c802c97bdc5eadc1" translate="yes" xml:space="preserve">
          <source>unsets debug mode for packages.</source>
          <target state="translated">取消设置软件包的调试模式。</target>
        </trans-unit>
        <trans-unit id="aa81750b23852766b6c1312c52c74e8e43376ec7" translate="yes" xml:space="preserve">
          <source>unshift</source>
          <target state="translated">unshift</target>
        </trans-unit>
        <trans-unit id="e7cfc09be72c471dc24ba67fa64a04d2094e0c98" translate="yes" xml:space="preserve">
          <source>unshift ARRAY,LIST</source>
          <target state="translated">unshift ARRAY,LIST</target>
        </trans-unit>
        <trans-unit id="7c2f42f7576eda73695913606951c9319ab37f8b" translate="yes" xml:space="preserve">
          <source>unshift EXPR,LIST</source>
          <target state="translated">unshift EXPR,LIST</target>
        </trans-unit>
        <trans-unit id="6960baf3f3c0a0ba2056861718b4e11ab734837d" translate="yes" xml:space="preserve">
          <source>unsigned integer, the same size as</source>
          <target state="translated">无符号的整数,大小与 &quot;无符号整数 &quot;相同。</target>
        </trans-unit>
        <trans-unit id="71a357a89ef6c8cc2c4b8fede70ba2f64a1fb87a" translate="yes" xml:space="preserve">
          <source>untaint_pattern</source>
          <target state="translated">untaint_pattern</target>
        </trans-unit>
        <trans-unit id="08257bf290350a2f8d16f85ae7fda5d81b518918" translate="yes" xml:space="preserve">
          <source>untie</source>
          <target state="translated">untie</target>
        </trans-unit>
        <trans-unit id="41ffa486976cc60b0d9967f715609a090b4a3233" translate="yes" xml:space="preserve">
          <source>untie VARIABLE</source>
          <target state="translated">松绑变量</target>
        </trans-unit>
        <trans-unit id="5615ce15b3dc9cab6781e3f31740416951c3440d" translate="yes" xml:space="preserve">
          <source>untie() is called:</source>
          <target state="translated">untie()被调用。</target>
        </trans-unit>
        <trans-unit id="b310f4d4d89b8570184b9777ad7d90fc1df20457" translate="yes" xml:space="preserve">
          <source>until</source>
          <target state="translated">until</target>
        </trans-unit>
        <trans-unit id="54cf6374a981007eef58d61195525d7f8217765c" translate="yes" xml:space="preserve">
          <source>until EOF, and appends that data to the current state. The return value is the updated object itself.</source>
          <target state="translated">直到EOF,并将该数据追加到当前状态。返回值是更新后的对象本身。</target>
        </trans-unit>
        <trans-unit id="bfcf86091d3067466bc9ffe8d93a97d5a468fb2d" translate="yes" xml:space="preserve">
          <source>until the lock goes out of scope.</source>
          <target state="translated">直到锁出范围。</target>
        </trans-unit>
        <trans-unit id="0d864558375e79b6bcd8d41b4eadfd0e190c7c45" translate="yes" xml:space="preserve">
          <source>unweaken</source>
          <target state="translated">unweaken</target>
        </trans-unit>
        <trans-unit id="49b9dec079931986840591d4efaaed3acf9eae03" translate="yes" xml:space="preserve">
          <source>unzip $input_filename_or_reference =&amp;gt; $output_filename_or_reference [, OPTS]</source>
          <target state="translated">解压缩$ input_filename_or_reference =&amp;gt; $ output_filename_or_reference [，OPTS]</target>
        </trans-unit>
        <trans-unit id="c601a15fbbc4f41d21e99b8a92db91d6e7d39d25" translate="yes" xml:space="preserve">
          <source>unzip.exe</source>
          <target state="translated">unzip.exe</target>
        </trans-unit>
        <trans-unit id="4e7d82f49845ac441224661e3cf7519a4da4777e" translate="yes" xml:space="preserve">
          <source>uotemeta,</source>
          <target state="translated">uotemeta,</target>
        </trans-unit>
        <trans-unit id="a9f314bc60e448e7fbd1dd13bce399681bb032d3" translate="yes" xml:space="preserve">
          <source>updated by the binary installer, some of them may need to be hand-edited. I know no such data, please keep me informed if you find one. Moreover, manual changes to the installed version may need to be accompanied by an edit of this file.</source>
          <target state="translated">由二进制安装程序更新,有些可能需要手工编辑。我不知道有这样的数据,如果发现有这样的数据,请及时通知我。另外,手动修改安装版本可能需要同时编辑这个文件。</target>
        </trans-unit>
        <trans-unit id="5a656fda5269af09ff3873ba74dd4de0ac85bbc1" translate="yes" xml:space="preserve">
          <source>updated the build process during the 5.19 development track.</source>
          <target state="translated">在5.19开发轨道上更新了构建过程。</target>
        </trans-unit>
        <trans-unit id="0d9974044112d7da99592fcbf7918308b2bc8a6d" translate="yes" xml:space="preserve">
          <source>upgrade [Module|/Regexp/]...</source>
          <target state="translated">升级[模块|/Regexp/]...。</target>
        </trans-unit>
        <trans-unit id="f0cdaeeecd9781d9f40d62459a27fb4ba813d0e3" translate="yes" xml:space="preserve">
          <source>upon failure.</source>
          <target state="translated">失败后。</target>
        </trans-unit>
        <trans-unit id="c538c170bdc6b0f3bb98dce44a016a2e2d45a6e7" translate="yes" xml:space="preserve">
          <source>upper</source>
          <target state="translated">upper</target>
        </trans-unit>
        <trans-unit id="81736358b1645103ae83247b10c5f82af641ddfc" translate="yes" xml:space="preserve">
          <source>url</source>
          <target state="translated">url</target>
        </trans-unit>
        <trans-unit id="4b281e89c728be235d2824fa8c4c0f6f127e3fa5" translate="yes" xml:space="preserve">
          <source>urllist parameters are URLs according to RFC 1738. We do a little guessing if your URL is not compliant, but if you have problems with &lt;code&gt;file&lt;/code&gt; URLs, please try the correct format. Either:</source>
          <target state="translated">urllist参数是符合RFC 1738的URL。如果您的URL不兼容，我们会做一些猜测，但是如果 &lt;code&gt;file&lt;/code&gt; URL 有问题，请尝试使用正确的格式。要么：</target>
        </trans-unit>
        <trans-unit id="04489a12bbaa6aebffb61ed2f524424ba8e1147e" translate="yes" xml:space="preserve">
          <source>use</source>
          <target state="translated">use</target>
        </trans-unit>
        <trans-unit id="5f81e2624a9db0b5ca4038055b053e3a8d67059d" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;&amp;amp;len&lt;/code&gt; ). If you do not care about what the length of the key is, you may use the global variable &lt;code&gt;PL_na&lt;/code&gt; , though this is rather less efficient than using a local variable. Remember though, that hash keys in perl are free to contain embedded nulls, so using &lt;code&gt;strlen()&lt;/code&gt; or similar is not a good way to find the length of hash keys. This is very similar to the &lt;code&gt;SvPV()&lt;/code&gt; macro described elsewhere in this document. See also &lt;code&gt;HeUTF8&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;&amp;amp;len&lt;/code&gt; ）。如果您不关心密钥的长度，则可以使用全局变量 &lt;code&gt;PL_na&lt;/code&gt; ，尽管效率不如使用局部变量。但是请记住，perl中的哈希键可以自由地包含嵌入的null，因此使用 &lt;code&gt;strlen()&lt;/code&gt; 或类似方法不是查找哈希键长度的好方法。这与本文档其他地方介绍的 &lt;code&gt;SvPV()&lt;/code&gt; 宏非常相似。另请参见 &lt;code&gt;HeUTF8&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
