<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="b01d04c5af24a4340d0f912c2ccf886a5fc1edcb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#exit-EXPR&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt; function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt;. If this is a problem, you can call &lt;a href=&quot;posix#_exit&quot;&gt;&lt;code&gt;POSIX::_exit($status)&lt;/code&gt;&lt;/a&gt; to avoid &lt;code&gt;END&lt;/code&gt; and destructor processing. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee540728eb307530289af963d36689ec3a1444d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#getprotobynumber-NUMBER&quot;&gt;&lt;code&gt;getprotobynumber&lt;/code&gt;&lt;/a&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a1f9e63055c82c44f33e919de1bfed56733c2d3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;last EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;last LABEL&lt;/code&gt;. The &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; block, if any, is not executed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889dc5e06ef6b79bfd7037342382aa88c842b099" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; command is like the &lt;code&gt;continue&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c37dbdd3d3faf157e953bebef6eeac7f43fa10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#oct-EXPR&quot;&gt;&lt;code&gt;oct&lt;/code&gt;&lt;/a&gt; function is commonly used when a string such as &lt;code&gt;644&lt;/code&gt; needs to be converted into a file mode, for example. Although Perl automatically converts strings into numbers as needed, this automatic conversion assumes base 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2173488a74d711836ae18ee727857a8643388af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the external protocol. Uses &lt;a href=&quot;Net::Ping::External&quot;&gt;Net::Ping::External&lt;/a&gt; to do an external ping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7c9b7850979e6e7def2184badf7bf1bc4a1d3d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the forking syn protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641eb29f28723359d8e506ee9152e1f38204dfa6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the icmp protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1957ff6c7452234943290c79fb5d121b6e83c5a4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the icmpv6 protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd013c64eb2eb70a4842cac8e8d68d7939687f1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the stream protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf91af075e5c18933e470cdffacd91d45bab2cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the syn protocol. Sends a TCP SYN packet to host specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e289226b6ef91e47994450b9dc7ca74494856a25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the tcp protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bacd7d416bf9eb142f724a00d7ab4625004301a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the udp protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be711bbef7a00d2eb13cc8d85cfba9b425e71aaf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function can be used to get all the synonyms of the bidi type name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4486da16fa0f4a006b57a0a44a17953ec38fd8dc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function can be used to get all the synonyms of the category name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce0427217e7e69e6e5a80f1afd684e23957d161" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function can be used to get all the synonyms of the combining class number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8854fb6583fec2754cd3983ea80d85f9b0022749" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the bidi type name.</source>
          <target state="translated">该&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;函数可用于获取比迪烟的类型名称的所有同义词。</target>
        </trans-unit>
        <trans-unit id="76a16bb68fd364d030e4901c8f1d916862b53339" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the category name.</source>
          <target state="translated">该&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;函数可用于获取类别名称的所有同义词。</target>
        </trans-unit>
        <trans-unit id="2277466bc19ae0c38a8069cd1ac99be48d5794e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the combining class number.</source>
          <target state="translated">该&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;函数可用于获取组合类号码的所有同义词。</target>
        </trans-unit>
        <trans-unit id="4904f3373dd8be370b7583b9b3b50ffe1a1a4b51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values%28%29&quot;&gt;&quot;prop_values()&quot;&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short bidi type names; and the second gets all the synonyms of a given bidi type name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1feb25bb50a467b88daf8d606e828a649203e2c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values%28%29&quot;&gt;&quot;prop_values()&quot;&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short category names; and the second gets all the synonyms of a given category name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d02ad47d23ca3616a65821c3a3e94a1c4a3210" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short bidi type names; and the second gets all the synonyms of a given bidi type name.</source>
          <target state="translated">所述&lt;a href=&quot;#prop_values()&quot;&gt;prop_values（）&lt;/a&gt;和&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;函数可以被用作替代该功能; 第一个返回简短的比迪烟类型名称的简单列表；第二个获取给定的比迪烟类型名称的所有同义词。</target>
        </trans-unit>
        <trans-unit id="ff1836f9843147fc775222ff3469395bcf43b303" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short category names; and the second gets all the synonyms of a given category name.</source>
          <target state="translated">所述&lt;a href=&quot;#prop_values()&quot;&gt;prop_values（）&lt;/a&gt;和&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;函数可以被用作替代该功能; 第一个返回简短类别名称的简单列表；第二个获取给定类别名称的所有同义词。</target>
        </trans-unit>
        <trans-unit id="234f248bda745adf52767c8afed6c1179ce0b206" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#redo-LABEL&quot;&gt;&lt;code&gt;redo&lt;/code&gt;&lt;/a&gt; command restarts the loop block without evaluating the conditional again. The &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;redo EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;redo LABEL&lt;/code&gt;. Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a519b9af5d08ee020d0e49465d3e607833a7248" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#search_invlist%28%29&quot;&gt;&quot;search_invlist()&quot;&lt;/a&gt; function is provided for finding a code point within an inversion list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8295b9c404465c68e21720ae88623e9c9b91d667" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist()&lt;/a&gt; function is provided for finding a code point within an inversion list.</source>
          <target state="translated">提供&lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist（）&lt;/a&gt;函数用于在反转列表中查找代码点。</target>
        </trans-unit>
        <trans-unit id="a99fc3c1e89a0b4e840a4661bca0de0880d27694" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../file/stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="translated">该&lt;a href=&quot;../file/stat&quot;&gt;文件::统计&lt;/a&gt;模块提供了便利，通过名字访问的机制：</target>
        </trans-unit>
        <trans-unit id="f74e082436b86f6a01a3f1c31662df75f43fb323" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; does not use a formal grammar because TAP is essentially a stream-based protocol. In fact, it's quite legal to have an infinite stream. For the same reason that we don't apply regexes to streams, we're not using a formal grammar here. Instead, we parse the TAP in lines.</source>
          <target state="translated">该&lt;a href=&quot;../parser&quot;&gt;TAP ::分析器&lt;/a&gt;因为自来水本质上是一种基于流的协议不使用正式的语法。实际上，拥有无限的流是很合法的。出于与我们不将正则表达式应用于流相同的原因，我们在这里没有使用正式的语法。相反，我们按行解析TAP。</target>
        </trans-unit>
        <trans-unit id="9b27238d4d5342b8376d19c0241b7f8feab19452" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section contains an example of tying handles.</source>
          <target state="translated">所述&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;部分包含捆扎把手的一个例子。</target>
        </trans-unit>
        <trans-unit id="6d31ab6a810582c2c717e2c46d057f9872d7ae58" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section uses a good example of tying scalars by associating process IDs with priority.</source>
          <target state="translated">所述&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;部使用由进程ID与优先级相关联的标量捆扎的一个很好的例子。</target>
        </trans-unit>
        <trans-unit id="ef794a4d4eb5de692a3463fa7a1780b4cded7598" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../time/gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;../time/localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the gmtime() and localtime() functions, respectively.</source>
          <target state="translated">的&lt;a href=&quot;../time/gmtime&quot;&gt;时间:: gmtime的&lt;/a&gt;和&lt;a href=&quot;../time/localtime&quot;&gt;时间::本地时间&lt;/a&gt;模块分别向gmtime的（）和localtime（）函数提供了方便，通过名的访问机制。</target>
        </trans-unit>
        <trans-unit id="7f59d8b64082e6585a0f86dcd5c37ba82d09b8aa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Algorithm::Loops&quot;&gt;Algorithm::Loops&lt;/a&gt; module also provides the &lt;code&gt;NextPermute&lt;/code&gt; and &lt;code&gt;NextPermuteNum&lt;/code&gt; functions which efficiently find all unique permutations of an array, even if it contains duplicate values, modifying it in-place: if its elements are in reverse-sorted order then the array is reversed, making it sorted, and it returns false; otherwise the next permutation is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f0381e14460ccca0ae56322db0a7c83995df5b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Array::Iterator::Circular&quot;&gt;Array::Iterator::Circular&lt;/a&gt; creates an iterator object for circular arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf4aaa34018ae1ca4bf41f4b79cdbb9a0cff285" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;B::Xref&quot;&gt;B::Xref&lt;/a&gt; module can be used to generate cross-reference reports for Perl programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f196a1609183db140dea47e36f3fc23cd9f51305" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; module on CPAN can do it for you too. Its &lt;code&gt;Dive&lt;/code&gt; subroutine can tell you not only if the keys exist but also get the value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94925a2d828e44c2072ac8bf9e5922e018a8e287" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Data::Dumper&quot;&gt;Data::Dumper&lt;/a&gt; module can pretty-print Perl data structures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5057256958429150491aec28876109720171696" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Data::Dumper&quot;&gt;Data::Dumper&lt;/a&gt; module on CPAN (or the 5.005 release of Perl) is great for printing out data structures. The &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; module on CPAN (or the 5.8 release of Perl), provides a function called &lt;code&gt;dclone&lt;/code&gt; that recursively copies its argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="061063093e9b457e789ea7dfaed817ebef3e8fa9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module provides two functions to calculate these, too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="414fad6d87355758dbe61a47fbcaa678d06818a4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt; (New York Times Profiler) does both statement and subroutine profiling. It's available from CPAN and you also invoke it with the &lt;code&gt;-d&lt;/code&gt; switch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad6fcc6ed17db5c607714adee78b91a0147dac4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; module can decode base 64-encoded email message parts transparently so the developer doesn't need to worry about it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63fa62cd04b5ec9ae734d2f288b28465a83825b7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; module, better known simply as &quot;MakeMaker&quot;, turns a Perl script, typically called &lt;code&gt;Makefile.PL&lt;/code&gt;, into a Makefile. The Unix tool &lt;code&gt;make&lt;/code&gt; uses this file to manage dependencies and actions to process and install a Perl distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a2f33574a7da40336507f2c618ec329b05bfc03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Find&quot;&gt;File::Find&lt;/a&gt; module, which comes with Perl, does all of the hard work to traverse a directory structure. It comes with Perl. You simply call the &lt;code&gt;find&lt;/code&gt; subroutine with a callback subroutine and the directories you want to traverse:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f493ee4e3ed13a3c3c25372d0b8e47b8faa82e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Find::Closures&quot;&gt;File::Find::Closures&lt;/a&gt;, which you can download from CPAN, provides many ready-to-use subroutines that you can use with &lt;a href=&quot;File::Find&quot;&gt;File::Find&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41be3e08eb17eb5dab7c9db97b667db51319891c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt; module, which you can download from CPAN, has a similar interface, but does the traversal for you too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7bd1eef5bd53ddee501c6b8d48384c043b208a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Finder&quot;&gt;File::Finder&lt;/a&gt;, which you can download from CPAN, can help you create the callback subroutine using something closer to the syntax of the &lt;code&gt;find&lt;/code&gt; command-line utility:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8b4aba1c450fd5e83e76f37c3b27a8ef91aa4e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Path&quot;&gt;File::Path&lt;/a&gt; module also has a legacy interface to the older &lt;code&gt;rmtree&lt;/code&gt; subroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6eb5ba6674a28ab9cde2b0f4fa3385630b28d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Path&quot;&gt;File::Path&lt;/a&gt; module, which comes with Perl, has a &lt;code&gt;remove_tree&lt;/code&gt; which can take care of all of the hard work for you:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785624fefaf011b1c3c4e26dff67213b765e81c8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt; module also has the advantage of setting the input record separator to a regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e7daf70cf70f962093675df7cd3c0bff0a54c56" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Spec&quot;&gt;&lt;code&gt;File::Spec&lt;/code&gt;&lt;/a&gt; modules provide methods to manipulate path specifications and return the results in native format for each platform. This is often unnecessary as Unix-style paths are understood by Perl on every supported platform, but if you need to produce native paths for a native utility that does not understand Unix syntax, or if you are operating on paths or path components in unknown (and thus possibly native) syntax, &lt;a href=&quot;File::Spec&quot;&gt;&lt;code&gt;File::Spec&lt;/code&gt;&lt;/a&gt; is your friend. Here are two brief examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b19e201b91274dc82f186817a1d33cf7babd619" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16818dfffaaf61b6c966f79b42c1f8e2b7feb79d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt; objects also have a &lt;code&gt;flush&lt;/code&gt; method. You can flush the buffer any time you want without auto-buffering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba763c04be417f13a8a4419a2a27f106dcca680" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;IO::Interactive&quot;&gt;IO::Interactive&lt;/a&gt; module does the best it can to give you an answer. Its &lt;code&gt;is_interactive&lt;/code&gt; function returns an output filehandle; that filehandle points to standard output if the module thinks the session is interactive. Otherwise, the filehandle is a null handle that simply discards the output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5994860ba25215b560ca2d61fa7577cd91572e65" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;IO::Pty&quot;&gt;IO::Pty&lt;/a&gt; and &lt;a href=&quot;expect&quot;&gt;Expect&lt;/a&gt; modules from CPAN can help with this, as they provide a real tty (well, a pseudo-tty, actually), which gets you back to line buffering in the invoked command again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ff19b2be9bd948571db368af45b45f30d772d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;IPC::Open2&quot;&gt;IPC::Open2&lt;/a&gt; module (part of the standard perl distribution) is an easy-to-use approach that internally uses &lt;code&gt;pipe()&lt;/code&gt;, &lt;code&gt;fork()&lt;/code&gt;, and &lt;code&gt;exec()&lt;/code&gt; to do the job. Make sure you read the deadlock warnings in its documentation, though (see &lt;a href=&quot;IPC::Open2&quot;&gt;IPC::Open2&lt;/a&gt;). See &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;&quot;Bidirectional Communication with Another Process&quot; in perlipc&lt;/a&gt; and &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;&quot;Bidirectional Communication with Yourself&quot; in perlipc&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bfdae92972068b982647ca50573a173382b253e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;MIME::Base64&quot;&gt;MIME::Base64&lt;/a&gt; package handles this as well as the MIME/QP encoding. Decoding base 64 becomes as simple as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81136d6431fd17ef0e4aa23b6bb0cdcdd4be5ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Net::Domain&quot;&gt;Net::Domain&lt;/a&gt; module, which is part of the Standard Library starting in Perl 5.7.3, can get you the fully qualified domain name (FQDN), the host name, or the domain name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e94a57c84c2082998da5d9e3718fef9c662bb23" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Pod::Simple::Methody&quot;&gt;Pod::Simple::Methody&lt;/a&gt; interface is event-based, similar to that of &lt;a href=&quot;HTML::Parser&quot;&gt;HTML::Parser&lt;/a&gt; or &lt;a href=&quot;XML::Parser&quot;&gt;XML::Parser&lt;/a&gt;'s &quot;Handlers&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3225637b7a30ef3b9b4ead58416b060ae1216f73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Proc::Daemon&quot;&gt;Proc::Daemon&lt;/a&gt; module, available from CPAN, provides a function to perform these actions for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570fbc1b333b95e1cacbc6d622c051543a52e083" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Sys::Hostname&quot;&gt;Sys::Hostname&lt;/a&gt; module, part of the Standard Library, can also get the hostname:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83438d62ddac1d3b0024cb20543586b81f4a2ed4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Sys::Hostname::Long&quot;&gt;Sys::Hostname::Long&lt;/a&gt; module takes a different approach and tries harder to return the fully qualified hostname:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360df13e9e42398d87ddf7c87ae270331934433d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; does not use a formal grammar because TAP is essentially a stream-based protocol. In fact, it's quite legal to have an infinite stream. For the same reason that we don't apply regexes to streams, we're not using a formal grammar here. Instead, we parse the TAP in lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5808fca337034f35682036721a9427ccd81f04" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Task::Kensho&quot;&gt;Task::Kensho&lt;/a&gt; module has a list of recommended modules which you should review as a good starting point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aafbf1ee7c517c584849dcba00f2431a29c861d9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Term::Cap&quot;&gt;Term::Cap&lt;/a&gt; module can also get the special sequence if you want to deal with the low-level details of terminal control. The &lt;code&gt;Tputs&lt;/code&gt; method returns the string for the given capability:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="000a3fd43d21166c2b39d6546fdf69078cc7d878" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN offers an easy-to-use interface that should be more efficient than shelling out to &lt;b&gt;stty&lt;/b&gt; for each key. It even includes limited support for Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e513d6d25a35bd468fa6dfadf342f7abd0a9398b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Test2::API::Context&quot;&gt;Test2::API::Context&lt;/a&gt; object, as well as all &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; types need to have access to information about where they were created. This object represents that information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e3f2d15c3d0ceb7fdd915ea6fc508fa38a5afa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Test2::Event::Pass&quot;&gt;Test2::Event::Pass&lt;/a&gt; is a specially crafted and optimized event, using this will help the performance of passing tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e3ab29916cf475d197cf70cfb13cb08a0c4ba1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; module (part of the standard distribution as of Perl 5.8) measures time with the &lt;code&gt;gettimeofday()&lt;/code&gt; system call, which returns the time in microseconds since the epoch. If you can't install &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; for older Perls and you are on a Unixish system, you may be able to call &lt;code&gt;gettimeofday(2)&lt;/code&gt; directly. See &lt;a href=&quot;perlfunc#syscall&quot;&gt;&quot;syscall&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6f85e54060d65479b4d06b632210eb849f1f0e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Time::Piece&quot;&gt;Time::Piece&lt;/a&gt; module exports a new &lt;code&gt;localtime&lt;/code&gt; that returns an object, and &lt;a href=&quot;Time::Seconds&quot;&gt;Time::Seconds&lt;/a&gt; exports the &lt;code&gt;ONE_DAY&lt;/code&gt; constant that is a set number of seconds. This means that it always gives the time 24 hours ago, which is not always yesterday. This can cause problems around the end of daylight saving time when there's one day that is 25 hours long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae8d644c0f0739788e0fe94553d172a549be62ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Time::Piece&quot;&gt;Time::Piece&lt;/a&gt; module, which comes with Perl, replaces &lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt; with a version that returns an object. It also overloads the comparison operators so you can compare them directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc9a688570f19df6de24c492632ed7647b5575b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Time::gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;Time::localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the &lt;a href=&quot;#gmtime-EXPR&quot;&gt;&lt;code&gt;gmtime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; functions, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9edd1164f7fd428ef66d1f77bb74482f07ecc4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Unicode::Tussle&quot;&gt;Unicode::Tussle&lt;/a&gt; CPAN module includes many programs to help with working with Unicode, including these programs to fully or partly replace standard utilities:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4148a12496e441ea4f3ef8053e86029175f36271" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; pragma is very smart when it comes to working with Perl's built-in functions. The behaviour for these functions are fixed, and &lt;code&gt;autodie&lt;/code&gt; knows exactly how they try to signal failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b61ff031aeab44addeeb9ed990fdd03cf707db7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;b/xref&quot;&gt;B::Xref&lt;/a&gt; module can be used to generate cross-reference reports for Perl programs.</source>
          <target state="translated">的&lt;a href=&quot;b/xref&quot;&gt;B ::外部参照&lt;/a&gt;模块可用于生成用于Perl程序交叉引用的报告。</target>
        </trans-unit>
        <trans-unit id="1c782dc05843dae452f5fa426b35990195e14641" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; module allows you to present your error messages from the caller's perspective; this gives you a way to signal a problem with the caller and not your module. For instance, if you say this:</source>
          <target state="translated">将&lt;a href=&quot;carp&quot;&gt;鲤鱼&lt;/a&gt;模块允许您从调用方的角度展示你的错误信息; 这为您提供了一种方法来表示调用者而不是模块的问题。例如，如果您这样说：</target>
        </trans-unit>
        <trans-unit id="99917712f2804784fe8d984e9caf76b36fd4b3a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; function is unsuitable for hashing large quantities of data, not least of all because you can't get the information back. Look at the &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; module for more robust algorithms.</source>
          <target state="translated">该&lt;a href=&quot;crypt&quot;&gt;墓穴&lt;/a&gt;功能不适用于散列大量并非最不重要的所有数据，因为你不能得到信息反馈。查看&lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt;模块以获取更强大的算法。</target>
        </trans-unit>
        <trans-unit id="5477977d65c206b7b8a0bfb0ffcfed2d08e7d436" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; module can pretty-print Perl data structures:</source>
          <target state="translated">该&lt;a href=&quot;data/dumper&quot;&gt;数据::自卸车&lt;/a&gt;模块可以漂亮地打印Perl数据结构：</target>
        </trans-unit>
        <trans-unit id="c389b29dcc18d72eca5cc18bef171945489bed86" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; module on CPAN (or the 5.005 release of Perl) is great for printing out data structures. The &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; module on CPAN (or the 5.8 release of Perl), provides a function called &lt;code&gt;dclone&lt;/code&gt; that recursively copies its argument.</source>
          <target state="translated">CPAN（或Perl的5.005版本）上的&lt;a href=&quot;data/dumper&quot;&gt;Data :: Dumper&lt;/a&gt;模块非常适合打印数据结构。CPAN（或Perl 5.8版本）上的&lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt;模块提供了一个名为 &lt;code&gt;dclone&lt;/code&gt; 的函数，该函数递归地复制其参数。</target>
        </trans-unit>
        <trans-unit id="3a7849edfc0302d7fe31cbb60d0e88c8f3db830b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;dbi&quot;&gt;DBI&lt;/a&gt; module provides an abstract interface to most database servers and types, including Oracle, DB2, Sybase, mysql, Postgresql, ODBC, and flat files. The DBI module accesses each database type through a database driver, or DBD. You can see a complete list of available drivers on CPAN: &lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http://www.cpan.org/modules/by-module/DBD/&lt;/a&gt; . You can read more about DBI on &lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http://dbi.perl.org/&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fb29e7cd4504f7ca3895f71c6eb9fad7707159a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; module has been deprecated since perl 5.18 and the perl internals it requires have been removed with perl 5.26.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90e864f3a759969a519520835fc4b34320f5652" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; module, better known simply as &quot;MakeMaker&quot;, turns a Perl script, typically called &lt;code&gt;Makefile.PL&lt;/code&gt; , into a Makefile. The Unix tool &lt;code&gt;make&lt;/code&gt; uses this file to manage dependencies and actions to process and install a Perl distribution.</source>
          <target state="translated">该&lt;a href=&quot;extutils/makemaker&quot;&gt;参考ExtUtils :: MakeMaker的&lt;/a&gt;模块，更好地简称为&amp;ldquo;MakeMaker的&amp;rdquo;，变成一个Perl脚本，通常称为 &lt;code&gt;Makefile.PL&lt;/code&gt; ，进入一个Makefile。Unix工具 &lt;code&gt;make&lt;/code&gt; 使用此文件来管理依赖关系和操作，以处理和安装Perl发行版。</target>
        </trans-unit>
        <trans-unit id="b36a8fb9e123f79842afcd307b1051443b42499f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt; module, which comes with Perl, does all of the hard work to traverse a directory structure. It comes with Perl. You simply call the &lt;code&gt;find&lt;/code&gt; subroutine with a callback subroutine and the directories you want to traverse:</source>
          <target state="translated">Perl附带的&lt;a href=&quot;file/find&quot;&gt;File :: Find&lt;/a&gt;模块完成了遍历目录结构的所有艰苦工作。它随Perl一起提供。您只需使用回调子例程和要遍历的目录来调用 &lt;code&gt;find&lt;/code&gt; 子例程：</target>
        </trans-unit>
        <trans-unit id="c85303530151e0f7d4bf77f032f56bce0f2d433a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module also has a legacy interface to the older &lt;code&gt;rmtree&lt;/code&gt; subroutine.</source>
          <target state="translated">该&lt;a href=&quot;file/path&quot;&gt;文件::路径&lt;/a&gt;模块还具有一个旧式接口到旧 &lt;code&gt;rmtree&lt;/code&gt; 子程序。</target>
        </trans-unit>
        <trans-unit id="2e3abc4db13d619062f522429a3b20e4ff646e91" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module, which comes with Perl, has a &lt;code&gt;remove_tree&lt;/code&gt; which can take care of all of the hard work for you:</source>
          <target state="translated">Perl随附的&lt;a href=&quot;file/path&quot;&gt;File :: Path&lt;/a&gt;模块具有 &lt;code&gt;remove_tree&lt;/code&gt; ，它可以为您处理所有辛苦的工作：</target>
        </trans-unit>
        <trans-unit id="e423ba5fb093092e153154cd61200bfa0809ecf8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="translated">该&lt;a href=&quot;file/stat&quot;&gt;文件::统计&lt;/a&gt;模块提供了便利，通过名字访问的机制：</target>
        </trans-unit>
        <trans-unit id="147153b8beaaff8771aea84e885cb82d17734d7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;findbin&quot;&gt;FindBin&lt;/a&gt; module, which comes with Perl, might work. It finds the directory of the currently running script and puts it in &lt;code&gt;$Bin&lt;/code&gt; , which you can then use to construct the right library path:</source>
          <target state="translated">Perl附带的&lt;a href=&quot;findbin&quot;&gt;FindBin&lt;/a&gt;模块可能会起作用。它找到当前正在运行的脚本的目录，并将其放入 &lt;code&gt;$Bin&lt;/code&gt; ，然后可以使用该目录构造正确的库路径：</target>
        </trans-unit>
        <trans-unit id="177b530c271fe1dca56344e28974f18250fe298e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;findbin&quot;&gt;FindBin&lt;/a&gt; module, which comes with Perl, might work. It finds the directory of the currently running script and puts it in &lt;code&gt;$Bin&lt;/code&gt;, which you can then use to construct the right library path:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6627242b752186d85aed5b69d9aaec46b0dd05af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Loops&quot;&gt;Algorithm::Loops&lt;/a&gt; module also provides the &lt;code&gt;NextPermute&lt;/code&gt; and &lt;code&gt;NextPermuteNum&lt;/code&gt; functions which efficiently find all unique permutations of an array, even if it contains duplicate values, modifying it in-place: if its elements are in reverse-sorted order then the array is reversed, making it sorted, and it returns false; otherwise the next permutation is returned.</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Loops&quot;&gt;算法::循环&lt;/a&gt;模块还提供了 &lt;code&gt;NextPermute&lt;/code&gt; 和 &lt;code&gt;NextPermuteNum&lt;/code&gt; 功能，这有效地找到一个数组的所有独特排列，即使它包含重复的值，就地修改它：如果它的元素都以相反排序的顺序，则排列被反转，使其排序，并返回false；否则，返回下一个排列。</target>
        </trans-unit>
        <trans-unit id="7f004cbac628e9968204a02264b31a3bb1043a19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Array::Iterator::Circular&quot;&gt;Array::Iterator::Circular&lt;/a&gt; creates an iterator object for circular arrays:</source>
          <target state="translated">所述&lt;a href=&quot;http://search.cpan.org/perldoc/Array::Iterator::Circular&quot;&gt;阵列::迭代::圆形&lt;/a&gt;创建圆形阵列的迭代器对象：</target>
        </trans-unit>
        <trans-unit id="a8c05beafd26231c80f038931300ac0e459427b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; module provides an abstract interface to most database servers and types, including Oracle, DB2, Sybase, mysql, Postgresql, ODBC, and flat files. The DBI module accesses each database type through a database driver, or DBD. You can see a complete list of available drivers on CPAN: &lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http://www.cpan.org/modules/by-module/DBD/&lt;/a&gt; . You can read more about DBI on &lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http://dbi.perl.org/&lt;/a&gt; .</source>
          <target state="translated">在&lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt;模块提供的抽象接口大多数数据库服务器和类型，包括Oracle，DB2中，Sybase，MySQL和PostgreSQL，ODBC和平面文件。DBI模块通过数据库驱动程序或DBD访问每种数据库类型。您可以在CPAN上看到可用驱动程序的完整列表：&lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http&lt;/a&gt; : //www.cpan.org/modules/by-module/DBD/。您可以在&lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http://dbi.perl.org/&lt;/a&gt;上阅读有关DBI的更多信息。</target>
        </trans-unit>
        <trans-unit id="d99e17e2d810ab06df1befd3ba4deffe8e1f4100" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; module on CPAN can do it for you too. Its &lt;code&gt;Dive&lt;/code&gt; subroutine can tell you not only if the keys exist but also get the value:</source>
          <target state="translated">CPAN上的&lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data :: Diver&lt;/a&gt;模块也可以为您完成此操作。它的 &lt;code&gt;Dive&lt;/code&gt; 子例程不仅可以告诉您密钥是否存在，还可以获取值：</target>
        </trans-unit>
        <trans-unit id="2f20a46404ea5d10e8ff52857742923d6a8c636c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module provides two functions to calculate these, too:</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;日期::计算器&lt;/a&gt;模块提供了两个函数来计算这些产品：</target>
        </trans-unit>
        <trans-unit id="cffc0b8a618b23964a5ae541c5cad5a91da659e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt; (New York Times Profiler) does both statement and subroutine profiling. It's available from CPAN and you also invoke it with the &lt;code&gt;-d&lt;/code&gt; switch:</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;杰韦利:: NYTProf&lt;/a&gt;（纽约时报探查）同时做两语句和子程序剖析。它可以从CPAN获得，您还可以使用 &lt;code&gt;-d&lt;/code&gt; 开关来调用它：</target>
        </trans-unit>
        <trans-unit id="36fe1514538dca6b4e14625a53ea351dc45f0bbb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; module can decode base 64-encoded email message parts transparently so the developer doesn't need to worry about it.</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;电子邮件:: MIME&lt;/a&gt;模块可以解码透明，因此开发人员无需对此担心基地64编码的电子邮件消息部分。</target>
        </trans-unit>
        <trans-unit id="5544c90428de4242a1010e3b0f0f5fbfd72933f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Closures&quot;&gt;File::Find::Closures&lt;/a&gt;, which you can download from CPAN, provides many ready-to-use subroutines that you can use with &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Closures&quot;&gt;文件::查找::闭包&lt;/a&gt;，你可以从CPAN下载，提供了很多现成的使用子程序，您可以用使用&lt;a href=&quot;file/find&quot;&gt;文件::查找&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56af297ba8a5f6d4fadfc00398e4a75a93e0389e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt; module, which you can download from CPAN, has a similar interface, but does the traversal for you too:</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;文件::查找::规则&lt;/a&gt;模块，你可以从CPAN下载，也有类似的接口，但是没有遍历对你太：</target>
        </trans-unit>
        <trans-unit id="b152dc512307ef4ac58f7c9208c20855dec936d6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Finder&quot;&gt;File::Finder&lt;/a&gt;, which you can download from CPAN, can help you create the callback subroutine using something closer to the syntax of the &lt;code&gt;find&lt;/code&gt; command-line utility:</source>
          <target state="translated">可以从CPAN下载的&lt;a href=&quot;http://search.cpan.org/perldoc/File::Finder&quot;&gt;File :: Finder&lt;/a&gt;可以帮助您使用更接近 &lt;code&gt;find&lt;/code&gt; 命令行实用程序语法的内容来创建回调子例程：</target>
        </trans-unit>
        <trans-unit id="1598869d41d1eca117a3416dff8d5309f0c6cfec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt; module also has the advantage of setting the input record separator to a regular expression.</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;文件:: ReadBackwards&lt;/a&gt;模块还具有输入记录分隔符设置为正则表达式的优势。</target>
        </trans-unit>
        <trans-unit id="91110246c66bf6d661128beb45e4417253ba4c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Interactive&quot;&gt;IO::Interactive&lt;/a&gt; module does the best it can to give you an answer. Its &lt;code&gt;is_interactive&lt;/code&gt; function returns an output filehandle; that filehandle points to standard output if the module thinks the session is interactive. Otherwise, the filehandle is a null handle that simply discards the output:</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/IO::Interactive&quot;&gt;IO ::互动&lt;/a&gt;模块做最好的它可以给你一个答案。它的 &lt;code&gt;is_interactive&lt;/code&gt; 函数返回一个输出文件句柄；如果模块认为会话是交互式的，则该文件句柄指向标准输出。否则，filehandle是一个空句柄，它仅丢弃输出：</target>
        </trans-unit>
        <trans-unit id="6b13cf53c66e0915c0e8281e749fbd4b759e7ba2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Proc::Daemon&quot;&gt;Proc::Daemon&lt;/a&gt; module, available from CPAN, provides a function to perform these actions for you.</source>
          <target state="translated">可从CPAN获得的&lt;a href=&quot;http://search.cpan.org/perldoc/Proc::Daemon&quot;&gt;Proc :: Daemon&lt;/a&gt;模块提供了为您执行这些操作的功能。</target>
        </trans-unit>
        <trans-unit id="078338e81125883115260ece46dd352b4457327c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Sys::Hostname::Long&quot;&gt;Sys::Hostname::Long&lt;/a&gt; module takes a different approach and tries harder to return the fully qualified hostname:</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/Sys::Hostname::Long&quot;&gt;Sys系统::主机名::龙&lt;/a&gt;模块采用不同的方法，并尝试更难返回完全合格的主机名：</target>
        </trans-unit>
        <trans-unit id="d7d7335f50cc47451871f0f97f15916c1b4287d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Task::Kensho&quot;&gt;Task::Kensho&lt;/a&gt; module has a list of recommended modules which you should review as a good starting point.</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/Task::Kensho&quot;&gt;任务:: Kensho计划&lt;/a&gt;模块推荐模块，你应该检讨是一个很好的出发点的列表。</target>
        </trans-unit>
        <trans-unit id="96f2822c5bca6e995fc1a0007a9363af6e5934b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN offers an easy-to-use interface that should be more efficient than shelling out to &lt;b&gt;stty&lt;/b&gt; for each key. It even includes limited support for Windows.</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;期限:: ReadKey&lt;/a&gt;从CPAN模块提供了一个易于使用的界面，应该比脱壳而出，以更有效&lt;b&gt;的stty&lt;/b&gt;每个键。它甚至包括对Windows的有限支持。</target>
        </trans-unit>
        <trans-unit id="32118c4d7f9e3bede84a1a66430b5426071bf4d3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Tussle&quot;&gt;Unicode::Tussle&lt;/a&gt; CPAN module includes many programs to help with working with Unicode, including these programs to fully or partly replace standard utilities:</source>
          <target state="translated">该&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Tussle&quot;&gt;统一::厮打&lt;/a&gt; CPAN模块包括许多方案，以帮助使用Unicode工作，其中包括这些程序完全替代或部分替代标准工具：</target>
        </trans-unit>
        <trans-unit id="919f72853738df881eb6e91400681adc998b688b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/strictures#VERSION-2&quot;&gt;strictures&lt;/a&gt; module on CPAN offers one example of a warnings subset that the module's authors believe is relatively safe to fatalize.</source>
          <target state="translated">CPAN上的&lt;a href=&quot;http://search.cpan.org/perldoc/strictures#VERSION-2&quot;&gt;狭窄&lt;/a&gt;模块提供了一个警告子集的示例，该模块的作者认为该警告子集可以相对安全地致命。</target>
        </trans-unit>
        <trans-unit id="843917bc0f80fad466bd923d5aab8d1c0906f90e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt; objects also have a &lt;code&gt;flush&lt;/code&gt; method. You can flush the buffer any time you want without auto-buffering</source>
          <target state="translated">该&lt;a href=&quot;io/handle&quot;&gt;IO ::句柄&lt;/a&gt;对象也具有 &lt;code&gt;flush&lt;/code&gt; 方法。您可以随时刷新缓冲区而无需自动缓冲</target>
        </trans-unit>
        <trans-unit id="5839e7279588dcb1c4433f17b527ae9a9d772eed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt; module (part of the standard perl distribution) is an easy-to-use approach that internally uses &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; to do the job. Make sure you read the deadlock warnings in its documentation, though (see &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt;). See &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;Bidirectional Communication with Another Process in perlipc&lt;/a&gt; and &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;Bidirectional Communication with Yourself in perlipc&lt;/a&gt;</source>
          <target state="translated">该&lt;a href=&quot;ipc/open2&quot;&gt;IPC :: Open2&lt;/a&gt;模组（标准perl的一部分）是内部使用一个易于使用的方法 &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 的，和 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 来完成这项工作。但是，请确保已阅读其文档中的死锁警告（请参阅&lt;a href=&quot;ipc/open2&quot;&gt;IPC :: Open2&lt;/a&gt;）。见&lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;双向通信与perlipc另一个进程&lt;/a&gt;和&lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;在perlipc双向通信与自己&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09e04b4b58ffa26e2662b854208dafbdb133126a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mime/base64&quot;&gt;MIME::Base64&lt;/a&gt; package handles this as well as the MIME/QP encoding. Decoding base 64 becomes as simple as:</source>
          <target state="translated">该&lt;a href=&quot;mime/base64&quot;&gt;MIME :: Base64的&lt;/a&gt;包处理此还有MIME / QP编码。解码基数64变得很简单：</target>
        </trans-unit>
        <trans-unit id="0b7108620b7e75ec5ba066fc83c0e7f6113d802f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma provides some functions for manipulating the method cache directly.</source>
          <target state="translated">在&lt;a href=&quot;mro&quot;&gt;MRO&lt;/a&gt;编译指示提供了一些功能直接操纵方法缓存。</target>
        </trans-unit>
        <trans-unit id="f076d77a637b12522b1379f81df9ca81640a9292" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;net/domain&quot;&gt;Net::Domain&lt;/a&gt; module, which is part of the Standard Library starting in Perl 5.7.3, can get you the fully qualified domain name (FQDN), the host name, or the domain name.</source>
          <target state="translated">该&lt;a href=&quot;net/domain&quot;&gt;网::域&lt;/a&gt;模块，这是标准库的一部分，在Perl 5.7.3开始，可以让你的完全限定域名（FQDN），主机名或域名。</target>
        </trans-unit>
        <trans-unit id="76dc71fd851bfecf3d4eefc768e03ef389a05460" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma affects all the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; calls after the pragma by setting default layers. If you want to affect only certain streams, use explicit layers directly in the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">在&lt;a href=&quot;open&quot;&gt;开放&lt;/a&gt;编译影响所有 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 设置默认层编译后调用。如果只想影响某些流，请在 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 调用中直接使用显式图层。</target>
        </trans-unit>
        <trans-unit id="3b5f1dd446b40bac39fbf56bdb1eee6bbfa27f8d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma affects all the &lt;code&gt;open()&lt;/code&gt; calls after the pragma by setting default layers. If you want to affect only certain streams, use explicit layers directly in the &lt;code&gt;open()&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf8373e5ee8839618cf4f3d8412574499af0964" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; module is one of several ways that Perl lets you define inheritance relationships.</source>
          <target state="translated">该&lt;a href=&quot;parent&quot;&gt;父&lt;/a&gt;模块的几种方法之一是Perl让你定义的继承关系。</target>
        </trans-unit>
        <trans-unit id="4ba42fed843fbbf72076d217b81b8e5c3f052f2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;&lt;code&gt;-C&lt;/code&gt;&lt;/a&gt; command line option can specify that certain inputs to the program are Unicode, and the values of this can be read by your Perl code, see &lt;a href=&quot;perlvar#%24%7B%5EUNICODE%7D&quot;&gt;&quot;${^UNICODE}&quot; in perlvar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0fe01583804e7c24edcd36bf4d1dc86edd7004" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C &lt;/a&gt; command line option can specify that certain inputs to the program are Unicode, and the values of this can be read by your Perl code, see &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;${^UNICODE} in perlvar&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt;命令行选项可以指定某些输入到程序都是Unicode，并在此值可以通过你的Perl代码读出，见&lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;$ {^ UNICODE}在perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc877ff3004436e21e412f3d7536c1241e3ab1bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; documentation has general advice about data security. If you are using the &lt;a href=&quot;dbi&quot;&gt;DBI&lt;/a&gt; module, use placeholder to fill in data. If you are running external programs with &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;exec&lt;/code&gt;, use the list forms. There are many other precautions that you should take, too many to list here, and most of them fall under the category of not using any data that you don't intend to use. Trust no one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd5f1da5843d43e215f1c5605c7bd2602ba3c8d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; documentation has general advice about data security. If you are using the &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; module, use placeholder to fill in data. If you are running external programs with &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, use the list forms. There are many other precautions that you should take, too many to list here, and most of them fall under the category of not using any data that you don't intend to use. Trust no one.</source>
          <target state="translated">该&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;文档中有关于数据安全的一般建议。如果使用的是&lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt;模块，请使用占位符填写数据。如果您正在使用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 运行外部程序，请使用列表形式。您还应该采取许多其他预防措施，在这里过多列出，大多数措施属于不使用任何您不打算使用的数据的类别。不要相信任何人。</target>
        </trans-unit>
        <trans-unit id="a18edb94d1038cfdd671ad02ef0a771da5913e80" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; section contains an example of tying handles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d872a7f80e3dcd2bcfe4f77e0ab218cfcf5f3d9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; section uses a good example of tying scalars by associating process IDs with priority.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e969c75d9a86d34240a9b4b0c3bacd72a35586a9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; variable and the &lt;a href=&quot;config#archname&quot;&gt;&lt;code&gt;$Config{archname}&lt;/code&gt;&lt;/a&gt; values for various DOSish perls are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3dddc8cefb2df3a4b2f380a117370ecb94e0324" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module (part of the standard Perl distribution) implements &lt;code&gt;ceil()&lt;/code&gt; , &lt;code&gt;floor()&lt;/code&gt; , and a number of other mathematical and trigonometric functions.</source>
          <target state="translated">的&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块器械（标准的Perl分布的一部分） &lt;code&gt;ceil()&lt;/code&gt; ， &lt;code&gt;floor()&lt;/code&gt; ，和许多其它的数学和三角函数。</target>
        </trans-unit>
        <trans-unit id="3cfd8963d803d863b1baabc1a6fb32761a10e916" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module (part of the standard Perl distribution) implements &lt;code&gt;ceil()&lt;/code&gt;, &lt;code&gt;floor()&lt;/code&gt;, and a number of other mathematical and trigonometric functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb81881ffc1ffa7659057b3aad0d531c1c255d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module can also format a date as the day of the year or week of the year.</source>
          <target state="translated">该&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块还可以格式化日期为今年一年或一周中的一天。</target>
        </trans-unit>
        <trans-unit id="f19febd4ca12ddc4d78578d816e9ed0531d16d0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module makes extensive use of this type.</source>
          <target state="translated">该&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块广泛使用这种类型。</target>
        </trans-unit>
        <trans-unit id="dda44e28f3e372b46a40263a9e3342beb0a11995" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix#getattr&quot;&gt;&lt;code&gt;POSIX::getattr&lt;/code&gt;&lt;/a&gt; function can do this more portably on systems purporting POSIX compliance. See also the &lt;a href=&quot;Term::ReadKey&quot;&gt;&lt;code&gt;Term::ReadKey&lt;/code&gt;&lt;/a&gt; module on CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9379f8868c28dae16be3be866b6601876aaeaba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;provide&quot;&gt;provide&lt;/a&gt; module from CPAN can be used to select one of several possible modules to load based on the version of Perl that is running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b0fd33e8403b054935aab9d8ee0ab65dd34b689" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; module to alter behaviour and aid debugging.</source>
          <target state="translated">在&lt;a href=&quot;re&quot;&gt;重新&lt;/a&gt;模块改变行为和帮助调试。</target>
        </trans-unit>
        <trans-unit id="82ec47dd24e184de112e4cf2a9605a038adc3316" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strictures#VERSION-2&quot;&gt;strictures&lt;/a&gt; module on CPAN offers one example of a warnings subset that the module's authors believe is relatively safe to fatalize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb49b0f767217eaf2addd5f51c9329970eca01df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sys/hostname&quot;&gt;Sys::Hostname&lt;/a&gt; module, part of the Standard Library, can also get the hostname:</source>
          <target state="translated">该&lt;a href=&quot;sys/hostname&quot;&gt;Sys系统::主机名&lt;/a&gt;模块，标准库的一部分，也可以得到主机名：</target>
        </trans-unit>
        <trans-unit id="220edf79ba9ff4834b00c1168d4289b47c73eb1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;term/cap&quot;&gt;Term::Cap&lt;/a&gt; module can also get the special sequence if you want to deal with the low-level details of terminal control. The &lt;code&gt;Tputs&lt;/code&gt; method returns the string for the given capability:</source>
          <target state="translated">该&lt;a href=&quot;term/cap&quot;&gt;期限::上限&lt;/a&gt;，如果你想处理终端控制的低层细节模块还可以得到特殊的序列。该 &lt;code&gt;Tputs&lt;/code&gt; 方法返回给定功能的字符串：</target>
        </trans-unit>
        <trans-unit id="e87c5439cafd856838e66bb969aac3bccda2430c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; modules are included in the core Perl distribution. Additionally, they are maintained as a separate modules on CPAN, so you can check there for any updates.</source>
          <target state="translated">的&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;和&lt;a href=&quot;threads/shared&quot;&gt;线程共享::&lt;/a&gt;模块被包含在核心Perl发行。此外，它们在CPAN上作为单独的模块维护，因此您可以在此处检查是否有任何更新。</target>
        </trans-unit>
        <trans-unit id="f6686ccb369690f0486ecaf90ca58010d28981b5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt; modules are included in the core Perl distribution. Additionally, they are maintained as a separate modules on CPAN, so you can check there for any updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9bb0674257a5140b5151993d5c3d3a37202400" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the basic functions you need to write threaded programs. In the following sections, we'll cover the basics, showing you what you need to do to create a threaded program. After that, we'll go over some of the features of the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module that make threaded programming easier.</source>
          <target state="translated">该&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;模块提供了你需要编写线程程序的基本功能。在以下各节中，我们将介绍基础知识，向您展示创建线程程序所需的操作。之后，我们将介绍&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;模块的一些功能，这些功能使线程编程更加容易。</target>
        </trans-unit>
        <trans-unit id="2a739a40945ec3475dfa2806df561fe8eb1d910a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the tools you need to create new threads. Like any other module, you need to tell Perl that you want to use it; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads;&lt;/code&gt; imports all the pieces you need to create basic threads.</source>
          <target state="translated">该&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;模块提供了你需要创建新线程的工具。像其他任何模块一样，您需要告诉Perl您要使用它。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads;&lt;/code&gt; 导入创建基本线程所需的所有片段。</target>
        </trans-unit>
        <trans-unit id="5c7c73d979dc1bd0fbebb065f801ce33de931673" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the tools you need to create new threads. Like any other module, you need to tell Perl that you want to use it; &lt;code&gt;use threads;&lt;/code&gt; imports all the pieces you need to create basic threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac95afd4b80a6c32d7d4b6fc126fc11993d69484" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;time/localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the gmtime() and localtime() functions, respectively.</source>
          <target state="translated">的&lt;a href=&quot;time/gmtime&quot;&gt;时间:: gmtime的&lt;/a&gt;和&lt;a href=&quot;time/localtime&quot;&gt;时间::本地时间&lt;/a&gt;模块分别向gmtime的（）和localtime（）函数提供了方便，通过名的访问机制。</target>
        </trans-unit>
        <trans-unit id="27e7660ba02616c82b0460251677001be2bab8d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; module (part of the standard distribution as of Perl 5.8) measures time with the &lt;code&gt;gettimeofday()&lt;/code&gt; system call, which returns the time in microseconds since the epoch. If you can't install &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; for older Perls and you are on a Unixish system, you may be able to call &lt;code&gt;gettimeofday(2)&lt;/code&gt; directly. See &lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;.</source>
          <target state="translated">的&lt;a href=&quot;time/hires&quot;&gt;时间::高分辨率&lt;/a&gt;模块测量的时间与（标准分布Perl 5.8的的一部分） &lt;code&gt;gettimeofday()&lt;/code&gt; 系统调用，因为时代它返回时间以微秒。如果您无法为较早的Perls 安装&lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt;，并且您使用的是Unixish系统，则可以直接调用 &lt;code&gt;gettimeofday(2)&lt;/code&gt; 。请参阅&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="70cd112c1d983694e459a2b5affce0b2c176b5e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module exports a new &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; that returns an object, and &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; exports the &lt;code&gt;ONE_DAY&lt;/code&gt; constant that is a set number of seconds. This means that it always gives the time 24 hours ago, which is not always yesterday. This can cause problems around the end of daylight saving time when there's one day that is 25 hours long.</source>
          <target state="translated">该&lt;a href=&quot;time/piece&quot;&gt;时间::件&lt;/a&gt;模块导出一个新的 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 返回一个对象，&lt;a href=&quot;time/seconds&quot;&gt;时间::秒&lt;/a&gt;出口 &lt;code&gt;ONE_DAY&lt;/code&gt; 常量，它是几秒钟的定数。这意味着它总是提供24小时之前的时间，而并非总是昨天。当一天的时间长达25小时时，这可能会导致夏令时结束时出现问题。</target>
        </trans-unit>
        <trans-unit id="ad7b96811e1e0447b346c7c68b0b6f49a0e303ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module, which comes with Perl, replaces &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt; with a version that returns an object. It also overloads the comparison operators so you can compare them directly:</source>
          <target state="translated">Perl随附的&lt;a href=&quot;time/piece&quot;&gt;Time :: Piece&lt;/a&gt;模块将&lt;a href=&quot;functions/localtime&quot;&gt;本地&lt;/a&gt;时间替换为返回对象的版本。它还使比较运算符过载，因此您可以直接比较它们：</target>
        </trans-unit>
        <trans-unit id="3b4c77d08ed357c92167918b7693fcf1d9ab7f90" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;universal#VERSION-%28-%5B-REQUIRE-%5D-%29&quot;&gt;default &lt;code&gt;VERSION&lt;/code&gt; method&lt;/a&gt;, inherited from the &lt;a href=&quot;universal&quot;&gt;&lt;code&gt;UNIVERSAL&lt;/code&gt;&lt;/a&gt; class, croaks if the given version is larger than the value of the variable &lt;code&gt;$Module::VERSION&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b06bcf860d30364b7b86c5e727206450a5e8ad8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module provides the most reliable way to compare version numbers in all the various ways they might be provided or might exist within modules. Given two strings containing version numbers, &lt;code&gt;$v1&lt;/code&gt; and &lt;code&gt;$v2&lt;/code&gt;, they should be converted to &lt;code&gt;version&lt;/code&gt; objects before using ordinary comparison operators. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7624d8ccf09fad70c6649ad6b1aa4fa701ecfb1c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-C&lt;/b&gt; flag controls some of the Perl Unicode features.</source>
          <target state="translated">的&lt;b&gt;-C&lt;/b&gt;标志控制部分的Perl的Unicode的功能。</target>
        </trans-unit>
        <trans-unit id="eeee1b2385aaa3798bce91466fcda51762a843eb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-C&lt;/b&gt; option only works if it is specified on the command line as well (with the same sequence of letters or numbers following). Either specify this option on the command line, or, if your system supports it, make your script executable and run it directly instead of passing it to perl.</source>
          <target state="translated">的&lt;b&gt;-C&lt;/b&gt;选项仅当在命令行上被指定它，以及（具有字母或下面的数字相同的序列）的工作原理。在命令行上指定此选项，或者，如果系统支持，则使脚本可执行并直接运行它，而不是将其传递给perl。</target>
        </trans-unit>
        <trans-unit id="adbe88919d7c337e67d217e417ae52c5e78e86cc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-DL&lt;/b&gt; command-line switch is obsolete since circa Perl 5.6.0 (it was available only if Perl was built with &lt;code&gt;-DDEBUGGING&lt;/code&gt; ). The switch was used to track Perl's memory allocations and possible memory leaks. These days the use of malloc debugging tools like</source>
          <target state="translated">的&lt;b&gt;-DL&lt;/b&gt;命令行开关是过时因为大约的Perl 5.6.0（这是仅当的Perl用内置可用 &lt;code&gt;-DDEBUGGING&lt;/code&gt; ）。该开关用于跟踪Perl的内存分配和可能的内存泄漏。这些天来使用malloc调试工具，例如</target>
        </trans-unit>
        <trans-unit id="10ff88d6a964ef244acd1861f020528cdc0021d6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-DL&lt;/b&gt; command-line switch is obsolete since circa Perl 5.6.0 (it was available only if Perl was built with &lt;code&gt;-DDEBUGGING&lt;/code&gt;). The switch was used to track Perl's memory allocations and possible memory leaks. These days the use of malloc debugging tools like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a02c2d05901d298065bac05eaefdaf89b098f1d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-a&lt;/b&gt; option followed by the name of a perl api function will extract the documentation of this function from &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;.</source>
          <target state="translated">该&lt;b&gt;-a&lt;/b&gt;选项，后跟一个Perl API函数的名称将提取此函数的文档&lt;a href=&quot;perlapi&quot;&gt;负责填实perlapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7458f799f2d3bc9e0821f8f30b793deae5a843f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-f&lt;/b&gt; option followed by the name of a perl built-in function will extract the documentation of this function from &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">该&lt;b&gt;-f&lt;/b&gt;选项，后跟内置函数一个Perl的名称将提取此函数的文档&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1902e94f8bb188d5617c0fc133e4af994267a619" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-q&lt;/b&gt; option takes a regular expression as an argument. It will search the &lt;b&gt;q&lt;/b&gt;uestion headings in perlfaq[1-9] and print the entries matching the regular expression.</source>
          <target state="translated">该&lt;b&gt;-q&lt;/b&gt;选项接受一个正则表达式作为参数。它将搜索perlfaq [1-9]中的&lt;b&gt;q&lt;/b&gt;标题，并打印与正则表达式匹配的条目。</target>
        </trans-unit>
        <trans-unit id="5344e76d29fb1384ca26893a56599519b1faad07" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-v&lt;/b&gt; option followed by the name of a Perl predefined variable will extract the documentation of this variable from &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">的&lt;b&gt;-v&lt;/b&gt;选项，后跟一个Perl的名称预定义的变量将提取从这个变量的文档&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5ae0073660f495c2b0b0a5aff71edb22c20f2cb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-verbose&lt;/b&gt; flag first prints out the &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; introduction before any other diagnostics. The $diagnostics::PRETTY variable can generate nicer escape sequences for pagers.</source>
          <target state="translated">该&lt;b&gt;-verbose&lt;/b&gt;标志首先打印出的&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;任何其他诊断之前的介绍。$ diagnostics :: PRETTY变量可以为寻呼机生成更好的转义序列。</target>
        </trans-unit>
        <trans-unit id="ceb38ecccfec93207c00c9dee183b84b32a5f056" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-w&lt;/b&gt; flag just sets the global &lt;code&gt;$^W&lt;/code&gt; variable as in 5.005. This means that any legacy code that currently relies on manipulating &lt;code&gt;$^W&lt;/code&gt; to control warning behavior will still work as is.</source>
          <target state="translated">该&lt;b&gt;-w&lt;/b&gt;标志只是设置全局 &lt;code&gt;$^W&lt;/code&gt; 变量在5.005。这意味着当前依赖于操纵 &lt;code&gt;$^W&lt;/code&gt; 来控制警告行为的任何旧版代码仍将按原样工作。</target>
        </trans-unit>
        <trans-unit id="72bbdbcc137e1ec7edde830d8069bcdc7d47c4dc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;AutoLoader&lt;/b&gt; is similar in purpose to &lt;b&gt;SelfLoader&lt;/b&gt;: both delay the loading of subroutines.</source>
          <target state="translated">该&lt;b&gt;自动装载&lt;/b&gt;在目的上类似&lt;b&gt;SelfLoader&lt;/b&gt;：两个延迟子程序的加载。</target>
        </trans-unit>
        <trans-unit id="0f53ec7201e8a617c94e28662bed3af80a664f4d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;AutoLoader&lt;/b&gt; module works with the &lt;b&gt;AutoSplit&lt;/b&gt; module and the &lt;code&gt;__END__&lt;/code&gt; token to defer the loading of some subroutines until they are used rather than loading them all at once.</source>
          <target state="translated">该&lt;b&gt;自动装入&lt;/b&gt;与模块厂&lt;b&gt;自动分割&lt;/b&gt;模块和 &lt;code&gt;__END__&lt;/code&gt; 一些子程序的令牌推迟装载，直到它们被使用，而不是装载它们的一次。</target>
        </trans-unit>
        <trans-unit id="93865b59868e970114227e97ec05c9ea3f594f39" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;ExtUtils::Embed&lt;/b&gt; kit on CPAN also contains all source code for the examples in this document, tests, additional examples and other information you may find useful.</source>
          <target state="translated">CPAN上的&lt;b&gt;ExtUtils :: Embed&lt;/b&gt;套件还包含本文档中的示例，测试，其他示例以及您认为有用的其他信息的所有源代码。</target>
        </trans-unit>
        <trans-unit id="78c68d8eddf3cc79f99821ef8cc24a0430101c54" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;IO&lt;/b&gt; extension, &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d362af90dceed3d87816d0dcbc3d699668f7c9c9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;IO&lt;/b&gt; extension, &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">在&lt;b&gt;IO&lt;/b&gt;扩展，&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;，&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I / O操作员在perlop中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4ddb503abc843b9ef214b377226c71b441a111a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Pod::Hyperlink&lt;/b&gt; class is mainly designed to parse the contents of the &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; sequence, providing a simple interface for accessing the different parts of a POD hyperlink for further processing. It can also be used to construct hyperlinks.</source>
          <target state="translated">的&lt;b&gt;波德::超链接&lt;/b&gt;类主要被设计来解析的内容 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 序列，提供用于访问超链接POD的不同部分以用于进一步处理的简单接口。它也可以用来构造超链接。</target>
        </trans-unit>
        <trans-unit id="159cbd250976e52bd0b54f9fbb2c920f60501cf2" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; can replace the AutoLoader - just change 'use AutoLoader' to 'use SelfLoader' (though note that the &lt;b&gt;SelfLoader&lt;/b&gt; exports the AUTOLOAD function - but if you have your own AUTOLOAD and are using the AutoLoader too, you probably know what you're doing), and the &lt;code&gt;__END__&lt;/code&gt; token to &lt;code&gt;__DATA__&lt;/code&gt; . You will need perl version 5.001m or later to use this (version 5.001 with all patches up to patch m).</source>
          <target state="translated">该&lt;b&gt;SelfLoader&lt;/b&gt;可以代替自动装入-只是改变&amp;ldquo;使用自动装入&amp;rdquo;到&amp;ldquo;使用SelfLoader&amp;rdquo;（但要注意的是，&lt;b&gt;SelfLoader&lt;/b&gt;出口自动加载功能-但如果你有自己的AUTOLOAD和正在使用的自动装载过多，你可能不知道你），并将 &lt;code&gt;__END__&lt;/code&gt; 令牌添加到 &lt;code&gt;__DATA__&lt;/code&gt; 。您将需要perl版本5.001m或更高版本才能使用此版本（版本5.001，所有补丁直至补丁m）。</target>
        </trans-unit>
        <trans-unit id="b4c86354fde60d804671cf8056d3c10e6c5b0099" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; can replace the AutoLoader - just change 'use AutoLoader' to 'use SelfLoader' (though note that the &lt;b&gt;SelfLoader&lt;/b&gt; exports the AUTOLOAD function - but if you have your own AUTOLOAD and are using the AutoLoader too, you probably know what you're doing), and the &lt;code&gt;__END__&lt;/code&gt; token to &lt;code&gt;__DATA__&lt;/code&gt;. You will need perl version 5.001m or later to use this (version 5.001 with all patches up to patch m).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc1e94494f4935e31dcd4aca4dd8097e05b3034" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; exports the &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine to the package using the &lt;b&gt;SelfLoader&lt;/b&gt;, and this loads the called subroutine when it is first called.</source>
          <target state="translated">该&lt;b&gt;SelfLoader&lt;/b&gt;出口的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 子程序包使用&lt;b&gt;SelfLoader&lt;/b&gt;，并且当它第一次叫这个负载调用的子程序。</target>
        </trans-unit>
        <trans-unit id="be3fad23fb52579393cf97f6d16c823542fd3d2f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; reads from wherever the current position of the &lt;code&gt;FOOBAR::DATA&lt;/code&gt; filehandle is, until the EOF or &lt;code&gt;__END__&lt;/code&gt; . This means that if you want to use that filehandle (and ONLY if you want to), you should either</source>
          <target state="translated">该&lt;b&gt;SelfLoader&lt;/b&gt;在任何地方的当前位置读取 &lt;code&gt;FOOBAR::DATA&lt;/code&gt; 文件句柄，直到EOF或 &lt;code&gt;__END__&lt;/code&gt; 。这意味着，如果您要使用该文件句柄（并且仅在需要时使用），则应该</target>
        </trans-unit>
        <trans-unit id="11f27c5dcec516e53a8a4d6fd79ba993403bc153" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; reads from wherever the current position of the &lt;code&gt;FOOBAR::DATA&lt;/code&gt; filehandle is, until the EOF or &lt;code&gt;__END__&lt;/code&gt;. This means that if you want to use that filehandle (and ONLY if you want to), you should either</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f59147d20cbbd96eaf3ce69c4654c447143a93e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will read from the FOOBAR::DATA filehandle to load in the data after &lt;code&gt;__DATA__&lt;/code&gt; , and load in any subroutine when it is called. The costs are the one-time parsing of the data after &lt;code&gt;__DATA__&lt;/code&gt; , and a load delay for the _first_ call of any autoloaded function. The benefits (hopefully) are a speeded up compilation phase, with no need to load functions which are never used.</source>
          <target state="translated">该&lt;b&gt;SelfLoader&lt;/b&gt;将从FOOBAR读:: DATA文件句柄在数据加载后 &lt;code&gt;__DATA__&lt;/code&gt; 任何子程序调用时，和负载。成本是 &lt;code&gt;__DATA__&lt;/code&gt; 之后的数据的一次性解析，以及任何自动加载函数的_first_调用的加载延迟。好处（希望是）可以加快编译阶段，而无需加载从未使用过的函数。</target>
        </trans-unit>
        <trans-unit id="661b13cb881f0c177baa79d2f9cc5c08efa1139f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will read from the FOOBAR::DATA filehandle to load in the data after &lt;code&gt;__DATA__&lt;/code&gt;, and load in any subroutine when it is called. The costs are the one-time parsing of the data after &lt;code&gt;__DATA__&lt;/code&gt;, and a load delay for the _first_ call of any autoloaded function. The benefits (hopefully) are a speeded up compilation phase, with no need to load functions which are never used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9076a846b441722c5113e39b9bcd0673ac55d99" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will stop reading from &lt;code&gt;__DATA__&lt;/code&gt; if it encounters the &lt;code&gt;__END__&lt;/code&gt; token - just as you would expect. If the &lt;code&gt;__END__&lt;/code&gt; token is present, and is followed by the token DATA, then the &lt;b&gt;SelfLoader&lt;/b&gt; leaves the FOOBAR::DATA filehandle open on the line after that token.</source>
          <target state="translated">该&lt;b&gt;SelfLoader&lt;/b&gt;将停止从阅读 &lt;code&gt;__DATA__&lt;/code&gt; 如果遇到 &lt;code&gt;__END__&lt;/code&gt; 令牌-就像你期望的那样。如果存在 &lt;code&gt;__END__&lt;/code&gt; 令牌，然后是令牌DATA，则&lt;b&gt;SelfLoader&lt;/b&gt;会将FOOBAR :: DATA文件句柄在该令牌之后的行上保持打开状态。</target>
        </trans-unit>
        <trans-unit id="ae4ca9e2af773bc53d6ebfbbbcbbb68e0e663b29" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works by the user placing the &lt;code&gt;__DATA__&lt;/code&gt; token</source>
          <target state="translated">该&lt;b&gt;SelfLoader&lt;/b&gt;作品被用户放置 &lt;code&gt;__DATA__&lt;/code&gt; 令牌</target>
        </trans-unit>
        <trans-unit id="b8a45570c1acb4c43b6a7805f6337844a9606503" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works similarly to the AutoLoader, but picks up the subs from after the &lt;code&gt;__DATA__&lt;/code&gt; instead of in the 'lib/auto' directory. There is a maintenance gain in not needing to run AutoSplit on the module at installation, and a runtime gain in not needing to keep opening and closing files to load subs. There is a runtime loss in needing to parse the code after the &lt;code&gt;__DATA__&lt;/code&gt; . Details of the &lt;b&gt;AutoLoader&lt;/b&gt; and another view of these distinctions can be found in that module's documentation.</source>
          <target state="translated">该&lt;b&gt;SelfLoader&lt;/b&gt;的工作方式类似于自动加载器，但拾起从后潜艇 &lt;code&gt;__DATA__&lt;/code&gt; 而不是在&amp;ldquo;LIB /自动&amp;rdquo;目录。在维护过程中，无需在模块上运行AutoSplit会带来维护方面的收益，而无需保持打开和关闭文件来加载sub的运行时方面的收益。需要解析 &lt;code&gt;__DATA__&lt;/code&gt; 之后的代码会导致运行时丢失。可在该模块的文档中找到&lt;b&gt;AutoLoader的&lt;/b&gt;详细信息以及这些区别的另一种视图。</target>
        </trans-unit>
        <trans-unit id="7dcbf6c27d3fbecf0a1da02dbc8cbd5d7c319816" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works similarly to the AutoLoader, but picks up the subs from after the &lt;code&gt;__DATA__&lt;/code&gt; instead of in the 'lib/auto' directory. There is a maintenance gain in not needing to run AutoSplit on the module at installation, and a runtime gain in not needing to keep opening and closing files to load subs. There is a runtime loss in needing to parse the code after the &lt;code&gt;__DATA__&lt;/code&gt;. Details of the &lt;b&gt;AutoLoader&lt;/b&gt; and another view of these distinctions can be found in that module's documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94dafc36f54a138d4c7c8beed77372c0b7d94298" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::Array&lt;/b&gt; implementation is a stub that simply croaks.</source>
          <target state="translated">该&lt;b&gt;领带::阵列&lt;/b&gt;的实现方式是简单地嘎嘎叫着存根。</target>
        </trans-unit>
        <trans-unit id="6b199766c781a0ae9ebeafd1ad9efb33847e8a69" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::Hash&lt;/b&gt; implementation is a stub that simply croaks.</source>
          <target state="translated">该&lt;b&gt;帖::哈希&lt;/b&gt;实现是简单地嘎嘎叫着存根。</target>
        </trans-unit>
        <trans-unit id="4134fa729bc36043c1bbc4226f0d69bd4bd166dc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdArray&lt;/b&gt; package provides efficient methods required for tied arrays which are implemented as blessed references to an &quot;inner&quot; perl array. It inherits from &lt;b&gt;Tie::Array&lt;/b&gt;, and should cause tied arrays to behave exactly like standard arrays, allowing for selective overloading of methods.</source>
          <target state="translated">所述&lt;b&gt;领带:: StdArray&lt;/b&gt;包提供用于其被实现为一个&amp;ldquo;内部&amp;rdquo;的perl阵列福地引用绑阵列所需的有效的方法。它继承自&lt;b&gt;Tie :: Array&lt;/b&gt;，并应使绑定数组的行为与标准数组完全相同，从而允许方法的选择性重载。</target>
        </trans-unit>
        <trans-unit id="61ae2de46d00875a51e425357ad71e5ccdd2ad38" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdHandle&lt;/b&gt; package provide most methods for file handles described in &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; (the exceptions are &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; ). It causes tied file handles to behave exactly like standard file handles and allow for selective overwriting of methods.</source>
          <target state="translated">该&lt;b&gt;帖:: StdHandle&lt;/b&gt;包提供了所描述的文件句柄大多数方法&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;（例外是 &lt;code&gt;UNTIE&lt;/code&gt; 和 &lt;code&gt;DESTROY&lt;/code&gt; ）。它使绑定的文件句柄的行为与标准文件句柄完全相同，并允许方法的选择性覆盖。</target>
        </trans-unit>
        <trans-unit id="4245a18625b67300aa61449aa8288d150f2262ee" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdHandle&lt;/b&gt; package provide most methods for file handles described in &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; (the exceptions are &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt;). It causes tied file handles to behave exactly like standard file handles and allow for selective overwriting of methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eacf0e41a2a5258a61ae34656b72764dd7acc141" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::SubstrHash&lt;/b&gt; package provides a hash-table-like interface to an array of determinate size, with constant key size and record size.</source>
          <target state="translated">所述&lt;b&gt;领带:: SubstrHash&lt;/b&gt;包提供一个哈希表类似的接口来确定的尺寸的阵列，具有恒定的密钥大小和记录大小。</target>
        </trans-unit>
        <trans-unit id="a8a3a1e60f743e1378ee92d392f9857036d4b3d2" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;begincheck&lt;/b&gt; program makes it all clear, eventually:</source>
          <target state="translated">该&lt;b&gt;begincheck&lt;/b&gt;程序让这一切清楚，最终：</target>
        </trans-unit>
        <trans-unit id="1112db1b82f4fc99681fd70d53f56d13ced227cf" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma changes this to use the specified encoding instead. For example:</source>
          <target state="translated">该&lt;b&gt;编码&lt;/b&gt;编译改变了这种使用指定的编码来代替。例如：</target>
        </trans-unit>
        <trans-unit id="b7162377ab2247a065b27f7ed4e48c5d078da511" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma works by decoding string literals in &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; and so forth. In perl v5.8.0, this does not apply to &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. Therefore,</source>
          <target state="translated">该&lt;b&gt;编码&lt;/b&gt;编译的工作原理是在解码字符串字面量 &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; 等等。在perl v5.8.0中，这不适用于 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 。因此，</target>
        </trans-unit>
        <trans-unit id="0567b6469c4f0ce811f82d15382d41c3cb9254e1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma works by decoding string literals in &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; and so forth. In perl v5.8.0, this does not apply to &lt;code&gt;tr///&lt;/code&gt;. Therefore,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80faef413c7207aab71b9f1d03988df6331ef791" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;file&lt;/b&gt; (or &lt;b&gt;string&lt;/b&gt;, in the case of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;) that is currently being &lt;b&gt;compiled&lt;/b&gt;.</source>
          <target state="translated">当前正在&lt;b&gt;编译&lt;/b&gt;的&lt;b&gt;文件&lt;/b&gt;（如果为 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，则为&lt;b&gt;字符串&lt;/b&gt;）。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b93fec3ba5d429ebcf5cae82011aef3ec4a01036" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;file&lt;/b&gt; (or &lt;b&gt;string&lt;/b&gt;, in the case of &lt;code&gt;eval&lt;/code&gt;) that is currently being &lt;b&gt;compiled&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5cf33051195df3d457e45e85209f2138dc4a05" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;first time&lt;/b&gt; the hook is hit in a serialization flow, you may have it return an empty list. That will signal the Storable engine to further discard that hook for this class and to therefore revert to the default serialization of the underlying Perl data. The hook will again be normally processed in the next serialization.</source>
          <target state="translated">在&lt;b&gt;第一次&lt;/b&gt;钩在一个序列化流击中，你可能有它返回一个空列表。这将指示Storable引擎进一步丢弃该类的该挂钩，并因此恢复为基础Perl数据的默认序列化。该挂钩将在下一个序列化中再次正常处理。</target>
        </trans-unit>
        <trans-unit id="31b896e0d53803b62960180dd945e43dfa7f81e7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;garbage collection&lt;/b&gt; of globals (and the running of any associated object destructors) that takes place when a Perl &lt;b&gt;interpreter&lt;/b&gt; is being shut down. Global destruction should not be confused with the Apocalypse, except perhaps when it should.</source>
          <target state="translated">当关闭Perl &lt;b&gt;解释器&lt;/b&gt;时，将进行全局变量的&lt;b&gt;垃圾回收&lt;/b&gt;（以及所有相关对象析构函数的运行）。全球毁灭不应该与世界末日相混淆，除非应该这样做。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="987526f88e29534e7fb822b3987e499066378921" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;grouping&lt;/b&gt; metacharacters &lt;code&gt;()&lt;/code&gt; allow a part of a regex to be treated as a single unit. Parts of a regex are grouped by enclosing them in parentheses. The regex &lt;code&gt;house(cat|keeper)&lt;/code&gt; means match &lt;code&gt;house&lt;/code&gt; followed by either &lt;code&gt;cat&lt;/code&gt; or &lt;code&gt;keeper&lt;/code&gt; . Some more examples are</source>
          <target state="translated">的&lt;b&gt;分组&lt;/b&gt;元字符 &lt;code&gt;()&lt;/code&gt; 允许一个正则表达式的一部分被视为单一的单元。正则表达式的部分通过将其括在圆括号中进行分组。regex &lt;code&gt;house(cat|keeper)&lt;/code&gt; 表示比赛 &lt;code&gt;house&lt;/code&gt; 后跟 &lt;code&gt;cat&lt;/code&gt; 或 &lt;code&gt;keeper&lt;/code&gt; 。还有更多的例子是</target>
        </trans-unit>
        <trans-unit id="8b06519ab9371f66acf34ade00457226ccfb28ee" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;grouping&lt;/b&gt; metacharacters &lt;code&gt;()&lt;/code&gt; allow a part of a regex to be treated as a single unit. Parts of a regex are grouped by enclosing them in parentheses. The regex &lt;code&gt;house(cat|keeper)&lt;/code&gt; means match &lt;code&gt;house&lt;/code&gt; followed by either &lt;code&gt;cat&lt;/code&gt; or &lt;code&gt;keeper&lt;/code&gt;. Some more examples are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba87bd98015a685039202791b8b4c178941ed0ba" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;interpolation&lt;/b&gt; of a scalar or array variable into a string.</source>
          <target state="translated">的&lt;b&gt;内插&lt;/b&gt;标量或数组变量为一个字符串。</target>
        </trans-unit>
        <trans-unit id="fd9fd954815d11416f915389911ed3472be1a48a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;new()&lt;/b&gt; method can either be passed a set of key/value pairs or a single scalar value, namely the contents of a &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; sequence. An object of the class &lt;code&gt;Pod::Hyperlink&lt;/code&gt; is returned. The value &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; indicates a failure, the error message is stored in &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">的&lt;b&gt;新的（）&lt;/b&gt;方法既可以通过了一组键/值对或单个标量值，一个即内容 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 序列。返回 &lt;code&gt;Pod::Hyperlink&lt;/code&gt; 类的对象。值 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 表示失败，错误消息存储在 &lt;code&gt;$@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22dcd0ec3aed7a2c1842ef98e2374e061c59b868" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;package&lt;/b&gt; in which the current statement is &lt;b&gt;compiled&lt;/b&gt;. Scan backward in the text of your program through the current &lt;b&gt;lexical scope&lt;/b&gt; or any enclosing lexical scopes until you find a package declaration. That&amp;rsquo;s your current package name.</source>
          <target state="translated">在其中&lt;b&gt;编译&lt;/b&gt;当前语句的&lt;b&gt;包&lt;/b&gt;。通过当前&lt;b&gt;词法范围&lt;/b&gt;或任何封闭的词法范围在程序文本中向后扫描，直到找到包声明为止。那是您当前的包裹名称。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="837534d7853b1df8d6be64303da76d4fb655fe6c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parse_text()&lt;/b&gt; method takes a given paragraph of text, and returns a parse-tree that contains one or more children, each of which may be a text-string, or an InteriorSequence object. There are also callback-options that may be passed to &lt;b&gt;parse_text()&lt;/b&gt; to customize the way it expands or transforms interior-sequences, as well as the returned result. These callbacks can be used to create a parse-tree with custom-made objects (which may or may not support the parse-tree interface, depending on how you choose to do it).</source>
          <target state="translated">所述&lt;b&gt;parse_Text在（）&lt;/b&gt;方法采用文本的给定段，并返回一个解析树，包含一个或多个孩子，其中的每一个可以是文本串，或一个InteriorSequence对象。也可以将回调选项传递给&lt;b&gt;parse_text（），&lt;/b&gt;以自定义其扩展或转换内部序列以及返回结果的方式。这些回调可用于创建带有自定义对象的解析树（根据您选择的方式，该对象可能支持也可能不支持解析树接口）。</target>
        </trans-unit>
        <trans-unit id="b2fcda0a32417727cdd721f28d0c908b93bc1f19" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;perlivp&lt;/b&gt; program is set up at Perl source code build time to test the Perl version it was built under. It can be used after running:</source>
          <target state="translated">该&lt;b&gt;perlivp&lt;/b&gt;程序设置在Perl的源代码编译时间来测试Perl版本它是下建造的。可以在运行后使用：</target>
        </trans-unit>
        <trans-unit id="dc37ad02e0c6923bebd0d4430ccd02307461404f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;podchecker&lt;/b&gt; command is provided for checking Pod syntax for errors and warnings. For example, it checks for completely blank lines in Pod blocks and for unknown commands and formatting codes. You should still also pass your document through one or more translators and proofread the result, or print out the result and proofread that. Some of the problems found may be bugs in the translators, which you may or may not wish to work around.</source>
          <target state="translated">该&lt;b&gt;podchecker&lt;/b&gt;命令用于检查错误和警告波德语法。例如，它检查Pod块中的完全空白行以及未知的命令和格式代码。您还应该通过一个或多个翻译人员传递文档并校对结果，或打印结果并进行校对。发现的一些问题可能是翻译程序中的错误，您可能希望也可能不希望解决。</target>
        </trans-unit>
        <trans-unit id="0a20174d8e3b5a76e2734d6eb6a0cf7707e14ad1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;podchecker&lt;/b&gt; script that comes with this distribution is a lean wrapper around this module. See the online manual with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d299b97d8bab37b1330370eb9473b8a413d005a5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;quantifier&lt;/b&gt; metacharacters &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , and &lt;code&gt;{}&lt;/code&gt; allow us to determine the number of repeats of a portion of a regex we consider to be a match. Quantifiers are put immediately after the character, character class, or grouping that we want to specify. They have the following meanings:</source>
          <target state="translated">该&lt;b&gt;量词&lt;/b&gt;元字符 &lt;code&gt;?&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;{}&lt;/code&gt; 允许我们确定被视为匹配项的正则表达式的一部分重复的次数。量词紧跟在我们要指定的字符，字符类或分组之后。它们具有以下含义：</target>
        </trans-unit>
        <trans-unit id="eaae51c09e62ae41b20067864a8beaa2340f2425" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;quantifier&lt;/b&gt; metacharacters &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt; allow us to determine the number of repeats of a portion of a regex we consider to be a match. Quantifiers are put immediately after the character, character class, or grouping that we want to specify. They have the following meanings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b54e7f659f70ec7a4f3708e917b8834ab10ef21" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;scalar values&lt;/b&gt; that you supply to a &lt;b&gt;function&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt; when you call it. For instance, when you call &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt; , the string &lt;code&gt;&quot;puff&quot;&lt;/code&gt; is the actual argument. See also &lt;b&gt;argument&lt;/b&gt; and &lt;b&gt;formal arguments&lt;/b&gt;.</source>
          <target state="translated">调用&lt;b&gt;函数&lt;/b&gt;或&lt;b&gt;子例程&lt;/b&gt;时提供的&lt;b&gt;标量值&lt;/b&gt;。例如，当您调用 &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt; ，字符串 &lt;code&gt;&quot;puff&quot;&lt;/code&gt; 是实际参数。另请参见&lt;b&gt;论证&lt;/b&gt;和&lt;b&gt;形式论证&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="322845e84e15f9ba6a6f987f2f0f5a926b87542a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;scalar values&lt;/b&gt; that you supply to a &lt;b&gt;function&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt; when you call it. For instance, when you call &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt;, the string &lt;code&gt;&quot;puff&quot;&lt;/code&gt; is the actual argument. See also &lt;b&gt;argument&lt;/b&gt; and &lt;b&gt;formal arguments&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a023f0632e523744570838f6670cc7a9e367c0e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sigtrap&lt;/b&gt; pragma is a simple interface to installing signal handlers. You can have it install one of two handlers supplied by &lt;b&gt;sigtrap&lt;/b&gt; itself (one which provides a Perl stack trace and one which simply &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;s), or alternately you can supply your own handler for it to install. It can be told only to install a handler for signals which are either untrapped or ignored. It has a couple of lists of signals to trap, plus you can supply your own list of signals.</source>
          <target state="translated">该&lt;b&gt;SIGTRAP&lt;/b&gt;编译是一个简单的界面，安装信号处理程序。您可以让它安装&lt;b&gt;sigtrap&lt;/b&gt;本身提供的两个处理程序之一（一个提供Perl堆栈跟踪，另一个简单地 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; ），或者您也可以提供自己的处理程序以进行安装。只能告诉您为未捕获或忽略的信号安装处理程序。它有几个要捕获的信号列表，此外，您还可以提供自己的信号列表。</target>
        </trans-unit>
        <trans-unit id="9bf9f6bd9139c0d963b36b36175d399537dfc4fb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sigtrap&lt;/b&gt; pragma is a simple interface to installing signal handlers. You can have it install one of two handlers supplied by &lt;b&gt;sigtrap&lt;/b&gt; itself (one which provides a Perl stack trace and one which simply &lt;code&gt;die()&lt;/code&gt;s), or alternately you can supply your own handler for it to install. It can be told only to install a handler for signals which are either untrapped or ignored. It has a couple of lists of signals to trap, plus you can supply your own list of signals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7c162ba3d4340b1ed67afae232423e0f505fd2b" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; produced by a &lt;b&gt;subroutine&lt;/b&gt; or &lt;b&gt;expression&lt;/b&gt; when evaluated. In Perl, a return value may be either a &lt;b&gt;list&lt;/b&gt; or a &lt;b&gt;scalar&lt;/b&gt;.</source>
          <target state="translated">的&lt;b&gt;值&lt;/b&gt;产生由一个&lt;b&gt;子程序&lt;/b&gt;或&lt;b&gt;表达&lt;/b&gt;进行评估时。在Perl中，返回值可以是&lt;b&gt;list&lt;/b&gt;或&lt;b&gt;scalar&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="7487920171bd7708f5f44fcbcd3a51b3cd669ff9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; returned to the parent &lt;b&gt;process&lt;/b&gt; when one of its child processes dies. This value is placed in the special variable &lt;code&gt;$?&lt;/code&gt; . Its upper eight &lt;b&gt;bits&lt;/b&gt; are the exit status of the defunct process, and its lower eight bits identify the signal (if any) that the process died from. On Unix systems, this status value is the same as the status word returned by</source>
          <target state="translated">该&lt;b&gt;值&lt;/b&gt;在其子进程之一死亡时返回给父&lt;b&gt;进程&lt;/b&gt;。此值放在特殊变量 &lt;code&gt;$?&lt;/code&gt; 中。。它的高八位&lt;b&gt;位&lt;/b&gt;是死进程的退出状态，而其低八位识别信号（如果有的话）的过程中经抢救无效死亡。在Unix系统上，此状态值与的返回值相同</target>
        </trans-unit>
        <trans-unit id="92fc59668896181422dc0c709aa06976d25a8bdd" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; returned to the parent &lt;b&gt;process&lt;/b&gt; when one of its child processes dies. This value is placed in the special variable &lt;code&gt;$?&lt;/code&gt;. Its upper eight &lt;b&gt;bits&lt;/b&gt; are the exit status of the defunct process, and its lower eight bits identify the signal (if any) that the process died from. On Unix systems, this status value is the same as the status word returned by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75f87bdfa0eb35c4f5fe0a1642de1f3532d7289" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;values&lt;/b&gt; you supply along with a program name when you tell a &lt;b&gt;shell&lt;/b&gt; to execute a &lt;b&gt;command&lt;/b&gt;. These values are passed to a Perl program through &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">当您告诉&lt;b&gt;外壳&lt;/b&gt;程序执行&lt;b&gt;命令&lt;/b&gt;时，您提供的&lt;b&gt;值&lt;/b&gt;以及程序名称。这些值通过 &lt;code&gt;@ARGV&lt;/code&gt; 传递给Perl程序。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="41ad86c2a0eef157efad4b1818e0188a3bba4d01" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;values&lt;/b&gt; you supply along with a program name when you tell a &lt;b&gt;shell&lt;/b&gt; to execute a &lt;b&gt;command&lt;/b&gt;. These values are passed to a Perl program through &lt;code&gt;@ARGV&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8215a7b783f151c4ff06cfd84ff859eb48442e77" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;word anchor&lt;/b&gt;&lt;code&gt;\b&lt;/code&gt; matches a boundary between a word character and a non-word character &lt;code&gt;\w\W&lt;/code&gt; or &lt;code&gt;\W\w&lt;/code&gt; :</source>
          <target state="translated">所述&lt;b&gt;字锚&lt;/b&gt; &lt;code&gt;\b&lt;/code&gt; 单词字符和非字符字之间的边界匹配 &lt;code&gt;\w\W&lt;/code&gt; 或 &lt;code&gt;\W\w&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e0d33c43c6614d46185d88549fdc18a2c8537ffc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;word anchor&lt;/b&gt;&lt;code&gt;\b&lt;/code&gt; matches a boundary between a word character and a non-word character &lt;code&gt;\w\W&lt;/code&gt; or &lt;code&gt;\W\w&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98df2a206a33c61c05323edbf28b990dfe8bb9b6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;xsubpp&lt;/b&gt; program takes the XS code in the .xs file and translates it into C code, placing it in a file whose suffix is .c. The C code created makes heavy use of the C functions within Perl.</source>
          <target state="translated">该&lt;b&gt;xsubpp&lt;/b&gt;程序取入.xs文件中的XS代码并将其转换成C代码，将其放置在其后缀是.c的一个文件。创建的C代码大量使用了Perl中的C函数。</target>
        </trans-unit>
        <trans-unit id="e9db711485ba959f3d0b453c931365b6638809a5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;xsubpp&lt;/b&gt; program uses rules to convert from Perl's data types (scalar, array, etc.) to C's data types (int, char, etc.). These rules are stored in the typemap file ($PERLLIB/ExtUtils/typemap). There's a brief discussion below, but all the nitty-gritty details can be found in &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;. If you have a new-enough version of perl (5.16 and up) or an upgraded XS compiler (&lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 3.13_01 or better), then you can inline typemaps in your XS instead of writing separate files. Either way, this typemap thing is split into three parts:</source>
          <target state="translated">该&lt;b&gt;xsubpp&lt;/b&gt;程序使用规则来转换从Perl的数据类型（标量，阵列等）至C的数据类型（int，焦炭等）。这些规则存储在类型映射文件（$ PERLLIB / ExtUtils / typemap）中。下面有一个简短的讨论，但是所有的细节都可以在&lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap中&lt;/a&gt;找到。如果您有新版本的perl（5.16及更高版本）或升级的XS编译器（ &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 3.13_01或更高版本），则可以在XS中内联类型映射，而不必编写单独的文件。无论哪种方式，此类型映射都分为三个部分：</target>
        </trans-unit>
        <trans-unit id="1082cc04157e373604ca98ab1606eeb58e2bd5d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt; $output &lt;/code&gt; argument may be:</source>
          <target state="translated">该 &lt;code&gt; $output &lt;/code&gt; 参数可以是：</target>
        </trans-unit>
        <trans-unit id="fe02d79593918e0f0b57f9efa92b9388e3573b1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;)&quot;&lt;/code&gt; is out-of-place. Something apparently was supposed to be combined with the digits, or the &lt;code&gt;&quot;+&quot;&lt;/code&gt; shouldn't be there, or something like that. Perl can't figure out what was intended.</source>
          <target state="translated">该 &lt;code&gt;&quot;)&quot;&lt;/code&gt; 是外的地方。显然应该将某些内容与数字结合在一起，或者不应该在其中加上 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 类的东西。Perl无法弄清楚它的意图。</target>
        </trans-unit>
        <trans-unit id="b82e89101d474c0486e6c08a915553c14b105df6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;*&quot;&lt;/code&gt; quantifier is equivalent to &lt;code&gt;{0,}&lt;/code&gt;, the &lt;code&gt;&quot;+&quot;&lt;/code&gt; quantifier to &lt;code&gt;{1,}&lt;/code&gt;, and the &lt;code&gt;&quot;?&quot;&lt;/code&gt; quantifier to &lt;code&gt;{0,1}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74bbd851b5114dd4dbacbd6abc257c5bbd630765" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;+&quot;&lt;/code&gt; is valid only when followed by digits, indicating a capturing group. See &lt;a href=&quot;perlre#%28%3FPARNO%29-%28%3F-PARNO%29-%28%3F%2BPARNO%29-%28%3FR%29-%28%3F0%29&quot;&gt;&lt;code&gt;(?&lt;i&gt;PARNO&lt;/i&gt;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54034a923125cadab60eef06f26fcb91d4e7c351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;+&quot;&lt;/code&gt; is valid only when followed by digits, indicating a capturing group. See &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(?PARNO)&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;&quot;+&quot;&lt;/code&gt; ，随后的数字时，才指示捕获组是有效的。参见&lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;（？PARNO）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07bb712ac114a7fe219229eb5a67b484b3ca58ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;?&quot;&lt;/code&gt; and &lt;code&gt;&quot;+&quot;&lt;/code&gt; don't have any effect, as they modify whether to match more or fewer when there is a choice, and by specifying to match exactly a given numer, there is no room left for a choice.</source>
          <target state="translated">在 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 没有任何作用，因为它们会在选择时修改是匹配还是多或少，并且通过指定精确匹配给定的数字，就没有选择余地。</target>
        </trans-unit>
        <trans-unit id="622f5262d7227133a18718033006d1fe595c3150" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;U&quot;&lt;/code&gt; template has been ported to mean &quot;Unicode&quot; on all platforms so that</source>
          <target state="translated">在所有平台上， &lt;code&gt;&quot;U&quot;&lt;/code&gt; 模板已被移植为&amp;ldquo; Unicode&amp;rdquo;，因此</target>
        </trans-unit>
        <trans-unit id="d9a4c62629e10d33b540e16fc1ce8f7a3f41635f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;\x&quot;&lt;/code&gt; construct without curly braces should be followed by exactly two hex digits; this one is followed by three. This currently evaluates as equivalent to</source>
          <target state="translated">不带花括号的 &lt;code&gt;&quot;\x&quot;&lt;/code&gt; 结构后面应紧跟两个十六进制数字。接下来是三个。目前，这相当于</target>
        </trans-unit>
        <trans-unit id="18a8e19a030c3c8f53e48396122990cc28295c5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;a&quot;&lt;/code&gt; is a valid modifier flag, but the &lt;code&gt;&quot;n&quot;&lt;/code&gt; is not, and raises this error. Likely what was meant instead was:</source>
          <target state="translated">在 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 是一个有效的修改标志，但 &lt;code&gt;&quot;n&quot;&lt;/code&gt; 是不是，并提出了这个错误。相反，可能的意思是：</target>
        </trans-unit>
        <trans-unit id="14e2e8dae7c922be26733e3e660b25612cc5ce26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;c&quot;&lt;/code&gt; and &lt;code&gt;&quot;C&quot;&lt;/code&gt; templates for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; are dependent upon character set encoding. Examples of usage on EBCDIC include:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&quot;c&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 模板取决于字符集编码。EBCDIC上的用法示例包括：</target>
        </trans-unit>
        <trans-unit id="3a90b3cf3b7660a315d348d508a144827f3fa53e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;c&quot;&lt;/code&gt; and &lt;code&gt;&quot;C&quot;&lt;/code&gt; templates for &lt;code&gt;pack()&lt;/code&gt; are dependent upon character set encoding. Examples of usage on EBCDIC include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c8f5308cfb898e8f57b9a7b021b28f517778138" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;code&quot;&lt;/code&gt; subroutine will only be used to filter parts of the source code that are not quotelikes, POD, or &lt;code&gt;__DATA__&lt;/code&gt; . The &lt;code&gt;quotelike&lt;/code&gt; subroutine only filters Perl quotelikes (including here documents).</source>
          <target state="translated">的 &lt;code&gt;&quot;code&quot;&lt;/code&gt; 子程序将仅被用于将源代码，不quotelikes，POD，或过滤器部件 &lt;code&gt;__DATA__&lt;/code&gt; 。该 &lt;code&gt;quotelike&lt;/code&gt; 子程序仅过滤的Perl quotelikes（这里包括文档）。</target>
        </trans-unit>
        <trans-unit id="00d33c98d86ed179e5a669f2bc40830325b6bdf3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;code&quot;&lt;/code&gt; subroutine will only be used to filter parts of the source code that are not quotelikes, POD, or &lt;code&gt;__DATA__&lt;/code&gt;. The &lt;code&gt;quotelike&lt;/code&gt; subroutine only filters Perl quotelikes (including here documents).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5cb8ed1d57c1871e5453eb580a0076b635dfd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; pragma</source>
          <target state="translated">在 &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; 编译</target>
        </trans-unit>
        <trans-unit id="9e55a545076df6df5f2e5f8da5ca2fba9b8a556b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#!&lt;/code&gt; line is always examined for switches as the line is being parsed. Thus, if you're on a machine that allows only one argument with the &lt;code&gt;#!&lt;/code&gt; line, or worse, doesn't even recognize the &lt;code&gt;#!&lt;/code&gt; line, you still can get consistent switch behaviour regardless of how Perl was invoked, even if &lt;a href=&quot;#-x&quot;&gt;&quot;-x&quot;&lt;/a&gt; was used to find the beginning of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5361c21bc61e8999f4b7544ffeef33e12b0b1a2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#!&lt;/code&gt; line is always examined for switches as the line is being parsed. Thus, if you're on a machine that allows only one argument with the &lt;code&gt;#!&lt;/code&gt; line, or worse, doesn't even recognize the &lt;code&gt;#!&lt;/code&gt; line, you still can get consistent switch behaviour regardless of how Perl was invoked, even if &lt;b&gt;-x&lt;/b&gt; was used to find the beginning of the program.</source>
          <target state="translated">该 &lt;code&gt;#!&lt;/code&gt; 解析线路时，始终会检查线路是否有开关。因此，如果您使用的机器上只允许使用 &lt;code&gt;#!&lt;/code&gt; 参数！行，或更糟的是，甚至无法识别 &lt;code&gt;#!&lt;/code&gt; 在第1行中，即使使用&lt;b&gt;-x&lt;/b&gt;查找程序的开始，无论Perl是如何调用的，您仍然可以获得一致的开关行为。</target>
        </trans-unit>
        <trans-unit id="108405af164a595d0a02e5242d4aac5c7a9939f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$OLD_PERL_VERSION&lt;/code&gt; form was added in Perl v5.20.0 for historical reasons but its use is discouraged. (If your reason to use &lt;code&gt;$]&lt;/code&gt; is to run code on old perls then referring to it as &lt;code&gt;$OLD_PERL_VERSION&lt;/code&gt; would be self-defeating.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a8b854056feda55458ac395207c0edacf4109d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; doesn't support &lt;code&gt;'IGNORE'&lt;/code&gt;; it has the same effect as &lt;code&gt;'DEFAULT'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06cfb8f268bdf180a533e3982943c594a32d2955" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is called even inside an &lt;code&gt;eval()&lt;/code&gt;. It was never intended to happen this way, but an implementation glitch made this possible. This used to be deprecated, as it allowed strange action at a distance like rewriting a pending exception in &lt;code&gt;$@&lt;/code&gt;. Plans to rectify this have been scrapped, as users found that rewriting a pending exception is actually a useful feature, and not a bug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb2868e39025eacf0d00ec1478ba8ee01a99e7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$VERSION&lt;/code&gt; variable is used to ensure that the .pm file and the shared library are &quot;in sync&quot; with each other. Any time you make changes to the .pm or .xs files, you should increment the value of this variable.</source>
          <target state="translated">的 &lt;code&gt;$VERSION&lt;/code&gt; 变量用于确保的.pm文件和共享库&amp;ldquo;处于同步&amp;rdquo;彼此。每次更改.pm或.xs文件时，都应增加此变量的值。</target>
        </trans-unit>
        <trans-unit id="2ee72eb90ddce6bbc0931d4e233b1341c5327087" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable (&lt;code&gt;$OSNAME&lt;/code&gt; if you use &lt;code&gt;English&lt;/code&gt; ) contains an indication of the name of the operating system (not its release number) that your perl binary was built for.</source>
          <target state="translated">在 &lt;code&gt;$^O&lt;/code&gt; 变量（ &lt;code&gt;$OSNAME&lt;/code&gt; 如果你用 &lt;code&gt;English&lt;/code&gt; ）包含操作系统（而不是它的版本号），你的perl程序，是为建名的指示。</target>
        </trans-unit>
        <trans-unit id="3c4fecf66108e7576d4b50d6bd4010c1a13f5ea1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable (&lt;code&gt;$OSNAME&lt;/code&gt; if you use &lt;code&gt;English&lt;/code&gt;) contains an indication of the name of the operating system (not its release number) that your perl binary was built for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2aab00569329bab82f1ebc14faa8b668168dc31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable and the &lt;code&gt;$Config{archname}&lt;/code&gt; values for various DOSish perls are as follows:</source>
          <target state="translated">各种DOSish perls 的 &lt;code&gt;$^O&lt;/code&gt; 变量和 &lt;code&gt;$Config{archname}&lt;/code&gt; 值如下：</target>
        </trans-unit>
        <trans-unit id="eba7fdbb831c55f9a441c12e1806775b9e1de0a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$array[1]&lt;/code&gt; is a single-element access to the array. It's going to return the item in index 1 (or undef if there is no item there). If you intend to get exactly one element from the array, this is the form you should use.</source>
          <target state="translated">的 &lt;code&gt;$array[1]&lt;/code&gt; 是将阵列中的单个元件的访问。它会返回索引1中的项目（如果没有项目，则返回undef）。如果打算从数组中仅获取一个元素，则应使用这种形式。</target>
        </trans-unit>
        <trans-unit id="2844c7d661123084d4f84dec0ab13e6bfc03da52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter can either be a scalar or a scalar reference.</source>
          <target state="translated">的 &lt;code&gt;$buffer&lt;/code&gt; 参数可以是一个标量或标量参考。</target>
        </trans-unit>
        <trans-unit id="27274181277155f678e99b9a2b287e41860c82ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter can either be a scalar or a scalar reference. The contents of the &lt;code&gt;$buffer&lt;/code&gt; parameter are destroyed after calling this function.</source>
          <target state="translated">的 &lt;code&gt;$buffer&lt;/code&gt; 参数可以是一个标量或标量参考。调用此函数后， &lt;code&gt;$buffer&lt;/code&gt; 参数的内容将被销毁。</target>
        </trans-unit>
        <trans-unit id="8c4fb1959a7d1bef1019739dc5a4ea212bbc1a3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt; . On completion it will contain what remains of the input buffer after inflation. This means that &lt;code&gt;$buffer&lt;/code&gt; will be an empty string when the return status is &lt;code&gt;Z_OK&lt;/code&gt; . When the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$buffer&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="translated">所述 &lt;code&gt;$buffer&lt;/code&gt; 参数由改性 &lt;code&gt;inflate&lt;/code&gt; 。完成后，它将包含充气后输入缓冲区的剩余内容。这意味着，当返回状态为 &lt;code&gt;Z_OK&lt;/code&gt; 时， &lt;code&gt;$buffer&lt;/code&gt; 将为空字符串。当返回状态为 &lt;code&gt;Z_STREAM_END&lt;/code&gt; 时， &lt;code&gt;$buffer&lt;/code&gt; 参数将包含放气后的数据流之后存储在输入缓冲区中的内容（如果有的话）。</target>
        </trans-unit>
        <trans-unit id="735065db643a224d7abc76057afb08424a7f97a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt;. On completion it will contain what remains of the input buffer after inflation. This means that &lt;code&gt;$buffer&lt;/code&gt; will be an empty string when the return status is &lt;code&gt;Z_OK&lt;/code&gt;. When the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$buffer&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd78ddf95d786af083e0413cd47b10ceef529f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$context&lt;/code&gt; passed in will be an instance of &lt;a href=&quot;Test2::API::Context&quot;&gt;Test2::API::Context&lt;/a&gt;. The &lt;code&gt;$exit&lt;/code&gt; argument will be the original exit code before anything modified it. &lt;code&gt;$$new_exit&lt;/code&gt; is a reference to the new exit code. You may modify this to change the exit code. Please note that &lt;code&gt;$$new_exit&lt;/code&gt; may already be different from &lt;code&gt;$exit&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1f084c43da0252a420f089c62656f2a4438958f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$description&lt;/code&gt; is usually a test file name (but only by convention.) It is used as a unique identifier (see e.g. &lt;a href=&quot;#parsers&quot;&gt;&quot;parsers&quot;&lt;/a&gt;.) Reusing a description is a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4deaa69228d0bed93aa2331246fd160457f98868" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$description&lt;/code&gt; is usually a test file name (but only by convention.) It is used as a unique identifier (see e.g. &lt;a href=&quot;#parsers&quot;&gt;parsers&lt;/a&gt;.) Reusing a description is a fatal error.</source>
          <target state="translated">在 &lt;code&gt;$description&lt;/code&gt; 通常是一个测试文件名（但仅限于按约定）。它被用来作为一个唯一的标识符（见例如&lt;a href=&quot;#parsers&quot;&gt;解析器&lt;/a&gt;）重用的描述是一个致命的错误。</target>
        </trans-unit>
        <trans-unit id="04558cf60bc9c7167d85368eb6635a2473770d4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$eof&lt;/code&gt; parameter needs a bit of explanation.</source>
          <target state="translated">在 &lt;code&gt;$eof&lt;/code&gt; 参数需要一点解释。</target>
        </trans-unit>
        <trans-unit id="65f92aaac6b66cd674844396e8d45e3f370fce50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$eof&lt;/code&gt; parameter only needs to be used if &lt;b&gt;all&lt;/b&gt; of the following conditions apply</source>
          <target state="translated">在 &lt;code&gt;$eof&lt;/code&gt; 参数只需要如果要使用&lt;b&gt;所有&lt;/b&gt;的以下条件</target>
        </trans-unit>
        <trans-unit id="8a410599f21ede34ce0c4e99388bf1aa3ff8199e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$gzerrno&lt;/code&gt; scalar holds the error code associated with the most recent</source>
          <target state="translated">在 &lt;code&gt;$gzerrno&lt;/code&gt; 标保存与最近有关的错误代码</target>
        </trans-unit>
        <trans-unit id="6264c4349310ae2e82ed9dccab08bd7526a285d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$in_fh&lt;/code&gt; parameter may be any object that provides a &lt;b&gt;getline()&lt;/b&gt; method to retrieve a single line of input text (hence, an appropriate wrapper object could be used to parse PODs from a single string or an array of strings).</source>
          <target state="translated">所述 &lt;code&gt;$in_fh&lt;/code&gt; 参数可以是提供一个任意对象&lt;b&gt;函数getline（）&lt;/b&gt;方法检索输入文本的一行（因此，适当的包装对象可以从一个单一的字符串或字符串数组用于解析的POD）。</target>
        </trans-unit>
        <trans-unit id="e89b34e9c40c9e18afebc88c2be1c3150fecd52e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$input&lt;/code&gt; and &lt;code&gt;$output&lt;/code&gt; parameters can be either scalars or scalar references.</source>
          <target state="translated">在 &lt;code&gt;$input&lt;/code&gt; 和 &lt;code&gt;$output&lt;/code&gt; 参数可以是标量或标量引用。</target>
        </trans-unit>
        <trans-unit id="d5ad245702c5052688f1d153e2fbd703e2f8f301" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter</source>
          <target state="translated">在 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="daa9f5f9a1ef279c49e625124d1e76146ad5e7d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$level&lt;/code&gt; parameter defines the compression level. Valid values are 0 through 9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; , &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; , &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; , and &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; . If &lt;code&gt;$level&lt;/code&gt; is not specified &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; will be used.</source>
          <target state="translated">在 &lt;code&gt;$level&lt;/code&gt; 参数定义的压缩级别。有效值为0到9， &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; ， &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; ， &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; 和 &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; 。如果未指定 &lt;code&gt;$level&lt;/code&gt; 将使用 &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="898131faa0f3e8f99a6d077f4bd62a3c78ce8ae9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$level&lt;/code&gt; parameter defines the compression level. Valid values are 0 through 9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt;, &lt;code&gt;Z_BEST_SPEED&lt;/code&gt;, &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt;, and &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt;. If &lt;code&gt;$level&lt;/code&gt; is not specified &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb33cd5cc665b9c3bd624d64f0ec40381e42cbac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$mon&lt;/code&gt; is zero-based: January equals &lt;code&gt;0&lt;/code&gt; . The &lt;code&gt;$year&lt;/code&gt; is 1900-based: 2001 equals &lt;code&gt;101&lt;/code&gt; . &lt;code&gt;$wday&lt;/code&gt; and &lt;code&gt;$yday&lt;/code&gt; default to zero (and are usually ignored anyway), and &lt;code&gt;$isdst&lt;/code&gt; defaults to -1.</source>
          <target state="translated">该 &lt;code&gt;$mon&lt;/code&gt; 是从零开始：一月等于 &lt;code&gt;0&lt;/code&gt; 。该 &lt;code&gt;$year&lt;/code&gt; 是1900型：2001年相当于 &lt;code&gt;101&lt;/code&gt; 。 &lt;code&gt;$wday&lt;/code&gt; 和 &lt;code&gt;$yday&lt;/code&gt; 默认为零（反正通常被忽略），和 &lt;code&gt;$isdst&lt;/code&gt; 默认为-1。</target>
        </trans-unit>
        <trans-unit id="7421dc164fd8281f20128cde64ce3b745047d3c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$mon&lt;/code&gt; is zero-based: January equals &lt;code&gt;0&lt;/code&gt;. The &lt;code&gt;$year&lt;/code&gt; is 1900-based: 2001 equals &lt;code&gt;101&lt;/code&gt;. &lt;code&gt;$wday&lt;/code&gt; and &lt;code&gt;$yday&lt;/code&gt; default to zero (and are usually ignored anyway), and &lt;code&gt;$isdst&lt;/code&gt; defaults to -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23cd0f7ae4d6af5b92c0f4a1db509d798cb0ac59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$name&lt;/code&gt; variable should be the key used to access the facet in a facets hashref. For instance the assertion facet has the key 'assert', the information facet has the 'info' key, and the error facet has the key 'errors'. You may include or omit the 's' at the end of the name, the method is smart enough to try both the 's' and no-'s' forms, it will check what you provided first, and if that is not found it will add or strip the 's and try again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d866868676edf3ef0ef337619cbb9d7d463b060f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter</source>
          <target state="translated">在 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="c96d672905fea90a5656f24eb9f7936742884276" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$parser&lt;/code&gt; is a &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; object.</source>
          <target state="translated">该 &lt;code&gt;$parser&lt;/code&gt; 是一个&lt;a href=&quot;../parser&quot;&gt;TAP ::分析器&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="6143cd77ebc527cea165f0db3248c326b91b9c6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$parser&lt;/code&gt; is a &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cde3685cee91824cf2720ce6f47ce3c1655541a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$tabstop&lt;/code&gt; variable controls how many column positions apart each tabstop is. The default is 8.</source>
          <target state="translated">在 &lt;code&gt;$tabstop&lt;/code&gt; 变量控制多少列位置除了每个制表位是。预设值为8。</target>
        </trans-unit>
        <trans-unit id="07507ab596d7a55a579157466578b8c289c17f57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$whence&lt;/code&gt; parameter should be one of SEEK_SET, SEEK_CUR or SEEK_END.</source>
          <target state="translated">在 &lt;code&gt;$whence&lt;/code&gt; 参数应该是SEEK_SET，SEEK_CUR或SEEK_END之一。</target>
        </trans-unit>
        <trans-unit id="78200cc1ea59e994c5d2418e77df8c6e8fa8185d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$whence&lt;/code&gt; parameter takes one the usual values, namely SEEK_SET, SEEK_CUR or SEEK_END.</source>
          <target state="translated">在 &lt;code&gt;$whence&lt;/code&gt; 参数需要一个平常值，即SEEK_SET，SEEK_CUR或SEEK_END。</target>
        </trans-unit>
        <trans-unit id="d36c42de8f17d5532305a2dae875ef12d3135188" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$|&lt;/code&gt; is one of the per-filehandle special variables, so each filehandle has its own copy of its value. If you want to merge standard output and standard error for instance, you have to unbuffer each (although STDERR might be unbuffered by default):</source>
          <target state="translated">在 &lt;code&gt;$|&lt;/code&gt; 是每个文件句柄的特殊变量之一，因此每个文件句柄都有自己的值副本。例如，如果要合并标准输出和标准错误，则必须分别取消缓冲（尽管默认情况下STDERR可能未缓冲）：</target>
        </trans-unit>
        <trans-unit id="697d0e02c23a6252ba73964b72ba7fef06e6718b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%^H&lt;/code&gt; hash provides the same scoping semantic as &lt;code&gt;$^H&lt;/code&gt; . This makes it useful for implementation of lexically scoped pragmas. See &lt;a href=&quot;perlpragma&quot;&gt;perlpragma&lt;/a&gt;. All the entries are stringified when accessed at runtime, so only simple values can be accommodated. This means no pointers to objects, for example.</source>
          <target state="translated">的 &lt;code&gt;%^H&lt;/code&gt; 散列提供相同的语义范围界定为 &lt;code&gt;$^H&lt;/code&gt; 。这对于实现词法范围的编译指示很有用。参见&lt;a href=&quot;perlpragma&quot;&gt;perlpragma&lt;/a&gt;。在运行时访问时，所有条目都是字符串化的，因此只能容纳简单的值。例如，这意味着没有指向对象的指针。</target>
        </trans-unit>
        <trans-unit id="1c509249d339b2febfc4d2738ff085bd8d0cc7d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%^H&lt;/code&gt; hash provides the same scoping semantic as &lt;code&gt;$^H&lt;/code&gt;. This makes it useful for implementation of lexically scoped pragmas. See &lt;a href=&quot;perlpragma&quot;&gt;perlpragma&lt;/a&gt;. All the entries are stringified when accessed at runtime, so only simple values can be accommodated. This means no pointers to objects, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6228356b1a9a18f543cd58f3d14ae5ed0885fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%s&lt;/code&gt; is expanded to be the filename (&lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; is used, so be careful to escape any other &lt;code&gt;%&lt;/code&gt; signs). The 'commands' are checked for sanity - they must contain the &lt;code&gt;%s&lt;/code&gt; , and the read open must end with the pipe sign, and the write open must begin with the pipe sign.</source>
          <target state="translated">将 &lt;code&gt;%s&lt;/code&gt; 扩展为文件名（使用 &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; ，因此请小心转义任何其他 &lt;code&gt;%&lt;/code&gt; 符号）。检查&amp;ldquo;命令&amp;rdquo;的完整性&amp;ndash;它们必须包含 &lt;code&gt;%s&lt;/code&gt; ，并且读打开必须以管道符号结尾，写打开必须以管道符号开头。</target>
        </trans-unit>
        <trans-unit id="2719188c4cf371193166be19d0cfafdbeb67f360" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%s&lt;/code&gt; is expanded to be the filename (&lt;code&gt;sprintf&lt;/code&gt; is used, so be careful to escape any other &lt;code&gt;%&lt;/code&gt; signs). The 'commands' are checked for sanity - they must contain the &lt;code&gt;%s&lt;/code&gt;, and the read open must end with the pipe sign, and the write open must begin with the pipe sign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6ebcc90a0416e4d456de5b17214b9e0b4a29e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator in the INPUT: section is used to tell &lt;b&gt;xsubpp&lt;/b&gt; that it should convert a Perl value to/from C using the C type to the left of &lt;code&gt;&amp;amp;&lt;/code&gt; , but provide a pointer to this value when the C function is called.</source>
          <target state="translated">INPUT：部分中的 &lt;code&gt;&amp;amp;&lt;/code&gt; 一元运算符用于告诉&lt;b&gt;xsubpp&lt;/b&gt;它应使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 左侧的C类型将Perl值转换为C或从C转换为Perl值，但在调用C函数时提供指向该值的指针。</target>
        </trans-unit>
        <trans-unit id="f377db487fb9db0d6201d5c112d20cdac0c1ec99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator in the INPUT: section is used to tell &lt;b&gt;xsubpp&lt;/b&gt; that it should convert a Perl value to/from C using the C type to the left of &lt;code&gt;&amp;amp;&lt;/code&gt;, but provide a pointer to this value when the C function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b29d8efcd6e9fd3b54226af4554626aa17bc6d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers can also be used on &lt;code&gt;()&lt;/code&gt; groups to force a particular byte-order on all components in that group, including all its subgroups.</source>
          <target state="translated">所述 &lt;code&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&lt;/code&gt; 改性剂也可以在使用 &lt;code&gt;()&lt;/code&gt; 基团，以迫使该组中的所有组件，包括其所有亚组的特定字节顺序。</target>
        </trans-unit>
        <trans-unit id="46a36b2037ff10a0c2a8e03718578280ecd8883f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers can only be used on floating-point formats on big- or little-endian machines. Otherwise, attempting to use them raises an exception.</source>
          <target state="translated">所述 &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&lt;/code&gt; 修饰符只能对大端或小端机浮点格式一起使用。否则，尝试使用它们会引发异常。</target>
        </trans-unit>
        <trans-unit id="99da10732816cfac1a93d49f7cb24d6856262342" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator is most often seen in a &lt;code&gt;while&lt;/code&gt; loop:</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符最常见于一个 &lt;code&gt;while&lt;/code&gt; 循环：</target>
        </trans-unit>
        <trans-unit id="afce8c3936870dcddae71b2f62bcc6619bb65ebe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator performs a globbing operation (see above). In Perl versions earlier than v5.6.0, the internal glob() operator forks csh(1) to do the actual glob expansion, but csh can't handle more than 127 items and so gives the error message &lt;code&gt;Argument list too long&lt;/code&gt; . People who installed tcsh as csh won't have this problem, but their users may be surprised by it.</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符执行一个通配符操作（见上文）。在低于v5.6.0的Perl版本中，内部glob（）运算符派生csh（1）进行实际的glob扩展，但是csh不能处理127个以上的项目，因此错误消息 &lt;code&gt;Argument list too long&lt;/code&gt; 。将tcsh安装为csh的用户不会遇到此问题，但是他们的用户可能对此感到惊讶。</target>
        </trans-unit>
        <trans-unit id="83ef73a269b83405910162deabaede06a6badff3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator performs a globbing operation (see above). In Perl versions earlier than v5.6.0, the internal glob() operator forks csh(1) to do the actual glob expansion, but csh can't handle more than 127 items and so gives the error message &lt;code&gt;Argument list too long&lt;/code&gt;. People who installed tcsh as csh won't have this problem, but their users may be surprised by it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6640438652752fb93dc538db26332c2e258075d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; symbol will return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for end-of-file only once. If you call it again after this, it will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from STDIN.</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 符号将返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 只有一次结束文件。如果在此之后再次调用它，它将假定您正在处理另一个 &lt;code&gt;@ARGV&lt;/code&gt; 列表，如果尚未设置 &lt;code&gt;@ARGV&lt;/code&gt; ，则会从STDIN读取输入。</target>
        </trans-unit>
        <trans-unit id="3dc916b5527d8e3b6254129215dab620bcd909c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; symbol will return &lt;code&gt;undef&lt;/code&gt; for end-of-file only once. If you call it again after this, it will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt;, will read input from STDIN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb62b601a884f58c8064f8b862089ac2459b0228" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'I'&lt;/code&gt; prefix is used during creation of &lt;code&gt;stdin&lt;/code&gt; ..&lt;code&gt;stderr&lt;/code&gt; via special &lt;code&gt;PerlIO_fdopen&lt;/code&gt; calls; the &lt;code&gt;'#'&lt;/code&gt; prefix means that this is &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; and that</source>
          <target state="translated">在 &lt;code&gt;'I'&lt;/code&gt; 前缀创建的过程中使用 &lt;code&gt;stdin&lt;/code&gt; .. &lt;code&gt;stderr&lt;/code&gt; 通过特殊 &lt;code&gt;PerlIO_fdopen&lt;/code&gt; 电话;在 &lt;code&gt;'#'&lt;/code&gt; 前缀意味着这是 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 和</target>
        </trans-unit>
        <trans-unit id="e4a1e4127c99792fcfccb34fc1ce371d9c5cbbcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'I'&lt;/code&gt; prefix is used during creation of &lt;code&gt;stdin&lt;/code&gt;..&lt;code&gt;stderr&lt;/code&gt; via special &lt;code&gt;PerlIO_fdopen&lt;/code&gt; calls; the &lt;code&gt;'#'&lt;/code&gt; prefix means that this is &lt;code&gt;sysopen&lt;/code&gt; and that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039ae207dd483bda31bf76d897310e5b8ac60fad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'nomethod'&lt;/code&gt; key is used to specify a catch-all function to be called for any operator that is not individually overloaded. The specified function will be passed four parameters. The first three arguments coincide with those that would have been passed to the corresponding method if it had been defined. The fourth argument is the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; key for that missing method. If the experimental &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; to indicate that the caller is expecting numeric behaviour.</source>
          <target state="translated">该 &lt;code&gt;'nomethod'&lt;/code&gt; 键用于指定一个包罗万象的功能被称为对未单独重载任何操作。指定的函数将传递四个参数。前三个参数与如果已定义相应方法的参数相吻合。第四个参数是该丢失方法的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 键。如果启用了实验性的&amp;ldquo;按位&amp;rdquo;功能（请参见&lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;），则将第五个TRUE参数传递给处理 &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; 的子例程。， &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; 表示呼叫者正在期待数字行为。</target>
        </trans-unit>
        <trans-unit id="7a25ce7c1bcfa6d33e234b18065c7c24fe6b0cdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'nomethod'&lt;/code&gt; key is used to specify a catch-all function to be called for any operator that is not individually overloaded. The specified function will be passed four parameters. The first three arguments coincide with those that would have been passed to the corresponding method if it had been defined. The fourth argument is the &lt;code&gt;use overload&lt;/code&gt; key for that missing method. If the &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; to indicate that the caller is expecting numeric behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56ee7f30e7bca1dfc3e81783dadbc2bc19f727f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(a|b)*&lt;/code&gt; part can match at every char in the string, and then fail every time because there is no &lt;code&gt;z&lt;/code&gt; in the string. So obviously we can avoid using the regex engine unless there is a &lt;code&gt;z&lt;/code&gt; in the string. Likewise in a pattern like:</source>
          <target state="translated">该 &lt;code&gt;(a|b)*&lt;/code&gt; 部分可以匹配在字符串中的字符每一个，再失败，每次都因为没有 &lt;code&gt;z&lt;/code&gt; 的的字符串中。因此，显然，除非字符串中包含 &lt;code&gt;z&lt;/code&gt; ，否则我们可以避免使用正则表达式引擎。同样的模式如下：</target>
        </trans-unit>
        <trans-unit id="13f6771d5d5f30a227731a56b375d2b66657907c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*_BS&lt;/code&gt; file can put some code into the generated &lt;code&gt;*.bs&lt;/code&gt; file by placing it in &lt;code&gt;$bscode&lt;/code&gt; . This is a handy 'escape' mechanism that may prove useful in complex situations.</source>
          <target state="translated">在 &lt;code&gt;*_BS&lt;/code&gt; 文件可以把一些代码到生成的 &lt;code&gt;*.bs&lt;/code&gt; 通过将其放置在文件 &lt;code&gt;$bscode&lt;/code&gt; 。这是一种方便的&amp;ldquo;转义&amp;rdquo;机制，在复杂情况下可能会很有用。</target>
        </trans-unit>
        <trans-unit id="b4a8908910386e1e7fa8ea911939f668d427bb11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*_BS&lt;/code&gt; file can put some code into the generated &lt;code&gt;*.bs&lt;/code&gt; file by placing it in &lt;code&gt;$bscode&lt;/code&gt;. This is a handy 'escape' mechanism that may prove useful in complex situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ecae669ab5e752a1da7ac780070c852f9269859" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*foo{THING}&lt;/code&gt; notation can also be used to obtain references to the individual elements of *foo. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;*foo{THING}&lt;/code&gt; 表示法也可以被用于获取* foo的单个元素的引用。参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="255645a7c66228ebcb1a14a341007dcfb97aeb51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*x = \$y&lt;/code&gt; mechanism may be used to pass and return cheap references into or from subroutines if you don't want to copy the whole thing. It only works when assigning to dynamic variables, not lexicals.</source>
          <target state="translated">在 &lt;code&gt;*x = \$y&lt;/code&gt; 机制可以用来传递和返回便宜引用或从子程序，如果你不想复制整个事情。仅在分配给动态变量而不是词法时才起作用。</target>
        </trans-unit>
        <trans-unit id="fa1621299f61dcb4d1993cf9ac21afe7e26870e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; form is now obsolete and strongly deprecated.</source>
          <target state="translated">该 &lt;code&gt;+&lt;/code&gt; 的形式是现在已经过时，并强烈反对。</target>
        </trans-unit>
        <trans-unit id="6cc8f120eca26410795cc27186ae2b363ac834f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; prototype is a special alternative to &lt;code&gt;$&lt;/code&gt; that will act like &lt;code&gt;\[@%]&lt;/code&gt; when given a literal array or hash variable, but will otherwise force scalar context on the argument. This is useful for functions which should accept either a literal array or an array reference as the argument:</source>
          <target state="translated">的 &lt;code&gt;+&lt;/code&gt; 原型是一个特别的替代 &lt;code&gt;$&lt;/code&gt; 将充当像 &lt;code&gt;\[@%]&lt;/code&gt; 给出一个字面阵列或散列变量时，反而会否则迫使参数标量上下文。这对于应该接受文字数组或数组引用作为参数的函数很有用：</target>
        </trans-unit>
        <trans-unit id="bb2105637115aa748fce8bf2036dcef89f13282b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; specifier is ignored if the option destination is not a scalar.</source>
          <target state="translated">在 &lt;code&gt;+&lt;/code&gt; 如果选项目的不是标符被忽略。</target>
        </trans-unit>
        <trans-unit id="6806c6a2e8d1792a36b6bbc8a8afc151b341b78f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; unary operator doesn't do anything in Perl. It exists to avoid syntactic ambiguities.</source>
          <target state="translated">在 &lt;code&gt;+&lt;/code&gt; 一元运算符并不在Perl做任何事情。它的存在是为了避免句法歧义。</target>
        </trans-unit>
        <trans-unit id="37675ebea1632ec83c2cb0e9f47bb19d76dac534" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;&lt;/code&gt; syntax is also used when dereferencing a reference. It looks like the same operator, but these are two different operations.</source>
          <target state="translated">的 &lt;code&gt;-&amp;gt;&lt;/code&gt; 语法也解除引用的参考时使用。看起来好像是同一操作符，但是这是两个不同的操作。</target>
        </trans-unit>
        <trans-unit id="d4b0e534108246bac541ccb7068bc25380ccc720" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;new()&lt;/code&gt; method is an alias for &lt;code&gt;-&amp;gt;create()&lt;/code&gt; .</source>
          <target state="translated">的 &lt;code&gt;-&amp;gt;new()&lt;/code&gt; 方法是用于一个别名 &lt;code&gt;-&amp;gt;create()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7955495872f4b4ea374a5a73bb5908daadd88feb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;new()&lt;/code&gt; method is an alias for &lt;code&gt;-&amp;gt;create()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8192632e359d95a2b8b1baa2f14ef188f64fb3bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--libpods&lt;/code&gt; option is no longer recognized as of Perl 5.26.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127cc52ec86933168c2c1aece6f9b232d7cd7b7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--rules&lt;/code&gt; option is used to control which tests are run sequentially and which are run in parallel, if the &lt;code&gt;--jobs&lt;/code&gt; option is specified. The option may be specified multiple times, and the order matters.</source>
          <target state="translated">该 &lt;code&gt;--rules&lt;/code&gt; 选项用于哪些测试被顺序地运行并且被并行运行控制，如果 &lt;code&gt;--jobs&lt;/code&gt; 选项被指定。可以多次指定该选项，并且顺序很重要。</target>
        </trans-unit>
        <trans-unit id="608a757f76e2d49976d1abe026a19ab9cb45d134" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--state&lt;/code&gt; switch may be used more than once.</source>
          <target state="translated">该 &lt;code&gt;--state&lt;/code&gt; 开关可以使用一次以上。</target>
        </trans-unit>
        <trans-unit id="cc3c8ce0b0c852fbdda4091c52f36592afcdc410" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--state&lt;/code&gt; switch requires an argument which must be a comma separated list of one or more of the following options.</source>
          <target state="translated">所述 &lt;code&gt;--state&lt;/code&gt; 开关需要必须是一个逗号参数分隔的一个或多个下面的选项的列表。</target>
        </trans-unit>
        <trans-unit id="377dc2d9444ba53f1e07b9f9c8ed4eb80a1854c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--trap&lt;/code&gt; option will attempt to trap SIGINT (Ctrl-C) during a test run and display the test summary even if the run is interrupted</source>
          <target state="translated">该 &lt;code&gt;--trap&lt;/code&gt; 选项将在测试运行期间尝试陷阱SIGINT（CTRL-C），并显示即使运行被中断的测试总结</target>
        </trans-unit>
        <trans-unit id="e392f25b1c4fe3943f476468712579d620408f6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; command line switch</source>
          <target state="translated">所述 &lt;code&gt;-A&lt;/code&gt; 命令行开关</target>
        </trans-unit>
        <trans-unit id="eb91ceec65f320f24de6ea1ba97059dfa04bc1be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; omits the Autoloader code, &lt;code&gt;-X&lt;/code&gt; omits XS elements, &lt;code&gt;--skip-exporter&lt;/code&gt; omits the Exporter code, &lt;code&gt;--use-new-tests&lt;/code&gt; sets up a modern testing environment, and &lt;code&gt;-n&lt;/code&gt; specifies the name of the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597b9a9c8e6ccba33470cbc78977519edc52f8e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; omits the Autoloader code, &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; omits XS elements, &lt;code&gt;--skip-exporter&lt;/code&gt; omits the Exporter code, &lt;code&gt;--&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;-new-tests&lt;/code&gt; sets up a modern testing environment, and &lt;code&gt;-n&lt;/code&gt; specifies the name of the module.</source>
          <target state="translated">该 &lt;code&gt;-A&lt;/code&gt; 忽略了自动装弹机代码， &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 遗漏XS元素， &lt;code&gt;--skip-exporter&lt;/code&gt; 省略了出口商的代码， &lt;code&gt;--&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;-new-tests&lt;/code&gt; 建立了一个现代化的测试环境，并 &lt;code&gt;-n&lt;/code&gt; 指定模块的名称。</target>
        </trans-unit>
        <trans-unit id="c623c1943d0dabf76760d7670756f1a93a94f39a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Dusecbacktrace&lt;/code&gt; also enables keeping the debug information when compiling/linking (often: &lt;code&gt;-g&lt;/code&gt; ). Many compilers/linkers do support having both optimization and keeping the debug information. The debug information is needed for the symbol names and the source locations.</source>
          <target state="translated">该 &lt;code&gt;-Dusecbacktrace&lt;/code&gt; 还能够保持调试信息编译/链接时（通常是： &lt;code&gt;-g&lt;/code&gt; ）。许多编译器/链接器都支持同时具有优化和保留调试信息。符号名称和源位置需要调试信息。</target>
        </trans-unit>
        <trans-unit id="82d0f491a8ddd8c808b16ec9be7ca117f4caf1b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Dusecbacktrace&lt;/code&gt; also enables keeping the debug information when compiling/linking (often: &lt;code&gt;-g&lt;/code&gt;). Many compilers/linkers do support having both optimization and keeping the debug information. The debug information is needed for the symbol names and the source locations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63378b07c96f9b709eea4a8451598ec112926512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; switches work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If, so it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;../perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;-T&lt;/code&gt; 和 &lt;code&gt;-B&lt;/code&gt; 开关的工作如下。检查文件的第一个块左右，以查看它是否是包含非ASCII字符的有效UTF-8。如果是，那么它是 &lt;code&gt;-T&lt;/code&gt; 文件。否则，将检查文件的同一部分中是否有奇怪的字符，例如奇怪的控制代码或设置了高位的字符。如果超过三分之一的字符是奇怪的， &lt;code&gt;-B&lt;/code&gt; 文件；否则，为-B文件。否则，它是 &lt;code&gt;-T&lt;/code&gt; 文件。同样，在检查的部分中任何包含零字节的文件都被视为二进制文件。 （如果在包含 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的&lt;a href=&quot;../perllocale&quot;&gt;使用语言环境&lt;/a&gt;的范围内执行，则奇数字符是在当前语言环境中既不可打印也不可空格的任何字符。） &lt;code&gt;-T&lt;/code&gt; 在文件句柄上使用-T或 &lt;code&gt;-B&lt;/code&gt; ，将检查当前IO缓冲区而不是第一个块。在测试文件句柄时， &lt;code&gt;-T&lt;/code&gt; 和 &lt;code&gt;-B&lt;/code&gt; 在空文件或EOF处的文件上均返回true。因为必须读取文件才能进行 &lt;code&gt;-T&lt;/code&gt; 测试，所以在大多数情况下，您首先要对文件使用 &lt;code&gt;-f&lt;/code&gt; ，就像 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; 要使用-f一样，除非-f $ file &amp;amp;&amp;amp; -T $ file。</target>
        </trans-unit>
        <trans-unit id="c91ca83f347b61a13eb65089f07047ddb67d9622" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; switches work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If, so it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;-T&lt;/code&gt; 和 &lt;code&gt;-B&lt;/code&gt; 开关的工作如下。检查文件的第一个块左右，以查看它是否是包含非ASCII字符的有效UTF-8。如果是，那么它是 &lt;code&gt;-T&lt;/code&gt; 文件。否则，将检查文件的同一部分中是否有奇怪的字符，例如奇怪的控制代码或设置了高位的字符。如果超过三分之一的字符是奇怪的， &lt;code&gt;-B&lt;/code&gt; 文件；否则，为-B文件。否则，它是 &lt;code&gt;-T&lt;/code&gt; 文件。同样，在检查的部分中任何包含零字节的文件都被视为二进制文件。 （如果在包含 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的&lt;a href=&quot;perllocale&quot;&gt;使用语言环境&lt;/a&gt;的范围内执行，则奇数字符是在当前语言环境中既不可打印也不可空格的任何字符。） &lt;code&gt;-T&lt;/code&gt; 在文件句柄上使用-T或 &lt;code&gt;-B&lt;/code&gt; ，将检查当前IO缓冲区而不是第一个块。在测试文件句柄时， &lt;code&gt;-T&lt;/code&gt; 和 &lt;code&gt;-B&lt;/code&gt; 在空文件或EOF处的文件上均返回true。因为必须读取文件才能进行 &lt;code&gt;-T&lt;/code&gt; 测试，所以在大多数情况下，您首先要对文件使用 &lt;code&gt;-f&lt;/code&gt; ，就像 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; 要使用-f一样，除非-f $ file &amp;amp;&amp;amp; -T $ file。</target>
        </trans-unit>
        <trans-unit id="7d03161bfdc601bdcaa9b51890ed40d35154d9a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; tests work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If so, it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt;, odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;next unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc0f3fa215c39800076a942f11672815853d1f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Wall&lt;/code&gt; is by default on.</source>
          <target state="translated">该 &lt;code&gt;-Wall&lt;/code&gt; 是默认的。</target>
        </trans-unit>
        <trans-unit id="6dfbaa82d695de76db5a43cbdf063e4ffac5d9ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Wtraditional&lt;/code&gt; is another example of the annoying tendency of gcc to bundle a lot of warnings under one switch (it would be impossible to deploy in practice because it would complain a lot) but it does contain some warnings that would be beneficial to have available on their own, such as the warning about string constants inside macros containing the macro arguments: this behaved differently pre-ANSI than it does in ANSI, and some C compilers are still in transition, AIX being an example.</source>
          <target state="translated">该 &lt;code&gt;-Wtraditional&lt;/code&gt; 是gcc的恼人倾向捆绑了很多警告的下一个开关的另一个例子（这将是不可能在实践中部署，因为它会抱怨很多），但它确实包含了一些警告，这将是有益的可用就其本身而言，例如关于包含宏参数的宏内的字符串常量的警告：在ANSI之前的行为与在ANSI中的行为不同，并且某些C编译器仍在过渡中，以AIX为例。</target>
        </trans-unit>
        <trans-unit id="29f275b0f904c074e809dc11f6813898aaca641a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-a&lt;/code&gt; option is used to include all files that git tracks that you have changed. If at this time, you only want to commit some of the files you have worked on, you can omit the &lt;code&gt;-a&lt;/code&gt; and use the command &lt;code&gt;git add &lt;i&gt;FILE ...&lt;/i&gt;&lt;/code&gt; before doing the commit. &lt;code&gt;git add --interactive&lt;/code&gt; allows you to even just commit portions of files instead of all the changes in them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea68b3a7d6bdc421299da6629ccc22d6bd7b572" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-ansi&lt;/code&gt; (and its sidekick, &lt;code&gt;-pedantic&lt;/code&gt; ) would be nice to be on always, but unfortunately they are not safe on all platforms, they can for example cause fatal conflicts with the system headers (Solaris being a prime example). If Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; is used, the &lt;code&gt;cflags&lt;/code&gt; frontend selects &lt;code&gt;-ansi -pedantic&lt;/code&gt; for the platforms where they are known to be safe.</source>
          <target state="translated">该 &lt;code&gt;-ansi&lt;/code&gt; （和它的搭档， &lt;code&gt;-pedantic&lt;/code&gt; ）将是很好的始终，但不幸的是他们不是在所有平台上的安全，它们可以例如导致系统标题（的Solaris是一个最好的例子）致命的冲突。如果使用Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; ，则 &lt;code&gt;cflags&lt;/code&gt; 前端会为已知安全的平台选择 &lt;code&gt;-ansi -pedantic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c0974d53dc0e4835c4ef757f3690c3874414b6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-ansi&lt;/code&gt; (and its sidekick, &lt;code&gt;-pedantic&lt;/code&gt;) would be nice to be on always, but unfortunately they are not safe on all platforms, they can for example cause fatal conflicts with the system headers (Solaris being a prime example). If Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; is used, the &lt;code&gt;cflags&lt;/code&gt; frontend selects &lt;code&gt;-ansi -pedantic&lt;/code&gt; for the platforms where they are known to be safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb94d9f2c59455332a30530ef3be81c2f437b975" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-h&lt;/code&gt; option will show a usage message.</source>
          <target state="translated">该 &lt;code&gt;-h&lt;/code&gt; 选项将显示用法消息。</target>
        </trans-unit>
        <trans-unit id="2bf6b5a2450e550c35673777465af352e8fad7fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-m&lt;/code&gt; option is used to specify the commit message. If you omit it, git will open a text editor for you to compose the message interactively. This is useful when the changes are more complex than the sample given here, and, depending on the editor, to know that the first line of the commit message doesn't exceed the 50 character legal maximum. See &lt;a href=&quot;perlhack#Commit-message&quot;&gt;&quot;Commit message&quot; in perlhack&lt;/a&gt; for more information about what makes a good commit message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02d034bd54a852b799ddb0bca00601006bc9ad62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-newlex&lt;/code&gt; option produces a more readable &lt;code&gt;name =&amp;gt; value&lt;/code&gt; format, and is shown in the second example above.</source>
          <target state="translated">所述 &lt;code&gt;-newlex&lt;/code&gt; 选项生成一个更可读的 &lt;code&gt;name =&amp;gt; value&lt;/code&gt; 格式，并且在上面的第二个例子被示出。</target>
        </trans-unit>
        <trans-unit id="3ed7e26de1fd10b827d09512227b49a4f8d06d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-nosp&lt;/code&gt; option eliminates reporting of SPECIALs, such as &lt;code&gt;0: SPECIAL
#1 &amp;amp;PL_sv_undef&lt;/code&gt; above. Reporting of SPECIALs can sometimes overwhelm your declared lexicals.</source>
          <target state="translated">所述 &lt;code&gt;-nosp&lt;/code&gt; 选项消除特价报告，诸如 &lt;code&gt;0: SPECIAL #1 &amp;amp;PL_sv_undef&lt;/code&gt; 上方。SPECIAL的报告有时会使您所声明的词汇不堪重负。</target>
        </trans-unit>
        <trans-unit id="063586d44811e787a3acc7fa9925ec22a0e1ef32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-pretty&lt;/code&gt; directive is called too late to affect matters. You have to do this instead, and</source>
          <target state="translated">该 &lt;code&gt;-pretty&lt;/code&gt; 指令被称为来不及影响的事项。您必须这样做，并且</target>
        </trans-unit>
        <trans-unit id="64b5e1fcc02dcf849bd221c8c257f81fb47b92a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-q&lt;/code&gt; and &lt;code&gt;-qq&lt;/code&gt; options don't work correctly if perl isn't compiled with PerlIO support : STDOUT will be closed instead of being redirected to &lt;code&gt;$O::BEGIN_output&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;-q&lt;/code&gt; 和 &lt;code&gt;-qq&lt;/code&gt; 如果是用perl不PerlIO的支持编译选项不能正常工作：STDOUT将被关闭，而不是被重定向到 &lt;code&gt;$O::BEGIN_output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29496d6f7bd6b984673c9ef63d5a96a39bc5fbb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-q&lt;/code&gt; and &lt;code&gt;-qq&lt;/code&gt; options don't work correctly if perl isn't compiled with PerlIO support : STDOUT will be closed instead of being redirected to &lt;code&gt;$O::BEGIN_output&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6261ab8564541d33e35c7ac1e97aa8a5e571dd14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-qq&lt;/code&gt; option behaves like &lt;code&gt;-q&lt;/code&gt;, except that it also closes STDERR after deparsing has finished. This suppresses the &quot;Syntax OK&quot; message normally produced by perl.</source>
          <target state="translated">该 &lt;code&gt;-qq&lt;/code&gt; 选项的行为就像 &lt;code&gt;-q&lt;/code&gt; ，但它也deparsing完成后关闭STDERR。这抑制了perl通常生成的&amp;ldquo;语法确定&amp;rdquo;消息。</target>
        </trans-unit>
        <trans-unit id="cb173d8eff47f06c7e37f7374c7227453a2ad4d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-u&lt;/code&gt; switch causes the VMS debugger to be invoked after the Perl program is compiled, but before it has run. It does not create a core dump file.</source>
          <target state="translated">该 &lt;code&gt;-u&lt;/code&gt; 开关使Perl程序被编译后要调用的VMS调试器，但它已运行之前。它不会创建核心转储文件。</target>
        </trans-unit>
        <trans-unit id="1e542d84460c8b59074b5a3d74792d84cf2329fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; and &lt;code&gt;...&lt;/code&gt; flip-flop operators. Note that the &lt;code&gt;...&lt;/code&gt; flip-flop operator is completely different from the &lt;code&gt;...&lt;/code&gt; elliptical statement just described.</source>
          <target state="translated">该 &lt;code&gt;..&lt;/code&gt; 和 &lt;code&gt;...&lt;/code&gt; 触发器运营商。请注意， &lt;code&gt;...&lt;/code&gt; 触发器运算符与刚刚描述的 &lt;code&gt;...&lt;/code&gt; 椭圆语句完全不同。</target>
        </trans-unit>
        <trans-unit id="8189082aec1c35ce34b10a2a482272d1f9442cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; range operator treats certain character ranges with care on EBCDIC platforms. For example the following array will have twenty six elements on either an EBCDIC platform or an ASCII platform:</source>
          <target state="translated">该 &lt;code&gt;..&lt;/code&gt; 范围操作符对待某些字符范围小心在EBCDIC平台。例如，以下数组在EBCDIC平台或ASCII平台上将具有26个元素：</target>
        </trans-unit>
        <trans-unit id="1bfc1b4066699d36e1a1c96b8bf42e5d376ee7e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;//&lt;/code&gt; matching operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;. It operates on &lt;code&gt;$_&lt;/code&gt; by default, or can be bound to another variable using the &lt;code&gt;=~&lt;/code&gt; binding operator (also documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;).</source>
          <target state="translated">该 &lt;code&gt;//&lt;/code&gt; 匹配运算符中记录&lt;a href=&quot;perlop&quot;&gt;perlop中&lt;/a&gt;。默认情况下，它在 &lt;code&gt;$_&lt;/code&gt; 上操作，或者可以使用 &lt;code&gt;=~&lt;/code&gt; 绑定运算符（也记录在&lt;a href=&quot;perlop&quot;&gt;perlop中&lt;/a&gt;）绑定到另一个变量。</target>
        </trans-unit>
        <trans-unit id="32ef826cb43c384876c66cdfd8ef3d6094273ed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;//a&lt;/code&gt; modifier, available starting in Perl 5.14, is used to restrict the matches of \d, \s, and \w to just those in the ASCII range. It is useful to keep your program from being needlessly exposed to full Unicode (and its accompanying security considerations) when all you want is to process English-like text. (The &quot;a&quot; may be doubled, &lt;code&gt;//aa&lt;/code&gt; , to provide even more restrictions, preventing case-insensitive matching of ASCII with non-ASCII characters; otherwise a Unicode &quot;Kelvin Sign&quot; would caselessly match a &quot;k&quot; or &quot;K&quot;.)</source>
          <target state="translated">所述 &lt;code&gt;//a&lt;/code&gt; 改性剂，在Perl 5.14获得的起始，用于限制\ d S的匹配，\，和\ w至只是那些在ASCII范围。当您只需要处理类似英语的文本时，使您的程序避免不必要地暴露于完整的Unicode（及其伴随的安全性考虑）非常有用。 （&amp;ldquo; a&amp;rdquo;可以加倍 &lt;code&gt;//aa&lt;/code&gt; ，以提供更多限制，防止ASCII与非ASCII字符不区分大小写的匹配；否则，Unicode&amp;ldquo; Kelvin Sign&amp;rdquo;将无条件地匹配&amp;ldquo; k&amp;rdquo;或&amp;ldquo; K&amp;rdquo; ）</target>
        </trans-unit>
        <trans-unit id="4d28a339cbae1f464fa994976dfeef2db93a1d7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/&lt;/code&gt; template character allows packing and unpacking of a sequence of items where the packed structure contains a packed item count followed by the packed items themselves. This is useful when the structure you're unpacking has encoded the sizes or repeat counts for some of its fields within the structure itself as separate fields.</source>
          <target state="translated">该 &lt;code&gt;/&lt;/code&gt; 模板性质允许包装和项目的序列，其中的填充结构包含打包项目计数，然后打包项目本身的拆包。当您要拆包的结构将其内部某些字段的大小或重复计数编码为单独的字段时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="11f550725d5f2471c6ff447b2d5f1594f1eb63d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/a&lt;/code&gt; modifier, available starting in Perl 5.14, is used to restrict the matches of &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; to just those in the ASCII range. It is useful to keep your program from being needlessly exposed to full Unicode (and its accompanying security considerations) when all you want is to process English-like text. (The &quot;a&quot; may be doubled, &lt;code&gt;/aa&lt;/code&gt;, to provide even more restrictions, preventing case-insensitive matching of ASCII with non-ASCII characters; otherwise a Unicode &quot;Kelvin Sign&quot; would caselessly match a &quot;k&quot; or &quot;K&quot;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8377a1a6991c29f230dc12ce290846f6b362ebc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/a&lt;/code&gt; modifier, on the other hand, may be useful. Its purpose is to allow code that is to work mostly on ASCII data to not have to concern itself with Unicode.</source>
          <target state="translated">的 &lt;code&gt;/a&lt;/code&gt; 改性剂，在另一方面，可能是有用的。其目的是使主要用于ASCII数据的代码不必与Unicode有关。</target>
        </trans-unit>
        <trans-unit id="4128278fcab003f758fd62a9e37cfc1e76abe115" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/a&lt;/code&gt;, &lt;code&gt;/d&lt;/code&gt;, &lt;code&gt;/l&lt;/code&gt;, and &lt;code&gt;/u&lt;/code&gt; modifiers (added in Perl 5.14) control the character set rules, but &lt;code&gt;/a&lt;/code&gt; is the only one you are likely to want to specify explicitly; the other three are selected automatically by various pragmas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d46362c6dee371fc1e41d5a94fbe9c509a82363" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/d&lt;/code&gt;, &lt;code&gt;/u&lt;/code&gt; , and &lt;code&gt;/l&lt;/code&gt; modifiers are not likely to be of much use to you, and so you need not worry about them very much. They exist for Perl's internal use, so that complex regular expression data structures can be automatically serialized and later exactly reconstituted, including all their nuances. But, since Perl can't keep a secret, and there may be rare instances where they are useful, they are documented here.</source>
          <target state="translated">将 &lt;code&gt;/d&lt;/code&gt; ， &lt;code&gt;/u&lt;/code&gt; ，和 &lt;code&gt;/l&lt;/code&gt; 修饰符不可能多大用处给你的，所以你不必对他们非常担心。它们存在的目的是供Perl内部使用，因此可以自动序列化复杂的正则表达式数据结构，并在以后对其进行精确重构，包括所有细微差别。但是，由于Perl不能保密，并且在少数情况下它们很有用，因此在此处进行了说明。</target>
        </trans-unit>
        <trans-unit id="12ab225e2a1f0826b5de7058218cdd1f025dae16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/d&lt;/code&gt;, &lt;code&gt;/u&lt;/code&gt;, and &lt;code&gt;/l&lt;/code&gt; modifiers are not likely to be of much use to you, and so you need not worry about them very much. They exist for Perl's internal use, so that complex regular expression data structures can be automatically serialized and later exactly reconstituted, including all their nuances. But, since Perl can't keep a secret, and there may be rare instances where they are useful, they are documented here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a635bd3deb5f6d1f8ced7e30d0ca4af436ee119" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/e&lt;/code&gt; will also silently ignore violations of strict, replacing undefined variable names with the empty string. Since I'm using the &lt;code&gt;/e&lt;/code&gt; flag (twice even!), I have all of the same security problems I have with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; in its string form. If there's something odd in &lt;code&gt;$foo&lt;/code&gt; , perhaps something like &lt;code&gt;@{[ &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; &quot;rm -rf /&quot; ]}&lt;/code&gt; , then I could get myself in trouble.</source>
          <target state="translated">该 &lt;code&gt;/e&lt;/code&gt; 也将忽略这些违规行为的严格，用空字符串替换未定义的变量名。由于我正在使用 &lt;code&gt;/e&lt;/code&gt; 标志（甚至是两次！），因此我遇到了与字符串形式的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 相同的所有安全问题。如果 &lt;code&gt;$foo&lt;/code&gt; 有些奇怪的东西，也许像 &lt;code&gt;@{[ &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; &quot;rm -rf /&quot; ]}&lt;/code&gt; ，那么我可能会遇到麻烦。</target>
        </trans-unit>
        <trans-unit id="b81362cf7da8bf9fa9ba69433decc106d6e660e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/e&lt;/code&gt; will also silently ignore violations of strict, replacing undefined variable names with the empty string. Since I'm using the &lt;code&gt;/e&lt;/code&gt; flag (twice even!), I have all of the same security problems I have with &lt;code&gt;eval&lt;/code&gt; in its string form. If there's something odd in &lt;code&gt;$foo&lt;/code&gt;, perhaps something like &lt;code&gt;@{[ system &quot;rm -rf /&quot; ]}&lt;/code&gt;, then I could get myself in trouble.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613bcc3a2284ecc4926054a5b934f30e880d5007" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/g&lt;/code&gt; modifier specifies global pattern matching--that is, matching as many times as possible within the string. How it behaves depends on the context. In list context, it returns a list of the substrings matched by any capturing parentheses in the regular expression. If there are no parentheses, it returns a list of all the matched strings, as if there were parentheses around the whole pattern.</source>
          <target state="translated">The &lt;code&gt;/g&lt;/code&gt; modifier specifies global pattern matching--that is, matching as many times as possible within the string. How it behaves depends on the context. In list context, it returns a list of the substrings matched by any capturing parentheses in the regular expression. If there are no parentheses, it returns a list of all the matched strings, as if there were parentheses around the whole pattern.</target>
        </trans-unit>
        <trans-unit id="987314591903795033c1fec25347d7b594aec577" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/l&lt;/code&gt; and &lt;code&gt;/u&lt;/code&gt; modifiers are automatically selected for regular expressions compiled within the scope of various pragmas, and we recommend that in general, you use those pragmas instead of specifying these modifiers explicitly. For one thing, the modifiers affect only pattern matching, and do not extend to even any replacement done, whereas using the pragmas give consistent results for all appropriate operations within their scopes. For example,</source>
          <target state="translated">在 &lt;code&gt;/l&lt;/code&gt; 和 &lt;code&gt;/u&lt;/code&gt; 修饰符自动选择不同的编译指示的范围之内编译的正则表达式，我们建议在一般情况下，您使用的，而不是明确指定这些修饰的编译指示。一方面，修饰符仅影响模式匹配，甚至不会扩展到任何已完成的替换，而使用编译指示可在其范围内为所有适当的操作提供一致的结果。例如，</target>
        </trans-unit>
        <trans-unit id="2a3e23c2d6681fc3d86e431f129513cbcb6ae252" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/l&lt;/code&gt; and &lt;code&gt;/u&lt;/code&gt; modifiers are automatically selected for regular expressions compiled within the scope of various pragmas, and we recommend that in general, you use those pragmas instead of specifying these modifiers explicitly. For one thing, the modifiers affect only pattern matching, and do not extend to even any replacement done, whereas using the pragmas gives consistent results for all appropriate operations within their scopes. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a222e38b5a40a1bf140094ce44f5b0c1b82a0ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/o&lt;/code&gt; option for regular expressions (documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt;) tells Perl to compile the regular expression only once. This is only useful when the pattern contains a variable. Perls 5.6 and later handle this automatically if the pattern does not change.</source>
          <target state="translated">正则表达式的 &lt;code&gt;/o&lt;/code&gt; 选项（在&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;和&lt;a href=&quot;perlreref&quot;&gt;perlreref中有说明&lt;/a&gt;）告诉Perl仅一次编译正则表达式。仅在模式包含变量时才有用。如果模式不变，Perls 5.6和更高版本将自动处理此问题。</target>
        </trans-unit>
        <trans-unit id="02f1967b4475720a962bf35cfc3049c63165e0f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/x&lt;/code&gt; modifier causes whitespace to be ignored in a regex pattern (except in a character class and a few other places), and also allows you to use normal comments there, too. As you can imagine, whitespace and comments help a lot.</source>
          <target state="translated">该 &lt;code&gt;/x&lt;/code&gt; 修改原因空白在正则表达式模式被忽略（除了在字符类和其他几个地方），也可以让你有使用普通的意见了。您可以想象，空格和注释会很有帮助。</target>
        </trans-unit>
        <trans-unit id="26a965e97d532904de76cbb5ec7fa62c78040c70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0x&lt;/code&gt; prefix means a hexadecimal number, the digits are 0-9</source>
          <target state="translated">该 &lt;code&gt;0x&lt;/code&gt; 前缀是指一个十六进制数，数字0-9</target>
        </trans-unit>
        <trans-unit id="c084ffd08879b68d48b86f14b0edd6d007fd471f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; tag, now discouraged, is the old version of &lt;code&gt;:bsd_glob&lt;/code&gt; . It exports the same constants and functions, but its glob() override does not support iteration; it returns the last file name in scalar context. That means this will loop forever:</source>
          <target state="translated">现在不建议使用 &lt;code&gt;:&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 标记，它是 &lt;code&gt;:bsd_glob&lt;/code&gt; 的旧版本。它导出相同的常量和函数，但其​​glob（）覆盖不支持迭代；它返回标量上下文中的最后一个文件名。这意味着它将永远循环：</target>
        </trans-unit>
        <trans-unit id="4231c54d461bf5e25a3f991c3ecf987daad7c115" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:ALL&lt;/code&gt; tag will get all of the above exports.</source>
          <target state="translated">的 &lt;code&gt;:ALL&lt;/code&gt; 标签将得到所有上述出口。</target>
        </trans-unit>
        <trans-unit id="f4ffb1e41b5af144e1e66d6009daba34fcfe78d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bsd_glob&lt;/code&gt; export tag exports bsd_glob() and the constants listed below. It also overrides glob() in the calling package with one that behaves like bsd_glob() with regard to spaces (the space is treated as part of a file name), but supports iteration in scalar context; i.e., it preserves the core function's feature of returning the next item each time it is called.</source>
          <target state="translated">的 &lt;code&gt;:bsd_glob&lt;/code&gt; 出口标签出口bsd_glob（）和下面列出的常量。它还用一个在行为方面类似于bsd_glob（）的行为覆盖调用包中的glob（）（该空间被视为文件名的一部分），但在标量上下文中支持迭代。即，它保留了核心函数每次调用时返回下一个项目的功能。</target>
        </trans-unit>
        <trans-unit id="e5933b7ecdff0d26d0d1ee137373273e087ab3ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt; , &lt;code&gt;:crlf&lt;/code&gt; , &lt;code&gt;:utf8&lt;/code&gt; , and any other directives of the form &lt;code&gt;:...&lt;/code&gt; , are called I/O</source>
          <target state="translated">的 &lt;code&gt;:bytes&lt;/code&gt; ， &lt;code&gt;:crlf&lt;/code&gt; ， &lt;code&gt;:utf8&lt;/code&gt; 和形式的任何其他指令 &lt;code&gt;:...&lt;/code&gt; ...，被称为I / O</target>
        </trans-unit>
        <trans-unit id="586c160f0002e3dc300faf81c49d6dc770a315b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt; layer corresponds to &quot;binary mode&quot; and the &lt;code&gt;:crlf&lt;/code&gt; layer corresponds to &quot;text mode&quot; on platforms that distinguish between the two modes when opening files (which is many DOS-like platforms, including Windows). These two layers are no-ops on platforms where binmode() is a no-op, but perform their functions everywhere if PerlIO is enabled.</source>
          <target state="translated">的 &lt;code&gt;:bytes&lt;/code&gt; 层对应于&amp;ldquo;二进制模式&amp;rdquo;和 &lt;code&gt;:crlf&lt;/code&gt; 层对应于&amp;ldquo;文本模式&amp;rdquo;上打开文件时（这是DOS状许多平台，包括Windows）在两种模式之间区分的平台。在binmode（）是无操作的平台上，这两层是无操作的，但是如果启用了PerlIO，则在任何地方都将执行其功能。</target>
        </trans-unit>
        <trans-unit id="11a84ca57962b97df10238d25c4ab7c8ca38ba9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt;, &lt;code&gt;:crlf&lt;/code&gt;, &lt;code&gt;:utf8&lt;/code&gt;, and any other directives of the form &lt;code&gt;:...&lt;/code&gt;, are called I/O</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6da40dddc20e97c2aa930b3dff507bcb27589f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:default&lt;/code&gt; bundle represents the feature set that is enabled before any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature&lt;/code&gt; declaration.</source>
          <target state="translated">的 &lt;code&gt;:default&lt;/code&gt; 捆绑表示之前的任何启用该功能集 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature&lt;/code&gt; 的声明。</target>
        </trans-unit>
        <trans-unit id="09364c3e01a418de2009247f52456634c275c2f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:default&lt;/code&gt; bundle represents the feature set that is enabled before any &lt;code&gt;use feature&lt;/code&gt; or &lt;code&gt;no feature&lt;/code&gt; declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="229b3ff64bd12a209b4e991d14388add7cc976a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:glob&lt;/code&gt; tag, now discouraged, is the old version of &lt;code&gt;:bsd_glob&lt;/code&gt;. It exports the same constants and functions, but its glob() override does not support iteration; it returns the last file name in scalar context. That means this will loop forever:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a790449d8cd7160d313e0f6fd7d2b5f5cd711410" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_external&lt;/code&gt; requires one boolean argument.</source>
          <target state="translated">的 &lt;code&gt;:gzip_external&lt;/code&gt; 需要一个boolean变量。</target>
        </trans-unit>
        <trans-unit id="bc95aee8e2b941e818640ac51c8f3c3052958780" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_external&lt;/code&gt; requires one string argument.</source>
          <target state="translated">的 &lt;code&gt;:gzip_external&lt;/code&gt; 需要一个字符串参数。</target>
        </trans-unit>
        <trans-unit id="d6ef1d12b23a99b06dce59bf86591d40b628073e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_read_open&lt;/code&gt; argument must end with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;&quot;USING THE EXTERNAL GZIP&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c0f5f557ffbe0666f0dfcd916d2b61a638ef52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_read_open&lt;/code&gt; argument must end with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;USING THE EXTERNAL GZIP&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;:gzip_read_open&lt;/code&gt; 参数必须与管道标识尾部（|），并有 &lt;code&gt;%s&lt;/code&gt; 作为文件名。请参阅&lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;使用外部GZIP&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c09f18a82aa110a317c88049c0e7c4128399d22c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_write_open&lt;/code&gt; argument must begin with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. An output redirect (&amp;gt;) is also often a good idea, depending on your operating system shell syntax. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;&quot;USING THE EXTERNAL GZIP&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740fe127c4ced02d559ebb2a859c745ac796eb7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_write_open&lt;/code&gt; argument must begin with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. An output redirect (&amp;gt;) is also often a good idea, depending on your operating system shell syntax. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;USING THE EXTERNAL GZIP&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;:gzip_write_open&lt;/code&gt; 参数必须与管道符号开头（|），并有 &lt;code&gt;%s&lt;/code&gt; 作为文件名。根据您的操作系统外壳语法，输出重定向（&amp;gt;）通常也是个好主意。请参阅&lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;使用外部GZIP&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="244205effe1c86456dd4171100ec82efbb0324f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; does not currently work with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;, only with the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma. The &lt;code&gt;:utf8&lt;/code&gt; and &lt;code&gt;:encoding(...)&lt;/code&gt; methods do work with all of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;, and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma.</source>
          <target state="translated">在 &lt;code&gt;:locale&lt;/code&gt; 目前没有一起工作 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; ，仅与 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 编译。的 &lt;code&gt;:utf8&lt;/code&gt; 和 &lt;code&gt;:encoding(...)&lt;/code&gt; 方法做了所有工作 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; ，和 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 编译。</target>
        </trans-unit>
        <trans-unit id="868d235ace169d2c7fa342c5a97f5b35d506dd95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; does not currently work with &lt;code&gt;open()&lt;/code&gt; and &lt;code&gt;binmode()&lt;/code&gt;, only with the &lt;code&gt;open&lt;/code&gt; pragma. The &lt;code&gt;:utf8&lt;/code&gt; and &lt;code&gt;:encoding(...)&lt;/code&gt; methods do work with all of &lt;code&gt;open()&lt;/code&gt;, &lt;code&gt;binmode()&lt;/code&gt;, and the &lt;code&gt;open&lt;/code&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a7c262fbc0be9a9844fe48c62a845c0f4528fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; sub-pragma</source>
          <target state="translated">在 &lt;code&gt;:locale&lt;/code&gt; 子编译</target>
        </trans-unit>
        <trans-unit id="90148b6fce0bbabdeb9d2a0e71e782bdff20ba4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:mmap&lt;/code&gt; layer will not exist if the platform does not support &lt;code&gt;mmap()&lt;/code&gt; .</source>
          <target state="translated">的 &lt;code&gt;:mmap&lt;/code&gt; 如果平台不支持层将不存在 &lt;code&gt;mmap()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81e4222eb657623bdd73dc5a2ea005b2d704479c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:mmap&lt;/code&gt; layer will not exist if the platform does not support &lt;code&gt;mmap()&lt;/code&gt;. See &lt;a href=&quot;PerlIO::mmap&quot;&gt;PerlIO::mmap&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd944a87b4f64134b2d5190fde7ca74a27bd05a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:raw&lt;/code&gt; layer is</source>
          <target state="translated">的 &lt;code&gt;:raw&lt;/code&gt; 层是</target>
        </trans-unit>
        <trans-unit id="9474a45f1b69ac0f4649940b34d53df78423a114" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:raw&lt;/code&gt; pseudo-layer is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8af45fe08808536fe0e78893d59ec120f251eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:std&lt;/code&gt; subpragma on its own has no effect, but if combined with the &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding&lt;/code&gt; subpragmas, it converts the standard filehandles (STDIN, STDOUT, STDERR) to comply with encoding selected for input/output handles. For example, if both input and out are chosen to be &lt;code&gt;:encoding(utf8)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; will mean that STDIN, STDOUT, and STDERR are also in &lt;code&gt;:encoding(utf8)&lt;/code&gt; . On the other hand, if only output is chosen to be in &lt;code&gt;:encoding(koi8r)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; will cause only the STDOUT and STDERR to be in &lt;code&gt;koi8r&lt;/code&gt; . The &lt;code&gt;:locale&lt;/code&gt; subpragma implicitly turns on &lt;code&gt;:std&lt;/code&gt; .</source>
          <target state="translated">的 &lt;code&gt;:std&lt;/code&gt; 自身subpragma没有效果，但如果与组合 &lt;code&gt;:utf8&lt;/code&gt; 或 &lt;code&gt;:encoding&lt;/code&gt; subpragmas，将其转换的标准文件句柄（STDIN，STDOUT STDERR）遵守用编码选择用于输入/输出的把手。例如，如果输入和输出都选择为 &lt;code&gt;:encoding(utf8)&lt;/code&gt; ，则 &lt;code&gt;:std&lt;/code&gt; 表示STDIN，STDOUT和STDERR也位于 &lt;code&gt;:encoding(utf8)&lt;/code&gt; 中。另一方面，如果仅选择在 &lt;code&gt;:encoding(koi8r)&lt;/code&gt; 中输出，则 &lt;code&gt;:std&lt;/code&gt; 将仅导致STDOUT和STDERR进入 &lt;code&gt;koi8r&lt;/code&gt; 。该 &lt;code&gt;:locale&lt;/code&gt; subpragma隐含开启 &lt;code&gt;:std&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2743b792818bf7f895d0f0b22baae763060aa81f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:void&lt;/code&gt; option is supported in &lt;a href=&quot;fatal&quot;&gt;Fatal&lt;/a&gt;, but not &lt;code&gt;autodie&lt;/code&gt; . To workaround this, &lt;code&gt;autodie&lt;/code&gt; may be explicitly disabled until the end of the current block with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; . To disable autodie for only a single function (eg, open) use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(open)&lt;/code&gt; .</source>
          <target state="translated">的 &lt;code&gt;:void&lt;/code&gt; 选项在支持&lt;a href=&quot;fatal&quot;&gt;致命&lt;/a&gt;，但不 &lt;code&gt;autodie&lt;/code&gt; 。要解决此， &lt;code&gt;autodie&lt;/code&gt; 可以明确地禁用，直到与当前块的末尾 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; 。要仅对单个功能（例如open）禁用autodie，请 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(open)&lt;/code&gt; 使用autodie qw（open）。</target>
        </trans-unit>
        <trans-unit id="0969ef951925275c4d8bd4c9c51662e300f9c641" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:void&lt;/code&gt; option is supported in &lt;a href=&quot;fatal&quot;&gt;Fatal&lt;/a&gt;, but not &lt;code&gt;autodie&lt;/code&gt;. To workaround this, &lt;code&gt;autodie&lt;/code&gt; may be explicitly disabled until the end of the current block with &lt;code&gt;no autodie&lt;/code&gt;. To disable autodie for only a single function (eg, open) use &lt;code&gt;no autodie qw(open)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67318be992f4377bb68fbe49ed99f910c657a047" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method is used to create an instance of the filter. It is called indirectly by Perl when it encounters the &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; MyFilter&lt;/code&gt; line in a source file (See &lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt; for more details on &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法用于创建过滤器的一个实例。当Perl 在源文件中遇到 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; MyFilter&lt;/code&gt; 行时，它会间接调用它（有关&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;的更多详细信息，请参见 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="69849addd7818fee9c7e8c167a05d6c0d2986859" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; will</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 意志</target>
        </trans-unit>
        <trans-unit id="0eafa6355d483056647b2819a7f67215461c3497" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call returns an object, say &lt;code&gt;$o&lt;/code&gt; . You may call</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用返回的对象，说 &lt;code&gt;$o&lt;/code&gt; 。你可以打电话</target>
        </trans-unit>
        <trans-unit id="51ffe3fc21c6601c2932126d4f4eca5123604eda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; 构建体也可用于阵列/散列元素的删除定位于当前块。请参见&lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsub中复合类型元素的局部删除&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1621ad946434d6c08e6becea5950298e8d654de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; 构建本地化的缺失在运行时当前块。在该块退出之前，暂时删除的本地元素不再存在。请参见&lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsub中复合类型元素的局部删除&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="413b32076323a1b9dc32ef8307740eba59479274" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function executes a system command</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 功能执行系统命令</target>
        </trans-unit>
        <trans-unit id="2195a8cff19304cef2dc99fbcce68cf6dbdaf4fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; function is not implemented on all versions of Windows. Check the documentation for your specific version of Perl.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 函数未在所有的Windows版本中实现。查看文档以了解特定版本的Perl。</target>
        </trans-unit>
        <trans-unit id="1cc7a7cd989d44101ffb59063ba0d9ec90f901e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; operator will attempt to insure that no translation of carriage control occurs on input from or output to this filehandle. Since this involves reopening the file and then restoring its file position indicator, if this function returns FALSE, the underlying filehandle may no longer point to an open file, or may point to a different position in the file than before &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 操作者将试图确保没有托架控制的翻译从输入或输出到该文件句柄发生。由于这涉及到重新打开文件然后恢复其文件位置指示符，因此，如果此函数返回FALSE，则底层文件句柄可能不再指向打开的文件，或者可能指向文件中与调用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 之前不同的位置。</target>
        </trans-unit>
        <trans-unit id="d7b9155394683e2730126a87d41bdd8b7ec8ee0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; functions work on whole characters.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; 函数对整个人物的工作。</target>
        </trans-unit>
        <trans-unit id="b8d018fd592275cef4c6f8f9148b669393d46ef8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; operator uses the &lt;code&gt;sys$hash_password&lt;/code&gt; system service to generate the hashed representation of PLAINTEXT. If USER is a valid username, the algorithm and salt values are taken from that user's UAF record. If it is not, then the preferred algorithm and a salt of 0 are used. The quadword encrypted value is returned as an 8-character string.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; 操作员使用 &lt;code&gt;sys$hash_password&lt;/code&gt; 系统服务产生明文的哈希表示。如果USER是有效的用户名，则算法和盐值将从该用户的UAF记录中获取。如果不是，则使用首选算法和盐0。四字加密值以8个字符的字符串形式返回。</target>
        </trans-unit>
        <trans-unit id="51567ba352ff0d9256d32ae3d4a4cc5e55c3b1bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; 构建体也可用于阵列/散列元素的删除定位于当前块。请参见&lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsub中复合类型元素的局部删除&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="205f4f4c053e1354b5fd41e9a973041210cd6cb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; 构建本地化的缺失在运行时当前块。在该块退出之前，暂时删除的本地元素不再存在。请参见&lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;perlsub中复合类型元素的局部删除&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c330ed0d1614413aef6482d1172074b901ca8ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; construct isn't a real loop that you can use loop control on.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; 构造是不是一个真正的循环，你可以使用闭环控制。</target>
        </trans-unit>
        <trans-unit id="bf5bbfe9093c8abccc03e7c7efe8dbe3d8e0233d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; operator can be a bit tricky though. You can't add or delete keys of the hash while you're using it without possibly skipping or re-processing some pairs after Perl internally rehashes all of the elements. Additionally, a hash has only one iterator, so if you mix &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; on the same hash, you risk resetting the iterator and messing up your processing. See the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; entry in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="translated">尽管 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; 运算符可能有些棘手。在使用散列时，您不能添加或删除散列的键，而在Perl内部对所有元素进行重新散列后，可能无法跳过或重新处理某些对。另外，一个哈希只有一个迭代器，因此，如果您在同一哈希中混合使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; ，则可能会重置迭代器并弄乱您的处理。有关更多详细信息，请参见&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;的 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="6a7ce17abb69e82a8250b438247bf503d68963f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; operator returns the pairs in apparently random order, so if ordering matters to you, you'll have to stick with the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 操作员返回显然随机顺序对，所以如果排序的问题给你，你必须坚持与 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 的方法。</target>
        </trans-unit>
        <trans-unit id="1d704aced95cc8764eb35404aac65f2304fbf2d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; method wrapped an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; around a &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;, and so waited for a thread to exit, passing along any values the thread might have returned and placing any errors into &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 方法包裹的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 周围 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; ，所以等待线程退出，沿着螺纹可能返回的任何值传递和放置任何错误到 &lt;code&gt;$@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80c53083069f05797eef5848d626cca139bde071" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; feature enables the &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; keyword, which evaluates the argument passed to it as a string of bytes. It dies if the string contains any characters outside the 8-bit range. Source filters work within &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt;: they apply to the contents of the string being evaluated.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; 特征使 &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; 关键字，其评估传递给它作为字节串的论点。如果该字符串包含8位范围以外的任何字符，它将终止。源过滤器在 &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; 内工作：它们适用于要评估的字符串的内容。</target>
        </trans-unit>
        <trans-unit id="013c20c8a39c1e9d213753c8f42aa60136c4133a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function executes a system command</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 功能执行系统命令</target>
        </trans-unit>
        <trans-unit id="cc6b445e37f9fe0173dc131ac1ed2864194322f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function's job is to turn your process into another command and never to return. If that's not what you want to do, don't use &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;. :)</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 功能的任务是把你的过程到另一个命令，并再也没有回来。如果那不是您想要的，请不要使用 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 。:)</target>
        </trans-unit>
        <trans-unit id="c64c8f5547bb2a6573770267608423f5c2aa4dc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for(each)&lt;/a&gt;&lt;/code&gt; modifier is an iterator: it executes the statement once for each item in the LIST (with &lt;code&gt;$_&lt;/code&gt; aliased to each item in turn).</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for(each)&lt;/a&gt;&lt;/code&gt; 修饰符是一个迭代器：它执行该语句一次列表中的每个项目（以 &lt;code&gt;$_&lt;/code&gt; 又化名为每个项目）。</target>
        </trans-unit>
        <trans-unit id="fcbb7f06dac39b4543299760a90086a0717180ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; 功能，即使只需要一个说法，有一个列表操作符的优先级，所以要小心：</target>
        </trans-unit>
        <trans-unit id="d7025a8a8790fde9485d755f6c425f01c04b8467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; operator will function properly if you have a working CRTL &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; routine, or if the logical name SYS$TIMEZONE_DIFFERENTIAL is defined as the number of seconds which must be added to UTC to yield local time. (This logical name is defined automatically if you are running a version of VMS with built-in UTC support.) If neither of these cases is true, a warning message is printed, and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 的，如果你有一个工作CRTL运营商将正常工作 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 程序，或者如果逻辑名SYS $ TIMEZONE_DIFFERENTIAL定义为必须添加到UTC以获得本地时间的秒数。 （如果您正在运行具有内置UTC支持的VMS版本，则将自动定义此逻辑名。）如果以上两种情况均不成立，则将显示警告消息，并返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a3ff2f4c2a7967681e4811d9bc792e927dbfcbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by local()) and immediately calls in its place the named subroutine using the current value of @_. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; 形式从其他形式的完全不同的 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 。实际上，从根本上说，它根本不是goto，也没有与其他goto相关的污名。而是，它退出当前子例程（丢失由local（）设置的任何更改），并立即使用@_的当前值在其位置调用命名子例程。希望加载另一个子例程的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 子例程使用此方法，然后假装首先调用了另一个子例程（除了当前子例程中对 &lt;code&gt;@_&lt;/code&gt; 的任何修改都会传播到另一个子例程。） &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 之后，甚至没有 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 就能知道该例程首先被调用。</target>
        </trans-unit>
        <trans-unit id="8c6cdb8b9140a3413b924a1be37defd8094c23ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , below. This is especially useful for implementing tail recursion via &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 形式预计评价 &lt;code&gt;EXPR&lt;/code&gt; 到代码引用或标签名称。如果它评估为代码引用，则将像下面的 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; 一样进行处理。这对于通过 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; 实现尾递归特别有用。</target>
        </trans-unit>
        <trans-unit id="f9a08aec53b4872b20c38601dfe1ff47bb7271a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; in other languages.)</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; 形式发现标有LABEL的语句，并继续执行那里。它不能用于退出给 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 指定的块或子例程。它可以用于动态范围内的几乎所有其他地方，包括子例程之外的其他地方，但是通常最好使用诸如 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 的其他构造。 Perl的作者从未感觉过需要使用这种形式的 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; （在Perl中，C是另一回事）。 （不同之处在于C不提供与循环控制相结合的命名循环。Perl则提供了此功能，并且它替换了其他语言中 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 的大多数结构化用法。）</target>
        </trans-unit>
        <trans-unit id="fd5e7141b6809acf60b4ffb9ca0527589ab4d1fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-&amp;amp;NAME form is highly magical, and substitutes a call to the named subroutine for the currently running subroutine. This is used by &lt;code&gt;AUTOLOAD()&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; - ＆名称形式是非常神奇的，并替换为当前运行的子程序命名子程序调用。 &lt;code&gt;AUTOLOAD()&lt;/code&gt; 子例程使用此方法，该子例程希望加载另一个子例程，然后假装首先调用了另一个子例程（除了当前子例程中对 &lt;code&gt;@_&lt;/code&gt; 的任何修改都会传播到另一个子例程。） &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; ，甚至 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 都不会知道该例程是首先被调用的。</target>
        </trans-unit>
        <trans-unit id="0f2fbb144491503128d3d631573fe99dbb58cb74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-EXPR form expects a label name, whose scope will be resolved dynamically. This allows for computed &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -expr形式需要一个标签名称，其范围将动态解析。这允许每个FORTRAN 计算 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; ，但是如果您要针对可维护性进行优化，则不一定建议这样做：</target>
        </trans-unit>
        <trans-unit id="747fd1051ce1561b7aad0a462ec80a7083e807f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-LABEL form finds the statement labeled with LABEL and resumes execution there. It may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is--C is another matter).</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -label形式发现标有LABEL的语句，并继续执行那里。它可能不能用于需要初始化的任何构造，例如子例程或 &lt;code&gt;foreach&lt;/code&gt; 循环。也不能将其用于经过优化的结构。它可以用于动态范围内的几乎所有其他地方，包括子例程之外的其他地方，但是通常最好使用诸如 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 的其他构造。Perl的作者从未感到需要使用这种形式的 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; （在Perl中，C是另一回事）。</target>
        </trans-unit>
        <trans-unit id="b3e30e59d91f75eda248244fb51004176883c63f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in scalar context returns the count. If you want the list of matching items, just use it in list context instead:</source>
          <target state="translated">标量上下文中的 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 返回计数。如果您想要匹配项的列表，只需在列表上下文中使用它即可：</target>
        </trans-unit>
        <trans-unit id="612dabc89cee10beadc6c980b04dfdba8cc2e280" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; function also resets the iterator, which means that you may see strange results if you use this between uses of other hash operators such as &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; 函数还复位迭代，这意味着可能会看到奇怪的结果如果使用这种其它散列运营商的使用之间，例如 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84a92b66f23e84ffcea0f8036601109332768c0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; function can be used to test this functionality from within a program.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 功能可用于在程序中测试此功能。</target>
        </trans-unit>
        <trans-unit id="8f9dd8be24cd7b207201afca586d0393221c8761" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; function in the parent's &lt;code&gt;if&lt;/code&gt; block is there to send a signal to our child process, currently running in the &lt;code&gt;else&lt;/code&gt; block, as soon as the remote server has closed its end of the connection.</source>
          <target state="translated">远程服务器关闭连接结束后，父级 &lt;code&gt;if&lt;/code&gt; 块中的 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 函数就会向当前在 &lt;code&gt;else&lt;/code&gt; 块中运行的子进程发送信号。</target>
        </trans-unit>
        <trans-unit id="8bfb3b07d45ff01232bb221af626a6a5fb4ea5a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command immediately exits the loop in question. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 命令立即退出有问题的循环。在 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，如果有的话，不执行：</target>
        </trans-unit>
        <trans-unit id="ac302bdab0f919a07174f63d0969bebc85f1b892" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 命令是像 &lt;code&gt;break&lt;/code&gt; 在C（如在循环使用）语句; 它立即退出有问题的循环。如果省略了LABEL，则该命令引用最里面的封闭循环。从Perl 5.18.0开始可用的 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; 格式允许在运行时计算标签名称，否则与 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; 相同。在 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，如果有的话，不执行：</target>
        </trans-unit>
        <trans-unit id="506963259280dc353e83831a1d7243717b046918" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; Keyword</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; 关键字</target>
        </trans-unit>
        <trans-unit id="249bfee98e5c2e5ddbdeda77c1a70bb97c684fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; function takes a shared variable and puts a lock on it. No other thread may lock the variable until the variable is unlocked by the thread holding the lock. Unlocking happens automatically when the locking thread exits the block that contains the call to the &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; function. Using &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; is straightforward: This example has several threads doing some calculations in parallel, and occasionally updating a running total:</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; 函数获得一个共享变量，并把锁就可以了。直到持有锁的线程将变量解锁，其他线程才可以锁定该变量。当锁定线程退出包含对 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; 函数的调用的块时，将自动进行解锁。使用 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; 很简单：此示例有多个线程并行执行一些计算，并偶尔更新运行总计：</target>
        </trans-unit>
        <trans-unit id="844dd628839d69aa91981cfdf9d35b8aa941b210" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; is actually not required; you could just use:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 实际上不是必需的; 您可以使用：</target>
        </trans-unit>
        <trans-unit id="15c7027f68a72fedc245e7d612cf00a82d9df24d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; is simply a modifier on something you might assign to. So when you do assign to variables in its argument list, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; doesn't change whether those variables are viewed as a scalar or an array. So</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 简直就是一些你可能分配给修饰符。因此，当您在其参数列表中分配变量时，无论变量被视为标量还是数组， &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 都不会改变。所以</target>
        </trans-unit>
        <trans-unit id="82cb7d6fd4d7d98853ace6ba4000362cdc7fa762" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; operator declares the listed variables to be lexically confined to the enclosing block, conditional (&lt;code&gt;if/unless/elsif/else&lt;/code&gt;), loop (&lt;code&gt;for/foreach/while/until/continue&lt;/code&gt;), subroutine, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do/require/use&lt;/a&gt;&lt;/code&gt;'d file. If more than one value is listed, the list must be placed in parentheses. All listed elements must be legal lvalues. Only alphanumeric identifiers may be lexically scoped--magical built-ins like &lt;code&gt;$/&lt;/code&gt; must currently be &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized with &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 操作声明中列出的变量是词法仅限于封闭块，条件（ &lt;code&gt;if/unless/elsif/else&lt;/code&gt; ），循环（ &lt;code&gt;for/foreach/while/until/continue&lt;/code&gt; ），子程序， &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，或 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do/require/use&lt;/a&gt;&lt;/code&gt; 的文件。如果列出了多个值，则该列表必须放在括号中。所有列出的元素必须是合法的左值。只有字母数字标识符可以词法范围-神奇的内置插件类似 &lt;code&gt;$/&lt;/code&gt; 当前必须 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 与美化版 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="598c24981891ed39a33542154be0ea54335c8268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 命令是一样 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 使用C语句; 它开始循环的下一个迭代：</target>
        </trans-unit>
        <trans-unit id="4ac987f577bf457aa0aa7edd6027d43957e00541" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command starts the next iteration of the loop:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 命令开始循环的下一次迭代：</target>
        </trans-unit>
        <trans-unit id="90d027781b9d30c834bc3f75976b8010ac44b08a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keywords work differently.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; ，并 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 关键字的工作方式不同。</target>
        </trans-unit>
        <trans-unit id="5eeb76addad99da0bbdd65d75ec9e60f2b34827f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma doesn't</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 编译不</target>
        </trans-unit>
        <trans-unit id="7bf3b5adc84fde6d734586f4bec0209359aa5187" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; lib&lt;/code&gt; statement deletes all instances of each named directory from @INC.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; lib&lt;/code&gt; 语句删除从@INC每个指定目录的所有实例。</target>
        </trans-unit>
        <trans-unit id="1aa289805fbc7ad3a1863fbfa81d350e063c7221" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;|-&quot;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(BAR, &quot;-|&quot;)&lt;/code&gt; constructs are not yet implemented. This limitation can be easily worked around in new code by creating a pipe explicitly. The following example shows how to write to a forked child:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;|-&quot;)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(BAR, &quot;-|&quot;)&lt;/code&gt; 结构尚未实现。通过显式创建管道，可以在新代码中轻松解决此限制。下面的示例显示了如何写入派生的孩子：</target>
        </trans-unit>
        <trans-unit id="91b6442686235ec3446ecfbcfcc1b68ae5f717df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma serves as one of the interfaces to declare default &quot;layers&quot; (also known as &quot;disciplines&quot;) for all I/O. Any two-argument open(), readpipe() (aka qx//) and similar operators found within the lexical scope of this pragma will use the declared defaults. Even three-argument opens may be affected by this pragma when they don't specify IO layers in MODE.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 的pragma用作接口申报默认&amp;ldquo;层&amp;rdquo;（也称为&amp;ldquo;学科&amp;rdquo;）为所有的I / O中的一个。在此编译指示的词法范围内找到的任何两个参数的open（），readpipe（）（aka qx //）和类似的运算符都将使用声明的默认值。如果未在MODE中指定IO层，则即使是三参数打开也可能会受到此编译指示的影响。</target>
        </trans-unit>
        <trans-unit id="d568cb2b48539b711386365d8e03258e04c0c727" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; functions work transparently on all codepoints, not just on ASCII alone &amp;mdash; nor in fact, not even just on Unicode alone.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 功能上的所有代码点透明地工作，而不仅仅是ASCII单独-也不事实上，甚至不仅仅是对Unicode的孤独。</target>
        </trans-unit>
        <trans-unit id="48c955c71d75929afac22e8dfa9aad63b2004a10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator showed up in perl 5.005. It compiles a regular expression, but doesn't apply it. When you use the pre-compiled version of the regex, perl does less work. In this example, I inserted a &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; to turn each pattern into its pre-compiled form. The rest of the script is the same, but faster:</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 运营商在Perl 5.005露面。它编译一个正则表达式，但不应用它。使用正则表达式的预编译版本时，perl的工作量较少。在此示例中，我插入了一个 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; ，将每个模式转换为其预编译的形式。脚本的其余部分相同，但速度更快：</target>
        </trans-unit>
        <trans-unit id="6086a140e1b37399f10a989a119aa2028d369c83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 命令重新启动循环块，而无需再次评价以下条件。在 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，如果有的话，</target>
        </trans-unit>
        <trans-unit id="362e8253628830d9a4d5614fd639fe79bc546984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;
LABEL&lt;/code&gt; . Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 命令重新启动循环块，而无需再次评价以下条件。在 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，如果有的话，不执行。如果省略了LABEL，则该命令引用最里面的封闭循环。从Perl 5.18.0开始可用的 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; 格式允许在运行时计算标签名称，否则与 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; LABEL&lt;/code&gt; 相同。想要对自己所输入的内容撒谎的程序通常使用以下命令：</target>
        </trans-unit>
        <trans-unit id="f9c130f1621f9ce97dabd985717a6055d0d6afd0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; substitution operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 替换操作在记录&lt;a href=&quot;perlop&quot;&gt;perlop中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="121511ae0b5d1fbb23eba64b638e8a05d463c939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; function is another place where a regexp is used. &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; /regexp/, string, limit&lt;/code&gt; separates the &lt;code&gt;string&lt;/code&gt; operand into a list of substrings and returns that list. The regexp must be designed to match whatever constitutes the separators for the desired substrings. The &lt;code&gt;limit&lt;/code&gt; , if present, constrains splitting into no more than &lt;code&gt;limit&lt;/code&gt; number of strings. For example, to split a string into words, use</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; 函数是其中使用正则表达式另一个地方。 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; /regexp/, string, limit&lt;/code&gt; 将 &lt;code&gt;string&lt;/code&gt; 操作数分成子字符串列表，并返回该列表。必须将正则表达式设计为匹配所需子字符串的分隔符。该 &lt;code&gt;limit&lt;/code&gt; ，如果存在的话，约束分裂成不超过 &lt;code&gt;limit&lt;/code&gt; 数量的字符串。例如，要将字符串拆分为单词，请使用</target>
        </trans-unit>
        <trans-unit id="7f7da5ebd320780203ed7d5e0028f1f486db3bfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword creates a lexical variable (following the same scoping rules as &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;) that persists from one subroutine call to the next. If a state variable resides inside an anonymous subroutine, then each copy of the subroutine has its own copy of the state variable. However, the value of the state variable will still persist between calls to the same copy of the anonymous subroutine. (Don't forget that &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; { ... }&lt;/code&gt; creates a new subroutine each time it is executed.)</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 的关键字创建一个词法变量（以下同范围的规则为 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ）从一个子程序调用一直持续到下一个。如果状态变量驻留在匿名子例程中，则该子例程的每个副本都有其自己的状态变量副本。但是，状态变量的值仍将在两次调用匿名子例程的相同副本之间保持不变。（不要忘记 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; { ... }&lt;/code&gt; 每次执行都会创建一个新的子例程。）</target>
        </trans-unit>
        <trans-unit id="87a4764ce311581074e8327a658c6ee1ed914b66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; probes gain a fourth argument: the package name of the function.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; 探头获得第四个参数：函数的包名。</target>
        </trans-unit>
        <trans-unit id="fa495b532decb2c8f20d40c7506dd35df2aff6f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; built-in is considered to have failed in the following circumstances:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 内置的被认为是失败在下列情况下：</target>
        </trans-unit>
        <trans-unit id="007bfa453d22a010bcc25f103e9e741d0e19770d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; operator creates a subprocess, and passes its arguments to the subprocess for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt; , any valid DCL command string may be specified. If the string begins with '@', it is treated as a DCL command unconditionally. Otherwise, if the first token contains a character used as a delimiter in file specification (e.g. &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt;), an attempt is made to expand it using a default type of</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 操作者创建子进程，和将其参数传递到子进程来执行作为DCL命令。由于子过程是通过 &lt;code&gt;lib$spawn()&lt;/code&gt; 直接创建的，因此可以指定任何有效的DCL命令字符串。如果字符串以&amp;ldquo; @&amp;rdquo;开头，则无条件地将其视为DCL命令。否则，如果第一个标记包含用作文件规范中定界符的字符（例如 &lt;code&gt;:&lt;/code&gt; 或 &lt;code&gt;]&lt;/code&gt; ），则会尝试使用默认类型扩展它</target>
        </trans-unit>
        <trans-unit id="c442498b077f35c1d517c581c1d1aa5d5b6d170c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; function returns elapsed realtime since some point in the past (such as system startup), user and system times for this process, and user and system times used by child processes. All times are returned in clock ticks.</source>
          <target state="translated">自过去某个时间点（例如系统启动）以来， &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; 函数返回经过的实时时间，该进程的用户和系统时间以及子进程使用的用户和系统时间。所有时间都以时钟滴答数返回。</target>
        </trans-unit>
        <trans-unit id="80b97318408e6d656bf28c96d67c4dfdc24c2653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; operator translates whole characters. (Note that the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///CU&lt;/a&gt;&lt;/code&gt; functionality has been removed. For similar functionality to that, see &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('U0', ...)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('C0', ...)&lt;/code&gt; ).</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 运营商整体转换的字符。（请注意， &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///CU&lt;/a&gt;&lt;/code&gt; 功能已删除。有关此功能，请参见 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('U0', ...)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('C0', ...)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="11a568ea0ae08ef300d37d167d740832b4c2b16f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; alternative might look like this:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 的替代可能是这样的：</target>
        </trans-unit>
        <trans-unit id="42f87c254ee8d81cee26e792f60cacaefbfbe36a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; counts the null bytes. The &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; call returns a list of name-value pairs each of which is taken apart in the &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; block.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 计数空字节。该 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 调用返回其中的每一个拆开的名称-值对的列表 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="a53ff006297297281156ad4ddc8aef0830e3811c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; version is a clear winner. One solution is flexible, the other is fast - and it's appropriately the programmer's choice which to use.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 版本是一个明显的赢家。一种解决方案是灵活的，另一种是快速的-使用哪种是程序员的适当选择。</target>
        </trans-unit>
        <trans-unit id="6f47b182b84a1df9e8040499b142da5e15a5a35d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; Gotcha</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 疑难杂症</target>
        </trans-unit>
        <trans-unit id="5e2ca855aa217bd553e610f05dba85cf9019d5da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma disables character semantics for the rest of the lexical scope in which it appears. &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; bytes&lt;/code&gt; can be used to reverse the effect of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; within the current lexical scope.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 编译指示禁止字符语义在它所在的词法作用域的其余部分。在当前词法范围内，不能使用 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; bytes&lt;/code&gt; 来反转 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 的效果。</target>
        </trans-unit>
        <trans-unit id="9fdef637aec2a8c40d4ef4a640873fd3daeaa545" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; filetest&lt;/code&gt; statements affect file tests defined in their block, up to the end of the closest enclosing block (they are lexically block-scoped).</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; filetest&lt;/code&gt; 语句影响对其块中定义，最多到最接近的封闭块的端部（它们是词法块范围的）文件的测试。</target>
        </trans-unit>
        <trans-unit id="8744ea2543ae1b476ba91732c622f01f08c1038b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma tells the Perl parser to allow UTF-8 in the program text in the current lexical scope (allow UTF-EBCDIC on EBCDIC based platforms). The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8&lt;/code&gt; pragma tells Perl to switch back to treating the source text as literal bytes in the current lexical scope.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 编译告诉Perl的解析器允许UTF-8在当前词法范围的程序文本（允许UTF-EBCDIC基于EBCDIC平台）。所述 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8&lt;/code&gt; 编译告诉Perl切换回处理所述源文本作为当前词法作用域字面字节。</target>
        </trans-unit>
        <trans-unit id="43067066e43761608ec314550d1ef0009ca78c23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; switch will warn you if it interprets a reserved word as a string. But it will no longer warn you about using lowercase words, because the string is effectively quoted.</source>
          <target state="translated">如果将保留字解释为字符串，则 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 编译指示或&lt;b&gt;-w&lt;/b&gt;开关将警告您。但这将不再警告您使用小写单词，因为该字符串已被有效引用。</target>
        </trans-unit>
        <trans-unit id="19cdd025fab18dcd164b56bb8b49804d47261c9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma produces some lovely diagnostics. One can also use the &lt;b&gt;-w&lt;/b&gt; flag, but its use is normally discouraged, because it gets applied to all executed Perl code, including that not under your control.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 编译产生一些可爱的诊断。也可以使用&lt;b&gt;-w&lt;/b&gt;标志，但是通常不建议使用&lt;b&gt;-w&lt;/b&gt;标志，因为它会应用于所有已执行的Perl代码，包括不受您控制的代码。</target>
        </trans-unit>
        <trans-unit id="98ff32ffdb1aaec51b5964ab04fedf9b556042ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; 功能，即使只需要一个说法，有一个列表操作符的优先级，所以要小心：</target>
        </trans-unit>
        <trans-unit id="57bb7a10c9bf27aba4e74945efa7f4324ecc8306" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by local()) and immediately calls in its place the named subroutine using the current value of @_. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; 形式从其他形式的完全不同的 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 。实际上，从一般意义上讲，它根本不是goto，也没有与其他goto相关的污名。而是，它退出当前子例程（丢失由local（）设置的任何更改），并立即使用@_的当前值在其位置调用命名子例程。希望加载另一个子例程的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 子例程使用此方法，然后假装首先调用了另一个子例程（除了当前子例程中对 &lt;code&gt;@_&lt;/code&gt; 的任何修改都会传播到另一个子例程。） &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 之后，甚至没有 &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 就能知道该例程首先被调用。</target>
        </trans-unit>
        <trans-unit id="e45cfef5656ef233c1972b6e6db8f04158149f58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , below. This is especially useful for implementing tail recursion via &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 形式预计评价 &lt;code&gt;EXPR&lt;/code&gt; 到代码引用或标签名称。如果它评估为代码引用，则将像下面的 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; 一样进行处理。这对于通过 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; 实现尾部递归特别有用。</target>
        </trans-unit>
        <trans-unit id="a0fba7d2ee7cbb751d9b45951b63706bcd429d8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; in other languages.)</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; 形式发现标有LABEL的语句，并继续执行那里。它不能用于退出给 &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 的块或子例程。它可以用于动态范围内的几乎所有其他地方，包括子例程之外的其他地方，但是通常最好使用其他构造，例如 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 。 Perl的作者从未感到过需要使用这种形式的 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; （在Perl中，C是另一回事）。 （不同之处在于，C不提供与循环控制相结合的命名循环。Perl则提供了这种组合，它替代了其他语言中 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 的大多数结构化用法。）</target>
        </trans-unit>
        <trans-unit id="0ec2144df4bcb647e47e9a3fffb037716e0ff735" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 命令是像 &lt;code&gt;break&lt;/code&gt; 在C（如在循环使用）语句; 它立即退出有问题的循环。如果省略了LABEL，则该命令引用最里面的封闭循环。从Perl 5.18.0开始可用的 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; 格式允许在运行时计算标签名称，否则与 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; 相同。在 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，如果有的话，不执行：</target>
        </trans-unit>
        <trans-unit id="0dc04adeb5f33f6be3e55c3b75049d3460dd5faf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 命令是一样 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 使用C语句; 它开始循环的下一个迭代：</target>
        </trans-unit>
        <trans-unit id="d03baace3369995824b0971e1012da68e7afe6a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;re#%27%2Fflags%27-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; pragma can be used to set default modifiers (including these) for regular expressions compiled within its scope. This pragma has precedence over the other pragmas listed below that also change the defaults.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90f5477a728439ae001b7de4028bc5063fe8048" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; pragma can be used to set default modifiers (including these) for regular expressions compiled within its scope. This pragma has precedence over the other pragmas listed below that also change the defaults.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; 编译指示可用于设定的默认调节剂（包括这些），用于在其范围内已编译的正则表达式。该实用程序优先于下面列出的其他实用程序，这些其他实用程序也会更改默认值。</target>
        </trans-unit>
        <trans-unit id="00f56e4e287b4dad7bb9b00175cad4e28ccf4f49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;
LABEL&lt;/code&gt; . Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 命令重新启动循环块，而无需再次评价以下条件。在 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，如果有的话，不执行。如果省略了LABEL，则该命令引用最里面的封闭循环。从Perl 5.18.0开始可用的 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; 格式允许在运行时计算标签名称，否则与 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; LABEL&lt;/code&gt; 相同。想要对自己所输入的内容撒谎的程序通常使用以下命令：</target>
        </trans-unit>
        <trans-unit id="98d8fed67bad4314d20d9f4fe777fa7ab53123e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (sometimes pronounced &quot;fat comma&quot;) is a synonym for the comma except that it causes a word on its left to be interpreted as a string if it begins with a letter or underscore and is composed only of letters, digits and underscores. This includes operands that might otherwise be interpreted as operators, constants, single number v-strings or function calls. If in doubt about this behavior, the left operand can be quoted explicitly.</source>
          <target state="translated">的 &lt;code&gt;=&amp;gt;&lt;/code&gt; 运算符（有时发音为&amp;ldquo;脂肪逗号&amp;rdquo;）是逗号的同义词不同之处在于它会导致在其左侧，如果它以字母或下划线开始被解释为字符串的单词和只由字母，数字组成和下划线。这包括可能被解释为运算符，常量，单数字v字符串或函数调用的操作数。如果对此行为有疑问，可以显式引用左操作数。</target>
        </trans-unit>
        <trans-unit id="8399dbf8e2e784c4274bc7b091a4f7216970d51b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is helpful in documenting the correspondence between keys and values in hashes, and other paired elements in lists.</source>
          <target state="translated">的 &lt;code&gt;=&amp;gt;&lt;/code&gt; 运算符是在记录在散列中列出了其他成对的元件的键和值之间的对应关系，和有帮助的。</target>
        </trans-unit>
        <trans-unit id="efd3e2bb957eaa0ff2ef103df55bdfaea8225389" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=back&lt;/code&gt; command does not take any arguments.</source>
          <target state="translated">该 &lt;code&gt;=back&lt;/code&gt; 的命令不带任何参数。</target>
        </trans-unit>
        <trans-unit id="2748bc14f635bff7b4cada98a19718c4d6f31834" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=begin&lt;/code&gt; directive can mark a section for a particular purpose. If the Pod parser doesn't want to handle it, it just ignores it. Label the comments with &lt;code&gt;comment&lt;/code&gt; . End the comment using &lt;code&gt;=end&lt;/code&gt; with the same label. You still need the &lt;code&gt;=cut&lt;/code&gt; to go back to Perl code from the Pod comment:</source>
          <target state="translated">该 &lt;code&gt;=begin&lt;/code&gt; 指令可以标记为特定目的的部分。如果Pod解析器不想处理它，则将其忽略。用 &lt;code&gt;comment&lt;/code&gt; 标记注释。使用 &lt;code&gt;=end&lt;/code&gt; 结束注释并带有相同标签。您仍然需要 &lt;code&gt;=cut&lt;/code&gt; 从Pod注释返回到Perl代码：</target>
        </trans-unit>
        <trans-unit id="f59fd3ccb5e9b7feba1f1fe25b7136044c1d07fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=begin&lt;/code&gt; directive can mark a section for a particular purpose. If the Pod parser doesn't want to handle it, it just ignores it. Label the comments with &lt;code&gt;comment&lt;/code&gt;. End the comment using &lt;code&gt;=end&lt;/code&gt; with the same label. You still need the &lt;code&gt;=cut&lt;/code&gt; to go back to Perl code from the Pod comment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef8064ce24f5339d152aec47e53a990ce73ae1e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=over&lt;/code&gt; command does not have a corresponding &lt;code&gt;=back&lt;/code&gt; before the next heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt; ) or the end of the file.</source>
          <target state="translated">的 &lt;code&gt;=over&lt;/code&gt; 命令不具有对应 &lt;code&gt;=back&lt;/code&gt; 下一标题之前（ &lt;code&gt;=head1&lt;/code&gt; 或 &lt;code&gt;=head2&lt;/code&gt; ）或文件的末尾。</target>
        </trans-unit>
        <trans-unit id="e8028d211e346b9053331798c8e936f0c3ebfac6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=over&lt;/code&gt; command does not have a corresponding &lt;code&gt;=back&lt;/code&gt; before the next heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt;) or the end of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8153dbca699722108378e052ce04788e510ab3df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@EXPORT&lt;/code&gt; array tells Perl which of the extension's variables and subroutines should be placed into the calling package's namespace. Because you don't know if the user has already used your variable and subroutine names, it's vitally important to carefully select what to export. Do</source>
          <target state="translated">在 &lt;code&gt;@EXPORT&lt;/code&gt; 数组告诉Perl其扩展的变量和子程序应放在调用包的命名空间。因为您不知道用户是否已经使用了变量名和子例程名，所以仔细选择要导出的内容至关重要。做</target>
        </trans-unit>
        <trans-unit id="59c8e98631ebe2ad43446558b18c0e9a67b97b20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@array[1]&lt;/code&gt; is an array slice, although it has only one index. You can pull out multiple elements simultaneously by specifying additional indices as a list, like &lt;code&gt;@array[1,4,3,0]&lt;/code&gt; .</source>
          <target state="translated">所述 &lt;code&gt;@array[1]&lt;/code&gt; 是一个数组切片，尽管它仅具有一个索引。您可以通过将其他索引指定为列表来同时提取多个元素，例如 &lt;code&gt;@array[1,4,3,0]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acd3d23d5c24e2e27f46834d267601cebe9f5684" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@array[1]&lt;/code&gt; is an array slice, although it has only one index. You can pull out multiple elements simultaneously by specifying additional indices as a list, like &lt;code&gt;@array[1,4,3,0]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="651c155493f8eecba5929c58d7483ab06d1863f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ACTUAL&lt;/code&gt; tells &lt;code&gt;NEXT&lt;/code&gt; that there must actually be a next method to call, or it should throw an exception.</source>
          <target state="translated">在 &lt;code&gt;ACTUAL&lt;/code&gt; 告诉 &lt;code&gt;NEXT&lt;/code&gt; 一定有实际上是调用下一个方法，或者它应该抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="8e537d261fb0eb0877ceb1c6331c23797b3540cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alias&lt;/code&gt; module implements localization of the basic types within the</source>
          <target state="translated">该 &lt;code&gt;Alias&lt;/code&gt; 模块实现定位的基本类型的内</target>
        </trans-unit>
        <trans-unit id="2c6a8f1a286c25be4929a3d652924543120a4cba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Archive::Tar&lt;/code&gt; module can optionally use &lt;code&gt;Compress::Zlib&lt;/code&gt; (via the &lt;code&gt;IO::Zlib&lt;/code&gt; module) to access tar files that have been compressed with &lt;code&gt;gzip&lt;/code&gt; . Unfortunately tar files compressed with the Unix &lt;code&gt;compress&lt;/code&gt; utility cannot be read by &lt;code&gt;Compress::Zlib&lt;/code&gt; and so cannot be directly accesses by &lt;code&gt;Archive::Tar&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;Archive::Tar&lt;/code&gt; 模块可以选择使用 &lt;code&gt;Compress::Zlib&lt;/code&gt; （通过 &lt;code&gt;IO::Zlib&lt;/code&gt; 模块）对已压缩的访问tar文件 &lt;code&gt;gzip&lt;/code&gt; 。不幸的是， &lt;code&gt;Compress::Zlib&lt;/code&gt; 无法读取使用Unix &lt;code&gt;compress&lt;/code&gt; 实用程序压缩的tar文件，因此 &lt;code&gt;Archive::Tar&lt;/code&gt; 无法直接访问。</target>
        </trans-unit>
        <trans-unit id="c846109c9cdb2321e2be7662c4588cdc7ec88db7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Archive::Tar&lt;/code&gt; module can optionally use &lt;code&gt;Compress::Zlib&lt;/code&gt; (via the &lt;code&gt;IO::Zlib&lt;/code&gt; module) to access tar files that have been compressed with &lt;code&gt;gzip&lt;/code&gt;. Unfortunately tar files compressed with the Unix &lt;code&gt;compress&lt;/code&gt; utility cannot be read by &lt;code&gt;Compress::Zlib&lt;/code&gt; and so cannot be directly accessed by &lt;code&gt;Archive::Tar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b17fdbcd746a9f7c286b280ba85ada7dc1cad7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Archive::Tar&lt;/code&gt; module can optionally use &lt;code&gt;Compress::Zlib&lt;/code&gt; (via the &lt;code&gt;IO::Zlib&lt;/code&gt; module) to access tar files that have been compressed with &lt;code&gt;gzip&lt;/code&gt;. Unfortunately tar files compressed with the Unix &lt;code&gt;compress&lt;/code&gt; utility cannot be read by &lt;code&gt;Compress::Zlib&lt;/code&gt; and so cannot be directly accesses by &lt;code&gt;Archive::Tar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43769b61441be000184345132a2a54dc3708064b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B::COP&lt;/code&gt; class is used for &quot;nextstate&quot; and &quot;dbstate&quot; ops. As of Perl 5.22, it is also used for &quot;null&quot; ops that started out as COPs.</source>
          <target state="translated">的 &lt;code&gt;B::COP&lt;/code&gt; 类是用于&amp;ldquo;nextstate&amp;rdquo;和&amp;ldquo;dbstate&amp;rdquo; OPS。从Perl 5.22开始，它还用于以COP开头的&amp;ldquo;空&amp;rdquo;操作。</target>
        </trans-unit>
        <trans-unit id="1a2938ca3d630d110b73048269c361ea78fb5cb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module contains a set of utility functions for querying the current state of the Perl interpreter; typically these functions return objects from the B::SV and B::OP classes, or their derived classes. These classes in turn define methods for querying the resulting objects about their own internal state.</source>
          <target state="translated">所述 &lt;code&gt;B&lt;/code&gt; 模块包含一组用于查询Perl解释的当前状态的实用功能; 通常，这些函数从B :: SV和B :: OP类或其派生类返回对象。这些类依次定义用于查询结果对象有关其内部状态的方法。</target>
        </trans-unit>
        <trans-unit id="40f9413962f128106cd0802b4a2c73013cd7ed0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module exports a variety of functions: some are simple utility functions, others provide a Perl program with a way to get an initial &quot;handle&quot; on an internal object.</source>
          <target state="translated">在 &lt;code&gt;B&lt;/code&gt; 模块出口的多种功能：有些是简单的实用功能，他人提供Perl程序用一种方式来获得一个内部对象上最初的&amp;ldquo;手柄&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5c92116836eedf111e1da108ac269b10e9e38e79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module supplies classes which allow a Perl program to delve into its own innards. It is the module used to implement the &quot;backends&quot; of the Perl compiler. Usage of the compiler does not require knowledge of this module: see the</source>
          <target state="translated">所述 &lt;code&gt;B&lt;/code&gt; 模块提供的类，其允许一个Perl程序钻研它自己的内脏。它是用于实现Perl编译器的&amp;ldquo;后端&amp;rdquo;的模块。使用编译器不需要了解此模块：请参阅</target>
        </trans-unit>
        <trans-unit id="36e744ee541a84c63162e7b4ffbdc783bc6d5f1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; subroutines are not so much subroutines as named special code blocks, of which you can have more than one in a package, and which you can &lt;b&gt;not&lt;/b&gt; call explicitly. See &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;BEGIN, UNITCHECK, CHECK, INIT and END in perlmod&lt;/a&gt;</source>
          <target state="translated">该 &lt;code&gt;BEGIN&lt;/code&gt; ， &lt;code&gt;UNITCHECK&lt;/code&gt; ， &lt;code&gt;CHECK&lt;/code&gt; ， &lt;code&gt;INIT&lt;/code&gt; 和 &lt;code&gt;END&lt;/code&gt; 子程序是没有这么多的子程序为名为特殊代码块，其中可以有一个以上的包，你可以&lt;b&gt;不&lt;/b&gt;显式调用。请参见&lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;perlmod中的BEGIN，UNITCHECK，CHECK，INIT和END&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b8aea840d46b0e93fbdf7c5fc764686c8f3b8c58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; to happen at compile time. The &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method any way it likes, though most modules just choose to derive their &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;a href=&quot;exporter&quot;&gt;&lt;code&gt;Exporter&lt;/code&gt;&lt;/a&gt; module. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method can be found, then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a9cf1f5e3f21b86fcbb8df98f12cbc38b145e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to happen at compile time. The &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method any way it likes, though most modules just choose to derive their &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;code&gt;Exporter&lt;/code&gt; module. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method can be found then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="translated">该 &lt;code&gt;BEGIN&lt;/code&gt; 部队 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 在编译时发生。该 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 确保模块被加载到内存中若没有得到它。该 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 是不是一个内置的;这只是对 &lt;code&gt;Module&lt;/code&gt; 包的普通静态方法调用，告诉模块将功能列表重新导入到当前包中。尽管大多数模块只是选择通过继承自 &lt;code&gt;Exporter&lt;/code&gt; 模块中定义的 &lt;code&gt;Exporter&lt;/code&gt; 类的继承来派生其 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法，但是该模块可以按自己喜欢的任何方式实现其 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法。见&lt;a href=&quot;exporter&quot;&gt;出口商&lt;/a&gt;。如果不 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 即使存在AUTOLOAD方法，也可以找到 import方法，然后跳过该调用。</target>
        </trans-unit>
        <trans-unit id="a9fa3a73043129ebc13296822d30d370f57d9e72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to happen at compile time. The &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method any way it likes, though most modules just choose to derive their &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;code&gt;Exporter&lt;/code&gt; module. See &lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method can be found then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="translated">该 &lt;code&gt;BEGIN&lt;/code&gt; 部队 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 在编译时发生。该 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 确保模块被加载到内存中若没有得到它。该 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 是不是一个内置的;这只是对 &lt;code&gt;Module&lt;/code&gt; 包的普通静态方法调用，告诉模块将功能列表重新导入到当前包中。尽管大多数模块只是选择通过继承自 &lt;code&gt;Exporter&lt;/code&gt; 模块中定义的 &lt;code&gt;Exporter&lt;/code&gt; 类的继承来派生其 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法，但是该模块可以按自己喜欢的任何方式实现其 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法。见&lt;a href=&quot;../exporter&quot;&gt;出口商&lt;/a&gt;。如果不 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 即使存在AUTOLOAD方法，也可以找到 import方法，然后跳过该调用。</target>
        </trans-unit>
        <trans-unit id="9201471b5261b8b4c37aca6c270b666c4082753d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; will assure that the loading of</source>
          <target state="translated">该 &lt;code&gt;BEGIN&lt;/code&gt; 将确保的负载</target>
        </trans-unit>
        <trans-unit id="1df83aa021f2d25a04664c457983f82d52813309" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;UNITCHECK&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; subroutines are not so much subroutines as named special code blocks, of which you can have more than one in a package, and which you can &lt;b&gt;not&lt;/b&gt; call explicitly. See &lt;a href=&quot;perlmod#BEGIN%2C-UNITCHECK%2C-CHECK%2C-INIT-and-END&quot;&gt;&quot;BEGIN, UNITCHECK, CHECK, INIT and END&quot; in perlmod&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a5cc1adfa77075f0adc752b299d298837ebeee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;INIT&lt;/code&gt; blocks in code compiled by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, string &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, or string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; will not be executed if they occur after the end of the main compilation phase; that can be a problem in mod_perl and other persistent environments which use those functions to load code at runtime.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ，string &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 或string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 编译的代码中的 &lt;code&gt;CHECK&lt;/code&gt; 和 &lt;code&gt;INIT&lt;/code&gt; 块在主编译阶段结束之后发生，则将不执行它们；在mod_perl和其他使用这些函数在运行时加载代码的持久性环境中，这可能是个问题。</target>
        </trans-unit>
        <trans-unit id="b104eb26cbd94be033237435dd68c95041e8eb25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;INIT&lt;/code&gt; blocks in code compiled by &lt;code&gt;require&lt;/code&gt;, string &lt;code&gt;do&lt;/code&gt;, or string &lt;code&gt;eval&lt;/code&gt; will not be executed if they occur after the end of the main compilation phase; that can be a problem in mod_perl and other persistent environments which use those functions to load code at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="981efa7d62f736b9f150f24425de3b13fd11e4dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CNS11643&lt;/code&gt; encoding files are not complete. For common &lt;code&gt;CNS11643&lt;/code&gt; manipulation, please use &lt;code&gt;EUC-TW&lt;/code&gt; in &lt;a href=&quot;Encode::HanExtra&quot;&gt;Encode::HanExtra&lt;/a&gt;, which contains planes 1-7.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8f4372f9a2ba513ea1d0d1264224c42f7ba97c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CNS11643&lt;/code&gt; encoding files are not complete. For common &lt;code&gt;CNS11643&lt;/code&gt; manipulation, please use &lt;code&gt;EUC-TW&lt;/code&gt; in &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode::HanExtra&lt;/a&gt;, which contains planes 1-7.</source>
          <target state="translated">该 &lt;code&gt;CNS11643&lt;/code&gt; 编码的文件是不完整的。对于普通 &lt;code&gt;CNS11643&lt;/code&gt; 操作，请使用 &lt;code&gt;EUC-TW&lt;/code&gt; 在&lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;编码:: HanExtra&lt;/a&gt;，其中包含飞机1-7。</target>
        </trans-unit>
        <trans-unit id="82651f5375f4780d1c104db566c2ac41e7d83b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CORE&lt;/code&gt; namespace gives access to the original built-in functions of Perl. The &lt;code&gt;CORE&lt;/code&gt; package is built into Perl, and therefore you do not need to use or require a hypothetical &quot;CORE&quot; module prior to accessing routines in this namespace.</source>
          <target state="translated">使用 &lt;code&gt;CORE&lt;/code&gt; 命名空间可以访问Perl的原始内置函数。该 &lt;code&gt;CORE&lt;/code&gt; 包被内置到Perl的，因此，你不需要使用或先于这个命名空间访问例程需要一个假想的&amp;ldquo;核心&amp;rdquo;模块。</target>
        </trans-unit>
        <trans-unit id="8ae42d583657def46159ee7ad1318ba4bd6a3fc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Compress::Zlib&lt;/code&gt; module can be split into two general areas of functionality, namely a simple read/write interface to</source>
          <target state="translated">该 &lt;code&gt;Compress::Zlib&lt;/code&gt; 模块可以拆分成两个功能一般区域，即一个简单的读/写接口</target>
        </trans-unit>
        <trans-unit id="46e8d3223a09166ecaf398dcfdae3710dcb3dcb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DATA&lt;/code&gt; file handle by default has whatever PerlIO layers were in place when Perl read the file to parse the source. Normally that means that the file is being read bytewise, as if it were encoded in Latin-1, but there are two major ways for it to be otherwise. Firstly, if the &lt;code&gt;__END__&lt;/code&gt;/&lt;code&gt;__DATA__&lt;/code&gt; token is in the scope of a &lt;code&gt;use utf8&lt;/code&gt; pragma then the &lt;code&gt;DATA&lt;/code&gt; handle will be in UTF-8 mode. And secondly, if the source is being read from perl's standard input then the &lt;code&gt;DATA&lt;/code&gt; file handle is actually aliased to the &lt;code&gt;STDIN&lt;/code&gt; file handle, and may be in UTF-8 mode because of the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable or perl's command-line switches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6db4ade377c3bdb345b712f7106420996bb7261" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DB::OUT&lt;/code&gt; filehandle is opened to</source>
          <target state="translated">该 &lt;code&gt;DB::OUT&lt;/code&gt; 文件句柄被打开</target>
        </trans-unit>
        <trans-unit id="3f0a37f63cf06fefd13078baff9b2ef8733fd16b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DB&lt;/code&gt; and &lt;code&gt;main&lt;/code&gt; packages are always omitted, as are any &quot;private&quot; packages that have leading underscores in the namespace (e.g. &lt;code&gt;Foo::_private&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ced3778c80b0e6ddceec7627220df1317342e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DEBUG&lt;/code&gt; constant wipes the floor with even the &lt;code&gt;$debug&lt;/code&gt; variable, clocking in at minus zero seconds, and generates a &quot;warning: too few iterations for a reliable count&quot; message into the bargain. To see what is really going on, and why we had too few iterations when we thought we asked for 100000, we can use the very useful &lt;code&gt;B::Deparse&lt;/code&gt; to inspect the new code:</source>
          <target state="translated">在 &lt;code&gt;DEBUG&lt;/code&gt; 常数抹地板甚至 &lt;code&gt;$debug&lt;/code&gt; 变量，在零下零秒计时，并生成一个&amp;ldquo;警告：一个可靠的计数过几次迭代&amp;rdquo;的消息的呢。要查看实际情况，以及为什么当我们认为要求100000时为什么迭代次数太少，我们可以使用非常有用的 &lt;code&gt;B::Deparse&lt;/code&gt; 来检查新代码：</target>
        </trans-unit>
        <trans-unit id="c9d4dcbece0076153dceb385297ea42930b3d2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DOES&lt;/code&gt; method returns</source>
          <target state="translated">该 &lt;code&gt;DOES&lt;/code&gt; 方法返回</target>
        </trans-unit>
        <trans-unit id="13b108bacf05fadc1d57d69518e2671634247ba4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Deparse&lt;/code&gt; flag makes Dump() run slower, since the XSUB implementation does not support it.</source>
          <target state="translated">该 &lt;code&gt;Deparse&lt;/code&gt; 标志使转储（）运行速度较慢，因为XSUB实现不支持它。</target>
        </trans-unit>
        <trans-unit id="1afec46de9e3c4185e7d2feb3396554e349575f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel::NYTProf&lt;/code&gt; and &lt;code&gt;Devel::FindAmpersand&lt;/code&gt; modules can help you find uses of these problematic match variables in your code.</source>
          <target state="translated">该 &lt;code&gt;Devel::NYTProf&lt;/code&gt; 和 &lt;code&gt;Devel::FindAmpersand&lt;/code&gt; 模块可以帮助你找到这些问题的匹配变量的使用您的代码。</target>
        </trans-unit>
        <trans-unit id="7a6b56d230ad8470a46e41fa3a6181ade20a4909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel::SmallProf&lt;/code&gt; profiler examines the runtime of your Perl program and produces a line-by-line listing to show how many times each line was called, and how long each line took to execute. It is called by supplying the familiar &lt;code&gt;-d&lt;/code&gt; flag to Perl at runtime.</source>
          <target state="translated">该 &lt;code&gt;Devel::SmallProf&lt;/code&gt; 探查检查你的Perl程序的运行时间，并产生一个行由行上市，以显示每行了多少次调用，并在每行花费的时间执行。通过在运行时向Perl 提供熟悉的 &lt;code&gt;-d&lt;/code&gt; 标志来调用它。</target>
        </trans-unit>
        <trans-unit id="e3e899b88f5d9c103f9957a381fb75493e4ca219" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel&lt;/code&gt; namespace has several modules which you can use to profile your Perl programs.</source>
          <target state="translated">该 &lt;code&gt;Devel&lt;/code&gt; 命名空间有几个模块，你可以用它来分析你的Perl程序。</target>
        </trans-unit>
        <trans-unit id="f7b3b4bbb4e3a91049c3f2bf1c1599a52a4bab75" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::&lt;/code&gt; interface is based on the interface originally developed by Neil Winton for his &lt;code&gt;MD5&lt;/code&gt; module.</source>
          <target state="translated">该 &lt;code&gt;Digest::&lt;/code&gt; 接口是基于最初由尼尔&amp;middot;温顿开发了自己的界面上 &lt;code&gt;MD5&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="359f33360a7a83f14790bf4d659bef0945120eaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::&lt;/code&gt; modules calculate digests, also called &quot;fingerprints&quot; or &quot;hashes&quot;, of some data, called a message. The digest is (usually) some small/fixed size string. The actual size of the digest depend of the algorithm used. The message is simply a sequence of arbitrary bytes or bits.</source>
          <target state="translated">该 &lt;code&gt;Digest::&lt;/code&gt; 模块计算一些数据，称为消息摘要的，也被称为&amp;ldquo;指纹&amp;rdquo;或&amp;ldquo;散列&amp;rdquo;。摘要是（通常）一些小/固定大小的字符串。摘要的实际大小取决于所使用的算法。该消息只是任意字节或位的序列。</target>
        </trans-unit>
        <trans-unit id="5112b49f2609b19e911cd2f6a34cb7ffa7088cff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module allows you to use the RSA Data Security Inc. MD5 Message Digest algorithm from within Perl programs. The algorithm takes as input a message of arbitrary length and produces as output a 128-bit &quot;fingerprint&quot; or &quot;message digest&quot; of the input.</source>
          <target state="translated">本 &lt;code&gt;Digest::MD5&lt;/code&gt; 模块允许您从Perl程序中使用的RSA数据安全公司的MD5消息摘要算法。该算法将任意长度的消息作为输入，并产生输出的128位输入&amp;ldquo;指纹&amp;rdquo;或&amp;ldquo;消息摘要&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2adafeb0e9eb580775e9922353cdda9ed2fef18a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module is written by Gisle Aas &amp;lt;gisle@ActiveState.com&amp;gt;.</source>
          <target state="translated">该 &lt;code&gt;Digest::MD5&lt;/code&gt; 模块由伊斯勒阿斯&amp;lt;gisle@ActiveState.com&amp;gt;写入。</target>
        </trans-unit>
        <trans-unit id="048cfda097524929fcf424f6794f7c010276767b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module provide a procedural interface for simple use, as well as an object oriented interface that can handle messages of arbitrary length and which can read files directly.</source>
          <target state="translated">该 &lt;code&gt;Digest::MD5&lt;/code&gt; 模块提供简单的使用一个程序接口，以及面向对象的接口，可以处理任意长度和可直接读取的文件的消息。</target>
        </trans-unit>
        <trans-unit id="417545c4adfbc434083e36d20bccbfb0f99aa98e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::base&lt;/code&gt; class provide implementations of the methods &lt;code&gt;addfile&lt;/code&gt; and &lt;code&gt;add_bits&lt;/code&gt; in terms of &lt;code&gt;add&lt;/code&gt; , and of the methods &lt;code&gt;hexdigest&lt;/code&gt; and &lt;code&gt;b64digest&lt;/code&gt; in terms of &lt;code&gt;digest&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;Digest::base&lt;/code&gt; 类提供的方法的实现 &lt;code&gt;addfile&lt;/code&gt; 和 &lt;code&gt;add_bits&lt;/code&gt; 来讲 &lt;code&gt;add&lt;/code&gt; ，并且所述方法 &lt;code&gt;hexdigest&lt;/code&gt; 和 &lt;code&gt;b64digest&lt;/code&gt; 来讲 &lt;code&gt;digest&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c6996a284acc9e86940a92ab690a3ac4f18b4dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::base&lt;/code&gt; class provide implementations of the methods &lt;code&gt;addfile&lt;/code&gt; and &lt;code&gt;add_bits&lt;/code&gt; in terms of &lt;code&gt;add&lt;/code&gt;, and of the methods &lt;code&gt;hexdigest&lt;/code&gt; and &lt;code&gt;b64digest&lt;/code&gt; in terms of &lt;code&gt;digest&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628d5f24b15638f2c6ff193717192cc425ae4155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DirHandle&lt;/code&gt; method provide an alternative interface to the opendir(), closedir(), readdir(), and rewinddir() functions.</source>
          <target state="translated">该 &lt;code&gt;DirHandle&lt;/code&gt; 方法提供一种替代接口向执行opendir（），closedir（），readdir的（）和rewinddir（）函数。</target>
        </trans-unit>
        <trans-unit id="358ca39e53232388840862f052183678f86697cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function takes one or two arguments: something to dump, and an optional limit for recursion and array elements (default is 4). The first argument is evaluted in rvalue scalar context, with exceptions for @array and %hash, which dump the array or hash itself. So &lt;code&gt;Dump @array&lt;/code&gt; works, as does &lt;code&gt;Dump $foo&lt;/code&gt; . And &lt;code&gt;Dump &lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; will call &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; in rvalue context, whereas &lt;code&gt;Dump ${\&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;}&lt;/code&gt; will call it in lvalue context.</source>
          <target state="translated">该 &lt;code&gt;Dump()&lt;/code&gt; 函数采用一个或两个参数：东西倾倒，并递归和数组元素一个可选的限制（默认为4）。第一个参数在右值标量上下文中求值，@ array和％hash例外，它们会转储数组或哈希本身。所以 &lt;code&gt;Dump @array&lt;/code&gt; 可以工作， &lt;code&gt;Dump $foo&lt;/code&gt; 。和 &lt;code&gt;Dump &lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 将调用 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 在右值范围内，而 &lt;code&gt;Dump ${\&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;}&lt;/code&gt; 将其称之为在左值范围内。</target>
        </trans-unit>
        <trans-unit id="a13938ff22176b323e1b3258e2271152d9209b89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function takes one or two arguments: something to dump, and an optional limit for recursion and array elements (default is 4). The first argument is evaluted in rvalue scalar context, with exceptions for @array and %hash, which dump the array or hash itself. So &lt;code&gt;Dump @array&lt;/code&gt; works, as does &lt;code&gt;Dump $foo&lt;/code&gt;. And &lt;code&gt;Dump pos&lt;/code&gt; will call &lt;code&gt;pos&lt;/code&gt; in rvalue context, whereas &lt;code&gt;Dump ${\pos}&lt;/code&gt; will call it in lvalue context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdbf79b7555598c068ba8d9743bee2fb95392923" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function, by default, dumps up to 4 elements from a toplevel array or hash. This number can be increased by supplying a second argument to the function.</source>
          <target state="translated">该 &lt;code&gt;Dump()&lt;/code&gt; 函数，默认情况下，转储到从顶层数组或哈希4个元素。可以通过向函数提供第二个参数来增加此数字。</target>
        </trans-unit>
        <trans-unit id="c95778d99c76e8e03e061209f2b6b5768436be5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;END&lt;/code&gt; block isn't called when untrapped signals kill the program, though, so if you use &lt;code&gt;END&lt;/code&gt; blocks you should also use</source>
          <target state="translated">在 &lt;code&gt;END&lt;/code&gt; 时未捕获的信号杀死程序，但块不叫，所以如果你使用 &lt;code&gt;END&lt;/code&gt; 块，你也应该使用</target>
        </trans-unit>
        <trans-unit id="f434d74067f98a36c01cbe9c20f7d7cf7b02ed54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXPR&lt;/code&gt; following the modifier is referred to as the &quot;condition&quot;. Its truth or falsehood determines how the modifier will behave.</source>
          <target state="translated">所述 &lt;code&gt;EXPR&lt;/code&gt; 改性剂以下被称为&amp;ldquo;条件&amp;rdquo;。它的真假决定了修饰符的行为。</target>
        </trans-unit>
        <trans-unit id="0be035a23dc6f5f75a5bb7fdc10fe00056028240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encode&lt;/code&gt; module knows about many encodings and has interfaces for doing conversions between those encodings:</source>
          <target state="translated">该 &lt;code&gt;Encode&lt;/code&gt; 模块知道许多编码和具有做这些编码之间的转换接口：</target>
        </trans-unit>
        <trans-unit id="5cdf933f51543c5ce4713919bd68bbd3f797378f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encode&lt;/code&gt; module provides the interface between Perl strings and the rest of the system. Perl strings are sequences of</source>
          <target state="translated">的 &lt;code&gt;Encode&lt;/code&gt; 模块提供的Perl字符串和系统的其余部分之间的接口。Perl字符串是</target>
        </trans-unit>
        <trans-unit id="4968644a1dddd78111692e0824f91d81d4b5fde6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Env::import()&lt;/code&gt; function ties environment variables with suitable names to global Perl variables with the same names. By default it ties all existing environment variables (&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %ENV&lt;/code&gt; ) to scalars. If the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function receives arguments, it takes them to be a list of variables to tie; it's okay if they don't yet exist. The scalar type prefix '$' is inferred for any element of this list not prefixed by '$' or '@'. Arrays are implemented in terms of &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;, using &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; as the delimiter.</source>
          <target state="translated">该 &lt;code&gt;Env::import()&lt;/code&gt; 函数关系的环境变量与适当的名称具有相同名称的全局变量的Perl。默认情况下，它将所有现有环境变量（ &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %ENV&lt;/code&gt; ）绑定到标量。如果 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 函数接收到参数，则将其视为要绑定的变量列表；如果还不存在也可以。对于此列表中没有以&amp;ldquo; $&amp;rdquo;或&amp;ldquo; @&amp;rdquo;为前缀的任何元素，将推导出标量类型前缀&amp;ldquo; $&amp;rdquo;。数组是使用 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 来实现的，使用 &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; 作为分隔符。</target>
        </trans-unit>
        <trans-unit id="5d5e15ad1a58fa2627594efcd21d9bd55ca58029" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Env::import()&lt;/code&gt; function ties environment variables with suitable names to global Perl variables with the same names. By default it ties all existing environment variables (&lt;code&gt;keys %ENV&lt;/code&gt;) to scalars. If the &lt;code&gt;import&lt;/code&gt; function receives arguments, it takes them to be a list of variables to tie; it's okay if they don't yet exist. The scalar type prefix '$' is inferred for any element of this list not prefixed by '$' or '@'. Arrays are implemented in terms of &lt;code&gt;split&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt;, using &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; as the delimiter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb5e18a95e482684c2bead13158da2042ed8e01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04fe8159aef76b700007013f5b9be387367b2a84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraFieldLocal&lt;/code&gt; option is used to store additional metadata in the local header for the zip file/buffer. The &lt;code&gt;ExtraFieldCentral&lt;/code&gt; does the same for the matching central header.</source>
          <target state="translated">该 &lt;code&gt;ExtraFieldLocal&lt;/code&gt; 选项用于存储额外的元数据中的压缩文件/缓冲本地报头。该 &lt;code&gt;ExtraFieldCentral&lt;/code&gt; 做为匹配中央头是相同的。</target>
        </trans-unit>
        <trans-unit id="7dceaf4fc99f40b45472fc6396adb3cf093b19ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FREETMPS&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt; pair will get rid of any values returned by the Perl subroutine (see next example), plus it will also dump the mortal SVs we have created. Having &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;SAVETMPS&lt;/code&gt; at the beginning of the code makes sure that no other mortals are destroyed.</source>
          <target state="translated">该 &lt;code&gt;FREETMPS&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 对将摆脱由Perl子（见下面的例子）返回的任何值，再加上它也将倾，我们已经创建了凡人的SV。在代码的开头 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;SAVETMPS&lt;/code&gt; 可确保没有其他凡人被破坏。</target>
        </trans-unit>
        <trans-unit id="140fe01c0b7ba42e4663eeef8254f0e842ecf849" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FREETMPS&lt;/code&gt;/&lt;code&gt;LEAVE&lt;/code&gt; pair will get rid of any values returned by the Perl subroutine (see next example), plus it will also dump the mortal SVs we have created. Having &lt;code&gt;ENTER&lt;/code&gt;/&lt;code&gt;SAVETMPS&lt;/code&gt; at the beginning of the code makes sure that no other mortals are destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ea08916fc715ad11c85a7aa69540693ba076ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FREEZE&lt;/code&gt; method can return any number of values (i.e. zero or more). These values and the paclkage/classname of the object will then be encoded as a tagged JSON value in the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577b209cddb0e754330f4709ee24d502c593af10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;G_RETHROW&lt;/code&gt; flag can be used if you only need eval_sv() to execute code specified by a string, but not catch any errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e4c30b0dc82b24659a532f35106fc4afecb721" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Host&lt;/code&gt; header is generated from the URL in accordance with RFC 2616. It is a fatal error to specify &lt;code&gt;Host&lt;/code&gt; in the &lt;code&gt;headers&lt;/code&gt; option. Other headers may be ignored or overwritten if necessary for transport compliance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e824605b84cee8c0b954423f3ab5ef2eb2758b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN&lt;/code&gt; /&lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; keywords can be mixed with ANSI-style declarations, as in</source>
          <target state="translated">在 &lt;code&gt;IN&lt;/code&gt; / &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; 的关键字可以用ANSI风格声明混合，如</target>
        </trans-unit>
        <trans-unit id="9f81634b914a660a9d16e3716c6017257055b0e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN&lt;/code&gt;/&lt;code&gt;OUTLIST&lt;/code&gt;/&lt;code&gt;IN_OUTLIST&lt;/code&gt;/&lt;code&gt;IN_OUT&lt;/code&gt;/&lt;code&gt;OUT&lt;/code&gt; keywords can be mixed with ANSI-style declarations, as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2291d3950c0f7a1274711a429d0d47b0e9604c3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; sections have identical formats, that is, each unindented line starts a new in- or output map respectively. A new in- or output map must start with the name of the XS type to map on a line by itself, followed by the code that implements it indented on the following lines. Example:</source>
          <target state="translated">的 &lt;code&gt;INPUT&lt;/code&gt; 和 &lt;code&gt;OUTPUT&lt;/code&gt; 部分具有相同的格式，即，没有锯齿的各线分别开始一个新的输入或输出图。新的输入或输出映射必须以XS类型的名称开头，才能单独在一行上进行映射，然后在下一行上以缩进形式实现该映射的代码。例：</target>
        </trans-unit>
        <trans-unit id="0839ebfa51c8f90f143d226a6a7f33a7ff311878" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INT2PTR&lt;/code&gt; macro (defined in perl.h) casts an integer to a pointer of a given type, taking care of the possible different size of integers and pointers. There are also &lt;code&gt;PTR2IV&lt;/code&gt; , &lt;code&gt;PTR2UV&lt;/code&gt; , &lt;code&gt;PTR2NV&lt;/code&gt; macros, to map the other way, which may be useful in OUTPUT sections.</source>
          <target state="translated">所述 &lt;code&gt;INT2PTR&lt;/code&gt; 宏（在perl.h定义）投射的整数到一个给定类型的指针，以可能的不同大小整数和指针的照顾。还有 &lt;code&gt;PTR2IV&lt;/code&gt; ， &lt;code&gt;PTR2UV&lt;/code&gt; 和 &lt;code&gt;PTR2NV&lt;/code&gt; 宏，以另一种方式映射，这在OUTPUT部分中可能有用。</target>
        </trans-unit>
        <trans-unit id="8dee4e81117d0288fc40b8cb09d886277f261bfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INT2PTR&lt;/code&gt; macro (defined in perl.h) casts an integer to a pointer of a given type, taking care of the possible different size of integers and pointers. There are also &lt;code&gt;PTR2IV&lt;/code&gt;, &lt;code&gt;PTR2UV&lt;/code&gt;, &lt;code&gt;PTR2NV&lt;/code&gt; macros, to map the other way, which may be useful in OUTPUT sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7466a438605e61935ae6328f4fe2d9214ef781c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN_OUT&lt;/code&gt; parameters are identical with parameters introduced with &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;&quot;The &amp;amp; Unary Operator&quot;&lt;/a&gt; and put into the &lt;code&gt;OUTPUT:&lt;/code&gt; section (see &lt;a href=&quot;#The-OUTPUT%3A-Keyword&quot;&gt;&quot;The OUTPUT: Keyword&quot;&lt;/a&gt;). The &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters are very similar, the only difference being that the value C function writes through the pointer would not modify the Perl parameter, but is put in the output list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f85903ef5f9040c0ff99931c044e8d15426a65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN_OUT&lt;/code&gt; parameters are identical with parameters introduced with &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt; and put into the &lt;code&gt;OUTPUT:&lt;/code&gt; section (see &lt;a href=&quot;#The-OUTPUT%3a-Keyword&quot;&gt;The OUTPUT: Keyword&lt;/a&gt;). The &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters are very similar, the only difference being that the value C function writes through the pointer would not modify the Perl parameter, but is put in the output list.</source>
          <target state="translated">的 &lt;code&gt;IN_OUT&lt;/code&gt; 参数是与引入参数相同&lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;的＆元运算符&lt;/a&gt;并投入 &lt;code&gt;OUTPUT:&lt;/code&gt; 部分（请参见&lt;a href=&quot;#The-OUTPUT%3a-Keyword&quot;&gt;输出：关键字&lt;/a&gt;）。该 &lt;code&gt;IN_OUTLIST&lt;/code&gt; 参数非常相似，唯一的区别是，C值函数通过指针写入不会修改Perl的参数，而是被放在输出列表。</target>
        </trans-unit>
        <trans-unit id="e01d4a34408ea1bec61899bb0715159c8fcfc543" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Dir&lt;/code&gt; package provides two interfaces to perl's directory reading routines.</source>
          <target state="translated">该 &lt;code&gt;IO::Dir&lt;/code&gt; 包提供了两个接口，Perl的目录阅读程序。</target>
        </trans-unit>
        <trans-unit id="2e8c3db24464dee992cbd4fb5389ee4e7af6c03b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Select&lt;/code&gt; package implements an object approach to the system &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function call. It allows the user to see what IO handles, see &lt;a href=&quot;handle&quot;&gt;IO::Handle&lt;/a&gt;, are ready for reading, writing or have an exception pending.</source>
          <target state="translated">该 &lt;code&gt;IO::Select&lt;/code&gt; 包实现的一个对象的方法对系统 &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 函数调用。它允许用户查看IO处理的内容，请参见&lt;a href=&quot;handle&quot;&gt;IO :: Handle&lt;/a&gt;，准备进行读取，写入或等待异常处理。</target>
        </trans-unit>
        <trans-unit id="d4a23c694ba8531eb134632f2092cafc7861a78d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Select&lt;/code&gt; package implements an object approach to the system &lt;code&gt;select&lt;/code&gt; function call. It allows the user to see what IO handles, see &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;, are ready for reading, writing or have an exception pending.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b99267c0bd0ea1d7a95c4de6c3170224a12616" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IVdf&lt;/code&gt; will expand to whatever is the correct format for the IVs. Note that the spaces are required around the format in case the code is compiled with C++, to maintain compliance with its standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e9868cf44653a0a473010fe2cd91001e0a676d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Interpolation&lt;/code&gt; module can also do a lot of magic for you. You can specify a variable name, in this case &lt;code&gt;E&lt;/code&gt; , to set up a tied hash that does the interpolation for you. It has several other methods to do this as well.</source>
          <target state="translated">该 &lt;code&gt;Interpolation&lt;/code&gt; 模块还可以做很多的魔法给你。您可以指定一个变量名，在这种情况下为 &lt;code&gt;E&lt;/code&gt; ，以设置一个绑定的哈希为您进行插值。它也有其他几种方法可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="329ab637f04429657f9fe6aaf5dca20594f33c89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Interpolation&lt;/code&gt; module can also do a lot of magic for you. You can specify a variable name, in this case &lt;code&gt;E&lt;/code&gt;, to set up a tied hash that does the interpolation for you. It has several other methods to do this as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3bc590cafc9b13c0e888463643b3750cf44fd73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_CTYPE&lt;/code&gt; locale also provides the map used in transliterating characters between lower and uppercase. This affects the case-mapping functions--&lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt;; case-mapping interpolation with &lt;code&gt;\F&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , or &lt;code&gt;\U&lt;/code&gt; in double-quoted strings and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; substitutions; and case-independent regular expression pattern matching using the &lt;code&gt;i&lt;/code&gt; modifier.</source>
          <target state="translated">的 &lt;code&gt;LC_CTYPE&lt;/code&gt; 语言环境还提供了在较低和大写之间音译字符使用的地图。这影响的情况下映射functions-- &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt; ; 在双引号字符串和 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 替换中用 &lt;code&gt;\F&lt;/code&gt; ， &lt;code&gt;\l&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; 或 &lt;code&gt;\U&lt;/code&gt; 进行大小写映射插值；以及使用 &lt;code&gt;i&lt;/code&gt; 修饰符的大小写无关的正则表达式模式匹配。</target>
        </trans-unit>
        <trans-unit id="bc3c541f503e52e8ac4f6d3ffd90d52fc4128eb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_CTYPE&lt;/code&gt; locale also provides the map used in transliterating characters between lower and uppercase. This affects the case-mapping functions--&lt;code&gt;fc()&lt;/code&gt;, &lt;code&gt;lc()&lt;/code&gt;, &lt;code&gt;lcfirst()&lt;/code&gt;, &lt;code&gt;uc()&lt;/code&gt;, and &lt;code&gt;ucfirst()&lt;/code&gt;; case-mapping interpolation with &lt;code&gt;\F&lt;/code&gt;, &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, or &lt;code&gt;\U&lt;/code&gt; in double-quoted strings and &lt;code&gt;s///&lt;/code&gt; substitutions; and case-insensitive regular expression pattern matching using the &lt;code&gt;i&lt;/code&gt; modifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941219cd505be61ac26ba8728d69370c60e37046" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_NUMERIC&lt;/code&gt; controls the numeric output:</source>
          <target state="translated">所述 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 控制数字输出：</target>
        </trans-unit>
        <trans-unit id="412121500ef04a2233556ed3ed8bb5c784494003" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option changes the behavior of the &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; method so that the amount of memory used by the output buffer can be limited.</source>
          <target state="translated">所述 &lt;code&gt;LimitOutput&lt;/code&gt; 选项改变的行为 &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; 方法使得存储由输出缓冲器的使用量可以被限制。</target>
        </trans-unit>
        <trans-unit id="1b18a1d213993f63112fefb5d5804b6552cbf33b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option changes the behavior of the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method so that the amount of memory used by the output buffer can be limited.</source>
          <target state="translated">所述 &lt;code&gt;LimitOutput&lt;/code&gt; 选项改变的行为 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 方法使得存储由输出缓冲器的使用量可以被限制。</target>
        </trans-unit>
        <trans-unit id="3600b0d3775b442853dade84e908851ee6d60512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option is designed to help with this use-case.</source>
          <target state="translated">该 &lt;code&gt;LimitOutput&lt;/code&gt; 选项被设计为与该用例的帮助。</target>
        </trans-unit>
        <trans-unit id="4e39cafde8d7c8f339d79044ffb14c41f2b59abf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Listen&lt;/code&gt; parameter is set to the maximum number of pending connections we can accept until we turn away incoming clients. Think of it as a call-waiting queue for your telephone. The low-level Socket module has a special symbol for the system maximum, which is SOMAXCONN.</source>
          <target state="translated">该 &lt;code&gt;Listen&lt;/code&gt; 参数设置为未决的连接，我们可以接受，直到我们转身离开传入客户端的最大数量。将其视为电话的呼叫等待队列。对于系统最大值，低级Socket模块具有特殊符号，即SOMAXCONN。</target>
        </trans-unit>
        <trans-unit id="39d8f8a92949aebb617dd074e69f347a559dd1fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Country&lt;/code&gt; module provides access to several code sets that can be used for identifying countries, such as those defined in ISO 3166-1.</source>
          <target state="translated">的 &lt;code&gt;Locale::Country&lt;/code&gt; 模块提供的是可用于标识国家的若干代码集，例如在ISO 3166-1定义的访问。</target>
        </trans-unit>
        <trans-unit id="7ce570b70dc3b1217c7829eb357747faae317306" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Currency&lt;/code&gt; module provides access to standard codes used for identifying currencies and funds, such as those defined in ISO 4217.</source>
          <target state="translated">的 &lt;code&gt;Locale::Currency&lt;/code&gt; 模块提供用于识别货币和资金，诸如那些在ISO 4217定义的标准代码。</target>
        </trans-unit>
        <trans-unit id="e1ffcce2675347ee9e15ffb62b7a866fc9499f7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Language&lt;/code&gt; module provides access to standard codes used for identifying languages, such as those as defined in ISO 639.</source>
          <target state="translated">的 &lt;code&gt;Locale::Language&lt;/code&gt; 模块提供用于识别语言，如在ISO 639所定义的那些标准代码。</target>
        </trans-unit>
        <trans-unit id="aa76c519ff8997e91915d966da6aed9450ba1a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Script&lt;/code&gt; module provides access to standards codes used for identifying scripts, such as those defined in ISO 15924.</source>
          <target state="translated">的 &lt;code&gt;Locale::Script&lt;/code&gt; 模块提供用于识别脚本，诸如那些在ISO 15924定义的标准代码。</target>
        </trans-unit>
        <trans-unit id="e8120d017d19784f5ec18621659dfbf762367c0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MGVTBL&lt;/code&gt; has five (or sometimes eight) pointers to the following routine types:</source>
          <target state="translated">该 &lt;code&gt;MGVTBL&lt;/code&gt; 有五个（或有时为八个）指针以下的常规类型：</target>
        </trans-unit>
        <trans-unit id="cb0939f4e09d7100879a1f0cd7a45d518f685d85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Math::Trig&lt;/code&gt; handles this by using the &lt;code&gt;Math::Complex&lt;/code&gt; package which knows how to handle complex numbers, please see &lt;a href=&quot;Math::Complex&quot;&gt;Math::Complex&lt;/a&gt; for more information. In practice you need not to worry about getting complex numbers as results because the &lt;code&gt;Math::Complex&lt;/code&gt; takes care of details like for example how to display complex numbers. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62960d717ea2191ee6cb352f5b362492a57f4b7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Math::Trig&lt;/code&gt; handles this by using the &lt;code&gt;Math::Complex&lt;/code&gt; package which knows how to handle complex numbers, please see &lt;a href=&quot;complex&quot;&gt;Math::Complex&lt;/a&gt; for more information. In practice you need not to worry about getting complex numbers as results because the &lt;code&gt;Math::Complex&lt;/code&gt; takes care of details like for example how to display complex numbers. For example:</source>
          <target state="translated">该 &lt;code&gt;Math::Trig&lt;/code&gt; 通过处理这 &lt;code&gt;Math::Complex&lt;/code&gt; 包，它知道如何处理复杂的数字，请参阅&lt;a href=&quot;complex&quot;&gt;数学::情结&lt;/a&gt;了解更多信息。在实践中，您不必担心将复数作为结果，因为 &lt;code&gt;Math::Complex&lt;/code&gt; 会处理诸如如何显示复数之类的细节。例如：</target>
        </trans-unit>
        <trans-unit id="59d3e5116a50776a62b5e7307aca3591f0689480" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Moose&lt;/code&gt; authors hope that one day &lt;code&gt;Moo&lt;/code&gt; can be made obsolete by improving &lt;code&gt;Moose&lt;/code&gt; enough, but for now it provides a worthwhile alternative to &lt;code&gt;Moose&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;Moose&lt;/code&gt; 笔者希望有一天， &lt;code&gt;Moo&lt;/code&gt; 可以通过改进制造过时 &lt;code&gt;Moose&lt;/code&gt; 就够了，但现在它提供了一个有价值的替代 &lt;code&gt;Moose&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd61d23b6e3309b14f23bde3328a9b1cfdb75d47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Moose&lt;/code&gt; authors hope that one day &lt;code&gt;Moo&lt;/code&gt; can be made obsolete by improving &lt;code&gt;Moose&lt;/code&gt; enough, but for now it provides a worthwhile alternative to &lt;code&gt;Moose&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9a3a0a2d0497d18f72b7ad30f16ed602816e32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NEXT&lt;/code&gt; module adds a pseudoclass named &lt;code&gt;NEXT&lt;/code&gt; to any program that uses it. If a method &lt;code&gt;m&lt;/code&gt; calls &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt;, the call to &lt;code&gt;m&lt;/code&gt; is redispatched as if the calling method had not originally been found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cda22c66d7ae69cf0c1a687755ef0ea97e644b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NNTP&lt;/code&gt; protocol uses the &lt;code&gt;WILDMAT&lt;/code&gt; format for patterns. The WILDMAT format was first developed by Rich Salz based on the format used in the UNIX &quot;find&quot; command to articulate file names. It was developed to provide a uniform mechanism for matching patterns in the same manner that the UNIX shell matches filenames.</source>
          <target state="translated">的 &lt;code&gt;NNTP&lt;/code&gt; 协议使用 &lt;code&gt;WILDMAT&lt;/code&gt; 的模式格式。 WILDMAT格式由Rich Salz首先根据UNIX&amp;ldquo;查找&amp;rdquo;命令中用于表达文件名的格式开发。它的开发旨在提供一种统一的机制，以与UNIX Shell匹配文件名的方式匹配模式。</target>
        </trans-unit>
        <trans-unit id="8856a9c3b92894fbca75a7c6a84e03f49c7d82b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Net::FTP&lt;/code&gt; module provides two low-level methods called &lt;code&gt;stor&lt;/code&gt; and &lt;code&gt;retr&lt;/code&gt; that both return filehandles. These filehandles can used with the &lt;code&gt;IO::Compress/Uncompress&lt;/code&gt; modules to compress or uncompress files read from or written to an FTP Server on the fly, without having to create a temporary file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812543816e7e36906e0a41744e1b881bd6061a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;O::import&lt;/code&gt; function loads the appropriate &lt;code&gt;B::Backend&lt;/code&gt; module and calls its &lt;code&gt;compile&lt;/code&gt; function, passing it OPTIONS. That function is expected to return a sub reference which we'll call CALLBACK. Next, the &quot;compile-only&quot; flag is switched on (equivalent to the command-line option &lt;code&gt;-c&lt;/code&gt; ) and a CHECK block is registered which calls CALLBACK. Thus the main Perl program mentioned on the command-line is read in, parsed and compiled into internal syntax tree form. Since the &lt;code&gt;-c&lt;/code&gt; flag is set, the program does not start running (excepting BEGIN blocks of course) but the CALLBACK function registered by the compiler backend is called.</source>
          <target state="translated">该 &lt;code&gt;O::import&lt;/code&gt; 功能加载相应的 &lt;code&gt;B::Backend&lt;/code&gt; 模块，并调用它的 &lt;code&gt;compile&lt;/code&gt; 功能，通过它选项。该函数将返回一个子引用，我们将其称为CALLBACK。接下来，打开&amp;ldquo;仅编译&amp;rdquo;标志（等效于命令行选项 &lt;code&gt;-c&lt;/code&gt; ），并注册一个CHECK块，该块调用CALLBACK。因此，在命令行中提到的主要Perl程序将被读入，解析并编译为内部语法树形式。由于设置了 &lt;code&gt;-c&lt;/code&gt; 标志，因此程序不会开始运行（当然，BEGIN块除外），但是会调用编译器后端注册的CALLBACK函数。</target>
        </trans-unit>
        <trans-unit id="d7e78f61b2ef3885efb7f8bb2d5b2723a7d2f5bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;O::import&lt;/code&gt; function loads the appropriate &lt;code&gt;B::Backend&lt;/code&gt; module and calls its &lt;code&gt;compile&lt;/code&gt; function, passing it OPTIONS. That function is expected to return a sub reference which we'll call CALLBACK. Next, the &quot;compile-only&quot; flag is switched on (equivalent to the command-line option &lt;code&gt;-c&lt;/code&gt;) and a CHECK block is registered which calls CALLBACK. Thus the main Perl program mentioned on the command-line is read in, parsed and compiled into internal syntax tree form. Since the &lt;code&gt;-c&lt;/code&gt; flag is set, the program does not start running (excepting BEGIN blocks of course) but the CALLBACK function registered by the compiler backend is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d373b71890ff94863d227c7cfce5d1d697b7746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OP *&lt;/code&gt; is op_free()ed at the end of</source>
          <target state="translated">的 &lt;code&gt;OP *&lt;/code&gt; 是op_free（）的在端部</target>
        </trans-unit>
        <trans-unit id="998cf5d3020bb78a9ba1d3cad328d90e354a7767" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; parameter differ from &lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; parameters only by the initial value of the Perl parameter not being read (and not being given to the C function - which gets some garbage instead). For example, the same C function as above can be interfaced with as</source>
          <target state="translated">所述 &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; 参数不同于 &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; 仅由Perl的参数不被读取的初始值的参数（而不是被提供给C函数-它获取一些垃圾代替）。例如，可以将与上述相同的C函数与</target>
        </trans-unit>
        <trans-unit id="77d530437d7fdd465ebf5f4d28d1ba3ab2ce9989" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OUTLIST&lt;/code&gt;/&lt;code&gt;OUT&lt;/code&gt; parameter differ from &lt;code&gt;IN_OUTLIST&lt;/code&gt;/&lt;code&gt;IN_OUT&lt;/code&gt; parameters only by the initial value of the Perl parameter not being read (and not being given to the C function - which gets some garbage instead). For example, the same C function as above can be interfaced with as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0628c399d26c3378a27108a14e1ac2344b8aefb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Open()&lt;/code&gt; method has lots of arguments because it combines the functions of perl's &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;PerlIO_open&lt;/code&gt; , perl's &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;PerlIO_fdopen&lt;/code&gt; and &lt;code&gt;PerlIO_reopen&lt;/code&gt; . The full prototype is as follows:</source>
          <target state="translated">在 &lt;code&gt;Open()&lt;/code&gt; 方法有很多的参数，因为它结合了Perl的功能 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;PerlIO_open&lt;/code&gt; ，Perl的 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;PerlIO_fdopen&lt;/code&gt; 和 &lt;code&gt;PerlIO_reopen&lt;/code&gt; 。完整的原型如下：</target>
        </trans-unit>
        <trans-unit id="a364ca34d8039b509a216c6b70daa6a333bd164c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Open()&lt;/code&gt; method has lots of arguments because it combines the functions of perl's &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;PerlIO_open&lt;/code&gt;, perl's &lt;code&gt;sysopen&lt;/code&gt;, &lt;code&gt;PerlIO_fdopen&lt;/code&gt; and &lt;code&gt;PerlIO_reopen&lt;/code&gt;. The full prototype is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b50db457121e66e0a351ce78b3a957dc8ab0fb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL5DB&lt;/code&gt; environment variable can be used to define a debugger. For example, the minimal &quot;working&quot; debugger (it actually doesn't do anything) consists of one line:</source>
          <target state="translated">所述 &lt;code&gt;PERL5DB&lt;/code&gt; 环境变量可以用于定义调试器。例如，最小的&amp;ldquo;工作&amp;rdquo;调试器（它实际上不执行任何操作）由一行组成：</target>
        </trans-unit>
        <trans-unit id="d2bc99a442d5c0b29501891792cdc1fff80da05a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; and &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic types are defined specifically for use by extensions and will not be used by perl itself. Extensions can use &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic to 'attach' private information to variables (typically objects). This is especially useful because there is no way for normal perl code to corrupt this private information (unlike using extra elements of a hash object).</source>
          <target state="translated">的 &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; 和 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 魔术类型由扩展使用具体限定，并且不会被Perl本身使用。扩展可以使用 &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; 魔术来将私有信息&amp;ldquo;附加&amp;rdquo;到变量（通常是对象）。这是特别有用的，因为普通的perl代码无法破坏此私有信息（与使用哈希对象的其他元素不同）。</target>
        </trans-unit>
        <trans-unit id="8a6e94721b04748465ec2688a94fd6f249730156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; interface for hashes</source>
          <target state="translated">该 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 接口哈希</target>
        </trans-unit>
        <trans-unit id="bda510e29f461a0c3d4c9c5037a48e14d8e62436" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; flag is always treated as being set for this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc956792cc9e74cf6710a9899c98dc65f9e9723" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POPi&lt;/code&gt; macro is used here to pop the return value from the stack. In this case we wanted an integer, so &lt;code&gt;POPi&lt;/code&gt; was used.</source>
          <target state="translated">该 &lt;code&gt;POPi&lt;/code&gt; 宏这里使用流行从堆栈的返回值。在这种情况下，我们需要一个整数，因此使用了 &lt;code&gt;POPi&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="441004a0b6f6f50d94cdd26e8efdb4418e11d7d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::getattr&lt;/code&gt; function can do this more portably on systems purporting POSIX compliance. See also the &lt;code&gt;Term::ReadKey&lt;/code&gt; module from your nearest &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org&quot;&gt;CPAN&lt;/a&gt; site.</source>
          <target state="translated">该 &lt;code&gt;POSIX::getattr&lt;/code&gt; 功能，可以对声称符合POSIX系统更可移植做到这一点。另请参见离您最近的&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org&quot;&gt;CPAN&lt;/a&gt;站点的 &lt;code&gt;Term::ReadKey&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="30a4c7c0312ad4ebafbfc4ecde82010a30e5b1d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::localeconv()&lt;/code&gt; function allows you to get particulars of the locale-dependent numeric formatting information specified by the current underlying &lt;code&gt;LC_NUMERIC&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; locales (regardless of whether called from within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; or not). (If you just want the name of the current locale for a particular category, use &lt;code&gt;POSIX::setlocale()&lt;/code&gt; with a single parameter--see &lt;a href=&quot;#The-setlocale-function&quot;&gt;The setlocale function&lt;/a&gt;.)</source>
          <target state="translated">该 &lt;code&gt;POSIX::localeconv()&lt;/code&gt; 函数可以让你获得的当前底层指定的区域设置相关的数字格式信息细节 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 和 &lt;code&gt;LC_MONETARY&lt;/code&gt; 语言环境（无论从范围内调用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 或没有）。（如果只需要特定类别的当前语言环境的名称，请使用带有单个参数的 &lt;code&gt;POSIX::setlocale()&lt;/code&gt; －请参阅&lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale函数&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="2b43e9db384d2d0a57a2a9c77f122fdc5d00196d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::localeconv()&lt;/code&gt; function allows you to get particulars of the locale-dependent numeric formatting information specified by the current underlying &lt;code&gt;LC_NUMERIC&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; locales (regardless of whether called from within the scope of &lt;code&gt;use locale&lt;/code&gt; or not). (If you just want the name of the current locale for a particular category, use &lt;code&gt;POSIX::setlocale()&lt;/code&gt; with a single parameter--see &lt;a href=&quot;#The-setlocale-function&quot;&gt;&quot;The setlocale function&quot;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f685f77eea7b515d4045c7a67182dbbc7755a25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUSHMARK&lt;/code&gt; macro tells Perl to make a mental note of the current stack pointer. Even if you aren't passing any parameters (like the example shown in the section</source>
          <target state="translated">该 &lt;code&gt;PUSHMARK&lt;/code&gt; 宏告诉Perl做一个心里记下当前堆栈指针的。即使您没有传递任何参数（例如本节中显示的示例）</target>
        </trans-unit>
        <trans-unit id="163850ef5b169ef12088a9930a0f3972d7c61a0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUSHMARK&lt;/code&gt; macro tells Perl to make a mental note of the current stack pointer. Even if you aren't passing any parameters (like the example shown in the section &lt;a href=&quot;#No-Parameters%2C-Nothing-Returned&quot;&gt;&quot;No Parameters, Nothing Returned&quot;&lt;/a&gt;) you must still call the &lt;code&gt;PUSHMARK&lt;/code&gt; macro before you can call any of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07465ad7c738ebeee81550400552ecd67a850bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUTBACK&lt;/code&gt; macro sets the global copy of the stack pointer to be the same as our local copy. If we didn't do this,</source>
          <target state="translated">该 &lt;code&gt;PUTBACK&lt;/code&gt; 堆栈指针的宏设置全局副本是一样的我们的本地副本。如果我们不这样做，</target>
        </trans-unit>
        <trans-unit id="8baae86fdb4cb4e701226e31c2071774be7ff5cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PeerAddr&lt;/code&gt; can be a hostname or the IP-address on the &quot;xx.xx.xx.xx&quot; form. The &lt;code&gt;PeerPort&lt;/code&gt; can be a number or a symbolic service name. The service name might be followed by a number in parenthesis which is used if the service is not known by the system. The &lt;code&gt;PeerPort&lt;/code&gt; specification can also be embedded in the &lt;code&gt;PeerAddr&lt;/code&gt; by preceding it with a &quot;:&quot;.</source>
          <target state="translated">该 &lt;code&gt;PeerAddr&lt;/code&gt; 可以是&amp;ldquo;XX.XX.XX.XX&amp;rdquo;表单上的主机名或IP地址。该 &lt;code&gt;PeerPort&lt;/code&gt; 可以是一个数字或符号服务名称。服务名称后可能带有括号中的数字，如果系统不知道该服务，则使用该数字。所述 &lt;code&gt;PeerPort&lt;/code&gt; 规范也可以嵌入在 &lt;code&gt;PeerAddr&lt;/code&gt; &amp;ldquo;：&amp;rdquo;通过用它前面。</target>
        </trans-unit>
        <trans-unit id="354584d7434f3b3042f7e803f86eee0735ecb30f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PerlInterpreter*&lt;/code&gt; is being constructed via &lt;code&gt;perl_construct&lt;/code&gt; . This value is mostly there for completeness and for use via the underlying C variable &lt;code&gt;PL_phase&lt;/code&gt; . It's not really possible for Perl code to be executed unless construction of the interpreter is finished.</source>
          <target state="translated">所述 &lt;code&gt;PerlInterpreter*&lt;/code&gt; 正在通过构造 &lt;code&gt;perl_construct&lt;/code&gt; 。此值主要用于完整性和通过基础C变量 &lt;code&gt;PL_phase&lt;/code&gt; 使用。除非解释器的构建完成，否则实际上不可能执行Perl代码。</target>
        </trans-unit>
        <trans-unit id="98058838817e528c0fbf9fe55b4c498c1c669b4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PerlInterpreter*&lt;/code&gt; is being constructed via &lt;code&gt;perl_construct&lt;/code&gt;. This value is mostly there for completeness and for use via the underlying C variable &lt;code&gt;PL_phase&lt;/code&gt;. It's not really possible for Perl code to be executed unless construction of the interpreter is finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619b9e421badf230488baf0eee0a8b4f64f3d92d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REGlob&lt;/code&gt; example above does not implement all the support needed to cleanly override perl's &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator. The built-in &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; has different behaviors depending on whether it appears in a scalar or list context, but our &lt;code&gt;REGlob&lt;/code&gt; doesn't. Indeed, many perl built-in have such context sensitive behaviors, and these must be adequately supported by a properly written override. For a fully functional example of overriding &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, study the implementation of &lt;code&gt;File::DosGlob&lt;/code&gt; in the standard library.</source>
          <target state="translated">上面的 &lt;code&gt;REGlob&lt;/code&gt; 示例未实现完全重写perl的 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 运算符所需的所有支持。内置 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 具有不同的行为，具体取决于它出现在标量还是列表上下文中，但我们的 &lt;code&gt;REGlob&lt;/code&gt; 却没有。实际上，许多内置的perl都具有此类上下文相关的行为，并且必须由适当编写的重写来充分支持这些行为。有关覆盖 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 的完整功能示例，请研究标准库中 &lt;code&gt;File::DosGlob&lt;/code&gt; 的实现。</target>
        </trans-unit>
        <trans-unit id="2793461193bbb08faabc42ded2214d9447a84314" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REGlob&lt;/code&gt; example above does not implement all the support needed to cleanly override perl's &lt;code&gt;glob&lt;/code&gt; operator. The built-in &lt;code&gt;glob&lt;/code&gt; has different behaviors depending on whether it appears in a scalar or list context, but our &lt;code&gt;REGlob&lt;/code&gt; doesn't. Indeed, many perl built-in have such context sensitive behaviors, and these must be adequately supported by a properly written override. For a fully functional example of overriding &lt;code&gt;glob&lt;/code&gt;, study the implementation of &lt;code&gt;File::DosGlob&lt;/code&gt; in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541482224c51c4cb7a6cd08e437f820560b203ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Return&lt;/code&gt; and &lt;code&gt;Envelope&lt;/code&gt; parameters are used for DSN (Delivery Status Notification).</source>
          <target state="translated">在 &lt;code&gt;Return&lt;/code&gt; 和 &lt;code&gt;Envelope&lt;/code&gt; 参数用于DSN（传递状态通知）。</target>
        </trans-unit>
        <trans-unit id="0fb74752f70cdbcc4b24e6fe1a79d1c71cc57bd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reuse&lt;/code&gt; parameter is needed so that we restart our server manually without waiting a few minutes to allow system buffers to clear out.</source>
          <target state="translated">该 &lt;code&gt;Reuse&lt;/code&gt; 需要参数，以便我们手动重新启动我们的服务器，而无需等待几分钟，让系统缓冲区就一目了然了。</target>
        </trans-unit>
        <trans-unit id="6ef497f2f64147d9fc11b64ad7836f6a54270b55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIGALRM&lt;/code&gt; signal is sent after the specified number of seconds. Implemented using &lt;code&gt;setitimer()&lt;/code&gt; if available, &lt;code&gt;ualarm()&lt;/code&gt; if not. The &lt;code&gt;$interval_floating_seconds&lt;/code&gt; argument is optional and will be zero if unspecified, resulting in &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt;-like behaviour. This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; below.</source>
          <target state="translated">所述 &lt;code&gt;SIGALRM&lt;/code&gt; 信号的指定的秒数之后被发送。如果有的话，使用 &lt;code&gt;setitimer()&lt;/code&gt; 实现；如果没有，则使用 &lt;code&gt;ualarm()&lt;/code&gt; 实现。 &lt;code&gt;$interval_floating_seconds&lt;/code&gt; 参数是可选的，如果未指定，则为零，从而导致类似 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 的行为。可以导入此功能，从而可以很好地替代perl随附的 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; ，请参见下面的&lt;a href=&quot;#EXAMPLES&quot;&gt;示例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c45565a357a5307165173264e504c30b567da1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIGALRM&lt;/code&gt; signal is sent after the specified number of seconds. Implemented using &lt;code&gt;setitimer()&lt;/code&gt; if available, &lt;code&gt;ualarm()&lt;/code&gt; if not. The &lt;code&gt;$interval_floating_seconds&lt;/code&gt; argument is optional and will be zero if unspecified, resulting in &lt;code&gt;alarm()&lt;/code&gt;-like behaviour. This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;alarm&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="739f23e9e223585aacd76fc17b10f95586c4f592" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SSL_options&lt;/code&gt; attribute could also be used for such things as providing a client certificate for authentication to a server or controlling the choice of cipher used for the SSL connection. See &lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO::Socket::SSL&lt;/a&gt; documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb26b9a2abefa95e1228823d5039552d2541e20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER::&lt;/code&gt; bit tells Perl to look for the &lt;code&gt;print_info()&lt;/code&gt; in the &lt;code&gt;File::MP3&lt;/code&gt; class's inheritance chain. When it finds the parent class that implements this method, the method is called.</source>
          <target state="translated">该 &lt;code&gt;SUPER::&lt;/code&gt; 位告诉Perl来寻找 &lt;code&gt;print_info()&lt;/code&gt; 在 &lt;code&gt;File::MP3&lt;/code&gt; 类的继承链。当找到实现此方法的父类时，将调用该方法。</target>
        </trans-unit>
        <trans-unit id="3f5b4cff6fbfe1c281604ef06c021cd92e1eaa6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; modifier can</source>
          <target state="translated">该 &lt;code&gt;SUPER&lt;/code&gt; 改性剂可</target>
        </trans-unit>
        <trans-unit id="371b5ebfc9cdf0db9a0a55eae240989e954cb726" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; pseudo-class is resolved from the package where the call is made. It is</source>
          <target state="translated">该 &lt;code&gt;SUPER&lt;/code&gt; 伪类是从哪里拨制成的包装解决。它是</target>
        </trans-unit>
        <trans-unit id="00f36328e65732130767ca69dab4491f0365d24c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; pseudo-class that was described earlier is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7a3a508d1d6570aa1ef0df5ea57827a95bbfc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SV_FORCE_UTF8_UPGRADE&lt;/code&gt; flag is now ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9315ac1b0e03b32c4d0f032e1290883c21a935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Script&lt;/code&gt; or &lt;code&gt;Script_Extensions&lt;/code&gt; properties are likely to be the ones you want to use when processing natural language; the &lt;code&gt;Block&lt;/code&gt; property may occasionally be useful in working with the nuts and bolts of Unicode.</source>
          <target state="translated">该 &lt;code&gt;Script&lt;/code&gt; 或 &lt;code&gt;Script_Extensions&lt;/code&gt; 性质可能是处理自然语言，当你想使用的人; 的 &lt;code&gt;Block&lt;/code&gt; 属性可能偶尔会在使用Unicode的螺母和螺栓的工作是有用的。</target>
        </trans-unit>
        <trans-unit id="0c768e6f5d4be03a1a932a1028083efcf53f3ba5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Script_Extensions&lt;/code&gt; or &lt;code&gt;Script&lt;/code&gt; properties are likely to be the ones you want to use when processing natural language; the &lt;code&gt;Block&lt;/code&gt; property may occasionally be useful in working with the nuts and bolts of Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2c75703b39600771c0a8ce5df27de06d22689b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Script_Extensions&lt;/code&gt; property as modified by UTS 39 (&lt;a href=&quot;https://unicode.org/reports/tr39/&quot;&gt;https://unicode.org/reports/tr39/&lt;/a&gt;) is used as the basis for this feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0daac5f890ff04f28fabf32094505977d698c4f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Storable::last_op_in_netorder()&lt;/code&gt; predicate will tell you whether network order was used in the last store or retrieve operation. If you don't know how to use this, just forget about it.</source>
          <target state="translated">该 &lt;code&gt;Storable::last_op_in_netorder()&lt;/code&gt; 谓词会告诉你是否在过去的商店使用或检索操作网络秩序。如果您不知道如何使用它，那就别管它了。</target>
        </trans-unit>
        <trans-unit id="4f2453d7aa3fb23473e60b4a26a3d26672cf6341" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TODO:&lt;/code&gt; and &lt;code&gt;$TODO&lt;/code&gt; syntax is generally pretty good about figuring out whether or not we're in a TODO test. However, often we find that this is not possible to determine (such as when we want to use &lt;code&gt;$TODO&lt;/code&gt; but the tests are being executed in other packages which can't be inferred beforehand).</source>
          <target state="translated">通常， &lt;code&gt;TODO:&lt;/code&gt; 和 &lt;code&gt;$TODO&lt;/code&gt; 语法可以很好地判断我们是否处于TODO测试中。但是，通常我们发现这是无法确定的（例如，当我们想使用 &lt;code&gt;$TODO&lt;/code&gt; 但是测试是在其他无法事先推断的程序包中执行时）。</target>
        </trans-unit>
        <trans-unit id="316a59c6c105ba5a65d5de6abf6871022622f157" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TO_JSON&lt;/code&gt; method may safely call die if it wants. If &lt;code&gt;TO_JSON&lt;/code&gt; returns other blessed objects, those will be handled in the same way. &lt;code&gt;TO_JSON&lt;/code&gt; must take care of not causing an endless recursion cycle (== crash) in this case. The name of &lt;code&gt;TO_JSON&lt;/code&gt; was chosen because other methods called by the Perl core (== not by the user of the object) are usually in upper case letters and to avoid collisions with any &lt;code&gt;to_json&lt;/code&gt; function or method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94063ef306bbe0bc69a744042850751f57d8165a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; macros are available for situations where using them would clarify intent. (But they always just mean the same as the integers 1 and 0 regardless, so using them isn't compulsory.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca16843b685fa84c8313aca285e376c5597ef322" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TYPEMAP&lt;/code&gt; section should contain one pair of C type and XS type per line as follows. An example from the core typemap file:</source>
          <target state="translated">的 &lt;code&gt;TYPEMAP&lt;/code&gt; 部分应包含一对C类和如下每行XS类型。核心类型映射文件中的示例：</target>
        </trans-unit>
        <trans-unit id="ea8183d7125676dfc1989dcabf04b34c38b4f669" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; function returns a thread object that represents the thread making the &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; call.</source>
          <target state="translated">该 &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; 函数返回一个代表线程使一个线程对象 &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; 电话。</target>
        </trans-unit>
        <trans-unit id="5f72cf2b372d3d426c2948d6098fd6cd1afad651" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; module provides multithreading support for Perl.</source>
          <target state="translated">该 &lt;code&gt;Thread&lt;/code&gt; 模块提供了对Perl多线程的支持。</target>
        </trans-unit>
        <trans-unit id="7fe8315550458ad4289f70c4a27bed2792ae2d78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; module served as the frontend to the old-style thread model, called</source>
          <target state="translated">该 &lt;code&gt;Thread&lt;/code&gt; 担任前台的老样式的线程模型模块，名为</target>
        </trans-unit>
        <trans-unit id="ab5cb47a9617fcafbcf6221a375828cf9de09e24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Time::HiRes&lt;/code&gt; module implements a Perl interface to the &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;nanosleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , and &lt;code&gt;setitimer&lt;/code&gt; /&lt;code&gt;getitimer&lt;/code&gt; system calls, in other words, high resolution time and timers. See the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; section below and the test scripts for usage; see your system documentation for the description of the underlying &lt;code&gt;nanosleep&lt;/code&gt; or &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , and &lt;code&gt;setitimer&lt;/code&gt; /&lt;code&gt;getitimer&lt;/code&gt; calls.</source>
          <target state="translated">该 &lt;code&gt;Time::HiRes&lt;/code&gt; 模块实现Perl接口 &lt;code&gt;usleep&lt;/code&gt; ， &lt;code&gt;nanosleep&lt;/code&gt; ， &lt;code&gt;ualarm&lt;/code&gt; ， &lt;code&gt;gettimeofday&lt;/code&gt; 的，和 &lt;code&gt;setitimer&lt;/code&gt; / &lt;code&gt;getitimer&lt;/code&gt; 系统调用，换句话说，高分辨率时间和计时器。请参见下面的&lt;a href=&quot;#EXAMPLES&quot;&gt;示例&lt;/a&gt;部分和测试脚本以了解用法。有关底层 &lt;code&gt;nanosleep&lt;/code&gt; 或 &lt;code&gt;usleep&lt;/code&gt; ， &lt;code&gt;ualarm&lt;/code&gt; ， &lt;code&gt;gettimeofday&lt;/code&gt; 和 &lt;code&gt;setitimer&lt;/code&gt; / &lt;code&gt;getitimer&lt;/code&gt; 调用的描述，请参见系统文档。</target>
        </trans-unit>
        <trans-unit id="840bb1616acfc5f4c8448fa1adbdaac8f85745ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Time::HiRes&lt;/code&gt; module implements a Perl interface to the &lt;code&gt;usleep&lt;/code&gt;, &lt;code&gt;nanosleep&lt;/code&gt;, &lt;code&gt;ualarm&lt;/code&gt;, &lt;code&gt;gettimeofday&lt;/code&gt;, and &lt;code&gt;setitimer&lt;/code&gt;/&lt;code&gt;getitimer&lt;/code&gt; system calls, in other words, high resolution time and timers. See the &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; section below and the test scripts for usage; see your system documentation for the description of the underlying &lt;code&gt;nanosleep&lt;/code&gt; or &lt;code&gt;usleep&lt;/code&gt;, &lt;code&gt;ualarm&lt;/code&gt;, &lt;code&gt;gettimeofday&lt;/code&gt;, and &lt;code&gt;setitimer&lt;/code&gt;/&lt;code&gt;getitimer&lt;/code&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db031bd2869c09fc69e58469a4b3b15d15dfaaa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; flag overrides the behavior when a non-allowed (by other flags) malformation is found. If this flag is set, the routine assumes that the caller will raise a warning, and this function will silently just set &lt;code&gt;retlen&lt;/code&gt; to &lt;code&gt;-1&lt;/code&gt; (cast to &lt;code&gt;STRLEN&lt;/code&gt;) and return zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adde2e15da0476d4564064bbc384c4ca957b8d40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VERSION&lt;/code&gt; method returns the version number of the class (package).</source>
          <target state="translated">的 &lt;code&gt;VERSION&lt;/code&gt; 方法返回类（包）的版本号。</target>
        </trans-unit>
        <trans-unit id="d8baa2e2f7c0fd0a2f0c9455f11a42eb910290cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Win32::*&lt;/code&gt; modules in &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;Win32::*&lt;/code&gt; 模块&lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;的Win32&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="365cfe3394d31517ee04bbcb7fdcf61281c556f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Win32::*&lt;/code&gt; modules in &lt;a href=&quot;win32&quot;&gt;Win32&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c47ba9b1855f9e0e157ed96c1dac4112ef8de3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; sequence is supposed to be empty.</source>
          <target state="translated">所述 &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; 序列被认为是空的。</target>
        </trans-unit>
        <trans-unit id="4f3af2152fe286b612ed068b47a818a0a9d55853" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; notation also works in certain circumstances outside the pattern. See &lt;a href=&quot;#Warning-on-%5C1-Instead-of-%241&quot;&gt;&quot;Warning on \1 Instead of $1&quot;&lt;/a&gt; below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c164b87544e368a57522144bf31b4093cb008b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; notation also works in certain circumstances outside the pattern. See &lt;a href=&quot;#Warning-on-%5c1-Instead-of-%241&quot;&gt;Warning on \1 Instead of $1&lt;/a&gt; below for details.</source>
          <target state="translated">该 &lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; 符号也适用于从图案的某些情况。有关详细信息，请参见下面的&lt;a href=&quot;#Warning-on-%5c1-Instead-of-%241&quot;&gt;\ 1而不是$ 1上的警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c49d42a1bfbc0b22f583d2817d2ce107934b83b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\C&lt;/code&gt; is unsupported in lookbehind, because the already treacherous definition of &lt;code&gt;\C&lt;/code&gt; would become even more so when going backwards.</source>
          <target state="translated">该 &lt;code&gt;\C&lt;/code&gt; 是回顾后不支持的，因为已经奸诈定义 &lt;code&gt;\C&lt;/code&gt; 倒退时会变得更加如此。</target>
        </trans-unit>
        <trans-unit id="b97997ed1726a2dd70e1e88046ee54105827a12b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\G&lt;/code&gt; assertion can be used to chain global matches (using &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;), as described in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;. It is also useful when writing &lt;code&gt;lex&lt;/code&gt; -like scanners, when you have several patterns that you want to match against consequent substrings of your string; see the previous reference. The actual location where &lt;code&gt;\G&lt;/code&gt; will match can also be influenced by using &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; as an lvalue: see &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;. Note that the rule for zero-length matches (see &lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;Repeated Patterns Matching a Zero-length Substring&lt;/a&gt;) is modified somewhat, in that contents to the left of &lt;code&gt;\G&lt;/code&gt; are not counted when determining the length of the match. Thus the following will not match forever:</source>
          <target state="translated">所述 &lt;code&gt;\G&lt;/code&gt; 断言可以用于链全局匹配（使用 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; ），如描述&lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;在perlop中的正则表达式报价样算&lt;/a&gt;。当编写 &lt;code&gt;lex&lt;/code&gt; 的扫描器时，当您有几种模式要与字符串的后续子字符串进行匹配时，它也很有用；请参阅前面的参考。 &lt;code&gt;\G&lt;/code&gt; 匹配的实际位置也可以通过使用 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 作为左值来影响：请参见&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;。请注意，零长度匹配的规则（请参见&lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;匹配零长度子字符串的重复模式&lt;/a&gt;）有所修改，其内容位于 &lt;code&gt;\G&lt;/code&gt; 左侧确定比赛时间时不计算在内。因此，以下内容将永远不会匹配：</target>
        </trans-unit>
        <trans-unit id="e1ff47fb2c42daca3a8b3c8a3d0395f0593d6c3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\G&lt;/code&gt; assertion can be used to chain global matches (using &lt;code&gt;m//g&lt;/code&gt;), as described in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt;. It is also useful when writing &lt;code&gt;lex&lt;/code&gt;-like scanners, when you have several patterns that you want to match against consequent substrings of your string; see the previous reference. The actual location where &lt;code&gt;\G&lt;/code&gt; will match can also be influenced by using &lt;code&gt;pos()&lt;/code&gt; as an lvalue: see &lt;a href=&quot;perlfunc#pos&quot;&gt;&quot;pos&quot; in perlfunc&lt;/a&gt;. Note that the rule for zero-length matches (see &lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;&quot;Repeated Patterns Matching a Zero-length Substring&quot;&lt;/a&gt;) is modified somewhat, in that contents to the left of &lt;code&gt;\G&lt;/code&gt; are not counted when determining the length of the match. Thus the following will not match forever:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9300fc0425608314652e19b5173bc5fd7efd18c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\N&lt;/code&gt; character class, not to be confused with the named character sequence &lt;code&gt;\N{NAME}&lt;/code&gt; , denotes any non-newline character in a regular expression.</source>
          <target state="translated">的 &lt;code&gt;\N&lt;/code&gt; 字符类，不与已命名的字符序列相混淆 &lt;code&gt;\N{NAME}&lt;/code&gt; ，表示在正则表达式的任何非换行符。</target>
        </trans-unit>
        <trans-unit id="6fc55e5a124a8f9ba1fb9b74d5a25063c2e050b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\N{...}&lt;/code&gt; construct explicitly refers to a Unicode code point, even if it is one that is also in ASCII. Therefore the string containing it must be Unicode.</source>
          <target state="translated">该 &lt;code&gt;\N{...}&lt;/code&gt; 结构明确指的是Unicode代码点，即使它是一个在ASCII中也。因此，包含它的字符串必须是Unicode。</target>
        </trans-unit>
        <trans-unit id="7f0273d79d748bac786c369cab505ed24fe2cfda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d&lt;/code&gt; gets rid of needing to anchor the pattern, since it forces the result to only match &lt;code&gt;[0-9]&lt;/code&gt;, and the &lt;code&gt;[0-5]&lt;/code&gt; further restricts it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52316cb23d6228b5040f834369875ce8a00e4e55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations can be used both inside and outside of bracketed character classes. Here are some in use:</source>
          <target state="translated">所述 &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; 的缩写可用于括号字符类的内部和外部。这里有一些使用中：</target>
        </trans-unit>
        <trans-unit id="dc3bb1079451a53e38a66554502d10e12737dc82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations can be used both inside and outside of character classes. Here are some in use:</source>
          <target state="translated">所述 &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; 的缩写可用于字符类的内部和外部。这里有一些使用中：</target>
        </trans-unit>
        <trans-unit id="0f2c8f2ff00b285673d694a7e44211cdef772f8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;/code&gt; and &lt;code&gt;\k&lt;/code&gt; notations were introduced in Perl 5.10.0. Prior to that there were no named nor relative numbered capture groups. Absolute numbered groups were referred to using &lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; , etc., and this notation is still accepted (and likely always will be). But it leads to some ambiguities if there are more than 9 capture groups, as &lt;code&gt;\10&lt;/code&gt; could mean either the tenth capture group, or the character whose ordinal in octal is 010 (a backspace in ASCII). Perl resolves this ambiguity by interpreting &lt;code&gt;\10&lt;/code&gt; as a backreference only if at least 10 left parentheses have opened before it. Likewise &lt;code&gt;\11&lt;/code&gt; is a backreference only if at least 11 left parentheses have opened before it. And so on. &lt;code&gt;\1&lt;/code&gt; through &lt;code&gt;\9&lt;/code&gt; are always interpreted as backreferences. There are several examples below that illustrate these perils. You can avoid the ambiguity by always using &lt;code&gt;\g{}&lt;/code&gt; or &lt;code&gt;\g&lt;/code&gt; if you mean capturing groups; and for octal constants always using &lt;code&gt;\o{}&lt;/code&gt; , or for &lt;code&gt;\077&lt;/code&gt; and below, using 3 digits padded with leading zeros, since a leading zero implies an octal constant.</source>
          <target state="translated">在 &lt;code&gt;\g&lt;/code&gt; Perl 5.10.0中引入了\ g和 &lt;code&gt;\k&lt;/code&gt; 表示法。在此之前，没有命名或相对编号的捕获组。绝对编号的组使用 &lt;code&gt;\1&lt;/code&gt; ， &lt;code&gt;\2&lt;/code&gt; 等来引用，并且该表示法仍然被接受（并且可能总是被使用）。但是，如果捕获组超过9个，则会导致一些歧义，因为 &lt;code&gt;\10&lt;/code&gt; 可能表示第十个捕获组，或者八进制序数为010（ASCII的退格键）的字符。 Perl 仅在至少10个左括号之前将 &lt;code&gt;\10&lt;/code&gt; 解释为反向引用，从而解决了这种歧义。同样 &lt;code&gt;\11&lt;/code&gt; 仅当至少有11个左括号在其之前打开时，才为backreference。等等。 &lt;code&gt;\1&lt;/code&gt; 到 &lt;code&gt;\9&lt;/code&gt; 始终被解释为反向引用。下面有几个示例说明了这些危险。如果要捕获组，可以始终使用 &lt;code&gt;\g{}&lt;/code&gt; 或 &lt;code&gt;\g&lt;/code&gt; 来避免歧义。对于始终使用 &lt;code&gt;\o{}&lt;/code&gt; 八进制常量，或者对于 &lt;code&gt;\077&lt;/code&gt; 及以下版本的八进制常量，请使用3位数字加上前导零，因为前导零表示八进制常数。</target>
        </trans-unit>
        <trans-unit id="15b6b1b5929104c2b72fb96a6e633ae2051f4ffd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;/code&gt; and &lt;code&gt;\k&lt;/code&gt; notations were introduced in Perl 5.10.0. Prior to that there were no named nor relative numbered capture groups. Absolute numbered groups were referred to using &lt;code&gt;\1&lt;/code&gt;, &lt;code&gt;\2&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517d2abbf8670e3eaf5c272713d99b8bf67cd7d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; form can be equivalently written as &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; which avoids ambiguity when building a regex by concatenating shorter strings. Otherwise if you had a regex &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt; , you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="translated">所述 &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; 形式可以等同地写为 &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; 通过连接较短字符串构建一个正则表达式时，其避免歧义。否则，如果您有一个正则表达式 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt; ，并且 &lt;code&gt;$a&lt;/code&gt; 包含 &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; ，而 &lt;code&gt;$b&lt;/code&gt; 包含 &lt;code&gt;&quot;37&quot;&lt;/code&gt; ，则会得到 &lt;code&gt;/\g137/&lt;/code&gt; ，这可能不是您想要的。</target>
        </trans-unit>
        <trans-unit id="03256d4028754b69d229d57c7593954c93901408" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; form can be equivalently written as &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; which avoids ambiguity when building a regex by concatenating shorter strings. Otherwise if you had a regex &lt;code&gt;qr/$a$b/&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt;, and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt;, you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1162dcf378fe4b180c42e9c8606223aea754f52f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__DATA__&lt;/code&gt; token tells the perl compiler that the perl code for compilation is finished. Everything after the &lt;code&gt;__DATA__&lt;/code&gt; token is available for reading via the filehandle FOOBAR::DATA, where FOOBAR is the name of the current package when the &lt;code&gt;__DATA__&lt;/code&gt; token is reached. This works just the same as &lt;code&gt;__END__&lt;/code&gt; does in package 'main', but for other modules data after &lt;code&gt;__END__&lt;/code&gt; is not automatically retrievable, whereas data after &lt;code&gt;__DATA__&lt;/code&gt; is. The &lt;code&gt;__DATA__&lt;/code&gt; token is not recognized in versions of perl prior to 5.001m.</source>
          <target state="translated">该 &lt;code&gt;__DATA__&lt;/code&gt; 令牌告诉perl的编译器编译Perl代码完成。 &lt;code&gt;__DATA__&lt;/code&gt; 令牌之后的所有内容都可以通过文件句柄FOOBAR :: DATA读取，其中FOOBAR 是到达 &lt;code&gt;__DATA__&lt;/code&gt; 令牌时的当前包的名称。这与 &lt;code&gt;__END__&lt;/code&gt; 在程序包&amp;ldquo; main&amp;rdquo;中的工作原理相同，但是对于其他模块， &lt;code&gt;__END__&lt;/code&gt; 之后的数据不能自动检索，而 &lt;code&gt;__DATA__&lt;/code&gt; 之后的数据则可以自动检索。该 &lt;code&gt;__DATA__&lt;/code&gt; 令牌不能在Perl之前5.001米版本认可。</target>
        </trans-unit>
        <trans-unit id="aaae759fadc0ccc32d523d9d6a0dc772ae2d9269" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_r&lt;/code&gt; forms are automatically used, starting in Perl 5.28, if you compile your code, with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e846812293eaeddc68b23ea744d79168534a2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , and &lt;code&gt;Z&lt;/code&gt; types gobble just one value, but pack it as a string of length count, padding with nulls or spaces as needed. When unpacking, &lt;code&gt;A&lt;/code&gt; strips trailing whitespace and nulls, &lt;code&gt;Z&lt;/code&gt; strips everything after the first null, and &lt;code&gt;a&lt;/code&gt; returns data with no stripping at all.</source>
          <target state="translated">的 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;A&lt;/code&gt; ，和 &lt;code&gt;Z&lt;/code&gt; 类型吞噬只有一个值，但根据需要包装它作为长度计数，用null填充或空格的字符串。拆包时， &lt;code&gt;A&lt;/code&gt; 会删除结尾的空格和null， &lt;code&gt;Z&lt;/code&gt; 会删除第一个null之后的所有内容，而 &lt;code&gt;a&lt;/code&gt; 则返回没有任何内容的数据。</target>
        </trans-unit>
        <trans-unit id="1a1b3cf59097aca7e4188f4992a603a0b5d6ae0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, and &lt;code&gt;Z&lt;/code&gt; types gobble just one value, but pack it as a string of length count, padding with nulls or spaces as needed. When unpacking, &lt;code&gt;A&lt;/code&gt; strips trailing whitespace and nulls, &lt;code&gt;Z&lt;/code&gt; strips everything after the first null, and &lt;code&gt;a&lt;/code&gt; returns data with no stripping at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893b37c14397452b4b42e37cd794a8b9b2d1eb65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alarm()&lt;/code&gt; function is not implemented on all versions of Windows. Check the documentation for your specific version of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5cca45db774b8d4bbc26743f5dae5512cca0753" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;antlers&lt;/code&gt; import flag tells &lt;code&gt;Class::Accessor&lt;/code&gt; that you want to define your attributes using &lt;code&gt;Moose&lt;/code&gt; -like syntax. The only parameter that you can pass to &lt;code&gt;has&lt;/code&gt; is &lt;code&gt;is&lt;/code&gt; . We recommend that you use this Moose-like syntax if you choose &lt;code&gt;Class::Accessor&lt;/code&gt; since it means you will have a smoother upgrade path if you later decide to move to &lt;code&gt;Moose&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;antlers&lt;/code&gt; 进口标志告诉 &lt;code&gt;Class::Accessor&lt;/code&gt; 要定义使用属性 &lt;code&gt;Moose&lt;/code&gt; 般的语法。你可以传递给唯一的参数 &lt;code&gt;has&lt;/code&gt; 是 &lt;code&gt;is&lt;/code&gt; 。如果您选择 &lt;code&gt;Class::Accessor&lt;/code&gt; ，则建议您使用类似Moose的语法，因为这意味着如果您以后决定迁移到 &lt;code&gt;Moose&lt;/code&gt; ,则升级路径将更加平滑。</target>
        </trans-unit>
        <trans-unit id="96ee1d0dc9d201f79ce6ef0d53eb7c5448972089" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;antlers&lt;/code&gt; import flag tells &lt;code&gt;Class::Accessor&lt;/code&gt; that you want to define your attributes using &lt;code&gt;Moose&lt;/code&gt;-like syntax. The only parameter that you can pass to &lt;code&gt;has&lt;/code&gt; is &lt;code&gt;is&lt;/code&gt;. We recommend that you use this Moose-like syntax if you choose &lt;code&gt;Class::Accessor&lt;/code&gt; since it means you will have a smoother upgrade path if you later decide to move to &lt;code&gt;Moose&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d4c5418acb92744951617bccd4c2bb4e907086" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as_number()&lt;/code&gt; function returns a BigInt from a Math::BigFloat. It uses 'trunc' as rounding mode to make it equivalent to:</source>
          <target state="translated">该 &lt;code&gt;as_number()&lt;/code&gt; 函数返回从数学:: BigFloat一个BIGINT。它使用&amp;ldquo; trunc&amp;rdquo;作为舍入模式，使其等效于：</target>
        </trans-unit>
        <trans-unit id="a93f0f0ee3776b1d1340911a8e79d371cb0d5ce7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;authors&lt;/code&gt; and &lt;code&gt;licenses&lt;/code&gt; methods may also be called as &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;license&lt;/code&gt;, respectively, to match the field name in the distmeta structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4be85862bcecd6790751ef47534ab240cde4eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autodie&lt;/code&gt; pragma has</source>
          <target state="translated">该 &lt;code&gt;autodie&lt;/code&gt; 编译具有</target>
        </trans-unit>
        <trans-unit id="92907be6274b88924410c3eb7108af17c084f529" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autodie&lt;/code&gt; pragma provides a convenient way to replace functions that normally return false on failure with equivalents that throw an exception on failure.</source>
          <target state="translated">自动 &lt;code&gt;autodie&lt;/code&gt; 编译指示提供了一种方便的方法，可以将通常会在失败时返回false的函数替换为在失败时引发异常的等效项。</target>
        </trans-unit>
        <trans-unit id="3ccf77f6494c4bb94f71a5890c3e377c22247ef4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit&lt;/code&gt; interface splits the specified file into a hierarchy rooted at the directory &lt;code&gt;$dir&lt;/code&gt; . It creates directories as needed to reflect class hierarchy, and creates the file</source>
          <target state="translated">该 &lt;code&gt;autosplit&lt;/code&gt; 接口拆分指定的文件到在目录为根的层次 &lt;code&gt;$dir&lt;/code&gt; 。它根据需要创建目录以反映类层次结构，并创建文件</target>
        </trans-unit>
        <trans-unit id="9ec1a56ade0e6bb491c622b2d56bc77a622eb46d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit&lt;/code&gt; interface splits the specified file into a hierarchy rooted at the directory &lt;code&gt;$dir&lt;/code&gt;. It creates directories as needed to reflect class hierarchy, and creates the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc73dbc80868b5e2537b36abd82d968f2ba4c751" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit_lib_modules&lt;/code&gt; form is used in the building of perl. It takes as input a list of files (modules) that are assumed to reside in a directory &lt;b&gt;lib&lt;/b&gt; relative to the current directory. Each file is sent to the autosplitter one at a time, to be split into the directory &lt;b&gt;lib/auto&lt;/b&gt;.</source>
          <target state="translated">该 &lt;code&gt;autosplit_lib_modules&lt;/code&gt; 形式是Perl的建设使用。它以假定位于相对于当前目录的目录&lt;b&gt;lib&lt;/b&gt;中的文件（模块）列表作为输入。每个文件一次发送到&lt;b&gt;自动&lt;/b&gt;拆分器，然后拆分到目录&lt;b&gt;lib / auto&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="423004d21ce960dd9509db30e9f26d66964e12d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autotie&lt;/code&gt; mechanism supports this too. The following code:</source>
          <target state="translated">该 &lt;code&gt;autotie&lt;/code&gt; 机制支持这一点。如下代码：</target>
        </trans-unit>
        <trans-unit id="eadb034339c34e003fe891167b8ebaef4be23657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_clear&lt;/code&gt; function deletes all the elements in the AV* array, but does not actually delete the array itself. The &lt;code&gt;av_undef&lt;/code&gt; function will delete all the elements in the array plus the array itself. The &lt;code&gt;av_extend&lt;/code&gt; function extends the array so that it contains at least &lt;code&gt;key+1&lt;/code&gt; elements. If &lt;code&gt;key+1&lt;/code&gt; is less than the currently allocated length of the array, then nothing is done.</source>
          <target state="translated">该 &lt;code&gt;av_clear&lt;/code&gt; 函数删除在AV *阵列的所有元素，但不实际删除阵列本身。该 &lt;code&gt;av_undef&lt;/code&gt; 功能将删除阵列以及在阵列本身上的所有元素。所述 &lt;code&gt;av_extend&lt;/code&gt; 功能以便它包含至少延伸所述阵列 &lt;code&gt;key+1&lt;/code&gt; 的元件。如果 &lt;code&gt;key+1&lt;/code&gt; 小于当前分配的数组长度，则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="d6bd36bbe209d0e332f324c88cb8fab5da451e26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_store&lt;/code&gt; function, when given a tied array argument, merely copies the magic of the array onto the value to be &quot;stored&quot;, using &lt;code&gt;mg_copy&lt;/code&gt; . It may also return NULL, indicating that the value did not actually need to be stored in the array. [MAYCHANGE] After a call to &lt;code&gt;av_store&lt;/code&gt; on a tied array, the caller will usually need to call &lt;code&gt;mg_set(val)&lt;/code&gt; to actually invoke the perl level &quot;STORE&quot; method on the TIEARRAY object. If &lt;code&gt;av_store&lt;/code&gt; did return NULL, a call to &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; will also be usually necessary to avoid a memory leak. [/MAYCHANGE]</source>
          <target state="translated">的 &lt;code&gt;av_store&lt;/code&gt; 功能，给定一个绑数组参数，仅仅复制阵列上的值的魔术被&amp;ldquo;存储&amp;rdquo;，使用时 &lt;code&gt;mg_copy&lt;/code&gt; 。它还可能返回NULL，指示该值实际上不需要存储在数组中。 [MAYCHANGE]到呼叫后 &lt;code&gt;av_store&lt;/code&gt; 一个绑阵列上，呼叫者将通常需要呼叫 &lt;code&gt;mg_set(val)&lt;/code&gt; 到TIEARRAY对象上实际调用Perl的水平&amp;ldquo;STORE&amp;rdquo;方法。如果 &lt;code&gt;av_store&lt;/code&gt; 确实返回了NULL，则通常也需要调用 &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; 以避免内存泄漏。 [/ MAYCHANGE]</target>
        </trans-unit>
        <trans-unit id="e12306e741c00686916bfa82246266097410a872" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_store&lt;/code&gt; function, when given a tied array argument, merely copies the magic of the array onto the value to be &quot;stored&quot;, using &lt;code&gt;mg_copy&lt;/code&gt;. It may also return NULL, indicating that the value did not actually need to be stored in the array. [MAYCHANGE] After a call to &lt;code&gt;av_store&lt;/code&gt; on a tied array, the caller will usually need to call &lt;code&gt;mg_set(val)&lt;/code&gt; to actually invoke the perl level &quot;STORE&quot; method on the TIEARRAY object. If &lt;code&gt;av_store&lt;/code&gt; did return NULL, a call to &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; will also be usually necessary to avoid a memory leak. [/MAYCHANGE]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0bf6421125301461c635d2914e7cd34219ce4cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_top_index&lt;/code&gt; function returns the highest index value in an array (just like $#array in Perl). If the array is empty, -1 is returned. The &lt;code&gt;av_fetch&lt;/code&gt; function returns the value at index &lt;code&gt;key&lt;/code&gt; , but if &lt;code&gt;lval&lt;/code&gt; is non-zero, then &lt;code&gt;av_fetch&lt;/code&gt; will store an undef value at that index. The &lt;code&gt;av_store&lt;/code&gt; function stores the value &lt;code&gt;val&lt;/code&gt; at index &lt;code&gt;key&lt;/code&gt; , and does not increment the reference count of &lt;code&gt;val&lt;/code&gt; . Thus the caller is responsible for taking care of that, and if &lt;code&gt;av_store&lt;/code&gt; returns NULL, the caller will have to decrement the reference count to avoid a memory leak. Note that &lt;code&gt;av_fetch&lt;/code&gt; and &lt;code&gt;av_store&lt;/code&gt; both return &lt;code&gt;SV**&lt;/code&gt; 's, not &lt;code&gt;SV*&lt;/code&gt; 's as their return value.</source>
          <target state="translated">该 &lt;code&gt;av_top_index&lt;/code&gt; 功能在一个数组（就像$＃数组在Perl）返回指数最高值。如果数组为空，则返回-1。该 &lt;code&gt;av_fetch&lt;/code&gt; 函数返回的索引值 &lt;code&gt;key&lt;/code&gt; ，但如果 &lt;code&gt;lval&lt;/code&gt; 中是不为零，那么 &lt;code&gt;av_fetch&lt;/code&gt; 将存储指数在UNDEF值。该 &lt;code&gt;av_store&lt;/code&gt; 功能将值 &lt;code&gt;val&lt;/code&gt; 索引 &lt;code&gt;key&lt;/code&gt; ，并且不增加的引用计数 &lt;code&gt;val&lt;/code&gt; 。因此，调用者负责处理此问题，并且如果 &lt;code&gt;av_store&lt;/code&gt; 返回NULL，则调用者将不得不减少引用计数以避免内存泄漏。注意 &lt;code&gt;av_fetch&lt;/code&gt; 和 &lt;code&gt;av_store&lt;/code&gt; 都返回 &lt;code&gt;SV**&lt;/code&gt; 而不是 &lt;code&gt;SV*&lt;/code&gt; 作为它们的返回值。</target>
        </trans-unit>
        <trans-unit id="b720f9a7cf39478f335b0b67c7ecec4e7dd453ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_top_index&lt;/code&gt; function returns the highest index value in an array (just like $#array in Perl). If the array is empty, -1 is returned. The &lt;code&gt;av_fetch&lt;/code&gt; function returns the value at index &lt;code&gt;key&lt;/code&gt;, but if &lt;code&gt;lval&lt;/code&gt; is non-zero, then &lt;code&gt;av_fetch&lt;/code&gt; will store an undef value at that index. The &lt;code&gt;av_store&lt;/code&gt; function stores the value &lt;code&gt;val&lt;/code&gt; at index &lt;code&gt;key&lt;/code&gt;, and does not increment the reference count of &lt;code&gt;val&lt;/code&gt;. Thus the caller is responsible for taking care of that, and if &lt;code&gt;av_store&lt;/code&gt; returns NULL, the caller will have to decrement the reference count to avoid a memory leak. Note that &lt;code&gt;av_fetch&lt;/code&gt; and &lt;code&gt;av_store&lt;/code&gt; both return &lt;code&gt;SV**&lt;/code&gt;'s, not &lt;code&gt;SV*&lt;/code&gt;'s as their return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b7a8fbb40ab78219d70980fb393c043d50ef45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; argument specifies the local_addr to bind to. By specifying a bind argument you don't need the bind method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be24d4311997148f32f98999c298c4120e52577" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binmode&lt;/code&gt; function can be called on an opened handle to push additional layers onto the stack, which may also modify the existing layers. &lt;code&gt;binmode&lt;/code&gt; called with no layers will remove or unset any existing layers which transform the byte stream, making the handle suitable for binary data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185e8e007341d198fca87c48c9798b7fe0dfa929" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binmode&lt;/code&gt; operator will attempt to insure that no translation of carriage control occurs on input from or output to this filehandle. Since this involves reopening the file and then restoring its file position indicator, if this function returns FALSE, the underlying filehandle may no longer point to an open file, or may point to a different position in the file than before &lt;code&gt;binmode&lt;/code&gt; was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca3e501abc26cf1405f0402c343ec30915264f88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keywords from C become in Perl &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, respectively. Unlike in C, these do</source>
          <target state="translated">来自C 的 &lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 关键字分别在Perl中的 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 中。与C不同，这些</target>
        </trans-unit>
        <trans-unit id="cf097e70ce7b8cc145798b0019e84f65b1044b49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; keywords from C become in Perl &lt;code&gt;last&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, respectively. Unlike in C, these do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787c128b8b97671abe15918465f291ec006979e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;buffered&lt;/code&gt; attribute of the &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2::Event::Subtest&lt;/a&gt; event will be set to the value of this flag. This means any formatter, listener, etc which looks at the event will know if it was buffered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1750aab93908ada1ee29e1880f7061b67617e505" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cacheout&lt;/code&gt; function will make sure that there's a filehandle open for reading or writing available as the pathname you give it. It automatically closes and re-opens files if you exceed your system's maximum number of file descriptors, or the suggested maximum</source>
          <target state="translated">该 &lt;code&gt;cacheout&lt;/code&gt; 功能将确保有一个句柄开放阅读或你给它的路径写入时，可用。如果您超过系统的最大文件描述符数量或建议的最大数量，它将自动关闭并重新打开文件</target>
        </trans-unit>
        <trans-unit id="2c5778ca552de672cec71f94fb24332cb951e6b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can&lt;/code&gt; method checks to see if the class or object it was called on has a method named &lt;code&gt;$method&lt;/code&gt; . This checks for the method in the class and all of its parents. If the method exists, then a reference to the subroutine is returned. If it does not then &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">该 &lt;code&gt;can&lt;/code&gt; 的方法检查，看是否类或对象，它被称为上有一个名为方法 &lt;code&gt;$method&lt;/code&gt; 。这将检查该类及其所有父级中的方法。如果该方法存在，则返回对该子例程的引用。如果没有，则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b581c43bfa8c63ce0337f8cf0f51834457cb5241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can&lt;/code&gt; method checks to see if the class or object it was called on has a method named &lt;code&gt;$method&lt;/code&gt;. This checks for the method in the class and all of its parents. If the method exists, then a reference to the subroutine is returned. If it does not then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a231f00f91910adc2ab3862d9199fc8f2fdda4f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can_run&lt;/code&gt; function can tell you if a certain binary is installed and if so where, whereas the &lt;code&gt;run&lt;/code&gt; function can actually execute any of the commands you give it and give you a clear return value, as well as adhere to your verbosity settings.</source>
          <target state="translated">该 &lt;code&gt;can_run&lt;/code&gt; 功能可以告诉你，如果安装了某些二进制如果是的话在哪里，而 &lt;code&gt;run&lt;/code&gt; 功能，实际上可以执行任何你给它，给你一个明确的返回值，以及坚持你的级别设置的命令。</target>
        </trans-unit>
        <trans-unit id="ae669119c46135f428f552580c056d83e94ae6fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char*&lt;/code&gt; string does not tell you the whole story, and you can't copy or reconstruct an SV just by copying the string value. Check if the old SV has the UTF8 flag set (</source>
          <target state="translated">该 &lt;code&gt;char*&lt;/code&gt; 字符串不告诉你整个故事，你不能复制或只是通过复制字符串值重建的SV。检查旧的SV是否设置了UTF8标志（</target>
        </trans-unit>
        <trans-unit id="3b094d933bb88b4ae1f6722063975d6ce16a864f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;charnames&lt;/code&gt; pragma supports arguments &lt;code&gt;:full&lt;/code&gt; , &lt;code&gt;:loose&lt;/code&gt; , &lt;code&gt;:short&lt;/code&gt; , script names and &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;customized aliases&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;charnames&lt;/code&gt; 编译支持论据 &lt;code&gt;:full&lt;/code&gt; ， &lt;code&gt;:loose&lt;/code&gt; ， &lt;code&gt;:short&lt;/code&gt; ，脚本的名称和&lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;自定义的别名&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3385057bdbf70e4b65ad1d11db30e12395abd68a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;charnames&lt;/code&gt; pragma supports arguments &lt;code&gt;:full&lt;/code&gt;, &lt;code&gt;:loose&lt;/code&gt;, &lt;code&gt;:short&lt;/code&gt;, script names and &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;customized aliases&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f351acbd57d2d1102a02f0ad7f0071439704163" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chr()&lt;/code&gt; and &lt;code&gt;ord()&lt;/code&gt; functions work on whole characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf018bbe36ec38be15a617cdd0dc65af5cb382c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cmp&lt;/code&gt; (and hence &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;) operators do not necessarily give the correct results when both operands are UTF-EBCDIC encoded strings and there is a mixture of ASCII and/or control characters, along with other characters.</source>
          <target state="translated">当两个操作数都是UTF-EBCDIC编码的字符串并且混合了ASCII和/或控制字符以及其他字符时， &lt;code&gt;cmp&lt;/code&gt; （并因此是 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; ）运算符不一定给出正确的结果。</target>
        </trans-unit>
        <trans-unit id="ec09ece4b13035db3b64ac6559a812694d130f2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;color&lt;/code&gt; function determines if colouring should occur or not. Passing it a true or false value will enable or disable colouring respectively, and the function called with no argument will return the current setting.</source>
          <target state="translated">的 &lt;code&gt;color&lt;/code&gt; 函数确定着色应该发生与否。为其传递true或false值将分别启用或禁用着色，并且不带参数调用的函数将返回当前设置。</target>
        </trans-unit>
        <trans-unit id="fcc832a2467057f7acfd689fa1bb07925f149ce1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complicated&lt;/code&gt; function will return the same numeric &lt;code&gt;$result&lt;/code&gt; regardless of whether it is called in list or in scalar context.</source>
          <target state="translated">在 &lt;code&gt;complicated&lt;/code&gt; 函数将返回相同的数值 &lt;code&gt;$result&lt;/code&gt; ，无论它被称为列表或者在标量上下文。</target>
        </trans-unit>
        <trans-unit id="f67952b359119ecd8ea38089ffb10eb7987a4172" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_broadcast&lt;/code&gt; function works similarly to &lt;code&gt;cond_signal&lt;/code&gt; . &lt;code&gt;cond_broadcast&lt;/code&gt; , though, will unblock &lt;b&gt;all&lt;/b&gt; the threads that are blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the locked variable, rather than only one.</source>
          <target state="translated">该 &lt;code&gt;cond_broadcast&lt;/code&gt; 功能工作，以同样 &lt;code&gt;cond_signal&lt;/code&gt; 。但是， &lt;code&gt;cond_broadcast&lt;/code&gt; 将取消阻塞在 &lt;code&gt;cond_wait&lt;/code&gt; 中被锁定的变量（而不是仅一个）上的&lt;b&gt;所有&lt;/b&gt;线程。</target>
        </trans-unit>
        <trans-unit id="2c18198f3431b0af0518f8194180bdd1d59f0718" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_broadcast&lt;/code&gt; function works similarly to &lt;code&gt;cond_signal&lt;/code&gt;. &lt;code&gt;cond_broadcast&lt;/code&gt;, though, will unblock &lt;b&gt;all&lt;/b&gt; the threads that are blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the locked variable, rather than only one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85c76c4fd238a57c5f21f762fcaeb20729d17df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt; ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="translated">该 &lt;code&gt;cond_signal&lt;/code&gt; 函数接受一个&lt;b&gt;锁定&lt;/b&gt;变量作为参数，并接通一个线程的 &lt;code&gt;cond_wait&lt;/code&gt; 该变量ING。如果在该变量的 &lt;code&gt;cond_wait&lt;/code&gt; 中阻塞了多个线程，则只有一个（不确定哪个线程）将被取消阻塞。</target>
        </trans-unit>
        <trans-unit id="17177c8bfdab5cbbef640ed5fdbe840af84bd3e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt;ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5be06c4673c5f0381dc64821a424c5ce57dffbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a locked variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt; ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="translated">该 &lt;code&gt;cond_signal&lt;/code&gt; 函数接受一个加锁的变量作为参数，并放开一个线程的 &lt;code&gt;cond_wait&lt;/code&gt; 该变量ING。如果在该变量的 &lt;code&gt;cond_wait&lt;/code&gt; 中阻塞了一个以上的线程，则只有一个（不确定哪个线程）将被取消阻塞。</target>
        </trans-unit>
        <trans-unit id="90834b3f231b489213b8a6d3ee5e7273db92badc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a locked variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt;ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076e7dbb91376a2a5dc565f0cafe6a8c9c90bfab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is re-locked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt; ing on the same variable, all but one will re-block waiting to reacquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible). The two actions of unlocking the variable and entering the blocked wait state are atomic, the two actions of exiting from the blocked wait state and re-locking the variable are not.</source>
          <target state="translated">的 &lt;code&gt;cond_wait&lt;/code&gt; 函数接受一个&lt;b&gt;锁定&lt;/b&gt;变量作为参数，解锁变量，块，直到另一个线程做了 &lt;code&gt;cond_signal&lt;/code&gt; 或 &lt;code&gt;cond_broadcast&lt;/code&gt; 该相同锁定变量。该变量 &lt;code&gt;cond_wait&lt;/code&gt; 阻塞是重新锁定后 &lt;code&gt;cond_wait&lt;/code&gt; 满足。如果在同一个变量上有多个 &lt;code&gt;cond_wait&lt;/code&gt; 线程，则除一个线程外的所有线程都将重新阻塞，以等待重新获取该变量的锁。 （因此，如果您仅使用 &lt;code&gt;cond_wait&lt;/code&gt; 为了同步，请尽快放弃该锁）。解锁变量和进入阻塞等待状态的两个动作是原子的，退出阻塞等待状态和重新锁定变量的两个动作不是原子的。</target>
        </trans-unit>
        <trans-unit id="439f35352dbf1d510415ebca01133fb2e86790ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is re-locked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt;ing on the same variable, all but one will re-block waiting to reacquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible). The two actions of unlocking the variable and entering the blocked wait state are atomic, the two actions of exiting from the blocked wait state and re-locking the variable are not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa04a005ef5fee3bbdeb8f830aca63065ce2e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is relocked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt; ing on the same variable, all but one will reblock waiting to re-acquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible.)</source>
          <target state="translated">的 &lt;code&gt;cond_wait&lt;/code&gt; 函数接受一个&lt;b&gt;锁定&lt;/b&gt;变量作为参数，解锁变量，块，直到另一个线程做了 &lt;code&gt;cond_signal&lt;/code&gt; 或 &lt;code&gt;cond_broadcast&lt;/code&gt; 该相同锁定变量。满足 &lt;code&gt;cond_wait&lt;/code&gt; 之后，将重新锁定 &lt;code&gt;cond_wait&lt;/code&gt; 阻塞的变量。如果在同一变量上有多个 &lt;code&gt;cond_wait&lt;/code&gt; 线程，则除一个线程外的所有线程都将重新阻塞，以等待重新获取该变量的锁。 （因此，如果您仅使用 &lt;code&gt;cond_wait&lt;/code&gt; 进行同步，请尽快放弃该锁。）</target>
        </trans-unit>
        <trans-unit id="ad78498a67881045948d88db7f3bfb4f745feb3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is relocked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt;ing on the same variable, all but one will reblock waiting to re-acquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05e65092ed5c30b3ec99766dc7198ef2d697366" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;condition&lt;/code&gt; can have several forms. The first form is simply an integer in parentheses &lt;code&gt;(integer)&lt;/code&gt; . It is true if the corresponding backreference &lt;code&gt;\integer&lt;/code&gt; matched earlier in the regexp. The same thing can be done with a name associated with a capture group, written as &lt;code&gt;(&amp;lt;name&amp;gt;)&lt;/code&gt; or &lt;code&gt;('name')&lt;/code&gt; . The second form is a bare zero-width assertion &lt;code&gt;(?...)&lt;/code&gt;, either a lookahead, a lookbehind, or a code assertion (discussed in the next section). The third set of forms provides tests that return true if the expression is executed within a recursion (&lt;code&gt;(R)&lt;/code&gt; ) or is being called from some capturing group, referenced either by number (&lt;code&gt;(R1)&lt;/code&gt; , &lt;code&gt;(R2)&lt;/code&gt; ,...) or by name (&lt;code&gt;(R&amp;amp;name)&lt;/code&gt; ).</source>
          <target state="translated">该 &lt;code&gt;condition&lt;/code&gt; 可以有几种形式。第一种形式只是括号中的整数 &lt;code&gt;(integer)&lt;/code&gt; 。如果相应的反向引用 &lt;code&gt;\integer&lt;/code&gt; 在正则表达式中较早匹配，则为true 。可以使用与捕获组关联的名称来完成同一件事，该名称用 &lt;code&gt;(&amp;lt;name&amp;gt;)&lt;/code&gt; 或 &lt;code&gt;('name')&lt;/code&gt; 表示。第二种形式是裸零宽度断言 &lt;code&gt;(?...)&lt;/code&gt; ，可以是超前，后向或代码断言（在下一节中讨论）。第三组形式提供了以下测试：如果表达式是在递归（ &lt;code&gt;(R)&lt;/code&gt; ）中执行的，或者是从某个捕获组中调用的，则返回true ，这些捕获组可以用数字（ &lt;code&gt;(R1)&lt;/code&gt; ， &lt;code&gt;(R2)&lt;/code&gt; ，...）或按名称（ &lt;code&gt;(R&amp;amp;name)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ad47d7c085885e724ad5ee56f7fe5e436f8b9c0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;context()&lt;/code&gt; function will always return the current context. If there is already a context active, it will be returned. If there is not an active context, one will be generated. When a context is generated it will default to using the file and line number where the currently running sub was called from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec10fe3aaaca1b55ef86de9fafc8bbe404ebad2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;context()&lt;/code&gt; method is your primary interface into the Test2 framework.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf42e706aa15e3b9613116ccaae1bce3997d5965" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; function takes two parameters: a file to copy from and a file to copy to. Either argument may be a string, a FileHandle reference or a FileHandle glob. Obviously, if the first argument is a filehandle of some sort, it will be read from, and if it is a file</source>
          <target state="translated">该 &lt;code&gt;copy&lt;/code&gt; 函数有两个参数：从文件拷贝和复制到文件中。自变量可以是字符串，FileHandle引用或FileHandle Glob。显然，如果第一个参数是某种文件句柄，则将从中读取它，并且如果它是文件</target>
        </trans-unit>
        <trans-unit id="bb585d66ac9e0baf39acd70331ff3f0f5eef7b95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cpp&lt;/code&gt; filter does not apply to the text of the Fred module, only to the text of the file that used it (&lt;code&gt;cpp_test&lt;/code&gt; ). Although the use statement on line 3 will pass through the cpp filter, the module that gets included (&lt;code&gt;Fred&lt;/code&gt; ) will not. The source streams look like this after line 3 has been parsed and before line 4 is parsed:</source>
          <target state="translated">该 &lt;code&gt;cpp&lt;/code&gt; 过滤器并不适用于弗雷德模块的文本，只对使用它的文件（文本 &lt;code&gt;cpp_test&lt;/code&gt; ）。尽管第3行上的use语句将通过cpp过滤器，但包含的模块（ &lt;code&gt;Fred&lt;/code&gt; ）不会通过。在解析第3行之后和解析第4行之前，源流如下所示：</target>
        </trans-unit>
        <trans-unit id="cb5beac8049360b845cf124791fe07ff9a12d34c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cpp&lt;/code&gt; filter does not apply to the text of the Fred module, only to the text of the file that used it (&lt;code&gt;cpp_test&lt;/code&gt;). Although the use statement on line 3 will pass through the cpp filter, the module that gets included (&lt;code&gt;Fred&lt;/code&gt;) will not. The source streams look like this after line 3 has been parsed and before line 4 is parsed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a0e889b0f475939308ccb8373e116461d3751c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;create()&lt;/code&gt; method takes a reference to a subroutine and creates a new thread that starts executing in the referenced subroutine. Control then passes both to the subroutine and the caller.</source>
          <target state="translated">的 &lt;code&gt;create()&lt;/code&gt; 方法花费的子程序的参考，并创建开始在引用的子程序执行新线程。然后，控制将传递给子例程和调用者。</target>
        </trans-unit>
        <trans-unit id="4daee3058488514b062a77504cbed0c79eee6390" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypt&lt;/code&gt; operator uses the &lt;code&gt;sys$hash_password&lt;/code&gt; system service to generate the hashed representation of PLAINTEXT. If USER is a valid username, the algorithm and salt values are taken from that user's UAF record. If it is not, then the preferred algorithm and a salt of 0 are used. The quadword encrypted value is returned as an 8-character string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3224bd5303e6f5ddff9eaa9e8454f4b95ad9fcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;curlen&lt;/code&gt; length parameter passed in was too small, and the function was prevented from examining all the necessary bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b2e5dabf98fd166f3cc23d1829d0ea566d66df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;declare()&lt;/code&gt; method always creates dotted-decimal version objects. When used in a module, you &lt;b&gt;must&lt;/b&gt; put it on the same line as &quot;use version&quot; to ensure that $VERSION is read correctly by PAUSE and installer tools. You should also add 'version' to the 'configure_requires' section of your module metadata file. See instructions in &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; or &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af1cb7eb6b21f006259e64b150fa56903267e60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete local EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;&quot;Localized deletion of elements of composite types&quot; in perlsub&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69524f53f96840e72cc2460d82457b60c364f5a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete local EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;&quot;Localized deletion of elements of composite types&quot; in perlsub&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b3d6c14b075946962dafa1dc3a2886740f908a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;diagnostics&lt;/code&gt; Pragma</source>
          <target state="translated">该 &lt;code&gt;diagnostics&lt;/code&gt; 附注</target>
        </trans-unit>
        <trans-unit id="086b0e345be46fb23c5d4022bc1b3516ac49d7c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;display_format&lt;/code&gt; class method and the corresponding &lt;code&gt;display_format&lt;/code&gt; object method can now be called using a parameter hash instead of just a one parameter.</source>
          <target state="translated">该 &lt;code&gt;display_format&lt;/code&gt; 类方法和相应的 &lt;code&gt;display_format&lt;/code&gt; 对象方法现在可以使用一个参数散列而不只是一个参数被调用。</target>
        </trans-unit>
        <trans-unit id="a9abe66ed186f7fcb344af8814b57766600779f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do {}&lt;/code&gt; construct isn't a real loop that you can use loop control on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85937d63d0c2a7155254307de5c15a8dc64cc7fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;done&lt;/code&gt; method returns true if the thread you're checking has finished, and false otherwise.</source>
          <target state="translated">该 &lt;code&gt;done&lt;/code&gt; 真正的方法返回如果线程您检查已完成，否则为false。</target>
        </trans-unit>
        <trans-unit id="322d30ea9fcb9b2fb4107fa041a490d3eef3fbe8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dontfrag&lt;/code&gt; argument sets the IP_DONTFRAG bit, but note that IP_DONTFRAG is not yet defined by Socket, and not available on many systems. Then it is ignored. On linux it also sets IP_MTU_DISCOVER to IP_PMTUDISC_DO but need we don't chunk oversized packets. You need to set $data_size manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c42a2b150a081cef9d9a1db39370eb144f13339" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down&lt;/code&gt; method decreases the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">该 &lt;code&gt;down&lt;/code&gt; 的方法由指定的数目，如果没有指定数目（它必须是整数&amp;gt; = 1），或由一个减小信号量的计数。</target>
        </trans-unit>
        <trans-unit id="1d986e9044d0332c0e0b20d1b476092f758b1763" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_force&lt;/code&gt; method decreases the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified. This method does not block, and may cause the semaphore's count to drop below zero.</source>
          <target state="translated">该 &lt;code&gt;down_force&lt;/code&gt; 方法由指定数目如果没有指定数目（它必须是整数&amp;gt; = 1），或由一个减小信号量的计数。此方法不会阻塞，并且可能导致信号量的计数降至零以下。</target>
        </trans-unit>
        <trans-unit id="59032671c2f862c61987094dab4187139af577bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_nb&lt;/code&gt; method attempts to decrease the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">该 &lt;code&gt;down_nb&lt;/code&gt; 方法试图通过指定的号码，如果没有指定数目（它必须是整数&amp;gt; = 1），或由一个以降低信号量的计数。</target>
        </trans-unit>
        <trans-unit id="ad817bd0c55a8a17c45e80be5bfb80185a6f0a13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_timed&lt;/code&gt; method attempts to decrease the semaphore's count by 1 or by the specified number within the specified timeout period given in seconds (which must be an integer &amp;gt;= 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b4509e2a48be8cd2c584657729b851defbc375" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;each()&lt;/code&gt; operator can be a bit tricky though. You can't add or delete keys of the hash while you're using it without possibly skipping or re-processing some pairs after Perl internally rehashes all of the elements. Additionally, a hash has only one iterator, so if you mix &lt;code&gt;keys&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;, or &lt;code&gt;each&lt;/code&gt; on the same hash, you risk resetting the iterator and messing up your processing. See the &lt;code&gt;each&lt;/code&gt; entry in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eb0881abe1e42d6f6890023e371e6cf04aeaeaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;each&lt;/code&gt; operator returns the pairs in apparently random order, so if ordering matters to you, you'll have to stick with the &lt;code&gt;keys&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac628ac906a6e8c64ae1a2404030120f69cfb8c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;else&lt;/code&gt; branch should be used for the really ultimate fallback, not for code specific to some platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48ce45b8c5dc5a90ffb8cc26e428eb8e7134ca2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eogc&lt;/code&gt; flags are stripped out before being passed to the comp routine. The regex engine does not need to know if any of these are set, as those flags should only affect what Perl does with the pattern and its match variables, not how it gets compiled and executed.</source>
          <target state="translated">该 &lt;code&gt;eogc&lt;/code&gt; 标志传递给补偿程序之前被剥离出来。正则表达式引擎不需要知道是否设置了其中任何一个，因为这些标志仅会影响Perl对模式及其匹配变量的作用，而不会影响其如何编译和执行。</target>
        </trans-unit>
        <trans-unit id="5dcaf0131993c2fe373ceb68066111b75397ce84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equal()&lt;/code&gt; method takes two thread objects and returns true if the objects represent the same thread, and false if they don't.</source>
          <target state="translated">该 &lt;code&gt;equal()&lt;/code&gt; 方法有两个线程对象，并返回true，如果对象表示相同的线程，假如果他们不这样做。</target>
        </trans-unit>
        <trans-unit id="49890ceef3269a9849305b4a6f9b549bc3f0c714" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;errno&lt;/code&gt; value is optional. In versions of &lt;code&gt;autodie::exception&lt;/code&gt; 1.99 and earlier the code would try to automatically use the current value of &lt;code&gt;$!&lt;/code&gt;, but this was unreliable and is no longer supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5c1caef84073c78e4b57183c72209f1a463dd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eval&lt;/code&gt; method wrapped an &lt;code&gt;eval&lt;/code&gt; around a &lt;code&gt;join&lt;/code&gt;, and so waited for a thread to exit, passing along any values the thread might have returned and placing any errors into &lt;code&gt;$@&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80af1149bc4ce69fb624da74e40c6a5dafd9409" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;examples&lt;/code&gt; sub-directory has copies of all these filters implemented both as</source>
          <target state="translated">该 &lt;code&gt;examples&lt;/code&gt; 子目录拥有所有这些过滤器的副本来实现既作为</target>
        </trans-unit>
        <trans-unit id="1c3c6e01b0d3bd33a4ed4055dd31b80304ebc9d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exec&lt;/code&gt; function's job is to turn your process into another command and never to return. If that's not what you want to do, don't use &lt;code&gt;exec&lt;/code&gt;. :)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc84f2c59070bf508814fa3ebed34092fe0cca71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimental&lt;/code&gt; pragma exists to combine the required incantations into a single interface stable across releases of perl. For every experimental feature, this should enable the feature and silence warnings for the enclosing lexical scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="472a34a62dd6bdcf8df5e53d452c5f9dca79546f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extra_mappings&lt;/code&gt; arguments takes a hash ref with the same type of structure as described in &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt;, except with its values as one of the &lt;a href=&quot;#MERGE-STRATEGIES&quot;&gt;defined merge strategies&lt;/a&gt; or a code ref to a merging function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a371087f59ef9684a3303b0318405ae011e9ec34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract_delimited&lt;/code&gt; function formalizes the common idiom of extracting a single-character-delimited substring from the start of a string. For example, to extract a single-quote delimited string, the following code is typically used:</source>
          <target state="translated">该 &lt;code&gt;extract_delimited&lt;/code&gt; 功能正式确定从字符串的开头提取单字符分隔的子串的习惯用法。例如，要提取单引号分隔的字符串，通常使用以下代码：</target>
        </trans-unit>
        <trans-unit id="01013bd276b6d8fe2331fe338d632601823957b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract_multiple&lt;/code&gt; subroutine takes a string to be processed and a list of extractors (subroutines or regular expressions) to apply to that string.</source>
          <target state="translated">该 &lt;code&gt;extract_multiple&lt;/code&gt; 子程序需要要处理的字符串，并提取（子程序或正则表达式）的列表，以适用于该字符串。</target>
        </trans-unit>
        <trans-unit id="0234e9715d2d58dfe4e40eada785cc5d3ba85e48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fail&lt;/code&gt; option indicates the action to be taken if a matching end tag is not encountered (i.e. before the end of the string or some &lt;code&gt;reject&lt;/code&gt; pattern matches). By default, a failure to match a closing tag causes &lt;code&gt;extract_tagged&lt;/code&gt; to immediately fail.</source>
          <target state="translated">如果未遇到匹配的结束标记（例如，在字符串的结尾或某些 &lt;code&gt;reject&lt;/code&gt; 模式匹配之前），则 &lt;code&gt;fail&lt;/code&gt; 选项指示要采取的操作。默认情况下，未能匹配结束标记会导致 &lt;code&gt;extract_tagged&lt;/code&gt; 立即失败。</target>
        </trans-unit>
        <trans-unit id="7fdb136937ca0405fd0e09f20f2a40c4f858261d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;failed&lt;/code&gt; command reports all distributions that failed on one of &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; or &lt;code&gt;install&lt;/code&gt; for some reason in the currently running shell session.</source>
          <target state="translated">该 &lt;code&gt;failed&lt;/code&gt; 命令报告失败对一个所有发行 &lt;code&gt;make&lt;/code&gt; ， &lt;code&gt;test&lt;/code&gt; 或 &lt;code&gt;install&lt;/code&gt; 出于某种原因在当前运行的shell会话。</target>
        </trans-unit>
        <trans-unit id="5ad80da9f3017cad820985c782b83967ca308a28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;family&lt;/code&gt; hint to getaddrinfo(), or the family of the socket address passed to getnameinfo() is not supported.</source>
          <target state="translated">不支持getaddrinfo（）的 &lt;code&gt;family&lt;/code&gt; 提示或传递给getnameinfo（）的套接字地址的族。</target>
        </trans-unit>
        <trans-unit id="acd804f7e1462316c1795d1b040a724ba816aee2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch&lt;/code&gt; command just updates the &lt;code&gt;camel&lt;/code&gt; refs, as the objects themselves should have been fetched when pulling from &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa028e0e10b907654ea97ca6e2e56dbd54cf34e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch&lt;/code&gt; utility is available on FreeBSD. NetBSD and Dragonfly BSD may also have it from &lt;code&gt;pkgsrc&lt;/code&gt; . We only check for &lt;code&gt;fetch&lt;/code&gt; on those three platforms.</source>
          <target state="translated">该 &lt;code&gt;fetch&lt;/code&gt; 实用程序可在FreeBSD。NetBSD和Dragonfly BSD也可能来自 &lt;code&gt;pkgsrc&lt;/code&gt; 。我们仅在这三个平台上检查 &lt;code&gt;fetch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88909127a630a0e568460e4ef567fdf6cebea70a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch&lt;/code&gt; utility is available on FreeBSD. NetBSD and Dragonfly BSD may also have it from &lt;code&gt;pkgsrc&lt;/code&gt;. We only check for &lt;code&gt;fetch&lt;/code&gt; on those three platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e227d5e7190288807dd09d5662a48f3b24c6088" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fforce&lt;/code&gt; pragma is a variant that emulates a &lt;code&gt;force get&lt;/code&gt; which erases the entire memory followed by the action specified, effectively restarting the whole get/make/test/install procedure from scratch.</source>
          <target state="translated">该 &lt;code&gt;fforce&lt;/code&gt; 编译是一个模拟变体 &lt;code&gt;force get&lt;/code&gt; 其擦除整个存储器，然后指定的动作，有效地重启整个GET /化妆/测试/从头开始安装过程。</target>
        </trans-unit>
        <trans-unit id="67136aec5c09887a5fbdbeaf79603ace225d72fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fields&lt;/code&gt; pragma enables compile-time and run-time verified class fields.</source>
          <target state="translated">该 &lt;code&gt;fields&lt;/code&gt; 编译使编译时和运行时验证类字段。</target>
        </trans-unit>
        <trans-unit id="1da25c8608c050c137eec0fcb8b96dfa9d530dcf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filename&lt;/code&gt; , &lt;code&gt;flags&lt;/code&gt; and &lt;code&gt;mode&lt;/code&gt; parameters are the direct equivalent of their dbopen() counterparts. The final parameter $DB_HASH performs the function of both the &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;openinfo&lt;/code&gt; parameters in dbopen().</source>
          <target state="translated">的 &lt;code&gt;filename&lt;/code&gt; ， &lt;code&gt;flags&lt;/code&gt; 和 &lt;code&gt;mode&lt;/code&gt; 参数是其dbopen（）对应的直接等同物。最终参数$ DB_HASH 在dbopen（）中同时执行 &lt;code&gt;type&lt;/code&gt; 和 &lt;code&gt;openinfo&lt;/code&gt; 参数的功能。</target>
        </trans-unit>
        <trans-unit id="d57b7b57482f3e0bdad4f727d65fbd7d3f8d08ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filename&lt;/code&gt;, &lt;code&gt;flags&lt;/code&gt; and &lt;code&gt;mode&lt;/code&gt; parameters are the direct equivalent of their dbopen() counterparts. The final parameter $DB_HASH performs the function of both the &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;openinfo&lt;/code&gt; parameters in dbopen().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711049b66f21cfb21f8abf404e302b9cb973606c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fileparse()&lt;/code&gt; routine divides a file path into its $dirs, $filename and (optionally) the filename $suffix.</source>
          <target state="translated">该 &lt;code&gt;fileparse()&lt;/code&gt; 程序把一个文件路径到其$迪尔斯，$文件名和（可选）的文件名后缀$。</target>
        </trans-unit>
        <trans-unit id="2894a076625213bf8472ba18a1068c216ff2972b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method is always the last thing called on the formatter,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c20640b93e6e1928bfa39a7352c6c3efb0f1519" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument can have &lt;code&gt;UNI_DISPLAY_ISPRINT&lt;/code&gt; set to display &lt;code&gt;isPRINT()&lt;/code&gt;able characters as themselves, &lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; to display the &lt;code&gt;\\[nrfta\\]&lt;/code&gt; as the backslashed versions (like &lt;code&gt;&quot;\n&quot;&lt;/code&gt;) (&lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; is preferred over &lt;code&gt;UNI_DISPLAY_ISPRINT&lt;/code&gt; for &lt;code&gt;&quot;\\&quot;&lt;/code&gt;). &lt;code&gt;UNI_DISPLAY_QQ&lt;/code&gt; (and its alias &lt;code&gt;UNI_DISPLAY_REGEX&lt;/code&gt;) have both &lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; and &lt;code&gt;UNI_DISPLAY_ISPRINT&lt;/code&gt; turned on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602708ab2289d55123d1e5cfa483278e5dc2b095" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument can have UNI_DISPLAY_ISPRINT set to display isPRINT()able characters as themselves, UNI_DISPLAY_BACKSLASH to display the \\[nrfta\\] as the backslashed versions (like '\n') (UNI_DISPLAY_BACKSLASH is preferred over UNI_DISPLAY_ISPRINT for \\). UNI_DISPLAY_QQ (and its alias UNI_DISPLAY_REGEX) have both UNI_DISPLAY_BACKSLASH and UNI_DISPLAY_ISPRINT turned on.</source>
          <target state="translated">的 &lt;code&gt;flags&lt;/code&gt; 参数可以具有UNI_DISPLAY_ISPRINT组显示isprint判断（）能够字符本身，UNI_DISPLAY_BACKSLASH作为反斜杠的版本（如&amp;ldquo;\ n&amp;rdquo;）来显示\\ [nrfta \\（UNI_DISPLAY_BACKSLASH优于UNI_DISPLAY_ISPRINT为\\）。UNI_DISPLAY_QQ（及其别名UNI_DISPLAY_REGEX）同时打开了UNI_DISPLAY_BACKSLASH和UNI_DISPLAY_ISPRINT。</target>
        </trans-unit>
        <trans-unit id="45b476535dde9c4df2a5ce21abd7562e13744b06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument is as in &lt;a href=&quot;#pv_uni_display&quot;&gt;&quot;pv_uni_display&quot;&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2dfe02c9ae062f42652141438a9f9714c71cea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument is as in &lt;a href=&quot;#pv_uni_display&quot;&gt;pv_uni_display&lt;/a&gt;().</source>
          <target state="translated">该 &lt;code&gt;flags&lt;/code&gt; 的说法是在&lt;a href=&quot;#pv_uni_display&quot;&gt;pv_uni_display&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="99738c77e0f1da5722068673963c4a8f215d0b31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; can be:</source>
          <target state="translated">该 &lt;code&gt;flags&lt;/code&gt; 可以是：</target>
        </trans-unit>
        <trans-unit id="cefd6d4dfafa940aea51a92bdcb195eed2de69a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; method returned the flags for the thread - an integer value corresponding to the internal flags for the thread.</source>
          <target state="translated">该 &lt;code&gt;flags&lt;/code&gt; 方法返回的标志的线程-对应于所述线程的内部标记的整数值。</target>
        </trans-unit>
        <trans-unit id="8425d60192539121edf35ab62976eb395bc2a704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; option is optional and defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cca4f06215bca47eddea026c40afe1b9a43be1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter can be used to determine which of these operations the callbacks should respond to. The following flags are currently defined:</source>
          <target state="translated">该 &lt;code&gt;flags&lt;/code&gt; 参数可以用来确定这些操作的回调应该做出响应。当前定义了以下标志：</target>
        </trans-unit>
        <trans-unit id="459faaa5e3280fee22284d6b094987c77fa7de30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter in all the</source>
          <target state="translated">所有参数中的 &lt;code&gt;flags&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="bfe1865df397f3698f54ec1b600413c38607abed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is a bitfield which indicates which of the &lt;code&gt;msixpn&lt;/code&gt; flags the regex was compiled with. It also contains additional info, such as if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect.</source>
          <target state="translated">的 &lt;code&gt;flags&lt;/code&gt; 参数是一个位字段，其指示其中的 &lt;code&gt;msixpn&lt;/code&gt; 标志正则表达式编译时使用。它还包含其他信息，例如 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 是否有效。</target>
        </trans-unit>
        <trans-unit id="6fd73fe1f5c776efd0dba4ac9a66a7649c62b563" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is a bitfield which indicates which of the &lt;code&gt;msixpn&lt;/code&gt; flags the regex was compiled with. It also contains additional info, such as if &lt;code&gt;use locale&lt;/code&gt; is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="600009146ad8caeb28aa4266bb11bcc93c6081be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is reserved for future use, and must always be zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b4f74a7487e51319a762323a60ac4f87b549c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is reserved for future use. Currently it is only used by perl internally, so extensions should always pass zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b886ddfa56e0b9ebfe8f2070d41589a1086768dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flush_cache()&lt;/code&gt; function will raise a run-time error unless the tied package provides a &lt;code&gt;CLEAR&lt;/code&gt; method.</source>
          <target state="translated">所述 &lt;code&gt;flush_cache()&lt;/code&gt; 除非捆绑包提供了一个功能将提高运行时错误 &lt;code&gt;CLEAR&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="124f73ccb9aad8a6d48616fcbcb3b56af5616b10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for(each)&lt;/code&gt; modifier is an iterator: it executes the statement once for each item in the LIST (with &lt;code&gt;$_&lt;/code&gt; aliased to each item in turn). There is no syntax to specify a C-style for loop or a lexically scoped iteration variable in this form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee8bf6c49cb0d370b573c84b81eeff22daa626c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;force&lt;/code&gt; pragma may precede another command (currently: &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; , or &lt;code&gt;install&lt;/code&gt; ) to execute the command from scratch and attempt to continue past certain errors. See the section below on the &lt;code&gt;force&lt;/code&gt; and the &lt;code&gt;fforce&lt;/code&gt; pragma.</source>
          <target state="translated">该 &lt;code&gt;force&lt;/code&gt; 编译可能先于其他命令（目前为： &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;make&lt;/code&gt; ， &lt;code&gt;test&lt;/code&gt; ，或 &lt;code&gt;install&lt;/code&gt; ）从头开始执行命令，并试图继续过去的某些错误。请参见以下有关 &lt;code&gt;force&lt;/code&gt; 和力的 &lt;code&gt;fforce&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34f4026c135fb9c9e701839369f22ab72881f9e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; is the non-experimental way to set a topicalizer. If you wish to use the highly experimental &lt;code&gt;given&lt;/code&gt; , that could be written like this:</source>
          <target state="translated">该 &lt;code&gt;foreach&lt;/code&gt; 是非实验的方法来设置一个topicalizer。如果您想使用 &lt;code&gt;given&lt;/code&gt; 的高度实验性，可以这样写：</target>
        </trans-unit>
        <trans-unit id="8adf50b4a12807b9b440b3e9dd59f76950784e30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; is the non-experimental way to set a topicalizer. If you wish to use the highly experimental &lt;code&gt;given&lt;/code&gt;, that could be written like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de226564415ab69d6441fa2857763cf2ce5fdae3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword, so you can use either. If VAR is omitted, &lt;code&gt;$_&lt;/code&gt; is set to each value.</source>
          <target state="translated">该 &lt;code&gt;foreach&lt;/code&gt; 关键字实际上是对一个同义词 &lt;code&gt;for&lt;/code&gt; 关键字，这样你就可以使用。如果省略VAR，则将 &lt;code&gt;$_&lt;/code&gt; 设置为每个值。</target>
        </trans-unit>
        <trans-unit id="eb1c9008000e928d5125162497dd929b484cbedf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword. See &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;&quot;Foreach Loops&quot; in perlsyn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375dcc1d1d2f6f42cca4896811ca8fdfa2d3b491" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword. See &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;Foreach Loops in perlsyn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;foreach&lt;/code&gt; 关键字实际上是对一个同义词 &lt;code&gt;for&lt;/code&gt; 关键字。请参见 &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;Foreach Loops in perlsyn&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b86bb402e5da8037aee4e69efe060f892f194612" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop can also take a reference constructor for its loop variable, though the syntax is limited to one of the following, with an optional &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; after the backslash:</source>
          <target state="translated">该 &lt;code&gt;foreach&lt;/code&gt; 循环还可以利用它的循环变量的引用构造函数，虽然语法限于下列情况之一，使用可选的 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; ，还是 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 反斜杠后：</target>
        </trans-unit>
        <trans-unit id="21bbc47a2581808651eb8a89a9f603b84e2a2657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop can also take a reference constructor for its loop variable, though the syntax is limited to one of the following, with an optional &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt;, or &lt;code&gt;our&lt;/code&gt; after the backslash:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c367bfb9bb4dab65fff1b13521d38572d69dfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop defaults to scoping its index variable dynamically in the manner of &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;. However, if the index variable is prefixed with the keyword &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, or if there is already a lexical by that name in scope, then a new lexical is created instead. Thus in the loop</source>
          <target state="translated">所述 &lt;code&gt;foreach&lt;/code&gt; 循环默认为动态范围设定其索引变量的方式 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 。但是，如果index变量以关键字 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 开头，或者如果作用域中已经存在该名称的词法，则将创建一个新词法。因此在循环中</target>
        </trans-unit>
        <trans-unit id="fc6d0492eecb0b7b77ecb47ab19f74f65e2c9439" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop defaults to scoping its index variable dynamically in the manner of &lt;code&gt;local&lt;/code&gt;. However, if the index variable is prefixed with the keyword &lt;code&gt;my&lt;/code&gt;, or if there is already a lexical by that name in scope, then a new lexical is created instead. Thus in the loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c4603cb509242d80999a110064359f577c21d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop iterates over a normal list value and sets the scalar variable VAR to be each element of the list in turn. If the variable is preceded with the keyword &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, then it is lexically scoped, and is therefore visible only within the loop. Otherwise, the variable is implicitly local to the loop and regains its former value upon exiting the loop. If the variable was previously declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, it uses that variable instead of the global one, but it's still localized to the loop. This implicit localization occurs</source>
          <target state="translated">所述 &lt;code&gt;foreach&lt;/code&gt; 超过正常列表值循环迭代，并设置标量变量VAR是反过来的列表的每个元素。如果变量以关键字 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 开头，则它在词法范围内，因此仅在循环中可见。否则，变量在循环中是隐式局部的，并在退出循环时重新获得其先前的值。如果该变量先前是使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明的，则它将使用该变量而不是全局变量，但仍将其本地化到循环中。发生这种隐式本地化</target>
        </trans-unit>
        <trans-unit id="d0916d837b24f716ed6d234f4dd39fce8bf3c636" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop iterates over a normal list value and sets the scalar variable VAR to be each element of the list in turn. If the variable is preceded with the keyword &lt;code&gt;my&lt;/code&gt;, then it is lexically scoped, and is therefore visible only within the loop. Otherwise, the variable is implicitly local to the loop and regains its former value upon exiting the loop. If the variable was previously declared with &lt;code&gt;my&lt;/code&gt;, it uses that variable instead of the global one, but it's still localized to the loop. This implicit localization occurs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb381f2681e84a2954e18395a958e606ca6cba3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame&lt;/code&gt; option can be used to control the output of frame information. For example, contrast this expression trace:</source>
          <target state="translated">该 &lt;code&gt;frame&lt;/code&gt; 选项可用于控制的帧信息的输出。例如，对比此表达式跟踪：</target>
        </trans-unit>
        <trans-unit id="591f72361e30bcbf229773b985f4b81bad64b394" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gateway&lt;/code&gt; argument is only valid for IPv6, and requires a IPv6 address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01af8f56de621025abc07dc645713da63a5fe927" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_delimited_pat&lt;/code&gt; subroutine takes a single (string) argument and &amp;gt; builds a Friedl-style optimized regex that matches a string delimited by any one of the characters in the single argument. For example:</source>
          <target state="translated">所述 &lt;code&gt;gen_delimited_pat&lt;/code&gt; 子程序采用一个（字符串）参数，并&amp;gt;建立，通过在单一的参数中的字符中的任一项限定的字符串相匹配的弗里德尔式优化正则表达式。例如：</target>
        </trans-unit>
        <trans-unit id="617ccfb027c1e5d2773071a87cbcedc95dc112aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get_dup&lt;/code&gt; method assists in reading duplicate values from BTREE databases. The method can take the following forms:</source>
          <target state="translated">该 &lt;code&gt;get_dup&lt;/code&gt; 从BTREE数据库中读取数据的重复值法助攻。该方法可以采用以下形式：</target>
        </trans-unit>
        <trans-unit id="38757d13de90c9736c762577e50e5a7475bfa2f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getname&lt;/code&gt; function returns the file specification associated with a Perl I/O handle. If an error occurs, it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea986ecd3305b94f4546f1c6e3ce692488dd0fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopt()&lt;/code&gt; function is similar, but its argument is a string containing all switches that take an argument. If no argument is provided for a switch, say, &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, the corresponding &lt;code&gt;$opt_y&lt;/code&gt; will be set to an undefined value. Unspecified switches are silently accepted. Use of &lt;code&gt;getopt()&lt;/code&gt; is not recommended.</source>
          <target state="translated">所述 &lt;code&gt;getopt()&lt;/code&gt; 函数是类似的，但它的参数是含有带参数的所有开关的字符串。如果没有为开关提供参数，例如 &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; ，则相应的 &lt;code&gt;$opt_y&lt;/code&gt; 将被设置为未定义的值。未指定的开关将被静默接受。不建议使用 &lt;code&gt;getopt()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8dad5d808a96d01abfb75223a15354d771a92d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopt()&lt;/code&gt; function is similar, but its argument is a string containing all switches that take an argument. If no argument is provided for a switch, say, &lt;code&gt;y&lt;/code&gt;, the corresponding &lt;code&gt;$opt_y&lt;/code&gt; will be set to an undefined value. Unspecified switches are silently accepted. Use of &lt;code&gt;getopt()&lt;/code&gt; is not recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c037451f79364fbd043155e0ffbbe91d2a70fbad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function processes single-character switches with switch clustering. Pass one argument which is a string containing all switches to be recognized. For each switch found, if an argument is expected and provided, &lt;code&gt;getopts()&lt;/code&gt; sets &lt;code&gt;$opt_x&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is the switch name) to the value of the argument. If an argument is expected but none is provided, &lt;code&gt;$opt_x&lt;/code&gt; is set to an undefined value. If a switch does not take an argument, &lt;code&gt;$opt_x&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;getopts()&lt;/code&gt; 函数处理单字符与开关聚类切换。传递一个参数，该参数是一个包含所有要识别的开关的字符串。对于每个开关发现，如果参数是预期的和提供， &lt;code&gt;getopts()&lt;/code&gt; 设置 &lt;code&gt;$opt_x&lt;/code&gt; （其中 &lt;code&gt;x&lt;/code&gt; 是交换机名称）该参数的值。如果需要参数，但不提供，则 &lt;code&gt;$opt_x&lt;/code&gt; 设置为未定义的值。如果开关不带参数，则 &lt;code&gt;$opt_x&lt;/code&gt; 设置为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91aef3725c2efdb205ada4f0830cb2c2f0326f3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function processes single-character switches with switch clustering. Pass one argument which is a string containing all switches to be recognized. For each switch found, if an argument is expected and provided, &lt;code&gt;getopts()&lt;/code&gt; sets &lt;code&gt;$opt_x&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is the switch name) to the value of the argument. If an argument is expected but none is provided, &lt;code&gt;$opt_x&lt;/code&gt; is set to an undefined value. If a switch does not take an argument, &lt;code&gt;$opt_x&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe182c59e721bf2edc44a9253eded06fe11c1a8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function returns true unless an invalid option was found.</source>
          <target state="translated">该 &lt;code&gt;getopts()&lt;/code&gt; ，除非无效选项发现函数返回true。</target>
        </trans-unit>
        <trans-unit id="a7db78679ac7caa25a3af4ac6eb9b08a0ab0fc92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gmtime&lt;/code&gt; operator will function properly if you have a working CRTL &lt;code&gt;gmtime()&lt;/code&gt; routine, or if the logical name SYS$TIMEZONE_DIFFERENTIAL is defined as the number of seconds which must be added to UTC to yield local time. (This logical name is defined automatically if you are running a version of VMS with built-in UTC support.) If neither of these cases is true, a warning message is printed, and &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf55542a974db500db0203f6bd0350de0ee8029" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by &lt;a href=&quot;#local-EXPR&quot;&gt;&lt;code&gt;local&lt;/code&gt;&lt;/a&gt;) and immediately calls in its place the named subroutine using the current value of &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt;. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt;, not even &lt;a href=&quot;#caller-EXPR&quot;&gt;&lt;code&gt;caller&lt;/code&gt;&lt;/a&gt; will be able to tell that this routine was called first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87b19f1c73c949cde9da8170870a148c4211b7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;goto &amp;amp;NAME&lt;/code&gt;, below. This is especially useful for implementing tail recursion via &lt;code&gt;goto __SUB__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5712e372b5c3349bd4c5753ceb08d65a1f34e0e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt;. The author of Perl has never felt the need to use this form of &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt; in other languages.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a01fb6d408173d3e22945b3c56ff55146388d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto&lt;/code&gt;-&amp;amp;NAME form is highly magical, and substitutes a call to the named subroutine for the currently running subroutine. This is used by &lt;code&gt;AUTOLOAD()&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;goto&lt;/code&gt;, not even &lt;code&gt;caller()&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="445db83ca6a37cdb271d1da44d8e4a2e039ee781" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto&lt;/code&gt;-EXPR form expects a label name, whose scope will be resolved dynamically. This allows for computed &lt;code&gt;goto&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3604bc760ddc7f229653ccec982fbb33374f75b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto&lt;/code&gt;-LABEL form finds the statement labeled with LABEL and resumes execution there. It may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;last&lt;/code&gt; or &lt;code&gt;die&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;goto&lt;/code&gt; (in Perl, that is--C is another matter).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fadcd77a199834658c813ed1ecacfc31717619" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grammar_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="688985f64d8825090cd98452194bcbd67a98423b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grammar_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;grammar_class&lt;/code&gt; 可定制，如在&lt;a href=&quot;#new&quot;&gt;新的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="777e123af8a17b58624e4e03631072776b99c240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grep&lt;/code&gt; in scalar context returns the count. If you want the list of matching items, just use it in list context instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361db5e35a8a030899f4185a6ca897ccf88b2984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;h&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; formats pack a string that many nybbles (4-bit groups, representable as hexadecimal digits, &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt;&lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; ) long.</source>
          <target state="translated">的 &lt;code&gt;h&lt;/code&gt; 和 &lt;code&gt;H&lt;/code&gt; 格式打包的字符串，许多半字节（4位组，可表示为十六进制数字， &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt; &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; ）长。</target>
        </trans-unit>
        <trans-unit id="282363bb17be47a4571b65bee183b55491c1858f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;h&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; formats pack a string that many nybbles (4-bit groups, representable as hexadecimal digits, &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt;&lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt;) long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b0ba82d51f8c56aed17fcdac89e94cd7a38305" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has()&lt;/code&gt; subroutine declares an attribute, and &lt;code&gt;Moose&lt;/code&gt; automatically creates accessors for these attributes. It also takes care of creating a &lt;code&gt;new()&lt;/code&gt; method for you. This constructor knows about the attributes you declared, so you can set them when creating a new &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;has()&lt;/code&gt; 子程序声明的属性，和 &lt;code&gt;Moose&lt;/code&gt; 自动创建这些属性访问器。它还需要为您创建一个 &lt;code&gt;new()&lt;/code&gt; 方法。该构造函数知道您声明的属性，因此可以在创建新 &lt;code&gt;File&lt;/code&gt; 时进行设置。</target>
        </trans-unit>
        <trans-unit id="0b9970d46e3cdb5c6bbb0a61789e35dad5828ae7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has()&lt;/code&gt; subroutine declares an attribute, and &lt;code&gt;Moose&lt;/code&gt; automatically creates accessors for these attributes. It also takes care of creating a &lt;code&gt;new()&lt;/code&gt; method for you. This constructor knows about the attributes you declared, so you can set them when creating a new &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a592c009139dada36763e63a154e69a7ae21aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hide_buffered()&lt;/code&gt; method must return a boolean. This is used to tell buffered subtests whether or not to send it events as they are being buffered. See &lt;a href=&quot;Test2::API#run_subtest%28...%29&quot;&gt;&quot;run_subtest(...)&quot; in Test2::API&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfb4b1270d7a6c1577ddc7dc43612517ef56c1fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;host&lt;/code&gt; argument implicitly specifies the family if the family argument is not given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a9683174ca55dfc5709630b38ddbf4013af69ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i!&lt;/code&gt; and &lt;code&gt;I!&lt;/code&gt; codes aren't different from &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt; ; they are tolerated for completeness' sake.</source>
          <target state="translated">在 &lt;code&gt;i!&lt;/code&gt; 和 &lt;code&gt;I!&lt;/code&gt; 码不从不同 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;I&lt;/code&gt; ; 为了完整起见，我们容忍他们。</target>
        </trans-unit>
        <trans-unit id="788c747d1d57898e8c459685e81e82083e2bc64a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i!&lt;/code&gt; and &lt;code&gt;I!&lt;/code&gt; codes aren't different from &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt;; they are tolerated for completeness' sake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441288d51b032bd9af407d3a9d7124153bae7480" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is incorporated in</source>
          <target state="translated">的 &lt;code&gt;id()&lt;/code&gt; 函数是在并入</target>
        </trans-unit>
        <trans-unit id="5b77bbf33fef07ab4b901464b3d1fbf57256a9cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is provided in addition to the existing &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; . Besides its short name it can be a little faster under some circumstances (and a bit slower under others). Benchmark if it matters. The working of &lt;code&gt;id()&lt;/code&gt; also allows the use of the class name as a</source>
          <target state="translated">的 &lt;code&gt;id()&lt;/code&gt; 函数是在除了现有的提供 &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; 。除了它的简称，在某些情况下它可能会快一些（在其他情况下则要慢一些）。如果重要，则进行基准测试。 &lt;code&gt;id()&lt;/code&gt; 的工作方式还允许将类名用作</target>
        </trans-unit>
        <trans-unit id="b2d4a03cd0e504b918c77f964222c03e6f8204c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is provided in addition to the existing &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt;. Besides its short name it can be a little faster under some circumstances (and a bit slower under others). Benchmark if it matters. The working of &lt;code&gt;id()&lt;/code&gt; also allows the use of the class name as a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1766324c2122418c9321a7a3323084287c423699" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; module is used to conditionally load another module. The construct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d508e8165fd2906f6e1a4da8eddef354ad1b2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; module is used to conditionally load or unload another module. The construct</source>
          <target state="translated">所述 &lt;code&gt;if&lt;/code&gt; 模块用于有条件地加载或卸载另一个模块。构造</target>
        </trans-unit>
        <trans-unit id="4b048e8a441fb17f85efa08c37a67df6bc5d9c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is straightforward. Because BLOCKs are always bounded by curly brackets, there is never any ambiguity about which &lt;code&gt;if&lt;/code&gt; an &lt;code&gt;else&lt;/code&gt; goes with. If you use &lt;code&gt;unless&lt;/code&gt; in place of &lt;code&gt;if&lt;/code&gt; , the sense of the test is reversed. Like &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;unless&lt;/code&gt; can be followed by &lt;code&gt;else&lt;/code&gt; . &lt;code&gt;unless&lt;/code&gt; can even be followed by one or more &lt;code&gt;elsif&lt;/code&gt; statements, though you may want to think twice before using that particular language construct, as everyone reading your code will have to think at least twice before they can understand what's going on.</source>
          <target state="translated">该 &lt;code&gt;if&lt;/code&gt; 语句是直接的。由于块始终以大括号为界，因此， &lt;code&gt;if&lt;/code&gt; 使用 &lt;code&gt;else&lt;/code&gt; ，则永远不会有任何歧义。如果使用 &lt;code&gt;unless&lt;/code&gt; 代替 &lt;code&gt;if&lt;/code&gt; ，则测试的意义相反。就像 &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;unless&lt;/code&gt; 可以跟 &lt;code&gt;else&lt;/code&gt; 。 &lt;code&gt;unless&lt;/code&gt; 甚至可以跟在一个或多个 &lt;code&gt;elsif&lt;/code&gt; 语句之后，但是您可能要在使用该特定语言构造之前三思而后行，因为每个阅读您代码的人都必须至少三思而后行才能理解正在发生的事情。</target>
        </trans-unit>
        <trans-unit id="a3f74430f10fb167c78fb2a5e2886ee696f50106" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is straightforward. Because BLOCKs are always bounded by curly brackets, there is never any ambiguity about which &lt;code&gt;if&lt;/code&gt; an &lt;code&gt;else&lt;/code&gt; goes with. If you use &lt;code&gt;unless&lt;/code&gt; in place of &lt;code&gt;if&lt;/code&gt;, the sense of the test is reversed. Like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;unless&lt;/code&gt; can be followed by &lt;code&gt;else&lt;/code&gt;. &lt;code&gt;unless&lt;/code&gt; can even be followed by one or more &lt;code&gt;elsif&lt;/code&gt; statements, though you may want to think twice before using that particular language construct, as everyone reading your code will have to think at least twice before they can understand what's going on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f3b671cb1eeb07ae7f1604035f9acb4eeee7c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ihave&lt;/code&gt; command informs the server that the client has an article whose id is &lt;code&gt;MSGID&lt;/code&gt; . If the server desires a copy of that article, and &lt;code&gt;MESSAGE&lt;/code&gt; has been given the it will be sent.</source>
          <target state="translated">该 &lt;code&gt;ihave&lt;/code&gt; 命令通知客户端有一篇文章编号为服务器 &lt;code&gt;MSGID&lt;/code&gt; 。如果服务器需要该文章的副本，并且已提供 &lt;code&gt;MESSAGE&lt;/code&gt; ，则将其发送。</target>
        </trans-unit>
        <trans-unit id="31b23815f5a49e656771e950c98aed03ec7f0fc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ihave&lt;/code&gt; command informs the server that the client has an article whose id is &lt;code&gt;MSGID&lt;/code&gt;. If the server desires a copy of that article and &lt;code&gt;MESSAGE&lt;/code&gt; has been given then it will be sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aeda9f25872f01fa1451e80b809c2f965a34d18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; method is used to create an instance of the filter. It is called indirectly by Perl when it encounters the &lt;code&gt;use MyFilter&lt;/code&gt; line in a source file (See &lt;a href=&quot;perlfunc#import&quot;&gt;&quot;import&quot; in perlfunc&lt;/a&gt; for more details on &lt;code&gt;import&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a41824798980582f7eebe5a9af3082e01f3a340" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intercept { ... }&lt;/code&gt; tool lets you temporarily intercept all events generated by the test system:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9e48c7280cc08e3dbfd771c25dd8dc760ce4df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;io&lt;/code&gt; options mean that any subsequent open() (or similar I/O operations) in main program scope will have the &lt;code&gt;:utf8&lt;/code&gt; PerlIO layer implicitly applied to them, in other words, UTF-8 is expected from any input stream, and UTF-8 is produced to any output stream. This is just the default set via &lt;a href=&quot;perlvar#%24%7B%5EOPEN%7D&quot;&gt;&lt;code&gt;${^OPEN}&lt;/code&gt;&lt;/a&gt;, with explicit layers in open() and with binmode() one can manipulate streams as usual. This has no effect on code run in modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31aa9addcda21b8978ff9bf041daba569f826e41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;io&lt;/code&gt; options mean that any subsequent open() (or similar I/O operations) in the current file scope will have the &lt;code&gt;:utf8&lt;/code&gt; PerlIO layer implicitly applied to them, in other words, UTF-8 is expected from any input stream, and UTF-8 is produced to any output stream. This is just the default, with explicit layers in open() and with binmode() one can manipulate streams as usual.</source>
          <target state="translated">该 &lt;code&gt;io&lt;/code&gt; 选项意味着，在当前的文件范围内的任何后续的open（）（或类似的I / O操作）将有 &lt;code&gt;:utf8&lt;/code&gt; PerlIO的层隐式施加到它们，换句话说，UTF-8从任何输入流预期的，和UTF-8被生成到任何输出流。这只是默认设置，在open（）中有显式层，在binmode（）中可以像往常一样操纵流。</target>
        </trans-unit>
        <trans-unit id="ea8cc24a093a2a51529b8db29000183dfdfc585d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isa&lt;/code&gt; method returns</source>
          <target state="translated">该 &lt;code&gt;isa&lt;/code&gt; 方法返回</target>
        </trans-unit>
        <trans-unit id="d80df4437426b10544ca2a3550913f7483c70900" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keep_alive&lt;/code&gt; parameter enables a persistent connection, but only to a single destination scheme, host and port. Also, if any connection-relevant attributes are modified, or if the process ID or thread ID change, the persistent connection will be dropped. If you want persistent connections across multiple destinations, use multiple HTTP::Tiny objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e537c44915ef2c8c7d2ba733eb7ee50f9fc357" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keys()&lt;/code&gt; function also resets the iterator, which means that you may see strange results if you use this between uses of other hash operators such as &lt;code&gt;each()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f328cf1649c302313e1693d9d3ed492ede670c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kill&lt;/code&gt; function can be used to test this functionality from within a program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b31ef1c90508af7c0b307ce12a58574a2fffa8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kill&lt;/code&gt; function in the parent's &lt;code&gt;if&lt;/code&gt; block is there to send a signal to our child process, currently running in the &lt;code&gt;else&lt;/code&gt; block, as soon as the remote server has closed its end of the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b75cea7c9c256a2c7f367ec1f2a28305318646" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;klen&lt;/code&gt; parameter is the length of the key being passed in (Note that you cannot pass 0 in as a value of &lt;code&gt;klen&lt;/code&gt; to tell Perl to measure the length of the key). The &lt;code&gt;val&lt;/code&gt; argument contains the SV pointer to the scalar being stored, and &lt;code&gt;hash&lt;/code&gt; is the precomputed hash value (zero if you want &lt;code&gt;hv_store&lt;/code&gt; to calculate it for you). The &lt;code&gt;lval&lt;/code&gt; parameter indicates whether this fetch is actually a part of a store operation, in which case a new undefined value will be added to the HV with the supplied key and &lt;code&gt;hv_fetch&lt;/code&gt; will return as if the value had already existed.</source>
          <target state="translated">该 &lt;code&gt;klen&lt;/code&gt; 参数键值为传入的长度（请注意，你不能为一个值传递0 &lt;code&gt;klen&lt;/code&gt; 告诉Perl来衡量密钥的长度）。该 &lt;code&gt;val&lt;/code&gt; 参数包含存储的SV指向标，而 &lt;code&gt;hash&lt;/code&gt; 是预先计算哈希值（零，如果你想 &lt;code&gt;hv_store&lt;/code&gt; 来算一下）。该 &lt;code&gt;lval&lt;/code&gt; 参数表示是否获取实际上是一个存储操作，在这种情况下，一个新的未定义的值将被添加到HV与所提供的密钥和一部分 &lt;code&gt;hv_fetch&lt;/code&gt; 将返回仿佛值已经存在。</target>
        </trans-unit>
        <trans-unit id="ce7404a130e41b36d0d6586ea9856d3d751bce9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;last&lt;/code&gt; command immediately exits the loop in question. The &lt;code&gt;continue&lt;/code&gt; block, if any, is not executed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c1db6e5ea234d6a6e740b669d07b2f2f87de01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;length(NAME)&lt;/code&gt; Keyword</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b3be6dbaf0292e629ff79d5077e6e86e950020" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line numbers&lt;/code&gt; are a comma separated list of line numbers (some preceded by code letters) where that object is used in some way. Simple uses aren't preceded by a code letter. Introductions (such as where a lexical is first defined with &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;) are indicated with the letter &quot;i&quot;. Subroutine and method calls are indicated by the character &quot;&amp;amp;&quot;. Subroutine definitions are indicated by &quot;s&quot; and format definitions by &quot;f&quot;.</source>
          <target state="translated">的 &lt;code&gt;line numbers&lt;/code&gt; 是行号（一些前面加上字母代码），其中该对象以某种方式使用的逗号分隔的列表。简单使用之前没有代码字母。简介（例如，首先使用 &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 定义词汇的地方）以字母&amp;ldquo; i&amp;rdquo;表示。子例程和方法调用由字符&amp;ldquo;＆&amp;rdquo;指示。子例程定义由&amp;ldquo; s&amp;rdquo;指示，格式定义由&amp;ldquo; f&amp;rdquo;指示。</target>
        </trans-unit>
        <trans-unit id="236b6ae4af5c95ab170ad24f4ae0aa38234165ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line numbers&lt;/code&gt; are a comma separated list of line numbers (some preceded by code letters) where that object is used in some way. Simple uses aren't preceded by a code letter. Introductions (such as where a lexical is first defined with &lt;code&gt;my&lt;/code&gt;) are indicated with the letter &quot;i&quot;. Subroutine and method calls are indicated by the character &quot;&amp;amp;&quot;. Subroutine definitions are indicated by &quot;s&quot; and format definitions by &quot;f&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1df1ad78d22b500a60841a63c43cbb5af0dd2c94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock()&lt;/code&gt; function takes a shared variable and puts a lock on it. No other thread may lock the variable until the variable is unlocked by the thread holding the lock. Unlocking happens automatically when the locking thread exits the block that contains the call to the &lt;code&gt;lock()&lt;/code&gt; function. Using &lt;code&gt;lock()&lt;/code&gt; is straightforward: This example has several threads doing some calculations in parallel, and occasionally updating a running total:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed26c2274a611c42add606638c2955102446922f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_nstore&lt;/code&gt; routine are equivalent to &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;nstore&lt;/code&gt; , except that they get an exclusive lock on the file before writing. Likewise, &lt;code&gt;lock_retrieve&lt;/code&gt; does the same as &lt;code&gt;retrieve&lt;/code&gt; , but also gets a shared lock on the file before reading.</source>
          <target state="translated">该 &lt;code&gt;lock_store&lt;/code&gt; 和 &lt;code&gt;lock_nstore&lt;/code&gt; 常规相当于 &lt;code&gt;store&lt;/code&gt; 和 &lt;code&gt;nstore&lt;/code&gt; ，但他们得到的写作前的文件的独占锁定。同样， &lt;code&gt;lock_retrieve&lt;/code&gt; 的功能与 &lt;code&gt;retrieve&lt;/code&gt; 的功能相同，但在读取文件之前还获得了文件的共享锁。</target>
        </trans-unit>
        <trans-unit id="c09918116ac6368cc484da6987f7bb75bbaec828" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_nstore&lt;/code&gt; routine are equivalent to &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;nstore&lt;/code&gt;, except that they get an exclusive lock on the file before writing. Likewise, &lt;code&gt;lock_retrieve&lt;/code&gt; does the same as &lt;code&gt;retrieve&lt;/code&gt;, but also gets a shared lock on the file before reading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931b71dd87fea82969167ed5b3226571750cd592" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mail&lt;/code&gt; method can some additional ESMTP OPTIONS which is passed in hash like fashion, using key and value pairs. Possible options are:</source>
          <target state="translated">该 &lt;code&gt;mail&lt;/code&gt; 方法可一些附加ESMTP OPTIONS这在散列传递类似的方式，使用键和值对。可能的选项是：</target>
        </trans-unit>
        <trans-unit id="1672385883542a7bfdb246cc1c07640a71a68feb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make&lt;/code&gt; and &lt;code&gt;emake&lt;/code&gt; accept both real and complex arguments. When they cannot recognize the arguments they will die with error messages like the following</source>
          <target state="translated">在 &lt;code&gt;make&lt;/code&gt; 和 &lt;code&gt;emake&lt;/code&gt; 接受真实和复杂的参数。当他们无法识别参数时，它们将死于错误消息，如下所示</target>
        </trans-unit>
        <trans-unit id="c85fa07be63e0e0f2104a7ea90d6fd3b867aea55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make_path&lt;/code&gt; function creates the given directories if they don't exist before, much like the Unix command &lt;code&gt;mkdir -p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36df2e300d21e511804bebffd14eb9e7ae60ac30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make_path&lt;/code&gt; function creates the given directories if they don't exists before, much like the Unix command &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt; -p&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;make_path&lt;/code&gt; 如果他们不存在之前，很像Unix命令函数创建指定目录 &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt; -p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="072d415ade3aa9a1737c770e2e53b08afe60d304" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match&lt;/code&gt; , &lt;code&gt;gmatch&lt;/code&gt; , &lt;code&gt;subst&lt;/code&gt; , &lt;code&gt;gsubst&lt;/code&gt; methods work like &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt;, respectively, but they are not aware of any pattern, but only a literal substring.</source>
          <target state="translated">的 &lt;code&gt;match&lt;/code&gt; ， &lt;code&gt;gmatch&lt;/code&gt; ， &lt;code&gt;subst&lt;/code&gt; ， &lt;code&gt;gsubst&lt;/code&gt; 方法工作像 &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; ，分别，但它们是不知道任何的图案，但只有一个文字串。</target>
        </trans-unit>
        <trans-unit id="3e1a1e48900b4f1b87b0c10e8e5f854b940363da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match&lt;/code&gt;, &lt;code&gt;gmatch&lt;/code&gt;, &lt;code&gt;subst&lt;/code&gt;, &lt;code&gt;gsubst&lt;/code&gt; methods work like &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;m//g&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt;, &lt;code&gt;s///g&lt;/code&gt;, respectively, but they are not aware of any pattern, but only a literal substring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece173d4e6c78d6e5935815075ac81cc7c62a227" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;memory&lt;/code&gt; value is not an absolute or exact limit on the memory used. &lt;code&gt;Tie::File&lt;/code&gt; objects contains some structures besides the read cache and the deferred write buffer, whose sizes are not charged against &lt;code&gt;memory&lt;/code&gt; .</source>
          <target state="translated">所述 &lt;code&gt;memory&lt;/code&gt; 值是不使用的存储器中的绝对或完全限制。 &lt;code&gt;Tie::File&lt;/code&gt; 对象除了读取缓存和延迟的写入缓冲区之外，还包含其他一些结构，这些结构的大小不计入 &lt;code&gt;memory&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e86eeea566744434422bb67f1ca33c0f448174c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;memory&lt;/code&gt; value is not an absolute or exact limit on the memory used. &lt;code&gt;Tie::File&lt;/code&gt; objects contains some structures besides the read cache and the deferred write buffer, whose sizes are not charged against &lt;code&gt;memory&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d121e9a361d9d72576c01fa16affeece8189c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mg_virtual&lt;/code&gt; field in the &lt;code&gt;MAGIC&lt;/code&gt; structure is a pointer to an &lt;code&gt;MGVTBL&lt;/code&gt; , which is a structure of function pointers and stands for &quot;Magic Virtual Table&quot; to handle the various operations that might be applied to that variable.</source>
          <target state="translated">&lt;code&gt;MAGIC&lt;/code&gt; 结构中的 &lt;code&gt;mg_virtual&lt;/code&gt; 字段是指向 &lt;code&gt;MGVTBL&lt;/code&gt; 的指针，MGVTBL是函数指针的结构，代表&amp;ldquo; Magic Virtual Table&amp;rdquo;来处理可能应用于该变量的各种操作。</target>
        </trans-unit>
        <trans-unit id="7a8acc1e771fdb8b24c87ae131045c8c79a6a526" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mg_virtual&lt;/code&gt; field in the &lt;code&gt;MAGIC&lt;/code&gt; structure is a pointer to an &lt;code&gt;MGVTBL&lt;/code&gt;, which is a structure of function pointers and stands for &quot;Magic Virtual Table&quot; to handle the various operations that might be applied to that variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2676c3bd8442c2414026f369d263715f307f12fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mkpath()&lt;/code&gt; function provide the legacy interface of &lt;code&gt;make_path()&lt;/code&gt; with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to &lt;code&gt;make_path()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5023c90eb5f90ef422233e2dd5d44f7824eab24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; related one will be matched against</source>
          <target state="translated">与之相关的 &lt;code&gt;module&lt;/code&gt; 将与之匹配</target>
        </trans-unit>
        <trans-unit id="47efd6577f009e8c4308e174f5b14a11ddfaec14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;move&lt;/code&gt; function also takes two parameters: the current name and the intended name of the file to be moved. If the destination already exists and is a directory, and the source is not a directory, then the source file will be renamed into the directory specified by the destination.</source>
          <target state="translated">该 &lt;code&gt;move&lt;/code&gt; 功能也有两个参数：要移动的当前名称和文件的预期的名称。如果目标已经存在并且是目录，而源不是目录，那么源文件将重命名为目标指定的目录。</target>
        </trans-unit>
        <trans-unit id="f9ad05dfff8b94ab9a9d935cf92a180ec9ff2c2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;my&lt;/code&gt; is actually not required; you could just use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38fd69505c43bd3a6104acf78cba741dff69018d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;my&lt;/code&gt; is simply a modifier on something you might assign to. So when you do assign to variables in its argument list, &lt;code&gt;my&lt;/code&gt; doesn't change whether those variables are viewed as a scalar or an array. So</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19231a9a0cfdbf1775816cb2ae3551e57856cb0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;my&lt;/code&gt; operator declares the listed variables to be lexically confined to the enclosing block, conditional (&lt;code&gt;if&lt;/code&gt;/&lt;code&gt;unless&lt;/code&gt;/&lt;code&gt;elsif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;), loop (&lt;code&gt;for&lt;/code&gt;/&lt;code&gt;foreach&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt;/&lt;code&gt;until&lt;/code&gt;/&lt;code&gt;continue&lt;/code&gt;), subroutine, &lt;code&gt;eval&lt;/code&gt;, or &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;/&lt;code&gt;use&lt;/code&gt;'d file. If more than one value is listed, the list must be placed in parentheses. All listed elements must be legal lvalues. Only alphanumeric identifiers may be lexically scoped--magical built-ins like &lt;code&gt;$/&lt;/code&gt; must currently be &lt;code&gt;local&lt;/code&gt;ized with &lt;code&gt;local&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82300ffe8ea8c4a83935f63ac88aba05d079a68e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;namlen&lt;/code&gt; arguments are used to associate a string with the magic, typically the name of a variable. &lt;code&gt;namlen&lt;/code&gt; is stored in the &lt;code&gt;mg_len&lt;/code&gt; field and if &lt;code&gt;name&lt;/code&gt; is non-null then either a &lt;code&gt;savepvn&lt;/code&gt; copy of &lt;code&gt;name&lt;/code&gt; or &lt;code&gt;name&lt;/code&gt; itself is stored in the &lt;code&gt;mg_ptr&lt;/code&gt; field, depending on whether &lt;code&gt;namlen&lt;/code&gt; is greater than zero or equal to zero respectively. As a special case, if &lt;code&gt;(name &amp;amp;&amp;amp; namlen == HEf_SVKEY)&lt;/code&gt; then &lt;code&gt;name&lt;/code&gt; is assumed to contain an &lt;code&gt;SV*&lt;/code&gt; and is stored as-is with its REFCNT incremented.</source>
          <target state="translated">该 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;namlen&lt;/code&gt; 参数用于字符串与魔法，一个变量的典型的名字联系在一起。 &lt;code&gt;namlen&lt;/code&gt; 被存储在 &lt;code&gt;mg_len&lt;/code&gt; 字段，如果 &lt;code&gt;name&lt;/code&gt; 是非空然后是一个 &lt;code&gt;savepvn&lt;/code&gt; 的副本 &lt;code&gt;name&lt;/code&gt; 或 &lt;code&gt;name&lt;/code&gt; 本身被存储在 &lt;code&gt;mg_ptr&lt;/code&gt; 字段，这取决于是否 &lt;code&gt;namlen&lt;/code&gt; 是大于零或分别等于零。作为一种特殊情况，如果 &lt;code&gt;(name &amp;amp;&amp;amp; namlen == HEf_SVKEY)&lt;/code&gt; 则假定 &lt;code&gt;name&lt;/code&gt; 包含 &lt;code&gt;SV*&lt;/code&gt; ，并按原样存储，其REFCNT递增。</target>
        </trans-unit>
        <trans-unit id="30007f38d6317a12ba00ec6e0a7e1a8a5a903fc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; will also understand a single (string) argument of the forms</source>
          <target state="translated">在 &lt;code&gt;new&lt;/code&gt; ， &lt;code&gt;make&lt;/code&gt; ， &lt;code&gt;emake&lt;/code&gt; ， &lt;code&gt;cplx&lt;/code&gt; ，和 &lt;code&gt;cplxe&lt;/code&gt; 也会理解的形式单一（字符串）参数</target>
        </trans-unit>
        <trans-unit id="ed69370147fad222f299ba19e375b2bf7b98be5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; will also understand the case of no arguments: this means plain zero or (0, 0).</source>
          <target state="translated">在 &lt;code&gt;new&lt;/code&gt; ， &lt;code&gt;make&lt;/code&gt; ， &lt;code&gt;emake&lt;/code&gt; ， &lt;code&gt;cplx&lt;/code&gt; ，和 &lt;code&gt;cplxe&lt;/code&gt; 也会理解的不带参数的情况：这意味着普通零或（0，0）。</target>
        </trans-unit>
        <trans-unit id="6c65b03e7c38b210fdc728780536955dda01e185" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; method returns a collator object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99af811bc283e732950a12fee28684ae132d20bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; method returns a collator object. If new() is called with no parameters, the collator should do the default collation.</source>
          <target state="translated">该 &lt;code&gt;new&lt;/code&gt; 方法返回一个Collat​​or对象。如果没有参数调用new（），则整理器应执行默认整理。</target>
        </trans-unit>
        <trans-unit id="ae0f663693f54f75cfb0a197fa36ce7749539dce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;emake&lt;/code&gt;, &lt;code&gt;cplx&lt;/code&gt;, and &lt;code&gt;cplxe&lt;/code&gt; will also understand a single (string) argument of the forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5852a1533162d9c64ba81a3a508d931f75c8fc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;emake&lt;/code&gt;, &lt;code&gt;cplx&lt;/code&gt;, and &lt;code&gt;cplxe&lt;/code&gt; will also understand the case of no arguments: this means plain zero or (0, 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66998427833c37a6112ac1501f01bdbb2d3aed3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new_root&lt;/code&gt; method is called when &lt;code&gt;Test2::API::Stack&lt;/code&gt; Initializes the root hub for the first time. Most formatters will simply have this call &lt;code&gt;$class-&amp;gt;new&lt;/code&gt;, which is the default behavior. Some formatters however may want to take extra action during construction of the root formatter, this is where they can do that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9d718f2247f950a12fdfc4b79710e6bdd5032a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new_root&lt;/code&gt; method is used when constructing a root formatter. The default is to just delegate to the regular &lt;code&gt;new()&lt;/code&gt; method, most formatters can ignore this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb14c874127fdd24641fa3165f1f47f1c0c5962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; command starts the next iteration of the loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b10b638a2af4c10544e1d329f2b109151bd6354" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, and &lt;code&gt;continue&lt;/code&gt; keywords work differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe7378b188460d4f95907a0bf8fffd8170aa799" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nntpstat&lt;/code&gt; command is similar to the &lt;code&gt;article&lt;/code&gt; command except that no text is returned. When selecting by message number within a group, the &lt;code&gt;nntpstat&lt;/code&gt; command serves to set the &quot;current article pointer&quot; without sending text.</source>
          <target state="translated">该 &lt;code&gt;nntpstat&lt;/code&gt; 命令是类似的 &lt;code&gt;article&lt;/code&gt; ，除了没有文本返回指令。当按组中的消息号进行选择时， &lt;code&gt;nntpstat&lt;/code&gt; 命令用于设置&amp;ldquo;当前文章指针&amp;rdquo;而不发送文本。</target>
        </trans-unit>
        <trans-unit id="fef6e564421c89438d32761ce9e7776b6464e92d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no if&lt;/code&gt; construct assumes that a module or pragma has correctly implemented an &lt;code&gt;unimport()&lt;/code&gt; method -- but most modules and pragmata have not. That explains why the &lt;code&gt;no if&lt;/code&gt; construct is of limited applicability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4f0c6076233a4be0a02d3164def9d1f31e4b673" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no if&lt;/code&gt; construct is mainly used to deactivate categories of warnings when those categories would produce superfluous output under specified versions of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="696981a277bda71ab876e23444c84e4c429ec79c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no lib&lt;/code&gt; statement deletes all instances of each named directory from @INC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc82aa3e704adf455ebd4a8a84e684b82c4c216" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no sort&lt;/code&gt; pragma doesn't</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44265817f41c8d93c79e5cd86bbcac999ebebf51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_proxy&lt;/code&gt; environment variable is supported in the format of a comma-separated list of domain extensions proxy should not be used for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9f846f976939c6373f157aacddb5340df46521" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;notest&lt;/code&gt; pragma skips the test part in the build process.</source>
          <target state="translated">最重要的 &lt;code&gt;notest&lt;/code&gt; 在构建过程中跳过测试部分。</target>
        </trans-unit>
        <trans-unit id="402cbf532fb5078e8455cec160e9e8dbd08504b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nvsize&lt;/code&gt; element is only present for file format v2.2 and higher.</source>
          <target state="translated">所述 &lt;code&gt;nvsize&lt;/code&gt; 元件只存在于文件格式V2.2和更高。</target>
        </trans-unit>
        <trans-unit id="c6ccaa6545aa4fe6352eb7229eabe18e5414aa4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o conf&lt;/code&gt; command has various bells and whistles:</source>
          <target state="translated">该 &lt;code&gt;o conf&lt;/code&gt; 命令具有各种花里胡哨：</target>
        </trans-unit>
        <trans-unit id="20b61e97734fd2f3d96ceb929809c05aaac0cfef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o?&lt;/code&gt; matches at the beginning of &quot;&lt;code&gt;foo&lt;/code&gt;&quot;, and since the position in the string is not moved by the match, &lt;code&gt;o?&lt;/code&gt; would match again and again because of the &lt;code&gt;&quot;*&quot;&lt;/code&gt; quantifier. Another common way to create a similar cycle is with the looping modifier &lt;code&gt;/g&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d6fb5846e3f0194a9a7d71677ca6c483145c33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o?&lt;/code&gt; matches at the beginning of &lt;code&gt;'foo'&lt;/code&gt; , and since the position in the string is not moved by the match, &lt;code&gt;o?&lt;/code&gt; would match again and again because of the &lt;code&gt;*&lt;/code&gt; quantifier. Another common way to create a similar cycle is with the looping modifier &lt;code&gt;//g&lt;/code&gt; :</source>
          <target state="translated">该 &lt;code&gt;o?&lt;/code&gt; 在 &lt;code&gt;'foo'&lt;/code&gt; 的开头匹配，并且由于字符串不被匹配移动，所以 &lt;code&gt;o?&lt;/code&gt; 会因 &lt;code&gt;*&lt;/code&gt; 量词而一次又一次地匹配。创建类似循环的另一种常见方法是使用循环修饰符 &lt;code&gt;//g&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8add6c5a9ee20cf8238a46e09a0cd46fe0b061c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; argument is stored in the &lt;code&gt;mg_obj&lt;/code&gt; field of the &lt;code&gt;MAGIC&lt;/code&gt; structure. If it is not the same as the &lt;code&gt;sv&lt;/code&gt; argument, the reference count of the &lt;code&gt;obj&lt;/code&gt; object is incremented. If it is the same, or if the &lt;code&gt;how&lt;/code&gt; argument is &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt; , or if it is a NULL pointer, then &lt;code&gt;obj&lt;/code&gt; is merely stored, without the reference count being incremented.</source>
          <target state="translated">所述 &lt;code&gt;obj&lt;/code&gt; 参数被存储在 &lt;code&gt;mg_obj&lt;/code&gt; 所述的场 &lt;code&gt;MAGIC&lt;/code&gt; 结构。如果与 &lt;code&gt;sv&lt;/code&gt; 参数不同，则 &lt;code&gt;obj&lt;/code&gt; 对象的引用计数增加。如果相同，或者 &lt;code&gt;how&lt;/code&gt; 参数为 &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt; ，或者为NULL指针，则仅存储 &lt;code&gt;obj&lt;/code&gt; ，而不会增加引用计数。</target>
        </trans-unit>
        <trans-unit id="dca84bbcee637e6ee5a3f3b53c079982ba47b456" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; argument is stored in the &lt;code&gt;mg_obj&lt;/code&gt; field of the &lt;code&gt;MAGIC&lt;/code&gt; structure. If it is not the same as the &lt;code&gt;sv&lt;/code&gt; argument, the reference count of the &lt;code&gt;obj&lt;/code&gt; object is incremented. If it is the same, or if the &lt;code&gt;how&lt;/code&gt; argument is &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt;, &lt;code&gt;PERL_MAGIC_regdatum&lt;/code&gt;, &lt;code&gt;PERL_MAGIC_regdata&lt;/code&gt;, or if it is a NULL pointer, then &lt;code&gt;obj&lt;/code&gt; is merely stored, without the reference count being incremented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80e9ad5ac5b4640a379da6ded2e4e7da8ef85d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op-entry&lt;/code&gt; , &lt;code&gt;loading-file&lt;/code&gt; , and &lt;code&gt;loaded-file&lt;/code&gt; probes were added.</source>
          <target state="translated">添加了 &lt;code&gt;op-entry&lt;/code&gt; ， &lt;code&gt;loading-file&lt;/code&gt; 和 &lt;code&gt;loaded-file&lt;/code&gt; 探针。</target>
        </trans-unit>
        <trans-unit id="f888b5670cd3a579164b6986631d6a361f670ffe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op-entry&lt;/code&gt;, &lt;code&gt;loading-file&lt;/code&gt;, and &lt;code&gt;loaded-file&lt;/code&gt; probes were added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6cb40ac71f3af050d6baa8551cc82228d3a4f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;open(FOO, &quot;|-&quot;)&lt;/code&gt; and &lt;code&gt;open(BAR, &quot;-|&quot;)&lt;/code&gt; constructs are not yet implemented. This limitation can be easily worked around in new code by creating a pipe explicitly. The following example shows how to write to a forked child:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1d994756f4894d537087cc5686928a7d382dd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;open&lt;/code&gt; pragma serves as one of the interfaces to declare default &quot;layers&quot; (previously known as &quot;disciplines&quot;) for all I/O. Any open(), readpipe() (aka qx//) and similar operators found within the lexical scope of this pragma will use the declared defaults via the &lt;a href=&quot;perlvar#%24%7B%5EOPEN%7D&quot;&gt;&lt;code&gt;${^OPEN}&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb381293ba1d62c6bb1f8b641a8f8c1b0afc8bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ord&lt;/code&gt; and &lt;code&gt;chr&lt;/code&gt; functions work transparently on all codepoints, not just on ASCII alone &amp;mdash; nor in fact, not even just on Unicode alone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df48f02864fb5733b7bb66ec5f70b228889d68c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;os_unsupported()&lt;/code&gt; function provides a way to correctly exit your &lt;code&gt;Makefile.PL&lt;/code&gt; before calling &lt;code&gt;WriteMakefile&lt;/code&gt;. It is essentially a &lt;code&gt;die&lt;/code&gt; with the message &quot;OS unsupported&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f6e73c286e870319f1bf5046f6a37ff92d8c6ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overloading&lt;/code&gt; pragma can be used to enable or disable overloaded operations within a lexical scope - see &lt;a href=&quot;overloading&quot;&gt;overloading&lt;/a&gt;.</source>
          <target state="translated">所述 &lt;code&gt;overloading&lt;/code&gt; 编译指示可用于使能或词法范围内禁用重载的操作-参见&lt;a href=&quot;overloading&quot;&gt;超载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="20efdbd26d83eb3c5a0a6712c2d992c599e01133" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d5bf30a5d50f38a10cfc2d7578244917da917c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="translated">该 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt; 格式应小心使用。由于Perl无法检查传递给 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 的值是否对应于有效的内存位置，因此传递未知有效的指针值可能会造成灾难性的后果。</target>
        </trans-unit>
        <trans-unit id="edad35170db1a049ca495222b3c0b5b8c415db1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="translated">该 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt; 格式应小心使用。由于Perl无法检查传递给 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 的值是否对应于有效的内存位置，因此传递未知有效的指针值可能会造成灾难性的后果。</target>
        </trans-unit>
        <trans-unit id="bc14cc8e3b01ab283787dc8c289608a88dca9ea7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;; similarly with &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;, where a null pointer unpacks into &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a342dbe90eb2666a6875f71f1fa1cb3e6e7241a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;; similarly with unpack(), where a null pointer unpacks into &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;p&lt;/code&gt; 格式包的指针，空终止字符串。您有责任确保该字符串不是临时值，因为在使用打包结果之前，该字符串可能会被释放。的 &lt;code&gt;P&lt;/code&gt; 格式包的指针由长度表示的大小的结构。如果 &lt;code&gt;p&lt;/code&gt; 或 &lt;code&gt;P&lt;/code&gt; 的对应值是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则创建一个空指针；与unpack（）类似，其中null指针将解压缩为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2e0e3d979b5c34967b7ced67a74a5510cb236cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;; similarly with unpack(), where a null pointer unpacks into &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;p&lt;/code&gt; 格式包的指针，空终止字符串。您有责任确保该字符串不是临时值，因为在使用打包结果之前，该字符串可能会被释放。的 &lt;code&gt;P&lt;/code&gt; 格式包的指针由长度表示的大小的结构。如果 &lt;code&gt;p&lt;/code&gt; 或 &lt;code&gt;P&lt;/code&gt; 的对应值是 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则创建一个空指针；与unpack（）类似，其中null指针将解压缩为 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cd57772719120a4cc44e7170b8984f064c5142a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;paren&lt;/code&gt; parameter will be &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; for &lt;code&gt;$2&lt;/code&gt; and so forth, and have these symbolic values for the special variables:</source>
          <target state="translated">在 &lt;code&gt;paren&lt;/code&gt; 参数将是 &lt;code&gt;1&lt;/code&gt; 为 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; 为 &lt;code&gt;$2&lt;/code&gt; 等等，并有特殊的变量，这些符号值：</target>
        </trans-unit>
        <trans-unit id="02d079f599dacaf5683c95e116afdd6471bd3c7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;paren&lt;/code&gt; parameter will be &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; for &lt;code&gt;$2&lt;/code&gt; and so forth, and have these symbolic values for the special variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d81fd54d838a03f6a557d9a972a797c3d53d12e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parse()&lt;/code&gt; method takes in anything that might be a version and returns a corresponding version object, doing any necessary conversion along the way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc153b0fac70aafae4ce7fa649dc1cbd578affc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pass*&lt;/code&gt; and &lt;code&gt;fail*&lt;/code&gt; are optimal if they meet your situation, using one of them will always be the most optimal. That said they are optimal by eliminating many features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49927bc872809a6862bb2b73a995c90fcc3d0b9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; parameter is the scalar that was used as the pattern. Previous versions of Perl would pass two &lt;code&gt;char*&lt;/code&gt; indicating the start and end of the stringified pattern; the following snippet can be used to get the old parameters:</source>
          <target state="translated">的 &lt;code&gt;pattern&lt;/code&gt; 参数是用作图案的标量。以前的Perl版本会传递两个 &lt;code&gt;char*&lt;/code&gt; 指示字符串化模式的开始和结束；以下代码段可用于获取旧参数：</target>
        </trans-unit>
        <trans-unit id="db17bf3bf687b24a2fdb5945dac7eff0732c46a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perl&lt;/code&gt; related one will be matched against &lt;code&gt;$^X&lt;/code&gt; (but with the absolute path).</source>
          <target state="translated">与 &lt;code&gt;perl&lt;/code&gt; 相关的将与 &lt;code&gt;$^X&lt;/code&gt; 匹配（但具有绝对路径）。</target>
        </trans-unit>
        <trans-unit id="5f5ee6756d1fcb64032b91cf7b890baca1e81e1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perl_alloc&lt;/code&gt; and &lt;code&gt;perl_clone&lt;/code&gt; API functions will automatically set the TLS slot to the interpreter they created, so that there is no need to do anything special if the interpreter is always accessed in the same thread that created it, and that thread did not create or call any other interpreters afterwards. If that is not the case, you have to set the TLS slot of the thread before calling any functions in the Perl API on that particular interpreter. This is done by calling the &lt;code&gt;PERL_SET_CONTEXT&lt;/code&gt; macro in that thread as the first thing you do:</source>
          <target state="translated">该 &lt;code&gt;perl_alloc&lt;/code&gt; 和 &lt;code&gt;perl_clone&lt;/code&gt; API函数将自动设置TLS插槽，他们创造了解释，所以没有必要做什么特别的事情，如果解释在创建它的同一线程总是访问，而这些线程没有创造或致电之后再有其他口译员。如果不是这种情况，则必须在该特定解释程序上调用Perl API中的任何函数之前，设置线程的TLS插槽。这是通过 &lt;code&gt;PERL_SET_CONTEXT&lt;/code&gt; 在该线程中调用PERL_SET_CONTEXT宏来完成的：</target>
        </trans-unit>
        <trans-unit id="97a02a3c258cf1103ffa6170e07625f674c4d40e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perldoc&lt;/code&gt; command line tool is part of the standard Perl distribution. To read the perlfaq:</source>
          <target state="translated">所述 &lt;code&gt;perldoc&lt;/code&gt; 命令行工具是标准的Perl分布的一部分。要阅读perlfaq：</target>
        </trans-unit>
        <trans-unit id="50ad124de63dc48f75c0f2545fa281fab8aa3db8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phase-change&lt;/code&gt; probe was added.</source>
          <target state="translated">该 &lt;code&gt;phase-change&lt;/code&gt; 添加探头。</target>
        </trans-unit>
        <trans-unit id="04bb003d93ac0037aab6a2f453c58a6ac0c41912" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;plugin_list&lt;/code&gt; configuration parameter holds a list of strings of the form</source>
          <target state="translated">该 &lt;code&gt;plugin_list&lt;/code&gt; 配置参数保存形式的字符串列表</target>
        </trans-unit>
        <trans-unit id="a0b743645c5c1c48eeb64bb89437f58e73a4be52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;port&lt;/code&gt; argument is only valid for a udp, tcp or stream ping, and will not do what you think it does. ping returns true when we get a &quot;Connection refused&quot;! The default is the echo port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63eacc1cc33a9d0218e84fb4e04a60cb849a989" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pp_tie&lt;/code&gt; does a &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; , then starts a second runops loop to execute the body of &lt;code&gt;TIEARRAY&lt;/code&gt; . When it executes the entertry op on line 3, &lt;code&gt;CATCH_GET&lt;/code&gt; is true, so &lt;code&gt;pp_entertry&lt;/code&gt; calls &lt;code&gt;docatch&lt;/code&gt; which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and starts a third runops loop, which then executes the die op. At this point the C call stack looks like this:</source>
          <target state="translated">所述 &lt;code&gt;pp_tie&lt;/code&gt; 做了 &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; ，那么开始第二runops循环执行的主体 &lt;code&gt;TIEARRAY&lt;/code&gt; 。当它在第3行执行Entertry op时， &lt;code&gt;CATCH_GET&lt;/code&gt; 为true，因此 &lt;code&gt;pp_entertry&lt;/code&gt; 调用 &lt;code&gt;docatch&lt;/code&gt; ，它执行 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 并启动第三个runops循环，然后执行die op。此时，C调用堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="158d812c1686b0935b414c31c5100461991aaa3b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pp_tie&lt;/code&gt; does a &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt;, then starts a second runops loop to execute the body of &lt;code&gt;TIEARRAY&lt;/code&gt;. When it executes the entertry op on line 3, &lt;code&gt;CATCH_GET&lt;/code&gt; is true, so &lt;code&gt;pp_entertry&lt;/code&gt; calls &lt;code&gt;docatch&lt;/code&gt; which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and starts a third runops loop, which then executes the die op. At this point the C call stack looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdfe7fb594151a128519964cf51c5b075b56f64a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prereqs&lt;/code&gt; key in the top-level metadata and within &lt;code&gt;optional_features&lt;/code&gt; define the relationship between a distribution and other packages. The prereq spec structure is a hierarchical data structure which divides prerequisites into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6012284b93fc2045dcbcea769da43a4a9d853f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prompt()&lt;/code&gt; function provides an easy way to request user input used to write a makefile. It displays the $message as a prompt for input. If a $default is provided it will be used as a default. The function returns the $value selected by the user.</source>
          <target state="translated">的 &lt;code&gt;prompt()&lt;/code&gt; 函数提供了一种简单的方法来用于写入生成文件请求用户输入。它显示$ message作为输入提示。如果提供了$ default，它将用作默认值。该函数返回用户选择的$ value。</target>
        </trans-unit>
        <trans-unit id="251a318ac7ae399ceb208b84bc39666205a2a077" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module encapsulates the results for a single test suite run.</source>
          <target state="translated">该 &lt;code&gt;prove&lt;/code&gt; 命令支持 &lt;code&gt;--state&lt;/code&gt; 指示它来存储整个运行持续状态的选择。该模块封装了单个测试套件运行的结果。</target>
        </trans-unit>
        <trans-unit id="225b0b123ca124089a53e65a14a10e06fffd421b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module encapsulates the results for a single test.</source>
          <target state="translated">该 &lt;code&gt;prove&lt;/code&gt; 命令支持 &lt;code&gt;--state&lt;/code&gt; 指示它来存储整个运行持续状态的选择。该模块封装了单个测试的结果。</target>
        </trans-unit>
        <trans-unit id="630214733172c835a26947747354eba32ad3911c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module implements that state and the operations that may be performed on it.</source>
          <target state="translated">该 &lt;code&gt;prove&lt;/code&gt; 命令支持 &lt;code&gt;--state&lt;/code&gt; 指示它来存储整个运行持续状态的选择。该模块实现该状态以及可以在其上执行的操作。</target>
        </trans-unit>
        <trans-unit id="ebc7b6c659bfd339fe90d4f36223bdf0f00d2207" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qr//&lt;/code&gt; operator showed up in perl 5.005. It compiles a regular expression, but doesn't apply it. When you use the pre-compiled version of the regex, perl does less work. In this example, I inserted a &lt;code&gt;map&lt;/code&gt; to turn each pattern into its pre-compiled form. The rest of the script is the same, but faster:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a8c0b3ff5aa42089f6c9d44d37572f7b89a880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;re '/flags'&lt;/code&gt; pragma (introduced in Perl 5.14) turns on the given regular expression flags until the end of the lexical scope. See &lt;a href=&quot;re#%27%2Fflags%27-mode&quot;&gt;&quot;'/flags' mode&quot; in re&lt;/a&gt; for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ee1aae608f6953af89e472ae38b6d9068b7d8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;re '/flags'&lt;/code&gt; pragma (introduced in Perl 5.14) turns on the given regular expression flags until the end of the lexical scope. See &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;'/flags' mode in re&lt;/a&gt; for more detail.</source>
          <target state="translated">所述 &lt;code&gt;re '/flags'&lt;/code&gt; 编译指示（在Perl 5.14引入）接通给定正则表达式标志直到词法作用域的末尾。有关更多详细信息，请参见&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;re中的&amp;ldquo; / flags&amp;rdquo;模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8026b2e7b59b6835c618b76fac10379af835df78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; will</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabbdc8a005d2bf3f21650b9e863366189c7ced7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recent&lt;/code&gt; command downloads a list of recent uploads to CPAN and displays them</source>
          <target state="translated">在 &lt;code&gt;recent&lt;/code&gt; 命令下载最近上传到CPAN并显示它们的列表</target>
        </trans-unit>
        <trans-unit id="3ae27e036bb44d621cb68002f9a110e07c700371" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recipient&lt;/code&gt; method can also pass additional case-sensitive OPTIONS as an anonymous hash using key and value pairs. Possible options are:</source>
          <target state="translated">的 &lt;code&gt;recipient&lt;/code&gt; 方法还可以通过使用键和值的对附加区分大小写选项作为匿名散列。可能的选项是：</target>
        </trans-unit>
        <trans-unit id="fbfa5e6131ec26898b29be346c8692d308b580c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;redo&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;continue&lt;/code&gt; block, if any, is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6b672315250ddc806f0b1d734bf40a266a6de9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is common to all regex engines. Two of its fields are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and pprivate members. The &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values. In the case of the stock engine the structure pointed to by &lt;code&gt;pprivate&lt;/code&gt; is called &lt;code&gt;regexp_internal&lt;/code&gt; .</source>
          <target state="translated">&lt;a href=&quot;perlreapi&quot;&gt;perlreapi中&lt;/a&gt;描述的 &lt;code&gt;regexp&lt;/code&gt; 结构对所有regex引擎都是通用的。它的两个字段供编译该模式的正则表达式引擎专用。这些是 &lt;code&gt;intflags&lt;/code&gt; 和私有成员。该 &lt;code&gt;pprivate&lt;/code&gt; 是一个空指针到任意的结构，其使用和管理是编译引擎的责任。 perl永远不会修改这些值中的任何一个。在股票引擎的情况下， &lt;code&gt;pprivate&lt;/code&gt; 指向的结构称为 &lt;code&gt;regexp_internal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43d7f5d7cf7b3bd50ec33b3f8b3d3e3e1b16ccb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is common to all regex engines. Two of its fields are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and pprivate members. The &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values. In the case of the stock engine the structure pointed to by &lt;code&gt;pprivate&lt;/code&gt; is called &lt;code&gt;regexp_internal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e74666fabd3ef514f919b776494b74805eeb39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; method allows for the registration of a message handler for a given subroutine. The full subroutine name including the package should be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4f7500531b634ca33f77ec64b4dcfc7b5a94686" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;release_status&lt;/code&gt; field &lt;b&gt;must&lt;/b&gt; have one of the following values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2292ba9ae057df1902ceef2446c66c533b62b3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remove_tree&lt;/code&gt; function deletes the given directories and any files and subdirectories they might contain, much like the Unix command &lt;code&gt;rm -r&lt;/code&gt; or &lt;code&gt;del /s&lt;/code&gt; on Windows.</source>
          <target state="translated">该 &lt;code&gt;remove_tree&lt;/code&gt; 函数删除指定的目录和它们可能包含任何文件和子目录，就像Unix命令 &lt;code&gt;rm -r&lt;/code&gt; 或 &lt;code&gt;del /s&lt;/code&gt; Windows上。</target>
        </trans-unit>
        <trans-unit id="f1fcc73f0626aba933df61d1eca5f7c5f0df238b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remove_tree&lt;/code&gt; function deletes the given directories and any files and subdirectories they might contain, much like the Unix command &lt;code&gt;rm -rf&lt;/code&gt; or the Windows commands &lt;code&gt;rmdir /s&lt;/code&gt; and &lt;code&gt;rd /s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f800b61fba3cbdc9dbaf2d3127156f3c10c2be33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;report&lt;/code&gt; command temporarily turns on the &lt;code&gt;test_report&lt;/code&gt; config variable, then runs the &lt;code&gt;force test&lt;/code&gt; command with the given arguments. The &lt;code&gt;force&lt;/code&gt; pragma reruns the tests and repeats every step that might have failed before.</source>
          <target state="translated">该 &lt;code&gt;report&lt;/code&gt; 命令暂时打开了 &lt;code&gt;test_report&lt;/code&gt; 配置变量，然后运行 &lt;code&gt;force test&lt;/code&gt; 与给定的参数命令。该 &lt;code&gt;force&lt;/code&gt; 编译重新运行测试，并重复每一个可能之前已经失败的步骤。</target>
        </trans-unit>
        <trans-unit id="3e0418f790bb3ba77ebbb5b8be57ce758907a81a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request&lt;/code&gt; method returns a hashref containing the response. The hashref will have the following keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb965f28ada4d369f813e7b58370f45663a7e17c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;requires&lt;/code&gt; and &lt;code&gt;build_requires&lt;/code&gt; dependency declarations</source>
          <target state="translated">的 &lt;code&gt;requires&lt;/code&gt; 和 &lt;code&gt;build_requires&lt;/code&gt; 依赖声明</target>
        </trans-unit>
        <trans-unit id="6825adde139cbe709d6cacc6c4ea55d8ef7cff02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;resolve&lt;/code&gt; function is called to generate a linearised ISA for the given stash, using this MRO. It is called with a pointer to the stash, and a</source>
          <target state="translated">该 &lt;code&gt;resolve&lt;/code&gt; 函数被调用，生成针对给定的藏匿一个线性化ISA，使用这种MRO。它被称为带有隐藏的指针，并且</target>
        </trans-unit>
        <trans-unit id="20a1d55e5f69a55a8401c7bd274cec494c442203" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result_factory_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e85b7e6554a08b089b5049ccd1a608787302c15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result_factory_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;result_factory_class&lt;/code&gt; 可定制，如在&lt;a href=&quot;#new&quot;&gt;新的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ca2114e55ee9c4857e906508831f67273f52466" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;retrans&lt;/code&gt; argument the exponential backoff rate, default 1.2. It matches the $def_factor global.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4f5cbea499bebe5f70cb857ce9ac77d66aaa7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rmtree()&lt;/code&gt; function provide the legacy interface of &lt;code&gt;remove_tree()&lt;/code&gt; with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to &lt;code&gt;remove_tree()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6451f829e84fc9b2a12b294243486a8357dccdcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;roffitall&lt;/code&gt; utility is not installed on your system but lives in the</source>
          <target state="translated">该 &lt;code&gt;roffitall&lt;/code&gt; 实用程序未安装在系统上，但居住在</target>
        </trans-unit>
        <trans-unit id="38bb81c7279e4123eea02d7b94773b0e43184b92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; method returns 0 on success and a positive number on failure. See the section on EXIT CODES for details on the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec12f7a8b2d7f40a1c42ea8d991b557d8527791c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;s///&lt;/code&gt; substitution operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f11595235e0f9e5e74b59c34bf7ac4552157c76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send()&lt;/code&gt; method is used to issue an event to the hub. This method will handle thread/fork sync, filters, listeners, TAP output, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9411561fa33dd9a0d96df4e7b49fae524226bee1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip(...)&lt;/code&gt; function is for tests that might or might not be possible to run, depending on the availability of platform-specific features. The first argument should evaluate to true (think &quot;yes, please skip&quot;) if the required feature is</source>
          <target state="translated">将 &lt;code&gt;skip(...)&lt;/code&gt; 功能是对可能或可能无法运行测试，取决于特定平台功能的可用性。如果所需的功能是，则第一个参数的计算结果应为true（认为&amp;ldquo;是，请跳过&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="4dd34dc5f337a99adbdb95ed69eaa2b33a678e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;smoke&lt;/code&gt; command takes the list of recent uploads to CPAN as provided by the &lt;code&gt;recent&lt;/code&gt; command and tests them all. While the command is running $SIG{INT} is defined to mean that the current item shall be skipped.</source>
          <target state="translated">该 &lt;code&gt;smoke&lt;/code&gt; 命令将最近上传到CPAN的列表，通过所提供的 &lt;code&gt;recent&lt;/code&gt; 的命令，并测试其所有。当命令运行时，$ SIG {INT}被定义为表示将跳过当前项目。</target>
        </trans-unit>
        <trans-unit id="c81eca2265a8bfa89f7e2b8216b25f7468527582" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;socktype&lt;/code&gt; hint to getaddrinfo() filters the results to only include one socket type and protocol. Without this most OSes return three combinations, for &lt;code&gt;SOCK_STREAM&lt;/code&gt; , &lt;code&gt;SOCK_DGRAM&lt;/code&gt; and &lt;code&gt;SOCK_RAW&lt;/code&gt; , resulting in triplicate output of addresses. The &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; flag to getnameinfo() causes it to return a string-formatted plain IP address, rather than reverse resolving it back into a hostname.</source>
          <target state="translated">getaddrinfo（）的 &lt;code&gt;socktype&lt;/code&gt; 提示会过滤结果，使其仅包含一种套接字类型和协议。没有这些操作系统，大多数OS将返回 &lt;code&gt;SOCK_STREAM&lt;/code&gt; ， &lt;code&gt;SOCK_DGRAM&lt;/code&gt; 和 &lt;code&gt;SOCK_RAW&lt;/code&gt; 的三种组合，从而导致地址输出一式三份。getnameinfo（）的 &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; 标志使它返回字符串格式的纯IP地址，而不是将其反向解析为主机名。</target>
        </trans-unit>
        <trans-unit id="96db56547c2805160963104b9881650067bc074a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;socktype&lt;/code&gt; hint to getaddrinfo() filters the results to only include one socket type and protocol. Without this most OSes return three combinations, for &lt;code&gt;SOCK_STREAM&lt;/code&gt;, &lt;code&gt;SOCK_DGRAM&lt;/code&gt; and &lt;code&gt;SOCK_RAW&lt;/code&gt;, resulting in triplicate output of addresses. The &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; flag to getnameinfo() causes it to return a string-formatted plain IP address, rather than reverse resolving it back into a hostname.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03364b2c6aff3f77be6e48e31bc6fc170edb9637" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;source&lt;/code&gt; is used to create a &lt;a href=&quot;TAP::Parser::Source&quot;&gt;TAP::Parser::Source&lt;/a&gt; that is passed to the &lt;a href=&quot;#iterator_factory_class&quot;&gt;&quot;iterator_factory_class&quot;&lt;/a&gt; which in turn figures out how to handle the source and creates a &amp;lt;TAP::Parser::Iterator&amp;gt; for it. The iterator is used by the parser to read in the TAP stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb1bd48c372b36b030a4985fb7d0b8ecfff9314" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;source&lt;/code&gt; is used to create a &lt;a href=&quot;parser/source&quot;&gt;TAP::Parser::Source&lt;/a&gt; that is passed to the &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt; which in turn figures out how to handle the source and creates a &amp;lt;TAP::Parser::Iterator&amp;gt; for it. The iterator is used by the parser to read in the TAP stream.</source>
          <target state="translated">该 &lt;code&gt;source&lt;/code&gt; 用于创建&lt;a href=&quot;parser/source&quot;&gt;TAP :: Parser :: Source&lt;/a&gt;，该消息传递给&lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt;，后者进而找出如何处理源代码并为其创建&amp;lt;TAP :: Parser :: Iterator&amp;gt;。解析器使用迭代器来读取TAP流。</target>
        </trans-unit>
        <trans-unit id="92eb80578e9c5fa00cf858e0d3634beaaf8da658" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sources&lt;/code&gt; parameter affects how &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; parameters are handled.</source>
          <target state="translated">在 &lt;code&gt;sources&lt;/code&gt; 参数将影响 &lt;code&gt;source&lt;/code&gt; ， &lt;code&gt;tap&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 参数进行处理。</target>
        </trans-unit>
        <trans-unit id="ecf38e3d7dde64637f98a88870a2d809b9706769" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sources&lt;/code&gt; parameter affects how &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; parameters are handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7630407dfd17260fb141bba76fd71474e26eb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;split()&lt;/code&gt; function is another place where a regexp is used. &lt;code&gt;split /regexp/, string, limit&lt;/code&gt; separates the &lt;code&gt;string&lt;/code&gt; operand into a list of substrings and returns that list. The regexp must be designed to match whatever constitutes the separators for the desired substrings. The &lt;code&gt;limit&lt;/code&gt;, if present, constrains splitting into no more than &lt;code&gt;limit&lt;/code&gt; number of strings. For example, to split a string into words, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5429b24bd7773605c81ffce19b7803e3914ae70b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; keyword creates a lexical variable (following the same scoping rules as &lt;code&gt;my&lt;/code&gt;) that persists from one subroutine call to the next. If a state variable resides inside an anonymous subroutine, then each copy of the subroutine has its own copy of the state variable. However, the value of the state variable will still persist between calls to the same copy of the anonymous subroutine. (Don't forget that &lt;code&gt;sub { ... }&lt;/code&gt; creates a new subroutine each time it is executed.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a6aa9719696ddb8bff79a8c79538ca92e0d2e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strend&lt;/code&gt; and &lt;code&gt;patend&lt;/code&gt; pointers should point to the byte following the last character of each string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6e352d41818ff4bf26ca16e10b39452c55d91f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict&lt;/code&gt; pragma disables certain Perl expressions that could behave unexpectedly or are difficult to debug, turning them into errors. The effect of this pragma is limited to the current file or scope block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027d4af5bb9710fddfec7b10292492a3bd8321cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict&lt;/code&gt; pragma is useful in avoiding such errors.</source>
          <target state="translated">在 &lt;code&gt;strict&lt;/code&gt; 附注为避免这样的错误非常有用。</target>
        </trans-unit>
        <trans-unit id="bda6d4349e03cdc3822accb764cf2332f0d166cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct()&lt;/code&gt; function</source>
          <target state="translated">的 &lt;code&gt;struct()&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="7a95e760c73406947e7da7714b03782e42d5fa06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct&lt;/code&gt; function has three forms of parameter-list.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 的功能有三种形式参数列表中。</target>
        </trans-unit>
        <trans-unit id="4f0312b0e41bdaef162518003e58d7dd5119b5b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sub-entry&lt;/code&gt; and &lt;code&gt;sub-return&lt;/code&gt; probes gain a fourth argument: the package name of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e032455d26f301f9311f3905ad487e2683ae6647" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;success&lt;/code&gt; field of the response will be true if the status code is 2XX or if the status code is 304 (unmodified).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f86ba3ab4dadf0c5969933e8badc4119d9d2f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;success&lt;/code&gt; field of the response will be true if the status code is 2XX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f8db9fbaa56d501321f36a7b37f026962feda33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;supports_tables&lt;/code&gt; method should be true if the formatter supports directly rendering table data from the &lt;code&gt;info&lt;/code&gt; facets. This is a newer feature and many older formatters may not support it. When not supported the formatter falls back to rendering &lt;code&gt;detail&lt;/code&gt; instead of the &lt;code&gt;table&lt;/code&gt; data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2248434d315d7f4555ab09ed558fffeb25af18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv&lt;/code&gt; argument is a pointer to the SV that is to acquire a new magical feature.</source>
          <target state="translated">该 &lt;code&gt;sv&lt;/code&gt; 参数是一个指向是获取一个新的神奇功能的SV。</target>
        </trans-unit>
        <trans-unit id="3bd810d1cf1c18312d2c5eb1e03b023fe5ee01ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv&lt;/code&gt; argument must be a reference value. The &lt;code&gt;stash&lt;/code&gt; argument specifies which class the reference will belong to. See &lt;a href=&quot;#Stashes-and-Globs&quot;&gt;&quot;Stashes and Globs&quot;&lt;/a&gt; for information on converting class names into stashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1732cdeea04b3b5302655756ff012b4b97e760" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv&lt;/code&gt; argument must be a reference value. The &lt;code&gt;stash&lt;/code&gt; argument specifies which class the reference will belong to. See &lt;a href=&quot;#Stashes-and-Globs&quot;&gt;Stashes and Globs&lt;/a&gt; for information on converting class names into stashes.</source>
          <target state="translated">的 &lt;code&gt;sv&lt;/code&gt; 参数必须是一个参考值。该 &lt;code&gt;stash&lt;/code&gt; 参数指定哪一个类的引用将属于。有关将类名转换为存储的信息，请参见&lt;a href=&quot;#Stashes-and-Globs&quot;&gt;存储和全局&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c426a5175e1475eb159d7aa2bfc10b9aeb2592e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_cat*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;&quot;Magic Virtual Tables&quot;&lt;/a&gt; later in this document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa9fb7196f50b878b4d2185150e32ef86a1a0ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_cat*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; later in this document.</source>
          <target state="translated">该 &lt;code&gt;sv_cat*()&lt;/code&gt; 函数不是通用的，足以对具有&amp;ldquo;魔力&amp;rdquo;的值进行操作。请参阅本文档后面的&lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ca2c3639e16b490b555d2489361f0871018a997" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_set*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;&quot;Magic Virtual Tables&quot;&lt;/a&gt; later in this document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451bffe03c920b337c26d3f6c5c7b3d0a90a952c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_set*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; later in this document.</source>
          <target state="translated">该 &lt;code&gt;sv_set*()&lt;/code&gt; 函数不是通用的，足以对具有&amp;ldquo;魔力&amp;rdquo;的值进行操作。请参阅本文档后面的&lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a022ed577de5458a14b966f973f3ce2a62bb2a5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; built-in is considered to have failed in the following circumstances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817c94b76b6dd84c4c7d9bb171edda3a93d8445e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; operator creates a subprocess, and passes its arguments to the subprocess for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt;, any valid DCL command string may be specified. If the string begins with '@', it is treated as a DCL command unconditionally. Otherwise, if the first token contains a character used as a delimiter in file specification (e.g. &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt;), an attempt is made to expand it using a default type of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264e3c8ac2fdd944cc02ae92713944fc8cf6494f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;taint&lt;/code&gt; pragma causes any substrings from a match with a tainted variable to be tainted as well. This is not normally the case, as regexps are often used to extract the safe bits from a tainted variable. Use &lt;code&gt;taint&lt;/code&gt; when you are not extracting safe bits, but are performing some other processing. Both &lt;code&gt;taint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; pragmas are lexically scoped, which means they are in effect only until the end of the block enclosing the pragmas.</source>
          <target state="translated">的 &lt;code&gt;taint&lt;/code&gt; 编译会导致从与被感染的可变匹配任何子被污染，以及。通常情况并非如此，因为经常使用正则表达式从受污染的变量中提取安全位。当您不提取安全位而是执行其他处理时，请使用 &lt;code&gt;taint&lt;/code&gt; 。两个 &lt;code&gt;taint&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; pragma可词法作用域的，这意味着它们在效果仅直到包围编译指示所述块的端部。</target>
        </trans-unit>
        <trans-unit id="45b556a65806a34a0370ae702153cb4405855fa8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;taint&lt;/code&gt; pragma causes any substrings from a match with a tainted variable to be tainted as well. This is not normally the case, as regexps are often used to extract the safe bits from a tainted variable. Use &lt;code&gt;taint&lt;/code&gt; when you are not extracting safe bits, but are performing some other processing. Both &lt;code&gt;taint&lt;/code&gt; and &lt;code&gt;eval&lt;/code&gt; pragmas are lexically scoped, which means they are in effect only until the end of the block enclosing the pragmas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc9bc272d719ab5016869a769d84acd8ec8d7c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;terminate&lt;/code&gt; and &lt;code&gt;finalize&lt;/code&gt; methods are optional methods called that you can implement if the format you're generating needs to handle these cases, for example if you are generating XML and need close open tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423cad30ef0048166a8eebe3340a46a30155372e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;terminate&lt;/code&gt; method is called when an event's &lt;code&gt;terminate&lt;/code&gt; method returns true, for example when a &lt;a href=&quot;Test2::Event::Plan&quot;&gt;Test2::Event::Plan&lt;/a&gt; has a &lt;code&gt;'skip_all'&lt;/code&gt; plan, or when a &lt;a href=&quot;Test2::Event::Bail&quot;&gt;Test2::Event::Bail&lt;/a&gt; event is sent. The &lt;code&gt;terminate&lt;/code&gt; method is passed a single argument, the &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; object which triggered the terminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e22b53957ab545ec5f1fe43f2463dbb75fb5bef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test_diag&lt;/code&gt; function prepends comment hashes and spacing to the start and newlines to the end of the expected output passed to it and adds it to the list of expected error output. So, instead of writing</source>
          <target state="translated">该 &lt;code&gt;test_diag&lt;/code&gt; 功能前添加评论散列和间隔的开始和新行的预期产出传递给它的结束，并将其添加到预期的错误输出的列表。所以，而不是写</target>
        </trans-unit>
        <trans-unit id="9a044497bbeccf899d123e744ac60158148d66b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thing&lt;/code&gt; argument can be any of an &lt;code&gt;SV*&lt;/code&gt; , &lt;code&gt;AV*&lt;/code&gt; , or &lt;code&gt;HV*&lt;/code&gt; . The functions are identical except that &lt;code&gt;newRV_inc&lt;/code&gt; increments the reference count of the &lt;code&gt;thing&lt;/code&gt; , while &lt;code&gt;newRV_noinc&lt;/code&gt; does not. For historical reasons, &lt;code&gt;newRV&lt;/code&gt; is a synonym for &lt;code&gt;newRV_inc&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;thing&lt;/code&gt; 参数可以是任何一个的 &lt;code&gt;SV*&lt;/code&gt; ， &lt;code&gt;AV*&lt;/code&gt; 或者 &lt;code&gt;HV*&lt;/code&gt; 。这些函数是相同的，除了 &lt;code&gt;newRV_inc&lt;/code&gt; 增加 &lt;code&gt;thing&lt;/code&gt; 的引用计数，而 &lt;code&gt;newRV_noinc&lt;/code&gt; 不增加。由于历史原因， &lt;code&gt;newRV&lt;/code&gt; 是一个代名词 &lt;code&gt;newRV_inc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39f6cd9542d25aca0f6da28dc2eb900530cd2e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thing&lt;/code&gt; argument can be any of an &lt;code&gt;SV*&lt;/code&gt;, &lt;code&gt;AV*&lt;/code&gt;, or &lt;code&gt;HV*&lt;/code&gt;. The functions are identical except that &lt;code&gt;newRV_inc&lt;/code&gt; increments the reference count of the &lt;code&gt;thing&lt;/code&gt;, while &lt;code&gt;newRV_noinc&lt;/code&gt; does not. For historical reasons, &lt;code&gt;newRV&lt;/code&gt; is a synonym for &lt;code&gt;newRV_inc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764690cb5a9a1e69711deb7f1d4bd7570cd33533" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;threads-&amp;gt;self()&lt;/code&gt; class method provides your program with a way to get an object representing the thread it's currently in. You can use this object in the same way as the ones returned from thread creation.</source>
          <target state="translated">该 &lt;code&gt;threads-&amp;gt;self()&lt;/code&gt; 类方法提供了一种方式来获得代表它目前在线程对象的程序，你可以以同样的方式从创建线程返回的人使用这个对象。</target>
        </trans-unit>
        <trans-unit id="5cb77a0f1c56daabcc9daa1cb20e1afceca163c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tid&lt;/code&gt; method returns the tid of a thread. The tid is a monotonically increasing integer assigned when a thread is created. The main thread of a program will have a tid of zero, while subsequent threads will have tids assigned starting with one.</source>
          <target state="translated">该 &lt;code&gt;tid&lt;/code&gt; 方法返回一个线程的TID。tid是创建线程时分配的单调递增整数。程序的主线程的tid为零，而后续线程的tid则从1开始分配。</target>
        </trans-unit>
        <trans-unit id="852bdb693d32a436b5f27ac2d4c29c14b07baed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tie&lt;/code&gt; call returns an object, say &lt;code&gt;$o&lt;/code&gt;. You may call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7906336a9d98d4a1cf6a79c6964edf2df1f812" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;time*_modern()&lt;/code&gt; subs do not do this year munging and simply take the year value as provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62cae6d3e02f73d7641c7861d0693bc4b08d5c81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; functions perform range checking on the input $sec, $min, $hour, $mday, and $mon values by default.</source>
          <target state="translated">所述 &lt;code&gt;timelocal()&lt;/code&gt; 和 &lt;code&gt;timegm()&lt;/code&gt; 函数的输入$秒，$分钟，$小时，$ MDAY和$周一个值默认执行范围检查。</target>
        </trans-unit>
        <trans-unit id="3444ad2f99e605827ac849ba41549cb93537c5ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timelocal()&lt;/code&gt; function is implemented using the same cache. We just assume that we're translating a GMT time, and then fudge it when we're done for the timezone and daylight savings arguments. Note that the timezone is evaluated for each date because countries occasionally change their official timezones. Assuming that &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; corrects for these changes, this routine will also be correct.</source>
          <target state="translated">该 &lt;code&gt;timelocal()&lt;/code&gt; 函数使用相同的高速缓存来实现。我们只是假设我们正在翻译GMT时间，然后在完成时区和夏令时参数时将其弄乱了。请注意，每个国家都会评估时区，因为国家有时会更改其官方时区。假设 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 可以纠正这些更改，则此例程也将是正确的。</target>
        </trans-unit>
        <trans-unit id="d6031b9f93c7f0ead71810ff0ffcc9e88c83f87c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timelocal()&lt;/code&gt; function is implemented using the same cache. We just assume that we're translating a GMT time, and then fudge it when we're done for the timezone and daylight savings arguments. Note that the timezone is evaluated for each date because countries occasionally change their official timezones. Assuming that &lt;code&gt;localtime()&lt;/code&gt; corrects for these changes, this routine will also be correct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e29c335d0e24d411a115fbcbdaff898b8a8cf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;times()&lt;/code&gt; function returns elapsed realtime since some point in the past (such as system startup), user and system times for this process, and user and system times used by child processes. All times are returned in clock ticks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88ddb341d5b31f6433cf87d10fae07c89fb702d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tmpnam&lt;/code&gt; function returns a unique string which can be used as a filename when creating temporary files. If, for some reason, it is unable to generate a name, it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8678670162f30c825dc963303a8366061c0624" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tr///&lt;/code&gt; operator translates whole characters. (Note that the &lt;code&gt;tr///CU&lt;/code&gt; functionality has been removed. For similar functionality to that, see &lt;code&gt;pack('U0', ...)&lt;/code&gt; and &lt;code&gt;pack('C0', ...)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1863d41e42c91ece1fce678f54e90a29e06de0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tr&lt;/code&gt; alternative might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c010b9c38ee87dfd390ac847c9b0e002caa8d481" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tr&lt;/code&gt; counts the null bytes. The &lt;code&gt;unpack&lt;/code&gt; call returns a list of name-value pairs each of which is taken apart in the &lt;code&gt;map&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="accc9aa113f108f1f58344bb9d92f9dd409a973d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tr&lt;/code&gt; version is a clear winner. One solution is flexible, the other is fast - and it's appropriately the programmer's choice which to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7969d03acba8ec22322bc524970a2e67bf531eeb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument should be equal to the &lt;code&gt;how&lt;/code&gt; value when the &lt;code&gt;SV&lt;/code&gt; was initially made magical.</source>
          <target state="translated">该 &lt;code&gt;type&lt;/code&gt; 参数应该是等于 &lt;code&gt;how&lt;/code&gt; 当值 &lt;code&gt;SV&lt;/code&gt; 最初是由神奇。</target>
        </trans-unit>
        <trans-unit id="45b58766c7b5bfa7d8fbeea9c00e3139b61f934f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type=&quot;man&quot;&lt;/code&gt; attribute is always specified for this type of L code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e37e784cf8826358b635a533d80412ae68521a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type=&quot;url&quot;&lt;/code&gt; attribute is always specified for this type of L code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e605c3e8404b3b1569b2a8f6ee2a28bb09c8e25f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u&lt;/code&gt; template to &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; will render EBCDIC data in EBCDIC characters equivalent to their ASCII counterparts. For example, the following will print &quot;Yes indeed\n&quot; on either an ASCII or EBCDIC computer:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;u&lt;/code&gt; 模板将以EBCDIC字符（与ASCII对等物相同）呈现EBCDIC数据。例如，以下代码将在ASCII或EBCDIC计算机上打印&amp;ldquo; Yes确实\ n&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="bcdcd5bf5921d41526775a635bdda4515bcae7f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u&lt;/code&gt; template to &lt;code&gt;pack()&lt;/code&gt; or &lt;code&gt;unpack()&lt;/code&gt; will render EBCDIC data in EBCDIC characters equivalent to their ASCII counterparts. For example, the following will print &quot;Yes indeed\n&quot; on either an ASCII or EBCDIC computer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0998cba5f7c7355370ef1940f9de1afcbe1199eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;undef&lt;/code&gt; value is treated by this function as distinct from the empty string, and no warning will be produced. It is left as-is in the returned list. Subsequent &lt;code&gt;undef&lt;/code&gt; values are still considered identical to the first, and will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c83289af1a4c0f7e1129f103e79b7a1caa912f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;untie&lt;/code&gt; Gotcha</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a1909f52d28496be25968c9641232bd70a050cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;up&lt;/code&gt; method increases the semaphore's count by the number specified (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">该 &lt;code&gt;up&lt;/code&gt; 方法由指定的数量，如果没有指定数目（它必须是整数&amp;gt; = 1），或由一个增加信号量的计数。</target>
        </trans-unit>
        <trans-unit id="3bfafbe930277e35ea02604239f7cd015c3326fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade&lt;/code&gt; command first runs an &lt;code&gt;r&lt;/code&gt; command with the given arguments and then installs the newest versions of all modules that were listed by that.</source>
          <target state="translated">该 &lt;code&gt;upgrade&lt;/code&gt; 命令首次运行 &lt;code&gt;r&lt;/code&gt; 与给定的参数命令，然后安装由上市的所有模块的最新版本。</target>
        </trans-unit>
        <trans-unit id="ed2a8ecd68dda5352fc1303d01e5cd582863eba1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;urllist&lt;/code&gt; parameter of the configuration table contains a list of URLs used for downloading. If the list contains any &lt;code&gt;file&lt;/code&gt; URLs, CPAN always tries there first. This feature is disabled for index files. So the recommendation for the owner of a CD-ROM with CPAN contents is: include your local, possibly outdated CD-ROM as a &lt;code&gt;file&lt;/code&gt; URL at the end of urllist, e.g.</source>
          <target state="translated">配置表的 &lt;code&gt;urllist&lt;/code&gt; 参数包含用于下载的URL列表。如果列表中包含任何 &lt;code&gt;file&lt;/code&gt; URL，则CPAN总是首先尝试在那里。索引文件禁用此功能。因此，对于具有CPAN内容的CD-ROM的所有者的建议是：在urllist的末尾包含本地的，可能已过时的CD-ROM作为 &lt;code&gt;file&lt;/code&gt; URL，例如</target>
        </trans-unit>
        <trans-unit id="52b900f042b9fdb4fefbfa11c5b63b7617ef4658" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;&lt;/code&gt; pragma produces some lovely diagnostics. One can also use the &lt;b&gt;-w&lt;/b&gt; flag, but its use is normally discouraged, because it gets applied to all executed Perl code, including that not under your control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d475de0db7f66747e084c66e42ee75d8f3488116" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use filetest&lt;/code&gt; or &lt;code&gt;no filetest&lt;/code&gt; statements affect file tests defined in their block, up to the end of the closest enclosing block (they are lexically block-scoped).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acfbde926d15ce3b3022057fc9c74ed9c253c404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use utf8&lt;/code&gt; pragma tells the Perl parser to allow UTF-8 in the program text in the current lexical scope. The &lt;code&gt;no utf8&lt;/code&gt; pragma tells Perl to switch back to treating the source text as literal bytes in the current lexical scope. (On EBCDIC platforms, technically it is allowing UTF-EBCDIC, and not UTF-8, but this distinction is academic, so in this document the term UTF-8 is used to mean both).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c5989f0b30cb3c2f7f588b2b53bc0b52ccd653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; switch will warn you if it interprets a reserved word as a string. But it will no longer warn you about using lowercase words, because the string is effectively quoted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="468aa2690cfac4f39947fa49f9490387f38518f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; and &lt;code&gt;utf8::upgrade()&lt;/code&gt; aren't needed if the argument is above 0xFF, so the above could have been written as</source>
          <target state="translated">该 &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; 和 &lt;code&gt;utf8::upgrade()&lt;/code&gt; 是不需要的，如果参数高于0xFF的，所以上面的程序可以写为</target>
        </trans-unit>
        <trans-unit id="c685630771328cb31903796f4e815c9203e60a01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;utf8&lt;/code&gt; flag therefore switches between two modes: disabled means you will get a Unicode string in Perl, enabled means you get an UTF-8 encoded octet/binary string in Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14707ff227aab2f7f6198f5296b54e26eed1065e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;util.c:1716&lt;/code&gt; is the source code file and line number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b13c9e2cf58e77564c57c1639c049e04a961551" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vars&lt;/code&gt; pragma (see &lt;a href=&quot;perlmod#vars&quot;&gt;&quot;vars&quot; in perlmod&lt;/a&gt;) may be used in such situations as an alternative to explicitly qualifying all globals with the package namespace. Variables pre-declared with this pragma will be visible to any autoloaded routines (but will not be invisible outside the package, unfortunately).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a270d12703e96872d5ec49cc2bfa5c1ab0eb455" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vars&lt;/code&gt; pragma (see &lt;a href=&quot;perlmod#vars&quot;&gt;vars in perlmod&lt;/a&gt;) may be used in such situations as an alternative to explicitly qualifying all globals with the package namespace. Variables pre-declared with this pragma will be visible to any autoloaded routines (but will not be invisible outside the package, unfortunately).</source>
          <target state="translated">的 &lt;code&gt;vars&lt;/code&gt; 编译指示（见&lt;a href=&quot;perlmod#vars&quot;&gt;瓦尔在perlmod的&lt;/a&gt;）可以在这种情况下被使用来替代明确资格所有全局与包命名空间。使用此编译指示预先声明的变量将对任何自动加载的例程可见（但不幸的是，在程序包外部将不可见）。</target>
        </trans-unit>
        <trans-unit id="8a981f510b5bc1a31c1fe6f83ee184b884a41beb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;verbose&lt;/code&gt; and &lt;code&gt;inc&lt;/code&gt; attributes influence the behavior of this search; notably, &lt;code&gt;inc&lt;/code&gt; , if true, adds @INC</source>
          <target state="translated">在 &lt;code&gt;verbose&lt;/code&gt; 和 &lt;code&gt;inc&lt;/code&gt; 属性影响该搜索的行为; 值得注意的是， &lt;code&gt;inc&lt;/code&gt; ，如果为true，则添加@INC</target>
        </trans-unit>
        <trans-unit id="e2febc4d875aa8fe8fb27485c483c05158694811" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;verbose&lt;/code&gt; and &lt;code&gt;inc&lt;/code&gt; attributes influence the behavior of this search; notably, &lt;code&gt;inc&lt;/code&gt;, if true, adds @INC</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="543a455e6e879b54b06a46e043825bb2c5bcee1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;version&lt;/code&gt; option is required. If it is omitted or if an unsupported version is given, then &lt;code&gt;provides&lt;/code&gt; will throw an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647cdf74da11836aaddbacaf0e85905018d3cf1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vmsopen&lt;/code&gt; function enables you to specify optional RMS arguments to the VMS CRTL when opening a file. Its operation is similar to the built-in Perl &lt;code&gt;open&lt;/code&gt; function (see &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for a complete description), but it will only open normal files; it cannot open pipes or duplicate existing I/O handles. Up to 8 optional arguments may follow the file name. These arguments should be strings which specify optional file characteristics as allowed by the CRTL. (See the CRTL reference manual description of creat() and fopen() for details.) If successful, &lt;code&gt;vmsopen&lt;/code&gt; returns a VMS::Stdio file handle; if an error occurs, it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e9db15fd405837558fc69a3922cf4c07b0d66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; return type for this function tells the &lt;b&gt;xsubpp&lt;/b&gt; compiler that the RETVAL variable is not needed or used and that it should not be created. In most scenarios the void return type should be used with the PPCODE: directive.</source>
          <target state="translated">此函数的 &lt;code&gt;void&lt;/code&gt; 返回类型告诉&lt;b&gt;xsubpp&lt;/b&gt;编译器不需要或不使用RETVAL变量，并且不应创建该变量。在大多数情况下，void返回类型应与PPCODE：指令一起使用。</target>
        </trans-unit>
        <trans-unit id="0803129a0bffe56a31c42b951ef5b3d0fb1885a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wanted()&lt;/code&gt; function does whatever verifications you want on each file and directory. Note that despite its name, the &lt;code&gt;wanted()&lt;/code&gt; function is a generic callback function, and does &lt;b&gt;not&lt;/b&gt; tell File::Find if a file is &quot;wanted&quot; or not. In fact, its return value is ignored.</source>
          <target state="translated">本 &lt;code&gt;wanted()&lt;/code&gt; 函数，你想要做的每个文件和目录的任何核查。需要注意的是，尽管它的名字，在 &lt;code&gt;wanted()&lt;/code&gt; 函数是一个通用的回调函数，并&lt;b&gt;没有&lt;/b&gt;告诉文件::查找一个文件是&amp;ldquo;通缉令&amp;rdquo;与否。实际上，它的返回值被忽略。</target>
        </trans-unit>
        <trans-unit id="31b1fe49028e0123810b9a17034fff70bf1be6cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warnings&lt;/code&gt; pragma gives control over which warnings are enabled in which parts of a Perl program. It's a more flexible alternative for both the command line flag &lt;b&gt;-w&lt;/b&gt; and the equivalent Perl variable, &lt;code&gt;$^W&lt;/code&gt; .</source>
          <target state="translated">该 &lt;code&gt;warnings&lt;/code&gt; 编译给出了该警告的Perl程序的这部分功能的控制。对于命令行标志&lt;b&gt;-w&lt;/b&gt;和等效的Perl变量 &lt;code&gt;$^W&lt;/code&gt; ，这是一种更加灵活的替代方法。</target>
        </trans-unit>
        <trans-unit id="a8cf47d373c14fa99c46a7f56571b8224d41ad4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warnings&lt;/code&gt; pragma gives control over which warnings are enabled in which parts of a Perl program. It's a more flexible alternative for both the command line flag &lt;b&gt;-w&lt;/b&gt; and the equivalent Perl variable, &lt;code&gt;$^W&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d599e8a7252be8237239500a33b9cae49be5da2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warnings&lt;/code&gt; pragma provides a number of functions that are useful for module authors. These are used when you want to report a module-specific warning to a calling module has enabled warnings via the &lt;code&gt;warnings&lt;/code&gt; pragma.</source>
          <target state="translated">该 &lt;code&gt;warnings&lt;/code&gt; 编译提供的一定数量的是模块的作者有用的功能。当您要向警告模块报告特定于模块的警告时，可以使用这些 &lt;code&gt;warnings&lt;/code&gt; 。警告模块已通过警告编译指示启用了警告。</target>
        </trans-unit>
        <trans-unit id="eaaf2c2b19accccb92902e0f89453388a8136ad7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; modifier is an experimental feature that first appeared in Perl 5.14. To use it, you should include a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.14&lt;/code&gt; declaration. (Technically, it requires only the &lt;code&gt;switch&lt;/code&gt; feature, but that aspect of it was not available before 5.14.) Operative only from within a &lt;code&gt;foreach&lt;/code&gt; loop or a &lt;code&gt;given&lt;/code&gt; block, it executes the statement only if the smartmatch &lt;code&gt;$_ ~~ &lt;i&gt;EXPR&lt;/i&gt;&lt;/code&gt; is true. If the statement executes, it is followed by a &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; from inside a &lt;code&gt;foreach&lt;/code&gt; and &lt;code&gt;break&lt;/code&gt; from inside a &lt;code&gt;given&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;when&lt;/code&gt; 改性剂是一种实验性的功能最早出现在Perl 5.14。要使用它，您应该包括一个 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.14&lt;/code&gt; 声明。 （从技术上讲，它仅需要 &lt;code&gt;switch&lt;/code&gt; 功能，但该方面在5.14之前不可用。）仅在 &lt;code&gt;foreach&lt;/code&gt; 循环或 &lt;code&gt;given&lt;/code&gt; 块内可操作，它仅在smartmatch &lt;code&gt;$_ ~~ &lt;i&gt;EXPR&lt;/i&gt;&lt;/code&gt; 为true 时才执行该语句。如果执行该语句，则从 &lt;code&gt;foreach&lt;/code&gt; 内部执行 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 语句，并从 &lt;code&gt;given&lt;/code&gt; 内部 &lt;code&gt;break&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01d8e0a81cc17a534c96cebc629a6872720abbea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; modifier is an experimental feature that first appeared in Perl 5.14. To use it, you should include a &lt;code&gt;use v5.14&lt;/code&gt; declaration. (Technically, it requires only the &lt;code&gt;switch&lt;/code&gt; feature, but that aspect of it was not available before 5.14.) Operative only from within a &lt;code&gt;foreach&lt;/code&gt; loop or a &lt;code&gt;given&lt;/code&gt; block, it executes the statement only if the smartmatch &lt;code&gt;$_ ~~ &lt;i&gt;EXPR&lt;/i&gt;&lt;/code&gt; is true. If the statement executes, it is followed by a &lt;code&gt;next&lt;/code&gt; from inside a &lt;code&gt;foreach&lt;/code&gt; and &lt;code&gt;break&lt;/code&gt; from inside a &lt;code&gt;given&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19be3044d8f18bead09bab3403090b34e1156d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;until&lt;/code&gt; modifiers have the usual &quot;&lt;code&gt;while&lt;/code&gt; loop&quot; semantics (conditional evaluated first), except when applied to a &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;-BLOCK (or to the Perl4 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;-SUBROUTINE statement), in which case the block executes once before the conditional is evaluated.</source>
          <target state="translated">的 &lt;code&gt;while&lt;/code&gt; 和 &lt;code&gt;until&lt;/code&gt; 改性剂具有通常的&amp;ldquo; &lt;code&gt;while&lt;/code&gt; 循环&amp;rdquo;语义（有条件的第一计算的），当施加至除了 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; （或到Perl4样式-嵌段 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; -SUBROUTINE语句），在这种情况下，块执行一次前的条件被评估。</target>
        </trans-unit>
        <trans-unit id="9a6cf234df302fa34cb78a16f01d3bf12b7f579c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;until&lt;/code&gt; modifiers have the usual &quot;&lt;code&gt;while&lt;/code&gt; loop&quot; semantics (conditional evaluated first), except when applied to a &lt;code&gt;do&lt;/code&gt;-BLOCK (or to the Perl4 &lt;code&gt;do&lt;/code&gt;-SUBROUTINE statement), in which case the block executes once before the conditional is evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d5b06f931731acb22dad061fcd52f2783c874b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement executes the block as long as the expression is &lt;a href=&quot;#Truth-and-Falsehood&quot;&gt;true&lt;/a&gt;. The &lt;code&gt;until&lt;/code&gt; statement executes the block as long as the expression is false. The LABEL is optional, and if present, consists of an identifier followed by a colon. The LABEL identifies the loop for the loop control statements &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;. If the LABEL is omitted, the loop control statement refers to the innermost enclosing loop. This may include dynamically looking back your call-stack at run time to find the LABEL. Such desperate behavior triggers a warning if you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; flag.</source>
          <target state="translated">只要表达式为&lt;a href=&quot;#Truth-and-Falsehood&quot;&gt;true&lt;/a&gt;， &lt;code&gt;while&lt;/code&gt; 语句就会执行该块。只要表达式为假， &lt;code&gt;until&lt;/code&gt; 语句将执行该块。 LABEL是可选的，并且如果存在，则由标识符和冒号组成。 LABEL为 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 的循环控制语句标识循环。如果省略了LABEL，则循环控制语句引用最内层的循环。这可能包括在运行时动态回顾您的调用堆栈以找到LABEL。如果使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; warnings编译指示或&lt;b&gt;-w&lt;/b&gt;标志，则这种绝望的行为将触发警告。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fc7bfa0e2e102bef2e270e8846cdbd5da131def6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement executes the block as long as the expression is true. The &lt;code&gt;until&lt;/code&gt; statement executes the block as long as the expression is false. The LABEL is optional, and if present, consists of an identifier followed by a colon. The LABEL identifies the loop for the loop control statements &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, and &lt;code&gt;redo&lt;/code&gt;. If the LABEL is omitted, the loop control statement refers to the innermost enclosing loop. This may include dynamically looking back your call-stack at run time to find the LABEL. Such desperate behavior triggers a warning if you use the &lt;code&gt;use warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2df4bdf5b271135d9fbaa4b9e22485bd5691df53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; method is a method, so it either gets a class or instance. The two arguments are the &lt;code&gt;$event&lt;/code&gt; object it should record, and the &lt;code&gt;$assert_num&lt;/code&gt; which is the number of the current assertion (ok), or the last assertion if this event is not itself an assertion. The assertion number may be any integer 0 or greater, and may be undefined in some cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f557fbb89c75fd2ab740d93d25721ccbf0fda2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; function allows another thread to take control of the CPU. The exact results are implementation-dependent.</source>
          <target state="translated">的 &lt;code&gt;yield&lt;/code&gt; 函数允许另一个线程来采取CPU的控制。确切的结果取决于实现。</target>
        </trans-unit>
        <trans-unit id="213469077fec26be3b6b3b082204198d28c562aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;zipinfo&lt;/code&gt; program that comes with the info-zip distribution (&lt;a href=&quot;http://www.info-zip.org/&quot;&gt;http://www.info-zip.org/&lt;/a&gt;) can also display details of the structure of a zip file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246e63b2eb0074027eaf6b6fe6bf0995cbbb987b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;//&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operators return the last value evaluated (unlike C's &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, which return 0 or 1). Thus, a reasonably portable way to find out the home directory might be:</source>
          <target state="translated">该 &lt;code&gt;||&lt;/code&gt; ， &lt;code&gt;//&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 运算符返回最后计算的值（不同于C的 &lt;code&gt;||&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ，它们返回0或1）。因此，找出主目录的合理移植方式可能是：</target>
        </trans-unit>
        <trans-unit id="11f57b3d94eabb5c19fb9360ab6afe8316dfa0a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~~&lt;/code&gt; operator compares its operands &quot;polymorphically&quot;, determining how to compare them according to their actual types (numeric, string, array, hash, etc.) Like the equality operators with which it shares the same precedence, &lt;code&gt;~~&lt;/code&gt; returns 1 for true and &lt;code&gt;&quot;&quot;&lt;/code&gt; for false. It is often best read aloud as &quot;in&quot;, &quot;inside of&quot;, or &quot;is contained in&quot;, because the left operand is often looked for</source>
          <target state="translated">的 &lt;code&gt;~~&lt;/code&gt; 操作其操作数&amp;ldquo;多晶型&amp;rdquo;进行比较，确定如何根据他们的实际类型（数值，字符串数组，散列等）喜欢用它共享相同的优先级相等的运营商，他们比较 &lt;code&gt;~~&lt;/code&gt; 返回1为正确， &lt;code&gt;&quot;&quot;&lt;/code&gt; 代表错误。通常最好将其大声读为&amp;ldquo;在...中&amp;rdquo;，&amp;ldquo;在...中&amp;rdquo;或&amp;ldquo;包含在其中&amp;rdquo;，因为通常会寻找左操作数</target>
        </trans-unit>
        <trans-unit id="9e2869673394c26d565412dbb368358875961728" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~~&lt;/code&gt; operator compares its operands &quot;polymorphically&quot;, determining how to compare them according to their actual types (numeric, string, array, hash, etc.). Like the equality operators with which it shares the same precedence, &lt;code&gt;~~&lt;/code&gt; returns 1 for true and &lt;code&gt;&quot;&quot;&lt;/code&gt; for false. It is often best read aloud as &quot;in&quot;, &quot;inside of&quot;, or &quot;is contained in&quot;, because the left operand is often looked for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef321bd7088ac81817f2231db61c1174692aaac0" translate="yes" xml:space="preserve">
          <source>The ADLER32 checksum field must be present.</source>
          <target state="translated">ADLER32校验字段必须存在。</target>
        </trans-unit>
        <trans-unit id="9c4519701849f27da68be727b95e63207f2a9abf" translate="yes" xml:space="preserve">
          <source>The AIX tar does not fill all unused space in the tar archive with 0x00. This sometimes leads to warning messages from &lt;code&gt;Archive::Tar&lt;/code&gt; .</source>
          <target state="translated">AIX tar不会用0x00填充tar归档中所有未使用的空间。有时这会导致来自 &lt;code&gt;Archive::Tar&lt;/code&gt; 警告消息。</target>
        </trans-unit>
        <trans-unit id="508b055d2e59a80ceed1c9bfc5a331ff6cb825bc" translate="yes" xml:space="preserve">
          <source>The AIX tar does not fill all unused space in the tar archive with 0x00. This sometimes leads to warning messages from &lt;code&gt;Archive::Tar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5549afa573e8454744ea43299cd8d8505147fcd" translate="yes" xml:space="preserve">
          <source>The ALIAS: Keyword</source>
          <target state="translated">ALIAS:关键字</target>
        </trans-unit>
        <trans-unit id="2ce9242faeeab07eef2f7afd701bea6933de8059" translate="yes" xml:space="preserve">
          <source>The ALIAS: keyword allows an XSUB to have two or more unique Perl names and to know which of those names was used when it was invoked. The Perl names may be fully-qualified with package names. Each alias is given an index. The compiler will setup a variable called &lt;code&gt;ix&lt;/code&gt; which contain the index of the alias which was used. When the XSUB is called with its declared name &lt;code&gt;ix&lt;/code&gt; will be 0.</source>
          <target state="translated">ALIAS：关键字允许XSUB具有两个或多个唯一的Perl名称，并知道在调用它时使用了哪个名称。Perl名称可以使用包名称来完全限定。每个别名都有一个索引。编译器将设置一个名为 &lt;code&gt;ix&lt;/code&gt; 的变量，其中包含使用的别名的索引。当使用其声明的名称调用XSUB时， &lt;code&gt;ix&lt;/code&gt; 将为0。</target>
        </trans-unit>
        <trans-unit id="15fd0430aabb02304def7c36146cf671599d3942" translate="yes" xml:space="preserve">
          <source>The API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="9ed04c99d7b2c6a9ba47b9e4b73c73bb3ccc347c" translate="yes" xml:space="preserve">
          <source>The API was changed in the 2.0 branch. For a time, &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; tried, unsuccessfully, to deal with the two different calling mechanisms. This approach was considered a failure.</source>
          <target state="translated">该API已在2.0分支中更改。一段时间以来， &lt;code&gt;mkpath&lt;/code&gt; 和 &lt;code&gt;rmtree&lt;/code&gt; 尝试处理两种不同的调用机制均未成功。这种方法被认为是失败的。</target>
        </trans-unit>
        <trans-unit id="009ead0f6ffd2c056d27d3bfda98818a54d2faea" translate="yes" xml:space="preserve">
          <source>The ASCII region (0x00-0x7f) is preserved for all encodings, even though this conflicts with mappings by the Unicode Consortium.</source>
          <target state="translated">ASCII区域(0x00-0x7f)在所有编码中都被保留,尽管这与Unicode联盟的映射有冲突。</target>
        </trans-unit>
        <trans-unit id="93fd64b40c593362e390e4e7060b0bced9f138ed" translate="yes" xml:space="preserve">
          <source>The ASCII-specific functions. Each of these is just the same as the version without the trailing &quot;A&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c4e287eeab5aae5482e7df8b6e409cada7c372" translate="yes" xml:space="preserve">
          <source>The ASCII/Latin-1/Unicode character with that number. A leading &quot;0x&quot; means that</source>
          <target state="translated">带有该数字的ASCII/拉丁语1/Unicode字符。前面的 &quot;0x &quot;表示</target>
        </trans-unit>
        <trans-unit id="b76347c5c2c07c6a471b32d6864a1a7d9b8fb48a" translate="yes" xml:space="preserve">
          <source>The AUTOLOAD method, discussed in &lt;a href=&quot;perlsub#Autoloading&quot;&gt;&quot;Autoloading&quot; in perlsub&lt;/a&gt; lets you capture calls to undefined functions and methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2afefe4f37ea14f731718bb07a4d6306f1639c5" translate="yes" xml:space="preserve">
          <source>The AUTOLOAD method, discussed in &lt;a href=&quot;perlsub#Autoloading&quot;&gt;Autoloading in perlsub&lt;/a&gt; lets you capture calls to undefined functions and methods.</source>
          <target state="translated">&lt;a href=&quot;perlsub#Autoloading&quot;&gt;在perlsub的自动加载中&lt;/a&gt;讨论的AUTOLOAD方法使您可以捕获对未定义函数和方法的调用。</target>
        </trans-unit>
        <trans-unit id="31231455a0cef5b5794db63f07a47d2f6efab12c" translate="yes" xml:space="preserve">
          <source>The ActiveState Pages, &lt;a href=&quot;http://www.activestate.com/&quot;&gt;http://www.activestate.com/&lt;/a&gt;</source>
          <target state="translated">ActiveState页面，&lt;a href=&quot;http://www.activestate.com/&quot;&gt;http&lt;/a&gt;：//www.activestate.com/</target>
        </trans-unit>
        <trans-unit id="334394ca32871dfe81ad4bfaf08e575776ff3a37" translate="yes" xml:space="preserve">
          <source>The ActiveState Pages, &lt;a href=&quot;https://www.activestate.com/&quot;&gt;https://www.activestate.com/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbbc6fc0e5dd1ef33879bfc672f5e3e8813e4f97" translate="yes" xml:space="preserve">
          <source>The Adventures of Tom Bombadil</source>
          <target state="translated">汤姆-本巴迪尔历险记</target>
        </trans-unit>
        <trans-unit id="e2e0a5aea5199e87efc4db9939033262cf1e73b8" translate="yes" xml:space="preserve">
          <source>The Alignment Pit</source>
          <target state="translated">校准坑</target>
        </trans-unit>
        <trans-unit id="68a751b9c456def01d238b0c06471f4927931bb2" translate="yes" xml:space="preserve">
          <source>The American Standard Code for Information Interchange (ASCII or US-ASCII) is a set of integers running from 0 to 127 (decimal) that have standardized interpretations by the computers which use ASCII. For example, 65 means the letter &quot;A&quot;. The range 0..127 can be covered by setting the bits in a 7-bit binary digit, hence the set is sometimes referred to as &quot;7-bit ASCII&quot;. ASCII was described by the American National Standards Institute document ANSI X3.4-1986. It was also described by ISO 646:1991 (with localization for currency symbols). The full ASCII set is given in the table &lt;a href=&quot;#recipe-3&quot;&gt;below&lt;/a&gt; as the first 128 elements. Languages that can be written adequately with the characters in ASCII include English, Hawaiian, Indonesian, Swahili and some Native American languages.</source>
          <target state="translated">美国信息交换标准代码（ASCII或US-ASCII）是一组从0到127（十进制）的整数，这些整数由使用ASCII的计算机进行了标准化的解释。例如，65表示字母&amp;ldquo; A&amp;rdquo;。可以通过将位设置为7位二进制数字来覆盖范围0..127，因此该设置有时称为&amp;ldquo; 7位ASCII&amp;rdquo;。 ASCII由美国国家标准协会文件ANSI X3.4-1986描述。 ISO 646：1991也对此进行了描述（货币符号的本地化）。完整的ASCII集&lt;a href=&quot;#recipe-3&quot;&gt;在下&lt;/a&gt;表中作为前128个元素给出。可以使用ASCII字符充分书写的语言包括英语，夏威夷语，印度尼西亚语，斯瓦希里语和某些美洲原住民语言。</target>
        </trans-unit>
        <trans-unit id="4f30a3791e1ac69d9730db09043c7e01d216a23a" translate="yes" xml:space="preserve">
          <source>The American Standard Code for Information Interchange (ASCII or US-ASCII) is a set of integers running from 0 to 127 (decimal) that have standardized interpretations by the computers which use ASCII. For example, 65 means the letter &quot;A&quot;. The range 0..127 can be covered by setting various bits in a 7-bit binary digit, hence the set is sometimes referred to as &quot;7-bit ASCII&quot;. ASCII was described by the American National Standards Institute document ANSI X3.4-1986. It was also described by ISO 646:1991 (with localization for currency symbols). The full ASCII set is given in the table &lt;a href=&quot;#recipe-3&quot;&gt;below&lt;/a&gt; as the first 128 elements. Languages that can be written adequately with the characters in ASCII include English, Hawaiian, Indonesian, Swahili and some Native American languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ff218a8809c68d0eb083f2cf66b8207142d4f0" translate="yes" xml:space="preserve">
          <source>The American Standard Code for Information Interchange (a 7-bit character set adequate only for poorly representing English text). Often used loosely to describe the lowest 128 values of the various ISO-8859-X character sets, a bunch of mutually incompatible 8-bit codes best described as half ASCII. See also &lt;b&gt;Unicode&lt;/b&gt;.</source>
          <target state="translated">美国信息交换标准代码（一个7位字符集，仅适用于表示较差的英文文本）。通常宽松地描述各种ISO-8859-X字符集的最低128个值，一堆相互不兼容的8位代码最好用半个ASCII描述。另请参见&lt;b&gt;Unicode&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="0269ea9ab723afb75524e043608495b84069c96f" translate="yes" xml:space="preserve">
          <source>The Amiga::ARexx module allows you to easily create a perl based ARexx host or to send ARexx commands to other programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af5792ad21fdac265ea44a70d1cb66ca1977707" translate="yes" xml:space="preserve">
          <source>The Amiga::Exec module introduces support for Wait().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1c7da39d90054f5c4c81dc1a1fa13bcbbe82e7" translate="yes" xml:space="preserve">
          <source>The Anatomy of an XSUB</source>
          <target state="translated">XSUB的解剖</target>
        </trans-unit>
        <trans-unit id="0746d95bfde5c5ba18bf27b5d1463ad01ffdafa1" translate="yes" xml:space="preserve">
          <source>The Argument Stack</source>
          <target state="translated">争论堆栈</target>
        </trans-unit>
        <trans-unit id="59f8369b68ee932dd97b5ec57202b3f3969c4a83" translate="yes" xml:space="preserve">
          <source>The Arrow Operator</source>
          <target state="translated">箭头操作员</target>
        </trans-unit>
        <trans-unit id="e40e5d487b331e1f7f4c2477322a84662ea1dcde" translate="yes" xml:space="preserve">
          <source>The Art of Computer Programming</source>
          <target state="translated">计算机编程的艺术</target>
        </trans-unit>
        <trans-unit id="e6a71a9e8ae70e8f61fd0c5d80d8189dbf3cf681" translate="yes" xml:space="preserve">
          <source>The AutoSplit and &lt;b&gt;AutoLoader&lt;/b&gt; modules automate the creation of forward declarations. The AutoSplit module creates an 'index' file containing forward declarations of all the AutoSplit subroutines. When the AutoLoader module is 'use'd it loads these declarations into its callers package.</source>
          <target state="translated">AutoSplit和&lt;b&gt;AutoLoader&lt;/b&gt;模块可自动创建前向声明。AutoSplit模块创建一个&amp;ldquo;索引&amp;rdquo;文件，其中包含所有AutoSplit子例程的前向声明。当&amp;ldquo;使用&amp;rdquo; AutoLoader模块时，它将这些声明加载到其调用程序包中。</target>
        </trans-unit>
        <trans-unit id="547ca45f60093a7fb15745aaa1976d8399cc0918" translate="yes" xml:space="preserve">
          <source>The B-determined class of the OP, in all caps.</source>
          <target state="translated">上文中的B定类,大写的。</target>
        </trans-unit>
        <trans-unit id="fad9fed447a0e7963d894765232a4acc4b663de9" translate="yes" xml:space="preserve">
          <source>The B::Xref module is used to generate a cross reference listing of all definitions and uses of variables, subroutines and formats in a Perl program. It is implemented as a backend for the Perl compiler.</source>
          <target state="translated">B::Xref 模块用于生成一个交叉引用列表,列出 Perl 程序中所有变量、子程序和格式的定义和用法。它是作为Perl编译器的后端实现的。</target>
        </trans-unit>
        <trans-unit id="8026a52e63f99adbefc0e084618e1f479fd95572" translate="yes" xml:space="preserve">
          <source>The BITS mode (&quot;0&quot;) interprets the contents of</source>
          <target state="translated">BITS模式(&quot;0&quot;)解释了以下内容</target>
        </trans-unit>
        <trans-unit id="ba88dd1d9005852348725927325ddcf383a69f7c" translate="yes" xml:space="preserve">
          <source>The BLOCK construct can be used to emulate case structures.</source>
          <target state="translated">BLOCK结构可以用来模拟案例结构。</target>
        </trans-unit>
        <trans-unit id="6dfef44d3b22aafe27912b6966e2a486d9c0c14d" translate="yes" xml:space="preserve">
          <source>The BOOT: Keyword</source>
          <target state="translated">的BOOT。关键字</target>
        </trans-unit>
        <trans-unit id="d4a87a13d39a77a50a617134650c09dd8bdc8e3b" translate="yes" xml:space="preserve">
          <source>The BOOT: keyword is used to add code to the extension's bootstrap function. The bootstrap function is generated by the &lt;b&gt;xsubpp&lt;/b&gt; compiler and normally holds the statements necessary to register any XSUBs with Perl. With the BOOT: keyword the programmer can tell the compiler to add extra statements to the bootstrap function.</source>
          <target state="translated">BOOT：关键字用于将代码添加到扩展的引导功能。引导程序功能由&lt;b&gt;xsubpp&lt;/b&gt;编译器生成，并且通常包含向Perl注册任何&lt;b&gt;XSUB&lt;/b&gt;所必需的语句。使用BOOT：关键字，程序员可以告诉编译器向启动函数添加额外的语句。</target>
        </trans-unit>
        <trans-unit id="ad4a573da9545ff1a8eab5e0d4f5f08622036178" translate="yes" xml:space="preserve">
          <source>The BTREE file type optionally allows a single key to be associated with an arbitrary number of values. This option is enabled by setting the flags element of &lt;code&gt;$DB_BTREE&lt;/code&gt; to R_DUP when creating the database.</source>
          <target state="translated">BTREE文件类型可选地允许单个键与任意数量的值相关联。通过在创建数据库时将 &lt;code&gt;$DB_BTREE&lt;/code&gt; 的flags元素设置为R_DUP来启用此选项。</target>
        </trans-unit>
        <trans-unit id="4a8451f6eedb6a6056c8ac828a203a8cf8bdc79c" translate="yes" xml:space="preserve">
          <source>The BTREE interface has a feature which allows partial keys to be matched. This functionality is</source>
          <target state="translated">BTREE接口有一个功能,允许匹配部分密钥。这个功能是</target>
        </trans-unit>
        <trans-unit id="19350bba9c33f125fd021dceab5ff7633dce372c" translate="yes" xml:space="preserve">
          <source>The BUILD and INSTALL steps are identical to those for Unix. Some modules generate Makefiles that work better with GNU make, which is available from &lt;a href=&quot;http://www.mks.com/s390/gnu/&quot;&gt;http://www.mks.com/s390/gnu/&lt;/a&gt;</source>
          <target state="translated">BUILD和INSTALL步骤与Unix相同。某些模块会生成与GNU make更好地配合使用的Makefile，可从&lt;a href=&quot;http://www.mks.com/s390/gnu/&quot;&gt;http://www.mks.com/s390/gnu/&lt;/a&gt;获得。</target>
        </trans-unit>
        <trans-unit id="06987733f8223bbe1dde5201da803a816622002c" translate="yes" xml:space="preserve">
          <source>The Basic Principle</source>
          <target state="translated">基本原则</target>
        </trans-unit>
        <trans-unit id="a093f7952b1838c4dd6aeda28ea5e1fc38030960" translate="yes" xml:space="preserve">
          <source>The Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afdc8705dda034aabf31fc65386bddfb61c3e95b" translate="yes" xml:space="preserve">
          <source>The Benchmark module encapsulates a number of routines to help you figure out how long it takes to execute some code.</source>
          <target state="translated">Benchmark模块封装了一些例程,帮助你计算出执行一些代码所需的时间。</target>
        </trans-unit>
        <trans-unit id="869885b765935f032e1e45165248683c4d860661" translate="yes" xml:space="preserve">
          <source>The Berkeley DB 4.1.25 has been tested with Tru64 V5.1A and found to work. The latest Berkeley DB can be found from &lt;a href=&quot;http://www.sleepycat.com&quot;&gt;http://www.sleepycat.com&lt;/a&gt;.</source>
          <target state="translated">Berkeley DB 4.1.25已通过Tru64 V5.1A进行了测试，并且可以正常工作。可以从&lt;a href=&quot;http://www.sleepycat.com&quot;&gt;http://www.sleepycat.com&lt;/a&gt;找到最新的Berkeley DB 。</target>
        </trans-unit>
        <trans-unit id="1425da38b0881b20e7239aedd72aa0c3d5db10c1" translate="yes" xml:space="preserve">
          <source>The Bessel function of the first kind of the order zero.</source>
          <target state="translated">阶为零的第一种贝塞尔函数。</target>
        </trans-unit>
        <trans-unit id="2488bfae0d46b9e4a8c30cc5e6937e82c99c48ea" translate="yes" xml:space="preserve">
          <source>The Bignum mailing list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95802efdaca31b27a14913bfe1089183b4ec8875" translate="yes" xml:space="preserve">
          <source>The C API for the backtrace is as follows:</source>
          <target state="translated">回溯的C API如下。</target>
        </trans-unit>
        <trans-unit id="89f382052ffa523340ba739809ce6ebbf65c53dd" translate="yes" xml:space="preserve">
          <source>The C array of a padlist, containing the pads. Only subscript it with numbers &amp;gt;= 1, as the 0th entry is not guaranteed to remain usable.</source>
          <target state="translated">填充列表的C数组，包含填充。仅用数字&amp;gt; = 1下标，因为不能保证第0个条目保持可用。</target>
        </trans-unit>
        <trans-unit id="9d9a695f29b97a18f6840062c9b13365fc424c17" translate="yes" xml:space="preserve">
          <source>The C array of pad entries.</source>
          <target state="translated">C数组的焊盘条目。</target>
        </trans-unit>
        <trans-unit id="82cdebaae9f3b94b2c40ce92be9ab7f40abcb4e4" translate="yes" xml:space="preserve">
          <source>The C array of pad names.</source>
          <target state="translated">垫名的C数组。</target>
        </trans-unit>
        <trans-unit id="66ccfe4f23602b2282c83a4407f8d3eb55b4ce47" translate="yes" xml:space="preserve">
          <source>The C code asks for:</source>
          <target state="translated">C代码要求:</target>
        </trans-unit>
        <trans-unit id="1755acfd3f32daf3e3ba7fab9fbb3582e6e7bc1c" translate="yes" xml:space="preserve">
          <source>The C function required to call</source>
          <target state="translated">调用所需的C函数</target>
        </trans-unit>
        <trans-unit id="593e19336c2ea1e5b6f3c47a320c97c9b260fd7c" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, wrapped if necessary, to ensure that it will return the length of the string written to the buffer. Only rare pre-ANSI systems need the wrapper function - usually this is a direct call to &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">C库 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; ，如果有必要包装，以确保它将返回写入缓冲区的字符串的长度。只有罕见的pre-ANSI系统需要包装函数-通常这是对 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 的直接调用。</target>
        </trans-unit>
        <trans-unit id="9f593f0f7e2f42e16decd49842d3eba832ba134e" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;snprintf&lt;/code&gt; functionality, if available and standards-compliant (uses &lt;code&gt;vsnprintf&lt;/code&gt; , actually). However, if the &lt;code&gt;vsnprintf&lt;/code&gt; is not available, will unfortunately use the unsafe &lt;code&gt;vsprintf&lt;/code&gt; which can overrun the buffer (there is an overrun check, but that may be too late). Consider using &lt;code&gt;sv_vcatpvf&lt;/code&gt; instead, or getting &lt;code&gt;vsnprintf&lt;/code&gt; .</source>
          <target state="translated">C库 &lt;code&gt;snprintf&lt;/code&gt; 功能（如果可用）并且符合标准（实际上使用 &lt;code&gt;vsnprintf&lt;/code&gt; ）。但是，如果 &lt;code&gt;vsnprintf&lt;/code&gt; 不可用，将不幸地使用不安全的 &lt;code&gt;vsprintf&lt;/code&gt; ，它可能会使缓冲区溢出（存在溢出检查，但这可能为时已晚）。考虑改用 &lt;code&gt;sv_vcatpvf&lt;/code&gt; 或获取 &lt;code&gt;vsnprintf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0e1b6d35f4716db28bfc47e17c382e52671433d" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;snprintf&lt;/code&gt; functionality, if available and standards-compliant (uses &lt;code&gt;vsnprintf&lt;/code&gt;, actually). However, if the &lt;code&gt;vsnprintf&lt;/code&gt; is not available, will unfortunately use the unsafe &lt;code&gt;vsprintf&lt;/code&gt; which can overrun the buffer (there is an overrun check, but that may be too late). Consider using &lt;code&gt;sv_vcatpvf&lt;/code&gt; instead, or getting &lt;code&gt;vsnprintf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661ddafc70911db04cf396a10417bb22f9c9013f" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;strlcat&lt;/code&gt; if available, or a Perl implementation of it. This operates on C &lt;code&gt;NUL&lt;/code&gt; -terminated strings.</source>
          <target state="translated">C库 &lt;code&gt;strlcat&lt;/code&gt; (如果可用）或其Perl实现。这对C &lt;code&gt;NUL&lt;/code&gt; 终止的字符串起作用。</target>
        </trans-unit>
        <trans-unit id="15d5b3af47acfb54f6e568de8eff6bc75bdb63f0" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;strlcat&lt;/code&gt; if available, or a Perl implementation of it. This operates on C &lt;code&gt;NUL&lt;/code&gt;-terminated strings.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
