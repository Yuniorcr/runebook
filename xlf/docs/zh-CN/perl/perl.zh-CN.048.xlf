<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="261136bd75aafd5cdd3130fb700c6549b50d82b1" translate="yes" xml:space="preserve">
          <source>Usage might be something like:</source>
          <target state="translated">用法可能是这样的。</target>
        </trans-unit>
        <trans-unit id="1d4d43cc6f3a833e0340a0d1794b6d7b9958657e" translate="yes" xml:space="preserve">
          <source>Use</source>
          <target state="translated">Use</target>
        </trans-unit>
        <trans-unit id="82df0013720cd7586b2bc95bd024b2fab925070f" translate="yes" xml:space="preserve">
          <source>Use &quot;opaque&quot; data type for the C types matched by the regular expression, even if these types are &lt;code&gt;typedef&lt;/code&gt; -equivalent to types from typemaps. Should not be used without &lt;b&gt;-x&lt;/b&gt;.</source>
          <target state="translated">对于正则表达式匹配的C类型，请使用&amp;ldquo;不透明&amp;rdquo;数据类型，即使这些类型与typemap 中的 &lt;code&gt;typedef&lt;/code&gt; 是等效的也是如此。不带&lt;b&gt;-x&lt;/b&gt;不应使用。</target>
        </trans-unit>
        <trans-unit id="3c21be167d639b35ddaa57a08912b97d5e9dff41" translate="yes" xml:space="preserve">
          <source>Use &quot;tie&quot; to open the database.</source>
          <target state="translated">使用 &quot;领带 &quot;打开数据库。</target>
        </trans-unit>
        <trans-unit id="4c6d07e8046e85c144f5081da5bd8baf9030e3a5" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Strip&quot;&gt;HTML::Strip&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::FormatText&quot;&gt;HTML::FormatText&lt;/a&gt; which not only removes HTML but also attempts to do a little simple formatting of the resulting plain text.</source>
          <target state="translated">使用&lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Strip&quot;&gt;HTML :: Strip&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/HTML::FormatText&quot;&gt;HTML :: FormatText&lt;/a&gt;不仅可以删除HTML，还可以尝试对生成的纯文本进行一些简单的格式化。</target>
        </trans-unit>
        <trans-unit id="a5b53467807b9027de0ba1ae32437de79640c9fd" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; (part of the standard Perl distribution):</source>
          <target state="translated">使用&lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt;（标准Perl发行版的一部分）：</target>
        </trans-unit>
        <trans-unit id="87276cc5955780242b6240d9ad22eaa36930d92c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;:alias&lt;/code&gt; to give your own lexically scoped nicknames to existing characters, or even to give unnamed private-use characters useful names.</source>
          <target state="translated">使用 &lt;code&gt;:alias&lt;/code&gt; 可以为现有字符提供自己的词法范围昵称，甚至可以为未命名的私人字符提供有用的名称。</target>
        </trans-unit>
        <trans-unit id="fdf71fcf7dcb9c3fbc3fc7c52735a70671018192" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;:encoding(ENCODING)&lt;/code&gt; either in open() or binmode() to install a layer that transparently does character set and encoding transformations, for example from Shift-JIS to Unicode. Note that under &lt;code&gt;stdio&lt;/code&gt; an &lt;code&gt;:encoding&lt;/code&gt; also enables &lt;code&gt;:utf8&lt;/code&gt; . See &lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO::encoding&lt;/a&gt; for more information.</source>
          <target state="translated">在open（）或binmode（）中使用 &lt;code&gt;:encoding(ENCODING)&lt;/code&gt; 来安装透明执行字符集和编码转换（例如从Shift-JIS到Unicode）的图层。请注意，在 &lt;code&gt;stdio&lt;/code&gt; 下， &lt;code&gt;:encoding&lt;/code&gt; 也可以启用 &lt;code&gt;:utf8&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO :: encoding&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b32751627ad0f538a9c781523741b9c9689a81e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;:via(MODULE)&lt;/code&gt; either in open() or binmode() to install a layer that does whatever transformation (for example compression / decompression, encryption / decryption) to the filehandle. See &lt;a href=&quot;perlio/via&quot;&gt;PerlIO::via&lt;/a&gt; for more information.</source>
          <target state="translated">在open（）或binmode（）中使用 &lt;code&gt;:via(MODULE)&lt;/code&gt; 来安装对文件句柄进行任何转换（例如压缩/解压缩，加密/解密）的层。有关更多信息，请参见&lt;a href=&quot;perlio/via&quot;&gt;PerlIO :: via&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c35f727c8e06fe9ff695531c994a06e6d32367e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; for local variables whenever you can get away with it (but see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for where you can't). Using &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; actually gives a local value to a global variable, which leaves you open to unforeseen side-effects of dynamic scoping.</source>
          <target state="translated">只要可以使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; 就可以使用局部变量（但是请参见&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;以了解无法使用的地方）。使用 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; 实际上为全局变量提供了一个局部值，这使您对动态作用域的意外影响敞开了怀抱。</target>
        </trans-unit>
        <trans-unit id="c47d329f16fdbd745016d298559c2d16104952e0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt;, or else &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt; and the bitwise operations.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; ，或者使用 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt; 和按位运算。</target>
        </trans-unit>
        <trans-unit id="e7d6c1efbb4fe6ed3d0e44682a7fdfcad4845a94" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; to go from several pieces of data to one fixed-width version; use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; to turn a fixed-width-format string into several pieces of data.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 将数个数据转换为一个固定宽度的版本；使用 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 将固定宽度格式的字符串转换成几段数据。</target>
        </trans-unit>
        <trans-unit id="8fbc052d865293ed23949ab2e7f416dfadd5a776" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse()&lt;/a&gt;&lt;/code&gt; in scalar context, as documented in &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;.</source>
          <target state="translated">如在&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;中所述，在标量上下文中使用 &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27ae995888d29f8142b3c2932bd24cab6ea87cf6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;@CARP_NOT&lt;/code&gt; , instead of &lt;code&gt;$Carp::CarpLevel&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;@CARP_NOT&lt;/code&gt; ，而不是 &lt;code&gt;$Carp::CarpLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92183967ac97249aea7bc977e218502508a51699" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;NDBM_File&lt;/code&gt; with the Perl built-in &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function to establish the connection between the variable and the file. The arguments to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; should be:</source>
          <target state="translated">将 &lt;code&gt;NDBM_File&lt;/code&gt; 与Perl内置的 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 函数一起使用，可以在变量和文件之间建立连接。 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 的参数应为：</target>
        </trans-unit>
        <trans-unit id="a39f53bf0801332ad81a8e20b727e708ddef3b6b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Role::Tiny&lt;/code&gt; with &lt;code&gt;Class::Accessor&lt;/code&gt; or &lt;code&gt;Class::Tiny&lt;/code&gt; if you find yourself considering multiple inheritance. If you go with &lt;code&gt;Moose&lt;/code&gt; , it comes with its own role implementation.</source>
          <target state="translated">使用 &lt;code&gt;Role::Tiny&lt;/code&gt; 用 &lt;code&gt;Class::Accessor&lt;/code&gt; 或 &lt;code&gt;Class::Tiny&lt;/code&gt; ，如果你发现自己考虑多重继承。如果您选择 &lt;code&gt;Moose&lt;/code&gt; ，它将带有自己的角色实现。</target>
        </trans-unit>
        <trans-unit id="0f06b5eddbf8d97d651f4831a1beb13b8718c8d6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;SDBM_File&lt;/code&gt; with the Perl built-in &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function to establish the connection between the variable and the file.</source>
          <target state="translated">将 &lt;code&gt;SDBM_File&lt;/code&gt; 与Perl内置的 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 函数一起使用，可以在变量和文件之间建立连接。</target>
        </trans-unit>
        <trans-unit id="dd5ddb92a2e87aa696e71c88822af794ba04ff5b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;SvPVbyte_nolen&lt;/code&gt; instead.</source>
          <target state="translated">请改用 &lt;code&gt;SvPVbyte_nolen&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5709fd5fee3c8f65a9f2b5ff4443b46d700ffd8b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;error&lt;/code&gt; to trap all that is reasonable (problems with permissions and the like), and let it die if things get out of hand. This is the safest course of action.</source>
          <target state="translated">使用 &lt;code&gt;error&lt;/code&gt; 来捕获所有合理的内容（权限问题等），如果事情失控，它会死掉。这是最安全的措施。</target>
        </trans-unit>
        <trans-unit id="a7ae97b4dc032127dbdf525b36f3287eea7a74cc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;for&lt;/code&gt; /&lt;code&gt;foreach&lt;/code&gt; :</source>
          <target state="translated">使用 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;foreach&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="42448f158fc4cf33aed96fb909d73152cfab8a01" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;sv_pos_b2u_flags&lt;/code&gt; in preference, which correctly handles strings longer than 2Gb.</source>
          <target state="translated">优先使用 &lt;code&gt;sv_pos_b2u_flags&lt;/code&gt; ，它可以正确处理长度超过2Gb的字符串。</target>
        </trans-unit>
        <trans-unit id="7227aee0b7448cf59bbacaf7f7fdbecd1aac240b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;sv_pos_u2b_flags&lt;/code&gt; in preference, which correctly handles strings longer than 2Gb.</source>
          <target state="translated">优先使用 &lt;code&gt;sv_pos_u2b_flags&lt;/code&gt; ，它可以正确处理长度超过2Gb的字符串。</target>
        </trans-unit>
        <trans-unit id="9174053d497c0bac4b0650a86818fe94eb1cad92" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;utf8::encode()&lt;/code&gt; instead.</source>
          <target state="translated">请改用 &lt;code&gt;utf8::encode()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e974bf00a2d723dec73908b097ca121c9409a8e4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;~pattern&lt;/code&gt; and &lt;code&gt;!pattern&lt;/code&gt; for positive and negative regexes.</source>
          <target state="translated">使用 &lt;code&gt;~pattern&lt;/code&gt; 和 &lt;code&gt;!pattern&lt;/code&gt; 的正面和负面的正则表达式。</target>
        </trans-unit>
        <trans-unit id="061b1dc7990493487dde420be8fe1d319fffab9e" translate="yes" xml:space="preserve">
          <source>Use CPAN::SQLite if available? (yes/no)?</source>
          <target state="translated">如果可用,请使用CPAN::SQLite?(是/否)?</target>
        </trans-unit>
        <trans-unit id="714325381beb635775804a746adac93cfa93686a" translate="yes" xml:space="preserve">
          <source>Use Internet-domain sockets when you want to do client-server communication that might extend to machines outside of your own system.</source>
          <target state="translated">当你想进行可能扩展到自己系统之外的机器的客户机-服务器通信时,请使用Internet域套接字。</target>
        </trans-unit>
        <trans-unit id="0b9b3669dfa437dd595e2562fc06d4aa9b5c2435" translate="yes" xml:space="preserve">
          <source>Use MM[SK] macros, and VMS command line for C compiler.</source>
          <target state="translated">使用MM[SK]宏,以及VMS命令行进行C编译。</target>
        </trans-unit>
        <trans-unit id="ea4874b782f37efa4adbe580d7fbd195de341f05" translate="yes" xml:space="preserve">
          <source>Use MM[SK] macros.</source>
          <target state="translated">使用MM[SK]宏。</target>
        </trans-unit>
        <trans-unit id="566b4db3c362df6b71e0ff5dee0038deb7684d52" translate="yes" xml:space="preserve">
          <source>Use MakeMaker's uninstalled version of a package</source>
          <target state="translated">使用MakeMaker的未安装版本的包。</target>
        </trans-unit>
        <trans-unit id="8e0e5dba70a90f698d3e0ca5e61baef285d0f01f" translate="yes" xml:space="preserve">
          <source>Use VMS Link command.</source>
          <target state="translated">使用VMS链接命令。</target>
        </trans-unit>
        <trans-unit id="280948ed6505d39690e8bfb21e155eff171d0ef1" translate="yes" xml:space="preserve">
          <source>Use VMS commands to manipulate object library.</source>
          <target state="translated">使用VMS命令来操作对象库。</target>
        </trans-unit>
        <trans-unit id="bda9ca770225246f2160551c7450fb9367f1b262" translate="yes" xml:space="preserve">
          <source>Use VMS file specification syntax and CLI commands to find and invoke Perl images.</source>
          <target state="translated">使用VMS文件规范语法和CLI命令来查找和调用Perl镜像。</target>
        </trans-unit>
        <trans-unit id="ede73fbf3b4744edf3efb586d91835b3d9ad9918" translate="yes" xml:space="preserve">
          <source>Use VMS syntax on command line. In particular, $(DEFINE) and $(PERL_INC) have been pulled into $(CCCMD). Also use MM[SK] macros.</source>
          <target state="translated">在命令行中使用VMS语法。特别是$(DEFINE)和$(PERL_INC)被拉到$(CCCMD)中。同时使用MM[SK]宏。</target>
        </trans-unit>
        <trans-unit id="691de1dabff4e93d09d661b351d70e27dc9a3c25" translate="yes" xml:space="preserve">
          <source>Use VMS-style syntax for files; it's cheaper to just do it directly here than to have the MM_Unix method call &lt;code&gt;catfile&lt;/code&gt; repeatedly. Also, if we have to rebuild Config.pm, use MM[SK] to do it.</source>
          <target state="translated">对文件使用VMS样式的语法；与直接让MM_Unix方法重复调用 &lt;code&gt;catfile&lt;/code&gt; 相比，直接在此处进行操作要便宜一些。另外，如果我们必须重建Config.pm，请使用MM [SK]来完成。</target>
        </trans-unit>
        <trans-unit id="21386b7269a32025e94fbc169460c22c01ed7e1f" translate="yes" xml:space="preserve">
          <source>Use a collator object to compare Unicode text by character instead of by codepoint.</source>
          <target state="translated">使用整理器对象按字符而不是按代码点来比较Unicode文本。</target>
        </trans-unit>
        <trans-unit id="af5688754fcfe001260b97f3d6228bac17ab8a5e" translate="yes" xml:space="preserve">
          <source>Use a command-line option, an environment variable, or else call &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; explicitly:</source>
          <target state="translated">使用命令行选项，环境变量，或显式调用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ba762ed342f4cf062ad179e99538aaf1e4c1ae60" translate="yes" xml:space="preserve">
          <source>Use a hash. Here's code to do both and more. It assumes that each element is unique in a given array:</source>
          <target state="translated">使用哈希。这里的代码可以做到这两点以及更多。它假设每个元素在给定数组中是唯一的。</target>
        </trans-unit>
        <trans-unit id="271eac68025544545b6b8cda21c48f10de3e2be3" translate="yes" xml:space="preserve">
          <source>Use a hash. When you think the words &quot;unique&quot; or &quot;duplicated&quot;, think &quot;hash keys&quot;.</source>
          <target state="translated">使用哈希键。当你想到 &quot;唯一 &quot;或 &quot;重复 &quot;这些词时,请想到 &quot;哈希键&quot;。</target>
        </trans-unit>
        <trans-unit id="fb4ec017e331a31a5b1abaea84089100f3dba15e" translate="yes" xml:space="preserve">
          <source>Use a sort helper function</source>
          <target state="translated">使用排序辅助功能</target>
        </trans-unit>
        <trans-unit id="f616a684cd386a4ea767461805601287970f5579" translate="yes" xml:space="preserve">
          <source>Use a tree format in which the minimum amount of space is used for the lines connecting nodes (one character in most cases). This squeezes out a few precious columns of screen real estate.</source>
          <target state="translated">使用树形格式,其中连接节点的行使用最少的空间(大多数情况下为一个字符)。这样可以挤出几列宝贵的屏幕空间。</target>
        </trans-unit>
        <trans-unit id="5882a02b6e19732df1aac03e7c042980b0e32ff8" translate="yes" xml:space="preserve">
          <source>Use a tree format that uses longer edges to separate OP nodes. This format tends to look better than the compact one, especially in ASCII, and is the default.</source>
          <target state="translated">使用树形格式,使用较长的边来分隔OP节点。这种格式往往比紧凑的格式更好看,特别是在ASCII中,而且是默认的。</target>
        </trans-unit>
        <trans-unit id="4b48f7ca244968605d46dde3055bd12f89577678" translate="yes" xml:space="preserve">
          <source>Use an alpha/beta style version number. Causes version number to be &quot;0.00_01&quot; unless &lt;b&gt;-v&lt;/b&gt; is specified.</source>
          <target state="translated">使用Alpha / Beta样式版本号。除非指定&lt;b&gt;-v，&lt;/b&gt;否则导致版本号为&amp;ldquo; 0.00_01&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="6134c36e04029ff2453cb542046305a1f937b7f5" translate="yes" xml:space="preserve">
          <source>Use an alternate output format that, among other things, uses a different heading style and marks &lt;code&gt;=item&lt;/code&gt; entries with a colon in the left margin.</source>
          <target state="translated">使用另一种输出格式，该格式除其他外使用一种不同的标题样式，并在左边距中用冒号标记 &lt;code&gt;=item&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="dcdeb0b163229c6ff03de5a0cdb9e6a57a7ea002" translate="yes" xml:space="preserve">
          <source>Use an index if it is present. The &lt;b&gt;-X&lt;/b&gt; option looks for an entry whose basename matches the name given on the command line in the file &lt;code&gt;$Config{archlib}/pod.idx&lt;/code&gt; . The</source>
          <target state="translated">使用索引（如果存在）。该&lt;b&gt;-X&lt;/b&gt;选项寻找匹配的基本名在文件中的命令行上指定的名称相匹配的条目 &lt;code&gt;$Config{archlib}/pod.idx&lt;/code&gt; 。的</target>
        </trans-unit>
        <trans-unit id="ae7e5fe5c728700cd50b3c52c6ee63480235da37" translate="yes" xml:space="preserve">
          <source>Use as separator a character which is legal in a VMS-syntax file name.</source>
          <target state="translated">在VMS-syntax文件名中使用合法的字符作为分隔符。</target>
        </trans-unit>
        <trans-unit id="672a1c76642ee42c51ebfa65fd5a5d1a95399678" translate="yes" xml:space="preserve">
          <source>Use autosplit so little used or newly added functions won't be a burden to programs that don't use them. Add test functions to the module after __END__ either using AutoSplit or by saying:</source>
          <target state="translated">使用autosplit,这样很少使用或新添加的函数就不会成为不使用它们的程序的负担。在__END__后添加测试函数到模块中,可以使用AutoSplit,也可以说。</target>
        </trans-unit>
        <trans-unit id="317a05001ebb0c43c5b2e6eaa3b070114b0ab11b" translate="yes" xml:space="preserve">
          <source>Use blessed references. Use the two argument form of bless to bless into the class name given as the first parameter of the constructor, e.g.,:</source>
          <target state="translated">使用祝福的引用。使用祝福的两个参数形式将祝福到作为构造函数的第一个参数给出的类名中,例如,。</target>
        </trans-unit>
        <trans-unit id="ec95e04beca28ff76c489858d434dba58b46f4b7" translate="yes" xml:space="preserve">
          <source>Use both global and lexical variables.</source>
          <target state="translated">同时使用全局变量和词汇变量。</target>
        </trans-unit>
        <trans-unit id="3ec0b24d1442368e951d28938a31c4007d000691" translate="yes" xml:space="preserve">
          <source>Use formatting conventions in which the name of each OP, rather than being written out in full, is represented by a one- or two-character abbreviation. This is mainly a joke.</source>
          <target state="translated">使用格式惯例,每个OP的名字,不是全写出来,而是用一个或两个字符的缩写来表示。这主要是一个笑话。</target>
        </trans-unit>
        <trans-unit id="32e0435d286f4e0f5dea4e605f6ba74b7a19693a" translate="yes" xml:space="preserve">
          <source>Use formatting conventions read from the environment variables &lt;code&gt;B_CONCISE_FORMAT&lt;/code&gt; , &lt;code&gt;B_CONCISE_GOTO_FORMAT&lt;/code&gt; , and &lt;code&gt;B_CONCISE_TREE_FORMAT&lt;/code&gt; .</source>
          <target state="translated">使用从环境变量 &lt;code&gt;B_CONCISE_FORMAT&lt;/code&gt; ， &lt;code&gt;B_CONCISE_GOTO_FORMAT&lt;/code&gt; 和 &lt;code&gt;B_CONCISE_TREE_FORMAT&lt;/code&gt; 中读取的格式约定。</target>
        </trans-unit>
        <trans-unit id="4fae2a54363441130a92de76cae86f65e4405daf" translate="yes" xml:space="preserve">
          <source>Use formatting conventions reminiscent of &lt;b&gt;B::Debug&lt;/b&gt;; these aren't very concise at all.</source>
          <target state="translated">使用格式化约定，使人联想到&lt;b&gt;B :: Debug&lt;/b&gt; ; 这些都不是很简洁。</target>
        </trans-unit>
        <trans-unit id="60e51473a2aeb572e34290de332f54db3103274f" translate="yes" xml:space="preserve">
          <source>Use formatting conventions that emulate the output of &lt;b&gt;B::Terse&lt;/b&gt;. The basic mode is almost indistinguishable from the real &lt;b&gt;B::Terse&lt;/b&gt;, and the exec mode looks very similar, but is in a more logical order and lacks curly brackets. &lt;b&gt;B::Terse&lt;/b&gt; doesn't have a tree mode, so the tree mode is only vaguely reminiscent of &lt;b&gt;B::Terse&lt;/b&gt;.</source>
          <target state="translated">使用模拟&lt;b&gt;B :: Terse&lt;/b&gt;输出的格式约定。基本模式与真正的&lt;b&gt;B :: Terse&lt;/b&gt;几乎没有区别，而exec模式看起来非常相似，但顺序更合逻辑且没有花括号。&lt;b&gt;B :: Terse&lt;/b&gt;没有树形模式，因此树形模式仅隐约让人联想到&lt;b&gt;B :: Terse&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="05e7e7257def62f44171c1ab5e1ea5739af490a1" translate="yes" xml:space="preserve">
          <source>Use grok_atoUV() instead. atoi() has ill-defined behavior on overflows, and cannot be used for incremental parsing. It is also affected by locale, which is bad.</source>
          <target state="translated">atoi()在溢出时有定义不清的行为,不能用于增量解析。它还受到locale的影响,这很糟糕。</target>
        </trans-unit>
        <trans-unit id="49bfe15faf704565402bc75b321564e7f1a0847e" translate="yes" xml:space="preserve">
          <source>Use grok_atoUV() instead. strtol() or strtoul() (or their IV/UV-friendly macro disguises, Strtol() and Strtoul(), or Atol() and Atoul() are affected by locale, which is bad.</source>
          <target state="translated">strtol()或strtoul()(或它们的IV/UV友好的宏伪装,Strtol()和Strtoul(),或Atol()和Atoul()会受到locale的影响,这是不好的。</target>
        </trans-unit>
        <trans-unit id="fec2179657e1b299044343e0b89c5b33f2055639" translate="yes" xml:space="preserve">
          <source>Use here documents instead of repeated &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; statements.</source>
          <target state="translated">使用此处文档代替重复的 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="7408313f5feae22d66298e9df35a5c92afed0d81" translate="yes" xml:space="preserve">
          <source>Use integer arithmetic instead of floating point</source>
          <target state="translated">使用整数运算而不是浮点运算。</target>
        </trans-unit>
        <trans-unit id="4a2d0c065aebe88058e7899fe2b03390f5fd9ac8" translate="yes" xml:space="preserve">
          <source>Use it as follows:</source>
          <target state="translated">使用方法如下:</target>
        </trans-unit>
        <trans-unit id="0f2153ef63f7f49f92d87613b8e6086727534be7" translate="yes" xml:space="preserve">
          <source>Use mkstemp() instead.</source>
          <target state="translated">使用mkstemp()代替。</target>
        </trans-unit>
        <trans-unit id="9d215af52eba1c24168d3668f703076a6c44c6c8" translate="yes" xml:space="preserve">
          <source>Use mstat() function to emit a memory state statistic to the terminal. For more information on the format of output of mstat() see &lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;Using $ENV{PERL_DEBUG_MSTATS} in perldebguts&lt;/a&gt;.</source>
          <target state="translated">使用mstat（）函数向终端发出内存状态统计信息。有关mstat（）输出格式的更多信息，请参见&lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;在perldebguts中使用$ ENV {PERL_DEBUG_MSTATS}&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="531c130b925ffd3120eb898dd244351239e437cf" translate="yes" xml:space="preserve">
          <source>Use my_strlcpy() and my_strlcat() instead: they either use the native implementation, or Perl's own implementation (borrowed from the public domain implementation of INN).</source>
          <target state="translated">使用my_strlcpy()和my_strlcat()来代替:它们要么使用本机实现,要么使用Perl自己的实现(借用INN的公有领域实现)。</target>
        </trans-unit>
        <trans-unit id="2c9671db7475e8358c84b51b41af26939a79a05c" translate="yes" xml:space="preserve">
          <source>Use named parameters (a hash or hashref) when there are more than two parameters</source>
          <target state="translated">当有两个以上的参数时,使用命名参数(哈希或哈希夫)。</target>
        </trans-unit>
        <trans-unit id="6b1ab005a876449dcff824693329635ee0415484" translate="yes" xml:space="preserve">
          <source>Use named parameters. It's easier to use a hash like this:</source>
          <target state="translated">使用命名参数。使用这样的哈希更容易。</target>
        </trans-unit>
        <trans-unit id="a7996c874ba5c6e6417be6c43ab584f3aaff6022" translate="yes" xml:space="preserve">
          <source>Use nice English (or awk) names for ugly punctuation variables</source>
          <target state="translated">为丑陋的标点符号变量起一个好听的英文(或awk)名字。</target>
        </trans-unit>
        <trans-unit id="8d5397d217e6f86d4205c68445ae6f732da49e78" translate="yes" xml:space="preserve">
          <source>Use non-standard idioms (otherwise you are not testing TIMTOWTDI).</source>
          <target state="translated">使用非标准的成语(否则就不是在测试TIMTOWTDI)。</target>
        </trans-unit>
        <trans-unit id="0f0cda525ac86ed2eeaa7f4035a68ab00df2e040" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;/x&lt;/code&gt; means that if you want real whitespace or &lt;code&gt;#&lt;/code&gt; characters in the pattern (outside a bracketed character class, which is unaffected by &lt;code&gt;/x&lt;/code&gt;), then you'll either have to escape them (using backslashes or &lt;code&gt;\Q...\E&lt;/code&gt; ) or encode them using octal, hex, or &lt;code&gt;\N{}&lt;/code&gt; escapes. It is ineffective to try to continue a comment onto the next line by escaping the &lt;code&gt;\n&lt;/code&gt; with a backslash or &lt;code&gt;\Q&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;/x&lt;/code&gt; 意味着如果您希望模式中包含真实的空格或 &lt;code&gt;#&lt;/code&gt; 个字符（在括号字符类之外，不受 &lt;code&gt;/x&lt;/code&gt; 的影响），则必须将其转义（使用反斜杠或 &lt;code&gt;\Q...\E&lt;/code&gt; ）或使用八进制，十六进制或 &lt;code&gt;\N{}&lt;/code&gt; 转义对其进行编码。尝试通过用反斜杠或 &lt;code&gt;\Q&lt;/code&gt; 来转义 &lt;code&gt;\n&lt;/code&gt; 来继续对下一行进行注释是无效的。</target>
        </trans-unit>
        <trans-unit id="1cbbacbfb5cc1cd370b8cd67026b2e577274d54c" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; on aggregates (hashes and arrays) is deprecated. It used to report whether memory for that aggregate had ever been allocated. This behavior may disappear in future versions of Perl. You should instead use a simple test for size:</source>
          <target state="translated">使用的 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 上聚集体（散列和阵列）被弃用。它用来报告是否为该聚合分配了内存。在以后的Perl版本中，这种现象可能会消失。您应该改为使用简单的尺寸测试：</target>
        </trans-unit>
        <trans-unit id="c575003ac8ed97c3c8c499c8985b645cc965dd9e" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; on aggregates (hashes and arrays) is deprecated. It used to report whether memory for that aggregate had ever been allocated. This behavior may disappear in future versions of Perl. You should instead use a simple test for size:</source>
          <target state="translated">使用的 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 上聚集体（散列和阵列）被弃用。它用来报告是否为该聚合分配了内存。在以后的Perl版本中，这种现象可能会消失。您应该改为使用简单的尺寸测试：</target>
        </trans-unit>
        <trans-unit id="a1452256e006f48ab16db831ff1d2bc55b7b495f" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; to jump into a construct is deprecated and will issue a warning. Even then, it may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away.</source>
          <target state="translated">不建议使用 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 跳入构造，并将发出警告。即使这样，它也可能不会被用于需要初始化的任何构造中，例如子例程或 &lt;code&gt;foreach&lt;/code&gt; 循环。也不能将其用于经过优化的结构。</target>
        </trans-unit>
        <trans-unit id="5aa03266aa6d88c654f206267c8022d408e9c245" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; to jump into a construct is deprecated and will issue a warning. Even then, it may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away.</source>
          <target state="translated">不建议使用 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 跳入构造，并将发出警告。即使这样，它也可能不会被用于需要初始化的任何构造中，例如子例程或 &lt;code&gt;foreach&lt;/code&gt; 循环。也不能将其用于经过优化的结构。</target>
        </trans-unit>
        <trans-unit id="0ce1975659a74600b8f5d10e727a0e482e0ccb5e" translate="yes" xml:space="preserve">
          <source>Use of a single identifier, prefixed with &lt;code&gt;*&lt;/code&gt; . For example, &lt;code&gt;*name&lt;/code&gt; stands for any or all of &lt;code&gt;$name&lt;/code&gt; , &lt;code&gt;@name&lt;/code&gt; , &lt;code&gt;%name&lt;/code&gt; , &lt;code&gt;&amp;amp;name&lt;/code&gt; , or just &lt;code&gt;name&lt;/code&gt; . How you use it determines whether it is interpreted as all or only one of them. See &amp;ldquo;Typeglobs and Filehandles&amp;rdquo; in Camel chapter 2, &amp;ldquo;Bits and Pieces&amp;rdquo;.</source>
          <target state="translated">使用带有 &lt;code&gt;*&lt;/code&gt; 前缀的单个标识符。例如， &lt;code&gt;*name&lt;/code&gt; 代表任何或全部的 &lt;code&gt;$name&lt;/code&gt; ， &lt;code&gt;@name&lt;/code&gt; ， &lt;code&gt;%name&lt;/code&gt; ， &lt;code&gt;&amp;amp;name&lt;/code&gt; ，或只是 &lt;code&gt;name&lt;/code&gt; 。如何使用它确定将其解释为全部还是仅其中之一。请参见骆驼第2章&amp;ldquo;零碎&amp;rdquo;中的&amp;ldquo; Typeglob和文件句柄&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="79921a859879ed1277d82b4cc80975d8402d69d3" translate="yes" xml:space="preserve">
          <source>Use of a subroutine call, rather than a subroutine name, as an argument to exists() is an error.</source>
          <target state="translated">使用子程序调用,而不是子程序名称作为exist()的参数,是一个错误。</target>
        </trans-unit>
        <trans-unit id="86136067e812367f102852e0f2a4131e0073483c" translate="yes" xml:space="preserve">
          <source>Use of any other character following the &lt;code&gt;&quot;c&quot;&lt;/code&gt; besides those listed above is discouraged, and as of Perl v5.20, the only characters actually allowed are the printable ASCII ones, minus the left brace &lt;code&gt;&quot;{&quot;&lt;/code&gt; . What happens for any of the allowed other characters is that the value is derived by xor'ing with the seventh bit, which is 64, and a warning raised if enabled. Using the non-allowed characters generates a fatal error.</source>
          <target state="translated">除上面列出的字符外，不建议在 &lt;code&gt;&quot;c&quot;&lt;/code&gt; 之后使用任何其他字符，从Perl v5.20开始，实际允许的字符是可打印的ASCII字符，减去左括号 &lt;code&gt;&quot;{&quot;&lt;/code&gt; 。对于任何允许的其他字符，发生的情况是该值是通过与第七位（即64）进行异或运算得出的，如果启用，则会发出警告。使用不允许的字符会产生致命错误。</target>
        </trans-unit>
        <trans-unit id="2d322945b4e21e9e3602bafb5e497ecc98176eed" translate="yes" xml:space="preserve">
          <source>Use of each publically accessible method or subroutine, including parameters and return values</source>
          <target state="translated">使用每个可公开访问的方法或子程序,包括参数和返回值。</target>
        </trans-unit>
        <trans-unit id="c4576ebd26dc37f362b412c956b1df320b83b3af" translate="yes" xml:space="preserve">
          <source>Use of epoch seconds</source>
          <target state="translated">纪元秒的使用</target>
        </trans-unit>
        <trans-unit id="1731aaf31968c5fdd9480f64d745beb19858cc51" translate="yes" xml:space="preserve">
          <source>Use of interval timers may interfere with &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;usleep()&lt;/code&gt; . In standard-speak the &quot;interaction is unspecified&quot;, which means that</source>
          <target state="translated">使用间隔计时器可能会干扰 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;usleep()&lt;/code&gt; 。用标准语言来说，&amp;ldquo;互动是不确定的&amp;rdquo;，这意味着</target>
        </trans-unit>
        <trans-unit id="1a808d3a7e8e48ea8bc89247be3129db920de8bf" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;normalization&lt;/code&gt; parameter requires the &lt;b&gt;Unicode::Normalize&lt;/b&gt; module (see &lt;a href=&quot;normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;).</source>
          <target state="translated">使用 &lt;code&gt;normalization&lt;/code&gt; 参数需要&lt;b&gt;Unicode :: Normalize&lt;/b&gt;模块（请参见&lt;a href=&quot;normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0f49c2ebf95d755e5a6d2e5df09c73558f210f71" translate="yes" xml:space="preserve">
          <source>Use one of</source>
          <target state="translated">使用其中一种</target>
        </trans-unit>
        <trans-unit id="5c06bf7bc66bd95d8dadea94a66d540da42d6175" translate="yes" xml:space="preserve">
          <source>Use one of the RPC modules( &lt;a href=&quot;https://metacpan.org/search?q=RPC&quot;&gt;https://metacpan.org/search?q=RPC&lt;/a&gt; ).</source>
          <target state="translated">使用RPC模块之一（&lt;a href=&quot;https://metacpan.org/search?q=RPC&quot;&gt;https://metacpan.org/search?q=RPC&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e43df0045591deb1920c698e1e06d9540206f44c" translate="yes" xml:space="preserve">
          <source>Use only modes 'rb' or 'wb' or /wb[1-9]/.</source>
          <target state="translated">只能使用模式'rb'或'wb'或/wb[1-9]/。</target>
        </trans-unit>
        <trans-unit id="852a3fb75c58ea9ab6aee1d984501d31575dbe43" translate="yes" xml:space="preserve">
          <source>Use or avoid POSIX locales for built-in operations</source>
          <target state="translated">使用或避免使用内置操作的POSIX语言。</target>
        </trans-unit>
        <trans-unit id="42549f09d2d3209d758990ebfc780be7cd9d6789" translate="yes" xml:space="preserve">
          <source>Use references as hash keys</source>
          <target state="translated">使用引用作为哈希键</target>
        </trans-unit>
        <trans-unit id="24db154be0d68fd92b28271f4ccc60a8152b9d53" translate="yes" xml:space="preserve">
          <source>Use subroutine address instead of name when reporting.</source>
          <target state="translated">报告时用子程序地址代替名称。</target>
        </trans-unit>
        <trans-unit id="e65336030d621ad236216bbd262ac0c17be3ed80" translate="yes" xml:space="preserve">
          <source>Use tabs for each 8 columns of indent. The default is to use only spaces. For instance, if the style options are &lt;b&gt;-si4T&lt;/b&gt;, a line that's indented 3 times will be preceded by one tab and four spaces; if the options were &lt;b&gt;-si8T&lt;/b&gt;, the same line would be preceded by three tabs.</source>
          <target state="translated">每8列缩进使用制表符。默认设置为仅使用空格。例如，如果样式选项为&lt;b&gt;-si4T&lt;/b&gt;，则缩进3行的行之前将带有一个制表符和四个空格；如果选项为&lt;b&gt;-si8T&lt;/b&gt;，则同一行之前将带有三个选项卡。</target>
        </trans-unit>
        <trans-unit id="900e9cc0a9414f47ad3c3cf6cec86c687d5c9a3b" translate="yes" xml:space="preserve">
          <source>Use the &amp;lt;&amp;gt; (&lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt;) operator, documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. Versions of Perl older than 5.6 require that you have a shell installed that groks tildes. Later versions of Perl have this feature built in. The &lt;a href=&quot;http://search.cpan.org/perldoc/File::KGlob&quot;&gt;File::KGlob&lt;/a&gt; module (available from CPAN) gives more portable glob functionality.</source>
          <target state="translated">使用在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;记录的&amp;lt;&amp;gt;（ &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; ）运算符。低于5.6的Perl版本要求您安装的外壳会出现波浪号。更高版本的Perl内置了此功能&lt;a href=&quot;http://search.cpan.org/perldoc/File::KGlob&quot;&gt;。File :: KGlob&lt;/a&gt;模块（可从CPAN获得）提供了更多的可移植glob功能。</target>
        </trans-unit>
        <trans-unit id="70b160440316452f340f816438a94ac57e43a80b" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt; module. It comes with Perl and can do a true copy across file systems, and it does its magic in a portable fashion.</source>
          <target state="translated">使用&lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt;模块。它随Perl一起提供，并且可以跨文件系统进行真实复制，并且以可移植的方式发挥其神奇作用。</target>
        </trans-unit>
        <trans-unit id="e3fef79cbd4ceac4e867796d39b4567be99b7a0c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Resource&quot;&gt;BSD::Resource&lt;/a&gt; module from CPAN. As an example:</source>
          <target state="translated">使用CPAN 的&lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Resource&quot;&gt;BSD :: Resource&lt;/a&gt;模块。举个例子：</target>
        </trans-unit>
        <trans-unit id="d164af42cbef789ed1001f4b9517bb726a601d59" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email::Folder&lt;/a&gt; module, like so:</source>
          <target state="translated">使用&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email :: Folder&lt;/a&gt;模块，如下所示：</target>
        </trans-unit>
        <trans-unit id="66505dab9f27e8ded0226b45047ac4d95ef19d93" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email::Sender::Simple&lt;/a&gt; modules, like so:</source>
          <target state="translated">使用&lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email :: MIME&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email :: Sender :: Simple&lt;/a&gt;模块，如下所示：</target>
        </trans-unit>
        <trans-unit id="9cda4728e014cde6b4aa8b1e9ff60d1e00b00f30" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; module. It's well-tested and supports all the craziness that you'll see in the real world (comment-folding whitespace, encodings, comments, etc.).</source>
          <target state="translated">使用&lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email :: MIME&lt;/a&gt;模块。它经过了充分的测试，并支持您在现实世界中看到的所有疯狂行为（注释折叠空白，编码，注释等）。</target>
        </trans-unit>
        <trans-unit id="6c838954123651f7a7afc095c1c154c266d44966" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/List::Permutor&quot;&gt;List::Permutor&lt;/a&gt; module on CPAN. If the list is actually an array, try the &lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Permute&quot;&gt;Algorithm::Permute&lt;/a&gt; module (also on CPAN). It's written in XS code and is very efficient:</source>
          <target state="translated">使用CPAN上的&lt;a href=&quot;http://search.cpan.org/perldoc/List::Permutor&quot;&gt;List :: Permutor&lt;/a&gt;模块。如果列表实际上是一个数组，请尝试&lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Permute&quot;&gt;Algorithm :: Permute&lt;/a&gt;模块（也在CPAN上）。它是用XS代码编写的，非常有效：</target>
        </trans-unit>
        <trans-unit id="65a351301ca14a96333147c8b3d3106e99e464c1" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Math::Matrix&quot;&gt;Math::Matrix&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Math::MatrixReal&quot;&gt;Math::MatrixReal&lt;/a&gt; modules (available from CPAN) or the &lt;a href=&quot;http://search.cpan.org/perldoc/PDL&quot;&gt;PDL&lt;/a&gt; extension (also available from CPAN).</source>
          <target state="translated">使用&lt;a href=&quot;http://search.cpan.org/perldoc/Math::Matrix&quot;&gt;Math :: Matrix&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/Math::MatrixReal&quot;&gt;Math :: MatrixReal&lt;/a&gt;模块（可从CPAN获得）或&lt;a href=&quot;http://search.cpan.org/perldoc/PDL&quot;&gt;PDL&lt;/a&gt;扩展（也可从CPAN获得）。</target>
        </trans-unit>
        <trans-unit id="9284406bbe8e82a3357e3616e641d1dd96c570f0" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::IxHash&quot;&gt;Tie::IxHash&lt;/a&gt; from CPAN.</source>
          <target state="translated">使用CPAN 的&lt;a href=&quot;http://search.cpan.org/perldoc/Tie::IxHash&quot;&gt;Tie :: IxHash&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0e1ce41fa321637cf3d64ebec09008a4c7342ad" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;$/&lt;/code&gt; variable (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for details). You can either set it to &lt;code&gt;&quot;&quot;&lt;/code&gt; to eliminate empty paragraphs (&lt;code&gt;&quot;abc\n\n\n\ndef&quot;&lt;/code&gt; , for instance, gets treated as two paragraphs and not three), or &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; to accept empty paragraphs.</source>
          <target state="translated">使用 &lt;code&gt;$/&lt;/code&gt; 变量（有关详细信息，请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;）。您可以将其设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 以消除空的段落（例如， &lt;code&gt;&quot;abc\n\n\n\ndef&quot;&lt;/code&gt; 被视为两个段落而不是三个段落），或者将其设置为 &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; 以接受空的段落。</target>
        </trans-unit>
        <trans-unit id="3eb28dd761b36a73acd489d9a060d0261a86e1b3" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;:encoding(...)&lt;/code&gt; layer to read from and write to filehandles using the specified encoding. (See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;.)</source>
          <target state="translated">使用 &lt;code&gt;:encoding(...)&lt;/code&gt; 层，使用指定的编码从文件句柄读取和写入文件句柄。（请参阅&lt;a href=&quot;open&quot;&gt;打开&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="1043c9bb577ccc31fca3b4929e685adcde02639a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; function, probably in conjunction with a signal handler, as documented in &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt; and the section on &quot;Signals&quot; in the Camel. You may instead use the more flexible &lt;a href=&quot;http://search.cpan.org/perldoc/Sys::AlarmCall&quot;&gt;Sys::AlarmCall&lt;/a&gt; module available from CPAN.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 函数（可能与信号处理程序结合使用），如&lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc&lt;/a&gt;中的Signals和Camel中&amp;ldquo; Signals&amp;rdquo;部分中所述。您可以改用CPAN中可用的更灵活的&lt;a href=&quot;http://search.cpan.org/perldoc/Sys::AlarmCall&quot;&gt;Sys :: AlarmCall&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="0b06aec35cc8ae0b522498e65b1bb4f4583c757e" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; function (see &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;):</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 函数（请参阅&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="24977a0b1e006e0285b58c0302df8403248c380a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;Encode&lt;/code&gt; package to try converting it. For example,</source>
          <target state="translated">使用 &lt;code&gt;Encode&lt;/code&gt; 包尝试转换它。例如，</target>
        </trans-unit>
        <trans-unit id="0dc5eef8749d48465cf33790a50fb27f748e0a9f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;SvPV_nolen&lt;/code&gt; macro instead</source>
          <target state="translated">请改用 &lt;code&gt;SvPV_nolen&lt;/code&gt; 宏</target>
        </trans-unit>
        <trans-unit id="ef653b1e1ac17e7ebb2ebd7fe5cecc710ea855b0" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;SvPVutf8_nolen&lt;/code&gt; macro instead</source>
          <target state="translated">请改用 &lt;code&gt;SvPVutf8_nolen&lt;/code&gt; 宏</target>
        </trans-unit>
        <trans-unit id="bfd1997217ebfcfd0b8127ecc2505173b83edb29" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;\N{&lt;i&gt;charname&lt;/i&gt;}&lt;/code&gt; notation to get the character by that name for use in interpolated literals (double-quoted strings and regexes). In v5.16, there is an implicit</source>
          <target state="translated">使用 &lt;code&gt;\N{&lt;i&gt;charname&lt;/i&gt;}&lt;/code&gt; 表示法可通过该名称获取字符，以用于插值文字（双引号字符串和正则表达式）。在v5.16中，有一个隐式</target>
        </trans-unit>
        <trans-unit id="7d52ddc8b7977a545ad663296d7fb2fca1b0f239" translate="yes" xml:space="preserve">
          <source>Use the Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; flag to enable the gcc &lt;code&gt;-ansi
-pedantic&lt;/code&gt; flags which enforce stricter ANSI rules.</source>
          <target state="translated">使用Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; 标志启用启用更严格ANSI规则的gcc &lt;code&gt;-ansi -pedantic&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="ddf13da36f032e379ae4d2a3b1c1bae344b15223" translate="yes" xml:space="preserve">
          <source>Use the MY_CXT macro to access members of the &lt;code&gt;my_cxt_t&lt;/code&gt; struct. For example, if &lt;code&gt;my_cxt_t&lt;/code&gt; is</source>
          <target state="translated">使用MY_CXT宏访问 &lt;code&gt;my_cxt_t&lt;/code&gt; 结构的成员。例如，如果 &lt;code&gt;my_cxt_t&lt;/code&gt; 为</target>
        </trans-unit>
        <trans-unit id="209d781836e6b1246a37a402443979bfc102b6da" translate="yes" xml:space="preserve">
          <source>Use the alternate DATA command &quot;BDAT&quot; of the data chunking service extension defined in RFC1830 for efficiently sending large MIME messages.</source>
          <target state="translated">使用RFC1830中定义的数据分块服务扩展的备用DATA命令 &quot;BDAT &quot;来有效地发送大型MIME消息。</target>
        </trans-unit>
        <trans-unit id="3b568a8fe0839108748606587d3b5ef52fd93b31" translate="yes" xml:space="preserve">
          <source>Use the author's favorite set of formatting conventions. This is the default, of course.</source>
          <target state="translated">使用作者最喜欢的一套格式约定。当然,这是默认的。</target>
        </trans-unit>
        <trans-unit id="9ac34b7ac482595c74c32af79b7d65f665861078" translate="yes" xml:space="preserve">
          <source>Use the backslash ('\') character for quoting: every occurrence of a backslash followed by a character in the pattern is replaced by that character, avoiding any special interpretation of the character. (But see below for exceptions on DOSISH systems).</source>
          <target state="translated">使用反斜杠('/')字符进行引用:模式中每出现一个反斜杠后的字符,都会被该字符所取代,避免了对该字符的任何特殊解释。但DOSISH系统的例外情况见下文)。</target>
        </trans-unit>
        <trans-unit id="58c791ac75ac6f9811d7c1cd895cf02a99e988fc" translate="yes" xml:space="preserve">
          <source>Use the dMY_CXT macro (a declaration) in all the functions that access MY_CXT.</source>
          <target state="translated">在所有访问MY_CXT的函数中使用dMY_CXT宏(一个声明)。</target>
        </trans-unit>
        <trans-unit id="a11c34555178b87ed57024b7506fd7ffd640c9ab" translate="yes" xml:space="preserve">
          <source>Use the default &quot;cmd&quot; shell that comes with Windows. Some versions of the popular 4DOS/NT shell have incompatibilities that may cause you trouble. If the build fails under that shell, try building again with the cmd shell.</source>
          <target state="translated">使用Windows自带的默认 &quot;cmd &quot;shell。流行的4DOS/NT shell的某些版本有不兼容之处,可能会给你带来麻烦。如果在该shell下编译失败,请尝试使用cmd shell重新编译。</target>
        </trans-unit>
        <trans-unit id="860daa28ec194a818f5b182bccd22928db406092" translate="yes" xml:space="preserve">
          <source>Use the default to produce the *.dll's. But for new archdir dll's use the same rebase address if the old exists.</source>
          <target state="translated">使用默认的生成*.dll的。但对于新的archdir dll,如果旧的存在,则使用相同的rebase地址。</target>
        </trans-unit>
        <trans-unit id="e1fc4198386c0572da6a991c5d426478433e6323" translate="yes" xml:space="preserve">
          <source>Use the external tar program instead of Archive::Tar?</source>
          <target state="translated">使用外部的tar程序代替Archive::Tar?</target>
        </trans-unit>
        <trans-unit id="4bac2574d114ae82b8fd263b9459dca50bff3c24" translate="yes" xml:space="preserve">
          <source>Use the following simple functions:</source>
          <target state="translated">使用以下简单的功能:</target>
        </trans-unit>
        <trans-unit id="82c21f5742907cbf65bd7db33516fce8af244b3d" translate="yes" xml:space="preserve">
          <source>Use the force pragma like so</source>
          <target state="translated">使用武力原则,如</target>
        </trans-unit>
        <trans-unit id="d7f075c6e2b64b3ce706fb827bca3411e7b8504c" translate="yes" xml:space="preserve">
          <source>Use the key mentioned at</source>
          <target state="translated">使用下面提到的钥匙</target>
        </trans-unit>
        <trans-unit id="718a478ced25e8295348d28c5a0bc5741996efff" translate="yes" xml:space="preserve">
          <source>Use the libwww-perl distribution. The &lt;a href=&quot;http://search.cpan.org/perldoc/LWP::Simple&quot;&gt;LWP::Simple&lt;/a&gt; module can fetch web resources and give their content back to you as a string:</source>
          <target state="translated">使用libwww-perl发行版。该&lt;a href=&quot;http://search.cpan.org/perldoc/LWP::Simple&quot;&gt;LWP ::简单的&lt;/a&gt;模块可以获取网络资源，并给他们的内容还给你作为一个字符串：</target>
        </trans-unit>
        <trans-unit id="cb1603df2ef00841c0d9bacb479a841ff6e25e94" translate="yes" xml:space="preserve">
          <source>Use the macros STMT_START and STMT_END.</source>
          <target state="translated">使用宏STMTT_START和STMTT_END。</target>
        </trans-unit>
        <trans-unit id="c888fae92abf19a81b4d142f09c5f461d8d9608c" translate="yes" xml:space="preserve">
          <source>Use the name of the class for the object reference, &lt;code&gt;$object&lt;/code&gt; , as the warnings category.</source>
          <target state="translated">将类的名称用于对象引用 &lt;code&gt;$object&lt;/code&gt; 作为警告类别。</target>
        </trans-unit>
        <trans-unit id="90b334d1699fa8ac1b699ca7fe59817de25916cf" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators to avoid having to parenthesize list operators so much, and to reduce the incidence of punctuation operators like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;. Call your subroutines as if they were functions or list operators to avoid excessive ampersands and parentheses.</source>
          <target state="translated">使用new &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; 运算符可以避免在括号中加上太多括号，并减少 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 等标点运算符的出现。。像调用函数或列表运算符一样调用子例程，以避免过多的与号和括号。</target>
        </trans-unit>
        <trans-unit id="442188b51b5e18cf49fd3890247d5179d50e4049" translate="yes" xml:space="preserve">
          <source>Use the object-oriented interface if fine-grained control of when a file is removed is required.</source>
          <target state="translated">如果需要精细控制何时删除文件,请使用面向对象的接口。</target>
        </trans-unit>
        <trans-unit id="79265afb000f4991752261ca28217b5c373e53aa" translate="yes" xml:space="preserve">
          <source>Use the perlrebase or rebase utilities to resolve the conflicting dll addresses. The rebase package is included in the Cygwin setup. Use</source>
          <target state="translated">使用 perlrebase 或 rebase 工具来解决冲突的 dll 地址。rebase包包含在Cygwin设置中。使用</target>
        </trans-unit>
        <trans-unit id="0801908980e9c580009d45c4098d1486f12c00b2" translate="yes" xml:space="preserve">
          <source>Use the reaper code from &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt; to call &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; when a SIGCHLD is received, or else use the double-fork technique described in &lt;a href=&quot;perlfaq8#How-do-I-start-a-process-in-the-background%3f&quot;&gt;How do I start a process in the background? in perlfaq8&lt;/a&gt;.</source>
          <target state="translated">当收到SIGCHLD时，使用&lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc中Signals&lt;/a&gt;的收割者代码来调用 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; ，或者使用&lt;a href=&quot;perlfaq8#How-do-I-start-a-process-in-the-background%3f&quot;&gt;如何在后台启动进程中所述&lt;/a&gt;的双叉技术？在perlfaq8中。</target>
        </trans-unit>
        <trans-unit id="4ab1865ade7c5cbdf616d9cfa7bc296cc942c842" translate="yes" xml:space="preserve">
          <source>Use the split function:</source>
          <target state="translated">使用分割功能。</target>
        </trans-unit>
        <trans-unit id="a9b5bca0abebc1d76df512275844e6baf7fca732" translate="yes" xml:space="preserve">
          <source>Use the three-argument form to open a file with arbitrary weird characters in it,</source>
          <target state="translated">使用三参数形式打开一个文件,里面有任意奇怪的字符。</target>
        </trans-unit>
        <trans-unit id="0e2045ea69cf09267eda92b39d5360c52617d312" translate="yes" xml:space="preserve">
          <source>Use the warnings category with the same name as the current package.</source>
          <target state="translated">使用与当前软件包名称相同的警告类别。</target>
        </trans-unit>
        <trans-unit id="0293445fabb340233713c8257ab81530a2889bf1" translate="yes" xml:space="preserve">
          <source>Use these rather than &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; , &lt;code&gt;stderr&lt;/code&gt; . They are written to look like &quot;function calls&quot; rather than variables because this makes it easier to</source>
          <target state="translated">使用这些而不是 &lt;code&gt;stdin&lt;/code&gt; ， &lt;code&gt;stdout&lt;/code&gt; ， &lt;code&gt;stderr&lt;/code&gt; 。它们被编写为看起来像&amp;ldquo;函数调用&amp;rdquo;，而不是变量，因为这样可以更容易地</target>
        </trans-unit>
        <trans-unit id="a81fa8275577903400d658f76e856afcaee1f2f2" translate="yes" xml:space="preserve">
          <source>Use these very, very, very sparingly.</source>
          <target state="translated">非常、非常、非常少地使用这些。</target>
        </trans-unit>
        <trans-unit id="87ebb269f56a9a915023b69eabf6ff027e2f7e0c" translate="yes" xml:space="preserve">
          <source>Use this code, provided by Mark-Jason Dominus:</source>
          <target state="translated">使用这个代码,由Mark-Jason Dominus提供。</target>
        </trans-unit>
        <trans-unit id="1a99888f271041405f93aa8e81d9f5a2d2c20746" translate="yes" xml:space="preserve">
          <source>Use this instead of $(PERL) when you wish to run perl to work with modules. It will add things like -I$(INST_ARCH) and other necessary flags so perl can see the modules you're about to install.</source>
          <target state="translated">当你希望运行perl来处理模块时,可以用它来代替$(PERL)。它将添加诸如-I$(INST_ARCH)和其他必要的标志,这样perl就可以看到你将要安装的模块。</target>
        </trans-unit>
        <trans-unit id="388121ab9a82a1ad19377b89ac9de297ea8e7f2c" translate="yes" xml:space="preserve">
          <source>Use this instead of $(PERL) when you wish to run perl. It will set up extra necessary flags for you.</source>
          <target state="translated">当你想运行perl时,用这个来代替$(PERL)。它将为你设置额外的必要标志。</target>
        </trans-unit>
        <trans-unit id="e6433f54cefa63ecf9e10e3ca3a566ca9eb8f9de" translate="yes" xml:space="preserve">
          <source>Use this instead:</source>
          <target state="translated">用这个代替。</target>
        </trans-unit>
        <trans-unit id="9482ca604a352c4ff781a10e825ea8768f370ffb" translate="yes" xml:space="preserve">
          <source>Use this module like this:</source>
          <target state="translated">这样使用这个模块。</target>
        </trans-unit>
        <trans-unit id="24fd134a2b3d96c5cbea104957e21046321bc6c3" translate="yes" xml:space="preserve">
          <source>Use this to build perl outside of the source tree. Details can be found in the</source>
          <target state="translated">用它来在源代码树之外构建perl。详情可以在</target>
        </trans-unit>
        <trans-unit id="163162b126000a656e356ab3254dffb8d7962901" translate="yes" xml:space="preserve">
          <source>Use this to disassociate a file from a PerlIO * that was associated using PerlIO_exportFILE().</source>
          <target state="translated">使用该功能可以将一个文件从PerlIO *中分离出来,该文件是使用PerlIO_exportFILE()关联的。</target>
        </trans-unit>
        <trans-unit id="b543720e8daabc3733964f244cca2d14e58df202" translate="yes" xml:space="preserve">
          <source>Use this:</source>
          <target state="translated">用这个。</target>
        </trans-unit>
        <trans-unit id="03038b4251119aa1c25d1f79aa4a7d76f09e6350" translate="yes" xml:space="preserve">
          <source>Use tree connecting characters drawn from the VT100 line-drawing set. This looks better if your terminal supports it.</source>
          <target state="translated">使用从 VT100 画线集绘制的树状连接字符。如果你的终端支持这样做,看起来会更好。</target>
        </trans-unit>
        <trans-unit id="5b877243c67d7922e8d87750811b66b31f1b397f" translate="yes" xml:space="preserve">
          <source>Use underscores to separate words. It is generally easier to read $var_names_like_this than $VarNamesLikeThis, especially for non-native speakers of English. It's also a simple rule that works consistently with VAR_NAMES_LIKE_THIS.</source>
          <target state="translated">使用下划线来分隔单词。一般来说,读$var_names_like_this比读$VarNamesLikeThis更容易,特别是对于非英语母语的人来说。这也是一个简单的规则,与VAR_NAMES_LIKE_THIS一致。</target>
        </trans-unit>
        <trans-unit id="a9f6d10a6d2104b7922abf95412d3e52031b3d8b" translate="yes" xml:space="preserve">
          <source>Use unrelated features (this will flush out bizarre interactions).</source>
          <target state="translated">使用不相关的功能(这将冲出奇异的交互)。</target>
        </trans-unit>
        <trans-unit id="b5b5116cfec58023d905fc9d5b3040b726593cef" translate="yes" xml:space="preserve">
          <source>Used as a noun in this case, this refers to a known way to compromise a program to get it to do something the author didn&amp;rsquo;t intend. Your task is to write unexploitable programs.</source>
          <target state="translated">在这种情况下用作名词，这是指一种已知的方法，它可以危害程序以使其执行作者不希望的操作。您的任务是编写无法利用的程序。</target>
        </trans-unit>
        <trans-unit id="79c6d27106d07e0f5897103d8c6a8d8a85ec8bb1" translate="yes" xml:space="preserve">
          <source>Used as a noun, a name in a &lt;b&gt;directory&lt;/b&gt; that represents a &lt;b&gt;file&lt;/b&gt;. A given file can have multiple links to it. It&amp;rsquo;s like having the same phone number listed in the phone directory under different names. As a verb, to resolve a partially &lt;b&gt;compiled&lt;/b&gt; file&amp;rsquo;s unresolved symbols into a (nearly) executable image. Linking can generally be static or dynamic, which has nothing to do with static or dynamic scoping.</source>
          <target state="translated">用作名词，是表示&lt;b&gt;文件&lt;/b&gt;的&lt;b&gt;目录&lt;/b&gt;中的名称。给定文件可以具有多个链接。就像在电话目录中以不同的名称列出了相同的电话号码一样。作为动词，用于将部分&lt;b&gt;编译的&lt;/b&gt;文件的未解析符号解析为（几乎）可执行映像。链接通常可以是静态或动态的，而与静态或动态作用域无关。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5e94bf506fd2ed1897d55415e2eda38e61b816ec" translate="yes" xml:space="preserve">
          <source>Used as an lvalue, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; allows you to increase the number of hash buckets allocated for the given hash. This can gain you a measure of efficiency if you know the hash is going to get big. (This is similar to pre-extending an array by assigning a larger number to $#array.) If you say</source>
          <target state="translated">用作左值时， &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 允许您增加为给定哈希分配的哈希桶的数量。如果您知道哈希将变得很大，则可以提高效率。（这类似于通过为$＃array分配更大的数字来预先扩展数组。）如果您说</target>
        </trans-unit>
        <trans-unit id="cfcd9d6e7d0af6a973640e08731f7579c85d2ca6" translate="yes" xml:space="preserve">
          <source>Used as an lvalue, &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; allows you to increase the number of hash buckets allocated for the given hash. This can gain you a measure of efficiency if you know the hash is going to get big. (This is similar to pre-extending an array by assigning a larger number to $#array.) If you say</source>
          <target state="translated">用作左值时， &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 允许您增加为给定哈希分配的哈希桶的数量。如果您知道哈希将变得很大，则可以提高效率。（这类似于通过为$＃array分配更大的数字来预先扩展数组。）如果您说</target>
        </trans-unit>
        <trans-unit id="9d927fa8ae51a19f16800a69ce9d19da2c120815" translate="yes" xml:space="preserve">
          <source>Used as part of the &quot;clone&quot; process when a thread is spawned (in which case param will be non-NULL) and when a stream is being duplicated via '&amp;amp;' in the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">产生线程时（在这种情况下，param将为非NULL）以及在 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 中通过'＆'复制流时，用作&amp;ldquo;克隆&amp;rdquo;过程的一部分。</target>
        </trans-unit>
        <trans-unit id="251c18a90eefe3a719259f59bb8700c29e6c2e54" translate="yes" xml:space="preserve">
          <source>Used by 'make install' which copies files from INST_SCRIPT to this directory if INSTALLDIRS is set to site (default).</source>
          <target state="translated">如果INSTALLDIRS被设置为site(默认),'make install'会将INST_SCRIPT中的文件复制到这个目录中。</target>
        </trans-unit>
        <trans-unit id="0413527e465c4de8a077bbf425ed66e91381919a" translate="yes" xml:space="preserve">
          <source>Used by 'make install' which copies files from INST_SCRIPT to this directory if INSTALLDIRS is set to vendor.</source>
          <target state="translated">如果INSTALLDIRS被设置为vendor,则由'make install'使用,将INST_SCRIPT中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="976bda008ac56ae36683d29627c3f35a11dab1ca" translate="yes" xml:space="preserve">
          <source>Used by 'make install' which copies files from INST_SCRIPT to this directory if INSTALLDIRS=perl.</source>
          <target state="translated">由'make install'使用,如果INST_SCRIPT=perl,它会将INST_SCRIPT中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="37d1058a6b6ba0e70de245f908c09c85ed3a873d" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_ARCHLIB to this directory if INSTALLDIRS is set to perl.</source>
          <target state="translated">由'make install'使用,如果 INSTALLDIRS 被设置为 perl,则会将 INST_ARCHLIB 中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="8402b50cbc218eeff1f81c3db2cda9adf3fffbd7" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_ARCHLIB to this directory if INSTALLDIRS is set to site (default).</source>
          <target state="translated">由'make install'使用,如果INST_ARCHLIB被设置为site(默认),它会将INST_ARCHLIB中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="c4c8328bf8916ab5fdd86eb62de06cc4f4230a70" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_ARCHLIB to this directory if INSTALLDIRS is set to vendor.</source>
          <target state="translated">由'make install'使用,如果 INSTALLDIRS 被设置为 vendor,它会将 INST_ARCHLIB 中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="3b0cddfea5d7479fbfb7a215e845b5a123be89bb" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_BIN to this directory if INSTALLDIRS is set to site (default).</source>
          <target state="translated">由'make install'使用,如果INSTALLDIRS被设置为site(默认),它会将INST_BIN中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="eb49c11648bc66ca1d5846b99271ffd0d898ea32" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_BIN to this directory if INSTALLDIRS is set to vendor.</source>
          <target state="translated">由'make install'使用,如果INSTALLDIRS被设置为vendor,则会将INST_BIN中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="2b07ebb6cc38d7286ba9e956f3eba69a5ff528fe" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_LIB to this directory if INSTALLDIRS is set to perl.</source>
          <target state="translated">由'make install'使用,如果INST_LIB被设置为perl,它会将INST_LIB中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="4c572796939181da5eba99b899ab05bfaac9e449" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_LIB to this directory if INSTALLDIRS is set to site (default).</source>
          <target state="translated">由'make install'使用,如果INST_LIB被设置为site(默认),它会将INST_LIB中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="497f3b2bdeaf3749352a862b66d7233b6bb7365e" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_LIB to this directory if INSTALLDIRS is set to vendor.</source>
          <target state="translated">由'make install'使用,如果INST_LIB被设置为vendor,则会将INST_LIB中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="955b442432c35e6b42d1db59049e0e27c3353bce" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;xsubpp&lt;/code&gt; to hook up XSUBs as Perl subs.</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; 用于将XSUB连接为Perl子。</target>
        </trans-unit>
        <trans-unit id="b701e8ad52984344882bfc710f4e3b41bfee3ae7" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;xsubpp&lt;/code&gt; to hook up XSUBs as Perl subs. Adds Perl prototypes to the subs.</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; 用于将XSUB连接为Perl子。将Perl原型添加到subs。</target>
        </trans-unit>
        <trans-unit id="bf413f31411cb5187dfc08c3a35d494612fab477" translate="yes" xml:space="preserve">
          <source>Used by Unicode internally for generating other properties and not intended to be used stand-alone</source>
          <target state="translated">由Unicode内部用于生成其他属性,不打算单独使用。</target>
        </trans-unit>
        <trans-unit id="4e698d59aaba8e3ee1c30011c41b0b74d5937cc8" translate="yes" xml:space="preserve">
          <source>Used by a &lt;b&gt;standard I/O&lt;/b&gt; output stream that flushes its &lt;b&gt;buffer&lt;/b&gt; after every &lt;b&gt;newline&lt;/b&gt;. Many standard I/O libraries automatically set up line buffering on output that is going to the terminal.</source>
          <target state="translated">由&lt;b&gt;标准I / O&lt;/b&gt;输出流使用，该&lt;b&gt;标准&lt;/b&gt;流在每个&lt;b&gt;换行符&lt;/b&gt;之后刷新其&lt;b&gt;缓冲区&lt;/b&gt;。许多标准I / O库会自动在要发送到终端的输出上设置行缓冲。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e00976e80fe78228b9297b3ddbd122a14f1abe1f" translate="yes" xml:space="preserve">
          <source>Used by some OS' to define DL_FUNCS and DL_VARS and write the *.exp files.</source>
          <target state="translated">被一些操作系统用来定义DL_FUNCS和DL_VARS并写入*.exp文件。</target>
        </trans-unit>
        <trans-unit id="1ba26d0698fc6f53589c3fcda2fd4a8860e0e9f9" translate="yes" xml:space="preserve">
          <source>Used by the IS_SAFE_SYSCALL() macro.</source>
          <target state="translated">由IS_SAFE_SYSCALL()宏使用。</target>
        </trans-unit>
        <trans-unit id="c2253cb286405345c16b81c3000c80dff0161abd" translate="yes" xml:space="preserve">
          <source>Used during the execution phase for managing search and replace patterns, and for providing the text for &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$1&lt;/code&gt; etc. &lt;code&gt;subbeg&lt;/code&gt; points to a buffer (either the original string, or a copy in the case of &lt;code&gt;RX_MATCH_COPIED(rx)&lt;/code&gt; ), and &lt;code&gt;sublen&lt;/code&gt; is the length of the buffer. The &lt;code&gt;RX_OFFS&lt;/code&gt; start and end indices index into this buffer.</source>
          <target state="translated">在执行阶段用于管理搜索和替换模式，以及为 &lt;code&gt;$&amp;amp;&lt;/code&gt; ， &lt;code&gt;$1&lt;/code&gt; 等提供文本 &lt;code&gt;subbeg&lt;/code&gt; 指向缓冲区（原始字符串，或者为 &lt;code&gt;RX_MATCH_COPIED(rx)&lt;/code&gt; 的副本）和 &lt;code&gt;sublen&lt;/code&gt; 是缓冲区的长度。该 &lt;code&gt;RX_OFFS&lt;/code&gt; 开始和结束索引的索引到这个缓冲区。</target>
        </trans-unit>
        <trans-unit id="c07d1ff394d728bbcdaa2001c2857f1cf7faa30d" translate="yes" xml:space="preserve">
          <source>Used for emphasis (&quot;&lt;code&gt;be I&amp;lt;careful!&amp;gt;&lt;/code&gt; &quot;) and parameters (&quot;&lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; I&amp;lt;LABEL&amp;gt;&lt;/code&gt; &quot;)</source>
          <target state="translated">用于强调（&amp;ldquo; &lt;code&gt;be I&amp;lt;careful!&amp;gt;&lt;/code&gt; &amp;rdquo;）和参数（&amp;ldquo; &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; I&amp;lt;LABEL&amp;gt;&lt;/code&gt; &amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="7d3c574527f056e37525c76d104fc8a22ad9cc2b" translate="yes" xml:space="preserve">
          <source>Used for optimisations. &lt;code&gt;precomp&lt;/code&gt; holds a copy of the pattern that was compiled and &lt;code&gt;prelen&lt;/code&gt; its length. When a new pattern is to be compiled (such as inside a loop) the internal &lt;code&gt;regcomp&lt;/code&gt; operator checks if the last compiled &lt;code&gt;REGEXP&lt;/code&gt; 's &lt;code&gt;precomp&lt;/code&gt; and &lt;code&gt;prelen&lt;/code&gt; are equivalent to the new one, and if so uses the old pattern instead of compiling a new one.</source>
          <target state="translated">用于优化。 &lt;code&gt;precomp&lt;/code&gt; 保留已编译模式的副本，并 &lt;code&gt;prelen&lt;/code&gt; 其长度。当要编译新模式时（例如在循环内），内部 &lt;code&gt;regcomp&lt;/code&gt; 运算符将检查最后编译的 &lt;code&gt;REGEXP&lt;/code&gt; 的 &lt;code&gt;precomp&lt;/code&gt; 和 &lt;code&gt;prelen&lt;/code&gt; 是否等于新模式，如果使用，则使用旧模式而不是编译新模式。 。</target>
        </trans-unit>
        <trans-unit id="c16a1dda4419ca1fa42a25c2f463240abdf22010" translate="yes" xml:space="preserve">
          <source>Used for switches (&quot;&lt;code&gt;perl's B&amp;lt;-n&amp;gt; switch&lt;/code&gt; &quot;), programs (&quot;&lt;code&gt;some systems provide a B&amp;lt;chfn&amp;gt; for that&lt;/code&gt; &quot;), emphasis (&quot;&lt;code&gt;be B&amp;lt;careful!&amp;gt;&lt;/code&gt; &quot;), and so on (&quot;&lt;code&gt;and that feature is known as B&amp;lt;autovivification&amp;gt;&lt;/code&gt; &quot;).</source>
          <target state="translated">用于开关（&amp;rdquo; &lt;code&gt;perl's B&amp;lt;-n&amp;gt; switch&lt;/code&gt; &amp;ldquo;），程序（&amp;rdquo; &lt;code&gt;some systems provide a B&amp;lt;chfn&amp;gt; for that&lt;/code&gt; &amp;ldquo;），强调（&amp;rdquo; &lt;code&gt;be B&amp;lt;careful!&amp;gt;&lt;/code&gt; &amp;ldquo;），等等（&amp;rdquo; &lt;code&gt;and that feature is known as B&amp;lt;autovivification&amp;gt;&lt;/code&gt; &amp;ldquo;）。</target>
        </trans-unit>
        <trans-unit id="8d00f06e1f81e3c4218071563a3bababae3c7eab" translate="yes" xml:space="preserve">
          <source>Used for test.pl, since they don't always follow Test::Harness formatting.</source>
          <target state="translated">用于 test.pl,因为它们并不总是遵循 Test::Harness 的格式。</target>
        </trans-unit>
        <trans-unit id="85f7caced82a8f0a4057356aaa1e87b6b4b7ead3" translate="yes" xml:space="preserve">
          <source>Used if &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; has no argument and HOME is not set.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 没有参数并且未设置HOME，则使用该参数。</target>
        </trans-unit>
        <trans-unit id="a5442b49ecc1bae306f70b5a25e1762fda194c70" translate="yes" xml:space="preserve">
          <source>Used if &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; has no argument.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 没有参数，则使用它。</target>
        </trans-unit>
        <trans-unit id="5908b09f62d202af9a5d54ac62b509abf705e1f4" translate="yes" xml:space="preserve">
          <source>Used if chdir has no argument and HOME and LOGDIR are not set.</source>
          <target state="translated">如果chdir没有参数,并且没有设置HOME和LOGDIR,则使用。</target>
        </trans-unit>
        <trans-unit id="9b97a5382104ef747655a54d5cf00ae2ece3ac3e" translate="yes" xml:space="preserve">
          <source>Used in conjunction with the &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; option to supply a reference to an &lt;code&gt;@ARGV&lt;/code&gt; style array of arguments to pass to the test program.</source>
          <target state="translated">与 &lt;code&gt;source&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 选项一起使用，以提供对 &lt;code&gt;@ARGV&lt;/code&gt; 样式参数数组的引用，以传递给测试程序。</target>
        </trans-unit>
        <trans-unit id="477606f47e75aab0d16ae4c72010e54847d20bed" translate="yes" xml:space="preserve">
          <source>Used in conjunction with the &lt;code&gt;strcoll()&lt;/code&gt; function, see &lt;a href=&quot;#strcoll&quot;&gt;strcoll&lt;/a&gt;.</source>
          <target state="translated">与 &lt;code&gt;strcoll()&lt;/code&gt; 函数结合使用，请参见&lt;a href=&quot;#strcoll&quot;&gt;strcoll&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0096c9408c39e5114a134ce424b3de68995688e0" translate="yes" xml:space="preserve">
          <source>Used in executing subprocesses, and in finding the program if &lt;b&gt;-S&lt;/b&gt; is used.</source>
          <target state="translated">如果使用&lt;b&gt;-S，&lt;/b&gt;则用于执行子过程以及查找程序。</target>
        </trans-unit>
        <trans-unit id="fc7e238a8b39d615018cf421f51aee97a59ca55c" translate="yes" xml:space="preserve">
          <source>Used on numbers, the bitwise operators (&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;~&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ) always produce integral results. (But see also &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.) However, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; still has meaning for them. By default, their results are interpreted as unsigned integers, but if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; is in effect, their results are interpreted as signed integers. For example, &lt;code&gt;~0&lt;/code&gt; usually evaluates to a large integral value. However, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer; ~0&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; on two's-complement machines.</source>
          <target state="translated">在数字上使用时，按位运算符（ &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;~&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ）始终会产生整数结果。（但另请参阅&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;按位字符串运算符&lt;/a&gt;。）但是， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 对它们仍然有意义。默认情况下，其结果被解释为无符号整数，但是如果有效 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; ，则其结果将被解释为有符号整数。例如， &lt;code&gt;~0&lt;/code&gt; 通常会得出较大的整数值。但是，请 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer; ~0&lt;/code&gt; 为 &lt;code&gt;-1&lt;/code&gt; 的补码机。</target>
        </trans-unit>
        <trans-unit id="22f1fcd6bfd2f48fba3948a9e62685e57c7db9d1" translate="yes" xml:space="preserve">
          <source>Used on the t/*.t files.</source>
          <target state="translated">用于t/*.t文件。</target>
        </trans-unit>
        <trans-unit id="a64dabf0b28b220a6076bc6a581b9356f3e76610" translate="yes" xml:space="preserve">
          <source>Used only when MakeMaker is building the extensions of the Perl core distribution (because normally $(PERL_ARCHLIB) is automatically in @INC, and adding it would get in the way of PERL5LIB).</source>
          <target state="translated">只在MakeMaker构建Perl核心发行版的扩展时使用(因为通常$(PERL_ARCHLIB)是自动在@INC中的,加入它会妨碍PERL5LIB)。</target>
        </trans-unit>
        <trans-unit id="522904b951ae26afa223c455d7c6bd2555ea2781" translate="yes" xml:space="preserve">
          <source>Used only when MakeMaker is building the extensions of the Perl core distribution (because normally $(PERL_LIB) is automatically in @INC, and adding it would get in the way of PERL5LIB).</source>
          <target state="translated">只在MakeMaker构建Perl核心发行版的扩展时使用(因为通常$(PERL_LIB)是自动在@INC中的,加入它会妨碍PERL5LIB)。</target>
        </trans-unit>
        <trans-unit id="f0b6e6daa054441299880d327c03ad5022b9eb54" translate="yes" xml:space="preserve">
          <source>Used to access elements on the XSUB's stack.</source>
          <target state="translated">用于访问XSUB栈中的元素。</target>
        </trans-unit>
        <trans-unit id="e35e54c290e520db893e920267b9220db378f0a1" translate="yes" xml:space="preserve">
          <source>Used to check if any errata was seen.</source>
          <target state="translated">用于检查是否看到任何勘误。</target>
        </trans-unit>
        <trans-unit id="87a9aa1ba364ad0831ad8d0593884f266cd7c93e" translate="yes" xml:space="preserve">
          <source>Used to choose the LZMA compression preset.</source>
          <target state="translated">用于选择LZMA压缩预置。</target>
        </trans-unit>
        <trans-unit id="7c52aa40f13bb513d24fe0ba0fa19d6fcc4a443a" translate="yes" xml:space="preserve">
          <source>Used to compare numbers.</source>
          <target state="translated">用于比较数字。</target>
        </trans-unit>
        <trans-unit id="c48ef407eccd138f057ccc3292baa7a78dede864" translate="yes" xml:space="preserve">
          <source>Used to describe a &lt;b&gt;referent&lt;/b&gt; that is not directly accessible through a named &lt;b&gt;variable&lt;/b&gt;. Such a referent must be indirectly accessible through at least one &lt;b&gt;hard reference&lt;/b&gt;. When the last hard reference goes away, the anonymous referent is destroyed without pity.</source>
          <target state="translated">用于描述不能通过命名&lt;b&gt;变量&lt;/b&gt;直接访问的&lt;b&gt;参照对象&lt;/b&gt;。必须至少可以通过一个&lt;b&gt;硬引用&lt;/b&gt;间接访问此&lt;b&gt;引用对象&lt;/b&gt;。当最后一个硬引用消失时，匿名引用被无故破坏。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="68eae2d00f0bb0e45444425d5ef88e0a25c713c4" translate="yes" xml:space="preserve">
          <source>Used to extend the argument stack for an XSUB's return values. Once used, guarantees that there is room for at least &lt;code&gt;nitems&lt;/code&gt; to be pushed onto the stack.</source>
          <target state="translated">用于扩展XSUB返回值的参数堆栈。一旦使用，请确保至少有 &lt;code&gt;nitems&lt;/code&gt; 可以将尼特推入堆栈。</target>
        </trans-unit>
        <trans-unit id="c9d6ff55b3e514bbe849f67e44d09a8a1f610db4" translate="yes" xml:space="preserve">
          <source>Used to force a Perl &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; wrapper around a callback. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">用于强制在回调周围进行Perl &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 包装。参见&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de62f27495e3f33e099616750808f449be5f2cfc" translate="yes" xml:space="preserve">
          <source>Used to get a PerlIO * from a FILE *.</source>
          <target state="translated">用来从FILE *中获取PerlIO *。</target>
        </trans-unit>
        <trans-unit id="e5f86f7323575cf5c768f8e5109eb6cf3318d1d9" translate="yes" xml:space="preserve">
          <source>Used to indicate list context. See &lt;code&gt;GIMME_V&lt;/code&gt; , &lt;code&gt;GIMME&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">用于指示列表上下文。请参见 &lt;code&gt;GIMME_V&lt;/code&gt; ， &lt;code&gt;GIMME&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a930c77deebf229f4a954c4d6804d1b626a7c0da" translate="yes" xml:space="preserve">
          <source>Used to indicate scalar context. See &lt;code&gt;GIMME_V&lt;/code&gt; , &lt;code&gt;GIMME&lt;/code&gt; , and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">用于指示标量上下文。请参见 &lt;code&gt;GIMME_V&lt;/code&gt; ， &lt;code&gt;GIMME&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06d42cedd073f96c9a77c4270da2ab3e95ee0de9" translate="yes" xml:space="preserve">
          <source>Used to indicate void context. See &lt;code&gt;GIMME_V&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">用于指示无效上下文。参见 &lt;code&gt;GIMME_V&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9bb1d0a62eb268dccff9ee670a0b1ed19d224173" translate="yes" xml:space="preserve">
          <source>Used to negate the object in-place.</source>
          <target state="translated">用于原地否定对象。</target>
        </trans-unit>
        <trans-unit id="7ab9fb9e2f57ebf6032a373e79745b71c5c594eb" translate="yes" xml:space="preserve">
          <source>Used to pass in and return a reference to an SV.</source>
          <target state="translated">用于传入并返回一个SV的引用。</target>
        </trans-unit>
        <trans-unit id="02c1be0e858c6b96b18473855240486ec63fb69b" translate="yes" xml:space="preserve">
          <source>Used to pass in and return a reference to an SV. This is a fixed variant of T_SVREF that decrements the refcount appropriately when returning a reference to an SV*. Introduced in perl 5.15.4.</source>
          <target state="translated">用于传入并返回一个SV的引用.这是T_SVREF的固定变体.这是T_SVREF的一个固定的变体,当返回一个SV*的引用时,会适当地减少refcount。在 perl 5.15.4 中引入。</target>
        </trans-unit>
        <trans-unit id="c91a5082aa2e7c4d29d7e1b996780ca43a12407b" translate="yes" xml:space="preserve">
          <source>Used to shift numbers left/right.</source>
          <target state="translated">用于左/右移动数字。</target>
        </trans-unit>
        <trans-unit id="3deb258f4b48416c1a5909b948e6f301fdab02b0" translate="yes" xml:space="preserve">
          <source>Used to upgrade an SV to a more complex form. Uses &lt;code&gt;sv_upgrade&lt;/code&gt; to perform the upgrade if necessary. See &lt;code&gt;svtype&lt;/code&gt; .</source>
          <target state="translated">用于将SV升级为更复杂的形式。如有必要，使用 &lt;code&gt;sv_upgrade&lt;/code&gt; 进行升级。参见 &lt;code&gt;svtype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcb5d7f5c46a099246ea8a6f9905effe5c22e13c" translate="yes" xml:space="preserve">
          <source>Used together, as &lt;code&gt;/ms&lt;/code&gt;, they let the &quot;.&quot; match any character whatsoever, while still allowing &quot;^&quot; and &quot;$&quot; to match, respectively, just after and just before newlines within the string.</source>
          <target state="translated">与 &lt;code&gt;/ms&lt;/code&gt; 一起使用时，它们使&amp;ldquo;。&amp;rdquo; 匹配任何字符，同时仍然允许&amp;ldquo; ^&amp;rdquo;和&amp;ldquo; $&amp;rdquo;分别匹配字符串中换行符之后和之前。</target>
        </trans-unit>
        <trans-unit id="6fa27f5c1082734ec40392b2d9f3d19afd0775e2" translate="yes" xml:space="preserve">
          <source>Used when creating PPD files for binary packages. It can be set to a full or relative path or URL to the binary archive for a particular architecture. For example:</source>
          <target state="translated">在为二进制包创建PPD文件时使用。它可以设置为一个完整的或相对的路径或URL,用于特定架构的二进制存档。比如说,它可以设置为一个特定架构的二进制存档的完整或相对路径或URL。</target>
        </trans-unit>
        <trans-unit id="0efa982fe3c01dc21ffac634d0623c22f8078dad" translate="yes" xml:space="preserve">
          <source>Used when the layer's open() accepts more arguments than usual. The extra arguments should come not before the &lt;code&gt;MODE&lt;/code&gt; argument. When this flag is used it's up to the layer to validate the args.</source>
          <target state="translated">当层的open（）接受比平常更多的参数时使用。多余的参数不应出现在 &lt;code&gt;MODE&lt;/code&gt; 参数之前。使用此标志时，取决于层来验证args。</target>
        </trans-unit>
        <trans-unit id="cdd67bcd97e446b57807bc47ce4d7da189f0ad26" translate="yes" xml:space="preserve">
          <source>Used with the example above, &lt;code&gt;@libfiles&lt;/code&gt; (or &lt;code&gt;@$libfiles&lt;/code&gt; ) would contain two strings upon completion: &lt;code&gt;&quot;lib/stdlib&quot;&lt;/code&gt; and &lt;code&gt;&quot;lib/extlib&quot;&lt;/code&gt; , in that order. It is also possible to specify that only integer or floating point numbers are acceptable values.</source>
          <target state="translated">与上面的示例一起使用时， &lt;code&gt;@$libfiles&lt;/code&gt; &lt;code&gt;@libfiles&lt;/code&gt; （或@ $ libfiles）在完成时将包含两个字符串： &lt;code&gt;&quot;lib/stdlib&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;lib/extlib&quot;&lt;/code&gt; ，按此顺序。也可以指定仅整数或浮点数为可接受的值。</target>
        </trans-unit>
        <trans-unit id="32482e797407c687053869f8a4e7d0cfe24ca4f2" translate="yes" xml:space="preserve">
          <source>Used without arguments in scalar context, reverse() reverses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">在标量上下文中不带参数使用时，reverse（）会反转 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="287fb92f0982907aa797c3b17e0824ad256b9b20" translate="yes" xml:space="preserve">
          <source>Useful functions for dealing with the filehandle and filename.</source>
          <target state="translated">处理文件柄和文件名的有用功能。</target>
        </trans-unit>
        <trans-unit id="f0b64588f00eed76bae59e12d25ea5d5e9aeab35" translate="yes" xml:space="preserve">
          <source>Useful modules to help you write tests (with minimum impact on your development process or your time) include Test::Simple, Carp::Assert and Test::Inline. For more sophisticated test suites there are Test::More and Test::MockObject.</source>
          <target state="translated">帮助你编写测试的有用模块(对你的开发过程或时间影响最小)包括Test::Simple,Carp::Assert和Test::Inline。对于更复杂的测试套件,有Test::More和Test::MockObject。</target>
        </trans-unit>
        <trans-unit id="04355f5678f3ad8646b491395f68bd676dba02d6" translate="yes" xml:space="preserve">
          <source>Useful options of</source>
          <target state="translated">有用的选项</target>
        </trans-unit>
        <trans-unit id="7705a5ed12704795a74e0deb45a6e2191d0de39a" translate="yes" xml:space="preserve">
          <source>Useful values for &lt;code&gt;PERLDOC&lt;/code&gt; include &lt;code&gt;-oterm&lt;/code&gt; , &lt;code&gt;-otext&lt;/code&gt; , &lt;code&gt;-ortf&lt;/code&gt; , &lt;code&gt;-oxml&lt;/code&gt; , and so on, depending on what modules you have on hand; or the formatter class may be specified exactly with &lt;code&gt;-MPod::Perldoc::ToTerm&lt;/code&gt; or the like.</source>
          <target state="translated">&lt;code&gt;PERLDOC&lt;/code&gt; 的有用值包括 &lt;code&gt;-oterm&lt;/code&gt; ， &lt;code&gt;-otext&lt;/code&gt; ， &lt;code&gt;-ortf&lt;/code&gt; ， &lt;code&gt;-oxml&lt;/code&gt; 等等，这取决于您手头上有哪些模块。或者可以使用 &lt;code&gt;-MPod::Perldoc::ToTerm&lt;/code&gt; 或类似名称精确地指定格式程序类。</target>
        </trans-unit>
        <trans-unit id="108f6902446d675962ade16c5ef5d6ed95723631" translate="yes" xml:space="preserve">
          <source>Useful, huh? You can eval nearly anything in there, and experiment with bits of code or regexes until the cows come home:</source>
          <target state="translated">很有用,是吧?你可以在里面评估几乎所有的东西,用代码或regexs做实验,直到牛回家。</target>
        </trans-unit>
        <trans-unit id="fe3be132ee381a9663c71ca2a6207a31717e7705" translate="yes" xml:space="preserve">
          <source>User Datagram Protocol, the typical way to send &lt;b&gt;datagrams&lt;/b&gt; over the Internet.</source>
          <target state="translated">用户数据报协议，这是通过Internet 发送&lt;b&gt;数据报&lt;/b&gt;的典型方式。</target>
        </trans-unit>
        <trans-unit id="3056b101498f0c6196c04d621ba22bd3175219d6" translate="yes" xml:space="preserve">
          <source>User Groups</source>
          <target state="translated">用户组</target>
        </trans-unit>
        <trans-unit id="4325c61b581bf8fe6a3e2400d58928e7b9a55496" translate="yes" xml:space="preserve">
          <source>User Interfaces</source>
          <target state="translated">用户界面</target>
        </trans-unit>
        <trans-unit id="84956701ef226c2e8ce9adf59fb3ab8347d15b4f" translate="yes" xml:space="preserve">
          <source>User mounts override system mounts.</source>
          <target state="translated">用户挂载覆盖系统挂载。</target>
        </trans-unit>
        <trans-unit id="158586304dc1eef989a278eac13c889b9d8fde82" translate="yes" xml:space="preserve">
          <source>User pragmata store their state by writing to the magical hash &lt;code&gt;%^H&lt;/code&gt; , hence these two routines manipulate it. The state information in &lt;code&gt;%^H&lt;/code&gt; is stored in the optree, and can be retrieved read-only at runtime with &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt;, at index 10 of the list of returned results. In the example pragma, retrieval is encapsulated into the routine &lt;code&gt;in_effect()&lt;/code&gt; , which takes as parameter the number of call frames to go up to find the value of the pragma in the user's script. This uses &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; to determine the value of &lt;code&gt;$^H{&quot;myint/in_effect&quot;}&lt;/code&gt; when each line of the user's script was called, and therefore provide the correct semantics in the subroutine implementing the overloaded addition.</source>
          <target state="translated">用户实用程序通过写入魔术哈希 &lt;code&gt;%^H&lt;/code&gt; 来存储其状态，因此这两个例程对其进行了操作。 &lt;code&gt;%^H&lt;/code&gt; 的状态信息存储在optree中，并且可以在运行时使用 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 以只读方式在返回结果列表的索引10 处进行检索。在示例编译指示中，检索被封装到例程 &lt;code&gt;in_effect()&lt;/code&gt; 中，该例程以要在用户脚本中查找编译指示值的调用帧数作为参数。当调用用户脚本的每一行时，它使用 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 确定 &lt;code&gt;$^H{&quot;myint/in_effect&quot;}&lt;/code&gt; 的值，因此在实现重载加法的子例程中提供了正确的语义。</target>
        </trans-unit>
        <trans-unit id="94ffd06de7d6ceb23de314937b25f1039f95408e" translate="yes" xml:space="preserve">
          <source>User-Defined Case Mappings (for serious hackers only)</source>
          <target state="translated">用户自定义案例映射(仅适用于严重的黑客)</target>
        </trans-unit>
        <trans-unit id="021fce3b8ed64c4c7ea81643b8e56e61d1fb88d9" translate="yes" xml:space="preserve">
          <source>User-Defined Character Properties</source>
          <target state="translated">用户自定义字符属性</target>
        </trans-unit>
        <trans-unit id="8bdd4953a2aaaf5875fdc9a6599aaccd9331209f" translate="yes" xml:space="preserve">
          <source>User-defined subroutines may choose to care whether they are being called in a void, scalar, or list context. Most subroutines do not need to bother, though. That's because both scalars and lists are automatically interpolated into lists. See &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt; for how you would dynamically discern your function's calling context.</source>
          <target state="translated">用户定义的子例程可以选择关心是否在void，标量或列表上下文中调用它们。不过，大多数子例程都不需要打扰。这是因为标量和列表都会自动插入列表中。有关如何动态识别函数的调用上下文的信息，请参见&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04b3f7fd0444d60354dbca146d3a101a49d16754" translate="yes" xml:space="preserve">
          <source>User-defined subroutines to handle options</source>
          <target state="translated">用户自定义处理选项的子程序。</target>
        </trans-unit>
        <trans-unit id="c2c8678cd5e840290be2cdc362d36d4139b6821c" translate="yes" xml:space="preserve">
          <source>User-mode threads are threads that live entirely within a program and its libraries. In this model, the OS knows nothing about threads. As far as it's concerned, your process is just a process.</source>
          <target state="translated">用户模式的线程是完全生活在程序及其库中的线程。在这种模式下,操作系统对线程一无所知。对于它来说,你的进程只是一个进程。</target>
        </trans-unit>
        <trans-unit id="5e4e64aff0ba218cc4ec3a0635d41a38135e5b7e" translate="yes" xml:space="preserve">
          <source>User::grent</source>
          <target state="translated">User::grent</target>
        </trans-unit>
        <trans-unit id="5e0090a6a9d55bf78a5f019a9872cf7e4308c124" translate="yes" xml:space="preserve">
          <source>User::grent - by-name interface to Perl's built-in getgr*() functions</source>
          <target state="translated">User::grent-Perl内置的getgr*()函数的按名接口</target>
        </trans-unit>
        <trans-unit id="a2bda03ecc876d5bf92fb7707c3e5918fe5160b9" translate="yes" xml:space="preserve">
          <source>User::pwent</source>
          <target state="translated">User::pwent</target>
        </trans-unit>
        <trans-unit id="c4a9575f1a385e0c0339a3155858dfaa2331a364" translate="yes" xml:space="preserve">
          <source>User::pwent - by-name interface to Perl's built-in getpw*() functions</source>
          <target state="translated">User::pwent-Perl内置的getpw*()函数的按名接口</target>
        </trans-unit>
        <trans-unit id="5dc8b5002e114f1d2e85c5074d99f142b8068508" translate="yes" xml:space="preserve">
          <source>Users of &lt;b&gt;vi&lt;/b&gt; should also look into &lt;b&gt;vim&lt;/b&gt; and &lt;b&gt;gvim&lt;/b&gt;, the mousey and windy version, for coloring of Perl keywords.</source>
          <target state="translated">&lt;b&gt;vi的&lt;/b&gt;用户还应该研究&lt;b&gt;vim&lt;/b&gt;和&lt;b&gt;gvim&lt;/b&gt;（鼠标和大风版本），以为Perl关键字着色。</target>
        </trans-unit>
        <trans-unit id="ba4927255994b8f9be2cf9331a8ecd222ec16885" translate="yes" xml:space="preserve">
          <source>Users of &lt;code&gt;Emacs&lt;/code&gt; would appreciate it very much, especially with &lt;code&gt;CPerl&lt;/code&gt; mode loaded. You need to get latest &lt;code&gt;pod2info&lt;/code&gt; from &lt;code&gt;CPAN&lt;/code&gt; , or, alternately, prebuilt info pages.</source>
          <target state="translated">&lt;code&gt;Emacs&lt;/code&gt; 的用户非常喜欢它，尤其是在加载了 &lt;code&gt;CPerl&lt;/code&gt; 模式的情况下。您需要从 &lt;code&gt;CPAN&lt;/code&gt; 获得最新的 &lt;code&gt;pod2info&lt;/code&gt; ，或者从预建的信息页面获得。</target>
        </trans-unit>
        <trans-unit id="06b3fe1f4b99439f17ea2b119c5a26871e0414f8" translate="yes" xml:space="preserve">
          <source>Users of Emacs would appreciate it very much, especially with &lt;code&gt;CPerl&lt;/code&gt; mode loaded. You need to get latest &lt;code&gt;pod2texi&lt;/code&gt; from &lt;code&gt;CPAN&lt;/code&gt; , or, alternately, the prebuilt info pages.</source>
          <target state="translated">Emacs的用户非常喜欢它，尤其是在加载了 &lt;code&gt;CPerl&lt;/code&gt; 模式的情况下。您需要从 &lt;code&gt;CPAN&lt;/code&gt; 或替代地从预制信息页面获取最新的 &lt;code&gt;pod2texi&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d37ee7e83ea8423b48a5461ba1696b2c860b013" translate="yes" xml:space="preserve">
          <source>Users of these operating systems may also wish to make use of scripts such as</source>
          <target state="translated">这些操作系统的用户也可以使用一些脚本,如</target>
        </trans-unit>
        <trans-unit id="5f2a2d2f970a65c0f069bae958a29d5ba1eb82f2" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;$Config{pod2html}&lt;/code&gt; to setup default options.</source>
          <target state="translated">使用 &lt;code&gt;$Config{pod2html}&lt;/code&gt; 设置默认选项。</target>
        </trans-unit>
        <trans-unit id="1bd665ac74aefc48e3c1dedcb2f5bc582892064f" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;strlen&lt;/code&gt; to get the length of &lt;code&gt;name&lt;/code&gt; , then calls &lt;code&gt;get_cvn_flags&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;strlen&lt;/code&gt; 获取 &lt;code&gt;name&lt;/code&gt; 的长度，然后调用 &lt;code&gt;get_cvn_flags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2d33b5a65c41c46d97dad83c368ba4c31fcb025" translate="yes" xml:space="preserve">
          <source>Uses Bourne shell from &lt;code&gt;$exedir/../dll/sh/ksh.exe&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;$exedir/../dll/sh/ksh.exe&lt;/code&gt; Bourne shell 。</target>
        </trans-unit>
        <trans-unit id="8535753d5756d418d77c7eeafa2177abcd178411" translate="yes" xml:space="preserve">
          <source>Uses Encode::from_to for conversion. This is the default.</source>
          <target state="translated">使用 Encode::from_to 进行转换。这是默认的。</target>
        </trans-unit>
        <trans-unit id="a78266e003805d15484a613ae3192f24c4a5e63f" translate="yes" xml:space="preserve">
          <source>Uses a single private buffer so if you want to format several strings you must explicitly copy the earlier strings away (and free the copies when you are done).</source>
          <target state="translated">使用一个单独的私有缓冲区,所以如果你想格式化几个字符串,你必须显式地复制早期的字符串(当你完成时释放副本)。</target>
        </trans-unit>
        <trans-unit id="fce3093136a7d2638de72d1f6b19af95e4dd37ba" translate="yes" xml:space="preserve">
          <source>Uses for the &lt;code&gt;export_fail&lt;/code&gt; method include giving better error messages for some symbols and performing lazy architectural checks (put more symbols into &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; by default and then take them out if someone actually tries to use them and an expensive check shows that they are usable on that platform).</source>
          <target state="translated">&lt;code&gt;export_fail&lt;/code&gt; 方法的用法包括为某些符号提供更好的错误消息，以及执行懒惰的体系结构检查（默认情况下，将更多符号放入 &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; ，然后在有人尝试使用它们的情况下将其取出，而昂贵的检查则表明它们可用于该对象）平台）。</target>
        </trans-unit>
        <trans-unit id="ff51dbb10de4f730c3d10cc9e64e2774f2375b58" translate="yes" xml:space="preserve">
          <source>Uses the same algorithm as getcwd(). Symbolic links and relative-path components (&quot;.&quot; and &quot;..&quot;) are resolved to return the canonical pathname, just like realpath(3).</source>
          <target state="translated">使用与 getcwd()相同的算法。符号链接和相对路径组件 (&quot;.&quot;和&quot;.&quot;)被解析为返回规范路径名,就像 realpath(3)一样。</target>
        </trans-unit>
        <trans-unit id="9086306446f5bee7eedc51873f977f5639cf3890" translate="yes" xml:space="preserve">
          <source>Uses the value of EXPR as a filename and executes the contents of the file as a Perl script.</source>
          <target state="translated">使用EXPR的值作为文件名,并将文件的内容作为Perl脚本执行。</target>
        </trans-unit>
        <trans-unit id="b191f377109544e991562530e982f3ab20d97a29" translate="yes" xml:space="preserve">
          <source>Uses the value of a previous getpos call to return to a previously visited position. Returns &quot;0 but true&quot; on success, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">使用以前的getpos调用的值返回到以前访问的位置。成功返回&amp;ldquo; 0但为真&amp;rdquo;，失败返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c25de2e83e9fceeee022a34e378748baf14ac201" translate="yes" xml:space="preserve">
          <source>Using</source>
          <target state="translated">Using</target>
        </trans-unit>
        <trans-unit id="2352b330d6ed131b0eecd5f3967c2801dc2e677c" translate="yes" xml:space="preserve">
          <source>Using &quot;#&quot; as a padding character specifies a numeric field, with right justification. An optional &quot;.&quot; defines the position of the decimal point. With a &quot;0&quot; (zero) instead of the first &quot;#&quot;, the formatted number will be padded with leading zeroes if necessary. A special numeric field is blanked out if the value is undefined. If the resulting value would exceed the width specified the field is filled with &quot;#&quot; as overflow evidence.</source>
          <target state="translated">使用 &quot;#&quot;作为填充字符,指定一个数字字段,并对其进行右对齐。一个可选的&quot;.&quot;定义了小数点的位置。用 &quot;0&quot;(零)代替第一个 &quot;#&quot;,必要时,格式化的数字将用前导零填充。如果数值未定义,特殊的数字字段将被清空。如果产生的值会超过指定的宽度,则用 &quot;#&quot;填充该字段作为溢出证据。</target>
        </trans-unit>
        <trans-unit id="4d195a30219da687f66f5ac2e4c6c839d91fc335" translate="yes" xml:space="preserve">
          <source>Using &quot;&amp;gt;&quot; always clobbers or creates. Using &quot;&amp;lt;&quot; never does either. The &quot;+&quot; doesn't change this.</source>
          <target state="translated">使用&amp;ldquo;&amp;gt;&amp;rdquo;总是掩盖或创造。使用&amp;ldquo; &amp;lt;&amp;rdquo;也不会。&amp;ldquo; +&amp;rdquo;号不会更改此设置。</target>
        </trans-unit>
        <trans-unit id="16cc068fbb7f0118050467d326f37173d537b721" translate="yes" xml:space="preserve">
          <source>Using &quot;pl2bat&quot; has a few problems: the file name gets changed, so scripts that rely on &lt;code&gt;$0&lt;/code&gt; to find what they must do may not run properly; running &quot;pl2bat&quot; replicates the contents of the original script, and so this process can be maintenance intensive if the originals get updated often. A different approach that avoids both problems is possible.</source>
          <target state="translated">使用&amp;ldquo; pl2bat&amp;rdquo;有几个问题：文件名被更改，因此依赖 &lt;code&gt;$0&lt;/code&gt; 来查找必须执行的操作的脚本可能无法正常运行；运行&amp;ldquo; pl2bat&amp;rdquo;将复制原始脚本的内容，因此，如果经常更新原始脚本，则此过程可能需要大量维护。避免这两个问题的另一种方法是可能的。</target>
        </trans-unit>
        <trans-unit id="05f631394c6e9641817e0e504fc7c43b66232fc2" translate="yes" xml:space="preserve">
          <source>Using $ENV{PERL_DEBUG_MSTATS}</source>
          <target state="translated">使用 $ENV{PERL_DEBUG_MSTATS}。</target>
        </trans-unit>
        <trans-unit id="369ff12968f332b6148e74df2b66edfe0b032cb0" translate="yes" xml:space="preserve">
          <source>Using 'X' and cousins requires you not to use the type identifiers ($@%), just the 'name':</source>
          <target state="translated">使用'X'和表兄弟需要你不使用类型标识符($@%),只使用'名称'。</target>
        </trans-unit>
        <trans-unit id="2dfddf8d7a196c4e7f1fa3524316075003cbc8ac" translate="yes" xml:space="preserve">
          <source>Using *AutoLoader*'s AUTOLOAD Subroutine</source>
          <target state="translated">使用*AutoLoader*的AUTOLOAD子程序。</target>
        </trans-unit>
        <trans-unit id="9094fd1811fd7f32bf808bb09cf11c4c4b959972" translate="yes" xml:space="preserve">
          <source>Using / for Unix. Called by init_main.</source>
          <target state="translated">在Unix中使用/,由init_main调用。由 init_main 调用。</target>
        </trans-unit>
        <trans-unit id="ef6fd37cde410d5e8c4989d291b7ed857f9e1011" translate="yes" xml:space="preserve">
          <source>Using //-comments</source>
          <target state="translated">使用//-comments</target>
        </trans-unit>
        <trans-unit id="5f4a15910e3dadf2cc006c6867eda30e63f7dc0f" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="9e6665571474aeb5014d9a2187041b82aa2b6cf9" translate="yes" xml:space="preserve">
          <source>Using &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD Subroutine</source>
          <target state="translated">使用&lt;b&gt;AutoLoader&lt;/b&gt;的AUTOLOAD子例程</target>
        </trans-unit>
        <trans-unit id="5cfa1c0592cc7196c9a7f1e7194e067f8fe4c528" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&quot;or&quot;&lt;/code&gt; for assignment is unlikely to do what you want; see below.</source>
          <target state="translated">使用 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 进行分配不太可能做您想要的；见下文。</target>
        </trans-unit>
        <trans-unit id="8a303f25d71d0c242dc6c0e5ae7c606b1bec2045" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$ENV{PERL_DEBUG_MSTATS}&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;$ENV{PERL_DEBUG_MSTATS}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6ff3dae92bc192e26ee0eb7af7182c12b0e7db8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$in_fh-&amp;gt;getline()&lt;/code&gt; , input is read line-by-line and assembled into paragraphs or &quot;blocks&quot; (which are separated by lines containing nothing but whitespace). For each block of POD documentation encountered it will invoke a method to parse the given paragraph.</source>
          <target state="translated">使用 &lt;code&gt;$in_fh-&amp;gt;getline()&lt;/code&gt; ，输入被逐行读取，并组装成段落或&amp;ldquo;块&amp;rdquo;（由空格分隔的行分隔）。对于遇到的POD文档的每个块，它将调用一种方法来解析给定的段落。</target>
        </trans-unit>
        <trans-unit id="f2a68f677fc4720bdeb7e4f8032c1c375f4d6291" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--verbose&lt;/code&gt; on the command line will increment the value of &lt;code&gt;$verbose&lt;/code&gt; . This way the program can keep track of how many times the option occurred on the command line. For example, each occurrence of &lt;code&gt;--verbose&lt;/code&gt; could increase the verbosity level of the program.</source>
          <target state="translated">在命令行上使用 &lt;code&gt;--verbose&lt;/code&gt; 将增加 &lt;code&gt;$verbose&lt;/code&gt; 的值。这样，程序可以跟踪该选项在命令行上发生了多少次。例如，-- &lt;code&gt;--verbose&lt;/code&gt; 每次出现都可能增加程序的详细程度。</target>
        </trans-unit>
        <trans-unit id="4ad1d7060df6581913c9f5f84ab874f296c32585" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; rather than &lt;code&gt;-Dusemultiplicity&lt;/code&gt; is more appropriate if you intend to run multiple interpreters concurrently in different threads, because it enables support for linking in the thread libraries of your system with the interpreter.</source>
          <target state="translated">如果您打算在不同的线程中同时运行多个解释器，则使用 &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; 而不是 &lt;code&gt;-Dusemultiplicity&lt;/code&gt; 更为合适，因为它支持在系统的线程库中使用解释器进行链接。</target>
        </trans-unit>
        <trans-unit id="61eab4185699c92641d9413479e73b37872fd212" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; out to another perl after loading multiple dlls may result on a DLL baseaddress conflict. The internal cygwin error looks like like the following:</source>
          <target state="translated">在加载多个dll之后使用 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 移出另一个perl可能会导致DLL基址冲突。内部cygwin错误如下所示：</target>
        </trans-unit>
        <trans-unit id="fcca95252686536518c82a86f093a53ca5ff8ade" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; in combination with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; at the top of your Perl scripts means that the interpreter will pick up certain common programming errors. For instance, in the example above, the final &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $y&lt;/code&gt; would cause a compile-time error and prevent you from running the program. Using &lt;code&gt;strict&lt;/code&gt; is highly recommended.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; 结合&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;；Perl脚本顶部的表示解释器将拾取某些常见的编程错误。例如，在上面的示例中，最终的 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $y&lt;/code&gt; 将导致编译时错误并阻止您运行该程序。强烈建议使用 &lt;code&gt;strict&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6570099c968b1dac1aeada91a2fa62948e513fde" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c4ee3a2331f58e1266f76a324d649c5e7a530542" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(..., $x)&lt;/code&gt; with &lt;code&gt;P&lt;/code&gt; or &lt;code&gt;p&lt;/code&gt; to get the address where &lt;code&gt;$x&lt;/code&gt; is actually stored must be used with circumspection. Perl's internal machinery considers the relation between a variable and that address as its very own private matter and doesn't really care that we have obtained a copy. Therefore:</source>
          <target state="translated">必须结合使用带 &lt;code&gt;P&lt;/code&gt; 或 &lt;code&gt;p&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(..., $x)&lt;/code&gt; 来获取 &lt;code&gt;$x&lt;/code&gt; 实际存储的地址。Perl的内部机制将变量和该地址之间的关系视为其自身的私人事务，并不在乎我们是否已获得副本。因此：</target>
        </trans-unit>
        <trans-unit id="f64f7e3c602eac9f0cc5d3fae9a96d9a3eb0bb0b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5fe85d80b5d4e554e757435dadbee8779f515048" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; for larger strings:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 较大字符串：</target>
        </trans-unit>
        <trans-unit id="77bac2c89d98d4342e51014bdc1e5dfcf83f7405" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9b2ba3ba2d555e75ce68454a406fe0f0433207e8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; (or the operator form, &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; ) as the conditional of a &lt;code&gt;for&lt;/code&gt; loop is shorthand for the following. This behaviour is the same as a &lt;code&gt;while&lt;/code&gt; loop conditional.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; （或运算符形式， &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; ）作为 &lt;code&gt;for&lt;/code&gt; 循环的条件是以下内容的简写。此行为与 &lt;code&gt;while&lt;/code&gt; 循环条件相同。</target>
        </trans-unit>
        <trans-unit id="48ea9a8aca48a2ecece519f0da9a5610c9c21b22" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; (perl 5.6+):</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; （perl 5.6+）：</target>
        </trans-unit>
        <trans-unit id="672d9d441ef641164ca3c34a7892f3146881bd19" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="46b9c6aa21d990c3320125b6b398a58171b824d2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c96b7be56d606a5173254b9ecaa85e8754516cc1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;C0&lt;/code&gt; to get Unicode characters while using &lt;code&gt;U0&lt;/code&gt; to get</source>
          <target state="translated">使用 &lt;code&gt;C0&lt;/code&gt; 获取Unicode字符，而使用 &lt;code&gt;U0&lt;/code&gt; 获取</target>
        </trans-unit>
        <trans-unit id="bd76d249b9cc849b475f04243607bd5ac606dc24" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;EVERY&lt;/code&gt; methods</source>
          <target state="translated">使用 &lt;code&gt;EVERY&lt;/code&gt; 一种方法</target>
        </trans-unit>
        <trans-unit id="0ecd1ec7133eb6a574dc47a89387830a895fdc67" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;autouse&lt;/code&gt; will move important steps of your program's execution from compile time to runtime. This can</source>
          <target state="translated">使用 &lt;code&gt;autouse&lt;/code&gt; 使用将使程序执行的重要步骤从编译时移至运行时。这个可以</target>
        </trans-unit>
        <trans-unit id="2c94e397182ad35f0199796c485d6c8aec54e54f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;gen_extract_tagged&lt;/code&gt; to create extraction functions for specific tags is a good idea if those functions are going to be called more than once, since their performance is typically twice as good as the more general-purpose &lt;code&gt;extract_tagged&lt;/code&gt; .</source>
          <target state="translated">如果要多次调用这些函数，则使用 &lt;code&gt;gen_extract_tagged&lt;/code&gt; 创建特定标签的提取函数是一个好主意，因为它们的性能通常是更通用的 &lt;code&gt;extract_tagged&lt;/code&gt; 的两倍。</target>
        </trans-unit>
        <trans-unit id="5b55d7735ea783b5e6004e758bd55af4f884bf92" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;lib&lt;/code&gt; warns if none of the specified libraries can be found and &lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt; did fall back to one of the default libraries. To suppress this warning, use &lt;code&gt;try&lt;/code&gt; instead:</source>
          <target state="translated">如果找不到指定的库，并且使用&lt;a href=&quot;math/bigint&quot;&gt;Math :: BigInt会&lt;/a&gt;退回到默认库之一，则使用 &lt;code&gt;lib&lt;/code&gt; 会发出警告。要禁止显示此警告，请改用 &lt;code&gt;try&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0ffd8ad58b1a0f4bd73c5c83cc872616c113bd7f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;refaddr()&lt;/code&gt; is unreliable for testing whether or not two shared references are equivalent (e.g., when testing for circular references). Use &lt;a href=&quot;#is_shared-VARIABLE&quot;&gt;is_shared()&lt;/a&gt;, instead:</source>
          <target state="translated">使用 &lt;code&gt;refaddr()&lt;/code&gt; 来测试两个共享引用是否等效是不可靠的（例如，在测试循环引用时）。使用&lt;a href=&quot;#is_shared-VARIABLE&quot;&gt;is_shared（）&lt;/a&gt;代替：</target>
        </trans-unit>
        <trans-unit id="2ef178ae90603162abddf22f7d9bb0fc3e898af5" translate="yes" xml:space="preserve">
          <source>Using Attributes and Parameters</source>
          <target state="translated">使用属性和参数</target>
        </trans-unit>
        <trans-unit id="03bf2717e06af78329e93ebf453e1e826613e2e4" translate="yes" xml:space="preserve">
          <source>Using B::Concise outside of the O framework</source>
          <target state="translated">在O框架外使用B::Concise。</target>
        </trans-unit>
        <trans-unit id="18bafced67519d44baeebd7cfdcaf662b62afabc" translate="yes" xml:space="preserve">
          <source>Using DB_File with Berkeley DB version 2 or greater</source>
          <target state="translated">在Berkeley DB 2或更高版本中使用DB_File。</target>
        </trans-unit>
        <trans-unit id="97e4ec7dc3ee57617b8c25e5da7b2620a2b30764" translate="yes" xml:space="preserve">
          <source>Using EVERY methods</source>
          <target state="translated">使用所有方法</target>
        </trans-unit>
        <trans-unit id="eaf5424654cdf470f964dbc03078a17cf18e6b68" translate="yes" xml:space="preserve">
          <source>Using Encode</source>
          <target state="translated">使用 Encode</target>
        </trans-unit>
        <trans-unit id="b3c01fd9731ccf33cc32d289966ab7fb5c9b6f88" translate="yes" xml:space="preserve">
          <source>Using Fill Mode</source>
          <target state="translated">使用填充模式</target>
        </trans-unit>
        <trans-unit id="5cb7c472310d76de5801b53745949b0358783728" translate="yes" xml:space="preserve">
          <source>Using Filter::Simple and Exporter together</source>
          <target state="translated">同时使用Filter::Simple和Exporter</target>
        </trans-unit>
        <trans-unit id="8adffc36e41ac8b6ef194fa0464f19be3d960928" translate="yes" xml:space="preserve">
          <source>Using Filter::Simple with an explicit &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine</source>
          <target state="translated">使用Filter :: Simple和一个显式 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程</target>
        </trans-unit>
        <trans-unit id="4fae20bc9d38356a2d17453bc9b205cc1c897f19" translate="yes" xml:space="preserve">
          <source>Using Filter::Simple with an explicit import subroutine</source>
          <target state="translated">使用Filter::Simple的显式导入子程序。</target>
        </trans-unit>
        <trans-unit id="1ae3259ed8aaec135b40d3c0be57406133a41acb" translate="yes" xml:space="preserve">
          <source>Using GIMME_V</source>
          <target state="translated">使用GIMME_V</target>
        </trans-unit>
        <trans-unit id="1d57725fba088f8b24d927a2eedcfd4e936a608f" translate="yes" xml:space="preserve">
          <source>Using GNU's gcc for building Perl</source>
          <target state="translated">使用GNU的gcc来构建Perl</target>
        </trans-unit>
        <trans-unit id="e882257535f024e0d015187d37538f63a8847fce" translate="yes" xml:space="preserve">
          <source>Using G_EVAL</source>
          <target state="translated">使用G_EVAL</target>
        </trans-unit>
        <trans-unit id="295eff162915babd344155c6be19db49d4d64f02" translate="yes" xml:space="preserve">
          <source>Using G_KEEPERR</source>
          <target state="translated">使用G_KEEPERR</target>
        </trans-unit>
        <trans-unit id="16d5f49af97261f97893047f771a98e55443d77c" translate="yes" xml:space="preserve">
          <source>Using Large Files with Perl</source>
          <target state="translated">用Perl使用大文件</target>
        </trans-unit>
        <trans-unit id="317a1b556565aa526e2b302cc529d9bc9bad8e03" translate="yes" xml:space="preserve">
          <source>Using Large Files with Perl &amp;lt; 5L</source>
          <target state="translated">使用Perl &amp;lt;5L的大文件</target>
        </trans-unit>
        <trans-unit id="4193d5877700c1da7cc3dc0d04426fb8e279c514" translate="yes" xml:space="preserve">
          <source>Using Large Files with Perl on HP-UX</source>
          <target state="translated">在HP-UX上使用Perl的大文件</target>
        </trans-unit>
        <trans-unit id="bb8e5976c90f08c21142951c3aacf31e66206c3b" translate="yes" xml:space="preserve">
          <source>Using Large Files with Perl on Tru64</source>
          <target state="translated">在 Tru64 上使用 Perl 的大文件</target>
        </trans-unit>
        <trans-unit id="d35a8b92c0313948c8001f6e0f5a80140456f638" translate="yes" xml:space="preserve">
          <source>Using Math::BigInt::Lite</source>
          <target state="translated">使用 Math::BigInt::Lite</target>
        </trans-unit>
        <trans-unit id="f4a9198bb8db024f66e7beddb02099ae2c33e45d" translate="yes" xml:space="preserve">
          <source>Using POSIX::ARG_MAX. Otherwise falling back to 4096.</source>
          <target state="translated">使用POSIX::ARG_MAX。否则回落到4096。</target>
        </trans-unit>
        <trans-unit id="7f350838d7d6c4618cf4c3624992c0a5fa550ccf" translate="yes" xml:space="preserve">
          <source>Using Perl in &quot;native&quot; BS2000</source>
          <target state="translated">在 &quot;本地 &quot;BS2000中使用Perl</target>
        </trans-unit>
        <trans-unit id="adbb3dbb566652d469c92e143d370e6625a585c4" translate="yes" xml:space="preserve">
          <source>Using Perl in OS/400 PASE</source>
          <target state="translated">在OS/400 PASE中使用Perl</target>
        </trans-unit>
        <trans-unit id="2f91327799ddf2016004ebaf8e8d6bedda20acf6" translate="yes" xml:space="preserve">
          <source>Using Perl in Symbian</source>
          <target state="translated">在Symbian中使用Perl</target>
        </trans-unit>
        <trans-unit id="6d719543bb32291214db915134a27443927a8c27" translate="yes" xml:space="preserve">
          <source>Using Perl in the Posix-Shell of BS2000</source>
          <target state="translated">在BS2000的Posix-Shell中使用Perl。</target>
        </trans-unit>
        <trans-unit id="84118c01838e699ac467fa37b8bb29a7f8370768" translate="yes" xml:space="preserve">
          <source>Using Perl modules</source>
          <target state="translated">使用Perl模块</target>
        </trans-unit>
        <trans-unit id="028de32ca6d30212bfbce4a0c1bee8b8576b4e69" translate="yes" xml:space="preserve">
          <source>Using Perl modules, which themselves use C libraries, from your C program</source>
          <target state="translated">从你的C程序中使用Perl模块,这些模块本身也使用C库</target>
        </trans-unit>
        <trans-unit id="0ff9818b99a67e75450030e8c7e7092cbe65f9c0" translate="yes" xml:space="preserve">
          <source>Using Perl on WinCE</source>
          <target state="translated">在WinCE上使用Perl</target>
        </trans-unit>
        <trans-unit id="a5580cc662de9455c8f221545dacc2b26132369a" translate="yes" xml:space="preserve">
          <source>Using Perl to Dispose of Temporaries</source>
          <target state="translated">使用Perl来处理临时文件</target>
        </trans-unit>
        <trans-unit id="5320f15bf6dff40493f314bd488164951d124fee" translate="yes" xml:space="preserve">
          <source>Using Perl to dispose of temporaries</source>
          <target state="translated">使用Perl来处理临时文件</target>
        </trans-unit>
        <trans-unit id="b797430b32d30f68c1ea4534b74218539d3aaf64" translate="yes" xml:space="preserve">
          <source>Using Perl's built in conversion of numbers with leading zeros:</source>
          <target state="translated">使用Perl内置的带前导零的数字转换。</target>
        </trans-unit>
        <trans-unit id="f15ed3b42ac67b1af9e23e97edaf317ed0b825a6" translate="yes" xml:space="preserve">
          <source>Using PerlIO and different encodings on ASCII and EBCDIC partitions</source>
          <target state="translated">在ASCII和EBCDIC分区上使用PerlIO和不同的编码。</target>
        </trans-unit>
        <trans-unit id="36711385fbee8d56f23de9017ef392314347e2e0" translate="yes" xml:space="preserve">
          <source>Using References</source>
          <target state="translated">使用参考文献</target>
        </trans-unit>
        <trans-unit id="82685302632dac9e1fd31a13c0849aefa5124be7" translate="yes" xml:space="preserve">
          <source>Using Unicode in XS</source>
          <target state="translated">在XS中使用Unicode</target>
        </trans-unit>
        <trans-unit id="998956ebf62d14d931cc7ad656bc083d855b7aba" translate="yes" xml:space="preserve">
          <source>Using XS With C++</source>
          <target state="translated">使用XS与C++</target>
        </trans-unit>
        <trans-unit id="dac1e6f7cf5fb38291cdecac855edeefdf437f99" translate="yes" xml:space="preserve">
          <source>Using \ for Windows, except for &quot;gmake&quot; where it is /.</source>
          <target state="translated">在Windows中使用/,除了 &quot;gmake &quot;是/。</target>
        </trans-unit>
        <trans-unit id="8137c8c1ed484dbce9760788d8ea8483549cf1f0" translate="yes" xml:space="preserve">
          <source>Using _t/harness_ for testing</source>
          <target state="translated">使用_t/harness_进行测试</target>
        </trans-unit>
        <trans-unit id="4f4b906f20b028b71f5628fd6f90032d406f6155" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;__WARN__&lt;/code&gt; handler provides a powerful way to silence all warnings (even the so-called mandatory ones). An example:</source>
          <target state="translated">使用 &lt;code&gt;__WARN__&lt;/code&gt; 处理程序提供了一种使所有警告（甚至是强制性警告）静音的强大方法。一个例子：</target>
        </trans-unit>
        <trans-unit id="b4b4ca6e1deabca931233328798f7fbb48c8c07b" translate="yes" xml:space="preserve">
          <source>Using a closure as a function template allows us to generate many functions that act similarly. Suppose you wanted functions named after the colors that generated HTML font changes for the various colors:</source>
          <target state="translated">使用一个闭包作为函数模板,我们可以生成许多作用类似的函数。假设你想要以颜色命名的函数,生成各种颜色的HTML字体变化。</target>
        </trans-unit>
        <trans-unit id="3428ced333d3144f878ace997075432ead893fb6" translate="yes" xml:space="preserve">
          <source>Using a hash reference is</source>
          <target state="translated">使用哈希引用是</target>
        </trans-unit>
        <trans-unit id="336ecaf20b3b819b2df81459841f824dd710f158" translate="yes" xml:space="preserve">
          <source>Using a lexical pragma to enable or disable legacy behavior should be considered when appropriate, and in the absence of any pragma legacy behavior should be enabled. Which backward-incompatible changes are controlled implicitly by a 'use v5.x.y' is a decision which should be made by the pumpking in consultation with the community.</source>
          <target state="translated">在适当的时候,应该考虑使用词法pragma来启用或禁用遗留行为,在没有任何pragma的情况下,应该启用遗留行为。哪些向后不兼容的变化是由'使用v5.x.y'来隐含控制的,这是一个应该由泵金与社区协商后做出的决定。</target>
        </trans-unit>
        <trans-unit id="37d264a714cc8982079f31352e5a02a2d407c9ec" translate="yes" xml:space="preserve">
          <source>Using a reference as a string produces both its referent's type, including any package blessing as described in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;, as well as the numeric address expressed in hex. The ref() operator returns just the type of thing the reference is pointing to, without the address. See &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; for details and examples of its use.</source>
          <target state="translated">将引用用作字符串会同时产生其引用对象的类型，包括&lt;a href=&quot;perlobj&quot;&gt;perlobj中&lt;/a&gt;描述的所有程序包祝福以及以十六进制表示的数字地址。ref（）运算符仅返回引用指向的事物的类型，而不返回地址。有关详细信息及其使用示例，请参见&lt;a href=&quot;functions/ref&quot;&gt;参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="178dbf3b1655da796ad383968646cf6aaa7b961a" translate="yes" xml:space="preserve">
          <source>Using a regular Perl string as a key or value for a DBM hash will trigger a wide character exception if any codepoints won&amp;rsquo;t fit into a byte. Here&amp;rsquo;s how to manually manage the translation:</source>
          <target state="translated">如果任何代码点都不适合字节，则使用常规Perl字符串作为DBM哈希的键或值将触发宽字符异常。以下是手动管理翻译的方法：</target>
        </trans-unit>
        <trans-unit id="544cb5d954d39b68ec105da285e699133ee66333" translate="yes" xml:space="preserve">
          <source>Using a slice on the lefthand side of the assignment supplies list context to the righthand side. This can lead to unexpected results. For instance, if you want to read a single line from a filehandle, assigning to a scalar value is fine:</source>
          <target state="translated">在任务的左手边使用分片为右手边提供列表上下文。这可能会导致意想不到的结果。例如,如果你想从一个文件柄中读取一行,分配给一个标量值就可以了。</target>
        </trans-unit>
        <trans-unit id="047ab6347496bdbb043bb75da5faf973242f2e7a" translate="yes" xml:space="preserve">
          <source>Using a source-level debugger</source>
          <target state="translated">使用源码级调试器</target>
        </trans-unit>
        <trans-unit id="5e1e5b1c335e1407e117badbc02a20174cee06fd" translate="yes" xml:space="preserve">
          <source>Using a string or number as a reference produces a symbolic reference, as explained above. Using a reference as a number produces an integer representing its storage location in memory. The only useful thing to be done with this is to compare two references numerically to see whether they refer to the same location.</source>
          <target state="translated">如上所述,使用字符串或数字作为引用会产生一个符号引用。将一个引用作为数字使用会产生一个整数,代表它在内存中的存储位置。唯一有用的是用数字比较两个引用,看它们是否指向同一个位置。</target>
        </trans-unit>
        <trans-unit id="d9e91a5896764f48c6ace56fa4d53091e1acc312" translate="yes" xml:space="preserve">
          <source>Using a subroutine as part of your sort is a powerful way to get exactly what you want, but will usually be slower than the built-in</source>
          <target state="translated">使用子程序作为排序的一部分,是获得你想要的东西的强大方法,但通常会比内置的</target>
        </trans-unit>
        <trans-unit id="2a79ecdd0e9982d50231f84c62b552b6746f4f38" translate="yes" xml:space="preserve">
          <source>Using a value of &lt;code&gt;'IGNORE'&lt;/code&gt; usually has the effect of ignoring the signal, except for the &lt;code&gt;CHLD&lt;/code&gt; signal. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more about this special case.</source>
          <target state="translated">使用值 &lt;code&gt;'IGNORE'&lt;/code&gt; 通常具有忽略信号的效果，但 &lt;code&gt;CHLD&lt;/code&gt; 信号除外。有关此特殊情况的更多信息，请参见&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4df5e3fd8acd272c23a1963f6dc8693fe3a9c164" translate="yes" xml:space="preserve">
          <source>Using an indirect object with &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; is also more secure. This usage (which also works fine with system()) forces interpretation of the arguments as a multivalued list, even if the list had just one argument. That way you're safe from the shell expanding wildcards or splitting up words with whitespace in them.</source>
          <target state="translated">将间接对象与 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 一起使用也更安全。这种用法（在system（）中也可以正常工作）强制将参数解释为多值列表，即使列表只有一个参数也是如此。这样一来，您就可以避免shell扩展通配符或拆分包含空格的单词。</target>
        </trans-unit>
        <trans-unit id="44d98963d401217f7be5255c87293a2853856e67" translate="yes" xml:space="preserve">
          <source>Using an indirect object with &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; is also more secure. This usage (which also works fine with system()) forces interpretation of the arguments as a multivalued list, even if the list had just one argument. That way you're safe from the shell expanding wildcards or splitting up words with whitespace in them.</source>
          <target state="translated">将间接对象与 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 一起使用也更安全。这种用法（在system（）中也可以正常工作）强制将参数解释为多值列表，即使列表只有一个参数也是如此。这样一来，您就可以避免shell扩展通配符或拆分包含空格的单词。</target>
        </trans-unit>
        <trans-unit id="604eef1aa9c7558fedd10f863a9440cef58a337c" translate="yes" xml:space="preserve">
          <source>Using an installation prefix of '/usr' will result in a directory layout that mirrors that of Apple's default Perl, with core modules stored in '/System/Library/Perl/${version}', CPAN modules stored in '/Library/Perl/${version}', and the addition of '/Network/Library/Perl/${version}' to @INC for modules that are stored on a file server and used by many Macs.</source>
          <target state="translated">使用'/usr'的安装前缀会导致目录布局与苹果默认的Perl一致,核心模块存储在'/System/Library/Perl/${version}',CPAN模块存储在'/Library/Perl/${version}',对于存储在文件服务器上且被许多Mac使用的模块,则需要在@INC中添加'/Network/Library/Perl/${version}'。</target>
        </trans-unit>
        <trans-unit id="aa23c98317fa566c477de2941d147e87b315123e" translate="yes" xml:space="preserve">
          <source>Using an object as the left operand is allowed, although not very useful. Smartmatching rules take precedence over overloading, so even if the object in the left operand has smartmatch overloading, this will be ignored. A left operand that is a non-overloaded object falls back on a string or numeric comparison of whatever the &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; operator returns. That means that</source>
          <target state="translated">允许使用对象作为左操作数，尽管不是很有用。智能匹配规则优先于重载，因此即使左侧操作数中的对象具有智能匹配重载，也会将其忽略。左操作数是一个未重载的对象，它依赖于 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 运算符返回的任何字符串或数字比较。那意味着</target>
        </trans-unit>
        <trans-unit id="6e3237ae31bb37c81782ea50be28770f0de2555e" translate="yes" xml:space="preserve">
          <source>Using any of the above invocations, the first argument to the constructor is always the corresponding package name (or object reference). No other arguments are required, but if desired, an associative array (or hash-table) my be passed to the &lt;b&gt;new()&lt;/b&gt; constructor, as in:</source>
          <target state="translated">使用上述任何调用，构造函数的第一个参数始终是对应的包名称（或对象引用）。不需要其他参数，但是如果需要，可以将关联数组（或哈希表）传递给&lt;b&gt;new（）&lt;/b&gt;构造函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="8097e70784bcbb030b53b18d1acb24cd21f46737" translate="yes" xml:space="preserve">
          <source>Using arguments of the form &lt;code&gt;-Ldir&lt;/code&gt; and &lt;code&gt;-lname&lt;/code&gt; is recommended.</source>
          <target state="translated">建议使用 &lt;code&gt;-Ldir&lt;/code&gt; 和 &lt;code&gt;-lname&lt;/code&gt; 形式的参数。</target>
        </trans-unit>
        <trans-unit id="f6161aa0cd787955761dec12d0177c3ac026e9b0" translate="yes" xml:space="preserve">
          <source>Using call_argv</source>
          <target state="translated">使用call_argv</target>
        </trans-unit>
        <trans-unit id="9134163152acbc5710de0bd418aa078593a2b9c2" translate="yes" xml:space="preserve">
          <source>Using call_method</source>
          <target state="translated">使用call_method</target>
        </trans-unit>
        <trans-unit id="b881b2dfc007740bbb57d40d5226f14e171509f9" translate="yes" xml:space="preserve">
          <source>Using call_sv</source>
          <target state="translated">使用call_sv</target>
        </trans-unit>
        <trans-unit id="fa52cf5ccb980442f1ec3e9f0afd04690158c461" translate="yes" xml:space="preserve">
          <source>Using caret fields can produce lines where all fields are blank. You can suppress such lines by putting a &quot;~&quot; (tilde) character anywhere in the line. The tilde will be translated to a space upon output.</source>
          <target state="translated">使用卡擦字段可能会产生所有字段都是空白的行,你可以通过在行内任何地方添加&quot;~&quot;(tilde)字符来抑制这种行。您可以在行中的任何位置添加&quot;~&quot;(斜线)字符来抑制这种行。在输出时,小括号将被转换为空格。</target>
        </trans-unit>
        <trans-unit id="3b35e7b174dfce328e49d2c9b54ef677263d0168" translate="yes" xml:space="preserve">
          <source>Using caseless (&lt;code&gt;/i&lt;/code&gt;) regular expression matching.</source>
          <target state="translated">使用无大小写（ &lt;code&gt;/i&lt;/code&gt; ）正则表达式匹配。</target>
        </trans-unit>
        <trans-unit id="912a2aec3bed273542aa33d8ea10bb43e6f23900" translate="yes" xml:space="preserve">
          <source>Using character classes</source>
          <target state="translated">使用字符类</target>
        </trans-unit>
        <trans-unit id="0ed204e094dc9752d186724902c15a617f19dc27" translate="yes" xml:space="preserve">
          <source>Using diagnostics to get stack traces from a misbehaving script:</source>
          <target state="translated">使用诊断程序从行为不当的脚本中获取堆栈痕迹。</target>
        </trans-unit>
        <trans-unit id="6d1350125897c58fd7a177587a74cb5b6d024e7d" translate="yes" xml:space="preserve">
          <source>Using double angle brackets inside of a while causes the open to use the three argument form (with the second argument being &lt;code&gt;&amp;lt;&lt;/code&gt; ), so all arguments in &lt;code&gt;ARGV&lt;/code&gt; are treated as literal filenames (including &lt;code&gt;&quot;-&quot;&lt;/code&gt; ). (Note that for convenience, if you use &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; and if &lt;code&gt;@ARGV&lt;/code&gt; is empty, it will still read from the standard input.)</source>
          <target state="translated">在while内使用双尖括号会使open使用三个参数形式（第二个参数为 &lt;code&gt;&amp;lt;&lt;/code&gt; ），因此 &lt;code&gt;ARGV&lt;/code&gt; 中的所有参数都被视为文字文件名（包括 &lt;code&gt;&quot;-&quot;&lt;/code&gt; ）。（请注意，为方便起见，如果使用 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; ，并且 &lt;code&gt;@ARGV&lt;/code&gt; 为空，它仍将从标准输入中读取。）</target>
        </trans-unit>
        <trans-unit id="87082cc66c652c8a0a8c6cf8ba8fff9479b0be7a" translate="yes" xml:space="preserve">
          <source>Using either $MM-&amp;gt;{uc $var} || $Config{lc $var}, it will attempt to replace it's $prefix with a $new_prefix.</source>
          <target state="translated">使用$ MM-&amp;gt; {uc $ var} || $ Config {lc $ var}，它将尝试用$ new_prefix替换其$ prefix。</target>
        </trans-unit>
        <trans-unit id="215bd29754319db34f811a8f9488126e67fb90a8" translate="yes" xml:space="preserve">
          <source>Using embedded Perl with POSIX locales</source>
          <target state="translated">使用嵌入式Perl和POSIX语言</target>
        </trans-unit>
        <trans-unit id="b18845c29a07642058d0aa5ccceaac4ae90f9d59" translate="yes" xml:space="preserve">
          <source>Using gcc statement expressions</source>
          <target state="translated">使用gcc语句表达式</target>
        </trans-unit>
        <trans-unit id="2fe92cd4a689f7ce76bfa5b984e6c38acace0732" translate="yes" xml:space="preserve">
          <source>Using gcc-3.x (tested with 3.0.4, 3.1, and 3.2) now works out of the box, as do recent gcc-2.9 builds available directly from IBM as part of their Linux compatibility packages, available here:</source>
          <target state="translated">使用gcc-3.x(用3.0.4、3.1和3.2测试)现在可以开箱即用,最近的gcc-2.9构建版也可以直接从IBM的Linux兼容包中获得,这里有。</target>
        </trans-unit>
        <trans-unit id="bdb0c9c540b125781f1757da970ccae106c403a1" translate="yes" xml:space="preserve">
          <source>Using gdb to look at specific parts of a program</source>
          <target state="translated">使用gdb查看程序的特定部分</target>
        </trans-unit>
        <trans-unit id="57bf0c1d6a34f5d8784552210b62d448a2b10410" translate="yes" xml:space="preserve">
          <source>Using gdb to look at what the parser/lexer are doing</source>
          <target state="translated">使用gdb查看解析器/lexer正在做什么。</target>
        </trans-unit>
        <trans-unit id="29fde3627eec5ec683270fb27481ef8c0d1c38c6" translate="yes" xml:space="preserve">
          <source>Using independent subexpressions to prevent backtracking</source>
          <target state="translated">使用独立的子表达式来防止回溯。</target>
        </trans-unit>
        <trans-unit id="31ab5d33d67aac1b9f2ccad1cbfd447894360c2b" translate="yes" xml:space="preserve">
          <source>Using logically paired delimiters can be even more readable:</source>
          <target state="translated">使用逻辑上成对的定界符可以更易读。</target>
        </trans-unit>
        <trans-unit id="3a44a3d396fc486b4ee2331bfc52809b0dad44df" translate="yes" xml:space="preserve">
          <source>Using methods that do not modify, but test that the contents works:</source>
          <target state="translated">使用不修改的方法,但测试内容是否有效。</target>
        </trans-unit>
        <trans-unit id="b0d1b97f67a06429913567862e9a662a62326468" translate="yes" xml:space="preserve">
          <source>Using methods that do not modify, but test the contents works:</source>
          <target state="translated">使用不修改,但测试内容的方法工作。</target>
        </trans-unit>
        <trans-unit id="a5aebc39485edc859f77fc91f87d35c5af691252" translate="yes" xml:space="preserve">
          <source>Using methods that do not modify, but testthe contents works:</source>
          <target state="translated">使用不修改的方法,但testthe内容工作。</target>
        </trans-unit>
        <trans-unit id="8d80ea05e0ed4a3e5f034eecf41875e66394f03f" translate="yes" xml:space="preserve">
          <source>Using negation on a single letter option when bundling is in effect is pointless and will result in a warning.</source>
          <target state="translated">当捆绑生效时,在单字母选项上使用否定式是没有意义的,会导致警告。</target>
        </trans-unit>
        <trans-unit id="8d592d89e9701f8203326be192c2ab0972d996bc" translate="yes" xml:space="preserve">
          <source>Using open() for IPC</source>
          <target state="translated">在IPC中使用open()</target>
        </trans-unit>
        <trans-unit id="f8c56b194bd4e8beff577cc65b3f025dea6a56fa" translate="yes" xml:space="preserve">
          <source>Using perl as shipped with HP-UX</source>
          <target state="translated">使用HP-UX中的perl。</target>
        </trans-unit>
        <trans-unit id="543f3ae6c47ff0945f0303be3eebde44d6d34ce3" translate="yes" xml:space="preserve">
          <source>Using perl from HP's porting centre</source>
          <target state="translated">使用HP的移植中心的perl。</target>
        </trans-unit>
        <trans-unit id="8b05c58f51293f54962b4c8b3d752fd39e7ea984" translate="yes" xml:space="preserve">
          <source>Using perl to connect to Oracle databases through DBI and DBD::Oracle has caused a lot of people many headaches. Read README.hpux in the DBD::Oracle for much more information. The reason to mention it here is that Oracle requires a perl built with libcl and libpthread, the latter even when perl is build without threads. Building perl using all defaults, but still enabling to build DBD::Oracle later on can be achieved using</source>
          <target state="translated">使用perl通过DBI和DBD::Oracle连接Oracle数据库,让很多人头疼不已。阅读DBD::Oracle中的README.hpux可以了解更多信息。这里要提到的原因是,Oracle要求用libcl和libpthread构建的perl,后者即使在构建perl时没有线程。使用所有的默认值来构建perl,但仍然可以实现以后构建DBD::Oracle,可以使用</target>
        </trans-unit>
        <trans-unit id="7a2126efc34d2ceda4c425a482fb9bb2ca847f69" translate="yes" xml:space="preserve">
          <source>Using perl's built in conversion of &lt;code&gt;0x&lt;/code&gt; notation:</source>
          <target state="translated">使用perl的内置 &lt;code&gt;0x&lt;/code&gt; 表示法转换：</target>
        </trans-unit>
        <trans-unit id="1d2a5a50232b147e3a169652436928c470a9aa77" translate="yes" xml:space="preserve">
          <source>Using printf formats for non-basic C types</source>
          <target state="translated">在非基本C类型中使用printf格式</target>
        </trans-unit>
        <trans-unit id="df5384f5e1467c8d0cf10444a33f9f98d9662cee" translate="yes" xml:space="preserve">
          <source>Using qq(), q(), and qx(), instead of &quot;double quotes&quot;, 'single quotes', and `backticks`, may make one-liners easier to write.</source>
          <target state="translated">使用qq()、q()和qx(),而不是 &quot;双引号&quot;、&quot;单引号 &quot;和 &quot;反引号&quot;,可能会使单行本更容易写。</target>
        </trans-unit>
        <trans-unit id="322a6e9972f7fb8edd8295fc130224c62501d62e" translate="yes" xml:space="preserve">
          <source>Using regular expressions in Perl</source>
          <target state="translated">在Perl中使用正则表达式</target>
        </trans-unit>
        <trans-unit id="6fac332e29fd0c799ec1618a5cc40f7221532230" translate="yes" xml:space="preserve">
          <source>Using single-quote as a delimiter protects the command from Perl's double-quote interpolation, passing it on to the shell instead:</source>
          <target state="translated">使用单引号作为定界符,可以保护命令不受 Perl 的双引号插值的影响,而将其传递给 shell。</target>
        </trans-unit>
        <trans-unit id="e361630850aae34ab890ed75be3d3681ddf2f2b5" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; form as an exception trap in libraries does have some issues. Due to the current arguably broken state of &lt;code&gt;__DIE__&lt;/code&gt; hooks, you may wish not to trigger any &lt;code&gt;__DIE__&lt;/code&gt; hooks that user code may have installed. You can use the &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; $SIG{__DIE__}&lt;/code&gt; construct for this purpose, as this example shows:</source>
          <target state="translated">在库中使用 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 格式作为异常陷阱确实存在一些问题。由于 &lt;code&gt;__DIE__&lt;/code&gt; 钩子当前处于断开状态，您可能不希望触发用户代码可能已安装的任何 &lt;code&gt;__DIE__&lt;/code&gt; 钩子。为此，可以使用 &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; $SIG{__DIE__}&lt;/code&gt; 构造，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="1af4f95da6bd74e39669d85ff89a3cba96099269" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; form as an exception trap in libraries does have some issues. Due to the current arguably broken state of &lt;code&gt;__DIE__&lt;/code&gt; hooks, you may wish not to trigger any &lt;code&gt;__DIE__&lt;/code&gt; hooks that user code may have installed. You can use the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $SIG{__DIE__}&lt;/code&gt; construct for this purpose, as this example shows:</source>
          <target state="translated">在库中使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 格式作为异常陷阱确实存在一些问题。由于 &lt;code&gt;__DIE__&lt;/code&gt; 钩子当前处于断开状态，您可能不希望触发用户代码可能已安装的任何 &lt;code&gt;__DIE__&lt;/code&gt; 钩子。为此，可以使用 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $SIG{__DIE__}&lt;/code&gt; 构造，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="de2169c7a04ae8dba7470fca93fa527b85798dbe" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; function:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; 功能：</target>
        </trans-unit>
        <trans-unit id="1108296e898fc2261dd95f4aa7570d85ddac276e" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; command of Perl debugger (see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;) one can deduce which operations are overloaded (and which ancestor triggers this overloading). Say, if &lt;code&gt;eq&lt;/code&gt; is overloaded, then the method &lt;code&gt;(eq&lt;/code&gt; is shown by debugger. The method &lt;code&gt;()&lt;/code&gt; corresponds to the &lt;code&gt;fallback&lt;/code&gt; key (in fact a presence of this method shows that this package has overloading enabled, and it is what is used by the &lt;code&gt;Overloaded&lt;/code&gt; function of module &lt;code&gt;overload&lt;/code&gt; ).</source>
          <target state="translated">使用Perl调试器的 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 命令（请参阅&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;），可以推断出哪些操作被重载了（哪个祖先触发了该重载）。假设，如果 &lt;code&gt;eq&lt;/code&gt; 被重载，则该方法 &lt;code&gt;(eq&lt;/code&gt; 由调试器显示。方法 &lt;code&gt;()&lt;/code&gt; 对应于 &lt;code&gt;fallback&lt;/code&gt; 键（实际上，此方法的存在表明此程序包已启用重载，并且 &lt;code&gt;Overloaded&lt;/code&gt; 模块的功能 &lt;code&gt;overload&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="aa67b5d2a4e3907ddf928ce915424a8bf19328d4" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; function:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="53251a51732562d07b79a04a55bb9b101d155369" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; pragma ensures that all variables are properly declared and prevents other misuses of legacy Perl features.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 的&lt;a href=&quot;functions/use&quot;&gt;用法说明&lt;/a&gt;可确保正确声明所有变量，并防止其他对遗留Perl功能的滥用。</target>
        </trans-unit>
        <trans-unit id="1bda480993361a430b2548cdcd3f02a2d61e7bb5" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;In&lt;/code&gt; prefix avoids this ambiguity, so far. But new versions of Unicode continue to add new properties whose names begin with &lt;code&gt;In&lt;/code&gt; . There is a possibility that one of them someday will conflict with your usage. Since this is just a Perl extension, Unicode's name will take precedence and your code will become broken. Also, Unicode is free to add a script whose name begins with &lt;code&gt;In&lt;/code&gt; ; that would cause problems.</source>
          <target state="translated">到目前为止，使用 &lt;code&gt;In&lt;/code&gt; 前缀可以避免这种歧义。但是新版本的Unicode继续添加名称以 &lt;code&gt;In&lt;/code&gt; 开头的新属性。有可能某一天其中之一会与您的使用冲突。由于这只是Perl扩展名，因此Unicode名称优先，并且您的代码将损坏。另外，Unicode可以自由添加名称以 &lt;code&gt;In&lt;/code&gt; 开头的脚本；那会引起问题。</target>
        </trans-unit>
        <trans-unit id="26fd47284e729cedc59da500b68930f9ee3e861b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;diagnostics&lt;/code&gt; pragma:</source>
          <target state="translated">使用 &lt;code&gt;diagnostics&lt;/code&gt; 编译指示：</target>
        </trans-unit>
        <trans-unit id="18c4a3f647e2f5d82357ab39ea92ae98228cc2e0" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;nntpstat&lt;/code&gt; command to select by message-id is valid but of questionable value, since a selection by message-id does &lt;b&gt;not&lt;/b&gt; alter the &quot;current article pointer&quot;.</source>
          <target state="translated">使用 &lt;code&gt;nntpstat&lt;/code&gt; 命令来按message-id进行选择是有效的，但具有可疑的价值，因为按message-id进行的选择&lt;b&gt;不会&lt;/b&gt;更改&amp;ldquo;当前文章指针&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="13d6e3a9e702d5a08e56927cb7a997c29fc49a7b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;splain&lt;/code&gt; standalone filter program:</source>
          <target state="translated">使用 &lt;code&gt;splain&lt;/code&gt; 独立过滤程序：</target>
        </trans-unit>
        <trans-unit id="5ea33d1eaae8e24543688decd019ec0f69a1f79d" translate="yes" xml:space="preserve">
          <source>Using the CPAN module &lt;code&gt;Bit::Vector&lt;/code&gt; :</source>
          <target state="translated">使用CPAN模块 &lt;code&gt;Bit::Vector&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="910c0c6f5c0907edc9665e4e606f548cf3f4c360" translate="yes" xml:space="preserve">
          <source>Using the G_EVAL flag described above will always set &lt;code&gt;$@&lt;/code&gt; : clearing it if there was no error, and setting it to describe the error if there was an error in the called code. This is what you want if your intention is to handle possible errors, but sometimes you just want to trap errors and stop them interfering with the rest of the program.</source>
          <target state="translated">使用上述G_EVAL标志将始终设置 &lt;code&gt;$@&lt;/code&gt; ：如果没有错误，则将其清除；如果被调用的代码中存在错误，则将其设置为描述错误。如果您打算处理可能的错误，这就是您想要的，但是有时您只想捕获错误并阻止它们干扰程序的其余部分。</target>
        </trans-unit>
        <trans-unit id="81c0cbb80720ba82333e9cac242b49c7344290c8" translate="yes" xml:space="preserve">
          <source>Using the O_WRONLY flag.</source>
          <target state="translated">使用O_WRONLY标志。</target>
        </trans-unit>
        <trans-unit id="318651aa0afd4166b844c0395b31d38b0b5bb275" translate="yes" xml:space="preserve">
          <source>Using the copy or the original with overloaded math is okay, e.g. the following work:</source>
          <target state="translated">用复印件或原件的超载数学都可以,比如下面的作品。</target>
        </trans-unit>
        <trans-unit id="0de692f809342e61f897ad9464158e162341eb3b" translate="yes" xml:space="preserve">
          <source>Using the form $x += $y; etc over $x = $x + $y is faster, since a copy of $x must be made in the second case. For long numbers, the copy can eat up to 20% of the work (in the case of addition/subtraction, less for multiplication/division). If $y is very small compared to $x, the form $x += $y is MUCH faster than $x = $x + $y since making the copy of $x takes more time then the actual addition.</source>
          <target state="translated">使用 $x +=$y;等形式比 $x=$x+$y 更快,因为在第二种情况下必须复制 $x。对于长的数字,复制可能会消耗多达20%的工作(在加/减法的情况下,乘/除法的情况下会少一些)。如果$y与$x相比非常小,那么$x +=$y的形式比$x=$x+$y要快得多,因为复制$x需要更多的时间,而不是实际的加法。</target>
        </trans-unit>
        <trans-unit id="12ccaa0444078f2a1b0edccce245e0b394be801a" translate="yes" xml:space="preserve">
          <source>Using the supplied template, create the temporary directory in a standard location for temporary files. Equivalent to doing</source>
          <target state="translated">使用提供的模板,在标准位置创建临时文件的临时目录。相当于做</target>
        </trans-unit>
        <trans-unit id="9e2035734d6024304e489d6917a2e574dba468c1" translate="yes" xml:space="preserve">
          <source>Using the syntax &lt;code&gt;MyParser::new()&lt;/code&gt; to invoke the constructor is</source>
          <target state="translated">使用语法 &lt;code&gt;MyParser::new()&lt;/code&gt; 调用构造函数是</target>
        </trans-unit>
        <trans-unit id="acb6f03c46c097330bc723d0ffaf6e2dff2e6744" translate="yes" xml:space="preserve">
          <source>Using the template pat..patend, this function unpacks the string s..strend into a number of mortal SVs, which it pushes onto the perl argument (@_) stack (so you will need to issue a &lt;code&gt;PUTBACK&lt;/code&gt; before and &lt;code&gt;SPAGAIN&lt;/code&gt; after the call to this function). It returns the number of pushed elements.</source>
          <target state="translated">使用模板pat..patend，此函数将字符串s..strend解压缩为多个凡人SV，并将其推送到perl参数（@_）堆栈中（因此，您需要在 &lt;code&gt;PUTBACK&lt;/code&gt; 之前发出PUTBACK，在 &lt;code&gt;SPAGAIN&lt;/code&gt; 之后发出SPAGAIN调用此函数）。它返回推送元素的数量。</target>
        </trans-unit>
        <trans-unit id="7a18622b9f73cf084e1c40515e63402b15a29333" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::bitwise&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别为 &lt;code&gt;experimental::bitwise&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="c41fbff9d3dc71a6f8badab26c0a06f0e18953ee" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::const_attr&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别为 &lt;code&gt;experimental::const_attr&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="cc856eaeef355d43fa8953f9faffa4c073431f05" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::lexical_subs&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别 &lt;code&gt;experimental::lexical_subs&lt;/code&gt; 中的警告。</target>
        </trans-unit>
        <trans-unit id="857c7cbd2ca8ba6b31bcdbf6dd9c2b32441faf23" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::lexical_topic&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别为 &lt;code&gt;experimental::lexical_topic&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="de44610062c3b08fbff0aea3fd8f765facd544b6" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::postderef&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别为 &lt;code&gt;experimental::postderef&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="e5af3cfd78b8e6f9d0563b3f4cf549f389ec7ba5" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::re_strict&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别 &lt;code&gt;experimental::re_strict&lt;/code&gt; 中的警告。</target>
        </trans-unit>
        <trans-unit id="65fcb853c1a517ad8d77449f7c0018250e14485b" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::refaliasing&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别为 &lt;code&gt;experimental::refaliasing&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="37bffd5a63be98cf17b1b1c985d57c2adb638271" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::regex_sets&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别为 &lt;code&gt;experimental::regex_sets&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="c0a382b10a1d9a073eb205f7f2bb7818eb3bbf75" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::signatures&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别为 &lt;code&gt;experimental::signatures&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="482e06051ee37583e9eea4d7cca4c50c1fbeaf4e" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::smartmatch&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别为 &lt;code&gt;experimental::smartmatch&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="2d4359e0b1138dffdeb53a1d3017037757b78671" translate="yes" xml:space="preserve">
          <source>Using this operator can lead to programs that are difficult to port, because the shell commands called vary between systems, and may in fact not be present at all. As one example, the &lt;code&gt;type&lt;/code&gt; command under the POSIX shell is very different from the &lt;code&gt;type&lt;/code&gt; command under DOS. That doesn't mean you should go out of your way to avoid backticks when they're the right way to get something done. Perl was made to be a glue language, and one of the things it glues together is commands. Just understand what you're getting yourself into.</source>
          <target state="translated">使用此运算符可能导致程序难以移植，因为所调用的shell命令在系统之间有所不同，并且实际上可能根本不存在。作为一个示例，该 &lt;code&gt;type&lt;/code&gt; 下的POSIX外壳命令是从一不同 &lt;code&gt;type&lt;/code&gt; DOS下命令。这并不意味着当它们是正确完成某件事的正确方法时，您应该竭尽所能避免出现反引号。Perl成为一种粘合语言，它粘合在一起的一件事就是命令。只要了解您正在进入的领域即可。</target>
        </trans-unit>
        <trans-unit id="d4d70574aacd1d1847898b08d95988a332169072" translate="yes" xml:space="preserve">
          <source>Using various gambits, try to get a CV from an SV; in addition, try if possible to set &lt;code&gt;*st&lt;/code&gt; and &lt;code&gt;*gvp&lt;/code&gt; to the stash and GV associated with it. The flags in &lt;code&gt;lref&lt;/code&gt; are passed to gv_fetchsv.</source>
          <target state="translated">使用各种技巧，尝试从SV获取简历；此外，请尝试将 &lt;code&gt;*st&lt;/code&gt; 和 &lt;code&gt;*gvp&lt;/code&gt; 设置为与其关联的存储和GV。 &lt;code&gt;lref&lt;/code&gt; 中的标志将传递到gv_fetchsv。</target>
        </trans-unit>
        <trans-unit id="27cc9ed80851550eb53eda865f75d2e008f1dc72" translate="yes" xml:space="preserve">
          <source>Using various gambits, try to get an IO from an SV: the IO slot if its a GV; or the recursive result if we're an RV; or the IO slot of the symbol named after the PV if we're a string.</source>
          <target state="translated">使用各种赌博,尝试从SV中获得一个IO:如果是GV,则是IO槽;如果是RV,则是递归结果;如果是字符串,则是以PV命名的符号的IO槽。</target>
        </trans-unit>
        <trans-unit id="40c4ad482806895c6f8713969b3ecb705fa44118" translate="yes" xml:space="preserve">
          <source>Using various methods &lt;b&gt;attempt&lt;/b&gt; to find the Fully Qualified Domain Name (FQDN) of the current host. From this determine the host-name and the host-domain.</source>
          <target state="translated">使用各种方法&lt;b&gt;尝试&lt;/b&gt;查找当前主机的完全限定域名（FQDN）。由此确定主机名和主机域。</target>
        </trans-unit>
        <trans-unit id="892738b2747cec8282f76dab54e62a0b79491609" translate="yes" xml:space="preserve">
          <source>Usual perl lib path (semi-list).</source>
          <target state="translated">通常的perl lib路径(半列表)。</target>
        </trans-unit>
        <trans-unit id="b7cde133a5ff79130fd30cde6b361d0ab467bd51" translate="yes" xml:space="preserve">
          <source>Usually a hash ref, perhaps like this:</source>
          <target state="translated">通常是一个哈希裁判,也许像这样。</target>
        </trans-unit>
        <trans-unit id="ad35f25dce96f5712243ad327f82cc56b137d4d7" translate="yes" xml:space="preserve">
          <source>Usually accessed via the &lt;code&gt;SvPVbyte&lt;/code&gt; macro.</source>
          <target state="translated">通常通过 &lt;code&gt;SvPVbyte&lt;/code&gt; 宏进行访问。</target>
        </trans-unit>
        <trans-unit id="e38187632a58d32566d4fbc0b71dc22c87d815e2" translate="yes" xml:space="preserve">
          <source>Usually accessed via the &lt;code&gt;SvPVbyte_nolen&lt;/code&gt; macro.</source>
          <target state="translated">通常通过 &lt;code&gt;SvPVbyte_nolen&lt;/code&gt; 宏进行访问。</target>
        </trans-unit>
        <trans-unit id="a0ca6cd076c679630ac44632c012203ed79a11ad" translate="yes" xml:space="preserve">
          <source>Usually accessed via the &lt;code&gt;SvPVutf8&lt;/code&gt; macro.</source>
          <target state="translated">通常通过 &lt;code&gt;SvPVutf8&lt;/code&gt; 宏进行访问。</target>
        </trans-unit>
        <trans-unit id="b020d8f1cda36b9415a539e77cdc15cb72cc9530" translate="yes" xml:space="preserve">
          <source>Usually accessed via the &lt;code&gt;SvPVutf8_nolen&lt;/code&gt; macro.</source>
          <target state="translated">通常通过 &lt;code&gt;SvPVutf8_nolen&lt;/code&gt; 宏进行访问。</target>
        </trans-unit>
        <trans-unit id="7c024fdbe2028ca7a62024863c10f1c75039e578" translate="yes" xml:space="preserve">
          <source>Usually called from the object destructor when using the OO interface.</source>
          <target state="translated">当使用OO接口时,通常从对象分解器中调用。</target>
        </trans-unit>
        <trans-unit id="4285fe9b5258e25bc264f1b1a13271726e80e089" translate="yes" xml:space="preserve">
          <source>Usually inherited from DB package. Ask for a STRING to be &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;-ed in executing code context.</source>
          <target state="translated">通常从DB包继承。要求在执行代码上下文中 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 一个STRING 。</target>
        </trans-unit>
        <trans-unit id="026b900ced2773356641f583fde7b62143e57def" translate="yes" xml:space="preserve">
          <source>Usually inherited from DB package. If no arguments are passed, returns the poststop action string.</source>
          <target state="translated">通常从DB包中继承,如果没有参数传递,返回poststop动作字符串。如果没有传递参数,返回poststop动作字符串。</target>
        </trans-unit>
        <trans-unit id="7d9b8edd49b4cf562a81e5b8decb5de77fa1afd9" translate="yes" xml:space="preserve">
          <source>Usually inherited from DB package. If no arguments are passed, returns the prestop action string.</source>
          <target state="translated">通常继承自DB包。如果没有传递参数,返回prestop动作字符串。</target>
        </trans-unit>
        <trans-unit id="0c460ecc82dad59a8d6a90636305608877d8c532" translate="yes" xml:space="preserve">
          <source>Usually programs take command line options as well as other arguments, for example, file names. It is good practice to always specify the options first, and the other arguments last. Getopt::Long will, however, allow the options and arguments to be mixed and 'filter out' all the options before passing the rest of the arguments to the program. To stop Getopt::Long from processing further arguments, insert a double dash &lt;code&gt;--&lt;/code&gt; on the command line:</source>
          <target state="translated">通常，程序使用命令行选项以及其他参数，例如文件名。最好总是先指定选项，最后再指定其他参数。但是，Getopt :: Long将允许将选项和参数混合使用，并在将其余参数传递给程序之前&amp;ldquo;过滤掉&amp;rdquo;所有选项。要停止Getopt :: Long处理更多参数，请在命令行上插入双破折号 &lt;code&gt;--&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2691970d8d342de7ae3956a2783fcd64867158b2" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_catpvf&lt;/code&gt; .</source>
          <target state="translated">通常通过其前端 &lt;code&gt;sv_catpvf&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="221ae26d5a59ab131e1ef8287fa9b5a715378994" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_catpvf_mg&lt;/code&gt; .</source>
          <target state="translated">通常通过其前端 &lt;code&gt;sv_catpvf_mg&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="1f47e17c3d0a65f1e24ab46a970720597c10ef39" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_setpvf&lt;/code&gt; .</source>
          <target state="translated">通常通过其前端 &lt;code&gt;sv_setpvf&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="3548cea6e28d55dc32a5bfd0e3189ea93c77d357" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_setpvf_mg&lt;/code&gt; .</source>
          <target state="translated">通常通过其前端 &lt;code&gt;sv_setpvf_mg&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="a9bb4c004a0f7c4b905c963d10b31ef391b5c334" translate="yes" xml:space="preserve">
          <source>Usually used via one of its frontends &lt;code&gt;sv_vcatpvf&lt;/code&gt; and &lt;code&gt;sv_vcatpvf_mg&lt;/code&gt; .</source>
          <target state="translated">通常通过其前端之一 &lt;code&gt;sv_vcatpvf&lt;/code&gt; 和 &lt;code&gt;sv_vcatpvf_mg&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="2f08502c181dd16b4bbf68ae24c29b059d5a1bce" translate="yes" xml:space="preserve">
          <source>Usually used via one of its frontends &lt;code&gt;sv_vsetpvf&lt;/code&gt; and &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; .</source>
          <target state="translated">通常通过其前端之一 &lt;code&gt;sv_vsetpvf&lt;/code&gt; 和 &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="7fff94b5e5d0e7b2c191398749185343c2f32a65" translate="yes" xml:space="preserve">
          <source>Usually when a variable is localized you want to make sure that this change affects the shortest scope possible. So unless you are already inside some short &lt;code&gt;{}&lt;/code&gt; block, you should create one yourself. For example:</source>
          <target state="translated">通常，在对变量进行本地化时，您需要确保此更改影响可能的最短范围。因此，除非您已经在简短的 &lt;code&gt;{}&lt;/code&gt; 块中，否则您应该自己创建一个。例如：</target>
        </trans-unit>
        <trans-unit id="599351f57ec025dcf8b7e2139660d070855a8727" translate="yes" xml:space="preserve">
          <source>Usually you'll want to pack or unpack UTF-8 strings:</source>
          <target state="translated">通常你会想要打包或解压UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="cf8c2092d45b2a1234c61351a627eb75997a3b4f" translate="yes" xml:space="preserve">
          <source>Usually, the feature can be entirely ignored. Calling</source>
          <target state="translated">通常情况下,可以完全忽略该功能。调用</target>
        </trans-unit>
        <trans-unit id="3747a1556b1698c5e4df73c06a70d49b29b190d1" translate="yes" xml:space="preserve">
          <source>Usually, these single-character options can be bundled:</source>
          <target state="translated">通常,这些单字符选项可以捆绑在一起。</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="29f83b729f46062c9dd1b32c5a75ee83eb4a8e12" translate="yes" xml:space="preserve">
          <source>Utilities for embedding Perl in C/C++ applications</source>
          <target state="translated">在C/C++应用中嵌入Perl的实用工具。</target>
        </trans-unit>
        <trans-unit id="c5c36f1963730a8868662732388dc0c0703a634a" translate="yes" xml:space="preserve">
          <source>Utilities for managing %^H scopes</source>
          <target state="translated">管理%^H作用域的实用工具</target>
        </trans-unit>
        <trans-unit id="35acf3ef6343308f92e84a6c665aa85cecd79c2b" translate="yes" xml:space="preserve">
          <source>Utilities to replace common UNIX commands in Makefiles etc.</source>
          <target state="translated">用来替换Makefile等文件中常见的UNIX命令的实用工具。</target>
        </trans-unit>
        <trans-unit id="1637dc7299266babf67a48df4d48af858929b4bd" translate="yes" xml:space="preserve">
          <source>Utilities to write and check a MANIFEST file</source>
          <target state="translated">编写和检查MANIFEST文件的实用工具。</target>
        </trans-unit>
        <trans-unit id="8bf056ede57539fe7ab422f88b516c58223a0adf" translate="yes" xml:space="preserve">
          <source>Utility Functions</source>
          <target state="translated">实用功能</target>
        </trans-unit>
        <trans-unit id="5486a0e8e13b0b039dc58793f09b6e6eb6465317" translate="yes" xml:space="preserve">
          <source>Utility Methods</source>
          <target state="translated">实用方法</target>
        </trans-unit>
        <trans-unit id="2ffeb2e1de80e186589b30d3572aa3cf779263b5" translate="yes" xml:space="preserve">
          <source>Utility for CPAN::Config file Initialization</source>
          <target state="translated">用于CPAN::Config文件初始化的工具。</target>
        </trans-unit>
        <trans-unit id="bc41614ee1aee6d115725273058a3f6ba77aebc5" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Cmd&lt;/code&gt; is capable of capturing buffers in it's current configuration.</source>
          <target state="translated">实用程序功能，可告诉您 &lt;code&gt;IPC::Cmd&lt;/code&gt; 是否能够捕获其当前配置中的缓冲区。</target>
        </trans-unit>
        <trans-unit id="f378c15ae2f401b4423675b36af5d2e3c5f0b6d5" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Cmd&lt;/code&gt; is capable of providing &lt;code&gt;run_forked&lt;/code&gt; on the current platform.</source>
          <target state="translated">实用程序功能，可告诉您 &lt;code&gt;IPC::Cmd&lt;/code&gt; 是否能够在当前平台上提供 &lt;code&gt;run_forked&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bd9fd9b54869479fd1b5ab93786828f7dca29ba" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Open3&lt;/code&gt; is available. If the verbose flag is passed, it will print diagnostic messages if &lt;code&gt;IPC::Open3&lt;/code&gt; can not be found or loaded.</source>
          <target state="translated">实用程序功能，告诉您 &lt;code&gt;IPC::Open3&lt;/code&gt; 是否可用。如果传递了详细标志，则在找不到或加载 &lt;code&gt;IPC::Open3&lt;/code&gt; ，它将打印诊断消息。</target>
        </trans-unit>
        <trans-unit id="451db65a6c9d4e76bfbbd6735fbbae7748464a49" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Run&lt;/code&gt; is available. If the &lt;code&gt;verbose&lt;/code&gt; flag is passed, it will print diagnostic messages if &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC::Run&lt;/a&gt; can not be found or loaded.</source>
          <target state="translated">实用程序功能，告诉您 &lt;code&gt;IPC::Run&lt;/code&gt; 是否可用。如果传递了 &lt;code&gt;verbose&lt;/code&gt; 标志，则在找不到或加载&lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC :: Run的情况下&lt;/a&gt;，它将打印诊断消息。</target>
        </trans-unit>
        <trans-unit id="f16cdccb3faaa5e67faa6fdb65caa5cf29d51cbb" translate="yes" xml:space="preserve">
          <source>Utility functions</source>
          <target state="translated">实用功能</target>
        </trans-unit>
        <trans-unit id="1f8287a26f238372802990f191fcd97ce4ce1919" translate="yes" xml:space="preserve">
          <source>Utility functions to compare CPAN versions</source>
          <target state="translated">比较CPAN版本的实用功能</target>
        </trans-unit>
        <trans-unit id="e944fa11ecc3fc10a3b409bcd5f6df4ebd3f4487" translate="yes" xml:space="preserve">
          <source>Uuencoding</source>
          <target state="translated">Uuencoding</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="7dc10180b878fd7bd185c2d6a23c0519a292a3a0" translate="yes" xml:space="preserve">
          <source>VALUE</source>
          <target state="translated">VALUE</target>
        </trans-unit>
        <trans-unit id="41fdf9c71f9b0e67f5d577b57ffb59065472ee6e" translate="yes" xml:space="preserve">
          <source>VAR</source>
          <target state="translated">VAR</target>
        </trans-unit>
        <trans-unit id="b5fcb61029823124da78ad195388293fa0fe55ea" translate="yes" xml:space="preserve">
          <source>VARIABLES</source>
          <target state="translated">VARIABLES</target>
        </trans-unit>
        <trans-unit id="b33892fbddeffc3368077b4904ad0b3d562a7312" translate="yes" xml:space="preserve">
          <source>VERSION</source>
          <target state="translated">VERSION</target>
        </trans-unit>
        <trans-unit id="f189e0805d92e6bfdd489073d1a01e43b46335be" translate="yes" xml:space="preserve">
          <source>VERSION may be either a numeric argument such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a literal of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter. Compare with &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;, which can do a similar check at compile time.</source>
          <target state="translated">VERSION可以是将与 &lt;code&gt;$]&lt;/code&gt; 相比较的数字参数（例如5.006），也可以是与 &lt;code&gt;$^V&lt;/code&gt; 相比较的形式v5.6.1的文字（也称为$ PERL_VERSION）。如果VERSION大于当前Perl解释器的版本，则会引发异常。与&lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;比较，在编译时可以进行类似的检查。</target>
        </trans-unit>
        <trans-unit id="3f48ba5d24abaab8495945658838888561f00637" translate="yes" xml:space="preserve">
          <source>VERSION may be either a numeric argument such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a literal of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter. Compare with &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;, which can do a similar check at compile time.</source>
          <target state="translated">VERSION可以是将与 &lt;code&gt;$]&lt;/code&gt; 相比较的数字参数（例如5.006），也可以是与 &lt;code&gt;$^V&lt;/code&gt; 相比较的形式v5.6.1的文字（也称为$ PERL_VERSION）。如果VERSION大于当前Perl解释器的版本，则会引发异常。与&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;比较，在编译时可以进行类似的检查。</target>
        </trans-unit>
        <trans-unit id="8aab271152b932f50d15f749cb2ad3f6aa388e98" translate="yes" xml:space="preserve">
          <source>VERSION: version of your module</source>
          <target state="translated">VERSION:您的模块的版本</target>
        </trans-unit>
        <trans-unit id="439c8f3808541b8d38659912158a7dbb6e0d7837" translate="yes" xml:space="preserve">
          <source>VERSION_MACRO: which macro represents the version (usually 'VERSION')</source>
          <target state="translated">VERSION_MACRO:哪个宏代表版本(通常是 &quot;VERSION&quot;)。</target>
        </trans-unit>
        <trans-unit id="d46d79d5b527245ae65e82f18ddd3ba603c16976" translate="yes" xml:space="preserve">
          <source>VERSION_SYM: like version but safe for use as an RCS revision number</source>
          <target state="translated">VERSION_SYM:类似于版本,但可以作为RCS的版本号使用。</target>
        </trans-unit>
        <trans-unit id="a850272b9ab78b2a9e2f07713cef8bc188b3ede9" translate="yes" xml:space="preserve">
          <source>VERY ALPHA AND LIKELY TO CHANGE</source>
          <target state="translated">非常阳性,容易改变。</target>
        </trans-unit>
        <trans-unit id="cce163acefa51c5f80357419607cd2acfc9bcda6" translate="yes" xml:space="preserve">
          <source>VIEW.EXE</source>
          <target state="translated">VIEW.EXE</target>
        </trans-unit>
        <trans-unit id="8e5207fffbfb609ac37a389e363f0db0120b9dae" translate="yes" xml:space="preserve">
          <source>VMS</source>
          <target state="translated">VMS</target>
        </trans-unit>
        <trans-unit id="6ad64d23074ae7d322786e62e572397b29888496" translate="yes" xml:space="preserve">
          <source>VMS Software Inc. web site, &lt;a href=&quot;http://www.vmssoftware.com&quot;&gt;http://www.vmssoftware.com&lt;/a&gt;</source>
          <target state="translated">VMS Software Inc.网站，&lt;a href=&quot;http://www.vmssoftware.com&quot;&gt;http：//www.vmssoftware.com&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2719ba4075d542c93bfa0cdfa52b9abcdd8bf1e2" translate="yes" xml:space="preserve">
          <source>VMS file specification syntax is case-tolerant.</source>
          <target state="translated">VMS文件规范语法是不分大小写的。</target>
        </trans-unit>
        <trans-unit id="731e9eea656f3a7b49847d98fa31bc8bf39060b9" translate="yes" xml:space="preserve">
          <source>VMS has $(MMSQUALIFIERS) which is a listing of all the original command line options. This is used in every invocation of make in the VMS Makefile so PASTHRU should not be necessary. Using PASTHRU tends to blow commands past the 256 character limit.</source>
          <target state="translated">VMS有$(MMSQUALIFIERS),它是所有原始命令行选项的列表。在VMS的Makefile中,每次调用make时都会用到它,所以PASTHRU应该是没有必要的。使用PASTHRU往往会使命令超过256个字符的限制。</target>
        </trans-unit>
        <trans-unit id="26ff54e8c5dec349cf161af5221feaf07190cd81" translate="yes" xml:space="preserve">
          <source>VMS implementation</source>
          <target state="translated">虚拟监理系统的实施</target>
        </trans-unit>
        <trans-unit id="044140c726f05d1f569402b05b60683ee5f27ac8" translate="yes" xml:space="preserve">
          <source>VMS is VMS.</source>
          <target state="translated">VMS就是VMS。</target>
        </trans-unit>
        <trans-unit id="19cc64067b9d9a483d87606a5fc200285da5a247" translate="yes" xml:space="preserve">
          <source>VMS support for this process in the current release of Perl is sufficient to handle most extensions. (See the MakeMaker documentation for more details on installation options for extensions.)</source>
          <target state="translated">在当前版本的Perl中,VMS对这个过程的支持足以处理大多数扩展。(关于扩展的安装选项,请参见MakeMaker文档)。</target>
        </trans-unit>
        <trans-unit id="a0b48a2078e8546f59c353d4437730af0e465606" translate="yes" xml:space="preserve">
          <source>VMS systems have a permissions structure that cannot be completely represented in a stat buffer, and unlike on other systems the builtin filetest operators respect this. The &lt;code&gt;File::stat&lt;/code&gt; overloads, however, do not, since the information required is not available.</source>
          <target state="translated">VMS系统具有无法在状态缓冲区中完全表示的权限结构，并且与其他系统不同，内置的文件测试操作员会遵守此权限结构。该 &lt;code&gt;File::stat&lt;/code&gt; 过载，但是，不这样做，因为所需的信息不可用。</target>
        </trans-unit>
        <trans-unit id="d55cb5dcb20d55a8b83dc657590161b870f2b37b" translate="yes" xml:space="preserve">
          <source>VMS wants a dot in every file so we can't have one called 'pm_to_blib', it becomes 'pm_to_blib.' and MMS/K isn't smart enough to know that when you have a target called 'pm_to_blib' it should look for 'pm_to_blib.'.</source>
          <target state="translated">VMS希望每个文件中都有一个点,所以我们不能有一个叫'pm_to_blib'的文件,它就变成了'pm_to_blib.',而MMS/K不够聪明,它知道当你有一个叫'pm_to_blib'的目标时,它应该找'pm_to_blib.'。</target>
        </trans-unit>
        <trans-unit id="f2c0fca2c674b5e61f569c9a2276cbaa83043ca7" translate="yes" xml:space="preserve">
          <source>VMSish defaults for some values.</source>
          <target state="translated">VMSish默认的一些值。</target>
        </trans-unit>
        <trans-unit id="b34e6b4bc196605f4ec9f36bd956bf4d5349e341" translate="yes" xml:space="preserve">
          <source>VOS</source>
          <target state="translated">VOS</target>
        </trans-unit>
        <trans-unit id="3ed32c224bfdeaef83075fa116b0ec438527a823" translate="yes" xml:space="preserve">
          <source>VOS Open-Source Software on the web at &lt;a href=&quot;http://ftp.stratus.com/pub/vos/vos.html&quot;&gt;http://ftp.stratus.com/pub/vos/vos.html&lt;/a&gt;</source>
          <target state="translated">Web上的VOS开源软件，网址为&lt;a href=&quot;http://ftp.stratus.com/pub/vos/vos.html&quot;&gt;http://ftp.stratus.com/pub/vos/vos.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="957b3df553f7dff11b930fd1fbc2f8551388c83f" translate="yes" xml:space="preserve">
          <source>VOS perl can emulate Unix filenames with &lt;code&gt;/&lt;/code&gt; as path separator. The native pathname characters greater-than, less-than, number-sign, and percent-sign are always accepted.</source>
          <target state="translated">VOS perl可以使用 &lt;code&gt;/&lt;/code&gt; 作为路径分隔符来模拟Unix文件名。始终接受大于，小于，数字符号和百分号的本机路径名字符。</target>
        </trans-unit>
        <trans-unit id="228203bd56ca8f33c2e2cf1d51934741f92afc9c" translate="yes" xml:space="preserve">
          <source>VOS specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_Unix的VOS特定子类。</target>
        </trans-unit>
        <trans-unit id="0565b8691c25d546ce54285d2b39e0a691ab1159" translate="yes" xml:space="preserve">
          <source>Valgrind also provides a cachegrind tool, invoked on perl as:</source>
          <target state="translated">Valgrind还提供了一个cachegrind工具,在perl上调用为。</target>
        </trans-unit>
        <trans-unit id="c78c948aba2c03abbf33d21db8439afd4716f2fd" translate="yes" xml:space="preserve">
          <source>Valid $types are &quot;MacOS&quot;, &quot;VMS&quot;, &quot;AmigaOS&quot;, &quot;OS2&quot;, &quot;RISCOS&quot;, &quot;MSWin32&quot;, &quot;DOS&quot; (also &quot;MSDOS&quot; for backwards bug compatibility), &quot;Epoc&quot; and &quot;Unix&quot; (all case-insensitive). If an unrecognized $type is given &quot;Unix&quot; will be assumed.</source>
          <target state="translated">有效的$types是 &quot;MacOS&quot;,&quot;VMS&quot;,&quot;AmigaOS&quot;,&quot;OS2&quot;,&quot;RISCOS&quot;,&quot;MSWin32&quot;,&quot;DOS&quot;(也包括 &quot;MSDOS&quot;,以便向后兼容错误),&quot;Epoc &quot;和 &quot;Unix&quot;(都不区分大小写)。如果给定了一个未识别的$type,将假定为 &quot;Unix&quot;。</target>
        </trans-unit>
        <trans-unit id="4f1f0874166d8489998a2dabaec65b65aacdc83c" translate="yes" xml:space="preserve">
          <source>Valid flags are R_CURSOR, R_IAFTER, R_IBEFORE, R_NOOVERWRITE and R_SETCURSOR.</source>
          <target state="translated">有效的标志有R_CURSOR、R_IAFTER、R_IBEFORE、R_NOOVERWRITE和R_SETCURSOR。</target>
        </trans-unit>
        <trans-unit id="372003ef32f4fb85add82bd740d0d6f53c484da5" translate="yes" xml:space="preserve">
          <source>Valid values are 0-9 and &lt;code&gt;LZMA_PRESET_DEFAULT&lt;/code&gt; .</source>
          <target state="translated">有效值为0-9和 &lt;code&gt;LZMA_PRESET_DEFAULT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4fc9756075f953dec67702b67d732830de319ae" translate="yes" xml:space="preserve">
          <source>Valid values are from 1 to 9, where 9 is best compression.</source>
          <target state="translated">有效值从1到9,其中9是最佳压缩值。</target>
        </trans-unit>
        <trans-unit id="61c0f0c254e06b47f44e05f0b16b8e15856c3b3c" translate="yes" xml:space="preserve">
          <source>Valid values for the file type are the following constants defined by Archive::Tar::Constant:</source>
          <target state="translated">文件类型的有效值是下列由 Archive::Tar::Constant 定义的常量。</target>
        </trans-unit>
        <trans-unit id="e2d14a7d576fe1f87f5d9e8e9cd3b19b9f3883ab" translate="yes" xml:space="preserve">
          <source>Valid values range from 0 to 250, where 0 means use the default value 30.</source>
          <target state="translated">有效值范围从0到250,其中0表示使用默认值30。</target>
        </trans-unit>
        <trans-unit id="0c5fff5f0da802e753b92748a90cbb8fb80c8fcd" translate="yes" xml:space="preserve">
          <source>Validate CPAN distribution metadata structures</source>
          <target state="translated">验证CPAN分布元数据结构</target>
        </trans-unit>
        <trans-unit id="42ca1a4cda43fbba8ac585879a08c0309c1d20bf" translate="yes" xml:space="preserve">
          <source>Validate that a given string can be parsed as a version object, but doesn't actually perform the parsing. Can use either strict or lax validation rules. Can optionally set a number of hint variables to save the parsing code some time when tokenizing.</source>
          <target state="translated">验证一个给定的字符串可以被解析为一个版本对象,但并不实际执行解析。可以使用严格或宽松的验证规则。可以选择性地设置一些提示变量,以节省解析代码在标记化时的一些时间。</target>
        </trans-unit>
        <trans-unit id="02a3f32fae979c719788dc5214614a1ca3e7e4ee" translate="yes" xml:space="preserve">
          <source>Validate the arguments given by the user based on strings, regexes, lists or even subroutines</source>
          <target state="translated">基于字符串、regexes、列表甚至子程序来验证用户给出的参数。</target>
        </trans-unit>
        <trans-unit id="df34a04c181ba88b10ee206f3171d24fb01034c4" translate="yes" xml:space="preserve">
          <source>Validates that the SV contains valid internal structure for a version object. It may be passed either the version object (RV) or the hash itself (HV). If the structure is valid, it returns the HV. If the structure is invalid, it returns NULL.</source>
          <target state="translated">验证 SV 是否包含版本对象的有效内部结构。可以传递版本对象(RV)或哈希本身(HV)。如果结构有效,它返回HV。如果结构无效,则返回NULL。</target>
        </trans-unit>
        <trans-unit id="ff4094183301726c60c811c9d974ce575c34af6b" translate="yes" xml:space="preserve">
          <source>Validation Tests</source>
          <target state="translated">验证测试</target>
        </trans-unit>
        <trans-unit id="fa414ab19e33bf9bd3aaeda3e54cacdb51c904fe" translate="yes" xml:space="preserve">
          <source>Value must be greater than zero. Pass an undef value to disable it:</source>
          <target state="translated">值必须大于零。传递一个undef值来禁用它。</target>
        </trans-unit>
        <trans-unit id="5329eac11375c274bf2934a43944e0d3c65118bd" translate="yes" xml:space="preserve">
          <source>Value slices of arrays and hashes may also be taken with postfix dereferencing notation, with the following equivalencies:</source>
          <target state="translated">数组和哈希的值片也可以采取后缀去参考的记法,其等价关系如下。</target>
        </trans-unit>
        <trans-unit id="9d49e40c3d7ac176f056540076e808cf6346a547" translate="yes" xml:space="preserve">
          <source>Values are usually referred to by name, or through a named reference. The first character of the name tells you to what sort of data structure it refers. The rest of the name tells you the particular value to which it refers. Usually this name is a single</source>
          <target state="translated">值通常通过名称或通过命名引用来引用。名称的第一个字符告诉你它指的是哪种数据结构。名字的其余部分告诉你它所引用的特定值。通常这个名字是一个单一的</target>
        </trans-unit>
        <trans-unit id="b95834354d188d1c446139257f83c336e08b30f1" translate="yes" xml:space="preserve">
          <source>Values in this array are magical in numeric context: they compare equal to zero only if the line is not breakable.</source>
          <target state="translated">这个数组中的值在数字背景下是很神奇的:只有当线不可断时,它们才会比较等于零。</target>
        </trans-unit>
        <trans-unit id="f6e707c7542fd8d8b012efb4bcba22c20e79cddd" translate="yes" xml:space="preserve">
          <source>Values must be either strings with possible glob-style matching, or arrayrefs of strings or hashrefs which follow this pattern recursively.</source>
          <target state="translated">值必须是具有可能的 glob 风格匹配的字符串,或者是字符串的 arrayrefs,或者是递归遵循这种模式的 hashrefs。</target>
        </trans-unit>
        <trans-unit id="9d7f43d25cf7a3a7519ab8b3625879499f1cffcc" translate="yes" xml:space="preserve">
          <source>Values of %meta_add will overwrite any existing metadata in those keys. %meta_merge will be merged with them.</source>
          <target state="translated">%meta_add的值将覆盖这些键中现有的元数据。%meta_merge的值将与它们合并。</target>
        </trans-unit>
        <trans-unit id="a7c124848c793b84e7134c4f5b9435a446fc14e9" translate="yes" xml:space="preserve">
          <source>Values stored in config.sh as 'undef' are returned as undefined values. The perl &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; function can be used to check if a named variable exists.</source>
          <target state="translated">以&amp;ldquo; undef&amp;rdquo;形式存储在config.sh中的值将作为未定义值返回。perl &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 函数可用于检查命名变量是否存在。</target>
        </trans-unit>
        <trans-unit id="9adc561121b10d3163cfe0f3b6e1049a68105bd5" translate="yes" xml:space="preserve">
          <source>Variable names</source>
          <target state="translated">变量名称</target>
        </trans-unit>
        <trans-unit id="5b24debec3e800c2a01f6fe873b50e5c2cfac784" translate="yes" xml:space="preserve">
          <source>Variable names in Perl can have several formats. Usually, they must begin with a letter or underscore, in which case they can be arbitrarily long (up to an internal limit of 251 characters) and may contain letters, digits, underscores, or the special sequence &lt;code&gt;::&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;. In this case, the part before the last &lt;code&gt;::&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt; is taken to be a</source>
          <target state="translated">Perl中的变量名可以有几种格式。通常，它们必须以字母或下划线开头，在这种情况下，它们可以任意长（最多251个字符的内部限制），并且可以包含字母，数字，下划线或特殊序列 &lt;code&gt;::&lt;/code&gt; 或 &lt;code&gt;'&lt;/code&gt; 。在这种情况下，最后一个 &lt;code&gt;::&lt;/code&gt; 或 &lt;code&gt;'&lt;/code&gt; 之前的部分被视为</target>
        </trans-unit>
        <trans-unit id="41f1e305cd399af1bab308129c47ec5731d3275e" translate="yes" xml:space="preserve">
          <source>Variable scoping</source>
          <target state="translated">可变范围</target>
        </trans-unit>
        <trans-unit id="ef32d1f98150e537dbad0f8aeb79c36da9b27e19" translate="yes" xml:space="preserve">
          <source>Variable suicide is when you (temporarily or permanently) lose the value of a variable. It is caused by scoping through my() and local() interacting with either closures or aliased foreach() iterator variables and subroutine arguments. It used to be easy to inadvertently lose a variable's value this way, but now it's much harder. Take this code:</source>
          <target state="translated">变量自杀是指你(暂时或永久)失去一个变量的值。它是通过my()和local()的作用域与闭包或别名的foreach()迭代器变量和子程序参数交互造成的。以前很容易通过这种方式无意中丢失一个变量的值,但现在就难多了。就拿这段代码来说吧。</target>
        </trans-unit>
        <trans-unit id="250f3f77348f1daf074babbf51813ae9c5cec2e2" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to designate the object in a C++ XSUB. This is always the proper type for the C++ object. See &lt;code&gt;CLASS&lt;/code&gt; and &lt;a href=&quot;perlxs#Using-XS-With-C%2b%2b&quot;&gt;Using XS With C++ in perlxs&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于指定C ++ XSUB中的对象。对于C ++对象，这始终是正确的类型。请参见&lt;a href=&quot;perlxs#Using-XS-With-C%2b%2b&quot;&gt;perlxs中的&lt;/a&gt; &lt;code&gt;CLASS&lt;/code&gt; 和在C ++中使用XS。</target>
        </trans-unit>
        <trans-unit id="96f93b135985c0d3733c8f2cb9adad25487bb3de" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to hold the return value for an XSUB. This is always the proper type for the XSUB. See &lt;a href=&quot;perlxs#The-RETVAL-Variable&quot;&gt;The RETVAL Variable in perlxs&lt;/a&gt;.</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于保存XSUB的返回值。这始终是XSUB的正确类型。请参见&lt;a href=&quot;perlxs#The-RETVAL-Variable&quot;&gt;perlxs中的RETVAL变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca0fab0f8678649996d70b3f1641bab2dc619d79" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the class name for a C++ XS constructor. This is always a &lt;code&gt;char*&lt;/code&gt; . See &lt;code&gt;THIS&lt;/code&gt; .</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于指示C ++ XS构造函数的类名称。这始终是一个 &lt;code&gt;char*&lt;/code&gt; 。请参阅 &lt;code&gt;THIS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="047db5765fb37d513256abe7c3bb231a7730d231" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the number of items on the stack. See &lt;a href=&quot;perlxs#Variable-length-Parameter-Lists&quot;&gt;Variable-length Parameter Lists in perlxs&lt;/a&gt;.</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于指示堆栈中的项目数。请参见&lt;a href=&quot;perlxs#Variable-length-Parameter-Lists&quot;&gt;perlxs中的可变长度参数列表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9f90eb2fc40e8b2bdb8fd7693973daf5289f55d" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the stack base offset, used by the &lt;code&gt;ST&lt;/code&gt; , &lt;code&gt;XSprePUSH&lt;/code&gt; and &lt;code&gt;XSRETURN&lt;/code&gt; macros. The &lt;code&gt;dMARK&lt;/code&gt; macro must be called prior to setup the &lt;code&gt;MARK&lt;/code&gt; variable.</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于指示堆栈基偏移，由 &lt;code&gt;ST&lt;/code&gt; ， &lt;code&gt;XSprePUSH&lt;/code&gt; 和 &lt;code&gt;XSRETURN&lt;/code&gt; 宏使用。所述 &lt;code&gt;dMARK&lt;/code&gt; 宏之前必须设置被叫 &lt;code&gt;MARK&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="71ae1592070f983485afeb1f94bb9f14e5751687" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate which of an XSUB's aliases was used to invoke it. See &lt;a href=&quot;perlxs#The-ALIAS%3a-Keyword&quot;&gt;The ALIAS: Keyword in perlxs&lt;/a&gt;.</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于指示使用哪个XSUB别名来调用它。请参阅&lt;a href=&quot;perlxs#The-ALIAS%3a-Keyword&quot;&gt;ALIAS：perlxs中的关键字&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="262d6897e3f4e2ab273d197b04708a28aa8bbe0f" translate="yes" xml:space="preserve">
          <source>Variable-length Parameter Lists</source>
          <target state="translated">可变长度的参数列表</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="ab9c1a29fb6d3de8ef612773205828e2a92ce7d5" translate="yes" xml:space="preserve">
          <source>Variables begin with &quot;$&quot;, &quot;@&quot; or &quot;%&quot; in Perl.</source>
          <target state="translated">在Perl中,变量以&quot;$&quot;、&quot;@&quot;或&quot;%&quot;开头。</target>
        </trans-unit>
        <trans-unit id="5694c664526ad480f20d39864f7f31a2f29da553" translate="yes" xml:space="preserve">
          <source>Variables beginning with underscore used to be forced into package main, but we decided it was more useful for package writers to be able to use leading underscore to indicate private variables and method names. However, variables and functions named with a single &lt;code&gt;_&lt;/code&gt; , such as $_ and &lt;code&gt;sub _&lt;/code&gt; , are still forced into the package &lt;code&gt;main&lt;/code&gt; . See also &lt;a href=&quot;perlvar#The-Syntax-of-Variable-Names&quot;&gt;The Syntax of Variable Names in perlvar&lt;/a&gt;.</source>
          <target state="translated">以下划线开头的变量曾经被强制放入包main，但是我们认为对于包编写者来说，使用前导下划线指示私有变量和方法名更为有用。但是，以单个 &lt;code&gt;_&lt;/code&gt; 命名的变量和函数（例如$ _和 &lt;code&gt;sub _&lt;/code&gt; ）仍被强制放入包 &lt;code&gt;main&lt;/code&gt; 中。另请参见&lt;a href=&quot;perlvar#The-Syntax-of-Variable-Names&quot;&gt;perlvar中的变量名语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d9f29c9ec062e45676786fba6e4ad3c40d0d306" translate="yes" xml:space="preserve">
          <source>Variables can also be marked as shared at compile time by using the &lt;code&gt;:shared&lt;/code&gt; attribute:</source>
          <target state="translated">也可以使用 &lt;code&gt;:shared&lt;/code&gt; 属性在编译时将变量标记为共享：</target>
        </trans-unit>
        <trans-unit id="0033a0c4e8e90fcf27d95fe18f7eaf535322599e" translate="yes" xml:space="preserve">
          <source>Variables created by &lt;code&gt;xsubpp&lt;/code&gt; and &lt;code&gt;xsubpp&lt;/code&gt; internal functions</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 和 &lt;code&gt;xsubpp&lt;/code&gt; 内部函数创建的变量</target>
        </trans-unit>
        <trans-unit id="2071c5e3d5c20b9e635746474f5973d9034dd205" translate="yes" xml:space="preserve">
          <source>Variables created by xsubpp and xsubpp internal functions</source>
          <target state="translated">由xsubpp和xsubpp内部函数创建的变量。</target>
        </trans-unit>
        <trans-unit id="ca450e789c925910d0144b598324f623b886a902" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; are not part of any package and are therefore never fully qualified with the package name. In particular, you're not allowed to try to make a package variable (or other global) lexical:</source>
          <target state="translated">用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明的变量不是任何程序包的一部分，因此永远不会用程序包名称完全限定。特别是，不允许您尝试使包变量（或其他全局变量）成为词法：</target>
        </trans-unit>
        <trans-unit id="56cf64dcca72d1ecb702e55ecfffca62a98a5220" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; only affect code</source>
          <target state="translated">用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 唯一的影响代码声明的变量</target>
        </trans-unit>
        <trans-unit id="8ca248e3be58f6491cbca3baeca1c24e3a843c96" translate="yes" xml:space="preserve">
          <source>Variables related to filehandles</source>
          <target state="translated">与filehandles相关的变量</target>
        </trans-unit>
        <trans-unit id="558d3788e0608ddd59e54bc45d3414f4ed7b1e43" translate="yes" xml:space="preserve">
          <source>Variables related to formats</source>
          <target state="translated">与格式有关的变量</target>
        </trans-unit>
        <trans-unit id="f14620676ede46dcf2f3ea6fa3c3858d660e5480" translate="yes" xml:space="preserve">
          <source>Variables related to regular expressions</source>
          <target state="translated">与正则表达式有关的变量</target>
        </trans-unit>
        <trans-unit id="68141fa59316c5490c4a375661890da2077e4814" translate="yes" xml:space="preserve">
          <source>Variables related to the interpreter state</source>
          <target state="translated">与解释器状态有关的变量</target>
        </trans-unit>
        <trans-unit id="9c673dd907946ee700d211969e18c41800f161cd" translate="yes" xml:space="preserve">
          <source>Variables that depend on the currently selected filehandle may be set by calling an appropriate object method on the &lt;code&gt;IO::Handle&lt;/code&gt; object, although this is less efficient than using the regular built-in variables. (Summary lines below for this contain the word HANDLE.) First you must say</source>
          <target state="translated">可以通过在 &lt;code&gt;IO::Handle&lt;/code&gt; 对象上调用适当的对象方法来设置依赖于当前所选文件句柄的变量，尽管这种方法的效率不如使用常规内置变量。（下面的摘要行包含&amp;ldquo; HANDLE&amp;rdquo;一词。）首先，您必须说</target>
        </trans-unit>
        <trans-unit id="e157f974af404a93fff305d4d8e7f7a16c700432" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_A&lt;/code&gt; (e.g., &lt;code&gt;isALPHA_A()&lt;/code&gt; ) is identical to the base function with no suffix &lt;code&gt;&quot;_A&quot;&lt;/code&gt; .</source>
          <target state="translated">变量 &lt;code&gt;isFOO_A&lt;/code&gt; （例如， &lt;code&gt;isALPHA_A()&lt;/code&gt; ）与基本函数相同，但没有后缀 &lt;code&gt;&quot;_A&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee9c1e7b92e7d90953ad4f56c51f36c66e7040f2" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_L1&lt;/code&gt; imposes the Latin-1 (or EBCDIC equivlalent) character set onto the platform. That is, the code points that are ASCII are unaffected, since ASCII is a subset of Latin-1. But the non-ASCII code points are treated as if they are Latin-1 characters. For example, &lt;code&gt;isWORDCHAR_L1()&lt;/code&gt; will return true when called with the code point 0xDF, which is a word character in both ASCII and EBCDIC (though it represents different characters in each).</source>
          <target state="translated">变体 &lt;code&gt;isFOO_L1&lt;/code&gt; 将Latin-1（或EBCDIC等价字符）强加到平台上。即，因为ASCII是Latin-1的子集，所以ASCII的代码点不受影响。但是，将非ASCII代码点视为拉丁1字符。例如，当使用代码点0xDF调用 &lt;code&gt;isWORDCHAR_L1()&lt;/code&gt; 时,它将返回true，这是ASCII和EBCDIC中的单词字符（尽管每个字符代表不同的字符）。</target>
        </trans-unit>
        <trans-unit id="2ba58c7880e89de07e18f6663de6bf67a770fa3f" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_LC&lt;/code&gt; is like the &lt;code&gt;isFOO_A&lt;/code&gt; and &lt;code&gt;isFOO_L1&lt;/code&gt; variants, but the result is based on the current locale, which is what &lt;code&gt;LC&lt;/code&gt; in the name stands for. If Perl can determine that the current locale is a UTF-8 locale, it uses the published Unicode rules; otherwise, it uses the C library function that gives the named classification. For example, &lt;code&gt;isDIGIT_LC()&lt;/code&gt; when not in a UTF-8 locale returns the result of calling &lt;code&gt;isdigit()&lt;/code&gt; . FALSE is always returned if the input won't fit into an octet. On some platforms where the C library function is known to be defective, Perl changes its result to follow the POSIX standard's rules.</source>
          <target state="translated">变体 &lt;code&gt;isFOO_LC&lt;/code&gt; 类似于 &lt;code&gt;isFOO_A&lt;/code&gt; 和 &lt;code&gt;isFOO_L1&lt;/code&gt; 变体，但结果基于当前语言环境，这就是名称中 &lt;code&gt;LC&lt;/code&gt; 的代表。如果Perl可以确定当前语言环境为UTF-8语言环境，则它将使用已发布的U​​nicode规则；否则，它将使用给出命名分类的C库函数。例如，如果 &lt;code&gt;isDIGIT_LC()&lt;/code&gt; 不在UTF-8语言环境中，则返回调用 &lt;code&gt;isdigit()&lt;/code&gt; 的结果。如果输入不适合八位字节，则始终返回FALSE。在某些已知C函数库存在缺陷的平台上，Perl更改其结果以遵循POSIX标准的规则。</target>
        </trans-unit>
        <trans-unit id="0cd770db8027add93d163f3958fbe5e0a03fc884" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_LC_utf8&lt;/code&gt; is like &lt;code&gt;isFOO_LC_uvchr&lt;/code&gt; , but the input is a pointer to a (known to be well-formed) UTF-8 encoded string (&lt;code&gt;U8*&lt;/code&gt; or &lt;code&gt;char*&lt;/code&gt; ). The classification of just the first (possibly multi-byte) character in the string is tested.</source>
          <target state="translated">变体 &lt;code&gt;isFOO_LC_utf8&lt;/code&gt; 类似于 &lt;code&gt;isFOO_LC_uvchr&lt;/code&gt; ，但是输入是指向（已知格式良好）UTF-8编码字符串（ &lt;code&gt;U8*&lt;/code&gt; 或 &lt;code&gt;char*&lt;/code&gt; ）的指针。测试字符串中仅第一个（可能为多字节）字符的分类。</target>
        </trans-unit>
        <trans-unit id="2e2baae040164a854cd256e8bb0078a6be7e0556" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_LC_uvchr&lt;/code&gt; is like &lt;code&gt;isFOO_LC&lt;/code&gt; , but is defined on any UV. It returns the same as &lt;code&gt;isFOO_LC&lt;/code&gt; for input code points less than 256, and returns the hard-coded, not-affected-by-locale, Unicode results for larger ones.</source>
          <target state="translated">变体 &lt;code&gt;isFOO_LC_uvchr&lt;/code&gt; 类似于 &lt;code&gt;isFOO_LC&lt;/code&gt; ，但是在任何UV上定义。对于小于256的输入代码点，它返回与 &lt;code&gt;isFOO_LC&lt;/code&gt; 相同的值，对于较大的代码点，则返回硬编码的，不受区域设置影响的Unicode结果。</target>
        </trans-unit>
        <trans-unit id="2ad298897b2ed0cfe491083076d3380e15f29221" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_uni&lt;/code&gt; is like the &lt;code&gt;isFOO_L1&lt;/code&gt; variant, but accepts any UV code point as input. If the code point is larger than 255, Unicode rules are used to determine if it is in the character class. For example, &lt;code&gt;isWORDCHAR_uni(0x100)&lt;/code&gt; returns TRUE, since 0x100 is LATIN CAPITAL LETTER A WITH MACRON in Unicode, and is a word character.</source>
          <target state="translated">变量 &lt;code&gt;isFOO_uni&lt;/code&gt; 类似于 &lt;code&gt;isFOO_L1&lt;/code&gt; 变量，但是接受任何UV代码点作为输入。如果代码点大于255，则使用Unicode规则确定它是否在字符类中。例如， &lt;code&gt;isWORDCHAR_uni(0x100)&lt;/code&gt; 返回TRUE，因为0x100是Unicode中的LATIN CAPITAL LETTER A WITH MACRON，并且是文字字符。</target>
        </trans-unit>
        <trans-unit id="4a2fc63255fac34edd7ea0e57902967c8c3777dd" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_utf8&lt;/code&gt; is like &lt;code&gt;isFOO_uni&lt;/code&gt; , but the input is a pointer to a (known to be well-formed) UTF-8 encoded string (&lt;code&gt;U8*&lt;/code&gt; or &lt;code&gt;char*&lt;/code&gt; ). The classification of just the first (possibly multi-byte) character in the string is tested.</source>
          <target state="translated">变体 &lt;code&gt;isFOO_utf8&lt;/code&gt; 类似于 &lt;code&gt;isFOO_uni&lt;/code&gt; ，但是输入是指向（已知格式良好）UTF-8编码的字符串（ &lt;code&gt;U8*&lt;/code&gt; 或 &lt;code&gt;char*&lt;/code&gt; ）的指针。测试字符串中仅第一个（可能为多字节）字符的分类。</target>
        </trans-unit>
        <trans-unit id="786f5e70748cc3ce6d3a4d95eb203e5790a45b20" translate="yes" xml:space="preserve">
          <source>Variant of make you intend to run the generated Makefile with. This parameter lets Makefile.PL know what make quirks to account for when generating the Makefile.</source>
          <target state="translated">你打算用make的变量来运行生成的Makefile。这个参数可以让Makefile.PL知道在生成Makefile时要考虑哪些make怪癖。</target>
        </trans-unit>
        <trans-unit id="8c77b7455bfd7adea569c5a3c57a2f0f3eeee8c3" translate="yes" xml:space="preserve">
          <source>Various ALLOW flags can be set in &lt;code&gt;flags&lt;/code&gt; to allow (and not warn on) individual types of malformations, such as the sequence being overlong (that is, when there is a shorter sequence that can express the same code point; overlong sequences are expressly forbidden in the UTF-8 standard due to potential security issues). Another malformation example is the first byte of a character not being a legal first byte. See</source>
          <target state="translated">可以在 &lt;code&gt;flags&lt;/code&gt; 中设置各种ALLOW标志，以允许（而不是发出警告）个别类型的格式错误，例如序列过长（即，当存在可以表示相同代码点的较短序列时；明确禁止过长序列）由于存在潜在的安全问题，请使用UTF-8标准）。另一个格式错误的示例是字符的第一个字节不是合法的第一个字节。看到</target>
        </trans-unit>
        <trans-unit id="afddad8d7b065f14bf0be2c971fc90accba56a72" translate="yes" xml:space="preserve">
          <source>Various Unicode Transformation Formats</source>
          <target state="translated">各种Unicode转换格式</target>
        </trans-unit>
        <trans-unit id="07521b5f641f36eca327ef3a95aecd1a3cb86300" translate="yes" xml:space="preserve">
          <source>Various flags whose names begin with &lt;code&gt;ANYOF_&lt;/code&gt; are used for special situations. Above Latin1 matches and things not known until run-time are stored in &lt;a href=&quot;#Perl's-pprivate-structure&quot;&gt;Perl's pprivate structure&lt;/a&gt;.</source>
          <target state="translated">在特殊情况下，会使用名称以 &lt;code&gt;ANYOF_&lt;/code&gt; 开头的各种标志。在Latin1匹配之上，直到运行时才知道的内容存储在&lt;a href=&quot;#Perl's-pprivate-structure&quot;&gt;Perl的pprivate结构中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44c78407657471f7c495761722bd853edd5018b1" translate="yes" xml:space="preserve">
          <source>Various people have made helpful suggestions and contributions, in particular:</source>
          <target state="translated">各界人士提出了有益的建议和意见,特别是:</target>
        </trans-unit>
        <trans-unit id="e18054f599f969e2a7425c026d09df10072d24d7" translate="yes" xml:space="preserve">
          <source>Various tools exist for analysing C source code &lt;b&gt;statically&lt;/b&gt;, as opposed to &lt;b&gt;dynamically&lt;/b&gt;, that is, without executing the code. It is possible to detect resource leaks, undefined behaviour, type mismatches, portability problems, code paths that would cause illegal memory accesses, and other similar problems by just parsing the C code and looking at the resulting graph, what does it tell about the execution and data flows. As a matter of fact, this is exactly how C compilers know to give warnings about dubious code.</source>
          <target state="translated">存在各种各样的工具来&lt;b&gt;静态地&lt;/b&gt;分析C源代码，而不是&lt;b&gt;动态地&lt;/b&gt;分析C源代码，也就是说，无需执行代码。仅通过解析C代码并查看结果图，就可以检测到资源泄漏，未定义的行为，类型不匹配，可移植性问题，可能导致非法内存访问的代码路径以及其他类似问题，这可以说明执行情况和数据流。事实上，这正是C编译器知道如何发出有关可疑代码的警告的方式。</target>
        </trans-unit>
        <trans-unit id="73cab00905b3a6637e1ac427d0bd8b9c7ea4bd82" translate="yes" xml:space="preserve">
          <source>Various useful techniques for the redirection of STDOUT and STDERR filehandles are explained in &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; and &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;和&lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;中介绍了用于STDOUT和STDERR文件句柄重定向的各种有用技术。</target>
        </trans-unit>
        <trans-unit id="348afb03d84f05d16f7adbc3eb8e693f676f5018" translate="yes" xml:space="preserve">
          <source>Varying slowly compared to something else. (Unfortunately, everything is relatively stable compared to something else, except for certain elementary particles, and we&amp;rsquo;re not so sure about them.) In computers, where things are supposed to vary rapidly, &amp;ldquo;static&amp;rdquo; has a derogatory connotation, indicating a slightly dysfunctional &lt;b&gt;variable&lt;/b&gt;, &lt;b&gt;subroutine&lt;/b&gt;, or &lt;b&gt;method&lt;/b&gt;. In Perl culture, the word is politely avoided.</source>
          <target state="translated">与其他事物相比变化缓慢。 （不幸的是，与某些事物相比，除某些基本粒子之外，其他事物都相对稳定，我们对它们不太确定。）在计算机中，事物应该迅速变化，&amp;ldquo;静态&amp;rdquo;具有贬义含义，表示&lt;b&gt;变量&lt;/b&gt;，&lt;b&gt;子程序&lt;/b&gt;或&lt;b&gt;方法的&lt;/b&gt;功能稍有失调。在Perl文化中，礼貌地避免使用该词。</target>
        </trans-unit>
        <trans-unit id="85ffef503f476138b4fff0b28711a4307dd0273e" translate="yes" xml:space="preserve">
          <source>Vendor locales are notoriously buggy, and it is difficult for Perl to test its locale-handling code because this interacts with code that Perl has no control over; therefore the locale-handling code in Perl may be buggy as well. (However, the Unicode-supplied locales should be better, and there is a feed back mechanism to correct any problems. See &lt;a href=&quot;#Freely-available-locale-definitions&quot;&gt;Freely available locale definitions&lt;/a&gt;.)</source>
          <target state="translated">供应商语言环境臭名昭著的是bug，Perl很难测试其语言环境处理代码，因为这与Perl无法控制的代码交互。因此，Perl中的语言环境处理代码也可能有问题。（但是，提供Unicode的语言环境应该更好，并且有一种反馈机制可以纠正任何问题。请参阅&lt;a href=&quot;#Freely-available-locale-definitions&quot;&gt;免费提供的语言环境定义&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="6d32a0f82e0ef391607d7fd073f792ba0310faa2" translate="yes" xml:space="preserve">
          <source>Verbatim Paragraph</source>
          <target state="translated">逐字记录段</target>
        </trans-unit>
        <trans-unit id="3c3c8bdee8d70621828a9acf42235be7b9af6f25" translate="yes" xml:space="preserve">
          <source>Verbatim paragraphs are usually used for presenting a codeblock or other text which does not require any special parsing or formatting, and which shouldn't be wrapped.</source>
          <target state="translated">逐字段通常用于呈现不需要任何特殊解析或格式化的代码块或其他文本,并且不应该被包装。</target>
        </trans-unit>
        <trans-unit id="d2ed762aa9e6f4a70c69d05cecc69ec96c79f712" translate="yes" xml:space="preserve">
          <source>Verbosity level for PERL5LIB changes (none or v)?</source>
          <target state="translated">PERL5LIB变化的verbosity级别(无或v)?</target>
        </trans-unit>
        <trans-unit id="b16f50ef11893ee8a56a924cf21f29d6d3384b2d" translate="yes" xml:space="preserve">
          <source>Verbosity level for loading modules (none or v)?</source>
          <target state="translated">加载模块的verbosity级别(无或v)?</target>
        </trans-unit>
        <trans-unit id="5c786adc4be052262918fbf867ae699f3967bdb1" translate="yes" xml:space="preserve">
          <source>Verifies your POD's correctness</source>
          <target state="translated">验证您的POD的正确性</target>
        </trans-unit>
        <trans-unit id="d4e18ac1b3adf04f8a64f79e732d6cb231328446" translate="yes" xml:space="preserve">
          <source>Verify that</source>
          <target state="translated">确认</target>
        </trans-unit>
        <trans-unit id="c6d2ae8d70f95ac35eb4f17f52487e3fbb74bfe8" translate="yes" xml:space="preserve">
          <source>Verify that &lt;code&gt;ADDRESS&lt;/code&gt; is a legitimate mailing address.</source>
          <target state="translated">确认 &lt;code&gt;ADDRESS&lt;/code&gt; 是合法的邮寄地址。</target>
        </trans-unit>
        <trans-unit id="aa131b92248ccc3e18a5da63bd932dabad63bce2" translate="yes" xml:space="preserve">
          <source>Verify that the element at index</source>
          <target state="translated">确认索引处的元素</target>
        </trans-unit>
        <trans-unit id="994d1b0dafb2a784fe9a62de996298af3c56fa67" translate="yes" xml:space="preserve">
          <source>Version 0.17</source>
          <target state="translated">0.17版本</target>
        </trans-unit>
        <trans-unit id="cf9296ff9faf64bcbf7077fc94b20c36180a2b81" translate="yes" xml:space="preserve">
          <source>Version 1.0 metadata specification for META.yml</source>
          <target state="translated">META.yml的1.0版元数据规范。</target>
        </trans-unit>
        <trans-unit id="5f58248b430683f1248cf64cbe1e704fe1b1c2aa" translate="yes" xml:space="preserve">
          <source>Version 1.1 metadata specification for META.yml</source>
          <target state="translated">META.yml的1.1版元数据规范。</target>
        </trans-unit>
        <trans-unit id="6b502e3047cfe1751d1d1b7edc28b46bfd3a8d92" translate="yes" xml:space="preserve">
          <source>Version 1.2 metadata specification for META.yml</source>
          <target state="translated">META.yml的1.2版元数据规范。</target>
        </trans-unit>
        <trans-unit id="c0707932557d9b8e2fa8ebb9e9863bf7fee11d96" translate="yes" xml:space="preserve">
          <source>Version 1.3 metadata specification for META.yml</source>
          <target state="translated">META.yml的1.3版元数据规范。</target>
        </trans-unit>
        <trans-unit id="6bb856fd2cb7a8a4749ea08a96d81eed38d2bee4" translate="yes" xml:space="preserve">
          <source>Version 1.3, 14th Apr 1997</source>
          <target state="translated">1.3版,1997年4月14日</target>
        </trans-unit>
        <trans-unit id="50cdda2fafe15d6a81c70eb22bbe3a4d4d6f2154" translate="yes" xml:space="preserve">
          <source>Version 1.4 metadata specification for META.yml</source>
          <target state="translated">META.yml的1.4版元数据规范。</target>
        </trans-unit>
        <trans-unit id="e595432938de926793decdb5491565f726cb5632" translate="yes" xml:space="preserve">
          <source>Version 1.x of Devel::PPPort was written by Kenneth Albanowski.</source>
          <target state="translated">1.x版本的Devel::PPPort是由Kenneth Albanowski编写的。</target>
        </trans-unit>
        <trans-unit id="a64e96de79863ac878adbe6d99f0ef3004f7ada2" translate="yes" xml:space="preserve">
          <source>Version 1.x, Copyright (C) 1999, Kenneth Albanowski.</source>
          <target state="translated">版本1.x,版权(C)1999,Kenneth Albanowski。</target>
        </trans-unit>
        <trans-unit id="a5a2dcb962ed837bde5bb2d230fbf541ca8dd67b" translate="yes" xml:space="preserve">
          <source>Version 1.x, Copyright (c) 1997, Graham Barr.</source>
          <target state="translated">1.x版,版权(c)1997年,Graham Barr。</target>
        </trans-unit>
        <trans-unit id="45647cd5610f6e1c8ad80ff8302e3680ebe69bd4" translate="yes" xml:space="preserve">
          <source>Version 2.07 included 2 functions for modifying the internal data: rename_country and alias_code. Both of these could be used only to modify the internal data for country codes.</source>
          <target state="translated">2.07版包括2个修改内部数据的函数:rename_country和alias_code。这两个函数只能用于修改国家代码的内部数据。</target>
        </trans-unit>
        <trans-unit id="92a1c91419a81cd1268ac19dce637a320313655e" translate="yes" xml:space="preserve">
          <source>Version 2.158 (March 13 2015)</source>
          <target state="translated">2.158版(2015年3月13日)</target>
        </trans-unit>
        <trans-unit id="2b76e68914b5b481fce750a4808d6a01e4e0d7a5" translate="yes" xml:space="preserve">
          <source>Version 2.x was ported to the Perl core by Paul Marquess.</source>
          <target state="translated">2.x版本是由Paul Marquess移植到Perl核心的。</target>
        </trans-unit>
        <trans-unit id="b4dfa929b5ee3edcabc4bb1ff1f2299b2ba1ffbf" translate="yes" xml:space="preserve">
          <source>Version 2.x, Copyright (C) 2001, Paul Marquess.</source>
          <target state="translated">版本2.x,版权(C)2001,Paul Marquess。</target>
        </trans-unit>
        <trans-unit id="afb9e5ddc0f066d6e4fe7219b73a7a8e7aeed9fa" translate="yes" xml:space="preserve">
          <source>Version 2.x, Copyright (C) 2007-2013, Marcus Holland-Moritz.</source>
          <target state="translated">Version 2.x,Copyright (C)2007-2013,Marcus Holland-Moritz.</target>
        </trans-unit>
        <trans-unit id="2b92364fcb707c868641f18b85e8bb1624050d73" translate="yes" xml:space="preserve">
          <source>Version 3.35</source>
          <target state="translated">3.35版本</target>
        </trans-unit>
        <trans-unit id="4f0303ef100e7bd0b627ac0ed92f17d79836c82a" translate="yes" xml:space="preserve">
          <source>Version 3.x was ported back to CPAN by Marcus Holland-Moritz.</source>
          <target state="translated">3.x版本由Marcus Holland-Moritz移植回CPAN。</target>
        </trans-unit>
        <trans-unit id="87ba3aa39294d7bd5f976dfda6425a25c0769a48" translate="yes" xml:space="preserve">
          <source>Version 3.x, Copyright (C) 2004-2013, Marcus Holland-Moritz.</source>
          <target state="translated">版本3.x,版权(C)2004-2013,Marcus Holland-Moritz。</target>
        </trans-unit>
        <trans-unit id="70ac02d65beabeafc66ef77aabf5e475e6710dac" translate="yes" xml:space="preserve">
          <source>Version 8 Regular Expressions</source>
          <target state="translated">第八版正则表达式</target>
        </trans-unit>
        <trans-unit id="5148ac4d9167ac054bd9f1a1a44dfedd508ff1b8" translate="yes" xml:space="preserve">
          <source>Version Strings</source>
          <target state="translated">版本字符串</target>
        </trans-unit>
        <trans-unit id="68c98714c821df335863c348a8dc241ec68a74da" translate="yes" xml:space="preserve">
          <source>Version caveat</source>
          <target state="translated">版本注意事项</target>
        </trans-unit>
        <trans-unit id="01e4cae31c98991a3d53edad9d5a04ca08ed4f3b" translate="yes" xml:space="preserve">
          <source>Version numbering</source>
          <target state="translated">版本编号</target>
        </trans-unit>
        <trans-unit id="7a4b23d2aee6859898d9d8a68bcc2c3cf6b34466" translate="yes" xml:space="preserve">
          <source>Version numbers can be checked like so:</source>
          <target state="translated">版本号可以这样查询。</target>
        </trans-unit>
        <trans-unit id="9ea6fb41a1f5c2adb11175166f62cfde32e3e36d" translate="yes" xml:space="preserve">
          <source>Version numbers should indicate at least major and minor releases, and possibly sub-minor releases. A major release is one in which most of the functionality has changed, or in which major new functionality is added. A minor release is one in which a small amount of functionality has been added or changed. Sub-minor version numbers are usually used for changes which do not affect functionality, such as documentation patches.</source>
          <target state="translated">版本号应至少表示主要和次要版本,可能还有次要版本。主要版本是指大部分功能发生了变化,或增加了新的主要功能。次要版本是指增加或修改了少量功能的版本。次小版本号通常用于不影响功能的更改,如文档补丁。</target>
        </trans-unit>
        <trans-unit id="d33038b68a6d275b70080c4ca40f495c404258ac" translate="yes" xml:space="preserve">
          <source>Version object aware cmp. Both operands must already have been converted into version objects.</source>
          <target state="translated">版本对象感知cmp。两个操作数都必须已经被转换为版本对象。</target>
        </trans-unit>
        <trans-unit id="2750d3223582565870adf32b96da562927d7229f" translate="yes" xml:space="preserve">
          <source>Versioning</source>
          <target state="translated">Versioning</target>
        </trans-unit>
        <trans-unit id="6fe8bcdb81f192c675970c262f42ae11e468a493" translate="yes" xml:space="preserve">
          <source>Versions &amp;gt;= 3.22 are maintained with support from Matthew Horsfall (alh).</source>
          <target state="translated">&amp;gt; = 3.22的版本在Matthew Horsfall（alh）的支持下得以维护。</target>
        </trans-unit>
        <trans-unit id="0a0e4cacd3bf4b53f4105e538a9024d7fb5c49ec" translate="yes" xml:space="preserve">
          <source>Versions of Perl from 5.002 to 5.003 did use the &lt;code&gt;LC_CTYPE&lt;/code&gt; information if available; that is, &lt;code&gt;\w&lt;/code&gt; did understand what were the letters according to the locale environment variables. The problem was that the user had no control over the feature: if the C library supported locales, Perl used them.</source>
          <target state="translated">从5.002到5.003的Perl版本确实使用了 &lt;code&gt;LC_CTYPE&lt;/code&gt; 信息（如果有）；也就是说， &lt;code&gt;\w&lt;/code&gt; 确实根据区域设置环境变量了解字母是什么。问题在于用户无法控制该功能：如果C库支持语言环境，则Perl会使用它们。</target>
        </trans-unit>
        <trans-unit id="e19f78e14eb21b19646ec53e2aa5cba777aaa99b" translate="yes" xml:space="preserve">
          <source>Versions of Perl prior to 5.004 &lt;b&gt;mostly&lt;/b&gt; ignored locale information, generally behaving as if something similar to the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale were always in force, even if the program environment suggested otherwise (see &lt;a href=&quot;#The-setlocale-function&quot;&gt;The setlocale function&lt;/a&gt;). By default, Perl still behaves this way for backward compatibility. If you want a Perl application to pay attention to locale information, you &lt;b&gt;must&lt;/b&gt; use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma (see &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;The use locale pragma&lt;/a&gt;) or, in the unlikely event that you want to do so for just pattern matching, the &lt;code&gt;/l&lt;/code&gt; regular expression modifier (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt;) to instruct it to do so.</source>
          <target state="translated">5.004之前的Perl版本&lt;b&gt;大多&lt;/b&gt;忽略了语言环境信息，即使程序环境另有建议，通常似乎总是在执行类似于 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 语言环境的行为（请参阅&lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale函数&lt;/a&gt;）。默认情况下，Perl仍然以这种方式运行以实现向后兼容。如果要让Perl应用程序注意语言环境信息，则&lt;b&gt;必须&lt;/b&gt;使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma（请参阅&lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;The use locale pragma&lt;/a&gt;），或者在不太可能发生的仅用于模式匹配的情况下，使用 &lt;code&gt;/l&lt;/code&gt; 正则表达式修饰符（请参见&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre中的字符集修饰符&lt;/a&gt;）以指示它这样做。</target>
        </trans-unit>
        <trans-unit id="cd42417aaf403d8a849b95358e372d8ab627e926" translate="yes" xml:space="preserve">
          <source>Versions of Perl prior to 5.6 would recompile the regular expression for each iteration, even if &lt;code&gt;$pattern&lt;/code&gt; had not changed. The &lt;code&gt;/o&lt;/code&gt; would prevent this by telling Perl to compile the pattern the first time, then reuse that for subsequent iterations:</source>
          <target state="translated">即使 &lt;code&gt;$pattern&lt;/code&gt; 不变，5.6之前的Perl版本也会为每次迭代重新编译正则表达式。的 &lt;code&gt;/o&lt;/code&gt; 将防止此通过告诉Perl来编译该图案在第一时间，然后重新使用用于随后的迭代：</target>
        </trans-unit>
        <trans-unit id="3862168f946314ea765703eeec887a87938d1f6e" translate="yes" xml:space="preserve">
          <source>Versions prior to perl5.004 had serious security problems with buffer overflows, and in some cases have CERT advisories (for instance, &lt;a href=&quot;http://www.cert.org/advisories/CA-1997-17.html&quot;&gt;http://www.cert.org/advisories/CA-1997-17.html&lt;/a&gt; ).</source>
          <target state="translated">perl5.004之前的版本存在严重的安全问题，缓冲区溢出，并且在某些情况下具有CERT咨询（例如，&lt;a href=&quot;http://www.cert.org/advisories/CA-1997-17.html&quot;&gt;http://www.cert.org/advisories/CA-1997-17.html&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="af88a51473f729bd7efb750c66c484d3ad88aa17" translate="yes" xml:space="preserve">
          <source>Versions up to 2.11 Copyright (c) 1995-2004 Graham Barr. All rights reserved. Changes in Version 2.11 onwards Copyright (C) 2014 Steve Hay. All rights reserved.</source>
          <target state="translated">2.11以下版本 版权所有 (c)1995-2004 Graham Barr。保留所有权利。2.11以上版本的变更 Copyright (C)2014 Steve Hay.保留所有权利。</target>
        </trans-unit>
        <trans-unit id="645570264e1c9b5d4c69c1487a566c0753776ad2" translate="yes" xml:space="preserve">
          <source>Versions up to 2.13 Copyright (c) 1995-1998 Graham Barr. All rights reserved. Changes in Version 2.13_01 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">2.13以下版本 版权所有 (c)1995-1998 Graham Barr。保留所有权利。2.13_01以上版本的变更 Copyright (C)2013-2014 Steve Hay.保留所有权利。</target>
        </trans-unit>
        <trans-unit id="df128b7f68ed19de182414be1bd4f1f2d9c6a0b4" translate="yes" xml:space="preserve">
          <source>Versions up to 2.21 Copyright (c) 1995-1998 Graham Barr. All rights reserved. Changes in Version 2.22 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">版本至2.21 Copyright (c)1995-1998 Graham Barr.保留所有权利。2.22以上版本的变更 Copyright (C)2013-2014 Steve Hay.保留所有权利。</target>
        </trans-unit>
        <trans-unit id="230af24ce1338603fae4bdb469b6688c0e4037a9" translate="yes" xml:space="preserve">
          <source>Versions up to 2.24_1 Copyright (c) 1995-1997 Graham Barr. All rights reserved. Changes in Version 2.25 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">版本至2.24_1 Copyright (c)1995-1997 Graham Barr.保留所有权利。2.25以上版本的变更 Copyright (C)2013-2014 Steve Hay.保留所有权利。</target>
        </trans-unit>
        <trans-unit id="5670a2aa1f7771d1194bac3e8af5f2d1835dd801" translate="yes" xml:space="preserve">
          <source>Versions up to 2.29 Copyright (c) 1995-2004 Graham Barr. All rights reserved. Changes in Version 2.29_01 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">版本至2.29 Copyright (c)1995-2004 Graham Barr.保留所有权利。2.29_01以上版本的变更 Copyright (C)2013-2014 Steve Hay.保留所有权利。</target>
        </trans-unit>
        <trans-unit id="f23d5e96a8b776d3b4630eccbbe42aa010b76c05" translate="yes" xml:space="preserve">
          <source>Versions up to 2.29_1 Copyright (c) 1995-2006 Graham Barr. All rights reserved. Changes in Version 2.29_2 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">版本至2.29_1 Copyright (c)1995-2006 Graham Barr.保留所有权利。2.29_2以上版本的变更 Copyright (C)2013-2014 Steve Hay.保留所有权利。</target>
        </trans-unit>
        <trans-unit id="84d20de3782c28252a3c6f7756f86f07da1b04bb" translate="yes" xml:space="preserve">
          <source>Versions up to 2.31_1 Copyright (c) 1995-2004 Graham Barr. All rights reserved. Changes in Version 2.31_2 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">版本至2.31_1 Copyright (c)1995-2004 Graham Barr.保留所有权利。2.31_2以上版本的变更 Copyright (C)2013-2014 Steve Hay.保留所有权利。</target>
        </trans-unit>
        <trans-unit id="e46c1089fa8e642aaf026e639393be6e2f9a3f93" translate="yes" xml:space="preserve">
          <source>Versions up to 2.77_2 Copyright (c) 1995-2004 Graham Barr. All rights reserved. Changes in Version 2.77_3 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">版本至 2.77_2 Copyright (c)1995-2004 Graham Barr.保留所有权利。2.77_3以上版本的变更 Copyright (C)2013-2014 Steve Hay.保留所有权利.</target>
        </trans-unit>
        <trans-unit id="3e953c4e403299818cc2d2c327160433abe8b2b9" translate="yes" xml:space="preserve">
          <source>Very large code points (above 0x7FFF_FFFF) are considered more problematic than the others that are above the Unicode legal maximum. There are several reasons: they requre at least 32 bits to represent them on ASCII platforms, are not representable at all on EBCDIC platforms, and the original UTF-8 specification never went above this number (the current 0x10FFFF limit was imposed later). (The smaller ones, those that fit into 32 bits, are representable by a UV on ASCII platforms, but not by an IV, which means that the number of operations that can be performed on them is quite restricted.) The UTF-8 encoding on ASCII platforms for these large code points begins with a byte containing 0xFE or 0xFF. The UTF8_DISALLOW_FE_FF flag will cause them to be treated as malformations, while allowing smaller above-Unicode code points. (Of course UTF8_DISALLOW_SUPER will treat all above-Unicode code points, including these, as malformations.) Similarly, UTF8_WARN_FE_FF acts just like the other WARN flags, but applies just to these code points.</source>
          <target state="translated">非常大的码点(高于0x7FFF_FFFF)被认为比其他超过Unicode法定最大值的码点更有问题。有几个原因:它们至少需要32位才能在ASCII平台上表示,在EBCDIC平台上根本无法表示,而且最初的UTF-8规范从来没有超过这个数字(目前的0x10FFFF限制是后来强加的)。(更小的,适合32位的,在ASCII平台上可以用UV来表示,但不能用IV来表示,这意味着对它们进行操作的数量受到了很大的限制)。在ASCII平台上,这些大码点的UTF-8编码以一个包含0xFE或0xFF的字节开始。UTF8_DISALLOW_FE_FF标志将使它们被当作畸形码处理,同时允许较小的以上Unicode码点。当然,UTF8_DISALLOW_SUPER将把所有高于Unicode的码点,包括这些码点,都视为畸形。同样,UTF8_WARN_FE_FF的作用和其他WARN标志一样,但只适用于这些码点。</target>
        </trans-unit>
        <trans-unit id="a0d5201ccd05c9ec8ec53b6a69352780556eae41" translate="yes" xml:space="preserve">
          <source>Very little work should be needed since nothing changes until you generate Unicode data. The most important thing is getting input as Unicode; for that, see the earlier I/O discussion. To get full seamless Unicode support, add &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher) to your script.</source>
          <target state="translated">几乎不需要做任何工作，因为在生成Unicode数据之前没有任何变化。最重要的是获取输入为Unicode。为此，请参见前面的I / O讨论。要获得完全的无缝Unicode支持，请在脚本中添加 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; （或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 或更高版本）。</target>
        </trans-unit>
        <trans-unit id="eb22342c76c7e665931efb33364b8148d2bfea0a" translate="yes" xml:space="preserve">
          <source>Very nearly all Unicode character properties are accessible through regular expressions by using the &lt;code&gt;\p{}&lt;/code&gt; &quot;matches property&quot; construct and the &lt;code&gt;\P{}&lt;/code&gt; &quot;doesn't match property&quot; for its negation.</source>
          <target state="translated">通过使用 &lt;code&gt;\p{}&lt;/code&gt; &amp;ldquo; matches属性&amp;rdquo;构造和 &lt;code&gt;\P{}&lt;/code&gt; &amp;ldquo;不匹配属性&amp;rdquo;进行否定，几乎所有的Unicode字符属性都可以通过正则表达式访问。</target>
        </trans-unit>
        <trans-unit id="5c9d6c4d037708bb7601d0c4b194d48f70b48661" translate="yes" xml:space="preserve">
          <source>Very probably not. Unless you are generating Unicode characters somehow, old behaviour should be preserved. About the only behaviour that has changed and which could start generating Unicode is the old behaviour of &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; where supplying an argument more than 255 produced a character modulo 255. &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(300)&lt;/a&gt;&lt;/code&gt;, for example, was equal to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(45)&lt;/a&gt;&lt;/code&gt; or &quot;-&quot; (in ASCII), now it is LATIN CAPITAL LETTER I WITH BREVE.</source>
          <target state="translated">很有可能不会。除非以某种方式生成Unicode字符，否则应保留旧的行为。关于唯一已更改并可能开始生成Unicode的行为是 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; 的旧行为，其中提供的参数超过255会产生字符模255。例如， &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(300)&lt;/a&gt;&lt;/code&gt; 等于 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(45)&lt;/a&gt;&lt;/code&gt; 或&amp;ldquo;-&amp;rdquo;（以ASCII表示），现在是带有大写字母的拉丁文大写字母I。</target>
        </trans-unit>
        <trans-unit id="3df57364769892c03471ecd89738053fe81083da" translate="yes" xml:space="preserve">
          <source>Very similar to HTML/XML &lt;code&gt;&amp;amp;&lt;i&gt;foo&lt;/i&gt;;&lt;/code&gt; &quot;entity references&quot;:</source>
          <target state="translated">与HTML / XML &lt;code&gt;&amp;amp;&lt;i&gt;foo&lt;/i&gt;;&lt;/code&gt; 非常相似；&amp;ldquo;实体引用&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="88a7cc964078758d646c21f587f22b62e9a2dd56" translate="yes" xml:space="preserve">
          <source>Very useful online reference material:</source>
          <target state="translated">非常有用的在线参考资料。</target>
        </trans-unit>
        <trans-unit id="81b34b94e5e74c2375523a735ce4a25a6536b5a0" translate="yes" xml:space="preserve">
          <source>View a few lines of code around the current line.</source>
          <target state="translated">查看当前行周围的几行代码。</target>
        </trans-unit>
        <trans-unit id="ee53ceb3384ce0d69b124dce7f13e6c99981e32e" translate="yes" xml:space="preserve">
          <source>View existing bug reports at, and submit any new bugs, problems, patches, etc. to: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=threads-shared&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=threads-shared&lt;/a&gt;</source>
          <target state="translated">查看以下位置的现有错误报告，并将任何新的错误，问题，补丁等提交到：&lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=threads-shared&quot;&gt;http&lt;/a&gt; : //rt.cpan.org/Public/Dist/Display.html?Name=threads-shared</target>
        </trans-unit>
        <trans-unit id="3ee82a6b555759727c4e5933e475a065e10be5a6" translate="yes" xml:space="preserve">
          <source>Vipul Ved Prakash &amp;lt;mail AT vipul DOT net&amp;gt; - Helping with debugging</source>
          <target state="translated">Vipul Ved Prakash &amp;lt;邮件发送到vipul DOT网络&amp;gt;-帮助调试</target>
        </trans-unit>
        <trans-unit id="028988d7a45fe46ec8fd41d271d201dc35932db0" translate="yes" xml:space="preserve">
          <source>Visual Perl is a Visual Studio.NET plug-in from ActiveState.</source>
          <target state="translated">Visual Perl是ActiveState的一个Visual Studio.NET插件。</target>
        </trans-unit>
        <trans-unit id="386d827cc4ba6b5f42c38cef2abc770e9c36de72" translate="yes" xml:space="preserve">
          <source>Volumes can be drive letters or UNC sharenames (\\server\share).</source>
          <target state="translated">卷可以是驱动字母,也可以是UNC sharenames (\server\share)。</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="c26d74df8890b7f659e90425275e4ff437fc0eeb" translate="yes" xml:space="preserve">
          <source>WAIT</source>
          <target state="translated">WAIT</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="3c94abff24468ec74283806394c7e1079287562a" translate="yes" xml:space="preserve">
          <source>WARNING: A variable used as a buffer by &lt;code&gt;setbuf&lt;/code&gt; or &lt;code&gt;setvbuf&lt;/code&gt;&lt;b&gt;must not be modified&lt;/b&gt; in any way until the IO::Handle is closed or &lt;code&gt;setbuf&lt;/code&gt; or &lt;code&gt;setvbuf&lt;/code&gt; is called again, or memory corruption may result! Remember that the order of global destruction is undefined, so even if your buffer variable remains in scope until program termination, it may be undefined before the file IO::Handle is closed. Note that you need to import the constants &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; , and &lt;code&gt;_IONBF&lt;/code&gt; explicitly. Like C, setbuf returns nothing. setvbuf returns &quot;0 but true&quot;, on success, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">警告：在关闭IO :: Handle或再次调用 &lt;code&gt;setbuf&lt;/code&gt; 或 &lt;code&gt;setvbuf&lt;/code&gt; 之前，&lt;b&gt;不得&lt;/b&gt;以任何方式&lt;b&gt;修改&lt;/b&gt; &lt;code&gt;setbuf&lt;/code&gt; 或 &lt;code&gt;setvbuf&lt;/code&gt; 用作缓冲区的变量，否则可能导致内存损坏！请记住，全局销毁的顺序是不确定的，因此即使您的缓冲区变量在程序终止之前一直在作用域内，在关闭文件IO :: Handle之前它也可能是不确定的。请注意，您需要显式导入常量 &lt;code&gt;_IOFBF&lt;/code&gt; ， &lt;code&gt;_IOLBF&lt;/code&gt; 和 &lt;code&gt;_IONBF&lt;/code&gt; 。像C一样，setbuf不返回任何内容。setvbuf成功时返回&amp;ldquo; 0但为真&amp;rdquo;，失败时 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="84c2915b48a50feabe204322fda8dc2bbdf52e7d" translate="yes" xml:space="preserve">
          <source>WARNING: As of the 5.004 release, proper usage of the array and hash access functions requires understanding a few caveats. Some of these caveats are actually considered bugs in the API, to be fixed in later releases, and are bracketed with [MAYCHANGE] below. If you find yourself actually applying such information in this section, be aware that the behavior may change in the future, umm, without warning.</source>
          <target state="translated">警告:从5.004版本开始,正确使用数组和哈希访问函数需要了解一些注意事项。其中一些注意事项实际上被认为是API中的bug,将在以后的版本中修复,并在下面用[MAYCHANGE]括起来。如果你发现自己实际应用了本节中的这些信息,请注意行为可能会在未来改变,嗯,没有警告。</target>
        </trans-unit>
        <trans-unit id="05aab9ee07d74b03226bac90b4501275a8030a8f" translate="yes" xml:space="preserve">
          <source>WARNING: The IO::Handle::setvbuf() is not available by default on Perls 5.8.0 and later because setvbuf() is rather specific to using the stdio library, while Perl prefers the new perlio subsystem instead.</source>
          <target state="translated">警告:IO::Handle::setvbuf()在Perls 5.8.0及以后的版本中默认是不可用的,因为setvbuf()是专门针对stdio库的,而Perl更喜欢使用新的perlio子系统。</target>
        </trans-unit>
        <trans-unit id="19985e22537400319dbf86c71031d6722bd3ab22" translate="yes" xml:space="preserve">
          <source>WARNING: This variable is strictly for internal use only. Its availability, behavior, and contents are subject to change without notice.</source>
          <target state="translated">警告:此变量仅用于内部使用,其可用性、行为和内容如有变化,恕不另行通知。它的可用性、行为和内容如有变化,恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="5fbfa986b2fb43598295e70fb2ca9f7ae7e83632" translate="yes" xml:space="preserve">
          <source>WARNING: do not use the following unless you *know* &lt;code&gt;off&lt;/code&gt; is within the UTF-8 data pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; *and* that on entry &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; is aligned on the first byte of character or just after the last byte of a character.</source>
          <target state="translated">警告：除非您*知道* &lt;code&gt;off&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 所指向的UTF-8数据内并且*项 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 上的位置是在字符的第一个字节上或在字符的最后一个字节后对齐，否则不要使用以下内容。</target>
        </trans-unit>
        <trans-unit id="678aa148e87e729dd3e10fce0605ee0538d043a2" translate="yes" xml:space="preserve">
          <source>WARNING: use only if you *know* that the pointers point inside the same UTF-8 buffer.</source>
          <target state="translated">警告:只有当你*知道指针指向同一个UTF-8缓冲区内时才使用。</target>
        </trans-unit>
        <trans-unit id="163b0dd1ef8e487db793ddc755bf68fdfda1ccf3" translate="yes" xml:space="preserve">
          <source>WARNINGS</source>
          <target state="translated">WARNINGS</target>
        </trans-unit>
        <trans-unit id="991fe4b3587f5bc3956dbdf64cab7946d865d2e1" translate="yes" xml:space="preserve">
          <source>WARRANTY</source>
          <target state="translated">WARRANTY</target>
        </trans-unit>
        <trans-unit id="899abc782023a16c90d026f7662b081d0e5603bf" translate="yes" xml:space="preserve">
          <source>WELCOME to Plan 9 Perl, brave soul!</source>
          <target state="translated">欢迎来到Plan 9 Perl,勇敢的灵魂!</target>
        </trans-unit>
        <trans-unit id="943f25cc8d7abfb9400129c428f47471a4e77ccc" translate="yes" xml:space="preserve">
          <source>WHAT</source>
          <target state="translated">WHAT</target>
        </trans-unit>
        <trans-unit id="d8c634435f258992c7dbf89bc42a5c10afe89f43" translate="yes" xml:space="preserve">
          <source>WHAT ABOUT &lt;code&gt;DB_File&lt;/code&gt; ?</source>
          <target state="translated">关于 &lt;code&gt;DB_File&lt;/code&gt; 呢？</target>
        </trans-unit>
        <trans-unit id="a3e4fe4880a26ca7ed67d03d21e6c8855e324c1e" translate="yes" xml:space="preserve">
          <source>WHAT ABOUT DB_File?</source>
          <target state="translated">什么是DB_File?</target>
        </trans-unit>
        <trans-unit id="69dc14e97abf1c2f032d0ecddf4083e210815600" translate="yes" xml:space="preserve">
          <source>WHAT IS A LOCALE</source>
          <target state="translated">什么是地点</target>
        </trans-unit>
        <trans-unit id="8df7eec36d2c3cf583d0c776054ef24d9f2ed0ea" translate="yes" xml:space="preserve">
          <source>WHAT NEXT?</source>
          <target state="translated">接下来呢?</target>
        </trans-unit>
        <trans-unit id="a31a09e4a44017984cab9426a275543f91816385" translate="yes" xml:space="preserve">
          <source>WHY YOU SHOULD ALWAYS &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt;</source>
          <target state="translated">为什么您应该始终 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcf4ad6d76037668ee7377a5088288d629d80a03" translate="yes" xml:space="preserve">
          <source>WHY YOU SHOULD ALWAYS use strict</source>
          <target state="translated">为什么你总是使用严格的</target>
        </trans-unit>
        <trans-unit id="89237cfda70e873f323e7dd25612ea5b444530a5" translate="yes" xml:space="preserve">
          <source>WIZARDS ONLY</source>
          <target state="translated">仅限IZARDS</target>
        </trans-unit>
        <trans-unit id="612951b55eb7373e18b643aac58cf8c1af06a81c" translate="yes" xml:space="preserve">
          <source>WORKING WITH CPAN.pm BEHIND FIREWALLS</source>
          <target state="translated">与CPAN.pm一起工作 在火墙之后</target>
        </trans-unit>
        <trans-unit id="999a14026114357b2720836f701f7f83d4e769ea" translate="yes" xml:space="preserve">
          <source>WRAP YOUR OWN</source>
          <target state="translated">编写你自己的</target>
        </trans-unit>
        <trans-unit id="66af5a28971a4c6868ba337400ea0c92dd22295d" translate="yes" xml:space="preserve">
          <source>WRITING A SOURCE FILTER</source>
          <target state="translated">编写源过滤器</target>
        </trans-unit>
        <trans-unit id="0d91186f3fc1a27893403674a7abb0832febe2cf" translate="yes" xml:space="preserve">
          <source>WRITING A SOURCE FILTER IN C</source>
          <target state="translated">在C语言中写一个源过滤器</target>
        </trans-unit>
        <trans-unit id="1cd7808a59ef1fb929041296bd5ead5a0b08527e" translate="yes" xml:space="preserve">
          <source>WRITING A SOURCE FILTER IN PERL</source>
          <target state="translated">在PERL中编写一个源过滤器</target>
        </trans-unit>
        <trans-unit id="6f33f4557886e9a55139159f018449074d30de1b" translate="yes" xml:space="preserve">
          <source>WRITING PLUGINS</source>
          <target state="translated">写作插件</target>
        </trans-unit>
        <trans-unit id="975f1891ff79af7de3d437f83af46051523ae8be" translate="yes" xml:space="preserve">
          <source>Wait a bit. The PAUSE admins don't want to act too quickly in case the current maintainer is on holiday. If there's no response to private communication or the public post, a PAUSE admin can transfer it to you.</source>
          <target state="translated">稍等一下。PAUSE管理员不希望行动太快,以防现任维护者放假。如果私信或公帖没有回应,PAUSE管理员可以将其转给你。</target>
        </trans-unit>
        <trans-unit id="15314082ca8a524c0f28646da09da9a7b2b19503" translate="yes" xml:space="preserve">
          <source>Wait for a child process to change state. This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;.</source>
          <target state="translated">等待子进程更改状态。这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; 函数相同，请参见&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6cf131695c42ff802839eee6d284c2ac7d67182" translate="yes" xml:space="preserve">
          <source>Waiting For A Thread To Exit</source>
          <target state="translated">等待线程退出</target>
        </trans-unit>
        <trans-unit id="e3ebec26983a17c27a53a6ef7e86c4cba507cfab" translate="yes" xml:space="preserve">
          <source>Waiting for a Condition</source>
          <target state="translated">等待条件</target>
        </trans-unit>
        <trans-unit id="a039b2b9c5bcec1c837f18b2a777a3cf1a5c101d" translate="yes" xml:space="preserve">
          <source>Waits for a particular child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there is no such child process. On some systems, a value of 0 indicates that there are processes still running. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . If you say</source>
          <target state="translated">等待特定的子进程终止并返回已故进程的pid，如果没有此类子进程，则返回 &lt;code&gt;-1&lt;/code&gt; 。在某些系统上，值0表示仍有进程在运行。状态以 &lt;code&gt;$?&lt;/code&gt; 返回？和 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 。如果你说</target>
        </trans-unit>
        <trans-unit id="9d2d2ea3d50db6c0193c946021247ef1ef74c98a" translate="yes" xml:space="preserve">
          <source>Walk Perl syntax tree, printing concise info about ops</source>
          <target state="translated">Walk Perl语法树,打印关于OPS的简明信息。</target>
        </trans-unit>
        <trans-unit id="98ac99324db8fed0af8f3ac36eac780a0f3b01c7" translate="yes" xml:space="preserve">
          <source>Walk Perl syntax tree, printing debug info about ops</source>
          <target state="translated">走Perl语法树,打印OPS的调试信息。</target>
        </trans-unit>
        <trans-unit id="7431af4c5a7328a3a156e7686791a7345dc2386a" translate="yes" xml:space="preserve">
          <source>Walk Perl syntax tree, printing terse info about ops</source>
          <target state="translated">漫步Perl语法树,打印关于OPS的简明信息</target>
        </trans-unit>
        <trans-unit id="a864d880f623d2740f245bfcfe987603dc895c7a" translate="yes" xml:space="preserve">
          <source>Walk the symbol table starting at SYMREF and call METHOD on each symbol (a B::GV object) visited. When the walk reaches package symbols (such as &quot;Foo::&quot;) it invokes RECURSE, passing in the symbol name, and only recurses into the package if that sub returns true.</source>
          <target state="translated">从SYMREF开始走符号表,并对访问的每个符号(一个B::GV对象)调用METHOD。当走到包的符号(如 &quot;Foo::&quot;)时,它调用RECURSE,传递符号名,只有当该子返回true时才会递归到包中。</target>
        </trans-unit>
        <trans-unit id="8c7c87239fc66d9d343f9260489e69fb8f9d3386" translate="yes" xml:space="preserve">
          <source>Walking through a zip file</source>
          <target state="translated">走过一个压缩文件</target>
        </trans-unit>
        <trans-unit id="4e8d79fb203d74f77c4bb0a86a3b744deaaf0e27" translate="yes" xml:space="preserve">
          <source>Wanting to explore this thoroughly, we want to use the stdio &lt;code&gt;fputs()&lt;/code&gt; on a PerlIO *. This means we have to ask the perlio system for a stdio &lt;code&gt;FILE *&lt;/code&gt; :</source>
          <target state="translated">想要深入探讨这一点，我们想在PerlIO *上使用stdio &lt;code&gt;fputs()&lt;/code&gt; 。这意味着我们必须向perlio系统询问stdio &lt;code&gt;FILE *&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="00ff4de53d3fe3ffe55031beb5fa9d320e5a35d7" translate="yes" xml:space="preserve">
          <source>Warn on implicit encoding conversions</source>
          <target state="translated">隐式编码转换警告</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="5e95a54cc5d29c0bcc82593871bdfa68f79221af" translate="yes" xml:space="preserve">
          <source>Warning about Output Arguments</source>
          <target state="translated">关于输出参数的警告</target>
        </trans-unit>
        <trans-unit id="78a452b501be745d32ffe67fa7b1df3549ee0e88" translate="yes" xml:space="preserve">
          <source>Warning and Dieing</source>
          <target state="translated">警告和死亡</target>
        </trans-unit>
        <trans-unit id="e62cd761838ae197b4220edd9e3bd0f69c6d3c92" translate="yes" xml:space="preserve">
          <source>Warning messages are not collected in this variable. You can, however, set up a routine to process warnings by setting &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; as described in &lt;a href=&quot;#%25SIG&quot;&gt;%SIG&lt;/a&gt;.</source>
          <target state="translated">警告消息未收集在此变量中。但是，您可以按照&lt;a href=&quot;#%25SIG&quot;&gt;％SIG&lt;/a&gt;所述设置 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 来设置处理警告的例程。</target>
        </trans-unit>
        <trans-unit id="e6fb45b9b8c6b7b341ac8191e822e0bd743414ee" translate="yes" xml:space="preserve">
          <source>Warning on \1 Instead of $1</source>
          <target state="translated">警告1而不是1美元</target>
        </trans-unit>
        <trans-unit id="151e71b95baa6e558c89aa6c4dcb9635e2009b86" translate="yes" xml:space="preserve">
          <source>Warning! The accuracy</source>
          <target state="translated">警告! 准确性</target>
        </trans-unit>
        <trans-unit id="dab0c499dcd06e930b9b78c9e213ee3924e2052e" translate="yes" xml:space="preserve">
          <source>Warning: If &lt;code&gt;SvCUR&lt;/code&gt; is equal to &lt;code&gt;SvLEN&lt;/code&gt; , then &lt;code&gt;SvEND&lt;/code&gt; points to unallocated memory.</source>
          <target state="translated">警告：如果 &lt;code&gt;SvCUR&lt;/code&gt; 等于 &lt;code&gt;SvLEN&lt;/code&gt; ，则 &lt;code&gt;SvEND&lt;/code&gt; 指向未分配的内存。</target>
        </trans-unit>
        <trans-unit id="897e60f42bffb44a74b7eeefd8312eec6b6adc82" translate="yes" xml:space="preserve">
          <source>Warning: What follows is an experimental feature.</source>
          <target state="translated">警告:下面的内容是实验性的。</target>
        </trans-unit>
        <trans-unit id="0f8de18035aca70c8dfa181a9a2f5d6af3e09a08" translate="yes" xml:space="preserve">
          <source>Warning: syntactical care is required when sorting the list returned from a function. If you want to sort the list returned by the function call &lt;code&gt;find_records(@key)&lt;/code&gt; , you can use:</source>
          <target state="translated">警告：对从函数返回的列表进行排序时，需要注意语法。如果要对函数调用 &lt;code&gt;find_records(@key)&lt;/code&gt; 返回的列表进行排序，可以使用：</target>
        </trans-unit>
        <trans-unit id="5108285f53caf36c4da1bf90b62aacb88666b29e" translate="yes" xml:space="preserve">
          <source>Warning: the inst_perl: target will most probably overwrite your existing perl binary. Use with care!</source>
          <target state="translated">警告:inst_perl:target很可能会覆盖你现有的perl二进制文件。请小心使用!</target>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="cd781cfd6561f1847315b32c68e5aa6443ed0ce1" translate="yes" xml:space="preserve">
          <source>Warnings about floating-point overflow when compiling Perl on Tru64</source>
          <target state="translated">在Tru64上编译Perl时出现浮点溢出的警告。</target>
        </trans-unit>
        <trans-unit id="f781ae9f2ff2acd0ab91c312289ece490360983a" translate="yes" xml:space="preserve">
          <source>Warnings are issued and the file skipped if &lt;code&gt;AutoSplit&lt;/code&gt; cannot locate either the</source>
          <target state="translated">如果 &lt;code&gt;AutoSplit&lt;/code&gt; 无法找到警告或警告，则会发出警告并跳过文件</target>
        </trans-unit>
        <trans-unit id="931a49d01050aa1b2755e3ac6bcc484cb7da972d" translate="yes" xml:space="preserve">
          <source>Warnings dispatched from perl itself (or more accurately, those that match descriptions found in &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;) are only displayed once (no duplicate descriptions). User code generated warnings a la warn() are unaffected, allowing duplicate user messages to be displayed.</source>
          <target state="translated">从perl本身发出的警告（或更准确地说，与在&lt;a href=&quot;perldiag&quot;&gt;perldiag中&lt;/a&gt;找到的描述匹配的警告）仅显示一次（没有重复的描述）。用户代码生成的警告la warn（）不受影响，从而允许显示重复的用户消息。</target>
        </trans-unit>
        <trans-unit id="e5a6430c53bc65107aa5413603aa9d5ae883fbaa" translate="yes" xml:space="preserve">
          <source>Warnings import function</source>
          <target state="translated">警告导入函数</target>
        </trans-unit>
        <trans-unit id="c2ae6895b901f6f499e198f2b33c31bd733ed306" translate="yes" xml:space="preserve">
          <source>Warnings of other C compilers</source>
          <target state="translated">其他C编译器的警告</target>
        </trans-unit>
        <trans-unit id="3e543092d93dedef30b6a118c959f36cd73b7b20" translate="yes" xml:space="preserve">
          <source>Warns with &lt;code&gt;@message&lt;/code&gt; but the message will appear to come from the point where the original test function was called (&lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ).</source>
          <target state="translated">使用 &lt;code&gt;@message&lt;/code&gt; 发出警告，但消息似乎来自调用原始测试函数的位置（ &lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d321acbea9d4ab268b54e61d4d0b39001cfb34d4" translate="yes" xml:space="preserve">
          <source>Wayne Thompson</source>
          <target state="translated">韦恩-汤普森</target>
        </trans-unit>
        <trans-unit id="43464fb1e06d4c1bc9db7081e9ca038cc1269495" translate="yes" xml:space="preserve">
          <source>We &quot;officially&quot; support the two most recent stable release series. 5.16.x and earlier are now out of support. As of the release of 5.22.0, we will &quot;officially&quot; end support for Perl 5.18.x, other than providing security updates as described below.</source>
          <target state="translated">我们 &quot;正式 &quot;支持两个最新的稳定版本系列。5.16.x 和更早的版本现在已经不支持了。从 5.22.0 发布开始,我们将 &quot;正式 &quot;终止对 Perl 5.18.x 的支持,但会提供如下所述的安全更新。</target>
        </trans-unit>
        <trans-unit id="17a0049b3e8190b56f011a925a65f0578bf35206" translate="yes" xml:space="preserve">
          <source>We already talked about the special &lt;code&gt;@ISA&lt;/code&gt; array and the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma.</source>
          <target state="translated">我们已经讨论过特殊的 &lt;code&gt;@ISA&lt;/code&gt; 数组和&lt;a href=&quot;parent&quot;&gt;父级&lt;/a&gt;编译指示。</target>
        </trans-unit>
        <trans-unit id="99f6d15ea0dac8c570f259e877f08f9c6317a1cf" translate="yes" xml:space="preserve">
          <source>We also recommend using this method to check whether a module has a sufficient version. The internal implementation uses the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module to make sure that different types of version numbers are compared correctly.</source>
          <target state="translated">我们还建议使用此方法检查模块是否具有足够的版本。内部实现使用&lt;a href=&quot;version&quot;&gt;版本&lt;/a&gt;模块来确保正确比较不同类型的版本号。</target>
        </trans-unit>
        <trans-unit id="777641065ef9fefa679b6e058d833646233119c1" translate="yes" xml:space="preserve">
          <source>We are at the end of the regexp, so we are done! We have matched 'abcd' out of the string &quot;abcde&quot;.</source>
          <target state="translated">我们已经到了regexp的最后,所以我们完成了!我们已经从字符串 &quot;abcd &quot;中匹配出了 &quot;abcd&quot;。我们从字符串 &quot;abcde &quot;中匹配出了 &quot;abcd&quot;。</target>
        </trans-unit>
        <trans-unit id="88e6eb598d1ae4c98a1710166c586176804c4ac7" translate="yes" xml:space="preserve">
          <source>We are done!</source>
          <target state="translated">我们完成了!</target>
        </trans-unit>
        <trans-unit id="b8c42eb02770fa660f067266841b9afabfa1a1c9" translate="yes" xml:space="preserve">
          <source>We are performing only one hash operation in this function, which is storing a new scalar under a key using &lt;code&gt;hv_store&lt;/code&gt; . A hash is represented by an HV* pointer. Like arrays, the functions for manipulating hashes from an XSUB mirror the functionality available from Perl. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for details.</source>
          <target state="translated">我们在此函数中仅执行一个哈希操作，该操作使用 &lt;code&gt;hv_store&lt;/code&gt; 将新标量存储在键下。哈希由HV *指针表示。像数组一样，用于从XSUB处理哈希的功能也反映了Perl的功能。有关详细信息，请参见&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;和&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd90ced3661ebd845235cda2b54db721e3957aec" translate="yes" xml:space="preserve">
          <source>We aren't interested in anything returned from</source>
          <target state="translated">我们对从以下地方返回的任何东西不感兴趣</target>
        </trans-unit>
        <trans-unit id="b554448ff034d8f0532aebe7287733b598ce6629" translate="yes" xml:space="preserve">
          <source>We aren't passing any parameters to</source>
          <target state="translated">我们没有向</target>
        </trans-unit>
        <trans-unit id="4e3a929680591b90a57e354fe70746318049b8f9" translate="yes" xml:space="preserve">
          <source>We build perl using GNU make. We tried the native make once and it worked too.</source>
          <target state="translated">我们使用GNU make构建perl。我们试过一次native make,也成功了。</target>
        </trans-unit>
        <trans-unit id="41071245738df49d45438a45bb484058bfc57858" translate="yes" xml:space="preserve">
          <source>We can also dump out this op: the current op is always stored in &lt;code&gt;PL_op&lt;/code&gt; , and we can dump it with &lt;code&gt;Perl_op_dump&lt;/code&gt; . This'll give us similar output to &lt;a href=&quot;b/debug&quot;&gt;B::Debug&lt;/a&gt;.</source>
          <target state="translated">我们还可以转储该op：当前op总是存储在 &lt;code&gt;PL_op&lt;/code&gt; 中，我们可以使用 &lt;code&gt;Perl_op_dump&lt;/code&gt; 进行转储。这将为我们提供与&lt;a href=&quot;b/debug&quot;&gt;B :: Debug&lt;/a&gt;类似的输出。</target>
        </trans-unit>
        <trans-unit id="961c3c25dd241cffc69783f122b1016732a7e65b" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;@&lt;/code&gt; to jump to an offset, with 0 being the position where we were when the last &lt;code&gt;(&lt;/code&gt; was encountered:</source>
          <target state="translated">我们还可以使用 &lt;code&gt;@&lt;/code&gt; 跳转到偏移量，其中0 是遇到最后一个 &lt;code&gt;(&lt;/code&gt; 时遇到的位置：</target>
        </trans-unit>
        <trans-unit id="dbea0db461430bae70d9c35bb3e6a3ab77cd3179" translate="yes" xml:space="preserve">
          <source>We can also use a variable to store a reference to the data structure that is being blessed as our object:</source>
          <target state="translated">我们也可以使用一个变量来存储对被祝福为我们对象的数据结构的引用。</target>
        </trans-unit>
        <trans-unit id="3ae43a4ae8c47d1af2dad91e0ab8b4c97424cc6a" translate="yes" xml:space="preserve">
          <source>We can also use the transliteration operator, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. In this example, the search list side of our &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; contains nothing, but the &lt;code&gt;c&lt;/code&gt; option complements that so it contains everything. The replacement list also contains nothing, so the transliteration is almost a no-op since it won't do any replacements (or more exactly, replace the character with itself). However, the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; option squashes duplicated and consecutive characters in the string so a character does not show up next to itself</source>
          <target state="translated">我们还可以使用音译运算符 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 。在此示例中， &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 的搜索列表端不包含任何内容，但是 &lt;code&gt;c&lt;/code&gt; 选项对其进行了补充，因此包含了所有内容。替换列表也不包含任何内容，因此音译几乎是空手，因为它不会进行任何替换（或更确切地说，将字符替换为自身）。但是， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 选项可压缩字符串中重复的和连续的字符，因此不会在其旁边显示一个字符</target>
        </trans-unit>
        <trans-unit id="8d9637ace5e985325b750e53a0a2e0777af26ff5" translate="yes" xml:space="preserve">
          <source>We can deal with this by using both an assertion and a negation. We'll say that the first part in $1 must be followed both by a digit and by something that's not &quot;123&quot;. Remember that the look-aheads are zero-width expressions--they only look, but don't consume any of the string in their match. So rewriting this way produces what you'd expect; that is, case 5 will fail, but case 6 succeeds:</source>
          <target state="translated">我们可以通过使用断言和否定来处理这个问题。我们可以说$1中的第一部分后面必须有一个数字和一个不是 &quot;123 &quot;的东西。请记住,look-aheads是零宽度的表达式--它们只看,但不消耗匹配中的任何字符串。所以这样重写会产生你所期望的结果;也就是说,case 5会失败,但case 6会成功。</target>
        </trans-unit>
        <trans-unit id="69e73838de4aed15f5d24b688fd13aef192fb3f9" translate="yes" xml:space="preserve">
          <source>We can extend the example above:</source>
          <target state="translated">我们可以扩展上面的例子。</target>
        </trans-unit>
        <trans-unit id="84c843f2491ce2ba91f8ea33bd419c025bcac31f" translate="yes" xml:space="preserve">
          <source>We can manipulate &lt;code&gt;@_&lt;/code&gt; in other ways too:</source>
          <target state="translated">我们也可以通过其他方式操纵 &lt;code&gt;@_&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c8e881a1155e87edea33bdbd7aaa36ea47df11e3" translate="yes" xml:space="preserve">
          <source>We can match different character strings with the &lt;b&gt;alternation&lt;/b&gt; metacharacter &lt;code&gt;'|'&lt;/code&gt; . To match &lt;code&gt;dog&lt;/code&gt; or &lt;code&gt;cat&lt;/code&gt; , we form the regex &lt;code&gt;dog|cat&lt;/code&gt; . As before, Perl will try to match the regex at the earliest possible point in the string. At each character position, Perl will first try to match the first alternative, &lt;code&gt;dog&lt;/code&gt; . If &lt;code&gt;dog&lt;/code&gt; doesn't match, Perl will then try the next alternative, &lt;code&gt;cat&lt;/code&gt; . If &lt;code&gt;cat&lt;/code&gt; doesn't match either, then the match fails and Perl moves to the next position in the string. Some examples:</source>
          <target state="translated">我们可以将不同的字符串与&lt;b&gt;替换&lt;/b&gt;元字符 &lt;code&gt;'|'&lt;/code&gt; 匹配 。为了匹配 &lt;code&gt;dog&lt;/code&gt; 或 &lt;code&gt;cat&lt;/code&gt; ，我们形成了正则表达式 &lt;code&gt;dog|cat&lt;/code&gt; 。和以前一样，Perl将尝试在字符串的最早点匹配正则表达式。在每个角色位置，Perl首先将尝试匹配第一个替代项 &lt;code&gt;dog&lt;/code&gt; 。如果 &lt;code&gt;dog&lt;/code&gt; 不匹配，Perl将尝试下一个选择 &lt;code&gt;cat&lt;/code&gt; 。如果 &lt;code&gt;cat&lt;/code&gt; 也不匹配，则匹配失败，Perl移至字符串中的下一个位置。一些例子：</target>
        </trans-unit>
        <trans-unit id="ea854225fefa1280a29795bb4f271d273dbd77b0" translate="yes" xml:space="preserve">
          <source>We can modify principle 3 above to take into account non-greedy quantifiers:</source>
          <target state="translated">我们可以修改上面的原则3,以考虑到非贪婪的量化器。</target>
        </trans-unit>
        <trans-unit id="ab79fcd6910e13f271bf0f10b6fac2de440cb105" translate="yes" xml:space="preserve">
          <source>We can now use &lt;code&gt;Perl_sv_dump&lt;/code&gt; to investigate the SV:</source>
          <target state="translated">现在，我们可以使用 &lt;code&gt;Perl_sv_dump&lt;/code&gt; 研究SV：</target>
        </trans-unit>
        <trans-unit id="9e3ffbb12768a148e4cd9144c59ebb38f57598ff" translate="yes" xml:space="preserve">
          <source>We can override a parent's method in a child class. When we do so, we can still call the parent class's method with the &lt;code&gt;SUPER&lt;/code&gt; pseudo-class.</source>
          <target state="translated">我们可以在子类中重写父方法。这样做时，我们仍然可以使用 &lt;code&gt;SUPER&lt;/code&gt; 伪类调用父类的方法。</target>
        </trans-unit>
        <trans-unit id="2754e3aa57380296cb4f092e33ffe2f92fac593d" translate="yes" xml:space="preserve">
          <source>We can put another break point on any line beginning with a colon, we'll use line 17 as that's just as we come out of the subroutine, and we'd like to pause there later on:</source>
          <target state="translated">我们可以在任何以冒号开头的行上再加一个断点,我们用第17行,因为那是我们从子程序出来的时候,我们想稍后在那里暂停。</target>
        </trans-unit>
        <trans-unit id="8aece3bd543cbe6fe75eaf5ad6965a489841cbb4" translate="yes" xml:space="preserve">
          <source>We can put that into a test file which we can run to check which approach is the fastest, using a global &lt;code&gt;$STR&lt;/code&gt; variable to assign to the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $str&lt;/code&gt; variable so as to avoid perl trying to optimize any of the work away by noticing it's assigned only the once.</source>
          <target state="translated">我们可以将其放入测试文件中，然后使用全局 &lt;code&gt;$STR&lt;/code&gt; 变量将其分配给 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $str&lt;/code&gt; 变量，以检查哪种方法最快，从而避免perl注意到它的存在而试图优化任何工作只分配一次。</target>
        </trans-unit>
        <trans-unit id="192c194669c26df922a17b7997201101414dafec" translate="yes" xml:space="preserve">
          <source>We can reduce some of the looping through slices</source>
          <target state="translated">我们可以减少一些通过切片的循环。</target>
        </trans-unit>
        <trans-unit id="393d2cf123dc0cecdbadd1ca8c26943dc464db54" translate="yes" xml:space="preserve">
          <source>We could get more fancy in the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; block though. Instead of comparing the keys, we can compute a value with them and use that value as the comparison.</source>
          <target state="translated">不过，我们可以在 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 块中得到更多的效果。无需比较键，我们可以使用它们计算一个值并将该值用作比较。</target>
        </trans-unit>
        <trans-unit id="373abf531902aa68eac45baf244872a1e2626f66" translate="yes" xml:space="preserve">
          <source>We could have both classes inherit from a common parent, like &lt;code&gt;Machine&lt;/code&gt; , but not all machines have on/off switches. We could create a parent class called &lt;code&gt;HasOnOffSwitch&lt;/code&gt; , but that is very artificial. Radios and computers are not specializations of this parent. This parent is really a rather ridiculous creation.</source>
          <target state="translated">我们可以让这两个类都从一个共同的父类（例如 &lt;code&gt;Machine&lt;/code&gt; )继承，但是并非所有机器都具有on / off开关。我们可以创建一个名为 &lt;code&gt;HasOnOffSwitch&lt;/code&gt; 的父类，但这是非常人为的。收音机和计算机不是该父母的专业。这个父母确实是一个相当荒谬的创造。</target>
        </trans-unit>
        <trans-unit id="23ce6432aa57322234fa603b7b093664929a40c6" translate="yes" xml:space="preserve">
          <source>We could have used an unpack template &lt;code&gt;'b12'&lt;/code&gt; just as well, since the last 4 bits can be ignored anyway.</source>
          <target state="translated">我们也可以使用解压缩模板 &lt;code&gt;'b12'&lt;/code&gt; ，因为无论如何最后4位都可以忽略。</target>
        </trans-unit>
        <trans-unit id="737f5642c49143f79a5e632705526d6d3453018c" translate="yes" xml:space="preserve">
          <source>We do this by using the PPCODE: directive, rather than the CODE: directive. This tells &lt;b&gt;xsubpp&lt;/b&gt; that we will be managing the return values that will be put on the argument stack by ourselves.</source>
          <target state="translated">我们通过使用PPCODE：指令而不是CODE：指令来做到这一点。这告诉&lt;b&gt;xsubpp&lt;/b&gt;，我们将管理自己将放到参数堆栈中的返回值。</target>
        </trans-unit>
        <trans-unit id="bbf4d60422d93cc3418f9928672ab7a165e0c448" translate="yes" xml:space="preserve">
          <source>We don't have much experience with this yet, but try the following:</source>
          <target state="translated">我们还没有太多经验,但可以试试下面的方法。</target>
        </trans-unit>
        <trans-unit id="3714a8cbbcb3d8e34c4cf78e7eb46446670ccdf4" translate="yes" xml:space="preserve">
          <source>We don't have to hard-code patterns into the match operator (or anything else that works with regular expressions). We can put the pattern in a variable for later use.</source>
          <target state="translated">我们不必将模式硬编码到匹配操作符中(或其他任何与正则表达式一起使用的东西)。我们可以把模式放在一个变量中,供以后使用。</target>
        </trans-unit>
        <trans-unit id="9b9b047b90e6f20cc1587612f1c7f873786eee50" translate="yes" xml:space="preserve">
          <source>We encourage using this rather than calling print directly.</source>
          <target state="translated">我们鼓励使用这个而不是直接调用打印。</target>
        </trans-unit>
        <trans-unit id="7ef0cc263f45630948ec977db18c296d89495351" translate="yes" xml:space="preserve">
          <source>We encourage vendors to ship the most recent supported release of Perl at the time of their code freeze.</source>
          <target state="translated">我们鼓励厂商在冻结代码时提供最新支持的Perl版本。</target>
        </trans-unit>
        <trans-unit id="dd33c6dcc68f66e550d47a04957cd34a37a4f9d0" translate="yes" xml:space="preserve">
          <source>We encourage you to play with and evaluate &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class::Accessor&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt; to see which OO system is right for you.</source>
          <target state="translated">我们鼓励您使用&lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class :: Accessor&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class :: Tiny&lt;/a&gt;并对其进行评估，以查看哪种OO系统适合您。</target>
        </trans-unit>
        <trans-unit id="a75ee8e59a59e98ee82483d5a167a8e74430cf9d" translate="yes" xml:space="preserve">
          <source>We fix our quoting: 'tom' =&amp;gt; q(and jerry), and run it again, this time we get our expected output:</source>
          <target state="translated">我们更正了引号：'tom'=&amp;gt; q（和jerry），然后再次运行它，这一次我们获得了预期的输出：</target>
        </trans-unit>
        <trans-unit id="ad7822a7bc01015524040b6228bd7a714fe0ea5e" translate="yes" xml:space="preserve">
          <source>We have already introduced the matching operator in its default &lt;code&gt;/regexp/&lt;/code&gt; and arbitrary delimiter &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m!regexp!&lt;/a&gt;&lt;/code&gt; forms. We have used the binding operator &lt;code&gt;=~&lt;/code&gt; and its negation &lt;code&gt;!~&lt;/code&gt; to test for string matches. Associated with the matching operator, we have discussed the single line &lt;code&gt;//s&lt;/code&gt; , multi-line &lt;code&gt;//m&lt;/code&gt; , case-insensitive &lt;code&gt;//i&lt;/code&gt; and extended &lt;code&gt;//x&lt;/code&gt; modifiers. There are a few more things you might want to know about matching operators.</source>
          <target state="translated">我们已经在其默认的 &lt;code&gt;/regexp/&lt;/code&gt; 和任意定界符 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m!regexp!&lt;/a&gt;&lt;/code&gt; 中引入了匹配运算符！形式。我们已经使用绑定运算符 &lt;code&gt;=~&lt;/code&gt; 及其否定项 &lt;code&gt;!~&lt;/code&gt; 来测试字符串匹配。与匹配运算符相关联，我们讨论了单行 &lt;code&gt;//s&lt;/code&gt; ，多行 &lt;code&gt;//m&lt;/code&gt; ，不区分大小写的 &lt;code&gt;//i&lt;/code&gt; 和扩展的 &lt;code&gt;//x&lt;/code&gt; 修饰符。关于匹配运算符，您可能还需要了解几件事。</target>
        </trans-unit>
        <trans-unit id="6e2bfdcf3348ad31286e830869ab5ab9cf57a976" translate="yes" xml:space="preserve">
          <source>We have no nroff on BS2000 POSIX (yet), so we ignored any errors while installing the documentation.</source>
          <target state="translated">我们在BS2000 POSIX上没有nroff(还没有),所以我们在安装文档时忽略了任何错误。</target>
        </trans-unit>
        <trans-unit id="c5a4c49687cb5b4e725178b1ad770374684a7f19" translate="yes" xml:space="preserve">
          <source>We have to use a &lt;code&gt;CODE&lt;/code&gt; section because &lt;code&gt;PerlIO_puts()&lt;/code&gt; has the arguments reversed compared to &lt;code&gt;fputs()&lt;/code&gt; , and we want to keep the arguments the same.</source>
          <target state="translated">我们必须使用 &lt;code&gt;CODE&lt;/code&gt; 节，因为与 &lt;code&gt;fputs()&lt;/code&gt; 相比， &lt;code&gt;PerlIO_puts()&lt;/code&gt; 具有相反的参数，并且我们希望保持相同的参数。</target>
        </trans-unit>
        <trans-unit id="4a78632eb571a6503bee4006e791fffefd6cf4ab" translate="yes" xml:space="preserve">
          <source>We have tried to make Perl aware of both VMS-style and Unix-style file specifications wherever possible. You may use either style, or both, on the command line and in scripts, but you may not combine the two styles within a single file specification. VMS Perl interprets Unix pathnames in much the same way as the CRTL (</source>
          <target state="translated">我们试图让Perl尽可能地了解VMS风格和Unix风格的文件规范。你可以在命令行和脚本中使用其中一种风格,或者两种风格都使用,但是你不能在一个文件规范中结合两种风格。VMS Perl 解释 Unix 路径名的方式与 CRTL(</target>
        </trans-unit>
        <trans-unit id="78dd390dcc77c45fe1854b3e48358f0f7f0c1ae7" translate="yes" xml:space="preserve">
          <source>We highly discourage this method. It should only be used if you know what you're doing and specifically need the PREFIX behavior. The PREFIX algorithm is complicated and focused on matching the system installation.</source>
          <target state="translated">我们非常不鼓励这种方法。只有当你知道自己在做什么,并且特别需要Prefix行为时,才应该使用它。PREFIX算法很复杂,而且专注于匹配系统安装。</target>
        </trans-unit>
        <trans-unit id="0d078f205cc7733f26f4527b8b9a508a7c925969" translate="yes" xml:space="preserve">
          <source>We highly recommend the install_base method, its the simplest and most closely approximates the expected behavior of an installation prefix.</source>
          <target state="translated">我们强烈推荐 install_base 方法,它是最简单的,最接近安装前缀的预期行为。</target>
        </trans-unit>
        <trans-unit id="cf829d6773d2acaf89ace4612301d748f71133de" translate="yes" xml:space="preserve">
          <source>We hope these notes will save you from confusion and lost sleep when writing Perl scripts on VMS. If you find we've missed something you think should appear here, please don't hesitate to drop a line to vmsperl@perl.org.</source>
          <target state="translated">我们希望这些说明能让您在VMS上编写Perl脚本时免于困惑和失眠。如果你发现我们遗漏了一些你认为应该出现在这里的东西,请不要犹豫,请发邮件到 vmsperl@perl.org。</target>
        </trans-unit>
        <trans-unit id="c62eabab19d963ec1dc9f96b723cb4b48b7d1ebd" translate="yes" xml:space="preserve">
          <source>We implement our own glob-style pattern matching for --rules. Here are the supported patterns:</source>
          <target state="translated">我们为--rules实现了我们自己的glob式模式匹配。以下是支持的模式。</target>
        </trans-unit>
        <trans-unit id="f3c2a6f9803dfeb38af1055d966366fc67acbab0" translate="yes" xml:space="preserve">
          <source>We implement our own glob-style pattern matching. Here are the patterns it supports:</source>
          <target state="translated">我们实现了自己的 glob 式模式匹配。以下是它支持的模式。</target>
        </trans-unit>
        <trans-unit id="821afd715774631771e27078ffd6e046b44c39d8" translate="yes" xml:space="preserve">
          <source>We know we're going to get &lt;code&gt;6&lt;/code&gt; from this, so let's finish the subroutine:</source>
          <target state="translated">我们知道我们将从中得到 &lt;code&gt;6&lt;/code&gt; ，所以让我们完成子例程：</target>
        </trans-unit>
        <trans-unit id="56ac7541ed28a7466aa3352e9da342249eeae09f" translate="yes" xml:space="preserve">
          <source>We looked at this bit of code before, and we said that &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; arranges for two &lt;code&gt;NV&lt;/code&gt; s to be placed into &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; - let's slightly expand it:</source>
          <target state="translated">我们期待在此位的代码之前，我们说 &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; 排列两 &lt;code&gt;NV&lt;/code&gt; s到被放置到 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; -让我们稍微展开：</target>
        </trans-unit>
        <trans-unit id="bf8f7ecbf0eb0e715d021c51919b36afbf4f3b1d" translate="yes" xml:space="preserve">
          <source>We maintain the binary incompatibility.</source>
          <target state="translated">我们维持二进制的不兼容。</target>
        </trans-unit>
        <trans-unit id="0fd132a408c3e7900b7667b28ffdaffdc2cfda3e" translate="yes" xml:space="preserve">
          <source>We manipulate several arrays in this XSUB. Note that an array is represented internally by an AV* pointer. The functions and macros for manipulating arrays are similar to the functions in Perl: &lt;code&gt;av_top_index&lt;/code&gt; returns the highest index in an AV*, much like $#array; &lt;code&gt;av_fetch&lt;/code&gt; fetches a single scalar value from an array, given its index; &lt;code&gt;av_push&lt;/code&gt; pushes a scalar value onto the end of the array, automatically extending the array as necessary.</source>
          <target state="translated">我们在此XSUB中操纵几个数组。注意，数组在内部由AV *指针表示。操纵数组的函数和宏与Perl中的函数相似： &lt;code&gt;av_top_index&lt;/code&gt; 返回AV *中的最高索引，与$＃array相似； &lt;code&gt;av_fetch&lt;/code&gt; 从数组中获取给定索引的单个标量值； &lt;code&gt;av_push&lt;/code&gt; 将标量值推入数组的末尾，并根据需要自动扩展数组。</target>
        </trans-unit>
        <trans-unit id="6201b3e74828151a0b8123986740745576c51a04" translate="yes" xml:space="preserve">
          <source>We may change it so that things that remain legal uses in normal bracketed character classes might become illegal within this experimental construct. One proposal, for example, is to forbid adjacent uses of the same character, as in &lt;code&gt;(?[ [aa] ])&lt;/code&gt; . The motivation for such a change is that this usage is likely a typo, as the second &quot;a&quot; adds nothing.</source>
          <target state="translated">我们可能会对其进行更改，以使在正常的带括号的字符类中仍然合法使用的东西在此实验性构造中可能变得非法。例如，一个建议是禁止与 &lt;code&gt;(?[ [aa] ])&lt;/code&gt; 相同字符的相邻使用。进行此更改的动机是此用法可能是拼写错误，因为第二个&amp;ldquo; a&amp;rdquo;不添加任何内容。</target>
        </trans-unit>
        <trans-unit id="9d8db65a7f163486a998a7bf47269c4123bd2dc9" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that most Perl objects are implemented as hashes under the hood. The principle of encapsulation tells us that we should not rely on this. Instead, we should use accessor methods to access the data in that hash. The object systems that we recommend below all automate the generation of accessor methods. If you use one of them, you should never have to access the object as a hash directly.</source>
          <target state="translated">前面我们提到过,大多数Perl对象都是在引擎盖下以哈希的形式实现的。封装的原则告诉我们,我们不应该依赖这个。相反,我们应该使用访问器方法来访问该哈希中的数据。下面我们推荐的对象系统都能自动生成访问者方法。如果你使用了其中的一个,你应该永远都不用直接访问该对象作为哈希。</target>
        </trans-unit>
        <trans-unit id="fd2e3b2237cf2c9ebd6d21ee18dff2f93d4edaee" translate="yes" xml:space="preserve">
          <source>We mentioned multiple inheritance earlier. The main problem with multiple inheritance is that it greatly complicates method resolution. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more details.</source>
          <target state="translated">我们前面提到了多重继承。多重继承的主要问题在于，它极大地使方法解析变得复杂。有关更多详细信息，请参见&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05de83678232988de23cc08caee2a559bec4d96c" translate="yes" xml:space="preserve">
          <source>We must know how much to read.</source>
          <target state="translated">我们必须知道要读多少书。</target>
        </trans-unit>
        <trans-unit id="786b499d8e7780442a91c12acac79f0bab40bb9c" translate="yes" xml:space="preserve">
          <source>We now compile up Perl, and run it through the test suite. Our new tests pass, hooray!</source>
          <target state="translated">现在我们编译Perl,并在测试套件中运行它。我们的新测试通过了,万岁</target>
        </trans-unit>
        <trans-unit id="885cb8f93d773c304687f5c7d8f7995e03fd1f70" translate="yes" xml:space="preserve">
          <source>We now know how to create choices among classes of characters in a regexp. What about choices among words or character strings? Such choices are described in the next section.</source>
          <target state="translated">我们现在知道了如何在regexp中创建字符类的选择。那么在单词或字符串之间的选择呢?这种选择将在下一节中介绍。</target>
        </trans-unit>
        <trans-unit id="68e3b46c3317fe81b8a4f43f4375d9dc3eef2342" translate="yes" xml:space="preserve">
          <source>We often refer to inheritance relationships as &lt;b&gt;parent-child&lt;/b&gt; or &lt;code&gt;superclass/subclass&lt;/code&gt; relationships. Sometimes we say that the child has an &lt;b&gt;is-a&lt;/b&gt; relationship with its parent class.</source>
          <target state="translated">我们通常将继承关系称为&lt;b&gt;父子&lt;/b&gt;关系或 &lt;code&gt;superclass/subclass&lt;/code&gt; 关系。有时我们说孩子与其父类之间存在&lt;b&gt;is-a&lt;/b&gt;关系。</target>
        </trans-unit>
        <trans-unit id="37fd14d3b6f6bb386e0f6cc77e29f8b6538c7a73" translate="yes" xml:space="preserve">
          <source>We recognize that the Perl core, defined as the software distributed with the heart of Perl itself, is a joint project on the part of all of us. From time to time, a script, module, or set of modules (hereafter referred to simply as a &quot;module&quot;) will prove so widely useful and/or so integral to the correct functioning of Perl itself that it should be distributed with the Perl core. This should never be done without the author's explicit consent, and a clear recognition on all parts that this means the module is being distributed under the same terms as Perl itself. A module author should realize that inclusion of a module into the Perl core will necessarily mean some loss of control over it, since changes may occasionally have to be made on short notice or for consistency with the rest of Perl.</source>
          <target state="translated">我们认识到,Perl 核心(定义为与 Perl 本身的核心一起发布的软件)是我们所有人的共同项目。有时,一个脚本、模块或一组模块(以下简称为 &quot;模块&quot;)会被证明是非常有用的,或者说对 Perl 本身的正常运行是不可或缺的,因此它应该和 Perl 核心一起发布。如果没有作者的明确同意,并且所有的人都清楚地认识到这意味着该模块是在与 Perl 本身相同的条件下发布的,那么就不应该这样做。模块的作者应该意识到,将一个模块纳入 Perl 核心,必然意味着对它的控制权的丧失,因为有时可能需要在短时间内进行修改,或者为了与 Perl 的其他部分保持一致。</target>
        </trans-unit>
        <trans-unit id="adbff354730155d973632a844ddac8001f83317b" translate="yes" xml:space="preserve">
          <source>We recommend InfoZIP: &lt;a href=&quot;http://www.info-zip.org/Zip.html&quot;&gt;http://www.info-zip.org/Zip.html&lt;/a&gt;</source>
          <target state="translated">我们建议使用InfoZIP：&lt;a href=&quot;http://www.info-zip.org/Zip.html&quot;&gt;http&lt;/a&gt;：//www.info-zip.org/Zip.html</target>
        </trans-unit>
        <trans-unit id="4f1a977094921f3a67ec1b5d153f5c0398eec08d" translate="yes" xml:space="preserve">
          <source>We recommend ptar from Archive::Tar not older than 1.66 with '-C' option.</source>
          <target state="translated">我们建议使用'-C'选项从Archive::Tar中下载不超过1.66的ptar。</target>
        </trans-unit>
        <trans-unit id="cbe1fc263dadb40ca151eed92966c9248a04de8d" translate="yes" xml:space="preserve">
          <source>We recommend that you avoid this syntax, for several reasons.</source>
          <target state="translated">我们建议你避免使用这种语法,原因如下。</target>
        </trans-unit>
        <trans-unit id="579e792fc6edac0deca16c23591b561128b4c15e" translate="yes" xml:space="preserve">
          <source>We recommend that you only access attributes via &lt;b&gt;accessor&lt;/b&gt; methods. These are methods that can get or set the value of each attribute. We saw this earlier in the &lt;code&gt;print_info()&lt;/code&gt; example, which calls &lt;code&gt;$self-&amp;gt;path&lt;/code&gt; .</source>
          <target state="translated">我们建议您仅通过访问&lt;b&gt;器&lt;/b&gt;方法访问属性。这些方法可以获取或设置每个属性的值。我们在前面的 &lt;code&gt;print_info()&lt;/code&gt; 示例中看到了这一点，该示例调用 &lt;code&gt;$self-&amp;gt;path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3cd090bb786563ac9394aa0d7f58e631fb54d86e" translate="yes" xml:space="preserve">
          <source>We recommend that you use this method to access another package's version, rather than looking directly at &lt;code&gt;$Package::VERSION&lt;/code&gt; . The package you are looking at could have overridden the &lt;code&gt;VERSION&lt;/code&gt; method.</source>
          <target state="translated">我们建议您使用此方法访问另一个软件包的版本，而不是直接查看 &lt;code&gt;$Package::VERSION&lt;/code&gt; 。您正在查看的软件包可能已覆盖 &lt;code&gt;VERSION&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="3584759389d1a5c9463e1916b5f8cba299128724" translate="yes" xml:space="preserve">
          <source>We said that references spring into existence as necessary if they are undefined, but we didn't say what happens if a value used as a reference is already defined, but</source>
          <target state="translated">我们说过,如果引用未被定义,那么引用就会根据需要而产生,但我们没有说如果用作引用的值已经被定义了,会发生什么,但</target>
        </trans-unit>
        <trans-unit id="f1e706dab14e9082a067c69407d520e37d14c840" translate="yes" xml:space="preserve">
          <source>We saw in the section above that there were ordinary characters, which represented themselves, and special characters, which needed a backslash &lt;code&gt;\&lt;/code&gt; to represent themselves. The same is true in a character class, but the sets of ordinary and special characters inside a character class are different than those outside a character class. The special characters for a character class are &lt;code&gt;-]\^$&lt;/code&gt; (and the pattern delimiter, whatever it is). &lt;code&gt;]&lt;/code&gt; is special because it denotes the end of a character class. &lt;code&gt;$&lt;/code&gt; is special because it denotes a scalar variable. &lt;code&gt;\&lt;/code&gt; is special because it is used in escape sequences, just like above. Here is how the special characters &lt;code&gt;]$\&lt;/code&gt; are handled:</source>
          <target state="translated">我们在上一节中看到，有普通字符表示自己，而特殊字符则需要反斜杠 &lt;code&gt;\&lt;/code&gt; 表示自己。在字符类中也是如此，但是字符类内的普通字符和特殊字符集与字符类外的字符集不同。字符类的特殊字符是 &lt;code&gt;-]\^$&lt;/code&gt; （以及模式定界符，无论它是什么）。 &lt;code&gt;]&lt;/code&gt; 是特殊的，因为它表示字符类的结尾。 &lt;code&gt;$&lt;/code&gt; 之所以特殊是因为它表示一个标量变量。 &lt;code&gt;\&lt;/code&gt; 之所以很特殊，是因为它用于转义序列中，就像上面一样。以下是特殊字符 &lt;code&gt;]$\&lt;/code&gt; 的处理方式：</target>
        </trans-unit>
        <trans-unit id="91ab61be245cfbe060001be5799707fcb012f47d" translate="yes" xml:space="preserve">
          <source>We saw that the norm of &lt;code&gt;z&lt;/code&gt; was noted &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt; and was defined as the distance to the origin, also known as:</source>
          <target state="translated">我们看到的规范 &lt;code&gt;z&lt;/code&gt; 指出 &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt; ，并定义为原点，也被称为距离：</target>
        </trans-unit>
        <trans-unit id="08920844359a9b99eec6c4ed6a36e0f532af1cca" translate="yes" xml:space="preserve">
          <source>We show the &quot;put&quot; form of the accessors below (i.e., the syntax you use for setting the accessor to a specific value). But you can also call each method with no parameters to get its current value. For example, &lt;code&gt;$self-&amp;gt;contents_file()&lt;/code&gt; returns the current value of the contents_file attribute.</source>
          <target state="translated">我们在下面显示访问器的&amp;ldquo; put&amp;rdquo;形式（即，用于将访问器设置为特定值的语法）。但是，您也可以不使用任何参数来调用每个方法以获取其当前值。例如， &lt;code&gt;$self-&amp;gt;contents_file()&lt;/code&gt; 返回contents_file属性的当前值。</target>
        </trans-unit>
        <trans-unit id="d711adc8921158fc2754824f56564036d9f3cc37" translate="yes" xml:space="preserve">
          <source>We specify a local port in the &lt;code&gt;LocalPort&lt;/code&gt; argument, which we didn't do for the client. This is service name or port number for which you want to be the server. (Under Unix, ports under 1024 are restricted to the superuser.) In our sample, we'll use port 9000, but you can use any port that's not currently in use on your system. If you try to use one already in used, you'll get an &quot;Address already in use&quot; message. Under Unix, the &lt;code&gt;netstat -a&lt;/code&gt; command will show which services current have servers.</source>
          <target state="translated">我们在 &lt;code&gt;LocalPort&lt;/code&gt; 参数中指定一个本地端口，而我们并未为客户端做此操作。这是您要用作服务器的服务名称或端口号。（在Unix下，低于1024的端口仅限于超级用户。）在我们的示例中，我们将使用端口9000，但是您可以使用系统上当前未使用的任何端口。如果您尝试使用已使用的地址，则会收到&amp;ldquo;地址已使用&amp;rdquo;消息。在Unix下， &lt;code&gt;netstat -a&lt;/code&gt; 命令将显示当前具有服务器的服务。</target>
        </trans-unit>
        <trans-unit id="d2e82c57891dd489170077bbfa6bd5d7eef124d7" translate="yes" xml:space="preserve">
          <source>We still got a few errors during &lt;code&gt;make test&lt;/code&gt; . Some of them are the result of using bison. Bison prints</source>
          <target state="translated">在进行 &lt;code&gt;make test&lt;/code&gt; 我们仍然有一些错误。其中一些是使用野牛的结果。野牛版画</target>
        </trans-unit>
        <trans-unit id="5d27fd099f66e666f815d6a063eb846b9d1e750a" translate="yes" xml:space="preserve">
          <source>We still use the normal yacc for a2p.y though!!! We made a softlink called byacc to distinguish between the two versions:</source>
          <target state="translated">不过我们还是用普通的yacc来做a2p.y!!! 我们做了一个名为byacc的软链接来区分这两个版本。</target>
        </trans-unit>
        <trans-unit id="f7a01cac535c65877c2cb721bb86383129124455" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use git if possible. It will make your life easier, and ours as well.</source>
          <target state="translated">我们强烈建议您尽可能使用 git。它将使您和我们的生活更加轻松。</target>
        </trans-unit>
        <trans-unit id="c1224f92134a2160e75f8a1e63e0730529cc456d" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use one of these systems. Even the most minimal of them eliminates a lot of repetitive boilerplate. There's really no good reason to write your classes from scratch in Perl.</source>
          <target state="translated">我们强烈建议你使用这些系统之一。即使是最简陋的系统,也能消除很多重复的模板。真的没有理由在Perl中从头开始写你的类。</target>
        </trans-unit>
        <trans-unit id="5f4fa8e578a8c0a7391c3d072ae8a1a053f0a384" translate="yes" xml:space="preserve">
          <source>We tend to avoid this term because it means so many things. It may mean a command-line &lt;b&gt;switch&lt;/b&gt; that takes no argument itself (such as Perl&amp;rsquo;s &lt;code&gt;&amp;ndash;n&lt;/code&gt; and &lt;code&gt;&amp;ndash;p&lt;/code&gt; flags) or, less frequently, a single-bit indicator (such as the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags used in &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;). Sometimes informally used to refer to certain regex modifiers.</source>
          <target state="translated">我们倾向于避免使用这个术语，因为它意味着很多东西。这可能意味着命令行&lt;b&gt;开关&lt;/b&gt;本身不带任何参数（例如Perl的 &lt;code&gt;&amp;ndash;n&lt;/code&gt; 和 &lt;code&gt;&amp;ndash;p&lt;/code&gt; 标志），或者不经常使用单个位的指示符（例如 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 中使用的 &lt;code&gt;O_CREAT&lt;/code&gt; 和 &lt;code&gt;O_EXCL&lt;/code&gt; 标志）。有时非正式地用于指代某些正则表达式修饰符。</target>
        </trans-unit>
        <trans-unit id="8a3b4e98c264bb32d9998c5d96e9cb12719e9b31" translate="yes" xml:space="preserve">
          <source>We then do (always a good idea) a syntax check before we try to run it again:</source>
          <target state="translated">然后,在我们再次尝试运行它之前,我们要做一次语法检查(总是一个好主意)。</target>
        </trans-unit>
        <trans-unit id="a54d539385035f7d9714e68587e437b9e809a0a4" translate="yes" xml:space="preserve">
          <source>We use the term &quot;nearly&quot;, because &lt;code&gt;:not_characters&lt;/code&gt; also turns on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; within its scope. This form is less useful in v5.20 and later, and is described fully in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;, but briefly, it tells Perl to not use the character portions of the locale definition, that is the &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt; categories. Instead it will use the native character set (extended by Unicode). When using this parameter, you are responsible for getting the external character set translated into the native/Unicode one (which it already will be if it is one of the increasingly popular UTF-8 locales). There are convenient ways of doing this, as described in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;.</source>
          <target state="translated">我们使用术语&amp;ldquo;几乎&amp;rdquo;，因为 &lt;code&gt;:not_characters&lt;/code&gt; 还会在其范围内启用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 。此格式在v5.20及更高版本中不太有用，并且在&lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode和UTF-8&lt;/a&gt;中进行了完整描述，但简要地说，它告诉Perl不要使用语言环境定义的字符部分，即 &lt;code&gt;LC_CTYPE&lt;/code&gt; 和 &lt;code&gt;LC_COLLATE&lt;/code&gt; 类别。相反，它将使用本机字符集（由Unicode扩展）。使用此参数时，您有责任将外部字符集转换为本地/ Unicode字符集（如果它是越来越流行的UTF-8语言环境之一，则已经存在）。有很方便的方法，如&lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode和UTF-8中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d72bbd81e111127cc31735e5170b3d3ebdc6c5df" translate="yes" xml:space="preserve">
          <source>We used version 1.2.4, which could be installed out of the box with one failure during 'make check'.</source>
          <target state="translated">我们使用的是1.2.4版本,在 &quot;make check &quot;过程中,只要有一次失败,就可以开箱安装。</target>
        </trans-unit>
        <trans-unit id="aff45f6c939582aab469b75158efc5869d3a2fcf" translate="yes" xml:space="preserve">
          <source>We want to be able to catch the</source>
          <target state="translated">我们希望能够抓住</target>
        </trans-unit>
        <trans-unit id="da129d4b3f31bc7e0cab0dd659997b6d3ef9282c" translate="yes" xml:space="preserve">
          <source>We want to ensure that Perl continues to grow and flourish in the coming years and decades, but not at the expense of our user community.</source>
          <target state="translated">我们希望确保Perl在未来的几年和几十年里继续发展和繁荣,但不能以牺牲我们的用户社区为代价。</target>
        </trans-unit>
        <trans-unit id="7602b11fb920ddd30994aa4313930abda93469a9" translate="yes" xml:space="preserve">
          <source>We wanted list context, so G_ARRAY was used.</source>
          <target state="translated">我们想要的是列表上下文,所以使用了G_ARRAY。</target>
        </trans-unit>
        <trans-unit id="3134ffe8598077df7a151748c12e387529c7d2bc" translate="yes" xml:space="preserve">
          <source>We will be calling the test script through the command &quot;&lt;code&gt;make test&lt;/code&gt; &quot;. You should see output that looks something like this:</source>
          <target state="translated">我们将通过&amp;ldquo; &lt;code&gt;make test&lt;/code&gt; &amp;rdquo; 命令调用测试脚本。您应该看到如下所示的输出：</target>
        </trans-unit>
        <trans-unit id="0a6f3f09fa5bfb41f8f72f761c01531e59969f1d" translate="yes" xml:space="preserve">
          <source>We will not provide security updates or bug fixes for development releases of Perl.</source>
          <target state="translated">我们不会为 Perl 的开发版本提供安全更新或错误修复。</target>
        </trans-unit>
        <trans-unit id="788212053c8b040e14cd53eba253eacd9f8cbdce" translate="yes" xml:space="preserve">
          <source>We will now create the main top-level Mytest2 files. Change to the directory above Mytest2 and run the following command:</source>
          <target state="translated">现在我们将创建主要的顶层Mytest2文件。换到Mytest2上面的目录,运行下面的命令。</target>
        </trans-unit>
        <trans-unit id="d22caa360403eba16e21b51e9ea68e688fb5cc28" translate="yes" xml:space="preserve">
          <source>We would all love to unmake some mistakes we've made over the past decades. Living with every design error we've ever made can lead to painful stagnation. Unwinding our mistakes is very, very difficult. Doing so without actively harming our users is nearly impossible.</source>
          <target state="translated">我们都很想解开过去几十年来所犯的一些错误。带着我们曾经犯过的每一个设计错误生活会导致痛苦的停滞。解除我们的错误是非常非常困难的。在不主动伤害我们的用户的情况下,这样做几乎是不可能的。</target>
        </trans-unit>
        <trans-unit id="461ccef8111ec963260713b6b25723c4d738d9a8" translate="yes" xml:space="preserve">
          <source>We'll come back to this city-country problem later, after we've seen some syntax for managing references.</source>
          <target state="translated">在我们看过一些管理引用的语法之后,我们以后再来讨论这个城乡问题。</target>
        </trans-unit>
        <trans-unit id="7cbf9f8ec2dcbf019622a935f28d55742617ea78" translate="yes" xml:space="preserve">
          <source>We'll get to the meaning of those Perlish-looking variables in a little bit.</source>
          <target state="translated">我们稍后会了解这些看起来像Perlish的变量的含义。</target>
        </trans-unit>
        <trans-unit id="ccbe83524a5012d45f354f697c95fa9a1eb5367f" translate="yes" xml:space="preserve">
          <source>We'll have another string pointer in there:</source>
          <target state="translated">我们将有另一个字符串指针在那里。</target>
        </trans-unit>
        <trans-unit id="5672edbff82e9ae33e95bbfe34109b2db08b3398" translate="yes" xml:space="preserve">
          <source>We'll look at output first. Supposing we already have this structure, how do we print it out?</source>
          <target state="translated">我们先看输出。假设我们已经有了这个结构,那么我们如何将它打印出来呢?</target>
        </trans-unit>
        <trans-unit id="8801992116fa36a8b481455c1f17fda02ba0a864" translate="yes" xml:space="preserve">
          <source>We'll see a more tricky example of this when we consider Perl's macros below. &lt;code&gt;POPn&lt;/code&gt; gives you the NV (floating point value) of the top SV on the stack: the &lt;code&gt;$x&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos($x)&lt;/a&gt;&lt;/code&gt;. Then we compute the cosine, and push the result back as an NV. The &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;XPUSHn&lt;/code&gt; means that the stack should be extended if necessary - it can't be necessary here, because we know there's room for one more item on the stack, since we've just removed one! The &lt;code&gt;XPUSH*&lt;/code&gt; macros at least guarantee safety.</source>
          <target state="translated">当我们在下面考虑Perl的宏时，我们将看到一个更加棘手的示例。 &lt;code&gt;POPn&lt;/code&gt; 给你堆栈顶部SV的NV（浮点值）：在 &lt;code&gt;$x&lt;/code&gt; 中的 &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos($x)&lt;/a&gt;&lt;/code&gt; 。然后我们计算余弦，并将结果推回为NV。该 &lt;code&gt;X&lt;/code&gt; 在 &lt;code&gt;XPUSHn&lt;/code&gt; 意味着当堆栈应该在必要时延长- ，因为我们知道它没有必要在这里的房间栈上多了一个项目，因为我们刚刚删除了一个！该 &lt;code&gt;XPUSH*&lt;/code&gt; 至少保证安全的宏。</target>
        </trans-unit>
        <trans-unit id="b55bbd57ee31a3c27c5821f6c991f3bb8fbebc65" translate="yes" xml:space="preserve">
          <source>We'll simply continue down to our pre-set breakpoint with a '&lt;b&gt;c&lt;/b&gt;':</source>
          <target state="translated">我们将简单地继续使用' &lt;b&gt;c&lt;/b&gt; ' 到我们的预设断点：</target>
        </trans-unit>
        <trans-unit id="a9a2d405fbc50682e1a3c2bf95879ebe85538d93" translate="yes" xml:space="preserve">
          <source>We'll use &lt;code&gt;gdb&lt;/code&gt; for our examples here; the principles will apply to any debugger (many vendors call their debugger &lt;code&gt;dbx&lt;/code&gt; ), but check the manual of the one you're using.</source>
          <target state="translated">在这里，我们将使用 &lt;code&gt;gdb&lt;/code&gt; 作为示例；该原则将适用于任何调试器（许多供应商称其调试器为 &lt;code&gt;dbx&lt;/code&gt; ），但请查看所用调试器的手册。</target>
        </trans-unit>
        <trans-unit id="dd00180725dcce313c6ef1b86501c9848503c2c0" translate="yes" xml:space="preserve">
          <source>We'll use Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">我们将使用Jarkko Hietaniemi &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f54f2656a6244346ba143809ce965c3e152258c1" translate="yes" xml:space="preserve">
          <source>We're Netware in addition to being Windows.</source>
          <target state="translated">我们除了是Windows之外,还是网件。</target>
        </trans-unit>
        <trans-unit id="89a6bcd8665abf52d39396f9fea984b5d7d01f5f" translate="yes" xml:space="preserve">
          <source>We're Unix and Cygwin.</source>
          <target state="translated">我们是Unix和Cygwin。</target>
        </trans-unit>
        <trans-unit id="bae7bf51fd64828a801e9cd04e2c5e1eac38f446" translate="yes" xml:space="preserve">
          <source>We're going to add two more items onto the argument stack: when you have a tied array, the &lt;code&gt;PUSH&lt;/code&gt; subroutine receives the object and the value to be pushed, and that's exactly what we have here - the tied object, retrieved with &lt;code&gt;SvTIED_obj&lt;/code&gt; , and the value, the SV &lt;code&gt;val&lt;/code&gt; .</source>
          <target state="translated">我们将在参数堆栈上再添加两个项目：当您有一个绑定数组时， &lt;code&gt;PUSH&lt;/code&gt; 子例程会接收对象和要推送的值，而这正是我们在这里-绑定对象，使用 &lt;code&gt;SvTIED_obj&lt;/code&gt; 检索，和值SV &lt;code&gt;val&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="982b2dd7e00a50956cc41a996392e78491465b29" translate="yes" xml:space="preserve">
          <source>We're going to primarily concentrate on Perl-only modules here, rather than XS modules. XS modules serve a rather different purpose, and you should consider different things before distributing them - the popularity of the library you are gluing, the portability to other operating systems, and so on. However, the notes on preparing the Perl side of the module and packaging and distributing it will apply equally well to an XS module as a pure-Perl one.</source>
          <target state="translated">我们在这里主要集中在Perl专用模块上,而不是XS模块。XS模块的作用相当不同,你在发布它们之前应该考虑不同的事情--你所粘连的库的受欢迎程度,对其他操作系统的可移植性等等。然而,关于准备模块的Perl方面以及打包和发布的注意事项同样适用于XS模块和纯Perl模块。</target>
        </trans-unit>
        <trans-unit id="34118bf3962978ee960cb834c23b6a7907e48ac6" translate="yes" xml:space="preserve">
          <source>We've already seen how to print to standard output using &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; can also take an optional first argument specifying which filehandle to print to:</source>
          <target state="translated">我们已经看到了如何使用 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 打印到标准输出。但是， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 也可以使用可选的第一个参数，以指定要打印到的文件句柄：</target>
        </trans-unit>
        <trans-unit id="01a8063bdaca09993ddd8d252b857fa09a430a49" translate="yes" xml:space="preserve">
          <source>We've also told Perl about the library that we built in the mylib subdirectory. That required only the addition of the &lt;code&gt;MYEXTLIB&lt;/code&gt; variable to the WriteMakefile call and the replacement of the postamble subroutine to cd into the subdirectory and run make. The Makefile.PL for the library is a bit more complicated, but not excessively so. Again we replaced the postamble subroutine to insert our own code. This code simply specified that the library to be created here was a static archive library (as opposed to a dynamically loadable library) and provided the commands to build it.</source>
          <target state="translated">我们还告诉了Perl我们在mylib子目录中构建的库。只需向WriteMakefile调用中添加 &lt;code&gt;MYEXTLIB&lt;/code&gt; 变量，并替换postamble子例程即可将cd插入子目录并运行make。该库的Makefile.PL有点复杂，但并不过分。再次，我们替换了postamble子例程以插入我们自己的代码。该代码仅指定要在此处创建的库是静态存档库（与可动态加载的库相对），并提供了构建它的命令。</target>
        </trans-unit>
        <trans-unit id="6afd998315c2c6324bb813d112e9a8f30bf0d582" translate="yes" xml:space="preserve">
          <source>We've covered the workhorse parts of Perl's threading package, and with these tools you should be well on your way to writing threaded code and packages. There are a few useful little pieces that didn't really fit in anyplace else.</source>
          <target state="translated">我们已经介绍了Perl的线程包的主要部分,有了这些工具,你应该可以很好地编写线程代码和包。有一些有用的小部件并没有放在其他任何地方。</target>
        </trans-unit>
        <trans-unit id="b4d69ed91d0829df5cfa125f68b479f5de86f05f" translate="yes" xml:space="preserve">
          <source>We've gone past our check (where 'All OK' was printed) and have stopped just before the meat of our task. We could try to print out a couple of variables to see what is happening:</source>
          <target state="translated">我们已经通过了检查(打印了 &quot;All OK&quot;),在任务的实质之前停了下来。我们可以试着打印出几个变量来看看发生了什么。</target>
        </trans-unit>
        <trans-unit id="33a66a35950ff295dc8b9c6a23c44bcace53edc3" translate="yes" xml:space="preserve">
          <source>We've had Larry's h2ph translator, which helped, but that only works on cpp symbols, not real C, which was also very much needed. What I offer you is a symbolic way of getting at all the C structures. I've couched them in terms of packages and functions. Consider the following program:</source>
          <target state="translated">我们已经有了Larry的h2ph翻译器,这很有帮助,但那只对cpp符号有效,而不是真正的C,这也是非常需要的。我提供给你的是一种符号化的方式来获取所有的C结构。我把它们用包和函数来表述。考虑以下程序。</target>
        </trans-unit>
        <trans-unit id="f3af9852bf7e4f70a4af9b26111fb8e3956f866b" translate="yes" xml:space="preserve">
          <source>We've made some changes to Makefile.PL. In this case, we've specified an extra library to be linked into the extension's shared library, the math library libm in this case. We'll talk later about how to write XSUBs that can call every routine in a library.</source>
          <target state="translated">我们对Makefile.PL做了一些修改。在这种情况下,我们指定了一个额外的库来链接到扩展的共享库中,本例中的数学库libm。我们稍后将讨论如何编写XSUB,可以调用库中的每个例程。</target>
        </trans-unit>
        <trans-unit id="a904b7cf0e87b370c484aeda4a3fd7921273c345" translate="yes" xml:space="preserve">
          <source>We've seen how to encourage good coding practices with &lt;b&gt;use strict&lt;/b&gt; and &lt;b&gt;-w&lt;/b&gt;. We can run the perl debugger &lt;b&gt;perl -d scriptname&lt;/b&gt; to inspect your data from within the perl debugger with the &lt;b&gt;p&lt;/b&gt; and &lt;b&gt;x&lt;/b&gt; commands. You can walk through your code, set breakpoints with &lt;b&gt;b&lt;/b&gt; and step through that code with &lt;b&gt;s&lt;/b&gt; or &lt;b&gt;n&lt;/b&gt;, continue with &lt;b&gt;c&lt;/b&gt; and return from a sub with &lt;b&gt;r&lt;/b&gt;. Fairly intuitive stuff when you get down to it.</source>
          <target state="translated">我们已经看到了如何通过&lt;b&gt;使用strict&lt;/b&gt;和&lt;b&gt;-w&lt;/b&gt;鼓励良好的编码实践。我们可以运行perl调试器&lt;b&gt;perl -d脚本名&lt;/b&gt;，使用&lt;b&gt;p&lt;/b&gt;和&lt;b&gt;x&lt;/b&gt;命令从perl调试器中检查您的数据。您可以遍历代码，使用&lt;b&gt;b&lt;/b&gt;设置断点，并使用&lt;b&gt;s&lt;/b&gt;或&lt;b&gt;n&lt;/b&gt;逐步执行该代码，使用&lt;b&gt;c&lt;/b&gt;继续并使用&lt;b&gt;r&lt;/b&gt;从子返回。当您开始学习时，它会非常直观。</target>
        </trans-unit>
        <trans-unit id="9f4aba3ac8d090b513bcacbad039797adbe73abe" translate="yes" xml:space="preserve">
          <source>We've taken some pains to construct the template so that it matches the contents of our frame buffer. Otherwise we'd either get undefined values, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; could not unpack all. If &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; runs out of items, it will supply null strings (which are coerced into zeroes whenever the pack code says so).</source>
          <target state="translated">我们花了一些心思来构造模板，以使其与我们的帧缓冲区的内容匹配。否则，我们要么得到未定义的值，要么 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 无法解包全部。如果 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 中的项目用完了，它将提供null字符串（每当pack代码这样说时，它们就会强制为零）。</target>
        </trans-unit>
        <trans-unit id="37fc93f698eef77381e152ba1261b27e22014722" translate="yes" xml:space="preserve">
          <source>We've tried to make this also work with the TODO: syntax, but it's not guaranteed and its use is also discouraged:</source>
          <target state="translated">我们试图让这个也能使用TODO:语法,但这不能保证,也不鼓励使用它。</target>
        </trans-unit>
        <trans-unit id="d057d23b834db4b8d50936a9c8b48cc9bb56ac94" translate="yes" xml:space="preserve">
          <source>We've tried to minimize the dependence of Perl library modules on Unix syntax, but you may find that some of these, as well as some scripts written for Unix systems, will require that you use Unix syntax, since they will assume that '/' is the directory separator,</source>
          <target state="translated">我们已经尽量减少Perl库模块对Unix语法的依赖性,但是你可能会发现其中的一些模块,以及一些为Unix系统编写的脚本,会要求你使用Unix语法,因为它们会假定'/'是目录分隔符。</target>
        </trans-unit>
        <trans-unit id="f63c6786d8c83343c69f80cf76418c3681700514" translate="yes" xml:space="preserve">
          <source>We've used a hash slice in order to easily handle the fields of each row. Storing the keys in an array makes it easy to operate on them as a group or loop over them with &lt;code&gt;for&lt;/code&gt; . It also avoids polluting the program with global variables and using symbolic references.</source>
          <target state="translated">为了方便处理每一行的字段，我们使用了哈希切片。将键存储在数组中可以轻松地对它们进行分组操作或使用 &lt;code&gt;for&lt;/code&gt; 对其进行循环。它还避免了使用全局变量和使用符号引用来污染程序。</target>
        </trans-unit>
        <trans-unit id="e147d82cb4cdd9e073d031a1a26cd0222dd868d0" translate="yes" xml:space="preserve">
          <source>Weaken a reference: set the &lt;code&gt;SvWEAKREF&lt;/code&gt; flag on this RV; give the referred-to SV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; magic if it hasn't already; and push a back-reference to this RV onto the array of backreferences associated with that magic. If the RV is magical, set magic will be called after the RV is cleared.</source>
          <target state="translated">&lt;code&gt;SvWEAKREF&lt;/code&gt; 引用：在此RV上设置SvWEAKREF标志；如果尚未提供，请给所引用的SV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; 魔术；并将此RV的反向引用推到与该魔术关联的反向引用数组中。如果RV具有魔力，则清除RV后将召唤设定魔法。</target>
        </trans-unit>
        <trans-unit id="6f4b4063ed2668451305a4ea955df5abd08928f3" translate="yes" xml:space="preserve">
          <source>Weakrefs call uvar magic</source>
          <target state="translated">弱参考调用uvar magic</target>
        </trans-unit>
        <trans-unit id="a87a48da60ac110880ba420c176bfa3b966a1bbc" translate="yes" xml:space="preserve">
          <source>Websites</source>
          <target state="translated">Websites</target>
        </trans-unit>
        <trans-unit id="c46c01995b645fa6ced7ccd3bd695a2325cf2829" translate="yes" xml:space="preserve">
          <source>Weed out arguments that are not supported and warn about them to the user</source>
          <target state="translated">剔除不支持的论点,并向用户发出警告。</target>
        </trans-unit>
        <trans-unit id="5ff64b425852808bfa9bcc07404d47fe62f5255b" translate="yes" xml:space="preserve">
          <source>Week Number</source>
          <target state="translated">周数</target>
        </trans-unit>
        <trans-unit id="e47cfca7176dccc849b8b9085335ec9965e39788" translate="yes" xml:space="preserve">
          <source>Weighting CJK Unified Ideographs</source>
          <target state="translated">中日韩统一表意文字的权重</target>
        </trans-unit>
        <trans-unit id="6b33b573e9b7a7f05800470ad22d2691de1ad1d8" translate="yes" xml:space="preserve">
          <source>Weighting JIS KANJI for Unicode::Collate</source>
          <target state="translated">为Unicode::Collate加权JIS KANJI。</target>
        </trans-unit>
        <trans-unit id="b6757ec0e4d4ce4eae1496f199fc7aa0d085efea" translate="yes" xml:space="preserve">
          <source>Weighting may vary depending on collation element table. So ensure the weights defined in &lt;code&gt;entry&lt;/code&gt; will be consistent with those in the collation element table loaded via &lt;code&gt;table&lt;/code&gt; .</source>
          <target state="translated">权重可能因归类元素表而异。因此，请确保 &lt;code&gt;entry&lt;/code&gt; 定义的权重与通过 &lt;code&gt;table&lt;/code&gt; 加载的归类元素表中的权重保持一致。</target>
        </trans-unit>
        <trans-unit id="7b6bdfd154d71780792f4f6d415a46881c01b84f" translate="yes" xml:space="preserve">
          <source>Weights in reverse order; ex. level 2 (diacritic ordering) in French. If omitted (or &lt;code&gt;$levelNumber&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;\@levelNumbers&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt; ), forwards at all the levels.</source>
          <target state="translated">权重相反；例如 法语2级（变音符号顺序）。如果省略（或 &lt;code&gt;$levelNumber&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;\@levelNumbers&lt;/code&gt; 为 &lt;code&gt;[]&lt;/code&gt; ），则在所有级别转发。</target>
        </trans-unit>
        <trans-unit id="1ade9c702a20a6384a7a0b9552d289287a18c722" translate="yes" xml:space="preserve">
          <source>Well, apart from a bare &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; $fh&lt;/code&gt; , you shouldn't treat them specially. (The binmode is needed because otherwise Perl may convert line endings on Win32 systems.)</source>
          <target state="translated">好吧，除了简单的 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; $fh&lt;/code&gt; ，您不应该特别对待它们。（bin模式是必需的，因为否则Perl可能会在Win32系统上转换行尾。）</target>
        </trans-unit>
        <trans-unit id="504ec4c7237da89364f87b2aad3291cf833f70a8" translate="yes" xml:space="preserve">
          <source>Well, having several executables dynamically linked to the same huge library has its advantages, but this would not substantiate the additional work to make it compile. The reason is the complicated-to-developers but very quick and convenient-to-users &quot;hard&quot; dynamic linking used by OS/2.</source>
          <target state="translated">好吧,让几个可执行文件动态链接到同一个庞大的库中有它的优势,但这并不能证明要为编译而进行额外的工作。原因是OS/2使用的 &quot;硬 &quot;动态链接对开发者来说很复杂,但对用户来说却非常快速和方便。</target>
        </trans-unit>
        <trans-unit id="b4bf2ee14e4e81fc05f1087aeed820b042b0028b" translate="yes" xml:space="preserve">
          <source>Well, if you can, upgrade to the most recent, but certainly &lt;code&gt;5.8.1&lt;/code&gt; or newer. The tutorial and FAQ assume the latest release.</source>
          <target state="translated">好吧，如果可以的话，升级到最新的版本，但肯定是 &lt;code&gt;5.8.1&lt;/code&gt; 或更高版本。本教程和FAQ假定为最新版本。</target>
        </trans-unit>
        <trans-unit id="c922bdb3f23d6c5306883fe0bee806df01fe877f" translate="yes" xml:space="preserve">
          <source>Well, maybe not. Anyway, each op contains a function pointer, which stipulates the function which will actually carry out the operation. This function will return the next op in the sequence - this allows for things like &lt;code&gt;if&lt;/code&gt; which choose the next op dynamically at run time. The &lt;code&gt;PERL_ASYNC_CHECK&lt;/code&gt; makes sure that things like signals interrupt execution if required.</source>
          <target state="translated">好吧，也许不是。无论如何，每个操作都包含一个函数指针，该指针规定了将实际执行该操作的函数。该函数将返回下一个运算序列中-这使得喜欢的事情 &lt;code&gt;if&lt;/code&gt; 动态地选择下一个运算的运行时间。该 &lt;code&gt;PERL_ASYNC_CHECK&lt;/code&gt; 可以确保在需要的东西像信号中断执行。</target>
        </trans-unit>
        <trans-unit id="fb7d8a35468fea02bd934ea87237f211894a5751" translate="yes" xml:space="preserve">
          <source>Well, nowadays Perl DLL should be usable from a differently compiled program too... If you can run Perl code from REXX scripts (see &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;), then there are some other aspect of interaction which are overlooked by the current hackish code to support differently-compiled principal programs.</source>
          <target state="translated">好吧，如今，Perl DLL也应该可以从不同编译的程序中使用...如果您可以从REXX脚本中运行Perl代码（请参阅&lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2 :: REXX&lt;/a&gt;），那么当前的黑名单代码会忽略交互的其他方面支持不同编译的主体程序。</target>
        </trans-unit>
        <trans-unit id="61cb10844d83ee77c0e38f0deaf6e76838a94cbb" translate="yes" xml:space="preserve">
          <source>Well, okay, not entirely like C's arrays, actually. C doesn't know how to grow its arrays on demand. Perl does.</source>
          <target state="translated">好吧,好吧,其实不完全像C的数组。C不知道如何按需增长其数组。Perl知道。</target>
        </trans-unit>
        <trans-unit id="c4f3fa326a3af64f93426bcdac847f46a94f9b1b" translate="yes" xml:space="preserve">
          <source>Well, that's</source>
          <target state="translated">嗯,那是</target>
        </trans-unit>
        <trans-unit id="bf3871275db74807de50e10189deb9ba1201d5b4" translate="yes" xml:space="preserve">
          <source>Well, that's all fine if you want to send one command and get one answer, but what about setting up something fully interactive, somewhat like the way</source>
          <target state="translated">好吧,如果你想发送一个命令并得到一个答案,这一切都很好,但是设置一些完全互动的东西,有点像</target>
        </trans-unit>
        <trans-unit id="a4fcece5fae45fd55beac8d83dea4ffc7bb1546c" translate="yes" xml:space="preserve">
          <source>Well, that's because the rule is that on adjacent brackets only (whether square or curly), you are free to omit the pointer dereferencing arrow. But you cannot do so for the very first one if it's a scalar containing a reference, which means that $ref_to_AoA always needs it.</source>
          <target state="translated">好吧,那是因为规则是只在相邻的括号上(不管是方括号还是卷括号),你可以自由地省略指针去参考箭头。但是如果是一个包含引用的标量,你就不能对第一个标量这样做,这意味着$ref_to_AoA总是需要它。</target>
        </trans-unit>
        <trans-unit id="5937ea9ee293b2d54cd64fb9f3a778625f679e1c" translate="yes" xml:space="preserve">
          <source>Well, this isn't very easy to read, and using the helpful manual (&lt;b&gt;h h&lt;/b&gt;), the '&lt;b&gt;x&lt;/b&gt;' command looks promising:</source>
          <target state="translated">好吧，这不是很容易阅读，使用有用的手册（&lt;b&gt;hh&lt;/b&gt;），' &lt;b&gt;x&lt;/b&gt; '命令看起来很有希望：</target>
        </trans-unit>
        <trans-unit id="81775bcb15e4091e227d731dfdef1462a2bf3f2b" translate="yes" xml:space="preserve">
          <source>Well, you could keep them in sync, but there's no guarantee it will always hold on classes somebody else wrote. Besides, there is little to gain in doing so: a serializing hook could keep only one attribute of an object, which is probably not what should happen during a deep cloning of that same object.</source>
          <target state="translated">好吧,你可以让它们保持同步,但并不能保证它永远保持在别人写的类上。此外,这样做也没有什么好处:一个序列化钩子只能保持一个对象的一个属性,这可能不是同一个对象的深度克隆过程中应该发生的事情。</target>
        </trans-unit>
        <trans-unit id="c6c58c114eba15fa1fde6b56057cb927734327d9" translate="yes" xml:space="preserve">
          <source>What *is* Unicode, anyway?</source>
          <target state="translated">统一码到底是什么?</target>
        </trans-unit>
        <trans-unit id="2948ac1effa2d43a9756f45e31fc4dfaf54b428e" translate="yes" xml:space="preserve">
          <source>What &lt;b&gt;is&lt;/b&gt; Unicode, anyway?</source>
          <target state="translated">Unicode &lt;b&gt;是&lt;/b&gt;什么？</target>
        </trans-unit>
        <trans-unit id="0c27997670ea19d058363ea936f9c5a132d90646" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; does</source>
          <target state="translated">什么 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 呢</target>
        </trans-unit>
        <trans-unit id="828c569308e99c356a11f905449002a24faaf00f" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\n&lt;/code&gt; represents depends on the type of file opened. It usually represents &lt;code&gt;\012&lt;/code&gt; but it could also be &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , &lt;code&gt;\015\012&lt;/code&gt; , &lt;code&gt;\000&lt;/code&gt; , &lt;code&gt;\040&lt;/code&gt; , or nothing depending on the file organization and record format. The &lt;code&gt;VMS::Stdio&lt;/code&gt; module provides access to the special &lt;code&gt;fopen()&lt;/code&gt; requirements of files with unusual attributes on VMS.</source>
          <target state="translated">&lt;code&gt;\n&lt;/code&gt; 代表什么取决于打开的文件类型。它通常表示 &lt;code&gt;\012&lt;/code&gt; 但也可以是 &lt;code&gt;\015&lt;/code&gt; ， &lt;code&gt;\012&lt;/code&gt; ， &lt;code&gt;\015\012&lt;/code&gt; ， &lt;code&gt;\000&lt;/code&gt; ， &lt;code&gt;\040&lt;/code&gt; 或什么都不是，这取决于文件的组织和记录格式。该 &lt;code&gt;VMS::Stdio&lt;/code&gt; 模块提供特殊的 &lt;code&gt;fopen()&lt;/code&gt; 函数与VMS不寻常的属性的文件的要求。</target>
        </trans-unit>
        <trans-unit id="fcc1cc41a80c328b4eb792743f378eba1c9a93d1" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\p{Digit}&lt;/code&gt; means (and hence &lt;code&gt;\d&lt;/code&gt; except under the &lt;code&gt;/a&lt;/code&gt; modifier) is &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt; , or synonymously, &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt; . Starting with Unicode version 4.1, this is the same set of characters matched by &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt; . But Unicode also has a different property with a similar name, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; , which matches a completely different set of characters. These characters are things such as &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; or subscripts, or are from writing systems that lack all ten digits.</source>
          <target state="translated">什么 &lt;code&gt;\p{Digit}&lt;/code&gt; 的装置（并且因此 &lt;code&gt;\d&lt;/code&gt; 除下 &lt;code&gt;/a&lt;/code&gt; 改性剂）是 &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt; ，或同义地， &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt; 。从Unicode版本4.1开始，这是 &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt; 匹配的相同字符集。但是Unicode也具有另一个具有类似名称 &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; 属性，该属性与完全不同的字符集匹配。这些字符是诸如&amp;ldquo; &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; &amp;rdquo;或下标之类的字符，或者来自缺少所有十位数字的书写系统。</target>
        </trans-unit>
        <trans-unit id="1e45028df29a344ed3d5dcfe47d49eff1e4e5b3d" translate="yes" xml:space="preserve">
          <source>What Is A Thread Anyway?</source>
          <target state="translated">到底什么是线?</target>
        </trans-unit>
        <trans-unit id="9f3aa83a51cae6aa5da8eadacc3922153fc22ffe" translate="yes" xml:space="preserve">
          <source>What Not to Export</source>
          <target state="translated">不要出口什么</target>
        </trans-unit>
        <trans-unit id="bcf1ef3ecb402df133384ad31b9f0ab2cd6f6d09" translate="yes" xml:space="preserve">
          <source>What Thread Am I In?</source>
          <target state="translated">我在哪条线上?</target>
        </trans-unit>
        <trans-unit id="bdf11c2c3fa2430fc36aec96902da89a7d6631c6" translate="yes" xml:space="preserve">
          <source>What Threads Are Running?</source>
          <target state="translated">什么线程在运行?</target>
        </trans-unit>
        <trans-unit id="4628ec6a65c6ef207e94ed239509a432eb2d40b1" translate="yes" xml:space="preserve">
          <source>What You See Is What You Get. Usually used when something that appears on the screen matches how it will eventually look, like Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; declarations. Also used to mean the opposite of magic because everything works exactly as it appears, as in the three- argument form of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">你所看到的就是你得到的。通常在屏幕上出现的内容与最终外观匹配时使用，例如Perl的 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 声明。也用来表示魔术的反义词，因为一切都按其看起来完全一样地工作，如 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 的三参数形式。</target>
        </trans-unit>
        <trans-unit id="71fba121999cf66c38da9b22673582805a4f1ef9" translate="yes" xml:space="preserve">
          <source>What a &lt;b&gt;process&lt;/b&gt; does when it has to wait for something: &amp;ldquo;My process blocked waiting for the disk.&amp;rdquo; As an unrelated noun, it refers to a large chunk of data, of a size that the &lt;b&gt;operating system&lt;/b&gt; likes to deal with (normally a power of 2 such as 512 or 8192). Typically refers to a chunk of data that&amp;rsquo;s coming from or going to a disk file.</source>
          <target state="translated">什么&lt;b&gt;过程&lt;/b&gt;呢，当它必须等待的东西：&amp;ldquo;我的进程阻塞等待磁盘&amp;rdquo;。作为不相关的名词，它指的是大数据块，其大小是&lt;b&gt;操作系统&lt;/b&gt;喜欢处理的大小（通常为2的幂，例如512或8192）。通常指的是来自磁盘文件或进入磁盘文件的数据块。</target>
        </trans-unit>
        <trans-unit id="bc0f239768e941abba33a14d0c879853b4c42602" translate="yes" xml:space="preserve">
          <source>What about &lt;code&gt;pp_add&lt;/code&gt; , the function we examined earlier to implement the &lt;code&gt;+&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;pp_add&lt;/code&gt; 是什么，我们之前检查过的用于实现 &lt;code&gt;+&lt;/code&gt; 运算符的函数：</target>
        </trans-unit>
        <trans-unit id="f06b49d955a9223ccdbf114f85c4f46fdc429b37" translate="yes" xml:space="preserve">
          <source>What about binary data, like images?</source>
          <target state="translated">那二进制数据呢,比如图像?</target>
        </trans-unit>
        <trans-unit id="904b144e4b71718e8b3ada176614f796ad653d66" translate="yes" xml:space="preserve">
          <source>What about read-write mode? You should probably pretend it doesn't exist, because opening text files in read-write mode is unlikely to do what you would like. See &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; for details.</source>
          <target state="translated">那读写模式呢？您可能应该假装它不存在，因为以读写模式打开文本文件不太可能做您想要的事情。有关详细信息，请参见&lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a98ea247bf23a0f2706e40c287b52d50377a4b2f" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 的用法如何？</target>
        </trans-unit>
        <trans-unit id="b08e1e06d029706420aa4cf6848aa2370810866c" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; pragma?</source>
          <target state="translated">怎么样 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; 编译？</target>
        </trans-unit>
        <trans-unit id="3887d9c889fae85aa71ceab4eb1a53b1a8af8aa5" translate="yes" xml:space="preserve">
          <source>What about the use bytes pragma?</source>
          <target state="translated">那使用字节的pragma呢?</target>
        </trans-unit>
        <trans-unit id="77d5d80251afa9ef6da60c5e5fbcd215435339d8" translate="yes" xml:space="preserve">
          <source>What about the use encoding pragma?</source>
          <target state="translated">那使用编码原则呢?</target>
        </trans-unit>
        <trans-unit id="20f362258fa45c702309bd2513e61621aa1951d0" translate="yes" xml:space="preserve">
          <source>What are &lt;code&gt;decode_utf8&lt;/code&gt; and &lt;code&gt;encode_utf8&lt;/code&gt; ?</source>
          <target state="translated">什么是 &lt;code&gt;decode_utf8&lt;/code&gt; 和 &lt;code&gt;encode_utf8&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="f5cae90cb4f341d083e0d8337510fe30e0b15640" translate="yes" xml:space="preserve">
          <source>What are Perl 4, Perl 5, or Perl 6?</source>
          <target state="translated">什么是Perl 4、Perl 5或Perl 6?</target>
        </trans-unit>
        <trans-unit id="01965e32414f80a123a1d37d107d508fa4c75578" translate="yes" xml:space="preserve">
          <source>What are all these $@%&amp;amp;* punctuation signs, and how do I know when to use them?</source>
          <target state="translated">这些$ @％＆*标点符号都是什么，我怎么知道何时使用它们？</target>
        </trans-unit>
        <trans-unit id="11092e508878fe9b88c670c816521fca7c847f2f" translate="yes" xml:space="preserve">
          <source>What are decode_utf8 and encode_utf8?</source>
          <target state="translated">什么是 decode_utf8 和 encode_utf8?</target>
        </trans-unit>
        <trans-unit id="0a2a28ac7fb746402e9baa692599b97fb2da048e" translate="yes" xml:space="preserve">
          <source>What can you do with a reference once you have it? It's a scalar value, and we've seen that you can store it as a scalar and get it back again just like any scalar. There are just two more ways to use it:</source>
          <target state="translated">一旦你拥有了一个引用,你可以用它做什么?它是一个标量值,我们已经看到,你可以把它作为一个标量来存储,并像任何一个标量一样再把它找回来。只是还有两种方法可以使用它。</target>
        </trans-unit>
        <trans-unit id="36be343f96dfd613d8c5cf587823d859ba4e947b" translate="yes" xml:space="preserve">
          <source>What character encodings does Perl support?</source>
          <target state="translated">Perl支持哪些字符编码?</target>
        </trans-unit>
        <trans-unit id="d6aa1873fd68eba0f41fb53a3f8a2033690a4a51" translate="yes" xml:space="preserve">
          <source>What do you really want to know? If you merely want to know if one of your filehandles is connected to a terminal, you can try the &lt;code&gt;-t&lt;/code&gt; file test:</source>
          <target state="translated">您真正想知道什么？如果只想知道您的文件句柄之一是否已连接到终端，则可以尝试 &lt;code&gt;-t&lt;/code&gt; 文件测试：</target>
        </trans-unit>
        <trans-unit id="1c337f8d590673be03d6eb277fa1a70849d518ac" translate="yes" xml:space="preserve">
          <source>What do you think &lt;code&gt;$x&lt;/code&gt; will be? The answer, unfortunately, is</source>
          <target state="translated">您认为 &lt;code&gt;$x&lt;/code&gt; 是什么？不幸的是，答案是</target>
        </trans-unit>
        <trans-unit id="72e224b443b5da69c66ac0a14f3f8175aa612a15" translate="yes" xml:space="preserve">
          <source>What does &quot;Bareword 'DB_File' not allowed&quot; mean?</source>
          <target state="translated">裸词'DB_File'不允许 &quot;是什么意思?</target>
        </trans-unit>
        <trans-unit id="d0af16451ebfa2bdedb9044267c2bc5c148972de" translate="yes" xml:space="preserve">
          <source>What does &quot;Invalid Argument&quot; mean?</source>
          <target state="translated">什么叫 &quot;无效论证&quot;?</target>
        </trans-unit>
        <trans-unit id="f0a7abc8d37e669509493f3435ed1f9575fda404" translate="yes" xml:space="preserve">
          <source>What does &quot;bad interpreter&quot; mean?</source>
          <target state="translated">什么叫 &quot;不好翻译&quot;?</target>
        </trans-unit>
        <trans-unit id="5e47776a0ddea1129634daa43d411c09b05f88dc" translate="yes" xml:space="preserve">
          <source>What does it mean that regexes are greedy? How can I get around it?</source>
          <target state="translated">贪婪的regex是什么意思?怎样才能绕过它?</target>
        </trans-unit>
        <trans-unit id="fad85491a61b1ab9b17396e45b64b419ab4c8e77" translate="yes" xml:space="preserve">
          <source>What does this mean for regexps? Well, regexp users don't need to know much about Perl's internal representation of strings. But they do need to know 1) how to represent Unicode characters in a regexp and 2) that a matching operation will treat the string to be searched as a sequence of characters, not bytes. The answer to 1) is that Unicode characters greater than &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(255)&lt;/a&gt;&lt;/code&gt; are represented using the &lt;code&gt;\x{&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;}&lt;/code&gt; notation, because \x hex (without curly braces) doesn't go further than 255. (Starting in Perl 5.14, if you're an octal fan, you can also use &lt;code&gt;\o{&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;}&lt;/code&gt; .)</source>
          <target state="translated">这对正则表达式意味着什么？好的，regexp用户不需要了解Perl的字符串内部表示形式。但是他们确实需要知道1）如何在正则表达式中表示Unicode字符，以及2）匹配操作会将要搜索的字符串视为字符序列，而不是字节。对1）的答案是，大于 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(255)&lt;/a&gt;&lt;/code&gt; 的 Unicode字符用 &lt;code&gt;\x{&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;}&lt;/code&gt; 表示，因为\ x hex（不带花括号）不会超过255。（从Perl 5.14开始，如果您是八进制风扇，也可以使用 &lt;code&gt;\o{&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;}&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="0d60263af797b45d08166a1e2276365e53b9c7d0" translate="yes" xml:space="preserve">
          <source>What exact layers are in this default stack depends on a lot of things: your operating system, Perl version, Perl compile time configuration, and Perl runtime configuration. See &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;, &lt;a href=&quot;perlrun#PERLIO&quot;&gt;PERLIO in perlrun&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; for more information.</source>
          <target state="translated">此默认堆栈中的确切层取决于很多因素：操作系统，Perl版本，Perl编译时配置和Perl运行时配置。请参阅&lt;a href=&quot;perlio&quot;&gt;perlrun&lt;/a&gt;中的&lt;a href=&quot;perlrun#PERLIO&quot;&gt;PerlIO，PERLIO&lt;/a&gt;，并&lt;a href=&quot;open&quot;&gt;打开&lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="07854a74e069ff620decff4308e92c81d6bd8098" translate="yes" xml:space="preserve">
          <source>What follows are the more advanced, less used, or sometimes esoteric capabilities of Perl regexps. In Part 2, we will assume you are comfortable with the basics and concentrate on the advanced features.</source>
          <target state="translated">下面将介绍Perl regexps中比较高级的、不常用的,或者有时是深奥的功能。在第二部分中,我们将假设你对基础知识已经很熟悉,并将注意力集中在高级功能上。</target>
        </trans-unit>
        <trans-unit id="565ee5d3831c954154cf4129999eb2ce193f0752" translate="yes" xml:space="preserve">
          <source>What follows is a detailed guide through these steps.</source>
          <target state="translated">下面是对这些步骤的详细指导。</target>
        </trans-unit>
        <trans-unit id="75d7e12868bcb8f2565578748be73375fac12333" translate="yes" xml:space="preserve">
          <source>What follows is a statement about artistic control, defined as the ability of authors of packages to guide the future of their code and maintain control over their work. It is a recognition that authors should have control over their work, and that it is a responsibility of the rest of the Perl community to ensure that they retain this control. It is an attempt to document the standards to which we, as Perl developers, intend to hold ourselves. It is an attempt to write down rough guidelines about the respect we owe each other as Perl developers.</source>
          <target state="translated">下面是关于艺术控制的声明,它被定义为包的作者指导其代码的未来和保持对其作品的控制的能力。它承认作者应该对他们的作品有控制权,而确保他们保持这种控制权是Perl社区其他成员的责任。它试图将我们作为 Perl 开发者所要达到的标准记录下来。它试图写下关于我们作为 Perl 开发者应该相互尊重的大致准则。</target>
        </trans-unit>
        <trans-unit id="374a8e110bb4c1d9c752734c71a27f6e3e497ea6" translate="yes" xml:space="preserve">
          <source>What follows is subject to change RSN.</source>
          <target state="translated">以下内容可能会有变化RSN。</target>
        </trans-unit>
        <trans-unit id="24917de591e0d7708ee26a13cd3362afc4f6c7c4" translate="yes" xml:space="preserve">
          <source>What formats output as a form feed. The default is &lt;code&gt;\f&lt;/code&gt; .</source>
          <target state="translated">什么格式输出为换页。默认值为 &lt;code&gt;\f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d479059298a571f524af929b6aea396ec65a05e6" translate="yes" xml:space="preserve">
          <source>What gets returned depends on several factors:</source>
          <target state="translated">得到的回报取决于几个因素。</target>
        </trans-unit>
        <trans-unit id="8722b12ceccd8e92d99a716a04b297746411e5f8" translate="yes" xml:space="preserve">
          <source>What good is &lt;code&gt;\G&lt;/code&gt; in a regular expression?</source>
          <target state="translated">有什么好处 &lt;code&gt;\G&lt;/code&gt; 正则表达式？</target>
        </trans-unit>
        <trans-unit id="2f0a90d9f77866c3233e1aef1cc7a9560c6ec0c3" translate="yes" xml:space="preserve">
          <source>What good is \G in a regular expression?</source>
          <target state="translated">正则表达式中的\G有什么用?</target>
        </trans-unit>
        <trans-unit id="ebf8dc71994cee4560964d904824ac92b27fed19" translate="yes" xml:space="preserve">
          <source>What happens if I add or remove keys from a hash while iterating over it?</source>
          <target state="translated">如果我在迭代哈希时从哈希中添加或删除键会发生什么?</target>
        </trans-unit>
        <trans-unit id="5b6c83c5563cf3fe722575d6dd30278f0a9d68bc" translate="yes" xml:space="preserve">
          <source>What has gone on?</source>
          <target state="translated">到底发生了什么?</target>
        </trans-unit>
        <trans-unit id="148ce7ffb164566545434b0feef660c7bee4a489" translate="yes" xml:space="preserve">
          <source>What has happened here?</source>
          <target state="translated">这里发生了什么?</target>
        </trans-unit>
        <trans-unit id="21eec199e3d296f021d3cdb05af5afb550abb23b" translate="yes" xml:space="preserve">
          <source>What has happened is that &lt;code&gt;fred&lt;/code&gt; accesses the &lt;code&gt;@_&lt;/code&gt; array which belongs to &lt;code&gt;joe&lt;/code&gt; .</source>
          <target state="translated">发生的是， &lt;code&gt;fred&lt;/code&gt; 访问了属于 &lt;code&gt;joe&lt;/code&gt; 的 &lt;code&gt;@_&lt;/code&gt; 数组。</target>
        </trans-unit>
        <trans-unit id="1061def72c9d3f6d8d9699c831f84918bba3a0be" translate="yes" xml:space="preserve">
          <source>What if I don't decode?</source>
          <target state="translated">如果我不解码呢?</target>
        </trans-unit>
        <trans-unit id="edc0c9ac4aa8c7b7a3fb61b68506b87d3c69f4bc" translate="yes" xml:space="preserve">
          <source>What if I don't encode?</source>
          <target state="translated">如果我不编码呢?</target>
        </trans-unit>
        <trans-unit id="0ddebc8779b4a58623bcc03eec19b9fd5bdcc57a" translate="yes" xml:space="preserve">
          <source>What if I don't know which encoding was used?</source>
          <target state="translated">如果我不知道使用的是哪种编码怎么办?</target>
        </trans-unit>
        <trans-unit id="b012d213b447ce5a8b3e4b308232eb1a6c342960" translate="yes" xml:space="preserve">
          <source>What if my question isn't answered in the FAQ?</source>
          <target state="translated">如果我的问题没有在FAQ中得到回答怎么办?</target>
        </trans-unit>
        <trans-unit id="30310a64f6e6f73114ef8ff5955e14d7deb5a4c5" translate="yes" xml:space="preserve">
          <source>What if the interface provided by the C callback doesn't contain a parameter which allows the file handle to Perl subroutine mapping? Say in the asynchronous i/o package, the callback function gets passed only the &lt;code&gt;buffer&lt;/code&gt; parameter like this</source>
          <target state="translated">如果C回调提供的接口不包含允许文件句柄到Perl子例程映射的参数，该怎么办？在异步I / O包中说，回调函数仅传递像这样的 &lt;code&gt;buffer&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="f9002d28fd7ee52f5e73c33c74a403efd3585ddf" translate="yes" xml:space="preserve">
          <source>What import does</source>
          <target state="translated">有什么意义?</target>
        </trans-unit>
        <trans-unit id="9281510e66c9b036bf0f2b1f98689d5dbd410309" translate="yes" xml:space="preserve">
          <source>What is &quot;the UTF8 flag&quot;?</source>
          <target state="translated">什么是 &quot;UTF8旗&quot;?</target>
        </trans-unit>
        <trans-unit id="48776d293c1cf7b50ee10897815e6e1c09782388" translate="yes" xml:space="preserve">
          <source>What is /o really for?</source>
          <target state="translated">/o到底是干什么的?</target>
        </trans-unit>
        <trans-unit id="f799c97279ef39d3426ad309ad7dfc5a7d36fff1" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;/o&lt;/code&gt; really for?</source>
          <target state="translated">什么是 &lt;code&gt;/o&lt;/code&gt; 真的？</target>
        </trans-unit>
        <trans-unit id="4da6343eb07811de611e2143a23a9e42def6f17c" translate="yes" xml:space="preserve">
          <source>What is C3?</source>
          <target state="translated">什么是C3?</target>
        </trans-unit>
        <trans-unit id="bda040c2e08659bcff6001c6dcad6149b2b71af9" translate="yes" xml:space="preserve">
          <source>What is Perl 6?</source>
          <target state="translated">什么是Perl 6?</target>
        </trans-unit>
        <trans-unit id="90e6903f9207d6b5637de9d9ec259575b1877362" translate="yes" xml:space="preserve">
          <source>What is Perl?</source>
          <target state="translated">什么是Perl?</target>
        </trans-unit>
        <trans-unit id="79dc15d896921a5be3532940c7478220c26d76f5" translate="yes" xml:space="preserve">
          <source>What is Plack and PSGI?</source>
          <target state="translated">什么是普拉克和PSGI?</target>
        </trans-unit>
        <trans-unit id="387b2d5d4628ca2a97a160cf17017d26f2363e65" translate="yes" xml:space="preserve">
          <source>What is a &quot;wide character&quot;?</source>
          <target state="translated">什么是 &quot;广字&quot;?</target>
        </trans-unit>
        <trans-unit id="6c07c0817bd40c0602c40f4eb163a577c33eb9e2" translate="yes" xml:space="preserve">
          <source>What is a 'record'? By default, the meaning is the same as for the &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; operator: It's a string terminated by &lt;code&gt;$/&lt;/code&gt; , which is probably &lt;code&gt;&quot;\n&quot;&lt;/code&gt; . (Minor exception: on DOS and Win32 systems, a 'record' is a string terminated by &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; .) You may change the definition of &quot;record&quot; by supplying the &lt;code&gt;recsep&lt;/code&gt; option in the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call:</source>
          <target state="translated">什么是&amp;ldquo;记录&amp;rdquo;？默认情况下，其含义与 &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; 运算符的含义相同：这是一个以 &lt;code&gt;$/&lt;/code&gt; 结尾的字符串，该字符串可能是 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 。（较小的例外：在DOS和Win32系统上，&amp;ldquo;记录&amp;rdquo;是以 &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; 结尾的字符串。）您可以通过在 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用中提供 &lt;code&gt;recsep&lt;/code&gt; 选项来更改&amp;ldquo;记录&amp;rdquo;的定义：</target>
        </trans-unit>
        <trans-unit id="41a841a9e9e59dbc901dca478a52731689558d70" translate="yes" xml:space="preserve">
          <source>What is a DBM Filter?</source>
          <target state="translated">什么是DBM过滤器?</target>
        </trans-unit>
        <trans-unit id="75ea94c254fb7320b80e8d79c658d169412a3588" translate="yes" xml:space="preserve">
          <source>What is a JAPH?</source>
          <target state="translated">什么是JAPH?</target>
        </trans-unit>
        <trans-unit id="8e7e75800308f6339899e8db69308ae93f0337df" translate="yes" xml:space="preserve">
          <source>What is a regular expression engine?</source>
          <target state="translated">什么是正则表达式引擎?</target>
        </trans-unit>
        <trans-unit id="e7e08c44504e895661b69ab0d094008da5741e55" translate="yes" xml:space="preserve">
          <source>What is a regular expression? A regular expression is simply a string that describes a pattern. Patterns are in common use these days; examples are the patterns typed into a search engine to find web pages and the patterns used to list files in a directory, e.g., &lt;code&gt;ls *.txt&lt;/code&gt; or &lt;code&gt;dir *.*&lt;/code&gt;. In Perl, the patterns described by regular expressions are used to search strings, extract desired parts of strings, and to do search and replace operations.</source>
          <target state="translated">什么是正则表达式？正则表达式只是描述模式的字符串。如今，模式已经很普遍了。示例包括输入搜索引擎以查找网页的模式以及用于列出目录中文件的模式，例如 &lt;code&gt;ls *.txt&lt;/code&gt; 或 &lt;code&gt;dir *.*&lt;/code&gt; 。在Perl中，用正则表达式描述的模式用于搜索字符串，提取字符串的所需部分以及进行搜索和替换操作。</target>
        </trans-unit>
        <trans-unit id="fc1f1924f0cab71521b063802ea721cd9de2bf43" translate="yes" xml:space="preserve">
          <source>What is an &quot;IV&quot;?</source>
          <target state="translated">什么是 &quot;静脉&quot;?</target>
        </trans-unit>
        <trans-unit id="8de138e681884a542d6a632e3d45af8060ecf685" translate="yes" xml:space="preserve">
          <source>What is meant here is unclear, as the &lt;code&gt;\N{...}&lt;/code&gt; escape is a sequence of code points, so this is made an error.</source>
          <target state="translated">这里的含义不清楚，因为 &lt;code&gt;\N{...}&lt;/code&gt; 转义是一系列代码点，因此这是一个错误。</target>
        </trans-unit>
        <trans-unit id="7e4d744a0a34b3ed6f2bacfcf8917df2728b341f" translate="yes" xml:space="preserve">
          <source>What is much worse, some DLLs change the floating point flags when in _DLLInitTerm() (e.g.,</source>
          <target state="translated">更糟糕的是,有些DLL在_DLLInitTerm()中改变了浮点标志(例如。</target>
        </trans-unit>
        <trans-unit id="b80f71784676643cac72b04d16a86ddd2aad93c3" translate="yes" xml:space="preserve">
          <source>What is perl.com? Perl Mongers? pm.org? perl.org? cpan.org?</source>
          <target state="translated">什么是perl.com?Perl Mongers? pm.org? perl.org? cpan.org?</target>
        </trans-unit>
        <trans-unit id="b4511cf9900e620f3e5c53ed90d05dd1b6347288" translate="yes" xml:space="preserve">
          <source>What is socket.ph and where do I get it?</source>
          <target state="translated">什么是socket.ph,我在哪里得到它?</target>
        </trans-unit>
        <trans-unit id="466ca1293cf697f510f855a869e855e56cd9f9c1" translate="yes" xml:space="preserve">
          <source>What is the difference between &quot;state&quot; subs and &quot;my&quot; subs? Each time that execution enters a block when &quot;my&quot; subs are declared, a new copy of each sub is created. &quot;State&quot; subroutines persist from one execution of the containing block to the next.</source>
          <target state="translated">&quot;状态 &quot;子和 &quot;我的 &quot;子有什么区别?当 &quot;我的 &quot;子程序被声明时,每次该执行进入一个块时,每个子程序都会创建一个新的副本。&quot;状态 &quot;子程序从包含块的一个执行到下一个执行都是持久的。</target>
        </trans-unit>
        <trans-unit id="fc949184376f42b77d53568413143ee5107891ea" translate="yes" xml:space="preserve">
          <source>What is the difference between $array[1] and @array[1]?</source>
          <target state="translated">$array[1]和@array[1]的区别是什么?</target>
        </trans-unit>
        <trans-unit id="e5e94a34863c5b06b0902ba29af6bbdd60a89b26" translate="yes" xml:space="preserve">
          <source>What is the difference between :encoding and :utf8?</source>
          <target state="translated">:编码和:utf8的区别是什么?</target>
        </trans-unit>
        <trans-unit id="87b2e888c908f6842e557ad8d646535f8dd07500" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;:encoding&lt;/code&gt; and &lt;code&gt;:utf8&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;:encoding&lt;/code&gt; 和 &lt;code&gt;:utf8&lt;/code&gt; 有什么区别？</target>
        </trans-unit>
        <trans-unit id="bdd9348a87a0e037c9116062611c030ca4d85da9" translate="yes" xml:space="preserve">
          <source>What is the difference between a list and an array?</source>
          <target state="translated">列表和数组的区别是什么?</target>
        </trans-unit>
        <trans-unit id="aa2dc660c0cced5d46caea2cf443fe5e368244c8" translate="yes" xml:space="preserve">
          <source>What is this Perl statement all about? &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; is a simple double-quoted string. &lt;code&gt;World&lt;/code&gt; is the regular expression and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regexp match and produces a true value if the regexp matched, or false if the regexp did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; , so the expression is true. Expressions like this are useful in conditionals:</source>
          <target state="translated">这个Perl声明的全部含义是什么？ &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 是一个简单的双引号字符串。 &lt;code&gt;World&lt;/code&gt; 是正则表达式， &lt;code&gt;//&lt;/code&gt; 包含的 &lt;code&gt;/World/&lt;/code&gt; 告诉Perl在字符串中搜索匹配项。运算符 &lt;code&gt;=~&lt;/code&gt; 将字符串与regexp匹配相关联，如果regexp匹配，则生成true值；如果regexp不匹配，则生成false。在我们的例子中， &lt;code&gt;World&lt;/code&gt; 与 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 中的第二个单词匹配，因此该表达式为true。这样的表达式在条件语句中很有用：</target>
        </trans-unit>
        <trans-unit id="c9fb4cb8e09b50cfb90602035114712466d59042" translate="yes" xml:space="preserve">
          <source>What is variable suicide and how can I prevent it?</source>
          <target state="translated">什么是变量自杀,如何预防?</target>
        </trans-unit>
        <trans-unit id="49ac75fc20864efd20e6c484dddbafd73db6a2e3" translate="yes" xml:space="preserve">
          <source>What is your favorite pager program?</source>
          <target state="translated">你最喜欢的寻呼机程序是什么?</target>
        </trans-unit>
        <trans-unit id="fd63f60b8b6a48f0264ba03539d262e0388b66e2" translate="yes" xml:space="preserve">
          <source>What is your favorite shell?</source>
          <target state="translated">你最喜欢的贝壳是什么?</target>
        </trans-unit>
        <trans-unit id="f41b525bca416a73d68432b879e12cd6ce5cae2d" translate="yes" xml:space="preserve">
          <source>What kind of threads are Perl threads?</source>
          <target state="translated">什么样的线程是Perl线程?</target>
        </trans-unit>
        <trans-unit id="523c42f572591f0bfb9eb624031ecf0ded9f0a2a" translate="yes" xml:space="preserve">
          <source>What library to use?</source>
          <target state="translated">用什么图书馆?</target>
        </trans-unit>
        <trans-unit id="c9dcfd1a76d749e07495e332956ce4a77d52e8a9" translate="yes" xml:space="preserve">
          <source>What machines support Perl? Where do I get it?</source>
          <target state="translated">哪些机器支持Perl?我在哪里可以得到它?</target>
        </trans-unit>
        <trans-unit id="602afa592af7887a3bffb104fc775a95a31125b0" translate="yes" xml:space="preserve">
          <source>What mailing lists are there for Perl?</source>
          <target state="translated">有哪些邮件列表适合Perl?</target>
        </trans-unit>
        <trans-unit id="4862bb3e93457f890d9e122c5362daa5b89c1284" translate="yes" xml:space="preserve">
          <source>What makes a method special is</source>
          <target state="translated">一个方法的特殊之处在于</target>
        </trans-unit>
        <trans-unit id="c65301b41224a5b616b4c8a04b46b840cdda0ef5" translate="yes" xml:space="preserve">
          <source>What makes all of this important is that the Exporter module uses glob aliasing as the import/export mechanism. Whether or not you can properly localize a variable that has been exported from a module depends on how it was exported:</source>
          <target state="translated">这一切之所以重要,是因为Exporter模块使用glob别名作为导入/导出机制。你是否能正确地本地化一个从模块中导出的变量,取决于它是如何导出的。</target>
        </trans-unit>
        <trans-unit id="8fb5a283f17d0d098d1490569f3aaeb90f52254c" translate="yes" xml:space="preserve">
          <source>What makes for a good patch?</source>
          <target state="translated">怎样才是一个好的补丁?</target>
        </trans-unit>
        <trans-unit id="486e1e8fa6072821d31ad344e76845b470464a6d" translate="yes" xml:space="preserve">
          <source>What makes this pass interesting for perl developers is that some optimization may be performed on this pass. This is optimization by so-called &quot;check routines&quot;. The correspondence between node names and corresponding check routines is described in</source>
          <target state="translated">对于perl开发者来说,这个通证的有趣之处在于,在这个通证上可能会进行一些优化。这就是所谓的 &quot;检查例程 &quot;的优化。节点名和相应的检查例程之间的对应关系在</target>
        </trans-unit>
        <trans-unit id="7c3d71cb8c06e618edc314c89194f61b595a4c29" translate="yes" xml:space="preserve">
          <source>What modules and extensions are available for Perl? What is CPAN?</source>
          <target state="translated">Perl 有哪些模块和扩展?什么是CPAN?</target>
        </trans-unit>
        <trans-unit id="709f8e1c07fc1fe28e0f229bb8ce88d468c08c8e" translate="yes" xml:space="preserve">
          <source>What modules shipped with versions of perl</source>
          <target state="translated">perl版本中包含哪些模块</target>
        </trans-unit>
        <trans-unit id="d5f3978619a4438d900606a19c92b7d1f8afc742" translate="yes" xml:space="preserve">
          <source>What regop is next?</source>
          <target state="translated">接下来是什么regop?</target>
        </trans-unit>
        <trans-unit id="88176d2562c5c584253c31b2148c8703789870d4" translate="yes" xml:space="preserve">
          <source>What seems a successful strategy is the combination of &lt;code&gt;reload
cpan&lt;/code&gt; and the debugging switches. Add a new debug statement while running in the shell and then issue a &lt;code&gt;reload cpan&lt;/code&gt; and see the new debugging messages immediately without losing the current context.</source>
          <target state="translated">成功的策略似乎是 &lt;code&gt;reload cpan&lt;/code&gt; 和调试开关的组合。在Shell中运行时添加新的调试语句，然后发出 &lt;code&gt;reload cpan&lt;/code&gt; 并立即查看新的调试消息，而不会丢失当前上下文。</target>
        </trans-unit>
        <trans-unit id="494e70de221fde56713efc23ab1ca24064c718dc" translate="yes" xml:space="preserve">
          <source>What should I make into a module?</source>
          <target state="translated">我应该做成什么模块?</target>
        </trans-unit>
        <trans-unit id="0e5fb1910c7b0867ac71d8402069e7fbfc90bc05" translate="yes" xml:space="preserve">
          <source>What some helper &lt;b&gt;process&lt;/b&gt; did to transform the incoming data into a form more suitable for the current process. Often done with an incoming &lt;b&gt;pipe&lt;/b&gt;. See also &lt;b&gt;C preprocessor&lt;/b&gt;.</source>
          <target state="translated">某些帮助&lt;b&gt;程序流程&lt;/b&gt;将传入的数据转换为更适合当前流程的形式所做的工作。通常用进&lt;b&gt;水管&lt;/b&gt;来完成。另请参见&lt;b&gt;C预处理程序&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="05edee69ab0b091485f39a349759f585c24e0340" translate="yes" xml:space="preserve">
          <source>What the program or function returns, if successful. This section can be omitted for programs whose precise exit codes aren't important, provided they return 0 on success and non-zero on failure as is standard. It should always be present for functions. For modules, it may be useful to summarize return values from the module interface here, or it may be more useful to discuss return values separately in the documentation of each function or method the module provides.</source>
          <target state="translated">如果成功,程序或函数返回什么。对于那些精确的退出代码并不重要的程序,这部分可以省略,只要它们在成功时返回0,失败时返回非零即可。对于函数来说,这部分应该始终存在。对于模块来说,在这里总结模块接口的返回值可能是有用的,或者在模块提供的每个函数或方法的文档中单独讨论返回值可能更有用。</target>
        </trans-unit>
        <trans-unit id="b11685dda194db5e13d9f10a2284151cb724112f" translate="yes" xml:space="preserve">
          <source>What this does is creates a new binary op, and feeds it a number of variables. The variables refer to the tokens: &lt;code&gt;$1&lt;/code&gt; is the first token in the input, &lt;code&gt;$2&lt;/code&gt; the second, and so on - think regular expression backreferences. &lt;code&gt;$$&lt;/code&gt; is the op returned from this reduction. So, we call &lt;code&gt;newBINOP&lt;/code&gt; to create a new binary operator. The first parameter to &lt;code&gt;newBINOP&lt;/code&gt; , a function in</source>
          <target state="translated">这样做是创建一个新的二进制op，并为其提供许多变量。变量引用标记： &lt;code&gt;$1&lt;/code&gt; 是输入中的第一个标记， &lt;code&gt;$2&lt;/code&gt; 是输入中的第二个标记，依此类推-考虑正则表达式反向引用。 &lt;code&gt;$$&lt;/code&gt; 是此减少所返回的操作。因此，我们调用 &lt;code&gt;newBINOP&lt;/code&gt; 创建一个新的二进制运算符。 &lt;code&gt;newBINOP&lt;/code&gt; 的第一个参数，是</target>
        </trans-unit>
        <trans-unit id="4cc8ecd0e95182504b6e5e23619c1654db502160" translate="yes" xml:space="preserve">
          <source>What this means is that if you have data written by Storable 1.x running on perl 5.6.0 or 5.6.1 configured with 64 bit integers on Unix or Linux then by default this Storable will refuse to read it, giving the error</source>
          <target state="translated">这意味着,如果你的数据由运行在perl 5.6.0或5.6.1上的Storable 1.x写入,并在Unix或Linux上配置了64位整数,那么默认情况下,这个Storable将拒绝读取数据,并给出错误提示</target>
        </trans-unit>
        <trans-unit id="c1074e9471d381d1e3fa377b4baeab5a37484773" translate="yes" xml:space="preserve">
          <source>What this means is that unless the &lt;code&gt;/a&lt;/code&gt; modifier is in effect &lt;code&gt;\d&lt;/code&gt; not only matches the digits '0' - '9', but also Arabic, Devanagari, and digits from other languages. This may cause some confusion, and some security issues.</source>
          <target state="translated">这意味着除非 &lt;code&gt;/a&lt;/code&gt; 修饰符有效，否则 &lt;code&gt;\d&lt;/code&gt; 不仅与数字'0'-'9'匹配，而且还与阿拉伯语，梵文和其他语言的数字匹配。这可能会引起一些混乱和一些安全问题。</target>
        </trans-unit>
        <trans-unit id="b90ef1b55a5f8c0ad6415f98413e6a092c07a530" translate="yes" xml:space="preserve">
          <source>What to put after &quot;1/crontab&quot; in the URL. This option is not set by default.</source>
          <target state="translated">在URL中的 &quot;1/crontab &quot;后面放什么。这个选项默认不设置。</target>
        </trans-unit>
        <trans-unit id="616a4166af25f3f615ff259d316398355eca1fd7" translate="yes" xml:space="preserve">
          <source>What to put after &quot;Foo%3a%3aBar&quot; in the URL. This option is not set by default.</source>
          <target state="translated">在URL中的 &quot;Foo%3a%3aBar &quot;后面放什么。这个选项默认不设置。</target>
        </trans-unit>
        <trans-unit id="774021bac19bdf5e083a7ddf41b218a869e89eea" translate="yes" xml:space="preserve">
          <source>What to put before and after the title in the head. The values should already be &amp;amp;-escaped.</source>
          <target state="translated">标题之前和之后的内容。值应已＆换码。</target>
        </trans-unit>
        <trans-unit id="46d727439e117340febafb43135cffaac5ab87fa" translate="yes" xml:space="preserve">
          <source>What utilities shipped with versions of perl</source>
          <target state="translated">哪些实用程序随perl的版本一起发布?</target>
        </trans-unit>
        <trans-unit id="79f6137e22ba58dcead1d29483955dc880eaf485" translate="yes" xml:space="preserve">
          <source>What was in this chunk of memory? Numbers, characters, or a mixture of both? Assuming that we're on a computer where ASCII (or some similar) encoding is used: hexadecimal values in the range &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; indicate an uppercase letter, and &lt;code&gt;0x20&lt;/code&gt; encodes a space. So we might assume it is a piece of text, which some are able to read like a tabloid; but others will have to get hold of an ASCII table and relive that firstgrader feeling. Not caring too much about which way to read this, we note that &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the template code &lt;code&gt;H&lt;/code&gt; converts the contents of a sequence of bytes into the customary hexadecimal notation. Since &quot;a sequence of&quot; is a pretty vague indication of quantity, &lt;code&gt;H&lt;/code&gt; has been defined to convert just a single hexadecimal digit unless it is followed by a repeat count. An asterisk for the repeat count means to use whatever remains.</source>
          <target state="translated">这块内存是什么？数字，字符还是两者的混合？假设我们其中ASCII（或一些类似的）编码用于在计算机上：十六进制值的范围在 &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; 指示大写字母，和 &lt;code&gt;0x20&lt;/code&gt; 的编码的空间。因此，我们可以假设它是一段文本，有些文本可以像小报一样阅读。但其他人则必须掌握ASCII表并重温这种firstgrader的感觉。我们不太在乎读取哪种方式，我们注意到用模板代码 &lt;code&gt;H&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 会将字节序列的内容转换为惯用的十六进制表示法。由于&amp;ldquo;序列的&amp;rdquo;是数量的模糊表示，因此 &lt;code&gt;H&lt;/code&gt; 已定义为仅转换一个十六进制数字，除非其后跟随重复计数。重复计数的星号表示要使用剩余的任何东西。</target>
        </trans-unit>
        <trans-unit id="16a26aa5328e43e90f045fe86149fb674a158916" translate="yes" xml:space="preserve">
          <source>What we actually need to do is expand the width of the fields. The &lt;code&gt;A&lt;/code&gt; format pads any non-existent characters with spaces, so we can use the additional spaces to line up our fields, like this:</source>
          <target state="translated">我们实际上需要做的是扩大字段的宽度。在 &lt;code&gt;A&lt;/code&gt; 格式垫任何不存在的字符空格，所以我们可以使用额外的空间来排队我们的田野，就像这样：</target>
        </trans-unit>
        <trans-unit id="0c37b176ea3009646e0be80ec6a53f25b8ff9dcd" translate="yes" xml:space="preserve">
          <source>What we have described so far is the single form of the &lt;code&gt;\p{...}&lt;/code&gt; character classes. There is also a compound form which you may run into. These look like &lt;code&gt;\p{name=value}&lt;/code&gt; or &lt;code&gt;\p{name:value}&lt;/code&gt; (the equals sign and colon can be used interchangeably). These are more general than the single form, and in fact most of the single forms are just Perl-defined shortcuts for common compound forms. For example, the script examples in the previous paragraph could be written equivalently as &lt;code&gt;\p{Script=Latin}&lt;/code&gt; , &lt;code&gt;\p{Script:Greek}&lt;/code&gt; , &lt;code&gt;\p{script=katakana}&lt;/code&gt; , and &lt;code&gt;\P{script=balinese}&lt;/code&gt; (case is irrelevant between the &lt;code&gt;{}&lt;/code&gt; braces). You may never have to use the compound forms, but sometimes it is necessary, and their use can make your code easier to understand.</source>
          <target state="translated">到目前为止，我们已经描述的是 &lt;code&gt;\p{...}&lt;/code&gt; 字符类的单一形式。您可能还会遇到一种复合形式。它们看起来像 &lt;code&gt;\p{name=value}&lt;/code&gt; 或 &lt;code&gt;\p{name:value}&lt;/code&gt; （等号和冒号可以互换使用）。它们比单一形式更通用，实际上，大多数单一形式只是Perl定义的常见复合形式的快捷方式。例如，上一段中的脚本示例可以等效地写为 &lt;code&gt;\p{Script=Latin}&lt;/code&gt; ， &lt;code&gt;\p{Script:Greek}&lt;/code&gt; ， &lt;code&gt;\p{script=katakana}&lt;/code&gt; 和 &lt;code&gt;\P{script=balinese}&lt;/code&gt; （大小写为与 &lt;code&gt;{}&lt;/code&gt; 之间无关大括号）。您可能永远不必使用复合形式，但有时是必须的，它们的使用可以使您的代码更易于理解。</target>
        </trans-unit>
        <trans-unit id="3384939add5296135f386c16a3d5a3c4d7477676" translate="yes" xml:space="preserve">
          <source>What you are told when someone thinks you should Read The Fine Manual.</source>
          <target state="translated">当有人认为你应该阅读《精美手册》时,会告诉你什么。</target>
        </trans-unit>
        <trans-unit id="5da1aaeac7913632bcb1c91e0e40a9b8f5b306d1" translate="yes" xml:space="preserve">
          <source>What you can do is calculate the MD5 checksum of the UTF-8 representation of such strings. This is achieved by filtering the string through encode_utf8() function:</source>
          <target state="translated">你可以做的是计算这种字符串的UTF-8表示的MD5校验和。这是通过 encode_utf8()函数对字符串进行过滤来实现的。</target>
        </trans-unit>
        <trans-unit id="bdac7845b72b0a0aaba866c488e59de83492ce2f" translate="yes" xml:space="preserve">
          <source>What you get from your ancestors, genetically or otherwise. If you happen to be a &lt;b&gt;class&lt;/b&gt;, your ancestors are called &lt;b&gt;base classes&lt;/b&gt; and your descendants are called &lt;b&gt;derived classes&lt;/b&gt;. See &lt;b&gt;single inheritance&lt;/b&gt; and &lt;b&gt;multiple inheritance&lt;/b&gt;.</source>
          <target state="translated">从遗传学或其他方面从祖先那里获得的收益。如果您碰巧是一个&lt;b&gt;类&lt;/b&gt;，那么您的祖先将被称为&lt;b&gt;基类，&lt;/b&gt;而您的后代将被称为&lt;b&gt;派生类&lt;/b&gt;。请参阅&lt;b&gt;单继承&lt;/b&gt;和&lt;b&gt;多继承&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2c06f68d01c975c0659982cd1d1ea555fe3696b9" translate="yes" xml:space="preserve">
          <source>What you get when you do &lt;code&gt;Perl++&lt;/code&gt; twice. Doing it only once will curl your hair. You have to increment it eight times to shampoo your hair. Lather, rinse, iterate.</source>
          <target state="translated">两次执行 &lt;code&gt;Perl++&lt;/code&gt; 会得到什么。只做一次会卷曲你的头发。您必须将其增加八倍才能洗头。泡沫，冲洗，反复。</target>
        </trans-unit>
        <trans-unit id="d8dd19339629eae0964d65277b9af39d2d940ac8" translate="yes" xml:space="preserve">
          <source>What you probably want instead is this:</source>
          <target state="translated">你可能想要的是这个。</target>
        </trans-unit>
        <trans-unit id="b04bf6a0eeeb74b4ebb74c0ffdfd7f57764ab34f" translate="yes" xml:space="preserve">
          <source>What you want to use instead is:</source>
          <target state="translated">你要用的是:</target>
        </trans-unit>
        <trans-unit id="f3ca9a26fe44a59f17183be2ef23ecb124cf272f" translate="yes" xml:space="preserve">
          <source>What's MakeMaker?</source>
          <target state="translated">什么是MakeMaker?</target>
        </trans-unit>
        <trans-unit id="42464d9de4a99557d583081f2fb3c257e19a8cfc" translate="yes" xml:space="preserve">
          <source>What's Really Stored in an SV?</source>
          <target state="translated">SV中到底存储了什么?</target>
        </trans-unit>
        <trans-unit id="8f84a94f1018dae65b2467147ba94f01d14ea50b" translate="yes" xml:space="preserve">
          <source>What's a closure?</source>
          <target state="translated">什么是封闭?</target>
        </trans-unit>
        <trans-unit id="a80aec1f19639cbbb28c71d9ddfac9f28b371cff" translate="yes" xml:space="preserve">
          <source>What's an extension?</source>
          <target state="translated">什么是扩展?</target>
        </trans-unit>
        <trans-unit id="96c69ba1e09918b49d4e34120c9bbb2d0968449e" translate="yes" xml:space="preserve">
          <source>What's in Plan 9 Perl</source>
          <target state="translated">Plan 9 Perl中的内容</target>
        </trans-unit>
        <trans-unit id="e9c4131b2629bb86dafeed8bcd2c9f6a25583f3a" translate="yes" xml:space="preserve">
          <source>What's in a name?</source>
          <target state="translated">名字里有什么?</target>
        </trans-unit>
        <trans-unit id="5131dc0eec6cff59e581098235ddc4625176b69a" translate="yes" xml:space="preserve">
          <source>What's new here?</source>
          <target state="translated">这里有什么新鲜事?</target>
        </trans-unit>
        <trans-unit id="22ab29c1c9e23b6be4d152ca0fbe8d1fd5003e73" translate="yes" xml:space="preserve">
          <source>What's not in Plan 9 Perl</source>
          <target state="translated">Plan 9 Perl中没有的内容</target>
        </trans-unit>
        <trans-unit id="5d2b08ade1fd6cb20cb499440eecabb1a859edc0" translate="yes" xml:space="preserve">
          <source>What's that &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;? Well, the arguments to a subroutine are available to us as a special array called &lt;code&gt;@_&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more on that). The default argument to the &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; function just happens to be &lt;code&gt;@_&lt;/code&gt; . So &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $logmessage = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; shifts the first item off the list of arguments and assigns it to &lt;code&gt;$logmessage&lt;/code&gt; .</source>
          <target state="translated">那是什么 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; ？好吧，子例程的参数可以作为称为 &lt;code&gt;@_&lt;/code&gt; 的特殊数组提供给我们（有关更多信息，请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;）。 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 函数的默认参数恰好是 &lt;code&gt;@_&lt;/code&gt; 。所以 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $logmessage = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; 将第一项移出参数列表，并将其分配给 &lt;code&gt;$logmessage&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46db4fba6102cb384fdb3af284b14f9799d7a634" translate="yes" xml:space="preserve">
          <source>What's the difference between &quot;delete&quot; and &quot;undef&quot; with hashes?</source>
          <target state="translated">&quot;删除 &quot;和 &quot;undef &quot;与哈希有什么区别?</target>
        </trans-unit>
        <trans-unit id="efcfc0c915c5ced8aa18fe665d7a6bf921317ac3" translate="yes" xml:space="preserve">
          <source>What's the difference between &quot;perl&quot; and &quot;Perl&quot;?</source>
          <target state="translated">&quot;perl &quot;和 &quot;Perl &quot;有什么区别?</target>
        </trans-unit>
        <trans-unit id="63f076d778aa21d0e84626f4c5e0c5b8d663503c" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;UTF-8&lt;/code&gt; and &lt;code&gt;utf8&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;UTF-8&lt;/code&gt; 和 &lt;code&gt;utf8&lt;/code&gt; 有什么区别？</target>
        </trans-unit>
        <trans-unit id="9c1cf1781cda10277aefd4a7483c6c07d76809d8" translate="yes" xml:space="preserve">
          <source>What's the difference between UTF-8 and utf8?</source>
          <target state="translated">UTF-8和utf8有什么区别?</target>
        </trans-unit>
        <trans-unit id="1a32eae97c19fcd8cd7ae50ba5b1fb91847cfda9" translate="yes" xml:space="preserve">
          <source>What's the difference between calling a function as &amp;amp;foo and foo()?</source>
          <target state="translated">将函数调用为＆foo和foo（）有什么区别？</target>
        </trans-unit>
        <trans-unit id="def2247288e4f5204ba55472b4461e996492e2e7" translate="yes" xml:space="preserve">
          <source>What's the difference between deep and shallow binding?</source>
          <target state="translated">深装和浅装有什么区别?</target>
        </trans-unit>
        <trans-unit id="95fdb9749f45655e65a25dc015c0a84e8ebabe59" translate="yes" xml:space="preserve">
          <source>What's the difference between dynamic and lexical (static) scoping? Between local() and my()?</source>
          <target state="translated">动态和词法(静态)作用域之间的区别是什么?local()和my()之间的区别?</target>
        </trans-unit>
        <trans-unit id="83bcf34d32fd45bb7e4990d1041e30347690cdee" translate="yes" xml:space="preserve">
          <source>What's the difference between require and use?</source>
          <target state="translated">要求和使用之间有什么区别?</target>
        </trans-unit>
        <trans-unit id="e20e3ec3698a540277cd6005030f3f2eae027cdc" translate="yes" xml:space="preserve">
          <source>What's wrong with *-w* and $^W</source>
          <target state="translated">*-w*和$^W有什么问题?</target>
        </trans-unit>
        <trans-unit id="d8abb891068053380c8e2c57ccfc03bd7f1c3bec" translate="yes" xml:space="preserve">
          <source>What's wrong with &lt;b&gt;-w&lt;/b&gt; and &lt;code&gt;$^W&lt;/code&gt;</source>
          <target state="translated">&lt;b&gt;-w&lt;/b&gt;和 &lt;code&gt;$^W&lt;/code&gt; 有什么问题</target>
        </trans-unit>
        <trans-unit id="86c8915176784b924b124a7df71bcedbc4d5aeac" translate="yes" xml:space="preserve">
          <source>What's wrong with always quoting &quot;$vars&quot;?</source>
          <target state="translated">总是引用&quot;$vars &quot;有什么问题?</target>
        </trans-unit>
        <trans-unit id="a6b6f35263a6c409ef4d9ea90bf4d23520808808" translate="yes" xml:space="preserve">
          <source>What's wrong with using backticks in a void context?</source>
          <target state="translated">在虚空语境中使用背标有什么问题?</target>
        </trans-unit>
        <trans-unit id="15b450eb4383c04ae9890e63ad467617d37b687c" translate="yes" xml:space="preserve">
          <source>What's wrong with using grep in a void context?</source>
          <target state="translated">在void上下文中使用grep有什么问题?</target>
        </trans-unit>
        <trans-unit id="48dabfbbabfdd23fd6a91f1e79b5b5393e8fc727" translate="yes" xml:space="preserve">
          <source>What's wrong?</source>
          <target state="translated">怎么了?</target>
        </trans-unit>
        <trans-unit id="81f7ea2721e1db165495605d1bf1128fca1fe7a9" translate="yes" xml:space="preserve">
          <source>Whatever a reference refers to, which may or may not have a name. Common types of referents include scalars, arrays, hashes, and subroutines.</source>
          <target state="translated">无论引用指的是什么,它都可以有名字,也可以没有名字。常见的引用类型包括标量、数组、哈希和子程序。</target>
        </trans-unit>
        <trans-unit id="088ce6907b9c85d16edc0ae58b2aca12ddc17aac" translate="yes" xml:space="preserve">
          <source>Whatever happens in the RE engine might be better discussed in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;, but for the sake of continuity, we shall do so here.</source>
          <target state="translated">RE引擎中发生的任何事情都可能会在&lt;a href=&quot;perlre&quot;&gt;Perlre中&lt;/a&gt;进行更好的讨论，但是出于连续性考虑，我们将在此处进行讨论。</target>
        </trans-unit>
        <trans-unit id="f153d99158c54cb43c1d3fc8596ddbfe423f08fe" translate="yes" xml:space="preserve">
          <source>Whatever you want to do with a reference, &lt;b&gt;Use Rule 1&lt;/b&gt; tells you how to do it. You just write the Perl code that you would have written for doing the same thing to a regular array or hash, and then replace the array or hash name with &lt;code&gt;{$reference}&lt;/code&gt; . &quot;How do I loop over an array when all I have is a reference?&quot; Well, to loop over an array, you would write</source>
          <target state="translated">无论您想对参考进行什么操作，&lt;b&gt;使用规则1都会&lt;/b&gt;告诉您如何做。您只需将为完成相同操作而编写的Perl代码写入常规数组或哈希，然后将数组或哈希名称替换为 &lt;code&gt;{$reference}&lt;/code&gt; 。&amp;ldquo;当我只有引用时，如何遍历数组？&amp;rdquo; 好吧，要遍历数组，您可以编写</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="7ae3880ea71f58f5dbf3834e6e0d70053eb70246" translate="yes" xml:space="preserve">
          <source>When &quot;&lt;code&gt;::&lt;/code&gt; &quot; is not in the name, &quot;&lt;code&gt;Encode::&lt;/code&gt; &quot; is assumed.</source>
          <target state="translated">当&amp;ldquo; &lt;code&gt;::&lt;/code&gt; &amp;rdquo;的名称不是&amp;ldquo; &lt;code&gt;Encode::&lt;/code&gt; &amp;rdquo;假设。</target>
        </trans-unit>
        <trans-unit id="a89c66deca9575739eac57be484648de00b11290" translate="yes" xml:space="preserve">
          <source>When $data is present, sets the instance data to $data and returns the object itself. Otherwise, the current instance data is returned.</source>
          <target state="translated">当$data存在时,将实例数据设置为$data,并返回对象本身。否则,将返回当前的实例数据。</target>
        </trans-unit>
        <trans-unit id="5ea5db67e72bdcabd78dcc6373fac87d452cfae7" translate="yes" xml:space="preserve">
          <source>When $encoding is omitted, it defaults to utf8 if $data is already in utf8 or &quot;&quot; (empty string) otherwise.</source>
          <target state="translated">当省略$encoding时,如果$data已经是utf8或&quot;&quot;,则默认为utf8。(空字符串),否则。</target>
        </trans-unit>
        <trans-unit id="3a255f10977ad0e9fd4eef99c75ca5b6bedb2369" translate="yes" xml:space="preserve">
          <source>When $encoding is present, sets the instance encoding to $encoding and returns the object itself. Otherwise, the current instance encoding is returned.</source>
          <target state="translated">当存在$encoding时,将实例编码设置为$encoding并返回对象本身。否则,返回当前的实例编码。</target>
        </trans-unit>
        <trans-unit id="c1731c29e738a553728a82585755466ae75d0743" translate="yes" xml:space="preserve">
          <source>When $walker is called, it traverses the subroutines supplied when it was created, and renders them using the current style. You can change the style afterwards in several different ways:</source>
          <target state="translated">当调用$walker时,它会遍历创建它时提供的子程序,并使用当前的样式来渲染它们。你可以在之后用几种不同的方式改变风格。</target>
        </trans-unit>
        <trans-unit id="34501938bea4725e00e5d23af26af9e9de4937a2" translate="yes" xml:space="preserve">
          <source>When 'make clean' or similar is run, the $(FIRST_MAKEFILE) will be backed up at this location.</source>
          <target state="translated">当运行'make clean'或类似的程序时,$(FIRST_MAKEFILE)将在这个位置进行备份。</target>
        </trans-unit>
        <trans-unit id="9a46234156e6749e9bc38b78f59bb3969925d8bf" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;--compat-version&lt;/b&gt; (&lt;b&gt;-b&lt;/b&gt;) is present the generated tests will use &lt;code&gt;Test::More&lt;/code&gt; rather than &lt;code&gt;Test&lt;/code&gt; which is the default for versions before 5.6.2. &lt;code&gt;Test::More&lt;/code&gt; will be added to PREREQ_PM in the generated &lt;code&gt;Makefile.PL&lt;/code&gt; .</source>
          <target state="translated">当出现&lt;b&gt;--compat-version&lt;/b&gt;（&lt;b&gt;-b&lt;/b&gt;）时，生成的测试将使用 &lt;code&gt;Test::More&lt;/code&gt; 而不是 &lt;code&gt;Test&lt;/code&gt; ，这是5.6.2之前版本的默认设置。 &lt;code&gt;Test::More&lt;/code&gt; 将添加到生成的 &lt;code&gt;Makefile.PL&lt;/code&gt; 中的 PREREQ_PM中。</target>
        </trans-unit>
        <trans-unit id="98323433c84745d96d2f69c24c5375707e53e818" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, when &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">当 &lt;code&gt;$/&lt;/code&gt; 设置为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 时，当 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 在标量上下文中（即，文件slurp模式），并且在读取空文件时，它第一次返回 &lt;code&gt;''&lt;/code&gt; ，随后是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7865066f4690dc076b5908415bb1b4ea7d2066d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, when &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">当 &lt;code&gt;$/&lt;/code&gt; 设置为 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 时，当 &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 在标量上下文中（即，文件slurp模式），并且在读取空文件时，它第一次返回 &lt;code&gt;''&lt;/code&gt; ，随后是 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75765cbe47d6e2730ecd17d719657c6826993abb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple compressed files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer, after uncompression &lt;code&gt;$output_filename_or_reference&lt;/code&gt; will contain a concatenation of all the uncompressed data from each of the input files/buffers.</source>
          <target state="translated">当 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 映射到多个压缩文件/缓冲区并且 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是单个文件/缓冲区时，解压缩后 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 将包含来自每个输入文件/缓冲区的所有未压缩数据的串联。</target>
        </trans-unit>
        <trans-unit id="ead5ec1ebcf9002ff366c3f4b5ecf105bcef3b1c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer the input files/buffers will be stored in &lt;code&gt;$output_filename_or_reference&lt;/code&gt; as a concatenated series of compressed data streams.</source>
          <target state="translated">当 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 映射到多个文件/缓冲区，而 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是单个文件/缓冲区时，输入文件/缓冲区将作为一系列压缩数据流串联存储在 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="42c11e18ef09b7c84100ba9f7d909d637366a78e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer the input files/buffers will each be stored in &lt;code&gt;$output_filename_or_reference&lt;/code&gt; as a distinct entry.</source>
          <target state="translated">当 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 映射到多个文件/缓冲区，并且 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是单个文件/缓冲区时，输入文件/缓冲区将分别作为一个单独的条目存储在 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="161359b9eacea931dac1aa6e52278dc1eae64067" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is an fileglob string, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; must also be a fileglob string. Anything else is an error.</source>
          <target state="translated">当 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是fileglob字符串时， &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 也必须是fileglob字符串。其他所有都是错误。</target>
        </trans-unit>
        <trans-unit id="2506bf0aaa0a66933521706c1367d6dcef56da1b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, these options will be completely ignored. See &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;${^UNICODE} in perlvar&lt;/a&gt; and &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C in perlrun&lt;/a&gt; for details.</source>
          <target state="translated">当 &lt;code&gt;${^UNICODE}&lt;/code&gt; （从v5.8.2开始可用）存在且不为零时，这些选项将被完全忽略。有关详细信息，请参见&lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;perlvar中的$ {^ UNICODE}&lt;/a&gt;和&lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;perlrun&lt;/a&gt;中的-C。</target>
        </trans-unit>
        <trans-unit id="b7dd1602a2fa020d33fb149e95e48b61aba92e31" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; and &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt; for details.</source>
          <target state="translated">当shell间接执行 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 的参数时，结果和返回码将受其怪癖的影响。有关详细信息，请参见&lt;a href=&quot;perlop#%60STRING%60&quot;&gt;perlop&lt;/a&gt;和&lt;a href=&quot;#exec&quot;&gt;exec中的&lt;/a&gt;`STRING`。</target>
        </trans-unit>
        <trans-unit id="ce37de4fd1569bb63f53c7c4c16cdb716157400b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (but not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; （但不 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ）有效时， &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; LIST根据当前的整理语言环境对 LIST进行排序。参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4b89dec84fb05fc282a0e80acf7739b8c5833a7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/flags'&lt;/code&gt; is specified, the given flags are automatically added to every regular expression till the end of the lexical scope.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/flags'&lt;/code&gt; 被指定时，给定的标志被自动添加到每一个正则表达式，直到词法作用域的末尾。</target>
        </trans-unit>
        <trans-unit id="826f4d022e4908a4bde930341263c135e67935f4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; is in effect, perl emits debugging messages when compiling and using regular expressions. The output is the same as that obtained by running a &lt;code&gt;-DDEBUGGING&lt;/code&gt; -enabled perl interpreter with the &lt;b&gt;-Dr&lt;/b&gt; switch. It may be quite voluminous depending on the complexity of the match. Using &lt;code&gt;debugcolor&lt;/code&gt; instead of &lt;code&gt;debug&lt;/code&gt; enables a form of output that can be used to get a colorful display on terminals that understand termcap color sequences. Set &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; to a comma-separated list of &lt;code&gt;termcap&lt;/code&gt; properties to use for highlighting strings on/off, pre-point part on/off. See &lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;Debugging Regular Expressions in perldebug&lt;/a&gt; for additional info.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; 有效时，perl在编译和使用正则表达式时会发出调试消息。输出与通过&lt;b&gt;-Dr&lt;/b&gt;开关运行启用 &lt;code&gt;-DDEBUGGING&lt;/code&gt; 的 perl解释器获得的输出相同。根据比赛的复杂程度，可能会非常庞大​​。使用 &lt;code&gt;debugcolor&lt;/code&gt; 代替 &lt;code&gt;debug&lt;/code&gt; 启用一种输出形式，该输出形式可用于在了解termcap颜色序列的终端上获得彩色显示。将 &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; 设置为 &lt;code&gt;termcap&lt;/code&gt; 属性的逗号分隔列表，以用于高亮显示字符串的开/关，指示部分的开/关。请参见&lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;在perldebug中调试正则表达式&lt;/a&gt;&lt;b&gt;&lt;/b&gt; 有关其他信息。</target>
        </trans-unit>
        <trans-unit id="6c428ad9961e409888285c5019a1884325617653" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; is in effect, a regexp is allowed to contain &lt;code&gt;(?{ ... })&lt;/code&gt; zero-width assertions and &lt;code&gt;(??{ ... })&lt;/code&gt; postponed subexpressions that are derived from variable interpolation, rather than appearing literally within the regexp. That is normally disallowed, since it is a potential security risk. Note that this pragma is ignored when the regular expression is obtained from tainted data, i.e. evaluation is always disallowed with tainted regular expressions. See &lt;a href=&quot;perlre#(%3f%7b-code-%7d)&quot;&gt;(?{ code }) in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#(%3f%3f%7b-code-%7d)&quot;&gt;(??{ code }) in perlre&lt;/a&gt;.</source>
          <target state="translated">有效 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; 正则表达式允许包含 &lt;code&gt;(?{ ... })&lt;/code&gt; 零宽度断言和 &lt;code&gt;(??{ ... })&lt;/code&gt; 从变量插值派生的延迟子表达式，而不是出现从字面上来看正则表达式。由于存在潜在的安全风险，因此通常不允许这样做。请注意，当从受污染的数据中获取正则表达式时，将忽略该杂项，即，始终禁止使用受污染的正则表达式进行评估。见&lt;a href=&quot;perlre#(%3f%7b-code-%7d)&quot;&gt;（{代码}）在perlre&lt;/a&gt;和&lt;a href=&quot;perlre#(%3f%3f%7b-code-%7d)&quot;&gt;（?? {代码}）在perlre&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c489bf5f6075f7a85a4147bc159e1965fa8ad2cd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; is in effect, stricter checks are applied than otherwise when compiling regular expressions patterns. These may cause more warnings to be raised than otherwise, and more things to be fatal instead of just warnings. The purpose of this is to find and report at compile time some things, which may be legal, but have a reasonable possibility of not being the programmer's actual intent. This automatically turns on the &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; warnings category (if not already on) within its scope.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; 生效时，与编译正则表达式模式时相比，将应用更严格的检查。这些可能导致发出更多警告，而不是其他警告，并且导致更多致命的事情。这样做的目的是在编译时查找并报告一些可能合法的东西，但是有可能不是程序员的实际意图。这会自动在其范围内打开 &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; 警告类别（如果尚未启用）。</target>
        </trans-unit>
        <trans-unit id="057f6216fa3faf81b159095b26d348ad7b06bd25" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'taint'&lt;/code&gt; is in effect, and a tainted string is the target of a regexp, the regexp memories (or values returned by the m// operator in list context) are tainted. This feature is useful when regexp operations on tainted data aren't meant to extract safe substrings, but to perform other transformations.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'taint'&lt;/code&gt; 有效时，且受污染的字符串是正则表达式的目标时，则将正则表达式内存（或m //运算符在列表上下文中返回的值）污染。当对受污染的数据进行正则表达式操作不是要提取安全子字符串，而是要执行其他转换时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="d35b2d737154679691874d190272f87d34f67d6b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; and &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; for details.</source>
          <target state="translated">当shell间接执行 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 的参数时，结果和返回码将受其怪癖的影响。有关详细信息，请参见&lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;perlop&lt;/a&gt;和&lt;a href=&quot;exec&quot;&gt;exec中的&lt;/a&gt;`STRING`。</target>
        </trans-unit>
        <trans-unit id="d249161b8d76a85447f9bcf8c19ecaa9c4041708" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (but not &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect, &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; （但不 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ）有效时， &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; LIST根据当前的整理语言环境对 LIST进行排序。参见&lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9cb0ac41f5c76b7790f54d079dd94b8ce0665510" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Append&lt;/code&gt; is specified, and set to true, it will</source>
          <target state="translated">当指定了 &lt;code&gt;Append&lt;/code&gt; 并将其设置为true时，它将</target>
        </trans-unit>
        <trans-unit id="74620e73df76b9793a4b5915498c084620ae1197" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutout&lt;/code&gt; is not specified &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; will use as much memory as it takes to write all the uncompressed data it creates by uncompressing the input buffer.</source>
          <target state="translated">当 &lt;code&gt;LimitOutout&lt;/code&gt; 没有指定 &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; 将尽可能多的内存，因为它需要所有通过解压缩的输入缓冲区写入其创建的未压缩数据使用。</target>
        </trans-unit>
        <trans-unit id="476db1003af9ea2b2d5dff0b4d9aae2335796a1b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutout&lt;/code&gt; is not specified &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; will use as much memory as it takes to write all the uncompressed data it creates by uncompressing the input buffer.</source>
          <target state="translated">当未指定 &lt;code&gt;LimitOutout&lt;/code&gt; 时, &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; inflate将使用尽可能多的内存来写入通过解压缩输入缓冲区而创建的所有未压缩数据。</target>
        </trans-unit>
        <trans-unit id="3a29eb1b7605b447e178aa583e1e3d0b18b3e32a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the 16k or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt; , whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="translated">当使用 &lt;code&gt;LimitOutput&lt;/code&gt; 时，使用的输出缓冲区的大小将为16k或已分配给 &lt;code&gt;$output&lt;/code&gt; 的内存量，以较大者为准。预测可用的输出大小非常棘手，因此不要依赖于获取确切的输出缓冲区大小。</target>
        </trans-unit>
        <trans-unit id="6884e67243b247f9f83c1056f56446e2954b8717" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the value of the &lt;code&gt;Bufsize&lt;/code&gt; option or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt; , whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="translated">当使用 &lt;code&gt;LimitOutput&lt;/code&gt; 时，使用的输出缓冲区的大小将为 &lt;code&gt;Bufsize&lt;/code&gt; 选项的值或已分配给 &lt;code&gt;$output&lt;/code&gt; 的内存量（以较大者为准）。预测可用的输出大小非常棘手，因此不要依赖于获取确切的输出缓冲区大小。</target>
        </trans-unit>
        <trans-unit id="f6c4b51758778b88a3620755cd86e2bac9c6c0e5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; is active (see &lt;a href=&quot;#%24%3f&quot;&gt;$?&lt;/a&gt; below), the native VMS exit status value will have either one of the &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$^E&lt;/code&gt; or the Unix value 255 encoded into it in a way that the effective original value can be decoded by other programs written in C, including Perl and the GNV package. As per the normal non-VMS behavior of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; if either &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; are non-zero, one of those values will be encoded into a native VMS status value. If both of the Unix status values are 0, and the &lt;code&gt;$^E&lt;/code&gt; value is set one of ERROR or SEVERE_ERROR severity, then the &lt;code&gt;$^E&lt;/code&gt; value will be used as the exit code as is. If none of the above apply, the Unix value of 255 will be encoded into a native VMS exit status value.</source>
          <target state="translated">当 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 处于活动状态时（请参见下面的&lt;a href=&quot;#%24%3f&quot;&gt;$？&lt;/a&gt;），本机VMS退出状态值将具有 &lt;code&gt;$!&lt;/code&gt; 或 &lt;code&gt;$?&lt;/code&gt; 或 &lt;code&gt;$^E&lt;/code&gt; 或其中编码的Unix值255，以便有效的原始值可以用用C编写的其他程序（包括Perl和GNV包）进行解码。按照正常的非VMS行为，如果 &lt;code&gt;$!&lt;/code&gt; 要么 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ！或 &lt;code&gt;$?&lt;/code&gt; 如果为非零值，则这些值之一将被编码为本地VMS状态值。如果两个Unix状态值都为0，并且 &lt;code&gt;$^E&lt;/code&gt; 值设置为ERROR或SEVERE_ERROR严重性之一，则 &lt;code&gt;$^E&lt;/code&gt; 值将直接用作退出代码。如果上述都不适用，则Unix值255将被编码为本地VMS退出状态值。</target>
        </trans-unit>
        <trans-unit id="edf0ae2377a2b22abb92a09c7cbee6dad38f469d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;S&lt;/code&gt; can match, it is a better match than when only &lt;code&gt;T&lt;/code&gt; can match.</source>
          <target state="translated">当 &lt;code&gt;S&lt;/code&gt; 可以匹配时，比仅 &lt;code&gt;T&lt;/code&gt; 可以匹配时更好。</target>
        </trans-unit>
        <trans-unit id="5e7bb6aa4bca28bb16c16381fd1ea0fe317f098c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Strict&lt;/code&gt; is disabled the following behaviour will be policed:</source>
          <target state="translated">当 &lt;code&gt;Strict&lt;/code&gt; 禁止以下行为将进行监管：</target>
        </trans-unit>
        <trans-unit id="792e600779793d69f3a4dfa3dfa3dd30d40ce8a4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt;= 22, the weights of out-of-range values can be overridden. Though &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; are available for them, out-of-range values are too many.</source>
          <target state="translated">当 &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; = 22时，超出范围值的权重可以被覆盖。尽管可以使用 &lt;code&gt;table&lt;/code&gt; 或 &lt;code&gt;entry&lt;/code&gt; ，但超出范围的值太多。</target>
        </trans-unit>
        <trans-unit id="a88bdc0c0c759d08c6275afc07854842d8f95efa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;base&lt;/code&gt; tries to &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module, it will not die if it cannot find the module's file, but will die on any other error. After all this, should your base class be empty, containing no symbols, &lt;code&gt;base&lt;/code&gt; will die. This is useful for inheriting from classes in the same file as yourself but where the filename does not match the base module name, like so:</source>
          <target state="translated">当 &lt;code&gt;base&lt;/code&gt; 试图 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 一个模块时，如果找不到模块的文件，它将不会死亡，但是会因其他任何错误而死亡。毕竟，如果您的基类为空，不包含任何符号，则 &lt;code&gt;base&lt;/code&gt; 将消失。这对于从与您自己位于同一文件中但文件名与基本模块名称不匹配的类进行继承很有用，例如：</target>
        </trans-unit>
        <trans-unit id="f3f15dbf4bfac8ce422e1183a7c97c2a550a0582" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; are in effect, there is also a &lt;code&gt;$File::Find::fullname&lt;/code&gt; . The function may set &lt;code&gt;$File::Find::prune&lt;/code&gt; to prune the tree unless &lt;code&gt;bydepth&lt;/code&gt; was specified. Unless &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; is specified, for compatibility reasons (find.pl, find2perl) there are in addition the following globals available: &lt;code&gt;$File::Find::topdir&lt;/code&gt; , &lt;code&gt;$File::Find::topdev&lt;/code&gt; , &lt;code&gt;$File::Find::topino&lt;/code&gt; , &lt;code&gt;$File::Find::topmode&lt;/code&gt; and &lt;code&gt;$File::Find::topnlink&lt;/code&gt; .</source>
          <target state="translated">当 &lt;code&gt;follow&lt;/code&gt; 或 &lt;code&gt;follow_fast&lt;/code&gt; 生效时，还有一个 &lt;code&gt;$File::Find::fullname&lt;/code&gt; 。该函数可以设置 &lt;code&gt;$File::Find::prune&lt;/code&gt; 来修剪树，除非指定了 &lt;code&gt;bydepth&lt;/code&gt; 。除非指定了 &lt;code&gt;follow&lt;/code&gt; 或 &lt;code&gt;follow_fast&lt;/code&gt; ，否则出于兼容性原因（find.pl，find2perl），还可以使用以下全局变量： &lt;code&gt;$File::Find::topdir&lt;/code&gt; ， &lt;code&gt;$File::Find::topdev&lt;/code&gt; ， &lt;code&gt;$File::Find::topino&lt;/code&gt; ， &lt;code&gt;$File::Find::topmode&lt;/code&gt; 和 &lt;code&gt;$File::Find::topnlink&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c3af0ccfdbd0226b2c1c6a386ea7d1149b898de" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;get_handle&lt;/code&gt; is called with an empty parameter list, magic happens:</source>
          <target state="translated">当使用空参数列表调用 &lt;code&gt;get_handle&lt;/code&gt; 时，会发生魔术：</target>
        </trans-unit>
        <trans-unit id="0587cd71d3cd406da1e34d9f0121a501c139389a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;remove_tree&lt;/code&gt; returned from deleting files in a child directory, a check revealed that the parent directory it returned to wasn't the one it started out from. This is considered a sign of malicious activity.</source>
          <target state="translated">当 &lt;code&gt;remove_tree&lt;/code&gt; 从删除子目录中的文件中返回时，检查发现它返回的父目录不是从其开始的目录。这被认为是恶意活动的标志。</target>
        </trans-unit>
        <trans-unit id="0abaa039dcd0b20cc37827ce7e9a425281864469" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;share&lt;/code&gt; is used on arrays, hashes, array refs or hash refs, any data they contain will be lost.</source>
          <target state="translated">当在数组，哈希，数组引用或哈希引用上使用 &lt;code&gt;share&lt;/code&gt; 时，它们包含的任何数据都会丢失。</target>
        </trans-unit>
        <trans-unit id="f072734b6ff55766546071395774e151a8cea193" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;test_test&lt;/code&gt; is called and the output that your tests generate does not match that which you declared, &lt;code&gt;test_test&lt;/code&gt; will print out debug information showing the two conflicting versions. As this output itself is debug information it can be confusing which part of the output is from &lt;code&gt;test_test&lt;/code&gt; and which was the original output from your original tests. Also, it may be hard to spot things like extraneous whitespace at the end of lines that may cause your test to fail even though the output looks similar.</source>
          <target state="translated">当 &lt;code&gt;test_test&lt;/code&gt; 且测试生成的输出与声明的输出不匹配时， &lt;code&gt;test_test&lt;/code&gt; 将打印出调试信息，显示两个冲突的版本。由于此输出本身是调试信息，因此可能会混淆输出的哪一部分来自 &lt;code&gt;test_test&lt;/code&gt; ,以及哪一部分是原始测试的原始输出。另外，即使输出看起来相似，也很难在行尾发现类似多余的空格之类的东西，这可能会导致测试失败。</target>
        </trans-unit>
        <trans-unit id="0a8ac650ec538c50bdeb4cf6dbd53747bc753f1f" translate="yes" xml:space="preserve">
          <source>When BE or LE is explicitly stated as the name of encoding, BOM is simply treated as a normal character (ZERO WIDTH NO-BREAK SPACE).</source>
          <target state="translated">当BE或LE被明确表示为编码名称时,BOM被简单地视为普通字符(ZERO WIDTH NO-BREAK SPACE)。</target>
        </trans-unit>
        <trans-unit id="0fbaed27da231d1d0f199bebcb75bb30dedc0240" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during decode(), it checks if BOM is at the beginning of the string; if one is found, the endianness is set to what the BOM says. If no BOM is found, the routine dies.</source>
          <target state="translated">当在decode()过程中省略BE或LE时,它会检查BOM是否在字符串的开头;如果找到了,则将endianness设置为BOM所说的内容。如果没有发现BOM,则该例程死亡。</target>
        </trans-unit>
        <trans-unit id="420dd2e0afe91753dba538ca831997f9f3a56a48" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during encode(), it returns a BE-encoded string with BOM prepended. So when you want to encode a whole text file, make sure you encode() the whole text at once, not line by line or each line, not file, will have a BOM prepended.</source>
          <target state="translated">当在encode()过程中省略BE或LE时,它返回的是一个BE编码的字符串,前面有BOM。所以,当你想对整个文本文件进行编码时,请确保你一次编码()整个文本,而不是逐行编码,否则每一行,而不是文件,都会有一个BOM预注。</target>
        </trans-unit>
        <trans-unit id="dacba9cd09b7954f0b607de2124d67d55cdeb2ac" translate="yes" xml:space="preserve">
          <source>When CPAN runs, it sets the environment variable PERL5_CPAN_IS_RUNNING to the ID of the running process. It also sets PERL5_CPANPLUS_IS_RUNNING to prevent runaway processes which could happen with older versions of Module::Install.</source>
          <target state="translated">当CPAN运行时,它会将环境变量PERL5_CPAN_IS_RUNNING设置为运行进程的ID。它还设置PERL5_CPANPLUS_IS_RUNNING来防止失控进程,因为旧版本的Module::Install可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="652978d2789dfa7c2e88ae3ead48735cc4a8b7e9" translate="yes" xml:space="preserve">
          <source>When CPAN.pm extends @INC via PERL5LIB, it prints a list of directories added (or a summary of how many directories are added). Choose 'v' to get this message, 'none' to suppress it.</source>
          <target state="translated">当 CPAN.pm 通过 PERL5LIB 扩展 @INC 时,它会打印出一个添加的目录列表 (或者是添加了多少个目录的摘要)。选择'v'来获取这个消息,选择'none'来抑制它。</target>
        </trans-unit>
        <trans-unit id="ec2c74f66c6e4b429c5d3bf449f05522f381cd48" translate="yes" xml:space="preserve">
          <source>When CPAN.pm loads a module it needs for some optional feature, it usually reports about module name and version. Choose 'v' to get this message, 'none' to suppress it.</source>
          <target state="translated">当CPAN.pm加载一个它需要的模块时,它通常会报告模块的名称和版本。选择'v'可以得到这个消息,选择'none'可以抑制它。</target>
        </trans-unit>
        <trans-unit id="a6c2efe210167d6d16736590efab450901a5223c" translate="yes" xml:space="preserve">
          <source>When CPAN.pm uses the tar command, which switch for the verbosity shall be used? Choose 'none' for quiet operation, 'v' for file name listing, 'vv' for full listing.</source>
          <target state="translated">当CPAN.pm使用tar命令时,应使用哪一个开关来控制verbosity?选择'none'表示安静操作,选择'v'表示文件名列表,选择'vv'表示完全列表。</target>
        </trans-unit>
        <trans-unit id="09926237f4d026fd4275fa85769eac33da9c9434" translate="yes" xml:space="preserve">
          <source>When Configure asks about the extensions, I suggest IO and Fcntl, and if you want database handling then SDBM_File or GDBM_File (you need to install gdbm for this one). If you want to use the POSIX extension (this is the default), make sure that the stack size of your</source>
          <target state="translated">当Configure问及扩展时,我建议使用IO和Fcntl,如果你想要数据库处理,那么就使用SDBM_File或GDBM_File(这个需要安装gdbm)。如果你想使用POSIX扩展(这是默认的),确保你的堆栈大小在你的</target>
        </trans-unit>
        <trans-unit id="04e0b7cf71399471be99cb867416364c0df9f40e" translate="yes" xml:space="preserve">
          <source>When Democritus gave the word &amp;ldquo;atom&amp;rdquo; to the indivisible bits of matter, he meant literally something that could not be cut:</source>
          <target state="translated">当德cri克利特斯给不可分割的物质赋予&amp;ldquo;原子&amp;rdquo;一词时，他的意思是无法切割的东西：</target>
        </trans-unit>
        <trans-unit id="bed16fa39ff4d380815a5a95de03029e7764deee" translate="yes" xml:space="preserve">
          <source>When G_KEEPERR is used, any error in the called code will terminate the call as usual, and the error will not propagate beyond the call (as usual for G_EVAL), but it will not go into &lt;code&gt;$@&lt;/code&gt; . Instead the error will be converted into a warning, prefixed with the string &quot;\t(in cleanup)&quot;. This can be disabled using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'misc'&lt;/code&gt; . If there is no error, &lt;code&gt;$@&lt;/code&gt; will not be cleared.</source>
          <target state="translated">当使用G_KEEPERR时，被调用代码中的任何错误将照常终止该调用，并且该错误不会传播到整个调用之外（与G_EVAL一样），但不会进入 &lt;code&gt;$@&lt;/code&gt; 。而是将错误转换为警告，并以字符串&amp;ldquo; \ t（in cleanup）&amp;rdquo;为前缀。可以使用 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'misc'&lt;/code&gt; 禁用此功能。如果没有错误，则不会清除 &lt;code&gt;$@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6cefe86149d167c60485e01ab068ab4acc1c96d" translate="yes" xml:space="preserve">
          <source>When I install bundles or multiple modules with one command there is too much output to keep track of.</source>
          <target state="translated">当我用一个命令安装捆绑包或多个模块时,有太多的输出,无法跟踪。</target>
        </trans-unit>
        <trans-unit id="96aa2dd484c673b89bb47260df9f770fc3e65459" translate="yes" xml:space="preserve">
          <source>When I run CPAN's shell, I get an error message about things in my &lt;code&gt;/etc/inputrc&lt;/code&gt; (or &lt;code&gt;~/.inputrc&lt;/code&gt;) file.</source>
          <target state="translated">当我运行CPAN的外壳程序时，我在 &lt;code&gt;/etc/inputrc&lt;/code&gt; （或 &lt;code&gt;~/.inputrc&lt;/code&gt; ）文件中收到有关事情的错误消息。</target>
        </trans-unit>
        <trans-unit id="6b21be97219bbbb10df79f70e49405f833c3cad4" translate="yes" xml:space="preserve">
          <source>When I tried to run my script, I got this message. What does it mean?</source>
          <target state="translated">当我试图运行我的脚本时,我得到了这个消息。这是什么意思?</target>
        </trans-unit>
        <trans-unit id="e4bb48e8ad735dfd3ed959c0444d6089c891d679" translate="yes" xml:space="preserve">
          <source>When I/O, for example &quot;read&quot;, is requested, the request goes from Perl first down the stack using &quot;read&quot; functions of each layer, then at the bottom the input is requested from the operating system services, then the result is returned up the stack, finally being interpreted as Perl data.</source>
          <target state="translated">当请求I/O时,例如 &quot;读&quot;,请求从Perl先用各层的 &quot;读 &quot;函数向下堆栈,然后在最底层向操作系统服务请求输入,再将结果向上堆栈返回,最后被解释为Perl数据。</target>
        </trans-unit>
        <trans-unit id="e5e8467b062c382be485cbe69584b5d02adf0299" translate="yes" xml:space="preserve">
          <source>When Memoize needs to check to see if an entry is in the cache already, it will invoke &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt; . &lt;code&gt;key&lt;/code&gt; is the normalized function argument. MyExpirePolicy::EXISTS should return 0 if the key is not in the cache, or if it has expired, and 1 if an unexpired value is in the cache. It should</source>
          <target state="translated">当Memoize需要检查条目是否已在缓存中时，它将调用 &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt; 。 &lt;code&gt;key&lt;/code&gt; 是归一化函数参数。如果密钥不在高速缓存中或密钥已经过期，则MyExpirePolicy :: EXISTS应该返回0；如果高速缓存中没有未过期的值，则返回1。这应该</target>
        </trans-unit>
        <trans-unit id="ebd887c91b9049b8dfb0bd1e032eea2b43f90690" translate="yes" xml:space="preserve">
          <source>When Perl 5.12 or later encounters an ellipsis statement, it parses this without error, but if and when you should actually try to execute it, Perl throws an exception with the text &lt;code&gt;Unimplemented&lt;/code&gt; :</source>
          <target state="translated">当Perl 5.12或更高版本遇到省略号语句时，它会解析此语句而不会出错，但是如果并且当您实际尝试执行它时，Perl会抛出一个带有文本 &lt;code&gt;Unimplemented&lt;/code&gt; 的异常：</target>
        </trans-unit>
        <trans-unit id="ab4ce43e1ebabd776abd8a74c5e1d002b8bd8ffe" translate="yes" xml:space="preserve">
          <source>When Perl compiles the regular expression, it treats the parenthesis as the start of a memory match. When it doesn't find the closing parenthesis, it complains:</source>
          <target state="translated">当 Perl 编译正则表达式时,它将小括号视为内存匹配的开始。当它没有找到最后的小括号时,它就会抱怨。</target>
        </trans-unit>
        <trans-unit id="53c411ad4e1523024c43c3f84e8d99bfb2921a55" translate="yes" xml:space="preserve">
          <source>When Perl destroys the object referenced by $netconf it will send the object to the supplied XSUB DESTROY function. Perl cannot determine, and does not care, that this object is a C struct and not a Perl object. In this sense, there is no difference between the object created by the getnetconfigent() XSUB and an object created by a normal Perl subroutine.</source>
          <target state="translated">当Perl销毁$netconf引用的对象时,它将把这个对象发送到提供的XSUB DESTROY函数中。Perl无法确定,也不关心这个对象是C结构而不是Perl对象。在这个意义上,getnetconfigent()XSUB 创建的对象和普通 Perl 子程序创建的对象没有区别。</target>
        </trans-unit>
        <trans-unit id="e513aa6b4ab015986cab17c857cc3e0082b263e5" translate="yes" xml:space="preserve">
          <source>When Perl exchanges data with an extension, the extension should be able to understand the UTF8 flag and act accordingly. If the extension doesn't recognize that flag, it's likely that the extension will return incorrectly-flagged data.</source>
          <target state="translated">当Perl与扩展进行数据交换时,扩展应该能够理解UTF8标志并采取相应的行动。如果扩展不能识别该标志,那么扩展很可能会返回错误的标志数据。</target>
        </trans-unit>
        <trans-unit id="f6f1776d7dcd16bb2da8426867ab48b032eaee97" translate="yes" xml:space="preserve">
          <source>When Perl is built with PERL_IMPLICIT_CONTEXT, extensions that call any functions in the Perl API will need to pass the initial context argument somehow. The kicker is that you will need to write it in such a way that the extension still compiles when Perl hasn't been built with PERL_IMPLICIT_CONTEXT enabled.</source>
          <target state="translated">当 Perl 以 PERL_IMPLICIT_CONTEXT 构建时,调用 Perl API 中任何函数的扩展都需要以某种方式传递初始上下文参数。更重要的是,你需要以这样的方式来编写它,以便在没有启用 PERL_IMPLICIT_CONTEXT 的情况下,扩展仍然能够编译。</target>
        </trans-unit>
        <trans-unit id="f6fb72d35777e36edb4c8c03f40429a73f9b258a" translate="yes" xml:space="preserve">
          <source>When Perl is built without options that set PERL_IMPLICIT_CONTEXT, there is no first argument containing the interpreter's context. The trailing underscore in the pTHX_ macro indicates that the macro expansion needs a comma after the context argument because other arguments follow it. If PERL_IMPLICIT_CONTEXT is not defined, pTHX_ will be ignored, and the subroutine is not prototyped to take the extra argument. The form of the macro without the trailing underscore is used when there are no additional explicit arguments.</source>
          <target state="translated">当Perl在构建时没有设置PERL_IMPLICIT_CONTEXT的选项时,没有包含解释器上下文的第一个参数。pTHX_宏中尾部的下划线表示宏的扩展需要在上下文参数后面加上逗号,因为其他参数都在后面。如果没有定义PERL_IMPLICIT_CONTEXT,那么pTHX_将被忽略,而且子程序也没有原型来接受额外的参数。当没有额外的显式参数时,会使用没有尾部下划线的宏的形式。</target>
        </trans-unit>
        <trans-unit id="8079f54267f5c6445383e49837ffc5d08d1d7078" translate="yes" xml:space="preserve">
          <source>When Perl is compiled for a platform, it looks at all of these characters to guess which EBCDIC character set the platform uses, and adapts itself accordingly to that platform. If the platform uses a character set that is not one of the three Perl knows about, Perl will either fail to compile, or mistakenly and silently choose one of the three.</source>
          <target state="translated">当Perl为某个平台编译时,它会查看所有这些字符,以猜测该平台使用的是哪种EBCDIC字符集,并据此使自己适应该平台。如果平台使用的字符集不是Perl知道的三种字符集之一,Perl就会编译失败,或者错误地默默地选择三种字符中的一种。</target>
        </trans-unit>
        <trans-unit id="80ed2279b39397e0ed205899926800b606fe0a42" translate="yes" xml:space="preserve">
          <source>When Perl is configured to use ithreads, it will use re-entrant library calls in preference to non-re-entrant versions. There is an incompatibility in OpenBSD's &lt;code&gt;getprotobyname_r&lt;/code&gt; and &lt;code&gt;getservbyname_r&lt;/code&gt; function in versions 3.7 and later that will cause a SEGV when called without doing a &lt;code&gt;bzero&lt;/code&gt; on their return structs prior to calling these functions. Current Perl's should handle this problem correctly. Older threaded Perls (5.8.6 or earlier) will run into this problem. If you want to run a threaded Perl on OpenBSD 3.7 or higher, you will need to upgrade to at least Perl 5.8.7.</source>
          <target state="translated">当Perl配置为使用ithreads时，它将优先使用非可重入版本的可重入库调用。 OpenBSD的3.7版及更高版本中的 &lt;code&gt;getprotobyname_r&lt;/code&gt; 和 &lt;code&gt;getservbyname_r&lt;/code&gt; 函数不兼容，这在调用这些函数之前在不对其返回结构执行 &lt;code&gt;bzero&lt;/code&gt; 的情况下调用时会导致SEGV 。当前的Perl应该可以正确处理此问题。较旧的线程Perls（5.8.6或更早版本）将遇到此问题。如果要在OpenBSD 3.7或更高版本上运行线程化的Perl，则需要至少升级到Perl 5.8.7。</target>
        </trans-unit>
        <trans-unit id="df300d221e04eb6da687f72d9bfb0bebe32d3fc0" translate="yes" xml:space="preserve">
          <source>When Perl is processing &quot;binary data&quot;, the programmer wants Perl to process &quot;sequences of bytes&quot;. This is not a problem for Perl: because a byte has 256 possible values, it easily fits in Perl's much larger &quot;logical character&quot;.</source>
          <target state="translated">当Perl处理 &quot;二进制数据 &quot;时,程序员希望Perl处理 &quot;字节序列&quot;。这对Perl来说并不是问题:因为一个字节有256种可能的值,所以它很容易适合Perl大得多的 &quot;逻辑字符&quot;。</target>
        </trans-unit>
        <trans-unit id="cc51149dee007d3915d8fd89443c351da938e4a2" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this GV contains the SV which holds the name of the sub being debugged. This is the C variable which corresponds to Perl's $DB::sub variable. See &lt;code&gt;PL_DBsingle&lt;/code&gt; .</source>
          <target state="translated">当Perl在调试模式下使用&lt;b&gt;-d&lt;/b&gt;开关运行时，此GV包含SV，该SV包含要调试的子程序的名称。这是C变量，它对应于Perl的$ DB :: sub变量。参见 &lt;code&gt;PL_DBsingle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3590f13940a356a00f485512d64c10323ed9ae31" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this SV is a boolean which indicates whether subs are being single-stepped. Single-stepping is automatically turned on after every step. This is the C variable which corresponds to Perl's $DB::single variable. See &lt;code&gt;PL_DBsub&lt;/code&gt; .</source>
          <target state="translated">当Perl在调试模式下使用&lt;b&gt;-d&lt;/b&gt;开关运行时，此SV是一个布尔值，指示子程序是否为单步执行。每一步后单步自动打开。这是C变量，它对应于Perl的$ DB :: single变量。参见 &lt;code&gt;PL_DBsub&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="987fa57f3d6e2d1a009a00d587b9bac8f003a80c" translate="yes" xml:space="preserve">
          <source>When Perl is run with the &lt;b&gt;-Do&lt;/b&gt; switch or its equivalent, overloading induces diagnostic messages.</source>
          <target state="translated">当使用&lt;b&gt;-Do&lt;/b&gt;开关或等效开关运行Perl时，过载会产生诊断消息。</target>
        </trans-unit>
        <trans-unit id="31b65aa4a8ccdb59770227d57464bc9d968a6a6c" translate="yes" xml:space="preserve">
          <source>When Perl searches for a method, it caches the lookup so that future calls to the method do not need to search for it again. Changing a class's parent class or adding subroutines to a class will invalidate the cache for that class.</source>
          <target state="translated">当Perl搜索一个方法时,它会缓存查找,这样以后对该方法的调用就不需要再次搜索了。改变一个类的父类或在一个类中添加子程序会使该类的缓存无效。</target>
        </trans-unit>
        <trans-unit id="dc44d70cd8e2f4c150d9b1a250549091ec350dff" translate="yes" xml:space="preserve">
          <source>When Perl sees a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; extension;&lt;/code&gt; , it searches for a file with the same name as the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;'d extension that has a .pm suffix. If that file cannot be found, Perl dies with a fatal error. The default search path is contained in the &lt;code&gt;@INC&lt;/code&gt; array.</source>
          <target state="translated">当Perl看到 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; extension;&lt;/code&gt; ，它将搜索具有相同名称的文件 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 具有的.pm后缀&amp;ldquo;d延伸。如果找不到该文件，则Perl死于致命错误。默认搜索路径包含在 &lt;code&gt;@INC&lt;/code&gt; 数组中。</target>
        </trans-unit>
        <trans-unit id="c45a181d0244e9e1141094875e09095d6414b083" translate="yes" xml:space="preserve">
          <source>When Pod::Simple sees a &quot;=head1 Hi there&quot;, for example, it basically does this:</source>
          <target state="translated">例如,当Pod::Simple看到&quot;=head1 Hi there &quot;时,它基本上会这样做。</target>
        </trans-unit>
        <trans-unit id="1cd158af5ecd016f5844a2f8d5f52d658dbd56fa" translate="yes" xml:space="preserve">
          <source>When STDERR is tied, its PRINT method will be called to issue warnings and error messages. This feature is temporarily disabled during the call, which means you can use &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; inside PRINT without starting a recursive loop. And just like &lt;code&gt;__WARN__&lt;/code&gt; and &lt;code&gt;__DIE__&lt;/code&gt; handlers, STDERR's PRINT method may be called to report parser errors, so the caveats mentioned under &lt;a href=&quot;perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; apply.</source>
          <target state="translated">绑定STDERR时，将调用其PRINT方法以发出警告和错误消息。调用期间会暂时禁用此功能，这意味着您可以在PRINT中使用 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; 而不启动递归循环。与 &lt;code&gt;__WARN__&lt;/code&gt; 和 &lt;code&gt;__DIE__&lt;/code&gt; 处理程序一样，可以调用STDERR的PRINT方法来报告解析器错误，因此适用&lt;a href=&quot;perlvar#%25SIG&quot;&gt;于perlvar中％SIG&lt;/a&gt;下提到的警告。</target>
        </trans-unit>
        <trans-unit id="776742a8703e38b8c7c180ad1bc1e1f2ea07cf1b" translate="yes" xml:space="preserve">
          <source>When Storable croaks, it tries to report the error via the &lt;code&gt;logcroak()&lt;/code&gt; routine from the &lt;code&gt;Log::Agent&lt;/code&gt; package, if it is available.</source>
          <target state="translated">当可存储杂音出现时，它将尝试通过 &lt;code&gt;Log::Agent&lt;/code&gt; 包中的 &lt;code&gt;logcroak()&lt;/code&gt; 例程报告错误（如果可用）。</target>
        </trans-unit>
        <trans-unit id="d6016e444b9f013774a61df21cb4a60b0edf43d8" translate="yes" xml:space="preserve">
          <source>When UTF-8 becomes the standard source format, this pragma will effectively become a no-op. For convenience in what follows the term</source>
          <target state="translated">当UTF-8成为标准的源码格式时,这个pragma实际上将成为一个无用的工具。为方便起见,下面的术语</target>
        </trans-unit>
        <trans-unit id="1e26f2f78b2d3c5f0bcbde15044bd5212be0247d" translate="yes" xml:space="preserve">
          <source>When Unicode Does Not Happen</source>
          <target state="translated">当Unicode不发生时</target>
        </trans-unit>
        <trans-unit id="7748cfda1edce223207e83e001d28dffb7bf724f" translate="yes" xml:space="preserve">
          <source>When Unicode rules are in effect:</source>
          <target state="translated">当Unicode规则生效时。</target>
        </trans-unit>
        <trans-unit id="a9436974a6cc23829e6eb2bd840fe00c99d5fdc2" translate="yes" xml:space="preserve">
          <source>When Unicode was first conceived, it was thought that all the world's characters could be represented using a 16-bit word; that is a maximum of &lt;code&gt;0x10000&lt;/code&gt; (or 65,536) characters would be needed, from &lt;code&gt;0x0000&lt;/code&gt; to &lt;code&gt;0xFFFF&lt;/code&gt; . This soon proved to be wrong, and since Unicode 2.0 (July 1996), Unicode has been defined all the way up to 21 bits (&lt;code&gt;0x10FFFF&lt;/code&gt; ), and Unicode 3.1 (March 2001) defined the first characters above &lt;code&gt;0xFFFF&lt;/code&gt; . The first &lt;code&gt;0x10000&lt;/code&gt; characters are called the</source>
          <target state="translated">最初设想Unicode时，人们认为可以使用16位字来表示世界上所有字符。最多需要 &lt;code&gt;0x10000&lt;/code&gt; 个字符（或65,536个），从 &lt;code&gt;0x0000&lt;/code&gt; 到 &lt;code&gt;0xFFFF&lt;/code&gt; 。很快就证明这是错误的，并且自Unicode 2.0（1996年7月）以来，一直到21位（ &lt;code&gt;0x10FFFF&lt;/code&gt; ）都定义了Unicode，而Unicode 3.1（2001年3月）定义了 &lt;code&gt;0xFFFF&lt;/code&gt; 以上的第一个字符。前 &lt;code&gt;0x10000&lt;/code&gt; 个字符称为</target>
        </trans-unit>
        <trans-unit id="824bf2e880285aa9c434d2acac5d910818e02e5d" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;SelectSaver&lt;/code&gt; is destroyed, it re-selects the file handle that was selected when it was created.</source>
          <target state="translated">当 &lt;code&gt;SelectSaver&lt;/code&gt; 被破坏，它会重新选择在创建时所选择的文件句柄。</target>
        </trans-unit>
        <trans-unit id="47dccd0143522691a9547f34d1ed5af302d02e22" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;given&lt;/code&gt; statement is also a valid expression (for example, when it's the last statement of a block), it evaluates to:</source>
          <target state="translated">当 &lt;code&gt;given&lt;/code&gt; 语句也是有效表达式时（例如，当它是块的最后一条语句时），其结果为：</target>
        </trans-unit>
        <trans-unit id="0af006e8d26663a7078cc20a1292be03a5256d66" translate="yes" xml:space="preserve">
          <source>When a CV has a reference count on its slab (CvSLABBED), it is responsible for making sure it is freed. (Hence, no two CVs should ever have a reference count on the same slab.) The CV only needs to reference the slab during compilation. Once it is compiled and CvROOT attached, it has finished its job, so it can forget the slab.</source>
          <target state="translated">当一个 CV 在它的 slab 上有一个引用计数 (CvSLABBED),它有责任确保它被释放。(因此,任何两个 CV 都不应该在同一个 slab 上有一个引用计数。)CV 只需要在编译时引用 slab。一旦它被编译并连接了 CvROOT,它就完成了它的工作,所以它可以忘记 slab。</target>
        </trans-unit>
        <trans-unit id="5c03e144fe4a4613006ecf4b238cfa477e26c49c" translate="yes" xml:space="preserve">
          <source>When a DST change causes a locale clock to skip one hour forward, there will be an hour's worth of local times that don't exist. Again, for the &quot;Europe/Paris&quot; time zone, the local clock jumped from 2001-03-25 01:59:59 to 2001-03-25 03:00:00.</source>
          <target state="translated">当DST变化导致一个地区时钟向前跳过一个小时时,会有一个小时的当地时间不存在。同样,对于 &quot;欧洲/巴黎 &quot;时区,当地时钟从2001-03-25 01:59:59跳到2001-03-25 03:00:00。</target>
        </trans-unit>
        <trans-unit id="6c769151f41d9f979bbea6aa6d7a29c398587207" translate="yes" xml:space="preserve">
          <source>When a block is preceding by a compilation phase keyword such as &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;END&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , or &lt;code&gt;UNITCHECK&lt;/code&gt; , then the block will run only during the corresponding phase of execution. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for more details.</source>
          <target state="translated">当一个块前面有一个编译阶段关键字，例如 &lt;code&gt;BEGIN&lt;/code&gt; ， &lt;code&gt;END&lt;/code&gt; ， &lt;code&gt;INIT&lt;/code&gt; ， &lt;code&gt;CHECK&lt;/code&gt; 或 &lt;code&gt;UNITCHECK&lt;/code&gt; 时，该块将仅在相应的执行阶段运行。有关更多详细信息，请参见&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d61af89d14aac150579ea072baeedb77daecc0a" translate="yes" xml:space="preserve">
          <source>When a class has multiple parents, the method lookup order becomes more complicated.</source>
          <target state="translated">当一个类有多个父类时,方法的查找顺序会变得更加复杂。</target>
        </trans-unit>
        <trans-unit id="bbfabd64dc538b19e52659b29026ea44adaac5bb" translate="yes" xml:space="preserve">
          <source>When a class inherits from another class, any methods defined in the parent class are available to the child class. If you attempt to call a method on an object that isn't defined in its own class, Perl will also look for that method in any parent classes it may have.</source>
          <target state="translated">当一个类从另一个类继承时,父类中定义的任何方法都可以被子类使用。如果你试图在一个对象上调用一个没有在它自己的类中定义的方法,Perl也会在它可能有的任何父类中寻找该方法。</target>
        </trans-unit>
        <trans-unit id="3fbe037b656bddc24c2846062762f1fce297b32a" translate="yes" xml:space="preserve">
          <source>When a comma-separated list of subroutine names is given as options, Showlex prints the lexical variables used in those subroutines. Otherwise, it prints the file-scope lexicals in the file.</source>
          <target state="translated">当给定一个以逗号分隔的子程序名称列表作为选项时,Showlex会打印这些子程序中使用的词汇变量。否则,它将打印文件中的文件范围词法。</target>
        </trans-unit>
        <trans-unit id="7150e31ab9e9cca66d69c6a47a4d5fc17ee83d01" translate="yes" xml:space="preserve">
          <source>When a constant is used in an expression, Perl replaces it with its value at compile time, and may then optimize the expression further. In particular, any code in an &lt;code&gt;if (CONSTANT)&lt;/code&gt; block will be optimized away if the constant is false.</source>
          <target state="translated">在表达式中使用常量时，Perl在编译时将其替换为其值，然后可以进一步优化表达式。特别是，如果常量为false，则 &lt;code&gt;if (CONSTANT)&lt;/code&gt; 块中的任何代码都将被优化。</target>
        </trans-unit>
        <trans-unit id="ff12ac8ff6a9fb5ab965d82a8adb8da16c238288" translate="yes" xml:space="preserve">
          <source>When a context for a part of compile tree is known, it is propagated down through the tree. At this time the context can have 5 values (instead of 2 for runtime context): void, boolean, scalar, list, and lvalue. In contrast with the pass 1 this pass is processed from top to bottom: a node's context determines the context for its children.</source>
          <target state="translated">当编译树的一部分上下文已知时,它会通过树向下传播。此时上下文可以有5个值(而不是运行时上下文的2个):void、boolean、scalar、list和lvalue。与通证1不同的是,这个通证是从上到下处理的:一个节点的上下文决定了其子节点的上下文。</target>
        </trans-unit>
        <trans-unit id="d87717a8777688d74cabbb2304d94b51341cc91d" translate="yes" xml:space="preserve">
          <source>When a core function calls another, it must pass the context. This is normally hidden via macros. Consider &lt;code&gt;sv_setiv&lt;/code&gt; . It expands into something like this:</source>
          <target state="translated">当一个核心函数调用另一个函数时，它必须传递上下文。通常通过宏将其隐藏。考虑 &lt;code&gt;sv_setiv&lt;/code&gt; 。它扩展为如下所示：</target>
        </trans-unit>
        <trans-unit id="40ceceb3dfac228f4dc1ea2316b05b14abb23395" translate="yes" xml:space="preserve">
          <source>When a dictionary is specified</source>
          <target state="translated">当指定一个字典时</target>
        </trans-unit>
        <trans-unit id="d409b69c538e75e300d571031fe6a755a4d085f3" translate="yes" xml:space="preserve">
          <source>When a distribution has already been tested by CPAN::Reporter on this machine, CPAN can skip the test phase and just rely on the test report history instead.</source>
          <target state="translated">当CPAN::Reporter已经在这台机器上测试过一个发行版时,CPAN可以跳过测试阶段,而只依靠测试报告历史记录。</target>
        </trans-unit>
        <trans-unit id="f71acc218a83c770a92fc1a815404b3d3de498a7" translate="yes" xml:space="preserve">
          <source>When a file is opened it is in either text or binary mode. In text mode a file is subject to CR/LF/Ctrl-Z translations. With Cygwin, the default mode for an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; is determined by the mode of the mount that underlies the file. See &lt;a href=&quot;#Cygwin%3a%3ais_binmount&quot;&gt;Cygwin::is_binmount&lt;/a&gt;(). Perl provides a &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; function to set binary mode on files that otherwise would be treated as text. &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;O_TEXT&lt;/code&gt; flag sets text mode on files that otherwise would be treated as binary:</source>
          <target state="translated">打开文件时，它处于文本或二进制模式。在文本模式下，文件需要进行CR / LF / Ctrl-Z转换。使用Cygwin时， &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 的默认模式由文件基础安装的模式决定。请参见&lt;a href=&quot;#Cygwin%3a%3ais_binmount&quot;&gt;Cygwin :: is_binmount&lt;/a&gt;（）。 Perl提供了 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; 函数来设置文件的二进制模式，否则该文件将被视为文本。带有 &lt;code&gt;O_TEXT&lt;/code&gt; 标志的 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; 在文件上设置文本模式，否则将被视为二进制文件：</target>
        </trans-unit>
        <trans-unit id="973bff9414f9daff4e8ac9353de5be029b42eafe" translate="yes" xml:space="preserve">
          <source>When a handle is so opened, then reads get bytes from the string value of</source>
          <target state="translated">当一个句柄被如此打开,那么从字符串值的</target>
        </trans-unit>
        <trans-unit id="17e8d47075484fcb067bf9d5f01cdea7dd0c053a" translate="yes" xml:space="preserve">
          <source>When a keyword is being handled, the plugin function must build a tree of &lt;code&gt;OP&lt;/code&gt; structures, representing the code that was parsed. The root of the tree must be stored in &lt;code&gt;*op_ptr&lt;/code&gt; . The function then returns a constant indicating the syntactic role of the construct that it has parsed: &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; if it is a complete statement, or &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; if it is an expression. Note that a statement construct cannot be used inside an expression (except via &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; and similar), and an expression is not a complete statement (it requires at least a terminating semicolon).</source>
          <target state="translated">处理关键字时，插件功能必须构建 &lt;code&gt;OP&lt;/code&gt; 结构树，以表示已解析的代码。树的根必须存储在 &lt;code&gt;*op_ptr&lt;/code&gt; 中。该函数然后返回指示结构的语法作用，它已解析的常数： &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; ，如果它是一个完整的语句，或者 &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; 如果它是一个表达式。注意，语句构造不能在表达式内部使用（通过 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; 和类似方法除外），并且表达式不是完整的语句（它至少需要一个终止分号）。</target>
        </trans-unit>
        <trans-unit id="9e79d667e2ee3be13474d3de61e4494ae38724c2" translate="yes" xml:space="preserve">
          <source>When a keyword is handled, the plugin function may also have (compile-time) side effects. It may modify &lt;code&gt;%^H&lt;/code&gt; , define functions, and so on. Typically, if side effects are the main purpose of a handler, it does not wish to generate any ops to be included in the normal compilation. In this case it is still required to supply an op tree, but it suffices to generate a single null op.</source>
          <target state="translated">处理关键字时，插件功能也可能具有（编译时）副作用。它可以修改 &lt;code&gt;%^H&lt;/code&gt; ，定义函数，等等。通常，如果副作用是处理程序的主要目的，则它不希望生成要包含在常规编译中的任何操作。在这种情况下，仍然需要提供一个op树，但是足以生成一个空op。</target>
        </trans-unit>
        <trans-unit id="57ad4f96e4d1cfbd5bc9ad7761654ce09c743746" translate="yes" xml:space="preserve">
          <source>When a line is rendered, the correct format-spec is copied and scanned for the following items; data is substituted in, and other manipulations like basic indenting are done, for each opcode rendered.</source>
          <target state="translated">当一行被渲染时,正确的格式-规格被复制,并扫描以下项目;数据被替换进去,并对每个操作码进行其他操作,如基本缩进。</target>
        </trans-unit>
        <trans-unit id="816633f303f39f0cbcf02a62fbc386a09fe865f3" translate="yes" xml:space="preserve">
          <source>When a match has failed, and unless another verb has been involved in failing the match and has provided its own name to use, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:NAME)&lt;/code&gt;.</source>
          <target state="translated">如果匹配失败，并且除非另一个动词导致匹配失败并提供了自己的名称， &lt;code&gt;$REGERROR&lt;/code&gt; 变量将设置为最近执行的名称 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="166223375f2bf3db19459da46d44df6881e6c346" translate="yes" xml:space="preserve">
          <source>When a match is successful, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:NAME)&lt;/code&gt; that was involved in the match.</source>
          <target state="translated">匹配成功后， &lt;code&gt;$REGMARK&lt;/code&gt; 变量将设置为匹配中最近执行的名称 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4580d4e00986eec91e11abd53ea45f7e741116fe" translate="yes" xml:space="preserve">
          <source>When a module declares another one as a 'build_requires' prerequisite this means that the other module is only needed for building or testing the module but need not be installed permanently. In this case you may wish to install that other module nonetheless or just keep it in the 'build_dir' directory to have it available only temporarily. Installing saves time on future installations but makes the perl installation bigger.</source>
          <target state="translated">当一个模块声明另一个模块是'build_requires'的先决条件时,这意味着另一个模块只是在构建或测试该模块时才需要,而不需要永久安装。在这种情况下,您可能希望还是安装那个模块,或者只是把它放在'build_dir'目录下,让它暂时可用。安装可以节省以后安装的时间,但会使perl的安装变得更大。</target>
        </trans-unit>
        <trans-unit id="1496adc7bcbe4a50d48879cef9be976a3fb2e9c5" translate="yes" xml:space="preserve">
          <source>When a new language is being encoded, Unicode generally will choose a &lt;code&gt;block&lt;/code&gt; of consecutive unallocated code points for its characters. So far, the number of code points in these blocks has always been evenly divisible by 16. Extras in a block, not currently needed, are left unallocated, for future growth. But there have been occasions when a later release needed more code points than the available extras, and a new block had to allocated somewhere else, not contiguous to the initial one, to handle the overflow. Thus, it became apparent early on that &quot;block&quot; wasn't an adequate organizing principal, and so the &lt;code&gt;Script&lt;/code&gt; property was created. (Later an improved script property was added as well, the &lt;code&gt;Script_Extensions&lt;/code&gt; property.) Those code points that are in overflow blocks can still have the same script as the original ones. The script concept fits more closely with natural language: there is &lt;code&gt;Latin&lt;/code&gt; script, &lt;code&gt;Greek&lt;/code&gt; script, and so on; and there are several artificial scripts, like &lt;code&gt;Common&lt;/code&gt; for characters that are used in multiple scripts, such as mathematical symbols. Scripts usually span varied parts of several blocks. For more information about scripts, see &lt;a href=&quot;perlunicode#Scripts&quot;&gt;Scripts in perlunicode&lt;/a&gt;. The division into blocks exists, but it is almost completely accidental--an artifact of how the characters have been and still are allocated. (Note that this paragraph has oversimplified things for the sake of this being an introduction. Unicode doesn't really encode languages, but the writing systems for them--their scripts; and one script can be used by many languages. Unicode also encodes things that aren't really about languages, such as symbols like &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt; .)</source>
          <target state="translated">在对一种新语言进行编码时，Unicode通常会为其字符选择一个 &lt;code&gt;block&lt;/code&gt; 连续的未分配代码点。到目前为止，这些块中的代码点数量始终可以被16整除。为了将来的增长，该块中不需要的多余部分将不分配。但是，有些情况下，较新的发行版需要比可用附加功能更多的代码点，并且必须将新块分配到其他位置（与初始位置不相邻）来处理溢出。因此，很早就很明显，&amp;ldquo;块&amp;rdquo;不是足够的组织主体，因此创建了 &lt;code&gt;Script&lt;/code&gt; 属性。 （后来还添加了改进的脚本属性， &lt;code&gt;Script_Extensions&lt;/code&gt; 属性。）位于溢出块中的那些代码点仍可以具有与原始脚本相同的脚本。脚本概念更适合自然语言： &lt;code&gt;Latin&lt;/code&gt; ， &lt;code&gt;Greek&lt;/code&gt; 字母等；还有几种人工脚本，例如 &lt;code&gt;Common&lt;/code&gt; 表示用于多个脚本的字符，例如数学符号。脚本通常跨越几个块的不同部分。有关脚本的更多信息，请参见&lt;a href=&quot;perlunicode#Scripts&quot;&gt;perlunicode中的脚本。&lt;/a&gt;。虽然存在划分为块的情况，但是这几乎完全是偶然的-有关如何以及仍然分配字符的伪像。 （请注意，为了便于介绍，本段对事情进行了简化。Unicode并未真正对语言进行编码，但它们的书写系统是它们的脚本；多种语言可以使用一个脚本。Unicode也可以对事物进行编码。与语言无关，例如像 &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt; 之类的符号。）</target>
        </trans-unit>
        <trans-unit id="3bbe3c04751e10d9bc078e9c200bbf898654f3d9" translate="yes" xml:space="preserve">
          <source>When a package is compiled, a line like this</source>
          <target state="translated">当一个软件包被编译时,会有这样一行字</target>
        </trans-unit>
        <trans-unit id="93bffad6a970da997c7854ebcbcae55a405a4802" translate="yes" xml:space="preserve">
          <source>When a perl script assigns a value to $0 then the perl runtime will try to make this value show up as the program name reported by &quot;ps&quot; by updating the memory pointed to by the argv passed to perl_parse() and also calling API functions like setproctitle() where available. This behaviour might not be appropriate when embedding perl and can be disabled by assigning the value &lt;code&gt;1&lt;/code&gt; to the variable &lt;code&gt;PL_origalen&lt;/code&gt; before perl_parse() is called.</source>
          <target state="translated">当perl脚本为$ 0赋值时，perl运行时将尝试通过更新传递给perl_parse（）的argv指向的内存并调用API函数（例如，&amp;ldquo; ps&amp;rdquo;报告的程序名称）来显示该值。 setproctitle（）（如果有）。嵌入perl时，此行为可能不合适，可以通过在调用perl_parse（）之前将值 &lt;code&gt;1&lt;/code&gt; 分配给变量 &lt;code&gt;PL_origalen&lt;/code&gt; 来禁用此行为。</target>
        </trans-unit>
        <trans-unit id="5dd94d34aa40052479abfe68a7305a1776af1c6b" translate="yes" xml:space="preserve">
          <source>When a regexp can match a string in several different ways, we can use the principles above to predict which way the regexp will match:</source>
          <target state="translated">当一个regexp可以用几种不同的方式来匹配一个字符串时,我们可以用上面的原理来预测regexp的匹配方式。</target>
        </trans-unit>
        <trans-unit id="5e93e818427f981a20b5cd3c2cdc058e4ee5f4c1" translate="yes" xml:space="preserve">
          <source>When a regexp is compiled, its &lt;code&gt;engine&lt;/code&gt; field is then set to point at the appropriate structure, so that when it needs to be used Perl can find the right routines to do so.</source>
          <target state="translated">编译正则表达式时，然后将其 &lt;code&gt;engine&lt;/code&gt; 字段设置为指向适当的结构，以便在需要使用它时，Perl可以找到正确的例程来执行此操作。</target>
        </trans-unit>
        <trans-unit id="1ee520116426a3c213440cc6f7664ca3ad684e60" translate="yes" xml:space="preserve">
          <source>When a signal is delivered (e.g., SIGINT from a control-C) the operating system breaks into IO operations like</source>
          <target state="translated">当一个信号传递过来时(例如,来自控制C的SIGINT),操作系统就会分解成IO操作,如</target>
        </trans-unit>
        <trans-unit id="232c6b5f6274d23859408b92a2808f3fc59dd734" translate="yes" xml:space="preserve">
          <source>When a space and a plus sign are given as the flags at once, a plus sign is used to prefix a positive number.</source>
          <target state="translated">当同时给出一个空格和一个加号作为标志时,加号用于正数的前缀。</target>
        </trans-unit>
        <trans-unit id="d4c0062970171773b2800c4b96cf35e1d153d560" translate="yes" xml:space="preserve">
          <source>When a variable is tied, it is associated with the object which is the return value of the TIESCALAR, TIEARRAY, or TIEHASH function. This object normally has only one reference, namely, the implicit reference from the tied variable. When untie() is called, that reference is destroyed. Then, as in the first example above, the object's destructor (DESTROY) is called, which is normal for objects that have no more valid references; and thus the file is closed.</source>
          <target state="translated">当一个变量被绑定时,它与对象相关联,这个对象是TIESCALAR、TIEARRAY或TIEHASH函数的返回值。这个对象通常只有一个引用,即来自绑定变量的隐式引用。当调用untie()时,这个引用会被销毁。然后,就像上面第一个例子一样,调用对象的destructor(DESTROY),这对于没有更多有效引用的对象来说是正常的;因此文件被关闭。</target>
        </trans-unit>
        <trans-unit id="4c087ed039f3d9aacb0c9c7c411e1eafe86f0a03" translate="yes" xml:space="preserve">
          <source>When a weak reference is stored in an &lt;code&gt;SV&lt;/code&gt; that has &quot;uvar&quot; magic, &lt;code&gt;set&lt;/code&gt; magic is called after the reference has gone stale. This hook can be used to trigger further garbage-collection activities associated with the referenced object.</source>
          <target state="translated">当弱引用存储在具有&amp;ldquo; uvar&amp;rdquo;魔术的 &lt;code&gt;SV&lt;/code&gt; 中时，在引用失效后将调用 &lt;code&gt;set&lt;/code&gt; magic。该钩子可用于触发与引用的对象关联的其他垃圾收集活动。</target>
        </trans-unit>
        <trans-unit id="9a9840147d7f095037a163c370bf370a7676a796" translate="yes" xml:space="preserve">
          <source>When all parsers are exhausted an empty list will be returned.</source>
          <target state="translated">当所有的解析器都用完后,将返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="d58a9a2162a7d9db701502c02549ae6467f05b83" translate="yes" xml:space="preserve">
          <source>When an array or an array slice is interpolated into a double-quoted string or a similar context such as &lt;code&gt;/.../&lt;/code&gt; , its elements are separated by this value. Default is a space. For example, this:</source>
          <target state="translated">当将数组或数组切片插值到双引号字符串或类似的上下文（例如 &lt;code&gt;/.../&lt;/code&gt; )时，其元素由该值分隔。默认为空格。例如，这：</target>
        </trans-unit>
        <trans-unit id="e576a7aca6fc0d7ad26c29db1ef25b646d312e24" translate="yes" xml:space="preserve">
          <source>When an attribute list is present in a declaration, a check is made to see whether an attribute 'modify' handler is present in the appropriate package (or its @ISA inheritance tree). Similarly, when &lt;code&gt;attributes::get&lt;/code&gt; is called on a valid reference, a check is made for an appropriate attribute 'fetch' handler. See &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; to see how the &quot;appropriate package&quot; determination works.</source>
          <target state="translated">当声明中存在属性列表时，将进行检查以查看适当的包（或其@ISA继承树）中是否存在&amp;ldquo;修改&amp;rdquo;属性处理程序。类似地，当在有效引用上调用 &lt;code&gt;attributes::get&lt;/code&gt; 时，将检查适当的属性&amp;ldquo;提取&amp;rdquo;处理程序。请参阅&lt;a href=&quot;#EXAMPLES&quot;&gt;示例，&lt;/a&gt;以了解&amp;ldquo;合适的包装&amp;rdquo;确定的工作原理。</target>
        </trans-unit>
        <trans-unit id="8cddb5e14177fc6acd8b55e0252f21e912b7951c" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is read, the locations to which</source>
          <target state="translated">读取 &lt;code&gt;%ENV&lt;/code&gt; 的元素时，</target>
        </trans-unit>
        <trans-unit id="0687a40bbb86ac6f75e3c72f51434b562de688d3" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the element is looked up as if it were being read, and if it is found, it is deleted. (An item &quot;deleted&quot; from the CRTL &lt;code&gt;environ&lt;/code&gt; array is set to the empty string.) Using &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; to remove an element from &lt;code&gt;%ENV&lt;/code&gt; has a similar effect, but after the element is deleted, another attempt is made to look up the element, so an inner-mode logical name or a name in another location will replace the logical name just deleted. In either case, only the first value found searching PERL_ENV_TABLES is altered. It is not possible at present to define a search list logical name via %ENV.</source>
          <target state="translated">当 &lt;code&gt;%ENV&lt;/code&gt; 的元素设置为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 时，将查找该元素，就像正在读取该元素一样；如果找到该元素，则将其删除。 （将从CRTL &lt;code&gt;environ&lt;/code&gt; 数组中&amp;ldquo;删除&amp;rdquo;的项设置为空字符串。）使用 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;%ENV&lt;/code&gt; 中删除元素具有类似的效果，但是在删除该元素之后，会再次尝试查找该元素，因此内部模式逻辑名称或其他位置的名称将替换刚刚删除的逻辑名称。在这两种情况下，只有搜索PERL_ENV_TABLES时找到的第一个值都会被更改。目前尚无法通过％ENV定义搜索列表逻辑名。</target>
        </trans-unit>
        <trans-unit id="f3d5e830d380d586cadba3ebb3b0b5993def5162" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to a defined string, the corresponding definition is made in the location to which the first translation of</source>
          <target state="translated">当 &lt;code&gt;%ENV&lt;/code&gt; 的元素设置为已定义的字符串时，将在以下位置进行相应的定义：</target>
        </trans-unit>
        <trans-unit id="6e4667405eb0016e589d7ee3b3978551b835b138" translate="yes" xml:space="preserve">
          <source>When an install fails for some reason and then I correct the error condition and retry, CPAN.pm refuses to install the module, saying &lt;code&gt;Already tried without success&lt;/code&gt; .</source>
          <target state="translated">如果安装由于某种原因而失败，然后我纠正了错误情况并重试，则CPAN.pm拒绝安装该模块，并说&amp;ldquo; &lt;code&gt;Already tried without success&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88b449cc559ca252d850238032174c7042fa310e" translate="yes" xml:space="preserve">
          <source>When an undefined layer 'foo' is encountered in an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; layer specification then C code performs the equivalent of:</source>
          <target state="translated">当在 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 层或 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 层规范中遇到未定义的层'foo'时，C代码将执行以下操作：</target>
        </trans-unit>
        <trans-unit id="05eb98d8070a762d6a7fd65d464d57e96f47f0ef" translate="yes" xml:space="preserve">
          <source>When an updir path like &quot;:::lib::&quot; is passed as argument, the number of directories to climb up is handled correctly, not removing leading or trailing colons when necessary. E.g.</source>
          <target state="translated">当传递&quot;:::lib::&quot;这样的updir路径作为参数时,会正确处理要爬升的目录数,必要时不会去掉前导或尾部的冒号。例如</target>
        </trans-unit>
        <trans-unit id="fc030f96c1c92f54f8dacedeb177bdbc127fdac6" translate="yes" xml:space="preserve">
          <source>When an uppercase and lowercase letter both exist in the table, then the uppercase letter is typically used to represent some kind of composite type (a list or a hash), and the lowercase letter is used to represent an element of that composite type. Some internals code makes use of this case relationship. However, 'v' and 'V' (vec and v-string) are in no way related.</source>
          <target state="translated">当表中同时存在大写字母和小写字母时,那么大写字母通常用来表示某种复合类型(列表或哈希),小写字母用来表示该复合类型的一个元素。一些内部代码就利用了这种大小写关系。但是,'v'和'V'(vec和v-string)没有任何关系。</target>
        </trans-unit>
        <trans-unit id="34009ee0cae148f2a1680a702fb847661476a204" translate="yes" xml:space="preserve">
          <source>When and whether to use small caps is somewhat tricky, and Pod::Man doesn't necessarily get it right.</source>
          <target state="translated">什么时候用、是否用小写字母有些棘手,Pod::Man也不一定能做好。</target>
        </trans-unit>
        <trans-unit id="50a0e6b3c1e9721563cfa37763282c6acaf8fe8f" translate="yes" xml:space="preserve">
          <source>When applied to the following command line:</source>
          <target state="translated">当应用到以下命令行时。</target>
        </trans-unit>
        <trans-unit id="a01d1e59657f16ebb14cc78dbc769393ad07bd40" translate="yes" xml:space="preserve">
          <source>When auto-detecting the compressed format, try to test for lzma_alone content using the &lt;code&gt;IO::Uncompress::UnLzma&lt;/code&gt; module.</source>
          <target state="translated">当自动检测压缩格式时，请尝试使用 &lt;code&gt;IO::Uncompress::UnLzma&lt;/code&gt; 模块测试lzma_alone内容。</target>
        </trans-unit>
        <trans-unit id="3afc2592b2e6769a24dccd537ec52009da2c39f6" translate="yes" xml:space="preserve">
          <source>When auto-detecting the compressed format, try to test for raw-deflate (RFC 1951) content using the &lt;code&gt;IO::Uncompress::RawInflate&lt;/code&gt; module.</source>
          <target state="translated">自动检测压缩格式时，请尝试使用 &lt;code&gt;IO::Uncompress::RawInflate&lt;/code&gt; 模块测试原始压缩（RFC 1951）内容。</target>
        </trans-unit>
        <trans-unit id="11c4b6b6311800f4181591dd698a41134ea1ef8b" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; are used at the same time, the regexp has to match both the beginning and the end of the string, i.e., the regexp matches the whole string. Consider</source>
          <target state="translated">当同时使用 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 时，正则表达式必须匹配字符串的开头和结尾，即，正则表达式匹配整个字符串。考虑</target>
        </trans-unit>
        <trans-unit id="0058d0939f56e0836aecac00731cc26dae5c908c" translate="yes" xml:space="preserve">
          <source>When both A and P are undefined, this is used as a fallback accuracy when dividing numbers.</source>
          <target state="translated">当A和P都未定义时,这是在除数时作为后备精度使用的。</target>
        </trans-unit>
        <trans-unit id="060766cfa822ddf97bd7bc65f3fc7e729b274423" translate="yes" xml:space="preserve">
          <source>When building 64-bit modules, it is your responsibility to ensure that linked external libraries and frameworks provide 64-bit support: if they do not, module building may appear to succeed, but attempts to use the module will result in run-time dynamic linking errors, and subsequent test failures. You can use &lt;code&gt;file&lt;/code&gt; to discover the architectures supported by a library:</source>
          <target state="translated">构建64位模块时，您有责任确保链接的外部库和框架提供64位支持：如果不提供，则模块构建可能会成功，但是尝试使用模块将导致运行时动态变化链接错误以及随后的测试失败。您可以使用 &lt;code&gt;file&lt;/code&gt; 来发现库支持的体系结构：</target>
        </trans-unit>
        <trans-unit id="d21008e482052b445cfd243ad8bc31adfd3249b5" translate="yes" xml:space="preserve">
          <source>When building Perl it will always return true, as nothing is installed yet.</source>
          <target state="translated">当构建Perl时,它将总是返回true,因为还没有安装任何东西。</target>
        </trans-unit>
        <trans-unit id="aaf49b07a212f715b8dd8f309b5c78af1bf1e342" translate="yes" xml:space="preserve">
          <source>When built on an ODS-5 volume with symbolic links enabled, Perl by default supports symbolic links when the requisite support is available in the filesystem and CRTL (generally 64-bit OpenVMS v8.3 and later). There are a number of limitations and caveats to be aware of when working with symbolic links on VMS. Most notably, the target of a valid symbolic link must be expressed as a Unix-style path and it must exist on a volume visible from your POSIX root (see the &lt;code&gt;SHOW ROOT&lt;/code&gt; command in DCL help). For further details on symbolic link capabilities and requirements, see chapter 12 of the CRTL manual that ships with OpenVMS v8.3 or later.</source>
          <target state="translated">当在启用了符号链接的ODS-5卷上构建时，默认情况下，当文件系统和CRTL（通常是64位OpenVMS v8.3和更高版本）中提供必要的支持时，Perl将支持符号链接。在VMS上使用符号链接时，需要注意许多限制和警告。最值得注意的是，有效符号链接的目标必须表示为Unix样式的路径，并且必须存在于POSIX根目录可见的卷上（请参阅DCL帮助中的 &lt;code&gt;SHOW ROOT&lt;/code&gt; 命令）。有关符号链接功能和要求的更多详细信息，请参阅OpenVMS v8.3或更高版本随附的CRTL手册的第12章。</target>
        </trans-unit>
        <trans-unit id="3274ae41eb972b48380cd0be38746ee76dc6d9df" translate="yes" xml:space="preserve">
          <source>When bundling is in effect, case is ignored on single-character options also.</source>
          <target state="translated">当捆绑生效时,单字符选项的大小写也会被忽略。</target>
        </trans-unit>
        <trans-unit id="534230020f5629c55b27da34563c08514a84a5c7" translate="yes" xml:space="preserve">
          <source>When calculating specific times, such as for tests in time or date modules, it may be appropriate to calculate an offset for the epoch.</source>
          <target state="translated">当计算特定的时间时,如在时间或日期模块中进行测试,可能需要计算一个纪元的偏移量。</target>
        </trans-unit>
        <trans-unit id="9da2af35b4e027fcb57324a97e158a9219d7749d" translate="yes" xml:space="preserve">
          <source>When called from a thread, this behaves like &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; (i.e., the exit status code is ignored).</source>
          <target state="translated">从线程调用时，其行为类似于 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; （即，退出状态代码将被忽略）。</target>
        </trans-unit>
        <trans-unit id="9c8531e379ee34158f961b216941a888acd13144" translate="yes" xml:space="preserve">
          <source>When called from the</source>
          <target state="translated">呼叫时,从</target>
        </trans-unit>
        <trans-unit id="43350391a792d394d51fbfdf3323ff9bf611b150" translate="yes" xml:space="preserve">
          <source>When called in a scalar context &lt;code&gt;strtod&lt;/code&gt; returns the parsed number.</source>
          <target state="translated">在标量上下文中调用时， &lt;code&gt;strtod&lt;/code&gt; 返回已解析的数字。</target>
        </trans-unit>
        <trans-unit id="da1211ed8e0b63c4bc2cdd7832083442b210dfa8" translate="yes" xml:space="preserve">
          <source>When called in a scalar context &lt;code&gt;strtol&lt;/code&gt; returns the parsed number.</source>
          <target state="translated">在标量上下文中调用时， &lt;code&gt;strtol&lt;/code&gt; 返回已解析的数字。</target>
        </trans-unit>
        <trans-unit id="cd23c4a922c775b095b3cd879f0e839934775a17" translate="yes" xml:space="preserve">
          <source>When called in list context, a filehandle to the open file and a filename are returned. This is achieved by calling mkstemp() after constructing a suitable template.</source>
          <target state="translated">当在列表上下文中调用时,将返回一个打开文件的filehandle和一个文件名。这是通过在构建一个合适的模板后调用mkstemp()实现的。</target>
        </trans-unit>
        <trans-unit id="c3dee4680a21f3b47b4b6c94d86c7920c11b3ca5" translate="yes" xml:space="preserve">
          <source>When called in scalar context, returns the full name (including path) of a temporary file (uses mktemp()). The only check is that the file does not already exist, but there is no guarantee that that condition will continue to apply.</source>
          <target state="translated">当在标量上下文中调用时,返回一个临时文件的全名(包括路径)(使用mktemp())。唯一的检查是该文件是否已经存在,但不保证该条件会继续适用。</target>
        </trans-unit>
        <trans-unit id="a89727e96b1fd47a54daec87adf9ead3599db8aa" translate="yes" xml:space="preserve">
          <source>When called on a hash in list context, returns a 2-element list consisting of the key and value for the next element of a hash. In Perl 5.12 and later only, it will also return the index and value for the next element of an array so that you can iterate over it; older Perls consider this a syntax error. When called in scalar context, returns only the key (not the value) in a hash, or the index in an array.</source>
          <target state="translated">当在列表上下文中调用哈希时,返回一个由哈希下一个元素的键和值组成的2元素列表。仅在Perl 5.12及以后的版本中,它还将返回数组中下一个元素的索引和值,这样你就可以在数组上进行迭代;旧版Perl认为这是一个语法错误。当在标量上下文中调用时,只返回哈希中的键(不是值),或者数组中的索引。</target>
        </trans-unit>
        <trans-unit id="a0114581d0437322ee0322acd573e8db3818a675" translate="yes" xml:space="preserve">
          <source>When called with a port number, the port number used to ping is set to $port_number rather than using the echo port. It also has the effect of calling &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; causing a ping to return a successful response only if that specific port is accessible. This function returns the value of the port that &lt;code&gt;ping()&lt;/code&gt; will connect to.</source>
          <target state="translated">当使用端口号调用时，用于ping的端口号设置为$ port_number而不是使用echo端口。它还具有调用 &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; 的作用，仅当该特定端口可访问时，ping才会返回成功的响应。此函数返回 &lt;code&gt;ping()&lt;/code&gt; 将连接的端口的值。</target>
        </trans-unit>
        <trans-unit id="f7e732b0f6b3939ab5bc51276cb4115c5f3c0e3c" translate="yes" xml:space="preserve">
          <source>When called with a property that is a Perl extension that isn't expressible in a compound form, this function currently returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, as the only two possible values are</source>
          <target state="translated">当使用无法以复合形式表示的Perl扩展属性来调用该函数时，此函数当前返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，因为只有两个可能的值是</target>
        </trans-unit>
        <trans-unit id="d7f088f6cc700d00236d5621c430de681ccc4d48" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;Mksymlists&lt;/code&gt; , one should always specify the NAME attribute. In most cases, this is all that's necessary. In the case of unusual extensions, however, the other attributes can be used to provide additional information to the linker.</source>
          <target state="translated">调用 &lt;code&gt;Mksymlists&lt;/code&gt; 时，应始终指定NAME属性。在大多数情况下，这就是必需的。但是，在异常扩展的情况下，其他属性可以用于向链接器提供其他信息。</target>
        </trans-unit>
        <trans-unit id="fb764d0e74f6cde0aeec88532fcd886bfa4b9853" translate="yes" xml:space="preserve">
          <source>When choosing a language you should also be influenced by the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;resources&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpantesters.org%2f&quot;&gt;testing culture&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fcommunity.html&quot;&gt;community&lt;/a&gt; which surrounds it.</source>
          <target state="translated">选择语言时，还应该受到&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;资源&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpantesters.org%2f&quot;&gt;测试文化&lt;/a&gt;和周围&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fcommunity.html&quot;&gt;社区的&lt;/a&gt;影响。</target>
        </trans-unit>
        <trans-unit id="28fc2ee6241766189106d0612895f0d6c35cb4ac" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; accepts.</source>
          <target state="translated">选择新的盐时，创建一个随机的两个字符串，其字符来自集合 &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; （例如 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ）。这组字符只是一个建议；盐中允许的字符仅取决于系统的crypt库，Perl不能限制 &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; 接受的盐。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
