<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="2859cc3896fe55bbb891ae357f5f5a8329f3cec3" translate="yes" xml:space="preserve">
          <source>Perl 5.10 added three specials, &lt;code&gt;${^MATCH}&lt;/code&gt;, &lt;code&gt;${^PREMATCH}&lt;/code&gt;, and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; to do the same job but without the global performance penalty. Perl 5.10 only sets these variables if you compile or execute the regular expression with the &lt;code&gt;/p&lt;/code&gt; modifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce44e09ff142e65fee17e89d97567bf27f5d29b1" translate="yes" xml:space="preserve">
          <source>Perl 5.10 also introduced named capture groups and named backreferences. To attach a name to a capturing group, you write either &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; or &lt;code&gt;(?'name'...)&lt;/code&gt;. The backreference may then be written as &lt;code&gt;\g{name}&lt;/code&gt; . It is permissible to attach the same name to more than one group, but then only the leftmost one of the eponymous set can be referenced. Outside of the pattern a named capture group is accessible through the &lt;code&gt;%+&lt;/code&gt; hash.</source>
          <target state="translated">Perl 5.10还引入了命名捕获组和命名后向引用。要将名称附加到捕获组，请编写 &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; 或 &lt;code&gt;(?'name'...)&lt;/code&gt; 。然后可以将后向引用写为 &lt;code&gt;\g{name}&lt;/code&gt; 。允许将相同的名称附加到多个组中，但是只能引用同义集合中最左边的一组。在模式之外，可以通过 &lt;code&gt;%+&lt;/code&gt; 哈希访问命名的捕获组。</target>
        </trans-unit>
        <trans-unit id="115264f71824b47785d298c1ef35a6a89f372587" translate="yes" xml:space="preserve">
          <source>Perl 5.10 also introduced named capture groups and named backreferences. To attach a name to a capturing group, you write either &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; or &lt;code&gt;(?'name'...)&lt;/code&gt;. The backreference may then be written as &lt;code&gt;\g{name}&lt;/code&gt;. It is permissible to attach the same name to more than one group, but then only the leftmost one of the eponymous set can be referenced. Outside of the pattern a named capture group is accessible through the &lt;code&gt;%+&lt;/code&gt; hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78bc07daf7287cd2d82e764c55679c183debb95" translate="yes" xml:space="preserve">
          <source>Perl 5.10 introduced a number of control verbs intended to provide detailed control over the backtracking process, by directly influencing the regexp engine and by providing monitoring techniques. As all the features in this group are experimental and subject to change or removal in a future version of Perl, the interested reader is referred to &lt;a href=&quot;perlre#Special-Backtracking-Control-Verbs&quot;&gt;Special Backtracking Control Verbs in perlre&lt;/a&gt; for a detailed description.</source>
          <target state="translated">Perl 5.10引入了许多控制动词，旨在通过直接影响正则表达式引擎并提供监视技术来提供对回溯过程的详细控制。由于该组中的所有功能都是实验性的，并且在Perl的将来版本中可能会更改或删除，因此有兴趣的读者可以参考&lt;a href=&quot;perlre#Special-Backtracking-Control-Verbs&quot;&gt;perlre&lt;/a&gt;中的&amp;ldquo; 特殊回溯控制动词&amp;rdquo;以获取详细说明。</target>
        </trans-unit>
        <trans-unit id="8d197238627a1653007f58ee33834bfb110a45a3" translate="yes" xml:space="preserve">
          <source>Perl 5.10 introduced a number of control verbs intended to provide detailed control over the backtracking process, by directly influencing the regexp engine and by providing monitoring techniques. See &lt;a href=&quot;perlre#Special-Backtracking-Control-Verbs&quot;&gt;&quot;Special Backtracking Control Verbs&quot; in perlre&lt;/a&gt; for a detailed description.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584eeb9af5c995523642f05c75ed86704463abbd" translate="yes" xml:space="preserve">
          <source>Perl 5.10.0 has a bug when compiled with newer gcc versions. This bug causes a segfault whenever a new thread is launched. Test2 will attempt to detect this, and note that the system is not capable of forking when it is detected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8fc66ff20f940e5def5d5b04e16e404fe2d5094" translate="yes" xml:space="preserve">
          <source>Perl 5.12 an newer is not compatible with the IBM fileset perl.libext.</source>
          <target state="translated">Perl 5.12 或更新的版本与 IBM 文件集 perl.libext 不兼容。</target>
        </trans-unit>
        <trans-unit id="22c1a552baa41f722e50e202fb00024c3ebfb6db" translate="yes" xml:space="preserve">
          <source>Perl 5.16</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea53addd5f513ae8ff9630b1ab8b434a441c0d82" translate="yes" xml:space="preserve">
          <source>Perl 5.16 introduced a slightly more efficient mechanism that notes separately whether each of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; , and &lt;code&gt;$'&lt;/code&gt; have been seen, and thus may only need to copy part of the string. Perl 5.20 introduced a much more efficient copy-on-write mechanism which eliminates any slowdown.</source>
          <target state="translated">Perl 5.16引入了一种效率更高的机制，该机制可以单独记录 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 和 &lt;code&gt;$'&lt;/code&gt; 中的每一个是否已被看到，因此可能只需要复制部分字符串。Perl 5.20引入了一种效率更高的写时复制机制，该机制消除了任何速度下降问题。</target>
        </trans-unit>
        <trans-unit id="a1e98cc406baf109c9d02615750864a42131b157" translate="yes" xml:space="preserve">
          <source>Perl 5.16 introduced a slightly more efficient mechanism that notes separately whether each of &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt;, and &lt;code&gt;$'&lt;/code&gt; have been seen, and thus may only need to copy part of the string. Perl 5.20 introduced a much more efficient copy-on-write mechanism which eliminates any slowdown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecdd633a06acc3333c70644f93001a3679676523" translate="yes" xml:space="preserve">
          <source>Perl 5.18 introduced a new class, B::PADLIST, returned by B::CV's &lt;code&gt;PADLIST&lt;/code&gt; method.</source>
          <target state="translated">Perl 5.18引入了一个新类B :: PADLIST，由B :: CV的 &lt;code&gt;PADLIST&lt;/code&gt; 方法返回。</target>
        </trans-unit>
        <trans-unit id="6b567ee259b41361a0ad9018ea4088cb70239efc" translate="yes" xml:space="preserve">
          <source>Perl 5.22 also introduces the experimental &quot;const&quot; attribute as an alternative. (Disable the &quot;experimental::const_attr&quot; warnings if you want to use it.) When applied to an anonymous subroutine, it forces the sub to be called when the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; expression is evaluated. The return value is captured and turned into a constant subroutine:</source>
          <target state="translated">Perl 5.22还引入了实验性的&amp;ldquo; const&amp;rdquo;属性作为替代。（如果要使用它，请禁用&amp;ldquo; experimental :: const_attr&amp;rdquo;警告。）当应用于匿名子例程时，它将在评估 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 表达式时强制调用该子例程。捕获返回值并将其转换为常量子例程：</target>
        </trans-unit>
        <trans-unit id="31d7199897d8b920eebab904073bac73dc70089f" translate="yes" xml:space="preserve">
          <source>Perl 5.22 also introduces the experimental &quot;const&quot; attribute as an alternative. (Disable the &quot;experimental::const_attr&quot; warnings if you want to use it.) When applied to an anonymous subroutine, it forces the sub to be called when the &lt;code&gt;sub&lt;/code&gt; expression is evaluated. The return value is captured and turned into a constant subroutine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5bb1f9d37da5d5c2d35eb2fe5db684768a1718" translate="yes" xml:space="preserve">
          <source>Perl 5.22 introduced the B::PADNAMELIST and B::PADNAME classes.</source>
          <target state="translated">Perl 5.22引入了B::PADNAMELIST和B::PADNAME类。</target>
        </trans-unit>
        <trans-unit id="8eb64573fd28436266ef8b83ae879c922aa2718a" translate="yes" xml:space="preserve">
          <source>Perl 5.24</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d54e9a22b86ccb042ec9ad9cdcb8b20f3feb99" translate="yes" xml:space="preserve">
          <source>Perl 5.26</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7d5255cbd686c042840f5ff2f1c80ef3b153ed" translate="yes" xml:space="preserve">
          <source>Perl 5.28</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87966d58d51aae325250821ef9dbcdd86c8cbe91" translate="yes" xml:space="preserve">
          <source>Perl 5.30</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="366edd1a774f9c1660a61ddaa3d7c12fc7af5703" translate="yes" xml:space="preserve">
          <source>Perl 5.32</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16cebccb7e37f3bcda23a91f5a5b4aa3276930af" translate="yes" xml:space="preserve">
          <source>Perl 5.32.0 Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2d0ccd58dc8c574da7bcb06529ab63a9227edf7" translate="yes" xml:space="preserve">
          <source>Perl 5.34</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c423e3fdc417abd5c0a870160561ad280c5b05c" translate="yes" xml:space="preserve">
          <source>Perl 5.6 added support for Unicode characters with code points &amp;gt; 255, and Perl 5.8 has full support for Unicode characters in hash keys. Perl internally encodes strings with these characters using utf8, and Storable serializes them as utf8. By default, if an older version of Perl encounters a utf8 value it cannot represent, it will &lt;code&gt;croak()&lt;/code&gt; . To change this behaviour so that Storable deserializes utf8 encoded values as the string of bytes (effectively dropping the</source>
          <target state="translated">Perl 5.6添加了对代码点&amp;gt; 255的Unicode字符的支持，而Perl 5.8对哈希键中的Unicode字符提供了完全支持。Perl使用utf8在内部使用这些字符编码字符串，而Storable将其序列化为utf8。默认情况下，如果旧版本的Perl遇到它无法表示的utf8值，它将 &lt;code&gt;croak()&lt;/code&gt; 。要更改此行为，以便Storable将utf8编码的值反序列化为字节串（有效地删除了</target>
        </trans-unit>
        <trans-unit id="cde995577e5439f98ee44f0a1873e0f95b95226b" translate="yes" xml:space="preserve">
          <source>Perl 5.6 added support for Unicode characters with code points &amp;gt; 255, and Perl 5.8 has full support for Unicode characters in hash keys. Perl internally encodes strings with these characters using utf8, and Storable serializes them as utf8. By default, if an older version of Perl encounters a utf8 value it cannot represent, it will &lt;code&gt;croak()&lt;/code&gt;. To change this behaviour so that Storable deserializes utf8 encoded values as the string of bytes (effectively dropping the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d666cc8f0c2aafb781a5c3ee7854aa462c22563" translate="yes" xml:space="preserve">
          <source>Perl 5.6 and earlier used a quicksort algorithm to implement sort. That algorithm was not stable, so</source>
          <target state="translated">Perl 5.6 和更早的版本使用 quicksort 算法来实现 sort。这种算法并不稳定,所以</target>
        </trans-unit>
        <trans-unit id="cc23cb198586dd32a543690c051c8df0366d1085" translate="yes" xml:space="preserve">
          <source>Perl 5.6 lets you write binary numbers directly with the &lt;code&gt;0b&lt;/code&gt; notation:</source>
          <target state="translated">Perl 5.6允许您直接使用 &lt;code&gt;0b&lt;/code&gt; 表示法编写二进制数字：</target>
        </trans-unit>
        <trans-unit id="45926b613d53010c55908af141dded6cf0223b03" translate="yes" xml:space="preserve">
          <source>Perl 5.6.0 introduced Unicode support. It's important for porters and XS writers to understand this support and make sure that the code they write does not corrupt Unicode data.</source>
          <target state="translated">Perl 5.6.0 引入了 Unicode 支持。对于移植者和 XS 编写者来说,理解这种支持并确保他们编写的代码不会损坏 Unicode 数据非常重要。</target>
        </trans-unit>
        <trans-unit id="d766774f1389bd4f4ba4c170949b6d3cfbd45c53" translate="yes" xml:space="preserve">
          <source>Perl 5.6.x introduced the ability to optional configure the perl interpreter to use C's &lt;code&gt;long long&lt;/code&gt; type to allow scalars to store 64 bit integers on 32 bit systems. However, due to the way the Perl configuration system generated the C configuration files on non-Windows platforms, and the way Storable generates its header, nothing in the Storable file header reflected whether the perl writing was using 32 or 64 bit integers, despite the fact that Storable was storing some data differently in the file. Hence Storable running on perl with 64 bit integers will read the header from a file written by a 32 bit perl, not realise that the data is actually in a subtly incompatible format, and then go horribly wrong (possibly crashing) if it encountered a stored integer. This is a design failure.</source>
          <target state="translated">Perl 5.6.x引入了对Perl解释器进行可选配置的功能，以使用C的 &lt;code&gt;long long&lt;/code&gt; 类型来允许标量在32位系统上存储64位整数。但是，由于Perl配置系统在非Windows平台上生成C配置文件的方式以及Storable生成其标头的方式，尽管在存储方式中，Perl配置标头中的任何内容都无法反映出Perl编写是使用32位还是64位整数。 Storable在文件中存储某些数据的事实。因此，在具有64位整数的perl上运行的Storable会从由32位perl写入的文件中读取标头，而不是意识到数据实际上是微妙不兼容的格式，然后如果遇到存储错误，则会出现严重错误（可能崩溃）整数。这是设计失败。</target>
        </trans-unit>
        <trans-unit id="85ca30a6ededa148e4bfea0d2618456fe4f02a72" translate="yes" xml:space="preserve">
          <source>Perl 5.8 adds support for restricted hashes, which have keys restricted to a given set, and can have values locked to be read only. By default, when Storable encounters a restricted hash on a perl that doesn't support them, it will deserialize it as a normal hash, silently discarding any placeholder keys and leaving the keys and all values unlocked. To make Storable &lt;code&gt;croak()&lt;/code&gt; instead, set &lt;code&gt;$Storable::downgrade_restricted&lt;/code&gt; to a &lt;code&gt;FALSE&lt;/code&gt; value. To restore the default set it back to some &lt;code&gt;TRUE&lt;/code&gt; value.</source>
          <target state="translated">Perl 5.8增加了对受限散列的支持，散列的键限于给定的集合，并且可以将值锁定为只读。默认情况下，当Storable在不支持它们的perl上遇到受限哈希时，它将以反序列化的形式将其作为普通哈希，静默丢弃任何占位符键，并保留键和所有值的解锁状态。要改用Storable &lt;code&gt;croak()&lt;/code&gt; ，请将 &lt;code&gt;$Storable::downgrade_restricted&lt;/code&gt; 设置为 &lt;code&gt;FALSE&lt;/code&gt; 值。要恢复默认值，请将其设置回一些 &lt;code&gt;TRUE&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="565a4d4fa800ce5182da9b6ba981e8a739829623" translate="yes" xml:space="preserve">
          <source>Perl 5.8.0 added support for Unicode on EBCDIC platforms. This support was allowed to lapse in later releases, but was revived in 5.22. Unicode support is somewhat more complex to implement since additional conversions are needed. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt; for more information.</source>
          <target state="translated">Perl 5.8.0在EBCDIC平台上增加了对Unicode的支持。在以后的版本中，该支持不再有效，但在5.22中恢复了。由于需要额外的转换，因此实现Unicode支持稍微复杂一些。有关更多信息，请参见&lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d3bf07733afdb8eccda724369492b44b06d3912" translate="yes" xml:space="preserve">
          <source>Perl 5.8.0 and later avoid these problems by &quot;deferring&quot; signals. That is, when the signal is delivered to the process by the system (to the C code that implements Perl) a flag is set, and the handler returns immediately. Then at strategic &quot;safe&quot; points in the Perl interpreter (e.g. when it is about to execute a new opcode) the flags are checked and the Perl level handler from %SIG is executed. The &quot;deferred&quot; scheme allows much more flexibility in the coding of signal handlers as we know the Perl interpreter is in a safe state, and that we are not in a system library function when the handler is called. However the implementation does differ from previous Perls in the following ways:</source>
          <target state="translated">Perl 5.8.0及以后的版本通过 &quot;延迟 &quot;信号来避免这些问题。也就是说,当系统将信号传递给进程时(传递给实现Perl的C代码),会设置一个标志,处理程序会立即返回。然后在Perl解释器中的战略 &quot;安全 &quot;点(例如当它要执行一个新的操作码时)检查标志,并执行%SIG的Perl级处理程序。延迟 &quot;方案允许信号处理程序的编码更加灵活,因为我们知道Perl解释器处于安全状态,而且当处理程序被调用时,我们不在系统库函数中。然而在实现上确实与以前的Perls有以下不同。</target>
        </trans-unit>
        <trans-unit id="e73fd9ce0c7c872add12735883aa527cd3cbf5df" translate="yes" xml:space="preserve">
          <source>Perl 5.8.0 or later</source>
          <target state="translated">Perl 5.8.0或更高版本</target>
        </trans-unit>
        <trans-unit id="5a0af5a1468c03fa40c2af7be5d9056970a7782e" translate="yes" xml:space="preserve">
          <source>Perl 5.8.1 and beyond are able to automatically quote v-strings but that is not possible in earlier versions of Perl. In other words:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8757ee96021b145f4cb52d1033c040338543b5" translate="yes" xml:space="preserve">
          <source>Perl 6 is a reinvention of Perl, it is a language in the same lineage but not compatible. The two are complementary, not mutually exclusive. Perl 6 is not meant to replace Perl 5, and vice versa. See &lt;a href=&quot;#What-is-Perl-6%3f&quot;&gt;What is Perl 6?&lt;/a&gt; below to find out more.</source>
          <target state="translated">Perl 6是Perl的重新发明，它是同一种谱系中的一种语言，但不兼容。两者是互补的，而不是相互排斥的。Perl 6并不是要取代Perl 5，反之亦然。请参阅&lt;a href=&quot;#What-is-Perl-6%3f&quot;&gt;什么是Perl 6？&lt;/a&gt;在下面找到更多。</target>
        </trans-unit>
        <trans-unit id="70eed57e9021b8ec1bdc60c299cf0007c990e85c" translate="yes" xml:space="preserve">
          <source>Perl 6 was</source>
          <target state="translated">Perl 6是</target>
        </trans-unit>
        <trans-unit id="c935317046cb2fe37bcb5104606c71edb33387e0" translate="yes" xml:space="preserve">
          <source>Perl &lt;b&gt;borrows syntax&lt;/b&gt; and concepts from many languages: awk, sed, C, Bourne Shell, Smalltalk, Lisp and even English. Other languages have borrowed syntax from Perl, particularly its regular expression extensions. So if you have programmed in another language you will see familiar pieces in Perl. They often work the same, but see &lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt; for information about how they differ.</source>
          <target state="translated">Perl 从多种语言中&lt;b&gt;借用了语法&lt;/b&gt;和概念：awk，sed，C，Bourne Shell，Smalltalk，Lisp甚至是英语。其他语言从Perl借用了语法，尤其是其正则表达式扩展。因此，如果您使用其他语言编程，您将在Perl中看到熟悉的部分。它们的工作原理通常相同，但是请参见&lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt;以获取有关它们之间的区别的信息。</target>
        </trans-unit>
        <trans-unit id="a37780bb487077495edf8f34f760c1da9044ebae" translate="yes" xml:space="preserve">
          <source>Perl API not supported by ppport.h</source>
          <target state="translated">ppport.h不支持Perl API。</target>
        </trans-unit>
        <trans-unit id="50704605d6b6262fd96cb32c233850a8761b03e3" translate="yes" xml:space="preserve">
          <source>Perl API version %s of %s does not match %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b7471df455475e2c7d2175b53792162c97edfe3" translate="yes" xml:space="preserve">
          <source>Perl Authors Upload Server. Contains links to information for module authors.</source>
          <target state="translated">Perl作者上传服务器。包含模块作者信息的链接。</target>
        </trans-unit>
        <trans-unit id="8bf74964bb9b0e9e3d4da81f0703933934a7c358" translate="yes" xml:space="preserve">
          <source>Perl Best Practices</source>
          <target state="translated">Perl最佳实践</target>
        </trans-unit>
        <trans-unit id="2cc43b42e51a4a8837fffe3af550658174edb610" translate="yes" xml:space="preserve">
          <source>Perl Books</source>
          <target state="translated">Perl书籍</target>
        </trans-unit>
        <trans-unit id="ed1deb6e5d999d91341ff20898eb3858a1d9c995" translate="yes" xml:space="preserve">
          <source>Perl Bugs and the CPAN Version of &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a9e748e5c4dd7f9dfa7cc95a251e60be896a8f" translate="yes" xml:space="preserve">
          <source>Perl Classes</source>
          <target state="translated">Perl类</target>
        </trans-unit>
        <trans-unit id="e482403a1124e0521d166c90c8a0769c85673b5e" translate="yes" xml:space="preserve">
          <source>Perl Cookbook</source>
          <target state="translated">Perl Cookbook</target>
        </trans-unit>
        <trans-unit id="d4efb54c65e7e3af46d13e87c7581a8dcba624d0" translate="yes" xml:space="preserve">
          <source>Perl DLL</source>
          <target state="translated">Perl DLL</target>
        </trans-unit>
        <trans-unit id="aeebc1579f8d617b27fe89ad608591410feec7ff" translate="yes" xml:space="preserve">
          <source>Perl Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3283f18cd28cbde0549accd86697398505934bb4" translate="yes" xml:space="preserve">
          <source>Perl Editor by EngInSite is a complete integrated development environment (IDE) for creating, testing, and debugging Perl scripts; the tool runs on Windows 9x/NT/2000/XP or later.</source>
          <target state="translated">EngInSite的Perl Editor是一个完整的集成开发环境(IDE),用于创建、测试和调试Perl脚本;该工具可在Windows 9x/NT/2000/XP或更高版本上运行。</target>
        </trans-unit>
        <trans-unit id="7ac9d4c93ef979889b211c88f596e981156f45f4" translate="yes" xml:space="preserve">
          <source>Perl Extensions</source>
          <target state="translated">Perl扩展</target>
        </trans-unit>
        <trans-unit id="f71fad82087d419a133c0dced88c67e1f9877063" translate="yes" xml:space="preserve">
          <source>Perl FAQ</source>
          <target state="translated">Perl FAQ</target>
        </trans-unit>
        <trans-unit id="da7c8c4aaafde8c9b2e5f84c7552444fbb08c636" translate="yes" xml:space="preserve">
          <source>Perl Fails Because Of Unresolved Symbol sockatmark</source>
          <target state="translated">由于未解决的符号 sockatmark,Perl 失败。</target>
        </trans-unit>
        <trans-unit id="7c3d43451e7cda778a3f9c97b52abf3fd44bedb9" translate="yes" xml:space="preserve">
          <source>Perl Functions by Category</source>
          <target state="translated">按类别划分的Perl函数</target>
        </trans-unit>
        <trans-unit id="920e14089fbbc423ee2d5724c1de68632aef3813" translate="yes" xml:space="preserve">
          <source>Perl GNU Info Files on AmigaOS</source>
          <target state="translated">Perl GNU信息文件在AmigaOS上的应用</target>
        </trans-unit>
        <trans-unit id="37de2a8ad505f52fcef06a6993c850291e480520" translate="yes" xml:space="preserve">
          <source>Perl HTML Documentation on AmigaOS</source>
          <target state="translated">AmigaOS上的Perl HTML文档</target>
        </trans-unit>
        <trans-unit id="05eb1caf8706fb276d9b12087337d5c6103138c5" translate="yes" xml:space="preserve">
          <source>Perl LaTeX Documentation on AmigaOS</source>
          <target state="translated">AmigaOS上的Perl LaTeX文档</target>
        </trans-unit>
        <trans-unit id="04d3717cc2f7e5ee505e9248aa236712bb68755e" translate="yes" xml:space="preserve">
          <source>Perl Module Tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a43bc6de8b72c656ec8849bbbaebef043357f9" translate="yes" xml:space="preserve">
          <source>Perl Modules</source>
          <target state="translated">Perl模块</target>
        </trans-unit>
        <trans-unit id="1444928d77d0dfce158ff301d3dbfb2b1588dd16" translate="yes" xml:space="preserve">
          <source>Perl Modules/Scripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="216d171ee4524430a28634ae1013da6c2f558efa" translate="yes" xml:space="preserve">
          <source>Perl Objects And C Structures</source>
          <target state="translated">Perl对象和C结构</target>
        </trans-unit>
        <trans-unit id="a472684894e509305085eced5d45bf35bf21cca5" translate="yes" xml:space="preserve">
          <source>Perl Smokers ( &lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build/&lt;/a&gt; and &lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build.reports/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build.reports/&lt;/a&gt; ) automatically test Perl source releases on platforms with various configurations.</source>
          <target state="translated">Perl吸烟者（&lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build/&lt;/a&gt;和&lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build.reports/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build.reports/&lt;/a&gt;）自动测试Perl在具有各种配置的平台上发布源代码。</target>
        </trans-unit>
        <trans-unit id="134999afb97cf5b769bf8c4b178dce62bcebf389" translate="yes" xml:space="preserve">
          <source>Perl Smokers ( &lt;a href=&quot;https://www.nntp.perl.org/group/perl.daily-build/&quot;&gt;https://www.nntp.perl.org/group/perl.daily-build/&lt;/a&gt; and &lt;a href=&quot;https://www.nntp.perl.org/group/perl.daily-build.reports/&quot;&gt;https://www.nntp.perl.org/group/perl.daily-build.reports/&lt;/a&gt; ) automatically test Perl source releases on platforms with various configurations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b49734e895fa49b2262a8eac32c0a87b309e7f" translate="yes" xml:space="preserve">
          <source>Perl Source Filter</source>
          <target state="translated">Perl源码过滤器</target>
        </trans-unit>
        <trans-unit id="d9385cb28cfa7ddf46c00b8a389aa72f1c3ecd2f" translate="yes" xml:space="preserve">
          <source>Perl Source Filter Utility Module</source>
          <target state="translated">Perl源码过滤工具模块</target>
        </trans-unit>
        <trans-unit id="11827d68497a169d041d5a9b84cc14e0b5402701" translate="yes" xml:space="preserve">
          <source>Perl Threads Are Not X Threads</source>
          <target state="translated">Perl线程不是X线程</target>
        </trans-unit>
        <trans-unit id="0d5f49a6432453dfdae5c9b853d5d2137d7a3d82" translate="yes" xml:space="preserve">
          <source>Perl Traps</source>
          <target state="translated">Perl陷阱</target>
        </trans-unit>
        <trans-unit id="baee6a50a34759c52a5448ef022819377b034948" translate="yes" xml:space="preserve">
          <source>Perl VIO and PM executables (dynamically linked)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e81612c89b54aaefee5157e85c78728a2455e0ca" translate="yes" xml:space="preserve">
          <source>Perl XS' attempt at a solution to this is the concept of typemaps. At an abstract level, a Perl XS typemap is nothing but a recipe for converting from a certain Perl data structure to a certain C data structure and vice versa. Since there can be C types that are sufficiently similar to one another to warrant converting with the same logic, XS typemaps are represented by a unique identifier, henceforth called an &lt;b&gt;XS type&lt;/b&gt; in this document. You can then tell the XS compiler that multiple C types are to be mapped with the same XS typemap.</source>
          <target state="translated">Perl XS解决此问题的尝试是类型映射的概念。从抽象的角度来看，Perl XS类型图不过是从某种Perl数据结构转换为某种C数据结构，反之亦然的秘诀。由于可能存在彼此非常相似的C类型，因此需要使用相同的逻辑进行转换，因此&lt;b&gt;XS类型图&lt;/b&gt;由唯一的标识符表示，因此在本文档中称为&lt;b&gt;XS类型&lt;/b&gt;。然后，您可以告诉XS编译器将使用同一XS类型图映射多个C类型。</target>
        </trans-unit>
        <trans-unit id="5aedddb9bed4a6f9cc4928e309c3362165c3d8aa" translate="yes" xml:space="preserve">
          <source>Perl actually inserts the following code:</source>
          <target state="translated">Perl实际上插入了以下代码。</target>
        </trans-unit>
        <trans-unit id="0370590002494d49cbee29303986558b8c939d60" translate="yes" xml:space="preserve">
          <source>Perl actually stands for Pathologically Eclectic Rubbish Lister, but don't tell anyone I said that.</source>
          <target state="translated">Perl其实是Pathologically Eclectic Rubbish Lister的缩写,但别告诉别人是我说的。</target>
        </trans-unit>
        <trans-unit id="4ac1014663aa23e842df07d5739089aa502fbf6c" translate="yes" xml:space="preserve">
          <source>Perl adds magic to an SV using the sv_magic function:</source>
          <target state="translated">Perl 使用 sv_magic 函数为 SV 添加魔法。</target>
        </trans-unit>
        <trans-unit id="c3b8bb4554b031723a2e07241fd747dea1d44323" translate="yes" xml:space="preserve">
          <source>Perl after 5.8.7 has support for the &lt;code&gt;CLONE_SKIP&lt;/code&gt; special subroutine. Like &lt;code&gt;CLONE&lt;/code&gt; , &lt;code&gt;CLONE_SKIP&lt;/code&gt; is called once per package; however, it is called just before cloning starts, and in the context of the parent thread. If it returns a true value, then no objects of that class will be cloned; or rather, they will be copied as unblessed, undef values. For example: if in the parent there are two references to a single blessed hash, then in the child there will be two references to a single undefined scalar value instead. This provides a simple mechanism for making a module threadsafe; just add &lt;code&gt;sub CLONE_SKIP { 1 }&lt;/code&gt; at the top of the class, and &lt;code&gt;DESTROY()&lt;/code&gt; will now only be called once per object. Of course, if the child thread needs to make use of the objects, then a more sophisticated approach is needed.</source>
          <target state="translated">5.8.7之后的Perl支持 &lt;code&gt;CLONE_SKIP&lt;/code&gt; 特殊子例程。与 &lt;code&gt;CLONE&lt;/code&gt; 一样， &lt;code&gt;CLONE_SKIP&lt;/code&gt; 每个包被调用一次；但是，它在克隆开始之前以及在父线程的上下文中被调用。如果返回真值，则不会克隆该类的任何对象；或者更确切地说，它们将被复制为un福气，undef值。例如：如果在父级中有两个引用指向一个有福的哈希，那么在子级中将有两个引用指向一个未定义的标量值。这提供了使模块线程安全的简单机制。只需在类顶部添加 &lt;code&gt;sub CLONE_SKIP { 1 }&lt;/code&gt; ，然后添加 &lt;code&gt;DESTROY()&lt;/code&gt; 现在每个对象只会被调用一次。当然，如果子线程需要使用对象，则需要一种更复杂的方法。</target>
        </trans-unit>
        <trans-unit id="cc574da81e120f807b416b88f2c0641a8912116e" translate="yes" xml:space="preserve">
          <source>Perl after 5.8.7 has support for the &lt;code&gt;CLONE_SKIP&lt;/code&gt; special subroutine. Like &lt;code&gt;CLONE&lt;/code&gt;, &lt;code&gt;CLONE_SKIP&lt;/code&gt; is called once per package; however, it is called just before cloning starts, and in the context of the parent thread. If it returns a true value, then no objects of that class will be cloned; or rather, they will be copied as unblessed, undef values. For example: if in the parent there are two references to a single blessed hash, then in the child there will be two references to a single undefined scalar value instead. This provides a simple mechanism for making a module threadsafe; just add &lt;code&gt;sub CLONE_SKIP { 1 }&lt;/code&gt; at the top of the class, and &lt;code&gt;DESTROY()&lt;/code&gt; will now only be called once per object. Of course, if the child thread needs to make use of the objects, then a more sophisticated approach is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3994bbd1bc4bb2e8469e1a722d815312e8adf0c" translate="yes" xml:space="preserve">
          <source>Perl allows multiple inheritance, which means that a class can inherit from multiple parents. While this is possible, we strongly recommend against it. Generally, you can use &lt;b&gt;roles&lt;/b&gt; to do everything you can do with multiple inheritance, but in a cleaner way.</source>
          <target state="translated">Perl允许多重继承，这意味着一个类可以从多个父类继承。尽管这是可能的，但我们强烈建议您反对。通常，您可以使用&lt;b&gt;角色&lt;/b&gt;来做多继承可以做的所有事情，但是要用一种更简洁的方式。</target>
        </trans-unit>
        <trans-unit id="6599623983e18eb4fc0786b977835cf73837499f" translate="yes" xml:space="preserve">
          <source>Perl allows strings to contain a superset of Unicode code points, but these may not be accepted by other languages/systems. Further, even if these languages/systems accept these large code points, they may have chosen a different representation for them than the UTF-8-like one that Perl has, which would mean files are not exchangeable between them and Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1876b83bb7cab17e23b16333856308b07e0072a3" translate="yes" xml:space="preserve">
          <source>Perl allows strings to contain a superset of Unicode code points, up to the limit of what is storable in an unsigned integer on your system, but these may not be accepted by other languages/systems. At one time, it was legal in some standards to have code points up to 0x7FFF_FFFF, but not higher. Code points above 0xFFFF_FFFF require larger than a 32 bit word.</source>
          <target state="translated">Perl 允许字符串中包含 Unicode 码点的超集,最多可存储在系统中的无符号整数中,但这些码点可能不被其他语言/系统接受。曾经,在某些标准中,码点最高为0x7FFF_FFFF是合法的,但不是更高。高于0xFFFF_FFFF的代码点需要大于32位的字。</target>
        </trans-unit>
        <trans-unit id="da9001288df945c437097ff6bd5fee062555f6d6" translate="yes" xml:space="preserve">
          <source>Perl allows you to call methods using their fully qualified name (the package and method name):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ac9734d0ed22e02e26ee85745c9780f4e398059" translate="yes" xml:space="preserve">
          <source>Perl already</source>
          <target state="translated">Perl已经</target>
        </trans-unit>
        <trans-unit id="15634b8ec3adda1649ae8821b358664ffd34a247" translate="yes" xml:space="preserve">
          <source>Perl also defines a consistent extension syntax for features not found in standard tools like &lt;b&gt;awk&lt;/b&gt; and &lt;b&gt;lex&lt;/b&gt;. The syntax for most of these is a pair of parentheses with a question mark as the first thing within the parentheses. The character after the question mark indicates the extension.</source>
          <target state="translated">Perl还为&lt;b&gt;awk&lt;/b&gt;和&lt;b&gt;lex&lt;/b&gt;等标准工具中没有的功能定义了一致的扩展语法。其中大多数语法是一对带有问号的括号，括号内是第一个东西。问号后面的字符表示扩展名。</target>
        </trans-unit>
        <trans-unit id="555f11f2e27ae1e8bf2d2bd41f29991c6d6def35" translate="yes" xml:space="preserve">
          <source>Perl also defines single form synonyms for the block property in cases where these do not conflict with something else. But don't use any of these, because they are unstable. Since these are Perl extensions, they are subordinate to official Unicode property names; Unicode doesn't know nor care about Perl's extensions. It may happen that a name that currently means the Perl extension will later be changed without warning to mean a different Unicode property in a future version of the perl interpreter that uses a later Unicode release, and your code would no longer work. The extensions are mentioned here for completeness: Take the block name and prefix it with one of: &lt;code&gt;In&lt;/code&gt; (for example &lt;code&gt;\p{Blk=Arrows}&lt;/code&gt; can currently be written as &lt;code&gt;\p{In_Arrows}&lt;/code&gt;); or sometimes &lt;code&gt;Is&lt;/code&gt; (like &lt;code&gt;\p{Is_Arrows}&lt;/code&gt;); or sometimes no prefix at all (&lt;code&gt;\p{Arrows}&lt;/code&gt;). As of this writing (Unicode 9.0) there are no conflicts with using the &lt;code&gt;In_&lt;/code&gt; prefix, but there are plenty with the other two forms. For example, &lt;code&gt;\p{Is_Hebrew}&lt;/code&gt; and &lt;code&gt;\p{Hebrew}&lt;/code&gt; mean &lt;code&gt;\p{Script_Extensions=Hebrew}&lt;/code&gt; which is NOT the same thing as &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt;. Our advice used to be to use the &lt;code&gt;In_&lt;/code&gt; prefix as a single form way of specifying a block. But Unicode 8.0 added properties whose names begin with &lt;code&gt;In&lt;/code&gt;, and it's now clear that it's only luck that's so far prevented a conflict. Using &lt;code&gt;In&lt;/code&gt; is only marginally less typing than &lt;code&gt;Blk:&lt;/code&gt;, and the latter's meaning is clearer anyway, and guaranteed to never conflict. So don't take chances. Use &lt;code&gt;\p{Blk=foo}&lt;/code&gt; for new code. And be sure that block is what you really really want to do. In most cases scripts are what you want instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a619d021759a90d753880bfe4b40f68e2b5378ff" translate="yes" xml:space="preserve">
          <source>Perl also guarantees that the ranges &lt;code&gt;A-Z&lt;/code&gt; , &lt;code&gt;a-z&lt;/code&gt; , &lt;code&gt;0-9&lt;/code&gt; , and any subranges of these match what an English-only speaker would expect them to match on any platform. That is, &lt;code&gt;[A-Z]&lt;/code&gt; matches the 26 ASCII uppercase letters; &lt;code&gt;[a-z]&lt;/code&gt; matches the 26 lowercase letters; and &lt;code&gt;[0-9]&lt;/code&gt; matches the 10 digits. Subranges, like &lt;code&gt;[h-k]&lt;/code&gt; , match correspondingly, in this case just the four letters &lt;code&gt;&quot;h&quot;&lt;/code&gt; , &lt;code&gt;&quot;i&quot;&lt;/code&gt; , &lt;code&gt;&quot;j&quot;&lt;/code&gt; , and &lt;code&gt;&quot;k&quot;&lt;/code&gt; . This is the natural behavior on ASCII platforms where the code points (ordinal values) for &lt;code&gt;&quot;h&quot;&lt;/code&gt; through &lt;code&gt;&quot;k&quot;&lt;/code&gt; are consecutive integers (0x68 through 0x6B). But special handling to achieve this may be needed on platforms with a non-ASCII native character set. For example, on EBCDIC platforms, the code point for &lt;code&gt;&quot;h&quot;&lt;/code&gt; is 0x88, &lt;code&gt;&quot;i&quot;&lt;/code&gt; is 0x89, &lt;code&gt;&quot;j&quot;&lt;/code&gt; is 0x91, and &lt;code&gt;&quot;k&quot;&lt;/code&gt; is 0x92. Perl specially treats &lt;code&gt;[h-k]&lt;/code&gt; to exclude the seven code points in the gap: 0x8A through 0x90. This special handling is only invoked when the range is a subrange of one of the ASCII uppercase, lowercase, and digit ranges, AND each end of the range is expressed either as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; , or as a named character (&lt;code&gt;\N{...}&lt;/code&gt; , including the &lt;code&gt;\N{U+...&lt;/code&gt; form).</source>
          <target state="translated">Perl还保证范围 &lt;code&gt;A-Z&lt;/code&gt; ， &lt;code&gt;a-z&lt;/code&gt; ， &lt;code&gt;0-9&lt;/code&gt; 以及这些范围的任何子范围都与仅英语使用者在任何平台上期望的范围相匹配。也就是说， &lt;code&gt;[A-Z]&lt;/code&gt; 匹配26个ASCII大写字母； &lt;code&gt;[a-z]&lt;/code&gt; 匹配26个小写字母；和 &lt;code&gt;[0-9]&lt;/code&gt; 相匹配的10位数字。子范围（例如 &lt;code&gt;[h-k]&lt;/code&gt; ）相应地匹配，在这种情况下，仅匹配四个字母 &lt;code&gt;&quot;h&quot;&lt;/code&gt; ， &lt;code&gt;&quot;i&quot;&lt;/code&gt; ， &lt;code&gt;&quot;j&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;k&quot;&lt;/code&gt; 。这是ASCII平台上的自然行为，在该平台上， &lt;code&gt;&quot;h&quot;&lt;/code&gt; 到 &lt;code&gt;&quot;k&quot;&lt;/code&gt; h&amp;rdquo;的代码点（常规值）k&amp;ldquo;是连续的整数（0x68至0x6B）。但是，在具有非ASCII本机字符集的平台上，可能需要特殊处理才能实现此目的。例如，在EBCDIC平台上， &lt;code&gt;&quot;h&quot;&lt;/code&gt; 的代码点是0x88， &lt;code&gt;&quot;i&quot;&lt;/code&gt; 是0x89， &lt;code&gt;&quot;j&quot;&lt;/code&gt; 是0x91， &lt;code&gt;&quot;k&quot;&lt;/code&gt; 是0x92。 Perl特别对待 &lt;code&gt;[h-k]&lt;/code&gt; 以排除间隙中的七个代码点：0x8A到0x90。仅当范围是ASCII大写，小写和数字范围之一的子范围时，才调用此特殊处理，并且范围的每一端都以文字（如 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 或命名字符（ &lt;code&gt;\N{...}&lt;/code&gt; ，包括 &lt;code&gt;\N{U+...&lt;/code&gt; 形式）。</target>
        </trans-unit>
        <trans-unit id="d3478992830572c2488574386b02bb13d70d568a" translate="yes" xml:space="preserve">
          <source>Perl also guarantees that the ranges &lt;code&gt;A-Z&lt;/code&gt;, &lt;code&gt;a-z&lt;/code&gt;, &lt;code&gt;0-9&lt;/code&gt;, and any subranges of these match what an English-only speaker would expect them to match on any platform. That is, &lt;code&gt;[A-Z]&lt;/code&gt; matches the 26 ASCII uppercase letters; &lt;code&gt;[a-z]&lt;/code&gt; matches the 26 lowercase letters; and &lt;code&gt;[0-9]&lt;/code&gt; matches the 10 digits. Subranges, like &lt;code&gt;[h-k]&lt;/code&gt;, match correspondingly, in this case just the four letters &lt;code&gt;&quot;h&quot;&lt;/code&gt;, &lt;code&gt;&quot;i&quot;&lt;/code&gt;, &lt;code&gt;&quot;j&quot;&lt;/code&gt;, and &lt;code&gt;&quot;k&quot;&lt;/code&gt;. This is the natural behavior on ASCII platforms where the code points (ordinal values) for &lt;code&gt;&quot;h&quot;&lt;/code&gt; through &lt;code&gt;&quot;k&quot;&lt;/code&gt; are consecutive integers (0x68 through 0x6B). But special handling to achieve this may be needed on platforms with a non-ASCII native character set. For example, on EBCDIC platforms, the code point for &lt;code&gt;&quot;h&quot;&lt;/code&gt; is 0x88, &lt;code&gt;&quot;i&quot;&lt;/code&gt; is 0x89, &lt;code&gt;&quot;j&quot;&lt;/code&gt; is 0x91, and &lt;code&gt;&quot;k&quot;&lt;/code&gt; is 0x92. Perl specially treats &lt;code&gt;[h-k]&lt;/code&gt; to exclude the seven code points in the gap: 0x8A through 0x90. This special handling is only invoked when the range is a subrange of one of the ASCII uppercase, lowercase, and digit ranges, AND each end of the range is expressed either as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt;, or as a named character (&lt;code&gt;\N{...}&lt;/code&gt;, including the &lt;code&gt;\N{U+...&lt;/code&gt; form).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ed4c36b705c801489a6eaa310a7c1790004938" translate="yes" xml:space="preserve">
          <source>Perl also has environment variables that control how Perl handles data specific to particular natural languages; see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">Perl还具有环境变量，用于控制Perl如何处理特定于自然语言的数据。参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ec1e88310a904c3504c234668eb6f0ebab9fa04" translate="yes" xml:space="preserve">
          <source>Perl also has its own built-in variables whose names don't follow these rules. They have strange names so they don't accidentally collide with one of your normal variables. Strings that match parenthesized parts of a regular expression are saved under names containing only digits after the &lt;code&gt;$&lt;/code&gt; (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;). In addition, several special variables that provide windows into the inner working of Perl have names containing punctuation characters and control characters. These are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">Perl还具有自己的内置变量，其名称不遵循这些规则。它们的名称很奇怪，因此不会意外与您的普通变量之一发生冲突。匹配正则表达式括号部分的字符串将保存在 &lt;code&gt;$&lt;/code&gt; 之后仅包含数字的名称下（请参阅&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;和&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;）。另外，一些提供Perl内部工作窗口的特殊变量的名称包含标点符号和控制字符。这些都在&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;中记录。</target>
        </trans-unit>
        <trans-unit id="f3713f56b650ce5c5c9a6797e5a04ca7cc768c6f" translate="yes" xml:space="preserve">
          <source>Perl also has its own built-in variables whose names don't follow these rules. They have strange names so they don't accidentally collide with one of your normal variables. Strings that match parenthesized parts of a regular expression are saved under names containing only digits after the &lt;code&gt;$&lt;/code&gt; (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;). In addition, several special variables that provide windows into the inner working of Perl have names containing punctuation characters. These are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841c07e6d7a8a9202a2c193293298a117297f325" translate="yes" xml:space="preserve">
          <source>Perl also has single-form extensions that refer to blocks, &lt;code&gt;In_Cyrillic&lt;/code&gt; , meaning &lt;code&gt;Block=Cyrillic&lt;/code&gt; . These have always been written in the new style.</source>
          <target state="translated">Perl还具有引用块的单一形式扩展 &lt;code&gt;In_Cyrillic&lt;/code&gt; ，意味着 &lt;code&gt;Block=Cyrillic&lt;/code&gt; 。这些总是以新样式编写的。</target>
        </trans-unit>
        <trans-unit id="5bfcb9a0154768c6b22ee7b3439e847665a12d5c" translate="yes" xml:space="preserve">
          <source>Perl also has single-form extensions that refer to blocks, &lt;code&gt;In_Cyrillic&lt;/code&gt;, meaning &lt;code&gt;Block=Cyrillic&lt;/code&gt;. These have always been written in the new style.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="137aae63637704103b28432cb70098e2ba4ae7c0" translate="yes" xml:space="preserve">
          <source>Perl also lets you open a filehandle into an external program or shell command rather than into a file. You can do this in order to pass data from your Perl program to an external command for further processing, or to receive data from another program for your own Perl program to process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e768cdcaf855f3ac360271eae70fa3fb2f42dd9c" translate="yes" xml:space="preserve">
          <source>Perl also lets you use a dereferenced scalar reference in a method call. That's a mouthful, so let's look at some code:</source>
          <target state="translated">Perl还允许你在方法调用中使用一个去引用的标量。这是一个口水仗,让我们来看一些代码。</target>
        </trans-unit>
        <trans-unit id="bb3ab86dafec3fc1c1204665ff3d23b69370b1f7" translate="yes" xml:space="preserve">
          <source>Perl also lets you use a scalar containing a string as a class name:</source>
          <target state="translated">Perl还允许你使用一个包含字符串的标量作为类名。</target>
        </trans-unit>
        <trans-unit id="c015ec327f8f9a3ad1518fbf18a7cfa1b7b34e78" translate="yes" xml:space="preserve">
          <source>Perl also makes no guarantees that the representation of these code points won't change at some point in the future, say when machines become available that have larger than a 64-bit word. At that time, files containing any of these, written by an older Perl might require conversion before being readable by a newer Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371faeea377937a5cb124120c079958efb812b1f" translate="yes" xml:space="preserve">
          <source>Perl also provides some additional extensions and short-cut synonyms for Unicode properties.</source>
          <target state="translated">Perl还提供了一些额外的扩展和Unicode属性的快捷同义词。</target>
        </trans-unit>
        <trans-unit id="bc3b136059aadb780f36682ea1b93270fac2fc5f" translate="yes" xml:space="preserve">
          <source>Perl also uses two special typedefs, I32 and I16, which will always be at least 32-bits and 16-bits long, respectively. (Again, there are U32 and U16, as well.) They will usually be exactly 32 and 16 bits long, but on Crays they will both be 64 bits.</source>
          <target state="translated">Perl还使用了两个特殊的类型定义,I32和I16,它们将永远分别至少是32位和16位的长度,(同样,还有U32和U16)。(同样,还有U32和U16。)它们的长度通常正好是32位和16位,但在Crays上它们都是64位。</target>
        </trans-unit>
        <trans-unit id="d9ec80db167215866b69eb0ca3e0370b7320f73c" translate="yes" xml:space="preserve">
          <source>Perl and its various modules and components, including its test frameworks, may sometimes make use of certain other environment variables. Some of these are specific to a particular platform. Please consult the appropriate module documentation and any documentation for your platform (like &lt;a href=&quot;perlsolaris&quot;&gt;perlsolaris&lt;/a&gt;, &lt;a href=&quot;perllinux&quot;&gt;perllinux&lt;/a&gt;, &lt;a href=&quot;perlmacosx&quot;&gt;perlmacosx&lt;/a&gt;, &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;, etc) for variables peculiar to those specific situations.</source>
          <target state="translated">Perl及其各种模块和组件（包括其测试框架）有时可能会使用某些其他环境变量。其中一些特定于特定平台。请查阅适当的模块说明文件以及适用于您平台的任何说明文件（例如&lt;a href=&quot;perlsolaris&quot;&gt;perlsolaris&lt;/a&gt;，&lt;a href=&quot;perllinux&quot;&gt;perllinux&lt;/a&gt;，&lt;a href=&quot;perlmacosx&quot;&gt;perlmacosx&lt;/a&gt;，&lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;等），以获取特定于这些特定情况的变量。</target>
        </trans-unit>
        <trans-unit id="d1f38ea6665b57c86a485191974a93669f79515b" translate="yes" xml:space="preserve">
          <source>Perl applications</source>
          <target state="translated">Perl应用</target>
        </trans-unit>
        <trans-unit id="4025df8be02954e082a25375011463ff96fd6a98" translate="yes" xml:space="preserve">
          <source>Perl array references become JSON arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="502f7e3b25466218701794ac8b146d454581203f" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before forking the child process, but this may not be supported on some platforms (see &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid duplicate output.</source>
          <target state="translated">Perl尝试在派生子进程之前刷新所有打开的用于输出的文件，但是在某些平台上可能不支持此操作（请参阅&lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;）。为了安全起见，您可能需要设置 &lt;code&gt;$|&lt;/code&gt; （英文的$ AUTOFLUSH）或在任何打开的句柄上调用 &lt;code&gt;IO::Handle&lt;/code&gt; 的 &lt;code&gt;autoflush()&lt;/code&gt; 方法，以避免重复输出。</target>
        </trans-unit>
        <trans-unit id="9e63e6195bf1a4edf392bb3f6dbbceb58829cc90" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before forking the child process, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;a href=&quot;perlvar#%24%7C&quot;&gt;&lt;code&gt;$|&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; in &lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;) or call the &lt;code&gt;autoflush&lt;/code&gt; method of &lt;a href=&quot;IO::Handle#METHODS&quot;&gt;&lt;code&gt;IO::Handle&lt;/code&gt;&lt;/a&gt; on any open handles to avoid duplicate output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="310c094e234f2eeac0cd6d541a4252ff1573cf15" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before forking the child process, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid duplicate output.</source>
          <target state="translated">Perl尝试在派生子进程之前刷新所有打开的用于输出的文件，但是在某些平台上可能不支持此操作（请参阅&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;）。为了安全起见，您可能需要设置 &lt;code&gt;$|&lt;/code&gt; （英文的$ AUTOFLUSH）或在任何打开的句柄上调用 &lt;code&gt;IO::Handle&lt;/code&gt; 的 &lt;code&gt;autoflush()&lt;/code&gt; 方法，以避免重复输出。</target>
        </trans-unit>
        <trans-unit id="de17dd0dec4269e99ee3620228765bf8385c7342" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before the exec, but this may not be supported on some platforms (see &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid lost output.</source>
          <target state="translated">Perl尝试在exec之前刷新所有打开的用于输出的文件，但是在某些平台上可能不支持此操作（请参阅&lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;）。为了安全起见，您可能需要设置 &lt;code&gt;$|&lt;/code&gt; （英语中的$ AUTOFLUSH）或在任何打开的句柄上调用 &lt;code&gt;IO::Handle&lt;/code&gt; 的 &lt;code&gt;autoflush()&lt;/code&gt; 方法，以避免输出丢失。</target>
        </trans-unit>
        <trans-unit id="051c3f058010c205bb09ec0c0f5ce04fd3e0e5c9" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before the exec, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;a href=&quot;perlvar#%24%7C&quot;&gt;&lt;code&gt;$|&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; in &lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;) or call the &lt;code&gt;autoflush&lt;/code&gt; method of &lt;a href=&quot;IO::Handle#METHODS&quot;&gt;&lt;code&gt;IO::Handle&lt;/code&gt;&lt;/a&gt; on any open handles to avoid lost output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="003b4d9ba004fb0af8689ed0414255d30b89d115" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before the exec, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid lost output.</source>
          <target state="translated">Perl尝试在exec之前刷新所有打开的用于输出的文件，但是在某些平台上可能不支持此操作（请参阅&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;）。为了安全起见，您可能需要设置 &lt;code&gt;$|&lt;/code&gt; （英语中的$ AUTOFLUSH）或在任何打开的句柄上调用 &lt;code&gt;IO::Handle&lt;/code&gt; 的 &lt;code&gt;autoflush()&lt;/code&gt; 方法，以避免输出丢失。</target>
        </trans-unit>
        <trans-unit id="7d4f20a9384f8bc5428825b882bff482c1a8070c" translate="yes" xml:space="preserve">
          <source>Perl automatically calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method when processing a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement for a module. Modules and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; are documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;. Understanding the concept of modules and how the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement operates is important to understanding the Exporter.</source>
          <target state="translated">在处理模块的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句时，Perl自动调用 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法。模块和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 记录在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;和&lt;a href=&quot;perlmod&quot;&gt;perlmod中&lt;/a&gt;。理解模块的概念以及 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句的运行方式对于理解Exporter至关重要。</target>
        </trans-unit>
        <trans-unit id="6a95697cdde6d23d6eaf67c474daab5e6a483bb6" translate="yes" xml:space="preserve">
          <source>Perl automatically calls the &lt;code&gt;import&lt;/code&gt; method when processing a &lt;code&gt;use&lt;/code&gt; statement for a module. Modules and &lt;code&gt;use&lt;/code&gt; are documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;. Understanding the concept of modules and how the &lt;code&gt;use&lt;/code&gt; statement operates is important to understanding the Exporter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61b6a6317cfa23498f15dd9d06745532cf81070" translate="yes" xml:space="preserve">
          <source>Perl automatically enables a set of special security checks, called</source>
          <target state="translated">Perl会自动启用一组特殊的安全检查,称为</target>
        </trans-unit>
        <trans-unit id="fbe832a4f97c9466dde588ba9b2da8adad2850de" translate="yes" xml:space="preserve">
          <source>Perl automatically handles most of the common ways a method might be redefined. However, there are a few ways you could change a method in a stash without the cache code noticing, in which case you need to call this method afterwards:</source>
          <target state="translated">Perl 会自动处理大多数可能被重新定义的方法。然而,有几种方法可以在缓存代码没有注意到的情况下更改 stash 中的方法,在这种情况下,你需要在之后调用这个方法。</target>
        </trans-unit>
        <trans-unit id="c56019acc23d2639adf6a34824d254308e6f1860" translate="yes" xml:space="preserve">
          <source>Perl automatically loads &lt;code&gt;Errno&lt;/code&gt; the first time you use &lt;code&gt;%!&lt;/code&gt;, so you don't need an explicit &lt;code&gt;use&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="036d8f87f677f8c5718f1d28012fa559462c3777" translate="yes" xml:space="preserve">
          <source>Perl automatically provides large file support when built under 64-bit Windows.</source>
          <target state="translated">在64位Windows下构建时,Perl自动提供大文件支持。</target>
        </trans-unit>
        <trans-unit id="7a716c995ea81037d2661a333de648b734bf1c68" translate="yes" xml:space="preserve">
          <source>Perl believes that no machine ever has more than one of &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;age&lt;/code&gt; , or &lt;code&gt;quota&lt;/code&gt; implemented, nor more than one of either &lt;code&gt;comment&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; . Some machines do not support &lt;code&gt;expire&lt;/code&gt; , &lt;code&gt;gecos&lt;/code&gt; , or allegedly, &lt;code&gt;passwd&lt;/code&gt; . You may call these methods no matter what machine you're on, but they return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if unimplemented.</source>
          <target state="translated">Perl相信，任何机器都不能实现 &lt;code&gt;change&lt;/code&gt; ， &lt;code&gt;age&lt;/code&gt; 或 &lt;code&gt;quota&lt;/code&gt; 的任何一项，也不能 &lt;code&gt;comment&lt;/code&gt; 或 &lt;code&gt;class&lt;/code&gt; 的任何一项。有些机器不支持 &lt;code&gt;expire&lt;/code&gt; ， &lt;code&gt;gecos&lt;/code&gt; ，或据称， &lt;code&gt;passwd&lt;/code&gt; 文件。无论您在什么计算机上，都可以调用这些方法，但是如果未实现，它们将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9fd89618c3b47a0e722e09957c69ce215a51cf2c" translate="yes" xml:space="preserve">
          <source>Perl believes that no machine ever has more than one of &lt;code&gt;change&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt;, or &lt;code&gt;quota&lt;/code&gt; implemented, nor more than one of either &lt;code&gt;comment&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt;. Some machines do not support &lt;code&gt;expire&lt;/code&gt;, &lt;code&gt;gecos&lt;/code&gt;, or allegedly, &lt;code&gt;passwd&lt;/code&gt;. You may call these methods no matter what machine you're on, but they return &lt;code&gt;undef&lt;/code&gt; if unimplemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d0360d06e2a1778dd48425c09025dbdf8293f8e" translate="yes" xml:space="preserve">
          <source>Perl binary able to run this extension, load XS modules, etc...</source>
          <target state="translated">Perl二进制文件能够运行这个扩展,加载XS模块等...。</target>
        </trans-unit>
        <trans-unit id="cb8da21c98e2920d923d329d6f68942a153a615f" translate="yes" xml:space="preserve">
          <source>Perl binary distributions come with a</source>
          <target state="translated">Perl二进制发行版带有一个</target>
        </trans-unit>
        <trans-unit id="25b8cd5db95b73c8697ce2a24fc9a3c4624497ef" translate="yes" xml:space="preserve">
          <source>Perl binary for tasks that can be done by miniperl.</source>
          <target state="translated">可由miniperl完成的任务的Perl二进制。</target>
        </trans-unit>
        <trans-unit id="5c60e05f40789a6f58044b7f99b3ed4077f167aa" translate="yes" xml:space="preserve">
          <source>Perl binary for tasks that can be done by miniperl. If it contains spaces or other shell metacharacters, it needs to be quoted in a way that protects them, since this value is intended to be inserted in a shell command line in the Makefile. E.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72df5c4242785794c622b22864eb9d8a2e74001" translate="yes" xml:space="preserve">
          <source>Perl builds and runs on a bewildering number of platforms. Virtually all known and current Unix derivatives are supported (perl's native platform), as are other systems like VMS, DOS, OS/2, Windows, QNX, BeOS, OS X, MPE/iX and the Amiga.</source>
          <target state="translated">Perl可以在大量的平台上构建和运行。几乎所有已知的和当前的Unix派生系统(perl的本地平台)都被支持,其他系统如VMS、DOS、OS/2、Windows、QNX、BeOS、OS X、MPE/iX和Amiga也都支持。</target>
        </trans-unit>
        <trans-unit id="20d139451b19c9903cb470dbddc56287a00a07ca" translate="yes" xml:space="preserve">
          <source>Perl by default comes with the latest supported Unicode version built-in, but the goal is to allow you to change to use any earlier one. In Perls v5.20 and v5.22, however, the earliest usable version is Unicode 5.1. Perl v5.18 and v5.24 are able to handle all earlier versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96b360f2cb263510b9740f1a358943c2a62edfbc" translate="yes" xml:space="preserve">
          <source>Perl by default comes with the latest supported Unicode version built-in, but the goal is to allow you to change to use any earlier one. In Perls v5.20 and v5.22, however, the earliest usable version is Unicode 5.1. Perl v5.18 is able to handle all earlier versions.</source>
          <target state="translated">Perl默认内置了最新的Unicode支持版本,但我们的目标是允许你改变使用任何早期版本。然而,在 Perls v5.20 和 v5.22 中,最早的可用版本是 Unicode 5.1。Perl v5.18能够处理所有早期的版本。</target>
        </trans-unit>
        <trans-unit id="858924b099068580d5d02f65c2520871f9621191" translate="yes" xml:space="preserve">
          <source>Perl by default is very forgiving. In order to make it more robust it is recommended to start every program with the following lines:</source>
          <target state="translated">Perl默认情况下是非常宽容的。为了使它更加健壮,建议在每个程序开始时都用下面的行。</target>
        </trans-unit>
        <trans-unit id="41943c9223a2849d683a6cec44cbaf36e58b907e" translate="yes" xml:space="preserve">
          <source>Perl can be built so that it by default will try to execute</source>
          <target state="translated">构建Perl时,可以让它默认尝试执行</target>
        </trans-unit>
        <trans-unit id="36ba407dbee2d6e43709ef0153d960c56996ecc9" translate="yes" xml:space="preserve">
          <source>Perl can be compiled on platforms that run any of three commonly used EBCDIC character sets, listed below.</source>
          <target state="translated">Perl可以在运行以下三种常用EBCDIC字符集的平台上编译。</target>
        </trans-unit>
        <trans-unit id="bea19b77ce1281f9b9bf9a47baf0d79604e6dd7a" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with either HP's ANSI C compiler or with gcc. The former is recommended, as not only can it compile Perl with no difficulty, but also can take advantage of features listed later that require the use of HP compiler-specific command-line flags.</source>
          <target state="translated">Perl可以用HP的ANSI C编译器或gcc编译。建议使用前者,因为它不仅可以毫无困难地编译Perl,而且还可以利用后面列出的需要使用HP编译器专用命令行标志的特性。</target>
        </trans-unit>
        <trans-unit id="f05f1e5361560b59743e9bd4f32b54cc023f431f" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with either IBM's ANSI C compiler or with gcc. The former is recommended, as not only can it compile Perl with no difficulty, but also can take advantage of features listed later that require the use of IBM compiler-specific command-line flags.</source>
          <target state="translated">Perl可以用IBM的ANSI C编译器或gcc编译。建议使用前者,因为它不仅可以毫无困难地编译Perl,而且可以利用后面列出的需要使用IBM编译器专用命令行标志的特性。</target>
        </trans-unit>
        <trans-unit id="19a69f0e2f064ea4c82b3309e77eb45ccd797a4c" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with either IBM's ANSI C compiler or with gcc. The former is recommended, as not only it can compile Perl with no difficulty, but also can take advantage of features listed later that require the use of IBM compiler-specific command-line flags.</source>
          <target state="translated">Perl可以用IBM的ANSI C编译器或用gcc编译。建议使用前者,因为它不仅可以毫无困难地编译Perl,而且可以利用后面列出的需要使用IBM编译器专用命令行标志的特性。</target>
        </trans-unit>
        <trans-unit id="1eec7cebb78e4a4eae8424666c3dade6b3981bcc" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with gcc from MinGW (version 3.4.5 or later) or from MinGW64 (version 4.4.3 or later). It can be downloaded here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751c036d6e62fec07bc2f5f4e73156154792a0fd" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with gcc from MinGW release 3 and later (using gcc 3.4.5 and later). It can be downloaded here:</source>
          <target state="translated">Perl可以用MinGW第3版及以后的gcc编译(使用gcc 3.4.5及以后的版本)。它可以在这里下载。</target>
        </trans-unit>
        <trans-unit id="5aad21700ba14174a334f6c9d33b139e2bf40c72" translate="yes" xml:space="preserve">
          <source>Perl can be cross-compiled using either adb or a normal ssh connection; in general, if you can connect your device to the host using a USB port, or if you don't feel like installing an sshd app on your device, you may want to use adb, although you may be forced to switch to ssh if your device is not rooted and you're unlucky -- more on that later. Alternatively, if you're cross-compiling to an emulator, you'll have to use adb.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298c207dde281e03961c0f741436a83e917ef6d5" translate="yes" xml:space="preserve">
          <source>Perl can be run under the &quot;C&quot; locale by setting the environment variable &lt;code&gt;LC_ALL&lt;/code&gt; to &quot;C&quot;. This method is perhaps a bit more civilized than the &lt;code&gt;PERL_BADLANG&lt;/code&gt; approach, but setting &lt;code&gt;LC_ALL&lt;/code&gt; (or other locale variables) may affect other programs as well, not just Perl. In particular, external programs run from within Perl will see these changes. If you make the new settings permanent (read on), all programs you run see the changes. See &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt; for the full list of relevant environment variables and &lt;a href=&quot;#USING-LOCALES&quot;&gt;&quot;USING LOCALES&quot;&lt;/a&gt; for their effects in Perl. Effects in other programs are easily deducible. For example, the variable &lt;code&gt;LC_COLLATE&lt;/code&gt; may well affect your &lt;b&gt;sort&lt;/b&gt; program (or whatever the program that arranges &quot;records&quot; alphabetically in your system is called).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e57623077581e01731874e47fb8c2a4b90f970b" translate="yes" xml:space="preserve">
          <source>Perl can be run under the &quot;C&quot; locale by setting the environment variable &lt;code&gt;LC_ALL&lt;/code&gt; to &quot;C&quot;. This method is perhaps a bit more civilized than the &lt;code&gt;PERL_BADLANG&lt;/code&gt; approach, but setting &lt;code&gt;LC_ALL&lt;/code&gt; (or other locale variables) may affect other programs as well, not just Perl. In particular, external programs run from within Perl will see these changes. If you make the new settings permanent (read on), all programs you run see the changes. See &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; for the full list of relevant environment variables and &lt;a href=&quot;#USING-LOCALES&quot;&gt;USING LOCALES&lt;/a&gt; for their effects in Perl. Effects in other programs are easily deducible. For example, the variable &lt;code&gt;LC_COLLATE&lt;/code&gt; may well affect your &lt;b&gt;sort&lt;/b&gt; program (or whatever the program that arranges &quot;records&quot; alphabetically in your system is called).</source>
          <target state="translated">通过将环境变量 &lt;code&gt;LC_ALL&lt;/code&gt; 设置为&amp;ldquo; C&amp;rdquo;，可以在&amp;ldquo; C&amp;rdquo;语言环境下运行Perl 。该方法也许比 &lt;code&gt;PERL_BADLANG&lt;/code&gt; 方法更加文明，但是设置 &lt;code&gt;LC_ALL&lt;/code&gt; （或其他语言环境变量）也可能会影响其他程序，而不仅仅是Perl。特别是，从Perl内部运行的外部程序将看到这些更改。如果使新设置永久化（继续），则您运行的所有程序都会看到更改。有关相关环境变量的完整列表，请参见&lt;a href=&quot;#ENVIRONMENT&quot;&gt;环境；&lt;/a&gt;对于Perl，它们的作用请参见&lt;a href=&quot;#USING-LOCALES&quot;&gt;使用局部&lt;/a&gt;。其他程序中的效果很容易推论。例如，变量 &lt;code&gt;LC_COLLATE&lt;/code&gt; 可能会影响您的&lt;b&gt;排序&lt;/b&gt; 程序（或在系统中按字母顺序排列&amp;ldquo;记录&amp;rdquo;的任何程序都将被调用）。</target>
        </trans-unit>
        <trans-unit id="afea4028a165b75f73beb84894121ff0308d01df" translate="yes" xml:space="preserve">
          <source>Perl can be used for almost any coding problem, even ones which require integrating specialist C code for extra speed. As with any tool it can be used well or badly. Perl has many strengths, and a few weaknesses, precisely which areas are good and bad is often a personal choice.</source>
          <target state="translated">Perl几乎可以用于任何编码问题,甚至是那些需要整合专业C代码以获得额外速度的问题。就像任何工具一样,它可以用得好,也可以用得不好。Perl有很多优点,也有一些缺点,具体哪方面好,哪方面不好,往往是个人的选择。</target>
        </trans-unit>
        <trans-unit id="9f84aec4fa7ef06751c778c8e8173ffe00dcd629" translate="yes" xml:space="preserve">
          <source>Perl can compile and run under EBCDIC platforms. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;. This is transparent for the most part, but because the character sets differ, you shouldn't use numeric (decimal, octal, nor hex) constants to refer to characters. You can safely say &lt;code&gt;'A'&lt;/code&gt; , but not &lt;code&gt;0x41&lt;/code&gt; . You can safely say &lt;code&gt;'\n'&lt;/code&gt; , but not &lt;code&gt;\012&lt;/code&gt; . However, you can use macros defined in</source>
          <target state="translated">Perl可以在EBCDIC平台上编译和运行。参见&lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;。这在大多数情况下是透明的，但是由于字符集不同，因此不应使用数字（十进制，八进制或十六进制）常量来引用字符。您可以放心地说 &lt;code&gt;'A'&lt;/code&gt; ，但不能说 &lt;code&gt;0x41&lt;/code&gt; 。您可以放心说 &lt;code&gt;'\n'&lt;/code&gt; ，但不能说 &lt;code&gt;\012&lt;/code&gt; 。但是，您可以使用在中定义的宏</target>
        </trans-unit>
        <trans-unit id="89da686bd0b150df7259283a72feb17be88ef847" translate="yes" xml:space="preserve">
          <source>Perl can compile and run under EBCDIC platforms. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;. This is transparent for the most part, but because the character sets differ, you shouldn't use numeric (decimal, octal, nor hex) constants to refer to characters. You can safely say &lt;code&gt;'A'&lt;/code&gt;, but not &lt;code&gt;0x41&lt;/code&gt;. You can safely say &lt;code&gt;'\n'&lt;/code&gt;, but not &lt;code&gt;\012&lt;/code&gt;. However, you can use macros defined in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa07386a80b47ab8df8b6dbe1e6a41311efb8910" translate="yes" xml:space="preserve">
          <source>Perl can internally represent numbers in 3 different ways: as native integers, as native floating point numbers, and as decimal strings. Decimal strings may have an exponential notation part, as in &lt;code&gt;&quot;12.34e-56&quot;&lt;/code&gt; .</source>
          <target state="translated">Perl可以在内部以3种不同的方式表示数字：作为本机整数，作为本机浮点数和作为十进制字符串。小数字符串可以具有指数表示法部分，如 &lt;code&gt;&quot;12.34e-56&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91d8093cdc26010bc75cbe7ac13c80dda1139d5f" translate="yes" xml:space="preserve">
          <source>Perl can internally represent numbers in 3 different ways: as native integers, as native floating point numbers, and as decimal strings. Decimal strings may have an exponential notation part, as in &lt;code&gt;&quot;12.34e-56&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05cb1fb37d34785f635f75844d77033b80fc24ef" translate="yes" xml:space="preserve">
          <source>Perl can process line directives, much like the C preprocessor. Using this, one can control Perl's idea of filenames and line numbers in error or warning messages (especially for strings that are processed with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;). The syntax for this mechanism is almost the same as for most C preprocessors: it matches the regular expression</source>
          <target state="translated">Perl可以像C预处理器一样处理行指令。使用它，可以控制错误或警告消息中的Perl文件名和行号的概念（尤其是对于使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 处理的字符串）。该机制的语法与大多数C预处理器的语法几乎相同：它与正则表达式匹配</target>
        </trans-unit>
        <trans-unit id="5dbe3afd1eb59bb8a6efe4b4b5b6385c4ed178c9" translate="yes" xml:space="preserve">
          <source>Perl can process line directives, much like the C preprocessor. Using this, one can control Perl's idea of filenames and line numbers in error or warning messages (especially for strings that are processed with &lt;code&gt;eval()&lt;/code&gt;). The syntax for this mechanism is almost the same as for most C preprocessors: it matches the regular expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1175d291fc9d1138f03be93ce22b47fc929ba6" translate="yes" xml:space="preserve">
          <source>Perl can provide access to all non-provisional Unicode character properties, though not all are enabled by default. The omitted ones are the Unihan properties (accessible via the CPAN module &lt;a href=&quot;Unicode::Unihan&quot;&gt;Unicode::Unihan&lt;/a&gt;) and certain deprecated or Unicode-internal properties. (An installation may choose to recompile Perl's tables to change this. See &lt;a href=&quot;#Unicode-character-properties-that-are-NOT-accepted-by-Perl&quot;&gt;&quot;Unicode character properties that are NOT accepted by Perl&quot;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87b4bc522cc9bacefe7588c2849722683c7ccc0c" translate="yes" xml:space="preserve">
          <source>Perl can provide access to all non-provisional Unicode character properties, though not all are enabled by default. The omitted ones are the Unihan properties (accessible via the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Unihan&quot;&gt;Unicode::Unihan&lt;/a&gt;) and certain deprecated or Unicode-internal properties. (An installation may choose to recompile Perl's tables to change this. See &lt;a href=&quot;#Unicode-character-properties-that-are-NOT-accepted-by-Perl&quot;&gt;Unicode character properties that are NOT accepted by Perl&lt;/a&gt;.)</source>
          <target state="translated">Perl可以提供对所有非临时Unicode字符属性的访问，尽管默认情况下并非全部启用。省略的是Unihan属性（可通过CPAN模块&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Unihan&quot;&gt;Unicode :: Unihan访问&lt;/a&gt;）和某些不推荐使用或Unicode内部的属性。（安装程序可以选择重新编译Perl的表来更改此设置。请参阅&lt;a href=&quot;#Unicode-character-properties-that-are-NOT-accepted-by-Perl&quot;&gt;Perl不接受的Unicode字符属性&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="b9d3bae2bf6cbe36ec81823e26589a3e2497f6c1" translate="yes" xml:space="preserve">
          <source>Perl cannot be compiled with threading support ATM.</source>
          <target state="translated">Perl不能用ATM线程支持来编译。</target>
        </trans-unit>
        <trans-unit id="5aa9ff89c6dfca6cc410567a511ce06ca99ab635" translate="yes" xml:space="preserve">
          <source>Perl cannot protect you from all possibilities shown in the examples--there is no substitute for your own vigilance--but, when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, Perl uses the tainting mechanism (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) to mark string results that become locale-dependent, and which may be untrustworthy in consequence. Here is a summary of the tainting behavior of operators and functions that may be affected by the locale:</source>
          <target state="translated">Perl不能保护您免受示例中显示的所有可能性的困扰-不能替代您自己的警惕性-但是，当有效 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 时，Perl使用污染机制（请参阅&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;）来标记依赖于语言环境的字符串结果，其结果可能是不可信的。这是可能受语言环境影响的操作员和函数的污染行为的摘要：</target>
        </trans-unit>
        <trans-unit id="a594f813141415e6aca23ee60e047f5b3f5ab72f" translate="yes" xml:space="preserve">
          <source>Perl cannot protect you from all possibilities shown in the examples--there is no substitute for your own vigilance--but, when &lt;code&gt;use locale&lt;/code&gt; is in effect, Perl uses the tainting mechanism (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) to mark string results that become locale-dependent, and which may be untrustworthy in consequence. Here is a summary of the tainting behavior of operators and functions that may be affected by the locale:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f3aa702381872bb34697babcd6d91dd23feeed" translate="yes" xml:space="preserve">
          <source>Perl code is always compiled into an internal format before execution.</source>
          <target state="translated">Perl代码在执行前总是被编译成内部格式。</target>
        </trans-unit>
        <trans-unit id="cbb579bb2906840ac41b443c221a57b4ff511c5a" translate="yes" xml:space="preserve">
          <source>Perl code should convert to either call &lt;a href=&quot;perlapi#Perl_setlocale&quot;&gt;&lt;code&gt;Perl_setlocale&lt;/code&gt;&lt;/a&gt; (which is a drop-in for the system &lt;code&gt;setlocale&lt;/code&gt;) or use the methods given in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; to call &lt;a href=&quot;posix#setlocale&quot;&gt;&lt;code&gt;POSIX::setlocale&lt;/code&gt;&lt;/a&gt;. Either one will transparently properly handle all cases of single- vs multi-thread, POSIX 2008-supported or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5cce9b9678a00b1fe024a9af1e795642a5bcb9c" translate="yes" xml:space="preserve">
          <source>Perl comes with a wide selection of builtin functions. Some of the ones we've already seen include &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt;. A list of them is given at the start of &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and you can easily read about any given function by using &lt;code&gt;perldoc -f &lt;i&gt;functionname&lt;/i&gt;&lt;/code&gt;.</source>
          <target state="translated">Perl带有多种内置函数。我们已经看到的一些包括 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; 。在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;的开头给出了它们的列表，您可以使用 &lt;code&gt;perldoc -f &lt;i&gt;functionname&lt;/i&gt;&lt;/code&gt; 轻松了解任何给定的&lt;i&gt;函数&lt;/i&gt;。</target>
        </trans-unit>
        <trans-unit id="79ae445a5a6eedaef6fa6773c44a0f926e1cd176" translate="yes" xml:space="preserve">
          <source>Perl comes with a wide selection of builtin functions. Some of the ones we've already seen include &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;reverse&lt;/code&gt;. A list of them is given at the start of &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and you can easily read about any given function by using &lt;code&gt;perldoc -f &lt;i&gt;functionname&lt;/i&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d575f0416db18e1fc564b29cf8cc390222ecf415" translate="yes" xml:space="preserve">
          <source>Perl comes with an interactive debugger, which you can start with the &lt;code&gt;-d&lt;/code&gt; switch. It's fully explained in &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;.</source>
          <target state="translated">Perl带有交互式调试器，您可以从 &lt;code&gt;-d&lt;/code&gt; 开关开始。在&lt;a href=&quot;perldebug&quot;&gt;perldebug中有&lt;/a&gt;充分的解释。</target>
        </trans-unit>
        <trans-unit id="641c8779114365eacf0b514d71b892f3c88f6444" translate="yes" xml:space="preserve">
          <source>Perl compiler backend to produce perl code</source>
          <target state="translated">Perl编译器后台生成perl代码</target>
        </trans-unit>
        <trans-unit id="3d5234796bebd4a0240f58d33b5d22994612e499" translate="yes" xml:space="preserve">
          <source>Perl contains internal support for reporting its own memory usage, but this is a fairly advanced concept that requires some understanding of how memory allocation works. See &lt;a href=&quot;perldebguts#Debugging-Perl-Memory-Usage&quot;&gt;&quot;Debugging Perl Memory Usage&quot; in perldebguts&lt;/a&gt; for the details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a425209baf3b199ee00ab768f1943ede83ed4ff4" translate="yes" xml:space="preserve">
          <source>Perl contains internal support for reporting its own memory usage, but this is a fairly advanced concept that requires some understanding of how memory allocation works. See &lt;a href=&quot;perldebguts#Debugging-Perl-Memory-Usage&quot;&gt;Debugging Perl Memory Usage in perldebguts&lt;/a&gt; for the details.</source>
          <target state="translated">Perl包含内部支持以报告其自身的内存使用情况，但这是一个相当高级的概念，需要对内存分配的工作方式有所了解。有关详细信息，请参见&lt;a href=&quot;perldebguts#Debugging-Perl-Memory-Usage&quot;&gt;perldebguts&lt;/a&gt;中的调试Perl内存使用情况。</target>
        </trans-unit>
        <trans-unit id="dd31498cb274469b540952840b7aa19174e08b34" translate="yes" xml:space="preserve">
          <source>Perl continues to support the old non UTF-8 locales as well. There are currently no UTF-8 locales for EBCDIC platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a29ee67698d8ff496114e40d0f60aa708da987ff" translate="yes" xml:space="preserve">
          <source>Perl continues to warn (using the warning category &lt;code&gt;&quot;nonchar&quot;&lt;/code&gt; , which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ) if an attempt is made to output noncharacters.</source>
          <target state="translated">如果尝试输出非字符，Perl将继续发出警告（使用警告类别 &lt;code&gt;&quot;nonchar&quot;&lt;/code&gt; ，这是 &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 的子类别）。</target>
        </trans-unit>
        <trans-unit id="9cb01f485dfc78123b0a04671230b175342a0686" translate="yes" xml:space="preserve">
          <source>Perl continues to warn (using the warning category &lt;code&gt;&quot;nonchar&quot;&lt;/code&gt;, which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt;) if an attempt is made to output noncharacters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d488e88c0eb0084402cd1c0721ceebc56fc521" translate="yes" xml:space="preserve">
          <source>Perl core development team.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baa05b026a869001e1e5be6e67df2e5d03445c53" translate="yes" xml:space="preserve">
          <source>Perl currently only supports single-byte locales for &lt;code&gt;LC_COLLATE&lt;/code&gt; . This means that a UTF-8 locale likely will just give you machine-native ordering. Use &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; for the full implementation of the Unicode Collation Algorithm.</source>
          <target state="translated">Perl当前仅支持 &lt;code&gt;LC_COLLATE&lt;/code&gt; 的单字节语言环境。这意味着UTF-8语言环境可能只会给您本机排序。将&lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collat​​e&lt;/a&gt;用于Unicode归类算法的完整实现。</target>
        </trans-unit>
        <trans-unit id="77cf5a91724851c2026eb0ed52027faf2ff9d8f3" translate="yes" xml:space="preserve">
          <source>Perl debug information is frequently required not just by debuggers, but also by modules that need some &quot;special&quot; information to do their job properly, like profilers.</source>
          <target state="translated">Perl调试信息不仅是调试器经常需要的,也是那些需要一些 &quot;特殊 &quot;信息才能正常工作的模块所需要的,比如剖析器。</target>
        </trans-unit>
        <trans-unit id="edcd0b1168988fe6213df824f5ad91c7a66c6c43" translate="yes" xml:space="preserve">
          <source>Perl defines the following zero-width assertions:</source>
          <target state="translated">Perl定义了以下零宽度断言。</target>
        </trans-unit>
        <trans-unit id="6b26390b798af49773d52f4620dbbc3aff54133e" translate="yes" xml:space="preserve">
          <source>Perl deliberately randomizes hash order for security purposes on both ASCII and EBCDIC platforms.</source>
          <target state="translated">Perl为了ASCII和EBCDIC平台的安全,特意随机化了哈希顺序。</target>
        </trans-unit>
        <trans-unit id="b360e4dc6087d3b16edb381fbc0c1f20ea026de5" translate="yes" xml:space="preserve">
          <source>Perl derives from the ubiquitous C programming language and to a lesser extent from sed, awk, the Unix shell, and many other tools and languages.</source>
          <target state="translated">Perl源于无处不在的C编程语言,其次是sed、awk、Unix shell以及许多其他工具和语言。</target>
        </trans-unit>
        <trans-unit id="171910ec91b3b6b1e9deeb50ab9dfa78a36b3ec1" translate="yes" xml:space="preserve">
          <source>Perl does its own &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt; formatting: it emulates the C function &lt;a href=&quot;http://man.he.net/man3/sprintf&quot;&gt;sprintf(3)&lt;/a&gt;, but doesn't use it except for floating-point numbers, and even then only standard modifiers are allowed. Non-standard extensions in your local &lt;a href=&quot;http://man.he.net/man3/sprintf&quot;&gt;sprintf(3)&lt;/a&gt; are therefore unavailable from Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ed6e041cbd4aae6a032a9f05ea11dde0c68044" translate="yes" xml:space="preserve">
          <source>Perl does its own &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; formatting: it emulates the C function sprintf(3), but doesn't use it except for floating-point numbers, and even then only standard modifiers are allowed. Non-standard extensions in your local sprintf(3) are therefore unavailable from Perl.</source>
          <target state="translated">Perl进行自己的 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 格式化：它模拟C函数sprintf（3），但除浮点数外不使用它，即使如此，也只允许使用标准修饰符。因此，Perl无法使用本地sprintf（3）中的非标准扩展名。</target>
        </trans-unit>
        <trans-unit id="9fd3bbafbe5f224f645e29f633eba572a0b47a6b" translate="yes" xml:space="preserve">
          <source>Perl does its own &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; formatting: it emulates the C function sprintf(3), but doesn't use it except for floating-point numbers, and even then only standard modifiers are allowed. Non-standard extensions in your local sprintf(3) are therefore unavailable from Perl.</source>
          <target state="translated">Perl进行自己的 &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 格式化：它模拟C函数sprintf（3），但除浮点数外不使用它，即使如此，也只允许使用标准修饰符。因此，Perl无法使用本地sprintf（3）中的非标准扩展名。</target>
        </trans-unit>
        <trans-unit id="a4d0575e168bcb93baf91092d083b3f45edc7784" translate="yes" xml:space="preserve">
          <source>Perl does not allow overloading of ranges, so you can neither safely use ranges with bigint endpoints, nor is the iterator variable a bigint.</source>
          <target state="translated">Perl不允许重载范围,所以你既不能安全地使用带有bigint端点的范围,迭代器变量也不是bigint。</target>
        </trans-unit>
        <trans-unit id="c115815d6de8f54c97b95bbf1feacf608d2cdd8a" translate="yes" xml:space="preserve">
          <source>Perl does not call the shell to expand wild cards when you pass &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; explicit parameter lists instead of strings with possible shell wildcards in them. Unfortunately, the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, and backtick functions provide no such alternate calling convention, so more subterfuge will be required.</source>
          <target state="translated">当您传递 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 显式参数列表，而不是其中包含可能的外壳通配符的字符串时，Perl不会调用外壳扩展通配符。不幸的是， &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 和backtick函数不提供此类替代调用约定，因此将需要更多的替代方法。</target>
        </trans-unit>
        <trans-unit id="8b58eb8904f65d9a83df8472fec3b9959cc0c48d" translate="yes" xml:space="preserve">
          <source>Perl does not call the shell to expand wild cards when you pass &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; explicit parameter lists instead of strings with possible shell wildcards in them. Unfortunately, the &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;glob&lt;/code&gt;, and backtick functions provide no such alternate calling convention, so more subterfuge will be required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf14eaf9fdbdb615c0b9a213270f3740bd4a2b7" translate="yes" xml:space="preserve">
          <source>Perl does not care about file systems, but the perl library contains many files with long names, so to install it intact one needs a file system which supports long file names.</source>
          <target state="translated">Perl不在乎文件系统,但是perl库中包含了很多长名的文件,所以要想完整的安装,需要一个支持长文件名的文件系统。</target>
        </trans-unit>
        <trans-unit id="5a30d3ce357d2bad0edd8f956d77f82fd680b527" translate="yes" xml:space="preserve">
          <source>Perl does not depend on the registry, but it can look up certain default values if you choose to put them there unless disabled at build time with USE_NO_REGISTRY. On Perl process start Perl checks if &lt;code&gt;HKEY_CURRENT_USER\Software\Perl&lt;/code&gt; and &lt;code&gt;HKEY_LOCAL_MACHINE\Software\Perl&lt;/code&gt; exist. If the keys exists, they will be checked for remainder of the Perl process's run life for certain entries. Entries in &lt;code&gt;HKEY_CURRENT_USER\Software\Perl&lt;/code&gt; override entries in &lt;code&gt;HKEY_LOCAL_MACHINE\Software\Perl&lt;/code&gt;. One or more of the following entries (of type REG_SZ or REG_EXPAND_SZ) may be set in the keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5354348a14ac18fad5dfd9ae6dc9f4e8955fd5e4" translate="yes" xml:space="preserve">
          <source>Perl does not depend on the registry, but it can look up certain default values if you choose to put them there. Perl attempts to read entries from &lt;code&gt;HKEY_CURRENT_USER\Software\Perl&lt;/code&gt; and &lt;code&gt;HKEY_LOCAL_MACHINE\Software\Perl&lt;/code&gt; . Entries in the former override entries in the latter. One or more of the following entries (of type REG_SZ or REG_EXPAND_SZ) may be set:</source>
          <target state="translated">Perl不依赖于注册表，但是如果您选择将某些默认值放在注册表中，则它可以查找某些默认值。Perl尝试从 &lt;code&gt;HKEY_CURRENT_USER\Software\Perl&lt;/code&gt; 和 &lt;code&gt;HKEY_LOCAL_MACHINE\Software\Perl&lt;/code&gt; 读取条目。前者中的条目将覆盖后者中的条目。可以设置以下一项或多项（REG_SZ或REG_EXPAND_SZ类型）：</target>
        </trans-unit>
        <trans-unit id="e6697dea8bad1c38bf0eecc9764ad8eaf5ace311" translate="yes" xml:space="preserve">
          <source>Perl does not enforce private and public parts of its modules as you may have been used to in other languages like C++, Ada, or Modula-17. Perl doesn't have an infatuation with enforced privacy. It would prefer that you stayed out of its living room because you weren't invited, not because it has a shotgun.</source>
          <target state="translated">Perl并不像你可能已经习惯了其他语言如C++、Ada或Modula-17那样强制执行其模块的私有和公开部分。Perl并不迷恋强制的隐私。它更希望你远离它的客厅,因为你没有被邀请,而不是因为它有一把猎枪。</target>
        </trans-unit>
        <trans-unit id="7376046122227141976ff6a43223937f5fa71800" translate="yes" xml:space="preserve">
          <source>Perl does not expand &lt;code&gt;~&lt;/code&gt; in filenames, which is good, since some folks use it for their backup files:</source>
          <target state="translated">Perl不会在文件名中扩展 &lt;code&gt;~&lt;/code&gt; ，这很好，因为有些人将它用作备份文件：</target>
        </trans-unit>
        <trans-unit id="5b47de2bb8098559e3bf2dcabce87f213a6eb4f0" translate="yes" xml:space="preserve">
          <source>Perl does not have any built-in way to express roles. In the past, people just bit the bullet and used multiple inheritance. Nowadays, there are several good choices on CPAN for using roles.</source>
          <target state="translated">Perl没有任何内置的方式来表达角色。过去,人们只是咬紧牙关,使用多重继承。现在,在CPAN上有几个使用角色的好选择。</target>
        </trans-unit>
        <trans-unit id="eea568e6b9c913375e5a754c242df8539876547c" translate="yes" xml:space="preserve">
          <source>Perl does not provide any special syntax for class definitions. A package is simply a namespace containing variables and subroutines. The only difference is that in a class, the subroutines may expect a reference to an object or the name of a class as the first argument. This is purely a matter of convention, so a class may contain both methods and subroutines which</source>
          <target state="translated">Perl没有为类定义提供任何特殊的语法。一个包只是一个包含变量和子程序的命名空间。唯一不同的是,在一个类中,子程序可能需要一个对象的引用或一个类的名称作为第一个参数。这纯粹是一个约定俗成的问题,所以一个类可能同时包含方法和子程序,这些方法和子程序是</target>
        </trans-unit>
        <trans-unit id="c5c3b122d3c32f38c2b6df0053286a38a52964b9" translate="yes" xml:space="preserve">
          <source>Perl does not provide any special syntax for defining a method. A method is simply a regular subroutine, and is declared with &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt;. What makes a method special is that it expects to receive either an object or a class name as its first argument.</source>
          <target state="translated">Perl没有提供用于定义方法的任何特殊语法。方法只是常规的子例程，并用 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 声明。使方法与众不同的是，它希望接收对象或类名作为其第一个参数。</target>
        </trans-unit>
        <trans-unit id="0947ef57e8f5b7f263717d72ae86b49dba67c724" translate="yes" xml:space="preserve">
          <source>Perl does not provide any special syntax for defining a method. A method is simply a regular subroutine, and is declared with &lt;code&gt;sub&lt;/code&gt;. What makes a method special is that it expects to receive either an object or a class name as its first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66c91b8b39ed83c72047110950399f56a4745108" translate="yes" xml:space="preserve">
          <source>Perl doesn't match multiple characters in a bracketed character class unless the character that maps to them is explicitly mentioned, and it doesn't match them at all if the character class is inverted, which otherwise could be highly confusing. See &lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;&quot;Bracketed Character Classes&quot; in perlrecharclass&lt;/a&gt;, and &lt;a href=&quot;perlrecharclass#Negation&quot;&gt;&quot;Negation&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cedf75e55d51d5b15900a202031f864d4002fc15" translate="yes" xml:space="preserve">
          <source>Perl doesn't match multiple characters in a bracketed character class unless the character that maps to them is explicitly mentioned, and it doesn't match them at all if the character class is inverted, which otherwise could be highly confusing. See &lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;Bracketed Character Classes in perlrecharclass&lt;/a&gt;, and &lt;a href=&quot;perlrecharclass#Negation&quot;&gt;Negation in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">除非明确提到映射到它们的字符，否则Perl不会匹配方括号字符类中的多个字符，并且如果字符类颠倒了，Perl根本不匹配它们，否则可能会造成很大的混乱。见&lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;在perlrecharclass括号内的字符类&lt;/a&gt;，并&lt;a href=&quot;perlrecharclass#Negation&quot;&gt;否定在perlrecharclass&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="160ee861b96d9abcad026bc93515a6480468d14a" translate="yes" xml:space="preserve">
          <source>Perl doesn't officially have a no-op operator, but the bare constants &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; are special-cased not to produce a warning in void context, so you can for example safely do</source>
          <target state="translated">Perl正式没有no-op运算符，但是裸常量 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 是特殊情况，不会在void上下文中产生警告，因此可以安全地进行操作</target>
        </trans-unit>
        <trans-unit id="ee11bfd628d5bc290b395480aaa995c735fee62a" translate="yes" xml:space="preserve">
          <source>Perl doesn't understand &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; as numeric literals, but you can have them as strings, and Perl will convert them as needed: &quot;Inf&quot; + 1. (You can, however, import them from the POSIX extension; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX qw(Inf NaN);&lt;/code&gt; and then use them as literals.)</source>
          <target state="translated">Perl不能将 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; 理解为数字文字，但是您可以将它们作为字符串，Perl会根据需要将它们转换：&amp;ldquo; Inf&amp;rdquo; +1。（但是，您可以从POSIX扩展名中导入它们；请 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX qw(Inf NaN);&lt;/code&gt; 然后将它们用作文字。）</target>
        </trans-unit>
        <trans-unit id="ec5da9f5482b92ac03cf293065833b5b8af6f55e" translate="yes" xml:space="preserve">
          <source>Perl doesn't understand &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; as numeric literals, but you can have them as strings, and Perl will convert them as needed: &quot;Inf&quot; + 1. (You can, however, import them from the POSIX extension; &lt;code&gt;use POSIX qw(Inf NaN);&lt;/code&gt; and then use them as literals.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06c7777ec6a9cec60c6bbba96236c8c49e10f30" translate="yes" xml:space="preserve">
          <source>Perl enables DECC$EFS_CASE_PRESERVE and DECC$ARGV_PARSE_STYLE by default. Note that the latter only takes effect when extended parse is set in the process in which Perl is running. When these features are explicitly disabled in the environment or the CRTL does not support them, Perl follows the traditional CRTL behavior of downcasing command-line arguments and returning file specifications in lower case only.</source>
          <target state="translated">Perl 默认启用 DECC$EFS_CASE_PRESERVE 和 DECC$ARGV_PARSE_STYLE。请注意,后者只有在 Perl 运行的进程中设置了扩展解析时才会生效。当环境中明确禁用这些特性或者 CRTL 不支持这些特性时,Perl 会遵循传统的 CRTL 行为,将命令行参数降格,并仅以小写形式返回文件规范。</target>
        </trans-unit>
        <trans-unit id="9a7ffa77beb4b5bfb6e9cd592ffc3d63fefd5d7f" translate="yes" xml:space="preserve">
          <source>Perl environment problems</source>
          <target state="translated">Perl环境问题</target>
        </trans-unit>
        <trans-unit id="efd321f1d642a6164aeb6c6061ba19e8d5553328" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($myarray[$key])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Perl等效项： &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($myarray[$key])&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1023174861c373cd70c764cd28a1ffe52c362de1" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @array;&lt;/code&gt; .</source>
          <target state="translated">相当于Perl： &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @array;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1efb4e8b7d1884210a677a24eedc3aaa4097d90" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @new_array = ($scalar1, $scalar2, $scalar3...);&lt;/code&gt;</source>
          <target state="translated">相当于Perl： &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @new_array = ($scalar1, $scalar2, $scalar3...);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="994d82ebaabf45f0326fee88481665e6c0ceb2c7" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop(@myarray);&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">相当于Perl： &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop(@myarray);&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c448473e835de05f1fd2f4b0a4490f988bfea19" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; @myarray, $elem;&lt;/code&gt; .</source>
          <target state="translated">相当于Perl： &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; @myarray, $elem;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c7b86a8f8deba930918279e3c4fc84bda790f23" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@myarray);&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Perl等效： &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@myarray);&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4b1f7bdfb013ea4679d96a3812b271f5a3c227d" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; @myarray, ( (&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;) x $n );&lt;/code&gt;</source>
          <target state="translated">等价于Perl： &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; @myarray, ( (&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;) x $n );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="066d54dd7f117a044b123bb5ad4d4d8cf43e8b71" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;@myarray = ();&lt;/code&gt; .</source>
          <target state="translated">Perl等效： &lt;code&gt;@myarray = ();&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cef9ffe6af51e7c258630229039bfd2bf1b03f4a" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;@{&quot;$name&quot;}&lt;/code&gt; .</source>
          <target state="translated">Perl等效项： &lt;code&gt;@{&quot;$name&quot;}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd6c0fa81ee3f8c1c8439229199c54fb18bd674d" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;@{&quot;$name&quot;}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8387ac6319e9c82075e493d979c1ad9402112db0" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;exists($myarray[$key])&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5694e8120a54857700407b986aded553056c12c9" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;my @array;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64388bc4ae76bac317e416b96081b0d5a0b6f31c" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;my @new_array = ($scalar1, $scalar2, $scalar3...);&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c87143f1eb93d31e9b921daa9a01a7a20ad16d03" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;pop(@myarray);&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697b1808fa2455d4990177e0cd7be75e6d5166eb" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;push @myarray, $val;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1708a84090946a618873c3a265107ea3020eef" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;shift(@myarray);&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d39e18ca7e7f2ff2aed6b8cb0b4962580d73a5" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;splice(@myarray, $key, 1, undef)&lt;/code&gt; (with the &lt;code&gt;splice&lt;/code&gt; in void context if &lt;code&gt;G_DISCARD&lt;/code&gt; is present).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3899dd3b4004ff6e0fc8455247dbe889fc7876" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;unshift @myarray, ((undef) x $num);&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1633602744f0213cf03a917c908f3ac91926bf3d" translate="yes" xml:space="preserve">
          <source>Perl exited with active threads:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8a19dd0719175a9c848242a7e2217e48154534" translate="yes" xml:space="preserve">
          <source>Perl extension for ARexx support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aec2fb1965c42df65abc2f4f5003e7dd1e44262" translate="yes" xml:space="preserve">
          <source>Perl extension for BSD glob routine</source>
          <target state="translated">BSD glob例程的Perl扩展</target>
        </trans-unit>
        <trans-unit id="24aff9b9093549c7d05ba26875dcbd18c62f3127" translate="yes" xml:space="preserve">
          <source>Perl extension for SHA-1/224/256/384/512</source>
          <target state="translated">SHA-1/224/256/384/512的Perl扩展。</target>
        </trans-unit>
        <trans-unit id="403524ab53fcfa65297b5c6d11da8a41e9bdf68e" translate="yes" xml:space="preserve">
          <source>Perl extension for Version Objects</source>
          <target state="translated">版本对象的Perl扩展</target>
        </trans-unit>
        <trans-unit id="42f2f6711b11e99ed8f45572975dad7e69bf2e53" translate="yes" xml:space="preserve">
          <source>Perl extension for low level amiga support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c24a560ca7260d4a2d7424b6161a53890073335c" translate="yes" xml:space="preserve">
          <source>Perl extension for sharing data structures between threads</source>
          <target state="translated">线程间共享数据结构的Perl扩展</target>
        </trans-unit>
        <trans-unit id="3668aadc429b1304c6228d98dc9c4677872a86f1" translate="yes" xml:space="preserve">
          <source>Perl extension to manipulate DCL symbols</source>
          <target state="translated">用于操作DCL符号的Perl扩展</target>
        </trans-unit>
        <trans-unit id="b4ef3d43e200cfbf35d2a7b6f42754d585642e16" translate="yes" xml:space="preserve">
          <source>Perl extensions are packages which provide both XS and Perl code to add new functionality to perl. (XS is a meta-language which simplifies writing C code which interacts with Perl, see &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for more details.) The Perl code for an extension is treated like any other library module - it's made available in your script through the appropriate &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement, and usually defines a Perl package containing the extension.</source>
          <target state="translated">Perl扩展是提供XS和Perl代码以向perl添加新功能的软件包。（XS是一种元语言，它简化了与Perl交互的C代码的编写，有关更多详细信息，请参见&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;。）扩展的Perl代码被视为与其他任何库模块一样-通过适当的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 可以在脚本中使用它。语句，通常定义一个包含扩展名的Perl软件包。</target>
        </trans-unit>
        <trans-unit id="0e866b1770868c3ac8fc82a190900a1373e58cc0" translate="yes" xml:space="preserve">
          <source>Perl extensions are packages which provide both XS and Perl code to add new functionality to perl. (XS is a meta-language which simplifies writing C code which interacts with Perl, see &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for more details.) The Perl code for an extension is treated like any other library module - it's made available in your script through the appropriate &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; statement, and usually defines a Perl package containing the extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81d1af8c2de641461c82be3969f85e5ad3bba8c" translate="yes" xml:space="preserve">
          <source>Perl flavors</source>
          <target state="translated">Perl的味道</target>
        </trans-unit>
        <trans-unit id="bd0c8e091c1809181809f92d1bef1271c7b38ca1" translate="yes" xml:space="preserve">
          <source>Perl folding rules are not up-to-date for 0x%X; please use the perlbug utility to report; in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d53205939368bef651c20e6009f95c9046101c6" translate="yes" xml:space="preserve">
          <source>Perl for VMS supports redirection of input and output on the command line, using a subset of Bourne shell syntax:</source>
          <target state="translated">Perl for VMS支持在命令行上重定向输入和输出,使用Bourne shell语法的子集。</target>
        </trans-unit>
        <trans-unit id="903e263457faf9b024e447e13142cbcffaf64dc8" translate="yes" xml:space="preserve">
          <source>Perl functions</source>
          <target state="translated">Perl函数</target>
        </trans-unit>
        <trans-unit id="7328221f86957828b643cf959ce54c0e2d391c24" translate="yes" xml:space="preserve">
          <source>Perl functions that execute the most opcodes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eab57fb6512949ddd22c0f3a298921f86d2bf10" translate="yes" xml:space="preserve">
          <source>Perl had to change internally to decouple &quot;bytes&quot; from &quot;characters&quot;. It is important that you too change your ideas, if you haven't already, so that &quot;byte&quot; and &quot;character&quot; no longer mean the same thing in your mind.</source>
          <target state="translated">Perl不得不在内部进行改变,将 &quot;字节 &quot;和 &quot;字符 &quot;解耦。重要的是,如果你还没有改变你的想法,你也要改变你的想法,让 &quot;字节 &quot;和 &quot;字符 &quot;在你的脑海中不再是同一个意思。</target>
        </trans-unit>
        <trans-unit id="eb521c7add3b7379a78d9a6b6db7917dc107bbad" translate="yes" xml:space="preserve">
          <source>Perl has a mechanism for intermixing documentation with source code. While it's expecting the beginning of a new statement, if the compiler encounters a line that begins with an equal sign and a word, like this</source>
          <target state="translated">Perl有一种机制,可以将文档和源代码混在一起。当它期待一个新语句的开始时,如果编译器遇到一行以等号和一个词开头的语句,就像这样</target>
        </trans-unit>
        <trans-unit id="1e3d0cb76e6880e13fbb5d4447acbcbd4213008d" translate="yes" xml:space="preserve">
          <source>Perl has a mechanism to help you generate simple reports and charts. To facilitate this, Perl helps you code up your output page close to how it will look when it's printed. It can keep track of things like how many lines are on a page, what page you're on, when to print page headers, etc. Keywords are borrowed from FORTRAN: format() to declare and write() to execute; see their entries in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. Fortunately, the layout is much more legible, more like BASIC's PRINT USING statement. Think of it as a poor man's nroff(1).</source>
          <target state="translated">Perl有一种机制可以帮助您生成简单的报告和图表。为方便起见，Perl帮助您对输出页进行编码，使其接近打印时的外观。它可以跟踪诸如页面上有多少行，您所在的页面，何时打印页面标题等内容。从FORTRAN借用关键字：format（）进行声明，write（）执行；在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;查看他们的条目。幸运的是，布局更加清晰，更像是BASIC的PRINT USING语句。将其视为穷人的nroff（1）。</target>
        </trans-unit>
        <trans-unit id="a345738f3732f2f0cdf6981643487de1b3db946b" translate="yes" xml:space="preserve">
          <source>Perl has a number of C functions that allow you to call Perl subroutines. They are</source>
          <target state="translated">Perl有一些C函数,允许你调用Perl子程序。它们是</target>
        </trans-unit>
        <trans-unit id="1bddeb2bc37a6de64d61b4ee95d33bffdb149de8" translate="yes" xml:space="preserve">
          <source>Perl has a very handy construction</source>
          <target state="translated">Perl有一个非常方便的结构</target>
        </trans-unit>
        <trans-unit id="782c7b78803135d7443e4bbee913a7ff13f6ef7c" translate="yes" xml:space="preserve">
          <source>Perl has allowed you to use a bare here-document terminator to have the here-document end at the first empty line. This practise was deprecated in Perl 5.000; as of Perl 5.28, using a bare here-document terminator throws a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe803dd8b2d3f30a3a54343a2a1b136039b1f5f" translate="yes" xml:space="preserve">
          <source>Perl has an &lt;b&gt;internal format&lt;/b&gt;, an encoding that it uses to encode text strings so it can store them in memory. All text strings are in this internal format. In fact, text strings are never in any other format!</source>
          <target state="translated">Perl具有&lt;b&gt;内部格式&lt;/b&gt;，该&lt;b&gt;格式&lt;/b&gt;用于对文本字符串进行编码，以便将其存储在内存中。所有文本字符串均采用此内部格式。实际上，文本字符串绝不会采用任何其他格式！</target>
        </trans-unit>
        <trans-unit id="8e77f37e525e239856b2f6dca9aacaa6be1709a8" translate="yes" xml:space="preserve">
          <source>Perl has an abstracted interface for all supported character encodings, so this is actually a generic &lt;code&gt;Encode&lt;/code&gt; tutorial and &lt;code&gt;Encode&lt;/code&gt; FAQ. But many people think that Unicode is special and magical, and I didn't want to disappoint them, so I decided to call the document a Unicode tutorial.</source>
          <target state="translated">Perl具有适用于所有受支持的字符编码的抽象接口，因此它实际上是通用的 &lt;code&gt;Encode&lt;/code&gt; 教程和 &lt;code&gt;Encode&lt;/code&gt; 常见问题解答。但是许多人认为Unicode是特殊且神奇的，我不想让他们失望，因此我决定将文档称为Unicode教程。</target>
        </trans-unit>
        <trans-unit id="ba0cf0d83a33c18a21a219f52e56234294b46fae" translate="yes" xml:space="preserve">
          <source>Perl has an experimental facility to allow a subroutine's formal parameters to be introduced by special syntax, separate from the procedural code of the subroutine body. The formal parameter list is known as a</source>
          <target state="translated">Perl有一个实验性的设施,允许子程序的形式化参数通过特殊的语法引入,与子程序体的程序代码分开。形式参数列表被称为</target>
        </trans-unit>
        <trans-unit id="97abe0ed9adb57fe2fdef50f3e6441c8a80f29df" translate="yes" xml:space="preserve">
          <source>Perl has been built with &lt;code&gt;PERL_OLD_SIGNALS&lt;/code&gt; (see &lt;code&gt;perl -V&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67a3b41d8b9e93c19e7c374ecedc7c37bde9bf23" translate="yes" xml:space="preserve">
          <source>Perl has been extended to support certain types of locales available in the locale system. This is controlled per application by using one pragma, one function call, and several environment variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1de858c46ad7947531577a6915520f75857a413" translate="yes" xml:space="preserve">
          <source>Perl has been extended to support the locale system. This is controlled per application by using one pragma, one function call, and several environment variables.</source>
          <target state="translated">Perl已经扩展到支持locale系统。通过使用一个pragma、一个函数调用和几个环境变量来控制每个应用程序。</target>
        </trans-unit>
        <trans-unit id="9724b09cfb0bd9657e1b0740263fad624a62d13c" translate="yes" xml:space="preserve">
          <source>Perl has been ported to many platforms that do not fit into any of the categories listed above. Some, such as AmigaOS, QNX, Plan 9, and VOS, have been well-integrated into the standard Perl source code kit. You may need to see the</source>
          <target state="translated">Perl已被移植到许多平台上,但这些平台并不属于上述任何类别。有些平台,如 AmigaOS、QNX、Plan 9 和 VOS,已经被很好地集成到标准的 Perl 源代码包中。您可能需要查看</target>
        </trans-unit>
        <trans-unit id="59525826d5ce7fdcf57cd21fd12177031ab869c3" translate="yes" xml:space="preserve">
          <source>Perl has its own special way of easily writing test scripts, but for this example only, we'll create our own test script. Create a file called hello that looks like this:</source>
          <target state="translated">Perl有自己特殊的方式来轻松编写测试脚本,但仅在本例中,我们将创建自己的测试脚本。创建一个名为hello的文件,看起来像这样。</target>
        </trans-unit>
        <trans-unit id="998bc2b1651869833ea0ac38395b9fb4d5ed44f8" translate="yes" xml:space="preserve">
          <source>Perl has long been ported to Intel-style microcomputers running under systems like PC-DOS, MS-DOS, OS/2, and most Windows platforms you can bring yourself to mention (except for Windows CE, if you count that). Users familiar with</source>
          <target state="translated">Perl早已被移植到英特尔风格的微机上,运行在PC-DOS、MS-DOS、OS/2等系统下,以及大多数你能提得起的Windows平台上(Windows CE除外,如果你算的话)。熟悉的用户</target>
        </trans-unit>
        <trans-unit id="fe67796dc02d7b52e1f554749c03ec30b57d6bfa" translate="yes" xml:space="preserve">
          <source>Perl has most of the usual conditional and looping constructs. As of Perl 5.10, it even has a case/switch statement (spelled &lt;code&gt;given&lt;/code&gt; /&lt;code&gt;when&lt;/code&gt; ). See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more details.</source>
          <target state="translated">Perl具有大多数通常的条件和循环构造。像Perl 5.10的，它甚至有一个情况/ switch语句（拼写 &lt;code&gt;given&lt;/code&gt; / &lt;code&gt;when&lt;/code&gt; ）。有关更多详细信息，请参见&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;perlsyn中的Switch语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a9108e90e0b7ad511809f643c664cdbaf3b5a6fd" translate="yes" xml:space="preserve">
          <source>Perl has most of the usual conditional and looping constructs. As of Perl 5.10, it even has a case/switch statement (spelled &lt;code&gt;given&lt;/code&gt;/&lt;code&gt;when&lt;/code&gt;). See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;&quot;Switch Statements&quot; in perlsyn&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db019a5ac1f171d008187e1d1c55e0f5d5a9b3a4" translate="yes" xml:space="preserve">
          <source>Perl has never accepted code points above 255 without them being Unicode, so their use implies Unicode for the whole string.</source>
          <target state="translated">Perl从来没有接受过255以上的码点而不接受Unicode,所以它们的使用意味着整个字符串的Unicode。</target>
        </trans-unit>
        <trans-unit id="3dbc4a73529270e867678196c4fd9545abf0346b" translate="yes" xml:space="preserve">
          <source>Perl has no special syntax for attributes. Under the hood, attributes are often stored as keys in the object's underlying hash, but don't worry about this.</source>
          <target state="translated">Perl对属性没有特殊的语法。在外壳下,属性通常被存储为对象底层哈希中的键,但不用担心这个问题。</target>
        </trans-unit>
        <trans-unit id="7a462b0d48d68775e02812c002249670e7d86d56" translate="yes" xml:space="preserve">
          <source>Perl has several abbreviations for common character classes. (These definitions are those that Perl uses in ASCII-safe mode with the &lt;code&gt;/a&lt;/code&gt; modifier. Otherwise they could match many more non-ASCII Unicode characters as well. See &lt;a href=&quot;perlrecharclass#Backslash-sequences&quot;&gt;&quot;Backslash sequences&quot; in perlrecharclass&lt;/a&gt; for details.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2deb2a0ce121e98962483bd16f83d982606bfc5" translate="yes" xml:space="preserve">
          <source>Perl has several abbreviations for common character classes. (These definitions are those that Perl uses in ASCII-safe mode with the &lt;code&gt;/a&lt;/code&gt; modifier. Otherwise they could match many more non-ASCII Unicode characters as well. See &lt;a href=&quot;perlrecharclass#Backslash-sequences&quot;&gt;Backslash sequences in perlrecharclass&lt;/a&gt; for details.)</source>
          <target state="translated">Perl有几种常见字符类的缩写。（这些定义是Perl在带 &lt;code&gt;/a&lt;/code&gt; 修饰符的ASCII安全模式下使用的定义。否则，它们也可以与更多非ASCII Unicode字符匹配。有关详细信息，请参见&lt;a href=&quot;perlrecharclass#Backslash-sequences&quot;&gt;perlrecharclass中的反斜杠序列&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="6e2448e5aa8e9e98f0e99e7fca74328732318a16" translate="yes" xml:space="preserve">
          <source>Perl has special debugging hooks at compile-time and run-time used to create debugging environments. These hooks are not to be confused with the</source>
          <target state="translated">Perl在编译时和运行时都有特殊的调试钩子,用于创建调试环境。这些钩子不能与下面的</target>
        </trans-unit>
        <trans-unit id="0380b6f875ab18989e39e87ecb537accdd5cfd4c" translate="yes" xml:space="preserve">
          <source>Perl has three built-in data types: scalars, arrays of scalars, and associative arrays of scalars, known as &quot;hashes&quot;. A scalar is a single string (of any size, limited only by the available memory), number, or a reference to something (which will be discussed in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;). Normal arrays are ordered lists of scalars indexed by number, starting with 0. Hashes are unordered collections of scalar values indexed by their associated string key.</source>
          <target state="translated">Perl具有三种内置的数据类型：标量，标量数组和标量的关联数组，称为&amp;ldquo;哈希&amp;rdquo;。标量是单个字符串（任意大小，仅受可用内存限制），数字或对某物的引用（将在&lt;a href=&quot;perlref&quot;&gt;perlref中&lt;/a&gt;进行讨论）。普通数组是按数字索引的标量的有序列表，从0开始。哈希值是按标量值的无序集合，标量值由其关联的字符串键索引。</target>
        </trans-unit>
        <trans-unit id="fe80e5af445506b27b416f76f8599a7353684bc2" translate="yes" xml:space="preserve">
          <source>Perl has three main variable types: scalars, arrays, and hashes.</source>
          <target state="translated">Perl有三种主要的变量类型:标量、数组和哈希。</target>
        </trans-unit>
        <trans-unit id="5581a893a6439e102c22a8a8e459a544618d9458" translate="yes" xml:space="preserve">
          <source>Perl has three typedefs that handle Perl's three main data types:</source>
          <target state="translated">Perl有三个类型定义来处理Perl的三种主要数据类型。</target>
        </trans-unit>
        <trans-unit id="4982bfdcb9933aa8ea045e6714352b02205f1767" translate="yes" xml:space="preserve">
          <source>Perl has two major annual conventions: The Perl Conference (now part of OSCON), put on by O'Reilly, and Yet Another Perl Conference or YAPC (pronounced yap-see), which is localized into several regional YAPCs (North America, Europe, Asia) in a stunning grassroots display by the Perl community. For more information about either conference, check out their respective web pages: OSCON &lt;a href=&quot;http://conferences.oreillynet.com/&quot;&gt;http://conferences.oreillynet.com/&lt;/a&gt;; YAPC &lt;a href=&quot;http://www.yapc.org&quot;&gt;http://www.yapc.org&lt;/a&gt;.</source>
          <target state="translated">Perl有两个主要的年度大会：由O'Reilly主持的Perl会议（现在是OSCON的一部分），还有另一个Perl会议或YAPC（发音为yap-see），该会议已本地化为几个区域YAPC（北美，欧洲） （亚洲）在Perl社区的令人惊叹的草根展示中。有关任一会议的更多信息，请查看各自的网页：OSCON &lt;a href=&quot;http://conferences.oreillynet.com/&quot;&gt;http://conferences.oreillynet.com/&lt;/a&gt; ; YAPC &lt;a href=&quot;http://www.yapc.org&quot;&gt;http://www.yapc.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5fa0e69b9943a36c122fd92838ddb0e5f771d49b" translate="yes" xml:space="preserve">
          <source>Perl hash references become JSON objects. As there is no inherent ordering in hash keys (or JSON objects), they will usually be encoded in a pseudo-random order. JSON::PP can optionally sort the hash keys (determined by the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d410c5808a3d55ecb935a6972f7fdc386cde6d4b" translate="yes" xml:space="preserve">
          <source>Perl identifiers that begin with digits or punctuation characters are exempt from the effects of the &lt;code&gt;package&lt;/code&gt; declaration and are always forced to be in package &lt;code&gt;main&lt;/code&gt;; they are also exempt from &lt;code&gt;strict 'vars'&lt;/code&gt; errors. A few other names are also exempt in these ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6b908f8c33f304fe3c47ffea7a9a025bc30e32" translate="yes" xml:space="preserve">
          <source>Perl identifiers that begin with digits, control characters, or punctuation characters are exempt from the effects of the &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; declaration and are always forced to be in package &lt;code&gt;main&lt;/code&gt; ; they are also exempt from &lt;code&gt;strict 'vars'&lt;/code&gt; errors. A few other names are also exempt in these ways:</source>
          <target state="translated">以数字，控制字符或标点符号开头的Perl标识符不受 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 声明的影响，并且始终被强制包含在包 &lt;code&gt;main&lt;/code&gt; 中；他们也免于 &lt;code&gt;strict 'vars'&lt;/code&gt; 错误。其他一些名称也可以通过以下方式豁免：</target>
        </trans-unit>
        <trans-unit id="31969a763381ff2a4c90806f4b46526dbe2b269c" translate="yes" xml:space="preserve">
          <source>Perl implementations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8fd67f8a70f5e14b6e3a19738244712c763a3d5" translate="yes" xml:space="preserve">
          <source>Perl implements a class using a package, but the presence of a package doesn't imply the presence of a class. A package is just a namespace. A class is a package that provides subroutines that can be used as methods. A method is just a subroutine that expects, as its first argument, either the name of a package (for &quot;static&quot; methods), or a reference to something (for &quot;virtual&quot; methods).</source>
          <target state="translated">Perl用一个包来实现一个类,但包的存在并不意味着一个类的存在。一个包只是一个命名空间。一个类是一个提供子程序的包,这些子程序可以作为方法使用。一个方法只是一个子程序,它的第一个参数是一个包的名称(对于 &quot;静态 &quot;方法),或者是一个对某物的引用(对于 &quot;虚拟 &quot;方法)。</target>
        </trans-unit>
        <trans-unit id="58db3a9b91cfa56f68561f9fa6e162ac6046ad34" translate="yes" xml:space="preserve">
          <source>Perl implements a copy-on-write (COW) mechanism for scalars, in which string copies are not immediately made when requested, but are deferred until made necessary by one or the other scalar changing. This is mostly transparent, but one must take care not to modify string buffers that are shared by multiple SVs.</source>
          <target state="translated">Perl为标量实现了一种写后复制(copy-on-write,COW)机制,即当请求时,不会立即进行字符串复制,而是推迟到一个或另一个标量发生变化而变得必要时才进行。这在很大程度上是透明的,但必须注意不要修改由多个SV共享的字符串缓冲区。</target>
        </trans-unit>
        <trans-unit id="9f2e73e561af14b355b2cc7b94da012ba43ebaff" translate="yes" xml:space="preserve">
          <source>Perl in PASE may be used in the same manner as you would use Perl on AIX.</source>
          <target state="translated">PASE中的Perl可以像在AIX上使用Perl一样使用。</target>
        </trans-unit>
        <trans-unit id="f2a8c9dfcc6b27fc2b2bc1c4e09ed07f063fafcb" translate="yes" xml:space="preserve">
          <source>Perl inserts the contents of &lt;code&gt;$ENV{PERL5DB}&lt;/code&gt; (or &lt;code&gt;BEGIN {&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;
'perl5db.pl'}&lt;/code&gt; if not present) before the first line of your program.</source>
          <target state="translated">Perl中插入的内容 &lt;code&gt;$ENV{PERL5DB}&lt;/code&gt; （或 &lt;code&gt;BEGIN {&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'perl5db.pl'}&lt;/code&gt; 如果不存在）程序的第一行之前。</target>
        </trans-unit>
        <trans-unit id="5f14427130c0e5366717699f360d7e36f930c1e6" translate="yes" xml:space="preserve">
          <source>Perl inserts the contents of &lt;code&gt;$ENV{PERL5DB}&lt;/code&gt; (or &lt;code&gt;BEGIN {require 'perl5db.pl'}&lt;/code&gt; if not present) before the first line of your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23d0dc7556929e748dc66e21edf0645eb0e4825c" translate="yes" xml:space="preserve">
          <source>Perl installs into the SDK directory structure and expects many of the build tools present in the SDK to be available. So for the best results install the SDK first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9b4ba7a506b9d41ffb5e3879cb8f3519952178" translate="yes" xml:space="preserve">
          <source>Perl interface to IEEE Std 1003.1</source>
          <target state="translated">IEEE Std 1003.1的Perl接口。</target>
        </trans-unit>
        <trans-unit id="98db74e4a9950c02875b0447d97adf3fab69be22" translate="yes" xml:space="preserve">
          <source>Perl interface to the MD5 Algorithm</source>
          <target state="translated">MD5算法的Perl接口</target>
        </trans-unit>
        <trans-unit id="25640a112f893abdc0c31467980b237692e55c11" translate="yes" xml:space="preserve">
          <source>Perl interface to the UNIX syslog(3) calls</source>
          <target state="translated">的Perl接口,调用UNIX syslog(3)。</target>
        </trans-unit>
        <trans-unit id="eb268cafbb2bc2d6a265535e507a93da4ace82e9" translate="yes" xml:space="preserve">
          <source>Perl interface to various &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; packages.</source>
          <target state="translated">Perl与各种 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 软件包的接口。</target>
        </trans-unit>
        <trans-unit id="3c4d5afc98ae9e7a6b3b8ccc0bdaf8f20968aa0d" translate="yes" xml:space="preserve">
          <source>Perl interface to various &lt;code&gt;readline&lt;/code&gt; packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="532fa58abfc3c5192e3d89ee9b20cda6099a638d" translate="yes" xml:space="preserve">
          <source>Perl interpreter-based threads</source>
          <target state="translated">基于Perl解释器的线程</target>
        </trans-unit>
        <trans-unit id="7813b6fd0cf6ff0fcbbed68e090fa174337973c7" translate="yes" xml:space="preserve">
          <source>Perl is a &lt;b&gt;free-form&lt;/b&gt; language: you can format and indent it however you like. Whitespace serves mostly to separate tokens, unlike languages like Python where it is an important part of the syntax, or Fortran where it is immaterial.</source>
          <target state="translated">Perl是一种&lt;b&gt;自由格式的&lt;/b&gt;语言：您可以按自己的喜好格式化和缩进它。空格主要用于分隔令牌，这与Python等语言（而不是语法的重要组成部分）或Fortran语言（而不是语法）很重要。</target>
        </trans-unit>
        <trans-unit id="78b17861828e1fc00762c322f49cbad21d37d4a9" translate="yes" xml:space="preserve">
          <source>Perl is a general-purpose programming language originally developed for text manipulation and now used for a wide range of tasks including system administration, web development, network programming, GUI development, and more.</source>
          <target state="translated">Perl是一种通用的编程语言,最初是为文本操作而开发的,现在被广泛用于系统管理、网络开发、网络编程、GUI开发等任务。</target>
        </trans-unit>
        <trans-unit id="df24bdffd3ed3137e259ab273c3698d7eedca921" translate="yes" xml:space="preserve">
          <source>Perl is a high-level programming language with an eclectic heritage written by Larry Wall and a cast of thousands.</source>
          <target state="translated">Perl是一种高级编程语言,由Larry Wall和数千名演员编写,具有折中的传统。</target>
        </trans-unit>
        <trans-unit id="8e4a5a9567dfe12d565a7fe3569da1af894be351" translate="yes" xml:space="preserve">
          <source>Perl is a profligate wastrel when it comes to memory use. There is a saying that to estimate memory usage of Perl, assume a reasonable algorithm for memory allocation, multiply that estimate by 10, and while you still may miss the mark, at least you won't be quite so astonished. This is not absolutely true, but may provide a good grasp of what happens.</source>
          <target state="translated">在内存使用方面,Perl是个挥霍无度的废柴。有一种说法是,要估计Perl的内存使用量,假设一个合理的内存分配算法,将这个估计值乘以10,虽然你仍然可能会失误,但至少你不会那么惊讶。这并不是绝对正确的,但可以提供一个很好的把握。</target>
        </trans-unit>
        <trans-unit id="5676662b05d1f0dfe8bee99aada0c212a7cfdcd0" translate="yes" xml:space="preserve">
          <source>Perl is at the mercy of your machine's definitions of various operations such as type casting, atof(), and floating-point output with sprintf().</source>
          <target state="translated">Perl是由你的机器对各种操作的定义所决定的,比如类型转换,atof(),以及用sprintf()进行浮点输出。</target>
        </trans-unit>
        <trans-unit id="cf13bfd73fd319a7fa88b1a848a7fd42bf50c10e" translate="yes" xml:space="preserve">
          <source>Perl is available for most operating systems, including virtually all Unix-like platforms. See &lt;a href=&quot;perlport#Supported-Platforms&quot;&gt;&quot;Supported Platforms&quot; in perlport&lt;/a&gt; for a listing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d9807bc15de484f6b43cc02362e93cc66150c42" translate="yes" xml:space="preserve">
          <source>Perl is available for most operating systems, including virtually all Unix-like platforms. See &lt;a href=&quot;perlport#Supported-Platforms&quot;&gt;Supported Platforms in perlport&lt;/a&gt; for a listing.</source>
          <target state="translated">Perl可用于大多数操作系统，包括几乎所有类似Unix的平台。有关列表，请参见&lt;a href=&quot;perlport#Supported-Platforms&quot;&gt;perlport&lt;/a&gt;中的支持的平台。</target>
        </trans-unit>
        <trans-unit id="464c9f17acbbf3521c9fe1d4bfb03f4c8f71635b" translate="yes" xml:space="preserve">
          <source>Perl is binary-clean, so it can handle binary data just fine. On Windows or DOS, however, you have to use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; for binary files to avoid conversions for line endings. In general, you should use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; any time you want to work with binary data.</source>
          <target state="translated">Perl是二进制干净的，因此它可以很好地处理二进制数据。但是，在Windows或DOS上，必须对二进制文件使用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 以避免转换行尾。通常，任何时候要使用二进制数据时，都应使用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f177d6bd3fecf3c385b90d51e6e9dcdc131d2dc5" translate="yes" xml:space="preserve">
          <source>Perl is binary-clean, so it can handle binary data just fine. On Windows or DOS, however, you have to use &lt;code&gt;binmode&lt;/code&gt; for binary files to avoid conversions for line endings. In general, you should use &lt;code&gt;binmode&lt;/code&gt; any time you want to work with binary data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432dc52a3d4248eb12d8ce12a42a4bd4668bcd6d" translate="yes" xml:space="preserve">
          <source>Perl is built using PerlIO by default; Unless you've changed this (such as building Perl with &lt;code&gt;Configure -Uuseperlio&lt;/code&gt; ), you can open filehandles directly to Perl scalars via:</source>
          <target state="translated">默认情况下，Perl是使用PerlIO构建的。除非您进行了更改（例如，使用 &lt;code&gt;Configure -Uuseperlio&lt;/code&gt; 构建Perl ），否则可以通过以下方式直接将文件句柄打开到Perl标量：</target>
        </trans-unit>
        <trans-unit id="e2ba202ee46521f5f5b0bea93e68c6d4e90de303" translate="yes" xml:space="preserve">
          <source>Perl is built with a &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; variable that indicates the operating system it was built on. This was implemented to help speed up code that would otherwise have to &lt;code&gt;use Config&lt;/code&gt; and use the value of &lt;a href=&quot;config#osname&quot;&gt;&lt;code&gt;$Config{osname}&lt;/code&gt;&lt;/a&gt;. Of course, to get more detailed information about the system, looking into &lt;a href=&quot;config#DESCRIPTION&quot;&gt;&lt;code&gt;%Config&lt;/code&gt;&lt;/a&gt; is certainly recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5ecc6508ddab8f3c4d91e33bbc7e0f0b10c001" translate="yes" xml:space="preserve">
          <source>Perl is built with a &lt;code&gt;$^O&lt;/code&gt; variable that indicates the operating system it was built on. This was implemented to help speed up code that would otherwise have to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; and use the value of &lt;code&gt;$Config{osname}&lt;/code&gt; . Of course, to get more detailed information about the system, looking into &lt;code&gt;%Config&lt;/code&gt; is certainly recommended.</source>
          <target state="translated">Perl是用 &lt;code&gt;$^O&lt;/code&gt; 变量构建的，该变量指示构建它的操作系统。这样做是为了帮助加快代码，而这些代码本来必须 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; 并使用 &lt;code&gt;$Config{osname}&lt;/code&gt; 的值。当然，要获取有关系统的更多详细信息，当然建议查看 &lt;code&gt;%Config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0b403c257bdd4aeec1cd64ac49b8e8696c81aad" translate="yes" xml:space="preserve">
          <source>Perl is designed to make it easy to program securely even when running with extra privileges, like setuid or setgid programs. Unlike most command line shells, which are based on multiple substitution passes on each line of the script, Perl uses a more conventional evaluation scheme with fewer hidden snags. Additionally, because the language has more builtin functionality, it can rely less upon external (and possibly untrustworthy) programs to accomplish its purposes.</source>
          <target state="translated">Perl 的设计目的是为了使它能够轻松安全地进行编程,即使是以额外的权限运行,比如 setuid 或 setgid 程序。与大多数命令行 shell 不同的是,Perl 使用的是更为传统的评估方案,其隐患更少。此外,由于该语言有更多的内置功能,它可以较少地依赖外部(可能是不值得信任的)程序来实现其目的。</target>
        </trans-unit>
        <trans-unit id="95e020b4e0da8b6212d413773e1d9a2f7cfa598b" translate="yes" xml:space="preserve">
          <source>Perl is flexible and extensible enough for you to use on virtually any task, from one-line file-processing tasks to large, elaborate systems.</source>
          <target state="translated">Perl的灵活性和可扩展性足以让你在任何任务中使用,从单行文件处理任务到大型复杂的系统。</target>
        </trans-unit>
        <trans-unit id="6ca32777c65e9c1e819db2ba028d7f7c9855e9eb" translate="yes" xml:space="preserve">
          <source>Perl is generally used in the situation when all the floating-point exceptions are ignored, as is the default under EMX. If they are not ignored, some benign Perl programs would get a &lt;code&gt;SIGFPE&lt;/code&gt; and would die a horrible death.</source>
          <target state="translated">Perl通常用于忽略所有浮点异常的情况，这是EMX中的默认设置。如果不忽略它们，某些良性的Perl程序将获得 &lt;code&gt;SIGFPE&lt;/code&gt; ,并且将死于可怕的死亡。</target>
        </trans-unit>
        <trans-unit id="3df1fe819c8ca8623cc85794dcd13ce337949f92" translate="yes" xml:space="preserve">
          <source>Perl is invoked from the command line as described in &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt;. Most perl scripts, however, do have a first line such as &quot;#!/usr/local/bin/perl&quot;. This is known as a shebang (shell-bang) statement and tells the OS shell where to find the perl interpreter. In Plan 9 Perl this statement should be &quot;#!/bin/perl&quot; if you wish to be able to directly invoke the script by its name. Alternatively, you may invoke perl with the command &quot;Perl&quot; instead of &quot;perl&quot;. This will produce Acme-friendly error messages of the form &quot;filename:18&quot;.</source>
          <target state="translated">如&lt;a href=&quot;perl&quot;&gt;perl中&lt;/a&gt;所述，从命令行调用Perl。但是，大多数perl脚本确实有第一行，例如&amp;ldquo;＃！/ usr / local / bin / perl&amp;rdquo;。这称为shebang（shell-bang）语句，它告诉OS Shell在哪里可以找到perl解释器。在Plan 9 Perl中，如果您希望能够通过脚本名称直接调用该脚本，则该语句应为&amp;ldquo;＃！/ bin / perl&amp;rdquo;。或者，您可以使用命令&amp;ldquo; Perl&amp;rdquo;而不是&amp;ldquo; perl&amp;rdquo;来调用perl。这将产生格式为&amp;ldquo; filename：18&amp;rdquo;的Acme友好错误消息。</target>
        </trans-unit>
        <trans-unit id="e108d57bca9b7851cac34cf12c398ccee3cee194" translate="yes" xml:space="preserve">
          <source>Perl is one of the most ported pieces of software ever. It works on operating systems I've never even heard of (see perlport for details). It needs a build tool that can work on all those platforms and with any wacky C compilers and linkers they might have.</source>
          <target state="translated">Perl 是有史以来移植最多的软件之一。它可以在我从未听说过的操作系统上运行 (详见 perlport)。它需要一个能够在所有这些平台上工作的编译器和链接器的构建工具。</target>
        </trans-unit>
        <trans-unit id="69310d8ba2e9aaba734a13daced6bd681b7dd539" translate="yes" xml:space="preserve">
          <source>Perl is widely renowned for excellence in text processing, and regular expressions are one of the big factors behind this fame. Perl regular expressions display an efficiency and flexibility unknown in most other computer languages. Mastering even the basics of regular expressions will allow you to manipulate text with surprising ease.</source>
          <target state="translated">Perl以其在文本处理方面的卓越表现而广为人知,而正则表达式则是这种名声背后的重要因素之一。Perl正则表达式表现出的效率和灵活性是其他大多数计算机语言所无法比拟的。即使是掌握正则表达式的基础知识,也能让你出人意料地轻松处理文本。</target>
        </trans-unit>
        <trans-unit id="9136a62ad4b5fb86c3834a4ff695ef28ba74673c" translate="yes" xml:space="preserve">
          <source>Perl isn't sure if you meant this</source>
          <target state="translated">Perl不知道你是不是指这个</target>
        </trans-unit>
        <trans-unit id="29e85b3cc84aac2162dbddc5c0e070c097c573e4" translate="yes" xml:space="preserve">
          <source>Perl itself (outside the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module) will not use locales unless specifically requested to (but again note that Perl may interact with code that does use them). Even if there is such a request, &lt;b&gt;all&lt;/b&gt; of the following must be true for it to work properly:</source>
          <target state="translated">除非明确要求，否则Perl本身（在&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块外部）将不使用语言环境（但再次请注意，Perl可能会与使用它们的代码进行交互）。即使有这样的请求，也必须满足以下&lt;b&gt;所有&lt;/b&gt;条件才能使其正常工作：</target>
        </trans-unit>
        <trans-unit id="b448d0fc5ff15548da831acf37af4494d6504c93" translate="yes" xml:space="preserve">
          <source>Perl itself never had a Y2K problem, although that never stopped people from creating Y2K problems on their own. See the documentation for &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; for its proper use.</source>
          <target state="translated">Perl本身从未遇到过Y2K问题，尽管这并没有阻止人们自己创造Y2K问题。请参阅 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 时间文档以正确使用。</target>
        </trans-unit>
        <trans-unit id="f2cc4a6fccf4fd64e021bb2b5f362d3715f43b3f" translate="yes" xml:space="preserve">
          <source>Perl itself never had a Y2K problem, although that never stopped people from creating Y2K problems on their own. See the documentation for &lt;code&gt;localtime&lt;/code&gt; for its proper use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44b05ec97c9cd0cd0a392295c641d71beeda8b2c" translate="yes" xml:space="preserve">
          <source>Perl keeps the actual data in a linked list of structures with a typedef of HE. These contain the actual key and value pointers (plus extra administrative overhead). The key is a string pointer; the value is an &lt;code&gt;SV*&lt;/code&gt; . However, once you have an &lt;code&gt;HE*&lt;/code&gt; , to get the actual key and value, use the routines specified below.</source>
          <target state="translated">Perl将实际数据保存在类型为HE的结构的链接列表中。这些包含实际的键和值指针（加上额外的管理开销）。键是一个字符串指针；该值为 &lt;code&gt;SV*&lt;/code&gt; 。但是，一旦有了 &lt;code&gt;HE*&lt;/code&gt; ，要获取实际的键和值，请使用下面指定的例程。</target>
        </trans-unit>
        <trans-unit id="fb449bcf7d8ee7c61f13e13d363e2fbfa90f9e62" translate="yes" xml:space="preserve">
          <source>Perl keeps the actual data in a linked list of structures with a typedef of HE. These contain the actual key and value pointers (plus extra administrative overhead). The key is a string pointer; the value is an &lt;code&gt;SV*&lt;/code&gt;. However, once you have an &lt;code&gt;HE*&lt;/code&gt;, to get the actual key and value, use the routines specified below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5143bb91f08dc1c6dfd63a718e07f8c7c54d1b4" translate="yes" xml:space="preserve">
          <source>Perl knows how it stored the string internally, and will use that knowledge when you &lt;code&gt;encode&lt;/code&gt; . In other words: don't try to find out what the internal encoding for a certain string is, but instead just encode it into the encoding that you want.</source>
          <target state="translated">Perl知道它如何在内部存储字符串，并且在 &lt;code&gt;encode&lt;/code&gt; 时会使用该知识。换句话说：不要试图找出某个字符串的内部编码是什么，而只是将其编码为所需的编码。</target>
        </trans-unit>
        <trans-unit id="c655bf7234ceeb2dde7bb0db4fba269b70d380f3" translate="yes" xml:space="preserve">
          <source>Perl knows how it stored the string internally, and will use that knowledge when you &lt;code&gt;encode&lt;/code&gt;. In other words: don't try to find out what the internal encoding for a certain string is, but instead just encode it into the encoding that you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c0b3b1efe64d6536aefbbd7df5f013304f845e" translate="yes" xml:space="preserve">
          <source>Perl knows what package the method is in by looking at the left side of the arrow. If the left hand side is a package name, it looks for the method in that package. If the left hand side is an object, then Perl looks for the method in the package that the object has been blessed into.</source>
          <target state="translated">Perl通过看箭头左边的箭头就知道这个方法在哪个包里。如果左手边是包名,那么它就会寻找该包中的方法。如果左手边是一个对象,那么 Perl 会在这个对象被祝福的包中寻找方法。</target>
        </trans-unit>
        <trans-unit id="5816a72e8edbf2978259af959564532c0158a768" translate="yes" xml:space="preserve">
          <source>Perl lets us have complex data structures. You can write something like this and all of a sudden, you'd have an array with three dimensions!</source>
          <target state="translated">Perl让我们拥有复杂的数据结构。你可以写这样的东西,突然间,你就有了一个三维的数组。</target>
        </trans-unit>
        <trans-unit id="c792eeb72bf7222c26382dcf2643ff8d2431a9b2" translate="yes" xml:space="preserve">
          <source>Perl lets you use a scalar variable containing a string as a method name:</source>
          <target state="translated">Perl允许你使用一个包含字符串的标量变量作为方法名。</target>
        </trans-unit>
        <trans-unit id="cbe2b90e37525ab41be0459f402495dfeae82682" translate="yes" xml:space="preserve">
          <source>Perl maintains environment variables in a special hash named &lt;code&gt;%ENV&lt;/code&gt; . For when this access method is inconvenient, the Perl module &lt;code&gt;Env&lt;/code&gt; allows environment variables to be treated as scalar or array variables.</source>
          <target state="translated">Perl在名为 &lt;code&gt;%ENV&lt;/code&gt; 的特殊哈希中维护环境变量。对于这种访问方法不方便的情况，Perl模块 &lt;code&gt;Env&lt;/code&gt; 允许将环境变量视为标量或数组变量。</target>
        </trans-unit>
        <trans-unit id="2f4c9c62b19928dbcce3428ee1199a16ecae0aed" translate="yes" xml:space="preserve">
          <source>Perl maintains environment variables in a special hash named &lt;code&gt;%ENV&lt;/code&gt;. For when this access method is inconvenient, the Perl module &lt;code&gt;Env&lt;/code&gt; allows environment variables to be treated as scalar or array variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adff6cd758f5a3032ba367b5b7627b9df7afebcc" translate="yes" xml:space="preserve">
          <source>Perl makes all environment variables available to the program being executed, and passes these along to any child processes it starts. However, programs running setuid would do well to execute the following lines before doing anything else, just to keep people honest:</source>
          <target state="translated">Perl 将所有的环境变量提供给正在执行的程序,并将这些变量传递给它启动的任何子进程。然而,运行 setuid 的程序最好在做其他事情之前先执行以下几行,以保证人们的诚实。</target>
        </trans-unit>
        <trans-unit id="162c022ef155f35d9a828d8883301923c1130fa3" translate="yes" xml:space="preserve">
          <source>Perl manual in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb37d4ff4d4f8d3c98e670fbe144d6ded8ac9e4" translate="yes" xml:space="preserve">
          <source>Perl may also use &lt;code&gt;minus()&lt;/code&gt; to implement other operators which have not been specified in the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive, according to the rules for &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;Magic Autogeneration&lt;/a&gt; described later. For example, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; above declared no subroutine for any of the operators &lt;code&gt;--&lt;/code&gt; , &lt;code&gt;neg&lt;/code&gt; (the overload key for unary minus), or &lt;code&gt;-=&lt;/code&gt; . Thus</source>
          <target state="translated">根据&lt;a href=&quot;#Magic-Autogeneration&quot;&gt;稍后&lt;/a&gt;描述的Magic Autogeneration的规则，Perl还可以使用 &lt;code&gt;minus()&lt;/code&gt; 来实现 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 指令中未指定的其他运算符。例如，上述 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 重载对于任何运算符 &lt;code&gt;--&lt;/code&gt; ， &lt;code&gt;neg&lt;/code&gt; （一元减号的重载键）或 &lt;code&gt;-=&lt;/code&gt; 都不声明任何子例程。从而</target>
        </trans-unit>
        <trans-unit id="386fe189f1039aa3ac9a068a2d2a8d19e7ef0b9d" translate="yes" xml:space="preserve">
          <source>Perl may also use &lt;code&gt;minus()&lt;/code&gt; to implement other operators which have not been specified in the &lt;code&gt;use overload&lt;/code&gt; directive, according to the rules for &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;&quot;Magic Autogeneration&quot;&lt;/a&gt; described later. For example, the &lt;code&gt;use overload&lt;/code&gt; above declared no subroutine for any of the operators &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;neg&lt;/code&gt; (the overload key for unary minus), or &lt;code&gt;-=&lt;/code&gt;. Thus</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8da87cabae75ef4041db61733575500f2f5c87" translate="yes" xml:space="preserve">
          <source>Perl may be built to ignore this variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc722e05604a8e2215a16848c1b1749c16faaf82" translate="yes" xml:space="preserve">
          <source>Perl may be run from the AmigaOS shell but for best results should be run under abc-shell. (abc-shell handles file globbing, pattern expansion, and sets up environment variables in the UN*Xy way that Perl expects.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d02d1a8d8ad8ebaf66f5ae1fae9a8be6973bfe68" translate="yes" xml:space="preserve">
          <source>Perl modifies some standard C library calls in the following ways:</source>
          <target state="translated">Perl用以下方式修改了一些标准的C库调用。</target>
        </trans-unit>
        <trans-unit id="ae2b30d9e1d501c616a9183c5e463ad869566bb9" translate="yes" xml:space="preserve">
          <source>Perl module that imports environment variables as scalars or arrays</source>
          <target state="translated">将环境变量作为标量或数组导入的Perl模块。</target>
        </trans-unit>
        <trans-unit id="8ba6990d9c4bf6e673e08de2996db458f738f918" translate="yes" xml:space="preserve">
          <source>Perl modules &lt;a href=&quot;BSD::Resource&quot;&gt;BSD::Resource&lt;/a&gt;, &lt;a href=&quot;Time::TAI64&quot;&gt;Time::TAI64&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf20acb7bc71507889f12ba0d9ef4ff255fd169" translate="yes" xml:space="preserve">
          <source>Perl modules &lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Resource&quot;&gt;BSD::Resource&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Time::TAI64&quot;&gt;Time::TAI64&lt;/a&gt;.</source>
          <target state="translated">Perl模块&lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Resource&quot;&gt;BSD :: Resource&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Time::TAI64&quot;&gt;Time :: TAI64&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9426f05ffd49561244dd50c76b095078d755129d" translate="yes" xml:space="preserve">
          <source>Perl modules always have a</source>
          <target state="translated">Perl模块总是有一个</target>
        </trans-unit>
        <trans-unit id="51c59ce0ac574ea7f8b9de507be10bf4487a787f" translate="yes" xml:space="preserve">
          <source>Perl modules are included into your program by saying</source>
          <target state="translated">将Perl模块包含在你的程序中,说</target>
        </trans-unit>
        <trans-unit id="aefb322d2fca2dbb6f88aa84174a1e5c7a427c0e" translate="yes" xml:space="preserve">
          <source>Perl modules are not the only tools a performance analyst has at their disposal, system tools like &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; should not be overlooked as the next example shows, where we take a quick look at sorting. Many books, theses and articles, have been written about efficient sorting algorithms, and this is not the place to repeat such work, there's several good sorting modules which deserve taking a look at too: &lt;code&gt;Sort::Maker&lt;/code&gt; , &lt;code&gt;Sort::Key&lt;/code&gt; spring to mind. However, it's still possible to make some observations on certain Perl specific interpretations on issues relating to sorting data sets and give an example or two with regard to how sorting large data volumes can effect performance. Firstly, an often overlooked point when sorting large amounts of data, one can attempt to reduce the data set to be dealt with and in many cases &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; can be quite useful as a simple filter:</source>
          <target state="translated">Perl模块并不是性能分析人员可以使用的唯一工具，下一个示例显示了我们不应该忽略诸如 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 类的系统工具，在此我们快速地进行了排序。已经写了许多关于有效排序算法的书籍，论文和文章，而这里并不是重复此类工作的地方，这里有几个不错的排序模块也值得一看： &lt;code&gt;Sort::Maker&lt;/code&gt; ， &lt;code&gt;Sort::Key&lt;/code&gt; 浮现在脑海。但是，仍然有可能对某些Perl特定的解释进行观察，以解释与排序数据集有关的问题，并给出一两个示例，说明对大数据量进行排序如何影响性能。首先，排序大量数据时经常被忽视的一点是，人们可以尝试减少要处理的数据集，并且在许多情况下， &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; 作为简单的过滤器非常有用：</target>
        </trans-unit>
        <trans-unit id="c620f5ed9b475e8a05d4bd8c8511a64bdd8fb857" translate="yes" xml:space="preserve">
          <source>Perl modules are not the only tools a performance analyst has at their disposal, system tools like &lt;code&gt;time&lt;/code&gt; should not be overlooked as the next example shows, where we take a quick look at sorting. Many books, theses and articles, have been written about efficient sorting algorithms, and this is not the place to repeat such work, there's several good sorting modules which deserve taking a look at too: &lt;code&gt;Sort::Maker&lt;/code&gt;, &lt;code&gt;Sort::Key&lt;/code&gt; spring to mind. However, it's still possible to make some observations on certain Perl specific interpretations on issues relating to sorting data sets and give an example or two with regard to how sorting large data volumes can effect performance. Firstly, an often overlooked point when sorting large amounts of data, one can attempt to reduce the data set to be dealt with and in many cases &lt;code&gt;grep()&lt;/code&gt; can be quite useful as a simple filter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8ed366b21e1c4b28e58fe8a9ca47a44e9e81f0c" translate="yes" xml:space="preserve">
          <source>Perl modules included on CPAN have a naming hierarchy you should try to fit in with. See &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for more details on how this works, and browse around CPAN and the modules list to get a feel of it. At the very least, remember this: modules should be title capitalised, (This::Thing) fit in with a category, and explain their purpose succinctly.</source>
          <target state="translated">CPAN包含的Perl模块具有您应尝试使用的命名层次结构。有关如何工作的更多详细信息，请参见&lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt;，并浏览CPAN和模块列表以了解它。至少要记住这一点：模块的标题应大写，（This :: Thing）符合类别，并简要说明其用途。</target>
        </trans-unit>
        <trans-unit id="16a1215b63adeb8dd991dd695ae42ffb9a1eb457" translate="yes" xml:space="preserve">
          <source>Perl modules provide a range of features to help you avoid reinventing the wheel, and can be downloaded from CPAN ( &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; ). A number of popular modules are included with the Perl distribution itself.</source>
          <target state="translated">Perl模块提供了一系列功能来帮助您避免重新发明轮子，并且可以从CPAN（&lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;）下载。Perl发行版本身包含许多流行的模块。</target>
        </trans-unit>
        <trans-unit id="4baa5fc19e15bb718240e4d275bac1fb00891783" translate="yes" xml:space="preserve">
          <source>Perl mongers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1cd3ab508bb28b102f16c9bbb53b67e972c7a2d" translate="yes" xml:space="preserve">
          <source>Perl must be compiled with the &lt;code&gt;-Dusedtrace&lt;/code&gt; option in order to make use of the provided probes. While DTrace aims to have no overhead when its instrumentation is not active, Perl's support itself cannot uphold that guarantee, so it is built without DTrace probes under most systems. One notable exception is that Mac OS X ships a</source>
          <target state="translated">为了使用提供的探针，必须使用 &lt;code&gt;-Dusedtrace&lt;/code&gt; 选项编译Perl 。虽然DTrace的目标是在不使用其仪器时不产生任何开销，但Perl的支持本身无法维持这一保证，因此在大多数系统下，它都是在没有DTrace探针的情况下构建的。一个值得注意的例外是Mac OS X附带了</target>
        </trans-unit>
        <trans-unit id="4f0521c787f7204ca515e6ab4a24e34133e68740" translate="yes" xml:space="preserve">
          <source>Perl never issued a deprecation warning for this; the deprecation was by documentation policy only. But this deprecation has been lifted as of Perl 5.26.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7959a78b422ac56c4b5d4bc26bed7e5e49a45d2d" translate="yes" xml:space="preserve">
          <source>Perl normally assumes character semantics in the presence of character data (i.e. data that has come from a source that has been marked as being of a particular character encoding). When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; is in effect, the encoding is temporarily ignored, and each string is treated as a series of bytes.</source>
          <target state="translated">Perl通常在存在字符数据（即来自已被标记为具有特定字符编码的源的数据）的情况下假定字符语义。当 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 有效时，将暂时忽略编码，并将每个字符串视为一系列字节。</target>
        </trans-unit>
        <trans-unit id="1b90be8b391bd63ee34d9c789dadd260ffcc448a" translate="yes" xml:space="preserve">
          <source>Perl normally buffers output so it doesn't make a system call for every bit of output. By saving up output, it makes fewer expensive system calls. For instance, in this little bit of code, you want to print a dot to the screen for every line you process to watch the progress of your program. Instead of seeing a dot for every line, Perl buffers the output and you have a long wait before you see a row of 50 dots all at once:</source>
          <target state="translated">Perl通常会对输出进行缓冲,所以它不会为每一点输出进行系统调用。通过保存输出,它可以减少昂贵的系统调用。例如,在这段小代码中,你想为每处理一行打印一个点到屏幕上,以观察程序的进度。Perl会缓冲输出,而不是每行都看到一个点,你要等很久才能一下子看到一排50个点。</target>
        </trans-unit>
        <trans-unit id="431e8ad9293b07f5bdc791f87a08a93d077e2bfe" translate="yes" xml:space="preserve">
          <source>Perl now builds with FreeMiNT/Atari. It fails a few tests, that needs some investigation.</source>
          <target state="translated">Perl现在用FreeMiNT/Atari构建。有几个测试失败了,这需要调查一下。</target>
        </trans-unit>
        <trans-unit id="a3e768752fac3a285306cd9e651f17f9a775de00" translate="yes" xml:space="preserve">
          <source>Perl officially stands for Practical Extraction and Report Language, except when it doesn't.</source>
          <target state="translated">Perl官方代表的是实用提取和报告语言,除了当它不是。</target>
        </trans-unit>
        <trans-unit id="b0646278b43c189bd46c39a69a1dddf12d2a1a29" translate="yes" xml:space="preserve">
          <source>Perl on ILE</source>
          <target state="translated">Perl on ILE</target>
        </trans-unit>
        <trans-unit id="880fc5c1aef63a3507fd91075a126effdad077b7" translate="yes" xml:space="preserve">
          <source>Perl on VMS can accept either VMS- or Unix-style file specifications as in either of the following:</source>
          <target state="translated">VMS上的Perl可以接受VMS或Unix风格的文件规范,如以下任何一种。</target>
        </trans-unit>
        <trans-unit id="4e6cb5edd48ea8ec698a9fa2e92cd3f38a3692ce" translate="yes" xml:space="preserve">
          <source>Perl on VMS is discussed in &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt; in the Perl distribution.</source>
          <target state="translated">Perl 发行版中的&lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt;中讨论了VMS上的Perl。</target>
        </trans-unit>
        <trans-unit id="d5aebe7d6ab79a49ac64f2ccd625e787536b0d61" translate="yes" xml:space="preserve">
          <source>Perl on VMS supports an emulation of the forked debugger when Perl is run on a VMS system that has X11 support installed.</source>
          <target state="translated">当Perl在安装了X11支持的VMS系统上运行时,VMS上的Perl支持对forked调试器的模拟。</target>
        </trans-unit>
        <trans-unit id="e4268b27ba1ef13a83b583c860e24d2f36fbf4ec" translate="yes" xml:space="preserve">
          <source>Perl on VOS (also known as OpenVOS) is discussed in</source>
          <target state="translated">VOS上的Perl(也称为OpenVOS)将在下面讨论</target>
        </trans-unit>
        <trans-unit id="30b19fafc5c58735f6b1d4a22aac29cb87b533e0" translate="yes" xml:space="preserve">
          <source>Perl only implements the full form of casefolding, but you can access the simple folds using &lt;a href=&quot;../unicode/ucd#casefold()&quot;&gt;casefold() in Unicode::UCD&lt;/a&gt; and &lt;a href=&quot;../unicode/ucd#prop_invmap()&quot;&gt;prop_invmap() in Unicode::UCD&lt;/a&gt;. For further information on casefolding, refer to the Unicode Standard, specifically sections 3.13 &lt;code&gt;Default Case Operations&lt;/code&gt; , 4.2 &lt;code&gt;Case-Normative&lt;/code&gt; , and 5.18 &lt;code&gt;Case Mappings&lt;/code&gt; , available at &lt;a href=&quot;http://www.unicode.org/versions/latest/&quot;&gt;http://www.unicode.org/versions/latest/&lt;/a&gt;, as well as the Case Charts available at &lt;a href=&quot;http://www.unicode.org/charts/case/&quot;&gt;http://www.unicode.org/charts/case/&lt;/a&gt;.</source>
          <target state="translated">Perl仅实现完整的折叠形式，但是您可以使用&lt;a href=&quot;../unicode/ucd#casefold()&quot;&gt;Unicode :: UCD中的&lt;/a&gt;&lt;a href=&quot;../unicode/ucd#prop_invmap()&quot;&gt;casefold（）&lt;/a&gt;和Unicode :: UCD中的prop_invmap（）来访问简单折叠。有关案例折叠的更多信息，请参见Unicode标准，特别是第3.13节&amp;ldquo; &lt;code&gt;Default Case Operations&lt;/code&gt; ，&amp;ldquo; 4.2 &lt;code&gt;Case-Normative&lt;/code&gt; &amp;rdquo;和&amp;ldquo; 5.18 &lt;code&gt;Case Mappings&lt;/code&gt; ，可从&lt;a href=&quot;http://www.unicode.org/versions/latest/&quot;&gt;http://www.unicode.org/versions/latest/获得&lt;/a&gt;，以及案例表可从&lt;a href=&quot;http://www.unicode.org/charts/case/&quot;&gt;http://www.unicode.org/charts/case/获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec15f965c51c1ac480bfbe6c5c4b87645989a486" translate="yes" xml:space="preserve">
          <source>Perl only implements the full form of casefolding, but you can access the simple folds using &lt;a href=&quot;Unicode::UCD#casefold%28%29&quot;&gt;&quot;&lt;b&gt;casefold()&lt;/b&gt;&quot; in Unicode::UCD&lt;/a&gt; and &lt;a href=&quot;Unicode::UCD#prop_invmap%28%29&quot;&gt;&quot;&lt;b&gt;prop_invmap()&lt;/b&gt;&quot; in Unicode::UCD&lt;/a&gt;. For further information on casefolding, refer to the Unicode Standard, specifically sections 3.13 &lt;code&gt;Default Case Operations&lt;/code&gt;, 4.2 &lt;code&gt;Case-Normative&lt;/code&gt;, and 5.18 &lt;code&gt;Case Mappings&lt;/code&gt;, available at &lt;a href=&quot;https://www.unicode.org/versions/latest/&quot;&gt;https://www.unicode.org/versions/latest/&lt;/a&gt;, as well as the Case Charts available at &lt;a href=&quot;https://www.unicode.org/charts/case/&quot;&gt;https://www.unicode.org/charts/case/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03ce9ffc7efddb5ffb70fe53243d42ea4fbb733a" translate="yes" xml:space="preserve">
          <source>Perl only implements the full form of casefolding, but you can access the simple folds using &lt;a href=&quot;unicode/ucd#casefold()&quot;&gt;casefold() in Unicode::UCD&lt;/a&gt; and &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;prop_invmap() in Unicode::UCD&lt;/a&gt;. For further information on casefolding, refer to the Unicode Standard, specifically sections 3.13 &lt;code&gt;Default Case Operations&lt;/code&gt; , 4.2 &lt;code&gt;Case-Normative&lt;/code&gt; , and 5.18 &lt;code&gt;Case Mappings&lt;/code&gt; , available at &lt;a href=&quot;http://www.unicode.org/versions/latest/&quot;&gt;http://www.unicode.org/versions/latest/&lt;/a&gt;, as well as the Case Charts available at &lt;a href=&quot;http://www.unicode.org/charts/case/&quot;&gt;http://www.unicode.org/charts/case/&lt;/a&gt;.</source>
          <target state="translated">Perl仅实现完整的折叠形式，但是您可以使用&lt;a href=&quot;unicode/ucd#casefold()&quot;&gt;Unicode :: UCD中的&lt;/a&gt;&lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;casefold（）&lt;/a&gt;和Unicode :: UCD中的prop_invmap（）来访问简单折叠。有关案例折叠的更多信息，请参见Unicode标准，特别是第3.13节&amp;ldquo; &lt;code&gt;Default Case Operations&lt;/code&gt; ，&amp;ldquo; 4.2 &lt;code&gt;Case-Normative&lt;/code&gt; &amp;rdquo;和&amp;ldquo; 5.18 &lt;code&gt;Case Mappings&lt;/code&gt; ，可从&lt;a href=&quot;http://www.unicode.org/versions/latest/&quot;&gt;http://www.unicode.org/versions/latest/获得&lt;/a&gt;，以及案例表可从&lt;a href=&quot;http://www.unicode.org/charts/case/&quot;&gt;http://www.unicode.org/charts/case/获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="afa3b7b0cef4f08dacda3735ba0561143481e189" translate="yes" xml:space="preserve">
          <source>Perl operations which take a numeric argument treat that argument in one of four different ways: they may force it to one of the integer/floating/ string formats, or they may behave differently depending on the format of the operand. Forcing a numeric value to a particular format does not change the number stored in the value.</source>
          <target state="translated">Perl 中对数字参数的操作有四种不同的处理方式:它们可能会将参数强制为整数/浮点数/字符串格式中的一种,也可能会根据操作数的格式而采取不同的行为。将一个数值强制为特定的格式并不会改变该数值中存储的数字。</target>
        </trans-unit>
        <trans-unit id="2e266081b45b4d898d18421d1048baf2bfd24b32" translate="yes" xml:space="preserve">
          <source>Perl operators are documented in full in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;, but here are a few of the most common ones:</source>
          <target state="translated">Perl的运营商都记录在充满&lt;a href=&quot;perlop&quot;&gt;perlop中&lt;/a&gt;，但这里有一些最常见的：</target>
        </trans-unit>
        <trans-unit id="f67a6a1b456cb0e8982256ff29539f81c3619324" translate="yes" xml:space="preserve">
          <source>Perl operators have the following associativity and precedence, listed from highest precedence to lowest. Operators borrowed from C keep the same precedence relationship with each other, even where C's precedence is slightly screwy. (This makes learning Perl easier for C folks.) With very few exceptions, these all operate on scalar values only, not array values.</source>
          <target state="translated">Perl运算符的关联性和优先性如下,从最高的优先性到最低的优先性排列。从 C 语言借来的操作符之间保持相同的优先级关系,即使是在 C 语言的优先级稍有不顺的地方。(这使得C语言的人学习Perl更容易。)除了极少数例外,这些运算符都只对标量值进行操作,而不是数组值。</target>
        </trans-unit>
        <trans-unit id="979c77e2112ac6d101931348fcf8adccee72ed6b" translate="yes" xml:space="preserve">
          <source>Perl operators that return true or false generally return values that can be safely used as numbers. For example, the relational operators in this section and the equality operators in the next one return &lt;code&gt;1&lt;/code&gt; for true and a special version of the defined empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt; , which counts as a zero but is exempt from warnings about improper numeric conversions, just as &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; is.</source>
          <target state="translated">返回true或false的Perl运算符通常返回可以安全地用作数字的值。例如，本节中的关系运算符和下一个运算符中的相等运算符返回 &lt;code&gt;1&lt;/code&gt; 表示true，并且返回已定义的空字符串 &lt;code&gt;&quot;&quot;&lt;/code&gt; 的特殊版本，该字符串算作零，但可以免除有关不正确数字转换的警告，如 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="677a0f4b34098e3ab8a940f648ce50dea2fe1b35" translate="yes" xml:space="preserve">
          <source>Perl operators that return true or false generally return values that can be safely used as numbers. For example, the relational operators in this section and the equality operators in the next one return &lt;code&gt;1&lt;/code&gt; for true and a special version of the defined empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt;, which counts as a zero but is exempt from warnings about improper numeric conversions, just as &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93117613e1464552c05f74263a894f716b02c8a7" translate="yes" xml:space="preserve">
          <source>Perl packages may be nested inside other package names, so we can have package names containing &lt;code&gt;::&lt;/code&gt; . But if we used that package name directly as a filename it would make for unwieldy or impossible filenames on some systems. Therefore, if a module's name is, say, &lt;code&gt;Text::Soundex&lt;/code&gt; , then its definition is actually found in the library file</source>
          <target state="translated">Perl软件包可能嵌套在其他软件包名称中，因此我们可以使用包含 &lt;code&gt;::&lt;/code&gt; 的软件包名称。但是，如果我们直接将该软件包名称用作文件名，则在某些系统上会使文件名变得笨拙或不可能。因此，如果模块的名称为 &lt;code&gt;Text::Soundex&lt;/code&gt; ，则实际上在库文件中可以找到其定义。</target>
        </trans-unit>
        <trans-unit id="216db03ab75c4e916969b56dae5407299d192ab7" translate="yes" xml:space="preserve">
          <source>Perl packages may be nested inside other package names, so we can have package names containing &lt;code&gt;::&lt;/code&gt;. But if we used that package name directly as a filename it would make for unwieldy or impossible filenames on some systems. Therefore, if a module's name is, say, &lt;code&gt;Text::Soundex&lt;/code&gt;, then its definition is actually found in the library file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d7fb295d5657e201671476cb88a17b37a54746" translate="yes" xml:space="preserve">
          <source>Perl pragma for deprecating the core version of a module</source>
          <target state="translated">用于废弃模块核心版本的Perl pragma。</target>
        </trans-unit>
        <trans-unit id="b96fac04186779fda96ab3e9ac74bb9de167238d" translate="yes" xml:space="preserve">
          <source>Perl pragma for deprecating the inclusion of a module in core</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ff2d9baf63466a443978236f7b7cb1cc8bd8db5" translate="yes" xml:space="preserve">
          <source>Perl prefers to &lt;code&gt;dup&lt;/code&gt; the new low-level descriptor to the descriptor used by the existing PerlIO. This may become the behaviour of this function in the future.</source>
          <target state="translated">Perl的喜欢 &lt;code&gt;dup&lt;/code&gt; 新的低级别的描述符由现有的PerlIO的使用的描述符。将来这可能成为此功能的行为。</target>
        </trans-unit>
        <trans-unit id="c2ad17b9a58ab83af39d92dc2a0f734f0896297e" translate="yes" xml:space="preserve">
          <source>Perl programs are just plain text, so any editor will do.</source>
          <target state="translated">Perl程序只是纯文本,所以任何编辑器都可以。</target>
        </trans-unit>
        <trans-unit id="14cf61d2a257794aa1f24ba3ebb61b26c9fd6acc" translate="yes" xml:space="preserve">
          <source>Perl promises, that if we ever add regular expression pattern metacharacters to the dozen already defined (&lt;code&gt;\ | ( ) [ { ^ $ * + ? .&lt;/code&gt; ), that we will only use ones that have the Pattern_Syntax property. Perl also promises, that if we ever add characters that are considered to be white space in regular expressions (currently mostly affected by &lt;code&gt;/x&lt;/code&gt;), they will all have the Pattern_White_Space property.</source>
          <target state="translated">Perl承诺，如果我们将正则表达式模式元字符添加到已经定义的十二个（ &lt;code&gt;\ | ( ) [ { ^ $ * + ? .&lt;/code&gt; ）中，我们将仅使用具有Pattern_Syntax属性的字符。 Perl还承诺，如果我们在正则表达式中添加被视为空白的字符（当前主要受 &lt;code&gt;/x&lt;/code&gt; 影响），它们都将具有Pattern_White_Space属性。</target>
        </trans-unit>
        <trans-unit id="327076e1125cbcba12ce50958edba776f9d04697" translate="yes" xml:space="preserve">
          <source>Perl promises, that if we ever add regular expression pattern metacharacters to the dozen already defined (&lt;code&gt;\ | ( ) [ { ^ $ * + ? .&lt;/code&gt;), that we will only use ones that have the Pattern_Syntax property. Perl also promises, that if we ever add characters that are considered to be white space in regular expressions (currently mostly affected by &lt;code&gt;/x&lt;/code&gt;), they will all have the Pattern_White_Space property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b6495ec04782f446ea386cb264b80a6975aeb6" translate="yes" xml:space="preserve">
          <source>Perl provides a centralized management of these resources:</source>
          <target state="translated">Perl对这些资源进行了集中管理。</target>
        </trans-unit>
        <trans-unit id="d5560f27b86924c423060a2b1fc2c1981aafcb97" translate="yes" xml:space="preserve">
          <source>Perl provides a fork() keyword that corresponds to the Unix system call of the same name. On most Unix-like platforms where the fork() system call is available, Perl's fork() simply calls it.</source>
          <target state="translated">Perl提供了一个fork()关键字,对应于同名的Unix系统调用。在大多数类似Unix的平台上,只要有fork()系统调用,Perl的fork()就会简单地调用它。</target>
        </trans-unit>
        <trans-unit id="de3af496d08feb146e6538a70938f9e1c88a9d41" translate="yes" xml:space="preserve">
          <source>Perl provides a mechanism for alternative namespaces to protect packages from stomping on each other's variables. In fact, there's really no such thing as a global variable in Perl. The package statement declares the compilation unit as being in the given namespace. The scope of the package declaration is from the declaration itself through the end of the enclosing block, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or file, whichever comes first (the same scope as the my() and local() operators). Unqualified dynamic identifiers will be in this namespace, except for those few identifiers that if unqualified, default to the main package instead of the current one as described below. A package statement affects only dynamic variables--including those you've used local() on--but</source>
          <target state="translated">Perl为替代名称空间提供了一种机制，以保护程序包避免踩踏彼此的变量。实际上，Perl中确实没有全局变量之类的东西。 package语句将编译单元声明为位于给定的名称空间中。程序包声明的范围是从声明本身到封闭的块， &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 或文件的末尾，以先到者为准（与my（）和local（）运算符相同）。不合格的动态标识符将在此命名空间中，除了少数不合格的标识符之外，这些标识符默认为主包而不是当前的主包，如下所述。 package语句仅影响动态变量-包括您使用过local（）的那些变量-但</target>
        </trans-unit>
        <trans-unit id="73112f265f6b41c74dc1c4f6ba58a9aa61493def" translate="yes" xml:space="preserve">
          <source>Perl provides a number of mechanisms to coordinate the interactions between themselves and their data, to avoid race conditions and the like. Some of these are designed to resemble the common techniques used in thread libraries such as &lt;code&gt;pthreads&lt;/code&gt; ; others are Perl-specific. Often, the standard techniques are clumsy and difficult to get right (such as condition waits). Where possible, it is usually easier to use Perlish techniques such as queues, which remove some of the hard work involved.</source>
          <target state="translated">Perl提供了许多机制来协调自身与其数据之间的交互，从而避免出现竞争情况等。其中一些设计类似于线程库中使用的通用技术，如 &lt;code&gt;pthreads&lt;/code&gt; ;其他是Perl特定的。通常，标准技术笨拙且难以正确处理（例如条件等待）。在可能的情况下，通常更容易使用Perlish技术（例如队列），从而消除了一些艰苦的工作。</target>
        </trans-unit>
        <trans-unit id="2033b0d4b88c366862ed2f9bb35924fa40e4eea4" translate="yes" xml:space="preserve">
          <source>Perl provides a number of mechanisms to coordinate the interactions between themselves and their data, to avoid race conditions and the like. Some of these are designed to resemble the common techniques used in thread libraries such as &lt;code&gt;pthreads&lt;/code&gt;; others are Perl-specific. Often, the standard techniques are clumsy and difficult to get right (such as condition waits). Where possible, it is usually easier to use Perlish techniques such as queues, which remove some of the hard work involved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e7e1ce7a021b749d35bdf6f3b510a2bf8dd56c" translate="yes" xml:space="preserve">
          <source>Perl provides a reasonably safe way to open a file or pipe from a setuid or setgid program: just create a child process with reduced privilege who does the dirty work for you. First, fork a child using the special &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; syntax that connects the parent and child by a pipe. Now the child resets its ID set and any other per-process attributes, like environment variables, umasks, current working directories, back to the originals or known safe values. Then the child process, which no longer has any special permissions, does the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or other system call. Finally, the child passes the data it managed to access back to the parent. Because the file or pipe was opened in the child while running under less privilege than the parent, it's not apt to be tricked into doing something it shouldn't.</source>
          <target state="translated">Perl提供了一种从setuid或setgid程序中打开文件或管道的相当安全的方法：只需以降低的特权创建一个子进程即可为您执行肮脏的工作。首先，使用特殊的 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 语法（通过管道连接父级和子级）派生一个子级。现在，孩子将其ID集和所有其他按进程属性（如环境变量，umask，当前工作目录）重置为原始值或已知的安全值。然后，不再具有任何特殊权限的子进程将执行 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 或其他系统调用。最后，孩子将它设法访问的数据传回给父母。由于文件或管道是在子级中打开的，而其运行权限却比父级低，因此不容易被欺骗去做它不应该做的事情。</target>
        </trans-unit>
        <trans-unit id="6e7a421d4f41bbc8f45292eb6fb0c23e47fd47d6" translate="yes" xml:space="preserve">
          <source>Perl provides a reasonably safe way to open a file or pipe from a setuid or setgid program: just create a child process with reduced privilege who does the dirty work for you. First, fork a child using the special &lt;code&gt;open&lt;/code&gt; syntax that connects the parent and child by a pipe. Now the child resets its ID set and any other per-process attributes, like environment variables, umasks, current working directories, back to the originals or known safe values. Then the child process, which no longer has any special permissions, does the &lt;code&gt;open&lt;/code&gt; or other system call. Finally, the child passes the data it managed to access back to the parent. Because the file or pipe was opened in the child while running under less privilege than the parent, it's not apt to be tricked into doing something it shouldn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b6956704a1caccc5f1a829b2f6df16370a9f29" translate="yes" xml:space="preserve">
          <source>Perl provides many macros to assist in accessing the Perl stack. Wherever possible, these macros should always be used when interfacing to Perl internals. We hope this should make the code less vulnerable to any changes made to Perl in the future.</source>
          <target state="translated">Perl 提供了许多宏来协助访问 Perl 堆栈。在与Perl内部接口时,应尽可能地使用这些宏。我们希望这样做可以使代码在将来Perl的任何改动中不那么脆弱。</target>
        </trans-unit>
        <trans-unit id="8d83d3e4ff54e649960458ab09222a8186178865" translate="yes" xml:space="preserve">
          <source>Perl provides the function &lt;code&gt;sv_chop&lt;/code&gt; to efficiently remove characters from the beginning of a string; you give it an SV and a pointer to somewhere inside the PV, and it discards everything before the pointer. The efficiency comes by means of a little hack: instead of actually removing the characters, &lt;code&gt;sv_chop&lt;/code&gt; sets the flag &lt;code&gt;OOK&lt;/code&gt; (offset OK) to signal to other functions that the offset hack is in effect, and it moves the PV pointer (called &lt;code&gt;SvPVX&lt;/code&gt; ) forward by the number of bytes chopped off, and adjusts &lt;code&gt;SvCUR&lt;/code&gt; and &lt;code&gt;SvLEN&lt;/code&gt; accordingly. (A portion of the space between the old and new PV pointers is used to store the count of chopped bytes.)</source>
          <target state="translated">Perl提供了 &lt;code&gt;sv_chop&lt;/code&gt; 函数来有效地删除字符串开头的字符。您给它提供了SV和指向PV内部某个位置的指针，并且它丢弃了指针之前的所有内容。效率是通过一点技巧来实现的： &lt;code&gt;sv_chop&lt;/code&gt; 不会实际删除字符，而是设置标志 &lt;code&gt;OOK&lt;/code&gt; （偏移OK）以向其他函数发信号表示偏移技巧已生效，并且向前移动PV指针（称为 &lt;code&gt;SvPVX&lt;/code&gt; ）通过切掉的字节数，并相应地调整 &lt;code&gt;SvCUR&lt;/code&gt; 和 &lt;code&gt;SvLEN&lt;/code&gt; 。 （新旧PV指针之间的一部分空间用于存储切碎字节的计数。）</target>
        </trans-unit>
        <trans-unit id="6f5d51550851e99636a22add4af85faee83cebcf" translate="yes" xml:space="preserve">
          <source>Perl provides the function &lt;code&gt;sv_chop&lt;/code&gt; to efficiently remove characters from the beginning of a string; you give it an SV and a pointer to somewhere inside the PV, and it discards everything before the pointer. The efficiency comes by means of a little hack: instead of actually removing the characters, &lt;code&gt;sv_chop&lt;/code&gt; sets the flag &lt;code&gt;OOK&lt;/code&gt; (offset OK) to signal to other functions that the offset hack is in effect, and it moves the PV pointer (called &lt;code&gt;SvPVX&lt;/code&gt;) forward by the number of bytes chopped off, and adjusts &lt;code&gt;SvCUR&lt;/code&gt; and &lt;code&gt;SvLEN&lt;/code&gt; accordingly. (A portion of the space between the old and new PV pointers is used to store the count of chopped bytes.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b8c268aa39a037e84e8a60b81c199fef5923af6" translate="yes" xml:space="preserve">
          <source>Perl provides two API functions to evaluate pieces of Perl code. These are &lt;a href=&quot;perlapi#eval_sv&quot;&gt;&quot;eval_sv&quot; in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#eval_pv&quot;&gt;&quot;eval_pv&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9513d1ec6023b878e1b94840b432efff780b52df" translate="yes" xml:space="preserve">
          <source>Perl provides two API functions to evaluate pieces of Perl code. These are &lt;a href=&quot;perlapi#eval_sv&quot;&gt;eval_sv in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#eval_pv&quot;&gt;eval_pv in perlapi&lt;/a&gt;.</source>
          <target state="translated">Perl提供了两个API函数来评估Perl代码。这些是&lt;a href=&quot;perlapi#eval_sv&quot;&gt;perlapi中的eval_sv&lt;/a&gt;和&lt;a href=&quot;perlapi#eval_pv&quot;&gt;perlapi中的eval_pv&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ffb39ca049ef57e14f57d4751c1d1ac0f78a02d5" translate="yes" xml:space="preserve">
          <source>Perl recognizes the POSIX character classes &lt;code&gt;[=class=]&lt;/code&gt; and &lt;code&gt;[.class.]&lt;/code&gt;, but does not (yet?) support them. Any attempt to use either construct raises an exception.</source>
          <target state="translated">Perl可以识别POSIX字符类 &lt;code&gt;[=class=]&lt;/code&gt; 和 &lt;code&gt;[.class.]&lt;/code&gt; ，但还不支持（但？）。任何使用这两种构造的尝试都会引发异常。</target>
        </trans-unit>
        <trans-unit id="07f5219960a6f7bb8d18294a65d8b9d67281a7a2" translate="yes" xml:space="preserve">
          <source>Perl recognizes the following POSIX character classes:</source>
          <target state="translated">Perl可以识别以下POSIX字符类。</target>
        </trans-unit>
        <trans-unit id="d60612137eda4aa3ff39ca1a5e535cbfedf6b435" translate="yes" xml:space="preserve">
          <source>Perl regexps also support backreferences, lookaheads, and all kinds of other complex details. Read all about them in &lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt;, &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;, and &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">Perl正则表达式还支持反向引用，超前查找和所有其他复杂的细节。在&lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt;，&lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;和&lt;a href=&quot;perlre&quot;&gt;perlre中&lt;/a&gt;阅读有关它们的所有信息。</target>
        </trans-unit>
        <trans-unit id="aa3e77c17de568fb7fabddc21617e1e18fce47ab" translate="yes" xml:space="preserve">
          <source>Perl regexps can handle more than just the standard ASCII character set. Perl supports</source>
          <target state="translated">Perl的regexps可以处理的不仅仅是标准的ASCII字符集。Perl支持</target>
        </trans-unit>
        <trans-unit id="d440475b129d32904159fb94e727dbef0d4e25d9" translate="yes" xml:space="preserve">
          <source>Perl regular expressions have a large range of character classes. Some of the character classes are written as a backslash sequence. We will briefly discuss those here; full details of character classes can be found in &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">Perl正则表达式具有多种字符类。一些字符类被写为反斜杠序列。我们将在这里简要讨论这些内容；字符类的完整详细信息可以在&lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="8ae626456b6ab696d8a1f8c512b2605f948687bc" translate="yes" xml:space="preserve">
          <source>Perl relies on the underlying system for the implementation of &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt;; on some systems, the generated numbers are not random enough (especially on Windows : see &lt;a href=&quot;http://www.perlmonks.org/?node_id=803632&quot;&gt;http://www.perlmonks.org/?node_id=803632&lt;/a&gt;). Several CPAN modules in the &lt;code&gt;Math&lt;/code&gt; namespace implement better pseudorandom generators; see for example &lt;a href=&quot;http://search.cpan.org/perldoc/Math::Random::MT&quot;&gt;Math::Random::MT&lt;/a&gt; (&quot;Mersenne Twister&quot;, fast), or &lt;a href=&quot;http://search.cpan.org/perldoc/Math::TrulyRandom&quot;&gt;Math::TrulyRandom&lt;/a&gt; (uses the imperfections in the system's timer to generate random numbers, which is rather slow). More algorithms for random numbers are described in &quot;Numerical Recipes in C&quot; at &lt;a href=&quot;http://www.nr.com/&quot;&gt;http://www.nr.com/&lt;/a&gt;</source>
          <target state="translated">Perl依靠底层系统来实现 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; ；在某些系统上，生成的数字不够随机（尤其是在Windows上：请参见&lt;a href=&quot;http://www.perlmonks.org/?node_id=803632&quot;&gt;http://www.perlmonks.org/?node_id=803632&lt;/a&gt;）。 &lt;code&gt;Math&lt;/code&gt; 名称空间中的几个CPAN模块实现了更好的伪随机数生成器。参见例如&lt;a href=&quot;http://search.cpan.org/perldoc/Math::Random::MT&quot;&gt;Math :: Random :: MT&lt;/a&gt;（&amp;ldquo; Merenne Twister&amp;rdquo;，快速）或&lt;a href=&quot;http://search.cpan.org/perldoc/Math::TrulyRandom&quot;&gt;Math :: TrulyRandom&lt;/a&gt;（使用系统计时器中的缺陷生成随机数，这相当慢）。有关随机数的更多算法，&lt;a href=&quot;http://www.nr.com/&quot;&gt;请参见http://www.nr.com/上的&lt;/a&gt; &amp;ldquo; C的数字食谱&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="3f12ff9832e26034f1b71096dd8784c68818bdcd" translate="yes" xml:space="preserve">
          <source>Perl relies on the underlying system for the implementation of &lt;code&gt;rand&lt;/code&gt; and &lt;code&gt;srand&lt;/code&gt;; on some systems, the generated numbers are not random enough (especially on Windows : see &lt;a href=&quot;http://www.perlmonks.org/?node_id=803632&quot;&gt;http://www.perlmonks.org/?node_id=803632&lt;/a&gt;). Several CPAN modules in the &lt;code&gt;Math&lt;/code&gt; namespace implement better pseudorandom generators; see for example &lt;a href=&quot;Math::Random::MT&quot;&gt;Math::Random::MT&lt;/a&gt; (&quot;Mersenne Twister&quot;, fast), or &lt;a href=&quot;Math::TrulyRandom&quot;&gt;Math::TrulyRandom&lt;/a&gt; (uses the imperfections in the system's timer to generate random numbers, which is rather slow). More algorithms for random numbers are described in &quot;Numerical Recipes in C&quot; at &lt;a href=&quot;http://www.nr.com/&quot;&gt;http://www.nr.com/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8b101afd4e3699b22d8dd044a2afe59a2e5739" translate="yes" xml:space="preserve">
          <source>Perl requires braces following &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , etc.</source>
          <target state="translated">Perl要求在 &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; ， &lt;code&gt;foreach&lt;/code&gt; 等后面跟随大括号。</target>
        </trans-unit>
        <trans-unit id="da6e3123b7e4ffb6fc9eae18f7c7e43c09ee3028" translate="yes" xml:space="preserve">
          <source>Perl requires braces following &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;foreach&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baeb92759bd60617241bdfef388270964c6488e2" translate="yes" xml:space="preserve">
          <source>Perl requires semicolons to separate statements.</source>
          <target state="translated">Perl需要分号来分隔语句。</target>
        </trans-unit>
        <trans-unit id="e643a23b551f0082edc8c39f350e57fa7da27bfb" translate="yes" xml:space="preserve">
          <source>Perl resolves this dilemma by transparently calling a copy constructor before calling a method defined to implement a mutator (&lt;code&gt;--&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; , and so on.). In the above example, when Perl reaches the decrement statement, it makes a copy of the object data in &lt;code&gt;$a&lt;/code&gt; and assigns to &lt;code&gt;$a&lt;/code&gt; a reference to the copied data. Only then does it call &lt;code&gt;decr()&lt;/code&gt; , which alters the copied data, leaving &lt;code&gt;$b&lt;/code&gt; unchanged. Thus the object metaphor is preserved as far as possible, while mathemagical operations still work according to the arithmetic metaphor.</source>
          <target state="translated">Perl通过在调用定义为实现mutator的方法（ &lt;code&gt;--&lt;/code&gt; ， &lt;code&gt;+=&lt;/code&gt; 等）之前透明地调用复制构造函数来解决此难题。在上面的示例中，当Perl到达减量语句时，它将在 &lt;code&gt;$a&lt;/code&gt; 复制对象数据，并向 &lt;code&gt;$a&lt;/code&gt; 分配对复制数据的引用。只有这样，它才会调用 &lt;code&gt;decr()&lt;/code&gt; ，这会更改复制的数据，而保持 &lt;code&gt;$b&lt;/code&gt; 不变。因此，尽可能地保留了对象隐喻，而数学运算仍根据算术隐喻起作用。</target>
        </trans-unit>
        <trans-unit id="1602dd24bebfca9ce4871cb5fb94135e37cae349" translate="yes" xml:space="preserve">
          <source>Perl resolves this dilemma by transparently calling a copy constructor before calling a method defined to implement a mutator (&lt;code&gt;--&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, and so on.). In the above example, when Perl reaches the decrement statement, it makes a copy of the object data in &lt;code&gt;$a&lt;/code&gt; and assigns to &lt;code&gt;$a&lt;/code&gt; a reference to the copied data. Only then does it call &lt;code&gt;decr()&lt;/code&gt;, which alters the copied data, leaving &lt;code&gt;$b&lt;/code&gt; unchanged. Thus the object metaphor is preserved as far as possible, while mathemagical operations still work according to the arithmetic metaphor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e718ff2371b8bf00697a05f6ee1339b450bff042" translate="yes" xml:space="preserve">
          <source>Perl runs &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement at run-time. Once Perl loads, compiles, and runs the file, it doesn't do anything else. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement is the same as a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; run at compile-time, but Perl also calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method for the loaded package. These two are the same:</source>
          <target state="translated">Perl 在运行时运行 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 语句。一旦Perl加载，编译并运行文件，它就不会做任何其他事情。在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 的语句是一样的一个 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 在编译时运行，但Perl中也称 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 的加载封装的方法。这两个是相同的：</target>
        </trans-unit>
        <trans-unit id="98f089278b6995b15f2d41746ee27d2688f96f52" translate="yes" xml:space="preserve">
          <source>Perl runs &lt;code&gt;require&lt;/code&gt; statement at run-time. Once Perl loads, compiles, and runs the file, it doesn't do anything else. The &lt;code&gt;use&lt;/code&gt; statement is the same as a &lt;code&gt;require&lt;/code&gt; run at compile-time, but Perl also calls the &lt;code&gt;import&lt;/code&gt; method for the loaded package. These two are the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c228222cbce8f7e3a32ff65352e2b7ebaf362f" translate="yes" xml:space="preserve">
          <source>Perl runs on e-mail; there is no doubt about it. The Camel book was originally written mostly over e-mail and today Perl's development is co-ordinated through mailing lists. The largest repository of Perl mailing lists is located at &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt;.</source>
          <target state="translated">Perl通过电子邮件运行；这个毋庸置疑。骆驼书最初主要是通过电子邮件撰写的，而如今，Perl的开发是通过邮件列表来协调的。Perl邮件列表的最大存储库位于&lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61dbd8b3aa941e2fad4e470525c952ecca2fe9ad" translate="yes" xml:space="preserve">
          <source>Perl runs on numerous operating systems. While most of them share much in common, they also have their own unique features.</source>
          <target state="translated">Perl可以运行在众多的操作系统上。虽然它们中的大多数有很多共同点,但它们也有自己独特的特点。</target>
        </trans-unit>
        <trans-unit id="421935f6afff0e32fa7e44f720a70058704e68f6" translate="yes" xml:space="preserve">
          <source>Perl runs under Unix Systems Services or USS.</source>
          <target state="translated">Perl在Unix系统服务或USS下运行。</target>
        </trans-unit>
        <trans-unit id="e81d373d15ca40f4e59a6d6a3f7cafb56ab9ed4a" translate="yes" xml:space="preserve">
          <source>Perl scripts on UNIX use the &quot;#!&quot; (a.k.a &quot;shebang&quot;) line to indicate to the OS that it should execute the file using perl. Windows has no comparable means to indicate arbitrary files are executables.</source>
          <target state="translated">UNIX上的Perl脚本使用 &quot;#!&quot;(也就是 &quot;shebang&quot;)行来指示操作系统应该使用perl执行文件。(又名 &quot;shebang&quot;)行来向操作系统表明它应该使用perl执行文件。Windows没有类似的方法来表明任意文件是可执行文件。</target>
        </trans-unit>
        <trans-unit id="c4939ec259a60d684db202bce3bcf1de4f358448" translate="yes" xml:space="preserve">
          <source>Perl seems to allow out-of-range values (greater than 0x10FFFF). By default, out-of-range values are replaced with &lt;code&gt;U+FFFD&lt;/code&gt; (REPLACEMENT CHARACTER) when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt;= 22, or ignored when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;lt;= 20.</source>
          <target state="translated">Perl似乎允许超出范围的值（大于0x10FFFF）。默认情况下，当 &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; = 22 时，超出范围的值将替换为 &lt;code&gt;U+FFFD&lt;/code&gt; （REPLACEMENT CHARACTER），而当 &lt;code&gt;UCA_Version&lt;/code&gt; &amp;lt;= 20 时，则将其忽略。</target>
        </trans-unit>
        <trans-unit id="f744319952a7a0f61ea238f46c893e99d13a8174" translate="yes" xml:space="preserve">
          <source>Perl should now build using the win32/Makefile. You will need to edit that file to set</source>
          <target state="translated">Perl 现在应该使用 win32/Makefile 来构建。你需要编辑该文件,将</target>
        </trans-unit>
        <trans-unit id="a14edbe542c4c995c5b37c95f6789009c27399cc" translate="yes" xml:space="preserve">
          <source>Perl should now build using the win32/Makefile. You will need to edit that file to set CCTYPE to one of MSVC90-MSVC142 first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb621d78e2af41af5785030c0b682152fd53b938" translate="yes" xml:space="preserve">
          <source>Perl should now build using the win32/Makefile. You will need to edit that file to set CCTYPE to one of MSVC90FREE-MSVC120FREE first.</source>
          <target state="translated">现在Perl应该使用win32/Makefile来构建。你需要先编辑该文件,将 CCTYPE 设置为 MSVC90FREE-MSVC120FREE 中的一个。</target>
        </trans-unit>
        <trans-unit id="0ddc1cc89c294f8f7ab11f0687f3217bbc182d09" translate="yes" xml:space="preserve">
          <source>Perl should remain one language, rather than forking into a byte-oriented Perl and a character-oriented Perl.</source>
          <target state="translated">Perl应该保持一种语言,而不是分叉成面向字节的Perl和面向字符的Perl。</target>
        </trans-unit>
        <trans-unit id="c5c49b8b94391dce923175d25bc4e1e360818232" translate="yes" xml:space="preserve">
          <source>Perl source plays by ANSI C89 rules: no C99 (or C++) extensions. In some cases we have to take pre-ANSI requirements into consideration. You don't care about some particular platform having broken Perl? I hear there is still a strong demand for J2EE programmers.</source>
          <target state="translated">Perl源代码遵循ANSI C89规则:没有C99(或C++)扩展。在某些情况下,我们必须考虑到ANSI之前的要求。你不关心某些特定平台已经破坏了Perl?听说J2EE程序员的需求量还是很大的。</target>
        </trans-unit>
        <trans-unit id="50695da7bf648a9c3f976331e85b8f6be17c044c" translate="yes" xml:space="preserve">
          <source>Perl source plays by ANSI C89 rules: no C99 (or C++) extensions. You don't care about some particular platform having broken Perl? I hear there is still a strong demand for J2EE programmers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912bb016153409bf0daae81d17c059280f97296b" translate="yes" xml:space="preserve">
          <source>Perl stack pointer), and in the handling of data on the stack when returning from an XSUB. In CODE: sections SP preserves the value which was on entry to the XSUB: SP is on the function pointer (which follows the last parameter). In PPCODE: sections SP is moved backward to the beginning of the parameter list, which allows &lt;code&gt;PUSH*()&lt;/code&gt; macros to place output values in the place Perl expects them to be when the XSUB returns back to Perl.</source>
          <target state="translated">Perl堆栈指针），以及在处理从XSUB返回的堆栈上的数据时。在CODE中：SP保留了XSUB条目上输入的值：SP在函数指针上（位于最后一个参数之后）。在PPCODE中：SP部分向后移到参数列表的开头，这允许 &lt;code&gt;PUSH*()&lt;/code&gt; 宏将输出值放置在XSUB返回Perl时Perl期望它们的位置。</target>
        </trans-unit>
        <trans-unit id="c5c35727bb235feb64e08f5a4e4d865a3344d69d" translate="yes" xml:space="preserve">
          <source>Perl starts scripts which begin with cookies &lt;code&gt;extproc&lt;/code&gt; or &lt;code&gt;#!&lt;/code&gt; directly, without an intervention of shell. Perl uses the same algorithm to find the executable as</source>
          <target state="translated">Perl启动以cookie &lt;code&gt;extproc&lt;/code&gt; 或 &lt;code&gt;#!&lt;/code&gt; 开头的脚本。直接进行，无需shell干预。Perl使用相同的算法查找可执行文件，如下所示：</target>
        </trans-unit>
        <trans-unit id="311066088c9b05b3123661ea7b3305044bcd0edf" translate="yes" xml:space="preserve">
          <source>Perl statements end in a semi-colon:</source>
          <target state="translated">Perl语句以分号结束。</target>
        </trans-unit>
        <trans-unit id="085142f041ce2e9d800b457019222a09cb16a58b" translate="yes" xml:space="preserve">
          <source>Perl strings are NOT the same as C strings: They may contain &lt;code&gt;NUL&lt;/code&gt; characters, whereas a C string is terminated by the first &lt;code&gt;NUL&lt;/code&gt;. That is why Perl API functions that deal with strings generally take a pointer to the first byte and either a length or a pointer to the byte just beyond the final one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3110ac0fdedcb6602950b25f9e6691154e84e0e" translate="yes" xml:space="preserve">
          <source>Perl supports Unicode strings as of version 5.6. Such strings may contain wide characters, namely, characters whose ordinal values are greater than 255. This can cause problems for digest algorithms such as SHA that are specified to operate on sequences of bytes.</source>
          <target state="translated">Perl从5.6版本开始支持Unicode字符串。这种字符串可能包含宽字符,即序数值大于255的字符。这可能会给诸如SHA等指定对字节序列进行操作的摘要算法带来问题。</target>
        </trans-unit>
        <trans-unit id="a81cbe4ac67faced842394ca9c16af6e77feb312" translate="yes" xml:space="preserve">
          <source>Perl supports a type of threads called interpreter threads (ithreads). These threads can be used explicitly and implicitly.</source>
          <target state="translated">Perl支持一种叫做解释器线程(ithreads)的线程。这些线程可以显式和隐式使用。</target>
        </trans-unit>
        <trans-unit id="b3ddd3f5c1d03839d509e6149edea808fc6cb5cb" translate="yes" xml:space="preserve">
          <source>Perl supports a very limited kind of compile-time argument checking using function prototyping. This can be declared in either the PROTO section or with a &lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;prototype attribute&lt;/a&gt;. If you declare either of</source>
          <target state="translated">Perl使用函数原型支持非常有限的一种编译时参数检查。可以在PROTO部分或用&lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;prototype属性声明&lt;/a&gt;。如果您声明</target>
        </trans-unit>
        <trans-unit id="4e581f21aad5ef67a96d247b183e3193eac70dc7" translate="yes" xml:space="preserve">
          <source>Perl supports another method invocation syntax called &quot;indirect object&quot; notation. This syntax is called &quot;indirect&quot; because the method comes before the object it is being invoked on.</source>
          <target state="translated">Perl 支持另一种方法调用语法,叫做 &quot;间接对象 &quot;符号。这种语法之所以被称为 &quot;间接&quot;,是因为方法在它被调用的对象之前。</target>
        </trans-unit>
        <trans-unit id="455d7ce007e3563f3b515c14c6a68c715a128b3e" translate="yes" xml:space="preserve">
          <source>Perl supports both pre-5.6 strings of eight-bit native bytes, and strings of Unicode characters. The general principle is that Perl tries to keep its data as eight-bit bytes for as long as possible, but as soon as Unicodeness cannot be avoided, the data is transparently upgraded to Unicode. Prior to Perl v5.14.0, the upgrade was not completely transparent (see &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;), and for backwards compatibility, full transparency is not gained unless &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;) or &lt;code&gt;use 5.012&lt;/code&gt; (or higher) is selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="265dfd10b5f2d39d276f9f524b9c6e80cdea3f6c" translate="yes" xml:space="preserve">
          <source>Perl supports both pre-5.6 strings of eight-bit native bytes, and strings of Unicode characters. The general principle is that Perl tries to keep its data as eight-bit bytes for as long as possible, but as soon as Unicodeness cannot be avoided, the data is transparently upgraded to Unicode. Prior to Perl v5.14.0, the upgrade was not completely transparent (see &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt;), and for backwards compatibility, full transparency is not gained unless &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'unicode_strings'&lt;/code&gt; (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;) or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; (or higher) is selected.</source>
          <target state="translated">Perl支持5.6之前的8位本机字节字符串和Unicode字符字符串。一般原则是Perl尝试将其数据尽可能长时间地保持为八位字节，但是一旦无法避免Unicodeness，则将数据透明地升级为Unicode。在Perl v5.14.0之前，升级不是完全透明的（请参见&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicode中的Unicode错误&lt;/a&gt;），并且为了向后兼容，除非 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; （请参见&lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;）或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; （或更高版本），否则无法获得完全透明的功能。已选择。</target>
        </trans-unit>
        <trans-unit id="e2d84ca8811712997a8e9f3ad7161c9e75151f4e" translate="yes" xml:space="preserve">
          <source>Perl supports cross-compiling to QNX NTO through the Native Development Kit (NDK) for the Blackberry 10. This means that you can cross-compile for both ARM and x86 versions of the platform.</source>
          <target state="translated">Perl 支持通过黑莓 10 的本地开发工具包(NDK)向 QNX NTO 交叉编译。这意味着您可以对 ARM 和 x86 版本的平台进行交叉编译。</target>
        </trans-unit>
        <trans-unit id="61c6178993abcdebf49b240f9190abe5238c4bb9" translate="yes" xml:space="preserve">
          <source>Perl supports several other ways to call methods besides the &lt;code&gt;$object-&amp;gt;method()&lt;/code&gt; usage we've seen so far.</source>
          <target state="translated">除了到目前为止我们已经看到的 &lt;code&gt;$object-&amp;gt;method()&lt;/code&gt; 用法之外，Perl还支持其他几种方法来调用方法。</target>
        </trans-unit>
        <trans-unit id="51aafa2b4885796ac3ebbd5ae9ad8631e2f17f44" translate="yes" xml:space="preserve">
          <source>Perl supports single-byte locales that are supersets of ASCII, such as the ISO 8859 ones, and one multi-byte-type locale, UTF-8 ones, described in the next paragraph. Perl doesn't support any other multi-byte locales, such as the ones for East Asian languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b921bede497b8f7b569d6ab7232a231253948127" translate="yes" xml:space="preserve">
          <source>Perl tends to add NULs, as an insurance policy, after the end of strings in SV's, so it is likely that using this macro will prevent inadvertent reading beyond the end of the input buffer, even if it is malformed UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39eb141cb70a235796d1c9a3b86085a1c03895dd" translate="yes" xml:space="preserve">
          <source>Perl termcap interface</source>
          <target state="translated">Perl术语帽接口</target>
        </trans-unit>
        <trans-unit id="29dca9ab8b1d3b8377101aae3e9cbe3e4fbc8b16" translate="yes" xml:space="preserve">
          <source>Perl threading is going to work only in Tru64 4.0 and newer releases, older operating releases like 3.2 aren't probably going to work properly with threads.</source>
          <target state="translated">Perl线程只在Tru64 4.0和更新的版本中工作,旧的操作版本如3.2可能无法正常使用线程。</target>
        </trans-unit>
        <trans-unit id="711f6c74d0066ee853703c933b2128a03d5d8197" translate="yes" xml:space="preserve">
          <source>Perl threads mailing list: &lt;a href=&quot;http://lists.perl.org/list/ithreads.html&quot;&gt;http://lists.perl.org/list/ithreads.html&lt;/a&gt;</source>
          <target state="translated">Perl线程邮件列表：&lt;a href=&quot;http://lists.perl.org/list/ithreads.html&quot;&gt;http&lt;/a&gt; : //lists.perl.org/list/ithreads.html</target>
        </trans-unit>
        <trans-unit id="cba34b4e3f85c4f737c5ed55db9967c713391cb7" translate="yes" xml:space="preserve">
          <source>Perl threads mailing list: &lt;a href=&quot;https://lists.perl.org/list/ithreads.html&quot;&gt;https://lists.perl.org/list/ithreads.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2559db124cb4f86fc6327b39cc58f5d846e3791" translate="yes" xml:space="preserve">
          <source>Perl tips, autodie</source>
          <target state="translated">Perl 技巧,autodie</target>
        </trans-unit>
        <trans-unit id="eaf5bf8a496158d3f80504dd4ad1d919275e7f1f" translate="yes" xml:space="preserve">
          <source>Perl tracks the dynamic scope by a data structure called the context stack, which is an array of &lt;code&gt;PERL_CONTEXT&lt;/code&gt; structures, and which is itself a big union for all the types of context. Whenever a new scope is entered (such as a block, a &lt;code&gt;for&lt;/code&gt; loop, or a subroutine call), a new context entry is pushed onto the stack. Similarly when leaving a block or returning from a subroutine call etc. a context is popped. Since the context stack represents the current dynamic scope, it can be searched. For example, &lt;code&gt;next LABEL&lt;/code&gt; searches back through the stack looking for a loop context that matches the label; &lt;code&gt;return&lt;/code&gt; pops contexts until it finds a sub or eval context or similar; &lt;code&gt;caller&lt;/code&gt; examines sub contexts on the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417a3338dad2fe5b9c31529d81335ca36b2c6619" translate="yes" xml:space="preserve">
          <source>Perl under AmigaOS lacks some features of perl under UNIX because of deficiencies in the UNIX-emulation, most notably:</source>
          <target state="translated">AmigaOS下的Perl由于UNIX-emulation的缺陷,缺乏UNIX下perl的一些功能,最主要的是。</target>
        </trans-unit>
        <trans-unit id="6de1733b62296869d712e2db6939eb5aa3e92225" translate="yes" xml:space="preserve">
          <source>Perl under DOS lacks some features of perl under UNIX because of deficiencies in the UNIX-emulation, most notably:</source>
          <target state="translated">DOS下的Perl由于UNIX-emulation的缺陷,缺乏UNIX下的perl的一些功能,最主要的是。</target>
        </trans-unit>
        <trans-unit id="fed7e4c0f6346d8e97d2349cf02d579f8a312bef" translate="yes" xml:space="preserve">
          <source>Perl under Mac OS Classic has not been supported since before Perl 5.10 (April 2004).</source>
          <target state="translated">自Perl 5.10(2004年4月)之前,Mac OS Classic下的Perl已经不受支持。</target>
        </trans-unit>
        <trans-unit id="fe29a7a8cb01db791e95920fcdb336a6f5bf1bcb" translate="yes" xml:space="preserve">
          <source>Perl uses &quot;full&quot; Unicode case mappings. This means that converting a single character to another case may result in a sequence of more than one character. For example, the uppercase of &lt;code&gt;&amp;szlig;&lt;/code&gt; (LATIN SMALL LETTER SHARP S) is the two character sequence &lt;code&gt;SS&lt;/code&gt;. This presents some complications The lowercase of all characters in the range 0..255 is a single character, and thus &lt;code&gt;&lt;a href=&quot;#toLOWER_L1&quot;&gt;&quot;toLOWER_L1&quot;&lt;/a&gt;&lt;/code&gt; is furnished. But, &lt;code&gt;toUPPER_L1&lt;/code&gt; can't exist, as it couldn't return a valid result for all legal inputs. Instead &lt;code&gt;&lt;a href=&quot;#toUPPER_uvchr&quot;&gt;&quot;toUPPER_uvchr&quot;&lt;/a&gt;&lt;/code&gt; has an API that does allow every possible legal result to be returned.) Likewise no other function that is crippled by not being able to give the correct results for the full range of possible inputs has been implemented here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c71cd98e9f081d421a495772db91702ad362132" translate="yes" xml:space="preserve">
          <source>Perl uses &lt;code&gt;\n&lt;/code&gt; to represent the &quot;logical&quot; newline, where what is logical may depend on the platform in use. In MacPerl, &lt;code&gt;\n&lt;/code&gt; always means &lt;code&gt;\015&lt;/code&gt; . On EBCDIC platforms, &lt;code&gt;\n&lt;/code&gt; could be &lt;code&gt;\025&lt;/code&gt; or &lt;code&gt;\045&lt;/code&gt; . In DOSish perls, &lt;code&gt;\n&lt;/code&gt; usually means &lt;code&gt;\012&lt;/code&gt; , but when accessing a file in &quot;text&quot; mode, perl uses the &lt;code&gt;:crlf&lt;/code&gt; layer that translates it to (or from) &lt;code&gt;\015\012&lt;/code&gt; , depending on whether you're reading or writing. Unix does the same thing on ttys in canonical mode. &lt;code&gt;\015\012&lt;/code&gt; is commonly referred to as CRLF.</source>
          <target state="translated">Perl使用 &lt;code&gt;\n&lt;/code&gt; 表示&amp;ldquo;逻辑&amp;rdquo;换行符，其中逻辑内容可能取决于所使用的平台。在MacPerl中， &lt;code&gt;\n&lt;/code&gt; 始终表示 &lt;code&gt;\015&lt;/code&gt; 。在EBCDIC平台上， &lt;code&gt;\n&lt;/code&gt; 可以是 &lt;code&gt;\025&lt;/code&gt; 或 &lt;code&gt;\045&lt;/code&gt; 。在DOSish perls中， &lt;code&gt;\n&lt;/code&gt; 通常表示 &lt;code&gt;\012&lt;/code&gt; ，但是在以&amp;ldquo;文本&amp;rdquo;模式访问文件时，perl使用 &lt;code&gt;:crlf&lt;/code&gt; 层将其转换为 &lt;code&gt;\015\012&lt;/code&gt; （或从中转换），具体取决于您是在读取还是写入。 Unix在规范模式下对ttys执行相同的操作。 &lt;code&gt;\015\012&lt;/code&gt; 通常称为CRLF。</target>
        </trans-unit>
        <trans-unit id="890fade91864c028d9bdef8ccb2172dd937cfe65" translate="yes" xml:space="preserve">
          <source>Perl uses &lt;code&gt;\n&lt;/code&gt; to represent the &quot;logical&quot; newline, where what is logical may depend on the platform in use. In MacPerl, &lt;code&gt;\n&lt;/code&gt; always means &lt;code&gt;\015&lt;/code&gt;. On EBCDIC platforms, &lt;code&gt;\n&lt;/code&gt; could be &lt;code&gt;\025&lt;/code&gt; or &lt;code&gt;\045&lt;/code&gt;. In DOSish perls, &lt;code&gt;\n&lt;/code&gt; usually means &lt;code&gt;\012&lt;/code&gt;, but when accessing a file in &quot;text&quot; mode, perl uses the &lt;code&gt;:crlf&lt;/code&gt; layer that translates it to (or from) &lt;code&gt;\015\012&lt;/code&gt;, depending on whether you're reading or writing. Unix does the same thing on ttys in canonical mode. &lt;code&gt;\015\012&lt;/code&gt; is commonly referred to as CRLF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef2489d6cf6b9a1519765ae5403d21cedb84ac6c" translate="yes" xml:space="preserve">
          <source>Perl uses UTF-8, internally, for most Unicode strings.</source>
          <target state="translated">Perl内部使用UTF-8来处理大多数Unicode字符串。</target>
        </trans-unit>
        <trans-unit id="a32f78ca0221220c37e8fdc6e6abb5de92126da7" translate="yes" xml:space="preserve">
          <source>Perl uses a reference count-driven garbage collection mechanism. SVs, AVs, or HVs (xV for short in the following) start their life with a reference count of 1. If the reference count of an xV ever drops to 0, then it will be destroyed and its memory made available for reuse.</source>
          <target state="translated">Perl使用了一个引用计数驱动的垃圾收集机制。SV、AV或HV(以下简称xV)以参考计数1开始它们的生命。 如果一个xV的参考计数降到0,那么它将被销毁,其内存将被重新使用。</target>
        </trans-unit>
        <trans-unit id="687866e44b38320b5ab4b8c364c0ba7321b47747" translate="yes" xml:space="preserve">
          <source>Perl uses a reference count-driven garbage collection mechanism. SVs, AVs, or HVs (xV for short in the following) start their life with a reference count of 1. If the reference count of an xV ever drops to 0, then it will be destroyed and its memory made available for reuse. At the most basic internal level, reference counts can be manipulated with the following macros:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa78748c6c02aeaa5f6c0aa0037a286831d36b3" translate="yes" xml:space="preserve">
          <source>Perl uses a simple signal handling model: the %SIG hash contains names or references of user-installed signal handlers. These handlers will be called with an argument which is the name of the signal that triggered it. A signal may be generated intentionally from a particular keyboard sequence like control-C or control-Z, sent to you from another process, or triggered automatically by the kernel when special events transpire, like a child process exiting, your own process running out of stack space, or hitting a process file-size limit.</source>
          <target state="translated">Perl 使用了一个简单的信号处理模型:%SIG 哈希包含用户安装的信号处理程序的名称或引用。这些处理程序将被调用,其参数是触发它的信号的名称。信号可能是由特定的键盘序列(如control-C或control-Z)有意产生的,也可能是由另一个进程发送给你的,或者是由内核在特殊事件发生时自动触发的,比如一个子进程退出,你自己的进程用完了堆栈空间,或者达到了进程文件大小的限制。</target>
        </trans-unit>
        <trans-unit id="697496faa8f310204a7d494fa53a2d354c2af264" translate="yes" xml:space="preserve">
          <source>Perl uses a special typedef IV which is a simple signed integer type that is guaranteed to be large enough to hold a pointer (as well as an integer). Additionally, there is the UV, which is simply an unsigned IV.</source>
          <target state="translated">Perl 使用了一个特殊的 typedef IV,它是一个简单的有符号的整数类型,保证足够大,可以容纳一个指针(以及一个整数)。此外,还有UV,它是一个简单的无符号IV。</target>
        </trans-unit>
        <trans-unit id="77447e8f55a3fbc6e220b03acaf3a045c7382163" translate="yes" xml:space="preserve">
          <source>Perl uses an internal type called a</source>
          <target state="translated">Perl使用一个内部类型,叫做</target>
        </trans-unit>
        <trans-unit id="dcd23c3b2c97cdf3da72f0a14a98128b56138f99" translate="yes" xml:space="preserve">
          <source>Perl uses its own malloc() under OS/2 - interpreters are usually malloc-bound for speed, but perl is not, since its malloc is lightning-fast. Perl-memory-usage-tuned benchmarks show that Perl's malloc is 5 times quicker than EMX one. I do not have convincing data about memory footprint, but a (pretty random) benchmark showed that Perl's one is 5% better.</source>
          <target state="translated">Perl在OS/2下使用了自己的malloc()--解释器通常是为了速度而被malloc绑定的,但perl不是,因为它的malloc是闪电般的快。Perl-内存使用调整基准显示,Perl的malloc比EMX的快5倍。我没有关于内存占用的令人信服的数据,但是一个(相当随机的)基准测试显示Perl的比EMX的快5%。</target>
        </trans-unit>
        <trans-unit id="1739ec403c50a46c8549e731f4fbc63bb7b3c7ac" translate="yes" xml:space="preserve">
          <source>Perl uses the hardwired-or-customized shell (see &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;&quot;&lt;code&gt;PERL_SH_DIR&lt;/code&gt;&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaeb3f63a0dee2460eba26dc00ff361a3a2b8977" translate="yes" xml:space="preserve">
          <source>Perl uses the hardwired-or-customized shell (see &lt;code&gt;&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Perl使用硬连线或自定义的外壳程序（请参阅 &lt;code&gt;&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7ae85ddbb739ce30e8dfb43f3f02245520739733" translate="yes" xml:space="preserve">
          <source>Perl uses the platform's C library collation functions &lt;code&gt;strcoll()&lt;/code&gt; and &lt;code&gt;strxfrm()&lt;/code&gt;. That means you get whatever they give. On some platforms, these functions work well on UTF-8 locales, giving a reasonable default collation for the code points that are important in that locale. (And if they aren't working well, the problem may only be that the locale definition is deficient, so can be fixed by using a better definition file. Unicode's definitions (see &lt;a href=&quot;#Freely-available-locale-definitions&quot;&gt;&quot;Freely available locale definitions&quot;&lt;/a&gt;) provide reasonable UTF-8 locale collation definitions.) Starting in Perl v5.26, Perl's use of these functions has been made more seamless. This may be sufficient for your needs. For more control, and to make sure strings containing any code point (not just the ones important in the locale) collate properly, the &lt;a href=&quot;Unicode::Collate&quot;&gt;Unicode::Collate&lt;/a&gt; module is suggested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56985ba618cbe018e4fc2adbd42f3a731d5d38f" translate="yes" xml:space="preserve">
          <source>Perl uses the same mechanism to produce &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc, so you also pay a price for each pattern that contains capturing parentheses. (To avoid this cost while retaining the grouping behaviour, use the extended regular expression &lt;code&gt;(?: ... )&lt;/code&gt; instead.) But if you never use &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$`&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; , then patterns</source>
          <target state="translated">Perl使用相同的机制产生 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等，因此您还为包含捕获括号的每个模式付出了代价。（为了避免在保留分组行为的同时产生此费用，请改用扩展的正则表达式 &lt;code&gt;(?: ... )&lt;/code&gt; 。）但是，如果您从不使用 &lt;code&gt;$&amp;amp;&lt;/code&gt; ， &lt;code&gt;$`&lt;/code&gt; 或 &lt;code&gt;$'&lt;/code&gt; ，则使用模式</target>
        </trans-unit>
        <trans-unit id="fd3d29794e28820446964a33391fd6afd6169a0d" translate="yes" xml:space="preserve">
          <source>Perl uses the same mechanism to produce &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729ae7be2e299ed898ba24317c3f470da4a89862" translate="yes" xml:space="preserve">
          <source>Perl v5.6.0 introduced lexical control over the handling of warnings by category. The &lt;code&gt;warnings&lt;/code&gt; pragma generally replaces the command line flag &lt;b&gt;-w&lt;/b&gt;. Documentation on the use of lexical warnings, once partly found in this document, is now found in the &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; documentation.</source>
          <target state="translated">Perl v5.6.0引入了按类别对警告处理的词法控制。该 &lt;code&gt;warnings&lt;/code&gt; 编译通常替换命令行标志&lt;b&gt;-w&lt;/b&gt;。一旦在本文档中找到了有关词汇警告的使用文档，即可在&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;文档中找到。</target>
        </trans-unit>
        <trans-unit id="ed16c3492238f59d6acc4b17eee61789dc827788" translate="yes" xml:space="preserve">
          <source>Perl v5.8 and better allow extended Unicode characters in strings. Such strings cannot be encoded directly, as the base64 encoding is only defined for single-byte characters. The solution is to use the Encode module to select the byte encoding you want. For example:</source>
          <target state="translated">Perl v5.8 和更高版本允许在字符串中使用扩展的 Unicode 字符。这种字符串不能直接编码,因为base64编码只定义了单字节字符。解决办法是使用 Encode 模块来选择你想要的字节编码。例如</target>
        </trans-unit>
        <trans-unit id="fac662f37a6502961fed43d288ed81deaf631ca7" translate="yes" xml:space="preserve">
          <source>Perl v5.8 and better allow extended Unicode characters in strings. Such strings cannot be encoded directly, as the quoted-printable encoding is only defined for single-byte characters. The solution is to use the Encode module to select the byte encoding you want. For example:</source>
          <target state="translated">Perl v5.8 和更高版本允许在字符串中使用扩展的 Unicode 字符。这样的字符串不能直接进行编码,因为引号可打印编码只定义了单字节字符。解决办法是使用Encode模块来选择你想要的字节编码。比如说</target>
        </trans-unit>
        <trans-unit id="ca07f22517f53e73e435cde9502974d6bc1e648d" translate="yes" xml:space="preserve">
          <source>Perl variable names may also be a sequence of digits or a single punctuation or control character (with the literal control character form deprecated). These names are all reserved for special uses by Perl; for example, the all-digits names are used to hold data captured by backreferences after a regular expression match. Perl has a special syntax for the single-control-character names: It understands &lt;code&gt;^X&lt;/code&gt; (caret &lt;code&gt;X&lt;/code&gt; ) to mean the control-&lt;code&gt;X&lt;/code&gt; character. For example, the notation &lt;code&gt;$^W&lt;/code&gt; (dollar-sign caret &lt;code&gt;W&lt;/code&gt; ) is the scalar variable whose name is the single character control-&lt;code&gt;W&lt;/code&gt; . This is better than typing a literal control-&lt;code&gt;W&lt;/code&gt; into your program.</source>
          <target state="translated">Perl变量名称也可以是数字序列或单个标点符号或控制字符（不建议使用文字控制字符形式）。这些名称都保留供Perl特殊使用；例如，全数字名称用于保存正则表达式匹配后由反向引用捕获的数据。 Perl对单控件字符名称有一种特殊的语法：它理解 &lt;code&gt;^X&lt;/code&gt; （插入符号 &lt;code&gt;X&lt;/code&gt; ）表示控件 &lt;code&gt;X&lt;/code&gt; 字符。例如，符号 &lt;code&gt;$^W&lt;/code&gt; （美元符号插入符号 &lt;code&gt;W&lt;/code&gt; ）是标量，其名称是单个字符控制- &lt;code&gt;W&lt;/code&gt; 。这比在程序中键入文字控件 &lt;code&gt;W&lt;/code&gt; 更好。</target>
        </trans-unit>
        <trans-unit id="939e5e17b46e5bec2f5d706c2937023945ced9ed" translate="yes" xml:space="preserve">
          <source>Perl variable names may also be a sequence of digits, a single punctuation character, or the two-character sequence: &lt;code&gt;^&lt;/code&gt; (caret or CIRCUMFLEX ACCENT) followed by any one of the characters &lt;code&gt;[][A-Z^_?\]&lt;/code&gt;. These names are all reserved for special uses by Perl; for example, the all-digits names are used to hold data captured by backreferences after a regular expression match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed35d8a6334fde91537a85bc31a0ea827797100e" translate="yes" xml:space="preserve">
          <source>Perl variable types</source>
          <target state="translated">Perl变量类型</target>
        </trans-unit>
        <trans-unit id="4045947434895b417a6c84aaed4fd5f8d36c865a" translate="yes" xml:space="preserve">
          <source>Perl variables</source>
          <target state="translated">Perl变量</target>
        </trans-unit>
        <trans-unit id="c155457483cd87781fd4429cf68e8cc70eecc55b" translate="yes" xml:space="preserve">
          <source>Perl versions before 5.8 had in its C source code signal handlers which would catch the signal and possibly run a Perl function that you had set in &lt;code&gt;%SIG&lt;/code&gt; . This violated the rules of signal handling at that level causing perl to dump core. Since version 5.8.0, perl looks at &lt;code&gt;%SIG&lt;/code&gt;&lt;b&gt;after&lt;/b&gt; the signal has been caught, rather than while it is being caught. Previous versions of this answer were incorrect.</source>
          <target state="translated">5.8之前的Perl版本在其C源代码信号处理程序中将捕获信号并可能运行您在 &lt;code&gt;%SIG&lt;/code&gt; 中设置的Perl函数。这违反了该级别的信号处理规则，导致perl转储内核。从5.8.0版开始，perl在捕获信号&lt;b&gt;之后&lt;/b&gt;而不是捕获信号时将查看 &lt;code&gt;%SIG&lt;/code&gt; 。此答案的先前版本不正确。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="89a169d5ba146feda33d133d78a5e42e73c7c504" translate="yes" xml:space="preserve">
          <source>Perl versions before 5.8 had in its C source code signal handlers which would catch the signal and possibly run a Perl function that you had set in &lt;code&gt;%SIG&lt;/code&gt;. This violated the rules of signal handling at that level causing perl to dump core. Since version 5.8.0, perl looks at &lt;code&gt;%SIG&lt;/code&gt;&lt;b&gt;after&lt;/b&gt; the signal has been caught, rather than while it is being caught. Previous versions of this answer were incorrect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eacc0652f9a68bdddb6fbf37bd76bc666b4e50b" translate="yes" xml:space="preserve">
          <source>Perl waits for the subprocess to complete before continuing execution in the current process. As described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, the return value of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; is a fake &quot;status&quot; which follows POSIX semantics unless the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; is in effect; see the description of &lt;code&gt;$?&lt;/code&gt; in this document for more detail.</source>
          <target state="translated">Perl在继续在当前进程中执行之前，等待子进程完成。如&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;中所述， &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 的返回值是伪造的&amp;ldquo; status&amp;rdquo;，它遵循POSIX语义，除非编译指示 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; 有效。看到 &lt;code&gt;$?&lt;/code&gt; 的描述？有关详细信息，请参见本文档。</target>
        </trans-unit>
        <trans-unit id="76b6739e84bfe97e715bfa0d21f10031957c9f2e" translate="yes" xml:space="preserve">
          <source>Perl waits for the subprocess to complete before continuing execution in the current process. As described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, the return value of &lt;code&gt;system&lt;/code&gt; is a fake &quot;status&quot; which follows POSIX semantics unless the pragma &lt;code&gt;use vmsish 'status'&lt;/code&gt; is in effect; see the description of &lt;code&gt;$?&lt;/code&gt; in this document for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77bc7bc2d999572b3218f851bcc9845dccf95ea0" translate="yes" xml:space="preserve">
          <source>Perl was born in Unix and can therefore access all common Unix system calls. In non-Unix environments, the functionality of some Unix system calls may not be available or details of the available functionality may differ slightly. The Perl functions affected by this are:</source>
          <target state="translated">Perl诞生于Unix,因此可以访问所有常见的Unix系统调用。在非Unix环境下,一些Unix系统调用的功能可能无法使用,或者可用功能的细节可能略有不同。受此影响的Perl函数有:</target>
        </trans-unit>
        <trans-unit id="749163e214f8798aa3cc386d45ba1c2b25237249" translate="yes" xml:space="preserve">
          <source>Perl was originally a language optimized for scanning arbitrary text files, extracting information from those text files, and printing reports based on that information. It quickly became a good language for many system management tasks. Over the years, Perl has grown into a general-purpose programming language. It's widely used for everything from quick &quot;one-liners&quot; to full-scale application development.</source>
          <target state="translated">Perl最初是一种优化的语言,用于扫描任意文本文件,从这些文本文件中提取信息,并根据这些信息打印报告。它很快就成为了许多系统管理任务的好语言。经过多年的发展,Perl已经成长为一种通用的编程语言。它被广泛用于从快速的 &quot;单行本 &quot;到全面的应用程序开发。</target>
        </trans-unit>
        <trans-unit id="97d7a9a879c5c36fd28bdf27f2f4d6a7f1d3b405" translate="yes" xml:space="preserve">
          <source>Perl was originally written to handle US-ASCII only (that is characters whose ordinal numbers are in the range 0 - 127). And documentation and comments may still use the term ASCII, when sometimes in fact the entire range from 0 - 255 is meant.</source>
          <target state="translated">Perl最初是为了处理US-ASCII码(即序数在0-127范围内的字符)而编写的。文档和注释可能仍然使用ASCII码这个术语,但实际上有时是指0-255的整个范围。</target>
        </trans-unit>
        <trans-unit id="bb45aa3bdb1623dc3032bd795cae4fbe7d4a4df0" translate="yes" xml:space="preserve">
          <source>Perl was ported to Mac OS by Matthias Neeracher &amp;lt;neeracher@mac.com&amp;gt;. Chris Nandor &amp;lt;pudge@pobox.com&amp;gt; continued development and maintenance for the duration of the port's life.</source>
          <target state="translated">Perth由Matthias Neeracher &amp;lt;neeracher@mac.com&amp;gt;移植到Mac OS。克里斯&amp;middot;南多（Chris Nandor）&amp;lt;pudge@pobox.com&amp;gt;在该港口的整个使用寿命期间继续进行开发和维护。</target>
        </trans-unit>
        <trans-unit id="5ead554bbd070f695e13f79404f4e374bc4948d2" translate="yes" xml:space="preserve">
          <source>Perl websites come in a variety of forms, but they fit into two large categories: forums and news websites. There are many Perl-related websites, so only a few of the community's largest are mentioned here.</source>
          <target state="translated">Perl网站的形式多种多样,但它们适合分为两大类:论坛和新闻网站。与Perl相关的网站有很多,这里只提到社区中最大的几个网站。</target>
        </trans-unit>
        <trans-unit id="96b1e3be8ed57ad80c83e18b4ef34638cdbe949f" translate="yes" xml:space="preserve">
          <source>Perl will always interpret this as a method call.</source>
          <target state="translated">Perl总是会将其解释为方法调用。</target>
        </trans-unit>
        <trans-unit id="108590eaf1947f78469e9a64442a6238023bfc97" translate="yes" xml:space="preserve">
          <source>Perl will always match at the earliest possible point in the string:</source>
          <target state="translated">Perl总是会在字符串中最早的点进行匹配。</target>
        </trans-unit>
        <trans-unit id="dab60b10c40a3d1c155299bacd4f38f02082cabc" translate="yes" xml:space="preserve">
          <source>Perl will attempt to flush all files opened for output before any operation that may do a fork, but this may not be supported on some platforms (see &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles.</source>
          <target state="translated">Perl将在执行任何可能进行派生的操作之前尝试刷新所有打开的文件以进行输出，但是在某些平台上可能不支持此操作（请参阅&lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;）。为了安全起见，您可能需要设置 &lt;code&gt;$|&lt;/code&gt; （英语中的$ AUTOFLUSH）或在任何打开的句柄上调用 &lt;code&gt;IO::Handle&lt;/code&gt; 的 &lt;code&gt;autoflush()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="cbb77319c3caa8ab8afaeca5e241bd4affc14078" translate="yes" xml:space="preserve">
          <source>Perl will attempt to flush all files opened for output before any operation that may do a fork, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;a href=&quot;perlvar#%24%7C&quot;&gt;&lt;code&gt;$|&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; in &lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;) or call the &lt;code&gt;autoflush&lt;/code&gt; method of &lt;a href=&quot;IO::Handle#METHODS&quot;&gt;&lt;code&gt;IO::Handle&lt;/code&gt;&lt;/a&gt; on any open handles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b0e0c3bc56ba7ca3959a0f5e022566b0153f54" translate="yes" xml:space="preserve">
          <source>Perl will attempt to flush all files opened for output before any operation that may do a fork, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles.</source>
          <target state="translated">Perl将在执行任何可能进行派生的操作之前尝试刷新所有打开的文件以进行输出，但是在某些平台上可能不支持此操作（请参阅&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;）。为了安全起见，您可能需要设置 &lt;code&gt;$|&lt;/code&gt; （英语中的$ AUTOFLUSH）或在任何打开的句柄上调用 &lt;code&gt;IO::Handle&lt;/code&gt; 的 &lt;code&gt;autoflush()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="2d8b585d320f38f1a30c6c32f686d7f733f4dca8" translate="yes" xml:space="preserve">
          <source>Perl will attempt to flush all files opened for output before starting the child process, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;&lt;/code&gt;) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;&lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;&lt;/code&gt; on any open handles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bea16b3be61058b5cb516538e14480b80e24dcc" translate="yes" xml:space="preserve">
          <source>Perl will attempt to flush all files opened for output before starting the child process, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;&lt;/code&gt;) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;&lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;&lt;/code&gt; on any open handles.</source>
          <target state="translated">Perl将在启动子进程之前尝试刷新所有打开的文件以进行输出，但是在某些平台上可能不支持此操作（请参阅&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;）。为了安全起见，您可能需要设置 &lt;code&gt;$|&lt;/code&gt; （ &lt;code&gt;$AUTOFLUSH&lt;/code&gt; 中 &lt;code&gt;&lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;&lt;/code&gt; ）或拨打 &lt;code&gt;autoflush()&lt;/code&gt; 的方法 &lt;code&gt;&lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;&lt;/code&gt; 上的任何打开的句柄。</target>
        </trans-unit>
        <trans-unit id="69e6c1ab664ef4d480c4cc1af41e9e1fb158cde3" translate="yes" xml:space="preserve">
          <source>Perl will completely read from all open directory handles until they reach the end of the stream. It will then seekdir() back to the original location and all future readdir() requests will be fulfilled from the cache buffer. That means that neither the directory handle held by the parent process nor the one held by the child process will see any changes made to the directory after the fork() call.</source>
          <target state="translated">Perl 将完全读取所有打开的目录句柄,直到它们到达流的末端。然后它将把seekdir()返回到原来的位置,所有未来的readdir()请求都将从缓存缓冲区中完成。这意味着无论是父进程持有的目录句柄还是子进程持有的目录句柄,都不会在fork()调用后看到对目录的任何更改。</target>
        </trans-unit>
        <trans-unit id="ae724785888abcc4558016f3ec47b4f4e63fe38a" translate="yes" xml:space="preserve">
          <source>Perl will generate an error for a few character properties in Unicode when used in a regular expression. The non-Unihan ones are listed below, with the reasons they are not accepted, perhaps with work-arounds. The short names for the properties are listed enclosed in (parentheses). As described after the list, an installation can change the defaults and choose to accept any of these. The list is machine generated based on the choices made for the installation that generated this document.</source>
          <target state="translated">Perl在正则表达式中使用Unicode中的一些字符属性时,会产生错误。下面列出了非Unihan的属性,以及它们不被接受的原因,也许还有变通的办法。这些属性的简称用(括号)括起来。如列表后所述,安装者可以更改默认值并选择接受其中任何一个。这个列表是根据生成本文档的安装所做的选择而由机器生成的。</target>
        </trans-unit>
        <trans-unit id="8b82b63566b58bfbfd5f88517a9ea3598fc70e2d" translate="yes" xml:space="preserve">
          <source>Perl will not guarantee what the result of the above statements is.</source>
          <target state="translated">Perl不会保证上述语句的结果是什么。</target>
        </trans-unit>
        <trans-unit id="ad11d6c2aaa2cf9eed67c4c4a37abbefb094f00c" translate="yes" xml:space="preserve">
          <source>Perl will print</source>
          <target state="translated">Perl会打印</target>
        </trans-unit>
        <trans-unit id="bf866573cd4df8609484c1bf4b87543aa847fff1" translate="yes" xml:space="preserve">
          <source>Perl will print &lt;code&gt;ONCE UPON A TIME THERE WAS&lt;/code&gt; , assuming, of course, that</source>
          <target state="translated">Perl会一次打印 &lt;code&gt;ONCE UPON A TIME THERE WAS&lt;/code&gt; ，当然，前提是</target>
        </trans-unit>
        <trans-unit id="c9125a8fdf67019b69d1e6b1d55295e266cee711" translate="yes" xml:space="preserve">
          <source>Perl will print &lt;code&gt;ONCE UPON A TIME THERE WAS&lt;/code&gt;, assuming, of course, that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9a0a9d3a3fd7fe149a4004c226420f095952a0" translate="yes" xml:space="preserve">
          <source>Perl will start PM programs from VIO (=text-mode) Perl process in a separate PM session; the opposite is not true: when you start a non-PM program from a PM Perl process, Perl would not run it in a separate session. If a separate session is desired, either ensure that shell will be used, as in &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'cmd /c myprog'&lt;/code&gt; , or start it using optional arguments to system() documented in &lt;code&gt;OS2::Process&lt;/code&gt; module. This is considered to be a feature.</source>
          <target state="translated">Perl将在单独的PM会话中从VIO（=文本模式）Perl进程启动PM程序；反之则不成立：从PM Perl进程启动非PM程序时，Perl不会在单独的会话中运行它。如果需要单独的会话，请确保将使用shell，如 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'cmd /c myprog'&lt;/code&gt; ，或使用 &lt;code&gt;OS2::Process&lt;/code&gt; 模块中记录的system（）的可选参数启动它。这被认为是一个功能。</target>
        </trans-unit>
        <trans-unit id="78588e527fc97bd83af2c6a428985bc498ac231c" translate="yes" xml:space="preserve">
          <source>Perl will start PM programs from VIO (=text-mode) Perl process in a separate PM session; the opposite is not true: when you start a non-PM program from a PM Perl process, Perl would not run it in a separate session. If a separate session is desired, either ensure that shell will be used, as in &lt;code&gt;system 'cmd /c myprog'&lt;/code&gt;, or start it using optional arguments to system() documented in &lt;code&gt;OS2::Process&lt;/code&gt; module. This is considered to be a feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79467cc317c9e9a63f21c7fa1de773705edf809c" translate="yes" xml:space="preserve">
          <source>Perl word completion module</source>
          <target state="translated">Perl单词完成模块</target>
        </trans-unit>
        <trans-unit id="5a1baab191c5a4cbb8bc8a1bc0cd6292ba8ea600" translate="yes" xml:space="preserve">
          <source>Perl works on a bewildering variety of Unix and Unix-like platforms (see e.g. most of the files in the</source>
          <target state="translated">Perl可以在各种Unix和类似Unix的平台上工作(例如,请看在</target>
        </trans-unit>
        <trans-unit id="5f937e1c9658905a769f6858da3294349601c8d9" translate="yes" xml:space="preserve">
          <source>Perl works with UTF-EBCDIC, a multi-byte encoding. In Perls earlier than v5.22, there may be various bugs in this regard.</source>
          <target state="translated">Perl使用UTF-EBCDIC,这是一种多字节编码。在早于v5.22的Perls中,可能会出现这方面的各种错误。</target>
        </trans-unit>
        <trans-unit id="42414ebda9bd8b337ff75ba9b25023988eae655b" translate="yes" xml:space="preserve">
          <source>Perl workshops are, as the name might suggest, workshops where Perl is taught in a variety of ways. At the workshops, subjects range from a beginner's introduction (such as the Pittsburgh Perl Workshop's &quot;Zero To Perl&quot;) to much more advanced subjects.</source>
          <target state="translated">顾名思义,Perl 工作室是以各种方式教授 Perl 的工作室。讲习班的主题从初级入门(如匹兹堡Perl讲习班的 &quot;零到Perl&quot;)到更高级的主题。</target>
        </trans-unit>
        <trans-unit id="7e6b25cba02b7a0948e7b911d7360593ba8a4f62" translate="yes" xml:space="preserve">
          <source>Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; think all codepoints take up 1 print column, but many take 0 or 2. Here to show that normalization makes no difference, we print out both forms:</source>
          <target state="translated">Perl的 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 认为所有代码点占用1个打印列，但许多代码点占用0或2。这里为了表明规范化没有区别，我们打印了两种形式：</target>
        </trans-unit>
        <trans-unit id="df2feb6f1ec6c5fcfce646b1caa76de773ce0f59" translate="yes" xml:space="preserve">
          <source>Perl&amp;rsquo;s &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;sprintf&lt;/code&gt;, and &lt;code&gt;format&lt;/code&gt; think all codepoints take up 1 print column, but many take 0 or 2. Here to show that normalization makes no difference, we print out both forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609b12c8bffe220b74d5c614b906ddd9f420fc60" translate="yes" xml:space="preserve">
          <source>Perl's</source>
          <target state="translated">Perl's</target>
        </trans-unit>
        <trans-unit id="e5e5cc8de2d6897fcdb211dcd0cc9ecba9c81faf" translate="yes" xml:space="preserve">
          <source>Perl's &quot;use integer&quot; might change the behaviour of % and / for scalars. This is because under 'use integer' Perl does what the underlying C library thinks is right, and this varies. However, &quot;use integer&quot; does not change the way things are done with Math::BigInt objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4304adeb0f8bf2fdb8cb6a0ee28ba6a82fef1c9" translate="yes" xml:space="preserve">
          <source>Perl's 'use integer;' changes the behaviour of % and / for scalars, but will not change BigInt's way to do things. This is because under 'use integer' Perl will do what the underlying C thinks is right and this is different for each system. If you need BigInt's behaving exactly like Perl's 'use integer', bug the author to implement it ;)</source>
          <target state="translated">Perl 的 'use integer;' 改变了 % 和/的行为,但不会改变 BigInt 的做事方式。这是因为在'use integer'下,Perl会做底层C认为正确的事情,而这对每个系统都是不同的。如果你需要BigInt的行为与Perl的 &quot;使用整数 &quot;完全一样,请向作者提出要求,让他实现它;)</target>
        </trans-unit>
        <trans-unit id="064e821c3cc7d30b6bfa1d90af859d75eba797c0" translate="yes" xml:space="preserve">
          <source>Perl's &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt; permits the following universally-known conversions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78408db0ece90050f47f78be2d21f98042f5d6be" translate="yes" xml:space="preserve">
          <source>Perl's &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; permits the following universally-known conversions:</source>
          <target state="translated">Perl的 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 允许进行以下众所周知的转换：</target>
        </trans-unit>
        <trans-unit id="679bce65e9c564373f478362e333d0a68acc42d5" translate="yes" xml:space="preserve">
          <source>Perl's &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; permits the following universally-known conversions:</source>
          <target state="translated">Perl的 &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 允许进行以下众所周知的转换：</target>
        </trans-unit>
        <trans-unit id="53cad962b7a83e25af2f6bf67e501730e16fa363" translate="yes" xml:space="preserve">
          <source>Perl's &lt;code&gt;pprivate&lt;/code&gt; structure</source>
          <target state="translated">Perl的 &lt;code&gt;pprivate&lt;/code&gt; 结构</target>
        </trans-unit>
        <trans-unit id="50b7e56f45ec7b1f922cb2ef554212efaf347a1d" translate="yes" xml:space="preserve">
          <source>Perl's API has changed over time, gaining new features, new functions, increasing its flexibility, and reducing the impact on the C namespace environment (reduced pollution). The header file written by this module, typically</source>
          <target state="translated">Perl的API随着时间的推移发生了变化,获得了新的特性,新的功能,增加了它的灵活性,减少了对C命名空间环境的影响(减少污染)。该模块所写的头文件,通常为</target>
        </trans-unit>
        <trans-unit id="e05aa87f748ad78da85fa4d39c89ae07ccce030e" translate="yes" xml:space="preserve">
          <source>Perl's C-style &lt;code&gt;for&lt;/code&gt; loop works like the corresponding &lt;code&gt;while&lt;/code&gt; loop; that means that this:</source>
          <target state="translated">Perl的C风格的 &lt;code&gt;for&lt;/code&gt; 循环类似于相应的 &lt;code&gt;while&lt;/code&gt; 循环；这意味着：</target>
        </trans-unit>
        <trans-unit id="5db9c37ab5f7f0381d150d83940e69ede28d72bd" translate="yes" xml:space="preserve">
          <source>Perl's IO. Consequently only built-in layers can appear in this list, as external layers (such as &lt;code&gt;:encoding()&lt;/code&gt; ) need IO in order to load them! See &lt;a href=&quot;open&quot;&gt;open pragma&lt;/a&gt; for how to add external encodings as defaults.</source>
          <target state="translated">Perl的IO。因此，只有内置层可以出现在此列表中，因为外部层（例如 &lt;code&gt;:encoding()&lt;/code&gt; ）需要IO才能加载它们！有关如何添加外部编码作为默认值，请参见&lt;a href=&quot;open&quot;&gt;open pragma&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b76c3fa97974625df89eb014ff16153ff4616729" translate="yes" xml:space="preserve">
          <source>Perl's IO. Consequently only built-in layers can appear in this list, as external layers (such as &lt;code&gt;:encoding()&lt;/code&gt;) need IO in order to load them! See &lt;a href=&quot;open&quot;&gt;&quot;open pragma&quot;&lt;/a&gt; for how to add external encodings as defaults.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a012002430e5ec63e7214212c95e7a6c13798d5" translate="yes" xml:space="preserve">
          <source>Perl's OO system is class-based. Class-based OO is fairly common. It's used by Java, C++, C#, Python, Ruby, and many other languages. There are other object orientation paradigms as well. JavaScript is the most popular language to use another paradigm. JavaScript's OO system is prototype-based.</source>
          <target state="translated">Perl的OO系统是基于类的。基于类的OO相当普遍。它被Java、C++、C#、Python、Ruby和许多其他语言所使用。还有其他的对象导向范式。JavaScript是使用另一种范式的最流行的语言。JavaScript的OO系统是基于原型的。</target>
        </trans-unit>
        <trans-unit id="9806e03898721874442226704be9b61686d35f9b" translate="yes" xml:space="preserve">
          <source>Perl's TIEHANDLE spec was incomplete prior to 5.005_57; it was missing support for &lt;code&gt;seek()&lt;/code&gt;, &lt;code&gt;tell()&lt;/code&gt;, and &lt;code&gt;eof()&lt;/code&gt;. Attempting to use these functions with an IO::Scalar will not work prior to 5.005_57. IO::Scalar will not have the relevant methods invoked; and even worse, this kind of bug can lie dormant for a while. If you turn warnings on (via &lt;code&gt;$^W&lt;/code&gt; or &lt;code&gt;perl -w&lt;/code&gt;), and you see something like this...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14833bc12320cc5b22e2f7f5922dcba8b20a6ea" translate="yes" xml:space="preserve">
          <source>Perl's Unicode Model</source>
          <target state="translated">Perl的Unicode模型</target>
        </trans-unit>
        <trans-unit id="78c1f3e5a87cf4bde2cfaf198cd9b736e054adc6" translate="yes" xml:space="preserve">
          <source>Perl's Unicode Support</source>
          <target state="translated">Perl的Unicode支持</target>
        </trans-unit>
        <trans-unit id="2f4e8610ccf72680ce428d05cdb3a44400f56202" translate="yes" xml:space="preserve">
          <source>Perl's arrays do not have a fixed size, so you don't need linked lists if you just want to add or remove items. You can use array operations such as &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; to do that.</source>
          <target state="translated">Perl的数组没有固定的大小，因此，如果您只想添加或删除项目，则不需要链接列表。您可以使用 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 等数组操作来执行此操作。</target>
        </trans-unit>
        <trans-unit id="180c125ddac8494f8c8cf2f82ef0744802e2f7e3" translate="yes" xml:space="preserve">
          <source>Perl's arrays do not have a fixed size, so you don't need linked lists if you just want to add or remove items. You can use array operations such as &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;shift&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt;, or &lt;code&gt;splice&lt;/code&gt; to do that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0829cd34f91158f6d50d3501d1729557f626943" translate="yes" xml:space="preserve">
          <source>Perl's basic open() statement can also be used for unidirectional interprocess communication by either appending or prepending a pipe symbol to the second argument to open(). Here's how to start something up in a child process you intend to write to:</source>
          <target state="translated">Perl的基本open()语句也可以通过在open()的第二个参数上追加或预置一个管道符号来进行单向的进程间通信。下面是如何在你打算写入的子进程中启动一些东西。</target>
        </trans-unit>
        <trans-unit id="d1c613eb863cbd84885db8255f46385590e7af47" translate="yes" xml:space="preserve">
          <source>Perl's basic open() statement can also be used for unidirectional interprocess communication by specifying the open mode as &lt;code&gt;|-&lt;/code&gt; or &lt;code&gt;-|&lt;/code&gt;. Here's how to start something up in a child process you intend to write to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f15224970f30bbd8cc0d913eabc8b8733adcd9" translate="yes" xml:space="preserve">
          <source>Perl's built-in introspection features are fairly minimal. &lt;code&gt;Moose&lt;/code&gt; builds on top of them and creates a full introspection layer for your classes. This lets you ask questions like &quot;what methods does the File class implement?&quot; It also lets you modify your classes programmatically.</source>
          <target state="translated">Perl的内置自省功能非常少。 &lt;code&gt;Moose&lt;/code&gt; 建立在它们之上，并为您的课程创建了完整的自省层。这使您可以提出诸如&amp;ldquo; File类实现什么方法？&amp;rdquo;之类的问题。它还允许您以编程方式修改类。</target>
        </trans-unit>
        <trans-unit id="45287a14757d133ee14640bcf6c328a91774bc92" translate="yes" xml:space="preserve">
          <source>Perl's builtin flock() function (see &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for details) will call flock(2) if that exists, fcntl(2) if it doesn't (on perl version 5.004 and later), and lockf(3) if neither of the two previous system calls exists. On some systems, it may even use a different form of native locking. Here are some gotchas with Perl's flock():</source>
          <target state="translated">Perl的内置flock（）函数（有关详细信息，请参见&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;）将调用flock（2）（如果存在的话），fcntl（2）（如果不存在）（在perl版本5.004及更高版本上）以及lockf（3）（如果两者都不存在）存在先前的系统调用。在某些系统上，它甚至可以使用其他形式的本机锁定。这是Perl的flock（）的一些陷阱：</target>
        </trans-unit>
        <trans-unit id="4e23292bcea30aa529b568a400bba32042a7e37e" translate="yes" xml:space="preserve">
          <source>Perl's characters are stored internally as sequences of one or more bytes. This pragma allows for the examination of the individual bytes that together comprise a character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f507c173df4e9952b98c777db1766156932095e8" translate="yes" xml:space="preserve">
          <source>Perl's documentation is an important resource for our users. It's incredibly important for Perl's documentation to be reasonably coherent and to accurately reflect the current implementation.</source>
          <target state="translated">Perl 的文档是我们用户的重要资源。让Perl的文档保持合理的连贯性并准确地反映当前的实现是非常重要的。</target>
        </trans-unit>
        <trans-unit id="8e7bbfdbc61f02638ca2efad632597e1e0cf6bad" translate="yes" xml:space="preserve">
          <source>Perl's engine sets this flag if the pattern is &lt;code&gt;\s+&lt;/code&gt;.</source>
          <target state="translated">如果模式为 &lt;code&gt;\s+&lt;/code&gt; 则Perl的引擎会设置此标志。</target>
        </trans-unit>
        <trans-unit id="c7dfeaf28529f5593bf2febfb63757ff3cbe501b" translate="yes" xml:space="preserve">
          <source>Perl's engine sets this flag on empty patterns, this optimization makes &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; //&lt;/code&gt; much faster than it would otherwise be. It's even faster than &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Perl的引擎将此标志设置为空模式，此优化使 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; //&lt;/code&gt; 的速度比原本要快得多。它甚至比 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 快。</target>
        </trans-unit>
        <trans-unit id="a12b92b4349d16b75893487c4da574782b294666" translate="yes" xml:space="preserve">
          <source>Perl's engine sets this flag on empty patterns, this optimization makes &lt;code&gt;split //&lt;/code&gt; much faster than it would otherwise be. It's even faster than &lt;code&gt;unpack&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0e4b0c5f9f6cc7920bb5bbdeff06433a976d20" translate="yes" xml:space="preserve">
          <source>Perl's engine sets this if the pattern is &lt;code&gt;/^/&lt;/code&gt; (&lt;code&gt;plen == 1 &amp;amp;&amp;amp; *exp
== '^'&lt;/code&gt; ), even under &lt;code&gt;/^/s&lt;/code&gt; ; see &lt;a href=&quot;perlfunc&quot;&gt;split&lt;/a&gt;. Of course a different regex engine might want to use the same optimizations with a different syntax.</source>
          <target state="translated">如果模式为 &lt;code&gt;/^/&lt;/code&gt; （ &lt;code&gt;plen == 1 &amp;amp;&amp;amp; *exp == '^'&lt;/code&gt; ），即使在 &lt;code&gt;/^/s&lt;/code&gt; 以下，Perl的引擎也会设置此值；见&lt;a href=&quot;perlfunc&quot;&gt;分裂&lt;/a&gt;。当然，不同的正则表达式引擎可能希望使用具有不同语法的相同优化。</target>
        </trans-unit>
        <trans-unit id="491c64f9a6d1d02d83e18cbec69820885ad456fd" translate="yes" xml:space="preserve">
          <source>Perl's engine sets this if the pattern is &lt;code&gt;/^/&lt;/code&gt; (&lt;code&gt;plen == 1 &amp;amp;&amp;amp; *exp == '^'&lt;/code&gt;), even under &lt;code&gt;/^/s&lt;/code&gt;; see &lt;a href=&quot;perlfunc&quot;&gt;split&lt;/a&gt;. Of course a different regex engine might want to use the same optimizations with a different syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f1c7280d32070c89f6f598972838907640e2c7c" translate="yes" xml:space="preserve">
          <source>Perl's exception handing (i.e. &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; etc.) is built on top of the low-level &lt;code&gt;setjmp()&lt;/code&gt; /&lt;code&gt;longjmp()&lt;/code&gt; C-library functions. These basically provide a way to capture the current PC and SP registers and later restore them; i.e. a &lt;code&gt;longjmp()&lt;/code&gt; continues at the point in code where a previous &lt;code&gt;setjmp()&lt;/code&gt; was done, with anything further up on the C stack being lost. This is why code should always save values using &lt;code&gt;SAVE_FOO&lt;/code&gt; rather than in auto variables.</source>
          <target state="translated">Perl的异常处理（例如 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 等）建立在底层 &lt;code&gt;setjmp()&lt;/code&gt; / &lt;code&gt;longjmp()&lt;/code&gt; C库函数的顶部。这些基本上提供了一种捕获当前PC和SP寄存器并随后还原它们的方法。也就是说， &lt;code&gt;longjmp()&lt;/code&gt; 在代码中先前执行 &lt;code&gt;setjmp()&lt;/code&gt; 的位置继续，而C堆栈上的所有内容都将丢失。这就是为什么代码应始终使用 &lt;code&gt;SAVE_FOO&lt;/code&gt; 而非自动变量来保存值的原因。</target>
        </trans-unit>
        <trans-unit id="624ef0dffdfa023577d4ff52307fa87cfe9d9de6" translate="yes" xml:space="preserve">
          <source>Perl's exception handing (i.e. &lt;code&gt;die&lt;/code&gt; etc.) is built on top of the low-level &lt;code&gt;setjmp()&lt;/code&gt;/&lt;code&gt;longjmp()&lt;/code&gt; C-library functions. These basically provide a way to capture the current PC and SP registers and later restore them; i.e. a &lt;code&gt;longjmp()&lt;/code&gt; continues at the point in code where a previous &lt;code&gt;setjmp()&lt;/code&gt; was done, with anything further up on the C stack being lost. This is why code should always save values using &lt;code&gt;SAVE_FOO&lt;/code&gt; rather than in auto variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91c40c4e8331eb78a3c6f0cd54f4782d65eb5ae" translate="yes" xml:space="preserve">
          <source>Perl's exception-handling mechanism is its &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; operator. You can use &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;longjmp&lt;/code&gt; . For details of this, see the section on signals, especially the time-out handler for a blocking &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; in &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt; or the section on &quot;Signals&quot; in</source>
          <target state="translated">Perl的异常处理机制是其 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 运算符。您可以将 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 用作 &lt;code&gt;setjmp&lt;/code&gt; ，将 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 用作 &lt;code&gt;longjmp&lt;/code&gt; 。有关此信息的详细信息，请参见有关信号的部分，尤其是&lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc&lt;/a&gt;中的Signals中的阻塞 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; 的超时处理程序，或有关perSign中的&amp;ldquo; Signals&amp;rdquo;部分</target>
        </trans-unit>
        <trans-unit id="9cac2f4c55e81f4acfeedcd4627b6c31b378f1bc" translate="yes" xml:space="preserve">
          <source>Perl's exception-handling mechanism is its &lt;code&gt;eval()&lt;/code&gt; operator. You can use &lt;code&gt;eval()&lt;/code&gt; as &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;die()&lt;/code&gt; as &lt;code&gt;longjmp&lt;/code&gt;. For details of this, see the section on signals, especially the time-out handler for a blocking &lt;code&gt;flock()&lt;/code&gt; in &lt;a href=&quot;perlipc#Signals&quot;&gt;&quot;Signals&quot; in perlipc&lt;/a&gt; or the section on &quot;Signals&quot; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7495373aa18cedc70045dae42e442c9fd6b35bbc" translate="yes" xml:space="preserve">
          <source>Perl's initial DTrace support was added, providing &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; probes.</source>
          <target state="translated">添加了Perl的初始DTrace支持，提供了 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; 探针。</target>
        </trans-unit>
        <trans-unit id="3b6888971fb1fbb4f3722d29940392de31cd3dc2" translate="yes" xml:space="preserve">
          <source>Perl's initial DTrace support was added, providing &lt;code&gt;sub-entry&lt;/code&gt; and &lt;code&gt;sub-return&lt;/code&gt; probes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de9d9a267eecc4785713b5ac86a07e677cc17c7d" translate="yes" xml:space="preserve">
          <source>Perl's internal UTF8 flag is called &quot;UTF8&quot;, without a hyphen. It indicates whether a string is internally encoded as &quot;utf8&quot;, also without a hyphen.</source>
          <target state="translated">Perl内部的UTF8标志叫做 &quot;UTF8&quot;,没有连字符。它表示一个字符串是否被内部编码为 &quot;utf8&quot;,也没有连字符。</target>
        </trans-unit>
        <trans-unit id="964109bdae72322c39e19dfb06177d03a380e828" translate="yes" xml:space="preserve">
          <source>Perl's internal error-handling mechanisms implement &lt;code&gt;die&lt;/code&gt; (and its internal equivalents) using longjmp. If this occurs during lexing, parsing or compilation, we must ensure that any ops allocated as part of the compilation process are freed. (Older Perl versions did not adequately handle this situation: when failing a parse, they would leak ops that were stored in C &lt;code&gt;auto&lt;/code&gt; variables and not linked anywhere else.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c96604288539e03d84ef021ff0e6c92aef63b6c" translate="yes" xml:space="preserve">
          <source>Perl's malloc() uses bucketed allocations. Every request is rounded up to the closest bucket size available, and a bucket is taken from the pool of buckets of that size.</source>
          <target state="translated">Perl的malloc()使用桶式分配。每一个请求都会被四舍五入到最接近的可用桶的大小,然后从该大小的桶池中抽取一个桶。</target>
        </trans-unit>
        <trans-unit id="b579bfa5793ff016b56c6d7d86928d92232797da" translate="yes" xml:space="preserve">
          <source>Perl's moaning about locale problems can be silenced by setting the environment variable &lt;code&gt;PERL_BADLANG&lt;/code&gt; to &quot;0&quot; or &quot;&quot;. This method really just sweeps the problem under the carpet: you tell Perl to shut up even when Perl sees that something is wrong. Do not be surprised if later something locale-dependent misbehaves.</source>
          <target state="translated">通过将环境变量 &lt;code&gt;PERL_BADLANG&lt;/code&gt; 设置为&amp;ldquo; 0&amp;rdquo;或&amp;ldquo;&amp;rdquo;，可以消除 Perl对语言环境问题的抱怨。这种方法确实可以解决所有问题：即使Perl认为出问题了，您也要告诉Perl关闭。如果以后出现某些与语言环境有关的错误行为，请不要感到惊讶。</target>
        </trans-unit>
        <trans-unit id="1f69de9b9e78267eea8d1d7d32a8294de0865cf8" translate="yes" xml:space="preserve">
          <source>Perl's operator overloading facility is completely ignored here. Operator overloading allows user-defined behaviors for numbers, such as operations over arbitrarily large integers, floating points numbers with arbitrary precision, operations over &quot;exotic&quot; numbers such as modular arithmetic or p-adic arithmetic, and so on. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; for details.</source>
          <target state="translated">这里完全忽略了Perl的运算符重载功能。运算符重载允许用户定义数字的行为，例如，对任意大整数的运算，具有任意精度的浮点数，对&amp;ldquo;异&amp;rdquo;数的运算（例如，模算术或p-adic算术），等等。有关详细信息，请参见&lt;a href=&quot;overload&quot;&gt;重载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="669d7e9913d51876345768dad50e148946b6d1f0" translate="yes" xml:space="preserve">
          <source>Perl's own engine will croak on any attempt to modify the capture variables, to do this in another engine use the following callback (copied from &lt;code&gt;Perl_reg_numbered_buff_store&lt;/code&gt; ):</source>
          <target state="translated">Perl自己的引擎将对尝试修改捕获变量的尝试之以 &lt;code&gt;Perl_reg_numbered_buff_store&lt;/code&gt; ，要在另一个引擎中执行此操作，请使用以下回调（从Perl_reg_numbered_buff_store复制）：</target>
        </trans-unit>
        <trans-unit id="532111a8d37e622ace362d3c82b8583e84a70c42" translate="yes" xml:space="preserve">
          <source>Perl's own engine will croak on any attempt to modify the capture variables, to do this in another engine use the following callback (copied from &lt;code&gt;Perl_reg_numbered_buff_store&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9f49d7c7e821b89479c1f1cbb325917aa3145b" translate="yes" xml:space="preserve">
          <source>Perl's packages, namespaces, and some info on classes.</source>
          <target state="translated">Perl的包、命名空间和一些关于类的信息。</target>
        </trans-unit>
        <trans-unit id="89f3a57557f87a2d78c866238eabb4d6f9e4ed76" translate="yes" xml:space="preserve">
          <source>Perl's pprivate structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4588c5311e33f989f4525ce1f0cd16204a00ea04" translate="yes" xml:space="preserve">
          <source>Perl's process, file, and text manipulation facilities make it particularly well-suited for tasks involving quick prototyping, system utilities, software tools, system management tasks, database access, graphical programming, networking, and web programming.</source>
          <target state="translated">Perl的进程、文件和文本处理功能使它特别适合于涉及快速原型设计、系统实用程序、软件工具、系统管理任务、数据库访问、图形编程、网络和网络编程的任务。</target>
        </trans-unit>
        <trans-unit id="93c38b6a66fe842db97ccbef348de209e8c19b5f" translate="yes" xml:space="preserve">
          <source>Perl's regular expression support is both broad and deep, and is the subject of lengthy documentation in &lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt;, &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;, and elsewhere. However, in short:</source>
          <target state="translated">Perl的正则表达式支持广泛而深入，并且是&lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt;，&lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;和其他地方冗长文档的主题。简而言之：</target>
        </trans-unit>
        <trans-unit id="ff94ebb325d8b09e3a30e14e5986ca64a175f3eb" translate="yes" xml:space="preserve">
          <source>Perl's roots in text processing haven't been forgotten over the years. It still boasts some of the most powerful regular expressions to be found anywhere, and its support for Unicode text is world-class. It handles all kinds of structured text, too, through an extensive collection of extensions. Those libraries, collected in the CPAN, provide ready-made solutions to an astounding array of problems. When they haven't set the standard themselves, they steal from the best -- just like Perl itself.</source>
          <target state="translated">多年来,Perl 在文本处理方面的根基并没有被遗忘。它仍然拥有一些最强大的正则表达式,而且它对 Unicode 文本的支持是世界级的。它还可以通过广泛的扩展库处理各种结构化文本。这些库收集在 CPAN 中,为一系列令人震惊的问题提供了现成的解决方案。当它们自己没有制定标准时,它们就从最好的库中偷取,就像Perl本身一样。</target>
        </trans-unit>
        <trans-unit id="e5126fad405ea6c1a0317bc1b96e0b7052710e86" translate="yes" xml:space="preserve">
          <source>Perl's source code is stored in a Git repository.</source>
          <target state="translated">Perl的源代码存储在Git仓库中。</target>
        </trans-unit>
        <trans-unit id="770b04c9b25881d8dba46acccf2294a181b06ea5" translate="yes" xml:space="preserve">
          <source>Perl's source code, and extensions that want maximum portability, should use the above functions instead of those defined in ANSI C's</source>
          <target state="translated">Perl的源代码,以及希望最大限度地提高可移植性的扩展,应该使用上述函数,而不是ANSI C的</target>
        </trans-unit>
        <trans-unit id="c91e012015b18438a085bd4240921bd7bbe55b97" translate="yes" xml:space="preserve">
          <source>Perl's threading package provides the &lt;code&gt;yield()&lt;/code&gt; function that does this. &lt;code&gt;yield()&lt;/code&gt; is pretty straightforward, and works like this:</source>
          <target state="translated">Perl的线程包提供了 &lt;code&gt;yield()&lt;/code&gt; 函数。 &lt;code&gt;yield()&lt;/code&gt; 非常简单，其工作方式如下：</target>
        </trans-unit>
        <trans-unit id="0d178a4e92aee7a478bcdc3786f5d6c00e61333c" translate="yes" xml:space="preserve">
          <source>Perl's version of &lt;code&gt;strdup()&lt;/code&gt; . Returns a pointer to a newly allocated string which is a duplicate of &lt;code&gt;pv&lt;/code&gt; . The size of the string is determined by &lt;code&gt;strlen()&lt;/code&gt; , which means it may not contain embedded &lt;code&gt;NUL&lt;/code&gt; characters and must have a trailing &lt;code&gt;NUL&lt;/code&gt; . The memory allocated for the new string can be freed with the &lt;code&gt;Safefree()&lt;/code&gt; function.</source>
          <target state="translated">Perl的 &lt;code&gt;strdup()&lt;/code&gt; 版本。返回指向新分配的字符串的指针，该字符串与 &lt;code&gt;pv&lt;/code&gt; 重复。字符串的大小由 &lt;code&gt;strlen()&lt;/code&gt; 确定，这意味着它可能不包含嵌入的 &lt;code&gt;NUL&lt;/code&gt; 字符，并且必须具有尾随 &lt;code&gt;NUL&lt;/code&gt; 。可以使用 &lt;code&gt;Safefree()&lt;/code&gt; 函数释放为新字符串分配的内存。</target>
        </trans-unit>
        <trans-unit id="cb7ece6ff69cf5a8948099da499efb5b6df6d0fa" translate="yes" xml:space="preserve">
          <source>Perl's version of &lt;code&gt;strdup()&lt;/code&gt;. Returns a pointer to a newly allocated string which is a duplicate of &lt;code&gt;pv&lt;/code&gt;. The size of the string is determined by &lt;code&gt;strlen()&lt;/code&gt;, which means it may not contain embedded &lt;code&gt;NUL&lt;/code&gt; characters and must have a trailing &lt;code&gt;NUL&lt;/code&gt;. To prevent memory leaks, the memory allocated for the new string needs to be freed when no longer needed. This can be done with the &lt;a href=&quot;#Safefree&quot;&gt;&quot;&lt;code&gt;Safefree&lt;/code&gt;&quot;&lt;/a&gt; function, or &lt;a href=&quot;perlguts#SAVEFREEPV%28p%29&quot;&gt;&lt;code&gt;SAVEFREEPV&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25b683a4b535a4d7cfe41ce26d997bfe703e18cc" translate="yes" xml:space="preserve">
          <source>Perl's version of what &lt;code&gt;strndup()&lt;/code&gt; would be if it existed. Returns a pointer to a newly allocated string which is a duplicate of the first &lt;code&gt;len&lt;/code&gt; bytes from &lt;code&gt;pv&lt;/code&gt; , plus a trailing &lt;code&gt;NUL&lt;/code&gt; byte. The memory allocated for the new string can be freed with the &lt;code&gt;Safefree()&lt;/code&gt; function.</source>
          <target state="translated">如果存在，则为 &lt;code&gt;strndup()&lt;/code&gt; Perl版本。返回一个指向新分配的字符串的指针，该字符串与 &lt;code&gt;pv&lt;/code&gt; 的前 &lt;code&gt;len&lt;/code&gt; 个字节以及 &lt;code&gt;NUL&lt;/code&gt; 字节重复。可以使用 &lt;code&gt;Safefree()&lt;/code&gt; 函数释放为新字符串分配的内存。</target>
        </trans-unit>
        <trans-unit id="dcb73b72031ec0067bbb619275e109d78350c312" translate="yes" xml:space="preserve">
          <source>Perl's version of what &lt;code&gt;strndup()&lt;/code&gt; would be if it existed. Returns a pointer to a newly allocated string which is a duplicate of the first &lt;code&gt;len&lt;/code&gt; bytes from &lt;code&gt;pv&lt;/code&gt;, plus a trailing &lt;code&gt;NUL&lt;/code&gt; byte. The memory allocated for the new string can be freed with the &lt;code&gt;Safefree()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a6f57c5b6a74291061b990e5d20daa26fe09bb" translate="yes" xml:space="preserve">
          <source>Perl's version vs. Unicode version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a524db45cae5747e45efc8dd0850e8e606106b1" translate="yes" xml:space="preserve">
          <source>Perl, for example, is supplied with two types of licence: The GNU GPL and The Artistic Licence (see the files README, Copying, and Artistic, or &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt; and &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;). Larry has good reasons for NOT just using the GNU GPL.</source>
          <target state="translated">例如，Perl提供了两种类型的许可证：GNU GPL和艺术许可（请参阅文件README，Copying和Artistic或&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt;和&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;）。Larry有充分的理由不只是使用GNU GPL。</target>
        </trans-unit>
        <trans-unit id="564aee985156bf1f7e4d6943ab0b96e9d1591dee" translate="yes" xml:space="preserve">
          <source>Perl, for example, is supplied with two types of licence: The GNU GPL and The Artistic Licence (see the files README, Copying, and Artistic, or &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlgpl&quot;&gt;perlgpl&lt;/a&gt; and &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlartistic&quot;&gt;perlartistic&lt;/a&gt;). Larry has good reasons for NOT just using the GNU GPL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb2ce1409b2c38c39e7006d8b4053a16eb3cd6a" translate="yes" xml:space="preserve">
          <source>Perl, in most cases, will raise a warning when matching an above-Unicode code point against a Unicode property when the result is &lt;code&gt;TRUE&lt;/code&gt; for &lt;code&gt;\p{}&lt;/code&gt; , and &lt;code&gt;FALSE&lt;/code&gt; for &lt;code&gt;\P{}&lt;/code&gt; . For example:</source>
          <target state="translated">Perl中，在大多数情况下，将针对匹配一个Unicode性的上述的Unicode代码点时当结果是提高警告 &lt;code&gt;TRUE&lt;/code&gt; 为 &lt;code&gt;\p{}&lt;/code&gt; ，和 &lt;code&gt;FALSE&lt;/code&gt; 为 &lt;code&gt;\P{}&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="4e8a529ad62929cfec8c575ae762a6bdd257a323" translate="yes" xml:space="preserve">
          <source>Perl, in most cases, will raise a warning when matching an above-Unicode code point against a Unicode property when the result is &lt;code&gt;TRUE&lt;/code&gt; for &lt;code&gt;\p{}&lt;/code&gt;, and &lt;code&gt;FALSE&lt;/code&gt; for &lt;code&gt;\P{}&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca608dbd89f51d5e2692a9f1c25c1e965290836e" translate="yes" xml:space="preserve">
          <source>Perl-Zeitung</source>
          <target state="translated">Perl-Zeitung</target>
        </trans-unit>
        <trans-unit id="ad6b525b8d5c1fb1d32da22f33d9e131f0326e0b" translate="yes" xml:space="preserve">
          <source>Perl.Exe</source>
          <target state="translated">Perl.Exe</target>
        </trans-unit>
        <trans-unit id="9a9aafaa9f4d06797b1c23d69746010b54bd3e53" translate="yes" xml:space="preserve">
          <source>Perl.com has two interesting articles on profiling: &quot;Profiling Perl&quot;, by Simon Cozens, &lt;a href=&quot;http://www.perl.com/lpt/a/850&quot;&gt;http://www.perl.com/lpt/a/850&lt;/a&gt; and &quot;Debugging and Profiling mod_perl Applications&quot;, by Frank Wiles, &lt;a href=&quot;http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&quot;&gt;http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&lt;/a&gt; .</source>
          <target state="translated">Perl.com上有两篇有关概要分析的有趣文章：Simon Cozens的&amp;ldquo;概要分析Perl&amp;rdquo;，&lt;a href=&quot;http://www.perl.com/lpt/a/850&quot;&gt;http&lt;/a&gt;：//www.perl.com/lpt/a/850 和Frank韦尔斯的&amp;ldquo;调试和概要分析mod_perl应用程序&amp;rdquo;，&lt;a href=&quot;http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&quot;&gt;http：/ /www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4578b93cb1f77ba5f7e19625dc5d7f4767458f2f" translate="yes" xml:space="preserve">
          <source>Perl.com has two interesting articles on profiling: &quot;Profiling Perl&quot;, by Simon Cozens, &lt;a href=&quot;https://www.perl.com/pub/2004/06/25/profiling.html/&quot;&gt;https://www.perl.com/pub/2004/06/25/profiling.html/&lt;/a&gt; and &quot;Debugging and Profiling mod_perl Applications&quot;, by Frank Wiles, &lt;a href=&quot;http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&quot;&gt;http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ecc62b49475d2cb5cb7295258de980e7bb9d53" translate="yes" xml:space="preserve">
          <source>Perl.pkg</source>
          <target state="translated">Perl.pkg</target>
        </trans-unit>
        <trans-unit id="047f2fc576481bb11cc4caee3ec1941467bc112a" translate="yes" xml:space="preserve">
          <source>Perl/Pollution/Portability</source>
          <target state="translated">Perl/Pollution/Portability</target>
        </trans-unit>
        <trans-unit id="0fabd9b0cbed286f085c386669bbb624b6ae0be5" translate="yes" xml:space="preserve">
          <source>Perl2Exe ( &lt;a href=&quot;http://www.indigostar.com/perl2exe.htm&quot;&gt;http://www.indigostar.com/perl2exe.htm&lt;/a&gt; ) is a command line program for converting perl scripts to executable files. It targets both Windows and Unix platforms.</source>
          <target state="translated">Perl2Exe（&lt;a href=&quot;http://www.indigostar.com/perl2exe.htm&quot;&gt;http://www.indigostar.com/perl2exe.htm&lt;/a&gt;）是用于将perl脚本转换为可执行文件的命令行程序。它针对Windows和Unix平台。</target>
        </trans-unit>
        <trans-unit id="a58d113e289a5dca1b713eadc28920196d35302a" translate="yes" xml:space="preserve">
          <source>Perl5 Functions not currently supported in Plan 9 Perl</source>
          <target state="translated">Perl5 Plan 9目前不支持的函数 Perl</target>
        </trans-unit>
        <trans-unit id="7cf03298e4568d40fe4a8c254cdea9aeaf4618e7" translate="yes" xml:space="preserve">
          <source>Perl5 access to Berkeley DB version 1.x</source>
          <target state="translated">Perl5访问Berkeley DB 1.x版本。</target>
        </trans-unit>
        <trans-unit id="a6b97c33f7f10f0b285f97ea17573e6970b9aabb" translate="yes" xml:space="preserve">
          <source>Perl5 access to the gdbm library.</source>
          <target state="translated">Perl5对gdbm库的访问。</target>
        </trans-unit>
        <trans-unit id="03941ae667c96e0e93e4d324251c39d314452658" translate="yes" xml:space="preserve">
          <source>Perl::OSType</source>
          <target state="translated">Perl::OSType</target>
        </trans-unit>
        <trans-unit id="b6aec8ca037613e9d0fce40c6e0f1816ba73a700" translate="yes" xml:space="preserve">
          <source>Perl::OSType - Map Perl operating system names to generic types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f928d45134ea1b82a2f4001e977a9ca5021266a" translate="yes" xml:space="preserve">
          <source>PerlApp</source>
          <target state="translated">PerlApp</target>
        </trans-unit>
        <trans-unit id="35c6d70e8ca70c86c34afe75094fe416cee5049d" translate="yes" xml:space="preserve">
          <source>PerlBuilder</source>
          <target state="translated">PerlBuilder</target>
        </trans-unit>
        <trans-unit id="1fdc87c61ab4b84ad3bb7770857151e78dcb1fd1" translate="yes" xml:space="preserve">
          <source>PerlBuilder is an integrated development environment for Windows that supports Perl development.</source>
          <target state="translated">PerlBuilder是一个支持Perl开发的Windows集成开发环境。</target>
        </trans-unit>
        <trans-unit id="6649c958c30583d092dd8452f695dfb9e308dc26" translate="yes" xml:space="preserve">
          <source>PerlCE is currently linked with a simple console window, so it also works on non-hpc devices.</source>
          <target state="translated">PerlCE目前与一个简单的控制台窗口相连,所以它也可以在非hpc设备上工作。</target>
        </trans-unit>
        <trans-unit id="7aa73f69917f5eded1a42950facbce7317ea38d8" translate="yes" xml:space="preserve">
          <source>PerlIDE is handy to deal with perlce.</source>
          <target state="translated">PerlIDE是方便处理perlce的。</target>
        </trans-unit>
        <trans-unit id="579ddb2e63a9c9da8567b958430ce3a45a513b30" translate="yes" xml:space="preserve">
          <source>PerlIO</source>
          <target state="translated">PerlIO</target>
        </trans-unit>
        <trans-unit id="2bc2886f7622b1210de6b2d1553751fdf04796f5" translate="yes" xml:space="preserve">
          <source>PerlIO * is a FILE *. This has been the default implementation since the abstraction was introduced in perl5.003_02.</source>
          <target state="translated">PerlIO *是一个FILE *。自从perl5.003_02中引入抽象概念以来,这一直是默认的实现。</target>
        </trans-unit>
        <trans-unit id="71eb144823195b4440065066f28d18b5ab87828c" translate="yes" xml:space="preserve">
          <source>PerlIO - On demand loader for PerlIO layers and root of PerlIO::* name space</source>
          <target state="translated">PerlIO-PerlIO层和PerlIO::*名称空间根的按需加载器。</target>
        </trans-unit>
        <trans-unit id="d16207b42b045b160714ba5de2f5ff0e6ff0943e" translate="yes" xml:space="preserve">
          <source>PerlIO ALWAYS calls this method to make sure it has its own private encoding object.</source>
          <target state="translated">PerlIO 总是调用这个方法来确保它有自己的私有编码对象。</target>
        </trans-unit>
        <trans-unit id="197c942bd2c3920a8495cda350b62bc73882bf34" translate="yes" xml:space="preserve">
          <source>PerlIO is a stack of layers.</source>
          <target state="translated">PerlIO是一个层的堆栈。</target>
        </trans-unit>
        <trans-unit id="44ba71a577701dc77528a1c3cec83d223013c700" translate="yes" xml:space="preserve">
          <source>PerlIO layer ':win32' is experimental</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="439a0e2b9ec37cb15accbd0aa170c3040534253a" translate="yes" xml:space="preserve">
          <source>PerlIO layer for quoted-printable strings</source>
          <target state="translated">可引用打印字符串的PerlIO层。</target>
        </trans-unit>
        <trans-unit id="4ee79df7d6409c5fdbae86adeadf23592d153d40" translate="yes" xml:space="preserve">
          <source>PerlIO layers for &lt;b&gt;STDIN&lt;/b&gt; and &lt;b&gt;STDOUT&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6870089453c5b7ff02d4f86fa5b13e128f37bf93" translate="yes" xml:space="preserve">
          <source>PerlIO material contributed by Lupe Christoph, with some clarification by Nick Ing-Simmons.</source>
          <target state="translated">PerlIO材料由Lupe Christoph贡献,Nick Ing-Simmons做了一些澄清。</target>
        </trans-unit>
        <trans-unit id="820323203cd8f8b2a76e01512d15f3f0590e6729" translate="yes" xml:space="preserve">
          <source>PerlIO overrides the default Cygwin Text/Binary behaviour. A file will always be treated as binary, regardless of the mode of the mount it lives on, just like it is in UNIX. So CR/LF translation needs to be requested in either the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; call like this:</source>
          <target state="translated">PerlIO会覆盖默认的Cygwin文本/二进制行为。就像文件在UNIX中一样，无论文件位于哪种装载模式，它都将始终被视为二进制文件。因此，需要在 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 调用中请求CR / LF转换，如下所示：</target>
        </trans-unit>
        <trans-unit id="9cc5889d76cbd97257ac5d37c17d569437b80e5c" translate="yes" xml:space="preserve">
          <source>PerlIO overrides the default Cygwin Text/Binary behaviour. A file will always be treated as binary, regardless of the mode of the mount it lives on, just like it is in UNIX. So CR/LF translation needs to be requested in either the &lt;code&gt;open()&lt;/code&gt; call like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4261eaed3053779b6ac602dc0094ca271817116" translate="yes" xml:space="preserve">
          <source>PerlIO.pm</source>
          <target state="translated">PerlIO.pm</target>
        </trans-unit>
        <trans-unit id="1154ad98b215ecf5df7b1e7ad79cee31862d0eaf" translate="yes" xml:space="preserve">
          <source>PerlIO::encoding</source>
          <target state="translated">PerlIO::encoding</target>
        </trans-unit>
        <trans-unit id="0bd3d0c97f8a1994a38840e4b2078cd8c7618564" translate="yes" xml:space="preserve">
          <source>PerlIO::encoding - encoding layer</source>
          <target state="translated">PerlIO::encoding-编码层</target>
        </trans-unit>
        <trans-unit id="1ed740d1e5082e67b34e9a633e9e92164f2f7b46" translate="yes" xml:space="preserve">
          <source>PerlIO::encoding, PerlIO::scalar, PerlIO::via in the Perl core.</source>
          <target state="translated">PerlIO::编码、PerlIO::标量、PerlIO::via在Perl核心。</target>
        </trans-unit>
        <trans-unit id="c62625c5db5d75cf0d983910b623b95f9bd27b6e" translate="yes" xml:space="preserve">
          <source>PerlIO::gzip and APR::PerlIO (mod_perl 2.0) on CPAN.</source>
          <target state="translated">PerlIO::gzip 和 APR::PerlIO (mod_perl 2.0)在 CPAN 上。</target>
        </trans-unit>
        <trans-unit id="304331cfad71f1b33cdb168da072d68db60896f0" translate="yes" xml:space="preserve">
          <source>PerlIO::mmap</source>
          <target state="translated">PerlIO::mmap</target>
        </trans-unit>
        <trans-unit id="a72b9d3b9fb038f07c1da369e861e7afab553215" translate="yes" xml:space="preserve">
          <source>PerlIO::mmap - Memory mapped IO</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b76466d411ce33a97489bbc61bc858849f23c2d6" translate="yes" xml:space="preserve">
          <source>PerlIO::scalar</source>
          <target state="translated">PerlIO::scalar</target>
        </trans-unit>
        <trans-unit id="68b32bd3bc2551440298bb2d6347e307a14d02ff" translate="yes" xml:space="preserve">
          <source>PerlIO::scalar - in-memory IO, scalar IO</source>
          <target state="translated">PerlIO::scalar-内存中的IO,标量IO</target>
        </trans-unit>
        <trans-unit id="6f4147b27883b678d3b28400a2747841090cc49c" translate="yes" xml:space="preserve">
          <source>PerlIO::via</source>
          <target state="translated">PerlIO::via</target>
        </trans-unit>
        <trans-unit id="d69e5b0660da6ada8428bd96b3dfa15197a8ec90" translate="yes" xml:space="preserve">
          <source>PerlIO::via - Helper class for PerlIO layers implemented in perl</source>
          <target state="translated">PerlIO::via-在perl中实现的PerlIO层的辅助类。</target>
        </trans-unit>
        <trans-unit id="c1ddecb6a7a6597042738bddffe28139074d4d7b" translate="yes" xml:space="preserve">
          <source>PerlIO::via::QuotedPrint</source>
          <target state="translated">PerlIO::via::QuotedPrint</target>
        </trans-unit>
        <trans-unit id="82ccb99b92622bcc0fc58d955a6b7496cc1351ac" translate="yes" xml:space="preserve">
          <source>PerlIO::via::QuotedPrint - PerlIO layer for quoted-printable strings</source>
          <target state="translated">PerlIO::via::QuotedPrint-用于引用打印字符串的PerlIO层。</target>
        </trans-unit>
        <trans-unit id="60e19b81fad8ebbf88c9ee26060f85ab35b8d0b9" translate="yes" xml:space="preserve">
          <source>PerlIO::via::QuotedPrint in the Perl core and PerlIO::via::* on CPAN.</source>
          <target state="translated">PerlIO::via::QuotedPrint在Perl核心和PerlIO::via::*在CPAN上。</target>
        </trans-unit>
        <trans-unit id="031a53d77ac71ec3ef46da5f59553f918d566426" translate="yes" xml:space="preserve">
          <source>PerlIOBase(PerlIO *f) returns the &quot;Base&quot; pointer, or in other words, the &lt;code&gt;PerlIOl*&lt;/code&gt; pointer.</source>
          <target state="translated">PerlIOBase（PerlIO * f）返回&amp;ldquo; Base&amp;rdquo;指针，或者换句话说， &lt;code&gt;PerlIOl*&lt;/code&gt; 指针。</target>
        </trans-unit>
        <trans-unit id="b34114bdf01a0e654170651a1a2e3dc55613845c" translate="yes" xml:space="preserve">
          <source>PerlIOSelf(PerlIO* f, type) return the PerlIOBase cast to a type.</source>
          <target state="translated">PerlIOSelf(PerlIO*f,type)返回PerlIOBase的类型。</target>
        </trans-unit>
        <trans-unit id="d57d00fa34f5c798b1a3aa08845fb7d0cb59fd01" translate="yes" xml:space="preserve">
          <source>PerlIO_apply_layers(f,mode,layers)</source>
          <target state="translated">PerlIO_apply_layers(f,mode,layers)</target>
        </trans-unit>
        <trans-unit id="571d6043e2ec872d7cb6f9099f8b8245ff464e37" translate="yes" xml:space="preserve">
          <source>PerlIO_binmode(f,ptype,imode,layers)</source>
          <target state="translated">PerlIO_binmode(f,ptype,imode,layers)</target>
        </trans-unit>
        <trans-unit id="3d8d78d3151e28ab17b88db0695455690dcd0493" translate="yes" xml:space="preserve">
          <source>PerlIO_close</source>
          <target state="translated">PerlIO_close</target>
        </trans-unit>
        <trans-unit id="3be650734ae821da60ceb0f946fbc1e419f8206f" translate="yes" xml:space="preserve">
          <source>PerlIO_context_layers</source>
          <target state="translated">PerlIO_context_layers</target>
        </trans-unit>
        <trans-unit id="0255e27b57dfc3265eea6731c6b0c7839e9ab42d" translate="yes" xml:space="preserve">
          <source>PerlIO_debug is a printf()-like function which can be used for debugging. No return value. Its main use is inside PerlIO where using real printf, warn() etc. would recursively call PerlIO and be a problem.</source>
          <target state="translated">PerlIO_debug 是一个类似 printf()的函数,可以用来调试。没有返回值。它的主要用途是在PerlIO内部,如果使用真正的printf、warning()等函数,会递归调用PerlIO,会有问题。</target>
        </trans-unit>
        <trans-unit id="89d032ee35b94a317d1e11679408a01d0f02011d" translate="yes" xml:space="preserve">
          <source>PerlIO_debug writes to the file named by $ENV{'PERLIO_DEBUG'} or defaults to stderr if the environment variable is not defined. Typical use might be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0fff3fc1334ecf07d826a061819bfc08e3aaea" translate="yes" xml:space="preserve">
          <source>PerlIO_debug writes to the file named by $ENV{'PERLIO_DEBUG'} typical use might be</source>
          <target state="translated">PerlIO_debug会写入以$ENV{'PERLIO_DEBUG'}命名的文件,典型的用法是</target>
        </trans-unit>
        <trans-unit id="7a73888154ab95ec9d3189d67cc64d8a26900457" translate="yes" xml:space="preserve">
          <source>PerlIO_debug(fmt,...)</source>
          <target state="translated">PerlIO_debug(fmt,...)</target>
        </trans-unit>
        <trans-unit id="100b7f7c057785e0afeda1c6eecdad5e89f91daa" translate="yes" xml:space="preserve">
          <source>PerlIO_error</source>
          <target state="translated">PerlIO_error</target>
        </trans-unit>
        <trans-unit id="9e246fb113c359325db7b695c42623371987cfe5" translate="yes" xml:space="preserve">
          <source>PerlIO_fill</source>
          <target state="translated">PerlIO_fill</target>
        </trans-unit>
        <trans-unit id="13b27853883b92af97538fe15f7fe52484d7c534" translate="yes" xml:space="preserve">
          <source>PerlIO_flush</source>
          <target state="translated">PerlIO_flush</target>
        </trans-unit>
        <trans-unit id="efbc7a55cb5fc7dbd487f7b3df5582d0c9c5b4ab" translate="yes" xml:space="preserve">
          <source>PerlIO_get_bufsiz</source>
          <target state="translated">PerlIO_get_bufsiz</target>
        </trans-unit>
        <trans-unit id="c10b5fb9db4780628505f2900df4a076d31c1d81" translate="yes" xml:space="preserve">
          <source>PerlIO_get_ptr</source>
          <target state="translated">PerlIO_get_ptr</target>
        </trans-unit>
        <trans-unit id="7178d99df96dc1b4506cce98992701276d9c239e" translate="yes" xml:space="preserve">
          <source>PerlIO_read</source>
          <target state="translated">PerlIO_read</target>
        </trans-unit>
        <trans-unit id="c9db204115f2772dfe73d45d977a7ab26c3db174" translate="yes" xml:space="preserve">
          <source>PerlIO_restore_errno</source>
          <target state="translated">PerlIO_restore_errno</target>
        </trans-unit>
        <trans-unit id="4ea99c1a1f0e14060bbf9890b956ec2732fc7963" translate="yes" xml:space="preserve">
          <source>PerlIO_save_errno</source>
          <target state="translated">PerlIO_save_errno</target>
        </trans-unit>
        <trans-unit id="3448e5bfc541fa5c1c6f7d0c567036327a6d1b1d" translate="yes" xml:space="preserve">
          <source>PerlIO_seek</source>
          <target state="translated">PerlIO_seek</target>
        </trans-unit>
        <trans-unit id="c3494517fbb2fd9ae4140e2f05e92ed232d54343" translate="yes" xml:space="preserve">
          <source>PerlIO_set_cnt</source>
          <target state="translated">PerlIO_set_cnt</target>
        </trans-unit>
        <trans-unit id="28b9d60a7d7cdedf7f8eab9fbfb1586a5e74e162" translate="yes" xml:space="preserve">
          <source>PerlIO_setlinebuf</source>
          <target state="translated">PerlIO_setlinebuf</target>
        </trans-unit>
        <trans-unit id="d03e37a9fec4395065d7268bae0c026fec23c250" translate="yes" xml:space="preserve">
          <source>PerlIO_stdout</source>
          <target state="translated">PerlIO_stdout</target>
        </trans-unit>
        <trans-unit id="d0cbd7701c5904432f5b089a12f15c43e18b06f2" translate="yes" xml:space="preserve">
          <source>PerlIO_unread</source>
          <target state="translated">PerlIO_unread</target>
        </trans-unit>
        <trans-unit id="3557c0fab3f26cfdec99b940ea71520d75ea2ee0" translate="yes" xml:space="preserve">
          <source>PerlInterpreter</source>
          <target state="translated">PerlInterpreter</target>
        </trans-unit>
        <trans-unit id="38a6b25b1659011ae61cace35aeff9baee4a13cd" translate="yes" xml:space="preserve">
          <source>PerlLIO_dup2_cloexec</source>
          <target state="translated">PerlLIO_dup2_cloexec</target>
        </trans-unit>
        <trans-unit id="f6ea8eebfba4a8ab959f7002d307625e66933740" translate="yes" xml:space="preserve">
          <source>PerlLIO_dup_cloexec</source>
          <target state="translated">PerlLIO_dup_cloexec</target>
        </trans-unit>
        <trans-unit id="73de2727af3d3234d0781998f683251a2002d497" translate="yes" xml:space="preserve">
          <source>PerlLIO_open3_cloexec</source>
          <target state="translated">PerlLIO_open3_cloexec</target>
        </trans-unit>
        <trans-unit id="f2fae1f35dbb5d09391fca46f2a80c2f8e50cc8b" translate="yes" xml:space="preserve">
          <source>PerlLIO_open_cloexec</source>
          <target state="translated">PerlLIO_open_cloexec</target>
        </trans-unit>
        <trans-unit id="6feba0dc339a322bf408c0ef0a0d56e7e1816aa9" translate="yes" xml:space="preserve">
          <source>PerlMonks is one of the largest Perl forums, and describes itself as &quot;A place for individuals to polish, improve, and showcase their Perl skills.&quot; and &quot;A community which allows everyone to grow and learn from each other.&quot;</source>
          <target state="translated">PerlMonks是最大的Perl论坛之一,它自称是 &quot;个人打磨、提高和展示Perl技能的地方。&quot;、&quot;一个让大家互相成长和学习的社区。&quot;</target>
        </trans-unit>
        <trans-unit id="96118a64fd38dbd81e3cb0e3744963bd1d54ba7a" translate="yes" xml:space="preserve">
          <source>PerlPower()</source>
          <target state="translated">PerlPower()</target>
        </trans-unit>
        <trans-unit id="f128e221d24537d88adf37c1080c58489584bc08" translate="yes" xml:space="preserve">
          <source>PerlProc_pipe_cloexec</source>
          <target state="translated">PerlProc_pipe_cloexec</target>
        </trans-unit>
        <trans-unit id="db63ab2940f098200e4ac58afc78b248f4d2fcb2" translate="yes" xml:space="preserve">
          <source>PerlShr.Exe</source>
          <target state="translated">PerlShr.Exe</target>
        </trans-unit>
        <trans-unit id="75aee309a8d63b5243b0d02f20422961a0ea87e9" translate="yes" xml:space="preserve">
          <source>PerlSock_accept_cloexec</source>
          <target state="translated">PerlSock_accept_cloexec</target>
        </trans-unit>
        <trans-unit id="24add7e2c5d5abdc4daafea395e2344696ac59c8" translate="yes" xml:space="preserve">
          <source>PerlSock_socket_cloexec</source>
          <target state="translated">PerlSock_socket_cloexec</target>
        </trans-unit>
        <trans-unit id="223a980cfc2b88529bd63e96b16d41c5cc62261a" translate="yes" xml:space="preserve">
          <source>PerlSock_socketpair_cloexec</source>
          <target state="translated">PerlSock_socketpair_cloexec</target>
        </trans-unit>
        <trans-unit id="097886f8ad6be4d2da4b42cedab0b39cdf7f9b1c" translate="yes" xml:space="preserve">
          <source>Perl_ VIO executable (statically linked)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07121cdb0e428e6add9cbaefd2f84414e43aa38b" translate="yes" xml:space="preserve">
          <source>Perl_PerlIO_or_Base(PerlIO* f, callback, base, failure, args) either calls the</source>
          <target state="translated">Perl_PerlIO_or_Base(PerlIO*f,callback,base,failure,args)要么调用了</target>
        </trans-unit>
        <trans-unit id="2f0f41f617e9b822c0919fb0f159f1a51c8bb029" translate="yes" xml:space="preserve">
          <source>Perl_PerlIO_or_Base_void(PerlIO* f, callback, base, args) either calls the</source>
          <target state="translated">Perl_PerlIO_or_Base_void(PerlIO*f,callback,base,args)可以调用</target>
        </trans-unit>
        <trans-unit id="81a3f26af0ca1bd5eb03eba445b883c96fd6bebb" translate="yes" xml:space="preserve">
          <source>Perl_PerlIO_or_fail(PerlIO* f, callback, failure, args) either calls the</source>
          <target state="translated">Perl_PerlIO_or_fail(PerlIO*f,callback,failure,args)可以调用</target>
        </trans-unit>
        <trans-unit id="e4851451f4653d2e45acca412261ea7befab27cf" translate="yes" xml:space="preserve">
          <source>Perl_PerlIO_or_fail_void(PerlIO* f, callback, args) either calls the</source>
          <target state="translated">Perl_PerlIO_or_fail_void(PerlIO*f,callback,args)可以调用</target>
        </trans-unit>
        <trans-unit id="2ed83c745e785ffa5b094c3edf1bccccffccea32" translate="yes" xml:space="preserve">
          <source>Perl_custom_op_xop</source>
          <target state="translated">Perl_custom_op_xop</target>
        </trans-unit>
        <trans-unit id="2bd7ba33bc197c1cac645c3fa7496edd8205233d" translate="yes" xml:space="preserve">
          <source>Perl_isinfnan() is utility function that returns true if the NV argument is either an infinity or a NaN, false otherwise. To test in more detail, use Perl_isinf() and Perl_isnan().</source>
          <target state="translated">Perl_isinfnan()是一个实用函数,如果 NV 参数是无穷大或 NaN,则返回 true,否则返回 false。要进行更详细的测试,请使用 Perl_isinf()和 Perl_isnan()。</target>
        </trans-unit>
        <trans-unit id="9632627677c9064aca08da1e222aaa10c0c1893b" translate="yes" xml:space="preserve">
          <source>Perl_langinfo</source>
          <target state="translated">Perl_langinfo</target>
        </trans-unit>
        <trans-unit id="9ddad3a0f4e11c02b4e6bd2fa655acf548001837" translate="yes" xml:space="preserve">
          <source>Perl_my_%s() not available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f50fc46743d6c022f3455d5dab2d3097bb717c" translate="yes" xml:space="preserve">
          <source>Perl_setlocale</source>
          <target state="translated">Perl_setlocale</target>
        </trans-unit>
        <trans-unit id="d5a2a12addea9810bccfcba9c388e5aa60aaf3d9" translate="yes" xml:space="preserve">
          <source>Perl_signbit</source>
          <target state="translated">Perl_signbit</target>
        </trans-unit>
        <trans-unit id="c68adda4177619ceaf594bde89a717be1213ecd6" translate="yes" xml:space="preserve">
          <source>Perls since %s too modern--this is %s, stopped</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435a6fd71f06655224907356e4d56d72c377a1bd" translate="yes" xml:space="preserve">
          <source>Perls starting in 5.8 have a different Unicode model from 5.6. In 5.6 the programmer was required to use the &lt;code&gt;utf8&lt;/code&gt; pragma to declare that a given scope expected to deal with Unicode data and had to make sure that only Unicode data were reaching that scope. If you have code that is working with 5.6, you will need some of the following adjustments to your code. The examples are written such that the code will continue to work under 5.6, so you should be safe to try them out.</source>
          <target state="translated">从5.8开始的Perls具有与5.6不同的Unicode模型。在5.6中，要求程序员使用 &lt;code&gt;utf8&lt;/code&gt; 编译指示声明给定范围希望处理Unicode数据，并且必须确保只有Unicode数据才能到达该范围。如果您有使用5.6的代码，则需要对代码进行以下一些调整。编写示例以使代码在5.6下可以继续工作，因此您应该安全地尝试它们。</target>
        </trans-unit>
        <trans-unit id="b95bc9c4bdba73fd23a6e99cb0cb35ee28a07aa3" translate="yes" xml:space="preserve">
          <source>Permanently attach to the shared memory segment. When a &lt;code&gt;IPC::SharedMem&lt;/code&gt; object is attached, it will use &lt;a href=&quot;http://search.cpan.org/perldoc/memread&quot;&gt;memread&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/memwrite&quot;&gt;memwrite&lt;/a&gt; instead of &lt;a href=&quot;../functions/shmread&quot;&gt;shmread&lt;/a&gt; and &lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt; for accessing the shared memory segment. Returns true if successful, or false on error. See &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat&lt;/a&gt;.</source>
          <target state="translated">永久附加到共享内存段。当一个 &lt;code&gt;IPC::SharedMem&lt;/code&gt; 物体附着，它将使用&lt;a href=&quot;http://search.cpan.org/perldoc/memread&quot;&gt;memread&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/memwrite&quot;&gt;memwrite&lt;/a&gt;代替&lt;a href=&quot;../functions/shmread&quot;&gt;shmread&lt;/a&gt;和&lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt;用于访问共享存储器段。如果成功，则返回true；如果错误，则返回false。参见&lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c26d4aa620dca99b812bc4a79254d9e74d407fd7" translate="yes" xml:space="preserve">
          <source>Permanently attach to the shared memory segment. When a &lt;code&gt;IPC::SharedMem&lt;/code&gt; object is attached, it will use &lt;a href=&quot;memread&quot;&gt;memread&lt;/a&gt; and &lt;a href=&quot;memwrite&quot;&gt;memwrite&lt;/a&gt; instead of &lt;a href=&quot;shmread&quot;&gt;shmread&lt;/a&gt; and &lt;a href=&quot;shmwrite&quot;&gt;shmwrite&lt;/a&gt; for accessing the shared memory segment. Returns true if successful, or false on error. See &lt;a href=&quot;http://man.he.net/man2/shmat&quot;&gt;shmat(2)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c52fa4da091dd586a97843497807bc0e23a069" translate="yes" xml:space="preserve">
          <source>Permanently fixing locale problems</source>
          <target state="translated">永久性地解决地域问题</target>
        </trans-unit>
        <trans-unit id="2cf2947e5f569b9ea7e16800990428360247021e" translate="yes" xml:space="preserve">
          <source>Permanently fixing your system's locale configuration</source>
          <target state="translated">永久修复您的系统的locale配置。</target>
        </trans-unit>
        <trans-unit id="9ab7f14d670c62039e207778bc0fed042486426a" translate="yes" xml:space="preserve">
          <source>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</source>
          <target state="translated">兹免费允许任何获得本软件和相关文档文件(&quot;软件&quot;)的人不受限制地使用本软件,包括但不限于使用、复制、修改、合并、出版、分发、再许可和/或出售本软件的权利,并允许接受本软件的人在以下条件下这样做:</target>
        </trans-unit>
        <trans-unit id="78d9cc4b4fc45291ef4d268d18882d87b86fac76" translate="yes" xml:space="preserve">
          <source>Permit</source>
          <target state="translated">Permit</target>
        </trans-unit>
        <trans-unit id="0f8250826e3e169df1c1ab3f1a4991fb276b498f" translate="yes" xml:space="preserve">
          <source>Permit the listed operators to be used when compiling code in the compartment (in</source>
          <target state="translated">允许在车厢内编译代码时使用列出的操作符(在</target>
        </trans-unit>
        <trans-unit id="d4efe59e4dc596d83fe507198172c79c563d3297" translate="yes" xml:space="preserve">
          <source>Pern</source>
          <target state="translated">Pern</target>
        </trans-unit>
        <trans-unit id="b7871f509f5f98e4d602975abaec93401e8fa9c5" translate="yes" xml:space="preserve">
          <source>Persistence for Perl data structures</source>
          <target state="translated">Perl数据结构的持久性</target>
        </trans-unit>
        <trans-unit id="f887bea11bbedab00d763b35a7c513eee8986177" translate="yes" xml:space="preserve">
          <source>Persistent Private Variables</source>
          <target state="translated">永久性私有变量</target>
        </trans-unit>
        <trans-unit id="37fcb2b67d89818ceecfdb67f2459b636da00b36" translate="yes" xml:space="preserve">
          <source>Persistent variables via state()</source>
          <target state="translated">通过state()的持久性变量</target>
        </trans-unit>
        <trans-unit id="2e14d0f6039c4bed4f250852e11a5960cec217cc" translate="yes" xml:space="preserve">
          <source>Persistent variables with closures</source>
          <target state="translated">带闭合的持久性变量</target>
        </trans-unit>
        <trans-unit id="297062bf4f638f4e5a1559e426d9dca1019c35bc" translate="yes" xml:space="preserve">
          <source>Peter J. Farley III</source>
          <target state="translated">Peter J.Farley III</target>
        </trans-unit>
        <trans-unit id="2443526b197b82e6711ce47499d4a744b2d3caac" translate="yes" xml:space="preserve">
          <source>Peter John Acklam</source>
          <target state="translated">Peter John Acklam</target>
        </trans-unit>
        <trans-unit id="9619c2ff06f7bbbafb0d5e9160ae26df77e91db0" translate="yes" xml:space="preserve">
          <source>Peter John Acklam &amp;lt;pjacklam@gmail.com&amp;lt;gt&amp;gt;, 2014-.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9567258b003fa101683db10492bc177b3b183a" translate="yes" xml:space="preserve">
          <source>Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="587cf83d47912d48cff152ba5703ff6e1be6461d" translate="yes" xml:space="preserve">
          <source>Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt;, 2011-.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad3ffe64617bfe15d4f21e7a60a9ca00647098f" translate="yes" xml:space="preserve">
          <source>Peter John Acklam, &amp;lt;pjacklam@online.no&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a32278777d03ff2e6b6ad59e9b3657ba9315fcef" translate="yes" xml:space="preserve">
          <source>Peter Prymmer</source>
          <target state="translated">Peter Prymmer</target>
        </trans-unit>
        <trans-unit id="c3032976541bf9515b50f93b039ec87133fcbe77" translate="yes" xml:space="preserve">
          <source>Peter Prymmer pvhp@best.com wrote this in 1999 and 2000 with CCSID 0819 and 0037 help from Chris Leach and Andr&amp;eacute; Pirard A.Pirard@ulg.ac.be as well as POSIX-BC help from Thomas Dorner Thomas.Dorner@start.de. Thanks also to Vickie Cooper, Philip Newton, William Raffloer, and Joe Smith. Trademarks, registered trademarks, service marks and registered service marks used in this document are the property of their respective owners.</source>
          <target state="translated">Peter Prymmer pvhp@best.com在1999和2000年用Chris Leach和Andr&amp;eacute;Pirard A.Pirard@ulg.ac.be的CCSID 0819和0037帮助以及Thomas Dorner Thomas.Dorner@start的POSIX-BC帮助编写了此文件。德 同时还要感谢Vickie Cooper，Philip Newton，William Raffloer和Joe Smith。本文档中使用的商标，注册商标，服务商标和注册服务商标均为其各自所有者的财产。</target>
        </trans-unit>
        <trans-unit id="b678d41f58da447298d919f29043393443d0cb8b" translate="yes" xml:space="preserve">
          <source>Peter Rabbitson</source>
          <target state="translated">Peter Rabbitson</target>
        </trans-unit>
        <trans-unit id="898a609b1123bee03d0fba96ca647e344dd3c879" translate="yes" xml:space="preserve">
          <source>Peter Rabbitson &amp;lt;ribasushi@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6caa883001f8951928abc18a49fa0996873b1e" translate="yes" xml:space="preserve">
          <source>Peter Scott &amp;lt;Peter@PSDT.com&amp;gt;</source>
          <target state="translated">彼得&amp;middot;斯科特&amp;lt;Peter@PSDT.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6bf5b1ffed5896f2003c72c19a4b2211605af373" translate="yes" xml:space="preserve">
          <source>Petr P&amp;iacute;sař &amp;lt;ppisar@redhat.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bab0d91a1e342ed2899a60bb0fd7fbb5d908345" translate="yes" xml:space="preserve">
          <source>Phase-specific attribute handlers</source>
          <target state="translated">特定阶段的属性处理程序</target>
        </trans-unit>
        <trans-unit id="1299c5da4d36f7c6543acebafdc41ccf1b565939" translate="yes" xml:space="preserve">
          <source>Phases</source>
          <target state="translated">Phases</target>
        </trans-unit>
        <trans-unit id="11224e45779f711f0ecc038e4dc550b38b44febf" translate="yes" xml:space="preserve">
          <source>Philippe Bruhat &amp;lt;book@cpan.org&amp;gt;</source>
          <target state="translated">菲利普&amp;middot;布鲁哈（Philippe Bruhat）&amp;lt;book@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8067364d44f5e37baba7e13ba124e934df410e2a" translate="yes" xml:space="preserve">
          <source>Philippines</source>
          <target state="translated">Philippines</target>
        </trans-unit>
        <trans-unit id="b7b6129ef396633c6d7fbf8b5ba6a676cf84b685" translate="yes" xml:space="preserve">
          <source>Philosophy and History</source>
          <target state="translated">哲学和历史</target>
        </trans-unit>
        <trans-unit id="a7ca65a16231d5ab21bb882a874c4184071b79df" translate="yes" xml:space="preserve">
          <source>Pick one style or another of &quot;TODO&quot; to be on the safe side.</source>
          <target state="translated">为了安全起见,选择一种或多种风格的 &quot;TODO&quot;。</target>
        </trans-unit>
        <trans-unit id="d9e68904cd8d62a6bd9853c94a5ff5af64e98135" translate="yes" xml:space="preserve">
          <source>Picture lines contain output field definitions, intermingled with literal text. These lines do not undergo any kind of variable interpolation. Field definitions are made up from a set of characters, for starting and extending a field to its desired width. This is the complete set of characters for field definitions:</source>
          <target state="translated">图片行包含输出字段定义,与文字混合在一起。这些行没有经过任何形式的变量插值。字段定义由一组字符组成,用于开始和扩展一个字段到它所需的宽度。这是字段定义的完整字符集。</target>
        </trans-unit>
        <trans-unit id="2ce99d2159f85cc771804ecbd9dda841764e190d" translate="yes" xml:space="preserve">
          <source>Pictures help... Here's the &lt;code&gt;%hash&lt;/code&gt; table:</source>
          <target state="translated">图片帮助...这是 &lt;code&gt;%hash&lt;/code&gt; 表：</target>
        </trans-unit>
        <trans-unit id="c65c8c71a5372d959508dd740dbc1277950d7e03" translate="yes" xml:space="preserve">
          <source>Pictures of the characters in</source>
          <target state="translated">角色的图片</target>
        </trans-unit>
        <trans-unit id="576c308de400973ac0e3b490eedf5eb2dfd16554" translate="yes" xml:space="preserve">
          <source>Ping the configured mirrors and print a report</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a9c866fde7f49d0c8287047fc7266c3fcf3448" translate="yes" xml:space="preserve">
          <source>Ping the remote host and wait for a response. $host can be either the hostname or the IP number of the remote host. The optional timeout must be greater than 0 seconds and defaults to whatever was specified when the ping object was created. Returns a success flag. If the hostname cannot be found or there is a problem with the IP number, the success flag returned will be undef. Otherwise, the success flag will be 1 if the host is reachable and 0 if it is not. For most practical purposes, undef and 0 and can be treated as the same case. In array context, the elapsed time as well as the string form of the ip the host resolved to are also returned. The elapsed time value will be a float, as returned by the Time::HiRes::time() function, if hires() has been previously called, otherwise it is returned as an integer.</source>
          <target state="translated">Ping远程主机并等待响应。$host可以是远程主机的主机名或IP号。可选的超时时间必须大于0秒,默认为创建ping对象时指定的时间。返回一个成功标志。如果找不到主机名或者IP号有问题,返回的成功标志将是undef。否则,如果主机是可到达的,则返回1,如果不是,则返回0。对于大多数实际目的,undef和0和可以作为相同的情况。在数组上下文中,还将返回经过的时间以及主机解析到的ip的字符串形式。如果之前调用了hires(),那么经过的时间值将是一个float,由Time::HiRes::time()函数返回,否则将作为一个整数返回。</target>
        </trans-unit>
        <trans-unit id="07ec367a9d37985bd6dc081364fe2955df9103f5" translate="yes" xml:space="preserve">
          <source>Piotr Roszatycki &amp;lt;piotr.roszatycki@gmail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc0c839f8f40b7cdba9f85501b6142c7594b73f" translate="yes" xml:space="preserve">
          <source>Pipe-open (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="translated">使用包含重定向或shell元字符的命令以管道方式打开（请参见&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5e4c7a898c7f3c0a7c60e0a1f604f62469eeccef" translate="yes" xml:space="preserve">
          <source>Pipe-open (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b1d5a78493496dd5152fd2d504f7e21009e3f2" translate="yes" xml:space="preserve">
          <source>Pipeline</source>
          <target state="translated">Pipeline</target>
        </trans-unit>
        <trans-unit id="785af2a4ad3c4ee912623c6e0b6d4299ea305bf6" translate="yes" xml:space="preserve">
          <source>Pipes</source>
          <target state="translated">Pipes</target>
        </trans-unit>
        <trans-unit id="86638d4dd1bfeebd306bf371ebd586c8fe132936" translate="yes" xml:space="preserve">
          <source>Place &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack.</source>
          <target state="translated">将 &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; 放置在堆栈上的指定位置 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="667a33361c3428c4b6aa60ad95cf789c3ab5ca45" translate="yes" xml:space="preserve">
          <source>Place &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; into the specified position &lt;code&gt;pos&lt;/code&gt; on the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfd0139035f77f7f1b17632082240cf0b36e9af1" translate="yes" xml:space="preserve">
          <source>Place &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack.</source>
          <target state="translated">将 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 放置在堆栈上的指定位置 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="1bb0eaf6fb6e81489445c95594e8a4006384093d" translate="yes" xml:space="preserve">
          <source>Place &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; into the specified position &lt;code&gt;pos&lt;/code&gt; on the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916f413ffd5622b866aac763ff8940f66e4a31b9" translate="yes" xml:space="preserve">
          <source>Place &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack.</source>
          <target state="translated">将 &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; 放入堆栈中的指定位置 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e6b770ad9c900ebf8f52e20c4972e42b76ef551" translate="yes" xml:space="preserve">
          <source>Place &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; into the specified position &lt;code&gt;pos&lt;/code&gt; on the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6d516f55eff9b2bccabbdde7685a4b4a9da03f" translate="yes" xml:space="preserve">
          <source>Place a copy of a string into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack. The value is stored in a new mortal SV.</source>
          <target state="translated">将字符串的副本放入堆栈中的指定位置 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 。该值存储在新的凡人SV中。</target>
        </trans-unit>
        <trans-unit id="0280f1983669ea3d48307e5d81450dc6030237bb" translate="yes" xml:space="preserve">
          <source>Place a copy of a string into the specified position &lt;code&gt;pos&lt;/code&gt; on the stack. The value is stored in a new mortal SV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e9ab6d8d695d32843b4420d43d220a9cd88325d" translate="yes" xml:space="preserve">
          <source>Place a double into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack. The value is stored in a new mortal SV.</source>
          <target state="translated">将双 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 放入堆栈中的指定位置pos。该值存储在新的凡人SV中。</target>
        </trans-unit>
        <trans-unit id="acaa37c824afdb131865b7892e6a4b9ea9e6bb6f" translate="yes" xml:space="preserve">
          <source>Place a double into the specified position &lt;code&gt;pos&lt;/code&gt; on the stack. The value is stored in a new mortal SV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd0007151ad5655c9cbf9340c82d4632eb28b7a" translate="yes" xml:space="preserve">
          <source>Place a message on the queue with the data from &lt;code&gt;MSG&lt;/code&gt; and with type &lt;code&gt;TYPE&lt;/code&gt; . See &lt;a href=&quot;../functions/msgsnd&quot;&gt;msgsnd&lt;/a&gt;.</source>
          <target state="translated">将消息与来自 &lt;code&gt;MSG&lt;/code&gt; 的数据和类型 &lt;code&gt;TYPE&lt;/code&gt; 放入队列中。参见&lt;a href=&quot;../functions/msgsnd&quot;&gt;msgsnd&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e44c92ac9de84e3be1e9794c9e8e47af2229079" translate="yes" xml:space="preserve">
          <source>Place a message on the queue with the data from &lt;code&gt;MSG&lt;/code&gt; and with type &lt;code&gt;TYPE&lt;/code&gt;. See &lt;a href=&quot;http://man.he.net/man2/msgsnd&quot;&gt;msgsnd(2)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d30c30326aad079b79429ee5676ce31987795b" translate="yes" xml:space="preserve">
          <source>Place an integer into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack. The value is stored in a new mortal SV.</source>
          <target state="translated">将整数放入堆栈中的指定位置 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 。该值存储在新的凡人SV中。</target>
        </trans-unit>
        <trans-unit id="710e9af5bbb2e9924ef8178acb3d4818fea16e1d" translate="yes" xml:space="preserve">
          <source>Place an integer into the specified position &lt;code&gt;pos&lt;/code&gt; on the stack. The value is stored in a new mortal SV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751296589ec0d0f52635e93df3addb6811063c1f" translate="yes" xml:space="preserve">
          <source>Place an unsigned integer into the specified position &lt;code&gt;pos&lt;/code&gt; on the stack. The value is stored in a new mortal SV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ab3cd1c8c731f94b45abaa6c37498e8157e7f50" translate="yes" xml:space="preserve">
          <source>Placeholder for a, w, t, T</source>
          <target state="translated">a,w,t,T的占位符。</target>
        </trans-unit>
        <trans-unit id="51c02f2095250dc21f9cbdf7822d894accd922c2" translate="yes" xml:space="preserve">
          <source>Plain &lt;code&gt;eval&lt;/code&gt; with no argument is just &lt;code&gt;eval EXPR&lt;/code&gt;, where the expression is understood to be contained in &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;. Thus there are only two real &lt;code&gt;eval&lt;/code&gt; forms; the one with an EXPR is often called &quot;string eval&quot;. In a string eval, the value of the expression (which is itself determined within scalar context) is first parsed, and if there were no errors, executed as a block within the lexical context of the current Perl program. This form is typically used to delay parsing and subsequent execution of the text of EXPR until run time. Note that the value is parsed every time the &lt;code&gt;eval&lt;/code&gt; executes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054293d76d1e13ea0985d27d43a20139eff0cdfe" translate="yes" xml:space="preserve">
          <source>Plain Old Comments (Not!)</source>
          <target state="translated">平凡的评论(不是!)。</target>
        </trans-unit>
        <trans-unit id="9580fcbce0c31ceaa47eb583e5f7ce637fdc8a0a" translate="yes" xml:space="preserve">
          <source>Plain text</source>
          <target state="translated">纯文本</target>
        </trans-unit>
        <trans-unit id="ae2f98a099fe5855c31126233e9c13641ee7fdba" translate="yes" xml:space="preserve">
          <source>Plan</source>
          <target state="translated">Plan</target>
        </trans-unit>
        <trans-unit id="253c3601a5c1772632a58221b654c54c8e50d5ad" translate="yes" xml:space="preserve">
          <source>Plan 9,</source>
          <target state="translated">计划9:</target>
        </trans-unit>
        <trans-unit id="385e0a23397d52d755976c0e7320a1e9bbbbf5ea" translate="yes" xml:space="preserve">
          <source>Plan events are fired off whenever a plan is declared, done testing is called, or a subtext completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24aa0fed2f1fce379a116b32ca6b7911453a9150" translate="yes" xml:space="preserve">
          <source>Plan handling lifted from Test::More. written by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b2cf4211ed36a7b6ec3c0f885611d65d2982aae" translate="yes" xml:space="preserve">
          <source>Plan result token.</source>
          <target state="translated">计划结果令牌。</target>
        </trans-unit>
        <trans-unit id="89a27c59b357dc17fcf14a17fcc79f90df885094" translate="yes" xml:space="preserve">
          <source>Plane 0</source>
          <target state="translated">平面0</target>
        </trans-unit>
        <trans-unit id="8be58825425054cbd0b59342becdd853b8548be0" translate="yes" xml:space="preserve">
          <source>Platform Specific</source>
          <target state="translated">特定平台</target>
        </trans-unit>
        <trans-unit id="e0bdb4c07f2772a4a54cf92695aa356c9a6579b0" translate="yes" xml:space="preserve">
          <source>Platform abstraction over &lt;code&gt;inet_ntop()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c39100db86a74639c0232bfd97c1daf53f3255" translate="yes" xml:space="preserve">
          <source>Platform and configuration independent &lt;code&gt;strtol&lt;/code&gt;. This expands to the appropriate &lt;code&gt;strotol&lt;/code&gt;-like function based on the platform and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fbe98f422743bc7e2a75d7c1f99951eb4321f74" translate="yes" xml:space="preserve">
          <source>Platform and configuration independent &lt;code&gt;strtoul&lt;/code&gt;. This expands to the appropriate &lt;code&gt;strotoul&lt;/code&gt;-like function based on the platform and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb666bc9b27013cda41fa8a2da0d844236374b6f" translate="yes" xml:space="preserve">
          <source>Platform-Specific</source>
          <target state="translated">Platform-Specific</target>
        </trans-unit>
        <trans-unit id="eef47a635b38ce4bb5160d8fbf43c327f07918d8" translate="yes" xml:space="preserve">
          <source>Platform-agnostic MM methods</source>
          <target state="translated">不受平台影响的MM方法</target>
        </trans-unit>
        <trans-unit id="efc0c78db0c6b708dec802259186b13ee8606a83" translate="yes" xml:space="preserve">
          <source>Platform-specific pieces of the build system also live in platform-specific directories like</source>
          <target state="translated">构建系统中特定平台的部分也存在于特定平台的目录中,如</target>
        </trans-unit>
        <trans-unit id="67155fe2d558d3be96473a78ebaa5f39e1acf3d8" translate="yes" xml:space="preserve">
          <source>Platforms that do not have &lt;code&gt;rdev&lt;/code&gt;, &lt;code&gt;blksize&lt;/code&gt;, or &lt;code&gt;blocks&lt;/code&gt; will return these as &lt;code&gt;''&lt;/code&gt;, so numeric comparison or manipulation of these fields may cause 'not numeric' warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2151168060825531d644ad2c9ef307ad23d45dd1" translate="yes" xml:space="preserve">
          <source>Platforms that do not have rdev, blksize, or blocks will return these as '', so numeric comparison or manipulation of these fields may cause 'not numeric' warnings.</source>
          <target state="translated">没有rdev、blksize或block的平台将以''返回,所以数字比较或操作这些字段可能会导致'非数字'警告。</target>
        </trans-unit>
        <trans-unit id="cb78dc6caa9da43d8d82895592406c2fb238b4d0" translate="yes" xml:space="preserve">
          <source>Playing Safe</source>
          <target state="translated">玩安全</target>
        </trans-unit>
        <trans-unit id="f5f50c6b28a2dbf428734248274d14fcc946d37a" translate="yes" xml:space="preserve">
          <source>Please add examples to what follows!</source>
          <target state="translated">请对以下内容进行补充说明!</target>
        </trans-unit>
        <trans-unit id="90db41980a6ddf9879d54f849f2452dacbc9ddd8" translate="yes" xml:space="preserve">
          <source>Please be aware that code in debugger listings may not look the same as your original source code. Line directives and external source filters can alter the code before Perl sees it, causing code to move from its original positions or take on entirely different forms.</source>
          <target state="translated">请注意,调试器列表中的代码可能与您的原始源代码看起来不一样。行指令和外部源码过滤器可能会在Perl看到之前改变代码,导致代码从原来的位置移动,或者采取完全不同的形式。</target>
        </trans-unit>
        <trans-unit id="6e35b70405206d942352bd9cec349bc8a7f2d0ac" translate="yes" xml:space="preserve">
          <source>Please check individual plugin documentation for more details.</source>
          <target state="translated">更多细节请查看各个插件文档。</target>
        </trans-unit>
        <trans-unit id="46a88c30ac9775bf9675292bcf8883102c284165" translate="yes" xml:space="preserve">
          <source>Please check the archive of the perl5-porters list (see below) and/or the bug tracking system before submitting a bug report. Often, you'll find that the bug has been reported already.</source>
          <target state="translated">在提交错误报告之前,请检查 perl5-porters 列表的存档(见下文)和/或错误跟踪系统。通常,你会发现这个错误已经被报告了。</target>
        </trans-unit>
        <trans-unit id="30d084e470b1305e613cce5c8a8f760ce12b4e60" translate="yes" xml:space="preserve">
          <source>Please e-mail us with problems, bug fixes, comments and complaints, although if you have compliments you should send them to Raphael. Please don't e-mail Raphael with problems, as he no longer works on Storable, and your message will be delayed while he forwards it to us.</source>
          <target state="translated">请把问题、错误修复、评论和抱怨用电子邮件发给我们,如果你有赞美之词,你应该把它们发给Raphael。请不要给Raphael发问题邮件,因为他已经不在Storable工作了,你的信息会被他转发给我们而被延迟。</target>
        </trans-unit>
        <trans-unit id="c431b3a19986ac53c575f9800468af7f81b46d87" translate="yes" xml:space="preserve">
          <source>Please feedback what is wrong</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c152b00259545a7771c21e247f5c5553ad4a6f" translate="yes" xml:space="preserve">
          <source>Please inform the module author if this is necessary to successfully install a module under 5.6 or later.</source>
          <target state="translated">如果要成功安装5.6或更高版本的模块,请告知模块作者。</target>
        </trans-unit>
        <trans-unit id="8b79f33567ebd39e312df677117f1f02c643059b" translate="yes" xml:space="preserve">
          <source>Please keep this list up-to-date by informing me about other items.</source>
          <target state="translated">如果有其他项目,请通知我,以保持这个清单的更新。</target>
        </trans-unit>
        <trans-unit id="d8e4357df6c51adf400f25dbaa777916223b07af" translate="yes" xml:space="preserve">
          <source>Please make sure the SDK version (i.e. the numbers right before '.sdk') matches your system's (in this case, Mac OS X 10.8 &quot;Mountain Lion&quot;), as it is possible to have more than one SDK installed. Also make sure the path exists in your system, and if it doesn't please make sure the SDK is properly installed, as it should come with the 'Command Line Tools' bundle mentioned above. Finally, if you have an older Mac OS X (10.6 &quot;Snow Leopard&quot; and below) running Xcode 4.2 or lower, the SDK path might be something like &lt;code&gt;'/Developer/SDKs/MacOSX10.3.9.sdk'&lt;/code&gt; .</source>
          <target state="translated">请确保SDK版本（即&amp;ldquo; .sdk&amp;rdquo;前的数字）与您的系统版本（在本例中为Mac OS X 10.8&amp;ldquo; Mountain Lion&amp;rdquo;）匹配，因为可能会安装多个SDK。另外，请确保该路径存在于您的系统中，如果没有，请确保正确安装了SDK，因为该SDK应该随上述&amp;ldquo;命令行工具&amp;rdquo;软件包一起提供。最后，如果您有运行Xcode 4.2或更低版本的较旧的Mac OS X（10.6&amp;ldquo; Snow Leopard&amp;rdquo;及以下版本），则SDK路径可能类似于 &lt;code&gt;'/Developer/SDKs/MacOSX10.3.9.sdk'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83b8ae2c8755481b5060b9d197a3f14fa03b0c26" translate="yes" xml:space="preserve">
          <source>Please make sure the SDK version (i.e. the numbers right before '.sdk') matches your system's (in this case, Mac OS X 10.8 &quot;Mountain Lion&quot;), as it is possible to have more than one SDK installed. Also make sure the path exists in your system, and if it doesn't please make sure the SDK is properly installed, as it should come with the 'Command Line Tools' bundle mentioned above. Finally, if you have an older Mac OS X (10.6 &quot;Snow Leopard&quot; and below) running Xcode 4.2 or lower, the SDK path might be something like &lt;code&gt;'/Developer/SDKs/MacOSX10.3.9.sdk'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93b9716fcd4491544e9d39d5e1bcaaba2e6587ef" translate="yes" xml:space="preserve">
          <source>Please make sure you add the perldelta entry to the right section within</source>
          <target state="translated">请确保您将perldelta条目添加到正确的部分中。</target>
        </trans-unit>
        <trans-unit id="4af848fa0de6bb5d98f95a63ab5b33868a64d534" translate="yes" xml:space="preserve">
          <source>Please make your issue title informative. &quot;a bug&quot; is not informative. Neither is &quot;perl crashes&quot; nor is &quot;HELP!!!&quot;. These don't help. A compact description of what's wrong is fine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a323093ed3237613762e5f23d911eb5beeb543" translate="yes" xml:space="preserve">
          <source>Please note a significant difference in the behavior of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; mode is that it does not force a VMS SEVERE_ERROR status on exit. The Unix exit values of 2 through 255 will be encoded in VMS status values with severity levels of SUCCESS. The Unix exit value of 1 will be encoded in a VMS status value with a severity level of ERROR. This is to be compatible with how the VMS C library encodes these values.</source>
          <target state="translated">请注意，在 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 模式下， &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 行为上的显着差异是，它不会在退出时强制VMS SEVERE_ERROR状态。Unix出口值2到255将以VMS状态值进行编码，严重性级别为SUCCESS。Unix出口值1将被编码为VMS状态值，其严重性级别为ERROR。这将与VMS C库如何编码这些值兼容。</target>
        </trans-unit>
        <trans-unit id="6c177938660fc8c8c17b75bc3c856520fd266ed0" translate="yes" xml:space="preserve">
          <source>Please note a significant difference in the behavior of &lt;code&gt;die&lt;/code&gt; in the &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; mode is that it does not force a VMS SEVERE_ERROR status on exit. The Unix exit values of 2 through 255 will be encoded in VMS status values with severity levels of SUCCESS. The Unix exit value of 1 will be encoded in a VMS status value with a severity level of ERROR. This is to be compatible with how the VMS C library encodes these values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb93428fa7988b6bd9d3d5b914c777174b9e347" translate="yes" xml:space="preserve">
          <source>Please note that ':constant' does not affect integer constants, nor binary nor hexadecimal constants. Use &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; or &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; to get this to work.</source>
          <target state="translated">请注意，'：constant'不影响整数常量，也不影响二进制或十六进制常量。使用&lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;或&lt;a href=&quot;bigint&quot;&gt;Math :: BigInt使它&lt;/a&gt;起作用。</target>
        </trans-unit>
        <trans-unit id="06ca6df37fb7aa8ce55441f1d546847190fefd39" translate="yes" xml:space="preserve">
          <source>Please note that ':constant' does not affect integer constants, nor binary nor hexadecimal constants. Use &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt; or &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; to get this to work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d144a30f04447f4891231cca52898c1f409adce" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local($tabstop)&lt;/a&gt;&lt;/code&gt; doesn't do the right thing and if you want to use &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; to override &lt;code&gt;$tabstop&lt;/code&gt; , you need to use &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local($Text::Tabs::tabstop)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local($tabstop)&lt;/a&gt;&lt;/code&gt; 做不正确的事情，如果要使用 &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 覆盖 &lt;code&gt;$tabstop&lt;/code&gt; ，则需要使用 &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local($Text::Tabs::tabstop)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9aa5bbfabef472a29774dca149c4460b4d54f432" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;local($tabstop)&lt;/code&gt; doesn't do the right thing and if you want to use &lt;code&gt;local&lt;/code&gt; to override &lt;code&gt;$tabstop&lt;/code&gt;, you need to use &lt;code&gt;local($Text::Tabs::tabstop)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633a4db7a1c782ae1b6e824e0fc9e69a016269b6" translate="yes" xml:space="preserve">
          <source>Please note that Math::BigFloat does &lt;b&gt;not&lt;/b&gt; use the denoted library itself, but it merely passes the lib argument to Math::BigInt. So, instead of the need to do:</source>
          <target state="translated">请注意，Math :: BigFloat本身&lt;b&gt;并不&lt;/b&gt;使用指定的库，而只是将lib参数传递给Math :: BigInt。因此，无需执行以下操作：</target>
        </trans-unit>
        <trans-unit id="a54801dfc85b8f9fc3dbd94457ccfddcfab12f10" translate="yes" xml:space="preserve">
          <source>Please note that POD has the notion of &quot;paragraphs&quot;: this is something starting</source>
          <target state="translated">请注意,POD有一个 &quot;段落 &quot;的概念:这是一个始于</target>
        </trans-unit>
        <trans-unit id="72307c57d87a56e5608808a2107363696283fed6" translate="yes" xml:space="preserve">
          <source>Please note that if multiple files are parsed for a single POD document (perhaps the result of some kind of &lt;code&gt;=include&lt;/code&gt; directive) this method is invoked for every file that is parsed. If you wish to perform certain cleanup actions once per document, then you should use &lt;b&gt;end_pod()&lt;/b&gt;.</source>
          <target state="translated">请注意，如果为单个POD文档解析了多个文件（也许是某种 &lt;code&gt;=include&lt;/code&gt; 指令的结果），则为每个解析的文件调用此方法。如果您希望每个文档执行一次特定的清理操作，则应使用&lt;b&gt;end_pod（）&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="10f71534786c6e41d011fbc9deff5549daf1fe0b" translate="yes" xml:space="preserve">
          <source>Please note that if the layer is created in the PerlIO::via:: namespace, it does &lt;b&gt;not&lt;/b&gt; have to be fully qualified. The PerlIO::via module will prefix the PerlIO::via:: namespace if the specified modulename does not exist as a fully qualified module name.</source>
          <target state="translated">请注意，如果该层中创建的PerlIO的::通过::命名空间，但这&lt;b&gt;并不&lt;/b&gt;必须是完全合格的。如果指定的模块名称不作为标准模块名称存在，则PerlIO :: via模块将在PerlIO :: via ::名称空间前添加前缀。</target>
        </trans-unit>
        <trans-unit id="713c4ec8dda734601e7b059dd41a997e18f77cd8" translate="yes" xml:space="preserve">
          <source>Please note that on Windows platforms colorized output also requires the Win32::Console::ANSI module.</source>
          <target state="translated">请注意,在Windows平台上,彩色化输出还需要Win32::Console::ANSI模块。</target>
        </trans-unit>
        <trans-unit id="b414f05f7085ad8d048ca6abb13a1f7ce979a37b" translate="yes" xml:space="preserve">
          <source>Please note that some of the trigonometric functions can break out from the &lt;b&gt;real axis&lt;/b&gt; into the &lt;b&gt;complex plane&lt;/b&gt;. For example &lt;code&gt;asin(2)&lt;/code&gt; has no definition for plain real numbers but it has definition for complex numbers.</source>
          <target state="translated">请注意，某些三角函数可能会从&lt;b&gt;实轴&lt;/b&gt;分解为&lt;b&gt;复平面&lt;/b&gt;。例如， &lt;code&gt;asin(2)&lt;/code&gt; 没有为普通实数定义，但为复数定义。</target>
        </trans-unit>
        <trans-unit id="2b7c92535c70d75e42791f8ddb48d4ce9ec51fc0" translate="yes" xml:space="preserve">
          <source>Please note that strings and floating point constants are not affected, so that</source>
          <target state="translated">请注意,字符串和浮点常量不受影响,所以</target>
        </trans-unit>
        <trans-unit id="c7e396ad592125eb642ceacdd629f60983df2bdf" translate="yes" xml:space="preserve">
          <source>Please note that the &lt;b&gt;preprocess_line()&lt;/b&gt; method is invoked</source>
          <target state="translated">请注意，调用了&lt;b&gt;preprocess_line（）&lt;/b&gt;方法</target>
        </trans-unit>
        <trans-unit id="5653094baeaeebceed5e5c79fc61bfba84826926" translate="yes" xml:space="preserve">
          <source>Please note that the first &lt;code&gt;good&lt;/code&gt; state must be an ancestor of the first &lt;code&gt;bad&lt;/code&gt; state. If you want to search for the commit that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865709c0c581d8169eede3efc9f220dad69fc01d" translate="yes" xml:space="preserve">
          <source>Please note that this is an area of recent development in Perl and that the interface described here is therefore still subject to change (and hopefully will have better documentation and more examples).</source>
          <target state="translated">请注意,这是Perl最近发展的一个领域,因此这里描述的界面仍然会有变化(希望会有更好的文档和更多的例子)。</target>
        </trans-unit>
        <trans-unit id="9d1dda7d4ff18b02aa0b290b258576653be091e9" translate="yes" xml:space="preserve">
          <source>Please note that this layer is implied when calling open() thus:</source>
          <target state="translated">请注意,当调用open()时,这一层是隐含的,因此。</target>
        </trans-unit>
        <trans-unit id="14bd27e9d494565b2545ea76d64ba9560ebda982" translate="yes" xml:space="preserve">
          <source>Please note that while this module works on Perl 5.6, it is no longer being routinely tested on 5.6 - the earliest Perl version being routinely tested, and expressly supported, is 5.8.1. However, patches to repair any breakage on 5.6 are still being accepted.</source>
          <target state="translated">请注意,虽然这个模块可以在 Perl 5.6 上运行,但它不再在 5.6 上进行例行测试--最早被例行测试并明确支持的 Perl 版本是 5.8.1。不过,我们仍然接受修复 5.6 版本上的任何故障的补丁。</target>
        </trans-unit>
        <trans-unit id="538443df0be8abcb2c7740f09bb5b4b6d88ac69f" translate="yes" xml:space="preserve">
          <source>Please note the following does not work as expected (prints nothing), since overloading of '..' is not yet possible in Perl (as of v5.8.0):</source>
          <target state="translated">请注意,下面的内容没有达到预期的效果(什么也不打印),因为在Perl中,'...'的重载是不可能的(从v5.8.0开始)。</target>
        </trans-unit>
        <trans-unit id="81118967e42641b9c6eb5f04cdbe62abe7740600" translate="yes" xml:space="preserve">
          <source>Please note: This mode of operation is no longer supported as of Perl v5.26.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc3f6a4a31c88f4e79077f99064bd4223a68148" translate="yes" xml:space="preserve">
          <source>Please note: in the general case, you're better off using &lt;a href=&quot;encode#decode&quot;&gt;&lt;code&gt;Encode::decode('UTF-8', $utf)&lt;/code&gt;&lt;/a&gt; to decode a UTF-8 encoded byte string to a Perl Unicode string, and &lt;a href=&quot;encode#encode&quot;&gt;&lt;code&gt;Encode::encode('UTF-8', $str)&lt;/code&gt;&lt;/a&gt; to encode a Perl Unicode string to UTF-8 bytes. These functions provide means of handling invalid byte sequences and generally have a friendlier interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a240f0a420b088c6642d6eafb7c3deb2f9e741be" translate="yes" xml:space="preserve">
          <source>Please note: in the general case, you're better off using Encode::decode_utf8 to decode a UTF-8 encoded byte string to a Perl Unicode string, and Encode::encode_utf8 to encode a Perl Unicode string to UTF-8 bytes. These functions provide means of handling invalid byte sequences and generally have a friendlier interface.</source>
          <target state="translated">请注意:在一般情况下,你最好使用Encode::decode_utf8将UTF-8编码的字节字符串解码为Perl Unicode字符串,而Encode::encode_utf8将Perl Unicode字符串编码为UTF-8字节。这些函数提供了处理无效字节序列的方法,并且通常具有更友好的接口。</target>
        </trans-unit>
        <trans-unit id="a968cbb027497bb1dd61f62478bee1c4fb7295eb" translate="yes" xml:space="preserve">
          <source>Please note: the two functions defined above are</source>
          <target state="translated">请注意:上面定义的两个函数是</target>
        </trans-unit>
        <trans-unit id="59a34246a11ef1f18ccb92fad013882849039fa3" translate="yes" xml:space="preserve">
          <source>Please read &lt;a href=&quot;#COPYRIGHT&quot;&gt;&quot;COPYRIGHT&quot;&lt;/a&gt; before using version 2.x or greater of Berkeley DB with DB_File.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e14b19aff89c4aad18c1b1f461b6bc9f9f18afb0" translate="yes" xml:space="preserve">
          <source>Please read &lt;a href=&quot;#COPYRIGHT&quot;&gt;COPYRIGHT&lt;/a&gt; before using version 2.x or greater of Berkeley DB with DB_File.</source>
          <target state="translated">在将2.x或更高版本的Berkeley DB与DB_File一起使用之前，请阅读&lt;a href=&quot;#COPYRIGHT&quot;&gt;COPYRIGHT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a49d7388a9b16b3144a078e3b5020dee8701b8c5" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;code&gt;Archive::Tar::File&lt;/code&gt; documentation on how to handle these objects.</source>
          <target state="translated">请参考 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 文档，了解如何处理这些对象。</target>
        </trans-unit>
        <trans-unit id="63dd61b82f101f26826b0ee19baaf07fb1de5b36" translate="yes" xml:space="preserve">
          <source>Please refer to the MSDN documentation of the CSIDL constants, currently available at:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba05ea79d06558fc847ddce39fd58ed9e3603b4" translate="yes" xml:space="preserve">
          <source>Please refer to your native fcntl(2), open(2), fseek(3), lseek(2) (equal to Perl's seek() and sysseek(), respectively), and chmod(2) documentation to see what constants are implemented in your system.</source>
          <target state="translated">请参考你的本机fcntl(2)、open(2)、fseek(3)、lseek(2)(分别等于Perl的seek()和sysseek())和chmod(2)文档,看看你的系统中实现了哪些常量。</target>
        </trans-unit>
        <trans-unit id="c84d853900a8b1e8461d42ec22c7bb0bc4e4555b" translate="yes" xml:space="preserve">
          <source>Please remember to send me an updated entry for the Module list!</source>
          <target state="translated">请记得给我发送模块列表的更新条目!</target>
        </trans-unit>
        <trans-unit id="9d4f61b83a34e9d17810bf3a6beba8149a3099ab" translate="yes" xml:space="preserve">
          <source>Please report all bugs on the RT queue, either via the web interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5ac378228cc627e576428f688749bb3cf44169" translate="yes" xml:space="preserve">
          <source>Please report all bugs on the RT queue:</source>
          <target state="translated">请在RT队列中报告所有BUG。</target>
        </trans-unit>
        <trans-unit id="cd1826396d92eaf26d7671cebd0646515ababb89" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests through the issue tracker at &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=Parse-CPAN-Meta&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=Parse-CPAN-Meta&lt;/a&gt;. You will be notified automatically of any progress on your issue.</source>
          <target state="translated">请通过问题跟踪器报告所有错误或功能请求，网址为&lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=Parse-CPAN-Meta&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=Parse-CPAN-Meta&lt;/a&gt;。系统会自动将您的问题进展情况通知您。</target>
        </trans-unit>
        <trans-unit id="f29e539c9949d7fd976fcf0ef31e3d520dfef64c" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests through the issue tracker at &lt;a href=&quot;https://github.com/Perl-Toolchain-Gang/CPAN-Meta-Requirements/issues&quot;&gt;https://github.com/Perl-Toolchain-Gang/CPAN-Meta-Requirements/issues&lt;/a&gt;. You will be notified automatically of any progress on your issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e10dad34d98d968a9e79abbac903596e6421800b" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests through the issue tracker at &lt;a href=&quot;https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues&quot;&gt;https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues&lt;/a&gt;. You will be notified automatically of any progress on your issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95a04dfd4c1fc483cefbbd64e9cf7d0f5a2a01dc" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests through the issue tracker at &lt;a href=&quot;https://github.com/Perl-Toolchain-Gang/Perl-OSType/issues&quot;&gt;https://github.com/Perl-Toolchain-Gang/Perl-OSType/issues&lt;/a&gt;. You will be notified automatically of any progress on your issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3e9326f48a70cd35e62a3e7c3c1b10a005c4e2" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests through the issue tracker at &lt;a href=&quot;https://github.com/chansen/p5-http-tiny/issues&quot;&gt;https://github.com/chansen/p5-http-tiny/issues&lt;/a&gt;. You will be notified automatically of any progress on your issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e910ef38da12f1e82d477c66613f898afde850" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests through the issue tracker at L</source>
          <target state="translated">请通过问题跟踪器报告任何错误或功能请求,在L</target>
        </trans-unit>
        <trans-unit id="bb7ffcd32fde8fcb70ebf33b96ca410b8c21fd4d" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-math-bigint at rt.cpan.org&lt;/code&gt; , or through the web interface at &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&lt;/a&gt; (requires login). We will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="translated">请将任何错误或功能请求报告给 &lt;code&gt;bug-math-bigint at rt.cpan.org&lt;/code&gt; 上的bug-math-bigint，或者通过&lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt上&lt;/a&gt;的网络界面（需要登录） ）。我们会收到通知，然后在我进行更改时会自动通知您有关错误的进展。</target>
        </trans-unit>
        <trans-unit id="7c1ec7a85f06c97f5ca00ceba49cd056337d425f" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-math-bigint at rt.cpan.org&lt;/code&gt;, or through the web interface at &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&lt;/a&gt; (requires login). We will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4855ec4202fef3ce386c7a181d6e6a5bd1e45ec3" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-math-bigint at rt.cpan.org&lt;/code&gt;, or through the web interface at &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=bignum&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=bignum&lt;/a&gt; (requires login). We will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1e163ae4819860c0befb05416f4880530b21f6" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-math-bigint-fastcalc at rt.cpan.org&lt;/code&gt;, or through the web interface at &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt-FastCalc&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt-FastCalc&lt;/a&gt; (requires login). We will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fedca4eaf22650d4f30ff44ea5ea07caadc39831" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-math-bigrat at rt.cpan.org&lt;/code&gt; , or through the web interface at &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat&lt;/a&gt; (requires login). We will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="translated">请将任何错误或功能请求报告给 &lt;code&gt;bug-math-bigrat at rt.cpan.org&lt;/code&gt; ，或通过&lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat上&lt;/a&gt;的网络界面（需要登录） ）。我们会收到通知，然后在我进行更改时会自动通知您有关错误的进展。</target>
        </trans-unit>
        <trans-unit id="44b2b1389efa7dcc1194b0bee5209d80e2cd9879" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-math-bigrat at rt.cpan.org&lt;/code&gt;, or through the web interface at &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat&lt;/a&gt; (requires login). We will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e63d77d099b0075753f056790cc8a0a16061cd4" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-sys-syslog (at) rt.cpan.org&lt;/code&gt;, or through the web interface at &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=Sys-Syslog&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=Sys-Syslog&lt;/a&gt;. I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="translated">请将任何错误或功能请求报告给 &lt;code&gt;bug-sys-syslog (at) rt.cpan.org&lt;/code&gt; 上的bug-sys-syslog或通过&lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=Sys-Syslog&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=Sys- Syslog&lt;/a&gt;。我们会收到通知，然后在我进行更改时会自动通知您Bug的进展。</target>
        </trans-unit>
        <trans-unit id="ae680a8d27e7e30eaabedd56fcc07aec11c11d49" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-test-harness at rt.cpan.org&lt;/code&gt; , or through the web interface at &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&lt;/a&gt;. I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="translated">请将任何错误或功能请求报告给 &lt;code&gt;bug-test-harness at rt.cpan.org&lt;/code&gt; 上的bug-test-harness，或者通过&lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness上&lt;/a&gt;的网络界面进行报告。我们会收到通知，然后在我进行更改时会自动通知您Bug的进展。</target>
        </trans-unit>
        <trans-unit id="341b6e60f3036ad2f760be88739c597fd2cbae0b" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-test-harness at rt.cpan.org&lt;/code&gt;, or through the web interface at &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&lt;/a&gt;. I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667d7074054f4f754df9eeb8e155a22d30cbaad3" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-test-harness@rt.cpan.org&lt;/code&gt; , or through the web interface at &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&lt;/a&gt;. We will be notified, and then you'll automatically be notified of progress on your bug as we make changes.</source>
          <target state="translated">请将任何错误或功能请求报告给 &lt;code&gt;bug-test-harness@rt.cpan.org&lt;/code&gt; 或通过Web界面&lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness进行报告&lt;/a&gt;。我们会收到通知，然后在我们进行更改时会自动通知您有关错误的进展。</target>
        </trans-unit>
        <trans-unit id="f074316234c4859a301df22686a28d5f2ff92bd3" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-test-harness@rt.cpan.org&lt;/code&gt;, or through the web interface at &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&lt;/a&gt;. We will be notified, and then you'll automatically be notified of progress on your bug as we make changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c61f91a0c5559a90a0233170a166239a41b69c9" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests via the perlbug(1) utility.</source>
          <target state="translated">请通过 perlbug(1)工具报告任何错误或功能请求。</target>
        </trans-unit>
        <trans-unit id="da1690d7c5d6c84d4dfa27a5c4d0acb738c84780" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature using the CPAN Request Tracker. Bugs can be submitted through the web interface at &lt;a href=&quot;http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta&quot;&gt;http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538631f2230a63e6ce1111d15fa806e9dbfb590c" translate="yes" xml:space="preserve">
          <source>Please report any errors, updates, or suggestions to</source>
          <target state="translated">如果有任何错误、更新或建议,请报告给我们。</target>
        </trans-unit>
        <trans-unit id="b2fed3d97135253678acd7ef66f99b903e366619" translate="yes" xml:space="preserve">
          <source>Please report any errors, updates, or suggestions to &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fdf7d53b3d96ceb75d6b632d2b4d517d6b8a6a5" translate="yes" xml:space="preserve">
          <source>Please report any other failures as described under &lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;&quot;BUGS AND CAVEATS&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="535c1e5f2236649cfc5cd24875aa7a7f5d8bb2dc" translate="yes" xml:space="preserve">
          <source>Please report any other failures as described under &lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;BUGS AND CAVEATS&lt;/a&gt;.</source>
          <target state="translated">请按照&lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;BUGGS和CAVEATS中的说明&lt;/a&gt;报告任何其他失败。</target>
        </trans-unit>
        <trans-unit id="5ecba84d92ce32aa62a862b9a6870d59796672d9" translate="yes" xml:space="preserve">
          <source>Please report bugs in this version of perl to andy@broad.ology.org.uk in the first instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588e8512c3a527a86acc4f15dfb514051940faad" translate="yes" xml:space="preserve">
          <source>Please report bugs on a specific behavior of this module to RT or GitHub issues (preferred):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76aa5507d30b205fb08850d3924328ca2edc4fec" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-file-fetch@rt.cpan.org&amp;lt;gt&amp;gt;.</source>
          <target state="translated">请向&amp;lt;bug-file-fetch@rt.cpan.org &amp;lt;gt&amp;gt;报告错误或其他问题。</target>
        </trans-unit>
        <trans-unit id="5af156ec0cb2830a387a464db78f0177138c46c7" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-ipc-cmd@rt.cpan.org&amp;gt;.</source>
          <target state="translated">请向&amp;lt;bug-ipc-cmd@rt.cpan.org&amp;gt;报告错误或其他问题。</target>
        </trans-unit>
        <trans-unit id="89fa61346f2ac4a97f3b1820d45a05f5cf6df3b4" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-module-load-conditional@rt.cpan.org&amp;gt;.</source>
          <target state="translated">请将错误或其他问题报告给&amp;lt;bug-module-load-conditional@rt.cpan.org&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="74e57493a005451600337c2cd20b19335784389b" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-module-load@rt.cpan.org&amp;lt;gt&amp;gt;.</source>
          <target state="translated">请向&amp;lt;bug-module-load@rt.cpan.org &amp;lt;gt&amp;gt;报告错误或其他问题。</target>
        </trans-unit>
        <trans-unit id="aa48dcb88c79a4bb30f628a4e59b5790599238be" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-module-loaded@rt.cpan.org&amp;lt;gt&amp;gt;.</source>
          <target state="translated">请向&amp;lt;bug-module-loaded@rt.cpan.org &amp;lt;gt&amp;gt;报告错误或其他问题。</target>
        </trans-unit>
        <trans-unit id="ea6595769a4f7e77e760cd27c4315806767a46e6" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-params-check@rt.cpan.org&amp;gt;.</source>
          <target state="translated">请将错误或其他问题报告给&amp;lt;bug-params-check@rt.cpan.org&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="e2b012cfb62b0833f158983eb6a125eb9f62cad3" translate="yes" xml:space="preserve">
          <source>Please report bugs using &lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org&lt;/a&gt;.</source>
          <target state="translated">请使用&lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org&lt;/a&gt;报告错误。</target>
        </trans-unit>
        <trans-unit id="9b0a18ec15ee7f8f9cfa33de7bf50e0926919e26" translate="yes" xml:space="preserve">
          <source>Please report bugs via &lt;a href=&quot;http://rt.cpan.org/&quot;&gt;http://rt.cpan.org/&lt;/a&gt;</source>
          <target state="translated">请通过&lt;a href=&quot;http://rt.cpan.org/&quot;&gt;http://rt.cpan.org/&lt;/a&gt;报告错误</target>
        </trans-unit>
        <trans-unit id="e4417cf7026fd3b1d558ce74b166a72450fc9e3b" translate="yes" xml:space="preserve">
          <source>Please report bugs via the GitHub Issue Tracker at &lt;a href=&quot;https://github.com/pjf/autodie/issues&quot;&gt;https://github.com/pjf/autodie/issues&lt;/a&gt; or via the CPAN Request Tracker at &lt;a href=&quot;https://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie&quot;&gt;https://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie&lt;/a&gt;.</source>
          <target state="translated">请报告通过GitHub的问题跟踪错误&lt;a href=&quot;https://github.com/pjf/autodie/issues&quot;&gt;https://github.com/pjf/autodie/issues&lt;/a&gt;或通过CPAN请求跟踪器在&lt;a href=&quot;https://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie&quot;&gt;https://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8aab4e1e45b67fc9f30850be9456ba3f03a04a5a" translate="yes" xml:space="preserve">
          <source>Please report detailed descriptions of any problems and solutions that you may find at &amp;lt;&lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;&amp;gt;, along with the output produced by &lt;code&gt;perl -V&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79a854cdb114b54082c119689356c304d2fefdd" translate="yes" xml:space="preserve">
          <source>Please reports bugs to &amp;lt;bug-archive-tar@rt.cpan.org&amp;gt;.</source>
          <target state="translated">请将错误报告给&amp;lt;bug-archive-tar@rt.cpan.org&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="d4341b4d3e627a1778c8a45b586f98e9adc4ce3b" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;#parseopts()&quot;&gt;parseopts()&lt;/a&gt; for a complete description of the interface for the setting and unsetting of parse-options.</source>
          <target state="translated">请参阅&lt;a href=&quot;#parseopts()&quot;&gt;parseopts（）&lt;/a&gt;获取有关设置和取消设置parse-options接口的完整说明。</target>
        </trans-unit>
        <trans-unit id="e7f51c19c32ff7fa52bd5ea5cccc3312c8f093f3" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;../parser#SUBCLASSING&quot;&gt;SUBCLASSING in TAP::Parser&lt;/a&gt; for a subclassing overview.</source>
          <target state="translated">有关子类概述，请参见&lt;a href=&quot;../parser#SUBCLASSING&quot;&gt;TAP :: Parser&lt;/a&gt;中的&amp;ldquo;子类&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c86f144c936b547d1a8fcab0618c4dcef4646042" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;App::Prove#PLUGINS&quot;&gt;&quot;PLUGINS&quot; in App::Prove&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e91d7e19846bba266909a5e73288f2011d3c67a" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;TAP::Parser#SUBCLASSING&quot;&gt;&quot;SUBCLASSING&quot; in TAP::Parser&lt;/a&gt; for a subclassing overview, and any of the subclasses that ship with this module as an example. What follows is a quick overview.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26bbee5cc38dd221caeb15c8d0b9944048cfb0e3" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;TAP::Parser#SUBCLASSING&quot;&gt;&quot;SUBCLASSING&quot; in TAP::Parser&lt;/a&gt; for a subclassing overview.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c46841005cacd4d19b8897f62c9bcdf00ba021" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;Test2::API::Context#CRITICAL-DETAILS&quot;&gt;&quot;CRITICAL DETAILS&quot; in Test2::API::Context&lt;/a&gt; for important rules about what you can and cannot do with a context once it is obtained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b0d65ae346953461c6709072b8e34d6894faf9a" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;Test::use::ok&quot;&gt;Test::use::ok&lt;/a&gt; for the full description.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e0a1481bb7e7875074f0faee7691f33bd29319" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;app/prove#PLUGINS&quot;&gt;PLUGINS in App::Prove&lt;/a&gt;.</source>
          <target state="translated">请&lt;a href=&quot;app/prove#PLUGINS&quot;&gt;在App :: Prove中&lt;/a&gt;查看PLUGINS。</target>
        </trans-unit>
        <trans-unit id="989a39f3d25282b53431795da6fd8624c0e76184" translate="yes" xml:space="preserve">
          <source>Please see respective module documentation for further details.</source>
          <target state="translated">更多细节请参见各模块文档。</target>
        </trans-unit>
        <trans-unit id="a30c68c43e99e52ddbaa4a59fdceb1dd51800da4" translate="yes" xml:space="preserve">
          <source>Please see the &quot;See Also&quot; references for a thorough explanation of how to correctly use language tags.</source>
          <target state="translated">关于如何正确使用语言标签,请参见 &quot;另见 &quot;参考资料。</target>
        </trans-unit>
        <trans-unit id="5eb0ce8841e107e9f0e205e51d26edff17acc24e" translate="yes" xml:space="preserve">
          <source>Please see the &lt;a href=&quot;ExtUtils::Mksymlists&quot;&gt;ExtUtils::Mksymlists&lt;/a&gt; documentation for more information about the DL_FUNCS, DL_VARS and FUNCLIST attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81fd05bcd06561fbf4acc7c17c9823d8c0d4b322" translate="yes" xml:space="preserve">
          <source>Please see the &lt;a href=&quot;mksymlists&quot;&gt;ExtUtils::Mksymlists&lt;/a&gt; documentation for more information about the DL_FUNCS, DL_VARS and FUNCLIST attributes.</source>
          <target state="translated">请参阅&lt;a href=&quot;mksymlists&quot;&gt;ExtUtils :: Mksymlists&lt;/a&gt;文档以获取有关DL_FUNCS，DL_VARS和FUNCLIST属性的更多信息。</target>
        </trans-unit>
        <trans-unit id="2c2e515c2102fd49c64f216a02d32d621813ef11" translate="yes" xml:space="preserve">
          <source>Please see the README file in distribution.</source>
          <target state="translated">请参阅发行版中的 README 文件。</target>
        </trans-unit>
        <trans-unit id="628ecfdf942d40232f5db37e81fc0010f48d3a4b" translate="yes" xml:space="preserve">
          <source>Please see the documentation for &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; for the details of what these parameters do.</source>
          <target state="translated">有关这些参数的详细信息，请参见 &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="f40ec33c90f01c635cb2192f1f99978f9b263bcc" translate="yes" xml:space="preserve">
          <source>Please see the documentation in &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a5dc2d5751ee8cce246c66908a7b4ec4c62daf7" translate="yes" xml:space="preserve">
          <source>Please see the documentation in &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for further details.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;bigint&quot;&gt;Math :: BigInt中&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="05004fbce196a7e0bf2a95059afe8e5ce82a91f3" translate="yes" xml:space="preserve">
          <source>Please see the documentation in &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;bigint&quot;&gt;Math :: BigInt中&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="e4b33a5a89e332b7c7e9bac36dcb4a5524d98fc6" translate="yes" xml:space="preserve">
          <source>Please see the file README in the Perl source distribution for details of the Perl license.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0151ca432ab861ca7ca145a28b62d6ba2feb6f2" translate="yes" xml:space="preserve">
          <source>Please see the git repository for revision history.</source>
          <target state="translated">请查看git仓库的修订历史。</target>
        </trans-unit>
        <trans-unit id="8996e7dee5730a1986500bc16557a0d869c75480" translate="yes" xml:space="preserve">
          <source>Please see the section about &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;&quot;ACCURACY and PRECISION&quot;&lt;/a&gt; for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3073b87722e3ef7fb20a17229c346b64eb30ea5d" translate="yes" xml:space="preserve">
          <source>Please see the section about &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;ACCURACY and PRECISION&lt;/a&gt; for further details.</source>
          <target state="translated">有关更多详细信息，请参见&amp;ldquo; &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;精度和精度&lt;/a&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="221b6d6c2e3933bcc937bf432e64ccb1ebb6a488" translate="yes" xml:space="preserve">
          <source>Please send detailed descriptions of any problems and solutions that you may find to &amp;lt;</source>
          <target state="translated">请将您可能发现的任何问题和解决方案的详细说明发送给&amp;lt;</target>
        </trans-unit>
        <trans-unit id="ef68d6f3b0d5f9f183ddfa8c1c49597c47fc04d3" translate="yes" xml:space="preserve">
          <source>Please set your policy to one of the three values.</source>
          <target state="translated">请将您的政策设置为三个值之一。</target>
        </trans-unit>
        <trans-unit id="e5456a0ea6c8660091c6463eca153f6f42857178" translate="yes" xml:space="preserve">
          <source>Please submit bug reports and patches to perlbug@perl.org.</source>
          <target state="translated">请将错误报告和补丁提交到 perlbug@perl.org。</target>
        </trans-unit>
        <trans-unit id="1670aa48b29f76eeff5e31510ce8161f83f94922" translate="yes" xml:space="preserve">
          <source>Please submit bugs to the CPAN RT system at &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Time-Local&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Time-Local&lt;/a&gt; or via email at bug-time-local@rt.cpan.org.</source>
          <target state="translated">请将错误提交到CPAN RT系统，网址为&lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Time-Local&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Time-Local&lt;/a&gt;或通过电子邮件发送至bug-time-local@rt.cpan.org。</target>
        </trans-unit>
        <trans-unit id="027daf21662ca08eda2a7bd48d5158b216706744" translate="yes" xml:space="preserve">
          <source>Please try and supply some documentation if you add functions to the Perl core.</source>
          <target state="translated">如果你在Perl核心中添加函数,请尝试提供一些文档。</target>
        </trans-unit>
        <trans-unit id="f0a1af1032147376b66464947571d72cef968e98" translate="yes" xml:space="preserve">
          <source>Please use &lt;a href=&quot;https://github.com/perl-pod/pod-simple/issues/new&quot;&gt;https://github.com/perl-pod/pod-simple/issues/new&lt;/a&gt; to file a bug report.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f714e6d31a681125e28768dfea867640b126ff8d" translate="yes" xml:space="preserve">
          <source>Please, unless you're hacking the internals, or debugging weirdness, don't think about the UTF8 flag at all. That means that you very probably shouldn't use &lt;code&gt;is_utf8&lt;/code&gt; , &lt;code&gt;_utf8_on&lt;/code&gt; or &lt;code&gt;_utf8_off&lt;/code&gt; at all.</source>
          <target state="translated">拜托，除非您要破解内部程序或调试怪异现象，否则请不要考虑UTF8标志。这意味着您很可能根本不应该使用 &lt;code&gt;is_utf8&lt;/code&gt; ， &lt;code&gt;_utf8_on&lt;/code&gt; 或 &lt;code&gt;_utf8_off&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1202c034ad5e532f9a82495be81ce4863a3e9945" translate="yes" xml:space="preserve">
          <source>Please, unless you're hacking the internals, or debugging weirdness, don't think about the UTF8 flag at all. That means that you very probably shouldn't use &lt;code&gt;is_utf8&lt;/code&gt;, &lt;code&gt;_utf8_on&lt;/code&gt; or &lt;code&gt;_utf8_off&lt;/code&gt; at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f29d232cd4bc7b00f36ebc0732290db154e722" translate="yes" xml:space="preserve">
          <source>Plug-in module for automatic expiration of memoized values</source>
          <target state="translated">备忘值自动失效的插件模块。</target>
        </trans-unit>
        <trans-unit id="9edf1040d2bfeaaf802cb8b27a5c7e4a201ff06a" translate="yes" xml:space="preserve">
          <source>Pluggable runops</source>
          <target state="translated">可插拔式运行</target>
        </trans-unit>
        <trans-unit id="5697803d10d7bf281aadc37a72c18ea36adecd64" translate="yes" xml:space="preserve">
          <source>Plugin support ***EXPERIMENTAL***</source>
          <target state="translated">插件支持 ***经验****</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="76ccce846df3b4c3ab1a6f65fc358f4fc11db43e" translate="yes" xml:space="preserve">
          <source>Plugins are objects that implement any of currently eight methods:</source>
          <target state="translated">插件是实现当前八种方法中任何一种方法的对象。</target>
        </trans-unit>
        <trans-unit id="1de58880797e013d954730b62488aa821afcb4c8" translate="yes" xml:space="preserve">
          <source>Plugins can be loaded using the &lt;code&gt;-P&lt;i&gt;plugin&lt;/i&gt;&lt;/code&gt; syntax, eg:</source>
          <target state="translated">插件可以使用所述被加载 &lt;code&gt;-P&lt;i&gt;plugin&lt;/i&gt;&lt;/code&gt; 的语法，例如：</target>
        </trans-unit>
        <trans-unit id="71494d8d1e8a55e1a56d948d21ff0111c0e58ab0" translate="yes" xml:space="preserve">
          <source>Pod Commands</source>
          <target state="translated">花苞命令</target>
        </trans-unit>
        <trans-unit id="3d5386faff713ed9d1073c9258ceccd049f3d049" translate="yes" xml:space="preserve">
          <source>Pod Definitions</source>
          <target state="translated">花苞定义</target>
        </trans-unit>
        <trans-unit id="4ae454b70ee2c5e321bfbc301f9d36222768b986" translate="yes" xml:space="preserve">
          <source>Pod Formatting Codes</source>
          <target state="translated">Pod格式化代码</target>
        </trans-unit>
        <trans-unit id="47918185382f833db1e30bfcfbc001132c7cba90" translate="yes" xml:space="preserve">
          <source>Pod content is contained in &lt;b&gt;Pod blocks&lt;/b&gt;. A Pod block starts with a line that matches &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt;, and continues up to the next line that matches &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=cut/&lt;/a&gt;&lt;/code&gt; or up to the end of the file if there is no &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=cut/&lt;/a&gt;&lt;/code&gt; line.</source>
          <target state="translated">Pod内容包含在&lt;b&gt;Pod块中&lt;/b&gt;。 Pod块从与 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; 匹配的行开始，一直到与 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=cut/&lt;/a&gt;&lt;/code&gt; 匹配的下一行，或者直到有文件末尾为止没有 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=cut/&lt;/a&gt;&lt;/code&gt; 行。</target>
        </trans-unit>
        <trans-unit id="02c2e8126c233f706e9cd59a2533c9f50c98bc10" translate="yes" xml:space="preserve">
          <source>Pod content is contained in &lt;b&gt;Pod blocks&lt;/b&gt;. A Pod block starts with a line that matches &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt;, and continues up to the next line that matches &lt;code&gt;m/\A=cut/&lt;/code&gt; or up to the end of the file if there is no &lt;code&gt;m/\A=cut/&lt;/code&gt; line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ddb3d03f7f589056100b138c86215515b2e453" translate="yes" xml:space="preserve">
          <source>Pod formatters</source>
          <target state="translated">Pod格式化器</target>
        </trans-unit>
        <trans-unit id="d66a0d27d4c73edcb27d25e097424b0951626f0c" translate="yes" xml:space="preserve">
          <source>Pod formatters can use Pod::Simple to parse Pod documents and render them into plain text, HTML, or any number of other formats. Typically, such formatters will be subclasses of Pod::Simple, and so they will inherit its methods, like &lt;code&gt;parse_file&lt;/code&gt; .</source>
          <target state="translated">Pod格式化程序可以使用Pod :: Simple解析Pod文档并将其呈现为纯文本，HTML或任何其他多种格式。通常，此类格式化程序将是Pod :: Simple的子类，因此它们将继承其方法，例如 &lt;code&gt;parse_file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="746daa555fbd186d7d4c6882e67f7c32f9c561ea" translate="yes" xml:space="preserve">
          <source>Pod formatters can use Pod::Simple to parse Pod documents and render them into plain text, HTML, or any number of other formats. Typically, such formatters will be subclasses of Pod::Simple, and so they will inherit its methods, like &lt;code&gt;parse_file&lt;/code&gt;. But note that Pod::Simple doesn't understand and properly parse Perl itself, so if you have a file which contains a Perl program that has a multi-line quoted string which has lines that look like pod, Pod::Simple will treat them as pod. This can be avoided if the file makes these into indented here documents instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44803dfacbed653092718af27817d667ae913774" translate="yes" xml:space="preserve">
          <source>Pod formatters should make reasonable efforts to keep words of Perl code from being broken across lines. For example, &quot;Foo::Bar&quot; in some formatting systems is seen as eligible for being broken across lines as &quot;Foo::&quot; newline &quot;Bar&quot; or even &quot;Foo::-&quot; newline &quot;Bar&quot;. This should be avoided where possible, either by disabling all line-breaking in mid-word, or by wrapping particular words with internal punctuation in &quot;don't break this across lines&quot; codes (which in some formats may not be a single code, but might be a matter of inserting non-breaking zero-width spaces between every pair of characters in a word.)</source>
          <target state="translated">花苞格式化人员应合理地努力使Perl代码中的单词不被跨行打断。例如,在某些格式化系统中,&quot;Foo::Bar &quot;被认为可以作为 &quot;Foo::&quot;换行 &quot;Bar&quot;,甚至是 &quot;Foo::-&quot;换行 &quot;Bar &quot;来断行。在可能的情况下,应该避免这种情况的发生,要么在单词中禁用所有的断行,要么将带有内部标点符号的特定单词包装成 &quot;不要跨行断行 &quot;代码(在某些格式中,这可能不是一个单一的代码,而可能是在单词中的每一对字符之间插入不断行的零宽度空格)。</target>
        </trans-unit>
        <trans-unit id="d30f3aa798097994ab967bc039b02fb5704336d9" translate="yes" xml:space="preserve">
          <source>Pod formatters should tolerate lines in verbatim blocks that are of any length, even if that means having to break them (possibly several times, for very long lines) to avoid text running off the side of the page. Pod formatters may warn of such line-breaking. Such warnings are particularly appropriate for lines are over 100 characters long, which are usually not intentional.</source>
          <target state="translated">花苞格式化人员应该容忍任何长度的逐字块中的行,即使这意味着必须打断它们(对于非常长的行,可能要打断好几次),以避免文本跑出页面的一侧。花苞格式化器可能会对这种断行提出警告。这种警告特别适用于长度超过100个字符的行,这通常不是故意的。</target>
        </trans-unit>
        <trans-unit id="9e45409759a4a45d8ec12bca70ef02e438fd2271" translate="yes" xml:space="preserve">
          <source>Pod formatters, where feasible, are advised to avoid splitting short verbatim paragraphs (under twelve lines, say) across pages.</source>
          <target state="translated">建议花苞格式化人员在可行的情况下,避免将短小的逐字段落(比如说,12行以下)跨页分割。</target>
        </trans-unit>
        <trans-unit id="6b57013c8fdcb737d69c938a9f663099a631cacb" translate="yes" xml:space="preserve">
          <source>Pod is a simple-to-use markup language used for writing documentation for Perl, Perl programs, and Perl modules.</source>
          <target state="translated">Pod是一种简单易用的标记语言,用于编写Perl、Perl程序和Perl模块的文档。</target>
        </trans-unit>
        <trans-unit id="0f6434053591d377adc29bce6462c4e2195b1c17" translate="yes" xml:space="preserve">
          <source>Pod is embedded in files, typically Perl source files, although you can write a file that's nothing but Pod.</source>
          <target state="translated">Pod被嵌入到文件中,通常是Perl的源文件,尽管你可以写一个除了Pod之外什么都没有的文件。</target>
        </trans-unit>
        <trans-unit id="a317c10bc80719752bdbc59669224f21caf94cb6" translate="yes" xml:space="preserve">
          <source>Pod markup consists of three basic kinds of paragraphs: &lt;a href=&quot;#Ordinary-Paragraph&quot;&gt;ordinary&lt;/a&gt;, &lt;a href=&quot;#Verbatim-Paragraph&quot;&gt;verbatim&lt;/a&gt;, and &lt;a href=&quot;#Command-Paragraph&quot;&gt;command&lt;/a&gt;.</source>
          <target state="translated">Pod标记包含三种基本的段落：&lt;a href=&quot;#Ordinary-Paragraph&quot;&gt;普通&lt;/a&gt;，&lt;a href=&quot;#Verbatim-Paragraph&quot;&gt;逐字&lt;/a&gt;和&lt;a href=&quot;#Command-Paragraph&quot;&gt;命令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3729d4ffa4c690e28dd8755c4c73a027d3ed32e0" translate="yes" xml:space="preserve">
          <source>Pod now defaults to text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4100fa00f1a6ff1bc2589ecc13660c9f209d6e8" translate="yes" xml:space="preserve">
          <source>Pod parsers</source>
          <target state="translated">Pod解析器</target>
        </trans-unit>
        <trans-unit id="826ed58998f5bc33125341c4f36a3a43574102c1" translate="yes" xml:space="preserve">
          <source>Pod parsers may also note additional attributes including:</source>
          <target state="translated">花苞解析器还可以注意到其他属性,包括:</target>
        </trans-unit>
        <trans-unit id="78ce92125382b9b17f3f27b241298cd0d948dfa7" translate="yes" xml:space="preserve">
          <source>Pod parsers must also support the XHTML codes &quot;E&amp;lt;quot&amp;gt;&quot; for character 34 (doublequote, &quot;), &quot;E&amp;lt;amp&amp;gt;&quot; for character 38 (ampersand, &amp;amp;), and &quot;E&amp;lt;apos&amp;gt;&quot; for character 39 (apostrophe, ').</source>
          <target state="translated">Pod解析器还必须支持XHTML代码&amp;ldquo; E &amp;lt;&amp;rdquo;&amp;gt;表示字符34（双引号，&amp;ldquo;）&amp;rdquo;，&amp;ldquo; E &amp;lt;amp&amp;gt;&amp;rdquo;表示字符38（&amp;ldquo;＆&amp;rdquo;号，和），以及&amp;ldquo; E &amp;lt;&amp;rdquo;表示字符39（撇号）。 ，'）。</target>
        </trans-unit>
        <trans-unit id="d16107ce92c757a467355de94f2c9937bd3ef851" translate="yes" xml:space="preserve">
          <source>Pod parsers must recognize</source>
          <target state="translated">花苞解析器必须识别</target>
        </trans-unit>
        <trans-unit id="6e60f4cd73d8a373a60400a3a94686dfb7543ae7" translate="yes" xml:space="preserve">
          <source>Pod parsers must treat a line with only spaces and/or tabs on it as a &quot;blank line&quot; such as separates paragraphs. (Some older parsers recognized only two adjacent newlines as a &quot;blank line&quot; but would not recognize a newline, a space, and a newline, as a blank line. This is noncompliant behavior.)</source>
          <target state="translated">花苞解析器必须将仅有空格和/或制表符的行视为 &quot;空行&quot;,如分隔段落。(一些旧的解析器只将两个相邻的新行识别为 &quot;空行&quot;,但不会将一个新行、一个空格和一个新行识别为空行。这是不合规的行为。)</target>
        </trans-unit>
        <trans-unit id="0c42bd4ec3460b4dc34871ff713c3f41e0e29ace" translate="yes" xml:space="preserve">
          <source>Pod parsers should accept input lines that are of any length.</source>
          <target state="translated">Pod解析器应该接受任何长度的输入行。</target>
        </trans-unit>
        <trans-unit id="1bf89edbc56bd1aa97ad7cab04b88498a0a483ec" translate="yes" xml:space="preserve">
          <source>Pod parsers should not, by default, try to coerce apostrophe (') and quote (&quot;) into smart quotes (little 9's, 66's, 99's, etc), nor try to turn backtick (`) into anything else but a single backtick character (distinct from an open quote character!), nor &quot;--&quot; into anything but two minus signs. They</source>
          <target state="translated">默认情况下,花苞解析器不应该试图将撇号(')和引号(&quot;)变成智能引号(小9、66、99等),也不应该试图将回车键(`)变成除了单个回车键字符(有别于开放的引号字符!)以外的任何东西,也不应该将&quot;--&quot;变成除了两个减号以外的任何东西。他们</target>
        </trans-unit>
        <trans-unit id="6e79c8f8c8738ed0d3f21bff581d4bef63a3b7d3" translate="yes" xml:space="preserve">
          <source>Pod parsers should understand all &quot;E&amp;lt;html&amp;gt;&quot; codes as defined in the entity declarations in the most recent XHTML specification at &lt;code&gt;www.W3.org&lt;/code&gt; . Pod parsers must understand at least the entities that define characters in the range 160-255 (Latin-1). Pod parsers, when faced with some unknown &quot;E&amp;lt;</source>
          <target state="translated">Pod解析器应了解 &lt;code&gt;www.W3.org&lt;/code&gt; 上最新XHTML规范中的实体声明中定义的所有&amp;ldquo; E &amp;lt;html&amp;gt;&amp;rdquo;代码。 Pod解析器必须至少了解在160-255（Latin-1）范围内定义字符的实体。当遇到某些未知的&amp;ldquo; E &amp;lt;</target>
        </trans-unit>
        <trans-unit id="16758347dcd3bd561280b8ac6b5b799804590e6a" translate="yes" xml:space="preserve">
          <source>Pod parsers should understand all &quot;E&amp;lt;html&amp;gt;&quot; codes as defined in the entity declarations in the most recent XHTML specification at &lt;code&gt;www.W3.org&lt;/code&gt;. Pod parsers must understand at least the entities that define characters in the range 160-255 (Latin-1). Pod parsers, when faced with some unknown &quot;E&amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435533c0da449df0b3756321a9e1ae46d36e29f8" translate="yes" xml:space="preserve">
          <source>Pod parsers should, by default, expand tabs in verbatim paragraphs as they are processed, before passing them to the formatter or other processor. Parsers may also allow an option for overriding this.</source>
          <target state="translated">默认情况下,Pod解析器应该在处理逐字段中展开标签,然后再将其传递给格式化或其他处理器。解析器也可以允许一个选项来覆盖这一点。</target>
        </trans-unit>
        <trans-unit id="3ca8470501fde76fe0175878b3907601deeb185a" translate="yes" xml:space="preserve">
          <source>Pod parsers should, by default, remove newlines from the end of ordinary and verbatim paragraphs before passing them to the formatter. For example, while the paragraph you're reading now could be considered, in Pod source, to end with (and contain) the newline(s) that end it, it should be processed as ending with (and containing) the period character that ends this sentence.</source>
          <target state="translated">默认情况下,Pod解析器应该在将普通段落和逐字段落的结尾处删除换行符,然后再将其传递给格式化器。例如,虽然你现在阅读的段落在Pod源中可以被认为是以(并包含)结束它的换行符结束,但它应该被处理为以(并包含)结束这句话的句号字符结束。</target>
        </trans-unit>
        <trans-unit id="ed20dd657439280794de2dd1f166cc37caab82bd" translate="yes" xml:space="preserve">
          <source>Pod parsers, when processing a series of data paragraphs one after another (within a single region), should consider them to be one large data paragraph that happens to contain blank lines. So the content of the above &quot;=begin html&quot;...&quot;=end html&quot;</source>
          <target state="translated">Pod解析器在处理一系列数据段时,一个接一个(在一个区域内),应该把它们看作是一个大的数据段,而这个数据段恰好包含空行。所以上面&quot;=begin html&quot;...&quot;=end html &quot;的内容为</target>
        </trans-unit>
        <trans-unit id="f0083162b22d1c665e8c416af71fd03dff278ffc" translate="yes" xml:space="preserve">
          <source>Pod parsers, when processing a series of verbatim paragraphs one after another, should consider them to be one large verbatim paragraph that happens to contain blank lines. I.e., these two lines, which have a blank line between them:</source>
          <target state="translated">花苞解析器在接连处理一系列逐字段时,应把它们看作是一个大的逐字段,而这个大的逐字段恰好包含空行。即这两行字,它们之间有一条空行。</target>
        </trans-unit>
        <trans-unit id="b5f64a484d29376d6815265a1e55624e33ac0e03" translate="yes" xml:space="preserve">
          <source>Pod parsers, when reporting errors, should make some effort to report an approximate line number (&quot;Nested E&amp;lt;&amp;gt;'s in Paragraph #52, near line 633 of Thing/Foo.pm!&quot;), instead of merely noting the paragraph number (&quot;Nested E&amp;lt;&amp;gt;'s in Paragraph #52 of Thing/Foo.pm!&quot;). Where this is problematic, the paragraph number should at least be accompanied by an excerpt from the paragraph (&quot;Nested E&amp;lt;&amp;gt;'s in Paragraph #52 of Thing/Foo.pm, which begins 'Read/write accessor for the C&amp;lt;interest rate&amp;gt; attribute...'&quot;).</source>
          <target state="translated">Pod解析器在报告错误时，应做出一些努力来报告大约的行号（&amp;ldquo;第52段中的嵌套E &amp;lt;&amp;gt;，位于Thing / Foo.pm的第633行附近！&amp;rdquo;），而不是仅注意该段号。 （&amp;ldquo;在Thing / Foo.pm的第52段中嵌套的E &amp;lt;&amp;gt;！&amp;rdquo;）。如果这有问题，则该段号至少应附有该段的节选（Thing / Foo.pm的第52段中的&amp;ldquo;嵌套E &amp;lt;&amp;gt;&amp;rdquo;，该段的开头是&amp;ldquo;对C &amp;lt;interest率&amp;gt;属性...'&amp;ldquo;）。</target>
        </trans-unit>
        <trans-unit id="668dc3898e0866dd2110d298d9f0248ce827b86d" translate="yes" xml:space="preserve">
          <source>Pod processors must now treat &quot;text|&quot;-less links as follows:</source>
          <target state="translated">花苞处理器现在必须按以下方式处理 &quot;文本|&quot;-无链接。</target>
        </trans-unit>
        <trans-unit id="594a4383ca99a25d0a62e673cd217ea7d9ae8dcd" translate="yes" xml:space="preserve">
          <source>Pod processors must treat a &quot;=for [label] [content...]&quot; paragraph as meaning the same thing as a &quot;=begin [label]&quot; paragraph, content, and an &quot;=end [label]&quot; paragraph. (The parser may conflate these two constructs, or may leave them distinct, in the expectation that the formatter will nevertheless treat them the same.)</source>
          <target state="translated">花苞处理器必须将&quot;=for [label][content...]&quot;段与&quot;=begin [label]&quot;段、内容和&quot;=end [label]&quot;段的含义相同。(解析器可以将这两个结构混为一谈,也可以将它们分开,期望格式化器将它们视为一样的东西。)</target>
        </trans-unit>
        <trans-unit id="6de2f56b65b8b60daa7959cb94ce9eb7617c07e8" translate="yes" xml:space="preserve">
          <source>Pod processors seeing such a contentless &quot;=over&quot; ... &quot;=back&quot; region, may ignore it, or may report it as an error.</source>
          <target state="translated">花苞处理器看到这样一个无内容的&quot;=over&quot;......区域,可能会忽略它,或者报错。&quot;=back &quot;区域,可能会忽略它,或者报告为错误。</target>
        </trans-unit>
        <trans-unit id="3a61b4f9c5145d423bbf4e3510d246b1bb3674c7" translate="yes" xml:space="preserve">
          <source>Pod processors should tolerate &quot;=item *&quot; / &quot;=item</source>
          <target state="translated">花苞处理器应容忍&quot;=项目*&quot;/&quot;=item</target>
        </trans-unit>
        <trans-unit id="9adfdecd54c38e1ba53caaf5b50318f5e88b69d6" translate="yes" xml:space="preserve">
          <source>Pod processors should tolerate empty &quot;=begin</source>
          <target state="translated">花苞处理器应该容忍空的&quot;=begin&quot;。</target>
        </trans-unit>
        <trans-unit id="6ba827650f169b32c9dafe5b41a25b33124521f2" translate="yes" xml:space="preserve">
          <source>Pod text (i.e., possibly containing formatting codes) that's just not for normal formatting (e.g., may not be a normal-use paragraph, but might be for formatting as a footnote).</source>
          <target state="translated">只是不用于正常格式化的花苞文本(即可能包含格式化代码)(例如,可能不是一个正常使用的段落,但可能是用于格式化的脚注)。</target>
        </trans-unit>
        <trans-unit id="2783a719cd65c4f57c6fddc4f5f579afb17e9719" translate="yes" xml:space="preserve">
          <source>Pod-Parser is free software; you can redistribute it and/or modify it under the terms of the Artistic License distributed with Perl version 5.000 or (at your option) any later version. Please refer to the Artistic License that came with your Perl distribution for more details. If your version of Perl was not distributed under the terms of the Artistic License, than you may distribute PodParser under the same terms as Perl itself.</source>
          <target state="translated">Pod-Parser 是一个自由软件;你可以根据随 Perl 5.000 版或(由你选择)任何更新版本发布的 Artistic License 条款重新发布它和/或修改它。请参考你的Perl发行版所附带的Artistic License来了解更多细节。如果你的Perl版本不是按照Artistic License的条款发布的,你可以按照Perl本身的条款发布PodParser。</target>
        </trans-unit>
        <trans-unit id="1e0d75b84c30c843c8bfda065ca1ea8379066bee" translate="yes" xml:space="preserve">
          <source>Pod::Cache</source>
          <target state="translated">Pod::Cache</target>
        </trans-unit>
        <trans-unit id="b1da253840554c380163f270f69e5e71950e910f" translate="yes" xml:space="preserve">
          <source>Pod::Cache::Item</source>
          <target state="translated">Pod::Cache::Item</target>
        </trans-unit>
        <trans-unit id="4309bafc5148041a8cbecb4efa7c1ba20ab29cfb" translate="yes" xml:space="preserve">
          <source>Pod::Checker</source>
          <target state="translated">Pod::Checker</target>
        </trans-unit>
        <trans-unit id="27cda8ded60e07a80496a98d87fc154efc44a085" translate="yes" xml:space="preserve">
          <source>Pod::Checker - check pod documents for syntax errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5093f45c4b5aaed940c739c6d883bfba267a005" translate="yes" xml:space="preserve">
          <source>Pod::Checker, podchecker() - check pod documents for syntax errors</source>
          <target state="translated">Pod::Checker,podchecker()-检查pod文档的语法错误。</target>
        </trans-unit>
        <trans-unit id="b66220cfac7078b071d64dbaadef5e2df1a1682d" translate="yes" xml:space="preserve">
          <source>Pod::Escapes</source>
          <target state="translated">Pod::Escapes</target>
        </trans-unit>
        <trans-unit id="70a96b22865c78bae1b86e98f32189c8aaa2bb49" translate="yes" xml:space="preserve">
          <source>Pod::Escapes - for resolving Pod E&amp;lt;...&amp;gt; sequences</source>
          <target state="translated">Pod :: Escapes-用于解析Pod E &amp;lt;...&amp;gt;序列</target>
        </trans-unit>
        <trans-unit id="6defdf29847160bf19d64c9df0b01a83e7104754" translate="yes" xml:space="preserve">
          <source>Pod::Find</source>
          <target state="translated">Pod::Find</target>
        </trans-unit>
        <trans-unit id="808564a4fa3f783ef4d67e5d6df9a8f115d31c52" translate="yes" xml:space="preserve">
          <source>Pod::Find - find POD documents in directory trees</source>
          <target state="translated">Pod::Find-在目录树中查找POD文档。</target>
        </trans-unit>
        <trans-unit id="dad87a793e174e3498e4bb970a27f08fc37c4ec4" translate="yes" xml:space="preserve">
          <source>Pod::Functions</source>
          <target state="translated">Pod::Functions</target>
        </trans-unit>
        <trans-unit id="5ae2aa0e6801f18d083fa71458d5eb312ff91cd1" translate="yes" xml:space="preserve">
          <source>Pod::Functions - Group Perl's functions a la perlfunc.pod</source>
          <target state="translated">Pod::Functions-用perlfunc.pod对Perl的功能进行分组。</target>
        </trans-unit>
        <trans-unit id="155d59dfdac80d383af24b34deb797773121193e" translate="yes" xml:space="preserve">
          <source>Pod::Html</source>
          <target state="translated">Pod::Html</target>
        </trans-unit>
        <trans-unit id="6ce65cf1b1b1d8e5982cc14bc857d4e459129be4" translate="yes" xml:space="preserve">
          <source>Pod::Html - module to convert pod files to HTML</source>
          <target state="translated">Pod::Html-将 pod 文件转换为 HTML 的模块。</target>
        </trans-unit>
        <trans-unit id="5ed5257c3f06b8fdcae25020648334294f4275b0" translate="yes" xml:space="preserve">
          <source>Pod::Hyperlink</source>
          <target state="translated">Pod::Hyperlink</target>
        </trans-unit>
        <trans-unit id="dd2479ef40c118023069cffd4b8d4af17078456b" translate="yes" xml:space="preserve">
          <source>Pod::InputObjects</source>
          <target state="translated">Pod::InputObjects</target>
        </trans-unit>
        <trans-unit id="bfd22e221bc5d9239254ba01ea54c7e2a5450505" translate="yes" xml:space="preserve">
          <source>Pod::InputObjects - objects representing POD input paragraphs, commands, etc.</source>
          <target state="translated">Pod::InputObjects-代表POD输入段落、命令等的对象。</target>
        </trans-unit>
        <trans-unit id="1fd87a3ff91f7bce73657a26c6061dd462442c15" translate="yes" xml:space="preserve">
          <source>Pod::InteriorSequence-&amp;gt;*new()*</source>
          <target state="translated">Pod::InteriorSequence-&amp;gt;*new()*</target>
        </trans-unit>
        <trans-unit id="aa9152899b6499f1f28c2040e96614e6bafb5e59" translate="yes" xml:space="preserve">
          <source>Pod::InteriorSequence-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</source>
          <target state="translated">Pod::InteriorSequence-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="910131799392bc52cef82e99a388fd9c65b4ae23" translate="yes" xml:space="preserve">
          <source>Pod::InteriorSequence::*DESTROY()*</source>
          <target state="translated">Pod::InteriorSequence::*DESTROY()*</target>
        </trans-unit>
        <trans-unit id="1f1f3b74ed98a3dd9e45e5bf6a582d0ed682382c" translate="yes" xml:space="preserve">
          <source>Pod::InteriorSequence::&lt;b&gt;DESTROY()&lt;/b&gt;</source>
          <target state="translated">Pod::InteriorSequence::&lt;b&gt;DESTROY()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7583826bf22698054ad129c59e6b413946e80949" translate="yes" xml:space="preserve">
          <source>Pod::List</source>
          <target state="translated">Pod::List</target>
        </trans-unit>
        <trans-unit id="399a822bdd33d5589ccd5adac65bb8bcadff8e2b" translate="yes" xml:space="preserve">
          <source>Pod::Man</source>
          <target state="translated">Pod::Man</target>
        </trans-unit>
        <trans-unit id="5e62c421e1876f6d3d9c493879772552cb121e98" translate="yes" xml:space="preserve">
          <source>Pod::Man - Convert POD data to formatted *roff input</source>
          <target state="translated">Pod::Man-将POD数据转换为格式化的*roff输入。</target>
        </trans-unit>
        <trans-unit id="b90fbc49b7a05d49287613663bd77efed96454b2" translate="yes" xml:space="preserve">
          <source>Pod::Man assumes that your *roff formatters have a fixed-width font named &lt;code&gt;CW&lt;/code&gt; . If yours is called something else (like &lt;code&gt;CR&lt;/code&gt; ), use the &lt;code&gt;fixed&lt;/code&gt; option to specify it. This generally only matters for troff output for printing. Similarly, you can set the fonts used for bold, italic, and bold italic fixed-width output.</source>
          <target state="translated">Pod :: Man假定您的* roff格式化程序使用的定宽字体为 &lt;code&gt;CW&lt;/code&gt; 。如果您的名称被称为其他名称（例如 &lt;code&gt;CR&lt;/code&gt; ），请使用 &lt;code&gt;fixed&lt;/code&gt; 选项进行指定。这通常仅对打印输出的troff重要。同样，您可以设置用于粗体，斜体和粗斜体固定宽度输出的字体。</target>
        </trans-unit>
        <trans-unit id="cb9d1748a81808e728009b92b1162054aaa06911" translate="yes" xml:space="preserve">
          <source>Pod::Man assumes that your *roff formatters have a fixed-width font named &lt;code&gt;CW&lt;/code&gt;. If yours is called something else (like &lt;code&gt;CR&lt;/code&gt;), use the &lt;code&gt;fixed&lt;/code&gt; option to specify it. This generally only matters for troff output for printing. Similarly, you can set the fonts used for bold, italic, and bold italic fixed-width output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a26f0879ac57b4dc74e16802d7a975443066e4" translate="yes" xml:space="preserve">
          <source>Pod::Man doesn't handle font names longer than two characters. Neither do most &lt;b&gt;troff&lt;/b&gt; implementations, but GNU troff does as an extension. It would be nice to support as an option for those who want to use it.</source>
          <target state="translated">Pod :: Man处理的字体名称不能超过两个字符。大多数&lt;b&gt;troff的&lt;/b&gt;实现都没有，但是GNU troff作为扩展。对于那些想使用它的人来说，将其作为一种选择是很好的。</target>
        </trans-unit>
        <trans-unit id="ac7f587bee7ab6accabf7dabad0c45ac456a4a26" translate="yes" xml:space="preserve">
          <source>Pod::Man is a module to convert documentation in the POD format (the preferred language for documenting Perl) into *roff input using the man macro set. The resulting *roff code is suitable for display on a terminal using</source>
          <target state="translated">Pod::Man 是一个模块,它可以使用 man 宏集将 POD 格式(Perl 的首选文档语言)的文档转换为 *roff 输入。由此产生的*roff代码适合在终端上显示,可以使用</target>
        </trans-unit>
        <trans-unit id="3d124211073212f4a2d9f14b6de074e349d8b73d" translate="yes" xml:space="preserve">
          <source>Pod::Man is a module to convert documentation in the POD format (the preferred language for documenting Perl) into *roff input using the man macro set. The resulting *roff code is suitable for display on a terminal using &lt;a href=&quot;http://man.he.net/man1/nroff&quot;&gt;nroff(1)&lt;/a&gt;, normally via &lt;a href=&quot;http://man.he.net/man1/man&quot;&gt;man(1)&lt;/a&gt;, or printing using &lt;a href=&quot;http://man.he.net/man1/troff&quot;&gt;troff(1)&lt;/a&gt;. It is conventionally invoked using the driver script &lt;b&gt;pod2man&lt;/b&gt;, but it can also be used directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad3445f4f79ce9259a8628ec68bc720cda5d5e62" translate="yes" xml:space="preserve">
          <source>Pod::Man is excessively slow.</source>
          <target state="translated">花苞::人是过分的慢。</target>
        </trans-unit>
        <trans-unit id="51823c2a78f4399e5665a442ee35e9c5bca035b6" translate="yes" xml:space="preserve">
          <source>Pod::Paragraph-&amp;gt;*new()*</source>
          <target state="translated">Pod::Paragraph-&amp;gt;*new()*</target>
        </trans-unit>
        <trans-unit id="7d19eb9c0ae5cf759f818151ef1964f55c63cf45" translate="yes" xml:space="preserve">
          <source>Pod::Paragraph-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</source>
          <target state="translated">Pod::Paragraph-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="74702680baaf5527f7457048b890cf998a0bb577" translate="yes" xml:space="preserve">
          <source>Pod::ParseLink</source>
          <target state="translated">Pod::ParseLink</target>
        </trans-unit>
        <trans-unit id="cb542aa99fa734c9712efd42aa4abd5626202cf7" translate="yes" xml:space="preserve">
          <source>Pod::ParseLink - Parse an L&amp;lt;&amp;gt; formatting code in POD text</source>
          <target state="translated">Pod :: ParseLink-解析POD文本中的L &amp;lt;&amp;gt;格式代码</target>
        </trans-unit>
        <trans-unit id="40d45d7153ea7fd47a061f54ddf8f05276e6b0a8" translate="yes" xml:space="preserve">
          <source>Pod::ParseTree-&amp;gt;*new()*</source>
          <target state="translated">Pod::ParseTree-&amp;gt;*new()*</target>
        </trans-unit>
        <trans-unit id="c5b3a2fe463766f0c50d1925513a960e96c11a70" translate="yes" xml:space="preserve">
          <source>Pod::ParseTree-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</source>
          <target state="translated">Pod::ParseTree-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="58e28f5f7a4d5a5122148dd16c2d1e71ce7bc46b" translate="yes" xml:space="preserve">
          <source>Pod::ParseTree::*DESTROY()*</source>
          <target state="translated">Pod::ParseTree::*DESTROY()*</target>
        </trans-unit>
        <trans-unit id="81662ddf3d094b6a72fa9f04c80b756682be36f9" translate="yes" xml:space="preserve">
          <source>Pod::ParseTree::&lt;b&gt;DESTROY()&lt;/b&gt;</source>
          <target state="translated">Pod::ParseTree::&lt;b&gt;DESTROY()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ee80a8df78f91720393a41e76f1774b357695e04" translate="yes" xml:space="preserve">
          <source>Pod::ParseUtils</source>
          <target state="translated">Pod::ParseUtils</target>
        </trans-unit>
        <trans-unit id="bbc14d0ac8be47a43775571a03e2b17ca30027af" translate="yes" xml:space="preserve">
          <source>Pod::ParseUtils - helpers for POD parsing and conversion</source>
          <target state="translated">Pod::ParseUtils-用于POD解析和转换的帮助程序。</target>
        </trans-unit>
        <trans-unit id="0f85b7c22f11f515805110a0d85c8bbe81e1d272" translate="yes" xml:space="preserve">
          <source>Pod::Parser</source>
          <target state="translated">Pod::Parser</target>
        </trans-unit>
        <trans-unit id="e349932a04d5644a45ac3d6d00713d29777c5bd0" translate="yes" xml:space="preserve">
          <source>Pod::Parser - base class for creating POD filters and translators</source>
          <target state="translated">Pod::Parser-创建POD过滤器和翻译器的基础类。</target>
        </trans-unit>
        <trans-unit id="87e59733686c14028fb5b5ae16afd20f13d498de" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc</source>
          <target state="translated">Pod::Perldoc</target>
        </trans-unit>
        <trans-unit id="9d3a2f1ea446fa05938de94bfd8b37f662112ca1" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc - Look up Perl documentation in Pod format.</source>
          <target state="translated">Pod::Perldoc-以Pod格式查找Perl文档。</target>
        </trans-unit>
        <trans-unit id="952ca16414e36da5649f023d81973c25e340d6f9" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::BaseTo</source>
          <target state="translated">Pod::Perldoc::BaseTo</target>
        </trans-unit>
        <trans-unit id="35bfe0dc1cd61b9db99276bb0f43f2c0c5ad18a2" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::BaseTo - Base for Pod::Perldoc formatters</source>
          <target state="translated">Pod::Perldoc::BaseTo-Pod::Perldoc格式化的基础。</target>
        </trans-unit>
        <trans-unit id="b4063f396bd36a75310fe477b3233942b1f8e567" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::GetOptsOO</source>
          <target state="translated">Pod::Perldoc::GetOptsOO</target>
        </trans-unit>
        <trans-unit id="a32860ca9b02758a905681124e46d01c0cb1afa0" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::GetOptsOO - Customized option parser for Pod::Perldoc</source>
          <target state="translated">Pod::Perldoc::GetOptsOO-为Pod::Perldoc定制的选项解析器。</target>
        </trans-unit>
        <trans-unit id="9cd9c7c8bf140c8ef70c8bdc93de0b50d1c033a5" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToANSI</source>
          <target state="translated">Pod::Perldoc::ToANSI</target>
        </trans-unit>
        <trans-unit id="7657ee714db57c17e93a20e9955a2fbbbe328e50" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToANSI - render Pod with ANSI color escapes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db2d3912d225b5fb9794a822706dc8ac6dd251e" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToChecker</source>
          <target state="translated">Pod::Perldoc::ToChecker</target>
        </trans-unit>
        <trans-unit id="fb1bc67a07a358017c46696594ab3bb46f1cb4a2" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToChecker - let Perldoc check Pod for errors</source>
          <target state="translated">Pod::Perldoc::ToChecker-让Perldoc检查Pod的错误。</target>
        </trans-unit>
        <trans-unit id="a1574ea07e4ca7da944a178adab1f198c77bb9c4" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToMan</source>
          <target state="translated">Pod::Perldoc::ToMan</target>
        </trans-unit>
        <trans-unit id="30ccb6b13c861e844f65ca3477dee08e5031e04b" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToMan - let Perldoc render Pod as man pages</source>
          <target state="translated">Pod::Perldoc::ToMan-让Perldoc将Pod渲染成man页。</target>
        </trans-unit>
        <trans-unit id="e4528b7a26cc2f22afcb70063b8c90bfcec139cb" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToNroff</source>
          <target state="translated">Pod::Perldoc::ToNroff</target>
        </trans-unit>
        <trans-unit id="aad347f7e727638ba9cf62fde0284182ed3e5499" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToNroff - let Perldoc convert Pod to nroff</source>
          <target state="translated">Pod::Perldoc::ToNroff-让Perldoc将Pod转换为nroff。</target>
        </trans-unit>
        <trans-unit id="c74cfee58278b9d7e2d985e281b40bac7cf67fe1" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToPod</source>
          <target state="translated">Pod::Perldoc::ToPod</target>
        </trans-unit>
        <trans-unit id="d74169b37abf471a8016b67eb6b64f1d9c9504cb" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToPod - let Perldoc render Pod as ... Pod!</source>
          <target state="translated">Under::Perldoc::ToPod-让Perldoc将Under渲染成...下!</target>
        </trans-unit>
        <trans-unit id="f92919a3efdae5160bab598ae79998a12eaeb9d9" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToRtf</source>
          <target state="translated">Pod::Perldoc::ToRtf</target>
        </trans-unit>
        <trans-unit id="0397b052f308b568ed8ea3c3f278e9880b59064b" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToRtf - let Perldoc render Pod as RTF</source>
          <target state="translated">Pod::Perldoc::ToRtf-让Perldoc将Pod渲染成RTF格式。</target>
        </trans-unit>
        <trans-unit id="fd1e41f569b50e20cb00459a2e024d1d48daa4ae" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToTerm</source>
          <target state="translated">Pod::Perldoc::ToTerm</target>
        </trans-unit>
        <trans-unit id="9fd6d1a0399a01712bf45f2452104d56dd37b0b7" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToTerm - render Pod with terminal escapes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c7e677057bffb1949a495159f761c28d093073" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToText</source>
          <target state="translated">Pod::Perldoc::ToText</target>
        </trans-unit>
        <trans-unit id="1b76ad0504a574b95327f3837e47de7fc1023f81" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToText - let Perldoc render Pod as plaintext</source>
          <target state="translated">Pod::Perldoc::ToText-让Perldoc将Pod渲染成纯文本。</target>
        </trans-unit>
        <trans-unit id="44a2311f8a968a637bebf75641a7ba7c7bea0e77" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToTk</source>
          <target state="translated">Pod::Perldoc::ToTk</target>
        </trans-unit>
        <trans-unit id="ce6206e971d4052af6b94fba7e16c592c58263c8" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToTk - let Perldoc use Tk::Pod to render Pod</source>
          <target state="translated">Pod::Perldoc::ToTk-让Perldoc使用Tk::Pod来渲染Pod。</target>
        </trans-unit>
        <trans-unit id="cd1e43a8f3efd6bddd767fd169879bd7e8783197" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToXml</source>
          <target state="translated">Pod::Perldoc::ToXml</target>
        </trans-unit>
        <trans-unit id="eb2c349f8bc3477a2154a9f78f20889a0cd5e99e" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToXml - let Perldoc render Pod as XML</source>
          <target state="translated">Pod::Perldoc::ToXml-让Perldoc将Pod渲染成XML格式。</target>
        </trans-unit>
        <trans-unit id="944eb1a064749ff64ccfc3ec1500e3e6fc76949a" translate="yes" xml:space="preserve">
          <source>Pod::PlainText</source>
          <target state="translated">Pod::PlainText</target>
        </trans-unit>
        <trans-unit id="5cc69f416528304166ca8b06a7aa0165df6da3fc" translate="yes" xml:space="preserve">
          <source>Pod::PlainText - Convert POD data to formatted ASCII text</source>
          <target state="translated">Pod::PlainText-将POD数据转换为格式化的ASCII文本。</target>
        </trans-unit>
        <trans-unit id="946a0512ab5f99c773ae3db3dc5b34c4ce07ed9b" translate="yes" xml:space="preserve">
          <source>Pod::PlainText is a module that can convert documentation in the POD format (the preferred language for documenting Perl) into formatted ASCII. It uses no special formatting controls or codes whatsoever, and its output is therefore suitable for nearly any device.</source>
          <target state="translated">Pod::PlainText 是一个模块,它可以将 POD 格式(Perl 文档的首选语言)的文档转换成格式化的 ASCII。它没有使用任何特殊的格式化控件或代码,因此它的输出几乎适用于任何设备。</target>
        </trans-unit>
        <trans-unit id="8ed6eb484633051ee80e6a561ff9dcdff2c845ec" translate="yes" xml:space="preserve">
          <source>Pod::Select</source>
          <target state="translated">Pod::Select</target>
        </trans-unit>
        <trans-unit id="14904b6c97faa949c076532da064781f2d55c6b6" translate="yes" xml:space="preserve">
          <source>Pod::Select, podselect() - extract selected sections of POD from input</source>
          <target state="translated">Pod::Select,podselect()-从输入中提取POD的选定部分。</target>
        </trans-unit>
        <trans-unit id="661be2b89917f8caa0e44c582550ee749e115412" translate="yes" xml:space="preserve">
          <source>Pod::Simpele::XHTML was created by Allison Randal &amp;lt;allison@perl.org&amp;gt;.</source>
          <target state="translated">Pod :: Simpele :: XHTML由Allison Randal &amp;lt;allison@perl.org&amp;gt;创建。</target>
        </trans-unit>
        <trans-unit id="d6a12e7ef9128476299731ac0108ac1f784f3a4d" translate="yes" xml:space="preserve">
          <source>Pod::Simple</source>
          <target state="translated">Pod::Simple</target>
        </trans-unit>
        <trans-unit id="5996780debc4d561a6d61c26d2810b23db42afb5" translate="yes" xml:space="preserve">
          <source>Pod::Simple - framework for parsing Pod</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d11b0239af7ff1a19852fc395f1f5f5a3a35c0c" translate="yes" xml:space="preserve">
          <source>Pod::Simple is a Perl library for parsing text in the Pod (&quot;plain old documentation&quot;) markup language that is typically used for writing documentation for Perl and for Perl modules. The Pod format is explained &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;; the most common formatter is called &lt;code&gt;perldoc&lt;/code&gt; .</source>
          <target state="translated">Pod :: Simple是一个Perl库，用于解析Pod（&amp;ldquo;普通旧文档&amp;rdquo;）标记语言中的文本，该语言通常用于编写Perl和Perl模块的文档。Pod格式解释&lt;a href=&quot;../perlpod&quot;&gt;了&lt;/a&gt; ; 最常见的格式化程序称为 &lt;code&gt;perldoc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5137b4a66b1a3ab70161fd3fed20b8efa15f0b7" translate="yes" xml:space="preserve">
          <source>Pod::Simple is a Perl library for parsing text in the Pod (&quot;plain old documentation&quot;) markup language that is typically used for writing documentation for Perl and for Perl modules. The Pod format is explained in &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;; the most common formatter is called &lt;code&gt;perldoc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540c209eeff967303f473e2a9f8cc439bebb7a9a" translate="yes" xml:space="preserve">
          <source>Pod::Simple is maintained by:</source>
          <target state="translated">Pod::Simple的维护者是。</target>
        </trans-unit>
        <trans-unit id="bb05ccf22951145f967d6e477a3802aa35df7d1b" translate="yes" xml:space="preserve">
          <source>Pod::Simple provides a lot of methods that aren't generally interesting to the end user of an existing Pod formatter, but some of which you might find useful in writing a Pod formatter. They are listed below. The first several methods (the accept_* methods) are for declaring the capabilities of your parser, notably what &lt;code&gt;=for &lt;i&gt;targetname&lt;/i&gt;&lt;/code&gt; sections it's interested in, what extra N&amp;lt;...&amp;gt; codes it accepts beyond the ones described in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1804f7888eed7ad55ddcaa1547cb97407e48d6c0" translate="yes" xml:space="preserve">
          <source>Pod::Simple uses this class for representing the value of the &quot;section&quot; attribute of &quot;L&quot; start-element events. Most applications can just use the normal stringification of objects of this class; they stringify to just the text content of the section, such as &quot;foo&quot; for &lt;code&gt;L&amp;lt;Stuff/foo&amp;gt;&lt;/code&gt; , and &quot;bar&quot; for &lt;code&gt;L&amp;lt;Stuff/bI&amp;lt;ar&amp;gt;&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">Pod :: Simple使用此类表示&amp;ldquo; L&amp;rdquo;个起始元素事件的&amp;ldquo; section&amp;rdquo;属性的值。大多数应用程序只能使用此类的普通字符串化对象。它们只字符串化为该部分的文本内容，例如 &lt;code&gt;L&amp;lt;Stuff/foo&amp;gt;&lt;/code&gt; &amp;ldquo; foo &amp;rdquo;， &lt;code&gt;L&amp;lt;Stuff/bI&amp;lt;ar&amp;gt;&amp;gt;&lt;/code&gt; &amp;ldquo; bar&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="3042d36d43941ed5b64500dc2cd178778f09f598" translate="yes" xml:space="preserve">
          <source>Pod::Simple uses this class for representing the value of the &quot;section&quot; attribute of &quot;L&quot; start-element events. Most applications can just use the normal stringification of objects of this class; they stringify to just the text content of the section, such as &quot;foo&quot; for &lt;code&gt;L&amp;lt;Stuff/foo&amp;gt;&lt;/code&gt;, and &quot;bar&quot; for &lt;code&gt;L&amp;lt;Stuff/bI&amp;lt;ar&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc75eedd949380ed057546f8903efcf7ffa0476d" translate="yes" xml:space="preserve">
          <source>Pod::Simple was created by Sean M. Burke &amp;lt;sburke@cpan.org&amp;gt; with code borrowed from Marek Rouchal's &lt;a href=&quot;../find&quot;&gt;Pod::Find&lt;/a&gt;, which in turn heavily borrowed code from Nick Ing-Simmons' &lt;code&gt;PodToHtml&lt;/code&gt; .</source>
          <target state="translated">Pod :: Simple是由Sean M. Burke &amp;lt;sburke@cpan.org&amp;gt;创建的，代码是从Marek Rouchal的&lt;a href=&quot;../find&quot;&gt;Pod :: Find&lt;/a&gt;借来的，而后者又从Nick Ing-Simmons的 &lt;code&gt;PodToHtml&lt;/code&gt; 借来了代码。</target>
        </trans-unit>
        <trans-unit id="046013a100ec04c3c2d20b96d7505ecd3be590e8" translate="yes" xml:space="preserve">
          <source>Pod::Simple was created by Sean M. Burke &amp;lt;sburke@cpan.org&amp;gt; with code borrowed from Marek Rouchal's &lt;a href=&quot;Pod::Find&quot;&gt;Pod::Find&lt;/a&gt;, which in turn heavily borrowed code from Nick Ing-Simmons' &lt;code&gt;PodToHtml&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8185c68a0339f127d3dbf1b4ad4adf9a512efe5f" translate="yes" xml:space="preserve">
          <source>Pod::Simple was created by Sean M. Burke &amp;lt;sburke@cpan.org&amp;gt;. But don't bother him, he's retired.</source>
          <target state="translated">Pod :: Simple是由Sean M. Burke &amp;lt;sburke@cpan.org&amp;gt;创建的。但是不要打扰他，他已经退休了。</target>
        </trans-unit>
        <trans-unit id="d80b5e8d9939c2b2cdcf8caadd6b9ea76e6a4a21" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Checker</source>
          <target state="translated">Pod::Simple::Checker</target>
        </trans-unit>
        <trans-unit id="55590025c27353d8a373860de047b5dce37dba23" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Checker -- check the Pod syntax of a document</source>
          <target state="translated">Pod::Simple::Checker --检查文档的Pod语法。</target>
        </trans-unit>
        <trans-unit id="b74f1729aad6ae1a22d920544a38e42cdf81b6d7" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Debug</source>
          <target state="translated">Pod::Simple::Debug</target>
        </trans-unit>
        <trans-unit id="fa67e2158a0a94760ae209d78cc2c60c328cfd2a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Debug -- put Pod::Simple into trace/debug mode</source>
          <target state="translated">Pod::Simple::Debug --进入跟踪/调试模式。</target>
        </trans-unit>
        <trans-unit id="c186101b5cf38096df66f1dfcd5544f7e2c30c6c" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsText</source>
          <target state="translated">Pod::Simple::DumpAsText</target>
        </trans-unit>
        <trans-unit id="c3c292397a980ed71b52c2ff0898634dee25e619" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsText -- dump Pod-parsing events as text</source>
          <target state="translated">Pod::Simple::DumpAsText --将Pod-parsing事件转储为文本。</target>
        </trans-unit>
        <trans-unit id="cc35fcc6b860e53e9fba03174336a15b24d3e20e" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsXML</source>
          <target state="translated">Pod::Simple::DumpAsXML</target>
        </trans-unit>
        <trans-unit id="373b728991f6282ba763bd2a10793d147d39c8ce" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsXML -- turn Pod into XML</source>
          <target state="translated">Pod::Simple::DumpAsXML --将Pod转换成XML。</target>
        </trans-unit>
        <trans-unit id="9f6b85c1362b8bcf343570ad01e881211977b269" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsXML inherits methods from &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt;.</source>
          <target state="translated">Pod :: Simple :: DumpAsXML继承&lt;a href=&quot;../simple&quot;&gt;Pod :: Simple的&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="02b3f87b1932c51400c8b115e4f1ba0a1b176a04" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsXML inherits methods from &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a26787ab4cbd9b5d37d67ecda1faa021db04bcda" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsXML is a subclass of &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt; that parses Pod and turns it into indented and wrapped XML. This class is of interest to people writing Pod formatters based on Pod::Simple.</source>
          <target state="translated">波德::简单:: DumpAsXML是的子类&lt;a href=&quot;../simple&quot;&gt;波德::简单&lt;/a&gt;，它解析POD和把它变成缩进和包裹XML。此类是基于Pod :: Simple编写Pod格式器的人们所感兴趣的。</target>
        </trans-unit>
        <trans-unit id="3bc6aef0753a906554fe52605727fcd96d63c2f8" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsXML is a subclass of &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; that parses Pod and turns it into indented and wrapped XML. This class is of interest to people writing Pod formatters based on Pod::Simple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e3cad548b1d58d72a35d1b97df012592abca6a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::HTML</source>
          <target state="translated">Pod::Simple::HTML</target>
        </trans-unit>
        <trans-unit id="9ba84d76002e656d6a841be7c0fa1ddaf7a15278" translate="yes" xml:space="preserve">
          <source>Pod::Simple::HTML - convert Pod to HTML</source>
          <target state="translated">Pod::Simple::HTML-将Pod转换为HTML。</target>
        </trans-unit>
        <trans-unit id="4f616c51b55e2caed067f512efd6be765988729c" translate="yes" xml:space="preserve">
          <source>Pod::Simple::HTMLBatch</source>
          <target state="translated">Pod::Simple::HTMLBatch</target>
        </trans-unit>
        <trans-unit id="b714f30d97375e99cc3dc025fe21efb3928ffb30" translate="yes" xml:space="preserve">
          <source>Pod::Simple::HTMLBatch - convert several Pod files to several HTML files</source>
          <target state="translated">Pod::Simple::HTMLBatch-将多个Pod文件转换为多个HTML文件。</target>
        </trans-unit>
        <trans-unit id="ffc09ddc7418e3e9cf3efb9e134eaaaeff9f17d4" translate="yes" xml:space="preserve">
          <source>Pod::Simple::JustPod</source>
          <target state="translated">Pod::Simple::JustPod</target>
        </trans-unit>
        <trans-unit id="b431e9b8673f61ccfc1e9efe125ce7dfc3efc755" translate="yes" xml:space="preserve">
          <source>Pod::Simple::JustPod -- just the Pod, the whole Pod, and nothing but the Pod</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eddaf844c75beb11321838c4f34da6339343ef39" translate="yes" xml:space="preserve">
          <source>Pod::Simple::JustPod was developed by John SJ Anderson &lt;code&gt;genehack@genehack.org&lt;/code&gt;, with contributions from Karl Williamson &lt;code&gt;khw@cpan.org&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d427af968fe5b5f7cabfdd1b7609d966dc62cc" translate="yes" xml:space="preserve">
          <source>Pod::Simple::LinkSection</source>
          <target state="translated">Pod::Simple::LinkSection</target>
        </trans-unit>
        <trans-unit id="565e4c6e11a593b50f5257b1a4aee37099620372" translate="yes" xml:space="preserve">
          <source>Pod::Simple::LinkSection -- represent &quot;section&quot; attributes of L codes</source>
          <target state="translated">Pod::Simple::LinkSection --代表L代码的 &quot;部分 &quot;属性。</target>
        </trans-unit>
        <trans-unit id="04192c711189c3d3745e9766bf472b32950a1f73" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Methody</source>
          <target state="translated">Pod::Simple::Methody</target>
        </trans-unit>
        <trans-unit id="0ca575b26347f441076a6fd1a824c79b25cf2619" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Methody -- turn Pod::Simple events into method calls</source>
          <target state="translated">Pod::Simple::Methody --将Pod::Simple事件转化为方法调用。</target>
        </trans-unit>
        <trans-unit id="7aa02a3f7b5768f2a6ec877904dc7ab387a3061a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParser</source>
          <target state="translated">Pod::Simple::PullParser</target>
        </trans-unit>
        <trans-unit id="ea0c112c9214628c826e97034dffc164b33f6a82" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParser -- a pull-parser interface to parsing Pod</source>
          <target state="translated">Pod::Simple::PullParser --一个用于解析Pod的pull-parser接口。</target>
        </trans-unit>
        <trans-unit id="070ea3cf235fa0c5ea455a6107c6b1c28503ff41" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserEndToken</source>
          <target state="translated">Pod::Simple::PullParserEndToken</target>
        </trans-unit>
        <trans-unit id="0e20ea7a70dab49b1f0f66e63f1a06a2f448b097" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserEndToken -- end-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod::Simple::PullParserEndToken --来自Pod::Simple::PullParser的结束标记。</target>
        </trans-unit>
        <trans-unit id="11aea837de023672a7a9d2518ea0e8e11a95f00a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserStartToken</source>
          <target state="translated">Pod::Simple::PullParserStartToken</target>
        </trans-unit>
        <trans-unit id="d6244e584441e2b0f907fb0ffecde2defcc17cae" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserStartToken -- start-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod::Simple::PullParserStartToken --来自 Pod::Simple::PullParser 的启动令牌。</target>
        </trans-unit>
        <trans-unit id="41b32f7393c26878ea6e6764691f6ab8d4cfed16" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserTextToken</source>
          <target state="translated">Pod::Simple::PullParserTextToken</target>
        </trans-unit>
        <trans-unit id="85a00c2aa32007d196ff05d09a358b591b60a9d7" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserTextToken -- text-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod::Simple::PullParserTextToken --来自Pod::Simple::PullParser的文本标记。</target>
        </trans-unit>
        <trans-unit id="af99c7c32db60fbc39ffa01aa36158222378886f" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserToken</source>
          <target state="translated">Pod::Simple::PullParserToken</target>
        </trans-unit>
        <trans-unit id="83ed709c868d2cc4eff657e59deb01ec607246dd" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserToken -- tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod::Simple::PullParserToken --来自Pod::Simple::PullParser的标记。</target>
        </trans-unit>
        <trans-unit id="cd8b2814ae13bcab0bbe442896010091755dc3df" translate="yes" xml:space="preserve">
          <source>Pod::Simple::RTF</source>
          <target state="translated">Pod::Simple::RTF</target>
        </trans-unit>
        <trans-unit id="b3241001e4eb1949e4d0740b263d2fb59490fadf" translate="yes" xml:space="preserve">
          <source>Pod::Simple::RTF -- format Pod as RTF</source>
          <target state="translated">Pod::Simple::RTF --将Pod格式化为RTF。</target>
        </trans-unit>
        <trans-unit id="7cec88f41732497c431990231ff60d0d97239c5a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Search</source>
          <target state="translated">Pod::Simple::Search</target>
        </trans-unit>
        <trans-unit id="e1ea8fdb67de63159764e718db4fbefbb27c467f" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Search - find POD documents in directory trees</source>
          <target state="translated">Pod::Simple::Search-在目录树中查找POD文档。</target>
        </trans-unit>
        <trans-unit id="62021a054d37a5d7fcf8c80130c7b291785a01cf" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Search will by default internally make an assumption based on the underlying filesystem where the class file is found whether it is case insensitive or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bec063b1fe4a8b7088da5083ba7437146419ca6" translate="yes" xml:space="preserve">
          <source>Pod::Simple::SimpleTree</source>
          <target state="translated">Pod::Simple::SimpleTree</target>
        </trans-unit>
        <trans-unit id="eea909e0d762cb819c8aa8330fdb9ba6a9be4d16" translate="yes" xml:space="preserve">
          <source>Pod::Simple::SimpleTree -- parse Pod into a simple parse tree</source>
          <target state="translated">Pod::Simple::SimpleTree --将Pod解析成一棵简单的解析树。</target>
        </trans-unit>
        <trans-unit id="5da91d8d6431a8c01e6c864a85dab3bf9cec1f3e" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Subclassing</source>
          <target state="translated">Pod::Simple::Subclassing</target>
        </trans-unit>
        <trans-unit id="7f952b92af53e1429b73f0a13edd27e756189634" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Subclassing -- write a formatter as a Pod::Simple subclass</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b18ba6877611e38d5ebeca357ca45de50b3d8f5a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Text</source>
          <target state="translated">Pod::Simple::Text</target>
        </trans-unit>
        <trans-unit id="753e56ce7ac1a58ad889fddf470a50b96539c6da" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Text -- format Pod as plaintext</source>
          <target state="translated">Pod::Simple::Text --将Pod格式化为纯文本。</target>
        </trans-unit>
        <trans-unit id="8d8c6d10cf65bae9e13056ddeb8c6d2c2a890ff6" translate="yes" xml:space="preserve">
          <source>Pod::Simple::TextContent</source>
          <target state="translated">Pod::Simple::TextContent</target>
        </trans-unit>
        <trans-unit id="7e136e15cf39e6850f0880e93ca8c30b3d62e90f" translate="yes" xml:space="preserve">
          <source>Pod::Simple::TextContent -- get the text content of Pod</source>
          <target state="translated">Pod::Simple::TextContent --获取Pod的文本内容。</target>
        </trans-unit>
        <trans-unit id="c87067a51be41176018a7a02a831c44466936f6a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XHTML</source>
          <target state="translated">Pod::Simple::XHTML</target>
        </trans-unit>
        <trans-unit id="259f074470a9013b0eea26649d0b91cffcd63426" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XHTML -- format Pod as validating XHTML</source>
          <target state="translated">Pod::Simple::XHTML --将Pod格式化为验证XHTML。</target>
        </trans-unit>
        <trans-unit id="fcd3e6ec8f3899adef753786dbd1ab596eb81dbe" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XHTML offers a number of methods that modify the format of the HTML output. Call these after creating the parser object, but before the call to &lt;code&gt;parse_file&lt;/code&gt; :</source>
          <target state="translated">Pod :: Simple :: XHTML提供了许多修改HTML输出格式的方法。在创建解析器对象之后，但在调用 &lt;code&gt;parse_file&lt;/code&gt; 之前调用它们：</target>
        </trans-unit>
        <trans-unit id="3e5485140fcfa8d3ea4729639fdcbb80ddfb24e3" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XHTML offers a number of methods that modify the format of the HTML output. Call these after creating the parser object, but before the call to &lt;code&gt;parse_file&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="951593ce225e4b7953c95143c2dd0fc68256192b" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XMLOutStream</source>
          <target state="translated">Pod::Simple::XMLOutStream</target>
        </trans-unit>
        <trans-unit id="2c8ebe8007a83f6db16cd28e4028774e22050e1e" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XMLOutStream -- turn Pod into XML</source>
          <target state="translated">Pod::Simple::XMLOutStream --将Pod转为XML。</target>
        </trans-unit>
        <trans-unit id="5a6dda8cf65a6f2f753c09f42fcc82ca0f054678" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XMLOutStream inherits methods from &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt;.</source>
          <target state="translated">Pod :: Simple :: XMLOutStream继承&lt;a href=&quot;../simple&quot;&gt;Pod :: Simple的&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="d5fe61554e18ee37710a20ddffd872e1657ed8e9" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XMLOutStream inherits methods from &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5393b17d53eb5cd3e02f552010cdbdc23dd6294" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XMLOutStream is a subclass of &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt; that parses Pod and turns it into XML.</source>
          <target state="translated">波德::简单:: XMLOutStream是的子类&lt;a href=&quot;../simple&quot;&gt;波德::简单&lt;/a&gt;，它分析波德并将其转化为XML。</target>
        </trans-unit>
        <trans-unit id="6afeca633f44df878f3c6c4af1eb0dc5fc515050" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XMLOutStream is a subclass of &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; that parses Pod and turns it into XML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7f94950bba4ec35927384f3ba52a47b2d388e7" translate="yes" xml:space="preserve">
          <source>Pod::Text</source>
          <target state="translated">Pod::Text</target>
        </trans-unit>
        <trans-unit id="e6e584d20fd5725d4428861f69402acfdd834bf0" translate="yes" xml:space="preserve">
          <source>Pod::Text - Convert POD data to formatted ASCII text</source>
          <target state="translated">Pod::Text-将POD数据转换为格式化的ASCII文本。</target>
        </trans-unit>
        <trans-unit id="ab9108e9dff7e6acb11c45245829f8db58a22933" translate="yes" xml:space="preserve">
          <source>Pod::Text - Convert POD data to formatted text</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519614764ccb1ff38de936b78f067c16eca0fe48" translate="yes" xml:space="preserve">
          <source>Pod::Text is a module that can convert documentation in the POD format (the preferred language for documenting Perl) into formatted ASCII. It uses no special formatting controls or codes whatsoever, and its output is therefore suitable for nearly any device.</source>
          <target state="translated">Pod::Text 是一个模块,它可以将 POD 格式(Perl 文档的首选语言)的文档转换为格式化的 ASCII 文件。它没有使用任何特殊的格式化控件或代码,因此它的输出几乎适用于任何设备。</target>
        </trans-unit>
        <trans-unit id="d7ae0431b95823c9cdaef0a1a00879b188191692" translate="yes" xml:space="preserve">
          <source>Pod::Text is a module that can convert documentation in the POD format (the preferred language for documenting Perl) into formatted text. It uses no special formatting controls or codes whatsoever, and its output is therefore suitable for nearly any device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b000e1532343476a2f005325a7e1d5a7cc21c94" translate="yes" xml:space="preserve">
          <source>Pod::Text::Color</source>
          <target state="translated">Pod::Text::Color</target>
        </trans-unit>
        <trans-unit id="481fceb7f0a093b935ebdf609b3ea4b2ecf12680" translate="yes" xml:space="preserve">
          <source>Pod::Text::Color - Convert POD data to formatted color ASCII text</source>
          <target state="translated">Pod::Text::Color-将POD数据转换为格式化的彩色ASCII文本。</target>
        </trans-unit>
        <trans-unit id="77f334b564bfb0176f5034dad3905349c4003fa8" translate="yes" xml:space="preserve">
          <source>Pod::Text::Color is a simple subclass of Pod::Text that highlights output text using ANSI color escape sequences. Apart from the color, it in all ways functions like Pod::Text. See &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">Pod :: Text :: Color是Pod :: Text的简单子类，它使用ANSI颜色转义序列突出显示输出文本。除颜色外，它在所有方面都类似于Pod :: Text。有关详细信息和可用选项，请参见&lt;a href=&quot;../text&quot;&gt;Pod :: Text&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efbe00bb611152db236e4b619961328e4de0f95f" translate="yes" xml:space="preserve">
          <source>Pod::Text::Color is a simple subclass of Pod::Text that highlights output text using ANSI color escape sequences. Apart from the color, it in all ways functions like Pod::Text. See &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bbee340278a2ff3fc6d6d87793be1b3326a3164" translate="yes" xml:space="preserve">
          <source>Pod::Text::Overstrike</source>
          <target state="translated">Pod::Text::Overstrike</target>
        </trans-unit>
        <trans-unit id="6f979e30783784683adf1aac75e360359ed243cf" translate="yes" xml:space="preserve">
          <source>Pod::Text::Overstrike - Convert POD data to formatted overstrike text</source>
          <target state="translated">Pod::Text::Overstrike-将POD数据转换为格式化的Overstrike文本。</target>
        </trans-unit>
        <trans-unit id="29be1312d16601e968f895f7174874218cfa222e" translate="yes" xml:space="preserve">
          <source>Pod::Text::Overstrike is a simple subclass of Pod::Text that highlights output text using overstrike sequences, in a manner similar to nroff. Characters in bold text are overstruck (character, backspace, character) and characters in underlined text are converted to overstruck underscores (underscore, backspace, character). This format was originally designed for hard-copy terminals and/or line printers, yet is readable on soft-copy (CRT) terminals.</source>
          <target state="translated">Pod::Text::Overstrike是Pod::Text的一个简单的子类,它以类似于nroff的方式,使用overstrike序列来突出输出文本。粗体文本中的字符会被覆盖(字符、退格、字符),而下划线文本中的字符会被转换为覆盖的下划线(下划线、退格、字符)。这种格式最初是为硬拷贝终端和/或行式打印机设计的,但在软拷贝(CRT)终端上也可以阅读。</target>
        </trans-unit>
        <trans-unit id="7195453df8fc7b6eab0965ce075c75610190c6a6" translate="yes" xml:space="preserve">
          <source>Pod::Text::Termcap</source>
          <target state="translated">Pod::Text::Termcap</target>
        </trans-unit>
        <trans-unit id="22f155581256a8a1fab5e33d67ab86301d7bc4cd" translate="yes" xml:space="preserve">
          <source>Pod::Text::Termcap - Convert POD data to ASCII text with format escapes</source>
          <target state="translated">Pod::Text::Termcap-通过格式转义将POD数据转换为ASCII文本。</target>
        </trans-unit>
        <trans-unit id="4aec2a63ef082d360b91e6eb0afca126e8b2efc0" translate="yes" xml:space="preserve">
          <source>Pod::Text::Termcap is a simple subclass of Pod::Text that highlights output text using the correct termcap escape sequences for the current terminal. Apart from the format codes, it in all ways functions like Pod::Text. See &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">Pod :: Text :: Termcap是Pod :: Text的简单子类，它使用当前终端的正确termcap转义序列突出显示输出文本。除了格式代码，它在所有方面都类似于Pod :: Text。有关详细信息和可用选项，请参见&lt;a href=&quot;../text&quot;&gt;Pod :: Text&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2858aa68e07f4dd145d3fcb814f559d00a90436" translate="yes" xml:space="preserve">
          <source>Pod::Text::Termcap is a simple subclass of Pod::Text that highlights output text using the correct termcap escape sequences for the current terminal. Apart from the format codes, it in all ways functions like Pod::Text. See &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ead75c44533a688798cad50ab41fa8f303554d" translate="yes" xml:space="preserve">
          <source>Pod::Usage</source>
          <target state="translated">Pod::Usage</target>
        </trans-unit>
        <trans-unit id="b4dc8d5361b7e455072cf29ee34ca11a59abca9a" translate="yes" xml:space="preserve">
          <source>Pod::Usage - print a usage message from embedded pod documentation</source>
          <target state="translated">Pod::Usage-从嵌入式 pod 文档中打印使用信息</target>
        </trans-unit>
        <trans-unit id="ce218f4b64ca779219ccdd981ed413ca8b202fdc" translate="yes" xml:space="preserve">
          <source>Pod::Usage uses &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt;'s _handle_element_end() method to implement the section selection, and in case of verbosity &amp;lt; 2 it down-cases the all-caps headings to first capital letter and rest lowercase, and adds a colon/newline at the end of the headings, for better readability. Same for verbosity = 99.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad7eae188bc449da645418942520b12991444b2" translate="yes" xml:space="preserve">
          <source>Pointer to a structure encapsulating the state of the parsing operation currently in progress. The pointer can be locally changed to perform a nested parse without interfering with the state of an outer parse. Individual members of &lt;code&gt;PL_parser&lt;/code&gt; have their own documentation.</source>
          <target state="translated">指向封装当前正在进行的解析操作状态的结构的指针。可以在本地更改指针以执行嵌套解析，而不会干扰外部解析的状态。 &lt;code&gt;PL_parser&lt;/code&gt; 的各个成员都有自己的文档。</target>
        </trans-unit>
        <trans-unit id="569cfd3e6d40d0f45b19803b2cef265e9a1d1cb3" translate="yes" xml:space="preserve">
          <source>Pointer to the character following the physical end of the string (i.e. the &lt;code&gt;\0&lt;/code&gt; , if any).</source>
          <target state="translated">指向字符串物理结尾之后的字符的指针（即 &lt;code&gt;\0&lt;/code&gt; ，如果有的话）。</target>
        </trans-unit>
        <trans-unit id="f26443a6f326aa8e35a57bd9708b38b493031f37" translate="yes" xml:space="preserve">
          <source>Pointer to the character following the physical end of the string (i.e. the &lt;code&gt;\0&lt;/code&gt;, if any).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7efb8f2f5c41fc448cd25b9357a4b637d7c3c35" translate="yes" xml:space="preserve">
          <source>Pointer to the linearisation function, described below.</source>
          <target state="translated">指向线性化函数的指针,如下所述。</target>
        </trans-unit>
        <trans-unit id="93e37c8eb5980406ef58242eae9fe75acd07201b" translate="yes" xml:space="preserve">
          <source>Pointer to the per-subroutine peephole optimiser. This is a function that gets called at the end of compilation of a Perl subroutine (or equivalently independent piece of Perl code) to perform fixups of some ops and to perform small-scale optimisations. The function is called once for each subroutine that is compiled, and is passed, as sole parameter, a pointer to the op that is the entry point to the subroutine. It modifies the op tree in place.</source>
          <target state="translated">指向每个子程序的窥视孔优化器的指针。这个函数在Perl子程序(或等价的独立Perl代码)编译结束时被调用,用于对一些操作进行修复和小规模的优化。这个函数对每一个被编译的子程序都会被调用一次,作为唯一的参数,它被传递给一个指向子程序入口的 op 的指针。它在原地修改 op 树。</target>
        </trans-unit>
        <trans-unit id="d2e62507cb5b989fbd3aba1b8f6ac801e56c7fb1" translate="yes" xml:space="preserve">
          <source>Pointer to the physical start of the string.</source>
          <target state="translated">指向字符串的物理起始点的指针。</target>
        </trans-unit>
        <trans-unit id="24a8aad8d082073a41e895d4c5a7e7f9947568de" translate="yes" xml:space="preserve">
          <source>Pointer to the position in the string where matching should start; it might not be equal to &lt;code&gt;strbeg&lt;/code&gt; (for example in a later iteration of &lt;code&gt;/.../g&lt;/code&gt; ).</source>
          <target state="translated">指向字符串中应该开始匹配的位置的指针；它可能不等于 &lt;code&gt;strbeg&lt;/code&gt; （例如，在以后的 &lt;code&gt;/.../g&lt;/code&gt; 迭代中）。</target>
        </trans-unit>
        <trans-unit id="fc9305ad14128dd61fc34d5fec4f93e8c59716ad" translate="yes" xml:space="preserve">
          <source>Pointer to the position in the string where matching should start; it might not be equal to &lt;code&gt;strbeg&lt;/code&gt; (for example in a later iteration of &lt;code&gt;/.../g&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f83ff7c09e64b6014d200a49cf4d57b3fe2a3b7" translate="yes" xml:space="preserve">
          <source>Pointer to the recursive peephole optimiser. This is a function that gets called at the end of compilation of a Perl subroutine (or equivalently independent piece of Perl code) to perform fixups of some ops and to perform small-scale optimisations. The function is called once for each chain of ops linked through their &lt;code&gt;op_next&lt;/code&gt; fields; it is recursively called to handle each side chain. It is passed, as sole parameter, a pointer to the op that is at the head of the chain. It modifies the op tree in place.</source>
          <target state="translated">指向递归窥孔优化器的指针。这个函数在Perl子例程（或等效地独立的Perl代码）的编译结束时被调用，以执行某些操作的修正并进行小规模优化。通过 &lt;code&gt;op_next&lt;/code&gt; 字段链接的每个op链都会调用一次该函数；它被递归调用以处理每个侧链。作为唯一参数，将其传递给指向链顶部的op的指针。它会修改操作树。</target>
        </trans-unit>
        <trans-unit id="1b15de7f05dc81e7a10d8422ae41b092aa35ff88" translate="yes" xml:space="preserve">
          <source>Pointer-To-Integer and Integer-To-Pointer</source>
          <target state="translated">指针到整数和整数到指针。</target>
        </trans-unit>
        <trans-unit id="8db4543231fbc881b475cb920918beb06e6957b1" translate="yes" xml:space="preserve">
          <source>Pointers for How to Use Them</source>
          <target state="translated">如何使用它们的要点</target>
        </trans-unit>
        <trans-unit id="d2230d33a0d37bef7c5428bbaebaf857455229dd" translate="yes" xml:space="preserve">
          <source>Points directly to the body of the &lt;a href=&quot;#PL_comppad&quot;&gt;&quot;PL_comppad&quot;&lt;/a&gt; array. (I.e., this is &lt;code&gt;PadARRAY(PL_comppad)&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0e53b7caa90905a98f7bada48b61cffae6dfc0" translate="yes" xml:space="preserve">
          <source>Points directly to the body of the &lt;a href=&quot;#PL_comppad&quot;&gt;PL_comppad&lt;/a&gt; array. (I.e., this is &lt;code&gt;PAD_ARRAY(PL_comppad)&lt;/code&gt; .)</source>
          <target state="translated">直接指向&lt;a href=&quot;#PL_comppad&quot;&gt;PL_comppad&lt;/a&gt;数组的主体。（即，这是 &lt;code&gt;PAD_ARRAY(PL_comppad)&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="cd50ccbc12c1ecc8379096a1e5a3ea405480427c" translate="yes" xml:space="preserve">
          <source>Points to note this time are</source>
          <target state="translated">这次要注意的几点是</target>
        </trans-unit>
        <trans-unit id="a1ba2b16bcbd7c4705abb0e0545c7340c416117e" translate="yes" xml:space="preserve">
          <source>Points to note this time:</source>
          <target state="translated">这次要注意的几点。</target>
        </trans-unit>
        <trans-unit id="7f6158e808f6832883a61fff6f7473e7ffa8d937" translate="yes" xml:space="preserve">
          <source>Points to note:</source>
          <target state="translated">需要注意的是:</target>
        </trans-unit>
        <trans-unit id="1bbd752ae8b2d8dd16a7b7697a38f3cb2e507749" translate="yes" xml:space="preserve">
          <source>Points to the current position of lexing inside the lexer buffer. Characters around this point may be freely examined, within the range delimited by &lt;code&gt;SvPVX(&lt;a href=&quot;#PL_parser-%3Elinestr&quot;&gt;&quot;PL_parser-&amp;gt;linestr&quot;&lt;/a&gt;)&lt;/code&gt; and &lt;a href=&quot;#PL_parser-%3Ebufend&quot;&gt;&quot;PL_parser-&amp;gt;bufend&quot;&lt;/a&gt;. The octets of the buffer may be intended to be interpreted as either UTF-8 or Latin-1, as indicated by &lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd6843c94f87c938da300ec96118788e1ddfc762" translate="yes" xml:space="preserve">
          <source>Points to the current position of lexing inside the lexer buffer. Characters around this point may be freely examined, within the range delimited by &lt;code&gt;SvPVX(&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;)&lt;/code&gt; and &lt;a href=&quot;#PL_parser-%3ebufend&quot;&gt;PL_parser-&amp;gt;bufend&lt;/a&gt;. The octets of the buffer may be intended to be interpreted as either UTF-8 or Latin-1, as indicated by &lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt;.</source>
          <target state="translated">指向词法分析器缓冲区内词法化的当前位置。在由 &lt;code&gt;SvPVX(&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;)&lt;/code&gt; 和&lt;a href=&quot;#PL_parser-%3ebufend&quot;&gt;PL_parser-&amp;gt; bufend&lt;/a&gt;分隔的范围内，可以自由检查此点附近的字符。如&lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt;所示，缓冲区的八位位组可以解释为UTF-8或Latin-1 。</target>
        </trans-unit>
        <trans-unit id="1bb0820f4a550e8794d4bb990433e5c6f6edc648" translate="yes" xml:space="preserve">
          <source>Points to the start of the current line inside the lexer buffer. This is useful for indicating at which column an error occurred, and not much else. This must be updated by any lexing code that consumes a newline; the function &lt;a href=&quot;#lex_read_to&quot;&gt;&quot;lex_read_to&quot;&lt;/a&gt; handles this detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="466e9eed69ae31dedb4b4028316ec9e7f9681d76" translate="yes" xml:space="preserve">
          <source>Points to the start of the current line inside the lexer buffer. This is useful for indicating at which column an error occurred, and not much else. This must be updated by any lexing code that consumes a newline; the function &lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt; handles this detail.</source>
          <target state="translated">指向词法分析器缓冲区内当前行的开头。这对于指示错误发生在哪一列以及不多的错误很有用。这必须由使用换行符的所有词法分析代码进行更新；函数&lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt;处理此细节。</target>
        </trans-unit>
        <trans-unit id="6de0b0c656444c55bac48c2e467aa0f841083cdc" translate="yes" xml:space="preserve">
          <source>Poison</source>
          <target state="translated">Poison</target>
        </trans-unit>
        <trans-unit id="60326c7bc618b42717ee02bd88c572c7975b5c05" translate="yes" xml:space="preserve">
          <source>PoisonFree</source>
          <target state="translated">PoisonFree</target>
        </trans-unit>
        <trans-unit id="213cead1d3c3d191853846b8f588306499713f3d" translate="yes" xml:space="preserve">
          <source>PoisonNew</source>
          <target state="translated">PoisonNew</target>
        </trans-unit>
        <trans-unit id="921ff8ca38465c5b1707bafca4e8d140614024bb" translate="yes" xml:space="preserve">
          <source>PoisonWith</source>
          <target state="translated">PoisonWith</target>
        </trans-unit>
        <trans-unit id="7cba271b13a59766b27ccda79d87f5f8e1106365" translate="yes" xml:space="preserve">
          <source>PoisonWith(0xAB) for catching access to allocated but uninitialized memory.</source>
          <target state="translated">PoisonWith(0xAB)用于捕获对已分配但未初始化的内存的访问。</target>
        </trans-unit>
        <trans-unit id="a5b29691b9f8fe361aff7b2c944f86e8960b1c90" translate="yes" xml:space="preserve">
          <source>PoisonWith(0xEF) for catching access to freed memory.</source>
          <target state="translated">PoisonWith(0xEF)用于捕获对释放内存的访问。</target>
        </trans-unit>
        <trans-unit id="50978bfdc443a56d15758e582ae96263dec24405" translate="yes" xml:space="preserve">
          <source>Poking around in the existing &lt;a href=&quot;Date::ICal&quot;&gt;Date::ICal&lt;/a&gt; tests, I found this in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f252f9719bb4092eedbac8a2fb53fbb1039f3c" translate="yes" xml:space="preserve">
          <source>Poking at Perl</source>
          <target state="translated">戳穿Perl</target>
        </trans-unit>
        <trans-unit id="5ff03b7273b1808e5ba852e230991bbf07da703c" translate="yes" xml:space="preserve">
          <source>Poland</source>
          <target state="translated">Poland</target>
        </trans-unit>
        <trans-unit id="1ebd3f7855634092b44032651f78d5bfb891f918" translate="yes" xml:space="preserve">
          <source>Policy on building prerequisites (follow, ask or ignore)?</source>
          <target state="translated">建设先决条件的政策(遵循、询问还是忽略)?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
